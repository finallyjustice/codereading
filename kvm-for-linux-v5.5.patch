From 32f0d39aac7932f54a9aca120702f4242072022e Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Fri, 21 Feb 2020 02:30:34 -0800
Subject: [PATCH 1/1] kvm for linux v5.5

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/kvm/mmu.h                |  6 +++
 arch/x86/kvm/mmu/mmu.c            |  5 +++
 arch/x86/kvm/x86.c                | 13 +++++++
 drivers/vfio/pci/vfio_pci.c       |  9 +++++
 drivers/vfio/pci/vfio_pci_intrs.c | 15 ++++++++
 drivers/vfio/pci/vfio_pci_rdwr.c  |  5 +++
 drivers/vfio/vfio.c               | 64 +++++++++++++++++++++++++++++++
 drivers/vfio/vfio_iommu_type1.c   | 48 +++++++++++++++++++++++
 include/linux/kvm_host.h          |  8 ++++
 9 files changed, 173 insertions(+)

diff --git a/arch/x86/kvm/mmu.h b/arch/x86/kvm/mmu.h
index d55674f44a18..51db11a6e926 100644
--- a/arch/x86/kvm/mmu.h
+++ b/arch/x86/kvm/mmu.h
@@ -73,6 +73,12 @@ static inline unsigned long kvm_mmu_available_pages(struct kvm *kvm)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/vmx/nested.c|5234| <<nested_vmx_eptp_switching>> kvm_mmu_reload(vcpu);
+ *   - arch/x86/kvm/x86.c|8142| <<vcpu_enter_guest>> r = kvm_mmu_reload(vcpu);
+ *   - arch/x86/kvm/x86.c|10009| <<kvm_arch_async_page_ready>> r = kvm_mmu_reload(vcpu);
+ */
 static inline int kvm_mmu_reload(struct kvm_vcpu *vcpu)
 {
 	if (likely(vcpu->arch.mmu->root_hpa != INVALID_PAGE))
diff --git a/arch/x86/kvm/mmu/mmu.c b/arch/x86/kvm/mmu/mmu.c
index 6f92b40d798c..6d0b4d6216a3 100644
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@ -5257,6 +5257,11 @@ void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_mmu_reset_context);
 
+/*
+ * called by:
+ *   - arch/x86/kvm/mmu.h|81| <<kvm_mmu_reload>> return kvm_mmu_load(vcpu);
+ *   - arch/x86/kvm/svm.c|3442| <<nested_svm_vmexit>> kvm_mmu_load(&svm->vcpu);
+ */
 int kvm_mmu_load(struct kvm_vcpu *vcpu)
 {
 	int r;
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index cf917139de6b..bd917d9b0b69 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -8000,6 +8000,13 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 
 	bool req_immediate_exit = false;
 
+	/*
+	 * x86下调用的例子:
+	 *   - arch/x86/kvm/x86.c|8003| <<vcpu_enter_guest>> if (kvm_request_pending(vcpu)) {
+	 *   - arch/x86/kvm/x86.c|8182| <<vcpu_enter_guest>> if (vcpu->mode == EXITING_GUEST_MODE || kvm_request_pending(vcpu)
+	 *
+	 * 返回vcpu->requests (u64)
+	 */
 	if (kvm_request_pending(vcpu)) {
 		if (kvm_check_request(KVM_REQ_GET_VMCS12_PAGES, vcpu)) {
 			if (unlikely(!kvm_x86_ops->get_vmcs12_pages(vcpu))) {
@@ -8139,6 +8146,12 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 		}
 	}
 
+	/*
+	 * called by:
+	 *   - arch/x86/kvm/vmx/nested.c|5234| <<nested_vmx_eptp_switching>> kvm_mmu_reload(vcpu);
+	 *   - arch/x86/kvm/x86.c|8142| <<vcpu_enter_guest>> r = kvm_mmu_reload(vcpu);
+	 *   - arch/x86/kvm/x86.c|10009| <<kvm_arch_async_page_ready>> r = kvm_mmu_reload(vcpu);
+	 */
 	r = kvm_mmu_reload(vcpu);
 	if (unlikely(r)) {
 		goto cancel_injection;
diff --git a/drivers/vfio/pci/vfio_pci.c b/drivers/vfio/pci/vfio_pci.c
index 379a02c36e37..49d419ca3faa 100644
--- a/drivers/vfio/pci/vfio_pci.c
+++ b/drivers/vfio/pci/vfio_pci.c
@@ -1145,6 +1145,11 @@ static long vfio_pci_ioctl(void *device_data,
 	return -ENOTTY;
 }
 
+/*
+ * called by:
+ *   - drivers/vfio/pci/vfio_pci.c|1186| <<vfio_pci_read>> return vfio_pci_rw(device_data, buf, count, ppos, false);
+ *   - drivers/vfio/pci/vfio_pci.c|1195| <<vfio_pci_write>> return vfio_pci_rw(device_data, (char __user *)buf, count, ppos, true);
+ */
 static ssize_t vfio_pci_rw(void *device_data, char __user *buf,
 			   size_t count, loff_t *ppos, bool iswrite)
 {
@@ -1278,6 +1283,10 @@ static void vfio_pci_request(void *device_data, unsigned int count)
 	mutex_unlock(&vdev->igate);
 }
 
+/*
+ * 在以下使用vfio_pci_ops:
+ *   - drivers/vfio/pci/vfio_pci.c|1334| <<vfio_pci_probe>> ret = vfio_add_group_dev(&pdev->dev, &vfio_pci_ops, vdev);
+ */
 static const struct vfio_device_ops vfio_pci_ops = {
 	.name		= "vfio-pci",
 	.open		= vfio_pci_open,
diff --git a/drivers/vfio/pci/vfio_pci_intrs.c b/drivers/vfio/pci/vfio_pci_intrs.c
index 2056f3f85f59..1af35796fb95 100644
--- a/drivers/vfio/pci/vfio_pci_intrs.c
+++ b/drivers/vfio/pci/vfio_pci_intrs.c
@@ -236,6 +236,10 @@ static void vfio_intx_disable(struct vfio_pci_device *vdev)
 /*
  * MSI/MSI-X
  */
+/*
+ * 在以下使用vfio_msihandler:
+ *   - drivers/vfio/pci/vfio_pci_intrs.c|333| <<vfio_msi_set_vector_signal>> ret = request_irq(irq, vfio_msihandler, 0,
+ */
 static irqreturn_t vfio_msihandler(int irq, void *arg)
 {
 	struct eventfd_ctx *trigger = arg;
@@ -281,6 +285,11 @@ static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vfio/pci/vfio_pci_intrs.c|364| <<vfio_msi_set_block>> ret = vfio_msi_set_vector_signal(vdev, j, fd, msix);
+ *   - drivers/vfio/pci/vfio_pci_intrs.c|369| <<vfio_msi_set_block>> vfio_msi_set_vector_signal(vdev, j, -1, msix);
+ */
 static int vfio_msi_set_vector_signal(struct vfio_pci_device *vdev,
 				      int vector, int fd, bool msix)
 {
@@ -351,6 +360,12 @@ static int vfio_msi_set_vector_signal(struct vfio_pci_device *vdev,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vfio/pci/vfio_pci_intrs.c|385| <<vfio_msi_disable>> vfio_msi_set_block(vdev, 0, vdev->num_ctx, NULL, msix);
+ *   - drivers/vfio/pci/vfio_pci_intrs.c|514| <<vfio_pci_set_msi_trigger>> return vfio_msi_set_block(vdev, start, count,
+ *   - drivers/vfio/pci/vfio_pci_intrs.c|521| <<vfio_pci_set_msi_trigger>> ret = vfio_msi_set_block(vdev, start, count, fds, msix);
+ */
 static int vfio_msi_set_block(struct vfio_pci_device *vdev, unsigned start,
 			      unsigned count, int32_t *fds, bool msix)
 {
diff --git a/drivers/vfio/pci/vfio_pci_rdwr.c b/drivers/vfio/pci/vfio_pci_rdwr.c
index 0120d8324a40..bcede782accb 100644
--- a/drivers/vfio/pci/vfio_pci_rdwr.c
+++ b/drivers/vfio/pci/vfio_pci_rdwr.c
@@ -153,6 +153,11 @@ static int vfio_pci_setup_barmap(struct vfio_pci_device *vdev, int bar)
 	return 0;
 }
 
+/*
+ * 处理VFIO_PCI_ROM_REGION_INDEX或者VFIO_PCI_BAR0_REGION_INDEX ... VFIO_PCI_BAR5_REGION_INDEX:
+ *   - drivers/vfio/pci/vfio_pci.c|1164| <<vfio_pci_rw>> return vfio_pci_bar_rw(vdev, buf, count, ppos, false);
+ *   - drivers/vfio/pci/vfio_pci.c|1167| <<vfio_pci_rw>> return vfio_pci_bar_rw(vdev, buf, count, ppos, iswrite);
+ */
 ssize_t vfio_pci_bar_rw(struct vfio_pci_device *vdev, char __user *buf,
 			size_t count, loff_t *ppos, bool iswrite)
 {
diff --git a/drivers/vfio/vfio.c b/drivers/vfio/vfio.c
index c8482624ca34..ed3a4aaa5c9c 100644
--- a/drivers/vfio/vfio.c
+++ b/drivers/vfio/vfio.c
@@ -39,6 +39,15 @@
 
 static struct vfio {
 	struct class			*class;
+	/*
+	 * 在以下使用iommu_drivers_list:
+	 *   - drivers/vfio/vfio.c|235| <<vfio_register_iommu_driver>> list_for_each_entry(tmp, &vfio.iommu_drivers_list, vfio_next) {
+	 *   - drivers/vfio/vfio.c|243| <<vfio_register_iommu_driver>> list_add(&driver->vfio_next, &vfio.iommu_drivers_list);
+	 *   - drivers/vfio/vfio.c|256| <<vfio_unregister_iommu_driver>> list_for_each_entry(driver, &vfio.iommu_drivers_list, vfio_next) {
+	 *   - drivers/vfio/vfio.c|1025| <<vfio_ioctl_check_extension>> list_for_each_entry(driver, &vfio.iommu_drivers_list,
+	 *   - drivers/vfio/vfio.c|1103| <<vfio_ioctl_set_iommu>> list_for_each_entry(driver, &vfio.iommu_drivers_list, vfio_next) {
+	 *   - drivers/vfio/vfio.c|2173| <<vfio_init>> INIT_LIST_HEAD(&vfio.iommu_drivers_list);
+	 */
 	struct list_head		iommu_drivers_list;
 	struct mutex			iommu_drivers_lock;
 	struct list_head		group_list;
@@ -58,6 +67,11 @@ struct vfio_container {
 	struct kref			kref;
 	struct list_head		group_list;
 	struct rw_semaphore		group_lock;
+	/*
+	 * 在以下设置iommu_driver:
+	 *   - drivers/vfio/vfio.c|1144| <<vfio_ioctl_set_iommu>> container->iommu_driver = driver;
+	 *   - drivers/vfio/vfio.c|1308| <<__vfio_group_unset_container>> container->iommu_driver = NULL;
+	 */
 	struct vfio_iommu_driver	*iommu_driver;
 	void				*iommu_data;
 	bool				noiommu;
@@ -74,6 +88,15 @@ struct vfio_group {
 	atomic_t			container_users;
 	struct iommu_group		*iommu_group;
 	struct vfio_container		*container;
+	/*
+	 * 在以下使用device_list:
+	 *   - drivers/vfio/vfio.c|354| <<vfio_create_group>> INIT_LIST_HEAD(&group->device_list);
+	 *   - drivers/vfio/vfio.c|426| <<vfio_group_release>> WARN_ON(!list_empty(&group->device_list));
+	 *   - drivers/vfio/vfio.c|577| <<vfio_group_create_device>> list_add(&device->group_next, &group->device_list);
+	 *   - drivers/vfio/vfio.c|621| <<vfio_group_get_device>> list_for_each_entry(device, &group->device_list, group_next) {
+	 *   - drivers/vfio/vfio.c|901| <<vfio_device_get_from_name>> list_for_each_entry(it, &group->device_list, group_next) {
+	 *   - drivers/vfio/vfio.c|1012| <<vfio_del_group_dev>> if (list_empty(&group->device_list))
+	 */
 	struct list_head		device_list;
 	struct mutex			device_lock;
 	struct device			*dev;
@@ -219,6 +242,12 @@ static const struct vfio_iommu_driver_ops vfio_noiommu_ops = {
 /**
  * IOMMU driver registration
  */
+/*
+ * called by:
+ *   - drivers/vfio/vfio.c|2203| <<vfio_init>> vfio_register_iommu_driver(&vfio_noiommu_ops);
+ *   - drivers/vfio/vfio_iommu_spapr_tce.c|1374| <<tce_iommu_init>> return vfio_register_iommu_driver(&tce_iommu_driver_ops);
+ *   - drivers/vfio/vfio_iommu_type1.c|2345| <<vfio_iommu_type1_init>> return vfio_register_iommu_driver(&vfio_iommu_driver_ops_type1);
+ */
 int vfio_register_iommu_driver(const struct vfio_iommu_driver_ops *ops)
 {
 	struct vfio_iommu_driver *driver, *tmp;
@@ -531,6 +560,10 @@ static struct vfio_group *vfio_group_get_from_dev(struct device *dev)
 /**
  * Device objects - create, release, get, put, search
  */
+/*
+ * called by:
+ *   - drivers/vfio/vfio.c|855| <<vfio_add_group_dev>> device = vfio_group_create_device(group, dev, ops, device_data);
+ */
 static
 struct vfio_device *vfio_group_create_device(struct vfio_group *group,
 					     struct device *dev,
@@ -797,6 +830,12 @@ static int vfio_iommu_group_notifier(struct notifier_block *nb,
 /**
  * VFIO driver API
  */
+/*
+ * called by:
+ *   - drivers/vfio/mdev/vfio_mdev.c|115| <<vfio_mdev_probe>> return vfio_add_group_dev(dev, &vfio_mdev_dev_ops, mdev);
+ *   - drivers/vfio/pci/vfio_pci.c|1334| <<vfio_pci_probe>> ret = vfio_add_group_dev(&pdev->dev, &vfio_pci_ops, vdev);
+ *   - drivers/vfio/platform/vfio_platform_common.c|689| <<vfio_platform_probe_common>> ret = vfio_add_group_dev(dev, &vfio_platform_ops, vdev);
+ */
 int vfio_add_group_dev(struct device *dev,
 		       const struct vfio_device_ops *ops, void *device_data)
 {
@@ -1184,6 +1223,9 @@ static long vfio_fops_unl_ioctl(struct file *filep,
 	return ret;
 }
 
+/*
+ * 核心思想是分配一个struct vfio_container用来设置为这个file的private_data
+ */
 static int vfio_fops_open(struct inode *inode, struct file *filep)
 {
 	struct vfio_container *container;
@@ -1259,6 +1301,15 @@ static int vfio_fops_mmap(struct file *filep, struct vm_area_struct *vma)
 	return ret;
 }
 
+/*
+ * static struct miscdevice vfio_dev = {
+ *	.minor = VFIO_MINOR,
+ *	.name = "vfio",
+ *	.fops = &vfio_fops,
+ *	.nodename = "vfio/vfio",
+ *	.mode = S_IRUGO | S_IWUGO,
+ * };
+ */
 static const struct file_operations vfio_fops = {
 	.owner		= THIS_MODULE,
 	.open		= vfio_fops_open,
@@ -1597,6 +1648,12 @@ static int vfio_group_fops_release(struct inode *inode, struct file *filep)
 	return 0;
 }
 
+/*
+ * 在以下使用vfio_group_fops:
+ *   - drivers/vfio/vfio.c|1710| <<vfio_group_get_external_user>> if (filep->f_op != &vfio_group_fops)
+ *   - drivers/vfio/vfio.c|1735| <<vfio_external_group_match_file>> return (filep->f_op == &vfio_group_fops) && (group == test_group);
+ *   - drivers/vfio/vfio.c|2177| <<vfio_init>> cdev_init(&vfio.group_cdev, &vfio_group_fops);
+ */
 static const struct file_operations vfio_group_fops = {
 	.owner		= THIS_MODULE,
 	.unlocked_ioctl	= vfio_group_fops_unl_ioctl,
@@ -2131,6 +2188,10 @@ EXPORT_SYMBOL(vfio_unregister_notifier);
 /**
  * Module/class support
  */
+/*
+ * 在以下使用vfio_devnode():
+ *   - drivers/vfio/vfio.c|2212| <<vfio_init>> vfio.class->devnode = vfio_devnode;
+ */
 static char *vfio_devnode(struct device *dev, umode_t *mode)
 {
 	return kasprintf(GFP_KERNEL, "vfio/%s", dev_name(dev));
@@ -2148,6 +2209,9 @@ static int __init vfio_init(void)
 {
 	int ret;
 
+	/*
+	 * struct vfio vfio在文件的一开始定义
+	 */
 	idr_init(&vfio.group_idr);
 	mutex_init(&vfio.group_lock);
 	mutex_init(&vfio.iommu_drivers_lock);
diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c
index 2ada8e6cdb88..25101cedb504 100644
--- a/drivers/vfio/vfio_iommu_type1.c
+++ b/drivers/vfio/vfio_iommu_type1.c
@@ -520,6 +520,9 @@ static int vfio_unpin_page_external(struct vfio_dma *dma, dma_addr_t iova,
 	return unlocked;
 }
 
+/*
+ * struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1.pin_pages = vfio_iommu_type1_pin_pages()
+ */
 static int vfio_iommu_type1_pin_pages(void *iommu_data,
 				      unsigned long *user_pfn,
 				      int npage, int prot,
@@ -606,6 +609,9 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,
 	return ret;
 }
 
+/*
+ * struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1.unpin_pages = vfio_iommu_type1_unpin_pages()
+ */
 static int vfio_iommu_type1_unpin_pages(void *iommu_data,
 					unsigned long *user_pfn,
 					int npage)
@@ -964,6 +970,10 @@ static int vfio_dma_do_unmap(struct vfio_iommu *iommu,
 	return ret;
 }
 
+/*
+ * called by:
+ *   - drivers/vfio/vfio_iommu_type1.c|1018| <<vfio_pin_map_dma>> ret = vfio_iommu_map(iommu, iova + dma->size, pfn, npage,
+ */
 static int vfio_iommu_map(struct vfio_iommu *iommu, dma_addr_t iova,
 			  unsigned long pfn, long npage, int prot)
 {
@@ -1418,6 +1428,13 @@ static int vfio_mdev_iommu_device(struct device *dev, void *data)
  * or with any existing dma mappings. The list is also modified to
  * exclude any reserved regions associated with the device group.
  */
+/*
+ * called by:
+ *   - drivers/vfio/vfio_iommu_type1.c|1482| <<vfio_iommu_aper_resize>> return vfio_iommu_iova_insert(iova, start, end);
+ *   - drivers/vfio/vfio_iommu_type1.c|1566| <<vfio_iommu_resv_exclude>> ret = vfio_iommu_iova_insert(&n->list, n->start,
+ *   - drivers/vfio/vfio_iommu_type1.c|1569| <<vfio_iommu_resv_exclude>> ret = vfio_iommu_iova_insert(&n->list, end + 1,
+ *   - drivers/vfio/vfio_iommu_type1.c|1613| <<vfio_iommu_iova_get_copy>> ret = vfio_iommu_iova_insert(iova_copy, n->start, n->end);
+ */
 static int vfio_iommu_iova_insert(struct list_head *head,
 				  dma_addr_t start, dma_addr_t end)
 {
@@ -1631,6 +1648,13 @@ static void vfio_iommu_iova_insert_copy(struct vfio_iommu *iommu,
 
 	list_splice_tail(iova_copy, iova);
 }
+/*
+ * called by:
+ *   - drivers/vfio/vfio.c|1085| <<__vfio_container_attach_groups>> ret = driver->ops->attach_group(data, group->iommu_group);
+ *   - drivers/vfio/vfio.c|1406| <<vfio_group_set_container>> ret = driver->ops->attach_group(container->iommu_data,
+ *
+ * struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1.attach_group = vfio_iommu_type1_attach_group()
+ */
 static int vfio_iommu_type1_attach_group(void *iommu_data,
 					 struct iommu_group *iommu_group)
 {
@@ -1961,6 +1985,9 @@ static int vfio_iommu_resv_refresh(struct vfio_iommu *iommu,
 	return ret;
 }
 
+/*
+ * struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1.detach_group = vfio_iommu_type1_detach_group()
+ */
 static void vfio_iommu_type1_detach_group(void *iommu_data,
 					  struct iommu_group *iommu_group)
 {
@@ -2036,6 +2063,9 @@ static void vfio_iommu_type1_detach_group(void *iommu_data,
 	mutex_unlock(&iommu->lock);
 }
 
+/*
+ * struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1.open = vfio_iommu_type1_open()
+ */
 static void *vfio_iommu_type1_open(unsigned long arg)
 {
 	struct vfio_iommu *iommu;
@@ -2084,6 +2114,9 @@ static void vfio_release_domain(struct vfio_domain *domain, bool external)
 		iommu_domain_free(domain->domain);
 }
 
+/*
+ * struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1.release = vfio_iommu_type1_release()
+ */
 static void vfio_iommu_type1_release(void *iommu_data)
 {
 	struct vfio_iommu *iommu = iommu_data;
@@ -2193,6 +2226,9 @@ static int vfio_iommu_iova_build_caps(struct vfio_iommu *iommu,
 	return ret;
 }
 
+/*
+ * struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1.ioctl = vfio_iommu_type1_ioctl()
+ */
 static long vfio_iommu_type1_ioctl(void *iommu_data,
 				   unsigned int cmd, unsigned long arg)
 {
@@ -2302,6 +2338,9 @@ static long vfio_iommu_type1_ioctl(void *iommu_data,
 	return -ENOTTY;
 }
 
+/*
+ * struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1.register_notifier = vfio_iommu_type1_register_notifier()
+ */
 static int vfio_iommu_type1_register_notifier(void *iommu_data,
 					      unsigned long *events,
 					      struct notifier_block *nb)
@@ -2318,6 +2357,9 @@ static int vfio_iommu_type1_register_notifier(void *iommu_data,
 	return blocking_notifier_chain_register(&iommu->notifier, nb);
 }
 
+/*
+ * struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1.unregister_notifier = vfio_iommu_type1_unregister_notifier()
+ */
 static int vfio_iommu_type1_unregister_notifier(void *iommu_data,
 						struct notifier_block *nb)
 {
@@ -2342,6 +2384,12 @@ static const struct vfio_iommu_driver_ops vfio_iommu_driver_ops_type1 = {
 
 static int __init vfio_iommu_type1_init(void)
 {
+	/*
+	 * called by:
+	 *   - drivers/vfio/vfio.c|2203| <<vfio_init>> vfio_register_iommu_driver(&vfio_noiommu_ops);
+	 *   - drivers/vfio/vfio_iommu_spapr_tce.c|1374| <<tce_iommu_init>> return vfio_register_iommu_driver(&tce_iommu_driver_ops);
+	 *   - drivers/vfio/vfio_iommu_type1.c|2345| <<vfio_iommu_type1_init>> return vfio_register_iommu_driver(&vfio_iommu_driver_ops_type1);
+	 */
 	return vfio_register_iommu_driver(&vfio_iommu_driver_ops_type1);
 }
 
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index 538c25e778c0..667f26b67bf9 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -219,6 +219,8 @@ int kvm_async_pf_wakeup_all(struct kvm_vcpu *vcpu);
 
 enum {
 	OUTSIDE_GUEST_MODE,
+	/*
+	 */
 	IN_GUEST_MODE,
 	EXITING_GUEST_MODE,
 	READING_SHADOW_PAGE_TABLES,
@@ -1221,8 +1223,14 @@ static inline void kvm_make_request(int req, struct kvm_vcpu *vcpu)
 	set_bit(req & KVM_REQUEST_MASK, (void *)&vcpu->requests);
 }
 
+/*
+ * x86下调用的例子:
+ *   - arch/x86/kvm/x86.c|8003| <<vcpu_enter_guest>> if (kvm_request_pending(vcpu)) {
+ *   - arch/x86/kvm/x86.c|8182| <<vcpu_enter_guest>> if (vcpu->mode == EXITING_GUEST_MODE || kvm_request_pending(vcpu)
+ */
 static inline bool kvm_request_pending(struct kvm_vcpu *vcpu)
 {
+	/* u64 requests */
 	return READ_ONCE(vcpu->requests);
 }
 
-- 
2.17.1

