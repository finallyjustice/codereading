From 565eadf5c1e20e209652d02d0c633c8c6944e12a Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 13 Sep 2023 00:27:10 -0700
Subject: [PATCH 1/1] qemu for v8.1.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 block/block-backend.c          | 21 ++++++++
 block/monitor/block-hmp-cmds.c | 90 ++++++++++++++++++++++++++++++++++
 block/qapi.c                   | 25 ++++++++++
 hw/vfio/common.c               |  4 ++
 migration/migration-stats.c    | 32 ++++++++++++
 migration/migration.c          | 32 ++++++++++++
 migration/migration.h          | 10 ++++
 softmmu/balloon.c              |  4 ++
 softmmu/dma-helpers.c          |  9 ++++
 target/arm/kvm64.c             |  4 ++
 10 files changed, 231 insertions(+)

diff --git a/block/block-backend.c b/block/block-backend.c
index 4009ed5fe..1e153a46b 100644
--- a/block/block-backend.c
+++ b/block/block-backend.c
@@ -110,6 +110,14 @@ static const AIOCBInfo block_backend_aiocb_info = {
 static void drive_info_del(DriveInfo *dinfo);
 static BlockBackend *bdrv_first_blk(BlockDriverState *bs);
 
+/*
+ * 在以下block_backends:
+ *   - block/block-backend.c|114| <<QTAILQ_HEAD>> static QTAILQ_HEAD(, BlockBackend) block_backends = QTAILQ_HEAD_INITIALIZER(block_backends);
+ *   - block/block-backend.c|115| <<QTAILQ_HEAD>> QTAILQ_HEAD_INITIALIZER(block_backends);
+ *   - block/block-backend.c|378| <<blk_new>> QTAILQ_INSERT_TAIL(&block_backends, blk, link);
+ *   - block/block-backend.c|507| <<blk_delete>> QTAILQ_REMOVE(&block_backends, blk, link);
+ *   - block/block-backend.c|569| <<blk_all_next>> : QTAILQ_FIRST(&block_backends);
+ */
 /* All BlockBackends. Protected by BQL. */
 static QTAILQ_HEAD(, BlockBackend) block_backends =
     QTAILQ_HEAD_INITIALIZER(block_backends);
@@ -565,6 +573,14 @@ void blk_unref(BlockBackend *blk)
 BlockBackend *blk_all_next(BlockBackend *blk)
 {
     GLOBAL_STATE_CODE();
+    /*
+     * 在以下block_backends:
+     *   - block/block-backend.c|114| <<QTAILQ_HEAD>> static QTAILQ_HEAD(, BlockBackend) block_backends = QTAILQ_HEAD_INITIALIZER(block_backends);
+     *   - block/block-backend.c|115| <<QTAILQ_HEAD>> QTAILQ_HEAD_INITIALIZER(block_backends);
+     *   - block/block-backend.c|378| <<blk_new>> QTAILQ_INSERT_TAIL(&block_backends, blk, link);
+     *   - block/block-backend.c|507| <<blk_delete>> QTAILQ_REMOVE(&block_backends, blk, link);
+     *   - block/block-backend.c|569| <<blk_all_next>> : QTAILQ_FIRST(&block_backends);
+     */
     return blk ? QTAILQ_NEXT(blk, link)
                : QTAILQ_FIRST(&block_backends);
 }
@@ -776,6 +792,11 @@ BlockBackend *blk_by_name(const char *name)
 BlockDriverState *blk_bs(BlockBackend *blk)
 {
     IO_CODE();
+    /*
+     * BlockBackend *blk:
+     * -> BdrvChild *root;
+     *    -> BlockDriverState *bs;
+     */
     return blk->root ? blk->root->bs : NULL;
 }
 
diff --git a/block/monitor/block-hmp-cmds.c b/block/monitor/block-hmp-cmds.c
index ca2599de4..513c98b71 100644
--- a/block/monitor/block-hmp-cmds.c
+++ b/block/monitor/block-hmp-cmds.c
@@ -624,6 +624,23 @@ fail:
     hmp_handle_error(mon, err);
 }
 
+/*
+ * (qemu) info block
+ * ide0-hd0 (#block199): ol7.qcow2 (qcow2)
+ *     Attached to:      /machine/unattached/device[21]
+ *     Cache mode:       writeback
+ *
+ * sd0: [not inserted]
+ *     Removable device: not locked, tray closed
+ *
+ * drive01: test01.qcow2 (qcow2)
+ *     Attached to:      /machine/peripheral-anon/device[0]
+ *     Cache mode:       writeback, direct
+ *
+ * drive02: test02.qcow2 (qcow2)
+ *     Attached to:      /machine/peripheral-anon/device[1]
+ *     Cache mode:       writeback, direct
+ */
 static void print_block_info(Monitor *mon, BlockInfo *info,
                              BlockDeviceInfo *inserted, bool verbose)
 {
@@ -738,6 +755,36 @@ static void print_block_info(Monitor *mon, BlockInfo *info,
     }
 }
 
+/*
+ * # @BlockInfo:
+ * #
+ * # Block device information.  This structure describes a virtual device
+ * # and the backing device associated with it.
+ * #
+ * # @device: The device name associated with the virtual device.
+ * #
+ * # @qdev: The qdev ID, or if no ID is assigned, the QOM path of the
+ * #     block device.  (since 2.10)
+ * #
+ * # @type: This field is returned only for compatibility reasons, it
+ * #     should not be used (always returns 'unknown')
+ * #
+ * # @removable: True if the device supports removable media.
+ * #
+ * # @locked: True if the guest has locked this device from having its
+ * #     media removed
+ * #
+ * # @tray_open: True if the device's tray is open (only present if it
+ * #     has a tray)
+ * #
+ * # @io-status: @BlockDeviceIoStatus.  Only present if the device
+ * #     supports it and the VM is configured to stop on errors
+ * #     (supported device models: virtio-blk, IDE, SCSI except
+ * #     scsi-generic)
+ * #
+ * # @inserted: @BlockDeviceInfo describing the device if media is
+ * #     present
+ */
 void hmp_info_block(Monitor *mon, const QDict *qdict)
 {
     BlockInfoList *block_list, *info;
@@ -754,6 +801,9 @@ void hmp_info_block(Monitor *mon, const QDict *qdict)
         block_list = NULL;
     }
 
+    /*
+     * BlockInfoList *block_list, *info;
+     */
     for (info = block_list; info; info = info->next) {
         if (device && strcmp(device, info->value->device)) {
             continue;
@@ -791,6 +841,46 @@ void hmp_info_block(Monitor *mon, const QDict *qdict)
     qapi_free_BlockDeviceInfoList(blockdev_list);
 }
 
+/*
+ * # @BlockStats:
+ * #
+ * # Statistics of a virtual block device or a block backing device.
+ * #
+ * # @device: If the stats are for a virtual block device, the name
+ * #     corresponding to the virtual block device.
+ * #
+ * # @node-name: The node name of the device.  (Since 2.3)
+ * #
+ * # @qdev: The qdev ID, or if no ID is assigned, the QOM path of the
+ * #     block device.  (since 3.0)
+ * #
+ * # @stats: A @BlockDeviceStats for the device.
+ * #
+ * # @driver-specific: Optional driver-specific stats.  (Since 4.2)
+ * #
+ * # @parent: This describes the file block device if it has one.
+ * #     Contains recursively the statistics of the underlying protocol
+ * #     (e.g. the host file for a qcow2 image).  If there is no
+ * #     underlying protocol, this field is omitted
+ * #
+ * # @backing: This describes the backing block device if it has one.
+ * #     (Since 2.0)
+ *
+ *
+ * # @query-blockstats:
+ * #
+ * # Query the @BlockStats for all virtual block devices.
+ * #
+ * # @query-nodes: If true, the command will query all the block nodes
+ * #     that have a node name, in a list which will include "parent"
+ * #     information, but not "backing". If false or omitted, the
+ * #     behavior is as before - query all the device backends,
+ * #     recursively including their "parent" and "backing". Filter nodes
+ * #     that were created implicitly are skipped over in this mode.
+ * #     (Since 2.3)
+ * #
+ * # Returns: A list of @BlockStats for each virtual block devices.
+ */
 void hmp_info_blockstats(Monitor *mon, const QDict *qdict)
 {
     BlockStatsList *stats_list, *stats;
diff --git a/block/qapi.c b/block/qapi.c
index f34f95e0e..c18ef612c 100644
--- a/block/qapi.c
+++ b/block/qapi.c
@@ -723,6 +723,31 @@ BlockInfoList *qmp_query_block(Error **errp)
     return head;
 }
 
+/*
+ * # @BlockStats:
+ * #
+ * # Statistics of a virtual block device or a block backing device.
+ * #
+ * # @device: If the stats are for a virtual block device, the name
+ * #     corresponding to the virtual block device.
+ * #
+ * # @node-name: The node name of the device.  (Since 2.3)
+ * #
+ * # @qdev: The qdev ID, or if no ID is assigned, the QOM path of the
+ * #     block device.  (since 3.0)
+ * #
+ * # @stats: A @BlockDeviceStats for the device.
+ * #
+ * # @driver-specific: Optional driver-specific stats.  (Since 4.2)
+ * #
+ * # @parent: This describes the file block device if it has one.
+ * #     Contains recursively the statistics of the underlying protocol
+ * #     (e.g. the host file for a qcow2 image).  If there is no
+ * #     underlying protocol, this field is omitted
+ * #
+ * # @backing: This describes the backing block device if it has one.
+ * #     (Since 2.0)
+ */
 BlockStatsList *qmp_query_blockstats(bool has_query_nodes,
                                      bool query_nodes,
                                      Error **errp)
diff --git a/hw/vfio/common.c b/hw/vfio/common.c
index 9aac21abb..bab853252 100644
--- a/hw/vfio/common.c
+++ b/hw/vfio/common.c
@@ -1542,6 +1542,10 @@ static void vfio_device_feature_dma_logging_start_destroy(
     g_free(feature);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1593| <<vfio_listener_log_global_start>> ret = vfio_devices_dma_logging_start(container);
+ */
 static int vfio_devices_dma_logging_start(VFIOContainer *container)
 {
     struct vfio_device_feature *feature;
diff --git a/migration/migration-stats.c b/migration/migration-stats.c
index 095d6d75b..b1c94341b 100644
--- a/migration/migration-stats.c
+++ b/migration/migration-stats.c
@@ -18,15 +18,43 @@
 
 MigrationAtomicStats mig_stats;
 
+/*
+ * (gdb) bt
+ * #0  migration_rate_exceeded (f=f@entry=0x55718cc4c630) at ../migration/migration-stats.c:23
+ * #1  0x000055718a2e6546 in ram_save_iterate (f=0x55718cc4c630, opaque=<optimized out>) at ../migration/ram.c:3133
+ * #2  0x000055718a190939 in qemu_savevm_state_iterate (f=0x55718cc4c630, postcopy=postcopy@entry=false) at ../migration/savevm.c:1348
+ * #3  0x000055718a180fb1 in migration_iteration_run (s=0x55718c6d51c0) at ../migration/migration.c:2785
+ * #4  migration_thread (opaque=opaque@entry=0x55718c6d51c0) at ../migration/migration.c:3017
+ * #5  0x000055718a4b40d9 in qemu_thread_start (args=0x7f680ad0e8d0) at ../util/qemu-thread-posix.c:541
+ * #6  0x00007f69c3936ea5 in start_thread () at /lib64/libpthread.so.0
+ * #7  0x00007f69c365f9fd in clone () at /lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/ppc/spapr.c|2175| <<htab_save_first_pass>> } while ((index < htabslots) && !migration_rate_exceeded(f));
+ *   - hw/ppc/spapr.c|2246| <<htab_save_later_pass>> } while ((examined < htabslots) && (!migration_rate_exceeded(f) || final));
+ *   - hw/s390x/s390-stattrib.c|212| <<cmma_save>> while (final ? 1 : migration_rate_exceeded(f) == 0) {
+ *   - migration/block-dirty-bitmap.c|709| <<bulk_phase>> if (limit && migration_rate_exceeded(f)) {
+ *   - migration/block.c|629| <<flush_blks>> if (migration_rate_exceeded(f)) {
+ *   - migration/migration.c|2894| <<migration_rate_limit>> if (migration_rate_exceeded(s->to_dst_file)) {
+ *   - migration/migration.c|3016| <<migration_thread>> if (urgent || !migration_rate_exceeded(s->to_dst_file)) {
+ *   - migration/ram.c|3133| <<ram_save_iterate>> while ((ret = migration_rate_exceeded(f)) == 0 ||
+ *   - migration/savevm.c|1341| <<qemu_savevm_state_iterate>> if (migration_rate_exceeded(f)) {
+ */
 bool migration_rate_exceeded(QEMUFile *f)
 {
     if (qemu_file_get_error(f)) {
         return true;
     }
 
+    /*
+     * Amount of transferred data at the start of current cycle.
+     */
     uint64_t rate_limit_start = stat64_get(&mig_stats.rate_limit_start);
     uint64_t rate_limit_current = migration_transferred_bytes(f);
     uint64_t rate_limit_used = rate_limit_current - rate_limit_start;
+    /*
+     * Maximum amount of data we can send in a cycle.
+     */
     uint64_t rate_limit_max = stat64_get(&mig_stats.rate_limit_max);
 
     if (rate_limit_max == RATE_LIMIT_DISABLED) {
@@ -53,6 +81,10 @@ void migration_rate_set(uint64_t limit)
     stat64_set(&mig_stats.rate_limit_max, limit / XFER_LIMIT_RATIO);
 }
 
+/*
+ * called by:
+ *   - migration/migration.c|2717| <<migration_update_counters>> migration_rate_reset(s->to_dst_file);
+ */
 void migration_rate_reset(QEMUFile *f)
 {
     stat64_set(&mig_stats.rate_limit_start, migration_transferred_bytes(f));
diff --git a/migration/migration.c b/migration/migration.c
index 5528acb65..5656b73de 100644
--- a/migration/migration.c
+++ b/migration/migration.c
@@ -2307,6 +2307,10 @@ static int migration_maybe_pause(MigrationState *s,
  *
  * @s: Current migration state
  */
+/*
+ * called by:
+ *   - migration/migration.c|2775| <<migration_iteration_run>> migration_completion(s);
+ */
 static void migration_completion(MigrationState *s)
 {
     int ret;
@@ -2679,6 +2683,11 @@ static void update_iteration_initial_status(MigrationState *s)
     s->iteration_initial_pages = ram_get_total_transferred_pages();
 }
 
+/*
+ * called by:
+ *   - migration/migration.c|2893| <<migration_rate_limit>> migration_update_counters(s, now);
+ *   - migration/migration.c|3191| <<bg_migration_thread>> migration_update_counters(s, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));
+ */
 static void migration_update_counters(MigrationState *s,
                                       int64_t current_time)
 {
@@ -2747,6 +2756,14 @@ typedef enum {
  * Return true if continue to the next iteration directly, false
  * otherwise.
  */
+/*
+ * (gdb) bt
+ * #0  migration_iteration_run (s=s@entry=0x55e44417c1c0) at ../migration/migration.c:2751
+ * #1  0x000055e4428a7ef7 in migration_thread (opaque=opaque@entry=0x55e44417c1c0) at ../migration/migration.c:3022
+ * #2  0x000055e442bda0e9 in qemu_thread_start (args=0x7f362623c8d0) at ../util/qemu-thread-posix.c:541
+ * #3  0x00007f362c9e3ea5 in start_thread () at /lib64/libpthread.so.0
+ * #4  0x00007f362c70c9fd in clone () at /lib64/libc.so.6
+ */
 static MigIterateState migration_iteration_run(MigrationState *s)
 {
     uint64_t must_precopy, can_postcopy;
@@ -2765,6 +2782,16 @@ static MigIterateState migration_iteration_run(MigrationState *s)
         trace_migrate_pending_exact(pending_size, must_precopy, can_postcopy);
     }
 
+    /*
+     * 在以下使用MigrationState->threshold_size:
+     *   - migration/migration.c|1426| <<migrate_init>> s->threshold_size = 0;
+     *   - migration/migration.c|2702| <<migration_update_counters>> s->threshold_size = bandwidth * migrate_downtime_limit();
+     *   - migration/migration.c|2727| <<migration_update_counters>> bandwidth, s->threshold_size);
+     *   - migration/migration.c|2767| <<migration_iteration_run>> if (must_precopy <= s->threshold_size) {
+     *   - migration/migration.c|2773| <<migration_iteration_run>> if ((!pending_size || pending_size < s->threshold_size) && can_switchover) {
+     *   - migration/migration.c|2780| <<migration_iteration_run>> if (!in_postcopy && must_precopy <= s->threshold_size && can_switchover &&
+     *   - migration/ram.c|3302| <<ram_state_pending_exact>> if (!migration_in_postcopy() && remaining_size < s->threshold_size) {
+     */
     if ((!pending_size || pending_size < s->threshold_size) && can_switchover) {
         trace_migration_thread_low_pending(pending_size);
         migration_completion(s);
@@ -2883,6 +2910,11 @@ void migration_consume_urgent_request(void)
     qemu_sem_wait(&migrate_get_current()->rate_limit_sem);
 }
 
+/*
+ * called by:
+ *   - migration/migration.c|3042| <<migration_thread>> urgent = migration_rate_limit();
+ *   - migration/ram.c|2333| <<ram_save_host_page>> migration_rate_limit();
+ */
 /* Returns true if the rate limiting was broken by an urgent request */
 bool migration_rate_limit(void)
 {
diff --git a/migration/migration.h b/migration/migration.h
index 6eea18db3..c289bcd8f 100644
--- a/migration/migration.h
+++ b/migration/migration.h
@@ -285,6 +285,16 @@ struct MigrationState {
      * this threshold; it's calculated from the requested downtime and
      * measured bandwidth
      */
+    /*
+     * 在以下使用MigrationState->threshold_size:
+     *   - migration/migration.c|1426| <<migrate_init>> s->threshold_size = 0;
+     *   - migration/migration.c|2702| <<migration_update_counters>> s->threshold_size = bandwidth * migrate_downtime_limit();
+     *   - migration/migration.c|2727| <<migration_update_counters>> bandwidth, s->threshold_size);
+     *   - migration/migration.c|2767| <<migration_iteration_run>> if (must_precopy <= s->threshold_size) {
+     *   - migration/migration.c|2773| <<migration_iteration_run>> if ((!pending_size || pending_size < s->threshold_size) && can_switchover) {
+     *   - migration/migration.c|2780| <<migration_iteration_run>> if (!in_postcopy && must_precopy <= s->threshold_size && can_switchover &&
+     *   - migration/ram.c|3302| <<ram_state_pending_exact>> if (!migration_in_postcopy() && remaining_size < s->threshold_size) {
+     */
     int64_t threshold_size;
 
     /* params from 'migrate-set-parameters' */
diff --git a/softmmu/balloon.c b/softmmu/balloon.c
index e0e8969a4..b889ef84b 100644
--- a/softmmu/balloon.c
+++ b/softmmu/balloon.c
@@ -52,6 +52,10 @@ static bool have_balloon(Error **errp)
     return true;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-balloon.c|863| <<virtio_balloon_device_realize>> ret = qemu_add_balloon_handler(virtio_balloon_to_target, virtio_balloon_stat, s);
+ */
 int qemu_add_balloon_handler(QEMUBalloonEvent *event_func,
                              QEMUBalloonStatus *stat_func, void *opaque)
 {
diff --git a/softmmu/dma-helpers.c b/softmmu/dma-helpers.c
index 246396480..370819362 100644
--- a/softmmu/dma-helpers.c
+++ b/softmmu/dma-helpers.c
@@ -219,6 +219,15 @@ static const AIOCBInfo dma_aiocb_info = {
     .get_aio_context    = dma_get_aio_context,
 };
 
+/*
+ * called by:
+ *   - hw/ide/core.c|959| <<ide_dma_cb>> s->bus->dma->aiocb = dma_blk_io(blk_get_aio_context(s->blk),
+ *   - hw/ide/macio.c|193| <<pmac_ide_transfer_cb>> s->bus->dma->aiocb = dma_blk_io(blk_get_aio_context(s->blk), &s->sg,
+ *   - hw/scsi/scsi-disk.c|429| <<scsi_do_read>> r->req.aiocb = dma_blk_io(blk_get_aio_context(s->qdev.conf.blk),
+ *   - hw/scsi/scsi-disk.c|591| <<scsi_write_data>> r->req.aiocb = dma_blk_io(blk_get_aio_context(s->qdev.conf.blk),
+ *   - softmmu/dma-helpers.c|262| <<dma_blk_read>> return dma_blk_io(blk_get_aio_context(blk), sg, offset, align,
+ *   - softmmu/dma-helpers.c|280| <<dma_blk_write>> return dma_blk_io(blk_get_aio_context(blk), sg, offset, align,
+ */
 BlockAIOCB *dma_blk_io(AioContext *ctx,
     QEMUSGList *sg, uint64_t offset, uint32_t align,
     DMAIOFunc *io_func, void *io_func_opaque,
diff --git a/target/arm/kvm64.c b/target/arm/kvm64.c
index 94bbd9661..91f676373 100644
--- a/target/arm/kvm64.c
+++ b/target/arm/kvm64.c
@@ -1007,6 +1007,10 @@ static int kvm_arch_get_sve(CPUState *cs)
     return 0;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2851| <<do_kvm_cpu_synchronize_state>> kvm_arch_get_registers(cpu);
+ */
 int kvm_arch_get_registers(CPUState *cs)
 {
     struct kvm_one_reg reg;
-- 
2.34.1

