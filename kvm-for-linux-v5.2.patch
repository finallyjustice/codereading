From d410038b435831089ae1b07ba7838df5b8563421 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 26 Aug 2019 01:14:33 +0800
Subject: [PATCH 1/1] kvm for linux v5.2

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/kvm/lapic.c | 60 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 arch/x86/kvm/lapic.h |  6 ++++++
 2 files changed, 66 insertions(+)

diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 4dabc31..1a4c39e 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -41,6 +41,18 @@
 #include "cpuid.h"
 #include "hyperv.h"
 
+/* IRR: 功能和PIC的类似,代表LAPIC已接收中断m但还未交CPU处理.
+ * ISR: 功能和PIC类似,代表CPU已开始处理中断,但还未完成.
+ *
+ * The IRR specifies which interrupts are pending acknowledgement, and is
+ * typically a symbolic register which can not be directly accessed. The IRR
+ * tells us which interrupts have been raised.
+ *
+ * The ISR register specifies which interrupts have been acknowledged, but are
+ * still waiting for an End Of Interrupt (EOI). The ISR tells us which
+ * interrupts are being serviced, meaning IRQs sent to the CPU.
+ */
+
 #ifndef CONFIG_X86_64
 #define mod_64(x, y) ((x) - (y) * div64_u64(x, y))
 #else
@@ -72,11 +84,24 @@
 /* step-by-step approximation to mitigate fluctuation */
 #define LAPIC_TIMER_ADVANCE_ADJUST_STEP 8
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|84| <<kvm_apic_pending_eoi>> return apic_test_vector(vector, apic->regs + APIC_ISR) ||
+ *   - arch/x86/kvm/lapic.c|85| <<kvm_apic_pending_eoi>> apic_test_vector(vector, apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.c|1054| <<__apic_accept_irq>> if (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {
+ *   - arch/x86/kvm/lapic.c|1159| <<kvm_ioapic_send_eoi>> if (apic_test_vector(vector, apic->regs + APIC_TMR))
+ *   - arch/x86/kvm/lapic.c|1476| <<lapic_timer_int_injected>> if (apic_test_vector(vec, bitmap))
+ */
 static inline int apic_test_vector(int vec, void *bitmap)
 {
 	return test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/ioapic.c|120| <<__rtc_irq_eoi_tracking_restore_one>> new_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);
+ *   - arch/x86/kvm/ioapic.c|260| <<kvm_ioapic_scan_entry>> kvm_apic_pending_eoi(vcpu, e->fields.vector))
+ */
 bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
@@ -85,16 +110,30 @@ bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)
 		apic_test_vector(vector, apic->regs + APIC_IRR);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|446| <<apic_clear_irr>> apic_clear_vector(vec, apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.c|451| <<apic_clear_irr>> apic_clear_vector(vec, apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.c|1058| <<__apic_accept_irq>> apic_clear_vector(vector, apic->regs + APIC_TMR);
+ */
 static inline void apic_clear_vector(int vec, void *bitmap)
 {
 	clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|461| <<apic_set_isr>> if (__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))
+ */
 static inline int __apic_test_and_set_vector(int vec, void *bitmap)
 {
 	return __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|507| <<apic_clear_isr>> if (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))
+ */
 static inline int __apic_test_and_clear_vector(int vec, void *bitmap)
 {
 	return __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
@@ -346,6 +385,11 @@ static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {
 	LVT_MASK		/* LVTERR */
 };
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|418| <<apic_search_irr>> return find_highest_vector(apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.c|498| <<apic_find_highest_isr>> result = find_highest_vector(apic->regs + APIC_ISR);
+ */
 static int find_highest_vector(void *bitmap)
 {
 	int vec;
@@ -454,6 +498,10 @@ static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)
 	}
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|2461| <<kvm_get_apic_interrupt>> apic_set_isr(vector, apic);
+ */
 static inline void apic_set_isr(int vec, struct kvm_lapic *apic)
 {
 	struct kvm_vcpu *vcpu;
@@ -2266,6 +2314,10 @@ void kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)
 		kvm_apic_local_deliver(apic, APIC_LVT0);
 }
 
+/*
+ * used by:
+ *   - arch/x86/kvm/lapic.c|2328| <<kvm_create_lapic>> kvm_iodevice_init(&apic->dev, &apic_mmio_ops);
+ */
 static const struct kvm_io_device_ops apic_mmio_ops = {
 	.read     = apic_mmio_read,
 	.write    = apic_mmio_write,
@@ -2286,6 +2338,10 @@ static enum hrtimer_restart apic_timer_fn(struct hrtimer *data)
 		return HRTIMER_NORESTART;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|9154| <<kvm_arch_vcpu_init>> r = kvm_create_lapic(vcpu, lapic_timer_advance_ns);
+ */
 int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)
 {
 	struct kvm_lapic *apic;
@@ -2580,6 +2636,10 @@ static void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,
 	pv_eoi_set_pending(apic->vcpu);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|7892| <<vcpu_enter_guest>> kvm_lapic_sync_to_vapic(vcpu);
+ */
 void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)
 {
 	u32 data, tpr;
diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h
index d6d049b..6455db0 100644
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@ -57,6 +57,12 @@ struct kvm_lapic {
 	 */
 	void *regs;
 	gpa_t vapic_addr;
+	/*
+	 * vapic_cache在以下使用:
+	 *   - arch/x86/kvm/lapic.c|2602| <<kvm_lapic_sync_from_vapic>> if (kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,
+	 *   - arch/x86/kvm/lapic.c|2655| <<kvm_lapic_sync_to_vapic>> kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,
+	 *   - arch/x86/kvm/lapic.c|2663| <<kvm_lapic_set_vapic_addr>> &vcpu->arch.apic->vapic_cache,
+	 */
 	struct gfn_to_hva_cache vapic_cache;
 	unsigned long pending_events;
 	unsigned int sipi_vector;
-- 
2.7.4

