From d0041a97cd0a6758b578e43aea82e6c45d12821f Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 10 Jun 2020 00:11:55 -0700
Subject: [PATCH 1/1] io_uring comment for linux-5.7

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 fs/io_uring.c | 181 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 181 insertions(+)

diff --git a/fs/io_uring.c b/fs/io_uring.c
index bb25e3997d41..39accf580c63 100644
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@ -869,6 +869,10 @@ static struct kmem_cache *req_cachep;
 
 static const struct file_operations io_uring_fops;
 
+/*
+ * called by:
+ *   - net/unix/scm.c|38| <<unix_get_socket>> u_sock = io_uring_get_socket(filp);
+ */
 struct sock *io_uring_get_socket(struct file *file)
 {
 #if defined(CONFIG_UNIX)
@@ -5637,6 +5641,10 @@ static inline void io_queue_link_head(struct io_kiocb *req)
 		io_queue_sqe(req, NULL);
 }
 
+/*
+ * called by:
+ *   - fs/io_uring.c|5905| <<io_submit_sqes>> err = io_submit_sqe(req, sqe, statep, &link);
+ */
 static int io_submit_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe,
 			  struct io_submit_state *state, struct io_kiocb **link)
 {
@@ -5780,6 +5788,10 @@ static inline void io_consume_sqe(struct io_ring_ctx *ctx)
 				IOSQE_IO_HARDLINK | IOSQE_ASYNC | \
 				IOSQE_BUFFER_SELECT)
 
+/*
+ * called by:
+ *   - fs/io_uring.c|5899| <<io_submit_sqes>> err = io_init_req(ctx, req, sqe, statep, async);
+ */
 static int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb *req,
 		       const struct io_uring_sqe *sqe,
 		       struct io_submit_state *state, bool async)
@@ -5843,6 +5855,11 @@ static int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb *req,
 	return io_req_set_file(state, req, READ_ONCE(sqe->fd));
 }
 
+/*
+ * called by:
+ *   - fs/io_uring.c|6052| <<io_sq_thread>> ret = io_submit_sqes(ctx, to_submit, NULL, -1, true);
+ *   - fs/io_uring.c|7555| <<SYSCALL_DEFINE6(io_uring_enter)>> submitted = io_submit_sqes(ctx, to_submit, f.file, fd, false);
+ */
 static int io_submit_sqes(struct io_ring_ctx *ctx, unsigned int nr,
 			  struct file *ring_file, int ring_fd, bool async)
 {
@@ -6184,6 +6201,13 @@ static void io_file_ref_kill(struct percpu_ref *ref)
 	complete(&data->done);
 }
 
+/*
+ * called by:
+ *   - fs/io_uring.c|6625| <<io_sqe_files_register>> io_sqe_files_unregister(ctx);
+ *   - fs/io_uring.c|6631| <<io_sqe_files_register>> io_sqe_files_unregister(ctx);
+ *   - fs/io_uring.c|7253| <<io_ring_ctx_free>> io_sqe_files_unregister(ctx);
+ *   - fs/io_uring.c|8123| <<__io_uring_register(处理IORING_UNREGISTER_FILES)>> ret = io_sqe_files_unregister(ctx);
+ */
 static int io_sqe_files_unregister(struct io_ring_ctx *ctx)
 {
 	struct fixed_file_data *data = ctx->file_data;
@@ -6499,6 +6523,10 @@ static void destroy_fixed_file_ref_node(struct fixed_file_ref_node *ref_node)
 	kfree(ref_node);
 }
 
+/*
+ * 处理IORING_REGISTER_FILES:
+ *   - fs/io_uring.c|8117| <<__io_uring_register>> ret = io_sqe_files_register(ctx, arg, nr_args);
+ */
 static int io_sqe_files_register(struct io_ring_ctx *ctx, void __user *arg,
 				 unsigned nr_args)
 {
@@ -6770,6 +6798,10 @@ static int __io_sqe_files_update(struct io_ring_ctx *ctx,
 	return done ? done : err;
 }
 
+/*
+ * 处理IORING_REGISTER_FILES_UPDATE:
+ *   - fs/io_uring.c|8143| <<__io_uring_register>> ret = io_sqe_files_update(ctx, arg, nr_args);
+ */
 static int io_sqe_files_update(struct io_ring_ctx *ctx, void __user *arg,
 			       unsigned nr_args)
 {
@@ -6982,6 +7014,12 @@ static unsigned long ring_pages(unsigned sq_entries, unsigned cq_entries)
 	return pages;
 }
 
+/*
+ * called by:
+ *   - fs/io_uring.c|7194| <<io_sqe_buffer_register>> io_sqe_buffer_unregister(ctx);
+ *   - fs/io_uring.c|7252| <<io_ring_ctx_free>> io_sqe_buffer_unregister(ctx);
+ *   - fs/io_uring.c|8114| <<__io_uring_register(处理IORING_UNREGISTER_BUFFERS)>> ret = io_sqe_buffer_unregister(ctx);
+ */
 static int io_sqe_buffer_unregister(struct io_ring_ctx *ctx)
 {
 	int i, j;
@@ -7032,6 +7070,10 @@ static int io_copy_iov(struct io_ring_ctx *ctx, struct iovec *dst,
 	return 0;
 }
 
+/*
+ * 处理IORING_REGISTER_BUFFERS:
+ *   - fs/io_uring.c|8079| <<__io_uring_register>> ret = io_sqe_buffer_register(ctx, arg, nr_args);
+ */
 static int io_sqe_buffer_register(struct io_ring_ctx *ctx, void __user *arg,
 				  unsigned nr_args)
 {
@@ -7174,6 +7216,10 @@ static int io_sqe_buffer_register(struct io_ring_ctx *ctx, void __user *arg,
 	return ret;
 }
 
+/*
+ * 处理IORING_REGISTER_EVENTFD或者IORING_REGISTER_EVENTFD_ASYNC:
+ *   - fs/io_uring.c|8150| <<__io_uring_register>> ret = io_eventfd_register(ctx, arg);
+ */
 static int io_eventfd_register(struct io_ring_ctx *ctx, void __user *arg)
 {
 	__s32 __user *fds = arg;
@@ -7195,6 +7241,11 @@ static int io_eventfd_register(struct io_ring_ctx *ctx, void __user *arg)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - fs/io_uring.c|7271| <<io_ring_ctx_free>> io_eventfd_unregister(ctx);
+ *   - fs/io_uring.c|8162| <<__io_uring_register(处理IORING_UNREGISTER_EVENTFD)>> ret = io_eventfd_unregister(ctx);
+ */
 static int io_eventfd_unregister(struct io_ring_ctx *ctx)
 {
 	if (ctx->cq_ev_fd) {
@@ -7306,6 +7357,11 @@ static void io_ring_exit_work(struct work_struct *work)
 	io_ring_ctx_free(ctx);
 }
 
+/*
+ * called by:
+ *   - fs/io_uring.c|7353| <<io_uring_release>> io_ring_ctx_wait_and_kill(ctx);
+ *   - fs/io_uring.c|7889| <<io_uring_create>> io_ring_ctx_wait_and_kill(ctx);
+ */
 static void io_ring_ctx_wait_and_kill(struct io_ring_ctx *ctx)
 {
 	mutex_lock(&ctx->uring_lock);
@@ -7337,6 +7393,9 @@ static void io_ring_ctx_wait_and_kill(struct io_ring_ctx *ctx)
 	queue_work(system_wq, &ctx->exit_work);
 }
 
+/*
+ * struct file_operations io_uring_fops.release = io_uring_release()
+ */
 static int io_uring_release(struct inode *inode, struct file *file)
 {
 	struct io_ring_ctx *ctx = file->private_data;
@@ -7403,6 +7462,9 @@ static void io_uring_cancel_files(struct io_ring_ctx *ctx,
 	}
 }
 
+/*
+ * struct file_operations io_uring_fops.flush = io_uring_flush()
+ */
 static int io_uring_flush(struct file *file, void *data)
 {
 	struct io_ring_ctx *ctx = file->private_data;
@@ -7447,6 +7509,9 @@ static void *io_uring_validate_mmap_request(struct file *file,
 
 #ifdef CONFIG_MMU
 
+/*
+ * struct file_operations io_uring_fops.mmap = io_uring_mmap()
+ */
 static int io_uring_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	size_t sz = vma->vm_end - vma->vm_start;
@@ -7649,6 +7714,18 @@ static void io_uring_show_fdinfo(struct seq_file *m, struct file *f)
 }
 #endif
 
+/*
+ * 在以下使用io_uring_fops:
+ *   - fs/io_uring.c|875| <<io_uring_get_socket>> if (file->f_op == &io_uring_fops) {
+ *   - fs/io_uring.c|2038| <<io_file_supports_async>> if (S_ISREG(mode) && file->f_op != &io_uring_fops)
+ *   - fs/io_uring.c|3399| <<io_close_prep>> if (req->file->f_op == &io_uring_fops ||
+ *   - fs/io_uring.c|6582| <<io_sqe_files_register>> if (file->f_op == &io_uring_fops) {
+ *   - fs/io_uring.c|6745| <<__io_sqe_files_update>> if (file->f_op == &io_uring_fops) {
+ *   - fs/io_uring.c|6826| <<io_init_wq_offload>> if (f.file->f_op != &io_uring_fops) {
+ *   - fs/io_uring.c|7511| <<SYSCALL_DEFINE6(io_uring_enter)>> if (f.file->f_op != &io_uring_fops)
+ *   - fs/io_uring.c|7731| <<io_uring_get_fd>> file = anon_inode_getfile("[io_uring]", &io_uring_fops, ctx,
+ *   - fs/io_uring.c|8098| <<SYSCALL_DEFINE4(io_uring_register)>> if (f.file->f_op != &io_uring_fops)
+ */
 static const struct file_operations io_uring_fops = {
 	.release	= io_uring_release,
 	.flush		= io_uring_flush,
@@ -7664,6 +7741,10 @@ static const struct file_operations io_uring_fops = {
 #endif
 };
 
+/*
+ * called by:
+ *   - fs/io_uring.c|7911| <<io_uring_create>> ret = io_allocate_scq_urings(ctx, p);
+ */
 static int io_allocate_scq_urings(struct io_ring_ctx *ctx,
 				  struct io_uring_params *p)
 {
@@ -7712,6 +7793,15 @@ static int io_allocate_scq_urings(struct io_ring_ctx *ctx,
  * fd to gain access to the SQ/CQ ring details. If UNIX sockets are enabled,
  * we have to tie this fd to a socket for file garbage collection purposes.
  */
+/*
+ * SYSCALL_DEFINE2(io_uring_setup)
+ *  -> io_uring_setup()
+ *      -> io_uring_create()
+ *          -> io_uring_get_fd()
+ *
+ * called by:
+ *   - fs/io_uring.c|7905| <<io_uring_create>> ret = io_uring_get_fd(ctx);
+ */
 static int io_uring_get_fd(struct io_ring_ctx *ctx)
 {
 	struct file *file;
@@ -7749,6 +7839,11 @@ static int io_uring_get_fd(struct io_ring_ctx *ctx)
 	return ret;
 }
 
+/*
+ * called by:
+ *   - include/trace/events/io_uring.h|24| <<global>> TRACE_EVENT(io_uring_create,
+ *   - fs/io_uring.c|7890| <<io_uring_setup>> return io_uring_create(entries, &p, params);
+ */
 static int io_uring_create(unsigned entries, struct io_uring_params *p,
 			   struct io_uring_params __user *params)
 {
@@ -7870,6 +7965,11 @@ static int io_uring_create(unsigned entries, struct io_uring_params *p,
  * ring size, we return the actual sq/cq ring sizes (among other things) in the
  * params structure passed in.
  */
+/*
+ * called by:
+ *   - kernel/sys_ni.c|51| <<global>> COND_SYSCALL(io_uring_setup);
+ *   - fs/io_uring.c|7948| <<SYSCALL_DEFINE2(io_uring_setup)>> return io_uring_setup(entries, params);
+ */
 static long io_uring_setup(u32 entries, struct io_uring_params __user *params)
 {
 	struct io_uring_params p;
@@ -7896,6 +7996,10 @@ SYSCALL_DEFINE2(io_uring_setup, u32, entries,
 	return io_uring_setup(entries, params);
 }
 
+/*
+ * 处理IORING_REGISTER_PROBE:
+ *   - fs/io_uring.c|8058| <<__io_uring_register>> ret = io_probe(ctx, arg, nr_args);
+ */
 static int io_probe(struct io_ring_ctx *ctx, void __user *arg, unsigned nr_args)
 {
 	struct io_uring_probe *p;
@@ -7935,6 +8039,10 @@ static int io_probe(struct io_ring_ctx *ctx, void __user *arg, unsigned nr_args)
 	return ret;
 }
 
+/*
+ * 处理IORING_REGISTER_PERSONALITY:
+ *   - fs/io_uring.c|8187| <<__io_uring_register>> ret = io_register_personality(ctx);
+ */
 static int io_register_personality(struct io_ring_ctx *ctx)
 {
 	const struct cred *creds = get_current_cred();
@@ -7947,6 +8055,10 @@ static int io_register_personality(struct io_ring_ctx *ctx)
 	return id;
 }
 
+/*
+ * 处理IORING_UNREGISTER_PERSONALITY:
+ *   - fs/io_uring.c|8193| <<__io_uring_register>> ret = io_unregister_personality(ctx, nr_args);
+ */
 static int io_unregister_personality(struct io_ring_ctx *ctx, unsigned id)
 {
 	const struct cred *old_creds;
@@ -7960,6 +8072,18 @@ static int io_unregister_personality(struct io_ring_ctx *ctx, unsigned id)
 	return -EINVAL;
 }
 
+/*
+ * called by:
+ *   - fs/io_uring.c|8056| <<__io_uring_register>> if (io_register_op_must_quiesce(opcode)) {
+ *   - fs/io_uring.c|8141| <<__io_uring_register>> if (io_register_op_must_quiesce(opcode)) {
+ *
+ * 以下的这些不需要quiesce返回false
+ *  - IORING_UNREGISTER_FILES:
+ *  - IORING_REGISTER_FILES_UPDATE:
+ *  - IORING_REGISTER_PROBE:
+ *  - IORING_REGISTER_PERSONALITY:
+ *  - IORING_UNREGISTER_PERSONALITY:
+ */
 static bool io_register_op_must_quiesce(int op)
 {
 	switch (op) {
@@ -7974,6 +8098,9 @@ static bool io_register_op_must_quiesce(int op)
 	}
 }
 
+/*
+ * 被SYSCALL_DEFINE4(io_uring_register)调用
+ */
 static int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,
 			       void __user *arg, unsigned nr_args)
 	__releases(ctx->uring_lock)
@@ -7989,6 +8116,14 @@ static int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,
 	if (percpu_ref_is_dying(&ctx->refs))
 		return -ENXIO;
 
+	/*
+	 * 以下的这些不需要quiesce返回false
+	 *  - IORING_UNREGISTER_FILES:
+	 *  - IORING_REGISTER_FILES_UPDATE:
+	 *  - IORING_REGISTER_PROBE:
+	 *  - IORING_REGISTER_PERSONALITY:
+	 *  - IORING_UNREGISTER_PERSONALITY:
+	 */
 	if (io_register_op_must_quiesce(opcode)) {
 		percpu_ref_kill(&ctx->refs);
 
@@ -8074,6 +8209,14 @@ static int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,
 		break;
 	}
 
+	/*
+	 * 以下的这些不需要quiesce返回false
+	 *  - IORING_UNREGISTER_FILES:
+	 *  - IORING_REGISTER_FILES_UPDATE:
+	 *  - IORING_REGISTER_PROBE:
+	 *  - IORING_REGISTER_PERSONALITY:
+	 *  - IORING_UNREGISTER_PERSONALITY:
+	 */
 	if (io_register_op_must_quiesce(opcode)) {
 		/* bring the ctx back to life */
 		percpu_ref_reinit(&ctx->refs);
@@ -8090,17 +8233,38 @@ SYSCALL_DEFINE4(io_uring_register, unsigned int, fd, unsigned int, opcode,
 	long ret = -EBADF;
 	struct fd f;
 
+	/* f是struct fd */
 	f = fdget(fd);
 	if (!f.file)
 		return -EBADF;
 
 	ret = -EOPNOTSUPP;
+	/*
+	 * 在以下使用io_uring_fops:
+	 *   - fs/io_uring.c|875| <<io_uring_get_socket>> if (file->f_op == &io_uring_fops) {
+	 *   - fs/io_uring.c|2038| <<io_file_supports_async>> if (S_ISREG(mode) && file->f_op != &io_uring_fops)
+	 *   - fs/io_uring.c|3399| <<io_close_prep>> if (req->file->f_op == &io_uring_fops ||
+	 *   - fs/io_uring.c|6582| <<io_sqe_files_register>> if (file->f_op == &io_uring_fops) {
+	 *   - fs/io_uring.c|6745| <<__io_sqe_files_update>> if (file->f_op == &io_uring_fops) {
+	 *   - fs/io_uring.c|6826| <<io_init_wq_offload>> if (f.file->f_op != &io_uring_fops) {
+	 *   - fs/io_uring.c|7511| <<SYSCALL_DEFINE6(io_uring_enter)>> if (f.file->f_op != &io_uring_fops)
+	 *   - fs/io_uring.c|7731| <<io_uring_get_fd>> file = anon_inode_getfile("[io_uring]", &io_uring_fops, ctx,
+	 *   - fs/io_uring.c|8098| <<SYSCALL_DEFINE4(io_uring_register)>> if (f.file->f_op != &io_uring_fops)
+	 *
+	 * SYSCALL_DEFINE2(io_uring_setup)
+	 *  -> io_uring_setup()
+	 *      -> io_uring_create()
+	 *          -> io_uring_get_fd()
+	 */
 	if (f.file->f_op != &io_uring_fops)
 		goto out_fput;
 
 	ctx = f.file->private_data;
 
 	mutex_lock(&ctx->uring_lock);
+	/*
+	 * 只在这里被调用
+	 */
 	ret = __io_uring_register(ctx, opcode, arg, nr_args);
 	mutex_unlock(&ctx->uring_lock);
 	trace_io_uring_register(ctx, opcode, ctx->nr_user_files, ctx->nr_user_bufs,
@@ -8150,7 +8314,24 @@ static int __init io_uring_init(void)
 
 	BUILD_BUG_ON(ARRAY_SIZE(io_op_defs) != IORING_OP_LAST);
 	BUILD_BUG_ON(__REQ_F_LAST_BIT >= 8 * sizeof(int));
+	/*
+	 * 在以下使用req_cachep:
+	 *   - fs/io_uring.c|901| <<io_ring_ctx_alloc>> ctx->fallback_req = kmem_cache_alloc(req_cachep, GFP_KERNEL);
+	 *   - fs/io_uring.c|948| <<io_ring_ctx_alloc>> kmem_cache_free(req_cachep, ctx->fallback_req);
+	 *   - fs/io_uring.c|1306| <<io_alloc_req>> req = kmem_cache_alloc(req_cachep, gfp);
+	 *   - fs/io_uring.c|1314| <<io_alloc_req>> ret = kmem_cache_alloc_bulk(req_cachep, gfp, sz, state->reqs);
+	 *   - fs/io_uring.c|1321| <<io_alloc_req>> state->reqs[0] = kmem_cache_alloc(req_cachep, gfp);
+	 *   - fs/io_uring.c|1378| <<__io_free_req>> kmem_cache_free(req_cachep, req);
+	 *   - fs/io_uring.c|1423| <<io_free_req_many>> kmem_cache_free_bulk(req_cachep, rb->to_free, rb->reqs);
+	 *   - fs/io_uring.c|5716| <<io_submit_state_end>> kmem_cache_free_bulk(req_cachep, state->free_reqs, state->reqs);
+	 *   - fs/io_uring.c|7255| <<io_ring_ctx_free>> kmem_cache_free(req_cachep, ctx->fallback_req);
+	 *   - fs/io_uring.c|8153| <<io_uring_init>> req_cachep = KMEM_CACHE(io_kiocb, SLAB_HWCACHE_ALIGN | SLAB_PANIC);
+	 */
 	req_cachep = KMEM_CACHE(io_kiocb, SLAB_HWCACHE_ALIGN | SLAB_PANIC);
 	return 0;
 };
 __initcall(io_uring_init);
+
+/*
+ * SYSCALL_DEFINE4(io_uring_register)
+ */
-- 
2.17.1

