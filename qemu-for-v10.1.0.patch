From 2eb2543ceb6bf9cce6a978574683797f8cda153d Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Sun, 28 Sep 2025 11:07:00 -0700
Subject: [PATCH 1/1] qemu for v10.1.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-accel-ops.c      |   9 +
 accel/kvm/kvm-all.c            | 214 +++++++++++++++++
 dump/dump.c                    |  27 +++
 hw/acpi/vmclock.c              |  30 +++
 hw/core/cpu-system.c           |   4 +
 hw/display/vga.c               |   9 +
 hw/i386/kvm/clock.c            | 428 +++++++++++++++++++++++++++++++++
 hw/i386/pc.c                   |  18 ++
 hw/i386/pc_piix.c              |  16 ++
 hw/i386/pc_q35.c               |  16 ++
 hw/net/virtio-net.c            |  79 ++++++
 hw/vfio/migration.c            |  11 +
 hw/vfio/pci.c                  |  36 +++
 hw/vfio/pci.h                  |  10 +
 include/accel/accel-cpu-ops.h  |  36 +++
 include/hw/i386/pc.h           |   8 +
 include/hw/virtio/virtio-net.h |  22 ++
 include/migration/vmstate.h    |  22 ++
 include/system/kvm_int.h       |   7 +
 linux-headers/linux/kvm.h      |   7 +
 migration/block-dirty-bitmap.c |  11 +
 migration/channel.c            |  24 ++
 migration/colo.c               |  10 +
 migration/exec.c               |   8 +
 migration/fd.c                 |   8 +
 migration/file.c               |  15 ++
 migration/migration.c          | 400 ++++++++++++++++++++++++++++++
 migration/migration.h          |   7 +
 migration/ram.c                |  42 ++++
 migration/rdma.c               |   5 +
 migration/savevm.c             | 391 ++++++++++++++++++++++++++++++
 migration/savevm.h             |   8 +
 migration/socket.c             |   8 +
 migration/tls.c                |   8 +
 monitor/qmp-cmds.c             |  17 ++
 net/slirp.c                    |  11 +
 net/tap-linux.c                |  12 +
 net/tap.c                      |  12 +
 system/cpus.c                  | 364 ++++++++++++++++++++++++++++
 system/memory.c                |  53 ++++
 system/runstate.c              |  78 ++++++
 target/arm/hvf/hvf.c           |  10 +
 target/i386/cpu.c              |  85 +++++++
 target/i386/cpu.h              |  19 ++
 target/i386/kvm/kvm.c          | 105 ++++++++
 target/i386/kvm/xen-emu.c      |   9 +
 46 files changed, 2729 insertions(+)

diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index b709187c7..44a504d28 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -98,6 +98,15 @@ static void kvm_accel_ops_class_init(ObjectClass *oc, const void *data)
     ops->cpu_thread_is_idle = kvm_vcpu_thread_is_idle;
     ops->cpus_are_resettable = kvm_cpus_are_resettable;
     ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
     ops->synchronize_state = kvm_cpu_synchronize_state;
     ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 890d5ea9f..4ffb21f01 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -445,6 +445,10 @@ int kvm_unpark_vcpu(KVMState *s, unsigned long vcpu_id)
     return kvm_fd;
 }
 
+/*
+ * 在以下使用kvm_reset_parked_vcpus():
+ *   - accel/kvm/kvm-all.c|3048| <<kvm_cpu_synchronize_post_reset>> kvm_reset_parked_vcpus(kvm_state);
+ */
 static void kvm_reset_parked_vcpus(KVMState *s)
 {
     struct KVMParkedVcpu *cpu;
@@ -651,12 +655,24 @@ void kvm_close(void)
  * dirty pages logging control
  */
 
+/*
+ * 在以下使用kvm_mem_flags():
+ *   - accel/kvm/kvm-all.c|676| <<kvm_slot_update_flags>> mem->flags = kvm_mem_flags(mr);
+ *   - accel/kvm/kvm-all.c|1603| <<kvm_set_phys_mem>> mem->flags = kvm_mem_flags(mr);
+ */
 static int kvm_mem_flags(MemoryRegion *mr)
 {
     bool readonly = mr->readonly || memory_region_is_romd(mr);
     int flags = 0;
 
     if (memory_region_get_dirty_log_mask(mr) != 0) {
+        /*
+	 * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+         *   - accel/kvm/kvm-all.c|660| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+         *   - accel/kvm/kvm-all.c|772| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+         *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+         *   - accel/kvm/kvm-all.c|1864| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	 */
         flags |= KVM_MEM_LOG_DIRTY_PAGES;
     }
     if (readonly && kvm_readonly_mem_allowed) {
@@ -673,6 +689,11 @@ static int kvm_mem_flags(MemoryRegion *mr)
 static int kvm_slot_update_flags(KVMMemoryListener *kml, KVMSlot *mem,
                                  MemoryRegion *mr)
 {
+    /*
+     * 在以下使用kvm_mem_flags():
+     *   - accel/kvm/kvm-all.c|676| <<kvm_slot_update_flags>> mem->flags = kvm_mem_flags(mr);
+     *   - accel/kvm/kvm-all.c|1603| <<kvm_set_phys_mem>> mem->flags = kvm_mem_flags(mr);
+     */
     mem->flags = kvm_mem_flags(mr);
 
     /* If nothing changed effectively, no need to issue ioctl */
@@ -769,6 +790,13 @@ static void kvm_slot_reset_dirty_pages(KVMSlot *slot)
 /* Allocate the dirty bitmap for a slot  */
 static void kvm_slot_init_dirty_bitmap(KVMSlot *mem)
 {
+    /*
+     * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+     *   - accel/kvm/kvm-all.c|660| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+     *   - accel/kvm/kvm-all.c|772| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+     *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+     *   - accel/kvm/kvm-all.c|1864| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+     */
     if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
         return;
     }
@@ -1498,6 +1526,11 @@ int kvm_set_memory_attributes_shared(hwaddr start, uint64_t size)
     return kvm_set_memory_attributes(start, size, 0);
 }
 
+/*
+ * 在以下使用kvm_set_phys_mem():
+ *   - accel/kvm/kvm-all.c|1820| <<kvm_region_commit>> kvm_set_phys_mem(kml, &u1->section, false);
+ *   - accel/kvm/kvm-all.c|1830| <<kvm_region_commit>> kvm_set_phys_mem(kml, &u1->section, true);
+ */
 /* Called with KVMMemoryListener.slots_lock held */
 static void kvm_set_phys_mem(KVMMemoryListener *kml,
                              MemoryRegionSection *section, bool add)
@@ -1540,6 +1573,13 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
             if (!mem) {
                 return;
             }
+            /*
+	     * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+             *   - accel/kvm/kvm-all.c|660| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+             *   - accel/kvm/kvm-all.c|772| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+             *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+             *   - accel/kvm/kvm-all.c|1864| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	     */
             if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
                 /*
                  * NOTE: We should be aware of the fact that here we're only
@@ -1556,6 +1596,13 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
                  */
                 if (kvm_state->kvm_dirty_ring_size) {
                     kvm_dirty_ring_reap_locked(kvm_state, NULL);
+                    /*
+		     * 在以下使用KVMState->kvm_dirty_ring_with_bitmap:
+		     *   - accel/kvm/kvm-all.c|1559| <<kvm_set_phys_mem>> if (kvm_state->kvm_dirty_ring_with_bitmap) {
+		     *   - accel/kvm/kvm-all.c|1723| <<kvm_dirty_ring_init>> s->kvm_dirty_ring_with_bitmap = true;
+		     *   - accel/kvm/kvm-all.c|1853| <<kvm_log_sync_global>> if (s->kvm_dirty_ring_with_bitmap && last_stage &&
+		     *   - accel/kvm/kvm-all.c|4054| <<kvm_accel_instance_init>> s->kvm_dirty_ring_with_bitmap = false;
+		     */
                     if (kvm_state->kvm_dirty_ring_with_bitmap) {
                         kvm_slot_sync_dirty_pages(mem);
                         kvm_slot_get_dirty_log(kvm_state, mem);
@@ -1593,6 +1640,11 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
         mem->start_addr = start_addr;
         mem->ram_start_offset = ram_start_offset;
         mem->ram = ram;
+        /*
+	 * 在以下使用kvm_mem_flags():
+         *   - accel/kvm/kvm-all.c|676| <<kvm_slot_update_flags>> mem->flags = kvm_mem_flags(mr);
+         *   - accel/kvm/kvm-all.c|1603| <<kvm_set_phys_mem>> mem->flags = kvm_mem_flags(mr);
+	 */
         mem->flags = kvm_mem_flags(mr);
         mem->guest_memfd = mr->ram_block->guest_memfd;
         mem->guest_memfd_offset = (uint8_t*)ram - mr->ram_block->host;
@@ -1666,6 +1718,21 @@ static void kvm_dirty_ring_reaper_init(KVMState *s)
                        s, QEMU_THREAD_JOINABLE);
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_dirty_ring_init (s=0x55555775d560) at ../accel/kvm/kvm-all.c:1670
+ * #1  0x0000555555f23771 in kvm_setup_dirty_ring (s=0x55555775d560) at ../accel/kvm/kvm-all.c:2568
+ * #2  0x0000555555f23d89 in kvm_init (as=0x55555775d560, ms=0x55555784aad0) at ../accel/kvm/kvm-all.c:2729
+ * #3  0x0000555555d0aef9 in accel_init_machine (accel=0x55555775d560, ms=0x55555784aad0) at ../accel/accel-system.c:44
+ * #4  0x0000555555c03434 in do_configure_accelerator (opaque=0x7fffffffd964, opts=0x555557871f20, errp=0x555557527c40
+ *     <error_fatal>) at ../system/vl.c:2406
+ * #5  0x00005555561616f0 in qemu_opts_foreach (list=0x555557400b80 <qemu_accel_opts>, func=0x555555c032b3 <do_configure_accelerator>,
+ *     opaque=0x7fffffffd964, errp=0x555557527c40 <error_fatal>) at ../util/qemu-option.c:1135
+ * #6  0x0000555555c03714 in configure_accelerators (progname=0x7fffffffdfac "/home/zhang/kvm/test/qemu-10.1.0/build/qemu-system-x86_64")
+ *     at ../system/vl.c:2478
+ * #7  0x0000555555c06d77 in qemu_init (argc=21, argv=0x7fffffffdc18) at ../system/vl.c:3783
+ * #8  0x0000555556082a24 in main (argc=21, argv=0x7fffffffdc18) at ../system/main.c:71
+ */
 static int kvm_dirty_ring_init(KVMState *s)
 {
     uint32_t ring_size = s->kvm_dirty_ring_size;
@@ -1720,6 +1787,13 @@ static int kvm_dirty_ring_init(KVMState *s)
             return -EIO;
         }
 
+        /*
+	 * 在以下使用KVMState->kvm_dirty_ring_with_bitmap:
+         *   - accel/kvm/kvm-all.c|1559| <<kvm_set_phys_mem>> if (kvm_state->kvm_dirty_ring_with_bitmap) {
+         *   - accel/kvm/kvm-all.c|1723| <<kvm_dirty_ring_init>> s->kvm_dirty_ring_with_bitmap = true;
+         *   - accel/kvm/kvm-all.c|1853| <<kvm_log_sync_global>> if (s->kvm_dirty_ring_with_bitmap && last_stage &&
+         *   - accel/kvm/kvm-all.c|4054| <<kvm_accel_instance_init>> s->kvm_dirty_ring_with_bitmap = false;
+	 */
         s->kvm_dirty_ring_with_bitmap = true;
     }
 
@@ -1847,9 +1921,23 @@ static void kvm_log_sync_global(MemoryListener *l, bool last_stage)
     kvm_slots_lock();
     for (i = 0; i < kml->nr_slots_allocated; i++) {
         mem = &kml->slots[i];
+        /*
+	 * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+         *   - accel/kvm/kvm-all.c|660| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+         *   - accel/kvm/kvm-all.c|772| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+         *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+         *   - accel/kvm/kvm-all.c|1864| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	 */
         if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
             kvm_slot_sync_dirty_pages(mem);
 
+            /*
+	     * 在以下使用KVMState->kvm_dirty_ring_with_bitmap:
+	     *   - accel/kvm/kvm-all.c|1559| <<kvm_set_phys_mem>> if (kvm_state->kvm_dirty_ring_with_bitmap) {
+	     *   - accel/kvm/kvm-all.c|1723| <<kvm_dirty_ring_init>> s->kvm_dirty_ring_with_bitmap = true;
+	     *   - accel/kvm/kvm-all.c|1853| <<kvm_log_sync_global>> if (s->kvm_dirty_ring_with_bitmap && last_stage &&
+	     *   - accel/kvm/kvm-all.c|4054| <<kvm_accel_instance_init>> s->kvm_dirty_ring_with_bitmap = false;
+	     */
             if (s->kvm_dirty_ring_with_bitmap && last_stage &&
                 kvm_slot_get_dirty_log(s, mem)) {
                 kvm_slot_sync_dirty_pages(mem);
@@ -2875,6 +2963,10 @@ static int kvm_handle_internal_error(CPUState *cpu, struct kvm_run *run)
     return -1;
 }
 
+/*
+ * 在以下使用kvm_flush_coalesced_mmio_buffer():
+ *   - system/physmem.c|1170| <<qemu_flush_coalesced_mmio_buffer>> kvm_flush_coalesced_mmio_buffer();
+ */
 void kvm_flush_coalesced_mmio_buffer(void)
 {
     KVMState *s = kvm_state;
@@ -2907,6 +2999,10 @@ void kvm_flush_coalesced_mmio_buffer(void)
     s->coalesced_flush_in_progress = false;
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-all.c|2948| <<kvm_cpu_synchronize_state>> run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
@@ -2927,6 +3023,46 @@ static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用AccelOpsClass->synchronize_state():
+ *   - accel/hvf/hvf-accel-ops.c|382| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+ *   - accel/kvm/kvm-accel-ops.c|111| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - system/cpus.c|204| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+ *   - system/cpus.c|205| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|94| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+ *   - target/i386/whpx/whpx-accel-ops.c|97| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+ *
+ * 在以下使用kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-accel-ops.c|111| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - accel/kvm/kvm-all.c|3461| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+ *   - target/arm/kvm.c|1355| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/arm/kvm.c|2380| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+ *   - target/i386/kvm/kvm.c|5709| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5728| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5746| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5751| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6314| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+ *   - target/loongarch/kvm/kvm.c|1348| <<kvm_loongarch_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/riscv/kvm/kvm-cpu.c|1697| <<kvm_riscv_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/s390x/kvm/kvm.c|1910| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+ *
+ * 就是kvm_arch_get_registers()
+ */
 void kvm_cpu_synchronize_state(CPUState *cpu)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
@@ -2934,9 +3070,19 @@ void kvm_cpu_synchronize_state(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_post_reset():
+ *   - accel/kvm/kvm-all.c|3064| <<kvm_cpu_synchronize_post_reset>> run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_post_reset(CPUState *cpu, run_on_cpu_data arg)
 {
     Error *err = NULL;
+    /*
+     * 在以下使用kvm_arch_put_registers():
+     *   - accel/kvm/kvm-all.c|2959| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+     *   - accel/kvm/kvm-all.c|2990| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+     *   - accel/kvm/kvm-all.c|3221| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+     */
     int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
     if (ret) {
         if (err) {
@@ -2952,6 +3098,18 @@ static void do_kvm_cpu_synchronize_post_reset(CPUState *cpu, run_on_cpu_data arg
     cpu->vcpu_dirty = false;
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_post_reset():
+ *   - accel/hvf/hvf-accel-ops.c|380| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+ *   - accel/kvm/kvm-accel-ops.c|100| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+ *   - system/cpus.c|289| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+ *   - system/cpus.c|290| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+ *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+ *
+ * 只在以下使用kvm_cpu_synchronize_post_reset():
+ *   - accel/kvm/kvm-accel-ops.c|100| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+ */
 void kvm_cpu_synchronize_post_reset(CPUState *cpu)
 {
     run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
@@ -2961,9 +3119,19 @@ void kvm_cpu_synchronize_post_reset(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-all.c|3003| <<kvm_cpu_synchronize_post_init>> run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
 {
     Error *err = NULL;
+    /*
+     * 在以下使用kvm_arch_put_registers():
+     *   - accel/kvm/kvm-all.c|2959| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+     *   - accel/kvm/kvm-all.c|2990| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+     *   - accel/kvm/kvm-all.c|3221| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+     */
     int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
     if (ret) {
         if (err) {
@@ -2978,6 +3146,30 @@ static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
     cpu->vcpu_dirty = false;
 }
 
+/*
+ * (gdb) bt
+ * #0  cpu_synchronize_post_init (cpu=0x5555578f8060) at ../system/cpus.c:186
+ * #1  0x0000555555c08773 in cpu_synchronize_all_post_init () at ../system/cpus.c:157
+ * #2  0x0000555555c7e70e in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3199
+ * #3  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #4  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #5  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #6  0x00007fffffffc7e0 in ?? ()
+ * #7  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用AccelOpsClass->synchronize_post_init():
+ *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+ *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+ *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+ *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+ *
+ *
+ * 在以下使用kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ */
 void kvm_cpu_synchronize_post_init(CPUState *cpu)
 {
     if (!kvm_state->guest_state_protected) {
@@ -2994,6 +3186,15 @@ static void do_kvm_cpu_synchronize_pre_loadvm(CPUState *cpu, run_on_cpu_data arg
     cpu->vcpu_dirty = true;
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+ *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+ *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+ *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+ *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+ *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+ */
 void kvm_cpu_synchronize_pre_loadvm(CPUState *cpu)
 {
     run_on_cpu(cpu, do_kvm_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
@@ -3171,6 +3372,12 @@ int kvm_cpu_exec(CPUState *cpu)
 
         if (cpu->vcpu_dirty) {
             Error *err = NULL;
+            /*
+	     * 在以下使用kvm_arch_put_registers():
+             *   - accel/kvm/kvm-all.c|2959| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+             *   - accel/kvm/kvm-all.c|2990| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+             *   - accel/kvm/kvm-all.c|3221| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+	     */
             ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
             if (ret) {
                 if (err) {
@@ -3995,6 +4202,13 @@ static void kvm_accel_instance_init(Object *obj)
     s->kernel_irqchip_split = ON_OFF_AUTO_AUTO;
     /* KVM dirty ring is by default off */
     s->kvm_dirty_ring_size = 0;
+    /*
+     * 在以下使用KVMState->kvm_dirty_ring_with_bitmap:
+     *   - accel/kvm/kvm-all.c|1559| <<kvm_set_phys_mem>> if (kvm_state->kvm_dirty_ring_with_bitmap) {
+     *   - accel/kvm/kvm-all.c|1723| <<kvm_dirty_ring_init>> s->kvm_dirty_ring_with_bitmap = true;
+     *   - accel/kvm/kvm-all.c|1853| <<kvm_log_sync_global>> if (s->kvm_dirty_ring_with_bitmap && last_stage &&
+     *   - accel/kvm/kvm-all.c|4054| <<kvm_accel_instance_init>> s->kvm_dirty_ring_with_bitmap = false;
+     */
     s->kvm_dirty_ring_with_bitmap = false;
     s->kvm_eager_split_size = 0;
     s->notify_vmexit = NOTIFY_VMEXIT_OPTION_RUN;
diff --git a/dump/dump.c b/dump/dump.c
index 15bbcc0c6..df6d9d833 100644
--- a/dump/dump.c
+++ b/dump/dump.c
@@ -111,6 +111,23 @@ static int dump_cleanup(DumpState *s)
         if (s->detached) {
             bql_lock();
         }
+        /*
+	 * 在以下使用vm_start():
+	 *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+	 *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+	 *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|793| <<vm_resume>> vm_start();
+	 */
         vm_start();
         if (s->detached) {
             bql_unlock();
@@ -1808,6 +1825,16 @@ static void dump_init(DumpState *s, int fd, bool has_format,
     /* If we use KVM, we should synchronize the registers before we get dump
      * info or physmap info.
      */
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
     nr_cpus = 0;
     CPU_FOREACH(cpu) {
diff --git a/hw/acpi/vmclock.c b/hw/acpi/vmclock.c
index c582c0c1f..e1e80daff 100644
--- a/hw/acpi/vmclock.c
+++ b/hw/acpi/vmclock.c
@@ -61,6 +61,11 @@ void vmclock_build_acpi(VmclockState *vms, GArray *table_data,
     free_aml_allocator();
 }
 
+/*
+ * 在以下使用vmclock_update_guest():
+ *   - hw/acpi/vmclock.c|95| <<vmclock_post_load>> vmclock_update_guest(vms);
+ *   - hw/acpi/vmclock.c|154| <<vmclock_realize>> vmclock_update_guest(vms);
+ */
 static void vmclock_update_guest(VmclockState *vms)
 {
     uint64_t disruption_marker;
@@ -92,6 +97,11 @@ static int vmclock_post_load(void *opaque, int version_id)
 {
     VmclockState *vms = opaque;
 
+    /*
+     * 在以下使用vmclock_update_guest():
+     *   - hw/acpi/vmclock.c|95| <<vmclock_post_load>> vmclock_update_guest(vms);
+     *   - hw/acpi/vmclock.c|154| <<vmclock_realize>> vmclock_update_guest(vms);
+     */
     vmclock_update_guest(vms);
     return 0;
 }
@@ -138,6 +148,14 @@ static void vmclock_realize(DeviceState *dev, Error **errp)
     memory_region_init_ram(&vms->clk_page, OBJECT(dev), "vmclock_page",
                            VMCLOCK_SIZE, &error_abort);
     memory_region_set_enabled(&vms->clk_page, true);
+    /*
+     * struct VmclockState {
+     *     DeviceState parent_obj;
+     *     MemoryRegion clk_page;
+     *     uint64_t physaddr;
+     *     struct vmclock_abi *clk;
+     * };
+     */
     vms->clk = memory_region_get_ram_ptr(&vms->clk_page);
     memset(vms->clk, 0, VMCLOCK_SIZE);
 
@@ -146,11 +164,23 @@ static void vmclock_realize(DeviceState *dev, Error **errp)
     vms->clk->version = cpu_to_le16(1);
 
     /* These are all zero and thus default, but be explicit */
+    /*
+     * 121 #define VMCLOCK_STATUS_UNKNOWN          0
+     * 122 #define VMCLOCK_STATUS_INITIALIZING     1
+     * 123 #define VMCLOCK_STATUS_SYNCHRONIZED     2
+     * 124 #define VMCLOCK_STATUS_FREERUNNING      3
+     * 125 #define VMCLOCK_STATUS_UNRELIABLE       4
+     */
     vms->clk->clock_status = VMCLOCK_STATUS_UNKNOWN;
     vms->clk->counter_id = VMCLOCK_COUNTER_INVALID;
 
     qemu_register_reset(vmclock_handle_reset, vms);
 
+    /*
+     * 在以下使用vmclock_update_guest():
+     *   - hw/acpi/vmclock.c|95| <<vmclock_post_load>> vmclock_update_guest(vms);
+     *   - hw/acpi/vmclock.c|154| <<vmclock_realize>> vmclock_update_guest(vms);
+     */
     vmclock_update_guest(vms);
 }
 
diff --git a/hw/core/cpu-system.c b/hw/core/cpu-system.c
index a975405d3..4a4eb006f 100644
--- a/hw/core/cpu-system.c
+++ b/hw/core/cpu-system.c
@@ -283,6 +283,10 @@ const VMStateDescription vmstate_cpu_common = {
     }
 };
 
+/*
+ * 在以下使用cpu_vmstate_register():
+ *   - hw/core/cpu-common.c|242| <<cpu_exec_realizefn>> cpu_vmstate_register(cpu);
+ */
 void cpu_vmstate_register(CPUState *cpu)
 {
     if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {
diff --git a/hw/display/vga.c b/hw/display/vga.c
index 90b89cf40..ac691316b 100644
--- a/hw/display/vga.c
+++ b/hw/display/vga.c
@@ -1462,6 +1462,15 @@ static bool vga_scanline_invalidated(VGACommonState *s, int y)
     return s->invalidated_y_table[y >> 5] & (1 << (y & 0x1f));
 }
 
+/*
+ * 在以下使用vga_dirty_log_start():
+ *   - hw/display/qxl.c|1179| <<qxl_enter_vga_mode>> vga_dirty_log_start(&d->vga);
+ *   - hw/display/qxl.c|2166| <<qxl_realize_common>> vga_dirty_log_start(&qxl->vga);
+ *   - hw/display/vga.c|2270| <<vga_common_init>> vga_dirty_log_start(s);
+ *   - hw/display/virtio-vga.c|195| <<virtio_vga_base_reset_hold>> vga_dirty_log_start(&vvga->vga);
+ *   - hw/display/vmware_vga.c|1011| <<vmsvga_value_write>> vga_dirty_log_start(&s->vga);
+ *   - hw/display/vmware_vga.c|1172| <<vmsvga_reset>> vga_dirty_log_start(&s->vga);
+ */
 void vga_dirty_log_start(VGACommonState *s)
 {
     memory_region_set_log(&s->vram, true, DIRTY_MEMORY_VGA);
diff --git a/hw/i386/kvm/clock.c b/hw/i386/kvm/clock.c
index f56382717..1212cd5bb 100644
--- a/hw/i386/kvm/clock.c
+++ b/hw/i386/kvm/clock.c
@@ -38,16 +38,35 @@ struct KVMClockState {
     /*< public >*/
 
     uint64_t clock;
+    /*
+     * 在以下使用KVMClockState->clock_valid:
+     *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+     *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+     *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+     */
     bool clock_valid;
 
     /* whether the 'clock' value was obtained in the 'paused' state */
     bool runstate_paused;
 
+    /*
+     * 在以下使用KVMClockState->mach_use_reliable_get_clock:
+     *    - hw/i386/kvm/clock.c|726| <<global>> DEFINE_PROP_BOOL("x-mach-use-reliable-get-clock", KVMClockState,
+     *                                            mach_use_reliable_get_clock, true),
+     *    - hw/i386/kvm/clock.c|602| <<kvmclock_clock_is_reliable_needed>> return s->mach_use_reliable_get_clock;
+     */
     /* whether machine type supports reliable KVM_GET_CLOCK */
     bool mach_use_reliable_get_clock;
 
     /* whether the 'clock' value was obtained in a host with
      * reliable KVM_GET_CLOCK */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     bool clock_is_reliable;
 };
 
@@ -62,6 +81,12 @@ struct pvclock_vcpu_time_info {
     uint8_t    pad[2];
 } __attribute__((__packed__)); /* 32 bytes */
 
+/*
+ * 在以下使用kvmclock_current_nsec():
+ *   - hw/i386/kvm/clock.c|376| <<kvmclock_vm_state_change>> uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
+ *
+ * 读取vCPU 0的PVTI, 用env->tsc计算时间
+ */
 static uint64_t kvmclock_current_nsec(KVMClockState *s)
 {
     CPUState *cpu = first_cpu;
@@ -74,8 +99,19 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     uint64_t nsec_hi;
     uint64_t nsec;
 
+    /*
+     * 相当于kvm_arch_get_registers()
+     */
     cpu_synchronize_state(cpu);
 
+    /*
+     * 在以下使用CPUX86State->system_time_msr:
+     *   - target/i386/machine.c|1738| <<vmstate_x86_cpu>> VMSTATE_UINT64(env.system_time_msr, X86CPU),
+     *   - hw/i386/kvm/clock.c|96| <<kvmclock_current_nsec>> if (!(env->system_time_msr & 1ULL)) {
+     *   - hw/i386/kvm/clock.c|101| <<kvmclock_current_nsec>> kvmclock_struct_pa = env->system_time_msr & ~1ULL;
+     *   - target/i386/kvm/kvm.c|4058| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
+     *   - target/i386/kvm/kvm.c|4826| <<kvm_get_msrs>> env->system_time_msr = msrs[i].data;
+     */
     if (!(env->system_time_msr & 1ULL)) {
         /* KVM clock not active */
         return 0;
@@ -97,11 +133,81 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     return nsec + time.system_time;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用kvm_update_clock():
+ *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+ */
 static void kvm_update_clock(KVMClockState *s)
 {
+    /*
+     * struct kvm_clock_data {
+     *     __u64 clock;
+     *     __u32 flags;
+     *     __u32 pad0;
+     *     __u64 realtime;
+     *     __u64 host_tsc;
+     *     __u32 pad[4];
+     * };
+     */
     struct kvm_clock_data data;
     int ret;
 
+    /*
+     * 在两个地方使用KVM_GET_CLOCK:
+     *   - hw/i386/kvm/clock.c|200| <<kvm_update_clock>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     *   - target/i386/kvm/xen-emu.c|992| <<kvm_get_current_ns>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     */
     ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
     if (ret < 0) {
         fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(-ret));
@@ -148,9 +254,119 @@ static void kvm_update_clock(KVMClockState *s)
      *       if !kvm_has_adjust_clock_stable() then
      *               read from memory
      */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     s->clock_is_reliable = kvm_has_adjust_clock_stable();
 }
 
+/*
+ * 创建的时候这个调用一次.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ * 这个调用#vCPU次.
+ *
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x5555578c3250, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c3250) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c3250) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c3250) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c3250) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555578cd7d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 
+ * 迁移到文件的时候.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 从文件迁移到VM.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ * 然后下面调用#vCPU次.
+ *
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x5555578c3250, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c3250) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c3250) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c3250) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c3250) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555578cd7d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 从QEMU quit的时候
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_SHUTDOWN) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_SHUTDOWN) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_SHUTDOWN, send_stop=false) at ../system/cpus.c:300
+ * #3  0x0000555555c08bec in vm_shutdown () at ../system/cpus.c:322
+ * #4  0x0000555555c38ee9 in qemu_cleanup (status=0) at ../system/runstate.c:981
+ * #5  0x00005555560829d2 in qemu_default_main (opaque=0x0) at ../system/main.c:51
+ * #6  0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ */
+/*
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x55555790c330, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x55555790c330) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x55555790c330) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x55555790c330) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x55555790c330) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555579159d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用do_kvmclock_ctrl():
+ *   - hw/i386/kvm/clock.c|239| <<kvmclock_vm_state_change>> run_on_cpu(cpu, do_kvmclock_ctrl, RUN_ON_CPU_NULL);
+ */
 static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
 {
     int ret = kvm_vcpu_ioctl(cpu, KVM_KVMCLOCK_CTRL, 0);
@@ -160,6 +376,109 @@ static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
     }
 }
 
+/*
+ * 启动的时候
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e2f in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d3a in vm_prepare_start (step_pending=false) at ../system/cpus.c:780
+ * #3  0x0000555555c09d75 in vm_start () at ../system/cpus.c:787
+ * #4  0x0000555555c8be6d in qmp_cont (errp=0x7fffffffc750) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c86052 in hmp_cont (mon=0x5555578622a0, qdict=0x555558142820) at ../monitor/hmp-cmds.c:145
+ * #6  0x0000555555c89d89 in handle_hmp_command_exec (mon=0x5555578622a0, cmd=0x55555742d8b0 <hmp_cmds+1680>, qdict=0x555558142820) at ../monitor/hmp.c:1106
+ * #7  0x0000555555c89fd4 in handle_hmp_command (mon=0x5555578622a0, cmdline=0x555557883d74 "") at ../monitor/hmp.c:1158
+ * #8  0x0000555555c87059 in monitor_command_cb (opaque=0x5555578622a0, cmdline=0x555557883d70 "cont", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #9  0x0000555556185448 in readline_handle_byte (rs=0x555557883d70, ch=13) at ../util/readline.c:427
+ * #10 0x0000555555c8ac2b in monitor_read (opaque=0x5555578622a0, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", size=1) at ../monitor/hmp.c:1390
+ * #11 0x0000555556078410 in qemu_chr_be_write_impl (s=0x55555773e300, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:214
+ * #12 0x0000555556078481 in qemu_chr_be_write (s=0x55555773e300, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:226
+ * #13 0x000055555607b483 in fd_chr_read (chan=0x55555783fdc0, cond=G_IO_IN, opaque=0x55555773e300) at ../chardev/char-fd.c:72
+ * #14 0x0000555555f4a47a in qio_channel_fd_source_dispatch (source=0x555558455a20, callback=0x55555607b344 <fd_chr_read>, user_data=0x55555773e300)
+ *     at ../io/channel-watch.c:84
+ * #15 0x00007ffff6fd3854 in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #17 0x0000555556172240 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561722ce in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:310
+ * #19 0x00005555561723fd in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c38d08 in qemu_main_loop () at ../system/runstate.c:905
+ * #21 0x0000555556082abe in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x0000555556082b78 in main (argc=22, argv=0x7fffffffdc68) at ../system/main.c:93
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ *
+ * 迁移的时候在Source上的调用:
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 迁移的时候在Target上的调用:
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ *
+ * 这是迁移在Target上的.
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x5555582b37e0) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用kvmclock_vm_state_change():
+ *   - hw/i386/kvm/clock.c|284| <<kvmclock_realize>> qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
+ */
 static void kvmclock_vm_state_change(void *opaque, bool running,
                                      RunState state)
 {
@@ -171,11 +490,22 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
     if (running) {
         struct kvm_clock_data data = {};
 
+        /*
+	 * 在以下使用KVMClockState->clock_is_reliable:
+         *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+         *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+         *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+         *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+	 */
         /*
          * If the host where s->clock was read did not support reliable
          * KVM_GET_CLOCK, read kvmclock value from memory.
          */
         if (!s->clock_is_reliable) {
+            /*
+	     * 只在这里调用kvmclock_current_nsec()
+	     * 读取vCPU 0的PVTI, 用env->tsc计算时间
+	     */
             uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
             /* We can't rely on the saved clock value, just discard it */
             if (pvclock_via_mem) {
@@ -183,9 +513,18 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
             }
         }
 
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         s->clock_valid = false;
 
         data.clock = s->clock;
+        /*
+	 * 只在这一个地方调用KVM_SET_CLOCK
+	 */
         ret = kvm_vm_ioctl(kvm_state, KVM_SET_CLOCK, &data);
         if (ret < 0) {
             fprintf(stderr, "KVM_SET_CLOCK failed: %s\n", strerror(-ret));
@@ -200,20 +539,44 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
         }
     } else {
 
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+	 *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+	 *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+	 *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         if (s->clock_valid) {
             return;
         }
 
         s->runstate_paused = runstate_check(RUN_STATE_PAUSED);
 
+	/*
+	 * 只在这里调用
+	 * get MSR_IA32_TSC
+	 */
         kvm_synchronize_all_tsc();
 
+        /*
+	 * 在以下使用kvm_update_clock():
+	 *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+	 *
+	 * KVM_GET_CLOCK
+	 */
         kvm_update_clock(s);
         /*
          * If the VM is stopped, declare the clock state valid to
          * avoid re-reading it on next vmsave (which would return
          * a different value). Will be reset when the VM is continued.
          */
+	/*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         s->clock_valid = true;
     }
 }
@@ -227,6 +590,12 @@ static void kvmclock_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用kvm_update_clock():
+     *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+     *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+     *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+     */
     kvm_update_clock(s);
 
     qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
@@ -258,11 +627,54 @@ static int kvmclock_pre_load(void *opaque)
 {
     KVMClockState *s = opaque;
 
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     s->clock_is_reliable = false;
 
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x55555790d7e0, 
+ *     version_id=1, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, 
+ *     vmdesc_id=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x555557dad630, se=0x555557902320, vmdesc=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x555557dad630, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:282
+ * #1  0x0000555555f40775 in vmstate_save_state_v (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x55555790d7e0,
+ *     version_id=1, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:407
+ * #2  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:395
+ * #3  0x0000555555c79ef9 in vmstate_save (f=0x555557dad630, se=0x555557902320, vmdesc=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/savevm.c:1052
+ * #4  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x555557dad630, in_postcopy=false) at ../migration/savevm.c:1669
+ * #5  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1712
+ * #6  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 /*
  * When migrating a running guest, read the clock just
  * before migration, so that the guest clock counts
@@ -282,12 +694,22 @@ static int kvmclock_pre_save(void *opaque)
     KVMClockState *s = opaque;
 
     if (!s->runstate_paused) {
+        /*
+	 * 在以下使用kvm_update_clock():
+	 *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+	 */
         kvm_update_clock(s);
     }
 
     return 0;
 }
 
+/*
+ * 在以下使用kvmclock_vmsd:
+ *   - hw/i386/kvm/clock.c|664| <<kvmclock_class_init>> dc->vmsd = &kvmclock_vmsd;
+ */
 static const VMStateDescription kvmclock_vmsd = {
     .name = "kvmclock",
     .version_id = 1,
@@ -325,6 +747,12 @@ static const TypeInfo kvmclock_info = {
     .class_init    = kvmclock_class_init,
 };
 
+/*
+ * 在以下使用kvmclock_create():
+ *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+ *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+ *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+ */
 /* Note: Must be called after VCPU initialization. */
 void kvmclock_create(bool create_always)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 2f58e73d3..fa7ee73be 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1712,6 +1712,16 @@ static void pc_machine_reset(MachineState *machine, ResetType type)
 
 static void pc_machine_wakeup(MachineState *machine)
 {
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
     pc_machine_reset(machine, RESET_TYPE_WAKEUP);
     cpu_synchronize_all_post_reset();
@@ -1751,6 +1761,14 @@ static void pc_machine_class_init(ObjectClass *oc, const void *data)
     pcmc->enforce_amd_1tb_hole = true;
     pcmc->isa_bios_alias = true;
     pcmc->pvh_enabled = true;
+    /*
+     * 在以下使用PCMachineClass->kvmclock_create_always:
+     *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+     *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     */
     pcmc->kvmclock_create_always = true;
     x86mc->apic_xrupt_override = true;
     assert(!mc->get_hotplug_handler);
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index c03324281..89a629ca8 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -193,6 +193,14 @@ static void pc_init1(MachineState *machine, const char *pci_type)
     x86_cpus_init(x86ms, pcmc->default_cpu_version);
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用PCMachineClass->kvmclock_create_always:
+         *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+         *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+         *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+         *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+         *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+	 */
         kvmclock_create(pcmc->kvmclock_create_always);
     }
 
@@ -666,6 +674,14 @@ static void pc_i440fx_machine_5_1_options(MachineClass *m)
     pc_i440fx_machine_5_2_options(m);
     compat_props_add(m->compat_props, hw_compat_5_1, hw_compat_5_1_len);
     compat_props_add(m->compat_props, pc_compat_5_1, pc_compat_5_1_len);
+    /*
+     * 在以下使用PCMachineClass->kvmclock_create_always:
+     *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+     *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     */
     pcmc->kvmclock_create_always = false;
     pcmc->pci_root_uid = 1;
 }
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index b309b2b37..ae27377d8 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -194,6 +194,14 @@ static void pc_q35_init(MachineState *machine)
     x86_cpus_init(x86ms, pcmc->default_cpu_version);
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用PCMachineClass->kvmclock_create_always:
+         *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+         *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+         *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+         *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+         *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+	 */
         kvmclock_create(pcmc->kvmclock_create_always);
     }
 
@@ -532,6 +540,14 @@ static void pc_q35_machine_5_1_options(MachineClass *m)
     pc_q35_machine_5_2_options(m);
     compat_props_add(m->compat_props, hw_compat_5_1, hw_compat_5_1_len);
     compat_props_add(m->compat_props, pc_compat_5_1, pc_compat_5_1_len);
+    /*
+     * 在以下使用PCMachineClass->kvmclock_create_always:
+     *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+     *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     */
     pcmc->kvmclock_create_always = false;
     pcmc->pci_root_uid = 1;
 }
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index 6b5b5dace..46e14eb9d 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -688,6 +688,10 @@ default_value:
     return VIRTIO_NET_TX_QUEUE_DEFAULT_SIZE;
 }
 
+/*
+ * 在以下使用peer_attach():
+ *   - hw/net/virtio-net.c|754| <<virtio_net_set_queue_pairs>> r = peer_attach(n, i);
+ */
 static int peer_attach(VirtIONet *n, int index)
 {
     NetClientState *nc = qemu_get_subqueue(n->nic, index);
@@ -713,6 +717,10 @@ static int peer_attach(VirtIONet *n, int index)
     return tap_enable(nc->peer);
 }
 
+/*
+ * 在以下使用peer_detach():
+ *   - hw/net/virtio-net.c|757| <<virtio_net_set_queue_pairs>> r = peer_detach(n, i);
+ */
 static int peer_detach(VirtIONet *n, int index)
 {
     NetClientState *nc = qemu_get_subqueue(n->nic, index);
@@ -734,6 +742,12 @@ static int peer_detach(VirtIONet *n, int index)
     return tap_disable(nc->peer);
 }
 
+/*
+ * 在以下使用virtio_net_set_queue_pairs():
+ *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+ *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+ *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+ */
 static void virtio_net_set_queue_pairs(VirtIONet *n)
 {
     int i;
@@ -743,7 +757,25 @@ static void virtio_net_set_queue_pairs(VirtIONet *n)
         return;
     }
 
+    /*
+     * VirtIONet *n:
+     * -> uint16_t max_queue_pairs;
+     * -> uint16_t curr_queue_pairs;
+     *
+     *
+     * 在以下修改VirtIONet->max_queue_pairs:
+     *   - hw/net/virtio-net.c|3562| <<global>> VMSTATE_SINGLE_TEST(max_queue_pairs, VirtIONet, max_queue_pairs_gt_1, 0,
+     *   - hw/net/virtio-net.c|3897| <<virtio_net_device_realize>> ++n->max_queue_pairs;
+     *   - hw/net/virtio-net.c|3901| <<virtio_net_device_realize>> n->max_queue_pairs = MAX(n->max_queue_pairs, 1);
+     */
     for (i = 0; i < n->max_queue_pairs; i++) {
+        /*
+	 * 在以下修改VirtIONet->curr_queue_pairs:
+         *   - hw/net/virtio-net.c|3564| <<global>> VMSTATE_UINT16_TEST(curr_queue_pairs, VirtIONet, max_queue_pairs_gt_1),
+         *   - hw/net/virtio-net.c|1482| <<virtio_net_handle_mq>> n->curr_queue_pairs = queue_pairs;
+         *   - hw/net/virtio-net.c|3911| <<virtio_net_device_realize>> n->curr_queue_pairs = 1;
+         *   - hw/net/virtio-net.c|4057| <<virtio_net_reset>> n->curr_queue_pairs = 1;
+	 */
         if (i < n->curr_queue_pairs) {
             r = peer_attach(n, i);
             assert(!r);
@@ -1436,6 +1468,10 @@ error:
     return 0;
 }
 
+/*
+ * 在以下使用virtio_net_handle_mq():
+ *   - hw/net/virtio-net.c|1561| <<virtio_net_handle_ctrl_iov>> status = virtio_net_handle_mq(n, ctrl.cmd, iov, out_num);
+ */
 static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,
                                 struct iovec *iov, unsigned int iov_cnt)
 {
@@ -1460,6 +1496,13 @@ static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,
         if (s != sizeof(mq)) {
             return VIRTIO_NET_ERR;
         }
+        /*
+	 * struct virtio_net_ctrl_mq {
+         *     __virtio16 virtqueue_pairs;
+	 * };
+	 *
+	 * 似乎来自guest
+	 */
         queue_pairs = virtio_lduw_p(vdev, &mq.virtqueue_pairs);
 
     } else {
@@ -1484,6 +1527,12 @@ static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,
     /* stop the backend before changing the number of queue_pairs to avoid handling a
      * disabled queue */
     virtio_net_set_status(vdev, vdev->status);
+    /*
+     * 在以下使用virtio_net_set_queue_pairs():
+     *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+     */
     virtio_net_set_queue_pairs(n);
 
     return VIRTIO_NET_OK;
@@ -2999,6 +3048,12 @@ static void virtio_net_set_multiqueue(VirtIONet *n, int multiqueue)
     n->multiqueue = multiqueue;
     virtio_net_change_num_queues(n, max * 2 + 1);
 
+    /*
+     * 在以下使用virtio_net_set_queue_pairs():
+     *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+     */
     virtio_net_set_queue_pairs(n);
 }
 
@@ -3136,6 +3191,12 @@ static int virtio_net_post_load_device(void *opaque, int version_id)
      */
     n->saved_guest_offloads = n->curr_guest_offloads;
 
+    /*
+     * 在以下使用virtio_net_set_queue_pairs():
+     *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+     */
     virtio_net_set_queue_pairs(n);
 
     /* Find the first multicast entry in the saved MAC filter */
@@ -3861,6 +3922,15 @@ static void virtio_net_device_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用VirtIONet->max_ncs:
+     *   - hw/net/virtio-net.c|269| <<virtio_net_vhost_status>> int cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     *   - hw/net/virtio-net.c|3899| <<virtio_net_device_realize>> n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
+     *   - hw/net/virtio-net.c|3906| <<virtio_net_device_realize>> for (i = 0; i < n->max_ncs; i++) {
+     *   - net/vhost-vdpa.c|358| <<vhost_vdpa_net_log_global_enable>> cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     */
     n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
 
     /*
@@ -3868,6 +3938,15 @@ static void virtio_net_device_realize(DeviceState *dev, Error **errp)
      * provide control queue via peers as well.
      */
     if (n->nic_conf.peers.queues) {
+        /*
+         * 在以下使用VirtIONet->max_ncs:
+         *   - hw/net/virtio-net.c|269| <<virtio_net_vhost_status>> int cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+         *                   ? n->max_ncs - n->max_queue_pairs : 0;
+         *   - hw/net/virtio-net.c|3899| <<virtio_net_device_realize>> n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
+         *   - hw/net/virtio-net.c|3906| <<virtio_net_device_realize>> for (i = 0; i < n->max_ncs; i++) {
+         *   - net/vhost-vdpa.c|358| <<vhost_vdpa_net_log_global_enable>> cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+         *                   ? n->max_ncs - n->max_queue_pairs : 0;
+	 */
         for (i = 0; i < n->max_ncs; i++) {
             if (n->nic_conf.peers.ncs[i]->is_datapath) {
                 ++n->max_queue_pairs;
diff --git a/hw/vfio/migration.c b/hw/vfio/migration.c
index 4c06e3db9..a4f0f126e 100644
--- a/hw/vfio/migration.c
+++ b/hw/vfio/migration.c
@@ -1017,6 +1017,17 @@ static int vfio_migration_init(VFIODevice *vbasedev)
     }
     strpadcpy(id, sizeof(id), path, '\0');
 
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
                          vbasedev);
 
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 07257d0fa..63399a847 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -1013,9 +1013,28 @@ static void vfio_update_msi(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * 在以下使用vfio_pci_load_rom():
+ *   - hw/vfio/pci.c|1135| <<vfio_rom_read>> vfio_pci_load_rom(vdev);
+ */
 static void vfio_pci_load_rom(VFIOPCIDevice *vdev)
 {
     VFIODevice *vbasedev = &vdev->vbasedev;
+    /*
+     * 271 struct vfio_region_info {
+     * 272         __u32   argsz;
+     * 273         __u32   flags;
+     * 274 #define VFIO_REGION_INFO_FLAG_READ      (1 << 0) // Region supports read
+     * 275 #define VFIO_REGION_INFO_FLAG_WRITE     (1 << 1) // Region supports write
+     * 276 #define VFIO_REGION_INFO_FLAG_MMAP      (1 << 2) // Region supports mmap
+     * 277 #define VFIO_REGION_INFO_FLAG_CAPS      (1 << 3) // Info supports caps
+     * 278         __u32   index;          // Region index
+     * 279         __u32   cap_offset;     // Offset within info struct of first cap
+     * 280         __aligned_u64   size;   // Region size (bytes)
+     * 281         __aligned_u64   offset; // Region offset from start of device fd
+     * 282 };
+     * 283 #define VFIO_DEVICE_GET_REGION_INFO     _IO(VFIO_TYPE, VFIO_BASE + 8)
+     */
     struct vfio_region_info *reg_info = NULL;
     uint64_t size;
     off_t off = 0;
@@ -1035,6 +1054,10 @@ static void vfio_pci_load_rom(VFIOPCIDevice *vdev)
                             (unsigned long)reg_info->flags);
 
     vdev->rom_size = size = reg_info->size;
+    /*
+     * 在以下使用VFIOPCIDevice->rom_offset:
+     *   - hw/vfio/pci.c|1038| <<vfio_pci_load_rom>> vdev->rom_offset = reg_info->offset;
+     */
     vdev->rom_offset = reg_info->offset;
 
     if (!vdev->rom_size) {
@@ -1046,6 +1069,12 @@ static void vfio_pci_load_rom(VFIOPCIDevice *vdev)
         return;
     }
 
+    /*
+     * struct VFIOPCIDevice:
+     * -> unsigned int rom_size;
+     * -> off_t rom_offset;
+     * -> void *rom;
+     */
     vdev->rom = g_malloc(size);
     memset(vdev->rom, 0xff, size);
 
@@ -1119,6 +1148,13 @@ static int vfio_pci_config_space_write(VFIOPCIDevice *vdev, off_t offset,
                                                offset, size, data, false);
 }
 
+/*
+ * 1191 static const MemoryRegionOps vfio_rom_ops = {
+ * 1192     .read = vfio_rom_read,
+ * 1193     .write = vfio_rom_write,
+ * 1194     .endianness = DEVICE_LITTLE_ENDIAN,
+ * 1195 };
+ */
 static uint64_t vfio_rom_read(void *opaque, hwaddr addr, unsigned size)
 {
     VFIOPCIDevice *vdev = opaque;
diff --git a/hw/vfio/pci.h b/hw/vfio/pci.h
index 810a842f4..9e63eb573 100644
--- a/hw/vfio/pci.h
+++ b/hw/vfio/pci.h
@@ -130,6 +130,10 @@ struct VFIOPCIDevice {
     uint8_t *emulated_config_bits; /* QEMU emulated bits, little-endian */
     off_t config_offset; /* Offset of config space region within device fd */
     unsigned int rom_size;
+    /*
+     * 在以下使用VFIOPCIDevice->rom_offset:
+     *   - hw/vfio/pci.c|1038| <<vfio_pci_load_rom>> vdev->rom_offset = reg_info->offset;
+     */
     off_t rom_offset; /* Offset of ROM region within device fd */
     void *rom;
     int msi_cap_size;
@@ -173,6 +177,12 @@ struct VFIOPCIDevice {
     bool req_enabled;
     bool has_flr;
     bool has_pm_reset;
+    /*
+     * 在以下使用VFIOPCIDevice->rom_read_failed:
+     *   - hw/vfio/pci.c|1041| <<vfio_pci_load_rom>> vdev->rom_read_failed = true;
+     *   - hw/vfio/pci.c|1134| <<vfio_rom_read>> if (unlikely(!vdev->rom && !vdev->rom_read_failed)) {
+     *   - hw/vfio/pci.c|1235| <<vfio_pci_size_rom>> vdev->rom_read_failed = false;
+     */
     bool rom_read_failed;
     bool no_kvm_intx;
     bool no_kvm_msi;
diff --git a/include/accel/accel-cpu-ops.h b/include/accel/accel-cpu-ops.h
index 067476491..ff55112b2 100644
--- a/include/accel/accel-cpu-ops.h
+++ b/include/accel/accel-cpu-ops.h
@@ -49,7 +49,25 @@ struct AccelOpsClass {
      * Request to synchronize QEMU vCPU registers to the hardware accelerator
      * (QEMU is the reference).
      */
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_reset():
+     *   - accel/hvf/hvf-accel-ops.c|380| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|100| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - system/cpus.c|289| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - system/cpus.c|290| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     void (*synchronize_post_reset)(CPUState *cpu);
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     void (*synchronize_post_init)(CPUState *cpu);
     /**
      * synchronize_state:
@@ -59,7 +77,25 @@ struct AccelOpsClass {
      * Request to synchronize QEMU vCPU registers from the hardware accelerator
      * (the hardware accelerator is the reference).
      */
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state():
+     *   - accel/hvf/hvf-accel-ops.c|382| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|111| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - system/cpus.c|204| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|205| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|94| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|97| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     void (*synchronize_state)(CPUState *cpu);
+    /*
+     * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+     *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+     *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+     *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+     *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+     */
     void (*synchronize_pre_loadvm)(CPUState *cpu);
 
     /* handle_interrupt is mandatory. */
diff --git a/include/hw/i386/pc.h b/include/hw/i386/pc.h
index 79b72c54d..8952dfbbd 100644
--- a/include/hw/i386/pc.h
+++ b/include/hw/i386/pc.h
@@ -116,6 +116,14 @@ struct PCMachineClass {
     /* use PVH to load kernels that support this feature */
     bool pvh_enabled;
 
+    /*
+     * 在以下使用PCMachineClass->kvmclock_create_always:
+     *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+     *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     */
     /* create kvmclock device even when KVM PV features are not exposed */
     bool kvmclock_create_always;
 
diff --git a/include/hw/virtio/virtio-net.h b/include/hw/virtio/virtio-net.h
index 73fdefc0d..e6bfe912a 100644
--- a/include/hw/virtio/virtio-net.h
+++ b/include/hw/virtio/virtio-net.h
@@ -207,8 +207,30 @@ struct VirtIONet {
     NICConf nic_conf;
     DeviceState *qdev;
     int multiqueue;
+    /*
+     * 在以下修改VirtIONet->max_queue_pairs:
+     *   - hw/net/virtio-net.c|3562| <<global>> VMSTATE_SINGLE_TEST(max_queue_pairs, VirtIONet, max_queue_pairs_gt_1, 0,
+     *   - hw/net/virtio-net.c|3897| <<virtio_net_device_realize>> ++n->max_queue_pairs;
+     *   - hw/net/virtio-net.c|3901| <<virtio_net_device_realize>> n->max_queue_pairs = MAX(n->max_queue_pairs, 1);
+     */
     uint16_t max_queue_pairs;
+    /*
+     * 在以下修改VirtIONet->curr_queue_pairs:
+     *   - hw/net/virtio-net.c|1482| <<virtio_net_handle_mq>> n->curr_queue_pairs = queue_pairs;
+     *   - hw/net/virtio-net.c|3911| <<virtio_net_device_realize>> n->curr_queue_pairs = 1;
+     *   - hw/net/virtio-net.c|4057| <<virtio_net_reset>> n->curr_queue_pairs = 1;
+     *   - hw/net/virtio-net.c|3564| <<global>> VMSTATE_UINT16_TEST(curr_queue_pairs, VirtIONet, max_queue_pairs_gt_1),
+     */
     uint16_t curr_queue_pairs;
+    /*
+     * 在以下使用VirtIONet->max_ncs:
+     *   - hw/net/virtio-net.c|269| <<virtio_net_vhost_status>> int cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     *   - hw/net/virtio-net.c|3899| <<virtio_net_device_realize>> n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
+     *   - hw/net/virtio-net.c|3906| <<virtio_net_device_realize>> for (i = 0; i < n->max_ncs; i++) {
+     *   - net/vhost-vdpa.c|358| <<vhost_vdpa_net_log_global_enable>> cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     */
     uint16_t max_ncs;
     size_t config_size;
     char *netclient_name;
diff --git a/include/migration/vmstate.h b/include/migration/vmstate.h
index 1ff7bd9ac..f07b95777 100644
--- a/include/migration/vmstate.h
+++ b/include/migration/vmstate.h
@@ -1225,6 +1225,28 @@ int vmstate_register_with_alias_id(VMStateIf *obj, uint32_t instance_id,
  *
  * Returns: 0 on success, -1 on failure
  */
+/*
+ * 在以下使用vmstate_register():
+ *   - hw/arm/virt-acpi-build.c|1254| <<virt_acpi_setup>> vmstate_register(NULL, 0, &vmstate_virt_acpi_build, build_state);
+ *   - hw/core/cpu-system.c|289| <<cpu_vmstate_register>> vmstate_register(NULL, cpu->cpu_index, &vmstate_cpu_common, cpu);
+ *   - hw/core/cpu-system.c|292| <<cpu_vmstate_register>> vmstate_register(NULL, cpu->cpu_index,
+ *   - hw/i386/acpi-build.c|2241| <<acpi_setup>> vmstate_register(NULL, 0, &vmstate_acpi_build, build_state);
+ *   - hw/loongarch/virt-acpi-build.c|737| <<virt_acpi_setup>> vmstate_register(NULL, 0, &vmstate_acpi_build, build_state);
+ *   - hw/openrisc/cputimer.c|167| <<cpu_openrisc_clock_init>> vmstate_register(NULL, 0, &vmstate_or1k_timer, or1k_timer);
+ *   - hw/ppc/spapr.c|3102| <<spapr_machine_init>> vmstate_register(NULL, 0, &vmstate_spapr, spapr);
+ *   - hw/ppc/spapr_cpu_core.c|294| <<spapr_realize_vcpu>> vmstate_register(NULL, cs->cpu_index, &vmstate_spapr_cpu_state,
+ *   - hw/ppc/spapr_drc.c|547| <<drc_realize>> vmstate_register(VMSTATE_IF(drc), spapr_drc_index(drc), &vmstate_spapr_drc,
+ *   - hw/ppc/spapr_drc.c|653| <<realize_physical>> vmstate_register(VMSTATE_IF(drcp),
+ *   - hw/ppc/spapr_iommu.c|325| <<spapr_tce_table_realize>> vmstate_register(VMSTATE_IF(tcet), tcet->liobn, &vmstate_spapr_tce_table,
+ *   - hw/riscv/virt-acpi-build.c|1030| <<virt_acpi_setup>> vmstate_register(NULL, 0, &vmstate_virt_acpi_build, build_state);
+ *   - hw/s390x/css.c|390| <<css_register_vmstate>> vmstate_register(NULL, 0, &vmstate_css, &channel_subsys);
+ *   - hw/vfio/cpr-iommufd.c|165| <<vfio_iommufd_cpr_register_iommufd>> vmstate_register(NULL, -1, &iommufd_cpr_vmstate, be);
+ *   - hw/vfio/cpr-legacy.c|184| <<vfio_legacy_cpr_register_container>> vmstate_register(NULL, -1, &vfio_container_vmstate, container);
+ *   - migration/global_state.c|153| <<register_global_state>> vmstate_register(NULL, 0, &vmstate_globalstate, &global_state);
+ *   - replay/replay-snapshot.c|70| <<replay_vmstate_register>> vmstate_register(NULL, 0, &vmstate_replay, &replay_state);
+ *   - system/cpu-timers.c|274| <<cpu_timers_init>> vmstate_register(NULL, 0, &vmstate_timers, &timers_state);
+ *   - target/arm/hvf/hvf.c|2174| <<hvf_arch_init>> vmstate_register(NULL, 0, &vmstate_hvf_vtimer, &vtimer);
+ */
 static inline int vmstate_register(VMStateIf *obj, int instance_id,
                                    const VMStateDescription *vmsd,
                                    void *opaque)
diff --git a/include/system/kvm_int.h b/include/system/kvm_int.h
index 9247493b0..2163f7f5e 100644
--- a/include/system/kvm_int.h
+++ b/include/system/kvm_int.h
@@ -156,6 +156,13 @@ struct KVMState
     } *as;
     uint64_t kvm_dirty_ring_bytes;  /* Size of the per-vcpu dirty ring */
     uint32_t kvm_dirty_ring_size;   /* Number of dirty GFNs per ring */
+    /*
+     * 在以下使用KVMState->kvm_dirty_ring_with_bitmap:
+     *   - accel/kvm/kvm-all.c|1559| <<kvm_set_phys_mem>> if (kvm_state->kvm_dirty_ring_with_bitmap) {
+     *   - accel/kvm/kvm-all.c|1723| <<kvm_dirty_ring_init>> s->kvm_dirty_ring_with_bitmap = true;
+     *   - accel/kvm/kvm-all.c|1853| <<kvm_log_sync_global>> if (s->kvm_dirty_ring_with_bitmap && last_stage &&
+     *   - accel/kvm/kvm-all.c|4054| <<kvm_accel_instance_init>> s->kvm_dirty_ring_with_bitmap = false;
+     */
     bool kvm_dirty_ring_with_bitmap;
     uint64_t kvm_eager_split_size;  /* Eager Page Splitting chunk size */
     struct KVMDirtyRingReaper reaper;
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 32c5885a3..acf0d6196 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -48,6 +48,13 @@ struct kvm_userspace_memory_region2 {
  * userspace, other bits are reserved for kvm internal use which are defined
  * in include/linux/kvm_host.h.
  */
+/*
+ * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+ *   - accel/kvm/kvm-all.c|660| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+ *   - accel/kvm/kvm-all.c|772| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+ *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+ *   - accel/kvm/kvm-all.c|1864| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+ */
 #define KVM_MEM_LOG_DIRTY_PAGES	(1UL << 0)
 #define KVM_MEM_READONLY	(1UL << 1)
 #define KVM_MEM_GUEST_MEMFD	(1UL << 2)
diff --git a/migration/block-dirty-bitmap.c b/migration/block-dirty-bitmap.c
index a061aad81..dd3bde16c 100644
--- a/migration/block-dirty-bitmap.c
+++ b/migration/block-dirty-bitmap.c
@@ -1264,6 +1264,17 @@ void dirty_bitmap_mig_init(void)
     QSIMPLEQ_INIT(&dbm_state.save.dbms_list);
     qemu_mutex_init(&dbm_state.load.lock);
 
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live("dirty-bitmap", 0, 1,
                          &savevm_dirty_bitmap_handlers,
                          &dbm_state);
diff --git a/migration/channel.c b/migration/channel.c
index a547b1fbf..971c2c426 100644
--- a/migration/channel.c
+++ b/migration/channel.c
@@ -30,6 +30,14 @@
  *
  * @ioc: Channel to which we are connecting
  */
+/*
+ * 在以下使用migration_channel_process_incoming():
+ *   - migration/exec.c|66| <<exec_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/fd.c|81| <<fd_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/file.c|132| <<file_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/socket.c|132| <<socket_accept_incoming_migration>> migration_channel_process_incoming(QIO_CHANNEL(cioc));
+ *   - migration/tls.c|69| <<migration_tls_incoming_handshake>> migration_channel_process_incoming(ioc);
+ */
 void migration_channel_process_incoming(QIOChannel *ioc)
 {
     MigrationState *s = migrate_get_current();
@@ -43,6 +51,9 @@ void migration_channel_process_incoming(QIOChannel *ioc)
         migration_tls_channel_process_incoming(s, ioc, &local_err);
     } else {
         migration_ioc_register_yank(ioc);
+        /*
+	 * 只在这里调用
+	 */
         migration_ioc_process_incoming(ioc, &local_err);
     }
 
@@ -64,6 +75,14 @@ void migration_channel_process_incoming(QIOChannel *ioc)
  * @hostname: Where we want to connect
  * @error: Error indicating failure to connect, free'd here
  */
+/*
+ * 在以下使用migration_channel_connect():
+ *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+ *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+ *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+ *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+ *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+ */
 void migration_channel_connect(MigrationState *s,
                                QIOChannel *ioc,
                                const char *hostname,
@@ -94,6 +113,11 @@ void migration_channel_connect(MigrationState *s,
             qemu_mutex_unlock(&s->qemu_file_lock);
         }
     }
+    /*
+     * 在以下使用migration_connect():
+     *   - migration/channel.c|108| <<migration_channel_connect>> migration_connect(s, error);
+     *   - migration/rdma.c|4002| <<rdma_start_outgoing_migration>> migration_connect(s, NULL);
+     */
     migration_connect(s, error);
     error_free(error);
 }
diff --git a/migration/colo.c b/migration/colo.c
index e0f713c83..407cdbe97 100644
--- a/migration/colo.c
+++ b/migration/colo.c
@@ -685,6 +685,16 @@ static void colo_incoming_process_checkpoint(MigrationIncomingState *mis,
     }
 
     bql_lock();
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
     ret = qemu_loadvm_state_main(mis->from_src_file, mis);
     bql_unlock();
diff --git a/migration/exec.c b/migration/exec.c
index 20e6cccf8..d52deff22 100644
--- a/migration/exec.c
+++ b/migration/exec.c
@@ -55,6 +55,14 @@ void exec_start_outgoing_migration(MigrationState *s, strList *command,
     }
 
     qio_channel_set_name(ioc, "migration-exec-outgoing");
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, NULL);
     object_unref(OBJECT(ioc));
 }
diff --git a/migration/fd.c b/migration/fd.c
index 9bf9be6ac..e86b00fdd 100644
--- a/migration/fd.c
+++ b/migration/fd.c
@@ -70,6 +70,14 @@ void fd_start_outgoing_migration(MigrationState *s, const char *fdname, Error **
     }
 
     qio_channel_set_name(ioc, "migration-fd-outgoing");
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, NULL);
     object_unref(OBJECT(ioc));
 }
diff --git a/migration/file.c b/migration/file.c
index bb8031e3c..9789c1035 100644
--- a/migration/file.c
+++ b/migration/file.c
@@ -122,9 +122,24 @@ void file_start_outgoing_migration(MigrationState *s,
         return;
     }
     qio_channel_set_name(ioc, "migration-file-outgoing");
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, NULL);
 }
 
+/*
+ * 在以下使用file_accept_incoming_migration():
+ *   - migration/file.c|170| <<file_create_incoming_channels>> qio_channel_add_watch_full(iocs[i], G_IO_IN,
+ *                                                    file_accept_incoming_migration,
+ *                                                    NULL, NULL,
+ *                                                    g_main_context_get_thread_default());
+ */
 static gboolean file_accept_incoming_migration(QIOChannel *ioc,
                                                GIOCondition condition,
                                                gpointer opaque)
diff --git a/migration/migration.c b/migration/migration.c
index 10c216d25..2eb8f7303 100644
--- a/migration/migration.c
+++ b/migration/migration.c
@@ -113,6 +113,10 @@ static bool close_return_path_on_source(MigrationState *s);
 static void migration_completion_end(MigrationState *s);
 static void migrate_hup_delete(MigrationState *s);
 
+/*
+ * 在以下使用migration_downtime_start():
+ *   - migration/migration.c|311| <<migration_stop_vm>> migration_downtime_start(s);
+ */
 static void migration_downtime_start(MigrationState *s)
 {
     trace_vmstate_downtime_checkpoint("src-downtime-start");
@@ -140,6 +144,12 @@ static void migrate_incoming_unref_outgoing_state(void)
     object_unref(migrate_get_current());
 }
 
+/*
+ * 在以下使用migration_downtime_end():
+ *   - migration/migration.c|3005| <<postcopy_start>> migration_downtime_end(ms);
+ *   - migration/migration.c|3603| <<migration_completion_end>> migration_downtime_end(s);
+ *   - migration/migration.c|4113| <<bg_migration_vm_start_bh>> migration_downtime_end(s);
+ */
 static void migration_downtime_end(MigrationState *s)
 {
     int64_t now = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);
@@ -287,6 +297,23 @@ static gint page_request_addr_cmp(gconstpointer ap, gconstpointer bp)
     return (a > b) - (a < b);
 }
 
+/*
+ * (gdb) bt
+ * #0  migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:292
+ * #1  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #2  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #3  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #4  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用migration_stop_vm():
+ *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+ *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+ *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+ *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+ */
 static int migration_stop_vm(MigrationState *s, RunState state)
 {
     int ret;
@@ -296,6 +323,13 @@ static int migration_stop_vm(MigrationState *s, RunState state)
     s->vm_old_state = runstate_get();
     global_state_store();
 
+    /*
+     * 在以下使用vm_stop_force_state():
+     *   - migration/colo.c|216| <<colo_do_failover>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/colo.c|432| <<colo_do_checkpoint_transaction>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/colo.c|668| <<colo_incoming_process_checkpoint>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/migration.c|306| <<migration_stop_vm>> ret = vm_stop_force_state(state);
+     */
     ret = vm_stop_force_state(state);
 
     trace_vmstate_downtime_checkpoint("src-vm-stopped");
@@ -321,6 +355,13 @@ void migration_object_init(void)
         g_array_new(FALSE, TRUE, sizeof(struct PostCopyFD));
     qemu_mutex_init(&current_incoming->rp_mutex);
     qemu_mutex_init(&current_incoming->postcopy_prio_thread_mutex);
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     qemu_event_init(&current_incoming->main_thread_load_event, false);
     qemu_sem_init(&current_incoming->postcopy_pause_sem_dst, 0);
     qemu_sem_init(&current_incoming->postcopy_pause_sem_fault, 0);
@@ -348,6 +389,10 @@ typedef struct {
     void *opaque;
 } MigrationBH;
 
+/*
+ * 在以下使用migration_bh_dispatch_bh():
+ *   - migration/migration.c|395| <<migration_bh_schedule>> QEMUBH *bh = qemu_bh_new(migration_bh_dispatch_bh, migbh);
+ */
 static void migration_bh_dispatch_bh(void *opaque)
 {
     MigrationState *s = migrate_get_current();
@@ -364,6 +409,24 @@ static void migration_bh_dispatch_bh(void *opaque)
     g_free(migbh);
 }
 
+/*
+ * 在Target上.
+ * (gdb) bt
+ * #0  migration_bh_schedule (cb=0x555555c5fee6 <process_incoming_migration_bh>, opaque=0x5555575e2e00) at ../migration/migration.c:369
+ * #1  0x0000555555c601c6 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:920
+ * #2  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #3  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #4  0x00007fffffffc7e0 in ?? ()
+ * #5  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用migration_bh_schedule():
+ *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+ *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+ *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+ *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+ *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+ */
 void migration_bh_schedule(QEMUBHFunc *cb, void *opaque)
 {
     MigrationState *s = migrate_get_current();
@@ -481,6 +544,13 @@ void migration_incoming_state_destroy(void)
     }
 
     migration_incoming_transport_cleanup(mis);
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     qemu_event_reset(&mis->main_thread_load_event);
 
     if (mis->page_requested) {
@@ -809,6 +879,36 @@ static void qemu_start_incoming_migration(const char *uri, bool has_channels,
     cpr_state_close();
 }
 
+/*
+ * (gdb) bt
+ * #0  migration_bh_schedule (cb=0x555555c5fee6 <process_incoming_migration_bh>, opaque=0x5555575e2e00) at ../migration/migration.c:369
+ * #1  0x0000555555c601c6 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:920
+ * #2  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #3  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #4  0x00007fffffffc7e0 in ?? ()
+ * #5  0x0000000000000000 in ?? ()
+ *
+ *
+ * (gdb) bt
+ * #0  process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:814
+ * #1  0x0000555555c5ed01 in migration_bh_dispatch_bh (opaque=0x555558143a20) at ../migration/migration.c:361
+ * #2  0x0000555556170433 in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #3  0x0000555556170581 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #4  0x00005555561500fb in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #5  0x0000555556170a50 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #6  0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #7  g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #8  0x0000555556172240 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #9  0x00005555561722ce in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #10 0x00005555561723fd in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #11 0x0000555555c38d08 in qemu_main_loop () at ../system/runstate.c:905
+ * #12 0x0000555556082abe in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #13 0x0000555556082b78 in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用process_incoming_migration_bh():
+ *   - migration/migration.c|944| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+ */
 static void process_incoming_migration_bh(void *opaque)
 {
     MigrationIncomingState *mis = opaque;
@@ -842,6 +942,23 @@ static void process_incoming_migration_bh(void *opaque)
              * metadata.  If error, don't restart the VM yet.
              */
             if (migration_block_activate(NULL)) {
+                /*
+		 * 在以下使用vm_start():
+                 *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+                 *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+                 *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+                 *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+                 *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+                 *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+                 *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+                 *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+                 *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+                 *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+                 *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+                 *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+                 *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+                 *   - system/cpus.c|793| <<vm_resume>> vm_start();
+		 */
                 vm_start();
             }
         } else {
@@ -864,6 +981,18 @@ static void process_incoming_migration_bh(void *opaque)
     migration_incoming_state_destroy();
 }
 
+/*
+ * (gdb) bt
+ * #0  process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:873
+ * #1  0x0000555556174e10 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #2  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #3  0x00007fffffffc7e0 in ?? ()
+ * #4  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用process_incoming_migration_co():
+ *   - migration/migration.c|983| <<migration_incoming_process>> Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
+ */
 static void coroutine_fn
 process_incoming_migration_co(void *opaque)
 {
@@ -881,6 +1010,12 @@ process_incoming_migration_co(void *opaque)
                       MIGRATION_STATUS_ACTIVE);
 
     mis->loadvm_co = qemu_coroutine_self();
+    /*
+     * 在以下使用qemu_loadvm_state():
+     *   - migration/migration.c|908| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file);
+     *   - migration/savevm.c|3581| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f);
+     *   - migration/savevm.c|3655| <<load_snapshot>> ret = qemu_loadvm_state(f);
+     */
     ret = qemu_loadvm_state(mis->from_src_file);
     mis->loadvm_co = NULL;
 
@@ -917,6 +1052,14 @@ process_incoming_migration_co(void *opaque)
         colo_incoming_co();
     }
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(process_incoming_migration_bh, mis);
     goto out;
 
@@ -954,6 +1097,11 @@ static void migration_incoming_setup(QEMUFile *f)
     qemu_file_set_blocking(f, false);
 }
 
+/*
+ * 在以下使用migration_incoming_process():
+ *   - migration/migration.c|1026| <<migration_fd_process_incoming>> migration_incoming_process();
+ *   - migration/migration.c|1129| <<migration_ioc_process_incoming>> migration_incoming_process();
+ */
 void migration_incoming_process(void)
 {
     Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
@@ -993,15 +1141,30 @@ static bool postcopy_try_recover(void)
     return false;
 }
 
+/*
+ * 在以下使用migration_fd_process_incoming():
+ *   - migration/rdma.c|3888| <<rdma_accept_incoming_migration>> migration_fd_process_incoming(f);
+ */
 void migration_fd_process_incoming(QEMUFile *f)
 {
     migration_incoming_setup(f);
     if (postcopy_try_recover()) {
         return;
     }
+    /*
+     * 在以下使用migration_incoming_process():
+     *   - migration/migration.c|1026| <<migration_fd_process_incoming>> migration_incoming_process();
+     *   - migration/migration.c|1129| <<migration_ioc_process_incoming>> migration_incoming_process();
+     */
     migration_incoming_process();
 }
 
+/*
+ * 在以下使用migration_has_main_and_multifd_channels():
+ *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+ *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+ *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+ */
 static bool migration_has_main_and_multifd_channels(void)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -1018,6 +1181,10 @@ static bool migration_has_main_and_multifd_channels(void)
     return true;
 }
 
+/*
+ * 在以下使用migration_ioc_process_incoming():
+ *   - migration/channel.c|46| <<migration_channel_process_incoming>> migration_ioc_process_incoming(ioc, &local_err);
+ */
 void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -1027,6 +1194,12 @@ void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
     uint32_t channel_magic = 0;
     int ret = 0;
 
+    /*
+     * 在以下使用migration_has_main_and_multifd_channels():
+     *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+     */
     if (!migration_has_main_and_multifd_channels()) {
         if (qio_channel_has_feature(ioc, QIO_CHANNEL_FEATURE_READ_MSG_PEEK)) {
             /*
@@ -1097,11 +1270,22 @@ void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用migration_has_main_and_multifd_channels():
+     *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+     */
     if (migration_has_main_and_multifd_channels()) {
         /* If it's a recovery, we're done */
         if (postcopy_try_recover()) {
             return;
         }
+        /*
+	 * 在以下使用migration_incoming_process():
+         *   - migration/migration.c|1026| <<migration_fd_process_incoming>> migration_incoming_process();
+         *   - migration/migration.c|1129| <<migration_ioc_process_incoming>> migration_incoming_process();
+	 */
         migration_incoming_process();
     }
 }
@@ -1114,6 +1298,12 @@ void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
  */
 bool migration_has_all_channels(void)
 {
+    /*
+     * 在以下使用migration_has_main_and_multifd_channels():
+     *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+     */
     if (!migration_has_main_and_multifd_channels()) {
         return false;
     }
@@ -2740,6 +2930,13 @@ static int postcopy_start(MigrationState *ms, Error **errp)
     bql_lock();
     trace_postcopy_start_set_run();
 
+    /*
+     * 在以下使用migration_stop_vm():
+     *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+     *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     */
     ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
     if (ret < 0) {
         error_setg_errno(errp, -ret, "%s: Failed to stop the VM", __func__);
@@ -2797,6 +2994,12 @@ static int postcopy_start(MigrationState *ms, Error **errp)
      */
     qemu_savevm_send_postcopy_listen(fb);
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+     *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+     *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+     *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+     */
     ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
     if (ret) {
         error_setg(errp, "Postcopy save non-iterable device states failed");
@@ -2971,6 +3174,75 @@ static bool migration_switchover_start(MigrationState *s, Error **errp)
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *   
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用migration_completion_precopy():
+ *   - migration/migration.c|3029| <<migration_completion>> ret = migration_completion_precopy(s);
+ */
 static int migration_completion_precopy(MigrationState *s)
 {
     int ret;
@@ -2978,6 +3250,13 @@ static int migration_completion_precopy(MigrationState *s)
     bql_lock();
 
     if (!migrate_mode_is_cpr(s)) {
+        /*
+	 * 在以下使用migration_stop_vm():
+	 *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+	 *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 */
         ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
         if (ret < 0) {
             goto out_unlock;
@@ -2989,6 +3268,12 @@ static int migration_completion_precopy(MigrationState *s)
         goto out_unlock;
     }
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy():
+     *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+     *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+     *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+     */
     ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
 out_unlock:
     bql_unlock();
@@ -3020,12 +3305,21 @@ static void migration_completion_postcopy(MigrationState *s)
  *
  * @s: Current migration state
  */
+/*
+ * 在以下使用migration_completion():
+ *   - migration/migration.c|3523| <<migration_iteration_run>> migration_completion(s);
+ *
+ * 似乎没有到最后的部分不会到这里
+ */
 static void migration_completion(MigrationState *s)
 {
     int ret = 0;
     Error *local_err = NULL;
 
     if (s->state == MIGRATION_STATUS_ACTIVE) {
+        /*
+	 * 只在这调用
+	 */
         ret = migration_completion_precopy(s);
     } else if (s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE) {
         migration_completion_postcopy(s);
@@ -3051,6 +3345,11 @@ static void migration_completion(MigrationState *s)
         migrate_set_state(&s->state, MIGRATION_STATUS_ACTIVE,
                           MIGRATION_STATUS_COLO);
     } else {
+        /*
+	 * 在以下使用migration_completion_end():
+         *   - migration/migration.c|3089| <<migration_completion>> migration_completion_end(s);
+         *   - migration/migration.c|3137| <<bg_migration_completion>> migration_completion_end(s);
+	 */
         migration_completion_end(s);
     }
 
@@ -3099,6 +3398,11 @@ static void bg_migration_completion(MigrationState *s)
         goto fail;
     }
 
+    /*
+     * 在以下使用migration_completion_end():
+     *   - migration/migration.c|3089| <<migration_completion>> migration_completion_end(s);
+     *   - migration/migration.c|3137| <<bg_migration_completion>> migration_completion_end(s);
+     */
     migration_completion_end(s);
     return;
 
@@ -3314,6 +3618,11 @@ static MigThrError migration_detect_error(MigrationState *s)
     }
 }
 
+/*
+ * 在以下使用migration_completion_end():
+ *   - migration/migration.c|3089| <<migration_completion>> migration_completion_end(s);
+ *   - migration/migration.c|3137| <<bg_migration_completion>> migration_completion_end(s);
+ */
 static void migration_completion_end(MigrationState *s)
 {
     uint64_t bytes = migration_transferred_bytes();
@@ -3435,6 +3744,10 @@ typedef enum {
  * Return true if continue to the next iteration directly, false
  * otherwise.
  */
+/*
+ * 在以下使用migration_iteration_run():
+ *   - migration/migration.c|3792| <<migration_thread>> MigIterateState iter_state = migration_iteration_run(s);
+ */
 static MigIterateState migration_iteration_run(MigrationState *s)
 {
     uint64_t must_precopy, can_postcopy, pending_size;
@@ -3463,6 +3776,9 @@ static MigIterateState migration_iteration_run(MigrationState *s)
          * during postcopy phase.
          */
         if (pending_size < s->threshold_size) {
+            /*
+	     * 只在这里调用
+	     */
             qemu_savevm_state_pending_exact(&must_precopy, &can_postcopy);
             pending_size = must_precopy + can_postcopy;
             trace_migrate_pending_exact(pending_size, must_precopy,
@@ -3500,6 +3816,10 @@ static MigIterateState migration_iteration_run(MigrationState *s)
     return MIG_ITERATE_RESUME;
 }
 
+/*
+ * 在以下使用migration_iteration_finish():
+ *   - migration/migration.c|3822| <<migration_thread>> migration_iteration_finish(s);
+ */
 static void migration_iteration_finish(MigrationState *s)
 {
     bql_lock();
@@ -3532,6 +3852,23 @@ static void migration_iteration_finish(MigrationState *s)
         migration_block_activate(NULL);
         if (runstate_is_live(s->vm_old_state)) {
             if (!runstate_check(RUN_STATE_SHUTDOWN)) {
+                /*
+		 * 在以下使用vm_start():
+		 *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+		 *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+		 *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+		 *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+		 *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+		 *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+		 *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+		 *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+		 *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+		 *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+		 *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+		 *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+		 *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+		 *   - system/cpus.c|793| <<vm_resume>> vm_start();
+		 */
                 vm_start();
             }
         } else {
@@ -3547,6 +3884,14 @@ static void migration_iteration_finish(MigrationState *s)
         break;
     }
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(migration_cleanup_bh, s);
     bql_unlock();
 }
@@ -3575,6 +3920,14 @@ static void bg_migration_iteration_finish(MigrationState *s)
         break;
     }
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(migration_cleanup_bh, s);
     bql_unlock();
 }
@@ -3683,6 +4036,11 @@ static void qemu_savevm_wait_unplug(MigrationState *s, int old_state,
  * Master migration thread on the source VM.
  * It drives the migration and pumps the data down the outgoing channel.
  */
+/*
+ * 在以下使用migration_thread():
+ *   - migration/migration.c|4389| <<migration_connect>> qemu_thread_create(&s->thread,
+ *               MIGRATION_THREAD_SRC_MAIN, migration_thread, s, QEMU_THREAD_JOINABLE);
+ */
 static void *migration_thread(void *opaque)
 {
     MigrationState *s = opaque;
@@ -3705,6 +4063,12 @@ static void *migration_thread(void *opaque)
     }
 
     bql_lock();
+    /*
+     * 在以下使用qemu_savevm_state_header():
+     *   - migration/migration.c|4024| <<migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/migration.c|4186| <<bg_migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/savevm.c|2010| <<qemu_savevm_state>> qemu_savevm_state_header(f);
+     */
     qemu_savevm_state_header(s->to_dst_file);
     bql_unlock();
 
@@ -3794,6 +4158,9 @@ static void *migration_thread(void *opaque)
 
 out:
     trace_migration_thread_after_loop();
+    /*
+     * 只在这里调用
+     */
     migration_iteration_finish(s);
     object_unref(OBJECT(s));
     rcu_unregister_thread();
@@ -3889,10 +4256,23 @@ static void *bg_migration_thread(void *opaque)
 
     bql_lock();
 
+    /*
+     * 在以下使用migration_stop_vm():
+     *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+     *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     */
     if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
         goto fail;
     }
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+     *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+     *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+     *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+     */
     if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
         goto fail;
     }
@@ -3914,6 +4294,14 @@ static void *bg_migration_thread(void *opaque)
      * calling VM state change notifiers from vm_start() would initiate
      * writes to virtio VQs memory which is in write-protected region.
      */
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(bg_migration_vm_start_bh, s);
     bql_unlock();
 
@@ -3956,6 +4344,11 @@ fail_setup:
     return NULL;
 }
 
+/*
+ * 在以下使用migration_connect():
+ *   - migration/channel.c|108| <<migration_channel_connect>> migration_connect(s, error);
+ *   - migration/rdma.c|4002| <<rdma_start_outgoing_migration>> migration_connect(s, NULL);
+ */
 void migration_connect(MigrationState *s, Error *error_in)
 {
     Error *local_err = NULL;
@@ -4034,6 +4427,13 @@ void migration_connect(MigrationState *s, Error *error_in)
     }
 
     if (migrate_mode_is_cpr(s)) {
+        /*
+	 * 在以下使用migration_stop_vm():
+	 *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+	 *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 */
         ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
         if (ret < 0) {
             error_setg(&local_err, "migration_stop_vm failed, error %d", -ret);
diff --git a/migration/migration.h b/migration/migration.h
index 01329bf82..4f7671f2b 100644
--- a/migration/migration.h
+++ b/migration/migration.h
@@ -105,6 +105,13 @@ struct MigrationIncomingState {
      * Free at the start of the main state load, set as the main thread finishes
      * loading state.
      */
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     QemuEvent main_thread_load_event;
 
     /* For network announces */
diff --git a/migration/ram.c b/migration/ram.c
index 7208bc114..fce370d94 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -4323,6 +4323,37 @@ static int ram_load_precopy(QEMUFile *f)
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  vm_start () at ../system/cpus.c:785
+ * #1  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #2  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x55555786f100) at ../migration/migration.c:361
+ * #3  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #4  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #5  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #6  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #7  0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #8  g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #9  0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #10 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #11 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #12 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #13 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #14 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * (gdb) bt
+ * #0  ram_load (f=0x5555578d3200, opaque=0x555557524aa0 <ram_state>, version_id=4) at ../migration/ram.c:4327
+ * #1  0x0000555555c79a9d in vmstate_load (f=0x5555578d3200, se=0x5555575e3220) at ../migration/savevm.c:970
+ * #2  0x0000555555c7da30 in qemu_loadvm_section_part_end (f=0x5555578d3200, type=2 '\002') at ../migration/savevm.c:2796
+ * #3  0x0000555555c7e40d in qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3056
+ * #4  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #5  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #6  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #7  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #8  0x00007fffffffc7e0 in ?? ()
+ * #9  0x0000000000000000 in ?? ()
+ */
 static int ram_load(QEMUFile *f, void *opaque, int version_id)
 {
     int ret = 0;
@@ -4638,6 +4669,17 @@ static RAMBlockNotifier ram_mig_ram_notifier = {
 void ram_mig_init(void)
 {
     qemu_mutex_init(&XBZRLE.lock);
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
     ram_block_notifier_add(&ram_mig_ram_notifier);
 }
diff --git a/migration/rdma.c b/migration/rdma.c
index 2d839fce6..459229008 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -3999,6 +3999,11 @@ void rdma_start_outgoing_migration(void *opaque,
 
     s->to_dst_file = rdma_new_output(rdma);
     s->rdma_migration = true;
+    /*
+     * 在以下使用migration_connect():
+     *   - migration/channel.c|108| <<migration_channel_connect>> migration_connect(s, error);
+     *   - migration/rdma.c|4002| <<rdma_start_outgoing_migration>> migration_connect(s, NULL);
+     */
     migration_connect(s, NULL);
     return;
 return_path_err:
diff --git a/migration/savevm.c b/migration/savevm.c
index fabbeb296..75b23987a 100644
--- a/migration/savevm.c
+++ b/migration/savevm.c
@@ -743,6 +743,11 @@ static inline MigrationPriority save_state_priority(SaveStateEntry *se)
     return MIG_PRI_DEFAULT;
 }
 
+/*
+ * 在以下使用savevm_state_handler_insert():
+ *   - migration/savevm.c|832| <<register_savevm_live>> savevm_state_handler_insert(se);
+ *   - migration/savevm.c|948| <<vmstate_register_with_alias_id>> savevm_state_handler_insert(se);
+ */
 static void savevm_state_handler_insert(SaveStateEntry *nse)
 {
     MigrationPriority priority = save_state_priority(nse);
@@ -798,6 +803,17 @@ static void savevm_state_handler_remove(SaveStateEntry *se)
     QTAILQ_REMOVE(&savevm_state.handlers, se, entry);
 }
 
+/*
+ * 在以下使用register_savevm_live():
+ *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+ *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+ *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+ *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+ *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+ *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+ *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+ *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+ */
 /* TODO: Individual devices generally have very little idea about the rest
    of the system, so instance_id should be removed/replaced.
    Meanwhile pass -1 as instance_id if you do not already have a clearly
@@ -829,6 +845,11 @@ int register_savevm_live(const char *idstr,
         se->instance_id = instance_id;
     }
     assert(!se->compat || se->instance_id == 0);
+    /*
+     * 在以下使用savevm_state_handler_insert():
+     *   - migration/savevm.c|832| <<register_savevm_live>> savevm_state_handler_insert(se);
+     *   - migration/savevm.c|948| <<vmstate_register_with_alias_id>> savevm_state_handler_insert(se);
+     */
     savevm_state_handler_insert(se);
     return 0;
 }
@@ -894,6 +915,13 @@ static void vmstate_check(const VMStateDescription *vmsd)
 }
 
 
+/*
+ * 在以下使用vmstate_register_with_alias_id():
+ *   - hw/core/qdev.c|517| <<device_set_realized>> if (vmstate_register_with_alias_id(VMSTATE_IF(dev),
+ *   - hw/intc/apic_common.c|300| <<apic_common_realize>> vmstate_register_with_alias_id(NULL, instance_id, &vmstate_apic_common,
+ *   - include/migration/vmstate.h|1232| <<vmstate_register>> return vmstate_register_with_alias_id(obj, instance_id, vmsd,
+ *   - include/migration/vmstate.h|1260| <<vmstate_register_any>> return vmstate_register_with_alias_id(obj, VMSTATE_INSTANCE_ID_ANY, vmsd,
+ */
 int vmstate_register_with_alias_id(VMStateIf *obj, uint32_t instance_id,
                                    const VMStateDescription *vmsd,
                                    void *opaque, int alias_id,
@@ -945,6 +973,11 @@ int vmstate_register_with_alias_id(VMStateIf *obj, uint32_t instance_id,
         vmstate_check(vmsd);
     }
     assert(!se->compat || se->instance_id == 0);
+    /*
+     * 在以下使用savevm_state_handler_insert():
+     *   - migration/savevm.c|832| <<register_savevm_live>> savevm_state_handler_insert(se);
+     *   - migration/savevm.c|948| <<vmstate_register_with_alias_id>> savevm_state_handler_insert(se);
+     */
     savevm_state_handler_insert(se);
     return 0;
 }
@@ -1024,6 +1057,12 @@ static void save_section_footer(QEMUFile *f, SaveStateEntry *se)
     }
 }
 
+/*
+ * 在以下使用vmstate_save():
+ *   - migration/savevm.c|1361| <<qemu_savevm_state_setup>> ret = vmstate_save(f, se, vmdesc, errp);
+ *   - migration/savevm.c|1669| <<qemu_savevm_state_complete_precopy_non_iterable>> ret = vmstate_save(f, se, vmdesc, &local_err);
+ *   - migration/savevm.c|1864| <<qemu_save_device_state>> ret = vmstate_save(f, se, NULL, &local_err);
+ */
 static int vmstate_save(QEMUFile *f, SaveStateEntry *se, JSONWriter *vmdesc,
                         Error **errp)
 {
@@ -1274,6 +1313,12 @@ void qemu_savevm_non_migratable_list(strList **reasons)
     }
 }
 
+/*
+ * 在以下使用qemu_savevm_state_header():
+ *   - migration/migration.c|4024| <<migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+ *   - migration/migration.c|4186| <<bg_migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+ *   - migration/savevm.c|2010| <<qemu_savevm_state>> qemu_savevm_state_header(f);
+ */
 void qemu_savevm_state_header(QEMUFile *f)
 {
     MigrationState *s = migrate_get_current();
@@ -1573,6 +1618,11 @@ bool qemu_savevm_state_postcopy_prepare(QEMUFile *f, Error **errp)
     return true;
 }
 
+/*
+ * 在以下使用qemu_savevm_state_complete_precopy_iterable():
+ *   - migration/migration.c|2771| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_iterable(ms->to_dst_file, true);
+ *   - migration/savevm.c|1718| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_iterable(f, false);
+ */
 int qemu_savevm_state_complete_precopy_iterable(QEMUFile *f, bool in_postcopy)
 {
     int64_t start_ts_each, end_ts_each;
@@ -1644,6 +1694,62 @@ ret_fail_abort_threads:
     return -1;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+ *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+ *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+ *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+ */
 int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
                                                     bool in_postcopy)
 {
@@ -1655,6 +1761,16 @@ int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
     Error *local_err = NULL;
     int ret;
 
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     /* Making sure cpu states are synchronized before saving non-iterable */
     cpu_synchronize_all_states();
 
@@ -1680,6 +1796,14 @@ int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
     }
 
     if (!in_postcopy) {
+        /*
+	 * 非test使用QEMU_VM_EOF的地方:
+	 *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+	 */
         /* Postcopy stream will still be going */
         qemu_put_byte(f, QEMU_VM_EOF);
 
@@ -1699,16 +1823,106 @@ int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *   
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1704
+ * #1  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #2  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #3  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #4  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用qemu_savevm_state_complete_precopy():
+ *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+ *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+ *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+ */
 int qemu_savevm_state_complete_precopy(QEMUFile *f, bool iterable_only)
 {
     int ret;
 
+    /*
+     * 似乎是剩余可以迁移的最后一点数据?
+     */
     ret = qemu_savevm_state_complete_precopy_iterable(f, false);
     if (ret) {
         return ret;
     }
 
     if (!iterable_only) {
+        /*
+	 * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+         *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+         *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+         *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+	 */
         ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
         if (ret) {
             return ret;
@@ -1743,6 +1957,10 @@ void qemu_savevm_state_pending_estimate(uint64_t *must_precopy,
     }
 }
 
+/*
+ * 在以下使用qemu_savevm_state_pending_exact():
+ *   - migration/migration.c|3535| <<migration_iteration_run>> qemu_savevm_state_pending_exact(&must_precopy, &can_postcopy);
+ */
 void qemu_savevm_state_pending_exact(uint64_t *must_precopy,
                                      uint64_t *can_postcopy)
 {
@@ -1781,6 +1999,10 @@ void qemu_savevm_state_cleanup(void)
     }
 }
 
+/*
+ * 在以下使用qemu_savevm_state():
+ *   - migration/savevm.c|3351| <<save_snapshot>> ret = qemu_savevm_state(f, errp);
+ */
 static int qemu_savevm_state(QEMUFile *f, Error **errp)
 {
     int ret;
@@ -1798,6 +2020,12 @@ static int qemu_savevm_state(QEMUFile *f, Error **errp)
     }
     ms->to_dst_file = f;
 
+    /*
+     * 在以下使用qemu_savevm_state_header():
+     *   - migration/migration.c|4024| <<migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/migration.c|4186| <<bg_migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/savevm.c|2010| <<qemu_savevm_state>> qemu_savevm_state_header(f);
+     */
     qemu_savevm_state_header(f);
     ret = qemu_savevm_state_setup(f, errp);
     if (ret) {
@@ -1813,6 +2041,12 @@ static int qemu_savevm_state(QEMUFile *f, Error **errp)
     ret = qemu_file_get_error(f);
     if (ret == 0) {
         qemu_savevm_maybe_send_switchover_start(f);
+        /*
+	 * 在以下使用qemu_savevm_state_complete_precopy():
+	 *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+	 *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+	 *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+	 */
         qemu_savevm_state_complete_precopy(f, false);
         ret = qemu_file_get_error(f);
     }
@@ -1836,13 +2070,36 @@ cleanup:
     return ret;
 }
 
+/*
+ * 在以下使用qemu_savevm_live_state():
+ *   - migration/colo.c|474| <<colo_do_checkpoint_transaction>> qemu_savevm_live_state(s->to_dst_file);
+ */
 void qemu_savevm_live_state(QEMUFile *f)
 {
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy():
+     *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+     *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+     *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+     */
     /* save QEMU_VM_SECTION_END section */
     qemu_savevm_state_complete_precopy(f, true);
+    /*
+     * 非test使用QEMU_VM_EOF的地方:
+     *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+     */
     qemu_put_byte(f, QEMU_VM_EOF);
 }
 
+/*
+ * 在以下使用qemu_save_device_state():
+ *   - migration/colo.c|459| <<colo_do_checkpoint_transaction>> ret = qemu_save_device_state(fb);
+ *   - migration/savevm.c|3432| <<qmp_xen_save_devices_state>> ret = qemu_save_device_state(f);
+ */
 int qemu_save_device_state(QEMUFile *f)
 {
     MigrationState *ms = migrate_get_current();
@@ -1853,6 +2110,16 @@ int qemu_save_device_state(QEMUFile *f)
         qemu_put_be32(f, QEMU_VM_FILE_MAGIC);
         qemu_put_be32(f, QEMU_VM_FILE_VERSION);
     }
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
 
     QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
@@ -1869,6 +2136,14 @@ int qemu_save_device_state(QEMUFile *f)
         }
     }
 
+    /*
+     * 非test使用QEMU_VM_EOF的地方:
+     *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+     */
     qemu_put_byte(f, QEMU_VM_EOF);
 
     return qemu_file_get_error(f);
@@ -2076,6 +2351,11 @@ static int loadvm_postcopy_ram_handle_discard(MigrationIncomingState *mis,
  * (TODO:This could do with being in a postcopy file - but there again it's
  * just another input loop, not that postcopy specific)
  */
+/*
+ * 在以下使用postcopy_ram_listen_thread():
+ *   - migration/savevm.c|2353| <<loadvm_postcopy_handle_listen>> postcopy_thread_create(mis, &mis->listen_thread,
+ *                          MIGRATION_THREAD_DST_LISTEN, postcopy_ram_listen_thread, QEMU_THREAD_DETACHED);
+ */
 static void *postcopy_ram_listen_thread(void *opaque)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -2135,6 +2415,13 @@ static void *postcopy_ram_listen_thread(void *opaque)
          * main thread hasn't finished yet, and so we might not be in 'RUN'
          * state yet; wait for the end of the main thread.
          */
+        /*
+	 * 在以下使用MigrationIncomingState->main_thread_load_event:
+         *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+         *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+         *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+         *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+	 */
         qemu_event_wait(&mis->main_thread_load_event);
     }
     postcopy_ram_incoming_cleanup(mis);
@@ -2274,6 +2561,14 @@ static int loadvm_postcopy_handle_run(MigrationIncomingState *mis)
     }
 
     postcopy_state_set(POSTCOPY_INCOMING_RUNNING);
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
 
     /* We need to finish reading the stream from the package
@@ -2813,6 +3108,10 @@ qemu_loadvm_section_part_end(QEMUFile *f, uint8_t type)
     return 0;
 }
 
+/*
+ * 在以下使用qemu_loadvm_state_header():
+ *   - migration/savevm.c|3440| <<qemu_loadvm_state>> ret = qemu_loadvm_state_header(f);
+ */
 static int qemu_loadvm_state_header(QEMUFile *f)
 {
     unsigned int v;
@@ -3028,6 +3327,24 @@ static bool postcopy_pause_incoming(MigrationIncomingState *mis)
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3033
+ * #1  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #2  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #3  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #4  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #5  0x00007fffffffc7e0 in ?? ()
+ * #6  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用qemu_loadvm_state_main():
+ *   - migration/colo.c|699| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis);
+ *   - migration/savevm.c|2234| <<postcopy_ram_listen_thread>> load_res = qemu_loadvm_state_main(f, mis);
+ *   - migration/savevm.c|2593| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis);
+ *   - migration/savevm.c|3283| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis);
+ *   - migration/savevm.c|3357| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis);
+ */
 int qemu_loadvm_state_main(QEMUFile *f, MigrationIncomingState *mis)
 {
     uint8_t section_type;
@@ -3066,6 +3383,14 @@ retry:
             }
             break;
         case QEMU_VM_EOF:
+            /*
+	     * 非test使用QEMU_VM_EOF的地方:
+             *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+	     */
             /* This is the end of migration */
             goto out;
         default:
@@ -3103,6 +3428,21 @@ out:
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3112
+ * #1  0x0000555555c600fa in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:891
+ * #2  0x0000555556174e10 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #3  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #4  0x00007fffffffc7e0 in ?? ()
+ * #5  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用qemu_loadvm_state():
+ *   - migration/migration.c|908| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file);
+ *   - migration/savevm.c|3581| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f);
+ *   - migration/savevm.c|3655| <<load_snapshot>> ret = qemu_loadvm_state(f);
+ */
 int qemu_loadvm_state(QEMUFile *f)
 {
     MigrationState *s = migrate_get_current();
@@ -3131,9 +3471,33 @@ int qemu_loadvm_state(QEMUFile *f)
         qemu_loadvm_state_switchover_ack_needed(mis);
     }
 
+    /*
+     * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+     *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+     *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+     *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+     *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+     */
     cpu_synchronize_all_pre_loadvm();
 
+    /*
+     * 在以下使用qemu_loadvm_state_main():
+     *   - migration/colo.c|699| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis);
+     *   - migration/savevm.c|2234| <<postcopy_ram_listen_thread>> load_res = qemu_loadvm_state_main(f, mis);
+     *   - migration/savevm.c|2593| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis);
+     *   - migration/savevm.c|3283| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis);
+     *   - migration/savevm.c|3357| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis);
+     */
     ret = qemu_loadvm_state_main(f, mis);
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     qemu_event_set(&mis->main_thread_load_event);
 
     trace_qemu_loadvm_state_post_main(ret);
@@ -3196,6 +3560,13 @@ int qemu_loadvm_state(QEMUFile *f)
         }
     }
 
+    /*
+     * 在以下使用cpu_synchronize_all_post_init():
+     *   - hw/core/machine.c|1732| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|2368| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3346| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3363| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+     */
     cpu_synchronize_all_post_init();
 
     return ret;
@@ -3213,6 +3584,13 @@ int qemu_load_device_state(QEMUFile *f)
         return ret;
     }
 
+    /*
+     * 在以下使用cpu_synchronize_all_post_init():
+     *   - hw/core/machine.c|1732| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|2368| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3346| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3363| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+     */
     cpu_synchronize_all_post_init();
     return 0;
 }
@@ -3258,6 +3636,13 @@ bool qemu_loadvm_load_state_buffer(const char *idstr, uint32_t instance_id,
     return se->ops->load_state_buffer(se->opaque, buf, len, errp);
 }
 
+/*
+ * 在以下使用save_snapshot():
+ *   - migration/migration-hmp-cmds.c|463| <<hmp_savevm>> save_snapshot(qdict_get_try_str(qdict, "name"),
+ *   - migration/savevm.c|3629| <<snapshot_save_job_bh>> s->ret = save_snapshot(s->tag, false, s->vmstate,
+ *   - replay/replay-debugging.c|325| <<replay_gdb_attached>> if (!save_snapshot("start_debugging", true, NULL, false, NULL, NULL)) {
+ *   - replay/replay-snapshot.c|79| <<replay_vmstate_init>> if (!save_snapshot(replay_snapshot,
+ */
 bool save_snapshot(const char *name, bool overwrite, const char *vmstate,
                   bool has_devices, strList *devices, Error **errp)
 {
@@ -3512,6 +3897,12 @@ bool load_snapshot(const char *name, const char *vmstate,
         ret = -EINVAL;
         goto err_drain;
     }
+    /*
+     * 在以下使用qemu_loadvm_state():
+     *   - migration/migration.c|908| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file);
+     *   - migration/savevm.c|3581| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f);
+     *   - migration/savevm.c|3655| <<load_snapshot>> ret = qemu_loadvm_state(f);
+     */
     ret = qemu_loadvm_state(f);
     migration_incoming_state_destroy();
 
diff --git a/migration/savevm.h b/migration/savevm.h
index 2d5e9c716..c22efcf57 100644
--- a/migration/savevm.h
+++ b/migration/savevm.h
@@ -18,6 +18,14 @@
 #define QEMU_VM_FILE_VERSION_COMPAT  0x00000002
 #define QEMU_VM_FILE_VERSION         0x00000003
 
+/*
+ * 非test使用QEMU_VM_EOF的地方:
+ *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+ */
 #define QEMU_VM_EOF                  0x00
 #define QEMU_VM_SECTION_START        0x01
 #define QEMU_VM_SECTION_PART         0x02
diff --git a/migration/socket.c b/migration/socket.c
index 5ec65b8c0..0b6253522 100644
--- a/migration/socket.c
+++ b/migration/socket.c
@@ -77,6 +77,14 @@ static void socket_outgoing_migration(QIOTask *task,
     }
 
 out:
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(data->s, sioc, data->hostname, err);
     object_unref(OBJECT(sioc));
 }
diff --git a/migration/tls.c b/migration/tls.c
index 284a6194b..6c90428a6 100644
--- a/migration/tls.c
+++ b/migration/tls.c
@@ -114,6 +114,14 @@ static void migration_tls_outgoing_handshake(QIOTask *task,
     } else {
         trace_migration_tls_outgoing_handshake_complete();
     }
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, err);
     object_unref(OBJECT(ioc));
 }
diff --git a/monitor/qmp-cmds.c b/monitor/qmp-cmds.c
index 1ca44fbd7..4a1cb301a 100644
--- a/monitor/qmp-cmds.c
+++ b/monitor/qmp-cmds.c
@@ -109,6 +109,23 @@ void qmp_cont(Error **errp)
             error_propagate(errp, local_err);
             return;
         }
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|793| <<vm_resume>> vm_start();
+	 */
         vm_start();
     }
 }
diff --git a/net/slirp.c b/net/slirp.c
index 9657e86a8..fdeee85f3 100644
--- a/net/slirp.c
+++ b/net/slirp.c
@@ -669,6 +669,17 @@ static int net_slirp_init(NetClientState *peer, const char *model,
      * specific version?
      */
     g_assert(slirp_state_version() == 4);
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
                          slirp_state_version(), &savevm_slirp_state, s->slirp);
 
diff --git a/net/tap-linux.c b/net/tap-linux.c
index 22ec2f45d..7e8ff687b 100644
--- a/net/tap-linux.c
+++ b/net/tap-linux.c
@@ -37,6 +37,10 @@
 
 #define PATH_NET_TUN "/dev/net/tun"
 
+/*
+ * 在以下使用tap_open():
+ *   - net/tap.c|661| <<net_tap_init>> fd = RETRY_ON_EINTR(tap_open(ifname, ifname_sz, vnet_hdr, vnet_hdr_required,
+ */
 int tap_open(char *ifname, int ifname_size, int *vnet_hdr,
              int vnet_hdr_required, int mq_required, Error **errp)
 {
@@ -279,6 +283,10 @@ void tap_fd_set_offload(int fd, int csum, int tso4,
     }
 }
 
+/*
+ * 在以下使用tap_fd_enable():
+ *   - net/tap.c|1032| <<tap_enable>> ret = tap_fd_enable(s->fd);
+ */
 /* Enable a specific queue of tap. */
 int tap_fd_enable(int fd)
 {
@@ -297,6 +305,10 @@ int tap_fd_enable(int fd)
     return ret;
 }
 
+/*
+ * 在以下使用tap_fd_disable():
+ *   - net/tap.c|1049| <<tap_disable>> ret = tap_fd_disable(s->fd);
+ */
 /* Disable a specific queue of tap/ */
 int tap_fd_disable(int fd)
 {
diff --git a/net/tap.c b/net/tap.c
index f7df702f9..87bac19e6 100644
--- a/net/tap.c
+++ b/net/tap.c
@@ -643,6 +643,10 @@ int net_init_bridge(const Netdev *netdev, const char *name,
     return 0;
 }
 
+/*
+ * 在以下使用net_tap_init():
+ *   - net/tap.c|995| <<net_init_tap>> fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? "no" : script,
+ */
 static int net_tap_init(const NetdevTapOptions *tap, int *vnet_hdr,
                         const char *setup_script, char *ifname,
                         size_t ifname_sz, int mq_required, Error **errp)
@@ -1021,6 +1025,10 @@ free_fail:
     return 0;
 }
 
+/*
+ * 在以下使用tap_enable():
+ *   - hw/net/virtio-net.c|713| <<peer_attach>> return tap_enable(nc->peer);
+ */
 int tap_enable(NetClientState *nc)
 {
     TAPState *s = DO_UPCAST(TAPState, nc, nc);
@@ -1038,6 +1046,10 @@ int tap_enable(NetClientState *nc)
     }
 }
 
+/*
+ * 在以下使用tap_disable():
+ *   - hw/net/virtio-net.c|734| <<peer_detach>> return tap_disable(nc->peer);
+ */
 int tap_disable(NetClientState *nc)
 {
     TAPState *s = DO_UPCAST(TAPState, nc, nc);
diff --git a/system/cpus.c b/system/cpus.c
index 256723558..b4b2a765f 100644
--- a/system/cpus.c
+++ b/system/cpus.c
@@ -131,6 +131,16 @@ void hw_error(const char *fmt, ...)
     abort();
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_states():
+ *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+ *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+ *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+ *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+ *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+ *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+ *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+ */
 void cpu_synchronize_all_states(void)
 {
     CPUState *cpu;
@@ -140,6 +150,11 @@ void cpu_synchronize_all_states(void)
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_post_reset():
+ *   - hw/i386/pc.c|1727| <<pc_machine_wakeup>> cpu_synchronize_all_post_reset();
+ *   - system/runstate.c|615| <<qemu_system_reset>> cpu_synchronize_all_post_reset();
+ */
 void cpu_synchronize_all_post_reset(void)
 {
     CPUState *cpu;
@@ -149,6 +164,24 @@ void cpu_synchronize_all_post_reset(void)
     }
 }
 
+/*
+ * 迁移后在Target:
+ * (gdb) bt
+ * #0  cpu_synchronize_all_post_init () at ../system/cpus.c:153
+ * #1  0x0000555555c7e7b2 in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3206
+ * #2  0x0000555555c600fa in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:891
+ * #3  0x0000555556174e10 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #4  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #5  0x00007fffffffc7e0 in ?? ()
+ * #6  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用cpu_synchronize_all_post_init():
+ *   - hw/core/machine.c|1732| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|2368| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3346| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3363| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+ */
 void cpu_synchronize_all_post_init(void)
 {
     CPUState *cpu;
@@ -158,6 +191,10 @@ void cpu_synchronize_all_post_init(void)
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_pre_loadvm():
+ *   - migration/savevm.c|3454| <<qemu_loadvm_state>> cpu_synchronize_all_pre_loadvm();
+ */
 void cpu_synchronize_all_pre_loadvm(void)
 {
     CPUState *cpu;
@@ -167,13 +204,86 @@ void cpu_synchronize_all_pre_loadvm(void)
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_state():
+ *   - gdbstub/gdbstub.c|662| <<gdb_set_cpu_pc>> cpu_synchronize_state(cpu);
+ *   - gdbstub/gdbstub.c|1321| <<handle_write_all_regs>> cpu_synchronize_state(gdbserver_state.g_cpu);
+ *   - gdbstub/gdbstub.c|1340| <<handle_read_all_regs>> cpu_synchronize_state(gdbserver_state.g_cpu);
+ *   - gdbstub/gdbstub.c|1636| <<handle_query_thread_extra>> cpu_synchronize_state(cpu);
+ *   - hw/core/cpu-common.c|106| <<cpu_dump_state>> cpu_synchronize_state(cpu);
+ *   - hw/i386/kvm/apic.c|170| <<do_inject_external_nmi>> cpu_synchronize_state(cpu);
+ *   - hw/i386/kvm/clock.c|99| <<kvmclock_current_nsec>> cpu_synchronize_state(cpu);
+ *   - hw/i386/vapic.c|475| <<vapic_report_tpr_access>> cpu_synchronize_state(cs);
+ *   - hw/i386/vapic.c|651| <<vapic_write>> cpu_synchronize_state(current_cpu);
+ *   - hw/i386/vmport.c|107| <<vmport_ioport_read>> cpu_synchronize_state(cs);
+ *   - hw/ppc/pnv.c|2849| <<pnv_cpu_do_nmi_on_cpu>> cpu_synchronize_state(cs);
+ *   - hw/ppc/pnv_xscom.c|51| <<xscom_complete>> cpu_synchronize_state(cs);
+ *   - hw/ppc/ppce500_spin.c|81| <<spin_kick>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr.c|1351| <<do_lpcr_sync>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr.c|3503| <<spapr_do_system_reset_on_cpu>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr_hcall.c|138| <<do_push_sregs_to_kvm_pr>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr_hcall.c|209| <<h_set_sprg0>> cpu_synchronize_state(CPU(cpu));
+ *   - hw/ppc/spapr_hcall.c|221| <<h_set_dabr>> cpu_synchronize_state(CPU(cpu));
+ *   - hw/ppc/spapr_hcall.c|247| <<h_set_xdabr>> cpu_synchronize_state(CPU(cpu));
+ *   - hw/ppc/spapr_rtas.c|162| <<rtas_start_cpu>> cpu_synchronize_state(CPU(newcpu));
+ *   - monitor/hmp-cmds-target.c|72| <<mon_get_cpu_sync>> cpu_synchronize_state(cpu);
+ *   - system/cpus.c|149| <<cpu_synchronize_all_states>> cpu_synchronize_state(cpu);
+ *   - system/physmem.c|3745| <<cpu_memory_rw_debug>> cpu_synchronize_state(cpu);
+ *   - target/arm/cpu.c|1113| <<arm_cpu_virtio_is_big_endian>> cpu_synchronize_state(cs);
+ *   - target/arm/hvf/hvf.c|1455| <<hvf_sysreg_read>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1772| <<hvf_sysreg_write>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1977| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1989| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1999| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|2084| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|2097| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|2112| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|2353| <<hvf_arch_update_guest_debug>> cpu_synchronize_state(cpu);
+ *   - target/i386/cpu-apic.c|100| <<hmp_info_local_apic>> cpu_synchronize_state(cs);
+ *   - target/i386/helper.c|395| <<do_inject_x86_mce>> cpu_synchronize_state(cs);
+ *   - target/i386/hvf/x86hvf.c|436| <<hvf_process_events>> cpu_synchronize_state(cs);
+ *   - target/i386/hvf/x86hvf.c|450| <<hvf_process_events>> cpu_synchronize_state(cs);
+ *   - target/i386/hvf/x86hvf.c|455| <<hvf_process_events>> cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|752| <<kvm_mce_inject>> cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5934| <<kvm_handle_debug>> cpu_synchronize_state(cs);
+ *   - target/ppc/compat.c|192| <<ppc_set_compat>> cpu_synchronize_state(CPU(cpu));
+ *   - target/ppc/cpu_init.c|7356| <<ppc_cpu_is_big_endian>> cpu_synchronize_state(cs);
+ *   - target/ppc/kvm.c|1649| <<kvm_handle_debug>> cpu_synchronize_state(cs);
+ *   - target/ppc/kvm.c|2894| <<kvm_handle_nmi>> cpu_synchronize_state(CPU(cpu));
+ *   - target/ppc/mmu-hash64.c|91| <<dump_slb>> cpu_synchronize_state(CPU(cpu));
+ *   - target/s390x/cpu-system.c|96| <<s390_cpu_get_crash_info>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|147| <<sigp_stop_and_store_status>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|166| <<sigp_store_status_at_address>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|219| <<sigp_store_adtl_status>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|236| <<sigp_restart>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|256| <<sigp_initial_cpu_reset>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|266| <<sigp_cpu_reset>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|278| <<sigp_set_prefix>> cpu_synchronize_state(cs);
+ *
+ * 等同kvm_arch_get_registers()
+ */
 void cpu_synchronize_state(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state():
+     *   - accel/hvf/hvf-accel-ops.c|382| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|111| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - system/cpus.c|204| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|205| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|94| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|97| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     if (cpus_accel->synchronize_state) {
         cpus_accel->synchronize_state(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_post_reset():
+ *   - system/cpus.c|158| <<cpu_synchronize_all_post_reset>> cpu_synchronize_post_reset(cpu);
+ *   - target/s390x/sigp.c|258| <<sigp_initial_cpu_reset>> cpu_synchronize_post_reset(cs);
+ *   - target/s390x/sigp.c|268| <<sigp_cpu_reset>> cpu_synchronize_post_reset(cs);
+ */
 void cpu_synchronize_post_reset(CPUState *cpu)
 {
     if (cpus_accel->synchronize_post_reset) {
@@ -181,15 +291,66 @@ void cpu_synchronize_post_reset(CPUState *cpu)
     }
 }
 
+/*
+ * 多个vCPU
+ * (gdb) bt
+ * #0  cpu_synchronize_post_init (cpu=0x5555578f8060) at ../system/cpus.c:186
+ * #1  0x0000555555c08773 in cpu_synchronize_all_post_init () at ../system/cpus.c:157
+ * #2  0x0000555555c7e70e in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3199
+ * #3  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #4  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #5  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #6  0x00007fffffffc7e0 in ?? ()
+ * #7  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用cpu_synchronize_post_init():
+ *   - hw/core/cpu-common.c|266| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+ *   - system/cpus.c|167| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+ *   - target/s390x/gdbstub.c|92| <<cpu_write_ac_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|210| <<cpu_write_c_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|250| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|254| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|258| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|262| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|302| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|306| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|310| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|314| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|342| <<cpu_write_gs_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/sigp.c|295| <<sigp_set_prefix>> cpu_synchronize_post_init(cs);
+ */
 void cpu_synchronize_post_init(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     if (cpus_accel->synchronize_post_init) {
         cpus_accel->synchronize_post_init(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_pre_loadvm():
+ *   - system/cpus.c|183| <<cpu_synchronize_all_pre_loadvm>> cpu_synchronize_pre_loadvm(cpu);
+ */
 void cpu_synchronize_pre_loadvm(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+     *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+     *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+     *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+     *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+     */
     if (cpus_accel->synchronize_pre_loadvm) {
         cpus_accel->synchronize_pre_loadvm(cpu);
     }
@@ -285,6 +446,26 @@ bool vm_get_suspended(void)
     return vm_was_suspended;
 }
 
+/*
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:232
+ * #1  0x0000555555c08b8c in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:295
+ * #2  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #3  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #4  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #5  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用do_vm_stop():
+ *   - system/cpus.c|322| <<vm_shutdown>> return do_vm_stop(RUN_STATE_SHUTDOWN, false);
+ *   - system/cpus.c|737| <<vm_stop>> return do_vm_stop(state, true);
+ */
 static int do_vm_stop(RunState state, bool send_stop)
 {
     int ret = 0;
@@ -297,6 +478,11 @@ static int do_vm_stop(RunState state, bool send_stop)
         if (oldstate == RUN_STATE_RUNNING) {
             pause_all_vcpus();
         }
+        /*
+	 * 在以下使用vm_state_notify():
+	 *   - system/cpus.c|300| <<do_vm_stop>> ret = vm_state_notify(0, state);
+	 *   - system/cpus.c|778| <<vm_prepare_start>> vm_state_notify(1, state);
+	 */
         ret = vm_state_notify(0, state);
         if (send_stop) {
             qapi_event_send_stop();
@@ -319,6 +505,11 @@ static int do_vm_stop(RunState state, bool send_stop)
  */
 int vm_shutdown(void)
 {
+    /*
+     * 在以下使用do_vm_stop():
+     *   - system/cpus.c|322| <<vm_shutdown>> return do_vm_stop(RUN_STATE_SHUTDOWN, false);
+     *   - system/cpus.c|737| <<vm_stop>> return do_vm_stop(state, true);
+     */
     return do_vm_stop(RUN_STATE_SHUTDOWN, false);
 }
 
@@ -622,6 +813,14 @@ static bool all_vcpus_paused(void)
     return true;
 }
 
+/*
+ * 在以下使用pause_all_vcpus():
+ *   - hw/i386/vapic.c|688| <<vapic_write>> pause_all_vcpus();
+ *   - system/cpus.c|390| <<do_vm_stop>> pause_all_vcpus();
+ *   - system/runstate.c|778| <<qemu_system_suspend>> pause_all_vcpus();
+ *   - system/runstate.c|938| <<main_loop_should_exit>> pause_all_vcpus();
+ *   - system/runstate.c|952| <<main_loop_should_exit>> pause_all_vcpus();
+ */
 void pause_all_vcpus(void)
 {
     CPUState *cpu;
@@ -721,6 +920,36 @@ void cpu_stop_current(void)
     }
 }
 
+/*
+ * 在以下使用vm_stop():
+ *   - accel/kvm/kvm-all.c|2923| <<do_kvm_cpu_synchronize_state>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - accel/kvm/kvm-all.c|2949| <<do_kvm_cpu_synchronize_post_reset>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - accel/kvm/kvm-all.c|3346| <<kvm_cpu_exec>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - dump/dump.c|1802| <<dump_init>> vm_stop(RUN_STATE_SAVE_VM);
+ *   - gdbstub/gdbstub.c|2364| <<gdb_read_byte>> vm_stop(RUN_STATE_PAUSED);
+ *   - gdbstub/system.c|102| <<gdb_chr_event>> vm_stop(RUN_STATE_PAUSED);
+ *   - gdbstub/system.c|120| <<gdb_syscall_handling>> vm_stop(RUN_STATE_DEBUG);
+ *   - gdbstub/system.c|228| <<gdb_sigterm_handler>> vm_stop(RUN_STATE_PAUSED);
+ *   - hw/ppc/prep_systemio.c|78| <<prep_port0092_write>> vm_stop(RUN_STATE_PAUSED);
+ *   - hw/ppc/vof.c|921| <<vof_client_handle>> vm_stop(RUN_STATE_PAUSED);
+ *   - hw/vfio/pci.c|3040| <<vfio_err_notifier_handler>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - migration/migration-hmp-cmds.c|450| <<hmp_loadvm>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - migration/savevm.c|3315| <<save_snapshot>> vm_stop(RUN_STATE_SAVE_VM);
+ *   - migration/savevm.c|3386| <<qmp_xen_save_devices_state>> vm_stop(RUN_STATE_SAVE_VM);
+ *   - migration/savevm.c|3431| <<qmp_xen_load_devices_state>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - migration/savevm.c|3610| <<snapshot_load_job_bh>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - monitor/qmp-cmds.c|62| <<qmp_stop>> vm_stop(RUN_STATE_PAUSED);
+ *   - replay/replay-debugging.c|88| <<replay_stop_vm>> vm_stop(RUN_STATE_PAUSED);
+ *   - replay/replay-debugging.c|193| <<replay_seek>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - replay/replay-debugging.c|226| <<replay_stop_vm_debug>> vm_stop(RUN_STATE_DEBUG);
+ *   - replay/replay-debugging.c|253| <<replay_continue_end>> vm_stop(RUN_STATE_DEBUG);
+ *   - system/cpus.c|804| <<vm_stop_force_state>> return vm_stop(state);
+ *   - system/runstate.c|636| <<qemu_system_guest_panicked>> vm_stop(RUN_STATE_GUEST_PANICKED);
+ *   - system/runstate.c|640| <<qemu_system_guest_panicked>> vm_stop(RUN_STATE_GUEST_PANICKED);
+ *   - system/runstate.c|847| <<main_loop_should_exit>> vm_stop(RUN_STATE_DEBUG);
+ *   - system/runstate.c|857| <<main_loop_should_exit>> vm_stop(RUN_STATE_SHUTDOWN);
+ *   - system/runstate.c|895| <<main_loop_should_exit>> vm_stop(r);
+ */
 int vm_stop(RunState state)
 {
     if (qemu_in_vcpu_thread()) {
@@ -734,6 +963,11 @@ int vm_stop(RunState state)
         return 0;
     }
 
+    /*
+     * 在以下使用do_vm_stop():
+     *   - system/cpus.c|322| <<vm_shutdown>> return do_vm_stop(RUN_STATE_SHUTDOWN, false);
+     *   - system/cpus.c|737| <<vm_stop>> return do_vm_stop(state, true);
+     */
     return do_vm_stop(state, true);
 }
 
@@ -742,6 +976,11 @@ int vm_stop(RunState state)
  * Returns 0 if the vCPUs should be restarted, -1 on an error condition,
  * and 1 otherwise.
  */
+/*
+ * 在以下使用vm_prepare_start():
+ *   - gdbstub/system.c|578| <<gdb_continue_partial>> if (vm_prepare_start(step_requested)) {
+ *   - system/cpus.c|785| <<vm_start>> if (!vm_prepare_start(false)) {
+ */
 int vm_prepare_start(bool step_pending)
 {
     int ret = vm_was_suspended ? 1 : 0;
@@ -775,11 +1014,52 @@ int vm_prepare_start(bool step_pending)
 
     cpu_enable_ticks();
     runstate_set(state);
+    /*
+     * 在以下使用vm_state_notify():
+     *   - system/cpus.c|300| <<do_vm_stop>> ret = vm_state_notify(0, state);
+     *   - system/cpus.c|778| <<vm_prepare_start>> vm_state_notify(1, state);
+     */
     vm_state_notify(1, state);
     vm_was_suspended = false;
     return ret;
 }
 
+/*
+ * 迁移后在target.
+ * (gdb) bt
+ * #0  vm_start () at ../system/cpus.c:785
+ * #1  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #2  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x5555582b37e0) at ../migration/migration.c:361
+ * #3  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #4  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #5  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #6  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #7  0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #8  g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #9  0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #10 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #11 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #12 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #13 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #14 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用vm_start():
+ *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+ *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+ *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+ *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+ *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+ *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+ *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+ *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+ *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+ *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+ *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+ *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+ *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+ *   - system/cpus.c|793| <<vm_resume>> vm_start();
+ */
 void vm_start(void)
 {
     if (!vm_prepare_start(false)) {
@@ -790,12 +1070,96 @@ void vm_start(void)
 void vm_resume(RunState state)
 {
     if (runstate_is_live(state)) {
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|793| <<vm_resume>> vm_start();
+	 */
         vm_start();
     } else {
         runstate_set(state);
     }
 }
 
+/*
+ * 迁移的时候在Source上的调用:
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 迁移的时候在Target上的调用:
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ * 从QEMU cmdline quit的时候:
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_SHUTDOWN) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f20 in vm_state_notify (running=false, state=RUN_STATE_SHUTDOWN) at ../system/runstate.c:392
+ * #2  0x0000555555c08bba in do_vm_stop (state=RUN_STATE_SHUTDOWN, send_stop=false) at ../system/cpus.c:302
+ * #3  0x0000555555c08bfb in vm_shutdown () at ../system/cpus.c:324
+ * #4  0x0000555555c38ef8 in qemu_cleanup (status=0) at ../system/runstate.c:981
+ * #5  0x0000555556082acb in qemu_default_main (opaque=0x0) at ../system/main.c:51
+ * #6  0x0000555556082b78 in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用vm_stop_force_state():
+ *   - migration/colo.c|216| <<colo_do_failover>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/colo.c|432| <<colo_do_checkpoint_transaction>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/colo.c|668| <<colo_incoming_process_checkpoint>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/migration.c|306| <<migration_stop_vm>> ret = vm_stop_force_state(state);
+ */
 /* does a state transition even if the VM is already stopped,
    current state is forgotten forever */
 int vm_stop_force_state(RunState state)
diff --git a/system/memory.c b/system/memory.c
index 564654794..71c4a8f8a 100644
--- a/system/memory.c
+++ b/system/memory.c
@@ -42,6 +42,27 @@
 static unsigned memory_region_transaction_depth;
 static bool memory_region_update_pending;
 static bool ioeventfd_update_pending;
+/*
+ * 在以下修改global_dirty_tracking:
+ *   - system/memory.c|2950| <<memory_global_dirty_log_start>> global_dirty_tracking |= flags;
+ *   - system/memory.c|2944| <<memory_global_dirty_log_start>> flags &= ~global_dirty_tracking;
+ *   - system/memory.c|2955| <<memory_global_dirty_log_start>> global_dirty_tracking &= ~flags;
+ *   - system/memory.c|2971| <<memory_global_dirty_log_do_stop>> global_dirty_tracking &= ~flags;
+ * 在以下使用global_dirty_tracking:
+ *   - include/system/ram_addr.h|393| <<cpu_physical_memory_set_dirty_lebitmap>> if (global_dirty_tracking) {
+ *   - include/system/ram_addr.h|398| <<cpu_physical_memory_set_dirty_lebitmap>> if (unlikely(global_dirty_tracking & GLOBAL_DIRTY_DIRTY_RATE)) {
+ *   - include/system/ram_addr.h|424| <<cpu_physical_memory_set_dirty_lebitmap>> if (!global_dirty_tracking) {
+ *   - include/system/ram_addr.h|436| <<cpu_physical_memory_set_dirty_lebitmap>> if (unlikely(global_dirty_tracking & GLOBAL_DIRTY_DIRTY_RATE)) {
+ *   - migration/ram.c|2403| <<ram_save_cleanup>> if (global_dirty_tracking & GLOBAL_DIRTY_MIGRATION) {
+ *   - system/memory.c|1888| <<memory_region_get_dirty_log_mask>> if (global_dirty_tracking && ((rb && qemu_ram_is_migratable(rb)) ||
+ *   - system/memory.c|2949| <<memory_global_dirty_log_start>> old_flags = global_dirty_tracking;
+ *   - system/memory.c|2951| <<memory_global_dirty_log_start>> trace_global_dirty_changed(global_dirty_tracking);
+ *   - system/memory.c|2956| <<memory_global_dirty_log_start>> trace_global_dirty_changed(global_dirty_tracking);
+ *   - system/memory.c|2970| <<memory_global_dirty_log_do_stop>> assert((global_dirty_tracking & flags) == flags);
+ *   - system/memory.c|2973| <<memory_global_dirty_log_do_stop>> trace_global_dirty_changed(global_dirty_tracking);
+ *   - system/memory.c|2975| <<memory_global_dirty_log_do_stop>> if (!global_dirty_tracking) {
+ *   - system/memory.c|3039| <<listener_add_address_space>> if (global_dirty_tracking) {
+ */
 unsigned int global_dirty_tracking;
 
 static QTAILQ_HEAD(, MemoryListener) memory_listeners
@@ -1880,6 +1901,15 @@ bool memory_region_has_guest_memfd(MemoryRegion *mr)
     return mr->ram_block && mr->ram_block->guest_memfd >= 0;
 }
 
+/*
+ * 在以下使用memory_region_get_dirty_log_mask():
+ *   - accel/kvm/kvm-all.c|668| <<kvm_mem_flags>> if (memory_region_get_dirty_log_mask(mr) != 0) {
+ *   - hw/virtio/vhost.c|568| <<vhost_section>> uint8_t dirty_mask = memory_region_get_dirty_log_mask(mr);
+ *   - system/memory.c|671| <<render_memory_region>> fr.dirty_log_mask = memory_region_get_dirty_log_mask(mr);
+ *   - system/memory.c|1923| <<memory_region_is_logging>> return memory_region_get_dirty_log_mask(mr) & (1 << client);
+ *   - system/memory.c|2280| <<memory_region_set_dirty>> memory_region_get_dirty_log_mask(mr));
+ *   - system/physmem.c|2836| <<invalidate_and_set_dirty>> uint8_t dirty_log_mask = memory_region_get_dirty_log_mask(mr);
+ */
 uint8_t memory_region_get_dirty_log_mask(MemoryRegion *mr)
 {
     uint8_t mask = mr->dirty_log_mask;
@@ -2232,6 +2262,21 @@ MemoryRegion *memory_translate_iotlb(IOMMUTLBEntry *iotlb, hwaddr *xlat_p,
     return mr;
 }
 
+/*
+ * 在以下使用memory_region_set_log():
+ *   - hw/display/bochs-display.c|311| <<bochs_display_realize>> memory_region_set_log(&s->vram, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/cg3.c|314| <<cg3_realizefn>> memory_region_set_log(&s->vram_mem, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/exynos4210_fimd.c|1148| <<fimd_update_memory_section>> memory_region_set_log(w->mem_section.mr, false, DIRTY_MEMORY_VGA);
+ *   - hw/display/exynos4210_fimd.c|1181| <<fimd_update_memory_section>> memory_region_set_log(w->mem_section.mr, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/framebuffer.c|34| <<framebuffer_update_memory_section>> memory_region_set_log(mem_section->mr, false, DIRTY_MEMORY_VGA);
+ *   - hw/display/framebuffer.c|51| <<framebuffer_update_memory_section>> memory_region_set_log(mem_section->mr, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/g364fb.c|484| <<g364fb_init>> memory_region_set_log(&s->mem_vram, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/macfb.c|682| <<macfb_common_realize>> memory_region_set_log(&s->mem_vram, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/sm501.c|1905| <<sm501_init>> memory_region_set_log(&s->local_mem_region, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/tcx.c|821| <<tcx_realizefn>> memory_region_set_log(&s->vram_mem, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/vga.c|1467| <<vga_dirty_log_start>> memory_region_set_log(&s->vram, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/vga.c|1472| <<vga_dirty_log_stop>> memory_region_set_log(&s->vram, false, DIRTY_MEMORY_VGA);
+ */
 void memory_region_set_log(MemoryRegion *mr, bool log, unsigned client)
 {
     uint8_t mask = 1 << client;
@@ -2929,6 +2974,14 @@ err:
     return false;
 }
 
+/*
+ * 在以下使用memory_global_dirty_log_start():
+ *   - hw/i386/xen/xen-hvm.c|702| <<qmp_xen_set_global_dirty_log>> memory_global_dirty_log_start(GLOBAL_DIRTY_MIGRATION, errp);
+ *   - migration/dirtyrate.c|98| <<global_dirty_log_change>> ret = memory_global_dirty_log_start(flag, &local_err)
+ *   - migration/dirtyrate.c|622| <<calculate_dirtyrate_dirty_bitmap>> if (!memory_global_dirty_log_start(GLOBAL_DIRTY_DIRTY_RATE, &local_err)) {
+ *   - migration/ram.c|2816| <<ram_init_bitmaps>> ret = memory_global_dirty_log_start(GLOBAL_DIRTY_MIGRATION, errp);
+ *   - migration/ram.c|3639| <<colo_incoming_start_dirty_log>> if (!memory_global_dirty_log_start(GLOBAL_DIRTY_MIGRATION,
+ */
 bool memory_global_dirty_log_start(unsigned int flags, Error **errp)
 {
     unsigned int old_flags;
diff --git a/system/runstate.c b/system/runstate.c
index 6178b0091..0f602cf8b 100644
--- a/system/runstate.c
+++ b/system/runstate.c
@@ -64,6 +64,17 @@
 static NotifierList exit_notifiers =
     NOTIFIER_LIST_INITIALIZER(exit_notifiers);
 
+/*
+ * 在以下使用current_run_state:
+ *   - system/runstate.c|195| <<runstate_check>> return current_run_state == state;
+ *   - system/runstate.c|234| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+ *   - system/runstate.c|237| <<runstate_set>> if (current_run_state == new_state) {
+ *   - system/runstate.c|241| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+ *   - system/runstate.c|243| <<runstate_set>> RunState_str(current_run_state),
+ *   - system/runstate.c|248| <<runstate_set>> current_run_state = new_state;
+ *   - system/runstate.c|253| <<runstate_get>> return current_run_state;
+ *   - system/runstate.c|272| <<qmp_query_status>> info->status = current_run_state;
+ */
 static RunState current_run_state = RUN_STATE_PRELAUNCH;
 
 /* We use RUN_STATE__MAX but any invalid value will do */
@@ -226,6 +237,31 @@ static void runstate_init(void)
     qemu_mutex_init(&vmstop_lock);
 }
 
+/*
+ * 迁移的时候在Source上
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:232
+ * #1  0x0000555555c08b8c in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:295
+ * #2  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #3  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #4  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #5  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x555558309590) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在Source上结束的时候
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_POSTMIGRATE) at ../system/runstate.c:232
+ * #1  0x0000555555c65e7b in migration_iteration_finish (s=0x5555575e27f0) at ../migration/migration.c:3518
+ * #2  0x0000555555c66522 in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3797
+ * #3  0x0000555556155700 in qemu_thread_start (args=0x555558309590) at ../util/qemu-thread-posix.c:393
+ * #4  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #5  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 /* This function will abort() on invalid state transitions */
 void runstate_set(RunState new_state)
 {
@@ -253,6 +289,9 @@ RunState runstate_get(void)
     return current_run_state;
 }
 
+/*
+ * 很多的调用
+ */
 bool runstate_is_running(void)
 {
     return runstate_check(RUN_STATE_RUNNING);
@@ -268,7 +307,21 @@ StatusInfo *qmp_query_status(Error **errp)
 {
     StatusInfo *info = g_malloc0(sizeof(*info));
 
+    /*
+     * 检查是不是RUN_STATE_RUNNING
+     */
     info->running = runstate_is_running();
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|195| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|234| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|237| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|241| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|243| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|248| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|253| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|272| <<qmp_query_status>> info->status = current_run_state;
+     */
     info->status = current_run_state;
 
     return info;
@@ -353,6 +406,11 @@ void qemu_del_vm_change_state_handler(VMChangeStateEntry *e)
     g_free(e);
 }
 
+/*
+ * 在以下使用vm_state_notify():
+ *   - system/cpus.c|300| <<do_vm_stop>> ret = vm_state_notify(0, state);
+ *   - system/cpus.c|778| <<vm_prepare_start>> vm_state_notify(1, state);
+ */
 int vm_state_notify(bool running, RunState state)
 {
     VMChangeStateEntry *e, *next;
@@ -506,6 +564,14 @@ static int qemu_debug_requested(void)
 /*
  * Reset the VM. Issue an event unless @reason is SHUTDOWN_CAUSE_NONE.
  */
+/*
+ * 在以下使用qemu_system_reset():
+ *   - hw/core/machine.c|1775| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+ *   - hw/xen/xen-hvm-common.c|609| <<cpu_handle_ioreq>> qemu_system_reset(request);
+ *   - migration/savevm.c|3893| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+ *   - system/runstate.c|941| <<main_loop_should_exit>> qemu_system_reset(request);
+ *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+ */
 void qemu_system_reset(ShutdownCause reason)
 {
     MachineClass *mc;
@@ -513,6 +579,18 @@ void qemu_system_reset(ShutdownCause reason)
 
     mc = current_machine ? MACHINE_GET_CLASS(current_machine) : NULL;
 
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     *
+     * kvm_arch_get_registers()
+     */
     cpu_synchronize_all_states();
 
     switch (reason) {
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index 47b0cd3a3..7244f16f7 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -2151,6 +2151,16 @@ static void hvf_vm_state_change(void *opaque, bool running, RunState state)
     if (running) {
         /* Update vtimer offset on all CPUs */
         hvf_state->vtimer_offset = mach_absolute_time() - s->vtimer_val;
+        /*
+	 * 在以下使用cpu_synchronize_all_states():
+         *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+         *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+         *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+         *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+         *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+         *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+         *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+	 */
         cpu_synchronize_all_states();
     } else {
         /* Remember vtimer value on every pause */
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 6d85149e6..76ac4ef87 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -8578,6 +8578,91 @@ static bool cpuid_has_xsave_feature(CPUX86State *env, const ExtSaveArea *esa)
     return false;
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_reset_hold (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../target/i386/cpu.c:8583
+ * #1  0x0000555555f30643 in resettable_phase_hold (obj=0x5555578c1c80, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #2  0x0000555555f30247 in resettable_assert_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #3  0x0000555555f3019f in resettable_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #4  0x0000555555f2dc7f in device_cold_reset (dev=0x5555578c1c80) at ../hw/core/qdev.c:239
+ * #5  0x0000555555892f26 in cpu_reset (cpu=0x5555578c1c80) at ../hw/core/cpu-common.c:113
+ * #6  0x0000555555e21bb8 in x86_cpu_realizefn (dev=0x5555578c1c80, errp=0x7fffffffd500) at ../target/i386/cpu.c:9494
+ * #7  0x0000555555e19e94 in max_x86_cpu_realize (dev=0x5555578c1c80, errp=0x7fffffffd500) at ../target/i386/cpu.c:6715
+ * #8  0x0000555555f2e730 in device_set_realized (obj=0x5555578c1c80, value=true, errp=0x7fffffffd610) at ../hw/core/qdev.c:494
+ * #9  0x0000555555f3869f in property_set_bool (obj=0x5555578c1c80, v=0x5555578cbc00, name=0x55555636b911 "realized", opaque=0x5555575e6860,
+ *     errp=0x7fffffffd610) at ../qom/object.c:2375
+ * #10 0x0000555555f36114 in object_property_set (obj=0x5555578c1c80, name=0x55555636b911 "realized", v=0x5555578cbc00, errp=0x7fffffffd610)
+ *     at ../qom/object.c:1450
+ * #11 0x0000555555f3afa1 in object_property_set_qobject (obj=0x5555578c1c80, name=0x55555636b911 "realized", value=0x5555578c1990,
+ *     errp=0x555557527c40 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #12 0x0000555555f364b9 in object_property_set_bool (obj=0x5555578c1c80, name=0x55555636b911 "realized", value=true, errp=0x555557527c40
+ *     <error_fatal>) at ../qom/object.c:1520
+ * #13 0x0000555555f2de28 in qdev_realize (dev=0x5555578c1c80, bus=0x0, errp=0x555557527c40 <error_fatal>) at ../hw/core/qdev.c:276
+ * #14 0x0000555555dd43aa in x86_cpu_new (x86ms=0x555557848900, apic_id=0, errp=0x555557527c40 <error_fatal>) at ../hw/i386/x86-common.c:64
+ * #15 0x0000555555dd4524 in x86_cpus_init (x86ms=0x555557848900, default_cpu_version=1) at ../hw/i386/x86-common.c:115
+ * #16 0x0000555555ddc4a5 in pc_q35_init (machine=0x555557848900) at ../hw/i386/pc_q35.c:194
+ * #17 0x0000555555ddce75 in pc_q35_machine_10_1_init (machine=0x555557848900) at ../hw/i386/pc_q35.c:382
+ * #18 0x000055555597a3e8 in machine_run_board_init (machine=0x555557848900, mem_path=0x0, errp=0x7fffffffd8e0) at ../hw/core/machine.c:1694
+ * #19 0x0000555555c03fd9 in qemu_init_board () at ../system/vl.c:2710
+ * #20 0x0000555555c0436f in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2804
+ * #21 0x0000555555c06e99 in qemu_init (argc=23, argv=0x7fffffffdc08) at ../system/vl.c:3840
+ * #22 0x0000555556082a15 in main (argc=23, argv=0x7fffffffdc08) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  x86_cpu_reset_hold (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../target/i386/cpu.c:8583
+ * #1  0x0000555555f30643 in resettable_phase_hold (obj=0x5555578c1c80, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #2  0x0000555555f30247 in resettable_assert_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #3  0x0000555555f3019f in resettable_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #4  0x0000555555f2dc7f in device_cold_reset (dev=0x5555578c1c80) at ../hw/core/qdev.c:239
+ * #5  0x0000555555892f26 in cpu_reset (cpu=0x5555578c1c80) at ../hw/core/cpu-common.c:113
+ * #6  0x0000555555d91a51 in x86_cpu_machine_reset_cb (opaque=0x5555578c1c80) at ../target/i386/cpu-system.c:266
+ * #7  0x000055555598181e in legacy_reset_hold (obj=0x5555578c8dc0, type=RESET_TYPE_COLD) at ../hw/core/reset.c:76
+ * #8  0x0000555555f30643 in resettable_phase_hold (obj=0x5555578c8dc0, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #9  0x0000555555f2f6a2 in resettable_container_child_foreach (obj=0x55555786d300, cb=0x555555f3052b <resettable_phase_hold>, opaque=0x0,
+ *     type=RESET_TYPE_COLD) at ../hw/core/resetcontainer.c:54
+ * #10 0x0000555555f30392 in resettable_child_foreach (rc=0x55555781ec70, obj=0x55555786d300, cb=0x555555f3052b <resettable_phase_hold>,
+ *     opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:92
+ * #11 0x0000555555f305e8 in resettable_phase_hold (obj=0x55555786d300, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:155
+ * #12 0x0000555555f30247 in resettable_assert_reset (obj=0x55555786d300, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #13 0x0000555555f3019f in resettable_reset (obj=0x55555786d300, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #14 0x0000555555981b6b in qemu_devices_reset (type=RESET_TYPE_COLD) at ../hw/core/reset.c:176
+ * #15 0x0000555555df6f1f in pc_machine_reset (machine=0x555557848900, type=RESET_TYPE_COLD) at ../hw/i386/pc.c:1701
+ * #16 0x0000555555c381bd in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at ../system/runstate.c:526
+ * #17 0x000055555597a5b6 in qdev_machine_creation_done () at ../hw/core/machine.c:1775
+ * #18 0x0000555555c04241 in qemu_machine_creation_done (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2778
+ * #19 0x0000555555c04380 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2806
+ * #20 0x0000555555c06e99 in qemu_init (argc=23, argv=0x7fffffffdc08) at ../system/vl.c:3840
+ * #21 0x0000555556082a15 in main (argc=23, argv=0x7fffffffdc08) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  x86_cpu_reset_hold (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../target/i386/cpu.c:8583
+ * #1  0x0000555555f30643 in resettable_phase_hold (obj=0x5555578c1c80, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #2  0x0000555555f30247 in resettable_assert_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #3  0x0000555555f3019f in resettable_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #4  0x0000555555f2dc7f in device_cold_reset (dev=0x5555578c1c80) at ../hw/core/qdev.c:239
+ * #5  0x0000555555892f26 in cpu_reset (cpu=0x5555578c1c80) at ../hw/core/cpu-common.c:113
+ * #6  0x0000555555d91a51 in x86_cpu_machine_reset_cb (opaque=0x5555578c1c80) at ../target/i386/cpu-system.c:266
+ * #7  0x000055555598181e in legacy_reset_hold (obj=0x5555578c8dc0, type=RESET_TYPE_COLD) at ../hw/core/reset.c:76
+ * #8  0x0000555555f30643 in resettable_phase_hold (obj=0x5555578c8dc0, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #9  0x0000555555f2f6a2 in resettable_container_child_foreach (obj=0x55555786d300, cb=0x555555f3052b <resettable_phase_hold>, opaque=0x0,
+ *     type=RESET_TYPE_COLD) at ../hw/core/resetcontainer.c:54
+ * #10 0x0000555555f30392 in resettable_child_foreach (rc=0x55555781ec70, obj=0x55555786d300, cb=0x555555f3052b <resettable_phase_hold>,
+ *     opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:92
+ * #11 0x0000555555f305e8 in resettable_phase_hold (obj=0x55555786d300, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:155
+ * #12 0x0000555555f30247 in resettable_assert_reset (obj=0x55555786d300, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #13 0x0000555555f3019f in resettable_reset (obj=0x55555786d300, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #14 0x0000555555981b6b in qemu_devices_reset (type=RESET_TYPE_COLD) at ../hw/core/reset.c:176
+ * #15 0x0000555555df6f1f in pc_machine_reset (machine=0x555557848900, type=RESET_TYPE_COLD) at ../hw/i386/pc.c:1701
+ * #16 0x0000555555c381bd in qemu_system_reset (reason=SHUTDOWN_CAUSE_GUEST_RESET) at ../system/runstate.c:526
+ * #17 0x0000555555c38c04 in main_loop_should_exit (status=0x7fffffffdac4) at ../system/runstate.c:871
+ * #18 0x0000555555c38d05 in qemu_main_loop () at ../system/runstate.c:904
+ * #19 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+* #20 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc08) at ../system/main.c:93
+ *
+ *
+ * 在以下使用x86_cpu_reset_hold():
+ *   - target/i386/cpu.c|10041| <<x86_cpu_common_class_init>> resettable_class_set_parent_phases(rc, NULL, x86_cpu_reset_hold, NULL,
+ */
 static void x86_cpu_reset_hold(Object *obj, ResetType type)
 {
     CPUState *cs = CPU(obj);
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index f977fc49a..67f9d204e 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -1961,6 +1961,14 @@ typedef struct CPUArchState {
     /* End of state preserved by INIT (dummy marker).  */
     struct {} end_init_save;
 
+    /*
+     * 在以下使用CPUX86State->system_time_msr:
+     *   - target/i386/machine.c|1738| <<vmstate_x86_cpu>> VMSTATE_UINT64(env.system_time_msr, X86CPU),
+     *   - hw/i386/kvm/clock.c|96| <<kvmclock_current_nsec>> if (!(env->system_time_msr & 1ULL)) {
+     *   - hw/i386/kvm/clock.c|101| <<kvmclock_current_nsec>> kvmclock_struct_pa = env->system_time_msr & ~1ULL;
+     *   - target/i386/kvm/kvm.c|4058| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
+     *   - target/i386/kvm/kvm.c|4826| <<kvm_get_msrs>> env->system_time_msr = msrs[i].data;
+     */
     uint64_t system_time_msr;
     uint64_t wall_clock_msr;
     uint64_t steal_time_msr;
@@ -2100,6 +2108,17 @@ typedef struct CPUArchState {
     uint8_t triple_fault_pending;
     uint32_t ins_len;
     uint32_t sipi_vector;
+    /*
+     * 在以下使用CPUX86State->tsc_valid:
+     *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     bool tsc_valid;
     int64_t tsc_khz;
     int64_t user_tsc_khz; /* for sanity check only */
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 369626f8c..1f4713797 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -297,6 +297,22 @@ bool kvm_hv_vpindex_settable(void)
     return hv_vpindex_settable;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_get_tsc (cs=0x5555578c30f0) at ../target/i386/kvm/kvm.c:301
+ * #1  0x0000555555d9c4e7 in do_kvm_synchronize_tsc (cpu=0x5555578c30f0, arg=...) at ../target/i386/kvm/kvm.c:324
+ * #2  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c30f0) at ../cpu-common.c:374
+ * #3  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c30f0) at ../system/cpus.c:453
+ * #4  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c30f0) at ../system/cpus.c:471
+ * #5  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c30f0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #6  0x0000555556155700 in qemu_thread_start (args=0x5555578cd750) at ../util/qemu-thread-posix.c:393
+ * #7  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #8  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用kvm_get_tsc():
+ *   - target/i386/kvm/kvm.c|324| <<do_kvm_synchronize_tsc>> kvm_get_tsc(cpu);
+ */
 static int kvm_get_tsc(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -304,6 +320,17 @@ static int kvm_get_tsc(CPUState *cs)
     uint64_t value;
     int ret;
 
+    /*
+     * 在以下使用CPUX86State->tsc_valid:
+     *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     if (env->tsc_valid) {
         return 0;
     }
@@ -319,11 +346,19 @@ static int kvm_get_tsc(CPUState *cs)
     return 0;
 }
 
+/*
+ * 在以下使用do_kvm_synchronize_tsc():
+ *   - target/i386/kvm/kvm.c|364| <<kvm_synchronize_all_tsc>> run_on_cpu(cpu, do_kvm_synchronize_tsc, RUN_ON_CPU_NULL);
+ */
 static inline void do_kvm_synchronize_tsc(CPUState *cpu, run_on_cpu_data arg)
 {
     kvm_get_tsc(cpu);
 }
 
+/*
+ * 在以下使用kvm_synchronize_all_tsc():
+ *   - hw/i386/kvm/clock.c|431| <<kvmclock_vm_state_change>> kvm_synchronize_all_tsc();
+ */
 void kvm_synchronize_all_tsc(void)
 {
     CPUState *cpu;
@@ -830,6 +865,17 @@ static void cpu_update_state(void *opaque, bool running, RunState state)
     CPUX86State *env = opaque;
 
     if (running) {
+        /*
+	 * 在以下使用CPUX86State->tsc_valid:
+         *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+         *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+         *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+         *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+         *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+	 */
         env->tsc_valid = false;
     }
 }
@@ -867,6 +913,11 @@ static inline bool freq_within_bounds(int freq, int target_freq)
         return false;
 }
 
+/*
+ * 在以下使用kvm_arch_set_tsc_khz():
+ *   - target/i386/kvm/kvm.c|2156| <<kvm_arch_init_vcpu>> r = kvm_arch_set_tsc_khz(cs);
+ *   - target/i386/kvm/kvm.c|5390| <<kvm_arch_put_registers>> kvm_arch_set_tsc_khz(cpu);
+ */
 static int kvm_arch_set_tsc_khz(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -2442,6 +2493,10 @@ void kvm_arch_after_reset_vcpu(X86CPU *cpu)
     }
 }
 
+/*
+ * 在以下使用kvm_arch_reset_parked_vcpu():
+ *   - accel/kvm/kvm-all.c|453| <<kvm_reset_parked_vcpus>> kvm_arch_reset_parked_vcpu(cpu->vcpu_id, cpu->kvm_fd);
+ */
 void kvm_arch_reset_parked_vcpu(unsigned long vcpu_id, int kvm_fd)
 {
     g_autofree struct kvm_msrs *msrs = NULL;
@@ -3907,6 +3962,10 @@ static void kvm_init_msrs(X86CPU *cpu)
     assert(kvm_buf_set_msrs(cpu) == 0);
 }
 
+/*
+ * 在以下使用kvm_put_msrs():
+ *   - target/i386/kvm/kvm.c|5408| <<kvm_arch_put_registers>> ret = kvm_put_msrs(x86_cpu, level);
+ */
 static int kvm_put_msrs(X86CPU *cpu, int level)
 {
     CPUX86State *env = &cpu->env;
@@ -3996,6 +4055,14 @@ static int kvm_put_msrs(X86CPU *cpu, int level)
     if (level >= KVM_PUT_RESET_STATE) {
         kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
         if (env->features[FEAT_KVM] & (CPUID_KVM_CLOCK | CPUID_KVM_CLOCK2)) {
+            /*
+	     * 在以下使用CPUX86State->system_time_msr:
+	     *   - target/i386/machine.c|1738| <<vmstate_x86_cpu>> VMSTATE_UINT64(env.system_time_msr, X86CPU),
+	     *   - hw/i386/kvm/clock.c|96| <<kvmclock_current_nsec>> if (!(env->system_time_msr & 1ULL)) {
+	     *   - hw/i386/kvm/clock.c|101| <<kvmclock_current_nsec>> kvmclock_struct_pa = env->system_time_msr & ~1ULL;
+	     *   - target/i386/kvm/kvm.c|4058| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
+	     *   - target/i386/kvm/kvm.c|4826| <<kvm_get_msrs>> env->system_time_msr = msrs[i].data;
+	     */
             kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
             kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, env->wall_clock_msr);
         }
@@ -4383,6 +4450,19 @@ static int kvm_get_sregs2(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_get_msrs (cpu=0x5555578c30f0) at ../target/i386/kvm/kvm.c:4387
+ * #1  0x0000555555dab277 in kvm_arch_get_registers (cs=0x5555578c30f0, errp=0x7fffedb02580) at ../target/i386/kvm/kvm.c:5414
+ * #2  0x0000555555f24545 in do_kvm_cpu_synchronize_state (cpu=0x5555578c30f0, arg=...) at ../accel/kvm/kvm-all.c:2914
+ * #3  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c30f0) at ../cpu-common.c:374
+ * #4  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c30f0) at ../system/cpus.c:453
+ * #5  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c30f0) at ../system/cpus.c:471
+ * #6  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c30f0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #7  0x0000555556155700 in qemu_thread_start (args=0x5555578cd750) at ../util/qemu-thread-posix.c:393
+ * #8  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #9  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 static int kvm_get_msrs(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -4448,6 +4528,17 @@ static int kvm_get_msrs(X86CPU *cpu)
     if (has_msr_virt_ssbd) {
         kvm_msr_entry_add(cpu, MSR_VIRT_SSBD, 0);
     }
+    /*
+     * 在以下使用CPUX86State->tsc_valid:
+     *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     if (!env->tsc_valid) {
         kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);
         env->tsc_valid = !runstate_is_running();
@@ -4740,6 +4831,14 @@ static int kvm_get_msrs(X86CPU *cpu)
             env->vm_hsave = msrs[i].data;
             break;
         case MSR_KVM_SYSTEM_TIME:
+            /*
+	     * 在以下使用CPUX86State->system_time_msr:
+	     *   - target/i386/machine.c|1738| <<vmstate_x86_cpu>> VMSTATE_UINT64(env.system_time_msr, X86CPU),
+	     *   - hw/i386/kvm/clock.c|96| <<kvmclock_current_nsec>> if (!(env->system_time_msr & 1ULL)) {
+	     *   - hw/i386/kvm/clock.c|101| <<kvmclock_current_nsec>> kvmclock_struct_pa = env->system_time_msr & ~1ULL;
+	     *   - target/i386/kvm/kvm.c|4058| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
+	     *   - target/i386/kvm/kvm.c|4826| <<kvm_get_msrs>> env->system_time_msr = msrs[i].data;
+	     */
             env->system_time_msr = msrs[i].data;
             break;
         case MSR_KVM_WALL_CLOCK:
@@ -5270,6 +5369,12 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * 在以下使用kvm_arch_put_registers():
+ *   - accel/kvm/kvm-all.c|2959| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+ *   - accel/kvm/kvm-all.c|2990| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+ *   - accel/kvm/kvm-all.c|3221| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+ */
 int kvm_arch_put_registers(CPUState *cpu, int level, Error **errp)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
diff --git a/target/i386/kvm/xen-emu.c b/target/i386/kvm/xen-emu.c
index 284c5ef6f..719bdcbee 100644
--- a/target/i386/kvm/xen-emu.c
+++ b/target/i386/kvm/xen-emu.c
@@ -980,11 +980,20 @@ static int vcpuop_register_runstate_info(CPUState *cs, CPUState *target,
     return 0;
 }
 
+/*
+ * 只给xen使用:
+ *   - target/i386/kvm/xen-emu.c|1093| <<do_set_singleshot_timer>> int64_t now = kvm_get_current_ns();
+ */
 static uint64_t kvm_get_current_ns(void)
 {
     struct kvm_clock_data data;
     int ret;
 
+    /*
+     * 在两个地方使用KVM_GET_CLOCK:
+     *   - hw/i386/kvm/clock.c|200| <<kvm_update_clock>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     *   - target/i386/kvm/xen-emu.c|992| <<kvm_get_current_ns>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     */
     ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
     if (ret < 0) {
         fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(ret));
-- 
2.39.5 (Apple Git-154)

