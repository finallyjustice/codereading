From 5dd0b604c311567ed175b7b7ee69ca7ee44efe28 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Sun, 16 Nov 2025 17:51:58 -0800
Subject: [PATCH 1/1] qemu for v10.1.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-accel-ops.c         |  28 ++
 accel/kvm/kvm-all.c               | 300 ++++++++++++++++
 backends/vhost-user.c             |  12 +
 block.c                           |  49 +++
 block/block-backend.c             | 136 +++++++
 block/file-posix.c                |  23 ++
 block/io.c                        |  12 +
 block/qcow2-bitmap.c              |  51 +++
 block/qcow2-cache.c               |  13 +
 block/qcow2-cluster.c             | 123 +++++++
 block/qcow2-refcount.c            | 472 ++++++++++++++++++++++++
 block/qcow2-snapshot.c            |  40 +++
 block/qcow2-threads.c             |  50 +++
 block/qcow2.c                     | 257 ++++++++++++++
 block/qcow2.h                     |  56 +++
 bsd-user/main.c                   |  30 ++
 cpu-common.c                      |  12 +
 dump/dump.c                       |  27 ++
 hw/acpi/vmclock.c                 |  30 ++
 hw/block/virtio-blk.c             |   9 +
 hw/core/cpu-common.c              |  26 ++
 hw/core/cpu-system.c              |   4 +
 hw/core/qdev.c                    |  33 ++
 hw/core/sysbus.c                  |   8 +
 hw/core/vm-change-state-handler.c |  32 ++
 hw/display/vga.c                  |   9 +
 hw/i386/kvm/apic.c                | 129 +++++++
 hw/i386/kvm/clock.c               | 428 ++++++++++++++++++++++
 hw/i386/pc.c                      |  18 +
 hw/i386/pc_piix.c                 |  16 +
 hw/i386/pc_q35.c                  |  16 +
 hw/i386/vapic.c                   |  49 +++
 hw/intc/apic.c                    |   9 +
 hw/intc/apic_common.c             |  40 +++
 hw/net/vhost_net.c                |  49 +++
 hw/net/virtio-net.c               | 197 +++++++++++
 hw/pci-host/i440fx.c              |   8 +
 hw/pci-host/q35.c                 |   8 +
 hw/scsi/scsi-bus.c                |  48 +++
 hw/scsi/scsi-disk.c               |  27 ++
 hw/scsi/vhost-scsi-common.c       |  97 +++++
 hw/scsi/vhost-scsi.c              | 103 ++++++
 hw/scsi/vhost-user-scsi.c         |  11 +
 hw/scsi/virtio-scsi-dataplane.c   |   4 +
 hw/scsi/virtio-scsi.c             |  34 ++
 hw/vfio/migration.c               |  19 +
 hw/vfio/pci.c                     |  36 ++
 hw/vfio/pci.h                     |  10 +
 hw/virtio/vdpa-dev.c              |  12 +
 hw/virtio/vhost.c                 | 142 ++++++++
 hw/virtio/virtio-balloon.c        |   4 +
 hw/virtio/virtio-pci.c            |  30 ++
 hw/virtio/virtio.c                |  72 ++++
 include/accel/accel-cpu-ops.h     |  36 ++
 include/hw/i386/apic_internal.h   |  54 +++
 include/hw/i386/pc.h              |   8 +
 include/hw/virtio/virtio-net.h    |  22 ++
 include/hw/virtio/virtio-scsi.h   |  28 ++
 include/migration/vmstate.h       |  22 ++
 include/net/net.h                 |   8 +
 include/system/kvm_int.h          |  14 +
 linux-headers/linux/kvm.h         |   7 +
 migration/block-dirty-bitmap.c    |  11 +
 migration/channel.c               |  24 ++
 migration/colo.c                  |  10 +
 migration/exec.c                  |   8 +
 migration/fd.c                    |   8 +
 migration/file.c                  |  15 +
 migration/migration.c             | 400 +++++++++++++++++++++
 migration/migration.h             |   7 +
 migration/ram.c                   |  42 +++
 migration/rdma.c                  |   5 +
 migration/savevm.c                | 391 ++++++++++++++++++++
 migration/savevm.h                |   8 +
 migration/socket.c                |   8 +
 migration/tls.c                   |   8 +
 monitor/qmp-cmds.c                |  17 +
 net/net.c                         |  76 ++++
 net/slirp.c                       |  11 +
 net/tap-linux.c                   |  12 +
 net/tap.c                         |  38 ++
 net/vhost-vdpa.c                  |   5 +
 qemu-img.c                        | 146 ++++++++
 system/cpus.c                     | 571 ++++++++++++++++++++++++++++++
 system/memory.c                   |  53 +++
 system/qdev-monitor.c             |   6 +
 system/runstate.c                 | 242 +++++++++++++
 target/arm/hvf/hvf.c              |  10 +
 target/i386/cpu.c                 |  85 +++++
 target/i386/cpu.h                 |  19 +
 target/i386/helper.c              |   9 +
 target/i386/kvm/kvm.c             | 177 +++++++++
 target/i386/kvm/xen-emu.c         |   9 +
 util/osdep.c                      |  44 +++
 util/qemu-timer.c                 |   7 +
 util/thread-pool.c                |   8 +
 96 files changed, 6147 insertions(+)

diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index b709187c7..e0fd2ca8f 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -27,6 +27,22 @@
 #include <linux/kvm.h>
 #include "kvm-cpus.h"
 
+/*
+ * (gdb) bt
+ * #0  kvm_arch_put_registers (cpu=0x5555577517f0, level=2, errp=0x7fffedb02580) at ../target/i386/kvm/kvm.c:5252
+ * #1  0x0000555555f0bc3e in do_kvm_cpu_synchronize_post_reset (cpu=0x5555577517f0, arg=...) at ../accel/kvm/kvm-all.c:2893
+ * #2  0x000055555588e3ab in process_queued_cpu_work (cpu=0x5555577517f0) at ../cpu-common.c:374
+ * #3  0x0000555555c1e021 in qemu_wait_io_event_common (cpu=0x5555577517f0) at ../system/cpus.c:451
+ * #4  0x0000555555c1e0ba in qemu_wait_io_event (cpu=0x5555577517f0) at ../system/cpus.c:469
+ * #5  0x0000555555f0fef1 in kvm_vcpu_thread_fn (arg=0x5555577517f0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #6  0x00005555561ad4c6 in qemu_thread_start (args=0x55555775bc80) at ../util/qemu-thread-posix.c:541
+ * #7  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #8  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用kvm_vcpu_thread_fn():
+ *   - accel/kvm/kvm-accel-ops.c|72| <<kvm_start_vcpu_thread>> qemu_thread_create(cpu->thread, thread_name, kvm_vcpu_thread_fn,
+ */
 static void *kvm_vcpu_thread_fn(void *arg)
 {
     CPUState *cpu = arg;
@@ -39,6 +55,9 @@ static void *kvm_vcpu_thread_fn(void *arg)
     cpu->thread_id = qemu_get_thread_id();
     current_cpu = cpu;
 
+    /*
+     * 只在这里调用kvm_init_vcpu()
+     */
     r = kvm_init_vcpu(cpu, &error_fatal);
     kvm_init_cpu_signals(cpu);
 
@@ -98,6 +117,15 @@ static void kvm_accel_ops_class_init(ObjectClass *oc, const void *data)
     ops->cpu_thread_is_idle = kvm_vcpu_thread_is_idle;
     ops->cpus_are_resettable = kvm_cpus_are_resettable;
     ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
     ops->synchronize_state = kvm_cpu_synchronize_state;
     ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 890d5ea9f..8f60b54ab 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -414,6 +414,11 @@ err:
     return ret;
 }
 
+/*
+ * 在以下使用kvm_park_vcpu():
+ *   - accel/kvm/kvm-all.c|503| <<kvm_create_and_park_vcpu>> kvm_park_vcpu(cpu);
+ *   - accel/kvm/kvm-all.c|548| <<do_kvm_destroy_vcpu>> kvm_park_vcpu(cpu);
+ */
 void kvm_park_vcpu(CPUState *cpu)
 {
     struct KVMParkedVcpu *vcpu;
@@ -423,6 +428,13 @@ void kvm_park_vcpu(CPUState *cpu)
     vcpu = g_malloc0(sizeof(*vcpu));
     vcpu->vcpu_id = kvm_arch_vcpu_id(cpu);
     vcpu->kvm_fd = cpu->kvm_fd;
+    /*
+     * 在以下使用KVMState->kvm_parked_vcpus:
+     *   - accel/kvm/kvm-all.c|426| <<kvm_park_vcpu>> QLIST_INSERT_HEAD(&kvm_state->kvm_parked_vcpus, vcpu, node);
+     *   - accel/kvm/kvm-all.c|434| <<kvm_unpark_vcpu>> QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
+     *   - accel/kvm/kvm-all.c|456| <<kvm_reset_parked_vcpus>> QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
+     *   - accel/kvm/kvm-all.c|2729| <<kvm_init>> QLIST_INIT(&s->kvm_parked_vcpus);
+     */
     QLIST_INSERT_HEAD(&kvm_state->kvm_parked_vcpus, vcpu, node);
 }
 
@@ -431,6 +443,13 @@ int kvm_unpark_vcpu(KVMState *s, unsigned long vcpu_id)
     struct KVMParkedVcpu *cpu;
     int kvm_fd = -ENOENT;
 
+    /*
+     * 在以下使用KVMState->kvm_parked_vcpus:
+     *   - accel/kvm/kvm-all.c|426| <<kvm_park_vcpu>> QLIST_INSERT_HEAD(&kvm_state->kvm_parked_vcpus, vcpu, node);
+     *   - accel/kvm/kvm-all.c|434| <<kvm_unpark_vcpu>> QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
+     *   - accel/kvm/kvm-all.c|456| <<kvm_reset_parked_vcpus>> QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
+     *   - accel/kvm/kvm-all.c|2729| <<kvm_init>> QLIST_INIT(&s->kvm_parked_vcpus);
+     */
     QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
         if (cpu->vcpu_id == vcpu_id) {
             QLIST_REMOVE(cpu, node);
@@ -445,10 +464,21 @@ int kvm_unpark_vcpu(KVMState *s, unsigned long vcpu_id)
     return kvm_fd;
 }
 
+/*
+ * 在以下使用kvm_reset_parked_vcpus():
+ *   - accel/kvm/kvm-all.c|3048| <<kvm_cpu_synchronize_post_reset>> kvm_reset_parked_vcpus(kvm_state);
+ */
 static void kvm_reset_parked_vcpus(KVMState *s)
 {
     struct KVMParkedVcpu *cpu;
 
+    /*
+     * 在以下使用KVMState->kvm_parked_vcpus:
+     *   - accel/kvm/kvm-all.c|426| <<kvm_park_vcpu>> QLIST_INSERT_HEAD(&kvm_state->kvm_parked_vcpus, vcpu, node);
+     *   - accel/kvm/kvm-all.c|434| <<kvm_unpark_vcpu>> QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
+     *   - accel/kvm/kvm-all.c|456| <<kvm_reset_parked_vcpus>> QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
+     *   - accel/kvm/kvm-all.c|2729| <<kvm_init>> QLIST_INIT(&s->kvm_parked_vcpus);
+     */
     QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
         kvm_arch_reset_parked_vcpu(cpu->vcpu_id, cpu->kvm_fd);
     }
@@ -460,6 +490,11 @@ static void kvm_reset_parked_vcpus(KVMState *s)
  *
  * @returns: 0 when success, errno (<0) when failed.
  */
+/*
+ * 在以下使用kvm_create_vcpu():
+ *   - accel/kvm/kvm-all.c|501| <<kvm_create_and_park_vcpu>> ret = kvm_create_vcpu(cpu);
+ *   - accel/kvm/kvm-all.c|574| <<kvm_init_vcpu>> ret = kvm_create_vcpu(cpu);
+ */
 static int kvm_create_vcpu(CPUState *cpu)
 {
     unsigned long vcpu_id = kvm_arch_vcpu_id(cpu);
@@ -490,12 +525,26 @@ static int kvm_create_vcpu(CPUState *cpu)
     return 0;
 }
 
+/*
+ * 在以下使用kvm_create_and_park_vcpu():
+ *   - target/ppc/kvm.c|2377| <<kvmppc_cpu_realize>> ret = kvm_create_and_park_vcpu(cs);
+ */
 int kvm_create_and_park_vcpu(CPUState *cpu)
 {
     int ret = 0;
 
+    /*
+     * 在以下使用kvm_create_vcpu():
+     *   - accel/kvm/kvm-all.c|501| <<kvm_create_and_park_vcpu>> ret = kvm_create_vcpu(cpu);
+     *   - accel/kvm/kvm-all.c|574| <<kvm_init_vcpu>> ret = kvm_create_vcpu(cpu);
+     */
     ret = kvm_create_vcpu(cpu);
     if (!ret) {
+        /*
+	 * 在以下使用kvm_park_vcpu():
+         *   - accel/kvm/kvm-all.c|503| <<kvm_create_and_park_vcpu>> kvm_park_vcpu(cpu);
+         *   - accel/kvm/kvm-all.c|548| <<do_kvm_destroy_vcpu>> kvm_park_vcpu(cpu);
+	 */
         kvm_park_vcpu(cpu);
     }
 
@@ -541,11 +590,20 @@ static int do_kvm_destroy_vcpu(CPUState *cpu)
         cpu->kvm_dirty_gfns = NULL;
     }
 
+    /*
+     * 在以下使用kvm_park_vcpu():
+     *   - accel/kvm/kvm-all.c|503| <<kvm_create_and_park_vcpu>> kvm_park_vcpu(cpu);
+     *   - accel/kvm/kvm-all.c|548| <<do_kvm_destroy_vcpu>> kvm_park_vcpu(cpu);
+     */
     kvm_park_vcpu(cpu);
 err:
     return ret;
 }
 
+/*
+ * 在以下使用kvm_destroy_vcpu():
+ *   - accel/kvm/kvm-accel-ops.c|63| <<kvm_vcpu_thread_fn>> kvm_destroy_vcpu(cpu);
+ */
 void kvm_destroy_vcpu(CPUState *cpu)
 {
     if (do_kvm_destroy_vcpu(cpu) < 0) {
@@ -554,6 +612,10 @@ void kvm_destroy_vcpu(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用kvm_init_vcpu():
+ *   - accel/kvm/kvm-accel-ops.c|42| <<kvm_vcpu_thread_fn>> r = kvm_init_vcpu(cpu, &error_fatal);
+ */
 int kvm_init_vcpu(CPUState *cpu, Error **errp)
 {
     KVMState *s = kvm_state;
@@ -567,6 +629,11 @@ int kvm_init_vcpu(CPUState *cpu, Error **errp)
         goto err;
     }
 
+    /*
+     * 在以下使用kvm_create_vcpu():
+     *   - accel/kvm/kvm-all.c|501| <<kvm_create_and_park_vcpu>> ret = kvm_create_vcpu(cpu);
+     *   - accel/kvm/kvm-all.c|574| <<kvm_init_vcpu>> ret = kvm_create_vcpu(cpu);
+     */
     ret = kvm_create_vcpu(cpu);
     if (ret < 0) {
         error_setg_errno(errp, -ret,
@@ -651,12 +718,24 @@ void kvm_close(void)
  * dirty pages logging control
  */
 
+/*
+ * 在以下使用kvm_mem_flags():
+ *   - accel/kvm/kvm-all.c|676| <<kvm_slot_update_flags>> mem->flags = kvm_mem_flags(mr);
+ *   - accel/kvm/kvm-all.c|1603| <<kvm_set_phys_mem>> mem->flags = kvm_mem_flags(mr);
+ */
 static int kvm_mem_flags(MemoryRegion *mr)
 {
     bool readonly = mr->readonly || memory_region_is_romd(mr);
     int flags = 0;
 
     if (memory_region_get_dirty_log_mask(mr) != 0) {
+        /*
+	 * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+         *   - accel/kvm/kvm-all.c|660| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+         *   - accel/kvm/kvm-all.c|772| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+         *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+         *   - accel/kvm/kvm-all.c|1864| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	 */
         flags |= KVM_MEM_LOG_DIRTY_PAGES;
     }
     if (readonly && kvm_readonly_mem_allowed) {
@@ -673,6 +752,11 @@ static int kvm_mem_flags(MemoryRegion *mr)
 static int kvm_slot_update_flags(KVMMemoryListener *kml, KVMSlot *mem,
                                  MemoryRegion *mr)
 {
+    /*
+     * 在以下使用kvm_mem_flags():
+     *   - accel/kvm/kvm-all.c|676| <<kvm_slot_update_flags>> mem->flags = kvm_mem_flags(mr);
+     *   - accel/kvm/kvm-all.c|1603| <<kvm_set_phys_mem>> mem->flags = kvm_mem_flags(mr);
+     */
     mem->flags = kvm_mem_flags(mr);
 
     /* If nothing changed effectively, no need to issue ioctl */
@@ -769,6 +853,13 @@ static void kvm_slot_reset_dirty_pages(KVMSlot *slot)
 /* Allocate the dirty bitmap for a slot  */
 static void kvm_slot_init_dirty_bitmap(KVMSlot *mem)
 {
+    /*
+     * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+     *   - accel/kvm/kvm-all.c|660| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+     *   - accel/kvm/kvm-all.c|772| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+     *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+     *   - accel/kvm/kvm-all.c|1864| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+     */
     if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
         return;
     }
@@ -1498,6 +1589,11 @@ int kvm_set_memory_attributes_shared(hwaddr start, uint64_t size)
     return kvm_set_memory_attributes(start, size, 0);
 }
 
+/*
+ * 在以下使用kvm_set_phys_mem():
+ *   - accel/kvm/kvm-all.c|1820| <<kvm_region_commit>> kvm_set_phys_mem(kml, &u1->section, false);
+ *   - accel/kvm/kvm-all.c|1830| <<kvm_region_commit>> kvm_set_phys_mem(kml, &u1->section, true);
+ */
 /* Called with KVMMemoryListener.slots_lock held */
 static void kvm_set_phys_mem(KVMMemoryListener *kml,
                              MemoryRegionSection *section, bool add)
@@ -1540,6 +1636,13 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
             if (!mem) {
                 return;
             }
+            /*
+	     * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+             *   - accel/kvm/kvm-all.c|660| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+             *   - accel/kvm/kvm-all.c|772| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+             *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+             *   - accel/kvm/kvm-all.c|1864| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	     */
             if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
                 /*
                  * NOTE: We should be aware of the fact that here we're only
@@ -1556,6 +1659,13 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
                  */
                 if (kvm_state->kvm_dirty_ring_size) {
                     kvm_dirty_ring_reap_locked(kvm_state, NULL);
+                    /*
+		     * 在以下使用KVMState->kvm_dirty_ring_with_bitmap:
+		     *   - accel/kvm/kvm-all.c|1559| <<kvm_set_phys_mem>> if (kvm_state->kvm_dirty_ring_with_bitmap) {
+		     *   - accel/kvm/kvm-all.c|1723| <<kvm_dirty_ring_init>> s->kvm_dirty_ring_with_bitmap = true;
+		     *   - accel/kvm/kvm-all.c|1853| <<kvm_log_sync_global>> if (s->kvm_dirty_ring_with_bitmap && last_stage &&
+		     *   - accel/kvm/kvm-all.c|4054| <<kvm_accel_instance_init>> s->kvm_dirty_ring_with_bitmap = false;
+		     */
                     if (kvm_state->kvm_dirty_ring_with_bitmap) {
                         kvm_slot_sync_dirty_pages(mem);
                         kvm_slot_get_dirty_log(kvm_state, mem);
@@ -1593,6 +1703,11 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
         mem->start_addr = start_addr;
         mem->ram_start_offset = ram_start_offset;
         mem->ram = ram;
+        /*
+	 * 在以下使用kvm_mem_flags():
+         *   - accel/kvm/kvm-all.c|676| <<kvm_slot_update_flags>> mem->flags = kvm_mem_flags(mr);
+         *   - accel/kvm/kvm-all.c|1603| <<kvm_set_phys_mem>> mem->flags = kvm_mem_flags(mr);
+	 */
         mem->flags = kvm_mem_flags(mr);
         mem->guest_memfd = mr->ram_block->guest_memfd;
         mem->guest_memfd_offset = (uint8_t*)ram - mr->ram_block->host;
@@ -1666,6 +1781,21 @@ static void kvm_dirty_ring_reaper_init(KVMState *s)
                        s, QEMU_THREAD_JOINABLE);
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_dirty_ring_init (s=0x55555775d560) at ../accel/kvm/kvm-all.c:1670
+ * #1  0x0000555555f23771 in kvm_setup_dirty_ring (s=0x55555775d560) at ../accel/kvm/kvm-all.c:2568
+ * #2  0x0000555555f23d89 in kvm_init (as=0x55555775d560, ms=0x55555784aad0) at ../accel/kvm/kvm-all.c:2729
+ * #3  0x0000555555d0aef9 in accel_init_machine (accel=0x55555775d560, ms=0x55555784aad0) at ../accel/accel-system.c:44
+ * #4  0x0000555555c03434 in do_configure_accelerator (opaque=0x7fffffffd964, opts=0x555557871f20, errp=0x555557527c40
+ *     <error_fatal>) at ../system/vl.c:2406
+ * #5  0x00005555561616f0 in qemu_opts_foreach (list=0x555557400b80 <qemu_accel_opts>, func=0x555555c032b3 <do_configure_accelerator>,
+ *     opaque=0x7fffffffd964, errp=0x555557527c40 <error_fatal>) at ../util/qemu-option.c:1135
+ * #6  0x0000555555c03714 in configure_accelerators (progname=0x7fffffffdfac "/home/zhang/kvm/test/qemu-10.1.0/build/qemu-system-x86_64")
+ *     at ../system/vl.c:2478
+ * #7  0x0000555555c06d77 in qemu_init (argc=21, argv=0x7fffffffdc18) at ../system/vl.c:3783
+ * #8  0x0000555556082a24 in main (argc=21, argv=0x7fffffffdc18) at ../system/main.c:71
+ */
 static int kvm_dirty_ring_init(KVMState *s)
 {
     uint32_t ring_size = s->kvm_dirty_ring_size;
@@ -1720,6 +1850,13 @@ static int kvm_dirty_ring_init(KVMState *s)
             return -EIO;
         }
 
+        /*
+	 * 在以下使用KVMState->kvm_dirty_ring_with_bitmap:
+         *   - accel/kvm/kvm-all.c|1559| <<kvm_set_phys_mem>> if (kvm_state->kvm_dirty_ring_with_bitmap) {
+         *   - accel/kvm/kvm-all.c|1723| <<kvm_dirty_ring_init>> s->kvm_dirty_ring_with_bitmap = true;
+         *   - accel/kvm/kvm-all.c|1853| <<kvm_log_sync_global>> if (s->kvm_dirty_ring_with_bitmap && last_stage &&
+         *   - accel/kvm/kvm-all.c|4054| <<kvm_accel_instance_init>> s->kvm_dirty_ring_with_bitmap = false;
+	 */
         s->kvm_dirty_ring_with_bitmap = true;
     }
 
@@ -1847,9 +1984,23 @@ static void kvm_log_sync_global(MemoryListener *l, bool last_stage)
     kvm_slots_lock();
     for (i = 0; i < kml->nr_slots_allocated; i++) {
         mem = &kml->slots[i];
+        /*
+	 * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+         *   - accel/kvm/kvm-all.c|660| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+         *   - accel/kvm/kvm-all.c|772| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+         *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+         *   - accel/kvm/kvm-all.c|1864| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	 */
         if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
             kvm_slot_sync_dirty_pages(mem);
 
+            /*
+	     * 在以下使用KVMState->kvm_dirty_ring_with_bitmap:
+	     *   - accel/kvm/kvm-all.c|1559| <<kvm_set_phys_mem>> if (kvm_state->kvm_dirty_ring_with_bitmap) {
+	     *   - accel/kvm/kvm-all.c|1723| <<kvm_dirty_ring_init>> s->kvm_dirty_ring_with_bitmap = true;
+	     *   - accel/kvm/kvm-all.c|1853| <<kvm_log_sync_global>> if (s->kvm_dirty_ring_with_bitmap && last_stage &&
+	     *   - accel/kvm/kvm-all.c|4054| <<kvm_accel_instance_init>> s->kvm_dirty_ring_with_bitmap = false;
+	     */
             if (s->kvm_dirty_ring_with_bitmap && last_stage &&
                 kvm_slot_get_dirty_log(s, mem)) {
                 kvm_slot_sync_dirty_pages(mem);
@@ -2638,6 +2789,13 @@ static int kvm_init(AccelState *as, MachineState *ms)
 #ifdef TARGET_KVM_HAVE_GUEST_DEBUG
     QTAILQ_INIT(&s->kvm_sw_breakpoints);
 #endif
+    /*
+     * 在以下使用KVMState->kvm_parked_vcpus:
+     *   - accel/kvm/kvm-all.c|426| <<kvm_park_vcpu>> QLIST_INSERT_HEAD(&kvm_state->kvm_parked_vcpus, vcpu, node);
+     *   - accel/kvm/kvm-all.c|434| <<kvm_unpark_vcpu>> QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
+     *   - accel/kvm/kvm-all.c|456| <<kvm_reset_parked_vcpus>> QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
+     *   - accel/kvm/kvm-all.c|2729| <<kvm_init>> QLIST_INIT(&s->kvm_parked_vcpus);
+     */
     QLIST_INIT(&s->kvm_parked_vcpus);
     s->fd = qemu_open_old(s->device ?: "/dev/kvm", O_RDWR);
     if (s->fd == -1) {
@@ -2875,6 +3033,10 @@ static int kvm_handle_internal_error(CPUState *cpu, struct kvm_run *run)
     return -1;
 }
 
+/*
+ * 在以下使用kvm_flush_coalesced_mmio_buffer():
+ *   - system/physmem.c|1170| <<qemu_flush_coalesced_mmio_buffer>> kvm_flush_coalesced_mmio_buffer();
+ */
 void kvm_flush_coalesced_mmio_buffer(void)
 {
     KVMState *s = kvm_state;
@@ -2907,6 +3069,10 @@ void kvm_flush_coalesced_mmio_buffer(void)
     s->coalesced_flush_in_progress = false;
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-all.c|2948| <<kvm_cpu_synchronize_state>> run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
@@ -2927,6 +3093,46 @@ static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用AccelOpsClass->synchronize_state():
+ *   - accel/hvf/hvf-accel-ops.c|382| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+ *   - accel/kvm/kvm-accel-ops.c|111| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - system/cpus.c|204| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+ *   - system/cpus.c|205| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|94| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+ *   - target/i386/whpx/whpx-accel-ops.c|97| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+ *
+ * 在以下使用kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-accel-ops.c|111| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - accel/kvm/kvm-all.c|3461| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+ *   - target/arm/kvm.c|1355| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/arm/kvm.c|2380| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+ *   - target/i386/kvm/kvm.c|5709| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5728| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5746| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5751| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6314| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+ *   - target/loongarch/kvm/kvm.c|1348| <<kvm_loongarch_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/riscv/kvm/kvm-cpu.c|1697| <<kvm_riscv_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/s390x/kvm/kvm.c|1910| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+ *
+ * 就是kvm_arch_get_registers()
+ */
 void kvm_cpu_synchronize_state(CPUState *cpu)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
@@ -2934,9 +3140,19 @@ void kvm_cpu_synchronize_state(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_post_reset():
+ *   - accel/kvm/kvm-all.c|3064| <<kvm_cpu_synchronize_post_reset>> run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_post_reset(CPUState *cpu, run_on_cpu_data arg)
 {
     Error *err = NULL;
+    /*
+     * 在以下使用kvm_arch_put_registers():
+     *   - accel/kvm/kvm-all.c|2959| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+     *   - accel/kvm/kvm-all.c|2990| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+     *   - accel/kvm/kvm-all.c|3221| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+     */
     int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
     if (ret) {
         if (err) {
@@ -2952,6 +3168,18 @@ static void do_kvm_cpu_synchronize_post_reset(CPUState *cpu, run_on_cpu_data arg
     cpu->vcpu_dirty = false;
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_post_reset():
+ *   - accel/hvf/hvf-accel-ops.c|380| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+ *   - accel/kvm/kvm-accel-ops.c|100| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+ *   - system/cpus.c|289| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+ *   - system/cpus.c|290| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+ *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+ *
+ * 只在以下使用kvm_cpu_synchronize_post_reset():
+ *   - accel/kvm/kvm-accel-ops.c|100| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+ */
 void kvm_cpu_synchronize_post_reset(CPUState *cpu)
 {
     run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
@@ -2961,9 +3189,19 @@ void kvm_cpu_synchronize_post_reset(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-all.c|3003| <<kvm_cpu_synchronize_post_init>> run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
 {
     Error *err = NULL;
+    /*
+     * 在以下使用kvm_arch_put_registers():
+     *   - accel/kvm/kvm-all.c|2959| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+     *   - accel/kvm/kvm-all.c|2990| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+     *   - accel/kvm/kvm-all.c|3221| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+     */
     int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
     if (ret) {
         if (err) {
@@ -2978,6 +3216,30 @@ static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
     cpu->vcpu_dirty = false;
 }
 
+/*
+ * (gdb) bt
+ * #0  cpu_synchronize_post_init (cpu=0x5555578f8060) at ../system/cpus.c:186
+ * #1  0x0000555555c08773 in cpu_synchronize_all_post_init () at ../system/cpus.c:157
+ * #2  0x0000555555c7e70e in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3199
+ * #3  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #4  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #5  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #6  0x00007fffffffc7e0 in ?? ()
+ * #7  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用AccelOpsClass->synchronize_post_init():
+ *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+ *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+ *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+ *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+ *
+ *
+ * 在以下使用kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ */
 void kvm_cpu_synchronize_post_init(CPUState *cpu)
 {
     if (!kvm_state->guest_state_protected) {
@@ -2994,6 +3256,15 @@ static void do_kvm_cpu_synchronize_pre_loadvm(CPUState *cpu, run_on_cpu_data arg
     cpu->vcpu_dirty = true;
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+ *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+ *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+ *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+ *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+ *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+ */
 void kvm_cpu_synchronize_pre_loadvm(CPUState *cpu)
 {
     run_on_cpu(cpu, do_kvm_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
@@ -3005,6 +3276,11 @@ static __thread int pending_sigbus_code;
 static __thread bool have_sigbus_pending;
 #endif
 
+/*
+ * 在以下使用kvm_cpu_kick():
+ *   - accel/kvm/kvm-all.c|3287| <<kvm_cpu_kick_self>> kvm_cpu_kick(current_cpu);
+ *   - accel/kvm/kvm-all.c|3973| <<kvm_ipi_signal>> kvm_cpu_kick(current_cpu);
+ */
 static void kvm_cpu_kick(CPUState *cpu)
 {
     qatomic_set(&cpu->kvm_run->immediate_exit, 1);
@@ -3171,6 +3447,12 @@ int kvm_cpu_exec(CPUState *cpu)
 
         if (cpu->vcpu_dirty) {
             Error *err = NULL;
+            /*
+	     * 在以下使用kvm_arch_put_registers():
+             *   - accel/kvm/kvm-all.c|2959| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+             *   - accel/kvm/kvm-all.c|2990| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+             *   - accel/kvm/kvm-all.c|3221| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+	     */
             ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
             if (ret) {
                 if (err) {
@@ -3204,6 +3486,9 @@ int kvm_cpu_exec(CPUState *cpu)
 
         run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0);
 
+	/*
+	 * 只在这里调用
+	 */
         attrs = kvm_arch_post_run(cpu, run);
 
 #ifdef KVM_HAVE_MCE_INJECTION
@@ -3686,6 +3971,10 @@ static int kvm_set_signal_mask(CPUState *cpu, const sigset_t *sigset)
     return r;
 }
 
+/*
+ * 在以下使用kvm_ipi_signal():
+ *   - accel/kvm/kvm-all.c|3988| <<kvm_init_cpu_signals>> sigact.sa_handler = kvm_ipi_signal;
+ */
 static void kvm_ipi_signal(int sig)
 {
     if (current_cpu) {
@@ -3694,6 +3983,10 @@ static void kvm_ipi_signal(int sig)
     }
 }
 
+/*
+ * 在以下使用kvm_init_cpu_signals():
+ *   - accel/kvm/kvm-accel-ops.c|47| <<kvm_vcpu_thread_fn>> kvm_init_cpu_signals(cpu);
+ */
 void kvm_init_cpu_signals(CPUState *cpu)
 {
     int r;
@@ -3995,6 +4288,13 @@ static void kvm_accel_instance_init(Object *obj)
     s->kernel_irqchip_split = ON_OFF_AUTO_AUTO;
     /* KVM dirty ring is by default off */
     s->kvm_dirty_ring_size = 0;
+    /*
+     * 在以下使用KVMState->kvm_dirty_ring_with_bitmap:
+     *   - accel/kvm/kvm-all.c|1559| <<kvm_set_phys_mem>> if (kvm_state->kvm_dirty_ring_with_bitmap) {
+     *   - accel/kvm/kvm-all.c|1723| <<kvm_dirty_ring_init>> s->kvm_dirty_ring_with_bitmap = true;
+     *   - accel/kvm/kvm-all.c|1853| <<kvm_log_sync_global>> if (s->kvm_dirty_ring_with_bitmap && last_stage &&
+     *   - accel/kvm/kvm-all.c|4054| <<kvm_accel_instance_init>> s->kvm_dirty_ring_with_bitmap = false;
+     */
     s->kvm_dirty_ring_with_bitmap = false;
     s->kvm_eager_split_size = 0;
     s->notify_vmexit = NOTIFY_VMEXIT_OPTION_RUN;
diff --git a/backends/vhost-user.c b/backends/vhost-user.c
index 42845329e..de1009f1a 100644
--- a/backends/vhost-user.c
+++ b/backends/vhost-user.c
@@ -108,6 +108,18 @@ vhost_user_backend_stop(VhostUserBackend *b)
         return 0;
     }
 
+    /*
+     * 在以下使用vhost_dev_stop():
+     *   - backends/cryptodev-vhost.c|113| <<cryptodev_vhost_stop_one>> vhost_dev_stop(&crypto->dev, dev, false);
+     *   - backends/vhost-user.c|111| <<vhost_user_backend_stop>> ret = vhost_dev_stop(&b->dev, b->vdev, true);
+     *   - hw/block/vhost-user-blk.c|228| <<vhost_user_blk_stop>> vhost_dev_stop(&s->dev, vdev, true);
+     *   - hw/net/vhost_net.c|382| <<vhost_net_start_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|401| <<vhost_net_stop_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|689| <<vhost_net_virtqueue_restart>> vhost_dev_stop(&net->dev, vdev, false);
+     *   - hw/scsi/vhost-scsi-common.c|111| <<vhost_scsi_common_stop>> ret = vhost_dev_stop(&vsc->dev, vdev, true);
+     *   - hw/virtio/vdpa-dev.c|304| <<vhost_vdpa_device_stop>> vhost_dev_stop(&s->dev, vdev, false);
+     *   - hw/virtio/vhost-user-base.c|80| <<vub_stop>> ret = vhost_dev_stop(&vub->vhost_dev, vdev, true);
+     */
     ret = vhost_dev_stop(&b->dev, b->vdev, true);
 
     if (k->set_guest_notifiers &&
diff --git a/block.c b/block.c
index 8848e9a7e..bc09e2f3a 100644
--- a/block.c
+++ b/block.c
@@ -990,6 +990,30 @@ BlockDriver *bdrv_find_protocol(const char *filename,
  * probing score.
  * Return the first block driver with the highest probing score.
  */
+/*
+ * (gdb) bt
+ * #0  bdrv_probe_all (buf=0x7fffffffd010 "QF", <incomplete sequence \373>, buf_size=512, filename=0x7fffffffda71 "test.img") at ../block.c:996
+ * #1  0x0000555555586642 in find_image_format (file=0x55555581e1c0, filename=0x7fffffffda71 "test.img", pdrv=0x7fffffffd288, errp=0x7fffffffd290)
+ *     at ../block.c:1036
+ * #2  0x000055555558dcce in bdrv_open_inherit (filename=0x7fffffffda71 "test.img", reference=0x0, options=0x555555816c10, flags=65792,
+ *     parent=0x0, child_class=0x0, child_role=0, parse_filename=true, errp=0x7fffffffd498) at ../block.c:4149
+ * #3  0x000055555558e3f8 in bdrv_open (filename=0x7fffffffda71 "test.img", reference=0x0, options=0x5555558107d0, flags=65792, errp=0x7fffffffd498)
+ *     at ../block.c:4273
+ * #4  0x00005555555b73ac in blk_new_open (filename=0x7fffffffda71 "test.img", reference=0x0, options=0x5555558107d0, flags=65792, errp=0x7fffffffd498)
+ *     at ../block/block-backend.c:457
+ * #5  0x000055555568fa6f in img_open_file (filename=0x7fffffffda71 "test.img", options=0x5555558107d0, fmt=0x0, flags=65792, writethrough=false,
+ *     quiet=false, force_share=false) at ../qemu-img.c:322
+ * #6  0x000055555568fc4e in img_open (image_opts=false, filename=0x7fffffffda71 "test.img", fmt=0x0, flags=65792, writethrough=false, quiet=false,
+ *     force_share=false) at ../qemu-img.c:367
+ * #7  0x00005555556962f6 in collect_image_info_list (image_opts=false, filename=0x7fffffffda71 "test.img", fmt=0x0, chain=false, force_share=false)
+ *     at ../qemu-img.c:3026
+ * #8  0x0000555555696661 in img_info (ccmd=0x5555557ccff8 <img_cmds+216>, argc=2, argv=0x7fffffffd730) at ../qemu-img.c:3158
+ * #9  0x000055555569d124 in main (argc=2, argv=0x7fffffffd730) at ../qemu-img.c:5976
+ *
+ * 在以下使用bdrv_probe_all():
+ *   - block.c|1036| <<find_image_format>> drv = bdrv_probe_all(buf, sizeof(buf), filename);
+ *   - block/raw-format.c|253| <<raw_co_pwritev>> drv = bdrv_probe_all(buf, 512, NULL);
+ */
 BlockDriver *bdrv_probe_all(const uint8_t *buf, int buf_size,
                             const char *filename)
 {
@@ -999,6 +1023,10 @@ BlockDriver *bdrv_probe_all(const uint8_t *buf, int buf_size,
 
     QLIST_FOREACH(d, &bdrv_drivers, list) {
         if (d->bdrv_probe) {
+            /*
+	     * qcow2_probe()
+	     * raw_probe()
+	     */
             score = d->bdrv_probe(buf, buf_size, filename);
             if (score > score_max) {
                 score_max = score;
@@ -1010,6 +1038,10 @@ BlockDriver *bdrv_probe_all(const uint8_t *buf, int buf_size,
     return drv;
 }
 
+/*
+ * 在以下使用find_image_format():
+ *   - block.c|4166| <<bdrv_open_inherit>> ret = find_image_format(file, filename, &drv, &local_err);
+ */
 static int find_image_format(BlockBackend *file, const char *filename,
                              BlockDriver **pdrv, Error **errp)
 {
@@ -1170,6 +1202,23 @@ int bdrv_parse_discard_flags(const char *mode, int *flags)
  *
  * Return 0 on success, -1 if the cache mode was invalid.
  */
+/*
+ * 在以下使用bdrv_parse_cache_mode():
+ *   - blockdev.c|834| <<drive_new>> if (bdrv_parse_cache_mode(value, &flags, &writethrough) != 0) {
+ *   - qemu-img.c|765| <<img_check>> ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);
+ *   - qemu-img.c|1015| <<img_commit>> ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);
+ *   - qemu-img.c|1456| <<img_compare>> ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);
+ *   - qemu-img.c|2553| <<img_convert>> ret = bdrv_parse_cache_mode(src_cache, &src_flags, &src_writethrough);
+ *   - qemu-img.c|2762| <<img_convert>> ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);
+ *   - qemu-img.c|3786| <<img_rebase>> ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);
+ *   - qemu-img.c|3793| <<img_rebase>> ret = bdrv_parse_cache_mode(src_cache, &src_flags, &src_writethrough);
+ *   - qemu-img.c|4537| <<img_amend>> ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);
+ *   - qemu-img.c|4819| <<img_bench>> ret = bdrv_parse_cache_mode(optarg, &flags, &writethrough);
+ *   - qemu-io-cmds.c|2411| <<reopen_f>> if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) < 0) {
+ *   - qemu-io.c|197| <<open_f>> if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) < 0) {
+ *   - qemu-io.c|584| <<main>> if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) < 0) {
+ *   - qemu-nbd.c|650| <<main>> if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) == -1) {
+ */
 int bdrv_parse_cache_mode(const char *mode, int *flags, bool *writethrough)
 {
     *flags &= ~BDRV_O_CACHE_MASK;
diff --git a/block/block-backend.c b/block/block-backend.c
index f8d6ba65c..d248f7d36 100644
--- a/block/block-backend.c
+++ b/block/block-backend.c
@@ -58,6 +58,13 @@ struct BlockBackend {
      * can be used to restore those options in the new BDS on insert) */
     BlockBackendRootState root_state;
 
+    /*
+     * 在以下使用BlockBackend->enable_write_cache:
+     *   - block/block-backend.c|1432| <<blk_co_do_pwritev_part>> if (!blk->enable_write_cache) {
+     *   - block/block-backend.c|2303| <<blk_enable_write_cache>> return blk->enable_write_cache;
+     *   - block/block-backend.c|2313| <<blk_set_enable_write_cache>> blk->enable_write_cache = wce;
+     *   - block/block-backend.c|2647| <<blk_save_vmstate>> if (ret == size && !blk->enable_write_cache) {
+     */
     bool enable_write_cache;
 
     /* I/O stats (display with "info blockstats"). */
@@ -1400,6 +1407,11 @@ int coroutine_fn blk_co_preadv_part(BlockBackend *blk, int64_t offset,
     return ret;
 }
 
+/*
+ * 在以下使用blk_co_do_pwritev_part():
+ *   - block/block-backend.c|1451| <<blk_co_pwritev_part>> ret = blk_co_do_pwritev_part(blk, offset, bytes, qiov, qiov_offset, flags);
+ *   - block/block-backend.c|1631| <<blk_aio_write_entry>> rwco->ret = blk_co_do_pwritev_part(rwco->blk, rwco->offset, acb->bytes,
+ */
 /* To be called between exactly one pair of blk_inc/dec_in_flight() */
 static int coroutine_fn
 blk_co_do_pwritev_part(BlockBackend *blk, int64_t offset, int64_t bytes,
@@ -1429,6 +1441,13 @@ blk_co_do_pwritev_part(BlockBackend *blk, int64_t offset, int64_t bytes,
                 bytes, THROTTLE_WRITE);
     }
 
+    /*
+     * 在以下使用BlockBackend->enable_write_cache:
+     *   - block/block-backend.c|1432| <<blk_co_do_pwritev_part>> if (!blk->enable_write_cache) {
+     *   - block/block-backend.c|2303| <<blk_enable_write_cache>> return blk->enable_write_cache;
+     *   - block/block-backend.c|2313| <<blk_set_enable_write_cache>> blk->enable_write_cache = wce;
+     *   - block/block-backend.c|2647| <<blk_save_vmstate>> if (ret == size && !blk->enable_write_cache) {
+     */
     if (!blk->enable_write_cache) {
         flags |= BDRV_REQ_FUA;
     }
@@ -1439,6 +1458,12 @@ blk_co_do_pwritev_part(BlockBackend *blk, int64_t offset, int64_t bytes,
     return ret;
 }
 
+/*
+ * 在以下使用blk_co_pwritev_part():
+ *   - block/block-backend.c|1492| <<blk_co_pwritev>> return blk_co_pwritev_part(blk, offset, bytes, qiov, 0, flags);
+ *   - block/block-backend.c|2664| <<blk_co_pwrite_compressed>> return blk_co_pwritev_part(blk, offset, bytes, &qiov, 0,
+ *   - block/mirror.c|1502| <<do_sync_target_write>> ret = blk_co_pwritev_part(job->target, offset, bytes,
+ */
 int coroutine_fn blk_co_pwritev_part(BlockBackend *blk, int64_t offset,
                                      int64_t bytes,
                                      QEMUIOVector *qiov, size_t qiov_offset,
@@ -2228,15 +2253,119 @@ bool blk_is_sg(BlockBackend *blk)
     return bdrv_is_sg(bs);
 }
 
+/*
+ * (gdb) bt
+ * #0  blk_enable_write_cache (blk=0x555557890ca0) at ../block/block-backend.c:2234
+ * #1  0x00005555559513a0 in blkconf_apply_backend_options (conf=0x5555577fc8a8, readonly=false, resizable=true, errp=0x7fffffffd400)
+ *     at ../hw/block/block.c:234
+ * #2  0x0000555555aee763 in scsi_realize (dev=0x5555577fc800, errp=0x7fffffffd400) at ../hw/scsi/scsi-disk.c:2533
+ * #3  0x0000555555aeeb58 in scsi_hd_realize (dev=0x5555577fc800, errp=0x7fffffffd400) at ../hw/scsi/scsi-disk.c:2613
+ * #4  0x0000555555ae162e in scsi_device_realize (s=0x5555577fc800, errp=0x7fffffffd400) at ../hw/scsi/scsi-bus.c:221
+ * #5  0x0000555555ae1f4a in scsi_qdev_realize (qdev=0x5555577fc800, errp=0x7fffffffd470) at ../hw/scsi/scsi-bus.c:397
+ * #6  0x0000555555f2e730 in device_set_realized (obj=0x5555577fc800, value=true, errp=0x7fffffffd700) at ../hw/core/qdev.c:494
+ * #7  0x0000555555f3869f in property_set_bool (obj=0x5555577fc800, v=0x5555586b2540, name=0x55555636b911 "realized", opaque=0x5555575e6f20,
+ *     errp=0x7fffffffd700) at ../qom/object.c:2375
+ * #8  0x0000555555f36114 in object_property_set (obj=0x5555577fc800, name=0x55555636b911 "realized", v=0x5555586b2540, errp=0x7fffffffd700)
+ *     at ../qom/object.c:1450
+ * #9  0x0000555555f3afa1 in object_property_set_qobject (obj=0x5555577fc800, name=0x55555636b911 "realized", value=0x5555586b3650,
+ *     errp=0x7fffffffd700) at ../qom/qom-qobject.c:28
+ * #10 0x0000555555f364b9 in object_property_set_bool (obj=0x5555577fc800, name=0x55555636b911 "realized", value=true, errp=0x7fffffffd700)
+ *     at ../qom/object.c:1520
+ * #11 0x0000555555f2de28 in qdev_realize (dev=0x5555577fc800, bus=0x55555852d8c8, errp=0x7fffffffd700) at ../hw/core/qdev.c:276
+ * #12 0x0000555555c31707 in qdev_device_add_from_qdict (opts=0x555558524050, from_json=false, errp=0x7fffffffd700)
+ *     at ../system/qdev-monitor.c:714
+ * #13 0x0000555555c317b4 in qdev_device_add (opts=0x5555575e3e90, errp=0x555557527c40 <error_fatal>) at ../system/qdev-monitor.c:732
+ * #14 0x0000555555bffe07 in device_init_func (opaque=0x0, opts=0x5555575e3e90, errp=0x555557527c40 <error_fatal>) at ../system/vl.c:1208
+ * #15 0x00005555561616e1 in qemu_opts_foreach (list=0x555557401700 <qemu_device_opts>, func=0x555555bffdd8 <device_init_func>,
+ *     opaque=0x0, errp=0x555557527c40 <error_fatal>) at ../util/qemu-option.c:1135
+ * #16 0x0000555555c0412e in qemu_create_cli_devices () at ../system/vl.c:2745
+ * #17 0x0000555555c04374 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2805
+ * #18 0x0000555555c06e99 in qemu_init (argc=29, argv=0x7fffffffdb28) at ../system/vl.c:3840
+ * #19 0x0000555556082a15 in main (argc=29, argv=0x7fffffffdb28) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  blk_enable_write_cache (blk=0x555557890ca0) at ../block/block-backend.c:2234
+ * #1  0x0000555555aeae7b in mode_sense_page (s=0x5555577fc800, page=8, p_outbuf=0x7fffffffd5c8, page_control=0) at ../hw/scsi/scsi-disk.c:1233
+ * #2  0x0000555555aeb4b0 in scsi_disk_emulate_mode_sense (r=0x555557948670, outbuf=0x555557944000 "") at ../hw/scsi/scsi-disk.c:1418
+ * #3  0x0000555555aed38e in scsi_disk_emulate_command (req=0x555557948670, buf=0x5555579486b0 "\032") at ../hw/scsi/scsi-disk.c:2073
+ * #4  0x0000555555ae3df1 in scsi_req_enqueue (req=0x555557948670) at ../hw/scsi/scsi-bus.c:1027
+ * #5  0x0000555555ec9a57 in virtio_scsi_handle_cmd_req_submit (s=0x55555852d630, req=0x55555793e8a0) at ../hw/scsi/virtio-scsi.c:892
+ * #6  0x0000555555ec9cab in virtio_scsi_handle_cmd_vq (s=0x55555852d630, vq=0x555558535738) at ../hw/scsi/virtio-scsi.c:935
+ * #7  0x0000555555ec9d27 in virtio_scsi_handle_cmd (vdev=0x55555852d630, vq=0x555558535738) at ../hw/scsi/virtio-scsi.c:948
+ * #8  0x0000555555ef0d93 in virtio_queue_notify_vq (vq=0x555558535738) at ../hw/virtio/virtio.c:2466
+ * #9  0x0000555555ef4785 in virtio_queue_host_notifier_read (n=0x5555585357ac) at ../hw/virtio/virtio.c:3896
+ * #10 0x000055555614fd9d in aio_dispatch_handler (ctx=0x5555575e4860, node=0x7ffe50006e00) at ../util/aio-posix.c:376
+ * #11 0x000055555614ffb2 in aio_dispatch_handlers (ctx=0x5555575e4860) at ../util/aio-posix.c:427
+ * #12 0x000055555615000e in aio_dispatch (ctx=0x5555575e4860) at ../util/aio-posix.c:437
+ * #13 0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4860, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #14 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e4c70) at ../glib/gmain.c:3325
+ * #15 g_main_context_dispatch (context=0x5555575e4c70) at ../glib/gmain.c:4043
+ * #16 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #17 0x00005555561721d5 in os_host_main_loop_wait (timeout=795176) at ../util/main-loop.c:310
+ * #18 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #19 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #20 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #21 0x0000555556082a7f in main (argc=29, argv=0x7fffffffdb28) at ../system/main.c:93
+ *
+ *
+ * 在以下使用blk_enable_write_cache():
+ *   - block/qapi.c|73| <<bdrv_block_device_info>> .writeback = blk ? blk_enable_write_cache(blk) : true,
+ *   - hw/block/block.c|234| <<blkconf_apply_backend_options>> case ON_OFF_AUTO_AUTO: wce = blk_enable_write_cache(blk); break;
+ *   - hw/block/virtio-blk.c|1179| <<virtio_blk_update_config>> blkcfg.wce = blk_enable_write_cache(s->blk);
+ *   - hw/block/virtio-blk.c|1258| <<virtio_blk_get_features>> if (blk_enable_write_cache(s->blk) ||
+ *   - hw/block/virtio-blk.c|1735| <<virtio_blk_device_realize>> s->original_wce = blk_enable_write_cache(conf->conf.blk);
+ *   - hw/ide/core.c|200| <<ide_identify>> if (blk_enable_write_cache(s->blk)) {
+ *   - hw/nvme/ctrl.c|6364| <<nvme_get_feature>> result = blk_enable_write_cache(ns->blkconf.blk);
+ *   - hw/nvme/ctrl.c|6625| <<nvme_set_feature>> if (!(dw11 & 0x1) && blk_enable_write_cache(ns->blkconf.blk)) {
+ *   - hw/scsi/scsi-disk.c|1233| <<mode_sense_page>> blk_enable_write_cache(s->qdev.conf.blk)) {
+ *   - hw/scsi/scsi-disk.c|1700| <<scsi_disk_emulate_mode_select>> if (!blk_enable_write_cache(s->qdev.conf.blk)) {
+ *   - qemu-io-cmds.c|2403| <<reopen_f>> bool writethrough = !blk_enable_write_cache(blk);
+ *   - qemu-io-cmds.c|2452| <<reopen_f>> if (!writethrough != blk_enable_write_cache(blk) &&
+ */
 bool blk_enable_write_cache(BlockBackend *blk)
 {
     IO_CODE();
+    /*
+     * 在以下使用BlockBackend->enable_write_cache:
+     *   - block/block-backend.c|1432| <<blk_co_do_pwritev_part>> if (!blk->enable_write_cache) {
+     *   - block/block-backend.c|2303| <<blk_enable_write_cache>> return blk->enable_write_cache;
+     *   - block/block-backend.c|2313| <<blk_set_enable_write_cache>> blk->enable_write_cache = wce;
+     *   - block/block-backend.c|2647| <<blk_save_vmstate>> if (ret == size && !blk->enable_write_cache) {
+     */
     return blk->enable_write_cache;
 }
 
+/*
+ * 在以下使用blk_set_enable_write_cache():
+ *   - block/block-backend.c|366| <<blk_new>> blk_set_enable_write_cache(blk, true);
+ *   - block/export/export.c|185| <<blk_exp_add>> blk_set_enable_write_cache(blk, !export->writethrough);
+ *   - block/export/vhost-user-blk-server.c|181| <<vu_blk_set_config>> blk_set_enable_write_cache(vexp->export.blk, wce);
+ *   - blockdev.c|638| <<blockdev_init>> blk_set_enable_write_cache(blk, !writethrough);
+ *   - hw/block/block.c|249| <<blkconf_apply_backend_options>> blk_set_enable_write_cache(blk, wce);
+ *   - hw/block/virtio-blk.c|1134| <<virtio_blk_reset>> blk_set_enable_write_cache(s->blk, s->original_wce);
+ *   - hw/block/virtio-blk.c|1237| <<virtio_blk_set_config>> blk_set_enable_write_cache(s->blk, blkcfg.wce != 0);
+ *   - hw/block/virtio-blk.c|1301| <<virtio_blk_set_status>> blk_set_enable_write_cache(s->blk,
+ *   - hw/ide/core.c|1686| <<cmd_set_features>> blk_set_enable_write_cache(s->blk, true);
+ *   - hw/ide/core.c|1691| <<cmd_set_features>> blk_set_enable_write_cache(s->blk, false);
+ *   - hw/ide/core.c|2855| <<ide_drive_post_load>> blk_set_enable_write_cache(s->blk, !!(s->identify_data[85] & (1 << 5)));
+ *   - hw/nvme/ctrl.c|6629| <<nvme_set_feature>> blk_set_enable_write_cache(ns->blkconf.blk, dw11 & 1);
+ *   - hw/scsi/scsi-disk.c|1574| <<scsi_disk_apply_mode_select>> blk_set_enable_write_cache(s->qdev.conf.blk, (p[0] & 4) != 0);
+ *   - qemu-img.c|298| <<img_open_opts>> blk_set_enable_write_cache(blk, !writethrough);
+ *   - qemu-img.c|327| <<img_open_file>> blk_set_enable_write_cache(blk, !writethrough);
+ *   - qemu-io-cmds.c|2505| <<reopen_f>> blk_set_enable_write_cache(blk, !writethrough);
+ *   - qemu-io.c|115| <<openfile>> blk_set_enable_write_cache(qemuio_blk, !writethrough);
+ *   - qemu-nbd.c|1156| <<main>> blk_set_enable_write_cache(blk, !writethrough);
+ */
 void blk_set_enable_write_cache(BlockBackend *blk, bool wce)
 {
     IO_CODE();
+    /*
+     * 在以下使用BlockBackend->enable_write_cache:
+     *   - block/block-backend.c|1432| <<blk_co_do_pwritev_part>> if (!blk->enable_write_cache) {
+     *   - block/block-backend.c|2303| <<blk_enable_write_cache>> return blk->enable_write_cache;
+     *   - block/block-backend.c|2313| <<blk_set_enable_write_cache>> blk->enable_write_cache = wce;
+     *   - block/block-backend.c|2647| <<blk_save_vmstate>> if (ret == size && !blk->enable_write_cache) {
+     */
     blk->enable_write_cache = wce;
 }
 
@@ -2571,6 +2700,13 @@ int blk_save_vmstate(BlockBackend *blk, const uint8_t *buf,
         return ret;
     }
 
+    /*
+     * 在以下使用BlockBackend->enable_write_cache:
+     *   - block/block-backend.c|1432| <<blk_co_do_pwritev_part>> if (!blk->enable_write_cache) {
+     *   - block/block-backend.c|2303| <<blk_enable_write_cache>> return blk->enable_write_cache;
+     *   - block/block-backend.c|2313| <<blk_set_enable_write_cache>> blk->enable_write_cache = wce;
+     *   - block/block-backend.c|2647| <<blk_save_vmstate>> if (ret == size && !blk->enable_write_cache) {
+     */
     if (ret == size && !blk->enable_write_cache) {
         ret = bdrv_flush(blk_bs(blk));
     }
diff --git a/block/file-posix.c b/block/file-posix.c
index 8c738674c..c07a9593a 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -533,6 +533,11 @@ static int check_hdev_writable(int fd)
     return 0;
 }
 
+/*
+ * 在以下使用raw_parse_flags():
+ *   - block/file-posix.c|712| <<raw_open_common>> raw_parse_flags(bdrv_flags, &s->open_flags, false);
+ *   - block/file-posix.c|1083| <<raw_reconfigure_getfd>> raw_parse_flags(flags, open_flags, has_writers);
+ */
 static void raw_parse_flags(int bdrv_flags, int *open_flags, bool has_writers)
 {
     bool read_write = false;
@@ -709,6 +714,11 @@ static int raw_open_common(BlockDriverState *bs, QDict *options,
                                                false);
 
     s->open_flags = open_flags;
+    /*
+     * 在以下使用raw_parse_flags():
+     *   - block/file-posix.c|712| <<raw_open_common>> raw_parse_flags(bdrv_flags, &s->open_flags, false);
+     *   - block/file-posix.c|1083| <<raw_reconfigure_getfd>> raw_parse_flags(flags, open_flags, has_writers);
+     */
     raw_parse_flags(bdrv_flags, &s->open_flags, false);
 
     s->fd = -1;
@@ -1080,6 +1090,11 @@ static int raw_reconfigure_getfd(BlockDriverState *bs, int flags,
         *open_flags |= O_NONBLOCK;
     }
 
+    /*
+     * 在以下使用raw_parse_flags():
+     *   - block/file-posix.c|712| <<raw_open_common>> raw_parse_flags(bdrv_flags, &s->open_flags, false);
+     *   - block/file-posix.c|1083| <<raw_reconfigure_getfd>> raw_parse_flags(flags, open_flags, has_writers);
+     */
     raw_parse_flags(flags, open_flags, has_writers);
 
 #ifdef O_ASYNC
@@ -2497,6 +2512,14 @@ out:
 
 static int coroutine_fn raw_thread_pool_submit(ThreadPoolFunc func, void *arg)
 {
+    /*
+     * 在以下使用thread_pool_submit_co():
+     *   - block/file-posix.c|2515| <<raw_thread_pool_submit>> return thread_pool_submit_co(func, arg);
+     *   - block/qcow2-threads.c|54| <<qcow2_co_process>> ret = thread_pool_submit_co(func, arg);
+     *   - scsi/pr-manager.c|64| <<pr_manager_execute>> return thread_pool_submit_co(pr_manager_worker, &data);
+     *   - scsi/qemu-pr-helper.c|194| <<do_sgio>> r = thread_pool_submit_co(do_sgio_worker, &data);
+     *   - tests/unit/test-thread-pool.c|80| <<co_test_cb>> thread_pool_submit_co(worker_cb, data);
+     */
     return thread_pool_submit_co(func, arg);
 }
 
diff --git a/block/io.c b/block/io.c
index 9bd8ba843..a03f98326 100644
--- a/block/io.c
+++ b/block/io.c
@@ -1772,6 +1772,18 @@ int coroutine_fn bdrv_co_preadv(BdrvChild *child,
     return bdrv_co_preadv_part(child, offset, bytes, qiov, 0, flags);
 }
 
+/*
+ * 在以下使用bdrv_co_preadv_part():
+ *   - block/block-backend.c|1365| <<blk_co_do_preadv_part>> ret = bdrv_co_preadv_part(blk->root, offset, bytes, qiov, qiov_offset,
+ *   - block/copy-before-write.c|278| <<cbw_co_preadv_snapshot>> ret = bdrv_co_preadv_part(file, offset, cur_bytes,
+ *   - block/copy-on-read.c|145| <<cor_co_preadv_part>> return bdrv_co_preadv_part(bs->file, offset, bytes, qiov, qiov_offset,
+ *   - block/copy-on-read.c|170| <<cor_co_preadv_part>> ret = bdrv_co_preadv_part(bs->file, offset, n, qiov, qiov_offset,
+ *   - block/filter-compress.c|72| <<compress_co_preadv_part>> return bdrv_co_preadv_part(bs->file, offset, bytes, qiov, qiov_offset,
+ *   - block/io.c|1772| <<bdrv_co_preadv>> return bdrv_co_preadv_part(child, offset, bytes, qiov, 0, flags);
+ *   - block/preallocate.c|282| <<preallocate_co_preadv_part>> return bdrv_co_preadv_part(bs->file, offset, bytes, qiov, qiov_offset,
+ *   - block/qcow2.c|2457| <<qcow2_co_preadv_task>> return bdrv_co_preadv_part(bs->backing, offset, bytes,
+ *   - block/qcow2.c|2471| <<qcow2_co_preadv_task>> return bdrv_co_preadv_part(s->data_file, host_offset,
+ */
 int coroutine_fn bdrv_co_preadv_part(BdrvChild *child,
     int64_t offset, int64_t bytes,
     QEMUIOVector *qiov, size_t qiov_offset,
diff --git a/block/qcow2-bitmap.c b/block/qcow2-bitmap.c
index 256ec9987..18f39b068 100644
--- a/block/qcow2-bitmap.c
+++ b/block/qcow2-bitmap.c
@@ -787,6 +787,23 @@ bitmap_list_store(BlockDriverState *bs, Qcow2BitmapList *bm_list,
     bitmap_directory_to_be(dir, dir_size);
 
     if (!in_place) {
+        /*
+	 * 在以下使用qcow2_alloc_clusters():
+         *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+         *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+         *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+         *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+         *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+         *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+         *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+         *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+         *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+         *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+         *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+	 */
         dir_offset = qcow2_alloc_clusters(bs, dir_size);
         if (dir_offset < 0) {
             ret = dir_offset;
@@ -1328,6 +1345,23 @@ store_bitmap_data(BlockDriverState *bs, BdrvDirtyBitmap *bitmap,
                                                           end - offset);
         assert(write_size <= s->cluster_size);
 
+	/*
+	 * 在以下使用qcow2_alloc_clusters():
+         *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+         *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+         *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+         *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+         *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+         *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+         *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+         *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+         *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+         *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+         *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+	 */
         off = qcow2_alloc_clusters(bs, s->cluster_size);
         if (off < 0) {
             error_setg_errno(errp, -off,
@@ -1395,6 +1429,23 @@ store_bitmap(BlockDriverState *bs, Qcow2Bitmap *bm, Error **errp)
     }
 
     assert(tb_size <= BME_MAX_TABLE_SIZE);
+    /*
+     * 在以下使用qcow2_alloc_clusters():
+     *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+     *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+     *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+     *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+     *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+     *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+     *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+     *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+     *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+     *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+     *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+     */
     tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
     if (tb_offset < 0) {
         error_setg_errno(errp, -tb_offset,
diff --git a/block/qcow2-cache.c b/block/qcow2-cache.c
index 23d9588b0..b559ad664 100644
--- a/block/qcow2-cache.c
+++ b/block/qcow2-cache.c
@@ -120,6 +120,11 @@ void qcow2_cache_clean_unused(Qcow2Cache *c)
     c->cache_clean_lru_counter = c->lru_counter;
 }
 
+/*
+ * 在以下使用qcow2_cache_create():
+ *   - block/qcow2.c|1075| <<qcow2_update_options_prepare>> r->l2_table_cache = qcow2_cache_create(bs, l2_cache_size, l2_cache_entry_size);
+ *   - block/qcow2.c|1077| <<qcow2_update_options_prepare>> r->refcount_block_cache = qcow2_cache_create(bs, refcount_cache_size, s->cluster_size);
+ */
 Qcow2Cache *qcow2_cache_create(BlockDriverState *bs, int num_tables,
                                unsigned table_size)
 {
@@ -346,6 +351,14 @@ qcow2_cache_do_get(BlockDriverState *bs, Qcow2Cache *c, uint64_t offset,
     /* Check if the table is already cached */
     i = lookup_index = (offset / c->table_size * 4) % c->size;
     do {
+        /*
+	 * typedef struct Qcow2CachedTable {
+	 *     int64_t  offset;
+	 *     uint64_t lru_counter;
+	 *     int      ref;
+	 *     bool     dirty;
+	 * } Qcow2CachedTable;
+	 */
         const Qcow2CachedTable *t = &c->entries[i];
         if (t->offset == offset) {
             goto found;
diff --git a/block/qcow2-cluster.c b/block/qcow2-cluster.c
index ce8c0076b..4116ca5b8 100644
--- a/block/qcow2-cluster.c
+++ b/block/qcow2-cluster.c
@@ -83,6 +83,33 @@ fail:
     return ret;
 }
 
+/*
+ * qemu-img create的时候
+ * (gdb) bt
+ * #0  qcow2_grow_l1_table (bs=0x55555581b510, min_size=1, exact_size=true) at ../block/qcow2-cluster.c:88
+ * #1  0x00005555555f3018 in qcow2_co_truncate (bs=0x55555581b510, offset=10485760, exact=false, prealloc=PREALLOC_MODE_OFF, flags=0, 
+ *     errp=0x7fffffffd4e8) at ../block/qcow2.c:4409
+ * #2  0x00005555555d45a7 in bdrv_co_truncate (child=0x55555580ac00, offset=10485760, exact=false, prealloc=PREALLOC_MODE_OFF, flags=0, 
+ *     errp=0x7fffffffd4e8) at ../block/io.c:3691
+ * #3  0x00005555555bc68c in blk_co_truncate (blk=0x555555820840, offset=10485760, exact=false, prealloc=PREALLOC_MODE_OFF, flags=0, 
+ *     errp=0x7fffffffd4e8) at ../block/block-backend.c:2556
+ * #4  0x00005555555f17c0 in qcow2_co_create (create_options=0x5555558194d0, errp=0x7fffffffd4e8) at ../block/qcow2.c:3827
+ * #5  0x00005555555f1ebc in qcow2_co_create_opts (drv=0x5555557d7100 <bdrv_qcow2>, filename=0x7fffffffda88 "test.qcow2", opts=0x555555810b10, 
+ *     errp=0x7fffffffd4e8) at ../block/qcow2.c:4014
+ * #6  0x0000555555585318 in bdrv_co_create (drv=0x5555557d7100 <bdrv_qcow2>, filename=0x7fffffffda88 "test.qcow2", opts=0x555555810b10, 
+ *     errp=0x7fffffffd4e8) at ../block.c:548
+ * #7  0x000055555566c02c in bdrv_co_create_entry (opaque=0x7fffffffd440) at block/block-gen.c:1179
+ * #8  0x000055555570b3fe in coroutine_trampoline (i0=1434520480, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #9  0x00007ffff5ee7120 in ?? () from /lib64/libc.so.6
+ * #10 0x00007fffffffcc40 in ?? ()
+ * #11 0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用qcow2_grow_l1_table():
+ *   - block/qcow2-cluster.c|777| <<get_cluster_table>> ret = qcow2_grow_l1_table(bs, l1_index + 1, false);
+ *   - block/qcow2-snapshot.c|812| <<qcow2_snapshot_goto>> ret = qcow2_grow_l1_table(bs, sn->l1_size, true);
+ *   - block/qcow2.c|4482| <<qcow2_co_truncate>> ret = qcow2_grow_l1_table(bs, new_l1_size, true);
+ */
 int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,
                         bool exact_size)
 {
@@ -139,6 +166,23 @@ int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,
 
     /* write new table (align to cluster) */
     BLKDBG_EVENT(bs->file, BLKDBG_L1_GROW_ALLOC_TABLE);
+    /*
+     * 在以下使用qcow2_alloc_clusters():
+     *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+     *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+     *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+     *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+     *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+     *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+     *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+     *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+     *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+     *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+     *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+     */
     new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
     if (new_l1_table_offset < 0) {
         qemu_vfree(new_l1_table);
@@ -285,6 +329,23 @@ static int GRAPH_RDLOCK l2_allocate(BlockDriverState *bs, int l1_index)
 
     /* allocate a new l2 entry */
 
+    /*
+     * 在以下使用qcow2_alloc_clusters():
+     *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+     *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+     *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+     *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+     *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+     *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+     *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+     *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+     *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+     *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+     *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+     */
     l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
     if (l2_offset < 0) {
         ret = l2_offset;
@@ -583,6 +644,14 @@ do_perform_cow_write(BlockDriverState *bs, uint64_t cluster_offset,
  *
  * Returns 0 on success, -errno in error cases.
  */
+/*
+ * 在以下使用qcow2_get_host_offset():
+ *   - block/qcow2.c|2186| <<qcow2_co_block_status>> ret = qcow2_get_host_offset(bs, offset, &bytes, &host_offset, &type);
+ *   - block/qcow2.c|2430| <<qcow2_co_preadv_part>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+ *   - block/qcow2.c|4135| <<qcow2_co_pwrite_zeroes>> ret = qcow2_get_host_offset(bs, offset, &nr, &off, &type);
+ *   - block/qcow2.c|4209| <<qcow2_co_copy_range_from>> ret = qcow2_get_host_offset(bs, src_offset, &cur_bytes, &copy_offset, &type);
+ *   - block/qcow2.c|5464| <<qcow2_has_compressed_clusters>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+ */
 int qcow2_get_host_offset(BlockDriverState *bs, uint64_t offset,
                           unsigned int *bytes, uint64_t *host_offset,
                           QCow2SubclusterType *subcluster_type)
@@ -766,6 +835,12 @@ get_cluster_table(BlockDriverState *bs, uint64_t offset,
 
     l1_index = offset_to_l1_index(s, offset);
     if (l1_index >= s->l1_size) {
+        /*
+	 * 在以下使用qcow2_grow_l1_table():
+	 *   - block/qcow2-cluster.c|777| <<get_cluster_table>> ret = qcow2_grow_l1_table(bs, l1_index + 1, false);
+         *   - block/qcow2-snapshot.c|812| <<qcow2_snapshot_goto>> ret = qcow2_grow_l1_table(bs, sn->l1_size, true);
+         *   - block/qcow2.c|4482| <<qcow2_co_truncate>> ret = qcow2_grow_l1_table(bs, new_l1_size, true);
+	 */
         ret = qcow2_grow_l1_table(bs, l1_index + 1, false);
         if (ret < 0) {
             return ret;
@@ -1620,6 +1695,23 @@ do_alloc_cluster_offset(BlockDriverState *bs, uint64_t guest_offset,
     /* Allocate new clusters */
     trace_qcow2_cluster_alloc_phys(qemu_coroutine_self());
     if (*host_offset == INV_OFFSET) {
+        /*
+	 * 在以下使用qcow2_alloc_clusters():
+         *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+         *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+         *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+         *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+         *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+         *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+         *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+         *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+         *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+         *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+         *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+	 */
         int64_t cluster_offset =
             qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
         if (cluster_offset < 0) {
@@ -2295,6 +2387,20 @@ expand_zero_clusters_in_l1(BlockDriverState *bs, uint64_t *l1_table,
             goto fail;
         }
 
+        /*
+	 * 在以下使用qcow2_get_refcount():
+         *   - block/qcow2-cluster.c|2339| <<expand_zero_clusters_in_l1>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|1016| <<alloc_clusters_noref>> ret = qcow2_get_refcount(bs, next_cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1131| <<qcow2_alloc_clusters_at>> ret = qcow2_get_refcount(bs, cluster_index++, &refcount);
+         *   - block/qcow2-refcount.c|1168| <<qcow2_alloc_bytes>> ret = qcow2_get_refcount(bs, offset >> s->cluster_bits, &refcount);
+         *   - block/qcow2-refcount.c|1480| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1521| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2096| <<check_oflag_copied>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2140| <<check_oflag_copied>> ret = qcow2_get_refcount(bs,
+         *   - block/qcow2-refcount.c|2428| <<compare_refcounts>> ret = qcow2_get_refcount(bs, i, &refcount1);
+         *   - block/qcow2-refcount.c|3831| <<qcow2_get_last_cluster>> int ret = qcow2_get_refcount(bs, i, &refcount);
+         *   - block/qcow2-refcount.c|3871| <<qcow2_detect_metadata_preallocation>> int ret = qcow2_get_refcount(bs, i, &refcount);
+	 */
         ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
                                  &l2_refcount);
         if (ret < 0) {
@@ -2340,6 +2446,23 @@ expand_zero_clusters_in_l1(BlockDriverState *bs, uint64_t *l1_table,
                         continue;
                     }
 
+                    /*
+		     * 在以下使用qcow2_alloc_clusters():
+                     *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+                     *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+                     *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+                     *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+                     *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+                     *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+                     *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+                     *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+                     *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+                     *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+                     *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+                     *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+                     *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+                     *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+		     */
                     offset = qcow2_alloc_clusters(bs, s->cluster_size);
                     if (offset < 0) {
                         ret = offset;
diff --git a/block/qcow2-refcount.c b/block/qcow2-refcount.c
index 0266542ce..6576ad685 100644
--- a/block/qcow2-refcount.c
+++ b/block/qcow2-refcount.c
@@ -98,6 +98,10 @@ static void update_max_refcount_table_index(BDRVQcow2State *s)
     s->max_refcount_table_index = i;
 }
 
+/*
+ * 在以下使用qcow2_refcount_init():
+ *   - block/qcow2.c|1703| <<qcow2_do_open>> ret = qcow2_refcount_init(bs);
+ */
 int coroutine_fn qcow2_refcount_init(BlockDriverState *bs)
 {
     BDRVQcow2State *s = bs->opaque;
@@ -106,6 +110,32 @@ int coroutine_fn qcow2_refcount_init(BlockDriverState *bs)
 
     assert(s->refcount_order >= 0 && s->refcount_order <= 6);
 
+    /*
+     * 67 static Qcow2GetRefcountFunc *const get_refcount_funcs[] = {
+     * 68     &get_refcount_ro0,
+     * 69     &get_refcount_ro1,
+     * 70     &get_refcount_ro2,
+     * 71     &get_refcount_ro3,
+     * 72     &get_refcount_ro4,
+     * 73     &get_refcount_ro5,
+     * 74     &get_refcount_ro6
+     * 75 };
+     * 76
+     * 77 static Qcow2SetRefcountFunc *const set_refcount_funcs[] = {
+     * 78     &set_refcount_ro0,
+     * 79     &set_refcount_ro1,
+     * 80     &set_refcount_ro2,
+     * 81     &set_refcount_ro3,
+     * 82     &set_refcount_ro4,
+     * 83     &set_refcount_ro5,
+     * 84     &set_refcount_ro6
+     * 85 };
+     *
+     *
+     * 在以下设置BDRVQcow2State->get_refcount:
+     *   - block/qcow2-refcount.c|109| <<qcow2_refcount_init>> s->get_refcount = get_refcount_funcs[s->refcount_order];
+     *   - block/qcow2-refcount.c|3850| <<qcow2_change_refcount_order>> s->get_refcount = new_get_refcount;
+     */
     s->get_refcount = get_refcount_funcs[s->refcount_order];
     s->set_refcount = set_refcount_funcs[s->refcount_order];
 
@@ -244,6 +274,20 @@ load_refcount_block(BlockDriverState *bs, int64_t refcount_block_offset,
  * Retrieves the refcount of the cluster given by its index and stores it in
  * *refcount. Returns 0 on success and -errno on failure.
  */
+/*
+ * 在以下使用qcow2_get_refcount():
+ *   - block/qcow2-cluster.c|2339| <<expand_zero_clusters_in_l1>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+ *   - block/qcow2-refcount.c|1016| <<alloc_clusters_noref>> ret = qcow2_get_refcount(bs, next_cluster_index, &refcount);
+ *   - block/qcow2-refcount.c|1131| <<qcow2_alloc_clusters_at>> ret = qcow2_get_refcount(bs, cluster_index++, &refcount);
+ *   - block/qcow2-refcount.c|1168| <<qcow2_alloc_bytes>> ret = qcow2_get_refcount(bs, offset >> s->cluster_bits, &refcount);
+ *   - block/qcow2-refcount.c|1480| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, cluster_index, &refcount);
+ *   - block/qcow2-refcount.c|1521| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+ *   - block/qcow2-refcount.c|2096| <<check_oflag_copied>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+ *   - block/qcow2-refcount.c|2140| <<check_oflag_copied>> ret = qcow2_get_refcount(bs,
+ *   - block/qcow2-refcount.c|2428| <<compare_refcounts>> ret = qcow2_get_refcount(bs, i, &refcount1);
+ *   - block/qcow2-refcount.c|3831| <<qcow2_get_last_cluster>> int ret = qcow2_get_refcount(bs, i, &refcount);
+ *   - block/qcow2-refcount.c|3871| <<qcow2_detect_metadata_preallocation>> int ret = qcow2_get_refcount(bs, i, &refcount);
+ */
 int qcow2_get_refcount(BlockDriverState *bs, int64_t cluster_index,
                        uint64_t *refcount)
 {
@@ -279,6 +323,32 @@ int qcow2_get_refcount(BlockDriverState *bs, int64_t cluster_index,
     }
 
     block_index = cluster_index & (s->refcount_block_size - 1);
+    /*
+     * 67 static Qcow2GetRefcountFunc *const get_refcount_funcs[] = {
+     * 68     &get_refcount_ro0,
+     * 69     &get_refcount_ro1,
+     * 70     &get_refcount_ro2,
+     * 71     &get_refcount_ro3,
+     * 72     &get_refcount_ro4,
+     * 73     &get_refcount_ro5,
+     * 74     &get_refcount_ro6
+     * 75 };
+     * 76
+     * 77 static Qcow2SetRefcountFunc *const set_refcount_funcs[] = {
+     * 78     &set_refcount_ro0,
+     * 79     &set_refcount_ro1,
+     * 80     &set_refcount_ro2,
+     * 81     &set_refcount_ro3,
+     * 82     &set_refcount_ro4,
+     * 83     &set_refcount_ro5,
+     * 84     &set_refcount_ro6
+     * 85 };
+     *
+     *
+     * 在以下设置BDRVQcow2State->get_refcount:
+     *   - block/qcow2-refcount.c|109| <<qcow2_refcount_init>> s->get_refcount = get_refcount_funcs[s->refcount_order];
+     *   - block/qcow2-refcount.c|3850| <<qcow2_change_refcount_order>> s->get_refcount = new_get_refcount;
+     */
     *refcount = s->get_refcount(refcount_block, block_index);
 
     qcow2_cache_put(s->refcount_block_cache, &refcount_block);
@@ -405,6 +475,18 @@ alloc_refcount_block(BlockDriverState *bs, int64_t cluster_index,
     } else {
         /* Described somewhere else. This can recurse at most twice before we
          * arrive at a block that describes itself. */
+        /*
+	 * 在以下使用update_refcount():
+         *   - block/qcow2-refcount.c|422| <<alloc_refcount_block>> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,
+         *   - block/qcow2-refcount.c|957| <<update_refcount>> dummy = update_refcount(bs, offset, cluster_offset - offset, addend,
+         *   - block/qcow2-refcount.c|981| <<qcow2_update_cluster_refcount>> ret = update_refcount(bs, cluster_index << s->cluster_bits, 1, addend,
+         *   - block/qcow2-refcount.c|1135| <<qcow2_alloc_clusters>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+         *   - block/qcow2-refcount.c|1185| <<qcow2_alloc_clusters_at>> ret = update_refcount(bs, offset, i << s->cluster_bits, 1, false,
+         *   - block/qcow2-refcount.c|1265| <<qcow2_alloc_bytes>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+         *   - block/qcow2-refcount.c|1323| <<qcow2_free_clusters>> ret = update_refcount(bs, offset, size, 1, true, type);
+         *   - block/qcow2-refcount.c|1501| <<qcow2_update_snapshot_refcount>> ret = update_refcount(
+         *   - block/qcow2-refcount.c|2562| <<compare_refcounts>> ret = update_refcount(bs, i << s->cluster_bits, 1,
+	 */
         ret = update_refcount(bs, new_block, s->cluster_size, 1, false,
                               QCOW2_DISCARD_NEVER);
         if (ret < 0) {
@@ -807,6 +889,18 @@ found:
 /* XXX: cache several refcount block clusters ? */
 /* @addend is the absolute value of the addend; if @decrease is set, @addend
  * will be subtracted from the current refcount, otherwise it will be added */
+/*
+ * 在以下使用update_refcount():
+ *   - block/qcow2-refcount.c|422| <<alloc_refcount_block>> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,
+ *   - block/qcow2-refcount.c|957| <<update_refcount>> dummy = update_refcount(bs, offset, cluster_offset - offset, addend,
+ *   - block/qcow2-refcount.c|981| <<qcow2_update_cluster_refcount>> ret = update_refcount(bs, cluster_index << s->cluster_bits, 1, addend,
+ *   - block/qcow2-refcount.c|1135| <<qcow2_alloc_clusters>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+ *   - block/qcow2-refcount.c|1185| <<qcow2_alloc_clusters_at>> ret = update_refcount(bs, offset, i << s->cluster_bits, 1, false,
+ *   - block/qcow2-refcount.c|1265| <<qcow2_alloc_bytes>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+ *   - block/qcow2-refcount.c|1323| <<qcow2_free_clusters>> ret = update_refcount(bs, offset, size, 1, true, type);
+ *   - block/qcow2-refcount.c|1501| <<qcow2_update_snapshot_refcount>> ret = update_refcount(
+ *   - block/qcow2-refcount.c|2562| <<compare_refcounts>> ret = update_refcount(bs, i << s->cluster_bits, 1,
+ */
 static int GRAPH_RDLOCK
 update_refcount(BlockDriverState *bs, int64_t offset, int64_t length,
                 uint64_t addend, bool decrease, enum qcow2_discard_type type)
@@ -880,6 +974,22 @@ update_refcount(BlockDriverState *bs, int64_t offset, int64_t length,
         } else {
             refcount += addend;
         }
+        /*
+	 * 在以下设置free_cluster_index:
+         *   - block/qcow2-refcount.c|856| <<update_refcount>> s->free_cluster_index = (start >> s->cluster_bits);
+         *   - block/qcow2-refcount.c|884| <<update_refcount>> s->free_cluster_index = cluster_index;
+         *   - block/qcow2-refcount.c|983| <<alloc_clusters_noref>> uint64_t next_cluster_index = s->free_cluster_index++;
+	 *   - block/qcow2-refcount.c|3694| <<qcow2_discard_refcount_block>> s->free_cluster_index = cluster_index;
+         *   - block/qcow2.c|5060| <<make_completely_empty>> s->free_cluster_index = 0;
+         * 在以下使用free_cluster_index:
+         *   - block/qcow2-refcount.c|855| <<update_refcount>> if (s->free_cluster_index > (start >> s->cluster_bits)) {
+         *   - block/qcow2-refcount.c|883| <<update_refcount>> if (refcount == 0 && cluster_index < s->free_cluster_index) {
+         *   - block/qcow2-refcount.c|995| <<alloc_clusters_noref>> if (s->free_cluster_index > 0 &&
+         *   - block/qcow2-refcount.c|996| <<alloc_clusters_noref>> s->free_cluster_index - 1 > (max >> s->cluster_bits))
+         *   - block/qcow2-refcount.c|1004| <<alloc_clusters_noref>> (s->free_cluster_index - nb_clusters) << s->cluster_bits);
+         *   - block/qcow2-refcount.c|1006| <<alloc_clusters_noref>> return (s->free_cluster_index - nb_clusters) << s->cluster_bits;
+         *   - block/qcow2-refcount.c|3693| <<qcow2_discard_refcount_block>> if (cluster_index < s->free_cluster_index) {
+	 */
         if (refcount == 0 && cluster_index < s->free_cluster_index) {
             s->free_cluster_index = cluster_index;
         }
@@ -924,6 +1034,18 @@ fail:
      */
     if (ret < 0) {
         int dummy;
+        /*
+	 * 在以下使用update_refcount():
+         *   - block/qcow2-refcount.c|422| <<alloc_refcount_block>> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,
+         *   - block/qcow2-refcount.c|957| <<update_refcount>> dummy = update_refcount(bs, offset, cluster_offset - offset, addend,
+         *   - block/qcow2-refcount.c|981| <<qcow2_update_cluster_refcount>> ret = update_refcount(bs, cluster_index << s->cluster_bits, 1, addend,
+         *   - block/qcow2-refcount.c|1135| <<qcow2_alloc_clusters>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+         *   - block/qcow2-refcount.c|1185| <<qcow2_alloc_clusters_at>> ret = update_refcount(bs, offset, i << s->cluster_bits, 1, false,
+         *   - block/qcow2-refcount.c|1265| <<qcow2_alloc_bytes>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+         *   - block/qcow2-refcount.c|1323| <<qcow2_free_clusters>> ret = update_refcount(bs, offset, size, 1, true, type);
+         *   - block/qcow2-refcount.c|1501| <<qcow2_update_snapshot_refcount>> ret = update_refcount(
+         *   - block/qcow2-refcount.c|2562| <<compare_refcounts>> ret = update_refcount(bs, i << s->cluster_bits, 1,
+	 */
         dummy = update_refcount(bs, offset, cluster_offset - offset, addend,
                                 !decrease, QCOW2_DISCARD_NEVER);
         (void)dummy;
@@ -948,6 +1070,18 @@ int qcow2_update_cluster_refcount(BlockDriverState *bs,
     BDRVQcow2State *s = bs->opaque;
     int ret;
 
+    /*
+     * 在以下使用update_refcount():
+     *   - block/qcow2-refcount.c|422| <<alloc_refcount_block>> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,
+     *   - block/qcow2-refcount.c|957| <<update_refcount>> dummy = update_refcount(bs, offset, cluster_offset - offset, addend,
+     *   - block/qcow2-refcount.c|981| <<qcow2_update_cluster_refcount>> ret = update_refcount(bs, cluster_index << s->cluster_bits, 1, addend,
+     *   - block/qcow2-refcount.c|1135| <<qcow2_alloc_clusters>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+     *   - block/qcow2-refcount.c|1185| <<qcow2_alloc_clusters_at>> ret = update_refcount(bs, offset, i << s->cluster_bits, 1, false,
+     *   - block/qcow2-refcount.c|1265| <<qcow2_alloc_bytes>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+     *   - block/qcow2-refcount.c|1323| <<qcow2_free_clusters>> ret = update_refcount(bs, offset, size, 1, true, type);
+     *   - block/qcow2-refcount.c|1501| <<qcow2_update_snapshot_refcount>> ret = update_refcount(
+     *   - block/qcow2-refcount.c|2562| <<compare_refcounts>> ret = update_refcount(bs, i << s->cluster_bits, 1,
+     */
     ret = update_refcount(bs, cluster_index << s->cluster_bits, 1, addend,
                           decrease, type);
     if (ret < 0) {
@@ -980,12 +1114,45 @@ alloc_clusters_noref(BlockDriverState *bs, uint64_t size, uint64_t max)
     nb_clusters = size_to_clusters(s, size);
 retry:
     for(i = 0; i < nb_clusters; i++) {
+        /*
+	 * 在以下设置free_cluster_index:
+         *   - block/qcow2-refcount.c|856| <<update_refcount>> s->free_cluster_index = (start >> s->cluster_bits);
+         *   - block/qcow2-refcount.c|884| <<update_refcount>> s->free_cluster_index = cluster_index;
+         *   - block/qcow2-refcount.c|983| <<alloc_clusters_noref>> uint64_t next_cluster_index = s->free_cluster_index++;
+         *   - block/qcow2-refcount.c|3694| <<qcow2_discard_refcount_block>> s->free_cluster_index = cluster_index;
+         *   - block/qcow2.c|5060| <<make_completely_empty>> s->free_cluster_index = 0;
+         * 在以下使用free_cluster_index:
+         *   - block/qcow2-refcount.c|855| <<update_refcount>> if (s->free_cluster_index > (start >> s->cluster_bits)) {
+         *   - block/qcow2-refcount.c|883| <<update_refcount>> if (refcount == 0 && cluster_index < s->free_cluster_index) {
+         *   - block/qcow2-refcount.c|995| <<alloc_clusters_noref>> if (s->free_cluster_index > 0 &&
+         *   - block/qcow2-refcount.c|996| <<alloc_clusters_noref>> s->free_cluster_index - 1 > (max >> s->cluster_bits))
+         *   - block/qcow2-refcount.c|1004| <<alloc_clusters_noref>> (s->free_cluster_index - nb_clusters) << s->cluster_bits);
+         *   - block/qcow2-refcount.c|1006| <<alloc_clusters_noref>> return (s->free_cluster_index - nb_clusters) << s->cluster_bits;
+         *   - block/qcow2-refcount.c|3693| <<qcow2_discard_refcount_block>> if (cluster_index < s->free_cluster_index) {
+	 */
         uint64_t next_cluster_index = s->free_cluster_index++;
+        /*
+	 * 在以下使用qcow2_get_refcount():
+         *   - block/qcow2-cluster.c|2339| <<expand_zero_clusters_in_l1>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|1016| <<alloc_clusters_noref>> ret = qcow2_get_refcount(bs, next_cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1131| <<qcow2_alloc_clusters_at>> ret = qcow2_get_refcount(bs, cluster_index++, &refcount);
+         *   - block/qcow2-refcount.c|1168| <<qcow2_alloc_bytes>> ret = qcow2_get_refcount(bs, offset >> s->cluster_bits, &refcount);
+         *   - block/qcow2-refcount.c|1480| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1521| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2096| <<check_oflag_copied>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2140| <<check_oflag_copied>> ret = qcow2_get_refcount(bs,
+         *   - block/qcow2-refcount.c|2428| <<compare_refcounts>> ret = qcow2_get_refcount(bs, i, &refcount1);
+         *   - block/qcow2-refcount.c|3831| <<qcow2_get_last_cluster>> int ret = qcow2_get_refcount(bs, i, &refcount);
+         *   - block/qcow2-refcount.c|3871| <<qcow2_detect_metadata_preallocation>> int ret = qcow2_get_refcount(bs, i, &refcount);
+	 */
         ret = qcow2_get_refcount(bs, next_cluster_index, &refcount);
 
         if (ret < 0) {
             return ret;
         } else if (refcount != 0) {
+            /*
+	     * 似乎这里保证必须是连续的
+	     */
             goto retry;
         }
     }
@@ -1006,6 +1173,57 @@ retry:
     return (s->free_cluster_index - nb_clusters) << s->cluster_bits;
 }
 
+/*
+ * (gdb) bt
+ * #0  qcow2_alloc_clusters (bs=0x55555581b510, size=196608) at ../block/qcow2-refcount.c:1011
+ * #1  0x00005555555f1653 in qcow2_co_create (create_options=0x5555558194d0, errp=0x7fffffffd4e8) at ../block/qcow2.c:3799
+ * #2  0x00005555555f1ebc in qcow2_co_create_opts (drv=0x5555557d7100 <bdrv_qcow2>, filename=0x7fffffffda88 "test.qcow2", opts=0x555555810b10, 
+ *     errp=0x7fffffffd4e8) at ../block/qcow2.c:4014
+ * #3  0x0000555555585318 in bdrv_co_create (drv=0x5555557d7100 <bdrv_qcow2>, filename=0x7fffffffda88 "test.qcow2", opts=0x555555810b10, 
+ *     errp=0x7fffffffd4e8) at ../block.c:548
+ * #4  0x000055555566c02c in bdrv_co_create_entry (opaque=0x7fffffffd440) at block/block-gen.c:1179
+ * #5  0x000055555570b3fe in coroutine_trampoline (i0=1434520480, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #6  0x00007ffff5ee7120 in ?? () from /lib64/libc.so.6
+ * #7  0x00007fffffffcc40 in ?? ()
+ * #8  0x0000000000000000 in ?? ()
+ *
+ * (gdb) bt
+ * #0  qcow2_alloc_clusters (bs=0x55555581b510, size=8) at ../block/qcow2-refcount.c:1011
+ * #1  0x00005555555fe656 in qcow2_grow_l1_table (bs=0x55555581b510, min_size=1, exact_size=true) at ../block/qcow2-cluster.c:142
+ * #2  0x00005555555f3018 in qcow2_co_truncate (bs=0x55555581b510, offset=10485760, exact=false, prealloc=PREALLOC_MODE_OFF, flags=0,
+ *     errp=0x7fffffffd4e8) at ../block/qcow2.c:4409
+ * #3  0x00005555555d45a7 in bdrv_co_truncate (child=0x55555580ac00, offset=10485760, exact=false, prealloc=PREALLOC_MODE_OFF, flags=0,
+ *     errp=0x7fffffffd4e8) at ../block/io.c:3691
+ * #4  0x00005555555bc68c in blk_co_truncate (blk=0x555555820840, offset=10485760, exact=false, prealloc=PREALLOC_MODE_OFF, flags=0,
+ *     errp=0x7fffffffd4e8) at ../block/block-backend.c:2556
+ * #5  0x00005555555f17c0 in qcow2_co_create (create_options=0x5555558194d0, errp=0x7fffffffd4e8) at ../block/qcow2.c:3827
+ * #6  0x00005555555f1ebc in qcow2_co_create_opts (drv=0x5555557d7100 <bdrv_qcow2>, filename=0x7fffffffda88 "test.qcow2", opts=0x555555810b10,
+ *     errp=0x7fffffffd4e8) at ../block/qcow2.c:4014
+ * #7  0x0000555555585318 in bdrv_co_create (drv=0x5555557d7100 <bdrv_qcow2>, filename=0x7fffffffda88 "test.qcow2", opts=0x555555810b10,
+ *     errp=0x7fffffffd4e8) at ../block.c:548
+ * #8  0x000055555566c02c in bdrv_co_create_entry (opaque=0x7fffffffd440) at block/block-gen.c:1179
+ * #9  0x000055555570b3fe in coroutine_trampoline (i0=1434520480, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #10 0x00007ffff5ee7120 in ?? () from /lib64/libc.so.6
+ * #11 0x00007fffffffcc40 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用qcow2_alloc_clusters():
+ *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+ *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+ *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+ *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+ *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+ *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+ *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+ *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+ *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+ *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+ *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+ *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+ *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+ *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+ */
 int64_t qcow2_alloc_clusters(BlockDriverState *bs, uint64_t size)
 {
     int64_t offset;
@@ -1018,6 +1236,18 @@ int64_t qcow2_alloc_clusters(BlockDriverState *bs, uint64_t size)
             return offset;
         }
 
+        /*
+	 * 在以下使用update_refcount():
+         *   - block/qcow2-refcount.c|422| <<alloc_refcount_block>> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,
+         *   - block/qcow2-refcount.c|957| <<update_refcount>> dummy = update_refcount(bs, offset, cluster_offset - offset, addend,
+         *   - block/qcow2-refcount.c|981| <<qcow2_update_cluster_refcount>> ret = update_refcount(bs, cluster_index << s->cluster_bits, 1, addend,
+         *   - block/qcow2-refcount.c|1135| <<qcow2_alloc_clusters>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+         *   - block/qcow2-refcount.c|1185| <<qcow2_alloc_clusters_at>> ret = update_refcount(bs, offset, i << s->cluster_bits, 1, false,
+         *   - block/qcow2-refcount.c|1265| <<qcow2_alloc_bytes>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+         *   - block/qcow2-refcount.c|1323| <<qcow2_free_clusters>> ret = update_refcount(bs, offset, size, 1, true, type);
+         *   - block/qcow2-refcount.c|1501| <<qcow2_update_snapshot_refcount>> ret = update_refcount(
+         *   - block/qcow2-refcount.c|2562| <<compare_refcounts>> ret = update_refcount(bs, i << s->cluster_bits, 1,
+	 */
         ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
     } while (ret == -EAGAIN);
 
@@ -1045,6 +1275,20 @@ int64_t coroutine_fn qcow2_alloc_clusters_at(BlockDriverState *bs, uint64_t offs
         /* Check how many clusters there are free */
         cluster_index = offset >> s->cluster_bits;
         for(i = 0; i < nb_clusters; i++) {
+            /*
+	     * 在以下使用qcow2_get_refcount():
+             *   - block/qcow2-cluster.c|2339| <<expand_zero_clusters_in_l1>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+             *   - block/qcow2-refcount.c|1016| <<alloc_clusters_noref>> ret = qcow2_get_refcount(bs, next_cluster_index, &refcount);
+             *   - block/qcow2-refcount.c|1131| <<qcow2_alloc_clusters_at>> ret = qcow2_get_refcount(bs, cluster_index++, &refcount);
+             *   - block/qcow2-refcount.c|1168| <<qcow2_alloc_bytes>> ret = qcow2_get_refcount(bs, offset >> s->cluster_bits, &refcount);
+             *   - block/qcow2-refcount.c|1480| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, cluster_index, &refcount);
+             *   - block/qcow2-refcount.c|1521| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+             *   - block/qcow2-refcount.c|2096| <<check_oflag_copied>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+             *   - block/qcow2-refcount.c|2140| <<check_oflag_copied>> ret = qcow2_get_refcount(bs,
+             *   - block/qcow2-refcount.c|2428| <<compare_refcounts>> ret = qcow2_get_refcount(bs, i, &refcount1);
+             *   - block/qcow2-refcount.c|3831| <<qcow2_get_last_cluster>> int ret = qcow2_get_refcount(bs, i, &refcount);
+             *   - block/qcow2-refcount.c|3871| <<qcow2_detect_metadata_preallocation>> int ret = qcow2_get_refcount(bs, i, &refcount);
+	     */
             ret = qcow2_get_refcount(bs, cluster_index++, &refcount);
             if (ret < 0) {
                 return ret;
@@ -1053,6 +1297,18 @@ int64_t coroutine_fn qcow2_alloc_clusters_at(BlockDriverState *bs, uint64_t offs
             }
         }
 
+        /*
+         * 在以下使用update_refcount():
+         *   - block/qcow2-refcount.c|422| <<alloc_refcount_block>> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,
+         *   - block/qcow2-refcount.c|957| <<update_refcount>> dummy = update_refcount(bs, offset, cluster_offset - offset, addend,
+         *   - block/qcow2-refcount.c|981| <<qcow2_update_cluster_refcount>> ret = update_refcount(bs, cluster_index << s->cluster_bits, 1, addend,
+         *   - block/qcow2-refcount.c|1135| <<qcow2_alloc_clusters>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+         *   - block/qcow2-refcount.c|1185| <<qcow2_alloc_clusters_at>> ret = update_refcount(bs, offset, i << s->cluster_bits, 1, false,
+         *   - block/qcow2-refcount.c|1265| <<qcow2_alloc_bytes>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+         *   - block/qcow2-refcount.c|1323| <<qcow2_free_clusters>> ret = update_refcount(bs, offset, size, 1, true, type);
+         *   - block/qcow2-refcount.c|1501| <<qcow2_update_snapshot_refcount>> ret = update_refcount(
+         *   - block/qcow2-refcount.c|2562| <<compare_refcounts>> ret = update_refcount(bs, i << s->cluster_bits, 1,
+	 */
         /* And then allocate them */
         ret = update_refcount(bs, offset, i << s->cluster_bits, 1, false,
                               QCOW2_DISCARD_NEVER);
@@ -1082,6 +1338,20 @@ int64_t coroutine_fn GRAPH_RDLOCK qcow2_alloc_bytes(BlockDriverState *bs, int si
 
     if (offset) {
         uint64_t refcount;
+        /*
+	 * 在以下使用qcow2_get_refcount():
+         *   - block/qcow2-cluster.c|2339| <<expand_zero_clusters_in_l1>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|1016| <<alloc_clusters_noref>> ret = qcow2_get_refcount(bs, next_cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1131| <<qcow2_alloc_clusters_at>> ret = qcow2_get_refcount(bs, cluster_index++, &refcount);
+         *   - block/qcow2-refcount.c|1168| <<qcow2_alloc_bytes>> ret = qcow2_get_refcount(bs, offset >> s->cluster_bits, &refcount);
+         *   - block/qcow2-refcount.c|1480| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1521| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2096| <<check_oflag_copied>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2140| <<check_oflag_copied>> ret = qcow2_get_refcount(bs,
+         *   - block/qcow2-refcount.c|2428| <<compare_refcounts>> ret = qcow2_get_refcount(bs, i, &refcount1);
+         *   - block/qcow2-refcount.c|3831| <<qcow2_get_last_cluster>> int ret = qcow2_get_refcount(bs, i, &refcount);
+         *   - block/qcow2-refcount.c|3871| <<qcow2_detect_metadata_preallocation>> int ret = qcow2_get_refcount(bs, i, &refcount);
+	 */
         ret = qcow2_get_refcount(bs, offset >> s->cluster_bits, &refcount);
         if (ret < 0) {
             return ret;
@@ -1120,6 +1390,18 @@ int64_t coroutine_fn GRAPH_RDLOCK qcow2_alloc_bytes(BlockDriverState *bs, int si
         }
 
         assert(offset);
+        /*
+	 * 在以下使用update_refcount():
+         *   - block/qcow2-refcount.c|422| <<alloc_refcount_block>> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,
+         *   - block/qcow2-refcount.c|957| <<update_refcount>> dummy = update_refcount(bs, offset, cluster_offset - offset, addend,
+         *   - block/qcow2-refcount.c|981| <<qcow2_update_cluster_refcount>> ret = update_refcount(bs, cluster_index << s->cluster_bits, 1, addend,
+         *   - block/qcow2-refcount.c|1135| <<qcow2_alloc_clusters>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+         *   - block/qcow2-refcount.c|1185| <<qcow2_alloc_clusters_at>> ret = update_refcount(bs, offset, i << s->cluster_bits, 1, false,
+         *   - block/qcow2-refcount.c|1265| <<qcow2_alloc_bytes>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+         *   - block/qcow2-refcount.c|1323| <<qcow2_free_clusters>> ret = update_refcount(bs, offset, size, 1, true, type);
+         *   - block/qcow2-refcount.c|1501| <<qcow2_update_snapshot_refcount>> ret = update_refcount(
+         *   - block/qcow2-refcount.c|2562| <<compare_refcounts>> ret = update_refcount(bs, i << s->cluster_bits, 1,
+	 */
         ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
         if (ret < 0) {
             offset = 0;
@@ -1141,6 +1423,36 @@ int64_t coroutine_fn GRAPH_RDLOCK qcow2_alloc_bytes(BlockDriverState *bs, int si
     return offset;
 }
 
+/*
+ * 在以下使用qcow2_free_clusters():
+ *   - block/qcow2-bitmap.c|219| <<clear_bitmap_table>> qcow2_free_clusters(bs, addr, s->cluster_size, QCOW2_DISCARD_ALWAYS);
+ *   - block/qcow2-bitmap.c|275| <<free_bitmap_clusters>> qcow2_free_clusters(bs, tb->offset, tb->size * BME_TABLE_ENTRY_SIZE,
+ *   - block/qcow2-bitmap.c|826| <<bitmap_list_store>> qcow2_free_clusters(bs, dir_offset, dir_size, QCOW2_DISCARD_OTHER);
+ *   - block/qcow2-bitmap.c|930| <<update_ext_header_and_dir>> qcow2_free_clusters(bs, old_offset, old_size, QCOW2_DISCARD_OTHER);
+ *   - block/qcow2-bitmap.c|937| <<update_ext_header_and_dir>> qcow2_free_clusters(bs, new_offset, new_size, QCOW2_DISCARD_OTHER);
+ *   - block/qcow2-bitmap.c|1434| <<store_bitmap>> qcow2_free_clusters(bs, tb_offset, tb_size * sizeof(tb[0]),
+ *   - block/qcow2-cluster.c|69| <<qcow2_shrink_l1_table>> qcow2_free_clusters(bs, s->l1_table[i] & L1E_OFFSET_MASK,
+ *   - block/qcow2-cluster.c|186| <<qcow2_grow_l1_table>> qcow2_free_clusters(bs, old_l1_table_offset, old_l1_size * L1E_SIZE,
+ *   - block/qcow2-cluster.c|191| <<qcow2_grow_l1_table>> qcow2_free_clusters(bs, new_l1_table_offset, new_l1_size2,
+ *   - block/qcow2-cluster.c|376| <<l2_allocate>> qcow2_free_clusters(bs, l2_offset, s->l2_size * l2_entry_size(s),
+ *   - block/qcow2-cluster.c|793| <<get_cluster_table>> qcow2_free_clusters(bs, l2_offset, s->l2_size * l2_entry_size(s),
+ *   - block/qcow2-cluster.c|1133| <<qcow2_alloc_cluster_abort>> qcow2_free_clusters(bs, m->alloc_offset,
+ *   - block/qcow2-cluster.c|2360| <<expand_zero_clusters_in_l1>> qcow2_free_clusters(bs, offset, s->cluster_size,
+ *   - block/qcow2-cluster.c|2376| <<expand_zero_clusters_in_l1>> qcow2_free_clusters(bs, offset, s->cluster_size,
+ *   - block/qcow2-cluster.c|2387| <<expand_zero_clusters_in_l1>> qcow2_free_clusters(bs, offset, s->cluster_size,
+ *   - block/qcow2-cluster.c|2397| <<expand_zero_clusters_in_l1>> qcow2_free_clusters(bs, offset, s->cluster_size,
+ *   - block/qcow2-refcount.c|725| <<qcow2_refcount_area>> qcow2_free_clusters(bs, old_table_offset,
+ *   - block/qcow2-refcount.c|1186| <<qcow2_free_any_cluster>> qcow2_free_clusters(bs, coffset, csize, type);
+ *   - block/qcow2-refcount.c|1196| <<qcow2_free_any_cluster>> qcow2_free_clusters(bs, l2_entry & L2E_OFFSET_MASK,
+ *   - block/qcow2-refcount.c|3418| <<qcow2_change_refcount_order>> qcow2_free_clusters(
+ *   - block/qcow2-refcount.c|3533| <<qcow2_change_refcount_order>> qcow2_free_clusters(bs, offset, s->cluster_size,
+ *   - block/qcow2-refcount.c|3540| <<qcow2_change_refcount_order>> qcow2_free_clusters(bs, new_reftable_offset,
+ *   - block/qcow2-snapshot.c|416| <<qcow2_write_snapshots>> qcow2_free_clusters(bs, s->snapshots_offset, s->snapshots_size,
+ *   - block/qcow2-snapshot.c|424| <<qcow2_write_snapshots>> qcow2_free_clusters(bs, snapshots_offset, snapshots_size,
+ *   - block/qcow2-snapshot.c|967| <<qcow2_snapshot_delete>> qcow2_free_clusters(bs, sn.l1_table_offset, sn.l1_size * L1E_SIZE,
+ *   - block/qcow2.c|4552| <<qcow2_co_truncate>> qcow2_free_clusters(bs, allocation_start,
+ *   - block/qcow2.c|4587| <<qcow2_co_truncate>> qcow2_free_clusters(bs, host_offset,
+ */
 void qcow2_free_clusters(BlockDriverState *bs,
                           int64_t offset, int64_t size,
                           enum qcow2_discard_type type)
@@ -1148,6 +1460,18 @@ void qcow2_free_clusters(BlockDriverState *bs,
     int ret;
 
     BLKDBG_EVENT(bs->file, BLKDBG_CLUSTER_FREE);
+    /*
+     * 在以下使用update_refcount():
+     *   - block/qcow2-refcount.c|422| <<alloc_refcount_block>> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,
+     *   - block/qcow2-refcount.c|957| <<update_refcount>> dummy = update_refcount(bs, offset, cluster_offset - offset, addend,
+     *   - block/qcow2-refcount.c|981| <<qcow2_update_cluster_refcount>> ret = update_refcount(bs, cluster_index << s->cluster_bits, 1, addend,
+     *   - block/qcow2-refcount.c|1135| <<qcow2_alloc_clusters>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+     *   - block/qcow2-refcount.c|1185| <<qcow2_alloc_clusters_at>> ret = update_refcount(bs, offset, i << s->cluster_bits, 1, false,
+     *   - block/qcow2-refcount.c|1265| <<qcow2_alloc_bytes>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+     *   - block/qcow2-refcount.c|1323| <<qcow2_free_clusters>> ret = update_refcount(bs, offset, size, 1, true, type);
+     *   - block/qcow2-refcount.c|1501| <<qcow2_update_snapshot_refcount>> ret = update_refcount(
+     *   - block/qcow2-refcount.c|2562| <<compare_refcounts>> ret = update_refcount(bs, i << s->cluster_bits, 1,
+     */
     ret = update_refcount(bs, offset, size, 1, true, type);
     if (ret < 0) {
         fprintf(stderr, "qcow2_free_clusters failed: %s\n", strerror(-ret));
@@ -1326,6 +1650,18 @@ int qcow2_update_snapshot_refcount(BlockDriverState *bs,
 
                             qcow2_parse_compressed_l2_entry(bs, entry,
                                                             &coffset, &csize);
+                            /*
+                             * 在以下使用update_refcount():
+                             *   - block/qcow2-refcount.c|422| <<alloc_refcount_block>> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,
+                             *   - block/qcow2-refcount.c|957| <<update_refcount>> dummy = update_refcount(bs, offset, cluster_offset - offset, addend,
+                             *   - block/qcow2-refcount.c|981| <<qcow2_update_cluster_refcount>> ret = update_refcount(bs, cluster_index << s->cluster_bits, 1, addend,
+                             *   - block/qcow2-refcount.c|1135| <<qcow2_alloc_clusters>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+                             *   - block/qcow2-refcount.c|1185| <<qcow2_alloc_clusters_at>> ret = update_refcount(bs, offset, i << s->cluster_bits, 1, false,
+                             *   - block/qcow2-refcount.c|1265| <<qcow2_alloc_bytes>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+                             *   - block/qcow2-refcount.c|1323| <<qcow2_free_clusters>> ret = update_refcount(bs, offset, size, 1, true, type);
+                             *   - block/qcow2-refcount.c|1501| <<qcow2_update_snapshot_refcount>> ret = update_refcount(
+                             *   - block/qcow2-refcount.c|2562| <<compare_refcounts>> ret = update_refcount(bs, i << s->cluster_bits, 1,
+			     */
                             ret = update_refcount(
                                 bs, coffset, csize,
                                 abs(addend), addend < 0,
@@ -1364,6 +1700,20 @@ int qcow2_update_snapshot_refcount(BlockDriverState *bs,
                             }
                         }
 
+                        /*
+			 * 在以下使用qcow2_get_refcount():
+                         *   - block/qcow2-cluster.c|2339| <<expand_zero_clusters_in_l1>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+                         *   - block/qcow2-refcount.c|1016| <<alloc_clusters_noref>> ret = qcow2_get_refcount(bs, next_cluster_index, &refcount);
+                         *   - block/qcow2-refcount.c|1131| <<qcow2_alloc_clusters_at>> ret = qcow2_get_refcount(bs, cluster_index++, &refcount);
+                         *   - block/qcow2-refcount.c|1168| <<qcow2_alloc_bytes>> ret = qcow2_get_refcount(bs, offset >> s->cluster_bits, &refcount);
+                         *   - block/qcow2-refcount.c|1480| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, cluster_index, &refcount);
+                         *   - block/qcow2-refcount.c|1521| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+                         *   - block/qcow2-refcount.c|2096| <<check_oflag_copied>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+                         *   - block/qcow2-refcount.c|2140| <<check_oflag_copied>> ret = qcow2_get_refcount(bs,
+                         *   - block/qcow2-refcount.c|2428| <<compare_refcounts>> ret = qcow2_get_refcount(bs, i, &refcount1);
+                         *   - block/qcow2-refcount.c|3831| <<qcow2_get_last_cluster>> int ret = qcow2_get_refcount(bs, i, &refcount);
+                         *   - block/qcow2-refcount.c|3871| <<qcow2_detect_metadata_preallocation>> int ret = qcow2_get_refcount(bs, i, &refcount);
+			 */
                         ret = qcow2_get_refcount(bs, cluster_index, &refcount);
                         if (ret < 0) {
                             goto fail;
@@ -1980,6 +2330,20 @@ check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix
             continue;
         }
 
+        /*
+	 * 在以下使用qcow2_get_refcount():
+         *   - block/qcow2-cluster.c|2339| <<expand_zero_clusters_in_l1>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|1016| <<alloc_clusters_noref>> ret = qcow2_get_refcount(bs, next_cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1131| <<qcow2_alloc_clusters_at>> ret = qcow2_get_refcount(bs, cluster_index++, &refcount);
+         *   - block/qcow2-refcount.c|1168| <<qcow2_alloc_bytes>> ret = qcow2_get_refcount(bs, offset >> s->cluster_bits, &refcount);
+         *   - block/qcow2-refcount.c|1480| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1521| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2096| <<check_oflag_copied>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2140| <<check_oflag_copied>> ret = qcow2_get_refcount(bs,
+         *   - block/qcow2-refcount.c|2428| <<compare_refcounts>> ret = qcow2_get_refcount(bs, i, &refcount1);
+         *   - block/qcow2-refcount.c|3831| <<qcow2_get_last_cluster>> int ret = qcow2_get_refcount(bs, i, &refcount);
+         *   - block/qcow2-refcount.c|3871| <<qcow2_detect_metadata_preallocation>> int ret = qcow2_get_refcount(bs, i, &refcount);
+	 */
         ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
                                  &refcount);
         if (ret < 0) {
@@ -2312,6 +2676,20 @@ compare_refcounts(BlockDriverState *bs, BdrvCheckResult *res,
     int ret;
 
     for (i = 0, *highest_cluster = 0; i < nb_clusters; i++) {
+        /*
+	 * 在以下使用qcow2_get_refcount():
+         *   - block/qcow2-cluster.c|2339| <<expand_zero_clusters_in_l1>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|1016| <<alloc_clusters_noref>> ret = qcow2_get_refcount(bs, next_cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1131| <<qcow2_alloc_clusters_at>> ret = qcow2_get_refcount(bs, cluster_index++, &refcount);
+         *   - block/qcow2-refcount.c|1168| <<qcow2_alloc_bytes>> ret = qcow2_get_refcount(bs, offset >> s->cluster_bits, &refcount);
+         *   - block/qcow2-refcount.c|1480| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1521| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2096| <<check_oflag_copied>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2140| <<check_oflag_copied>> ret = qcow2_get_refcount(bs,
+         *   - block/qcow2-refcount.c|2428| <<compare_refcounts>> ret = qcow2_get_refcount(bs, i, &refcount1);
+         *   - block/qcow2-refcount.c|3831| <<qcow2_get_last_cluster>> int ret = qcow2_get_refcount(bs, i, &refcount);
+         *   - block/qcow2-refcount.c|3871| <<qcow2_detect_metadata_preallocation>> int ret = qcow2_get_refcount(bs, i, &refcount);
+	 */
         ret = qcow2_get_refcount(bs, i, &refcount1);
         if (ret < 0) {
             fprintf(stderr, "Can't get refcount for cluster %" PRId64 ": %s\n",
@@ -2345,6 +2723,18 @@ compare_refcounts(BlockDriverState *bs, BdrvCheckResult *res,
                    i, refcount1, refcount2);
 
             if (num_fixed) {
+                /*
+		 * 在以下使用update_refcount():
+                 *   - block/qcow2-refcount.c|422| <<alloc_refcount_block>> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,
+                 *   - block/qcow2-refcount.c|957| <<update_refcount>> dummy = update_refcount(bs, offset, cluster_offset - offset, addend,
+                 *   - block/qcow2-refcount.c|981| <<qcow2_update_cluster_refcount>> ret = update_refcount(bs, cluster_index << s->cluster_bits, 1, addend,
+                 *   - block/qcow2-refcount.c|1135| <<qcow2_alloc_clusters>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+                 *   - block/qcow2-refcount.c|1185| <<qcow2_alloc_clusters_at>> ret = update_refcount(bs, offset, i << s->cluster_bits, 1, false,
+                 *   - block/qcow2-refcount.c|1265| <<qcow2_alloc_bytes>> ret = update_refcount(bs, offset, size, 1, false, QCOW2_DISCARD_NEVER);
+                 *   - block/qcow2-refcount.c|1323| <<qcow2_free_clusters>> ret = update_refcount(bs, offset, size, 1, true, type);
+                 *   - block/qcow2-refcount.c|1501| <<qcow2_update_snapshot_refcount>> ret = update_refcount(
+                 *   - block/qcow2-refcount.c|2562| <<compare_refcounts>> ret = update_refcount(bs, i << s->cluster_bits, 1,
+		 */
                 ret = update_refcount(bs, i << s->cluster_bits, 1,
                                       refcount_diff(refcount1, refcount2),
                                       refcount1 > refcount2,
@@ -3149,6 +3539,23 @@ alloc_refblock(BlockDriverState *bs, uint64_t **reftable,
     }
 
     if (!refblock_empty && !(*reftable)[reftable_index]) {
+        /*
+	 * 在以下使用qcow2_alloc_clusters():
+         *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+         *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+         *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+         *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+         *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+         *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+         *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+         *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+         *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+         *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+         *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+         *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+	 */
         offset = qcow2_alloc_clusters(bs, s->cluster_size);
         if (offset < 0) {
             error_setg_errno(errp, -offset, "Failed to allocate refblock");
@@ -3421,6 +3828,23 @@ int qcow2_change_refcount_order(BlockDriverState *bs, int refcount_order,
                     QCOW2_DISCARD_NEVER);
             }
 
+            /*
+	     * 在以下使用qcow2_alloc_clusters():
+             *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+             *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+             *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+             *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+             *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+             *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+             *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+             *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+             *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+             *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+             *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+             *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+             *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+             *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+	     */
             new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
                                                            REFTABLE_ENTRY_SIZE);
             if (new_reftable_offset < 0) {
@@ -3567,6 +3991,10 @@ get_refblock_offset(BlockDriverState *bs, uint64_t offset)
     return covering_refblock_offset;
 }
 
+/*
+ * 在以下使用qcow2_discard_refcount_block():
+ *   - block/qcow2-refcount.c|4029| <<qcow2_shrink_reftable>> ret = qcow2_discard_refcount_block(bs, s->refcount_table[i] &
+ */
 static int coroutine_fn GRAPH_RDLOCK
 qcow2_discard_refcount_block(BlockDriverState *bs, uint64_t discard_block_offs)
 {
@@ -3609,6 +4037,22 @@ qcow2_discard_refcount_block(BlockDriverState *bs, uint64_t discard_block_offs)
 
     qcow2_cache_put(s->refcount_block_cache, &refblock);
 
+    /*
+     * 在以下设置free_cluster_index:
+     *   - block/qcow2-refcount.c|856| <<update_refcount>> s->free_cluster_index = (start >> s->cluster_bits);
+     *   - block/qcow2-refcount.c|884| <<update_refcount>> s->free_cluster_index = cluster_index;
+     *   - block/qcow2-refcount.c|983| <<alloc_clusters_noref>> uint64_t next_cluster_index = s->free_cluster_index++;
+     *   - block/qcow2-refcount.c|3694| <<qcow2_discard_refcount_block>> s->free_cluster_index = cluster_index;
+     *   - block/qcow2.c|5060| <<make_completely_empty>> s->free_cluster_index = 0;
+     * 在以下使用free_cluster_index:
+     *   - block/qcow2-refcount.c|855| <<update_refcount>> if (s->free_cluster_index > (start >> s->cluster_bits)) {
+     *   - block/qcow2-refcount.c|883| <<update_refcount>> if (refcount == 0 && cluster_index < s->free_cluster_index) {
+     *   - block/qcow2-refcount.c|995| <<alloc_clusters_noref>> if (s->free_cluster_index > 0 &&
+     *   - block/qcow2-refcount.c|996| <<alloc_clusters_noref>> s->free_cluster_index - 1 > (max >> s->cluster_bits))
+     *   - block/qcow2-refcount.c|1004| <<alloc_clusters_noref>> (s->free_cluster_index - nb_clusters) << s->cluster_bits);
+     *   - block/qcow2-refcount.c|1006| <<alloc_clusters_noref>> return (s->free_cluster_index - nb_clusters) << s->cluster_bits;
+     *   - block/qcow2-refcount.c|3693| <<qcow2_discard_refcount_block>> if (cluster_index < s->free_cluster_index) {
+     */
     if (cluster_index < s->free_cluster_index) {
         s->free_cluster_index = cluster_index;
     }
@@ -3699,6 +4143,20 @@ int64_t coroutine_fn qcow2_get_last_cluster(BlockDriverState *bs, int64_t size)
 
     for (i = size_to_clusters(s, size) - 1; i >= 0; i--) {
         uint64_t refcount;
+        /*
+	 * 在以下使用qcow2_get_refcount():
+         *   - block/qcow2-cluster.c|2339| <<expand_zero_clusters_in_l1>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|1016| <<alloc_clusters_noref>> ret = qcow2_get_refcount(bs, next_cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1131| <<qcow2_alloc_clusters_at>> ret = qcow2_get_refcount(bs, cluster_index++, &refcount);
+         *   - block/qcow2-refcount.c|1168| <<qcow2_alloc_bytes>> ret = qcow2_get_refcount(bs, offset >> s->cluster_bits, &refcount);
+         *   - block/qcow2-refcount.c|1480| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, cluster_index, &refcount);
+         *   - block/qcow2-refcount.c|1521| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2096| <<check_oflag_copied>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+         *   - block/qcow2-refcount.c|2140| <<check_oflag_copied>> ret = qcow2_get_refcount(bs,
+         *   - block/qcow2-refcount.c|2428| <<compare_refcounts>> ret = qcow2_get_refcount(bs, i, &refcount1);
+         *   - block/qcow2-refcount.c|3831| <<qcow2_get_last_cluster>> int ret = qcow2_get_refcount(bs, i, &refcount);
+         *   - block/qcow2-refcount.c|3871| <<qcow2_detect_metadata_preallocation>> int ret = qcow2_get_refcount(bs, i, &refcount);
+	 */
         int ret = qcow2_get_refcount(bs, i, &refcount);
         if (ret < 0) {
             fprintf(stderr, "Can't get refcount for cluster %" PRId64 ": %s\n",
@@ -3739,6 +4197,20 @@ qcow2_detect_metadata_preallocation(BlockDriverState *bs)
     end_cluster = size_to_clusters(s, file_length);
     for (i = 0; i < end_cluster && cluster_count < threshold; i++) {
         uint64_t refcount;
+        /*
+	 * 在以下使用qcow2_get_refcount():
+         *   - block/qcow2-cluster.c|2339| <<expand_zero_clusters_in_l1>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+	 *   - block/qcow2-refcount.c|1016| <<alloc_clusters_noref>> ret = qcow2_get_refcount(bs, next_cluster_index, &refcount);
+	 *   - block/qcow2-refcount.c|1131| <<qcow2_alloc_clusters_at>> ret = qcow2_get_refcount(bs, cluster_index++, &refcount);
+	 *   - block/qcow2-refcount.c|1168| <<qcow2_alloc_bytes>> ret = qcow2_get_refcount(bs, offset >> s->cluster_bits, &refcount);
+	 *   - block/qcow2-refcount.c|1480| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, cluster_index, &refcount);
+	 *   - block/qcow2-refcount.c|1521| <<qcow2_update_snapshot_refcount>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+	 *   - block/qcow2-refcount.c|2096| <<check_oflag_copied>> ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,
+	 *   - block/qcow2-refcount.c|2140| <<check_oflag_copied>> ret = qcow2_get_refcount(bs,
+	 *   - block/qcow2-refcount.c|2428| <<compare_refcounts>> ret = qcow2_get_refcount(bs, i, &refcount1);
+	 *   - block/qcow2-refcount.c|3831| <<qcow2_get_last_cluster>> int ret = qcow2_get_refcount(bs, i, &refcount);
+	 *   - block/qcow2-refcount.c|3871| <<qcow2_detect_metadata_preallocation>> int ret = qcow2_get_refcount(bs, i, &refcount);
+	 */
         int ret = qcow2_get_refcount(bs, i, &refcount);
         if (ret < 0) {
             return ret;
diff --git a/block/qcow2-snapshot.c b/block/qcow2-snapshot.c
index 1e8dc48be..2e2d18bc3 100644
--- a/block/qcow2-snapshot.c
+++ b/block/qcow2-snapshot.c
@@ -301,6 +301,23 @@ int qcow2_write_snapshots(BlockDriverState *bs)
     assert(offset <= INT_MAX);
     snapshots_size = offset;
 
+    /*
+     * 在以下使用qcow2_alloc_clusters():
+     *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+     *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+     *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+     *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+     *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+     *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+     *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+     *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+     *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+     *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+     *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+     */
     /* Allocate space for the new snapshot list */
     snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
     offset = snapshots_offset;
@@ -669,6 +686,23 @@ int qcow2_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)
     sn->icount = sn_info->icount;
     sn->extra_data_size = sizeof(QCowSnapshotExtraData);
 
+    /*
+     * 在以下使用qcow2_alloc_clusters():
+     *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+     *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+     *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+     *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+     *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+     *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+     *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+     *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+     *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+     *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+     *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+     */
     /* Allocate the L1 table of the snapshot and copy the current one there. */
     l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
     if (l1_table_offset < 0) {
@@ -809,6 +843,12 @@ int qcow2_snapshot_goto(BlockDriverState *bs, const char *snapshot_id)
      * L1 table of the snapshot. If the snapshot L1 table is smaller, the
      * current one must be padded with zeros.
      */
+    /*
+     * 在以下使用qcow2_grow_l1_table():
+     *   - block/qcow2-cluster.c|777| <<get_cluster_table>> ret = qcow2_grow_l1_table(bs, l1_index + 1, false);
+     *   - block/qcow2-snapshot.c|812| <<qcow2_snapshot_goto>> ret = qcow2_grow_l1_table(bs, sn->l1_size, true);
+     *   - block/qcow2.c|4482| <<qcow2_co_truncate>> ret = qcow2_grow_l1_table(bs, new_l1_size, true);
+     */
     ret = qcow2_grow_l1_table(bs, sn->l1_size, true);
     if (ret < 0) {
         goto fail;
diff --git a/block/qcow2-threads.c b/block/qcow2-threads.c
index d6071a1ea..d9cf0513b 100644
--- a/block/qcow2-threads.c
+++ b/block/qcow2-threads.c
@@ -38,6 +38,11 @@
 #include "block/thread-pool.h"
 #include "crypto.h"
 
+/*
+ * 在以下使用qcow2_co_process():
+ *   - block/qcow2-threads.c|350| <<qcow2_co_do_compress>> qcow2_co_process(bs, qcow2_compress_pool_func, &arg);
+ *   - block/qcow2-threads.c|478| <<qcow2_co_encdec>> return len == 0 ? 0 : qcow2_co_process(bs, qcow2_encdec_pool_func, &arg);
+ */
 static int coroutine_fn
 qcow2_co_process(BlockDriverState *bs, ThreadPoolFunc *func, void *arg)
 {
@@ -51,6 +56,14 @@ qcow2_co_process(BlockDriverState *bs, ThreadPoolFunc *func, void *arg)
     s->nb_threads++;
     qemu_co_mutex_unlock(&s->lock);
 
+    /*
+     * 在以下使用thread_pool_submit_co():
+     *   - block/file-posix.c|2515| <<raw_thread_pool_submit>> return thread_pool_submit_co(func, arg);
+     *   - block/qcow2-threads.c|54| <<qcow2_co_process>> ret = thread_pool_submit_co(func, arg);
+     *   - scsi/pr-manager.c|64| <<pr_manager_execute>> return thread_pool_submit_co(pr_manager_worker, &data);
+     *   - scsi/qemu-pr-helper.c|194| <<do_sgio>> r = thread_pool_submit_co(do_sgio_worker, &data);
+     *   - tests/unit/test-thread-pool.c|80| <<co_test_cb>> thread_pool_submit_co(worker_cb, data);
+     */
     ret = thread_pool_submit_co(func, arg);
 
     qemu_co_mutex_lock(&s->lock);
@@ -137,6 +150,10 @@ static ssize_t qcow2_zlib_compress(void *dest, size_t dest_size,
  * Returns: 0 on success
  *          -EIO on fail
  */
+/*
+ * 只在这里调用qcow2_zlib_decompress():
+ *   - block/qcow2-threads.c|413| <<qcow2_co_decompress>> fn = qcow2_zlib_decompress;
+ */
 static ssize_t qcow2_zlib_decompress(void *dest, size_t dest_size,
                                      const void *src, size_t src_size)
 {
@@ -325,6 +342,10 @@ static ssize_t qcow2_zstd_decompress(void *dest, size_t dest_size,
 }
 #endif
 
+/*
+ * 在以下使用qcow2_compress_pool_func():
+ *   - block/qcow2-threads.c|350| <<qcow2_co_do_compress>> qcow2_co_process(bs, qcow2_compress_pool_func, &arg);
+ */
 static int qcow2_compress_pool_func(void *opaque)
 {
     Qcow2CompressData *data = opaque;
@@ -335,6 +356,11 @@ static int qcow2_compress_pool_func(void *opaque)
     return 0;
 }
 
+/*
+ * 在以下使用qcow2_co_do_compress():
+ *   - block/qcow2-threads.c|388| <<qcow2_co_compress>> return qcow2_co_do_compress(bs, dest, dest_size, src, src_size, fn);
+ *   - block/qcow2-threads.c|425| <<qcow2_co_decompress>> return qcow2_co_do_compress(bs, dest, dest_size, src, src_size, fn);
+ */
 static ssize_t coroutine_fn
 qcow2_co_do_compress(BlockDriverState *bs, void *dest, size_t dest_size,
                      const void *src, size_t src_size, Qcow2CompressFunc func)
@@ -347,6 +373,11 @@ qcow2_co_do_compress(BlockDriverState *bs, void *dest, size_t dest_size,
         .func = func,
     };
 
+    /*
+     * 在以下使用qcow2_co_process():
+     *   - block/qcow2-threads.c|350| <<qcow2_co_do_compress>> qcow2_co_process(bs, qcow2_compress_pool_func, &arg);
+     *   - block/qcow2-threads.c|478| <<qcow2_co_encdec>> return len == 0 ? 0 : qcow2_co_process(bs, qcow2_encdec_pool_func, &arg);
+     */
     qcow2_co_process(bs, qcow2_compress_pool_func, &arg);
 
     return arg.ret;
@@ -385,6 +416,11 @@ qcow2_co_compress(BlockDriverState *bs, void *dest, size_t dest_size,
         abort();
     }
 
+    /*
+     * 在以下使用qcow2_co_do_compress():
+     *   - block/qcow2-threads.c|388| <<qcow2_co_compress>> return qcow2_co_do_compress(bs, dest, dest_size, src, src_size, fn);
+     *   - block/qcow2-threads.c|425| <<qcow2_co_decompress>> return qcow2_co_do_compress(bs, dest, dest_size, src, src_size, fn);
+     */
     return qcow2_co_do_compress(bs, dest, dest_size, src, src_size, fn);
 }
 
@@ -401,6 +437,10 @@ qcow2_co_compress(BlockDriverState *bs, void *dest, size_t dest_size,
  * Returns: 0 on success
  *          a negative error code on failure
  */
+/*
+ * 在以下使用qcow2_co_decompress():
+ *   - block/qcow2.c|5029| <<qcow2_co_preadv_compressed>> if (qcow2_co_decompress(bs, out_buf, s->cluster_size, buf, csize) < 0) {
+ */
 ssize_t coroutine_fn
 qcow2_co_decompress(BlockDriverState *bs, void *dest, size_t dest_size,
                     const void *src, size_t src_size)
@@ -422,6 +462,11 @@ qcow2_co_decompress(BlockDriverState *bs, void *dest, size_t dest_size,
         abort();
     }
 
+    /*
+     * 在以下使用qcow2_co_do_compress():
+     *   - block/qcow2-threads.c|388| <<qcow2_co_compress>> return qcow2_co_do_compress(bs, dest, dest_size, src, src_size, fn);
+     *   - block/qcow2-threads.c|425| <<qcow2_co_decompress>> return qcow2_co_do_compress(bs, dest, dest_size, src, src_size, fn);
+     */
     return qcow2_co_do_compress(bs, dest, dest_size, src, src_size, fn);
 }
 
@@ -475,6 +520,11 @@ qcow2_co_encdec(BlockDriverState *bs, uint64_t host_offset,
     assert(QEMU_IS_ALIGNED(host_offset, sector_size));
     assert(QEMU_IS_ALIGNED(len, sector_size));
 
+    /*
+     * 在以下使用qcow2_co_process():
+     *   - block/qcow2-threads.c|350| <<qcow2_co_do_compress>> qcow2_co_process(bs, qcow2_compress_pool_func, &arg);
+     *   - block/qcow2-threads.c|478| <<qcow2_co_encdec>> return len == 0 ? 0 : qcow2_co_process(bs, qcow2_encdec_pool_func, &arg);
+     */
     return len == 0 ? 0 : qcow2_co_process(bs, qcow2_encdec_pool_func, &arg);
 }
 
diff --git a/block/qcow2.c b/block/qcow2.c
index 4aa9f9e06..adea0d587 100644
--- a/block/qcow2.c
+++ b/block/qcow2.c
@@ -45,6 +45,65 @@
 #include "block/aio_task.h"
 #include "block/dirty-bitmap.h"
 
+/*
+ * QCOW2的cluster可以分为:
+ *
+ * - Data cluster (数据 cluster)
+ * 存储实际虚拟磁盘数据(文件内容)
+ * 通过L1->L2->cluster offset映射访问
+ *
+ * - Refcount block cluster
+ * 存储refcount block(每个cluster的引用计数)
+ * 通过refcount table指向
+ *
+ * - L1 table cluster
+ * 存储L1表(指向L2 tables)
+ * 通常一个cluster存1个L1 table(如果L1 table太大,会有多个cluster)
+ *
+ * - L2 table cluster
+ * 存储L2 table(指向 data clusters)
+ * L1 entry指向它
+ *
+ * - 其他metadata(header extension, snapshot metadata, bitmap)
+ * 由QCOW2的header extension指向
+ *
+ * -----------------
+ *
+ * 给一个cluster index, 怎样确认这个cluster是什么?
+ *
+ * 1. 计算 cluster offset
+ *
+ * cluster_offset = cluster_index * cluster_size
+ *
+ * 2. 检查cluster是否属于L1/L2/refcount table.
+ *
+ * 2.1 Refcount block
+ *
+ * 遍历refcount table: 每个entry指向一个refcount block cluster
+ *
+ * 每个block占cluster_size(或多cluster）
+ *
+ * 如果cluster_offset在refcount block所占区间内-->metadata(refcount)
+ *
+ * 2.2 L1 table
+ *
+ * header中有L1 table offset和L1 table size(单位 cluster)
+ *
+ * 如果cluster_offset在[L1_table_offset, L1_table_offset + L1_table_clusters*cluster_size)-->metadata(L1 table)
+ *
+ * 2.3 L2 table
+ *
+ * 遍历L1 table entries, 取每个L2 offset --> cluster_offset
+ *
+ * 如果cluster_offset在某个L2 table cluster内 --> metadata(L2 table)
+ *
+ * 3. 如果不属于任何metadata --> 数据cluster
+ *
+ * 遍历L1-->L2 table映射
+ *
+ * 如果cluster_index被某个L2 entry指向-->data cluster
+ */
+
 /*
   Differences with QCOW:
 
@@ -128,6 +187,23 @@ qcow2_crypto_hdr_init_func(QCryptoBlock *block, size_t headerlen, void *opaque,
     int64_t ret;
     int64_t clusterlen;
 
+    /*
+     * 在以下使用qcow2_alloc_clusters():
+     *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+     *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+     *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+     *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+     *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+     *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+     *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+     *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+     *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+     *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+     *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+     */
     ret = qcow2_alloc_clusters(bs, headerlen);
     if (ret < 0) {
         error_setg_errno(errp, -ret,
@@ -571,6 +647,10 @@ int qcow2_mark_corrupt(BlockDriverState *bs)
  * Marks the image as consistent, i.e., unsets the corrupt bit, and flushes
  * before if necessary.
  */
+/*
+ * 在以下使用qcow2_mark_consistent():
+ *   - block/qcow2.c|641| <<qcow2_co_check_locked>> return qcow2_mark_consistent(bs);
+ */
 static int coroutine_fn GRAPH_RDLOCK
 qcow2_mark_consistent(BlockDriverState *bs)
 {
@@ -588,6 +668,13 @@ qcow2_mark_consistent(BlockDriverState *bs)
     return 0;
 }
 
+/*
+ * 在以下使用qcow2_add_check_result():
+ *   - block/qcow2.c|619| <<qcow2_co_check_locked>> qcow2_add_check_result(result, &snapshot_res, false);
+ *   - block/qcow2.c|624| <<qcow2_co_check_locked>> qcow2_add_check_result(result, &refcount_res, true);
+ *   - block/qcow2.c|626| <<qcow2_co_check_locked>> qcow2_add_check_result(result, &snapshot_res, false);
+ *   - block/qcow2.c|631| <<qcow2_co_check_locked>> qcow2_add_check_result(result, &snapshot_res, false);
+ */
 static void qcow2_add_check_result(BdrvCheckResult *out,
                                    const BdrvCheckResult *src,
                                    bool set_allocation_info)
@@ -643,6 +730,16 @@ qcow2_co_check_locked(BlockDriverState *bs, BdrvCheckResult *result,
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  qcow2_co_check (bs=0x5555558117c0, result=0x7fffffffdb90, fix=0) at ../block/qcow2.c:650
+ * #1  0x0000555555591c58 in bdrv_co_check (bs=0x5555558117c0, res=0x7fffffffdb90, fix=0) at ../block.c:5673
+ * #2  0x000055555566b62b in bdrv_co_check_entry (opaque=0x7fffffffdb00) at block/block-gen.c:811
+ * #3  0x000055555570b3fe in coroutine_trampoline (i0=1434582832, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #4  0x00007ffff5ee7120 in ?? () from /lib64/libc.so.6
+ * #5  0x00007fffffffcd80 in ?? ()
+ * #6  0x0000000000000000 in ?? ()
+ */
 static int coroutine_fn GRAPH_RDLOCK
 qcow2_co_check(BlockDriverState *bs, BdrvCheckResult *result,
                BdrvCheckMode fix)
@@ -2142,6 +2239,9 @@ static void qcow2_join_options(QDict *options, QDict *old_options)
     }
 }
 
+/*
+ * BlockDriver bdrv_qcow2.bdrv_co_block_status = qcow2_co_block_status()
+ */
 static int coroutine_fn GRAPH_RDLOCK
 qcow2_co_block_status(BlockDriverState *bs, unsigned int mode,
                       int64_t offset, int64_t count, int64_t *pnum,
@@ -2162,6 +2262,14 @@ qcow2_co_block_status(BlockDriverState *bs, unsigned int mode,
     }
 
     bytes = MIN(INT_MAX, count);
+    /*
+     * 在以下使用qcow2_get_host_offset():
+     *   - block/qcow2.c|2186| <<qcow2_co_block_status>> ret = qcow2_get_host_offset(bs, offset, &bytes, &host_offset, &type);
+     *   - block/qcow2.c|2430| <<qcow2_co_preadv_part>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+     *   - block/qcow2.c|4135| <<qcow2_co_pwrite_zeroes>> ret = qcow2_get_host_offset(bs, offset, &nr, &off, &type);
+     *   - block/qcow2.c|4209| <<qcow2_co_copy_range_from>> ret = qcow2_get_host_offset(bs, src_offset, &cur_bytes, &copy_offset, &type);
+     *   - block/qcow2.c|5464| <<qcow2_has_compressed_clusters>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+     */
     ret = qcow2_get_host_offset(bs, offset, &bytes, &host_offset, &type);
     qemu_co_mutex_unlock(&s->lock);
     if (ret < 0) {
@@ -2328,6 +2436,10 @@ static coroutine_fn int qcow2_add_task(BlockDriverState *bs,
     return 0;
 }
 
+/*
+ * 在以下使用qcow2_co_preadv_task():
+ *   - block/qcow2.c|2491| <<qcow2_co_preadv_task_entry>> return qcow2_co_preadv_task(t->bs, t->subcluster_type,
+ */
 static int coroutine_fn GRAPH_RDLOCK
 qcow2_co_preadv_task(BlockDriverState *bs, QCow2SubclusterType subc_type,
                      uint64_t host_offset, uint64_t offset, uint64_t bytes,
@@ -2406,6 +2518,14 @@ qcow2_co_preadv_part(BlockDriverState *bs, int64_t offset, int64_t bytes,
         }
 
         qemu_co_mutex_lock(&s->lock);
+        /*
+	 * 在以下使用qcow2_get_host_offset():
+         *   - block/qcow2.c|2186| <<qcow2_co_block_status>> ret = qcow2_get_host_offset(bs, offset, &bytes, &host_offset, &type);
+         *   - block/qcow2.c|2430| <<qcow2_co_preadv_part>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+         *   - block/qcow2.c|4135| <<qcow2_co_pwrite_zeroes>> ret = qcow2_get_host_offset(bs, offset, &nr, &off, &type);
+         *   - block/qcow2.c|4209| <<qcow2_co_copy_range_from>> ret = qcow2_get_host_offset(bs, src_offset, &cur_bytes, &copy_offset, &type);
+         *   - block/qcow2.c|5464| <<qcow2_has_compressed_clusters>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+	 */
         ret = qcow2_get_host_offset(bs, offset, &cur_bytes,
                                     &host_offset, &type);
         qemu_co_mutex_unlock(&s->lock);
@@ -2920,6 +3040,23 @@ static size_t header_ext_add(char *buf, uint32_t magic, const void *s,
  *
  * Returns 0 on success, -errno in error cases.
  */
+/*
+ * 在以下使用qcow2_update_header():
+ *   - block/qcow2-bitmap.c|112| <<update_header_sync>> ret = qcow2_update_header(bs);
+ *   - block/qcow2-refcount.c|3525| <<qcow2_change_refcount_order>> ret = qcow2_update_header(bs);
+ *   - block/qcow2.c|554| <<qcow2_mark_clean>> return qcow2_update_header(bs);
+ *   - block/qcow2.c|567| <<qcow2_mark_corrupt>> return qcow2_update_header(bs);
+ *   - block/qcow2.c|586| <<qcow2_mark_consistent>> return qcow2_update_header(bs);
+ *   - block/qcow2.c|1856| <<qcow2_do_open>> ret = qcow2_update_header(bs);
+ *   - block/qcow2.c|3206| <<qcow2_co_change_backing_file>> return qcow2_update_header(bs);
+ *   - block/qcow2.c|3240| <<qcow2_set_up_encryption>> ret = qcow2_update_header(bs);
+ *   - block/qcow2.c|3818| <<qcow2_co_create>> ret = qcow2_update_header(blk_bs(blk));
+ *   - block/qcow2.c|5544| <<qcow2_downgrade>> ret = qcow2_update_header(bs);
+ *   - block/qcow2.c|5604| <<qcow2_upgrade>> ret = qcow2_update_header(bs);
+ *   - block/qcow2.c|5856| <<qcow2_amend_options>> ret = qcow2_update_header(bs);
+ *   - block/qcow2.c|5881| <<qcow2_amend_options>> ret = qcow2_update_header(bs);
+ *   - block/qcow2.c|5897| <<qcow2_amend_options>> ret = qcow2_update_header(bs);
+ */
 int qcow2_update_header(BlockDriverState *bs)
 {
     BDRVQcow2State *s = bs->opaque;
@@ -3496,6 +3633,11 @@ static uint64_t qcow2_opt_get_refcount_bits_del(QemuOpts *opts, int version,
     return refcount_bits;
 }
 
+/*
+ * 在以下使用qcow2_co_create():
+ *   - block/qcow2.c|6272| <<global>> .bdrv_co_create = qcow2_co_create,
+ *   - block/qcow2.c|4071| <<qcow2_co_create_opts>> ret = qcow2_co_create(create_options, errp);
+ */
 static int coroutine_fn GRAPH_UNLOCKED
 qcow2_co_create(BlockdevCreateOptions *create_options, Error **errp)
 {
@@ -3796,6 +3938,23 @@ qcow2_co_create(BlockdevCreateOptions *create_options, Error **errp)
     }
 
     bdrv_graph_co_rdlock();
+    /*
+     * 在以下使用qcow2_alloc_clusters():
+     *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+     *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+     *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+     *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+     *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+     *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+     *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+     *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+     *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+     *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+     *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+     */
     ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
     if (ret < 0) {
         bdrv_graph_co_rdunlock();
@@ -4094,6 +4253,14 @@ qcow2_co_pwrite_zeroes(BlockDriverState *bs, int64_t offset, int64_t bytes,
         offset -= head;
         bytes = s->subcluster_size;
         nr = s->subcluster_size;
+        /*
+	 * 在以下使用qcow2_get_host_offset():
+         *   - block/qcow2.c|2186| <<qcow2_co_block_status>> ret = qcow2_get_host_offset(bs, offset, &bytes, &host_offset, &type);
+         *   - block/qcow2.c|2430| <<qcow2_co_preadv_part>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+         *   - block/qcow2.c|4135| <<qcow2_co_pwrite_zeroes>> ret = qcow2_get_host_offset(bs, offset, &nr, &off, &type);
+         *   - block/qcow2.c|4209| <<qcow2_co_copy_range_from>> ret = qcow2_get_host_offset(bs, src_offset, &cur_bytes, &copy_offset, &type);
+         *   - block/qcow2.c|5464| <<qcow2_has_compressed_clusters>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+	 */
         ret = qcow2_get_host_offset(bs, offset, &nr, &off, &type);
         if (ret < 0 ||
             (type != QCOW2_SUBCLUSTER_UNALLOCATED_PLAIN &&
@@ -4168,6 +4335,14 @@ qcow2_co_copy_range_from(BlockDriverState *bs,
         cur_bytes = MIN(bytes, INT_MAX);
         cur_write_flags = write_flags;
 
+        /*
+	 * 在以下使用qcow2_get_host_offset():
+         *   - block/qcow2.c|2186| <<qcow2_co_block_status>> ret = qcow2_get_host_offset(bs, offset, &bytes, &host_offset, &type);
+         *   - block/qcow2.c|2430| <<qcow2_co_preadv_part>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+         *   - block/qcow2.c|4135| <<qcow2_co_pwrite_zeroes>> ret = qcow2_get_host_offset(bs, offset, &nr, &off, &type);
+         *   - block/qcow2.c|4209| <<qcow2_co_copy_range_from>> ret = qcow2_get_host_offset(bs, src_offset, &cur_bytes, &copy_offset, &type);
+         *   - block/qcow2.c|5464| <<qcow2_has_compressed_clusters>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+	 */
         ret = qcow2_get_host_offset(bs, src_offset, &cur_bytes,
                                     &copy_offset, &type);
         if (ret < 0) {
@@ -4406,6 +4581,12 @@ qcow2_co_truncate(BlockDriverState *bs, int64_t offset, bool exact,
             }
         }
     } else {
+        /*
+	 * 在以下使用qcow2_grow_l1_table():
+         *   - block/qcow2-cluster.c|777| <<get_cluster_table>> ret = qcow2_grow_l1_table(bs, l1_index + 1, false);
+         *   - block/qcow2-snapshot.c|812| <<qcow2_snapshot_goto>> ret = qcow2_grow_l1_table(bs, sn->l1_size, true);
+         *   - block/qcow2.c|4482| <<qcow2_co_truncate>> ret = qcow2_grow_l1_table(bs, new_l1_size, true);
+	 */
         ret = qcow2_grow_l1_table(bs, new_l1_size, true);
         if (ret < 0) {
             error_setg_errno(errp, -ret, "Failed to grow the L1 table");
@@ -4820,6 +5001,10 @@ qcow2_co_pwritev_compressed_part(BlockDriverState *bs,
     return ret;
 }
 
+/*
+ * 处理QCOW2_SUBCLUSTER_COMPRESSED:
+ *   - block/qcow2.c|2461| <<qcow2_co_preadv_task>> return qcow2_co_preadv_compressed(bs, host_offset,
+ */
 static int coroutine_fn GRAPH_RDLOCK
 qcow2_co_preadv_compressed(BlockDriverState *bs,
                            uint64_t l2_entry,
@@ -4849,6 +5034,9 @@ qcow2_co_preadv_compressed(BlockDriverState *bs,
         goto fail;
     }
 
+    /*
+     * 只在这里调用
+     */
     if (qcow2_co_decompress(bs, out_buf, s->cluster_size, buf, csize) < 0) {
         ret = -EIO;
         goto fail;
@@ -4973,8 +5161,41 @@ static int GRAPH_RDLOCK make_completely_empty(BlockDriverState *bs)
     }
     s->refcount_table[0] = 2 * s->cluster_size;
 
+    /*
+     * 在以下设置free_cluster_index:
+     *   - block/qcow2-refcount.c|856| <<update_refcount>> s->free_cluster_index = (start >> s->cluster_bits);
+     *   - block/qcow2-refcount.c|884| <<update_refcount>> s->free_cluster_index = cluster_index;
+     *   - block/qcow2-refcount.c|983| <<alloc_clusters_noref>> uint64_t next_cluster_index = s->free_cluster_index++;
+     *   - block/qcow2-refcount.c|3694| <<qcow2_discard_refcount_block>> s->free_cluster_index = cluster_index;
+     *   - block/qcow2.c|5060| <<make_completely_empty>> s->free_cluster_index = 0;
+     * 在以下使用free_cluster_index:
+     *   - block/qcow2-refcount.c|855| <<update_refcount>> if (s->free_cluster_index > (start >> s->cluster_bits)) {
+     *   - block/qcow2-refcount.c|883| <<update_refcount>> if (refcount == 0 && cluster_index < s->free_cluster_index) {
+     *   - block/qcow2-refcount.c|995| <<alloc_clusters_noref>> if (s->free_cluster_index > 0 &&
+     *   - block/qcow2-refcount.c|996| <<alloc_clusters_noref>> s->free_cluster_index - 1 > (max >> s->cluster_bits))
+     *   - block/qcow2-refcount.c|1004| <<alloc_clusters_noref>> (s->free_cluster_index - nb_clusters) << s->cluster_bits);
+     *   - block/qcow2-refcount.c|1006| <<alloc_clusters_noref>> return (s->free_cluster_index - nb_clusters) << s->cluster_bits;
+     *   - block/qcow2-refcount.c|3693| <<qcow2_discard_refcount_block>> if (cluster_index < s->free_cluster_index) {
+     */
     s->free_cluster_index = 0;
     assert(3 + l1_clusters <= s->refcount_block_size);
+    /*
+     * 在以下使用qcow2_alloc_clusters():
+     *   - block/qcow2-bitmap.c|790| <<bitmap_list_store>> dir_offset = qcow2_alloc_clusters(bs, dir_size);
+     *   - block/qcow2-bitmap.c|1331| <<store_bitmap_data>> off = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-bitmap.c|1398| <<store_bitmap>> tb_offset = qcow2_alloc_clusters(bs, tb_size * sizeof(tb[0]));
+     *   - block/qcow2-cluster.c|142| <<qcow2_grow_l1_table>> new_l1_table_offset = qcow2_alloc_clusters(bs, new_l1_size2);
+     *   - block/qcow2-cluster.c|288| <<l2_allocate>> l2_offset = qcow2_alloc_clusters(bs, s->l2_size * l2_entry_size(s));
+     *   - block/qcow2-cluster.c|1632| <<do_alloc_cluster_offset>> qcow2_alloc_clusters(bs, *nb_clusters * s->cluster_size);
+     *   - block/qcow2-cluster.c|2351| <<expand_zero_clusters_in_l1>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3182| <<alloc_refblock>> offset = qcow2_alloc_clusters(bs, s->cluster_size);
+     *   - block/qcow2-refcount.c|3454| <<qcow2_change_refcount_order>> new_reftable_offset = qcow2_alloc_clusters(bs, new_reftable_size *
+     *   - block/qcow2-snapshot.c|305| <<qcow2_write_snapshots>> snapshots_offset = qcow2_alloc_clusters(bs, snapshots_size);
+     *   - block/qcow2-snapshot.c|673| <<qcow2_snapshot_create>> l1_table_offset = qcow2_alloc_clusters(bs, s->l1_size * L1E_SIZE);
+     *   - block/qcow2.c|131| <<qcow2_crypto_hdr_init_func>> ret = qcow2_alloc_clusters(bs, headerlen);
+     *   - block/qcow2.c|3856| <<qcow2_co_create>> ret = qcow2_alloc_clusters(blk_bs(blk), 3 * cluster_size);
+     *   - block/qcow2.c|5051| <<make_completely_empty>> offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
+     */
     offset = qcow2_alloc_clusters(bs, 3 * s->cluster_size + l1_size2);
     if (offset < 0) {
         ret = offset;
@@ -5423,6 +5644,14 @@ static int GRAPH_RDLOCK qcow2_has_compressed_clusters(BlockDriverState *bs)
         unsigned int cur_bytes = MIN(INT_MAX, bytes);
         uint64_t host_offset;
 
+        /*
+	 * 在以下使用qcow2_get_host_offset():
+         *   - block/qcow2.c|2186| <<qcow2_co_block_status>> ret = qcow2_get_host_offset(bs, offset, &bytes, &host_offset, &type);
+         *   - block/qcow2.c|2430| <<qcow2_co_preadv_part>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+         *   - block/qcow2.c|4135| <<qcow2_co_pwrite_zeroes>> ret = qcow2_get_host_offset(bs, offset, &nr, &off, &type);
+         *   - block/qcow2.c|4209| <<qcow2_co_copy_range_from>> ret = qcow2_get_host_offset(bs, src_offset, &cur_bytes, &copy_offset, &type);
+         *   - block/qcow2.c|5464| <<qcow2_has_compressed_clusters>> ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset, &type);
+	 */
         ret = qcow2_get_host_offset(bs, offset, &cur_bytes, &host_offset,
                                     &type);
         if (ret < 0) {
@@ -5979,6 +6208,34 @@ static int coroutine_fn qcow2_co_amend(BlockDriverState *bs,
  * fatal will be ignored for read-only BDS; corruptions found there will always
  * be considered non-fatal.
  */
+/*
+ * 在以下使用qcow2_signal_corruption():
+ *   - block/qcow2-cache.c|340| <<qcow2_cache_do_get>> qcow2_signal_corruption(bs, true, -1, -1, "Cannot get entry from %s "
+  2 block/qcow2-cluster.c|299| <<l2_allocate>> qcow2_signal_corruption(bs, true, -1, -1, "Preventing invalid "
+  3 block/qcow2-cluster.c|630| <<qcow2_get_host_offset>> qcow2_signal_corruption(bs, true, -1, -1, "L2 table offset %#" PRIx64
+  4 block/qcow2-cluster.c|659| <<qcow2_get_host_offset>> qcow2_signal_corruption(bs, true, -1, -1, "Zero cluster entry found"
+  5 block/qcow2-cluster.c|670| <<qcow2_get_host_offset>> qcow2_signal_corruption(bs, true, -1, -1, "Compressed cluster "
+  6 block/qcow2-cluster.c|688| <<qcow2_get_host_offset>> qcow2_signal_corruption(bs, true, -1, -1,
+  7 block/qcow2-cluster.c|697| <<qcow2_get_host_offset>> qcow2_signal_corruption(bs, true, -1, -1,
+  8 block/qcow2-cluster.c|715| <<qcow2_get_host_offset>> qcow2_signal_corruption(bs, true, -1, -1, "Invalid cluster entry found "
+  9 block/qcow2-cluster.c|778| <<get_cluster_table>> qcow2_signal_corruption(bs, true, -1, -1, "L2 table offset %#" PRIx64
+ 10 block/qcow2-cluster.c|1200| <<calculate_l2_meta>> qcow2_signal_corruption(bs, true, -1, -1, "Invalid cluster "
+ *   0 block/qcow2-cluster.c|1535| <<handle_copied>> qcow2_signal_corruption(bs, true, -1, -1, "%s cluster offset "
+ 12 block/qcow2-cluster.c|2291| <<expand_zero_clusters_in_l1>> qcow2_signal_corruption(bs, true, -1, -1, "L2 table offset %#"
+ 13 block/qcow2-cluster.c|2369| <<expand_zero_clusters_in_l1>> qcow2_signal_corruption(
+ 14 block/qcow2-refcount.c|269| <<qcow2_get_refcount>> qcow2_signal_corruption(bs, true, -1, -1, "Refblock offset %#" PRIx64
+ 15 block/qcow2-refcount.c|326| <<alloc_refcount_block>> qcow2_signal_corruption(bs, true, -1, -1, "Refblock offset %#"
+ 16 block/qcow2-refcount.c|380| <<alloc_refcount_block>> qcow2_signal_corruption(bs, true, -1, -1, "Preventing invalid "
+ 17 block/qcow2-refcount.c|1108| <<qcow2_alloc_bytes>> qcow2_signal_corruption(bs, true, -1, -1, "Preventing invalid "
+ 18 block/qcow2-refcount.c|1192| <<qcow2_free_any_cluster>> qcow2_signal_corruption(bs, false, -1, -1,
+ *   - block/qcow2-refcount.c|1297| <<qcow2_update_snapshot_refcount>> qcow2_signal_corruption(bs, true, -1, -1, "L2 table offset %#"
+ 20 block/qcow2-refcount.c|1346| <<qcow2_update_snapshot_refcount>> qcow2_signal_corruption(
+ 21 block/qcow2-refcount.c|3085| <<qcow2_pre_write_overlap_check>> qcow2_signal_corruption(bs, true, offset, size, "Preventing invalid "
+ 22 block/qcow2-refcount.c|3246| <<walk_over_reftable>> qcow2_signal_corruption(bs, true, -1, -1, "Refblock offset %#"
+ 23 block/qcow2-refcount.c|3561| <<get_refblock_offset>> qcow2_signal_corruption(bs, true, -1, -1, "Refblock at %#" PRIx64 " is "
+ 24 block/qcow2-refcount.c|3594| <<qcow2_discard_refcount_block>> qcow2_signal_corruption(bs, true, -1, -1, "Invalid refcount:"
+ 25 block/qcow2-refcount.c|3712| <<qcow2_get_last_cluster>> qcow2_signal_corruption(bs, true, -1, -1,
+ */
 void qcow2_signal_corruption(BlockDriverState *bs, bool fatal, int64_t offset,
                              int64_t size, const char *message_format, ...)
 {
diff --git a/block/qcow2.h b/block/qcow2.h
index a9e3481c6..e63e96c49 100644
--- a/block/qcow2.h
+++ b/block/qcow2.h
@@ -354,6 +354,22 @@ typedef struct BDRVQcow2State {
     uint64_t refcount_table_offset;
     uint32_t refcount_table_size;
     uint32_t max_refcount_table_index; /* Last used entry in refcount_table */
+    /*
+     * 在以下设置free_cluster_index:
+     *   - block/qcow2-refcount.c|856| <<update_refcount>> s->free_cluster_index = (start >> s->cluster_bits);
+     *   - block/qcow2-refcount.c|884| <<update_refcount>> s->free_cluster_index = cluster_index;
+     *   - block/qcow2-refcount.c|983| <<alloc_clusters_noref>> uint64_t next_cluster_index = s->free_cluster_index++;
+     *   - block/qcow2-refcount.c|3694| <<qcow2_discard_refcount_block>> s->free_cluster_index = cluster_index;
+     *   - block/qcow2.c|5060| <<make_completely_empty>> s->free_cluster_index = 0;
+     * 在以下使用free_cluster_index:
+     *   - block/qcow2-refcount.c|855| <<update_refcount>> if (s->free_cluster_index > (start >> s->cluster_bits)) {
+     *   - block/qcow2-refcount.c|883| <<update_refcount>> if (refcount == 0 && cluster_index < s->free_cluster_index) {
+     *   - block/qcow2-refcount.c|995| <<alloc_clusters_noref>> if (s->free_cluster_index > 0 &&
+     *   - block/qcow2-refcount.c|996| <<alloc_clusters_noref>> s->free_cluster_index - 1 > (max >> s->cluster_bits))
+     *   - block/qcow2-refcount.c|1004| <<alloc_clusters_noref>> (s->free_cluster_index - nb_clusters) << s->cluster_bits);
+     *   - block/qcow2-refcount.c|1006| <<alloc_clusters_noref>> return (s->free_cluster_index - nb_clusters) << s->cluster_bits;
+     *   - block/qcow2-refcount.c|3693| <<qcow2_discard_refcount_block>> if (cluster_index < s->free_cluster_index) {
+     */
     uint64_t free_cluster_index;
     uint64_t free_byte_offset;
 
@@ -381,6 +397,46 @@ typedef struct BDRVQcow2State {
     int refcount_bits;
     uint64_t refcount_max;
 
+    /*
+     * 67 static Qcow2GetRefcountFunc *const get_refcount_funcs[] = {
+     * 68     &get_refcount_ro0,
+     * 69     &get_refcount_ro1,
+     * 70     &get_refcount_ro2,
+     * 71     &get_refcount_ro3,
+     * 72     &get_refcount_ro4,
+     * 73     &get_refcount_ro5,
+     * 74     &get_refcount_ro6
+     * 75 };
+     * 76
+     * 77 static Qcow2SetRefcountFunc *const set_refcount_funcs[] = {
+     * 78     &set_refcount_ro0,
+     * 79     &set_refcount_ro1,
+     * 80     &set_refcount_ro2,
+     * 81     &set_refcount_ro3,
+     * 82     &set_refcount_ro4,
+     * 83     &set_refcount_ro5,
+     * 84     &set_refcount_ro6
+     * 85 };
+     *
+     *
+     * 在以下设置BDRVQcow2State->get_refcount:
+     *   - block/qcow2-refcount.c|109| <<qcow2_refcount_init>> s->get_refcount = get_refcount_funcs[s->refcount_order];
+     *   - block/qcow2-refcount.c|3850| <<qcow2_change_refcount_order>> s->get_refcount = new_get_refcount;
+     * 在以下使用BDRVQcow2State->get_refcount:
+     *   - block/qcow2-refcount.c|296| <<qcow2_get_refcount>> *refcount = s->get_refcount(refcount_block, block_index);
+     *   - block/qcow2-refcount.c|689| <<qcow2_refcount_area>> assert(s->get_refcount(refblock_data, j) == 0);
+     *   - block/qcow2-refcount.c|908| <<update_refcount>> refcount = s->get_refcount(refcount_block, block_index);
+     *   - block/qcow2-refcount.c|1866| <<qcow2_inc_refcounts_imrt>> refcount = s->get_refcount(*refcount_table, k);
+     *   - block/qcow2-refcount.c|2492| <<check_refblocks>> if (s->get_refcount(*refcount_table, cluster) != 1) {
+     *   - block/qcow2-refcount.c|2495| <<check_refblocks>> s->get_refcount(*refcount_table, cluster));
+     *   - block/qcow2-refcount.c|2645| <<compare_refcounts>> refcount2 = s->get_refcount(refcount_table, i);
+     *   - block/qcow2-refcount.c|2733| <<alloc_clusters_imrt>> if (!s->get_refcount(*refcount_table, cluster)) {
+     *   - block/qcow2-refcount.c|2822| <<rebuild_refcounts_write_refblocks>> if (!s->get_refcount(*refcount_table, cluster)) {
+     *   - block/qcow2-refcount.c|3616| <<walk_over_reftable>> refcount = s->get_refcount(refblock, refblock_index);
+     *   - block/qcow2-refcount.c|3927| <<qcow2_discard_refcount_block>> if (s->get_refcount(refblock, block_index) != 1) {
+     *   - block/qcow2-refcount.c|3936| <<qcow2_discard_refcount_block>> s->get_refcount(refblock, block_index));
+     *   - block/qcow2-refcount.c|4003| <<qcow2_shrink_reftable>> uint64_t refcount = s->get_refcount(refblock, block_index);
+     */
     Qcow2GetRefcountFunc *get_refcount;
     Qcow2SetRefcountFunc *set_refcount;
 
diff --git a/bsd-user/main.c b/bsd-user/main.c
index 7e5d4bbce..d8f96af4d 100644
--- a/bsd-user/main.c
+++ b/bsd-user/main.c
@@ -214,6 +214,36 @@ bool qemu_cpu_is_self(CPUState *cpu)
     return thread_cpu == cpu;
 }
 
+/*
+ * 在以下使用qemu_cpu_kick():
+ *   - accel/accel-blocker.c|93| <<accel_has_to_wait>> qemu_cpu_kick(cpu);
+ *   - accel/tcg/icount-common.c|500| <<icount_notify_exit>> qemu_cpu_kick(current_cpu);
+ *   - accel/tcg/tcg-accel-ops.c|107| <<tcg_handle_interrupt>> qemu_cpu_kick(cpu);
+ *   - cpu-common.c|140| <<queue_work_on_cpu>> qemu_cpu_kick(cpu);
+ *   - cpu-common.c|217| <<start_exclusive>> qemu_cpu_kick(other_cpu);
+ *   - gdbstub/system.c|121| <<gdb_syscall_handling>> qemu_cpu_kick(gdbserver_state.c_cpu);
+ *   - hw/openrisc/cputimer.c|126| <<openrisc_timer_cb>> qemu_cpu_kick(CPU(cpu));
+ *   - hw/ppc/ppc.c|196| <<ppc970_set_irq>> qemu_cpu_kick(cs);
+ *   - hw/ppc/ppc.c|392| <<ppc40x_set_irq>> qemu_cpu_kick(cs);
+ *   - hw/ppc/ppce500_spin.c|103| <<spin_kick>> qemu_cpu_kick(cs);
+ *   - hw/ppc/spapr_hcall.c|651| <<h_prod>> qemu_cpu_kick(cs);
+ *   - hw/ppc/spapr_rtas.c|199| <<rtas_start_cpu>> qemu_cpu_kick(CPU(newcpu));
+ *   - hw/ppc/spapr_rtas.c|224| <<rtas_stop_self>> qemu_cpu_kick(cs);
+ *   - hw/sparc/sun4m.c|180| <<cpu_kick_irq>> qemu_cpu_kick(cs);
+ *   - hw/sparc64/sparc64.c|45| <<cpu_kick_irq>> qemu_cpu_kick(cs);
+ *   - replay/replay-events.c|121| <<replay_add_event>> qemu_cpu_kick(first_cpu);
+ *   - semihosting/console.c|56| <<console_wake_up>> qemu_cpu_kick(cs);
+ *   - system/cpu-timers.c|253| <<qemu_timer_notify_cb>> qemu_cpu_kick(current_cpu);
+ *   - system/cpus.c|432| <<generic_handle_interrupt>> qemu_cpu_kick(cpu);
+ *   - system/cpus.c|749| <<qemu_cpu_kick>> void qemu_cpu_kick(CPUState *cpu)
+ *   - system/cpus.c|866| <<cpu_pause>> qemu_cpu_kick(cpu);
+ *   - system/cpus.c|883| <<cpu_resume>> qemu_cpu_kick(cpu);
+ *   - system/cpus.c|949| <<pause_all_vcpus>> qemu_cpu_kick(cpu);
+ *   - system/cpus.c|983| <<cpu_remove_sync>> qemu_cpu_kick(cpu);
+ *   - target/arm/tcg/mte_helper.c|594| <<mte_async_check_fail>> qemu_cpu_kick(env_cpu(env));
+ *   - target/i386/kvm/xen-emu.c|463| <<kvm_xen_inject_vcpu_callback_vector>> qemu_cpu_kick(cs);
+ *   - target/xtensa/helper.c|319| <<xtensa_runstall>> qemu_cpu_kick(cpu);
+ */
 void qemu_cpu_kick(CPUState *cpu)
 {
     cpu_exit(cpu);
diff --git a/cpu-common.c b/cpu-common.c
index ef5757d23..27cae000f 100644
--- a/cpu-common.c
+++ b/cpu-common.c
@@ -345,6 +345,18 @@ void free_queued_cpu_work(CPUState *cpu)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_arch_put_registers (cpu=0x5555577517f0, level=2, errp=0x7fffedb02580) at ../target/i386/kvm/kvm.c:5252
+ * #1  0x0000555555f0bc3e in do_kvm_cpu_synchronize_post_reset (cpu=0x5555577517f0, arg=...) at ../accel/kvm/kvm-all.c:2893
+ * #2  0x000055555588e3ab in process_queued_cpu_work (cpu=0x5555577517f0) at ../cpu-common.c:374
+ * #3  0x0000555555c1e021 in qemu_wait_io_event_common (cpu=0x5555577517f0) at ../system/cpus.c:451
+ * #4  0x0000555555c1e0ba in qemu_wait_io_event (cpu=0x5555577517f0) at ../system/cpus.c:469
+ * #5  0x0000555555f0fef1 in kvm_vcpu_thread_fn (arg=0x5555577517f0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #6  0x00005555561ad4c6 in qemu_thread_start (args=0x55555775bc80) at ../util/qemu-thread-posix.c:541
+ * #7  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #8  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 void process_queued_cpu_work(CPUState *cpu)
 {
     struct qemu_work_item *wi;
diff --git a/dump/dump.c b/dump/dump.c
index 15bbcc0c6..df6d9d833 100644
--- a/dump/dump.c
+++ b/dump/dump.c
@@ -111,6 +111,23 @@ static int dump_cleanup(DumpState *s)
         if (s->detached) {
             bql_lock();
         }
+        /*
+	 * 在以下使用vm_start():
+	 *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+	 *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+	 *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|793| <<vm_resume>> vm_start();
+	 */
         vm_start();
         if (s->detached) {
             bql_unlock();
@@ -1808,6 +1825,16 @@ static void dump_init(DumpState *s, int fd, bool has_format,
     /* If we use KVM, we should synchronize the registers before we get dump
      * info or physmap info.
      */
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
     nr_cpus = 0;
     CPU_FOREACH(cpu) {
diff --git a/hw/acpi/vmclock.c b/hw/acpi/vmclock.c
index c582c0c1f..e1e80daff 100644
--- a/hw/acpi/vmclock.c
+++ b/hw/acpi/vmclock.c
@@ -61,6 +61,11 @@ void vmclock_build_acpi(VmclockState *vms, GArray *table_data,
     free_aml_allocator();
 }
 
+/*
+ * 在以下使用vmclock_update_guest():
+ *   - hw/acpi/vmclock.c|95| <<vmclock_post_load>> vmclock_update_guest(vms);
+ *   - hw/acpi/vmclock.c|154| <<vmclock_realize>> vmclock_update_guest(vms);
+ */
 static void vmclock_update_guest(VmclockState *vms)
 {
     uint64_t disruption_marker;
@@ -92,6 +97,11 @@ static int vmclock_post_load(void *opaque, int version_id)
 {
     VmclockState *vms = opaque;
 
+    /*
+     * 在以下使用vmclock_update_guest():
+     *   - hw/acpi/vmclock.c|95| <<vmclock_post_load>> vmclock_update_guest(vms);
+     *   - hw/acpi/vmclock.c|154| <<vmclock_realize>> vmclock_update_guest(vms);
+     */
     vmclock_update_guest(vms);
     return 0;
 }
@@ -138,6 +148,14 @@ static void vmclock_realize(DeviceState *dev, Error **errp)
     memory_region_init_ram(&vms->clk_page, OBJECT(dev), "vmclock_page",
                            VMCLOCK_SIZE, &error_abort);
     memory_region_set_enabled(&vms->clk_page, true);
+    /*
+     * struct VmclockState {
+     *     DeviceState parent_obj;
+     *     MemoryRegion clk_page;
+     *     uint64_t physaddr;
+     *     struct vmclock_abi *clk;
+     * };
+     */
     vms->clk = memory_region_get_ram_ptr(&vms->clk_page);
     memset(vms->clk, 0, VMCLOCK_SIZE);
 
@@ -146,11 +164,23 @@ static void vmclock_realize(DeviceState *dev, Error **errp)
     vms->clk->version = cpu_to_le16(1);
 
     /* These are all zero and thus default, but be explicit */
+    /*
+     * 121 #define VMCLOCK_STATUS_UNKNOWN          0
+     * 122 #define VMCLOCK_STATUS_INITIALIZING     1
+     * 123 #define VMCLOCK_STATUS_SYNCHRONIZED     2
+     * 124 #define VMCLOCK_STATUS_FREERUNNING      3
+     * 125 #define VMCLOCK_STATUS_UNRELIABLE       4
+     */
     vms->clk->clock_status = VMCLOCK_STATUS_UNKNOWN;
     vms->clk->counter_id = VMCLOCK_COUNTER_INVALID;
 
     qemu_register_reset(vmclock_handle_reset, vms);
 
+    /*
+     * 在以下使用vmclock_update_guest():
+     *   - hw/acpi/vmclock.c|95| <<vmclock_post_load>> vmclock_update_guest(vms);
+     *   - hw/acpi/vmclock.c|154| <<vmclock_realize>> vmclock_update_guest(vms);
+     */
     vmclock_update_guest(vms);
 }
 
diff --git a/hw/block/virtio-blk.c b/hw/block/virtio-blk.c
index 9bab2716c..b2769251b 100644
--- a/hw/block/virtio-blk.c
+++ b/hw/block/virtio-blk.c
@@ -1802,6 +1802,15 @@ static void virtio_blk_device_realize(DeviceState *dev, Error **errp)
      * This must be after virtio_init() so virtio_blk_dma_restart_cb() gets
      * called after ->start_ioeventfd() has already set blk's AioContext.
      */
+    /*
+     * 在以下使用qdev_add_vm_change_state_handler():
+     *   - hw/block/virtio-blk.c|1806| <<virtio_blk_device_realize>> qdev_add_vm_change_state_handler(dev,
+     *        virtio_blk_dma_restart_cb, NULL, s);
+     *   - hw/scsi/scsi-bus.c|402| <<scsi_qdev_realize>> dev->vmsentry = qdev_add_vm_change_state_handler(DEVICE(dev),
+     *        scsi_dma_restart_cb, NULL, dev);
+     *   - hw/virtio/virtio.c|3580| <<virtio_init>> vdev->vmstate = qdev_add_vm_change_state_handler(DEVICE(vdev),
+     *        NULL, virtio_vmstate_change, vdev);
+     */
     s->change =
         qdev_add_vm_change_state_handler(dev, virtio_blk_dma_restart_cb, NULL, s);
 
diff --git a/hw/core/cpu-common.c b/hw/core/cpu-common.c
index 39e674aca..6eed98dd4 100644
--- a/hw/core/cpu-common.c
+++ b/hw/core/cpu-common.c
@@ -263,7 +263,33 @@ static void cpu_common_realizefn(DeviceState *dev, Error **errp)
     }
 
     if (dev->hotplugged) {
+        /*
+         * 在以下使用cpu_synchronize_post_init():
+         *   - hw/core/cpu-common.c|266| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+         *   - system/cpus.c|167| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+         *   - target/s390x/gdbstub.c|92| <<cpu_write_ac_reg>> cpu_synchronize_post_init(env_cpu(env));
+         *   - target/s390x/gdbstub.c|210| <<cpu_write_c_reg>> cpu_synchronize_post_init(env_cpu(env));
+         *   - target/s390x/gdbstub.c|250| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+         *   - target/s390x/gdbstub.c|254| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+         *   - target/s390x/gdbstub.c|258| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+         *   - target/s390x/gdbstub.c|262| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+         *   - target/s390x/gdbstub.c|302| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+         *   - target/s390x/gdbstub.c|306| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+         *   - target/s390x/gdbstub.c|310| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+         *   - target/s390x/gdbstub.c|314| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+         *   - target/s390x/gdbstub.c|342| <<cpu_write_gs_reg>> cpu_synchronize_post_init(env_cpu(env));
+         *   - target/s390x/sigp.c|295| <<sigp_set_prefix>> cpu_synchronize_post_init(cs);
+         *
+         * kvm_cpu_synchronize_post_init()
+	 */
         cpu_synchronize_post_init(cpu);
+        /*
+         * 在以下使用cpu_resume():
+         *   - gdbstub/system.c|590| <<gdb_continue_partial>> cpu_resume(cpu);
+         *   - gdbstub/system.c|595| <<gdb_continue_partial>> cpu_resume(cpu);
+         *   - hw/core/cpu-common.c|267| <<cpu_common_realizefn>> cpu_resume(cpu);
+         *   - system/cpus.c|975| <<resume_all_vcpus>> cpu_resume(cpu);
+	 */
         cpu_resume(cpu);
     }
 
diff --git a/hw/core/cpu-system.c b/hw/core/cpu-system.c
index a975405d3..4a4eb006f 100644
--- a/hw/core/cpu-system.c
+++ b/hw/core/cpu-system.c
@@ -283,6 +283,10 @@ const VMStateDescription vmstate_cpu_common = {
     }
 };
 
+/*
+ * 在以下使用cpu_vmstate_register():
+ *   - hw/core/cpu-common.c|242| <<cpu_exec_realizefn>> cpu_vmstate_register(cpu);
+ */
 void cpu_vmstate_register(CPUState *cpu)
 {
     if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index f60022617..9d27c554b 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -40,7 +40,19 @@
 #include "migration/vmstate.h"
 #include "trace.h"
 
+/*
+ * 在以下使用qdev_hot_added:
+ *   - hw/core/qdev.c|43| <<global>> static bool qdev_hot_added = false;
+ *   - hw/core/qdev.c|314| <<qdev_machine_modified>> return qdev_hot_added || qdev_hot_removed;
+ *   - hw/core/qdev.c|642| <<device_initfn>> qdev_hot_added = true;
+ */
 static bool qdev_hot_added = false;
+/*
+ * 在以下使用qdev_hot_removed:
+ *   - hw/core/qdev.c|44| <<global>> bool qdev_hot_removed = false;
+ *   - hw/core/qdev.c|314| <<qdev_machine_modified>> return qdev_hot_added || qdev_hot_removed;
+ *   - system/qdev-monitor.c|905| <<qdev_unplug>> qdev_hot_removed = true;
+ */
 bool qdev_hot_removed = false;
 
 const VMStateDescription *qdev_get_vmsd(DeviceState *dev)
@@ -309,8 +321,23 @@ void qdev_assert_realized_properly(void)
                                    qdev_assert_realized_properly_cb, NULL);
 }
 
+/*
+ * 在以下使用qdev_machine_modified():
+ *   - hw/net/rtl8139.c|3148| <<rtl8139_hotplug_ready_needed>> return qdev_machine_modified();
+ */
 bool qdev_machine_modified(void)
 {
+    /*
+     * 在以下使用qdev_hot_added:
+     *   - hw/core/qdev.c|43| <<global>> static bool qdev_hot_added = false;
+     *   - hw/core/qdev.c|314| <<qdev_machine_modified>> return qdev_hot_added || qdev_hot_removed;
+     *   - hw/core/qdev.c|642| <<device_initfn>> qdev_hot_added = true;
+     *
+     * 在以下使用qdev_hot_removed:
+     *   - hw/core/qdev.c|44| <<global>> bool qdev_hot_removed = false;
+     *   - hw/core/qdev.c|314| <<qdev_machine_modified>> return qdev_hot_added || qdev_hot_removed;
+     *   - system/qdev-monitor.c|905| <<qdev_unplug>> qdev_hot_removed = true;
+     */
     return qdev_hot_added || qdev_hot_removed;
 }
 
@@ -639,6 +666,12 @@ static void device_initfn(Object *obj)
 
     if (phase_check(PHASE_MACHINE_READY)) {
         dev->hotplugged = 1;
+        /*
+	 * 在以下使用qdev_hot_added:
+         *   - hw/core/qdev.c|43| <<global>> static bool qdev_hot_added = false;
+         *   - hw/core/qdev.c|314| <<qdev_machine_modified>> return qdev_hot_added || qdev_hot_removed;
+         *   - hw/core/qdev.c|642| <<device_initfn>> qdev_hot_added = true;
+	 */
         qdev_hot_added = true;
     }
 
diff --git a/hw/core/sysbus.c b/hw/core/sysbus.c
index ec69e877a..1e3e5f3e1 100644
--- a/hw/core/sysbus.c
+++ b/hw/core/sysbus.c
@@ -196,6 +196,14 @@ MemoryRegion *sysbus_mmio_get_region(SysBusDevice *dev, int n)
     return dev->mmio[n].memory;
 }
 
+/*
+ * 在以下使用sysbus_init_ioports():
+ *   - hw/i386/vapic.c|742| <<vapic_realize>> sysbus_init_ioports(sbd, VAPIC_IO_PORT, 2);
+ *   - hw/pci-host/i440fx.c|261| <<i440fx_pcihost_realize>> sysbus_init_ioports(sbd, 0xcf8, 4);
+ *   - hw/pci-host/i440fx.c|264| <<i440fx_pcihost_realize>> sysbus_init_ioports(sbd, 0xcfc, 4);
+ *   - hw/pci-host/q35.c|55| <<q35_host_realize>> sysbus_init_ioports(sbd, MCH_HOST_BRIDGE_CONFIG_ADDR, 4);
+ *   - hw/pci-host/q35.c|59| <<q35_host_realize>> sysbus_init_ioports(sbd, MCH_HOST_BRIDGE_CONFIG_DATA, 4);
+ */
 void sysbus_init_ioports(SysBusDevice *dev, uint32_t ioport, uint32_t size)
 {
     uint32_t i;
diff --git a/hw/core/vm-change-state-handler.c b/hw/core/vm-change-state-handler.c
index 99c642b55..7005cb7d9 100644
--- a/hw/core/vm-change-state-handler.c
+++ b/hw/core/vm-change-state-handler.c
@@ -55,12 +55,29 @@ static int qdev_get_dev_tree_depth(DeviceState *dev)
  *
  * Returns: an entry to be freed with qemu_del_vm_change_state_handler()
  */
+/*
+ * 在以下使用qdev_add_vm_change_state_handler():
+ *   - hw/block/virtio-blk.c|1806| <<virtio_blk_device_realize>> qdev_add_vm_change_state_handler(dev,
+ *        virtio_blk_dma_restart_cb, NULL, s);
+ *   - hw/scsi/scsi-bus.c|402| <<scsi_qdev_realize>> dev->vmsentry = qdev_add_vm_change_state_handler(DEVICE(dev),
+ *        scsi_dma_restart_cb, NULL, dev);
+ *   - hw/virtio/virtio.c|3580| <<virtio_init>> vdev->vmstate = qdev_add_vm_change_state_handler(DEVICE(vdev),
+ *        NULL, virtio_vmstate_change, vdev);
+ */
 VMChangeStateEntry *qdev_add_vm_change_state_handler(DeviceState *dev,
                                                      VMChangeStateHandler *cb,
                                                      VMChangeStateHandlerWithRet *cb_ret,
                                                      void *opaque)
 {
     assert(!cb || !cb_ret);
+    /*
+     * 在以下使用qdev_add_vm_change_state_handler_full():
+     *   - hw/core/vm-change-state-handler.c|64| <<qdev_add_vm_change_state_handler>>
+     *       return qdev_add_vm_change_state_handler_full(dev, cb, NULL, cb_ret, opaque);
+     *   - hw/vfio/migration.c|1037| <<vfio_migration_init>> migration->vm_state =
+     *       qdev_add_vm_change_state_handler_full(vbasedev->dev, vfio_vmstate_change,
+     *       prepare_cb, NULL, vbasedev);
+     */
     return qdev_add_vm_change_state_handler_full(dev, cb, NULL, cb_ret, opaque);
 }
 
@@ -68,6 +85,14 @@ VMChangeStateEntry *qdev_add_vm_change_state_handler(DeviceState *dev,
  * Exactly like qdev_add_vm_change_state_handler() but passes a prepare_cb
  * and the cb_ret arguments too.
  */
+/*
+ * 在以下使用qdev_add_vm_change_state_handler_full():
+ *   - hw/core/vm-change-state-handler.c|64| <<qdev_add_vm_change_state_handler>>
+ *       return qdev_add_vm_change_state_handler_full(dev, cb, NULL, cb_ret, opaque);
+ *   - hw/vfio/migration.c|1037| <<vfio_migration_init>> migration->vm_state =
+ *       qdev_add_vm_change_state_handler_full(vbasedev->dev, vfio_vmstate_change,
+ *       prepare_cb, NULL, vbasedev);
+ */
 VMChangeStateEntry *qdev_add_vm_change_state_handler_full(
     DeviceState *dev, VMChangeStateHandler *cb, VMChangeStateHandler *prepare_cb,
     VMChangeStateHandlerWithRet *cb_ret, void *opaque)
@@ -75,6 +100,13 @@ VMChangeStateEntry *qdev_add_vm_change_state_handler_full(
     int depth = qdev_get_dev_tree_depth(dev);
 
     assert(!cb || !cb_ret);
+    /*
+     * 在以下使用qemu_add_vm_change_state_handler_prio_full():
+     *   - hw/core/vm-change-state-handler.c|78| <<qdev_add_vm_change_state_handler_full>>
+     *        return qemu_add_vm_change_state_handler_prio_full(cb, prepare_cb, cb_ret, opaque, depth);
+     *   - system/runstate.c|455| <<qemu_add_vm_change_state_handler_prio>>
+     *        return qemu_add_vm_change_state_handler_prio_full(cb, NULL, NULL, opaque, priority);
+     */
     return qemu_add_vm_change_state_handler_prio_full(cb, prepare_cb, cb_ret,
                                                       opaque, depth);
 }
diff --git a/hw/display/vga.c b/hw/display/vga.c
index 90b89cf40..ac691316b 100644
--- a/hw/display/vga.c
+++ b/hw/display/vga.c
@@ -1462,6 +1462,15 @@ static bool vga_scanline_invalidated(VGACommonState *s, int y)
     return s->invalidated_y_table[y >> 5] & (1 << (y & 0x1f));
 }
 
+/*
+ * 在以下使用vga_dirty_log_start():
+ *   - hw/display/qxl.c|1179| <<qxl_enter_vga_mode>> vga_dirty_log_start(&d->vga);
+ *   - hw/display/qxl.c|2166| <<qxl_realize_common>> vga_dirty_log_start(&qxl->vga);
+ *   - hw/display/vga.c|2270| <<vga_common_init>> vga_dirty_log_start(s);
+ *   - hw/display/virtio-vga.c|195| <<virtio_vga_base_reset_hold>> vga_dirty_log_start(&vvga->vga);
+ *   - hw/display/vmware_vga.c|1011| <<vmsvga_value_write>> vga_dirty_log_start(&s->vga);
+ *   - hw/display/vmware_vga.c|1172| <<vmsvga_reset>> vga_dirty_log_start(&s->vga);
+ */
 void vga_dirty_log_start(VGACommonState *s)
 {
     memory_region_set_log(&s->vram, true, DIRTY_MEMORY_VGA);
diff --git a/hw/i386/kvm/apic.c b/hw/i386/kvm/apic.c
index 1be9bfe36..dbd7faa3e 100644
--- a/hw/i386/kvm/apic.c
+++ b/hw/i386/kvm/apic.c
@@ -31,6 +31,10 @@ static inline uint32_t kvm_apic_get_reg(struct kvm_lapic_state *kapic,
     return *((uint32_t *)(kapic->regs + (reg_id << 4)));
 }
 
+/*
+ * 在以下使用kvm_put_apic_state():
+ *   - hw/i386/kvm/apic.c|163| <<kvm_apic_put>> kvm_put_apic_state(s, &kapic);
+ */
 static void kvm_put_apic_state(APICCommonState *s, struct kvm_lapic_state *kapic)
 {
     int i;
@@ -60,6 +64,10 @@ static void kvm_put_apic_state(APICCommonState *s, struct kvm_lapic_state *kapic
     kvm_apic_set_reg(kapic, 0x3e, s->divide_conf);
 }
 
+/*
+ * 在以下使用kvm_get_apic_state():
+ *   - target/i386/kvm/kvm.c|5128| <<kvm_get_apic>> kvm_get_apic_state(apic, &kapic);
+ */
 void kvm_get_apic_state(DeviceState *dev, struct kvm_lapic_state *kapic)
 {
     APICCommonState *s = APIC_COMMON(dev);
@@ -96,6 +104,18 @@ void kvm_get_apic_state(DeviceState *dev, struct kvm_lapic_state *kapic)
     apic_next_timer(s, s->initial_count_load_time);
 }
 
+/*
+ * 在以下使用APICCommonClass->set_base:
+ *   - hw/i386/kvm/apic.c|268| <<kvm_apic_class_init>> k->set_base = kvm_apic_set_base;
+ *   - hw/i386/xen/xen_apic.c|84| <<xen_apic_class_init>> k->set_base = xen_apic_set_base;
+ *   - hw/intc/apic.c|1185| <<apic_class_init>> k->set_base = apic_set_base;
+ *   - hw/intc/apic_common.c|47| <<cpu_set_apic_base>> return info->set_base(s, val);
+ *   - target/i386/whpx/whpx-apic.c|261| <<whpx_apic_class_init>> k->set_base = whpx_apic_set_base;
+ *
+ *
+ * 在以下使用kvm_apic_set_base():
+ *   - hw/i386/kvm/apic.c|268| <<kvm_apic_class_init>> k->set_base = kvm_apic_set_base;
+ */
 static int kvm_apic_set_base(APICCommonState *s, uint64_t val)
 {
     s->apicbase = val;
@@ -121,6 +141,19 @@ static void kvm_apic_enable_tpr_reporting(APICCommonState *s, bool enable)
     kvm_vcpu_ioctl(CPU(s->cpu), KVM_TPR_ACCESS_REPORTING, &ctl);
 }
 
+/*
+ * 在以下使用APICCommonClass->vapic_base_update:
+ *   - hw/i386/kvm/apic.c|260| <<kvm_apic_class_init>> k->vapic_base_update = kvm_apic_vapic_base_update;
+ *   - hw/i386/xen/xen_apic.c|87| <<xen_apic_class_init>> k->vapic_base_update = xen_apic_vapic_base_update;
+ *   - hw/intc/apic.c|1188| <<apic_class_init>> k->vapic_base_update = apic_vapic_base_update;
+ *   - hw/intc/apic_common.c|125| <<apic_enable_vapic>> info->vapic_base_update(s);
+ *   - hw/intc/apic_common.c|263| <<apic_reset_common>> info->vapic_base_update(s);
+ *   - target/i386/whpx/whpx-apic.c|265| <<whpx_apic_class_init>> k->vapic_base_update = whpx_apic_vapic_base_update;
+ *
+ *
+ * 在以下使用kvm_apic_vapic_base_update():
+ *   - hw/i386/kvm/apic.c|260| <<kvm_apic_class_init>> k->vapic_base_update = kvm_apic_vapic_base_update;
+ */
 static void kvm_apic_vapic_base_update(APICCommonState *s)
 {
     struct kvm_vapic_addr vapid_addr = {
@@ -136,6 +169,11 @@ static void kvm_apic_vapic_base_update(APICCommonState *s)
     }
 }
 
+/*
+ * 在以下使用kvm_apic_put():
+ *   - hw/i386/kvm/apic.c|174| <<kvm_apic_post_load>> run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
+ *   - hw/i386/kvm/apic.c|243| <<kvm_apic_reset>> run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
+ */
 static void kvm_apic_put(CPUState *cs, run_on_cpu_data data)
 {
     APICCommonState *s = data.host_ptr;
@@ -146,7 +184,13 @@ static void kvm_apic_put(CPUState *cs, run_on_cpu_data data)
         return;
     }
 
+    /*
+     * 只在这里调用kvm_put_apicbase()
+     */
     kvm_put_apicbase(s->cpu, s->apicbase);
+    /*
+     * 只在这里调用kvm_put_apic_state()
+     */
     kvm_put_apic_state(s, &kapic);
 
     ret = kvm_vcpu_ioctl(CPU(s->cpu), KVM_SET_LAPIC, &kapic);
@@ -222,6 +266,74 @@ static const MemoryRegionOps kvm_apic_io_ops = {
     .endianness = DEVICE_LITTLE_ENDIAN,
 };
 
+/*
+ * (gdb) bt
+ * #0  kvm_apic_reset (s=0x555557618000) at ../hw/i386/kvm/apic.c:221 
+ * #1  0x0000555555e4b64b in apic_init_reset (dev=0x555557618000) at ../hw/intc/apic_common.c:232 
+ * #2  0x0000555555e4b76a in apic_reset_common (dev=0x555557618000) at ../hw/intc/apic_common.c:265
+ * #3  0x0000555555f1eca5 in do_legacy_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/qdev.c:776
+ * #4  0x0000555555f20bad in resettable_phase_hold (obj=0x555557618000, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #5  0x0000555555f207b1 in resettable_assert_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #6  0x0000555555f20709 in resettable_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #7  0x0000555555f1d762 in device_cold_reset (dev=0x555557618000) at ../hw/core/qdev.c:239
+ * #8  0x0000555555da9303 in x86_cpu_after_reset (cpu=0x5555577517f0) at ../target/i386/cpu.c:7621
+ * #9  0x0000555555d7ec7e in pc_machine_reset (machine=0x5555576d8c50, type=RESET_TYPE_COLD) at ../hw/i386/pc.c:1735
+ * #10 0x0000555555c2d38f in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at ../system/runstate.c:525
+ * #11 0x000055555597da2f in qdev_machine_creation_done () at ../hw/core/machine.c:1763
+ * #12 0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #13 0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #14 0x0000555555c38346 in qemu_init (argc=21, argv=0x7fffffffdc28) at ../system/vl.c:3843
+ * #15 0x00005555560d2905 in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  kvm_apic_reset (s=0x555557549400) at ../hw/i386/kvm/apic.c:221
+ * #1  0x0000555555e4b64b in apic_init_reset (dev=0x555557549400) at ../hw/intc/apic_common.c:232
+ * #2  0x0000555555e4b76a in apic_reset_common (dev=0x555557549400) at ../hw/intc/apic_common.c:265
+ * #3  0x0000555555f1eca5 in do_legacy_reset (obj=0x555557549400, type=RESET_TYPE_COLD) at ../hw/core/qdev.c:776
+ * #4  0x0000555555f20bad in resettable_phase_hold (obj=0x555557549400, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #5  0x0000555555f207b1 in resettable_assert_reset (obj=0x555557549400, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #6  0x0000555555f1e3c6 in device_set_realized (obj=0x555557549400, value=true, errp=0x7fffffffc318) at ../hw/core/qdev.c:543
+ * #7  0x0000555555f29192 in property_set_bool (obj=0x555557549400, v=0x555557fd25f0, name=0x5555563e9969 "realized", opaque=0x555557460d40, errp=0x7fffffffc318)
+ *     at ../qom/object.c:2374
+ * #8  0x0000555555f26c07 in object_property_set (obj=0x555557549400, name=0x5555563e9969 "realized", v=0x555557fd25f0, errp=0x7fffffffc318) at ../qom/object.c:1449
+ * #9  0x0000555555f2ba94 in object_property_set_qobject (obj=0x555557549400, name=0x5555563e9969 "realized", value=0x5555582f1b20, errp=0x7fffffffc318) at ../qom/qom-qobject.c:28
+ * #10 0x0000555555f26fac in object_property_set_bool (obj=0x555557549400, name=0x5555563e9969 "realized", value=true, errp=0x7fffffffc318) at ../qom/object.c:1519
+ * #11 0x0000555555f1d90b in qdev_realize (dev=0x555557549400, bus=0x0, errp=0x7fffffffc318) at ../hw/core/qdev.c:276
+ * #12 0x0000555555d1a6b6 in x86_cpu_apic_realize (cpu=0x55555775f620, errp=0x7fffffffc318) at ../target/i386/cpu-apic.c:77
+ * #13 0x0000555555daafa3 in x86_cpu_realizefn (dev=0x55555775f620, errp=0x7fffffffc3e0) at ../target/i386/cpu.c:8355
+ * #14 0x0000555555da3bf3 in max_x86_cpu_realize (dev=0x55555775f620, errp=0x7fffffffc3e0) at ../target/i386/cpu.c:5689
+ * #15 0x0000555555f1e213 in device_set_realized (obj=0x55555775f620, value=true, errp=0x7fffffffc700) at ../hw/core/qdev.c:494
+ * #16 0x0000555555f29192 in property_set_bool (obj=0x55555775f620, v=0x5555582e4a30, name=0x5555563e9969 "realized", opaque=0x555557460d40, errp=0x7fffffffc700)
+ *     at ../qom/object.c:2374
+ * #17 0x0000555555f26c07 in object_property_set (obj=0x55555775f620, name=0x5555563e9969 "realized", v=0x5555582e4a30, errp=0x7fffffffc700) at ../qom/object.c:1449
+ * #18 0x0000555555f2ba94 in object_property_set_qobject (obj=0x55555775f620, name=0x5555563e9969 "realized", value=0x5555576e9580, errp=0x7fffffffc700) at ../qom/qom-qobject.c:28
+ * #19 0x0000555555f26fac in object_property_set_bool (obj=0x55555775f620, name=0x5555563e9969 "realized", value=true, errp=0x7fffffffc700) at ../qom/object.c:1519
+ * #20 0x0000555555f1d90b in qdev_realize (dev=0x55555775f620, bus=0x0, errp=0x7fffffffc700) at ../hw/core/qdev.c:276
+ * #21 0x0000555555c26632 in qdev_device_add_from_qdict (opts=0x555557fd15d0, from_json=false, errp=0x7fffffffc700) at ../system/qdev-monitor.c:714
+ * #22 0x0000555555c266e6 in qdev_device_add (opts=0x5555580f96a0, errp=0x7fffffffc700) at ../system/qdev-monitor.c:733
+ * #23 0x0000555555c2730b in hmp_device_add (mon=0x5555576efc20, qdict=0x5555577b5400) at ../system/qdev-monitor.c:994
+ * #24 0x0000555555c9118f in handle_hmp_command_exec (mon=0x5555576efc20, cmd=0x5555572ac020 <hmp_cmds+1920>, qdict=0x5555577b5400) at ../monitor/hmp.c:1106
+ * #25 0x0000555555c913da in handle_hmp_command (mon=0x5555576efc20, cmdline=0x555557711d7c "host-x86_64-cpu,id=core2,socket-id=0,core-id=2,thread-id=0") at ../monitor/hmp.c:1158
+ * #26 0x0000555555c8e45f in monitor_command_cb (opaque=0x5555576efc20, cmdline=0x555557711d70 " device_add host-x86_64-cpu,id=core2,socket-id=0,core-id=2,thread-id=0",
+ *     readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #27 0x00005555561de895 in readline_handle_byte (rs=0x555557711d70, ch=13) at ../util/readline.c:427
+ * #28 0x0000555555c92031 in monitor_read (opaque=0x5555576efc20, buf=0x7fffffffc970 "\r", size=1) at ../monitor/hmp.c:1390
+ * #29 0x00005555560c7d61 in qemu_chr_be_write_impl (s=0x55555758df40, buf=0x7fffffffc970 "\r", len=1) at ../chardev/char.c:214
+ * #30 0x00005555560c7dd2 in qemu_chr_be_write (s=0x55555758df40, buf=0x7fffffffc970 "\r", len=1) at ../chardev/char.c:226
+ * #31 0x00005555560cadf1 in fd_chr_read (chan=0x5555576d6a00, cond=G_IO_IN, opaque=0x55555758df40) at ../chardev/char-fd.c:72
+ * #32 0x0000555555f8f8d0 in qio_channel_fd_source_dispatch (source=0x555557e71390, callback=0x5555560cac95 <fd_chr_read>, user_data=0x55555758df40) at ../io/channel-watch.c:84
+ * #33 0x00007ffff6fd3854 in g_main_dispatch (context=0x55555745e9e0) at ../glib/gmain.c:3325
+ * #34 g_main_context_dispatch (context=0x55555745e9e0) at ../glib/gmain.c:4043
+ * #35 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #36 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=964283) at ../util/main-loop.c:310
+ * #37 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #38 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #39 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #40 0x00005555560d296f in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:80
+ *
+ * 在以下使用kvm_apic_reset():
+ *   - hw/i386/kvm/apic.c|292| <<kvm_apic_class_init>> k->reset = kvm_apic_reset;
+ */
 static void kvm_apic_reset(APICCommonState *s)
 {
     /* Not used by KVM, which uses the CPU mp_state instead.  */
@@ -252,7 +364,24 @@ static void kvm_apic_class_init(ObjectClass *klass, const void *data)
     k->realize = kvm_apic_realize;
     k->unrealize = kvm_apic_unrealize;
     k->reset = kvm_apic_reset;
+    /*
+     * 在以下使用APICCommonClass->set_base:
+     *   - hw/i386/kvm/apic.c|268| <<kvm_apic_class_init>> k->set_base = kvm_apic_set_base;
+     *   - hw/i386/xen/xen_apic.c|84| <<xen_apic_class_init>> k->set_base = xen_apic_set_base;
+     *   - hw/intc/apic.c|1185| <<apic_class_init>> k->set_base = apic_set_base;
+     *   - hw/intc/apic_common.c|47| <<cpu_set_apic_base>> return info->set_base(s, val);
+     *   - target/i386/whpx/whpx-apic.c|261| <<whpx_apic_class_init>> k->set_base = whpx_apic_set_base;
+     */
     k->set_base = kvm_apic_set_base;
+    /*
+     * 在以下使用APICCommonClass->vapic_base_update:
+     *   - hw/i386/kvm/apic.c|260| <<kvm_apic_class_init>> k->vapic_base_update = kvm_apic_vapic_base_update;
+     *   - hw/i386/xen/xen_apic.c|87| <<xen_apic_class_init>> k->vapic_base_update = xen_apic_vapic_base_update;
+     *   - hw/intc/apic.c|1188| <<apic_class_init>> k->vapic_base_update = apic_vapic_base_update;
+     *   - hw/intc/apic_common.c|125| <<apic_enable_vapic>> info->vapic_base_update(s);
+     *   - hw/intc/apic_common.c|263| <<apic_reset_common>> info->vapic_base_update(s);
+     *   - target/i386/whpx/whpx-apic.c|265| <<whpx_apic_class_init>> k->vapic_base_update = whpx_apic_vapic_base_update;
+     */
     k->set_tpr = kvm_apic_set_tpr;
     k->get_tpr = kvm_apic_get_tpr;
     k->post_load = kvm_apic_post_load;
diff --git a/hw/i386/kvm/clock.c b/hw/i386/kvm/clock.c
index f56382717..1212cd5bb 100644
--- a/hw/i386/kvm/clock.c
+++ b/hw/i386/kvm/clock.c
@@ -38,16 +38,35 @@ struct KVMClockState {
     /*< public >*/
 
     uint64_t clock;
+    /*
+     * 在以下使用KVMClockState->clock_valid:
+     *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+     *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+     *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+     */
     bool clock_valid;
 
     /* whether the 'clock' value was obtained in the 'paused' state */
     bool runstate_paused;
 
+    /*
+     * 在以下使用KVMClockState->mach_use_reliable_get_clock:
+     *    - hw/i386/kvm/clock.c|726| <<global>> DEFINE_PROP_BOOL("x-mach-use-reliable-get-clock", KVMClockState,
+     *                                            mach_use_reliable_get_clock, true),
+     *    - hw/i386/kvm/clock.c|602| <<kvmclock_clock_is_reliable_needed>> return s->mach_use_reliable_get_clock;
+     */
     /* whether machine type supports reliable KVM_GET_CLOCK */
     bool mach_use_reliable_get_clock;
 
     /* whether the 'clock' value was obtained in a host with
      * reliable KVM_GET_CLOCK */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     bool clock_is_reliable;
 };
 
@@ -62,6 +81,12 @@ struct pvclock_vcpu_time_info {
     uint8_t    pad[2];
 } __attribute__((__packed__)); /* 32 bytes */
 
+/*
+ * 在以下使用kvmclock_current_nsec():
+ *   - hw/i386/kvm/clock.c|376| <<kvmclock_vm_state_change>> uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
+ *
+ * 读取vCPU 0的PVTI, 用env->tsc计算时间
+ */
 static uint64_t kvmclock_current_nsec(KVMClockState *s)
 {
     CPUState *cpu = first_cpu;
@@ -74,8 +99,19 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     uint64_t nsec_hi;
     uint64_t nsec;
 
+    /*
+     * 相当于kvm_arch_get_registers()
+     */
     cpu_synchronize_state(cpu);
 
+    /*
+     * 在以下使用CPUX86State->system_time_msr:
+     *   - target/i386/machine.c|1738| <<vmstate_x86_cpu>> VMSTATE_UINT64(env.system_time_msr, X86CPU),
+     *   - hw/i386/kvm/clock.c|96| <<kvmclock_current_nsec>> if (!(env->system_time_msr & 1ULL)) {
+     *   - hw/i386/kvm/clock.c|101| <<kvmclock_current_nsec>> kvmclock_struct_pa = env->system_time_msr & ~1ULL;
+     *   - target/i386/kvm/kvm.c|4058| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
+     *   - target/i386/kvm/kvm.c|4826| <<kvm_get_msrs>> env->system_time_msr = msrs[i].data;
+     */
     if (!(env->system_time_msr & 1ULL)) {
         /* KVM clock not active */
         return 0;
@@ -97,11 +133,81 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     return nsec + time.system_time;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用kvm_update_clock():
+ *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+ */
 static void kvm_update_clock(KVMClockState *s)
 {
+    /*
+     * struct kvm_clock_data {
+     *     __u64 clock;
+     *     __u32 flags;
+     *     __u32 pad0;
+     *     __u64 realtime;
+     *     __u64 host_tsc;
+     *     __u32 pad[4];
+     * };
+     */
     struct kvm_clock_data data;
     int ret;
 
+    /*
+     * 在两个地方使用KVM_GET_CLOCK:
+     *   - hw/i386/kvm/clock.c|200| <<kvm_update_clock>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     *   - target/i386/kvm/xen-emu.c|992| <<kvm_get_current_ns>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     */
     ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
     if (ret < 0) {
         fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(-ret));
@@ -148,9 +254,119 @@ static void kvm_update_clock(KVMClockState *s)
      *       if !kvm_has_adjust_clock_stable() then
      *               read from memory
      */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     s->clock_is_reliable = kvm_has_adjust_clock_stable();
 }
 
+/*
+ * 创建的时候这个调用一次.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ * 这个调用#vCPU次.
+ *
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x5555578c3250, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c3250) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c3250) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c3250) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c3250) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555578cd7d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 
+ * 迁移到文件的时候.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 从文件迁移到VM.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ * 然后下面调用#vCPU次.
+ *
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x5555578c3250, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c3250) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c3250) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c3250) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c3250) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555578cd7d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 从QEMU quit的时候
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_SHUTDOWN) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_SHUTDOWN) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_SHUTDOWN, send_stop=false) at ../system/cpus.c:300
+ * #3  0x0000555555c08bec in vm_shutdown () at ../system/cpus.c:322
+ * #4  0x0000555555c38ee9 in qemu_cleanup (status=0) at ../system/runstate.c:981
+ * #5  0x00005555560829d2 in qemu_default_main (opaque=0x0) at ../system/main.c:51
+ * #6  0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ */
+/*
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x55555790c330, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x55555790c330) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x55555790c330) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x55555790c330) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x55555790c330) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555579159d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用do_kvmclock_ctrl():
+ *   - hw/i386/kvm/clock.c|239| <<kvmclock_vm_state_change>> run_on_cpu(cpu, do_kvmclock_ctrl, RUN_ON_CPU_NULL);
+ */
 static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
 {
     int ret = kvm_vcpu_ioctl(cpu, KVM_KVMCLOCK_CTRL, 0);
@@ -160,6 +376,109 @@ static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
     }
 }
 
+/*
+ * 启动的时候
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e2f in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d3a in vm_prepare_start (step_pending=false) at ../system/cpus.c:780
+ * #3  0x0000555555c09d75 in vm_start () at ../system/cpus.c:787
+ * #4  0x0000555555c8be6d in qmp_cont (errp=0x7fffffffc750) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c86052 in hmp_cont (mon=0x5555578622a0, qdict=0x555558142820) at ../monitor/hmp-cmds.c:145
+ * #6  0x0000555555c89d89 in handle_hmp_command_exec (mon=0x5555578622a0, cmd=0x55555742d8b0 <hmp_cmds+1680>, qdict=0x555558142820) at ../monitor/hmp.c:1106
+ * #7  0x0000555555c89fd4 in handle_hmp_command (mon=0x5555578622a0, cmdline=0x555557883d74 "") at ../monitor/hmp.c:1158
+ * #8  0x0000555555c87059 in monitor_command_cb (opaque=0x5555578622a0, cmdline=0x555557883d70 "cont", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #9  0x0000555556185448 in readline_handle_byte (rs=0x555557883d70, ch=13) at ../util/readline.c:427
+ * #10 0x0000555555c8ac2b in monitor_read (opaque=0x5555578622a0, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", size=1) at ../monitor/hmp.c:1390
+ * #11 0x0000555556078410 in qemu_chr_be_write_impl (s=0x55555773e300, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:214
+ * #12 0x0000555556078481 in qemu_chr_be_write (s=0x55555773e300, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:226
+ * #13 0x000055555607b483 in fd_chr_read (chan=0x55555783fdc0, cond=G_IO_IN, opaque=0x55555773e300) at ../chardev/char-fd.c:72
+ * #14 0x0000555555f4a47a in qio_channel_fd_source_dispatch (source=0x555558455a20, callback=0x55555607b344 <fd_chr_read>, user_data=0x55555773e300)
+ *     at ../io/channel-watch.c:84
+ * #15 0x00007ffff6fd3854 in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #17 0x0000555556172240 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561722ce in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:310
+ * #19 0x00005555561723fd in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c38d08 in qemu_main_loop () at ../system/runstate.c:905
+ * #21 0x0000555556082abe in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x0000555556082b78 in main (argc=22, argv=0x7fffffffdc68) at ../system/main.c:93
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ *
+ * 迁移的时候在Source上的调用:
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 迁移的时候在Target上的调用:
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ *
+ * 这是迁移在Target上的.
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x5555582b37e0) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用kvmclock_vm_state_change():
+ *   - hw/i386/kvm/clock.c|284| <<kvmclock_realize>> qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
+ */
 static void kvmclock_vm_state_change(void *opaque, bool running,
                                      RunState state)
 {
@@ -171,11 +490,22 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
     if (running) {
         struct kvm_clock_data data = {};
 
+        /*
+	 * 在以下使用KVMClockState->clock_is_reliable:
+         *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+         *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+         *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+         *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+	 */
         /*
          * If the host where s->clock was read did not support reliable
          * KVM_GET_CLOCK, read kvmclock value from memory.
          */
         if (!s->clock_is_reliable) {
+            /*
+	     * 只在这里调用kvmclock_current_nsec()
+	     * 读取vCPU 0的PVTI, 用env->tsc计算时间
+	     */
             uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
             /* We can't rely on the saved clock value, just discard it */
             if (pvclock_via_mem) {
@@ -183,9 +513,18 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
             }
         }
 
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         s->clock_valid = false;
 
         data.clock = s->clock;
+        /*
+	 * 只在这一个地方调用KVM_SET_CLOCK
+	 */
         ret = kvm_vm_ioctl(kvm_state, KVM_SET_CLOCK, &data);
         if (ret < 0) {
             fprintf(stderr, "KVM_SET_CLOCK failed: %s\n", strerror(-ret));
@@ -200,20 +539,44 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
         }
     } else {
 
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+	 *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+	 *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+	 *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         if (s->clock_valid) {
             return;
         }
 
         s->runstate_paused = runstate_check(RUN_STATE_PAUSED);
 
+	/*
+	 * 只在这里调用
+	 * get MSR_IA32_TSC
+	 */
         kvm_synchronize_all_tsc();
 
+        /*
+	 * 在以下使用kvm_update_clock():
+	 *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+	 *
+	 * KVM_GET_CLOCK
+	 */
         kvm_update_clock(s);
         /*
          * If the VM is stopped, declare the clock state valid to
          * avoid re-reading it on next vmsave (which would return
          * a different value). Will be reset when the VM is continued.
          */
+	/*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         s->clock_valid = true;
     }
 }
@@ -227,6 +590,12 @@ static void kvmclock_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用kvm_update_clock():
+     *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+     *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+     *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+     */
     kvm_update_clock(s);
 
     qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
@@ -258,11 +627,54 @@ static int kvmclock_pre_load(void *opaque)
 {
     KVMClockState *s = opaque;
 
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     s->clock_is_reliable = false;
 
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x55555790d7e0, 
+ *     version_id=1, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, 
+ *     vmdesc_id=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x555557dad630, se=0x555557902320, vmdesc=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x555557dad630, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:282
+ * #1  0x0000555555f40775 in vmstate_save_state_v (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x55555790d7e0,
+ *     version_id=1, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:407
+ * #2  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:395
+ * #3  0x0000555555c79ef9 in vmstate_save (f=0x555557dad630, se=0x555557902320, vmdesc=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/savevm.c:1052
+ * #4  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x555557dad630, in_postcopy=false) at ../migration/savevm.c:1669
+ * #5  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1712
+ * #6  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 /*
  * When migrating a running guest, read the clock just
  * before migration, so that the guest clock counts
@@ -282,12 +694,22 @@ static int kvmclock_pre_save(void *opaque)
     KVMClockState *s = opaque;
 
     if (!s->runstate_paused) {
+        /*
+	 * 在以下使用kvm_update_clock():
+	 *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+	 */
         kvm_update_clock(s);
     }
 
     return 0;
 }
 
+/*
+ * 在以下使用kvmclock_vmsd:
+ *   - hw/i386/kvm/clock.c|664| <<kvmclock_class_init>> dc->vmsd = &kvmclock_vmsd;
+ */
 static const VMStateDescription kvmclock_vmsd = {
     .name = "kvmclock",
     .version_id = 1,
@@ -325,6 +747,12 @@ static const TypeInfo kvmclock_info = {
     .class_init    = kvmclock_class_init,
 };
 
+/*
+ * 在以下使用kvmclock_create():
+ *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+ *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+ *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+ */
 /* Note: Must be called after VCPU initialization. */
 void kvmclock_create(bool create_always)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 2f58e73d3..fa7ee73be 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1712,6 +1712,16 @@ static void pc_machine_reset(MachineState *machine, ResetType type)
 
 static void pc_machine_wakeup(MachineState *machine)
 {
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
     pc_machine_reset(machine, RESET_TYPE_WAKEUP);
     cpu_synchronize_all_post_reset();
@@ -1751,6 +1761,14 @@ static void pc_machine_class_init(ObjectClass *oc, const void *data)
     pcmc->enforce_amd_1tb_hole = true;
     pcmc->isa_bios_alias = true;
     pcmc->pvh_enabled = true;
+    /*
+     * 在以下使用PCMachineClass->kvmclock_create_always:
+     *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+     *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     */
     pcmc->kvmclock_create_always = true;
     x86mc->apic_xrupt_override = true;
     assert(!mc->get_hotplug_handler);
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index c03324281..89a629ca8 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -193,6 +193,14 @@ static void pc_init1(MachineState *machine, const char *pci_type)
     x86_cpus_init(x86ms, pcmc->default_cpu_version);
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用PCMachineClass->kvmclock_create_always:
+         *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+         *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+         *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+         *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+         *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+	 */
         kvmclock_create(pcmc->kvmclock_create_always);
     }
 
@@ -666,6 +674,14 @@ static void pc_i440fx_machine_5_1_options(MachineClass *m)
     pc_i440fx_machine_5_2_options(m);
     compat_props_add(m->compat_props, hw_compat_5_1, hw_compat_5_1_len);
     compat_props_add(m->compat_props, pc_compat_5_1, pc_compat_5_1_len);
+    /*
+     * 在以下使用PCMachineClass->kvmclock_create_always:
+     *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+     *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     */
     pcmc->kvmclock_create_always = false;
     pcmc->pci_root_uid = 1;
 }
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index b309b2b37..ae27377d8 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -194,6 +194,14 @@ static void pc_q35_init(MachineState *machine)
     x86_cpus_init(x86ms, pcmc->default_cpu_version);
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用PCMachineClass->kvmclock_create_always:
+         *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+         *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+         *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+         *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+         *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+	 */
         kvmclock_create(pcmc->kvmclock_create_always);
     }
 
@@ -532,6 +540,14 @@ static void pc_q35_machine_5_1_options(MachineClass *m)
     pc_q35_machine_5_2_options(m);
     compat_props_add(m->compat_props, hw_compat_5_1, hw_compat_5_1_len);
     compat_props_add(m->compat_props, pc_compat_5_1, pc_compat_5_1_len);
+    /*
+     * 在以下使用PCMachineClass->kvmclock_create_always:
+     *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+     *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     */
     pcmc->kvmclock_create_always = false;
     pcmc->pci_root_uid = 1;
 }
diff --git a/hw/i386/vapic.c b/hw/i386/vapic.c
index 0c1c92c47..d1c49aa4f 100644
--- a/hw/i386/vapic.c
+++ b/hw/i386/vapic.c
@@ -363,6 +363,12 @@ static int get_kpcr_number(X86CPU *cpu)
     return kpcr.number;
 }
 
+/*
+ * 在以下使用vapic_enable():
+ *   - hw/i386/vapic.c|479| <<vapic_report_tpr_access>> vapic_enable(s, cpu);
+ *   - hw/i386/vapic.c|486| <<vapic_report_tpr_access>> if (vapic_enable(s, cpu) < 0) {
+ *   - hw/i386/vapic.c|703| <<vapic_write>> vapic_enable(s, cpu);
+ */
 static int vapic_enable(VAPICROMState *s, X86CPU *cpu)
 {
     int cpu_number = get_kpcr_number(cpu);
@@ -376,6 +382,11 @@ static int vapic_enable(VAPICROMState *s, X86CPU *cpu)
         (((hwaddr)cpu_number) << VAPIC_CPU_SHIFT);
     cpu_physical_memory_write(vapic_paddr + offsetof(VAPICState, enabled),
                               &enabled, sizeof(enabled));
+    /*
+     * 在以下使用apic_enable_vapic():
+     *   - hw/i386/vapic.c|385| <<vapic_enable>> apic_enable_vapic(cpu->apic_state, vapic_paddr);
+     *   - hw/i386/vapic.c|753| <<do_vapic_enable>> apic_enable_vapic(cpu->apic_state, s->vapic_paddr);
+     */
     apic_enable_vapic(cpu->apic_state, vapic_paddr);
 
     s->state = VAPIC_ACTIVE;
@@ -465,6 +476,10 @@ static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)
     async_safe_run_on_cpu(cs, do_patch_instruction, RUN_ON_CPU_HOST_PTR(info));
 }
 
+/*
+ * 在以下使用vapic_report_tpr_access():
+ *   - hw/intc/apic_common.c|147| <<apic_handle_tpr_access_report>> vapic_report_tpr_access(s->vapic, CPU(s->cpu), ip, access);
+ */
 void vapic_report_tpr_access(DeviceState *dev, CPUState *cs, target_ulong ip,
                              TPRAccess access)
 {
@@ -729,6 +744,14 @@ static void vapic_realize(DeviceState *dev, Error **errp)
 
     memory_region_init_io(&s->io, OBJECT(s), &vapic_ops, s, "kvmvapic", 2);
     memory_region_add_subregion(get_system_io(), VAPIC_IO_PORT, &s->io);
+    /*
+     * 在以下使用sysbus_init_ioports():
+     *   - hw/i386/vapic.c|742| <<vapic_realize>> sysbus_init_ioports(sbd, VAPIC_IO_PORT, 2);
+     *   - hw/pci-host/i440fx.c|261| <<i440fx_pcihost_realize>> sysbus_init_ioports(sbd, 0xcf8, 4);
+     *   - hw/pci-host/i440fx.c|264| <<i440fx_pcihost_realize>> sysbus_init_ioports(sbd, 0xcfc, 4);
+     *   - hw/pci-host/q35.c|55| <<q35_host_realize>> sysbus_init_ioports(sbd, MCH_HOST_BRIDGE_CONFIG_ADDR, 4);
+     *   - hw/pci-host/q35.c|59| <<q35_host_realize>> sysbus_init_ioports(sbd, MCH_HOST_BRIDGE_CONFIG_DATA, 4);
+     */
     sysbus_init_ioports(sbd, VAPIC_IO_PORT, 2);
 
     option_rom[nb_option_roms].name = "kvmvapic.bin";
@@ -736,6 +759,10 @@ static void vapic_realize(DeviceState *dev, Error **errp)
     nb_option_roms++;
 }
 
+/*
+ * 在以下使用do_vapic_enable():
+ *   - hw/i386/vapic.c|769| <<vapic_vm_state_change>> run_on_cpu(first_cpu, do_vapic_enable, RUN_ON_CPU_HOST_PTR(s));
+ */
 static void do_vapic_enable(CPUState *cs, run_on_cpu_data data)
 {
     VAPICROMState *s = data.host_ptr;
@@ -748,6 +775,10 @@ static void do_vapic_enable(CPUState *cs, run_on_cpu_data data)
     s->state = VAPIC_ACTIVE;
 }
 
+/*
+ * 在以下使用vapic_vm_state_change():
+ *   - hw/i386/vapic.c|802| <<vapic_post_load>> qemu_add_vm_change_state_handler(vapic_vm_state_change, s);
+ */
 static void vapic_vm_state_change(void *opaque, bool running, RunState state)
 {
     MachineState *ms = MACHINE(qdev_get_machine());
@@ -773,6 +804,24 @@ static void vapic_vm_state_change(void *opaque, bool running, RunState state)
     s->vmsentry = NULL;
 }
 
+/*
+ * 847 static const VMStateDescription vmstate_vapic = {
+ * 848     .name = "kvm-tpr-opt",      // compatible with qemu-kvm VAPIC
+ * 849     .version_id = 1,
+ * 850     .minimum_version_id = 1,
+ * 851     .post_load = vapic_post_load,
+ * 852     .fields = (const VMStateField[]) {
+ * 853         VMSTATE_STRUCT(rom_state, VAPICROMState, 0, vmstate_guest_rom,
+ * 854                        GuestROMState),
+ * 855         VMSTATE_UINT32(state, VAPICROMState),
+ * 856         VMSTATE_UINT32(real_tpr_addr, VAPICROMState),
+ * 857         VMSTATE_UINT32(rom_state_vaddr, VAPICROMState),
+ * 858         VMSTATE_UINT32(vapic_paddr, VAPICROMState),
+ * 859         VMSTATE_UINT32(rom_state_paddr, VAPICROMState),
+ * 860         VMSTATE_END_OF_LIST()
+ * 861     }
+ * 862 };
+ */
 static int vapic_post_load(void *opaque, int version_id)
 {
     VAPICROMState *s = opaque;
diff --git a/hw/intc/apic.c b/hw/intc/apic.c
index bcb103560..7d9978129 100644
--- a/hw/intc/apic.c
+++ b/hw/intc/apic.c
@@ -1185,6 +1185,15 @@ static void apic_class_init(ObjectClass *klass, const void *data)
     k->set_base = apic_set_base;
     k->set_tpr = apic_set_tpr;
     k->get_tpr = apic_get_tpr;
+    /*
+     * 在以下使用APICCommonClass->vapic_base_update:
+     *   - hw/i386/kvm/apic.c|260| <<kvm_apic_class_init>> k->vapic_base_update = kvm_apic_vapic_base_update;
+     *   - hw/i386/xen/xen_apic.c|87| <<xen_apic_class_init>> k->vapic_base_update = xen_apic_vapic_base_update;
+     *   - hw/intc/apic.c|1188| <<apic_class_init>> k->vapic_base_update = apic_vapic_base_update;
+     *   - hw/intc/apic_common.c|125| <<apic_enable_vapic>> info->vapic_base_update(s);
+     *   - hw/intc/apic_common.c|263| <<apic_reset_common>> info->vapic_base_update(s);
+     *   - target/i386/whpx/whpx-apic.c|265| <<whpx_apic_class_init>> k->vapic_base_update = whpx_apic_vapic_base_update;
+     */
     k->vapic_base_update = apic_vapic_base_update;
     k->external_nmi = apic_external_nmi;
     k->pre_save = apic_pre_save;
diff --git a/hw/intc/apic_common.c b/hw/intc/apic_common.c
index 37a7a7019..68bc169e6 100644
--- a/hw/intc/apic_common.c
+++ b/hw/intc/apic_common.c
@@ -35,6 +35,14 @@
 
 bool apic_report_tpr_access;
 
+/*
+ * 在以下使用cpu_set_apic_base():
+ *   - target/i386/hvf/hvf.c|630| <<hvf_simulate_wrmsr>> r = cpu_set_apic_base(cpu->apic_state, data);
+ *   - target/i386/kvm/kvm.c|5717| <<kvm_arch_post_run>> cpu_set_apic_base(x86_cpu->apic_state, run->apic_base);
+ *   - target/i386/nvmm/nvmm-all.c|620| <<nvmm_handle_wrmsr>> cpu_set_apic_base(x86_cpu->apic_state, val);
+ *   - target/i386/tcg/system/misc_helper.c|159| <<helper_wrmsr>> ret = cpu_set_apic_base(env_archcpu(env)->apic_state, val);
+ *   - target/i386/whpx/whpx-all.c|743| <<whpx_get_registers>> cpu_set_apic_base(x86_cpu->apic_state, vcpu->apic_base);
+ */
 int cpu_set_apic_base(DeviceState *dev, uint64_t val)
 {
     trace_cpu_set_apic_base(val);
@@ -116,15 +124,38 @@ void apic_enable_tpr_access_reporting(DeviceState *dev, bool enable)
     }
 }
 
+/*
+ * 在以下使用apic_enable_vapic():
+ *   - hw/i386/vapic.c|385| <<vapic_enable>> apic_enable_vapic(cpu->apic_state, vapic_paddr);
+ *   - hw/i386/vapic.c|753| <<do_vapic_enable>> apic_enable_vapic(cpu->apic_state, s->vapic_paddr);
+ */
 void apic_enable_vapic(DeviceState *dev, hwaddr paddr)
 {
     APICCommonState *s = APIC_COMMON(dev);
     APICCommonClass *info = APIC_COMMON_GET_CLASS(s);
 
     s->vapic_paddr = paddr;
+    /*
+     * 在以下使用APICCommonClass->vapic_base_update:
+     *   - hw/i386/kvm/apic.c|260| <<kvm_apic_class_init>> k->vapic_base_update = kvm_apic_vapic_base_update;
+     *   - hw/i386/xen/xen_apic.c|87| <<xen_apic_class_init>> k->vapic_base_update = xen_apic_vapic_base_update;
+     *   - hw/intc/apic.c|1188| <<apic_class_init>> k->vapic_base_update = apic_vapic_base_update;
+     *   - hw/intc/apic_common.c|125| <<apic_enable_vapic>> info->vapic_base_update(s);
+     *   - hw/intc/apic_common.c|263| <<apic_reset_common>> info->vapic_base_update(s);
+     *   - target/i386/whpx/whpx-apic.c|265| <<whpx_apic_class_init>> k->vapic_base_update = whpx_apic_vapic_base_update;
+     */
     info->vapic_base_update(s);
 }
 
+/*
+ * 在以下使用apic_handle_tpr_access_report():
+ *   - arget/i386/helper.c|559| <<cpu_report_tpr_access>> apic_handle_tpr_access_report(cpu->apic_state, eip, access);
+ *   - target/i386/hvf/x86hvf.c|456| <<hvf_process_events>> apic_handle_tpr_access_report(cpu->apic_state, env->eip,
+ *   - target/i386/kvm/kvm.c|5774| <<kvm_arch_process_async_events>> apic_handle_tpr_access_report(cpu->apic_state, env->eip,
+ *   - target/i386/kvm/kvm.c|5801| <<kvm_handle_tpr_access>> apic_handle_tpr_access_report(cpu->apic_state, run->tpr_access.rip,
+ *   - target/i386/nvmm/nvmm-all.c|715| <<nvmm_vcpu_loop>> apic_handle_tpr_access_report(x86_cpu->apic_state, env->eip,
+ *   - target/i386/whpx/whpx-all.c|1628| <<whpx_vcpu_process_async_events>> apic_handle_tpr_access_report(x86_cpu->apic_state, env->eip,
+ */
 void apic_handle_tpr_access_report(DeviceState *dev, target_ulong ip,
                                    TPRAccess access)
 {
@@ -260,6 +291,15 @@ static void apic_reset_common(DeviceState *dev)
     kvm_reset_irq_delivered();
 
     s->vapic_paddr = 0;
+    /*
+     * 在以下使用APICCommonClass->vapic_base_update:
+     *   - hw/i386/kvm/apic.c|260| <<kvm_apic_class_init>> k->vapic_base_update = kvm_apic_vapic_base_update;
+     *   - hw/i386/xen/xen_apic.c|87| <<xen_apic_class_init>> k->vapic_base_update = xen_apic_vapic_base_update;
+     *   - hw/intc/apic.c|1188| <<apic_class_init>> k->vapic_base_update = apic_vapic_base_update;
+     *   - hw/intc/apic_common.c|125| <<apic_enable_vapic>> info->vapic_base_update(s);
+     *   - hw/intc/apic_common.c|263| <<apic_reset_common>> info->vapic_base_update(s);
+     *   - target/i386/whpx/whpx-apic.c|265| <<whpx_apic_class_init>> k->vapic_base_update = whpx_apic_vapic_base_update;
+     */
     info->vapic_base_update(s);
 
     apic_init_reset(dev);
diff --git a/hw/net/vhost_net.c b/hw/net/vhost_net.c
index 540492b37..f32293de5 100644
--- a/hw/net/vhost_net.c
+++ b/hw/net/vhost_net.c
@@ -330,6 +330,19 @@ static int vhost_net_start_one(struct vhost_net *net,
         }
     }
 
+    /*
+     * 在以下使用vhost_dev_start():
+     *   - backends/cryptodev-vhost.c|96| <<cryptodev_vhost_start_one>> r = vhost_dev_start(&crypto->dev, dev, false);
+     *   - backends/vhost-user.c|76| <<vhost_user_backend_start>> ret = vhost_dev_start(&b->dev, b->vdev, true);
+     *   - hw/block/vhost-user-blk.c|188| <<vhost_user_blk_start>> ret = vhost_dev_start(&s->dev, vdev, true);
+     *   - hw/net/vhost_net.c|333| <<vhost_net_start_one>> r = vhost_dev_start(&net->dev, dev, false);
+     *   - hw/scsi/vhost-scsi-common.c|81| <<vhost_scsi_common_start>> ret = vhost_dev_start(&vsc->dev, vdev, true);
+     *   - hw/virtio/vdpa-dev.c|263| <<vhost_vdpa_device_start>> ret = vhost_dev_start(&s->dev, vdev, true);
+     *   - hw/virtio/vhost-user-base.c|46| <<vub_start>> ret = vhost_dev_start(&vub->vhost_dev, vdev, true);
+     *   - hw/virtio/vhost-user-fs.c|80| <<vuf_start>> ret = vhost_dev_start(&fs->vhost_dev, vdev, true);
+     *   - hw/virtio/vhost-user-scmi.c|61| <<vu_scmi_start>> ret = vhost_dev_start(vhost_dev, vdev, true);
+     *   - hw/virtio/vhost-vsock-common.c|74| <<vhost_vsock_common_start>> ret = vhost_dev_start(&vvc->vhost_dev, vdev, true);
+     */
     r = vhost_dev_start(&net->dev, dev, false);
     if (r < 0) {
         goto fail_start;
@@ -379,6 +392,18 @@ fail:
     if (net->nc->info->poll) {
         net->nc->info->poll(net->nc, true);
     }
+    /*
+     * 在以下使用vhost_dev_stop():
+     *   - backends/cryptodev-vhost.c|113| <<cryptodev_vhost_stop_one>> vhost_dev_stop(&crypto->dev, dev, false);
+     *   - backends/vhost-user.c|111| <<vhost_user_backend_stop>> ret = vhost_dev_stop(&b->dev, b->vdev, true);
+     *   - hw/block/vhost-user-blk.c|228| <<vhost_user_blk_stop>> vhost_dev_stop(&s->dev, vdev, true);
+     *   - hw/net/vhost_net.c|382| <<vhost_net_start_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|401| <<vhost_net_stop_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|689| <<vhost_net_virtqueue_restart>> vhost_dev_stop(&net->dev, vdev, false);
+     *   - hw/scsi/vhost-scsi-common.c|111| <<vhost_scsi_common_stop>> ret = vhost_dev_stop(&vsc->dev, vdev, true);
+     *   - hw/virtio/vdpa-dev.c|304| <<vhost_vdpa_device_stop>> vhost_dev_stop(&s->dev, vdev, false);
+     *   - hw/virtio/vhost-user-base.c|80| <<vub_stop>> ret = vhost_dev_stop(&vub->vhost_dev, vdev, true);
+     */
     vhost_dev_stop(&net->dev, dev, false);
 fail_start:
     return r;
@@ -398,6 +423,18 @@ static void vhost_net_stop_one(struct vhost_net *net,
     if (net->nc->info->poll) {
         net->nc->info->poll(net->nc, true);
     }
+    /*
+     * 在以下使用vhost_dev_stop():
+     *   - backends/cryptodev-vhost.c|113| <<cryptodev_vhost_stop_one>> vhost_dev_stop(&crypto->dev, dev, false);
+     *   - backends/vhost-user.c|111| <<vhost_user_backend_stop>> ret = vhost_dev_stop(&b->dev, b->vdev, true);
+     *   - hw/block/vhost-user-blk.c|228| <<vhost_user_blk_stop>> vhost_dev_stop(&s->dev, vdev, true);
+     *   - hw/net/vhost_net.c|382| <<vhost_net_start_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|401| <<vhost_net_stop_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|689| <<vhost_net_virtqueue_restart>> vhost_dev_stop(&net->dev, vdev, false);
+     *   - hw/scsi/vhost-scsi-common.c|111| <<vhost_scsi_common_stop>> ret = vhost_dev_stop(&vsc->dev, vdev, true);
+     *   - hw/virtio/vdpa-dev.c|304| <<vhost_vdpa_device_stop>> vhost_dev_stop(&s->dev, vdev, false);
+     *   - hw/virtio/vhost-user-base.c|80| <<vub_stop>> ret = vhost_dev_stop(&vub->vhost_dev, vdev, true);
+     */
     vhost_dev_stop(&net->dev, dev, false);
     if (net->nc->info->stop) {
         net->nc->info->stop(net->nc);
@@ -686,6 +723,18 @@ err_start:
         assert(ret >= 0);
     }
 
+    /*
+     * 在以下使用vhost_dev_stop():
+     *   - backends/cryptodev-vhost.c|113| <<cryptodev_vhost_stop_one>> vhost_dev_stop(&crypto->dev, dev, false);
+     *   - backends/vhost-user.c|111| <<vhost_user_backend_stop>> ret = vhost_dev_stop(&b->dev, b->vdev, true);
+     *   - hw/block/vhost-user-blk.c|228| <<vhost_user_blk_stop>> vhost_dev_stop(&s->dev, vdev, true);
+     *   - hw/net/vhost_net.c|382| <<vhost_net_start_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|401| <<vhost_net_stop_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|689| <<vhost_net_virtqueue_restart>> vhost_dev_stop(&net->dev, vdev, false);
+     *   - hw/scsi/vhost-scsi-common.c|111| <<vhost_scsi_common_stop>> ret = vhost_dev_stop(&vsc->dev, vdev, true);
+     *   - hw/virtio/vdpa-dev.c|304| <<vhost_vdpa_device_stop>> vhost_dev_stop(&s->dev, vdev, false);
+     *   - hw/virtio/vhost-user-base.c|80| <<vub_stop>> ret = vhost_dev_stop(&vub->vhost_dev, vdev, true);
+     */
     vhost_dev_stop(&net->dev, vdev, false);
 
     return r;
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index 6b5b5dace..db2032e61 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -688,6 +688,10 @@ default_value:
     return VIRTIO_NET_TX_QUEUE_DEFAULT_SIZE;
 }
 
+/*
+ * 在以下使用peer_attach():
+ *   - hw/net/virtio-net.c|754| <<virtio_net_set_queue_pairs>> r = peer_attach(n, i);
+ */
 static int peer_attach(VirtIONet *n, int index)
 {
     NetClientState *nc = qemu_get_subqueue(n->nic, index);
@@ -713,6 +717,10 @@ static int peer_attach(VirtIONet *n, int index)
     return tap_enable(nc->peer);
 }
 
+/*
+ * 在以下使用peer_detach():
+ *   - hw/net/virtio-net.c|757| <<virtio_net_set_queue_pairs>> r = peer_detach(n, i);
+ */
 static int peer_detach(VirtIONet *n, int index)
 {
     NetClientState *nc = qemu_get_subqueue(n->nic, index);
@@ -734,17 +742,52 @@ static int peer_detach(VirtIONet *n, int index)
     return tap_disable(nc->peer);
 }
 
+/*
+ * 在以下使用virtio_net_set_queue_pairs():
+ *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+ *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+ *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+ */
 static void virtio_net_set_queue_pairs(VirtIONet *n)
 {
     int i;
     int r;
 
+    /*
+     * 在以下使用NICState->peer_deleted:
+     *   - hw/net/virtio-net.c|756| <<virtio_net_set_queue_pairs>> if (n->nic->peer_deleted) {
+     *   - net/net.c|440| <<qemu_del_net_client>> if (nic->peer_deleted) {
+     *   - net/net.c|443| <<qemu_del_net_client>> nic->peer_deleted = true;
+     *   - net/net.c|475| <<qemu_del_nic>> if (nic->peer_deleted) {
+     *   - net/net.c|1724| <<net_cleanup>> if (nic->peer_deleted) {
+     */
     if (n->nic->peer_deleted) {
         return;
     }
 
+    /*
+     * VirtIONet *n:
+     * -> uint16_t max_queue_pairs;
+     * -> uint16_t curr_queue_pairs;
+     *
+     *
+     * 在以下修改VirtIONet->max_queue_pairs:
+     *   - hw/net/virtio-net.c|3562| <<global>> VMSTATE_SINGLE_TEST(max_queue_pairs, VirtIONet, max_queue_pairs_gt_1, 0,
+     *   - hw/net/virtio-net.c|3897| <<virtio_net_device_realize>> ++n->max_queue_pairs;
+     *   - hw/net/virtio-net.c|3901| <<virtio_net_device_realize>> n->max_queue_pairs = MAX(n->max_queue_pairs, 1);
+     */
     for (i = 0; i < n->max_queue_pairs; i++) {
+        /*
+	 * 在以下修改VirtIONet->curr_queue_pairs:
+         *   - hw/net/virtio-net.c|3564| <<global>> VMSTATE_UINT16_TEST(curr_queue_pairs, VirtIONet, max_queue_pairs_gt_1),
+         *   - hw/net/virtio-net.c|1482| <<virtio_net_handle_mq>> n->curr_queue_pairs = queue_pairs;
+         *   - hw/net/virtio-net.c|3911| <<virtio_net_device_realize>> n->curr_queue_pairs = 1;
+         *   - hw/net/virtio-net.c|4057| <<virtio_net_reset>> n->curr_queue_pairs = 1;
+	 */
         if (i < n->curr_queue_pairs) {
+            /*
+	     * 只在这里调用
+	     */
             r = peer_attach(n, i);
             assert(!r);
         } else {
@@ -879,6 +922,13 @@ static void failover_add_primary(VirtIONet *n, Error **errp)
     error_propagate(errp, err);
 }
 
+/*
+ * 在以下调用set_features:
+ *   - hw/virtio/virtio.c|3110| <<virtio_set_features_nocheck>> k->set_features(vdev, val);
+ *
+ * 在以下使用virtio_net_set_features():
+ *   - hw/net/virtio-net.c|4318| <<virtio_net_class_init>> vdc->set_features = virtio_net_set_features;
+ */
 static void virtio_net_set_features(VirtIODevice *vdev, uint64_t features)
 {
     VirtIONet *n = VIRTIO_NET(vdev);
@@ -890,6 +940,9 @@ static void virtio_net_set_features(VirtIODevice *vdev, uint64_t features)
         features &= ~(1ULL << VIRTIO_NET_F_MTU);
     }
 
+    /*
+     * 只在这里调用
+     */
     virtio_net_set_multiqueue(n,
                               virtio_has_feature(features, VIRTIO_NET_F_RSS) ||
                               virtio_has_feature(features, VIRTIO_NET_F_MQ));
@@ -1436,6 +1489,10 @@ error:
     return 0;
 }
 
+/*
+ * 在以下使用virtio_net_handle_mq():
+ *   - hw/net/virtio-net.c|1561| <<virtio_net_handle_ctrl_iov>> status = virtio_net_handle_mq(n, ctrl.cmd, iov, out_num);
+ */
 static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,
                                 struct iovec *iov, unsigned int iov_cnt)
 {
@@ -1460,6 +1517,13 @@ static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,
         if (s != sizeof(mq)) {
             return VIRTIO_NET_ERR;
         }
+        /*
+	 * struct virtio_net_ctrl_mq {
+         *     __virtio16 virtqueue_pairs;
+	 * };
+	 *
+	 * 似乎来自guest
+	 */
         queue_pairs = virtio_lduw_p(vdev, &mq.virtqueue_pairs);
 
     } else {
@@ -1484,11 +1548,22 @@ static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,
     /* stop the backend before changing the number of queue_pairs to avoid handling a
      * disabled queue */
     virtio_net_set_status(vdev, vdev->status);
+    /*
+     * 在以下使用virtio_net_set_queue_pairs():
+     *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+     */
     virtio_net_set_queue_pairs(n);
 
     return VIRTIO_NET_OK;
 }
 
+/*
+ * 在以下使用virtio_net_handle_ctrl_iov():
+ *   - hw/net/virtio-net.c|1608| <<virtio_net_handle_ctrl>> written = virtio_net_handle_ctrl_iov(vdev, elem->in_sg, elem->in_num,
+ *   - net/vhost-vdpa.c|1563| <<vhost_vdpa_net_handle_ctrl_avail>> virtio_net_handle_ctrl_iov(svq->vdev, &model_in, 1, &out, 1);
+ */
 size_t virtio_net_handle_ctrl_iov(VirtIODevice *vdev,
                                   const struct iovec *in_sg, unsigned in_num,
                                   const struct iovec *out_sg,
@@ -1532,6 +1607,47 @@ size_t virtio_net_handle_ctrl_iov(VirtIODevice *vdev,
     return sizeof(status);
 }
 
+/*
+ * (gdb) bt
+ * #0  peer_detach (n=0x5555586546b0, index=3) at ../hw/net/virtio-net.c:718
+ * #1  0x0000555555ebdec1 in virtio_net_set_queue_pairs (n=0x5555586546b0) at ../hw/net/virtio-net.c:751
+ * #2  0x0000555555ebfe24 in virtio_net_handle_mq (n=0x5555586546b0, cmd=0 '\000', iov=0x7fffe4041b50,
+ *     iov_cnt=1) at ../hw/net/virtio-net.c:1487
+ * #3  0x0000555555ec0034 in virtio_net_handle_ctrl_iov (vdev=0x5555586546b0, in_sg=0x7ffe580c44b0,
+ *     in_num=1, out_sg=0x7ffe580c44c0, out_num=1) at ../hw/net/virtio-net.c:1523
+ * #4  0x0000555555ec0151 in virtio_net_handle_ctrl (vdev=0x5555586546b0, vq=0x555558659010)
+ *     at ../hw/net/virtio-net.c:1546
+ * #5  0x0000555555ef0eb3 in virtio_queue_notify (vdev=0x5555586546b0, n=8) at ../hw/virtio/virtio.c:2486
+ * #6  0x0000555555ba2df9 in virtio_pci_notify_write (opaque=0x55555864c0f0, addr=32, val=8, size=2)
+ *     at ../hw/virtio/virtio-pci.c:1724
+ * #7  0x0000555555c14c0b in memory_region_write_accessor (mr=0x55555864d030, addr=32, value=0x7fffed3013e8,
+ *     size=2, shift=0, mask=65535, attrs=...) at ../system/memory.c:490
+ * #8  0x0000555555c14f5d in access_with_adjusted_size (addr=32, value=0x7fffed3013e8, size=2, access_size_min=1,
+ *     access_size_max=4, access_fn=0x555555c14b15 <memory_region_write_accessor>, mr=0x55555864d030, attrs=...)
+ *     at ../system/memory.c:566
+ * #9  0x0000555555c18720 in memory_region_dispatch_write (mr=0x55555864d030, addr=32, data=8, op=MO_16,
+ *     attrs=...) at ../system/memory.c:1546
+ * #10 0x0000555555c29b89 in flatview_write_continue_step (attrs=..., buf=0x7ffff7fed028 "\b", len=2,
+ *     mr_addr=32, l=0x7fffed3014d0, mr=0x55555864d030) at ../system/physmem.c:2972
+ * #11 0x0000555555c29c5e in flatview_write_continue (fv=0x7ffe58065650, addr=15393162801184, attrs=...
+ *     ptr=0x7ffff7fed028, len=2, mr_addr=32, l=2, mr=0x55555864d030) at ../system/physmem.c:3002
+ * #12 0x0000555555c29d8b in flatview_write (fv=0x7ffe58065650, addr=15393162801184, attrs=...,
+ *     buf=0x7ffff7fed028, len=2) at ../system/physmem.c:3033
+ * #13 0x0000555555c2a218 in address_space_write (as=0x555557503a20 <address_space_memory>, addr=15393162801184,
+ *     attrs=..., buf=0x7ffff7fed028, len=2) at ../system/physmem.c:3153
+ * #14 0x0000555555c2a292 in address_space_rw (as=0x555557503a20 <address_space_memory>, addr=15393162801184,
+ *     attrs=..., buf=0x7ffff7fed028, len=2, is_write=true) at ../system/physmem.c:3163
+ * #15 0x0000555555f252c9 in kvm_cpu_exec (cpu=0x555557941b40) at ../accel/kvm/kvm-all.c:3255
+ * #16 0x0000555555f289f2 in kvm_vcpu_thread_fn (arg=0x555557941b40) at ../accel/kvm/kvm-accel-ops.c:51
+ * #17 0x0000555556155700 in qemu_thread_start (args=0x55555794b3a0) at ../util/qemu-thread-posix.c:393
+ * #18 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #19 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用virtio_net_handle_ctrl():
+ *   - hw/net/virtio-net.c|3054| <<virtio_net_change_num_queues>> n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
+ *   - hw/net/virtio-net.c|4001| <<virtio_net_device_realize>> n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
+ */
 static void virtio_net_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtQueueElement *elem;
@@ -1543,6 +1659,11 @@ static void virtio_net_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
             break;
         }
 
+        /*
+	 * 在以下使用virtio_net_handle_ctrl_iov():
+         *   - hw/net/virtio-net.c|1608| <<virtio_net_handle_ctrl>> written = virtio_net_handle_ctrl_iov(vdev, elem->in_sg, elem->in_num,
+         *   - net/vhost-vdpa.c|1563| <<vhost_vdpa_net_handle_ctrl_avail>> virtio_net_handle_ctrl_iov(svq->vdev, &model_in, 1, &out, 1);
+	 */
         written = virtio_net_handle_ctrl_iov(vdev, elem->in_sg, elem->in_num,
                                              elem->out_sg, elem->out_num);
         if (written > 0) {
@@ -2992,6 +3113,47 @@ static void virtio_net_change_num_queues(VirtIONet *n, int new_num_queues)
     n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
 }
 
+/*
+ * (gdb) bt
+ * #0  peer_detach (n=0x5555586546b0, index=1) at ../hw/net/virtio-net.c:718
+ * #1  0x0000555555ebdec1 in virtio_net_set_queue_pairs (n=0x5555586546b0) at ../hw/net/virtio-net.c:751
+ * #2  0x0000555555ec3fa8 in virtio_net_set_multiqueue (n=0x5555586546b0, multiqueue=0) at ../hw/net/virtio-net.c:3002
+ * #3  0x0000555555ebe460 in virtio_net_set_features (vdev=0x5555586546b0, features=0) at ../hw/net/virtio-net.c:893
+ * #4  0x0000555555ef222f in virtio_set_features_nocheck (vdev=0x5555586546b0, val=0) at ../hw/virtio/virtio.c:3079
+ * #5  0x0000555555ef25e1 in virtio_reset (opaque=0x5555586546b0) at ../hw/virtio/virtio.c:3184
+ * #6  0x0000555555b9c52d in virtio_bus_reset (bus=0x555558654630) at ../hw/virtio/virtio-bus.c:109
+ * #7  0x0000555555ba4567 in virtio_pci_reset (qdev=0x55555864c0f0) at ../hw/virtio/virtio-pci.c:2311
+ * #8  0x0000555555ba2735 in virtio_pci_common_write (opaque=0x55555864c0f0, addr=20, val=0, size=1)
+ *     at ../hw/virtio/virtio-pci.c:1623
+ * #9  0x0000555555c14c0b in memory_region_write_accessor (mr=0x55555864ccd0, addr=20, value=0x7fffedb023e8,
+ *     size=1, shift=0, mask=255, attrs=...) at ../system/memory.c:490
+ * #10 0x0000555555c14f5d in access_with_adjusted_size (addr=20, value=0x7fffedb023e8, size=1, access_size_min=1,
+ *     access_size_max=4, access_fn=0x555555c14b15 <memory_region_write_accessor>, mr=0x55555864ccd0, attrs=...)
+ *     at ../system/memory.c:566
+ * #11 0x0000555555c18720 in memory_region_dispatch_write (mr=0x55555864ccd0, addr=20, data=0, op=MO_8, attrs=...)
+ *     at ../system/memory.c:1546
+ * #12 0x0000555555c29b89 in flatview_write_continue_step (attrs=..., buf=0x7ffff7ff0028 "", len=1, mr_addr=20,
+ *     l=0x7fffedb024d0, mr=0x55555864ccd0) at ../system/physmem.c:2972
+ * #13 0x0000555555c29c5e in flatview_write_continue (fv=0x7fffe417d080, addr=15393162788884, attrs=...,
+ *     ptr=0x7ffff7ff0028, len=1, mr_addr=20, l=1, mr=0x55555864ccd0) at ../system/physmem.c:3002
+ * #14 0x0000555555c29d8b in flatview_write (fv=0x7fffe417d080, addr=15393162788884, attrs=..., buf=0x7ffff7ff0028,
+ *     len=1) at ../system/physmem.c:3033
+ * #15 0x0000555555c2a218 in address_space_write (as=0x555557503a20 <address_space_memory>, addr=15393162788884,
+ *     attrs=..., buf=0x7ffff7ff0028, len=1) at ../system/physmem.c:3153
+ * #16 0x0000555555c2a292 in address_space_rw (as=0x555557503a20 <address_space_memory>, addr=15393162788884,
+ *     attrs=..., buf=0x7ffff7ff0028, len=1, is_write=true) at ../system/physmem.c:3163
+ * #17 0x0000555555f252c9 in kvm_cpu_exec (cpu=0x55555790dc80) at ../accel/kvm/kvm-all.c:3255
+ * #18 0x0000555555f289f2 in kvm_vcpu_thread_fn (arg=0x55555790dc80) at ../accel/kvm/kvm-accel-ops.c:51
+ * #19 0x0000555556155700 in qemu_thread_start (args=0x555557917a30) at ../util/qemu-thread-posix.c:393
+ * #20 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #21 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用virtio_net_set_multiqueue():
+ *   - hw/net/virtio-net.c|925| <<virtio_net_set_features>> virtio_net_set_multiqueue(n,
+ *                                    virtio_has_feature(features, VIRTIO_NET_F_RSS) ||
+ *                                    virtio_has_feature(features, VIRTIO_NET_F_MQ));
+ */
 static void virtio_net_set_multiqueue(VirtIONet *n, int multiqueue)
 {
     int max = multiqueue ? n->max_queue_pairs : 1;
@@ -2999,6 +3161,12 @@ static void virtio_net_set_multiqueue(VirtIONet *n, int multiqueue)
     n->multiqueue = multiqueue;
     virtio_net_change_num_queues(n, max * 2 + 1);
 
+    /*
+     * 在以下使用virtio_net_set_queue_pairs():
+     *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+     */
     virtio_net_set_queue_pairs(n);
 }
 
@@ -3136,6 +3304,12 @@ static int virtio_net_post_load_device(void *opaque, int version_id)
      */
     n->saved_guest_offloads = n->curr_guest_offloads;
 
+    /*
+     * 在以下使用virtio_net_set_queue_pairs():
+     *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+     */
     virtio_net_set_queue_pairs(n);
 
     /* Find the first multicast entry in the saved MAC filter */
@@ -3861,6 +4035,15 @@ static void virtio_net_device_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用VirtIONet->max_ncs:
+     *   - hw/net/virtio-net.c|269| <<virtio_net_vhost_status>> int cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     *   - hw/net/virtio-net.c|3899| <<virtio_net_device_realize>> n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
+     *   - hw/net/virtio-net.c|3906| <<virtio_net_device_realize>> for (i = 0; i < n->max_ncs; i++) {
+     *   - net/vhost-vdpa.c|358| <<vhost_vdpa_net_log_global_enable>> cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     */
     n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
 
     /*
@@ -3868,6 +4051,15 @@ static void virtio_net_device_realize(DeviceState *dev, Error **errp)
      * provide control queue via peers as well.
      */
     if (n->nic_conf.peers.queues) {
+        /*
+         * 在以下使用VirtIONet->max_ncs:
+         *   - hw/net/virtio-net.c|269| <<virtio_net_vhost_status>> int cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+         *                   ? n->max_ncs - n->max_queue_pairs : 0;
+         *   - hw/net/virtio-net.c|3899| <<virtio_net_device_realize>> n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
+         *   - hw/net/virtio-net.c|3906| <<virtio_net_device_realize>> for (i = 0; i < n->max_ncs; i++) {
+         *   - net/vhost-vdpa.c|358| <<vhost_vdpa_net_log_global_enable>> cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+         *                   ? n->max_ncs - n->max_queue_pairs : 0;
+	 */
         for (i = 0; i < n->max_ncs; i++) {
             if (n->nic_conf.peers.ncs[i]->is_datapath) {
                 ++n->max_queue_pairs;
@@ -3900,6 +4092,11 @@ static void virtio_net_device_realize(DeviceState *dev, Error **errp)
 
     virtio_net_add_queue(n, 0);
 
+    /*
+     * 在以下使用virtio_net_handle_ctrl():
+     *   - hw/net/virtio-net.c|3054| <<virtio_net_change_num_queues>> n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
+     *   - hw/net/virtio-net.c|4001| <<virtio_net_device_realize>> n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
+     */
     n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
     qemu_macaddr_default_if_unset(&n->nic_conf.macaddr);
     memcpy(&n->mac[0], &n->nic_conf.macaddr, sizeof(n->mac));
diff --git a/hw/pci-host/i440fx.c b/hw/pci-host/i440fx.c
index e13bb1b53..0b4673a14 100644
--- a/hw/pci-host/i440fx.c
+++ b/hw/pci-host/i440fx.c
@@ -258,6 +258,14 @@ static void i440fx_pcihost_realize(DeviceState *dev, Error **errp)
     unsigned i;
 
     memory_region_add_subregion(s->io_memory, 0xcf8, &phb->conf_mem);
+    /*
+     * 在以下使用sysbus_init_ioports():
+     *   - hw/i386/vapic.c|742| <<vapic_realize>> sysbus_init_ioports(sbd, VAPIC_IO_PORT, 2);
+     *   - hw/pci-host/i440fx.c|261| <<i440fx_pcihost_realize>> sysbus_init_ioports(sbd, 0xcf8, 4);
+     *   - hw/pci-host/i440fx.c|264| <<i440fx_pcihost_realize>> sysbus_init_ioports(sbd, 0xcfc, 4);
+     *   - hw/pci-host/q35.c|55| <<q35_host_realize>> sysbus_init_ioports(sbd, MCH_HOST_BRIDGE_CONFIG_ADDR, 4);
+     *   - hw/pci-host/q35.c|59| <<q35_host_realize>> sysbus_init_ioports(sbd, MCH_HOST_BRIDGE_CONFIG_DATA, 4);
+     */
     sysbus_init_ioports(sbd, 0xcf8, 4);
 
     memory_region_add_subregion(s->io_memory, 0xcfc, &phb->data_mem);
diff --git a/hw/pci-host/q35.c b/hw/pci-host/q35.c
index 1951ae440..8c3204beb 100644
--- a/hw/pci-host/q35.c
+++ b/hw/pci-host/q35.c
@@ -52,6 +52,14 @@ static void q35_host_realize(DeviceState *dev, Error **errp)
 
     memory_region_add_subregion(s->mch.address_space_io,
                                 MCH_HOST_BRIDGE_CONFIG_ADDR, &pci->conf_mem);
+    /*
+     * 在以下使用sysbus_init_ioports():
+     *   - hw/i386/vapic.c|742| <<vapic_realize>> sysbus_init_ioports(sbd, VAPIC_IO_PORT, 2);
+     *   - hw/pci-host/i440fx.c|261| <<i440fx_pcihost_realize>> sysbus_init_ioports(sbd, 0xcf8, 4);
+     *   - hw/pci-host/i440fx.c|264| <<i440fx_pcihost_realize>> sysbus_init_ioports(sbd, 0xcfc, 4);
+     *   - hw/pci-host/q35.c|55| <<q35_host_realize>> sysbus_init_ioports(sbd, MCH_HOST_BRIDGE_CONFIG_ADDR, 4);
+     *   - hw/pci-host/q35.c|59| <<q35_host_realize>> sysbus_init_ioports(sbd, MCH_HOST_BRIDGE_CONFIG_DATA, 4);
+     */
     sysbus_init_ioports(sbd, MCH_HOST_BRIDGE_CONFIG_ADDR, 4);
 
     memory_region_add_subregion(s->mch.address_space_io,
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 9b12ee7f1..197338187 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -291,6 +291,23 @@ static void scsi_dma_restart_req(SCSIRequest *req, void *opaque)
                 break;
             case SCSI_XFER_NONE:
                 scsi_req_dequeue(req);
+                /*
+		 * 在以下使用scsi_req_enqueue():
+                 *   - hw/scsi/esp.c|321| <<do_command_phase>> datalen = scsi_req_enqueue(s->current_req);
+                 *   - hw/scsi/lsi53c895a.c|880| <<lsi_do_command>> n = scsi_req_enqueue(s->current->req);
+                 *   - hw/scsi/megasas.c|1074| <<megasas_pd_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+                 *   - hw/scsi/megasas.c|1090| <<megasas_pd_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+                 *   - hw/scsi/megasas.c|1280| <<megasas_ld_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+                 *   - hw/scsi/megasas.c|1670| <<megasas_enqueue_req>> len = scsi_req_enqueue(cmd->req);
+                 *   - hw/scsi/mptsas.c|353| <<mptsas_process_scsi_io_request>> if (scsi_req_enqueue(req->sreq)) {
+                 *   - hw/scsi/scsi-bus.c|294| <<scsi_dma_restart_req>> scsi_req_enqueue(req);
+                 *   - hw/scsi/spapr_vscsi.c|806| <<vscsi_queue_cmd>> n = scsi_req_enqueue(req->sreq);
+                 *   - hw/scsi/virtio-scsi.c|892| <<virtio_scsi_handle_cmd_req_submit>> if (scsi_req_enqueue(sreq)) {
+                 *   - hw/scsi/vmw_pvscsi.c|737| <<pvscsi_process_request_descriptor>> n = scsi_req_enqueue(r->sreq);
+                 *   - hw/ufs/lu.c|269| <<ufs_process_scsi_cmd>> uint32_t len = scsi_req_enqueue(scsi_req);
+                 *   - hw/usb/dev-storage.c|451| <<usb_msd_handle_data>> len = scsi_req_enqueue(s->req);
+                 *   - hw/usb/dev-uas.c|737| <<usb_uas_command>> len = scsi_req_enqueue(req->req);
+		 */
                 scsi_req_enqueue(req);
                 break;
         }
@@ -399,6 +416,15 @@ static void scsi_qdev_realize(DeviceState *qdev, Error **errp)
         error_propagate(errp, local_err);
         return;
     }
+    /*
+     * 在以下使用qdev_add_vm_change_state_handler():
+     *   - hw/block/virtio-blk.c|1806| <<virtio_blk_device_realize>> qdev_add_vm_change_state_handler(dev,
+     *        virtio_blk_dma_restart_cb, NULL, s);
+     *   - hw/scsi/scsi-bus.c|402| <<scsi_qdev_realize>> dev->vmsentry = qdev_add_vm_change_state_handler(DEVICE(dev),
+     *        scsi_dma_restart_cb, NULL, dev);
+     *   - hw/virtio/virtio.c|3580| <<virtio_init>> vdev->vmstate = qdev_add_vm_change_state_handler(DEVICE(vdev),
+     *        NULL, virtio_vmstate_change, vdev);
+     */
     dev->vmsentry = qdev_add_vm_change_state_handler(DEVICE(dev),
             scsi_dma_restart_cb, NULL, dev);
 }
@@ -1017,6 +1043,23 @@ static void scsi_req_enqueue_internal(SCSIRequest *req)
     }
 }
 
+/*
+ * 在以下使用scsi_req_enqueue():
+ *   - hw/scsi/esp.c|321| <<do_command_phase>> datalen = scsi_req_enqueue(s->current_req);
+ *   - hw/scsi/lsi53c895a.c|880| <<lsi_do_command>> n = scsi_req_enqueue(s->current->req);
+ *   - hw/scsi/megasas.c|1074| <<megasas_pd_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+ *   - hw/scsi/megasas.c|1090| <<megasas_pd_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+ *   - hw/scsi/megasas.c|1280| <<megasas_ld_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+ *   - hw/scsi/megasas.c|1670| <<megasas_enqueue_req>> len = scsi_req_enqueue(cmd->req);
+ *   - hw/scsi/mptsas.c|353| <<mptsas_process_scsi_io_request>> if (scsi_req_enqueue(req->sreq)) {
+ *   - hw/scsi/scsi-bus.c|294| <<scsi_dma_restart_req>> scsi_req_enqueue(req);
+ *   - hw/scsi/spapr_vscsi.c|806| <<vscsi_queue_cmd>> n = scsi_req_enqueue(req->sreq);
+ *   - hw/scsi/virtio-scsi.c|892| <<virtio_scsi_handle_cmd_req_submit>> if (scsi_req_enqueue(sreq)) {
+ *   - hw/scsi/vmw_pvscsi.c|737| <<pvscsi_process_request_descriptor>> n = scsi_req_enqueue(r->sreq);
+ *   - hw/ufs/lu.c|269| <<ufs_process_scsi_cmd>> uint32_t len = scsi_req_enqueue(scsi_req);
+ *   - hw/usb/dev-storage.c|451| <<usb_msd_handle_data>> len = scsi_req_enqueue(s->req);
+ *   - hw/usb/dev-uas.c|737| <<usb_uas_command>> len = scsi_req_enqueue(req->req);
+ */
 int32_t scsi_req_enqueue(SCSIRequest *req)
 {
     int32_t rc;
@@ -1599,6 +1642,11 @@ void scsi_req_print(SCSIRequest *req)
     }
 }
 
+/*
+ * 在以下使用scsi_req_complete_failed():
+ *   - hw/scsi/scsi-disk.c|307| <<scsi_handle_rw_error>> scsi_req_complete_failed(&r->req, host_status);
+ *   - hw/scsi/scsi-generic.c|92| <<scsi_command_complete_noio>> scsi_req_complete_failed(&r->req, io_hdr->host_status);
+ */
 void scsi_req_complete_failed(SCSIRequest *req, int host_status)
 {
     SCSISense sense;
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index b4782c624..9835fc77b 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -1326,6 +1326,10 @@ static int mode_sense_page(SCSIDiskState *s, int page, uint8_t **p_outbuf,
     return length + 2;
 }
 
+/*
+ * 在以下使用scsi_disk_emulate_mode_sense():
+ *   - hw/scsi/scsi-disk.c|2073| <<scsi_disk_emulate_command>> buflen = scsi_disk_emulate_mode_sense(r, outbuf);
+ */
 static int scsi_disk_emulate_mode_sense(SCSIDiskReq *r, uint8_t *outbuf)
 {
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
@@ -1575,6 +1579,10 @@ static void scsi_disk_apply_mode_select(SCSIDiskState *s, int page, uint8_t *p)
     }
 }
 
+/*
+ * 在以下使用mode_select_pages():
+ *   - hw/scsi/scsi-disk.c|1695| <<scsi_disk_emulate_mode_select>> if (mode_select_pages(r, p, len, pass == 1) < 0) {
+ */
 static int mode_select_pages(SCSIDiskReq *r, uint8_t *p, int len, bool change)
 {
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
@@ -1634,6 +1642,10 @@ invalid_param_len:
     return -1;
 }
 
+/*
+ * 在以下使用scsi_disk_emulate_mode_select():
+ *   - hw/scsi/scsi-disk.c|1985| <<scsi_disk_emulate_write_data>> scsi_disk_emulate_mode_select(r, r->iov.iov_base);
+ */
 static void scsi_disk_emulate_mode_select(SCSIDiskReq *r, uint8_t *inbuf)
 {
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
@@ -2007,6 +2019,21 @@ static void scsi_disk_emulate_write_data(SCSIRequest *req)
     }
 }
 
+/*
+ * 2648 static const SCSIReqOps scsi_disk_emulate_reqops = {
+ * 2649     .size         = sizeof(SCSIDiskReq),
+ * 2650     .free_req     = scsi_free_request,
+ * 2651     .send_command = scsi_disk_emulate_command,
+ * 2652     .read_data    = scsi_disk_emulate_read_data,
+ * 2653     .write_data   = scsi_disk_emulate_write_data,
+ * 2654     .get_buf      = scsi_get_buf,
+ * 2655     .load_request = scsi_disk_emulate_load_request,
+ * 2656     .save_request = scsi_disk_emulate_save_request,
+ * 2657 };
+ *
+ * 在以下调用send_command指针函数:
+ *   - hw/scsi/scsi-bus.c|1036| <<scsi_req_enqueue>> rc = req->ops->send_command(req, req->cmd.buf);
+ */
 static int32_t scsi_disk_emulate_command(SCSIRequest *req, uint8_t *buf)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
diff --git a/hw/scsi/vhost-scsi-common.c b/hw/scsi/vhost-scsi-common.c
index 43525ba46..1824c3959 100644
--- a/hw/scsi/vhost-scsi-common.c
+++ b/hw/scsi/vhost-scsi-common.c
@@ -26,6 +26,11 @@
 #include "hw/virtio/virtio-access.h"
 #include "hw/fw-path-provider.h"
 
+/*
+ * 在以下使用vhost_scsi_common_start():
+ *   - hw/scsi/vhost-scsi.c|125| <<vhost_scsi_start>> ret = vhost_scsi_common_start(vsc, &local_err);
+ *   - hw/scsi/vhost-user-scsi.c|49| <<vhost_user_scsi_start>> ret = vhost_scsi_common_start(vsc, errp);
+ */
 int vhost_scsi_common_start(VHostSCSICommon *vsc, Error **errp)
 {
     int ret, i;
@@ -54,6 +59,11 @@ int vhost_scsi_common_start(VHostSCSICommon *vsc, Error **errp)
 
     vsc->dev.acked_features = vdev->guest_features;
 
+    /*
+     * 在以下使用vhost_dev_prepare_inflight():
+     *   - hw/block/vhost-user-blk.c|159| <<vhost_user_blk_start>> ret = vhost_dev_prepare_inflight(&s->dev, vdev);
+     *   - hw/scsi/vhost-scsi-common.c|62| <<vhost_scsi_common_start>> ret = vhost_dev_prepare_inflight(&vsc->dev, vdev);
+     */
     ret = vhost_dev_prepare_inflight(&vsc->dev, vdev);
     if (ret < 0) {
         error_setg_errno(errp, -ret, "Error setting inflight format");
@@ -78,6 +88,19 @@ int vhost_scsi_common_start(VHostSCSICommon *vsc, Error **errp)
         }
     }
 
+    /*
+     * 在以下使用vhost_dev_start():
+     *   - backends/cryptodev-vhost.c|96| <<cryptodev_vhost_start_one>> r = vhost_dev_start(&crypto->dev, dev, false);
+     *   - backends/vhost-user.c|76| <<vhost_user_backend_start>> ret = vhost_dev_start(&b->dev, b->vdev, true);
+     *   - hw/block/vhost-user-blk.c|188| <<vhost_user_blk_start>> ret = vhost_dev_start(&s->dev, vdev, true);
+     *   - hw/net/vhost_net.c|333| <<vhost_net_start_one>> r = vhost_dev_start(&net->dev, dev, false);
+     *   - hw/scsi/vhost-scsi-common.c|81| <<vhost_scsi_common_start>> ret = vhost_dev_start(&vsc->dev, vdev, true);
+     *   - hw/virtio/vdpa-dev.c|263| <<vhost_vdpa_device_start>> ret = vhost_dev_start(&s->dev, vdev, true);
+     *   - hw/virtio/vhost-user-base.c|46| <<vub_start>> ret = vhost_dev_start(&vub->vhost_dev, vdev, true);
+     *   - hw/virtio/vhost-user-fs.c|80| <<vuf_start>> ret = vhost_dev_start(&fs->vhost_dev, vdev, true);
+     *   - hw/virtio/vhost-user-scmi.c|61| <<vu_scmi_start>> ret = vhost_dev_start(vhost_dev, vdev, true);
+     *   - hw/virtio/vhost-vsock-common.c|74| <<vhost_vsock_common_start>> ret = vhost_dev_start(&vvc->vhost_dev, vdev, true);
+     */
     ret = vhost_dev_start(&vsc->dev, vdev, true);
     if (ret < 0) {
         error_setg_errno(errp, -ret, "Error starting vhost dev");
@@ -101,6 +124,68 @@ err_host_notifiers:
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_scsi_common_stop (vsc=0x55555850f310) at ../hw/scsi/vhost-scsi-common.c:106
+ * #1  0x0000555555b1a46e in vhost_scsi_stop (s=0x55555850f310) at ../hw/scsi/vhost-scsi.c:114
+ * #2  0x0000555555b1a544 in vhost_scsi_set_status (vdev=0x55555850f310, val=15 '\017') at ../hw/scsi/vhost-scsi.c:140
+ * #3  0x0000555555ef03d4 in virtio_set_status (vdev=0x55555850f310, val=15 '\017') at ../hw/virtio/virtio.c:2263
+ * #4  0x0000555555ef35d7 in virtio_vmstate_change (opaque=0x55555850f310, running=false, state=RUN_STATE_PAUSED) at ../hw/virtio/virtio.c:3464
+ * #5  0x0000555555c37f3f in vm_state_notify (running=false, state=RUN_STATE_PAUSED) at ../system/runstate.c:399
+ * #6  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_PAUSED, send_stop=true) at ../system/cpus.c:300
+ * #7  0x0000555555c09c5a in vm_stop (state=RUN_STATE_PAUSED) at ../system/cpus.c:737
+ * #8  0x0000555555c8bbb3 in qmp_stop (errp=0x0) at ../monitor/qmp-cmds.c:62
+ * #9  0x0000555555c85d42 in hmp_stop (mon=0x555557868360, qdict=0x5555582c7e00) at ../monitor/hmp-cmds.c:93
+ * #10 0x0000555555c89ce5 in handle_hmp_command_exec (mon=0x555557868360, cmd=0x55555742f020 <hmp_cmds+7680>, qdict=0x5555582c7e00) at ../monitor/hmp.c:1106
+ * #11 0x0000555555c89f30 in handle_hmp_command (mon=0x555557868360, cmdline=0x5555578839a4 "") at ../monitor/hmp.c:1158
+ * #12 0x0000555555c86fb5 in monitor_command_cb (opaque=0x555557868360, cmdline=0x5555578839a0 "stop", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #13 0x000055555618534f in readline_handle_byte (rs=0x5555578839a0, ch=13) at ../util/readline.c:427
+ * #14 0x0000555555c8ab87 in monitor_read (opaque=0x555557868360, buf=0x7fffffffc920 "\r\311\377\377\377\177", size=1) at ../monitor/hmp.c:1390
+ * #15 0x0000555556078317 in qemu_chr_be_write_impl (s=0x55555773cb00, buf=0x7fffffffc920 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:214
+ * #16 0x0000555556078388 in qemu_chr_be_write (s=0x55555773cb00, buf=0x7fffffffc920 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:226
+ * #17 0x000055555607b38a in fd_chr_read (chan=0x55555783fbd0, cond=G_IO_IN, opaque=0x55555773cb00) at ../chardev/char-fd.c:72
+ * #18 0x0000555555f4a381 in qio_channel_fd_source_dispatch (source=0x555558542f60, callback=0x55555607b24b <fd_chr_read>, user_data=0x55555773cb00)
+ *     at ../io/channel-watch.c:84
+ * #19 0x00007ffff6fd3854 in g_main_dispatch (context=0x5555575e4840) at ../glib/gmain.c:3325
+ * #20 g_main_context_dispatch (context=0x5555575e4840) at ../glib/gmain.c:4043
+ * #21 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #22 0x00005555561721d5 in os_host_main_loop_wait (timeout=971330) at ../util/main-loop.c:310
+ * #23 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #24 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #25 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #26 0x0000555556082a7f in main (argc=25, argv=0x7fffffffdbd8) at ../system/main.c:93
+ *
+ * (gdb) bt
+ * #0  vhost_scsi_common_stop (vsc=0x55555850f310) at ../hw/scsi/vhost-scsi-common.c:106
+ * #1  0x0000555555b1a46e in vhost_scsi_stop (s=0x55555850f310) at ../hw/scsi/vhost-scsi.c:114
+ * #2  0x0000555555b1a544 in vhost_scsi_set_status (vdev=0x55555850f310, val=0 '\000') at ../hw/scsi/vhost-scsi.c:140
+ * #3  0x0000555555ef03d4 in virtio_set_status (vdev=0x55555850f310, val=0 '\000') at ../hw/virtio/virtio.c:2263
+ * #4  0x0000555555ba26f6 in virtio_pci_common_write (opaque=0x555558506d50, addr=20, val=0, size=1) at ../hw/virtio/virtio-pci.c:1616
+ * #5  0x0000555555c14c0b in memory_region_write_accessor (mr=0x555558507930, addr=20, value=0x7ffe5fdfe3e8, size=1, shift=0, mask=255, attrs=...) at ../system/memory.c:490
+ * #6  0x0000555555c14f5d in access_with_adjusted_size (addr=20, value=0x7ffe5fdfe3e8, size=1, access_size_min=1, access_size_max=4, 
+ *     access_fn=0x555555c14b15 <memory_region_write_accessor>, mr=0x555558507930, attrs=...) at ../system/memory.c:566
+ * #7  0x0000555555c18720 in memory_region_dispatch_write (mr=0x555558507930, addr=20, data=0, op=MO_8, attrs=...) at ../system/memory.c:1546
+ * #8  0x0000555555c29b89 in flatview_write_continue_step (attrs=..., buf=0x7fffec2fb028 "", len=1, mr_addr=20, l=0x7ffe5fdfe4d0, mr=0x555558507930)
+ *     at ../system/physmem.c:2972
+ * #9  0x0000555555c29c5e in flatview_write_continue (fv=0x7fffe43f51a0, addr=15393162788884, attrs=..., ptr=0x7fffec2fb028, len=1, mr_addr=20, l=1, mr=0x555558507930)
+ *     at ../system/physmem.c:3002
+ * #10 0x0000555555c29d8b in flatview_write (fv=0x7fffe43f51a0, addr=15393162788884, attrs=..., buf=0x7fffec2fb028, len=1) at ../system/physmem.c:3033
+ * #11 0x0000555555c2a218 in address_space_write (as=0x555557503a20 <address_space_memory>, addr=15393162788884, attrs=..., buf=0x7fffec2fb028, len=1)
+ *     at ../system/physmem.c:3153
+ * #12 0x0000555555c2a292 in address_space_rw (as=0x555557503a20 <address_space_memory>, addr=15393162788884, attrs=..., buf=0x7fffec2fb028, len=1, is_write=true)
+ *     at ../system/physmem.c:3163
+ * #13 0x0000555555f252c9 in kvm_cpu_exec (cpu=0x55555790c7d0) at ../accel/kvm/kvm-all.c:3255
+ * #14 0x0000555555f289f2 in kvm_vcpu_thread_fn (arg=0x55555790c7d0) at ../accel/kvm/kvm-accel-ops.c:51
+ * #15 0x0000555556155700 in qemu_thread_start (args=0x555557915e70) at ../util/qemu-thread-posix.c:393
+ * #16 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #17 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用vhost_scsi_common_stop():
+ *   - hw/scsi/vhost-scsi.c|103| <<vhost_scsi_start>> vhost_scsi_common_stop(vsc);
+ *   - hw/scsi/vhost-scsi.c|114| <<vhost_scsi_stop>> vhost_scsi_common_stop(vsc);
+ *   - hw/scsi/vhost-user-scsi.c|64| <<vhost_user_scsi_stop>> return vhost_scsi_common_stop(vsc);
+ */
 int vhost_scsi_common_stop(VHostSCSICommon *vsc)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(vsc);
@@ -108,6 +193,18 @@ int vhost_scsi_common_stop(VHostSCSICommon *vsc)
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
     int ret = 0;
 
+    /*
+     * 在以下使用vhost_dev_stop():
+     *   - backends/cryptodev-vhost.c|113| <<cryptodev_vhost_stop_one>> vhost_dev_stop(&crypto->dev, dev, false);
+     *   - backends/vhost-user.c|111| <<vhost_user_backend_stop>> ret = vhost_dev_stop(&b->dev, b->vdev, true);
+     *   - hw/block/vhost-user-blk.c|228| <<vhost_user_blk_stop>> vhost_dev_stop(&s->dev, vdev, true);
+     *   - hw/net/vhost_net.c|382| <<vhost_net_start_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|401| <<vhost_net_stop_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|689| <<vhost_net_virtqueue_restart>> vhost_dev_stop(&net->dev, vdev, false);
+     *   - hw/scsi/vhost-scsi-common.c|111| <<vhost_scsi_common_stop>> ret = vhost_dev_stop(&vsc->dev, vdev, true);
+     *   - hw/virtio/vdpa-dev.c|304| <<vhost_vdpa_device_stop>> vhost_dev_stop(&s->dev, vdev, false);
+     *   - hw/virtio/vhost-user-base.c|80| <<vub_stop>> ret = vhost_dev_stop(&vub->vhost_dev, vdev, true);
+     */
     ret = vhost_dev_stop(&vsc->dev, vdev, true);
 
     if (k->set_guest_notifiers) {
diff --git a/hw/scsi/vhost-scsi.c b/hw/scsi/vhost-scsi.c
index cdf405b0f..fcffe936a 100644
--- a/hw/scsi/vhost-scsi.c
+++ b/hw/scsi/vhost-scsi.c
@@ -43,6 +43,10 @@ static const int kernel_feature_bits[] = {
     VHOST_INVALID_FEATURE_BIT
 };
 
+/*
+ * 在以下使用vhost_scsi_set_endpoint():
+ *   - hw/scsi/vhost-scsi.c|131| <<vhost_scsi_start>> ret = vhost_scsi_set_endpoint(s);
+ */
 static int vhost_scsi_set_endpoint(VHostSCSI *s)
 {
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);
@@ -60,6 +64,41 @@ static int vhost_scsi_set_endpoint(VHostSCSI *s)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_scsi_common_stop (vsc=0x55555850f310) at ../hw/scsi/vhost-scsi-common.c:106
+ * #1  0x0000555555b1a46e in vhost_scsi_stop (s=0x55555850f310) at ../hw/scsi/vhost-scsi.c:114
+ * #2  0x0000555555b1a544 in vhost_scsi_set_status (vdev=0x55555850f310, val=15 '\017') at ../hw/scsi/vhost-scsi.c:140
+ * #3  0x0000555555ef03d4 in virtio_set_status (vdev=0x55555850f310, val=15 '\017') at ../hw/virtio/virtio.c:2263
+ * #4  0x0000555555ef35d7 in virtio_vmstate_change (opaque=0x55555850f310, running=false, state=RUN_STATE_PAUSED) at ../hw/virtio/virtio.c:3464
+ * #5  0x0000555555c37f3f in vm_state_notify (running=false, state=RUN_STATE_PAUSED) at ../system/runstate.c:399
+ * #6  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_PAUSED, send_stop=true) at ../system/cpus.c:300
+ * #7  0x0000555555c09c5a in vm_stop (state=RUN_STATE_PAUSED) at ../system/cpus.c:737
+ * #8  0x0000555555c8bbb3 in qmp_stop (errp=0x0) at ../monitor/qmp-cmds.c:62
+ * #9  0x0000555555c85d42 in hmp_stop (mon=0x555557868360, qdict=0x5555582c7e00) at ../monitor/hmp-cmds.c:93
+ * #10 0x0000555555c89ce5 in handle_hmp_command_exec (mon=0x555557868360, cmd=0x55555742f020 <hmp_cmds+7680>, qdict=0x5555582c7e00) at ../monitor/hmp.c:1106
+ * #11 0x0000555555c89f30 in handle_hmp_command (mon=0x555557868360, cmdline=0x5555578839a4 "") at ../monitor/hmp.c:1158
+ * #12 0x0000555555c86fb5 in monitor_command_cb (opaque=0x555557868360, cmdline=0x5555578839a0 "stop", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #13 0x000055555618534f in readline_handle_byte (rs=0x5555578839a0, ch=13) at ../util/readline.c:427
+ * #14 0x0000555555c8ab87 in monitor_read (opaque=0x555557868360, buf=0x7fffffffc920 "\r\311\377\377\377\177", size=1) at ../monitor/hmp.c:1390
+ * #15 0x0000555556078317 in qemu_chr_be_write_impl (s=0x55555773cb00, buf=0x7fffffffc920 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:214
+ * #16 0x0000555556078388 in qemu_chr_be_write (s=0x55555773cb00, buf=0x7fffffffc920 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:226
+ * #17 0x000055555607b38a in fd_chr_read (chan=0x55555783fbd0, cond=G_IO_IN, opaque=0x55555773cb00) at ../chardev/char-fd.c:72
+ * #18 0x0000555555f4a381 in qio_channel_fd_source_dispatch (source=0x555558542f60, callback=0x55555607b24b <fd_chr_read>, user_data=0x55555773cb00)
+ *     at ../io/channel-watch.c:84
+ * #19 0x00007ffff6fd3854 in g_main_dispatch (context=0x5555575e4840) at ../glib/gmain.c:3325
+ * #20 g_main_context_dispatch (context=0x5555575e4840) at ../glib/gmain.c:4043
+ * #21 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #22 0x00005555561721d5 in os_host_main_loop_wait (timeout=971330) at ../util/main-loop.c:310
+ * #23 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #24 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #25 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #26 0x0000555556082a7f in main (argc=25, argv=0x7fffffffdbd8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用vhost_scsi_clear_endpoint():
+ *   - hw/scsi/vhost-scsi.c|185| <<vhost_scsi_stop>> vhost_scsi_clear_endpoint(s);
+ */
 static void vhost_scsi_clear_endpoint(VHostSCSI *s)
 {
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);
@@ -72,6 +111,10 @@ static void vhost_scsi_clear_endpoint(VHostSCSI *s)
     vhost_ops->vhost_scsi_clear_endpoint(&vsc->dev, &backend);
 }
 
+/*
+ * 在以下使用vhost_scsi_start():
+ *   - hw/scsi/vhost-scsi.c|230| <<vhost_scsi_set_status>> ret = vhost_scsi_start(s);
+ */
 static int vhost_scsi_start(VHostSCSI *s)
 {
     int ret, abi_version;
@@ -91,29 +134,89 @@ static int vhost_scsi_start(VHostSCSI *s)
         return -ENOSYS;
     }
 
+    /*
+     * 在以下使用vhost_scsi_common_start():
+     *   - hw/scsi/vhost-scsi.c|125| <<vhost_scsi_start>> ret = vhost_scsi_common_start(vsc, &local_err);
+     *   - hw/scsi/vhost-user-scsi.c|49| <<vhost_user_scsi_start>> ret = vhost_scsi_common_start(vsc, errp);
+     */
     ret = vhost_scsi_common_start(vsc, &local_err);
     if (ret < 0) {
         error_reportf_err(local_err, "Error starting vhost-scsi: ");
         return ret;
     }
 
+    /*
+     * 只在这里调用
+     */
     ret = vhost_scsi_set_endpoint(s);
     if (ret < 0) {
         error_report("Error setting vhost-scsi endpoint");
+        /*
+	 * 在以下使用vhost_scsi_common_stop():
+         *   - hw/scsi/vhost-scsi.c|103| <<vhost_scsi_start>> vhost_scsi_common_stop(vsc);
+         *   - hw/scsi/vhost-scsi.c|114| <<vhost_scsi_stop>> vhost_scsi_common_stop(vsc);
+         *   - hw/scsi/vhost-user-scsi.c|64| <<vhost_user_scsi_stop>> return vhost_scsi_common_stop(vsc);
+	 */
         vhost_scsi_common_stop(vsc);
     }
 
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_scsi_common_stop (vsc=0x55555850f310) at ../hw/scsi/vhost-scsi-common.c:106
+ * #1  0x0000555555b1a46e in vhost_scsi_stop (s=0x55555850f310) at ../hw/scsi/vhost-scsi.c:114
+ * #2  0x0000555555b1a544 in vhost_scsi_set_status (vdev=0x55555850f310, val=15 '\017') at ../hw/scsi/vhost-scsi.c:140
+ * #3  0x0000555555ef03d4 in virtio_set_status (vdev=0x55555850f310, val=15 '\017') at ../hw/virtio/virtio.c:2263
+ * #4  0x0000555555ef35d7 in virtio_vmstate_change (opaque=0x55555850f310, running=false, state=RUN_STATE_PAUSED) at ../hw/virtio/virtio.c:3464
+ * #5  0x0000555555c37f3f in vm_state_notify (running=false, state=RUN_STATE_PAUSED) at ../system/runstate.c:399
+ * #6  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_PAUSED, send_stop=true) at ../system/cpus.c:300
+ * #7  0x0000555555c09c5a in vm_stop (state=RUN_STATE_PAUSED) at ../system/cpus.c:737
+ * #8  0x0000555555c8bbb3 in qmp_stop (errp=0x0) at ../monitor/qmp-cmds.c:62
+ * #9  0x0000555555c85d42 in hmp_stop (mon=0x555557868360, qdict=0x5555582c7e00) at ../monitor/hmp-cmds.c:93
+ * #10 0x0000555555c89ce5 in handle_hmp_command_exec (mon=0x555557868360, cmd=0x55555742f020 <hmp_cmds+7680>, qdict=0x5555582c7e00) at ../monitor/hmp.c:1106
+ * #11 0x0000555555c89f30 in handle_hmp_command (mon=0x555557868360, cmdline=0x5555578839a4 "") at ../monitor/hmp.c:1158
+ * #12 0x0000555555c86fb5 in monitor_command_cb (opaque=0x555557868360, cmdline=0x5555578839a0 "stop", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #13 0x000055555618534f in readline_handle_byte (rs=0x5555578839a0, ch=13) at ../util/readline.c:427
+ * #14 0x0000555555c8ab87 in monitor_read (opaque=0x555557868360, buf=0x7fffffffc920 "\r\311\377\377\377\177", size=1) at ../monitor/hmp.c:1390
+ * #15 0x0000555556078317 in qemu_chr_be_write_impl (s=0x55555773cb00, buf=0x7fffffffc920 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:214
+ * #16 0x0000555556078388 in qemu_chr_be_write (s=0x55555773cb00, buf=0x7fffffffc920 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:226
+ * #17 0x000055555607b38a in fd_chr_read (chan=0x55555783fbd0, cond=G_IO_IN, opaque=0x55555773cb00) at ../chardev/char-fd.c:72
+ * #18 0x0000555555f4a381 in qio_channel_fd_source_dispatch (source=0x555558542f60, callback=0x55555607b24b <fd_chr_read>, user_data=0x55555773cb00)
+ *     at ../io/channel-watch.c:84
+ * #19 0x00007ffff6fd3854 in g_main_dispatch (context=0x5555575e4840) at ../glib/gmain.c:3325
+ * #20 g_main_context_dispatch (context=0x5555575e4840) at ../glib/gmain.c:4043
+ * #21 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #22 0x00005555561721d5 in os_host_main_loop_wait (timeout=971330) at ../util/main-loop.c:310
+ * #23 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #24 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #25 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #26 0x0000555556082a7f in main (argc=25, argv=0x7fffffffdbd8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用vhost_scsi_stop():
+ *   - hw/scsi/vhost-scsi.c|140| <<vhost_scsi_set_status>> vhost_scsi_stop(s);
+ */
 static void vhost_scsi_stop(VHostSCSI *s)
 {
     VHostSCSICommon *vsc = VHOST_SCSI_COMMON(s);
 
     vhost_scsi_clear_endpoint(s);
+    /*
+     * 在以下使用vhost_scsi_common_stop():
+     *   - hw/scsi/vhost-scsi.c|103| <<vhost_scsi_start>> vhost_scsi_common_stop(vsc);
+     *   - hw/scsi/vhost-scsi.c|114| <<vhost_scsi_stop>> vhost_scsi_common_stop(vsc);
+     *   - hw/scsi/vhost-user-scsi.c|64| <<vhost_user_scsi_stop>> return vhost_scsi_common_stop(vsc);
+     */
     vhost_scsi_common_stop(vsc);
 }
 
+/*
+ * 在以下使用vhost_scsi_set_status():
+ *   - hw/scsi/vhost-scsi.c|331| <<vhost_scsi_unrealize>> vhost_scsi_set_status(vdev, 0);
+ *   - hw/scsi/vhost-scsi.c|383| <<vhost_scsi_class_init>> vdc->set_status = vhost_scsi_set_status;
+ */
 static int vhost_scsi_set_status(VirtIODevice *vdev, uint8_t val)
 {
     VHostSCSI *s = VHOST_SCSI(vdev);
diff --git a/hw/scsi/vhost-user-scsi.c b/hw/scsi/vhost-user-scsi.c
index 25f2d894e..bb53b22a1 100644
--- a/hw/scsi/vhost-user-scsi.c
+++ b/hw/scsi/vhost-user-scsi.c
@@ -46,6 +46,11 @@ static int vhost_user_scsi_start(VHostUserSCSI *s, Error **errp)
     VHostSCSICommon *vsc = VHOST_SCSI_COMMON(s);
     int ret;
 
+    /*
+     * 在以下使用vhost_scsi_common_start():
+     *   - hw/scsi/vhost-scsi.c|125| <<vhost_scsi_start>> ret = vhost_scsi_common_start(vsc, &local_err);
+     *   - hw/scsi/vhost-user-scsi.c|49| <<vhost_user_scsi_start>> ret = vhost_scsi_common_start(vsc, errp);
+     */
     ret = vhost_scsi_common_start(vsc, errp);
     s->started_vu = !(ret < 0);
 
@@ -61,6 +66,12 @@ static int vhost_user_scsi_stop(VHostUserSCSI *s)
     }
     s->started_vu = false;
 
+    /*
+     * 在以下使用vhost_scsi_common_stop():
+     *   - hw/scsi/vhost-scsi.c|103| <<vhost_scsi_start>> vhost_scsi_common_stop(vsc);
+     *   - hw/scsi/vhost-scsi.c|114| <<vhost_scsi_stop>> vhost_scsi_common_stop(vsc);
+     *   - hw/scsi/vhost-user-scsi.c|64| <<vhost_user_scsi_stop>> return vhost_scsi_common_stop(vsc);
+     */
     return vhost_scsi_common_stop(vsc);
 }
 
diff --git a/hw/scsi/virtio-scsi-dataplane.c b/hw/scsi/virtio-scsi-dataplane.c
index 95f13fb7c..c8171ff04 100644
--- a/hw/scsi/virtio-scsi-dataplane.c
+++ b/hw/scsi/virtio-scsi-dataplane.c
@@ -21,6 +21,10 @@
 #include "hw/virtio/iothread-vq-mapping.h"
 #include "hw/virtio/virtio-bus.h"
 
+/*
+ * 在以下使用virtio_scsi_dataplane_setup():
+ *   - hw/scsi/virtio-scsi.c|1371| <<virtio_scsi_device_realize>> virtio_scsi_dataplane_setup(s, errp);
+ */
 /* Context: BQL held */
 void virtio_scsi_dataplane_setup(VirtIOSCSI *s, Error **errp)
 {
diff --git a/hw/scsi/virtio-scsi.c b/hw/scsi/virtio-scsi.c
index 34ae14f7b..4ccdd16b3 100644
--- a/hw/scsi/virtio-scsi.c
+++ b/hw/scsi/virtio-scsi.c
@@ -886,9 +886,30 @@ static int virtio_scsi_handle_cmd_req_prepare(VirtIOSCSI *s, VirtIOSCSIReq *req)
     return 0;
 }
 
+/*
+ * 在以下使用virtio_scsi_handle_cmd_req_submit():
+ *   - hw/scsi/virtio-scsi.c|935| <<virtio_scsi_handle_cmd_vq>> virtio_scsi_handle_cmd_req_submit(s, req);
+ */
 static void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)
 {
     SCSIRequest *sreq = req->sreq;
+    /*
+     * 在以下使用scsi_req_enqueue():
+     *   - hw/scsi/esp.c|321| <<do_command_phase>> datalen = scsi_req_enqueue(s->current_req);
+     *   - hw/scsi/lsi53c895a.c|880| <<lsi_do_command>> n = scsi_req_enqueue(s->current->req);
+     *   - hw/scsi/megasas.c|1074| <<megasas_pd_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+     *   - hw/scsi/megasas.c|1090| <<megasas_pd_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+     *   - hw/scsi/megasas.c|1280| <<megasas_ld_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+     *   - hw/scsi/megasas.c|1670| <<megasas_enqueue_req>> len = scsi_req_enqueue(cmd->req);
+     *   - hw/scsi/mptsas.c|353| <<mptsas_process_scsi_io_request>> if (scsi_req_enqueue(req->sreq)) {
+     *   - hw/scsi/scsi-bus.c|294| <<scsi_dma_restart_req>> scsi_req_enqueue(req);
+     *   - hw/scsi/spapr_vscsi.c|806| <<vscsi_queue_cmd>> n = scsi_req_enqueue(req->sreq);
+     *   - hw/scsi/virtio-scsi.c|892| <<virtio_scsi_handle_cmd_req_submit>> if (scsi_req_enqueue(sreq)) {
+     *   - hw/scsi/vmw_pvscsi.c|737| <<pvscsi_process_request_descriptor>> n = scsi_req_enqueue(r->sreq);
+     *   - hw/ufs/lu.c|269| <<ufs_process_scsi_cmd>> uint32_t len = scsi_req_enqueue(scsi_req);
+     *   - hw/usb/dev-storage.c|451| <<usb_msd_handle_data>> len = scsi_req_enqueue(s->req);
+     *   - hw/usb/dev-uas.c|737| <<usb_uas_command>> len = scsi_req_enqueue(req->req);
+     */
     if (scsi_req_enqueue(sreq)) {
         scsi_req_continue(sreq);
     }
@@ -896,6 +917,10 @@ static void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)
     scsi_req_unref(sreq);
 }
 
+/*
+ * 在以下使用virtio_scsi_handle_cmd_vq():
+ *   - hw/scsi/virtio-scsi.c|948| <<virtio_scsi_handle_cmd>> virtio_scsi_handle_cmd_vq(s, vq);
+ */
 static void virtio_scsi_handle_cmd_vq(VirtIOSCSI *s, VirtQueue *vq)
 {
     VirtIOSCSIReq *req, *next;
@@ -936,6 +961,15 @@ static void virtio_scsi_handle_cmd_vq(VirtIOSCSI *s, VirtQueue *vq)
     }
 }
 
+/*
+ * 在以下使用virtio_scsi_handle_cmd():
+ *   - hw/scsi/virtio-scsi.c|1325| <<virtio_scsi_device_realize>>
+ *        virtio_scsi_common_realize(dev,
+ *                                   virtio_scsi_handle_ctrl,
+ *                                   virtio_scsi_handle_event,
+ *                                   virtio_scsi_handle_cmd,
+ *                                   &err);
+ */
 static void virtio_scsi_handle_cmd(VirtIODevice *vdev, VirtQueue *vq)
 {
     /* use non-QOM casts in the data path */
diff --git a/hw/vfio/migration.c b/hw/vfio/migration.c
index 4c06e3db9..fbfc87d73 100644
--- a/hw/vfio/migration.c
+++ b/hw/vfio/migration.c
@@ -1017,12 +1017,31 @@ static int vfio_migration_init(VFIODevice *vbasedev)
     }
     strpadcpy(id, sizeof(id), path, '\0');
 
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
                          vbasedev);
 
     prepare_cb = migration->mig_flags & VFIO_MIGRATION_P2P ?
                      vfio_vmstate_change_prepare :
                      NULL;
+    /*
+     * 在以下使用qdev_add_vm_change_state_handler_full():
+     *   - hw/core/vm-change-state-handler.c|64| <<qdev_add_vm_change_state_handler>>
+     *       return qdev_add_vm_change_state_handler_full(dev, cb, NULL, cb_ret, opaque);
+     *   - hw/vfio/migration.c|1037| <<vfio_migration_init>> migration->vm_state =
+     *       qdev_add_vm_change_state_handler_full(vbasedev->dev, vfio_vmstate_change,
+     *       prepare_cb, NULL, vbasedev);
+     */
     migration->vm_state = qdev_add_vm_change_state_handler_full(
         vbasedev->dev, vfio_vmstate_change, prepare_cb, NULL, vbasedev);
     migration_add_notifier(&migration->migration_state,
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 07257d0fa..63399a847 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -1013,9 +1013,28 @@ static void vfio_update_msi(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * 在以下使用vfio_pci_load_rom():
+ *   - hw/vfio/pci.c|1135| <<vfio_rom_read>> vfio_pci_load_rom(vdev);
+ */
 static void vfio_pci_load_rom(VFIOPCIDevice *vdev)
 {
     VFIODevice *vbasedev = &vdev->vbasedev;
+    /*
+     * 271 struct vfio_region_info {
+     * 272         __u32   argsz;
+     * 273         __u32   flags;
+     * 274 #define VFIO_REGION_INFO_FLAG_READ      (1 << 0) // Region supports read
+     * 275 #define VFIO_REGION_INFO_FLAG_WRITE     (1 << 1) // Region supports write
+     * 276 #define VFIO_REGION_INFO_FLAG_MMAP      (1 << 2) // Region supports mmap
+     * 277 #define VFIO_REGION_INFO_FLAG_CAPS      (1 << 3) // Info supports caps
+     * 278         __u32   index;          // Region index
+     * 279         __u32   cap_offset;     // Offset within info struct of first cap
+     * 280         __aligned_u64   size;   // Region size (bytes)
+     * 281         __aligned_u64   offset; // Region offset from start of device fd
+     * 282 };
+     * 283 #define VFIO_DEVICE_GET_REGION_INFO     _IO(VFIO_TYPE, VFIO_BASE + 8)
+     */
     struct vfio_region_info *reg_info = NULL;
     uint64_t size;
     off_t off = 0;
@@ -1035,6 +1054,10 @@ static void vfio_pci_load_rom(VFIOPCIDevice *vdev)
                             (unsigned long)reg_info->flags);
 
     vdev->rom_size = size = reg_info->size;
+    /*
+     * 在以下使用VFIOPCIDevice->rom_offset:
+     *   - hw/vfio/pci.c|1038| <<vfio_pci_load_rom>> vdev->rom_offset = reg_info->offset;
+     */
     vdev->rom_offset = reg_info->offset;
 
     if (!vdev->rom_size) {
@@ -1046,6 +1069,12 @@ static void vfio_pci_load_rom(VFIOPCIDevice *vdev)
         return;
     }
 
+    /*
+     * struct VFIOPCIDevice:
+     * -> unsigned int rom_size;
+     * -> off_t rom_offset;
+     * -> void *rom;
+     */
     vdev->rom = g_malloc(size);
     memset(vdev->rom, 0xff, size);
 
@@ -1119,6 +1148,13 @@ static int vfio_pci_config_space_write(VFIOPCIDevice *vdev, off_t offset,
                                                offset, size, data, false);
 }
 
+/*
+ * 1191 static const MemoryRegionOps vfio_rom_ops = {
+ * 1192     .read = vfio_rom_read,
+ * 1193     .write = vfio_rom_write,
+ * 1194     .endianness = DEVICE_LITTLE_ENDIAN,
+ * 1195 };
+ */
 static uint64_t vfio_rom_read(void *opaque, hwaddr addr, unsigned size)
 {
     VFIOPCIDevice *vdev = opaque;
diff --git a/hw/vfio/pci.h b/hw/vfio/pci.h
index 810a842f4..9e63eb573 100644
--- a/hw/vfio/pci.h
+++ b/hw/vfio/pci.h
@@ -130,6 +130,10 @@ struct VFIOPCIDevice {
     uint8_t *emulated_config_bits; /* QEMU emulated bits, little-endian */
     off_t config_offset; /* Offset of config space region within device fd */
     unsigned int rom_size;
+    /*
+     * 在以下使用VFIOPCIDevice->rom_offset:
+     *   - hw/vfio/pci.c|1038| <<vfio_pci_load_rom>> vdev->rom_offset = reg_info->offset;
+     */
     off_t rom_offset; /* Offset of ROM region within device fd */
     void *rom;
     int msi_cap_size;
@@ -173,6 +177,12 @@ struct VFIOPCIDevice {
     bool req_enabled;
     bool has_flr;
     bool has_pm_reset;
+    /*
+     * 在以下使用VFIOPCIDevice->rom_read_failed:
+     *   - hw/vfio/pci.c|1041| <<vfio_pci_load_rom>> vdev->rom_read_failed = true;
+     *   - hw/vfio/pci.c|1134| <<vfio_rom_read>> if (unlikely(!vdev->rom && !vdev->rom_read_failed)) {
+     *   - hw/vfio/pci.c|1235| <<vfio_pci_size_rom>> vdev->rom_read_failed = false;
+     */
     bool rom_read_failed;
     bool no_kvm_intx;
     bool no_kvm_msi;
diff --git a/hw/virtio/vdpa-dev.c b/hw/virtio/vdpa-dev.c
index d1da40afc..dd4d89c74 100644
--- a/hw/virtio/vdpa-dev.c
+++ b/hw/virtio/vdpa-dev.c
@@ -301,6 +301,18 @@ static void vhost_vdpa_device_stop(VirtIODevice *vdev)
         return;
     }
 
+    /*
+     * 在以下使用vhost_dev_stop():
+     *   - backends/cryptodev-vhost.c|113| <<cryptodev_vhost_stop_one>> vhost_dev_stop(&crypto->dev, dev, false);
+     *   - backends/vhost-user.c|111| <<vhost_user_backend_stop>> ret = vhost_dev_stop(&b->dev, b->vdev, true);
+     *   - hw/block/vhost-user-blk.c|228| <<vhost_user_blk_stop>> vhost_dev_stop(&s->dev, vdev, true);
+     *   - hw/net/vhost_net.c|382| <<vhost_net_start_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|401| <<vhost_net_stop_one>> vhost_dev_stop(&net->dev, dev, false);
+     *   - hw/net/vhost_net.c|689| <<vhost_net_virtqueue_restart>> vhost_dev_stop(&net->dev, vdev, false);
+     *   - hw/scsi/vhost-scsi-common.c|111| <<vhost_scsi_common_stop>> ret = vhost_dev_stop(&vsc->dev, vdev, true);
+     *   - hw/virtio/vdpa-dev.c|304| <<vhost_vdpa_device_stop>> vhost_dev_stop(&s->dev, vdev, false);
+     *   - hw/virtio/vhost-user-base.c|80| <<vub_stop>> ret = vhost_dev_stop(&vub->vhost_dev, vdev, true);
+     */
     vhost_dev_stop(&s->dev, vdev, false);
 
     ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);
diff --git a/hw/virtio/vhost.c b/hw/virtio/vhost.c
index 6557c58d1..f827b12ca 100644
--- a/hw/virtio/vhost.c
+++ b/hw/virtio/vhost.c
@@ -969,6 +969,13 @@ static int vhost_virtqueue_set_addr(struct vhost_dev *dev,
     return r;
 }
 
+/*
+ * 在以下使用vhost_dev_set_features():
+ *   - hw/virtio/vhost.c|1010| <<vhost_dev_set_log>> r = vhost_dev_set_features(dev, enable_log);
+ *   - hw/virtio/vhost.c|1052| <<vhost_dev_set_log>> vhost_dev_set_features(dev, dev->log_enabled);
+ *   - hw/virtio/vhost.c|1964| <<vhost_dev_prepare_inflight>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+ *   - hw/virtio/vhost.c|2046| <<vhost_dev_start>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+ */
 static int vhost_dev_set_features(struct vhost_dev *dev,
                                   bool enable_log)
 {
@@ -1007,6 +1014,13 @@ static int vhost_dev_set_log(struct vhost_dev *dev, bool enable_log)
     int r, i, idx;
     hwaddr addr;
 
+    /*
+     * 在以下使用vhost_dev_set_features():
+     *   - hw/virtio/vhost.c|1010| <<vhost_dev_set_log>> r = vhost_dev_set_features(dev, enable_log);
+     *   - hw/virtio/vhost.c|1052| <<vhost_dev_set_log>> vhost_dev_set_features(dev, dev->log_enabled);
+     *   - hw/virtio/vhost.c|1964| <<vhost_dev_prepare_inflight>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     *   - hw/virtio/vhost.c|2046| <<vhost_dev_start>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     */
     r = vhost_dev_set_features(dev, enable_log);
     if (r < 0) {
         goto err_features;
@@ -1049,6 +1063,13 @@ err_vq:
         vhost_virtqueue_set_addr(dev, dev->vqs + i, idx,
                                  dev->log_enabled);
     }
+    /*
+     * 在以下使用vhost_dev_set_features():
+     *   - hw/virtio/vhost.c|1010| <<vhost_dev_set_log>> r = vhost_dev_set_features(dev, enable_log);
+     *   - hw/virtio/vhost.c|1052| <<vhost_dev_set_log>> vhost_dev_set_features(dev, dev->log_enabled);
+     *   - hw/virtio/vhost.c|1964| <<vhost_dev_prepare_inflight>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     *   - hw/virtio/vhost.c|2046| <<vhost_dev_start>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     */
     vhost_dev_set_features(dev, dev->log_enabled);
 err_features:
     return r;
@@ -1236,6 +1257,11 @@ out:
     return ret;
 }
 
+/*
+ * 在以下使用vhost_virtqueue_start():
+ *   - hw/net/vhost_net.c|683| <<vhost_net_virtqueue_restart>> r = vhost_virtqueue_start(&net->dev,
+ *   - hw/virtio/vhost.c|2107| <<vhost_dev_start>> r = vhost_virtqueue_start(hdev,
+ */
 int vhost_virtqueue_start(struct vhost_dev *dev,
                           struct VirtIODevice *vdev,
                           struct vhost_virtqueue *vq,
@@ -1356,6 +1382,12 @@ fail_alloc_desc:
     return r;
 }
 
+/*
+ * 在以下使用do_vhost_virtqueue_stop():
+ *   - hw/virtio/vhost.c|1416| <<vhost_virtqueue_stop>> return do_vhost_virtqueue_stop(dev, vdev, vq, idx, false);
+ *   - hw/virtio/vhost.c|2176| <<do_vhost_dev_stop>> rc |= do_vhost_virtqueue_stop(hdev, vdev, hdev->vqs + i,
+ *                                     hdev->vq_index + i, force);
+ */
 static int do_vhost_virtqueue_stop(struct vhost_dev *dev,
                                    struct VirtIODevice *vdev,
                                    struct vhost_virtqueue *vq,
@@ -1408,11 +1440,22 @@ static int do_vhost_virtqueue_stop(struct vhost_dev *dev,
     return r;
 }
 
+/*
+ * 在以下使用vhost_virtqueue_stop():
+ *   - hw/net/vhost_net.c|660| <<vhost_net_virtqueue_reset>> vhost_virtqueue_stop(&net->dev,
+ *   - hw/virtio/vhost.c|2177| <<vhost_dev_start>> vhost_virtqueue_stop(hdev,
+ */
 int vhost_virtqueue_stop(struct vhost_dev *dev,
                          struct VirtIODevice *vdev,
                          struct vhost_virtqueue *vq,
                          unsigned idx)
 {
+    /*
+     * 在以下使用do_vhost_virtqueue_stop():
+     *   - hw/virtio/vhost.c|1416| <<vhost_virtqueue_stop>> return do_vhost_virtqueue_stop(dev, vdev, vq, idx, false);
+     *   - hw/virtio/vhost.c|2176| <<do_vhost_dev_stop>> rc |= do_vhost_virtqueue_stop(hdev, vdev, hdev->vqs + i,
+     *                                     hdev->vq_index + i, force);
+     */
     return do_vhost_virtqueue_stop(dev, vdev, vq, idx, false);
 }
 
@@ -1452,6 +1495,10 @@ static void vhost_virtqueue_error_notifier(EventNotifier *n)
     }
 }
 
+/*
+ * 在以下使用vhost_virtqueue_init():
+ *   - hw/virtio/vhost.c|1556| <<vhost_dev_init>> r = vhost_virtqueue_init(hdev, hdev->vqs + i, hdev->vq_index + i);
+ */
 static int vhost_virtqueue_init(struct vhost_dev *dev,
                                 struct vhost_virtqueue *vq, int n)
 {
@@ -1465,6 +1512,10 @@ static int vhost_virtqueue_init(struct vhost_dev *dev,
     }
 
     file.fd = event_notifier_get_wfd(&vq->masked_notifier);
+    /*
+     * vhost_kernel_set_vring_call()
+     * VHOST_SET_VRING_CALL
+     */
     r = dev->vhost_ops->vhost_set_vring_call(dev, &file);
     if (r) {
         VHOST_OPS_DEBUG(r, "vhost_set_vring_call failed");
@@ -1473,12 +1524,20 @@ static int vhost_virtqueue_init(struct vhost_dev *dev,
 
     vq->dev = dev;
 
+    /*
+     * vhost_kernel_set_vring_err()
+     * VHOST_SET_VRING_ERR
+     */
     if (dev->vhost_ops->vhost_set_vring_err) {
         r = event_notifier_init(&vq->error_notifier, 0);
         if (r < 0) {
             goto fail_call;
         }
 
+        /*
+	 * vhost_kernel_set_vring_err()
+         * VHOST_SET_VRING_ERR
+	 */
         file.fd = event_notifier_get_fd(&vq->error_notifier);
         r = dev->vhost_ops->vhost_set_vring_err(dev, &file);
         if (r) {
@@ -1928,6 +1987,11 @@ void vhost_dev_free_inflight(struct vhost_inflight *inflight)
     }
 }
 
+/*
+ * 在以下使用vhost_dev_prepare_inflight():
+ *   - hw/block/vhost-user-blk.c|159| <<vhost_user_blk_start>> ret = vhost_dev_prepare_inflight(&s->dev, vdev);
+ *   - hw/scsi/vhost-scsi-common.c|62| <<vhost_scsi_common_start>> ret = vhost_dev_prepare_inflight(&vsc->dev, vdev);
+ */
 int vhost_dev_prepare_inflight(struct vhost_dev *hdev, VirtIODevice *vdev)
 {
     int r;
@@ -1939,6 +2003,13 @@ int vhost_dev_prepare_inflight(struct vhost_dev *hdev, VirtIODevice *vdev)
 
     hdev->vdev = vdev;
 
+    /*
+     * 在以下使用vhost_dev_set_features():
+     *   - hw/virtio/vhost.c|1010| <<vhost_dev_set_log>> r = vhost_dev_set_features(dev, enable_log);
+     *   - hw/virtio/vhost.c|1052| <<vhost_dev_set_log>> vhost_dev_set_features(dev, dev->log_enabled);
+     *   - hw/virtio/vhost.c|1964| <<vhost_dev_prepare_inflight>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     *   - hw/virtio/vhost.c|2046| <<vhost_dev_start>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     */
     r = vhost_dev_set_features(hdev, hdev->log_enabled);
     if (r < 0) {
         VHOST_OPS_DEBUG(r, "vhost_dev_prepare_inflight failed");
@@ -2008,6 +2079,19 @@ static int vhost_dev_set_vring_enable(struct vhost_dev *hdev, int enable)
  * device. If it is false, the vring initialization is left to be done by the
  * caller.
  */
+/*
+ * 在以下使用vhost_dev_start():
+ *   - backends/cryptodev-vhost.c|96| <<cryptodev_vhost_start_one>> r = vhost_dev_start(&crypto->dev, dev, false);
+ *   - backends/vhost-user.c|76| <<vhost_user_backend_start>> ret = vhost_dev_start(&b->dev, b->vdev, true);
+ *   - hw/block/vhost-user-blk.c|188| <<vhost_user_blk_start>> ret = vhost_dev_start(&s->dev, vdev, true);
+ *   - hw/net/vhost_net.c|333| <<vhost_net_start_one>> r = vhost_dev_start(&net->dev, dev, false);
+ *   - hw/scsi/vhost-scsi-common.c|81| <<vhost_scsi_common_start>> ret = vhost_dev_start(&vsc->dev, vdev, true);
+ *   - hw/virtio/vdpa-dev.c|263| <<vhost_vdpa_device_start>> ret = vhost_dev_start(&s->dev, vdev, true);
+ *   - hw/virtio/vhost-user-base.c|46| <<vub_start>> ret = vhost_dev_start(&vub->vhost_dev, vdev, true);
+ *   - hw/virtio/vhost-user-fs.c|80| <<vuf_start>> ret = vhost_dev_start(&fs->vhost_dev, vdev, true);
+ *   - hw/virtio/vhost-user-scmi.c|61| <<vu_scmi_start>> ret = vhost_dev_start(vhost_dev, vdev, true);
+ *   - hw/virtio/vhost-vsock-common.c|74| <<vhost_vsock_common_start>> ret = vhost_dev_start(&vvc->vhost_dev, vdev, true);
+ */
 int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev, bool vrings)
 {
     int i, r;
@@ -2021,6 +2105,13 @@ int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev, bool vrings)
     hdev->started = true;
     hdev->vdev = vdev;
 
+    /*
+     * 在以下使用vhost_dev_set_features():
+     *   - hw/virtio/vhost.c|1010| <<vhost_dev_set_log>> r = vhost_dev_set_features(dev, enable_log);
+     *   - hw/virtio/vhost.c|1052| <<vhost_dev_set_log>> vhost_dev_set_features(dev, dev->log_enabled);
+     *   - hw/virtio/vhost.c|1964| <<vhost_dev_prepare_inflight>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     *   - hw/virtio/vhost.c|2046| <<vhost_dev_start>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     */
     r = vhost_dev_set_features(hdev, hdev->log_enabled);
     if (r < 0) {
         goto fail_features;
@@ -2036,6 +2127,13 @@ int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev, bool vrings)
         goto fail_mem;
     }
     for (i = 0; i < hdev->nvqs; ++i) {
+        /*
+	 * 在以下使用vhost_virtqueue_start():
+         *   - hw/net/vhost_net.c|683| <<vhost_net_virtqueue_restart>> r = vhost_virtqueue_start(&net->dev,
+         *   - hw/virtio/vhost.c|2107| <<vhost_dev_start>> r = vhost_virtqueue_start(hdev,
+	 *
+	 * 这里设置了VRING_KICK!!!!
+	 */
         r = vhost_virtqueue_start(hdev,
                                   vdev,
                                   hdev->vqs + i,
@@ -2133,6 +2231,11 @@ fail_features:
     return r;
 }
 
+/*
+ * 在以下使用do_vhost_dev_stop():
+ *   - hw/virtio/vhost.c|2202| <<vhost_dev_stop>> return do_vhost_dev_stop(hdev, vdev, vrings, false);
+ *   - hw/virtio/vhost.c|2208| <<vhost_dev_force_stop>> return do_vhost_dev_stop(hdev, vdev, vrings, true);
+ */
 /* Host notifiers must be enabled at this point. */
 static int do_vhost_dev_stop(struct vhost_dev *hdev, VirtIODevice *vdev,
                              bool vrings, bool force)
@@ -2181,17 +2284,56 @@ static int do_vhost_dev_stop(struct vhost_dev *hdev, VirtIODevice *vdev,
     return rc;
 }
 
+/*
+ * 在以下使用vhost_dev_stop():
+ *   - backends/cryptodev-vhost.c|113| <<cryptodev_vhost_stop_one>> vhost_dev_stop(&crypto->dev, dev, false);
+ *   - backends/vhost-user.c|111| <<vhost_user_backend_stop>> ret = vhost_dev_stop(&b->dev, b->vdev, true);
+ *   - hw/block/vhost-user-blk.c|228| <<vhost_user_blk_stop>> vhost_dev_stop(&s->dev, vdev, true);
+ *   - hw/net/vhost_net.c|382| <<vhost_net_start_one>> vhost_dev_stop(&net->dev, dev, false);
+ *   - hw/net/vhost_net.c|401| <<vhost_net_stop_one>> vhost_dev_stop(&net->dev, dev, false);
+ *   - hw/net/vhost_net.c|689| <<vhost_net_virtqueue_restart>> vhost_dev_stop(&net->dev, vdev, false);
+ *   - hw/scsi/vhost-scsi-common.c|111| <<vhost_scsi_common_stop>> ret = vhost_dev_stop(&vsc->dev, vdev, true);
+ *   - hw/virtio/vdpa-dev.c|304| <<vhost_vdpa_device_stop>> vhost_dev_stop(&s->dev, vdev, false);
+ *   - hw/virtio/vhost-user-base.c|80| <<vub_stop>> ret = vhost_dev_stop(&vub->vhost_dev, vdev, true);
+ */
 int vhost_dev_stop(struct vhost_dev *hdev, VirtIODevice *vdev, bool vrings)
 {
+    /*
+     * 在以下使用do_vhost_dev_stop():
+     *   - hw/virtio/vhost.c|2202| <<vhost_dev_stop>> return do_vhost_dev_stop(hdev, vdev, vrings, false);
+     *   - hw/virtio/vhost.c|2208| <<vhost_dev_force_stop>> return do_vhost_dev_stop(hdev, vdev, vrings, true);
+     */
     return do_vhost_dev_stop(hdev, vdev, vrings, false);
 }
 
+/*
+ * 在以下使用vhost_dev_force_stop():
+ *   - hw/block/vhost-user-blk.c|227| <<vhost_user_blk_stop>> ret = force_stop ?
+ *                                          vhost_dev_force_stop(&s->dev, vdev, true) :
+ *                                          vhost_dev_stop(&s->dev, vdev, true);
+ */
 int vhost_dev_force_stop(struct vhost_dev *hdev, VirtIODevice *vdev,
                          bool vrings)
 {
+    /*
+     * 在以下使用do_vhost_dev_stop():
+     *   - hw/virtio/vhost.c|2202| <<vhost_dev_stop>> return do_vhost_dev_stop(hdev, vdev, vrings, false);
+     *   - hw/virtio/vhost.c|2208| <<vhost_dev_force_stop>> return do_vhost_dev_stop(hdev, vdev, vrings, true);
+     */
     return do_vhost_dev_stop(hdev, vdev, vrings, true);
 }
 
+/*
+ * 在以下使用vhost_net_set_backend():
+ *   - hw/net/vhost_net.c|364| <<vhost_net_start_one>> r = vhost_net_set_backend(&net->dev, &file);
+ *   - hw/net/vhost_net.c|388| <<vhost_net_start_one>> int ret = vhost_net_set_backend(&net->dev, &file);
+ *   - hw/net/vhost_net.c|419| <<vhost_net_stop_one>> int r = vhost_net_set_backend(&net->dev, &file);
+ *   - hw/net/vhost_net.c|669| <<vhost_net_virtqueue_reset>> int r = vhost_net_set_backend(&net->dev, &file);
+ *   - hw/net/vhost_net.c|707| <<vhost_net_virtqueue_restart>> r = vhost_net_set_backend(&net->dev, &file);
+ *   - hw/net/vhost_net.c|722| <<vhost_net_virtqueue_restart>> int ret = vhost_net_set_backend(&net->dev, &file);
+ *   - hw/virtio/vhost.c|2317| <<vhost_net_set_backend>> if (hdev->vhost_ops->vhost_net_set_backend) {
+ *   - hw/virtio/vhost.c|2318| <<vhost_net_set_backend>> return hdev->vhost_ops->vhost_net_set_backend(hdev, file);
+ */
 int vhost_net_set_backend(struct vhost_dev *hdev,
                           struct vhost_vring_file *file)
 {
diff --git a/hw/virtio/virtio-balloon.c b/hw/virtio/virtio-balloon.c
index db787d00b..7f9472a9c 100644
--- a/hw/virtio/virtio-balloon.c
+++ b/hw/virtio/virtio-balloon.c
@@ -140,6 +140,10 @@ static void balloon_inflate_page(VirtIOBalloon *balloon,
     }
 }
 
+/*
+ * 在以下使用balloon_deflate_page():
+ *   - hw/virtio/virtio-balloon.c|445| <<virtio_balloon_handle_output>> balloon_deflate_page(s, section.mr, section.offset_within_region);
+ */
 static void balloon_deflate_page(VirtIOBalloon *balloon,
                                  MemoryRegion *mr, hwaddr mr_offset)
 {
diff --git a/hw/virtio/virtio-pci.c b/hw/virtio/virtio-pci.c
index 767216d79..de86ad76a 100644
--- a/hw/virtio/virtio-pci.c
+++ b/hw/virtio/virtio-pci.c
@@ -216,6 +216,16 @@ static int virtio_pci_load_queue(DeviceState *d, int n, QEMUFile *f)
     } else {
         vector = VIRTIO_NO_VECTOR;
     }
+    /*
+     * 在以下使用virtio_queue_set_vector():
+     *   - hw/s390x/virtio-ccw.c|230| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, VIRTIO_NO_VECTOR);
+     *   - hw/s390x/virtio-ccw.c|245| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, index);
+     *   - hw/s390x/virtio-ccw.c|1125| <<virtio_ccw_load_queue>> virtio_queue_set_vector(vdev, n , vector);
+     *   - hw/virtio/virtio-pci.c|219| <<virtio_pci_load_queue>> virtio_queue_set_vector(vdev, n, vector);
+     *   - hw/virtio/virtio-pci.c|468| <<virtio_ioport_write>> virtio_queue_set_vector(vdev, vdev->queue_sel, val);
+     *   - hw/virtio/virtio-pci.c|1454| <<virtio_pci_set_vector>> virtio_queue_set_vector(vdev, queue_no, new_vector);
+     *   - hw/virtio/virtio.c|2303| <<__virtio_queue_reset>> virtio_queue_set_vector(vdev, i, VIRTIO_NO_VECTOR);
+     */
     virtio_queue_set_vector(vdev, n, vector);
     if (vector != VIRTIO_NO_VECTOR) {
         msix_vector_use(&proxy->pci_dev, vector);
@@ -465,6 +475,16 @@ static void virtio_ioport_write(void *opaque, uint32_t addr, uint32_t val)
         } else {
             val = VIRTIO_NO_VECTOR;
         }
+        /*
+	 * 在以下使用virtio_queue_set_vector():
+         *   - hw/s390x/virtio-ccw.c|230| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, VIRTIO_NO_VECTOR);
+         *   - hw/s390x/virtio-ccw.c|245| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, index);
+         *   - hw/s390x/virtio-ccw.c|1125| <<virtio_ccw_load_queue>> virtio_queue_set_vector(vdev, n , vector);
+         *   - hw/virtio/virtio-pci.c|219| <<virtio_pci_load_queue>> virtio_queue_set_vector(vdev, n, vector);
+         *   - hw/virtio/virtio-pci.c|468| <<virtio_ioport_write>> virtio_queue_set_vector(vdev, vdev->queue_sel, val);
+         *   - hw/virtio/virtio-pci.c|1454| <<virtio_pci_set_vector>> virtio_queue_set_vector(vdev, queue_no, new_vector);
+         *   - hw/virtio/virtio.c|2303| <<__virtio_queue_reset>> virtio_queue_set_vector(vdev, i, VIRTIO_NO_VECTOR);
+	 */
         virtio_queue_set_vector(vdev, vdev->queue_sel, val);
         break;
     default:
@@ -1451,6 +1471,16 @@ static void virtio_pci_set_vector(VirtIODevice *vdev,
     if (queue_no == VIRTIO_CONFIG_IRQ_IDX) {
         vdev->config_vector = new_vector;
     } else {
+        /*
+	 * 在以下使用virtio_queue_set_vector():
+         *   - hw/s390x/virtio-ccw.c|230| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, VIRTIO_NO_VECTOR);
+         *   - hw/s390x/virtio-ccw.c|245| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, index);
+	 *   - hw/s390x/virtio-ccw.c|1125| <<virtio_ccw_load_queue>> virtio_queue_set_vector(vdev, n , vector);
+         *   - hw/virtio/virtio-pci.c|219| <<virtio_pci_load_queue>> virtio_queue_set_vector(vdev, n, vector);
+         *   - hw/virtio/virtio-pci.c|468| <<virtio_ioport_write>> virtio_queue_set_vector(vdev, vdev->queue_sel, val);
+         *   - hw/virtio/virtio-pci.c|1454| <<virtio_pci_set_vector>> virtio_queue_set_vector(vdev, queue_no, new_vector);
+         *   - hw/virtio/virtio.c|2303| <<__virtio_queue_reset>> virtio_queue_set_vector(vdev, i, VIRTIO_NO_VECTOR);
+	 */
         virtio_queue_set_vector(vdev, queue_no, new_vector);
     }
     /* If the new vector changed need to set it up. */
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index 9a81ad912..f7d568eb8 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -2300,6 +2300,16 @@ static void __virtio_queue_reset(VirtIODevice *vdev, uint32_t i)
     vdev->vq[i].last_avail_wrap_counter = true;
     vdev->vq[i].shadow_avail_wrap_counter = true;
     vdev->vq[i].used_wrap_counter = true;
+    /*
+     * 在以下使用virtio_queue_set_vector():
+     *   - hw/s390x/virtio-ccw.c|230| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, VIRTIO_NO_VECTOR);
+     *   - hw/s390x/virtio-ccw.c|245| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, index);
+     *   - hw/s390x/virtio-ccw.c|1125| <<virtio_ccw_load_queue>> virtio_queue_set_vector(vdev, n , vector);
+     *   - hw/virtio/virtio-pci.c|219| <<virtio_pci_load_queue>> virtio_queue_set_vector(vdev, n, vector);
+     *   - hw/virtio/virtio-pci.c|468| <<virtio_ioport_write>> virtio_queue_set_vector(vdev, vdev->queue_sel, val);
+     *   - hw/virtio/virtio-pci.c|1454| <<virtio_pci_set_vector>> virtio_queue_set_vector(vdev, queue_no, new_vector);
+     *   - hw/virtio/virtio.c|2303| <<__virtio_queue_reset>> virtio_queue_set_vector(vdev, i, VIRTIO_NO_VECTOR);
+     */
     virtio_queue_set_vector(vdev, i, VIRTIO_NO_VECTOR);
     vdev->vq[i].signalled_used = 0;
     vdev->vq[i].signalled_used_valid = false;
@@ -2497,6 +2507,16 @@ uint16_t virtio_queue_vector(VirtIODevice *vdev, int n)
         VIRTIO_NO_VECTOR;
 }
 
+/*
+ * 在以下使用virtio_queue_set_vector():
+ *   - hw/s390x/virtio-ccw.c|230| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, VIRTIO_NO_VECTOR);
+ *   - hw/s390x/virtio-ccw.c|245| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, index);
+ *   - hw/s390x/virtio-ccw.c|1125| <<virtio_ccw_load_queue>> virtio_queue_set_vector(vdev, n , vector);
+ *   - hw/virtio/virtio-pci.c|219| <<virtio_pci_load_queue>> virtio_queue_set_vector(vdev, n, vector);
+ *   - hw/virtio/virtio-pci.c|468| <<virtio_ioport_write>> virtio_queue_set_vector(vdev, vdev->queue_sel, val);
+ *   - hw/virtio/virtio-pci.c|1454| <<virtio_pci_set_vector>> virtio_queue_set_vector(vdev, queue_no, new_vector);
+ *   - hw/virtio/virtio.c|2303| <<__virtio_queue_reset>> virtio_queue_set_vector(vdev, i, VIRTIO_NO_VECTOR);
+ */
 void virtio_queue_set_vector(VirtIODevice *vdev, int n, uint16_t vector)
 {
     VirtQueue *vq = &vdev->vq[n];
@@ -2514,6 +2534,9 @@ void virtio_queue_set_vector(VirtIODevice *vdev, int n, uint16_t vector)
     }
 }
 
+/*
+ * 很多调用
+ */
 VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,
                             VirtIOHandleOutput handle_output)
 {
@@ -3023,9 +3046,20 @@ int virtio_save(VirtIODevice *vdev, QEMUFile *f)
          * Save desc now, the rest of the ring addresses are saved in
          * subsections for VIRTIO-1 devices.
          */
+        /*
+	 * VirtIODevice *vdev:
+         * -> VirtQueue *vq;
+         *    -> VRing vring;
+         *       -> hwaddr desc;
+	 *       -> hwaddr avail;
+         *       -> hwaddr used;
+	 */
         qemu_put_be64(f, vdev->vq[i].vring.desc);
         qemu_put_be16s(f, &vdev->vq[i].last_avail_idx);
         if (k->save_queue) {
+            /*
+	     * virtio_pci_save_queue()
+	     */
             k->save_queue(qbus->parent, i, f);
         }
     }
@@ -3069,6 +3103,13 @@ const VMStateInfo  virtio_vmstate_info = {
     .put = virtio_device_put,
 };
 
+/*
+ * 在以下使用virtio_set_features_nocheck():
+ *   - hw/virtio/virtio.c|3127| <<virtio_set_features_nocheck_bh>> data->ret = virtio_set_features_nocheck(data->vdev, data->val);
+ *   - hw/virtio/virtio.c|3145| <<virtio_set_features_nocheck_maybe_co>> return virtio_set_features_nocheck(vdev, val);
+ *   - hw/virtio/virtio.c|3166| <<virtio_set_features>> ret = virtio_set_features_nocheck(vdev, val);
+ *   - hw/virtio/virtio.c|3215| <<virtio_reset>> virtio_set_features_nocheck(vdev, 0);
+ */
 static int virtio_set_features_nocheck(VirtIODevice *vdev, uint64_t val)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -3115,6 +3156,15 @@ virtio_set_features_nocheck_maybe_co(VirtIODevice *vdev, uint64_t val)
     }
 }
 
+/*
+ * 在以下使用virtio_set_features():
+ *   - hw/s390x/virtio-ccw.c|431| <<virtio_ccw_cb>> virtio_set_features(vdev,
+  4 hw/s390x/virtio-ccw.c|440| <<virtio_ccw_cb>> virtio_set_features(vdev,
+  5 hw/virtio/virtio-mmio.c|319| <<virtio_mmio_write>> virtio_set_features(vdev, value);
+  6 hw/virtio/virtio-mmio.c|431| <<virtio_mmio_write>> virtio_set_features(vdev,
+  7 hw/virtio/virtio-pci.c|405| <<virtio_ioport_write>> virtio_set_features(vdev, val);
+  8 hw/virtio/virtio-pci.c|1623| <<virtio_pci_common_write>> virtio_set_features(vdev,
+ */
 int virtio_set_features(VirtIODevice *vdev, uint64_t val)
 {
     int ret;
@@ -3304,6 +3354,14 @@ virtio_load(VirtIODevice *vdev, QEMUFile *f, int version_id)
         vdev->vq[i].signalled_used_valid = false;
         vdev->vq[i].notification = true;
 
+        /*
+	 * VirtIODevice *vdev:
+	 * -> VirtQueue *vq;
+	 *    -> VRing vring;
+	 *       -> hwaddr desc;         
+	 *       -> hwaddr avail;        
+	 *       -> hwaddr used;
+	 */
         if (!vdev->vq[i].vring.desc && vdev->vq[i].last_avail_idx) {
             error_report("VQ %d address 0x0 "
                          "inconsistent with Host index 0x%x",
@@ -3444,6 +3502,11 @@ void virtio_cleanup(VirtIODevice *vdev)
     qemu_del_vm_change_state_handler(vdev->vmstate);
 }
 
+/*
+ * 在以下使用virtio_vmstate_change():
+ *   - hw/virtio/virtio.c|3560| <<virtio_init>> vdev->vmstate = qdev_add_vm_change_state_handler(DEVICE(vdev),
+ *                  NULL, virtio_vmstate_change, vdev);
+ */
 static int virtio_vmstate_change(void *opaque, bool running, RunState state)
 {
     VirtIODevice *vdev = opaque;
@@ -3517,6 +3580,15 @@ void virtio_init(VirtIODevice *vdev, uint16_t device_id, size_t config_size)
     } else {
         vdev->config = NULL;
     }
+    /*
+     * 在以下使用qdev_add_vm_change_state_handler():
+     *   - hw/block/virtio-blk.c|1806| <<virtio_blk_device_realize>> qdev_add_vm_change_state_handler(dev,
+     *        virtio_blk_dma_restart_cb, NULL, s);
+     *   - hw/scsi/scsi-bus.c|402| <<scsi_qdev_realize>> dev->vmsentry = qdev_add_vm_change_state_handler(DEVICE(dev),
+     *        scsi_dma_restart_cb, NULL, dev);
+     *   - hw/virtio/virtio.c|3580| <<virtio_init>> vdev->vmstate = qdev_add_vm_change_state_handler(DEVICE(vdev),
+     *        NULL, virtio_vmstate_change, vdev);
+     */
     vdev->vmstate = qdev_add_vm_change_state_handler(DEVICE(vdev),
             NULL, virtio_vmstate_change, vdev);
     vdev->device_endian = virtio_default_endian();
diff --git a/include/accel/accel-cpu-ops.h b/include/accel/accel-cpu-ops.h
index 067476491..ff55112b2 100644
--- a/include/accel/accel-cpu-ops.h
+++ b/include/accel/accel-cpu-ops.h
@@ -49,7 +49,25 @@ struct AccelOpsClass {
      * Request to synchronize QEMU vCPU registers to the hardware accelerator
      * (QEMU is the reference).
      */
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_reset():
+     *   - accel/hvf/hvf-accel-ops.c|380| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|100| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - system/cpus.c|289| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - system/cpus.c|290| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     void (*synchronize_post_reset)(CPUState *cpu);
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     void (*synchronize_post_init)(CPUState *cpu);
     /**
      * synchronize_state:
@@ -59,7 +77,25 @@ struct AccelOpsClass {
      * Request to synchronize QEMU vCPU registers from the hardware accelerator
      * (the hardware accelerator is the reference).
      */
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state():
+     *   - accel/hvf/hvf-accel-ops.c|382| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|111| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - system/cpus.c|204| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|205| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|94| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|97| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     void (*synchronize_state)(CPUState *cpu);
+    /*
+     * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+     *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+     *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+     *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+     *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+     */
     void (*synchronize_pre_loadvm)(CPUState *cpu);
 
     /* handle_interrupt is mandatory. */
diff --git a/include/hw/i386/apic_internal.h b/include/hw/i386/apic_internal.h
index 429278da6..446f6e004 100644
--- a/include/hw/i386/apic_internal.h
+++ b/include/hw/i386/apic_internal.h
@@ -137,10 +137,27 @@ struct APICCommonClass {
 
     DeviceRealize realize;
     DeviceUnrealize unrealize;
+    /*
+     * 在以下使用APICCommonClass->set_base:
+     *   - hw/i386/kvm/apic.c|268| <<kvm_apic_class_init>> k->set_base = kvm_apic_set_base;
+     *   - hw/i386/xen/xen_apic.c|84| <<xen_apic_class_init>> k->set_base = xen_apic_set_base;
+     *   - hw/intc/apic.c|1185| <<apic_class_init>> k->set_base = apic_set_base;
+     *   - hw/intc/apic_common.c|47| <<cpu_set_apic_base>> return info->set_base(s, val);
+     *   - target/i386/whpx/whpx-apic.c|261| <<whpx_apic_class_init>> k->set_base = whpx_apic_set_base;
+     */
     int (*set_base)(APICCommonState *s, uint64_t val);
     void (*set_tpr)(APICCommonState *s, uint8_t val);
     uint8_t (*get_tpr)(APICCommonState *s);
     void (*enable_tpr_reporting)(APICCommonState *s, bool enable);
+    /*
+     * 在以下使用APICCommonClass->vapic_base_update:
+     *   - hw/i386/kvm/apic.c|260| <<kvm_apic_class_init>> k->vapic_base_update = kvm_apic_vapic_base_update;
+     *   - hw/i386/xen/xen_apic.c|87| <<xen_apic_class_init>> k->vapic_base_update = xen_apic_vapic_base_update;
+     *   - hw/intc/apic.c|1188| <<apic_class_init>> k->vapic_base_update = apic_vapic_base_update;
+     *   - hw/intc/apic_common.c|125| <<apic_enable_vapic>> info->vapic_base_update(s);
+     *   - hw/intc/apic_common.c|263| <<apic_reset_common>> info->vapic_base_update(s);
+     *   - target/i386/whpx/whpx-apic.c|265| <<whpx_apic_class_init>> k->vapic_base_update = whpx_apic_vapic_base_update;
+     */
     void (*vapic_base_update)(APICCommonState *s);
     void (*external_nmi)(APICCommonState *s);
     void (*pre_save)(APICCommonState *s);
@@ -159,6 +176,43 @@ struct APICCommonState {
 
     MemoryRegion io_memory;
     X86CPU *cpu;
+    /*
+     * 在以下设置APICCommonState->apicbase:
+     *   - hw/i386/kvm/apic.c|101| <<kvm_apic_set_base>> s->apicbase = val;
+     *   - hw/intc/apic.c|353| <<apic_set_base>> s->apicbase = (val & MSR_IA32_APICBASE_BASE) |
+     *   - hw/intc/apic.c|354| <<apic_set_base>> s->apicbase = (val & MSR_IA32_APICBASE_BASE) |
+     *                    (s->apicbase & (MSR_IA32_APICBASE_BSP | MSR_IA32_APICBASE_ENABLE));
+     *   - hw/intc/apic.c|356| <<apic_set_base>> s->apicbase &= ~MSR_IA32_APICBASE_ENABLE;
+     *   - hw/intc/apic.c|364| <<apic_set_base>> s->apicbase |= MSR_IA32_APICBASE_ENABLE;
+     *   - hw/intc/apic.c|372| <<apic_set_base>> s->apicbase |= MSR_IA32_APICBASE_EXTD;
+     *   - hw/intc/apic_common.c|267| <<apic_designate_bsp>> s->apicbase |= MSR_IA32_APICBASE_BSP;
+     *   - hw/intc/apic_common.c|269| <<apic_designate_bsp>> s->apicbase &= ~MSR_IA32_APICBASE_BSP;
+     *   - hw/intc/apic_common.c|280| <<apic_reset_common>> s->apicbase = APIC_DEFAULT_ADDRESS | bsp | MSR_IA32_APICBASE_ENABLE;
+     *   - target/i386/cpu-apic.c|59| <<x86_cpu_apic_create>> apic->apicbase = APIC_DEFAULT_ADDRESS | MSR_IA32_APICBASE_ENABLE;
+     *   - target/i386/whpx/whpx-apic.c|95| <<whpx_apic_set_base>> s->apicbase = val;
+     * 在以下使用APICCommonState->apicbase:
+     *   - hw/intc/apic_common.c|415| <<global>> VMSTATE_UINT32(apicbase, APICCommonState),
+     *   - hw/i386/kvm/apic.c|39| <<kvm_put_apic_state>> if (kvm_has_x2apic_api() && s->apicbase & MSR_IA32_APICBASE_EXTD) {
+     *   - hw/i386/kvm/apic.c|68| <<kvm_get_apic_state>> if (kvm_has_x2apic_api() && s->apicbase & MSR_IA32_APICBASE_EXTD) {
+     *   - hw/i386/kvm/apic.c|162| <<kvm_apic_put>> kvm_put_apicbase(s->cpu, s->apicbase);
+     *   - hw/intc/apic.c|307| <<is_x2apic_mode>> return s->apicbase & MSR_IA32_APICBASE_EXTD;
+     *   - hw/intc/apic.c|329| <<apic_set_base_check>> if (!(s->apicbase & MSR_IA32_APICBASE_ENABLE) && !(s->apicbase & MSR_IA32_APICBASE_EXTD) &&
+     *   - hw/intc/apic.c|330| <<apic_set_base_check>> if (!(s->apicbase & MSR_IA32_APICBASE_ENABLE) && !(s->apicbase & MSR_IA32_APICBASE_EXTD) &&
+     *   - hw/intc/apic.c|337| <<apic_set_base_check>> if ((s->apicbase & MSR_IA32_APICBASE_ENABLE) && (s->apicbase & MSR_IA32_APICBASE_EXTD) &&
+     *   - hw/intc/apic.c|338| <<apic_set_base_check>> if ((s->apicbase & MSR_IA32_APICBASE_ENABLE) && (s->apicbase & MSR_IA32_APICBASE_EXTD) &&
+     *   - hw/intc/apic.c|362| <<apic_set_base>> if (!(s->apicbase & MSR_IA32_APICBASE_ENABLE) &&
+     *   - hw/intc/apic.c|370| <<apic_set_base>> if (cpu_has_x2apic_feature(&s->cpu->env) && !(s->apicbase & MSR_IA32_APICBASE_EXTD) &&
+     *   - hw/intc/apic.c|599| <<apic_get_delivery_bitmask>> if (apic->apicbase & MSR_IA32_APICBASE_EXTD) {
+     *   - hw/intc/apic.c|766| <<apic_accept_pic_intr>> if ((s->apicbase & MSR_IA32_APICBASE_ENABLE) == 0 ||
+     *   - hw/intc/apic_common.c|57| <<cpu_get_apic_base>> trace_cpu_get_apic_base((uint64_t)s->apicbase);
+     *   - hw/intc/apic_common.c|58| <<cpu_get_apic_base>> return s->apicbase;
+     *   - hw/intc/apic_common.c|75| <<cpu_is_apic_enabled>> return s->apicbase & MSR_IA32_APICBASE_ENABLE;
+     *   - hw/intc/apic_common.c|279| <<apic_reset_common>> bsp = s->apicbase & MSR_IA32_APICBASE_BSP;
+     *   - hw/intc/apic_common.c|457| <<apic_common_get_id>> value = s->apicbase & MSR_IA32_APICBASE_EXTD ? s->initial_apic_id : s->id;
+     *   - target/i386/cpu-apic.c|83| <<x86_cpu_apic_realize>> memory_region_add_subregion_overlap(get_system_memory(),
+     *                              apic->apicbase & MSR_IA32_APICBASE_BASE, &apic->io_memory, 0x1000);
+     *   - target/i386/whpx/whpx-apic.c|137| <<whpx_apic_put>> whpx_put_apic_base(CPU(s->cpu), s->apicbase);
+     */
     uint32_t apicbase;
     uint8_t id; /* legacy APIC ID */
     uint32_t initial_apic_id;
diff --git a/include/hw/i386/pc.h b/include/hw/i386/pc.h
index 79b72c54d..8952dfbbd 100644
--- a/include/hw/i386/pc.h
+++ b/include/hw/i386/pc.h
@@ -116,6 +116,14 @@ struct PCMachineClass {
     /* use PVH to load kernels that support this feature */
     bool pvh_enabled;
 
+    /*
+     * 在以下使用PCMachineClass->kvmclock_create_always:
+     *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> pcmc->kvmclock_create_always = true;
+     *   - hw/i386/pc_piix.c|196| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_piix.c|669| <<pc_i440fx_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+     *   - hw/i386/pc_q35.c|535| <<pc_q35_machine_5_1_options>> pcmc->kvmclock_create_always = false;
+     */
     /* create kvmclock device even when KVM PV features are not exposed */
     bool kvmclock_create_always;
 
diff --git a/include/hw/virtio/virtio-net.h b/include/hw/virtio/virtio-net.h
index 73fdefc0d..e6bfe912a 100644
--- a/include/hw/virtio/virtio-net.h
+++ b/include/hw/virtio/virtio-net.h
@@ -207,8 +207,30 @@ struct VirtIONet {
     NICConf nic_conf;
     DeviceState *qdev;
     int multiqueue;
+    /*
+     * 在以下修改VirtIONet->max_queue_pairs:
+     *   - hw/net/virtio-net.c|3562| <<global>> VMSTATE_SINGLE_TEST(max_queue_pairs, VirtIONet, max_queue_pairs_gt_1, 0,
+     *   - hw/net/virtio-net.c|3897| <<virtio_net_device_realize>> ++n->max_queue_pairs;
+     *   - hw/net/virtio-net.c|3901| <<virtio_net_device_realize>> n->max_queue_pairs = MAX(n->max_queue_pairs, 1);
+     */
     uint16_t max_queue_pairs;
+    /*
+     * 在以下修改VirtIONet->curr_queue_pairs:
+     *   - hw/net/virtio-net.c|1482| <<virtio_net_handle_mq>> n->curr_queue_pairs = queue_pairs;
+     *   - hw/net/virtio-net.c|3911| <<virtio_net_device_realize>> n->curr_queue_pairs = 1;
+     *   - hw/net/virtio-net.c|4057| <<virtio_net_reset>> n->curr_queue_pairs = 1;
+     *   - hw/net/virtio-net.c|3564| <<global>> VMSTATE_UINT16_TEST(curr_queue_pairs, VirtIONet, max_queue_pairs_gt_1),
+     */
     uint16_t curr_queue_pairs;
+    /*
+     * 在以下使用VirtIONet->max_ncs:
+     *   - hw/net/virtio-net.c|269| <<virtio_net_vhost_status>> int cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     *   - hw/net/virtio-net.c|3899| <<virtio_net_device_realize>> n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
+     *   - hw/net/virtio-net.c|3906| <<virtio_net_device_realize>> for (i = 0; i < n->max_ncs; i++) {
+     *   - net/vhost-vdpa.c|358| <<vhost_vdpa_net_log_global_enable>> cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     */
     uint16_t max_ncs;
     size_t config_size;
     char *netclient_name;
diff --git a/include/hw/virtio/virtio-scsi.h b/include/hw/virtio/virtio-scsi.h
index 31e852ed6..54cf20800 100644
--- a/include/hw/virtio/virtio-scsi.h
+++ b/include/hw/virtio/virtio-scsi.h
@@ -90,6 +90,34 @@ struct VirtIOSCSI {
 
     QemuMutex ctrl_lock; /* protects ctrl_vq */
 
+    /*
+     * 在以下使用VirtIOSCSIReq->vq_aio_context (**二维指针):
+     *   - hw/scsi/virtio-scsi-dataplane.c|52| <<virtio_scsi_dataplane_setup>> s->vq_aio_context = g_new(AioContext *,
+     *         vs->conf.num_queues + VIRTIO_SCSI_VQ_NUM_FIXED);
+     *   - hw/scsi/virtio-scsi-dataplane.c|59| <<virtio_scsi_dataplane_setup>> s->vq_aio_context[0] = qemu_get_aio_context();
+     *   - hw/scsi/virtio-scsi-dataplane.c|65| <<virtio_scsi_dataplane_setup>> s->vq_aio_context[1] = qemu_get_aio_context();
+     *   - hw/scsi/virtio-scsi-dataplane.c|69| <<virtio_scsi_dataplane_setup>> if (!iothread_vq_mapping_apply(
+     *         vs->conf.iothread_vq_mapping_list, &s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED], vs->conf.num_queues, errp)) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|71| <<virtio_scsi_dataplane_setup>> g_free(s->vq_aio_context);
+     *   - hw/scsi/virtio-scsi-dataplane.c|72| <<virtio_scsi_dataplane_setup>> s->vq_aio_context = NULL;
+     *   - hw/scsi/virtio-scsi-dataplane.c|78| <<virtio_scsi_dataplane_setup>> s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED + i] = ctx;
+     *   - hw/scsi/virtio-scsi-dataplane.c|86| <<virtio_scsi_dataplane_setup>> s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED + i] = ctx;
+     *   - hw/scsi/virtio-scsi-dataplane.c|104| <<virtio_scsi_dataplane_cleanup>> g_free(s->vq_aio_context);
+     *   - hw/scsi/virtio-scsi-dataplane.c|105| <<virtio_scsi_dataplane_cleanup>> s->vq_aio_context = NULL;
+     *   - hw/scsi/virtio-scsi-dataplane.c|204| <<virtio_scsi_dataplane_start>> virtio_queue_aio_attach_host_notifier(vs->ctrl_vq,
+     *         s->vq_aio_context[0]);
+     *   - hw/scsi/virtio-scsi-dataplane.c|206| <<virtio_scsi_dataplane_start>> virtio_queue_aio_attach_host_notifier_no_poll(vs->event_vq,
+     *         s->vq_aio_context[1]);
+     *   - hw/scsi/virtio-scsi-dataplane.c|209| <<virtio_scsi_dataplane_start>> AioContext *ctx = s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED + i];
+     *   - hw/scsi/virtio-scsi-dataplane.c|261| <<virtio_scsi_dataplane_stop>> AioContext *ctx = s->vq_aio_context[i];
+     *   - hw/scsi/virtio-scsi.c|406| <<virtio_scsi_flush_defer_tmf_to_aio_context>> AioContext *ctx = s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED + i];
+     *   - hw/scsi/virtio-scsi.c|564| <<virtio_scsi_do_tmf>> ctx = s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED + i];
+     *   - hw/scsi/virtio-scsi.c|695| <<virtio_scsi_defer_to_dataplane>> if (s->vq_aio_context[0] == qemu_get_aio_context()) {
+     *   - hw/scsi/virtio-scsi.c|1175| <<virtio_scsi_hotplug>> AioContext *ctx = s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED];
+     *   - hw/scsi/virtio-scsi.c|1219| <<virtio_scsi_hotunplug>> if (s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED] != qemu_get_aio_context()) {
+     *   - hw/scsi/virtio-scsi.c|1253| <<virtio_scsi_drained_begin>> virtio_queue_aio_detach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/scsi/virtio-scsi.c|1279| <<virtio_scsi_drained_end>> AioContext *ctx = s->vq_aio_context[i];
+     */
     /* Fields for dataplane below */
     AioContext **vq_aio_context; /* per-virtqueue AioContext pointer */
 
diff --git a/include/migration/vmstate.h b/include/migration/vmstate.h
index 1ff7bd9ac..f07b95777 100644
--- a/include/migration/vmstate.h
+++ b/include/migration/vmstate.h
@@ -1225,6 +1225,28 @@ int vmstate_register_with_alias_id(VMStateIf *obj, uint32_t instance_id,
  *
  * Returns: 0 on success, -1 on failure
  */
+/*
+ * 在以下使用vmstate_register():
+ *   - hw/arm/virt-acpi-build.c|1254| <<virt_acpi_setup>> vmstate_register(NULL, 0, &vmstate_virt_acpi_build, build_state);
+ *   - hw/core/cpu-system.c|289| <<cpu_vmstate_register>> vmstate_register(NULL, cpu->cpu_index, &vmstate_cpu_common, cpu);
+ *   - hw/core/cpu-system.c|292| <<cpu_vmstate_register>> vmstate_register(NULL, cpu->cpu_index,
+ *   - hw/i386/acpi-build.c|2241| <<acpi_setup>> vmstate_register(NULL, 0, &vmstate_acpi_build, build_state);
+ *   - hw/loongarch/virt-acpi-build.c|737| <<virt_acpi_setup>> vmstate_register(NULL, 0, &vmstate_acpi_build, build_state);
+ *   - hw/openrisc/cputimer.c|167| <<cpu_openrisc_clock_init>> vmstate_register(NULL, 0, &vmstate_or1k_timer, or1k_timer);
+ *   - hw/ppc/spapr.c|3102| <<spapr_machine_init>> vmstate_register(NULL, 0, &vmstate_spapr, spapr);
+ *   - hw/ppc/spapr_cpu_core.c|294| <<spapr_realize_vcpu>> vmstate_register(NULL, cs->cpu_index, &vmstate_spapr_cpu_state,
+ *   - hw/ppc/spapr_drc.c|547| <<drc_realize>> vmstate_register(VMSTATE_IF(drc), spapr_drc_index(drc), &vmstate_spapr_drc,
+ *   - hw/ppc/spapr_drc.c|653| <<realize_physical>> vmstate_register(VMSTATE_IF(drcp),
+ *   - hw/ppc/spapr_iommu.c|325| <<spapr_tce_table_realize>> vmstate_register(VMSTATE_IF(tcet), tcet->liobn, &vmstate_spapr_tce_table,
+ *   - hw/riscv/virt-acpi-build.c|1030| <<virt_acpi_setup>> vmstate_register(NULL, 0, &vmstate_virt_acpi_build, build_state);
+ *   - hw/s390x/css.c|390| <<css_register_vmstate>> vmstate_register(NULL, 0, &vmstate_css, &channel_subsys);
+ *   - hw/vfio/cpr-iommufd.c|165| <<vfio_iommufd_cpr_register_iommufd>> vmstate_register(NULL, -1, &iommufd_cpr_vmstate, be);
+ *   - hw/vfio/cpr-legacy.c|184| <<vfio_legacy_cpr_register_container>> vmstate_register(NULL, -1, &vfio_container_vmstate, container);
+ *   - migration/global_state.c|153| <<register_global_state>> vmstate_register(NULL, 0, &vmstate_globalstate, &global_state);
+ *   - replay/replay-snapshot.c|70| <<replay_vmstate_register>> vmstate_register(NULL, 0, &vmstate_replay, &replay_state);
+ *   - system/cpu-timers.c|274| <<cpu_timers_init>> vmstate_register(NULL, 0, &vmstate_timers, &timers_state);
+ *   - target/arm/hvf/hvf.c|2174| <<hvf_arch_init>> vmstate_register(NULL, 0, &vmstate_hvf_vtimer, &vtimer);
+ */
 static inline int vmstate_register(VMStateIf *obj, int instance_id,
                                    const VMStateDescription *vmsd,
                                    void *opaque)
diff --git a/include/net/net.h b/include/net/net.h
index 84ee18e0f..512837aab 100644
--- a/include/net/net.h
+++ b/include/net/net.h
@@ -126,6 +126,14 @@ typedef struct NICState {
     NICConf *conf;
     MemReentrancyGuard *reentrancy_guard;
     void *opaque;
+    /*
+     * 在以下使用NICState->peer_deleted:
+     *   - hw/net/virtio-net.c|756| <<virtio_net_set_queue_pairs>> if (n->nic->peer_deleted) {
+     *   - net/net.c|440| <<qemu_del_net_client>> if (nic->peer_deleted) {
+     *   - net/net.c|443| <<qemu_del_net_client>> nic->peer_deleted = true;
+     *   - net/net.c|475| <<qemu_del_nic>> if (nic->peer_deleted) {
+     *   - net/net.c|1724| <<net_cleanup>> if (nic->peer_deleted) {
+     */
     bool peer_deleted;
 } NICState;
 
diff --git a/include/system/kvm_int.h b/include/system/kvm_int.h
index 9247493b0..0d1aaa608 100644
--- a/include/system/kvm_int.h
+++ b/include/system/kvm_int.h
@@ -146,6 +146,13 @@ struct KVMState
     unsigned int gsi_count;
 #endif
     KVMMemoryListener memory_listener;
+    /*
+     * 在以下使用KVMState->kvm_parked_vcpus:
+     *   - accel/kvm/kvm-all.c|426| <<kvm_park_vcpu>> QLIST_INSERT_HEAD(&kvm_state->kvm_parked_vcpus, vcpu, node);
+     *   - accel/kvm/kvm-all.c|434| <<kvm_unpark_vcpu>> QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
+     *   - accel/kvm/kvm-all.c|456| <<kvm_reset_parked_vcpus>> QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
+     *   - accel/kvm/kvm-all.c|2729| <<kvm_init>> QLIST_INIT(&s->kvm_parked_vcpus);
+     */
     QLIST_HEAD(, KVMParkedVcpu) kvm_parked_vcpus;
 
     /* For "info mtree -f" to tell if an MR is registered in KVM */
@@ -156,6 +163,13 @@ struct KVMState
     } *as;
     uint64_t kvm_dirty_ring_bytes;  /* Size of the per-vcpu dirty ring */
     uint32_t kvm_dirty_ring_size;   /* Number of dirty GFNs per ring */
+    /*
+     * 在以下使用KVMState->kvm_dirty_ring_with_bitmap:
+     *   - accel/kvm/kvm-all.c|1559| <<kvm_set_phys_mem>> if (kvm_state->kvm_dirty_ring_with_bitmap) {
+     *   - accel/kvm/kvm-all.c|1723| <<kvm_dirty_ring_init>> s->kvm_dirty_ring_with_bitmap = true;
+     *   - accel/kvm/kvm-all.c|1853| <<kvm_log_sync_global>> if (s->kvm_dirty_ring_with_bitmap && last_stage &&
+     *   - accel/kvm/kvm-all.c|4054| <<kvm_accel_instance_init>> s->kvm_dirty_ring_with_bitmap = false;
+     */
     bool kvm_dirty_ring_with_bitmap;
     uint64_t kvm_eager_split_size;  /* Eager Page Splitting chunk size */
     struct KVMDirtyRingReaper reaper;
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 32c5885a3..acf0d6196 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -48,6 +48,13 @@ struct kvm_userspace_memory_region2 {
  * userspace, other bits are reserved for kvm internal use which are defined
  * in include/linux/kvm_host.h.
  */
+/*
+ * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+ *   - accel/kvm/kvm-all.c|660| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+ *   - accel/kvm/kvm-all.c|772| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+ *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+ *   - accel/kvm/kvm-all.c|1864| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+ */
 #define KVM_MEM_LOG_DIRTY_PAGES	(1UL << 0)
 #define KVM_MEM_READONLY	(1UL << 1)
 #define KVM_MEM_GUEST_MEMFD	(1UL << 2)
diff --git a/migration/block-dirty-bitmap.c b/migration/block-dirty-bitmap.c
index a061aad81..dd3bde16c 100644
--- a/migration/block-dirty-bitmap.c
+++ b/migration/block-dirty-bitmap.c
@@ -1264,6 +1264,17 @@ void dirty_bitmap_mig_init(void)
     QSIMPLEQ_INIT(&dbm_state.save.dbms_list);
     qemu_mutex_init(&dbm_state.load.lock);
 
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live("dirty-bitmap", 0, 1,
                          &savevm_dirty_bitmap_handlers,
                          &dbm_state);
diff --git a/migration/channel.c b/migration/channel.c
index a547b1fbf..971c2c426 100644
--- a/migration/channel.c
+++ b/migration/channel.c
@@ -30,6 +30,14 @@
  *
  * @ioc: Channel to which we are connecting
  */
+/*
+ * 在以下使用migration_channel_process_incoming():
+ *   - migration/exec.c|66| <<exec_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/fd.c|81| <<fd_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/file.c|132| <<file_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/socket.c|132| <<socket_accept_incoming_migration>> migration_channel_process_incoming(QIO_CHANNEL(cioc));
+ *   - migration/tls.c|69| <<migration_tls_incoming_handshake>> migration_channel_process_incoming(ioc);
+ */
 void migration_channel_process_incoming(QIOChannel *ioc)
 {
     MigrationState *s = migrate_get_current();
@@ -43,6 +51,9 @@ void migration_channel_process_incoming(QIOChannel *ioc)
         migration_tls_channel_process_incoming(s, ioc, &local_err);
     } else {
         migration_ioc_register_yank(ioc);
+        /*
+	 * 只在这里调用
+	 */
         migration_ioc_process_incoming(ioc, &local_err);
     }
 
@@ -64,6 +75,14 @@ void migration_channel_process_incoming(QIOChannel *ioc)
  * @hostname: Where we want to connect
  * @error: Error indicating failure to connect, free'd here
  */
+/*
+ * 在以下使用migration_channel_connect():
+ *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+ *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+ *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+ *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+ *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+ */
 void migration_channel_connect(MigrationState *s,
                                QIOChannel *ioc,
                                const char *hostname,
@@ -94,6 +113,11 @@ void migration_channel_connect(MigrationState *s,
             qemu_mutex_unlock(&s->qemu_file_lock);
         }
     }
+    /*
+     * 在以下使用migration_connect():
+     *   - migration/channel.c|108| <<migration_channel_connect>> migration_connect(s, error);
+     *   - migration/rdma.c|4002| <<rdma_start_outgoing_migration>> migration_connect(s, NULL);
+     */
     migration_connect(s, error);
     error_free(error);
 }
diff --git a/migration/colo.c b/migration/colo.c
index e0f713c83..407cdbe97 100644
--- a/migration/colo.c
+++ b/migration/colo.c
@@ -685,6 +685,16 @@ static void colo_incoming_process_checkpoint(MigrationIncomingState *mis,
     }
 
     bql_lock();
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
     ret = qemu_loadvm_state_main(mis->from_src_file, mis);
     bql_unlock();
diff --git a/migration/exec.c b/migration/exec.c
index 20e6cccf8..d52deff22 100644
--- a/migration/exec.c
+++ b/migration/exec.c
@@ -55,6 +55,14 @@ void exec_start_outgoing_migration(MigrationState *s, strList *command,
     }
 
     qio_channel_set_name(ioc, "migration-exec-outgoing");
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, NULL);
     object_unref(OBJECT(ioc));
 }
diff --git a/migration/fd.c b/migration/fd.c
index 9bf9be6ac..e86b00fdd 100644
--- a/migration/fd.c
+++ b/migration/fd.c
@@ -70,6 +70,14 @@ void fd_start_outgoing_migration(MigrationState *s, const char *fdname, Error **
     }
 
     qio_channel_set_name(ioc, "migration-fd-outgoing");
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, NULL);
     object_unref(OBJECT(ioc));
 }
diff --git a/migration/file.c b/migration/file.c
index bb8031e3c..9789c1035 100644
--- a/migration/file.c
+++ b/migration/file.c
@@ -122,9 +122,24 @@ void file_start_outgoing_migration(MigrationState *s,
         return;
     }
     qio_channel_set_name(ioc, "migration-file-outgoing");
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, NULL);
 }
 
+/*
+ * 在以下使用file_accept_incoming_migration():
+ *   - migration/file.c|170| <<file_create_incoming_channels>> qio_channel_add_watch_full(iocs[i], G_IO_IN,
+ *                                                    file_accept_incoming_migration,
+ *                                                    NULL, NULL,
+ *                                                    g_main_context_get_thread_default());
+ */
 static gboolean file_accept_incoming_migration(QIOChannel *ioc,
                                                GIOCondition condition,
                                                gpointer opaque)
diff --git a/migration/migration.c b/migration/migration.c
index 10c216d25..2eb8f7303 100644
--- a/migration/migration.c
+++ b/migration/migration.c
@@ -113,6 +113,10 @@ static bool close_return_path_on_source(MigrationState *s);
 static void migration_completion_end(MigrationState *s);
 static void migrate_hup_delete(MigrationState *s);
 
+/*
+ * 在以下使用migration_downtime_start():
+ *   - migration/migration.c|311| <<migration_stop_vm>> migration_downtime_start(s);
+ */
 static void migration_downtime_start(MigrationState *s)
 {
     trace_vmstate_downtime_checkpoint("src-downtime-start");
@@ -140,6 +144,12 @@ static void migrate_incoming_unref_outgoing_state(void)
     object_unref(migrate_get_current());
 }
 
+/*
+ * 在以下使用migration_downtime_end():
+ *   - migration/migration.c|3005| <<postcopy_start>> migration_downtime_end(ms);
+ *   - migration/migration.c|3603| <<migration_completion_end>> migration_downtime_end(s);
+ *   - migration/migration.c|4113| <<bg_migration_vm_start_bh>> migration_downtime_end(s);
+ */
 static void migration_downtime_end(MigrationState *s)
 {
     int64_t now = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);
@@ -287,6 +297,23 @@ static gint page_request_addr_cmp(gconstpointer ap, gconstpointer bp)
     return (a > b) - (a < b);
 }
 
+/*
+ * (gdb) bt
+ * #0  migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:292
+ * #1  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #2  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #3  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #4  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用migration_stop_vm():
+ *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+ *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+ *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+ *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+ */
 static int migration_stop_vm(MigrationState *s, RunState state)
 {
     int ret;
@@ -296,6 +323,13 @@ static int migration_stop_vm(MigrationState *s, RunState state)
     s->vm_old_state = runstate_get();
     global_state_store();
 
+    /*
+     * 在以下使用vm_stop_force_state():
+     *   - migration/colo.c|216| <<colo_do_failover>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/colo.c|432| <<colo_do_checkpoint_transaction>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/colo.c|668| <<colo_incoming_process_checkpoint>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/migration.c|306| <<migration_stop_vm>> ret = vm_stop_force_state(state);
+     */
     ret = vm_stop_force_state(state);
 
     trace_vmstate_downtime_checkpoint("src-vm-stopped");
@@ -321,6 +355,13 @@ void migration_object_init(void)
         g_array_new(FALSE, TRUE, sizeof(struct PostCopyFD));
     qemu_mutex_init(&current_incoming->rp_mutex);
     qemu_mutex_init(&current_incoming->postcopy_prio_thread_mutex);
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     qemu_event_init(&current_incoming->main_thread_load_event, false);
     qemu_sem_init(&current_incoming->postcopy_pause_sem_dst, 0);
     qemu_sem_init(&current_incoming->postcopy_pause_sem_fault, 0);
@@ -348,6 +389,10 @@ typedef struct {
     void *opaque;
 } MigrationBH;
 
+/*
+ * 在以下使用migration_bh_dispatch_bh():
+ *   - migration/migration.c|395| <<migration_bh_schedule>> QEMUBH *bh = qemu_bh_new(migration_bh_dispatch_bh, migbh);
+ */
 static void migration_bh_dispatch_bh(void *opaque)
 {
     MigrationState *s = migrate_get_current();
@@ -364,6 +409,24 @@ static void migration_bh_dispatch_bh(void *opaque)
     g_free(migbh);
 }
 
+/*
+ * 在Target上.
+ * (gdb) bt
+ * #0  migration_bh_schedule (cb=0x555555c5fee6 <process_incoming_migration_bh>, opaque=0x5555575e2e00) at ../migration/migration.c:369
+ * #1  0x0000555555c601c6 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:920
+ * #2  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #3  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #4  0x00007fffffffc7e0 in ?? ()
+ * #5  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用migration_bh_schedule():
+ *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+ *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+ *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+ *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+ *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+ */
 void migration_bh_schedule(QEMUBHFunc *cb, void *opaque)
 {
     MigrationState *s = migrate_get_current();
@@ -481,6 +544,13 @@ void migration_incoming_state_destroy(void)
     }
 
     migration_incoming_transport_cleanup(mis);
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     qemu_event_reset(&mis->main_thread_load_event);
 
     if (mis->page_requested) {
@@ -809,6 +879,36 @@ static void qemu_start_incoming_migration(const char *uri, bool has_channels,
     cpr_state_close();
 }
 
+/*
+ * (gdb) bt
+ * #0  migration_bh_schedule (cb=0x555555c5fee6 <process_incoming_migration_bh>, opaque=0x5555575e2e00) at ../migration/migration.c:369
+ * #1  0x0000555555c601c6 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:920
+ * #2  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #3  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #4  0x00007fffffffc7e0 in ?? ()
+ * #5  0x0000000000000000 in ?? ()
+ *
+ *
+ * (gdb) bt
+ * #0  process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:814
+ * #1  0x0000555555c5ed01 in migration_bh_dispatch_bh (opaque=0x555558143a20) at ../migration/migration.c:361
+ * #2  0x0000555556170433 in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #3  0x0000555556170581 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #4  0x00005555561500fb in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #5  0x0000555556170a50 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #6  0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #7  g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #8  0x0000555556172240 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #9  0x00005555561722ce in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #10 0x00005555561723fd in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #11 0x0000555555c38d08 in qemu_main_loop () at ../system/runstate.c:905
+ * #12 0x0000555556082abe in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #13 0x0000555556082b78 in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用process_incoming_migration_bh():
+ *   - migration/migration.c|944| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+ */
 static void process_incoming_migration_bh(void *opaque)
 {
     MigrationIncomingState *mis = opaque;
@@ -842,6 +942,23 @@ static void process_incoming_migration_bh(void *opaque)
              * metadata.  If error, don't restart the VM yet.
              */
             if (migration_block_activate(NULL)) {
+                /*
+		 * 在以下使用vm_start():
+                 *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+                 *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+                 *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+                 *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+                 *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+                 *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+                 *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+                 *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+                 *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+                 *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+                 *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+                 *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+                 *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+                 *   - system/cpus.c|793| <<vm_resume>> vm_start();
+		 */
                 vm_start();
             }
         } else {
@@ -864,6 +981,18 @@ static void process_incoming_migration_bh(void *opaque)
     migration_incoming_state_destroy();
 }
 
+/*
+ * (gdb) bt
+ * #0  process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:873
+ * #1  0x0000555556174e10 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #2  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #3  0x00007fffffffc7e0 in ?? ()
+ * #4  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用process_incoming_migration_co():
+ *   - migration/migration.c|983| <<migration_incoming_process>> Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
+ */
 static void coroutine_fn
 process_incoming_migration_co(void *opaque)
 {
@@ -881,6 +1010,12 @@ process_incoming_migration_co(void *opaque)
                       MIGRATION_STATUS_ACTIVE);
 
     mis->loadvm_co = qemu_coroutine_self();
+    /*
+     * 在以下使用qemu_loadvm_state():
+     *   - migration/migration.c|908| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file);
+     *   - migration/savevm.c|3581| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f);
+     *   - migration/savevm.c|3655| <<load_snapshot>> ret = qemu_loadvm_state(f);
+     */
     ret = qemu_loadvm_state(mis->from_src_file);
     mis->loadvm_co = NULL;
 
@@ -917,6 +1052,14 @@ process_incoming_migration_co(void *opaque)
         colo_incoming_co();
     }
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(process_incoming_migration_bh, mis);
     goto out;
 
@@ -954,6 +1097,11 @@ static void migration_incoming_setup(QEMUFile *f)
     qemu_file_set_blocking(f, false);
 }
 
+/*
+ * 在以下使用migration_incoming_process():
+ *   - migration/migration.c|1026| <<migration_fd_process_incoming>> migration_incoming_process();
+ *   - migration/migration.c|1129| <<migration_ioc_process_incoming>> migration_incoming_process();
+ */
 void migration_incoming_process(void)
 {
     Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
@@ -993,15 +1141,30 @@ static bool postcopy_try_recover(void)
     return false;
 }
 
+/*
+ * 在以下使用migration_fd_process_incoming():
+ *   - migration/rdma.c|3888| <<rdma_accept_incoming_migration>> migration_fd_process_incoming(f);
+ */
 void migration_fd_process_incoming(QEMUFile *f)
 {
     migration_incoming_setup(f);
     if (postcopy_try_recover()) {
         return;
     }
+    /*
+     * 在以下使用migration_incoming_process():
+     *   - migration/migration.c|1026| <<migration_fd_process_incoming>> migration_incoming_process();
+     *   - migration/migration.c|1129| <<migration_ioc_process_incoming>> migration_incoming_process();
+     */
     migration_incoming_process();
 }
 
+/*
+ * 在以下使用migration_has_main_and_multifd_channels():
+ *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+ *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+ *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+ */
 static bool migration_has_main_and_multifd_channels(void)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -1018,6 +1181,10 @@ static bool migration_has_main_and_multifd_channels(void)
     return true;
 }
 
+/*
+ * 在以下使用migration_ioc_process_incoming():
+ *   - migration/channel.c|46| <<migration_channel_process_incoming>> migration_ioc_process_incoming(ioc, &local_err);
+ */
 void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -1027,6 +1194,12 @@ void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
     uint32_t channel_magic = 0;
     int ret = 0;
 
+    /*
+     * 在以下使用migration_has_main_and_multifd_channels():
+     *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+     */
     if (!migration_has_main_and_multifd_channels()) {
         if (qio_channel_has_feature(ioc, QIO_CHANNEL_FEATURE_READ_MSG_PEEK)) {
             /*
@@ -1097,11 +1270,22 @@ void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用migration_has_main_and_multifd_channels():
+     *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+     */
     if (migration_has_main_and_multifd_channels()) {
         /* If it's a recovery, we're done */
         if (postcopy_try_recover()) {
             return;
         }
+        /*
+	 * 在以下使用migration_incoming_process():
+         *   - migration/migration.c|1026| <<migration_fd_process_incoming>> migration_incoming_process();
+         *   - migration/migration.c|1129| <<migration_ioc_process_incoming>> migration_incoming_process();
+	 */
         migration_incoming_process();
     }
 }
@@ -1114,6 +1298,12 @@ void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
  */
 bool migration_has_all_channels(void)
 {
+    /*
+     * 在以下使用migration_has_main_and_multifd_channels():
+     *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+     */
     if (!migration_has_main_and_multifd_channels()) {
         return false;
     }
@@ -2740,6 +2930,13 @@ static int postcopy_start(MigrationState *ms, Error **errp)
     bql_lock();
     trace_postcopy_start_set_run();
 
+    /*
+     * 在以下使用migration_stop_vm():
+     *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+     *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     */
     ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
     if (ret < 0) {
         error_setg_errno(errp, -ret, "%s: Failed to stop the VM", __func__);
@@ -2797,6 +2994,12 @@ static int postcopy_start(MigrationState *ms, Error **errp)
      */
     qemu_savevm_send_postcopy_listen(fb);
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+     *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+     *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+     *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+     */
     ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
     if (ret) {
         error_setg(errp, "Postcopy save non-iterable device states failed");
@@ -2971,6 +3174,75 @@ static bool migration_switchover_start(MigrationState *s, Error **errp)
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *   
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用migration_completion_precopy():
+ *   - migration/migration.c|3029| <<migration_completion>> ret = migration_completion_precopy(s);
+ */
 static int migration_completion_precopy(MigrationState *s)
 {
     int ret;
@@ -2978,6 +3250,13 @@ static int migration_completion_precopy(MigrationState *s)
     bql_lock();
 
     if (!migrate_mode_is_cpr(s)) {
+        /*
+	 * 在以下使用migration_stop_vm():
+	 *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+	 *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 */
         ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
         if (ret < 0) {
             goto out_unlock;
@@ -2989,6 +3268,12 @@ static int migration_completion_precopy(MigrationState *s)
         goto out_unlock;
     }
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy():
+     *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+     *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+     *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+     */
     ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
 out_unlock:
     bql_unlock();
@@ -3020,12 +3305,21 @@ static void migration_completion_postcopy(MigrationState *s)
  *
  * @s: Current migration state
  */
+/*
+ * 在以下使用migration_completion():
+ *   - migration/migration.c|3523| <<migration_iteration_run>> migration_completion(s);
+ *
+ * 似乎没有到最后的部分不会到这里
+ */
 static void migration_completion(MigrationState *s)
 {
     int ret = 0;
     Error *local_err = NULL;
 
     if (s->state == MIGRATION_STATUS_ACTIVE) {
+        /*
+	 * 只在这调用
+	 */
         ret = migration_completion_precopy(s);
     } else if (s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE) {
         migration_completion_postcopy(s);
@@ -3051,6 +3345,11 @@ static void migration_completion(MigrationState *s)
         migrate_set_state(&s->state, MIGRATION_STATUS_ACTIVE,
                           MIGRATION_STATUS_COLO);
     } else {
+        /*
+	 * 在以下使用migration_completion_end():
+         *   - migration/migration.c|3089| <<migration_completion>> migration_completion_end(s);
+         *   - migration/migration.c|3137| <<bg_migration_completion>> migration_completion_end(s);
+	 */
         migration_completion_end(s);
     }
 
@@ -3099,6 +3398,11 @@ static void bg_migration_completion(MigrationState *s)
         goto fail;
     }
 
+    /*
+     * 在以下使用migration_completion_end():
+     *   - migration/migration.c|3089| <<migration_completion>> migration_completion_end(s);
+     *   - migration/migration.c|3137| <<bg_migration_completion>> migration_completion_end(s);
+     */
     migration_completion_end(s);
     return;
 
@@ -3314,6 +3618,11 @@ static MigThrError migration_detect_error(MigrationState *s)
     }
 }
 
+/*
+ * 在以下使用migration_completion_end():
+ *   - migration/migration.c|3089| <<migration_completion>> migration_completion_end(s);
+ *   - migration/migration.c|3137| <<bg_migration_completion>> migration_completion_end(s);
+ */
 static void migration_completion_end(MigrationState *s)
 {
     uint64_t bytes = migration_transferred_bytes();
@@ -3435,6 +3744,10 @@ typedef enum {
  * Return true if continue to the next iteration directly, false
  * otherwise.
  */
+/*
+ * 在以下使用migration_iteration_run():
+ *   - migration/migration.c|3792| <<migration_thread>> MigIterateState iter_state = migration_iteration_run(s);
+ */
 static MigIterateState migration_iteration_run(MigrationState *s)
 {
     uint64_t must_precopy, can_postcopy, pending_size;
@@ -3463,6 +3776,9 @@ static MigIterateState migration_iteration_run(MigrationState *s)
          * during postcopy phase.
          */
         if (pending_size < s->threshold_size) {
+            /*
+	     * 只在这里调用
+	     */
             qemu_savevm_state_pending_exact(&must_precopy, &can_postcopy);
             pending_size = must_precopy + can_postcopy;
             trace_migrate_pending_exact(pending_size, must_precopy,
@@ -3500,6 +3816,10 @@ static MigIterateState migration_iteration_run(MigrationState *s)
     return MIG_ITERATE_RESUME;
 }
 
+/*
+ * 在以下使用migration_iteration_finish():
+ *   - migration/migration.c|3822| <<migration_thread>> migration_iteration_finish(s);
+ */
 static void migration_iteration_finish(MigrationState *s)
 {
     bql_lock();
@@ -3532,6 +3852,23 @@ static void migration_iteration_finish(MigrationState *s)
         migration_block_activate(NULL);
         if (runstate_is_live(s->vm_old_state)) {
             if (!runstate_check(RUN_STATE_SHUTDOWN)) {
+                /*
+		 * 在以下使用vm_start():
+		 *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+		 *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+		 *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+		 *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+		 *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+		 *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+		 *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+		 *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+		 *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+		 *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+		 *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+		 *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+		 *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+		 *   - system/cpus.c|793| <<vm_resume>> vm_start();
+		 */
                 vm_start();
             }
         } else {
@@ -3547,6 +3884,14 @@ static void migration_iteration_finish(MigrationState *s)
         break;
     }
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(migration_cleanup_bh, s);
     bql_unlock();
 }
@@ -3575,6 +3920,14 @@ static void bg_migration_iteration_finish(MigrationState *s)
         break;
     }
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(migration_cleanup_bh, s);
     bql_unlock();
 }
@@ -3683,6 +4036,11 @@ static void qemu_savevm_wait_unplug(MigrationState *s, int old_state,
  * Master migration thread on the source VM.
  * It drives the migration and pumps the data down the outgoing channel.
  */
+/*
+ * 在以下使用migration_thread():
+ *   - migration/migration.c|4389| <<migration_connect>> qemu_thread_create(&s->thread,
+ *               MIGRATION_THREAD_SRC_MAIN, migration_thread, s, QEMU_THREAD_JOINABLE);
+ */
 static void *migration_thread(void *opaque)
 {
     MigrationState *s = opaque;
@@ -3705,6 +4063,12 @@ static void *migration_thread(void *opaque)
     }
 
     bql_lock();
+    /*
+     * 在以下使用qemu_savevm_state_header():
+     *   - migration/migration.c|4024| <<migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/migration.c|4186| <<bg_migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/savevm.c|2010| <<qemu_savevm_state>> qemu_savevm_state_header(f);
+     */
     qemu_savevm_state_header(s->to_dst_file);
     bql_unlock();
 
@@ -3794,6 +4158,9 @@ static void *migration_thread(void *opaque)
 
 out:
     trace_migration_thread_after_loop();
+    /*
+     * 只在这里调用
+     */
     migration_iteration_finish(s);
     object_unref(OBJECT(s));
     rcu_unregister_thread();
@@ -3889,10 +4256,23 @@ static void *bg_migration_thread(void *opaque)
 
     bql_lock();
 
+    /*
+     * 在以下使用migration_stop_vm():
+     *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+     *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     */
     if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
         goto fail;
     }
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+     *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+     *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+     *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+     */
     if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
         goto fail;
     }
@@ -3914,6 +4294,14 @@ static void *bg_migration_thread(void *opaque)
      * calling VM state change notifiers from vm_start() would initiate
      * writes to virtio VQs memory which is in write-protected region.
      */
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(bg_migration_vm_start_bh, s);
     bql_unlock();
 
@@ -3956,6 +4344,11 @@ fail_setup:
     return NULL;
 }
 
+/*
+ * 在以下使用migration_connect():
+ *   - migration/channel.c|108| <<migration_channel_connect>> migration_connect(s, error);
+ *   - migration/rdma.c|4002| <<rdma_start_outgoing_migration>> migration_connect(s, NULL);
+ */
 void migration_connect(MigrationState *s, Error *error_in)
 {
     Error *local_err = NULL;
@@ -4034,6 +4427,13 @@ void migration_connect(MigrationState *s, Error *error_in)
     }
 
     if (migrate_mode_is_cpr(s)) {
+        /*
+	 * 在以下使用migration_stop_vm():
+	 *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+	 *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 */
         ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
         if (ret < 0) {
             error_setg(&local_err, "migration_stop_vm failed, error %d", -ret);
diff --git a/migration/migration.h b/migration/migration.h
index 01329bf82..4f7671f2b 100644
--- a/migration/migration.h
+++ b/migration/migration.h
@@ -105,6 +105,13 @@ struct MigrationIncomingState {
      * Free at the start of the main state load, set as the main thread finishes
      * loading state.
      */
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     QemuEvent main_thread_load_event;
 
     /* For network announces */
diff --git a/migration/ram.c b/migration/ram.c
index 7208bc114..fce370d94 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -4323,6 +4323,37 @@ static int ram_load_precopy(QEMUFile *f)
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  vm_start () at ../system/cpus.c:785
+ * #1  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #2  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x55555786f100) at ../migration/migration.c:361
+ * #3  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #4  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #5  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #6  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #7  0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #8  g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #9  0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #10 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #11 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #12 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #13 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #14 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * (gdb) bt
+ * #0  ram_load (f=0x5555578d3200, opaque=0x555557524aa0 <ram_state>, version_id=4) at ../migration/ram.c:4327
+ * #1  0x0000555555c79a9d in vmstate_load (f=0x5555578d3200, se=0x5555575e3220) at ../migration/savevm.c:970
+ * #2  0x0000555555c7da30 in qemu_loadvm_section_part_end (f=0x5555578d3200, type=2 '\002') at ../migration/savevm.c:2796
+ * #3  0x0000555555c7e40d in qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3056
+ * #4  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #5  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #6  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #7  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #8  0x00007fffffffc7e0 in ?? ()
+ * #9  0x0000000000000000 in ?? ()
+ */
 static int ram_load(QEMUFile *f, void *opaque, int version_id)
 {
     int ret = 0;
@@ -4638,6 +4669,17 @@ static RAMBlockNotifier ram_mig_ram_notifier = {
 void ram_mig_init(void)
 {
     qemu_mutex_init(&XBZRLE.lock);
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
     ram_block_notifier_add(&ram_mig_ram_notifier);
 }
diff --git a/migration/rdma.c b/migration/rdma.c
index 2d839fce6..459229008 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -3999,6 +3999,11 @@ void rdma_start_outgoing_migration(void *opaque,
 
     s->to_dst_file = rdma_new_output(rdma);
     s->rdma_migration = true;
+    /*
+     * 在以下使用migration_connect():
+     *   - migration/channel.c|108| <<migration_channel_connect>> migration_connect(s, error);
+     *   - migration/rdma.c|4002| <<rdma_start_outgoing_migration>> migration_connect(s, NULL);
+     */
     migration_connect(s, NULL);
     return;
 return_path_err:
diff --git a/migration/savevm.c b/migration/savevm.c
index fabbeb296..75b23987a 100644
--- a/migration/savevm.c
+++ b/migration/savevm.c
@@ -743,6 +743,11 @@ static inline MigrationPriority save_state_priority(SaveStateEntry *se)
     return MIG_PRI_DEFAULT;
 }
 
+/*
+ * 在以下使用savevm_state_handler_insert():
+ *   - migration/savevm.c|832| <<register_savevm_live>> savevm_state_handler_insert(se);
+ *   - migration/savevm.c|948| <<vmstate_register_with_alias_id>> savevm_state_handler_insert(se);
+ */
 static void savevm_state_handler_insert(SaveStateEntry *nse)
 {
     MigrationPriority priority = save_state_priority(nse);
@@ -798,6 +803,17 @@ static void savevm_state_handler_remove(SaveStateEntry *se)
     QTAILQ_REMOVE(&savevm_state.handlers, se, entry);
 }
 
+/*
+ * 在以下使用register_savevm_live():
+ *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+ *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+ *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+ *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+ *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+ *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+ *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+ *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+ */
 /* TODO: Individual devices generally have very little idea about the rest
    of the system, so instance_id should be removed/replaced.
    Meanwhile pass -1 as instance_id if you do not already have a clearly
@@ -829,6 +845,11 @@ int register_savevm_live(const char *idstr,
         se->instance_id = instance_id;
     }
     assert(!se->compat || se->instance_id == 0);
+    /*
+     * 在以下使用savevm_state_handler_insert():
+     *   - migration/savevm.c|832| <<register_savevm_live>> savevm_state_handler_insert(se);
+     *   - migration/savevm.c|948| <<vmstate_register_with_alias_id>> savevm_state_handler_insert(se);
+     */
     savevm_state_handler_insert(se);
     return 0;
 }
@@ -894,6 +915,13 @@ static void vmstate_check(const VMStateDescription *vmsd)
 }
 
 
+/*
+ * 在以下使用vmstate_register_with_alias_id():
+ *   - hw/core/qdev.c|517| <<device_set_realized>> if (vmstate_register_with_alias_id(VMSTATE_IF(dev),
+ *   - hw/intc/apic_common.c|300| <<apic_common_realize>> vmstate_register_with_alias_id(NULL, instance_id, &vmstate_apic_common,
+ *   - include/migration/vmstate.h|1232| <<vmstate_register>> return vmstate_register_with_alias_id(obj, instance_id, vmsd,
+ *   - include/migration/vmstate.h|1260| <<vmstate_register_any>> return vmstate_register_with_alias_id(obj, VMSTATE_INSTANCE_ID_ANY, vmsd,
+ */
 int vmstate_register_with_alias_id(VMStateIf *obj, uint32_t instance_id,
                                    const VMStateDescription *vmsd,
                                    void *opaque, int alias_id,
@@ -945,6 +973,11 @@ int vmstate_register_with_alias_id(VMStateIf *obj, uint32_t instance_id,
         vmstate_check(vmsd);
     }
     assert(!se->compat || se->instance_id == 0);
+    /*
+     * 在以下使用savevm_state_handler_insert():
+     *   - migration/savevm.c|832| <<register_savevm_live>> savevm_state_handler_insert(se);
+     *   - migration/savevm.c|948| <<vmstate_register_with_alias_id>> savevm_state_handler_insert(se);
+     */
     savevm_state_handler_insert(se);
     return 0;
 }
@@ -1024,6 +1057,12 @@ static void save_section_footer(QEMUFile *f, SaveStateEntry *se)
     }
 }
 
+/*
+ * 在以下使用vmstate_save():
+ *   - migration/savevm.c|1361| <<qemu_savevm_state_setup>> ret = vmstate_save(f, se, vmdesc, errp);
+ *   - migration/savevm.c|1669| <<qemu_savevm_state_complete_precopy_non_iterable>> ret = vmstate_save(f, se, vmdesc, &local_err);
+ *   - migration/savevm.c|1864| <<qemu_save_device_state>> ret = vmstate_save(f, se, NULL, &local_err);
+ */
 static int vmstate_save(QEMUFile *f, SaveStateEntry *se, JSONWriter *vmdesc,
                         Error **errp)
 {
@@ -1274,6 +1313,12 @@ void qemu_savevm_non_migratable_list(strList **reasons)
     }
 }
 
+/*
+ * 在以下使用qemu_savevm_state_header():
+ *   - migration/migration.c|4024| <<migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+ *   - migration/migration.c|4186| <<bg_migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+ *   - migration/savevm.c|2010| <<qemu_savevm_state>> qemu_savevm_state_header(f);
+ */
 void qemu_savevm_state_header(QEMUFile *f)
 {
     MigrationState *s = migrate_get_current();
@@ -1573,6 +1618,11 @@ bool qemu_savevm_state_postcopy_prepare(QEMUFile *f, Error **errp)
     return true;
 }
 
+/*
+ * 在以下使用qemu_savevm_state_complete_precopy_iterable():
+ *   - migration/migration.c|2771| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_iterable(ms->to_dst_file, true);
+ *   - migration/savevm.c|1718| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_iterable(f, false);
+ */
 int qemu_savevm_state_complete_precopy_iterable(QEMUFile *f, bool in_postcopy)
 {
     int64_t start_ts_each, end_ts_each;
@@ -1644,6 +1694,62 @@ ret_fail_abort_threads:
     return -1;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+ *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+ *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+ *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+ */
 int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
                                                     bool in_postcopy)
 {
@@ -1655,6 +1761,16 @@ int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
     Error *local_err = NULL;
     int ret;
 
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     /* Making sure cpu states are synchronized before saving non-iterable */
     cpu_synchronize_all_states();
 
@@ -1680,6 +1796,14 @@ int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
     }
 
     if (!in_postcopy) {
+        /*
+	 * 非test使用QEMU_VM_EOF的地方:
+	 *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+	 */
         /* Postcopy stream will still be going */
         qemu_put_byte(f, QEMU_VM_EOF);
 
@@ -1699,16 +1823,106 @@ int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *   
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1704
+ * #1  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #2  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #3  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #4  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用qemu_savevm_state_complete_precopy():
+ *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+ *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+ *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+ */
 int qemu_savevm_state_complete_precopy(QEMUFile *f, bool iterable_only)
 {
     int ret;
 
+    /*
+     * 似乎是剩余可以迁移的最后一点数据?
+     */
     ret = qemu_savevm_state_complete_precopy_iterable(f, false);
     if (ret) {
         return ret;
     }
 
     if (!iterable_only) {
+        /*
+	 * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+         *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+         *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+         *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+	 */
         ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
         if (ret) {
             return ret;
@@ -1743,6 +1957,10 @@ void qemu_savevm_state_pending_estimate(uint64_t *must_precopy,
     }
 }
 
+/*
+ * 在以下使用qemu_savevm_state_pending_exact():
+ *   - migration/migration.c|3535| <<migration_iteration_run>> qemu_savevm_state_pending_exact(&must_precopy, &can_postcopy);
+ */
 void qemu_savevm_state_pending_exact(uint64_t *must_precopy,
                                      uint64_t *can_postcopy)
 {
@@ -1781,6 +1999,10 @@ void qemu_savevm_state_cleanup(void)
     }
 }
 
+/*
+ * 在以下使用qemu_savevm_state():
+ *   - migration/savevm.c|3351| <<save_snapshot>> ret = qemu_savevm_state(f, errp);
+ */
 static int qemu_savevm_state(QEMUFile *f, Error **errp)
 {
     int ret;
@@ -1798,6 +2020,12 @@ static int qemu_savevm_state(QEMUFile *f, Error **errp)
     }
     ms->to_dst_file = f;
 
+    /*
+     * 在以下使用qemu_savevm_state_header():
+     *   - migration/migration.c|4024| <<migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/migration.c|4186| <<bg_migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/savevm.c|2010| <<qemu_savevm_state>> qemu_savevm_state_header(f);
+     */
     qemu_savevm_state_header(f);
     ret = qemu_savevm_state_setup(f, errp);
     if (ret) {
@@ -1813,6 +2041,12 @@ static int qemu_savevm_state(QEMUFile *f, Error **errp)
     ret = qemu_file_get_error(f);
     if (ret == 0) {
         qemu_savevm_maybe_send_switchover_start(f);
+        /*
+	 * 在以下使用qemu_savevm_state_complete_precopy():
+	 *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+	 *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+	 *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+	 */
         qemu_savevm_state_complete_precopy(f, false);
         ret = qemu_file_get_error(f);
     }
@@ -1836,13 +2070,36 @@ cleanup:
     return ret;
 }
 
+/*
+ * 在以下使用qemu_savevm_live_state():
+ *   - migration/colo.c|474| <<colo_do_checkpoint_transaction>> qemu_savevm_live_state(s->to_dst_file);
+ */
 void qemu_savevm_live_state(QEMUFile *f)
 {
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy():
+     *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+     *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+     *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+     */
     /* save QEMU_VM_SECTION_END section */
     qemu_savevm_state_complete_precopy(f, true);
+    /*
+     * 非test使用QEMU_VM_EOF的地方:
+     *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+     */
     qemu_put_byte(f, QEMU_VM_EOF);
 }
 
+/*
+ * 在以下使用qemu_save_device_state():
+ *   - migration/colo.c|459| <<colo_do_checkpoint_transaction>> ret = qemu_save_device_state(fb);
+ *   - migration/savevm.c|3432| <<qmp_xen_save_devices_state>> ret = qemu_save_device_state(f);
+ */
 int qemu_save_device_state(QEMUFile *f)
 {
     MigrationState *ms = migrate_get_current();
@@ -1853,6 +2110,16 @@ int qemu_save_device_state(QEMUFile *f)
         qemu_put_be32(f, QEMU_VM_FILE_MAGIC);
         qemu_put_be32(f, QEMU_VM_FILE_VERSION);
     }
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
 
     QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
@@ -1869,6 +2136,14 @@ int qemu_save_device_state(QEMUFile *f)
         }
     }
 
+    /*
+     * 非test使用QEMU_VM_EOF的地方:
+     *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+     */
     qemu_put_byte(f, QEMU_VM_EOF);
 
     return qemu_file_get_error(f);
@@ -2076,6 +2351,11 @@ static int loadvm_postcopy_ram_handle_discard(MigrationIncomingState *mis,
  * (TODO:This could do with being in a postcopy file - but there again it's
  * just another input loop, not that postcopy specific)
  */
+/*
+ * 在以下使用postcopy_ram_listen_thread():
+ *   - migration/savevm.c|2353| <<loadvm_postcopy_handle_listen>> postcopy_thread_create(mis, &mis->listen_thread,
+ *                          MIGRATION_THREAD_DST_LISTEN, postcopy_ram_listen_thread, QEMU_THREAD_DETACHED);
+ */
 static void *postcopy_ram_listen_thread(void *opaque)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -2135,6 +2415,13 @@ static void *postcopy_ram_listen_thread(void *opaque)
          * main thread hasn't finished yet, and so we might not be in 'RUN'
          * state yet; wait for the end of the main thread.
          */
+        /*
+	 * 在以下使用MigrationIncomingState->main_thread_load_event:
+         *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+         *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+         *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+         *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+	 */
         qemu_event_wait(&mis->main_thread_load_event);
     }
     postcopy_ram_incoming_cleanup(mis);
@@ -2274,6 +2561,14 @@ static int loadvm_postcopy_handle_run(MigrationIncomingState *mis)
     }
 
     postcopy_state_set(POSTCOPY_INCOMING_RUNNING);
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
 
     /* We need to finish reading the stream from the package
@@ -2813,6 +3108,10 @@ qemu_loadvm_section_part_end(QEMUFile *f, uint8_t type)
     return 0;
 }
 
+/*
+ * 在以下使用qemu_loadvm_state_header():
+ *   - migration/savevm.c|3440| <<qemu_loadvm_state>> ret = qemu_loadvm_state_header(f);
+ */
 static int qemu_loadvm_state_header(QEMUFile *f)
 {
     unsigned int v;
@@ -3028,6 +3327,24 @@ static bool postcopy_pause_incoming(MigrationIncomingState *mis)
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3033
+ * #1  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #2  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #3  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #4  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #5  0x00007fffffffc7e0 in ?? ()
+ * #6  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用qemu_loadvm_state_main():
+ *   - migration/colo.c|699| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis);
+ *   - migration/savevm.c|2234| <<postcopy_ram_listen_thread>> load_res = qemu_loadvm_state_main(f, mis);
+ *   - migration/savevm.c|2593| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis);
+ *   - migration/savevm.c|3283| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis);
+ *   - migration/savevm.c|3357| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis);
+ */
 int qemu_loadvm_state_main(QEMUFile *f, MigrationIncomingState *mis)
 {
     uint8_t section_type;
@@ -3066,6 +3383,14 @@ retry:
             }
             break;
         case QEMU_VM_EOF:
+            /*
+	     * 非test使用QEMU_VM_EOF的地方:
+             *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+	     */
             /* This is the end of migration */
             goto out;
         default:
@@ -3103,6 +3428,21 @@ out:
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3112
+ * #1  0x0000555555c600fa in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:891
+ * #2  0x0000555556174e10 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #3  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #4  0x00007fffffffc7e0 in ?? ()
+ * #5  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用qemu_loadvm_state():
+ *   - migration/migration.c|908| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file);
+ *   - migration/savevm.c|3581| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f);
+ *   - migration/savevm.c|3655| <<load_snapshot>> ret = qemu_loadvm_state(f);
+ */
 int qemu_loadvm_state(QEMUFile *f)
 {
     MigrationState *s = migrate_get_current();
@@ -3131,9 +3471,33 @@ int qemu_loadvm_state(QEMUFile *f)
         qemu_loadvm_state_switchover_ack_needed(mis);
     }
 
+    /*
+     * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+     *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+     *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+     *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+     *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+     */
     cpu_synchronize_all_pre_loadvm();
 
+    /*
+     * 在以下使用qemu_loadvm_state_main():
+     *   - migration/colo.c|699| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis);
+     *   - migration/savevm.c|2234| <<postcopy_ram_listen_thread>> load_res = qemu_loadvm_state_main(f, mis);
+     *   - migration/savevm.c|2593| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis);
+     *   - migration/savevm.c|3283| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis);
+     *   - migration/savevm.c|3357| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis);
+     */
     ret = qemu_loadvm_state_main(f, mis);
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     qemu_event_set(&mis->main_thread_load_event);
 
     trace_qemu_loadvm_state_post_main(ret);
@@ -3196,6 +3560,13 @@ int qemu_loadvm_state(QEMUFile *f)
         }
     }
 
+    /*
+     * 在以下使用cpu_synchronize_all_post_init():
+     *   - hw/core/machine.c|1732| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|2368| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3346| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3363| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+     */
     cpu_synchronize_all_post_init();
 
     return ret;
@@ -3213,6 +3584,13 @@ int qemu_load_device_state(QEMUFile *f)
         return ret;
     }
 
+    /*
+     * 在以下使用cpu_synchronize_all_post_init():
+     *   - hw/core/machine.c|1732| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|2368| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3346| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3363| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+     */
     cpu_synchronize_all_post_init();
     return 0;
 }
@@ -3258,6 +3636,13 @@ bool qemu_loadvm_load_state_buffer(const char *idstr, uint32_t instance_id,
     return se->ops->load_state_buffer(se->opaque, buf, len, errp);
 }
 
+/*
+ * 在以下使用save_snapshot():
+ *   - migration/migration-hmp-cmds.c|463| <<hmp_savevm>> save_snapshot(qdict_get_try_str(qdict, "name"),
+ *   - migration/savevm.c|3629| <<snapshot_save_job_bh>> s->ret = save_snapshot(s->tag, false, s->vmstate,
+ *   - replay/replay-debugging.c|325| <<replay_gdb_attached>> if (!save_snapshot("start_debugging", true, NULL, false, NULL, NULL)) {
+ *   - replay/replay-snapshot.c|79| <<replay_vmstate_init>> if (!save_snapshot(replay_snapshot,
+ */
 bool save_snapshot(const char *name, bool overwrite, const char *vmstate,
                   bool has_devices, strList *devices, Error **errp)
 {
@@ -3512,6 +3897,12 @@ bool load_snapshot(const char *name, const char *vmstate,
         ret = -EINVAL;
         goto err_drain;
     }
+    /*
+     * 在以下使用qemu_loadvm_state():
+     *   - migration/migration.c|908| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file);
+     *   - migration/savevm.c|3581| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f);
+     *   - migration/savevm.c|3655| <<load_snapshot>> ret = qemu_loadvm_state(f);
+     */
     ret = qemu_loadvm_state(f);
     migration_incoming_state_destroy();
 
diff --git a/migration/savevm.h b/migration/savevm.h
index 2d5e9c716..c22efcf57 100644
--- a/migration/savevm.h
+++ b/migration/savevm.h
@@ -18,6 +18,14 @@
 #define QEMU_VM_FILE_VERSION_COMPAT  0x00000002
 #define QEMU_VM_FILE_VERSION         0x00000003
 
+/*
+ * 非test使用QEMU_VM_EOF的地方:
+ *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+ */
 #define QEMU_VM_EOF                  0x00
 #define QEMU_VM_SECTION_START        0x01
 #define QEMU_VM_SECTION_PART         0x02
diff --git a/migration/socket.c b/migration/socket.c
index 5ec65b8c0..0b6253522 100644
--- a/migration/socket.c
+++ b/migration/socket.c
@@ -77,6 +77,14 @@ static void socket_outgoing_migration(QIOTask *task,
     }
 
 out:
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(data->s, sioc, data->hostname, err);
     object_unref(OBJECT(sioc));
 }
diff --git a/migration/tls.c b/migration/tls.c
index 284a6194b..6c90428a6 100644
--- a/migration/tls.c
+++ b/migration/tls.c
@@ -114,6 +114,14 @@ static void migration_tls_outgoing_handshake(QIOTask *task,
     } else {
         trace_migration_tls_outgoing_handshake_complete();
     }
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, err);
     object_unref(OBJECT(ioc));
 }
diff --git a/monitor/qmp-cmds.c b/monitor/qmp-cmds.c
index 1ca44fbd7..4a1cb301a 100644
--- a/monitor/qmp-cmds.c
+++ b/monitor/qmp-cmds.c
@@ -109,6 +109,23 @@ void qmp_cont(Error **errp)
             error_propagate(errp, local_err);
             return;
         }
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|793| <<vm_resume>> vm_start();
+	 */
         vm_start();
     }
 }
diff --git a/net/net.c b/net/net.c
index da275db86..03dfb65ab 100644
--- a/net/net.c
+++ b/net/net.c
@@ -437,6 +437,14 @@ void qemu_del_net_client(NetClientState *nc)
      */
     if (nc->peer && nc->peer->info->type == NET_CLIENT_DRIVER_NIC) {
         NICState *nic = qemu_get_nic(nc->peer);
+        /*
+         * 在以下使用NICState->peer_deleted:
+         *   - hw/net/virtio-net.c|756| <<virtio_net_set_queue_pairs>> if (n->nic->peer_deleted) {
+         *   - net/net.c|440| <<qemu_del_net_client>> if (nic->peer_deleted) {
+         *   - net/net.c|443| <<qemu_del_net_client>> nic->peer_deleted = true;
+         *   - net/net.c|475| <<qemu_del_nic>> if (nic->peer_deleted) {
+         *   - net/net.c|1724| <<net_cleanup>> if (nic->peer_deleted) {
+	 */
         if (nic->peer_deleted) {
             return;
         }
@@ -472,6 +480,14 @@ void qemu_del_nic(NICState *nic)
          * If this is a peer NIC and peer has already been deleted, clean it up
          * and free it now.
          */
+        /*
+	 * 在以下使用NICState->peer_deleted:
+         *   - hw/net/virtio-net.c|756| <<virtio_net_set_queue_pairs>> if (n->nic->peer_deleted) {
+         *   - net/net.c|440| <<qemu_del_net_client>> if (nic->peer_deleted) {
+         *   - net/net.c|443| <<qemu_del_net_client>> nic->peer_deleted = true;
+         *   - net/net.c|475| <<qemu_del_nic>> if (nic->peer_deleted) {
+         *   - net/net.c|1724| <<net_cleanup>> if (nic->peer_deleted) {
+	 */
         if (nic->peer_deleted) {
             qemu_cleanup_net_client(nc->peer, false);
             qemu_free_net_client(nc->peer);
@@ -1252,6 +1268,13 @@ void qemu_create_nic_bus_devices(BusState *bus, const char *parent_type,
     g_ptr_array_free(nic_models, true);
 }
 
+/*
+ * 在以下使用net_client_init_fun[]:
+ *   - net/net.c|1255| <<global>> static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(
+ *   - net/net.c|1307| <<net_client_init1>> if (netdev->type == NET_CLIENT_DRIVER_NIC || !net_client_init_fun[netdev->type]) {
+ *   - net/net.c|1322| <<net_client_init1>> if (!net_client_init_fun[netdev->type]) {
+ *   - net/net.c|1341| <<net_client_init1>> if (net_client_init_fun[netdev->type](netdev, netdev->id, peer, errp) < 0) {
+ */
 static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(
     const Netdev *netdev,
     const char *name,
@@ -1297,12 +1320,25 @@ static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(
 };
 
 
+/*
+ * 在以下使用net_client_init1():
+ *   - net/net.c|1450| <<net_client_init>> ret = net_client_init1(object, is_netdev, errp);
+ *   - net/net.c|1473| <<qmp_netdev_add>> net_client_init1(netdev, true, errp);
+ *   - net/net.c|1889| <<netdev_init_modern>> net_client_init1(nd->nd, true, &error_fatal);
+ */
 static int net_client_init1(const Netdev *netdev, bool is_netdev, Error **errp)
 {
     NetClientState *peer = NULL;
     NetClientState *nc;
 
     if (is_netdev) {
+        /*
+	 * 在以下使用net_client_init_fun[]:
+         *   - net/net.c|1255| <<global>> static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(
+         *   - net/net.c|1307| <<net_client_init1>> if (netdev->type == NET_CLIENT_DRIVER_NIC || !net_client_init_fun[netdev->type]) {
+         *   - net/net.c|1322| <<net_client_init1>> if (!net_client_init_fun[netdev->type]) {
+         *   - net/net.c|1341| <<net_client_init1>> if (net_client_init_fun[netdev->type](netdev, netdev->id, peer, errp) < 0) {
+	 */
         if (netdev->type == NET_CLIENT_DRIVER_NIC ||
             !net_client_init_fun[netdev->type]) {
             error_setg(errp, "network backend '%s' is not compiled into this binary",
@@ -1319,6 +1355,13 @@ static int net_client_init1(const Netdev *netdev, bool is_netdev, Error **errp)
             return -1;
         }
 
+        /*
+	 * 在以下使用net_client_init_fun[]:
+         *   - net/net.c|1255| <<global>> static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(
+         *   - net/net.c|1307| <<net_client_init1>> if (netdev->type == NET_CLIENT_DRIVER_NIC || !net_client_init_fun[netdev->type]) {
+         *   - net/net.c|1322| <<net_client_init1>> if (!net_client_init_fun[netdev->type]) {
+         *   - net/net.c|1341| <<net_client_init1>> if (net_client_init_fun[netdev->type](netdev, netdev->id, peer, errp) < 0) {
+	 */
         if (!net_client_init_fun[netdev->type]) {
             error_setg(errp, "network backend '%s' is not compiled into this binary",
                        NetClientDriver_str(netdev->type));
@@ -1338,6 +1381,13 @@ static int net_client_init1(const Netdev *netdev, bool is_netdev, Error **errp)
         return -1;
     }
 
+    /*
+     * 在以下使用net_client_init_fun[]:
+     *   - net/net.c|1255| <<global>> static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(
+     *   - net/net.c|1307| <<net_client_init1>> if (netdev->type == NET_CLIENT_DRIVER_NIC || !net_client_init_fun[netdev->type]) {
+     *   - net/net.c|1322| <<net_client_init1>> if (!net_client_init_fun[netdev->type]) {
+     *   - net/net.c|1341| <<net_client_init1>> if (net_client_init_fun[netdev->type](netdev, netdev->id, peer, errp) < 0) {
+     */
     if (net_client_init_fun[netdev->type](netdev, netdev->id, peer, errp) < 0) {
         /* FIXME drop when all init functions store an Error */
         if (errp && !*errp) {
@@ -1447,6 +1497,12 @@ static int net_client_init(QemuOpts *opts, bool is_netdev, Error **errp)
     }
 
     if (visit_type_Netdev(v, NULL, &object, errp)) {
+        /*
+	 * 在以下使用net_client_init1():
+         *   - net/net.c|1450| <<net_client_init>> ret = net_client_init1(object, is_netdev, errp);
+         *   - net/net.c|1473| <<qmp_netdev_add>> net_client_init1(netdev, true, errp);
+         *   - net/net.c|1889| <<netdev_init_modern>> net_client_init1(nd->nd, true, &error_fatal);
+	 */
         ret = net_client_init1(object, is_netdev, errp);
     }
 
@@ -1470,6 +1526,12 @@ void qmp_netdev_add(Netdev *netdev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用net_client_init1():
+     *   - net/net.c|1450| <<net_client_init>> ret = net_client_init1(object, is_netdev, errp);
+     *   - net/net.c|1473| <<qmp_netdev_add>> net_client_init1(netdev, true, errp);
+     *   - net/net.c|1889| <<netdev_init_modern>> net_client_init1(nd->nd, true, &error_fatal);
+     */
     net_client_init1(netdev, true, errp);
 }
 
@@ -1721,6 +1783,14 @@ void net_cleanup(void)
         if (nc->info->type == NET_CLIENT_DRIVER_NIC) {
             NICState *nic = qemu_get_nic(nc);
 
+            /*
+	     * 在以下使用NICState->peer_deleted:
+             *   - hw/net/virtio-net.c|756| <<virtio_net_set_queue_pairs>> if (n->nic->peer_deleted) {
+             *   - net/net.c|440| <<qemu_del_net_client>> if (nic->peer_deleted) {
+             *   - net/net.c|443| <<qemu_del_net_client>> nic->peer_deleted = true;
+             *   - net/net.c|475| <<qemu_del_nic>> if (nic->peer_deleted) {
+             *   - net/net.c|1724| <<net_cleanup>> if (nic->peer_deleted) {
+	     */
             if (nic->peer_deleted) {
                 int queues = MAX(nic->conf->peers.queues, 1);
 
@@ -1886,6 +1956,12 @@ static void netdev_init_modern(void)
 
         QSIMPLEQ_REMOVE_HEAD(&nd_queue, entry);
         loc_push_restore(&nd->loc);
+        /*
+	 * 在以下使用net_client_init1():
+         *   - net/net.c|1450| <<net_client_init>> ret = net_client_init1(object, is_netdev, errp);
+         *   - net/net.c|1473| <<qmp_netdev_add>> net_client_init1(netdev, true, errp);
+         *   - net/net.c|1889| <<netdev_init_modern>> net_client_init1(nd->nd, true, &error_fatal);
+	 */
         net_client_init1(nd->nd, true, &error_fatal);
         loc_pop(&nd->loc);
         qapi_free_Netdev(nd->nd);
diff --git a/net/slirp.c b/net/slirp.c
index 9657e86a8..fdeee85f3 100644
--- a/net/slirp.c
+++ b/net/slirp.c
@@ -669,6 +669,17 @@ static int net_slirp_init(NetClientState *peer, const char *model,
      * specific version?
      */
     g_assert(slirp_state_version() == 4);
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
                          slirp_state_version(), &savevm_slirp_state, s->slirp);
 
diff --git a/net/tap-linux.c b/net/tap-linux.c
index 22ec2f45d..7e8ff687b 100644
--- a/net/tap-linux.c
+++ b/net/tap-linux.c
@@ -37,6 +37,10 @@
 
 #define PATH_NET_TUN "/dev/net/tun"
 
+/*
+ * 在以下使用tap_open():
+ *   - net/tap.c|661| <<net_tap_init>> fd = RETRY_ON_EINTR(tap_open(ifname, ifname_sz, vnet_hdr, vnet_hdr_required,
+ */
 int tap_open(char *ifname, int ifname_size, int *vnet_hdr,
              int vnet_hdr_required, int mq_required, Error **errp)
 {
@@ -279,6 +283,10 @@ void tap_fd_set_offload(int fd, int csum, int tso4,
     }
 }
 
+/*
+ * 在以下使用tap_fd_enable():
+ *   - net/tap.c|1032| <<tap_enable>> ret = tap_fd_enable(s->fd);
+ */
 /* Enable a specific queue of tap. */
 int tap_fd_enable(int fd)
 {
@@ -297,6 +305,10 @@ int tap_fd_enable(int fd)
     return ret;
 }
 
+/*
+ * 在以下使用tap_fd_disable():
+ *   - net/tap.c|1049| <<tap_disable>> ret = tap_fd_disable(s->fd);
+ */
 /* Disable a specific queue of tap/ */
 int tap_fd_disable(int fd)
 {
diff --git a/net/tap.c b/net/tap.c
index f7df702f9..7f714b17a 100644
--- a/net/tap.c
+++ b/net/tap.c
@@ -385,6 +385,11 @@ static NetClientInfo net_tap_info = {
     .get_vhost_net = tap_get_vhost_net,
 };
 
+/*
+ * 在以下使用net_tap_fd_init():
+ *   - net/tap.c|639| <<net_init_bridge>> s = net_tap_fd_init(peer, "bridge", name, fd, vnet_hdr);
+ *   - net/tap.c|694| <<net_init_tap_one>> TAPState *s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);
+ */
 static TAPState *net_tap_fd_init(NetClientState *peer,
                                  const char *model,
                                  const char *name,
@@ -643,6 +648,10 @@ int net_init_bridge(const Netdev *netdev, const char *name,
     return 0;
 }
 
+/*
+ * 在以下使用net_tap_init():
+ *   - net/tap.c|995| <<net_init_tap>> fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? "no" : script,
+ */
 static int net_tap_init(const NetdevTapOptions *tap, int *vnet_hdr,
                         const char *setup_script, char *ifname,
                         size_t ifname_sz, int mq_required, Error **errp)
@@ -680,6 +689,13 @@ static int net_tap_init(const NetdevTapOptions *tap, int *vnet_hdr,
 
 #define MAX_TAP_QUEUES 1024
 
+/*
+ * 在以下使用net_init_tap_one():
+ *   - net/tap.c|859| <<net_init_tap>> net_init_tap_one(tap, peer, "tap", name, NULL,
+ *   - net/tap.c|922| <<net_init_tap>> net_init_tap_one(tap, peer, "tap", name, ifname,
+ *   - net/tap.c|968| <<net_init_tap>> net_init_tap_one(tap, peer, "bridge", name, ifname,
+ *   - net/tap.c|1013| <<net_init_tap>> net_init_tap_one(tap, peer, "tap", name, ifname,
+ */
 static void net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,
                              const char *model, const char *name,
                              const char *ifname, const char *script,
@@ -797,6 +813,20 @@ static int get_fds(char *str, char *fds[], int max)
     return i;
 }
 
+/*
+ * 1271 static int (* const net_client_init_fun[NET_CLIENT_DRIVER__MAX])(
+ * 1272     const Netdev *netdev,
+ * 1273     const char *name,
+ * 1274     NetClientState *peer, Error **errp) = {
+ * 1275         [NET_CLIENT_DRIVER_NIC]       = net_init_nic,
+ * 1276 #ifdef CONFIG_PASST
+ * 1277         [NET_CLIENT_DRIVER_PASST]     = net_init_passt,
+ * 1278 #endif
+ * 1279 #ifdef CONFIG_SLIRP
+ * 1280         [NET_CLIENT_DRIVER_USER]      = net_init_slirp,
+ * 1281 #endif
+ * 1282         [NET_CLIENT_DRIVER_TAP]       = net_init_tap,
+ */
 int net_init_tap(const Netdev *netdev, const char *name,
                  NetClientState *peer, Error **errp)
 {
@@ -1021,6 +1051,10 @@ free_fail:
     return 0;
 }
 
+/*
+ * 在以下使用tap_enable():
+ *   - hw/net/virtio-net.c|713| <<peer_attach>> return tap_enable(nc->peer);
+ */
 int tap_enable(NetClientState *nc)
 {
     TAPState *s = DO_UPCAST(TAPState, nc, nc);
@@ -1038,6 +1072,10 @@ int tap_enable(NetClientState *nc)
     }
 }
 
+/*
+ * 在以下使用tap_disable():
+ *   - hw/net/virtio-net.c|734| <<peer_detach>> return tap_disable(nc->peer);
+ */
 int tap_disable(NetClientState *nc)
 {
     TAPState *s = DO_UPCAST(TAPState, nc, nc);
diff --git a/net/vhost-vdpa.c b/net/vhost-vdpa.c
index 74d26a949..bb0a7b047 100644
--- a/net/vhost-vdpa.c
+++ b/net/vhost-vdpa.c
@@ -1560,6 +1560,11 @@ static int vhost_vdpa_net_handle_ctrl_avail(VhostShadowVirtqueue *svq,
     }
 
     status = VIRTIO_NET_ERR;
+    /*
+     * 在以下使用virtio_net_handle_ctrl_iov():
+     *   - hw/net/virtio-net.c|1608| <<virtio_net_handle_ctrl>> written = virtio_net_handle_ctrl_iov(vdev, elem->in_sg, elem->in_num,
+     *   - net/vhost-vdpa.c|1563| <<vhost_vdpa_net_handle_ctrl_avail>> virtio_net_handle_ctrl_iov(svq->vdev, &model_in, 1, &out, 1);
+     */
     virtio_net_handle_ctrl_iov(svq->vdev, &model_in, 1, &out, 1);
     if (status != VIRTIO_NET_OK) {
         error_report("Bad CVQ processing in model");
diff --git a/qemu-img.c b/qemu-img.c
index 7a162fdc0..8d739d900 100644
--- a/qemu-img.c
+++ b/qemu-img.c
@@ -606,6 +606,11 @@ static void dump_human_image_check(ImageCheck *check, bool quiet)
     }
 }
 
+/*
+ * 在以下使用collect_image_check():
+ *   - qemu-img.c|779| <<img_check>> ret = collect_image_check(bs, check, filename, fmt, fix);
+ *   - qemu-img.c|808| <<img_check>> ret = collect_image_check(bs, check, filename, fmt, 0);
+ */
 static int collect_image_check(BlockDriverState *bs,
                    ImageCheck *check,
                    const char *filename,
@@ -615,6 +620,12 @@ static int collect_image_check(BlockDriverState *bs,
     int ret;
     BdrvCheckResult result;
 
+    /*
+     * 在block/block-gen.c
+     * bdrv_co_check_entry
+     * bdrv_co_check
+     * qcow2_co_check
+     */
     ret = bdrv_check(bs, &result, fix);
     if (ret < 0) {
         return ret;
@@ -3178,6 +3189,39 @@ static int img_info(const img_cmd_t *ccmd, int argc, char **argv)
     return 0;
 }
 
+/*
+ * 415 ##
+ * 416 # @MapEntry:
+ * 417 #
+ * 418 # Mapping information from a virtual block range to a host file range
+ * 419 #
+ * 420 # @start: virtual (guest) offset of the first byte described by this
+ * 421 #     entry
+ * 422 #
+ * 423 # @length: the number of bytes of the mapped virtual range
+ * 424 #
+ * 425 # @data: reading the image will actually read data from a file (in
+ * 426 #     particular, if @offset is present this means that the sectors
+ * 427 #     are not simply preallocated, but contain actual data in raw
+ * 428 #     format)
+ * 429 #
+ * 430 # @zero: whether the virtual blocks read as zeroes
+ * 431 #
+ * 432 # @compressed: true if the data is stored compressed (since 8.2)
+ * 433 #
+ * 434 # @depth: number of layers (0 = top image, 1 = top image's backing
+ * 435 #     file, ..., n - 1 = bottom image (where n is the number of images
+ * 436 #     in the chain)) before reaching one for which the range is
+ * 437 #     allocated
+ * 438 #
+ * 439 # @present: true if this layer provides the data, false if adding a
+ * 440 #     backing layer could impact this region (since 6.1
+ * 441 #
+ * 442 # @offset: if present, the image file stores the data for this range
+ * 443 #     in raw format at the given (host) offset
+ * 444 #
+ * 445 # @filename: filename that is referred to by @offset
+ */
 static int dump_map_entry(OutputFormat output_format, MapEntry *e,
                           MapEntry *next)
 {
@@ -3223,6 +3267,39 @@ static int dump_map_entry(OutputFormat output_format, MapEntry *e,
     return 0;
 }
 
+/*
+ * 415 ##
+ * 416 # @MapEntry:
+ * 417 #
+ * 418 # Mapping information from a virtual block range to a host file range
+ * 419 #
+ * 420 # @start: virtual (guest) offset of the first byte described by this
+ * 421 #     entry
+ * 422 #
+ * 423 # @length: the number of bytes of the mapped virtual range
+ * 424 #
+ * 425 # @data: reading the image will actually read data from a file (in
+ * 426 #     particular, if @offset is present this means that the sectors
+ * 427 #     are not simply preallocated, but contain actual data in raw
+ * 428 #     format)
+ * 429 #
+ * 430 # @zero: whether the virtual blocks read as zeroes
+ * 431 #
+ * 432 # @compressed: true if the data is stored compressed (since 8.2)
+ * 433 #
+ * 434 # @depth: number of layers (0 = top image, 1 = top image's backing
+ * 435 #     file, ..., n - 1 = bottom image (where n is the number of images
+ * 436 #     in the chain)) before reaching one for which the range is
+ * 437 #     allocated
+ * 438 #
+ * 439 # @present: true if this layer provides the data, false if adding a
+ * 440 #     backing layer could impact this region (since 6.1
+ * 441 #
+ * 442 # @offset: if present, the image file stores the data for this range
+ * 443 #     in raw format at the given (host) offset
+ * 444 #
+ * 445 # @filename: filename that is referred to by @offset
+ */
 static int get_block_status(BlockDriverState *bs, int64_t offset,
                             int64_t bytes, MapEntry *e)
 {
@@ -3244,6 +3321,9 @@ static int get_block_status(BlockDriverState *bs, int64_t offset,
     depth = 0;
     for (;;) {
         bs = bdrv_skip_filters(bs);
+	/*
+	 * qcow2_co_block_status
+	 */
         ret = bdrv_block_status(bs, offset, bytes, &bytes, &map, &file);
         if (ret < 0) {
             return ret;
@@ -3284,6 +3364,39 @@ static int get_block_status(BlockDriverState *bs, int64_t offset,
     return 0;
 }
 
+/*
+ * 415 ##
+ * 416 # @MapEntry:
+ * 417 #
+ * 418 # Mapping information from a virtual block range to a host file range
+ * 419 #
+ * 420 # @start: virtual (guest) offset of the first byte described by this
+ * 421 #     entry
+ * 422 #
+ * 423 # @length: the number of bytes of the mapped virtual range
+ * 424 #
+ * 425 # @data: reading the image will actually read data from a file (in
+ * 426 #     particular, if @offset is present this means that the sectors
+ * 427 #     are not simply preallocated, but contain actual data in raw
+ * 428 #     format)
+ * 429 #
+ * 430 # @zero: whether the virtual blocks read as zeroes
+ * 431 #
+ * 432 # @compressed: true if the data is stored compressed (since 8.2)
+ * 433 #
+ * 434 # @depth: number of layers (0 = top image, 1 = top image's backing
+ * 435 #     file, ..., n - 1 = bottom image (where n is the number of images
+ * 436 #     in the chain)) before reaching one for which the range is
+ * 437 #     allocated
+ * 438 #
+ * 439 # @present: true if this layer provides the data, false if adding a
+ * 440 #     backing layer could impact this region (since 6.1
+ * 441 #
+ * 442 # @offset: if present, the image file stores the data for this range
+ * 443 #     in raw format at the given (host) offset
+ * 444 #
+ * 445 # @filename: filename that is referred to by @offset
+ */
 static inline bool entry_mergeable(const MapEntry *curr, const MapEntry *next)
 {
     if (curr->length == 0) {
@@ -3307,6 +3420,39 @@ static inline bool entry_mergeable(const MapEntry *curr, const MapEntry *next)
     return true;
 }
 
+/*
+ * 415 ##
+ * 416 # @MapEntry:
+ * 417 #
+ * 418 # Mapping information from a virtual block range to a host file range
+ * 419 #
+ * 420 # @start: virtual (guest) offset of the first byte described by this
+ * 421 #     entry
+ * 422 #
+ * 423 # @length: the number of bytes of the mapped virtual range
+ * 424 #
+ * 425 # @data: reading the image will actually read data from a file (in
+ * 426 #     particular, if @offset is present this means that the sectors
+ * 427 #     are not simply preallocated, but contain actual data in raw
+ * 428 #     format)
+ * 429 #
+ * 430 # @zero: whether the virtual blocks read as zeroes
+ * 431 #
+ * 432 # @compressed: true if the data is stored compressed (since 8.2)
+ * 433 #
+ * 434 # @depth: number of layers (0 = top image, 1 = top image's backing
+ * 435 #     file, ..., n - 1 = bottom image (where n is the number of images
+ * 436 #     in the chain)) before reaching one for which the range is
+ * 437 #     allocated
+ * 438 #
+ * 439 # @present: true if this layer provides the data, false if adding a
+ * 440 #     backing layer could impact this region (since 6.1
+ * 441 #
+ * 442 # @offset: if present, the image file stores the data for this range
+ * 443 #     in raw format at the given (host) offset
+ * 444 #
+ * 445 # @filename: filename that is referred to by @offset
+ */
 static int img_map(const img_cmd_t *ccmd, int argc, char **argv)
 {
     int c;
diff --git a/system/cpus.c b/system/cpus.c
index 256723558..88a2471b1 100644
--- a/system/cpus.c
+++ b/system/cpus.c
@@ -74,8 +74,28 @@ static QemuMutex bql;
  */
 static const AccelOpsClass *cpus_accel;
 
+/*
+ * 在以下使用cpu_is_stopped():
+ *   - system/cpus.c|101| <<cpu_thread_is_idle>> if (cpu_is_stopped(cpu)) {
+ *   - system/cpus.c|571| <<cpu_can_run>> if (cpu_is_stopped(cpu)) {
+ *   - target/i386/kvm/kvm.c|5383| <<kvm_arch_put_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+ *   - target/i386/kvm/kvm.c|5483| <<kvm_arch_get_registers>> assert(cpu_is_stopped(cs) || qemu_cpu_is_self(cs));
+ *   - target/i386/nvmm/nvmm-all.c|93| <<nvmm_set_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+ *   - target/i386/nvmm/nvmm-all.c|231| <<nvmm_get_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+ *   - target/i386/whpx/whpx-all.c|395| <<whpx_set_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+ *   - target/i386/whpx/whpx-all.c|610| <<whpx_get_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+ */
 bool cpu_is_stopped(CPUState *cpu)
 {
+    /*
+     * 几乎是核心的时候地方cpu->stopped:
+     *   - system/cpus.c|79| <<cpu_is_stopped>> return cpu->stopped || !runstate_is_running();
+     *   - system/cpus.c|543| <<cpu_handle_guest_debug>> cpu->stopped = true;
+     *   - system/cpus.c|631| <<qemu_cpu_stop>> cpu->stopped = true;
+     *   - system/cpus.c|799| <<cpu_resume>> cpu->stopped = false;
+     *   - system/cpus.c|808| <<all_vcpus_paused>> if (!cpu->stopped) {
+     *   - system/cpus.c|895| <<qemu_init_vcpu>> cpu->stopped = true;
+     */
     return cpu->stopped || !runstate_is_running();
 }
 
@@ -89,6 +109,17 @@ bool cpu_thread_is_idle(CPUState *cpu)
     if (cpu->stop || !cpu_work_list_empty(cpu)) {
         return false;
     }
+    /*
+     * 在以下使用cpu_is_stopped():
+     *   - system/cpus.c|101| <<cpu_thread_is_idle>> if (cpu_is_stopped(cpu)) {
+     *   - system/cpus.c|571| <<cpu_can_run>> if (cpu_is_stopped(cpu)) {
+     *   - target/i386/kvm/kvm.c|5383| <<kvm_arch_put_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/kvm/kvm.c|5483| <<kvm_arch_get_registers>> assert(cpu_is_stopped(cs) || qemu_cpu_is_self(cs));
+     *   - target/i386/nvmm/nvmm-all.c|93| <<nvmm_set_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/nvmm/nvmm-all.c|231| <<nvmm_get_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/whpx/whpx-all.c|395| <<whpx_set_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/whpx/whpx-all.c|610| <<whpx_get_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     */
     if (cpu_is_stopped(cpu)) {
         return true;
     }
@@ -131,6 +162,16 @@ void hw_error(const char *fmt, ...)
     abort();
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_states():
+ *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+ *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+ *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+ *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+ *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+ *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+ *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+ */
 void cpu_synchronize_all_states(void)
 {
     CPUState *cpu;
@@ -140,6 +181,11 @@ void cpu_synchronize_all_states(void)
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_post_reset():
+ *   - hw/i386/pc.c|1727| <<pc_machine_wakeup>> cpu_synchronize_all_post_reset();
+ *   - system/runstate.c|615| <<qemu_system_reset>> cpu_synchronize_all_post_reset();
+ */
 void cpu_synchronize_all_post_reset(void)
 {
     CPUState *cpu;
@@ -149,6 +195,24 @@ void cpu_synchronize_all_post_reset(void)
     }
 }
 
+/*
+ * 迁移后在Target:
+ * (gdb) bt
+ * #0  cpu_synchronize_all_post_init () at ../system/cpus.c:153
+ * #1  0x0000555555c7e7b2 in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3206
+ * #2  0x0000555555c600fa in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:891
+ * #3  0x0000555556174e10 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #4  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #5  0x00007fffffffc7e0 in ?? ()
+ * #6  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用cpu_synchronize_all_post_init():
+ *   - hw/core/machine.c|1732| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|2368| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3346| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3363| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+ */
 void cpu_synchronize_all_post_init(void)
 {
     CPUState *cpu;
@@ -158,6 +222,10 @@ void cpu_synchronize_all_post_init(void)
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_pre_loadvm():
+ *   - migration/savevm.c|3454| <<qemu_loadvm_state>> cpu_synchronize_all_pre_loadvm();
+ */
 void cpu_synchronize_all_pre_loadvm(void)
 {
     CPUState *cpu;
@@ -167,13 +235,86 @@ void cpu_synchronize_all_pre_loadvm(void)
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_state():
+ *   - gdbstub/gdbstub.c|662| <<gdb_set_cpu_pc>> cpu_synchronize_state(cpu);
+ *   - gdbstub/gdbstub.c|1321| <<handle_write_all_regs>> cpu_synchronize_state(gdbserver_state.g_cpu);
+ *   - gdbstub/gdbstub.c|1340| <<handle_read_all_regs>> cpu_synchronize_state(gdbserver_state.g_cpu);
+ *   - gdbstub/gdbstub.c|1636| <<handle_query_thread_extra>> cpu_synchronize_state(cpu);
+ *   - hw/core/cpu-common.c|106| <<cpu_dump_state>> cpu_synchronize_state(cpu);
+ *   - hw/i386/kvm/apic.c|170| <<do_inject_external_nmi>> cpu_synchronize_state(cpu);
+ *   - hw/i386/kvm/clock.c|99| <<kvmclock_current_nsec>> cpu_synchronize_state(cpu);
+ *   - hw/i386/vapic.c|475| <<vapic_report_tpr_access>> cpu_synchronize_state(cs);
+ *   - hw/i386/vapic.c|651| <<vapic_write>> cpu_synchronize_state(current_cpu);
+ *   - hw/i386/vmport.c|107| <<vmport_ioport_read>> cpu_synchronize_state(cs);
+ *   - hw/ppc/pnv.c|2849| <<pnv_cpu_do_nmi_on_cpu>> cpu_synchronize_state(cs);
+ *   - hw/ppc/pnv_xscom.c|51| <<xscom_complete>> cpu_synchronize_state(cs);
+ *   - hw/ppc/ppce500_spin.c|81| <<spin_kick>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr.c|1351| <<do_lpcr_sync>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr.c|3503| <<spapr_do_system_reset_on_cpu>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr_hcall.c|138| <<do_push_sregs_to_kvm_pr>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr_hcall.c|209| <<h_set_sprg0>> cpu_synchronize_state(CPU(cpu));
+ *   - hw/ppc/spapr_hcall.c|221| <<h_set_dabr>> cpu_synchronize_state(CPU(cpu));
+ *   - hw/ppc/spapr_hcall.c|247| <<h_set_xdabr>> cpu_synchronize_state(CPU(cpu));
+ *   - hw/ppc/spapr_rtas.c|162| <<rtas_start_cpu>> cpu_synchronize_state(CPU(newcpu));
+ *   - monitor/hmp-cmds-target.c|72| <<mon_get_cpu_sync>> cpu_synchronize_state(cpu);
+ *   - system/cpus.c|149| <<cpu_synchronize_all_states>> cpu_synchronize_state(cpu);
+ *   - system/physmem.c|3745| <<cpu_memory_rw_debug>> cpu_synchronize_state(cpu);
+ *   - target/arm/cpu.c|1113| <<arm_cpu_virtio_is_big_endian>> cpu_synchronize_state(cs);
+ *   - target/arm/hvf/hvf.c|1455| <<hvf_sysreg_read>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1772| <<hvf_sysreg_write>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1977| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1989| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1999| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|2084| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|2097| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|2112| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|2353| <<hvf_arch_update_guest_debug>> cpu_synchronize_state(cpu);
+ *   - target/i386/cpu-apic.c|100| <<hmp_info_local_apic>> cpu_synchronize_state(cs);
+ *   - target/i386/helper.c|395| <<do_inject_x86_mce>> cpu_synchronize_state(cs);
+ *   - target/i386/hvf/x86hvf.c|436| <<hvf_process_events>> cpu_synchronize_state(cs);
+ *   - target/i386/hvf/x86hvf.c|450| <<hvf_process_events>> cpu_synchronize_state(cs);
+ *   - target/i386/hvf/x86hvf.c|455| <<hvf_process_events>> cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|752| <<kvm_mce_inject>> cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5934| <<kvm_handle_debug>> cpu_synchronize_state(cs);
+ *   - target/ppc/compat.c|192| <<ppc_set_compat>> cpu_synchronize_state(CPU(cpu));
+ *   - target/ppc/cpu_init.c|7356| <<ppc_cpu_is_big_endian>> cpu_synchronize_state(cs);
+ *   - target/ppc/kvm.c|1649| <<kvm_handle_debug>> cpu_synchronize_state(cs);
+ *   - target/ppc/kvm.c|2894| <<kvm_handle_nmi>> cpu_synchronize_state(CPU(cpu));
+ *   - target/ppc/mmu-hash64.c|91| <<dump_slb>> cpu_synchronize_state(CPU(cpu));
+ *   - target/s390x/cpu-system.c|96| <<s390_cpu_get_crash_info>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|147| <<sigp_stop_and_store_status>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|166| <<sigp_store_status_at_address>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|219| <<sigp_store_adtl_status>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|236| <<sigp_restart>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|256| <<sigp_initial_cpu_reset>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|266| <<sigp_cpu_reset>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|278| <<sigp_set_prefix>> cpu_synchronize_state(cs);
+ *
+ * 等同kvm_arch_get_registers()
+ */
 void cpu_synchronize_state(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state():
+     *   - accel/hvf/hvf-accel-ops.c|382| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|111| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - system/cpus.c|204| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|205| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|94| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|97| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     if (cpus_accel->synchronize_state) {
         cpus_accel->synchronize_state(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_post_reset():
+ *   - system/cpus.c|158| <<cpu_synchronize_all_post_reset>> cpu_synchronize_post_reset(cpu);
+ *   - target/s390x/sigp.c|258| <<sigp_initial_cpu_reset>> cpu_synchronize_post_reset(cs);
+ *   - target/s390x/sigp.c|268| <<sigp_cpu_reset>> cpu_synchronize_post_reset(cs);
+ */
 void cpu_synchronize_post_reset(CPUState *cpu)
 {
     if (cpus_accel->synchronize_post_reset) {
@@ -181,15 +322,68 @@ void cpu_synchronize_post_reset(CPUState *cpu)
     }
 }
 
+/*
+ * 多个vCPU
+ * (gdb) bt
+ * #0  cpu_synchronize_post_init (cpu=0x5555578f8060) at ../system/cpus.c:186
+ * #1  0x0000555555c08773 in cpu_synchronize_all_post_init () at ../system/cpus.c:157
+ * #2  0x0000555555c7e70e in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3199
+ * #3  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #4  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #5  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #6  0x00007fffffffc7e0 in ?? ()
+ * #7  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用cpu_synchronize_post_init():
+ *   - hw/core/cpu-common.c|266| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+ *   - system/cpus.c|167| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+ *   - target/s390x/gdbstub.c|92| <<cpu_write_ac_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|210| <<cpu_write_c_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|250| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|254| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|258| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|262| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|302| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|306| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|310| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|314| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|342| <<cpu_write_gs_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/sigp.c|295| <<sigp_set_prefix>> cpu_synchronize_post_init(cs);
+ *
+ * kvm_cpu_synchronize_post_init()
+ */
 void cpu_synchronize_post_init(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     if (cpus_accel->synchronize_post_init) {
         cpus_accel->synchronize_post_init(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_pre_loadvm():
+ *   - system/cpus.c|183| <<cpu_synchronize_all_pre_loadvm>> cpu_synchronize_pre_loadvm(cpu);
+ */
 void cpu_synchronize_pre_loadvm(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+     *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+     *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+     *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+     *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+     */
     if (cpus_accel->synchronize_pre_loadvm) {
         cpus_accel->synchronize_pre_loadvm(cpu);
     }
@@ -285,6 +479,57 @@ bool vm_get_suspended(void)
     return vm_was_suspended;
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_scsi_common_stop (vsc=0x55555850f310) at ../hw/scsi/vhost-scsi-common.c:106
+ * #1  0x0000555555b1a46e in vhost_scsi_stop (s=0x55555850f310) at ../hw/scsi/vhost-scsi.c:114
+ * #2  0x0000555555b1a544 in vhost_scsi_set_status (vdev=0x55555850f310, val=15 '\017') at ../hw/scsi/vhost-scsi.c:140
+ * #3  0x0000555555ef03d4 in virtio_set_status (vdev=0x55555850f310, val=15 '\017') at ../hw/virtio/virtio.c:2263
+ * #4  0x0000555555ef35d7 in virtio_vmstate_change (opaque=0x55555850f310, running=false, state=RUN_STATE_PAUSED) at ../hw/virtio/virtio.c:3464
+ * #5  0x0000555555c37f3f in vm_state_notify (running=false, state=RUN_STATE_PAUSED) at ../system/runstate.c:399
+ * #6  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_PAUSED, send_stop=true) at ../system/cpus.c:300
+ * #7  0x0000555555c09c5a in vm_stop (state=RUN_STATE_PAUSED) at ../system/cpus.c:737
+ * #8  0x0000555555c8bbb3 in qmp_stop (errp=0x0) at ../monitor/qmp-cmds.c:62
+ * #9  0x0000555555c85d42 in hmp_stop (mon=0x555557868360, qdict=0x5555582c7e00) at ../monitor/hmp-cmds.c:93
+ * #10 0x0000555555c89ce5 in handle_hmp_command_exec (mon=0x555557868360, cmd=0x55555742f020 <hmp_cmds+7680>, qdict=0x5555582c7e00) at ../monitor/hmp.c:1106
+ * #11 0x0000555555c89f30 in handle_hmp_command (mon=0x555557868360, cmdline=0x5555578839a4 "") at ../monitor/hmp.c:1158
+ * #12 0x0000555555c86fb5 in monitor_command_cb (opaque=0x555557868360, cmdline=0x5555578839a0 "stop", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #13 0x000055555618534f in readline_handle_byte (rs=0x5555578839a0, ch=13) at ../util/readline.c:427
+ * #14 0x0000555555c8ab87 in monitor_read (opaque=0x555557868360, buf=0x7fffffffc920 "\r\311\377\377\377\177", size=1) at ../monitor/hmp.c:1390
+ * #15 0x0000555556078317 in qemu_chr_be_write_impl (s=0x55555773cb00, buf=0x7fffffffc920 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:214
+ * #16 0x0000555556078388 in qemu_chr_be_write (s=0x55555773cb00, buf=0x7fffffffc920 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:226
+ * #17 0x000055555607b38a in fd_chr_read (chan=0x55555783fbd0, cond=G_IO_IN, opaque=0x55555773cb00) at ../chardev/char-fd.c:72
+ * #18 0x0000555555f4a381 in qio_channel_fd_source_dispatch (source=0x555558542f60, callback=0x55555607b24b <fd_chr_read>, user_data=0x55555773cb00)
+ *     at ../io/channel-watch.c:84
+ * #19 0x00007ffff6fd3854 in g_main_dispatch (context=0x5555575e4840) at ../glib/gmain.c:3325
+ * #20 g_main_context_dispatch (context=0x5555575e4840) at ../glib/gmain.c:4043
+ * #21 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #22 0x00005555561721d5 in os_host_main_loop_wait (timeout=971330) at ../util/main-loop.c:310
+ * #23 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #24 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #25 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #26 0x0000555556082a7f in main (argc=25, argv=0x7fffffffdbd8) at ../system/main.c:93
+ *
+ *
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:232
+ * #1  0x0000555555c08b8c in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:295
+ * #2  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #3  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #4  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #5  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用do_vm_stop():
+ *   - system/cpus.c|322| <<vm_shutdown>> return do_vm_stop(RUN_STATE_SHUTDOWN, false);
+ *   - system/cpus.c|737| <<vm_stop>> return do_vm_stop(state, true);
+ */
 static int do_vm_stop(RunState state, bool send_stop)
 {
     int ret = 0;
@@ -295,8 +540,21 @@ static int do_vm_stop(RunState state, bool send_stop)
         runstate_set(state);
         cpu_disable_ticks();
         if (oldstate == RUN_STATE_RUNNING) {
+            /*
+	     * 在以下使用pause_all_vcpus():
+             *   - hw/i386/vapic.c|688| <<vapic_write>> pause_all_vcpus();
+             *   - system/cpus.c|390| <<do_vm_stop>> pause_all_vcpus();
+             *   - system/runstate.c|778| <<qemu_system_suspend>> pause_all_vcpus();
+             *   - system/runstate.c|938| <<main_loop_should_exit>> pause_all_vcpus();
+             *   - system/runstate.c|952| <<main_loop_should_exit>> pause_all_vcpus();
+	     */
             pause_all_vcpus();
         }
+        /*
+	 * 在以下使用vm_state_notify():
+	 *   - system/cpus.c|300| <<do_vm_stop>> ret = vm_state_notify(0, state);
+	 *   - system/cpus.c|778| <<vm_prepare_start>> vm_state_notify(1, state);
+	 */
         ret = vm_state_notify(0, state);
         if (send_stop) {
             qapi_event_send_stop();
@@ -319,6 +577,11 @@ static int do_vm_stop(RunState state, bool send_stop)
  */
 int vm_shutdown(void)
 {
+    /*
+     * 在以下使用do_vm_stop():
+     *   - system/cpus.c|322| <<vm_shutdown>> return do_vm_stop(RUN_STATE_SHUTDOWN, false);
+     *   - system/cpus.c|737| <<vm_stop>> return do_vm_stop(state, true);
+     */
     return do_vm_stop(RUN_STATE_SHUTDOWN, false);
 }
 
@@ -327,6 +590,17 @@ bool cpu_can_run(CPUState *cpu)
     if (cpu->stop) {
         return false;
     }
+    /*
+     * 在以下使用cpu_is_stopped():
+     *   - system/cpus.c|101| <<cpu_thread_is_idle>> if (cpu_is_stopped(cpu)) {
+     *   - system/cpus.c|571| <<cpu_can_run>> if (cpu_is_stopped(cpu)) {
+     *   - target/i386/kvm/kvm.c|5383| <<kvm_arch_put_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/kvm/kvm.c|5483| <<kvm_arch_get_registers>> assert(cpu_is_stopped(cs) || qemu_cpu_is_self(cs));
+     *   - target/i386/nvmm/nvmm-all.c|93| <<nvmm_set_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/nvmm/nvmm-all.c|231| <<nvmm_get_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/whpx/whpx-all.c|395| <<whpx_set_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/whpx/whpx-all.c|610| <<whpx_get_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     */
     if (cpu_is_stopped(cpu)) {
         return false;
     }
@@ -349,6 +623,15 @@ void cpu_handle_guest_debug(CPUState *cpu)
     } else {
         gdb_set_stop_cpu(cpu);
         qemu_system_debug_request();
+        /*
+	 * 几乎是核心的时候地方cpu->stopped:
+         *   - system/cpus.c|79| <<cpu_is_stopped>> return cpu->stopped || !runstate_is_running();
+         *   - system/cpus.c|543| <<cpu_handle_guest_debug>> cpu->stopped = true;
+         *   - system/cpus.c|631| <<qemu_cpu_stop>> cpu->stopped = true;
+         *   - system/cpus.c|799| <<cpu_resume>> cpu->stopped = false;
+         *   - system/cpus.c|808| <<all_vcpus_paused>> if (!cpu->stopped) {
+         *   - system/cpus.c|895| <<qemu_init_vcpu>> cpu->stopped = true;
+	 */
         cpu->stopped = true;
     }
 }
@@ -437,6 +720,15 @@ static void qemu_cpu_stop(CPUState *cpu, bool exit)
 {
     g_assert(qemu_cpu_is_self(cpu));
     cpu->stop = false;
+    /*
+     * 几乎是核心的时候地方cpu->stopped:
+     *   - system/cpus.c|79| <<cpu_is_stopped>> return cpu->stopped || !runstate_is_running();
+     *   - system/cpus.c|543| <<cpu_handle_guest_debug>> cpu->stopped = true;
+     *   - system/cpus.c|631| <<qemu_cpu_stop>> cpu->stopped = true;
+     *   - system/cpus.c|799| <<cpu_resume>> cpu->stopped = false;
+     *   - system/cpus.c|808| <<all_vcpus_paused>> if (!cpu->stopped) {
+     *   - system/cpus.c|895| <<qemu_init_vcpu>> cpu->stopped = true;
+     */
     cpu->stopped = true;
     if (exit) {
         cpu_exit(cpu);
@@ -444,6 +736,18 @@ static void qemu_cpu_stop(CPUState *cpu, bool exit)
     qemu_cond_broadcast(&qemu_pause_cond);
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_arch_put_registers (cpu=0x5555577517f0, level=2, errp=0x7fffedb02580) at ../target/i386/kvm/kvm.c:5252
+ * #1  0x0000555555f0bc3e in do_kvm_cpu_synchronize_post_reset (cpu=0x5555577517f0, arg=...) at ../accel/kvm/kvm-all.c:2893
+ * #2  0x000055555588e3ab in process_queued_cpu_work (cpu=0x5555577517f0) at ../cpu-common.c:374
+ * #3  0x0000555555c1e021 in qemu_wait_io_event_common (cpu=0x5555577517f0) at ../system/cpus.c:451
+ * #4  0x0000555555c1e0ba in qemu_wait_io_event (cpu=0x5555577517f0) at ../system/cpus.c:469
+ * #5  0x0000555555f0fef1 in kvm_vcpu_thread_fn (arg=0x5555577517f0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #6  0x00005555561ad4c6 in qemu_thread_start (args=0x55555775bc80) at ../util/qemu-thread-posix.c:541
+ * #7  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #8  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 void qemu_wait_io_event_common(CPUState *cpu)
 {
     qatomic_set_mb(&cpu->thread_kicked, false);
@@ -453,6 +757,18 @@ void qemu_wait_io_event_common(CPUState *cpu)
     process_queued_cpu_work(cpu);
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_arch_put_registers (cpu=0x5555577517f0, level=2, errp=0x7fffedb02580) at ../target/i386/kvm/kvm.c:5252
+ * #1  0x0000555555f0bc3e in do_kvm_cpu_synchronize_post_reset (cpu=0x5555577517f0, arg=...) at ../accel/kvm/kvm-all.c:2893
+ * #2  0x000055555588e3ab in process_queued_cpu_work (cpu=0x5555577517f0) at ../cpu-common.c:374
+ * #3  0x0000555555c1e021 in qemu_wait_io_event_common (cpu=0x5555577517f0) at ../system/cpus.c:451
+ * #4  0x0000555555c1e0ba in qemu_wait_io_event (cpu=0x5555577517f0) at ../system/cpus.c:469
+ * #5  0x0000555555f0fef1 in kvm_vcpu_thread_fn (arg=0x5555577517f0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #6  0x00005555561ad4c6 in qemu_thread_start (args=0x55555775bc80) at ../util/qemu-thread-posix.c:541
+ * #7  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #8  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 void qemu_wait_io_event(CPUState *cpu)
 {
     bool slept = false;
@@ -492,6 +808,9 @@ void cpus_kick_thread(CPUState *cpu)
 void qemu_cpu_kick(CPUState *cpu)
 {
     qemu_cond_broadcast(cpu->halt_cond);
+    /*
+     * kick_vcpu_thread没有kvm的.
+     */
     if (cpus_accel->kick_vcpu_thread) {
         cpus_accel->kick_vcpu_thread(cpu);
     } else { /* default */
@@ -592,6 +911,11 @@ void cpu_thread_signal_destroyed(CPUState *cpu)
     qemu_cond_signal(&qemu_cpu_cond);
 }
 
+/*
+ * 在以下使用cpu_pause():
+ *   - hw/ppc/pnv_core.c|253| <<pnv_core_power10_xscom_write>> cpu_pause(cs);
+ *   - system/cpus.c|830| <<pause_all_vcpus>> cpu_pause(cpu);
+ */
 void cpu_pause(CPUState *cpu)
 {
     if (qemu_cpu_is_self(cpu)) {
@@ -602,18 +926,50 @@ void cpu_pause(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用cpu_resume():
+ *   - gdbstub/system.c|590| <<gdb_continue_partial>> cpu_resume(cpu);
+ *   - gdbstub/system.c|595| <<gdb_continue_partial>> cpu_resume(cpu);
+ *   - hw/core/cpu-common.c|267| <<cpu_common_realizefn>> cpu_resume(cpu);
+ *   - system/cpus.c|975| <<resume_all_vcpus>> cpu_resume(cpu);
+ */
 void cpu_resume(CPUState *cpu)
 {
     cpu->stop = false;
+    /*
+     * 几乎是核心的时候地方cpu->stopped:
+     *   - system/cpus.c|79| <<cpu_is_stopped>> return cpu->stopped || !runstate_is_running();
+     *   - system/cpus.c|543| <<cpu_handle_guest_debug>> cpu->stopped = true;
+     *   - system/cpus.c|631| <<qemu_cpu_stop>> cpu->stopped = true;
+     *   - system/cpus.c|799| <<cpu_resume>> cpu->stopped = false;
+     *   - system/cpus.c|808| <<all_vcpus_paused>> if (!cpu->stopped) {
+     *   - system/cpus.c|895| <<qemu_init_vcpu>> cpu->stopped = true;
+     */
     cpu->stopped = false;
+    /*
+     * cpus_kick_thread()发送SIG_IPI.
+     */
     qemu_cpu_kick(cpu);
 }
 
+/*
+ * 在以下使用all_vcpus_paused():
+ *   - system/cpus.c|838| <<pause_all_vcpus>> while (!all_vcpus_paused()) {
+ */
 static bool all_vcpus_paused(void)
 {
     CPUState *cpu;
 
     CPU_FOREACH(cpu) {
+        /*
+	 * 几乎是核心的时候地方cpu->stopped:
+         *   - system/cpus.c|79| <<cpu_is_stopped>> return cpu->stopped || !runstate_is_running();
+         *   - system/cpus.c|543| <<cpu_handle_guest_debug>> cpu->stopped = true;
+         *   - system/cpus.c|631| <<qemu_cpu_stop>> cpu->stopped = true;
+         *   - system/cpus.c|799| <<cpu_resume>> cpu->stopped = false;
+         *   - system/cpus.c|808| <<all_vcpus_paused>> if (!cpu->stopped) {
+         *   - system/cpus.c|895| <<qemu_init_vcpu>> cpu->stopped = true;
+	 */
         if (!cpu->stopped) {
             return false;
         }
@@ -622,12 +978,32 @@ static bool all_vcpus_paused(void)
     return true;
 }
 
+/*
+ * 在以下使用pause_all_vcpus():
+ *   - hw/i386/vapic.c|688| <<vapic_write>> pause_all_vcpus();
+ *   - system/cpus.c|390| <<do_vm_stop>> pause_all_vcpus();
+ *   - system/runstate.c|778| <<qemu_system_suspend>> pause_all_vcpus();
+ *   - system/runstate.c|938| <<main_loop_should_exit>> pause_all_vcpus();
+ *   - system/runstate.c|952| <<main_loop_should_exit>> pause_all_vcpus();
+ */
 void pause_all_vcpus(void)
 {
     CPUState *cpu;
 
+    /*
+     * 在以下使用qemu_clock_enable():
+     *   - accel/tcg/tcg-accel-ops-rr.c|251| <<rr_cpu_thread_fn>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL,
+     *   - gdbstub/system.c|605| <<gdb_continue_partial>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);
+     *   - system/cpus.c|828| <<pause_all_vcpus>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL, false);
+     *   - system/cpus.c|858| <<resume_all_vcpus>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);
+     */
     qemu_clock_enable(QEMU_CLOCK_VIRTUAL, false);
     CPU_FOREACH(cpu) {
+        /*
+	 * 在以下使用cpu_pause():
+         *   - hw/ppc/pnv_core.c|253| <<pnv_core_power10_xscom_write>> cpu_pause(cs);
+         *   - system/cpus.c|830| <<pause_all_vcpus>> cpu_pause(cpu);
+	 */
         cpu_pause(cpu);
     }
 
@@ -648,6 +1024,13 @@ void pause_all_vcpus(void)
     bql_lock();
 }
 
+/*
+ * 在以下使用resume_all_vcpus():
+ *   - hw/i386/vapic.c|691| <<vapic_write>> resume_all_vcpus();
+ *   - system/cpus.c|1190| <<vm_start>> resume_all_vcpus();
+ *   - system/runstate.c|972| <<main_loop_should_exit>> resume_all_vcpus();
+ *   - system/runstate.c|988| <<main_loop_should_exit>> resume_all_vcpus();
+ */
 void resume_all_vcpus(void)
 {
     CPUState *cpu;
@@ -656,8 +1039,22 @@ void resume_all_vcpus(void)
         return;
     }
 
+    /*
+     * 在以下使用qemu_clock_enable():
+     *   - accel/tcg/tcg-accel-ops-rr.c|251| <<rr_cpu_thread_fn>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL,
+     *   - gdbstub/system.c|605| <<gdb_continue_partial>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);
+     *   - system/cpus.c|828| <<pause_all_vcpus>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL, false);
+     *   - system/cpus.c|858| <<resume_all_vcpus>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);
+     */
     qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);
     CPU_FOREACH(cpu) {
+        /*
+	 * 在以下使用cpu_resume():
+         *   - gdbstub/system.c|590| <<gdb_continue_partial>> cpu_resume(cpu);
+         *   - gdbstub/system.c|595| <<gdb_continue_partial>> cpu_resume(cpu);
+         *   - hw/core/cpu-common.c|267| <<cpu_common_realizefn>> cpu_resume(cpu);
+         *   - system/cpus.c|975| <<resume_all_vcpus>> cpu_resume(cpu);
+	 */
         cpu_resume(cpu);
     }
 }
@@ -693,6 +1090,15 @@ void qemu_init_vcpu(CPUState *cpu)
     MachineState *ms = MACHINE(qdev_get_machine());
 
     cpu->nr_threads =  ms->smp.threads;
+    /*
+     * 几乎是核心的时候地方cpu->stopped:
+     *   - system/cpus.c|79| <<cpu_is_stopped>> return cpu->stopped || !runstate_is_running();
+     *   - system/cpus.c|543| <<cpu_handle_guest_debug>> cpu->stopped = true;
+     *   - system/cpus.c|631| <<qemu_cpu_stop>> cpu->stopped = true;
+     *   - system/cpus.c|799| <<cpu_resume>> cpu->stopped = false;
+     *   - system/cpus.c|808| <<all_vcpus_paused>> if (!cpu->stopped) {
+     *   - system/cpus.c|895| <<qemu_init_vcpu>> cpu->stopped = true;
+     */
     cpu->stopped = true;
     cpu->random_seed = qemu_guest_random_seed_thread_part1();
 
@@ -721,6 +1127,36 @@ void cpu_stop_current(void)
     }
 }
 
+/*
+ * 在以下使用vm_stop():
+ *   - accel/kvm/kvm-all.c|2923| <<do_kvm_cpu_synchronize_state>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - accel/kvm/kvm-all.c|2949| <<do_kvm_cpu_synchronize_post_reset>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - accel/kvm/kvm-all.c|3346| <<kvm_cpu_exec>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - dump/dump.c|1802| <<dump_init>> vm_stop(RUN_STATE_SAVE_VM);
+ *   - gdbstub/gdbstub.c|2364| <<gdb_read_byte>> vm_stop(RUN_STATE_PAUSED);
+ *   - gdbstub/system.c|102| <<gdb_chr_event>> vm_stop(RUN_STATE_PAUSED);
+ *   - gdbstub/system.c|120| <<gdb_syscall_handling>> vm_stop(RUN_STATE_DEBUG);
+ *   - gdbstub/system.c|228| <<gdb_sigterm_handler>> vm_stop(RUN_STATE_PAUSED);
+ *   - hw/ppc/prep_systemio.c|78| <<prep_port0092_write>> vm_stop(RUN_STATE_PAUSED);
+ *   - hw/ppc/vof.c|921| <<vof_client_handle>> vm_stop(RUN_STATE_PAUSED);
+ *   - hw/vfio/pci.c|3040| <<vfio_err_notifier_handler>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - migration/migration-hmp-cmds.c|450| <<hmp_loadvm>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - migration/savevm.c|3315| <<save_snapshot>> vm_stop(RUN_STATE_SAVE_VM);
+ *   - migration/savevm.c|3386| <<qmp_xen_save_devices_state>> vm_stop(RUN_STATE_SAVE_VM);
+ *   - migration/savevm.c|3431| <<qmp_xen_load_devices_state>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - migration/savevm.c|3610| <<snapshot_load_job_bh>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - monitor/qmp-cmds.c|62| <<qmp_stop>> vm_stop(RUN_STATE_PAUSED);
+ *   - replay/replay-debugging.c|88| <<replay_stop_vm>> vm_stop(RUN_STATE_PAUSED);
+ *   - replay/replay-debugging.c|193| <<replay_seek>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - replay/replay-debugging.c|226| <<replay_stop_vm_debug>> vm_stop(RUN_STATE_DEBUG);
+ *   - replay/replay-debugging.c|253| <<replay_continue_end>> vm_stop(RUN_STATE_DEBUG);
+ *   - system/cpus.c|804| <<vm_stop_force_state>> return vm_stop(state);
+ *   - system/runstate.c|636| <<qemu_system_guest_panicked>> vm_stop(RUN_STATE_GUEST_PANICKED);
+ *   - system/runstate.c|640| <<qemu_system_guest_panicked>> vm_stop(RUN_STATE_GUEST_PANICKED);
+ *   - system/runstate.c|847| <<main_loop_should_exit>> vm_stop(RUN_STATE_DEBUG);
+ *   - system/runstate.c|857| <<main_loop_should_exit>> vm_stop(RUN_STATE_SHUTDOWN);
+ *   - system/runstate.c|895| <<main_loop_should_exit>> vm_stop(r);
+ */
 int vm_stop(RunState state)
 {
     if (qemu_in_vcpu_thread()) {
@@ -734,6 +1170,11 @@ int vm_stop(RunState state)
         return 0;
     }
 
+    /*
+     * 在以下使用do_vm_stop():
+     *   - system/cpus.c|322| <<vm_shutdown>> return do_vm_stop(RUN_STATE_SHUTDOWN, false);
+     *   - system/cpus.c|737| <<vm_stop>> return do_vm_stop(state, true);
+     */
     return do_vm_stop(state, true);
 }
 
@@ -742,6 +1183,11 @@ int vm_stop(RunState state)
  * Returns 0 if the vCPUs should be restarted, -1 on an error condition,
  * and 1 otherwise.
  */
+/*
+ * 在以下使用vm_prepare_start():
+ *   - gdbstub/system.c|578| <<gdb_continue_partial>> if (vm_prepare_start(step_requested)) {
+ *   - system/cpus.c|785| <<vm_start>> if (!vm_prepare_start(false)) {
+ */
 int vm_prepare_start(bool step_pending)
 {
     int ret = vm_was_suspended ? 1 : 0;
@@ -775,11 +1221,52 @@ int vm_prepare_start(bool step_pending)
 
     cpu_enable_ticks();
     runstate_set(state);
+    /*
+     * 在以下使用vm_state_notify():
+     *   - system/cpus.c|300| <<do_vm_stop>> ret = vm_state_notify(0, state);
+     *   - system/cpus.c|778| <<vm_prepare_start>> vm_state_notify(1, state);
+     */
     vm_state_notify(1, state);
     vm_was_suspended = false;
     return ret;
 }
 
+/*
+ * 迁移后在target.
+ * (gdb) bt
+ * #0  vm_start () at ../system/cpus.c:785
+ * #1  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #2  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x5555582b37e0) at ../migration/migration.c:361
+ * #3  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #4  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #5  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #6  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #7  0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #8  g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #9  0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #10 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #11 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #12 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #13 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #14 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用vm_start():
+ *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+ *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+ *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+ *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+ *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+ *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+ *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+ *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+ *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+ *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+ *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+ *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+ *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+ *   - system/cpus.c|793| <<vm_resume>> vm_start();
+ */
 void vm_start(void)
 {
     if (!vm_prepare_start(false)) {
@@ -790,12 +1277,96 @@ void vm_start(void)
 void vm_resume(RunState state)
 {
     if (runstate_is_live(state)) {
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|793| <<vm_resume>> vm_start();
+	 */
         vm_start();
     } else {
         runstate_set(state);
     }
 }
 
+/*
+ * 迁移的时候在Source上的调用:
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 迁移的时候在Target上的调用:
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ * 从QEMU cmdline quit的时候:
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_SHUTDOWN) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f20 in vm_state_notify (running=false, state=RUN_STATE_SHUTDOWN) at ../system/runstate.c:392
+ * #2  0x0000555555c08bba in do_vm_stop (state=RUN_STATE_SHUTDOWN, send_stop=false) at ../system/cpus.c:302
+ * #3  0x0000555555c08bfb in vm_shutdown () at ../system/cpus.c:324
+ * #4  0x0000555555c38ef8 in qemu_cleanup (status=0) at ../system/runstate.c:981
+ * #5  0x0000555556082acb in qemu_default_main (opaque=0x0) at ../system/main.c:51
+ * #6  0x0000555556082b78 in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用vm_stop_force_state():
+ *   - migration/colo.c|216| <<colo_do_failover>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/colo.c|432| <<colo_do_checkpoint_transaction>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/colo.c|668| <<colo_incoming_process_checkpoint>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/migration.c|306| <<migration_stop_vm>> ret = vm_stop_force_state(state);
+ */
 /* does a state transition even if the VM is already stopped,
    current state is forgotten forever */
 int vm_stop_force_state(RunState state)
diff --git a/system/memory.c b/system/memory.c
index 564654794..71c4a8f8a 100644
--- a/system/memory.c
+++ b/system/memory.c
@@ -42,6 +42,27 @@
 static unsigned memory_region_transaction_depth;
 static bool memory_region_update_pending;
 static bool ioeventfd_update_pending;
+/*
+ * 在以下修改global_dirty_tracking:
+ *   - system/memory.c|2950| <<memory_global_dirty_log_start>> global_dirty_tracking |= flags;
+ *   - system/memory.c|2944| <<memory_global_dirty_log_start>> flags &= ~global_dirty_tracking;
+ *   - system/memory.c|2955| <<memory_global_dirty_log_start>> global_dirty_tracking &= ~flags;
+ *   - system/memory.c|2971| <<memory_global_dirty_log_do_stop>> global_dirty_tracking &= ~flags;
+ * 在以下使用global_dirty_tracking:
+ *   - include/system/ram_addr.h|393| <<cpu_physical_memory_set_dirty_lebitmap>> if (global_dirty_tracking) {
+ *   - include/system/ram_addr.h|398| <<cpu_physical_memory_set_dirty_lebitmap>> if (unlikely(global_dirty_tracking & GLOBAL_DIRTY_DIRTY_RATE)) {
+ *   - include/system/ram_addr.h|424| <<cpu_physical_memory_set_dirty_lebitmap>> if (!global_dirty_tracking) {
+ *   - include/system/ram_addr.h|436| <<cpu_physical_memory_set_dirty_lebitmap>> if (unlikely(global_dirty_tracking & GLOBAL_DIRTY_DIRTY_RATE)) {
+ *   - migration/ram.c|2403| <<ram_save_cleanup>> if (global_dirty_tracking & GLOBAL_DIRTY_MIGRATION) {
+ *   - system/memory.c|1888| <<memory_region_get_dirty_log_mask>> if (global_dirty_tracking && ((rb && qemu_ram_is_migratable(rb)) ||
+ *   - system/memory.c|2949| <<memory_global_dirty_log_start>> old_flags = global_dirty_tracking;
+ *   - system/memory.c|2951| <<memory_global_dirty_log_start>> trace_global_dirty_changed(global_dirty_tracking);
+ *   - system/memory.c|2956| <<memory_global_dirty_log_start>> trace_global_dirty_changed(global_dirty_tracking);
+ *   - system/memory.c|2970| <<memory_global_dirty_log_do_stop>> assert((global_dirty_tracking & flags) == flags);
+ *   - system/memory.c|2973| <<memory_global_dirty_log_do_stop>> trace_global_dirty_changed(global_dirty_tracking);
+ *   - system/memory.c|2975| <<memory_global_dirty_log_do_stop>> if (!global_dirty_tracking) {
+ *   - system/memory.c|3039| <<listener_add_address_space>> if (global_dirty_tracking) {
+ */
 unsigned int global_dirty_tracking;
 
 static QTAILQ_HEAD(, MemoryListener) memory_listeners
@@ -1880,6 +1901,15 @@ bool memory_region_has_guest_memfd(MemoryRegion *mr)
     return mr->ram_block && mr->ram_block->guest_memfd >= 0;
 }
 
+/*
+ * 在以下使用memory_region_get_dirty_log_mask():
+ *   - accel/kvm/kvm-all.c|668| <<kvm_mem_flags>> if (memory_region_get_dirty_log_mask(mr) != 0) {
+ *   - hw/virtio/vhost.c|568| <<vhost_section>> uint8_t dirty_mask = memory_region_get_dirty_log_mask(mr);
+ *   - system/memory.c|671| <<render_memory_region>> fr.dirty_log_mask = memory_region_get_dirty_log_mask(mr);
+ *   - system/memory.c|1923| <<memory_region_is_logging>> return memory_region_get_dirty_log_mask(mr) & (1 << client);
+ *   - system/memory.c|2280| <<memory_region_set_dirty>> memory_region_get_dirty_log_mask(mr));
+ *   - system/physmem.c|2836| <<invalidate_and_set_dirty>> uint8_t dirty_log_mask = memory_region_get_dirty_log_mask(mr);
+ */
 uint8_t memory_region_get_dirty_log_mask(MemoryRegion *mr)
 {
     uint8_t mask = mr->dirty_log_mask;
@@ -2232,6 +2262,21 @@ MemoryRegion *memory_translate_iotlb(IOMMUTLBEntry *iotlb, hwaddr *xlat_p,
     return mr;
 }
 
+/*
+ * 在以下使用memory_region_set_log():
+ *   - hw/display/bochs-display.c|311| <<bochs_display_realize>> memory_region_set_log(&s->vram, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/cg3.c|314| <<cg3_realizefn>> memory_region_set_log(&s->vram_mem, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/exynos4210_fimd.c|1148| <<fimd_update_memory_section>> memory_region_set_log(w->mem_section.mr, false, DIRTY_MEMORY_VGA);
+ *   - hw/display/exynos4210_fimd.c|1181| <<fimd_update_memory_section>> memory_region_set_log(w->mem_section.mr, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/framebuffer.c|34| <<framebuffer_update_memory_section>> memory_region_set_log(mem_section->mr, false, DIRTY_MEMORY_VGA);
+ *   - hw/display/framebuffer.c|51| <<framebuffer_update_memory_section>> memory_region_set_log(mem_section->mr, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/g364fb.c|484| <<g364fb_init>> memory_region_set_log(&s->mem_vram, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/macfb.c|682| <<macfb_common_realize>> memory_region_set_log(&s->mem_vram, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/sm501.c|1905| <<sm501_init>> memory_region_set_log(&s->local_mem_region, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/tcx.c|821| <<tcx_realizefn>> memory_region_set_log(&s->vram_mem, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/vga.c|1467| <<vga_dirty_log_start>> memory_region_set_log(&s->vram, true, DIRTY_MEMORY_VGA);
+ *   - hw/display/vga.c|1472| <<vga_dirty_log_stop>> memory_region_set_log(&s->vram, false, DIRTY_MEMORY_VGA);
+ */
 void memory_region_set_log(MemoryRegion *mr, bool log, unsigned client)
 {
     uint8_t mask = 1 << client;
@@ -2929,6 +2974,14 @@ err:
     return false;
 }
 
+/*
+ * 在以下使用memory_global_dirty_log_start():
+ *   - hw/i386/xen/xen-hvm.c|702| <<qmp_xen_set_global_dirty_log>> memory_global_dirty_log_start(GLOBAL_DIRTY_MIGRATION, errp);
+ *   - migration/dirtyrate.c|98| <<global_dirty_log_change>> ret = memory_global_dirty_log_start(flag, &local_err)
+ *   - migration/dirtyrate.c|622| <<calculate_dirtyrate_dirty_bitmap>> if (!memory_global_dirty_log_start(GLOBAL_DIRTY_DIRTY_RATE, &local_err)) {
+ *   - migration/ram.c|2816| <<ram_init_bitmaps>> ret = memory_global_dirty_log_start(GLOBAL_DIRTY_MIGRATION, errp);
+ *   - migration/ram.c|3639| <<colo_incoming_start_dirty_log>> if (!memory_global_dirty_log_start(GLOBAL_DIRTY_MIGRATION,
+ */
 bool memory_global_dirty_log_start(unsigned int flags, Error **errp)
 {
     unsigned int old_flags;
diff --git a/system/qdev-monitor.c b/system/qdev-monitor.c
index 2ac92d0a0..1799ea473 100644
--- a/system/qdev-monitor.c
+++ b/system/qdev-monitor.c
@@ -902,6 +902,12 @@ void qdev_unplug(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用qdev_hot_removed:
+     *   - hw/core/qdev.c|44| <<global>> bool qdev_hot_removed = false;
+     *   - hw/core/qdev.c|314| <<qdev_machine_modified>> return qdev_hot_added || qdev_hot_removed;
+     *   - system/qdev-monitor.c|905| <<qdev_unplug>> qdev_hot_removed = true;
+     */
     qdev_hot_removed = true;
 
     hotplug_ctrl = qdev_get_hotplug_handler(dev);
diff --git a/system/runstate.c b/system/runstate.c
index 6178b0091..71ee58085 100644
--- a/system/runstate.c
+++ b/system/runstate.c
@@ -64,6 +64,17 @@
 static NotifierList exit_notifiers =
     NOTIFIER_LIST_INITIALIZER(exit_notifiers);
 
+/*
+ * 在以下使用current_run_state:
+ *   - system/runstate.c|195| <<runstate_check>> return current_run_state == state;
+ *   - system/runstate.c|234| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+ *   - system/runstate.c|237| <<runstate_set>> if (current_run_state == new_state) {
+ *   - system/runstate.c|241| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+ *   - system/runstate.c|243| <<runstate_set>> RunState_str(current_run_state),
+ *   - system/runstate.c|248| <<runstate_set>> current_run_state = new_state;
+ *   - system/runstate.c|253| <<runstate_get>> return current_run_state;
+ *   - system/runstate.c|272| <<qmp_query_status>> info->status = current_run_state;
+ */
 static RunState current_run_state = RUN_STATE_PRELAUNCH;
 
 /* We use RUN_STATE__MAX but any invalid value will do */
@@ -192,6 +203,17 @@ static bool runstate_valid_transitions[RUN_STATE__MAX][RUN_STATE__MAX];
 
 bool runstate_check(RunState state)
 {
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|195| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|234| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|237| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|241| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|243| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|248| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|253| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|272| <<qmp_query_status>> info->status = current_run_state;
+     */
     return current_run_state == state;
 }
 
@@ -226,6 +248,99 @@ static void runstate_init(void)
     qemu_mutex_init(&vmstop_lock);
 }
 
+/*
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_RUNNING) at ../system/runstate.c:232
+ * #1  0x0000555555c09d1c in vm_prepare_start (step_pending=false) at ../system/cpus.c:777
+ * #2  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #3  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #4  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #5  0x0000555555c06e99 in qemu_init (argc=23, argv=0x7fffffffdc38) at ../system/vl.c:3840
+ * #6  0x0000555556082a15 in main (argc=23, argv=0x7fffffffdc38) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_PAUSED) at ../system/runstate.c:232
+ * #1  0x0000555555c08b8c in do_vm_stop (state=RUN_STATE_PAUSED, send_stop=true) at ../system/cpus.c:295
+ * #2  0x0000555555c09c5a in vm_stop (state=RUN_STATE_PAUSED) at ../system/cpus.c:737
+ * #3  0x0000555555c8bbb3 in qmp_stop (errp=0x0) at ../monitor/qmp-cmds.c:62
+ * #4  0x0000555555c85d42 in hmp_stop (mon=0x555557867690, qdict=0x5555582ac400) at ../monitor/hmp-cmds.c:93
+ * #5  0x0000555555c89ce5 in handle_hmp_command_exec (mon=0x555557867690, cmd=0x55555742f020 <hmp_cmds+7680>, qdict=0x5555582ac400) at ../monitor/hmp.c:1106
+ * #6  0x0000555555c89f30 in handle_hmp_command (mon=0x555557867690, cmdline=0x5555578829a4 "") at ../monitor/hmp.c:1158
+ * #7  0x0000555555c86fb5 in monitor_command_cb (opaque=0x555557867690, cmdline=0x5555578829a0 "stop", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #8  0x000055555618534f in readline_handle_byte (rs=0x5555578829a0, ch=13) at ../util/readline.c:427
+ * #9  0x0000555555c8ab87 in monitor_read (opaque=0x555557867690, buf=0x7fffffffc980 "\r\311\377\377\377\177", size=1) at ../monitor/hmp.c:1390
+ * #10 0x0000555556078317 in qemu_chr_be_write_impl (s=0x55555773d100, buf=0x7fffffffc980 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:214
+ * #11 0x0000555556078388 in qemu_chr_be_write (s=0x55555773d100, buf=0x7fffffffc980 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:226
+ * #12 0x000055555607b38a in fd_chr_read (chan=0x555557835f00, cond=G_IO_IN, opaque=0x55555773d100) at ../chardev/char-fd.c:72
+ * #13 0x0000555555f4a381 in qio_channel_fd_source_dispatch (source=0x5555582afde0, callback=0x55555607b24b <fd_chr_read>, user_data=0x55555773d100)
+ *     at ../io/channel-watch.c:84
+ * #14 0x00007ffff6fd3854 in g_main_dispatch (context=0x5555575e4580) at ../glib/gmain.c:3325
+ * #15 g_main_context_dispatch (context=0x5555575e4580) at ../glib/gmain.c:4043
+ * #16 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #17 0x00005555561721d5 in os_host_main_loop_wait (timeout=892985) at ../util/main-loop.c:310
+ * #18 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #19 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #20 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #21 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc38) at ../system/main.c:93
+ *
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_RUNNING) at ../system/runstate.c:232
+ * #1  0x0000555555c09d1c in vm_prepare_start (step_pending=false) at ../system/cpus.c:777
+ * #2  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #3  0x0000555555c8bdc9 in qmp_cont (errp=0x7fffffffc720) at ../monitor/qmp-cmds.c:112
+ * #4  0x0000555555c85fae in hmp_cont (mon=0x555557867690, qdict=0x5555582ac400) at ../monitor/hmp-cmds.c:145
+ * #5  0x0000555555c89ce5 in handle_hmp_command_exec (mon=0x555557867690, cmd=0x55555742d8b0 <hmp_cmds+1680>, qdict=0x5555582ac400) at ../monitor/hmp.c:1106
+ * #6  0x0000555555c89f30 in handle_hmp_command (mon=0x555557867690, cmdline=0x5555578829a4 "") at ../monitor/hmp.c:1158
+ * #7  0x0000555555c86fb5 in monitor_command_cb (opaque=0x555557867690, cmdline=0x5555578829a0 "cont", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #8  0x000055555618534f in readline_handle_byte (rs=0x5555578829a0, ch=13) at ../util/readline.c:427
+ * #9  0x0000555555c8ab87 in monitor_read (opaque=0x555557867690, buf=0x7fffffffc980 "\r\311\377\377\377\177", size=1) at ../monitor/hmp.c:1390
+ * #10 0x0000555556078317 in qemu_chr_be_write_impl (s=0x55555773d100, buf=0x7fffffffc980 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:214
+ * #11 0x0000555556078388 in qemu_chr_be_write (s=0x55555773d100, buf=0x7fffffffc980 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:226
+ * #12 0x000055555607b38a in fd_chr_read (chan=0x555557835f00, cond=G_IO_IN, opaque=0x55555773d100) at ../chardev/char-fd.c:72
+ * #13 0x0000555555f4a381 in qio_channel_fd_source_dispatch (source=0x5555582afde0, callback=0x55555607b24b <fd_chr_read>, user_data=0x55555773d100)
+ *     at ../io/channel-watch.c:84
+ * #14 0x00007ffff6fd3854 in g_main_dispatch (context=0x5555575e4580) at ../glib/gmain.c:3325
+ * #15 g_main_context_dispatch (context=0x5555575e4580) at ../glib/gmain.c:4043
+ * #16 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #17 0x00005555561721d5 in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:310
+ * #18 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #19 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #20 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #21 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc38) at ../system/main.c:93
+ *
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_SHUTDOWN) at ../system/runstate.c:232
+ * #1  0x0000555555c08b8c in do_vm_stop (state=RUN_STATE_SHUTDOWN, send_stop=false) at ../system/cpus.c:295
+ * #2  0x0000555555c08bec in vm_shutdown () at ../system/cpus.c:322
+ * #3  0x0000555555c38ee9 in qemu_cleanup (status=0) at ../system/runstate.c:981
+ * #4  0x00005555560829d2 in qemu_default_main (opaque=0x0) at ../system/main.c:51
+ * #5  0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc38) at ../system/main.c:93
+ *
+ *
+ * 迁移的时候在Source上
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:232
+ * #1  0x0000555555c08b8c in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:295
+ * #2  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #3  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #4  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #5  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x555558309590) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在Source上结束的时候
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_POSTMIGRATE) at ../system/runstate.c:232
+ * #1  0x0000555555c65e7b in migration_iteration_finish (s=0x5555575e27f0) at ../migration/migration.c:3518
+ * #2  0x0000555555c66522 in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3797
+ * #3  0x0000555556155700 in qemu_thread_start (args=0x555558309590) at ../util/qemu-thread-posix.c:393
+ * #4  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #5  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 /* This function will abort() on invalid state transitions */
 void runstate_set(RunState new_state)
 {
@@ -250,9 +365,23 @@ void runstate_set(RunState new_state)
 
 RunState runstate_get(void)
 {
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|195| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|234| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|237| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|241| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|243| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|248| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|253| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|272| <<qmp_query_status>> info->status = current_run_state;
+     */
     return current_run_state;
 }
 
+/*
+ * 很多的调用
+ */
 bool runstate_is_running(void)
 {
     return runstate_check(RUN_STATE_RUNNING);
@@ -268,7 +397,21 @@ StatusInfo *qmp_query_status(Error **errp)
 {
     StatusInfo *info = g_malloc0(sizeof(*info));
 
+    /*
+     * 检查是不是RUN_STATE_RUNNING
+     */
     info->running = runstate_is_running();
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|195| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|234| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|237| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|241| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|243| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|248| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|253| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|272| <<qmp_query_status>> info->status = current_run_state;
+     */
     info->status = current_run_state;
 
     return info;
@@ -303,16 +446,47 @@ struct VMChangeStateEntry {
     int priority;
 };
 
+/*
+ * 在以下使用vm_change_state_head():
+ *   - system/runstate.c|449| <<QTAILQ_HEAD>> static QTAILQ_HEAD(, VMChangeStateEntry) vm_change_state_head =
+ *       QTAILQ_HEAD_INITIALIZER(vm_change_state_head);
+ *   - system/runstate.c|450| <<QTAILQ_HEAD>> QTAILQ_HEAD_INITIALIZER(vm_change_state_head);
+ *   - system/runstate.c|476| <<qemu_add_vm_change_state_handler_prio_full>> QTAILQ_FOREACH(other, &vm_change_state_head, entries) {
+ *   - system/runstate.c|483| <<qemu_add_vm_change_state_handler_prio_full>> QTAILQ_INSERT_TAIL(&vm_change_state_head, e, entries);
+ *   - system/runstate.c|495| <<qemu_del_vm_change_state_handler>> QTAILQ_REMOVE(&vm_change_state_head, e, entries);
+ *   - system/runstate.c|512| <<vm_state_notify>> QTAILQ_FOREACH_SAFE(e, &vm_change_state_head, entries, next) {
+ *   - system/runstate.c|518| <<vm_state_notify>> QTAILQ_FOREACH_SAFE(e, &vm_change_state_head, entries, next) {
+ *   - system/runstate.c|532| <<vm_state_notify>> QTAILQ_FOREACH_REVERSE_SAFE(e, &vm_change_state_head, entries, next) {
+ *   - system/runstate.c|538| <<vm_state_notify>> QTAILQ_FOREACH_REVERSE_SAFE(e, &vm_change_state_head, entries, next) {
+ */
 static QTAILQ_HEAD(, VMChangeStateEntry) vm_change_state_head =
     QTAILQ_HEAD_INITIALIZER(vm_change_state_head);
 
+/*
+ * 在以下使用qemu_add_vm_change_state_handler_prio():
+ *   - system/runstate.c|523| <<qemu_add_vm_change_state_handler>> return qemu_add_vm_change_state_handler_prio(cb, opaque, 0);
+ */
 VMChangeStateEntry *qemu_add_vm_change_state_handler_prio(
         VMChangeStateHandler *cb, void *opaque, int priority)
 {
+    /*
+     * 在以下使用qemu_add_vm_change_state_handler_prio_full():
+     *   - hw/core/vm-change-state-handler.c|78| <<qdev_add_vm_change_state_handler_full>>
+     *        return qemu_add_vm_change_state_handler_prio_full(cb, prepare_cb, cb_ret, opaque, depth);
+     *   - system/runstate.c|455| <<qemu_add_vm_change_state_handler_prio>>
+     *        return qemu_add_vm_change_state_handler_prio_full(cb, NULL, NULL, opaque, priority);
+     */
     return qemu_add_vm_change_state_handler_prio_full(cb, NULL, NULL,
                                                       opaque, priority);
 }
 
+/*
+ * 在以下使用qemu_add_vm_change_state_handler_prio_full():
+ *   - hw/core/vm-change-state-handler.c|78| <<qdev_add_vm_change_state_handler_full>>
+ *        return qemu_add_vm_change_state_handler_prio_full(cb, prepare_cb, cb_ret, opaque, depth);
+ *   - system/runstate.c|455| <<qemu_add_vm_change_state_handler_prio>>
+ *        return qemu_add_vm_change_state_handler_prio_full(cb, NULL, NULL, opaque, priority);
+ */
 VMChangeStateEntry *
 qemu_add_vm_change_state_handler_prio_full(VMChangeStateHandler *cb,
                                            VMChangeStateHandler *prepare_cb,
@@ -329,6 +503,19 @@ qemu_add_vm_change_state_handler_prio_full(VMChangeStateHandler *cb,
     e->opaque = opaque;
     e->priority = priority;
 
+    /*
+     * 在以下使用vm_change_state_head():
+     *   - system/runstate.c|449| <<QTAILQ_HEAD>> static QTAILQ_HEAD(, VMChangeStateEntry) vm_change_state_head =
+     *       QTAILQ_HEAD_INITIALIZER(vm_change_state_head);
+     *   - system/runstate.c|450| <<QTAILQ_HEAD>> QTAILQ_HEAD_INITIALIZER(vm_change_state_head);
+     *   - system/runstate.c|476| <<qemu_add_vm_change_state_handler_prio_full>> QTAILQ_FOREACH(other, &vm_change_state_head, entries) {
+     *   - system/runstate.c|483| <<qemu_add_vm_change_state_handler_prio_full>> QTAILQ_INSERT_TAIL(&vm_change_state_head, e, entries);
+     *   - system/runstate.c|495| <<qemu_del_vm_change_state_handler>> QTAILQ_REMOVE(&vm_change_state_head, e, entries);
+     *   - system/runstate.c|512| <<vm_state_notify>> QTAILQ_FOREACH_SAFE(e, &vm_change_state_head, entries, next) {
+     *   - system/runstate.c|518| <<vm_state_notify>> QTAILQ_FOREACH_SAFE(e, &vm_change_state_head, entries, next) {
+     *   - system/runstate.c|532| <<vm_state_notify>> QTAILQ_FOREACH_REVERSE_SAFE(e, &vm_change_state_head, entries, next) {
+     *   - system/runstate.c|538| <<vm_state_notify>> QTAILQ_FOREACH_REVERSE_SAFE(e, &vm_change_state_head, entries, next) {
+     */
     /* Keep list sorted in ascending priority order */
     QTAILQ_FOREACH(other, &vm_change_state_head, entries) {
         if (priority < other->priority) {
@@ -344,15 +531,36 @@ qemu_add_vm_change_state_handler_prio_full(VMChangeStateHandler *cb,
 VMChangeStateEntry *qemu_add_vm_change_state_handler(VMChangeStateHandler *cb,
                                                      void *opaque)
 {
+    /*
+     * 只在这里调用
+     */
     return qemu_add_vm_change_state_handler_prio(cb, opaque, 0);
 }
 
 void qemu_del_vm_change_state_handler(VMChangeStateEntry *e)
 {
+    /*
+     * 在以下使用vm_change_state_head():
+     *   - system/runstate.c|449| <<QTAILQ_HEAD>> static QTAILQ_HEAD(, VMChangeStateEntry) vm_change_state_head =
+     *       QTAILQ_HEAD_INITIALIZER(vm_change_state_head);
+     *   - system/runstate.c|450| <<QTAILQ_HEAD>> QTAILQ_HEAD_INITIALIZER(vm_change_state_head);
+     *   - system/runstate.c|476| <<qemu_add_vm_change_state_handler_prio_full>> QTAILQ_FOREACH(other, &vm_change_state_head, entries) {
+     *   - system/runstate.c|483| <<qemu_add_vm_change_state_handler_prio_full>> QTAILQ_INSERT_TAIL(&vm_change_state_head, e, entries);
+     *   - system/runstate.c|495| <<qemu_del_vm_change_state_handler>> QTAILQ_REMOVE(&vm_change_state_head, e, entries);
+     *   - system/runstate.c|512| <<vm_state_notify>> QTAILQ_FOREACH_SAFE(e, &vm_change_state_head, entries, next) {
+     *   - system/runstate.c|518| <<vm_state_notify>> QTAILQ_FOREACH_SAFE(e, &vm_change_state_head, entries, next) {
+     *   - system/runstate.c|532| <<vm_state_notify>> QTAILQ_FOREACH_REVERSE_SAFE(e, &vm_change_state_head, entries, next) {
+     *   - system/runstate.c|538| <<vm_state_notify>> QTAILQ_FOREACH_REVERSE_SAFE(e, &vm_change_state_head, entries, next) {
+     */
     QTAILQ_REMOVE(&vm_change_state_head, e, entries);
     g_free(e);
 }
 
+/*
+ * 在以下使用vm_state_notify():
+ *   - system/cpus.c|300| <<do_vm_stop>> ret = vm_state_notify(0, state);
+ *   - system/cpus.c|778| <<vm_prepare_start>> vm_state_notify(1, state);
+ */
 int vm_state_notify(bool running, RunState state)
 {
     VMChangeStateEntry *e, *next;
@@ -360,6 +568,20 @@ int vm_state_notify(bool running, RunState state)
 
     trace_vm_state_notify(running, state, RunState_str(state));
 
+    /*
+     * 在以下使用vm_change_state_head():
+     *   - system/runstate.c|449| <<QTAILQ_HEAD>> static QTAILQ_HEAD(, VMChangeStateEntry) vm_change_state_head =
+     *       QTAILQ_HEAD_INITIALIZER(vm_change_state_head);
+     *   - system/runstate.c|450| <<QTAILQ_HEAD>> QTAILQ_HEAD_INITIALIZER(vm_change_state_head);
+     *   - system/runstate.c|476| <<qemu_add_vm_change_state_handler_prio_full>> QTAILQ_FOREACH(other, &vm_change_state_head, entries) {
+     *   - system/runstate.c|483| <<qemu_add_vm_change_state_handler_prio_full>> QTAILQ_INSERT_TAIL(&vm_change_state_head, e, entries);
+     *   - system/runstate.c|495| <<qemu_del_vm_change_state_handler>> QTAILQ_REMOVE(&vm_change_state_head, e, entries);
+     *   - system/runstate.c|512| <<vm_state_notify>> QTAILQ_FOREACH_SAFE(e, &vm_change_state_head, entries, next) {
+     *   - system/runstate.c|518| <<vm_state_notify>> QTAILQ_FOREACH_SAFE(e, &vm_change_state_head, entries, next) {
+     *   - system/runstate.c|532| <<vm_state_notify>> QTAILQ_FOREACH_REVERSE_SAFE(e, &vm_change_state_head, entries, next) {
+     *   - system/runstate.c|538| <<vm_state_notify>> QTAILQ_FOREACH_REVERSE_SAFE(e, &vm_change_state_head, entries, next) {
+     */
+
     if (running) {
         QTAILQ_FOREACH_SAFE(e, &vm_change_state_head, entries, next) {
             if (e->prepare_cb) {
@@ -506,6 +728,14 @@ static int qemu_debug_requested(void)
 /*
  * Reset the VM. Issue an event unless @reason is SHUTDOWN_CAUSE_NONE.
  */
+/*
+ * 在以下使用qemu_system_reset():
+ *   - hw/core/machine.c|1775| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+ *   - hw/xen/xen-hvm-common.c|609| <<cpu_handle_ioreq>> qemu_system_reset(request);
+ *   - migration/savevm.c|3893| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+ *   - system/runstate.c|941| <<main_loop_should_exit>> qemu_system_reset(request);
+ *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+ */
 void qemu_system_reset(ShutdownCause reason)
 {
     MachineClass *mc;
@@ -513,6 +743,18 @@ void qemu_system_reset(ShutdownCause reason)
 
     mc = current_machine ? MACHINE_GET_CLASS(current_machine) : NULL;
 
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     *
+     * kvm_arch_get_registers()
+     */
     cpu_synchronize_all_states();
 
     switch (reason) {
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index 47b0cd3a3..7244f16f7 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -2151,6 +2151,16 @@ static void hvf_vm_state_change(void *opaque, bool running, RunState state)
     if (running) {
         /* Update vtimer offset on all CPUs */
         hvf_state->vtimer_offset = mach_absolute_time() - s->vtimer_val;
+        /*
+	 * 在以下使用cpu_synchronize_all_states():
+         *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+         *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+         *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+         *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+         *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+         *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+         *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+	 */
         cpu_synchronize_all_states();
     } else {
         /* Remember vtimer value on every pause */
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 6d85149e6..76ac4ef87 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -8578,6 +8578,91 @@ static bool cpuid_has_xsave_feature(CPUX86State *env, const ExtSaveArea *esa)
     return false;
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_reset_hold (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../target/i386/cpu.c:8583
+ * #1  0x0000555555f30643 in resettable_phase_hold (obj=0x5555578c1c80, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #2  0x0000555555f30247 in resettable_assert_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #3  0x0000555555f3019f in resettable_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #4  0x0000555555f2dc7f in device_cold_reset (dev=0x5555578c1c80) at ../hw/core/qdev.c:239
+ * #5  0x0000555555892f26 in cpu_reset (cpu=0x5555578c1c80) at ../hw/core/cpu-common.c:113
+ * #6  0x0000555555e21bb8 in x86_cpu_realizefn (dev=0x5555578c1c80, errp=0x7fffffffd500) at ../target/i386/cpu.c:9494
+ * #7  0x0000555555e19e94 in max_x86_cpu_realize (dev=0x5555578c1c80, errp=0x7fffffffd500) at ../target/i386/cpu.c:6715
+ * #8  0x0000555555f2e730 in device_set_realized (obj=0x5555578c1c80, value=true, errp=0x7fffffffd610) at ../hw/core/qdev.c:494
+ * #9  0x0000555555f3869f in property_set_bool (obj=0x5555578c1c80, v=0x5555578cbc00, name=0x55555636b911 "realized", opaque=0x5555575e6860,
+ *     errp=0x7fffffffd610) at ../qom/object.c:2375
+ * #10 0x0000555555f36114 in object_property_set (obj=0x5555578c1c80, name=0x55555636b911 "realized", v=0x5555578cbc00, errp=0x7fffffffd610)
+ *     at ../qom/object.c:1450
+ * #11 0x0000555555f3afa1 in object_property_set_qobject (obj=0x5555578c1c80, name=0x55555636b911 "realized", value=0x5555578c1990,
+ *     errp=0x555557527c40 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #12 0x0000555555f364b9 in object_property_set_bool (obj=0x5555578c1c80, name=0x55555636b911 "realized", value=true, errp=0x555557527c40
+ *     <error_fatal>) at ../qom/object.c:1520
+ * #13 0x0000555555f2de28 in qdev_realize (dev=0x5555578c1c80, bus=0x0, errp=0x555557527c40 <error_fatal>) at ../hw/core/qdev.c:276
+ * #14 0x0000555555dd43aa in x86_cpu_new (x86ms=0x555557848900, apic_id=0, errp=0x555557527c40 <error_fatal>) at ../hw/i386/x86-common.c:64
+ * #15 0x0000555555dd4524 in x86_cpus_init (x86ms=0x555557848900, default_cpu_version=1) at ../hw/i386/x86-common.c:115
+ * #16 0x0000555555ddc4a5 in pc_q35_init (machine=0x555557848900) at ../hw/i386/pc_q35.c:194
+ * #17 0x0000555555ddce75 in pc_q35_machine_10_1_init (machine=0x555557848900) at ../hw/i386/pc_q35.c:382
+ * #18 0x000055555597a3e8 in machine_run_board_init (machine=0x555557848900, mem_path=0x0, errp=0x7fffffffd8e0) at ../hw/core/machine.c:1694
+ * #19 0x0000555555c03fd9 in qemu_init_board () at ../system/vl.c:2710
+ * #20 0x0000555555c0436f in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2804
+ * #21 0x0000555555c06e99 in qemu_init (argc=23, argv=0x7fffffffdc08) at ../system/vl.c:3840
+ * #22 0x0000555556082a15 in main (argc=23, argv=0x7fffffffdc08) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  x86_cpu_reset_hold (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../target/i386/cpu.c:8583
+ * #1  0x0000555555f30643 in resettable_phase_hold (obj=0x5555578c1c80, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #2  0x0000555555f30247 in resettable_assert_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #3  0x0000555555f3019f in resettable_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #4  0x0000555555f2dc7f in device_cold_reset (dev=0x5555578c1c80) at ../hw/core/qdev.c:239
+ * #5  0x0000555555892f26 in cpu_reset (cpu=0x5555578c1c80) at ../hw/core/cpu-common.c:113
+ * #6  0x0000555555d91a51 in x86_cpu_machine_reset_cb (opaque=0x5555578c1c80) at ../target/i386/cpu-system.c:266
+ * #7  0x000055555598181e in legacy_reset_hold (obj=0x5555578c8dc0, type=RESET_TYPE_COLD) at ../hw/core/reset.c:76
+ * #8  0x0000555555f30643 in resettable_phase_hold (obj=0x5555578c8dc0, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #9  0x0000555555f2f6a2 in resettable_container_child_foreach (obj=0x55555786d300, cb=0x555555f3052b <resettable_phase_hold>, opaque=0x0,
+ *     type=RESET_TYPE_COLD) at ../hw/core/resetcontainer.c:54
+ * #10 0x0000555555f30392 in resettable_child_foreach (rc=0x55555781ec70, obj=0x55555786d300, cb=0x555555f3052b <resettable_phase_hold>,
+ *     opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:92
+ * #11 0x0000555555f305e8 in resettable_phase_hold (obj=0x55555786d300, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:155
+ * #12 0x0000555555f30247 in resettable_assert_reset (obj=0x55555786d300, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #13 0x0000555555f3019f in resettable_reset (obj=0x55555786d300, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #14 0x0000555555981b6b in qemu_devices_reset (type=RESET_TYPE_COLD) at ../hw/core/reset.c:176
+ * #15 0x0000555555df6f1f in pc_machine_reset (machine=0x555557848900, type=RESET_TYPE_COLD) at ../hw/i386/pc.c:1701
+ * #16 0x0000555555c381bd in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at ../system/runstate.c:526
+ * #17 0x000055555597a5b6 in qdev_machine_creation_done () at ../hw/core/machine.c:1775
+ * #18 0x0000555555c04241 in qemu_machine_creation_done (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2778
+ * #19 0x0000555555c04380 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2806
+ * #20 0x0000555555c06e99 in qemu_init (argc=23, argv=0x7fffffffdc08) at ../system/vl.c:3840
+ * #21 0x0000555556082a15 in main (argc=23, argv=0x7fffffffdc08) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  x86_cpu_reset_hold (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../target/i386/cpu.c:8583
+ * #1  0x0000555555f30643 in resettable_phase_hold (obj=0x5555578c1c80, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #2  0x0000555555f30247 in resettable_assert_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #3  0x0000555555f3019f in resettable_reset (obj=0x5555578c1c80, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #4  0x0000555555f2dc7f in device_cold_reset (dev=0x5555578c1c80) at ../hw/core/qdev.c:239
+ * #5  0x0000555555892f26 in cpu_reset (cpu=0x5555578c1c80) at ../hw/core/cpu-common.c:113
+ * #6  0x0000555555d91a51 in x86_cpu_machine_reset_cb (opaque=0x5555578c1c80) at ../target/i386/cpu-system.c:266
+ * #7  0x000055555598181e in legacy_reset_hold (obj=0x5555578c8dc0, type=RESET_TYPE_COLD) at ../hw/core/reset.c:76
+ * #8  0x0000555555f30643 in resettable_phase_hold (obj=0x5555578c8dc0, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #9  0x0000555555f2f6a2 in resettable_container_child_foreach (obj=0x55555786d300, cb=0x555555f3052b <resettable_phase_hold>, opaque=0x0,
+ *     type=RESET_TYPE_COLD) at ../hw/core/resetcontainer.c:54
+ * #10 0x0000555555f30392 in resettable_child_foreach (rc=0x55555781ec70, obj=0x55555786d300, cb=0x555555f3052b <resettable_phase_hold>,
+ *     opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:92
+ * #11 0x0000555555f305e8 in resettable_phase_hold (obj=0x55555786d300, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:155
+ * #12 0x0000555555f30247 in resettable_assert_reset (obj=0x55555786d300, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #13 0x0000555555f3019f in resettable_reset (obj=0x55555786d300, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #14 0x0000555555981b6b in qemu_devices_reset (type=RESET_TYPE_COLD) at ../hw/core/reset.c:176
+ * #15 0x0000555555df6f1f in pc_machine_reset (machine=0x555557848900, type=RESET_TYPE_COLD) at ../hw/i386/pc.c:1701
+ * #16 0x0000555555c381bd in qemu_system_reset (reason=SHUTDOWN_CAUSE_GUEST_RESET) at ../system/runstate.c:526
+ * #17 0x0000555555c38c04 in main_loop_should_exit (status=0x7fffffffdac4) at ../system/runstate.c:871
+ * #18 0x0000555555c38d05 in qemu_main_loop () at ../system/runstate.c:904
+ * #19 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+* #20 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc08) at ../system/main.c:93
+ *
+ *
+ * 在以下使用x86_cpu_reset_hold():
+ *   - target/i386/cpu.c|10041| <<x86_cpu_common_class_init>> resettable_class_set_parent_phases(rc, NULL, x86_cpu_reset_hold, NULL,
+ */
 static void x86_cpu_reset_hold(Object *obj, ResetType type)
 {
     CPUState *cs = CPU(obj);
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index f977fc49a..67f9d204e 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -1961,6 +1961,14 @@ typedef struct CPUArchState {
     /* End of state preserved by INIT (dummy marker).  */
     struct {} end_init_save;
 
+    /*
+     * 在以下使用CPUX86State->system_time_msr:
+     *   - target/i386/machine.c|1738| <<vmstate_x86_cpu>> VMSTATE_UINT64(env.system_time_msr, X86CPU),
+     *   - hw/i386/kvm/clock.c|96| <<kvmclock_current_nsec>> if (!(env->system_time_msr & 1ULL)) {
+     *   - hw/i386/kvm/clock.c|101| <<kvmclock_current_nsec>> kvmclock_struct_pa = env->system_time_msr & ~1ULL;
+     *   - target/i386/kvm/kvm.c|4058| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
+     *   - target/i386/kvm/kvm.c|4826| <<kvm_get_msrs>> env->system_time_msr = msrs[i].data;
+     */
     uint64_t system_time_msr;
     uint64_t wall_clock_msr;
     uint64_t steal_time_msr;
@@ -2100,6 +2108,17 @@ typedef struct CPUArchState {
     uint8_t triple_fault_pending;
     uint32_t ins_len;
     uint32_t sipi_vector;
+    /*
+     * 在以下使用CPUX86State->tsc_valid:
+     *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     bool tsc_valid;
     int64_t tsc_khz;
     int64_t user_tsc_khz; /* for sanity check only */
diff --git a/target/i386/helper.c b/target/i386/helper.c
index e0aaed3c4..5853907d1 100644
--- a/target/i386/helper.c
+++ b/target/i386/helper.c
@@ -556,6 +556,15 @@ void cpu_report_tpr_access(CPUX86State *env, TPRAccess access)
     } else if (tcg_enabled()) {
         target_ulong eip = get_memio_eip(env);
 
+        /*
+	 * 在以下使用apic_handle_tpr_access_report():
+	 *   - arget/i386/helper.c|559| <<cpu_report_tpr_access>> apic_handle_tpr_access_report(cpu->apic_state, eip, access);
+         *   - target/i386/hvf/x86hvf.c|456| <<hvf_process_events>> apic_handle_tpr_access_report(cpu->apic_state, env->eip,
+         *   - target/i386/kvm/kvm.c|5774| <<kvm_arch_process_async_events>> apic_handle_tpr_access_report(cpu->apic_state, env->eip,
+         *   - target/i386/kvm/kvm.c|5801| <<kvm_handle_tpr_access>> apic_handle_tpr_access_report(cpu->apic_state, run->tpr_access.rip,
+         *   - target/i386/nvmm/nvmm-all.c|715| <<nvmm_vcpu_loop>> apic_handle_tpr_access_report(x86_cpu->apic_state, env->eip,
+         *   - target/i386/whpx/whpx-all.c|1628| <<whpx_vcpu_process_async_events>> apic_handle_tpr_access_report(x86_cpu->apic_state, env->eip,
+	 */
         apic_handle_tpr_access_report(cpu->apic_state, eip, access);
     }
 }
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 369626f8c..ef127bfe7 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -297,6 +297,22 @@ bool kvm_hv_vpindex_settable(void)
     return hv_vpindex_settable;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_get_tsc (cs=0x5555578c30f0) at ../target/i386/kvm/kvm.c:301
+ * #1  0x0000555555d9c4e7 in do_kvm_synchronize_tsc (cpu=0x5555578c30f0, arg=...) at ../target/i386/kvm/kvm.c:324
+ * #2  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c30f0) at ../cpu-common.c:374
+ * #3  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c30f0) at ../system/cpus.c:453
+ * #4  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c30f0) at ../system/cpus.c:471
+ * #5  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c30f0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #6  0x0000555556155700 in qemu_thread_start (args=0x5555578cd750) at ../util/qemu-thread-posix.c:393
+ * #7  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #8  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用kvm_get_tsc():
+ *   - target/i386/kvm/kvm.c|324| <<do_kvm_synchronize_tsc>> kvm_get_tsc(cpu);
+ */
 static int kvm_get_tsc(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -304,6 +320,17 @@ static int kvm_get_tsc(CPUState *cs)
     uint64_t value;
     int ret;
 
+    /*
+     * 在以下使用CPUX86State->tsc_valid:
+     *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     if (env->tsc_valid) {
         return 0;
     }
@@ -319,11 +346,19 @@ static int kvm_get_tsc(CPUState *cs)
     return 0;
 }
 
+/*
+ * 在以下使用do_kvm_synchronize_tsc():
+ *   - target/i386/kvm/kvm.c|364| <<kvm_synchronize_all_tsc>> run_on_cpu(cpu, do_kvm_synchronize_tsc, RUN_ON_CPU_NULL);
+ */
 static inline void do_kvm_synchronize_tsc(CPUState *cpu, run_on_cpu_data arg)
 {
     kvm_get_tsc(cpu);
 }
 
+/*
+ * 在以下使用kvm_synchronize_all_tsc():
+ *   - hw/i386/kvm/clock.c|431| <<kvmclock_vm_state_change>> kvm_synchronize_all_tsc();
+ */
 void kvm_synchronize_all_tsc(void)
 {
     CPUState *cpu;
@@ -830,6 +865,17 @@ static void cpu_update_state(void *opaque, bool running, RunState state)
     CPUX86State *env = opaque;
 
     if (running) {
+        /*
+	 * 在以下使用CPUX86State->tsc_valid:
+         *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+         *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+         *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+         *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+         *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+	 */
         env->tsc_valid = false;
     }
 }
@@ -867,6 +913,11 @@ static inline bool freq_within_bounds(int freq, int target_freq)
         return false;
 }
 
+/*
+ * 在以下使用kvm_arch_set_tsc_khz():
+ *   - target/i386/kvm/kvm.c|2156| <<kvm_arch_init_vcpu>> r = kvm_arch_set_tsc_khz(cs);
+ *   - target/i386/kvm/kvm.c|5390| <<kvm_arch_put_registers>> kvm_arch_set_tsc_khz(cpu);
+ */
 static int kvm_arch_set_tsc_khz(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -2073,6 +2124,10 @@ int kvm_arch_pre_create_vcpu(CPUState *cpu, Error **errp)
     return 0;
 }
 
+/*
+ * 在以下使用kvm_arch_init_vcpu():
+ *   - accel/kvm/kvm-all.c|617| <<kvm_init_vcpu>> ret = kvm_arch_init_vcpu(cpu);
+ */
 int kvm_arch_init_vcpu(CPUState *cs)
 {
     struct {
@@ -2442,6 +2497,10 @@ void kvm_arch_after_reset_vcpu(X86CPU *cpu)
     }
 }
 
+/*
+ * 在以下使用kvm_arch_reset_parked_vcpu():
+ *   - accel/kvm/kvm-all.c|453| <<kvm_reset_parked_vcpus>> kvm_arch_reset_parked_vcpu(cpu->vcpu_id, cpu->kvm_fd);
+ */
 void kvm_arch_reset_parked_vcpu(unsigned long vcpu_id, int kvm_fd)
 {
     g_autofree struct kvm_msrs *msrs = NULL;
@@ -3647,6 +3706,10 @@ static int kvm_get_one_msr(X86CPU *cpu, int index, uint64_t *value)
     *value = msr_data.entries[0].data;
     return ret;
 }
+/*
+ * 在以下使用kvm_put_apicbase():
+ *   - hw/i386/kvm/apic.c|162| <<kvm_apic_put>> kvm_put_apicbase(s->cpu, s->apicbase);
+ */
 void kvm_put_apicbase(X86CPU *cpu, uint64_t value)
 {
     int ret;
@@ -3907,6 +3970,10 @@ static void kvm_init_msrs(X86CPU *cpu)
     assert(kvm_buf_set_msrs(cpu) == 0);
 }
 
+/*
+ * 在以下使用kvm_put_msrs():
+ *   - target/i386/kvm/kvm.c|5408| <<kvm_arch_put_registers>> ret = kvm_put_msrs(x86_cpu, level);
+ */
 static int kvm_put_msrs(X86CPU *cpu, int level)
 {
     CPUX86State *env = &cpu->env;
@@ -3996,6 +4063,14 @@ static int kvm_put_msrs(X86CPU *cpu, int level)
     if (level >= KVM_PUT_RESET_STATE) {
         kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
         if (env->features[FEAT_KVM] & (CPUID_KVM_CLOCK | CPUID_KVM_CLOCK2)) {
+            /*
+	     * 在以下使用CPUX86State->system_time_msr:
+	     *   - target/i386/machine.c|1738| <<vmstate_x86_cpu>> VMSTATE_UINT64(env.system_time_msr, X86CPU),
+	     *   - hw/i386/kvm/clock.c|96| <<kvmclock_current_nsec>> if (!(env->system_time_msr & 1ULL)) {
+	     *   - hw/i386/kvm/clock.c|101| <<kvmclock_current_nsec>> kvmclock_struct_pa = env->system_time_msr & ~1ULL;
+	     *   - target/i386/kvm/kvm.c|4058| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
+	     *   - target/i386/kvm/kvm.c|4826| <<kvm_get_msrs>> env->system_time_msr = msrs[i].data;
+	     */
             kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
             kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, env->wall_clock_msr);
         }
@@ -4383,6 +4458,19 @@ static int kvm_get_sregs2(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_get_msrs (cpu=0x5555578c30f0) at ../target/i386/kvm/kvm.c:4387
+ * #1  0x0000555555dab277 in kvm_arch_get_registers (cs=0x5555578c30f0, errp=0x7fffedb02580) at ../target/i386/kvm/kvm.c:5414
+ * #2  0x0000555555f24545 in do_kvm_cpu_synchronize_state (cpu=0x5555578c30f0, arg=...) at ../accel/kvm/kvm-all.c:2914
+ * #3  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c30f0) at ../cpu-common.c:374
+ * #4  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c30f0) at ../system/cpus.c:453
+ * #5  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c30f0) at ../system/cpus.c:471
+ * #6  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c30f0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #7  0x0000555556155700 in qemu_thread_start (args=0x5555578cd750) at ../util/qemu-thread-posix.c:393
+ * #8  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #9  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 static int kvm_get_msrs(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -4448,6 +4536,17 @@ static int kvm_get_msrs(X86CPU *cpu)
     if (has_msr_virt_ssbd) {
         kvm_msr_entry_add(cpu, MSR_VIRT_SSBD, 0);
     }
+    /*
+     * 在以下使用CPUX86State->tsc_valid:
+     *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     if (!env->tsc_valid) {
         kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);
         env->tsc_valid = !runstate_is_running();
@@ -4740,6 +4839,14 @@ static int kvm_get_msrs(X86CPU *cpu)
             env->vm_hsave = msrs[i].data;
             break;
         case MSR_KVM_SYSTEM_TIME:
+            /*
+	     * 在以下使用CPUX86State->system_time_msr:
+	     *   - target/i386/machine.c|1738| <<vmstate_x86_cpu>> VMSTATE_UINT64(env.system_time_msr, X86CPU),
+	     *   - hw/i386/kvm/clock.c|96| <<kvmclock_current_nsec>> if (!(env->system_time_msr & 1ULL)) {
+	     *   - hw/i386/kvm/clock.c|101| <<kvmclock_current_nsec>> kvmclock_struct_pa = env->system_time_msr & ~1ULL;
+	     *   - target/i386/kvm/kvm.c|4058| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
+	     *   - target/i386/kvm/kvm.c|4826| <<kvm_get_msrs>> env->system_time_msr = msrs[i].data;
+	     */
             env->system_time_msr = msrs[i].data;
             break;
         case MSR_KVM_WALL_CLOCK:
@@ -5196,11 +5303,23 @@ static int kvm_get_debugregs(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * 在以下使用kvm_put_nested_state():
+ *   - target/i386/kvm/kvm.c|5425| <<kvm_arch_put_registers>> ret = kvm_put_nested_state(x86_cpu);
+ */
 static int kvm_put_nested_state(X86CPU *cpu)
 {
+    /*
+     * struct CPUX86State:
+     * -> struct kvm_nested_state *nested_state;
+     */
     CPUX86State *env = &cpu->env;
     int max_nested_state_len = kvm_max_nested_state_length();
 
+    /*
+     *  struct CPUX86State:
+     * -> struct kvm_nested_state *nested_state;
+     */
     if (!env->nested_state) {
         return 0;
     }
@@ -5270,11 +5389,28 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * 在以下使用kvm_arch_put_registers():
+ *   - accel/kvm/kvm-all.c|2959| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+ *   - accel/kvm/kvm-all.c|2990| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+ *   - accel/kvm/kvm-all.c|3221| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+ */
 int kvm_arch_put_registers(CPUState *cpu, int level, Error **errp)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
     int ret;
 
+    /*
+     * 在以下使用cpu_is_stopped():
+     *   - system/cpus.c|101| <<cpu_thread_is_idle>> if (cpu_is_stopped(cpu)) {
+     *   - system/cpus.c|571| <<cpu_can_run>> if (cpu_is_stopped(cpu)) {
+     *   - target/i386/kvm/kvm.c|5383| <<kvm_arch_put_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/kvm/kvm.c|5483| <<kvm_arch_get_registers>> assert(cpu_is_stopped(cs) || qemu_cpu_is_self(cs));
+     *   - target/i386/nvmm/nvmm-all.c|93| <<nvmm_set_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/nvmm/nvmm-all.c|231| <<nvmm_get_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/whpx/whpx-all.c|395| <<whpx_set_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/whpx/whpx-all.c|610| <<whpx_get_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     */
     assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
 
     /*
@@ -5375,6 +5511,17 @@ int kvm_arch_get_registers(CPUState *cs, Error **errp)
     X86CPU *cpu = X86_CPU(cs);
     int ret;
 
+    /*
+     * 在以下使用cpu_is_stopped():
+     *   - system/cpus.c|101| <<cpu_thread_is_idle>> if (cpu_is_stopped(cpu)) {
+     *   - system/cpus.c|571| <<cpu_can_run>> if (cpu_is_stopped(cpu)) {
+     *   - target/i386/kvm/kvm.c|5383| <<kvm_arch_put_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/kvm/kvm.c|5483| <<kvm_arch_get_registers>> assert(cpu_is_stopped(cs) || qemu_cpu_is_self(cs));
+     *   - target/i386/nvmm/nvmm-all.c|93| <<nvmm_set_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/nvmm/nvmm-all.c|231| <<nvmm_get_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/whpx/whpx-all.c|395| <<whpx_set_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     *   - target/i386/whpx/whpx-all.c|610| <<whpx_get_registers>> assert(cpu_is_stopped(cpu) || qemu_cpu_is_self(cpu));
+     */
     assert(cpu_is_stopped(cs) || qemu_cpu_is_self(cs));
 
     ret = kvm_get_vcpu_events(cpu);
@@ -5545,6 +5692,10 @@ static void kvm_rate_limit_on_bus_lock(void)
     }
 }
 
+/*
+ * 在以下使用kvm_arch_post_run():
+ *   - accel/kvm/kvm-all.c|3484| <<kvm_cpu_exec>> attrs = kvm_arch_post_run(cpu, run);
+ */
 MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -5583,6 +5734,14 @@ MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
         bql_lock();
     }
     cpu_set_apic_tpr(x86_cpu->apic_state, run->cr8);
+    /*
+     * 在以下使用cpu_set_apic_base():
+     *   - target/i386/hvf/hvf.c|630| <<hvf_simulate_wrmsr>> r = cpu_set_apic_base(cpu->apic_state, data);
+     *   - target/i386/kvm/kvm.c|5717| <<kvm_arch_post_run>> cpu_set_apic_base(x86_cpu->apic_state, run->apic_base);
+     *   - target/i386/nvmm/nvmm-all.c|620| <<nvmm_handle_wrmsr>> cpu_set_apic_base(x86_cpu->apic_state, val);
+     *   - target/i386/tcg/system/misc_helper.c|159| <<helper_wrmsr>> ret = cpu_set_apic_base(env_archcpu(env)->apic_state, val);
+     *   - target/i386/whpx/whpx-all.c|743| <<whpx_get_registers>> cpu_set_apic_base(x86_cpu->apic_state, vcpu->apic_base);
+     */
     cpu_set_apic_base(x86_cpu->apic_state, run->apic_base);
     if (!kvm_irqchip_in_kernel()) {
         bql_unlock();
@@ -5644,6 +5803,15 @@ int kvm_arch_process_async_events(CPUState *cs)
     if (cs->interrupt_request & CPU_INTERRUPT_TPR) {
         cs->interrupt_request &= ~CPU_INTERRUPT_TPR;
         kvm_cpu_synchronize_state(cs);
+        /*
+	 * 在以下使用apic_handle_tpr_access_report():
+	 *   - arget/i386/helper.c|559| <<cpu_report_tpr_access>> apic_handle_tpr_access_report(cpu->apic_state, eip, access);
+	 *   - target/i386/hvf/x86hvf.c|456| <<hvf_process_events>> apic_handle_tpr_access_report(cpu->apic_state, env->eip,
+	 *   - target/i386/kvm/kvm.c|5774| <<kvm_arch_process_async_events>> apic_handle_tpr_access_report(cpu->apic_state, env->eip,
+	 *   - target/i386/kvm/kvm.c|5801| <<kvm_handle_tpr_access>> apic_handle_tpr_access_report(cpu->apic_state, run->tpr_access.rip,
+	 *   - target/i386/nvmm/nvmm-all.c|715| <<nvmm_vcpu_loop>> apic_handle_tpr_access_report(x86_cpu->apic_state, env->eip,
+	 *   - target/i386/whpx/whpx-all.c|1628| <<whpx_vcpu_process_async_events>> apic_handle_tpr_access_report(x86_cpu->apic_state, env->eip,
+	 */
         apic_handle_tpr_access_report(cpu->apic_state, env->eip,
                                       env->tpr_access_type);
     }
@@ -5671,6 +5839,15 @@ static int kvm_handle_tpr_access(X86CPU *cpu)
     CPUState *cs = CPU(cpu);
     struct kvm_run *run = cs->kvm_run;
 
+    /*
+     * 在以下使用apic_handle_tpr_access_report():
+     *   - arget/i386/helper.c|559| <<cpu_report_tpr_access>> apic_handle_tpr_access_report(cpu->apic_state, eip, access);
+     *   - target/i386/hvf/x86hvf.c|456| <<hvf_process_events>> apic_handle_tpr_access_report(cpu->apic_state, env->eip,
+     *   - target/i386/kvm/kvm.c|5774| <<kvm_arch_process_async_events>> apic_handle_tpr_access_report(cpu->apic_state, env->eip,
+     *   - target/i386/kvm/kvm.c|5801| <<kvm_handle_tpr_access>> apic_handle_tpr_access_report(cpu->apic_state, run->tpr_access.rip,
+     *   - target/i386/nvmm/nvmm-all.c|715| <<nvmm_vcpu_loop>> apic_handle_tpr_access_report(x86_cpu->apic_state, env->eip,
+     *   - target/i386/whpx/whpx-all.c|1628| <<whpx_vcpu_process_async_events>> apic_handle_tpr_access_report(x86_cpu->apic_state, env->eip,
+     */
     apic_handle_tpr_access_report(cpu->apic_state, run->tpr_access.rip,
                                   run->tpr_access.is_write ? TPR_ACCESS_WRITE
                                                            : TPR_ACCESS_READ);
diff --git a/target/i386/kvm/xen-emu.c b/target/i386/kvm/xen-emu.c
index 284c5ef6f..719bdcbee 100644
--- a/target/i386/kvm/xen-emu.c
+++ b/target/i386/kvm/xen-emu.c
@@ -980,11 +980,20 @@ static int vcpuop_register_runstate_info(CPUState *cs, CPUState *target,
     return 0;
 }
 
+/*
+ * 只给xen使用:
+ *   - target/i386/kvm/xen-emu.c|1093| <<do_set_singleshot_timer>> int64_t now = kvm_get_current_ns();
+ */
 static uint64_t kvm_get_current_ns(void)
 {
     struct kvm_clock_data data;
     int ret;
 
+    /*
+     * 在两个地方使用KVM_GET_CLOCK:
+     *   - hw/i386/kvm/clock.c|200| <<kvm_update_clock>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     *   - target/i386/kvm/xen-emu.c|992| <<kvm_get_current_ns>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     */
     ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
     if (ret < 0) {
         fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(ret));
diff --git a/util/osdep.c b/util/osdep.c
index 770369831..5b865a08d 100644
--- a/util/osdep.c
+++ b/util/osdep.c
@@ -308,6 +308,50 @@ static int qemu_open_cloexec(const char *name, int flags, mode_t mode)
 /*
  * Opens a file with FD_CLOEXEC set
  */
+/*
+ * (gdb) bt
+ * #0  qemu_open_internal (name=0x7fffffffda74 "test.qcow2", flags=66, mode=420, errp=0x7fffffffd4c8) at ../util/osdep.c:313
+ * #1  0x00005555556eb8ef in qemu_create (name=0x7fffffffda74 "test.qcow2", flags=2, mode=420, errp=0x7fffffffd4c8) at ../util/osdep.c:372
+ * #2  0x0000555555652dd4 in raw_co_create (options=0x7fffefeeace0, errp=0x7fffffffd4c8) at ../block/file-posix.c:3001
+ * #3  0x0000555555653306 in raw_co_create_opts (drv=0x5555557db6e0 <bdrv_file>, filename=0x7fffffffda74 "test.qcow2", opts=0x555555812d50, errp=0x7fffffffd4c8)
+ *     at ../block/file-posix.c:3151
+ * #4  0x0000555555585318 in bdrv_co_create (drv=0x5555557db6e0 <bdrv_file>, filename=0x7fffffffda74 "test.qcow2", opts=0x555555812d50, errp=0x7fffffffd4c8)
+ *     at ../block.c:548
+ * #5  0x0000555555585a0c in bdrv_co_create_file (filename=0x7fffffffda74 "test.qcow2", opts=0x555555810b10, errp=0x7fffffffd4c8) at ../block.c:737
+ * #6  0x00005555555f1cf0 in qcow2_co_create_opts (drv=0x5555557d7100 <bdrv_qcow2>, filename=0x7fffffffda74 "test.qcow2", opts=0x555555810b10, errp=0x7fffffffd4c8)
+ *     at ../block/qcow2.c:3959
+ * #7  0x0000555555585318 in bdrv_co_create (drv=0x5555557d7100 <bdrv_qcow2>, filename=0x7fffffffda74 "test.qcow2", opts=0x555555810b10, errp=0x7fffffffd4c8)
+ *     at ../block.c:548
+ * #8  0x000055555566c02c in bdrv_co_create_entry (opaque=0x7fffffffd420) at block/block-gen.c:1179
+ * #9  0x000055555570b3fe in coroutine_trampoline (i0=1434520480, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #10 0x00007ffff5ee7120 in ?? () from /lib64/libc.so.6
+ * #11 0x00007fffffffcc20 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ *
+ * (gdb) bt
+ * #0  qemu_open_internal (name=0x5555557eaea0 "test.qcow2", flags=2, mode=0, errp=0x7fffffffd020) at ../util/osdep.c:313
+ * #1  0x00005555556eb882 in qemu_open (name=0x5555557eaea0 "test.qcow2", flags=2, errp=0x7fffffffd020) at ../util/osdep.c:364
+ * #2  0x000055555564df64 in raw_open_common (bs=0x555555813040, options=0x555555819390, bdrv_flags=8198, open_flags=0, device=false, errp=0x7fffffffd020)
+ *     at ../block/file-posix.c:715
+ * #3  0x000055555564e51f in raw_open (bs=0x555555813040, options=0x555555819390, flags=8198, errp=0x7fffffffd020) at ../block/file-posix.c:850
+ * #4  0x0000555555587f4e in bdrv_open_driver (bs=0x555555813040, drv=0x5555557db6e0 <bdrv_file>, node_name=0x0, options=0x555555819390, open_flags=8198, 
+ *     errp=0x7fffffffd130) at ../block.c:1665
+ * #5  0x0000555555588b9e in bdrv_open_common (bs=0x555555813040, file=0x0, options=0x555555819390, errp=0x7fffffffd130) at ../block.c:1995
+ * #6  0x000055555558de26 in bdrv_open_inherit (filename=0x7fffffffda74 "test.qcow2", reference=0x0, options=0x555555819390, flags=40966, parent=0x0, child_class=0x0, 
+ *     child_role=0, parse_filename=true, errp=0x7fffffffd4c8) at ../block.c:4178
+ * #7  0x000055555558e3f8 in bdrv_open (filename=0x7fffffffda74 "test.qcow2", reference=0x0, options=0x0, flags=32774, errp=0x7fffffffd4c8) at ../block.c:4273
+ * #8  0x000055555566c4bb in bdrv_open_bh (opaque=0x7fffefeeadf0) at block/block-gen.c:1313
+ * #9  0x0000555555706a21 in aio_bh_call (bh=0x555555811d30) at ../util/async.c:172
+ * #10 0x0000555555706b6f in aio_bh_poll (ctx=0x55555580b870) at ../util/async.c:219
+ * #11 0x00005555556f04c6 in aio_poll (ctx=0x55555580b870, blocking=true) at ../util/aio-posix.c:746
+ * #12 0x0000555555669e27 in bdrv_poll_co (s=0x7fffffffd420) at /home/zhang/kvm/test/qemu-10.1.0/block/block-gen.h:43
+ * #13 0x000055555566c13b in bdrv_create (drv=0x5555557d7100 <bdrv_qcow2>, filename=0x7fffffffda74 "test.qcow2", opts=0x555555810b10, errp=0x7fffffffd4c8)
+ *     at block/block-gen.c:1201
+ * #14 0x0000555555595db9 in bdrv_img_create (filename=0x7fffffffda74 "test.qcow2", fmt=0x7fffffffda6e "qcow2", base_filename=0x0, base_fmt=0x0, options=0x0, 
+ *     img_size=1073741824, flags=0, quiet=false, errp=0x7fffffffd598) at ../block.c:7460
+ * #15 0x0000555555690198 in img_create (ccmd=0x5555557ccfc8 <img_cmds+168>, argc=5, argv=0x7fffffffd710) at ../qemu-img.c:535
+ * #16 0x000055555569d124 in main (argc=5, argv=0x7fffffffd710) at ../qemu-img.c:5976
+ */
 static int
 qemu_open_internal(const char *name, int flags, mode_t mode, Error **errp)
 {
diff --git a/util/qemu-timer.c b/util/qemu-timer.c
index 1fb48be28..cec7cf86d 100644
--- a/util/qemu-timer.c
+++ b/util/qemu-timer.c
@@ -155,6 +155,13 @@ void qemu_clock_notify(QEMUClockType type)
  *
  * Caller should hold BQL.
  */
+/*
+ * 在以下使用qemu_clock_enable():
+ *   - accel/tcg/tcg-accel-ops-rr.c|251| <<rr_cpu_thread_fn>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL,
+ *   - gdbstub/system.c|605| <<gdb_continue_partial>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);
+ *   - system/cpus.c|828| <<pause_all_vcpus>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL, false);
+ *   - system/cpus.c|858| <<resume_all_vcpus>> qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);
+ */
 void qemu_clock_enable(QEMUClockType type, bool enabled)
 {
     QEMUClock *clock = qemu_clock_ptr(type);
diff --git a/util/thread-pool.c b/util/thread-pool.c
index d2ead6b72..6e5b44948 100644
--- a/util/thread-pool.c
+++ b/util/thread-pool.c
@@ -281,6 +281,14 @@ static void thread_pool_co_cb(void *opaque, int ret)
     aio_co_wake(co->co);
 }
 
+/*
+ * 在以下使用thread_pool_submit_co():
+ *   - block/file-posix.c|2515| <<raw_thread_pool_submit>> return thread_pool_submit_co(func, arg);
+ *   - block/qcow2-threads.c|54| <<qcow2_co_process>> ret = thread_pool_submit_co(func, arg);
+ *   - scsi/pr-manager.c|64| <<pr_manager_execute>> return thread_pool_submit_co(pr_manager_worker, &data);
+ *   - scsi/qemu-pr-helper.c|194| <<do_sgio>> r = thread_pool_submit_co(do_sgio_worker, &data);
+ *   - tests/unit/test-thread-pool.c|80| <<co_test_cb>> thread_pool_submit_co(worker_cb, data);
+ */
 int coroutine_fn thread_pool_submit_co(ThreadPoolFunc *func, void *arg)
 {
     ThreadPoolCo tpc = { .co = qemu_coroutine_self(), .ret = -EINPROGRESS };
-- 
2.39.5 (Apple Git-154)

