From 5f90b8347d99a80afd2232fcad9d7ad3876f60a4 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Sun, 7 Sep 2025 18:29:30 -0700
Subject: [PATCH 1/1] qemu for v10.1.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-accel-ops.c      |   9 +
 accel/kvm/kvm-all.c            |  56 +++++
 dump/dump.c                    |  10 +
 hw/i386/kvm/clock.c            | 347 +++++++++++++++++++++++++++++
 hw/i386/pc.c                   |  10 +
 hw/net/virtio-net.c            |  79 +++++++
 hw/vfio/migration.c            |  11 +
 include/accel/accel-cpu-ops.h  |  18 ++
 include/hw/virtio/virtio-net.h |  22 ++
 migration/block-dirty-bitmap.c |  11 +
 migration/channel.c            |  24 +++
 migration/colo.c               |  10 +
 migration/exec.c               |   8 +
 migration/fd.c                 |   8 +
 migration/file.c               |  15 ++
 migration/migration.c          | 383 ++++++++++++++++++++++++++++++++
 migration/migration.h          |   7 +
 migration/ram.c                |  42 ++++
 migration/rdma.c               |   5 +
 migration/savevm.c             | 384 +++++++++++++++++++++++++++++++++
 migration/savevm.h             |   8 +
 migration/socket.c             |   8 +
 migration/tls.c                |   8 +
 monitor/qmp-cmds.c             |  17 ++
 net/slirp.c                    |  11 +
 net/tap-linux.c                |  12 ++
 net/tap.c                      |  12 ++
 system/cpus.c                  | 286 ++++++++++++++++++++++++
 system/runstate.c              |  68 ++++++
 target/arm/hvf/hvf.c           |  10 +
 target/i386/cpu.h              |  11 +
 target/i386/kvm/kvm.c          |  81 +++++++
 target/i386/kvm/xen-emu.c      |   4 +
 33 files changed, 1995 insertions(+)

diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index b709187c7..44a504d28 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -98,6 +98,15 @@ static void kvm_accel_ops_class_init(ObjectClass *oc, const void *data)
     ops->cpu_thread_is_idle = kvm_vcpu_thread_is_idle;
     ops->cpus_are_resettable = kvm_cpus_are_resettable;
     ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
     ops->synchronize_state = kvm_cpu_synchronize_state;
     ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 890d5ea9f..61f2cf9c4 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -2907,6 +2907,10 @@ void kvm_flush_coalesced_mmio_buffer(void)
     s->coalesced_flush_in_progress = false;
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-all.c|2948| <<kvm_cpu_synchronize_state>> run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
@@ -2927,6 +2931,21 @@ static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 void kvm_cpu_synchronize_state(CPUState *cpu)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
@@ -2961,6 +2980,10 @@ void kvm_cpu_synchronize_post_reset(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-all.c|3003| <<kvm_cpu_synchronize_post_init>> run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
 {
     Error *err = NULL;
@@ -2978,6 +3001,30 @@ static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
     cpu->vcpu_dirty = false;
 }
 
+/*
+ * (gdb) bt
+ * #0  cpu_synchronize_post_init (cpu=0x5555578f8060) at ../system/cpus.c:186
+ * #1  0x0000555555c08773 in cpu_synchronize_all_post_init () at ../system/cpus.c:157
+ * #2  0x0000555555c7e70e in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3199
+ * #3  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #4  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #5  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #6  0x00007fffffffc7e0 in ?? ()
+ * #7  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用AccelOpsClass->synchronize_post_init():
+ *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+ *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+ *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+ *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+ *
+ *
+ * 在以下使用kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ */
 void kvm_cpu_synchronize_post_init(CPUState *cpu)
 {
     if (!kvm_state->guest_state_protected) {
@@ -2994,6 +3041,15 @@ static void do_kvm_cpu_synchronize_pre_loadvm(CPUState *cpu, run_on_cpu_data arg
     cpu->vcpu_dirty = true;
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+ *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+ *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+ *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+ *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+ *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+ */
 void kvm_cpu_synchronize_pre_loadvm(CPUState *cpu)
 {
     run_on_cpu(cpu, do_kvm_cpu_synchronize_pre_loadvm, RUN_ON_CPU_NULL);
diff --git a/dump/dump.c b/dump/dump.c
index 15bbcc0c6..b028365f4 100644
--- a/dump/dump.c
+++ b/dump/dump.c
@@ -1808,6 +1808,16 @@ static void dump_init(DumpState *s, int fd, bool has_format,
     /* If we use KVM, we should synchronize the registers before we get dump
      * info or physmap info.
      */
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
     nr_cpus = 0;
     CPU_FOREACH(cpu) {
diff --git a/hw/i386/kvm/clock.c b/hw/i386/kvm/clock.c
index f56382717..9fcc5093a 100644
--- a/hw/i386/kvm/clock.c
+++ b/hw/i386/kvm/clock.c
@@ -38,6 +38,12 @@ struct KVMClockState {
     /*< public >*/
 
     uint64_t clock;
+    /*
+     * 在以下使用KVMClockState->clock_valid:
+     *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+     *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+     *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+     */
     bool clock_valid;
 
     /* whether the 'clock' value was obtained in the 'paused' state */
@@ -48,6 +54,13 @@ struct KVMClockState {
 
     /* whether the 'clock' value was obtained in a host with
      * reliable KVM_GET_CLOCK */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     bool clock_is_reliable;
 };
 
@@ -62,6 +75,10 @@ struct pvclock_vcpu_time_info {
     uint8_t    pad[2];
 } __attribute__((__packed__)); /* 32 bytes */
 
+/*
+ * 在以下使用kvmclock_current_nsec():
+ *   - hw/i386/kvm/clock.c|376| <<kvmclock_vm_state_change>> uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
+ */
 static uint64_t kvmclock_current_nsec(KVMClockState *s)
 {
     CPUState *cpu = first_cpu;
@@ -97,6 +114,61 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     return nsec + time.system_time;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用kvm_update_clock():
+ *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+ */
 static void kvm_update_clock(KVMClockState *s)
 {
     struct kvm_clock_data data;
@@ -148,9 +220,119 @@ static void kvm_update_clock(KVMClockState *s)
      *       if !kvm_has_adjust_clock_stable() then
      *               read from memory
      */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     s->clock_is_reliable = kvm_has_adjust_clock_stable();
 }
 
+/*
+ * 创建的时候这个调用一次.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ * 这个调用#vCPU次.
+ *
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x5555578c3250, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c3250) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c3250) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c3250) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c3250) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555578cd7d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 
+ * 迁移到文件的时候.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 从文件迁移到VM.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ * 然后下面调用#vCPU次.
+ *
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x5555578c3250, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c3250) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c3250) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c3250) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c3250) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555578cd7d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 从QEMU quit的时候
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_SHUTDOWN) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_SHUTDOWN) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_SHUTDOWN, send_stop=false) at ../system/cpus.c:300
+ * #3  0x0000555555c08bec in vm_shutdown () at ../system/cpus.c:322
+ * #4  0x0000555555c38ee9 in qemu_cleanup (status=0) at ../system/runstate.c:981
+ * #5  0x00005555560829d2 in qemu_default_main (opaque=0x0) at ../system/main.c:51
+ * #6  0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ */
+/*
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x55555790c330, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x55555790c330) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x55555790c330) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x55555790c330) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x55555790c330) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555579159d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用do_kvmclock_ctrl():
+ *   - hw/i386/kvm/clock.c|239| <<kvmclock_vm_state_change>> run_on_cpu(cpu, do_kvmclock_ctrl, RUN_ON_CPU_NULL);
+ */
 static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
 {
     int ret = kvm_vcpu_ioctl(cpu, KVM_KVMCLOCK_CTRL, 0);
@@ -160,6 +342,82 @@ static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
     }
 }
 
+/*
+ * 迁移的时候在Source上的调用:
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 迁移的时候在Target上的调用:
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ *
+ * 这是迁移在Target上的.
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x5555582b37e0) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用kvmclock_vm_state_change():
+ *   - hw/i386/kvm/clock.c|284| <<kvmclock_realize>> qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
+ */
 static void kvmclock_vm_state_change(void *opaque, bool running,
                                      RunState state)
 {
@@ -171,6 +429,13 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
     if (running) {
         struct kvm_clock_data data = {};
 
+        /*
+	 * 在以下使用KVMClockState->clock_is_reliable:
+         *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+         *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+         *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+         *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+	 */
         /*
          * If the host where s->clock was read did not support reliable
          * KVM_GET_CLOCK, read kvmclock value from memory.
@@ -183,9 +448,18 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
             }
         }
 
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         s->clock_valid = false;
 
         data.clock = s->clock;
+        /*
+	 * 只在这一个地方调用KVM_SET_CLOCK
+	 */
         ret = kvm_vm_ioctl(kvm_state, KVM_SET_CLOCK, &data);
         if (ret < 0) {
             fprintf(stderr, "KVM_SET_CLOCK failed: %s\n", strerror(-ret));
@@ -200,6 +474,12 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
         }
     } else {
 
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+	 *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+	 *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+	 *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         if (s->clock_valid) {
             return;
         }
@@ -208,12 +488,24 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
 
         kvm_synchronize_all_tsc();
 
+        /*
+	 * 在以下使用kvm_update_clock():
+	 *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+	 */
         kvm_update_clock(s);
         /*
          * If the VM is stopped, declare the clock state valid to
          * avoid re-reading it on next vmsave (which would return
          * a different value). Will be reset when the VM is continued.
          */
+	/*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|408| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|425| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|445| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         s->clock_valid = true;
     }
 }
@@ -227,6 +519,12 @@ static void kvmclock_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用kvm_update_clock():
+     *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+     *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+     *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+     */
     kvm_update_clock(s);
 
     qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
@@ -258,11 +556,54 @@ static int kvmclock_pre_load(void *opaque)
 {
     KVMClockState *s = opaque;
 
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|457| <<kvmclock_reliable_get_clock>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|191| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|375| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|470| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     s->clock_is_reliable = false;
 
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x55555790d7e0, 
+ *     version_id=1, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, 
+ *     vmdesc_id=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x555557dad630, se=0x555557902320, vmdesc=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x555557dad630, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:282
+ * #1  0x0000555555f40775 in vmstate_save_state_v (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x55555790d7e0,
+ *     version_id=1, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:407
+ * #2  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:395
+ * #3  0x0000555555c79ef9 in vmstate_save (f=0x555557dad630, se=0x555557902320, vmdesc=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/savevm.c:1052
+ * #4  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x555557dad630, in_postcopy=false) at ../migration/savevm.c:1669
+ * #5  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1712
+ * #6  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 /*
  * When migrating a running guest, read the clock just
  * before migration, so that the guest clock counts
@@ -282,6 +623,12 @@ static int kvmclock_pre_save(void *opaque)
     KVMClockState *s = opaque;
 
     if (!s->runstate_paused) {
+        /*
+	 * 在以下使用kvm_update_clock():
+	 *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|230| <<kvmclock_realize>> kvm_update_clock(s);
+	 *   - hw/i386/kvm/clock.c|285| <<kvmclock_pre_save>> kvm_update_clock(s);
+	 */
         kvm_update_clock(s);
     }
 
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 2f58e73d3..eeeadf257 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1712,6 +1712,16 @@ static void pc_machine_reset(MachineState *machine, ResetType type)
 
 static void pc_machine_wakeup(MachineState *machine)
 {
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
     pc_machine_reset(machine, RESET_TYPE_WAKEUP);
     cpu_synchronize_all_post_reset();
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index 6b5b5dace..46e14eb9d 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -688,6 +688,10 @@ default_value:
     return VIRTIO_NET_TX_QUEUE_DEFAULT_SIZE;
 }
 
+/*
+ * 在以下使用peer_attach():
+ *   - hw/net/virtio-net.c|754| <<virtio_net_set_queue_pairs>> r = peer_attach(n, i);
+ */
 static int peer_attach(VirtIONet *n, int index)
 {
     NetClientState *nc = qemu_get_subqueue(n->nic, index);
@@ -713,6 +717,10 @@ static int peer_attach(VirtIONet *n, int index)
     return tap_enable(nc->peer);
 }
 
+/*
+ * 在以下使用peer_detach():
+ *   - hw/net/virtio-net.c|757| <<virtio_net_set_queue_pairs>> r = peer_detach(n, i);
+ */
 static int peer_detach(VirtIONet *n, int index)
 {
     NetClientState *nc = qemu_get_subqueue(n->nic, index);
@@ -734,6 +742,12 @@ static int peer_detach(VirtIONet *n, int index)
     return tap_disable(nc->peer);
 }
 
+/*
+ * 在以下使用virtio_net_set_queue_pairs():
+ *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+ *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+ *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+ */
 static void virtio_net_set_queue_pairs(VirtIONet *n)
 {
     int i;
@@ -743,7 +757,25 @@ static void virtio_net_set_queue_pairs(VirtIONet *n)
         return;
     }
 
+    /*
+     * VirtIONet *n:
+     * -> uint16_t max_queue_pairs;
+     * -> uint16_t curr_queue_pairs;
+     *
+     *
+     * 在以下修改VirtIONet->max_queue_pairs:
+     *   - hw/net/virtio-net.c|3562| <<global>> VMSTATE_SINGLE_TEST(max_queue_pairs, VirtIONet, max_queue_pairs_gt_1, 0,
+     *   - hw/net/virtio-net.c|3897| <<virtio_net_device_realize>> ++n->max_queue_pairs;
+     *   - hw/net/virtio-net.c|3901| <<virtio_net_device_realize>> n->max_queue_pairs = MAX(n->max_queue_pairs, 1);
+     */
     for (i = 0; i < n->max_queue_pairs; i++) {
+        /*
+	 * 在以下修改VirtIONet->curr_queue_pairs:
+         *   - hw/net/virtio-net.c|3564| <<global>> VMSTATE_UINT16_TEST(curr_queue_pairs, VirtIONet, max_queue_pairs_gt_1),
+         *   - hw/net/virtio-net.c|1482| <<virtio_net_handle_mq>> n->curr_queue_pairs = queue_pairs;
+         *   - hw/net/virtio-net.c|3911| <<virtio_net_device_realize>> n->curr_queue_pairs = 1;
+         *   - hw/net/virtio-net.c|4057| <<virtio_net_reset>> n->curr_queue_pairs = 1;
+	 */
         if (i < n->curr_queue_pairs) {
             r = peer_attach(n, i);
             assert(!r);
@@ -1436,6 +1468,10 @@ error:
     return 0;
 }
 
+/*
+ * 在以下使用virtio_net_handle_mq():
+ *   - hw/net/virtio-net.c|1561| <<virtio_net_handle_ctrl_iov>> status = virtio_net_handle_mq(n, ctrl.cmd, iov, out_num);
+ */
 static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,
                                 struct iovec *iov, unsigned int iov_cnt)
 {
@@ -1460,6 +1496,13 @@ static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,
         if (s != sizeof(mq)) {
             return VIRTIO_NET_ERR;
         }
+        /*
+	 * struct virtio_net_ctrl_mq {
+         *     __virtio16 virtqueue_pairs;
+	 * };
+	 *
+	 * 似乎来自guest
+	 */
         queue_pairs = virtio_lduw_p(vdev, &mq.virtqueue_pairs);
 
     } else {
@@ -1484,6 +1527,12 @@ static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,
     /* stop the backend before changing the number of queue_pairs to avoid handling a
      * disabled queue */
     virtio_net_set_status(vdev, vdev->status);
+    /*
+     * 在以下使用virtio_net_set_queue_pairs():
+     *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+     */
     virtio_net_set_queue_pairs(n);
 
     return VIRTIO_NET_OK;
@@ -2999,6 +3048,12 @@ static void virtio_net_set_multiqueue(VirtIONet *n, int multiqueue)
     n->multiqueue = multiqueue;
     virtio_net_change_num_queues(n, max * 2 + 1);
 
+    /*
+     * 在以下使用virtio_net_set_queue_pairs():
+     *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+     */
     virtio_net_set_queue_pairs(n);
 }
 
@@ -3136,6 +3191,12 @@ static int virtio_net_post_load_device(void *opaque, int version_id)
      */
     n->saved_guest_offloads = n->curr_guest_offloads;
 
+    /*
+     * 在以下使用virtio_net_set_queue_pairs():
+     *   - hw/net/virtio-net.c|1487| <<virtio_net_handle_mq>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3002| <<virtio_net_set_multiqueue>> virtio_net_set_queue_pairs(n);
+     *   - hw/net/virtio-net.c|3139| <<virtio_net_post_load_device>> virtio_net_set_queue_pairs(n);
+     */
     virtio_net_set_queue_pairs(n);
 
     /* Find the first multicast entry in the saved MAC filter */
@@ -3861,6 +3922,15 @@ static void virtio_net_device_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用VirtIONet->max_ncs:
+     *   - hw/net/virtio-net.c|269| <<virtio_net_vhost_status>> int cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     *   - hw/net/virtio-net.c|3899| <<virtio_net_device_realize>> n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
+     *   - hw/net/virtio-net.c|3906| <<virtio_net_device_realize>> for (i = 0; i < n->max_ncs; i++) {
+     *   - net/vhost-vdpa.c|358| <<vhost_vdpa_net_log_global_enable>> cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     */
     n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
 
     /*
@@ -3868,6 +3938,15 @@ static void virtio_net_device_realize(DeviceState *dev, Error **errp)
      * provide control queue via peers as well.
      */
     if (n->nic_conf.peers.queues) {
+        /*
+         * 在以下使用VirtIONet->max_ncs:
+         *   - hw/net/virtio-net.c|269| <<virtio_net_vhost_status>> int cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+         *                   ? n->max_ncs - n->max_queue_pairs : 0;
+         *   - hw/net/virtio-net.c|3899| <<virtio_net_device_realize>> n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
+         *   - hw/net/virtio-net.c|3906| <<virtio_net_device_realize>> for (i = 0; i < n->max_ncs; i++) {
+         *   - net/vhost-vdpa.c|358| <<vhost_vdpa_net_log_global_enable>> cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+         *                   ? n->max_ncs - n->max_queue_pairs : 0;
+	 */
         for (i = 0; i < n->max_ncs; i++) {
             if (n->nic_conf.peers.ncs[i]->is_datapath) {
                 ++n->max_queue_pairs;
diff --git a/hw/vfio/migration.c b/hw/vfio/migration.c
index 4c06e3db9..a4f0f126e 100644
--- a/hw/vfio/migration.c
+++ b/hw/vfio/migration.c
@@ -1017,6 +1017,17 @@ static int vfio_migration_init(VFIODevice *vbasedev)
     }
     strpadcpy(id, sizeof(id), path, '\0');
 
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
                          vbasedev);
 
diff --git a/include/accel/accel-cpu-ops.h b/include/accel/accel-cpu-ops.h
index 067476491..356e4ce4c 100644
--- a/include/accel/accel-cpu-ops.h
+++ b/include/accel/accel-cpu-ops.h
@@ -50,6 +50,15 @@ struct AccelOpsClass {
      * (QEMU is the reference).
      */
     void (*synchronize_post_reset)(CPUState *cpu);
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     void (*synchronize_post_init)(CPUState *cpu);
     /**
      * synchronize_state:
@@ -60,6 +69,15 @@ struct AccelOpsClass {
      * (the hardware accelerator is the reference).
      */
     void (*synchronize_state)(CPUState *cpu);
+    /*
+     * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+     *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+     *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+     *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+     *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+     */
     void (*synchronize_pre_loadvm)(CPUState *cpu);
 
     /* handle_interrupt is mandatory. */
diff --git a/include/hw/virtio/virtio-net.h b/include/hw/virtio/virtio-net.h
index 73fdefc0d..e6bfe912a 100644
--- a/include/hw/virtio/virtio-net.h
+++ b/include/hw/virtio/virtio-net.h
@@ -207,8 +207,30 @@ struct VirtIONet {
     NICConf nic_conf;
     DeviceState *qdev;
     int multiqueue;
+    /*
+     * 在以下修改VirtIONet->max_queue_pairs:
+     *   - hw/net/virtio-net.c|3562| <<global>> VMSTATE_SINGLE_TEST(max_queue_pairs, VirtIONet, max_queue_pairs_gt_1, 0,
+     *   - hw/net/virtio-net.c|3897| <<virtio_net_device_realize>> ++n->max_queue_pairs;
+     *   - hw/net/virtio-net.c|3901| <<virtio_net_device_realize>> n->max_queue_pairs = MAX(n->max_queue_pairs, 1);
+     */
     uint16_t max_queue_pairs;
+    /*
+     * 在以下修改VirtIONet->curr_queue_pairs:
+     *   - hw/net/virtio-net.c|1482| <<virtio_net_handle_mq>> n->curr_queue_pairs = queue_pairs;
+     *   - hw/net/virtio-net.c|3911| <<virtio_net_device_realize>> n->curr_queue_pairs = 1;
+     *   - hw/net/virtio-net.c|4057| <<virtio_net_reset>> n->curr_queue_pairs = 1;
+     *   - hw/net/virtio-net.c|3564| <<global>> VMSTATE_UINT16_TEST(curr_queue_pairs, VirtIONet, max_queue_pairs_gt_1),
+     */
     uint16_t curr_queue_pairs;
+    /*
+     * 在以下使用VirtIONet->max_ncs:
+     *   - hw/net/virtio-net.c|269| <<virtio_net_vhost_status>> int cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     *   - hw/net/virtio-net.c|3899| <<virtio_net_device_realize>> n->max_ncs = MAX(n->nic_conf.peers.queues, 1);
+     *   - hw/net/virtio-net.c|3906| <<virtio_net_device_realize>> for (i = 0; i < n->max_ncs; i++) {
+     *   - net/vhost-vdpa.c|358| <<vhost_vdpa_net_log_global_enable>> cvq = virtio_vdev_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ)
+     *                   ? n->max_ncs - n->max_queue_pairs : 0;
+     */
     uint16_t max_ncs;
     size_t config_size;
     char *netclient_name;
diff --git a/migration/block-dirty-bitmap.c b/migration/block-dirty-bitmap.c
index a061aad81..dd3bde16c 100644
--- a/migration/block-dirty-bitmap.c
+++ b/migration/block-dirty-bitmap.c
@@ -1264,6 +1264,17 @@ void dirty_bitmap_mig_init(void)
     QSIMPLEQ_INIT(&dbm_state.save.dbms_list);
     qemu_mutex_init(&dbm_state.load.lock);
 
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live("dirty-bitmap", 0, 1,
                          &savevm_dirty_bitmap_handlers,
                          &dbm_state);
diff --git a/migration/channel.c b/migration/channel.c
index a547b1fbf..971c2c426 100644
--- a/migration/channel.c
+++ b/migration/channel.c
@@ -30,6 +30,14 @@
  *
  * @ioc: Channel to which we are connecting
  */
+/*
+ * 在以下使用migration_channel_process_incoming():
+ *   - migration/exec.c|66| <<exec_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/fd.c|81| <<fd_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/file.c|132| <<file_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/socket.c|132| <<socket_accept_incoming_migration>> migration_channel_process_incoming(QIO_CHANNEL(cioc));
+ *   - migration/tls.c|69| <<migration_tls_incoming_handshake>> migration_channel_process_incoming(ioc);
+ */
 void migration_channel_process_incoming(QIOChannel *ioc)
 {
     MigrationState *s = migrate_get_current();
@@ -43,6 +51,9 @@ void migration_channel_process_incoming(QIOChannel *ioc)
         migration_tls_channel_process_incoming(s, ioc, &local_err);
     } else {
         migration_ioc_register_yank(ioc);
+        /*
+	 * 只在这里调用
+	 */
         migration_ioc_process_incoming(ioc, &local_err);
     }
 
@@ -64,6 +75,14 @@ void migration_channel_process_incoming(QIOChannel *ioc)
  * @hostname: Where we want to connect
  * @error: Error indicating failure to connect, free'd here
  */
+/*
+ * 在以下使用migration_channel_connect():
+ *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+ *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+ *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+ *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+ *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+ */
 void migration_channel_connect(MigrationState *s,
                                QIOChannel *ioc,
                                const char *hostname,
@@ -94,6 +113,11 @@ void migration_channel_connect(MigrationState *s,
             qemu_mutex_unlock(&s->qemu_file_lock);
         }
     }
+    /*
+     * 在以下使用migration_connect():
+     *   - migration/channel.c|108| <<migration_channel_connect>> migration_connect(s, error);
+     *   - migration/rdma.c|4002| <<rdma_start_outgoing_migration>> migration_connect(s, NULL);
+     */
     migration_connect(s, error);
     error_free(error);
 }
diff --git a/migration/colo.c b/migration/colo.c
index e0f713c83..407cdbe97 100644
--- a/migration/colo.c
+++ b/migration/colo.c
@@ -685,6 +685,16 @@ static void colo_incoming_process_checkpoint(MigrationIncomingState *mis,
     }
 
     bql_lock();
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
     ret = qemu_loadvm_state_main(mis->from_src_file, mis);
     bql_unlock();
diff --git a/migration/exec.c b/migration/exec.c
index 20e6cccf8..d52deff22 100644
--- a/migration/exec.c
+++ b/migration/exec.c
@@ -55,6 +55,14 @@ void exec_start_outgoing_migration(MigrationState *s, strList *command,
     }
 
     qio_channel_set_name(ioc, "migration-exec-outgoing");
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, NULL);
     object_unref(OBJECT(ioc));
 }
diff --git a/migration/fd.c b/migration/fd.c
index 9bf9be6ac..e86b00fdd 100644
--- a/migration/fd.c
+++ b/migration/fd.c
@@ -70,6 +70,14 @@ void fd_start_outgoing_migration(MigrationState *s, const char *fdname, Error **
     }
 
     qio_channel_set_name(ioc, "migration-fd-outgoing");
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, NULL);
     object_unref(OBJECT(ioc));
 }
diff --git a/migration/file.c b/migration/file.c
index bb8031e3c..9789c1035 100644
--- a/migration/file.c
+++ b/migration/file.c
@@ -122,9 +122,24 @@ void file_start_outgoing_migration(MigrationState *s,
         return;
     }
     qio_channel_set_name(ioc, "migration-file-outgoing");
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, NULL);
 }
 
+/*
+ * 在以下使用file_accept_incoming_migration():
+ *   - migration/file.c|170| <<file_create_incoming_channels>> qio_channel_add_watch_full(iocs[i], G_IO_IN,
+ *                                                    file_accept_incoming_migration,
+ *                                                    NULL, NULL,
+ *                                                    g_main_context_get_thread_default());
+ */
 static gboolean file_accept_incoming_migration(QIOChannel *ioc,
                                                GIOCondition condition,
                                                gpointer opaque)
diff --git a/migration/migration.c b/migration/migration.c
index 10c216d25..775396afd 100644
--- a/migration/migration.c
+++ b/migration/migration.c
@@ -113,6 +113,10 @@ static bool close_return_path_on_source(MigrationState *s);
 static void migration_completion_end(MigrationState *s);
 static void migrate_hup_delete(MigrationState *s);
 
+/*
+ * 在以下使用migration_downtime_start():
+ *   - migration/migration.c|311| <<migration_stop_vm>> migration_downtime_start(s);
+ */
 static void migration_downtime_start(MigrationState *s)
 {
     trace_vmstate_downtime_checkpoint("src-downtime-start");
@@ -140,6 +144,12 @@ static void migrate_incoming_unref_outgoing_state(void)
     object_unref(migrate_get_current());
 }
 
+/*
+ * 在以下使用migration_downtime_end():
+ *   - migration/migration.c|3005| <<postcopy_start>> migration_downtime_end(ms);
+ *   - migration/migration.c|3603| <<migration_completion_end>> migration_downtime_end(s);
+ *   - migration/migration.c|4113| <<bg_migration_vm_start_bh>> migration_downtime_end(s);
+ */
 static void migration_downtime_end(MigrationState *s)
 {
     int64_t now = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);
@@ -287,6 +297,23 @@ static gint page_request_addr_cmp(gconstpointer ap, gconstpointer bp)
     return (a > b) - (a < b);
 }
 
+/*
+ * (gdb) bt
+ * #0  migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:292
+ * #1  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #2  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #3  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #4  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用migration_stop_vm():
+ *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+ *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+ *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+ *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+ */
 static int migration_stop_vm(MigrationState *s, RunState state)
 {
     int ret;
@@ -296,6 +323,13 @@ static int migration_stop_vm(MigrationState *s, RunState state)
     s->vm_old_state = runstate_get();
     global_state_store();
 
+    /*
+     * 在以下使用vm_stop_force_state():
+     *   - migration/colo.c|216| <<colo_do_failover>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/colo.c|432| <<colo_do_checkpoint_transaction>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/colo.c|668| <<colo_incoming_process_checkpoint>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/migration.c|306| <<migration_stop_vm>> ret = vm_stop_force_state(state);
+     */
     ret = vm_stop_force_state(state);
 
     trace_vmstate_downtime_checkpoint("src-vm-stopped");
@@ -321,6 +355,13 @@ void migration_object_init(void)
         g_array_new(FALSE, TRUE, sizeof(struct PostCopyFD));
     qemu_mutex_init(&current_incoming->rp_mutex);
     qemu_mutex_init(&current_incoming->postcopy_prio_thread_mutex);
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     qemu_event_init(&current_incoming->main_thread_load_event, false);
     qemu_sem_init(&current_incoming->postcopy_pause_sem_dst, 0);
     qemu_sem_init(&current_incoming->postcopy_pause_sem_fault, 0);
@@ -348,6 +389,10 @@ typedef struct {
     void *opaque;
 } MigrationBH;
 
+/*
+ * 在以下使用migration_bh_dispatch_bh():
+ *   - migration/migration.c|395| <<migration_bh_schedule>> QEMUBH *bh = qemu_bh_new(migration_bh_dispatch_bh, migbh);
+ */
 static void migration_bh_dispatch_bh(void *opaque)
 {
     MigrationState *s = migrate_get_current();
@@ -364,6 +409,24 @@ static void migration_bh_dispatch_bh(void *opaque)
     g_free(migbh);
 }
 
+/*
+ * 在Target上.
+ * (gdb) bt
+ * #0  migration_bh_schedule (cb=0x555555c5fee6 <process_incoming_migration_bh>, opaque=0x5555575e2e00) at ../migration/migration.c:369
+ * #1  0x0000555555c601c6 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:920
+ * #2  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #3  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #4  0x00007fffffffc7e0 in ?? ()
+ * #5  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用migration_bh_schedule():
+ *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+ *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+ *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+ *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+ *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+ */
 void migration_bh_schedule(QEMUBHFunc *cb, void *opaque)
 {
     MigrationState *s = migrate_get_current();
@@ -481,6 +544,13 @@ void migration_incoming_state_destroy(void)
     }
 
     migration_incoming_transport_cleanup(mis);
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     qemu_event_reset(&mis->main_thread_load_event);
 
     if (mis->page_requested) {
@@ -809,6 +879,36 @@ static void qemu_start_incoming_migration(const char *uri, bool has_channels,
     cpr_state_close();
 }
 
+/*
+ * (gdb) bt
+ * #0  migration_bh_schedule (cb=0x555555c5fee6 <process_incoming_migration_bh>, opaque=0x5555575e2e00) at ../migration/migration.c:369
+ * #1  0x0000555555c601c6 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:920
+ * #2  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #3  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #4  0x00007fffffffc7e0 in ?? ()
+ * #5  0x0000000000000000 in ?? ()
+ *
+ *
+ * (gdb) bt
+ * #0  process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:814
+ * #1  0x0000555555c5ed01 in migration_bh_dispatch_bh (opaque=0x555558143a20) at ../migration/migration.c:361
+ * #2  0x0000555556170433 in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #3  0x0000555556170581 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #4  0x00005555561500fb in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #5  0x0000555556170a50 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #6  0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #7  g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #8  0x0000555556172240 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #9  0x00005555561722ce in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #10 0x00005555561723fd in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #11 0x0000555555c38d08 in qemu_main_loop () at ../system/runstate.c:905
+ * #12 0x0000555556082abe in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #13 0x0000555556082b78 in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用process_incoming_migration_bh():
+ *   - migration/migration.c|944| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+ */
 static void process_incoming_migration_bh(void *opaque)
 {
     MigrationIncomingState *mis = opaque;
@@ -842,6 +942,23 @@ static void process_incoming_migration_bh(void *opaque)
              * metadata.  If error, don't restart the VM yet.
              */
             if (migration_block_activate(NULL)) {
+                /*
+		 * 在以下使用vm_start():
+                 *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+                 *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+                 *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+                 *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+                 *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+                 *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+                 *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+                 *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+                 *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+                 *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+                 *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+                 *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+                 *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+                 *   - system/cpus.c|793| <<vm_resume>> vm_start();
+		 */
                 vm_start();
             }
         } else {
@@ -864,6 +981,18 @@ static void process_incoming_migration_bh(void *opaque)
     migration_incoming_state_destroy();
 }
 
+/*
+ * (gdb) bt
+ * #0  process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:873
+ * #1  0x0000555556174e10 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #2  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #3  0x00007fffffffc7e0 in ?? ()
+ * #4  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用process_incoming_migration_co():
+ *   - migration/migration.c|983| <<migration_incoming_process>> Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
+ */
 static void coroutine_fn
 process_incoming_migration_co(void *opaque)
 {
@@ -881,6 +1010,12 @@ process_incoming_migration_co(void *opaque)
                       MIGRATION_STATUS_ACTIVE);
 
     mis->loadvm_co = qemu_coroutine_self();
+    /*
+     * 在以下使用qemu_loadvm_state():
+     *   - migration/migration.c|908| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file);
+     *   - migration/savevm.c|3581| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f);
+     *   - migration/savevm.c|3655| <<load_snapshot>> ret = qemu_loadvm_state(f);
+     */
     ret = qemu_loadvm_state(mis->from_src_file);
     mis->loadvm_co = NULL;
 
@@ -917,6 +1052,14 @@ process_incoming_migration_co(void *opaque)
         colo_incoming_co();
     }
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(process_incoming_migration_bh, mis);
     goto out;
 
@@ -954,6 +1097,11 @@ static void migration_incoming_setup(QEMUFile *f)
     qemu_file_set_blocking(f, false);
 }
 
+/*
+ * 在以下使用migration_incoming_process():
+ *   - migration/migration.c|1026| <<migration_fd_process_incoming>> migration_incoming_process();
+ *   - migration/migration.c|1129| <<migration_ioc_process_incoming>> migration_incoming_process();
+ */
 void migration_incoming_process(void)
 {
     Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
@@ -993,15 +1141,30 @@ static bool postcopy_try_recover(void)
     return false;
 }
 
+/*
+ * 在以下使用migration_fd_process_incoming():
+ *   - migration/rdma.c|3888| <<rdma_accept_incoming_migration>> migration_fd_process_incoming(f);
+ */
 void migration_fd_process_incoming(QEMUFile *f)
 {
     migration_incoming_setup(f);
     if (postcopy_try_recover()) {
         return;
     }
+    /*
+     * 在以下使用migration_incoming_process():
+     *   - migration/migration.c|1026| <<migration_fd_process_incoming>> migration_incoming_process();
+     *   - migration/migration.c|1129| <<migration_ioc_process_incoming>> migration_incoming_process();
+     */
     migration_incoming_process();
 }
 
+/*
+ * 在以下使用migration_has_main_and_multifd_channels():
+ *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+ *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+ *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+ */
 static bool migration_has_main_and_multifd_channels(void)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -1018,6 +1181,10 @@ static bool migration_has_main_and_multifd_channels(void)
     return true;
 }
 
+/*
+ * 在以下使用migration_ioc_process_incoming():
+ *   - migration/channel.c|46| <<migration_channel_process_incoming>> migration_ioc_process_incoming(ioc, &local_err);
+ */
 void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -1027,6 +1194,12 @@ void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
     uint32_t channel_magic = 0;
     int ret = 0;
 
+    /*
+     * 在以下使用migration_has_main_and_multifd_channels():
+     *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+     */
     if (!migration_has_main_and_multifd_channels()) {
         if (qio_channel_has_feature(ioc, QIO_CHANNEL_FEATURE_READ_MSG_PEEK)) {
             /*
@@ -1097,11 +1270,22 @@ void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用migration_has_main_and_multifd_channels():
+     *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+     */
     if (migration_has_main_and_multifd_channels()) {
         /* If it's a recovery, we're done */
         if (postcopy_try_recover()) {
             return;
         }
+        /*
+	 * 在以下使用migration_incoming_process():
+         *   - migration/migration.c|1026| <<migration_fd_process_incoming>> migration_incoming_process();
+         *   - migration/migration.c|1129| <<migration_ioc_process_incoming>> migration_incoming_process();
+	 */
         migration_incoming_process();
     }
 }
@@ -1114,6 +1298,12 @@ void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
  */
 bool migration_has_all_channels(void)
 {
+    /*
+     * 在以下使用migration_has_main_and_multifd_channels():
+     *   - migration/migration.c|1090| <<migration_ioc_process_incoming>> if (!migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1160| <<migration_ioc_process_incoming>> if (migration_has_main_and_multifd_channels()) {
+     *   - migration/migration.c|1177| <<migration_has_all_channels>> if (!migration_has_main_and_multifd_channels()) {
+     */
     if (!migration_has_main_and_multifd_channels()) {
         return false;
     }
@@ -2740,6 +2930,13 @@ static int postcopy_start(MigrationState *ms, Error **errp)
     bql_lock();
     trace_postcopy_start_set_run();
 
+    /*
+     * 在以下使用migration_stop_vm():
+     *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+     *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     */
     ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
     if (ret < 0) {
         error_setg_errno(errp, -ret, "%s: Failed to stop the VM", __func__);
@@ -2797,6 +2994,12 @@ static int postcopy_start(MigrationState *ms, Error **errp)
      */
     qemu_savevm_send_postcopy_listen(fb);
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+     *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+     *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+     *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+     */
     ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
     if (ret) {
         error_setg(errp, "Postcopy save non-iterable device states failed");
@@ -2971,6 +3174,75 @@ static bool migration_switchover_start(MigrationState *s, Error **errp)
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *   
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用migration_completion_precopy():
+ *   - migration/migration.c|3029| <<migration_completion>> ret = migration_completion_precopy(s);
+ */
 static int migration_completion_precopy(MigrationState *s)
 {
     int ret;
@@ -2978,6 +3250,13 @@ static int migration_completion_precopy(MigrationState *s)
     bql_lock();
 
     if (!migrate_mode_is_cpr(s)) {
+        /*
+	 * 在以下使用migration_stop_vm():
+	 *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+	 *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 */
         ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
         if (ret < 0) {
             goto out_unlock;
@@ -2989,6 +3268,12 @@ static int migration_completion_precopy(MigrationState *s)
         goto out_unlock;
     }
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy():
+     *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+     *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+     *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+     */
     ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
 out_unlock:
     bql_unlock();
@@ -3020,12 +3305,21 @@ static void migration_completion_postcopy(MigrationState *s)
  *
  * @s: Current migration state
  */
+/*
+ * 在以下使用migration_completion():
+ *   - migration/migration.c|3523| <<migration_iteration_run>> migration_completion(s);
+ *
+ * 似乎没有到最后的部分不会到这里
+ */
 static void migration_completion(MigrationState *s)
 {
     int ret = 0;
     Error *local_err = NULL;
 
     if (s->state == MIGRATION_STATUS_ACTIVE) {
+        /*
+	 * 只在这调用
+	 */
         ret = migration_completion_precopy(s);
     } else if (s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE) {
         migration_completion_postcopy(s);
@@ -3051,6 +3345,11 @@ static void migration_completion(MigrationState *s)
         migrate_set_state(&s->state, MIGRATION_STATUS_ACTIVE,
                           MIGRATION_STATUS_COLO);
     } else {
+        /*
+	 * 在以下使用migration_completion_end():
+         *   - migration/migration.c|3089| <<migration_completion>> migration_completion_end(s);
+         *   - migration/migration.c|3137| <<bg_migration_completion>> migration_completion_end(s);
+	 */
         migration_completion_end(s);
     }
 
@@ -3099,6 +3398,11 @@ static void bg_migration_completion(MigrationState *s)
         goto fail;
     }
 
+    /*
+     * 在以下使用migration_completion_end():
+     *   - migration/migration.c|3089| <<migration_completion>> migration_completion_end(s);
+     *   - migration/migration.c|3137| <<bg_migration_completion>> migration_completion_end(s);
+     */
     migration_completion_end(s);
     return;
 
@@ -3314,6 +3618,11 @@ static MigThrError migration_detect_error(MigrationState *s)
     }
 }
 
+/*
+ * 在以下使用migration_completion_end():
+ *   - migration/migration.c|3089| <<migration_completion>> migration_completion_end(s);
+ *   - migration/migration.c|3137| <<bg_migration_completion>> migration_completion_end(s);
+ */
 static void migration_completion_end(MigrationState *s)
 {
     uint64_t bytes = migration_transferred_bytes();
@@ -3435,6 +3744,10 @@ typedef enum {
  * Return true if continue to the next iteration directly, false
  * otherwise.
  */
+/*
+ * 在以下使用migration_iteration_run():
+ *   - migration/migration.c|3792| <<migration_thread>> MigIterateState iter_state = migration_iteration_run(s);
+ */
 static MigIterateState migration_iteration_run(MigrationState *s)
 {
     uint64_t must_precopy, can_postcopy, pending_size;
@@ -3463,6 +3776,9 @@ static MigIterateState migration_iteration_run(MigrationState *s)
          * during postcopy phase.
          */
         if (pending_size < s->threshold_size) {
+            /*
+	     * 只在这里调用
+	     */
             qemu_savevm_state_pending_exact(&must_precopy, &can_postcopy);
             pending_size = must_precopy + can_postcopy;
             trace_migrate_pending_exact(pending_size, must_precopy,
@@ -3500,6 +3816,10 @@ static MigIterateState migration_iteration_run(MigrationState *s)
     return MIG_ITERATE_RESUME;
 }
 
+/*
+ * 在以下使用migration_iteration_finish():
+ *   - migration/migration.c|3822| <<migration_thread>> migration_iteration_finish(s);
+ */
 static void migration_iteration_finish(MigrationState *s)
 {
     bql_lock();
@@ -3547,6 +3867,14 @@ static void migration_iteration_finish(MigrationState *s)
         break;
     }
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(migration_cleanup_bh, s);
     bql_unlock();
 }
@@ -3575,6 +3903,14 @@ static void bg_migration_iteration_finish(MigrationState *s)
         break;
     }
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(migration_cleanup_bh, s);
     bql_unlock();
 }
@@ -3683,6 +4019,11 @@ static void qemu_savevm_wait_unplug(MigrationState *s, int old_state,
  * Master migration thread on the source VM.
  * It drives the migration and pumps the data down the outgoing channel.
  */
+/*
+ * 在以下使用migration_thread():
+ *   - migration/migration.c|4389| <<migration_connect>> qemu_thread_create(&s->thread,
+ *               MIGRATION_THREAD_SRC_MAIN, migration_thread, s, QEMU_THREAD_JOINABLE);
+ */
 static void *migration_thread(void *opaque)
 {
     MigrationState *s = opaque;
@@ -3705,6 +4046,12 @@ static void *migration_thread(void *opaque)
     }
 
     bql_lock();
+    /*
+     * 在以下使用qemu_savevm_state_header():
+     *   - migration/migration.c|4024| <<migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/migration.c|4186| <<bg_migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/savevm.c|2010| <<qemu_savevm_state>> qemu_savevm_state_header(f);
+     */
     qemu_savevm_state_header(s->to_dst_file);
     bql_unlock();
 
@@ -3794,6 +4141,9 @@ static void *migration_thread(void *opaque)
 
 out:
     trace_migration_thread_after_loop();
+    /*
+     * 只在这里调用
+     */
     migration_iteration_finish(s);
     object_unref(OBJECT(s));
     rcu_unregister_thread();
@@ -3889,10 +4239,23 @@ static void *bg_migration_thread(void *opaque)
 
     bql_lock();
 
+    /*
+     * 在以下使用migration_stop_vm():
+     *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+     *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     */
     if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
         goto fail;
     }
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+     *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+     *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+     *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+     */
     if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
         goto fail;
     }
@@ -3914,6 +4277,14 @@ static void *bg_migration_thread(void *opaque)
      * calling VM state change notifiers from vm_start() would initiate
      * writes to virtio VQs memory which is in write-protected region.
      */
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(bg_migration_vm_start_bh, s);
     bql_unlock();
 
@@ -3956,6 +4327,11 @@ fail_setup:
     return NULL;
 }
 
+/*
+ * 在以下使用migration_connect():
+ *   - migration/channel.c|108| <<migration_channel_connect>> migration_connect(s, error);
+ *   - migration/rdma.c|4002| <<rdma_start_outgoing_migration>> migration_connect(s, NULL);
+ */
 void migration_connect(MigrationState *s, Error *error_in)
 {
     Error *local_err = NULL;
@@ -4034,6 +4410,13 @@ void migration_connect(MigrationState *s, Error *error_in)
     }
 
     if (migrate_mode_is_cpr(s)) {
+        /*
+	 * 在以下使用migration_stop_vm():
+	 *   - migration/migration.c|2743| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|2981| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 *   - migration/migration.c|3892| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+	 *   - migration/migration.c|4037| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 */
         ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
         if (ret < 0) {
             error_setg(&local_err, "migration_stop_vm failed, error %d", -ret);
diff --git a/migration/migration.h b/migration/migration.h
index 01329bf82..4f7671f2b 100644
--- a/migration/migration.h
+++ b/migration/migration.h
@@ -105,6 +105,13 @@ struct MigrationIncomingState {
      * Free at the start of the main state load, set as the main thread finishes
      * loading state.
      */
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     QemuEvent main_thread_load_event;
 
     /* For network announces */
diff --git a/migration/ram.c b/migration/ram.c
index 7208bc114..fce370d94 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -4323,6 +4323,37 @@ static int ram_load_precopy(QEMUFile *f)
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  vm_start () at ../system/cpus.c:785
+ * #1  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #2  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x55555786f100) at ../migration/migration.c:361
+ * #3  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #4  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #5  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #6  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #7  0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #8  g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #9  0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #10 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #11 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #12 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #13 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #14 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * (gdb) bt
+ * #0  ram_load (f=0x5555578d3200, opaque=0x555557524aa0 <ram_state>, version_id=4) at ../migration/ram.c:4327
+ * #1  0x0000555555c79a9d in vmstate_load (f=0x5555578d3200, se=0x5555575e3220) at ../migration/savevm.c:970
+ * #2  0x0000555555c7da30 in qemu_loadvm_section_part_end (f=0x5555578d3200, type=2 '\002') at ../migration/savevm.c:2796
+ * #3  0x0000555555c7e40d in qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3056
+ * #4  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #5  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #6  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #7  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #8  0x00007fffffffc7e0 in ?? ()
+ * #9  0x0000000000000000 in ?? ()
+ */
 static int ram_load(QEMUFile *f, void *opaque, int version_id)
 {
     int ret = 0;
@@ -4638,6 +4669,17 @@ static RAMBlockNotifier ram_mig_ram_notifier = {
 void ram_mig_init(void)
 {
     qemu_mutex_init(&XBZRLE.lock);
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
     ram_block_notifier_add(&ram_mig_ram_notifier);
 }
diff --git a/migration/rdma.c b/migration/rdma.c
index 2d839fce6..459229008 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -3999,6 +3999,11 @@ void rdma_start_outgoing_migration(void *opaque,
 
     s->to_dst_file = rdma_new_output(rdma);
     s->rdma_migration = true;
+    /*
+     * 在以下使用migration_connect():
+     *   - migration/channel.c|108| <<migration_channel_connect>> migration_connect(s, error);
+     *   - migration/rdma.c|4002| <<rdma_start_outgoing_migration>> migration_connect(s, NULL);
+     */
     migration_connect(s, NULL);
     return;
 return_path_err:
diff --git a/migration/savevm.c b/migration/savevm.c
index fabbeb296..70eea2bc4 100644
--- a/migration/savevm.c
+++ b/migration/savevm.c
@@ -743,6 +743,11 @@ static inline MigrationPriority save_state_priority(SaveStateEntry *se)
     return MIG_PRI_DEFAULT;
 }
 
+/*
+ * 在以下使用savevm_state_handler_insert():
+ *   - migration/savevm.c|832| <<register_savevm_live>> savevm_state_handler_insert(se);
+ *   - migration/savevm.c|948| <<vmstate_register_with_alias_id>> savevm_state_handler_insert(se);
+ */
 static void savevm_state_handler_insert(SaveStateEntry *nse)
 {
     MigrationPriority priority = save_state_priority(nse);
@@ -798,6 +803,17 @@ static void savevm_state_handler_remove(SaveStateEntry *se)
     QTAILQ_REMOVE(&savevm_state.handlers, se, entry);
 }
 
+/*
+ * 在以下使用register_savevm_live():
+ *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+ *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+ *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+ *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+ *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+ *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+ *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+ *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+ */
 /* TODO: Individual devices generally have very little idea about the rest
    of the system, so instance_id should be removed/replaced.
    Meanwhile pass -1 as instance_id if you do not already have a clearly
@@ -829,6 +845,11 @@ int register_savevm_live(const char *idstr,
         se->instance_id = instance_id;
     }
     assert(!se->compat || se->instance_id == 0);
+    /*
+     * 在以下使用savevm_state_handler_insert():
+     *   - migration/savevm.c|832| <<register_savevm_live>> savevm_state_handler_insert(se);
+     *   - migration/savevm.c|948| <<vmstate_register_with_alias_id>> savevm_state_handler_insert(se);
+     */
     savevm_state_handler_insert(se);
     return 0;
 }
@@ -945,6 +966,11 @@ int vmstate_register_with_alias_id(VMStateIf *obj, uint32_t instance_id,
         vmstate_check(vmsd);
     }
     assert(!se->compat || se->instance_id == 0);
+    /*
+     * 在以下使用savevm_state_handler_insert():
+     *   - migration/savevm.c|832| <<register_savevm_live>> savevm_state_handler_insert(se);
+     *   - migration/savevm.c|948| <<vmstate_register_with_alias_id>> savevm_state_handler_insert(se);
+     */
     savevm_state_handler_insert(se);
     return 0;
 }
@@ -1024,6 +1050,12 @@ static void save_section_footer(QEMUFile *f, SaveStateEntry *se)
     }
 }
 
+/*
+ * 在以下使用vmstate_save():
+ *   - migration/savevm.c|1361| <<qemu_savevm_state_setup>> ret = vmstate_save(f, se, vmdesc, errp);
+ *   - migration/savevm.c|1669| <<qemu_savevm_state_complete_precopy_non_iterable>> ret = vmstate_save(f, se, vmdesc, &local_err);
+ *   - migration/savevm.c|1864| <<qemu_save_device_state>> ret = vmstate_save(f, se, NULL, &local_err);
+ */
 static int vmstate_save(QEMUFile *f, SaveStateEntry *se, JSONWriter *vmdesc,
                         Error **errp)
 {
@@ -1274,6 +1306,12 @@ void qemu_savevm_non_migratable_list(strList **reasons)
     }
 }
 
+/*
+ * 在以下使用qemu_savevm_state_header():
+ *   - migration/migration.c|4024| <<migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+ *   - migration/migration.c|4186| <<bg_migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+ *   - migration/savevm.c|2010| <<qemu_savevm_state>> qemu_savevm_state_header(f);
+ */
 void qemu_savevm_state_header(QEMUFile *f)
 {
     MigrationState *s = migrate_get_current();
@@ -1573,6 +1611,11 @@ bool qemu_savevm_state_postcopy_prepare(QEMUFile *f, Error **errp)
     return true;
 }
 
+/*
+ * 在以下使用qemu_savevm_state_complete_precopy_iterable():
+ *   - migration/migration.c|2771| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_iterable(ms->to_dst_file, true);
+ *   - migration/savevm.c|1718| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_iterable(f, false);
+ */
 int qemu_savevm_state_complete_precopy_iterable(QEMUFile *f, bool in_postcopy)
 {
     int64_t start_ts_each, end_ts_each;
@@ -1644,6 +1687,62 @@ ret_fail_abort_threads:
     return -1;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+ *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+ *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+ *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+ */
 int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
                                                     bool in_postcopy)
 {
@@ -1655,6 +1754,16 @@ int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
     Error *local_err = NULL;
     int ret;
 
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     /* Making sure cpu states are synchronized before saving non-iterable */
     cpu_synchronize_all_states();
 
@@ -1680,6 +1789,14 @@ int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
     }
 
     if (!in_postcopy) {
+        /*
+	 * 非test使用QEMU_VM_EOF的地方:
+	 *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+	 *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+	 */
         /* Postcopy stream will still be going */
         qemu_put_byte(f, QEMU_VM_EOF);
 
@@ -1699,16 +1816,106 @@ int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *   
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1704
+ * #1  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #2  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #3  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #4  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用qemu_savevm_state_complete_precopy():
+ *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+ *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+ *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+ */
 int qemu_savevm_state_complete_precopy(QEMUFile *f, bool iterable_only)
 {
     int ret;
 
+    /*
+     * 似乎是剩余可以迁移的最后一点数据?
+     */
     ret = qemu_savevm_state_complete_precopy_iterable(f, false);
     if (ret) {
         return ret;
     }
 
     if (!iterable_only) {
+        /*
+	 * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+         *   - migration/migration.c|2814| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+         *   - migration/migration.c|3949| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+         *   - migration/savevm.c|1724| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+	 */
         ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
         if (ret) {
             return ret;
@@ -1743,6 +1950,10 @@ void qemu_savevm_state_pending_estimate(uint64_t *must_precopy,
     }
 }
 
+/*
+ * 在以下使用qemu_savevm_state_pending_exact():
+ *   - migration/migration.c|3535| <<migration_iteration_run>> qemu_savevm_state_pending_exact(&must_precopy, &can_postcopy);
+ */
 void qemu_savevm_state_pending_exact(uint64_t *must_precopy,
                                      uint64_t *can_postcopy)
 {
@@ -1781,6 +1992,10 @@ void qemu_savevm_state_cleanup(void)
     }
 }
 
+/*
+ * 在以下使用qemu_savevm_state():
+ *   - migration/savevm.c|3351| <<save_snapshot>> ret = qemu_savevm_state(f, errp);
+ */
 static int qemu_savevm_state(QEMUFile *f, Error **errp)
 {
     int ret;
@@ -1798,6 +2013,12 @@ static int qemu_savevm_state(QEMUFile *f, Error **errp)
     }
     ms->to_dst_file = f;
 
+    /*
+     * 在以下使用qemu_savevm_state_header():
+     *   - migration/migration.c|4024| <<migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/migration.c|4186| <<bg_migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+     *   - migration/savevm.c|2010| <<qemu_savevm_state>> qemu_savevm_state_header(f);
+     */
     qemu_savevm_state_header(f);
     ret = qemu_savevm_state_setup(f, errp);
     if (ret) {
@@ -1813,6 +2034,12 @@ static int qemu_savevm_state(QEMUFile *f, Error **errp)
     ret = qemu_file_get_error(f);
     if (ret == 0) {
         qemu_savevm_maybe_send_switchover_start(f);
+        /*
+	 * 在以下使用qemu_savevm_state_complete_precopy():
+	 *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+	 *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+	 *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+	 */
         qemu_savevm_state_complete_precopy(f, false);
         ret = qemu_file_get_error(f);
     }
@@ -1836,13 +2063,36 @@ cleanup:
     return ret;
 }
 
+/*
+ * 在以下使用qemu_savevm_live_state():
+ *   - migration/colo.c|474| <<colo_do_checkpoint_transaction>> qemu_savevm_live_state(s->to_dst_file);
+ */
 void qemu_savevm_live_state(QEMUFile *f)
 {
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy():
+     *   - migration/migration.c|3017| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+     *   - migration/savevm.c|1816| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+     *   - migration/savevm.c|1842| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+     */
     /* save QEMU_VM_SECTION_END section */
     qemu_savevm_state_complete_precopy(f, true);
+    /*
+     * 非test使用QEMU_VM_EOF的地方:
+     *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+     */
     qemu_put_byte(f, QEMU_VM_EOF);
 }
 
+/*
+ * 在以下使用qemu_save_device_state():
+ *   - migration/colo.c|459| <<colo_do_checkpoint_transaction>> ret = qemu_save_device_state(fb);
+ *   - migration/savevm.c|3432| <<qmp_xen_save_devices_state>> ret = qemu_save_device_state(f);
+ */
 int qemu_save_device_state(QEMUFile *f)
 {
     MigrationState *ms = migrate_get_current();
@@ -1853,6 +2103,16 @@ int qemu_save_device_state(QEMUFile *f)
         qemu_put_be32(f, QEMU_VM_FILE_MAGIC);
         qemu_put_be32(f, QEMU_VM_FILE_VERSION);
     }
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
 
     QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
@@ -1869,6 +2129,14 @@ int qemu_save_device_state(QEMUFile *f)
         }
     }
 
+    /*
+     * 非test使用QEMU_VM_EOF的地方:
+     *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+     *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+     */
     qemu_put_byte(f, QEMU_VM_EOF);
 
     return qemu_file_get_error(f);
@@ -2076,6 +2344,11 @@ static int loadvm_postcopy_ram_handle_discard(MigrationIncomingState *mis,
  * (TODO:This could do with being in a postcopy file - but there again it's
  * just another input loop, not that postcopy specific)
  */
+/*
+ * 在以下使用postcopy_ram_listen_thread():
+ *   - migration/savevm.c|2353| <<loadvm_postcopy_handle_listen>> postcopy_thread_create(mis, &mis->listen_thread,
+ *                          MIGRATION_THREAD_DST_LISTEN, postcopy_ram_listen_thread, QEMU_THREAD_DETACHED);
+ */
 static void *postcopy_ram_listen_thread(void *opaque)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -2135,6 +2408,13 @@ static void *postcopy_ram_listen_thread(void *opaque)
          * main thread hasn't finished yet, and so we might not be in 'RUN'
          * state yet; wait for the end of the main thread.
          */
+        /*
+	 * 在以下使用MigrationIncomingState->main_thread_load_event:
+         *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+         *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+         *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+         *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+	 */
         qemu_event_wait(&mis->main_thread_load_event);
     }
     postcopy_ram_incoming_cleanup(mis);
@@ -2274,6 +2554,14 @@ static int loadvm_postcopy_handle_run(MigrationIncomingState *mis)
     }
 
     postcopy_state_set(POSTCOPY_INCOMING_RUNNING);
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|975| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3717| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3745| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4100| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/savevm.c|2410| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
 
     /* We need to finish reading the stream from the package
@@ -2813,6 +3101,10 @@ qemu_loadvm_section_part_end(QEMUFile *f, uint8_t type)
     return 0;
 }
 
+/*
+ * 在以下使用qemu_loadvm_state_header():
+ *   - migration/savevm.c|3440| <<qemu_loadvm_state>> ret = qemu_loadvm_state_header(f);
+ */
 static int qemu_loadvm_state_header(QEMUFile *f)
 {
     unsigned int v;
@@ -3028,6 +3320,24 @@ static bool postcopy_pause_incoming(MigrationIncomingState *mis)
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3033
+ * #1  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #2  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #3  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #4  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #5  0x00007fffffffc7e0 in ?? ()
+ * #6  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用qemu_loadvm_state_main():
+ *   - migration/colo.c|699| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis);
+ *   - migration/savevm.c|2234| <<postcopy_ram_listen_thread>> load_res = qemu_loadvm_state_main(f, mis);
+ *   - migration/savevm.c|2593| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis);
+ *   - migration/savevm.c|3283| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis);
+ *   - migration/savevm.c|3357| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis);
+ */
 int qemu_loadvm_state_main(QEMUFile *f, MigrationIncomingState *mis)
 {
     uint8_t section_type;
@@ -3066,6 +3376,14 @@ retry:
             }
             break;
         case QEMU_VM_EOF:
+            /*
+	     * 非test使用QEMU_VM_EOF的地方:
+             *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+             *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+	     */
             /* This is the end of migration */
             goto out;
         default:
@@ -3103,6 +3421,21 @@ out:
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3112
+ * #1  0x0000555555c600fa in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:891
+ * #2  0x0000555556174e10 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #3  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #4  0x00007fffffffc7e0 in ?? ()
+ * #5  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用qemu_loadvm_state():
+ *   - migration/migration.c|908| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file);
+ *   - migration/savevm.c|3581| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f);
+ *   - migration/savevm.c|3655| <<load_snapshot>> ret = qemu_loadvm_state(f);
+ */
 int qemu_loadvm_state(QEMUFile *f)
 {
     MigrationState *s = migrate_get_current();
@@ -3131,9 +3464,33 @@ int qemu_loadvm_state(QEMUFile *f)
         qemu_loadvm_state_switchover_ack_needed(mis);
     }
 
+    /*
+     * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+     *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+     *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+     *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+     *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+     */
     cpu_synchronize_all_pre_loadvm();
 
+    /*
+     * 在以下使用qemu_loadvm_state_main():
+     *   - migration/colo.c|699| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis);
+     *   - migration/savevm.c|2234| <<postcopy_ram_listen_thread>> load_res = qemu_loadvm_state_main(f, mis);
+     *   - migration/savevm.c|2593| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis);
+     *   - migration/savevm.c|3283| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis);
+     *   - migration/savevm.c|3357| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis);
+     */
     ret = qemu_loadvm_state_main(f, mis);
+    /*
+     * 在以下使用MigrationIncomingState->main_thread_load_event:
+     *   - migration/migration.c|348| <<migration_object_init>> qemu_event_init(&current_incoming->main_thread_load_event, false);
+     *   - migration/migration.c|530| <<migration_incoming_state_destroy>> qemu_event_reset(&mis->main_thread_load_event);
+     *   - migration/savevm.c|2271| <<postcopy_ram_listen_thread>> qemu_event_wait(&mis->main_thread_load_event);
+     *   - migration/savevm.c|3284| <<qemu_loadvm_state>> qemu_event_set(&mis->main_thread_load_event);
+     */
     qemu_event_set(&mis->main_thread_load_event);
 
     trace_qemu_loadvm_state_post_main(ret);
@@ -3196,6 +3553,13 @@ int qemu_loadvm_state(QEMUFile *f)
         }
     }
 
+    /*
+     * 在以下使用cpu_synchronize_all_post_init():
+     *   - hw/core/machine.c|1732| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|2368| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3346| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3363| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+     */
     cpu_synchronize_all_post_init();
 
     return ret;
@@ -3213,6 +3577,13 @@ int qemu_load_device_state(QEMUFile *f)
         return ret;
     }
 
+    /*
+     * 在以下使用cpu_synchronize_all_post_init():
+     *   - hw/core/machine.c|1732| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|2368| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3346| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3363| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+     */
     cpu_synchronize_all_post_init();
     return 0;
 }
@@ -3258,6 +3629,13 @@ bool qemu_loadvm_load_state_buffer(const char *idstr, uint32_t instance_id,
     return se->ops->load_state_buffer(se->opaque, buf, len, errp);
 }
 
+/*
+ * 在以下使用save_snapshot():
+ *   - migration/migration-hmp-cmds.c|463| <<hmp_savevm>> save_snapshot(qdict_get_try_str(qdict, "name"),
+ *   - migration/savevm.c|3629| <<snapshot_save_job_bh>> s->ret = save_snapshot(s->tag, false, s->vmstate,
+ *   - replay/replay-debugging.c|325| <<replay_gdb_attached>> if (!save_snapshot("start_debugging", true, NULL, false, NULL, NULL)) {
+ *   - replay/replay-snapshot.c|79| <<replay_vmstate_init>> if (!save_snapshot(replay_snapshot,
+ */
 bool save_snapshot(const char *name, bool overwrite, const char *vmstate,
                   bool has_devices, strList *devices, Error **errp)
 {
@@ -3512,6 +3890,12 @@ bool load_snapshot(const char *name, const char *vmstate,
         ret = -EINVAL;
         goto err_drain;
     }
+    /*
+     * 在以下使用qemu_loadvm_state():
+     *   - migration/migration.c|908| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file);
+     *   - migration/savevm.c|3581| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f);
+     *   - migration/savevm.c|3655| <<load_snapshot>> ret = qemu_loadvm_state(f);
+     */
     ret = qemu_loadvm_state(f);
     migration_incoming_state_destroy();
 
diff --git a/migration/savevm.h b/migration/savevm.h
index 2d5e9c716..c22efcf57 100644
--- a/migration/savevm.h
+++ b/migration/savevm.h
@@ -18,6 +18,14 @@
 #define QEMU_VM_FILE_VERSION_COMPAT  0x00000002
 #define QEMU_VM_FILE_VERSION         0x00000003
 
+/*
+ * 非test使用QEMU_VM_EOF的地方:
+ *   - migration/savevm.c|1571| <<qemu_savevm_state_complete_postcopy>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|1752| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|1961| <<qemu_savevm_live_state>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|2005| <<qemu_save_device_state>> qemu_put_byte(f, QEMU_VM_EOF);
+ *   - migration/savevm.c|3209| <<qemu_loadvm_state_main>> case QEMU_VM_EOF:
+ */
 #define QEMU_VM_EOF                  0x00
 #define QEMU_VM_SECTION_START        0x01
 #define QEMU_VM_SECTION_PART         0x02
diff --git a/migration/socket.c b/migration/socket.c
index 5ec65b8c0..0b6253522 100644
--- a/migration/socket.c
+++ b/migration/socket.c
@@ -77,6 +77,14 @@ static void socket_outgoing_migration(QIOTask *task,
     }
 
 out:
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(data->s, sioc, data->hostname, err);
     object_unref(OBJECT(sioc));
 }
diff --git a/migration/tls.c b/migration/tls.c
index 284a6194b..6c90428a6 100644
--- a/migration/tls.c
+++ b/migration/tls.c
@@ -114,6 +114,14 @@ static void migration_tls_outgoing_handshake(QIOTask *task,
     } else {
         trace_migration_tls_outgoing_handshake_complete();
     }
+    /*
+     * 在以下使用migration_channel_connect():
+     *   - migration/exec.c|58| <<exec_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/fd.c|73| <<fd_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/file.c|125| <<file_start_outgoing_migration>> migration_channel_connect(s, ioc, NULL, NULL);
+     *   - migration/socket.c|80| <<socket_outgoing_migration>> migration_channel_connect(data->s, sioc, data->hostname, err);
+     *   - migration/tls.c|117| <<migration_tls_outgoing_handshake>> migration_channel_connect(s, ioc, NULL, err);
+     */
     migration_channel_connect(s, ioc, NULL, err);
     object_unref(OBJECT(ioc));
 }
diff --git a/monitor/qmp-cmds.c b/monitor/qmp-cmds.c
index 1ca44fbd7..4a1cb301a 100644
--- a/monitor/qmp-cmds.c
+++ b/monitor/qmp-cmds.c
@@ -109,6 +109,23 @@ void qmp_cont(Error **errp)
             error_propagate(errp, local_err);
             return;
         }
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|793| <<vm_resume>> vm_start();
+	 */
         vm_start();
     }
 }
diff --git a/net/slirp.c b/net/slirp.c
index 9657e86a8..fdeee85f3 100644
--- a/net/slirp.c
+++ b/net/slirp.c
@@ -669,6 +669,17 @@ static int net_slirp_init(NetClientState *peer, const char *model,
      * specific version?
      */
     g_assert(slirp_state_version() == 4);
+    /*
+     * 在以下使用register_savevm_live():
+     *   - hw/ppc/spapr.c|3103| <<spapr_machine_init>> register_savevm_live("spapr/htab", VMSTATE_INSTANCE_ID_ANY, 1,
+     *   - hw/s390x/s390-skeys.c|465| <<s390_skeys_realize>> register_savevm_live(TYPE_S390_SKEYS, 0, 1, &savevm_s390_storage_keys, ss);
+     *   - hw/s390x/s390-stattrib.c|359| <<s390_stattrib_realize>> register_savevm_live(TYPE_S390_STATTRIB, 0, 0,
+     *   - hw/s390x/tod.c|111| <<s390_tod_realize>> register_savevm_live("todclock", 0, 1, &savevm_tod, td);
+     *   - hw/vfio/migration.c|1020| <<vfio_migration_init>> register_savevm_live(id, VMSTATE_INSTANCE_ID_ANY, 1, &savevm_vfio_handlers,
+     *   - migration/block-dirty-bitmap.c|1267| <<dirty_bitmap_mig_init>> register_savevm_live("dirty-bitmap", 0, 1,
+     *   - migration/ram.c|4641| <<ram_mig_init>> register_savevm_live("ram", 0, 4, &savevm_ram_handlers, &ram_state);
+     *   - net/slirp.c|672| <<net_slirp_init>> register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
+     */
     register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
                          slirp_state_version(), &savevm_slirp_state, s->slirp);
 
diff --git a/net/tap-linux.c b/net/tap-linux.c
index 22ec2f45d..7e8ff687b 100644
--- a/net/tap-linux.c
+++ b/net/tap-linux.c
@@ -37,6 +37,10 @@
 
 #define PATH_NET_TUN "/dev/net/tun"
 
+/*
+ * 在以下使用tap_open():
+ *   - net/tap.c|661| <<net_tap_init>> fd = RETRY_ON_EINTR(tap_open(ifname, ifname_sz, vnet_hdr, vnet_hdr_required,
+ */
 int tap_open(char *ifname, int ifname_size, int *vnet_hdr,
              int vnet_hdr_required, int mq_required, Error **errp)
 {
@@ -279,6 +283,10 @@ void tap_fd_set_offload(int fd, int csum, int tso4,
     }
 }
 
+/*
+ * 在以下使用tap_fd_enable():
+ *   - net/tap.c|1032| <<tap_enable>> ret = tap_fd_enable(s->fd);
+ */
 /* Enable a specific queue of tap. */
 int tap_fd_enable(int fd)
 {
@@ -297,6 +305,10 @@ int tap_fd_enable(int fd)
     return ret;
 }
 
+/*
+ * 在以下使用tap_fd_disable():
+ *   - net/tap.c|1049| <<tap_disable>> ret = tap_fd_disable(s->fd);
+ */
 /* Disable a specific queue of tap/ */
 int tap_fd_disable(int fd)
 {
diff --git a/net/tap.c b/net/tap.c
index f7df702f9..87bac19e6 100644
--- a/net/tap.c
+++ b/net/tap.c
@@ -643,6 +643,10 @@ int net_init_bridge(const Netdev *netdev, const char *name,
     return 0;
 }
 
+/*
+ * 在以下使用net_tap_init():
+ *   - net/tap.c|995| <<net_init_tap>> fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? "no" : script,
+ */
 static int net_tap_init(const NetdevTapOptions *tap, int *vnet_hdr,
                         const char *setup_script, char *ifname,
                         size_t ifname_sz, int mq_required, Error **errp)
@@ -1021,6 +1025,10 @@ free_fail:
     return 0;
 }
 
+/*
+ * 在以下使用tap_enable():
+ *   - hw/net/virtio-net.c|713| <<peer_attach>> return tap_enable(nc->peer);
+ */
 int tap_enable(NetClientState *nc)
 {
     TAPState *s = DO_UPCAST(TAPState, nc, nc);
@@ -1038,6 +1046,10 @@ int tap_enable(NetClientState *nc)
     }
 }
 
+/*
+ * 在以下使用tap_disable():
+ *   - hw/net/virtio-net.c|734| <<peer_detach>> return tap_disable(nc->peer);
+ */
 int tap_disable(NetClientState *nc)
 {
     TAPState *s = DO_UPCAST(TAPState, nc, nc);
diff --git a/system/cpus.c b/system/cpus.c
index 256723558..3bb4ec65c 100644
--- a/system/cpus.c
+++ b/system/cpus.c
@@ -131,6 +131,16 @@ void hw_error(const char *fmt, ...)
     abort();
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_states():
+ *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+ *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+ *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+ *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+ *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+ *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+ *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+ */
 void cpu_synchronize_all_states(void)
 {
     CPUState *cpu;
@@ -149,6 +159,24 @@ void cpu_synchronize_all_post_reset(void)
     }
 }
 
+/*
+ * 迁移后在Target:
+ * (gdb) bt
+ * #0  cpu_synchronize_all_post_init () at ../system/cpus.c:153
+ * #1  0x0000555555c7e7b2 in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3206
+ * #2  0x0000555555c600fa in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:891
+ * #3  0x0000555556174e10 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #4  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #5  0x00007fffffffc7e0 in ?? ()
+ * #6  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用cpu_synchronize_all_post_init():
+ *   - hw/core/machine.c|1732| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|2368| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3346| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3363| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+ */
 void cpu_synchronize_all_post_init(void)
 {
     CPUState *cpu;
@@ -158,6 +186,10 @@ void cpu_synchronize_all_post_init(void)
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_pre_loadvm():
+ *   - migration/savevm.c|3454| <<qemu_loadvm_state>> cpu_synchronize_all_pre_loadvm();
+ */
 void cpu_synchronize_all_pre_loadvm(void)
 {
     CPUState *cpu;
@@ -181,15 +213,66 @@ void cpu_synchronize_post_reset(CPUState *cpu)
     }
 }
 
+/*
+ * 多个vCPU
+ * (gdb) bt
+ * #0  cpu_synchronize_post_init (cpu=0x5555578f8060) at ../system/cpus.c:186
+ * #1  0x0000555555c08773 in cpu_synchronize_all_post_init () at ../system/cpus.c:157
+ * #2  0x0000555555c7e70e in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3199
+ * #3  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #4  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #5  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #6  0x00007fffffffc7e0 in ?? ()
+ * #7  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用cpu_synchronize_post_init():
+ *   - hw/core/cpu-common.c|266| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+ *   - system/cpus.c|167| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+ *   - target/s390x/gdbstub.c|92| <<cpu_write_ac_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|210| <<cpu_write_c_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|250| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|254| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|258| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|262| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|302| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|306| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|310| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|314| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|342| <<cpu_write_gs_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/sigp.c|295| <<sigp_set_prefix>> cpu_synchronize_post_init(cs);
+ */
 void cpu_synchronize_post_init(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|96| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     if (cpus_accel->synchronize_post_init) {
         cpus_accel->synchronize_post_init(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_pre_loadvm():
+ *   - system/cpus.c|183| <<cpu_synchronize_all_pre_loadvm>> cpu_synchronize_pre_loadvm(cpu);
+ */
 void cpu_synchronize_pre_loadvm(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_pre_loadvm():
+     *   - accel/hvf/hvf-accel-ops.c|383| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+     *   - system/cpus.c|248| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+     *   - system/cpus.c|249| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+     *   - target/i386/whpx/whpx-accel-ops.c|98| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+     */
     if (cpus_accel->synchronize_pre_loadvm) {
         cpus_accel->synchronize_pre_loadvm(cpu);
     }
@@ -285,6 +368,26 @@ bool vm_get_suspended(void)
     return vm_was_suspended;
 }
 
+/*
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:232
+ * #1  0x0000555555c08b8c in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:295
+ * #2  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #3  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #4  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #5  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用do_vm_stop():
+ *   - system/cpus.c|322| <<vm_shutdown>> return do_vm_stop(RUN_STATE_SHUTDOWN, false);
+ *   - system/cpus.c|737| <<vm_stop>> return do_vm_stop(state, true);
+ */
 static int do_vm_stop(RunState state, bool send_stop)
 {
     int ret = 0;
@@ -297,6 +400,11 @@ static int do_vm_stop(RunState state, bool send_stop)
         if (oldstate == RUN_STATE_RUNNING) {
             pause_all_vcpus();
         }
+        /*
+	 * 在以下使用vm_state_notify():
+	 *   - system/cpus.c|300| <<do_vm_stop>> ret = vm_state_notify(0, state);
+	 *   - system/cpus.c|778| <<vm_prepare_start>> vm_state_notify(1, state);
+	 */
         ret = vm_state_notify(0, state);
         if (send_stop) {
             qapi_event_send_stop();
@@ -319,6 +427,11 @@ static int do_vm_stop(RunState state, bool send_stop)
  */
 int vm_shutdown(void)
 {
+    /*
+     * 在以下使用do_vm_stop():
+     *   - system/cpus.c|322| <<vm_shutdown>> return do_vm_stop(RUN_STATE_SHUTDOWN, false);
+     *   - system/cpus.c|737| <<vm_stop>> return do_vm_stop(state, true);
+     */
     return do_vm_stop(RUN_STATE_SHUTDOWN, false);
 }
 
@@ -622,6 +735,14 @@ static bool all_vcpus_paused(void)
     return true;
 }
 
+/*
+ * 在以下使用pause_all_vcpus():
+ *   - hw/i386/vapic.c|688| <<vapic_write>> pause_all_vcpus();
+ *   - system/cpus.c|390| <<do_vm_stop>> pause_all_vcpus();
+ *   - system/runstate.c|778| <<qemu_system_suspend>> pause_all_vcpus();
+ *   - system/runstate.c|938| <<main_loop_should_exit>> pause_all_vcpus();
+ *   - system/runstate.c|952| <<main_loop_should_exit>> pause_all_vcpus();
+ */
 void pause_all_vcpus(void)
 {
     CPUState *cpu;
@@ -721,6 +842,36 @@ void cpu_stop_current(void)
     }
 }
 
+/*
+ * 在以下使用vm_stop():
+ *   - accel/kvm/kvm-all.c|2923| <<do_kvm_cpu_synchronize_state>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - accel/kvm/kvm-all.c|2949| <<do_kvm_cpu_synchronize_post_reset>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - accel/kvm/kvm-all.c|3346| <<kvm_cpu_exec>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - dump/dump.c|1802| <<dump_init>> vm_stop(RUN_STATE_SAVE_VM);
+ *   - gdbstub/gdbstub.c|2364| <<gdb_read_byte>> vm_stop(RUN_STATE_PAUSED);
+ *   - gdbstub/system.c|102| <<gdb_chr_event>> vm_stop(RUN_STATE_PAUSED);
+ *   - gdbstub/system.c|120| <<gdb_syscall_handling>> vm_stop(RUN_STATE_DEBUG);
+ *   - gdbstub/system.c|228| <<gdb_sigterm_handler>> vm_stop(RUN_STATE_PAUSED);
+ *   - hw/ppc/prep_systemio.c|78| <<prep_port0092_write>> vm_stop(RUN_STATE_PAUSED);
+ *   - hw/ppc/vof.c|921| <<vof_client_handle>> vm_stop(RUN_STATE_PAUSED);
+ *   - hw/vfio/pci.c|3040| <<vfio_err_notifier_handler>> vm_stop(RUN_STATE_INTERNAL_ERROR);
+ *   - migration/migration-hmp-cmds.c|450| <<hmp_loadvm>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - migration/savevm.c|3315| <<save_snapshot>> vm_stop(RUN_STATE_SAVE_VM);
+ *   - migration/savevm.c|3386| <<qmp_xen_save_devices_state>> vm_stop(RUN_STATE_SAVE_VM);
+ *   - migration/savevm.c|3431| <<qmp_xen_load_devices_state>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - migration/savevm.c|3610| <<snapshot_load_job_bh>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - monitor/qmp-cmds.c|62| <<qmp_stop>> vm_stop(RUN_STATE_PAUSED);
+ *   - replay/replay-debugging.c|88| <<replay_stop_vm>> vm_stop(RUN_STATE_PAUSED);
+ *   - replay/replay-debugging.c|193| <<replay_seek>> vm_stop(RUN_STATE_RESTORE_VM);
+ *   - replay/replay-debugging.c|226| <<replay_stop_vm_debug>> vm_stop(RUN_STATE_DEBUG);
+ *   - replay/replay-debugging.c|253| <<replay_continue_end>> vm_stop(RUN_STATE_DEBUG);
+ *   - system/cpus.c|804| <<vm_stop_force_state>> return vm_stop(state);
+ *   - system/runstate.c|636| <<qemu_system_guest_panicked>> vm_stop(RUN_STATE_GUEST_PANICKED);
+ *   - system/runstate.c|640| <<qemu_system_guest_panicked>> vm_stop(RUN_STATE_GUEST_PANICKED);
+ *   - system/runstate.c|847| <<main_loop_should_exit>> vm_stop(RUN_STATE_DEBUG);
+ *   - system/runstate.c|857| <<main_loop_should_exit>> vm_stop(RUN_STATE_SHUTDOWN);
+ *   - system/runstate.c|895| <<main_loop_should_exit>> vm_stop(r);
+ */
 int vm_stop(RunState state)
 {
     if (qemu_in_vcpu_thread()) {
@@ -734,6 +885,11 @@ int vm_stop(RunState state)
         return 0;
     }
 
+    /*
+     * 在以下使用do_vm_stop():
+     *   - system/cpus.c|322| <<vm_shutdown>> return do_vm_stop(RUN_STATE_SHUTDOWN, false);
+     *   - system/cpus.c|737| <<vm_stop>> return do_vm_stop(state, true);
+     */
     return do_vm_stop(state, true);
 }
 
@@ -742,6 +898,11 @@ int vm_stop(RunState state)
  * Returns 0 if the vCPUs should be restarted, -1 on an error condition,
  * and 1 otherwise.
  */
+/*
+ * 在以下使用vm_prepare_start():
+ *   - gdbstub/system.c|578| <<gdb_continue_partial>> if (vm_prepare_start(step_requested)) {
+ *   - system/cpus.c|785| <<vm_start>> if (!vm_prepare_start(false)) {
+ */
 int vm_prepare_start(bool step_pending)
 {
     int ret = vm_was_suspended ? 1 : 0;
@@ -775,11 +936,52 @@ int vm_prepare_start(bool step_pending)
 
     cpu_enable_ticks();
     runstate_set(state);
+    /*
+     * 在以下使用vm_state_notify():
+     *   - system/cpus.c|300| <<do_vm_stop>> ret = vm_state_notify(0, state);
+     *   - system/cpus.c|778| <<vm_prepare_start>> vm_state_notify(1, state);
+     */
     vm_state_notify(1, state);
     vm_was_suspended = false;
     return ret;
 }
 
+/*
+ * 迁移后在target.
+ * (gdb) bt
+ * #0  vm_start () at ../system/cpus.c:785
+ * #1  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #2  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x5555582b37e0) at ../migration/migration.c:361
+ * #3  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #4  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #5  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #6  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #7  0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #8  g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #9  0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #10 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #11 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #12 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #13 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #14 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用vm_start():
+ *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+ *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+ *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+ *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+ *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+ *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+ *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+ *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+ *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+ *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+ *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+ *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+ *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+ *   - system/cpus.c|793| <<vm_resume>> vm_start();
+ */
 void vm_start(void)
 {
     if (!vm_prepare_start(false)) {
@@ -790,12 +992,96 @@ void vm_start(void)
 void vm_resume(RunState state)
 {
     if (runstate_is_live(state)) {
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|556| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|515| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|574| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|767| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/migration.c|845| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|852| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3535| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2255| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3414| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|793| <<vm_resume>> vm_start();
+	 */
         vm_start();
     } else {
         runstate_set(state);
     }
 }
 
+/*
+ * 迁移的时候在Source上的调用:
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 迁移的时候在Target上的调用:
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ * 从QEMU cmdline quit的时候:
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_SHUTDOWN) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f20 in vm_state_notify (running=false, state=RUN_STATE_SHUTDOWN) at ../system/runstate.c:392
+ * #2  0x0000555555c08bba in do_vm_stop (state=RUN_STATE_SHUTDOWN, send_stop=false) at ../system/cpus.c:302
+ * #3  0x0000555555c08bfb in vm_shutdown () at ../system/cpus.c:324
+ * #4  0x0000555555c38ef8 in qemu_cleanup (status=0) at ../system/runstate.c:981
+ * #5  0x0000555556082acb in qemu_default_main (opaque=0x0) at ../system/main.c:51
+ * #6  0x0000555556082b78 in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用vm_stop_force_state():
+ *   - migration/colo.c|216| <<colo_do_failover>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/colo.c|432| <<colo_do_checkpoint_transaction>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/colo.c|668| <<colo_incoming_process_checkpoint>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/migration.c|306| <<migration_stop_vm>> ret = vm_stop_force_state(state);
+ */
 /* does a state transition even if the VM is already stopped,
    current state is forgotten forever */
 int vm_stop_force_state(RunState state)
diff --git a/system/runstate.c b/system/runstate.c
index 6178b0091..4e984f7d6 100644
--- a/system/runstate.c
+++ b/system/runstate.c
@@ -64,6 +64,17 @@
 static NotifierList exit_notifiers =
     NOTIFIER_LIST_INITIALIZER(exit_notifiers);
 
+/*
+ * 在以下使用current_run_state:
+ *   - system/runstate.c|195| <<runstate_check>> return current_run_state == state;
+ *   - system/runstate.c|234| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+ *   - system/runstate.c|237| <<runstate_set>> if (current_run_state == new_state) {
+ *   - system/runstate.c|241| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+ *   - system/runstate.c|243| <<runstate_set>> RunState_str(current_run_state),
+ *   - system/runstate.c|248| <<runstate_set>> current_run_state = new_state;
+ *   - system/runstate.c|253| <<runstate_get>> return current_run_state;
+ *   - system/runstate.c|272| <<qmp_query_status>> info->status = current_run_state;
+ */
 static RunState current_run_state = RUN_STATE_PRELAUNCH;
 
 /* We use RUN_STATE__MAX but any invalid value will do */
@@ -226,6 +237,31 @@ static void runstate_init(void)
     qemu_mutex_init(&vmstop_lock);
 }
 
+/*
+ * 迁移的时候在Source上
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:232
+ * #1  0x0000555555c08b8c in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:295
+ * #2  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #3  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #4  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #5  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x555558309590) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在Source上结束的时候
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_POSTMIGRATE) at ../system/runstate.c:232
+ * #1  0x0000555555c65e7b in migration_iteration_finish (s=0x5555575e27f0) at ../migration/migration.c:3518
+ * #2  0x0000555555c66522 in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3797
+ * #3  0x0000555556155700 in qemu_thread_start (args=0x555558309590) at ../util/qemu-thread-posix.c:393
+ * #4  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #5  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 /* This function will abort() on invalid state transitions */
 void runstate_set(RunState new_state)
 {
@@ -253,6 +289,9 @@ RunState runstate_get(void)
     return current_run_state;
 }
 
+/*
+ * 很多的调用
+ */
 bool runstate_is_running(void)
 {
     return runstate_check(RUN_STATE_RUNNING);
@@ -268,7 +307,21 @@ StatusInfo *qmp_query_status(Error **errp)
 {
     StatusInfo *info = g_malloc0(sizeof(*info));
 
+    /*
+     * 检查是不是RUN_STATE_RUNNING
+     */
     info->running = runstate_is_running();
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|195| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|234| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|237| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|241| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|243| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|248| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|253| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|272| <<qmp_query_status>> info->status = current_run_state;
+     */
     info->status = current_run_state;
 
     return info;
@@ -353,6 +406,11 @@ void qemu_del_vm_change_state_handler(VMChangeStateEntry *e)
     g_free(e);
 }
 
+/*
+ * 在以下使用vm_state_notify():
+ *   - system/cpus.c|300| <<do_vm_stop>> ret = vm_state_notify(0, state);
+ *   - system/cpus.c|778| <<vm_prepare_start>> vm_state_notify(1, state);
+ */
 int vm_state_notify(bool running, RunState state)
 {
     VMChangeStateEntry *e, *next;
@@ -513,6 +571,16 @@ void qemu_system_reset(ShutdownCause reason)
 
     mc = current_machine ? MACHINE_GET_CLASS(current_machine) : NULL;
 
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
 
     switch (reason) {
diff --git a/target/arm/hvf/hvf.c b/target/arm/hvf/hvf.c
index 47b0cd3a3..7244f16f7 100644
--- a/target/arm/hvf/hvf.c
+++ b/target/arm/hvf/hvf.c
@@ -2151,6 +2151,16 @@ static void hvf_vm_state_change(void *opaque, bool running, RunState state)
     if (running) {
         /* Update vtimer offset on all CPUs */
         hvf_state->vtimer_offset = mach_absolute_time() - s->vtimer_val;
+        /*
+	 * 在以下使用cpu_synchronize_all_states():
+         *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+         *   - hw/i386/pc.c|1715| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+         *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+         *   - migration/savevm.c|1665| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+         *   - migration/savevm.c|1884| <<qemu_save_device_state>> cpu_synchronize_all_states();
+         *   - system/runstate.c|574| <<qemu_system_reset>> cpu_synchronize_all_states();
+         *   - target/arm/hvf/hvf.c|2154| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+	 */
         cpu_synchronize_all_states();
     } else {
         /* Remember vtimer value on every pause */
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index f977fc49a..f8ee38e0a 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -2100,6 +2100,17 @@ typedef struct CPUArchState {
     uint8_t triple_fault_pending;
     uint32_t ins_len;
     uint32_t sipi_vector;
+    /*
+     * 在以下使用CPUX86State->tsc_valid:
+     *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     bool tsc_valid;
     int64_t tsc_khz;
     int64_t user_tsc_khz; /* for sanity check only */
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 369626f8c..92ced8189 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -297,6 +297,22 @@ bool kvm_hv_vpindex_settable(void)
     return hv_vpindex_settable;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_get_tsc (cs=0x5555578c30f0) at ../target/i386/kvm/kvm.c:301
+ * #1  0x0000555555d9c4e7 in do_kvm_synchronize_tsc (cpu=0x5555578c30f0, arg=...) at ../target/i386/kvm/kvm.c:324
+ * #2  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c30f0) at ../cpu-common.c:374
+ * #3  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c30f0) at ../system/cpus.c:453
+ * #4  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c30f0) at ../system/cpus.c:471
+ * #5  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c30f0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #6  0x0000555556155700 in qemu_thread_start (args=0x5555578cd750) at ../util/qemu-thread-posix.c:393
+ * #7  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #8  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用kvm_get_tsc():
+ *   - target/i386/kvm/kvm.c|324| <<do_kvm_synchronize_tsc>> kvm_get_tsc(cpu);
+ */
 static int kvm_get_tsc(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -304,6 +320,17 @@ static int kvm_get_tsc(CPUState *cs)
     uint64_t value;
     int ret;
 
+    /*
+     * 在以下使用CPUX86State->tsc_valid:
+     *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     if (env->tsc_valid) {
         return 0;
     }
@@ -324,6 +351,10 @@ static inline void do_kvm_synchronize_tsc(CPUState *cpu, run_on_cpu_data arg)
     kvm_get_tsc(cpu);
 }
 
+/*
+ * 在以下使用kvm_synchronize_all_tsc():
+ *   - hw/i386/kvm/clock.c|431| <<kvmclock_vm_state_change>> kvm_synchronize_all_tsc();
+ */
 void kvm_synchronize_all_tsc(void)
 {
     CPUState *cpu;
@@ -830,6 +861,17 @@ static void cpu_update_state(void *opaque, bool running, RunState state)
     CPUX86State *env = opaque;
 
     if (running) {
+        /*
+	 * 在以下使用CPUX86State->tsc_valid:
+         *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+         *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+         *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+         *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+         *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+	 */
         env->tsc_valid = false;
     }
 }
@@ -867,6 +909,11 @@ static inline bool freq_within_bounds(int freq, int target_freq)
         return false;
 }
 
+/*
+ * 在以下使用kvm_arch_set_tsc_khz():
+ *   - target/i386/kvm/kvm.c|2156| <<kvm_arch_init_vcpu>> r = kvm_arch_set_tsc_khz(cs);
+ *   - target/i386/kvm/kvm.c|5390| <<kvm_arch_put_registers>> kvm_arch_set_tsc_khz(cpu);
+ */
 static int kvm_arch_set_tsc_khz(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -3907,6 +3954,10 @@ static void kvm_init_msrs(X86CPU *cpu)
     assert(kvm_buf_set_msrs(cpu) == 0);
 }
 
+/*
+ * 在以下使用kvm_put_msrs():
+ *   - target/i386/kvm/kvm.c|5408| <<kvm_arch_put_registers>> ret = kvm_put_msrs(x86_cpu, level);
+ */
 static int kvm_put_msrs(X86CPU *cpu, int level)
 {
     CPUX86State *env = &cpu->env;
@@ -4383,6 +4434,19 @@ static int kvm_get_sregs2(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_get_msrs (cpu=0x5555578c30f0) at ../target/i386/kvm/kvm.c:4387
+ * #1  0x0000555555dab277 in kvm_arch_get_registers (cs=0x5555578c30f0, errp=0x7fffedb02580) at ../target/i386/kvm/kvm.c:5414
+ * #2  0x0000555555f24545 in do_kvm_cpu_synchronize_state (cpu=0x5555578c30f0, arg=...) at ../accel/kvm/kvm-all.c:2914
+ * #3  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c30f0) at ../cpu-common.c:374
+ * #4  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c30f0) at ../system/cpus.c:453
+ * #5  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c30f0) at ../system/cpus.c:471
+ * #6  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c30f0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #7  0x0000555556155700 in qemu_thread_start (args=0x5555578cd750) at ../util/qemu-thread-posix.c:393
+ * #8  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #9  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 static int kvm_get_msrs(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -4448,6 +4512,17 @@ static int kvm_get_msrs(X86CPU *cpu)
     if (has_msr_virt_ssbd) {
         kvm_msr_entry_add(cpu, MSR_VIRT_SSBD, 0);
     }
+    /*
+     * 在以下使用CPUX86State->tsc_valid:
+     *   - target/i386/kvm/kvm.c|323| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|327| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|853| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4484| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4486| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2127| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     if (!env->tsc_valid) {
         kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);
         env->tsc_valid = !runstate_is_running();
@@ -5270,6 +5345,12 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * 在以下使用kvm_arch_put_registers():
+ *   - accel/kvm/kvm-all.c|2959| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+ *   - accel/kvm/kvm-all.c|2990| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+ *   - accel/kvm/kvm-all.c|3221| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+ */
 int kvm_arch_put_registers(CPUState *cpu, int level, Error **errp)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
diff --git a/target/i386/kvm/xen-emu.c b/target/i386/kvm/xen-emu.c
index 284c5ef6f..63f27e399 100644
--- a/target/i386/kvm/xen-emu.c
+++ b/target/i386/kvm/xen-emu.c
@@ -980,6 +980,10 @@ static int vcpuop_register_runstate_info(CPUState *cs, CPUState *target,
     return 0;
 }
 
+/*
+ * 只给xen使用:
+ *   - target/i386/kvm/xen-emu.c|1093| <<do_set_singleshot_timer>> int64_t now = kvm_get_current_ns();
+ */
 static uint64_t kvm_get_current_ns(void)
 {
     struct kvm_clock_data data;
-- 
2.39.5 (Apple Git-154)

