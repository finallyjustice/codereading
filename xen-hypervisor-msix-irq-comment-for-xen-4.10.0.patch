From 393544807e18ef2ed3e3a161e73907d5152c3cb3 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 25 Mar 2019 00:22:36 +0800
Subject: [PATCH 1/1] xen hypervisor msix irq comment for xen-4.10.0

xen-4.10.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 xen/arch/x86/io_apic.c | 20 ++++++++++++++++++++
 xen/arch/x86/irq.c     | 23 +++++++++++++++++++++++
 xen/arch/x86/physdev.c | 17 +++++++++++++++++
 3 files changed, 60 insertions(+)

diff --git a/xen/arch/x86/io_apic.c b/xen/arch/x86/io_apic.c
index f959090..71864a8 100644
--- a/xen/arch/x86/io_apic.c
+++ b/xen/arch/x86/io_apic.c
@@ -2522,6 +2522,12 @@ void __init init_ioapic_mappings(void)
     unsigned int i, idx = FIX_IO_APIC_BASE_0;
     union IO_APIC_reg_01 reg_01;
 
+    /*
+     * 在desktop上:
+     *   smp_found_config = true
+     *   nr_ioapics = 1
+     */
+
     if ( smp_found_config )
         nr_irqs_gsi = 0;
     for ( i = 0; i < nr_ioapics; i++ )
@@ -2560,6 +2566,9 @@ void __init init_ioapic_mappings(void)
             /* The number of IO-APIC IRQ registers (== #pins): */
             reg_01.raw = io_apic_read(i, 1);
             nr_ioapic_entries[i] = reg_01.bits.entries + 1;
+	    /*
+	     * nr_irqs_gsi上面设置的开始是0, nr_ioapic_entries[i]是120
+	     */
             nr_irqs_gsi += nr_ioapic_entries[i];
 
             if ( rangeset_add_singleton(mmio_ro_ranges,
@@ -2569,8 +2578,16 @@ void __init init_ioapic_mappings(void)
         }
     }
 
+    /*
+     * highest_gsi()是119
+     */
     nr_irqs_gsi = max(nr_irqs_gsi, highest_gsi() + 1);
 
+    /*
+     * max_gsi_irqs是0
+     *
+     * 因为nr_irqs默认是0, max_gsi_irqs=4096
+     */
     if ( max_gsi_irqs == 0 )
         max_gsi_irqs = nr_irqs ? nr_irqs / 8 : PAGE_SIZE;
     else if ( nr_irqs != 0 && max_gsi_irqs > nr_irqs )
@@ -2595,6 +2612,9 @@ void __init init_ioapic_mappings(void)
         nr_irqs_gsi = max_gsi_irqs;
     }
 
+    /*
+     * 在desktop上默认nr_irqs在这里是0
+     */
     if ( nr_irqs == 0 )
         nr_irqs = cpu_has_apic ?
                   max(16U + num_present_cpus() * NR_DYNAMIC_VECTORS,
diff --git a/xen/arch/x86/irq.c b/xen/arch/x86/irq.c
index c0ab299..b785cba 100644
--- a/xen/arch/x86/irq.c
+++ b/xen/arch/x86/irq.c
@@ -157,11 +157,28 @@ int __init bind_irq_vector(int irq, int vector, const cpumask_t *cpu_mask)
 /*
  * Dynamic irq allocate and deallocation for MSI
  */
+/*
+ * called by:
+ *   - arch/x86/hpet.c|376| <<hpet_assign_irq>> if ( (irq = create_irq(NUMA_NO_NODE)) < 0 )
+ *   - arch/x86/irq.c|2036| <<map_domain_pirq>> irq = create_irq(NUMA_NO_NODE);
+ *   - arch/x86/irq.c|2673| <<allocate_and_map_msi_pirq>> irq = create_irq(NUMA_NO_NODE);
+ *   - drivers/passthrough/amd/iommu_init.c|783| <<set_iommu_interrupt_handler>> irq = create_irq(NUMA_NO_NODE);
+ *   - drivers/passthrough/vtd/iommu.c|1130| <<iommu_set_interrupt>> irq = create_irq(rhsa ? pxm_to_node(rhsa->proximity_domain)
+ */
 int create_irq(nodeid_t node)
 {
     int irq, ret;
     struct irq_desc *desc;
 
+    /*
+     * 在desktop默认:
+     * (XEN) IRQ limits: 120 GSI, 1432 MSI/MSI-X
+     * nr_irqs_gsi = 120, nr_irqs = 1552
+     *
+     * 设置nr_irqs=4096后:
+     * (XEN) IRQ limits: 120 GSI, 3976 MSI/MSI-X
+     */
+
     for (irq = nr_irqs_gsi; irq < nr_irqs; irq++)
     {
         desc = irq_to_desc(irq);
@@ -169,6 +186,7 @@ int create_irq(nodeid_t node)
            break;
     }
 
+    /* 上面也间接设置了返回值irq */
     if (irq >= nr_irqs)
          return -ENOSPC;
 
@@ -188,6 +206,7 @@ int create_irq(nodeid_t node)
     if (ret < 0)
     {
         desc->arch.used = IRQ_UNUSED;
+	/* 设置返回值irq的地方 */
         irq = ret;
     }
     else if ( hardware_domain )
@@ -2656,6 +2675,10 @@ int allocate_and_map_gsi_pirq(struct domain *d, int index, int *pirq_p)
     return ret;
 }
 
+/*
+ * called by only:
+ *   - arch/x86/physdev.c|129| <<physdev_map_pirq>> ret = allocate_and_map_msi_pirq(d, *index, pirq_p, type, msi);
+ */
 int allocate_and_map_msi_pirq(struct domain *d, int index, int *pirq_p,
                               int type, struct msi_info *msi)
 {
diff --git a/xen/arch/x86/physdev.c b/xen/arch/x86/physdev.c
index a5fedca..3ab6973 100644
--- a/xen/arch/x86/physdev.c
+++ b/xen/arch/x86/physdev.c
@@ -88,6 +88,12 @@ static int physdev_hvm_map_pirq(
     return ret;
 }
 
+/*
+ * called only by:
+ *   - arch/x86/physdev.c|335| <<XEN_GUEST_HANDLE_PARAM>> ret = physdev_map_pirq(map.domid, map.type, &map.index, &map.pirq,
+ *
+ * 从desktop nvme进来的时候猜测, type=MAP_PIRQ_TYPE_MSI, *index=-1
+ */
 int physdev_map_pirq(domid_t domid, int type, int *index, int *pirq_p,
                      struct msi_info *msi)
 {
@@ -126,6 +132,9 @@ int physdev_map_pirq(domid_t domid, int type, int *index, int *pirq_p,
             msi->entry_nr = 1;
         /* fallthrough */
     case MAP_PIRQ_TYPE_MULTI_MSI:
+        /*
+	 * 上面desktop的nvme进来, 猜测msi->entry_nr每次分别是0, 1, 2, 3, 4, 5, 6, 7
+         */
         ret = allocate_and_map_msi_pirq(d, *index, pirq_p, type, msi);
         break;
 
@@ -313,6 +322,9 @@ ret_t do_physdev_op(int cmd, XEN_GUEST_HANDLE_PARAM(void) arg)
 
         switch ( map.type )
         {
+        /*
+	 * 在desktop nvme上猜测这里应该是MAP_PIRQ_TYPE_MSI_SEG
+	 */
         case MAP_PIRQ_TYPE_MSI_SEG:
             map.type = MAP_PIRQ_TYPE_MSI;
             msi.seg = map.bus >> 16;
@@ -332,6 +344,11 @@ ret_t do_physdev_op(int cmd, XEN_GUEST_HANDLE_PARAM(void) arg)
         msi.devfn = map.devfn;
         msi.entry_nr = map.entry_nr;
         msi.table_base = map.table_base;
+        /*
+	 * 因为上面在desktop nvme上猜测应该是MAP_PIRQ_TYPE_MSI_SEG
+	 *
+	 * 所以上面把map.type换成了MAP_PIRQ_TYPE_MSI, msi.seg包含了seg的信息
+         */
         ret = physdev_map_pirq(map.domid, map.type, &map.index, &map.pirq,
                                &msi);
 
-- 
2.7.4

