From bcf65edecd2727d9653a08b6338d47bf143f6462 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 15 Mar 2021 09:22:03 -0700
Subject: [PATCH 1/1] qemu for 5.2.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 backends/hostmem-file.c         |  22 +++
 backends/hostmem.c              |  22 +++
 chardev/char-fe.c               |  20 +++
 chardev/char-socket.c           |  71 ++++++++
 hw/block/dataplane/virtio-blk.c |  29 +++
 hw/block/virtio-blk.c           |  73 ++++++++
 hw/net/vhost_net.c              |  16 ++
 hw/net/virtio-net.c             |  43 +++++
 hw/pci/pci.c                    |  11 ++
 hw/scsi/vhost-scsi-common.c     |   5 +
 hw/scsi/vhost-scsi.c            |  10 ++
 hw/scsi/virtio-scsi-dataplane.c |  25 +++
 hw/scsi/virtio-scsi.c           |  86 +++++++++
 hw/timer/hpet.c                 |  18 ++
 hw/vfio/common.c                | 201 +++++++++++++++++++++
 hw/vfio/pci.c                   |  75 ++++++++
 hw/virtio/vhost.c               |  19 ++
 hw/virtio/virtio-bus.c          | 157 +++++++++++++++++
 hw/virtio/virtio-pci.c          |  25 +++
 hw/virtio/virtio-scsi-pci.c     |   4 +
 hw/virtio/virtio.c              | 302 ++++++++++++++++++++++++++++++++
 include/hw/vfio/vfio-common.h   |  35 ++++
 include/hw/virtio/virtio-blk.h  |  24 +++
 include/hw/virtio/virtio-bus.h  |  27 +++
 include/hw/virtio/virtio-scsi.h |  51 ++++++
 include/hw/virtio/virtio.h      |  27 +++
 io/channel-socket.c             |   4 +
 io/channel.c                    |  14 ++
 linux-headers/linux/kvm.h       |   4 +
 monitor/misc.c                  |  97 ++++++++++
 monitor/monitor-internal.h      |  14 ++
 qapi/qmp-dispatch.c             |  12 ++
 softmmu/physmem.c               |   4 +
 target/i386/helper.c            |  10 ++
 target/i386/kvm.c               |   4 +
 util/event_notifier-posix.c     |  20 +++
 36 files changed, 1581 insertions(+)

diff --git a/backends/hostmem-file.c b/backends/hostmem-file.c
index 40e1e5b3e..480fec9d1 100644
--- a/backends/hostmem-file.c
+++ b/backends/hostmem-file.c
@@ -31,6 +31,28 @@ struct HostMemoryBackendFile {
     bool is_pmem;
 };
 
+/*
+ * (gdb) 
+ * #0  0x000055555584608e in file_backend_memory_alloc (backend=0x555556ab8850, errp=0x7fffffffdae0) at ../backends/hostmem-file.c:41
+ * #1  0x000055555580a70a in host_memory_backend_memory_complete (uc=0x555556ab8850, errp=0x7fffffffdb58) at ../backends/hostmem.c:333
+ * #2  0x0000555555d7e06a in user_creatable_complete (uc=0x555556ab8850, errp=0x7fffffffdbb8) at ../qom/object_interfaces.c:23
+ * #3  0x0000555555d7e35c in user_creatable_add_type (type=0x5555568c0380 "memory-backend-file", id=0x5555568c0310 "mem0", qdict=0x555556ae5390, v=
+ *     0x555556ac07c0, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:93
+ * #4  0x0000555555d7e714 in user_creatable_add_opts (opts=0x5555568c0330, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:163
+ * #5  0x0000555555d7e80f in user_creatable_add_opts_foreach
+ *     (opaque=0x555555ba6db7 <object_create_delayed>, opts=0x5555568c0330, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:186
+ * #6  0x0000555555e6d9a0 in qemu_opts_foreach
+ *     (list=0x5555567835c0 <qemu_object_opts>, func=0x555555d7e791 <user_creatable_add_opts_foreach>, opaque=0x555555ba6db7 <object_create_delayed>, errp=0x555556837f40 <error_fatal>)
+ *     at ../util/qemu-option.c:1156
+ * #7  0x0000555555baaf3a in qemu_init (argc=20, argv=0x7fffffffe028, envp=0x7fffffffe0d0) at ../softmmu/vl.c:4271
+ * #8  0x0000555555809b2d in main (argc=20, argv=0x7fffffffe028, envp=0x7fffffffe0d0) at ../softmmu/main.c:49
+ *
+ * 在以下使用file_backend_memory_alloc():
+ *   - backends/hostmem-file.c|172| <<file_backend_class_init>> bc->alloc = file_backend_memory_alloc;
+ *
+ * 分配失败会显示:
+ * qemu-system-x86_64: -object memory-backend-file,id=mem0,size=4000M,mem-path=/dev/hugepages_test,share=on: unable to map backing store for guest RAM: Cannot allocate memory
+ */
 static void
 file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
diff --git a/backends/hostmem.c b/backends/hostmem.c
index 4bde00e8e..c9c9b8862 100644
--- a/backends/hostmem.c
+++ b/backends/hostmem.c
@@ -320,6 +320,28 @@ size_t host_memory_backend_pagesize(HostMemoryBackend *memdev)
 }
 #endif
 
+/*
+ * (gdb) 
+ * #0  0x000055555584608e in file_backend_memory_alloc (backend=0x555556ab8850, errp=0x7fffffffdae0) at ../backends/hostmem-file.c:41
+ * #1  0x000055555580a70a in host_memory_backend_memory_complete (uc=0x555556ab8850, errp=0x7fffffffdb58) at ../backends/hostmem.c:333
+ * #2  0x0000555555d7e06a in user_creatable_complete (uc=0x555556ab8850, errp=0x7fffffffdbb8) at ../qom/object_interfaces.c:23
+ * #3  0x0000555555d7e35c in user_creatable_add_type (type=0x5555568c0380 "memory-backend-file", id=0x5555568c0310 "mem0", qdict=0x555556ae5390, v=
+ *     0x555556ac07c0, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:93
+ * #4  0x0000555555d7e714 in user_creatable_add_opts (opts=0x5555568c0330, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:163
+ * #5  0x0000555555d7e80f in user_creatable_add_opts_foreach
+ *     (opaque=0x555555ba6db7 <object_create_delayed>, opts=0x5555568c0330, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:186
+ * #6  0x0000555555e6d9a0 in qemu_opts_foreach
+ *     (list=0x5555567835c0 <qemu_object_opts>, func=0x555555d7e791 <user_creatable_add_opts_foreach>, opaque=0x555555ba6db7 <object_create_delayed>, errp=0x555556837f40 <error_fatal>)
+ *     at ../util/qemu-option.c:1156
+ * #7  0x0000555555baaf3a in qemu_init (argc=20, argv=0x7fffffffe028, envp=0x7fffffffe0d0) at ../softmmu/vl.c:4271
+ * #8  0x0000555555809b2d in main (argc=20, argv=0x7fffffffe028, envp=0x7fffffffe0d0) at ../softmmu/main.c:49
+ *      
+ * 分配失败会显示:
+ * qemu-system-x86_64: -object memory-backend-file,id=mem0,size=4000M,mem-path=/dev/hugepages_test,share=on: unable to map backing store for guest RAM: Cannot allocate memory
+ *
+ * 在以下使用host_memory_backend_memory_complete():
+ *   - backends/hostmem.c|454| <<host_memory_backend_class_init>> ucc->complete = host_memory_backend_memory_complete;
+ */
 static void
 host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)
 {
diff --git a/chardev/char-fe.c b/chardev/char-fe.c
index 474715c5a..95bf751df 100644
--- a/chardev/char-fe.c
+++ b/chardev/char-fe.c
@@ -110,6 +110,16 @@ int qemu_chr_fe_ioctl(CharBackend *be, int cmd, void *arg)
     return res;
 }
 
+/*
+ * called by:
+ *   - hw/display/vhost-user-gpu.c|209| <<vhost_user_gpu_handle_display>> int fd = qemu_chr_fe_get_msgfd(&g->vhost_chr);
+ *   - hw/misc/ivshmem.c|599| <<ivshmem_read>> fd = qemu_chr_fe_get_msgfd(&s->server_chr);
+ *   - hw/misc/ivshmem.c|626| <<ivshmem_recv_msg>> *pfd = qemu_chr_fe_get_msgfd(&s->server_chr);
+ *   - hw/virtio/vhost-user.c|1681| <<vhost_user_postcopy_advise>> ufd = qemu_chr_fe_get_msgfd(chr);
+ *   - hw/virtio/vhost-user.c|2278| <<vhost_user_get_inflight_fd>> fd = qemu_chr_fe_get_msgfd(chr);
+ *   - monitor/misc.c|1233| <<qmp_getfd>> fd = qemu_chr_fe_get_msgfd(&cur_mon->chr);
+ *   - monitor/misc.c|1372| <<qmp_add_fd>> fd = qemu_chr_fe_get_msgfd(&mon->chr);
+ */
 int qemu_chr_fe_get_msgfd(CharBackend *be)
 {
     Chardev *s = be->chr;
@@ -123,6 +133,13 @@ int qemu_chr_fe_get_msgfd(CharBackend *be)
     return res;
 }
 
+/*
+ * called by:
+ *   - chardev/char-fe.c|127| <<qemu_chr_fe_get_msgfd>> int res = (qemu_chr_fe_get_msgfds(be, &fd, 1) == 1) ? fd : -1;
+ *   - tests/qtest/vhost-user-test.c|381| <<chr_read>> s->fds_num = qemu_chr_fe_get_msgfds(chr, s->fds,
+ *   - tests/qtest/vhost-user-test.c|391| <<chr_read>> qemu_chr_fe_get_msgfds(chr, &fd, 1);
+ *   - tests/qtest/vhost-user-test.c|405| <<chr_read>> qemu_chr_fe_get_msgfds(chr, &s->log_fd, 1);
+ */
 int qemu_chr_fe_get_msgfds(CharBackend *be, int *fds, int len)
 {
     Chardev *s = be->chr;
@@ -131,6 +148,9 @@ int qemu_chr_fe_get_msgfds(CharBackend *be, int *fds, int len)
         return -1;
     }
 
+    /*
+     * 似乎目前只能是tcp_get_msgfds()或者NULL
+     */
     return CHARDEV_GET_CLASS(s)->get_msgfds ?
         CHARDEV_GET_CLASS(s)->get_msgfds(s, fds, len) : -1;
 }
diff --git a/chardev/char-socket.c b/chardev/char-socket.c
index 213a4c8dd..56f7fcbef 100644
--- a/chardev/char-socket.c
+++ b/chardev/char-socket.c
@@ -66,7 +66,34 @@ struct SocketChardev {
     int max_size;
     int do_telnetopt;
     int do_nodelay;
+    /*
+     * 在以下使用SocketChadev->read_msgfds:
+     *   - chardev/char-socket.c|301| <<tcp_get_msgfds>> memcpy(fds, s->read_msgfds, to_copy * sizeof(int ));
+     *   - chardev/char-socket.c|305| <<tcp_get_msgfds>> close(s->read_msgfds[i]);
+     *   - chardev/char-socket.c|308| <<tcp_get_msgfds>> g_free(s->read_msgfds);
+     *   - chardev/char-socket.c|309| <<tcp_get_msgfds>> s->read_msgfds = 0;
+     *   - chardev/char-socket.c|375| <<tcp_chr_recv>> close(s->read_msgfds[i]);
+     *   - chardev/char-socket.c|379| <<tcp_chr_recv>> g_free(s->read_msgfds);
+     *   - chardev/char-socket.c|382| <<tcp_chr_recv>> s->read_msgfds = msgfds;
+     *   - chardev/char-socket.c|387| <<tcp_chr_recv>> int fd = s->read_msgfds[i];
+     *   - chardev/char-socket.c|425| <<tcp_chr_free_connection>> close(s->read_msgfds[i]);
+     *   - chardev/char-socket.c|427| <<tcp_chr_free_connection>> g_free(s->read_msgfds);
+     *   - chardev/char-socket.c|428| <<tcp_chr_free_connection>> s->read_msgfds = NULL;
+     */
     int *read_msgfds;
+    /*
+     * 在以下使用SocketChardev->read_msgfds_num:
+     *   - chardev/char-socket.c|281| <<tcp_get_msgfds>> int to_copy = (s->read_msgfds_num < num) ? s->read_msgfds_num : num;
+     *   - chardev/char-socket.c|291| <<tcp_get_msgfds>> for (i = to_copy; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|297| <<tcp_get_msgfds>> s->read_msgfds_num = 0;
+     *   - chardev/char-socket.c|356| <<tcp_chr_recv>> for (i = 0; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|360| <<tcp_chr_recv>> if (s->read_msgfds_num) {
+     *   - chardev/char-socket.c|365| <<tcp_chr_recv>> s->read_msgfds_num = msgfds_num;
+     *   - chardev/char-socket.c|368| <<tcp_chr_recv>> for (i = 0; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|405| <<tcp_chr_free_connection>> if (s->read_msgfds_num) {
+     *   - chardev/char-socket.c|406| <<tcp_chr_free_connection>> for (i = 0; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|411| <<tcp_chr_free_connection>> s->read_msgfds_num = 0;
+     */
     size_t read_msgfds_num;
     int *write_msgfds;
     size_t write_msgfds_num;
@@ -274,6 +301,10 @@ static void tcp_chr_process_IAC_bytes(Chardev *chr,
     *size = j;
 }
 
+/*
+ * 在以下使用tcp_get_msgfds():
+ *   - chardev/char-socket.c|1546| <<char_socket_class_init>> cc->get_msgfds = tcp_get_msgfds;
+ */
 static int tcp_get_msgfds(Chardev *chr, int *fds, int num)
 {
     SocketChardev *s = SOCKET_CHARDEV(chr);
@@ -293,7 +324,19 @@ static int tcp_get_msgfds(Chardev *chr, int *fds, int num)
         }
 
         g_free(s->read_msgfds);
+	/*
+	 * 在以下设置SocketChadev->read_msgfds:
+	 *   - chardev/char-socket.c|309| <<tcp_get_msgfds>> s->read_msgfds = 0;
+	 *   - chardev/char-socket.c|382| <<tcp_chr_recv>> s->read_msgfds = msgfds;
+	 *   - chardev/char-socket.c|428| <<tcp_chr_free_connection>> s->read_msgfds = NULL;
+	 */
         s->read_msgfds = 0;
+	/*
+	 * 在以下使用SocketChardev->read_msgfds_num:
+	 *   - chardev/char-socket.c|297| <<tcp_get_msgfds>> s->read_msgfds_num = 0;
+	 *   - chardev/char-socket.c|365| <<tcp_chr_recv>> s->read_msgfds_num = msgfds_num;
+	 *   - chardev/char-socket.c|411| <<tcp_chr_free_connection>> s->read_msgfds_num = 0;
+	 */
         s->read_msgfds_num = 0;
     }
 
@@ -325,6 +368,23 @@ static int tcp_set_msgfds(Chardev *chr, int *fds, int num)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000556f1cc82048 in tcp_chr_recv (chr=0x556f1eea62b0, buf=0x7efed630d750 "", len=1) at ../chardev/char-socket.c:329
+ * #1  0x0000556f1cc828c0 in tcp_chr_read (chan=0x7efed0002150, cond=G_IO_IN, opaque=0x556f1eea62b0) at ../chardev/char-socket.c:536
+ * #2  0x0000556f1cc71f9a in qio_channel_fd_source_dispatch (source=0x7efed0002000, callback=0x556f1cc827e5 <tcp_chr_read>, user_data=0x556f1eea62b0) at ../io/channel-watch.c:84
+ * #3  0x00007efedfbbd099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #4  0x00007efedfbbd3f8 in g_main_context_iterate.isra () at /lib/../lib64/libglib-2.0.so.0
+ * #5  0x00007efedfbbd6ca in g_main_loop_run () at /lib/../lib64/libglib-2.0.so.0
+ * #6  0x0000556f1cb987b4 in iothread_run (opaque=0x556f1eeb9d00) at ../iothread.c:80
+ * #7  0x0000556f1cd31abc in qemu_thread_start (args=0x556f1eea83e0) at ../util/qemu-thread-posix.c:521
+ * #8  0x00007efeddba5ea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #9  0x00007efedd8ce8cd in clone () at /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - chardev/char-socket.c|536| <<tcp_chr_read>> size = tcp_chr_recv(chr, (void *)buf, len);
+ *   - chardev/char-socket.c|571| <<tcp_chr_sync_read>> size = tcp_chr_recv(chr, (void *) buf, len);
+ */
 static ssize_t tcp_chr_recv(Chardev *chr, char *buf, size_t len)
 {
     SocketChardev *s = SOCKET_CHARDEV(chr);
@@ -518,6 +578,13 @@ static void tcp_chr_disconnect(Chardev *chr)
     qemu_mutex_unlock(&chr->chr_write_lock);
 }
 
+/*
+ * 在update_ioc_handlers()使用tcp_chr_read():
+ *  681     chr->gsource = io_add_watch_poll(chr, s->ioc,
+ *  682                                      tcp_chr_read_poll,
+ *  683                                      tcp_chr_read, chr,
+ *  684                                      chr->gcontext);
+ */
 static gboolean tcp_chr_read(QIOChannel *chan, GIOCondition cond, void *opaque)
 {
     Chardev *chr = CHARDEV(opaque);
@@ -558,6 +625,10 @@ static gboolean tcp_chr_hup(QIOChannel *channel,
     return G_SOURCE_REMOVE;
 }
 
+/*
+ * 在以下使用tcp_chr_sync_read():
+ *   - chardev/char-socket.c|1560| <<char_socket_class_init>> cc->chr_sync_read = tcp_chr_sync_read;
+ */
 static int tcp_chr_sync_read(Chardev *chr, const uint8_t *buf, int len)
 {
     SocketChardev *s = SOCKET_CHARDEV(chr);
diff --git a/hw/block/dataplane/virtio-blk.c b/hw/block/dataplane/virtio-blk.c
index 37499c556..fff4a2b95 100644
--- a/hw/block/dataplane/virtio-blk.c
+++ b/hw/block/dataplane/virtio-blk.c
@@ -46,6 +46,10 @@ struct VirtIOBlockDataPlane {
 };
 
 /* Raise an interrupt to signal guest, if necessary */
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|87| <<virtio_blk_req_complete>> virtio_blk_data_plane_notify(s->dataplane, req->vq);
+ */
 void virtio_blk_data_plane_notify(VirtIOBlockDataPlane *s, VirtQueue *vq)
 {
     if (s->batch_notifications) {
@@ -56,6 +60,11 @@ void virtio_blk_data_plane_notify(VirtIOBlockDataPlane *s, VirtQueue *vq)
     }
 }
 
+/*
+ * 在以下使用notify_guest_bh():
+ *   - hw/block/dataplane/virtio-blk.c|130| <<virtio_blk_data_plane_create>> s->bh = aio_bh_new(s->ctx, notify_guest_bh, s);
+ *   - hw/block/dataplane/virtio-blk.c|310| <<virtio_blk_data_plane_stop>> notify_guest_bh(s);
+ */
 static void notify_guest_bh(void *opaque)
 {
     VirtIOBlockDataPlane *s = opaque;
@@ -136,6 +145,10 @@ bool virtio_blk_data_plane_create(VirtIODevice *vdev, VirtIOBlkConf *conf,
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|1265| <<virtio_blk_device_unrealize>> virtio_blk_data_plane_destroy(s->dataplane);
+ */
 void virtio_blk_data_plane_destroy(VirtIOBlockDataPlane *s)
 {
     VirtIOBlock *vblk;
@@ -154,6 +167,10 @@ void virtio_blk_data_plane_destroy(VirtIOBlockDataPlane *s)
     g_free(s);
 }
 
+/*
+ * 在以下使用virtio_blk_data_plane_handle_output():
+ *   - hw/block/dataplane/virtio-blk.c|244| <<virtio_blk_data_plane_start>> virtio_queue_aio_set_host_notifier_handler(vq, s->ctx, virtio_blk_data_plane_handle_output);
+ */
 static bool virtio_blk_data_plane_handle_output(VirtIODevice *vdev,
                                                 VirtQueue *vq)
 {
@@ -166,6 +183,10 @@ static bool virtio_blk_data_plane_handle_output(VirtIODevice *vdev,
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * 在以下使用virtio_blk_data_plane_start():
+ *   - hw/block/virtio-blk.c|1343| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start;
+ */
 int virtio_blk_data_plane_start(VirtIODevice *vdev)
 {
     VirtIOBlock *vblk = VIRTIO_BLK(vdev);
@@ -257,6 +278,10 @@ int virtio_blk_data_plane_start(VirtIODevice *vdev)
  *
  * Context: BH in IOThread
  */
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|301| <<virtio_blk_data_plane_stop>> aio_wait_bh_oneshot(s->ctx, virtio_blk_data_plane_stop_bh, s);
+ */
 static void virtio_blk_data_plane_stop_bh(void *opaque)
 {
     VirtIOBlockDataPlane *s = opaque;
@@ -270,6 +295,10 @@ static void virtio_blk_data_plane_stop_bh(void *opaque)
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * 在以下使用virtio_blk_data_plane_stop():
+ *   - hw/block/virtio-blk.c|1344| <<virtio_blk_class_init>> vdc->stop_ioeventfd = virtio_blk_data_plane_stop;
+ */
 void virtio_blk_data_plane_stop(VirtIODevice *vdev)
 {
     VirtIOBlock *vblk = VIRTIO_BLK(vdev);
diff --git a/hw/block/virtio-blk.c b/hw/block/virtio-blk.c
index bac2d6fa2..f888ac759 100644
--- a/hw/block/virtio-blk.c
+++ b/hw/block/virtio-blk.c
@@ -33,6 +33,16 @@
 #include "migration/qemu-file-types.h"
 #include "hw/virtio/virtio-access.h"
 
+/*
+ * virtio-blk的ioeventfd和dataplane的关系 (ioeventfd不设置就没有dataplane)
+ *
+ * virtio_bus_start_ioeventfd()
+ * -> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy))
+ *        return -ENOSYS; //k->ioeventfd_enabled = virtio_pci_ioeventfd_enabled()
+ *        virtio_pci_ioeventfd_enabled()会确认ioeventfd是否enabled
+ * -> vdc->start_ioeventfd = virtio_blk_data_plane_start()或virtio_scsi_dataplane_start()或virtio_device_start_ioeventfd_impl()
+ */
+
 /* Config size before the discard support (hide associated config fields) */
 #define VIRTIO_BLK_CFG_SIZE offsetof(struct virtio_blk_config, \
                                      max_discard_sectors)
@@ -72,6 +82,20 @@ static void virtio_blk_free_request(VirtIOBlockReq *req)
     g_free(req);
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|106| <<virtio_blk_handle_rw_error>> virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
+ *   - hw/block/virtio-blk.c|152| <<virtio_blk_rw_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|171| <<virtio_blk_flush_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|193| <<virtio_blk_discard_write_zeroes_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|248| <<virtio_blk_ioctl_complete>> virtio_blk_req_complete(req, status);
+ *   - hw/block/virtio-blk.c|381| <<virtio_blk_handle_scsi>> virtio_blk_req_complete(req, status);
+ *   - hw/block/virtio-blk.c|676| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
+ *   - hw/block/virtio-blk.c|716| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|740| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
+ *   - hw/block/virtio-blk.c|757| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|764| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
+ */
 static void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
 {
     VirtIOBlock *s = req->dev;
@@ -767,6 +791,47 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555b73b2e in virtio_blk_handle_vq (s=0x555557913540, vq=0x55555791c848) at ../hw/block/virtio-blk.c:771
+ * #1  0x0000555555b8fb24 in virtio_blk_data_plane_handle_output (vdev=0x555557913540, vq=0x55555791c848) at ../hw/block/dataplane/virtio-blk.c:165
+ * #2  0x0000555555c5ddf2 in virtio_queue_notify_aio_vq (vq=0x55555791c848) at ../hw/virtio/virtio.c:2326
+ * #3  0x0000555555c60dc0 in virtio_queue_host_notifier_aio_read (n=0x55555791c8c0) at ../hw/virtio/virtio.c:3530
+ * #4  0x0000555555e80900 in aio_dispatch_handler (ctx=0x555556a9a0a0, node=0x7fff1c04fa00) at ../util/aio-posix.c:329
+ * #5  0x0000555555e80ab9 in aio_dispatch_handlers (ctx=0x555556a9a0a0) at ../util/aio-posix.c:372
+ * #6  0x0000555555e80b0f in aio_dispatch (ctx=0x555556a9a0a0) at ../util/aio-posix.c:382
+ * #7  0x0000555555e5ef83 in aio_ctx_dispatch (source=0x555556a9a0a0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #8  0x00007ffff7447099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #9  0x0000555555e644cb in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #10 0x0000555555e64545 in os_host_main_loop_wait (timeout=2000000) at ../util/main-loop.c:244
+ * #11 0x0000555555e6464d in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #12 0x0000555555ba3630 in qemu_main_loop () at ../softmmu/vl.c:1678
+ * #13 0x0000555555809b32 in main (argc=18, argv=0x7fffffffe028, envp=0x7fffffffe0c0) at ../softmmu/main.c:50
+ *
+ * (gdb) bt
+ * #0  0x0000555555b73b2e in virtio_blk_handle_vq (s=0x555557913540, vq=0x55555791c680) at ../hw/block/virtio-blk.c:771
+ * #1  0x0000555555b73d17 in virtio_blk_handle_output_do (s=0x555557913540, vq=0x55555791c680) at ../hw/block/virtio-blk.c:810
+ * #2  0x0000555555b73d73 in virtio_blk_handle_output (vdev=0x555557913540, vq=0x55555791c680) at ../hw/block/virtio-blk.c:826
+ * #3  0x0000555555c5dfdb in virtio_queue_notify (vdev=0x555557913540, n=0) at ../hw/virtio/virtio.c:2366
+ * #4  0x00005555558ea806 in virtio_pci_notify_write (opaque=0x55555790b3b0, addr=0, val=0, size=2) at ../hw/virtio/virtio-pci.c:1343
+ * #5  0x0000555555c4d454 in memory_region_write_accessor (mr=0x55555790c090, addr=0, value=0x7fff31d7c6c8, size=2, shift=0, mask=65535, attrs=...) at ../softmmu/memory.c:491
+ * #6  0x0000555555c4d678 in access_with_adjusted_size (addr=0, value=0x7fff31d7c6c8, size=2, access_size_min=1, access_size_max=4, access_fn=
+ *     0x555555c4d36f <memory_region_write_accessor>, mr=0x55555790c090, attrs=...) at ../softmmu/memory.c:552
+ * #7  0x0000555555c50681 in memory_region_dispatch_write (mr=0x55555790c090, addr=0, data=0, op=MO_16, attrs=...) at ../softmmu/memory.c:1501
+ * #8  0x0000555555bd91bb in flatview_write_continue (fv=0x7fff1c04e870, addr=4261425152, attrs=..., ptr=0x7ffff7fe1028, len=2, addr1=0, l=2, mr=0x55555790c090) at ../softmmu/physmem.c:2759
+ * #9  0x0000555555bd9300 in flatview_write (fv=0x7fff1c04e870, addr=4261425152, attrs=..., buf=0x7ffff7fe1028, len=2) at ../softmmu/physmem.c:2799
+ * #10 0x0000555555bd966e in address_space_write (as=0x55555681a340 <address_space_memory>, addr=4261425152, attrs=..., buf=0x7ffff7fe1028, len=2) at ../softmmu/physmem.c:2891
+ * #11 0x0000555555bd96db in address_space_rw (as=0x55555681a340 <address_space_memory>, addr=4261425152, attrs=..., buf=0x7ffff7fe1028, len=2, is_write=true) at ../softmmu/physmem.c:2901
+ * #12 0x0000555555c25961 in kvm_cpu_exec (cpu=0x555556b08720) at ../accel/kvm/kvm-all.c:2541
+ * #13 0x0000555555c801fe in kvm_vcpu_thread_fn (arg=0x555556b08720) at ../accel/kvm/kvm-cpus.c:49
+ * #14 0x0000555555e40abc in qemu_thread_start (args=0x555556b2f210) at ../util/qemu-thread-posix.c:521
+ * #15 0x00007ffff542fea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #16 0x00007ffff51588cd in clone () at /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|170| <<virtio_blk_data_plane_handle_output>> return virtio_blk_handle_vq(s, vq);
+ *   - hw/block/virtio-blk.c|810| <<virtio_blk_handle_output_do>> virtio_blk_handle_vq(s, vq);
+ */
 bool virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
 {
     VirtIOBlockReq *req;
@@ -805,11 +870,19 @@ bool virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
     return progress;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|826| <<virtio_blk_handle_output>> virtio_blk_handle_output_do(s, vq);
+ */
 static void virtio_blk_handle_output_do(VirtIOBlock *s, VirtQueue *vq)
 {
     virtio_blk_handle_vq(s, vq);
 }
 
+/*
+ * 在以下使用virtio_blk_handle_output():
+ *   - hw/block/virtio-blk.c|1219| <<virtio_blk_device_realize>> virtio_add_queue(vdev, conf->queue_size, virtio_blk_handle_output);
+ */
 static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBlock *s = (VirtIOBlock *)vdev;
diff --git a/hw/net/vhost_net.c b/hw/net/vhost_net.c
index 24d555e76..bb3d9a14e 100644
--- a/hw/net/vhost_net.c
+++ b/hw/net/vhost_net.c
@@ -310,6 +310,10 @@ static void vhost_net_stop_one(struct vhost_net *net,
     vhost_dev_disable_notifiers(&net->dev, dev);
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|276| <<virtio_net_vhost_status>> r = vhost_net_start(vdev, n->nic->ncs, queues);
+ */
 int vhost_net_start(VirtIODevice *dev, NetClientState *ncs,
                     int total_queues)
 {
@@ -457,6 +461,14 @@ VHostNetState *get_vhost_net(NetClientState *nc)
     return vhost_net;
 }
 
+/*
+ * called by:
+ *   - backends/cryptodev-vhost.c|147| <<vhost_set_vring_enable>> vhost_set_vring_enable(CryptoDevBackendClient *cc,
+ *   - ackends/cryptodev-vhost.c|219| <<cryptodev_vhost_start>> r = vhost_set_vring_enable(cc, b, i, cc->vring_enable);
+ *   - hw/net/vhost_net.c|359| <<vhost_net_start>> r = vhost_set_vring_enable(peer, peer->vring_enable);
+ *   - hw/net/virtio-net.c|646| <<peer_attach>> vhost_set_vring_enable(nc->peer, 1);
+ *   - hw/net/virtio-net.c|669| <<peer_detach>> vhost_set_vring_enable(nc->peer, 0);
+ */
 int vhost_set_vring_enable(NetClientState *nc, int enable)
 {
     VHostNetState *net = get_vhost_net(nc);
@@ -471,6 +483,10 @@ int vhost_set_vring_enable(NetClientState *nc, int enable)
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|266| <<virtio_net_vhost_status>> r = vhost_net_set_mtu(get_vhost_net(nc->peer), n->net_conf.mtu);
+ */
 int vhost_net_set_mtu(struct vhost_net *net, uint16_t mtu)
 {
     const VhostOps *vhost_ops = net->dev.vhost_ops;
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index 9179013ac..178d98488 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -2391,6 +2391,10 @@ static ssize_t virtio_net_receive(NetClientState *nc, const uint8_t *buf,
 
 static int32_t virtio_net_flush_tx(VirtIONetQueue *q);
 
+/*
+ * 在以下使用virtio_net_tx_complete():
+ *   - hw/net/virtio-net.c|2487| <<virtio_net_flush_tx>> ret = qemu_sendv_packet_async(qemu_get_subqueue(n->nic, queue_index), out_sg, out_num, virtio_net_tx_complete);
+ */
 static void virtio_net_tx_complete(NetClientState *nc, ssize_t len)
 {
     VirtIONet *n = qemu_get_nic_opaque(nc);
@@ -2534,6 +2538,41 @@ static void virtio_net_handle_tx_timer(VirtIODevice *vdev, VirtQueue *vq)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555bcdb28 in virtio_net_handle_tx_bh (vdev=0x5555578816f0, vq=0x7fff306671d8) at ../hw/net/virtio-net.c:2539
+ * #1  0x0000555555c5dec2 in virtio_queue_notify_vq (vq=0x7fff306671d8) at ../hw/virtio/virtio.c:2346
+ * #2  0x0000555555c60f76 in virtio_queue_host_notifier_read (n=0x7fff30667250) at ../hw/virtio/virtio.c:3585
+ * #3  0x0000555555e80900 in aio_dispatch_handler (ctx=0x5555568b6b40, node=0x7fff2804e300) at ../util/aio-posix.c:329
+ * #4  0x0000555555e80ab9 in aio_dispatch_handlers (ctx=0x5555568b6b40) at ../util/aio-posix.c:372
+ * #5  0x0000555555e80b0f in aio_dispatch (ctx=0x5555568b6b40) at ../util/aio-posix.c:382
+ * #6  0x0000555555e5ef83 in aio_ctx_dispatch (source=0x5555568b6b40, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #7  0x00007ffff7447099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #8  0x0000555555e644cb in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #9  0x0000555555e64545 in os_host_main_loop_wait (timeout=2999865660) at ../util/main-loop.c:244
+ * #10 0x0000555555e6464d in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #11 0x0000555555ba3630 in qemu_main_loop () at ../softmmu/vl.c:1678
+ * #12 0x0000555555809b32 in main (argc=14, argv=0x7fffffffe068, envp=0x7fffffffe0e0) at ../softmmu/main.c:50
+ *
+ * ioeventfd=false
+ * (gdb) bt
+ * #0  0x0000555555bcdb28 in virtio_net_handle_tx_bh (vdev=0x5555578816f0, vq=0x7fff30667438) at ../hw/net/virtio-net.c:2539
+ * #1  0x0000555555c5dfdb in virtio_queue_notify (vdev=0x5555578816f0, n=7) at ../hw/virtio/virtio.c:2366
+ * #2  0x00005555558ea806 in virtio_pci_notify_write (opaque=0x555557879560, addr=28, val=7, size=2) at ../hw/virtio/virtio-pci.c:1343
+ * #3  0x0000555555c4d454 in memory_region_write_accessor (mr=0x55555787a240, addr=28, value=0x7fff23ffe6c8, size=2, shift=0, mask=65535, attrs=...) at ../softmmu/memory.c:491
+ * #4  0x0000555555c4d678 in access_with_adjusted_size (addr=28, value=0x7fff23ffe6c8, size=2, access_size_min=1, access_size_max=4, access_fn=
+ *     0x555555c4d36f <memory_region_write_accessor>, mr=0x55555787a240, attrs=...) at ../softmmu/memory.c:552
+ * #5  0x0000555555c50681 in memory_region_dispatch_write (mr=0x55555787a240, addr=28, data=7, op=MO_16, attrs=...) at ../softmmu/memory.c:1501
+ * #6  0x0000555555bd91bb in flatview_write_continue (fv=0x7fff2c1649c0, addr=4261425180, attrs=..., ptr=0x7ffff7fd7028, len=2, addr1=28, l=2, mr=0x55555787a240) at ../softmmu/physmem.c:2759
+ * #7  0x0000555555bd9300 in flatview_write (fv=0x7fff2c1649c0, addr=4261425180, attrs=..., buf=0x7ffff7fd7028, len=2) at ../softmmu/physmem.c:2799
+ * #8  0x0000555555bd966e in address_space_write (as=0x55555681a340 <address_space_memory>, addr=4261425180, attrs=..., buf=0x7ffff7fd7028, len=2) at ../softmmu/physmem.c:2891
+ * #9  0x0000555555bd96db in address_space_rw (as=0x55555681a340 <address_space_memory>, addr=4261425180, attrs=..., buf=0x7ffff7fd7028, len=2, is_write=true) at ../softmmu/physmem.c:2901
+ * #10 0x0000555555c25961 in kvm_cpu_exec (cpu=0x555556bcc680) at ../accel/kvm/kvm-all.c:2541
+ * #11 0x0000555555c801fe in kvm_vcpu_thread_fn (arg=0x555556bcc680) at ../accel/kvm/kvm-cpus.c:49
+ * #12 0x0000555555e40abc in qemu_thread_start (args=0x555556bf26f0) at ../util/qemu-thread-posix.c:521
+ * #13 0x00007ffff542fea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #14 0x00007ffff51588cd in clone () at /lib/../lib64/libc.so.6
+ */
 static void virtio_net_handle_tx_bh(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIONet *n = VIRTIO_NET(vdev);
@@ -3055,6 +3094,10 @@ static NetClientInfo net_virtio_info = {
     .announce = virtio_net_announce,
 };
 
+/*
+ * 在以下使用virtio_net_guest_notifier_pending():
+ *   - hw/net/virtio-net.c|3592| <<virtio_net_class_init>> vdc->guest_notifier_pending = virtio_net_guest_notifier_pending;
+ */
 static bool virtio_net_guest_notifier_pending(VirtIODevice *vdev, int idx)
 {
     VirtIONet *n = VIRTIO_NET(vdev);
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index 0131d9d02..e42b667c9 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -1325,6 +1325,12 @@ static pcibus_t pci_bar_address(PCIDevice *d,
     return new_addr;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|330| <<pci_do_device_reset>> pci_update_mappings(dev);
+ *   - hw/pci/pci.c|545| <<get_pci_config_device>> pci_update_mappings(s);
+ *   - hw/pci/pci.c|1421| <<pci_default_write_config>> pci_update_mappings(d);
+ */
 static void pci_update_mappings(PCIDevice *d)
 {
     PCIIORegion *r;
@@ -2668,6 +2674,11 @@ static void pci_device_class_base_init(ObjectClass *klass, void *data)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|96| <<pci_init_bus_master>> AddressSpace *dma_as = pci_device_iommu_address_space(pci_dev);
+ *   - hw/vfio/pci.c|2824| <<vfio_realize>> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
+ */
 AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
 {
     PCIBus *bus = pci_get_bus(dev);
diff --git a/hw/scsi/vhost-scsi-common.c b/hw/scsi/vhost-scsi-common.c
index 767f827e5..9f7f93087 100644
--- a/hw/scsi/vhost-scsi-common.c
+++ b/hw/scsi/vhost-scsi-common.c
@@ -25,6 +25,11 @@
 #include "hw/virtio/virtio-access.h"
 #include "hw/fw-path-provider.h"
 
+/*
+ * called by:
+ *   - hw/scsi/vhost-scsi.c|91| <<vhost_scsi_start>> ret = vhost_scsi_common_start(vsc);
+ *   - hw/scsi/vhost-user-scsi.c|58| <<vhost_user_scsi_set_status>> ret = vhost_scsi_common_start(vsc);
+ */
 int vhost_scsi_common_start(VHostSCSICommon *vsc)
 {
     int ret, i;
diff --git a/hw/scsi/vhost-scsi.c b/hw/scsi/vhost-scsi.c
index 4d70fa036..f67233d4f 100644
--- a/hw/scsi/vhost-scsi.c
+++ b/hw/scsi/vhost-scsi.c
@@ -177,6 +177,16 @@ static void vhost_scsi_realize(DeviceState *dev, Error **errp)
     }
 
     if (vs->conf.vhostfd) {
+        /*
+	 * 在以下使用monitor_fd_param():
+	 *   - hw/scsi/vhost-scsi.c|180| <<vhost_scsi_realize>> vhostfd = monitor_fd_param(monitor_cur(), vs->conf.vhostfd, errp);
+	 *   - hw/virtio/vhost-vsock.c|147| <<vhost_vsock_device_realize>> vhostfd = monitor_fd_param(monitor_cur(), vsock->conf.vhostfd, errp);
+	 *   - migration/fd.c|58| <<fd_start_incoming_migration>> int fd = monitor_fd_param(monitor_cur(), fdname, errp);
+	 *   - net/socket.c|730| <<net_init_socket>> fd = monitor_fd_param(monitor_cur(), sock->fd, errp);
+	 *   - net/tap.c|703| <<net_init_tap_one>> vhostfd = monitor_fd_param(monitor_cur(), vhostfdname, &err);
+	 *   - net/tap.c|811| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), tap->fd, errp);
+	 *   - net/tap.c|867| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), fds[i], errp);
+	 */
         vhostfd = monitor_fd_param(monitor_cur(), vs->conf.vhostfd, errp);
         if (vhostfd == -1) {
             error_prepend(errp, "vhost-scsi: unable to parse vhostfd: ");
diff --git a/hw/scsi/virtio-scsi-dataplane.c b/hw/scsi/virtio-scsi-dataplane.c
index b995bab3a..6c3af30d0 100644
--- a/hw/scsi/virtio-scsi-dataplane.c
+++ b/hw/scsi/virtio-scsi-dataplane.c
@@ -22,6 +22,10 @@
 #include "hw/virtio/virtio-access.h"
 
 /* Context: QEMU global mutex held */
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|959| <<virtio_scsi_device_realize>> virtio_scsi_dataplane_setup(s, errp);
+ */
 void virtio_scsi_dataplane_setup(VirtIOSCSI *s, Error **errp)
 {
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);
@@ -49,6 +53,10 @@ void virtio_scsi_dataplane_setup(VirtIOSCSI *s, Error **errp)
     }
 }
 
+/*
+ * 在以下使用virtio_scsi_data_plane_handle_cmd():
+ *   - hw/scsi/virtio-scsi-dataplane.c|163| <<virtio_scsi_dataplane_start>> rc = virtio_scsi_vring_init(s, vs->cmd_vqs[i], i + 2, virtio_scsi_data_plane_handle_cmd);
+ */
 static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,
                                               VirtQueue *vq)
 {
@@ -57,6 +65,11 @@ static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,
 
     virtio_scsi_acquire(s);
     assert(s->ctx && s->dataplane_started);
+    /*
+     * called by:
+     *   - hw/scsi/virtio-scsi-dataplane.c|60| <<virtio_scsi_data_plane_handle_cmd>> progress = virtio_scsi_handle_cmd_vq(s, vq);
+     *   - hw/scsi/virtio-scsi.c|667| <<virtio_scsi_handle_cmd>> virtio_scsi_handle_cmd_vq(s, vq);
+     */
     progress = virtio_scsi_handle_cmd_vq(s, vq);
     virtio_scsi_release(s);
     return progress;
@@ -88,6 +101,12 @@ static bool virtio_scsi_data_plane_handle_event(VirtIODevice *vdev,
     return progress;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi-dataplane.c|159| <<virtio_scsi_dataplane_start>> rc = virtio_scsi_vring_init(s, vs->ctrl_vq, 0, virtio_scsi_data_plane_handle_ctrl);
+ *   - hw/scsi/virtio-scsi-dataplane.c|164| <<virtio_scsi_dataplane_start>> rc = virtio_scsi_vring_init(s, vs->event_vq, 1, virtio_scsi_data_plane_handle_event);
+ *   - hw/scsi/virtio-scsi-dataplane.c|170| <<virtio_scsi_dataplane_start>> rc = virtio_scsi_vring_init(s, vs->cmd_vqs[i], i + 2, virtio_scsi_data_plane_handle_cmd);
+ */
 static int virtio_scsi_vring_init(VirtIOSCSI *s, VirtQueue *vq, int n,
                                   VirtIOHandleAIOOutput fn)
 {
@@ -131,6 +150,12 @@ int virtio_scsi_dataplane_start(VirtIODevice *vdev)
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(vdev);
     VirtIOSCSI *s = VIRTIO_SCSI(vdev);
 
+    /*
+     * 在以下设置VirtIOSCSI->dataplane_fenced:
+     *   - hw/scsi/virtio-scsi-dataplane.c|121| <<virtio_scsi_vring_init>> s->dataplane_fenced = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|202| <<virtio_scsi_dataplane_start>> s->dataplane_fenced = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|223| <<virtio_scsi_dataplane_stop>> s->dataplane_fenced = false;
+     */
     if (s->dataplane_started ||
         s->dataplane_starting ||
         s->dataplane_fenced) {
diff --git a/hw/scsi/virtio-scsi.c b/hw/scsi/virtio-scsi.c
index 3db9a8aae..1969a0268 100644
--- a/hw/scsi/virtio-scsi.c
+++ b/hw/scsi/virtio-scsi.c
@@ -64,6 +64,13 @@ void virtio_scsi_free_req(VirtIOSCSIReq *req)
     g_free(req);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|242| <<virtio_scsi_cancel_notify>> virtio_scsi_complete_req(n->tmf_req);
+ *   - hw/scsi/virtio-scsi.c|437| <<virtio_scsi_handle_ctrl_req>> virtio_scsi_complete_req(req);
+ *   - hw/scsi/virtio-scsi.c|476| <<virtio_scsi_complete_cmd_req>> virtio_scsi_complete_req(req);
+ *   - hw/scsi/virtio-scsi.c|770| <<virtio_scsi_push_event>> virtio_scsi_complete_req(req);
+ */
 static void virtio_scsi_complete_req(VirtIOSCSIReq *req)
 {
     VirtIOSCSI *s = req->dev;
@@ -467,6 +474,14 @@ static void virtio_scsi_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
     virtio_scsi_release(s);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|510| <<virtio_scsi_command_complete>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|550| <<virtio_scsi_request_cancelled>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|556| <<virtio_scsi_fail_cmd_req>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|580| <<virtio_scsi_handle_cmd_req_prepare>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|592| <<virtio_scsi_handle_cmd_req_prepare>> virtio_scsi_complete_cmd_req(req);
+ */
 static void virtio_scsi_complete_cmd_req(VirtIOSCSIReq *req)
 {
     /* Sense data is not in req->resp and is copied separately
@@ -476,6 +491,25 @@ static void virtio_scsi_complete_cmd_req(VirtIOSCSIReq *req)
     virtio_scsi_complete_req(req);
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555c67c82 in virtio_scsi_command_complete (r=0x5555577c38a0, status=0, resid=0) at ../hw/scsi/virtio-scsi.c:481
+ * #1  0x000055555593577b in scsi_req_complete (req=0x5555577c38a0, status=0) at ../hw/scsi/scsi-bus.c:1482
+ * #2  0x0000555555940f0f in scsi_write_do_fua (r=0x5555577c38a0) at ../hw/scsi/scsi-disk.c:258
+ * #3  0x0000555555940fd9 in scsi_dma_complete_noio (r=0x5555577c38a0, ret=0) at ../hw/scsi/scsi-disk.c:272
+ * #4  0x00005555559410fc in scsi_dma_complete (opaque=0x5555577c38a0, ret=0) at ../hw/scsi/scsi-disk.c:296
+ * #5  0x00005555559743ee in dma_complete (dbs=0x5555574c3c30, ret=0) at ../softmmu/dma-helpers.c:120
+ * #6  0x000055555597449b in dma_blk_cb (opaque=0x5555574c3c30, ret=0) at ../softmmu/dma-helpers.c:138
+ * #7  0x0000555555d53f63 in blk_aio_complete (acb=0x555557252f00) at ../block/block-backend.c:1412
+ * #8  0x0000555555d54240 in blk_aio_write_entry (opaque=0x555557252f00) at ../block/block-backend.c:1478
+ * #9  0x0000555555e3c820 in coroutine_trampoline (i0=1461130352, i1=21845) at ../util/coroutine-ucontext.c:173
+ * #10 0x00007ffff50a2180 in __start_context () at /lib/../lib64/libc.so.6
+ * #11 0x00007fffffffd140 in  ()
+ * #12 0x0000000000000000 in  ()
+ *
+ * 在以下使用virtio_scsi_command_complete():
+ *   - hw/scsi/virtio-scsi.c|893| <<global>> .complete = virtio_scsi_command_complete,
+ */
 static void virtio_scsi_command_complete(SCSIRequest *r, uint32_t status,
                                          size_t resid)
 {
@@ -602,6 +636,46 @@ static void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)
     scsi_req_unref(sreq);
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555c6819c in virtio_scsi_handle_cmd_vq (s=0x555557912ef0, vq=0x55555791a7e0) at ../hw/scsi/virtio-scsi.c:606
+ * #1  0x0000555555c490ca in virtio_scsi_data_plane_handle_cmd (vdev=0x555557912ef0, vq=0x55555791a7e0) at ../hw/scsi/virtio-scsi-dataplane.c:60
+ * #2  0x0000555555c5ddf2 in virtio_queue_notify_aio_vq (vq=0x55555791a7e0) at ../hw/virtio/virtio.c:2326
+ * #3  0x0000555555c60dc0 in virtio_queue_host_notifier_aio_read (n=0x55555791a858) at ../hw/virtio/virtio.c:3530
+ * #4  0x0000555555e80900 in aio_dispatch_handler (ctx=0x555556a9a3a0, node=0x7fff1c0048d0) at ../util/aio-posix.c:329
+ * #5  0x0000555555e80ab9 in aio_dispatch_handlers (ctx=0x555556a9a3a0) at ../util/aio-posix.c:372
+ * #6  0x0000555555e80b0f in aio_dispatch (ctx=0x555556a9a3a0) at ../util/aio-posix.c:382
+ * #7  0x0000555555e5ef83 in aio_ctx_dispatch (source=0x555556a9a3a0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #8  0x00007ffff7447099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #9  0x0000555555e644cb in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #10 0x0000555555e64545 in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:244
+ * #11 0x0000555555e6464d in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #12 0x0000555555ba3630 in qemu_main_loop () at ../softmmu/vl.c:1678
+ * #13 0x0000555555809b32 in main (argc=20, argv=0x7fffffffdff8, envp=0x7fffffffe0a0) at ../softmmu/main.c:50
+ *
+ * (gdb) bt
+ * #0  0x0000555555c6819c in virtio_scsi_handle_cmd_vq (s=0x555557912fe0, vq=0x55555791a918) at ../hw/scsi/virtio-scsi.c:606
+ * #1  0x0000555555c68461 in virtio_scsi_handle_cmd (vdev=0x555557912fe0, vq=0x55555791a918) at ../hw/scsi/virtio-scsi.c:660
+ * #2  0x0000555555c5dfdb in virtio_queue_notify (vdev=0x555557912fe0, n=3) at ../hw/virtio/virtio.c:2366
+ * #3  0x00005555558ea806 in virtio_pci_notify_write (opaque=0x55555790ae50, addr=12, val=3, size=2) at ../hw/virtio/virtio-pci.c:1343
+ * #4  0x0000555555c4d454 in memory_region_write_accessor (mr=0x55555790bb30, addr=12, value=0x7fff3157b6c8, size=2, shift=0, mask=65535, attrs=...) at ../softmmu/memory.c:491
+ * #5  0x0000555555c4d678 in access_with_adjusted_size (addr=12, value=0x7fff3157b6c8, size=2, access_size_min=1, access_size_max=4, access_fn=
+       0x555555c4d36f <memory_region_write_accessor>, mr=0x55555790bb30, attrs=...) at ../softmmu/memory.c:552
+ * #6  0x0000555555c50681 in memory_region_dispatch_write (mr=0x55555790bb30, addr=12, data=3, op=MO_16, attrs=...) at ../softmmu/memory.c:1501
+ * #7  0x0000555555bd91bb in flatview_write_continue (fv=0x7fff2c1583f0, addr=4261425164, attrs=..., ptr=0x7ffff7fdd028, len=2, addr1=12, l=2, mr=0x55555790bb30) at ../softmmu/physmem.c:2759
+ * #8  0x0000555555bd9300 in flatview_write (fv=0x7fff2c1583f0, addr=4261425164, attrs=..., buf=0x7ffff7fdd028, len=2) at ../softmmu/physmem.c:2799
+ * #9  0x0000555555bd966e in address_space_write (as=0x55555681a340 <address_space_memory>, addr=4261425164, attrs=..., buf=0x7ffff7fdd028, len=2) at ../softmmu/physmem.c:2891
+ * #10 0x0000555555bd96db in address_space_rw (as=0x55555681a340 <address_space_memory>, addr=4261425164, attrs=..., buf=0x7ffff7fdd028, len=2, is_write=true) at ../softmmu/physmem.c:2901
+ * #11 0x0000555555c25961 in kvm_cpu_exec (cpu=0x555556b5a640) at ../accel/kvm/kvm-all.c:2541
+ * #12 0x0000555555c801fe in kvm_vcpu_thread_fn (arg=0x555556b5a640) at ../accel/kvm/kvm-cpus.c:49
+ * #13 0x0000555555e40abc in qemu_thread_start (args=0x555556b80e00) at ../util/qemu-thread-posix.c:521
+ * #14 0x00007ffff542fea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #15 0x00007ffff51588cd in clone () at /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/scsi/virtio-scsi-dataplane.c|60| <<virtio_scsi_data_plane_handle_cmd>> progress = virtio_scsi_handle_cmd_vq(s, vq);
+ *   - hw/scsi/virtio-scsi.c|667| <<virtio_scsi_handle_cmd>> virtio_scsi_handle_cmd_vq(s, vq);
+ */
 bool virtio_scsi_handle_cmd_vq(VirtIOSCSI *s, VirtQueue *vq)
 {
     VirtIOSCSIReq *req, *next;
@@ -645,6 +719,14 @@ bool virtio_scsi_handle_cmd_vq(VirtIOSCSI *s, VirtQueue *vq)
     return progress;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|983| <<virtio_scsi_device_realize>> virtio_scsi_common_realize(dev,
+ *                                                                        virtio_scsi_handle_ctrl,
+ *                                                                        virtio_scsi_handle_event,
+ *                                                                        virtio_scsi_handle_cmd,
+ *                                                                        &err);
+ */
 static void virtio_scsi_handle_cmd(VirtIODevice *vdev, VirtQueue *vq)
 {
     /* use non-QOM casts in the data path */
@@ -872,6 +954,10 @@ static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,
     }
 }
 
+/*
+ * 在以下使用virtio_scsi_scsi_info:
+ *   - hw/scsi/virtio-scsi.c|972| <<virtio_scsi_device_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), dev, &virtio_scsi_scsi_info, vdev->bus_name);
+ */
 static struct SCSIBusInfo virtio_scsi_scsi_info = {
     .tcq = true,
     .max_channel = VIRTIO_SCSI_MAX_CHANNEL,
diff --git a/hw/timer/hpet.c b/hw/timer/hpet.c
index 9520471be..d2c13a0fc 100644
--- a/hw/timer/hpet.c
+++ b/hw/timer/hpet.c
@@ -417,6 +417,24 @@ static void hpet_del_timer(HPETTimer *t)
     update_irq(t, 0);
 }
 
+/*
+ * (gdb) bt
+ * #0  0x000055e035a0f9a5 in hpet_ram_read (opaque=0x55e0388efd20, addr=240, size=4) at ../hw/timer/hpet.c:423
+ * #1  0x000055e035dc519b in memory_region_read_accessor (mr=0x55e0388f0040, addr=240, value=0x7f779957c740, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:442
+ * #2  0x000055e035dc5678 in access_with_adjusted_size (addr=240, value=0x7f779957c740, size=4, access_size_min=1, access_size_max=4, access_fn=
+ *                        0x55e035dc515d <memory_region_read_accessor>, mr=0x55e0388f0040, attrs=...) at ../softmmu/memory.c:552
+ * #3  0x000055e035dc82c7 in memory_region_dispatch_read1 (mr=0x55e0388f0040, addr=240, pval=0x7f779957c740, size=4, attrs=...) at ../softmmu/memory.c:1420
+ * #4  0x000055e035dc83b4 in memory_region_dispatch_read (mr=0x55e0388f0040, addr=240, pval=0x7f779957c740, op=MO_32, attrs=...) at ../softmmu/memory.c:1449
+ * #5  0x000055e035d513e2 in flatview_read_continue (fv=0x7f778c000d30, addr=4275044592, attrs=..., ptr=0x7f785f6f9028, len=4, addr1=240, l=4, mr=0x55e0388f0040) at ../softmmu/physmem.c:2822
+ * #6  0x000055e035d5154e in flatview_read (fv=0x7f778c000d30, addr=4275044592, attrs=..., buf=0x7f785f6f9028, len=4) at ../softmmu/physmem.c:2862
+ * #7  0x000055e035d515d7 in address_space_read_full (as=0x55e036992340 <address_space_memory>, addr=4275044592, attrs=..., buf=0x7f785f6f9028, len=4) at ../softmmu/physmem.c:2875
+ * #8  0x000055e035d516fb in address_space_rw (as=0x55e036992340 <address_space_memory>, addr=4275044592, attrs=..., buf=0x7f785f6f9028, len=4, is_write=false) at ../softmmu/physmem.c:2903
+ * #9  0x000055e035d9d961 in kvm_cpu_exec (cpu=0x55e0380ed7b0) at ../accel/kvm/kvm-all.c:2541
+ * #10 0x000055e035df81fe in kvm_vcpu_thread_fn (arg=0x55e0380ed7b0) at ../accel/kvm/kvm-cpus.c:49
+ * #11 0x000055e035fb8abc in qemu_thread_start (args=0x55e038114290) at ../util/qemu-thread-posix.c:521
+ * #12 0x00007f785cb43ea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #13 0x00007f785c86c8cd in clone () at /lib/../lib64/libc.so.6
+ */
 static uint64_t hpet_ram_read(void *opaque, hwaddr addr,
                               unsigned size)
 {
diff --git a/hw/vfio/common.c b/hw/vfio/common.c
index 6ff1daa76..3c52c0220 100644
--- a/hw/vfio/common.c
+++ b/hw/vfio/common.c
@@ -40,8 +40,30 @@
 #include "qapi/error.h"
 #include "migration/migration.h"
 
+/*
+ * 在以下使用vfio_group_list:
+ *   - hw/vfio/common.c|44| <<global>> QLIST_HEAD_INITIALIZER(vfio_group_list);
+ *   - hw/vfio/common.c|309| <<vfio_mig_active>> if (QLIST_EMPTY(&vfio_group_list)) {
+ *   - hw/vfio/common.c|313| <<vfio_mig_active>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|1520| <<vfio_reset_handler>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|1528| <<vfio_reset_handler>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|2009| <<vfio_get_group>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|2053| <<vfio_get_group>> if (QLIST_EMPTY(&vfio_group_list)) {
+ *   - hw/vfio/common.c|2057| <<vfio_get_group>> QLIST_INSERT_HEAD(&vfio_group_list, group, next);
+ *   - hw/vfio/common.c|2086| <<vfio_put_group>> if (QLIST_EMPTY(&vfio_group_list)) {
+ *   - hw/vfio/pci.c|2249| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/pci.c|2292| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/pci.c|2306| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/pci.c|2338| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ */
 VFIOGroupList vfio_group_list =
     QLIST_HEAD_INITIALIZER(vfio_group_list);
+/*
+ * 在以下使用vfio_address_spaces:
+ *   - hw/vfio/common.c|46| <<QLIST_HEAD>> QLIST_HEAD_INITIALIZER(vfio_address_spaces);
+ *   - hw/vfio/common.c|1594| <<vfio_get_address_space>> QLIST_FOREACH(space, &vfio_address_spaces, list) {
+ *   - hw/vfio/common.c|1605| <<vfio_get_address_space>> QLIST_INSERT_HEAD(&vfio_address_spaces, space, list);
+ */
 static QLIST_HEAD(, VFIOAddressSpace) vfio_address_spaces =
     QLIST_HEAD_INITIALIZER(vfio_address_spaces);
 
@@ -53,6 +75,15 @@ static QLIST_HEAD(, VFIOAddressSpace) vfio_address_spaces =
  * initialized, this file descriptor is only released on QEMU exit and
  * we'll re-use it should another vfio device be attached before then.
  */
+/*
+ * 在以下使用vfio_kvm_device_fd:
+ *   - hw/vfio/common.c|746| <<vfio_listener_region_add>> if (ioctl(vfio_kvm_device_fd, KVM_SET_DEVICE_ATTR, &attr)) {
+ *   - hw/vfio/common.c|1490| <<vfio_kvm_device_add_group>> if (vfio_kvm_device_fd < 0) {
+ *   - hw/vfio/common.c|1500| <<vfio_kvm_device_add_group>> vfio_kvm_device_fd = cd.fd;
+ *   - hw/vfio/common.c|1503| <<vfio_kvm_device_add_group>> if (ioctl(vfio_kvm_device_fd, KVM_SET_DEVICE_ATTR, &attr)) {
+ *   - hw/vfio/common.c|1519| <<vfio_kvm_device_del_group>> if (vfio_kvm_device_fd < 0) {
+ *   - hw/vfio/common.c|1523| <<vfio_kvm_device_del_group>> if (ioctl(vfio_kvm_device_fd, KVM_SET_DEVICE_ATTR, &attr)) {
+ */
 static int vfio_kvm_device_fd = -1;
 #endif
 
@@ -274,6 +305,10 @@ uint64_t vfio_region_read(void *opaque,
     return data;
 }
 
+/*
+ * 在以下使用vfio_region_ops:
+ *   - hw/vfio/common.c|1366| <<vfio_region_setup>> memory_region_init_io(region->mem, obj, &vfio_region_ops,
+ */
 const MemoryRegionOps vfio_region_ops = {
     .read = vfio_region_read,
     .write = vfio_region_write,
@@ -372,6 +407,10 @@ static bool vfio_devices_all_running_and_saving(VFIOContainer *container)
     return true;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|476| <<vfio_dma_unmap>> return vfio_dma_unmap_bitmap(container, iova, size, iotlb);
+ */
 static int vfio_dma_unmap_bitmap(VFIOContainer *container,
                                  hwaddr iova, ram_addr_t size,
                                  IOMMUTLBEntry *iotlb)
@@ -429,6 +468,13 @@ unmap_exit:
 /*
  * DMA - Mapping and unmapping for the "type1" IOMMU interface used on x86
  */
+/*
+ * called by:
+ *   - hw/vfio/common.c|582| <<vfio_dma_map>> (errno == EBUSY && vfio_dma_unmap(container, iova, size, NULL) == 0 &&
+ *   - hw/vfio/common.c|736| <<vfio_iommu_map_notify>> ret = vfio_dma_unmap(container, iova, iotlb->addr_mask + 1, iotlb);
+ *   - hw/vfio/common.c|1050| <<vfio_listener_region_del>> ret = vfio_dma_unmap(container, iova, int128_get64(llsize), NULL);
+ *   - hw/vfio/common.c|1058| <<vfio_listener_region_del>> ret = vfio_dma_unmap(container, iova, int128_get64(llsize), NULL);
+ */
 static int vfio_dma_unmap(VFIOContainer *container,
                           hwaddr iova, ram_addr_t size,
                           IOMMUTLBEntry *iotlb)
@@ -471,6 +517,62 @@ static int vfio_dma_unmap(VFIOContainer *container,
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555bbdd6a in vfio_dma_map (container=0x55555798cfe0, iova=1048576, size=3144679424, vaddr=0x7fff32100000, readonly=false) at ../hw/vfio/common.c:476
+ * #1  0x0000555555bbee65 in vfio_listener_region_add (listener=0x55555798cff0, section=0x7fffffffc720) at ../hw/vfio/common.c:838
+ * #2  0x0000555555c53adb in listener_add_address_space (listener=0x55555798cff0, as=0x55555681a340 <address_space_memory>) at ../softmmu/memory.c:2720
+ * #3  0x0000555555c53ef5 in memory_listener_register (listener=0x55555798cff0, as=0x55555681a340 <address_space_memory>) at ../softmmu/memory.c:2787
+ * #4  0x0000555555bc1a36 in vfio_connect_container (group=0x55555798cf60, as=0x55555681a340 <address_space_memory>, errp=0x7fffffffda08) at ../hw/vfio/common.c:1853
+ * #5  0x0000555555bc2020 in vfio_get_group (groupid=85, as=0x55555681a340 <address_space_memory>, errp=0x7fffffffda08) at ../hw/vfio/common.c:1970
+ * #6  0x0000555555b8db34 in vfio_realize (pdev=0x555557986940, errp=0x7fffffffda08) at ../hw/vfio/pci.c:2819
+ * #7  0x00005555559004df in pci_qdev_realize (qdev=0x555557986940, errp=0x7fffffffda80) at ../hw/pci/pci.c:2123
+ * #8  0x0000555555da15dd in device_set_realized (obj=0x555557986940, value=true, errp=0x7fffffffdb88) at ../hw/core/qdev.c:886
+ * #9  0x0000555555d7cb09 in property_set_bool (obj=0x555557986940, v=0x5555579878f0, name=0x555555ff4311 "realized", opaque=0x5555568c5230, errp=0x7fffffffdb88) at ../qom/object.c:2251
+ * #10 0x0000555555d7ac2b in object_property_set (obj=0x555557986940, name=0x555555ff4311 "realized", v=0x5555579878f0, errp=0x555556837f40 <error_fatal>) at ../qom/object.c:1398
+ * #11 0x0000555555d7de1b in object_property_set_qobject (obj=0x555557986940, name=0x555555ff4311 "realized", value=0x555557987830, errp=0x555556837f40 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #12 0x0000555555d7af70 in object_property_set_bool (obj=0x555557986940, name=0x555555ff4311 "realized", value=true, errp=0x555556837f40 <error_fatal>) at ../qom/object.c:1465
+ * #13 0x0000555555da01fc in qdev_realize (dev=0x555557986940, bus=0x555556d49d80, errp=0x555556837f40 <error_fatal>) at ../hw/core/qdev.c:399
+ * #14 0x0000555555a0c402 in qdev_device_add (opts=0x5555568c02b0, errp=0x555556837f40 <error_fatal>) at ../softmmu/qdev-monitor.c:676
+ * #15 0x0000555555ba5db6 in device_init_func (opaque=0x0, opts=0x5555568c02b0, errp=0x555556837f40 <error_fatal>) at ../softmmu/vl.c:2104
+ * #16 0x0000555555e6d9a0 in qemu_opts_foreach (list=0x555556755d20 <qemu_device_opts>, func=0x555555ba5d8f <device_init_func>, opaque=0x0, errp=0x555556837f40 <error_fatal>) at ../util/qemu-option.c:1156
+ * #17 0x0000555555bab329 in qemu_init (argc=16, argv=0x7fffffffe0b8, envp=0x7fffffffe140) at ../softmmu/vl.c:4398
+ * #18 0x0000555555809b2d in main (argc=16, argv=0x7fffffffe0b8, envp=0x7fffffffe140) at ../softmmu/main.c:49
+ *
+ * (gdb) bt
+ * #0  0x0000555555bbdd6a in vfio_dma_map (container=0x55555798cfe0, iova=4269805568, size=28672, vaddr=0x7fffed83b000, readonly=false) at ../hw/vfio/common.c:476
+ * #1  0x0000555555bbee65 in vfio_listener_region_add (listener=0x55555798cff0, section=0x7fff317fd1f0) at ../hw/vfio/common.c:838
+ * #2  0x0000555555c4f2db in address_space_update_topology_pass (as=0x55555681a340 <address_space_memory>, old_view=0x7fff245c7310, new_view=0x7fff245f5f60, adding=true) at ../softmmu/memory.c:971
+ * #3  0x0000555555c4f5d5 in address_space_set_flatview (as=0x55555681a340 <address_space_memory>) at ../softmmu/memory.c:1047
+ * #4  0x0000555555c4f77c in memory_region_transaction_commit () at ../softmmu/memory.c:1099
+ * #5  0x0000555555c52d72 in memory_region_update_container_subregions (subregion=0x5555579e92d0) at ../softmmu/memory.c:2428
+ * #6  0x0000555555c52dd9 in memory_region_add_subregion_common (mr=0x555556c4afe0, offset=4269801472, subregion=0x5555579e92d0) at ../softmmu/memory.c:2438
+ * #7  0x0000555555c52e53 in memory_region_add_subregion_overlap (mr=0x555556c4afe0, offset=4269801472, subregion=0x5555579e92d0, priority=1) at ../softmmu/memory.c:2455
+ * #8  0x00005555558fea23 in pci_update_mappings (d=0x555557986940) at ../hw/pci/pci.c:1361
+ * #9  0x00005555558fede4 in pci_default_write_config (d=0x555557986940, addr=4, val_in=326, l=2) at ../hw/pci/pci.c:1421
+ * #10 0x0000555555b898ef in vfio_pci_write_config (pdev=0x555557986940, addr=4, val=326, len=2) at ../hw/vfio/pci.c:1185
+ * #11 0x00005555558dca39 in pci_host_config_write_common (pci_dev=0x555557986940, addr=4, limit=256, val=326, len=2) at ../hw/pci/pci_host.c:83
+ * #12 0x00005555558dcb9d in pci_data_write (s=0x555556d49d80, addr=2147491844, val=326, len=2) at ../hw/pci/pci_host.c:120
+ * #13 0x00005555558dccc3 in pci_host_data_write (opaque=0x555556d48d10, addr=0, val=326, len=2) at ../hw/pci/pci_host.c:167
+ * #14 0x0000555555c4d454 in memory_region_write_accessor (mr=0x555556d49120, addr=0, value=0x7fff317fd688, size=2, shift=0, mask=65535, attrs=...) at ../softmmu/memory.c:491
+ * #15 0x0000555555c4d678 in access_with_adjusted_size (addr=0, value=0x7fff317fd688, size=2, access_size_min=1, access_size_max=4, access_fn=
+ *     0x555555c4d36f <memory_region_write_accessor>, mr=0x555556d49120, attrs=...) at ../softmmu/memory.c:552
+ * #16 0x0000555555c50681 in memory_region_dispatch_write (mr=0x555556d49120, addr=0, data=326, op=MO_16, attrs=...) at ../softmmu/memory.c:1501
+ * #17 0x0000555555bd91bb in flatview_write_continue (fv=0x7fff24595d10, addr=3324, attrs=..., ptr=0x7ffff7fdf000, len=2, addr1=0, l=2, mr=0x555556d49120) at ../softmmu/physmem.c:2759
+ * #18 0x0000555555bd9300 in flatview_write (fv=0x7fff24595d10, addr=3324, attrs=..., buf=0x7ffff7fdf000, len=2) at ../softmmu/physmem.c:2799
+ * #19 0x0000555555bd966e in address_space_write (as=0x55555681a2e0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7fdf000, len=2) at ../softmmu/physmem.c:2891
+ * #20 0x0000555555bd96db in address_space_rw (as=0x55555681a2e0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7fdf000, len=2, is_write=true) at ../softmmu/physmem.c:2901
+ * #21 0x0000555555c2515a in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7fdf000, direction=1, size=2, count=1) at ../accel/kvm/kvm-all.c:2285
+ * #22 0x0000555555c25911 in kvm_cpu_exec (cpu=0x555556b3ba10) at ../accel/kvm/kvm-all.c:2531
+ * #23 0x0000555555c801fe in kvm_vcpu_thread_fn (arg=0x555556b3ba10) at ../accel/kvm/kvm-cpus.c:49
+ * #24 0x0000555555e40abc in qemu_thread_start (args=0x555556b621d0) at ../util/qemu-thread-posix.c:521
+ * #25 0x00007ffff542fea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #26 0x00007ffff51588cd in clone () at /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/vfio/common.c|635| <<vfio_iommu_map_notify>> ret = vfio_dma_map(container, iova,
+ *   - hw/vfio/common.c|838| <<vfio_listener_region_add>> ret = vfio_dma_map(container, iova, int128_get64(llsize),
+ */
 static int vfio_dma_map(VFIOContainer *container, hwaddr iova,
                         ram_addr_t size, void *vaddr, bool readonly)
 {
@@ -501,6 +603,12 @@ static int vfio_dma_map(VFIOContainer *container, hwaddr iova,
     return -errno;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|810| <<vfio_listener_region_add>> vfio_host_win_add(container, section->offset_within_address_space,
+ *   - hw/vfio/common.c|1882| <<vfio_connect_container>> vfio_host_win_add(container, 0, (hwaddr)-1, info->iova_pgsizes);
+ *   - hw/vfio/common.c|1952| <<vfio_connect_container>> vfio_host_win_add(container, info.dma32_window_start,
+ */
 static void vfio_host_win_add(VFIOContainer *container,
                               hwaddr min_iova, hwaddr max_iova,
                               uint64_t iova_pgsizes)
@@ -553,6 +661,11 @@ static bool vfio_listener_skipped_section(MemoryRegionSection *section)
 }
 
 /* Called with rcu_read_lock held.  */
+/*
+ * called by:
+ *   - hw/vfio/common.c|716| <<vfio_iommu_map_notify>> if (!vfio_get_xlat_addr(iotlb, &vaddr, NULL, &read_only)) {
+ *   - hw/vfio/common.c|1156| <<vfio_iommu_map_dirty_notify>> if (vfio_get_xlat_addr(iotlb, NULL, &translated_addr, NULL)) {
+ */
 static bool vfio_get_xlat_addr(IOMMUTLBEntry *iotlb, void **vaddr,
                                ram_addr_t *ram_addr, bool *read_only)
 {
@@ -600,6 +713,10 @@ static bool vfio_get_xlat_addr(IOMMUTLBEntry *iotlb, void **vaddr,
     return true;
 }
 
+/*
+ * 在以下使用vfio_iommu_map_notify():
+ *   - hw/vfio/common.c|789| <<vfio_listener_region_add>> iommu_notifier_init(&giommu->n, vfio_iommu_map_notify,
+ */
 static void vfio_iommu_map_notify(IOMMUNotifier *n, IOMMUTLBEntry *iotlb)
 {
     VFIOGuestIOMMU *giommu = container_of(n, VFIOGuestIOMMU, n);
@@ -1044,6 +1161,15 @@ typedef struct {
     VFIOGuestIOMMU *giommu;
 } vfio_giommu_dirty_notifier;
 
+/*
+ * 只在vfio_sync_dirty_bitmap()使用:
+ * 1217                 iommu_notifier_init(&gdn.n,
+ * 1218                                     vfio_iommu_map_dirty_notify,
+ * 1219                                     IOMMU_NOTIFIER_MAP,
+ * 1220                                     section->offset_within_region,
+ * 1221                                     int128_get64(llend),
+ * 1222                                     idx);
+ */
 static void vfio_iommu_map_dirty_notify(IOMMUNotifier *n, IOMMUTLBEntry *iotlb)
 {
     vfio_giommu_dirty_notifier *gdn = container_of(n,
@@ -1133,12 +1259,21 @@ static void vfio_listerner_log_sync(MemoryListener *listener,
     }
 }
 
+/*
+ * 在以下使用vfio_memory_listener:
+ *   - hw/vfio/common.c|1851| <<vfio_connect_container>> container->listener = vfio_memory_listener;
+ */
 static const MemoryListener vfio_memory_listener = {
     .region_add = vfio_listener_region_add,
     .region_del = vfio_listener_region_del,
     .log_sync = vfio_listerner_log_sync,
 };
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|2012| <<vfio_connect_container>> vfio_listener_release(container);
+ *   - hw/vfio/common.c|2040| <<vfio_disconnect_container>> vfio_listener_release(container);
+ */
 static void vfio_listener_release(VFIOContainer *container)
 {
     memory_listener_unregister(&container->listener);
@@ -1191,6 +1326,10 @@ vfio_get_device_info_cap(struct vfio_device_info *info, uint16_t id)
     return vfio_get_cap((void *)info, info->cap_offset, id);
 }
 
+/*
+ * called only by:
+ *   - hw/s390x/s390-pci-vfio.c|58| <<s390_pci_update_dma_avail>> return vfio_get_info_dma_avail(info, avail);
+ */
 bool vfio_get_info_dma_avail(struct vfio_iommu_type1_info *info,
                              unsigned int *avail)
 {
@@ -1212,6 +1351,10 @@ bool vfio_get_info_dma_avail(struct vfio_iommu_type1_info *info,
     return true;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1416| <<vfio_region_setup>> ret = vfio_setup_region_sparse_mmaps(region, info);
+ */
 static int vfio_setup_region_sparse_mmaps(VFIORegion *region,
                                           struct vfio_region_info *info)
 {
@@ -1304,6 +1447,14 @@ static void vfio_subregion_unmap(VFIORegion *region, int index)
     region->mmaps[index].mmap = NULL;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/display.c|444| <<vfio_display_region_update>> ret = vfio_region_mmap(&dpy->region.buffer);
+ *   - hw/vfio/migration.c|456| <<vfio_save_setup>> ret = vfio_region_mmap(&migration->region);
+ *   - hw/vfio/migration.c|630| <<vfio_load_setup>> ret = vfio_region_mmap(&migration->region);
+ *   - hw/vfio/pci.c|1649| <<vfio_bar_register>> if (vfio_region_mmap(&bar->region)) {
+ *   - hw/vfio/platform.c|659| <<vfio_platform_realize>> if (vfio_region_mmap(vdev->regions[i])) {
+ */
 int vfio_region_mmap(VFIORegion *region)
 {
     int i, prot = 0;
@@ -1316,6 +1467,14 @@ int vfio_region_mmap(VFIORegion *region)
     prot |= region->flags & VFIO_REGION_INFO_FLAG_READ ? PROT_READ : 0;
     prot |= region->flags & VFIO_REGION_INFO_FLAG_WRITE ? PROT_WRITE : 0;
 
+    /*
+     * 在以下修改VFIORegion:
+     *   - hw/vfio/common.c|1389| <<vfio_setup_region_sparse_mmaps>> region->nr_mmaps = j;
+     *   - hw/vfio/common.c|1423| <<vfio_region_setup>> region->nr_mmaps = 1;
+     *   - hw/vfio/common.c|1569| <<vfio_region_finalize>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1300| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1322| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 2;
+     */
     for (i = 0; i < region->nr_mmaps; i++) {
         region->mmaps[i].mmap = mmap(NULL, region->mmaps[i].size, prot,
                                      MAP_SHARED, region->vbasedev->fd,
@@ -1461,6 +1620,11 @@ void vfio_reset_handler(void *opaque)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1874| <<vfio_connect_container>> vfio_kvm_device_add_group(group);
+ *   - hw/vfio/common.c|2004| <<vfio_connect_container>> vfio_kvm_device_add_group(group);
+ */
 static void vfio_kvm_device_add_group(VFIOGroup *group)
 {
 #ifdef CONFIG_KVM
@@ -1514,10 +1678,28 @@ static void vfio_kvm_device_del_group(VFIOGroup *group)
 #endif
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1752| <<vfio_connect_container>> space = vfio_get_address_space(as);
+ *   - hw/vfio/common.c|2294| <<vfio_eeh_as_container>> VFIOAddressSpace *space = vfio_get_address_space(as);
+ */
 static VFIOAddressSpace *vfio_get_address_space(AddressSpace *as)
 {
+    /*
+     * typedef struct VFIOAddressSpace {
+     *     AddressSpace *as;
+     *     QLIST_HEAD(, VFIOContainer) containers;
+     *     QLIST_ENTRY(VFIOAddressSpace) list;
+     * } VFIOAddressSpace;
+     */
     VFIOAddressSpace *space;
 
+    /*
+     * 在以下使用vfio_address_spaces:
+     *   - hw/vfio/common.c|46| <<QLIST_HEAD>> QLIST_HEAD_INITIALIZER(vfio_address_spaces);
+     *   - hw/vfio/common.c|1594| <<vfio_get_address_space>> QLIST_FOREACH(space, &vfio_address_spaces, list) {
+     *   - hw/vfio/common.c|1605| <<vfio_get_address_space>> QLIST_INSERT_HEAD(&vfio_address_spaces, space, list);
+     */
     QLIST_FOREACH(space, &vfio_address_spaces, list) {
         if (space->as == as) {
             return space;
@@ -1665,6 +1847,10 @@ static void vfio_get_iommu_info_migration(VFIOContainer *container,
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1970| <<vfio_get_group>> if (vfio_connect_container(group, as, errp)) {
+ */
 static int vfio_connect_container(VFIOGroup *group, AddressSpace *as,
                                   Error **errp)
 {
@@ -1923,6 +2109,13 @@ static void vfio_disconnect_container(VFIOGroup *group)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/ap.c|86| <<vfio_ap_get_group>> return vfio_get_group(groupid, &address_space_memory, errp);
+ *   - hw/vfio/ccw.c|627| <<vfio_ccw_get_group>> return vfio_get_group(groupid, &address_space_memory, errp);
+ *   - hw/vfio/pci.c|2824| <<vfio_realize>> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
+ *   - hw/vfio/platform.c|580| <<vfio_base_device_init>> group = vfio_get_group(groupid, &address_space_memory, errp);
+ */
 VFIOGroup *vfio_get_group(int groupid, AddressSpace *as, Error **errp)
 {
     VFIOGroup *group;
@@ -2243,6 +2436,14 @@ bool vfio_eeh_as_ok(AddressSpace *as)
     return (container != NULL) && vfio_eeh_container_ok(container);
 }
 
+/*
+ * 只被ppc调用:
+ *   - hw/ppc/spapr_pci_vfio.c|37| <<spapr_phb_vfio_eeh_reenable>> vfio_eeh_as_op(&sphb->iommu_as, VFIO_EEH_PE_ENABLE);
+ *   - hw/ppc/spapr_pci_vfio.c|90| <<spapr_phb_vfio_eeh_set_option>> ret = vfio_eeh_as_op(&sphb->iommu_as, op);
+ *   - hw/ppc/spapr_pci_vfio.c|102| <<spapr_phb_vfio_eeh_get_state>> ret = vfio_eeh_as_op(&sphb->iommu_as, VFIO_EEH_PE_GET_STATE);
+ *   - hw/ppc/spapr_pci_vfio.c|175| <<spapr_phb_vfio_eeh_reset>> ret = vfio_eeh_as_op(&sphb->iommu_as, op);
+ *   - hw/ppc/spapr_pci_vfio.c|187| <<spapr_phb_vfio_eeh_configure>> ret = vfio_eeh_as_op(&sphb->iommu_as, VFIO_EEH_PE_CONFIGURE);
+ */
 int vfio_eeh_as_op(AddressSpace *as, uint32_t op)
 {
     VFIOContainer *container = vfio_eeh_as_container(as);
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 51dc37369..f9c7ff758 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -330,6 +330,11 @@ static void vfio_intx_disable(VFIOPCIDevice *vdev)
 /*
  * MSI/X
  */
+/*
+ * 在以下使用vfio_msi_interrupt():
+ *   - hw/vfio/pci.c|540| <<vfio_msix_vector_use>> return vfio_msix_vector_do_use(pdev, nr, &msg, vfio_msi_interrupt);
+ *   - hw/vfio/pci.c|623| <<vfio_msi_enable>> qemu_set_fd_handler(event_notifier_get_fd(&vector->interrupt), vfio_msi_interrupt, NULL, vector);
+ */
 static void vfio_msi_interrupt(void *opaque)
 {
     VFIOMSIVector *vector = opaque;
@@ -1047,6 +1052,10 @@ static const MemoryRegionOps vfio_vga_ops = {
  * size of this sub-page BAR when its base address is changed in guest
  * and not page aligned any more.
  */
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1191| <<vfio_pci_write_config>> vfio_sub_page_bar_update_mapping(pdev, bar);
+ */
 static void vfio_sub_page_bar_update_mapping(PCIDevice *pdev, int bar)
 {
     VFIOPCIDevice *vdev = VFIO_PCI(pdev);
@@ -1502,6 +1511,10 @@ static void vfio_msix_early_setup(VFIOPCIDevice *vdev, Error **errp)
     vfio_pci_relocate_msix(vdev, errp);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2023| <<vfio_add_std_cap>> ret = vfio_msix_setup(vdev, pos, errp);
+ */
 static int vfio_msix_setup(VFIOPCIDevice *vdev, int pos, Error **errp)
 {
     int ret;
@@ -1620,6 +1633,19 @@ static void vfio_bars_prepare(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * 184 memory-region: pci
+ * 185   0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+ * ... ...
+ * 191     00000000fe000000-00000000fe7fffff (prio 1, i/o): 0000:03:00.3 base BAR 0
+ * 192       00000000fe000000-00000000fe7fffff (prio 0, i/o): 0000:03:00.3 BAR 0
+ * 193         00000000fe000000-00000000fe7fffff (prio 0, ramd): 0000:03:00.3 BAR 0 mmaps[0]
+ * 194     00000000fe800000-00000000fe807fff (prio 1, i/o): 0000:03:00.3 base BAR 3
+ * 195       00000000fe800000-00000000fe80080f (prio 0, i/o): msix-table
+ * 196       00000000fe800000-00000000fe807fff (prio 0, i/o): 0000:03:00.3 BAR 3
+ * 197         00000000fe801000-00000000fe807fff (prio 0, ramd): 0000:03:00.3 BAR 3 mmaps[0]
+ * 198       00000000fe801000-00000000fe801017 (prio 0, i/o): msix-pba [disabled]
+ */
 static void vfio_bar_register(VFIOPCIDevice *vdev, int nr)
 {
     VFIOBAR *bar = &vdev->bars[nr];
@@ -1631,21 +1657,42 @@ static void vfio_bar_register(VFIOPCIDevice *vdev, int nr)
 
     bar->mr = g_new0(MemoryRegion, 1);
     name = g_strdup_printf("%s base BAR %d", vdev->vbasedev.name, nr);
+    /*
+     * VFIOBAR *bar = &vdev->bars[nr]:
+     * -> VFIORegion region;
+     *    -> MemoryRegion *mem;
+     * -> MemoryRegion *mr; --> "base BAR"
+     */
     memory_region_init_io(bar->mr, OBJECT(vdev), NULL, NULL, name, bar->size);
     g_free(name);
 
     if (bar->region.size) {
         memory_region_add_subregion(bar->mr, 0, bar->region.mem);
 
+	/*
+	 * 这里非常重要!!!
+	 */
         if (vfio_region_mmap(&bar->region)) {
             error_report("Failed to mmap %s BAR %d. Performance may be slow",
                          vdev->vbasedev.name, nr);
         }
     }
 
+    /*
+     * VFIOBAR *bar = &vdev->bars[nr]:
+     * -> VFIORegion region;
+     *    -> MemoryRegion *mem;
+     * -> MemoryRegion *mr;
+     *
+     * 在pci_update_mappings()会把bar->mr挂到pci的memory上
+     */
     pci_register_bar(&vdev->pdev, nr, bar->type, bar->mr);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2979| <<vfio_realize>> vfio_bars_register(vdev);
+ */
 static void vfio_bars_register(VFIOPCIDevice *vdev)
 {
     int i;
@@ -1916,6 +1963,11 @@ static void vfio_check_af_flr(VFIOPCIDevice *vdev, uint8_t pos)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1944| <<vfio_add_std_cap>> ret = vfio_add_std_cap(vdev, next, errp);
+ *   - hw/vfio/pci.c|2102| <<vfio_add_capabilities>> ret = vfio_add_std_cap(vdev, pdev->config[PCI_CAPABILITY_LIST], errp);
+ */
 static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos, Error **errp)
 {
     PCIDevice *pdev = &vdev->pdev;
@@ -2758,6 +2810,10 @@ static void vfio_unregister_req_notifier(VFIOPCIDevice *vdev)
     vdev->req_enabled = false;
 }
 
+/*
+ * 在以下使用vfio_realize():
+ *   - hw/vfio/pci.c|3248| <<vfio_pci_dev_class_init>> pdc->realize = vfio_realize;
+ */
 static void vfio_realize(PCIDevice *pdev, Error **errp)
 {
     VFIOPCIDevice *vdev = VFIO_PCI(pdev);
@@ -2791,6 +2847,11 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
         return;
     }
 
+    /*
+     * VFIOPCIDevice *vdev:
+     * -> PCIDevice pdev;
+     * -> VFIODevice vbasedev;
+     */
     vdev->vbasedev.name = g_path_get_basename(vdev->vbasedev.sysfsdev);
     vdev->vbasedev.ops = &vfio_pci_ops;
     vdev->vbasedev.type = VFIO_DEVICE_TYPE_PCI;
@@ -2816,6 +2877,11 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
 
     trace_vfio_realize(vdev->vbasedev.name, groupid);
 
+    /*
+     * 在以下调用pci_device_iommu_address_space():
+     *   - hw/pci/pci.c|96| <<pci_init_bus_master>> AddressSpace *dma_as = pci_device_iommu_address_space(pci_dev);
+     *   - hw/vfio/pci.c|2824| <<vfio_realize>> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
+     */
     group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
     if (!group) {
         goto error;
@@ -2951,6 +3017,15 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
 
     vfio_bars_prepare(vdev);
 
+    /*
+     * 注释.
+     * We don't have any control over how pci_add_capability() inserts
+     * capabilities into the chain.  In order to setup MSI-X we need a
+     * MemoryRegion for the BAR.  In order to setup the BAR and not
+     * attempt to mmap the MSI-X table area, which VFIO won't allow, we
+     * need to first look for where the MSI-X table lives.  So we
+     * unfortunately split MSI-X setup across two functions.
+     */
     vfio_msix_early_setup(vdev, &err);
     if (err) {
         error_propagate(errp, err);
diff --git a/hw/virtio/vhost.c b/hw/virtio/vhost.c
index 614ccc2bc..ccb708e38 100644
--- a/hw/virtio/vhost.c
+++ b/hw/virtio/vhost.c
@@ -1128,6 +1128,25 @@ static int vhost_virtqueue_start(struct vhost_dev *dev,
     /* Clear and discard previous events if any. */
     event_notifier_test_and_clear(&vq->masked_notifier);
 
+    /*
+     * Since guest_mask_notifier can not be used in vhost-user mode due
+     * to buffering implied by unix control socket, force
+     * use_mask_notifier on virtio devices of vhost-user interfaces, and
+     * send correct callfd to the guest at vhost start.
+     *
+     * Using guest_notifier_mask function in vhost-user case may
+     * break interrupt mask paradigm, because mask/unmask is not
+     * really done when returning from guest_notifier_mask call, instead
+     * message is posted in a unix socket, and processed later.
+     *
+     * Add an option boolean flag 'use_mask_notifier' to disable the use
+     * of guest_notifier_mask in virtio pci.
+     *
+     * 在以下使用VirtIODevice->use_guest_notifier_mask:
+     *   - backends/cryptodev-vhost.c|197| <<cryptodev_vhost_start>> dev->use_guest_notifier_mask = false;
+     *   - hw/net/vhost_net.c|343| <<vhost_net_start>> dev->use_guest_notifier_mask = false;
+     *   - hw/virtio/virtio.c|3533| <<virtio_init>> vdev->use_guest_notifier_mask = true;
+     */
     /* Init vring in unmasked state, unless guest_notifier_mask
      * will do it later.
      */
diff --git a/hw/virtio/virtio-bus.c b/hw/virtio/virtio-bus.c
index d6332d45c..af43d7814 100644
--- a/hw/virtio/virtio-bus.c
+++ b/hw/virtio/virtio-bus.c
@@ -40,6 +40,10 @@ do { printf("virtio_bus: " fmt , ## __VA_ARGS__); } while (0)
 #endif
 
 /* A VirtIODevice is being plugged */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|3880| <<virtio_device_realize>> virtio_bus_device_plugged(vdev, &err);
+ */
 void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
 {
     DeviceState *qdev = DEVICE(vdev);
@@ -86,6 +90,11 @@ void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
 }
 
 /* Reset the virtio_bus */
+/*
+ * called by:
+ *   - hw/virtio/virtio-mmio.c|591| <<virtio_mmio_reset>> virtio_bus_reset(&proxy->bus);
+ *   - hw/virtio/virtio-pci.c|1874| <<virtio_pci_reset>> virtio_bus_reset(bus);
+ */
 void virtio_bus_reset(VirtioBusState *bus)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -97,6 +106,10 @@ void virtio_bus_reset(VirtioBusState *bus)
 }
 
 /* A VirtIODevice is being unplugged */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|3896| <<virtio_device_unrealize>> virtio_bus_device_unplugged(vdev);
+ */
 void virtio_bus_device_unplugged(VirtIODevice *vdev)
 {
     DeviceState *qdev = DEVICE(vdev);
@@ -113,6 +126,12 @@ void virtio_bus_device_unplugged(VirtIODevice *vdev)
 }
 
 /* Get the device id of the plugged device. */
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|1152| <<virtio_ccw_device_plugged>> sch->id.cu_model = virtio_bus_get_vdev_id(&dev->bus);
+ *   - hw/virtio/virtio-pci.c|1627| <<virtio_pci_device_plugged>> pci_set_word(config + PCI_SUBSYSTEM_ID, virtio_bus_get_vdev_id(bus));
+ *   - hw/virtio/virtio-pci.c|1633| <<virtio_pci_device_plugged>> 0x1040 + virtio_bus_get_vdev_id(bus));
+ */
 uint16_t virtio_bus_get_vdev_id(VirtioBusState *bus)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -121,6 +140,10 @@ uint16_t virtio_bus_get_vdev_id(VirtioBusState *bus)
 }
 
 /* Get the config_len field of the plugged device. */
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1709| <<virtio_pci_device_plugged>> + virtio_bus_get_vdev_config_len(bus);
+ */
 size_t virtio_bus_get_vdev_config_len(VirtioBusState *bus)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -129,6 +152,10 @@ size_t virtio_bus_get_vdev_config_len(VirtioBusState *bus)
 }
 
 /* Get bad features of the plugged device. */
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|310| <<virtio_ioport_write>> val = virtio_bus_get_vdev_bad_features(&proxy->bus);
+ */
 uint32_t virtio_bus_get_vdev_bad_features(VirtioBusState *bus)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -144,6 +171,10 @@ uint32_t virtio_bus_get_vdev_bad_features(VirtioBusState *bus)
 }
 
 /* Get config of the plugged device. */
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|447| <<virtio_ccw_cb>> virtio_bus_get_vdev_config(&dev->bus, vdev->config);
+ */
 void virtio_bus_get_vdev_config(VirtioBusState *bus, uint8_t *config)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -157,6 +188,10 @@ void virtio_bus_get_vdev_config(VirtioBusState *bus, uint8_t *config)
 }
 
 /* Set config of the plugged device. */
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|466| <<virtio_ccw_cb>> virtio_bus_set_vdev_config(&dev->bus, vdev->config);
+ */
 void virtio_bus_set_vdev_config(VirtioBusState *bus, uint8_t *config)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -170,6 +205,10 @@ void virtio_bus_set_vdev_config(VirtioBusState *bus, uint8_t *config)
 }
 
 /* On success, ioeventfd ownership belongs to the caller.  */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|4035| <<virtio_device_grab_ioeventfd>> return virtio_bus_grab_ioeventfd(vbus);
+ */
 int virtio_bus_grab_ioeventfd(VirtioBusState *bus)
 {
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(bus);
@@ -192,6 +231,10 @@ int virtio_bus_grab_ioeventfd(VirtioBusState *bus)
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|4043| <<virtio_device_release_ioeventfd>> virtio_bus_release_ioeventfd(vbus);
+ */
 void virtio_bus_release_ioeventfd(VirtioBusState *bus)
 {
     assert(bus->ioeventfd_grabbed != 0);
@@ -202,6 +245,14 @@ void virtio_bus_release_ioeventfd(VirtioBusState *bus)
     }
 }
 
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|133| <<virtio_ccw_start_ioeventfd>> virtio_bus_start_ioeventfd(&dev->bus);
+ *   - hw/virtio/virtio-bus.c|201| <<virtio_bus_release_ioeventfd>> virtio_bus_start_ioeventfd(bus);
+ *   - hw/virtio/virtio-mmio.c|60| <<virtio_mmio_start_ioeventfd>> virtio_bus_start_ioeventfd(&proxy->bus);
+ *   - hw/virtio/virtio-pci.c|292| <<virtio_pci_start_ioeventfd>> virtio_bus_start_ioeventfd(&proxy->bus);
+ *   - hw/virtio/virtio.c|4001| <<virtio_device_start_ioeventfd>> return virtio_bus_start_ioeventfd(vbus);
+ */
 int virtio_bus_start_ioeventfd(VirtioBusState *bus)
 {
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(bus);
@@ -210,6 +261,9 @@ int virtio_bus_start_ioeventfd(VirtioBusState *bus)
     VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(vdev);
     int r;
 
+    /*
+     * 比如virtio_pci_ioeventfd_enabled()
+     */
     if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
         return -ENOSYS;
     }
@@ -219,16 +273,43 @@ int virtio_bus_start_ioeventfd(VirtioBusState *bus)
 
     /* Only set our notifier if we have ownership.  */
     if (!bus->ioeventfd_grabbed) {
+        /*
+	 * 在以下调用VirtioDeviceClass->start_ioeventfd:
+	 *   - hw/virtio/virtio-bus.c|243| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+	 * 在以下使用VirtioDeviceClass->start_ioeventfd:
+	 *   - hw/block/virtio-blk.c|1330| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start;
+	 *   - hw/scsi/virtio-scsi.c|1082| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+	 *   - hw/virtio/virtio.c|4056| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+	 */
         r = vdc->start_ioeventfd(vdev);
         if (r < 0) {
             error_report("%s: failed. Fallback to userspace (slower).", __func__);
             return r;
         }
     }
+    /*
+     * 在以下设置VirtioBusState->ioeventfd_started:
+     *   - hw/virtio/virtio-bus.c|228| <<virtio_bus_grab_ioeventfd>> bus->ioeventfd_started = true;
+     *   - hw/virtio/virtio-bus.c|243| <<virtio_bus_release_ioeventfd>> bus->ioeventfd_started = false;
+     *   - hw/virtio/virtio-bus.c|279| <<virtio_bus_start_ioeventfd>> bus->ioeventfd_started = true;
+     *   - hw/virtio/virtio-bus.c|305| <<virtio_bus_stop_ioeventfd>> bus->ioeventfd_started = false;
+     * 在以下使用VirtioBusState->ioeventfd_started:
+     *   - hw/virtio/virtio-bus.c|223| <<virtio_bus_grab_ioeventfd>> if (bus->ioeventfd_grabbed == 0 && bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|241| <<virtio_bus_release_ioeventfd>> if (--bus->ioeventfd_grabbed == 0 && bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|267| <<virtio_bus_start_ioeventfd>> if (bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|295| <<virtio_bus_stop_ioeventfd>> if (!bus->ioeventfd_started) {
+     */
     bus->ioeventfd_started = true;
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|138| <<virtio_ccw_stop_ioeventfd>> virtio_bus_stop_ioeventfd(&dev->bus);
+ *   - hw/virtio/virtio-bus.c|198| <<virtio_bus_grab_ioeventfd>> virtio_bus_stop_ioeventfd(bus);
+ *   - hw/virtio/virtio-mmio.c|65| <<virtio_mmio_stop_ioeventfd>> virtio_bus_stop_ioeventfd(&proxy->bus);
+ *   - hw/virtio/virtio-pci.c|297| <<virtio_pci_stop_ioeventfd>> virtio_bus_stop_ioeventfd(&proxy->bus);
+ */
 void virtio_bus_stop_ioeventfd(VirtioBusState *bus)
 {
     VirtIODevice *vdev;
@@ -247,11 +328,31 @@ void virtio_bus_stop_ioeventfd(VirtioBusState *bus)
     bus->ioeventfd_started = false;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|888| <<virtio_blk_dma_restart_cb>> if (!s->bh && !virtio_bus_ioeventfd_enabled(bus)) {
+ *   - hw/virtio/virtio.c|4078| <<virtio_device_ioeventfd_enabled>> return virtio_bus_ioeventfd_enabled(vbus);
+ */
 bool virtio_bus_ioeventfd_enabled(VirtioBusState *bus)
 {
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(bus);
     DeviceState *proxy = DEVICE(BUS(bus)->parent);
 
+    /*
+     * 在以下设置VirtioBusClass->ioeventfd_assign:
+     *   - hw/s390x/virtio-ccw.c|1242| <<virtio_ccw_bus_class_init>> k->ioeventfd_assign = virtio_ccw_ioeventfd_assign;
+     *   - hw/virtio/virtio-mmio.c|780| <<virtio_mmio_bus_class_init>> k->ioeventfd_assign = virtio_mmio_ioeventfd_assign;
+     *   - hw/virtio/virtio-pci.c|2141| <<virtio_pci_bus_class_init>> k->ioeventfd_assign = virtio_pci_ioeventfd_assign;
+     * 在以下使用VirtioBusClass->ioeventfd_assign:
+     *   - hw/block/dataplane/virtio-blk.c|100| <<virtio_blk_data_plane_create>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|37| <<virtio_scsi_dataplane_setup>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|193| <<virtio_bus_grab_ioeventfd>> if (!k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|234| <<virtio_bus_start_ioeventfd>> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
+     *   - hw/virtio/virtio-bus.c|276| <<virtio_bus_ioeventfd_enabled>> return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
+     *   - hw/virtio/virtio-bus.c|292| <<virtio_bus_set_host_notifier>> if (!k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|303| <<virtio_bus_set_host_notifier>> r = k->ioeventfd_assign(proxy, notifier, n, true);
+     *   - hw/virtio/virtio-bus.c|309| <<virtio_bus_set_host_notifier>> k->ioeventfd_assign(proxy, notifier, n, false);
+     */
     return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
 }
 
@@ -259,6 +360,21 @@ bool virtio_bus_ioeventfd_enabled(VirtioBusState *bus)
  * This function switches ioeventfd on/off in the device.
  * The caller must set or clear the handlers for the EventNotifier.
  */
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|207| <<virtio_blk_data_plane_start>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, true);
+ *   - hw/block/dataplane/virtio-blk.c|211| <<virtio_blk_data_plane_start>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/block/dataplane/virtio-blk.c|310| <<virtio_blk_data_plane_stop>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|117| <<virtio_scsi_vring_init>> rc = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), n, true);
+ *   - hw/scsi/virtio-scsi-dataplane.c|197| <<virtio_scsi_dataplane_start>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|236| <<virtio_scsi_dataplane_stop>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/virtio/vhost.c|1445| <<vhost_dev_enable_notifiers>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i,
+ *   - hw/virtio/vhost.c|1456| <<vhost_dev_enable_notifiers>> e = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i,
+ *   - hw/virtio/vhost.c|1480| <<vhost_dev_disable_notifiers>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i,
+ *   - hw/virtio/virtio.c|3953| <<virtio_device_start_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, true);
+ *   - hw/virtio/virtio.c|3982| <<virtio_device_start_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, false);
+ *   - hw/virtio/virtio.c|4017| <<virtio_device_stop_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, false);
+ */
 int virtio_bus_set_host_notifier(VirtioBusState *bus, int n, bool assign)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -279,6 +395,23 @@ int virtio_bus_set_host_notifier(VirtioBusState *bus, int n, bool assign)
                          __func__, strerror(-r), r);
             return r;
         }
+	/*
+	 * 在以下设置VirtioBusClass->ioeventfd_assign:
+	 *   - hw/s390x/virtio-ccw.c|1242| <<virtio_ccw_bus_class_init>> k->ioeventfd_assign = virtio_ccw_ioeventfd_assign;
+	 *   - hw/virtio/virtio-mmio.c|780| <<virtio_mmio_bus_class_init>> k->ioeventfd_assign = virtio_mmio_ioeventfd_assign;
+	 *   - hw/virtio/virtio-pci.c|2141| <<virtio_pci_bus_class_init>> k->ioeventfd_assign = virtio_pci_ioeventfd_assign;
+	 * 在以下使用VirtioBusClass->ioeventfd_assign:
+	 *   - hw/block/dataplane/virtio-blk.c|100| <<virtio_blk_data_plane_create>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+	 *   - hw/scsi/virtio-scsi-dataplane.c|37| <<virtio_scsi_dataplane_setup>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+	 *   - hw/virtio/virtio-bus.c|193| <<virtio_bus_grab_ioeventfd>> if (!k->ioeventfd_assign) {
+	 *   - hw/virtio/virtio-bus.c|234| <<virtio_bus_start_ioeventfd>> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
+	 *   - hw/virtio/virtio-bus.c|276| <<virtio_bus_ioeventfd_enabled>> return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
+	 *   - hw/virtio/virtio-bus.c|292| <<virtio_bus_set_host_notifier>> if (!k->ioeventfd_assign) {
+	 *   - hw/virtio/virtio-bus.c|303| <<virtio_bus_set_host_notifier>> r = k->ioeventfd_assign(proxy, notifier, n, true);
+	 *   - hw/virtio/virtio-bus.c|309| <<virtio_bus_set_host_notifier>> k->ioeventfd_assign(proxy, notifier, n, false);
+	 *
+	 * 比如virtio_pci_ioeventfd_assign(), 就是向kernel注册一个eventfd (把地址和fd绑定)
+	 */
         r = k->ioeventfd_assign(proxy, notifier, n, true);
         if (r < 0) {
             error_report("%s: unable to assign ioeventfd: %d", __func__, r);
@@ -295,6 +428,18 @@ int virtio_bus_set_host_notifier(VirtioBusState *bus, int n, bool assign)
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|212| <<virtio_blk_data_plane_start>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/block/dataplane/virtio-blk.c|311| <<virtio_blk_data_plane_stop>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/scsi/virtio-scsi-dataplane.c|198| <<virtio_scsi_dataplane_start>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/scsi/virtio-scsi-dataplane.c|237| <<virtio_scsi_dataplane_stop>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/virtio/vhost.c|1462| <<vhost_dev_enable_notifiers>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i);
+ *   - hw/virtio/vhost.c|1486| <<vhost_dev_disable_notifiers>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i);
+ *   - hw/virtio/virtio-bus.c|306| <<virtio_bus_set_host_notifier>> virtio_bus_cleanup_host_notifier(bus, n);
+ *   - hw/virtio/virtio.c|3991| <<virtio_device_start_ioeventfd_impl>> virtio_bus_cleanup_host_notifier(qbus, i);
+ *   - hw/virtio/virtio.c|4026| <<virtio_device_stop_ioeventfd_impl>> virtio_bus_cleanup_host_notifier(qbus, n);
+ */
 void virtio_bus_cleanup_host_notifier(VirtioBusState *bus, int n)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -308,6 +453,10 @@ void virtio_bus_cleanup_host_notifier(VirtioBusState *bus, int n)
     event_notifier_cleanup(notifier);
 }
 
+/*
+ * 在以下使用virtio_bus_get_dev_path():
+ *   - hw/virtio/virtio-bus.c|347| <<virtio_bus_class_init>> bus_class->get_dev_path = virtio_bus_get_dev_path;
+ */
 static char *virtio_bus_get_dev_path(DeviceState *dev)
 {
     BusState *bus = qdev_get_parent_bus(dev);
@@ -315,11 +464,18 @@ static char *virtio_bus_get_dev_path(DeviceState *dev)
     return qdev_get_dev_path(proxy);
 }
 
+/*
+ * 在以下使用virtio_bus_get_fw_dev_path():
+ *   - hw/virtio/virtio-bus.c|348| <<virtio_bus_class_init>> bus_class->get_fw_dev_path = virtio_bus_get_fw_dev_path;
+ */
 static char *virtio_bus_get_fw_dev_path(DeviceState *dev)
 {
     return NULL;
 }
 
+/*
+ * TypeInfo virtio_bus_info.class_init = virtio_bus_class_init()
+ */
 static void virtio_bus_class_init(ObjectClass *klass, void *data)
 {
     BusClass *bus_class = BUS_CLASS(klass);
@@ -331,6 +487,7 @@ static const TypeInfo virtio_bus_info = {
     .name = TYPE_VIRTIO_BUS,
     .parent = TYPE_BUS,
     .instance_size = sizeof(VirtioBusState),
+    /* !!! abstract = true !!! */
     .abstract = true,
     .class_size = sizeof(VirtioBusClass),
     .class_init = virtio_bus_class_init
diff --git a/hw/virtio/virtio-pci.c b/hw/virtio/virtio-pci.c
index 36524a572..6316dd078 100644
--- a/hw/virtio/virtio-pci.c
+++ b/hw/virtio/virtio-pci.c
@@ -64,6 +64,10 @@ static inline VirtIOPCIProxy *to_virtio_pci_proxy_fast(DeviceState *d)
     return container_of(d, VirtIOPCIProxy, pci_dev.qdev);
 }
 
+/*
+ * 在以下使用virtio_pci_notify():
+ *   - hw/virtio/virtio-pci.c|2120| <<virtio_pci_bus_class_init>> k->notify = virtio_pci_notify;
+ */
 static void virtio_pci_notify(DeviceState *d, uint16_t vector)
 {
     VirtIOPCIProxy *proxy = to_virtio_pci_proxy_fast(d);
@@ -211,6 +215,10 @@ static int virtio_pci_load_queue(DeviceState *d, int n, QEMUFile *f)
     return 0;
 }
 
+/*
+ * 在以下使用virtio_pci_ioeventfd_enabled():
+ *   - hw/virtio/virtio-pci.c|2146| <<virtio_pci_bus_class_init>> k->ioeventfd_enabled = virtio_pci_ioeventfd_enabled;
+ */
 static bool virtio_pci_ioeventfd_enabled(DeviceState *d)
 {
     VirtIOPCIProxy *proxy = to_virtio_pci_proxy(d);
@@ -283,6 +291,12 @@ static int virtio_pci_ioeventfd_assign(DeviceState *d, EventNotifier *notifier,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|339| <<virtio_ioport_write>> virtio_pci_start_ioeventfd(proxy);
+ *   - hw/virtio/virtio-pci.c|1090| <<virtio_pci_vmstate_change>> virtio_pci_start_ioeventfd(proxy);
+ *   - hw/virtio/virtio-pci.c|1265| <<virtio_pci_common_write>> virtio_pci_start_ioeventfd(proxy);
+ */
 static void virtio_pci_start_ioeventfd(VirtIOPCIProxy *proxy)
 {
     virtio_bus_start_ioeventfd(&proxy->bus);
@@ -935,6 +949,11 @@ static void virtio_pci_vector_poll(PCIDevice *dev,
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1020| <<virtio_pci_set_guest_notifiers>> r = virtio_pci_set_guest_notifier(d, n, assign, with_irqfd);
+ *   - hw/virtio/virtio-pci.c|1058| <<virtio_pci_set_guest_notifiers>> virtio_pci_set_guest_notifier(d, n, !assign, with_irqfd);
+ */
 static int virtio_pci_set_guest_notifier(DeviceState *d, int n, bool assign,
                                          bool with_irqfd)
 {
@@ -2102,6 +2121,12 @@ unsigned virtio_pci_optimal_num_queues(unsigned fixed_queues)
 
 /* virtio-pci-bus */
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1865| <<virtio_pci_realize>> virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);
+ *
+ * 比如为virtio-blk-pci设备创建一个local的virtio bus, 用来挂virtio-blk
+ */
 static void virtio_pci_bus_new(VirtioBusState *bus, size_t bus_size,
                                VirtIOPCIProxy *dev)
 {
diff --git a/hw/virtio/virtio-scsi-pci.c b/hw/virtio/virtio-scsi-pci.c
index 97fab7423..d5375493d 100644
--- a/hw/virtio/virtio-scsi-pci.c
+++ b/hw/virtio/virtio-scsi-pci.c
@@ -35,6 +35,10 @@ struct VirtIOSCSIPCI {
     VirtIOSCSI vdev;
 };
 
+/*
+ * 在以下使用virtio_scsi_pci_properties:
+ *   - hw/virtio/virtio-scsi-pci.c|84| <<virtio_scsi_pci_class_init>> device_class_set_props(dc, virtio_scsi_pci_properties);
+ */
 static Property virtio_scsi_pci_properties[] = {
     DEFINE_PROP_BIT("ioeventfd", VirtIOPCIProxy, flags,
                     VIRTIO_PCI_FLAG_USE_IOEVENTFD_BIT, true),
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index ceb58fda6..00ec86db8 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -125,11 +125,64 @@ struct VirtQueue
     unsigned int inuse;
 
     uint16_t vector;
+    /*
+     * 在以下设置VirtQueue->handle_output:
+     *   - hw/virtio/virtio.c|2471| <<virtio_add_queue>> vdev->vq[i].handle_output = handle_output;
+     *   - hw/virtio/virtio.c|2483| <<virtio_delete_queue>> vq->handle_output = NULL;
+     * 在以下使用VirtQueue->handle_output:
+     *   - hw/virtio/virtio.c|2382| <<virtio_queue_notify_vq>> if (vq->vring.desc && vq->handle_output) {
+     *   - hw/virtio/virtio.c|2390| <<virtio_queue_notify_vq>> vq->handle_output(vdev, vq);
+     *   - hw/virtio/virtio.c|2423| <<virtio_queue_notify>> } else if (vq->handle_output) {
+     *   - hw/virtio/virtio.c|2424| <<virtio_queue_notify>> vq->handle_output(vdev, vq);
+     */
     VirtIOHandleOutput handle_output;
+    /*
+     * 在以下设置VirtQueue->handle_aio_output:
+     *   - hw/virtio/virtio.c|2472| <<virtio_add_queue>> vdev->vq[i].handle_aio_output = NULL;
+     *   - hw/virtio/virtio.c|2484| <<virtio_delete_queue>> vq->handle_aio_output = NULL;
+     *   - hw/virtio/virtio.c|3781| <<virtio_queue_aio_set_host_notifier_handler>> vq->handle_aio_output = handle_output;
+     *   - hw/virtio/virtio.c|3793| <<virtio_queue_aio_set_host_notifier_handler>> vq->handle_aio_output = NULL;
+     * 在以下使用VirtQueue->handle_aio_output:
+     *   - hw/virtio/virtio.c|2366| <<virtio_queue_notify_aio_vq>> if (vq->vring.desc && vq->handle_aio_output) {
+     *   - hw/virtio/virtio.c|2370| <<virtio_queue_notify_aio_vq>> ret = vq->handle_aio_output(vdev, vq);
+     */
     VirtIOHandleAIOOutput handle_aio_output;
     VirtIODevice *vdev;
+    /*
+     * 在以下使用VirtQueue->guest_notifier:
+     *   - hw/virtio/virtio.c|2560| <<virtio_notify_irqfd>> event_notifier_set(&vq->guest_notifier);
+     *   - hw/virtio/virtio.c|3563| <<virtio_queue_guest_notifier_read>> VirtQueue *vq = container_of(n, VirtQueue, guest_notifier);
+     *   - hw/virtio/virtio.c|3573| <<virtio_queue_set_guest_notifier_fd_handler>> event_notifier_set_handler(&vq->guest_notifier,
+     *   - hw/virtio/virtio.c|3576| <<virtio_queue_set_guest_notifier_fd_handler>> event_notifier_set_handler(&vq->guest_notifier, NULL);
+     *   - hw/virtio/virtio.c|3581| <<virtio_queue_set_guest_notifier_fd_handler>> virtio_queue_guest_notifier_read(&vq->guest_notifier);
+     *   - hw/virtio/virtio.c|3587| <<virtio_queue_get_guest_notifier>> return &vq->guest_notifier;
+     */
     EventNotifier guest_notifier;
+    /*
+     * 在以下使用VirtQueue->host_notifier:
+     *   - hw/virtio/virtio.c|2381| <<virtio_queue_notify>> event_notifier_set(&vq->host_notifier);
+     *   - hw/virtio/virtio.c|3615| <<virtio_queue_host_notifier_aio_read>> VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
+     *   - hw/virtio/virtio.c|3623| <<virtio_queue_host_notifier_aio_poll_begin>> VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
+     *   - hw/virtio/virtio.c|3631| <<virtio_queue_host_notifier_aio_poll>> VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
+     *   - hw/virtio/virtio.c|3642| <<virtio_queue_host_notifier_aio_poll_end>> VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
+     *   - hw/virtio/virtio.c|3653| <<virtio_queue_aio_set_host_notifier_handler>> aio_set_event_notifier(ctx, &vq->host_notifier, true,
+     *   - hw/virtio/virtio.c|3656| <<virtio_queue_aio_set_host_notifier_handler>> aio_set_event_notifier_poll(ctx, &vq->host_notifier,
+     *   - hw/virtio/virtio.c|3660| <<virtio_queue_aio_set_host_notifier_handler>> aio_set_event_notifier(ctx, &vq->host_notifier, true, NULL, NULL);
+     *   - hw/virtio/virtio.c|3663| <<virtio_queue_aio_set_host_notifier_handler>> virtio_queue_host_notifier_aio_read(&vq->host_notifier);
+     *   - hw/virtio/virtio.c|3670| <<virtio_queue_host_notifier_read>> VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
+     *   - hw/virtio/virtio.c|3678| <<virtio_queue_get_host_notifier>> return &vq->host_notifier;
+     *   - hw/virtio/virtio.c|3829| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier,
+     *   - hw/virtio/virtio.c|3839| <<virtio_device_start_ioeventfd_impl>> event_notifier_set(&vq->host_notifier);
+     *   - hw/virtio/virtio.c|3852| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier, NULL);
+     *   - hw/virtio/virtio.c|3887| <<virtio_device_stop_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier, NULL);
+     */
     EventNotifier host_notifier;
+    /*
+     * 在以下使用VirtQueue->host_notifier_enabled:
+     *   - hw/virtio/virtio.c|2380| <<virtio_queue_notify>> if (vq->host_notifier_enabled) {
+     *   - hw/virtio/virtio.c|3354| <<virtio_init>> vdev->vq[i].host_notifier_enabled = false;
+     *   - hw/virtio/virtio.c|3683| <<virtio_queue_set_host_notifier_enabled>> vq->host_notifier_enabled = enabled;
+     */
     bool host_notifier_enabled;
     QLIST_ENTRY(VirtQueue) node;
 };
@@ -1898,6 +1951,14 @@ void qemu_put_virtqueue_element(VirtIODevice *vdev, QEMUFile *f,
 }
 
 /* virtio device */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1950| <<virtio_update_irq>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ *   - hw/virtio/virtio.c|2046| <<virtio_reset>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|2618| <<virtio_irq>> virtio_notify_vector(vq->vdev, vq->vector);
+ *   - hw/virtio/virtio.c|2693| <<virtio_notify_config>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|3195| <<virtio_load>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ */
 static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
@@ -1907,6 +1968,9 @@ static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)
         return;
     }
 
+    /*
+     * 比如virtio_pci_notify()
+     */
     if (k->notify) {
         k->notify(qbus->parent, vector);
     }
@@ -2333,6 +2397,10 @@ static bool virtio_queue_notify_aio_vq(VirtQueue *vq)
     return ret;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|3821| <<virtio_queue_host_notifier_read>> virtio_queue_notify_vq(vq);
+ */
 static void virtio_queue_notify_vq(VirtQueue *vq)
 {
     if (vq->vring.desc && vq->handle_output) {
@@ -2351,6 +2419,14 @@ static void virtio_queue_notify_vq(VirtQueue *vq)
     }
 }
 
+/*
+ * called by:
+ *   - hw/s390x/s390-virtio-ccw.c|137| <<virtio_ccw_hcall_notify>> virtio_queue_notify(virtio_ccw_get_vdev(sch), queue);
+ *   - hw/virtio/virtio-mmio.c|369| <<virtio_mmio_write>> virtio_queue_notify(vdev, value);
+ *   - hw/virtio/virtio-pci.c|324| <<virtio_ioport_write>> virtio_queue_notify(vdev, val);
+ *   - hw/virtio/virtio-pci.c|1343| <<virtio_pci_notify_write>> virtio_queue_notify(vdev, queue);
+ *   - hw/virtio/virtio-pci.c|1356| <<virtio_pci_notify_write_pio>> virtio_queue_notify(vdev, queue);
+ */
 void virtio_queue_notify(VirtIODevice *vdev, int n)
 {
     VirtQueue *vq = &vdev->vq[n];
@@ -2360,6 +2436,12 @@ void virtio_queue_notify(VirtIODevice *vdev, int n)
     }
 
     trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
+    /*
+     * 在以下使用VirtQueue->host_notifier_enabled:
+     *   - hw/virtio/virtio.c|2380| <<virtio_queue_notify>> if (vq->host_notifier_enabled) {
+     *   - hw/virtio/virtio.c|3354| <<virtio_init>> vdev->vq[i].host_notifier_enabled = false;
+     *   - hw/virtio/virtio.c|3683| <<virtio_queue_set_host_notifier_enabled>> vq->host_notifier_enabled = enabled;
+     */
     if (vq->host_notifier_enabled) {
         event_notifier_set(&vq->host_notifier);
     } else if (vq->handle_output) {
@@ -2394,6 +2476,19 @@ void virtio_queue_set_vector(VirtIODevice *vdev, int n, uint16_t vector)
     }
 }
 
+/*
+ * 部分使用virtio_add_queue()的例子:
+ *   - hw/block/vhost-user-blk.c|464| <<vhost_user_blk_device_realize>> s->virtqs[i] = virtio_add_queue(vdev, s->queue_size, vhost_user_blk_handle_output);
+ *   - hw/block/virtio-blk.c|1282| <<virtio_blk_device_realize>> virtio_add_queue(vdev, conf->queue_size, virtio_blk_handle_output);
+ *   - hw/net/virtio-net.c|2639| <<virtio_net_add_queue>> n->vqs[index].rx_vq = virtio_add_queue(vdev, n->net_conf.rx_queue_size, virtio_net_handle_rx);
+ *   - hw/net/virtio-net.c|2644| <<virtio_net_add_queue>> virtio_add_queue(vdev, n->net_conf.tx_queue_size, virtio_net_handle_tx_timer);
+ *   - hw/net/virtio-net.c|2651| <<virtio_net_add_queue>> virtio_add_queue(vdev, n->net_conf.tx_queue_size, virtio_net_handle_tx_bh);
+ *   - hw/net/virtio-net.c|2713| <<virtio_net_change_num_queues>> n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
+ *   - hw/net/virtio-net.c|3362| <<virtio_net_device_realize>> n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
+ *   - hw/scsi/virtio-scsi.c|975| <<virtio_scsi_common_realize>> s->ctrl_vq = virtio_add_queue(vdev, s->conf.virtqueue_size, ctrl);
+ *   - hw/scsi/virtio-scsi.c|976| <<virtio_scsi_common_realize>> s->event_vq = virtio_add_queue(vdev, s->conf.virtqueue_size, evt);
+ *   - hw/scsi/virtio-scsi.c|978| <<virtio_scsi_common_realize>> s->cmd_vqs[i] = virtio_add_queue(vdev, s->conf.virtqueue_size, cmd);
+ */
 VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,
                             VirtIOHandleOutput handle_output)
 {
@@ -2438,6 +2533,12 @@ void virtio_del_queue(VirtIODevice *vdev, int n)
     virtio_delete_queue(&vdev->vq[n]);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|2559| <<virtio_notify_irqfd>> virtio_set_isr(vq->vdev, 0x1);
+ *   - hw/virtio/virtio.c|2570| <<virtio_irq>> virtio_set_isr(vq->vdev, 0x1);
+ *   - hw/virtio/virtio.c|2644| <<virtio_notify_config>> virtio_set_isr(vdev, 0x3);
+ */
 static void virtio_set_isr(VirtIODevice *vdev, int value)
 {
     uint8_t old = qatomic_read(&vdev->isr);
@@ -2516,6 +2617,11 @@ static bool virtio_packed_should_notify(VirtIODevice *vdev, VirtQueue *vq)
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|2584| <<virtio_notify_irqfd>> if (!virtio_should_notify(vdev, vq)) {
+ *   - hw/virtio/virtio.c|2659| <<virtio_notify>> if (!virtio_should_notify(vdev, vq)) {
+ */
 static bool virtio_should_notify(VirtIODevice *vdev, VirtQueue *vq)
 {
     if (virtio_vdev_has_feature(vdev, VIRTIO_F_RING_PACKED)) {
@@ -2525,6 +2631,12 @@ static bool virtio_should_notify(VirtIODevice *vdev, VirtQueue *vq)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|55| <<virtio_blk_data_plane_notify>> virtio_notify_irqfd(s->vdev, vq);
+ *   - hw/block/dataplane/virtio-blk.c|76| <<notify_guest_bh>> virtio_notify_irqfd(s->vdev, vq);
+ *   - hw/scsi/virtio-scsi.c|76| <<virtio_scsi_complete_req>> virtio_notify_irqfd(vdev, vq);
+ */
 void virtio_notify_irqfd(VirtIODevice *vdev, VirtQueue *vq)
 {
     WITH_RCU_READ_LOCK_GUARD() {
@@ -2551,15 +2663,64 @@ void virtio_notify_irqfd(VirtIODevice *vdev, VirtQueue *vq)
      * to an atomic operation.
      */
     virtio_set_isr(vq->vdev, 0x1);
+    /*
+     * 在以下使用VirtQueue->guest_notifier:
+     *   - hw/virtio/virtio.c|2560| <<virtio_notify_irqfd>> event_notifier_set(&vq->guest_notifier);
+     *   - hw/virtio/virtio.c|3563| <<virtio_queue_guest_notifier_read>> VirtQueue *vq = container_of(n, VirtQueue, guest_notifier);
+     *   - hw/virtio/virtio.c|3573| <<virtio_queue_set_guest_notifier_fd_handler>> event_notifier_set_handler(&vq->guest_notifier,
+     *   - hw/virtio/virtio.c|3576| <<virtio_queue_set_guest_notifier_fd_handler>> event_notifier_set_handler(&vq->guest_notifier, NULL);
+     *   - hw/virtio/virtio.c|3581| <<virtio_queue_set_guest_notifier_fd_handler>> virtio_queue_guest_notifier_read(&vq->guest_notifier);
+     *   - hw/virtio/virtio.c|3587| <<virtio_queue_get_guest_notifier>> return &vq->guest_notifier;
+     */
     event_notifier_set(&vq->guest_notifier);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|2607| <<virtio_notify>> virtio_irq(vq);
+ *   - hw/virtio/virtio.c|3536| <<virtio_queue_guest_notifier_read>> virtio_irq(vq);
+ */
 static void virtio_irq(VirtQueue *vq)
 {
     virtio_set_isr(vq->vdev, 0x1);
     virtio_notify_vector(vq->vdev, vq->vector);
 }
 
+/*
+ * called by:
+ *   - hw/9pfs/virtio-9p-device.c|38| <<virtio_9p_push_and_notify>> virtio_notify(VIRTIO_DEVICE(v), v->vq);
+ *   - hw/block/virtio-blk.c|89| <<virtio_blk_req_complete>> virtio_notify(vdev, req->vq);
+ *   - hw/char/virtio-serial-bus.c|130| <<write_to_port>> virtio_notify(VIRTIO_DEVICE(port->vser), vq);
+ *   - hw/char/virtio-serial-bus.c|149| <<discard_vq_data>> virtio_notify(vdev, vq);
+ *   - hw/char/virtio-serial-bus.c|212| <<do_flush_queued_data>> virtio_notify(vdev, vq);
+ *   - hw/char/virtio-serial-bus.c|244| <<send_control_msg>> virtio_notify(VIRTIO_DEVICE(vser), vq);
+ *   - hw/char/virtio-serial-bus.c|496| <<control_out>> virtio_notify(vdev, vq);
+ *   - hw/display/virtio-gpu.c|181| <<virtio_gpu_ctrl_response>> virtio_notify(VIRTIO_DEVICE(g), cmd->vq);
+ *   - hw/display/virtio-gpu.c|928| <<virtio_gpu_handle_cursor>> virtio_notify(vdev, vq);
+ *   - hw/input/virtio-input.c|68| <<virtio_input_send>> virtio_notify(VIRTIO_DEVICE(vinput), vinput->evt);
+ *   - hw/input/virtio-input.c|100| <<virtio_input_handle_sts>> virtio_notify(vdev, vinput->sts);
+ *   - hw/net/virtio-net.c|345| <<virtio_net_drop_tx_queue_data>> virtio_notify(vdev, vq);
+ *   - hw/net/virtio-net.c|1394| <<virtio_net_handle_ctrl>> virtio_notify(vdev, vq);
+ *   - hw/net/virtio-net.c|1774| <<virtio_net_receive_rcu>> virtio_notify(vdev, q->rx_vq);
+ *   - hw/net/virtio-net.c|2401| <<virtio_net_tx_complete>> virtio_notify(vdev, q->tx_vq);
+ *   - hw/net/virtio-net.c|2496| <<virtio_net_flush_tx>> virtio_notify(vdev, q->tx_vq);
+ *   - hw/scsi/virtio-scsi.c|78| <<virtio_scsi_complete_req>> virtio_notify(vdev, vq);
+ *   - hw/virtio/vhost-vsock-common.c|142| <<vhost_vsock_common_send_transport_reset>> virtio_notify(VIRTIO_DEVICE(vvc), vq);
+ *   - hw/virtio/virtio-balloon.c|230| <<balloon_stats_poll_cb>> virtio_notify(vdev, s->svq);
+ *   - hw/virtio/virtio-balloon.c|379| <<virtio_balloon_handle_report>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-balloon.c|437| <<virtio_balloon_handle_output>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-balloon.c|459| <<virtio_balloon_receive_stats>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-balloon.c|568| <<virtio_ballloon_get_free_page_hints>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-crypto.c|291| <<virtio_crypto_handle_ctrl>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-crypto.c|307| <<virtio_crypto_handle_ctrl>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-crypto.c|323| <<virtio_crypto_handle_ctrl>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-crypto.c|411| <<virtio_crypto_req_complete>> virtio_notify(vdev, req->vq);
+ *   - hw/virtio/virtio-iommu.c|642| <<virtio_iommu_handle_command>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-iommu.c|685| <<virtio_iommu_report_fault>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-mem.c|187| <<virtio_mem_send_response>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-pmem.c|61| <<done_cb>> virtio_notify((VirtIODevice *)req_data->pmem, req_data->pmem->rq_vq);
+ *   - hw/virtio/virtio-rng.c|85| <<chr_read>> virtio_notify(vdev, vrng->vq);
+ */
 void virtio_notify(VirtIODevice *vdev, VirtQueue *vq)
 {
     WITH_RCU_READ_LOCK_GUARD() {
@@ -2569,9 +2730,32 @@ void virtio_notify(VirtIODevice *vdev, VirtQueue *vq)
     }
 
     trace_virtio_notify(vdev, vq);
+    /*
+     * called by:
+     *   - hw/virtio/virtio.c|2607| <<virtio_notify>> virtio_irq(vq);
+     *   - hw/virtio/virtio.c|3536| <<virtio_queue_guest_notifier_read>> virtio_irq(vq);
+     */
     virtio_irq(vq);
 }
 
+/*
+ * called by:
+ *   - hw/block/vhost-user-blk.c|98| <<vhost_user_blk_handle_config_change>> virtio_notify_config(dev->vdev);
+ *   - hw/block/virtio-blk.c|1122| <<virtio_resize_cb>> virtio_notify_config(vdev);
+ *   - hw/char/virtio-serial-bus.c|1006| <<virtser_port_device_plug>> virtio_notify_config(VIRTIO_DEVICE(hotplug_dev));
+ *   - hw/display/virtio-gpu-base.c|70| <<virtio_gpu_notify_event>> virtio_notify_config(&g->parent_obj);
+ *   - hw/input/vhost-user-input.c|77| <<vhost_input_set_config>> virtio_notify_config(vdev);
+ *   - hw/input/virtio-input.c|183| <<virtio_input_set_config>> virtio_notify_config(vdev);
+ *   - hw/net/virtio-net.c|198| <<virtio_net_announce_notify>> virtio_notify_config(vdev);
+ *   - hw/net/virtio-net.c|418| <<virtio_net_set_link_status>> virtio_notify_config(vdev);
+ *   - hw/virtio/vhost-user-vsock.c|43| <<vuv_handle_config_change>> virtio_notify_config(dev->vdev);
+ *   - hw/virtio/virtio-balloon.c|607| <<virtio_balloon_free_page_start>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-balloon.c|627| <<virtio_balloon_free_page_stop>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-balloon.c|640| <<virtio_balloon_free_page_done>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-balloon.c|823| <<virtio_balloon_to_target>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-mem.c|819| <<virtio_mem_set_requested_size>> virtio_notify_config(VIRTIO_DEVICE(vmem));
+ *   - hw/virtio/virtio.c|3663| <<virtio_error>> virtio_notify_config(vdev);
+ */
 void virtio_notify_config(VirtIODevice *vdev)
 {
     if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK))
@@ -3226,6 +3410,50 @@ static void virtio_vmstate_change(void *opaque, int running, RunState state)
     }
 }
 
+/*
+ * called by:
+ *   - hw/display/vhost-user-gpu-pci.c|31| <<vhost_user_gpu_pci_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/display/vhost-user-vga.c|32| <<vhost_user_vga_inst_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/display/virtio-gpu-pci.c|82| <<virtio_gpu_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/display/virtio-vga.c|239| <<virtio_vga_inst_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/vhost-user-fs-ccw.c|48| <<vhost_user_fs_ccw_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/vhost-vsock-ccw.c|46| <<vhost_vsock_ccw_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-9p.c|31| <<virtio_ccw_9p_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-balloon.c|31| <<virtio_ccw_balloon_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-blk.c|31| <<virtio_ccw_blk_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-crypto.c|34| <<virtio_ccw_crypto_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-gpu.c|32| <<virtio_ccw_gpu_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-input.c|50| <<virtio_ccw_keyboard_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-input.c|60| <<virtio_ccw_mouse_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-input.c|70| <<virtio_ccw_tablet_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-net.c|34| <<virtio_ccw_net_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-rng.c|33| <<virtio_ccw_rng_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-scsi.c|43| <<virtio_ccw_scsi_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-scsi.c|87| <<vhost_ccw_scsi_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-serial.c|44| <<virtio_ccw_serial_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-scsi-pci.c|83| <<vhost_scsi_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-user-blk-pci.c|88| <<vhost_user_blk_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-user-fs-pci.c|69| <<vhost_user_fs_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-user-input-pci.c|31| <<vhost_user_input_pci_instance_init>> virtio_instance_init_common(obj, &dev->vhi, sizeof(dev->vhi),
+ *   - hw/virtio/vhost-user-scsi-pci.c|89| <<vhost_user_scsi_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-user-vsock-pci.c|68| <<vhost_user_vsock_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-vsock-pci.c|78| <<vhost_vsock_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-9p-pci.c|72| <<virtio_9p_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-balloon-pci.c|73| <<virtio_balloon_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-blk-pci.c|86| <<virtio_blk_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-crypto-pci.c|79| <<virtio_crypto_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-input-host-pci.c|31| <<virtio_host_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-input-pci.c|85| <<virtio_keyboard_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-input-pci.c|93| <<virtio_mouse_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-input-pci.c|101| <<virtio_tablet_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-iommu-pci.c|95| <<virtio_iommu_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-mem-pci.c|128| <<virtio_mem_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-net-pci.c|79| <<virtio_net_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pmem-pci.c|109| <<virtio_pmem_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-rng-pci.c|63| <<virtio_rng_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-scsi-pci.c|95| <<virtio_scsi_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-serial-pci.c|98| <<virtio_serial_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ */
 void virtio_instance_init_common(Object *proxy_obj, void *data,
                                  size_t vdev_size, const char *vdev_name)
 {
@@ -3237,6 +3465,25 @@ void virtio_instance_init_common(Object *proxy_obj, void *data,
     qdev_alias_all_properties(vdev, proxy_obj);
 }
 
+/*
+ * called by:
+ *   - hw/9pfs/virtio-9p-device.c|214| <<virtio_9p_device_realize>> virtio_init(vdev, "virtio-9p", VIRTIO_ID_9P, v->config_size);
+ *   - hw/block/vhost-user-blk.c|459| <<vhost_user_blk_device_realize>> virtio_init(vdev, "virtio-blk", VIRTIO_ID_BLOCK,
+ *   - hw/block/virtio-blk.c|1212| <<virtio_blk_device_realize>> virtio_init(vdev, "virtio-blk", VIRTIO_ID_BLOCK, s->config_size);
+ *   - hw/char/virtio-serial-bus.c|1049| <<virtio_serial_device_realize>> virtio_init(vdev, "virtio-serial", VIRTIO_ID_CONSOLE,
+ *   - hw/display/virtio-gpu-base.c|150| <<virtio_gpu_base_device_realize>> virtio_init(VIRTIO_DEVICE(g), "virtio-gpu", VIRTIO_ID_GPU,
+ *   - hw/input/virtio-input.c|260| <<virtio_input_device_realize>> virtio_init(vdev, "virtio-input", VIRTIO_ID_INPUT,
+ *   - hw/net/virtio-net.c|3298| <<virtio_net_device_realize>> virtio_init(vdev, "virtio-net", VIRTIO_ID_NET, n->config_size);
+ *   - hw/scsi/virtio-scsi.c|951| <<virtio_scsi_common_realize>> virtio_init(vdev, "virtio-scsi", VIRTIO_ID_SCSI,
+ *   - hw/virtio/vhost-user-fs.c|208| <<vuf_device_realize>> virtio_init(vdev, "vhost-user-fs", VIRTIO_ID_FS,
+ *   - hw/virtio/vhost-vsock-common.c|204| <<vhost_vsock_common_realize>> virtio_init(vdev, name, VIRTIO_ID_VSOCK,
+ *   - hw/virtio/virtio-balloon.c|884| <<virtio_balloon_device_realize>> virtio_init(vdev, "virtio-balloon", VIRTIO_ID_BALLOON,
+ *   - hw/virtio/virtio-crypto.c|813| <<virtio_crypto_device_realize>> virtio_init(vdev, "virtio-crypto", VIRTIO_ID_CRYPTO, vcrypto->config_size);
+ *   - hw/virtio/virtio-iommu.c|956| <<virtio_iommu_device_realize>> virtio_init(vdev, "virtio-iommu", VIRTIO_ID_IOMMU,
+ *   - hw/virtio/virtio-mem.c|572| <<virtio_mem_device_realize>> virtio_init(vdev, TYPE_VIRTIO_MEM, VIRTIO_ID_MEM,
+ *   - hw/virtio/virtio-pmem.c|122| <<virtio_pmem_realize>> virtio_init(vdev, TYPE_VIRTIO_PMEM, VIRTIO_ID_PMEM,
+ *   - hw/virtio/virtio-rng.c|218| <<virtio_rng_device_realize>> virtio_init(vdev, "virtio-rng", VIRTIO_ID_RNG, 0);
+ */
 void virtio_init(VirtIODevice *vdev, const char *name,
                  uint16_t device_id, size_t config_size)
 {
@@ -3264,6 +3511,12 @@ void virtio_init(VirtIODevice *vdev, const char *name,
         vdev->vq[i].vector = VIRTIO_NO_VECTOR;
         vdev->vq[i].vdev = vdev;
         vdev->vq[i].queue_index = i;
+	/*
+	 * 在以下使用VirtQueue->host_notifier_enabled:
+	 *   - hw/virtio/virtio.c|2380| <<virtio_queue_notify>> if (vq->host_notifier_enabled) {
+	 *   - hw/virtio/virtio.c|3354| <<virtio_init>> vdev->vq[i].host_notifier_enabled = false;
+	 *   - hw/virtio/virtio.c|3683| <<virtio_queue_set_host_notifier_enabled>> vq->host_notifier_enabled = enabled;
+	 */
         vdev->vq[i].host_notifier_enabled = false;
     }
 
@@ -3523,6 +3776,11 @@ EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
     return &vq->guest_notifier;
 }
 
+/*
+ * 在以下使用virtio_queue_host_notifier_aio_read():
+ *   - hw/virtio/virtio.c|3807| <<virtio_queue_aio_set_host_notifier_handler>> aio_set_event_notifier(ctx, &vq->host_notifier, true, virtio_queue_host_notifier_aio_read, virtio_queue_host_notifier_aio_poll);
+ *   - hw/virtio/virtio.c|3816| <<virtio_queue_aio_set_host_notifier_handler>> virtio_queue_host_notifier_aio_read(&vq->host_notifier);
+ */
 static void virtio_queue_host_notifier_aio_read(EventNotifier *n)
 {
     VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
@@ -3578,6 +3836,11 @@ void virtio_queue_aio_set_host_notifier_handler(VirtQueue *vq, AioContext *ctx,
     }
 }
 
+/*
+ * 在以下使用virtio_queue_host_notifier_read():
+ *   - hw/virtio/virtio-bus.c|412| <<virtio_bus_cleanup_host_notifier>> virtio_queue_host_notifier_read(notifier);
+ *   - hw/virtio/virtio.c|3989| <<virtio_device_start_ioeventfd_impl>> virtio_queue_host_notifier_read);
+ */
 void virtio_queue_host_notifier_read(EventNotifier *n)
 {
     VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
@@ -3591,8 +3854,18 @@ EventNotifier *virtio_queue_get_host_notifier(VirtQueue *vq)
     return &vq->host_notifier;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-bus.c|422| <<virtio_bus_set_host_notifier>> virtio_queue_set_host_notifier_enabled(vq, assign);
+ */
 void virtio_queue_set_host_notifier_enabled(VirtQueue *vq, bool enabled)
 {
+    /*
+     * 在以下使用VirtQueue->host_notifier_enabled:
+     *   - hw/virtio/virtio.c|2380| <<virtio_queue_notify>> if (vq->host_notifier_enabled) {
+     *   - hw/virtio/virtio.c|3354| <<virtio_init>> vdev->vq[i].host_notifier_enabled = false;
+     *   - hw/virtio/virtio.c|3683| <<virtio_queue_set_host_notifier_enabled>> vq->host_notifier_enabled = enabled;
+     */
     vq->host_notifier_enabled = enabled;
 }
 
@@ -3723,6 +3996,10 @@ static Property virtio_properties[] = {
     DEFINE_PROP_END_OF_LIST(),
 };
 
+/*
+ * 在以下使用virtio_device_start_ioeventfd_impl():
+ *   - hw/virtio/virtio.c|4102| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+ */
 static int virtio_device_start_ioeventfd_impl(VirtIODevice *vdev)
 {
     VirtioBusState *qbus = VIRTIO_BUS(qdev_get_parent_bus(DEVICE(vdev)));
@@ -3777,6 +4054,13 @@ assign_error:
     return err;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|884| <<virtio_blk_handle_output>> virtio_device_start_ioeventfd(vdev);
+ *   - hw/scsi/virtio-scsi.c|467| <<virtio_scsi_handle_ctrl>> virtio_device_start_ioeventfd(vdev);
+ *   - hw/scsi/virtio-scsi.c|736| <<virtio_scsi_handle_cmd>> virtio_device_start_ioeventfd(vdev);
+ *   - hw/scsi/virtio-scsi.c|869| <<virtio_scsi_handle_event>> virtio_device_start_ioeventfd(vdev);
+ */
 int virtio_device_start_ioeventfd(VirtIODevice *vdev)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
@@ -3827,6 +4111,9 @@ void virtio_device_release_ioeventfd(VirtIODevice *vdev)
     virtio_bus_release_ioeventfd(vbus);
 }
 
+/*
+ * TypeInfo virtio_device_info.class_init = virtio_device_class_init()
+ */
 static void virtio_device_class_init(ObjectClass *klass, void *data)
 {
     /* Set the default value here. */
@@ -3837,12 +4124,27 @@ static void virtio_device_class_init(ObjectClass *klass, void *data)
     dc->unrealize = virtio_device_unrealize;
     dc->bus_type = TYPE_VIRTIO_BUS;
     device_class_set_props(dc, virtio_properties);
+    /*
+     * 在以下调用VirtioDeviceClass->start_ioeventfd:
+     *   - hw/virtio/virtio-bus.c|243| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+     * 在以下使用VirtioDeviceClass->start_ioeventfd:
+     *   - hw/block/virtio-blk.c|1330| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start;
+     *   - hw/scsi/virtio-scsi.c|1082| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+     *   - hw/virtio/virtio.c|4056| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+     */
     vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
     vdc->stop_ioeventfd = virtio_device_stop_ioeventfd_impl;
 
     vdc->legacy_features |= VIRTIO_LEGACY_FEATURES;
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|110| <<virtio_blk_data_plane_create>> if (!virtio_device_ioeventfd_enabled(vdev)) {
+ *   - hw/block/dataplane/virtio-blk.c|124| <<virtio_blk_data_plane_create>> if (!virtio_device_ioeventfd_enabled(vdev)) {
+ *   - hw/scsi/virtio-scsi-dataplane.c|43| <<virtio_scsi_dataplane_setup>> if (!virtio_device_ioeventfd_enabled(vdev)) {
+ *   - hw/scsi/virtio-scsi-dataplane.c|49| <<virtio_scsi_dataplane_setup>> if (!virtio_device_ioeventfd_enabled(vdev)) {
+ */
 bool virtio_device_ioeventfd_enabled(VirtIODevice *vdev)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
diff --git a/include/hw/vfio/vfio-common.h b/include/hw/vfio/vfio-common.h
index 6141162d7..96737dc29 100644
--- a/include/hw/vfio/vfio-common.h
+++ b/include/hw/vfio/vfio-common.h
@@ -53,6 +53,24 @@ typedef struct VFIORegion {
     MemoryRegion *mem; /* slow, read/write access */
     size_t size;
     uint32_t flags; /* VFIO region flags (rd/wr/mmap) */
+    /*
+     * 在以下修改VFIORegion:
+     *   - hw/vfio/common.c|1389| <<vfio_setup_region_sparse_mmaps>> region->nr_mmaps = j;
+     *   - hw/vfio/common.c|1423| <<vfio_region_setup>> region->nr_mmaps = 1;
+     *   - hw/vfio/common.c|1569| <<vfio_region_finalize>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1300| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1322| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 2;
+     * 在以下使用VFIORegion:
+     *   - hw/vfio/common.c|1424| <<vfio_region_setup>> region->mmaps = g_new0(VFIOMmap, region->nr_mmaps);
+     *   - hw/vfio/common.c|1470| <<vfio_region_mmap>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1521| <<vfio_region_unmap>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1536| <<vfio_region_exit>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1553| <<vfio_region_finalize>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1583| <<vfio_region_mmaps_set_enabled>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/migration.c|168| <<get_data_section_size>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/pci.c|1069| <<vfio_sub_page_bar_update_mapping>> if (region->nr_mmaps != 1 || !region->mmaps[0].mmap ||
+     *   - hw/vfio/pci.c|1281| <<vfio_pci_fixup_msix_region>> if (region->nr_mmaps != 1 || region->mmaps[0].offset ||
+     */
     uint32_t nr_mmaps;
     VFIOMmap *mmaps;
     uint8_t nr; /* cache the region number for debug */
@@ -146,6 +164,23 @@ typedef struct VFIOGroup {
     int fd;
     int groupid;
     VFIOContainer *container;
+    /*
+     * 在以下使用VFIOGroup->device_list:
+     *   - hw/vfio/ccw.c|570| <<vfio_ccw_get_device>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|314| <<vfio_mig_active>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|334| <<vfio_devices_all_saving>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|366| <<vfio_devices_all_running_and_saving>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|1521| <<vfio_reset_handler>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|1529| <<vfio_reset_handler>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|2045| <<vfio_get_group>> QLIST_INIT(&group->device_list);
+     *   - hw/vfio/common.c|2072| <<vfio_put_group>> if (!group || !QLIST_EMPTY(&group->device_list)) {
+     *   - hw/vfio/common.c|2122| <<vfio_get_device>> if (!QLIST_EMPTY(&group->device_list)) {
+     *   - hw/vfio/common.c|2137| <<vfio_get_device>> QLIST_INSERT_HEAD(&group->device_list, vbasedev, next);
+     *   - hw/vfio/pci.c|2266| <<vfio_pci_hot_reset>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/pci.c|2348| <<vfio_pci_hot_reset>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/pci.c|2829| <<vfio_realize>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/platform.c|585| <<vfio_base_device_init>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     */
     QLIST_HEAD(, VFIODevice) device_list;
     QLIST_ENTRY(VFIOGroup) next;
     QLIST_ENTRY(VFIOGroup) container_next;
diff --git a/include/hw/virtio/virtio-blk.h b/include/hw/virtio/virtio-blk.h
index 214ab7482..189c4819a 100644
--- a/include/hw/virtio/virtio-blk.h
+++ b/include/hw/virtio/virtio-blk.h
@@ -58,7 +58,31 @@ struct VirtIOBlock {
     unsigned short sector_mask;
     bool original_wce;
     VMChangeStateEntry *change;
+    /*
+     * 在以下设置VirtIOBlock->dataplane_disabled:
+     *   - hw/block/dataplane/virtio-blk.c|271| <<virtio_blk_data_plane_start>> vblk->dataplane_disabled = true;
+     *   - hw/block/dataplane/virtio-blk.c|317| <<virtio_blk_data_plane_stop>> vblk->dataplane_disabled = false;
+     * 在以下使用VirtIOBlock->dataplane_disabled:
+     *   - hw/block/dataplane/virtio-blk.c|316| <<virtio_blk_data_plane_stop>> if (vblk->dataplane_disabled) {
+     *   - hw/block/virtio-blk.c|100| <<virtio_blk_req_complete>> if (s->dataplane_started && !s->dataplane_disabled) {
+     *   - hw/block/virtio-blk.c|885| <<virtio_blk_handle_output>> if (!s->dataplane_disabled) {
+     */
     bool dataplane_disabled;
+    /*
+     * 在以下设置VirtIOBlock->dataplane_started:
+     *   - hw/block/dataplane/virtio-blk.c|235| <<virtio_blk_data_plane_start>> vblk->dataplane_started = true;
+     *   - hw/block/dataplane/virtio-blk.c|273| <<virtio_blk_data_plane_start>> vblk->dataplane_started = true;
+     *   - hw/block/dataplane/virtio-blk.c|318| <<virtio_blk_data_plane_stop>> vblk->dataplane_started = false;
+     *   - hw/block/dataplane/virtio-blk.c|344| <<virtio_blk_data_plane_stop>> vblk->dataplane_started = false;
+     * 在以下使用VirtIOBlock->dataplane_started:
+     *   - hw/block/dataplane/virtio-blk.c|161| <<virtio_blk_data_plane_destroy>> assert(!vblk->dataplane_started);
+     *   - hw/block/dataplane/virtio-blk.c|180| <<virtio_blk_data_plane_handle_output>> assert(s->dataplane_started);
+     *   - hw/block/dataplane/virtio-blk.c|201| <<virtio_blk_data_plane_start>> if (vblk->dataplane_started || s->starting) {
+     *   - hw/block/dataplane/virtio-blk.c|311| <<virtio_blk_data_plane_stop>> if (!vblk->dataplane_started || s->stopping) {
+     *   - hw/block/virtio-blk.c|100| <<virtio_blk_req_complete>> if (s->dataplane_started && !s->dataplane_disabled) {
+     *   - hw/block/virtio-blk.c|980| <<virtio_blk_reset>> assert(!s->dataplane_started);
+     *   - hw/block/virtio-blk.c|1102| <<virtio_blk_set_status>> assert(!s->dataplane_started);
+     */
     bool dataplane_started;
     struct VirtIOBlockDataPlane *dataplane;
     uint64_t host_features;
diff --git a/include/hw/virtio/virtio-bus.h b/include/hw/virtio/virtio-bus.h
index ef8abe49c..a4af2004d 100644
--- a/include/hw/virtio/virtio-bus.h
+++ b/include/hw/virtio/virtio-bus.h
@@ -80,6 +80,21 @@ struct VirtioBusClass {
      * the device for queue number n. Returns an error value on
      * failure.
      */
+    /*
+     * 在以下设置VirtioBusClass->ioeventfd_assign:
+     *   - hw/s390x/virtio-ccw.c|1242| <<virtio_ccw_bus_class_init>> k->ioeventfd_assign = virtio_ccw_ioeventfd_assign;
+     *   - hw/virtio/virtio-mmio.c|780| <<virtio_mmio_bus_class_init>> k->ioeventfd_assign = virtio_mmio_ioeventfd_assign;
+     *   - hw/virtio/virtio-pci.c|2141| <<virtio_pci_bus_class_init>> k->ioeventfd_assign = virtio_pci_ioeventfd_assign;
+     * 在以下使用VirtioBusClass->ioeventfd_assign:
+     *   - hw/block/dataplane/virtio-blk.c|100| <<virtio_blk_data_plane_create>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|37| <<virtio_scsi_dataplane_setup>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|193| <<virtio_bus_grab_ioeventfd>> if (!k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|234| <<virtio_bus_start_ioeventfd>> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
+     *   - hw/virtio/virtio-bus.c|276| <<virtio_bus_ioeventfd_enabled>> return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
+     *   - hw/virtio/virtio-bus.c|292| <<virtio_bus_set_host_notifier>> if (!k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|303| <<virtio_bus_set_host_notifier>> r = k->ioeventfd_assign(proxy, notifier, n, true);
+     *   - hw/virtio/virtio-bus.c|309| <<virtio_bus_set_host_notifier>> k->ioeventfd_assign(proxy, notifier, n, false);
+     */
     int (*ioeventfd_assign)(DeviceState *d, EventNotifier *notifier,
                             int n, bool assign);
     /*
@@ -101,6 +116,18 @@ struct VirtioBusState {
     /*
      * Set if ioeventfd has been started.
      */
+    /*
+     * 在以下设置VirtioBusState->ioeventfd_started:
+     *   - hw/virtio/virtio-bus.c|228| <<virtio_bus_grab_ioeventfd>> bus->ioeventfd_started = true;
+     *   - hw/virtio/virtio-bus.c|243| <<virtio_bus_release_ioeventfd>> bus->ioeventfd_started = false;
+     *   - hw/virtio/virtio-bus.c|279| <<virtio_bus_start_ioeventfd>> bus->ioeventfd_started = true;
+     *   - hw/virtio/virtio-bus.c|305| <<virtio_bus_stop_ioeventfd>> bus->ioeventfd_started = false;
+     * 在以下使用VirtioBusState->ioeventfd_started:
+     *   - hw/virtio/virtio-bus.c|223| <<virtio_bus_grab_ioeventfd>> if (bus->ioeventfd_grabbed == 0 && bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|241| <<virtio_bus_release_ioeventfd>> if (--bus->ioeventfd_grabbed == 0 && bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|267| <<virtio_bus_start_ioeventfd>> if (bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|295| <<virtio_bus_stop_ioeventfd>> if (!bus->ioeventfd_started) {
+     */
     bool ioeventfd_started;
 
     /*
diff --git a/include/hw/virtio/virtio-scsi.h b/include/hw/virtio/virtio-scsi.h
index 543681bc1..ad10c659e 100644
--- a/include/hw/virtio/virtio-scsi.h
+++ b/include/hw/virtio/virtio-scsi.h
@@ -82,14 +82,65 @@ struct VirtIOSCSI {
 
     SCSIBus bus;
     int resetting;
+    /*
+     * 在以下使用VirtIOSCSI->events_dropped:
+     *   - hw/scsi/virtio-scsi.c|805| <<virtio_scsi_reset>> s->events_dropped = false;
+     *   - hw/scsi/virtio-scsi.c|822| <<virtio_scsi_push_event>> s->events_dropped = true;
+     *   - hw/scsi/virtio-scsi.c|826| <<virtio_scsi_push_event>> if (s->events_dropped) {
+     *   - hw/scsi/virtio-scsi.c|828| <<virtio_scsi_push_event>> s->events_dropped = false;
+     *   - hw/scsi/virtio-scsi.c|857| <<virtio_scsi_handle_event_vq>> if (s->events_dropped) {
+     */
     bool events_dropped;
 
     /* Fields for dataplane below */
     AioContext *ctx; /* one iothread per virtio-scsi-pci for now */
 
+    /*
+     * 在以下设置VirtIOSCSI->dataplane_started:
+     *   - hw/scsi/virtio-scsi-dataplane.c|189| <<virtio_scsi_dataplane_start>> s->dataplane_started = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|204| <<virtio_scsi_dataplane_start>> s->dataplane_started = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|224| <<virtio_scsi_dataplane_stop>> s->dataplane_started = false;
+     *   - hw/scsi/virtio-scsi-dataplane.c|243| <<virtio_scsi_dataplane_stop>> s->dataplane_started = false;
+     * 在以下使用VirtIOSCSI->dataplane_started:
+     *   - hw/scsi/virtio-scsi-dataplane.c|67| <<virtio_scsi_data_plane_handle_cmd>> assert(s->ctx && s->dataplane_started);
+     *   - hw/scsi/virtio-scsi-dataplane.c|85| <<virtio_scsi_data_plane_handle_ctrl>> assert(s->ctx && s->dataplane_started);
+     *   - hw/scsi/virtio-scsi-dataplane.c|98| <<virtio_scsi_data_plane_handle_event>> assert(s->ctx && s->dataplane_started);
+     *   - hw/scsi/virtio-scsi-dataplane.c|153| <<virtio_scsi_dataplane_start>> if (s->dataplane_started ||
+     *   - hw/scsi/virtio-scsi-dataplane.c|217| <<virtio_scsi_dataplane_stop>> if (!s->dataplane_started || s->dataplane_stopping) {
+     *   - hw/scsi/virtio-scsi.c|82| <<virtio_scsi_complete_req>> if (s->dataplane_started && !s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|256| <<virtio_scsi_ctx_check>> if (s->dataplane_started && d && blk_is_available(d->conf.blk)) {
+     *   - hw/scsi/virtio-scsi.c|798| <<virtio_scsi_reset>> assert(!s->dataplane_started);
+     */
     bool dataplane_started;
+    /*
+     * 在以下使用VirtIOSCSI->dataplane_starting:
+     *   - hw/scsi/virtio-scsi-dataplane.c|159| <<virtio_scsi_dataplane_start>> s->dataplane_starting = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|188| <<virtio_scsi_dataplane_start>> s->dataplane_starting = false;
+     *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>> s->dataplane_starting = false;
+     *   - hw/scsi/virtio-scsi-dataplane.c|154| <<virtio_scsi_dataplane_start>> s->dataplane_starting ||
+     */
     bool dataplane_starting;
+    /*
+     * 在以下使用VirtIOSCSI->dataplane_stopping:
+     *   - hw/scsi/virtio-scsi-dataplane.c|227| <<virtio_scsi_dataplane_stop>> s->dataplane_stopping = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|242| <<virtio_scsi_dataplane_stop>> s->dataplane_stopping = false;
+     *   - hw/scsi/virtio-scsi-dataplane.c|217| <<virtio_scsi_dataplane_stop>> if (!s->dataplane_started || s->dataplane_stopping) {
+     */
     bool dataplane_stopping;
+    /*
+     * 在以下设置VirtIOSCSI->dataplane_fenced:
+     *   - hw/scsi/virtio-scsi-dataplane.c|121| <<virtio_scsi_vring_init>> s->dataplane_fenced = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|202| <<virtio_scsi_dataplane_start>> s->dataplane_fenced = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|223| <<virtio_scsi_dataplane_stop>> s->dataplane_fenced = false;
+     * 在以下使用VirtIOSCSI->dataplane_fenced:
+     *   - hw/scsi/virtio-scsi-dataplane.c|155| <<virtio_scsi_dataplane_start>> s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|222| <<virtio_scsi_dataplane_stop>> if (s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|82| <<virtio_scsi_complete_req>> if (s->dataplane_started && !s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|468| <<virtio_scsi_handle_ctrl>> if (!s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|737| <<virtio_scsi_handle_cmd>> if (!s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|870| <<virtio_scsi_handle_event>> if (!s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|908| <<virtio_scsi_hotplug>> if (s->ctx && !s->dataplane_fenced) {
+     */
     bool dataplane_fenced;
     uint32_t host_features;
 };
diff --git a/include/hw/virtio/virtio.h b/include/hw/virtio/virtio.h
index b7ece7a6a..61a2c588d 100644
--- a/include/hw/virtio/virtio.h
+++ b/include/hw/virtio/virtio.h
@@ -105,6 +105,25 @@ struct VirtIODevice
     VMChangeStateEntry *vmstate;
     char *bus_name;
     uint8_t device_endian;
+    /*
+     * Since guest_mask_notifier can not be used in vhost-user mode due
+     * to buffering implied by unix control socket, force
+     * use_mask_notifier on virtio devices of vhost-user interfaces, and
+     * send correct callfd to the guest at vhost start.
+     *
+     * Using guest_notifier_mask function in vhost-user case may
+     * break interrupt mask paradigm, because mask/unmask is not
+     * really done when returning from guest_notifier_mask call, instead
+     * message is posted in a unix socket, and processed later.
+     *
+     * Add an option boolean flag 'use_mask_notifier' to disable the use
+     * of guest_notifier_mask in virtio pci.
+     *
+     * 在以下使用VirtIODevice->use_guest_notifier_mask:
+     *   - backends/cryptodev-vhost.c|197| <<cryptodev_vhost_start>> dev->use_guest_notifier_mask = false;
+     *   - hw/net/vhost_net.c|343| <<vhost_net_start>> dev->use_guest_notifier_mask = false;
+     *   - hw/virtio/virtio.c|3533| <<virtio_init>> vdev->use_guest_notifier_mask = true;
+     */
     bool use_guest_notifier_mask;
     AddressSpace *dma_as;
     QLIST_HEAD(, VirtQueue) *vector_queues;
@@ -145,6 +164,14 @@ struct VirtioDeviceClass {
      * must mask in frontend instead.
      */
     void (*guest_notifier_mask)(VirtIODevice *vdev, int n, bool mask);
+    /*
+     * 在以下调用VirtioDeviceClass->start_ioeventfd:
+     *   - hw/virtio/virtio-bus.c|243| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+     * 在以下使用VirtioDeviceClass->start_ioeventfd:
+     *   - hw/block/virtio-blk.c|1330| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start;
+     *   - hw/scsi/virtio-scsi.c|1082| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+     *   - hw/virtio/virtio.c|4056| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+     */
     int (*start_ioeventfd)(VirtIODevice *vdev);
     void (*stop_ioeventfd)(VirtIODevice *vdev);
     /* Saving and loading of a device; trying to deprecate save/load
diff --git a/io/channel-socket.c b/io/channel-socket.c
index de259f7ee..9535cfef9 100644
--- a/io/channel-socket.c
+++ b/io/channel-socket.c
@@ -426,6 +426,10 @@ static void qio_channel_socket_finalize(Object *obj)
 
 
 #ifndef WIN32
+/*
+ * called by:
+ *   - io/channel-socket.c|517| <<qio_channel_socket_readv>> qio_channel_socket_copy_fds(&msg, fds, nfds);
+ */
 static void qio_channel_socket_copy_fds(struct msghdr *msg,
                                         int **fds, size_t *nfds)
 {
diff --git a/io/channel.c b/io/channel.c
index 93d449dee..d1d9086ab 100644
--- a/io/channel.c
+++ b/io/channel.c
@@ -47,6 +47,17 @@ void qio_channel_set_name(QIOChannel *ioc,
 }
 
 
+/*
+ * called by:
+ *   - chardev/char-socket.c|370| <<tcp_chr_recv>> ret = qio_channel_readv_full(s->ioc, &iov, 1,
+ *   - chardev/char-socket.c|374| <<tcp_chr_recv>> ret = qio_channel_readv_full(s->ioc, &iov, 1,
+ *   - io/channel.c|198| <<qio_channel_readv>> return qio_channel_readv_full(ioc, iov, niov, NULL, NULL, errp);
+ *   - io/channel.c|217| <<qio_channel_read>> return qio_channel_readv_full(ioc, &iov, 1, NULL, NULL, errp);
+ *   - scsi/qemu-pr-helper.c|604| <<prh_read>> n_read = qio_channel_readv_full(QIO_CHANNEL(client->ioc), &iov, 1,
+ *   - tests/qtest/tpm-emu.c|95| <<tpm_emu_ctrl_thread>> qio_channel_readv_full(ioc, &iov, 1, &pfd, &nfd, &error_abort);
+ *   - tests/test-io-channel-socket.c|449| <<test_io_channel_unix_fd_pass>> qio_channel_readv_full(dst,
+ *   - util/vhost-user-server.c|105| <<vu_message_read>> rc = qio_channel_readv_full(ioc, &iov, 1, &fds, &nfds, &local_err);
+ */
 ssize_t qio_channel_readv_full(QIOChannel *ioc,
                                const struct iovec *iov,
                                size_t niov,
@@ -63,6 +74,9 @@ ssize_t qio_channel_readv_full(QIOChannel *ioc,
         return -1;
     }
 
+    /*
+     * 比如getfd用qio_channel_socket_readv()
+     */
     return klass->io_readv(ioc, iov, niov, fds, nfds, errp);
 }
 
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 56ce14ad2..596fadc91 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -1505,6 +1505,10 @@ struct kvm_enc_region {
 #define KVM_HYPERV_EVENTFD        _IOW(KVMIO,  0xbd, struct kvm_hyperv_eventfd)
 
 /* Available with KVM_CAP_NESTED_STATE */
+/*
+ * 在以下使用KVM_GET_NESTED_STATE:
+ *   - target/i386/kvm.c|3912| <<kvm_get_nested_state>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_NESTED_STATE, env->nested_state);
+ */
 #define KVM_GET_NESTED_STATE         _IOWR(KVMIO, 0xbe, struct kvm_nested_state)
 #define KVM_SET_NESTED_STATE         _IOW(KVMIO,  0xbf, struct kvm_nested_state)
 
diff --git a/monitor/misc.c b/monitor/misc.c
index 398211a03..e785e3642 100644
--- a/monitor/misc.c
+++ b/monitor/misc.c
@@ -1224,12 +1224,49 @@ static void hmp_acl_remove(Monitor *mon, const QDict *qdict)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  0x000055e0a0cc780f in qmp_getfd (fdname=0x55e0a2e32590 "vhost-scsi-test", errp=0x7ffea965a210) at ../monitor/misc.c:1228
+ * #1  0x000055e0a0f49676 in qmp_marshal_getfd (args=0x7fc3180037d0, ret=0x7fc32917fd88, errp=0x7fc32917fd80) at qapi/qapi-commands-misc.c:334
+ * #2  0x000055e0a0fd22bc in do_qmp_dispatch_bh (opaque=0x7fc32917fe20) at ../qapi/qmp-dispatch.c:110
+ * #3  0x000055e0a0fbd1b1 in aio_bh_call (bh=0x55e0a2e53530) at ../util/async.c:136
+ * #4  0x000055e0a0fbd2bb in aio_bh_poll (ctx=0x55e0a2099640) at ../util/async.c:164
+ * #5  0x000055e0a0f9605e in aio_dispatch (ctx=0x55e0a2099640) at ../util/aio-posix.c:381
+ * #6  0x000055e0a0fbd6ee in aio_ctx_dispatch (source=0x55e0a2099640, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #7  0x00007fc3285f7099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #8  0x000055e0a0fb92be in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #9  0x000055e0a0fb9338 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:244
+ * #10 0x000055e0a0fb9440 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #11 0x000055e0a0cd72cb in qemu_main_loop () at ../softmmu/vl.c:1678#12 0x000055e0a095db32 in main (argc=22, argv=0x7ffea965a5b8, envp=0x7ffea965a670) at ../softmmu/main.c:50
+ *
+ * (gdb) bt
+ * #0  0x0000555555b7380f in qmp_getfd (fdname=0x55555737db60 "hello", errp=0x7fffffffcb28) at ../monitor/misc.c:1228
+ * #1  0x0000555555a688b1 in hmp_getfd (mon=0x555556ab80f0, qdict=0x5555570a3a00) at ../monitor/hmp-cmds.c:1691
+ * #2  0x0000555555940606 in handle_hmp_command (mon=0x555556ab80f0, cmdline=0x555556adc5a6 "hello") at ../monitor/hmp.c:1100
+ * #3  0x000055555593dd99 in monitor_command_cb (opaque=0x555556ab80f0, cmdline=0x555556adc5a0 "getfd hello", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #4  0x0000555555e5a417 in readline_handle_byte (rs=0x555556adc5a0, ch=10) at ../util/readline.c:408
+ * #5  0x0000555555941156 in monitor_read (opaque=0x555556ab80f0, buf=0x7fffffffcd60 "\n", size=1) at ../monitor/hmp.c:1340
+ * #6  0x0000555555d8fabe in qemu_chr_be_write_impl (s=0x555556aaf530, buf=0x7fffffffcd60 "\n", len=1) at ../chardev/char.c:201
+ * #7  0x0000555555d8fb25 in qemu_chr_be_write (s=0x555556aaf530, buf=0x7fffffffcd60 "\n", len=1) at ../chardev/char.c:213
+ * #8  0x0000555555d8b38c in fd_chr_read (chan=0x555556aaf640, cond=G_IO_IN, opaque=0x555556aaf530) at ../chardev/char-fd.c:68
+ * #9  0x0000555555d88fd4 in qio_channel_fd_source_dispatch (source=0x55555737da00, callback=0x555555d8b262 <fd_chr_read>, user_data=0x555556aaf530) at ../io/channel-watch.c:84
+ * #10 0x00007ffff7447099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #11 0x0000555555e65297 in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #12 0x0000555555e65311 in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:244
+ * #13 0x0000555555e65419 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #14 0x0000555555b832cb in qemu_main_loop () at ../softmmu/vl.c:1678
+ * #15 0x0000555555809b32 in main (argc=20, argv=0x7fffffffe008, envp=0x7fffffffe0b0) at ../softmmu/main.c:50
+ */
 void qmp_getfd(const char *fdname, Error **errp)
 {
     Monitor *cur_mon = monitor_cur();
     mon_fd_t *monfd;
     int fd, tmp_fd;
 
+    /*
+     * struct Monitor:
+     * -> CharBackend chr;
+     */
     fd = qemu_chr_fe_get_msgfd(&cur_mon->chr);
     if (fd == -1) {
         error_setg(errp, QERR_FD_NOT_SUPPLIED);
@@ -1244,6 +1281,20 @@ void qmp_getfd(const char *fdname, Error **errp)
     }
 
     QEMU_LOCK_GUARD(&cur_mon->mon_lock);
+    /*
+     * 在以下使用Monitor->fds:
+     *   - monitor/misc.c|1247| <<qmp_getfd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1263| <<qmp_getfd>> QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
+     *   - monitor/misc.c|1273| <<qmp_closefd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1297| <<monitor_get_fd>> QLIST_FOREACH(monfd, &mon->fds, next) {
+     *   - monitor/misc.c|1323| <<monitor_fdset_cleanup>> QLIST_FOREACH_SAFE(mon_fdset_fd, &mon_fdset->fds, next, mon_fdset_fd_next) {
+     *   - monitor/misc.c|1334| <<monitor_fdset_cleanup>> if (QLIST_EMPTY(&mon_fdset->fds) && QLIST_EMPTY(&mon_fdset->dup_fds)) {
+     *   - monitor/misc.c|1388| <<qmp_remove_fd>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1430| <<qmp_query_fdsets>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1447| <<qmp_query_fdsets>> fdset_info->value->fds = fdsetfd_list;
+     *   - monitor/misc.c|1529| <<monitor_fdset_add_fd>> QLIST_INSERT_HEAD(&mon_fdset->fds, mon_fdset_fd, next);
+     *   - monitor/misc.c|1557| <<monitor_fdset_dup_fd_add>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     */
     QLIST_FOREACH(monfd, &cur_mon->fds, next) {
         if (strcmp(monfd->name, fdname) != 0) {
             continue;
@@ -1256,10 +1307,30 @@ void qmp_getfd(const char *fdname, Error **errp)
         return;
     }
 
+    /*
+     * 新的fd用以下方式被vhost-scsi取出.
+     * vhost_scsi_realize()
+     * -> monitor_fd_param()
+     *    -> monitor_get_fd()
+     */
     monfd = g_malloc0(sizeof(mon_fd_t));
     monfd->name = g_strdup(fdname);
     monfd->fd = fd;
 
+    /*
+     * 在以下使用Monitor->fds:
+     *   - monitor/misc.c|1247| <<qmp_getfd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1263| <<qmp_getfd>> QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
+     *   - monitor/misc.c|1273| <<qmp_closefd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1297| <<monitor_get_fd>> QLIST_FOREACH(monfd, &mon->fds, next) {
+     *   - monitor/misc.c|1323| <<monitor_fdset_cleanup>> QLIST_FOREACH_SAFE(mon_fdset_fd, &mon_fdset->fds, next, mon_fdset_fd_next) {
+     *   - monitor/misc.c|1334| <<monitor_fdset_cleanup>> if (QLIST_EMPTY(&mon_fdset->fds) && QLIST_EMPTY(&mon_fdset->dup_fds)) {
+     *   - monitor/misc.c|1388| <<qmp_remove_fd>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1430| <<qmp_query_fdsets>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1447| <<qmp_query_fdsets>> fdset_info->value->fds = fdsetfd_list;
+     *   - monitor/misc.c|1529| <<monitor_fdset_add_fd>> QLIST_INSERT_HEAD(&mon_fdset->fds, mon_fdset_fd, next);
+     *   - monitor/misc.c|1557| <<monitor_fdset_dup_fd_add>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     */
     QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
 }
 
@@ -1289,6 +1360,14 @@ void qmp_closefd(const char *fdname, Error **errp)
     error_setg(errp, QERR_FD_NOT_FOUND, fdname);
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|1989| <<qmp_dump_guest_memory>> fd = monitor_get_fd(monitor_cur(), p, errp);
+ *   - migration/fd.c|29| <<fd_start_outgoing_migration>> int fd = monitor_get_fd(monitor_cur(), fdname, errp);
+ *   - monitor/misc.c|1646| <<monitor_fd_param>> fd = monitor_get_fd(mon, fdname, &local_err);
+ *   - monitor/qmp-cmds.c|331| <<qmp_add_client>> fd = monitor_get_fd(monitor_cur(), fdname, errp);
+ *   - util/qemu-sockets.c|1128| <<socket_get_fd>> fd = monitor_get_fd(cur_mon, fdstr, errp);
+ */
 int monitor_get_fd(Monitor *mon, const char *fdname, Error **errp)
 {
     mon_fd_t *monfd;
@@ -1623,12 +1702,30 @@ void monitor_fdset_dup_fd_remove(int dup_fd)
     monitor_fdset_dup_fd_find_remove(dup_fd, true);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/vhost-scsi.c|180| <<vhost_scsi_realize>> vhostfd = monitor_fd_param(monitor_cur(), vs->conf.vhostfd, errp);
+ *   - hw/virtio/vhost-vsock.c|147| <<vhost_vsock_device_realize>> vhostfd = monitor_fd_param(monitor_cur(), vsock->conf.vhostfd, errp);
+ *   - migration/fd.c|58| <<fd_start_incoming_migration>> int fd = monitor_fd_param(monitor_cur(), fdname, errp);
+ *   - net/socket.c|730| <<net_init_socket>> fd = monitor_fd_param(monitor_cur(), sock->fd, errp);
+ *   - net/tap.c|703| <<net_init_tap_one>> vhostfd = monitor_fd_param(monitor_cur(), vhostfdname, &err);
+ *   - net/tap.c|811| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), tap->fd, errp);
+ *   - net/tap.c|867| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), fds[i], errp);
+ */
 int monitor_fd_param(Monitor *mon, const char *fdname, Error **errp)
 {
     int fd;
     Error *local_err = NULL;
 
     if (!qemu_isdigit(fdname[0]) && mon) {
+        /*
+	 * called by:
+	 *   - dump/dump.c|1989| <<qmp_dump_guest_memory>> fd = monitor_get_fd(monitor_cur(), p, errp);
+	 *   - migration/fd.c|29| <<fd_start_outgoing_migration>> int fd = monitor_get_fd(monitor_cur(), fdname, errp);
+	 *   - monitor/misc.c|1646| <<monitor_fd_param>> fd = monitor_get_fd(mon, fdname, &local_err);
+	 *   - monitor/qmp-cmds.c|331| <<qmp_add_client>> fd = monitor_get_fd(monitor_cur(), fdname, errp);
+	 *   - util/qemu-sockets.c|1128| <<socket_get_fd>> fd = monitor_get_fd(cur_mon, fdstr, errp);
+	 */
         fd = monitor_get_fd(mon, fdname, &local_err);
     } else {
         fd = qemu_parse_fd(fdname);
diff --git a/monitor/monitor-internal.h b/monitor/monitor-internal.h
index a6131554d..45ce089a3 100644
--- a/monitor/monitor-internal.h
+++ b/monitor/monitor-internal.h
@@ -104,6 +104,20 @@ struct Monitor {
     /*
      * Members that are protected by the per-monitor lock
      */
+    /*
+     * 在以下使用Monitor->fds:
+     *   - monitor/misc.c|1247| <<qmp_getfd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1263| <<qmp_getfd>> QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
+     *   - monitor/misc.c|1273| <<qmp_closefd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1297| <<monitor_get_fd>> QLIST_FOREACH(monfd, &mon->fds, next) {
+     *   - monitor/misc.c|1323| <<monitor_fdset_cleanup>> QLIST_FOREACH_SAFE(mon_fdset_fd, &mon_fdset->fds, next, mon_fdset_fd_next) {
+     *   - monitor/misc.c|1334| <<monitor_fdset_cleanup>> if (QLIST_EMPTY(&mon_fdset->fds) && QLIST_EMPTY(&mon_fdset->dup_fds)) {
+     *   - monitor/misc.c|1388| <<qmp_remove_fd>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1430| <<qmp_query_fdsets>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1447| <<qmp_query_fdsets>> fdset_info->value->fds = fdsetfd_list;
+     *   - monitor/misc.c|1529| <<monitor_fdset_add_fd>> QLIST_INSERT_HEAD(&mon_fdset->fds, mon_fdset_fd, next);
+     *   - monitor/misc.c|1557| <<monitor_fdset_dup_fd_add>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     */
     QLIST_HEAD(, mon_fd_t) fds;
     QString *outbuf;
     guint out_watch;
diff --git a/qapi/qmp-dispatch.c b/qapi/qmp-dispatch.c
index 9a2d7dd29..f7f83c5a4 100644
--- a/qapi/qmp-dispatch.c
+++ b/qapi/qmp-dispatch.c
@@ -101,6 +101,10 @@ typedef struct QmpDispatchBH {
     Coroutine *co;
 } QmpDispatchBH;
 
+/*
+ * 在以下使用do_qmp_dispatch_bh():
+ *   - qapi/qmp-dispatch.c|213| <<qmp_dispatch>> aio_bh_schedule_oneshot(qemu_get_aio_context(), do_qmp_dispatch_bh,
+ */
 static void do_qmp_dispatch_bh(void *opaque)
 {
     QmpDispatchBH *data = opaque;
@@ -116,6 +120,14 @@ static void do_qmp_dispatch_bh(void *opaque)
  * Runs outside of coroutine context for OOB commands, but in coroutine
  * context for everything else.
  */
+/*
+ * called by:
+ *   - monitor/qmp.c|145| <<monitor_qmp_dispatch>> rsp = qmp_dispatch(mon->commands, req, qmp_oob_enabled(mon),
+ *   - qga/main.c|582| <<process_event>> rsp = qmp_dispatch(&ga_commands, obj, false, NULL);
+ *   - tests/test-qmp-cmds.c|159| <<do_qmp_dispatch>> resp = qmp_dispatch(&qmp_commands, QOBJECT(req), allow_oob, NULL);
+ *   - tests/test-qmp-cmds.c|182| <<do_qmp_dispatch_error>> resp = qmp_dispatch(&qmp_commands, QOBJECT(req), allow_oob, NULL);
+ *   - tests/test-qmp-cmds.c|238| <<test_dispatch_cmd_success_response>> resp = qmp_dispatch(&qmp_commands, QOBJECT(req), false, NULL);
+ */
 QDict *qmp_dispatch(const QmpCommandList *cmds, QObject *request,
                     bool allow_oob, Monitor *cur_mon)
 {
diff --git a/softmmu/physmem.c b/softmmu/physmem.c
index 3027747c0..4e33bbc74 100644
--- a/softmmu/physmem.c
+++ b/softmmu/physmem.c
@@ -1513,6 +1513,10 @@ static void *file_ram_alloc(RAMBlock *block,
     area = qemu_ram_mmap(fd, memory, block->mr->align,
                          block->flags & RAM_SHARED, block->flags & RAM_PMEM);
     if (area == MAP_FAILED) {
+        /*
+	 * 分配失败会显示:
+	 * qemu-system-x86_64: -object memory-backend-file,id=mem0,size=4000M,mem-path=/dev/hugepages_test,share=on: unable to map backing store for guest RAM: Cannot allocate memory
+	 */
         error_setg_errno(errp, errno,
                          "unable to map backing store for guest RAM");
         return NULL;
diff --git a/target/i386/helper.c b/target/i386/helper.c
index 034f46bcc..0354439f8 100644
--- a/target/i386/helper.c
+++ b/target/i386/helper.c
@@ -861,6 +861,11 @@ static void emit_guest_memory_failure(MemoryFailureAction action, bool ar,
                                    &mff);
 }
 
+/*
+ * 在以下使用do_inject_x86_mce():
+ *   - target/i386/helper.c|988| <<cpu_x86_inject_mce>> run_on_cpu(cs, do_inject_x86_mce, RUN_ON_CPU_HOST_PTR(&params));
+ *   - target/i386/helper.c|1001| <<cpu_x86_inject_mce>> run_on_cpu(other_cs, do_inject_x86_mce, RUN_ON_CPU_HOST_PTR(&params));
+ */
 static void do_inject_x86_mce(CPUState *cs, run_on_cpu_data data)
 {
     MCEInjectionParams *params = data.host_ptr;
@@ -950,6 +955,11 @@ static void do_inject_x86_mce(CPUState *cs, run_on_cpu_data data)
     emit_guest_memory_failure(MEMORY_FAILURE_ACTION_INJECT, ar, recursive);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm.c|544| <<kvm_mce_inject>> cpu_x86_inject_mce(NULL, cpu, 9, status, mcg_status, paddr,
+ *   - target/i386/monitor.c|599| <<hmp_mce>> cpu_x86_inject_mce(mon, cpu, bank, status, mcg_status, addr, misc,
+ */
 void cpu_x86_inject_mce(Monitor *mon, X86CPU *cpu, int bank,
                         uint64_t status, uint64_t mcg_status, uint64_t addr,
                         uint64_t misc, int flags)
diff --git a/target/i386/kvm.c b/target/i386/kvm.c
index a2934dda0..fe310c274 100644
--- a/target/i386/kvm.c
+++ b/target/i386/kvm.c
@@ -514,6 +514,10 @@ static int kvm_get_mce_cap_supported(KVMState *s, uint64_t *mce_cap,
     return -ENOSYS;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm.c|582| <<kvm_arch_on_sigbus_vcpu>> kvm_mce_inject(cpu, paddr, code);
+ */
 static void kvm_mce_inject(X86CPU *cpu, hwaddr paddr, int code)
 {
     CPUState *cs = CPU(cpu);
diff --git a/util/event_notifier-posix.c b/util/event_notifier-posix.c
index 00d93204f..2956434a9 100644
--- a/util/event_notifier-posix.c
+++ b/util/event_notifier-posix.c
@@ -91,6 +91,26 @@ int event_notifier_get_fd(const EventNotifier *e)
     return e->rfd;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|211| <<kvm_resample_fd_notify>> event_notifier_set(rfd->resample_event);
+ *   - hw/block/dataplane/virtio-blk.c|235| <<virtio_blk_data_plane_start>> event_notifier_set(virtio_queue_get_host_notifier(vq));
+ *   - hw/block/vhost-user-blk.c|297| <<vhost_user_blk_handle_output>> event_notifier_set(virtio_queue_get_host_notifier(kick_vq));
+ *   - hw/hyperv/hyperv.c|470| <<hyperv_sint_route_set_sint>> return event_notifier_set(&sint_route->sint_set_notifier);
+ *   - hw/hyperv/hyperv.c|658| <<hyperv_hcall_signal_event>> event_notifier_set(handler->notifier);
+ *   - hw/hyperv/vmbus.c|714| <<vmbus_channel_notify_host>> event_notifier_set(&chan->notifier);
+ *   - hw/misc/ivshmem.c|203| <<ivshmem_io_write>> event_notifier_set(&s->peers[dest].eventfds[vector]);
+ *   - hw/s390x/virtio-ccw.c|1011| <<virtio_ccw_set_guest_notifier>> event_notifier_set(notifier);
+ *   - hw/usb/ccid-card-emulated.c|170| <<emulated_push_event>> event_notifier_set(&card->notifier);
+ *   - hw/usb/u2f-emulated.c|190| <<u2f_emulated_thread>> event_notifier_set(&key->notifier);
+ *   - hw/virtio/virtio-pci.c|827| <<virtio_pci_vq_vector_unmask>> event_notifier_set(n);
+ *   - hw/virtio/virtio.c|2416| <<virtio_queue_notify>> event_notifier_set(&vq->host_notifier);
+ *   - hw/virtio/virtio.c|2632| <<virtio_notify_irqfd>> event_notifier_set(&vq->guest_notifier);
+ *   - hw/virtio/virtio.c|3888| <<virtio_device_start_ioeventfd_impl>> event_notifier_set(&vq->host_notifier);
+ *   - softmmu/memory.c|1472| <<memory_region_dispatch_write_eventfds>> event_notifier_set(ioeventfd.e);
+ *   - util/async.c|435| <<aio_notify>> event_notifier_set(&ctx->notifier);
+ *   - util/event_notifier-posix.c|69| <<event_notifier_init>> event_notifier_set(e);
+ */
 int event_notifier_set(EventNotifier *e)
 {
     static const uint64_t value = 1;
-- 
2.17.1

