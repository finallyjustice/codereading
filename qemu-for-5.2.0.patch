From b956d734a2a5da6d8537412f8aefbbfc79aff9a2 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Thu, 9 Dec 2021 18:08:27 -0800
Subject: [PATCH 1/1] qemu for 5.2.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-all.c             |  82 ++++++
 backends/hostmem-file.c         |  22 ++
 backends/hostmem.c              |  22 ++
 block/block-backend.c           |   6 +
 block/file-posix.c              |   5 +
 block/io.c                      |  37 +++
 block/qcow2.c                   |   6 +
 chardev/char-fe.c               |  20 ++
 chardev/char-socket.c           |  71 +++++
 hw/block/dataplane/virtio-blk.c |  29 +++
 hw/block/virtio-blk.c           |  73 ++++++
 hw/i386/kvm/clock.c             |  36 +++
 hw/i386/pc_piix.c               |  38 +++
 hw/net/vhost_net.c              |  35 +++
 hw/net/virtio-net.c             |  43 ++++
 hw/pci-host/i440fx.c            |  55 ++++
 hw/pci/msi.c                    |  20 ++
 hw/pci/msix.c                   |  77 ++++++
 hw/pci/pci.c                    |  48 ++++
 hw/scsi/scsi-bus.c              |  26 ++
 hw/scsi/scsi-disk.c             |  52 ++++
 hw/scsi/vhost-scsi-common.c     |   5 +
 hw/scsi/vhost-scsi.c            |  10 +
 hw/scsi/virtio-scsi-dataplane.c |  25 ++
 hw/scsi/virtio-scsi.c           | 151 +++++++++++
 hw/timer/hpet.c                 |  18 ++
 hw/vfio/common.c                | 441 ++++++++++++++++++++++++++++++++
 hw/vfio/pci.c                   | 375 +++++++++++++++++++++++++++
 hw/vfio/pci.h                   |   6 +
 hw/virtio/vhost.c               |  76 ++++++
 hw/virtio/virtio-blk-pci.c      |  10 +
 hw/virtio/virtio-bus.c          | 157 ++++++++++++
 hw/virtio/virtio-pci.c          |  74 ++++++
 hw/virtio/virtio-scsi-pci.c     |   4 +
 hw/virtio/virtio.c              | 316 +++++++++++++++++++++++
 include/exec/memory.h           |   7 +
 include/hw/scsi/scsi.h          |  14 +
 include/hw/vfio/vfio-common.h   |  57 +++++
 include/hw/virtio/virtio-blk.h  |  24 ++
 include/hw/virtio/virtio-bus.h  |  27 ++
 include/hw/virtio/virtio-net.h  |  12 +
 include/hw/virtio/virtio-scsi.h |  51 ++++
 include/hw/virtio/virtio.h      |  27 ++
 io/channel-socket.c             |   4 +
 io/channel.c                    |  14 +
 linux-headers/linux/kvm.h       |   4 +
 monitor/misc.c                  |  97 +++++++
 monitor/monitor-internal.h      |  14 +
 net/tap.c                       |   7 +
 qapi/qmp-dispatch.c             |  12 +
 scsi/pr-manager-helper.c        |   3 +
 scsi/utils.c                    |   5 +
 softmmu/dma-helpers.c           |  19 ++
 softmmu/physmem.c               |   8 +
 target/i386/cpu.c               |   4 +
 target/i386/helper.c            |  10 +
 target/i386/kvm.c               |   8 +
 util/event_notifier-posix.c     |  52 ++++
 util/oslib-posix.c              |  43 ++++
 59 files changed, 2994 insertions(+)

diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index baaa54249..1f9483eae 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -99,6 +99,15 @@ struct KVMState
     int many_ioeventfds;
     int intx_set_mask;
     int kvm_shadow_mem;
+    /*
+     * 在以下使用KVMState->kernel_irqchip_allowed:
+     *   - accel/kvm/kvm-all.c|2302| <<kvm_init>> if (s->kernel_irqchip_allowed) {
+     *   - accel/kvm/kvm-all.c|3233| <<kvm_set_kernel_irqchip>> s->kernel_irqchip_allowed = true;
+     *   - accel/kvm/kvm-all.c|3238| <<kvm_set_kernel_irqchip>> s->kernel_irqchip_allowed = false;
+     *   - accel/kvm/kvm-all.c|3243| <<kvm_set_kernel_irqchip>> s->kernel_irqchip_allowed = true;
+     *   - accel/kvm/kvm-all.c|3257| <<kvm_kernel_irqchip_allowed>> return kvm_state->kernel_irqchip_allowed;
+     *   - accel/kvm/kvm-all.c|3275| <<kvm_accel_instance_init>> s->kernel_irqchip_allowed = true;
+     */
     bool kernel_irqchip_allowed;
     bool kernel_irqchip_required;
     OnOffAuto kernel_irqchip_split;
@@ -1409,6 +1418,11 @@ static void clear_gsi(KVMState *s, unsigned int gsi)
     clear_bit(gsi, s->used_gsi_bitmap);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2011| <<kvm_irqchip_create>> kvm_init_irq_routing(s);
+ *   - hw/intc/openpic_kvm.c|247| <<kvm_openpic_realize>> kvm_init_irq_routing(kvm_state);
+ */
 void kvm_init_irq_routing(KVMState *s)
 {
     int gsi_count, i;
@@ -1432,6 +1446,23 @@ void kvm_init_irq_routing(KVMState *s)
     kvm_arch_init_irq_routing(s);
 }
 
+/*
+ * calle by:
+ *   - accel/kvm/kvm-all.c|1657| <<kvm_irqchip_send_msi>> kvm_irqchip_commit_routes(s);
+ *   - accel/kvm/kvm-all.c|1718| <<kvm_irqchip_add_msi_route>> kvm_irqchip_commit_routes(s);
+ *   - accel/kvm/kvm-all.c|1870| <<kvm_irqchip_add_hv_sint_route>> kvm_irqchip_commit_routes(s);
+ *   - accel/stubs/kvm-stub.c|114| <<kvm_irqchip_commit_routes>> void kvm_irqchip_commit_routes(KVMState *s)
+ *   - hw/i386/kvm/ioapic.c|47| <<kvm_pc_setup_irq_routing>> kvm_irqchip_commit_routes(s);
+ *   - hw/intc/arm_gic_kvm.c|591| <<kvm_arm_gic_realize>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/intc/arm_gicv3_kvm.c|853| <<kvm_arm_gicv3_realize>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/intc/ioapic.c|208| <<ioapic_update_kvm_routes>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/intc/openpic_kvm.c|255| <<kvm_openpic_realize>> kvm_irqchip_commit_routes(s);
+ *   - hw/intc/s390_flic_kvm.c|347| <<kvm_s390_add_adapter_routes>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/misc/ivshmem.c|294| <<ivshmem_vector_unmask>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/vfio/pci.c|531| <<vfio_update_kvm_msi_virq>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/virtio/virtio-pci.c|825| <<virtio_pci_vq_vector_unmask>> kvm_irqchip_commit_routes(kvm_state);
+ *   - target/i386/kvm.c|4674| <<kvm_update_msi_routes_all>> kvm_irqchip_commit_routes(kvm_state);
+ */
 void kvm_irqchip_commit_routes(KVMState *s)
 {
     int ret;
@@ -1446,6 +1477,13 @@ void kvm_irqchip_commit_routes(KVMState *s)
 
     s->irq_routes->flags = 0;
     trace_kvm_irqchip_commit_routes();
+    /*
+     * KVMState *s:
+     * -> struct kvm_irq_routing *irq_routes;
+     *    -> __u32 nr;
+     *    -> __u32 flags;
+     *    -> struct kvm_irq_routing_entry entries[0];
+     */
     ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);
     assert(ret == 0);
 }
@@ -1481,6 +1519,13 @@ static int kvm_update_routing_entry(KVMState *s,
     int n;
 
     for (n = 0; n < s->irq_routes->nr; n++) {
+        /*
+	 * KVMState *s:
+	 * -> struct kvm_irq_routing *irq_routes;
+	 *    -> __u32 nr;
+	 *    -> __u32 flags;
+	 *    -> struct kvm_irq_routing_entry entries[0];
+	 */
         entry = &s->irq_routes->entries[n];
         if (entry->gsi != new_entry->gsi) {
             continue;
@@ -1651,6 +1696,13 @@ int kvm_irqchip_send_msi(KVMState *s, MSIMessage msg)
     return kvm_set_irq(s, route->kroute.gsi, 1);
 }
 
+/*
+ * called by:
+ *   - hw/misc/ivshmem.c|432| <<ivshmem_add_kvm_msi_virq>> ret = kvm_irqchip_add_msi_route(kvm_state, vector, pdev);
+ *   - hw/vfio/pci.c|473| <<vfio_add_kvm_msi_virq>> virq = kvm_irqchip_add_msi_route(kvm_state, vector_n, &vdev->pdev);
+ *   - hw/virtio/virtio-pci.c|688| <<kvm_virtio_pci_vq_vector_use>> ret = kvm_irqchip_add_msi_route(kvm_state, vector, &proxy->pci_dev);
+ *   - target/i386/kvm.c|4573| <<kvm_arch_init_irq_routing>> if (kvm_irqchip_add_msi_route(s, 0, NULL) < 0) {
+ */
 int kvm_irqchip_add_msi_route(KVMState *s, int vector, PCIDevice *dev)
 {
     struct kvm_irq_routing_entry kroute = {};
@@ -1699,6 +1751,14 @@ int kvm_irqchip_add_msi_route(KVMState *s, int vector, PCIDevice *dev)
     return virq;
 }
 
+/*
+ * called by:
+ *   - hw/intc/ioapic.c|205| <<ioapic_update_kvm_routes>> kvm_irqchip_update_msi_route(kvm_state, i, msg, NULL);
+ *   - hw/misc/ivshmem.c|290| <<ivshmem_vector_unmask>> ret = kvm_irqchip_update_msi_route(kvm_state, v->virq, msg, dev);
+ *   - hw/vfio/pci.c|530| <<vfio_update_kvm_msi_virq>> kvm_irqchip_update_msi_route(kvm_state, vector->virq, msg, pdev);
+ *   - hw/virtio/virtio-pci.c|820| <<virtio_pci_vq_vector_unmask>> ret = kvm_irqchip_update_msi_route(kvm_state, irqfd->virq, msg,
+ *   - target/i386/kvm.c|4672| <<kvm_update_msi_routes_all>> kvm_irqchip_update_msi_route(kvm_state, entry->virq, msg, dev);
+ */
 int kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg,
                                  PCIDevice *dev)
 {
@@ -1731,6 +1791,12 @@ int kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg,
     return kvm_update_routing_entry(s, &kroute);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1870| <<kvm_irqchip_assign_irqfd>> static int kvm_irqchip_assign_irqfd(KVMState *s, EventNotifier *event,
+ *   - accel/kvm/kvm-all.c|1898| <<kvm_irqchip_add_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, rn, virq, true);
+ *   - accel/kvm/kvm-all.c|1904| <<kvm_irqchip_remove_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, NULL, virq, false);
+ */
 static int kvm_irqchip_assign_irqfd(KVMState *s, EventNotifier *event,
                                     EventNotifier *resample, int virq,
                                     bool assign)
@@ -1880,6 +1946,18 @@ int kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg)
 }
 #endif /* !KVM_CAP_IRQ_ROUTING */
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1904| <<kvm_irqchip_add_irqfd_notifier>> return kvm_irqchip_add_irqfd_notifier_gsi(s, n, rn, GPOINTER_TO_INT(gsi));
+ *   - accel/stubs/kvm-stub.c|135| <<kvm_irqchip_add_irqfd_notifier_gsi>> int kvm_irqchip_add_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,
+ *   - hw/hyperv/hyperv.c|409| <<hyperv_sint_route_new>> r = kvm_irqchip_add_irqfd_notifier_gsi(kvm_state,
+ *   - hw/misc/ivshmem.c|296| <<ivshmem_vector_unmask>> ret = kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL, v->virq);
+ *   - hw/misc/ivshmem.c|464| <<setup_interrupt>> kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL,
+ *   - hw/s390x/virtio-ccw.c|962| <<virtio_ccw_add_irqfd>> return kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, notifier, NULL,
+ *   - hw/vfio/pci.c|136| <<vfio_intx_enable_kvm>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state,
+ *   - hw/vfio/pci.c|436| <<vfio_add_kvm_msi_virq>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+ *   - hw/virtio/virtio-pci.c|715| <<kvm_virtio_pci_irqfd_use>> return kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL, irqfd->virq);
+ */
 int kvm_irqchip_add_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,
                                        EventNotifier *rn, int virq)
 {
@@ -1921,6 +1999,10 @@ void kvm_irqchip_set_qemuirq_gsi(KVMState *s, qemu_irq irq, int gsi)
     g_hash_table_insert(s->gsimap, irq, GINT_TO_POINTER(gsi));
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2277| <<kvm_init>> kvm_irqchip_create(s);
+ */
 static void kvm_irqchip_create(KVMState *s)
 {
     int ret;
diff --git a/backends/hostmem-file.c b/backends/hostmem-file.c
index 40e1e5b3e..480fec9d1 100644
--- a/backends/hostmem-file.c
+++ b/backends/hostmem-file.c
@@ -31,6 +31,28 @@ struct HostMemoryBackendFile {
     bool is_pmem;
 };
 
+/*
+ * (gdb) 
+ * #0  0x000055555584608e in file_backend_memory_alloc (backend=0x555556ab8850, errp=0x7fffffffdae0) at ../backends/hostmem-file.c:41
+ * #1  0x000055555580a70a in host_memory_backend_memory_complete (uc=0x555556ab8850, errp=0x7fffffffdb58) at ../backends/hostmem.c:333
+ * #2  0x0000555555d7e06a in user_creatable_complete (uc=0x555556ab8850, errp=0x7fffffffdbb8) at ../qom/object_interfaces.c:23
+ * #3  0x0000555555d7e35c in user_creatable_add_type (type=0x5555568c0380 "memory-backend-file", id=0x5555568c0310 "mem0", qdict=0x555556ae5390, v=
+ *     0x555556ac07c0, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:93
+ * #4  0x0000555555d7e714 in user_creatable_add_opts (opts=0x5555568c0330, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:163
+ * #5  0x0000555555d7e80f in user_creatable_add_opts_foreach
+ *     (opaque=0x555555ba6db7 <object_create_delayed>, opts=0x5555568c0330, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:186
+ * #6  0x0000555555e6d9a0 in qemu_opts_foreach
+ *     (list=0x5555567835c0 <qemu_object_opts>, func=0x555555d7e791 <user_creatable_add_opts_foreach>, opaque=0x555555ba6db7 <object_create_delayed>, errp=0x555556837f40 <error_fatal>)
+ *     at ../util/qemu-option.c:1156
+ * #7  0x0000555555baaf3a in qemu_init (argc=20, argv=0x7fffffffe028, envp=0x7fffffffe0d0) at ../softmmu/vl.c:4271
+ * #8  0x0000555555809b2d in main (argc=20, argv=0x7fffffffe028, envp=0x7fffffffe0d0) at ../softmmu/main.c:49
+ *
+ * 在以下使用file_backend_memory_alloc():
+ *   - backends/hostmem-file.c|172| <<file_backend_class_init>> bc->alloc = file_backend_memory_alloc;
+ *
+ * 分配失败会显示:
+ * qemu-system-x86_64: -object memory-backend-file,id=mem0,size=4000M,mem-path=/dev/hugepages_test,share=on: unable to map backing store for guest RAM: Cannot allocate memory
+ */
 static void
 file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
diff --git a/backends/hostmem.c b/backends/hostmem.c
index 4bde00e8e..c9c9b8862 100644
--- a/backends/hostmem.c
+++ b/backends/hostmem.c
@@ -320,6 +320,28 @@ size_t host_memory_backend_pagesize(HostMemoryBackend *memdev)
 }
 #endif
 
+/*
+ * (gdb) 
+ * #0  0x000055555584608e in file_backend_memory_alloc (backend=0x555556ab8850, errp=0x7fffffffdae0) at ../backends/hostmem-file.c:41
+ * #1  0x000055555580a70a in host_memory_backend_memory_complete (uc=0x555556ab8850, errp=0x7fffffffdb58) at ../backends/hostmem.c:333
+ * #2  0x0000555555d7e06a in user_creatable_complete (uc=0x555556ab8850, errp=0x7fffffffdbb8) at ../qom/object_interfaces.c:23
+ * #3  0x0000555555d7e35c in user_creatable_add_type (type=0x5555568c0380 "memory-backend-file", id=0x5555568c0310 "mem0", qdict=0x555556ae5390, v=
+ *     0x555556ac07c0, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:93
+ * #4  0x0000555555d7e714 in user_creatable_add_opts (opts=0x5555568c0330, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:163
+ * #5  0x0000555555d7e80f in user_creatable_add_opts_foreach
+ *     (opaque=0x555555ba6db7 <object_create_delayed>, opts=0x5555568c0330, errp=0x555556837f40 <error_fatal>) at ../qom/object_interfaces.c:186
+ * #6  0x0000555555e6d9a0 in qemu_opts_foreach
+ *     (list=0x5555567835c0 <qemu_object_opts>, func=0x555555d7e791 <user_creatable_add_opts_foreach>, opaque=0x555555ba6db7 <object_create_delayed>, errp=0x555556837f40 <error_fatal>)
+ *     at ../util/qemu-option.c:1156
+ * #7  0x0000555555baaf3a in qemu_init (argc=20, argv=0x7fffffffe028, envp=0x7fffffffe0d0) at ../softmmu/vl.c:4271
+ * #8  0x0000555555809b2d in main (argc=20, argv=0x7fffffffe028, envp=0x7fffffffe0d0) at ../softmmu/main.c:49
+ *      
+ * 分配失败会显示:
+ * qemu-system-x86_64: -object memory-backend-file,id=mem0,size=4000M,mem-path=/dev/hugepages_test,share=on: unable to map backing store for guest RAM: Cannot allocate memory
+ *
+ * 在以下使用host_memory_backend_memory_complete():
+ *   - backends/hostmem.c|454| <<host_memory_backend_class_init>> ucc->complete = host_memory_backend_memory_complete;
+ */
 static void
 host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)
 {
diff --git a/block/block-backend.c b/block/block-backend.c
index ce78d3079..12c4ebd3d 100644
--- a/block/block-backend.c
+++ b/block/block-backend.c
@@ -1227,6 +1227,12 @@ int coroutine_fn blk_co_preadv(BlockBackend *blk, int64_t offset,
 }
 
 /* To be called between exactly one pair of blk_inc/dec_in_flight() */
+/*
+ * 在以下使用blk_do_pwritev_part():
+ *   - block/block-backend.c|1274| <<blk_co_pwritev_part>> ret = blk_do_pwritev_part(blk, offset, bytes, qiov, qiov_offset, flags);
+ *   - block/block-backend.c|1310| <<blk_write_entry>> rwco->ret = blk_do_pwritev_part(rwco->blk, rwco->offset, qiov->size,
+ *   - block/block-backend.c|1476| <<blk_aio_write_entry>> rwco->ret = blk_do_pwritev_part(rwco->blk, rwco->offset, acb->bytes,
+ */
 static int coroutine_fn
 blk_do_pwritev_part(BlockBackend *blk, int64_t offset, unsigned int bytes,
                     QEMUIOVector *qiov, size_t qiov_offset,
diff --git a/block/file-posix.c b/block/file-posix.c
index d5fd1dbcd..d7e7a50b6 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -458,6 +458,11 @@ static int check_hdev_writable(int fd)
     return 0;
 }
 
+/*
+ * called by:
+ *   - block/file-posix.c|630| <<raw_open_common>> raw_parse_flags(bdrv_flags, &s->open_flags, false);
+ *   - block/file-posix.c|1006| <<raw_reconfigure_getfd>> raw_parse_flags(flags, open_flags, has_writers);
+ */
 static void raw_parse_flags(int bdrv_flags, int *open_flags, bool has_writers)
 {
     bool read_write = false;
diff --git a/block/io.c b/block/io.c
index ec5e152bb..078de3dad 100644
--- a/block/io.c
+++ b/block/io.c
@@ -1092,6 +1092,43 @@ out:
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  0x000055f3d410b81d in bdrv_driver_pwritev (bs=0x55f3d546d600, offset=6442451456, bytes=512, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=16) at ../block/io.c:1099
+ * #1  0x000055f3d410dc7e in bdrv_aligned_pwritev (child=0x55f3d547ae00, req=0x7efde56d6df0, offset=6442451456, bytes=512, align=1, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=16) at ../block/io.c:1939
+ * #2  0x000055f3d410e48b in bdrv_co_pwritev_part (child=0x55f3d547ae00, offset=6442451456, bytes=512, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=BDRV_REQ_FUA) at ../block/io.c:2107
+ * #3  0x000055f3d41af8a3 in blk_do_pwritev_part (blk=0x55f3d546d2a0, offset=6442451456, bytes=512, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=BDRV_REQ_FUA) at ../block/block-backend.c:1261
+ * #4  0x000055f3d41b010b in blk_aio_write_entry (opaque=0x55f3d5b5d910) at ../block/block-backend.c:1477
+ * #5  0x000055f3d42847fd in coroutine_trampoline (i0=-708902976, i1=22003) at ../util/coroutine-ucontext.c:173
+ * #6  0x00007efebff5a180 in __start_context () at /lib/../lib64/libc.so.6
+ * #7  0x00007ffdac2e5cc0 in  ()
+ * #8  0x0000000000000000 in  ()
+ *
+ * (gdb) bt
+ * #0  0x000055f3d410b81d in bdrv_driver_pwritev (bs=0x55f3d5474ba0, offset=14025216, bytes=512, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=0) at ../block/io.c:1099
+ * #1  0x000055f3d410dc7e in bdrv_aligned_pwritev (child=0x55f3d547b330, req=0x7efde56d6930, offset=14025216, bytes=512, align=1, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=0) at ../block/io.c:1939
+ * #2  0x000055f3d410e48b in bdrv_co_pwritev_part (child=0x55f3d547b330, offset=14025216, bytes=512, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=0) at ../block/io.c:2107
+ * #3  0x000055f3d415ed8c in qcow2_co_pwritev_task (bs=0x55f3d546d600, host_offset=14025216, offset=6442451456, bytes=512, qiov=0x55f3d57ffaf0, qiov_offset=0, l2meta=0x0) at ../block/qcow2.c:2533
+ * #4  0x000055f3d415eeba in qcow2_co_pwritev_task_entry (task=0x7efde56d6b30) at ../block/qcow2.c:2563
+ * #5  0x000055f3d415e24c in qcow2_add_task (bs=0x55f3d546d600, pool=0x0, func=0x55f3d415ee2f <qcow2_co_pwritev_task_entry>, subcluster_type=QCOW2_SUBCLUSTER_UNALLOCATED_PLAIN,
+ *                           host_offset=14025216, offset=6442451456, bytes=512, qiov=0x55f3d57ffaf0, qiov_offset=0, l2meta=0x0) at ../block/qcow2.c:2219
+ * #6  0x000055f3d415f091 in qcow2_co_pwritev_part (bs=0x55f3d546d600, offset=6442451456, bytes=512, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=0) at ../block/qcow2.c:2614
+ * #7  0x000055f3d410b8ee in bdrv_driver_pwritev (bs=0x55f3d546d600, offset=6442451456, bytes=512, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=16) at ../block/io.c:1114
+ * #8  0x000055f3d410dc7e in bdrv_aligned_pwritev (child=0x55f3d547ae00, req=0x7efde56d6df0, offset=6442451456, bytes=512, align=1, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=16) at ../block/io.c:1939
+ * #9  0x000055f3d410e48b in bdrv_co_pwritev_part (child=0x55f3d547ae00, offset=6442451456, bytes=512, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=BDRV_REQ_FUA) at ../block/io.c:2107
+ * #10 0x000055f3d41af8a3 in blk_do_pwritev_part (blk=0x55f3d546d2a0, offset=6442451456, bytes=512, qiov=0x55f3d57ffaf0, qiov_offset=0, flags=BDRV_REQ_FUA) at ../block/block-backend.c:1261
+ * #11 0x000055f3d41b010b in blk_aio_write_entry (opaque=0x55f3d5b5d910) at ../block/block-backend.c:1477
+ * #12 0x000055f3d42847fd in coroutine_trampoline (i0=-708902976, i1=22003) at ../util/coroutine-ucontext.c:173
+ * #13 0x00007efebff5a180 in __start_context () at /lib/../lib64/libc.so.6
+ * #14 0x00007ffdac2e5cc0 in  ()
+ * #15 0x0000000000000000 in  ()
+ *
+ * 在以下使用bdrv_driver_pwritev():
+ *   - block/io.c|1324| <<bdrv_co_do_copy_on_readv>> ret = bdrv_driver_pwritev(bs, cluster_offset, pnum,
+ *   - block/io.c|1772| <<bdrv_co_do_pwrite_zeroes>> ret = bdrv_driver_pwritev(bs, offset, num, &qiov, 0, write_flags);
+ *   - block/io.c|1936| <<bdrv_aligned_pwritev>> ret = bdrv_driver_pwritev(bs, offset, bytes, qiov, qiov_offset, flags);
+ *   - block/io.c|1951| <<bdrv_aligned_pwritev>> ret = bdrv_driver_pwritev(bs, offset + bytes - bytes_remaining,
+ */
 static int coroutine_fn bdrv_driver_pwritev(BlockDriverState *bs,
                                             uint64_t offset, uint64_t bytes,
                                             QEMUIOVector *qiov,
diff --git a/block/qcow2.c b/block/qcow2.c
index 3a90ef278..c3c175368 100644
--- a/block/qcow2.c
+++ b/block/qcow2.c
@@ -2565,6 +2565,12 @@ static coroutine_fn int qcow2_co_pwritev_task_entry(AioTask *task)
                                  t->l2meta);
 }
 
+/*
+ * 在以下使用qcow2_co_pwritev_part():
+ *   - BlockDriver bdrv_qcow2..bdrv_co_pwritev_part = qcow2_co_pwritev_part()
+ *   - block/qcow2.c|4445| <<qcow2_co_truncate>> ret = qcow2_co_pwritev_part(bs, old_length, len, &qiov, 0, 0);
+ *   - block/qcow2.c|4519| <<qcow2_co_pwritev_compressed_task>> ret = qcow2_co_pwritev_part(bs, offset, bytes, qiov, qiov_offset, 0);
+ */
 static coroutine_fn int qcow2_co_pwritev_part(
         BlockDriverState *bs, uint64_t offset, uint64_t bytes,
         QEMUIOVector *qiov, size_t qiov_offset, int flags)
diff --git a/chardev/char-fe.c b/chardev/char-fe.c
index 474715c5a..95bf751df 100644
--- a/chardev/char-fe.c
+++ b/chardev/char-fe.c
@@ -110,6 +110,16 @@ int qemu_chr_fe_ioctl(CharBackend *be, int cmd, void *arg)
     return res;
 }
 
+/*
+ * called by:
+ *   - hw/display/vhost-user-gpu.c|209| <<vhost_user_gpu_handle_display>> int fd = qemu_chr_fe_get_msgfd(&g->vhost_chr);
+ *   - hw/misc/ivshmem.c|599| <<ivshmem_read>> fd = qemu_chr_fe_get_msgfd(&s->server_chr);
+ *   - hw/misc/ivshmem.c|626| <<ivshmem_recv_msg>> *pfd = qemu_chr_fe_get_msgfd(&s->server_chr);
+ *   - hw/virtio/vhost-user.c|1681| <<vhost_user_postcopy_advise>> ufd = qemu_chr_fe_get_msgfd(chr);
+ *   - hw/virtio/vhost-user.c|2278| <<vhost_user_get_inflight_fd>> fd = qemu_chr_fe_get_msgfd(chr);
+ *   - monitor/misc.c|1233| <<qmp_getfd>> fd = qemu_chr_fe_get_msgfd(&cur_mon->chr);
+ *   - monitor/misc.c|1372| <<qmp_add_fd>> fd = qemu_chr_fe_get_msgfd(&mon->chr);
+ */
 int qemu_chr_fe_get_msgfd(CharBackend *be)
 {
     Chardev *s = be->chr;
@@ -123,6 +133,13 @@ int qemu_chr_fe_get_msgfd(CharBackend *be)
     return res;
 }
 
+/*
+ * called by:
+ *   - chardev/char-fe.c|127| <<qemu_chr_fe_get_msgfd>> int res = (qemu_chr_fe_get_msgfds(be, &fd, 1) == 1) ? fd : -1;
+ *   - tests/qtest/vhost-user-test.c|381| <<chr_read>> s->fds_num = qemu_chr_fe_get_msgfds(chr, s->fds,
+ *   - tests/qtest/vhost-user-test.c|391| <<chr_read>> qemu_chr_fe_get_msgfds(chr, &fd, 1);
+ *   - tests/qtest/vhost-user-test.c|405| <<chr_read>> qemu_chr_fe_get_msgfds(chr, &s->log_fd, 1);
+ */
 int qemu_chr_fe_get_msgfds(CharBackend *be, int *fds, int len)
 {
     Chardev *s = be->chr;
@@ -131,6 +148,9 @@ int qemu_chr_fe_get_msgfds(CharBackend *be, int *fds, int len)
         return -1;
     }
 
+    /*
+     * 似乎目前只能是tcp_get_msgfds()或者NULL
+     */
     return CHARDEV_GET_CLASS(s)->get_msgfds ?
         CHARDEV_GET_CLASS(s)->get_msgfds(s, fds, len) : -1;
 }
diff --git a/chardev/char-socket.c b/chardev/char-socket.c
index 213a4c8dd..56f7fcbef 100644
--- a/chardev/char-socket.c
+++ b/chardev/char-socket.c
@@ -66,7 +66,34 @@ struct SocketChardev {
     int max_size;
     int do_telnetopt;
     int do_nodelay;
+    /*
+     * 在以下使用SocketChadev->read_msgfds:
+     *   - chardev/char-socket.c|301| <<tcp_get_msgfds>> memcpy(fds, s->read_msgfds, to_copy * sizeof(int ));
+     *   - chardev/char-socket.c|305| <<tcp_get_msgfds>> close(s->read_msgfds[i]);
+     *   - chardev/char-socket.c|308| <<tcp_get_msgfds>> g_free(s->read_msgfds);
+     *   - chardev/char-socket.c|309| <<tcp_get_msgfds>> s->read_msgfds = 0;
+     *   - chardev/char-socket.c|375| <<tcp_chr_recv>> close(s->read_msgfds[i]);
+     *   - chardev/char-socket.c|379| <<tcp_chr_recv>> g_free(s->read_msgfds);
+     *   - chardev/char-socket.c|382| <<tcp_chr_recv>> s->read_msgfds = msgfds;
+     *   - chardev/char-socket.c|387| <<tcp_chr_recv>> int fd = s->read_msgfds[i];
+     *   - chardev/char-socket.c|425| <<tcp_chr_free_connection>> close(s->read_msgfds[i]);
+     *   - chardev/char-socket.c|427| <<tcp_chr_free_connection>> g_free(s->read_msgfds);
+     *   - chardev/char-socket.c|428| <<tcp_chr_free_connection>> s->read_msgfds = NULL;
+     */
     int *read_msgfds;
+    /*
+     * 在以下使用SocketChardev->read_msgfds_num:
+     *   - chardev/char-socket.c|281| <<tcp_get_msgfds>> int to_copy = (s->read_msgfds_num < num) ? s->read_msgfds_num : num;
+     *   - chardev/char-socket.c|291| <<tcp_get_msgfds>> for (i = to_copy; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|297| <<tcp_get_msgfds>> s->read_msgfds_num = 0;
+     *   - chardev/char-socket.c|356| <<tcp_chr_recv>> for (i = 0; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|360| <<tcp_chr_recv>> if (s->read_msgfds_num) {
+     *   - chardev/char-socket.c|365| <<tcp_chr_recv>> s->read_msgfds_num = msgfds_num;
+     *   - chardev/char-socket.c|368| <<tcp_chr_recv>> for (i = 0; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|405| <<tcp_chr_free_connection>> if (s->read_msgfds_num) {
+     *   - chardev/char-socket.c|406| <<tcp_chr_free_connection>> for (i = 0; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|411| <<tcp_chr_free_connection>> s->read_msgfds_num = 0;
+     */
     size_t read_msgfds_num;
     int *write_msgfds;
     size_t write_msgfds_num;
@@ -274,6 +301,10 @@ static void tcp_chr_process_IAC_bytes(Chardev *chr,
     *size = j;
 }
 
+/*
+ * 在以下使用tcp_get_msgfds():
+ *   - chardev/char-socket.c|1546| <<char_socket_class_init>> cc->get_msgfds = tcp_get_msgfds;
+ */
 static int tcp_get_msgfds(Chardev *chr, int *fds, int num)
 {
     SocketChardev *s = SOCKET_CHARDEV(chr);
@@ -293,7 +324,19 @@ static int tcp_get_msgfds(Chardev *chr, int *fds, int num)
         }
 
         g_free(s->read_msgfds);
+	/*
+	 * 在以下设置SocketChadev->read_msgfds:
+	 *   - chardev/char-socket.c|309| <<tcp_get_msgfds>> s->read_msgfds = 0;
+	 *   - chardev/char-socket.c|382| <<tcp_chr_recv>> s->read_msgfds = msgfds;
+	 *   - chardev/char-socket.c|428| <<tcp_chr_free_connection>> s->read_msgfds = NULL;
+	 */
         s->read_msgfds = 0;
+	/*
+	 * 在以下使用SocketChardev->read_msgfds_num:
+	 *   - chardev/char-socket.c|297| <<tcp_get_msgfds>> s->read_msgfds_num = 0;
+	 *   - chardev/char-socket.c|365| <<tcp_chr_recv>> s->read_msgfds_num = msgfds_num;
+	 *   - chardev/char-socket.c|411| <<tcp_chr_free_connection>> s->read_msgfds_num = 0;
+	 */
         s->read_msgfds_num = 0;
     }
 
@@ -325,6 +368,23 @@ static int tcp_set_msgfds(Chardev *chr, int *fds, int num)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000556f1cc82048 in tcp_chr_recv (chr=0x556f1eea62b0, buf=0x7efed630d750 "", len=1) at ../chardev/char-socket.c:329
+ * #1  0x0000556f1cc828c0 in tcp_chr_read (chan=0x7efed0002150, cond=G_IO_IN, opaque=0x556f1eea62b0) at ../chardev/char-socket.c:536
+ * #2  0x0000556f1cc71f9a in qio_channel_fd_source_dispatch (source=0x7efed0002000, callback=0x556f1cc827e5 <tcp_chr_read>, user_data=0x556f1eea62b0) at ../io/channel-watch.c:84
+ * #3  0x00007efedfbbd099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #4  0x00007efedfbbd3f8 in g_main_context_iterate.isra () at /lib/../lib64/libglib-2.0.so.0
+ * #5  0x00007efedfbbd6ca in g_main_loop_run () at /lib/../lib64/libglib-2.0.so.0
+ * #6  0x0000556f1cb987b4 in iothread_run (opaque=0x556f1eeb9d00) at ../iothread.c:80
+ * #7  0x0000556f1cd31abc in qemu_thread_start (args=0x556f1eea83e0) at ../util/qemu-thread-posix.c:521
+ * #8  0x00007efeddba5ea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #9  0x00007efedd8ce8cd in clone () at /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - chardev/char-socket.c|536| <<tcp_chr_read>> size = tcp_chr_recv(chr, (void *)buf, len);
+ *   - chardev/char-socket.c|571| <<tcp_chr_sync_read>> size = tcp_chr_recv(chr, (void *) buf, len);
+ */
 static ssize_t tcp_chr_recv(Chardev *chr, char *buf, size_t len)
 {
     SocketChardev *s = SOCKET_CHARDEV(chr);
@@ -518,6 +578,13 @@ static void tcp_chr_disconnect(Chardev *chr)
     qemu_mutex_unlock(&chr->chr_write_lock);
 }
 
+/*
+ * 在update_ioc_handlers()使用tcp_chr_read():
+ *  681     chr->gsource = io_add_watch_poll(chr, s->ioc,
+ *  682                                      tcp_chr_read_poll,
+ *  683                                      tcp_chr_read, chr,
+ *  684                                      chr->gcontext);
+ */
 static gboolean tcp_chr_read(QIOChannel *chan, GIOCondition cond, void *opaque)
 {
     Chardev *chr = CHARDEV(opaque);
@@ -558,6 +625,10 @@ static gboolean tcp_chr_hup(QIOChannel *channel,
     return G_SOURCE_REMOVE;
 }
 
+/*
+ * 在以下使用tcp_chr_sync_read():
+ *   - chardev/char-socket.c|1560| <<char_socket_class_init>> cc->chr_sync_read = tcp_chr_sync_read;
+ */
 static int tcp_chr_sync_read(Chardev *chr, const uint8_t *buf, int len)
 {
     SocketChardev *s = SOCKET_CHARDEV(chr);
diff --git a/hw/block/dataplane/virtio-blk.c b/hw/block/dataplane/virtio-blk.c
index 37499c556..fff4a2b95 100644
--- a/hw/block/dataplane/virtio-blk.c
+++ b/hw/block/dataplane/virtio-blk.c
@@ -46,6 +46,10 @@ struct VirtIOBlockDataPlane {
 };
 
 /* Raise an interrupt to signal guest, if necessary */
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|87| <<virtio_blk_req_complete>> virtio_blk_data_plane_notify(s->dataplane, req->vq);
+ */
 void virtio_blk_data_plane_notify(VirtIOBlockDataPlane *s, VirtQueue *vq)
 {
     if (s->batch_notifications) {
@@ -56,6 +60,11 @@ void virtio_blk_data_plane_notify(VirtIOBlockDataPlane *s, VirtQueue *vq)
     }
 }
 
+/*
+ * 在以下使用notify_guest_bh():
+ *   - hw/block/dataplane/virtio-blk.c|130| <<virtio_blk_data_plane_create>> s->bh = aio_bh_new(s->ctx, notify_guest_bh, s);
+ *   - hw/block/dataplane/virtio-blk.c|310| <<virtio_blk_data_plane_stop>> notify_guest_bh(s);
+ */
 static void notify_guest_bh(void *opaque)
 {
     VirtIOBlockDataPlane *s = opaque;
@@ -136,6 +145,10 @@ bool virtio_blk_data_plane_create(VirtIODevice *vdev, VirtIOBlkConf *conf,
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|1265| <<virtio_blk_device_unrealize>> virtio_blk_data_plane_destroy(s->dataplane);
+ */
 void virtio_blk_data_plane_destroy(VirtIOBlockDataPlane *s)
 {
     VirtIOBlock *vblk;
@@ -154,6 +167,10 @@ void virtio_blk_data_plane_destroy(VirtIOBlockDataPlane *s)
     g_free(s);
 }
 
+/*
+ * 在以下使用virtio_blk_data_plane_handle_output():
+ *   - hw/block/dataplane/virtio-blk.c|244| <<virtio_blk_data_plane_start>> virtio_queue_aio_set_host_notifier_handler(vq, s->ctx, virtio_blk_data_plane_handle_output);
+ */
 static bool virtio_blk_data_plane_handle_output(VirtIODevice *vdev,
                                                 VirtQueue *vq)
 {
@@ -166,6 +183,10 @@ static bool virtio_blk_data_plane_handle_output(VirtIODevice *vdev,
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * 在以下使用virtio_blk_data_plane_start():
+ *   - hw/block/virtio-blk.c|1343| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start;
+ */
 int virtio_blk_data_plane_start(VirtIODevice *vdev)
 {
     VirtIOBlock *vblk = VIRTIO_BLK(vdev);
@@ -257,6 +278,10 @@ int virtio_blk_data_plane_start(VirtIODevice *vdev)
  *
  * Context: BH in IOThread
  */
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|301| <<virtio_blk_data_plane_stop>> aio_wait_bh_oneshot(s->ctx, virtio_blk_data_plane_stop_bh, s);
+ */
 static void virtio_blk_data_plane_stop_bh(void *opaque)
 {
     VirtIOBlockDataPlane *s = opaque;
@@ -270,6 +295,10 @@ static void virtio_blk_data_plane_stop_bh(void *opaque)
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * 在以下使用virtio_blk_data_plane_stop():
+ *   - hw/block/virtio-blk.c|1344| <<virtio_blk_class_init>> vdc->stop_ioeventfd = virtio_blk_data_plane_stop;
+ */
 void virtio_blk_data_plane_stop(VirtIODevice *vdev)
 {
     VirtIOBlock *vblk = VIRTIO_BLK(vdev);
diff --git a/hw/block/virtio-blk.c b/hw/block/virtio-blk.c
index bac2d6fa2..f888ac759 100644
--- a/hw/block/virtio-blk.c
+++ b/hw/block/virtio-blk.c
@@ -33,6 +33,16 @@
 #include "migration/qemu-file-types.h"
 #include "hw/virtio/virtio-access.h"
 
+/*
+ * virtio-blk的ioeventfd和dataplane的关系 (ioeventfd不设置就没有dataplane)
+ *
+ * virtio_bus_start_ioeventfd()
+ * -> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy))
+ *        return -ENOSYS; //k->ioeventfd_enabled = virtio_pci_ioeventfd_enabled()
+ *        virtio_pci_ioeventfd_enabled()会确认ioeventfd是否enabled
+ * -> vdc->start_ioeventfd = virtio_blk_data_plane_start()或virtio_scsi_dataplane_start()或virtio_device_start_ioeventfd_impl()
+ */
+
 /* Config size before the discard support (hide associated config fields) */
 #define VIRTIO_BLK_CFG_SIZE offsetof(struct virtio_blk_config, \
                                      max_discard_sectors)
@@ -72,6 +82,20 @@ static void virtio_blk_free_request(VirtIOBlockReq *req)
     g_free(req);
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|106| <<virtio_blk_handle_rw_error>> virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
+ *   - hw/block/virtio-blk.c|152| <<virtio_blk_rw_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|171| <<virtio_blk_flush_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|193| <<virtio_blk_discard_write_zeroes_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|248| <<virtio_blk_ioctl_complete>> virtio_blk_req_complete(req, status);
+ *   - hw/block/virtio-blk.c|381| <<virtio_blk_handle_scsi>> virtio_blk_req_complete(req, status);
+ *   - hw/block/virtio-blk.c|676| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
+ *   - hw/block/virtio-blk.c|716| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|740| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
+ *   - hw/block/virtio-blk.c|757| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|764| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
+ */
 static void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
 {
     VirtIOBlock *s = req->dev;
@@ -767,6 +791,47 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555b73b2e in virtio_blk_handle_vq (s=0x555557913540, vq=0x55555791c848) at ../hw/block/virtio-blk.c:771
+ * #1  0x0000555555b8fb24 in virtio_blk_data_plane_handle_output (vdev=0x555557913540, vq=0x55555791c848) at ../hw/block/dataplane/virtio-blk.c:165
+ * #2  0x0000555555c5ddf2 in virtio_queue_notify_aio_vq (vq=0x55555791c848) at ../hw/virtio/virtio.c:2326
+ * #3  0x0000555555c60dc0 in virtio_queue_host_notifier_aio_read (n=0x55555791c8c0) at ../hw/virtio/virtio.c:3530
+ * #4  0x0000555555e80900 in aio_dispatch_handler (ctx=0x555556a9a0a0, node=0x7fff1c04fa00) at ../util/aio-posix.c:329
+ * #5  0x0000555555e80ab9 in aio_dispatch_handlers (ctx=0x555556a9a0a0) at ../util/aio-posix.c:372
+ * #6  0x0000555555e80b0f in aio_dispatch (ctx=0x555556a9a0a0) at ../util/aio-posix.c:382
+ * #7  0x0000555555e5ef83 in aio_ctx_dispatch (source=0x555556a9a0a0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #8  0x00007ffff7447099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #9  0x0000555555e644cb in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #10 0x0000555555e64545 in os_host_main_loop_wait (timeout=2000000) at ../util/main-loop.c:244
+ * #11 0x0000555555e6464d in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #12 0x0000555555ba3630 in qemu_main_loop () at ../softmmu/vl.c:1678
+ * #13 0x0000555555809b32 in main (argc=18, argv=0x7fffffffe028, envp=0x7fffffffe0c0) at ../softmmu/main.c:50
+ *
+ * (gdb) bt
+ * #0  0x0000555555b73b2e in virtio_blk_handle_vq (s=0x555557913540, vq=0x55555791c680) at ../hw/block/virtio-blk.c:771
+ * #1  0x0000555555b73d17 in virtio_blk_handle_output_do (s=0x555557913540, vq=0x55555791c680) at ../hw/block/virtio-blk.c:810
+ * #2  0x0000555555b73d73 in virtio_blk_handle_output (vdev=0x555557913540, vq=0x55555791c680) at ../hw/block/virtio-blk.c:826
+ * #3  0x0000555555c5dfdb in virtio_queue_notify (vdev=0x555557913540, n=0) at ../hw/virtio/virtio.c:2366
+ * #4  0x00005555558ea806 in virtio_pci_notify_write (opaque=0x55555790b3b0, addr=0, val=0, size=2) at ../hw/virtio/virtio-pci.c:1343
+ * #5  0x0000555555c4d454 in memory_region_write_accessor (mr=0x55555790c090, addr=0, value=0x7fff31d7c6c8, size=2, shift=0, mask=65535, attrs=...) at ../softmmu/memory.c:491
+ * #6  0x0000555555c4d678 in access_with_adjusted_size (addr=0, value=0x7fff31d7c6c8, size=2, access_size_min=1, access_size_max=4, access_fn=
+ *     0x555555c4d36f <memory_region_write_accessor>, mr=0x55555790c090, attrs=...) at ../softmmu/memory.c:552
+ * #7  0x0000555555c50681 in memory_region_dispatch_write (mr=0x55555790c090, addr=0, data=0, op=MO_16, attrs=...) at ../softmmu/memory.c:1501
+ * #8  0x0000555555bd91bb in flatview_write_continue (fv=0x7fff1c04e870, addr=4261425152, attrs=..., ptr=0x7ffff7fe1028, len=2, addr1=0, l=2, mr=0x55555790c090) at ../softmmu/physmem.c:2759
+ * #9  0x0000555555bd9300 in flatview_write (fv=0x7fff1c04e870, addr=4261425152, attrs=..., buf=0x7ffff7fe1028, len=2) at ../softmmu/physmem.c:2799
+ * #10 0x0000555555bd966e in address_space_write (as=0x55555681a340 <address_space_memory>, addr=4261425152, attrs=..., buf=0x7ffff7fe1028, len=2) at ../softmmu/physmem.c:2891
+ * #11 0x0000555555bd96db in address_space_rw (as=0x55555681a340 <address_space_memory>, addr=4261425152, attrs=..., buf=0x7ffff7fe1028, len=2, is_write=true) at ../softmmu/physmem.c:2901
+ * #12 0x0000555555c25961 in kvm_cpu_exec (cpu=0x555556b08720) at ../accel/kvm/kvm-all.c:2541
+ * #13 0x0000555555c801fe in kvm_vcpu_thread_fn (arg=0x555556b08720) at ../accel/kvm/kvm-cpus.c:49
+ * #14 0x0000555555e40abc in qemu_thread_start (args=0x555556b2f210) at ../util/qemu-thread-posix.c:521
+ * #15 0x00007ffff542fea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #16 0x00007ffff51588cd in clone () at /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|170| <<virtio_blk_data_plane_handle_output>> return virtio_blk_handle_vq(s, vq);
+ *   - hw/block/virtio-blk.c|810| <<virtio_blk_handle_output_do>> virtio_blk_handle_vq(s, vq);
+ */
 bool virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
 {
     VirtIOBlockReq *req;
@@ -805,11 +870,19 @@ bool virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
     return progress;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|826| <<virtio_blk_handle_output>> virtio_blk_handle_output_do(s, vq);
+ */
 static void virtio_blk_handle_output_do(VirtIOBlock *s, VirtQueue *vq)
 {
     virtio_blk_handle_vq(s, vq);
 }
 
+/*
+ * 在以下使用virtio_blk_handle_output():
+ *   - hw/block/virtio-blk.c|1219| <<virtio_blk_device_realize>> virtio_add_queue(vdev, conf->queue_size, virtio_blk_handle_output);
+ */
 static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBlock *s = (VirtIOBlock *)vdev;
diff --git a/hw/i386/kvm/clock.c b/hw/i386/kvm/clock.c
index 24fe5091b..1e0c31080 100644
--- a/hw/i386/kvm/clock.c
+++ b/hw/i386/kvm/clock.c
@@ -50,6 +50,12 @@ struct KVMClockState {
 
     /* whether the 'clock' value was obtained in a host with
      * reliable KVM_GET_CLOCK */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|163| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|198| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|281| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     bool clock_is_reliable;
 };
 
@@ -64,6 +70,10 @@ struct pvclock_vcpu_time_info {
     uint8_t    pad[2];
 } __attribute__((__packed__)); /* 32 bytes */
 
+/*
+ * called by:
+ *   - hw/i386/kvm/clock.c|185| <<kvmclock_vm_state_change>> uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
+ */
 static uint64_t kvmclock_current_nsec(KVMClockState *s)
 {
     CPUState *cpu = first_cpu;
@@ -99,6 +109,12 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     return nsec + time.system_time;
 }
 
+/*
+ * called by:
+ *   - hw/i386/kvm/clock.c|221| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|240| <<kvmclock_realize>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|295| <<kvmclock_pre_save>> kvm_update_clock(s);
+ */
 static void kvm_update_clock(KVMClockState *s)
 {
     struct kvm_clock_data data;
@@ -150,9 +166,19 @@ static void kvm_update_clock(KVMClockState *s)
      *       if !kvm_has_adjust_clock_stable() then
      *               read from memory
      */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|163| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|198| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|281| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     s->clock_is_reliable = kvm_has_adjust_clock_stable();
 }
 
+/*
+ * called by:
+ *   - hw/i386/kvm/clock.c|209| <<kvmclock_vm_state_change>> run_on_cpu(cpu, do_kvmclock_ctrl, RUN_ON_CPU_NULL);
+ */
 static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
 {
     int ret = kvm_vcpu_ioctl(cpu, KVM_KVMCLOCK_CTRL, 0);
@@ -162,6 +188,10 @@ static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/kvm/clock.c|234| <<kvmclock_realize>> qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
+ */
 static void kvmclock_vm_state_change(void *opaque, int running,
                                      RunState state)
 {
@@ -329,6 +359,12 @@ static const TypeInfo kvmclock_info = {
 };
 
 /* Note: Must be called after VCPU initialization. */
+/*
+ * called by:
+ *   - hw/i386/microvm.c|179| <<microvm_devices_init>> kvmclock_create(true);
+ *   - hw/i386/pc_piix.c|162| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+ *   - hw/i386/pc_q35.c|182| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+ */
 void kvmclock_create(bool create_always)
 {
     X86CPU *cpu = X86_CPU(first_cpu);
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index 13d1628f1..00eec9742 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -74,6 +74,12 @@ static const int ide_irq[MAX_IDE_BUS] = { 14, 15 };
 #endif
 
 /* PC hardware initialisation */
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|376| <<pc_init_isa>> pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, TYPE_I440FX_PCI_DEVICE);
+ *   - hw/i386/pc_piix.c|385| <<pc_xen_hvm_init_pci>> pc_init1(machine,
+ *   - hw/i386/pc_piix.c|411| <<DEFINE_I440FX_MACHINE>> pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, TYPE_I440FX_PCI_DEVICE);
+ */
 static void pc_init1(MachineState *machine,
                      const char *host_type, const char *pci_type)
 {
@@ -401,6 +407,38 @@ static void pc_xen_hvm_init(MachineState *machine)
 }
 #endif
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|438| <<global>> DEFINE_I440FX_MACHINE(v5_2, "pc-i440fx-5.2", NULL,
+ *   - hw/i386/pc_piix.c|453| <<global>> DEFINE_I440FX_MACHINE(v5_1, "pc-i440fx-5.1", NULL,
+ *   - hw/i386/pc_piix.c|467| <<global>> DEFINE_I440FX_MACHINE(v5_0, "pc-i440fx-5.0", NULL,
+ *   - hw/i386/pc_piix.c|479| <<global>> DEFINE_I440FX_MACHINE(v4_2, "pc-i440fx-4.2", NULL,
+ *   - hw/i386/pc_piix.c|491| <<global>> DEFINE_I440FX_MACHINE(v4_1, "pc-i440fx-4.1", NULL,
+ *   - hw/i386/pc_piix.c|505| <<global>> DEFINE_I440FX_MACHINE(v4_0, "pc-i440fx-4.0", NULL,
+ *   - hw/i386/pc_piix.c|522| <<global>> DEFINE_I440FX_MACHINE(v3_1, "pc-i440fx-3.1", NULL,
+ *   - hw/i386/pc_piix.c|532| <<global>> DEFINE_I440FX_MACHINE(v3_0, "pc-i440fx-3.0", NULL,
+ *   - hw/i386/pc_piix.c|542| <<global>> DEFINE_I440FX_MACHINE(v2_12, "pc-i440fx-2.12", NULL,
+ *   - hw/i386/pc_piix.c|552| <<global>> DEFINE_I440FX_MACHINE(v2_11, "pc-i440fx-2.11", NULL,
+ *   - hw/i386/pc_piix.c|563| <<global>> DEFINE_I440FX_MACHINE(v2_10, "pc-i440fx-2.10", NULL,
+ *   - hw/i386/pc_piix.c|573| <<global>> DEFINE_I440FX_MACHINE(v2_9, "pc-i440fx-2.9", NULL,
+ *   - hw/i386/pc_piix.c|583| <<global>> DEFINE_I440FX_MACHINE(v2_8, "pc-i440fx-2.8", NULL,
+ *   - hw/i386/pc_piix.c|593| <<global>> DEFINE_I440FX_MACHINE(v2_7, "pc-i440fx-2.7", NULL,
+ *   - hw/i386/pc_piix.c|607| <<global>> DEFINE_I440FX_MACHINE(v2_6, "pc-i440fx-2.6", NULL,
+ *   - hw/i386/pc_piix.c|621| <<global>> DEFINE_I440FX_MACHINE(v2_5, "pc-i440fx-2.5", NULL,
+ *   - hw/i386/pc_piix.c|635| <<global>> DEFINE_I440FX_MACHINE(v2_4, "pc-i440fx-2.4", NULL,
+ *   - hw/i386/pc_piix.c|646| <<global>> DEFINE_I440FX_MACHINE(v2_3, "pc-i440fx-2.3", pc_compat_2_3_fn,
+ *   - hw/i386/pc_piix.c|661| <<global>> DEFINE_I440FX_MACHINE(v2_2, "pc-i440fx-2.2", pc_compat_2_2_fn,
+ *   - hw/i386/pc_piix.c|677| <<global>> DEFINE_I440FX_MACHINE(v2_1, "pc-i440fx-2.1", pc_compat_2_1_fn,
+ *   - hw/i386/pc_piix.c|709| <<global>> DEFINE_I440FX_MACHINE(v2_0, "pc-i440fx-2.0", pc_compat_2_0_fn,
+ *   - hw/i386/pc_piix.c|726| <<global>> DEFINE_I440FX_MACHINE(v1_7, "pc-i440fx-1.7", pc_compat_1_7_fn,
+ *   - hw/i386/pc_piix.c|740| <<global>> DEFINE_I440FX_MACHINE(v1_6, "pc-i440fx-1.6", pc_compat_1_6_fn,
+ *   - hw/i386/pc_piix.c|750| <<global>> DEFINE_I440FX_MACHINE(v1_5, "pc-i440fx-1.5", pc_compat_1_5_fn,
+ *   - hw/i386/pc_piix.c|760| <<global>> DEFINE_I440FX_MACHINE(v1_4, "pc-i440fx-1.4", pc_compat_1_4_fn,
+ *   - hw/i386/pc_piix.c|781| <<global>> DEFINE_I440FX_MACHINE(v1_3, "pc-1.3", pc_compat_1_3,
+ *   - hw/i386/pc_piix.c|801| <<global>> DEFINE_I440FX_MACHINE(v1_2, "pc-1.2", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|823| <<global>> DEFINE_I440FX_MACHINE(v1_1, "pc-1.1", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|841| <<global>> DEFINE_I440FX_MACHINE(v1_0, "pc-1.0", pc_compat_1_2,
+ */
 #define DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn) \
     static void pc_init_##suffix(MachineState *machine) \
     { \
diff --git a/hw/net/vhost_net.c b/hw/net/vhost_net.c
index 24d555e76..531155414 100644
--- a/hw/net/vhost_net.c
+++ b/hw/net/vhost_net.c
@@ -148,6 +148,12 @@ static int vhost_net_get_fd(NetClientState *backend)
     }
 }
 
+/*
+ * called by:
+ *   - net/tap.c|734| <<net_init_tap_one>> s->vhost_net = vhost_net_init(&options);
+ *   - net/vhost-user.c|88| <<vhost_user_start>> net = vhost_net_init(&options);
+ *   - net/vhost-vdpa.c|116| <<vhost_vdpa_add>> net = vhost_net_init(&options);
+ */
 struct vhost_net *vhost_net_init(VhostNetOptions *options)
 {
     int r;
@@ -161,6 +167,15 @@ struct vhost_net *vhost_net_init(VhostNetOptions *options)
     }
     net->nc = options->net_backend;
 
+    /*
+     * struct vhost_net *net:
+     * -> struct vhost_dev dev;
+     *    -> VirtIODevice *vdev;
+     *    -> int nvqs;
+     * -> struct vhost_virtqueue vqs[2];
+     * -> int backend;
+     * -> NetClientState *nc;
+     */
     net->dev.max_queues = 1;
     net->dev.nvqs = 2;
     net->dev.vqs = net->vqs;
@@ -310,6 +325,10 @@ static void vhost_net_stop_one(struct vhost_net *net,
     vhost_dev_disable_notifiers(&net->dev, dev);
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|276| <<virtio_net_vhost_status>> r = vhost_net_start(vdev, n->nic->ncs, queues);
+ */
 int vhost_net_start(VirtIODevice *dev, NetClientState *ncs,
                     int total_queues)
 {
@@ -420,6 +439,10 @@ bool vhost_net_virtqueue_pending(VHostNetState *net, int idx)
     return vhost_virtqueue_pending(&net->dev, idx);
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|3115| <<virtio_net_guest_notifier_mask>> vhost_net_virtqueue_mask(get_vhost_net(nc->peer),
+ */
 void vhost_net_virtqueue_mask(VHostNetState *net, VirtIODevice *dev,
                               int idx, bool mask)
 {
@@ -457,6 +480,14 @@ VHostNetState *get_vhost_net(NetClientState *nc)
     return vhost_net;
 }
 
+/*
+ * called by:
+ *   - backends/cryptodev-vhost.c|147| <<vhost_set_vring_enable>> vhost_set_vring_enable(CryptoDevBackendClient *cc,
+ *   - ackends/cryptodev-vhost.c|219| <<cryptodev_vhost_start>> r = vhost_set_vring_enable(cc, b, i, cc->vring_enable);
+ *   - hw/net/vhost_net.c|359| <<vhost_net_start>> r = vhost_set_vring_enable(peer, peer->vring_enable);
+ *   - hw/net/virtio-net.c|646| <<peer_attach>> vhost_set_vring_enable(nc->peer, 1);
+ *   - hw/net/virtio-net.c|669| <<peer_detach>> vhost_set_vring_enable(nc->peer, 0);
+ */
 int vhost_set_vring_enable(NetClientState *nc, int enable)
 {
     VHostNetState *net = get_vhost_net(nc);
@@ -471,6 +502,10 @@ int vhost_set_vring_enable(NetClientState *nc, int enable)
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|266| <<virtio_net_vhost_status>> r = vhost_net_set_mtu(get_vhost_net(nc->peer), n->net_conf.mtu);
+ */
 int vhost_net_set_mtu(struct vhost_net *net, uint16_t mtu)
 {
     const VhostOps *vhost_ops = net->dev.vhost_ops;
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index 9179013ac..178d98488 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -2391,6 +2391,10 @@ static ssize_t virtio_net_receive(NetClientState *nc, const uint8_t *buf,
 
 static int32_t virtio_net_flush_tx(VirtIONetQueue *q);
 
+/*
+ * 在以下使用virtio_net_tx_complete():
+ *   - hw/net/virtio-net.c|2487| <<virtio_net_flush_tx>> ret = qemu_sendv_packet_async(qemu_get_subqueue(n->nic, queue_index), out_sg, out_num, virtio_net_tx_complete);
+ */
 static void virtio_net_tx_complete(NetClientState *nc, ssize_t len)
 {
     VirtIONet *n = qemu_get_nic_opaque(nc);
@@ -2534,6 +2538,41 @@ static void virtio_net_handle_tx_timer(VirtIODevice *vdev, VirtQueue *vq)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555bcdb28 in virtio_net_handle_tx_bh (vdev=0x5555578816f0, vq=0x7fff306671d8) at ../hw/net/virtio-net.c:2539
+ * #1  0x0000555555c5dec2 in virtio_queue_notify_vq (vq=0x7fff306671d8) at ../hw/virtio/virtio.c:2346
+ * #2  0x0000555555c60f76 in virtio_queue_host_notifier_read (n=0x7fff30667250) at ../hw/virtio/virtio.c:3585
+ * #3  0x0000555555e80900 in aio_dispatch_handler (ctx=0x5555568b6b40, node=0x7fff2804e300) at ../util/aio-posix.c:329
+ * #4  0x0000555555e80ab9 in aio_dispatch_handlers (ctx=0x5555568b6b40) at ../util/aio-posix.c:372
+ * #5  0x0000555555e80b0f in aio_dispatch (ctx=0x5555568b6b40) at ../util/aio-posix.c:382
+ * #6  0x0000555555e5ef83 in aio_ctx_dispatch (source=0x5555568b6b40, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #7  0x00007ffff7447099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #8  0x0000555555e644cb in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #9  0x0000555555e64545 in os_host_main_loop_wait (timeout=2999865660) at ../util/main-loop.c:244
+ * #10 0x0000555555e6464d in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #11 0x0000555555ba3630 in qemu_main_loop () at ../softmmu/vl.c:1678
+ * #12 0x0000555555809b32 in main (argc=14, argv=0x7fffffffe068, envp=0x7fffffffe0e0) at ../softmmu/main.c:50
+ *
+ * ioeventfd=false
+ * (gdb) bt
+ * #0  0x0000555555bcdb28 in virtio_net_handle_tx_bh (vdev=0x5555578816f0, vq=0x7fff30667438) at ../hw/net/virtio-net.c:2539
+ * #1  0x0000555555c5dfdb in virtio_queue_notify (vdev=0x5555578816f0, n=7) at ../hw/virtio/virtio.c:2366
+ * #2  0x00005555558ea806 in virtio_pci_notify_write (opaque=0x555557879560, addr=28, val=7, size=2) at ../hw/virtio/virtio-pci.c:1343
+ * #3  0x0000555555c4d454 in memory_region_write_accessor (mr=0x55555787a240, addr=28, value=0x7fff23ffe6c8, size=2, shift=0, mask=65535, attrs=...) at ../softmmu/memory.c:491
+ * #4  0x0000555555c4d678 in access_with_adjusted_size (addr=28, value=0x7fff23ffe6c8, size=2, access_size_min=1, access_size_max=4, access_fn=
+ *     0x555555c4d36f <memory_region_write_accessor>, mr=0x55555787a240, attrs=...) at ../softmmu/memory.c:552
+ * #5  0x0000555555c50681 in memory_region_dispatch_write (mr=0x55555787a240, addr=28, data=7, op=MO_16, attrs=...) at ../softmmu/memory.c:1501
+ * #6  0x0000555555bd91bb in flatview_write_continue (fv=0x7fff2c1649c0, addr=4261425180, attrs=..., ptr=0x7ffff7fd7028, len=2, addr1=28, l=2, mr=0x55555787a240) at ../softmmu/physmem.c:2759
+ * #7  0x0000555555bd9300 in flatview_write (fv=0x7fff2c1649c0, addr=4261425180, attrs=..., buf=0x7ffff7fd7028, len=2) at ../softmmu/physmem.c:2799
+ * #8  0x0000555555bd966e in address_space_write (as=0x55555681a340 <address_space_memory>, addr=4261425180, attrs=..., buf=0x7ffff7fd7028, len=2) at ../softmmu/physmem.c:2891
+ * #9  0x0000555555bd96db in address_space_rw (as=0x55555681a340 <address_space_memory>, addr=4261425180, attrs=..., buf=0x7ffff7fd7028, len=2, is_write=true) at ../softmmu/physmem.c:2901
+ * #10 0x0000555555c25961 in kvm_cpu_exec (cpu=0x555556bcc680) at ../accel/kvm/kvm-all.c:2541
+ * #11 0x0000555555c801fe in kvm_vcpu_thread_fn (arg=0x555556bcc680) at ../accel/kvm/kvm-cpus.c:49
+ * #12 0x0000555555e40abc in qemu_thread_start (args=0x555556bf26f0) at ../util/qemu-thread-posix.c:521
+ * #13 0x00007ffff542fea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #14 0x00007ffff51588cd in clone () at /lib/../lib64/libc.so.6
+ */
 static void virtio_net_handle_tx_bh(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIONet *n = VIRTIO_NET(vdev);
@@ -3055,6 +3094,10 @@ static NetClientInfo net_virtio_info = {
     .announce = virtio_net_announce,
 };
 
+/*
+ * 在以下使用virtio_net_guest_notifier_pending():
+ *   - hw/net/virtio-net.c|3592| <<virtio_net_class_init>> vdc->guest_notifier_pending = virtio_net_guest_notifier_pending;
+ */
 static bool virtio_net_guest_notifier_pending(VirtIODevice *vdev, int idx)
 {
     VirtIONet *n = VIRTIO_NET(vdev);
diff --git a/hw/pci-host/i440fx.c b/hw/pci-host/i440fx.c
index 28c9bae89..cd6abdbf8 100644
--- a/hw/pci-host/i440fx.c
+++ b/hw/pci-host/i440fx.c
@@ -118,6 +118,49 @@ static const VMStateDescription vmstate_i440fx = {
     }
 };
 
+/*
+ * (gdb) bt
+ * #0  0x000055555596eee4 in i440fx_pcihost_get_pci_hole_start (obj=0x555556ea6550, v=0x55555748e980, name=0x555555ff7fbe "pci-hole-start", opaque=0x0, errp=0x7fffffffda28) at ../hw/pci-host/i440fx.c:124
+ * #1  0x0000555555d115ef in object_property_get (obj=0x555556ea6550, name=0x555555ff7fbe "pci-hole-start", v=0x55555748e980, errp=0x0) at ../qom/object.c:1383
+ * #2  0x0000555555d1590d in object_property_get_qobject (obj=0x555556ea6550, name=0x555555ff7fbe "pci-hole-start", errp=0x0) at ../qom/qom-qobject.c:40
+ * #3  0x0000555555d12009 in object_property_get_uint (obj=0x555556ea6550, name=0x555555ff7fbe "pci-hole-start", errp=0x0) at ../qom/object.c:1583
+ * #4  0x0000555555b04055 in acpi_get_pci_holes (hole=0x7fffffffdbd0, hole64=0x7fffffffdbe0) at ../hw/i386/acpi-build.c:322
+ * #5  0x0000555555b0b10f in acpi_build (tables=0x7fffffffdd50, machine=0x555556b56490) at ../hw/i386/acpi-build.c:2335
+ * #6  0x0000555555b0bdb1 in acpi_setup () at ../hw/i386/acpi-build.c:2626
+ * #7  0x0000555555ae94b3 in pc_machine_done (notifier=0x555556b56628, data=0x0) at ../hw/i386/pc.c:789
+ * #8  0x0000555555e997ff in notifier_list_notify (list=0x5555568baa00 <machine_init_done_notifiers>, data=0x0) at ../util/notify.c:39
+ * #9  0x00005555558b1be2 in qdev_machine_creation_done () at ../hw/core/machine.c:1268
+ * #10 0x0000555555c6598a in qemu_machine_creation_done () at ../softmmu/vl.c:2567
+ * #11 0x0000555555c65a59 in qmp_x_exit_preconfig (errp=0x5555568e2868 <error_fatal>) at ../softmmu/vl.c:2590
+ * #12 0x0000555555c680bd in qemu_init (argc=14, argv=0x7fffffffe0c8, envp=0x7fffffffe140) at ../softmmu/vl.c:3611
+ * #13 0x00005555558199cd in main (argc=14, argv=0x7fffffffe0c8, envp=0x7fffffffe140) at ../softmmu/main.c:49
+ *
+ * (gdb) bt
+ * #0  0x000055555596eee4 in i440fx_pcihost_get_pci_hole_start (obj=0x555556ea6550, v=0x7ffe6804bfb0, name=0x555555ff7fbe "pci-hole-start", opaque=0x0, errp=0x7ffe6d7fe158) at ../hw/pci-host/i440fx.c:124
+ * #1  0x0000555555d115ef in object_property_get (obj=0x555556ea6550, name=0x555555ff7fbe "pci-hole-start", v=0x7ffe6804bfb0, errp=0x0) at ../qom/object.c:1383
+ * #2  0x0000555555d1590d in object_property_get_qobject (obj=0x555556ea6550, name=0x555555ff7fbe "pci-hole-start", errp=0x0) at ../qom/qom-qobject.c:40
+ * #3  0x0000555555d12009 in object_property_get_uint (obj=0x555556ea6550, name=0x555555ff7fbe "pci-hole-start", errp=0x0) at ../qom/object.c:1583
+ * #4  0x0000555555b04055 in acpi_get_pci_holes (hole=0x7ffe6d7fe300, hole64=0x7ffe6d7fe310) at ../hw/i386/acpi-build.c:322
+ * #5  0x0000555555b0b10f in acpi_build (tables=0x7ffe6d7fe460, machine=0x555556b56490) at ../hw/i386/acpi-build.c:2335
+ * #6  0x0000555555b0bc22 in acpi_build_update (build_opaque=0x55555746e1a0) at ../hw/i386/acpi-build.c:2567
+ * #7  0x0000555555824ca9 in fw_cfg_select (s=0x555556e678b0, key=41) at ../hw/nvram/fw_cfg.c:298
+ * #8  0x0000555555824f73 in fw_cfg_dma_transfer (s=0x555556e678b0) at ../hw/nvram/fw_cfg.c:371
+ * #9  0x000055555582533a in fw_cfg_dma_mem_write (opaque=0x555556e678b0, addr=4, value=27736, size=4) at ../hw/nvram/fw_cfg.c:469
+ * #10 0x0000555555c73d6a in memory_region_write_accessor (mr=0x555556e67c30, addr=4, value=0x7ffe6d7fe688, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:491
+ * #11 0x0000555555c73f3a in access_with_adjusted_size (addr=4, value=0x7ffe6d7fe688, size=4, access_size_min=1, access_size_max=8, access_fn=
+ *                           0x555555c73c85 <memory_region_write_accessor>, mr=0x555556e67c30, attrs=...) at ../softmmu/memory.c:547
+ * #12 0x0000555555c76f8d in memory_region_dispatch_write (mr=0x555556e67c30, addr=4, data=27736, op=MO_32, attrs=...) at ../softmmu/memory.c:1502
+ * #13 0x0000555555cac5b0 in flatview_write_continue (fv=0x7ffe6801bc10, addr=1304, attrs=..., ptr=0x7ffff7ff4000, len=4, addr1=4, l=4, mr=0x555556e67c30) at ../softmmu/physmem.c:2746
+ * #14 0x0000555555cac6f5 in flatview_write (fv=0x7ffe6801bc10, addr=1304, attrs=..., buf=0x7ffff7ff4000, len=4) at ../softmmu/physmem.c:2786
+ * #15 0x0000555555caca61 in address_space_write (as=0x5555568ded80 <address_space_io>, addr=1304, attrs=..., buf=0x7ffff7ff4000, len=4) at ../softmmu/physmem.c:2878
+ * #16 0x0000555555cacace in address_space_rw (as=0x5555568ded80 <address_space_io>, addr=1304, attrs=..., buf=0x7ffff7ff4000, len=4, is_write=true) at ../softmmu/physmem.c:2888
+ * #17 0x0000555555bdb571 in kvm_handle_io (port=1304, attrs=..., data=0x7ffff7ff4000, direction=1, size=4, count=1) at ../accel/kvm/kvm-all.c:2256
+ * #18 0x0000555555bdbd33 in kvm_cpu_exec (cpu=0x555556ba7290) at ../accel/kvm/kvm-all.c:2507
+ * #19 0x0000555555cd8e31 in kvm_vcpu_thread_fn (arg=0x555556ba7290) at ../accel/kvm/kvm-accel-ops.c:49
+ * #20 0x0000555555e8bec1 in qemu_thread_start (args=0x555556bb5020) at ../util/qemu-thread-posix.c:521
+ * #21 0x00007ffff542fea5 in start_thread () at /lib64/libpthread.so.0
+ * #22 0x00007ffff51588cd in clone () at /lib64/libc.so.6
+ */
 static void i440fx_pcihost_get_pci_hole_start(Object *obj, Visitor *v,
                                               const char *name, void *opaque,
                                               Error **errp)
@@ -237,6 +280,18 @@ static void i440fx_realize(PCIDevice *dev, Error **errp)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|202| <<pc_init1>> pci_bus = i440fx_init(host_type,
+ *
+ * 202         pci_bus = i440fx_init(host_type,
+ * 203                               pci_type,
+ * 204                               &i440fx_state,
+ * 205                               system_memory, system_io, machine->ram_size,
+ * 206                               x86ms->below_4g_mem_size,
+ * 207                               x86ms->above_4g_mem_size,
+ * 208                               pci_memory, ram_memory);
+ */
 PCIBus *i440fx_init(const char *host_type, const char *pci_type,
                     PCII440FXState **pi440fx_state,
                     MemoryRegion *address_space_mem,
diff --git a/hw/pci/msi.c b/hw/pci/msi.c
index 47d2b0f33..514055f82 100644
--- a/hw/pci/msi.c
+++ b/hw/pci/msi.c
@@ -182,6 +182,26 @@ bool msi_enabled(const PCIDevice *dev)
  *  also means a programming error, except device assignment, which can check
  *  if a real HW is broken.
  */
+/*
+ * called by:
+ *   - hw/audio/intel-hda.c|1103| <<intel_hda_realize>> ret = msi_init(&d->pci, d->old_msi_addr ? 0x50 : 0x60,
+ *   - hw/i386/amd_iommu.c|1584| <<amdvi_realize>> msi_init(&s->pci.dev, 0, 1, true, false, errp);
+ *   - hw/ide/ich.c|148| <<pci_ich9_ahci_realize>> ret = msi_init(dev, ICH9_MSI_CAP_OFFSET, 1, true, false, NULL);
+ *   - hw/misc/edu.c|369| <<pci_edu_realize>> if (msi_init(pdev, 0, 1, true, false, errp)) {
+ *   - hw/net/e1000e.c|477| <<e1000e_pci_realize>> ret = msi_init(PCI_DEVICE(s), 0xD0, 1, true, false, NULL);
+ *   - hw/net/vmxnet3.c|2213| <<vmxnet3_pci_realize>> ret = msi_init(pci_dev, VMXNET3_MSI_OFFSET(s), VMXNET3_MAX_NMSIX_INTRS,
+ *   - hw/pci-bridge/ioh3420.c|69| <<ioh3420_interrupts_init>> rc = msi_init(d, IOH_EP_MSI_OFFSET, IOH_EP_MSI_NR_VECTOR,
+ *   - hw/pci-bridge/pci_bridge_dev.c|86| <<pci_bridge_dev_realize>> err = msi_init(dev, 0, 1, true, true, &local_err);
+ *   - hw/pci-bridge/pcie_pci_bridge.c|72| <<pcie_pci_bridge_realize>> rc = msi_init(d, 0, 1, true, true, &local_err);
+ *   - hw/pci-bridge/xio3130_downstream.c|74| <<xio3130_downstream_realize>> rc = msi_init(d, XIO3130_MSI_OFFSET, XIO3130_MSI_NR_VECTOR,
+ *   - hw/pci-bridge/xio3130_upstream.c|65| <<xio3130_upstream_realize>> rc = msi_init(d, XIO3130_MSI_OFFSET, XIO3130_MSI_NR_VECTOR,
+ *   - hw/pci-host/designware.c|402| <<designware_pcie_root_realize>> msi_init(dev, 0x50, 32, true, true, &error_fatal);
+ *   - hw/scsi/megasas.c|2338| <<megasas_scsi_realize>> ret = msi_init(dev, 0x50, 1, true, false, &err);
+ *   - hw/scsi/mptsas.c|1278| <<mptsas_scsi_realize>> ret = msi_init(dev, 0, 1, true, false, &err);
+ *   - hw/scsi/vmw_pvscsi.c|1069| <<pvscsi_init_msi>> res = msi_init(d, PVSCSI_MSI_OFFSET(s), PVSCSI_MSIX_NUM_VECTORS,
+ *   - hw/usb/hcd-xhci-pci.c|128| <<usb_xhci_pci_realize>> ret = msi_init(dev, 0x70, s->xhci.numintrs, true, false, &err);
+ *   - hw/vfio/pci.c|1394| <<vfio_msi_setup>> ret = msi_init(&vdev->pdev, pos, entries, msi_64bit, msi_maskbit, &err);
+ */
 int msi_init(struct PCIDevice *dev, uint8_t offset,
              unsigned int nr_vectors, bool msi64bit,
              bool msi_per_vector_mask, Error **errp)
diff --git a/hw/pci/msix.c b/hw/pci/msix.c
index 67e34f34d..62550aaff 100644
--- a/hw/pci/msix.c
+++ b/hw/pci/msix.c
@@ -103,6 +103,14 @@ static void msix_fire_vector_notifier(PCIDevice *dev,
     MSIMessage msg;
     int ret;
 
+    /*
+     * 在以下设置PCIDevice->msix_vector_use_notifier:
+     *   - hw/pci/msix.c|601| <<msix_set_vector_notifiers>> dev->msix_vector_use_notifier = use_notifier;
+     *   - hw/pci/msix.c|623| <<msix_set_vector_notifiers>> dev->msix_vector_use_notifier = NULL;
+     *   - hw/pci/msix.c|641| <<msix_unset_vector_notifiers>> dev->msix_vector_use_notifier = NULL;
+     *
+     * vfio_msix_vector_use()
+     */
     if (!dev->msix_vector_use_notifier) {
         return;
     }
@@ -115,6 +123,30 @@ static void msix_fire_vector_notifier(PCIDevice *dev,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555856deb in msix_handle_mask_update (dev=0x555557879560, vector=0, was_masked=true) at ../hw/pci/msix.c:120
+ * #1  0x00005555558570c4 in msix_table_mmio_write (opaque=0x555557879560, addr=0, val=4276092928, size=4) at ../hw/pci/msix.c:194
+ * #2  0x0000555555c4d454 in memory_region_write_accessor (mr=0x555557879b00, addr=0, value=0x7fff30ffc6c8, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:491
+ * #3  0x0000555555c4d678 in access_with_adjusted_size (addr=0, value=0x7fff30ffc6c8, size=4, access_size_min=1, access_size_max=4, access_fn=
+ *                             0x555555c4d36f <memory_region_write_accessor>, mr=0x555557879b00, attrs=...) at ../softmmu/memory.c:552
+ * #4  0x0000555555c50681 in memory_region_dispatch_write (mr=0x555557879b00, addr=0, data=4276092928, op=MO_32, attrs=...) at ../softmmu/memory.c:1501
+ * #5  0x0000555555bd91bb in flatview_write_continue (fv=0x7fff28000a20, addr=4273803264, attrs=..., ptr=0x7ffff7fdb028, len=4, addr1=0, l=4, mr=0x555557879b00) at ../softmmu/physmem.c:2759
+ * #6  0x0000555555bd9300 in flatview_write (fv=0x7fff28000a20, addr=4273803264, attrs=..., buf=0x7ffff7fdb028, len=4) at ../softmmu/physmem.c:2799
+ * #7  0x0000555555bd966e in address_space_write (as=0x55555681a340 <address_space_memory>, addr=4273803264, attrs=..., buf=0x7ffff7fdb028, len=4) at ../softmmu/physmem.c:2891
+ * #8  0x0000555555bd96db in address_space_rw (as=0x55555681a340 <address_space_memory>, addr=4273803264, attrs=..., buf=0x7ffff7fdb028, len=4, is_write=true) at ../softmmu/physmem.c:2901
+ * #9  0x0000555555c25961 in kvm_cpu_exec (cpu=0x555556ba5dd0) at ../accel/kvm/kvm-all.c:2541
+ * #10 0x0000555555c801fe in kvm_vcpu_thread_fn (arg=0x555556ba5dd0) at ../accel/kvm/kvm-cpus.c:49
+ * #11 0x0000555555e40abc in qemu_thread_start (args=0x555556bcbc60) at ../util/qemu-thread-posix.c:521
+ * #12 0x00007ffff542fea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #13 0x00007ffff51588cd in clone () at /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/pci/msix.c|172| <<msix_write_config>> msix_handle_mask_update(dev, vector,
+ *   - hw/pci/msix.c|194| <<msix_table_mmio_write>> msix_handle_mask_update(dev, vector, was_masked);
+ *   - hw/pci/msix.c|251| <<msix_mask_all>> msix_handle_mask_update(dev, vector, was_masked);
+ *   - hw/pci/msix.c|466| <<msix_load>> msix_handle_mask_update(dev, vector, true);
+ */
 static void msix_handle_mask_update(PCIDevice *dev, int vector, bool was_masked)
 {
     bool is_masked = msix_is_masked(dev, vector);
@@ -272,6 +304,17 @@ static void msix_mask_all(struct PCIDevice *dev, unsigned nentries)
  * also means a programming error, except device assignment, which can check
  * if a real HW is broken.
  */
+/*
+ * called by:
+ *   - hw/net/e1000e.c|297| <<e1000e_init_msix>> int res = msix_init(PCI_DEVICE(s), E1000E_MSIX_VEC_NUM,
+ *   - hw/net/rocker/rocker.c|1245| <<rocker_msix_init>> err = msix_init(dev, ROCKER_MSIX_VEC_COUNT(r->fp_ports),
+ *   - hw/net/vmxnet3.c|2105| <<vmxnet3_init_msix>> int res = msix_init(d, VMXNET3_MAX_INTRS,
+ *   - hw/pci/msix.c|409| <<msix_init_exclusive_bar>> ret = msix_init(dev, nentries, &dev->msix_exclusive_bar, bar_nr,
+ *   - hw/rdma/vmw/pvrdma_main.c|292| <<init_msix>> rc = msix_init(pdev, RDMA_MAX_INTRS, &dev->msix, RDMA_MSIX_BAR_IDX,
+ *   - hw/scsi/megasas.c|2363| <<megasas_scsi_realize>> msix_init(dev, 15, &s->mmio_io, b->mmio_bar, 0x2000,
+ *   - hw/usb/hcd-xhci-pci.c|158| <<usb_xhci_pci_realize>> msix_init(dev, s->xhci.numintrs,
+ *   - hw/vfio/pci.c|1686| <<vfio_msix_setup>> ret = msix_init(&vdev->pdev, vdev->msix->entries,
+ */
 int msix_init(struct PCIDevice *dev, unsigned short nentries,
               MemoryRegion *table_bar, uint8_t table_bar_nr,
               unsigned table_offset, MemoryRegion *pba_bar,
@@ -344,6 +387,13 @@ int msix_init(struct PCIDevice *dev, unsigned short nentries,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/block/nvme.c|2682| <<nvme_init_pci>> if (msix_init_exclusive_bar(pci_dev, n->params.msix_qsize, 4, errp)) {
+ *   - hw/misc/ivshmem.c|734| <<ivshmem_setup_interrupts>> if (msix_init_exclusive_bar(PCI_DEVICE(s), s->vectors, 1, errp)) {
+ *   - hw/pci-bridge/gen_pcie_root_port.c|51| <<gen_rp_interrupts_init>> rc = msix_init_exclusive_bar(d, GEN_PCIE_ROOT_PORT_MSIX_NR_VECTOR, 0, errp);
+ *   - hw/virtio/virtio-pci.c|1756| <<virtio_pci_device_plugged>> int err = msix_init_exclusive_bar(&proxy->pci_dev, proxy->nvectors,
+ */
 int msix_init_exclusive_bar(PCIDevice *dev, unsigned short nentries,
                             uint8_t bar_nr, Error **errp)
 {
@@ -468,6 +518,27 @@ void msix_load(PCIDevice *dev, QEMUFile *f)
 }
 
 /* Does device support MSI-X? */
+/*
+ * called by:
+ *   - hw/pci/msix.c|182| <<msix_write_config>> if (!msix_present(dev) || !range_covers_byte(addr, len, enable_pos)) {
+ *   - hw/pci/msix.c|443| <<msix_uninit>> if (!msix_present(dev)) {
+ *   - hw/pci/msix.c|463| <<msix_uninit_exclusive_bar>> if (msix_present(dev)) {
+ *   - hw/pci/msix.c|472| <<msix_save>> if (!msix_present(dev)) {
+ *   - hw/pci/msix.c|486| <<msix_load>> if (!msix_present(dev)) {
+ *   - hw/pci/msix.c|535| <<msix_reset>> if (!msix_present(dev)) {
+ *   - hw/pci/msix.c|579| <<msix_unuse_all_vectors>> if (!msix_present(dev)) {
+ *   - hw/ppc/spapr_pci.c|303| <<rtas_ibm_change_msi>> } else if (msix_present(pdev)) {
+ *   - hw/ppc/spapr_pci.c|319| <<rtas_ibm_change_msi>> if (msix_present(pdev)) {
+ *   - hw/ppc/spapr_pci.c|345| <<rtas_ibm_change_msi>> if (msix_present(pdev)) {
+ *   - hw/ppc/spapr_pci.c|1426| <<spapr_dt_pci_device>> if (msix_present(dev)) {
+ *   - hw/scsi/megasas.c|2011| <<megasas_mmio_read>> retval = (msix_present(pci_dev) ? MFI_FWSTATE_MSIX_SUPPORTED : 0) |
+ *   - hw/vfio/pci.c|2652| <<vfio_msix_present>> return msix_present(pdev);
+ *   - hw/virtio/virtio-pci.c|40| <<VIRTIO_PCI_REGION_SIZE>> #define VIRTIO_PCI_REGION_SIZE(dev) VIRTIO_PCI_CONFIG_OFF(msix_present(dev))
+ *   - hw/virtio/virtio-pci.c|90| <<virtio_pci_save_config>> if (msix_present(&proxy->pci_dev))
+ *   - hw/virtio/virtio-pci.c|172| <<virtio_pci_save_queue>> if (msix_present(&proxy->pci_dev))
+ *   - hw/virtio/virtio-pci.c|188| <<virtio_pci_load_config>> if (msix_present(&proxy->pci_dev)) {
+ *   - hw/virtio/virtio-pci.c|205| <<virtio_pci_load_queue>> if (msix_present(&proxy->pci_dev)) {
+ */
 int msix_present(PCIDevice *dev)
 {
     return dev->cap_present & QEMU_PCI_CAP_MSIX;
@@ -576,6 +647,12 @@ static void msix_unset_notifier_for_vector(PCIDevice *dev, unsigned int vector)
     dev->msix_vector_release_notifier(dev, vector);
 }
 
+/*
+ * 在以下使用msix_set_vector_notifiers():
+ *   - hw/misc/ivshmem.c|774| <<ivshmem_enable_irqfd>> if (msix_set_vector_notifiers(pdev,
+ *   - hw/vfio/pci.c|603| <<vfio_msix_enable>> if (msix_set_vector_notifiers(&vdev->pdev, vfio_msix_vector_use,
+ *   - hw/virtio/virtio-pci.c|1042| <<virtio_pci_set_guest_notifiers>> r = msix_set_vector_notifiers(&proxy->pci_dev,
+ */
 int msix_set_vector_notifiers(PCIDevice *dev,
                               MSIVectorUseNotifier use_notifier,
                               MSIVectorReleaseNotifier release_notifier,
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index 0131d9d02..d580957e4 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -224,6 +224,12 @@ static void pci_del_option_rom(PCIDevice *pdev);
 static uint16_t pci_default_sub_vendor_id = PCI_SUBVENDOR_ID_REDHAT_QUMRANET;
 static uint16_t pci_default_sub_device_id = PCI_SUBDEVICE_ID_QEMU;
 
+/*
+ * 在以下使用pci_host_bridges (链接PCIHostState类型):
+ *   - hw/pci/pci.c|371| <<pci_host_bus_register>> QLIST_INSERT_HEAD(&pci_host_bridges, host_bridge, next);
+ *   - hw/pci/pci.c|1863| <<qmp_query_pci>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+ *   - hw/pci/pci.c|2632| <<pci_qdev_find_device>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+ */
 static QLIST_HEAD(, PCIHostState) pci_host_bridges;
 
 int pci_bar(PCIDevice *d, int reg)
@@ -364,10 +370,20 @@ static void pcibus_reset(BusState *qbus)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|425| <<pci_root_bus_init>> pci_host_bus_register(parent);
+ */
 static void pci_host_bus_register(DeviceState *host)
 {
     PCIHostState *host_bridge = PCI_HOST_BRIDGE(host);
 
+    /*
+     * 在以下使用pci_host_bridges (链接PCIHostState类型):
+     *   - hw/pci/pci.c|371| <<pci_host_bus_register>> QLIST_INSERT_HEAD(&pci_host_bridges, host_bridge, next);
+     *   - hw/pci/pci.c|1863| <<qmp_query_pci>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     *   - hw/pci/pci.c|2632| <<pci_qdev_find_device>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     */
     QLIST_INSERT_HEAD(&pci_host_bridges, host_bridge, next);
 }
 
@@ -407,6 +423,11 @@ const char *pci_root_bus_path(PCIDevice *dev)
     return rootbus->qbus.name;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|445| <<pci_root_bus_new_inplace>> pci_root_bus_init(bus, parent, address_space_mem, address_space_io,
+ *   - hw/pci/pci.c|457| <<pci_root_bus_new>> pci_root_bus_init(bus, parent, address_space_mem, address_space_io,
+ */
 static void pci_root_bus_init(PCIBus *bus, DeviceState *parent,
                               MemoryRegion *address_space_mem,
                               MemoryRegion *address_space_io,
@@ -1325,6 +1346,12 @@ static pcibus_t pci_bar_address(PCIDevice *d,
     return new_addr;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|330| <<pci_do_device_reset>> pci_update_mappings(dev);
+ *   - hw/pci/pci.c|545| <<get_pci_config_device>> pci_update_mappings(s);
+ *   - hw/pci/pci.c|1421| <<pci_default_write_config>> pci_update_mappings(d);
+ */
 static void pci_update_mappings(PCIDevice *d)
 {
     PCIIORegion *r;
@@ -1757,6 +1784,10 @@ static PciBridgeInfo *qmp_query_pci_bridge(PCIDevice *dev, PCIBus *bus,
     return info;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|1850| <<qmp_query_pci_devices>> info->value = qmp_query_pci_device(dev, bus, bus_num);
+ */
 static PciDeviceInfo *qmp_query_pci_device(PCIDevice *dev, PCIBus *bus,
                                            int bus_num)
 {
@@ -1854,6 +1885,12 @@ PciInfoList *qmp_query_pci(Error **errp)
     PciInfoList *info, *head = NULL, *cur_item = NULL;
     PCIHostState *host_bridge;
 
+    /*
+     * 在以下使用pci_host_bridges (链接PCIHostState类型):
+     *   - hw/pci/pci.c|371| <<pci_host_bus_register>> QLIST_INSERT_HEAD(&pci_host_bridges, host_bridge, next);
+     *   - hw/pci/pci.c|1863| <<qmp_query_pci>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     *   - hw/pci/pci.c|2632| <<pci_qdev_find_device>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     */
     QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
         info = g_malloc0(sizeof(*info));
         info->value = qmp_query_pci_bus(host_bridge->bus,
@@ -2623,6 +2660,12 @@ int pci_qdev_find_device(const char *id, PCIDevice **pdev)
     PCIHostState *host_bridge;
     int rc = -ENODEV;
 
+    /*
+     * 在以下使用pci_host_bridges (链接PCIHostState类型):
+     *   - hw/pci/pci.c|371| <<pci_host_bus_register>> QLIST_INSERT_HEAD(&pci_host_bridges, host_bridge, next);
+     *   - hw/pci/pci.c|1863| <<qmp_query_pci>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     *   - hw/pci/pci.c|2632| <<pci_qdev_find_device>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     */
     QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
         int tmp = pci_qdev_find_recursive(host_bridge->bus, id, pdev);
         if (!tmp) {
@@ -2668,6 +2711,11 @@ static void pci_device_class_base_init(ObjectClass *klass, void *data)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|96| <<pci_init_bus_master>> AddressSpace *dma_as = pci_device_iommu_address_space(pci_dev);
+ *   - hw/vfio/pci.c|2824| <<vfio_realize>> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
+ */
 AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
 {
     PCIBus *bus = pci_get_bus(dev);
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index b901e701f..5571efc0b 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -854,6 +854,18 @@ int scsi_device_get_sense(SCSIDevice *dev, uint8_t *buf, int len, bool fixed)
     return scsi_convert_sense(dev->sense, dev->sense_len, buf, len, fixed);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|384| <<scsi_invalid_field>> scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-bus.c|398| <<scsi_invalid_command>> scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
+ *   - hw/scsi/scsi-bus.c|413| <<scsi_unit_attention>> scsi_req_build_sense(req, req->dev->unit_attention);
+ *   - hw/scsi/scsi-bus.c|415| <<scsi_unit_attention>> scsi_req_build_sense(req, req->bus->unit_attention);
+ *   - hw/scsi/scsi-bus.c|575| <<scsi_target_send_command>> scsi_req_build_sense(req, SENSE_CODE(LUN_NOT_SUPPORTED));
+ *   - hw/scsi/scsi-bus.c|611| <<scsi_target_send_command>> scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
+ *   - hw/scsi/scsi-bus.c|615| <<scsi_target_send_command>> scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-disk.c|127| <<scsi_check_condition>> scsi_req_build_sense(&r->req, sense);
+ *   - hw/scsi/scsi-generic.c|89| <<scsi_command_complete_noio>> scsi_req_build_sense(&r->req, sense);
+ */
 void scsi_req_build_sense(SCSIRequest *req, SCSISense sense)
 {
     trace_scsi_req_build_sense(req->dev->id, req->lun, req->tag,
@@ -1451,6 +1463,20 @@ void scsi_req_print(SCSIRequest *req)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  0x00005555558199a3 in scsi_req_complete (req=0x555557055000, status=0) at ../hw/scsi/scsi-bus.c:1456
+ * #1  0x0000555555a52f28 in scsi_dma_complete_noio (r=0x555557055000, ret=0) at ../hw/scsi/scsi-disk.c:275
+ * #2  0x0000555555a53035 in scsi_dma_complete (opaque=0x555557055000, ret=0) at ../hw/scsi/scsi-disk.c:296
+ * #3  0x000055555595db55 in dma_complete (dbs=0x555556ef5940, ret=0) at ../softmmu/dma-helpers.c:120
+ * #4  0x000055555595dc02 in dma_blk_cb (opaque=0x555556ef5940, ret=0) at ../softmmu/dma-helpers.c:138
+ * #5  0x0000555555cdf122 in blk_aio_complete (acb=0x55555729ea00) at ../block/block-backend.c:1412
+ * #6  0x0000555555cdf7ea in blk_aio_ioctl_entry (opaque=0x55555729ea00) at ../block/block-backend.c:1596
+ * #7  0x0000555555e327ab in coroutine_trampoline (i0=-469733232, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #8  0x00007ffff5ea2190 in __start_context () at /lib64/libc.so.6
+ * #9  0x00007ff7eed38b10 in  ()
+ * #10 0x0000000000000000 in  ()
+ */
 void scsi_req_complete(SCSIRequest *req, int status)
 {
     assert(req->status == -1);
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index 90841ad79..e94614e65 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -279,6 +279,34 @@ done:
     scsi_req_unref(&r->req);
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555a52f46 in scsi_dma_complete (opaque=0x555556a755a0, ret=0) at ../hw/scsi/scsi-disk.c:283
+ * #1  0x000055555595db55 in dma_complete (dbs=0x555557325d50, ret=0) at ../softmmu/dma-helpers.c:120
+ * #2  0x000055555595dc02 in dma_blk_cb (opaque=0x555557325d50, ret=0) at ../softmmu/dma-helpers.c:138
+ * #3  0x0000555555cdf122 in blk_aio_complete (acb=0x55555729ea00) at ../block/block-backend.c:1412
+ * #4  0x0000555555cdf7ea in blk_aio_ioctl_entry (opaque=0x55555729ea00) at ../block/block-backend.c:1596
+ * #5  0x0000555555e327ab in coroutine_trampoline (i0=-671058272, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #6  0x00007ffff5ea2190 in __start_context () at /lib64/libc.so.6
+ * #7  0x00007ff7ee537b10 in  ()
+ * #8  0x0000000000000000 in  ()
+ *
+ * 在以下使用scsi_dma_complete():
+ *   - hw/scsi/scsi-disk.c|357| <<scsi_do_read>> sdc->dma_readv, r, scsi_dma_complete, r,
+ *   - hw/scsi/scsi-disk.c|600| <<scsi_write_data>> sdc->dma_writev, r, scsi_dma_complete, r,
+ *
+ * 370         r->req.aiocb = dma_blk_io(blk_get_aio_context(s->qdev.conf.blk),
+ * 371                                   r->req.sg, r->sector << BDRV_SECTOR_BITS,
+ * 372                                   BDRV_SECTOR_SIZE,
+ * 373                                   sdc->dma_readv, r, scsi_dma_complete, r,
+ * 374                                   DMA_DIRECTION_FROM_DEVICE);
+ *
+ * 619         r->req.aiocb = dma_blk_io(blk_get_aio_context(s->qdev.conf.blk),
+ * 620                                   r->req.sg, r->sector << BDRV_SECTOR_BITS,
+ * 621                                   BDRV_SECTOR_SIZE,
+ * 622                                   sdc->dma_writev, r, scsi_dma_complete, r,
+ * 623                                   DMA_DIRECTION_TO_DEVICE);
+ */
 static void scsi_dma_complete(void *opaque, int ret)
 {
     SCSIDiskReq *r = (SCSIDiskReq *)opaque;
@@ -455,6 +483,12 @@ static bool scsi_handle_rw_error(SCSIDiskReq *r, int error, bool acct_failed)
             assert(r->status && *r->status);
             if (scsi_sense_buf_is_guest_recoverable(r->req.sense, sizeof(r->req.sense))) {
                 /* These errors are handled by guest. */
+                /*
+		 * 在以下使用update_sense:
+		 *   - hw/scsi/scsi-disk.c|65| <<OBJECT_DECLARE_TYPE>> void (*update_sense)(SCSIRequest *r);
+		 *   - hw/scsi/scsi-disk.c|486| <<scsi_handle_rw_error>> sdc->update_sense(&r->req);
+		 *   - hw/scsi/scsi-disk.c|3147| <<scsi_block_class_initfn>> sdc->update_sense = scsi_block_update_sense;
+		 */
                 sdc->update_sense(&r->req);
                 scsi_req_complete(&r->req, *r->status);
                 return true;
@@ -2944,10 +2978,28 @@ static int scsi_block_parse_cdb(SCSIDevice *d, SCSICommand *cmd,
     }
 }
 
+/*
+ * 在以下使用scsi_block_update_sense():
+ *   - hw/scsi/scsi-disk.c|3147| <<scsi_block_class_initfn>> sdc->update_sense = scsi_block_update_sense;
+ */
 static void scsi_block_update_sense(SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
     SCSIBlockReq *br = DO_UPCAST(SCSIBlockReq, req, r);
+    /*
+     * 部分在以下设置SCSIRequest->sense_len(怕找不全):
+     *   - hw/scsi/scsi-bus.c|873| <<scsi_req_build_sense>> req->sense_len = scsi_build_sense(req->sense, sense);
+     *   - hw/scsi/scsi-bus.c|1487| <<scsi_req_complete>> req->sense_len = 0;
+     *   - hw/scsi/scsi-disk.c|2979| <<scsi_block_update_sense>> r->req.sense_len = MIN(br->io_header.sb_len_wr, sizeof(r->req.sense));
+     *   - hw/scsi/scsi-generic.c|87| <<scsi_command_complete_noio>> r->req.sense_len = r->io_header.sb_len_wr;
+     * 部分在以下使用SCSIRequest->sense_len(怕找不全):
+     *   - hw/scsi/scsi-bus.c|829| <<scsi_req_get_sense>> if (!req->sense_len) {
+     *   - hw/scsi/scsi-bus.c|833| <<scsi_req_get_sense>> ret = scsi_convert_sense(req->sense, req->sense_len, buf, len, true);
+     *   - hw/scsi/scsi-bus.c|1485| <<scsi_req_complete>> assert(req->sense_len <= sizeof(req->sense));
+     *   - hw/scsi/scsi-bus.c|1490| <<scsi_req_complete>> if (req->sense_len) {
+     *   - hw/scsi/scsi-bus.c|1491| <<scsi_req_complete>> memcpy(req->dev->sense, req->sense, req->sense_len);
+     *   - hw/scsi/scsi-bus.c|1492| <<scsi_req_complete>> req->dev->sense_len = req->sense_len;
+     */
     r->req.sense_len = MIN(br->io_header.sb_len_wr, sizeof(r->req.sense));
 }
 #endif
diff --git a/hw/scsi/vhost-scsi-common.c b/hw/scsi/vhost-scsi-common.c
index 767f827e5..9f7f93087 100644
--- a/hw/scsi/vhost-scsi-common.c
+++ b/hw/scsi/vhost-scsi-common.c
@@ -25,6 +25,11 @@
 #include "hw/virtio/virtio-access.h"
 #include "hw/fw-path-provider.h"
 
+/*
+ * called by:
+ *   - hw/scsi/vhost-scsi.c|91| <<vhost_scsi_start>> ret = vhost_scsi_common_start(vsc);
+ *   - hw/scsi/vhost-user-scsi.c|58| <<vhost_user_scsi_set_status>> ret = vhost_scsi_common_start(vsc);
+ */
 int vhost_scsi_common_start(VHostSCSICommon *vsc)
 {
     int ret, i;
diff --git a/hw/scsi/vhost-scsi.c b/hw/scsi/vhost-scsi.c
index 4d70fa036..f67233d4f 100644
--- a/hw/scsi/vhost-scsi.c
+++ b/hw/scsi/vhost-scsi.c
@@ -177,6 +177,16 @@ static void vhost_scsi_realize(DeviceState *dev, Error **errp)
     }
 
     if (vs->conf.vhostfd) {
+        /*
+	 * 在以下使用monitor_fd_param():
+	 *   - hw/scsi/vhost-scsi.c|180| <<vhost_scsi_realize>> vhostfd = monitor_fd_param(monitor_cur(), vs->conf.vhostfd, errp);
+	 *   - hw/virtio/vhost-vsock.c|147| <<vhost_vsock_device_realize>> vhostfd = monitor_fd_param(monitor_cur(), vsock->conf.vhostfd, errp);
+	 *   - migration/fd.c|58| <<fd_start_incoming_migration>> int fd = monitor_fd_param(monitor_cur(), fdname, errp);
+	 *   - net/socket.c|730| <<net_init_socket>> fd = monitor_fd_param(monitor_cur(), sock->fd, errp);
+	 *   - net/tap.c|703| <<net_init_tap_one>> vhostfd = monitor_fd_param(monitor_cur(), vhostfdname, &err);
+	 *   - net/tap.c|811| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), tap->fd, errp);
+	 *   - net/tap.c|867| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), fds[i], errp);
+	 */
         vhostfd = monitor_fd_param(monitor_cur(), vs->conf.vhostfd, errp);
         if (vhostfd == -1) {
             error_prepend(errp, "vhost-scsi: unable to parse vhostfd: ");
diff --git a/hw/scsi/virtio-scsi-dataplane.c b/hw/scsi/virtio-scsi-dataplane.c
index b995bab3a..6c3af30d0 100644
--- a/hw/scsi/virtio-scsi-dataplane.c
+++ b/hw/scsi/virtio-scsi-dataplane.c
@@ -22,6 +22,10 @@
 #include "hw/virtio/virtio-access.h"
 
 /* Context: QEMU global mutex held */
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|959| <<virtio_scsi_device_realize>> virtio_scsi_dataplane_setup(s, errp);
+ */
 void virtio_scsi_dataplane_setup(VirtIOSCSI *s, Error **errp)
 {
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);
@@ -49,6 +53,10 @@ void virtio_scsi_dataplane_setup(VirtIOSCSI *s, Error **errp)
     }
 }
 
+/*
+ * 在以下使用virtio_scsi_data_plane_handle_cmd():
+ *   - hw/scsi/virtio-scsi-dataplane.c|163| <<virtio_scsi_dataplane_start>> rc = virtio_scsi_vring_init(s, vs->cmd_vqs[i], i + 2, virtio_scsi_data_plane_handle_cmd);
+ */
 static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,
                                               VirtQueue *vq)
 {
@@ -57,6 +65,11 @@ static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,
 
     virtio_scsi_acquire(s);
     assert(s->ctx && s->dataplane_started);
+    /*
+     * called by:
+     *   - hw/scsi/virtio-scsi-dataplane.c|60| <<virtio_scsi_data_plane_handle_cmd>> progress = virtio_scsi_handle_cmd_vq(s, vq);
+     *   - hw/scsi/virtio-scsi.c|667| <<virtio_scsi_handle_cmd>> virtio_scsi_handle_cmd_vq(s, vq);
+     */
     progress = virtio_scsi_handle_cmd_vq(s, vq);
     virtio_scsi_release(s);
     return progress;
@@ -88,6 +101,12 @@ static bool virtio_scsi_data_plane_handle_event(VirtIODevice *vdev,
     return progress;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi-dataplane.c|159| <<virtio_scsi_dataplane_start>> rc = virtio_scsi_vring_init(s, vs->ctrl_vq, 0, virtio_scsi_data_plane_handle_ctrl);
+ *   - hw/scsi/virtio-scsi-dataplane.c|164| <<virtio_scsi_dataplane_start>> rc = virtio_scsi_vring_init(s, vs->event_vq, 1, virtio_scsi_data_plane_handle_event);
+ *   - hw/scsi/virtio-scsi-dataplane.c|170| <<virtio_scsi_dataplane_start>> rc = virtio_scsi_vring_init(s, vs->cmd_vqs[i], i + 2, virtio_scsi_data_plane_handle_cmd);
+ */
 static int virtio_scsi_vring_init(VirtIOSCSI *s, VirtQueue *vq, int n,
                                   VirtIOHandleAIOOutput fn)
 {
@@ -131,6 +150,12 @@ int virtio_scsi_dataplane_start(VirtIODevice *vdev)
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(vdev);
     VirtIOSCSI *s = VIRTIO_SCSI(vdev);
 
+    /*
+     * 在以下设置VirtIOSCSI->dataplane_fenced:
+     *   - hw/scsi/virtio-scsi-dataplane.c|121| <<virtio_scsi_vring_init>> s->dataplane_fenced = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|202| <<virtio_scsi_dataplane_start>> s->dataplane_fenced = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|223| <<virtio_scsi_dataplane_stop>> s->dataplane_fenced = false;
+     */
     if (s->dataplane_started ||
         s->dataplane_starting ||
         s->dataplane_fenced) {
diff --git a/hw/scsi/virtio-scsi.c b/hw/scsi/virtio-scsi.c
index 3db9a8aae..3e83376f0 100644
--- a/hw/scsi/virtio-scsi.c
+++ b/hw/scsi/virtio-scsi.c
@@ -28,6 +28,71 @@
 #include "hw/virtio/virtio-bus.h"
 #include "hw/virtio/virtio-access.h"
 
+/*
+ * 下发IO和完成IO的地方
+ *
+ * qemu-6.0.0
+ *
+ * req->ops->send_command = scsi_block_dma_command() -> scsi_disk_dma_command()
+ *
+ * req->ops->read_data = scsi_read_data()
+ * -> scsi_do_read()
+ *    -> dma_blk_io() # BlockAIOCB->cb = scsi_dma_complete
+ *       -> sdc->dma_readv = scsi_block_dma_readv()
+ *          -> scsi_block_do_sgio()
+ *             -> blk_aio_ioctl(SG_IO) # cb = scsi_block_sgio_complete
+ *
+ * blk_aio_complete()
+ * -> scsi_block_sgio_complete()
+ *    -> scsi_req_complete_failed()
+ *    -> req->cb = dma_blk_cb()
+ *       -> dma_complete()
+ *          -> scsi_dma_complete()
+ *             -> scsi_dma_complete_noio()
+ *                -> scsi_req_complete()
+ *                   -> req->bus->info->complete = virtio_scsi_command_complete()
+ *
+ *
+ * (gdb) bt
+ * #0  0x0000555555a851ee in scsi_dma_complete (opaque=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:353
+ * #1  0x00005555558d9659 in dma_complete (dbs=0x555557094340, ret=0) at ../softmmu/dma-helpers.c:121
+ * #2  0x00005555558d9706 in dma_blk_cb (opaque=0x555557094340, ret=0) at ../softmmu/dma-helpers.c:139
+ * #3  0x0000555555a8b4e4 in scsi_block_sgio_complete (opaque=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:2714
+ * #4  0x0000555555d6ccc9 in blk_aio_complete (acb=0x5555570a5c60) at ../block/block-backend.c:1412
+ * #5  0x0000555555d6d3a7 in blk_aio_ioctl_entry (opaque=0x5555570a5c60) at ../block/block-backend.c:1596
+ * #6  0x0000555555e6f99a in coroutine_trampoline (i0=-536823856, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #7  0x00007ffff5c8c190 in __start_context () at /lib64/libc.so.6
+ * #8  0x00007ff7ef539b10 in  ()
+ * #9  0x0000000000000000 in  ()
+ *
+ * --------------------------
+ *
+ * qemu-5.2.0
+ *
+ * req->ops->send_command = scsi_block_dma_command() -> scsi_disk_dma_command()
+ *
+ * req->ops->read_data = scsi_read_data()
+ * -> scsi_do_read()
+ *    -> dma_blk_io() # BlockAIOCB->cb = scsi_dma_complete
+ *       -> sdc->dma_readv = scsi_block_dma_readv() # cb = scsi_dma_complete()
+ *          -> scsi_block_do_sgio()
+ *             -> blk_aio_ioctl(SG_IO) # cb = scsi_dma_complete()
+ *
+ *
+ * (gdb) bt
+ * #0  0x00005555558199a3 in scsi_req_complete (req=0x555557055000, status=0) at ../hw/scsi/scsi-bus.c:1456
+ * #1  0x0000555555a52f28 in scsi_dma_complete_noio (r=0x555557055000, ret=0) at ../hw/scsi/scsi-disk.c:275
+ * #2  0x0000555555a53035 in scsi_dma_complete (opaque=0x555557055000, ret=0) at ../hw/scsi/scsi-disk.c:296
+ * #3  0x000055555595db55 in dma_complete (dbs=0x555556ef5940, ret=0) at ../softmmu/dma-helpers.c:120
+ * #4  0x000055555595dc02 in dma_blk_cb (opaque=0x555556ef5940, ret=0) at ../softmmu/dma-helpers.c:138
+ * #5  0x0000555555cdf122 in blk_aio_complete (acb=0x55555729ea00) at ../block/block-backend.c:1412
+ * #6  0x0000555555cdf7ea in blk_aio_ioctl_entry (opaque=0x55555729ea00) at ../block/block-backend.c:1596
+ * #7  0x0000555555e327ab in coroutine_trampoline (i0=-469733232, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #8  0x00007ffff5ea2190 in __start_context () at /lib64/libc.so.6
+ * #9  0x00007ff7eed38b10 in  ()
+ * #10 0x0000000000000000 in  ()
+ */
+
 static inline int virtio_scsi_get_lun(uint8_t *lun)
 {
     return ((lun[2] << 8) | lun[3]) & 0x3FFF;
@@ -64,6 +129,13 @@ void virtio_scsi_free_req(VirtIOSCSIReq *req)
     g_free(req);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|242| <<virtio_scsi_cancel_notify>> virtio_scsi_complete_req(n->tmf_req);
+ *   - hw/scsi/virtio-scsi.c|437| <<virtio_scsi_handle_ctrl_req>> virtio_scsi_complete_req(req);
+ *   - hw/scsi/virtio-scsi.c|476| <<virtio_scsi_complete_cmd_req>> virtio_scsi_complete_req(req);
+ *   - hw/scsi/virtio-scsi.c|770| <<virtio_scsi_push_event>> virtio_scsi_complete_req(req);
+ */
 static void virtio_scsi_complete_req(VirtIOSCSIReq *req)
 {
     VirtIOSCSI *s = req->dev;
@@ -467,6 +539,14 @@ static void virtio_scsi_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
     virtio_scsi_release(s);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|510| <<virtio_scsi_command_complete>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|550| <<virtio_scsi_request_cancelled>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|556| <<virtio_scsi_fail_cmd_req>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|580| <<virtio_scsi_handle_cmd_req_prepare>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|592| <<virtio_scsi_handle_cmd_req_prepare>> virtio_scsi_complete_cmd_req(req);
+ */
 static void virtio_scsi_complete_cmd_req(VirtIOSCSIReq *req)
 {
     /* Sense data is not in req->resp and is copied separately
@@ -476,6 +556,25 @@ static void virtio_scsi_complete_cmd_req(VirtIOSCSIReq *req)
     virtio_scsi_complete_req(req);
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555c67c82 in virtio_scsi_command_complete (r=0x5555577c38a0, status=0, resid=0) at ../hw/scsi/virtio-scsi.c:481
+ * #1  0x000055555593577b in scsi_req_complete (req=0x5555577c38a0, status=0) at ../hw/scsi/scsi-bus.c:1482
+ * #2  0x0000555555940f0f in scsi_write_do_fua (r=0x5555577c38a0) at ../hw/scsi/scsi-disk.c:258
+ * #3  0x0000555555940fd9 in scsi_dma_complete_noio (r=0x5555577c38a0, ret=0) at ../hw/scsi/scsi-disk.c:272
+ * #4  0x00005555559410fc in scsi_dma_complete (opaque=0x5555577c38a0, ret=0) at ../hw/scsi/scsi-disk.c:296
+ * #5  0x00005555559743ee in dma_complete (dbs=0x5555574c3c30, ret=0) at ../softmmu/dma-helpers.c:120
+ * #6  0x000055555597449b in dma_blk_cb (opaque=0x5555574c3c30, ret=0) at ../softmmu/dma-helpers.c:138
+ * #7  0x0000555555d53f63 in blk_aio_complete (acb=0x555557252f00) at ../block/block-backend.c:1412
+ * #8  0x0000555555d54240 in blk_aio_write_entry (opaque=0x555557252f00) at ../block/block-backend.c:1478
+ * #9  0x0000555555e3c820 in coroutine_trampoline (i0=1461130352, i1=21845) at ../util/coroutine-ucontext.c:173
+ * #10 0x00007ffff50a2180 in __start_context () at /lib/../lib64/libc.so.6
+ * #11 0x00007fffffffd140 in  ()
+ * #12 0x0000000000000000 in  ()
+ *
+ * 在以下使用virtio_scsi_command_complete():
+ *   - hw/scsi/virtio-scsi.c|893| <<global>> .complete = virtio_scsi_command_complete,
+ */
 static void virtio_scsi_command_complete(SCSIRequest *r, uint32_t status,
                                          size_t resid)
 {
@@ -602,6 +701,46 @@ static void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)
     scsi_req_unref(sreq);
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555c6819c in virtio_scsi_handle_cmd_vq (s=0x555557912ef0, vq=0x55555791a7e0) at ../hw/scsi/virtio-scsi.c:606
+ * #1  0x0000555555c490ca in virtio_scsi_data_plane_handle_cmd (vdev=0x555557912ef0, vq=0x55555791a7e0) at ../hw/scsi/virtio-scsi-dataplane.c:60
+ * #2  0x0000555555c5ddf2 in virtio_queue_notify_aio_vq (vq=0x55555791a7e0) at ../hw/virtio/virtio.c:2326
+ * #3  0x0000555555c60dc0 in virtio_queue_host_notifier_aio_read (n=0x55555791a858) at ../hw/virtio/virtio.c:3530
+ * #4  0x0000555555e80900 in aio_dispatch_handler (ctx=0x555556a9a3a0, node=0x7fff1c0048d0) at ../util/aio-posix.c:329
+ * #5  0x0000555555e80ab9 in aio_dispatch_handlers (ctx=0x555556a9a3a0) at ../util/aio-posix.c:372
+ * #6  0x0000555555e80b0f in aio_dispatch (ctx=0x555556a9a3a0) at ../util/aio-posix.c:382
+ * #7  0x0000555555e5ef83 in aio_ctx_dispatch (source=0x555556a9a3a0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #8  0x00007ffff7447099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #9  0x0000555555e644cb in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #10 0x0000555555e64545 in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:244
+ * #11 0x0000555555e6464d in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #12 0x0000555555ba3630 in qemu_main_loop () at ../softmmu/vl.c:1678
+ * #13 0x0000555555809b32 in main (argc=20, argv=0x7fffffffdff8, envp=0x7fffffffe0a0) at ../softmmu/main.c:50
+ *
+ * (gdb) bt
+ * #0  0x0000555555c6819c in virtio_scsi_handle_cmd_vq (s=0x555557912fe0, vq=0x55555791a918) at ../hw/scsi/virtio-scsi.c:606
+ * #1  0x0000555555c68461 in virtio_scsi_handle_cmd (vdev=0x555557912fe0, vq=0x55555791a918) at ../hw/scsi/virtio-scsi.c:660
+ * #2  0x0000555555c5dfdb in virtio_queue_notify (vdev=0x555557912fe0, n=3) at ../hw/virtio/virtio.c:2366
+ * #3  0x00005555558ea806 in virtio_pci_notify_write (opaque=0x55555790ae50, addr=12, val=3, size=2) at ../hw/virtio/virtio-pci.c:1343
+ * #4  0x0000555555c4d454 in memory_region_write_accessor (mr=0x55555790bb30, addr=12, value=0x7fff3157b6c8, size=2, shift=0, mask=65535, attrs=...) at ../softmmu/memory.c:491
+ * #5  0x0000555555c4d678 in access_with_adjusted_size (addr=12, value=0x7fff3157b6c8, size=2, access_size_min=1, access_size_max=4, access_fn=
+       0x555555c4d36f <memory_region_write_accessor>, mr=0x55555790bb30, attrs=...) at ../softmmu/memory.c:552
+ * #6  0x0000555555c50681 in memory_region_dispatch_write (mr=0x55555790bb30, addr=12, data=3, op=MO_16, attrs=...) at ../softmmu/memory.c:1501
+ * #7  0x0000555555bd91bb in flatview_write_continue (fv=0x7fff2c1583f0, addr=4261425164, attrs=..., ptr=0x7ffff7fdd028, len=2, addr1=12, l=2, mr=0x55555790bb30) at ../softmmu/physmem.c:2759
+ * #8  0x0000555555bd9300 in flatview_write (fv=0x7fff2c1583f0, addr=4261425164, attrs=..., buf=0x7ffff7fdd028, len=2) at ../softmmu/physmem.c:2799
+ * #9  0x0000555555bd966e in address_space_write (as=0x55555681a340 <address_space_memory>, addr=4261425164, attrs=..., buf=0x7ffff7fdd028, len=2) at ../softmmu/physmem.c:2891
+ * #10 0x0000555555bd96db in address_space_rw (as=0x55555681a340 <address_space_memory>, addr=4261425164, attrs=..., buf=0x7ffff7fdd028, len=2, is_write=true) at ../softmmu/physmem.c:2901
+ * #11 0x0000555555c25961 in kvm_cpu_exec (cpu=0x555556b5a640) at ../accel/kvm/kvm-all.c:2541
+ * #12 0x0000555555c801fe in kvm_vcpu_thread_fn (arg=0x555556b5a640) at ../accel/kvm/kvm-cpus.c:49
+ * #13 0x0000555555e40abc in qemu_thread_start (args=0x555556b80e00) at ../util/qemu-thread-posix.c:521
+ * #14 0x00007ffff542fea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #15 0x00007ffff51588cd in clone () at /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/scsi/virtio-scsi-dataplane.c|60| <<virtio_scsi_data_plane_handle_cmd>> progress = virtio_scsi_handle_cmd_vq(s, vq);
+ *   - hw/scsi/virtio-scsi.c|667| <<virtio_scsi_handle_cmd>> virtio_scsi_handle_cmd_vq(s, vq);
+ */
 bool virtio_scsi_handle_cmd_vq(VirtIOSCSI *s, VirtQueue *vq)
 {
     VirtIOSCSIReq *req, *next;
@@ -645,6 +784,14 @@ bool virtio_scsi_handle_cmd_vq(VirtIOSCSI *s, VirtQueue *vq)
     return progress;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|983| <<virtio_scsi_device_realize>> virtio_scsi_common_realize(dev,
+ *                                                                        virtio_scsi_handle_ctrl,
+ *                                                                        virtio_scsi_handle_event,
+ *                                                                        virtio_scsi_handle_cmd,
+ *                                                                        &err);
+ */
 static void virtio_scsi_handle_cmd(VirtIODevice *vdev, VirtQueue *vq)
 {
     /* use non-QOM casts in the data path */
@@ -872,6 +1019,10 @@ static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,
     }
 }
 
+/*
+ * 在以下使用virtio_scsi_scsi_info:
+ *   - hw/scsi/virtio-scsi.c|972| <<virtio_scsi_device_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), dev, &virtio_scsi_scsi_info, vdev->bus_name);
+ */
 static struct SCSIBusInfo virtio_scsi_scsi_info = {
     .tcq = true,
     .max_channel = VIRTIO_SCSI_MAX_CHANNEL,
diff --git a/hw/timer/hpet.c b/hw/timer/hpet.c
index 9520471be..d2c13a0fc 100644
--- a/hw/timer/hpet.c
+++ b/hw/timer/hpet.c
@@ -417,6 +417,24 @@ static void hpet_del_timer(HPETTimer *t)
     update_irq(t, 0);
 }
 
+/*
+ * (gdb) bt
+ * #0  0x000055e035a0f9a5 in hpet_ram_read (opaque=0x55e0388efd20, addr=240, size=4) at ../hw/timer/hpet.c:423
+ * #1  0x000055e035dc519b in memory_region_read_accessor (mr=0x55e0388f0040, addr=240, value=0x7f779957c740, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:442
+ * #2  0x000055e035dc5678 in access_with_adjusted_size (addr=240, value=0x7f779957c740, size=4, access_size_min=1, access_size_max=4, access_fn=
+ *                        0x55e035dc515d <memory_region_read_accessor>, mr=0x55e0388f0040, attrs=...) at ../softmmu/memory.c:552
+ * #3  0x000055e035dc82c7 in memory_region_dispatch_read1 (mr=0x55e0388f0040, addr=240, pval=0x7f779957c740, size=4, attrs=...) at ../softmmu/memory.c:1420
+ * #4  0x000055e035dc83b4 in memory_region_dispatch_read (mr=0x55e0388f0040, addr=240, pval=0x7f779957c740, op=MO_32, attrs=...) at ../softmmu/memory.c:1449
+ * #5  0x000055e035d513e2 in flatview_read_continue (fv=0x7f778c000d30, addr=4275044592, attrs=..., ptr=0x7f785f6f9028, len=4, addr1=240, l=4, mr=0x55e0388f0040) at ../softmmu/physmem.c:2822
+ * #6  0x000055e035d5154e in flatview_read (fv=0x7f778c000d30, addr=4275044592, attrs=..., buf=0x7f785f6f9028, len=4) at ../softmmu/physmem.c:2862
+ * #7  0x000055e035d515d7 in address_space_read_full (as=0x55e036992340 <address_space_memory>, addr=4275044592, attrs=..., buf=0x7f785f6f9028, len=4) at ../softmmu/physmem.c:2875
+ * #8  0x000055e035d516fb in address_space_rw (as=0x55e036992340 <address_space_memory>, addr=4275044592, attrs=..., buf=0x7f785f6f9028, len=4, is_write=false) at ../softmmu/physmem.c:2903
+ * #9  0x000055e035d9d961 in kvm_cpu_exec (cpu=0x55e0380ed7b0) at ../accel/kvm/kvm-all.c:2541
+ * #10 0x000055e035df81fe in kvm_vcpu_thread_fn (arg=0x55e0380ed7b0) at ../accel/kvm/kvm-cpus.c:49
+ * #11 0x000055e035fb8abc in qemu_thread_start (args=0x55e038114290) at ../util/qemu-thread-posix.c:521
+ * #12 0x00007f785cb43ea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #13 0x00007f785c86c8cd in clone () at /lib/../lib64/libc.so.6
+ */
 static uint64_t hpet_ram_read(void *opaque, hwaddr addr,
                               unsigned size)
 {
diff --git a/hw/vfio/common.c b/hw/vfio/common.c
index 6ff1daa76..b3baa989d 100644
--- a/hw/vfio/common.c
+++ b/hw/vfio/common.c
@@ -40,8 +40,30 @@
 #include "qapi/error.h"
 #include "migration/migration.h"
 
+/*
+ * 在以下使用vfio_group_list:
+ *   - hw/vfio/common.c|44| <<global>> QLIST_HEAD_INITIALIZER(vfio_group_list);
+ *   - hw/vfio/common.c|309| <<vfio_mig_active>> if (QLIST_EMPTY(&vfio_group_list)) {
+ *   - hw/vfio/common.c|313| <<vfio_mig_active>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|1520| <<vfio_reset_handler>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|1528| <<vfio_reset_handler>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|2009| <<vfio_get_group>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|2053| <<vfio_get_group>> if (QLIST_EMPTY(&vfio_group_list)) {
+ *   - hw/vfio/common.c|2057| <<vfio_get_group>> QLIST_INSERT_HEAD(&vfio_group_list, group, next);
+ *   - hw/vfio/common.c|2086| <<vfio_put_group>> if (QLIST_EMPTY(&vfio_group_list)) {
+ *   - hw/vfio/pci.c|2249| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/pci.c|2292| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/pci.c|2306| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/pci.c|2338| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ */
 VFIOGroupList vfio_group_list =
     QLIST_HEAD_INITIALIZER(vfio_group_list);
+/*
+ * 在以下使用vfio_address_spaces:
+ *   - hw/vfio/common.c|46| <<QLIST_HEAD>> QLIST_HEAD_INITIALIZER(vfio_address_spaces);
+ *   - hw/vfio/common.c|1594| <<vfio_get_address_space>> QLIST_FOREACH(space, &vfio_address_spaces, list) {
+ *   - hw/vfio/common.c|1605| <<vfio_get_address_space>> QLIST_INSERT_HEAD(&vfio_address_spaces, space, list);
+ */
 static QLIST_HEAD(, VFIOAddressSpace) vfio_address_spaces =
     QLIST_HEAD_INITIALIZER(vfio_address_spaces);
 
@@ -53,12 +75,28 @@ static QLIST_HEAD(, VFIOAddressSpace) vfio_address_spaces =
  * initialized, this file descriptor is only released on QEMU exit and
  * we'll re-use it should another vfio device be attached before then.
  */
+/*
+ * 在以下使用vfio_kvm_device_fd:
+ *   - hw/vfio/common.c|746| <<vfio_listener_region_add>> if (ioctl(vfio_kvm_device_fd, KVM_SET_DEVICE_ATTR, &attr)) {
+ *   - hw/vfio/common.c|1490| <<vfio_kvm_device_add_group>> if (vfio_kvm_device_fd < 0) {
+ *   - hw/vfio/common.c|1500| <<vfio_kvm_device_add_group>> vfio_kvm_device_fd = cd.fd;
+ *   - hw/vfio/common.c|1503| <<vfio_kvm_device_add_group>> if (ioctl(vfio_kvm_device_fd, KVM_SET_DEVICE_ATTR, &attr)) {
+ *   - hw/vfio/common.c|1519| <<vfio_kvm_device_del_group>> if (vfio_kvm_device_fd < 0) {
+ *   - hw/vfio/common.c|1523| <<vfio_kvm_device_del_group>> if (ioctl(vfio_kvm_device_fd, KVM_SET_DEVICE_ATTR, &attr)) {
+ */
 static int vfio_kvm_device_fd = -1;
 #endif
 
 /*
  * Common VFIO interrupt disable
  */
+/*
+ * called by:
+ *   - hw/vfio/pci.c|354| <<vfio_intx_disable>> vfio_disable_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);
+ *   - hw/vfio/pci.c|561| <<vfio_msix_vector_do_use>> vfio_disable_irqindex(&vdev->vbasedev, VFIO_PCI_MSIX_IRQ_INDEX);
+ *   - hw/vfio/pci.c|791| <<vfio_msix_disable>> vfio_disable_irqindex(&vdev->vbasedev, VFIO_PCI_MSIX_IRQ_INDEX);
+ *   - hw/vfio/pci.c|804| <<vfio_msi_disable>> vfio_disable_irqindex(&vdev->vbasedev, VFIO_PCI_MSI_IRQ_INDEX);
+ */
 void vfio_disable_irqindex(VFIODevice *vbasedev, int index)
 {
     struct vfio_irq_set irq_set = {
@@ -69,9 +107,19 @@ void vfio_disable_irqindex(VFIODevice *vbasedev, int index)
         .count = 0,
     };
 
+    /*
+     * 重点应该是count=0
+     */
     ioctl(vbasedev->fd, VFIO_DEVICE_SET_IRQS, &irq_set);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|148| <<vfio_intx_eoi>> vfio_unmask_single_irqindex(vbasedev, VFIO_PCI_INTX_IRQ_INDEX);
+ *   - hw/vfio/pci.c|190| <<vfio_intx_enable_kvm>> vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);
+ *   - hw/vfio/pci.c|205| <<vfio_intx_enable_kvm>> vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);
+ *   - hw/vfio/pci.c|240| <<vfio_intx_disable_kvm>> vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);
+ */
 void vfio_unmask_single_irqindex(VFIODevice *vbasedev, int index)
 {
     struct vfio_irq_set irq_set = {
@@ -85,6 +133,11 @@ void vfio_unmask_single_irqindex(VFIODevice *vbasedev, int index)
     ioctl(vbasedev->fd, VFIO_DEVICE_SET_IRQS, &irq_set);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|164| <<vfio_intx_enable_kvm>> vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);
+ *   - hw/vfio/pci.c|220| <<vfio_intx_disable_kvm>> vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);
+ */
 void vfio_mask_single_irqindex(VFIODevice *vbasedev, int index)
 {
     struct vfio_irq_set irq_set = {
@@ -134,6 +187,21 @@ static const char *index_to_str(VFIODevice *vbasedev, int index)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/ccw.c|420| <<vfio_ccw_register_irq_notifier>> if (vfio_set_irq_signaling(vdev, irq, 0,
+ *   - hw/vfio/ccw.c|448| <<vfio_ccw_unregister_irq_notifier>> if (vfio_set_irq_signaling(&vcdev->vdev, irq, 0,
+ *   - hw/vfio/pci.c|182| <<vfio_intx_enable_kvm>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0,
+ *   - hw/vfio/pci.c|330| <<vfio_intx_enable>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0,
+ *   - hw/vfio/pci.c|577| <<vfio_msix_vector_do_use>> if (vfio_set_irq_signaling(&vdev->vbasedev,
+ *   - hw/vfio/pci.c|620| <<vfio_msix_vector_release>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_MSIX_IRQ_INDEX, nr,
+ *   - hw/vfio/pci.c|2817| <<vfio_register_err_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_ERR_IRQ_INDEX, 0,
+ *   - hw/vfio/pci.c|2834| <<vfio_unregister_err_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_ERR_IRQ_INDEX, 0,
+ *   - hw/vfio/pci.c|2882| <<vfio_register_req_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_REQ_IRQ_INDEX, 0,
+ *   - hw/vfio/pci.c|2900| <<vfio_unregister_req_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_REQ_IRQ_INDEX, 0,
+ *   - hw/vfio/platform.c|120| <<vfio_set_trigger_eventfd>> ret = vfio_set_irq_signaling(vbasedev, intp->pin, 0,
+ *   - hw/vfio/platform.c|359| <<vfio_set_resample_eventfd>> ret = vfio_set_irq_signaling(vbasedev, intp->pin, 0,
+ */
 int vfio_set_irq_signaling(VFIODevice *vbasedev, int index, int subindex,
                            int action, int fd, Error **errp)
 {
@@ -146,6 +214,14 @@ int vfio_set_irq_signaling(VFIODevice *vbasedev, int index, int subindex,
 
     irq_set = g_malloc0(argsz);
     irq_set->argsz = argsz;
+    /*
+     * DATA_EVENTFD binds the specified ACTION to the provided __s32 eventfd.
+     * A value of -1 can be used to either de-assign interrupts if already
+     * assigned or skip un-assigned interrupts.  For example, to set an eventfd
+     * to be trigger for interrupts [0,0] and [0,2]:
+     * flags = (DATA_EVENTFD|ACTION_TRIGGER), index = 0, start = 0, count = 3,
+     * data = {fd1, -1, fd2}
+     */
     irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | action;
     irq_set->index = index;
     irq_set->start = subindex;
@@ -242,6 +318,10 @@ uint64_t vfio_region_read(void *opaque,
     } buf;
     uint64_t data = 0;
 
+    /*
+     * 在以下设置VFIORegion->fd_offset:
+     *   - hw/vfio/common.c|1479| <<vfio_region_setup>> region->fd_offset = info->offset;
+     */
     if (pread(vbasedev->fd, &buf, size, region->fd_offset + addr) != size) {
         error_report("%s(%s:region%d+0x%"HWADDR_PRIx", %d) failed: %m",
                      __func__, vbasedev->name, region->nr,
@@ -274,6 +354,10 @@ uint64_t vfio_region_read(void *opaque,
     return data;
 }
 
+/*
+ * 在以下使用vfio_region_ops:
+ *   - hw/vfio/common.c|1366| <<vfio_region_setup>> memory_region_init_io(region->mem, obj, &vfio_region_ops,
+ */
 const MemoryRegionOps vfio_region_ops = {
     .read = vfio_region_read,
     .write = vfio_region_write,
@@ -292,6 +376,10 @@ const MemoryRegionOps vfio_region_ops = {
  * Device state interfaces
  */
 
+/*
+ * called by:
+ *   - migration/migration.c|1047| <<populate_vfio_info>> if (vfio_mig_active()) {
+ */
 bool vfio_mig_active(void)
 {
     VFIOGroup *group;
@@ -372,6 +460,10 @@ static bool vfio_devices_all_running_and_saving(VFIOContainer *container)
     return true;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|476| <<vfio_dma_unmap>> return vfio_dma_unmap_bitmap(container, iova, size, iotlb);
+ */
 static int vfio_dma_unmap_bitmap(VFIOContainer *container,
                                  hwaddr iova, ram_addr_t size,
                                  IOMMUTLBEntry *iotlb)
@@ -386,6 +478,22 @@ static int vfio_dma_unmap_bitmap(VFIOContainer *container,
     unmap->argsz = sizeof(*unmap) + sizeof(*bitmap);
     unmap->iova = iova;
     unmap->size = size;
+    /*
+     * Unmap IO virtual addresses using the provided struct vfio_dma_unmap.
+     * Caller sets argsz.  The actual unmapped size is returned in the size
+     * field.  No guarantee is made to the user that arbitrary unmaps of iova
+     * or size different from those used in the original mapping call will
+     * succeed.
+     * VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP should be set to get the dirty bitmap
+     * before unmapping IO virtual addresses. When this flag is set, the user must
+     * provide a struct vfio_bitmap in data[]. User must provide zero-allocated
+     * memory via vfio_bitmap.data and its size in the vfio_bitmap.size field.
+     * A bit in the bitmap represents one page, of user provided page size in
+     * vfio_bitmap.pgsize field, consecutively starting from iova offset. Bit set
+     * indicates that the page at that offset from iova is dirty. A Bitmap of the
+     * pages in the range of unmapped size is returned in the user-provided
+     * vfio_bitmap.data.
+     */
     unmap->flags |= VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP;
     bitmap = (struct vfio_bitmap *)&unmap->data;
 
@@ -429,6 +537,13 @@ unmap_exit:
 /*
  * DMA - Mapping and unmapping for the "type1" IOMMU interface used on x86
  */
+/*
+ * called by:
+ *   - hw/vfio/common.c|582| <<vfio_dma_map>> (errno == EBUSY && vfio_dma_unmap(container, iova, size, NULL) == 0 &&
+ *   - hw/vfio/common.c|736| <<vfio_iommu_map_notify>> ret = vfio_dma_unmap(container, iova, iotlb->addr_mask + 1, iotlb);
+ *   - hw/vfio/common.c|1050| <<vfio_listener_region_del>> ret = vfio_dma_unmap(container, iova, int128_get64(llsize), NULL);
+ *   - hw/vfio/common.c|1058| <<vfio_listener_region_del>> ret = vfio_dma_unmap(container, iova, int128_get64(llsize), NULL);
+ */
 static int vfio_dma_unmap(VFIOContainer *container,
                           hwaddr iova, ram_addr_t size,
                           IOMMUTLBEntry *iotlb)
@@ -471,9 +586,90 @@ static int vfio_dma_unmap(VFIOContainer *container,
     return 0;
 }
 
+/*
+ * 初始化RAM的地方.
+ * (gdb) bt
+ * #0  0x0000555555bd0caa in vfio_dma_map (container=0x555558783310, iova=4294967296, size=7516192768, vaddr=0x7ffe2d800000, readonly=false) at ../hw/vfio/common.c:476
+ * #1  0x0000555555bd1dc5 in vfio_listener_region_add (listener=0x555558783320, section=0x7fffffffc6e0) at ../hw/vfio/common.c:840
+ * #2  0x0000555555bf30e8 in listener_add_address_space (listener=0x555558783320, as=0x5555568345c0 <address_space_memory>) at ../softmmu/memory.c:2720
+ * #3  0x0000555555bf3502 in memory_listener_register (listener=0x555558783320, as=0x5555568345c0 <address_space_memory>) at ../softmmu/memory.c:2787
+ * #4  0x0000555555bd4996 in vfio_connect_container (group=0x555558783290, as=0x5555568345c0 <address_space_memory>, errp=0x7fffffffd9c8) at ../hw/vfio/common.c:1855
+ * #5  0x0000555555bd4f80 in vfio_get_group (groupid=106, as=0x5555568345c0 <address_space_memory>, errp=0x7fffffffd9c8) at ../hw/vfio/common.c:1972
+ * #6  0x0000555555b8488f in vfio_realize (pdev=0x55555877cc70, errp=0x7fffffffd9c8) at ../hw/vfio/pci.c:2819
+ * #7  0x00005555559aa7fe in pci_qdev_realize (qdev=0x55555877cc70, errp=0x7fffffffda40) at ../hw/pci/pci.c:2123
+ * #8  0x0000555555d9d03c in device_set_realized (obj=0x55555877cc70, value=true, errp=0x7fffffffdb48) at ../hw/core/qdev.c:886
+ * #9  0x0000555555d7dac2 in property_set_bool (obj=0x55555877cc70, v=0x55555877dc20, name=0x555555ff4439 "realized", opaque=0x5555568c3e60, errp=0x7fffffffdb48) at ../qom/object.c:2251
+ * #10 0x0000555555d7bbe4 in object_property_set (obj=0x55555877cc70, name=0x555555ff4439 "realized", v=0x55555877dc20, errp=0x555556839db8 <error_fatal>) at ../qom/object.c:1398
+ * #11 0x0000555555d786df in object_property_set_qobject (obj=0x55555877cc70, name=0x555555ff4439 "realized", value=0x55555877db60, errp=0x555556839db8 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #12 0x0000555555d7bf29 in object_property_set_bool (obj=0x55555877cc70, name=0x555555ff4439 "realized", value=true, errp=0x555556839db8 <error_fatal>) at ../qom/object.c:1465
+ * #13 0x0000555555d9bc5b in qdev_realize (dev=0x55555877cc70, bus=0x555557b352d0, errp=0x555556839db8 <error_fatal>) at ../hw/core/qdev.c:399
+ * #14 0x0000555555847942 in qdev_device_add (opts=0x5555568c22d0, errp=0x555556839db8 <error_fatal>) at ../softmmu/qdev-monitor.c:676
+ * #15 0x0000555555c18078 in device_init_func (opaque=0x0, opts=0x5555568c22d0, errp=0x555556839db8 <error_fatal>) at ../softmmu/vl.c:2104
+ * #16 0x0000555555e504e6 in qemu_opts_foreach (list=0x555556720f20 <qemu_device_opts>, func=0x555555c18051 <device_init_func>, opaque=0x0, errp=0x555556839db8 <error_fatal>) at ../util/qemu-option.c:1156
+ * #17 0x0000555555c1d5eb in qemu_init (argc=16, argv=0x7fffffffe078, envp=0x7fffffffe100) at ../softmmu/vl.c:4398
+ * #18 0x0000555555809b2d in main (argc=16, argv=0x7fffffffe078, envp=0x7fffffffe100) at ../softmmu/main.c:49
+ *
+ * (gdb) bt
+ * #0  0x0000555555bbdd6a in vfio_dma_map (container=0x55555798cfe0, iova=1048576, size=3144679424, vaddr=0x7fff32100000, readonly=false) at ../hw/vfio/common.c:476
+ * #1  0x0000555555bbee65 in vfio_listener_region_add (listener=0x55555798cff0, section=0x7fffffffc720) at ../hw/vfio/common.c:838
+ * #2  0x0000555555c53adb in listener_add_address_space (listener=0x55555798cff0, as=0x55555681a340 <address_space_memory>) at ../softmmu/memory.c:2720
+ * #3  0x0000555555c53ef5 in memory_listener_register (listener=0x55555798cff0, as=0x55555681a340 <address_space_memory>) at ../softmmu/memory.c:2787
+ * #4  0x0000555555bc1a36 in vfio_connect_container (group=0x55555798cf60, as=0x55555681a340 <address_space_memory>, errp=0x7fffffffda08) at ../hw/vfio/common.c:1853
+ * #5  0x0000555555bc2020 in vfio_get_group (groupid=85, as=0x55555681a340 <address_space_memory>, errp=0x7fffffffda08) at ../hw/vfio/common.c:1970
+ * #6  0x0000555555b8db34 in vfio_realize (pdev=0x555557986940, errp=0x7fffffffda08) at ../hw/vfio/pci.c:2819
+ * #7  0x00005555559004df in pci_qdev_realize (qdev=0x555557986940, errp=0x7fffffffda80) at ../hw/pci/pci.c:2123
+ * #8  0x0000555555da15dd in device_set_realized (obj=0x555557986940, value=true, errp=0x7fffffffdb88) at ../hw/core/qdev.c:886
+ * #9  0x0000555555d7cb09 in property_set_bool (obj=0x555557986940, v=0x5555579878f0, name=0x555555ff4311 "realized", opaque=0x5555568c5230, errp=0x7fffffffdb88) at ../qom/object.c:2251
+ * #10 0x0000555555d7ac2b in object_property_set (obj=0x555557986940, name=0x555555ff4311 "realized", v=0x5555579878f0, errp=0x555556837f40 <error_fatal>) at ../qom/object.c:1398
+ * #11 0x0000555555d7de1b in object_property_set_qobject (obj=0x555557986940, name=0x555555ff4311 "realized", value=0x555557987830, errp=0x555556837f40 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #12 0x0000555555d7af70 in object_property_set_bool (obj=0x555557986940, name=0x555555ff4311 "realized", value=true, errp=0x555556837f40 <error_fatal>) at ../qom/object.c:1465
+ * #13 0x0000555555da01fc in qdev_realize (dev=0x555557986940, bus=0x555556d49d80, errp=0x555556837f40 <error_fatal>) at ../hw/core/qdev.c:399
+ * #14 0x0000555555a0c402 in qdev_device_add (opts=0x5555568c02b0, errp=0x555556837f40 <error_fatal>) at ../softmmu/qdev-monitor.c:676
+ * #15 0x0000555555ba5db6 in device_init_func (opaque=0x0, opts=0x5555568c02b0, errp=0x555556837f40 <error_fatal>) at ../softmmu/vl.c:2104
+ * #16 0x0000555555e6d9a0 in qemu_opts_foreach (list=0x555556755d20 <qemu_device_opts>, func=0x555555ba5d8f <device_init_func>, opaque=0x0, errp=0x555556837f40 <error_fatal>) at ../util/qemu-option.c:1156
+ * #17 0x0000555555bab329 in qemu_init (argc=16, argv=0x7fffffffe0b8, envp=0x7fffffffe140) at ../softmmu/vl.c:4398
+ * #18 0x0000555555809b2d in main (argc=16, argv=0x7fffffffe0b8, envp=0x7fffffffe140) at ../softmmu/main.c:49
+ *
+ * (gdb) bt
+ * #0  0x0000555555bbdd6a in vfio_dma_map (container=0x55555798cfe0, iova=4269805568, size=28672, vaddr=0x7fffed83b000, readonly=false) at ../hw/vfio/common.c:476
+ * #1  0x0000555555bbee65 in vfio_listener_region_add (listener=0x55555798cff0, section=0x7fff317fd1f0) at ../hw/vfio/common.c:838
+ * #2  0x0000555555c4f2db in address_space_update_topology_pass (as=0x55555681a340 <address_space_memory>, old_view=0x7fff245c7310, new_view=0x7fff245f5f60, adding=true) at ../softmmu/memory.c:971
+ * #3  0x0000555555c4f5d5 in address_space_set_flatview (as=0x55555681a340 <address_space_memory>) at ../softmmu/memory.c:1047
+ * #4  0x0000555555c4f77c in memory_region_transaction_commit () at ../softmmu/memory.c:1099
+ * #5  0x0000555555c52d72 in memory_region_update_container_subregions (subregion=0x5555579e92d0) at ../softmmu/memory.c:2428
+ * #6  0x0000555555c52dd9 in memory_region_add_subregion_common (mr=0x555556c4afe0, offset=4269801472, subregion=0x5555579e92d0) at ../softmmu/memory.c:2438
+ * #7  0x0000555555c52e53 in memory_region_add_subregion_overlap (mr=0x555556c4afe0, offset=4269801472, subregion=0x5555579e92d0, priority=1) at ../softmmu/memory.c:2455
+ * #8  0x00005555558fea23 in pci_update_mappings (d=0x555557986940) at ../hw/pci/pci.c:1361
+ * #9  0x00005555558fede4 in pci_default_write_config (d=0x555557986940, addr=4, val_in=326, l=2) at ../hw/pci/pci.c:1421
+ * #10 0x0000555555b898ef in vfio_pci_write_config (pdev=0x555557986940, addr=4, val=326, len=2) at ../hw/vfio/pci.c:1185
+ * #11 0x00005555558dca39 in pci_host_config_write_common (pci_dev=0x555557986940, addr=4, limit=256, val=326, len=2) at ../hw/pci/pci_host.c:83
+ * #12 0x00005555558dcb9d in pci_data_write (s=0x555556d49d80, addr=2147491844, val=326, len=2) at ../hw/pci/pci_host.c:120
+ * #13 0x00005555558dccc3 in pci_host_data_write (opaque=0x555556d48d10, addr=0, val=326, len=2) at ../hw/pci/pci_host.c:167
+ * #14 0x0000555555c4d454 in memory_region_write_accessor (mr=0x555556d49120, addr=0, value=0x7fff317fd688, size=2, shift=0, mask=65535, attrs=...) at ../softmmu/memory.c:491
+ * #15 0x0000555555c4d678 in access_with_adjusted_size (addr=0, value=0x7fff317fd688, size=2, access_size_min=1, access_size_max=4, access_fn=
+ *     0x555555c4d36f <memory_region_write_accessor>, mr=0x555556d49120, attrs=...) at ../softmmu/memory.c:552
+ * #16 0x0000555555c50681 in memory_region_dispatch_write (mr=0x555556d49120, addr=0, data=326, op=MO_16, attrs=...) at ../softmmu/memory.c:1501
+ * #17 0x0000555555bd91bb in flatview_write_continue (fv=0x7fff24595d10, addr=3324, attrs=..., ptr=0x7ffff7fdf000, len=2, addr1=0, l=2, mr=0x555556d49120) at ../softmmu/physmem.c:2759
+ * #18 0x0000555555bd9300 in flatview_write (fv=0x7fff24595d10, addr=3324, attrs=..., buf=0x7ffff7fdf000, len=2) at ../softmmu/physmem.c:2799
+ * #19 0x0000555555bd966e in address_space_write (as=0x55555681a2e0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7fdf000, len=2) at ../softmmu/physmem.c:2891
+ * #20 0x0000555555bd96db in address_space_rw (as=0x55555681a2e0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7fdf000, len=2, is_write=true) at ../softmmu/physmem.c:2901
+ * #21 0x0000555555c2515a in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7fdf000, direction=1, size=2, count=1) at ../accel/kvm/kvm-all.c:2285
+ * #22 0x0000555555c25911 in kvm_cpu_exec (cpu=0x555556b3ba10) at ../accel/kvm/kvm-all.c:2531
+ * #23 0x0000555555c801fe in kvm_vcpu_thread_fn (arg=0x555556b3ba10) at ../accel/kvm/kvm-cpus.c:49
+ * #24 0x0000555555e40abc in qemu_thread_start (args=0x555556b621d0) at ../util/qemu-thread-posix.c:521
+ * #25 0x00007ffff542fea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #26 0x00007ffff51588cd in clone () at /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/vfio/common.c|635| <<vfio_iommu_map_notify>> ret = vfio_dma_map(container, iova,
+ *   - hw/vfio/common.c|838| <<vfio_listener_region_add>> ret = vfio_dma_map(container, iova, int128_get64(llsize),
+ */
 static int vfio_dma_map(VFIOContainer *container, hwaddr iova,
                         ram_addr_t size, void *vaddr, bool readonly)
 {
+    /*
+     * size是bytes
+     */
     struct vfio_iommu_type1_dma_map map = {
         .argsz = sizeof(map),
         .flags = VFIO_DMA_MAP_FLAG_READ,
@@ -501,6 +697,12 @@ static int vfio_dma_map(VFIOContainer *container, hwaddr iova,
     return -errno;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|810| <<vfio_listener_region_add>> vfio_host_win_add(container, section->offset_within_address_space,
+ *   - hw/vfio/common.c|1882| <<vfio_connect_container>> vfio_host_win_add(container, 0, (hwaddr)-1, info->iova_pgsizes);
+ *   - hw/vfio/common.c|1952| <<vfio_connect_container>> vfio_host_win_add(container, info.dma32_window_start,
+ */
 static void vfio_host_win_add(VFIOContainer *container,
                               hwaddr min_iova, hwaddr max_iova,
                               uint64_t iova_pgsizes)
@@ -553,6 +755,11 @@ static bool vfio_listener_skipped_section(MemoryRegionSection *section)
 }
 
 /* Called with rcu_read_lock held.  */
+/*
+ * called by:
+ *   - hw/vfio/common.c|716| <<vfio_iommu_map_notify>> if (!vfio_get_xlat_addr(iotlb, &vaddr, NULL, &read_only)) {
+ *   - hw/vfio/common.c|1156| <<vfio_iommu_map_dirty_notify>> if (vfio_get_xlat_addr(iotlb, NULL, &translated_addr, NULL)) {
+ */
 static bool vfio_get_xlat_addr(IOMMUTLBEntry *iotlb, void **vaddr,
                                ram_addr_t *ram_addr, bool *read_only)
 {
@@ -600,6 +807,10 @@ static bool vfio_get_xlat_addr(IOMMUTLBEntry *iotlb, void **vaddr,
     return true;
 }
 
+/*
+ * 在以下使用vfio_iommu_map_notify():
+ *   - hw/vfio/common.c|789| <<vfio_listener_region_add>> iommu_notifier_init(&giommu->n, vfio_iommu_map_notify,
+ */
 static void vfio_iommu_map_notify(IOMMUNotifier *n, IOMMUTLBEntry *iotlb)
 {
     VFIOGuestIOMMU *giommu = container_of(n, VFIOGuestIOMMU, n);
@@ -987,6 +1198,11 @@ static void vfio_listener_region_del(MemoryListener *listener,
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1288| <<vfio_iommu_map_dirty_notify>> ret = vfio_get_dirty_bitmap(container, iova, iotlb->addr_mask + 1,
+ *   - hw/vfio/common.c|1336| <<vfio_sync_dirty_bitmap>> return vfio_get_dirty_bitmap(container,
+ */
 static int vfio_get_dirty_bitmap(VFIOContainer *container, uint64_t iova,
                                  uint64_t size, ram_addr_t ram_addr)
 {
@@ -1044,6 +1260,15 @@ typedef struct {
     VFIOGuestIOMMU *giommu;
 } vfio_giommu_dirty_notifier;
 
+/*
+ * 只在vfio_sync_dirty_bitmap()使用:
+ * 1217                 iommu_notifier_init(&gdn.n,
+ * 1218                                     vfio_iommu_map_dirty_notify,
+ * 1219                                     IOMMU_NOTIFIER_MAP,
+ * 1220                                     section->offset_within_region,
+ * 1221                                     int128_get64(llend),
+ * 1222                                     idx);
+ */
 static void vfio_iommu_map_dirty_notify(IOMMUNotifier *n, IOMMUTLBEntry *iotlb)
 {
     vfio_giommu_dirty_notifier *gdn = container_of(n,
@@ -1133,12 +1358,21 @@ static void vfio_listerner_log_sync(MemoryListener *listener,
     }
 }
 
+/*
+ * 在以下使用vfio_memory_listener:
+ *   - hw/vfio/common.c|1851| <<vfio_connect_container>> container->listener = vfio_memory_listener;
+ */
 static const MemoryListener vfio_memory_listener = {
     .region_add = vfio_listener_region_add,
     .region_del = vfio_listener_region_del,
     .log_sync = vfio_listerner_log_sync,
 };
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|2012| <<vfio_connect_container>> vfio_listener_release(container);
+ *   - hw/vfio/common.c|2040| <<vfio_disconnect_container>> vfio_listener_release(container);
+ */
 static void vfio_listener_release(VFIOContainer *container)
 {
     memory_listener_unregister(&container->listener);
@@ -1191,6 +1425,10 @@ vfio_get_device_info_cap(struct vfio_device_info *info, uint16_t id)
     return vfio_get_cap((void *)info, info->cap_offset, id);
 }
 
+/*
+ * called only by:
+ *   - hw/s390x/s390-pci-vfio.c|58| <<s390_pci_update_dma_avail>> return vfio_get_info_dma_avail(info, avail);
+ */
 bool vfio_get_info_dma_avail(struct vfio_iommu_type1_info *info,
                              unsigned int *avail)
 {
@@ -1212,6 +1450,10 @@ bool vfio_get_info_dma_avail(struct vfio_iommu_type1_info *info,
     return true;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1416| <<vfio_region_setup>> ret = vfio_setup_region_sparse_mmaps(region, info);
+ */
 static int vfio_setup_region_sparse_mmaps(VFIORegion *region,
                                           struct vfio_region_info *info)
 {
@@ -1219,6 +1461,15 @@ static int vfio_setup_region_sparse_mmaps(VFIORegion *region,
     struct vfio_region_info_cap_sparse_mmap *sparse;
     int i, j;
 
+    /*
+     * The sparse mmap capability allows finer granularity of specifying areas
+     * within a region with mmap support.  When specified, the user should only
+     * mmap the offset ranges specified by the areas array.  mmaps outside of the
+     * areas specified may fail (such as the range covering a PCI MSI-X table) or
+     * may result in improper device behavior.
+     *
+     * The structures below define version 1 of this capability.
+     */
     hdr = vfio_get_region_info_cap(info, VFIO_REGION_INFO_CAP_SPARSE_MMAP);
     if (!hdr) {
         return -ENODEV;
@@ -1249,6 +1500,13 @@ static int vfio_setup_region_sparse_mmaps(VFIORegion *region,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/display.c|435| <<vfio_display_region_update>> ret = vfio_region_setup(OBJECT(vdev), &vdev->vbasedev,
+ *   - hw/vfio/migration.c|831| <<vfio_migration_init>> ret = vfio_region_setup(obj, vbasedev, &vbasedev->migration->region,
+ *   - hw/vfio/pci.c|2704| <<vfio_populate_device>> ret = vfio_region_setup(OBJECT(vdev), vbasedev,
+ *   - hw/vfio/platform.c|462| <<vfio_populate_device>> ret = vfio_region_setup(OBJECT(vdev), vbasedev,
+ */
 int vfio_region_setup(Object *obj, VFIODevice *vbasedev, VFIORegion *region,
                       int index, const char *name)
 {
@@ -1304,6 +1562,14 @@ static void vfio_subregion_unmap(VFIORegion *region, int index)
     region->mmaps[index].mmap = NULL;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/display.c|444| <<vfio_display_region_update>> ret = vfio_region_mmap(&dpy->region.buffer);
+ *   - hw/vfio/migration.c|456| <<vfio_save_setup>> ret = vfio_region_mmap(&migration->region);
+ *   - hw/vfio/migration.c|630| <<vfio_load_setup>> ret = vfio_region_mmap(&migration->region);
+ *   - hw/vfio/pci.c|1649| <<vfio_bar_register>> if (vfio_region_mmap(&bar->region)) {
+ *   - hw/vfio/platform.c|659| <<vfio_platform_realize>> if (vfio_region_mmap(vdev->regions[i])) {
+ */
 int vfio_region_mmap(VFIORegion *region)
 {
     int i, prot = 0;
@@ -1316,6 +1582,14 @@ int vfio_region_mmap(VFIORegion *region)
     prot |= region->flags & VFIO_REGION_INFO_FLAG_READ ? PROT_READ : 0;
     prot |= region->flags & VFIO_REGION_INFO_FLAG_WRITE ? PROT_WRITE : 0;
 
+    /*
+     * 在以下修改VFIORegion:
+     *   - hw/vfio/common.c|1389| <<vfio_setup_region_sparse_mmaps>> region->nr_mmaps = j;
+     *   - hw/vfio/common.c|1423| <<vfio_region_setup>> region->nr_mmaps = 1;
+     *   - hw/vfio/common.c|1569| <<vfio_region_finalize>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1300| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1322| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 2;
+     */
     for (i = 0; i < region->nr_mmaps; i++) {
         region->mmaps[i].mmap = mmap(NULL, region->mmaps[i].size, prot,
                                      MAP_SHARED, region->vbasedev->fd,
@@ -1374,6 +1648,14 @@ void vfio_region_unmap(VFIORegion *region)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/display.c|420| <<vfio_display_region_update>> vfio_region_exit(&dpy->region.buffer);
+ *   - hw/vfio/display.c|468| <<vfio_display_region_update>> vfio_region_exit(&dpy->region.buffer);
+ *   - hw/vfio/display.c|494| <<vfio_display_region_exit>> vfio_region_exit(&dpy->region.buffer);
+ *   - hw/vfio/migration.c|805| <<vfio_migration_exit>> vfio_region_exit(&migration->region);
+ *   - hw/vfio/pci.c|1791| <<vfio_bars_exit>> vfio_region_exit(&bar->region);
+ */
 void vfio_region_exit(VFIORegion *region)
 {
     int i;
@@ -1391,6 +1673,15 @@ void vfio_region_exit(VFIORegion *region)
     trace_vfio_region_exit(region->vbasedev->name, region->nr);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/display.c|421| <<vfio_display_region_update>> vfio_region_finalize(&dpy->region.buffer);
+ *   - hw/vfio/display.c|469| <<vfio_display_region_update>> vfio_region_finalize(&dpy->region.buffer);
+ *   - hw/vfio/display.c|495| <<vfio_display_region_exit>> vfio_region_finalize(&dpy->region.buffer);
+ *   - hw/vfio/migration.c|806| <<vfio_migration_exit>> vfio_region_finalize(&migration->region);
+ *   - hw/vfio/pci.c|1811| <<vfio_bars_finalize>> vfio_region_finalize(&bar->region);
+ *   - hw/vfio/platform.c|505| <<vfio_populate_device>> vfio_region_finalize(vdev->regions[i]);
+ */
 void vfio_region_finalize(VFIORegion *region)
 {
     int i;
@@ -1439,6 +1730,11 @@ void vfio_region_mmaps_set_enabled(VFIORegion *region, bool enabled)
                                         enabled);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|2313| <<vfio_get_group>> qemu_register_reset(vfio_reset_handler, NULL);
+ *   - hw/vfio/common.c|2346| <<vfio_put_group>> qemu_unregister_reset(vfio_reset_handler, NULL);
+ */
 void vfio_reset_handler(void *opaque)
 {
     VFIOGroup *group;
@@ -1461,6 +1757,11 @@ void vfio_reset_handler(void *opaque)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1874| <<vfio_connect_container>> vfio_kvm_device_add_group(group);
+ *   - hw/vfio/common.c|2004| <<vfio_connect_container>> vfio_kvm_device_add_group(group);
+ */
 static void vfio_kvm_device_add_group(VFIOGroup *group)
 {
 #ifdef CONFIG_KVM
@@ -1494,6 +1795,11 @@ static void vfio_kvm_device_add_group(VFIOGroup *group)
 #endif
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|2200| <<vfio_connect_container>> vfio_kvm_device_del_group(group);
+ *   - hw/vfio/common.c|2374| <<vfio_put_group>> vfio_kvm_device_del_group(group);
+ */
 static void vfio_kvm_device_del_group(VFIOGroup *group)
 {
 #ifdef CONFIG_KVM
@@ -1514,10 +1820,28 @@ static void vfio_kvm_device_del_group(VFIOGroup *group)
 #endif
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1752| <<vfio_connect_container>> space = vfio_get_address_space(as);
+ *   - hw/vfio/common.c|2294| <<vfio_eeh_as_container>> VFIOAddressSpace *space = vfio_get_address_space(as);
+ */
 static VFIOAddressSpace *vfio_get_address_space(AddressSpace *as)
 {
+    /*
+     * typedef struct VFIOAddressSpace {
+     *     AddressSpace *as;
+     *     QLIST_HEAD(, VFIOContainer) containers;
+     *     QLIST_ENTRY(VFIOAddressSpace) list;
+     * } VFIOAddressSpace;
+     */
     VFIOAddressSpace *space;
 
+    /*
+     * 在以下使用vfio_address_spaces:
+     *   - hw/vfio/common.c|46| <<QLIST_HEAD>> QLIST_HEAD_INITIALIZER(vfio_address_spaces);
+     *   - hw/vfio/common.c|1594| <<vfio_get_address_space>> QLIST_FOREACH(space, &vfio_address_spaces, list) {
+     *   - hw/vfio/common.c|1605| <<vfio_get_address_space>> QLIST_INSERT_HEAD(&vfio_address_spaces, space, list);
+     */
     QLIST_FOREACH(space, &vfio_address_spaces, list) {
         if (space->as == as) {
             return space;
@@ -1561,6 +1885,10 @@ static int vfio_get_iommu_type(VFIOContainer *container,
     return -EINVAL;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|2064| <<vfio_connect_container>> ret = vfio_init_container(container, group->fd, errp);
+ */
 static int vfio_init_container(VFIOContainer *container, int group_fd,
                                Error **errp)
 {
@@ -1665,6 +1993,10 @@ static void vfio_get_iommu_info_migration(VFIOContainer *container,
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1970| <<vfio_get_group>> if (vfio_connect_container(group, as, errp)) {
+ */
 static int vfio_connect_container(VFIOGroup *group, AddressSpace *as,
                                   Error **errp)
 {
@@ -1848,6 +2180,15 @@ static int vfio_connect_container(VFIOGroup *group, AddressSpace *as,
     group->container = container;
     QLIST_INSERT_HEAD(&container->group_list, group, container_next);
 
+    /*
+     * static const MemoryListener vfio_memory_listener = {
+     *     .region_add = vfio_listener_region_add,
+     *     .region_del = vfio_listener_region_del,
+     *     .log_sync = vfio_listerner_log_sync,
+     * };
+     *
+     * 只在此处使用vfio_memory_listener
+     */
     container->listener = vfio_memory_listener;
 
     memory_listener_register(&container->listener, container->space->as);
@@ -1923,6 +2264,13 @@ static void vfio_disconnect_container(VFIOGroup *group)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/ap.c|86| <<vfio_ap_get_group>> return vfio_get_group(groupid, &address_space_memory, errp);
+ *   - hw/vfio/ccw.c|627| <<vfio_ccw_get_group>> return vfio_get_group(groupid, &address_space_memory, errp);
+ *   - hw/vfio/pci.c|2824| <<vfio_realize>> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
+ *   - hw/vfio/platform.c|580| <<vfio_base_device_init>> group = vfio_get_group(groupid, &address_space_memory, errp);
+ */
 VFIOGroup *vfio_get_group(int groupid, AddressSpace *as, Error **errp)
 {
     VFIOGroup *group;
@@ -1965,8 +2313,41 @@ VFIOGroup *vfio_get_group(int groupid, AddressSpace *as, Error **errp)
     }
 
     group->groupid = groupid;
+    /*
+     * 在以下使用VFIOGroup->device_list:
+     *   - hw/vfio/ccw.c|570| <<vfio_ccw_get_device>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|314| <<vfio_mig_active>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|334| <<vfio_devices_all_saving>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|366| <<vfio_devices_all_running_and_saving>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|1521| <<vfio_reset_handler>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|1529| <<vfio_reset_handler>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|2045| <<vfio_get_group>> QLIST_INIT(&group->device_list);
+     *   - hw/vfio/common.c|2072| <<vfio_put_group>> if (!group || !QLIST_EMPTY(&group->device_list)) {
+     *   - hw/vfio/common.c|2122| <<vfio_get_device>> if (!QLIST_EMPTY(&group->device_list)) {
+     *   - hw/vfio/common.c|2137| <<vfio_get_device>> QLIST_INSERT_HEAD(&group->device_list, vbasedev, next);
+     *   - hw/vfio/pci.c|2266| <<vfio_pci_hot_reset>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/pci.c|2348| <<vfio_pci_hot_reset>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/pci.c|2829| <<vfio_realize>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/platform.c|585| <<vfio_base_device_init>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     */
     QLIST_INIT(&group->device_list);
 
+    /*
+     * Group 是IOMMU能够进行DMA隔离的最小硬件单元, 一个group内可能只有一个device, 也可能有多
+     * 个device, 这取决于物理平台上硬件的IOMMU拓扑结构. 设备直通的时候一个group里面的设备必须
+     * 都直通给一个虚拟机. 不能够让一个group里的多个device分别从属于2个不同的VM, 也不允许部分
+     * device在host上而另一部分被分配到guest里, 因为就这样一个guest中的device可以利用DMA攻击获
+     * 取另外一个guest里的数据, 就无法做到物理上的DMA隔离. 另外, VFIO中的group和iommu group可
+     * 以认为是同一个概念.
+     *
+     * Device 指的是我们要操作的硬件设备, 不过这里的"设备"需要从IOMMU拓扑的角度去理解. 如果该设
+     * 备是一个硬件拓扑上独立的设备, 那么它自己就构成一个iommu group. 如果这里是一个
+     * multi-function设备, 那么它和其他的function一起组成一个iommu group, 因为多个function设备
+     * 在物理硬件上就是互联的, 他们可以互相访问对方的数据所以必须放到一个group里隔离起来. 值得
+     * 一提的是, 对于支持PCIe ACS特性的硬件设备, 我们可以认为他们在物理上是互相隔离的.
+     *
+     * !!! Container 是一个和地址空间相关联的概念, 这里可以简单把它理解为一个VM Domain的物理内存空间.
+     */
     if (vfio_connect_container(group, as, errp)) {
         error_prepend(errp, "failed to setup container for group %d: ",
                       groupid);
@@ -2011,6 +2392,13 @@ void vfio_put_group(VFIOGroup *group)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/ap.c|116| <<vfio_ap_realize>> ret = vfio_get_device(vfio_group, mdevid, &vapdev->vdev, errp);
+ *   - hw/vfio/ccw.c|588| <<vfio_ccw_get_device>> if (vfio_get_device(group, vcdev->cdev.mdevid, &vcdev->vdev, errp)) {
+ *   - hw/vfio/pci.c|2967| <<vfio_realize>> ret = vfio_get_device(group, vdev->vbasedev.name, &vdev->vbasedev, errp);
+ *   - hw/vfio/platform.c|592| <<vfio_base_device_init>> ret = vfio_get_device(group, vbasedev->name, vbasedev, errp);
+ */
 int vfio_get_device(VFIOGroup *group, const char *name,
                     VFIODevice *vbasedev, Error **errp)
 {
@@ -2027,6 +2415,23 @@ int vfio_get_device(VFIOGroup *group, const char *name,
         return fd;
     }
 
+    /*
+     * struct vfio_device_info {
+     *     __u32   argsz;
+     *     __u32   flags;
+     * #define VFIO_DEVICE_FLAGS_RESET (1 << 0)        // Device supports reset
+     * #define VFIO_DEVICE_FLAGS_PCI   (1 << 1)        // vfio-pci device
+     * #define VFIO_DEVICE_FLAGS_PLATFORM (1 << 2)     // vfio-platform device
+     * #define VFIO_DEVICE_FLAGS_AMBA  (1 << 3)        // vfio-amba device
+     * #define VFIO_DEVICE_FLAGS_CCW   (1 << 4)        // vfio-ccw device
+     * #define VFIO_DEVICE_FLAGS_AP    (1 << 5)        // vfio-ap device
+     * #define VFIO_DEVICE_FLAGS_FSL_MC (1 << 6)       // vfio-fsl-mc device
+     * #define VFIO_DEVICE_FLAGS_CAPS  (1 << 7)        // Info supports caps
+     *     __u32   num_regions;    // Max region index + 1
+     *     __u32   num_irqs;       // Max IRQ index + 1
+     *     __u32   cap_offset;     // Offset within info struct of first cap
+     * };
+     */
     ret = ioctl(fd, VFIO_DEVICE_GET_INFO, &dev_info);
     if (ret) {
         error_setg_errno(errp, errno, "error getting device info");
@@ -2081,6 +2486,17 @@ void vfio_put_base_device(VFIODevice *vbasedev)
     close(vbasedev->fd);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/ccw.c|480| <<vfio_ccw_get_region>> ret = vfio_get_region_info(vdev, VFIO_CCW_CONFIG_REGION_INDEX, &info);
+ *   - hw/vfio/common.c|1516| <<vfio_region_setup>> ret = vfio_get_region_info(vbasedev, index, &info);
+ *   - hw/vfio/common.c|2516| <<vfio_get_dev_region_info>> if (vfio_get_region_info(vbasedev, i, info)) {
+ *   - hw/vfio/common.c|2547| <<vfio_has_region_cap>> if (!vfio_get_region_info(vbasedev, region, &info)) {
+ *   - hw/vfio/igd.c|423| <<vfio_probe_igd_bar4_quirk>> ret = vfio_get_region_info(&vdev->vbasedev,
+ *   - hw/vfio/pci.c|834| <<vfio_pci_load_rom>> if (vfio_get_region_info(&vdev->vbasedev,
+ *   - hw/vfio/pci.c|2598| <<vfio_populate_vga>> ret = vfio_get_region_info(vbasedev, VFIO_PCI_VGA_REGION_INDEX, &reg_info);
+ *   - hw/vfio/pci.c|2719| <<vfio_populate_device>> ret = vfio_get_region_info(vbasedev,
+ */
 int vfio_get_region_info(VFIODevice *vbasedev, int index,
                          struct vfio_region_info **info)
 {
@@ -2143,6 +2559,10 @@ int vfio_get_dev_region_info(VFIODevice *vbasedev, uint32_t type,
     return -ENODEV;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1335| <<vfio_pci_fixup_msix_region>> if (vfio_has_region_cap(&vdev->vbasedev, region->nr,
+ */
 bool vfio_has_region_cap(VFIODevice *vbasedev, int region, uint16_t cap_type)
 {
     struct vfio_region_info *info = NULL;
@@ -2189,6 +2609,10 @@ static bool vfio_eeh_container_ok(VFIOContainer *container)
     return true;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|2677| <<vfio_eeh_as_op>> return vfio_eeh_container_op(container, op);
+ */
 static int vfio_eeh_container_op(VFIOContainer *container, uint32_t op)
 {
     struct vfio_eeh_pe_op pe_op = {
@@ -2212,6 +2636,11 @@ static int vfio_eeh_container_op(VFIOContainer *container, uint32_t op)
     return ret;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|2657| <<vfio_eeh_as_ok>> VFIOContainer *container = vfio_eeh_as_container(as);
+ *   - hw/vfio/common.c|2672| <<vfio_eeh_as_op>> VFIOContainer *container = vfio_eeh_as_container(as);
+ */
 static VFIOContainer *vfio_eeh_as_container(AddressSpace *as)
 {
     VFIOAddressSpace *space = vfio_get_address_space(as);
@@ -2236,6 +2665,10 @@ out:
     return container;
 }
 
+/*
+ * called by:
+ *   - hw/ppc/spapr_pci_vfio.c|32| <<spapr_phb_eeh_available>> return vfio_eeh_as_ok(&sphb->iommu_as);
+ */
 bool vfio_eeh_as_ok(AddressSpace *as)
 {
     VFIOContainer *container = vfio_eeh_as_container(as);
@@ -2243,6 +2676,14 @@ bool vfio_eeh_as_ok(AddressSpace *as)
     return (container != NULL) && vfio_eeh_container_ok(container);
 }
 
+/*
+ * 只被ppc调用:
+ *   - hw/ppc/spapr_pci_vfio.c|37| <<spapr_phb_vfio_eeh_reenable>> vfio_eeh_as_op(&sphb->iommu_as, VFIO_EEH_PE_ENABLE);
+ *   - hw/ppc/spapr_pci_vfio.c|90| <<spapr_phb_vfio_eeh_set_option>> ret = vfio_eeh_as_op(&sphb->iommu_as, op);
+ *   - hw/ppc/spapr_pci_vfio.c|102| <<spapr_phb_vfio_eeh_get_state>> ret = vfio_eeh_as_op(&sphb->iommu_as, VFIO_EEH_PE_GET_STATE);
+ *   - hw/ppc/spapr_pci_vfio.c|175| <<spapr_phb_vfio_eeh_reset>> ret = vfio_eeh_as_op(&sphb->iommu_as, op);
+ *   - hw/ppc/spapr_pci_vfio.c|187| <<spapr_phb_vfio_eeh_configure>> ret = vfio_eeh_as_op(&sphb->iommu_as, VFIO_EEH_PE_CONFIGURE);
+ */
 int vfio_eeh_as_op(AddressSpace *as, uint32_t op)
 {
     VFIOContainer *container = vfio_eeh_as_container(as);
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 51dc37369..2ff7c6e0a 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -43,6 +43,44 @@
 #include "migration/blocker.h"
 #include "migration/qemu-file.h"
 
+/*
+ * https://kernelgo.org/vfio-insight.html
+ *
+ * qemu/vfio的设备包括:
+ *
+ * 1. 配置pci config
+ *
+ * vfio_pci_write_config()来配置, 如果需要更新bar的信息, 还要调用vfio_sub_page_bar_update_mapping()
+ *
+ * 2. 配置pci bar
+ *
+ * 因为用了subpage, msix和其他的bar可以分开
+ *
+ * 3. 配置msix table
+ *
+ * 4. ring buffer
+ *
+ * 5. irq
+ */
+
+/*
+ * Group 是IOMMU能够进行DMA隔离的最小硬件单元, 一个group内可能只有一个device, 也可能有多
+ * 个device, 这取决于物理平台上硬件的IOMMU拓扑结构. 设备直通的时候一个group里面的设备必须
+ * 都直通给一个虚拟机. 不能够让一个group里的多个device分别从属于2个不同的VM, 也不允许部分
+ * device在host上而另一部分被分配到guest里, 因为就这样一个guest中的device可以利用DMA攻击获
+ * 取另外一个guest里的数据, 就无法做到物理上的DMA隔离. 另外, VFIO中的group和iommu group可
+ * 以认为是同一个概念.
+ *
+ * Device 指的是我们要操作的硬件设备, 不过这里的"设备"需要从IOMMU拓扑的角度去理解. 如果该设
+ * 备是一个硬件拓扑上独立的设备, 那么它自己就构成一个iommu group. 如果这里是一个
+ * multi-function设备, 那么它和其他的function一起组成一个iommu group, 因为多个function设备
+ * 在物理硬件上就是互联的, 他们可以互相访问对方的数据所以必须放到一个group里隔离起来. 值得
+ * 一提的是, 对于支持PCIe ACS特性的硬件设备, 我们可以认为他们在物理上是互相隔离的.
+ *
+ * Container 是一个和地址空间相关联的概念, 这里可以简单把它理解为一个VM Domain的物理内存空间.
+ *
+ */
+
 #define TYPE_VFIO_PCI_NOHOTPLUG "vfio-pci-nohotplug"
 
 static void vfio_disable_interrupts(VFIOPCIDevice *vdev);
@@ -63,6 +101,10 @@ static void vfio_mmap_set_enabled(VFIOPCIDevice *vdev, bool enabled);
  * other options with the x-intx-mmap-timeout-ms parameter (a value of
  * zero disables the timer).
  */
+/*
+ * 在以下使用vfio_intx_mmap_enable():
+ *   - hw/vfio/pci.c|3221| <<vfio_realize>> vfio_intx_mmap_enable, vdev);
+ */
 static void vfio_intx_mmap_enable(void *opaque)
 {
     VFIOPCIDevice *vdev = opaque;
@@ -253,6 +295,12 @@ static void vfio_irqchip_change(Notifier *notify, void *data)
     vfio_intx_update(vdev, &vdev->intx.route);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|767| <<vfio_msi_disable_common>> vfio_intx_enable(vdev, &err);
+ *   - hw/vfio/pci.c|2283| <<vfio_pci_post_reset>> vfio_intx_enable(vdev, &err);
+ *   - hw/vfio/pci.c|3226| <<vfio_realize>> ret = vfio_intx_enable(vdev, errp);
+ */
 static int vfio_intx_enable(VFIOPCIDevice *vdev, Error **errp)
 {
     uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);
@@ -301,6 +349,12 @@ static int vfio_intx_enable(VFIOPCIDevice *vdev, Error **errp)
         warn_reportf_err(err, VFIO_MSG_PREFIX, vdev->vbasedev.name);
     }
 
+    /*
+     * 在以下使用VFIO_INT_INTx:
+     *   - hw/vfio/pci.c|275| <<vfio_intx_routing_notifier>> if (vdev->interrupt != VFIO_INT_INTx) {
+     *   - hw/vfio/pci.c|342| <<vfio_intx_enable>> vdev->interrupt = VFIO_INT_INTx;
+     *   - hw/vfio/pci.c|1288| <<vfio_disable_interrupts>> if (vdev->interrupt == VFIO_INT_INTx) {
+     */
     vdev->interrupt = VFIO_INT_INTx;
 
     trace_vfio_intx_enable(vdev->vbasedev.name);
@@ -330,6 +384,11 @@ static void vfio_intx_disable(VFIOPCIDevice *vdev)
 /*
  * MSI/X
  */
+/*
+ * 在以下使用vfio_msi_interrupt():
+ *   - hw/vfio/pci.c|540| <<vfio_msix_vector_use>> return vfio_msix_vector_do_use(pdev, nr, &msg, vfio_msi_interrupt);
+ *   - hw/vfio/pci.c|623| <<vfio_msi_enable>> qemu_set_fd_handler(event_notifier_get_fd(&vector->interrupt), vfio_msi_interrupt, NULL, vector);
+ */
 static void vfio_msi_interrupt(void *opaque)
 {
     VFIOMSIVector *vector = opaque;
@@ -365,6 +424,11 @@ static void vfio_msi_interrupt(void *opaque)
     notify(&vdev->pdev, nr);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|553| <<vfio_msix_vector_do_use>> ret = vfio_enable_vectors(vdev, true);
+ *   - hw/vfio/pci.c|688| <<vfio_msi_enable>> ret = vfio_enable_vectors(vdev, false);
+ */
 static int vfio_enable_vectors(VFIOPCIDevice *vdev, bool msix)
 {
     struct vfio_irq_set *irq_set;
@@ -409,6 +473,11 @@ static int vfio_enable_vectors(VFIOPCIDevice *vdev, bool msix)
     return ret;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|498| <<vfio_msix_vector_do_use>> vfio_add_kvm_msi_virq(vdev, vector, nr, true);
+ *   - hw/vfio/pci.c|634| <<vfio_msi_enable>> vfio_add_kvm_msi_virq(vdev, vector, i, false);
+ */
 static void vfio_add_kvm_msi_virq(VFIOPCIDevice *vdev, VFIOMSIVector *vector,
                                   int vector_n, bool msix)
 {
@@ -418,6 +487,9 @@ static void vfio_add_kvm_msi_virq(VFIOPCIDevice *vdev, VFIOMSIVector *vector,
         return;
     }
 
+    /*
+     * 初始化kvm_interrupt这个eventfd
+     */
     if (event_notifier_init(&vector->kvm_interrupt, 0)) {
         return;
     }
@@ -447,6 +519,11 @@ static void vfio_remove_kvm_msi_virq(VFIOMSIVector *vector)
     event_notifier_cleanup(&vector->kvm_interrupt);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|566| <<vfio_msix_vector_do_use>> vfio_update_kvm_msi_virq(vector, *msg, pdev);
+ *   - hw/vfio/pci.c|842| <<vfio_update_msi>> vfio_update_kvm_msi_virq(vector, msg, &vdev->pdev);
+ */
 static void vfio_update_kvm_msi_virq(VFIOMSIVector *vector, MSIMessage msg,
                                      PCIDevice *pdev)
 {
@@ -454,6 +531,27 @@ static void vfio_update_kvm_msi_virq(VFIOMSIVector *vector, MSIMessage msg,
     kvm_irqchip_commit_routes(kvm_state);
 }
 
+/*
+ * 虚拟机内部.
+ *  24:          0          0          0          0         13         87   PCI-MSI 65536-edge      iavf-0000:00:04.0:mbx
+ *  25:          0          0          0          0          0          0   PCI-MSI 65537-edge      iavf-ens4-TxRx-0
+ *  26:          0          0          0          0          0          0   PCI-MSI 65538-edge      iavf-ens4-TxRx-1
+ *  27:          0          0          0          0          0          0   PCI-MSI 65539-edge      iavf-ens4-TxRx-2
+ *  28:          0          0          0          0          0          0   PCI-MSI 65540-edge      iavf-ens4-TxRx-3
+ *
+ * host上的irq.
+ * IR-PCI-MSI 1802240-edge      vfio-msix[0](0000:03:0e.0)
+ * IR-PCI-MSI 1802241-edge      vfio-msix[1](0000:03:0e.0)
+ * IR-PCI-MSI 1802242-edge      vfio-msix[2](0000:03:0e.0)
+ * IR-PCI-MSI 1802243-edge      vfio-msix[3](0000:03:0e.0)
+ * IR-PCI-MSI 1802244-edge      vfio-msix[4](0000:03:0e.0)
+ *
+ * called by:
+ *   - hw/vfio/pci.c|588| <<vfio_msix_vector_use>> return vfio_msix_vector_do_use(pdev, nr, &msg, vfio_msi_interrupt);
+ *   - hw/vfio/pci.c|643| <<vfio_msix_enable>> vfio_msix_vector_do_use(&vdev->pdev, 0, NULL, NULL);
+ *
+ * host kernel在vfio_msihandler()处理硬件中断
+ */
 static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
                                    MSIMessage *msg, IOHandler *handler)
 {
@@ -566,6 +664,11 @@ static void vfio_msix_vector_release(PCIDevice *pdev, unsigned int nr)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1186| <<vfio_pci_write_config>> vfio_msix_enable(vdev);
+ *   - hw/vfio/pci.c|2504| <<vfio_pci_load_config>> vfio_msix_enable(vdev);
+ */
 static void vfio_msix_enable(VFIOPCIDevice *vdev)
 {
     vfio_disable_interrupts(vdev);
@@ -598,6 +701,11 @@ static void vfio_msix_enable(VFIOPCIDevice *vdev)
     trace_vfio_msix_enable(vdev->vbasedev.name);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1211| <<vfio_pci_write_config>> vfio_msi_enable(vdev);
+ *   - hw/vfio/pci.c|2560| <<vfio_pci_load_config>> vfio_msi_enable(vdev);
+ */
 static void vfio_msi_enable(VFIOPCIDevice *vdev)
 {
     int ret, i;
@@ -674,6 +782,11 @@ retry:
     trace_vfio_msi_enable(vdev->vbasedev.name, vdev->nr_vectors);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|813| <<vfio_msix_disable>> vfio_msi_disable_common(vdev);
+ *   - hw/vfio/pci.c|824| <<vfio_msi_disable>> vfio_msi_disable_common(vdev);
+ */
 static void vfio_msi_disable_common(VFIOPCIDevice *vdev)
 {
     Error *err = NULL;
@@ -702,6 +815,11 @@ static void vfio_msi_disable_common(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1265| <<vfio_pci_write_config>> vfio_msix_disable(vdev);
+ *   - hw/vfio/pci.c|1310| <<vfio_disable_interrupts>> vfio_msix_disable(vdev);
+ */
 static void vfio_msix_disable(VFIOPCIDevice *vdev)
 {
     int i;
@@ -731,6 +849,11 @@ static void vfio_msix_disable(VFIOPCIDevice *vdev)
     trace_vfio_msix_disable(vdev->vbasedev.name);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1249| <<vfio_pci_write_config>> vfio_msi_disable(vdev);
+ *   - hw/vfio/pci.c|1312| <<vfio_disable_interrupts>> vfio_msi_disable(vdev);
+ */
 static void vfio_msi_disable(VFIOPCIDevice *vdev)
 {
     vfio_disable_irqindex(&vdev->vbasedev, VFIO_PCI_MSI_IRQ_INDEX);
@@ -739,6 +862,10 @@ static void vfio_msi_disable(VFIOPCIDevice *vdev)
     trace_vfio_msi_disable(vdev->vbasedev.name);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1251| <<vfio_pci_write_config>> vfio_update_msi(vdev);
+ */
 static void vfio_update_msi(VFIOPCIDevice *vdev)
 {
     int i;
@@ -883,6 +1010,10 @@ static void vfio_rom_write(void *opaque, hwaddr addr,
 {
 }
 
+/*
+ * 在以下使用vfio_rom_ops:
+ *   - hw/vfio/pci.c|1037| <<vfio_pci_size_rom>> &vfio_rom_ops, vdev, name, size);
+ */
 static const MemoryRegionOps vfio_rom_ops = {
     .read = vfio_rom_read,
     .write = vfio_rom_write,
@@ -1031,6 +1162,12 @@ uint64_t vfio_vga_read(void *opaque, hwaddr addr, unsigned size)
     return data;
 }
 
+/*
+ * 在以下使用vfio_vga_ops:
+ *   - hw/vfio/pci.c|2655| <<vfio_populate_vga>> OBJECT(vdev), &vfio_vga_ops,
+ *   - hw/vfio/pci.c|2665| <<vfio_populate_vga>> OBJECT(vdev), &vfio_vga_ops,
+ *   - hw/vfio/pci.c|2675| <<vfio_populate_vga>> OBJECT(vdev), &vfio_vga_ops,
+ */
 static const MemoryRegionOps vfio_vga_ops = {
     .read = vfio_vga_read,
     .write = vfio_vga_write,
@@ -1047,6 +1184,10 @@ static const MemoryRegionOps vfio_vga_ops = {
  * size of this sub-page BAR when its base address is changed in guest
  * and not page aligned any more.
  */
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1191| <<vfio_pci_write_config>> vfio_sub_page_bar_update_mapping(pdev, bar);
+ */
 static void vfio_sub_page_bar_update_mapping(PCIDevice *pdev, int bar)
 {
     VFIOPCIDevice *vdev = VFIO_PCI(pdev);
@@ -1200,6 +1341,14 @@ void vfio_pci_write_config(PCIDevice *pdev,
 /*
  * Interrupt setup
  */
+/*
+ * called by:
+ *   - hw/vfio/pci.c|306| <<vfio_intx_enable>> vfio_disable_interrupts(vdev);
+ *   - hw/vfio/pci.c|634| <<vfio_msix_enable>> vfio_disable_interrupts(vdev);
+ *   - hw/vfio/pci.c|673| <<vfio_msi_enable>> vfio_disable_interrupts(vdev);
+ *   - hw/vfio/pci.c|2246| <<vfio_pci_pre_reset>> vfio_disable_interrupts(vdev);
+ *   - hw/vfio/pci.c|3320| <<vfio_exitfn>> vfio_disable_interrupts(vdev);
+ */
 static void vfio_disable_interrupts(VFIOPCIDevice *vdev)
 {
     /*
@@ -1218,6 +1367,10 @@ static void vfio_disable_interrupts(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2125| <<vfio_add_std_cap>> ret = vfio_msi_setup(vdev, pos, errp);
+ */
 static int vfio_msi_setup(VFIOPCIDevice *vdev, int pos, Error **errp)
 {
     uint16_t ctrl;
@@ -1251,6 +1404,10 @@ static int vfio_msi_setup(VFIOPCIDevice *vdev, int pos, Error **errp)
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1599| <<vfio_msix_early_setup>> vfio_pci_fixup_msix_region(vdev);
+ */
 static void vfio_pci_fixup_msix_region(VFIOPCIDevice *vdev)
 {
     off_t start, end;
@@ -1502,11 +1659,28 @@ static void vfio_msix_early_setup(VFIOPCIDevice *vdev, Error **errp)
     vfio_pci_relocate_msix(vdev, errp);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2023| <<vfio_add_std_cap>> ret = vfio_msix_setup(vdev, pos, errp);
+ */
 static int vfio_msix_setup(VFIOPCIDevice *vdev, int pos, Error **errp)
 {
     int ret;
     Error *err = NULL;
 
+    /*
+     * VFIOPCIDevice *vdev:
+     * -> PCIDevice pdev;
+     * -> VFIODevice vbasedev;
+     * -> VFIOMSIVector *msi_vectors;
+     * -> VFIOMSIXInfo *msix;
+     *    -> uint8_t table_bar;
+     *    -> uint8_t pba_bar;  
+     *    -> uint16_t entries;
+     *    -> uint32_t table_offset;
+     *    -> uint32_t pba_offset;
+     *    -> unsigned long *pending;
+     */
     vdev->msix->pending = g_malloc0(BITS_TO_LONGS(vdev->msix->entries) *
                                     sizeof(unsigned long));
     ret = msix_init(&vdev->pdev, vdev->msix->entries,
@@ -1574,6 +1748,12 @@ static void vfio_teardown_msi(VFIOPCIDevice *vdev)
 /*
  * Resource setup
  */
+/*
+ * called by:
+ *   - hw/vfio/pci.c|118| <<vfio_intx_mmap_enable>> vfio_mmap_set_enabled(vdev, true);
+ *   - hw/vfio/pci.c|133| <<vfio_intx_interrupt>> vfio_mmap_set_enabled(vdev, false);
+ *   - hw/vfio/pci.c|373| <<vfio_intx_disable>> vfio_mmap_set_enabled(vdev, true);
+ */
 static void vfio_mmap_set_enabled(VFIOPCIDevice *vdev, bool enabled)
 {
     int i;
@@ -1620,6 +1800,19 @@ static void vfio_bars_prepare(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * 184 memory-region: pci
+ * 185   0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+ * ... ...
+ * 191     00000000fe000000-00000000fe7fffff (prio 1, i/o): 0000:03:00.3 base BAR 0
+ * 192       00000000fe000000-00000000fe7fffff (prio 0, i/o): 0000:03:00.3 BAR 0
+ * 193         00000000fe000000-00000000fe7fffff (prio 0, ramd): 0000:03:00.3 BAR 0 mmaps[0]
+ * 194     00000000fe800000-00000000fe807fff (prio 1, i/o): 0000:03:00.3 base BAR 3
+ * 195       00000000fe800000-00000000fe80080f (prio 0, i/o): msix-table
+ * 196       00000000fe800000-00000000fe807fff (prio 0, i/o): 0000:03:00.3 BAR 3
+ * 197         00000000fe801000-00000000fe807fff (prio 0, ramd): 0000:03:00.3 BAR 3 mmaps[0]
+ * 198       00000000fe801000-00000000fe801017 (prio 0, i/o): msix-pba [disabled]
+ */
 static void vfio_bar_register(VFIOPCIDevice *vdev, int nr)
 {
     VFIOBAR *bar = &vdev->bars[nr];
@@ -1631,21 +1824,44 @@ static void vfio_bar_register(VFIOPCIDevice *vdev, int nr)
 
     bar->mr = g_new0(MemoryRegion, 1);
     name = g_strdup_printf("%s base BAR %d", vdev->vbasedev.name, nr);
+    /*
+     * VFIOBAR *bar = &vdev->bars[nr]:
+     * -> VFIORegion region;
+     *    -> MemoryRegion *mem;
+     * -> MemoryRegion *mr; --> "base BAR"
+     */
     memory_region_init_io(bar->mr, OBJECT(vdev), NULL, NULL, name, bar->size);
     g_free(name);
 
     if (bar->region.size) {
         memory_region_add_subregion(bar->mr, 0, bar->region.mem);
 
+	/*
+	 * 这里非常重要!!!
+	 *
+	 * 把bar map到QEMU的user address space
+	 */
         if (vfio_region_mmap(&bar->region)) {
             error_report("Failed to mmap %s BAR %d. Performance may be slow",
                          vdev->vbasedev.name, nr);
         }
     }
 
+    /*
+     * VFIOBAR *bar = &vdev->bars[nr]:
+     * -> VFIORegion region;
+     *    -> MemoryRegion *mem;
+     * -> MemoryRegion *mr;
+     *
+     * 在pci_update_mappings()会把bar->mr挂到pci的memory上
+     */
     pci_register_bar(&vdev->pdev, nr, bar->type, bar->mr);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2979| <<vfio_realize>> vfio_bars_register(vdev);
+ */
 static void vfio_bars_register(VFIOPCIDevice *vdev)
 {
     int i;
@@ -1750,6 +1966,12 @@ static void vfio_set_long_bits(uint8_t *buf, uint32_t val, uint32_t mask)
     pci_set_long(buf, (pci_get_long(buf) & ~mask) | val);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2040| <<vfio_setup_pcie_cap>> vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP, 0, ~0);
+ *   - hw/vfio/pci.c|2052| <<vfio_setup_pcie_cap>> vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP2, 0, ~0);
+ *   - hw/vfio/pci.c|2075| <<vfio_setup_pcie_cap>> vfio_add_emulated_long(vdev, pos + PCI_EXP_LNKCAP,
+ */
 static void vfio_add_emulated_long(VFIOPCIDevice *vdev, int pos,
                                    uint32_t val, uint32_t mask)
 {
@@ -1916,6 +2138,11 @@ static void vfio_check_af_flr(VFIOPCIDevice *vdev, uint8_t pos)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1944| <<vfio_add_std_cap>> ret = vfio_add_std_cap(vdev, next, errp);
+ *   - hw/vfio/pci.c|2102| <<vfio_add_capabilities>> ret = vfio_add_std_cap(vdev, pdev->config[PCI_CAPABILITY_LIST], errp);
+ */
 static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos, Error **errp)
 {
     PCIDevice *pdev = &vdev->pdev;
@@ -2089,6 +2316,10 @@ static void vfio_add_ext_cap(VFIOPCIDevice *vdev)
     return;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|3320| <<vfio_realize>> ret = vfio_add_capabilities(vdev, errp);
+ */
 static int vfio_add_capabilities(VFIOPCIDevice *vdev, Error **errp)
 {
     PCIDevice *pdev = &vdev->pdev;
@@ -2169,6 +2400,13 @@ static void vfio_pci_post_reset(VFIOPCIDevice *vdev)
     vfio_quirk_reset(vdev);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2466| <<vfio_pci_hot_reset>> if (vfio_pci_host_match(&host, vdev->vbasedev.name)) {
+ *   - hw/vfio/pci.c|2493| <<vfio_pci_hot_reset>> if (vfio_pci_host_match(&host, tmp->vbasedev.name)) {
+ *   - hw/vfio/pci.c|2555| <<vfio_pci_hot_reset>> if (vfio_pci_host_match(&host, vdev->vbasedev.name)) {
+ *   - hw/vfio/pci.c|2575| <<vfio_pci_hot_reset>> if (vfio_pci_host_match(&host, tmp->vbasedev.name)) {
+ */
 static bool vfio_pci_host_match(PCIHostDeviceAddress *addr, const char *name)
 {
     char tmp[13];
@@ -2179,6 +2417,11 @@ static bool vfio_pci_host_match(PCIHostDeviceAddress *addr, const char *name)
     return (strcmp(tmp, name) == 0);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2602| <<vfio_pci_hot_reset_one>> return vfio_pci_hot_reset(vdev, true);
+ *   - hw/vfio/pci.c|2608| <<vfio_pci_hot_reset_multi>> return vfio_pci_hot_reset(vdev, false);
+ */
 static int vfio_pci_hot_reset(VFIOPCIDevice *vdev, bool single)
 {
     VFIOGroup *group;
@@ -2409,6 +2652,11 @@ static bool vfio_msix_present(void *opaque, int version_id)
     return msix_present(pdev);
 }
 
+/*
+ * 在以下使用vmstate_vfio_pci_config:
+ *   - hw/vfio/pci.c|2648| <<vfio_pci_save_config>> vmstate_save_state(f, &vmstate_vfio_pci_config, vdev, NULL);
+ *   - hw/vfio/pci.c|2657| <<vfio_pci_load_config>> ret = vmstate_load_state(f, &vmstate_vfio_pci_config, vdev, 1);
+ */
 const VMStateDescription vmstate_vfio_pci_config = {
     .name = "VFIOPCIDevice",
     .version_id = 1,
@@ -2450,6 +2698,10 @@ static int vfio_pci_load_config(VFIODevice *vbasedev, QEMUFile *f)
     return ret;
 }
 
+/*
+ * 在以下使用vfio_pci_ops:
+ *   - hw/vfio/pci.c|3083| <<vfio_realize>> vdev->vbasedev.ops = &vfio_pci_ops;
+ */
 static VFIODeviceOps vfio_pci_ops = {
     .vfio_compute_needs_reset = vfio_pci_compute_needs_reset,
     .vfio_hot_reset_multi = vfio_pci_hot_reset_multi,
@@ -2459,6 +2711,11 @@ static VFIODeviceOps vfio_pci_ops = {
     .vfio_load_config = vfio_pci_load_config,
 };
 
+/*
+ * called by:
+ *   - hw/vfio/igd.c|480| <<vfio_probe_igd_bar4_quirk>> if (!(gmch & 0x2) && !vdev->vga && vfio_populate_vga(vdev, &err)) {
+ *   - hw/vfio/pci.c|2831| <<vfio_populate_device>> ret = vfio_populate_vga(vdev, errp);
+ */
 int vfio_populate_vga(VFIOPCIDevice *vdev, Error **errp)
 {
     VFIODevice *vbasedev = &vdev->vbasedev;
@@ -2527,6 +2784,12 @@ int vfio_populate_vga(VFIOPCIDevice *vdev, Error **errp)
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2973| <<vfio_realize>> vfio_populate_device(vdev, &err);
+ *   - hw/vfio/platform.c|444| <<vfio_populate_device>> static int vfio_populate_device(VFIODevice *vbasedev, Error **errp)
+ *   - hw/vfio/platform.c|598| <<vfio_base_device_init>> ret = vfio_populate_device(vbasedev, errp);
+ */
 static void vfio_populate_device(VFIOPCIDevice *vdev, Error **errp)
 {
     VFIODevice *vbasedev = &vdev->vbasedev;
@@ -2554,6 +2817,17 @@ static void vfio_populate_device(VFIOPCIDevice *vdev, Error **errp)
     for (i = VFIO_PCI_BAR0_REGION_INDEX; i < VFIO_PCI_ROM_REGION_INDEX; i++) {
         char *name = g_strdup_printf("%s BAR %d", vbasedev->name, i);
 
+        /*
+	 * VFIOPCIDevice *vdev:
+	 * -> PCIDevice pdev;
+	 * -> VFIODevice vbasedev;
+	 * -> VFIOBAR bars[PCI_NUM_REGIONS - 1];
+	 *    -> VFIORegion region;
+	 *       -> MemoryRegion *mem;
+	 *    -> MemoryRegion *mr;
+	 *
+	 * VFIODevice *vbasedev = &vdev->vbasedev;
+	 */
         ret = vfio_region_setup(OBJECT(vdev), vbasedev,
                                 &vdev->bars[i].region, i, name);
         g_free(name);
@@ -2566,6 +2840,9 @@ static void vfio_populate_device(VFIOPCIDevice *vdev, Error **errp)
         QLIST_INIT(&vdev->bars[i].quirks);
     }
 
+    /*
+     * 上面的循环是bar的, 这里是config的
+     */
     ret = vfio_get_region_info(vbasedev,
                                VFIO_PCI_CONFIG_REGION_INDEX, &reg_info);
     if (ret) {
@@ -2646,6 +2923,10 @@ static void vfio_err_notifier_handler(void *opaque)
  * and continue after disabling error recovery support for the
  * device.
  */
+/*
+ * called by:
+ *   - hw/vfio/pci.c|3403| <<vfio_realize>> vfio_register_err_notifier(vdev);
+ */
 static void vfio_register_err_notifier(VFIOPCIDevice *vdev)
 {
     Error *err = NULL;
@@ -2664,6 +2945,21 @@ static void vfio_register_err_notifier(VFIOPCIDevice *vdev)
     fd = event_notifier_get_fd(&vdev->err_notifier);
     qemu_set_fd_handler(fd, vfio_err_notifier_handler, NULL, vdev);
 
+    /*
+     * called by:
+     *   - hw/vfio/ccw.c|420| <<vfio_ccw_register_irq_notifier>> if (vfio_set_irq_signaling(vdev, irq, 0,
+     *   - hw/vfio/ccw.c|448| <<vfio_ccw_unregister_irq_notifier>> if (vfio_set_irq_signaling(&vcdev->vdev, irq, 0,
+     *   - hw/vfio/pci.c|182| <<vfio_intx_enable_kvm>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0,
+     *   - hw/vfio/pci.c|330| <<vfio_intx_enable>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0,
+     *   - hw/vfio/pci.c|577| <<vfio_msix_vector_do_use>> if (vfio_set_irq_signaling(&vdev->vbasedev,
+     *   - hw/vfio/pci.c|620| <<vfio_msix_vector_release>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_MSIX_IRQ_INDEX, nr,
+     *   - hw/vfio/pci.c|2817| <<vfio_register_err_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_ERR_IRQ_INDEX, 0,
+     *   - hw/vfio/pci.c|2834| <<vfio_unregister_err_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_ERR_IRQ_INDEX, 0,
+     *   - hw/vfio/pci.c|2882| <<vfio_register_req_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_REQ_IRQ_INDEX, 0,
+     *   - hw/vfio/pci.c|2900| <<vfio_unregister_req_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_REQ_IRQ_INDEX, 0,
+     *   - hw/vfio/platform.c|120| <<vfio_set_trigger_eventfd>> ret = vfio_set_irq_signaling(vbasedev, intp->pin, 0,
+     *   - hw/vfio/platform.c|359| <<vfio_set_resample_eventfd>> ret = vfio_set_irq_signaling(vbasedev, intp->pin, 0,
+     */
     if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_ERR_IRQ_INDEX, 0,
                                VFIO_IRQ_SET_ACTION_TRIGGER, fd, &err)) {
         error_reportf_err(err, VFIO_MSG_PREFIX, vdev->vbasedev.name);
@@ -2705,6 +3001,10 @@ static void vfio_req_notifier_handler(void *opaque)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|3350| <<vfio_realize>> vfio_register_req_notifier(vdev);
+ */
 static void vfio_register_req_notifier(VFIOPCIDevice *vdev)
 {
     struct vfio_irq_info irq_info = { .argsz = sizeof(irq_info),
@@ -2729,6 +3029,21 @@ static void vfio_register_req_notifier(VFIOPCIDevice *vdev)
     fd = event_notifier_get_fd(&vdev->req_notifier);
     qemu_set_fd_handler(fd, vfio_req_notifier_handler, NULL, vdev);
 
+    /*
+     * called by:
+     *   - hw/vfio/ccw.c|420| <<vfio_ccw_register_irq_notifier>> if (vfio_set_irq_signaling(vdev, irq, 0,
+     *   - hw/vfio/ccw.c|448| <<vfio_ccw_unregister_irq_notifier>> if (vfio_set_irq_signaling(&vcdev->vdev, irq, 0,
+     *   - hw/vfio/pci.c|182| <<vfio_intx_enable_kvm>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0,
+     *   - hw/vfio/pci.c|330| <<vfio_intx_enable>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0,
+     *   - hw/vfio/pci.c|577| <<vfio_msix_vector_do_use>> if (vfio_set_irq_signaling(&vdev->vbasedev,
+     *   - hw/vfio/pci.c|620| <<vfio_msix_vector_release>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_MSIX_IRQ_INDEX, nr,
+     *   - hw/vfio/pci.c|2817| <<vfio_register_err_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_ERR_IRQ_INDEX, 0,
+     *   - hw/vfio/pci.c|2834| <<vfio_unregister_err_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_ERR_IRQ_INDEX, 0,
+     *   - hw/vfio/pci.c|2882| <<vfio_register_req_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_REQ_IRQ_INDEX, 0,
+     *   - hw/vfio/pci.c|2900| <<vfio_unregister_req_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_REQ_IRQ_INDEX, 0,
+     *   - hw/vfio/platform.c|120| <<vfio_set_trigger_eventfd>> ret = vfio_set_irq_signaling(vbasedev, intp->pin, 0,
+     *   - hw/vfio/platform.c|359| <<vfio_set_resample_eventfd>> ret = vfio_set_irq_signaling(vbasedev, intp->pin, 0,
+     */
     if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_REQ_IRQ_INDEX, 0,
                            VFIO_IRQ_SET_ACTION_TRIGGER, fd, &err)) {
         error_reportf_err(err, VFIO_MSG_PREFIX, vdev->vbasedev.name);
@@ -2739,6 +3054,10 @@ static void vfio_register_req_notifier(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|3389| <<vfio_exitfn>> vfio_unregister_req_notifier(vdev);
+ */
 static void vfio_unregister_req_notifier(VFIOPCIDevice *vdev)
 {
     Error *err = NULL;
@@ -2758,6 +3077,10 @@ static void vfio_unregister_req_notifier(VFIOPCIDevice *vdev)
     vdev->req_enabled = false;
 }
 
+/*
+ * 在以下使用vfio_realize():
+ *   - hw/vfio/pci.c|3248| <<vfio_pci_dev_class_init>> pdc->realize = vfio_realize;
+ */
 static void vfio_realize(PCIDevice *pdev, Error **errp)
 {
     VFIOPCIDevice *vdev = VFIO_PCI(pdev);
@@ -2791,11 +3114,23 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
         return;
     }
 
+    /*
+     * VFIOPCIDevice *vdev:
+     * -> PCIDevice pdev;
+     * -> VFIODevice vbasedev;
+     */
     vdev->vbasedev.name = g_path_get_basename(vdev->vbasedev.sysfsdev);
     vdev->vbasedev.ops = &vfio_pci_ops;
     vdev->vbasedev.type = VFIO_DEVICE_TYPE_PCI;
     vdev->vbasedev.dev = DEVICE(vdev);
 
+    /*
+     * # ls /sys/bus/pci/devices/0000\:03\:00.3/iommu_group/devices/
+     * 0000:03:00.3
+     *
+     * # ll /sys/bus/pci/devices/0000\:03\:00.3/iommu_group
+     * lrwxrwxrwx 1 root root 0 Apr  1 00:48 /sys/bus/pci/devices/0000:03:00.3/iommu_group -> ../../../../kernel/iommu_groups/85
+     */
     tmp = g_strdup_printf("%s/iommu_group", vdev->vbasedev.sysfsdev);
     len = readlink(tmp, group_path, sizeof(group_path));
     g_free(tmp);
@@ -2816,6 +3151,13 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
 
     trace_vfio_realize(vdev->vbasedev.name, groupid);
 
+    /*
+     * 在以下调用pci_device_iommu_address_space():
+     *   - hw/pci/pci.c|96| <<pci_init_bus_master>> AddressSpace *dma_as = pci_device_iommu_address_space(pci_dev);
+     *   - hw/vfio/pci.c|2824| <<vfio_realize>> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
+     *
+     * VFIOGroup
+     */
     group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
     if (!group) {
         goto error;
@@ -2835,6 +3177,10 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
      * stays in sync with the active working set of the guest driver.  Prevent
      * the x-balloon-allowed option unless this is minimally an mdev device.
      */
+    /*
+     * # readlink /sys/bus/pci/devices/0000\:03\:00.3/subsystem
+     * ../../../../bus/pci
+     */
     tmp = g_strdup_printf("%s/subsystem", vdev->vbasedev.sysfsdev);
     subsys = realpath(tmp, NULL);
     g_free(tmp);
@@ -2863,6 +3209,10 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
     }
 
     /* Get a copy of config space */
+    /*
+     * config_size只在以下获取:
+     *   - hw/vfio/pci.c|2681| <<vfio_populate_device>> vdev->config_size = reg_info->size;
+     */
     ret = pread(vdev->vbasedev.fd, vdev->pdev.config,
                 MIN(pci_config_size(&vdev->pdev), vdev->config_size),
                 vdev->config_offset);
@@ -2951,12 +3301,37 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
 
     vfio_bars_prepare(vdev);
 
+    /*
+     * 注释.
+     * We don't have any control over how pci_add_capability() inserts
+     * capabilities into the chain.  In order to setup MSI-X we need a
+     * MemoryRegion for the BAR.  In order to setup the BAR and not
+     * attempt to mmap the MSI-X table area, which VFIO won't allow, we
+     * need to first look for where the MSI-X table lives.  So we
+     * unfortunately split MSI-X setup across two functions.
+     */
     vfio_msix_early_setup(vdev, &err);
     if (err) {
         error_propagate(errp, err);
         goto error;
     }
 
+    /*
+     *  1. QEMU首先调用vfio_region_mmap,通过mmap region->vbasedev->fd把设备MMIO映射
+     * 到QEMU进程的虚拟地址空间,这实际上通过调用vfio-pci内核驱动
+     * vfio_pci_mmap->remap_pfn_range,remap_pfn_range是内核提供的API,可以将一段连续
+     * 的物理地址空间映射到进程的虚拟地址空间,这里用它将设备的BAR空间的MMIO先映射到
+     * QEMU进程的虚拟地址空间再注册给虚拟机.
+     *
+     * 2. vfio_region_mmap调用memory_region_init_ram_device_ptr把前面mmap过来的这段
+     * IOVA作为RAM类型设备注册给虚拟机.
+     *
+     * 3. memory_region_init_ram_device_ptr中会标志mr->ram = true,那么QEMU就会通过
+     * kvm_set_phys_mem注册这段内存给虚拟机(是RAM类型才会建立EPT映射关系),这样KVM就
+     * 会为这段地址空间建立EPT页表,虚拟机访问设备的MMIO空间时通过EPT页表翻直接访问不
+     * 需要VM-Exit.例如,网卡的收发包场景,虚拟机可以直接操作真实网卡的相关寄存器(MMIO映射)
+     * 而没有陷入先出开销,大幅度提升了虚拟化场景下的I/O性能.
+     */
     vfio_bars_register(vdev);
 
     ret = vfio_add_capabilities(vdev, errp);
diff --git a/hw/vfio/pci.h b/hw/vfio/pci.h
index 1574ef983..3794e86c0 100644
--- a/hw/vfio/pci.h
+++ b/hw/vfio/pci.h
@@ -99,6 +99,12 @@ typedef struct VFIOMSIVector {
 
 enum {
     VFIO_INT_NONE = 0,
+    /*
+     * 在以下使用VFIO_INT_INTx:
+     *   - hw/vfio/pci.c|275| <<vfio_intx_routing_notifier>> if (vdev->interrupt != VFIO_INT_INTx) {
+     *   - hw/vfio/pci.c|342| <<vfio_intx_enable>> vdev->interrupt = VFIO_INT_INTx;
+     *   - hw/vfio/pci.c|1288| <<vfio_disable_interrupts>> if (vdev->interrupt == VFIO_INT_INTx) {
+     */
     VFIO_INT_INTx = 1,
     VFIO_INT_MSI  = 2,
     VFIO_INT_MSIX = 3,
diff --git a/hw/virtio/vhost.c b/hw/virtio/vhost.c
index 614ccc2bc..ecadcecf7 100644
--- a/hw/virtio/vhost.c
+++ b/hw/virtio/vhost.c
@@ -1128,6 +1128,25 @@ static int vhost_virtqueue_start(struct vhost_dev *dev,
     /* Clear and discard previous events if any. */
     event_notifier_test_and_clear(&vq->masked_notifier);
 
+    /*
+     * Since guest_mask_notifier can not be used in vhost-user mode due
+     * to buffering implied by unix control socket, force
+     * use_mask_notifier on virtio devices of vhost-user interfaces, and
+     * send correct callfd to the guest at vhost start.
+     *
+     * Using guest_notifier_mask function in vhost-user case may
+     * break interrupt mask paradigm, because mask/unmask is not
+     * really done when returning from guest_notifier_mask call, instead
+     * message is posted in a unix socket, and processed later.
+     *
+     * Add an option boolean flag 'use_mask_notifier' to disable the use
+     * of guest_notifier_mask in virtio pci.
+     *
+     * 在以下使用VirtIODevice->use_guest_notifier_mask:
+     *   - backends/cryptodev-vhost.c|197| <<cryptodev_vhost_start>> dev->use_guest_notifier_mask = false;
+     *   - hw/net/vhost_net.c|343| <<vhost_net_start>> dev->use_guest_notifier_mask = false;
+     *   - hw/virtio/virtio.c|3533| <<virtio_init>> vdev->use_guest_notifier_mask = true;
+     */
     /* Init vring in unmasked state, unless guest_notifier_mask
      * will do it later.
      */
@@ -1277,6 +1296,18 @@ static void vhost_virtqueue_cleanup(struct vhost_virtqueue *vq)
     event_notifier_cleanup(&vq->masked_notifier);
 }
 
+/*
+ * called by:
+ *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev, options->opaque, options->backend_type, 0);
+ *   - backends/vhost-user.c|51| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev, &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0);
+ *   - hw/block/vhost-user-blk.c|326| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev, &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0);
+ *   - hw/net/vhost_net.c|186| <<vhost_net_init>> r = vhost_dev_init(&net->dev, options->opaque,
+ *   - hw/scsi/vhost-scsi.c|231| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev, (void *)(uintptr_t)vhostfd,
+ *   - hw/scsi/vhost-user-scsi.c|123| <<vhost_user_scsi_realize>> ret = vhost_dev_init(&vsc->dev, &s->vhost_user,
+ *   - hw/virtio/vhost-user-fs.c|223| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev, &fs->vhost_user,
+ *   - hw/virtio/vhost-user-vsock.c|109| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev, &vsock->vhost_user,
+ *   - hw/virtio/vhost-vsock.c|172| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev, (void *)(uintptr_t)vhostfd,
+ */
 int vhost_dev_init(struct vhost_dev *hdev, void *opaque,
                    VhostBackendType backend_type, uint32_t busyloop_timeout)
 {
@@ -1427,6 +1458,16 @@ void vhost_dev_cleanup(struct vhost_dev *hdev)
 /* Stop processing guest IO notifications in qemu.
  * Start processing them in vhost in kernel.
  */
+/*
+ * called by:
+ *   - backends/cryptodev-vhost.c|89| <<cryptodev_vhost_start_one>> r = vhost_dev_enable_notifiers(&crypto->dev, dev);
+ *   - backends/vhost-user.c|76| <<vhost_user_backend_start>> ret = vhost_dev_enable_notifiers(&b->dev, b->vdev);
+ *   - hw/block/vhost-user-blk.c|120| <<vhost_user_blk_start>> ret = vhost_dev_enable_notifiers(&s->dev, vdev);
+ *   - hw/net/vhost_net.c|256| <<vhost_net_start_one>> r = vhost_dev_enable_notifiers(&net->dev, dev);
+ *   - hw/scsi/vhost-scsi-common.c|47| <<vhost_scsi_common_start>> ret = vhost_dev_enable_notifiers(&vsc->dev, vdev);
+ *   - hw/virtio/vhost-user-fs.c|51| <<vuf_start>> ret = vhost_dev_enable_notifiers(&fs->vhost_dev, vdev);
+ *   - hw/virtio/vhost-vsock-common.c|34| <<vhost_vsock_common_start>> ret = vhost_dev_enable_notifiers(&vvc->vhost_dev, vdev);
+ */
 int vhost_dev_enable_notifiers(struct vhost_dev *hdev, VirtIODevice *vdev)
 {
     BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));
@@ -1499,6 +1540,20 @@ bool vhost_virtqueue_pending(struct vhost_dev *hdev, int n)
 }
 
 /* Mask/unmask events from this vq. */
+/*
+ * called by:
+ *   - backends/cryptodev-vhost.c|283| <<cryptodev_vhost_virtqueue_mask>> vhost_virtqueue_mask(&vhost_crypto->dev, dev, idx, mask);
+ *   - backends/vhost-user.c|99| <<vhost_user_backend_start>> vhost_virtqueue_mask(&b->dev, b->vdev,
+ *   - hw/block/vhost-user-blk.c|166| <<vhost_user_blk_start>> vhost_virtqueue_mask(&s->dev, vdev, i, false);
+ *   - hw/display/vhost-user-gpu.c|502| <<vhost_user_gpu_guest_notifier_mask>> vhost_virtqueue_mask(&g->vhost->dev, vdev, idx, mask);
+ *   - hw/net/vhost_net.c|445| <<vhost_net_virtqueue_mask>> vhost_virtqueue_mask(&net->dev, dev, idx, mask);
+ *   - hw/scsi/vhost-scsi-common.c|87| <<vhost_scsi_common_start>> vhost_virtqueue_mask(&vsc->dev, vdev, vsc->dev.vq_index + i, false);
+ *   - hw/virtio/vhost-user-fs.c|76| <<vuf_start>> vhost_virtqueue_mask(&fs->vhost_dev, vdev, i, false);
+ *   - hw/virtio/vhost-user-fs.c|150| <<vuf_guest_notifier_mask>> vhost_virtqueue_mask(&fs->vhost_dev, vdev, idx, mask);
+ *   - hw/virtio/vhost-vsock-common.c|59| <<vhost_vsock_common_start>> vhost_virtqueue_mask(&vvc->vhost_dev, vdev, i, false);
+ *   - hw/virtio/vhost-vsock-common.c|104| <<vhost_vsock_common_guest_notifier_mask>> vhost_virtqueue_mask(&vvc->vhost_dev, vdev, idx, mask);
+ *   - hw/virtio/vhost.c|1155| <<vhost_virtqueue_start>> vhost_virtqueue_mask(dev, vdev, idx, false);
+ */
 void vhost_virtqueue_mask(struct vhost_dev *hdev, VirtIODevice *vdev, int n,
                          bool mask)
 {
@@ -1698,6 +1753,16 @@ int vhost_dev_get_inflight(struct vhost_dev *dev, uint16_t queue_size,
 }
 
 /* Host notifiers must be enabled at this point. */
+/*
+ * called by:
+ *   - backends/cryptodev-vhost.c|94| <<cryptodev_vhost_start_one>> r = vhost_dev_start(&crypto->dev, dev);
+ *   - backends/vhost-user.c|88| <<vhost_user_backend_start>> ret = vhost_dev_start(&b->dev, b->vdev);
+ *   - hw/block/vhost-user-blk.c|154| <<vhost_user_blk_start>> ret = vhost_dev_start(&s->dev, vdev);
+ *   - hw/net/vhost_net.c|261| <<vhost_net_start_one>> r = vhost_dev_start(&net->dev, dev);
+ *   - hw/scsi/vhost-scsi-common.c|76| <<vhost_scsi_common_start>> ret = vhost_dev_start(&vsc->dev, vdev);
+ *   - hw/virtio/vhost-user-fs.c|64| <<vuf_start>> ret = vhost_dev_start(&fs->vhost_dev, vdev);
+ *   - hw/virtio/vhost-vsock-common.c|47| <<vhost_vsock_common_start>> ret = vhost_dev_start(&vvc->vhost_dev, vdev);
+ */
 int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev)
 {
     int i, r;
@@ -1724,6 +1789,14 @@ int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev)
         goto fail_mem;
     }
     for (i = 0; i < hdev->nvqs; ++i) {
+        /*
+	 * struct vhost_dev *hdev:
+	 * -> VirtIODevice *vdev;
+	 * -> struct vhost_virtqueue *vqs;
+	 * -> int nvqs;
+	 * // the first virtqueue which would be used by this vhost dev
+	 * -> int vq_index;
+	 */
         r = vhost_virtqueue_start(hdev,
                                   vdev,
                                   hdev->vqs + i,
@@ -1750,6 +1823,9 @@ int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev)
         }
     }
     if (hdev->vhost_ops->vhost_dev_start) {
+        /*
+	 * 似乎只有vhost_vdpa_dev_start()
+	 */
         r = hdev->vhost_ops->vhost_dev_start(hdev, true);
         if (r) {
             goto fail_log;
diff --git a/hw/virtio/virtio-blk-pci.c b/hw/virtio/virtio-blk-pci.c
index 9d5795810..a57720eae 100644
--- a/hw/virtio/virtio-blk-pci.c
+++ b/hw/virtio/virtio-blk-pci.c
@@ -38,6 +38,16 @@ struct VirtIOBlkPCI {
     VirtIOBlock vdev;
 };
 
+/*
+ * virtio-blk的ioeventfd和dataplane的关系
+ *
+ * virtio_bus_start_ioeventfd()
+ * -> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy))
+ *        return -ENOSYS; //k->ioeventfd_enabled = virtio_pci_ioeventfd_enabled()
+ *        virtio_pci_ioeventfd_enabled()会确认ioeventfd是否enabled
+ * -> vdc->start_ioeventfd = virtio_blk_data_plane_start()或virtio_scsi_dataplane_start()或virtio_device_start_ioeventfd_impl()
+ */
+
 static Property virtio_blk_pci_properties[] = {
     DEFINE_PROP_UINT32("class", VirtIOPCIProxy, class_code, 0),
     DEFINE_PROP_BIT("ioeventfd", VirtIOPCIProxy, flags,
diff --git a/hw/virtio/virtio-bus.c b/hw/virtio/virtio-bus.c
index d6332d45c..af43d7814 100644
--- a/hw/virtio/virtio-bus.c
+++ b/hw/virtio/virtio-bus.c
@@ -40,6 +40,10 @@ do { printf("virtio_bus: " fmt , ## __VA_ARGS__); } while (0)
 #endif
 
 /* A VirtIODevice is being plugged */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|3880| <<virtio_device_realize>> virtio_bus_device_plugged(vdev, &err);
+ */
 void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
 {
     DeviceState *qdev = DEVICE(vdev);
@@ -86,6 +90,11 @@ void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
 }
 
 /* Reset the virtio_bus */
+/*
+ * called by:
+ *   - hw/virtio/virtio-mmio.c|591| <<virtio_mmio_reset>> virtio_bus_reset(&proxy->bus);
+ *   - hw/virtio/virtio-pci.c|1874| <<virtio_pci_reset>> virtio_bus_reset(bus);
+ */
 void virtio_bus_reset(VirtioBusState *bus)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -97,6 +106,10 @@ void virtio_bus_reset(VirtioBusState *bus)
 }
 
 /* A VirtIODevice is being unplugged */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|3896| <<virtio_device_unrealize>> virtio_bus_device_unplugged(vdev);
+ */
 void virtio_bus_device_unplugged(VirtIODevice *vdev)
 {
     DeviceState *qdev = DEVICE(vdev);
@@ -113,6 +126,12 @@ void virtio_bus_device_unplugged(VirtIODevice *vdev)
 }
 
 /* Get the device id of the plugged device. */
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|1152| <<virtio_ccw_device_plugged>> sch->id.cu_model = virtio_bus_get_vdev_id(&dev->bus);
+ *   - hw/virtio/virtio-pci.c|1627| <<virtio_pci_device_plugged>> pci_set_word(config + PCI_SUBSYSTEM_ID, virtio_bus_get_vdev_id(bus));
+ *   - hw/virtio/virtio-pci.c|1633| <<virtio_pci_device_plugged>> 0x1040 + virtio_bus_get_vdev_id(bus));
+ */
 uint16_t virtio_bus_get_vdev_id(VirtioBusState *bus)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -121,6 +140,10 @@ uint16_t virtio_bus_get_vdev_id(VirtioBusState *bus)
 }
 
 /* Get the config_len field of the plugged device. */
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1709| <<virtio_pci_device_plugged>> + virtio_bus_get_vdev_config_len(bus);
+ */
 size_t virtio_bus_get_vdev_config_len(VirtioBusState *bus)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -129,6 +152,10 @@ size_t virtio_bus_get_vdev_config_len(VirtioBusState *bus)
 }
 
 /* Get bad features of the plugged device. */
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|310| <<virtio_ioport_write>> val = virtio_bus_get_vdev_bad_features(&proxy->bus);
+ */
 uint32_t virtio_bus_get_vdev_bad_features(VirtioBusState *bus)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -144,6 +171,10 @@ uint32_t virtio_bus_get_vdev_bad_features(VirtioBusState *bus)
 }
 
 /* Get config of the plugged device. */
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|447| <<virtio_ccw_cb>> virtio_bus_get_vdev_config(&dev->bus, vdev->config);
+ */
 void virtio_bus_get_vdev_config(VirtioBusState *bus, uint8_t *config)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -157,6 +188,10 @@ void virtio_bus_get_vdev_config(VirtioBusState *bus, uint8_t *config)
 }
 
 /* Set config of the plugged device. */
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|466| <<virtio_ccw_cb>> virtio_bus_set_vdev_config(&dev->bus, vdev->config);
+ */
 void virtio_bus_set_vdev_config(VirtioBusState *bus, uint8_t *config)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -170,6 +205,10 @@ void virtio_bus_set_vdev_config(VirtioBusState *bus, uint8_t *config)
 }
 
 /* On success, ioeventfd ownership belongs to the caller.  */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|4035| <<virtio_device_grab_ioeventfd>> return virtio_bus_grab_ioeventfd(vbus);
+ */
 int virtio_bus_grab_ioeventfd(VirtioBusState *bus)
 {
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(bus);
@@ -192,6 +231,10 @@ int virtio_bus_grab_ioeventfd(VirtioBusState *bus)
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|4043| <<virtio_device_release_ioeventfd>> virtio_bus_release_ioeventfd(vbus);
+ */
 void virtio_bus_release_ioeventfd(VirtioBusState *bus)
 {
     assert(bus->ioeventfd_grabbed != 0);
@@ -202,6 +245,14 @@ void virtio_bus_release_ioeventfd(VirtioBusState *bus)
     }
 }
 
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|133| <<virtio_ccw_start_ioeventfd>> virtio_bus_start_ioeventfd(&dev->bus);
+ *   - hw/virtio/virtio-bus.c|201| <<virtio_bus_release_ioeventfd>> virtio_bus_start_ioeventfd(bus);
+ *   - hw/virtio/virtio-mmio.c|60| <<virtio_mmio_start_ioeventfd>> virtio_bus_start_ioeventfd(&proxy->bus);
+ *   - hw/virtio/virtio-pci.c|292| <<virtio_pci_start_ioeventfd>> virtio_bus_start_ioeventfd(&proxy->bus);
+ *   - hw/virtio/virtio.c|4001| <<virtio_device_start_ioeventfd>> return virtio_bus_start_ioeventfd(vbus);
+ */
 int virtio_bus_start_ioeventfd(VirtioBusState *bus)
 {
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(bus);
@@ -210,6 +261,9 @@ int virtio_bus_start_ioeventfd(VirtioBusState *bus)
     VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(vdev);
     int r;
 
+    /*
+     * 比如virtio_pci_ioeventfd_enabled()
+     */
     if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
         return -ENOSYS;
     }
@@ -219,16 +273,43 @@ int virtio_bus_start_ioeventfd(VirtioBusState *bus)
 
     /* Only set our notifier if we have ownership.  */
     if (!bus->ioeventfd_grabbed) {
+        /*
+	 * 在以下调用VirtioDeviceClass->start_ioeventfd:
+	 *   - hw/virtio/virtio-bus.c|243| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+	 * 在以下使用VirtioDeviceClass->start_ioeventfd:
+	 *   - hw/block/virtio-blk.c|1330| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start;
+	 *   - hw/scsi/virtio-scsi.c|1082| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+	 *   - hw/virtio/virtio.c|4056| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+	 */
         r = vdc->start_ioeventfd(vdev);
         if (r < 0) {
             error_report("%s: failed. Fallback to userspace (slower).", __func__);
             return r;
         }
     }
+    /*
+     * 在以下设置VirtioBusState->ioeventfd_started:
+     *   - hw/virtio/virtio-bus.c|228| <<virtio_bus_grab_ioeventfd>> bus->ioeventfd_started = true;
+     *   - hw/virtio/virtio-bus.c|243| <<virtio_bus_release_ioeventfd>> bus->ioeventfd_started = false;
+     *   - hw/virtio/virtio-bus.c|279| <<virtio_bus_start_ioeventfd>> bus->ioeventfd_started = true;
+     *   - hw/virtio/virtio-bus.c|305| <<virtio_bus_stop_ioeventfd>> bus->ioeventfd_started = false;
+     * 在以下使用VirtioBusState->ioeventfd_started:
+     *   - hw/virtio/virtio-bus.c|223| <<virtio_bus_grab_ioeventfd>> if (bus->ioeventfd_grabbed == 0 && bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|241| <<virtio_bus_release_ioeventfd>> if (--bus->ioeventfd_grabbed == 0 && bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|267| <<virtio_bus_start_ioeventfd>> if (bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|295| <<virtio_bus_stop_ioeventfd>> if (!bus->ioeventfd_started) {
+     */
     bus->ioeventfd_started = true;
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|138| <<virtio_ccw_stop_ioeventfd>> virtio_bus_stop_ioeventfd(&dev->bus);
+ *   - hw/virtio/virtio-bus.c|198| <<virtio_bus_grab_ioeventfd>> virtio_bus_stop_ioeventfd(bus);
+ *   - hw/virtio/virtio-mmio.c|65| <<virtio_mmio_stop_ioeventfd>> virtio_bus_stop_ioeventfd(&proxy->bus);
+ *   - hw/virtio/virtio-pci.c|297| <<virtio_pci_stop_ioeventfd>> virtio_bus_stop_ioeventfd(&proxy->bus);
+ */
 void virtio_bus_stop_ioeventfd(VirtioBusState *bus)
 {
     VirtIODevice *vdev;
@@ -247,11 +328,31 @@ void virtio_bus_stop_ioeventfd(VirtioBusState *bus)
     bus->ioeventfd_started = false;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|888| <<virtio_blk_dma_restart_cb>> if (!s->bh && !virtio_bus_ioeventfd_enabled(bus)) {
+ *   - hw/virtio/virtio.c|4078| <<virtio_device_ioeventfd_enabled>> return virtio_bus_ioeventfd_enabled(vbus);
+ */
 bool virtio_bus_ioeventfd_enabled(VirtioBusState *bus)
 {
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(bus);
     DeviceState *proxy = DEVICE(BUS(bus)->parent);
 
+    /*
+     * 在以下设置VirtioBusClass->ioeventfd_assign:
+     *   - hw/s390x/virtio-ccw.c|1242| <<virtio_ccw_bus_class_init>> k->ioeventfd_assign = virtio_ccw_ioeventfd_assign;
+     *   - hw/virtio/virtio-mmio.c|780| <<virtio_mmio_bus_class_init>> k->ioeventfd_assign = virtio_mmio_ioeventfd_assign;
+     *   - hw/virtio/virtio-pci.c|2141| <<virtio_pci_bus_class_init>> k->ioeventfd_assign = virtio_pci_ioeventfd_assign;
+     * 在以下使用VirtioBusClass->ioeventfd_assign:
+     *   - hw/block/dataplane/virtio-blk.c|100| <<virtio_blk_data_plane_create>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|37| <<virtio_scsi_dataplane_setup>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|193| <<virtio_bus_grab_ioeventfd>> if (!k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|234| <<virtio_bus_start_ioeventfd>> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
+     *   - hw/virtio/virtio-bus.c|276| <<virtio_bus_ioeventfd_enabled>> return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
+     *   - hw/virtio/virtio-bus.c|292| <<virtio_bus_set_host_notifier>> if (!k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|303| <<virtio_bus_set_host_notifier>> r = k->ioeventfd_assign(proxy, notifier, n, true);
+     *   - hw/virtio/virtio-bus.c|309| <<virtio_bus_set_host_notifier>> k->ioeventfd_assign(proxy, notifier, n, false);
+     */
     return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
 }
 
@@ -259,6 +360,21 @@ bool virtio_bus_ioeventfd_enabled(VirtioBusState *bus)
  * This function switches ioeventfd on/off in the device.
  * The caller must set or clear the handlers for the EventNotifier.
  */
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|207| <<virtio_blk_data_plane_start>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, true);
+ *   - hw/block/dataplane/virtio-blk.c|211| <<virtio_blk_data_plane_start>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/block/dataplane/virtio-blk.c|310| <<virtio_blk_data_plane_stop>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|117| <<virtio_scsi_vring_init>> rc = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), n, true);
+ *   - hw/scsi/virtio-scsi-dataplane.c|197| <<virtio_scsi_dataplane_start>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|236| <<virtio_scsi_dataplane_stop>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/virtio/vhost.c|1445| <<vhost_dev_enable_notifiers>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i,
+ *   - hw/virtio/vhost.c|1456| <<vhost_dev_enable_notifiers>> e = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i,
+ *   - hw/virtio/vhost.c|1480| <<vhost_dev_disable_notifiers>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i,
+ *   - hw/virtio/virtio.c|3953| <<virtio_device_start_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, true);
+ *   - hw/virtio/virtio.c|3982| <<virtio_device_start_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, false);
+ *   - hw/virtio/virtio.c|4017| <<virtio_device_stop_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, false);
+ */
 int virtio_bus_set_host_notifier(VirtioBusState *bus, int n, bool assign)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -279,6 +395,23 @@ int virtio_bus_set_host_notifier(VirtioBusState *bus, int n, bool assign)
                          __func__, strerror(-r), r);
             return r;
         }
+	/*
+	 * 在以下设置VirtioBusClass->ioeventfd_assign:
+	 *   - hw/s390x/virtio-ccw.c|1242| <<virtio_ccw_bus_class_init>> k->ioeventfd_assign = virtio_ccw_ioeventfd_assign;
+	 *   - hw/virtio/virtio-mmio.c|780| <<virtio_mmio_bus_class_init>> k->ioeventfd_assign = virtio_mmio_ioeventfd_assign;
+	 *   - hw/virtio/virtio-pci.c|2141| <<virtio_pci_bus_class_init>> k->ioeventfd_assign = virtio_pci_ioeventfd_assign;
+	 * 在以下使用VirtioBusClass->ioeventfd_assign:
+	 *   - hw/block/dataplane/virtio-blk.c|100| <<virtio_blk_data_plane_create>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+	 *   - hw/scsi/virtio-scsi-dataplane.c|37| <<virtio_scsi_dataplane_setup>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+	 *   - hw/virtio/virtio-bus.c|193| <<virtio_bus_grab_ioeventfd>> if (!k->ioeventfd_assign) {
+	 *   - hw/virtio/virtio-bus.c|234| <<virtio_bus_start_ioeventfd>> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
+	 *   - hw/virtio/virtio-bus.c|276| <<virtio_bus_ioeventfd_enabled>> return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
+	 *   - hw/virtio/virtio-bus.c|292| <<virtio_bus_set_host_notifier>> if (!k->ioeventfd_assign) {
+	 *   - hw/virtio/virtio-bus.c|303| <<virtio_bus_set_host_notifier>> r = k->ioeventfd_assign(proxy, notifier, n, true);
+	 *   - hw/virtio/virtio-bus.c|309| <<virtio_bus_set_host_notifier>> k->ioeventfd_assign(proxy, notifier, n, false);
+	 *
+	 * 比如virtio_pci_ioeventfd_assign(), 就是向kernel注册一个eventfd (把地址和fd绑定)
+	 */
         r = k->ioeventfd_assign(proxy, notifier, n, true);
         if (r < 0) {
             error_report("%s: unable to assign ioeventfd: %d", __func__, r);
@@ -295,6 +428,18 @@ int virtio_bus_set_host_notifier(VirtioBusState *bus, int n, bool assign)
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|212| <<virtio_blk_data_plane_start>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/block/dataplane/virtio-blk.c|311| <<virtio_blk_data_plane_stop>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/scsi/virtio-scsi-dataplane.c|198| <<virtio_scsi_dataplane_start>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/scsi/virtio-scsi-dataplane.c|237| <<virtio_scsi_dataplane_stop>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/virtio/vhost.c|1462| <<vhost_dev_enable_notifiers>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i);
+ *   - hw/virtio/vhost.c|1486| <<vhost_dev_disable_notifiers>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i);
+ *   - hw/virtio/virtio-bus.c|306| <<virtio_bus_set_host_notifier>> virtio_bus_cleanup_host_notifier(bus, n);
+ *   - hw/virtio/virtio.c|3991| <<virtio_device_start_ioeventfd_impl>> virtio_bus_cleanup_host_notifier(qbus, i);
+ *   - hw/virtio/virtio.c|4026| <<virtio_device_stop_ioeventfd_impl>> virtio_bus_cleanup_host_notifier(qbus, n);
+ */
 void virtio_bus_cleanup_host_notifier(VirtioBusState *bus, int n)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -308,6 +453,10 @@ void virtio_bus_cleanup_host_notifier(VirtioBusState *bus, int n)
     event_notifier_cleanup(notifier);
 }
 
+/*
+ * 在以下使用virtio_bus_get_dev_path():
+ *   - hw/virtio/virtio-bus.c|347| <<virtio_bus_class_init>> bus_class->get_dev_path = virtio_bus_get_dev_path;
+ */
 static char *virtio_bus_get_dev_path(DeviceState *dev)
 {
     BusState *bus = qdev_get_parent_bus(dev);
@@ -315,11 +464,18 @@ static char *virtio_bus_get_dev_path(DeviceState *dev)
     return qdev_get_dev_path(proxy);
 }
 
+/*
+ * 在以下使用virtio_bus_get_fw_dev_path():
+ *   - hw/virtio/virtio-bus.c|348| <<virtio_bus_class_init>> bus_class->get_fw_dev_path = virtio_bus_get_fw_dev_path;
+ */
 static char *virtio_bus_get_fw_dev_path(DeviceState *dev)
 {
     return NULL;
 }
 
+/*
+ * TypeInfo virtio_bus_info.class_init = virtio_bus_class_init()
+ */
 static void virtio_bus_class_init(ObjectClass *klass, void *data)
 {
     BusClass *bus_class = BUS_CLASS(klass);
@@ -331,6 +487,7 @@ static const TypeInfo virtio_bus_info = {
     .name = TYPE_VIRTIO_BUS,
     .parent = TYPE_BUS,
     .instance_size = sizeof(VirtioBusState),
+    /* !!! abstract = true !!! */
     .abstract = true,
     .class_size = sizeof(VirtioBusClass),
     .class_init = virtio_bus_class_init
diff --git a/hw/virtio/virtio-pci.c b/hw/virtio/virtio-pci.c
index 36524a572..4020a319b 100644
--- a/hw/virtio/virtio-pci.c
+++ b/hw/virtio/virtio-pci.c
@@ -64,6 +64,10 @@ static inline VirtIOPCIProxy *to_virtio_pci_proxy_fast(DeviceState *d)
     return container_of(d, VirtIOPCIProxy, pci_dev.qdev);
 }
 
+/*
+ * 在以下使用virtio_pci_notify():
+ *   - hw/virtio/virtio-pci.c|2120| <<virtio_pci_bus_class_init>> k->notify = virtio_pci_notify;
+ */
 static void virtio_pci_notify(DeviceState *d, uint16_t vector)
 {
     VirtIOPCIProxy *proxy = to_virtio_pci_proxy_fast(d);
@@ -211,6 +215,10 @@ static int virtio_pci_load_queue(DeviceState *d, int n, QEMUFile *f)
     return 0;
 }
 
+/*
+ * 在以下使用virtio_pci_ioeventfd_enabled():
+ *   - hw/virtio/virtio-pci.c|2146| <<virtio_pci_bus_class_init>> k->ioeventfd_enabled = virtio_pci_ioeventfd_enabled;
+ */
 static bool virtio_pci_ioeventfd_enabled(DeviceState *d)
 {
     VirtIOPCIProxy *proxy = to_virtio_pci_proxy(d);
@@ -283,6 +291,12 @@ static int virtio_pci_ioeventfd_assign(DeviceState *d, EventNotifier *notifier,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|339| <<virtio_ioport_write>> virtio_pci_start_ioeventfd(proxy);
+ *   - hw/virtio/virtio-pci.c|1090| <<virtio_pci_vmstate_change>> virtio_pci_start_ioeventfd(proxy);
+ *   - hw/virtio/virtio-pci.c|1265| <<virtio_pci_common_write>> virtio_pci_start_ioeventfd(proxy);
+ */
 static void virtio_pci_start_ioeventfd(VirtIOPCIProxy *proxy)
 {
     virtio_bus_start_ioeventfd(&proxy->bus);
@@ -828,6 +842,11 @@ static int virtio_pci_vq_vector_unmask(VirtIOPCIProxy *proxy,
     return ret;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|892| <<virtio_pci_vector_unmask>> virtio_pci_vq_vector_mask(proxy, index, vector);
+ *   - hw/virtio/virtio-pci.c|913| <<virtio_pci_vector_mask>> virtio_pci_vq_vector_mask(proxy, index, vector);
+ */
 static void virtio_pci_vq_vector_mask(VirtIOPCIProxy *proxy,
                                              unsigned int queue_no,
                                              unsigned int vector)
@@ -883,6 +902,15 @@ undo:
     return ret;
 }
 
+/*
+ * 在以下使用virtio_pci_vector_mask():
+ *   - hw/virtio/virtio-pci.c|1049| <<virtio_pci_set_guest_notifiers>> virtio_pci_vector_mask,
+ *
+ * 1047         r = msix_set_vector_notifiers(&proxy->pci_dev,
+ * 1048                                       virtio_pci_vector_unmask,
+ * 1049                                       virtio_pci_vector_mask,
+ * 1050                                       virtio_pci_vector_poll);
+ */
 static void virtio_pci_vector_mask(PCIDevice *dev, unsigned vector)
 {
     VirtIOPCIProxy *proxy = container_of(dev, VirtIOPCIProxy, pci_dev);
@@ -935,6 +963,11 @@ static void virtio_pci_vector_poll(PCIDevice *dev,
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1020| <<virtio_pci_set_guest_notifiers>> r = virtio_pci_set_guest_notifier(d, n, assign, with_irqfd);
+ *   - hw/virtio/virtio-pci.c|1058| <<virtio_pci_set_guest_notifiers>> virtio_pci_set_guest_notifier(d, n, !assign, with_irqfd);
+ */
 static int virtio_pci_set_guest_notifier(DeviceState *d, int n, bool assign,
                                          bool with_irqfd)
 {
@@ -970,6 +1003,37 @@ static bool virtio_pci_query_guest_notifiers(DeviceState *d)
     return msix_enabled(&proxy->pci_dev);
 }
 
+/*
+ * called by:
+ *   - backends/cryptodev-vhost.c|235| <<cryptodev_vhost_start>> e = k->set_guest_notifiers(qbus->parent, total_queues, false);
+ *   - backends/cryptodev-vhost.c|262| <<cryptodev_vhost_stop>> r = k->set_guest_notifiers(qbus->parent, total_queues, false);
+ *   - backends/vhost-user.c|81| <<vhost_user_backend_start>> ret = k->set_guest_notifiers(qbus->parent, b->dev.nvqs, true);
+ *   - backends/vhost-user.c|107| <<vhost_user_backend_start>> k->set_guest_notifiers(qbus->parent, b->dev.nvqs, false);
+ *   - backends/vhost-user.c|126| <<vhost_user_backend_stop>> ret = k->set_guest_notifiers(qbus->parent,
+ *   - hw/block/dataplane/virtio-blk.c|214| <<virtio_blk_data_plane_start>> r = k->set_guest_notifiers(qbus->parent, nvqs, true);
+ *   - hw/block/dataplane/virtio-blk.c|342| <<virtio_blk_data_plane_stop>> k->set_guest_notifiers(qbus->parent, nvqs, false);
+ *   - hw/block/vhost-user-blk.c|126| <<vhost_user_blk_start>> ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, true);
+ *   - hw/block/vhost-user-blk.c|172| <<vhost_user_blk_start>> k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);
+ *   - hw/block/vhost-user-blk.c|196| <<vhost_user_blk_stop>> ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);
+ *   - hw/net/vhost_net.c|362| <<vhost_net_start>> r = k->set_guest_notifiers(qbus->parent, total_queues * 2, true);
+ *   - hw/net/vhost_net.c|393| <<vhost_net_start>> e = k->set_guest_notifiers(qbus->parent, total_queues * 2, false);
+ *   - hw/net/vhost_net.c|414| <<vhost_net_stop>> r = k->set_guest_notifiers(qbus->parent, total_queues * 2, false);
+ *   - hw/scsi/vhost-scsi-common.c|52| <<vhost_scsi_common_start>> ret = k->set_guest_notifiers(qbus->parent, vsc->dev.nvqs, true);
+ *   - hw/scsi/vhost-scsi-common.c|96| <<vhost_scsi_common_start>> k->set_guest_notifiers(qbus->parent, vsc->dev.nvqs, false);
+ *   - hw/scsi/vhost-scsi-common.c|112| <<vhost_scsi_common_stop>> ret = k->set_guest_notifiers(qbus->parent, vsc->dev.nvqs, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|168| <<virtio_scsi_dataplane_start>> rc = k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, true);
+ *   - hw/scsi/virtio-scsi-dataplane.c|206| <<virtio_scsi_dataplane_start>> k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|247| <<virtio_scsi_dataplane_stop>> k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, false);
+ *   - hw/virtio/vhost-user-fs.c|57| <<vuf_start>> ret = k->set_guest_notifiers(qbus->parent, fs->vhost_dev.nvqs, true);
+ *   - hw/virtio/vhost-user-fs.c|82| <<vuf_start>> k->set_guest_notifiers(qbus->parent, fs->vhost_dev.nvqs, false);
+ *   - hw/virtio/vhost-user-fs.c|100| <<vuf_stop>> ret = k->set_guest_notifiers(qbus->parent, fs->vhost_dev.nvqs, false);
+ *   - hw/virtio/vhost-vsock-common.c|40| <<vhost_vsock_common_start>> ret = k->set_guest_notifiers(qbus->parent, vvc->vhost_dev.nvqs, true);
+ *   - hw/virtio/vhost-vsock-common.c|65| <<vhost_vsock_common_start>> k->set_guest_notifiers(qbus->parent, vvc->vhost_dev.nvqs, false);
+ *   - hw/virtio/vhost-vsock-common.c|84| <<vhost_vsock_common_stop>> ret = k->set_guest_notifiers(qbus->parent, vvc->vhost_dev.nvqs, false);
+ *
+ * 在以下使用virtio_pci_set_guest_notifiers():
+ *   - hw/virtio/virtio-pci.c|2172| <<virtio_pci_bus_class_init>> k->set_guest_notifiers = virtio_pci_set_guest_notifiers;
+ */
 static int virtio_pci_set_guest_notifiers(DeviceState *d, int nvqs, bool assign)
 {
     VirtIOPCIProxy *proxy = to_virtio_pci_proxy(d);
@@ -1331,6 +1395,10 @@ static uint64_t virtio_pci_notify_read(void *opaque, hwaddr addr,
     return 0;
 }
 
+/*
+ * 在以下使用virtio_pci_notify_write():
+ *   - hw/virtio/virtio-pci.c|1474| <<virtio_pci_modern_regions_init>> .write = virtio_pci_notify_write,
+ */
 static void virtio_pci_notify_write(void *opaque, hwaddr addr,
                                     uint64_t val, unsigned size)
 {
@@ -2102,6 +2170,12 @@ unsigned virtio_pci_optimal_num_queues(unsigned fixed_queues)
 
 /* virtio-pci-bus */
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1865| <<virtio_pci_realize>> virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);
+ *
+ * 比如为virtio-blk-pci设备创建一个local的virtio bus, 用来挂virtio-blk
+ */
 static void virtio_pci_bus_new(VirtioBusState *bus, size_t bus_size,
                                VirtIOPCIProxy *dev)
 {
diff --git a/hw/virtio/virtio-scsi-pci.c b/hw/virtio/virtio-scsi-pci.c
index 97fab7423..d5375493d 100644
--- a/hw/virtio/virtio-scsi-pci.c
+++ b/hw/virtio/virtio-scsi-pci.c
@@ -35,6 +35,10 @@ struct VirtIOSCSIPCI {
     VirtIOSCSI vdev;
 };
 
+/*
+ * 在以下使用virtio_scsi_pci_properties:
+ *   - hw/virtio/virtio-scsi-pci.c|84| <<virtio_scsi_pci_class_init>> device_class_set_props(dc, virtio_scsi_pci_properties);
+ */
 static Property virtio_scsi_pci_properties[] = {
     DEFINE_PROP_BIT("ioeventfd", VirtIOPCIProxy, flags,
                     VIRTIO_PCI_FLAG_USE_IOEVENTFD_BIT, true),
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index ceb58fda6..d7ad2dc11 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -120,16 +120,73 @@ struct VirtQueue
     /* Notification enabled? */
     bool notification;
 
+    /*
+     * 在以下使用VirtQueue->queue_index:
+     *   - 
+     */
     uint16_t queue_index;
 
     unsigned int inuse;
 
     uint16_t vector;
+    /*
+     * 在以下设置VirtQueue->handle_output:
+     *   - hw/virtio/virtio.c|2471| <<virtio_add_queue>> vdev->vq[i].handle_output = handle_output;
+     *   - hw/virtio/virtio.c|2483| <<virtio_delete_queue>> vq->handle_output = NULL;
+     * 在以下使用VirtQueue->handle_output:
+     *   - hw/virtio/virtio.c|2382| <<virtio_queue_notify_vq>> if (vq->vring.desc && vq->handle_output) {
+     *   - hw/virtio/virtio.c|2390| <<virtio_queue_notify_vq>> vq->handle_output(vdev, vq);
+     *   - hw/virtio/virtio.c|2423| <<virtio_queue_notify>> } else if (vq->handle_output) {
+     *   - hw/virtio/virtio.c|2424| <<virtio_queue_notify>> vq->handle_output(vdev, vq);
+     */
     VirtIOHandleOutput handle_output;
+    /*
+     * 在以下设置VirtQueue->handle_aio_output:
+     *   - hw/virtio/virtio.c|2472| <<virtio_add_queue>> vdev->vq[i].handle_aio_output = NULL;
+     *   - hw/virtio/virtio.c|2484| <<virtio_delete_queue>> vq->handle_aio_output = NULL;
+     *   - hw/virtio/virtio.c|3781| <<virtio_queue_aio_set_host_notifier_handler>> vq->handle_aio_output = handle_output;
+     *   - hw/virtio/virtio.c|3793| <<virtio_queue_aio_set_host_notifier_handler>> vq->handle_aio_output = NULL;
+     * 在以下使用VirtQueue->handle_aio_output:
+     *   - hw/virtio/virtio.c|2366| <<virtio_queue_notify_aio_vq>> if (vq->vring.desc && vq->handle_aio_output) {
+     *   - hw/virtio/virtio.c|2370| <<virtio_queue_notify_aio_vq>> ret = vq->handle_aio_output(vdev, vq);
+     */
     VirtIOHandleAIOOutput handle_aio_output;
     VirtIODevice *vdev;
+    /*
+     * 在以下使用VirtQueue->guest_notifier:
+     *   - hw/virtio/virtio.c|2560| <<virtio_notify_irqfd>> event_notifier_set(&vq->guest_notifier);
+     *   - hw/virtio/virtio.c|3563| <<virtio_queue_guest_notifier_read>> VirtQueue *vq = container_of(n, VirtQueue, guest_notifier);
+     *   - hw/virtio/virtio.c|3573| <<virtio_queue_set_guest_notifier_fd_handler>> event_notifier_set_handler(&vq->guest_notifier,
+     *   - hw/virtio/virtio.c|3576| <<virtio_queue_set_guest_notifier_fd_handler>> event_notifier_set_handler(&vq->guest_notifier, NULL);
+     *   - hw/virtio/virtio.c|3581| <<virtio_queue_set_guest_notifier_fd_handler>> virtio_queue_guest_notifier_read(&vq->guest_notifier);
+     *   - hw/virtio/virtio.c|3587| <<virtio_queue_get_guest_notifier>> return &vq->guest_notifier;
+     */
     EventNotifier guest_notifier;
+    /*
+     * 在以下使用VirtQueue->host_notifier:
+     *   - hw/virtio/virtio.c|2381| <<virtio_queue_notify>> event_notifier_set(&vq->host_notifier);
+     *   - hw/virtio/virtio.c|3615| <<virtio_queue_host_notifier_aio_read>> VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
+     *   - hw/virtio/virtio.c|3623| <<virtio_queue_host_notifier_aio_poll_begin>> VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
+     *   - hw/virtio/virtio.c|3631| <<virtio_queue_host_notifier_aio_poll>> VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
+     *   - hw/virtio/virtio.c|3642| <<virtio_queue_host_notifier_aio_poll_end>> VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
+     *   - hw/virtio/virtio.c|3653| <<virtio_queue_aio_set_host_notifier_handler>> aio_set_event_notifier(ctx, &vq->host_notifier, true,
+     *   - hw/virtio/virtio.c|3656| <<virtio_queue_aio_set_host_notifier_handler>> aio_set_event_notifier_poll(ctx, &vq->host_notifier,
+     *   - hw/virtio/virtio.c|3660| <<virtio_queue_aio_set_host_notifier_handler>> aio_set_event_notifier(ctx, &vq->host_notifier, true, NULL, NULL);
+     *   - hw/virtio/virtio.c|3663| <<virtio_queue_aio_set_host_notifier_handler>> virtio_queue_host_notifier_aio_read(&vq->host_notifier);
+     *   - hw/virtio/virtio.c|3670| <<virtio_queue_host_notifier_read>> VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
+     *   - hw/virtio/virtio.c|3678| <<virtio_queue_get_host_notifier>> return &vq->host_notifier;
+     *   - hw/virtio/virtio.c|3829| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier,
+     *   - hw/virtio/virtio.c|3839| <<virtio_device_start_ioeventfd_impl>> event_notifier_set(&vq->host_notifier);
+     *   - hw/virtio/virtio.c|3852| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier, NULL);
+     *   - hw/virtio/virtio.c|3887| <<virtio_device_stop_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier, NULL);
+     */
     EventNotifier host_notifier;
+    /*
+     * 在以下使用VirtQueue->host_notifier_enabled:
+     *   - hw/virtio/virtio.c|2380| <<virtio_queue_notify>> if (vq->host_notifier_enabled) {
+     *   - hw/virtio/virtio.c|3354| <<virtio_init>> vdev->vq[i].host_notifier_enabled = false;
+     *   - hw/virtio/virtio.c|3683| <<virtio_queue_set_host_notifier_enabled>> vq->host_notifier_enabled = enabled;
+     */
     bool host_notifier_enabled;
     QLIST_ENTRY(VirtQueue) node;
 };
@@ -1898,6 +1955,14 @@ void qemu_put_virtqueue_element(VirtIODevice *vdev, QEMUFile *f,
 }
 
 /* virtio device */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1950| <<virtio_update_irq>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ *   - hw/virtio/virtio.c|2046| <<virtio_reset>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|2618| <<virtio_irq>> virtio_notify_vector(vq->vdev, vq->vector);
+ *   - hw/virtio/virtio.c|2693| <<virtio_notify_config>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|3195| <<virtio_load>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ */
 static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
@@ -1907,6 +1972,9 @@ static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)
         return;
     }
 
+    /*
+     * 比如virtio_pci_notify()
+     */
     if (k->notify) {
         k->notify(qbus->parent, vector);
     }
@@ -2333,6 +2401,10 @@ static bool virtio_queue_notify_aio_vq(VirtQueue *vq)
     return ret;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|3821| <<virtio_queue_host_notifier_read>> virtio_queue_notify_vq(vq);
+ */
 static void virtio_queue_notify_vq(VirtQueue *vq)
 {
     if (vq->vring.desc && vq->handle_output) {
@@ -2351,6 +2423,14 @@ static void virtio_queue_notify_vq(VirtQueue *vq)
     }
 }
 
+/*
+ * called by:
+ *   - hw/s390x/s390-virtio-ccw.c|137| <<virtio_ccw_hcall_notify>> virtio_queue_notify(virtio_ccw_get_vdev(sch), queue);
+ *   - hw/virtio/virtio-mmio.c|369| <<virtio_mmio_write>> virtio_queue_notify(vdev, value);
+ *   - hw/virtio/virtio-pci.c|324| <<virtio_ioport_write>> virtio_queue_notify(vdev, val);
+ *   - hw/virtio/virtio-pci.c|1343| <<virtio_pci_notify_write>> virtio_queue_notify(vdev, queue);
+ *   - hw/virtio/virtio-pci.c|1356| <<virtio_pci_notify_write_pio>> virtio_queue_notify(vdev, queue);
+ */
 void virtio_queue_notify(VirtIODevice *vdev, int n)
 {
     VirtQueue *vq = &vdev->vq[n];
@@ -2360,6 +2440,12 @@ void virtio_queue_notify(VirtIODevice *vdev, int n)
     }
 
     trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
+    /*
+     * 在以下使用VirtQueue->host_notifier_enabled:
+     *   - hw/virtio/virtio.c|2380| <<virtio_queue_notify>> if (vq->host_notifier_enabled) {
+     *   - hw/virtio/virtio.c|3354| <<virtio_init>> vdev->vq[i].host_notifier_enabled = false;
+     *   - hw/virtio/virtio.c|3683| <<virtio_queue_set_host_notifier_enabled>> vq->host_notifier_enabled = enabled;
+     */
     if (vq->host_notifier_enabled) {
         event_notifier_set(&vq->host_notifier);
     } else if (vq->handle_output) {
@@ -2377,6 +2463,16 @@ uint16_t virtio_queue_vector(VirtIODevice *vdev, int n)
         VIRTIO_NO_VECTOR;
 }
 
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|227| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, VIRTIO_NO_VECTOR);
+ *   - hw/s390x/virtio-ccw.c|241| <<virtio_ccw_set_vqs>> virtio_queue_set_vector(vdev, index, index);
+ *   - hw/s390x/virtio-ccw.c|1083| <<virtio_ccw_load_queue>> virtio_queue_set_vector(vdev, n , vector);
+ *   - hw/virtio/virtio-pci.c|210| <<virtio_pci_load_queue>> virtio_queue_set_vector(vdev, n, vector);
+ *   - hw/virtio/virtio-pci.c|379| <<virtio_ioport_write>> virtio_queue_set_vector(vdev, vdev->queue_sel, val);
+ *   - hw/virtio/virtio-pci.c|1350| <<virtio_pci_common_write>> virtio_queue_set_vector(vdev, vdev->queue_sel, val);
+ *   - hw/virtio/virtio.c|2093| <<virtio_reset>> virtio_queue_set_vector(vdev, i, VIRTIO_NO_VECTOR);
+ */
 void virtio_queue_set_vector(VirtIODevice *vdev, int n, uint16_t vector)
 {
     VirtQueue *vq = &vdev->vq[n];
@@ -2394,6 +2490,19 @@ void virtio_queue_set_vector(VirtIODevice *vdev, int n, uint16_t vector)
     }
 }
 
+/*
+ * 部分使用virtio_add_queue()的例子:
+ *   - hw/block/vhost-user-blk.c|464| <<vhost_user_blk_device_realize>> s->virtqs[i] = virtio_add_queue(vdev, s->queue_size, vhost_user_blk_handle_output);
+ *   - hw/block/virtio-blk.c|1282| <<virtio_blk_device_realize>> virtio_add_queue(vdev, conf->queue_size, virtio_blk_handle_output);
+ *   - hw/net/virtio-net.c|2639| <<virtio_net_add_queue>> n->vqs[index].rx_vq = virtio_add_queue(vdev, n->net_conf.rx_queue_size, virtio_net_handle_rx);
+ *   - hw/net/virtio-net.c|2644| <<virtio_net_add_queue>> virtio_add_queue(vdev, n->net_conf.tx_queue_size, virtio_net_handle_tx_timer);
+ *   - hw/net/virtio-net.c|2651| <<virtio_net_add_queue>> virtio_add_queue(vdev, n->net_conf.tx_queue_size, virtio_net_handle_tx_bh);
+ *   - hw/net/virtio-net.c|2713| <<virtio_net_change_num_queues>> n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
+ *   - hw/net/virtio-net.c|3362| <<virtio_net_device_realize>> n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
+ *   - hw/scsi/virtio-scsi.c|975| <<virtio_scsi_common_realize>> s->ctrl_vq = virtio_add_queue(vdev, s->conf.virtqueue_size, ctrl);
+ *   - hw/scsi/virtio-scsi.c|976| <<virtio_scsi_common_realize>> s->event_vq = virtio_add_queue(vdev, s->conf.virtqueue_size, evt);
+ *   - hw/scsi/virtio-scsi.c|978| <<virtio_scsi_common_realize>> s->cmd_vqs[i] = virtio_add_queue(vdev, s->conf.virtqueue_size, cmd);
+ */
 VirtQueue *virtio_add_queue(VirtIODevice *vdev, int queue_size,
                             VirtIOHandleOutput handle_output)
 {
@@ -2438,6 +2547,12 @@ void virtio_del_queue(VirtIODevice *vdev, int n)
     virtio_delete_queue(&vdev->vq[n]);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|2559| <<virtio_notify_irqfd>> virtio_set_isr(vq->vdev, 0x1);
+ *   - hw/virtio/virtio.c|2570| <<virtio_irq>> virtio_set_isr(vq->vdev, 0x1);
+ *   - hw/virtio/virtio.c|2644| <<virtio_notify_config>> virtio_set_isr(vdev, 0x3);
+ */
 static void virtio_set_isr(VirtIODevice *vdev, int value)
 {
     uint8_t old = qatomic_read(&vdev->isr);
@@ -2516,6 +2631,11 @@ static bool virtio_packed_should_notify(VirtIODevice *vdev, VirtQueue *vq)
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|2584| <<virtio_notify_irqfd>> if (!virtio_should_notify(vdev, vq)) {
+ *   - hw/virtio/virtio.c|2659| <<virtio_notify>> if (!virtio_should_notify(vdev, vq)) {
+ */
 static bool virtio_should_notify(VirtIODevice *vdev, VirtQueue *vq)
 {
     if (virtio_vdev_has_feature(vdev, VIRTIO_F_RING_PACKED)) {
@@ -2525,6 +2645,12 @@ static bool virtio_should_notify(VirtIODevice *vdev, VirtQueue *vq)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|55| <<virtio_blk_data_plane_notify>> virtio_notify_irqfd(s->vdev, vq);
+ *   - hw/block/dataplane/virtio-blk.c|76| <<notify_guest_bh>> virtio_notify_irqfd(s->vdev, vq);
+ *   - hw/scsi/virtio-scsi.c|76| <<virtio_scsi_complete_req>> virtio_notify_irqfd(vdev, vq);
+ */
 void virtio_notify_irqfd(VirtIODevice *vdev, VirtQueue *vq)
 {
     WITH_RCU_READ_LOCK_GUARD() {
@@ -2551,15 +2677,64 @@ void virtio_notify_irqfd(VirtIODevice *vdev, VirtQueue *vq)
      * to an atomic operation.
      */
     virtio_set_isr(vq->vdev, 0x1);
+    /*
+     * 在以下使用VirtQueue->guest_notifier:
+     *   - hw/virtio/virtio.c|2560| <<virtio_notify_irqfd>> event_notifier_set(&vq->guest_notifier);
+     *   - hw/virtio/virtio.c|3563| <<virtio_queue_guest_notifier_read>> VirtQueue *vq = container_of(n, VirtQueue, guest_notifier);
+     *   - hw/virtio/virtio.c|3573| <<virtio_queue_set_guest_notifier_fd_handler>> event_notifier_set_handler(&vq->guest_notifier,
+     *   - hw/virtio/virtio.c|3576| <<virtio_queue_set_guest_notifier_fd_handler>> event_notifier_set_handler(&vq->guest_notifier, NULL);
+     *   - hw/virtio/virtio.c|3581| <<virtio_queue_set_guest_notifier_fd_handler>> virtio_queue_guest_notifier_read(&vq->guest_notifier);
+     *   - hw/virtio/virtio.c|3587| <<virtio_queue_get_guest_notifier>> return &vq->guest_notifier;
+     */
     event_notifier_set(&vq->guest_notifier);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|2607| <<virtio_notify>> virtio_irq(vq);
+ *   - hw/virtio/virtio.c|3536| <<virtio_queue_guest_notifier_read>> virtio_irq(vq);
+ */
 static void virtio_irq(VirtQueue *vq)
 {
     virtio_set_isr(vq->vdev, 0x1);
     virtio_notify_vector(vq->vdev, vq->vector);
 }
 
+/*
+ * called by:
+ *   - hw/9pfs/virtio-9p-device.c|38| <<virtio_9p_push_and_notify>> virtio_notify(VIRTIO_DEVICE(v), v->vq);
+ *   - hw/block/virtio-blk.c|89| <<virtio_blk_req_complete>> virtio_notify(vdev, req->vq);
+ *   - hw/char/virtio-serial-bus.c|130| <<write_to_port>> virtio_notify(VIRTIO_DEVICE(port->vser), vq);
+ *   - hw/char/virtio-serial-bus.c|149| <<discard_vq_data>> virtio_notify(vdev, vq);
+ *   - hw/char/virtio-serial-bus.c|212| <<do_flush_queued_data>> virtio_notify(vdev, vq);
+ *   - hw/char/virtio-serial-bus.c|244| <<send_control_msg>> virtio_notify(VIRTIO_DEVICE(vser), vq);
+ *   - hw/char/virtio-serial-bus.c|496| <<control_out>> virtio_notify(vdev, vq);
+ *   - hw/display/virtio-gpu.c|181| <<virtio_gpu_ctrl_response>> virtio_notify(VIRTIO_DEVICE(g), cmd->vq);
+ *   - hw/display/virtio-gpu.c|928| <<virtio_gpu_handle_cursor>> virtio_notify(vdev, vq);
+ *   - hw/input/virtio-input.c|68| <<virtio_input_send>> virtio_notify(VIRTIO_DEVICE(vinput), vinput->evt);
+ *   - hw/input/virtio-input.c|100| <<virtio_input_handle_sts>> virtio_notify(vdev, vinput->sts);
+ *   - hw/net/virtio-net.c|345| <<virtio_net_drop_tx_queue_data>> virtio_notify(vdev, vq);
+ *   - hw/net/virtio-net.c|1394| <<virtio_net_handle_ctrl>> virtio_notify(vdev, vq);
+ *   - hw/net/virtio-net.c|1774| <<virtio_net_receive_rcu>> virtio_notify(vdev, q->rx_vq);
+ *   - hw/net/virtio-net.c|2401| <<virtio_net_tx_complete>> virtio_notify(vdev, q->tx_vq);
+ *   - hw/net/virtio-net.c|2496| <<virtio_net_flush_tx>> virtio_notify(vdev, q->tx_vq);
+ *   - hw/scsi/virtio-scsi.c|78| <<virtio_scsi_complete_req>> virtio_notify(vdev, vq);
+ *   - hw/virtio/vhost-vsock-common.c|142| <<vhost_vsock_common_send_transport_reset>> virtio_notify(VIRTIO_DEVICE(vvc), vq);
+ *   - hw/virtio/virtio-balloon.c|230| <<balloon_stats_poll_cb>> virtio_notify(vdev, s->svq);
+ *   - hw/virtio/virtio-balloon.c|379| <<virtio_balloon_handle_report>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-balloon.c|437| <<virtio_balloon_handle_output>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-balloon.c|459| <<virtio_balloon_receive_stats>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-balloon.c|568| <<virtio_ballloon_get_free_page_hints>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-crypto.c|291| <<virtio_crypto_handle_ctrl>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-crypto.c|307| <<virtio_crypto_handle_ctrl>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-crypto.c|323| <<virtio_crypto_handle_ctrl>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-crypto.c|411| <<virtio_crypto_req_complete>> virtio_notify(vdev, req->vq);
+ *   - hw/virtio/virtio-iommu.c|642| <<virtio_iommu_handle_command>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-iommu.c|685| <<virtio_iommu_report_fault>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-mem.c|187| <<virtio_mem_send_response>> virtio_notify(vdev, vq);
+ *   - hw/virtio/virtio-pmem.c|61| <<done_cb>> virtio_notify((VirtIODevice *)req_data->pmem, req_data->pmem->rq_vq);
+ *   - hw/virtio/virtio-rng.c|85| <<chr_read>> virtio_notify(vdev, vrng->vq);
+ */
 void virtio_notify(VirtIODevice *vdev, VirtQueue *vq)
 {
     WITH_RCU_READ_LOCK_GUARD() {
@@ -2569,9 +2744,32 @@ void virtio_notify(VirtIODevice *vdev, VirtQueue *vq)
     }
 
     trace_virtio_notify(vdev, vq);
+    /*
+     * called by:
+     *   - hw/virtio/virtio.c|2607| <<virtio_notify>> virtio_irq(vq);
+     *   - hw/virtio/virtio.c|3536| <<virtio_queue_guest_notifier_read>> virtio_irq(vq);
+     */
     virtio_irq(vq);
 }
 
+/*
+ * called by:
+ *   - hw/block/vhost-user-blk.c|98| <<vhost_user_blk_handle_config_change>> virtio_notify_config(dev->vdev);
+ *   - hw/block/virtio-blk.c|1122| <<virtio_resize_cb>> virtio_notify_config(vdev);
+ *   - hw/char/virtio-serial-bus.c|1006| <<virtser_port_device_plug>> virtio_notify_config(VIRTIO_DEVICE(hotplug_dev));
+ *   - hw/display/virtio-gpu-base.c|70| <<virtio_gpu_notify_event>> virtio_notify_config(&g->parent_obj);
+ *   - hw/input/vhost-user-input.c|77| <<vhost_input_set_config>> virtio_notify_config(vdev);
+ *   - hw/input/virtio-input.c|183| <<virtio_input_set_config>> virtio_notify_config(vdev);
+ *   - hw/net/virtio-net.c|198| <<virtio_net_announce_notify>> virtio_notify_config(vdev);
+ *   - hw/net/virtio-net.c|418| <<virtio_net_set_link_status>> virtio_notify_config(vdev);
+ *   - hw/virtio/vhost-user-vsock.c|43| <<vuv_handle_config_change>> virtio_notify_config(dev->vdev);
+ *   - hw/virtio/virtio-balloon.c|607| <<virtio_balloon_free_page_start>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-balloon.c|627| <<virtio_balloon_free_page_stop>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-balloon.c|640| <<virtio_balloon_free_page_done>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-balloon.c|823| <<virtio_balloon_to_target>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-mem.c|819| <<virtio_mem_set_requested_size>> virtio_notify_config(VIRTIO_DEVICE(vmem));
+ *   - hw/virtio/virtio.c|3663| <<virtio_error>> virtio_notify_config(vdev);
+ */
 void virtio_notify_config(VirtIODevice *vdev)
 {
     if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK))
@@ -3226,6 +3424,50 @@ static void virtio_vmstate_change(void *opaque, int running, RunState state)
     }
 }
 
+/*
+ * called by:
+ *   - hw/display/vhost-user-gpu-pci.c|31| <<vhost_user_gpu_pci_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/display/vhost-user-vga.c|32| <<vhost_user_vga_inst_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/display/virtio-gpu-pci.c|82| <<virtio_gpu_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/display/virtio-vga.c|239| <<virtio_vga_inst_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/vhost-user-fs-ccw.c|48| <<vhost_user_fs_ccw_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/vhost-vsock-ccw.c|46| <<vhost_vsock_ccw_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-9p.c|31| <<virtio_ccw_9p_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-balloon.c|31| <<virtio_ccw_balloon_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-blk.c|31| <<virtio_ccw_blk_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-crypto.c|34| <<virtio_ccw_crypto_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-gpu.c|32| <<virtio_ccw_gpu_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-input.c|50| <<virtio_ccw_keyboard_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-input.c|60| <<virtio_ccw_mouse_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-input.c|70| <<virtio_ccw_tablet_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-net.c|34| <<virtio_ccw_net_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-rng.c|33| <<virtio_ccw_rng_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-scsi.c|43| <<virtio_ccw_scsi_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-scsi.c|87| <<vhost_ccw_scsi_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/s390x/virtio-ccw-serial.c|44| <<virtio_ccw_serial_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-scsi-pci.c|83| <<vhost_scsi_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-user-blk-pci.c|88| <<vhost_user_blk_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-user-fs-pci.c|69| <<vhost_user_fs_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-user-input-pci.c|31| <<vhost_user_input_pci_instance_init>> virtio_instance_init_common(obj, &dev->vhi, sizeof(dev->vhi),
+ *   - hw/virtio/vhost-user-scsi-pci.c|89| <<vhost_user_scsi_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-user-vsock-pci.c|68| <<vhost_user_vsock_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/vhost-vsock-pci.c|78| <<vhost_vsock_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-9p-pci.c|72| <<virtio_9p_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-balloon-pci.c|73| <<virtio_balloon_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-blk-pci.c|86| <<virtio_blk_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-crypto-pci.c|79| <<virtio_crypto_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-input-host-pci.c|31| <<virtio_host_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-input-pci.c|85| <<virtio_keyboard_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-input-pci.c|93| <<virtio_mouse_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-input-pci.c|101| <<virtio_tablet_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-iommu-pci.c|95| <<virtio_iommu_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-mem-pci.c|128| <<virtio_mem_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-net-pci.c|79| <<virtio_net_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pmem-pci.c|109| <<virtio_pmem_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-rng-pci.c|63| <<virtio_rng_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-scsi-pci.c|95| <<virtio_scsi_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-serial-pci.c|98| <<virtio_serial_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ */
 void virtio_instance_init_common(Object *proxy_obj, void *data,
                                  size_t vdev_size, const char *vdev_name)
 {
@@ -3237,6 +3479,25 @@ void virtio_instance_init_common(Object *proxy_obj, void *data,
     qdev_alias_all_properties(vdev, proxy_obj);
 }
 
+/*
+ * called by:
+ *   - hw/9pfs/virtio-9p-device.c|214| <<virtio_9p_device_realize>> virtio_init(vdev, "virtio-9p", VIRTIO_ID_9P, v->config_size);
+ *   - hw/block/vhost-user-blk.c|459| <<vhost_user_blk_device_realize>> virtio_init(vdev, "virtio-blk", VIRTIO_ID_BLOCK,
+ *   - hw/block/virtio-blk.c|1212| <<virtio_blk_device_realize>> virtio_init(vdev, "virtio-blk", VIRTIO_ID_BLOCK, s->config_size);
+ *   - hw/char/virtio-serial-bus.c|1049| <<virtio_serial_device_realize>> virtio_init(vdev, "virtio-serial", VIRTIO_ID_CONSOLE,
+ *   - hw/display/virtio-gpu-base.c|150| <<virtio_gpu_base_device_realize>> virtio_init(VIRTIO_DEVICE(g), "virtio-gpu", VIRTIO_ID_GPU,
+ *   - hw/input/virtio-input.c|260| <<virtio_input_device_realize>> virtio_init(vdev, "virtio-input", VIRTIO_ID_INPUT,
+ *   - hw/net/virtio-net.c|3298| <<virtio_net_device_realize>> virtio_init(vdev, "virtio-net", VIRTIO_ID_NET, n->config_size);
+ *   - hw/scsi/virtio-scsi.c|951| <<virtio_scsi_common_realize>> virtio_init(vdev, "virtio-scsi", VIRTIO_ID_SCSI,
+ *   - hw/virtio/vhost-user-fs.c|208| <<vuf_device_realize>> virtio_init(vdev, "vhost-user-fs", VIRTIO_ID_FS,
+ *   - hw/virtio/vhost-vsock-common.c|204| <<vhost_vsock_common_realize>> virtio_init(vdev, name, VIRTIO_ID_VSOCK,
+ *   - hw/virtio/virtio-balloon.c|884| <<virtio_balloon_device_realize>> virtio_init(vdev, "virtio-balloon", VIRTIO_ID_BALLOON,
+ *   - hw/virtio/virtio-crypto.c|813| <<virtio_crypto_device_realize>> virtio_init(vdev, "virtio-crypto", VIRTIO_ID_CRYPTO, vcrypto->config_size);
+ *   - hw/virtio/virtio-iommu.c|956| <<virtio_iommu_device_realize>> virtio_init(vdev, "virtio-iommu", VIRTIO_ID_IOMMU,
+ *   - hw/virtio/virtio-mem.c|572| <<virtio_mem_device_realize>> virtio_init(vdev, TYPE_VIRTIO_MEM, VIRTIO_ID_MEM,
+ *   - hw/virtio/virtio-pmem.c|122| <<virtio_pmem_realize>> virtio_init(vdev, TYPE_VIRTIO_PMEM, VIRTIO_ID_PMEM,
+ *   - hw/virtio/virtio-rng.c|218| <<virtio_rng_device_realize>> virtio_init(vdev, "virtio-rng", VIRTIO_ID_RNG, 0);
+ */
 void virtio_init(VirtIODevice *vdev, const char *name,
                  uint16_t device_id, size_t config_size)
 {
@@ -3264,6 +3525,12 @@ void virtio_init(VirtIODevice *vdev, const char *name,
         vdev->vq[i].vector = VIRTIO_NO_VECTOR;
         vdev->vq[i].vdev = vdev;
         vdev->vq[i].queue_index = i;
+	/*
+	 * 在以下使用VirtQueue->host_notifier_enabled:
+	 *   - hw/virtio/virtio.c|2380| <<virtio_queue_notify>> if (vq->host_notifier_enabled) {
+	 *   - hw/virtio/virtio.c|3354| <<virtio_init>> vdev->vq[i].host_notifier_enabled = false;
+	 *   - hw/virtio/virtio.c|3683| <<virtio_queue_set_host_notifier_enabled>> vq->host_notifier_enabled = enabled;
+	 */
         vdev->vq[i].host_notifier_enabled = false;
     }
 
@@ -3523,6 +3790,11 @@ EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
     return &vq->guest_notifier;
 }
 
+/*
+ * 在以下使用virtio_queue_host_notifier_aio_read():
+ *   - hw/virtio/virtio.c|3807| <<virtio_queue_aio_set_host_notifier_handler>> aio_set_event_notifier(ctx, &vq->host_notifier, true, virtio_queue_host_notifier_aio_read, virtio_queue_host_notifier_aio_poll);
+ *   - hw/virtio/virtio.c|3816| <<virtio_queue_aio_set_host_notifier_handler>> virtio_queue_host_notifier_aio_read(&vq->host_notifier);
+ */
 static void virtio_queue_host_notifier_aio_read(EventNotifier *n)
 {
     VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
@@ -3578,6 +3850,11 @@ void virtio_queue_aio_set_host_notifier_handler(VirtQueue *vq, AioContext *ctx,
     }
 }
 
+/*
+ * 在以下使用virtio_queue_host_notifier_read():
+ *   - hw/virtio/virtio-bus.c|412| <<virtio_bus_cleanup_host_notifier>> virtio_queue_host_notifier_read(notifier);
+ *   - hw/virtio/virtio.c|3989| <<virtio_device_start_ioeventfd_impl>> virtio_queue_host_notifier_read);
+ */
 void virtio_queue_host_notifier_read(EventNotifier *n)
 {
     VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
@@ -3591,8 +3868,18 @@ EventNotifier *virtio_queue_get_host_notifier(VirtQueue *vq)
     return &vq->host_notifier;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-bus.c|422| <<virtio_bus_set_host_notifier>> virtio_queue_set_host_notifier_enabled(vq, assign);
+ */
 void virtio_queue_set_host_notifier_enabled(VirtQueue *vq, bool enabled)
 {
+    /*
+     * 在以下使用VirtQueue->host_notifier_enabled:
+     *   - hw/virtio/virtio.c|2380| <<virtio_queue_notify>> if (vq->host_notifier_enabled) {
+     *   - hw/virtio/virtio.c|3354| <<virtio_init>> vdev->vq[i].host_notifier_enabled = false;
+     *   - hw/virtio/virtio.c|3683| <<virtio_queue_set_host_notifier_enabled>> vq->host_notifier_enabled = enabled;
+     */
     vq->host_notifier_enabled = enabled;
 }
 
@@ -3723,6 +4010,10 @@ static Property virtio_properties[] = {
     DEFINE_PROP_END_OF_LIST(),
 };
 
+/*
+ * 在以下使用virtio_device_start_ioeventfd_impl():
+ *   - hw/virtio/virtio.c|4102| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+ */
 static int virtio_device_start_ioeventfd_impl(VirtIODevice *vdev)
 {
     VirtioBusState *qbus = VIRTIO_BUS(qdev_get_parent_bus(DEVICE(vdev)));
@@ -3777,6 +4068,13 @@ assign_error:
     return err;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|884| <<virtio_blk_handle_output>> virtio_device_start_ioeventfd(vdev);
+ *   - hw/scsi/virtio-scsi.c|467| <<virtio_scsi_handle_ctrl>> virtio_device_start_ioeventfd(vdev);
+ *   - hw/scsi/virtio-scsi.c|736| <<virtio_scsi_handle_cmd>> virtio_device_start_ioeventfd(vdev);
+ *   - hw/scsi/virtio-scsi.c|869| <<virtio_scsi_handle_event>> virtio_device_start_ioeventfd(vdev);
+ */
 int virtio_device_start_ioeventfd(VirtIODevice *vdev)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
@@ -3827,6 +4125,9 @@ void virtio_device_release_ioeventfd(VirtIODevice *vdev)
     virtio_bus_release_ioeventfd(vbus);
 }
 
+/*
+ * TypeInfo virtio_device_info.class_init = virtio_device_class_init()
+ */
 static void virtio_device_class_init(ObjectClass *klass, void *data)
 {
     /* Set the default value here. */
@@ -3837,12 +4138,27 @@ static void virtio_device_class_init(ObjectClass *klass, void *data)
     dc->unrealize = virtio_device_unrealize;
     dc->bus_type = TYPE_VIRTIO_BUS;
     device_class_set_props(dc, virtio_properties);
+    /*
+     * 在以下调用VirtioDeviceClass->start_ioeventfd:
+     *   - hw/virtio/virtio-bus.c|243| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+     * 在以下使用VirtioDeviceClass->start_ioeventfd:
+     *   - hw/block/virtio-blk.c|1330| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start;
+     *   - hw/scsi/virtio-scsi.c|1082| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+     *   - hw/virtio/virtio.c|4056| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+     */
     vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
     vdc->stop_ioeventfd = virtio_device_stop_ioeventfd_impl;
 
     vdc->legacy_features |= VIRTIO_LEGACY_FEATURES;
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|110| <<virtio_blk_data_plane_create>> if (!virtio_device_ioeventfd_enabled(vdev)) {
+ *   - hw/block/dataplane/virtio-blk.c|124| <<virtio_blk_data_plane_create>> if (!virtio_device_ioeventfd_enabled(vdev)) {
+ *   - hw/scsi/virtio-scsi-dataplane.c|43| <<virtio_scsi_dataplane_setup>> if (!virtio_device_ioeventfd_enabled(vdev)) {
+ *   - hw/scsi/virtio-scsi-dataplane.c|49| <<virtio_scsi_dataplane_setup>> if (!virtio_device_ioeventfd_enabled(vdev)) {
+ */
 bool virtio_device_ioeventfd_enabled(VirtIODevice *vdev)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
diff --git a/include/exec/memory.h b/include/exec/memory.h
index 0f3e6bcd5..fbee20ab2 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -139,6 +139,13 @@ typedef struct IOMMUNotifier IOMMUNotifier;
 /* RAM is a persistent kind memory */
 #define RAM_PMEM (1 << 5)
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1000| <<vfio_listener_region_add>> iommu_notifier_init(&giommu->n, vfio_iommu_map_notify,
+ *   - hw/vfio/common.c|1320| <<vfio_sync_dirty_bitmap>> iommu_notifier_init(&gdn.n,
+ *   - hw/virtio/vhost.c|720| <<vhost_iommu_region_add>> iommu_notifier_init(&iommu->n, vhost_iommu_unmap_notify,
+ *   - softmmu/physmem.c|632| <<tcg_register_iommu_notifier>> iommu_notifier_init(&notifier->n,
+ */
 static inline void iommu_notifier_init(IOMMUNotifier *n, IOMMUNotify fn,
                                        IOMMUNotifierFlag flags,
                                        hwaddr start, hwaddr end,
diff --git a/include/hw/scsi/scsi.h b/include/hw/scsi/scsi.h
index 09fa5c9d2..ac043c450 100644
--- a/include/hw/scsi/scsi.h
+++ b/include/hw/scsi/scsi.h
@@ -39,6 +39,20 @@ struct SCSIRequest {
      * */
 
     uint8_t           sense[SCSI_SENSE_BUF_SIZE];
+    /*
+     * 部分在以下设置SCSIRequest->sense_len(怕找不全):
+     *   - hw/scsi/scsi-bus.c|873| <<scsi_req_build_sense>> req->sense_len = scsi_build_sense(req->sense, sense);
+     *   - hw/scsi/scsi-bus.c|1487| <<scsi_req_complete>> req->sense_len = 0;
+     *   - hw/scsi/scsi-disk.c|2979| <<scsi_block_update_sense>> r->req.sense_len = MIN(br->io_header.sb_len_wr, sizeof(r->req.sense));
+     *   - hw/scsi/scsi-generic.c|87| <<scsi_command_complete_noio>> r->req.sense_len = r->io_header.sb_len_wr;
+     * 部分在以下使用SCSIRequest->sense_len(怕找不全):
+     *   - hw/scsi/scsi-bus.c|829| <<scsi_req_get_sense>> if (!req->sense_len) {
+     *   - hw/scsi/scsi-bus.c|833| <<scsi_req_get_sense>> ret = scsi_convert_sense(req->sense, req->sense_len, buf, len, true);
+     *   - hw/scsi/scsi-bus.c|1485| <<scsi_req_complete>> assert(req->sense_len <= sizeof(req->sense));
+     *   - hw/scsi/scsi-bus.c|1490| <<scsi_req_complete>> if (req->sense_len) {
+     *   - hw/scsi/scsi-bus.c|1491| <<scsi_req_complete>> memcpy(req->dev->sense, req->sense, req->sense_len);
+     *   - hw/scsi/scsi-bus.c|1492| <<scsi_req_complete>> req->dev->sense_len = req->sense_len;
+     */
     uint32_t          sense_len;
     bool              enqueued;
     bool              io_canceled;
diff --git a/include/hw/vfio/vfio-common.h b/include/hw/vfio/vfio-common.h
index 6141162d7..3e3a89659 100644
--- a/include/hw/vfio/vfio-common.h
+++ b/include/hw/vfio/vfio-common.h
@@ -49,10 +49,32 @@ typedef struct VFIOMmap {
 
 typedef struct VFIORegion {
     struct VFIODevice *vbasedev;
+    /*
+     * 在以下设置VFIORegion->fd_offset:
+     *   - hw/vfio/common.c|1479| <<vfio_region_setup>> region->fd_offset = info->offset;
+     */
     off_t fd_offset; /* offset of region within device fd */
     MemoryRegion *mem; /* slow, read/write access */
     size_t size;
     uint32_t flags; /* VFIO region flags (rd/wr/mmap) */
+    /*
+     * 在以下修改VFIORegion:
+     *   - hw/vfio/common.c|1389| <<vfio_setup_region_sparse_mmaps>> region->nr_mmaps = j;
+     *   - hw/vfio/common.c|1423| <<vfio_region_setup>> region->nr_mmaps = 1;
+     *   - hw/vfio/common.c|1569| <<vfio_region_finalize>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1300| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1322| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 2;
+     * 在以下使用VFIORegion:
+     *   - hw/vfio/common.c|1424| <<vfio_region_setup>> region->mmaps = g_new0(VFIOMmap, region->nr_mmaps);
+     *   - hw/vfio/common.c|1470| <<vfio_region_mmap>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1521| <<vfio_region_unmap>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1536| <<vfio_region_exit>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1553| <<vfio_region_finalize>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1583| <<vfio_region_mmaps_set_enabled>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/migration.c|168| <<get_data_section_size>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/pci.c|1069| <<vfio_sub_page_bar_update_mapping>> if (region->nr_mmaps != 1 || !region->mmaps[0].mmap ||
+     *   - hw/vfio/pci.c|1281| <<vfio_pci_fixup_msix_region>> if (region->nr_mmaps != 1 || region->mmaps[0].offset ||
+     */
     uint32_t nr_mmaps;
     VFIOMmap *mmaps;
     uint8_t nr; /* cache the region number for debug */
@@ -84,11 +106,29 @@ typedef struct VFIOContainer {
     unsigned iommu_type;
     Error *error;
     bool initialized;
+    /*
+     * 在以下使用VFIOContainer->dirty_pages_supported:
+     *   - hw/vfio/common.c|538| <<vfio_dma_unmap>> if (iotlb && container->dirty_pages_supported &&
+     *   - hw/vfio/common.c|1327| <<vfio_listerner_log_sync>> !container->dirty_pages_supported) {
+     *   - hw/vfio/common.c|1925| <<vfio_get_iommu_info_migration>> container->dirty_pages_supported = true;
+     *   - hw/vfio/common.c|2004| <<vfio_connect_container>> container->dirty_pages_supported = false;
+     *   - hw/vfio/migration.c|885| <<vfio_migration_probe>> if (!vbasedev->enable_migration || !container->dirty_pages_supported) {
+     */
     bool dirty_pages_supported;
     uint64_t dirty_pgsizes;
     uint64_t max_dirty_bitmap_size;
     unsigned long pgsizes;
     QLIST_HEAD(, VFIOGuestIOMMU) giommu_list;
+    /*
+     * 在以下使用VFIOContainer->hostwin_list:
+     *   - hw/vfio/common.c|692| <<vfio_host_win_add>> QLIST_FOREACH(hostwin, &container->hostwin_list, hostwin_next) {
+     *   - hw/vfio/common.c|706| <<vfio_host_win_add>> QLIST_INSERT_HEAD(&container->hostwin_list, hostwin, hostwin_next);
+     *   - hw/vfio/common.c|714| <<vfio_host_win_del>> QLIST_FOREACH(hostwin, &container->hostwin_list, hostwin_next) {
+     *   - hw/vfio/common.c|888| <<vfio_listener_region_add>> QLIST_FOREACH(hostwin, &container->hostwin_list, hostwin_next) {
+     *   - hw/vfio/common.c|943| <<vfio_listener_region_add>> QLIST_FOREACH(hostwin, &container->hostwin_list, hostwin_next) {
+     *   - hw/vfio/common.c|1134| <<vfio_listener_region_del>> QLIST_FOREACH(hostwin, &container->hostwin_list, hostwin_next) {
+     *   - hw/vfio/common.c|2006| <<vfio_connect_container>> QLIST_INIT(&container->hostwin_list);
+     */
     QLIST_HEAD(, VFIOHostDMAWindow) hostwin_list;
     QLIST_HEAD(, VFIOGroup) group_list;
     QLIST_ENTRY(VFIOContainer) next;
@@ -146,6 +186,23 @@ typedef struct VFIOGroup {
     int fd;
     int groupid;
     VFIOContainer *container;
+    /*
+     * 在以下使用VFIOGroup->device_list:
+     *   - hw/vfio/ccw.c|570| <<vfio_ccw_get_device>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|314| <<vfio_mig_active>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|334| <<vfio_devices_all_saving>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|366| <<vfio_devices_all_running_and_saving>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|1521| <<vfio_reset_handler>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|1529| <<vfio_reset_handler>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|2045| <<vfio_get_group>> QLIST_INIT(&group->device_list);
+     *   - hw/vfio/common.c|2072| <<vfio_put_group>> if (!group || !QLIST_EMPTY(&group->device_list)) {
+     *   - hw/vfio/common.c|2122| <<vfio_get_device>> if (!QLIST_EMPTY(&group->device_list)) {
+     *   - hw/vfio/common.c|2137| <<vfio_get_device>> QLIST_INSERT_HEAD(&group->device_list, vbasedev, next);
+     *   - hw/vfio/pci.c|2266| <<vfio_pci_hot_reset>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/pci.c|2348| <<vfio_pci_hot_reset>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/pci.c|2829| <<vfio_realize>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/platform.c|585| <<vfio_base_device_init>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     */
     QLIST_HEAD(, VFIODevice) device_list;
     QLIST_ENTRY(VFIOGroup) next;
     QLIST_ENTRY(VFIOGroup) container_next;
diff --git a/include/hw/virtio/virtio-blk.h b/include/hw/virtio/virtio-blk.h
index 214ab7482..189c4819a 100644
--- a/include/hw/virtio/virtio-blk.h
+++ b/include/hw/virtio/virtio-blk.h
@@ -58,7 +58,31 @@ struct VirtIOBlock {
     unsigned short sector_mask;
     bool original_wce;
     VMChangeStateEntry *change;
+    /*
+     * 在以下设置VirtIOBlock->dataplane_disabled:
+     *   - hw/block/dataplane/virtio-blk.c|271| <<virtio_blk_data_plane_start>> vblk->dataplane_disabled = true;
+     *   - hw/block/dataplane/virtio-blk.c|317| <<virtio_blk_data_plane_stop>> vblk->dataplane_disabled = false;
+     * 在以下使用VirtIOBlock->dataplane_disabled:
+     *   - hw/block/dataplane/virtio-blk.c|316| <<virtio_blk_data_plane_stop>> if (vblk->dataplane_disabled) {
+     *   - hw/block/virtio-blk.c|100| <<virtio_blk_req_complete>> if (s->dataplane_started && !s->dataplane_disabled) {
+     *   - hw/block/virtio-blk.c|885| <<virtio_blk_handle_output>> if (!s->dataplane_disabled) {
+     */
     bool dataplane_disabled;
+    /*
+     * 在以下设置VirtIOBlock->dataplane_started:
+     *   - hw/block/dataplane/virtio-blk.c|235| <<virtio_blk_data_plane_start>> vblk->dataplane_started = true;
+     *   - hw/block/dataplane/virtio-blk.c|273| <<virtio_blk_data_plane_start>> vblk->dataplane_started = true;
+     *   - hw/block/dataplane/virtio-blk.c|318| <<virtio_blk_data_plane_stop>> vblk->dataplane_started = false;
+     *   - hw/block/dataplane/virtio-blk.c|344| <<virtio_blk_data_plane_stop>> vblk->dataplane_started = false;
+     * 在以下使用VirtIOBlock->dataplane_started:
+     *   - hw/block/dataplane/virtio-blk.c|161| <<virtio_blk_data_plane_destroy>> assert(!vblk->dataplane_started);
+     *   - hw/block/dataplane/virtio-blk.c|180| <<virtio_blk_data_plane_handle_output>> assert(s->dataplane_started);
+     *   - hw/block/dataplane/virtio-blk.c|201| <<virtio_blk_data_plane_start>> if (vblk->dataplane_started || s->starting) {
+     *   - hw/block/dataplane/virtio-blk.c|311| <<virtio_blk_data_plane_stop>> if (!vblk->dataplane_started || s->stopping) {
+     *   - hw/block/virtio-blk.c|100| <<virtio_blk_req_complete>> if (s->dataplane_started && !s->dataplane_disabled) {
+     *   - hw/block/virtio-blk.c|980| <<virtio_blk_reset>> assert(!s->dataplane_started);
+     *   - hw/block/virtio-blk.c|1102| <<virtio_blk_set_status>> assert(!s->dataplane_started);
+     */
     bool dataplane_started;
     struct VirtIOBlockDataPlane *dataplane;
     uint64_t host_features;
diff --git a/include/hw/virtio/virtio-bus.h b/include/hw/virtio/virtio-bus.h
index ef8abe49c..a4af2004d 100644
--- a/include/hw/virtio/virtio-bus.h
+++ b/include/hw/virtio/virtio-bus.h
@@ -80,6 +80,21 @@ struct VirtioBusClass {
      * the device for queue number n. Returns an error value on
      * failure.
      */
+    /*
+     * 在以下设置VirtioBusClass->ioeventfd_assign:
+     *   - hw/s390x/virtio-ccw.c|1242| <<virtio_ccw_bus_class_init>> k->ioeventfd_assign = virtio_ccw_ioeventfd_assign;
+     *   - hw/virtio/virtio-mmio.c|780| <<virtio_mmio_bus_class_init>> k->ioeventfd_assign = virtio_mmio_ioeventfd_assign;
+     *   - hw/virtio/virtio-pci.c|2141| <<virtio_pci_bus_class_init>> k->ioeventfd_assign = virtio_pci_ioeventfd_assign;
+     * 在以下使用VirtioBusClass->ioeventfd_assign:
+     *   - hw/block/dataplane/virtio-blk.c|100| <<virtio_blk_data_plane_create>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|37| <<virtio_scsi_dataplane_setup>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|193| <<virtio_bus_grab_ioeventfd>> if (!k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|234| <<virtio_bus_start_ioeventfd>> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
+     *   - hw/virtio/virtio-bus.c|276| <<virtio_bus_ioeventfd_enabled>> return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
+     *   - hw/virtio/virtio-bus.c|292| <<virtio_bus_set_host_notifier>> if (!k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|303| <<virtio_bus_set_host_notifier>> r = k->ioeventfd_assign(proxy, notifier, n, true);
+     *   - hw/virtio/virtio-bus.c|309| <<virtio_bus_set_host_notifier>> k->ioeventfd_assign(proxy, notifier, n, false);
+     */
     int (*ioeventfd_assign)(DeviceState *d, EventNotifier *notifier,
                             int n, bool assign);
     /*
@@ -101,6 +116,18 @@ struct VirtioBusState {
     /*
      * Set if ioeventfd has been started.
      */
+    /*
+     * 在以下设置VirtioBusState->ioeventfd_started:
+     *   - hw/virtio/virtio-bus.c|228| <<virtio_bus_grab_ioeventfd>> bus->ioeventfd_started = true;
+     *   - hw/virtio/virtio-bus.c|243| <<virtio_bus_release_ioeventfd>> bus->ioeventfd_started = false;
+     *   - hw/virtio/virtio-bus.c|279| <<virtio_bus_start_ioeventfd>> bus->ioeventfd_started = true;
+     *   - hw/virtio/virtio-bus.c|305| <<virtio_bus_stop_ioeventfd>> bus->ioeventfd_started = false;
+     * 在以下使用VirtioBusState->ioeventfd_started:
+     *   - hw/virtio/virtio-bus.c|223| <<virtio_bus_grab_ioeventfd>> if (bus->ioeventfd_grabbed == 0 && bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|241| <<virtio_bus_release_ioeventfd>> if (--bus->ioeventfd_grabbed == 0 && bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|267| <<virtio_bus_start_ioeventfd>> if (bus->ioeventfd_started) {
+     *   - hw/virtio/virtio-bus.c|295| <<virtio_bus_stop_ioeventfd>> if (!bus->ioeventfd_started) {
+     */
     bool ioeventfd_started;
 
     /*
diff --git a/include/hw/virtio/virtio-net.h b/include/hw/virtio/virtio-net.h
index f4852ac27..3a5b02ac5 100644
--- a/include/hw/virtio/virtio-net.h
+++ b/include/hw/virtio/virtio-net.h
@@ -178,6 +178,18 @@ struct VirtIONet {
     uint8_t nomulti;
     uint8_t nouni;
     uint8_t nobcast;
+    /*
+     * 在以下使用VirtIONet->vhost_started:
+     *   - hw/net/virtio-net.c|241| <<virtio_net_vhost_status>> !!n->vhost_started) {
+     *   - hw/net/virtio-net.c|244| <<virtio_net_vhost_status>> if (!n->vhost_started) {
+     *   - hw/net/virtio-net.c|275| <<virtio_net_vhost_status>> n->vhost_started = 1;
+     *   - hw/net/virtio-net.c|280| <<virtio_net_vhost_status>> n->vhost_started = 0;
+     *   - hw/net/virtio-net.c|284| <<virtio_net_vhost_status>> n->vhost_started = 0;
+     *   - hw/net/virtio-net.c|370| <<virtio_net_set_status>> virtio_net_started(n, queue_status) && !n->vhost_started;
+     *   - hw/net/virtio-net.c|3105| <<virtio_net_guest_notifier_pending>> assert(n->vhost_started);
+     *   - hw/net/virtio-net.c|3114| <<virtio_net_guest_notifier_mask>> assert(n->vhost_started);
+     *   - hw/net/virtio-net.c|3513| <<virtio_net_pre_save>> assert(!n->vhost_started);
+     */
     uint8_t vhost_started;
     struct {
         uint32_t in_use;
diff --git a/include/hw/virtio/virtio-scsi.h b/include/hw/virtio/virtio-scsi.h
index 543681bc1..ad10c659e 100644
--- a/include/hw/virtio/virtio-scsi.h
+++ b/include/hw/virtio/virtio-scsi.h
@@ -82,14 +82,65 @@ struct VirtIOSCSI {
 
     SCSIBus bus;
     int resetting;
+    /*
+     * 在以下使用VirtIOSCSI->events_dropped:
+     *   - hw/scsi/virtio-scsi.c|805| <<virtio_scsi_reset>> s->events_dropped = false;
+     *   - hw/scsi/virtio-scsi.c|822| <<virtio_scsi_push_event>> s->events_dropped = true;
+     *   - hw/scsi/virtio-scsi.c|826| <<virtio_scsi_push_event>> if (s->events_dropped) {
+     *   - hw/scsi/virtio-scsi.c|828| <<virtio_scsi_push_event>> s->events_dropped = false;
+     *   - hw/scsi/virtio-scsi.c|857| <<virtio_scsi_handle_event_vq>> if (s->events_dropped) {
+     */
     bool events_dropped;
 
     /* Fields for dataplane below */
     AioContext *ctx; /* one iothread per virtio-scsi-pci for now */
 
+    /*
+     * 在以下设置VirtIOSCSI->dataplane_started:
+     *   - hw/scsi/virtio-scsi-dataplane.c|189| <<virtio_scsi_dataplane_start>> s->dataplane_started = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|204| <<virtio_scsi_dataplane_start>> s->dataplane_started = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|224| <<virtio_scsi_dataplane_stop>> s->dataplane_started = false;
+     *   - hw/scsi/virtio-scsi-dataplane.c|243| <<virtio_scsi_dataplane_stop>> s->dataplane_started = false;
+     * 在以下使用VirtIOSCSI->dataplane_started:
+     *   - hw/scsi/virtio-scsi-dataplane.c|67| <<virtio_scsi_data_plane_handle_cmd>> assert(s->ctx && s->dataplane_started);
+     *   - hw/scsi/virtio-scsi-dataplane.c|85| <<virtio_scsi_data_plane_handle_ctrl>> assert(s->ctx && s->dataplane_started);
+     *   - hw/scsi/virtio-scsi-dataplane.c|98| <<virtio_scsi_data_plane_handle_event>> assert(s->ctx && s->dataplane_started);
+     *   - hw/scsi/virtio-scsi-dataplane.c|153| <<virtio_scsi_dataplane_start>> if (s->dataplane_started ||
+     *   - hw/scsi/virtio-scsi-dataplane.c|217| <<virtio_scsi_dataplane_stop>> if (!s->dataplane_started || s->dataplane_stopping) {
+     *   - hw/scsi/virtio-scsi.c|82| <<virtio_scsi_complete_req>> if (s->dataplane_started && !s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|256| <<virtio_scsi_ctx_check>> if (s->dataplane_started && d && blk_is_available(d->conf.blk)) {
+     *   - hw/scsi/virtio-scsi.c|798| <<virtio_scsi_reset>> assert(!s->dataplane_started);
+     */
     bool dataplane_started;
+    /*
+     * 在以下使用VirtIOSCSI->dataplane_starting:
+     *   - hw/scsi/virtio-scsi-dataplane.c|159| <<virtio_scsi_dataplane_start>> s->dataplane_starting = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|188| <<virtio_scsi_dataplane_start>> s->dataplane_starting = false;
+     *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>> s->dataplane_starting = false;
+     *   - hw/scsi/virtio-scsi-dataplane.c|154| <<virtio_scsi_dataplane_start>> s->dataplane_starting ||
+     */
     bool dataplane_starting;
+    /*
+     * 在以下使用VirtIOSCSI->dataplane_stopping:
+     *   - hw/scsi/virtio-scsi-dataplane.c|227| <<virtio_scsi_dataplane_stop>> s->dataplane_stopping = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|242| <<virtio_scsi_dataplane_stop>> s->dataplane_stopping = false;
+     *   - hw/scsi/virtio-scsi-dataplane.c|217| <<virtio_scsi_dataplane_stop>> if (!s->dataplane_started || s->dataplane_stopping) {
+     */
     bool dataplane_stopping;
+    /*
+     * 在以下设置VirtIOSCSI->dataplane_fenced:
+     *   - hw/scsi/virtio-scsi-dataplane.c|121| <<virtio_scsi_vring_init>> s->dataplane_fenced = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|202| <<virtio_scsi_dataplane_start>> s->dataplane_fenced = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|223| <<virtio_scsi_dataplane_stop>> s->dataplane_fenced = false;
+     * 在以下使用VirtIOSCSI->dataplane_fenced:
+     *   - hw/scsi/virtio-scsi-dataplane.c|155| <<virtio_scsi_dataplane_start>> s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|222| <<virtio_scsi_dataplane_stop>> if (s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|82| <<virtio_scsi_complete_req>> if (s->dataplane_started && !s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|468| <<virtio_scsi_handle_ctrl>> if (!s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|737| <<virtio_scsi_handle_cmd>> if (!s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|870| <<virtio_scsi_handle_event>> if (!s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|908| <<virtio_scsi_hotplug>> if (s->ctx && !s->dataplane_fenced) {
+     */
     bool dataplane_fenced;
     uint32_t host_features;
 };
diff --git a/include/hw/virtio/virtio.h b/include/hw/virtio/virtio.h
index b7ece7a6a..61a2c588d 100644
--- a/include/hw/virtio/virtio.h
+++ b/include/hw/virtio/virtio.h
@@ -105,6 +105,25 @@ struct VirtIODevice
     VMChangeStateEntry *vmstate;
     char *bus_name;
     uint8_t device_endian;
+    /*
+     * Since guest_mask_notifier can not be used in vhost-user mode due
+     * to buffering implied by unix control socket, force
+     * use_mask_notifier on virtio devices of vhost-user interfaces, and
+     * send correct callfd to the guest at vhost start.
+     *
+     * Using guest_notifier_mask function in vhost-user case may
+     * break interrupt mask paradigm, because mask/unmask is not
+     * really done when returning from guest_notifier_mask call, instead
+     * message is posted in a unix socket, and processed later.
+     *
+     * Add an option boolean flag 'use_mask_notifier' to disable the use
+     * of guest_notifier_mask in virtio pci.
+     *
+     * 在以下使用VirtIODevice->use_guest_notifier_mask:
+     *   - backends/cryptodev-vhost.c|197| <<cryptodev_vhost_start>> dev->use_guest_notifier_mask = false;
+     *   - hw/net/vhost_net.c|343| <<vhost_net_start>> dev->use_guest_notifier_mask = false;
+     *   - hw/virtio/virtio.c|3533| <<virtio_init>> vdev->use_guest_notifier_mask = true;
+     */
     bool use_guest_notifier_mask;
     AddressSpace *dma_as;
     QLIST_HEAD(, VirtQueue) *vector_queues;
@@ -145,6 +164,14 @@ struct VirtioDeviceClass {
      * must mask in frontend instead.
      */
     void (*guest_notifier_mask)(VirtIODevice *vdev, int n, bool mask);
+    /*
+     * 在以下调用VirtioDeviceClass->start_ioeventfd:
+     *   - hw/virtio/virtio-bus.c|243| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+     * 在以下使用VirtioDeviceClass->start_ioeventfd:
+     *   - hw/block/virtio-blk.c|1330| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start;
+     *   - hw/scsi/virtio-scsi.c|1082| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+     *   - hw/virtio/virtio.c|4056| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+     */
     int (*start_ioeventfd)(VirtIODevice *vdev);
     void (*stop_ioeventfd)(VirtIODevice *vdev);
     /* Saving and loading of a device; trying to deprecate save/load
diff --git a/io/channel-socket.c b/io/channel-socket.c
index de259f7ee..9535cfef9 100644
--- a/io/channel-socket.c
+++ b/io/channel-socket.c
@@ -426,6 +426,10 @@ static void qio_channel_socket_finalize(Object *obj)
 
 
 #ifndef WIN32
+/*
+ * called by:
+ *   - io/channel-socket.c|517| <<qio_channel_socket_readv>> qio_channel_socket_copy_fds(&msg, fds, nfds);
+ */
 static void qio_channel_socket_copy_fds(struct msghdr *msg,
                                         int **fds, size_t *nfds)
 {
diff --git a/io/channel.c b/io/channel.c
index 93d449dee..d1d9086ab 100644
--- a/io/channel.c
+++ b/io/channel.c
@@ -47,6 +47,17 @@ void qio_channel_set_name(QIOChannel *ioc,
 }
 
 
+/*
+ * called by:
+ *   - chardev/char-socket.c|370| <<tcp_chr_recv>> ret = qio_channel_readv_full(s->ioc, &iov, 1,
+ *   - chardev/char-socket.c|374| <<tcp_chr_recv>> ret = qio_channel_readv_full(s->ioc, &iov, 1,
+ *   - io/channel.c|198| <<qio_channel_readv>> return qio_channel_readv_full(ioc, iov, niov, NULL, NULL, errp);
+ *   - io/channel.c|217| <<qio_channel_read>> return qio_channel_readv_full(ioc, &iov, 1, NULL, NULL, errp);
+ *   - scsi/qemu-pr-helper.c|604| <<prh_read>> n_read = qio_channel_readv_full(QIO_CHANNEL(client->ioc), &iov, 1,
+ *   - tests/qtest/tpm-emu.c|95| <<tpm_emu_ctrl_thread>> qio_channel_readv_full(ioc, &iov, 1, &pfd, &nfd, &error_abort);
+ *   - tests/test-io-channel-socket.c|449| <<test_io_channel_unix_fd_pass>> qio_channel_readv_full(dst,
+ *   - util/vhost-user-server.c|105| <<vu_message_read>> rc = qio_channel_readv_full(ioc, &iov, 1, &fds, &nfds, &local_err);
+ */
 ssize_t qio_channel_readv_full(QIOChannel *ioc,
                                const struct iovec *iov,
                                size_t niov,
@@ -63,6 +74,9 @@ ssize_t qio_channel_readv_full(QIOChannel *ioc,
         return -1;
     }
 
+    /*
+     * 比如getfd用qio_channel_socket_readv()
+     */
     return klass->io_readv(ioc, iov, niov, fds, nfds, errp);
 }
 
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 56ce14ad2..596fadc91 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -1505,6 +1505,10 @@ struct kvm_enc_region {
 #define KVM_HYPERV_EVENTFD        _IOW(KVMIO,  0xbd, struct kvm_hyperv_eventfd)
 
 /* Available with KVM_CAP_NESTED_STATE */
+/*
+ * 在以下使用KVM_GET_NESTED_STATE:
+ *   - target/i386/kvm.c|3912| <<kvm_get_nested_state>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_NESTED_STATE, env->nested_state);
+ */
 #define KVM_GET_NESTED_STATE         _IOWR(KVMIO, 0xbe, struct kvm_nested_state)
 #define KVM_SET_NESTED_STATE         _IOW(KVMIO,  0xbf, struct kvm_nested_state)
 
diff --git a/monitor/misc.c b/monitor/misc.c
index 398211a03..e785e3642 100644
--- a/monitor/misc.c
+++ b/monitor/misc.c
@@ -1224,12 +1224,49 @@ static void hmp_acl_remove(Monitor *mon, const QDict *qdict)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  0x000055e0a0cc780f in qmp_getfd (fdname=0x55e0a2e32590 "vhost-scsi-test", errp=0x7ffea965a210) at ../monitor/misc.c:1228
+ * #1  0x000055e0a0f49676 in qmp_marshal_getfd (args=0x7fc3180037d0, ret=0x7fc32917fd88, errp=0x7fc32917fd80) at qapi/qapi-commands-misc.c:334
+ * #2  0x000055e0a0fd22bc in do_qmp_dispatch_bh (opaque=0x7fc32917fe20) at ../qapi/qmp-dispatch.c:110
+ * #3  0x000055e0a0fbd1b1 in aio_bh_call (bh=0x55e0a2e53530) at ../util/async.c:136
+ * #4  0x000055e0a0fbd2bb in aio_bh_poll (ctx=0x55e0a2099640) at ../util/async.c:164
+ * #5  0x000055e0a0f9605e in aio_dispatch (ctx=0x55e0a2099640) at ../util/aio-posix.c:381
+ * #6  0x000055e0a0fbd6ee in aio_ctx_dispatch (source=0x55e0a2099640, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #7  0x00007fc3285f7099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #8  0x000055e0a0fb92be in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #9  0x000055e0a0fb9338 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:244
+ * #10 0x000055e0a0fb9440 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #11 0x000055e0a0cd72cb in qemu_main_loop () at ../softmmu/vl.c:1678#12 0x000055e0a095db32 in main (argc=22, argv=0x7ffea965a5b8, envp=0x7ffea965a670) at ../softmmu/main.c:50
+ *
+ * (gdb) bt
+ * #0  0x0000555555b7380f in qmp_getfd (fdname=0x55555737db60 "hello", errp=0x7fffffffcb28) at ../monitor/misc.c:1228
+ * #1  0x0000555555a688b1 in hmp_getfd (mon=0x555556ab80f0, qdict=0x5555570a3a00) at ../monitor/hmp-cmds.c:1691
+ * #2  0x0000555555940606 in handle_hmp_command (mon=0x555556ab80f0, cmdline=0x555556adc5a6 "hello") at ../monitor/hmp.c:1100
+ * #3  0x000055555593dd99 in monitor_command_cb (opaque=0x555556ab80f0, cmdline=0x555556adc5a0 "getfd hello", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #4  0x0000555555e5a417 in readline_handle_byte (rs=0x555556adc5a0, ch=10) at ../util/readline.c:408
+ * #5  0x0000555555941156 in monitor_read (opaque=0x555556ab80f0, buf=0x7fffffffcd60 "\n", size=1) at ../monitor/hmp.c:1340
+ * #6  0x0000555555d8fabe in qemu_chr_be_write_impl (s=0x555556aaf530, buf=0x7fffffffcd60 "\n", len=1) at ../chardev/char.c:201
+ * #7  0x0000555555d8fb25 in qemu_chr_be_write (s=0x555556aaf530, buf=0x7fffffffcd60 "\n", len=1) at ../chardev/char.c:213
+ * #8  0x0000555555d8b38c in fd_chr_read (chan=0x555556aaf640, cond=G_IO_IN, opaque=0x555556aaf530) at ../chardev/char-fd.c:68
+ * #9  0x0000555555d88fd4 in qio_channel_fd_source_dispatch (source=0x55555737da00, callback=0x555555d8b262 <fd_chr_read>, user_data=0x555556aaf530) at ../io/channel-watch.c:84
+ * #10 0x00007ffff7447099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #11 0x0000555555e65297 in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #12 0x0000555555e65311 in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:244
+ * #13 0x0000555555e65419 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #14 0x0000555555b832cb in qemu_main_loop () at ../softmmu/vl.c:1678
+ * #15 0x0000555555809b32 in main (argc=20, argv=0x7fffffffe008, envp=0x7fffffffe0b0) at ../softmmu/main.c:50
+ */
 void qmp_getfd(const char *fdname, Error **errp)
 {
     Monitor *cur_mon = monitor_cur();
     mon_fd_t *monfd;
     int fd, tmp_fd;
 
+    /*
+     * struct Monitor:
+     * -> CharBackend chr;
+     */
     fd = qemu_chr_fe_get_msgfd(&cur_mon->chr);
     if (fd == -1) {
         error_setg(errp, QERR_FD_NOT_SUPPLIED);
@@ -1244,6 +1281,20 @@ void qmp_getfd(const char *fdname, Error **errp)
     }
 
     QEMU_LOCK_GUARD(&cur_mon->mon_lock);
+    /*
+     * 在以下使用Monitor->fds:
+     *   - monitor/misc.c|1247| <<qmp_getfd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1263| <<qmp_getfd>> QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
+     *   - monitor/misc.c|1273| <<qmp_closefd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1297| <<monitor_get_fd>> QLIST_FOREACH(monfd, &mon->fds, next) {
+     *   - monitor/misc.c|1323| <<monitor_fdset_cleanup>> QLIST_FOREACH_SAFE(mon_fdset_fd, &mon_fdset->fds, next, mon_fdset_fd_next) {
+     *   - monitor/misc.c|1334| <<monitor_fdset_cleanup>> if (QLIST_EMPTY(&mon_fdset->fds) && QLIST_EMPTY(&mon_fdset->dup_fds)) {
+     *   - monitor/misc.c|1388| <<qmp_remove_fd>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1430| <<qmp_query_fdsets>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1447| <<qmp_query_fdsets>> fdset_info->value->fds = fdsetfd_list;
+     *   - monitor/misc.c|1529| <<monitor_fdset_add_fd>> QLIST_INSERT_HEAD(&mon_fdset->fds, mon_fdset_fd, next);
+     *   - monitor/misc.c|1557| <<monitor_fdset_dup_fd_add>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     */
     QLIST_FOREACH(monfd, &cur_mon->fds, next) {
         if (strcmp(monfd->name, fdname) != 0) {
             continue;
@@ -1256,10 +1307,30 @@ void qmp_getfd(const char *fdname, Error **errp)
         return;
     }
 
+    /*
+     * 新的fd用以下方式被vhost-scsi取出.
+     * vhost_scsi_realize()
+     * -> monitor_fd_param()
+     *    -> monitor_get_fd()
+     */
     monfd = g_malloc0(sizeof(mon_fd_t));
     monfd->name = g_strdup(fdname);
     monfd->fd = fd;
 
+    /*
+     * 在以下使用Monitor->fds:
+     *   - monitor/misc.c|1247| <<qmp_getfd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1263| <<qmp_getfd>> QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
+     *   - monitor/misc.c|1273| <<qmp_closefd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1297| <<monitor_get_fd>> QLIST_FOREACH(monfd, &mon->fds, next) {
+     *   - monitor/misc.c|1323| <<monitor_fdset_cleanup>> QLIST_FOREACH_SAFE(mon_fdset_fd, &mon_fdset->fds, next, mon_fdset_fd_next) {
+     *   - monitor/misc.c|1334| <<monitor_fdset_cleanup>> if (QLIST_EMPTY(&mon_fdset->fds) && QLIST_EMPTY(&mon_fdset->dup_fds)) {
+     *   - monitor/misc.c|1388| <<qmp_remove_fd>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1430| <<qmp_query_fdsets>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1447| <<qmp_query_fdsets>> fdset_info->value->fds = fdsetfd_list;
+     *   - monitor/misc.c|1529| <<monitor_fdset_add_fd>> QLIST_INSERT_HEAD(&mon_fdset->fds, mon_fdset_fd, next);
+     *   - monitor/misc.c|1557| <<monitor_fdset_dup_fd_add>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     */
     QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
 }
 
@@ -1289,6 +1360,14 @@ void qmp_closefd(const char *fdname, Error **errp)
     error_setg(errp, QERR_FD_NOT_FOUND, fdname);
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|1989| <<qmp_dump_guest_memory>> fd = monitor_get_fd(monitor_cur(), p, errp);
+ *   - migration/fd.c|29| <<fd_start_outgoing_migration>> int fd = monitor_get_fd(monitor_cur(), fdname, errp);
+ *   - monitor/misc.c|1646| <<monitor_fd_param>> fd = monitor_get_fd(mon, fdname, &local_err);
+ *   - monitor/qmp-cmds.c|331| <<qmp_add_client>> fd = monitor_get_fd(monitor_cur(), fdname, errp);
+ *   - util/qemu-sockets.c|1128| <<socket_get_fd>> fd = monitor_get_fd(cur_mon, fdstr, errp);
+ */
 int monitor_get_fd(Monitor *mon, const char *fdname, Error **errp)
 {
     mon_fd_t *monfd;
@@ -1623,12 +1702,30 @@ void monitor_fdset_dup_fd_remove(int dup_fd)
     monitor_fdset_dup_fd_find_remove(dup_fd, true);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/vhost-scsi.c|180| <<vhost_scsi_realize>> vhostfd = monitor_fd_param(monitor_cur(), vs->conf.vhostfd, errp);
+ *   - hw/virtio/vhost-vsock.c|147| <<vhost_vsock_device_realize>> vhostfd = monitor_fd_param(monitor_cur(), vsock->conf.vhostfd, errp);
+ *   - migration/fd.c|58| <<fd_start_incoming_migration>> int fd = monitor_fd_param(monitor_cur(), fdname, errp);
+ *   - net/socket.c|730| <<net_init_socket>> fd = monitor_fd_param(monitor_cur(), sock->fd, errp);
+ *   - net/tap.c|703| <<net_init_tap_one>> vhostfd = monitor_fd_param(monitor_cur(), vhostfdname, &err);
+ *   - net/tap.c|811| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), tap->fd, errp);
+ *   - net/tap.c|867| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), fds[i], errp);
+ */
 int monitor_fd_param(Monitor *mon, const char *fdname, Error **errp)
 {
     int fd;
     Error *local_err = NULL;
 
     if (!qemu_isdigit(fdname[0]) && mon) {
+        /*
+	 * called by:
+	 *   - dump/dump.c|1989| <<qmp_dump_guest_memory>> fd = monitor_get_fd(monitor_cur(), p, errp);
+	 *   - migration/fd.c|29| <<fd_start_outgoing_migration>> int fd = monitor_get_fd(monitor_cur(), fdname, errp);
+	 *   - monitor/misc.c|1646| <<monitor_fd_param>> fd = monitor_get_fd(mon, fdname, &local_err);
+	 *   - monitor/qmp-cmds.c|331| <<qmp_add_client>> fd = monitor_get_fd(monitor_cur(), fdname, errp);
+	 *   - util/qemu-sockets.c|1128| <<socket_get_fd>> fd = monitor_get_fd(cur_mon, fdstr, errp);
+	 */
         fd = monitor_get_fd(mon, fdname, &local_err);
     } else {
         fd = qemu_parse_fd(fdname);
diff --git a/monitor/monitor-internal.h b/monitor/monitor-internal.h
index a6131554d..45ce089a3 100644
--- a/monitor/monitor-internal.h
+++ b/monitor/monitor-internal.h
@@ -104,6 +104,20 @@ struct Monitor {
     /*
      * Members that are protected by the per-monitor lock
      */
+    /*
+     * 在以下使用Monitor->fds:
+     *   - monitor/misc.c|1247| <<qmp_getfd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1263| <<qmp_getfd>> QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
+     *   - monitor/misc.c|1273| <<qmp_closefd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1297| <<monitor_get_fd>> QLIST_FOREACH(monfd, &mon->fds, next) {
+     *   - monitor/misc.c|1323| <<monitor_fdset_cleanup>> QLIST_FOREACH_SAFE(mon_fdset_fd, &mon_fdset->fds, next, mon_fdset_fd_next) {
+     *   - monitor/misc.c|1334| <<monitor_fdset_cleanup>> if (QLIST_EMPTY(&mon_fdset->fds) && QLIST_EMPTY(&mon_fdset->dup_fds)) {
+     *   - monitor/misc.c|1388| <<qmp_remove_fd>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1430| <<qmp_query_fdsets>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1447| <<qmp_query_fdsets>> fdset_info->value->fds = fdsetfd_list;
+     *   - monitor/misc.c|1529| <<monitor_fdset_add_fd>> QLIST_INSERT_HEAD(&mon_fdset->fds, mon_fdset_fd, next);
+     *   - monitor/misc.c|1557| <<monitor_fdset_dup_fd_add>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     */
     QLIST_HEAD(, mon_fd_t) fds;
     QString *outbuf;
     guint out_watch;
diff --git a/net/tap.c b/net/tap.c
index b7512853f..df3a5e9c0 100644
--- a/net/tap.c
+++ b/net/tap.c
@@ -652,6 +652,13 @@ static int net_tap_init(const NetdevTapOptions *tap, int *vnet_hdr,
 
 #define MAX_TAP_QUEUES 1024
 
+/*
+ * called by:
+ *   - net/tap.c|830| <<net_init_tap>> net_init_tap_one(tap, peer, "tap", name, NULL,
+ *   - net/tap.c|892| <<net_init_tap>> net_init_tap_one(tap, peer, "tap", name, ifname,
+ *   - net/tap.c|936| <<net_init_tap>> net_init_tap_one(tap, peer, "bridge", name, ifname,
+ *   - net/tap.c|981| <<net_init_tap>> net_init_tap_one(tap, peer, "tap", name, ifname,
+ */
 static void net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,
                              const char *model, const char *name,
                              const char *ifname, const char *script,
diff --git a/qapi/qmp-dispatch.c b/qapi/qmp-dispatch.c
index 9a2d7dd29..f7f83c5a4 100644
--- a/qapi/qmp-dispatch.c
+++ b/qapi/qmp-dispatch.c
@@ -101,6 +101,10 @@ typedef struct QmpDispatchBH {
     Coroutine *co;
 } QmpDispatchBH;
 
+/*
+ * 在以下使用do_qmp_dispatch_bh():
+ *   - qapi/qmp-dispatch.c|213| <<qmp_dispatch>> aio_bh_schedule_oneshot(qemu_get_aio_context(), do_qmp_dispatch_bh,
+ */
 static void do_qmp_dispatch_bh(void *opaque)
 {
     QmpDispatchBH *data = opaque;
@@ -116,6 +120,14 @@ static void do_qmp_dispatch_bh(void *opaque)
  * Runs outside of coroutine context for OOB commands, but in coroutine
  * context for everything else.
  */
+/*
+ * called by:
+ *   - monitor/qmp.c|145| <<monitor_qmp_dispatch>> rsp = qmp_dispatch(mon->commands, req, qmp_oob_enabled(mon),
+ *   - qga/main.c|582| <<process_event>> rsp = qmp_dispatch(&ga_commands, obj, false, NULL);
+ *   - tests/test-qmp-cmds.c|159| <<do_qmp_dispatch>> resp = qmp_dispatch(&qmp_commands, QOBJECT(req), allow_oob, NULL);
+ *   - tests/test-qmp-cmds.c|182| <<do_qmp_dispatch_error>> resp = qmp_dispatch(&qmp_commands, QOBJECT(req), allow_oob, NULL);
+ *   - tests/test-qmp-cmds.c|238| <<test_dispatch_cmd_success_response>> resp = qmp_dispatch(&qmp_commands, QOBJECT(req), false, NULL);
+ */
 QDict *qmp_dispatch(const QmpCommandList *cmds, QObject *request,
                     bool allow_oob, Monitor *cur_mon)
 {
diff --git a/scsi/pr-manager-helper.c b/scsi/pr-manager-helper.c
index 451c7631b..fa18a73c8 100644
--- a/scsi/pr-manager-helper.c
+++ b/scsi/pr-manager-helper.c
@@ -148,6 +148,9 @@ out_close:
     return r;
 }
 
+/*
+ * 简单的scsi-block测试没调用
+ */
 static int pr_manager_helper_run(PRManager *p,
                                  int fd, struct sg_io_hdr *io_hdr)
 {
diff --git a/scsi/utils.c b/scsi/utils.c
index b37c28301..ea6d8229a 100644
--- a/scsi/utils.c
+++ b/scsi/utils.c
@@ -561,6 +561,11 @@ const char *scsi_command_name(uint8_t cmd)
 }
 
 #ifdef CONFIG_LINUX
+/*
+ * called by:
+ *   - hw/scsi/scsi-generic.c|84| <<scsi_command_complete_noio>> status = sg_io_sense_from_errno(-ret, &r->io_header, &sense);
+ *   - scsi/qemu-pr-helper.c|152| <<do_sgio_worker>> status = sg_io_sense_from_errno(ret < 0 ? errno : 0, &io_hdr,
+ */
 int sg_io_sense_from_errno(int errno_value, struct sg_io_hdr *io_hdr,
                            SCSISense *sense)
 {
diff --git a/softmmu/dma-helpers.c b/softmmu/dma-helpers.c
index 03c92e0cc..69760f525 100644
--- a/softmmu/dma-helpers.c
+++ b/softmmu/dma-helpers.c
@@ -314,6 +314,25 @@ static uint64_t dma_buf_rw(uint8_t *ptr, int32_t len, QEMUSGList *sg,
     return resid;
 }
 
+/*
+ * called by:
+ *   - hw/block/nvme.c|702| <<nvme_dma>> residual = dma_buf_read(ptr, len, &req->qsg);
+ *   - hw/ide/ahci.c|1383| <<ahci_pio_transfer>> dma_buf_read(s->data_ptr, size, &s->sg);
+ *   - hw/ide/ahci.c|1476| <<ahci_dma_rw_buf>> dma_buf_read(p, l, &s->sg);
+ *   - hw/scsi/megasas.c|850| <<megasas_ctrl_get_info>> cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
+ *   - hw/scsi/megasas.c|880| <<megasas_mfc_get_defaults>> cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
+ *   - hw/scsi/megasas.c|901| <<megasas_dcmd_get_bios_info>> cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
+ *   - hw/scsi/megasas.c|912| <<megasas_dcmd_get_fw_time>> cmd->iov_size -= dma_buf_read((uint8_t *)&fw_time, dcmd_size, &cmd->qsg);
+ *   - hw/scsi/megasas.c|939| <<megasas_event_info>> cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
+ *   - hw/scsi/megasas.c|1008| <<megasas_dcmd_pd_get_list>> cmd->iov_size -= dma_buf_read((uint8_t *)&info, offset, &cmd->qsg);
+ *   - hw/scsi/megasas.c|1102| <<megasas_pd_get_info_submit>> resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);
+ *   - hw/scsi/megasas.c|1174| <<megasas_dcmd_ld_get_list>> resid = dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
+ *   - hw/scsi/megasas.c|1223| <<megasas_dcmd_ld_list_query>> resid = dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
+ *   - hw/scsi/megasas.c|1273| <<megasas_ld_get_info_submit>> resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg);
+ *   - hw/scsi/megasas.c|1392| <<megasas_dcmd_cfg_read>> cmd->iov_size -= dma_buf_read((uint8_t *)data, info->size, &cmd->qsg);
+ *   - hw/scsi/megasas.c|1422| <<megasas_dcmd_get_properties>> cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);
+ *   - hw/scsi/scsi-bus.c|1419| <<scsi_req_data>> req->resid = dma_buf_read(buf, len, req->sg);
+ */
 uint64_t dma_buf_read(uint8_t *ptr, int32_t len, QEMUSGList *sg)
 {
     return dma_buf_rw(ptr, len, sg, DMA_DIRECTION_FROM_DEVICE);
diff --git a/softmmu/physmem.c b/softmmu/physmem.c
index 3027747c0..1ae8876ed 100644
--- a/softmmu/physmem.c
+++ b/softmmu/physmem.c
@@ -1457,6 +1457,10 @@ static int file_ram_open(const char *path,
     return fd;
 }
 
+/*
+ * called by:
+ *   - softmmu/physmem.c|2003| <<qemu_ram_alloc_from_fd>> new_block->host = file_ram_alloc(new_block, size, fd, !file_size, errp);
+ */
 static void *file_ram_alloc(RAMBlock *block,
                             ram_addr_t memory,
                             int fd,
@@ -1513,6 +1517,10 @@ static void *file_ram_alloc(RAMBlock *block,
     area = qemu_ram_mmap(fd, memory, block->mr->align,
                          block->flags & RAM_SHARED, block->flags & RAM_PMEM);
     if (area == MAP_FAILED) {
+        /*
+	 * 分配失败会显示:
+	 * qemu-system-x86_64: -object memory-backend-file,id=mem0,size=4000M,mem-path=/dev/hugepages_test,share=on: unable to map backing store for guest RAM: Cannot allocate memory
+	 */
         error_setg_errno(errp, errno,
                          "unable to map backing store for guest RAM");
         return NULL;
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 5a8c96072..08ff854d2 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -6150,6 +6150,10 @@ APICCommonClass *apic_get_class(void)
     return APIC_COMMON_CLASS(object_class_by_name(apic_type));
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|6695| <<x86_cpu_realizefn>> x86_cpu_apic_create(cpu, &local_err);
+ */
 static void x86_cpu_apic_create(X86CPU *cpu, Error **errp)
 {
     APICCommonState *apic;
diff --git a/target/i386/helper.c b/target/i386/helper.c
index 034f46bcc..0354439f8 100644
--- a/target/i386/helper.c
+++ b/target/i386/helper.c
@@ -861,6 +861,11 @@ static void emit_guest_memory_failure(MemoryFailureAction action, bool ar,
                                    &mff);
 }
 
+/*
+ * 在以下使用do_inject_x86_mce():
+ *   - target/i386/helper.c|988| <<cpu_x86_inject_mce>> run_on_cpu(cs, do_inject_x86_mce, RUN_ON_CPU_HOST_PTR(&params));
+ *   - target/i386/helper.c|1001| <<cpu_x86_inject_mce>> run_on_cpu(other_cs, do_inject_x86_mce, RUN_ON_CPU_HOST_PTR(&params));
+ */
 static void do_inject_x86_mce(CPUState *cs, run_on_cpu_data data)
 {
     MCEInjectionParams *params = data.host_ptr;
@@ -950,6 +955,11 @@ static void do_inject_x86_mce(CPUState *cs, run_on_cpu_data data)
     emit_guest_memory_failure(MEMORY_FAILURE_ACTION_INJECT, ar, recursive);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm.c|544| <<kvm_mce_inject>> cpu_x86_inject_mce(NULL, cpu, 9, status, mcg_status, paddr,
+ *   - target/i386/monitor.c|599| <<hmp_mce>> cpu_x86_inject_mce(mon, cpu, bank, status, mcg_status, addr, misc,
+ */
 void cpu_x86_inject_mce(Monitor *mon, X86CPU *cpu, int bank,
                         uint64_t status, uint64_t mcg_status, uint64_t addr,
                         uint64_t misc, int flags)
diff --git a/target/i386/kvm.c b/target/i386/kvm.c
index a2934dda0..5dfaf7bfc 100644
--- a/target/i386/kvm.c
+++ b/target/i386/kvm.c
@@ -192,6 +192,10 @@ bool kvm_hv_vpindex_settable(void)
     return hv_vpindex_settable;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm.c|226| <<do_kvm_synchronize_tsc>> kvm_get_tsc(cpu);
+ */
 static int kvm_get_tsc(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -514,6 +518,10 @@ static int kvm_get_mce_cap_supported(KVMState *s, uint64_t *mce_cap,
     return -ENOSYS;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm.c|582| <<kvm_arch_on_sigbus_vcpu>> kvm_mce_inject(cpu, paddr, code);
+ */
 static void kvm_mce_inject(X86CPU *cpu, hwaddr paddr, int code)
 {
     CPUState *cs = CPU(cpu);
diff --git a/util/event_notifier-posix.c b/util/event_notifier-posix.c
index 00d93204f..d66dd3b2d 100644
--- a/util/event_notifier-posix.c
+++ b/util/event_notifier-posix.c
@@ -32,6 +32,38 @@ void event_notifier_init_fd(EventNotifier *e, int fd)
 }
 #endif
 
+/*
+ * 非test调用的例子:
+ *   - block/linux-aio.c|427| <<laio_init>> rc = event_notifier_init(&s->e, false);
+ *   - block/nvme.c|720| <<nvme_init>> ret = event_notifier_init(&s->irq_notifier[MSIX_SHARED_IRQ_IDX], 0);
+ *   - block/win32-aio.c|192| <<win32_aio_init>> if (event_notifier_init(&s->e, false) < 0) {
+ *   - contrib/ivshmem-server/ivshmem-server.c|176| <<ivshmem_server_handle_new_conn>> if (event_notifier_init(&peer->vectors[i], FALSE) < 0) {
+ *   - hw/hyperv/hyperv.c|384| <<hyperv_sint_route_new>> r = event_notifier_init(&sint_route->sint_set_notifier, false);
+ *   - hw/hyperv/hyperv.c|396| <<hyperv_sint_route_new>> r = event_notifier_init(ack_notifier, false);
+ *   - hw/hyperv/hyperv_testdev.c|216| <<evt_conn_create>> assert(!event_notifier_init(&conn->notifier, false));
+ *   - hw/hyperv/vmbus.c|1522| <<open_channel>> if (event_notifier_init(&chan->notifier, 0)) { 
+ *   - hw/hyperv/vmbus.c|2508| <<vmbus_realize>> ret = event_notifier_init(&vmbus->notifier, 0);
+ *   - hw/misc/pci-testdev.c|295| <<pci_testdev_realize>> r = event_notifier_init(&test->notifier, 0);
+ *   - hw/s390x/virtio-ccw.c|987| <<virtio_ccw_set_guest_notifier>> int r = event_notifier_init(notifier, 0);
+ *   - hw/usb/ccid-card-emulated.c|406| <<init_event_notifier>> if (event_notifier_init(&card->notifier, false) < 0) {
+ *   - hw/usb/u2f-emulated.c|325| <<u2f_emulated_realize>> if (event_notifier_init(&key->notifier, false) < 0) {
+ *   - hw/vfio/ccw.c|410| <<vfio_ccw_register_irq_notifier>> if (event_notifier_init(notifier, 0)) {
+ *   - hw/vfio/pci-quirks.c|354| <<vfio_ioeventfd_init>> if (event_notifier_init(&ioeventfd->e, 0)) {
+ *   - hw/vfio/pci.c|173| <<vfio_intx_enable_kvm>> if (event_notifier_init(&vdev->intx.unmask, 0)) {
+ *   - hw/vfio/pci.c|332| <<vfio_intx_enable>> ret = event_notifier_init(&vdev->intx.interrupt, 0);
+ *   - hw/vfio/pci.c|493| <<vfio_add_kvm_msi_virq>> if (event_notifier_init(&vector->kvm_interrupt, 0)) {
+ *   - hw/vfio/pci.c|569| <<vfio_msix_vector_do_use>> if (event_notifier_init(&vector->interrupt, 0)) {
+ *   - hw/vfio/pci.c|726| <<vfio_msi_enable>> if (event_notifier_init(&vector->interrupt, 0)) {
+ *   - hw/vfio/pci.c|2939| <<vfio_register_err_notifier>> if (event_notifier_init(&vdev->err_notifier, 0)) {
+ *   - hw/vfio/pci.c|3024| <<vfio_register_req_notifier>> if (event_notifier_init(&vdev->req_notifier, 0)) {
+ *   - hw/vfio/platform.c|75| <<vfio_init_intp>> ret = event_notifier_init(intp->interrupt, 0);
+ *   - hw/vfio/platform.c|86| <<vfio_init_intp>> ret = event_notifier_init(intp->unmask, 0);
+ *   - hw/virtio/vhost.c|1273| <<vhost_virtqueue_init>> int r = event_notifier_init(&vq->masked_notifier, 0);
+ *   - hw/virtio/virtio-bus.c|392| <<virtio_bus_set_host_notifier>> r = event_notifier_init(notifier, 1);
+ *   - hw/virtio/virtio-mmio.c|619| <<virtio_mmio_set_guest_notifier>> int r = event_notifier_init(notifier, 0);
+ *   - hw/virtio/virtio-pci.c|967| <<virtio_pci_set_guest_notifier>> int r = event_notifier_init(notifier, 0);
+ *   - util/async.c|508| <<aio_context_new>> ret = event_notifier_init(&ctx->notifier, false);
+ */
 int event_notifier_init(EventNotifier *e, int active)
 {
     int fds[2];
@@ -91,6 +123,26 @@ int event_notifier_get_fd(const EventNotifier *e)
     return e->rfd;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|211| <<kvm_resample_fd_notify>> event_notifier_set(rfd->resample_event);
+ *   - hw/block/dataplane/virtio-blk.c|235| <<virtio_blk_data_plane_start>> event_notifier_set(virtio_queue_get_host_notifier(vq));
+ *   - hw/block/vhost-user-blk.c|297| <<vhost_user_blk_handle_output>> event_notifier_set(virtio_queue_get_host_notifier(kick_vq));
+ *   - hw/hyperv/hyperv.c|470| <<hyperv_sint_route_set_sint>> return event_notifier_set(&sint_route->sint_set_notifier);
+ *   - hw/hyperv/hyperv.c|658| <<hyperv_hcall_signal_event>> event_notifier_set(handler->notifier);
+ *   - hw/hyperv/vmbus.c|714| <<vmbus_channel_notify_host>> event_notifier_set(&chan->notifier);
+ *   - hw/misc/ivshmem.c|203| <<ivshmem_io_write>> event_notifier_set(&s->peers[dest].eventfds[vector]);
+ *   - hw/s390x/virtio-ccw.c|1011| <<virtio_ccw_set_guest_notifier>> event_notifier_set(notifier);
+ *   - hw/usb/ccid-card-emulated.c|170| <<emulated_push_event>> event_notifier_set(&card->notifier);
+ *   - hw/usb/u2f-emulated.c|190| <<u2f_emulated_thread>> event_notifier_set(&key->notifier);
+ *   - hw/virtio/virtio-pci.c|827| <<virtio_pci_vq_vector_unmask>> event_notifier_set(n);
+ *   - hw/virtio/virtio.c|2416| <<virtio_queue_notify>> event_notifier_set(&vq->host_notifier);
+ *   - hw/virtio/virtio.c|2632| <<virtio_notify_irqfd>> event_notifier_set(&vq->guest_notifier);
+ *   - hw/virtio/virtio.c|3888| <<virtio_device_start_ioeventfd_impl>> event_notifier_set(&vq->host_notifier);
+ *   - softmmu/memory.c|1472| <<memory_region_dispatch_write_eventfds>> event_notifier_set(ioeventfd.e);
+ *   - util/async.c|435| <<aio_notify>> event_notifier_set(&ctx->notifier);
+ *   - util/event_notifier-posix.c|69| <<event_notifier_init>> event_notifier_set(e);
+ */
 int event_notifier_set(EventNotifier *e)
 {
     static const uint64_t value = 1;
diff --git a/util/oslib-posix.c b/util/oslib-posix.c
index f15234b5c..b25e18587 100644
--- a/util/oslib-posix.c
+++ b/util/oslib-posix.c
@@ -81,6 +81,22 @@ struct MemsetThread {
 };
 typedef struct MemsetThread MemsetThread;
 
+/*
+ * 在以下使用memset_thread:
+ *   - util/oslib-posix.c|447| <<sigbus_handler>> if (memset_thread) {
+ *   - util/oslib-posix.c|449| <<sigbus_handler>> if (qemu_thread_is_self(&memset_thread[i].pgthread)) {
+ *   - util/oslib-posix.c|450| <<sigbus_handler>> siglongjmp(memset_thread[i].env, 1);
+ *   - util/oslib-posix.c|534| <<touch_all_pages>> memset_thread = g_new0(MemsetThread, memset_num_threads);
+ *   - util/oslib-posix.c|538| <<touch_all_pages>> memset_thread[i].addr = addr;
+ *   - util/oslib-posix.c|539| <<touch_all_pages>> memset_thread[i].numpages = numpages_per_thread + (i < leftover);
+ *   - util/oslib-posix.c|540| <<touch_all_pages>> memset_thread[i].hpagesize = hpagesize;
+ *   - util/oslib-posix.c|541| <<touch_all_pages>> qemu_thread_create(&memset_thread[i].pgthread, "touch_pages",
+ *   - util/oslib-posix.c|542| <<touch_all_pages>> do_touch_pages, &memset_thread[i],
+ *   - util/oslib-posix.c|544| <<touch_all_pages>> addr += memset_thread[i].numpages * hpagesize;
+ *   - util/oslib-posix.c|553| <<touch_all_pages>> qemu_thread_join(&memset_thread[i].pgthread);
+ *   - util/oslib-posix.c|555| <<touch_all_pages>> g_free(memset_thread);
+ *   - util/oslib-posix.c|556| <<touch_all_pages>> memset_thread = NULL;
+ */
 static MemsetThread *memset_thread;
 static int memset_num_threads;
 static bool memset_thread_failed;
@@ -514,6 +530,28 @@ static inline int get_memset_num_threads(int smp_cpus)
     return ret;
 }
 
+/*
+ * -object memory-backend-file,id=mem0,size=8000M,prealloc=yes,mem-path=/dev/hugepages_test,share=on
+ * -numa node,memdev=mem0
+ * -m 8000M
+ *
+ * (gdb) bt
+ * #0  0x0000555555e59850 in touch_all_pages (area=0x7ffdf9a00000 "", hpagesize=2097152, numpages=4000, smp_cpus=1) at ../util/oslib-posix.c:522
+ * #1  0x0000555555e59bfd in os_mem_prealloc (fd=12, area=0x7ffdf9a00000 "", memory=8388608000, smp_cpus=1, errp=0x7fffffffdad0) at ../util/oslib-posix.c:581
+ * #2  0x0000555555848abc in host_memory_backend_memory_complete (uc=0x555556ab2a80, errp=0x7fffffffdb48) at ../backends/hostmem.c:393
+ * #3  0x0000555555c9a29b in user_creatable_complete (uc=0x555556ab2a80, errp=0x7fffffffdba8) at ../qom/object_interfaces.c:23
+ * #4  0x0000555555c9a58d in user_creatable_add_type (type=0x5555568c0b60 "memory-backend-file", id=0x5555568c0b40 "mem0", qdict=0x555556ae6480, v=0x555556ab2460, errp=0x555556838c50 <error_fatal>)
+ *                           at ../qom/object_interfaces.c:93
+ * #5  0x0000555555c9a945 in user_creatable_add_opts (opts=0x5555568c0af0, errp=0x555556838c50 <error_fatal>) at ../qom/object_interfaces.c:163
+ * #6  0x0000555555c9aa40 in user_creatable_add_opts_foreach (opaque=0x555555c5e553 <object_create_delayed>, opts=0x5555568c0af0, errp=0x555556838c50 <error_fatal>) at ../qom/object_interfaces.c:186
+ * #7  0x0000555555e51a18 in qemu_opts_foreach (list=0x555556789940 <qemu_object_opts>, func=0x555555c9a9c2 <user_creatable_add_opts_foreach>, opaque=0x555555c5e553 <object_create_delayed>,
+ *                            errp=0x555556838c50 <error_fatal>) at ../util/qemu-option.c:1156
+ * #8  0x0000555555c626d6 in qemu_init (argc=18, argv=0x7fffffffe018, envp=0x7fffffffe0b0) at ../softmmu/vl.c:4271
+ * #9  0x0000555555809b2d in main (argc=18, argv=0x7fffffffe018, envp=0x7fffffffe0b0) at ../softmmu/main.c:49
+ *
+ * called by:
+ *   - util/oslib-posix.c|581| <<os_mem_prealloc>> if (touch_all_pages(area, hpagesize, numpages, smp_cpus)) {
+ */
 static bool touch_all_pages(char *area, size_t hpagesize, size_t numpages,
                             int smp_cpus)
 {
@@ -558,6 +596,11 @@ static bool touch_all_pages(char *area, size_t hpagesize, size_t numpages,
     return memset_thread_failed;
 }
 
+/*
+ * called by:
+ *   - backends/hostmem.c|233| <<host_memory_backend_set_prealloc>> os_mem_prealloc(fd, ptr, sz, backend->prealloc_threads, &local_err);
+ *   - backends/hostmem.c|415| <<host_memory_backend_memory_complete>> os_mem_prealloc(memory_region_get_fd(&backend->mr), ptr, sz,
+ */
 void os_mem_prealloc(int fd, char *area, size_t memory, int smp_cpus,
                      Error **errp)
 {
-- 
2.17.1

