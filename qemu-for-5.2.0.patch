From a2b542fb3a6a139e33f290fffa9814a69bada776 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 11 Jan 2021 09:17:53 -0800
Subject: [PATCH 1/1] qemu for 5.2.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 chardev/char-fe.c             |  20 ++++
 chardev/char-socket.c         |  71 ++++++++++++
 hw/pci/pci.c                  |  11 ++
 hw/scsi/vhost-scsi.c          |  10 ++
 hw/vfio/common.c              | 201 ++++++++++++++++++++++++++++++++++
 hw/vfio/pci.c                 |  75 +++++++++++++
 include/hw/vfio/vfio-common.h |  35 ++++++
 io/channel-socket.c           |   4 +
 io/channel.c                  |  14 +++
 monitor/misc.c                |  97 ++++++++++++++++
 monitor/monitor-internal.h    |  14 +++
 qapi/qmp-dispatch.c           |  12 ++
 target/i386/helper.c          |  10 ++
 target/i386/kvm.c             |   4 +
 14 files changed, 578 insertions(+)

diff --git a/chardev/char-fe.c b/chardev/char-fe.c
index 474715c5a..95bf751df 100644
--- a/chardev/char-fe.c
+++ b/chardev/char-fe.c
@@ -110,6 +110,16 @@ int qemu_chr_fe_ioctl(CharBackend *be, int cmd, void *arg)
     return res;
 }
 
+/*
+ * called by:
+ *   - hw/display/vhost-user-gpu.c|209| <<vhost_user_gpu_handle_display>> int fd = qemu_chr_fe_get_msgfd(&g->vhost_chr);
+ *   - hw/misc/ivshmem.c|599| <<ivshmem_read>> fd = qemu_chr_fe_get_msgfd(&s->server_chr);
+ *   - hw/misc/ivshmem.c|626| <<ivshmem_recv_msg>> *pfd = qemu_chr_fe_get_msgfd(&s->server_chr);
+ *   - hw/virtio/vhost-user.c|1681| <<vhost_user_postcopy_advise>> ufd = qemu_chr_fe_get_msgfd(chr);
+ *   - hw/virtio/vhost-user.c|2278| <<vhost_user_get_inflight_fd>> fd = qemu_chr_fe_get_msgfd(chr);
+ *   - monitor/misc.c|1233| <<qmp_getfd>> fd = qemu_chr_fe_get_msgfd(&cur_mon->chr);
+ *   - monitor/misc.c|1372| <<qmp_add_fd>> fd = qemu_chr_fe_get_msgfd(&mon->chr);
+ */
 int qemu_chr_fe_get_msgfd(CharBackend *be)
 {
     Chardev *s = be->chr;
@@ -123,6 +133,13 @@ int qemu_chr_fe_get_msgfd(CharBackend *be)
     return res;
 }
 
+/*
+ * called by:
+ *   - chardev/char-fe.c|127| <<qemu_chr_fe_get_msgfd>> int res = (qemu_chr_fe_get_msgfds(be, &fd, 1) == 1) ? fd : -1;
+ *   - tests/qtest/vhost-user-test.c|381| <<chr_read>> s->fds_num = qemu_chr_fe_get_msgfds(chr, s->fds,
+ *   - tests/qtest/vhost-user-test.c|391| <<chr_read>> qemu_chr_fe_get_msgfds(chr, &fd, 1);
+ *   - tests/qtest/vhost-user-test.c|405| <<chr_read>> qemu_chr_fe_get_msgfds(chr, &s->log_fd, 1);
+ */
 int qemu_chr_fe_get_msgfds(CharBackend *be, int *fds, int len)
 {
     Chardev *s = be->chr;
@@ -131,6 +148,9 @@ int qemu_chr_fe_get_msgfds(CharBackend *be, int *fds, int len)
         return -1;
     }
 
+    /*
+     * 似乎目前只能是tcp_get_msgfds()或者NULL
+     */
     return CHARDEV_GET_CLASS(s)->get_msgfds ?
         CHARDEV_GET_CLASS(s)->get_msgfds(s, fds, len) : -1;
 }
diff --git a/chardev/char-socket.c b/chardev/char-socket.c
index 213a4c8dd..56f7fcbef 100644
--- a/chardev/char-socket.c
+++ b/chardev/char-socket.c
@@ -66,7 +66,34 @@ struct SocketChardev {
     int max_size;
     int do_telnetopt;
     int do_nodelay;
+    /*
+     * 在以下使用SocketChadev->read_msgfds:
+     *   - chardev/char-socket.c|301| <<tcp_get_msgfds>> memcpy(fds, s->read_msgfds, to_copy * sizeof(int ));
+     *   - chardev/char-socket.c|305| <<tcp_get_msgfds>> close(s->read_msgfds[i]);
+     *   - chardev/char-socket.c|308| <<tcp_get_msgfds>> g_free(s->read_msgfds);
+     *   - chardev/char-socket.c|309| <<tcp_get_msgfds>> s->read_msgfds = 0;
+     *   - chardev/char-socket.c|375| <<tcp_chr_recv>> close(s->read_msgfds[i]);
+     *   - chardev/char-socket.c|379| <<tcp_chr_recv>> g_free(s->read_msgfds);
+     *   - chardev/char-socket.c|382| <<tcp_chr_recv>> s->read_msgfds = msgfds;
+     *   - chardev/char-socket.c|387| <<tcp_chr_recv>> int fd = s->read_msgfds[i];
+     *   - chardev/char-socket.c|425| <<tcp_chr_free_connection>> close(s->read_msgfds[i]);
+     *   - chardev/char-socket.c|427| <<tcp_chr_free_connection>> g_free(s->read_msgfds);
+     *   - chardev/char-socket.c|428| <<tcp_chr_free_connection>> s->read_msgfds = NULL;
+     */
     int *read_msgfds;
+    /*
+     * 在以下使用SocketChardev->read_msgfds_num:
+     *   - chardev/char-socket.c|281| <<tcp_get_msgfds>> int to_copy = (s->read_msgfds_num < num) ? s->read_msgfds_num : num;
+     *   - chardev/char-socket.c|291| <<tcp_get_msgfds>> for (i = to_copy; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|297| <<tcp_get_msgfds>> s->read_msgfds_num = 0;
+     *   - chardev/char-socket.c|356| <<tcp_chr_recv>> for (i = 0; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|360| <<tcp_chr_recv>> if (s->read_msgfds_num) {
+     *   - chardev/char-socket.c|365| <<tcp_chr_recv>> s->read_msgfds_num = msgfds_num;
+     *   - chardev/char-socket.c|368| <<tcp_chr_recv>> for (i = 0; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|405| <<tcp_chr_free_connection>> if (s->read_msgfds_num) {
+     *   - chardev/char-socket.c|406| <<tcp_chr_free_connection>> for (i = 0; i < s->read_msgfds_num; i++) {
+     *   - chardev/char-socket.c|411| <<tcp_chr_free_connection>> s->read_msgfds_num = 0;
+     */
     size_t read_msgfds_num;
     int *write_msgfds;
     size_t write_msgfds_num;
@@ -274,6 +301,10 @@ static void tcp_chr_process_IAC_bytes(Chardev *chr,
     *size = j;
 }
 
+/*
+ * 在以下使用tcp_get_msgfds():
+ *   - chardev/char-socket.c|1546| <<char_socket_class_init>> cc->get_msgfds = tcp_get_msgfds;
+ */
 static int tcp_get_msgfds(Chardev *chr, int *fds, int num)
 {
     SocketChardev *s = SOCKET_CHARDEV(chr);
@@ -293,7 +324,19 @@ static int tcp_get_msgfds(Chardev *chr, int *fds, int num)
         }
 
         g_free(s->read_msgfds);
+	/*
+	 * 在以下设置SocketChadev->read_msgfds:
+	 *   - chardev/char-socket.c|309| <<tcp_get_msgfds>> s->read_msgfds = 0;
+	 *   - chardev/char-socket.c|382| <<tcp_chr_recv>> s->read_msgfds = msgfds;
+	 *   - chardev/char-socket.c|428| <<tcp_chr_free_connection>> s->read_msgfds = NULL;
+	 */
         s->read_msgfds = 0;
+	/*
+	 * 在以下使用SocketChardev->read_msgfds_num:
+	 *   - chardev/char-socket.c|297| <<tcp_get_msgfds>> s->read_msgfds_num = 0;
+	 *   - chardev/char-socket.c|365| <<tcp_chr_recv>> s->read_msgfds_num = msgfds_num;
+	 *   - chardev/char-socket.c|411| <<tcp_chr_free_connection>> s->read_msgfds_num = 0;
+	 */
         s->read_msgfds_num = 0;
     }
 
@@ -325,6 +368,23 @@ static int tcp_set_msgfds(Chardev *chr, int *fds, int num)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000556f1cc82048 in tcp_chr_recv (chr=0x556f1eea62b0, buf=0x7efed630d750 "", len=1) at ../chardev/char-socket.c:329
+ * #1  0x0000556f1cc828c0 in tcp_chr_read (chan=0x7efed0002150, cond=G_IO_IN, opaque=0x556f1eea62b0) at ../chardev/char-socket.c:536
+ * #2  0x0000556f1cc71f9a in qio_channel_fd_source_dispatch (source=0x7efed0002000, callback=0x556f1cc827e5 <tcp_chr_read>, user_data=0x556f1eea62b0) at ../io/channel-watch.c:84
+ * #3  0x00007efedfbbd099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #4  0x00007efedfbbd3f8 in g_main_context_iterate.isra () at /lib/../lib64/libglib-2.0.so.0
+ * #5  0x00007efedfbbd6ca in g_main_loop_run () at /lib/../lib64/libglib-2.0.so.0
+ * #6  0x0000556f1cb987b4 in iothread_run (opaque=0x556f1eeb9d00) at ../iothread.c:80
+ * #7  0x0000556f1cd31abc in qemu_thread_start (args=0x556f1eea83e0) at ../util/qemu-thread-posix.c:521
+ * #8  0x00007efeddba5ea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #9  0x00007efedd8ce8cd in clone () at /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - chardev/char-socket.c|536| <<tcp_chr_read>> size = tcp_chr_recv(chr, (void *)buf, len);
+ *   - chardev/char-socket.c|571| <<tcp_chr_sync_read>> size = tcp_chr_recv(chr, (void *) buf, len);
+ */
 static ssize_t tcp_chr_recv(Chardev *chr, char *buf, size_t len)
 {
     SocketChardev *s = SOCKET_CHARDEV(chr);
@@ -518,6 +578,13 @@ static void tcp_chr_disconnect(Chardev *chr)
     qemu_mutex_unlock(&chr->chr_write_lock);
 }
 
+/*
+ * 在update_ioc_handlers()使用tcp_chr_read():
+ *  681     chr->gsource = io_add_watch_poll(chr, s->ioc,
+ *  682                                      tcp_chr_read_poll,
+ *  683                                      tcp_chr_read, chr,
+ *  684                                      chr->gcontext);
+ */
 static gboolean tcp_chr_read(QIOChannel *chan, GIOCondition cond, void *opaque)
 {
     Chardev *chr = CHARDEV(opaque);
@@ -558,6 +625,10 @@ static gboolean tcp_chr_hup(QIOChannel *channel,
     return G_SOURCE_REMOVE;
 }
 
+/*
+ * 在以下使用tcp_chr_sync_read():
+ *   - chardev/char-socket.c|1560| <<char_socket_class_init>> cc->chr_sync_read = tcp_chr_sync_read;
+ */
 static int tcp_chr_sync_read(Chardev *chr, const uint8_t *buf, int len)
 {
     SocketChardev *s = SOCKET_CHARDEV(chr);
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index 0131d9d02..e42b667c9 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -1325,6 +1325,12 @@ static pcibus_t pci_bar_address(PCIDevice *d,
     return new_addr;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|330| <<pci_do_device_reset>> pci_update_mappings(dev);
+ *   - hw/pci/pci.c|545| <<get_pci_config_device>> pci_update_mappings(s);
+ *   - hw/pci/pci.c|1421| <<pci_default_write_config>> pci_update_mappings(d);
+ */
 static void pci_update_mappings(PCIDevice *d)
 {
     PCIIORegion *r;
@@ -2668,6 +2674,11 @@ static void pci_device_class_base_init(ObjectClass *klass, void *data)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|96| <<pci_init_bus_master>> AddressSpace *dma_as = pci_device_iommu_address_space(pci_dev);
+ *   - hw/vfio/pci.c|2824| <<vfio_realize>> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
+ */
 AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
 {
     PCIBus *bus = pci_get_bus(dev);
diff --git a/hw/scsi/vhost-scsi.c b/hw/scsi/vhost-scsi.c
index 4d70fa036..f67233d4f 100644
--- a/hw/scsi/vhost-scsi.c
+++ b/hw/scsi/vhost-scsi.c
@@ -177,6 +177,16 @@ static void vhost_scsi_realize(DeviceState *dev, Error **errp)
     }
 
     if (vs->conf.vhostfd) {
+        /*
+	 * 在以下使用monitor_fd_param():
+	 *   - hw/scsi/vhost-scsi.c|180| <<vhost_scsi_realize>> vhostfd = monitor_fd_param(monitor_cur(), vs->conf.vhostfd, errp);
+	 *   - hw/virtio/vhost-vsock.c|147| <<vhost_vsock_device_realize>> vhostfd = monitor_fd_param(monitor_cur(), vsock->conf.vhostfd, errp);
+	 *   - migration/fd.c|58| <<fd_start_incoming_migration>> int fd = monitor_fd_param(monitor_cur(), fdname, errp);
+	 *   - net/socket.c|730| <<net_init_socket>> fd = monitor_fd_param(monitor_cur(), sock->fd, errp);
+	 *   - net/tap.c|703| <<net_init_tap_one>> vhostfd = monitor_fd_param(monitor_cur(), vhostfdname, &err);
+	 *   - net/tap.c|811| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), tap->fd, errp);
+	 *   - net/tap.c|867| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), fds[i], errp);
+	 */
         vhostfd = monitor_fd_param(monitor_cur(), vs->conf.vhostfd, errp);
         if (vhostfd == -1) {
             error_prepend(errp, "vhost-scsi: unable to parse vhostfd: ");
diff --git a/hw/vfio/common.c b/hw/vfio/common.c
index 6ff1daa76..3c52c0220 100644
--- a/hw/vfio/common.c
+++ b/hw/vfio/common.c
@@ -40,8 +40,30 @@
 #include "qapi/error.h"
 #include "migration/migration.h"
 
+/*
+ * 在以下使用vfio_group_list:
+ *   - hw/vfio/common.c|44| <<global>> QLIST_HEAD_INITIALIZER(vfio_group_list);
+ *   - hw/vfio/common.c|309| <<vfio_mig_active>> if (QLIST_EMPTY(&vfio_group_list)) {
+ *   - hw/vfio/common.c|313| <<vfio_mig_active>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|1520| <<vfio_reset_handler>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|1528| <<vfio_reset_handler>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|2009| <<vfio_get_group>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/common.c|2053| <<vfio_get_group>> if (QLIST_EMPTY(&vfio_group_list)) {
+ *   - hw/vfio/common.c|2057| <<vfio_get_group>> QLIST_INSERT_HEAD(&vfio_group_list, group, next);
+ *   - hw/vfio/common.c|2086| <<vfio_put_group>> if (QLIST_EMPTY(&vfio_group_list)) {
+ *   - hw/vfio/pci.c|2249| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/pci.c|2292| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/pci.c|2306| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ *   - hw/vfio/pci.c|2338| <<vfio_pci_hot_reset>> QLIST_FOREACH(group, &vfio_group_list, next) {
+ */
 VFIOGroupList vfio_group_list =
     QLIST_HEAD_INITIALIZER(vfio_group_list);
+/*
+ * 在以下使用vfio_address_spaces:
+ *   - hw/vfio/common.c|46| <<QLIST_HEAD>> QLIST_HEAD_INITIALIZER(vfio_address_spaces);
+ *   - hw/vfio/common.c|1594| <<vfio_get_address_space>> QLIST_FOREACH(space, &vfio_address_spaces, list) {
+ *   - hw/vfio/common.c|1605| <<vfio_get_address_space>> QLIST_INSERT_HEAD(&vfio_address_spaces, space, list);
+ */
 static QLIST_HEAD(, VFIOAddressSpace) vfio_address_spaces =
     QLIST_HEAD_INITIALIZER(vfio_address_spaces);
 
@@ -53,6 +75,15 @@ static QLIST_HEAD(, VFIOAddressSpace) vfio_address_spaces =
  * initialized, this file descriptor is only released on QEMU exit and
  * we'll re-use it should another vfio device be attached before then.
  */
+/*
+ * 在以下使用vfio_kvm_device_fd:
+ *   - hw/vfio/common.c|746| <<vfio_listener_region_add>> if (ioctl(vfio_kvm_device_fd, KVM_SET_DEVICE_ATTR, &attr)) {
+ *   - hw/vfio/common.c|1490| <<vfio_kvm_device_add_group>> if (vfio_kvm_device_fd < 0) {
+ *   - hw/vfio/common.c|1500| <<vfio_kvm_device_add_group>> vfio_kvm_device_fd = cd.fd;
+ *   - hw/vfio/common.c|1503| <<vfio_kvm_device_add_group>> if (ioctl(vfio_kvm_device_fd, KVM_SET_DEVICE_ATTR, &attr)) {
+ *   - hw/vfio/common.c|1519| <<vfio_kvm_device_del_group>> if (vfio_kvm_device_fd < 0) {
+ *   - hw/vfio/common.c|1523| <<vfio_kvm_device_del_group>> if (ioctl(vfio_kvm_device_fd, KVM_SET_DEVICE_ATTR, &attr)) {
+ */
 static int vfio_kvm_device_fd = -1;
 #endif
 
@@ -274,6 +305,10 @@ uint64_t vfio_region_read(void *opaque,
     return data;
 }
 
+/*
+ * 在以下使用vfio_region_ops:
+ *   - hw/vfio/common.c|1366| <<vfio_region_setup>> memory_region_init_io(region->mem, obj, &vfio_region_ops,
+ */
 const MemoryRegionOps vfio_region_ops = {
     .read = vfio_region_read,
     .write = vfio_region_write,
@@ -372,6 +407,10 @@ static bool vfio_devices_all_running_and_saving(VFIOContainer *container)
     return true;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|476| <<vfio_dma_unmap>> return vfio_dma_unmap_bitmap(container, iova, size, iotlb);
+ */
 static int vfio_dma_unmap_bitmap(VFIOContainer *container,
                                  hwaddr iova, ram_addr_t size,
                                  IOMMUTLBEntry *iotlb)
@@ -429,6 +468,13 @@ unmap_exit:
 /*
  * DMA - Mapping and unmapping for the "type1" IOMMU interface used on x86
  */
+/*
+ * called by:
+ *   - hw/vfio/common.c|582| <<vfio_dma_map>> (errno == EBUSY && vfio_dma_unmap(container, iova, size, NULL) == 0 &&
+ *   - hw/vfio/common.c|736| <<vfio_iommu_map_notify>> ret = vfio_dma_unmap(container, iova, iotlb->addr_mask + 1, iotlb);
+ *   - hw/vfio/common.c|1050| <<vfio_listener_region_del>> ret = vfio_dma_unmap(container, iova, int128_get64(llsize), NULL);
+ *   - hw/vfio/common.c|1058| <<vfio_listener_region_del>> ret = vfio_dma_unmap(container, iova, int128_get64(llsize), NULL);
+ */
 static int vfio_dma_unmap(VFIOContainer *container,
                           hwaddr iova, ram_addr_t size,
                           IOMMUTLBEntry *iotlb)
@@ -471,6 +517,62 @@ static int vfio_dma_unmap(VFIOContainer *container,
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555bbdd6a in vfio_dma_map (container=0x55555798cfe0, iova=1048576, size=3144679424, vaddr=0x7fff32100000, readonly=false) at ../hw/vfio/common.c:476
+ * #1  0x0000555555bbee65 in vfio_listener_region_add (listener=0x55555798cff0, section=0x7fffffffc720) at ../hw/vfio/common.c:838
+ * #2  0x0000555555c53adb in listener_add_address_space (listener=0x55555798cff0, as=0x55555681a340 <address_space_memory>) at ../softmmu/memory.c:2720
+ * #3  0x0000555555c53ef5 in memory_listener_register (listener=0x55555798cff0, as=0x55555681a340 <address_space_memory>) at ../softmmu/memory.c:2787
+ * #4  0x0000555555bc1a36 in vfio_connect_container (group=0x55555798cf60, as=0x55555681a340 <address_space_memory>, errp=0x7fffffffda08) at ../hw/vfio/common.c:1853
+ * #5  0x0000555555bc2020 in vfio_get_group (groupid=85, as=0x55555681a340 <address_space_memory>, errp=0x7fffffffda08) at ../hw/vfio/common.c:1970
+ * #6  0x0000555555b8db34 in vfio_realize (pdev=0x555557986940, errp=0x7fffffffda08) at ../hw/vfio/pci.c:2819
+ * #7  0x00005555559004df in pci_qdev_realize (qdev=0x555557986940, errp=0x7fffffffda80) at ../hw/pci/pci.c:2123
+ * #8  0x0000555555da15dd in device_set_realized (obj=0x555557986940, value=true, errp=0x7fffffffdb88) at ../hw/core/qdev.c:886
+ * #9  0x0000555555d7cb09 in property_set_bool (obj=0x555557986940, v=0x5555579878f0, name=0x555555ff4311 "realized", opaque=0x5555568c5230, errp=0x7fffffffdb88) at ../qom/object.c:2251
+ * #10 0x0000555555d7ac2b in object_property_set (obj=0x555557986940, name=0x555555ff4311 "realized", v=0x5555579878f0, errp=0x555556837f40 <error_fatal>) at ../qom/object.c:1398
+ * #11 0x0000555555d7de1b in object_property_set_qobject (obj=0x555557986940, name=0x555555ff4311 "realized", value=0x555557987830, errp=0x555556837f40 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #12 0x0000555555d7af70 in object_property_set_bool (obj=0x555557986940, name=0x555555ff4311 "realized", value=true, errp=0x555556837f40 <error_fatal>) at ../qom/object.c:1465
+ * #13 0x0000555555da01fc in qdev_realize (dev=0x555557986940, bus=0x555556d49d80, errp=0x555556837f40 <error_fatal>) at ../hw/core/qdev.c:399
+ * #14 0x0000555555a0c402 in qdev_device_add (opts=0x5555568c02b0, errp=0x555556837f40 <error_fatal>) at ../softmmu/qdev-monitor.c:676
+ * #15 0x0000555555ba5db6 in device_init_func (opaque=0x0, opts=0x5555568c02b0, errp=0x555556837f40 <error_fatal>) at ../softmmu/vl.c:2104
+ * #16 0x0000555555e6d9a0 in qemu_opts_foreach (list=0x555556755d20 <qemu_device_opts>, func=0x555555ba5d8f <device_init_func>, opaque=0x0, errp=0x555556837f40 <error_fatal>) at ../util/qemu-option.c:1156
+ * #17 0x0000555555bab329 in qemu_init (argc=16, argv=0x7fffffffe0b8, envp=0x7fffffffe140) at ../softmmu/vl.c:4398
+ * #18 0x0000555555809b2d in main (argc=16, argv=0x7fffffffe0b8, envp=0x7fffffffe140) at ../softmmu/main.c:49
+ *
+ * (gdb) bt
+ * #0  0x0000555555bbdd6a in vfio_dma_map (container=0x55555798cfe0, iova=4269805568, size=28672, vaddr=0x7fffed83b000, readonly=false) at ../hw/vfio/common.c:476
+ * #1  0x0000555555bbee65 in vfio_listener_region_add (listener=0x55555798cff0, section=0x7fff317fd1f0) at ../hw/vfio/common.c:838
+ * #2  0x0000555555c4f2db in address_space_update_topology_pass (as=0x55555681a340 <address_space_memory>, old_view=0x7fff245c7310, new_view=0x7fff245f5f60, adding=true) at ../softmmu/memory.c:971
+ * #3  0x0000555555c4f5d5 in address_space_set_flatview (as=0x55555681a340 <address_space_memory>) at ../softmmu/memory.c:1047
+ * #4  0x0000555555c4f77c in memory_region_transaction_commit () at ../softmmu/memory.c:1099
+ * #5  0x0000555555c52d72 in memory_region_update_container_subregions (subregion=0x5555579e92d0) at ../softmmu/memory.c:2428
+ * #6  0x0000555555c52dd9 in memory_region_add_subregion_common (mr=0x555556c4afe0, offset=4269801472, subregion=0x5555579e92d0) at ../softmmu/memory.c:2438
+ * #7  0x0000555555c52e53 in memory_region_add_subregion_overlap (mr=0x555556c4afe0, offset=4269801472, subregion=0x5555579e92d0, priority=1) at ../softmmu/memory.c:2455
+ * #8  0x00005555558fea23 in pci_update_mappings (d=0x555557986940) at ../hw/pci/pci.c:1361
+ * #9  0x00005555558fede4 in pci_default_write_config (d=0x555557986940, addr=4, val_in=326, l=2) at ../hw/pci/pci.c:1421
+ * #10 0x0000555555b898ef in vfio_pci_write_config (pdev=0x555557986940, addr=4, val=326, len=2) at ../hw/vfio/pci.c:1185
+ * #11 0x00005555558dca39 in pci_host_config_write_common (pci_dev=0x555557986940, addr=4, limit=256, val=326, len=2) at ../hw/pci/pci_host.c:83
+ * #12 0x00005555558dcb9d in pci_data_write (s=0x555556d49d80, addr=2147491844, val=326, len=2) at ../hw/pci/pci_host.c:120
+ * #13 0x00005555558dccc3 in pci_host_data_write (opaque=0x555556d48d10, addr=0, val=326, len=2) at ../hw/pci/pci_host.c:167
+ * #14 0x0000555555c4d454 in memory_region_write_accessor (mr=0x555556d49120, addr=0, value=0x7fff317fd688, size=2, shift=0, mask=65535, attrs=...) at ../softmmu/memory.c:491
+ * #15 0x0000555555c4d678 in access_with_adjusted_size (addr=0, value=0x7fff317fd688, size=2, access_size_min=1, access_size_max=4, access_fn=
+ *     0x555555c4d36f <memory_region_write_accessor>, mr=0x555556d49120, attrs=...) at ../softmmu/memory.c:552
+ * #16 0x0000555555c50681 in memory_region_dispatch_write (mr=0x555556d49120, addr=0, data=326, op=MO_16, attrs=...) at ../softmmu/memory.c:1501
+ * #17 0x0000555555bd91bb in flatview_write_continue (fv=0x7fff24595d10, addr=3324, attrs=..., ptr=0x7ffff7fdf000, len=2, addr1=0, l=2, mr=0x555556d49120) at ../softmmu/physmem.c:2759
+ * #18 0x0000555555bd9300 in flatview_write (fv=0x7fff24595d10, addr=3324, attrs=..., buf=0x7ffff7fdf000, len=2) at ../softmmu/physmem.c:2799
+ * #19 0x0000555555bd966e in address_space_write (as=0x55555681a2e0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7fdf000, len=2) at ../softmmu/physmem.c:2891
+ * #20 0x0000555555bd96db in address_space_rw (as=0x55555681a2e0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7fdf000, len=2, is_write=true) at ../softmmu/physmem.c:2901
+ * #21 0x0000555555c2515a in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7fdf000, direction=1, size=2, count=1) at ../accel/kvm/kvm-all.c:2285
+ * #22 0x0000555555c25911 in kvm_cpu_exec (cpu=0x555556b3ba10) at ../accel/kvm/kvm-all.c:2531
+ * #23 0x0000555555c801fe in kvm_vcpu_thread_fn (arg=0x555556b3ba10) at ../accel/kvm/kvm-cpus.c:49
+ * #24 0x0000555555e40abc in qemu_thread_start (args=0x555556b621d0) at ../util/qemu-thread-posix.c:521
+ * #25 0x00007ffff542fea5 in start_thread () at /lib/../lib64/libpthread.so.0
+ * #26 0x00007ffff51588cd in clone () at /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/vfio/common.c|635| <<vfio_iommu_map_notify>> ret = vfio_dma_map(container, iova,
+ *   - hw/vfio/common.c|838| <<vfio_listener_region_add>> ret = vfio_dma_map(container, iova, int128_get64(llsize),
+ */
 static int vfio_dma_map(VFIOContainer *container, hwaddr iova,
                         ram_addr_t size, void *vaddr, bool readonly)
 {
@@ -501,6 +603,12 @@ static int vfio_dma_map(VFIOContainer *container, hwaddr iova,
     return -errno;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|810| <<vfio_listener_region_add>> vfio_host_win_add(container, section->offset_within_address_space,
+ *   - hw/vfio/common.c|1882| <<vfio_connect_container>> vfio_host_win_add(container, 0, (hwaddr)-1, info->iova_pgsizes);
+ *   - hw/vfio/common.c|1952| <<vfio_connect_container>> vfio_host_win_add(container, info.dma32_window_start,
+ */
 static void vfio_host_win_add(VFIOContainer *container,
                               hwaddr min_iova, hwaddr max_iova,
                               uint64_t iova_pgsizes)
@@ -553,6 +661,11 @@ static bool vfio_listener_skipped_section(MemoryRegionSection *section)
 }
 
 /* Called with rcu_read_lock held.  */
+/*
+ * called by:
+ *   - hw/vfio/common.c|716| <<vfio_iommu_map_notify>> if (!vfio_get_xlat_addr(iotlb, &vaddr, NULL, &read_only)) {
+ *   - hw/vfio/common.c|1156| <<vfio_iommu_map_dirty_notify>> if (vfio_get_xlat_addr(iotlb, NULL, &translated_addr, NULL)) {
+ */
 static bool vfio_get_xlat_addr(IOMMUTLBEntry *iotlb, void **vaddr,
                                ram_addr_t *ram_addr, bool *read_only)
 {
@@ -600,6 +713,10 @@ static bool vfio_get_xlat_addr(IOMMUTLBEntry *iotlb, void **vaddr,
     return true;
 }
 
+/*
+ * 在以下使用vfio_iommu_map_notify():
+ *   - hw/vfio/common.c|789| <<vfio_listener_region_add>> iommu_notifier_init(&giommu->n, vfio_iommu_map_notify,
+ */
 static void vfio_iommu_map_notify(IOMMUNotifier *n, IOMMUTLBEntry *iotlb)
 {
     VFIOGuestIOMMU *giommu = container_of(n, VFIOGuestIOMMU, n);
@@ -1044,6 +1161,15 @@ typedef struct {
     VFIOGuestIOMMU *giommu;
 } vfio_giommu_dirty_notifier;
 
+/*
+ * 只在vfio_sync_dirty_bitmap()使用:
+ * 1217                 iommu_notifier_init(&gdn.n,
+ * 1218                                     vfio_iommu_map_dirty_notify,
+ * 1219                                     IOMMU_NOTIFIER_MAP,
+ * 1220                                     section->offset_within_region,
+ * 1221                                     int128_get64(llend),
+ * 1222                                     idx);
+ */
 static void vfio_iommu_map_dirty_notify(IOMMUNotifier *n, IOMMUTLBEntry *iotlb)
 {
     vfio_giommu_dirty_notifier *gdn = container_of(n,
@@ -1133,12 +1259,21 @@ static void vfio_listerner_log_sync(MemoryListener *listener,
     }
 }
 
+/*
+ * 在以下使用vfio_memory_listener:
+ *   - hw/vfio/common.c|1851| <<vfio_connect_container>> container->listener = vfio_memory_listener;
+ */
 static const MemoryListener vfio_memory_listener = {
     .region_add = vfio_listener_region_add,
     .region_del = vfio_listener_region_del,
     .log_sync = vfio_listerner_log_sync,
 };
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|2012| <<vfio_connect_container>> vfio_listener_release(container);
+ *   - hw/vfio/common.c|2040| <<vfio_disconnect_container>> vfio_listener_release(container);
+ */
 static void vfio_listener_release(VFIOContainer *container)
 {
     memory_listener_unregister(&container->listener);
@@ -1191,6 +1326,10 @@ vfio_get_device_info_cap(struct vfio_device_info *info, uint16_t id)
     return vfio_get_cap((void *)info, info->cap_offset, id);
 }
 
+/*
+ * called only by:
+ *   - hw/s390x/s390-pci-vfio.c|58| <<s390_pci_update_dma_avail>> return vfio_get_info_dma_avail(info, avail);
+ */
 bool vfio_get_info_dma_avail(struct vfio_iommu_type1_info *info,
                              unsigned int *avail)
 {
@@ -1212,6 +1351,10 @@ bool vfio_get_info_dma_avail(struct vfio_iommu_type1_info *info,
     return true;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1416| <<vfio_region_setup>> ret = vfio_setup_region_sparse_mmaps(region, info);
+ */
 static int vfio_setup_region_sparse_mmaps(VFIORegion *region,
                                           struct vfio_region_info *info)
 {
@@ -1304,6 +1447,14 @@ static void vfio_subregion_unmap(VFIORegion *region, int index)
     region->mmaps[index].mmap = NULL;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/display.c|444| <<vfio_display_region_update>> ret = vfio_region_mmap(&dpy->region.buffer);
+ *   - hw/vfio/migration.c|456| <<vfio_save_setup>> ret = vfio_region_mmap(&migration->region);
+ *   - hw/vfio/migration.c|630| <<vfio_load_setup>> ret = vfio_region_mmap(&migration->region);
+ *   - hw/vfio/pci.c|1649| <<vfio_bar_register>> if (vfio_region_mmap(&bar->region)) {
+ *   - hw/vfio/platform.c|659| <<vfio_platform_realize>> if (vfio_region_mmap(vdev->regions[i])) {
+ */
 int vfio_region_mmap(VFIORegion *region)
 {
     int i, prot = 0;
@@ -1316,6 +1467,14 @@ int vfio_region_mmap(VFIORegion *region)
     prot |= region->flags & VFIO_REGION_INFO_FLAG_READ ? PROT_READ : 0;
     prot |= region->flags & VFIO_REGION_INFO_FLAG_WRITE ? PROT_WRITE : 0;
 
+    /*
+     * 在以下修改VFIORegion:
+     *   - hw/vfio/common.c|1389| <<vfio_setup_region_sparse_mmaps>> region->nr_mmaps = j;
+     *   - hw/vfio/common.c|1423| <<vfio_region_setup>> region->nr_mmaps = 1;
+     *   - hw/vfio/common.c|1569| <<vfio_region_finalize>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1300| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1322| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 2;
+     */
     for (i = 0; i < region->nr_mmaps; i++) {
         region->mmaps[i].mmap = mmap(NULL, region->mmaps[i].size, prot,
                                      MAP_SHARED, region->vbasedev->fd,
@@ -1461,6 +1620,11 @@ void vfio_reset_handler(void *opaque)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1874| <<vfio_connect_container>> vfio_kvm_device_add_group(group);
+ *   - hw/vfio/common.c|2004| <<vfio_connect_container>> vfio_kvm_device_add_group(group);
+ */
 static void vfio_kvm_device_add_group(VFIOGroup *group)
 {
 #ifdef CONFIG_KVM
@@ -1514,10 +1678,28 @@ static void vfio_kvm_device_del_group(VFIOGroup *group)
 #endif
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1752| <<vfio_connect_container>> space = vfio_get_address_space(as);
+ *   - hw/vfio/common.c|2294| <<vfio_eeh_as_container>> VFIOAddressSpace *space = vfio_get_address_space(as);
+ */
 static VFIOAddressSpace *vfio_get_address_space(AddressSpace *as)
 {
+    /*
+     * typedef struct VFIOAddressSpace {
+     *     AddressSpace *as;
+     *     QLIST_HEAD(, VFIOContainer) containers;
+     *     QLIST_ENTRY(VFIOAddressSpace) list;
+     * } VFIOAddressSpace;
+     */
     VFIOAddressSpace *space;
 
+    /*
+     * 在以下使用vfio_address_spaces:
+     *   - hw/vfio/common.c|46| <<QLIST_HEAD>> QLIST_HEAD_INITIALIZER(vfio_address_spaces);
+     *   - hw/vfio/common.c|1594| <<vfio_get_address_space>> QLIST_FOREACH(space, &vfio_address_spaces, list) {
+     *   - hw/vfio/common.c|1605| <<vfio_get_address_space>> QLIST_INSERT_HEAD(&vfio_address_spaces, space, list);
+     */
     QLIST_FOREACH(space, &vfio_address_spaces, list) {
         if (space->as == as) {
             return space;
@@ -1665,6 +1847,10 @@ static void vfio_get_iommu_info_migration(VFIOContainer *container,
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/common.c|1970| <<vfio_get_group>> if (vfio_connect_container(group, as, errp)) {
+ */
 static int vfio_connect_container(VFIOGroup *group, AddressSpace *as,
                                   Error **errp)
 {
@@ -1923,6 +2109,13 @@ static void vfio_disconnect_container(VFIOGroup *group)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/ap.c|86| <<vfio_ap_get_group>> return vfio_get_group(groupid, &address_space_memory, errp);
+ *   - hw/vfio/ccw.c|627| <<vfio_ccw_get_group>> return vfio_get_group(groupid, &address_space_memory, errp);
+ *   - hw/vfio/pci.c|2824| <<vfio_realize>> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
+ *   - hw/vfio/platform.c|580| <<vfio_base_device_init>> group = vfio_get_group(groupid, &address_space_memory, errp);
+ */
 VFIOGroup *vfio_get_group(int groupid, AddressSpace *as, Error **errp)
 {
     VFIOGroup *group;
@@ -2243,6 +2436,14 @@ bool vfio_eeh_as_ok(AddressSpace *as)
     return (container != NULL) && vfio_eeh_container_ok(container);
 }
 
+/*
+ * 只被ppc调用:
+ *   - hw/ppc/spapr_pci_vfio.c|37| <<spapr_phb_vfio_eeh_reenable>> vfio_eeh_as_op(&sphb->iommu_as, VFIO_EEH_PE_ENABLE);
+ *   - hw/ppc/spapr_pci_vfio.c|90| <<spapr_phb_vfio_eeh_set_option>> ret = vfio_eeh_as_op(&sphb->iommu_as, op);
+ *   - hw/ppc/spapr_pci_vfio.c|102| <<spapr_phb_vfio_eeh_get_state>> ret = vfio_eeh_as_op(&sphb->iommu_as, VFIO_EEH_PE_GET_STATE);
+ *   - hw/ppc/spapr_pci_vfio.c|175| <<spapr_phb_vfio_eeh_reset>> ret = vfio_eeh_as_op(&sphb->iommu_as, op);
+ *   - hw/ppc/spapr_pci_vfio.c|187| <<spapr_phb_vfio_eeh_configure>> ret = vfio_eeh_as_op(&sphb->iommu_as, VFIO_EEH_PE_CONFIGURE);
+ */
 int vfio_eeh_as_op(AddressSpace *as, uint32_t op)
 {
     VFIOContainer *container = vfio_eeh_as_container(as);
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 51dc37369..f9c7ff758 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -330,6 +330,11 @@ static void vfio_intx_disable(VFIOPCIDevice *vdev)
 /*
  * MSI/X
  */
+/*
+ * 在以下使用vfio_msi_interrupt():
+ *   - hw/vfio/pci.c|540| <<vfio_msix_vector_use>> return vfio_msix_vector_do_use(pdev, nr, &msg, vfio_msi_interrupt);
+ *   - hw/vfio/pci.c|623| <<vfio_msi_enable>> qemu_set_fd_handler(event_notifier_get_fd(&vector->interrupt), vfio_msi_interrupt, NULL, vector);
+ */
 static void vfio_msi_interrupt(void *opaque)
 {
     VFIOMSIVector *vector = opaque;
@@ -1047,6 +1052,10 @@ static const MemoryRegionOps vfio_vga_ops = {
  * size of this sub-page BAR when its base address is changed in guest
  * and not page aligned any more.
  */
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1191| <<vfio_pci_write_config>> vfio_sub_page_bar_update_mapping(pdev, bar);
+ */
 static void vfio_sub_page_bar_update_mapping(PCIDevice *pdev, int bar)
 {
     VFIOPCIDevice *vdev = VFIO_PCI(pdev);
@@ -1502,6 +1511,10 @@ static void vfio_msix_early_setup(VFIOPCIDevice *vdev, Error **errp)
     vfio_pci_relocate_msix(vdev, errp);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2023| <<vfio_add_std_cap>> ret = vfio_msix_setup(vdev, pos, errp);
+ */
 static int vfio_msix_setup(VFIOPCIDevice *vdev, int pos, Error **errp)
 {
     int ret;
@@ -1620,6 +1633,19 @@ static void vfio_bars_prepare(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * 184 memory-region: pci
+ * 185   0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+ * ... ...
+ * 191     00000000fe000000-00000000fe7fffff (prio 1, i/o): 0000:03:00.3 base BAR 0
+ * 192       00000000fe000000-00000000fe7fffff (prio 0, i/o): 0000:03:00.3 BAR 0
+ * 193         00000000fe000000-00000000fe7fffff (prio 0, ramd): 0000:03:00.3 BAR 0 mmaps[0]
+ * 194     00000000fe800000-00000000fe807fff (prio 1, i/o): 0000:03:00.3 base BAR 3
+ * 195       00000000fe800000-00000000fe80080f (prio 0, i/o): msix-table
+ * 196       00000000fe800000-00000000fe807fff (prio 0, i/o): 0000:03:00.3 BAR 3
+ * 197         00000000fe801000-00000000fe807fff (prio 0, ramd): 0000:03:00.3 BAR 3 mmaps[0]
+ * 198       00000000fe801000-00000000fe801017 (prio 0, i/o): msix-pba [disabled]
+ */
 static void vfio_bar_register(VFIOPCIDevice *vdev, int nr)
 {
     VFIOBAR *bar = &vdev->bars[nr];
@@ -1631,21 +1657,42 @@ static void vfio_bar_register(VFIOPCIDevice *vdev, int nr)
 
     bar->mr = g_new0(MemoryRegion, 1);
     name = g_strdup_printf("%s base BAR %d", vdev->vbasedev.name, nr);
+    /*
+     * VFIOBAR *bar = &vdev->bars[nr]:
+     * -> VFIORegion region;
+     *    -> MemoryRegion *mem;
+     * -> MemoryRegion *mr; --> "base BAR"
+     */
     memory_region_init_io(bar->mr, OBJECT(vdev), NULL, NULL, name, bar->size);
     g_free(name);
 
     if (bar->region.size) {
         memory_region_add_subregion(bar->mr, 0, bar->region.mem);
 
+	/*
+	 * 这里非常重要!!!
+	 */
         if (vfio_region_mmap(&bar->region)) {
             error_report("Failed to mmap %s BAR %d. Performance may be slow",
                          vdev->vbasedev.name, nr);
         }
     }
 
+    /*
+     * VFIOBAR *bar = &vdev->bars[nr]:
+     * -> VFIORegion region;
+     *    -> MemoryRegion *mem;
+     * -> MemoryRegion *mr;
+     *
+     * 在pci_update_mappings()会把bar->mr挂到pci的memory上
+     */
     pci_register_bar(&vdev->pdev, nr, bar->type, bar->mr);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2979| <<vfio_realize>> vfio_bars_register(vdev);
+ */
 static void vfio_bars_register(VFIOPCIDevice *vdev)
 {
     int i;
@@ -1916,6 +1963,11 @@ static void vfio_check_af_flr(VFIOPCIDevice *vdev, uint8_t pos)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1944| <<vfio_add_std_cap>> ret = vfio_add_std_cap(vdev, next, errp);
+ *   - hw/vfio/pci.c|2102| <<vfio_add_capabilities>> ret = vfio_add_std_cap(vdev, pdev->config[PCI_CAPABILITY_LIST], errp);
+ */
 static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos, Error **errp)
 {
     PCIDevice *pdev = &vdev->pdev;
@@ -2758,6 +2810,10 @@ static void vfio_unregister_req_notifier(VFIOPCIDevice *vdev)
     vdev->req_enabled = false;
 }
 
+/*
+ * 在以下使用vfio_realize():
+ *   - hw/vfio/pci.c|3248| <<vfio_pci_dev_class_init>> pdc->realize = vfio_realize;
+ */
 static void vfio_realize(PCIDevice *pdev, Error **errp)
 {
     VFIOPCIDevice *vdev = VFIO_PCI(pdev);
@@ -2791,6 +2847,11 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
         return;
     }
 
+    /*
+     * VFIOPCIDevice *vdev:
+     * -> PCIDevice pdev;
+     * -> VFIODevice vbasedev;
+     */
     vdev->vbasedev.name = g_path_get_basename(vdev->vbasedev.sysfsdev);
     vdev->vbasedev.ops = &vfio_pci_ops;
     vdev->vbasedev.type = VFIO_DEVICE_TYPE_PCI;
@@ -2816,6 +2877,11 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
 
     trace_vfio_realize(vdev->vbasedev.name, groupid);
 
+    /*
+     * 在以下调用pci_device_iommu_address_space():
+     *   - hw/pci/pci.c|96| <<pci_init_bus_master>> AddressSpace *dma_as = pci_device_iommu_address_space(pci_dev);
+     *   - hw/vfio/pci.c|2824| <<vfio_realize>> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
+     */
     group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
     if (!group) {
         goto error;
@@ -2951,6 +3017,15 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
 
     vfio_bars_prepare(vdev);
 
+    /*
+     * 注释.
+     * We don't have any control over how pci_add_capability() inserts
+     * capabilities into the chain.  In order to setup MSI-X we need a
+     * MemoryRegion for the BAR.  In order to setup the BAR and not
+     * attempt to mmap the MSI-X table area, which VFIO won't allow, we
+     * need to first look for where the MSI-X table lives.  So we
+     * unfortunately split MSI-X setup across two functions.
+     */
     vfio_msix_early_setup(vdev, &err);
     if (err) {
         error_propagate(errp, err);
diff --git a/include/hw/vfio/vfio-common.h b/include/hw/vfio/vfio-common.h
index 6141162d7..96737dc29 100644
--- a/include/hw/vfio/vfio-common.h
+++ b/include/hw/vfio/vfio-common.h
@@ -53,6 +53,24 @@ typedef struct VFIORegion {
     MemoryRegion *mem; /* slow, read/write access */
     size_t size;
     uint32_t flags; /* VFIO region flags (rd/wr/mmap) */
+    /*
+     * 在以下修改VFIORegion:
+     *   - hw/vfio/common.c|1389| <<vfio_setup_region_sparse_mmaps>> region->nr_mmaps = j;
+     *   - hw/vfio/common.c|1423| <<vfio_region_setup>> region->nr_mmaps = 1;
+     *   - hw/vfio/common.c|1569| <<vfio_region_finalize>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1300| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 0;
+     *   - hw/vfio/pci.c|1322| <<vfio_pci_fixup_msix_region>> region->nr_mmaps = 2;
+     * 在以下使用VFIORegion:
+     *   - hw/vfio/common.c|1424| <<vfio_region_setup>> region->mmaps = g_new0(VFIOMmap, region->nr_mmaps);
+     *   - hw/vfio/common.c|1470| <<vfio_region_mmap>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1521| <<vfio_region_unmap>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1536| <<vfio_region_exit>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1553| <<vfio_region_finalize>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/common.c|1583| <<vfio_region_mmaps_set_enabled>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/migration.c|168| <<get_data_section_size>> for (i = 0; i < region->nr_mmaps; i++) {
+     *   - hw/vfio/pci.c|1069| <<vfio_sub_page_bar_update_mapping>> if (region->nr_mmaps != 1 || !region->mmaps[0].mmap ||
+     *   - hw/vfio/pci.c|1281| <<vfio_pci_fixup_msix_region>> if (region->nr_mmaps != 1 || region->mmaps[0].offset ||
+     */
     uint32_t nr_mmaps;
     VFIOMmap *mmaps;
     uint8_t nr; /* cache the region number for debug */
@@ -146,6 +164,23 @@ typedef struct VFIOGroup {
     int fd;
     int groupid;
     VFIOContainer *container;
+    /*
+     * 在以下使用VFIOGroup->device_list:
+     *   - hw/vfio/ccw.c|570| <<vfio_ccw_get_device>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|314| <<vfio_mig_active>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|334| <<vfio_devices_all_saving>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|366| <<vfio_devices_all_running_and_saving>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|1521| <<vfio_reset_handler>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|1529| <<vfio_reset_handler>> QLIST_FOREACH(vbasedev, &group->device_list, next) {
+     *   - hw/vfio/common.c|2045| <<vfio_get_group>> QLIST_INIT(&group->device_list);
+     *   - hw/vfio/common.c|2072| <<vfio_put_group>> if (!group || !QLIST_EMPTY(&group->device_list)) {
+     *   - hw/vfio/common.c|2122| <<vfio_get_device>> if (!QLIST_EMPTY(&group->device_list)) {
+     *   - hw/vfio/common.c|2137| <<vfio_get_device>> QLIST_INSERT_HEAD(&group->device_list, vbasedev, next);
+     *   - hw/vfio/pci.c|2266| <<vfio_pci_hot_reset>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/pci.c|2348| <<vfio_pci_hot_reset>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/pci.c|2829| <<vfio_realize>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     *   - hw/vfio/platform.c|585| <<vfio_base_device_init>> QLIST_FOREACH(vbasedev_iter, &group->device_list, next) {
+     */
     QLIST_HEAD(, VFIODevice) device_list;
     QLIST_ENTRY(VFIOGroup) next;
     QLIST_ENTRY(VFIOGroup) container_next;
diff --git a/io/channel-socket.c b/io/channel-socket.c
index de259f7ee..9535cfef9 100644
--- a/io/channel-socket.c
+++ b/io/channel-socket.c
@@ -426,6 +426,10 @@ static void qio_channel_socket_finalize(Object *obj)
 
 
 #ifndef WIN32
+/*
+ * called by:
+ *   - io/channel-socket.c|517| <<qio_channel_socket_readv>> qio_channel_socket_copy_fds(&msg, fds, nfds);
+ */
 static void qio_channel_socket_copy_fds(struct msghdr *msg,
                                         int **fds, size_t *nfds)
 {
diff --git a/io/channel.c b/io/channel.c
index 93d449dee..d1d9086ab 100644
--- a/io/channel.c
+++ b/io/channel.c
@@ -47,6 +47,17 @@ void qio_channel_set_name(QIOChannel *ioc,
 }
 
 
+/*
+ * called by:
+ *   - chardev/char-socket.c|370| <<tcp_chr_recv>> ret = qio_channel_readv_full(s->ioc, &iov, 1,
+ *   - chardev/char-socket.c|374| <<tcp_chr_recv>> ret = qio_channel_readv_full(s->ioc, &iov, 1,
+ *   - io/channel.c|198| <<qio_channel_readv>> return qio_channel_readv_full(ioc, iov, niov, NULL, NULL, errp);
+ *   - io/channel.c|217| <<qio_channel_read>> return qio_channel_readv_full(ioc, &iov, 1, NULL, NULL, errp);
+ *   - scsi/qemu-pr-helper.c|604| <<prh_read>> n_read = qio_channel_readv_full(QIO_CHANNEL(client->ioc), &iov, 1,
+ *   - tests/qtest/tpm-emu.c|95| <<tpm_emu_ctrl_thread>> qio_channel_readv_full(ioc, &iov, 1, &pfd, &nfd, &error_abort);
+ *   - tests/test-io-channel-socket.c|449| <<test_io_channel_unix_fd_pass>> qio_channel_readv_full(dst,
+ *   - util/vhost-user-server.c|105| <<vu_message_read>> rc = qio_channel_readv_full(ioc, &iov, 1, &fds, &nfds, &local_err);
+ */
 ssize_t qio_channel_readv_full(QIOChannel *ioc,
                                const struct iovec *iov,
                                size_t niov,
@@ -63,6 +74,9 @@ ssize_t qio_channel_readv_full(QIOChannel *ioc,
         return -1;
     }
 
+    /*
+     * 比如getfd用qio_channel_socket_readv()
+     */
     return klass->io_readv(ioc, iov, niov, fds, nfds, errp);
 }
 
diff --git a/monitor/misc.c b/monitor/misc.c
index 398211a03..e785e3642 100644
--- a/monitor/misc.c
+++ b/monitor/misc.c
@@ -1224,12 +1224,49 @@ static void hmp_acl_remove(Monitor *mon, const QDict *qdict)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  0x000055e0a0cc780f in qmp_getfd (fdname=0x55e0a2e32590 "vhost-scsi-test", errp=0x7ffea965a210) at ../monitor/misc.c:1228
+ * #1  0x000055e0a0f49676 in qmp_marshal_getfd (args=0x7fc3180037d0, ret=0x7fc32917fd88, errp=0x7fc32917fd80) at qapi/qapi-commands-misc.c:334
+ * #2  0x000055e0a0fd22bc in do_qmp_dispatch_bh (opaque=0x7fc32917fe20) at ../qapi/qmp-dispatch.c:110
+ * #3  0x000055e0a0fbd1b1 in aio_bh_call (bh=0x55e0a2e53530) at ../util/async.c:136
+ * #4  0x000055e0a0fbd2bb in aio_bh_poll (ctx=0x55e0a2099640) at ../util/async.c:164
+ * #5  0x000055e0a0f9605e in aio_dispatch (ctx=0x55e0a2099640) at ../util/aio-posix.c:381
+ * #6  0x000055e0a0fbd6ee in aio_ctx_dispatch (source=0x55e0a2099640, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #7  0x00007fc3285f7099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #8  0x000055e0a0fb92be in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #9  0x000055e0a0fb9338 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:244
+ * #10 0x000055e0a0fb9440 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #11 0x000055e0a0cd72cb in qemu_main_loop () at ../softmmu/vl.c:1678#12 0x000055e0a095db32 in main (argc=22, argv=0x7ffea965a5b8, envp=0x7ffea965a670) at ../softmmu/main.c:50
+ *
+ * (gdb) bt
+ * #0  0x0000555555b7380f in qmp_getfd (fdname=0x55555737db60 "hello", errp=0x7fffffffcb28) at ../monitor/misc.c:1228
+ * #1  0x0000555555a688b1 in hmp_getfd (mon=0x555556ab80f0, qdict=0x5555570a3a00) at ../monitor/hmp-cmds.c:1691
+ * #2  0x0000555555940606 in handle_hmp_command (mon=0x555556ab80f0, cmdline=0x555556adc5a6 "hello") at ../monitor/hmp.c:1100
+ * #3  0x000055555593dd99 in monitor_command_cb (opaque=0x555556ab80f0, cmdline=0x555556adc5a0 "getfd hello", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #4  0x0000555555e5a417 in readline_handle_byte (rs=0x555556adc5a0, ch=10) at ../util/readline.c:408
+ * #5  0x0000555555941156 in monitor_read (opaque=0x555556ab80f0, buf=0x7fffffffcd60 "\n", size=1) at ../monitor/hmp.c:1340
+ * #6  0x0000555555d8fabe in qemu_chr_be_write_impl (s=0x555556aaf530, buf=0x7fffffffcd60 "\n", len=1) at ../chardev/char.c:201
+ * #7  0x0000555555d8fb25 in qemu_chr_be_write (s=0x555556aaf530, buf=0x7fffffffcd60 "\n", len=1) at ../chardev/char.c:213
+ * #8  0x0000555555d8b38c in fd_chr_read (chan=0x555556aaf640, cond=G_IO_IN, opaque=0x555556aaf530) at ../chardev/char-fd.c:68
+ * #9  0x0000555555d88fd4 in qio_channel_fd_source_dispatch (source=0x55555737da00, callback=0x555555d8b262 <fd_chr_read>, user_data=0x555556aaf530) at ../io/channel-watch.c:84
+ * #10 0x00007ffff7447099 in g_main_context_dispatch () at /lib/../lib64/libglib-2.0.so.0
+ * #11 0x0000555555e65297 in glib_pollfds_poll () at ../util/main-loop.c:221
+ * #12 0x0000555555e65311 in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:244
+ * #13 0x0000555555e65419 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:520
+ * #14 0x0000555555b832cb in qemu_main_loop () at ../softmmu/vl.c:1678
+ * #15 0x0000555555809b32 in main (argc=20, argv=0x7fffffffe008, envp=0x7fffffffe0b0) at ../softmmu/main.c:50
+ */
 void qmp_getfd(const char *fdname, Error **errp)
 {
     Monitor *cur_mon = monitor_cur();
     mon_fd_t *monfd;
     int fd, tmp_fd;
 
+    /*
+     * struct Monitor:
+     * -> CharBackend chr;
+     */
     fd = qemu_chr_fe_get_msgfd(&cur_mon->chr);
     if (fd == -1) {
         error_setg(errp, QERR_FD_NOT_SUPPLIED);
@@ -1244,6 +1281,20 @@ void qmp_getfd(const char *fdname, Error **errp)
     }
 
     QEMU_LOCK_GUARD(&cur_mon->mon_lock);
+    /*
+     * 在以下使用Monitor->fds:
+     *   - monitor/misc.c|1247| <<qmp_getfd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1263| <<qmp_getfd>> QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
+     *   - monitor/misc.c|1273| <<qmp_closefd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1297| <<monitor_get_fd>> QLIST_FOREACH(monfd, &mon->fds, next) {
+     *   - monitor/misc.c|1323| <<monitor_fdset_cleanup>> QLIST_FOREACH_SAFE(mon_fdset_fd, &mon_fdset->fds, next, mon_fdset_fd_next) {
+     *   - monitor/misc.c|1334| <<monitor_fdset_cleanup>> if (QLIST_EMPTY(&mon_fdset->fds) && QLIST_EMPTY(&mon_fdset->dup_fds)) {
+     *   - monitor/misc.c|1388| <<qmp_remove_fd>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1430| <<qmp_query_fdsets>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1447| <<qmp_query_fdsets>> fdset_info->value->fds = fdsetfd_list;
+     *   - monitor/misc.c|1529| <<monitor_fdset_add_fd>> QLIST_INSERT_HEAD(&mon_fdset->fds, mon_fdset_fd, next);
+     *   - monitor/misc.c|1557| <<monitor_fdset_dup_fd_add>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     */
     QLIST_FOREACH(monfd, &cur_mon->fds, next) {
         if (strcmp(monfd->name, fdname) != 0) {
             continue;
@@ -1256,10 +1307,30 @@ void qmp_getfd(const char *fdname, Error **errp)
         return;
     }
 
+    /*
+     * 新的fd用以下方式被vhost-scsi取出.
+     * vhost_scsi_realize()
+     * -> monitor_fd_param()
+     *    -> monitor_get_fd()
+     */
     monfd = g_malloc0(sizeof(mon_fd_t));
     monfd->name = g_strdup(fdname);
     monfd->fd = fd;
 
+    /*
+     * 在以下使用Monitor->fds:
+     *   - monitor/misc.c|1247| <<qmp_getfd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1263| <<qmp_getfd>> QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
+     *   - monitor/misc.c|1273| <<qmp_closefd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1297| <<monitor_get_fd>> QLIST_FOREACH(monfd, &mon->fds, next) {
+     *   - monitor/misc.c|1323| <<monitor_fdset_cleanup>> QLIST_FOREACH_SAFE(mon_fdset_fd, &mon_fdset->fds, next, mon_fdset_fd_next) {
+     *   - monitor/misc.c|1334| <<monitor_fdset_cleanup>> if (QLIST_EMPTY(&mon_fdset->fds) && QLIST_EMPTY(&mon_fdset->dup_fds)) {
+     *   - monitor/misc.c|1388| <<qmp_remove_fd>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1430| <<qmp_query_fdsets>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1447| <<qmp_query_fdsets>> fdset_info->value->fds = fdsetfd_list;
+     *   - monitor/misc.c|1529| <<monitor_fdset_add_fd>> QLIST_INSERT_HEAD(&mon_fdset->fds, mon_fdset_fd, next);
+     *   - monitor/misc.c|1557| <<monitor_fdset_dup_fd_add>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     */
     QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
 }
 
@@ -1289,6 +1360,14 @@ void qmp_closefd(const char *fdname, Error **errp)
     error_setg(errp, QERR_FD_NOT_FOUND, fdname);
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|1989| <<qmp_dump_guest_memory>> fd = monitor_get_fd(monitor_cur(), p, errp);
+ *   - migration/fd.c|29| <<fd_start_outgoing_migration>> int fd = monitor_get_fd(monitor_cur(), fdname, errp);
+ *   - monitor/misc.c|1646| <<monitor_fd_param>> fd = monitor_get_fd(mon, fdname, &local_err);
+ *   - monitor/qmp-cmds.c|331| <<qmp_add_client>> fd = monitor_get_fd(monitor_cur(), fdname, errp);
+ *   - util/qemu-sockets.c|1128| <<socket_get_fd>> fd = monitor_get_fd(cur_mon, fdstr, errp);
+ */
 int monitor_get_fd(Monitor *mon, const char *fdname, Error **errp)
 {
     mon_fd_t *monfd;
@@ -1623,12 +1702,30 @@ void monitor_fdset_dup_fd_remove(int dup_fd)
     monitor_fdset_dup_fd_find_remove(dup_fd, true);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/vhost-scsi.c|180| <<vhost_scsi_realize>> vhostfd = monitor_fd_param(monitor_cur(), vs->conf.vhostfd, errp);
+ *   - hw/virtio/vhost-vsock.c|147| <<vhost_vsock_device_realize>> vhostfd = monitor_fd_param(monitor_cur(), vsock->conf.vhostfd, errp);
+ *   - migration/fd.c|58| <<fd_start_incoming_migration>> int fd = monitor_fd_param(monitor_cur(), fdname, errp);
+ *   - net/socket.c|730| <<net_init_socket>> fd = monitor_fd_param(monitor_cur(), sock->fd, errp);
+ *   - net/tap.c|703| <<net_init_tap_one>> vhostfd = monitor_fd_param(monitor_cur(), vhostfdname, &err);
+ *   - net/tap.c|811| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), tap->fd, errp);
+ *   - net/tap.c|867| <<net_init_tap>> fd = monitor_fd_param(monitor_cur(), fds[i], errp);
+ */
 int monitor_fd_param(Monitor *mon, const char *fdname, Error **errp)
 {
     int fd;
     Error *local_err = NULL;
 
     if (!qemu_isdigit(fdname[0]) && mon) {
+        /*
+	 * called by:
+	 *   - dump/dump.c|1989| <<qmp_dump_guest_memory>> fd = monitor_get_fd(monitor_cur(), p, errp);
+	 *   - migration/fd.c|29| <<fd_start_outgoing_migration>> int fd = monitor_get_fd(monitor_cur(), fdname, errp);
+	 *   - monitor/misc.c|1646| <<monitor_fd_param>> fd = monitor_get_fd(mon, fdname, &local_err);
+	 *   - monitor/qmp-cmds.c|331| <<qmp_add_client>> fd = monitor_get_fd(monitor_cur(), fdname, errp);
+	 *   - util/qemu-sockets.c|1128| <<socket_get_fd>> fd = monitor_get_fd(cur_mon, fdstr, errp);
+	 */
         fd = monitor_get_fd(mon, fdname, &local_err);
     } else {
         fd = qemu_parse_fd(fdname);
diff --git a/monitor/monitor-internal.h b/monitor/monitor-internal.h
index a6131554d..45ce089a3 100644
--- a/monitor/monitor-internal.h
+++ b/monitor/monitor-internal.h
@@ -104,6 +104,20 @@ struct Monitor {
     /*
      * Members that are protected by the per-monitor lock
      */
+    /*
+     * 在以下使用Monitor->fds:
+     *   - monitor/misc.c|1247| <<qmp_getfd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1263| <<qmp_getfd>> QLIST_INSERT_HEAD(&cur_mon->fds, monfd, next);
+     *   - monitor/misc.c|1273| <<qmp_closefd>> QLIST_FOREACH(monfd, &cur_mon->fds, next) {
+     *   - monitor/misc.c|1297| <<monitor_get_fd>> QLIST_FOREACH(monfd, &mon->fds, next) {
+     *   - monitor/misc.c|1323| <<monitor_fdset_cleanup>> QLIST_FOREACH_SAFE(mon_fdset_fd, &mon_fdset->fds, next, mon_fdset_fd_next) {
+     *   - monitor/misc.c|1334| <<monitor_fdset_cleanup>> if (QLIST_EMPTY(&mon_fdset->fds) && QLIST_EMPTY(&mon_fdset->dup_fds)) {
+     *   - monitor/misc.c|1388| <<qmp_remove_fd>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1430| <<qmp_query_fdsets>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     *   - monitor/misc.c|1447| <<qmp_query_fdsets>> fdset_info->value->fds = fdsetfd_list;
+     *   - monitor/misc.c|1529| <<monitor_fdset_add_fd>> QLIST_INSERT_HEAD(&mon_fdset->fds, mon_fdset_fd, next);
+     *   - monitor/misc.c|1557| <<monitor_fdset_dup_fd_add>> QLIST_FOREACH(mon_fdset_fd, &mon_fdset->fds, next) {
+     */
     QLIST_HEAD(, mon_fd_t) fds;
     QString *outbuf;
     guint out_watch;
diff --git a/qapi/qmp-dispatch.c b/qapi/qmp-dispatch.c
index 9a2d7dd29..f7f83c5a4 100644
--- a/qapi/qmp-dispatch.c
+++ b/qapi/qmp-dispatch.c
@@ -101,6 +101,10 @@ typedef struct QmpDispatchBH {
     Coroutine *co;
 } QmpDispatchBH;
 
+/*
+ * 在以下使用do_qmp_dispatch_bh():
+ *   - qapi/qmp-dispatch.c|213| <<qmp_dispatch>> aio_bh_schedule_oneshot(qemu_get_aio_context(), do_qmp_dispatch_bh,
+ */
 static void do_qmp_dispatch_bh(void *opaque)
 {
     QmpDispatchBH *data = opaque;
@@ -116,6 +120,14 @@ static void do_qmp_dispatch_bh(void *opaque)
  * Runs outside of coroutine context for OOB commands, but in coroutine
  * context for everything else.
  */
+/*
+ * called by:
+ *   - monitor/qmp.c|145| <<monitor_qmp_dispatch>> rsp = qmp_dispatch(mon->commands, req, qmp_oob_enabled(mon),
+ *   - qga/main.c|582| <<process_event>> rsp = qmp_dispatch(&ga_commands, obj, false, NULL);
+ *   - tests/test-qmp-cmds.c|159| <<do_qmp_dispatch>> resp = qmp_dispatch(&qmp_commands, QOBJECT(req), allow_oob, NULL);
+ *   - tests/test-qmp-cmds.c|182| <<do_qmp_dispatch_error>> resp = qmp_dispatch(&qmp_commands, QOBJECT(req), allow_oob, NULL);
+ *   - tests/test-qmp-cmds.c|238| <<test_dispatch_cmd_success_response>> resp = qmp_dispatch(&qmp_commands, QOBJECT(req), false, NULL);
+ */
 QDict *qmp_dispatch(const QmpCommandList *cmds, QObject *request,
                     bool allow_oob, Monitor *cur_mon)
 {
diff --git a/target/i386/helper.c b/target/i386/helper.c
index 034f46bcc..0354439f8 100644
--- a/target/i386/helper.c
+++ b/target/i386/helper.c
@@ -861,6 +861,11 @@ static void emit_guest_memory_failure(MemoryFailureAction action, bool ar,
                                    &mff);
 }
 
+/*
+ * 在以下使用do_inject_x86_mce():
+ *   - target/i386/helper.c|988| <<cpu_x86_inject_mce>> run_on_cpu(cs, do_inject_x86_mce, RUN_ON_CPU_HOST_PTR(&params));
+ *   - target/i386/helper.c|1001| <<cpu_x86_inject_mce>> run_on_cpu(other_cs, do_inject_x86_mce, RUN_ON_CPU_HOST_PTR(&params));
+ */
 static void do_inject_x86_mce(CPUState *cs, run_on_cpu_data data)
 {
     MCEInjectionParams *params = data.host_ptr;
@@ -950,6 +955,11 @@ static void do_inject_x86_mce(CPUState *cs, run_on_cpu_data data)
     emit_guest_memory_failure(MEMORY_FAILURE_ACTION_INJECT, ar, recursive);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm.c|544| <<kvm_mce_inject>> cpu_x86_inject_mce(NULL, cpu, 9, status, mcg_status, paddr,
+ *   - target/i386/monitor.c|599| <<hmp_mce>> cpu_x86_inject_mce(mon, cpu, bank, status, mcg_status, addr, misc,
+ */
 void cpu_x86_inject_mce(Monitor *mon, X86CPU *cpu, int bank,
                         uint64_t status, uint64_t mcg_status, uint64_t addr,
                         uint64_t misc, int flags)
diff --git a/target/i386/kvm.c b/target/i386/kvm.c
index a2934dda0..fe310c274 100644
--- a/target/i386/kvm.c
+++ b/target/i386/kvm.c
@@ -514,6 +514,10 @@ static int kvm_get_mce_cap_supported(KVMState *s, uint64_t *mce_cap,
     return -ENOSYS;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm.c|582| <<kvm_arch_on_sigbus_vcpu>> kvm_mce_inject(cpu, paddr, code);
+ */
 static void kvm_mce_inject(X86CPU *cpu, hwaddr paddr, int code)
 {
     CPUState *cs = CPU(cpu);
-- 
2.17.1

