From 6ce21b523bd517fa20deeac2a48a5592dcbff6a7 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Sun, 9 Jun 2024 10:18:54 -0700
Subject: [PATCH 1/1] qemu for v9.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-all.c             | 128 +++++++++++++++++++++++++++++++
 hw/i386/kvm/apic.c              |  14 ++++
 hw/pci/msi.c                    |  10 +++
 hw/pci/msix.c                   |  60 +++++++++++++++
 hw/pci/pcie.c                   |   4 +
 hw/pci/pcie_port.c              |  14 ++++
 hw/vfio/helpers.c               |  17 ++++
 hw/vfio/pci.c                   | 132 ++++++++++++++++++++++++++++++++
 hw/vfio/pci.h                   |   9 +++
 hw/virtio/virtio-bus.c          |  22 ++++++
 hw/virtio/virtio-pci.c          |  34 ++++++++
 hw/virtio/virtio.c              |  58 ++++++++++++++
 include/hw/hotplug.h            |  23 ++++++
 include/hw/i386/apic_internal.h |  10 +++
 include/hw/pci/pci_device.h     |  51 ++++++++++++
 include/hw/virtio/virtio.h      |   7 ++
 include/sysemu/kvm_int.h        |  39 ++++++++++
 system/cpus.c                   |   4 +
 system/memory.c                 |  29 +++++++
 target/arm/kvm.c                |   5 ++
 target/i386/kvm/kvm.c           |   9 +++
 util/event_notifier-posix.c     |  55 +++++++++++++
 util/main-loop.c                |  33 ++++++++
 23 files changed, 767 insertions(+)

diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 931f74256..79e9fbf32 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -1182,6 +1182,11 @@ static uint32_t adjust_ioeventfd_endianness(uint32_t val, uint32_t size)
     return val;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1655| <<kvm_mem_ioeventfd_add>> r = kvm_set_ioeventfd_mmio(fd, section->offset_within_address_space, data, true, int128_get64(section->size), match_data);
+ *   - accel/kvm/kvm-all.c|1673| <<kvm_mem_ioeventfd_del>> r = kvm_set_ioeventfd_mmio(fd, section->offset_within_address_space, data, false, int128_get64(section->size), match_data);
+ */
 static int kvm_set_ioeventfd_mmio(int fd, hwaddr addr, uint32_t val,
                                   bool assign, uint32_t size, bool datamatch)
 {
@@ -1818,6 +1823,22 @@ void kvm_init_irq_routing(KVMState *s)
     kvm_arch_init_irq_routing(s);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2156| <<kvm_irqchip_add_hv_sint_route>> kvm_irqchip_commit_routes(s);
+ *   - hw/i386/kvm/ioapic.c|46| <<kvm_pc_setup_irq_routing>> kvm_irqchip_commit_routes(s);
+ *   - hw/intc/arm_gic_kvm.c|590| <<kvm_arm_gic_realize>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/intc/arm_gicv3_kvm.c|874| <<kvm_arm_gicv3_realize>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/intc/ioapic.c|208| <<ioapic_update_kvm_routes>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/intc/openpic_kvm.c|254| <<kvm_openpic_realize>> kvm_irqchip_commit_routes(s);
+ *   - hw/intc/s390_flic_kvm.c|345| <<kvm_s390_add_adapter_routes>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/misc/ivshmem.c|294| <<ivshmem_vector_unmask>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/vfio/pci.c|510| <<vfio_update_kvm_msi_virq>> kvm_irqchip_commit_routes(kvm_state);
+ *   - hw/virtio/virtio-pci.c|1005| <<virtio_pci_one_vector_unmask>> kvm_irqchip_commit_routes(kvm_state);
+ *   - include/sysemu/kvm.h|468| <<kvm_irqchip_commit_route_changes>> kvm_irqchip_commit_routes(c->s);
+ *   - target/i386/kvm/kvm.c|5552| <<kvm_update_msi_routes_all>> kvm_irqchip_commit_routes(kvm_state);
+ *   - target/riscv/kvm/kvm-cpu.c|1660| <<kvm_riscv_aia_create>> kvm_irqchip_commit_routes(kvm_state);
+ */
 void kvm_irqchip_commit_routes(KVMState *s)
 {
     int ret;
@@ -1836,6 +1857,13 @@ void kvm_irqchip_commit_routes(KVMState *s)
     assert(ret == 0);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1919| <<kvm_irqchip_add_irq_route>> kvm_add_routing_entry(s, &e);
+ *   - accel/kvm/kvm-all.c|2060| <<kvm_irqchip_add_msi_route>> kvm_add_routing_entry(s, &kroute);
+ *   - accel/kvm/kvm-all.c|2177| <<kvm_irqchip_add_adapter_route>> kvm_add_routing_entry(s, &kroute);
+ *   - accel/kvm/kvm-all.c|2204| <<kvm_irqchip_add_hv_sint_route>> kvm_add_routing_entry(s, &kroute);
+ */
 static void kvm_add_routing_entry(KVMState *s,
                                   struct kvm_irq_routing_entry *entry)
 {
@@ -1860,6 +1888,10 @@ static void kvm_add_routing_entry(KVMState *s,
     set_gsi(s, entry->gsi);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2100| <<kvm_irqchip_update_msi_route>> return kvm_update_routing_entry(s, &kroute);
+ */
 static int kvm_update_routing_entry(KVMState *s,
                                     struct kvm_irq_routing_entry *new_entry)
 {
@@ -1884,6 +1916,17 @@ static int kvm_update_routing_entry(KVMState *s,
     return -ESRCH;
 }
 
+/*
+ * called by:
+ *   - hw/i386/kvm/ioapic.c|32| <<kvm_pc_setup_irq_routing>> kvm_irqchip_add_irq_route(s, i, KVM_IRQCHIP_PIC_MASTER, i);
+ *   - hw/i386/kvm/ioapic.c|35| <<kvm_pc_setup_irq_routing>> kvm_irqchip_add_irq_route(s, i, KVM_IRQCHIP_PIC_SLAVE, i - 8);
+ *   - hw/i386/kvm/ioapic.c|40| <<kvm_pc_setup_irq_routing>> kvm_irqchip_add_irq_route(s, i, KVM_IRQCHIP_IOAPIC, 2);
+ *   - hw/i386/kvm/ioapic.c|42| <<kvm_pc_setup_irq_routing>> kvm_irqchip_add_irq_route(s, i, KVM_IRQCHIP_IOAPIC, i);
+ *   - hw/intc/arm_gic_kvm.c|585| <<kvm_arm_gic_realize>> kvm_irqchip_add_irq_route(kvm_state, i, 0, i);
+ *   - hw/intc/arm_gicv3_kvm.c|869| <<kvm_arm_gicv3_realize>> kvm_irqchip_add_irq_route(kvm_state, i, 0, i);
+ *   - hw/intc/openpic_kvm.c|248| <<kvm_openpic_realize>> kvm_irqchip_add_irq_route(kvm_state, i, 0, i);
+ *   - target/riscv/kvm/kvm-cpu.c|1657| <<kvm_riscv_aia_create>> kvm_irqchip_add_irq_route(kvm_state, idx, 0, idx);
+ */
 void kvm_irqchip_add_irq_route(KVMState *s, int irq, int irqchip, int pin)
 {
     struct kvm_irq_routing_entry e = {};
@@ -1947,6 +1990,11 @@ static int kvm_irqchip_get_virq(KVMState *s)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/kvm/apic.c|193| <<kvm_send_msi>> ret = kvm_irqchip_send_msi(kvm_state, *msg);
+ *   - target/i386/kvm/xen-emu.c|456| <<kvm_xen_inject_vcpu_callback_vector>> kvm_irqchip_send_msi(kvm_state, msg);
+ */
 int kvm_irqchip_send_msi(KVMState *s, MSIMessage msg)
 {
     struct kvm_msi msi;
@@ -1960,6 +2008,13 @@ int kvm_irqchip_send_msi(KVMState *s, MSIMessage msg)
     return kvm_vm_ioctl(s, KVM_SIGNAL_MSI, &msi);
 }
 
+/*
+ * called by:
+ *   - hw/misc/ivshmem.c|434| <<ivshmem_add_kvm_msi_virq>> ret = kvm_irqchip_add_msi_route(&c, vector, pdev);
+ *   - hw/vfio/pci.c|469| <<vfio_add_kvm_msi_virq>> vector->virq = kvm_irqchip_add_msi_route(&vfio_route_change, vector_n, &vdev->pdev);
+ *   - hw/virtio/virtio-pci.c|819| <<kvm_virtio_pci_vq_vector_use>> ret = kvm_irqchip_add_msi_route(&c, vector, &proxy->pci_dev);
+ *   - target/i386/kvm/kvm.c|5400| <<kvm_arch_init_irq_routing>> if (kvm_irqchip_add_msi_route(&c, 0, NULL) < 0) {
+ */
 int kvm_irqchip_add_msi_route(KVMRouteChange *c, int vector, PCIDevice *dev)
 {
     struct kvm_irq_routing_entry kroute = {};
@@ -1984,6 +2039,32 @@ int kvm_irqchip_add_msi_route(KVMRouteChange *c, int vector, PCIDevice *dev)
         return virq;
     }
 
+    /*
+     * 1162 struct kvm_irq_routing_msi {
+     * 1163         __u32 address_lo;
+     * 1164         __u32 address_hi;
+     * 1165         __u32 data;
+     * 1166         union {
+     * 1167                 __u32 pad;
+     * 1168                 __u32 devid;
+     * 1169         };
+     * 1170 };
+     *
+     * 1200 struct kvm_irq_routing_entry {
+     * 1201         __u32 gsi;
+     * 1202         __u32 type;
+     * 1203         __u32 flags;
+     * 1204         __u32 pad;
+     * 1205         union {
+     * 1206                 struct kvm_irq_routing_irqchip irqchip;
+     * 1207                 struct kvm_irq_routing_msi msi;
+     * 1208                 struct kvm_irq_routing_s390_adapter adapter;
+     * 1209                 struct kvm_irq_routing_hv_sint hv_sint;
+     * 1210                 struct kvm_irq_routing_xen_evtchn xen_evtchn;
+     * 1211                 __u32 pad[8];
+     * 1212         } u;
+     * 1213 };
+     */
     kroute.gsi = virq;
     kroute.type = KVM_IRQ_ROUTING_MSI;
     kroute.flags = 0;
@@ -1994,6 +2075,11 @@ int kvm_irqchip_add_msi_route(KVMRouteChange *c, int vector, PCIDevice *dev)
         kroute.flags = KVM_MSI_VALID_DEVID;
         kroute.u.msi.devid = pci_requester_id(dev);
     }
+    /*
+     * called by:
+     *   - accel/kvm/kvm-all.c|2078| <<kvm_irqchip_add_msi_route>> if (kvm_arch_fixup_msi_route(&kroute, msg.address, msg.data, dev)) {
+     *   - accel/kvm/kvm-all.c|2129| <<kvm_irqchip_update_msi_route>> if (kvm_arch_fixup_msi_route(&kroute, msg.address, msg.data, dev)) {
+     */
     if (kvm_arch_fixup_msi_route(&kroute, msg.address, msg.data, dev)) {
         kvm_irqchip_release_virq(s, virq);
         return -EINVAL;
@@ -2014,6 +2100,14 @@ int kvm_irqchip_add_msi_route(KVMRouteChange *c, int vector, PCIDevice *dev)
     return virq;
 }
 
+/*
+ * called by:
+ *   - hw/intc/ioapic.c|205| <<ioapic_update_kvm_routes>> kvm_irqchip_update_msi_route(kvm_state, i, msg, NULL);
+ *   - hw/misc/ivshmem.c|290| <<ivshmem_vector_unmask>> ret = kvm_irqchip_update_msi_route(kvm_state, v->virq, msg, dev);
+ *   - hw/vfio/pci.c|519| <<vfio_update_kvm_msi_virq>> kvm_irqchip_update_msi_route(kvm_state, vector->virq, msg, pdev);
+ *   - hw/virtio/virtio-pci.c|1027| <<virtio_pci_one_vector_unmask>> ret = kvm_irqchip_update_msi_route(kvm_state, irqfd->virq, msg, &proxy->pci_dev);
+ *   - target/i386/kvm/kvm.c|5550| <<kvm_update_msi_routes_all>> kvm_irqchip_update_msi_route(kvm_state, entry->virq, msg, dev);
+ */
 int kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg,
                                  PCIDevice *dev)
 {
@@ -2037,15 +2131,28 @@ int kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg,
         kroute.flags = KVM_MSI_VALID_DEVID;
         kroute.u.msi.devid = pci_requester_id(dev);
     }
+    /*
+     * called by:
+     *   - accel/kvm/kvm-all.c|2078| <<kvm_irqchip_add_msi_route>> if (kvm_arch_fixup_msi_route(&kroute, msg.address, msg.data, dev)) {
+     *   - accel/kvm/kvm-all.c|2129| <<kvm_irqchip_update_msi_route>> if (kvm_arch_fixup_msi_route(&kroute, msg.address, msg.data, dev)) {
+     */
     if (kvm_arch_fixup_msi_route(&kroute, msg.address, msg.data, dev)) {
         return -EINVAL;
     }
 
     trace_kvm_irqchip_update_msi_route(virq);
 
+    /*
+     * 只在此处调用
+     */
     return kvm_update_routing_entry(s, &kroute);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2202| <<kvm_irqchip_add_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, rn, virq, true);
+ *   - accel/kvm/kvm-all.c|2208| <<kvm_irqchip_remove_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, NULL, virq, false);
+ */
 static int kvm_irqchip_assign_irqfd(KVMState *s, EventNotifier *event,
                                     EventNotifier *resample, int virq,
                                     bool assign)
@@ -2092,6 +2199,10 @@ static int kvm_irqchip_assign_irqfd(KVMState *s, EventNotifier *event,
     return kvm_vm_ioctl(s, KVM_IRQFD, &irqfd);
 }
 
+/*
+ * called by:
+ *   - hw/intc/s390_flic_kvm.c|338| <<kvm_s390_add_adapter_routes>> ret = kvm_irqchip_add_adapter_route(kvm_state, &routes->adapter);
+ */
 int kvm_irqchip_add_adapter_route(KVMState *s, AdapterInfo *adapter)
 {
     struct kvm_irq_routing_entry kroute = {};
@@ -2191,6 +2302,19 @@ int kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg)
 }
 #endif /* !KVM_CAP_IRQ_ROUTING */
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2220| <<kvm_irqchip_add_irqfd_notifier>> return kvm_irqchip_add_irqfd_notifier_gsi(s, n, rn, GPOINTER_TO_INT(gsi));
+ *   - accel/stubs/kvm-stub.c|86| <<kvm_irqchip_add_irqfd_notifier_gsi>> int kvm_irqchip_add_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,
+ *   - hw/hyperv/hyperv.c|438| <<hyperv_sint_route_new>> r = kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &sint_route->sint_set_notifier, ack_notifier, gsi);
+ *   - hw/misc/ivshmem.c|296| <<ivshmem_vector_unmask>> ret = kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL, v->virq);
+ *   - hw/misc/ivshmem.c|467| <<setup_interrupt>> kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL, s->msi_vectors[vector].virq);
+ *   - hw/remote/proxy.c|45| <<proxy_intx_update>> kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &dev->intr, &dev->resample, dev->virq);
+ *   - hw/s390x/virtio-ccw.c|1003| <<virtio_ccw_add_irqfd>> return kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, notifier, NULL, dev->routes.gsi[n]);
+ *   - hw/vfio/pci.c|142| <<vfio_intx_enable_kvm>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &vdev->intx.interrupt, &vdev->intx.unmask, vdev->intx.route.irq)) {
+ *   - hw/vfio/pci.c|483| <<vfio_connect_kvm_msi_virq>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt, NULL, vector->virq) < 0) {
+ *   - hw/virtio/virtio-pci.c|844| <<kvm_virtio_pci_irqfd_use>> return kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL, irqfd->virq);
+ */
 int kvm_irqchip_add_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,
                                        EventNotifier *rn, int virq)
 {
@@ -3387,6 +3511,10 @@ int kvm_on_sigbus_vcpu(CPUState *cpu, int code, void *addr)
 #endif
 }
 
+/*
+ * 在以下使用kvm_on_sigbus():
+ *   - system/cpus.c|373| <<sigbus_handler>> if (kvm_on_sigbus(siginfo->si_code, siginfo->si_addr)) {
+ */
 /* Called synchronously (via signalfd) in main thread.  */
 int kvm_on_sigbus(int code, void *addr)
 {
diff --git a/hw/i386/kvm/apic.c b/hw/i386/kvm/apic.c
index a72c28e8a..69ffa20bd 100644
--- a/hw/i386/kvm/apic.c
+++ b/hw/i386/kvm/apic.c
@@ -179,6 +179,20 @@ static void kvm_apic_external_nmi(APICCommonState *s)
     run_on_cpu(CPU(s->cpu), do_inject_external_nmi, RUN_ON_CPU_HOST_PTR(s));
 }
 
+/*
+ * 在以下使用APICommonClass->send_msi:
+ *   - hw/i386/amd_iommu.c|1382| <<amdvi_mem_ir_write>> apic_get_class(NULL)->send_msi(&to);
+ *   - hw/i386/intel_iommu.c|400| <<vtd_generate_interrupt>> apic_get_class(NULL)->send_msi(&msi);
+ *   - hw/i386/intel_iommu.c|3628| <<vtd_mem_ir_write>> apic_get_class(NULL)->send_msi(&to);
+ *   - hw/i386/kvm/apic.c|257| <<kvm_apic_class_init>> k->send_msi = kvm_send_msi;
+ *   - hw/i386/xen/xen_apic.c|89| <<xen_apic_class_init>> k->send_msi = xen_send_msi;
+ *   - hw/intc/apic.c|1193| <<apic_class_init>> k->send_msi = apic_send_msi;
+ *   - target/i386/whpx/whpx-apic.c|267| <<whpx_apic_class_init>> k->send_msi = whpx_send_msi;
+ *
+ * 在以下使用kvm_send_msi():
+ *   - hw/i386/kvm/apic.c|211| <<kvm_apic_mem_write>> kvm_send_msi(&msg);
+ *   - hw/i386/kvm/apic.c|257| <<kvm_apic_class_init>> k->send_msi = kvm_send_msi;
+ */
 static void kvm_send_msi(MSIMessage *msg)
 {
     int ret;
diff --git a/hw/pci/msi.c b/hw/pci/msi.c
index 8104ac1d9..618d2091e 100644
--- a/hw/pci/msi.c
+++ b/hw/pci/msi.c
@@ -375,6 +375,16 @@ void msi_notify(PCIDevice *dev, unsigned int vector)
     msi_send_message(dev, msg);
 }
 
+/*
+ * 在以下使用APICommonClass->send_msi:
+ *   - hw/i386/amd_iommu.c|1382| <<amdvi_mem_ir_write>> apic_get_class(NULL)->send_msi(&to);
+ *   - hw/i386/intel_iommu.c|400| <<vtd_generate_interrupt>> apic_get_class(NULL)->send_msi(&msi);
+ *   - hw/i386/intel_iommu.c|3628| <<vtd_mem_ir_write>> apic_get_class(NULL)->send_msi(&to);
+ *   - hw/i386/kvm/apic.c|257| <<kvm_apic_class_init>> k->send_msi = kvm_send_msi;
+ *   - hw/i386/xen/xen_apic.c|89| <<xen_apic_class_init>> k->send_msi = xen_send_msi;
+ *   - hw/intc/apic.c|1193| <<apic_class_init>> k->send_msi = apic_send_msi;
+ *   - target/i386/whpx/whpx-apic.c|267| <<whpx_apic_class_init>> k->send_msi = whpx_send_msi;
+ */
 void msi_send_message(PCIDevice *dev, MSIMessage msg)
 {
     dev->msi_trigger(dev, msg);
diff --git a/hw/pci/msix.c b/hw/pci/msix.c
index 487e49834..a4b563fda 100644
--- a/hw/pci/msix.c
+++ b/hw/pci/msix.c
@@ -71,11 +71,24 @@ static uint8_t *msix_pending_byte(PCIDevice *dev, int vector)
     return dev->msix_pba + vector / 8;
 }
 
+/*
+ * called by:
+ *   - hw/pci/msix.c|142| <<msix_handle_mask_update>> if (!is_masked && msix_is_pending(dev, vector)) {
+ */
 static int msix_is_pending(PCIDevice *dev, int vector)
 {
     return *msix_pending_byte(dev, vector) & msix_pending_mask(vector);
 }
 
+/*
+ * called by:
+ *   - hw/misc/ivshmem.c|346| <<ivshmem_vector_poll>> msix_set_pending(dev, vector);
+ *   - hw/pci/msix.c|536| <<msix_notify>> msix_set_pending(dev, vector);
+ *   - hw/virtio/virtio-pci.c|1143| <<virtio_pci_vector_poll>> msix_set_pending(dev, vector);
+ *   - hw/virtio/virtio-pci.c|1146| <<virtio_pci_vector_poll>> msix_set_pending(dev, vector);
+ *   - hw/virtio/virtio-pci.c|1161| <<virtio_pci_vector_poll>> msix_set_pending(dev, vector);
+ *   - hw/virtio/virtio-pci.c|1164| <<virtio_pci_vector_poll>> msix_set_pending(dev, vector);
+ */
 void msix_set_pending(PCIDevice *dev, unsigned int vector)
 {
     *msix_pending_byte(dev, vector) |= msix_pending_mask(vector);
@@ -104,12 +117,22 @@ bool msix_is_masked(PCIDevice *dev, unsigned int vector)
     return msix_vector_masked(dev, vector, dev->msix_function_masked);
 }
 
+/*
+ * 在以下使用msix_fire_vector_notifier():
+ *   - hw/pci/msix.c|140| <<msix_handle_mask_update>> msix_fire_vector_notifier(dev, vector, is_masked);
+ */
 static void msix_fire_vector_notifier(PCIDevice *dev,
                                       unsigned int vector, bool is_masked)
 {
     MSIMessage msg;
     int ret;
 
+    /*
+     * 在以下调用msix_set_vector_notifiers():
+     *   - hw/misc/ivshmem.c|775| <<ivshmem_enable_irqfd>> if (msix_set_vector_notifiers(pdev, ivshmem_vector_unmask, ivshmem_vector_mask, ivshmem_vector_poll)) {
+     *   - hw/vfio/pci.c|683| <<vfio_msix_enable>> if (msix_set_vector_notifiers(&vdev->pdev, vfio_msix_vector_use, vfio_msix_vector_release, NULL)) {
+     *   - hw/virtio/virtio-pci.c|1291| <<virtio_pci_set_guest_notifiers>> r = msix_set_vector_notifiers(&proxy->pci_dev, virtio_pci_vector_unmask, virtio_pci_vector_mask, virtio_pci_vector_poll);
+     */
     if (!dev->msix_vector_use_notifier) {
         return;
     }
@@ -117,11 +140,27 @@ static void msix_fire_vector_notifier(PCIDevice *dev,
         dev->msix_vector_release_notifier(dev, vector);
     } else {
         msg = msix_get_message(dev, vector);
+	/*
+	 * 在以下调用msix_set_vector_notifiers():
+	 *   - hw/misc/ivshmem.c|775| <<ivshmem_enable_irqfd>> if (msix_set_vector_notifiers(pdev, ivshmem_vector_unmask, ivshmem_vector_mask, ivshmem_vector_poll)) {
+	 *   - hw/vfio/pci.c|683| <<vfio_msix_enable>> if (msix_set_vector_notifiers(&vdev->pdev, vfio_msix_vector_use, vfio_msix_vector_release, NULL)) {
+	 *   - hw/virtio/virtio-pci.c|1291| <<virtio_pci_set_guest_notifiers>> r = msix_set_vector_notifiers(&proxy->pci_dev, virtio_pci_vector_unmask, virtio_pci_vector_mask, virtio_pci_vector_poll);
+	 */
         ret = dev->msix_vector_use_notifier(dev, vector, msg);
         assert(ret >= 0);
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci/msix.c|165| <<msix_set_mask>> msix_handle_mask_update(dev, vector, was_masked);
+ *   - hw/pci/msix.c|206| <<msix_write_config>> msix_handle_mask_update(dev, vector,
+ *   - hw/pci/msix.c|231| <<msix_table_mmio_write>> msix_handle_mask_update(dev, vector, was_masked);
+ *   - hw/pci/msix.c|288| <<msix_mask_all>> msix_handle_mask_update(dev, vector, was_masked);
+ *   - hw/pci/msix.c|506| <<msix_load>> msix_handle_mask_update(dev, vector, true);
+ *
+ * 这里的vector是设备的第几个line
+ */
 static void msix_handle_mask_update(PCIDevice *dev, int vector, bool was_masked)
 {
     bool is_masked = msix_is_masked(dev, vector);
@@ -248,6 +287,21 @@ static uint64_t msix_pba_mmio_read(void *opaque, hwaddr addr,
                                    unsigned size)
 {
     PCIDevice *dev = opaque;
+    /*
+     * 在以下调用msix_set_vector_notifiers():
+     *   - hw/misc/ivshmem.c|775| <<ivshmem_enable_irqfd>> if (msix_set_vector_notifiers(pdev, ivshmem_vector_unmask, ivshmem_vector_mask, ivshmem_vector_poll)) {
+     *   - hw/vfio/pci.c|683| <<vfio_msix_enable>> if (msix_set_vector_notifiers(&vdev->pdev, vfio_msix_vector_use, vfio_msix_vector_release, NULL)) {
+     *   - hw/virtio/virtio-pci.c|1291| <<virtio_pci_set_guest_notifiers>> r = msix_set_vector_notifiers(&proxy->pci_dev, virtio_pci_vector_unmask, virtio_pci_vector_mask, virtio_pci_vector_poll);
+     *
+     * 在以下使用PCIDevice->msix_vector_poll_notifier:
+     *   - hw/pci/msix.c|251| <<msix_pba_mmio_read>> if (dev->msix_vector_poll_notifier) {
+     *   - hw/pci/msix.c|254| <<msix_pba_mmio_read>> dev->msix_vector_poll_notifier(dev, vector_start, vector_end);
+     *   - hw/pci/msix.c|629| <<msix_set_vector_notifiers>> dev->msix_vector_poll_notifier = poll_notifier;
+     *   - hw/pci/msix.c|640| <<msix_set_vector_notifiers>> if (dev->msix_vector_poll_notifier) {
+     *   - hw/pci/msix.c|641| <<msix_set_vector_notifiers>> dev->msix_vector_poll_notifier(dev, 0, dev->msix_entries_nr);
+     *   - hw/pci/msix.c|651| <<msix_set_vector_notifiers>> dev->msix_vector_poll_notifier = NULL;
+     *   - hw/pci/msix.c|670| <<msix_unset_vector_notifiers>> dev->msix_vector_poll_notifier = NULL;
+     */
     if (dev->msix_vector_poll_notifier) {
         unsigned vector_start = addr * 8;
         unsigned vector_end = MIN(addr + size * 8, dev->msix_entries_nr);
@@ -615,6 +669,12 @@ static void msix_unset_notifier_for_vector(PCIDevice *dev, unsigned int vector)
     dev->msix_vector_release_notifier(dev, vector);
 }
 
+/*
+ * 在以下调用msix_set_vector_notifiers():
+ *   - hw/misc/ivshmem.c|775| <<ivshmem_enable_irqfd>> if (msix_set_vector_notifiers(pdev, ivshmem_vector_unmask, ivshmem_vector_mask, ivshmem_vector_poll)) {
+ *   - hw/vfio/pci.c|683| <<vfio_msix_enable>> if (msix_set_vector_notifiers(&vdev->pdev, vfio_msix_vector_use, vfio_msix_vector_release, NULL)) {
+ *   - hw/virtio/virtio-pci.c|1291| <<virtio_pci_set_guest_notifiers>> r = msix_set_vector_notifiers(&proxy->pci_dev, virtio_pci_vector_unmask, virtio_pci_vector_mask, virtio_pci_vector_poll);
+ */
 int msix_set_vector_notifiers(PCIDevice *dev,
                               MSIVectorUseNotifier use_notifier,
                               MSIVectorReleaseNotifier release_notifier,
diff --git a/hw/pci/pcie.c b/hw/pci/pcie.c
index 4b2f0805c..cfdf84d70 100644
--- a/hw/pci/pcie.c
+++ b/hw/pci/pcie.c
@@ -572,6 +572,10 @@ static void pcie_cap_slot_do_unplug(PCIDevice *dev)
                                PCI_EXP_SLTSTA_PDC);
 }
 
+/*
+ * 在以下使用pcie_cap_slot_unplug_request_cb():
+ *   - hw/pci/pcie_port.c|235| <<pcie_slot_class_init>> hc->unplug_request = pcie_cap_slot_unplug_request_cb;
+ */
 void pcie_cap_slot_unplug_request_cb(HotplugHandler *hotplug_dev,
                                      DeviceState *dev, Error **errp)
 {
diff --git a/hw/pci/pcie_port.c b/hw/pci/pcie_port.c
index 20ff2b39e..a6f17ae07 100644
--- a/hw/pci/pcie_port.c
+++ b/hw/pci/pcie_port.c
@@ -102,8 +102,22 @@ PCIESlot *pcie_chassis_find_slot(uint8_t chassis_number, uint16_t slot)
     return pcie_chassis_find_slot_with_chassis(c, slot);
 }
 
+/*
+ * called by:
+ *   - hw/pci-bridge/cxl_downstream.c|169| <<cxl_dsp_realize>> rc = pcie_chassis_add_slot(s);
+ *   - hw/pci-bridge/pcie_root_port.c|106| <<rp_realize>> rc = pcie_chassis_add_slot(s);
+ *   - hw/pci-bridge/xio3130_downstream.c|102| <<xio3130_downstream_realize>> rc = pcie_chassis_add_slot(s);
+ */
 int pcie_chassis_add_slot(struct PCIESlot *slot)
 {
+    /*
+     * struct PCIEChassis {
+     *     uint8_t     number;
+     *
+     *     QLIST_HEAD(, PCIESlot) slots;
+     *     QLIST_ENTRY(PCIEChassis) next;
+     * };
+     */
     struct PCIEChassis *c;
     c = pcie_chassis_find(slot->chassis);
     if (!c) {
diff --git a/hw/vfio/helpers.c b/hw/vfio/helpers.c
index 47b4096c0..f3b43ed52 100644
--- a/hw/vfio/helpers.c
+++ b/hw/vfio/helpers.c
@@ -107,6 +107,23 @@ static const char *index_to_str(VFIODevice *vbasedev, int index)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/ap.c|120| <<vfio_ap_register_irq_notifier>> if (vfio_set_irq_signaling(vdev, irq, 0, VFIO_IRQ_SET_ACTION_TRIGGER, fd, errp)) {
+ *   - hw/vfio/ap.c|146| <<vfio_ap_unregister_irq_notifier>> if (vfio_set_irq_signaling(&vapdev->vdev, irq, 0, VFIO_IRQ_SET_ACTION_TRIGGER, -1, &err)) {
+ *   - hw/vfio/ccw.c|437| <<vfio_ccw_register_irq_notifier>> if (vfio_set_irq_signaling(vdev, irq, 0, VFIO_IRQ_SET_ACTION_TRIGGER, fd, errp)) {
+ *   - hw/vfio/ccw.c|468| <<vfio_ccw_unregister_irq_notifier>> if (vfio_set_irq_signaling(&vcdev->vdev, irq, 0, VFIO_IRQ_SET_ACTION_TRIGGER, -1, &err)) {
+ *   - hw/vfio/pci.c|150| <<vfio_intx_enable_kvm>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0, VFIO_IRQ_SET_ACTION_UNMASK, event_notifier_get_fd(&vdev->intx.unmask), errp)) {
+ *   - hw/vfio/pci.c|298| <<vfio_intx_enable>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0, VFIO_IRQ_SET_ACTION_TRIGGER, fd, errp)) {
+ *   - hw/vfio/pci.c|593| <<vfio_msix_vector_do_use>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_MSIX_IRQ_INDEX, nr, VFIO_IRQ_SET_ACTION_TRIGGER, fd, &err)) {
+ *   - hw/vfio/pci.c|647| <<vfio_msix_vector_release>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_MSIX_IRQ_INDEX, nr, VFIO_IRQ_SET_ACTION_TRIGGER, fd, &err)) {
+ *   - hw/vfio/pci.c|2860| <<vfio_register_err_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_ERR_IRQ_INDEX, 0, VFIO_IRQ_SET_ACTION_TRIGGER, fd, &err)) {
+ *   - hw/vfio/pci.c|2877| <<vfio_unregister_err_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_ERR_IRQ_INDEX, 0, VFIO_IRQ_SET_ACTION_TRIGGER, -1, &err)) {
+ *   - hw/vfio/pci.c|2925| <<vfio_register_req_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_REQ_IRQ_INDEX, 0, VFIO_IRQ_SET_ACTION_TRIGGER, fd, &err)) {
+ *   - hw/vfio/pci.c|2943| <<vfio_unregister_req_notifier>> if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_REQ_IRQ_INDEX, 0, VFIO_IRQ_SET_ACTION_TRIGGER, -1, &err)) {
+ *   - hw/vfio/platform.c|122| <<vfio_set_trigger_eventfd>> ret = vfio_set_irq_signaling(vbasedev, intp->pin, 0, VFIO_IRQ_SET_ACTION_TRIGGER, fd, &err);
+ *   - hw/vfio/platform.c|361| <<vfio_set_resample_eventfd>> ret = vfio_set_irq_signaling(vbasedev, intp->pin, 0, VFIO_IRQ_SET_ACTION_UNMASK, fd, &err);
+ */
 int vfio_set_irq_signaling(VFIODevice *vbasedev, int index, int subindex,
                            int action, int fd, Error **errp)
 {
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 64780d1b7..aab0eb393 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -356,7 +356,19 @@ static void vfio_msi_interrupt(void *opaque)
         /* A masked vector firing needs to use the PBA, enable it */
         if (msix_is_masked(&vdev->pdev, nr)) {
             set_bit(nr, vdev->msix->pending);
+            /*
+	     * 在以下使用PCIDevice->msix_pba_mmio:
+	     *   - hw/pci/msix.c|416| <<msix_init>> memory_region_init_io(&dev->msix_pba_mmio, OBJECT(dev), &msix_pba_mmio_ops, dev, "msix-pba", pba_size);
+	     *   - hw/pci/msix.c|418| <<msix_init>> memory_region_add_subregion(pba_bar, pba_offset, &dev->msix_pba_mmio);
+	     *   - hw/pci/msix.c|498| <<msix_uninit>> memory_region_del_subregion(pba_bar, &dev->msix_pba_mmio);
+	     *   - hw/vfio/pci.c|359| <<vfio_msi_interrupt>> memory_region_set_enabled(&vdev->pdev.msix_pba_mmio, true);
+	     *   - hw/vfio/pci.c|632| <<vfio_msix_vector_do_use>> memory_region_set_enabled(&vdev->pdev.msix_pba_mmio, false);
+	     *   - hw/vfio/pci.c|1737| <<vfio_msix_setup>> memory_region_set_enabled(&vdev->pdev.msix_pba_mmio, false);
+	     */
             memory_region_set_enabled(&vdev->pdev.msix_pba_mmio, true);
+            /*
+	     * 只在这里trace!
+	     */
             trace_vfio_msix_pba_enable(vdev->vbasedev.name);
         }
     } else if (vdev->interrupt == VFIO_INT_MSI) {
@@ -470,6 +482,11 @@ static void vfio_add_kvm_msi_virq(VFIOPCIDevice *vdev, VFIOMSIVector *vector,
                                              vector_n, &vdev->pdev);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|565| <<vfio_msix_vector_do_use>> vfio_connect_kvm_msi_virq(vector);
+ *   - hw/vfio/pci.c|692| <<vfio_commit_kvm_msi_virq_batch>> vfio_connect_kvm_msi_virq(&vdev->msi_vectors[i]);
+ */
 static void vfio_connect_kvm_msi_virq(VFIOMSIVector *vector)
 {
     if (vector->virq < 0) {
@@ -503,6 +520,11 @@ static void vfio_remove_kvm_msi_virq(VFIOMSIVector *vector)
     event_notifier_cleanup(&vector->kvm_interrupt);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|550| <<vfio_msix_vector_do_use>> vfio_update_kvm_msi_virq(vector, *msg, pdev);
+ *   - hw/vfio/pci.c|897| <<vfio_update_msi>> vfio_update_kvm_msi_virq(vector, msg, &vdev->pdev);
+ */
 static void vfio_update_kvm_msi_virq(VFIOMSIVector *vector, MSIMessage msg,
                                      PCIDevice *pdev)
 {
@@ -510,6 +532,10 @@ static void vfio_update_kvm_msi_virq(VFIOMSIVector *vector, MSIMessage msg,
     kvm_irqchip_commit_routes(kvm_state);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|615| <<vfio_msix_vector_use>> return vfio_msix_vector_do_use(pdev, nr, &msg, vfio_msi_interrupt);
+ */
 static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
                                    MSIMessage *msg, IOHandler *handler)
 {
@@ -547,6 +573,15 @@ static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
         }
     } else {
         if (msg) {
+            /*
+	     * 在以下使用VFIOPCIDevice->defer_kvm_irq_routing:
+	     *   - hw/vfio/pci.c|576| <<vfio_msix_vector_do_use>> if (vdev->defer_kvm_irq_routing) {
+	     *   - hw/vfio/pci.c|602| <<vfio_msix_vector_do_use>> if (!vdev->defer_kvm_irq_routing) {
+	     *   - hw/vfio/pci.c|711| <<vfio_prepare_kvm_msi_virq_batch>> assert(!vdev->defer_kvm_irq_routing);
+	     *   - hw/vfio/pci.c|712| <<vfio_prepare_kvm_msi_virq_batch>> vdev->defer_kvm_irq_routing = true;
+	     *   - hw/vfio/pci.c|720| <<vfio_commit_kvm_msi_virq_batch>> assert(vdev->defer_kvm_irq_routing);
+	     *   - hw/vfio/pci.c|721| <<vfio_commit_kvm_msi_virq_batch>> vdev->defer_kvm_irq_routing = false;
+	     */
             if (vdev->defer_kvm_irq_routing) {
                 vfio_add_kvm_msi_virq(vdev, vector, nr, true);
             } else {
@@ -573,6 +608,15 @@ static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
         vdev->nr_vectors = nr + 1;
     }
 
+    /*
+     * 在以下使用VFIOPCIDevice->defer_kvm_irq_routing:
+     *   - hw/vfio/pci.c|576| <<vfio_msix_vector_do_use>> if (vdev->defer_kvm_irq_routing) {
+     *   - hw/vfio/pci.c|602| <<vfio_msix_vector_do_use>> if (!vdev->defer_kvm_irq_routing) {
+     *   - hw/vfio/pci.c|711| <<vfio_prepare_kvm_msi_virq_batch>> assert(!vdev->defer_kvm_irq_routing);
+     *   - hw/vfio/pci.c|712| <<vfio_prepare_kvm_msi_virq_batch>> vdev->defer_kvm_irq_routing = true;
+     *   - hw/vfio/pci.c|720| <<vfio_commit_kvm_msi_virq_batch>> assert(vdev->defer_kvm_irq_routing);
+     *   - hw/vfio/pci.c|721| <<vfio_commit_kvm_msi_virq_batch>> vdev->defer_kvm_irq_routing = false;
+     */
     if (!vdev->defer_kvm_irq_routing) {
         if (vdev->msix->noresize && resizing) {
             vfio_disable_irqindex(&vdev->vbasedev, VFIO_PCI_MSIX_IRQ_INDEX);
@@ -584,6 +628,16 @@ static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
             Error *err = NULL;
             int32_t fd;
 
+	    /*
+	     * 注释
+	     *  Two interrupt paths are configured per vector.  The first, is only used
+	     * for interrupts injected via QEMU.  This is typically the non-accel path,
+	     * but may also be used when we want QEMU to handle masking and pending
+	     * bits.  The KVM path bypasses QEMU and is therefore higher performance,
+	     * but requires masking at the device.  virq is used to track the MSI route
+	     * through KVM, thus kvm_interrupt is only available when virq is set to a
+	     * valid (>= 0) value.
+	     */
             if (vector->virq >= 0) {
                 fd = event_notifier_get_fd(&vector->kvm_interrupt);
             } else {
@@ -598,6 +652,13 @@ static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
         }
     }
 
+    /*
+     * 这里会改变memslots!!!
+     *
+     * VFIOPCIDevice:
+     * -> VFIOMSIXInfo *msix;
+     *    -> unsigned long *pending;
+     */
     /* Disable PBA emulation when nothing more is pending. */
     clear_bit(nr, vdev->msix->pending);
     if (find_first_bit(vdev->msix->pending,
@@ -609,12 +670,34 @@ static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
     return 0;
 }
 
+/*
+ * 在以下调用msix_set_vector_notifiers():
+ *   - hw/misc/ivshmem.c|775| <<ivshmem_enable_irqfd>> if (msix_set_vector_notifiers(pdev, ivshmem_vector_unmask, ivshmem_vector_mask, ivshmem_vector_poll)) {
+ *   - hw/vfio/pci.c|683| <<vfio_msix_enable>> if (msix_set_vector_notifiers(&vdev->pdev, vfio_msix_vector_use, vfio_msix_vector_release, NULL)) {
+ *   - hw/virtio/virtio-pci.c|1291| <<virtio_pci_set_guest_notifiers>> r = msix_set_vector_notifiers(&proxy->pci_dev, virtio_pci_vector_unmask, virtio_pci_vector_mask, virtio_pci_vector_poll);
+ *
+ * 在以下使用vfio_msix_vector_use():
+ *   - hw/vfio/pci.c|693| <<vfio_msix_enable>> if (msix_set_vector_notifiers(&vdev->pdev, vfio_msix_vector_use, vfio_msix_vector_release, NULL)) {
+ */
 static int vfio_msix_vector_use(PCIDevice *pdev,
                                 unsigned int nr, MSIMessage msg)
 {
+    /*
+     * 只在此处调用
+     */
     return vfio_msix_vector_do_use(pdev, nr, &msg, vfio_msi_interrupt);
 }
 
+/*
+ * 在以下调用msix_set_vector_notifiers():
+ *   - hw/misc/ivshmem.c|775| <<ivshmem_enable_irqfd>> if (msix_set_vector_notifiers(pdev, ivshmem_vector_unmask, ivshmem_vector_mask, ivshmem_vector_poll)) {
+ *   - hw/vfio/pci.c|683| <<vfio_msix_enable>> if (msix_set_vector_notifiers(&vdev->pdev, vfio_msix_vector_use, vfio_msix_vector_release, NULL)) {
+ *   - hw/virtio/virtio-pci.c|1291| <<virtio_pci_set_guest_notifiers>> r = msix_set_vector_notifiers(&proxy->pci_dev, virtio_pci_vector_unmask, virtio_pci_vector_mask, virtio_pci_vector_poll);
+ *
+ * 在以下使用vfio_msix_vector_release():
+ *   - hw/vfio/pci.c|684| <<vfio_msix_enable>> if (msix_set_vector_notifiers(&vdev->pdev, vfio_msix_vector_use, vfio_msix_vector_release, NULL)) {
+ *   - hw/vfio/pci.c|824| <<vfio_msix_disable>> vfio_msix_vector_release(&vdev->pdev, i);
+ */
 static void vfio_msix_vector_release(PCIDevice *pdev, unsigned int nr)
 {
     VFIOPCIDevice *vdev = VFIO_PCI(pdev);
@@ -634,6 +717,10 @@ static void vfio_msix_vector_release(PCIDevice *pdev, unsigned int nr)
         int32_t fd = event_notifier_get_fd(&vector->interrupt);
         Error *err = NULL;
 
+        /*
+	 * 这是use的情况.
+	 * vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_MSIX_IRQ_INDEX, nr, VFIO_IRQ_SET_ACTION_TRIGGER, fd, &err)
+	 */
         if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_MSIX_IRQ_INDEX, nr,
                                    VFIO_IRQ_SET_ACTION_TRIGGER, fd, &err)) {
             error_reportf_err(err, VFIO_MSG_PREFIX, vdev->vbasedev.name);
@@ -641,8 +728,22 @@ static void vfio_msix_vector_release(PCIDevice *pdev, unsigned int nr)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|759| <<vfio_msix_enable>> vfio_prepare_kvm_msi_virq_batch(vdev);
+ *   - hw/vfio/pci.c|808| <<vfio_msi_enable>> vfio_prepare_kvm_msi_virq_batch(vdev);
+ */
 static void vfio_prepare_kvm_msi_virq_batch(VFIOPCIDevice *vdev)
 {
+    /*
+     * 在以下使用VFIOPCIDevice->defer_kvm_irq_routing:
+     *   - hw/vfio/pci.c|576| <<vfio_msix_vector_do_use>> if (vdev->defer_kvm_irq_routing) {
+     *   - hw/vfio/pci.c|602| <<vfio_msix_vector_do_use>> if (!vdev->defer_kvm_irq_routing) {
+     *   - hw/vfio/pci.c|711| <<vfio_prepare_kvm_msi_virq_batch>> assert(!vdev->defer_kvm_irq_routing);
+     *   - hw/vfio/pci.c|712| <<vfio_prepare_kvm_msi_virq_batch>> vdev->defer_kvm_irq_routing = true;
+     *   - hw/vfio/pci.c|720| <<vfio_commit_kvm_msi_virq_batch>> assert(vdev->defer_kvm_irq_routing);
+     *   - hw/vfio/pci.c|721| <<vfio_commit_kvm_msi_virq_batch>> vdev->defer_kvm_irq_routing = false;
+     */
     assert(!vdev->defer_kvm_irq_routing);
     vdev->defer_kvm_irq_routing = true;
     vfio_route_change = kvm_irqchip_begin_route_changes(kvm_state);
@@ -652,6 +753,15 @@ static void vfio_commit_kvm_msi_virq_batch(VFIOPCIDevice *vdev)
 {
     int i;
 
+    /*
+     * 在以下使用VFIOPCIDevice->defer_kvm_irq_routing:
+     *   - hw/vfio/pci.c|576| <<vfio_msix_vector_do_use>> if (vdev->defer_kvm_irq_routing) {
+     *   - hw/vfio/pci.c|602| <<vfio_msix_vector_do_use>> if (!vdev->defer_kvm_irq_routing) {
+     *   - hw/vfio/pci.c|711| <<vfio_prepare_kvm_msi_virq_batch>> assert(!vdev->defer_kvm_irq_routing);
+     *   - hw/vfio/pci.c|712| <<vfio_prepare_kvm_msi_virq_batch>> vdev->defer_kvm_irq_routing = true;
+     *   - hw/vfio/pci.c|720| <<vfio_commit_kvm_msi_virq_batch>> assert(vdev->defer_kvm_irq_routing);
+     *   - hw/vfio/pci.c|721| <<vfio_commit_kvm_msi_virq_batch>> vdev->defer_kvm_irq_routing = false;
+     */
     assert(vdev->defer_kvm_irq_routing);
     vdev->defer_kvm_irq_routing = false;
 
@@ -662,6 +772,11 @@ static void vfio_commit_kvm_msi_virq_batch(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1373| <<vfio_pci_write_config>> vfio_msix_enable(vdev);
+ *   - hw/vfio/pci.c|2712| <<vfio_pci_load_config>> vfio_msix_enable(vdev);
+ */
 static void vfio_msix_enable(VFIOPCIDevice *vdev)
 {
     int ret;
@@ -858,6 +973,10 @@ static void vfio_msi_disable(VFIOPCIDevice *vdev)
     trace_vfio_msi_disable(vdev->vbasedev.name);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1302| <<vfio_pci_write_config>> vfio_update_msi(vdev);
+ */
 static void vfio_update_msi(VFIOPCIDevice *vdev)
 {
     int i;
@@ -1244,6 +1363,19 @@ uint32_t vfio_pci_read_config(PCIDevice *pdev, uint32_t addr, int len)
     return val;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci-quirks.c|171| <<vfio_generic_window_quirk_data_write>> vfio_pci_write_config(&vdev->pdev, window->address_val, data, size);
+ *   - hw/vfio/pci-quirks.c|225| <<vfio_generic_quirk_mirror_write>> vfio_pci_write_config(&vdev->pdev, addr, data, size);
+ *   - hw/vfio/pci-quirks.c|647| <<vfio_nvidia_3d0_quirk_write>> vfio_pci_write_config(&vdev->pdev, offset, data, size);
+ *   - hw/vfio/pci-quirks.c|1396| <<vfio_radeon_reset>> vfio_pci_write_config(pdev, PCI_COMMAND, PCI_COMMAND_MEMORY, 2);
+ *   - hw/vfio/pci-quirks.c|1409| <<vfio_radeon_reset>> vfio_pci_write_config(pdev, 0x7c, 0x39d5e86b, 4);
+ *   - hw/vfio/pci-quirks.c|1439| <<vfio_radeon_reset>> vfio_pci_write_config(pdev, PCI_COMMAND, 0, 2);
+ *   - hw/vfio/pci.c|2480| <<vfio_pci_pre_reset>> vfio_pci_write_config(pdev, vdev->pm_cap + PCI_PM_CTRL, pmcsr, 2);
+ *   - hw/vfio/pci.c|2498| <<vfio_pci_pre_reset>> vfio_pci_write_config(pdev, PCI_COMMAND, cmd, 2);
+ *   - hw/vfio/pci.c|2694| <<vfio_pci_load_config>> vfio_pci_write_config(pdev, PCI_COMMAND,
+ *   - hw/vfio/pci.c|3500| <<vfio_pci_dev_class_init>> pdc->config_write = vfio_pci_write_config;
+ */
 void vfio_pci_write_config(PCIDevice *pdev,
                            uint32_t addr, uint32_t val, int len)
 {
diff --git a/hw/vfio/pci.h b/hw/vfio/pci.h
index 6e64a2654..d1793ae10 100644
--- a/hw/vfio/pci.h
+++ b/hw/vfio/pci.h
@@ -175,6 +175,15 @@ struct VFIOPCIDevice {
     bool no_vfio_ioeventfd;
     bool enable_ramfb;
     OnOffAuto ramfb_migrate;
+    /*
+     * 在以下使用VFIOPCIDevice->defer_kvm_irq_routing:
+     *   - hw/vfio/pci.c|576| <<vfio_msix_vector_do_use>> if (vdev->defer_kvm_irq_routing) {
+     *   - hw/vfio/pci.c|602| <<vfio_msix_vector_do_use>> if (!vdev->defer_kvm_irq_routing) {
+     *   - hw/vfio/pci.c|711| <<vfio_prepare_kvm_msi_virq_batch>> assert(!vdev->defer_kvm_irq_routing);
+     *   - hw/vfio/pci.c|712| <<vfio_prepare_kvm_msi_virq_batch>> vdev->defer_kvm_irq_routing = true;
+     *   - hw/vfio/pci.c|720| <<vfio_commit_kvm_msi_virq_batch>> assert(vdev->defer_kvm_irq_routing);
+     *   - hw/vfio/pci.c|721| <<vfio_commit_kvm_msi_virq_batch>> vdev->defer_kvm_irq_routing = false;
+     */
     bool defer_kvm_irq_routing;
     bool clear_parent_atomics_on_exit;
     VFIODisplay *dpy;
diff --git a/hw/virtio/virtio-bus.c b/hw/virtio/virtio-bus.c
index 896feb37a..81b9d782d 100644
--- a/hw/virtio/virtio-bus.c
+++ b/hw/virtio/virtio-bus.c
@@ -216,6 +216,14 @@ void virtio_bus_release_ioeventfd(VirtioBusState *bus)
     }
 }
 
+/*
+ * 在以下使用virtio_bus_start_ioeventfd():
+ *   - hw/s390x/virtio-ccw.c|136| <<virtio_ccw_start_ioeventfd>> virtio_bus_start_ioeventfd(&dev->bus);
+ *   - hw/virtio/virtio-bus.c|215| <<virtio_bus_release_ioeventfd>> virtio_bus_start_ioeventfd(bus);
+ *   - hw/virtio/virtio-mmio.c|63| <<virtio_mmio_start_ioeventfd>> virtio_bus_start_ioeventfd(&proxy->bus);
+ *   - hw/virtio/virtio-pci.c|375| <<virtio_pci_start_ioeventfd>> virtio_bus_start_ioeventfd(&proxy->bus);
+ *   - hw/virtio/virtio.c|3902| <<virtio_device_start_ioeventfd>> return virtio_bus_start_ioeventfd(vbus);
+ */
 int virtio_bus_start_ioeventfd(VirtioBusState *bus)
 {
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(bus);
@@ -269,6 +277,20 @@ bool virtio_bus_ioeventfd_enabled(VirtioBusState *bus)
     return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|1807| <<virtio_blk_start_ioeventfd>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, true);
+ *   - hw/block/virtio-blk.c|1813| <<virtio_blk_start_ioeventfd>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/block/virtio-blk.c|1928| <<virtio_blk_stop_ioeventfd>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|57| <<virtio_scsi_set_host_notifier>> rc = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), n, true);
+ *   - hw/scsi/virtio-scsi-dataplane.c|168| <<virtio_scsi_dataplane_start>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|222| <<virtio_scsi_dataplane_stop>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/virtio/vhost.c|1624| <<vhost_dev_disable_notifiers_nvqs>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i, false);
+ *   - hw/virtio/vhost.c|1668| <<vhost_dev_enable_notifiers>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i, true);
+ *   - hw/virtio/virtio.c|3850| <<virtio_device_start_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, true);
+ *   - hw/virtio/virtio.c|3879| <<virtio_device_start_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, false);
+ *   - hw/virtio/virtio.c|3922| <<virtio_device_stop_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, false);
+ */
 /*
  * This function switches ioeventfd on/off in the device.
  * The caller must set or clear the handlers for the EventNotifier.
diff --git a/hw/virtio/virtio-pci.c b/hw/virtio/virtio-pci.c
index cb159fd07..c660e8b68 100644
--- a/hw/virtio/virtio-pci.c
+++ b/hw/virtio/virtio-pci.c
@@ -333,6 +333,12 @@ static int virtio_pci_ioeventfd_assign(DeviceState *d, EventNotifier *notifier,
     bool legacy = virtio_pci_legacy(proxy);
     bool modern = virtio_pci_modern(proxy);
     bool modern_pio = proxy->flags & VIRTIO_PCI_FLAG_MODERN_PIO_NOTIFY;
+    /*
+     * VirtIOPCIProxy *proxy:
+     * -> MemoryRegion bar;
+     * -> VirtIOPCIRegion notify;
+     * -> VirtIOPCIRegion notify_pio;
+     */
     MemoryRegion *modern_mr = &proxy->notify.mr;
     MemoryRegion *modern_notify_mr = &proxy->notify_pio.mr;
     MemoryRegion *legacy_mr = &proxy->bar;
@@ -370,6 +376,12 @@ static int virtio_pci_ioeventfd_assign(DeviceState *d, EventNotifier *notifier,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|423| <<virtio_ioport_write(VIRTIO_PCI_STATUS/VIRTIO_CONFIG_S_DRIVER_OK)>> virtio_pci_start_ioeventfd(proxy);
+ *   - hw/virtio/virtio-pci.c|1368| <<virtio_pci_vmstate_change>> virtio_pci_start_ioeventfd(proxy);
+ *   - hw/virtio/virtio-pci.c|1623| <<virtio_pci_common_write(VIRTIO_PCI_COMMON_STATUS/VIRTIO_CONFIG_S_DRIVER_OK)>> virtio_pci_start_ioeventfd(proxy);
+ */
 static void virtio_pci_start_ioeventfd(VirtIOPCIProxy *proxy)
 {
     virtio_bus_start_ioeventfd(&proxy->bus);
@@ -836,6 +848,11 @@ static void kvm_virtio_pci_vq_vector_release(VirtIOPCIProxy *proxy,
     }
 }
 
+/*
+ * 在以下使用kvm_virtio_pci_irqfd_use():
+ *   - hw/virtio/virtio-pci.c|902| <<kvm_virtio_pci_vector_use_one>> ret = kvm_virtio_pci_irqfd_use(proxy, n, vector);
+ *   - hw/virtio/virtio-pci.c|1020| <<virtio_pci_one_vector_unmask>> ret = kvm_virtio_pci_irqfd_use(proxy, n, vector);
+ */
 static int kvm_virtio_pci_irqfd_use(VirtIOPCIProxy *proxy,
                                  EventNotifier *n,
                                  unsigned int vector)
@@ -874,6 +891,12 @@ static int virtio_pci_get_notifier(VirtIOPCIProxy *proxy, int queue_no,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|935| <<kvm_virtio_pci_vector_vq_use>> ret = kvm_virtio_pci_vector_use_one(proxy, queue_no);
+ *   - hw/virtio/virtio-pci.c|942| <<kvm_virtio_pci_vector_config_use>> return kvm_virtio_pci_vector_use_one(proxy, VIRTIO_CONFIG_IRQ_IDX);
+ *   - hw/virtio/virtio-pci.c|1462| <<virtio_pci_set_vector>> kvm_virtio_pci_vector_use_one(proxy, queue_no);
+ */
 static int kvm_virtio_pci_vector_use_one(VirtIOPCIProxy *proxy, int queue_no)
 {
     unsigned int vector;
@@ -922,6 +945,10 @@ undo:
     }
     return ret;
 }
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1288| <<virtio_pci_set_guest_notifiers>> r = kvm_virtio_pci_vector_vq_use(proxy, nvqs);
+ */
 static int kvm_virtio_pci_vector_vq_use(VirtIOPCIProxy *proxy, int nvqs)
 {
     int queue_no;
@@ -1176,6 +1203,13 @@ void virtio_pci_set_guest_notifier_fd_handler(VirtIODevice *vdev, VirtQueue *vq,
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1263| <<virtio_pci_set_guest_notifiers>> r = virtio_pci_set_guest_notifier(d, n, assign, with_irqfd);
+ *   - hw/virtio/virtio-pci.c|1268| <<virtio_pci_set_guest_notifiers>> r = virtio_pci_set_guest_notifier(d, VIRTIO_CONFIG_IRQ_IDX, assign, with_irqfd);
+ *   - hw/virtio/virtio-pci.c|1311| <<virtio_pci_set_guest_notifiers>> virtio_pci_set_guest_notifier(d, VIRTIO_CONFIG_IRQ_IDX, !assign, with_irqfd);
+ *   - hw/virtio/virtio-pci.c|1317| <<virtio_pci_set_guest_notifiers>> virtio_pci_set_guest_notifier(d, n, !assign, with_irqfd);
+ */
 static int virtio_pci_set_guest_notifier(DeviceState *d, int n, bool assign,
                                          bool with_irqfd)
 {
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index 871674f9b..1bb6b5145 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -148,7 +148,30 @@ struct VirtQueue
     uint16_t vector;
     VirtIOHandleOutput handle_output;
     VirtIODevice *vdev;
+    /*
+     * 在以下使用VirtQueue->guest_notifier:
+     *   - hw/virtio/virtio.c|2493| <<virtio_notify_irqfd>> defer_call(virtio_notify_irqfd_deferred_fn, &vq->guest_notifier);
+     *   - hw/virtio/virtio.c|3501| <<virtio_queue_set_guest_notifier_fd_handler>> event_notifier_set_handler(&vq->guest_notifier, virtio_queue_guest_notifier_read);
+     *   - hw/virtio/virtio.c|3504| <<virtio_queue_set_guest_notifier_fd_handler>> event_notifier_set_handler(&vq->guest_notifier, NULL);
+     *   - hw/virtio/virtio.c|3509| <<virtio_queue_set_guest_notifier_fd_handler>> virtio_queue_guest_notifier_read(&vq->guest_notifier);
+     *   - hw/virtio/virtio.c|3532| <<virtio_queue_get_guest_notifier>> return &vq->guest_notifier;
+     */
     EventNotifier guest_notifier;
+    /*
+     * 在以下使用VirtQueue->host_notifier:
+     *   - hw/virtio/virtio.c|2294| <<virtio_queue_notify>> event_notifier_set(&vq->host_notifier);
+     *   - hw/virtio/virtio.c|3578| <<virtio_queue_aio_attach_host_notifier>> aio_set_event_notifier(ctx, &vq->host_notifier,
+     *   - hw/virtio/virtio.c|3582| <<virtio_queue_aio_attach_host_notifier>> aio_set_event_notifier_poll(ctx, &vq->host_notifier,
+     *   - hw/virtio/virtio.c|3591| <<virtio_queue_aio_attach_host_notifier>> event_notifier_set(&vq->host_notifier);
+     *   - hw/virtio/virtio.c|3627| <<virtio_queue_aio_attach_host_notifier_no_poll>> aio_set_event_notifier(ctx, &vq->host_notifier,
+     *   - hw/virtio/virtio.c|3637| <<virtio_queue_aio_attach_host_notifier_no_poll>> event_notifier_set(&vq->host_notifier);
+     *   - hw/virtio/virtio.c|3642| <<virtio_queue_aio_detach_host_notifier>> aio_set_event_notifier(ctx, &vq->host_notifier, NULL, NULL, NULL);
+     *   - hw/virtio/virtio.c|3666| <<virtio_queue_get_host_notifier>> return &vq->host_notifier;
+     *   - hw/virtio/virtio.c|3827| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier,
+     *   - hw/virtio/virtio.c|3837| <<virtio_device_start_ioeventfd_impl>> event_notifier_set(&vq->host_notifier);
+     *   - hw/virtio/virtio.c|3850| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier, NULL);
+     *   - hw/virtio/virtio.c|3893| <<virtio_device_stop_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier, NULL);
+     */
     EventNotifier host_notifier;
     bool host_notifier_enabled;
     QLIST_ENTRY(VirtQueue) node;
@@ -3527,6 +3550,19 @@ void virtio_config_set_guest_notifier_fd_handler(VirtIODevice *vdev,
     }
 }
 
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|1001| <<virtio_ccw_add_irqfd>> EventNotifier *notifier = virtio_queue_get_guest_notifier(vq);
+ *   - hw/s390x/virtio-ccw.c|1011| <<virtio_ccw_remove_irqfd>> EventNotifier *notifier = virtio_queue_get_guest_notifier(vq);
+ *   - hw/s390x/virtio-ccw.c|1024| <<virtio_ccw_set_guest_notifier>> EventNotifier *notifier = virtio_queue_get_guest_notifier(vq);
+ *   - hw/virtio/vhost.c|1718| <<vhost_virtqueue_mask>> file.fd = event_notifier_get_wfd(virtio_queue_get_guest_notifier(vvq));
+ *   - hw/virtio/virtio-mmio.c|655| <<virtio_mmio_set_guest_notifier>> EventNotifier *notifier = virtio_queue_get_guest_notifier(vq);
+ *   - hw/virtio/virtio-pci.c|872| <<virtio_pci_get_notifier>> *n = virtio_queue_get_guest_notifier(vq);
+ *   - hw/virtio/virtio-pci.c|1058| <<virtio_pci_vector_unmask>> n = virtio_queue_get_guest_notifier(vq);
+ *   - hw/virtio/virtio-pci.c|1085| <<virtio_pci_vector_unmask>> n = virtio_queue_get_guest_notifier(vq);
+ *   - hw/virtio/virtio-pci.c|1104| <<virtio_pci_vector_mask>> n = virtio_queue_get_guest_notifier(vq);
+ *   - hw/virtio/virtio-pci.c|1192| <<virtio_pci_set_guest_notifier>> notifier = virtio_queue_get_guest_notifier(vq);
+ */
 EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
 {
     return &vq->guest_notifier;
@@ -3641,6 +3677,18 @@ void virtio_queue_host_notifier_read(EventNotifier *n)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/vhost-user-blk.c|304| <<vhost_user_blk_handle_output>> event_notifier_set(virtio_queue_get_host_notifier(kick_vq));
+  3 hw/block/virtio-blk.c|1880| <<virtio_blk_ioeventfd_stop_vq_bh>> EventNotifier *host_notifier = virtio_queue_get_host_notifier(vq);
+  4 hw/scsi/vhost-user-scsi.c|136| <<vhost_user_scsi_handle_output>> event_notifier_set(virtio_queue_get_host_notifier(kick_vq));
+  5 hw/scsi/virtio-scsi-dataplane.c|77| <<virtio_scsi_dataplane_stop_bh>> host_notifier = virtio_queue_get_host_notifier(vs->ctrl_vq);
+  6 hw/scsi/virtio-scsi-dataplane.c|86| <<virtio_scsi_dataplane_stop_bh>> host_notifier = virtio_queue_get_host_notifier(vs->event_vq);
+  7 hw/scsi/virtio-scsi-dataplane.c|91| <<virtio_scsi_dataplane_stop_bh>> host_notifier = virtio_queue_get_host_notifier(vs->cmd_vqs[i]);
+  8 hw/virtio/vhost.c|1251| <<vhost_virtqueue_start>> file.fd = event_notifier_get_fd(virtio_queue_get_host_notifier(vvq));
+  9 hw/virtio/virtio-bus.c|282| <<virtio_bus_set_host_notifier>> EventNotifier *notifier = virtio_queue_get_host_notifier(vq);
+ 10 hw/virtio/virtio-bus.c|316| <<virtio_bus_cleanup_host_notifier>> EventNotifier *notifier = virtio_queue_get_host_notifier(vq);
+ */
 EventNotifier *virtio_queue_get_host_notifier(VirtQueue *vq)
 {
     return &vq->host_notifier;
@@ -3784,6 +3832,16 @@ static Property virtio_properties[] = {
     DEFINE_PROP_END_OF_LIST(),
 };
 
+/*
+ * 在以下使用VirtioDeviceClass->start_ioeventfd:
+ *   - hw/block/virtio-blk.c|2181| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+ *   - hw/scsi/virtio-scsi.c|1342| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+ *   - hw/virtio/virtio.c|3965| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+ *
+ * 在以下使用virtio_device_start_ioeventfd_impl():
+ *   - hw/virtio/virtio.c|3965| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+ */
 static int virtio_device_start_ioeventfd_impl(VirtIODevice *vdev)
 {
     VirtioBusState *qbus = VIRTIO_BUS(qdev_get_parent_bus(DEVICE(vdev)));
diff --git a/include/hw/hotplug.h b/include/hw/hotplug.h
index a9840ed48..5bf50cd32 100644
--- a/include/hw/hotplug.h
+++ b/include/hw/hotplug.h
@@ -57,6 +57,29 @@ struct HotplugHandlerClass {
     /* <public> */
     hotplug_fn pre_plug;
     hotplug_fn plug;
+    /*
+     * 在以下设置HotplugHandlerClass->unplug_request:
+     *   - hw/acpi/generic_event_device.c|416| <<acpi_ged_class_init>> hc->unplug_request = acpi_ged_unplug_request_cb;
+     *   - hw/acpi/piix4.c|648| <<piix4_pm_class_init>> hc->unplug_request = piix4_device_unplug_request_cb;
+     *   - hw/arm/virt.c|3015| <<virt_machine_class_init>> hc->unplug_request = virt_machine_device_unplug_request_cb;
+     *   - hw/i386/microvm.c|667| <<microvm_class_init>> hc->unplug_request = microvm_device_unplug_request_cb;
+     *   - hw/i386/pc.c|1831| <<pc_machine_class_init>> hc->unplug_request = pc_machine_device_unplug_request_cb;
+     *   - hw/isa/lpc_ich9.c|891| <<ich9_lpc_class_init>> hc->unplug_request = ich9_pm_device_unplug_request_cb;
+     *   - hw/loongarch/virt.c|1191| <<loongarch_class_init>> hc->unplug_request = virt_machine_device_unplug_request;
+     *   - hw/pci-bridge/pci_bridge_dev.c|263| <<pci_bridge_dev_class_init>> hc->unplug_request = pci_bridge_dev_unplug_request_cb;
+     *   - hw/pci-bridge/pcie_pci_bridge.c|159| <<pcie_pci_bridge_class_init>> hc->unplug_request = pci_bridge_dev_unplug_request_cb;
+     *   - hw/pci/pcie_port.c|235| <<pcie_slot_class_init>> hc->unplug_request = pcie_cap_slot_unplug_request_cb;
+     *   - hw/ppc/spapr.c|4692| <<spapr_machine_class_init>> hc->unplug_request = spapr_machine_device_unplug_request;
+     *   - hw/ppc/spapr_pci.c|2261| <<spapr_phb_class_init>> hp->unplug_request = spapr_pci_unplug_request;
+     *   - hw/s390x/s390-pci-bus.c|1331| <<s390_pcihost_class_init>> hc->unplug_request = s390_pcihost_unplug_request;
+     *   - hw/s390x/s390-virtio-ccw.c|778| <<ccw_machine_class_init>> hc->unplug_request = s390_machine_device_unplug_request;
+     *   - hw/xen/xen-bus.c|389| <<xen_bus_class_init>> hotplug_class->unplug_request = xen_bus_unplug_request;
+     * 在以下使用HotplugHandlerClass->unplug_request:
+     *   - hw/core/hotplug.c|44| <<hotplug_handler_unplug_request>> if (hdc->unplug_request) {
+     *   - hw/core/hotplug.c|45| <<hotplug_handler_unplug_request>> hdc->unplug_request(plug_handler, plugged_dev, errp);
+     *   - hw/virtio/virtio-md-pci.c|100| <<virtio_md_pci_unplug_request>> if (hdc->unplug_request) {
+     *   - system/qdev-monitor.c|938| <<qdev_unplug>> if (hdc->unplug_request) {
+     */
     hotplug_fn unplug_request;
     hotplug_fn unplug;
     bool (*is_hotpluggable_bus)(HotplugHandler *plug_handler, BusState *bus);
diff --git a/include/hw/i386/apic_internal.h b/include/hw/i386/apic_internal.h
index d6e85833d..b762e01bf 100644
--- a/include/hw/i386/apic_internal.h
+++ b/include/hw/i386/apic_internal.h
@@ -149,6 +149,16 @@ struct APICCommonClass {
     /* send_msi emulates an APIC bus and its proper place would be in a new
      * device, but it's convenient to have it here for now.
      */
+    /*
+     * 在以下使用APICommonClass->send_msi:
+     *   - hw/i386/amd_iommu.c|1382| <<amdvi_mem_ir_write>> apic_get_class(NULL)->send_msi(&to);
+     *   - hw/i386/intel_iommu.c|400| <<vtd_generate_interrupt>> apic_get_class(NULL)->send_msi(&msi);
+     *   - hw/i386/intel_iommu.c|3628| <<vtd_mem_ir_write>> apic_get_class(NULL)->send_msi(&to);
+     *   - hw/i386/kvm/apic.c|257| <<kvm_apic_class_init>> k->send_msi = kvm_send_msi;
+     *   - hw/i386/xen/xen_apic.c|89| <<xen_apic_class_init>> k->send_msi = xen_send_msi;
+     *   - hw/intc/apic.c|1193| <<apic_class_init>> k->send_msi = apic_send_msi;
+     *   - target/i386/whpx/whpx-apic.c|267| <<whpx_apic_class_init>> k->send_msi = whpx_send_msi;
+     */
     void (*send_msi)(MSIMessage *msi);
 };
 
diff --git a/include/hw/pci/pci_device.h b/include/hw/pci/pci_device.h
index d3dd0f64b..bb61a3f96 100644
--- a/include/hw/pci/pci_device.h
+++ b/include/hw/pci/pci_device.h
@@ -112,6 +112,18 @@ struct PCIDevice {
 
     /* Space to store MSIX table & pending bit array */
     uint8_t *msix_table;
+    /*
+     * 在以下使用PCIDevice->msix_pba:
+     *   - hw/pci/msix.c|71| <<msix_pending_byte>> return dev->msix_pba + vector / 8;
+     *   - hw/pci/msix.c|311| <<msix_pba_mmio_read>> return pci_get_long(dev->msix_pba + addr);
+     *   - hw/pci/msix.c|423| <<msix_init>> dev->msix_pba = g_malloc0(pba_size);
+     *   - hw/pci/msix.c|514| <<msix_uninit>> g_free(dev->msix_pba);
+     *   - hw/pci/msix.c|515| <<msix_uninit>> dev->msix_pba = NULL;
+     *   - hw/pci/msix.c|541| <<msix_save>> qemu_put_buffer(f, dev->msix_pba, DIV_ROUND_UP(n, 8));
+     *   - hw/pci/msix.c|556| <<msix_load>> qemu_get_buffer(f, dev->msix_pba, DIV_ROUND_UP(n, 8));
+     *   - hw/pci/msix.c|608| <<msix_reset>> memset(dev->msix_pba, 0, QEMU_ALIGN_UP(dev->msix_entries_nr, 64) / 8);
+     *   - hw/usb/hcd-xhci-pci.c|171| <<usb_xhci_pci_exit>> if (dev->msix_table && dev->msix_pba && dev->msix_entry_used) {
+     */
     uint8_t *msix_pba;
 
     /* May be used by INTx or MSI during interrupt notification */
@@ -125,6 +137,15 @@ struct PCIDevice {
     MemoryRegion msix_exclusive_bar;
     /* Memory Regions for MSIX table and pending bit entries. */
     MemoryRegion msix_table_mmio;
+    /*
+     * 在以下使用PCIDevice->msix_pba_mmio:
+     *   - hw/pci/msix.c|416| <<msix_init>> memory_region_init_io(&dev->msix_pba_mmio, OBJECT(dev), &msix_pba_mmio_ops, dev, "msix-pba", pba_size);
+     *   - hw/pci/msix.c|418| <<msix_init>> memory_region_add_subregion(pba_bar, pba_offset, &dev->msix_pba_mmio);
+     *   - hw/pci/msix.c|498| <<msix_uninit>> memory_region_del_subregion(pba_bar, &dev->msix_pba_mmio);
+     *   - hw/vfio/pci.c|359| <<vfio_msi_interrupt>> memory_region_set_enabled(&vdev->pdev.msix_pba_mmio, true);
+     *   - hw/vfio/pci.c|632| <<vfio_msix_vector_do_use>> memory_region_set_enabled(&vdev->pdev.msix_pba_mmio, false);
+     *   - hw/vfio/pci.c|1737| <<vfio_msix_setup>> memory_region_set_enabled(&vdev->pdev.msix_pba_mmio, false);
+     */
     MemoryRegion msix_pba_mmio;
     /* Reference-count for entries actually in use by driver. */
     unsigned *msix_entry_used;
@@ -153,8 +174,38 @@ struct PCIDevice {
     PCIINTxRoutingNotifier intx_routing_notifier;
 
     /* MSI-X notifiers */
+    /*
+     * 在以下使用PCIDevice->msix_vector_use_notifier:
+     *   - hw/misc/ivshmem.c|795| <<ivshmem_disable_irqfd>> if (!pdev->msix_vector_use_notifier) {
+     *   - hw/pci/msix.c|113| <<msix_fire_vector_notifier>> if (!dev->msix_vector_use_notifier) {
+     *   - hw/pci/msix.c|120| <<msix_fire_vector_notifier>> ret = dev->msix_vector_use_notifier(dev, vector, msg);
+     *   - hw/pci/msix.c|607| <<msix_set_notifier_for_vector>> return dev->msix_vector_use_notifier(dev, vector, msg);
+     *   - hw/pci/msix.c|627| <<msix_set_vector_notifiers>> dev->msix_vector_use_notifier = use_notifier;
+     *   - hw/pci/msix.c|649| <<msix_set_vector_notifiers>> dev->msix_vector_use_notifier = NULL;
+     *   - hw/pci/msix.c|659| <<msix_unset_vector_notifiers>> assert(dev->msix_vector_use_notifier &&
+     *   - hw/pci/msix.c|668| <<msix_unset_vector_notifiers>> dev->msix_vector_use_notifier = NULL;
+     */
     MSIVectorUseNotifier msix_vector_use_notifier;
+    /*
+     * 在以下使用PCIDevice->msix_vector_release_notifier:
+     *   - hw/pci/msix.c|117| <<msix_fire_vector_notifier>> dev->msix_vector_release_notifier(dev, vector);
+     *   - hw/pci/msix.c|615| <<msix_unset_notifier_for_vector>> dev->msix_vector_release_notifier(dev, vector);
+     *   - hw/pci/msix.c|628| <<msix_set_vector_notifiers>> dev->msix_vector_release_notifier = release_notifier;
+     *   - hw/pci/msix.c|650| <<msix_set_vector_notifiers>> dev->msix_vector_release_notifier = NULL;
+     *   - hw/pci/msix.c|660| <<msix_unset_vector_notifiers>> dev->msix_vector_release_notifier);
+     *   - hw/pci/msix.c|669| <<msix_unset_vector_notifiers>> dev->msix_vector_release_notifier = NULL;
+     */
     MSIVectorReleaseNotifier msix_vector_release_notifier;
+    /*
+     * 在以下使用PCIDevice->msix_vector_poll_notifier:
+     *   - hw/pci/msix.c|251| <<msix_pba_mmio_read>> if (dev->msix_vector_poll_notifier) {
+     *   - hw/pci/msix.c|254| <<msix_pba_mmio_read>> dev->msix_vector_poll_notifier(dev, vector_start, vector_end);
+     *   - hw/pci/msix.c|629| <<msix_set_vector_notifiers>> dev->msix_vector_poll_notifier = poll_notifier;
+     *   - hw/pci/msix.c|640| <<msix_set_vector_notifiers>> if (dev->msix_vector_poll_notifier) {
+     *   - hw/pci/msix.c|641| <<msix_set_vector_notifiers>> dev->msix_vector_poll_notifier(dev, 0, dev->msix_entries_nr);
+     *   - hw/pci/msix.c|651| <<msix_set_vector_notifiers>> dev->msix_vector_poll_notifier = NULL;
+     *   - hw/pci/msix.c|670| <<msix_unset_vector_notifiers>> dev->msix_vector_poll_notifier = NULL;
+     */
     MSIVectorPollNotifier msix_vector_poll_notifier;
 
     /* ID of standby device in net_failover pair */
diff --git a/include/hw/virtio/virtio.h b/include/hw/virtio/virtio.h
index 7d5ffdc14..38d0aa447 100644
--- a/include/hw/virtio/virtio.h
+++ b/include/hw/virtio/virtio.h
@@ -206,6 +206,13 @@ struct VirtioDeviceClass {
      * must mask in frontend instead.
      */
     void (*guest_notifier_mask)(VirtIODevice *vdev, int n, bool mask);
+    /*
+     * 在以下使用VirtioDeviceClass->start_ioeventfd:
+     *   - hw/block/virtio-blk.c|2181| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+     *   - hw/scsi/virtio-scsi.c|1342| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+     *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+     *   - hw/virtio/virtio.c|3965| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+     */
     int (*start_ioeventfd)(VirtIODevice *vdev);
     void (*stop_ioeventfd)(VirtIODevice *vdev);
     /* Saving and loading of a device; trying to deprecate save/load
diff --git a/include/sysemu/kvm_int.h b/include/sysemu/kvm_int.h
index 882e37e12..495f09599 100644
--- a/include/sysemu/kvm_int.h
+++ b/include/sysemu/kvm_int.h
@@ -95,9 +95,48 @@ struct KVMState
     unsigned int sigmask_len;
     GHashTable *gsimap;
 #ifdef KVM_CAP_IRQ_ROUTING
+    /*
+     * 在以下使用KVMState->irq_routes:
+     *   - accel/kvm/kvm-all.c|1820| <<kvm_init_irq_routing>> s->irq_routes = g_malloc0(sizeof(*s->irq_routes));
+     *   - accel/kvm/kvm-all.c|1854| <<kvm_irqchip_commit_routes>> s->irq_routes->flags = 0;
+     *   - accel/kvm/kvm-all.c|1856| <<kvm_irqchip_commit_routes>> ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);
+     *   - accel/kvm/kvm-all.c|1866| <<kvm_add_routing_entry>> if (s->irq_routes->nr == s->nr_allocated_irq_routes) {
+     *   - accel/kvm/kvm-all.c|1873| <<kvm_add_routing_entry>> s->irq_routes = g_realloc(s->irq_routes, size);
+     *   - accel/kvm/kvm-all.c|1876| <<kvm_add_routing_entry>> n = s->irq_routes->nr++;
+     *   - accel/kvm/kvm-all.c|1877| <<kvm_add_routing_entry>> new = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|1890| <<kvm_update_routing_entry>> for (n = 0; n < s->irq_routes->nr; n++) {
+     *   - accel/kvm/kvm-all.c|1891| <<kvm_update_routing_entry>> entry = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|1931| <<kvm_irqchip_release_virq>> for (i = 0; i < s->irq_routes->nr; i++) {
+     *   - accel/kvm/kvm-all.c|1932| <<kvm_irqchip_release_virq>> e = &s->irq_routes->entries[i];
+     *   - accel/kvm/kvm-all.c|1934| <<kvm_irqchip_release_virq>> s->irq_routes->nr--;
+     *   - accel/kvm/kvm-all.c|1935| <<kvm_irqchip_release_virq>> *e = s->irq_routes->entries[s->irq_routes->nr];
+     *   - accel/kvm/kvm-all.c|2056| <<kvm_irqchip_add_msi_route>> if (s->irq_routes->nr < s->gsi_count) {
+     */
     struct kvm_irq_routing *irq_routes;
+    /*
+     * 在以下使用KVMState->nr_allocated_irq_routes:
+     *   - accel/kvm/kvm-all.c|1821| <<kvm_init_irq_routing>> s->nr_allocated_irq_routes = 0;
+     *   - accel/kvm/kvm-all.c|1866| <<kvm_add_routing_entry>> if (s->irq_routes->nr == s->nr_allocated_irq_routes) {
+     *   - accel/kvm/kvm-all.c|1867| <<kvm_add_routing_entry>> n = s->nr_allocated_irq_routes * 2;
+     *   - accel/kvm/kvm-all.c|1874| <<kvm_add_routing_entry>> s->nr_allocated_irq_routes = n;
+     */
     int nr_allocated_irq_routes;
+    /*
+     * 在以下使用KVMState->used_gsi_bitmap:
+     *   - accel/kvm/kvm-all.c|1801| <<set_gsi>> set_bit(gsi, s->used_gsi_bitmap);
+     *   - accel/kvm/kvm-all.c|1806| <<clear_gsi>> clear_bit(gsi, s->used_gsi_bitmap);
+     *   - accel/kvm/kvm-all.c|1816| <<kvm_init_irq_routing>> s->used_gsi_bitmap = bitmap_new(gsi_count);
+     *   - accel/kvm/kvm-all.c|1963| <<kvm_irqchip_get_virq>> next_virq = find_first_zero_bit(s->used_gsi_bitmap, s->gsi_count);
+     */
     unsigned long *used_gsi_bitmap;
+    /*
+     * 在以下使用KVMState->gsi_count:
+     *   - accel/kvm/kvm-all.c|1817| <<kvm_init_irq_routing>> s->gsi_count = gsi_count;
+     *   - accel/kvm/kvm-all.c|1912| <<kvm_irqchip_add_irq_route>> assert(pin < s->gsi_count);
+     *   - accel/kvm/kvm-all.c|1963| <<kvm_irqchip_get_virq>> next_virq = find_first_zero_bit(s->used_gsi_bitmap, s->gsi_count);
+     *   - accel/kvm/kvm-all.c|1964| <<kvm_irqchip_get_virq>> if (next_virq >= s->gsi_count) {
+     *   - accel/kvm/kvm-all.c|2056| <<kvm_irqchip_add_msi_route>> if (s->irq_routes->nr < s->gsi_count) {
+     */
     unsigned int gsi_count;
 #endif
     KVMMemoryListener memory_listener;
diff --git a/system/cpus.c b/system/cpus.c
index 68d161d96..c3ed8ede1 100644
--- a/system/cpus.c
+++ b/system/cpus.c
@@ -357,6 +357,10 @@ static void sigbus_reraise(void)
     abort();
 }
 
+/*
+ * 在以下使用sigbug_handler():
+ *   - system/cpus.c|389| <<qemu_init_sigbus>> action.sa_sigaction = sigbus_handler;
+ */
 static void sigbus_handler(int n, siginfo_t *siginfo, void *ctx)
 {
     if (siginfo->si_code != BUS_MCEERR_AO && siginfo->si_code != BUS_MCEERR_AR) {
diff --git a/system/memory.c b/system/memory.c
index a229a7998..3f4965fd6 100644
--- a/system/memory.c
+++ b/system/memory.c
@@ -39,6 +39,14 @@
 
 static unsigned memory_region_transaction_depth;
 static bool memory_region_update_pending;
+/*
+ * 在以下使用ioeventfd_update_pending():
+ *   - system/memory.c|1140| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - system/memory.c|1142| <<memory_region_transaction_commit>> } else if (ioeventfd_update_pending) {
+ *   - system/memory.c|1146| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - system/memory.c|2606| <<memory_region_add_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ *   - system/memory.c|2641| <<memory_region_del_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ */
 static bool ioeventfd_update_pending;
 unsigned int global_dirty_tracking;
 
@@ -776,6 +784,10 @@ static FlatView *generate_memory_topology(MemoryRegion *mr)
     return view;
 }
 
+/*
+ * called by:
+ *   - system/memory.c|883| <<address_space_update_ioeventfds>> address_space_add_del_ioeventfds(as, ioeventfds, ioeventfd_nb, as->ioeventfds, as->ioeventfd_nb);
+ */
 static void address_space_add_del_ioeventfds(AddressSpace *as,
                                              MemoryRegionIoeventfd *fds_new,
                                              unsigned fds_new_nb,
@@ -2556,6 +2568,18 @@ void memory_region_clear_flush_coalesced(MemoryRegion *mr)
     }
 }
 
+/*
+ * called by:
+ *   - hw/misc/ivshmem.c|365| <<ivshmem_add_eventfd>> memory_region_add_eventfd(&s->ivshmem_mmio, DOORBELL, 4, true, (posn << 16) | i, &s->peers[posn].eventfds[i]);
+ *   - hw/misc/pci-testdev.c|113| <<pci_testdev_start>> memory_region_add_eventfd(test->mr, le32_to_cpu(test->hdr->offset), test->size, test->match_data, test->hdr->data, &test->notifier);
+ *   - hw/nvme/ctrl.c|4523| <<nvme_init_cq_ioeventfd>> memory_region_add_eventfd(&n->iomem, 0x1000 + offset, 4, false, 0, &cq->notifier);
+ *   - hw/nvme/ctrl.c|4552| <<nvme_init_sq_ioeventfd>> memory_region_add_eventfd(&n->iomem, 0x1000 + offset, 4, false, 0, &sq->notifier);
+ *   - hw/vfio/pci-quirks.c|401| <<vfio_ioeventfd_init>> memory_region_add_eventfd(ioeventfd->mr, ioeventfd->addr, ioeventfd->size, true, ioeventfd->data, &ioeventfd->e);
+ *   - hw/virtio/virtio-mmio.c|52| <<virtio_mmio_ioeventfd_assign>> memory_region_add_eventfd(&proxy->iomem, VIRTIO_MMIO_QUEUE_NOTIFY, 4, true, n, notifier);
+ *   - hw/virtio/virtio-pci.c|345| <<virtio_pci_ioeventfd_assign>> memory_region_add_eventfd(modern_mr, modern_addr, 0, false, n, notifier);
+ *   - hw/virtio/virtio-pci.c|348| <<virtio_pci_ioeventfd_assign>> memory_region_add_eventfd(modern_notify_mr, 0, 2, true, n, notifier);
+ *   - hw/virtio/virtio-pci.c|353| <<virtio_pci_ioeventfd_assign>> memory_region_add_eventfd(legacy_mr, legacy_addr, 2, true, n, notifier);
+ */
 void memory_region_add_eventfd(MemoryRegion *mr,
                                hwaddr addr,
                                unsigned size,
@@ -2581,6 +2605,11 @@ void memory_region_add_eventfd(MemoryRegion *mr,
             break;
         }
     }
+    /*
+     * MemoryRegion *mr:
+     * -> unsigned ioeventfd_nb;
+     * -> MemoryRegionIoeventfd *ioeventfds;
+     */
     ++mr->ioeventfd_nb;
     mr->ioeventfds = g_realloc(mr->ioeventfds,
                                   sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);
diff --git a/target/arm/kvm.c b/target/arm/kvm.c
index ab85d628a..0db43fe9d 100644
--- a/target/arm/kvm.c
+++ b/target/arm/kvm.c
@@ -2356,6 +2356,11 @@ int kvm_arch_get_registers(CPUState *cs)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2876| <<kvm_cpu_exec>> kvm_arch_on_sigbus_vcpu(cpu, pending_sigbus_code, pending_sigbus_addr);
+ *   - accel/kvm/kvm-all.c|3399| <<kvm_on_sigbus>> kvm_arch_on_sigbus_vcpu(first_cpu, code, addr);
+ */
 void kvm_arch_on_sigbus_vcpu(CPUState *c, int code, void *addr)
 {
     ram_addr_t ram_addr;
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index e68cbe929..4f30321d7 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -5381,6 +5381,10 @@ bool kvm_arch_stop_on_emulation_error(CPUState *cs)
            ((env->segs[R_CS].selector  & 3) != 3);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1823| <<kvm_init_irq_routing>> kvm_arch_init_irq_routing(s);
+ */
 void kvm_arch_init_irq_routing(KVMState *s)
 {
     /* We know at this point that we're using the in-kernel
@@ -5453,6 +5457,11 @@ uint64_t kvm_swizzle_msi_ext_dest_id(uint64_t address)
     return address;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2078| <<kvm_irqchip_add_msi_route>> if (kvm_arch_fixup_msi_route(&kroute, msg.address, msg.data, dev)) {
+ *   - accel/kvm/kvm-all.c|2129| <<kvm_irqchip_update_msi_route>> if (kvm_arch_fixup_msi_route(&kroute, msg.address, msg.data, dev)) {
+ */
 int kvm_arch_fixup_msi_route(struct kvm_irq_routing_entry *route,
                              uint64_t address, uint32_t data, PCIDevice *dev)
 {
diff --git a/util/event_notifier-posix.c b/util/event_notifier-posix.c
index 76420c5b5..1dfe9252a 100644
--- a/util/event_notifier-posix.c
+++ b/util/event_notifier-posix.c
@@ -32,6 +32,61 @@ void event_notifier_init_fd(EventNotifier *e, int fd)
 }
 #endif
 
+/*
+ * called by:
+ *   - block/linux-aio.c|456| <<laio_init>> rc = event_notifier_init(&s->e, false);
+ *   - block/nvme.c|761| <<nvme_init>> ret = event_notifier_init(&s->irq_notifier[MSIX_SHARED_IRQ_IDX], 0);
+ *   - block/win32-aio.c|194| <<win32_aio_init>> if (event_notifier_init(&s->e, false) < 0) {
+ *   - contrib/ivshmem-server/ivshmem-server.c|176| <<ivshmem_server_handle_new_conn>> if (event_notifier_init(&peer->vectors[i], FALSE) < 0) {
+ *   - hw/hyperv/hyperv.c|414| <<hyperv_sint_route_new>> r = event_notifier_init(ack_notifier, false);
+ *   - hw/hyperv/hyperv.c|428| <<hyperv_sint_route_new>> r = event_notifier_init(&sint_route->sint_set_notifier, false);
+ *   - hw/hyperv/hyperv_testdev.c|216| <<evt_conn_create>> assert(!event_notifier_init(&conn->notifier, false));
+ *   - hw/hyperv/vmbus.c|1426| <<open_channel>> if (event_notifier_init(&chan->notifier, 0)) {
+ *   - hw/hyperv/vmbus.c|2421| <<vmbus_realize>> ret = event_notifier_init(&vmbus->notifier, 0);
+ *   - hw/misc/pci-testdev.c|294| <<pci_testdev_realize>> r = event_notifier_init(&test->notifier, 0);
+ *   - hw/nvme/ctrl.c|4517| <<nvme_init_cq_ioeventfd>> ret = event_notifier_init(&cq->notifier, 0);
+ *   - hw/nvme/ctrl.c|4546| <<nvme_init_sq_ioeventfd>> ret = event_notifier_init(&sq->notifier, 0);
+ *   - hw/remote/proxy.c|56| <<setup_irqfd>> event_notifier_init(&dev->intr, 0);
+ *   - hw/remote/proxy.c|57| <<setup_irqfd>> event_notifier_init(&dev->resample, 0);
+ *   - hw/s390x/virtio-ccw.c|1028| <<virtio_ccw_set_guest_notifier>> int r = event_notifier_init(notifier, 0);
+ *   - hw/usb/ccid-card-emulated.c|406| <<init_event_notifier>> if (event_notifier_init(&card->notifier, false) < 0) {
+ *   - hw/usb/u2f-emulated.c|325| <<u2f_emulated_realize>> if (event_notifier_init(&key->notifier, false) < 0) {
+ *   - hw/vfio/ap.c|110| <<vfio_ap_register_irq_notifier>> if (event_notifier_init(notifier, 0)) {
+ *   - hw/vfio/ccw.c|427| <<vfio_ccw_register_irq_notifier>> if (event_notifier_init(notifier, 0)) {
+ *   - hw/vfio/pci-quirks.c|361| <<vfio_ioeventfd_init>> if (event_notifier_init(&ioeventfd->e, 0)) {
+ *   - hw/vfio/pci.c|137| <<vfio_intx_enable_kvm>> if (event_notifier_init(&vdev->intx.unmask, 0)) {
+ *   - hw/vfio/pci.c|290| <<vfio_intx_enable>> ret = event_notifier_init(&vdev->intx.interrupt, 0);
+ *   - hw/vfio/pci.c|479| <<vfio_connect_kvm_msi_virq>> if (event_notifier_init(&vector->kvm_interrupt, 0)) {
+ *   - hw/vfio/pci.c|528| <<vfio_msix_vector_do_use>> if (event_notifier_init(&vector->interrupt, 0)) {
+ *   - hw/vfio/pci.c|751| <<vfio_msi_enable>> if (event_notifier_init(&vector->interrupt, 0)) {
+ *   - hw/vfio/pci.c|2851| <<vfio_register_err_notifier>> if (event_notifier_init(&vdev->err_notifier, 0)) {
+ *   - hw/vfio/pci.c|2917| <<vfio_register_req_notifier>> if (event_notifier_init(&vdev->req_notifier, 0)) {
+ *   - hw/vfio/platform.c|77| <<vfio_init_intp>> ret = event_notifier_init(intp->interrupt, 0);
+ *   - hw/vfio/platform.c|88| <<vfio_init_intp>> ret = event_notifier_init(intp->unmask, 0);
+ *   - hw/virtio/vhost-vdpa.c|1054| <<vhost_vdpa_svq_set_fds>> r = event_notifier_init(&svq->hdev_kick, 0);
+ *   - hw/virtio/vhost-vdpa.c|1060| <<vhost_vdpa_svq_set_fds>> r = event_notifier_init(&svq->hdev_call, 0);
+ *   - hw/virtio/vhost.c|1385| <<vhost_virtqueue_init>> int r = event_notifier_init(&vq->masked_notifier, 0);
+ *   - hw/virtio/vhost.c|1400| <<vhost_virtqueue_init>> r = event_notifier_init(&vq->error_notifier, 0);
+ *   - hw/virtio/vhost.c|2031| <<vhost_dev_start>> r = event_notifier_init(
+ *   - hw/virtio/virtio-bus.c|290| <<virtio_bus_set_host_notifier>> r = event_notifier_init(notifier, 1);
+ *   - hw/virtio/virtio-mmio.c|658| <<virtio_mmio_set_guest_notifier>> int r = event_notifier_init(notifier, 0);
+ *   - hw/virtio/virtio-mmio.c|684| <<virtio_mmio_set_config_guest_notifier>> r = event_notifier_init(notifier, 0);
+ *   - hw/virtio/virtio-pci.c|1196| <<virtio_pci_set_guest_notifier>> int r = event_notifier_init(notifier, 0);
+ *   - tests/unit/test-aio.c|261| <<test_set_event_notifier>> event_notifier_init(&data.e, false);
+ *   - tests/unit/test-aio.c|275| <<test_wait_event_notifier>> event_notifier_init(&data.e, false);
+ *   - tests/unit/test-aio.c|300| <<test_flush_event_notifier>> event_notifier_init(&data.e, false);
+ *   - tests/unit/test-aio.c|327| <<test_wait_event_notifier_noflush>> event_notifier_init(&data.e, false);
+ *   - tests/unit/test-aio.c|340| <<test_wait_event_notifier_noflush>> event_notifier_init(&dummy.e, false);
+ *   - tests/unit/test-aio.c|381| <<test_timer_schedule>> event_notifier_init(&e, false);
+ *   - tests/unit/test-aio.c|592| <<test_source_set_event_notifier>> event_notifier_init(&data.e, false);
+ *   - tests/unit/test-aio.c|606| <<test_source_wait_event_notifier>> event_notifier_init(&data.e, false);
+ *   - tests/unit/test-aio.c|631| <<test_source_flush_event_notifier>> event_notifier_init(&data.e, false);
+ *   - tests/unit/test-aio.c|658| <<test_source_wait_event_notifier_noflush>> event_notifier_init(&data.e, false);
+ *   - tests/unit/test-aio.c|671| <<test_source_wait_event_notifier_noflush>> event_notifier_init(&dummy.e, false);
+ *   - tests/unit/test-nested-aio-poll.c|93| <<test>> event_notifier_init(&td.poll_notifier, 1);
+ *   - tests/unit/test-nested-aio-poll.c|98| <<test>> event_notifier_init(&td.dummy_notifier, 0);
+ *   - util/async.c|584| <<aio_context_new>> ret = event_notifier_init(&ctx->notifier, false);
+ */
 int event_notifier_init(EventNotifier *e, int active)
 {
     int fds[2];
diff --git a/util/main-loop.c b/util/main-loop.c
index a0386cfeb..1bce9c2fa 100644
--- a/util/main-loop.c
+++ b/util/main-loop.c
@@ -635,6 +635,39 @@ GSource *iohandler_get_g_source(void)
     return aio_get_g_source(iohandler_ctx);
 }
 
+/*
+ * 一些例子:
+ *   - hw/net/vhost_net.c|284| <<vhost_net_start_one>> qemu_set_fd_handler(net->backend, NULL, NULL, NULL);
+ *   - hw/vfio/ap.c|118| <<vfio_ap_register_irq_notifier>> qemu_set_fd_handler(fd, fd_read, NULL, vapdev);
+ *   - hw/vfio/ap.c|122| <<vfio_ap_register_irq_notifier>> qemu_set_fd_handler(fd, NULL, NULL, vapdev);
+ *   - hw/vfio/ap.c|151| <<vfio_ap_unregister_irq_notifier>> qemu_set_fd_handler(event_notifier_get_fd(notifier), NULL, NULL, vapdev);
+ *   - hw/vfio/ccw.c|435| <<vfio_ccw_register_irq_notifier>> qemu_set_fd_handler(fd, fd_read, NULL, vcdev);
+ *   - hw/vfio/ccw.c|439| <<vfio_ccw_register_irq_notifier>> qemu_set_fd_handler(fd, NULL, NULL, vcdev);
+ *   - hw/vfio/ccw.c|473| <<vfio_ccw_unregister_irq_notifier>> qemu_set_fd_handler(event_notifier_get_fd(notifier), NULL, NULL, vcdev);
+ *   - hw/vfio/pci-quirks.c|312| <<vfio_ioeventfd_exit>> qemu_set_fd_handler(event_notifier_get_fd(&ioeventfd->e), NULL, NULL, NULL);
+ *   - hw/vfio/pci-quirks.c|397| <<vfio_ioeventfd_init>> qemu_set_fd_handler(event_notifier_get_fd(&ioeventfd->e), vfio_ioeventfd_handler, NULL, ioeventfd);
+ *   - hw/vfio/pci.c|131| <<vfio_intx_enable_kvm>> qemu_set_fd_handler(irq_fd, NULL, NULL, vdev);
+ *   - hw/vfio/pci.c|172| <<vfio_intx_enable_kvm>> qemu_set_fd_handler(irq_fd, vfio_intx_interrupt, NULL, vdev);
+ *   - hw/vfio/pci.c|202| <<vfio_intx_disable_kvm>> qemu_set_fd_handler(event_notifier_get_fd(&vdev->intx.interrupt), vfio_intx_interrupt, NULL, vdev);
+ *   - hw/vfio/pci.c|296| <<vfio_intx_enable>> qemu_set_fd_handler(fd, vfio_intx_interrupt, NULL, vdev);
+ *   - hw/vfio/pci.c|300| <<vfio_intx_enable>> qemu_set_fd_handler(fd, NULL, NULL, vdev);
+ *   - hw/vfio/pci.c|328| <<vfio_intx_disable>> qemu_set_fd_handler(fd, NULL, NULL, vdev);
+ *   - hw/vfio/pci.c|549| <<vfio_msix_vector_do_use>> qemu_set_fd_handler(event_notifier_get_fd(&vector->interrupt), handler, NULL, vector);
+ *   - hw/vfio/pci.c|795| <<vfio_msi_enable>> qemu_set_fd_handler(event_notifier_get_fd(&vector->interrupt), vfio_msi_interrupt, NULL, vector);
+ *   - hw/vfio/pci.c|849| <<vfio_msi_disable_common>> qemu_set_fd_handler(event_notifier_get_fd(&vector->interrupt), NULL, NULL, NULL);
+ *   - hw/vfio/pci.c|2902| <<vfio_register_err_notifier>> qemu_set_fd_handler(fd, vfio_err_notifier_handler, NULL, vdev);
+ *   - hw/vfio/pci.c|2907| <<vfio_register_err_notifier>> qemu_set_fd_handler(fd, NULL, NULL, vdev);
+ *   - hw/vfio/pci.c|2925| <<vfio_unregister_err_notifier>> qemu_set_fd_handler(event_notifier_get_fd(&vdev->err_notifier), NULL, NULL, vdev);
+ *   - hw/vfio/pci.c|2967| <<vfio_register_req_notifier>> qemu_set_fd_handler(fd, vfio_req_notifier_handler, NULL, vdev);
+ *   - hw/vfio/pci.c|2972| <<vfio_register_req_notifier>> qemu_set_fd_handler(fd, NULL, NULL, vdev);
+ *   - hw/vfio/pci.c|2991| <<vfio_unregister_req_notifier>> qemu_set_fd_handler(event_notifier_get_fd(&vdev->req_notifier), NULL, NULL, vdev);
+ *   - hw/vfio/platform.c|120| <<vfio_set_trigger_eventfd>> qemu_set_fd_handler(fd, (IOHandler *)handler, NULL, intp);
+ *   - hw/vfio/platform.c|126| <<vfio_set_trigger_eventfd>> qemu_set_fd_handler(fd, NULL, NULL, NULL);
+ *   - hw/vfio/platform.c|360| <<vfio_set_resample_eventfd>> qemu_set_fd_handler(fd, NULL, NULL, NULL);
+ *   - hw/virtio/vhost-backend.c|313| <<vhost_kernel_set_iotlb_callback>> qemu_set_fd_handler((uintptr_t)dev->opaque, vhost_kernel_iotlb_read, NULL, dev);
+ *   - hw/virtio/vhost-backend.c|316| <<vhost_kernel_set_iotlb_callback>> qemu_set_fd_handler((uintptr_t)dev->opaque, NULL, NULL, NULL);
+ *   - net/tap.c|75| <<tap_update_fd_handler>> qemu_set_fd_handler(s->fd, s->read_poll && s->enabled ? tap_send : NULL, s->write_poll && s->enabled ? tap_writable : NULL, s);
+ */
 void qemu_set_fd_handler(int fd,
                          IOHandler *fd_read,
                          IOHandler *fd_write,
-- 
2.34.1

