From bc10a27c712bbda43c560ca718568c87231a1552 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 11 Jun 2025 12:38:09 -0700
Subject: [PATCH 1/1] linux-v6.15

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/include/asm/kvm_host.h     |  20 +++
 arch/x86/kernel/apic/apic_flat_64.c |  57 ++++++
 arch/x86/kernel/apic/probe_64.c     |  54 ++++++
 arch/x86/kernel/apic/x2apic_phys.c  |  59 +++++++
 arch/x86/kvm/irq.c                  |  12 ++
 arch/x86/kvm/irq_comm.c             |  10 ++
 arch/x86/kvm/lapic.c                | 261 ++++++++++++++++++++++++++++
 arch/x86/kvm/lapic.h                |  30 ++++
 arch/x86/kvm/x86.c                  |   7 +
 9 files changed, 510 insertions(+)

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 7bc174a1f..7e949cd95 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -928,6 +928,13 @@ struct kvm_vcpu_arch {
 
 	u64 l1_tsc_offset;
 	u64 tsc_offset; /* current tsc offset */
+	/*
+	 * 在以下使用kvm_vcpu_arch->last_guest_tsc:
+	 *   - arch/x86/kvm/x86.c|2660| <<__kvm_synchronize_tsc>> vcpu->arch.last_guest_tsc = tsc;
+	 *   - arch/x86/kvm/x86.c|3260| <<kvm_guest_time_update>> vcpu->last_guest_tsc = tsc_timestamp;
+	 *   - arch/x86/kvm/x86.c|5018| <<kvm_arch_vcpu_load>> u64 offset = kvm_compute_l1_tsc_offset(vcpu, vcpu->arch.last_guest_tsc);
+	 *   - arch/x86/kvm/x86.c|11049| <<vcpu_enter_guest>> vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());
+	 */
 	u64 last_guest_tsc;
 	u64 last_host_tsc;
 	u64 tsc_offset_adjustment;
@@ -1371,6 +1378,19 @@ struct kvm_arch {
 	atomic_t vapics_in_nmi_mode;
 	struct mutex apic_map_lock;
 	struct kvm_apic_map __rcu *apic_map;
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|388| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|404| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty, DIRTY, UPDATE_IN_PROGRESS) == CLEAN) {
+	 *   - arch/x86/kvm/lapic.c|480| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty, UPDATE_IN_PROGRESS, CLEAN);
+	 *   - arch/x86/kvm/lapic.c|503| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|516| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|522| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|528| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|539| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2603| <<__kvm_apic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3108| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	atomic_t apic_map_dirty;
 
 	bool apic_access_memslot_enabled;
diff --git a/arch/x86/kernel/apic/apic_flat_64.c b/arch/x86/kernel/apic/apic_flat_64.c
index e0308d8c4..00d890162 100644
--- a/arch/x86/kernel/apic/apic_flat_64.c
+++ b/arch/x86/kernel/apic/apic_flat_64.c
@@ -14,6 +14,60 @@
 
 #include "local.h"
 
+/*
+ * x2apic的. "apic=verbose show_lapic=all"
+ *
+ * [    0.674958] ... APIC ID:      00000000 (0)
+ * [    0.675581] ... APIC VERSION: 00050014
+ * [    0.675924] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.675924] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.675924] 0000000000000000000000000000000000000000000000000000000000001000
+ *
+ * [    0.676419] ... APIC ID:      00000001 (1)
+ * [    0.677076] ... APIC VERSION: 00050014
+ * [    0.677418] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.677418] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.677418] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.677930] ... APIC ID:      00000002 (2)
+ * [    0.678562] ... APIC VERSION: 00050014
+ * [    0.678929] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.678929] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.678929] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.679410] ... APIC ID:      00000003 (3)
+ * [    0.680056] ... APIC VERSION: 00050014
+ * [    0.680409] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.680409] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.680409] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * nox2apic的. "apic=verbose show_lapic=all nox2apic"
+ *
+ * [    0.691664] ... APIC ID:      00000000 (0)
+ * [    0.692306] ... APIC VERSION: 00050014
+ * [    0.692662] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.692662] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.692662] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.693159] ... APIC ID:      01000000 (1)
+ * [    0.693880] ... APIC VERSION: 00050014
+ * [    0.694158] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.694158] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.694158] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.694862] ... APIC ID:      02000000 (2)
+ * [    0.695615] ... APIC VERSION: 00050014
+ * [    0.695627] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.695627] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.695627] 0000000000000000000000000000000000000000000000000000000000001000
+ *
+ * [    0.696721] ... APIC ID:      03000000 (3)
+ * [    0.697358] ... APIC VERSION: 00050014
+ * [    0.697720] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.697720] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.697720] 0000000000000000000000000000000000000000000000000000000000000000
+ */
+
 static u32 physflat_get_apic_id(u32 x)
 {
 	return (x >> 24) & 0xFF;
@@ -29,6 +83,9 @@ static int physflat_acpi_madt_oem_check(char *oem_id, char *oem_table_id)
 	return 1;
 }
 
+/*
+ * nox2apic的时候默认是这个
+ */
 static struct apic apic_physflat __ro_after_init = {
 
 	.name				= "physical flat",
diff --git a/arch/x86/kernel/apic/probe_64.c b/arch/x86/kernel/apic/probe_64.c
index ecdf0c412..c48e88981 100644
--- a/arch/x86/kernel/apic/probe_64.c
+++ b/arch/x86/kernel/apic/probe_64.c
@@ -13,6 +13,60 @@
 
 #include "local.h"
 
+/*
+ * x2apic的. "apic=verbose show_lapic=all"
+ *
+ * [    0.674958] ... APIC ID:      00000000 (0)
+ * [    0.675581] ... APIC VERSION: 00050014
+ * [    0.675924] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.675924] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.675924] 0000000000000000000000000000000000000000000000000000000000001000
+ *
+ * [    0.676419] ... APIC ID:      00000001 (1)
+ * [    0.677076] ... APIC VERSION: 00050014
+ * [    0.677418] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.677418] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.677418] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.677930] ... APIC ID:      00000002 (2)
+ * [    0.678562] ... APIC VERSION: 00050014
+ * [    0.678929] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.678929] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.678929] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.679410] ... APIC ID:      00000003 (3)
+ * [    0.680056] ... APIC VERSION: 00050014
+ * [    0.680409] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.680409] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.680409] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * nox2apic的. "apic=verbose show_lapic=all nox2apic"
+ *
+ * [    0.691664] ... APIC ID:      00000000 (0)
+ * [    0.692306] ... APIC VERSION: 00050014
+ * [    0.692662] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.692662] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.692662] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.693159] ... APIC ID:      01000000 (1)
+ * [    0.693880] ... APIC VERSION: 00050014
+ * [    0.694158] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.694158] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.694158] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.694862] ... APIC ID:      02000000 (2)
+ * [    0.695615] ... APIC VERSION: 00050014
+ * [    0.695627] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.695627] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.695627] 0000000000000000000000000000000000000000000000000000000000001000
+ *
+ * [    0.696721] ... APIC ID:      03000000 (3)
+ * [    0.697358] ... APIC VERSION: 00050014
+ * [    0.697720] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.697720] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.697720] 0000000000000000000000000000000000000000000000000000000000000000
+ */
+
 /* Select the appropriate APIC driver */
 void __init x86_64_probe_apic(void)
 {
diff --git a/arch/x86/kernel/apic/x2apic_phys.c b/arch/x86/kernel/apic/x2apic_phys.c
index 12d4c3554..9f904028e 100644
--- a/arch/x86/kernel/apic/x2apic_phys.c
+++ b/arch/x86/kernel/apic/x2apic_phys.c
@@ -5,6 +5,60 @@
 
 #include "local.h"
 
+/*
+ * x2apic的. "apic=verbose show_lapic=all"
+ *
+ * [    0.674958] ... APIC ID:      00000000 (0)
+ * [    0.675581] ... APIC VERSION: 00050014
+ * [    0.675924] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.675924] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.675924] 0000000000000000000000000000000000000000000000000000000000001000
+ *
+ * [    0.676419] ... APIC ID:      00000001 (1)
+ * [    0.677076] ... APIC VERSION: 00050014
+ * [    0.677418] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.677418] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.677418] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.677930] ... APIC ID:      00000002 (2)
+ * [    0.678562] ... APIC VERSION: 00050014
+ * [    0.678929] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.678929] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.678929] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.679410] ... APIC ID:      00000003 (3)
+ * [    0.680056] ... APIC VERSION: 00050014
+ * [    0.680409] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.680409] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.680409] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * nox2apic的. "apic=verbose show_lapic=all nox2apic"
+ *
+ * [    0.691664] ... APIC ID:      00000000 (0)
+ * [    0.692306] ... APIC VERSION: 00050014
+ * [    0.692662] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.692662] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.692662] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.693159] ... APIC ID:      01000000 (1)
+ * [    0.693880] ... APIC VERSION: 00050014
+ * [    0.694158] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.694158] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.694158] 0000000000000000000000000000000000000000000000000000000000000000
+ *
+ * [    0.694862] ... APIC ID:      02000000 (2)
+ * [    0.695615] ... APIC VERSION: 00050014
+ * [    0.695627] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.695627] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.695627] 0000000000000000000000000000000000000000000000000000000000001000
+ *
+ * [    0.696721] ... APIC ID:      03000000 (3)
+ * [    0.697358] ... APIC VERSION: 00050014
+ * [    0.697720] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.697720] 0000000000000000000000000000000000000000000000000000000000000000
+ * [    0.697720] 0000000000000000000000000000000000000000000000000000000000000000
+ */
+
 int x2apic_phys;
 
 static struct apic apic_x2apic_phys;
@@ -129,6 +183,11 @@ u32 x2apic_get_apic_id(u32 id)
 	return id;
 }
 
+/*
+ * [    0.038924] kvm-guest: APIC: eoi() replaced with kvm_guest_apic_eoi_write()
+ * [    0.211469] kvm-guest: APIC: send_IPI_mask() replaced with kvm_send_ipi_mask()
+ * [    0.212506] kvm-guest: APIC: send_IPI_mask_allbutself() replaced with kvm_send_ipi_mask_allbutself()
+ */
 static struct apic apic_x2apic_phys __ro_after_init = {
 
 	.name				= "physical x2apic",
diff --git a/arch/x86/kvm/irq.c b/arch/x86/kvm/irq.c
index 63f66c519..e9093f4d2 100644
--- a/arch/x86/kvm/irq.c
+++ b/arch/x86/kvm/irq.c
@@ -149,6 +149,10 @@ int kvm_cpu_get_interrupt(struct kvm_vcpu *v)
 	return vector;
 }
 
+/*
+ * 在以下调用kvm_inject_pending_timer_irqs():
+ *   - arch/x86/kvm/x86.c|11290| <<vcpu_run>> kvm_inject_pending_timer_irqs(vcpu);
+ */
 void kvm_inject_pending_timer_irqs(struct kvm_vcpu *vcpu)
 {
 	if (lapic_in_kernel(vcpu))
@@ -157,10 +161,18 @@ void kvm_inject_pending_timer_irqs(struct kvm_vcpu *vcpu)
 		kvm_xen_inject_timer_irqs(vcpu);
 }
 
+/*
+ * 在以下使用__kvm_migrate_timers():
+ *   - arch/x86/kvm/x86.c|10750| <<vcpu_enter_guest>> __kvm_migrate_timers(vcpu);
+ */
 void __kvm_migrate_timers(struct kvm_vcpu *vcpu)
 {
 	__kvm_migrate_apic_timer(vcpu);
 	__kvm_migrate_pit_timer(vcpu);
+	/*
+	 * vmx_migrate_timers()
+	 * 没有AMD的
+	 */
 	kvm_x86_call(migrate_timers)(vcpu);
 }
 
diff --git a/arch/x86/kvm/irq_comm.c b/arch/x86/kvm/irq_comm.c
index 8136695f7..3093d4922 100644
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@ -44,6 +44,16 @@ static int kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,
 				line_status);
 }
 
+/*
+ * 在以下使用kvm_irq_delivery_to_apic():
+ *   - arch/x86/kvm/hyperv.c|495| <<synic_set_irq>> ret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);
+ *   - arch/x86/kvm/ioapic.c|473| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, &ioapic->rtc_status.dest_map);
+ *   - arch/x86/kvm/ioapic.c|477| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);
+ *   - arch/x86/kvm/irq_comm.c|144| <<kvm_set_msi>> return kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);
+ *   - arch/x86/kvm/lapic.c|1717| <<kvm_apic_send_ipi>> kvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);
+ *   - arch/x86/kvm/x86.c|9938| <<kvm_pv_kick_cpu_op>> kvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);
+ *   - arch/x86/kvm/xen.c|629| <<kvm_xen_inject_vcpu_vector>> kvm_irq_delivery_to_apic(v->kvm, NULL, &irq, NULL);
+ */
 int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,
 		struct kvm_lapic_irq *irq, struct dest_map *dest_map)
 {
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 28e331712..f22ddc9ca 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -67,6 +67,12 @@
  * the guest, i.e. so that the interrupt arrives in the guest with minimal
  * latency relative to the deadline programmed by the guest.
  */
+/*
+ * 在以下使用lapic_timer_advance:
+ *   - arch/x86/kvm/lapic.c|70| <<global>> static bool lapic_timer_advance __read_mostly = true;
+ *   - arch/x86/kvm/lapic.c|71| <<global>> module_param(lapic_timer_advance, bool, 0444);
+ *   - arch/x86/kvm/lapic.c|3142| <<kvm_create_lapic>> if (lapic_timer_advance)
+ */
 static bool lapic_timer_advance __read_mostly = true;
 module_param(lapic_timer_advance, bool, 0444);
 
@@ -176,11 +182,21 @@ static bool kvm_use_posted_timer_interrupt(struct kvm_vcpu *vcpu)
 	return kvm_can_post_timer_interrupt(vcpu) && vcpu->mode == IN_GUEST_MODE;
 }
 
+/*
+ * 在以下调用kvm_apic_calc_x2apic_ldr:
+ *   - arch/x86/kvm/lapic.c|533| <<kvm_apic_set_x2apic_id>> u32 ldr = kvm_apic_calc_x2apic_ldr(id);
+ *   - arch/x86/kvm/lapic.c|3060| <<kvm_apic_state_fixup>> *ldr = kvm_apic_calc_x2apic_ldr(x2apic_id);
+ */
 static inline u32 kvm_apic_calc_x2apic_ldr(u32 id)
 {
 	return ((id >> 4) << 16) | (1 << (id & 0xf));
 }
 
+/*
+ * 在以下使用kvm_apic_map_get_logical_dest():
+ *   - arch/x86/kvm/lapic.c|350| <<kvm_recalculate_logical_map>> if (WARN_ON_ONCE(!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))) {
+ *   - arch/x86/kvm/lapic.c|1183| <<kvm_apic_map_get_dest_lapic>> if (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst, (u16 *)bitmap))
+ */
 static inline bool kvm_apic_map_get_logical_dest(struct kvm_apic_map *map,
 		u32 dest_id, struct kvm_lapic ***cluster, u16 *mask) {
 	switch (map->logical_mode) {
@@ -221,6 +237,10 @@ static inline bool kvm_apic_map_get_logical_dest(struct kvm_apic_map *map,
 	}
 }
 
+/*
+ * 在以下使用kvm_recalculate_phys_map():
+ *   - arch/x86/kvm/lapic.c|438| <<kvm_recalculate_apic_map>> r = kvm_recalculate_phys_map(new, vcpu, &xapic_id_mismatch);
+ */
 static int kvm_recalculate_phys_map(struct kvm_apic_map *new,
 				    struct kvm_vcpu *vcpu,
 				    bool *xapic_id_mismatch)
@@ -297,6 +317,21 @@ static int kvm_recalculate_phys_map(struct kvm_apic_map *new,
 	return 0;
 }
 
+/*
+ * 1105 struct kvm_apic_map {
+ * 1106         struct rcu_head rcu;
+ * 1107         enum kvm_apic_logical_mode logical_mode;
+ * 1108         u32 max_apic_id;
+ * 1109         union { 
+ * 1110                 struct kvm_lapic *xapic_flat_map[8];
+ * 1111                 struct kvm_lapic *xapic_cluster_map[16][4];
+ * 1112         };      
+ * 1113         struct kvm_lapic *phys_map[];
+ * 1114 };
+ *
+ * 在以下调用kvm_recalculate_logical_map():
+ *   - arch/x86/kvm/lapic.c|450| <<kvm_recalculate_apic_map>> kvm_recalculate_logical_map(new, vcpu);
+ */
 static void kvm_recalculate_logical_map(struct kvm_apic_map *new,
 					struct kvm_vcpu *vcpu)
 {
@@ -347,6 +382,11 @@ static void kvm_recalculate_logical_map(struct kvm_apic_map *new,
 	if (apic_x2apic_mode(apic))
 		return;
 
+	/*
+	 * 在以下使用kvm_apic_map_get_logical_dest():
+	 *   - arch/x86/kvm/lapic.c|350| <<kvm_recalculate_logical_map>> if (WARN_ON_ONCE(!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))) {
+	 *   - arch/x86/kvm/lapic.c|1183| <<kvm_apic_map_get_dest_lapic>> if (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst, (u16 *)bitmap))
+	 */
 	if (WARN_ON_ONCE(!kvm_apic_map_get_logical_dest(new, ldr,
 							&cluster, &mask))) {
 		new->logical_mode = KVM_APIC_MODE_MAP_DISABLED;
@@ -375,6 +415,49 @@ enum {
 	DIRTY
 };
 
+/*
+ * 5.15上hot-add的例子.
+ *
+ * kvm_recalculate_apic_map
+ * kvm_set_apic_base
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * kvm_recalculate_apic_map
+ * kvm_set_apic_base
+ * __set_sregs_common.constprop.0
+ * kvm_arch_vcpu_ioctl
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * kvm_recalculate_apic_map
+ * kvm_set_apic_base
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_arch_vcpu_ioctl
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * 在以下调用kvm_recalculate_apic_map():
+ *   - arch/x86/kvm/lapic.c|2413| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+ *   - arch/x86/kvm/lapic.c|2650| <<kvm_apic_set_base>> kvm_recalculate_apic_map(vcpu->kvm);
+ *   - arch/x86/kvm/lapic.c|2815| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+ *   - arch/x86/kvm/lapic.c|3103| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+ *   - arch/x86/kvm/lapic.c|3109| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+ */
 static void kvm_recalculate_apic_map(struct kvm *kvm)
 {
 	struct kvm_apic_map *new, *old = NULL;
@@ -384,6 +467,19 @@ static void kvm_recalculate_apic_map(struct kvm *kvm)
 	bool xapic_id_mismatch;
 	int r;
 
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|388| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|404| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty, DIRTY, UPDATE_IN_PROGRESS) == CLEAN) {
+	 *   - arch/x86/kvm/lapic.c|480| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty, UPDATE_IN_PROGRESS, CLEAN);
+	 *   - arch/x86/kvm/lapic.c|503| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|516| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|522| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|528| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|539| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2603| <<__kvm_apic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3108| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	/* Read kvm->arch.apic_map_dirty before kvm->arch.apic_map.  */
 	if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
 		return;
@@ -435,6 +531,9 @@ static void kvm_recalculate_apic_map(struct kvm *kvm)
 		if (!kvm_apic_present(vcpu))
 			continue;
 
+		/*
+		 * 只在此处调用
+		 */
 		r = kvm_recalculate_phys_map(new, vcpu, &xapic_id_mismatch);
 		if (r) {
 			kvfree(new);
@@ -447,6 +546,9 @@ static void kvm_recalculate_apic_map(struct kvm *kvm)
 			goto out;
 		}
 
+		/*
+		 * 只在此处调用
+		 */
 		kvm_recalculate_logical_map(new, vcpu);
 	}
 out:
@@ -500,6 +602,19 @@ static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)
 		else
 			static_branch_inc(&apic_sw_disabled.key);
 
+		/*
+		 * 在以下使用kvm_arch->apic_map_dirty:
+		 *   - arch/x86/kvm/lapic.c|388| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+		 *   - arch/x86/kvm/lapic.c|404| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty, DIRTY, UPDATE_IN_PROGRESS) == CLEAN) {
+		 *   - arch/x86/kvm/lapic.c|480| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty, UPDATE_IN_PROGRESS, CLEAN);
+		 *   - arch/x86/kvm/lapic.c|503| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|516| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|522| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|528| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|539| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|2603| <<__kvm_apic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|3108| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 */
 		atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 	}
 
@@ -510,32 +625,93 @@ static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)
 	}
 }
 
+/*
+ * 在以下使用kvm_apic_set_x2apic_id():
+ *   - arch/x86/kvm/lapic.c|2702| <<__kvm_apic_set_base>> kvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);
+ */
 static inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)
 {
 	kvm_lapic_set_reg(apic, APIC_ID, id << 24);
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|388| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|404| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty, DIRTY, UPDATE_IN_PROGRESS) == CLEAN) {
+	 *   - arch/x86/kvm/lapic.c|480| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty, UPDATE_IN_PROGRESS, CLEAN);
+	 *   - arch/x86/kvm/lapic.c|503| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|516| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|522| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|528| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|539| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2603| <<__kvm_apic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3108| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 }
 
 static inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)
 {
 	kvm_lapic_set_reg(apic, APIC_LDR, id);
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|388| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|404| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty, DIRTY, UPDATE_IN_PROGRESS) == CLEAN) {
+	 *   - arch/x86/kvm/lapic.c|480| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty, UPDATE_IN_PROGRESS, CLEAN);
+	 *   - arch/x86/kvm/lapic.c|503| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|516| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|522| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|528| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|539| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2603| <<__kvm_apic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3108| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 }
 
 static inline void kvm_apic_set_dfr(struct kvm_lapic *apic, u32 val)
 {
 	kvm_lapic_set_reg(apic, APIC_DFR, val);
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|388| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|404| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty, DIRTY, UPDATE_IN_PROGRESS) == CLEAN) {
+	 *   - arch/x86/kvm/lapic.c|480| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty, UPDATE_IN_PROGRESS, CLEAN);
+	 *   - arch/x86/kvm/lapic.c|503| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|516| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|522| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|528| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|539| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2603| <<__kvm_apic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3108| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 }
 
 static inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u32 id)
 {
+	/*
+	 * 在以下调用kvm_apic_calc_x2apic_ldr:
+	 *   - arch/x86/kvm/lapic.c|533| <<kvm_apic_set_x2apic_id>> u32 ldr = kvm_apic_calc_x2apic_ldr(id);
+	 *   - arch/x86/kvm/lapic.c|3060| <<kvm_apic_state_fixup>> *ldr = kvm_apic_calc_x2apic_ldr(x2apic_id);
+	 */
 	u32 ldr = kvm_apic_calc_x2apic_ldr(id);
 
 	WARN_ON_ONCE(id != apic->vcpu->vcpu_id);
 
 	kvm_lapic_set_reg(apic, APIC_ID, id);
 	kvm_lapic_set_reg(apic, APIC_LDR, ldr);
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|388| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|404| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty, DIRTY, UPDATE_IN_PROGRESS) == CLEAN) {
+	 *   - arch/x86/kvm/lapic.c|480| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty, UPDATE_IN_PROGRESS, CLEAN);
+	 *   - arch/x86/kvm/lapic.c|503| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|516| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|522| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|528| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|539| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2603| <<__kvm_apic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3108| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 }
 
@@ -655,6 +831,11 @@ static u8 count_vectors(void *bitmap)
 	return count;
 }
 
+/*
+ * 在以下使用__kvm_apic_update_irr():
+ *   - arch/x86/kvm/lapic.c|785| <<kvm_apic_update_irr>> bool irr_updated = __kvm_apic_update_irr(pir, apic->regs, max_irr);
+ *   - arch/x86/kvm/vmx/nested.c|3941| <<vmx_complete_nested_posted_interrupt>> __kvm_apic_update_irr(vmx->nested.pi_desc->pir, vapic_page, &max_irr);
+ */
 bool __kvm_apic_update_irr(u32 *pir, void *regs, int *max_irr)
 {
 	u32 i, vec;
@@ -832,11 +1013,28 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 			     int vector, int level, int trig_mode,
 			     struct dest_map *dest_map);
 
+/*
+ * 在以下使用kvm_apic_set_irq():
+ *   - arch/x86/kvm/hyperv.c|841| <<stimer_notify_direct>> return !kvm_apic_set_irq(vcpu, &irq, NULL);
+ *   - arch/x86/kvm/hyperv.c|2213| <<kvm_hv_send_ipi_to_many>> kvm_apic_set_irq(vcpu, &irq, NULL);
+ *   - arch/x86/kvm/irq_comm.c|77| <<kvm_irq_delivery_to_apic>> r += kvm_apic_set_irq(vcpu, irq, dest_map);
+ *   - arch/x86/kvm/irq_comm.c|99| <<kvm_irq_delivery_to_apic>> r = kvm_apic_set_irq(lowest, irq, dest_map);
+ *   - arch/x86/kvm/lapic.c|1032| <<__pv_send_ipi>> count += kvm_apic_set_irq(vcpu, irq, NULL);
+ *   - arch/x86/kvm/lapic.c|1416| <<kvm_irq_delivery_to_apic_fast>> *r = kvm_apic_set_irq(src->vcpu, irq, dest_map);
+ *   - arch/x86/kvm/lapic.c|1429| <<kvm_irq_delivery_to_apic_fast>> *r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);
+ *   - arch/x86/kvm/x86.c|13488| <<kvm_arch_async_page_present>> kvm_apic_set_irq(vcpu, &irq, NULL);
+ */
 int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,
 		     struct dest_map *dest_map)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
+	/*
+	 * 在以下使用__apic_accept_irq():
+	 *   - arch/x86/kvm/lapic.c|1015| <<kvm_apic_set_irq>> return __apic_accept_irq(apic, irq->delivery_mode,
+	 *          irq->vector, irq->level, irq->trig_mode, dest_map);
+	 *   - arch/x86/kvm/lapic.c|3043| <<kvm_apic_local_deliver>> r = __apic_accept_irq(apic, mode, vector, 1, trig_mode, NULL);
+	 */
 	return __apic_accept_irq(apic, irq->delivery_mode, irq->vector,
 			irq->level, irq->trig_mode, dest_map);
 }
@@ -1180,6 +1378,11 @@ static inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,
 	}
 
 	*bitmap = 0;
+	/*
+	 * 在以下使用kvm_apic_map_get_logical_dest():
+	 *   - arch/x86/kvm/lapic.c|350| <<kvm_recalculate_logical_map>> if (WARN_ON_ONCE(!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))) {
+	 *   - arch/x86/kvm/lapic.c|1183| <<kvm_apic_map_get_dest_lapic>> if (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst, (u16 *)bitmap))
+	 */
 	if (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,
 				(u16 *)bitmap))
 		return false;
@@ -1300,6 +1503,12 @@ bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,
  * Add a pending IRQ into lapic.
  * Return 1 if successfully added and 0 if discarded.
  */
+/*
+ * 在以下使用__apic_accept_irq():
+ *   - arch/x86/kvm/lapic.c|1015| <<kvm_apic_set_irq>> return __apic_accept_irq(apic, irq->delivery_mode,
+ *          irq->vector, irq->level, irq->trig_mode, dest_map);
+ *   - arch/x86/kvm/lapic.c|3043| <<kvm_apic_local_deliver>> r = __apic_accept_irq(apic, mode, vector, 1, trig_mode, NULL);
+ */
 static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 			     int vector, int level, int trig_mode,
 			     struct dest_map *dest_map)
@@ -2600,6 +2809,19 @@ static void __kvm_apic_set_base(struct kvm_vcpu *vcpu, u64 value)
 			kvm_make_request(KVM_REQ_APF_READY, vcpu);
 		} else {
 			static_branch_inc(&apic_hw_disabled.key);
+			/*
+			 * 在以下使用kvm_arch->apic_map_dirty:
+			 *   - arch/x86/kvm/lapic.c|388| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+			 *   - arch/x86/kvm/lapic.c|404| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty, DIRTY, UPDATE_IN_PROGRESS) == CLEAN) {
+			 *   - arch/x86/kvm/lapic.c|480| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty, UPDATE_IN_PROGRESS, CLEAN);
+			 *   - arch/x86/kvm/lapic.c|503| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|516| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|522| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|528| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|539| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|2603| <<__kvm_apic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|3108| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 */
 			atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 		}
 	}
@@ -2836,6 +3058,13 @@ int apic_has_pending_timer(struct kvm_vcpu *vcpu)
 	return 0;
 }
 
+/*
+ * 在以下调用kvm_apic_local_deliver():
+ *   - arch/x86/kvm/lapic.c|2074| <<kvm_apic_inject_pending_timer_irqs>> kvm_apic_local_deliver(apic, APIC_LVTT);
+ *   - arch/x86/kvm/lapic.c|3057| <<kvm_apic_nmi_wd_deliver>> kvm_apic_local_deliver(apic, APIC_LVT0);
+ *   - arch/x86/kvm/pmu.c|611| <<kvm_pmu_deliver_pmi>> kvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTPC);
+ *   - arch/x86/kvm/x86.c|5273| <<kvm_vcpu_x86_set_ucna>> kvm_apic_local_deliver(vcpu->arch.apic, APIC_LVTCMCI);
+ */
 int kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)
 {
 	u32 reg = kvm_lapic_get_reg(apic, lvt_type);
@@ -2916,6 +3145,12 @@ int kvm_create_lapic(struct kvm_vcpu *vcpu)
 
 	hrtimer_setup(&apic->lapic_timer.timer, apic_timer_fn, CLOCK_MONOTONIC,
 		      HRTIMER_MODE_ABS_HARD);
+	/*
+	 * 在以下使用lapic_timer_advance:
+	 *   - arch/x86/kvm/lapic.c|70| <<global>> static bool lapic_timer_advance __read_mostly = true;
+	 *   - arch/x86/kvm/lapic.c|71| <<global>> module_param(lapic_timer_advance, bool, 0444);
+	 *   - arch/x86/kvm/lapic.c|3142| <<kvm_create_lapic>> if (lapic_timer_advance)
+	 */
 	if (lapic_timer_advance)
 		apic->lapic_timer.timer_advance_ns = LAPIC_TIMER_ADVANCE_NS_INIT;
 
@@ -2975,6 +3210,10 @@ int kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)
 	return 0;
 }
 
+/*
+ * 在以下使用kvm_inject_apic_timer_irqs():
+ *   - arch/x86/kvm/irq.c|155| <<kvm_inject_pending_timer_irqs>> kvm_inject_apic_timer_irqs(vcpu);
+ */
 void kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
@@ -3056,6 +3295,11 @@ static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,
 		 * register, but needs to be split to ICR+ICR2 in userspace for
 		 * backwards compatibility.
 		 */
+		/*
+		 * 在以下调用kvm_apic_calc_x2apic_ldr:
+		 *   - arch/x86/kvm/lapic.c|533| <<kvm_apic_set_x2apic_id>> u32 ldr = kvm_apic_calc_x2apic_ldr(id);
+		 *   - arch/x86/kvm/lapic.c|3060| <<kvm_apic_state_fixup>> *ldr = kvm_apic_calc_x2apic_ldr(x2apic_id);
+		 */
 		if (set)
 			*ldr = kvm_apic_calc_x2apic_ldr(x2apic_id);
 
@@ -3105,6 +3349,19 @@ int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 	}
 	memcpy(vcpu->arch.apic->regs, s->regs, sizeof(*s));
 
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|388| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|404| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty, DIRTY, UPDATE_IN_PROGRESS) == CLEAN) {
+	 *   - arch/x86/kvm/lapic.c|480| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty, UPDATE_IN_PROGRESS, CLEAN);
+	 *   - arch/x86/kvm/lapic.c|503| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|516| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|522| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|528| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|539| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2603| <<__kvm_apic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3108| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 	kvm_recalculate_apic_map(vcpu->kvm);
 	kvm_apic_set_version(vcpu);
@@ -3131,6 +3388,10 @@ int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 	return 0;
 }
 
+/*
+ * 在以下使用__kvm_migrate_apic_timer():
+ *   - arch/x86/kvm/irq.c|162| <<__kvm_migrate_timers>> __kvm_migrate_apic_timer(vcpu);
+ */
 void __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)
 {
 	struct hrtimer *timer;
diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h
index 1a8553ebd..8a9e8fec5 100644
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@ -187,6 +187,36 @@ static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)
 
 extern struct static_key_false_deferred apic_hw_disabled;
 
+/*
+ * apic_hw_disabled代表HW enabled APIC in APIC_BASE MSR
+ * 比如过去是return (apic)->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;
+ *
+ * commit c5cc421ba3219b90f11d151bc55f1608c12830fa
+ * Author: Gleb Natapov <gleb@redhat.com>
+ * Date:   Sun Aug 5 15:58:30 2012 +0300
+ *
+ * KVM: use jump label to optimize checking for HW enabled APIC in APIC_BASE MSR
+ *
+ * Usually all APICs are HW enabled so the check can be optimized out.
+ *
+ * Signed-off-by: Gleb Natapov <gleb@redhat.com>
+ * Signed-off-by: Avi Kivity <avi@redhat.com>
+ *
+ *
+ * apic_sw_disabled代表SW enabled apic in spurious interrupt register,
+ * 比如过去是return apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_APIC_ENABLED;
+ *
+ * commit f8c1ea103947038b7197bdd4c8451886a58af0c0
+ * Author: Gleb Natapov <gleb@redhat.com>
+ * Date:   Sun Aug 5 15:58:31 2012 +0300
+ * 
+ * KVM: use jump label to optimize checking for SW enabled apic in spurious interrupt register
+ *
+ * Usually all APICs are SW enabled so the check can be optimized out.
+ *
+ * Signed-off-by: Gleb Natapov <gleb@redhat.com>
+ * Signed-off-by: Avi Kivity <avi@redhat.com>
+ */
 static inline bool kvm_apic_hw_enabled(struct kvm_lapic *apic)
 {
 	if (static_branch_unlikely(&apic_hw_disabled.key))
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index be7bb6d20..9aa69f0d2 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -3257,6 +3257,13 @@ int kvm_guest_time_update(struct kvm_vcpu *v)
 	hv_clock.tsc_to_system_mul = vcpu->pvclock_tsc_mul;
 	hv_clock.tsc_timestamp = tsc_timestamp;
 	hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;
+	/*
+	 * 在以下使用kvm_vcpu_arch->last_guest_tsc:
+	 *   - arch/x86/kvm/x86.c|2660| <<__kvm_synchronize_tsc>> vcpu->arch.last_guest_tsc = tsc;
+	 *   - arch/x86/kvm/x86.c|3260| <<kvm_guest_time_update>> vcpu->last_guest_tsc = tsc_timestamp;
+	 *   - arch/x86/kvm/x86.c|5018| <<kvm_arch_vcpu_load>> u64 offset = kvm_compute_l1_tsc_offset(vcpu, vcpu->arch.last_guest_tsc);
+	 *   - arch/x86/kvm/x86.c|11049| <<vcpu_enter_guest>> vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());
+	 */
 	vcpu->last_guest_tsc = tsc_timestamp;
 
 	/* If the host uses TSC clocksource, then it is stable */
-- 
2.39.5 (Apple Git-154)

