From b3752d96f0fa56d949d3259ecb981f0992997a08 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 29 May 2019 05:54:22 +0800
Subject: [PATCH 1/1] block comment for block and drivers for linux-5.2-rc2

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 block/blk-mq.c             | 87 ++++++++++++++++++++++++++++++++++++++++++++++
 drivers/scsi/sd.c          |  9 +++++
 include/linux/cpuhotplug.h | 19 ++++++++++
 kernel/cpu.c               | 13 +++++++
 4 files changed, 128 insertions(+)

diff --git a/block/blk-mq.c b/block/blk-mq.c
index 32b8ad3..c1fba75 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -42,6 +42,11 @@
 static void blk_mq_poll_stats_start(struct request_queue *q);
 static void blk_mq_poll_stats_fn(struct blk_stat_callback *cb);
 
+/*
+ * used by:
+ *   - block/blk-mq.c|2862| <<blk_mq_init_allocated_queue>> blk_mq_poll_stats_bkt,
+ *   - block/blk-mq.c|3388| <<blk_mq_poll_nsecs>> bucket = blk_mq_poll_stats_bkt(rq);
+ */
 static int blk_mq_poll_stats_bkt(const struct request *rq)
 {
 	int ddir, bytes, bucket;
@@ -3330,6 +3335,10 @@ static bool blk_poll_stats_enable(struct request_queue *q)
 	return false;
 }
 
+/*
+ * called by only:
+ *   - block/blk-mq.c|541| <<__blk_mq_end_request>> blk_mq_poll_stats_start(rq->q);
+ */
 static void blk_mq_poll_stats_start(struct request_queue *q)
 {
 	/*
@@ -3343,6 +3352,10 @@ static void blk_mq_poll_stats_start(struct request_queue *q)
 	blk_stat_activate_msecs(q->poll_cb, 100);
 }
 
+/*
+ * used by only:
+ *   - block/blk-mq.c|2861| <<blk_mq_init_allocated_queue>> q->poll_cb = blk_stat_alloc_callback(blk_mq_poll_stats_fn,
+ */
 static void blk_mq_poll_stats_fn(struct blk_stat_callback *cb)
 {
 	struct request_queue *q = cb->data;
@@ -3539,8 +3552,82 @@ unsigned int blk_mq_rq_cpu(struct request *rq)
 }
 EXPORT_SYMBOL(blk_mq_rq_cpu);
 
+/*
+ * 假设为cpuhp_setup_state_multi()的startup添加了blk_mq_hctx_notify_prepare()
+ *
+ * # echo 1 > /sys/devices/system/cpu/cpu2/online
+ *
+ * [  122.079907] blk_mq_hctx_notify_dead nr_hw_queues=1, cpu=2, queue_num=0
+ * [  122.080691] blk_mq_hctx_notify_dead nr_hw_queues=1, cpu=2, queue_num=0
+ * [  122.081429] blk_mq_hctx_notify_dead nr_hw_queues=4, cpu=2, queue_num=3 -> nvme queue 3
+ * [  122.082158] blk_mq_hctx_notify_dead nr_hw_queues=4, cpu=2, queue_num=2 -> nvme queue 2
+ * [  122.082919] blk_mq_hctx_notify_dead nr_hw_queues=4, cpu=2, queue_num=1 -> nvme queue 1
+ * [  122.083680] blk_mq_hctx_notify_dead nr_hw_queues=4, cpu=2, queue_num=0 -> nvme queue 0
+ * [  122.084443] blk_mq_hctx_notify_dead nr_hw_queues=1, cpu=2, queue_num=0
+ * [  122.085167] blk_mq_hctx_notify_dead nr_hw_queues=1, cpu=2, queue_num=0
+ * [  122.085925] blk_mq_hctx_notify_dead nr_hw_queues=1, cpu=2, queue_num=0
+ * [  122.086694] blk_mq_hctx_notify_dead nr_hw_queues=1, cpu=2, queue_num=0
+ * [  122.087458] blk_mq_hctx_notify_dead nr_hw_queues=1, cpu=2, queue_num=0
+ * [  122.088181] blk_mq_hctx_notify_dead nr_hw_queues=1, cpu=2, queue_num=0
+ * [  122.088938] blk_mq_hctx_notify_dead nr_hw_queues=1, cpu=2, queue_num=0
+ * [  122.089653] blk_mq_hctx_notify_dead nr_hw_queues=1, cpu=2, queue_num=0
+ * [  122.090400] blk_mq_hctx_notify_dead nr_hw_queues=1, cpu=2, queue_num=0
+ *
+ * # echo 0 > /sys/devices/system/cpu/cpu2/online
+ *
+ * [  250.582328] blk_mq_hctx_notify_prepare nr_hw_queues=1, cpu=2, queue_num=0
+ * [  250.583122] blk_mq_hctx_notify_prepare nr_hw_queues=1, cpu=2, queue_num=0
+ * [  250.583943] blk_mq_hctx_notify_prepare nr_hw_queues=4, cpu=2, queue_num=3 -> nvme queue 3
+ * [  250.584760] blk_mq_hctx_notify_prepare nr_hw_queues=4, cpu=2, queue_num=2 -> nvme queue 2
+ * [  250.585547] blk_mq_hctx_notify_prepare nr_hw_queues=4, cpu=2, queue_num=1 -> nvme queue 1
+ * [  250.586364] blk_mq_hctx_notify_prepare nr_hw_queues=4, cpu=2, queue_num=0 -> nvme queue 0
+ * [  250.587114] blk_mq_hctx_notify_prepare nr_hw_queues=1, cpu=2, queue_num=0
+ * [  250.588158] blk_mq_hctx_notify_prepare nr_hw_queues=1, cpu=2, queue_num=0
+ * [  250.589193] blk_mq_hctx_notify_prepare nr_hw_queues=1, cpu=2, queue_num=0
+ * [  250.590144] blk_mq_hctx_notify_prepare nr_hw_queues=1, cpu=2, queue_num=0
+ * [  250.590757] blk_mq_hctx_notify_prepare nr_hw_queues=1, cpu=2, queue_num=0
+ * [  250.591372] blk_mq_hctx_notify_prepare nr_hw_queues=1, cpu=2, queue_num=0
+ * [  250.591963] blk_mq_hctx_notify_prepare nr_hw_queues=1, cpu=2, queue_num=0
+ * [  250.592574] blk_mq_hctx_notify_prepare nr_hw_queues=1, cpu=2, queue_num=0
+ * [  250.593163] blk_mq_hctx_notify_prepare nr_hw_queues=1, cpu=2, queue_num=0
+ *
+ * 上面目前是把cpu和每个hctx queue都过一遍
+ *
+ *
+ * [0] blk_mq_hctx_notify_dead
+ * [0] cpuhp_invoke_callback
+ * [0] _cpu_down
+ * [0] do_cpu_down
+ * [0] device_offline
+ * [0] online_store
+ * [0] kernfs_fop_write
+ * [0] vfs_write
+ * [0] ksys_write
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ *
+ * [0] blk_mq_hctx_notify_prepare
+ * [0] cpuhp_invoke_callback
+ * [0] _cpu_up
+ * [0] do_cpu_up
+ * [0] cpu_subsys_online
+ * [0] device_online
+ * [0] online_store
+ * [0] kernfs_fop_write
+ * [0] vfs_write
+ * [0] ksys_write
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ */
+
 static int __init blk_mq_init(void)
 {
+	/*
+	 * CPUHP_BLK_MQ_DEAD在以下使用:
+	 *   - block/blk-mq.c|2254| <<blk_mq_remove_cpuhp>> cpuhp_state_remove_instance_nocalls(CPUHP_BLK_MQ_DEAD,
+	 *   - block/blk-mq.c|2313| <<blk_mq_init_hctx>> cpuhp_state_add_instance_nocalls(CPUHP_BLK_MQ_DEAD, &hctx->cpuhp_dead);
+	 *   - block/blk-mq.c|3544| <<blk_mq_init>> cpuhp_setup_state_multi(CPUHP_BLK_MQ_DEAD, "block/mq:dead", NULL,
+	 */
 	cpuhp_setup_state_multi(CPUHP_BLK_MQ_DEAD, "block/mq:dead", NULL,
 				blk_mq_hctx_notify_dead);
 	return 0;
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index a3406bd..449c807 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -563,6 +563,12 @@ static const struct dev_pm_ops sd_pm_ops = {
 	.runtime_resume		= sd_resume,
 };
 
+/*
+ * used by:
+ *   - drivers/scsi/sd.c|3381| <<sd_probe>> sdkp->driver = &sd_template;
+ *   - drivers/scsi/sd.c|3677| <<init_sd>> err = scsi_register_driver(&sd_template.gendrv);
+ *   - drivers/scsi/sd.c|3711| <<exit_sd>> scsi_unregister_driver(&sd_template.gendrv);
+ */
 static struct scsi_driver sd_template = {
 	.gendrv = {
 		.name		= "sd",
@@ -1941,6 +1947,9 @@ static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)
  *
  *	Note: potentially run from within an ISR. Must not block.
  **/
+/*
+ * struct scsi_driver sd_template.done = sd_done()
+ */
 static int sd_done(struct scsi_cmnd *SCpnt)
 {
 	int result = SCpnt->result;
diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h
index 6a38159..c710c9f 100644
--- a/include/linux/cpuhotplug.h
+++ b/include/linux/cpuhotplug.h
@@ -47,6 +47,12 @@ enum cpuhp_state {
 	CPUHP_BLOCK_SOFTIRQ_DEAD,
 	CPUHP_ACPI_CPUDRV_DEAD,
 	CPUHP_S390_PFAULT_DEAD,
+	/*
+	 * used by:
+	 *   - block/blk-mq.c|2254| <<blk_mq_remove_cpuhp>> cpuhp_state_remove_instance_nocalls(CPUHP_BLK_MQ_DEAD,
+	 *   - block/blk-mq.c|2313| <<blk_mq_init_hctx>> cpuhp_state_add_instance_nocalls(CPUHP_BLK_MQ_DEAD, &hctx->cpuhp_dead);
+	 *   - block/blk-mq.c|3544| <<blk_mq_init>> cpuhp_setup_state_multi(CPUHP_BLK_MQ_DEAD, "block/mq:dead", NULL,
+	 */
 	CPUHP_BLK_MQ_DEAD,
 	CPUHP_FS_BUFF_DEAD,
 	CPUHP_PRINTK_DEAD,
@@ -302,6 +308,19 @@ static inline int cpuhp_state_add_instance(enum cpuhp_state state,
  * Installs the instance for the @state The @state must have been earlier
  * marked as multi-instance by @cpuhp_setup_state_multi.
  */
+/*
+ * called by:
+ *   - arch/arm/mach-imx/mmdc.c|518| <<imx_mmdc_perf_init>> cpuhp_state_add_instance_nocalls(cpuhp_mmdc_state, &pmu_mmdc->node);
+ *   - block/blk-mq.c|2313| <<blk_mq_init_hctx>> cpuhp_state_add_instance_nocalls(CPUHP_BLK_MQ_DEAD, &hctx->cpuhp_dead);
+ *   - drivers/net/ethernet/marvell/mvneta.c|3841| <<mvneta_open>> ret = cpuhp_state_add_instance_nocalls(online_hpstate,
+ *   - drivers/net/ethernet/marvell/mvneta.c|3846| <<mvneta_open>> ret = cpuhp_state_add_instance_nocalls(CPUHP_NET_MVNETA_DEAD,
+ *   - drivers/net/ethernet/marvell/mvneta.c|4828| <<mvneta_resume>> cpuhp_state_add_instance_nocalls(online_hpstate,
+ *   - drivers/net/ethernet/marvell/mvneta.c|4830| <<mvneta_resume>> cpuhp_state_add_instance_nocalls(CPUHP_NET_MVNETA_DEAD,
+ *   - drivers/net/virtio_net.c|2000| <<virtnet_cpu_notif_add>> ret = cpuhp_state_add_instance_nocalls(virtionet_online, &vi->node);
+ *   - drivers/net/virtio_net.c|2003| <<virtnet_cpu_notif_add>> ret = cpuhp_state_add_instance_nocalls(CPUHP_VIRT_NET_DEAD,
+ *   - drivers/perf/arm-ccn.c|1313| <<arm_ccn_pmu_init>> cpuhp_state_add_instance_nocalls(CPUHP_AP_PERF_ARM_CCN_ONLINE,
+ *   - drivers/perf/arm_smmuv3_pmu.c|786| <<smmu_pmu_probe>> err = cpuhp_state_add_instance_nocalls(cpuhp_state_num,
+ */
 static inline int cpuhp_state_add_instance_nocalls(enum cpuhp_state state,
 						   struct hlist_node *node)
 {
diff --git a/kernel/cpu.c b/kernel/cpu.c
index f2ef104..8d31e98 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -126,6 +126,19 @@ struct cpuhp_step {
 static DEFINE_MUTEX(cpuhp_state_mutex);
 static struct cpuhp_step cpuhp_hp_states[];
 
+/*
+ * called by:
+ *   - kernel/cpu.c|149| <<cpuhp_invoke_callback>> struct cpuhp_step *step = cpuhp_get_step(state);
+ *   - kernel/cpu.c|1578| <<cpuhp_store_callbacks>> sp = cpuhp_get_step(state);
+ *   - kernel/cpu.c|1592| <<cpuhp_get_teardown_cb>> return cpuhp_get_step(state)->teardown.single;
+ *   - kernel/cpu.c|1602| <<cpuhp_issue_call>> struct cpuhp_step *sp = cpuhp_get_step(state);
+ *   - kernel/cpu.c|1662| <<__cpuhp_state_add_instance_cpuslocked>> sp = cpuhp_get_step(state);
+ *   - kernel/cpu.c|1804| <<__cpuhp_state_remove_instance>> struct cpuhp_step *sp = cpuhp_get_step(state);
+ *   - kernel/cpu.c|1851| <<__cpuhp_remove_state_cpuslocked>> struct cpuhp_step *sp = cpuhp_get_step(state);
+ *   - kernel/cpu.c|1930| <<write_cpuhp_target>> sp = cpuhp_get_step(target);
+ *   - kernel/cpu.c|1977| <<write_cpuhp_fail>> sp = cpuhp_get_step(fail);
+ *   - kernel/cpu.c|2020| <<show_cpuhp_states>> struct cpuhp_step *sp = cpuhp_get_step(i);
+ */
 static struct cpuhp_step *cpuhp_get_step(enum cpuhp_state state)
 {
 	return cpuhp_hp_states + state;
-- 
2.7.4

