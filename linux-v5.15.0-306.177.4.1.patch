From 3efe4425e502af90fcf8f55f4a54da4b821f273c Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Fri, 27 Jun 2025 10:17:30 -0700
Subject: [PATCH 1/1] linux v5.15.0-306.177.4.1

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/include/asm/apicdef.h     |   23 +
 arch/x86/include/asm/kvm_host.h    |  143 ++++
 arch/x86/kernel/apic/io_apic.c     |    5 +
 arch/x86/kvm/ioapic.c              |  298 +++++++
 arch/x86/kvm/ioapic.h              |   14 +
 arch/x86/kvm/irq.c                 |   31 +
 arch/x86/kvm/irq_comm.c            |  118 +++
 arch/x86/kvm/lapic.c               | 1161 ++++++++++++++++++++++++++++
 arch/x86/kvm/lapic.h               |  221 ++++++
 arch/x86/kvm/svm/avic.c            |   19 +
 arch/x86/kvm/vmx/vmx.c             |  170 ++++
 arch/x86/kvm/x86.c                 |  669 ++++++++++++++++
 arch/x86/kvm/x86.h                 |   27 +
 drivers/acpi/acpica/dbexec.c       |   40 +
 drivers/acpi/acpica/dbxface.c      |   20 +
 drivers/acpi/acpica/dswexec.c      |   50 ++
 drivers/acpi/acpica/evgpe.c        |  330 ++++++++
 drivers/acpi/acpica/evmisc.c       |  215 ++++++
 drivers/acpi/acpica/evsci.c        |   58 ++
 drivers/acpi/acpica/exoparg2.c     |   61 ++
 drivers/acpi/acpica/nseval.c       |  138 ++++
 drivers/acpi/acpica/nsnames.c      |    3 +
 drivers/acpi/acpica/nsxfeval.c     |   10 +
 drivers/acpi/acpica/nsxfname.c     |    3 +
 drivers/acpi/acpica/psloop.c       |   41 +
 drivers/acpi/acpica/psparse.c      |   40 +
 drivers/acpi/acpica/psxface.c      |   44 ++
 drivers/acpi/acpica/utstate.c      |   12 +
 drivers/acpi/bus.c                 |   44 ++
 drivers/acpi/osl.c                 |  122 +++
 drivers/acpi/scan.c                |  203 +++++
 drivers/pci/hotplug/acpiphp_glue.c |   94 +++
 drivers/pci/pci-acpi.c             |    4 +
 virt/kvm/eventfd.c                 |   10 +
 virt/kvm/irqchip.c                 |   41 +
 virt/kvm/kvm_main.c                |    8 +
 36 files changed, 4490 insertions(+)

diff --git a/arch/x86/include/asm/apicdef.h b/arch/x86/include/asm/apicdef.h
index 863c2cad5872..7f4752325b2b 100644
--- a/arch/x86/include/asm/apicdef.h
+++ b/arch/x86/include/asm/apicdef.h
@@ -18,6 +18,29 @@
  */
 #define IO_APIC_SLOT_SIZE		1024
 
+/*
+ * 在以下使用APIC_ID:
+ *   - arch/x86/kvm/svm/svm.c|119| <<global>> { .index = X2APIC_MSR(APIC_ID), .always = false },
+ *   - arch/x86/include/asm/apic.h|204| <<native_apic_msr_write>> if (reg == APIC_DFR || reg == APIC_ID || reg == APIC_LDR ||
+ *   - arch/x86/include/asm/apic.h|487| <<read_apic_id>> unsigned int reg = apic_read(APIC_ID);
+ *   - arch/x86/kernel/apic/apic.c|1797| <<setup_nox2apic>> int apicid = native_apic_msr_read(APIC_ID);
+ *   - arch/x86/kernel/apic/apic.c|2586| <<apic_bsp_up_setup>> apic_write(APIC_ID, apic->set_apic_id(boot_cpu_physical_apicid));
+ *   - arch/x86/kernel/apic/apic.c|2668| <<lapic_suspend>> apic_pm_state.apic_id = apic_read(APIC_ID);
+ *   - arch/x86/kernel/apic/apic.c|2745| <<lapic_resume>> apic_write(APIC_ID, apic_pm_state.apic_id);
+ *   - arch/x86/kernel/apic/apic_flat_64.c|91| <<read_xapic_id>> return flat_get_apic_id(apic_read(APIC_ID));
+ *   - arch/x86/kernel/apic/vector.c|1157| <<print_local_APIC>> v = apic_read(APIC_ID);
+ *   - arch/x86/kernel/apic/x2apic_uv_x.c|811| <<uv_read_apic_id>> return x2apic_get_apic_id(apic_read(APIC_ID));
+ *   - arch/x86/kernel/smpboot.c|689| <<__inquire_remote_apic>> unsigned i, regs[] = { APIC_ID >> 4, APIC_LVR >> 4, APIC_SPIV >> 4 };
+ *   - arch/x86/kvm/lapic.c|381| <<kvm_apic_set_xapic_id>> kvm_lapic_set_reg(apic, APIC_ID, id << 24);
+ *   - arch/x86/kvm/lapic.c|408| <<kvm_apic_set_x2apic_id>> kvm_lapic_set_reg(apic, APIC_ID, id);
+ *   - arch/x86/kvm/lapic.c|1762| <<kvm_lapic_reg_read>> APIC_REG_MASK(APIC_ID) |
+ *   - arch/x86/kvm/lapic.c|2393| <<kvm_lapic_reg_write>> case APIC_ID:
+ *   - arch/x86/kvm/lapic.c|3094| <<kvm_apic_state_fixup>> u32 *id = (u32 *)(s->regs + APIC_ID);
+ *   - arch/x86/kvm/lapic.h|305| <<kvm_xapic_id>> return kvm_lapic_get_reg(apic, APIC_ID) >> 24;
+ *   - arch/x86/kvm/svm/avic.c|675| <<is_avic_unaccelerated_access_trap>> case APIC_ID:
+ *   - arch/x86/xen/apic.c|63| <<xen_apic_read>> if (reg != APIC_ID)
+ *   - tools/testing/selftests/kvm/x86_64/xapic_ipi_test.c|100| <<halter_guest_code>> data->halter_apic_id = GET_APIC_ID_FIELD(xapic_read_reg(APIC_ID));
+ */
 #define	APIC_ID		0x20
 
 #define	APIC_LVR	0x30
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 8a710af8003c..6fa10ba2a07d 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -632,10 +632,67 @@ struct kvm_vcpu_arch {
 	u32 pkru;
 	u32 hflags;
 	u64 efer;
+	/*
+	 * 在以下设置kvm_vcpu_arch->apic_base (看似修改的地方):
+	 *   - arch/x86/kvm/lapic.c|2926| <<kvm_lapic_set_base>> vcpu->arch.apic_base = value;
+	 *   - arch/x86/kvm/lapic.c|3256| <<kvm_create_lapic>> vcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;
+	 * 在以下使用kvm_vcpu_arch->apic_base:
+	 *   - arch/x86/kvm/cpuid.c|222| <<__kvm_update_cpuid_runtime>> cpuid_entry_change(best, X86_FEATURE_APIC, vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE);
+	 *   - arch/x86/kvm/lapic.c|2862| <<kvm_free_lapic>> if (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))
+	 *   - arch/x86/kvm/lapic.c|2923| <<kvm_lapic_set_base>> u64 old_value = vcpu->arch.apic_base;
+	 *   - arch/x86/kvm/lapic.c|2974| <<kvm_lapic_set_base>> apic->base_address = apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_BASE;
+	 *   - arch/x86/kvm/lapic.c|3454| <<kvm_apic_set_state>> kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
+	 *   - arch/x86/kvm/lapic.h|231| <<kvm_apic_hw_enabled>> return apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;
+	 *   - arch/x86/kvm/lapic.h|256| <<apic_x2apic_mode>> return apic->vcpu->arch.apic_base & X2APIC_ENABLE;
+	 *   - arch/x86/kvm/lapic.h|300| <<kvm_apic_mode>> return apic_base & (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);
+	 *   - arch/x86/kvm/vmx/nested.c|878| <<nested_vmx_msr_check_common>> if (CC(vcpu->arch.apic_base & X2APIC_ENABLE && e->index >> 8 == 0x8))
+	 *   - arch/x86/kvm/x86.c|466| <<kvm_get_apic_base>> return vcpu->arch.apic_base;
+	 *   - arch/x86/kvm/x86.c|12215| <<kvm_vcpu_is_bsp>> return (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;
+	 */
 	u64 apic_base;
 	struct kvm_lapic *apic;    /* kernel irqchip context */
+	/*
+	 * 在以下设置kvm_vcpu_arch->apicv_active:
+	 *   - arch/x86/kvm/x86.c|9800| <<kvm_vcpu_update_apicv>> vcpu->arch.apicv_active = activate;
+	 *   - arch/x86/kvm/x86.c|11393| <<kvm_arch_vcpu_create>> vcpu->arch.apicv_active = true;
+	 * 在以下使用kvm_vcpu_arch->apicv_active:
+	 *   - arch/x86/kvm/lapic.c|553| <<kvm_apic_update_irr>> if (unlikely(!vcpu->arch.apicv_active && irr_updated))
+	 *   - arch/x86/kvm/lapic.c|602| <<apic_clear_irr>> if (unlikely(vcpu->arch.apicv_active)) {
+	 *   - arch/x86/kvm/lapic.c|654| <<apic_set_isr>> if (unlikely(vcpu->arch.apicv_active))
+	 *   - arch/x86/kvm/lapic.c|714| <<apic_clear_isr>> if (unlikely(vcpu->arch.apicv_active))
+	 *   - arch/x86/kvm/lapic.c|1827| <<lapic_timer_int_injected>> if (vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/lapic.c|1944| <<apic_timer_expired>> if (!from_timer_fn && vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|2613| <<kvm_apic_update_apicv>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|2703| <<kvm_lapic_reset>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|3003| <<kvm_apic_set_state>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.h|241| <<kvm_vcpu_apicv_active>> return vcpu->arch.apic && vcpu->arch.apicv_active;
+	 *   - arch/x86/kvm/svm/svm.c|3661| <<svm_complete_interrupt_delivery>> if (!READ_ONCE(vcpu->arch.apicv_active)) {
+	 *   - arch/x86/kvm/vmx/vmx.c|4114| <<vmx_deliver_posted_interrupt>> if (!vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|9241| <<update_cr8_intercept>> if (vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|9797| <<kvm_vcpu_update_apicv>> if (vcpu->arch.apicv_active == activate)
+	 *   - arch/x86/kvm/x86.c|9810| <<kvm_vcpu_update_apicv>> if (!vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|12441| <<kvm_arch_dy_has_pending_interrupt>> if (vcpu->arch.apicv_active &&
+	 *          static_call(kvm_x86_dy_apicv_has_pending_interrupt)(vcpu))
+	 */
 	bool apicv_active;
+	/*
+	 * 在以下使用kvm_vcpu_arch->load_eoi_exitmap_pending:
+	 *   - arch/x86/kvm/kvm_cache_regs.h|184| <<leave_guest_mode>> if (vcpu->arch.load_eoi_exitmap_pending) {
+	 *   - arch/x86/kvm/kvm_cache_regs.h|185| <<leave_guest_mode>> vcpu->arch.load_eoi_exitmap_pending = false;
+	 *   - arch/x86/kvm/x86.c|9850| <<vcpu_scan_ioapic>> vcpu->arch.load_eoi_exitmap_pending = true;
+	 */
 	bool load_eoi_exitmap_pending;
+	/*
+	 * 在以下使用kvm_vcpu_arch->ioapic_handled_vectors:
+	 *   - arch/x86/kvm/lapic.c|1273| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9840| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+	 *   - arch/x86/kvm/x86.c|9845| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9847| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9864| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,
+	 *              to_hv_synic(vcpu)->vec_bitmap, 256);
+	 *   - arch/x86/kvm/x86.c|9871| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10004| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+	 */
 	DECLARE_BITMAP(ioapic_handled_vectors, 256);
 	unsigned long apic_attention;
 	int32_t apic_arb_prio;
@@ -875,7 +932,23 @@ struct kvm_vcpu_arch {
 		bool pv_unhalted;
 	} pv;
 
+	/*
+	 * 在以下使用kvm_vcpu_arch->pending_ioapic_eoi:
+	 *   - arch/x86/kvm/lapic.c|1286| <<kvm_ioapic_send_eoi>> apic->vcpu->arch.pending_ioapic_eoi = vector;
+	 *   - arch/x86/kvm/x86.c|10008| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> BUG_ON(vcpu->arch.pending_ioapic_eoi > 255);
+	 *   - arch/x86/kvm/x86.c|10009| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> if (test_bit(vcpu->arch.pending_ioapic_eoi,
+	 *   - arch/x86/kvm/x86.c|10013| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> vcpu->arch.pending_ioapic_eoi;
+	 */
 	int pending_ioapic_eoi;
+	/*
+	 * 在以下使用kvm_vcpu_arch->pending_external_vector:
+	 *   - arch/x86/kvm/irq.c|37| <<pending_userspace_extint>> return v->arch.pending_external_vector != -1;
+	 *   - arch/x86/kvm/irq.c|121| <<kvm_cpu_get_extint>> int vector = v->arch.pending_external_vector;
+	 *   - arch/x86/kvm/irq.c|123| <<kvm_cpu_get_extint>> v->arch.pending_external_vector = -1;
+	 *   - arch/x86/kvm/x86.c|4691| <<kvm_vcpu_ioctl_interrupt>> if (vcpu->arch.pending_external_vector != -1)
+	 *   - arch/x86/kvm/x86.c|4694| <<kvm_vcpu_ioctl_interrupt>> vcpu->arch.pending_external_vector = irq->irq;
+	 *   - arch/x86/kvm/x86.c|11281| <<kvm_arch_vcpu_create>> vcpu->arch.pending_external_vector = -1;
+	 */
 	int pending_external_vector;
 
 	/* be preempted when it's in kernel-mode(cpl=0) */
@@ -1141,12 +1214,34 @@ struct kvm_arch {
 	atomic_t vapics_in_nmi_mode;
 	struct mutex apic_map_lock;
 	struct kvm_apic_map __rcu *apic_map;
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|279| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|290| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty,
+	 *   - arch/x86/kvm/lapic.c|378| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty,
+	 *   - arch/x86/kvm/lapic.c|401| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|441| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|447| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|453| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|496| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2862| <<kvm_lapic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3370| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	atomic_t apic_map_dirty;
 
 	/* Protects apic_access_memslot_enabled and apicv_inhibit_reasons */
 	struct rw_semaphore apicv_update_lock;
 
 	bool apic_access_memslot_enabled;
+	/*
+	 * 在以下使用kvm_arch->apicv_inhibit_reasons:
+	 *   - arch/x86/kvm/x86.c|9007| <<kvm_apicv_activated>> return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
+	 *   - arch/x86/kvm/x86.c|9013| <<kvm_vcpu_apicv_activated>> ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	 *   - arch/x86/kvm/x86.c|9033| <<kvm_apicv_init>> unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9830| <<__kvm_set_or_clear_apicv_inhibit>> old = new = kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9848| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 *   - arch/x86/kvm/x86.c|9857| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 */
 	unsigned long apicv_inhibit_reasons;
 
 	gpa_t wall_clock;
@@ -1156,6 +1251,13 @@ struct kvm_arch {
 	bool pause_in_guest;
 	bool cstate_in_guest;
 
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|187| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|219| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11732| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11735| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	unsigned long irq_sources_bitmap;
 	s64 kvmclock_offset;
 	raw_spinlock_t tsc_write_lock;
@@ -1177,6 +1279,12 @@ struct kvm_arch {
 
 	struct kvm_xen_hvm_config xen_hvm_config;
 
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|234| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|11763| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	/* reads protected by irq_srcu, writes by irq_lock */
 	struct hlist_head mask_notifier_list;
 
@@ -1195,11 +1303,38 @@ struct kvm_arch {
 	int cpu_dirty_logging_count;
 
 	enum kvm_irqchip_mode irqchip_mode;
+	/*
+	 * 在以下使用kvm_arch->nr_reserved_ioapic_pins:
+	 *   - arch/x86/kvm/irq_comm.c|405| <<kvm_scan_ioapic_routes>> nr_ioapic_pins =
+	 *               min_t(u32, table->nr_rt_entries, kvm->arch.nr_reserved_ioapic_pins);
+	 *   - arch/x86/kvm/x86.c|5796| <<kvm_vm_ioctl_enable_cap>>
+	 *               kvm->arch.nr_reserved_ioapic_pins = cap->args[0];
+	 */
 	u8 nr_reserved_ioapic_pins;
 
 	bool disabled_lapic_found;
 
+	/*
+	 * 在以下使用kvm_arch->x2apic_format:
+	 *   - arch/x86/kvm/irq_comm.c|137| <<kvm_set_msi_irq>> trace_kvm_msi_set_irq(msg.address_lo | (kvm->arch.x2apic_format ?
+	 *   - arch/x86/kvm/irq_comm.c|140| <<kvm_set_msi_irq>> irq->dest_id = x86_msi_msg_get_destid(&msg, kvm->arch.x2apic_format);
+	 *   - arch/x86/kvm/irq_comm.c|154| <<kvm_msi_route_invalid>> return kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);
+	 *   - arch/x86/kvm/lapic.c|3673| <<kvm_apic_state_fixup>> if (vcpu->kvm->arch.x2apic_format) {
+	 *   - arch/x86/kvm/x86.c|5933| <<kvm_vm_ioctl_enable_cap>> kvm->arch.x2apic_format = true;
+	 *
+	 *     x2apic_format = false,
+	 *     x2apic_broadcast_quirk_disabled = false,
+	 */
 	bool x2apic_format;
+	/*
+	 * 在以下使用kvm_arch->x2apic_broadcast_quirk_disabled:
+	 *   - arch/x86/kvm/lapic.c|1356| <<kvm_apic_mda>> if (!vcpu->kvm->arch.x2apic_broadcast_quirk_disabled &&
+	 *   - arch/x86/kvm/lapic.c|1435| <<kvm_apic_is_broadcast_dest>> if (kvm->arch.x2apic_broadcast_quirk_disabled) {
+	 *   - arch/x86/kvm/x86.c|5935| <<kvm_vm_ioctl_enable_cap>> kvm->arch.x2apic_broadcast_quirk_disabled = true;
+	 *
+	 *     x2apic_format = false,
+	 *     x2apic_broadcast_quirk_disabled = false,
+	 */
 	bool x2apic_broadcast_quirk_disabled;
 
 	bool guest_can_read_msr_platform_info;
@@ -1872,6 +2007,14 @@ void __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 void kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 				    enum kvm_apicv_inhibit reason, bool set);
 
+/*
+ * 在以下使用kvm_set_apicv_inhibit():
+ *   - arch/x86/kvm/i8254.c|308| <<kvm_pit_set_reinject>> kvm_set_apicv_inhibit(kvm, APICV_INHIBIT_REASON_PIT_REINJ);
+ *   - arch/x86/kvm/lapic.c|337| <<kvm_recalculate_apic_map>> kvm_set_apicv_inhibit(kvm, APICV_INHIBIT_REASON_APIC_ID_MODIFIED);
+ *   - arch/x86/kvm/lapic.c|2715| <<kvm_lapic_set_base>> kvm_set_apicv_inhibit(apic->vcpu->kvm, APICV_INHIBIT_REASON_APIC_BASE_MODIFIED);
+ *   - arch/x86/kvm/svm/sev.c|263| <<sev_guest_init>> kvm_set_apicv_inhibit(kvm, APICV_INHIBIT_REASON_SEV);
+ *   - arch/x86/kvm/svm/svm.c|3855| <<svm_enable_irq_window>> kvm_set_apicv_inhibit(vcpu->kvm, APICV_INHIBIT_REASON_IRQWIN);
+ */
 static inline void kvm_set_apicv_inhibit(struct kvm *kvm,
 					 enum kvm_apicv_inhibit reason)
 {
diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c
index 586ea838a5a1..22f9c3bc4c2a 100644
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@ -1896,6 +1896,11 @@ static void ioapic_setup_msg_from_msi(struct irq_data *irq_data,
 	entry->ir_index_0_14		= msg.arch_addr_lo.dmar_index_0_14;
 }
 
+/*
+ * 在以下使用ioapic_configure_entry():
+ *   - arch/x86/kernel/apic/io_apic.c|1920| <<ioapic_set_affinity>> ioapic_configure_entry(irq_data);
+ *   - arch/x86/kernel/apic/io_apic.c|3078| <<mp_irqdomain_activate>> ioapic_configure_entry(irq_data);
+ */
 static void ioapic_configure_entry(struct irq_data *irqd)
 {
 	struct mp_chip_data *mpd = irqd->chip_data;
diff --git a/arch/x86/kvm/ioapic.c b/arch/x86/kvm/ioapic.c
index 4e0f52660842..3e0d43006458 100644
--- a/arch/x86/kvm/ioapic.c
+++ b/arch/x86/kvm/ioapic.c
@@ -80,6 +80,20 @@ static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,
 				u32 index = array_index_nospec(
 					redir_index, IOAPIC_NUM_PINS);
 
+				/*
+				 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+				 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+				 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+				 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+				 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+				 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+				 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+				 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+				 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+				 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+				 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+				 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+				 */
 				redir_content = ioapic->redirtbl[index].bits;
 			}
 
@@ -114,7 +128,40 @@ static void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)
 	struct dest_map *dest_map = &ioapic->rtc_status.dest_map;
 	union kvm_ioapic_redirect_entry *e;
 
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	e = &ioapic->redirtbl[RTC_GSI];
+	/*
+	 * 在以下调用kvm_apic_match_dest():
+	 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+	 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+	 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+	 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+	 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+	 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+	 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+	 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+	 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+	 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+	 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+	 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+	 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+	 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+	 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+	 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+	 */
 	if (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,
 				 e->fields.dest_id,
 				 kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
@@ -186,9 +233,42 @@ static void ioapic_lazy_update_eoi(struct kvm_ioapic *ioapic, int irq)
 {
 	int i;
 	struct kvm_vcpu *vcpu;
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
 
 	kvm_for_each_vcpu(i, vcpu, ioapic->kvm) {
+		/*
+		 * 在以下调用kvm_apic_match_dest():
+		 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+		 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+		 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+		 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+		 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+		 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+		 */
 		if (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,
 					 entry->fields.dest_id,
 					 entry->fields.dest_mode) ||
@@ -212,6 +292,20 @@ static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,
 	u32 old_irr;
 	int edge, ret;
 
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	entry = ioapic->redirtbl[irq];
 	edge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);
 
@@ -276,6 +370,10 @@ static void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)
 }
 
 
+/*
+ * 在以下使用kvm_ioapic_scan_entry():
+ *   - arch/x86/kvm/x86.c|9917| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+ */
 void kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)
 {
 	struct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;
@@ -285,18 +383,97 @@ void kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)
 
 	spin_lock(&ioapic->lock);
 
+	/*
+	 * struct dest_map {
+	 * map = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 * 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 * 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+	 *
+	 * 第一次设置的地方
+	 * 看着似乎rtc_statu的bit都是空
+	 */
 	/* Make sure we see any missing RTC EOI */
 	if (test_bit(vcpu->vcpu_id, dest_map->map))
 		__set_bit(dest_map->vectors[vcpu->vcpu_id],
 			  ioapic_handled_vectors);
 
+	/*
+	 * union kvm_ioapic_redirect_entry {
+	 *     bits = 144115188075888682,
+	 *     fields = {
+	 *       vector = 42 '*',
+	 *       delivery_mode = 0 '\000',
+	 *       dest_mode = 0 '\000',
+	 *       delivery_status = 0 '\000',
+	 *       polarity = 0 '\000',
+	 *       remote_irr = 0 '\000',
+	 *       trig_mode = 1 '\001',
+	 *       mask = 0 '\000',
+	 *       reserve = 0 '\000',
+	 *       reserved = "\000\000\000",
+	 *       dest_id = 2 '\002'
+	 *     }
+	 *  }
+	 *
+	 * 57 union kvm_ioapic_redirect_entry {
+	 * 58         u64 bits;
+	 * 59         struct {
+	 * 60                 u8 vector;
+	 * 61                 u8 delivery_mode:3;
+	 * 62                 u8 dest_mode:1;
+	 * 63                 u8 delivery_status:1;
+	 * 64                 u8 polarity:1;
+	 * 65                 u8 remote_irr:1;
+	 * 66                 u8 trig_mode:1;
+	 * 67                 u8 mask:1;
+	 * 68                 u8 reserve:7;
+	 * 69                 u8 reserved[4];
+	 * 70                 u8 dest_id;
+	 * 71         } fields;
+	 * 72 };
+	 */
 	for (index = 0; index < IOAPIC_NUM_PINS; index++) {
+		/*
+		 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+		 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+		 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+		 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+		 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+		 *
+		 * 只在这里一个地方使用kvm_irq_has_notifier(), 返回false的概率大
+		 */
 		e = &ioapic->redirtbl[index];
 		if (e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||
 		    kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||
 		    index == RTC_GSI) {
 			u16 dm = kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);
 
+			/*
+			 * 在以下调用kvm_apic_match_dest():
+			 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+			 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+			 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+			 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+			 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+			 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+			 */
 			if (kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,
 						e->fields.dest_id, dm) ||
 			    kvm_apic_pending_eoi(vcpu, e->fields.vector))
@@ -314,6 +491,10 @@ void kvm_arch_post_irq_ack_notifier_list_update(struct kvm *kvm)
 	kvm_make_scan_ioapic_request(kvm);
 }
 
+/*
+ * 在以下使用ioapic_write_indirect():
+ *   - arch/x86/kvm/ioapic.c|907| <<ioapic_mmio_write>> ioapic_write_indirect(ioapic, data);
+ */
 static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)
 {
 	unsigned index;
@@ -340,6 +521,24 @@ static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)
 		if (index >= IOAPIC_NUM_PINS)
 			return;
 		index = array_index_nospec(index, IOAPIC_NUM_PINS);
+		/*
+		 * union kvm_ioapic_redirect_entry {
+		 *     u64 bits;
+		 *     struct {
+		 *         u8 vector;
+		 *         u8 delivery_mode:3;
+		 *         u8 dest_mode:1;
+		 *         u8 delivery_status:1;
+		 *         u8 polarity:1;
+		 *         u8 remote_irr:1;
+		 *         u8 trig_mode:1;
+		 *         u8 mask:1;
+		 *         u8 reserve:7;
+		 *         u8 reserved[4];
+		 *         u8 dest_id;
+		 *      } fields;
+		 * };
+		 */
 		e = &ioapic->redirtbl[index];
 		mask_before = e->fields.mask;
 		/* Preserve read-only fields */
@@ -347,6 +546,9 @@ static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)
 		old_delivery_status = e->fields.delivery_status;
 		old_dest_id = e->fields.dest_id;
 		old_dest_mode = e->fields.dest_mode;
+		/*
+		 * 主要在这里修改!
+		 */
 		if (ioapic->ioregsel & 1) {
 			e->bits &= 0xffffffff;
 			e->bits |= (u64) val << 32;
@@ -410,8 +612,35 @@ static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)
 	}
 }
 
+/*
+ * hot-add和hot-del都调用
+ *
+ * ioapic_service
+ * ioapic_set_irq
+ * kvm_ioapic_set_irq
+ * kvm_set_irq
+ * kvm_vm_ioctl_irq_line
+ * kvm_vm_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)
 {
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
 	struct kvm_lapic_irq irqe;
 	int ret;
@@ -487,6 +716,20 @@ static void kvm_ioapic_eoi_inject_work(struct work_struct *work)
 						 eoi_inject.work);
 	spin_lock(&ioapic->lock);
 	for (i = 0; i < IOAPIC_NUM_PINS; i++) {
+		/*
+		 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+		 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+		 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+		 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+		 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+		 */
 		union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
 
 		if (ent->fields.trig_mode != IOAPIC_LEVEL_TRIG)
@@ -499,12 +742,39 @@ static void kvm_ioapic_eoi_inject_work(struct work_struct *work)
 }
 
 #define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000
+/*
+ * kvm_ioapic_update_eoi
+ * kvm_apic_set_eoi_accelerated
+ * handle_apic_eoi_induced
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,
 				      struct kvm_ioapic *ioapic,
 				      int trigger_mode,
 				      int pin)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
 
 	/*
@@ -555,6 +825,20 @@ void kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)
 	spin_lock(&ioapic->lock);
 	rtc_irq_eoi(ioapic, vcpu, vector);
 	for (i = 0; i < IOAPIC_NUM_PINS; i++) {
+		/*
+		 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+		 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+		 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+		 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+		 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+		 */
 		union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
 
 		if (ent->fields.vector != vector)
@@ -666,6 +950,20 @@ static void kvm_ioapic_reset(struct kvm_ioapic *ioapic)
 	int i;
 
 	cancel_delayed_work_sync(&ioapic->eoi_inject);
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	for (i = 0; i < IOAPIC_NUM_PINS; i++)
 		ioapic->redirtbl[i].fields.mask = 1;
 	ioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;
diff --git a/arch/x86/kvm/ioapic.h b/arch/x86/kvm/ioapic.h
index f1b2b2a6ff4d..ac3cbdd17bcf 100644
--- a/arch/x86/kvm/ioapic.h
+++ b/arch/x86/kvm/ioapic.h
@@ -77,6 +77,20 @@ struct kvm_ioapic {
 	u32 id;
 	u32 irr;
 	u32 pad;
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry redirtbl[IOAPIC_NUM_PINS];
 	unsigned long irq_states[IOAPIC_NUM_PINS];
 	struct kvm_io_device dev;
diff --git a/arch/x86/kvm/irq.c b/arch/x86/kvm/irq.c
index 172b05343cfd..ca31ee95eda9 100644
--- a/arch/x86/kvm/irq.c
+++ b/arch/x86/kvm/irq.c
@@ -75,6 +75,12 @@ int kvm_cpu_has_extint(struct kvm_vcpu *v)
  * interrupt from apic will handled by hardware,
  * we don't need to check it here.
  */
+/*
+ * 在以下使用kvm_cpu_has_injectable_intr():
+ *   - arch/x86/kvm/svm/svm.c|2448| <<svm_set_gif>> kvm_cpu_has_injectable_intr(&svm->vcpu))
+ *   - arch/x86/kvm/x86.c|9412| <<inject_pending_event>> if (kvm_cpu_has_injectable_intr(vcpu)) {
+ *   - arch/x86/kvm/x86.c|9425| <<inject_pending_event>> if (kvm_cpu_has_injectable_intr(vcpu))
+ */
 int kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)
 {
 	if (kvm_cpu_has_extint(v))
@@ -83,6 +89,13 @@ int kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)
 	if (!is_guest_mode(v) && kvm_vcpu_apicv_active(v))
 		return 0;
 
+	/*
+	 * 在以下使用kvm_apic_has_interrupt():
+	 *   - arch/x86/kvm/irq.c|86| <<kvm_cpu_has_injectable_intr>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/irq.c|99| <<kvm_cpu_has_interrupt>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/lapic.c|2841| <<kvm_get_apic_interrupt>> int vector = kvm_apic_has_interrupt(vcpu);
+	 *   - arch/x86/kvm/vmx/nested.c|3627| <<nested_vmx_run>> kvm_apic_has_interrupt(vcpu) == vmx->nested.posted_intr_nv) {
+	 */
 	return kvm_apic_has_interrupt(v) != -1; /* LAPIC */
 }
 EXPORT_SYMBOL_GPL(kvm_cpu_has_injectable_intr);
@@ -91,11 +104,24 @@ EXPORT_SYMBOL_GPL(kvm_cpu_has_injectable_intr);
  * check if there is pending interrupt without
  * intack.
  */
+/*
+ * 在以下使用kvm_cpu_has_interrupt():
+ *   - arch/x86/kvm/svm/nested.c|1334| <<svm_check_nested_events>> if (kvm_cpu_has_interrupt(vcpu) && !svm_interrupt_blocked(vcpu)) {
+ *   - arch/x86/kvm/vmx/nested.c|4021| <<vmx_check_nested_events>> if (kvm_cpu_has_interrupt(vcpu) && !vmx_interrupt_blocked(vcpu)) {
+ *   - arch/x86/kvm/x86.c|12828| <<kvm_vcpu_has_events>> (kvm_cpu_has_interrupt(vcpu) ||
+ */
 int kvm_cpu_has_interrupt(struct kvm_vcpu *v)
 {
 	if (kvm_cpu_has_extint(v))
 		return 1;
 
+	/*
+	 * 在以下使用kvm_apic_has_interrupt():
+	 *   - arch/x86/kvm/irq.c|86| <<kvm_cpu_has_injectable_intr>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/irq.c|99| <<kvm_cpu_has_interrupt>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/lapic.c|2841| <<kvm_get_apic_interrupt>> int vector = kvm_apic_has_interrupt(vcpu);
+	 *   - arch/x86/kvm/vmx/nested.c|3627| <<nested_vmx_run>> kvm_apic_has_interrupt(vcpu) == vmx->nested.posted_intr_nv) {
+	 */
 	return kvm_apic_has_interrupt(v) != -1;	/* LAPIC */
 }
 EXPORT_SYMBOL_GPL(kvm_cpu_has_interrupt);
@@ -129,6 +155,11 @@ static int kvm_cpu_get_extint(struct kvm_vcpu *v)
 /*
  * Read pending interrupt vector and intack.
  */
+/*
+ * 在以下调用kvm_cpu_get_interrupt():
+ *   - arch/x86/kvm/vmx/nested.c|4709| <<nested_vmx_vmexit>> int irq = kvm_cpu_get_interrupt(vcpu);
+ *   - arch/x86/kvm/x86.c|9417| <<inject_pending_event>> int irq = kvm_cpu_get_interrupt(vcpu);
+ */
 int kvm_cpu_get_interrupt(struct kvm_vcpu *v)
 {
 	int vector = kvm_cpu_get_extint(v);
diff --git a/arch/x86/kvm/irq_comm.c b/arch/x86/kvm/irq_comm.c
index 025b65502fce..418bd44dd115 100644
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@ -65,6 +65,25 @@ int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,
 		if (!kvm_apic_present(vcpu))
 			continue;
 
+		/*
+		 * 在以下调用kvm_apic_match_dest():
+		 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+		 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+		 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+		 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+		 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+		 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+		 */
 		if (!kvm_apic_match_dest(vcpu, src, irq->shorthand,
 					irq->dest_id, irq->dest_mode))
 			continue;
@@ -74,6 +93,15 @@ int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,
 				r = 0;
 			r += kvm_apic_set_irq(vcpu, irq, dest_map);
 		} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {
+			/*
+			 * 在以下使用kvm_apic_sw_enabled():
+			 *   - arch/x86/kvm/irq_comm.c|95| <<kvm_irq_delivery_to_apic>> } else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {
+			 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+			 *   - arch/x86/kvm/lapic.c|424| <<kvm_recalculate_apic_map>> if (!kvm_apic_sw_enabled(apic))
+			 *   - arch/x86/kvm/lapic.c|2720| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+			 *   - arch/x86/kvm/lapic.c|2731| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+			 *   - arch/x86/kvm/lapic.h|251| <<kvm_lapic_enabled>> return kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);
+			 */
 			if (!kvm_vector_hashing_enabled()) {
 				if (!lowest)
 					lowest = vcpu;
@@ -109,6 +137,17 @@ void kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,
 	trace_kvm_msi_set_irq(msg.address_lo | (kvm->arch.x2apic_format ?
 			      (u64)msg.address_hi << 32 : 0), msg.data);
 
+	/*
+	 * 在以下使用kvm_arch->x2apic_format:
+	 *   - arch/x86/kvm/irq_comm.c|137| <<kvm_set_msi_irq>> trace_kvm_msi_set_irq(msg.address_lo | (kvm->arch.x2apic_format ?
+	 *   - arch/x86/kvm/irq_comm.c|140| <<kvm_set_msi_irq>> irq->dest_id = x86_msi_msg_get_destid(&msg, kvm->arch.x2apic_format);
+	 *   - arch/x86/kvm/irq_comm.c|154| <<kvm_msi_route_invalid>> return kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);
+	 *   - arch/x86/kvm/lapic.c|3673| <<kvm_apic_state_fixup>> if (vcpu->kvm->arch.x2apic_format) {
+	 *   - arch/x86/kvm/x86.c|5933| <<kvm_vm_ioctl_enable_cap>> kvm->arch.x2apic_format = true;
+	 *
+	 *     x2apic_format = false,
+	 *     x2apic_broadcast_quirk_disabled = false,
+	 */
 	irq->dest_id = x86_msi_msg_get_destid(&msg, kvm->arch.x2apic_format);
 	irq->vector = msg.arch_data.vector;
 	irq->dest_mode = kvm_lapic_irq_dest_mode(msg.arch_addr_lo.dest_mode_logical);
@@ -123,6 +162,17 @@ EXPORT_SYMBOL_GPL(kvm_set_msi_irq);
 static inline bool kvm_msi_route_invalid(struct kvm *kvm,
 		struct kvm_kernel_irq_routing_entry *e)
 {
+	/*
+	 * 在以下使用kvm_arch->x2apic_format:
+	 *   - arch/x86/kvm/irq_comm.c|137| <<kvm_set_msi_irq>> trace_kvm_msi_set_irq(msg.address_lo | (kvm->arch.x2apic_format ?
+	 *   - arch/x86/kvm/irq_comm.c|140| <<kvm_set_msi_irq>> irq->dest_id = x86_msi_msg_get_destid(&msg, kvm->arch.x2apic_format);
+	 *   - arch/x86/kvm/irq_comm.c|154| <<kvm_msi_route_invalid>> return kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);
+	 *   - arch/x86/kvm/lapic.c|3673| <<kvm_apic_state_fixup>> if (vcpu->kvm->arch.x2apic_format) {
+	 *   - arch/x86/kvm/x86.c|5933| <<kvm_vm_ioctl_enable_cap>> kvm->arch.x2apic_format = true;
+	 *
+	 *     x2apic_format = false,
+	 *     x2apic_broadcast_quirk_disabled = false,
+	 */
 	return kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);
 }
 
@@ -184,6 +234,13 @@ int kvm_arch_set_irq_inatomic(struct kvm_kernel_irq_routing_entry *e,
 
 int kvm_request_irq_source_id(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|187| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|219| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11732| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11735| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
 	int irq_source_id;
 
@@ -216,6 +273,13 @@ void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)
 		printk(KERN_ERR "kvm: IRQ source ID out of range!\n");
 		goto unlock;
 	}
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|187| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|219| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11732| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11735| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
 	if (!irqchip_kernel(kvm))
 		goto unlock;
@@ -231,6 +295,12 @@ void kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,
 {
 	mutex_lock(&kvm->irq_lock);
 	kimn->irq = irq;
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|234| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|11763| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
 	mutex_unlock(&kvm->irq_lock);
 }
@@ -252,6 +322,12 @@ void kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,
 
 	idx = srcu_read_lock(&kvm->irq_srcu);
 	gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|234| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|11763| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	if (gsi != -1)
 		hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
 			if (kimn->irq == gsi)
@@ -330,6 +406,25 @@ bool kvm_intr_is_single_vcpu(struct kvm *kvm, struct kvm_lapic_irq *irq,
 		if (!kvm_apic_present(vcpu))
 			continue;
 
+		/*
+		 * 在以下调用kvm_apic_match_dest():
+		 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+		 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+		 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+		 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+		 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+		 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+		 */
 		if (!kvm_apic_match_dest(vcpu, NULL, irq->shorthand,
 					irq->dest_id, irq->dest_mode))
 			continue;
@@ -390,6 +485,10 @@ void kvm_arch_post_irq_routing_update(struct kvm *kvm)
 	kvm_make_scan_ioapic_request(kvm);
 }
 
+/*
+ * 只在一个地方调用kvm_scan_ioapic_routes():
+ *   - arch/x86/kvm/x86.c|9856| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+ */
 void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,
 			    ulong *ioapic_handled_vectors)
 {
@@ -412,6 +511,25 @@ void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,
 
 			kvm_set_msi_irq(vcpu->kvm, entry, &irq);
 
+			/*
+			 * 在以下调用kvm_apic_match_dest():
+			 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+			 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+			 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+			 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+			 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+			 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+			 */
 			if (irq.trig_mode &&
 			    (kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,
 						 irq.dest_id, irq.dest_mode) ||
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 43c2722ef25e..40eec456d030 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -43,6 +43,66 @@
 #include "cpuid.h"
 #include "hyperv.h"
 
+/*
+ * | 项目                 | MSR_IA32_APICBASE       | SPIV (0xF0)                |
+ * | ------------------ | ------------------------- | -------------------------- |
+ * | 控制粒度               | 硬件级,全局关闭                  | 软件级,关闭中断处理                 |
+ * | 生效范围               | 关闭整个 Local APIC           | 保留结构但不响应中断                 |
+ * | 通常使用时机             | BIOS,操作系统启动阶段             | 操作系统运行时                    |
+ * | 会影响 APIC MMIO 寄存器吗 | 是,APIC 基址无效后不能访问 APIC 寄存器 | 否,仍然可访问 APIC 寄存器           |
+ * | 对中断的影响             | 完全禁用中断(包括 INIT, STARTUP)  | 仅禁用普通中断,某些特殊中断(如 NMI)有效    |
+ * | 典型用途               | 内核初始化前设置,关闭 SMP 支持        | 操作系统禁用中断(如使用 IOAPIC 或 PIC) |
+ *
+ *
+ * 如果你只把SPIV 的使能位关掉(即SPIV[8]=0),CPU不会响应普通中断,但Local APIC结构还在,
+ * 依然可以接收INIT或IPI等特殊信号.
+ *
+ * 如果你把MSR_IA32_APICBASE[11]=0,则整个Local APIC被禁用,APIC MMIO区也不能访问,
+ * 连 INIT,STARTUP都可能无法正确使用.
+ */
+
+/*
+ * 下面两个函数很重要.
+ *
+ * vmx_inject_irq()
+ * vmx_hwapic_isr_update()
+ */
+
+/*
+ * 在以下使用apic的regs:
+ *   - arch/x86/kvm/lapic.c|88| <<kvm_lapic_set_reg>> __kvm_lapic_set_reg(apic->regs, reg_off, val);
+ *   - arch/x86/kvm/lapic.c|99| <<kvm_lapic_get_reg64>> return __kvm_lapic_get_reg64(apic->regs, reg);
+ *   - arch/x86/kvm/lapic.c|111| <<kvm_lapic_set_reg64>> __kvm_lapic_set_reg64(apic->regs, reg, val);
+ *   - arch/x86/kvm/lapic.c|123| <<kvm_apic_pending_eoi>> return apic_test_vector(vector, apic->regs + APIC_ISR) ||
+ *   - arch/x86/kvm/lapic.c|124| <<kvm_apic_pending_eoi>> apic_test_vector(vector, apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.c|682| <<kvm_apic_update_irr>> bool irr_updated = __kvm_apic_update_irr(pir, apic->regs, max_irr);
+ *   - arch/x86/kvm/lapic.c|707| <<apic_search_irr>> return find_highest_vector(apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.c|750| <<apic_clear_irr>> kvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.c|770| <<apic_clear_irr>> kvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.c|790| <<apic_set_isr>> if (__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))
+ *   - arch/x86/kvm/lapic.c|878| <<apic_find_highest_isr>> result = find_highest_vector(apic->regs + APIC_ISR);
+ *   - arch/x86/kvm/lapic.c|891| <<apic_clear_isr>> if (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))
+ *   - arch/x86/kvm/lapic.c|1553| <<__apic_accept_irq>> if (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {
+ *   - arch/x86/kvm/lapic.c|1556| <<__apic_accept_irq>> kvm_lapic_set_vector(vector, apic->regs + APIC_TMR);
+ *   - arch/x86/kvm/lapic.c|1559| <<__apic_accept_irq>> kvm_lapic_clear_vector(vector, apic->regs + APIC_TMR);
+ *   - arch/x86/kvm/lapic.c|1730| <<kvm_ioapic_send_eoi>> if (apic_test_vector(vector, apic->regs + APIC_TMR))
+ *   - arch/x86/kvm/lapic.c|2060| <<lapic_timer_int_injected>> void *bitmap = apic->regs + APIC_ISR;
+ *   - arch/x86/kvm/lapic.c|2063| <<lapic_timer_int_injected>> bitmap = apic->regs + APIC_IRR;
+ *   - arch/x86/kvm/lapic.c|2833| <<kvm_free_lapic>> if (apic->regs)
+ *   - arch/x86/kvm/lapic.c|2834| <<kvm_free_lapic>> free_page((unsigned long )apic->regs);
+ *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_update_apicv>> apic->isr_count = count_vectors(apic->regs + APIC_ISR);
+ *   - arch/x86/kvm/lapic.c|3198| <<kvm_create_lapic>> apic->regs = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT);
+ *   - arch/x86/kvm/lapic.c|3199| <<kvm_create_lapic>> if (!apic->regs) {
+ *   - arch/x86/kvm/lapic.c|3373| <<kvm_apic_get_state>> memcpy(s->regs, vcpu->arch.apic->regs, sizeof(*s));
+ *   - arch/x86/kvm/lapic.c|3413| <<kvm_apic_set_state>> apic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));
+ *   - arch/x86/kvm/lapic.c|3433| <<kvm_apic_set_state>> memcpy(vcpu->arch.apic->regs, s->regs, sizeof(*s));
+ *   - arch/x86/kvm/lapic.h|184| <<kvm_lapic_set_irr>> kvm_lapic_set_vector(vec, apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.h|214| <<kvm_lapic_get_reg>> return __kvm_lapic_get_reg(apic->regs, reg_off);
+ *   - arch/x86/kvm/svm/avic.c|294| <<avic_init_backing_page>> if (!vcpu->arch.apic->regs)
+ *   - arch/x86/kvm/svm/avic.c|305| <<avic_init_backing_page>> svm->avic_backing_page = virt_to_page(vcpu->arch.apic->regs);
+ *   - arch/x86/kvm/vmx/vmx.c|4590| <<init_vmcs>> ivmcs_write64(VIRTUAL_APIC_PAGE_ADDR, __pa(vmx->vcpu.arch.apic->regs));
+ */
+
 #ifndef CONFIG_X86_64
 #define mod_64(x, y) ((x) - (y) * div64_u64(x, y))
 #else
@@ -130,8 +190,32 @@ static inline int __apic_test_and_clear_vector(int vec, void *bitmap)
 __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_hw_disabled, HZ);
 __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_sw_disabled, HZ);
 
+/*
+ * 在以下使用apic_enabled():
+ *   - arch/x86/kvm/lapic.c|1655| <<__apic_accept_irq>> if (unlikely(!apic_enabled(apic)))
+ *   - arch/x86/kvm/lapic.c|3388| <<apic_has_pending_timer>> if (apic_enabled(apic) && apic_lvt_enabled(apic, APIC_LVTT))
+ */
 static inline int apic_enabled(struct kvm_lapic *apic)
 {
+	/*
+	 * 在以下使用kvm_apic_sw_enabled():
+	 *   - arch/x86/kvm/irq_comm.c|95| <<kvm_irq_delivery_to_apic>> } else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {
+	 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+	 *   - arch/x86/kvm/lapic.c|424| <<kvm_recalculate_apic_map>> if (!kvm_apic_sw_enabled(apic))
+	 *   - arch/x86/kvm/lapic.c|2720| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+	 *   - arch/x86/kvm/lapic.c|2731| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+	 *   - arch/x86/kvm/lapic.h|251| <<kvm_lapic_enabled>> return kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);
+	 *
+	 * 在以下调用kvm_apic_hw_enabled():
+	 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+	 *   - arch/x86/kvm/lapic.c|2040| <<apic_mmio_read>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2125| <<lapic_timer_int_injected>> if (kvm_apic_hw_enabled(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2809| <<apic_mmio_write>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|3330| <<kvm_apic_local_deliver>> if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
+	 *   - arch/x86/kvm/lapic.c|3443| <<kvm_apic_accept_pic_intr>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 *   - arch/x86/kvm/lapic.h|246| <<kvm_apic_present>> return lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
+	 *   - arch/x86/kvm/x86.c|10218| <<vcpu_load_eoi_exitmap>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 */
 	return kvm_apic_sw_enabled(apic) &&	kvm_apic_hw_enabled(apic);
 }
 
@@ -222,6 +306,44 @@ enum {
 	DIRTY
 };
 
+/*
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_vcpu_reset
+ * kvm_apic_accept_events
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_lapic_reg_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ *
+ * 在以下调用kvm_recalculate_apic_map():
+ *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+ *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+ *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+ *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+ *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+ */
 void kvm_recalculate_apic_map(struct kvm *kvm)
 {
 	struct kvm_apic_map *new, *old = NULL;
@@ -230,6 +352,19 @@ void kvm_recalculate_apic_map(struct kvm *kvm)
 	u32 max_id = 255; /* enough space for any xAPIC ID */
 	bool xapic_id_mismatch = false;
 
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|279| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|290| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty,
+	 *   - arch/x86/kvm/lapic.c|378| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty,
+	 *   - arch/x86/kvm/lapic.c|401| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|441| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|447| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|453| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|496| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2862| <<kvm_lapic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3370| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	/* Read kvm->arch.apic_map_dirty before kvm->arch.apic_map.  */
 	if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
 		return;
@@ -273,9 +408,41 @@ void kvm_recalculate_apic_map(struct kvm *kvm)
 		if (!kvm_apic_present(vcpu))
 			continue;
 
+		/*
+		 * 在以下使用kvm_apic_set_xapic_id():
+		 *   - arch/x86/kvm/lapic.c|2455| <<kvm_lapic_reg_write(APIC_ID)>> kvm_apic_set_xapic_id(apic, val >> 24);
+		 *   - arch/x86/kvm/lapic.c|2756| <<kvm_lapic_set_base>> kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
+		 *   - arch/x86/kvm/lapic.c|2871| <<kvm_lapic_reset>> kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
+		 *
+		 *
+		 * 返回: return kvm_lapic_get_reg(apic, APIC_ID) >> 24;
+		 */
 		xapic_id = kvm_xapic_id(apic);
+		/*
+		 * 返回: return apic->vcpu->vcpu_id;
+		 */
 		x2apic_id = kvm_x2apic_id(apic);
 
+		/*
+		 * 在以下设置kvm_vcpu_arch->apic_base (看似修改的地方):
+		 *   - arch/x86/kvm/lapic.c|2926| <<kvm_lapic_set_base>> vcpu->arch.apic_base = value;
+		 *   - arch/x86/kvm/lapic.c|3256| <<kvm_create_lapic>> vcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;
+		 * 在以下使用kvm_vcpu_arch->apic_base:
+		 *   - arch/x86/kvm/cpuid.c|222| <<__kvm_update_cpuid_runtime>> cpuid_entry_change(best, X86_FEATURE_APIC, vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE);
+		 *   - arch/x86/kvm/lapic.c|2862| <<kvm_free_lapic>> if (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))
+		 *   - arch/x86/kvm/lapic.c|2923| <<kvm_lapic_set_base>> u64 old_value = vcpu->arch.apic_base;
+		 *   - arch/x86/kvm/lapic.c|2974| <<kvm_lapic_set_base>> apic->base_address = apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_BASE;
+		 *   - arch/x86/kvm/lapic.c|3454| <<kvm_apic_set_state>> kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
+		 *   - arch/x86/kvm/lapic.h|231| <<kvm_apic_hw_enabled>> return apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;
+		 *   - arch/x86/kvm/lapic.h|256| <<apic_x2apic_mode>> return apic->vcpu->arch.apic_base & X2APIC_ENABLE;
+		 *   - arch/x86/kvm/lapic.h|300| <<kvm_apic_mode>> return apic_base & (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);
+		 *   - arch/x86/kvm/vmx/nested.c|878| <<nested_vmx_msr_check_common>> if (CC(vcpu->arch.apic_base & X2APIC_ENABLE && e->index >> 8 == 0x8))
+		 *   - arch/x86/kvm/x86.c|466| <<kvm_get_apic_base>> return vcpu->arch.apic_base;
+		 *   - arch/x86/kvm/x86.c|12215| <<kvm_vcpu_is_bsp>> return (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;
+		 *
+		 * 返回:
+		 * return apic->vcpu->arch.apic_base & X2APIC_ENABLE;
+		 */
 		/*
 		 * Deliberately truncate the vCPU ID when detecting a mismatched
 		 * APIC ID to avoid false positives if the vCPU ID, i.e. x2APIC
@@ -296,6 +463,15 @@ void kvm_recalculate_apic_map(struct kvm *kvm)
 		if (!apic_x2apic_mode(apic) && !new->phys_map[xapic_id])
 			new->phys_map[xapic_id] = apic;
 
+		/*
+		 * 在以下使用kvm_apic_sw_enabled():
+		 *   - arch/x86/kvm/irq_comm.c|95| <<kvm_irq_delivery_to_apic>> } else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {
+		 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+		 *   - arch/x86/kvm/lapic.c|424| <<kvm_recalculate_apic_map>> if (!kvm_apic_sw_enabled(apic))
+		 *   - arch/x86/kvm/lapic.c|2720| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+		 *   - arch/x86/kvm/lapic.c|2731| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+		 *   - arch/x86/kvm/lapic.h|251| <<kvm_lapic_enabled>> return kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);
+		 */
 		if (!kvm_apic_sw_enabled(apic))
 			continue;
 
@@ -318,6 +494,9 @@ void kvm_recalculate_apic_map(struct kvm *kvm)
 			cluster[ffs(mask) - 1] = apic;
 	}
 out:
+	/*
+	 * 就在这一个地方修改APICV_INHIBIT_REASON_APIC_ID_MODIFIED
+	 */
 	if (xapic_id_mismatch)
 		kvm_set_apicv_inhibit(kvm, APICV_INHIBIT_REASON_APIC_ID_MODIFIED);
 	else
@@ -346,6 +525,13 @@ static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)
 
 	kvm_lapic_set_reg(apic, APIC_SPIV, val);
 
+	/*
+	 * 在以下使用kvm_lapic->sw_enabled:
+	 *   - arch/x86/kvm/lapic.c|474| <<apic_set_spiv>> if (enabled != apic->sw_enabled) {
+	 *   - arch/x86/kvm/lapic.c|475| <<apic_set_spiv>> apic->sw_enabled = enabled;
+	 *   - arch/x86/kvm/lapic.c|2899| <<kvm_free_lapic>> if (!apic->sw_enabled)
+	 *   - arch/x86/kvm/lapic.h|260| <<kvm_apic_sw_enabled>> return apic->sw_enabled;
+	 */
 	if (enabled != apic->sw_enabled) {
 		apic->sw_enabled = enabled;
 		if (enabled)
@@ -353,6 +539,19 @@ static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)
 		else
 			static_branch_inc(&apic_sw_disabled.key);
 
+		/*
+		 * 在以下使用kvm_arch->apic_map_dirty:
+		 *   - arch/x86/kvm/lapic.c|279| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+		 *   - arch/x86/kvm/lapic.c|290| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty,
+		 *   - arch/x86/kvm/lapic.c|378| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty,
+		 *   - arch/x86/kvm/lapic.c|401| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|441| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|447| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|453| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|496| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|2862| <<kvm_lapic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 *   - arch/x86/kvm/lapic.c|3370| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+		 */
 		atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 	}
 
@@ -361,9 +560,53 @@ static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)
 		kvm_make_request(KVM_REQ_APF_READY, apic->vcpu);
 }
 
+/*
+ * 在以下使用kvm_apic_set_xapic_id():
+ *   - arch/x86/kvm/lapic.c|2455| <<kvm_lapic_reg_write(APIC_ID)>> kvm_apic_set_xapic_id(apic, val >> 24);
+ *   - arch/x86/kvm/lapic.c|2756| <<kvm_lapic_set_base>> kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
+ *   - arch/x86/kvm/lapic.c|2871| <<kvm_lapic_reset>> kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
+ *
+ * 其实kvm_apic_set_state()也会修改APIC_ID
+ */
 static inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)
 {
+	/*
+	 * 在以下使用APIC_ID:
+	 *   - arch/x86/kvm/svm/svm.c|119| <<global>> { .index = X2APIC_MSR(APIC_ID), .always = false },
+	 *   - arch/x86/include/asm/apic.h|204| <<native_apic_msr_write>> if (reg == APIC_DFR || reg == APIC_ID || reg == APIC_LDR ||
+	 *   - arch/x86/include/asm/apic.h|487| <<read_apic_id>> unsigned int reg = apic_read(APIC_ID);
+	 *   - arch/x86/kernel/apic/apic.c|1797| <<setup_nox2apic>> int apicid = native_apic_msr_read(APIC_ID);
+	 *   - arch/x86/kernel/apic/apic.c|2586| <<apic_bsp_up_setup>> apic_write(APIC_ID, apic->set_apic_id(boot_cpu_physical_apicid));
+	 *   - arch/x86/kernel/apic/apic.c|2668| <<lapic_suspend>> apic_pm_state.apic_id = apic_read(APIC_ID);
+	 *   - arch/x86/kernel/apic/apic.c|2745| <<lapic_resume>> apic_write(APIC_ID, apic_pm_state.apic_id);
+	 *   - arch/x86/kernel/apic/apic_flat_64.c|91| <<read_xapic_id>> return flat_get_apic_id(apic_read(APIC_ID));
+	 *   - arch/x86/kernel/apic/vector.c|1157| <<print_local_APIC>> v = apic_read(APIC_ID);
+	 *   - arch/x86/kernel/apic/x2apic_uv_x.c|811| <<uv_read_apic_id>> return x2apic_get_apic_id(apic_read(APIC_ID));
+	 *   - arch/x86/kernel/smpboot.c|689| <<__inquire_remote_apic>> unsigned i, regs[] = { APIC_ID >> 4, APIC_LVR >> 4, APIC_SPIV >> 4 };
+	 *   - arch/x86/kvm/lapic.c|381| <<kvm_apic_set_xapic_id>> kvm_lapic_set_reg(apic, APIC_ID, id << 24);
+	 *   - arch/x86/kvm/lapic.c|408| <<kvm_apic_set_x2apic_id>> kvm_lapic_set_reg(apic, APIC_ID, id);
+	 *   - arch/x86/kvm/lapic.c|1762| <<kvm_lapic_reg_read>> APIC_REG_MASK(APIC_ID) |
+	 *   - arch/x86/kvm/lapic.c|2393| <<kvm_lapic_reg_write>> case APIC_ID:
+	 *   - arch/x86/kvm/lapic.c|3094| <<kvm_apic_state_fixup>> u32 *id = (u32 *)(s->regs + APIC_ID);
+	 *   - arch/x86/kvm/lapic.h|305| <<kvm_xapic_id>> return kvm_lapic_get_reg(apic, APIC_ID) >> 24;
+	 *   - arch/x86/kvm/svm/avic.c|675| <<is_avic_unaccelerated_access_trap>> case APIC_ID:
+	 *   - arch/x86/xen/apic.c|63| <<xen_apic_read>> if (reg != APIC_ID)
+	 *   - tools/testing/selftests/kvm/x86_64/xapic_ipi_test.c|100| <<halter_guest_code>> data->halter_apic_id = GET_APIC_ID_FIELD(xapic_read_reg(APIC_ID));
+	 */
 	kvm_lapic_set_reg(apic, APIC_ID, id << 24);
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|279| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|290| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty,
+	 *   - arch/x86/kvm/lapic.c|378| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty,
+	 *   - arch/x86/kvm/lapic.c|401| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|441| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|447| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|453| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|496| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2862| <<kvm_lapic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3370| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 }
 
@@ -384,14 +627,54 @@ static inline u32 kvm_apic_calc_x2apic_ldr(u32 id)
 	return ((id >> 4) << 16) | (1 << (id & 0xf));
 }
 
+/*
+ * 只在此处使用kvm_apic_set_x2apic_id():
+ *   - arch/x86/kvm/lapic.c|2767| <<kvm_lapic_set_base>> kvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);
+ */
 static inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u32 id)
 {
 	u32 ldr = kvm_apic_calc_x2apic_ldr(id);
 
 	WARN_ON_ONCE(id != apic->vcpu->vcpu_id);
 
+	/*
+	 * 在以下使用APIC_ID:
+	 *   - arch/x86/kvm/svm/svm.c|119| <<global>> { .index = X2APIC_MSR(APIC_ID), .always = false },
+	 *   - arch/x86/include/asm/apic.h|204| <<native_apic_msr_write>> if (reg == APIC_DFR || reg == APIC_ID || reg == APIC_LDR ||
+	 *   - arch/x86/include/asm/apic.h|487| <<read_apic_id>> unsigned int reg = apic_read(APIC_ID);
+	 *   - arch/x86/kernel/apic/apic.c|1797| <<setup_nox2apic>> int apicid = native_apic_msr_read(APIC_ID);
+	 *   - arch/x86/kernel/apic/apic.c|2586| <<apic_bsp_up_setup>> apic_write(APIC_ID, apic->set_apic_id(boot_cpu_physical_apicid));
+	 *   - arch/x86/kernel/apic/apic.c|2668| <<lapic_suspend>> apic_pm_state.apic_id = apic_read(APIC_ID);
+	 *   - arch/x86/kernel/apic/apic.c|2745| <<lapic_resume>> apic_write(APIC_ID, apic_pm_state.apic_id);
+	 *   - arch/x86/kernel/apic/apic_flat_64.c|91| <<read_xapic_id>> return flat_get_apic_id(apic_read(APIC_ID));
+	 *   - arch/x86/kernel/apic/vector.c|1157| <<print_local_APIC>> v = apic_read(APIC_ID);
+	 *   - arch/x86/kernel/apic/x2apic_uv_x.c|811| <<uv_read_apic_id>> return x2apic_get_apic_id(apic_read(APIC_ID));
+	 *   - arch/x86/kernel/smpboot.c|689| <<__inquire_remote_apic>> unsigned i, regs[] = { APIC_ID >> 4, APIC_LVR >> 4, APIC_SPIV >> 4 };
+	 *   - arch/x86/kvm/lapic.c|381| <<kvm_apic_set_xapic_id>> kvm_lapic_set_reg(apic, APIC_ID, id << 24);
+	 *   - arch/x86/kvm/lapic.c|408| <<kvm_apic_set_x2apic_id>> kvm_lapic_set_reg(apic, APIC_ID, id);
+	 *   - arch/x86/kvm/lapic.c|1762| <<kvm_lapic_reg_read>> APIC_REG_MASK(APIC_ID) |
+	 *   - arch/x86/kvm/lapic.c|2393| <<kvm_lapic_reg_write>> case APIC_ID:
+	 *   - arch/x86/kvm/lapic.c|3094| <<kvm_apic_state_fixup>> u32 *id = (u32 *)(s->regs + APIC_ID);
+	 *   - arch/x86/kvm/lapic.h|305| <<kvm_xapic_id>> return kvm_lapic_get_reg(apic, APIC_ID) >> 24;
+	 *   - arch/x86/kvm/svm/avic.c|675| <<is_avic_unaccelerated_access_trap>> case APIC_ID:
+	 *   - arch/x86/xen/apic.c|63| <<xen_apic_read>> if (reg != APIC_ID)
+	 *   - tools/testing/selftests/kvm/x86_64/xapic_ipi_test.c|100| <<halter_guest_code>> data->halter_apic_id = GET_APIC_ID_FIELD(xapic_read_reg(APIC_ID));
+	 */
 	kvm_lapic_set_reg(apic, APIC_ID, id);
 	kvm_lapic_set_reg(apic, APIC_LDR, ldr);
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|279| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|290| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty,
+	 *   - arch/x86/kvm/lapic.c|378| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty,
+	 *   - arch/x86/kvm/lapic.c|401| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|441| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|447| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|453| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|496| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2862| <<kvm_lapic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3370| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 }
 
@@ -478,6 +761,11 @@ static u8 count_vectors(void *bitmap)
 	return count;
 }
 
+/*
+ * 在以下使用__kvm_apic_update_irr():
+ *   - arch/x86/kvm/lapic.c|527| <<kvm_apic_update_irr>> bool irr_updated = __kvm_apic_update_irr(pir, apic->regs, max_irr);
+ *   - arch/x86/kvm/vmx/nested.c|3832| <<vmx_complete_nested_posted_interrupt>> __kvm_apic_update_irr(vmx->nested.pi_desc->pir,
+ */
 bool __kvm_apic_update_irr(u32 *pir, void *regs, int *max_irr)
 {
 	u32 i, vec;
@@ -514,11 +802,30 @@ bool __kvm_apic_update_irr(u32 *pir, void *regs, int *max_irr)
 }
 EXPORT_SYMBOL_GPL(__kvm_apic_update_irr);
 
+/*
+ * 只在以下调用kvm_apic_update_irr():
+ *   - arch/x86/kvm/vmx/vmx.c|6490| <<vmx_sync_pir_to_irr>> kvm_apic_update_irr(vcpu, vmx->pi_desc.pir, &max_irr);
+ */
 bool kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir, int *max_irr)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 	bool irr_updated = __kvm_apic_update_irr(pir, apic->regs, max_irr);
 
+	/*
+	 * 在以下使用kvm_lapic->irr_pending:
+	 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+	 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+	 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+	 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+	 *
+	 * 理论上来说:
+	 * irr_pending is always true when apicv is activated.
+	 */
 	if (unlikely(!vcpu->arch.apicv_active && irr_updated))
 		apic->irr_pending = true;
 	return irr_updated;
@@ -534,6 +841,21 @@ static inline int apic_find_highest_irr(struct kvm_lapic *apic)
 {
 	int result;
 
+	/*
+	 * 在以下使用kvm_lapic->irr_pending:
+	 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+	 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+	 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+	 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+	 *
+	 * 理论上来说:
+	 * irr_pending is always true when apicv is activated.
+	 */
 	/*
 	 * Note that irr_pending is just a hint. It will be always
 	 * true with virtual interrupt delivery enabled.
@@ -559,6 +881,21 @@ static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)
 		static_call(kvm_x86_hwapic_irr_update)(vcpu,
 				apic_find_highest_irr(apic));
 	} else {
+		/*
+		 * 在以下使用kvm_lapic->irr_pending:
+		 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+		 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+		 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+		 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+		 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+		 *
+		 * 理论上来说:
+		 * irr_pending is always true when apicv is activated.
+		 */
 		apic->irr_pending = false;
 		kvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);
 		if (apic_search_irr(apic) != -1)
@@ -572,6 +909,10 @@ void kvm_apic_clear_irr(struct kvm_vcpu *vcpu, int vec)
 }
 EXPORT_SYMBOL_GPL(kvm_apic_clear_irr);
 
+/*
+ * 只在以下调用apic_set_isr():
+ *   - arch/x86/kvm/lapic.c|2870| <<kvm_get_apic_interrupt>> apic_set_isr(vector, apic);
+ */
 static inline void apic_set_isr(int vec, struct kvm_lapic *apic)
 {
 	struct kvm_vcpu *vcpu;
@@ -586,11 +927,34 @@ static inline void apic_set_isr(int vec, struct kvm_lapic *apic)
 	 * because the processor can modify ISR under the hood.  Instead
 	 * just set SVI.
 	 */
+	/*
+	 * vmx_hwapic_isr_update()
+	 */
 	if (unlikely(vcpu->arch.apicv_active))
 		static_call(kvm_x86_hwapic_isr_update)(vcpu, vec);
 	else {
+		/*
+		 * 在以下使用kvm_lapic->isr_count:
+		 *   - arch/x86/kvm/lapic.c|657| <<apic_set_isr>> ++apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|658| <<apic_set_isr>> BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+		 *   - arch/x86/kvm/lapic.c|684| <<apic_find_highest_isr>> if (!apic->isr_count)
+		 *   - arch/x86/kvm/lapic.c|718| <<apic_clear_isr>> --apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|719| <<apic_clear_isr>> BUG_ON(apic->isr_count < 0);
+		 *   - arch/x86/kvm/lapic.c|2631| <<kvm_apic_update_apicv>> apic->isr_count = 1;
+		 *   - arch/x86/kvm/lapic.c|2639| <<kvm_apic_update_apicv>> apic->isr_count = count_vectors(apic->regs + APIC_ISR);
+		 */
 		++apic->isr_count;
 		BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+		/*
+		 * 在以下使用kvm_lapic->highest_isr_cache:
+		 *   - arch/x86/kvm/lapic.c|675| <<apic_set_isr>> apic->highest_isr_cache = vec;
+		 *   - arch/x86/kvm/lapic.c|697| <<apic_find_highest_isr>> if (likely(apic->highest_isr_cache != -1))
+		 *   - arch/x86/kvm/lapic.c|698| <<apic_find_highest_isr>> return apic->highest_isr_cache;
+		 *   - arch/x86/kvm/lapic.c|734| <<apic_clear_isr>> apic->highest_isr_cache = -1;
+		 *   - arch/x86/kvm/lapic.c|2669| <<kvm_apic_update_apicv>> apic->highest_isr_cache = -1;
+		 *   - arch/x86/kvm/lapic.c|3170| <<apic_sync_pv_eoi_to_guest>> apic->highest_isr_cache == -1 ||
+		 *   - arch/x86/kvm/lapic.c|3172| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+		 */
 		/*
 		 * ISR (in service register) bit is set when injecting an interrupt.
 		 * The highest vector is injected. Thus the latest bit set matches
@@ -600,6 +964,14 @@ static inline void apic_set_isr(int vec, struct kvm_lapic *apic)
 	}
 }
 
+/*
+ * 在以下调用apic_find_highest_isr():
+ *   - arch/x86/kvm/lapic.c|700| <<apic_clear_isr>> apic_find_highest_isr(apic));
+ *   - arch/x86/kvm/lapic.c|858| <<__apic_update_ppr>> isr = apic_find_highest_isr(apic);
+ *   - arch/x86/kvm/lapic.c|1486| <<apic_set_eoi>> int vector = apic_find_highest_isr(apic);
+ *   - arch/x86/kvm/lapic.c|2963| <<kvm_apic_set_state>> apic_find_highest_isr(apic));
+ *   - arch/x86/kvm/lapic.c|3097| <<kvm_lapic_sync_to_vapic>> max_isr = apic_find_highest_isr(apic);
+ */
 static inline int apic_find_highest_isr(struct kvm_lapic *apic)
 {
 	int result;
@@ -608,8 +980,28 @@ static inline int apic_find_highest_isr(struct kvm_lapic *apic)
 	 * Note that isr_count is always 1, and highest_isr_cache
 	 * is always -1, with APIC virtualization enabled.
 	 */
+	/*
+	 * 在以下使用kvm_lapic->isr_count:
+	 *   - arch/x86/kvm/lapic.c|657| <<apic_set_isr>> ++apic->isr_count;
+	 *   - arch/x86/kvm/lapic.c|658| <<apic_set_isr>> BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+	 *   - arch/x86/kvm/lapic.c|684| <<apic_find_highest_isr>> if (!apic->isr_count)
+	 *   - arch/x86/kvm/lapic.c|718| <<apic_clear_isr>> --apic->isr_count;
+	 *   - arch/x86/kvm/lapic.c|719| <<apic_clear_isr>> BUG_ON(apic->isr_count < 0);
+	 *   - arch/x86/kvm/lapic.c|2631| <<kvm_apic_update_apicv>> apic->isr_count = 1;
+	 *   - arch/x86/kvm/lapic.c|2639| <<kvm_apic_update_apicv>> apic->isr_count = count_vectors(apic->regs + APIC_ISR);
+	 */
 	if (!apic->isr_count)
 		return -1;
+	/*
+	 * 在以下使用kvm_lapic->highest_isr_cache:
+	 *   - arch/x86/kvm/lapic.c|675| <<apic_set_isr>> apic->highest_isr_cache = vec;
+	 *   - arch/x86/kvm/lapic.c|697| <<apic_find_highest_isr>> if (likely(apic->highest_isr_cache != -1))
+	 *   - arch/x86/kvm/lapic.c|698| <<apic_find_highest_isr>> return apic->highest_isr_cache;
+	 *   - arch/x86/kvm/lapic.c|734| <<apic_clear_isr>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|2669| <<kvm_apic_update_apicv>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|3170| <<apic_sync_pv_eoi_to_guest>> apic->highest_isr_cache == -1 ||
+	 *   - arch/x86/kvm/lapic.c|3172| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+	 */
 	if (likely(apic->highest_isr_cache != -1))
 		return apic->highest_isr_cache;
 
@@ -619,6 +1011,10 @@ static inline int apic_find_highest_isr(struct kvm_lapic *apic)
 	return result;
 }
 
+/*
+ * 在以下使用apic_clear_isr():
+ *   - arch/x86/kvm/lapic.c|1497| <<apic_set_eoi>> apic_clear_isr(vector, apic);
+ */
 static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)
 {
 	struct kvm_vcpu *vcpu;
@@ -627,6 +1023,29 @@ static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)
 
 	vcpu = apic->vcpu;
 
+	/*
+	 * 在以下设置kvm_vcpu_arch->apicv_active:
+	 *   - arch/x86/kvm/x86.c|9800| <<kvm_vcpu_update_apicv>> vcpu->arch.apicv_active = activate;
+	 *   - arch/x86/kvm/x86.c|11393| <<kvm_arch_vcpu_create>> vcpu->arch.apicv_active = true;
+	 * 在以下使用kvm_vcpu_arch->apicv_active:
+	 *   - arch/x86/kvm/lapic.c|553| <<kvm_apic_update_irr>> if (unlikely(!vcpu->arch.apicv_active && irr_updated))
+	 *   - arch/x86/kvm/lapic.c|602| <<apic_clear_irr>> if (unlikely(vcpu->arch.apicv_active)) {
+	 *   - arch/x86/kvm/lapic.c|654| <<apic_set_isr>> if (unlikely(vcpu->arch.apicv_active))
+	 *   - arch/x86/kvm/lapic.c|714| <<apic_clear_isr>> if (unlikely(vcpu->arch.apicv_active))
+	 *   - arch/x86/kvm/lapic.c|1827| <<lapic_timer_int_injected>> if (vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/lapic.c|1944| <<apic_timer_expired>> if (!from_timer_fn && vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|2613| <<kvm_apic_update_apicv>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|2703| <<kvm_lapic_reset>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|3003| <<kvm_apic_set_state>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.h|241| <<kvm_vcpu_apicv_active>> return vcpu->arch.apic && vcpu->arch.apicv_active;
+	 *   - arch/x86/kvm/svm/svm.c|3661| <<svm_complete_interrupt_delivery>> if (!READ_ONCE(vcpu->arch.apicv_active)) {
+	 *   - arch/x86/kvm/vmx/vmx.c|4114| <<vmx_deliver_posted_interrupt>> if (!vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|9241| <<update_cr8_intercept>> if (vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|9797| <<kvm_vcpu_update_apicv>> if (vcpu->arch.apicv_active == activate)
+	 *   - arch/x86/kvm/x86.c|9810| <<kvm_vcpu_update_apicv>> if (!vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|12441| <<kvm_arch_dy_has_pending_interrupt>> if (vcpu->arch.apicv_active &&
+	 *          static_call(kvm_x86_dy_apicv_has_pending_interrupt)(vcpu))
+	 */
 	/*
 	 * We do get here for APIC virtualization enabled if the guest
 	 * uses the Hyper-V APIC enlightenment.  In this case we may need
@@ -634,16 +1053,44 @@ static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)
 	 * on the other hand isr_count and highest_isr_cache are unused
 	 * and must be left alone.
 	 */
+	/*
+	 * vmx_hwapic_isr_update()
+	 */
 	if (unlikely(vcpu->arch.apicv_active))
 		static_call(kvm_x86_hwapic_isr_update)(vcpu,
 						apic_find_highest_isr(apic));
 	else {
+		/*
+		 * 在以下使用kvm_lapic->isr_count:
+		 *   - arch/x86/kvm/lapic.c|657| <<apic_set_isr>> ++apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|658| <<apic_set_isr>> BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+		 *   - arch/x86/kvm/lapic.c|684| <<apic_find_highest_isr>> if (!apic->isr_count)
+		 *   - arch/x86/kvm/lapic.c|718| <<apic_clear_isr>> --apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|719| <<apic_clear_isr>> BUG_ON(apic->isr_count < 0);
+		 *   - arch/x86/kvm/lapic.c|2631| <<kvm_apic_update_apicv>> apic->isr_count = 1;
+		 *   - arch/x86/kvm/lapic.c|2639| <<kvm_apic_update_apicv>> apic->isr_count = count_vectors(apic->regs + APIC_ISR);
+		 */
 		--apic->isr_count;
 		BUG_ON(apic->isr_count < 0);
+		/*
+		 * 在以下使用kvm_lapic->highest_isr_cache:
+		 *   - arch/x86/kvm/lapic.c|675| <<apic_set_isr>> apic->highest_isr_cache = vec;
+		 *   - arch/x86/kvm/lapic.c|697| <<apic_find_highest_isr>> if (likely(apic->highest_isr_cache != -1))
+		 *   - arch/x86/kvm/lapic.c|698| <<apic_find_highest_isr>> return apic->highest_isr_cache;
+		 *   - arch/x86/kvm/lapic.c|734| <<apic_clear_isr>> apic->highest_isr_cache = -1;
+		 *   - arch/x86/kvm/lapic.c|2669| <<kvm_apic_update_apicv>> apic->highest_isr_cache = -1;
+		 *   - arch/x86/kvm/lapic.c|3170| <<apic_sync_pv_eoi_to_guest>> apic->highest_isr_cache == -1 ||
+		 *   - arch/x86/kvm/lapic.c|3172| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+		 */
 		apic->highest_isr_cache = -1;
 	}
 }
 
+/*
+ * 在以下使用kvm_lapic_find_highest_irr():
+ *   - arch/x86/kvm/vmx/vmx.c|6502| <<vmx_sync_pir_to_irr>> max_irr = kvm_lapic_find_highest_irr(vcpu);
+ *   - arch/x86/kvm/x86.c|9245| <<update_cr8_intercept>> max_irr = kvm_lapic_find_highest_irr(vcpu);
+ */
 int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)
 {
 	/* This may race with setting of irr in __apic_accept_irq() and
@@ -735,6 +1182,18 @@ static int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)
 
 static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)
 {
+	/*
+	 *     pv_eoi = {
+	 *       msr_val = 0,
+	 *        data = {
+	 *          generation = 0,
+	 *          gpa = 0,
+	 *          hva = 0,
+	 *          len = 0,
+	 *          memslot = 0x0
+	 *        }
+	 *     },
+	 */
 	return vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;
 }
 
@@ -766,6 +1225,9 @@ static void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)
 static int apic_has_interrupt_for_ppr(struct kvm_lapic *apic, u32 ppr)
 {
 	int highest_irr;
+	/*
+	 * vmx_sync_pir_to_irr()
+	 */
 	if (kvm_x86_ops.sync_pir_to_irr)
 		highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
 	else
@@ -775,6 +1237,12 @@ static int apic_has_interrupt_for_ppr(struct kvm_lapic *apic, u32 ppr)
 	return highest_irr;
 }
 
+/*
+ * 在以下使用__apic_update_ppr():
+ *   - arch/x86/kvm/lapic.c|1266| <<apic_update_ppr>> if (__apic_update_ppr(apic, &ppr) &&
+ *   - arch/x86/kvm/lapic.c|3587| <<kvm_apic_has_interrupt>> __apic_update_ppr(apic, &ppr);
+ *   - arch/x86/kvm/lapic.c|3672| <<kvm_get_apic_interrupt>> __apic_update_ppr(apic, &ppr);
+ */
 static bool __apic_update_ppr(struct kvm_lapic *apic, u32 *new_ppr)
 {
 	u32 tpr, isrv, ppr, old_ppr;
@@ -891,6 +1359,15 @@ static u32 kvm_apic_mda(struct kvm_vcpu *vcpu, unsigned int dest_id,
 {
 	bool ipi = source != NULL;
 
+	/*
+	 * 在以下使用kvm_arch->x2apic_broadcast_quirk_disabled:
+	 *   - arch/x86/kvm/lapic.c|1356| <<kvm_apic_mda>> if (!vcpu->kvm->arch.x2apic_broadcast_quirk_disabled &&
+	 *   - arch/x86/kvm/lapic.c|1435| <<kvm_apic_is_broadcast_dest>> if (kvm->arch.x2apic_broadcast_quirk_disabled) {
+	 *   - arch/x86/kvm/x86.c|5935| <<kvm_vm_ioctl_enable_cap>> kvm->arch.x2apic_broadcast_quirk_disabled = true;
+	 *
+	 *     x2apic_format = false,
+	 *     x2apic_broadcast_quirk_disabled = false,
+	 */
 	if (!vcpu->kvm->arch.x2apic_broadcast_quirk_disabled &&
 	    !ipi && dest_id == APIC_BROADCAST && apic_x2apic_mode(target))
 		return X2APIC_BROADCAST;
@@ -898,6 +1375,25 @@ static u32 kvm_apic_mda(struct kvm_vcpu *vcpu, unsigned int dest_id,
 	return dest_id;
 }
 
+/*
+ * 在以下调用kvm_apic_match_dest():
+ *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+ *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+ *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+ *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+ *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+ *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+ *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+ *          irq->shorthand, irq->dest_id, irq->dest_mode))
+ *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+ *          irq->shorthand, irq->dest_id, irq->dest_mode))
+ *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+ *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+ *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+ *          irq->shorthand, irq->dest_id, irq->dest_mode))
+ *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+ *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+ */
 bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,
 			   int shorthand, unsigned int dest, int dest_mode)
 {
@@ -951,6 +1447,15 @@ static void kvm_apic_disabled_lapic_found(struct kvm *kvm)
 static bool kvm_apic_is_broadcast_dest(struct kvm *kvm, struct kvm_lapic **src,
 		struct kvm_lapic_irq *irq, struct kvm_apic_map *map)
 {
+	/*
+	 * 在以下使用kvm_arch->x2apic_broadcast_quirk_disabled:
+	 *   - arch/x86/kvm/lapic.c|1356| <<kvm_apic_mda>> if (!vcpu->kvm->arch.x2apic_broadcast_quirk_disabled &&
+	 *   - arch/x86/kvm/lapic.c|1435| <<kvm_apic_is_broadcast_dest>> if (kvm->arch.x2apic_broadcast_quirk_disabled) {
+	 *   - arch/x86/kvm/x86.c|5935| <<kvm_vm_ioctl_enable_cap>> kvm->arch.x2apic_broadcast_quirk_disabled = true;
+	 *
+	 *     x2apic_format = false,
+	 *     x2apic_broadcast_quirk_disabled = false,
+	 */
 	if (kvm->arch.x2apic_broadcast_quirk_disabled) {
 		if ((irq->dest_id == APIC_BROADCAST &&
 				map->mode != KVM_APIC_MODE_X2APIC))
@@ -1119,6 +1624,54 @@ bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,
 	return ret;
 }
 
+/*
+ * 其他的:
+ * __apic_accept_irq
+ * __pv_send_ipi
+ * kvm_pv_send_ipi
+ * kvm_emulate_hypercall
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __apic_accept_irq
+ * kvm_irq_delivery_to_apic
+ * kvm_apic_send_ipi
+ * kvm_x2apic_icr_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
+/*
+ * 关于RESCHEDULE_VECTOR (0xfd)
+ *
+ * __apic_accept_irq
+ * kvm_irq_delivery_to_apic_fast
+ * kvm_irq_delivery_to_apic
+ * kvm_apic_send_ipi
+ * kvm_x2apic_icr_write
+ * handle_fastpath_set_msr_irqoff
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 /*
  * Add a pending IRQ into lapic.
  * Return 1 if successfully added and 0 if discarded.
@@ -1252,6 +1805,25 @@ void kvm_bitmap_or_dest_vcpus(struct kvm *kvm, struct kvm_lapic_irq *irq,
 		kvm_for_each_vcpu(i, vcpu, kvm) {
 			if (!kvm_apic_present(vcpu))
 				continue;
+			/*
+			 * 在以下调用kvm_apic_match_dest():
+			 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+			 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+			 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+			 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+			 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+			 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+			 */
 			if (!kvm_apic_match_dest(vcpu, NULL,
 						 irq->shorthand,
 						 irq->dest_id,
@@ -1268,11 +1840,32 @@ int kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)
 	return vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;
 }
 
+/*
+ * 在以下使用kvm_ioapic_handles_vector():
+ *   - arch/x86/kvm/lapic.c|1397| <<kvm_ioapic_send_eoi>> if (!kvm_ioapic_handles_vector(apic, vector))
+ *   - arch/x86/kvm/lapic.c|2972| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+ */
 static bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)
 {
+	/*
+	 * 在以下使用kvm_vcpu_arch->ioapic_handled_vectors:
+	 *   - arch/x86/kvm/lapic.c|1273| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9840| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+	 *   - arch/x86/kvm/x86.c|9845| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9847| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9864| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,
+	 *              to_hv_synic(vcpu)->vec_bitmap, 256);
+	 *   - arch/x86/kvm/x86.c|9871| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10004| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+	 */
 	return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
 }
 
+/*
+ * 在以下调用kvm_ioapic_send_eoi():
+ *   - arch/x86/kvm/lapic.c|1435| <<apic_set_eoi>> kvm_ioapic_send_eoi(apic, vector);
+ *   - arch/x86/kvm/lapic.c|1450| <<kvm_apic_set_eoi_accelerated>> kvm_ioapic_send_eoi(apic, vector);
+ */
 static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)
 {
 	int trigger_mode;
@@ -1296,6 +1889,11 @@ static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)
 	kvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);
 }
 
+/*
+ * 在以下使用apic_set_eoi():
+ *   - arch/x86/kvm/lapic.c|2274| <<kvm_lapic_reg_write>> apic_set_eoi(apic);
+ *   - arch/x86/kvm/lapic.c|3015| <<apic_sync_pv_eoi_from_guest>> vector = apic_set_eoi(apic);
+ */
 static int apic_set_eoi(struct kvm_lapic *apic)
 {
 	int vector = apic_find_highest_isr(apic);
@@ -1309,6 +1907,9 @@ static int apic_set_eoi(struct kvm_lapic *apic)
 	if (vector == -1)
 		return vector;
 
+	/*
+	 * 只在此处调用apic_clear_isr()
+	 */
 	apic_clear_isr(vector, apic);
 	apic_update_ppr(apic);
 
@@ -1523,6 +2124,17 @@ static int apic_mmio_read(struct kvm_vcpu *vcpu, struct kvm_io_device *this,
 	if (!apic_mmio_in_range(apic, address))
 		return -EOPNOTSUPP;
 
+	/*
+	 * 在以下调用kvm_apic_hw_enabled():
+	 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+	 *   - arch/x86/kvm/lapic.c|2040| <<apic_mmio_read>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2125| <<lapic_timer_int_injected>> if (kvm_apic_hw_enabled(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2809| <<apic_mmio_write>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|3330| <<kvm_apic_local_deliver>> if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
+	 *   - arch/x86/kvm/lapic.c|3443| <<kvm_apic_accept_pic_intr>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 *   - arch/x86/kvm/lapic.h|246| <<kvm_apic_present>> return lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
+	 *   - arch/x86/kvm/x86.c|10218| <<vcpu_load_eoi_exitmap>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 */
 	if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
 		if (!kvm_check_has_quirk(vcpu->kvm,
 					 KVM_X86_QUIRK_LAPIC_MMIO_HOLE))
@@ -1608,6 +2220,17 @@ static bool lapic_timer_int_injected(struct kvm_vcpu *vcpu)
 	struct kvm_lapic *apic = vcpu->arch.apic;
 	u32 reg = kvm_lapic_get_reg(apic, APIC_LVTT);
 
+	/*
+	 * 在以下调用kvm_apic_hw_enabled():
+	 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+	 *   - arch/x86/kvm/lapic.c|2040| <<apic_mmio_read>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2125| <<lapic_timer_int_injected>> if (kvm_apic_hw_enabled(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2809| <<apic_mmio_write>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|3330| <<kvm_apic_local_deliver>> if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
+	 *   - arch/x86/kvm/lapic.c|3443| <<kvm_apic_accept_pic_intr>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 *   - arch/x86/kvm/lapic.h|246| <<kvm_apic_present>> return lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
+	 *   - arch/x86/kvm/x86.c|10218| <<vcpu_load_eoi_exitmap>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 */
 	if (kvm_apic_hw_enabled(apic)) {
 		int vec = reg & APIC_VECTOR_MASK;
 		void *bitmap = apic->regs + APIC_ISR;
@@ -2033,6 +2656,10 @@ void kvm_lapic_switch_to_sw_timer(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_lapic_switch_to_sw_timer);
 
+/*
+ * 在以下使用kvm_lapic_restart_hv_timer():
+ *   - arch/x86/kvm/x86.c|4546| <<kvm_arch_vcpu_load>> kvm_lapic_restart_hv_timer(vcpu);
+ */
 void kvm_lapic_restart_hv_timer(struct kvm_vcpu *vcpu)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
@@ -2070,6 +2697,44 @@ static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)
 	}
 }
 
+/*
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_vcpu_reset
+ * kvm_apic_accept_events
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_lapic_reg_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ *
+ * 在以下调用kvm_lapic_reg_write():
+ *   - arch/x86/kvm/lapic.c|2638| <<apic_mmio_write>> kvm_lapic_reg_write(apic, offset & 0xff0, val);
+ *   - arch/x86/kvm/lapic.c|2645| <<kvm_lapic_set_eoi>> kvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);
+ *   - arch/x86/kvm/lapic.c|2667| <<kvm_apic_write_nodecode>> kvm_lapic_reg_write(apic, offset, (u32)val);
+ *   - arch/x86/kvm/lapic.c|3496| <<kvm_lapic_msr_write>> return kvm_lapic_reg_write(apic, reg, (u32)data);
+ *   - arch/x86/kvm/svm/avic.c|665| <<avic_unaccel_trap_write>> kvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));
+ */
 int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 {
 	int ret = 0;
@@ -2079,6 +2744,12 @@ int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 	switch (reg) {
 	case APIC_ID:		/* Local APIC ID */
 		if (!apic_x2apic_mode(apic)) {
+			/*
+			 * 在以下使用kvm_apic_set_xapic_id():
+			 *   - arch/x86/kvm/lapic.c|2455| <<kvm_lapic_reg_write(APIC_ID)>> kvm_apic_set_xapic_id(apic, val >> 24);
+			 *   - arch/x86/kvm/lapic.c|2756| <<kvm_lapic_set_base>> kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
+			 *   - arch/x86/kvm/lapic.c|2871| <<kvm_lapic_reset>> kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
+			 */
 			kvm_apic_set_xapic_id(apic, val >> 24);
 		} else {
 			ret = 1;
@@ -2155,6 +2826,15 @@ int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 		size_t size;
 		u32 index;
 
+		/*
+		 * 在以下使用kvm_apic_sw_enabled():
+		 *   - arch/x86/kvm/irq_comm.c|95| <<kvm_irq_delivery_to_apic>> } else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {
+		 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+		 *   - arch/x86/kvm/lapic.c|424| <<kvm_recalculate_apic_map>> if (!kvm_apic_sw_enabled(apic))
+		 *   - arch/x86/kvm/lapic.c|2720| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+		 *   - arch/x86/kvm/lapic.c|2731| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+		 *   - arch/x86/kvm/lapic.h|251| <<kvm_lapic_enabled>> return kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);
+		 */
 		if (!kvm_apic_sw_enabled(apic))
 			val |= APIC_LVT_MASKED;
 		size = ARRAY_SIZE(apic_lvt_mask);
@@ -2166,6 +2846,15 @@ int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 	}
 
 	case APIC_LVTT:
+		/*
+		 * 在以下使用kvm_apic_sw_enabled():
+		 *   - arch/x86/kvm/irq_comm.c|95| <<kvm_irq_delivery_to_apic>> } else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {
+		 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+		 *   - arch/x86/kvm/lapic.c|424| <<kvm_recalculate_apic_map>> if (!kvm_apic_sw_enabled(apic))
+		 *   - arch/x86/kvm/lapic.c|2720| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+		 *   - arch/x86/kvm/lapic.c|2731| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+		 *   - arch/x86/kvm/lapic.h|251| <<kvm_lapic_enabled>> return kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);
+		 */
 		if (!kvm_apic_sw_enabled(apic))
 			val |= APIC_LVT_MASKED;
 		val &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);
@@ -2220,6 +2909,14 @@ int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 	 * was toggled, the APIC ID changed, etc...   The maps are marked dirty
 	 * on relevant changes, i.e. this is a nop for most writes.
 	 */
+	/*
+	 * 在以下调用kvm_recalculate_apic_map():
+	 *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+	 */
 	kvm_recalculate_apic_map(apic->vcpu->kvm);
 
 	return ret;
@@ -2236,6 +2933,17 @@ static int apic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,
 	if (!apic_mmio_in_range(apic, address))
 		return -EOPNOTSUPP;
 
+	/*
+	 * 在以下调用kvm_apic_hw_enabled():
+	 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+	 *   - arch/x86/kvm/lapic.c|2040| <<apic_mmio_read>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2125| <<lapic_timer_int_injected>> if (kvm_apic_hw_enabled(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2809| <<apic_mmio_write>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|3330| <<kvm_apic_local_deliver>> if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
+	 *   - arch/x86/kvm/lapic.c|3443| <<kvm_apic_accept_pic_intr>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 *   - arch/x86/kvm/lapic.h|246| <<kvm_apic_present>> return lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
+	 *   - arch/x86/kvm/x86.c|10218| <<vcpu_load_eoi_exitmap>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 */
 	if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
 		if (!kvm_check_has_quirk(vcpu->kvm,
 					 KVM_X86_QUIRK_LAPIC_MMIO_HOLE))
@@ -2254,6 +2962,14 @@ static int apic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,
 
 	val = *(u32*)data;
 
+	/*
+	 * 在以下调用kvm_lapic_reg_write():
+	 *   - arch/x86/kvm/lapic.c|2638| <<apic_mmio_write>> kvm_lapic_reg_write(apic, offset & 0xff0, val);
+	 *   - arch/x86/kvm/lapic.c|2645| <<kvm_lapic_set_eoi>> kvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);
+	 *   - arch/x86/kvm/lapic.c|2667| <<kvm_apic_write_nodecode>> kvm_lapic_reg_write(apic, offset, (u32)val);
+	 *   - arch/x86/kvm/lapic.c|3496| <<kvm_lapic_msr_write>> return kvm_lapic_reg_write(apic, reg, (u32)data);
+	 *   - arch/x86/kvm/svm/avic.c|665| <<avic_unaccel_trap_write>> kvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));
+	 */
 	kvm_lapic_reg_write(apic, offset & 0xff0, val);
 
 	return 0;
@@ -2261,6 +2977,14 @@ static int apic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,
 
 void kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)
 {
+	/*
+	 * 在以下调用kvm_lapic_reg_write():
+	 *   - arch/x86/kvm/lapic.c|2638| <<apic_mmio_write>> kvm_lapic_reg_write(apic, offset & 0xff0, val);
+	 *   - arch/x86/kvm/lapic.c|2645| <<kvm_lapic_set_eoi>> kvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);
+	 *   - arch/x86/kvm/lapic.c|2667| <<kvm_apic_write_nodecode>> kvm_lapic_reg_write(apic, offset, (u32)val);
+	 *   - arch/x86/kvm/lapic.c|3496| <<kvm_lapic_msr_write>> return kvm_lapic_reg_write(apic, reg, (u32)data);
+	 *   - arch/x86/kvm/svm/avic.c|665| <<avic_unaccel_trap_write>> kvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));
+	 */
 	kvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);
 }
 EXPORT_SYMBOL_GPL(kvm_lapic_set_eoi);
@@ -2283,6 +3007,14 @@ void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)
 	} else {
 		/* TODO: optimize to just emulate side effect w/o one more write */
 		val = kvm_lapic_get_reg(apic, offset);
+		/*
+		 * 在以下调用kvm_lapic_reg_write():
+		 *   - arch/x86/kvm/lapic.c|2638| <<apic_mmio_write>> kvm_lapic_reg_write(apic, offset & 0xff0, val);
+		 *   - arch/x86/kvm/lapic.c|2645| <<kvm_lapic_set_eoi>> kvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);
+		 *   - arch/x86/kvm/lapic.c|2667| <<kvm_apic_write_nodecode>> kvm_lapic_reg_write(apic, offset, (u32)val);
+		 *   - arch/x86/kvm/lapic.c|3496| <<kvm_lapic_msr_write>> return kvm_lapic_reg_write(apic, reg, (u32)data);
+		 *   - arch/x86/kvm/svm/avic.c|665| <<avic_unaccel_trap_write>> kvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));
+		 */
 		kvm_lapic_reg_write(apic, offset, (u32)val);
 	}
 }
@@ -2300,6 +3032,13 @@ void kvm_free_lapic(struct kvm_vcpu *vcpu)
 	if (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))
 		static_branch_slow_dec_deferred(&apic_hw_disabled);
 
+	/*
+	 * 在以下使用kvm_lapic->sw_enabled:
+	 *   - arch/x86/kvm/lapic.c|474| <<apic_set_spiv>> if (enabled != apic->sw_enabled) {
+	 *   - arch/x86/kvm/lapic.c|475| <<apic_set_spiv>> apic->sw_enabled = enabled;
+	 *   - arch/x86/kvm/lapic.c|2899| <<kvm_free_lapic>> if (!apic->sw_enabled)
+	 *   - arch/x86/kvm/lapic.h|260| <<kvm_apic_sw_enabled>> return apic->sw_enabled;
+	 */
 	if (!apic->sw_enabled)
 		static_branch_slow_dec_deferred(&apic_sw_disabled);
 
@@ -2350,13 +3089,135 @@ u64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)
 	return (tpr & 0xf0) >> 4;
 }
 
+/*
+ * virsh hot-add的时候一共调用五次.
+ *
+ * 185171  185801  CPU 17/KVM      kvm_lapic_set_base
+ * 185171  185801  CPU 17/KVM      kvm_lapic_set_base
+ * 185171  185801  CPU 17/KVM      kvm_lapic_set_base
+ * 185171  185801  CPU 17/KVM      kvm_lapic_set_base
+ * 185171  185801  CPU 17/KVM      kvm_lapic_set_base
+ *
+ * kvm_lapic_set_base
+ * kvm_lapic_reset
+ * kvm_vcpu_reset
+ * kvm_arch_vcpu_create
+ * kvm_vm_ioctl_create_vcpu
+ * kvm_vm_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * kvm_lapic_set_base
+ * kvm_set_apic_base
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_arch_vcpu_ioctl
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * kvm_lapic_set_base
+ * kvm_set_apic_base
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * kvm_lapic_set_base
+ * kvm_set_apic_base
+ * __set_sregs_common.constprop.0
+ * kvm_arch_vcpu_ioctl
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * kvm_lapic_set_base
+ * kvm_apic_set_state
+ * kvm_arch_vcpu_ioctl
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ *
+ * 这是另外的一组.
+ *
+ * kvm_lapic_set_base
+ * kvm_set_apic_base
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_arch_vcpu_ioctl
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * kvm_lapic_set_base
+ * kvm_set_apic_base
+ * __set_sregs_common.constprop.0
+ * kvm_arch_vcpu_ioctl
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * kvm_lapic_set_base
+ * kvm_set_apic_base
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * kvm_lapic_set_base
+ * kvm_apic_set_state
+ * kvm_arch_vcpu_ioctl
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ *
+ * 在以下使用kvm_lapic_set_base():
+ *   - arch/x86/kvm/lapic.c|2661| <<kvm_lapic_reset>> kvm_lapic_set_base(vcpu, msr_val);
+ *   - arch/x86/kvm/lapic.c|2989| <<kvm_apic_set_state>> kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
+ *   - arch/x86/kvm/x86.c|492| <<kvm_set_apic_base>> kvm_lapic_set_base(vcpu, msr_info->data);
+ */
 void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)
 {
 	u64 old_value = vcpu->arch.apic_base;
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
+	/*
+	 * 在以下设置kvm_vcpu_arch->apic_base (看似修改的地方):
+	 *   - arch/x86/kvm/lapic.c|2926| <<kvm_lapic_set_base>> vcpu->arch.apic_base = value;
+	 *   - arch/x86/kvm/lapic.c|3256| <<kvm_create_lapic>> vcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;
+	 *
+	 * struct kvm_vcpu:
+	 * -> struct kvm_vcpu_arch arch;
+	 *    -> u64 apic_base;
+	 */
 	vcpu->arch.apic_base = value;
 
+	/*
+	 * 如果新旧不同的bit里有MSR_IA32_APICBASE_ENABLE ...
+	 */
 	if ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE)
 		kvm_update_cpuid_runtime(vcpu);
 
@@ -2365,13 +3226,35 @@ void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)
 
 	/* update jump label if enable bit changes */
 	if ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {
+		/*
+		 * 如果新的value是enable
+		 */
 		if (value & MSR_IA32_APICBASE_ENABLE) {
+			/*
+			 * 在以下使用kvm_apic_set_xapic_id():
+			 *   - arch/x86/kvm/lapic.c|2455| <<kvm_lapic_reg_write(APIC_ID)>> kvm_apic_set_xapic_id(apic, val >> 24);
+			 *   - arch/x86/kvm/lapic.c|2756| <<kvm_lapic_set_base>> kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
+			 *   - arch/x86/kvm/lapic.c|2871| <<kvm_lapic_reset>> kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
+			 */
 			kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
 			static_branch_slow_dec_deferred(&apic_hw_disabled);
 			/* Check if there are APF page ready requests pending */
 			kvm_make_request(KVM_REQ_APF_READY, vcpu);
 		} else {
 			static_branch_inc(&apic_hw_disabled.key);
+			/*
+			 * 在以下使用kvm_arch->apic_map_dirty:
+			 *   - arch/x86/kvm/lapic.c|279| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+			 *   - arch/x86/kvm/lapic.c|290| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty,
+			 *   - arch/x86/kvm/lapic.c|378| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty,
+			 *   - arch/x86/kvm/lapic.c|401| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|441| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|447| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|453| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|496| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|2862| <<kvm_lapic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 *   - arch/x86/kvm/lapic.c|3370| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+			 */
 			atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 		}
 	}
@@ -2394,13 +3277,44 @@ void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)
 	}
 }
 
+/*
+ * 在以下使用kvm_apic_update_apicv():
+ *   - arch/x86/kvm/lapic.c|2828| <<kvm_lapic_reset>> kvm_apic_update_apicv(vcpu);
+ *   - arch/x86/kvm/lapic.c|3192| <<kvm_apic_set_state>> kvm_apic_update_apicv(vcpu);
+ *   - arch/x86/kvm/x86.c|9877| <<kvm_vcpu_update_apicv>> kvm_apic_update_apicv(vcpu);
+ */
 void kvm_apic_update_apicv(struct kvm_vcpu *vcpu)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
 	if (vcpu->arch.apicv_active) {
+		/*
+		 * 在以下使用kvm_lapic->irr_pending:
+		 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+		 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+		 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+		 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+		 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+		 *
+		 * 理论上来说:
+		 * irr_pending is always true when apicv is activated.
+		 */
 		/* irr_pending is always true when apicv is activated. */
 		apic->irr_pending = true;
+		/*
+		 * 在以下使用kvm_lapic->isr_count:
+		 *   - arch/x86/kvm/lapic.c|657| <<apic_set_isr>> ++apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|658| <<apic_set_isr>> BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+		 *   - arch/x86/kvm/lapic.c|684| <<apic_find_highest_isr>> if (!apic->isr_count)
+		 *   - arch/x86/kvm/lapic.c|718| <<apic_clear_isr>> --apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|719| <<apic_clear_isr>> BUG_ON(apic->isr_count < 0);
+		 *   - arch/x86/kvm/lapic.c|2631| <<kvm_apic_update_apicv>> apic->isr_count = 1;
+		 *   - arch/x86/kvm/lapic.c|2639| <<kvm_apic_update_apicv>> apic->isr_count = count_vectors(apic->regs + APIC_ISR);
+		 */
 		apic->isr_count = 1;
 	} else {
 		/*
@@ -2411,16 +3325,33 @@ void kvm_apic_update_apicv(struct kvm_vcpu *vcpu)
 		 */
 		apic->isr_count = count_vectors(apic->regs + APIC_ISR);
 	}
+	/*
+	 * 在以下使用kvm_lapic->highest_isr_cache:
+	 *   - arch/x86/kvm/lapic.c|675| <<apic_set_isr>> apic->highest_isr_cache = vec;
+	 *   - arch/x86/kvm/lapic.c|697| <<apic_find_highest_isr>> if (likely(apic->highest_isr_cache != -1))
+	 *   - arch/x86/kvm/lapic.c|698| <<apic_find_highest_isr>> return apic->highest_isr_cache;
+	 *   - arch/x86/kvm/lapic.c|734| <<apic_clear_isr>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|2669| <<kvm_apic_update_apicv>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|3170| <<apic_sync_pv_eoi_to_guest>> apic->highest_isr_cache == -1 ||
+	 *   - arch/x86/kvm/lapic.c|3172| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+	 */
 	apic->highest_isr_cache = -1;
 }
 EXPORT_SYMBOL_GPL(kvm_apic_update_apicv);
 
+/*
+ * 在以下使用kvm_lapic_reset():
+ *  - arch/x86/kvm/x86.c|11672| <<kvm_vcpu_reset>> kvm_lapic_reset(vcpu, init_event);
+ */
 void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 	u64 msr_val;
 	int i;
 
+	/*
+	 * 只有kvm_arch_vcpu_create()的时候init_event是false
+	 */
 	if (!init_event) {
 		msr_val = APIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE;
 		if (kvm_vcpu_is_reset_bsp(vcpu))
@@ -2434,6 +3365,12 @@ void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)
 	/* Stop the timer in case it's a reset to an active apic */
 	hrtimer_cancel(&apic->lapic_timer.timer);
 
+	/*
+	 * 在以下使用kvm_apic_set_xapic_id():
+	 *   - arch/x86/kvm/lapic.c|2455| <<kvm_lapic_reg_write(APIC_ID)>> kvm_apic_set_xapic_id(apic, val >> 24);
+	 *   - arch/x86/kvm/lapic.c|2756| <<kvm_lapic_set_base>> kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
+	 *   - arch/x86/kvm/lapic.c|2871| <<kvm_lapic_reset>> kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
+	 */
 	/* The xAPIC ID is set at RESET even if the APIC was already enabled. */
 	if (!init_event)
 		kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
@@ -2467,6 +3404,12 @@ void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)
 		kvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);
 		kvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);
 	}
+	/*
+	 * 在以下使用kvm_apic_update_apicv():
+	 *   - arch/x86/kvm/lapic.c|2828| <<kvm_lapic_reset>> kvm_apic_update_apicv(vcpu);
+	 *   - arch/x86/kvm/lapic.c|3192| <<kvm_apic_set_state>> kvm_apic_update_apicv(vcpu);
+	 *   - arch/x86/kvm/x86.c|9877| <<kvm_vcpu_update_apicv>> kvm_apic_update_apicv(vcpu);
+	 */
 	kvm_apic_update_apicv(vcpu);
 	update_divide_count(apic);
 	atomic_set(&apic->lapic_timer.pending, 0);
@@ -2474,14 +3417,43 @@ void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)
 	vcpu->arch.pv_eoi.msr_val = 0;
 	apic_update_ppr(apic);
 	if (vcpu->arch.apicv_active) {
+		/*
+		 * vmx_apicv_post_state_restore()
+		 */
 		static_call(kvm_x86_apicv_post_state_restore)(vcpu);
+		/*
+		 * vmx_hwapic_irr_update()
+		 */
 		static_call(kvm_x86_hwapic_irr_update)(vcpu, -1);
+		/*
+		 * vmx_hwapic_isr_update()
+		 */
 		static_call(kvm_x86_hwapic_isr_update)(vcpu, -1);
 	}
 
 	vcpu->arch.apic_arb_prio = 0;
 	vcpu->arch.apic_attention = 0;
 
+	/*
+	 * __kvm_set_or_clear_apicv_inhibit
+	 * __kvm_set_or_clear_apicv_inhibit
+	 * kvm_set_or_clear_apicv_inhibit
+	 * kvm_recalculate_apic_map
+	 * kvm_vcpu_reset
+	 * kvm_apic_accept_events
+	 * kvm_arch_vcpu_ioctl_run
+	 * kvm_vcpu_ioctl
+	 * __x64_sys_ioctl
+	 * do_syscall_64
+	 * entry_SYSCALL_64_after_hwframe
+	 *
+	 * 在以下调用kvm_recalculate_apic_map():
+	 *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+	 */
 	kvm_recalculate_apic_map(vcpu->kvm);
 }
 
@@ -2512,6 +3484,17 @@ int kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)
 	int vector, mode, trig_mode;
 	int r;
 
+	/*
+	 * 在以下调用kvm_apic_hw_enabled():
+	 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+	 *   - arch/x86/kvm/lapic.c|2040| <<apic_mmio_read>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2125| <<lapic_timer_int_injected>> if (kvm_apic_hw_enabled(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2809| <<apic_mmio_write>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|3330| <<kvm_apic_local_deliver>> if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
+	 *   - arch/x86/kvm/lapic.c|3443| <<kvm_apic_accept_pic_intr>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 *   - arch/x86/kvm/lapic.h|246| <<kvm_apic_present>> return lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
+	 *   - arch/x86/kvm/x86.c|10218| <<vcpu_load_eoi_exitmap>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 */
 	if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
 		vector = reg & APIC_VECTOR_MASK;
 		mode = reg & APIC_MODE_MASK;
@@ -2601,6 +3584,13 @@ int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)
 	return -ENOMEM;
 }
 
+/*
+ * 在以下使用kvm_apic_has_interrupt():
+ *   - arch/x86/kvm/irq.c|86| <<kvm_cpu_has_injectable_intr>> return kvm_apic_has_interrupt(v) != -1;
+ *   - arch/x86/kvm/irq.c|99| <<kvm_cpu_has_interrupt>> return kvm_apic_has_interrupt(v) != -1;
+ *   - arch/x86/kvm/lapic.c|2841| <<kvm_get_apic_interrupt>> int vector = kvm_apic_has_interrupt(vcpu);
+ *   - arch/x86/kvm/vmx/nested.c|3627| <<nested_vmx_run>> kvm_apic_has_interrupt(vcpu) == vmx->nested.posted_intr_nv) {
+ */
 int kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
@@ -2618,6 +3608,17 @@ int kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)
 {
 	u32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);
 
+	/*
+	 * 在以下调用kvm_apic_hw_enabled():
+	 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+	 *   - arch/x86/kvm/lapic.c|2040| <<apic_mmio_read>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2125| <<lapic_timer_int_injected>> if (kvm_apic_hw_enabled(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2809| <<apic_mmio_write>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|3330| <<kvm_apic_local_deliver>> if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
+	 *   - arch/x86/kvm/lapic.c|3443| <<kvm_apic_accept_pic_intr>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 *   - arch/x86/kvm/lapic.h|246| <<kvm_apic_present>> return lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
+	 *   - arch/x86/kvm/x86.c|10218| <<vcpu_load_eoi_exitmap>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 */
 	if (!kvm_apic_hw_enabled(vcpu->arch.apic))
 		return 1;
 	if ((lvt0 & APIC_LVT_MASKED) == 0 &&
@@ -2636,8 +3637,19 @@ void kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)
 	}
 }
 
+/*
+ * 在以下调用kvm_get_apic_interrupt():
+ *   - arch/x86/kvm/irq.c|138| <<kvm_cpu_get_interrupt>> return kvm_get_apic_interrupt(v);
+ */
 int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)
 {
+	/*
+	 * 在以下使用kvm_apic_has_interrupt():
+	 *   - arch/x86/kvm/irq.c|86| <<kvm_cpu_has_injectable_intr>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/irq.c|99| <<kvm_cpu_has_interrupt>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/lapic.c|2841| <<kvm_get_apic_interrupt>> int vector = kvm_apic_has_interrupt(vcpu);
+	 *   - arch/x86/kvm/vmx/nested.c|3627| <<nested_vmx_run>> kvm_apic_has_interrupt(vcpu) == vmx->nested.posted_intr_nv) {
+	 */
 	int vector = kvm_apic_has_interrupt(vcpu);
 	struct kvm_lapic *apic = vcpu->arch.apic;
 	u32 ppr;
@@ -2667,6 +3679,10 @@ int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)
 		 * a concurrent interrupt injection, but that would have
 		 * triggered KVM_REQ_EVENT already.
 		 */
+		/*
+		 * 这里set了ISR!
+		 * 只在这一个地方调用
+		 */
 		apic_set_isr(vector, apic);
 		__apic_update_ppr(apic, &ppr);
 	}
@@ -2674,6 +3690,16 @@ int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)
 	return vector;
 }
 
+/*
+ * 在以下调用kvm_apic_state_fixup():
+ *   - arch/x86/kvm/lapic.c|3114| <<kvm_apic_get_state>> return kvm_apic_state_fixup(vcpu, s, false);
+ *   - arch/x86/kvm/lapic.c|3136| <<kvm_apic_set_state>> r = kvm_apic_state_fixup(vcpu, s, true);
+ *
+ * #define KVM_APIC_REG_SIZE 0x400
+ * struct kvm_lapic_state {
+ *     char regs[KVM_APIC_REG_SIZE];
+ * };
+ */
 static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,
 		struct kvm_lapic_state *s, bool set)
 {
@@ -2682,6 +3708,17 @@ static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,
 		u32 *ldr = (u32 *)(s->regs + APIC_LDR);
 		u64 icr;
 
+		/*
+		 * 在以下使用kvm_arch->x2apic_format:
+		 *   - arch/x86/kvm/irq_comm.c|137| <<kvm_set_msi_irq>> trace_kvm_msi_set_irq(msg.address_lo | (kvm->arch.x2apic_format ?
+		 *   - arch/x86/kvm/irq_comm.c|140| <<kvm_set_msi_irq>> irq->dest_id = x86_msi_msg_get_destid(&msg, kvm->arch.x2apic_format);
+		 *   - arch/x86/kvm/irq_comm.c|154| <<kvm_msi_route_invalid>> return kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);
+		 *   - arch/x86/kvm/lapic.c|3673| <<kvm_apic_state_fixup>> if (vcpu->kvm->arch.x2apic_format) {
+		 *   - arch/x86/kvm/x86.c|5933| <<kvm_vm_ioctl_enable_cap>> kvm->arch.x2apic_format = true;
+		 *
+		 *     x2apic_format = false,
+		 *     x2apic_broadcast_quirk_disabled = false,
+		 */
 		if (vcpu->kvm->arch.x2apic_format) {
 			if (*id != vcpu->vcpu_id)
 				return -EINVAL;
@@ -2723,26 +3760,106 @@ int kvm_apic_get_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 	__kvm_lapic_set_reg(s->regs, APIC_TMCCT,
 			    __apic_read(vcpu->arch.apic, APIC_TMCCT));
 
+	/*
+	 * 在以下调用kvm_apic_state_fixup():
+	 *   - arch/x86/kvm/lapic.c|3114| <<kvm_apic_get_state>> return kvm_apic_state_fixup(vcpu, s, false);
+	 *   - arch/x86/kvm/lapic.c|3136| <<kvm_apic_set_state>> r = kvm_apic_state_fixup(vcpu, s, true);
+	 */
 	return kvm_apic_state_fixup(vcpu, s, false);
 }
 
+/*
+ * 在以下使用kvm_apic_set_state():
+ *   - arch/x86/kvm/x86.c|4654| <<kvm_vcpu_ioctl_set_lapic>> r = kvm_apic_set_state(vcpu, s);
+ *
+ * 根据测试, 只在add的时候调用:
+ * kvm_apic_set_state
+ * kvm_arch_vcpu_ioctl
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * kvm_arch_vcpu_ioctl(KVM_SET_LAPIC)
+ * -> kvm_vcpu_ioctl_set_lapic()
+ *    -> kvm_apic_set_state()
+ *       -> kvm_recalculate_apic_map() -> 只有kvm_apic_state_fixup() > 0的时候
+ *       -> kvm_recalculate_apic_map()
+ */
 int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 	int r;
 
+	/*
+	 * 在以下设置kvm_vcpu_arch->apic_base (看似修改的地方):
+	 *   - arch/x86/kvm/lapic.c|2926| <<kvm_lapic_set_base>> vcpu->arch.apic_base = value;
+	 *   - arch/x86/kvm/lapic.c|3256| <<kvm_create_lapic>> vcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;
+	 *
+	 *
+	 * 在以下使用kvm_lapic_set_base():
+	 *   - arch/x86/kvm/lapic.c|2661| <<kvm_lapic_reset>> kvm_lapic_set_base(vcpu, msr_val);
+	 *   - arch/x86/kvm/lapic.c|2989| <<kvm_apic_set_state>> kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
+	 *   - arch/x86/kvm/x86.c|492| <<kvm_set_apic_base>> kvm_lapic_set_base(vcpu, msr_info->data);
+	 *
+	 * 这一行在2024年被删掉了.
+	 * 8166d25579120590ad0ec4ece02afd00a3c54f6a
+	 * KVM: x86: Drop superfluous kvm_lapic_set_base() call when setting APIC state
+	 */
 	kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
+	/*
+	 * #define KVM_APIC_REG_SIZE 0x400
+	 * struct kvm_lapic_state {
+	 *     char regs[KVM_APIC_REG_SIZE];
+	 * };
+	 */
 	/* set SPIV separately to get count of SW disabled APICs right */
 	apic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));
 
+	/*
+	 * 在以下调用kvm_apic_state_fixup():
+	 *   - arch/x86/kvm/lapic.c|3114| <<kvm_apic_get_state>> return kvm_apic_state_fixup(vcpu, s, false);
+	 *   - arch/x86/kvm/lapic.c|3136| <<kvm_apic_set_state>> r = kvm_apic_state_fixup(vcpu, s, true);
+	 *
+	 * 这里fix的是s里面的!
+	 */
 	r = kvm_apic_state_fixup(vcpu, s, true);
 	if (r) {
+		/*
+		 * 在以下调用kvm_recalculate_apic_map():
+		 *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+		 *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+		 *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+		 *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+		 *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+		 */
 		kvm_recalculate_apic_map(vcpu->kvm);
 		return r;
 	}
 	memcpy(vcpu->arch.apic->regs, s->regs, sizeof(*s));
 
+	/*
+	 * 在以下使用kvm_arch->apic_map_dirty:
+	 *   - arch/x86/kvm/lapic.c|279| <<kvm_recalculate_apic_map>> if (atomic_read_acquire(&kvm->arch.apic_map_dirty) == CLEAN)
+	 *   - arch/x86/kvm/lapic.c|290| <<kvm_recalculate_apic_map>> if (atomic_cmpxchg_acquire(&kvm->arch.apic_map_dirty,
+	 *   - arch/x86/kvm/lapic.c|378| <<kvm_recalculate_apic_map>> atomic_cmpxchg_release(&kvm->arch.apic_map_dirty,
+	 *   - arch/x86/kvm/lapic.c|401| <<apic_set_spiv>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|441| <<kvm_apic_set_xapic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|447| <<kvm_apic_set_ldr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|453| <<kvm_apic_set_dfr>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|496| <<kvm_apic_set_x2apic_id>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|2862| <<kvm_lapic_set_base>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 *   - arch/x86/kvm/lapic.c|3370| <<kvm_apic_set_state>> atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	 */
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	/*
+	 * 在以下调用kvm_recalculate_apic_map():
+	 *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+	 */
 	kvm_recalculate_apic_map(vcpu->kvm);
 	kvm_apic_set_version(vcpu);
 
@@ -2754,11 +3871,26 @@ int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 	update_divide_count(apic);
 	__start_apic_timer(apic, APIC_TMCCT);
 	kvm_lapic_set_reg(apic, APIC_TMCCT, 0);
+	/*
+	 * 在以下使用kvm_apic_update_apicv():
+	 *   - arch/x86/kvm/lapic.c|2828| <<kvm_lapic_reset>> kvm_apic_update_apicv(vcpu);
+	 *   - arch/x86/kvm/lapic.c|3192| <<kvm_apic_set_state>> kvm_apic_update_apicv(vcpu);
+	 *   - arch/x86/kvm/x86.c|9877| <<kvm_vcpu_update_apicv>> kvm_apic_update_apicv(vcpu);
+	 */
 	kvm_apic_update_apicv(vcpu);
 	if (vcpu->arch.apicv_active) {
+		/*
+		 * vmx_apicv_post_state_restore()
+		 */
 		static_call(kvm_x86_apicv_post_state_restore)(vcpu);
+		/*
+		 * vmx_hwapic_irr_update()
+		 */
 		static_call(kvm_x86_hwapic_irr_update)(vcpu,
 				apic_find_highest_irr(apic));
+		/*
+		 * vmx_hwapic_isr_update()
+		 */
 		static_call(kvm_x86_hwapic_isr_update)(vcpu,
 				apic_find_highest_isr(apic));
 	}
@@ -2847,6 +3979,21 @@ void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
 static void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,
 					struct kvm_lapic *apic)
 {
+	/*
+	 * 在以下使用kvm_lapic->irr_pending:
+	 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+	 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+	 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+	 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+	 *
+	 * 理论上来说:
+	 * irr_pending is always true when apicv is activated.
+	 */
 	if (!pv_eoi_enabled(vcpu) ||
 	    /* IRR set or many bits in ISR: could be nested. */
 	    apic->irr_pending ||
@@ -2945,6 +4092,14 @@ static int kvm_lapic_msr_write(struct kvm_lapic *apic, u32 reg, u64 data)
 	if (data >> 32)
 		return 1;
 
+	/*
+	 * 在以下调用kvm_lapic_reg_write():
+	 *   - arch/x86/kvm/lapic.c|2638| <<apic_mmio_write>> kvm_lapic_reg_write(apic, offset & 0xff0, val);
+	 *   - arch/x86/kvm/lapic.c|2645| <<kvm_lapic_set_eoi>> kvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);
+	 *   - arch/x86/kvm/lapic.c|2667| <<kvm_apic_write_nodecode>> kvm_lapic_reg_write(apic, offset, (u32)val);
+	 *   - arch/x86/kvm/lapic.c|3496| <<kvm_lapic_msr_write>> return kvm_lapic_reg_write(apic, reg, (u32)data);
+	 *   - arch/x86/kvm/svm/avic.c|665| <<avic_unaccel_trap_write>> kvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));
+	 */
 	return kvm_lapic_reg_write(apic, reg, (u32)data);
 }
 
@@ -3058,6 +4213,12 @@ int kvm_apic_accept_events(struct kvm_vcpu *vcpu)
 
 	if (test_bit(KVM_APIC_INIT, &pe)) {
 		clear_bit(KVM_APIC_INIT, &apic->pending_events);
+		/*
+		 * 在以下使用:
+		 *   - arch/x86/kvm/lapic.c|3537| <<kvm_apic_accept_events>> kvm_vcpu_reset(vcpu, true);
+		 *   - arch/x86/kvm/svm/svm.c|2230| <<shutdown_interception>> kvm_vcpu_reset(vcpu, true);
+		 *   - arch/x86/kvm/x86.c|11655| <<kvm_arch_vcpu_create>> kvm_vcpu_reset(vcpu, false);
+		 */
 		kvm_vcpu_reset(vcpu, true);
 		if (kvm_vcpu_is_bsp(apic->vcpu))
 			vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;
diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h
index ee42eef92f32..41ea5efc2e34 100644
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@ -49,11 +49,53 @@ struct kvm_lapic {
 	struct kvm_timer lapic_timer;
 	u32 divide_count;
 	struct kvm_vcpu *vcpu;
+	/*
+	 * 在以下使用kvm_lapic->sw_enabled:
+	 *   - arch/x86/kvm/lapic.c|474| <<apic_set_spiv>> if (enabled != apic->sw_enabled) {
+	 *   - arch/x86/kvm/lapic.c|475| <<apic_set_spiv>> apic->sw_enabled = enabled;
+	 *   - arch/x86/kvm/lapic.c|2899| <<kvm_free_lapic>> if (!apic->sw_enabled)
+	 *   - arch/x86/kvm/lapic.h|260| <<kvm_apic_sw_enabled>> return apic->sw_enabled;
+	 */
 	bool sw_enabled;
+	/*
+	 * 在以下使用kvm_lapic->irr_pending:
+	 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+	 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+	 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+	 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+	 *
+	 * 理论上来说:
+	 * irr_pending is always true when apicv is activated.
+	 */
 	bool irr_pending;
 	bool lvt0_in_nmi_mode;
+	/*
+	 * 在以下使用kvm_lapic->isr_count:
+	 *   - arch/x86/kvm/lapic.c|657| <<apic_set_isr>> ++apic->isr_count;
+	 *   - arch/x86/kvm/lapic.c|658| <<apic_set_isr>> BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+	 *   - arch/x86/kvm/lapic.c|684| <<apic_find_highest_isr>> if (!apic->isr_count)
+	 *   - arch/x86/kvm/lapic.c|718| <<apic_clear_isr>> --apic->isr_count;
+	 *   - arch/x86/kvm/lapic.c|719| <<apic_clear_isr>> BUG_ON(apic->isr_count < 0);
+	 *   - arch/x86/kvm/lapic.c|2631| <<kvm_apic_update_apicv>> apic->isr_count = 1;
+	 *   - arch/x86/kvm/lapic.c|2639| <<kvm_apic_update_apicv>> apic->isr_count = count_vectors(apic->regs + APIC_ISR);
+	 */
 	/* Number of bits set in ISR. */
 	s16 isr_count;
+	/*
+	 * 在以下使用kvm_lapic->highest_isr_cache:
+	 *   - arch/x86/kvm/lapic.c|675| <<apic_set_isr>> apic->highest_isr_cache = vec;
+	 *   - arch/x86/kvm/lapic.c|697| <<apic_find_highest_isr>> if (likely(apic->highest_isr_cache != -1))
+	 *   - arch/x86/kvm/lapic.c|698| <<apic_find_highest_isr>> return apic->highest_isr_cache;
+	 *   - arch/x86/kvm/lapic.c|734| <<apic_clear_isr>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|2669| <<kvm_apic_update_apicv>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|3170| <<apic_sync_pv_eoi_to_guest>> apic->highest_isr_cache == -1 ||
+	 *   - arch/x86/kvm/lapic.c|3172| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+	 */
 	/* The highest vector set in ISR; if -1 - invalid, must scan ISR. */
 	int highest_isr_cache;
 	/**
@@ -147,6 +189,21 @@ static inline void kvm_lapic_set_vector(int vec, void *bitmap)
 static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)
 {
 	kvm_lapic_set_vector(vec, apic->regs + APIC_IRR);
+	/*
+	 * 在以下使用kvm_lapic->irr_pending:
+	 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+	 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+	 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+	 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+	 *
+	 * 理论上来说:
+	 * irr_pending is always true when apicv is activated.
+	 */
 	/*
 	 * irr_pending must be true if any interrupt is pending; set it after
 	 * APIC_IRR to avoid race with apic_clear_irr
@@ -173,10 +230,56 @@ static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)
 	return true;
 }
 
+/*
+ * | 项目                 | MSR_IA32_APICBASE       | SPIV (0xF0)                |
+ * | ------------------ | ------------------------- | -------------------------- |
+ * | 控制粒度               | 硬件级,全局关闭                  | 软件级,关闭中断处理                 |
+ * | 生效范围               | 关闭整个 Local APIC           | 保留结构但不响应中断                 |
+ * | 通常使用时机             | BIOS,操作系统启动阶段             | 操作系统运行时                    |
+ * | 会影响 APIC MMIO 寄存器吗 | 是,APIC 基址无效后不能访问 APIC 寄存器 | 否,仍然可访问 APIC 寄存器           |
+ * | 对中断的影响             | 完全禁用中断(包括 INIT, STARTUP)  | 仅禁用普通中断,某些特殊中断(如 NMI)有效    |
+ * | 典型用途               | 内核初始化前设置,关闭 SMP 支持        | 操作系统禁用中断(如使用 IOAPIC 或 PIC) |
+ *
+ *
+ * 如果你只把SPIV 的使能位关掉(即SPIV[8]=0),CPU不会响应普通中断,但Local APIC结构还在,
+ * 依然可以接收INIT或IPI等特殊信号.
+ *
+ * 如果你把MSR_IA32_APICBASE[11]=0,则整个Local APIC被禁用,APIC MMIO区也不能访问,
+ * 连 INIT,STARTUP都可能无法正确使用.
+ */
+
 extern struct static_key_false_deferred apic_hw_disabled;
 
+/*
+ * 在以下调用kvm_apic_hw_enabled():
+ *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+ *   - arch/x86/kvm/lapic.c|2040| <<apic_mmio_read>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+ *   - arch/x86/kvm/lapic.c|2125| <<lapic_timer_int_injected>> if (kvm_apic_hw_enabled(apic)) {
+ *   - arch/x86/kvm/lapic.c|2809| <<apic_mmio_write>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+ *   - arch/x86/kvm/lapic.c|3330| <<kvm_apic_local_deliver>> if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
+ *   - arch/x86/kvm/lapic.c|3443| <<kvm_apic_accept_pic_intr>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+ *   - arch/x86/kvm/lapic.h|246| <<kvm_apic_present>> return lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
+ *   - arch/x86/kvm/x86.c|10218| <<vcpu_load_eoi_exitmap>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+ */
 static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)
 {
+	/*
+	 * 在以下设置kvm_vcpu_arch->apic_base (看似修改的地方):
+	 *   - arch/x86/kvm/lapic.c|2926| <<kvm_lapic_set_base>> vcpu->arch.apic_base = value;
+	 *   - arch/x86/kvm/lapic.c|3256| <<kvm_create_lapic>> vcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;
+	 * 在以下使用kvm_vcpu_arch->apic_base:
+	 *   - arch/x86/kvm/cpuid.c|222| <<__kvm_update_cpuid_runtime>> cpuid_entry_change(best, X86_FEATURE_APIC, vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE);
+	 *   - arch/x86/kvm/lapic.c|2862| <<kvm_free_lapic>> if (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))
+	 *   - arch/x86/kvm/lapic.c|2923| <<kvm_lapic_set_base>> u64 old_value = vcpu->arch.apic_base;
+	 *   - arch/x86/kvm/lapic.c|2974| <<kvm_lapic_set_base>> apic->base_address = apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_BASE;
+	 *   - arch/x86/kvm/lapic.c|3454| <<kvm_apic_set_state>> kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
+	 *   - arch/x86/kvm/lapic.h|231| <<kvm_apic_hw_enabled>> return apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;
+	 *   - arch/x86/kvm/lapic.h|256| <<apic_x2apic_mode>> return apic->vcpu->arch.apic_base & X2APIC_ENABLE;
+	 *   - arch/x86/kvm/lapic.h|300| <<kvm_apic_mode>> return apic_base & (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);
+	 *   - arch/x86/kvm/vmx/nested.c|878| <<nested_vmx_msr_check_common>> if (CC(vcpu->arch.apic_base & X2APIC_ENABLE && e->index >> 8 == 0x8))
+	 *   - arch/x86/kvm/x86.c|466| <<kvm_get_apic_base>> return vcpu->arch.apic_base;
+	 *   - arch/x86/kvm/x86.c|12215| <<kvm_vcpu_is_bsp>> return (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;
+	 */
 	if (static_branch_unlikely(&apic_hw_disabled.key))
 		return apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;
 	return MSR_IA32_APICBASE_ENABLE;
@@ -184,33 +287,151 @@ static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)
 
 extern struct static_key_false_deferred apic_sw_disabled;
 
+/*
+ * 在以下使用kvm_apic_sw_enabled():
+ *   - arch/x86/kvm/irq_comm.c|95| <<kvm_irq_delivery_to_apic>> } else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {
+ *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+ *   - arch/x86/kvm/lapic.c|424| <<kvm_recalculate_apic_map>> if (!kvm_apic_sw_enabled(apic))
+ *   - arch/x86/kvm/lapic.c|2720| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+ *   - arch/x86/kvm/lapic.c|2731| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+ *   - arch/x86/kvm/lapic.h|251| <<kvm_lapic_enabled>> return kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);
+ */
 static inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)
 {
+	/*
+	 * 在以下使用kvm_lapic->sw_enabled:
+	 *   - arch/x86/kvm/lapic.c|474| <<apic_set_spiv>> if (enabled != apic->sw_enabled) {
+	 *   - arch/x86/kvm/lapic.c|475| <<apic_set_spiv>> apic->sw_enabled = enabled;
+	 *   - arch/x86/kvm/lapic.c|2899| <<kvm_free_lapic>> if (!apic->sw_enabled)
+	 *   - arch/x86/kvm/lapic.h|260| <<kvm_apic_sw_enabled>> return apic->sw_enabled;
+	 */
 	if (static_branch_unlikely(&apic_sw_disabled.key))
 		return apic->sw_enabled;
 	return true;
 }
 
+/*
+ * | 项目                 | MSR_IA32_APICBASE       | SPIV (0xF0)                |
+ * | ------------------ | ------------------------- | -------------------------- |
+ * | 控制粒度               | 硬件级,全局关闭                  | 软件级,关闭中断处理                 |
+ * | 生效范围               | 关闭整个 Local APIC           | 保留结构但不响应中断                 |
+ * | 通常使用时机             | BIOS,操作系统启动阶段             | 操作系统运行时                    |
+ * | 会影响 APIC MMIO 寄存器吗 | 是,APIC 基址无效后不能访问 APIC 寄存器 | 否,仍然可访问 APIC 寄存器           |
+ * | 对中断的影响             | 完全禁用中断(包括 INIT, STARTUP)  | 仅禁用普通中断,某些特殊中断(如 NMI)有效    |
+ * | 典型用途               | 内核初始化前设置,关闭 SMP 支持        | 操作系统禁用中断(如使用 IOAPIC 或 PIC) |
+ *
+ *
+ * 如果你只把SPIV 的使能位关掉(即SPIV[8]=0),CPU不会响应普通中断,但Local APIC结构还在,
+ * 依然可以接收INIT或IPI等特殊信号.
+ *
+ * 如果你把MSR_IA32_APICBASE[11]=0,则整个Local APIC被禁用,APIC MMIO区也不能访问,
+ * 连 INIT,STARTUP都可能无法正确使用.
+ *
+ *
+ * 在以下调用kvm_apic_present():
+ *   - arch/x86/kvm/irq_comm.c|65| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_present(vcpu))
+ *   - arch/x86/kvm/irq_comm.c|384| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_present(vcpu))
+ *   - arch/x86/kvm/lapic.c|373| <<kvm_recalculate_apic_map>> if (kvm_apic_present(vcpu))
+ *   - arch/x86/kvm/lapic.c|393| <<kvm_recalculate_apic_map>> if (!kvm_apic_present(vcpu))
+ *   - arch/x86/kvm/lapic.c|1764| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_present(vcpu))
+ *   - arch/x86/kvm/lapic.c|2985| <<kvm_get_lapic_tscdeadline_msr>> if (!kvm_apic_present(vcpu) || !apic_lvtt_tscdeadline(apic))
+ *   - arch/x86/kvm/lapic.c|2995| <<kvm_set_lapic_tscdeadline_msr>> if (!kvm_apic_present(vcpu) || !apic_lvtt_tscdeadline(apic))
+ *   - arch/x86/kvm/lapic.c|3501| <<kvm_apic_has_interrupt>> if (!kvm_apic_present(vcpu))
+ *   - arch/x86/kvm/lapic.h|346| <<kvm_lapic_enabled>> return kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);
+ *   - arch/x86/kvm/x86.c|10149| <<vcpu_scan_ioapic>> if (!kvm_apic_present(vcpu))
+ */
 static inline bool kvm_apic_present(struct kvm_vcpu *vcpu)
 {
+	/*
+	 * 在以下调用kvm_apic_hw_enabled():
+	 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+	 *   - arch/x86/kvm/lapic.c|2040| <<apic_mmio_read>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2125| <<lapic_timer_int_injected>> if (kvm_apic_hw_enabled(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2809| <<apic_mmio_write>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|3330| <<kvm_apic_local_deliver>> if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
+	 *   - arch/x86/kvm/lapic.c|3443| <<kvm_apic_accept_pic_intr>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 *   - arch/x86/kvm/lapic.h|246| <<kvm_apic_present>> return lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
+	 *   - arch/x86/kvm/x86.c|10218| <<vcpu_load_eoi_exitmap>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 */
 	return lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
 }
 
+/*
+ * 在以下使用kvm_lapic_enabled():
+ *   - arch/x86/kvm/x86.c|10495| <<vcpu_enter_guest>> if (kvm_lapic_enabled(vcpu)) {
+ *   - arch/x86/kvm/x86.c|10555| <<vcpu_enter_guest>> if (kvm_lapic_enabled(vcpu))
+ *   - arch/x86/kvm/x86.c|10620| <<vcpu_enter_guest>> if (kvm_lapic_enabled(vcpu))
+ *   - arch/x86/kvm/x86.c|13109| <<kvm_arch_can_dequeue_async_page_present>> return kvm_lapic_enabled(vcpu) && apf_pageready_slot_free(vcpu);
+ */
 static inline int kvm_lapic_enabled(struct kvm_vcpu *vcpu)
 {
+	/*
+	 * 在以下使用kvm_apic_sw_enabled():
+	 *   - arch/x86/kvm/irq_comm.c|95| <<kvm_irq_delivery_to_apic>> } else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {
+	 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+	 *   - arch/x86/kvm/lapic.c|424| <<kvm_recalculate_apic_map>> if (!kvm_apic_sw_enabled(apic))
+	 *   - arch/x86/kvm/lapic.c|2720| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+	 *   - arch/x86/kvm/lapic.c|2731| <<kvm_lapic_reg_write>> if (!kvm_apic_sw_enabled(apic))
+	 *   - arch/x86/kvm/lapic.h|251| <<kvm_lapic_enabled>> return kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);
+	 */
 	return kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);
 }
 
 static inline int apic_x2apic_mode(struct kvm_lapic *apic)
 {
+	/*
+	 * 在以下设置kvm_vcpu_arch->apic_base (看似修改的地方):
+	 *   - arch/x86/kvm/lapic.c|2926| <<kvm_lapic_set_base>> vcpu->arch.apic_base = value;
+	 *   - arch/x86/kvm/lapic.c|3256| <<kvm_create_lapic>> vcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;
+	 * 在以下使用kvm_vcpu_arch->apic_base:
+	 *   - arch/x86/kvm/cpuid.c|222| <<__kvm_update_cpuid_runtime>> cpuid_entry_change(best, X86_FEATURE_APIC, vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE);
+	 *   - arch/x86/kvm/lapic.c|2862| <<kvm_free_lapic>> if (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))
+	 *   - arch/x86/kvm/lapic.c|2923| <<kvm_lapic_set_base>> u64 old_value = vcpu->arch.apic_base;
+	 *   - arch/x86/kvm/lapic.c|2974| <<kvm_lapic_set_base>> apic->base_address = apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_BASE;
+	 *   - arch/x86/kvm/lapic.c|3454| <<kvm_apic_set_state>> kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
+	 *   - arch/x86/kvm/lapic.h|231| <<kvm_apic_hw_enabled>> return apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;
+	 *   - arch/x86/kvm/lapic.h|256| <<apic_x2apic_mode>> return apic->vcpu->arch.apic_base & X2APIC_ENABLE;
+	 *   - arch/x86/kvm/lapic.h|300| <<kvm_apic_mode>> return apic_base & (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE);
+	 *   - arch/x86/kvm/vmx/nested.c|878| <<nested_vmx_msr_check_common>> if (CC(vcpu->arch.apic_base & X2APIC_ENABLE && e->index >> 8 == 0x8))
+	 *   - arch/x86/kvm/x86.c|466| <<kvm_get_apic_base>> return vcpu->arch.apic_base;
+	 *   - arch/x86/kvm/x86.c|12215| <<kvm_vcpu_is_bsp>> return (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;
+	 */
 	return apic->vcpu->arch.apic_base & X2APIC_ENABLE;
 }
 
+/*
+ * 在以下使用kvm_vcpu_apicv_active():
+ *   - arch/x86/kvm/irq.c|89| <<kvm_cpu_has_injectable_intr>> if (!is_guest_mode(v) && kvm_vcpu_apicv_active(v))
+ *   - arch/x86/kvm/lapic.c|221| <<kvm_can_post_timer_interrupt>> return pi_inject_timer && kvm_vcpu_apicv_active(vcpu) &&
+ *   - arch/x86/kvm/svm/avic.c|964| <<avic_pi_update_irte>> kvm_vcpu_apicv_active(&svm->vcpu)) {
+ *   - arch/x86/kvm/svm/avic.c|1183| <<avic_refresh_apicv_exec_ctrl>> bool activated = kvm_vcpu_apicv_active(vcpu);
+ *   - arch/x86/kvm/svm/avic.c|1213| <<avic_vcpu_blocking>> if (!kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/svm/avic.c|1234| <<avic_vcpu_unblocking>> if (!kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/svm/nested.c|728| <<enter_svm_guest_mode>> if (kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/svm/svm.c|1307| <<init_vmcb>> if (!kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/svm/svm.c|1422| <<init_vmcb>> if (kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/svm/svm.c|1618| <<svm_vcpu_load>> if (kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/svm/svm.c|1624| <<svm_vcpu_put>> if (kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/svm/svm.c|3946| <<sync_lapic_to_cr8>> kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/vmx/nested.c|3402| <<nested_vmx_enter_non_root_mode>> if (likely(!evaluate_pending_interrupts) && kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/vmx/vmx.c|3984| <<vmx_update_msr_bitmap_x2apic>> if (enable_apicv && kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/vmx/vmx.c|4256| <<vmx_pin_based_exec_ctrl>> if (!kvm_vcpu_apicv_active(&vmx->vcpu))
+ *   - arch/x86/kvm/vmx/vmx.c|4303| <<vmx_refresh_apicv_exec_ctrl>> if (kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/vmx/vmx.c|4418| <<vmx_secondary_exec_control>> if (!kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/vmx/vmx.c|4511| <<init_vmcs>> if (kvm_vcpu_apicv_active(&vmx->vcpu)) {
+ *   - arch/x86/kvm/vmx/vmx.c|6613| <<vmx_sync_pir_to_irr>> if (!is_guest_mode(vcpu) && kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/vmx/vmx.c|6630| <<vmx_load_eoi_exitmap>> if (!kvm_vcpu_apicv_active(vcpu))
+ *   - arch/x86/kvm/x86.c|10602| <<vcpu_enter_guest>> WARN_ON_ONCE((kvm_vcpu_apicv_activated(vcpu) != kvm_vcpu_apicv_active(vcpu)) &&
+ */
 static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)
 {
 	return vcpu->arch.apic && vcpu->arch.apicv_active;
 }
 
+/*
+ * 在以下使用kvm_apic_has_events():
+ *   - arch/x86/kvm/x86.c|12773| <<kvm_vcpu_has_events>> if (kvm_apic_has_events(vcpu))
+ */
 static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)
 {
 	return lapic_in_kernel(vcpu) && vcpu->arch.apic->pending_events;
diff --git a/arch/x86/kvm/svm/avic.c b/arch/x86/kvm/svm/avic.c
index df2d33395a48..ffe3def8d22a 100644
--- a/arch/x86/kvm/svm/avic.c
+++ b/arch/x86/kvm/svm/avic.c
@@ -458,6 +458,25 @@ static void avic_kick_target_vcpus(struct kvm *kvm, struct kvm_lapic *source,
 	 * since entered the guest will have processed pending IRQs at VMRUN.
 	 */
 	kvm_for_each_vcpu(i, vcpu, kvm) {
+		/*
+		 * 在以下调用kvm_apic_match_dest():
+		 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+		 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+		 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+		 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+		 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+		 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+		 */
 		if (kvm_apic_match_dest(vcpu, source, icrl & APIC_SHORT_MASK,
 					dest, icrl & APIC_DEST_MASK)) {
 			vcpu->arch.apic->irr_pending = true;
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index d0a0883599c5..65037ad747f5 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -2033,6 +2033,36 @@ static u64 vcpu_supported_debugctl(struct kvm_vcpu *vcpu)
 	return debugctl;
 }
 
+/*
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_vcpu_reset
+ * kvm_apic_accept_events
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_lapic_reg_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 /*
  * Writes msr value into the appropriate "register".
  * Returns 0 on success, non-0 otherwise.
@@ -5407,6 +5437,16 @@ static int handle_task_switch(struct kvm_vcpu *vcpu)
 			break;
 		case INTR_TYPE_EXT_INTR:
 		case INTR_TYPE_SOFT_INTR:
+			/*
+			 * 在以下调用kvm_clear_interrupt_queue():
+			 *   - arch/x86/kvm/svm/nested.c|1017| <<nested_svm_vmexit>> kvm_clear_interrupt_queue(vcpu);
+			 *   - arch/x86/kvm/svm/svm.c|2556| <<task_switch_interception>> kvm_clear_interrupt_queue(vcpu);
+			 *   - arch/x86/kvm/svm/svm.c|4012| <<svm_complete_interrupts>> kvm_clear_interrupt_queue(vcpu);
+			 *   - arch/x86/kvm/vmx/nested.c|4645| <<nested_vmx_vmexit>> kvm_clear_interrupt_queue(vcpu);
+			 *   - arch/x86/kvm/vmx/vmx.c|5440| <<handle_task_switch>> kvm_clear_interrupt_queue(vcpu);
+			 *   - arch/x86/kvm/vmx/vmx.c|6799| <<__vmx_complete_interrupts>> kvm_clear_interrupt_queue(vcpu);
+			 *   - arch/x86/kvm/x86.c|11947| <<kvm_vcpu_reset>> kvm_clear_interrupt_queue(vcpu);
+			 */
 			kvm_clear_interrupt_queue(vcpu);
 			break;
 		case INTR_TYPE_HARD_EXCEPTION:
@@ -5686,6 +5726,11 @@ static int handle_pml_full(struct kvm_vcpu *vcpu)
 	return 1;
 }
 
+/*
+ * 在以下调用handle_fastpath_preemption_timer():
+ *   - arch/x86/kvm/vmx/vmx.c|5704| <<handle_preemption_timer>> handle_fastpath_preemption_timer(vcpu);
+ *   - arch/x86/kvm/vmx/vmx.c|6875| <<vmx_exit_handlers_fastpath>> return handle_fastpath_preemption_timer(vcpu);
+ */
 static fastpath_t handle_fastpath_preemption_timer(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
@@ -6236,6 +6281,36 @@ static int __vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)
 	return 0;
 }
 
+/*
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_vcpu_reset
+ * kvm_apic_accept_events
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_lapic_reg_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 static int vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)
 {
 	int ret = __vmx_handle_exit(vcpu, exit_fastpath);
@@ -6422,6 +6497,30 @@ static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu)
 	put_page(page);
 }
 
+/*
+ * vmx_hwapic_isr_update
+  kvm_lapic_reset
+  kvm_vcpu_reset
+  kvm_apic_accept_events
+  kvm_arch_vcpu_ioctl_run
+  kvm_vcpu_ioctl
+  __x64_sys_ioctl
+  do_syscall_64
+  entry_SYSCALL_64_after_hwframe
+  [unknown]
+    2
+
+  vmx_hwapic_isr_update
+  kvm_apic_set_state
+  kvm_arch_vcpu_ioctl
+  kvm_vcpu_ioctl
+  __x64_sys_ioctl
+  do_syscall_64
+  entry_SYSCALL_64_after_hwframe
+  [unknown]
+ *
+ * struct kvm_x86_ops vmx_x86_ops.hwapic_isr_update = vmx_hwapic_isr_update()
+ */
 static void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)
 {
 	u16 status;
@@ -6456,6 +6555,9 @@ static void vmx_set_rvi(int vector)
 	}
 }
 
+/*
+ * struct kvm_x86_ops vmx_x86_opshwapic_irr_update = vmx_hwapic_irr_update()
+ */
 static void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)
 {
 	/*
@@ -6470,6 +6572,16 @@ static void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)
 		vmx_set_rvi(max_irr);
 }
 
+/*
+ * 在以下调用kvm_x86_sync_pir_to_irr()
+ *   - arch/x86/kvm/lapic.c|789| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+ *   - arch/x86/kvm/x86.c|4623| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ *   - arch/x86/kvm/x86.c|9842| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ *   - arch/x86/kvm/x86.c|10171| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ *   - arch/x86/kvm/x86.c|10220| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ *
+ * struct kvm_x86_ops vmx_x86_ops.sync_pir_to_irr = vmx_sync_pir_to_irr()
+ */
 static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
@@ -6516,6 +6628,13 @@ static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)
 	return max_irr;
 }
 
+/*
+ * 在以下调用kvm_x86_load_eoi_exitmap():
+ *   - arch/x86/kvm/x86.c|9921| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, eoi_exit_bitmap);
+ *   - arch/x86/kvm/x86.c|9928| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(
+ *
+ * 在以下使用struct kvm_x86_ops vmx_x86_ops.load_eoi_exitmap = vmx_load_eoi_exitmap()
+ */
 static void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
 {
 	if (!kvm_vcpu_apicv_active(vcpu))
@@ -6674,6 +6793,13 @@ static void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)
 					      vmx->loaded_vmcs->entry_time));
 }
 
+/*
+ * 在以下使用__vmx_complete_interrupts():
+ *   - arch/x86/kvm/vmx/vmx.c|6842| <<vmx_complete_interrupts>> __vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,
+ *                                        VM_EXIT_INSTRUCTION_LEN, IDT_VECTORING_ERROR_CODE);
+ *   - arch/x86/kvm/vmx/vmx.c|6849| <<vmx_cancel_injection>> __vmx_complete_interrupts(vcpu, vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),
+ *                                        VM_ENTRY_INSTRUCTION_LEN, VM_ENTRY_EXCEPTION_ERROR_CODE);
+ */
 static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,
 				      u32 idt_vectoring_info,
 				      int instr_len_field,
@@ -6686,6 +6812,16 @@ static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,
 	idtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;
 
 	vcpu->arch.nmi_injected = false;
+	/*
+	 * 在以下调用kvm_clear_interrupt_queue():
+	 *   - arch/x86/kvm/svm/nested.c|1017| <<nested_svm_vmexit>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/svm/svm.c|2556| <<task_switch_interception>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/svm/svm.c|4012| <<svm_complete_interrupts>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/vmx/nested.c|4645| <<nested_vmx_vmexit>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/vmx/vmx.c|5440| <<handle_task_switch>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/vmx/vmx.c|6799| <<__vmx_complete_interrupts>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/x86.c|11947| <<kvm_vcpu_reset>> kvm_clear_interrupt_queue(vcpu);
+	 */
 	kvm_clear_exception_queue(vcpu);
 	kvm_clear_interrupt_queue(vcpu);
 
@@ -6721,6 +6857,15 @@ static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,
 		vcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);
 		fallthrough;
 	case INTR_TYPE_EXT_INTR:
+		/*
+		 * 在以下使用kvm_queue_interrupt():
+		 *   - arch/x86/kvm/svm/svm.c|4045| <<svm_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, false);
+		 *   - arch/x86/kvm/svm/svm.c|4048| <<svm_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, true);
+		 *   - arch/x86/kvm/vmx/vmx.c|6768| <<__vmx_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);
+		 *   - arch/x86/kvm/x86.c|4713| <<kvm_vcpu_ioctl_interrupt>> kvm_queue_interrupt(vcpu, irq->irq, false);
+		 *   - arch/x86/kvm/x86.c|9490| <<inject_pending_event>> kvm_queue_interrupt(vcpu, irq, false);
+		 *   - arch/x86/kvm/x86.c|11223| <<__set_sregs>> kvm_queue_interrupt(vcpu, pending_vec, false);
+		 */
 		kvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);
 		break;
 	default:
@@ -6728,15 +6873,36 @@ static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,
 	}
 }
 
+/*
+ * 在以下使用vmx_complete_interrupts():
+ *   - arch/x86/kvm/vmx/vmx.c|7133| <<vmx_vcpu_run>> vmx_complete_interrupts(vmx);
+ */
 static void vmx_complete_interrupts(struct vcpu_vmx *vmx)
 {
+	/*
+	 * 在以下使用__vmx_complete_interrupts():
+	 *   - arch/x86/kvm/vmx/vmx.c|6842| <<vmx_complete_interrupts>> __vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,
+	 *                                        VM_EXIT_INSTRUCTION_LEN, IDT_VECTORING_ERROR_CODE);
+	 *   - arch/x86/kvm/vmx/vmx.c|6849| <<vmx_cancel_injection>> __vmx_complete_interrupts(vcpu, vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),
+	 *                                        VM_ENTRY_INSTRUCTION_LEN, VM_ENTRY_EXCEPTION_ERROR_CODE);
+	 */
 	__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,
 				  VM_EXIT_INSTRUCTION_LEN,
 				  IDT_VECTORING_ERROR_CODE);
 }
 
+/*
+ * struct kvm_x86_ops vmx_x86_ops.cancel_injection = vmx_cancel_injection()
+ */
 static void vmx_cancel_injection(struct kvm_vcpu *vcpu)
 {
+	/*
+	 * 在以下使用__vmx_complete_interrupts():
+	 *   - arch/x86/kvm/vmx/vmx.c|6842| <<vmx_complete_interrupts>> __vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,
+	 *                                        VM_EXIT_INSTRUCTION_LEN, IDT_VECTORING_ERROR_CODE);
+	 *   - arch/x86/kvm/vmx/vmx.c|6849| <<vmx_cancel_injection>> __vmx_complete_interrupts(vcpu, vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),
+	 *                                        VM_ENTRY_INSTRUCTION_LEN, VM_ENTRY_EXCEPTION_ERROR_CODE);
+	 */
 	__vmx_complete_interrupts(vcpu,
 				  vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),
 				  VM_ENTRY_INSTRUCTION_LEN,
@@ -6822,6 +6988,10 @@ void noinstr vmx_spec_ctrl_restore_host(struct vcpu_vmx *vmx,
 	barrier_nospec();
 }
 
+/*
+ * 在以下调用vmx_exit_handlers_fastpath():
+ *   - arch/x86/kvm/vmx/vmx.c|7069| <<vmx_vcpu_run>> return vmx_exit_handlers_fastpath(vcpu);
+ */
 static fastpath_t vmx_exit_handlers_fastpath(struct kvm_vcpu *vcpu)
 {
 	switch (to_vmx(vcpu)->exit_reason.basic) {
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 321af8f0e7ab..0c837051bffb 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -473,6 +473,11 @@ enum lapic_mode kvm_get_apic_mode(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_get_apic_mode);
 
+/*
+ * 在以下使用kvm_set_apic_base():
+ *   - arch/x86/kvm/x86.c|3471| <<kvm_set_msr_common(MSR_IA32_APICBASE)>> return kvm_set_apic_base(vcpu, msr_info);
+ *   - arch/x86/kvm/x86.c|11103| <<__set_sregs_common>> if (kvm_set_apic_base(vcpu, &apic_base_msr))
+ */
 int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 {
 	enum lapic_mode old_mode = kvm_get_apic_mode(vcpu);
@@ -490,6 +495,14 @@ int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 	}
 
 	kvm_lapic_set_base(vcpu, msr_info->data);
+	/*
+	 * 在以下调用kvm_recalculate_apic_map():
+	 *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+	 */
 	kvm_recalculate_apic_map(vcpu->kvm);
 	return 0;
 }
@@ -1732,6 +1745,36 @@ bool kvm_msr_allowed(struct kvm_vcpu *vcpu, u32 index, u32 type)
 }
 EXPORT_SYMBOL_GPL(kvm_msr_allowed);
 
+/*
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_vcpu_reset
+ * kvm_apic_accept_events
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_lapic_reg_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 /*
  * Write @data into the MSR specified by @index.  Select MSR specific fault
  * checks are bypassed if @host_initiated is %true.
@@ -1967,6 +2010,36 @@ int kvm_emulate_rdmsr(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_emulate_rdmsr);
 
+/*
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_vcpu_reset
+ * kvm_apic_accept_events
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_lapic_reg_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 int kvm_emulate_wrmsr(struct kvm_vcpu *vcpu)
 {
 	u32 ecx = kvm_rcx_read(vcpu);
@@ -2020,6 +2093,11 @@ int kvm_handle_invalid_op(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_handle_invalid_op);
 
+/*
+ * 在以下使用kvm_emulate_monitor():
+ *   - arch/x86/kvm/svm/svm.c|3312| <<global>> [SVM_EXIT_MONITOR] = kvm_emulate_monitor,
+ *   - arch/x86/kvm/vmx/vmx.c|5788| <<global>> [EXIT_REASON_MONITOR_INSTRUCTION] = kvm_emulate_monitor,
+ */
 int kvm_emulate_monitor(struct kvm_vcpu *vcpu)
 {
 	pr_warn_once("kvm: MONITOR instruction emulated as NOP!\n");
@@ -2027,6 +2105,11 @@ int kvm_emulate_monitor(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_emulate_monitor);
 
+/*
+ * 在以下调用kvm_vcpu_exit_request():
+ *   - arch/x86/kvm/x86.c|10386| <<vcpu_enter_guest(关于cancel_injection)>> if (kvm_vcpu_exit_request(vcpu)) {
+ *   - arch/x86/kvm/x86.c|10443| <<vcpu_enter_guest(关于EXIT_FASTPATH_EXIT_HANDLED)>> if (unlikely(kvm_vcpu_exit_request(vcpu))) {
+ */
 static inline bool kvm_vcpu_exit_request(struct kvm_vcpu *vcpu)
 {
 	xfer_to_guest_mode_prepare();
@@ -2041,6 +2124,10 @@ static inline bool kvm_vcpu_exit_request(struct kvm_vcpu *vcpu)
  * from guest to host, e.g. reacquiring KVM's SRCU lock. In contrast to the
  * other cases which must be called after interrupts are enabled on the host.
  */
+/*
+ * 在以下调用handle_fastpath_set_x2apic_icr_irqoff():
+ *   - arch/x86/kvm/x86.c|2089| <<handle_fastpath_set_msr_irqoff>> if (!handle_fastpath_set_x2apic_icr_irqoff(vcpu, data)) {
+ */
 static int handle_fastpath_set_x2apic_icr_irqoff(struct kvm_vcpu *vcpu, u64 data)
 {
 	if (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(vcpu->arch.apic))
@@ -2055,6 +2142,10 @@ static int handle_fastpath_set_x2apic_icr_irqoff(struct kvm_vcpu *vcpu, u64 data
 	return 1;
 }
 
+/*
+ * 在以下使用handle_fastpath_set_tscdeadline():
+ *   - arch/x86/kvm/x86.c|2096| <<handle_fastpath_set_msr_irqoff>> if (!handle_fastpath_set_tscdeadline(vcpu, data)) {
+ */
 static int handle_fastpath_set_tscdeadline(struct kvm_vcpu *vcpu, u64 data)
 {
 	if (!kvm_can_use_hv_timer(vcpu))
@@ -2064,6 +2155,11 @@ static int handle_fastpath_set_tscdeadline(struct kvm_vcpu *vcpu, u64 data)
 	return 0;
 }
 
+/*
+ * 在以下调用handle_fastpath_set_msr_irqoff():
+ *   - arch/x86/kvm/svm/svm.c|4077| <<svm_exit_handlers_fastpath>> return handle_fastpath_set_msr_irqoff(vcpu);
+ *   - arch/x86/kvm/vmx/vmx.c|6873| <<vmx_exit_handlers_fastpath>> return handle_fastpath_set_msr_irqoff(vcpu);
+ */
 fastpath_t handle_fastpath_set_msr_irqoff(struct kvm_vcpu *vcpu)
 {
 	u32 msr = kvm_rcx_read(vcpu);
@@ -4620,16 +4716,37 @@ void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
 static int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,
 				    struct kvm_lapic_state *s)
 {
+	/*
+	 * 在以下调用kvm_x86_sync_pir_to_irr()
+	 *   - arch/x86/kvm/lapic.c|789| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+	 *   - arch/x86/kvm/x86.c|4623| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|9842| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10171| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10220| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 */
 	static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
 	return kvm_apic_get_state(vcpu, s);
 }
 
+/*
+ * 在以下使用KVM_SET_LAPIC:
+ *   - arch/x86/kvm/x86.c|5200| <<kvm_arch_vcpu_ioctl(KVM_SET_LAPIC)>> r = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);
+ *
+ * kvm_arch_vcpu_ioctl(KVM_SET_LAPIC)
+ * -> kvm_vcpu_ioctl_set_lapic()
+ *    -> kvm_apic_set_state()
+ *       -> kvm_recalculate_apic_map() -> 只有kvm_apic_state_fixup() > 0的时候
+ *       -> kvm_recalculate_apic_map()
+ */
 static int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,
 				    struct kvm_lapic_state *s)
 {
 	int r;
 
+	/*
+	 * 只在此处调用
+	 */
 	r = kvm_apic_set_state(vcpu, s);
 	if (r)
 		return r;
@@ -4676,6 +4793,15 @@ static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,
 		return -EINVAL;
 
 	if (!irqchip_in_kernel(vcpu->kvm)) {
+		/*
+		 * 在以下使用kvm_queue_interrupt():
+		 *   - arch/x86/kvm/svm/svm.c|4045| <<svm_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, false);
+		 *   - arch/x86/kvm/svm/svm.c|4048| <<svm_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, true);
+		 *   - arch/x86/kvm/vmx/vmx.c|6768| <<__vmx_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);
+		 *   - arch/x86/kvm/x86.c|4713| <<kvm_vcpu_ioctl_interrupt>> kvm_queue_interrupt(vcpu, irq->irq, false);
+		 *   - arch/x86/kvm/x86.c|9490| <<inject_pending_event>> kvm_queue_interrupt(vcpu, irq, false);
+		 *   - arch/x86/kvm/x86.c|11223| <<__set_sregs>> kvm_queue_interrupt(vcpu, pending_vec, false);
+		 */
 		kvm_queue_interrupt(vcpu, irq->irq, false);
 		kvm_make_request(KVM_REQ_EVENT, vcpu);
 		return 0;
@@ -5176,6 +5302,13 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 			goto out_nofree;
 		}
 
+		/*
+		 * kvm_arch_vcpu_ioctl(KVM_SET_LAPIC)
+		 * -> kvm_vcpu_ioctl_set_lapic()
+		 *    -> kvm_apic_set_state()
+		 *       -> kvm_recalculate_apic_map() -> 只有kvm_apic_state_fixup() > 0的时候
+		 *       -> kvm_recalculate_apic_map()
+		 */
 		r = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);
 		break;
 	}
@@ -5805,8 +5938,28 @@ int kvm_vm_ioctl_enable_cap(struct kvm *kvm,
 		if (cap->args[0] & ~KVM_X2APIC_API_VALID_FLAGS)
 			break;
 
+		/*
+		 * 在以下使用kvm_arch->x2apic_format:
+		 *   - arch/x86/kvm/irq_comm.c|137| <<kvm_set_msi_irq>> trace_kvm_msi_set_irq(msg.address_lo | (kvm->arch.x2apic_format ?
+		 *   - arch/x86/kvm/irq_comm.c|140| <<kvm_set_msi_irq>> irq->dest_id = x86_msi_msg_get_destid(&msg, kvm->arch.x2apic_format);
+		 *   - arch/x86/kvm/irq_comm.c|154| <<kvm_msi_route_invalid>> return kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);
+		 *   - arch/x86/kvm/lapic.c|3673| <<kvm_apic_state_fixup>> if (vcpu->kvm->arch.x2apic_format) {
+		 *   - arch/x86/kvm/x86.c|5933| <<kvm_vm_ioctl_enable_cap>> kvm->arch.x2apic_format = true;
+		 *
+		 *     x2apic_format = false,
+		 *     x2apic_broadcast_quirk_disabled = false,
+		 */
 		if (cap->args[0] & KVM_X2APIC_API_USE_32BIT_IDS)
 			kvm->arch.x2apic_format = true;
+		/*
+		 * 在以下使用kvm_arch->x2apic_broadcast_quirk_disabled:
+		 *   - arch/x86/kvm/lapic.c|1356| <<kvm_apic_mda>> if (!vcpu->kvm->arch.x2apic_broadcast_quirk_disabled &&
+		 *   - arch/x86/kvm/lapic.c|1435| <<kvm_apic_is_broadcast_dest>> if (kvm->arch.x2apic_broadcast_quirk_disabled) {
+		 *   - arch/x86/kvm/x86.c|5935| <<kvm_vm_ioctl_enable_cap>> kvm->arch.x2apic_broadcast_quirk_disabled = true;
+		 *
+		 *     x2apic_format = false,
+		 *     x2apic_broadcast_quirk_disabled = false,
+		 */
 		if (cap->args[0] & KVM_X2APIC_API_DISABLE_BROADCAST_QUIRK)
 			kvm->arch.x2apic_broadcast_quirk_disabled = true;
 
@@ -8996,13 +9149,41 @@ static void kvm_pv_kick_cpu_op(struct kvm *kvm, unsigned long flags, int apicid)
 
 bool kvm_apicv_activated(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用kvm_arch->apicv_inhibit_reasons:
+	 *   - arch/x86/kvm/x86.c|9007| <<kvm_apicv_activated>> return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
+	 *   - arch/x86/kvm/x86.c|9013| <<kvm_vcpu_apicv_activated>> ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	 *   - arch/x86/kvm/x86.c|9033| <<kvm_apicv_init>> unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9830| <<__kvm_set_or_clear_apicv_inhibit>> old = new = kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9848| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 *   - arch/x86/kvm/x86.c|9857| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 */
 	return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
 }
 EXPORT_SYMBOL_GPL(kvm_apicv_activated);
 
+/*
+ * 在以下调用kvm_vcpu_apicv_activated():
+ *   - arch/x86/kvm/svm/svm.c|1688| <<svm_set_vintr>> WARN_ON(kvm_vcpu_apicv_activated(&svm->vcpu));
+ *   - arch/x86/kvm/x86.c|9794| <<kvm_vcpu_update_apicv>> activate = kvm_vcpu_apicv_activated(vcpu) &&
+ *   - arch/x86/kvm/x86.c|10318| <<vcpu_enter_guest>> WARN_ON_ONCE((kvm_vcpu_apicv_activated(vcpu) != kvm_vcpu_apicv_active(vcpu)) &&
+ */
 bool kvm_vcpu_apicv_activated(struct kvm_vcpu *vcpu)
 {
+	/*
+	 * 在以下使用kvm_arch->apicv_inhibit_reasons:
+	 *   - arch/x86/kvm/x86.c|9007| <<kvm_apicv_activated>> return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
+	 *   - arch/x86/kvm/x86.c|9013| <<kvm_vcpu_apicv_activated>> ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	 *   - arch/x86/kvm/x86.c|9033| <<kvm_apicv_init>> unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9830| <<__kvm_set_or_clear_apicv_inhibit>> old = new = kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9848| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 *   - arch/x86/kvm/x86.c|9857| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 */
 	ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	/*
+	 * 只在这里调用
+	 * 只有amd有: avic_vcpu_get_apicv_inhibit_reasons()
+	 */
 	ulong vcpu_reasons = static_call(kvm_x86_vcpu_get_apicv_inhibit_reasons)(vcpu);
 
 	return (vm_reasons | vcpu_reasons) == 0;
@@ -9022,6 +9203,15 @@ static void set_or_clear_apicv_inhibit(unsigned long *inhibits,
 
 static void kvm_apicv_init(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用kvm_arch->apicv_inhibit_reasons:
+	 *   - arch/x86/kvm/x86.c|9007| <<kvm_apicv_activated>> return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
+	 *   - arch/x86/kvm/x86.c|9013| <<kvm_vcpu_apicv_activated>> ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	 *   - arch/x86/kvm/x86.c|9033| <<kvm_apicv_init>> unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9830| <<__kvm_set_or_clear_apicv_inhibit>> old = new = kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9848| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 *   - arch/x86/kvm/x86.c|9857| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 */
 	unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
 
 	init_rwsem(&kvm->arch.apicv_update_lock);
@@ -9276,6 +9466,10 @@ static void kvm_inject_exception(struct kvm_vcpu *vcpu)
 	static_call(kvm_x86_inject_exception)(vcpu);
 }
 
+/*
+ * 在以下调用inject_pending_event():
+ *   - arch/x86/kvm/x86.c|10320| <<vcpu_enter_guest>> r = inject_pending_event(vcpu, &req_immediate_exit);
+ */
 static int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)
 {
 	int r;
@@ -9306,6 +9500,9 @@ static int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)
 			static_call(kvm_x86_inject_nmi)(vcpu);
 			can_inject = false;
 		} else if (vcpu->arch.interrupt.injected) {
+			/*
+			 * vmx_inject_irq()
+			 */
 			static_call(kvm_x86_inject_irq)(vcpu, true);
 			can_inject = false;
 		}
@@ -9406,10 +9603,25 @@ static int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)
 		if (r < 0)
 			goto out;
 		if (r) {
+			/*
+			 * 这里很重要!
+			 */
 			int irq = kvm_cpu_get_interrupt(vcpu);
 
 			if (!WARN_ON_ONCE(irq == -1)) {
+				/*
+				 * 在以下使用kvm_queue_interrupt():
+				 *   - arch/x86/kvm/svm/svm.c|4045| <<svm_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, false);
+				 *   - arch/x86/kvm/svm/svm.c|4048| <<svm_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, true);
+				 *   - arch/x86/kvm/vmx/vmx.c|6768| <<__vmx_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);
+				 *   - arch/x86/kvm/x86.c|4713| <<kvm_vcpu_ioctl_interrupt>> kvm_queue_interrupt(vcpu, irq->irq, false);
+				 *   - arch/x86/kvm/x86.c|9490| <<inject_pending_event>> kvm_queue_interrupt(vcpu, irq, false);
+				 *   - arch/x86/kvm/x86.c|11223| <<__set_sregs>> kvm_queue_interrupt(vcpu, pending_vec, false);
+				 */
 				kvm_queue_interrupt(vcpu, irq, false);
+				/*
+				 * vmx_inject_irq
+				 */
 				static_call(kvm_x86_inject_irq)(vcpu, false);
 				WARN_ON(static_call(kvm_x86_interrupt_allowed)(vcpu, true) < 0);
 			}
@@ -9724,6 +9936,10 @@ static void process_smi(struct kvm_vcpu *vcpu)
 	kvm_make_request(KVM_REQ_EVENT, vcpu);
 }
 
+/*
+ * 在以下使用kvm_make_scan_ioapic_request_mask():
+ *   - arch/x86/kvm/ioapic.c|575| <<ioapic_write_indirect>> kvm_make_scan_ioapic_request_mask(ioapic->kvm, vcpu_bitmap);
+ */
 void kvm_make_scan_ioapic_request_mask(struct kvm *kvm,
 				       unsigned long *vcpu_bitmap)
 {
@@ -9731,17 +9947,60 @@ void kvm_make_scan_ioapic_request_mask(struct kvm *kvm,
 
 	zalloc_cpumask_var(&cpus, GFP_ATOMIC);
 
+	/*
+	 * 在以下使用KVM_REQ_SCAN_IOAPIC:
+	 *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+	 *   - arch/x86/kvm/x86.c|9742| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+	 *   - arch/x86/kvm/x86.c|9750| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+	 *   - arch/x86/kvm/x86.c|10087| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
+	 *
+	 * 处理的函数vcpu_scan_ioapic()
+	 */
 	kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
 				    NULL, vcpu_bitmap, cpus);
 
 	free_cpumask_var(cpus);
 }
 
+/*
+ * 在以下使用kvm_make_scan_ioapic_request():
+ *   - arch/x86/kvm/ioapic.c|485| <<kvm_arch_post_irq_ack_notifier_list_update>> kvm_make_scan_ioapic_request(kvm);
+ *   - arch/x86/kvm/ioapic.c|578| <<ioapic_write_indirect>> kvm_make_scan_ioapic_request(ioapic->kvm);
+ *   - arch/x86/kvm/ioapic.c|1011| <<kvm_set_ioapic>> kvm_make_scan_ioapic_request(kvm);
+ *   - arch/x86/kvm/irq_comm.c|454| <<kvm_arch_post_irq_routing_update>> kvm_make_scan_ioapic_request(kvm);
+ *   - arch/x86/kvm/lapic.c|347| <<kvm_recalculate_apic_map>> kvm_make_scan_ioapic_request(kvm);
+ */
 void kvm_make_scan_ioapic_request(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用KVM_REQ_SCAN_IOAPIC:
+	 *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+	 *   - arch/x86/kvm/x86.c|9742| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+	 *   - arch/x86/kvm/x86.c|9750| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+	 *   - arch/x86/kvm/x86.c|10087| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
+	 *
+	 * 处理的函数vcpu_scan_ioapic()
+	 */
 	kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
 }
 
+/*
+ * 在以下使用KVM_REQ_APICV_UPDATE:
+ *   - arch/x86/kvm/svm/nested.c|729| <<enter_svm_guest_mode>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+ *   - arch/x86/kvm/svm/nested.c|1111| <<svm_leave_nested>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+ *   - arch/x86/kvm/vmx/nested.c|4696| <<nested_vmx_vmexit>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+ *   - arch/x86/kvm/x86.c|10189| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))
+ *   - arch/x86/kvm/x86.c|11394| <<kvm_arch_vcpu_create>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+ *
+ * 处理的函数:
+ * kvm_vcpu_update_apicv(vcpu);
+ *
+ *
+ * 在以下使用kvm_vcpu_update_apicv():
+ *   - arch/x86/kvm/lapic.c|2595| <<kvm_lapic_set_base>> kvm_vcpu_update_apicv(vcpu);
+ *   - arch/x86/kvm/svm/nested.c|1033| <<nested_svm_vmexit>> kvm_vcpu_update_apicv(vcpu);
+ *   - arch/x86/kvm/x86.c|10190| <<vcpu_enter_guest(KVM_REQ_APICV_UPDATE)>> kvm_vcpu_update_apicv(vcpu);
+ */
 void kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)
 {
 	bool activate;
@@ -9760,7 +10019,16 @@ void kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)
 		goto out;
 
 	vcpu->arch.apicv_active = activate;
+	/*
+	 * 在以下使用kvm_apic_update_apicv():
+	 *   - arch/x86/kvm/lapic.c|2828| <<kvm_lapic_reset>> kvm_apic_update_apicv(vcpu);
+	 *   - arch/x86/kvm/lapic.c|3192| <<kvm_apic_set_state>> kvm_apic_update_apicv(vcpu);
+	 *   - arch/x86/kvm/x86.c|9877| <<kvm_vcpu_update_apicv>> kvm_apic_update_apicv(vcpu);
+	 */
 	kvm_apic_update_apicv(vcpu);
+	/*
+	 * vmx_refresh_apicv_exec_ctrl()
+	 */
 	static_call(kvm_x86_refresh_apicv_exec_ctrl)(vcpu);
 
 	/*
@@ -9778,6 +10046,36 @@ void kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_vcpu_update_apicv);
 
+/*
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_vcpu_reset
+ * kvm_apic_accept_events
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_lapic_reg_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 void __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 				      enum kvm_apicv_inhibit reason, bool set)
 {
@@ -9789,6 +10087,15 @@ void __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 	    !static_call(kvm_x86_check_apicv_inhibit_reasons)(reason))
 		return;
 
+	/*
+	 * 在以下使用kvm_arch->apicv_inhibit_reasons:
+	 *   - arch/x86/kvm/x86.c|9007| <<kvm_apicv_activated>> return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
+	 *   - arch/x86/kvm/x86.c|9013| <<kvm_vcpu_apicv_activated>> ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	 *   - arch/x86/kvm/x86.c|9033| <<kvm_apicv_init>> unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9830| <<__kvm_set_or_clear_apicv_inhibit>> old = new = kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9848| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 *   - arch/x86/kvm/x86.c|9857| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 */
 	old = new = kvm->arch.apicv_inhibit_reasons;
 
 	set_or_clear_apicv_inhibit(&new, reason, set);
@@ -9806,6 +10113,17 @@ void __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 		 * side (handling the request) also prevents other vCPUs from
 		 * servicing the request with a stale apicv_inhibit_reasons.
 		 */
+		/*
+		 * 在以下使用KVM_REQ_APICV_UPDATE:
+		 *   - arch/x86/kvm/svm/nested.c|729| <<enter_svm_guest_mode>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/svm/nested.c|1111| <<svm_leave_nested>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/vmx/nested.c|4696| <<nested_vmx_vmexit>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/x86.c|10189| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))
+		 *   - arch/x86/kvm/x86.c|11394| <<kvm_arch_vcpu_create>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *
+		 * 处理的函数:
+		 * kvm_vcpu_update_apicv(vcpu);
+		 */
 		kvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);
 		kvm->arch.apicv_inhibit_reasons = new;
 		if (new) {
@@ -9820,6 +10138,41 @@ void __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 	}
 }
 
+/*
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_vcpu_reset
+ * kvm_apic_accept_events
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_lapic_reg_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ *
+ * 在以下调用kvm_set_or_clear_apicv_inhibit():
+ *   - arch/x86/include/asm/kvm_host.h|2021| <<kvm_set_apicv_inhibit>> kvm_set_or_clear_apicv_inhibit(kvm, reason, true);
+ *   - arch/x86/include/asm/kvm_host.h|2027| <<kvm_clear_apicv_inhibit>> kvm_set_or_clear_apicv_inhibit(kvm, reason, false);
+ */
 void kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 				    enum kvm_apicv_inhibit reason, bool set)
 {
@@ -9832,6 +10185,17 @@ void kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 }
 EXPORT_SYMBOL_GPL(kvm_set_or_clear_apicv_inhibit);
 
+/*
+ * 在以下使用KVM_REQ_SCAN_IOAPIC:
+ *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+ *   - arch/x86/kvm/x86.c|9742| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+ *   - arch/x86/kvm/x86.c|9750| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+ *   - arch/x86/kvm/x86.c|10087| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu)) 
+ *
+ *
+ * 处理KVM_REQ_SCAN_IOAPIC:
+ *   - arch/x86/kvm/x86.c|10058| <<vcpu_enter_guest>> vcpu_scan_ioapic(vcpu);
+ */
 static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)
 {
 	if (!kvm_apic_present(vcpu))
@@ -9839,34 +10203,113 @@ static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)
 
 	bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
 
+	/*
+	 * 在以下调用kvm_x86_sync_pir_to_irr()
+	 *   - arch/x86/kvm/lapic.c|789| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+	 *   - arch/x86/kvm/x86.c|4623| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|9842| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10171| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10220| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *
+	 * vmx_sync_pir_to_irr()
+	 */
 	static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
+	/*
+	 * 在以下使用kvm_vcpu_arch->ioapic_handled_vectors:
+	 *   - arch/x86/kvm/lapic.c|1273| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9840| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+	 *   - arch/x86/kvm/x86.c|9845| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9847| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9864| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,
+	 *              to_hv_synic(vcpu)->vec_bitmap, 256);
+	 *   - arch/x86/kvm/x86.c|9871| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10004| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+	 */
 	if (irqchip_split(vcpu->kvm))
 		kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
 	else if (ioapic_in_kernel(vcpu->kvm))
 		kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
 
+	/*
+	 * 在以下使用kvm_vcpu_arch->load_eoi_exitmap_pending:
+	 *   - arch/x86/kvm/kvm_cache_regs.h|184| <<leave_guest_mode>> if (vcpu->arch.load_eoi_exitmap_pending) {
+	 *   - arch/x86/kvm/kvm_cache_regs.h|185| <<leave_guest_mode>> vcpu->arch.load_eoi_exitmap_pending = false;
+	 *   - arch/x86/kvm/x86.c|9850| <<vcpu_scan_ioapic>> vcpu->arch.load_eoi_exitmap_pending = true;
+	 */
 	if (is_guest_mode(vcpu))
 		vcpu->arch.load_eoi_exitmap_pending = true;
 	else
 		kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+	/*
+	 * 在以下使用KVM_REQ_LOAD_EOI_EXITMAP:
+	 *   - arch/x86/kvm/kvm_cache_regs.h|186| <<leave_guest_mode>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+	 *   - arch/x86/kvm/x86.c|9889| <<vcpu_scan_ioapic>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+	 *   - arch/x86/kvm/x86.c|10089| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))
+	 *
+	 * 处理的函数vcpu_load_eoi_exitmap()
+	 */
 }
 
+/*
+ * 在以下使用KVM_REQ_LOAD_EOI_EXITMAP:
+ *   - arch/x86/kvm/kvm_cache_regs.h|186| <<leave_guest_mode>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+ *   - arch/x86/kvm/x86.c|9889| <<vcpu_scan_ioapic>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+ *   - arch/x86/kvm/x86.c|10089| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))
+ *
+ * 处理的函数vcpu_load_eoi_exitmap()
+ *
+ *
+ * 处理KVM_REQ_IOAPIC_EOI_EXIT:
+ *   - arch/x86/kvm/x86.c|10060| <<vcpu_enter_guest>> vcpu_load_eoi_exitmap(vcpu);
+ */
 static void vcpu_load_eoi_exitmap(struct kvm_vcpu *vcpu)
 {
 	u64 eoi_exit_bitmap[4];
 
+	/*
+	 * 在以下调用kvm_apic_hw_enabled():
+	 *   - arch/x86/kvm/lapic.c|177| <<apic_enabled>> return kvm_apic_sw_enabled(apic) && kvm_apic_hw_enabled(apic);
+	 *   - arch/x86/kvm/lapic.c|2040| <<apic_mmio_read>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2125| <<lapic_timer_int_injected>> if (kvm_apic_hw_enabled(apic)) {
+	 *   - arch/x86/kvm/lapic.c|2809| <<apic_mmio_write>> if (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {
+	 *   - arch/x86/kvm/lapic.c|3330| <<kvm_apic_local_deliver>> if (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {
+	 *   - arch/x86/kvm/lapic.c|3443| <<kvm_apic_accept_pic_intr>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 *   - arch/x86/kvm/lapic.h|246| <<kvm_apic_present>> return lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);
+	 *   - arch/x86/kvm/x86.c|10218| <<vcpu_load_eoi_exitmap>> if (!kvm_apic_hw_enabled(vcpu->arch.apic))
+	 */
 	if (!kvm_apic_hw_enabled(vcpu->arch.apic))
 		return;
 
 	if (to_hv_vcpu(vcpu)) {
+		/*
+		 * 在以下使用kvm_vcpu_arch->ioapic_handled_vectors:
+		 *   - arch/x86/kvm/lapic.c|1273| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+		 *   - arch/x86/kvm/x86.c|9840| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+		 *   - arch/x86/kvm/x86.c|9845| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+		 *   - arch/x86/kvm/x86.c|9847| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+		 *   - arch/x86/kvm/x86.c|9864| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,
+		 *              to_hv_synic(vcpu)->vec_bitmap, 256);
+		 *   - arch/x86/kvm/x86.c|9871| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+		 *   - arch/x86/kvm/x86.c|10004| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+		 */
 		bitmap_or((ulong *)eoi_exit_bitmap,
 			  vcpu->arch.ioapic_handled_vectors,
 			  to_hv_synic(vcpu)->vec_bitmap, 256);
+		/*
+		 * vmx_load_eoi_exitmap()
+		 */
 		static_call(kvm_x86_load_eoi_exitmap)(vcpu, eoi_exit_bitmap);
 		return;
 	}
 
+	/*
+	 * 在以下调用kvm_x86_load_eoi_exitmap():
+	 *   - arch/x86/kvm/x86.c|9921| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, eoi_exit_bitmap);
+	 *   - arch/x86/kvm/x86.c|9928| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(
+	 *
+	 * vmx_load_eoi_exitmap()
+	 */
 	static_call(kvm_x86_load_eoi_exitmap)(
 		vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
 }
@@ -10000,6 +10443,23 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 			kvm_pmu_deliver_pmi(vcpu);
 		if (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {
 			BUG_ON(vcpu->arch.pending_ioapic_eoi > 255);
+			/*
+			 * 在以下使用kvm_vcpu_arch->pending_ioapic_eoi:
+			 *   - arch/x86/kvm/lapic.c|1286| <<kvm_ioapic_send_eoi>> apic->vcpu->arch.pending_ioapic_eoi = vector;
+			 *   - arch/x86/kvm/x86.c|10008| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> BUG_ON(vcpu->arch.pending_ioapic_eoi > 255);
+			 *   - arch/x86/kvm/x86.c|10009| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> if (test_bit(vcpu->arch.pending_ioapic_eoi,
+			 *   - arch/x86/kvm/x86.c|10013| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> vcpu->arch.pending_ioapic_eoi;
+			 *
+			 * 在以下使用kvm_vcpu_arch->ioapic_handled_vectors:
+			 *   - arch/x86/kvm/lapic.c|1273| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|9840| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+			 *   - arch/x86/kvm/x86.c|9845| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|9847| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|9864| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,
+			 *              to_hv_synic(vcpu)->vec_bitmap, 256);
+			 *   - arch/x86/kvm/x86.c|9871| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|10004| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+			 */
 			if (test_bit(vcpu->arch.pending_ioapic_eoi,
 				     vcpu->arch.ioapic_handled_vectors)) {
 				vcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;
@@ -10009,6 +10469,15 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 				goto out;
 			}
 		}
+		/*
+		 * 在以下使用KVM_REQ_SCAN_IOAPIC:
+		 *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+		 *   - arch/x86/kvm/x86.c|9742| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+		 *   - arch/x86/kvm/x86.c|9750| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+		 *   - arch/x86/kvm/x86.c|10087| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu)) 
+		 *
+		 * 处理的函数vcpu_scan_ioapic()
+		 */
 		if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
 			vcpu_scan_ioapic(vcpu);
 		if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))
@@ -10043,6 +10512,17 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 		 */
 		if (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))
 			kvm_hv_process_stimers(vcpu);
+		/*
+		 * 在以下使用KVM_REQ_APICV_UPDATE:
+		 *   - arch/x86/kvm/svm/nested.c|729| <<enter_svm_guest_mode>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/svm/nested.c|1111| <<svm_leave_nested>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/vmx/nested.c|4696| <<nested_vmx_vmexit>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/x86.c|10189| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))
+		 *   - arch/x86/kvm/x86.c|11394| <<kvm_arch_vcpu_create>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *
+		 * 处理的函数:
+		 * kvm_vcpu_update_apicv(vcpu);
+		 */
 		if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))
 			kvm_vcpu_update_apicv(vcpu);
 		if (kvm_check_request(KVM_REQ_APF_READY, vcpu))
@@ -10088,6 +10568,9 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 
 	preempt_disable();
 
+	/*
+	 * vmx_prepare_switch_to_guest()
+	 */
 	static_call(kvm_x86_prepare_switch_to_guest)(vcpu);
 
 	/*
@@ -10122,9 +10605,24 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 	 * use the POSTED_INTR_VECTOR even if APICv is disabled,
 	 * so do it even if APICv is disabled on this vCPU.
 	 */
+	/*
+	 * 在以下调用kvm_x86_sync_pir_to_irr()
+	 *   - arch/x86/kvm/lapic.c|789| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+	 *   - arch/x86/kvm/x86.c|4623| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|9842| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10171| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10220| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *
+	 * vmx_sync_pir_to_irr()
+	 */
 	if (kvm_lapic_enabled(vcpu))
 		static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
+	/*
+	 * 在以下调用kvm_vcpu_exit_request():
+	 *   - arch/x86/kvm/x86.c|10386| <<vcpu_enter_guest(关于cancel_injection)>> if (kvm_vcpu_exit_request(vcpu)) {
+	 *   - arch/x86/kvm/x86.c|10443| <<vcpu_enter_guest(关于EXIT_FASTPATH_EXIT_HANDLED)>> if (unlikely(kvm_vcpu_exit_request(vcpu))) {
+	 */
 	if (kvm_vcpu_exit_request(vcpu)) {
 		vcpu->mode = OUTSIDE_GUEST_MODE;
 		smp_wmb();
@@ -10167,13 +10665,35 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 		WARN_ON_ONCE((kvm_vcpu_apicv_activated(vcpu) != kvm_vcpu_apicv_active(vcpu)) &&
 			     (kvm_get_apic_mode(vcpu) != LAPIC_MODE_DISABLED));
 
+		/*
+		 * vmx_vcpu_run()
+		 */
 		exit_fastpath = static_call(kvm_x86_vcpu_run)(vcpu);
+		/*
+		 * 很可能是EXIT_FASTPATH_NONE
+		 * 除非ICR或者HW timer
+		 */
 		if (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST))
 			break;
 
+		/*
+		 * 在以下调用kvm_x86_sync_pir_to_irr()
+		 *   - arch/x86/kvm/lapic.c|789| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+		 *   - arch/x86/kvm/x86.c|4623| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 *   - arch/x86/kvm/x86.c|9842| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 *   - arch/x86/kvm/x86.c|10171| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 *   - arch/x86/kvm/x86.c|10220| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 *
+		 * vmx_sync_pir_to_irr();
+		 */
 		if (kvm_lapic_enabled(vcpu))
 			static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
+		/*
+		 * 在以下调用kvm_vcpu_exit_request():
+		 *   - arch/x86/kvm/x86.c|10386| <<vcpu_enter_guest(关于cancel_injection)>> if (kvm_vcpu_exit_request(vcpu)) {
+		 *   - arch/x86/kvm/x86.c|10443| <<vcpu_enter_guest(关于EXIT_FASTPATH_EXIT_HANDLED)>> if (unlikely(kvm_vcpu_exit_request(vcpu))) {
+		 */
 		if (unlikely(kvm_vcpu_exit_request(vcpu))) {
 			exit_fastpath = EXIT_FASTPATH_EXIT_HANDLED;
 			break;
@@ -10220,6 +10740,9 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 	if (vcpu->arch.xfd_no_write_intercept)
 		fpu_sync_guest_vmexit_xfd_state();
 
+	/*
+	 * vmx_handle_exit_irqoff
+	 */
 	static_call(kvm_x86_handle_exit_irqoff)(vcpu);
 
 	if (vcpu->arch.guest_fpu.xfd_err)
@@ -10274,12 +10797,33 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 	if (vcpu->arch.apic_attention)
 		kvm_lapic_sync_from_vapic(vcpu);
 
+	/*
+	 * apic_set_eoi
+	 * kvm_lapic_reg_write
+	 * vmx_set_msr
+	 * __kvm_set_msr
+	 * kvm_emulate_wrmsr
+	 * vmx_handle_exit
+	 * vcpu_enter_guest
+	 * vcpu_run
+	 * kvm_arch_vcpu_ioctl_run
+	 * kvm_vcpu_ioctl
+	 * __x64_sys_ioctl
+	 * do_syscall_64
+	 * entry_SYSCALL_64_after_hwframe
+	 *
+	 * vmx_handle_exit
+	 */
 	r = static_call(kvm_x86_handle_exit)(vcpu, exit_fastpath);
 	return r;
 
 cancel_injection:
 	if (req_immediate_exit)
 		kvm_make_request(KVM_REQ_EVENT, vcpu);
+	/*
+	 * vmx_cancel_injection
+	 * svm_cancel_injection
+	 */
 	static_call(kvm_x86_cancel_injection)(vcpu);
 	if (unlikely(vcpu->arch.apic_attention))
 		kvm_lapic_sync_from_vapic(vcpu);
@@ -10807,6 +11351,13 @@ int kvm_arch_vcpu_ioctl_set_mpstate(struct kvm_vcpu *vcpu,
 	return ret;
 }
 
+/*
+ * 在以下使用kvm_task_switch():
+ *   - arch/x86/kvm/svm/svm.c|2574| <<task_switch_interception>> return kvm_task_switch(vcpu,
+ *                  tss_selector, int_vec, reason, has_error_code, error_code);
+ *   - arch/x86/kvm/vmx/vmx.c|5468| <<handle_task_switch>> return kvm_task_switch(vcpu,
+ *                  tss_selector, type == INTR_TYPE_SOFT_INTR ? idt_index : -1, reason, has_error_code, error_code);
+ */
 int kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,
 		    int reason, bool has_error_code, u32 error_code)
 {
@@ -10855,6 +11406,11 @@ static bool kvm_is_valid_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
 	       kvm_is_valid_cr0(vcpu, sregs->cr0);
 }
 
+/*
+ * 在以下调用__set_sregs_common():
+ *   - arch/x86/kvm/x86.c|11200| <<__set_sregs>> int ret = __set_sregs_common(vcpu, sregs, &mmu_reset_needed, true);
+ *   - arch/x86/kvm/x86.c|11234| <<__set_sregs2>> ret = __set_sregs_common(vcpu, (struct kvm_sregs *)sregs2,
+ */
 static int __set_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs,
 		int *mmu_reset_needed, bool update_pdptrs)
 {
@@ -10927,6 +11483,11 @@ static int __set_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs,
 	return 0;
 }
 
+/*
+ * 在以下调用__set_sregs():
+ *   - arch/x86/kvm/x86.c|11258| <<kvm_arch_vcpu_ioctl_set_sregs>> ret = __set_sregs(vcpu, sregs);
+ *   - arch/x86/kvm/x86.c|11438| <<sync_regs>> if (__set_sregs(vcpu, &vcpu->run->s.regs.sregs))
+ */
 static int __set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
 {
 	int pending_vec, max_bits;
@@ -10944,6 +11505,15 @@ static int __set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
 		(const unsigned long *)sregs->interrupt_bitmap, max_bits);
 
 	if (pending_vec < max_bits) {
+		/*
+		 * 在以下使用kvm_queue_interrupt():
+		 *   - arch/x86/kvm/svm/svm.c|4045| <<svm_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, false);
+		 *   - arch/x86/kvm/svm/svm.c|4048| <<svm_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, true);
+		 *   - arch/x86/kvm/vmx/vmx.c|6768| <<__vmx_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);
+		 *   - arch/x86/kvm/x86.c|4713| <<kvm_vcpu_ioctl_interrupt>> kvm_queue_interrupt(vcpu, irq->irq, false);
+		 *   - arch/x86/kvm/x86.c|9490| <<inject_pending_event>> kvm_queue_interrupt(vcpu, irq, false);
+		 *   - arch/x86/kvm/x86.c|11223| <<__set_sregs>> kvm_queue_interrupt(vcpu, pending_vec, false);
+		 */
 		kvm_queue_interrupt(vcpu, pending_vec, false);
 		pr_debug("Set back pending irq %d\n", pending_vec);
 		kvm_make_request(KVM_REQ_EVENT, vcpu);
@@ -10951,6 +11521,10 @@ static int __set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
 	return 0;
 }
 
+/*
+ * 在以下调用__set_sregs2():
+ *   - arch/x86/kvm/x86.c|5597| <<kvm_arch_vcpu_ioctl(KVM_SET_SREGS2)>> r = __set_sregs2(vcpu, u.sregs2);
+ */
 static int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)
 {
 	int mmu_reset_needed = 0;
@@ -10983,6 +11557,10 @@ static int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)
 	return 0;
 }
 
+/*
+ * 处理KVM_SET_SREGS:
+ *   - virt/kvm/kvm_main.c|4062| <<kvm_vcpu_ioctl(KVM_SET_SREGS)>> r = kvm_arch_vcpu_ioctl_set_sregs(vcpu, kvm_sregs);
+ */
 int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
 				  struct kvm_sregs *sregs)
 {
@@ -11162,6 +11740,10 @@ static void store_regs(struct kvm_vcpu *vcpu)
 				vcpu, &vcpu->run->s.regs.events);
 }
 
+/*
+ * 在以下调用sync_regs():
+ *   - arch/x86/kvm/x86.c|10808| <<kvm_arch_vcpu_ioctl_run>> r = sync_regs(vcpu); 
+ */
 static int sync_regs(struct kvm_vcpu *vcpu)
 {
 	if (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_REGS) {
@@ -11232,6 +11814,17 @@ int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
 		 */
 		if (enable_apicv) {
 			vcpu->arch.apicv_active = true;
+			/*
+			 * 在以下使用KVM_REQ_APICV_UPDATE:
+			 *   - arch/x86/kvm/svm/nested.c|729| <<enter_svm_guest_mode>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+			 *   - arch/x86/kvm/svm/nested.c|1111| <<svm_leave_nested>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+			 *   - arch/x86/kvm/vmx/nested.c|4696| <<nested_vmx_vmexit>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+			 *   - arch/x86/kvm/x86.c|10189| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))
+			 *   - arch/x86/kvm/x86.c|11394| <<kvm_arch_vcpu_create>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+			 *
+			 * 处理的函数:
+			 * kvm_vcpu_update_apicv(vcpu);
+			 */
 			kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
 		}
 	} else
@@ -11355,6 +11948,42 @@ void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
 		static_branch_dec(&kvm_has_noapic_vcpu);
 }
 
+/*
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_vcpu_reset
+ * kvm_apic_accept_events
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __kvm_set_or_clear_apicv_inhibit
+ * __kvm_set_or_clear_apicv_inhibit
+ * kvm_set_or_clear_apicv_inhibit
+ * kvm_recalculate_apic_map
+ * kvm_lapic_reg_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ *
+ * 在以下使用:
+ *   - arch/x86/kvm/lapic.c|3537| <<kvm_apic_accept_events>> kvm_vcpu_reset(vcpu, true);
+ *   - arch/x86/kvm/svm/svm.c|2230| <<shutdown_interception>> kvm_vcpu_reset(vcpu, true);
+ *   - arch/x86/kvm/x86.c|11655| <<kvm_arch_vcpu_create>> kvm_vcpu_reset(vcpu, false);
+ */
 void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
 {
 	unsigned long old_cr0 = kvm_read_cr0(vcpu);
@@ -11370,6 +11999,19 @@ void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
 	if (is_guest_mode(vcpu))
 		kvm_leave_nested(vcpu);
 
+	/*
+	 * __kvm_set_or_clear_apicv_inhibit
+	 * __kvm_set_or_clear_apicv_inhibit
+	 * kvm_set_or_clear_apicv_inhibit
+	 * kvm_recalculate_apic_map
+	 * kvm_vcpu_reset
+	 * kvm_apic_accept_events
+	 * kvm_arch_vcpu_ioctl_run
+	 * kvm_vcpu_ioctl
+	 * __x64_sys_ioctl
+	 * do_syscall_64
+	 * entry_SYSCALL_64_after_hwframe
+	 */
 	kvm_lapic_reset(vcpu, init_event);
 
 	WARN_ON_ONCE(is_guest_mode(vcpu) || is_smm(vcpu));
@@ -11380,6 +12022,16 @@ void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
 	atomic_set(&vcpu->arch.nmi_queued, 0);
 	vcpu->arch.nmi_pending = 0;
 	vcpu->arch.nmi_injected = false;
+	/*
+	 * 在以下调用kvm_clear_interrupt_queue():
+	 *   - arch/x86/kvm/svm/nested.c|1017| <<nested_svm_vmexit>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/svm/svm.c|2556| <<task_switch_interception>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/svm/svm.c|4012| <<svm_complete_interrupts>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/vmx/nested.c|4645| <<nested_vmx_vmexit>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/vmx/vmx.c|5440| <<handle_task_switch>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/vmx/vmx.c|6799| <<__vmx_complete_interrupts>> kvm_clear_interrupt_queue(vcpu);
+	 *   - arch/x86/kvm/x86.c|11947| <<kvm_vcpu_reset>> kvm_clear_interrupt_queue(vcpu);
+	 */
 	kvm_clear_interrupt_queue(vcpu);
 	kvm_clear_exception_queue(vcpu);
 
@@ -11715,6 +12367,12 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 	if (ret)
 		return ret;
 
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|234| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|11763| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
 	INIT_LIST_HEAD(&kvm->arch.active_mmu_pages);
 	INIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);
@@ -11722,6 +12380,13 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 	INIT_LIST_HEAD(&kvm->arch.assigned_dev_head);
 	atomic_set(&kvm->arch.noncoherent_dma_count, 0);
 
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|187| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|219| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11732| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11735| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */
 	set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
 	/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */
@@ -12219,6 +12884,10 @@ static inline bool kvm_guest_apic_has_interrupt(struct kvm_vcpu *vcpu)
 		static_call(kvm_x86_guest_apic_has_interrupt)(vcpu));
 }
 
+/*
+ * 在以下使用kvm_vcpu_has_events():
+ *   - arch/x86/kvm/x86.c|12810| <<kvm_arch_vcpu_runnable>> return kvm_vcpu_running(vcpu) || kvm_vcpu_has_events(vcpu);
+ */
 static inline bool kvm_vcpu_has_events(struct kvm_vcpu *vcpu)
 {
 	if (!list_empty_careful(&vcpu->async_pf.done))
diff --git a/arch/x86/kvm/x86.h b/arch/x86/kvm/x86.h
index f7854e742e8c..a562df0f2cdc 100644
--- a/arch/x86/kvm/x86.h
+++ b/arch/x86/kvm/x86.h
@@ -112,6 +112,15 @@ static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)
 	vcpu->arch.exception.injected = false;
 }
 
+/*
+ * 在以下使用kvm_queue_interrupt():
+ *   - arch/x86/kvm/svm/svm.c|4045| <<svm_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, false);
+ *   - arch/x86/kvm/svm/svm.c|4048| <<svm_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, true);
+ *   - arch/x86/kvm/vmx/vmx.c|6768| <<__vmx_complete_interrupts>> kvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);
+ *   - arch/x86/kvm/x86.c|4713| <<kvm_vcpu_ioctl_interrupt>> kvm_queue_interrupt(vcpu, irq->irq, false);
+ *   - arch/x86/kvm/x86.c|9490| <<inject_pending_event>> kvm_queue_interrupt(vcpu, irq, false);
+ *   - arch/x86/kvm/x86.c|11223| <<__set_sregs>> kvm_queue_interrupt(vcpu, pending_vec, false);
+ */
 static inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,
 	bool soft)
 {
@@ -120,11 +129,29 @@ static inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,
 	vcpu->arch.interrupt.nr = vector;
 }
 
+/*
+ * 在以下调用kvm_clear_interrupt_queue():
+ *   - arch/x86/kvm/svm/nested.c|1017| <<nested_svm_vmexit>> kvm_clear_interrupt_queue(vcpu);
+ *   - arch/x86/kvm/svm/svm.c|2556| <<task_switch_interception>> kvm_clear_interrupt_queue(vcpu);
+ *   - arch/x86/kvm/svm/svm.c|4012| <<svm_complete_interrupts>> kvm_clear_interrupt_queue(vcpu);
+ *   - arch/x86/kvm/vmx/nested.c|4645| <<nested_vmx_vmexit>> kvm_clear_interrupt_queue(vcpu);
+ *   - arch/x86/kvm/vmx/vmx.c|5440| <<handle_task_switch>> kvm_clear_interrupt_queue(vcpu);
+ *   - arch/x86/kvm/vmx/vmx.c|6799| <<__vmx_complete_interrupts>> kvm_clear_interrupt_queue(vcpu);
+ *   - arch/x86/kvm/x86.c|11947| <<kvm_vcpu_reset>> kvm_clear_interrupt_queue(vcpu);
+ */
 static inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)
 {
 	vcpu->arch.interrupt.injected = false;
 }
 
+/*
+ * 在以下使用kvm_event_needs_reinjection():
+ *   - arch/x86/kvm/mmu/mmu.c|4031| <<kvm_handle_page_fault>> if (kvm_event_needs_reinjection(vcpu))
+ *   - arch/x86/kvm/svm/nested.c|1288| <<svm_check_nested_events>> kvm_event_needs_reinjection(vcpu) || svm->nested.nested_run_pending;
+ *   - arch/x86/kvm/vmx/nested.c|3921| <<vmx_check_nested_events>> vmx->nested.nested_run_pending || kvm_event_needs_reinjection(vcpu);
+ *   - arch/x86/kvm/x86.c|4785| <<kvm_vcpu_ready_for_interrupt_injection>> !kvm_event_needs_reinjection(vcpu) &&
+ *   - arch/x86/kvm/x86.c|13061| <<kvm_can_do_async_pf>> kvm_event_needs_reinjection(vcpu) ||
+ */
 static inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)
 {
 	return vcpu->arch.exception.injected || vcpu->arch.interrupt.injected ||
diff --git a/drivers/acpi/acpica/dbexec.c b/drivers/acpi/acpica/dbexec.c
index d3a9521e2dc8..78134e2119ff 100644
--- a/drivers/acpi/acpica/dbexec.c
+++ b/drivers/acpi/acpica/dbexec.c
@@ -692,6 +692,26 @@ acpi_db_create_execution_thread(char *method_name_arg,
 		return;
 	}
 
+	/*
+	 * 在以下调用acpi_os_execute():
+	 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+	 *            acpi_db_execute_thread, NULL);
+	 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+	 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+	 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+	 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_notify_dispatch, info);
+	 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_notify_device_fixed, data);
+	 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+	 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            rbtn_clear_suspended_flag, rbtn_data);
+	 */
 	status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
 				 acpi_db_single_execution_thread,
 				 &acpi_gbl_db_method_info);
@@ -845,6 +865,26 @@ acpi_db_create_execution_threads(char *num_threads_arg,
 		       num_threads, num_loops);
 
 	for (i = 0; i < (num_threads); i++) {
+		/*
+		 * 在以下调用acpi_os_execute():
+		 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+		 *            acpi_db_execute_thread, NULL);
+		 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+		 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+		 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+		 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_notify_dispatch, info);
+		 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_notify_device_fixed, data);
+		 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+		 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            rbtn_clear_suspended_flag, rbtn_data);
+		 */
 		status =
 		    acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
 				    acpi_db_method_thread,
diff --git a/drivers/acpi/acpica/dbxface.c b/drivers/acpi/acpica/dbxface.c
index 9dfd693cda3e..ac899207a957 100644
--- a/drivers/acpi/acpica/dbxface.c
+++ b/drivers/acpi/acpica/dbxface.c
@@ -445,6 +445,26 @@ acpi_status acpi_initialize_debugger(void)
 		/* Create the debug execution thread to execute commands */
 
 		acpi_gbl_db_threads_terminated = FALSE;
+		/*
+		 * 在以下调用acpi_os_execute():
+		 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+		 *            acpi_db_execute_thread, NULL);
+		 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+		 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+		 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+		 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_notify_dispatch, info);
+		 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_notify_device_fixed, data);
+		 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+		 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            rbtn_clear_suspended_flag, rbtn_data);
+		 */
 		status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
 					 acpi_db_execute_thread, NULL);
 		if (ACPI_FAILURE(status)) {
diff --git a/drivers/acpi/acpica/dswexec.c b/drivers/acpi/acpica/dswexec.c
index f2d2267054af..793d3c1a9c15 100644
--- a/drivers/acpi/acpica/dswexec.c
+++ b/drivers/acpi/acpica/dswexec.c
@@ -26,6 +26,10 @@ ACPI_MODULE_NAME("dswexec")
 /*
  * Dispatch table for opcode classes
  */
+/*
+ * 在以下使用acpi_gbl_op_type_dispatch[]:
+ *   - drivers/acpi/acpica/dswexec.c|453| <<acpi_ds_exec_end_op>> acpi_gbl_op_type_dispatch[op_type] (walk_state);
+ */
 static acpi_execute_op acpi_gbl_op_type_dispatch[] = {
 	acpi_ex_opcode_0A_0T_1R,
 	acpi_ex_opcode_1A_0T_0R,
@@ -324,6 +328,48 @@ acpi_ds_exec_begin_op(struct acpi_walk_state *walk_state,
  *
  ****************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *                      
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq         
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt     
+ *                            
+ * [0] acpi_os_execute       
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op  
+ * [0] acpi_ps_parse_loop   
+ * [0] acpi_ps_parse_aml        
+ * [0] acpi_ps_execute_method   
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work         
+ * [0] worker_thread            
+ * [0] kthread                      
+ * [0] ret_from_fork                                            
+ *                                                              
+ * [0] acpi_os_execute          
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred         
+ * [0] process_one_work                         
+ * [0] worker_thread                                            
+ * [0] kthread                          
+ * [0] ret_from_fork 
+ *
+ * 在以下使用acpi_ds_exec_end_op():
+ *   - drivers/acpi/acpica/dswload.c|78| <<acpi_ds_init_callbacks>> walk_state->ascending_callback = acpi_ds_exec_end_op;
+ *
+ * acpi_ex_opcode_2A_0T_0R()
+ */
 acpi_status acpi_ds_exec_end_op(struct acpi_walk_state *walk_state)
 {
 	union acpi_parse_object *op;
@@ -409,6 +455,10 @@ acpi_status acpi_ds_exec_end_op(struct acpi_walk_state *walk_state)
 			 * routine. There is one routine per opcode "type" based upon the
 			 * number of opcode arguments and return type.
 			 */
+			/*
+			 * 这里!!!!
+			 * acpi_ex_opcode_2A_0T_0R()
+			 */
 			status =
 			    acpi_gbl_op_type_dispatch[op_type] (walk_state);
 		} else {
diff --git a/drivers/acpi/acpica/evgpe.c b/drivers/acpi/acpica/evgpe.c
index c5a06882bdf6..c29c04c4bfb8 100644
--- a/drivers/acpi/acpica/evgpe.c
+++ b/drivers/acpi/acpica/evgpe.c
@@ -330,6 +330,43 @@ struct acpi_gpe_event_info *acpi_ev_get_gpe_event_info(acpi_handle gpe_device,
 		(gpe_number, obj_desc->device.gpe_block));
 }
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ */
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ev_gpe_detect
@@ -373,14 +410,26 @@ u32 acpi_ev_gpe_detect(struct acpi_gpe_xrupt_info *gpe_xrupt_list)
 
 	/* Examine all GPE blocks attached to this interrupt level */
 
+	/*
+	 * struct acpi_gpe_block_info *gpe_block;
+	 */
 	gpe_block = gpe_xrupt_list->gpe_block_list_head;
 	while (gpe_block) {
+		/*
+		 * 这个while循环就一个block,
+		 * gpe_device->name.ascii = "_GPE".
+		 *
+		 * struct acpi_namespace_node *gpe_device;
+		 */
 		gpe_device = gpe_block->node;
 
 		/*
 		 * Read all of the 8-bit GPE status and enable registers in this GPE
 		 * block, saving all of them. Find all currently active GP events.
 		 */
+		/*
+		 * hot-add测试register_count也是8个
+		 */
 		for (i = 0; i < gpe_block->register_count; i++) {
 
 			/* Get the next status/enable pair */
@@ -391,6 +440,9 @@ u32 acpi_ev_gpe_detect(struct acpi_gpe_xrupt_info *gpe_xrupt_list)
 			 * Optimization: If there are no GPEs enabled within this
 			 * register, we can safely ignore the entire register.
 			 */
+			/*
+			 * 只有0的能跳过这里
+			 */
 			if (!(gpe_register_info->enable_for_run |
 			      gpe_register_info->enable_for_wake)) {
 				ACPI_DEBUG_PRINT((ACPI_DB_INTERRUPTS,
@@ -410,10 +462,24 @@ u32 acpi_ev_gpe_detect(struct acpi_gpe_xrupt_info *gpe_xrupt_list)
 
 			/* Now look at the individual GPEs in this byte register */
 
+			/*
+			 * 8个
+			 */
 			for (j = 0; j < ACPI_GPE_REGISTER_WIDTH; j++) {
 
 				/* Detect and dispatch one GPE bit */
 
+				/*
+				 * gpe_block都链接在gpe_block_list_head
+				 *
+				 * struct acpi_gpe_block_info *gpe_block;
+				 * -> struct acpi_namespace_node *node; (gpe_device->name.ascii = "_GPE".)
+				 * -> struct acpi_gpe_register_info *register_info;
+				 * -> struct acpi_gpe_event_info *event_info;
+				 *
+				 *
+				 * struct acpi_gpe_event_info *gpe_event_info;
+				 */
 				gpe_event_info =
 				    &gpe_block->
 				    event_info[((acpi_size)i *
@@ -421,6 +487,13 @@ u32 acpi_ev_gpe_detect(struct acpi_gpe_xrupt_info *gpe_xrupt_list)
 				gpe_number =
 				    j + gpe_register_info->base_gpe_number;
 				acpi_os_release_lock(acpi_gbl_gpe_lock, flags);
+				/*
+				 * 在以下调用acpi_ev_detect_gpe():
+				 *   - drivers/acpi/acpica/evgpe.c|471| <<acpi_ev_gpe_detect>> acpi_ev_detect_gpe(gpe_device, gpe_event_info, gpe_number);
+				 *   - drivers/acpi/acpica/evxface.c|980| <<acpi_remove_gpe_handler>> (void )acpi_ev_detect_gpe(gpe_device, gpe_event_info, gpe_number);
+				 *   - drivers/acpi/acpica/evxfgpe.c|118| <<acpi_enable_gpe>> (void )acpi_ev_detect_gpe(gpe_device, gpe_event_info, gpe_number);
+				 *   - drivers/acpi/acpica/evxfgpe.c|657| <<acpi_dispatch_gpe>> return acpi_ev_detect_gpe(gpe_device, NULL, gpe_number);
+				 */
 				int_status |=
 				    acpi_ev_detect_gpe(gpe_device,
 						       gpe_event_info,
@@ -429,6 +502,9 @@ u32 acpi_ev_gpe_detect(struct acpi_gpe_xrupt_info *gpe_xrupt_list)
 			}
 		}
 
+		/*
+		 * 选择下一个
+		 */
 		gpe_block = gpe_block->next;
 	}
 
@@ -452,6 +528,64 @@ u32 acpi_ev_gpe_detect(struct acpi_gpe_xrupt_info *gpe_xrupt_list)
  *
  ******************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request ==> acpi_ev_notify_dispatch
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ *
+ * [0] acpi_hotplug_schedule
+ * [0] acpi_bus_notify
+ * [0] acpi_ev_notify_dispatch
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ *
+ * struct acpi_gpe_block_info *gpe_block;
+ * -> struct acpi_namespace_node *node; (gpe_device->name.ascii = "_GPE".)
+ * -> struct acpi_gpe_register_info *register_info;
+ * -> struct acpi_gpe_event_info *event_info;
+ *
+ * debug测试的时候只有i=0, j=1执行了这里
+ * gpe_number=1
+ * (插入第二个第三个还是这样)
+ * 应该是ACPI_GPE_DISPATCH_METHOD
+ */
 static void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context)
 {
 	struct acpi_gpe_event_info *gpe_event_info = context;
@@ -478,6 +612,9 @@ static void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context)
 		 */
 		notify = gpe_event_info->dispatch.notify_list;
 		while (ACPI_SUCCESS(status) && notify) {
+			/*
+			 * 似乎这里非常重要!!! 也不一定, 好吧不是!!!
+			 */
 			status =
 			    acpi_ev_queue_notify_request(notify->device_node,
 							 ACPI_NOTIFY_DEVICE_WAKE);
@@ -495,6 +632,20 @@ static void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context)
 		if (!info) {
 			status = AE_NO_MEMORY;
 		} else {
+			/*
+			 * struct acpi_gpe_block_info *gpe_block;
+			 * -> struct acpi_namespace_node *node; (gpe_device->name.ascii = "_GPE".)
+			 * -> struct acpi_gpe_register_info *register_info;
+			 * -> struct acpi_gpe_event_info *event_info;
+			 *
+			 * debug测试的时候只有i=0, j=1执行了这里
+			 * gpe_number=1
+			 * (插入第二个第三个还是这样)
+			 * 应该是ACPI_GPE_DISPATCH_METHOD
+			 *
+			 * 这里测试的
+			 * acpi_ut_get_node_name(gpe_event_info->dispatch.method_node)是"_E01"
+			 */
 			/*
 			 * Invoke the GPE Method (_Lxx, _Exx) i.e., evaluate the
 			 * _Lxx/_Exx control method that corresponds to this GPE
@@ -503,6 +654,11 @@ static void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context)
 			    gpe_event_info->dispatch.method_node;
 			info->flags = ACPI_IGNORE_RETURN_VALUE;
 
+			/*
+			 * 先执行这里!!!!!
+			 *
+			 * struct acpi_evaluate_info *info;
+			 */
 			status = acpi_ns_evaluate(info);
 			ACPI_FREE(info);
 		}
@@ -523,6 +679,28 @@ static void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context)
 
 	/* Defer enabling of GPE until all notify handlers are done */
 
+	/*
+	 * 在以下调用acpi_os_execute():
+	 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+	 *            acpi_db_execute_thread, NULL);
+	 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+	 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+	 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+	 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_notify_dispatch, info);
+	 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_notify_device_fixed, data);
+	 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+	 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            rbtn_clear_suspended_flag, rbtn_data);
+	 *
+	 * struct acpi_gpe_event_info *gpe_event_info = context;
+	 */
 	status = acpi_os_execute(OSL_NOTIFY_HANDLER,
 				 acpi_ev_asynch_enable_gpe, gpe_event_info);
 	if (ACPI_SUCCESS(status)) {
@@ -549,6 +727,11 @@ static void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context)
  *
  ******************************************************************************/
 
+/*
+ * 在以下使用acpi_ev_asynch_enable_gpe():
+ *   - drivers/acpi/acpica/evgpe.c|630| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_ev_asynch_enable_gpe, gpe_event_info);
+ *   - drivers/acpi/acpica/evgpe.c|636| <<acpi_ev_asynch_execute_gpe_method>> acpi_ev_asynch_enable_gpe(gpe_event_info);
+ */
 static void ACPI_SYSTEM_XFACE acpi_ev_asynch_enable_gpe(void *context)
 {
 	struct acpi_gpe_event_info *gpe_event_info = context;
@@ -622,6 +805,56 @@ acpi_status acpi_ev_finish_gpe(struct acpi_gpe_event_info *gpe_event_info)
  *
  ******************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下调用acpi_ev_detect_gpe():
+ *   - drivers/acpi/acpica/evgpe.c|471| <<acpi_ev_gpe_detect>> acpi_ev_detect_gpe(gpe_device, gpe_event_info, gpe_number);
+ *   - drivers/acpi/acpica/evxface.c|980| <<acpi_remove_gpe_handler>> (void )acpi_ev_detect_gpe(gpe_device, gpe_event_info, gpe_number);
+ *   - drivers/acpi/acpica/evxfgpe.c|118| <<acpi_enable_gpe>> (void )acpi_ev_detect_gpe(gpe_device, gpe_event_info, gpe_number);
+ *   - drivers/acpi/acpica/evxfgpe.c|657| <<acpi_dispatch_gpe>> return acpi_ev_detect_gpe(gpe_device, NULL, gpe_number);
+ *
+ * gpe_block都链接在gpe_block_list_head
+ *
+ * struct acpi_gpe_block_info *gpe_block;
+ * -> struct acpi_namespace_node *node; (gpe_device->name.ascii = "_GPE".)
+ * -> struct acpi_gpe_register_info *register_info;
+ * -> struct acpi_gpe_event_info *event_info;
+ */
 u32
 acpi_ev_detect_gpe(struct acpi_namespace_node *gpe_device,
 		   struct acpi_gpe_event_info *gpe_event_info, u32 gpe_number)
@@ -720,6 +953,18 @@ acpi_ev_detect_gpe(struct acpi_namespace_node *gpe_device,
 	} else {
 		/* Dispatch the event to a standard handler or method. */
 
+		/*
+		 * struct acpi_gpe_block_info *gpe_block;
+		 * -> struct acpi_namespace_node *node; (gpe_device->name.ascii = "_GPE".)
+		 * -> struct acpi_gpe_register_info *register_info;
+		 * -> struct acpi_gpe_event_info *event_info;
+		 *
+		 * debug测试的时候只有i=0, j=1执行了这里
+		 * gpe_number=1
+		 * (插入第二个第三个还是这样)
+		 *
+		 * 这里???
+		 */
 		int_status |= acpi_ev_gpe_dispatch(gpe_device,
 						   gpe_event_info, gpe_number);
 	}
@@ -744,6 +989,57 @@ acpi_ev_detect_gpe(struct acpi_namespace_node *gpe_device,
  *
  ******************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下使用acpi_ev_gpe_dispatch():
+ *   - drivers/acpi/acpica/dbcmds.c|1055| <<acpi_db_generate_gpe>> (void )acpi_ev_gpe_dispatch(NULL, gpe_event_info, gpe_number);
+ *   - drivers/acpi/acpica/evgpe.c|866| <<acpi_ev_detect_gpe>> int_status |= acpi_ev_gpe_dispatch(gpe_device, gpe_event_info, gpe_number);
+ *
+ * struct acpi_gpe_block_info *gpe_block;
+ * -> struct acpi_namespace_node *node; (gpe_device->name.ascii = "_GPE".)
+ * -> struct acpi_gpe_register_info *register_info;
+ * -> struct acpi_gpe_event_info *event_info;
+ *
+ * debug测试的时候只有i=0, j=1执行了这里
+ * gpe_number=1
+ * (插入第二个第三个还是这样)
+ * 应该是ACPI_GPE_DISPATCH_METHOD
+ */
 u32
 acpi_ev_gpe_dispatch(struct acpi_namespace_node *gpe_device,
 		     struct acpi_gpe_event_info *gpe_event_info, u32 gpe_number)
@@ -795,6 +1091,9 @@ acpi_ev_gpe_dispatch(struct acpi_namespace_node *gpe_device,
 	 * If there is neither a handler nor a method, leave the GPE
 	 * disabled.
 	 */
+	/*
+	 * hot-add应该是ACPI_GPE_DISPATCH_METHOD
+	 */
 	switch (ACPI_GPE_DISPATCH_TYPE(gpe_event_info->flags)) {
 	case ACPI_GPE_DISPATCH_HANDLER:
 
@@ -816,6 +1115,37 @@ acpi_ev_gpe_dispatch(struct acpi_namespace_node *gpe_device,
 
 	case ACPI_GPE_DISPATCH_METHOD:
 	case ACPI_GPE_DISPATCH_NOTIFY:
+		/*
+		 * 在以下调用acpi_os_execute():
+		 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+		 *            acpi_db_execute_thread, NULL);
+		 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+		 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+		 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+		 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_notify_dispatch, info);
+		 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_notify_device_fixed, data);
+		 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+		 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            rbtn_clear_suspended_flag, rbtn_data);
+		 *
+		 *
+		 * struct acpi_gpe_block_info *gpe_block;
+		 * -> struct acpi_namespace_node *node; (gpe_device->name.ascii = "_GPE".)
+		 * -> struct acpi_gpe_register_info *register_info;
+		 * -> struct acpi_gpe_event_info *event_info;
+		 *
+		 * debug测试的时候只有i=0, j=1执行了这里
+		 * gpe_number=1
+		 * (插入第二个第三个还是这样)
+		 * 应该是ACPI_GPE_DISPATCH_METHOD
+		 */
 		/*
 		 * Execute the method associated with the GPE
 		 * NOTE: Level-triggered GPEs are cleared after the method completes.
diff --git a/drivers/acpi/acpica/evmisc.c b/drivers/acpi/acpica/evmisc.c
index f14ebcd610ab..8e5f031301d7 100644
--- a/drivers/acpi/acpica/evmisc.c
+++ b/drivers/acpi/acpica/evmisc.c
@@ -64,11 +64,92 @@ u8 acpi_ev_is_notify_object(struct acpi_namespace_node *node)
  *
  ******************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ *
+ * [0] acpi_hotplug_schedule
+ * [0] acpi_bus_notify
+ * [0] acpi_ev_notify_dispatch
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * static acpi_execute_op acpi_gbl_op_type_dispatch[] = {
+ *     acpi_ex_opcode_0A_0T_1R,
+ *     acpi_ex_opcode_1A_0T_0R,
+ *     acpi_ex_opcode_1A_0T_1R,
+ *     acpi_ex_opcode_1A_1T_0R,
+ *     acpi_ex_opcode_1A_1T_1R,
+ *     acpi_ex_opcode_2A_0T_0R,
+ *     acpi_ex_opcode_2A_0T_1R,
+ *     acpi_ex_opcode_2A_1T_1R,
+ *     acpi_ex_opcode_2A_2T_1R,
+ *     acpi_ex_opcode_3A_0T_0R,
+ *     acpi_ex_opcode_3A_1T_1R,
+ *     acpi_ex_opcode_6A_0T_1R
+ *
+ * 在以下使用acpi_ev_queue_notify_request():
+ *   - drivers/acpi/acpica/dbcmds.c|386| <<acpi_db_send_notify>> status = acpi_ev_queue_notify_request(node, value);
+ *   - drivers/acpi/acpica/evgpe.c|482| <<acpi_ev_asynch_execute_gpe_method>> acpi_ev_queue_notify_request(notify->device_node, ACPI_NOTIFY_DEVICE_WAKE);
+ *   - drivers/acpi/acpica/exoparg2.c|96| <<acpi_ex_opcode_2A_0T_0R>> status = acpi_ev_queue_notify_request(node, value);
+ *
+ * 要看acpi_ex_opcode_2A_0T_0R()!!!
+ */
 acpi_status
 acpi_ev_queue_notify_request(struct acpi_namespace_node *node, u32 notify_value)
 {
 	union acpi_operand_object *obj_desc;
 	union acpi_operand_object *handler_list_head = NULL;
+	/*
+	 * union acpi_generic_state {
+	 *     struct acpi_common_state common;
+	 *     struct acpi_control_state control;
+	 *     struct acpi_update_state update;
+	 *     struct acpi_scope_state scope;
+	 *     struct acpi_pscope_state parse_scope;
+	 *     struct acpi_pkg_state pkg;
+	 *     struct acpi_thread_state thread;
+	 *     struct acpi_result_values results;
+	 *     struct acpi_notify_info notify;
+	 * };
+	 */
 	union acpi_generic_state *info;
 	u8 handler_list_id = 0;
 	acpi_status status = AE_OK;
@@ -116,6 +197,18 @@ acpi_ev_queue_notify_request(struct acpi_namespace_node *node, u32 notify_value)
 
 	/* Setup notify info and schedule the notify dispatcher */
 
+	/*
+	 * 在以下调用acpi_ut_create_generic_state():
+	 *   - drivers/acpi/acpica/dswscope.c|92| <<acpi_ds_scope_stack_push>> scope_info = acpi_ut_create_generic_state();
+	 *   - drivers/acpi/acpica/dswstate.c|198| <<acpi_ds_result_stack_push>> state = acpi_ut_create_generic_state();
+	 *   - drivers/acpi/acpica/evmisc.c|184| <<acpi_ev_queue_notify_request>> info = acpi_ut_create_generic_state();
+	 *   - drivers/acpi/acpica/psscope.c|78| <<acpi_ps_init_scope>> scope = acpi_ut_create_generic_state();
+	 *   - drivers/acpi/acpica/psscope.c|119| <<acpi_ps_push_scope>> scope = acpi_ut_create_generic_state();
+	 *   - drivers/acpi/acpica/utstate.c|121| <<acpi_ut_create_thread_state>> state = acpi_ut_create_generic_state();
+	 *   - drivers/acpi/acpica/utstate.c|165| <<acpi_ut_create_update_state>> state = acpi_ut_create_generic_state();
+	 *   - drivers/acpi/acpica/utstate.c|201| <<acpi_ut_create_pkg_state>> state = acpi_ut_create_generic_state();
+	 *   - drivers/acpi/acpica/utstate.c|238| <<acpi_ut_create_control_state>> state = acpi_ut_create_generic_state();
+	 */
 	info = acpi_ut_create_generic_state();
 	if (!info) {
 		return (AE_NO_MEMORY);
@@ -123,12 +216,40 @@ acpi_ev_queue_notify_request(struct acpi_namespace_node *node, u32 notify_value)
 
 	info->common.descriptor_type = ACPI_DESC_TYPE_STATE_NOTIFY;
 
+	/*
+	 * union acpi_generic_state *info;
+	 * -> struct acpi_notify_info notify;
+	 *    -> struct acpi_namespace_node *node;
+	 */
 	info->notify.node = node;
 	info->notify.value = (u16)notify_value;
 	info->notify.handler_list_id = handler_list_id;
 	info->notify.handler_list_head = handler_list_head;
 	info->notify.global = &acpi_gbl_global_notify[handler_list_id];
 
+	/*
+	 * Add第一个PCI.
+	 * acpi_ut_get_node_name(node) = "S00_"
+	 * acpi_ut_get_type_name(node->type) = "Device"
+	 * notify_value = 0x01
+	 * acpi_ut_get_notify_name(notify_value, ACPI_TYPE_ANY) = "Device Check"
+	 * node = "0000000000dc4999"
+	 *
+	 * Add第二个PCI.
+	 * acpi_ut_get_node_name(node) = "S00_"
+	 * acpi_ut_get_type_name(node->type) = "Device"
+	 * notify_value = 0x01
+	 * acpi_ut_get_notify_name(notify_value, ACPI_TYPE_ANY) = "Device Check"
+	 * node = "00000000864355e2"
+	 *
+	 * 然后删除:
+	 * Dispatching Notify on [S00_] (Device) Value 0x03 (Eject Request) Node 00000000864355e2
+	 *
+	 * 再Add一次第二个.
+	 * Dispatching Notify on [S00_] (Device) Value 0x01 (Device Check) Node 00000000864355e2
+	 *
+	 * acpi_ut_get_notify_name()竟然编译不过???
+	 */
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  "Dispatching Notify on [%4.4s] (%s) Value 0x%2.2X (%s) Node %p\n",
 			  acpi_ut_get_node_name(node),
@@ -136,6 +257,35 @@ acpi_ev_queue_notify_request(struct acpi_namespace_node *node, u32 notify_value)
 			  acpi_ut_get_notify_name(notify_value, ACPI_TYPE_ANY),
 			  node));
 
+	/*
+	 * 在以下调用acpi_os_execute():
+	 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+	 *            acpi_db_execute_thread, NULL);
+	 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+	 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+	 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+	 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_notify_dispatch, info);
+	 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_notify_device_fixed, data);
+	 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+	 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            rbtn_clear_suspended_flag, rbtn_data);
+	 *
+	 * [0] acpi_hotplug_schedule
+	 * [0] acpi_bus_notify
+	 * [0] acpi_ev_notify_dispatch
+	 * [0] acpi_os_execute_deferred
+	 * [0] process_one_work
+	 * [0] worker_thread
+	 * [0] kthread
+	 * [0] ret_from_fork
+	 */
 	status = acpi_os_execute(OSL_NOTIFY_HANDLER,
 				 acpi_ev_notify_dispatch, info);
 	if (ACPI_FAILURE(status)) {
@@ -158,6 +308,57 @@ acpi_ev_queue_notify_request(struct acpi_namespace_node *node, u32 notify_value)
  *
  ******************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ *
+ *
+ * [0] acpi_hotplug_schedule
+ * [0] acpi_bus_notify
+ * [0] acpi_ev_notify_dispatch
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下使用acpi_ev_notify_dispatch():
+ *   - drivers/acpi/acpica/evmisc.c|160| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_ev_notify_dispatch, info);
+ */
 static void ACPI_SYSTEM_XFACE acpi_ev_notify_dispatch(void *context)
 {
 	union acpi_generic_state *info = (union acpi_generic_state *)context;
@@ -165,6 +366,20 @@ static void ACPI_SYSTEM_XFACE acpi_ev_notify_dispatch(void *context)
 
 	ACPI_FUNCTION_ENTRY();
 
+	/*
+	 * union acpi_generic_state *info:
+	 * -> struct acpi_notify_info notify;
+	 *    -> struct acpi_namespace_node *node;
+	 *
+	 * 在以下使用acpi_bus_notify():
+	 *   -  drivers/acpi/bus.c|1335| <<acpi_bus_init>> status =
+	 *                  acpi_install_notify_handler(ACPI_ROOT_OBJECT, ACPI_SYSTEM_NOTIFY,
+	 *                                              &acpi_bus_notify, NULL);
+	 *
+	 * 定义是:
+	 * static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
+	 */
+
 	/* Invoke a global notify handler if installed */
 
 	if (info->notify.global->handler) {
diff --git a/drivers/acpi/acpica/evsci.c b/drivers/acpi/acpica/evsci.c
index 3915ff61412b..3213f53c03b3 100644
--- a/drivers/acpi/acpica/evsci.c
+++ b/drivers/acpi/acpica/evsci.c
@@ -73,6 +73,51 @@ u32 acpi_ev_sci_dispatch(void)
  *
  ******************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下使用acpi_ev_sci_xrupt_handler():
+ *   - drivers/acpi/acpica/evsci.c|171| <<acpi_ev_install_sci_handler>> status =
+ *                 acpi_os_install_interrupt_handler((u32) acpi_gbl_FADT.sci_interrupt,
+ *                 cpi_ev_sci_xrupt_handler, acpi_gbl_gpe_xrupt_list_head);
+ *   - drivers/acpi/acpica/evsci.c|207| <<acpi_ev_remove_all_sci_handlers>> status =
+ *                 acpi_os_remove_interrupt_handler((u32) acpi_gbl_FADT.sci_interrupt,
+ *                 acpi_ev_sci_xrupt_handler);
+ */
 static u32 ACPI_SYSTEM_XFACE acpi_ev_sci_xrupt_handler(void *context)
 {
 	struct acpi_gpe_xrupt_info *gpe_xrupt_list = context;
@@ -91,6 +136,19 @@ static u32 ACPI_SYSTEM_XFACE acpi_ev_sci_xrupt_handler(void *context)
 	 */
 	interrupt_handled |= acpi_ev_fixed_event_detect();
 
+	/*
+	 * [0] acpi_os_execute
+	 * [0] acpi_ev_gpe_dispatch
+	 * [0] acpi_ev_detect_gpe
+	 * [0] acpi_ev_gpe_detect
+	 * [0] acpi_ev_sci_xrupt_handler
+	 * [0] acpi_irq
+	 * [0] __handle_irq_event_percpu
+	 * [0] handle_irq_event
+	 * [0] handle_fasteoi_irq
+	 * [0] __common_interrupt
+	 * [0] common_interrupt
+	 */
 	/*
 	 * General Purpose Events:
 	 * Check for and dispatch any GPEs that have occurred
diff --git a/drivers/acpi/acpica/exoparg2.c b/drivers/acpi/acpica/exoparg2.c
index 10323ab186da..f448ed795277 100644
--- a/drivers/acpi/acpica/exoparg2.c
+++ b/drivers/acpi/acpica/exoparg2.c
@@ -52,8 +52,66 @@ ACPI_MODULE_NAME("exoparg2")
  * ALLOCATION:  Deletes both operands
  *
  ******************************************************************************/
+/*
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq         
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt     
+ *                            
+ * [0] acpi_os_execute       
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op  
+ * [0] acpi_ps_parse_loop   
+ * [0] acpi_ps_parse_aml        
+ * [0] acpi_ps_execute_method   
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work         
+ * [0] worker_thread            
+ * [0] kthread                      
+ * [0] ret_from_fork                                            
+ *                                                              
+ * [0] acpi_os_execute          
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred         
+ * [0] process_one_work                         
+ * [0] worker_thread                                            
+ * [0] kthread                          
+ * [0] ret_from_fork
+ *
+ *
+ * static acpi_execute_op acpi_gbl_op_type_dispatch[] = {
+ *     acpi_ex_opcode_0A_0T_1R,
+ *     acpi_ex_opcode_1A_0T_0R,
+ *     acpi_ex_opcode_1A_0T_1R,
+ *     acpi_ex_opcode_1A_1T_0R,
+ *     acpi_ex_opcode_1A_1T_1R,
+ *     acpi_ex_opcode_2A_0T_0R,
+ *     acpi_ex_opcode_2A_0T_1R,
+ *     acpi_ex_opcode_2A_1T_1R,
+ *     acpi_ex_opcode_2A_2T_1R,
+ *     acpi_ex_opcode_3A_0T_0R,
+ *     acpi_ex_opcode_3A_1T_1R,
+ *     acpi_ex_opcode_6A_0T_1R
+ * };
+ *
+ * 在以下使用acpi_gbl_op_type_dispatch[]:
+ *   - drivers/acpi/acpica/dswexec.c|453| <<acpi_ds_exec_end_op>> acpi_gbl_op_type_dispatch[op_type] (walk_state);
+ */
 acpi_status acpi_ex_opcode_2A_0T_0R(struct acpi_walk_state *walk_state)
 {
+	/*
+	 * struct acpi_walk_state *walk_state;
+	 * -> union acpi_operand_object *operands[ACPI_OBJ_NUM_OPERANDS + 1];
+	 */
 	union acpi_operand_object **operand = &walk_state->operands[0];
 	struct acpi_namespace_node *node;
 	u32 value;
@@ -93,6 +151,9 @@ acpi_status acpi_ex_opcode_2A_0T_0R(struct acpi_walk_state *walk_state)
 		 * from this thread -- because handlers may in turn run other
 		 * control methods.
 		 */
+		/*
+		 * 执行这里!!!
+		 */
 		status = acpi_ev_queue_notify_request(node, value);
 		break;
 
diff --git a/drivers/acpi/acpica/nseval.c b/drivers/acpi/acpica/nseval.c
index 63748ac699f7..a10aa62022ed 100644
--- a/drivers/acpi/acpica/nseval.c
+++ b/drivers/acpi/acpica/nseval.c
@@ -39,6 +39,127 @@ ACPI_MODULE_NAME("nseval")
  * MUTEX:       Locks interpreter
  *
  ******************************************************************************/
+/*
+ * _SB.PCI0.S29.S00._ADR (Integer)
+ *
+ * [0] acpi_ns_evaluate+0xe7/0x2ae
+ * [0] acpi_evaluate_object
+ * [0] acpi_evaluate_integer
+ * [0] acpi_find_child_device
+ * [0] acpi_pci_find_companion
+ * [0] pci_set_acpi_fwnode
+ * [0] pci_setup_device
+ * [0] pci_scan_single_device
+ * [0] pci_scan_slot
+ * [0] acpiphp_hotplug_notify
+ * [0] acpi_device_hotplug
+ * [0] acpi_hotplug_work_fn
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ *
+ * struct acpi_gpe_block_info *gpe_block;
+ * -> struct acpi_namespace_node *node; (gpe_device->name.ascii = "_GPE".)
+ * -> struct acpi_gpe_register_info *register_info;
+ * -> struct acpi_gpe_event_info *event_info;
+ *
+ * debug测试的时候只有i=0, j=1执行了这里
+ * gpe_number=1
+ * (插入第二个第三个还是这样)
+ * 应该是ACPI_GPE_DISPATCH_METHOD
+ *
+ * 这里测试的
+ * acpi_ut_get_node_name(gpe_event_info->dispatch.method_node)是"_E01"
+ *
+ *     Scope (_GPE)
+ *     {
+ *         Method (_E01, 0, NotSerialized)  // _Exx: Edge-Triggered GPE, xx=0x00-0xFF
+ *         {
+ *             Acquire (\_SB.PCI0.BLCK, 0xFFFF)
+ *             \_SB.PCI0.PCNT ()
+ *             Release (\_SB.PCI0.BLCK)
+ *         }
+ *     }
+ *
+ *         Method (PCNT, 0, NotSerialized)
+ *         {
+ *             ^S2C.PCNT ()
+ *             ^S2A.PCNT ()
+ *             ^S29.PCNT ()
+ *             ^S28.PCNT ()
+ *             ^S27.PCNT ()
+ *         }
+ *
+ * 其中一个例子
+ *        Scope (S29)
+ *         {
+ *             Method (PCNT, 0, NotSerialized)
+ *             {
+ *                 BNUM = 0x02
+ *                 DVNT (PCIU, One)
+ *                 DVNT (PCID, 0x03)
+ *             }
+ *         }
+ *
+ *
+ *                 Method (DVNT, 2, NotSerialized)
+ *                 {
+ *                     If ((Arg0 & One))
+ *                     {
+ *                         Notify (S00, Arg1)
+ *                     }
+ *                }
+ *
+ * 在以下调用acpi_ns_evaluate():
+ *   - drivers/acpi/acpica/evgpe.c|598| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_ns_evaluate(info);
+ *   - drivers/acpi/acpica/evregion.c|630| <<acpi_ev_execute_reg_method>> status = acpi_ns_evaluate(info);
+ *   - drivers/acpi/acpica/hwxface.c|362| <<acpi_get_sleep_type_data>> status = acpi_ns_evaluate(info);
+ *   - drivers/acpi/acpica/nsinit.c|156| <<acpi_ns_initialize_devices>> status = acpi_ns_evaluate(info.evaluate_info);
+ *   - drivers/acpi/acpica/nsinit.c|176| <<acpi_ns_initialize_devices>> status = acpi_ns_evaluate(info.evaluate_info);
+ *   - drivers/acpi/acpica/nsinit.c|645| <<acpi_ns_init_one_device>> status = acpi_ns_evaluate(info);
+ *   - drivers/acpi/acpica/nsxfeval.c|354| <<acpi_evaluate_object>> status = acpi_ns_evaluate(info);
+ *   - drivers/acpi/acpica/rsutils.c|746| <<acpi_rs_set_srs_method_data>> status = acpi_ns_evaluate(info);
+ *   - drivers/acpi/acpica/uteval.c|60| <<acpi_ut_evaluate_object>> status = acpi_ns_evaluate(info);
+ */
 acpi_status acpi_ns_evaluate(struct acpi_evaluate_info *info)
 {
 	acpi_status status;
@@ -49,6 +170,10 @@ acpi_status acpi_ns_evaluate(struct acpi_evaluate_info *info)
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
 	}
 
+	/*
+	 * 从acpi_ev_asynch_execute_gpe_method()过来的话
+	 * 感觉就设置了prefix_node和flags
+	 */
 	if (!info->node) {
 		/*
 		 * Get the actual namespace node for the target object if we
@@ -100,6 +225,15 @@ acpi_status acpi_ns_evaluate(struct acpi_evaluate_info *info)
 
 	/* Optional object evaluation log */
 
+	/*
+	 * 从acpi_ev_asynch_execute_gpe_method()进来
+	 * 这里"%s (%s)\n"显示的是:
+	 * "_GPE._E01 (Method)"
+	 *
+	 * 从这里接着往下走, 怎么变成了ACPI的handle的呢???
+	 *
+	 * BTW, 稍后来到这里的时候是"_SB.PCI0.S2A.S00._DSM (Method)"
+	 */
 	ACPI_DEBUG_PRINT_RAW((ACPI_DB_EVALUATION,
 			      "%-26s:  %s (%s)\n", "   Enter evaluation",
 			      &info->full_pathname[1],
@@ -202,6 +336,10 @@ acpi_status acpi_ns_evaluate(struct acpi_evaluate_info *info)
 		 * here before calling into the AML parser
 		 */
 		acpi_ex_enter_interpreter();
+		/*
+		 * 这里吧
+		 * 只在这里调用
+		 */
 		status = acpi_ps_execute_method(info);
 		acpi_ex_exit_interpreter();
 		break;
diff --git a/drivers/acpi/acpica/nsnames.c b/drivers/acpi/acpica/nsnames.c
index d91153f65700..00adf10529ea 100644
--- a/drivers/acpi/acpica/nsnames.c
+++ b/drivers/acpi/acpica/nsnames.c
@@ -137,6 +137,9 @@ acpi_ns_handle_to_pathname(acpi_handle target_handle,
 
 	ACPI_FUNCTION_TRACE_PTR(ns_handle_to_pathname, target_handle);
 
+	/*
+	 * struct acpi_namespace_node *node;
+	 */
 	node = acpi_ns_validate_handle(target_handle);
 	if (!node) {
 		return_ACPI_STATUS(AE_BAD_PARAMETER);
diff --git a/drivers/acpi/acpica/nsxfeval.c b/drivers/acpi/acpica/nsxfeval.c
index f9d059647cc5..9c8a396ee144 100644
--- a/drivers/acpi/acpica/nsxfeval.c
+++ b/drivers/acpi/acpica/nsxfeval.c
@@ -922,6 +922,13 @@ ACPI_EXPORT_SYMBOL(acpi_detach_data)
  *              and execute a callback before returning.
  *
  ******************************************************************************/
+/*
+ * 在以下调用acpi_get_data_full():
+ *   - drivers/acpi/acpica/nsxfeval.c|979| <<acpi_get_data>> return acpi_get_data_full(obj_handle, handler, data, NULL);
+ *   - drivers/acpi/scan.c|576| <<acpi_get_data>> status = acpi_get_data_full(handle, acpi_scan_drop_device, (void **)&adev, callback);
+ *
+ * callback的一个例子是get_acpi_device()
+ */
 acpi_status
 acpi_get_data_full(acpi_handle obj_handle, acpi_object_handler handler,
 		   void **data, void (*callback)(void *))
@@ -950,6 +957,9 @@ acpi_get_data_full(acpi_handle obj_handle, acpi_object_handler handler,
 
 	status = acpi_ns_get_attached_data(node, handler, data);
 	if (ACPI_SUCCESS(status) && callback) {
+		/*
+		 * 比如get_acpi_device()
+		 */
 		callback(*data);
 	}
 
diff --git a/drivers/acpi/acpica/nsxfname.c b/drivers/acpi/acpica/nsxfname.c
index 03487546da5a..76caa414d8a2 100644
--- a/drivers/acpi/acpica/nsxfname.c
+++ b/drivers/acpi/acpica/nsxfname.c
@@ -145,6 +145,9 @@ acpi_get_name(acpi_handle handle, u32 name_type, struct acpi_buffer *buffer)
 		return (status);
 	}
 
+	/*
+	 * 应该是ACPI_FULL_PATHNAME
+	 */
 	if (name_type == ACPI_FULL_PATHNAME ||
 	    name_type == ACPI_FULL_PATHNAME_NO_TRAILING) {
 
diff --git a/drivers/acpi/acpica/psloop.c b/drivers/acpi/acpica/psloop.c
index 4b51dd939f29..7b4f74ecdb73 100644
--- a/drivers/acpi/acpica/psloop.c
+++ b/drivers/acpi/acpica/psloop.c
@@ -218,6 +218,43 @@ acpi_ps_get_arguments(struct acpi_walk_state *walk_state,
  *
  ******************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ */
 acpi_status acpi_ps_parse_loop(struct acpi_walk_state *walk_state)
 {
 	acpi_status status = AE_OK;
@@ -522,6 +559,10 @@ acpi_status acpi_ps_parse_loop(struct acpi_walk_state *walk_state)
 			walk_state->op = op;
 			walk_state->opcode = op->common.aml_opcode;
 
+			/*
+			 * 这里很重要
+			 * acpi_ds_exec_end_op()
+			 */
 			status = walk_state->ascending_callback(walk_state);
 			status =
 			    acpi_ps_next_parse_state(walk_state, op, status);
diff --git a/drivers/acpi/acpica/psparse.c b/drivers/acpi/acpica/psparse.c
index 7eb7a81619a3..6155b1a12690 100644
--- a/drivers/acpi/acpica/psparse.c
+++ b/drivers/acpi/acpica/psparse.c
@@ -405,6 +405,43 @@ acpi_ps_next_parse_state(struct acpi_walk_state *walk_state,
  *
  ******************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ */
 acpi_status acpi_ps_parse_aml(struct acpi_walk_state *walk_state)
 {
 	acpi_status status;
@@ -472,6 +509,9 @@ acpi_status acpi_ps_parse_aml(struct acpi_walk_state *walk_state)
 			 * The parse_loop executes AML until the method terminates
 			 * or calls another method.
 			 */
+			/*
+			 * 在这里????
+			 */
 			status = acpi_ps_parse_loop(walk_state);
 		}
 
diff --git a/drivers/acpi/acpica/psxface.c b/drivers/acpi/acpica/psxface.c
index fd0f28c7af1e..f5ebc868ac0b 100644
--- a/drivers/acpi/acpica/psxface.c
+++ b/drivers/acpi/acpica/psxface.c
@@ -81,6 +81,47 @@ acpi_debug_trace(const char *name, u32 debug_level, u32 debug_layer, u32 flags)
  *
  ******************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ *
+ * 在以下使用acpi_ps_execute_method():
+ *   - drivers/acpi/acpica/nseval.c|313| <<acpi_ns_evaluate>> status = acpi_ps_execute_method(info);
+ */
 acpi_status acpi_ps_execute_method(struct acpi_evaluate_info *info)
 {
 	acpi_status status;
@@ -187,6 +228,9 @@ acpi_status acpi_ps_execute_method(struct acpi_evaluate_info *info)
 
 	/* Parse the AML */
 
+	/*
+	 * 在这里??
+	 */
 	status = acpi_ps_parse_aml(walk_state);
 
 	/* walk_state was deleted by parse_aml */
diff --git a/drivers/acpi/acpica/utstate.c b/drivers/acpi/acpica/utstate.c
index a2484556a6b5..512c874c95c0 100644
--- a/drivers/acpi/acpica/utstate.c
+++ b/drivers/acpi/acpica/utstate.c
@@ -81,6 +81,18 @@ union acpi_generic_state *acpi_ut_pop_generic_state(union acpi_generic_state
  *
  ******************************************************************************/
 
+/*
+ * 在以下调用acpi_ut_create_generic_state():
+ *   - drivers/acpi/acpica/dswscope.c|92| <<acpi_ds_scope_stack_push>> scope_info = acpi_ut_create_generic_state();
+ *   - drivers/acpi/acpica/dswstate.c|198| <<acpi_ds_result_stack_push>> state = acpi_ut_create_generic_state();
+ *   - drivers/acpi/acpica/evmisc.c|184| <<acpi_ev_queue_notify_request>> info = acpi_ut_create_generic_state();
+ *   - drivers/acpi/acpica/psscope.c|78| <<acpi_ps_init_scope>> scope = acpi_ut_create_generic_state();
+ *   - drivers/acpi/acpica/psscope.c|119| <<acpi_ps_push_scope>> scope = acpi_ut_create_generic_state();
+ *   - drivers/acpi/acpica/utstate.c|121| <<acpi_ut_create_thread_state>> state = acpi_ut_create_generic_state();
+ *   - drivers/acpi/acpica/utstate.c|165| <<acpi_ut_create_update_state>> state = acpi_ut_create_generic_state();
+ *   - drivers/acpi/acpica/utstate.c|201| <<acpi_ut_create_pkg_state>> state = acpi_ut_create_generic_state();
+ *   - drivers/acpi/acpica/utstate.c|238| <<acpi_ut_create_control_state>> state = acpi_ut_create_generic_state();
+ */
 union acpi_generic_state *acpi_ut_create_generic_state(void)
 {
 	union acpi_generic_state *state;
diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 30938e61d54b..952e4f397ed8 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -445,6 +445,22 @@ static void acpi_bus_osc_negotiate_usb_control(void)
  * ---------------
  * Callback for all 'system-level' device notifications (values 0x00-0x7F).
  */
+/*
+ * [0] acpi_hotplug_schedule
+ * [0] acpi_bus_notify
+ * [0] acpi_ev_notify_dispatch
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ *
+ * 在以下使用acpi_bus_notify():
+ *   -  drivers/acpi/bus.c|1335| <<acpi_bus_init>> status =
+ *                  acpi_install_notify_handler(ACPI_ROOT_OBJECT, ACPI_SYSTEM_NOTIFY,
+ *                                              &acpi_bus_notify, NULL);
+ */
 static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 {
 	struct acpi_device *adev;
@@ -496,6 +512,14 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 	}
 
+	/*
+	 * 在以下调用acpi_bus_get_acpi_device():
+	 *   - drivers/acpi/bus.c|508| <<acpi_bus_notify>> adev = acpi_bus_get_acpi_device(handle);
+	 *   - drivers/acpi/device_pm.c|447| <<acpi_pm_notify_handler>> adev = acpi_bus_get_acpi_device(handle);
+	 *   - drivers/acpi/irq.c|127| <<acpi_get_irq_source_fwhandle>> device = acpi_bus_get_acpi_device(handle);
+	 *   - drivers/acpi/scan.c|2223| <<acpi_dev_get_first_consumer_dev_cb>> adev = acpi_bus_get_acpi_device(dep->consumer);
+	 *   - drivers/acpi/scan.c|2276| <<acpi_scan_clear_dep>> struct acpi_device *adev = acpi_bus_get_acpi_device(dep->consumer);
+	 */
 	adev = acpi_bus_get_acpi_device(handle);
 	if (!adev)
 		goto err;
@@ -536,6 +560,26 @@ static void acpi_notify_device_fixed(void *data)
 
 static u32 acpi_device_fixed_event(void *data)
 {
+	/*
+	 * 在以下调用acpi_os_execute():
+	 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+	 *            acpi_db_execute_thread, NULL);
+	 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+	 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+	 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+	 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_notify_dispatch, info);
+	 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_notify_device_fixed, data);
+	 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+	 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            rbtn_clear_suspended_flag, rbtn_data);
+	 */
 	acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_notify_device_fixed, data);
 	return ACPI_INTERRUPT_HANDLED;
 }
diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 45c5c0e45e33..11d816d0f3ba 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -63,6 +63,12 @@ static int (*__acpi_os_prepare_extended_sleep)(u8 sleep_state, u32 val_a,
 				      u32 val_b);
 
 static acpi_osd_handler acpi_irq_handler;
+/*
+ * 在以下使用acpi_irq_context:
+ *   - drivers/acpi/osl.c|66| <<global>> static void *acpi_irq_context;
+ *   - drivers/acpi/osl.c|550| <<acpi_irq>> handled = (*acpi_irq_handler) (acpi_irq_context);
+ *   - drivers/acpi/osl.c|585| <<acpi_os_install_interrupt_handler>> acpi_irq_context = context;
+ */
 static void *acpi_irq_context;
 static struct workqueue_struct *kacpid_wq;
 static struct workqueue_struct *kacpi_notify_wq;
@@ -547,6 +553,12 @@ static irqreturn_t acpi_irq(int irq, void *dev_id)
 {
 	u32 handled;
 
+	/*
+	 * 在以下使用acpi_irq_context:
+	 *   - drivers/acpi/osl.c|66| <<global>> static void *acpi_irq_context;
+	 *   - drivers/acpi/osl.c|550| <<acpi_irq>> handled = (*acpi_irq_handler) (acpi_irq_context);
+	 *   - drivers/acpi/osl.c|585| <<acpi_os_install_interrupt_handler>> acpi_irq_context = context;
+	 */
 	handled = (*acpi_irq_handler) (acpi_irq_context);
 
 	if (handled) {
@@ -582,6 +594,12 @@ acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,
 	}
 
 	acpi_irq_handler = handler;
+	/*
+	 * 在以下使用acpi_irq_context:
+	 *   - drivers/acpi/osl.c|66| <<global>> static void *acpi_irq_context;
+	 *   - drivers/acpi/osl.c|550| <<acpi_irq>> handled = (*acpi_irq_handler) (acpi_irq_context);
+	 *   - drivers/acpi/osl.c|585| <<acpi_os_install_interrupt_handler>> acpi_irq_context = context;
+	 */
 	acpi_irq_context = context;
 	if (request_irq(irq, acpi_irq, IRQF_SHARED, "acpi", acpi_irq)) {
 		pr_err("SCI (IRQ%d) allocation failed\n", irq);
@@ -841,8 +859,20 @@ acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 }
 #endif
 
+/*
+ * 在以下使用acpi_os_execute_deferred():
+ *   - drivers/acpi/osl.c|1104| <<acpi_os_execute>> INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+ *   - drivers/acpi/osl.c|1107| <<acpi_os_execute>> INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+ */
 static void acpi_os_execute_deferred(struct work_struct *work)
 {
+	/*
+	 * struct acpi_os_dpc {
+	 *     acpi_osd_exec_callback function;
+	 *     void *context;
+	 *     struct work_struct work;
+	 * };
+	 */
 	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
 
 	dpc->function(dpc->context);
@@ -1058,6 +1088,65 @@ int __init acpi_debugger_init(void)
  *
  ******************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ *
+ * 在以下调用acpi_os_execute():
+ *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+ *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+ *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+ *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+ *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+ *            acpi_db_execute_thread, NULL);
+ *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+ *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+ *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+ *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+ *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+ *            acpi_ev_notify_dispatch, info);
+ *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+ *            acpi_notify_device_fixed, data);
+ *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+ *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+ *            rbtn_clear_suspended_flag, rbtn_data);
+ *
+ * hotplug的时候type好像是2, 1, 1
+ */
 acpi_status acpi_os_execute(acpi_execute_type type,
 			    acpi_osd_exec_callback function, void *context)
 {
@@ -1087,6 +1176,13 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	 * having a static work_struct.
 	 */
 
+	/*
+	 * struct acpi_os_dpc {
+	 *     acpi_osd_exec_callback function;
+	 *     void *context;
+	 *     struct work_struct work;
+	 * };
+	 */
 	dpc = kzalloc(sizeof(struct acpi_os_dpc), GFP_ATOMIC);
 	if (!dpc)
 		return AE_NO_MEMORY;
@@ -1152,6 +1248,18 @@ struct acpi_hp_work {
 	u32 src;
 };
 
+/*
+ * [0] acpiphp_hotplug_notify
+ * [0] acpi_device_hotplug
+ * [0] acpi_hotplug_work_fn
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下使用acpi_hotplug_work_fn():
+ *   - drivers/acpi/osl.c|1210| <<acpi_hotplug_schedule>> INIT_WORK(&hpw->work, acpi_hotplug_work_fn);
+ */
 static void acpi_hotplug_work_fn(struct work_struct *work)
 {
 	struct acpi_hp_work *hpw = container_of(work, struct acpi_hp_work, work);
@@ -1161,6 +1269,20 @@ static void acpi_hotplug_work_fn(struct work_struct *work)
 	kfree(hpw);
 }
 
+/*
+ * [0] acpi_hotplug_schedule
+ * [0] acpi_bus_notify
+ * [0] acpi_ev_notify_dispatch
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下调用acpi_hotplug_schedule():
+ *   - drivers/acpi/bus.c|522| <<acpi_bus_notify>> if (ACPI_SUCCESS(acpi_hotplug_schedule(adev, type)))
+ *   - drivers/acpi/device_sysfs.c|388| <<eject_store>> status = acpi_hotplug_schedule(acpi_device, ACPI_OST_EC_OSPM_EJECT);
+ */
 acpi_status acpi_hotplug_schedule(struct acpi_device *adev, u32 src)
 {
 	struct acpi_hp_work *hpw;
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e7d4a39e539f..77178c61b551 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -376,6 +376,83 @@ static int acpi_generic_hotplug_event(struct acpi_device *adev, u32 type)
 	return -EINVAL;
 }
 
+/*
+ * [  433.553792] <intr> acpi:624: ACPI: GPE event 0x01
+ * [  433.554104] [426] acpi:462: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: ACPI_NOTIFY_DEVICE_CHECK event
+ * [  433.554110] [426] acpi:1168: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: OSL: Scheduling hotplug event 1 for deferred handling
+ * [  433.554178] [97] acpiphp:803: ACPI: \_SB_.PCI0.S29_.S00_: acpiphp_glue: Device check in hotplug_event()
+ * [  433.554184] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._ADR: ACPI: No context!
+ * [  433.554186] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_.ASUN: ACPI: No context!
+ * [  433.554188] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._DSM: ACPI: No context!
+ * [  433.554190] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._SUN: ACPI: No context!
+ * [  433.554191] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._EJ0: ACPI: No context!
+ * [  433.554197] [97] acpi:28: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Evaluate [_STA]: AE_NOT_FOUND
+ * [  433.554199] [97] acpi:125: ACPI: Device [S00] status [0000000f]
+ * [  433.554356] [97] acpi:273: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Return value [0]
+ * [  433.554359] [97] acpi:273: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Return value [0]
+ * [  433.554419] pci 0000:02:00.0: [1af4:1048] type 00 class 0x010000
+ * [  433.555885] pci 0000:02:00.0: reg 0x14: [mem 0x00000000-0x00000fff]
+ * [  433.557122] pci 0000:02:00.0: reg 0x20: [mem 0x00000000-0x00003fff 64bit pref]
+ * [  433.559748] [97] edr:233: pci 0000:02:00.0: EDR: Notify handler installed
+ * [  433.559766] [97] acpi:324: wakeup wakeup15: No ACPI support
+ * [  433.559838] [97] acpi:318: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: Bound to device 0000:02:00.0
+ * [  433.560376] [97] acpi:28: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Evaluate [_STA]: AE_NOT_FOUND
+ * [  433.560402] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._ADR: ACPI: No context!
+ * [  433.560404] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_.ASUN: ACPI: No context!
+ * [  433.560405] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._DSM: ACPI: No context!
+ * [  433.560407] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._SUN: ACPI: No context!
+ * [  433.560409] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._EJ0: ACPI: No context!
+ * [  433.560411] [97] acpi:28: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Evaluate [_STA]: AE_NOT_FOUND
+ * [  433.560412] [97] acpi:125: ACPI: Device [S00] status [0000000f]
+ * [  433.560430] pci 0000:02:00.0: BAR 4: assigned [mem 0x802000000-0x802003fff 64bit pref]
+ * [  433.561843] pci 0000:02:00.0: BAR 1: assigned [mem 0x81200000-0x81200fff]
+ * [  433.563130] [97] acpi:1591: pciback 0000:02:00.0: Adding to IOMMU failed: -19
+ * [  433.563136] [97] setup_irq:27: pciback 0000:02:00.0: runtime IRQ mapping not provided by arch
+ * [  433.563161] [97] acpi:1591: virtio-pci 0000:02:00.0: Adding to IOMMU failed: -19
+ * [  433.563164] [97] setup_irq:27: virtio-pci 0000:02:00.0: runtime IRQ mapping not provided by arch
+ * [  433.563197] virtio-pci 0000:02:00.0: enabling device (0000 -> 0002)
+ * [  433.565778] [97] acpi:190: ACPI: PCI: 0000:00:05[A] -> \_SB_.GSIF[0]
+ * [  433.565782] [97] acpi:327: virtio-pci 0000:02:00.0: Derived GSI INT A from 0000:00:05.1
+ * [  433.565786] [97] acpi:649: ACPI: \_SB_.GSIF: ACPI: PCI: Link is referenced
+ * [  433.565791] [97] acpi:466: virtio-pci 0000:02:00.0: PCI INT A -> Link[GSIF] -> GSI 21 (level, high) -> IRQ 21
+ * [  433.566517] [97] pci:4371: virtio-pci 0000:02:00.0: enabling bus mastering
+ * [  433.567195] [97] acpi:324: virtio virtio1: No ACPI support
+ * [  433.567502] [97] acpi:324: workqueue scsi_tmf_7: No ACPI support
+ * [  433.568580] scsi host7: Virtio SCSI HBA
+ * [  433.569371] [97] acpi:324: scsi host7: No ACPI support
+ * [  433.569420] [97] acpi:324: scsi_host host7: No ACPI support
+ * [  433.574553] scsi 7:0:1:0: Direct-Access     LIO-ORG  storage02        4.0  PQ: 0 ANSI: 6
+ * [  433.589101] [1935] acpi:324: scsi target7:0:1: No ACPI support
+ * [  433.589137] scsi 7:0:1:0: alua: supports implicit and explicit TPGS
+ * [  433.590341] scsi 7:0:1:0: alua: device naa.6001405428c34d0d8a342cdbb4597c72 port group 0 rel port 1
+ * [  433.591927] [1935] acpi:324: scsi 7:0:1:0: No ACPI support
+ * [  433.591985] [1935] acpi:324: scsi_device 7:0:1:0: No ACPI support
+ * [  433.592021] [1935] acpi:324: scsi_generic sg3: No ACPI support
+ * [  433.592093] [105] acpi:324: scsi_disk 7:0:1:0: No ACPI support
+ * [  433.592302] sd 7:0:1:0: Attached scsi generic sg3 type 0
+ * [  433.592332] sd 7:0:1:0: [sdc] 262144 512-byte logical blocks: (134 MB/128 MiB)
+ * [  433.593213] [1935] acpi:324: bsg 7:0:1:0: No ACPI support
+ * [  433.594767] sd 7:0:1:0: [sdc] Write Protect is off
+ * [  433.595651] sd 7:0:1:0: [sdc] Mode Sense: 43 00 10 08
+ * [  433.595722] sd 7:0:1:0: [sdc] Write cache: enabled, read cache: enabled, supports DPO and FUA
+ * [  433.597263] sd 7:0:1:0: alua: transition timeout set to 60 seconds
+ * [  433.597270] sd 7:0:1:0: alua: port group 00 state A non-preferred supports TOlUSNA
+ * [  433.703687] sd 7:0:1:0: [sdc] Optimal transfer size 8388608 bytes
+ * [  433.705139] [105] acpi:324: block sdc: No ACPI support
+ * [  433.705660] [105] acpi:324: bdi 8:32: No ACPI support
+ * [  433.706272] sd 7:0:1:0: [sdc] Attached SCSI disk
+ *
+ * [0] acpiphp_hotplug_notify
+ * [0] acpi_device_hotplug
+ * [0] acpi_hotplug_work_fn
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下调用acpi_device_hotplug():
+ *   - drivers/acpi/osl.c|1250| <<acpi_hotplug_work_fn>> acpi_device_hotplug(hpw->adev, hpw->src);
+ */
 void acpi_device_hotplug(struct acpi_device *adev, u32 src)
 {
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
@@ -406,6 +483,9 @@ void acpi_device_hotplug(struct acpi_device *adev, u32 src)
 		 * There may be additional notify handlers for device objects
 		 * without the .event() callback, so ignore them here.
 		 */
+		/*
+		 * 应该是acpiphp_hotplug_notify()
+		 */
 		if (notify)
 			error = notify(adev, src);
 		else
@@ -567,12 +647,23 @@ static void acpi_scan_drop_device(acpi_handle handle, void *context)
 	mutex_unlock(&acpi_device_del_lock);
 }
 
+/*
+ * 在以下使用handle_to_device():
+ *   - drivers/acpi/scan.c|590| <<acpi_bus_get_device>> *device = handle_to_device(handle, NULL);
+ *   - drivers/acpi/scan.c|607| <<acpi_fetch_acpi_dev>> return handle_to_device(handle, NULL);
+ *   - drivers/acpi/scan.c|618| <<acpi_bus_get_acpi_device>> return handle_to_device(handle, get_acpi_device);
+ */
 static struct acpi_device *handle_to_device(acpi_handle handle,
 					    void (*callback)(void *))
 {
 	struct acpi_device *adev = NULL;
 	acpi_status status;
 
+	/*
+	 * 在以下调用acpi_get_data_full():
+	 *   - drivers/acpi/acpica/nsxfeval.c|979| <<acpi_get_data>> return acpi_get_data_full(obj_handle, handler, data, NULL);
+	 *   - drivers/acpi/scan.c|576| <<acpi_get_data>> status = acpi_get_data_full(handle, acpi_scan_drop_device, (void **)&adev, callback);
+	 */
 	status = acpi_get_data_full(handle, acpi_scan_drop_device,
 				    (void **)&adev, callback);
 	if (ACPI_FAILURE(status) || !adev) {
@@ -587,6 +678,12 @@ int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
 	if (!device)
 		return -EINVAL;
 
+	/*
+	 * 在以下使用handle_to_device():
+	 *   - drivers/acpi/scan.c|590| <<acpi_bus_get_device>> *device = handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|607| <<acpi_fetch_acpi_dev>> return handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|618| <<acpi_bus_get_acpi_device>> return handle_to_device(handle, get_acpi_device);
+	 */
 	*device = handle_to_device(handle, NULL);
 	if (!*device)
 		return -ENODEV;
@@ -604,6 +701,12 @@ EXPORT_SYMBOL(acpi_bus_get_device);
  */
 struct acpi_device *acpi_fetch_acpi_dev(acpi_handle handle)
 {
+	/*
+	 * 在以下使用handle_to_device():
+	 *   - drivers/acpi/scan.c|590| <<acpi_bus_get_device>> *device = handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|607| <<acpi_fetch_acpi_dev>> return handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|618| <<acpi_bus_get_acpi_device>> return handle_to_device(handle, get_acpi_device);
+	 */
 	return handle_to_device(handle, NULL);
 }
 EXPORT_SYMBOL_GPL(acpi_fetch_acpi_dev);
@@ -613,8 +716,22 @@ static void get_acpi_device(void *dev)
 	acpi_dev_get(dev);
 }
 
+/*
+ * 在以下调用acpi_bus_get_acpi_device():
+ *   - drivers/acpi/bus.c|508| <<acpi_bus_notify>> adev = acpi_bus_get_acpi_device(handle);
+ *   - drivers/acpi/device_pm.c|447| <<acpi_pm_notify_handler>> adev = acpi_bus_get_acpi_device(handle);
+ *   - drivers/acpi/irq.c|127| <<acpi_get_irq_source_fwhandle>> device = acpi_bus_get_acpi_device(handle);
+ *   - drivers/acpi/scan.c|2223| <<acpi_dev_get_first_consumer_dev_cb>> adev = acpi_bus_get_acpi_device(dep->consumer);
+ *   - drivers/acpi/scan.c|2276| <<acpi_scan_clear_dep>> struct acpi_device *adev = acpi_bus_get_acpi_device(dep->consumer);
+ */
 struct acpi_device *acpi_bus_get_acpi_device(acpi_handle handle)
 {
+	/*
+	 * 在以下使用handle_to_device():
+	 *   - drivers/acpi/scan.c|590| <<acpi_bus_get_device>> *device = handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|607| <<acpi_fetch_acpi_dev>> return handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|618| <<acpi_bus_get_acpi_device>> return handle_to_device(handle, get_acpi_device);
+	 */
 	return handle_to_device(handle, get_acpi_device);
 }
 
@@ -1793,6 +1910,25 @@ static void acpi_scan_init_status(struct acpi_device *adev)
 		acpi_set_device_status(adev, 0);
 }
 
+/*
+ * [0] acpi_add_single_object
+ * [0] acpi_bus_check_add
+ * [0] acpi_ns_walk_namespace
+ * [0] acpi_walk_namespace
+ * [0] acpi_bus_scan
+ * [0] acpi_scan_init
+ * [0] acpi_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * 在以下使用acpi_add_single_object():
+ *   - drivers/acpi/scan.c|2182| <<acpi_bus_check_add>> acpi_add_single_object(&device, handle, type, !check_dep);
+ *   - drivers/acpi/scan.c|2560| <<acpi_bus_register_early_device>> result = acpi_add_single_object(&device, NULL, type, false);
+ *   - drivers/acpi/scan.c|2579| <<acpi_bus_scan_fixed>> result = acpi_add_single_object(&device, NULL, ACPI_BUS_TYPE_POWER_BUTTON, false);
+ *   - drivers/acpi/scan.c|2595| <<acpi_bus_scan_fixed>> result = acpi_add_single_object(&device, NULL, ACPI_BUS_TYPE_SLEEP_BUTTON, false);
+ */
 static int acpi_add_single_object(struct acpi_device **child,
 				  acpi_handle handle, int type, bool dep_init)
 {
@@ -2014,6 +2150,13 @@ static u32 acpi_scan_check_dep(acpi_handle handle, bool check_dep)
 
 static bool acpi_bus_scan_second_pass;
 
+/*
+ * 在以下使用acpi_bus_check_add():
+ *   - drivers/acpi/scan.c|2198| <<acpi_bus_check_add_1>> return acpi_bus_check_add(handle, true, (struct acpi_device **)ret_p);
+ *   - drivers/acpi/scan.c|2204| <<acpi_bus_check_add_2>> return acpi_bus_check_add(handle, false, (struct acpi_device **)ret_p);
+ *   - drivers/acpi/scan.c|2494| <<acpi_bus_scan>> if (ACPI_SUCCESS(acpi_bus_check_add(handle, true, &device)))
+ *   - drivers/acpi/scan.c|2511| <<acpi_bus_scan>> if (ACPI_SUCCESS(acpi_bus_check_add(handle, false, &device)))
+ */
 static acpi_status acpi_bus_check_add(acpi_handle handle, bool check_dep,
 				      struct acpi_device **adev_p)
 {
@@ -2062,6 +2205,13 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, bool check_dep,
 	 * If check_dep is true at this point, the device has no dependencies,
 	 * or the creation of the device object would have been postponed above.
 	 */
+	/*
+	 * 在以下使用acpi_add_single_object():
+	 *   - drivers/acpi/scan.c|2182| <<acpi_bus_check_add>> acpi_add_single_object(&device, handle, type, !check_dep);
+	 *   - drivers/acpi/scan.c|2560| <<acpi_bus_register_early_device>> result = acpi_add_single_object(&device, NULL, type, false);
+	 *   - drivers/acpi/scan.c|2579| <<acpi_bus_scan_fixed>> result = acpi_add_single_object(&device, NULL, ACPI_BUS_TYPE_POWER_BUTTON, false);
+	 *   - drivers/acpi/scan.c|2595| <<acpi_bus_scan_fixed>> result = acpi_add_single_object(&device, NULL, ACPI_BUS_TYPE_SLEEP_BUTTON, false);
+	 */
 	acpi_add_single_object(&device, handle, type, !check_dep);
 	if (!device)
 		return AE_CTRL_DEPTH;
@@ -2078,12 +2228,26 @@ static acpi_status acpi_bus_check_add(acpi_handle handle, bool check_dep,
 static acpi_status acpi_bus_check_add_1(acpi_handle handle, u32 lvl_not_used,
 					void *not_used, void **ret_p)
 {
+	/*
+	 * 在以下使用acpi_bus_check_add():
+	 *   - drivers/acpi/scan.c|2198| <<acpi_bus_check_add_1>> return acpi_bus_check_add(handle, true, (struct acpi_device **)ret_p);
+	 *   - drivers/acpi/scan.c|2204| <<acpi_bus_check_add_2>> return acpi_bus_check_add(handle, false, (struct acpi_device **)ret_p);
+	 *   - drivers/acpi/scan.c|2494| <<acpi_bus_scan>> if (ACPI_SUCCESS(acpi_bus_check_add(handle, true, &device)))
+	 *   - drivers/acpi/scan.c|2511| <<acpi_bus_scan>> if (ACPI_SUCCESS(acpi_bus_check_add(handle, false, &device)))
+	 */
 	return acpi_bus_check_add(handle, true, (struct acpi_device **)ret_p);
 }
 
 static acpi_status acpi_bus_check_add_2(acpi_handle handle, u32 lvl_not_used,
 					void *not_used, void **ret_p)
 {
+	/*
+	 * 在以下使用acpi_bus_check_add():
+	 *   - drivers/acpi/scan.c|2198| <<acpi_bus_check_add_1>> return acpi_bus_check_add(handle, true, (struct acpi_device **)ret_p);
+	 *   - drivers/acpi/scan.c|2204| <<acpi_bus_check_add_2>> return acpi_bus_check_add(handle, false, (struct acpi_device **)ret_p);
+	 *   - drivers/acpi/scan.c|2494| <<acpi_bus_scan>> if (ACPI_SUCCESS(acpi_bus_check_add(handle, true, &device)))
+	 *   - drivers/acpi/scan.c|2511| <<acpi_bus_scan>> if (ACPI_SUCCESS(acpi_bus_check_add(handle, false, &device)))
+	 */
 	return acpi_bus_check_add(handle, false, (struct acpi_device **)ret_p);
 }
 
@@ -2374,6 +2538,13 @@ int acpi_bus_scan(acpi_handle handle)
 
 	/* Pass 1: Avoid enumerating devices with missing dependencies. */
 
+	/*
+	 * 在以下使用acpi_bus_check_add():
+	 *   - drivers/acpi/scan.c|2198| <<acpi_bus_check_add_1>> return acpi_bus_check_add(handle, true, (struct acpi_device **)ret_p);
+	 *   - drivers/acpi/scan.c|2204| <<acpi_bus_check_add_2>> return acpi_bus_check_add(handle, false, (struct acpi_device **)ret_p);
+	 *   - drivers/acpi/scan.c|2494| <<acpi_bus_scan>> if (ACPI_SUCCESS(acpi_bus_check_add(handle, true, &device)))
+	 *   - drivers/acpi/scan.c|2511| <<acpi_bus_scan>> if (ACPI_SUCCESS(acpi_bus_check_add(handle, false, &device)))
+	 */
 	if (ACPI_SUCCESS(acpi_bus_check_add(handle, true, &device)))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    acpi_bus_check_add_1, NULL, NULL,
@@ -2391,6 +2562,13 @@ int acpi_bus_scan(acpi_handle handle)
 
 	device = NULL;
 
+	/*
+	 * 在以下使用acpi_bus_check_add():
+	 *   - drivers/acpi/scan.c|2198| <<acpi_bus_check_add_1>> return acpi_bus_check_add(handle, true, (struct acpi_device **)ret_p);
+	 *   - drivers/acpi/scan.c|2204| <<acpi_bus_check_add_2>> return acpi_bus_check_add(handle, false, (struct acpi_device **)ret_p);
+	 *   - drivers/acpi/scan.c|2494| <<acpi_bus_scan>> if (ACPI_SUCCESS(acpi_bus_check_add(handle, true, &device)))
+	 *   - drivers/acpi/scan.c|2511| <<acpi_bus_scan>> if (ACPI_SUCCESS(acpi_bus_check_add(handle, false, &device)))
+	 */
 	if (ACPI_SUCCESS(acpi_bus_check_add(handle, false, &device)))
 		acpi_walk_namespace(ACPI_TYPE_ANY, handle, ACPI_UINT32_MAX,
 				    acpi_bus_check_add_2, NULL, NULL,
@@ -2435,11 +2613,22 @@ void acpi_bus_trim(struct acpi_device *adev)
 }
 EXPORT_SYMBOL_GPL(acpi_bus_trim);
 
+/*
+ * 在以下调用acpi_bus_register_early_device():
+ *   - drivers/acpi/ec.c|1835| <<acpi_ec_ecdt_start>> acpi_bus_register_early_device(ACPI_BUS_TYPE_ECDT_EC);
+ */
 int acpi_bus_register_early_device(int type)
 {
 	struct acpi_device *device = NULL;
 	int result;
 
+	/*
+	 * 在以下使用acpi_add_single_object():
+	 *   - drivers/acpi/scan.c|2182| <<acpi_bus_check_add>> acpi_add_single_object(&device, handle, type, !check_dep);
+	 *   - drivers/acpi/scan.c|2560| <<acpi_bus_register_early_device>> result = acpi_add_single_object(&device, NULL, type, false);
+	 *   - drivers/acpi/scan.c|2579| <<acpi_bus_scan_fixed>> result = acpi_add_single_object(&device, NULL, ACPI_BUS_TYPE_POWER_BUTTON, false);
+	 *   - drivers/acpi/scan.c|2595| <<acpi_bus_scan_fixed>> result = acpi_add_single_object(&device, NULL, ACPI_BUS_TYPE_SLEEP_BUTTON, false);
+	 */
 	result = acpi_add_single_object(&device, NULL, type, false);
 	if (result)
 		return result;
@@ -2459,6 +2648,13 @@ static int acpi_bus_scan_fixed(void)
 	if (!(acpi_gbl_FADT.flags & ACPI_FADT_POWER_BUTTON)) {
 		struct acpi_device *device = NULL;
 
+		/*
+		 * 在以下使用acpi_add_single_object():
+		 *   - drivers/acpi/scan.c|2182| <<acpi_bus_check_add>> acpi_add_single_object(&device, handle, type, !check_dep);
+		 *   - drivers/acpi/scan.c|2560| <<acpi_bus_register_early_device>> result = acpi_add_single_object(&device, NULL, type, false);
+		 *   - drivers/acpi/scan.c|2579| <<acpi_bus_scan_fixed>> result = acpi_add_single_object(&device, NULL, ACPI_BUS_TYPE_POWER_BUTTON, false);
+		 *   - drivers/acpi/scan.c|2595| <<acpi_bus_scan_fixed>> result = acpi_add_single_object(&device, NULL, ACPI_BUS_TYPE_SLEEP_BUTTON, false);
+		 */
 		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_POWER_BUTTON, false);
 		if (result)
@@ -2475,6 +2671,13 @@ static int acpi_bus_scan_fixed(void)
 	if (!(acpi_gbl_FADT.flags & ACPI_FADT_SLEEP_BUTTON)) {
 		struct acpi_device *device = NULL;
 
+		/*
+		 * 在以下使用acpi_add_single_object():
+		 *   - drivers/acpi/scan.c|2182| <<acpi_bus_check_add>> acpi_add_single_object(&device, handle, type, !check_dep);
+		 *   - drivers/acpi/scan.c|2560| <<acpi_bus_register_early_device>> result = acpi_add_single_object(&device, NULL, type, false);
+		 *   - drivers/acpi/scan.c|2579| <<acpi_bus_scan_fixed>> result = acpi_add_single_object(&device, NULL, ACPI_BUS_TYPE_POWER_BUTTON, false);
+		 *   - drivers/acpi/scan.c|2595| <<acpi_bus_scan_fixed>> result = acpi_add_single_object(&device, NULL, ACPI_BUS_TYPE_SLEEP_BUTTON, false);
+		 */
 		result = acpi_add_single_object(&device, NULL,
 						ACPI_BUS_TYPE_SLEEP_BUTTON, false);
 		if (result)
diff --git a/drivers/pci/hotplug/acpiphp_glue.c b/drivers/pci/hotplug/acpiphp_glue.c
index f031302ad401..142b19e133c9 100644
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@ -56,6 +56,10 @@ static void free_bridge(struct kref *kref);
  *
  * Call under acpi_hp_context_lock.
  */
+/*
+ * 在以下使用acpiphp_init_context():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|255| <<acpiphp_add_context>> context = acpiphp_init_context(adev);
+ */
 static struct acpiphp_context *acpiphp_init_context(struct acpi_device *adev)
 {
 	struct acpiphp_context *context;
@@ -117,12 +121,28 @@ static inline void put_bridge(struct acpiphp_bridge *bridge)
 	kref_put(&bridge->ref, free_bridge);
 }
 
+/*
+ * 在以下调用acpiphp_grab_context():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|195| <<acpiphp_post_dock_fixup>> struct acpiphp_context *context = acpiphp_grab_context(adev);
+ *   - drivers/pci/hotplug/acpiphp_glue.c|861| <<acpiphp_hotplug_notify>> context = acpiphp_grab_context(adev);
+ */
 static struct acpiphp_context *acpiphp_grab_context(struct acpi_device *adev)
 {
 	struct acpiphp_context *context;
 
 	acpi_lock_hp_context();
 
+	/*
+	 * struct acpi_device *adev:
+	 * -> struct acpi_hotplug_context *hp;
+	 *
+	 * struct acpiphp_context {
+	 *     struct acpi_hotplug_context hp;
+	 *     struct acpiphp_func func;
+	 *     struct acpiphp_bridge *bridge;
+	 *     unsigned int refcount;
+	 * };
+	 */
 	context = acpiphp_get_context(adev);
 	if (!context)
 		goto unlock;
@@ -223,6 +243,10 @@ static void acpiphp_post_dock_fixup(struct acpi_device *adev)
  * @data: The object's parent ACPIPHP bridge.
  * @rv: Not used.
  */
+/*
+ * 在以下使用acpiphp_add_context():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|916| <<acpiphp_enumerate_slots>> acpiphp_add_context, NULL, bridge, NULL);
+ */
 static acpi_status acpiphp_add_context(acpi_handle handle, u32 lvl, void *data,
 				       void **rv)
 {
@@ -771,10 +795,31 @@ void acpiphp_check_host_bridge(struct acpi_device *adev)
 
 static int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot);
 
+/*
+ * 在以下调用hotplug_event():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|836| <<acpiphp_hotplug_notify>> hotplug_event(type, context);
+ */
 static void hotplug_event(u32 type, struct acpiphp_context *context)
 {
+	/*
+	 * struct acpiphp_context *context:
+	 * -> struct acpi_hotplug_context hp;
+	 *    -> struct acpi_device *self;
+	 */
 	acpi_handle handle = context->hp.self->handle;
 	struct acpiphp_func *func = &context->func;
+	/*
+	 * struct acpiphp_slot {
+	 *     struct list_head node;
+	 *     struct pci_bus *bus;
+	 *     struct list_head funcs;          one slot may have different
+         *                                      objects (i.e. for each function)
+	 *     struct slot *slot;
+	 *
+	 *     u8              device;         // pci device# 
+	 *     u32             flags;          // see below 
+	 * };
+	 */
 	struct acpiphp_slot *slot = func->slot;
 	struct acpiphp_bridge *bridge;
 
@@ -825,14 +870,34 @@ static void hotplug_event(u32 type, struct acpiphp_context *context)
 		put_bridge(bridge);
 }
 
+/*
+ * [0] acpiphp_hotplug_notify
+ * [0] acpi_device_hotplug
+ * [0] acpi_hotplug_work_fn
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下使用acpiphp_hotplug_notify():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|72| <<acpiphp_init_context>> context->hp.notify = acpiphp_hotplug_notify;
+ */
 static int acpiphp_hotplug_notify(struct acpi_device *adev, u32 type)
 {
 	struct acpiphp_context *context;
 
+	/*
+	 * 在以下调用acpiphp_grab_context():
+	 *   - drivers/pci/hotplug/acpiphp_glue.c|195| <<acpiphp_post_dock_fixup>> struct acpiphp_context *context = acpiphp_grab_context(adev);
+	 *   - drivers/pci/hotplug/acpiphp_glue.c|861| <<acpiphp_hotplug_notify>> context = acpiphp_grab_context(adev);
+	 */
 	context = acpiphp_grab_context(adev);
 	if (!context)
 		return -ENODATA;
 
+	/*
+	 * 只在此处调用
+	 */
 	hotplug_event(type, context);
 	acpiphp_let_context_go(context);
 	return 0;
@@ -845,6 +910,35 @@ static int acpiphp_hotplug_notify(struct acpi_device *adev, u32 type)
  * A "slot" is an object associated with a PCI device number.  All functions
  * (PCI devices) with the same bus and device number belong to the same slot.
  */
+/*
+ * [0] acpiphp_init_context
+ * [0] acpiphp_add_context
+ * [0] acpi_ns_walk_namespace
+ * [0] acpi_walk_namespace
+ * [0] acpiphp_enumerate_slots
+ * [0] acpi_pci_add_bus
+ * [0] pci_alloc_child_bus
+ * [0] pci_scan_bridge_extend
+ * [0] pci_scan_child_bus_extend
+ * [0] acpi_pci_root_create
+ * [0] pci_acpi_scan_root
+ * [0] acpi_pci_root_add
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_scan
+ * [0] acpi_scan_init
+ * [0] acpi_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * 在以下调用acpiphp_enumerate_slots():
+ *   - drivers/pci/pci-acpi.c|1170| <<acpi_pci_add_bus>> acpiphp_enumerate_slots(bus);
+ *
+ * acpiphp_enumerate_slots()针对每一个bus调用一次
+ */
 void acpiphp_enumerate_slots(struct pci_bus *bus)
 {
 	struct acpiphp_bridge *bridge;
diff --git a/drivers/pci/pci-acpi.c b/drivers/pci/pci-acpi.c
index 8f4a4fc48efa..3210cfa3389a 100644
--- a/drivers/pci/pci-acpi.c
+++ b/drivers/pci/pci-acpi.c
@@ -935,6 +935,10 @@ static pci_power_t acpi_pci_choose_state(struct pci_dev *pdev)
 
 static struct acpi_device *acpi_pci_find_companion(struct device *dev);
 
+/*
+ * 在以下使用pci_set_acpi_fwnode():
+ *   - drivers/pci/probe.c|1855| <<pci_setup_device>> pci_set_acpi_fwnode(dev);
+ */
 void pci_set_acpi_fwnode(struct pci_dev *dev)
 {
 	if (!dev_fwnode(&dev->dev) && !pci_dev_is_added(dev))
diff --git a/virt/kvm/eventfd.c b/virt/kvm/eventfd.c
index 37e3a49f4e76..3d7df8542e01 100644
--- a/virt/kvm/eventfd.c
+++ b/virt/kvm/eventfd.c
@@ -338,6 +338,9 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
 
 		mutex_lock(&kvm->irqfds.resampler_lock);
 
+		/*
+		 * 似乎resampler_list也基本不怎么用
+		 */
 		list_for_each_entry(resampler,
 				    &kvm->irqfds.resampler_list, link) {
 			if (resampler->notifier.gsi == irqfd->gsi) {
@@ -448,6 +451,10 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
 	return ret;
 }
 
+/*
+ * 在以下使用kvm_irq_has_notifier():
+ *   - arch/x86/kvm/ioapic.c|448| <<kvm_ioapic_scan_entry>> kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||
+ */
 bool kvm_irq_has_notifier(struct kvm *kvm, unsigned irqchip, unsigned pin)
 {
 	struct kvm_irq_ack_notifier *kian;
@@ -455,6 +462,9 @@ bool kvm_irq_has_notifier(struct kvm *kvm, unsigned irqchip, unsigned pin)
 
 	idx = srcu_read_lock(&kvm->irq_srcu);
 	gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	/*
+	 * 似乎irq_ack_notifier_list不怎么用
+	 */
 	if (gsi != -1)
 		hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,
 					  link, srcu_read_lock_held(&kvm->irq_srcu))
diff --git a/virt/kvm/irqchip.c b/virt/kvm/irqchip.c
index 79dcd4cd5c60..38b03de2e145 100644
--- a/virt/kvm/irqchip.c
+++ b/virt/kvm/irqchip.c
@@ -75,6 +75,12 @@ int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi)
 int kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,
 		bool line_status)
 {
+	/*
+	 * #define KVM_IRQCHIP_PIC_MASTER   0
+	 * #define KVM_IRQCHIP_PIC_SLAVE    1
+	 * #define KVM_IRQCHIP_IOAPIC       2
+	 * #define KVM_NR_IRQCHIPS          3
+	 */
 	struct kvm_kernel_irq_routing_entry irq_set[KVM_NR_IRQCHIPS];
 	int ret = -1, i, idx;
 
@@ -170,6 +176,41 @@ bool __weak kvm_arch_can_set_irq_routing(struct kvm *kvm)
 	return true;
 }
 
+/*
+ * 265 把irq从CPU=5换到CPU=6上.
+ * 266
+ * 267        CPU 5/KVM-51857   [011] ..... 435912.873065: vfio_pci_set_msi_trigger <-vfio_pci_core_ioctl
+ * 268        CPU 5/KVM-51857   [011] ..... 435912.873068: vfio_msi_set_vector_signal <-vfio_msi_set_block
+ * 269        CPU 5/KVM-51857   [011] ..... 435912.873069: irq_bypass_unregister_producer <-vfio_msi_set_vector_signal
+ * 270        CPU 5/KVM-51857   [011] ..... 435912.873070: kvm_arch_irq_bypass_del_producer <-__disconnect
+ * 271        CPU 5/KVM-51857   [011] ..... 435912.873070: vmx_pi_update_irte <-kvm_arch_irq_bypass_del_producer
+ * 272        CPU 5/KVM-51857   [011] ..... 435912.873102: irq_bypass_register_producer <-vfio_msi_set_vector_signal
+ * 273
+ * 274        CPU 5/KVM-51857   [011] ..... 435912.873255: kvm_set_irq_routing <-kvm_vm_ioctl
+ * 275        CPU 5/KVM-51857   [011] ..... 435912.873263: kvm_irq_routing_update <-kvm_set_irq_routing
+ * 276        CPU 5/KVM-51857   [011] d.... 435912.873263: irqfd_update <-kvm_irq_routing_update
+ * 277        CPU 5/KVM-51857   [011] d.... 435912.873264: kvm_arch_update_irqfd_routing <-kvm_irq_routing_update
+ * 278        CPU 5/KVM-51857   [011] d.... 435912.873264: vmx_pi_update_irte <-kvm_irq_routing_update
+ * 279        CPU 5/KVM-51857   [011] d.... 435912.873266: irqfd_update <-kvm_irq_routing_update
+ * 280        CPU 5/KVM-51857   [011] d.... 435912.873266: irqfd_update <-kvm_irq_routing_update
+ * 281        CPU 5/KVM-51857   [011] d.... 435912.873266: kvm_arch_update_irqfd_routing <-kvm_irq_routing_update
+ * 282        CPU 5/KVM-51857   [011] d.... 435912.873266: vmx_pi_update_irte <-kvm_irq_routing_update
+ * 283
+ * 284        CPU 5/KVM-51857   [011] ..... 435912.873290: vfio_pci_set_msi_trigger <-vfio_pci_core_ioctl
+ * 285        CPU 5/KVM-51857   [011] ..... 435912.873291: vfio_msi_set_vector_signal <-vfio_msi_set_block
+ * 286        CPU 5/KVM-51857   [011] ..... 435912.873291: irq_bypass_unregister_producer <-vfio_msi_set_vector_signal
+ * 287        CPU 5/KVM-51857   [011] ..... 435912.873311: irq_bypass_register_producer <-vfio_msi_set_vector_signal
+ * 288        CPU 5/KVM-51857   [011] ..... 435912.873312: kvm_arch_irq_bypass_add_producer <-__connect
+ * 289        CPU 5/KVM-51857   [011] ..... 435912.873312: vmx_pi_update_irte <-kvm_arch_irq_bypass_add_producer
+ *
+ * Add或者Del vCPU会调用:
+ *
+ * kvm_set_irq_routing
+ * kvm_vm_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 int kvm_set_irq_routing(struct kvm *kvm,
 			const struct kvm_irq_routing_entry *ue,
 			unsigned nr,
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 36896443375a..ac8109abdee6 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -438,6 +438,10 @@ void *kvm_mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)
 }
 #endif
 
+/*
+ * 在以下调用kvm_vcpu_init():
+ *   - virt/kvm/kvm_main.c|3835| <<kvm_vm_ioctl_create_vcpu>> kvm_vcpu_init(vcpu, kvm, id);
+ */
 static void kvm_vcpu_init(struct kvm_vcpu *vcpu, struct kvm *kvm, unsigned id)
 {
 	mutex_init(&vcpu->mutex);
@@ -3796,6 +3800,10 @@ static void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)
 /*
  * Creates some virtual cpus.  Good luck creating more than one.
  */
+/*
+ * 在以下调用kvm_vm_ioctl_create_vcpu():
+ *   - virt/kvm/kvm_main.c|4593| <<kvm_vm_ioctl(KVM_CREATE_VCPU)>> r = kvm_vm_ioctl_create_vcpu(kvm, arg);
+ */
 static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)
 {
 	int r;
-- 
2.39.5 (Apple Git-154)

