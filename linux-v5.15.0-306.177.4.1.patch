From f4a17dfa029f2143cd2cda1e8080a4780e07d9c0 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Tue, 17 Jun 2025 09:46:50 -0700
Subject: [PATCH 1/1] linux v5.15.0-306.177.4.1

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/include/asm/kvm_host.h    |  85 ++++++
 arch/x86/kernel/apic/io_apic.c     |   5 +
 arch/x86/kvm/ioapic.c              | 298 +++++++++++++++++++
 arch/x86/kvm/ioapic.h              |  14 +
 arch/x86/kvm/irq.c                 |  25 ++
 arch/x86/kvm/irq_comm.c            |  87 ++++++
 arch/x86/kvm/lapic.c               | 450 +++++++++++++++++++++++++++++
 arch/x86/kvm/lapic.h               |  50 ++++
 arch/x86/kvm/svm/avic.c            |  19 ++
 arch/x86/kvm/vmx/vmx.c             |  44 +++
 arch/x86/kvm/x86.c                 | 312 ++++++++++++++++++++
 drivers/acpi/acpica/dbexec.c       |  40 +++
 drivers/acpi/acpica/dbxface.c      |  20 ++
 drivers/acpi/acpica/evgpe.c        |  40 +++
 drivers/acpi/acpica/evmisc.c       |  24 ++
 drivers/acpi/acpica/nsxfeval.c     |  10 +
 drivers/acpi/bus.c                 |  42 +++
 drivers/acpi/osl.c                 | 104 +++++++
 drivers/acpi/scan.c                | 114 ++++++++
 drivers/pci/hotplug/acpiphp_glue.c |  91 ++++++
 virt/kvm/eventfd.c                 |  10 +
 virt/kvm/irqchip.c                 |  41 +++
 22 files changed, 1925 insertions(+)

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 8a710af8003c..5ad98c9ba2da 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -634,8 +634,48 @@ struct kvm_vcpu_arch {
 	u64 efer;
 	u64 apic_base;
 	struct kvm_lapic *apic;    /* kernel irqchip context */
+	/*
+	 * 在以下设置kvm_vcpu_arch->apicv_active:
+	 *   - arch/x86/kvm/x86.c|9800| <<kvm_vcpu_update_apicv>> vcpu->arch.apicv_active = activate;
+	 *   - arch/x86/kvm/x86.c|11393| <<kvm_arch_vcpu_create>> vcpu->arch.apicv_active = true;
+	 * 在以下使用kvm_vcpu_arch->apicv_active:
+	 *   - arch/x86/kvm/lapic.c|553| <<kvm_apic_update_irr>> if (unlikely(!vcpu->arch.apicv_active && irr_updated))
+	 *   - arch/x86/kvm/lapic.c|602| <<apic_clear_irr>> if (unlikely(vcpu->arch.apicv_active)) {
+	 *   - arch/x86/kvm/lapic.c|654| <<apic_set_isr>> if (unlikely(vcpu->arch.apicv_active))
+	 *   - arch/x86/kvm/lapic.c|714| <<apic_clear_isr>> if (unlikely(vcpu->arch.apicv_active))
+	 *   - arch/x86/kvm/lapic.c|1827| <<lapic_timer_int_injected>> if (vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/lapic.c|1944| <<apic_timer_expired>> if (!from_timer_fn && vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|2613| <<kvm_apic_update_apicv>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|2703| <<kvm_lapic_reset>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|3003| <<kvm_apic_set_state>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.h|241| <<kvm_vcpu_apicv_active>> return vcpu->arch.apic && vcpu->arch.apicv_active;
+	 *   - arch/x86/kvm/svm/svm.c|3661| <<svm_complete_interrupt_delivery>> if (!READ_ONCE(vcpu->arch.apicv_active)) {
+	 *   - arch/x86/kvm/vmx/vmx.c|4114| <<vmx_deliver_posted_interrupt>> if (!vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|9241| <<update_cr8_intercept>> if (vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|9797| <<kvm_vcpu_update_apicv>> if (vcpu->arch.apicv_active == activate)
+	 *   - arch/x86/kvm/x86.c|9810| <<kvm_vcpu_update_apicv>> if (!vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|12441| <<kvm_arch_dy_has_pending_interrupt>> if (vcpu->arch.apicv_active &&
+	 *          static_call(kvm_x86_dy_apicv_has_pending_interrupt)(vcpu))
+	 */
 	bool apicv_active;
+	/*
+	 * 在以下使用kvm_vcpu_arch->load_eoi_exitmap_pending:
+	 *   - arch/x86/kvm/kvm_cache_regs.h|184| <<leave_guest_mode>> if (vcpu->arch.load_eoi_exitmap_pending) {
+	 *   - arch/x86/kvm/kvm_cache_regs.h|185| <<leave_guest_mode>> vcpu->arch.load_eoi_exitmap_pending = false;
+	 *   - arch/x86/kvm/x86.c|9850| <<vcpu_scan_ioapic>> vcpu->arch.load_eoi_exitmap_pending = true;
+	 */
 	bool load_eoi_exitmap_pending;
+	/*
+	 * 在以下使用kvm_vcpu_arch->ioapic_handled_vectors:
+	 *   - arch/x86/kvm/lapic.c|1273| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9840| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+	 *   - arch/x86/kvm/x86.c|9845| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9847| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9864| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,
+	 *              to_hv_synic(vcpu)->vec_bitmap, 256);
+	 *   - arch/x86/kvm/x86.c|9871| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10004| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+	 */
 	DECLARE_BITMAP(ioapic_handled_vectors, 256);
 	unsigned long apic_attention;
 	int32_t apic_arb_prio;
@@ -875,7 +915,23 @@ struct kvm_vcpu_arch {
 		bool pv_unhalted;
 	} pv;
 
+	/*
+	 * 在以下使用kvm_vcpu_arch->pending_ioapic_eoi:
+	 *   - arch/x86/kvm/lapic.c|1286| <<kvm_ioapic_send_eoi>> apic->vcpu->arch.pending_ioapic_eoi = vector;
+	 *   - arch/x86/kvm/x86.c|10008| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> BUG_ON(vcpu->arch.pending_ioapic_eoi > 255);
+	 *   - arch/x86/kvm/x86.c|10009| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> if (test_bit(vcpu->arch.pending_ioapic_eoi,
+	 *   - arch/x86/kvm/x86.c|10013| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> vcpu->arch.pending_ioapic_eoi;
+	 */
 	int pending_ioapic_eoi;
+	/*
+	 * 在以下使用kvm_vcpu_arch->pending_external_vector:
+	 *   - arch/x86/kvm/irq.c|37| <<pending_userspace_extint>> return v->arch.pending_external_vector != -1;
+	 *   - arch/x86/kvm/irq.c|121| <<kvm_cpu_get_extint>> int vector = v->arch.pending_external_vector;
+	 *   - arch/x86/kvm/irq.c|123| <<kvm_cpu_get_extint>> v->arch.pending_external_vector = -1;
+	 *   - arch/x86/kvm/x86.c|4691| <<kvm_vcpu_ioctl_interrupt>> if (vcpu->arch.pending_external_vector != -1)
+	 *   - arch/x86/kvm/x86.c|4694| <<kvm_vcpu_ioctl_interrupt>> vcpu->arch.pending_external_vector = irq->irq;
+	 *   - arch/x86/kvm/x86.c|11281| <<kvm_arch_vcpu_create>> vcpu->arch.pending_external_vector = -1;
+	 */
 	int pending_external_vector;
 
 	/* be preempted when it's in kernel-mode(cpl=0) */
@@ -1147,6 +1203,15 @@ struct kvm_arch {
 	struct rw_semaphore apicv_update_lock;
 
 	bool apic_access_memslot_enabled;
+	/*
+	 * 在以下使用kvm_arch->apicv_inhibit_reasons:
+	 *   - arch/x86/kvm/x86.c|9007| <<kvm_apicv_activated>> return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
+	 *   - arch/x86/kvm/x86.c|9013| <<kvm_vcpu_apicv_activated>> ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	 *   - arch/x86/kvm/x86.c|9033| <<kvm_apicv_init>> unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9830| <<__kvm_set_or_clear_apicv_inhibit>> old = new = kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9848| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 *   - arch/x86/kvm/x86.c|9857| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 */
 	unsigned long apicv_inhibit_reasons;
 
 	gpa_t wall_clock;
@@ -1156,6 +1221,13 @@ struct kvm_arch {
 	bool pause_in_guest;
 	bool cstate_in_guest;
 
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|187| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|219| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11732| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11735| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	unsigned long irq_sources_bitmap;
 	s64 kvmclock_offset;
 	raw_spinlock_t tsc_write_lock;
@@ -1177,6 +1249,12 @@ struct kvm_arch {
 
 	struct kvm_xen_hvm_config xen_hvm_config;
 
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|234| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|11763| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	/* reads protected by irq_srcu, writes by irq_lock */
 	struct hlist_head mask_notifier_list;
 
@@ -1195,6 +1273,13 @@ struct kvm_arch {
 	int cpu_dirty_logging_count;
 
 	enum kvm_irqchip_mode irqchip_mode;
+	/*
+	 * 在以下使用kvm_arch->nr_reserved_ioapic_pins:
+	 *   - arch/x86/kvm/irq_comm.c|405| <<kvm_scan_ioapic_routes>> nr_ioapic_pins =
+	 *               min_t(u32, table->nr_rt_entries, kvm->arch.nr_reserved_ioapic_pins);
+	 *   - arch/x86/kvm/x86.c|5796| <<kvm_vm_ioctl_enable_cap>>
+	 *               kvm->arch.nr_reserved_ioapic_pins = cap->args[0];
+	 */
 	u8 nr_reserved_ioapic_pins;
 
 	bool disabled_lapic_found;
diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c
index 586ea838a5a1..22f9c3bc4c2a 100644
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@ -1896,6 +1896,11 @@ static void ioapic_setup_msg_from_msi(struct irq_data *irq_data,
 	entry->ir_index_0_14		= msg.arch_addr_lo.dmar_index_0_14;
 }
 
+/*
+ * 在以下使用ioapic_configure_entry():
+ *   - arch/x86/kernel/apic/io_apic.c|1920| <<ioapic_set_affinity>> ioapic_configure_entry(irq_data);
+ *   - arch/x86/kernel/apic/io_apic.c|3078| <<mp_irqdomain_activate>> ioapic_configure_entry(irq_data);
+ */
 static void ioapic_configure_entry(struct irq_data *irqd)
 {
 	struct mp_chip_data *mpd = irqd->chip_data;
diff --git a/arch/x86/kvm/ioapic.c b/arch/x86/kvm/ioapic.c
index 4e0f52660842..3e0d43006458 100644
--- a/arch/x86/kvm/ioapic.c
+++ b/arch/x86/kvm/ioapic.c
@@ -80,6 +80,20 @@ static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,
 				u32 index = array_index_nospec(
 					redir_index, IOAPIC_NUM_PINS);
 
+				/*
+				 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+				 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+				 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+				 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+				 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+				 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+				 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+				 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+				 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+				 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+				 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+				 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+				 */
 				redir_content = ioapic->redirtbl[index].bits;
 			}
 
@@ -114,7 +128,40 @@ static void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)
 	struct dest_map *dest_map = &ioapic->rtc_status.dest_map;
 	union kvm_ioapic_redirect_entry *e;
 
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	e = &ioapic->redirtbl[RTC_GSI];
+	/*
+	 * 在以下调用kvm_apic_match_dest():
+	 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+	 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+	 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+	 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+	 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+	 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+	 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+	 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+	 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+	 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+	 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+	 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+	 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+	 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+	 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+	 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+	 */
 	if (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,
 				 e->fields.dest_id,
 				 kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
@@ -186,9 +233,42 @@ static void ioapic_lazy_update_eoi(struct kvm_ioapic *ioapic, int irq)
 {
 	int i;
 	struct kvm_vcpu *vcpu;
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
 
 	kvm_for_each_vcpu(i, vcpu, ioapic->kvm) {
+		/*
+		 * 在以下调用kvm_apic_match_dest():
+		 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+		 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+		 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+		 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+		 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+		 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+		 */
 		if (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,
 					 entry->fields.dest_id,
 					 entry->fields.dest_mode) ||
@@ -212,6 +292,20 @@ static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,
 	u32 old_irr;
 	int edge, ret;
 
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	entry = ioapic->redirtbl[irq];
 	edge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);
 
@@ -276,6 +370,10 @@ static void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)
 }
 
 
+/*
+ * 在以下使用kvm_ioapic_scan_entry():
+ *   - arch/x86/kvm/x86.c|9917| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+ */
 void kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)
 {
 	struct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;
@@ -285,18 +383,97 @@ void kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)
 
 	spin_lock(&ioapic->lock);
 
+	/*
+	 * struct dest_map {
+	 * map = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 * 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 * 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+	 *
+	 * 第一次设置的地方
+	 * 看着似乎rtc_statu的bit都是空
+	 */
 	/* Make sure we see any missing RTC EOI */
 	if (test_bit(vcpu->vcpu_id, dest_map->map))
 		__set_bit(dest_map->vectors[vcpu->vcpu_id],
 			  ioapic_handled_vectors);
 
+	/*
+	 * union kvm_ioapic_redirect_entry {
+	 *     bits = 144115188075888682,
+	 *     fields = {
+	 *       vector = 42 '*',
+	 *       delivery_mode = 0 '\000',
+	 *       dest_mode = 0 '\000',
+	 *       delivery_status = 0 '\000',
+	 *       polarity = 0 '\000',
+	 *       remote_irr = 0 '\000',
+	 *       trig_mode = 1 '\001',
+	 *       mask = 0 '\000',
+	 *       reserve = 0 '\000',
+	 *       reserved = "\000\000\000",
+	 *       dest_id = 2 '\002'
+	 *     }
+	 *  }
+	 *
+	 * 57 union kvm_ioapic_redirect_entry {
+	 * 58         u64 bits;
+	 * 59         struct {
+	 * 60                 u8 vector;
+	 * 61                 u8 delivery_mode:3;
+	 * 62                 u8 dest_mode:1;
+	 * 63                 u8 delivery_status:1;
+	 * 64                 u8 polarity:1;
+	 * 65                 u8 remote_irr:1;
+	 * 66                 u8 trig_mode:1;
+	 * 67                 u8 mask:1;
+	 * 68                 u8 reserve:7;
+	 * 69                 u8 reserved[4];
+	 * 70                 u8 dest_id;
+	 * 71         } fields;
+	 * 72 };
+	 */
 	for (index = 0; index < IOAPIC_NUM_PINS; index++) {
+		/*
+		 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+		 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+		 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+		 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+		 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+		 *
+		 * 只在这里一个地方使用kvm_irq_has_notifier(), 返回false的概率大
+		 */
 		e = &ioapic->redirtbl[index];
 		if (e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||
 		    kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||
 		    index == RTC_GSI) {
 			u16 dm = kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);
 
+			/*
+			 * 在以下调用kvm_apic_match_dest():
+			 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+			 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+			 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+			 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+			 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+			 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+			 */
 			if (kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,
 						e->fields.dest_id, dm) ||
 			    kvm_apic_pending_eoi(vcpu, e->fields.vector))
@@ -314,6 +491,10 @@ void kvm_arch_post_irq_ack_notifier_list_update(struct kvm *kvm)
 	kvm_make_scan_ioapic_request(kvm);
 }
 
+/*
+ * 在以下使用ioapic_write_indirect():
+ *   - arch/x86/kvm/ioapic.c|907| <<ioapic_mmio_write>> ioapic_write_indirect(ioapic, data);
+ */
 static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)
 {
 	unsigned index;
@@ -340,6 +521,24 @@ static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)
 		if (index >= IOAPIC_NUM_PINS)
 			return;
 		index = array_index_nospec(index, IOAPIC_NUM_PINS);
+		/*
+		 * union kvm_ioapic_redirect_entry {
+		 *     u64 bits;
+		 *     struct {
+		 *         u8 vector;
+		 *         u8 delivery_mode:3;
+		 *         u8 dest_mode:1;
+		 *         u8 delivery_status:1;
+		 *         u8 polarity:1;
+		 *         u8 remote_irr:1;
+		 *         u8 trig_mode:1;
+		 *         u8 mask:1;
+		 *         u8 reserve:7;
+		 *         u8 reserved[4];
+		 *         u8 dest_id;
+		 *      } fields;
+		 * };
+		 */
 		e = &ioapic->redirtbl[index];
 		mask_before = e->fields.mask;
 		/* Preserve read-only fields */
@@ -347,6 +546,9 @@ static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)
 		old_delivery_status = e->fields.delivery_status;
 		old_dest_id = e->fields.dest_id;
 		old_dest_mode = e->fields.dest_mode;
+		/*
+		 * 主要在这里修改!
+		 */
 		if (ioapic->ioregsel & 1) {
 			e->bits &= 0xffffffff;
 			e->bits |= (u64) val << 32;
@@ -410,8 +612,35 @@ static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)
 	}
 }
 
+/*
+ * hot-add和hot-del都调用
+ *
+ * ioapic_service
+ * ioapic_set_irq
+ * kvm_ioapic_set_irq
+ * kvm_set_irq
+ * kvm_vm_ioctl_irq_line
+ * kvm_vm_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)
 {
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
 	struct kvm_lapic_irq irqe;
 	int ret;
@@ -487,6 +716,20 @@ static void kvm_ioapic_eoi_inject_work(struct work_struct *work)
 						 eoi_inject.work);
 	spin_lock(&ioapic->lock);
 	for (i = 0; i < IOAPIC_NUM_PINS; i++) {
+		/*
+		 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+		 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+		 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+		 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+		 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+		 */
 		union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
 
 		if (ent->fields.trig_mode != IOAPIC_LEVEL_TRIG)
@@ -499,12 +742,39 @@ static void kvm_ioapic_eoi_inject_work(struct work_struct *work)
 }
 
 #define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000
+/*
+ * kvm_ioapic_update_eoi
+ * kvm_apic_set_eoi_accelerated
+ * handle_apic_eoi_induced
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,
 				      struct kvm_ioapic *ioapic,
 				      int trigger_mode,
 				      int pin)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
 
 	/*
@@ -555,6 +825,20 @@ void kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)
 	spin_lock(&ioapic->lock);
 	rtc_irq_eoi(ioapic, vcpu, vector);
 	for (i = 0; i < IOAPIC_NUM_PINS; i++) {
+		/*
+		 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+		 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+		 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+		 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+		 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+		 */
 		union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
 
 		if (ent->fields.vector != vector)
@@ -666,6 +950,20 @@ static void kvm_ioapic_reset(struct kvm_ioapic *ioapic)
 	int i;
 
 	cancel_delayed_work_sync(&ioapic->eoi_inject);
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	for (i = 0; i < IOAPIC_NUM_PINS; i++)
 		ioapic->redirtbl[i].fields.mask = 1;
 	ioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;
diff --git a/arch/x86/kvm/ioapic.h b/arch/x86/kvm/ioapic.h
index f1b2b2a6ff4d..ac3cbdd17bcf 100644
--- a/arch/x86/kvm/ioapic.h
+++ b/arch/x86/kvm/ioapic.h
@@ -77,6 +77,20 @@ struct kvm_ioapic {
 	u32 id;
 	u32 irr;
 	u32 pad;
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|83| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|117| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|189| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|215| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|294| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|343| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|415| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|490| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|508| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|558| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|670| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry redirtbl[IOAPIC_NUM_PINS];
 	unsigned long irq_states[IOAPIC_NUM_PINS];
 	struct kvm_io_device dev;
diff --git a/arch/x86/kvm/irq.c b/arch/x86/kvm/irq.c
index 172b05343cfd..e18d2cea666f 100644
--- a/arch/x86/kvm/irq.c
+++ b/arch/x86/kvm/irq.c
@@ -75,6 +75,12 @@ int kvm_cpu_has_extint(struct kvm_vcpu *v)
  * interrupt from apic will handled by hardware,
  * we don't need to check it here.
  */
+/*
+ * 在以下使用kvm_cpu_has_injectable_intr():
+ *   - arch/x86/kvm/svm/svm.c|2448| <<svm_set_gif>> kvm_cpu_has_injectable_intr(&svm->vcpu))
+ *   - arch/x86/kvm/x86.c|9412| <<inject_pending_event>> if (kvm_cpu_has_injectable_intr(vcpu)) {
+ *   - arch/x86/kvm/x86.c|9425| <<inject_pending_event>> if (kvm_cpu_has_injectable_intr(vcpu))
+ */
 int kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)
 {
 	if (kvm_cpu_has_extint(v))
@@ -83,6 +89,13 @@ int kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)
 	if (!is_guest_mode(v) && kvm_vcpu_apicv_active(v))
 		return 0;
 
+	/*
+	 * 在以下使用kvm_apic_has_interrupt():
+	 *   - arch/x86/kvm/irq.c|86| <<kvm_cpu_has_injectable_intr>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/irq.c|99| <<kvm_cpu_has_interrupt>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/lapic.c|2841| <<kvm_get_apic_interrupt>> int vector = kvm_apic_has_interrupt(vcpu);
+	 *   - arch/x86/kvm/vmx/nested.c|3627| <<nested_vmx_run>> kvm_apic_has_interrupt(vcpu) == vmx->nested.posted_intr_nv) {
+	 */
 	return kvm_apic_has_interrupt(v) != -1; /* LAPIC */
 }
 EXPORT_SYMBOL_GPL(kvm_cpu_has_injectable_intr);
@@ -96,6 +109,13 @@ int kvm_cpu_has_interrupt(struct kvm_vcpu *v)
 	if (kvm_cpu_has_extint(v))
 		return 1;
 
+	/*
+	 * 在以下使用kvm_apic_has_interrupt():
+	 *   - arch/x86/kvm/irq.c|86| <<kvm_cpu_has_injectable_intr>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/irq.c|99| <<kvm_cpu_has_interrupt>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/lapic.c|2841| <<kvm_get_apic_interrupt>> int vector = kvm_apic_has_interrupt(vcpu);
+	 *   - arch/x86/kvm/vmx/nested.c|3627| <<nested_vmx_run>> kvm_apic_has_interrupt(vcpu) == vmx->nested.posted_intr_nv) {
+	 */
 	return kvm_apic_has_interrupt(v) != -1;	/* LAPIC */
 }
 EXPORT_SYMBOL_GPL(kvm_cpu_has_interrupt);
@@ -129,6 +149,11 @@ static int kvm_cpu_get_extint(struct kvm_vcpu *v)
 /*
  * Read pending interrupt vector and intack.
  */
+/*
+ * 在以下调用kvm_cpu_get_interrupt():
+ *   - arch/x86/kvm/vmx/nested.c|4709| <<nested_vmx_vmexit>> int irq = kvm_cpu_get_interrupt(vcpu);
+ *   - arch/x86/kvm/x86.c|9417| <<inject_pending_event>> int irq = kvm_cpu_get_interrupt(vcpu);
+ */
 int kvm_cpu_get_interrupt(struct kvm_vcpu *v)
 {
 	int vector = kvm_cpu_get_extint(v);
diff --git a/arch/x86/kvm/irq_comm.c b/arch/x86/kvm/irq_comm.c
index 025b65502fce..ce1d8ae36625 100644
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@ -65,6 +65,25 @@ int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,
 		if (!kvm_apic_present(vcpu))
 			continue;
 
+		/*
+		 * 在以下调用kvm_apic_match_dest():
+		 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+		 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+		 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+		 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+		 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+		 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+		 */
 		if (!kvm_apic_match_dest(vcpu, src, irq->shorthand,
 					irq->dest_id, irq->dest_mode))
 			continue;
@@ -184,6 +203,13 @@ int kvm_arch_set_irq_inatomic(struct kvm_kernel_irq_routing_entry *e,
 
 int kvm_request_irq_source_id(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|187| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|219| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11732| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11735| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
 	int irq_source_id;
 
@@ -216,6 +242,13 @@ void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)
 		printk(KERN_ERR "kvm: IRQ source ID out of range!\n");
 		goto unlock;
 	}
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|187| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|219| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11732| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11735| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
 	if (!irqchip_kernel(kvm))
 		goto unlock;
@@ -231,6 +264,12 @@ void kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,
 {
 	mutex_lock(&kvm->irq_lock);
 	kimn->irq = irq;
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|234| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|11763| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
 	mutex_unlock(&kvm->irq_lock);
 }
@@ -252,6 +291,12 @@ void kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,
 
 	idx = srcu_read_lock(&kvm->irq_srcu);
 	gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|234| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|11763| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	if (gsi != -1)
 		hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
 			if (kimn->irq == gsi)
@@ -330,6 +375,25 @@ bool kvm_intr_is_single_vcpu(struct kvm *kvm, struct kvm_lapic_irq *irq,
 		if (!kvm_apic_present(vcpu))
 			continue;
 
+		/*
+		 * 在以下调用kvm_apic_match_dest():
+		 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+		 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+		 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+		 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+		 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+		 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+		 */
 		if (!kvm_apic_match_dest(vcpu, NULL, irq->shorthand,
 					irq->dest_id, irq->dest_mode))
 			continue;
@@ -390,6 +454,10 @@ void kvm_arch_post_irq_routing_update(struct kvm *kvm)
 	kvm_make_scan_ioapic_request(kvm);
 }
 
+/*
+ * 只在一个地方调用kvm_scan_ioapic_routes():
+ *   - arch/x86/kvm/x86.c|9856| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+ */
 void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,
 			    ulong *ioapic_handled_vectors)
 {
@@ -412,6 +480,25 @@ void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,
 
 			kvm_set_msi_irq(vcpu->kvm, entry, &irq);
 
+			/*
+			 * 在以下调用kvm_apic_match_dest():
+			 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+			 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+			 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+			 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+			 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+			 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+			 */
 			if (irq.trig_mode &&
 			    (kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,
 						 irq.dest_id, irq.dest_mode) ||
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 43c2722ef25e..edfdd3141cb7 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -43,6 +43,13 @@
 #include "cpuid.h"
 #include "hyperv.h"
 
+/*
+ * 下面两个函数很重要.
+ *
+ * vmx_inject_irq()
+ * vmx_hwapic_isr_update()
+ */
+
 #ifndef CONFIG_X86_64
 #define mod_64(x, y) ((x) - (y) * div64_u64(x, y))
 #else
@@ -222,6 +229,14 @@ enum {
 	DIRTY
 };
 
+/*
+ * 在以下调用kvm_recalculate_apic_map():
+ *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+ *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+ *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+ *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+ *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+ */
 void kvm_recalculate_apic_map(struct kvm *kvm)
 {
 	struct kvm_apic_map *new, *old = NULL;
@@ -478,6 +493,11 @@ static u8 count_vectors(void *bitmap)
 	return count;
 }
 
+/*
+ * 在以下使用__kvm_apic_update_irr():
+ *   - arch/x86/kvm/lapic.c|527| <<kvm_apic_update_irr>> bool irr_updated = __kvm_apic_update_irr(pir, apic->regs, max_irr);
+ *   - arch/x86/kvm/vmx/nested.c|3832| <<vmx_complete_nested_posted_interrupt>> __kvm_apic_update_irr(vmx->nested.pi_desc->pir,
+ */
 bool __kvm_apic_update_irr(u32 *pir, void *regs, int *max_irr)
 {
 	u32 i, vec;
@@ -514,11 +534,30 @@ bool __kvm_apic_update_irr(u32 *pir, void *regs, int *max_irr)
 }
 EXPORT_SYMBOL_GPL(__kvm_apic_update_irr);
 
+/*
+ * 只在以下调用kvm_apic_update_irr():
+ *   - arch/x86/kvm/vmx/vmx.c|6490| <<vmx_sync_pir_to_irr>> kvm_apic_update_irr(vcpu, vmx->pi_desc.pir, &max_irr);
+ */
 bool kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir, int *max_irr)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 	bool irr_updated = __kvm_apic_update_irr(pir, apic->regs, max_irr);
 
+	/*
+	 * 在以下使用kvm_lapic->irr_pending:
+	 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+	 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+	 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+	 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+	 *
+	 * 理论上来说:
+	 * irr_pending is always true when apicv is activated.
+	 */
 	if (unlikely(!vcpu->arch.apicv_active && irr_updated))
 		apic->irr_pending = true;
 	return irr_updated;
@@ -534,6 +573,21 @@ static inline int apic_find_highest_irr(struct kvm_lapic *apic)
 {
 	int result;
 
+	/*
+	 * 在以下使用kvm_lapic->irr_pending:
+	 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+	 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+	 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+	 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+	 *
+	 * 理论上来说:
+	 * irr_pending is always true when apicv is activated.
+	 */
 	/*
 	 * Note that irr_pending is just a hint. It will be always
 	 * true with virtual interrupt delivery enabled.
@@ -559,6 +613,21 @@ static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)
 		static_call(kvm_x86_hwapic_irr_update)(vcpu,
 				apic_find_highest_irr(apic));
 	} else {
+		/*
+		 * 在以下使用kvm_lapic->irr_pending:
+		 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+		 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+		 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+		 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+		 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+		 *
+		 * 理论上来说:
+		 * irr_pending is always true when apicv is activated.
+		 */
 		apic->irr_pending = false;
 		kvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);
 		if (apic_search_irr(apic) != -1)
@@ -572,6 +641,10 @@ void kvm_apic_clear_irr(struct kvm_vcpu *vcpu, int vec)
 }
 EXPORT_SYMBOL_GPL(kvm_apic_clear_irr);
 
+/*
+ * 只在以下调用apic_set_isr():
+ *   - arch/x86/kvm/lapic.c|2870| <<kvm_get_apic_interrupt>> apic_set_isr(vector, apic);
+ */
 static inline void apic_set_isr(int vec, struct kvm_lapic *apic)
 {
 	struct kvm_vcpu *vcpu;
@@ -586,11 +659,34 @@ static inline void apic_set_isr(int vec, struct kvm_lapic *apic)
 	 * because the processor can modify ISR under the hood.  Instead
 	 * just set SVI.
 	 */
+	/*
+	 * vmx_hwapic_isr_update()
+	 */
 	if (unlikely(vcpu->arch.apicv_active))
 		static_call(kvm_x86_hwapic_isr_update)(vcpu, vec);
 	else {
+		/*
+		 * 在以下使用kvm_lapic->isr_count:
+		 *   - arch/x86/kvm/lapic.c|657| <<apic_set_isr>> ++apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|658| <<apic_set_isr>> BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+		 *   - arch/x86/kvm/lapic.c|684| <<apic_find_highest_isr>> if (!apic->isr_count)
+		 *   - arch/x86/kvm/lapic.c|718| <<apic_clear_isr>> --apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|719| <<apic_clear_isr>> BUG_ON(apic->isr_count < 0);
+		 *   - arch/x86/kvm/lapic.c|2631| <<kvm_apic_update_apicv>> apic->isr_count = 1;
+		 *   - arch/x86/kvm/lapic.c|2639| <<kvm_apic_update_apicv>> apic->isr_count = count_vectors(apic->regs + APIC_ISR);
+		 */
 		++apic->isr_count;
 		BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+		/*
+		 * 在以下使用kvm_lapic->highest_isr_cache:
+		 *   - arch/x86/kvm/lapic.c|675| <<apic_set_isr>> apic->highest_isr_cache = vec;
+		 *   - arch/x86/kvm/lapic.c|697| <<apic_find_highest_isr>> if (likely(apic->highest_isr_cache != -1))
+		 *   - arch/x86/kvm/lapic.c|698| <<apic_find_highest_isr>> return apic->highest_isr_cache;
+		 *   - arch/x86/kvm/lapic.c|734| <<apic_clear_isr>> apic->highest_isr_cache = -1;
+		 *   - arch/x86/kvm/lapic.c|2669| <<kvm_apic_update_apicv>> apic->highest_isr_cache = -1;
+		 *   - arch/x86/kvm/lapic.c|3170| <<apic_sync_pv_eoi_to_guest>> apic->highest_isr_cache == -1 ||
+		 *   - arch/x86/kvm/lapic.c|3172| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+		 */
 		/*
 		 * ISR (in service register) bit is set when injecting an interrupt.
 		 * The highest vector is injected. Thus the latest bit set matches
@@ -600,6 +696,14 @@ static inline void apic_set_isr(int vec, struct kvm_lapic *apic)
 	}
 }
 
+/*
+ * 在以下调用apic_find_highest_isr():
+ *   - arch/x86/kvm/lapic.c|700| <<apic_clear_isr>> apic_find_highest_isr(apic));
+ *   - arch/x86/kvm/lapic.c|858| <<__apic_update_ppr>> isr = apic_find_highest_isr(apic);
+ *   - arch/x86/kvm/lapic.c|1486| <<apic_set_eoi>> int vector = apic_find_highest_isr(apic);
+ *   - arch/x86/kvm/lapic.c|2963| <<kvm_apic_set_state>> apic_find_highest_isr(apic));
+ *   - arch/x86/kvm/lapic.c|3097| <<kvm_lapic_sync_to_vapic>> max_isr = apic_find_highest_isr(apic);
+ */
 static inline int apic_find_highest_isr(struct kvm_lapic *apic)
 {
 	int result;
@@ -608,8 +712,28 @@ static inline int apic_find_highest_isr(struct kvm_lapic *apic)
 	 * Note that isr_count is always 1, and highest_isr_cache
 	 * is always -1, with APIC virtualization enabled.
 	 */
+	/*
+	 * 在以下使用kvm_lapic->isr_count:
+	 *   - arch/x86/kvm/lapic.c|657| <<apic_set_isr>> ++apic->isr_count;
+	 *   - arch/x86/kvm/lapic.c|658| <<apic_set_isr>> BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+	 *   - arch/x86/kvm/lapic.c|684| <<apic_find_highest_isr>> if (!apic->isr_count)
+	 *   - arch/x86/kvm/lapic.c|718| <<apic_clear_isr>> --apic->isr_count;
+	 *   - arch/x86/kvm/lapic.c|719| <<apic_clear_isr>> BUG_ON(apic->isr_count < 0);
+	 *   - arch/x86/kvm/lapic.c|2631| <<kvm_apic_update_apicv>> apic->isr_count = 1;
+	 *   - arch/x86/kvm/lapic.c|2639| <<kvm_apic_update_apicv>> apic->isr_count = count_vectors(apic->regs + APIC_ISR);
+	 */
 	if (!apic->isr_count)
 		return -1;
+	/*
+	 * 在以下使用kvm_lapic->highest_isr_cache:
+	 *   - arch/x86/kvm/lapic.c|675| <<apic_set_isr>> apic->highest_isr_cache = vec;
+	 *   - arch/x86/kvm/lapic.c|697| <<apic_find_highest_isr>> if (likely(apic->highest_isr_cache != -1))
+	 *   - arch/x86/kvm/lapic.c|698| <<apic_find_highest_isr>> return apic->highest_isr_cache;
+	 *   - arch/x86/kvm/lapic.c|734| <<apic_clear_isr>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|2669| <<kvm_apic_update_apicv>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|3170| <<apic_sync_pv_eoi_to_guest>> apic->highest_isr_cache == -1 ||
+	 *   - arch/x86/kvm/lapic.c|3172| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+	 */
 	if (likely(apic->highest_isr_cache != -1))
 		return apic->highest_isr_cache;
 
@@ -619,6 +743,10 @@ static inline int apic_find_highest_isr(struct kvm_lapic *apic)
 	return result;
 }
 
+/*
+ * 在以下使用apic_clear_isr():
+ *   - arch/x86/kvm/lapic.c|1497| <<apic_set_eoi>> apic_clear_isr(vector, apic);
+ */
 static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)
 {
 	struct kvm_vcpu *vcpu;
@@ -627,6 +755,29 @@ static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)
 
 	vcpu = apic->vcpu;
 
+	/*
+	 * 在以下设置kvm_vcpu_arch->apicv_active:
+	 *   - arch/x86/kvm/x86.c|9800| <<kvm_vcpu_update_apicv>> vcpu->arch.apicv_active = activate;
+	 *   - arch/x86/kvm/x86.c|11393| <<kvm_arch_vcpu_create>> vcpu->arch.apicv_active = true;
+	 * 在以下使用kvm_vcpu_arch->apicv_active:
+	 *   - arch/x86/kvm/lapic.c|553| <<kvm_apic_update_irr>> if (unlikely(!vcpu->arch.apicv_active && irr_updated))
+	 *   - arch/x86/kvm/lapic.c|602| <<apic_clear_irr>> if (unlikely(vcpu->arch.apicv_active)) {
+	 *   - arch/x86/kvm/lapic.c|654| <<apic_set_isr>> if (unlikely(vcpu->arch.apicv_active))
+	 *   - arch/x86/kvm/lapic.c|714| <<apic_clear_isr>> if (unlikely(vcpu->arch.apicv_active))
+	 *   - arch/x86/kvm/lapic.c|1827| <<lapic_timer_int_injected>> if (vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/lapic.c|1944| <<apic_timer_expired>> if (!from_timer_fn && vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|2613| <<kvm_apic_update_apicv>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|2703| <<kvm_lapic_reset>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.c|3003| <<kvm_apic_set_state>> if (vcpu->arch.apicv_active) {
+	 *   - arch/x86/kvm/lapic.h|241| <<kvm_vcpu_apicv_active>> return vcpu->arch.apic && vcpu->arch.apicv_active;
+	 *   - arch/x86/kvm/svm/svm.c|3661| <<svm_complete_interrupt_delivery>> if (!READ_ONCE(vcpu->arch.apicv_active)) {
+	 *   - arch/x86/kvm/vmx/vmx.c|4114| <<vmx_deliver_posted_interrupt>> if (!vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|9241| <<update_cr8_intercept>> if (vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|9797| <<kvm_vcpu_update_apicv>> if (vcpu->arch.apicv_active == activate)
+	 *   - arch/x86/kvm/x86.c|9810| <<kvm_vcpu_update_apicv>> if (!vcpu->arch.apicv_active)
+	 *   - arch/x86/kvm/x86.c|12441| <<kvm_arch_dy_has_pending_interrupt>> if (vcpu->arch.apicv_active &&
+	 *          static_call(kvm_x86_dy_apicv_has_pending_interrupt)(vcpu))
+	 */
 	/*
 	 * We do get here for APIC virtualization enabled if the guest
 	 * uses the Hyper-V APIC enlightenment.  In this case we may need
@@ -634,16 +785,44 @@ static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)
 	 * on the other hand isr_count and highest_isr_cache are unused
 	 * and must be left alone.
 	 */
+	/*
+	 * vmx_hwapic_isr_update()
+	 */
 	if (unlikely(vcpu->arch.apicv_active))
 		static_call(kvm_x86_hwapic_isr_update)(vcpu,
 						apic_find_highest_isr(apic));
 	else {
+		/*
+		 * 在以下使用kvm_lapic->isr_count:
+		 *   - arch/x86/kvm/lapic.c|657| <<apic_set_isr>> ++apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|658| <<apic_set_isr>> BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+		 *   - arch/x86/kvm/lapic.c|684| <<apic_find_highest_isr>> if (!apic->isr_count)
+		 *   - arch/x86/kvm/lapic.c|718| <<apic_clear_isr>> --apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|719| <<apic_clear_isr>> BUG_ON(apic->isr_count < 0);
+		 *   - arch/x86/kvm/lapic.c|2631| <<kvm_apic_update_apicv>> apic->isr_count = 1;
+		 *   - arch/x86/kvm/lapic.c|2639| <<kvm_apic_update_apicv>> apic->isr_count = count_vectors(apic->regs + APIC_ISR);
+		 */
 		--apic->isr_count;
 		BUG_ON(apic->isr_count < 0);
+		/*
+		 * 在以下使用kvm_lapic->highest_isr_cache:
+		 *   - arch/x86/kvm/lapic.c|675| <<apic_set_isr>> apic->highest_isr_cache = vec;
+		 *   - arch/x86/kvm/lapic.c|697| <<apic_find_highest_isr>> if (likely(apic->highest_isr_cache != -1))
+		 *   - arch/x86/kvm/lapic.c|698| <<apic_find_highest_isr>> return apic->highest_isr_cache;
+		 *   - arch/x86/kvm/lapic.c|734| <<apic_clear_isr>> apic->highest_isr_cache = -1;
+		 *   - arch/x86/kvm/lapic.c|2669| <<kvm_apic_update_apicv>> apic->highest_isr_cache = -1;
+		 *   - arch/x86/kvm/lapic.c|3170| <<apic_sync_pv_eoi_to_guest>> apic->highest_isr_cache == -1 ||
+		 *   - arch/x86/kvm/lapic.c|3172| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+		 */
 		apic->highest_isr_cache = -1;
 	}
 }
 
+/*
+ * 在以下使用kvm_lapic_find_highest_irr():
+ *   - arch/x86/kvm/vmx/vmx.c|6502| <<vmx_sync_pir_to_irr>> max_irr = kvm_lapic_find_highest_irr(vcpu);
+ *   - arch/x86/kvm/x86.c|9245| <<update_cr8_intercept>> max_irr = kvm_lapic_find_highest_irr(vcpu);
+ */
 int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)
 {
 	/* This may race with setting of irr in __apic_accept_irq() and
@@ -735,6 +914,18 @@ static int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)
 
 static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)
 {
+	/*
+	 *     pv_eoi = {
+	 *       msr_val = 0,
+	 *        data = {
+	 *          generation = 0,
+	 *          gpa = 0,
+	 *          hva = 0,
+	 *          len = 0,
+	 *          memslot = 0x0
+	 *        }
+	 *     },
+	 */
 	return vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;
 }
 
@@ -766,6 +957,9 @@ static void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)
 static int apic_has_interrupt_for_ppr(struct kvm_lapic *apic, u32 ppr)
 {
 	int highest_irr;
+	/*
+	 * vmx_sync_pir_to_irr()
+	 */
 	if (kvm_x86_ops.sync_pir_to_irr)
 		highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
 	else
@@ -898,6 +1092,25 @@ static u32 kvm_apic_mda(struct kvm_vcpu *vcpu, unsigned int dest_id,
 	return dest_id;
 }
 
+/*
+ * 在以下调用kvm_apic_match_dest():
+ *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+ *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+ *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+ *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+ *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+ *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+ *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+ *          irq->shorthand, irq->dest_id, irq->dest_mode))
+ *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+ *          irq->shorthand, irq->dest_id, irq->dest_mode))
+ *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+ *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+ *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+ *          irq->shorthand, irq->dest_id, irq->dest_mode))
+ *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+ *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+ */
 bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,
 			   int shorthand, unsigned int dest, int dest_mode)
 {
@@ -1119,6 +1332,54 @@ bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,
 	return ret;
 }
 
+/*
+ * 其他的:
+ * __apic_accept_irq
+ * __pv_send_ipi
+ * kvm_pv_send_ipi
+ * kvm_emulate_hypercall
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __apic_accept_irq
+ * kvm_irq_delivery_to_apic
+ * kvm_apic_send_ipi
+ * kvm_x2apic_icr_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
+/*
+ * 关于RESCHEDULE_VECTOR (0xfd)
+ *
+ * __apic_accept_irq
+ * kvm_irq_delivery_to_apic_fast
+ * kvm_irq_delivery_to_apic
+ * kvm_apic_send_ipi
+ * kvm_x2apic_icr_write
+ * handle_fastpath_set_msr_irqoff
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 /*
  * Add a pending IRQ into lapic.
  * Return 1 if successfully added and 0 if discarded.
@@ -1252,6 +1513,25 @@ void kvm_bitmap_or_dest_vcpus(struct kvm *kvm, struct kvm_lapic_irq *irq,
 		kvm_for_each_vcpu(i, vcpu, kvm) {
 			if (!kvm_apic_present(vcpu))
 				continue;
+			/*
+			 * 在以下调用kvm_apic_match_dest():
+			 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+			 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+			 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+			 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+			 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+			 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+			 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+			 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+			 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+			 */
 			if (!kvm_apic_match_dest(vcpu, NULL,
 						 irq->shorthand,
 						 irq->dest_id,
@@ -1268,11 +1548,32 @@ int kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)
 	return vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;
 }
 
+/*
+ * 在以下使用kvm_ioapic_handles_vector():
+ *   - arch/x86/kvm/lapic.c|1397| <<kvm_ioapic_send_eoi>> if (!kvm_ioapic_handles_vector(apic, vector))
+ *   - arch/x86/kvm/lapic.c|2972| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+ */
 static bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)
 {
+	/*
+	 * 在以下使用kvm_vcpu_arch->ioapic_handled_vectors:
+	 *   - arch/x86/kvm/lapic.c|1273| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9840| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+	 *   - arch/x86/kvm/x86.c|9845| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9847| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9864| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,
+	 *              to_hv_synic(vcpu)->vec_bitmap, 256);
+	 *   - arch/x86/kvm/x86.c|9871| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10004| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+	 */
 	return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
 }
 
+/*
+ * 在以下调用kvm_ioapic_send_eoi():
+ *   - arch/x86/kvm/lapic.c|1435| <<apic_set_eoi>> kvm_ioapic_send_eoi(apic, vector);
+ *   - arch/x86/kvm/lapic.c|1450| <<kvm_apic_set_eoi_accelerated>> kvm_ioapic_send_eoi(apic, vector);
+ */
 static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)
 {
 	int trigger_mode;
@@ -1296,6 +1597,11 @@ static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)
 	kvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);
 }
 
+/*
+ * 在以下使用apic_set_eoi():
+ *   - arch/x86/kvm/lapic.c|2274| <<kvm_lapic_reg_write>> apic_set_eoi(apic);
+ *   - arch/x86/kvm/lapic.c|3015| <<apic_sync_pv_eoi_from_guest>> vector = apic_set_eoi(apic);
+ */
 static int apic_set_eoi(struct kvm_lapic *apic)
 {
 	int vector = apic_find_highest_isr(apic);
@@ -1309,6 +1615,9 @@ static int apic_set_eoi(struct kvm_lapic *apic)
 	if (vector == -1)
 		return vector;
 
+	/*
+	 * 只在此处调用apic_clear_isr()
+	 */
 	apic_clear_isr(vector, apic);
 	apic_update_ppr(apic);
 
@@ -2220,6 +2529,14 @@ int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 	 * was toggled, the APIC ID changed, etc...   The maps are marked dirty
 	 * on relevant changes, i.e. this is a nop for most writes.
 	 */
+	/*
+	 * 在以下调用kvm_recalculate_apic_map():
+	 *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+	 */
 	kvm_recalculate_apic_map(apic->vcpu->kvm);
 
 	return ret;
@@ -2350,6 +2667,12 @@ u64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)
 	return (tpr & 0xf0) >> 4;
 }
 
+/*
+ * 在以下使用kvm_lapic_set_base():
+ *   - arch/x86/kvm/lapic.c|2661| <<kvm_lapic_reset>> kvm_lapic_set_base(vcpu, msr_val);
+ *   - arch/x86/kvm/lapic.c|2989| <<kvm_apic_set_state>> kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
+ *   - arch/x86/kvm/x86.c|492| <<kvm_set_apic_base>> kvm_lapic_set_base(vcpu, msr_info->data);
+ */
 void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)
 {
 	u64 old_value = vcpu->arch.apic_base;
@@ -2399,8 +2722,33 @@ void kvm_apic_update_apicv(struct kvm_vcpu *vcpu)
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
 	if (vcpu->arch.apicv_active) {
+		/*
+		 * 在以下使用kvm_lapic->irr_pending:
+		 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+		 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+		 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+		 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+		 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+		 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+		 *
+		 * 理论上来说:
+		 * irr_pending is always true when apicv is activated.
+		 */
 		/* irr_pending is always true when apicv is activated. */
 		apic->irr_pending = true;
+		/*
+		 * 在以下使用kvm_lapic->isr_count:
+		 *   - arch/x86/kvm/lapic.c|657| <<apic_set_isr>> ++apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|658| <<apic_set_isr>> BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+		 *   - arch/x86/kvm/lapic.c|684| <<apic_find_highest_isr>> if (!apic->isr_count)
+		 *   - arch/x86/kvm/lapic.c|718| <<apic_clear_isr>> --apic->isr_count;
+		 *   - arch/x86/kvm/lapic.c|719| <<apic_clear_isr>> BUG_ON(apic->isr_count < 0);
+		 *   - arch/x86/kvm/lapic.c|2631| <<kvm_apic_update_apicv>> apic->isr_count = 1;
+		 *   - arch/x86/kvm/lapic.c|2639| <<kvm_apic_update_apicv>> apic->isr_count = count_vectors(apic->regs + APIC_ISR);
+		 */
 		apic->isr_count = 1;
 	} else {
 		/*
@@ -2411,6 +2759,16 @@ void kvm_apic_update_apicv(struct kvm_vcpu *vcpu)
 		 */
 		apic->isr_count = count_vectors(apic->regs + APIC_ISR);
 	}
+	/*
+	 * 在以下使用kvm_lapic->highest_isr_cache:
+	 *   - arch/x86/kvm/lapic.c|675| <<apic_set_isr>> apic->highest_isr_cache = vec;
+	 *   - arch/x86/kvm/lapic.c|697| <<apic_find_highest_isr>> if (likely(apic->highest_isr_cache != -1))
+	 *   - arch/x86/kvm/lapic.c|698| <<apic_find_highest_isr>> return apic->highest_isr_cache;
+	 *   - arch/x86/kvm/lapic.c|734| <<apic_clear_isr>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|2669| <<kvm_apic_update_apicv>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|3170| <<apic_sync_pv_eoi_to_guest>> apic->highest_isr_cache == -1 ||
+	 *   - arch/x86/kvm/lapic.c|3172| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+	 */
 	apic->highest_isr_cache = -1;
 }
 EXPORT_SYMBOL_GPL(kvm_apic_update_apicv);
@@ -2482,6 +2840,14 @@ void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)
 	vcpu->arch.apic_arb_prio = 0;
 	vcpu->arch.apic_attention = 0;
 
+	/*
+	 * 在以下调用kvm_recalculate_apic_map():
+	 *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+	 */
 	kvm_recalculate_apic_map(vcpu->kvm);
 }
 
@@ -2601,6 +2967,13 @@ int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)
 	return -ENOMEM;
 }
 
+/*
+ * 在以下使用kvm_apic_has_interrupt():
+ *   - arch/x86/kvm/irq.c|86| <<kvm_cpu_has_injectable_intr>> return kvm_apic_has_interrupt(v) != -1;
+ *   - arch/x86/kvm/irq.c|99| <<kvm_cpu_has_interrupt>> return kvm_apic_has_interrupt(v) != -1;
+ *   - arch/x86/kvm/lapic.c|2841| <<kvm_get_apic_interrupt>> int vector = kvm_apic_has_interrupt(vcpu);
+ *   - arch/x86/kvm/vmx/nested.c|3627| <<nested_vmx_run>> kvm_apic_has_interrupt(vcpu) == vmx->nested.posted_intr_nv) {
+ */
 int kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
@@ -2636,8 +3009,19 @@ void kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)
 	}
 }
 
+/*
+ * 在以下调用kvm_get_apic_interrupt():
+ *   - arch/x86/kvm/irq.c|138| <<kvm_cpu_get_interrupt>> return kvm_get_apic_interrupt(v);
+ */
 int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)
 {
+	/*
+	 * 在以下使用kvm_apic_has_interrupt():
+	 *   - arch/x86/kvm/irq.c|86| <<kvm_cpu_has_injectable_intr>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/irq.c|99| <<kvm_cpu_has_interrupt>> return kvm_apic_has_interrupt(v) != -1;
+	 *   - arch/x86/kvm/lapic.c|2841| <<kvm_get_apic_interrupt>> int vector = kvm_apic_has_interrupt(vcpu);
+	 *   - arch/x86/kvm/vmx/nested.c|3627| <<nested_vmx_run>> kvm_apic_has_interrupt(vcpu) == vmx->nested.posted_intr_nv) {
+	 */
 	int vector = kvm_apic_has_interrupt(vcpu);
 	struct kvm_lapic *apic = vcpu->arch.apic;
 	u32 ppr;
@@ -2667,6 +3051,10 @@ int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)
 		 * a concurrent interrupt injection, but that would have
 		 * triggered KVM_REQ_EVENT already.
 		 */
+		/*
+		 * 这里set了ISR!
+		 * 只在这一个地方调用
+		 */
 		apic_set_isr(vector, apic);
 		__apic_update_ppr(apic, &ppr);
 	}
@@ -2674,6 +3062,11 @@ int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)
 	return vector;
 }
 
+/*
+ * 在以下调用kvm_apic_state_fixup():
+ *   - arch/x86/kvm/lapic.c|3114| <<kvm_apic_get_state>> return kvm_apic_state_fixup(vcpu, s, false);
+ *   - arch/x86/kvm/lapic.c|3136| <<kvm_apic_set_state>> r = kvm_apic_state_fixup(vcpu, s, true);
+ */
 static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,
 		struct kvm_lapic_state *s, bool set)
 {
@@ -2723,26 +3116,68 @@ int kvm_apic_get_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 	__kvm_lapic_set_reg(s->regs, APIC_TMCCT,
 			    __apic_read(vcpu->arch.apic, APIC_TMCCT));
 
+	/*
+	 * 在以下调用kvm_apic_state_fixup():
+	 *   - arch/x86/kvm/lapic.c|3114| <<kvm_apic_get_state>> return kvm_apic_state_fixup(vcpu, s, false);
+	 *   - arch/x86/kvm/lapic.c|3136| <<kvm_apic_set_state>> r = kvm_apic_state_fixup(vcpu, s, true);
+	 */
 	return kvm_apic_state_fixup(vcpu, s, false);
 }
 
+/*
+ * 在以下使用kvm_apic_set_state():
+ *   - arch/x86/kvm/x86.c|4654| <<kvm_vcpu_ioctl_set_lapic>> r = kvm_apic_set_state(vcpu, s);
+ *
+ * kvm_arch_vcpu_ioctl(KVM_SET_LAPIC)
+ * -> kvm_vcpu_ioctl_set_lapic()
+ *    -> kvm_apic_set_state()
+ *       -> kvm_recalculate_apic_map() -> 只有kvm_apic_state_fixup() > 0的时候
+ *       -> kvm_recalculate_apic_map()
+ */
 int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 	int r;
 
+	/*
+	 * 在以下使用kvm_lapic_set_base():
+	 *   - arch/x86/kvm/lapic.c|2661| <<kvm_lapic_reset>> kvm_lapic_set_base(vcpu, msr_val);
+	 *   - arch/x86/kvm/lapic.c|2989| <<kvm_apic_set_state>> kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
+	 *   - arch/x86/kvm/x86.c|492| <<kvm_set_apic_base>> kvm_lapic_set_base(vcpu, msr_info->data);
+	 */
 	kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
 	/* set SPIV separately to get count of SW disabled APICs right */
 	apic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));
 
+	/*
+	 * 在以下调用kvm_apic_state_fixup():
+	 *   - arch/x86/kvm/lapic.c|3114| <<kvm_apic_get_state>> return kvm_apic_state_fixup(vcpu, s, false);
+	 *   - arch/x86/kvm/lapic.c|3136| <<kvm_apic_set_state>> r = kvm_apic_state_fixup(vcpu, s, true);
+	 */
 	r = kvm_apic_state_fixup(vcpu, s, true);
 	if (r) {
+		/*
+		 * 在以下调用kvm_recalculate_apic_map():
+		 *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+		 *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+		 *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+		 *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+		 *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+		 */
 		kvm_recalculate_apic_map(vcpu->kvm);
 		return r;
 	}
 	memcpy(vcpu->arch.apic->regs, s->regs, sizeof(*s));
 
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
+	/*
+	 * 在以下调用kvm_recalculate_apic_map():
+	 *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+	 */
 	kvm_recalculate_apic_map(vcpu->kvm);
 	kvm_apic_set_version(vcpu);
 
@@ -2847,6 +3282,21 @@ void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
 static void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,
 					struct kvm_lapic *apic)
 {
+	/*
+	 * 在以下使用kvm_lapic->irr_pending:
+	 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+	 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+	 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+	 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+	 *
+	 * 理论上来说:
+	 * irr_pending is always true when apicv is activated.
+	 */
 	if (!pv_eoi_enabled(vcpu) ||
 	    /* IRR set or many bits in ISR: could be nested. */
 	    apic->irr_pending ||
diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h
index ee42eef92f32..2dd1e9be1a3b 100644
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@ -50,10 +50,45 @@ struct kvm_lapic {
 	u32 divide_count;
 	struct kvm_vcpu *vcpu;
 	bool sw_enabled;
+	/*
+	 * 在以下使用kvm_lapic->irr_pending:
+	 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+	 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+	 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+	 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+	 *
+	 * 理论上来说:
+	 * irr_pending is always true when apicv is activated.
+	 */
 	bool irr_pending;
 	bool lvt0_in_nmi_mode;
+	/*
+	 * 在以下使用kvm_lapic->isr_count:
+	 *   - arch/x86/kvm/lapic.c|657| <<apic_set_isr>> ++apic->isr_count;
+	 *   - arch/x86/kvm/lapic.c|658| <<apic_set_isr>> BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
+	 *   - arch/x86/kvm/lapic.c|684| <<apic_find_highest_isr>> if (!apic->isr_count)
+	 *   - arch/x86/kvm/lapic.c|718| <<apic_clear_isr>> --apic->isr_count;
+	 *   - arch/x86/kvm/lapic.c|719| <<apic_clear_isr>> BUG_ON(apic->isr_count < 0);
+	 *   - arch/x86/kvm/lapic.c|2631| <<kvm_apic_update_apicv>> apic->isr_count = 1;
+	 *   - arch/x86/kvm/lapic.c|2639| <<kvm_apic_update_apicv>> apic->isr_count = count_vectors(apic->regs + APIC_ISR);
+	 */
 	/* Number of bits set in ISR. */
 	s16 isr_count;
+	/*
+	 * 在以下使用kvm_lapic->highest_isr_cache:
+	 *   - arch/x86/kvm/lapic.c|675| <<apic_set_isr>> apic->highest_isr_cache = vec;
+	 *   - arch/x86/kvm/lapic.c|697| <<apic_find_highest_isr>> if (likely(apic->highest_isr_cache != -1))
+	 *   - arch/x86/kvm/lapic.c|698| <<apic_find_highest_isr>> return apic->highest_isr_cache;
+	 *   - arch/x86/kvm/lapic.c|734| <<apic_clear_isr>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|2669| <<kvm_apic_update_apicv>> apic->highest_isr_cache = -1;
+	 *   - arch/x86/kvm/lapic.c|3170| <<apic_sync_pv_eoi_to_guest>> apic->highest_isr_cache == -1 ||
+	 *   - arch/x86/kvm/lapic.c|3172| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+	 */
 	/* The highest vector set in ISR; if -1 - invalid, must scan ISR. */
 	int highest_isr_cache;
 	/**
@@ -147,6 +182,21 @@ static inline void kvm_lapic_set_vector(int vec, void *bitmap)
 static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)
 {
 	kvm_lapic_set_vector(vec, apic->regs + APIC_IRR);
+	/*
+	 * 在以下使用kvm_lapic->irr_pending:
+	 *   - arch/x86/kvm/lapic.c|530| <<kvm_apic_update_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|548| <<apic_find_highest_irr>> if (!apic->irr_pending)
+	 *   - arch/x86/kvm/lapic.c|569| <<apic_clear_irr>> apic->irr_pending = false;
+	 *   - arch/x86/kvm/lapic.c|572| <<apic_clear_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2519| <<kvm_apic_update_apicv>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/lapic.c|2968| <<apic_sync_pv_eoi_to_guest>> apic->irr_pending ||
+	 *   - arch/x86/kvm/lapic.h|154| <<kvm_lapic_set_irr>> apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|434| <<avic_kick_target_vcpus_fast>> target_vcpu->arch.apic->irr_pending = true;
+	 *   - arch/x86/kvm/svm/avic.c|482| <<avic_kick_target_vcpus>> vcpu->arch.apic->irr_pending = true;
+	 *
+	 * 理论上来说:
+	 * irr_pending is always true when apicv is activated.
+	 */
 	/*
 	 * irr_pending must be true if any interrupt is pending; set it after
 	 * APIC_IRR to avoid race with apic_clear_irr
diff --git a/arch/x86/kvm/svm/avic.c b/arch/x86/kvm/svm/avic.c
index df2d33395a48..ffe3def8d22a 100644
--- a/arch/x86/kvm/svm/avic.c
+++ b/arch/x86/kvm/svm/avic.c
@@ -458,6 +458,25 @@ static void avic_kick_target_vcpus(struct kvm *kvm, struct kvm_lapic *source,
 	 * since entered the guest will have processed pending IRQs at VMRUN.
 	 */
 	kvm_for_each_vcpu(i, vcpu, kvm) {
+		/*
+		 * 在以下调用kvm_apic_match_dest():
+		 *   - arch/x86/kvm/ioapic.c|146| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+		 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, entry->fields.dest_id, entry->fields.dest_mode) ||
+		 *   - arch/x86/kvm/ioapic.c|414| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, e->fields.dest_id, dm) ||
+		 *   - arch/x86/kvm/irq_comm.c|68| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|359| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/irq_comm.c|442| <<kvm_scan_ioapic_routes>> if (irq.trig_mode && (kvm_apic_match_dest(vcpu, NULL,
+		 *          APIC_DEST_NOSHORT, irq.dest_id, irq.dest_mode) ||
+		 *   - arch/x86/kvm/lapic.c|1262| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+		 *          irq->shorthand, irq->dest_id, irq->dest_mode))
+		 *   - arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source,
+		 *          icrl & APIC_SHORT_MASK, dest, icrl & APIC_DEST_MASK)) {
+		 */
 		if (kvm_apic_match_dest(vcpu, source, icrl & APIC_SHORT_MASK,
 					dest, icrl & APIC_DEST_MASK)) {
 			vcpu->arch.apic->irr_pending = true;
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index d0a0883599c5..e79901c18ed1 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -6422,6 +6422,30 @@ static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu)
 	put_page(page);
 }
 
+/*
+ * vmx_hwapic_isr_update
+  kvm_lapic_reset
+  kvm_vcpu_reset
+  kvm_apic_accept_events
+  kvm_arch_vcpu_ioctl_run
+  kvm_vcpu_ioctl
+  __x64_sys_ioctl
+  do_syscall_64
+  entry_SYSCALL_64_after_hwframe
+  [unknown]
+    2
+
+  vmx_hwapic_isr_update
+  kvm_apic_set_state
+  kvm_arch_vcpu_ioctl
+  kvm_vcpu_ioctl
+  __x64_sys_ioctl
+  do_syscall_64
+  entry_SYSCALL_64_after_hwframe
+  [unknown]
+ *
+ * struct kvm_x86_ops vmx_x86_ops.hwapic_isr_update = vmx_hwapic_isr_update()
+ */
 static void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)
 {
 	u16 status;
@@ -6456,6 +6480,9 @@ static void vmx_set_rvi(int vector)
 	}
 }
 
+/*
+ * struct kvm_x86_ops vmx_x86_opshwapic_irr_update = vmx_hwapic_irr_update()
+ */
 static void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)
 {
 	/*
@@ -6470,6 +6497,16 @@ static void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)
 		vmx_set_rvi(max_irr);
 }
 
+/*
+ * 在以下调用kvm_x86_sync_pir_to_irr()
+ *   - arch/x86/kvm/lapic.c|789| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+ *   - arch/x86/kvm/x86.c|4623| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ *   - arch/x86/kvm/x86.c|9842| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ *   - arch/x86/kvm/x86.c|10171| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ *   - arch/x86/kvm/x86.c|10220| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ *
+ * struct kvm_x86_ops vmx_x86_ops.sync_pir_to_irr = vmx_sync_pir_to_irr()
+ */
 static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
@@ -6516,6 +6553,13 @@ static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)
 	return max_irr;
 }
 
+/*
+ * 在以下调用kvm_x86_load_eoi_exitmap():
+ *   - arch/x86/kvm/x86.c|9921| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, eoi_exit_bitmap);
+ *   - arch/x86/kvm/x86.c|9928| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(
+ *
+ * 在以下使用struct kvm_x86_ops vmx_x86_ops.load_eoi_exitmap = vmx_load_eoi_exitmap()
+ */
 static void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
 {
 	if (!kvm_vcpu_apicv_active(vcpu))
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 321af8f0e7ab..530950a279b2 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -473,6 +473,11 @@ enum lapic_mode kvm_get_apic_mode(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_get_apic_mode);
 
+/*
+ * 在以下使用kvm_set_apic_base():
+ *   - arch/x86/kvm/x86.c|3471| <<kvm_set_msr_common(MSR_IA32_APICBASE)>> return kvm_set_apic_base(vcpu, msr_info);
+ *   - arch/x86/kvm/x86.c|11103| <<__set_sregs_common>> if (kvm_set_apic_base(vcpu, &apic_base_msr))
+ */
 int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 {
 	enum lapic_mode old_mode = kvm_get_apic_mode(vcpu);
@@ -490,6 +495,14 @@ int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 	}
 
 	kvm_lapic_set_base(vcpu, msr_info->data);
+	/*
+	 * 在以下调用kvm_recalculate_apic_map():
+	 *   - arch/x86/kvm/lapic.c|2441| <<kvm_lapic_reg_write>> kvm_recalculate_apic_map(apic->vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2718| <<kvm_lapic_reset>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|2995| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/lapic.c|3001| <<kvm_apic_set_state>> kvm_recalculate_apic_map(vcpu->kvm);
+	 *   - arch/x86/kvm/x86.c|493| <<kvm_set_apic_base>> kvm_recalculate_apic_map(vcpu->kvm);
+	 */
 	kvm_recalculate_apic_map(vcpu->kvm);
 	return 0;
 }
@@ -4620,16 +4633,37 @@ void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
 static int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,
 				    struct kvm_lapic_state *s)
 {
+	/*
+	 * 在以下调用kvm_x86_sync_pir_to_irr()
+	 *   - arch/x86/kvm/lapic.c|789| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+	 *   - arch/x86/kvm/x86.c|4623| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|9842| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10171| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10220| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 */
 	static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
 	return kvm_apic_get_state(vcpu, s);
 }
 
+/*
+ * 在以下使用KVM_SET_LAPIC:
+ *   - arch/x86/kvm/x86.c|5200| <<kvm_arch_vcpu_ioctl(KVM_SET_LAPIC)>> r = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);
+ *
+ * kvm_arch_vcpu_ioctl(KVM_SET_LAPIC)
+ * -> kvm_vcpu_ioctl_set_lapic()
+ *    -> kvm_apic_set_state()
+ *       -> kvm_recalculate_apic_map() -> 只有kvm_apic_state_fixup() > 0的时候
+ *       -> kvm_recalculate_apic_map()
+ */
 static int kvm_vcpu_ioctl_set_lapic(struct kvm_vcpu *vcpu,
 				    struct kvm_lapic_state *s)
 {
 	int r;
 
+	/*
+	 * 只在此处调用
+	 */
 	r = kvm_apic_set_state(vcpu, s);
 	if (r)
 		return r;
@@ -5176,6 +5210,13 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 			goto out_nofree;
 		}
 
+		/*
+		 * kvm_arch_vcpu_ioctl(KVM_SET_LAPIC)
+		 * -> kvm_vcpu_ioctl_set_lapic()
+		 *    -> kvm_apic_set_state()
+		 *       -> kvm_recalculate_apic_map() -> 只有kvm_apic_state_fixup() > 0的时候
+		 *       -> kvm_recalculate_apic_map()
+		 */
 		r = kvm_vcpu_ioctl_set_lapic(vcpu, u.lapic);
 		break;
 	}
@@ -8996,13 +9037,41 @@ static void kvm_pv_kick_cpu_op(struct kvm *kvm, unsigned long flags, int apicid)
 
 bool kvm_apicv_activated(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用kvm_arch->apicv_inhibit_reasons:
+	 *   - arch/x86/kvm/x86.c|9007| <<kvm_apicv_activated>> return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
+	 *   - arch/x86/kvm/x86.c|9013| <<kvm_vcpu_apicv_activated>> ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	 *   - arch/x86/kvm/x86.c|9033| <<kvm_apicv_init>> unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9830| <<__kvm_set_or_clear_apicv_inhibit>> old = new = kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9848| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 *   - arch/x86/kvm/x86.c|9857| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 */
 	return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
 }
 EXPORT_SYMBOL_GPL(kvm_apicv_activated);
 
+/*
+ * 在以下调用kvm_vcpu_apicv_activated():
+ *   - arch/x86/kvm/svm/svm.c|1688| <<svm_set_vintr>> WARN_ON(kvm_vcpu_apicv_activated(&svm->vcpu));
+ *   - arch/x86/kvm/x86.c|9794| <<kvm_vcpu_update_apicv>> activate = kvm_vcpu_apicv_activated(vcpu) &&
+ *   - arch/x86/kvm/x86.c|10318| <<vcpu_enter_guest>> WARN_ON_ONCE((kvm_vcpu_apicv_activated(vcpu) != kvm_vcpu_apicv_active(vcpu)) &&
+ */
 bool kvm_vcpu_apicv_activated(struct kvm_vcpu *vcpu)
 {
+	/*
+	 * 在以下使用kvm_arch->apicv_inhibit_reasons:
+	 *   - arch/x86/kvm/x86.c|9007| <<kvm_apicv_activated>> return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
+	 *   - arch/x86/kvm/x86.c|9013| <<kvm_vcpu_apicv_activated>> ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	 *   - arch/x86/kvm/x86.c|9033| <<kvm_apicv_init>> unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9830| <<__kvm_set_or_clear_apicv_inhibit>> old = new = kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9848| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 *   - arch/x86/kvm/x86.c|9857| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 */
 	ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	/*
+	 * 只在这里调用
+	 * 只有amd有: avic_vcpu_get_apicv_inhibit_reasons()
+	 */
 	ulong vcpu_reasons = static_call(kvm_x86_vcpu_get_apicv_inhibit_reasons)(vcpu);
 
 	return (vm_reasons | vcpu_reasons) == 0;
@@ -9022,6 +9091,15 @@ static void set_or_clear_apicv_inhibit(unsigned long *inhibits,
 
 static void kvm_apicv_init(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用kvm_arch->apicv_inhibit_reasons:
+	 *   - arch/x86/kvm/x86.c|9007| <<kvm_apicv_activated>> return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
+	 *   - arch/x86/kvm/x86.c|9013| <<kvm_vcpu_apicv_activated>> ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	 *   - arch/x86/kvm/x86.c|9033| <<kvm_apicv_init>> unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9830| <<__kvm_set_or_clear_apicv_inhibit>> old = new = kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9848| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 *   - arch/x86/kvm/x86.c|9857| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 */
 	unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
 
 	init_rwsem(&kvm->arch.apicv_update_lock);
@@ -9724,6 +9802,10 @@ static void process_smi(struct kvm_vcpu *vcpu)
 	kvm_make_request(KVM_REQ_EVENT, vcpu);
 }
 
+/*
+ * 在以下使用kvm_make_scan_ioapic_request_mask():
+ *   - arch/x86/kvm/ioapic.c|575| <<ioapic_write_indirect>> kvm_make_scan_ioapic_request_mask(ioapic->kvm, vcpu_bitmap);
+ */
 void kvm_make_scan_ioapic_request_mask(struct kvm *kvm,
 				       unsigned long *vcpu_bitmap)
 {
@@ -9731,17 +9813,49 @@ void kvm_make_scan_ioapic_request_mask(struct kvm *kvm,
 
 	zalloc_cpumask_var(&cpus, GFP_ATOMIC);
 
+	/*
+	 * 在以下使用KVM_REQ_SCAN_IOAPIC:
+	 *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+	 *   - arch/x86/kvm/x86.c|9742| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+	 *   - arch/x86/kvm/x86.c|9750| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+	 *   - arch/x86/kvm/x86.c|10087| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
+	 *
+	 * 处理的函数vcpu_scan_ioapic()
+	 */
 	kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
 				    NULL, vcpu_bitmap, cpus);
 
 	free_cpumask_var(cpus);
 }
 
+/*
+ * 在以下使用kvm_make_scan_ioapic_request():
+ *   - arch/x86/kvm/ioapic.c|485| <<kvm_arch_post_irq_ack_notifier_list_update>> kvm_make_scan_ioapic_request(kvm);
+ *   - arch/x86/kvm/ioapic.c|578| <<ioapic_write_indirect>> kvm_make_scan_ioapic_request(ioapic->kvm);
+ *   - arch/x86/kvm/ioapic.c|1011| <<kvm_set_ioapic>> kvm_make_scan_ioapic_request(kvm);
+ *   - arch/x86/kvm/irq_comm.c|454| <<kvm_arch_post_irq_routing_update>> kvm_make_scan_ioapic_request(kvm);
+ *   - arch/x86/kvm/lapic.c|347| <<kvm_recalculate_apic_map>> kvm_make_scan_ioapic_request(kvm);
+ */
 void kvm_make_scan_ioapic_request(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用KVM_REQ_SCAN_IOAPIC:
+	 *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+	 *   - arch/x86/kvm/x86.c|9742| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+	 *   - arch/x86/kvm/x86.c|9750| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+	 *   - arch/x86/kvm/x86.c|10087| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
+	 *
+	 * 处理的函数vcpu_scan_ioapic()
+	 */
 	kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
 }
 
+/*
+ * 在以下使用kvm_vcpu_update_apicv():
+ *   - arch/x86/kvm/lapic.c|2595| <<kvm_lapic_set_base>> kvm_vcpu_update_apicv(vcpu);
+ *   - arch/x86/kvm/svm/nested.c|1033| <<nested_svm_vmexit>> kvm_vcpu_update_apicv(vcpu);
+ *   - arch/x86/kvm/x86.c|10190| <<vcpu_enter_guest(KVM_REQ_APICV_UPDATE)>> kvm_vcpu_update_apicv(vcpu);
+ */
 void kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)
 {
 	bool activate;
@@ -9789,6 +9903,15 @@ void __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 	    !static_call(kvm_x86_check_apicv_inhibit_reasons)(reason))
 		return;
 
+	/*
+	 * 在以下使用kvm_arch->apicv_inhibit_reasons:
+	 *   - arch/x86/kvm/x86.c|9007| <<kvm_apicv_activated>> return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
+	 *   - arch/x86/kvm/x86.c|9013| <<kvm_vcpu_apicv_activated>> ulong vm_reasons = READ_ONCE(vcpu->kvm->arch.apicv_inhibit_reasons);
+	 *   - arch/x86/kvm/x86.c|9033| <<kvm_apicv_init>> unsigned long *inhibits = &kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9830| <<__kvm_set_or_clear_apicv_inhibit>> old = new = kvm->arch.apicv_inhibit_reasons;
+	 *   - arch/x86/kvm/x86.c|9848| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 *   - arch/x86/kvm/x86.c|9857| <<__kvm_set_or_clear_apicv_inhibit>> kvm->arch.apicv_inhibit_reasons = new;
+	 */
 	old = new = kvm->arch.apicv_inhibit_reasons;
 
 	set_or_clear_apicv_inhibit(&new, reason, set);
@@ -9806,6 +9929,17 @@ void __kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 		 * side (handling the request) also prevents other vCPUs from
 		 * servicing the request with a stale apicv_inhibit_reasons.
 		 */
+		/*
+		 * 在以下使用KVM_REQ_APICV_UPDATE:
+		 *   - arch/x86/kvm/svm/nested.c|729| <<enter_svm_guest_mode>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/svm/nested.c|1111| <<svm_leave_nested>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/vmx/nested.c|4696| <<nested_vmx_vmexit>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/x86.c|10189| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))
+		 *   - arch/x86/kvm/x86.c|11394| <<kvm_arch_vcpu_create>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *
+		 * 处理的函数:
+		 * kvm_vcpu_update_apicv(vcpu);
+		 */
 		kvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);
 		kvm->arch.apicv_inhibit_reasons = new;
 		if (new) {
@@ -9832,6 +9966,17 @@ void kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 }
 EXPORT_SYMBOL_GPL(kvm_set_or_clear_apicv_inhibit);
 
+/*
+ * 在以下使用KVM_REQ_SCAN_IOAPIC:
+ *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+ *   - arch/x86/kvm/x86.c|9742| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+ *   - arch/x86/kvm/x86.c|9750| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+ *   - arch/x86/kvm/x86.c|10087| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu)) 
+ *
+ *
+ * 处理KVM_REQ_SCAN_IOAPIC:
+ *   - arch/x86/kvm/x86.c|10058| <<vcpu_enter_guest>> vcpu_scan_ioapic(vcpu);
+ */
 static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)
 {
 	if (!kvm_apic_present(vcpu))
@@ -9839,19 +9984,66 @@ static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)
 
 	bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
 
+	/*
+	 * 在以下调用kvm_x86_sync_pir_to_irr()
+	 *   - arch/x86/kvm/lapic.c|789| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+	 *   - arch/x86/kvm/x86.c|4623| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|9842| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10171| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10220| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *
+	 * vmx_sync_pir_to_irr()
+	 */
 	static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
+	/*
+	 * 在以下使用kvm_vcpu_arch->ioapic_handled_vectors:
+	 *   - arch/x86/kvm/lapic.c|1273| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9840| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+	 *   - arch/x86/kvm/x86.c|9845| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9847| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|9864| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,
+	 *              to_hv_synic(vcpu)->vec_bitmap, 256);
+	 *   - arch/x86/kvm/x86.c|9871| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10004| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+	 */
 	if (irqchip_split(vcpu->kvm))
 		kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
 	else if (ioapic_in_kernel(vcpu->kvm))
 		kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
 
+	/*
+	 * 在以下使用kvm_vcpu_arch->load_eoi_exitmap_pending:
+	 *   - arch/x86/kvm/kvm_cache_regs.h|184| <<leave_guest_mode>> if (vcpu->arch.load_eoi_exitmap_pending) {
+	 *   - arch/x86/kvm/kvm_cache_regs.h|185| <<leave_guest_mode>> vcpu->arch.load_eoi_exitmap_pending = false;
+	 *   - arch/x86/kvm/x86.c|9850| <<vcpu_scan_ioapic>> vcpu->arch.load_eoi_exitmap_pending = true;
+	 */
 	if (is_guest_mode(vcpu))
 		vcpu->arch.load_eoi_exitmap_pending = true;
 	else
 		kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+	/*
+	 * 在以下使用KVM_REQ_LOAD_EOI_EXITMAP:
+	 *   - arch/x86/kvm/kvm_cache_regs.h|186| <<leave_guest_mode>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+	 *   - arch/x86/kvm/x86.c|9889| <<vcpu_scan_ioapic>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+	 *   - arch/x86/kvm/x86.c|10089| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))
+	 *
+	 * 处理的函数vcpu_load_eoi_exitmap()
+	 */
 }
 
+/*
+ * 在以下使用KVM_REQ_LOAD_EOI_EXITMAP:
+ *   - arch/x86/kvm/kvm_cache_regs.h|186| <<leave_guest_mode>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+ *   - arch/x86/kvm/x86.c|9889| <<vcpu_scan_ioapic>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+ *   - arch/x86/kvm/x86.c|10089| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))
+ *
+ * 处理的函数vcpu_load_eoi_exitmap()
+ *
+ *
+ * 处理KVM_REQ_IOAPIC_EOI_EXIT:
+ *   - arch/x86/kvm/x86.c|10060| <<vcpu_enter_guest>> vcpu_load_eoi_exitmap(vcpu);
+ */
 static void vcpu_load_eoi_exitmap(struct kvm_vcpu *vcpu)
 {
 	u64 eoi_exit_bitmap[4];
@@ -9860,13 +10052,34 @@ static void vcpu_load_eoi_exitmap(struct kvm_vcpu *vcpu)
 		return;
 
 	if (to_hv_vcpu(vcpu)) {
+		/*
+		 * 在以下使用kvm_vcpu_arch->ioapic_handled_vectors:
+		 *   - arch/x86/kvm/lapic.c|1273| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+		 *   - arch/x86/kvm/x86.c|9840| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+		 *   - arch/x86/kvm/x86.c|9845| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+		 *   - arch/x86/kvm/x86.c|9847| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+		 *   - arch/x86/kvm/x86.c|9864| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,
+		 *              to_hv_synic(vcpu)->vec_bitmap, 256);
+		 *   - arch/x86/kvm/x86.c|9871| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+		 *   - arch/x86/kvm/x86.c|10004| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+		 */
 		bitmap_or((ulong *)eoi_exit_bitmap,
 			  vcpu->arch.ioapic_handled_vectors,
 			  to_hv_synic(vcpu)->vec_bitmap, 256);
+		/*
+		 * vmx_load_eoi_exitmap()
+		 */
 		static_call(kvm_x86_load_eoi_exitmap)(vcpu, eoi_exit_bitmap);
 		return;
 	}
 
+	/*
+	 * 在以下调用kvm_x86_load_eoi_exitmap():
+	 *   - arch/x86/kvm/x86.c|9921| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, eoi_exit_bitmap);
+	 *   - arch/x86/kvm/x86.c|9928| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(
+	 *
+	 * vmx_load_eoi_exitmap()
+	 */
 	static_call(kvm_x86_load_eoi_exitmap)(
 		vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
 }
@@ -10000,6 +10213,23 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 			kvm_pmu_deliver_pmi(vcpu);
 		if (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {
 			BUG_ON(vcpu->arch.pending_ioapic_eoi > 255);
+			/*
+			 * 在以下使用kvm_vcpu_arch->pending_ioapic_eoi:
+			 *   - arch/x86/kvm/lapic.c|1286| <<kvm_ioapic_send_eoi>> apic->vcpu->arch.pending_ioapic_eoi = vector;
+			 *   - arch/x86/kvm/x86.c|10008| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> BUG_ON(vcpu->arch.pending_ioapic_eoi > 255);
+			 *   - arch/x86/kvm/x86.c|10009| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> if (test_bit(vcpu->arch.pending_ioapic_eoi,
+			 *   - arch/x86/kvm/x86.c|10013| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> vcpu->arch.pending_ioapic_eoi;
+			 *
+			 * 在以下使用kvm_vcpu_arch->ioapic_handled_vectors:
+			 *   - arch/x86/kvm/lapic.c|1273| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|9840| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+			 *   - arch/x86/kvm/x86.c|9845| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|9847| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|9864| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap, vcpu->arch.ioapic_handled_vectors,
+			 *              to_hv_synic(vcpu)->vec_bitmap, 256);
+			 *   - arch/x86/kvm/x86.c|9871| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|10004| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+			 */
 			if (test_bit(vcpu->arch.pending_ioapic_eoi,
 				     vcpu->arch.ioapic_handled_vectors)) {
 				vcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;
@@ -10009,6 +10239,15 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 				goto out;
 			}
 		}
+		/*
+		 * 在以下使用KVM_REQ_SCAN_IOAPIC:
+		 *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+		 *   - arch/x86/kvm/x86.c|9742| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+		 *   - arch/x86/kvm/x86.c|9750| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+		 *   - arch/x86/kvm/x86.c|10087| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu)) 
+		 *
+		 * 处理的函数vcpu_scan_ioapic()
+		 */
 		if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
 			vcpu_scan_ioapic(vcpu);
 		if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))
@@ -10043,6 +10282,17 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 		 */
 		if (kvm_check_request(KVM_REQ_HV_STIMER, vcpu))
 			kvm_hv_process_stimers(vcpu);
+		/*
+		 * 在以下使用KVM_REQ_APICV_UPDATE:
+		 *   - arch/x86/kvm/svm/nested.c|729| <<enter_svm_guest_mode>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/svm/nested.c|1111| <<svm_leave_nested>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/vmx/nested.c|4696| <<nested_vmx_vmexit>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *   - arch/x86/kvm/x86.c|10189| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))
+		 *   - arch/x86/kvm/x86.c|11394| <<kvm_arch_vcpu_create>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+		 *
+		 * 处理的函数:
+		 * kvm_vcpu_update_apicv(vcpu);
+		 */
 		if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))
 			kvm_vcpu_update_apicv(vcpu);
 		if (kvm_check_request(KVM_REQ_APF_READY, vcpu))
@@ -10122,6 +10372,14 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 	 * use the POSTED_INTR_VECTOR even if APICv is disabled,
 	 * so do it even if APICv is disabled on this vCPU.
 	 */
+	/*
+	 * 在以下调用kvm_x86_sync_pir_to_irr()
+	 *   - arch/x86/kvm/lapic.c|789| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+	 *   - arch/x86/kvm/x86.c|4623| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|9842| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10171| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10220| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 */
 	if (kvm_lapic_enabled(vcpu))
 		static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
@@ -10171,6 +10429,14 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 		if (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST))
 			break;
 
+		/*
+		 * 在以下调用kvm_x86_sync_pir_to_irr()
+		 *   - arch/x86/kvm/lapic.c|789| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+		 *   - arch/x86/kvm/x86.c|4623| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 *   - arch/x86/kvm/x86.c|9842| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 *   - arch/x86/kvm/x86.c|10171| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 *   - arch/x86/kvm/x86.c|10220| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 */
 		if (kvm_lapic_enabled(vcpu))
 			static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
@@ -10855,6 +11121,11 @@ static bool kvm_is_valid_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
 	       kvm_is_valid_cr0(vcpu, sregs->cr0);
 }
 
+/*
+ * 在以下调用__set_sregs_common():
+ *   - arch/x86/kvm/x86.c|11200| <<__set_sregs>> int ret = __set_sregs_common(vcpu, sregs, &mmu_reset_needed, true);
+ *   - arch/x86/kvm/x86.c|11234| <<__set_sregs2>> ret = __set_sregs_common(vcpu, (struct kvm_sregs *)sregs2,
+ */
 static int __set_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs,
 		int *mmu_reset_needed, bool update_pdptrs)
 {
@@ -10927,6 +11198,11 @@ static int __set_sregs_common(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs,
 	return 0;
 }
 
+/*
+ * 在以下调用__set_sregs():
+ *   - arch/x86/kvm/x86.c|11258| <<kvm_arch_vcpu_ioctl_set_sregs>> ret = __set_sregs(vcpu, sregs);
+ *   - arch/x86/kvm/x86.c|11438| <<sync_regs>> if (__set_sregs(vcpu, &vcpu->run->s.regs.sregs))
+ */
 static int __set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
 {
 	int pending_vec, max_bits;
@@ -10951,6 +11227,10 @@ static int __set_sregs(struct kvm_vcpu *vcpu, struct kvm_sregs *sregs)
 	return 0;
 }
 
+/*
+ * 在以下调用__set_sregs2():
+ *   - arch/x86/kvm/x86.c|5597| <<kvm_arch_vcpu_ioctl(KVM_SET_SREGS2)>> r = __set_sregs2(vcpu, u.sregs2);
+ */
 static int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)
 {
 	int mmu_reset_needed = 0;
@@ -10983,6 +11263,10 @@ static int __set_sregs2(struct kvm_vcpu *vcpu, struct kvm_sregs2 *sregs2)
 	return 0;
 }
 
+/*
+ * 处理KVM_SET_SREGS:
+ *   - virt/kvm/kvm_main.c|4062| <<kvm_vcpu_ioctl(KVM_SET_SREGS)>> r = kvm_arch_vcpu_ioctl_set_sregs(vcpu, kvm_sregs);
+ */
 int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,
 				  struct kvm_sregs *sregs)
 {
@@ -11162,6 +11446,10 @@ static void store_regs(struct kvm_vcpu *vcpu)
 				vcpu, &vcpu->run->s.regs.events);
 }
 
+/*
+ * 在以下调用sync_regs():
+ *   - arch/x86/kvm/x86.c|10808| <<kvm_arch_vcpu_ioctl_run>> r = sync_regs(vcpu); 
+ */
 static int sync_regs(struct kvm_vcpu *vcpu)
 {
 	if (vcpu->run->kvm_dirty_regs & KVM_SYNC_X86_REGS) {
@@ -11232,6 +11520,17 @@ int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
 		 */
 		if (enable_apicv) {
 			vcpu->arch.apicv_active = true;
+			/*
+			 * 在以下使用KVM_REQ_APICV_UPDATE:
+			 *   - arch/x86/kvm/svm/nested.c|729| <<enter_svm_guest_mode>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+			 *   - arch/x86/kvm/svm/nested.c|1111| <<svm_leave_nested>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+			 *   - arch/x86/kvm/vmx/nested.c|4696| <<nested_vmx_vmexit>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+			 *   - arch/x86/kvm/x86.c|10189| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))
+			 *   - arch/x86/kvm/x86.c|11394| <<kvm_arch_vcpu_create>> kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
+			 *
+			 * 处理的函数:
+			 * kvm_vcpu_update_apicv(vcpu);
+			 */
 			kvm_make_request(KVM_REQ_APICV_UPDATE, vcpu);
 		}
 	} else
@@ -11715,6 +12014,12 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 	if (ret)
 		return ret;
 
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|234| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|11763| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
 	INIT_LIST_HEAD(&kvm->arch.active_mmu_pages);
 	INIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);
@@ -11722,6 +12027,13 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 	INIT_LIST_HEAD(&kvm->arch.assigned_dev_head);
 	atomic_set(&kvm->arch.noncoherent_dma_count, 0);
 
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|187| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|219| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11732| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|11735| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */
 	set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
 	/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */
diff --git a/drivers/acpi/acpica/dbexec.c b/drivers/acpi/acpica/dbexec.c
index d3a9521e2dc8..78134e2119ff 100644
--- a/drivers/acpi/acpica/dbexec.c
+++ b/drivers/acpi/acpica/dbexec.c
@@ -692,6 +692,26 @@ acpi_db_create_execution_thread(char *method_name_arg,
 		return;
 	}
 
+	/*
+	 * 在以下调用acpi_os_execute():
+	 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+	 *            acpi_db_execute_thread, NULL);
+	 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+	 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+	 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+	 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_notify_dispatch, info);
+	 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_notify_device_fixed, data);
+	 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+	 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            rbtn_clear_suspended_flag, rbtn_data);
+	 */
 	status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
 				 acpi_db_single_execution_thread,
 				 &acpi_gbl_db_method_info);
@@ -845,6 +865,26 @@ acpi_db_create_execution_threads(char *num_threads_arg,
 		       num_threads, num_loops);
 
 	for (i = 0; i < (num_threads); i++) {
+		/*
+		 * 在以下调用acpi_os_execute():
+		 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+		 *            acpi_db_execute_thread, NULL);
+		 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+		 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+		 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+		 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_notify_dispatch, info);
+		 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_notify_device_fixed, data);
+		 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+		 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            rbtn_clear_suspended_flag, rbtn_data);
+		 */
 		status =
 		    acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
 				    acpi_db_method_thread,
diff --git a/drivers/acpi/acpica/dbxface.c b/drivers/acpi/acpica/dbxface.c
index 9dfd693cda3e..ac899207a957 100644
--- a/drivers/acpi/acpica/dbxface.c
+++ b/drivers/acpi/acpica/dbxface.c
@@ -445,6 +445,26 @@ acpi_status acpi_initialize_debugger(void)
 		/* Create the debug execution thread to execute commands */
 
 		acpi_gbl_db_threads_terminated = FALSE;
+		/*
+		 * 在以下调用acpi_os_execute():
+		 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+		 *            acpi_db_execute_thread, NULL);
+		 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+		 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+		 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+		 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_notify_dispatch, info);
+		 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_notify_device_fixed, data);
+		 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+		 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            rbtn_clear_suspended_flag, rbtn_data);
+		 */
 		status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
 					 acpi_db_execute_thread, NULL);
 		if (ACPI_FAILURE(status)) {
diff --git a/drivers/acpi/acpica/evgpe.c b/drivers/acpi/acpica/evgpe.c
index c5a06882bdf6..90b712b390cd 100644
--- a/drivers/acpi/acpica/evgpe.c
+++ b/drivers/acpi/acpica/evgpe.c
@@ -523,6 +523,26 @@ static void ACPI_SYSTEM_XFACE acpi_ev_asynch_execute_gpe_method(void *context)
 
 	/* Defer enabling of GPE until all notify handlers are done */
 
+	/*
+	 * 在以下调用acpi_os_execute():
+	 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+	 *            acpi_db_execute_thread, NULL);
+	 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+	 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+	 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+	 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_notify_dispatch, info);
+	 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_notify_device_fixed, data);
+	 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+	 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            rbtn_clear_suspended_flag, rbtn_data);
+	 */
 	status = acpi_os_execute(OSL_NOTIFY_HANDLER,
 				 acpi_ev_asynch_enable_gpe, gpe_event_info);
 	if (ACPI_SUCCESS(status)) {
@@ -816,6 +836,26 @@ acpi_ev_gpe_dispatch(struct acpi_namespace_node *gpe_device,
 
 	case ACPI_GPE_DISPATCH_METHOD:
 	case ACPI_GPE_DISPATCH_NOTIFY:
+		/*
+		 * 在以下调用acpi_os_execute():
+		 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+		 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+		 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+		 *            acpi_db_execute_thread, NULL);
+		 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+		 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+		 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+		 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_ev_notify_dispatch, info);
+		 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            acpi_notify_device_fixed, data);
+		 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+		 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+		 *            rbtn_clear_suspended_flag, rbtn_data);
+		 */
 		/*
 		 * Execute the method associated with the GPE
 		 * NOTE: Level-triggered GPEs are cleared after the method completes.
diff --git a/drivers/acpi/acpica/evmisc.c b/drivers/acpi/acpica/evmisc.c
index f14ebcd610ab..f9a29335e64f 100644
--- a/drivers/acpi/acpica/evmisc.c
+++ b/drivers/acpi/acpica/evmisc.c
@@ -136,6 +136,26 @@ acpi_ev_queue_notify_request(struct acpi_namespace_node *node, u32 notify_value)
 			  acpi_ut_get_notify_name(notify_value, ACPI_TYPE_ANY),
 			  node));
 
+	/*
+	 * 在以下调用acpi_os_execute():
+	 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+	 *            acpi_db_execute_thread, NULL);
+	 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+	 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+	 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+	 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_notify_dispatch, info);
+	 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_notify_device_fixed, data);
+	 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+	 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            rbtn_clear_suspended_flag, rbtn_data);
+	 */
 	status = acpi_os_execute(OSL_NOTIFY_HANDLER,
 				 acpi_ev_notify_dispatch, info);
 	if (ACPI_FAILURE(status)) {
@@ -158,6 +178,10 @@ acpi_ev_queue_notify_request(struct acpi_namespace_node *node, u32 notify_value)
  *
  ******************************************************************************/
 
+/*
+ * 在以下使用acpi_ev_notify_dispatch():
+ *   - drivers/acpi/acpica/evmisc.c|160| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_ev_notify_dispatch, info);
+ */
 static void ACPI_SYSTEM_XFACE acpi_ev_notify_dispatch(void *context)
 {
 	union acpi_generic_state *info = (union acpi_generic_state *)context;
diff --git a/drivers/acpi/acpica/nsxfeval.c b/drivers/acpi/acpica/nsxfeval.c
index f9d059647cc5..9c8a396ee144 100644
--- a/drivers/acpi/acpica/nsxfeval.c
+++ b/drivers/acpi/acpica/nsxfeval.c
@@ -922,6 +922,13 @@ ACPI_EXPORT_SYMBOL(acpi_detach_data)
  *              and execute a callback before returning.
  *
  ******************************************************************************/
+/*
+ * 在以下调用acpi_get_data_full():
+ *   - drivers/acpi/acpica/nsxfeval.c|979| <<acpi_get_data>> return acpi_get_data_full(obj_handle, handler, data, NULL);
+ *   - drivers/acpi/scan.c|576| <<acpi_get_data>> status = acpi_get_data_full(handle, acpi_scan_drop_device, (void **)&adev, callback);
+ *
+ * callback的一个例子是get_acpi_device()
+ */
 acpi_status
 acpi_get_data_full(acpi_handle obj_handle, acpi_object_handler handler,
 		   void **data, void (*callback)(void *))
@@ -950,6 +957,9 @@ acpi_get_data_full(acpi_handle obj_handle, acpi_object_handler handler,
 
 	status = acpi_ns_get_attached_data(node, handler, data);
 	if (ACPI_SUCCESS(status) && callback) {
+		/*
+		 * 比如get_acpi_device()
+		 */
 		callback(*data);
 	}
 
diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 30938e61d54b..b538c14ef011 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -445,6 +445,20 @@ static void acpi_bus_osc_negotiate_usb_control(void)
  * ---------------
  * Callback for all 'system-level' device notifications (values 0x00-0x7F).
  */
+/*
+ * [0] acpi_bus_notify
+ * [0] acpi_ev_notify_dispatch
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下使用acpi_bus_notify():
+ *   -  drivers/acpi/bus.c|1335| <<acpi_bus_init>> status =
+ *                  acpi_install_notify_handler(ACPI_ROOT_OBJECT, ACPI_SYSTEM_NOTIFY,
+ *                                              &acpi_bus_notify, NULL);
+ */
 static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 {
 	struct acpi_device *adev;
@@ -496,6 +510,14 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 	}
 
+	/*
+	 * 在以下调用acpi_bus_get_acpi_device():
+	 *   - drivers/acpi/bus.c|508| <<acpi_bus_notify>> adev = acpi_bus_get_acpi_device(handle);
+	 *   - drivers/acpi/device_pm.c|447| <<acpi_pm_notify_handler>> adev = acpi_bus_get_acpi_device(handle);
+	 *   - drivers/acpi/irq.c|127| <<acpi_get_irq_source_fwhandle>> device = acpi_bus_get_acpi_device(handle);
+	 *   - drivers/acpi/scan.c|2223| <<acpi_dev_get_first_consumer_dev_cb>> adev = acpi_bus_get_acpi_device(dep->consumer);
+	 *   - drivers/acpi/scan.c|2276| <<acpi_scan_clear_dep>> struct acpi_device *adev = acpi_bus_get_acpi_device(dep->consumer);
+	 */
 	adev = acpi_bus_get_acpi_device(handle);
 	if (!adev)
 		goto err;
@@ -536,6 +558,26 @@ static void acpi_notify_device_fixed(void *data)
 
 static u32 acpi_device_fixed_event(void *data)
 {
+	/*
+	 * 在以下调用acpi_os_execute():
+	 *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+	 *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+	 *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+	 *            acpi_db_execute_thread, NULL);
+	 *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+	 *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+	 *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+	 *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_ev_notify_dispatch, info);
+	 *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            acpi_notify_device_fixed, data);
+	 *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+	 *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+	 *            rbtn_clear_suspended_flag, rbtn_data);
+	 */
 	acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_notify_device_fixed, data);
 	return ACPI_INTERRUPT_HANDLED;
 }
diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 45c5c0e45e33..8d26237c82a1 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -841,8 +841,20 @@ acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 }
 #endif
 
+/*
+ * 在以下使用acpi_os_execute_deferred():
+ *   - drivers/acpi/osl.c|1104| <<acpi_os_execute>> INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+ *   - drivers/acpi/osl.c|1107| <<acpi_os_execute>> INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+ */
 static void acpi_os_execute_deferred(struct work_struct *work)
 {
+	/*
+	 * struct acpi_os_dpc {
+	 *     acpi_osd_exec_callback function;
+	 *     void *context;
+	 *     struct work_struct work;
+	 * };
+	 */
 	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
 
 	dpc->function(dpc->context);
@@ -1058,6 +1070,65 @@ int __init acpi_debugger_init(void)
  *
  ******************************************************************************/
 
+/*
+ * hotplug pci的时候调用三次.
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_gpe_dispatch
+ * [0] acpi_ev_detect_gpe
+ * [0] acpi_ev_gpe_detect
+ * [0] acpi_ev_sci_xrupt_handler
+ * [0] acpi_irq
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_fasteoi_irq
+ * [0] __common_interrupt
+ * [0] common_interrupt
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_queue_notify_request
+ * [0] acpi_ds_exec_end_op
+ * [0] acpi_ps_parse_loop
+ * [0] acpi_ps_parse_aml
+ * [0] acpi_ps_execute_method
+ * [0] acpi_ns_evaluate
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] acpi_os_execute
+ * [0] acpi_ev_asynch_execute_gpe_method
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ *
+ * 在以下调用acpi_os_execute():
+ *   - drivers/acpi/acpica/dbexec.c|695| <<acpi_db_create_execution_thread>> status = acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+ *            acpi_db_single_execution_thread, &acpi_gbl_db_method_info);
+ *   - drivers/acpi/acpica/dbexec.c|849| <<acpi_db_create_execution_threads>> acpi_os_execute(OSL_DEBUGGER_EXEC_THREAD,
+ *            acpi_db_method_thread, &acpi_gbl_db_method_info);
+ *   - drivers/acpi/acpica/dbxface.c|448| <<acpi_initialize_debugger>> status = acpi_os_execute(OSL_DEBUGGER_MAIN_THREAD,
+ *            acpi_db_execute_thread, NULL);
+ *   - drivers/acpi/acpica/evgpe.c|526| <<acpi_ev_asynch_execute_gpe_method>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+ *            acpi_ev_asynch_enable_gpe, gpe_event_info);
+ *   - drivers/acpi/acpica/evgpe.c|823| <<acpi_ev_gpe_dispatch>> status = acpi_os_execute(OSL_GPE_HANDLER,
+ *            acpi_ev_asynch_execute_gpe_method, gpe_event_info);
+ *   - drivers/acpi/acpica/evmisc.c|139| <<acpi_ev_queue_notify_request>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+ *            acpi_ev_notify_dispatch, info);
+ *   - drivers/acpi/bus.c|539| <<acpi_device_fixed_event>> acpi_os_execute(OSL_NOTIFY_HANDLER,
+ *            acpi_notify_device_fixed, data);
+ *   - drivers/acpi/sbshc.c|232| <<smbus_alarm>> acpi_os_execute(OSL_NOTIFY_HANDLER, acpi_smbus_callback, hc);
+ *   - drivers/platform/x86/dell/dell-rbtn.c|278| <<rbtn_resume>> status = acpi_os_execute(OSL_NOTIFY_HANDLER,
+ *            rbtn_clear_suspended_flag, rbtn_data);
+ *
+ * hotplug的时候type好像是2, 1, 1
+ */
 acpi_status acpi_os_execute(acpi_execute_type type,
 			    acpi_osd_exec_callback function, void *context)
 {
@@ -1087,6 +1158,13 @@ acpi_status acpi_os_execute(acpi_execute_type type,
 	 * having a static work_struct.
 	 */
 
+	/*
+	 * struct acpi_os_dpc {
+	 *     acpi_osd_exec_callback function;
+	 *     void *context;
+	 *     struct work_struct work;
+	 * };
+	 */
 	dpc = kzalloc(sizeof(struct acpi_os_dpc), GFP_ATOMIC);
 	if (!dpc)
 		return AE_NO_MEMORY;
@@ -1152,6 +1230,18 @@ struct acpi_hp_work {
 	u32 src;
 };
 
+/*
+ * [0] acpiphp_hotplug_notify
+ * [0] acpi_device_hotplug
+ * [0] acpi_hotplug_work_fn
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下使用acpi_hotplug_work_fn():
+ *   - drivers/acpi/osl.c|1210| <<acpi_hotplug_schedule>> INIT_WORK(&hpw->work, acpi_hotplug_work_fn);
+ */
 static void acpi_hotplug_work_fn(struct work_struct *work)
 {
 	struct acpi_hp_work *hpw = container_of(work, struct acpi_hp_work, work);
@@ -1161,6 +1251,20 @@ static void acpi_hotplug_work_fn(struct work_struct *work)
 	kfree(hpw);
 }
 
+/*
+ * [0] acpi_hotplug_schedule
+ * [0] acpi_bus_notify
+ * [0] acpi_ev_notify_dispatch
+ * [0] acpi_os_execute_deferred
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下调用acpi_hotplug_schedule():
+ *   - drivers/acpi/bus.c|522| <<acpi_bus_notify>> if (ACPI_SUCCESS(acpi_hotplug_schedule(adev, type)))
+ *   - drivers/acpi/device_sysfs.c|388| <<eject_store>> status = acpi_hotplug_schedule(acpi_device, ACPI_OST_EC_OSPM_EJECT);
+ */
 acpi_status acpi_hotplug_schedule(struct acpi_device *adev, u32 src)
 {
 	struct acpi_hp_work *hpw;
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e7d4a39e539f..129ea08ffbe4 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -376,6 +376,83 @@ static int acpi_generic_hotplug_event(struct acpi_device *adev, u32 type)
 	return -EINVAL;
 }
 
+/*
+ * [  433.553792] <intr> acpi:624: ACPI: GPE event 0x01
+ * [  433.554104] [426] acpi:462: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: ACPI_NOTIFY_DEVICE_CHECK event
+ * [  433.554110] [426] acpi:1168: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: OSL: Scheduling hotplug event 1 for deferred handling
+ * [  433.554178] [97] acpiphp:803: ACPI: \_SB_.PCI0.S29_.S00_: acpiphp_glue: Device check in hotplug_event()
+ * [  433.554184] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._ADR: ACPI: No context!
+ * [  433.554186] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_.ASUN: ACPI: No context!
+ * [  433.554188] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._DSM: ACPI: No context!
+ * [  433.554190] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._SUN: ACPI: No context!
+ * [  433.554191] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._EJ0: ACPI: No context!
+ * [  433.554197] [97] acpi:28: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Evaluate [_STA]: AE_NOT_FOUND
+ * [  433.554199] [97] acpi:125: ACPI: Device [S00] status [0000000f]
+ * [  433.554356] [97] acpi:273: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Return value [0]
+ * [  433.554359] [97] acpi:273: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Return value [0]
+ * [  433.554419] pci 0000:02:00.0: [1af4:1048] type 00 class 0x010000
+ * [  433.555885] pci 0000:02:00.0: reg 0x14: [mem 0x00000000-0x00000fff]
+ * [  433.557122] pci 0000:02:00.0: reg 0x20: [mem 0x00000000-0x00003fff 64bit pref]
+ * [  433.559748] [97] edr:233: pci 0000:02:00.0: EDR: Notify handler installed
+ * [  433.559766] [97] acpi:324: wakeup wakeup15: No ACPI support
+ * [  433.559838] [97] acpi:318: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: Bound to device 0000:02:00.0
+ * [  433.560376] [97] acpi:28: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Evaluate [_STA]: AE_NOT_FOUND
+ * [  433.560402] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._ADR: ACPI: No context!
+ * [  433.560404] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_.ASUN: ACPI: No context!
+ * [  433.560405] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._DSM: ACPI: No context!
+ * [  433.560407] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._SUN: ACPI: No context!
+ * [  433.560409] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._EJ0: ACPI: No context!
+ * [  433.560411] [97] acpi:28: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Evaluate [_STA]: AE_NOT_FOUND
+ * [  433.560412] [97] acpi:125: ACPI: Device [S00] status [0000000f]
+ * [  433.560430] pci 0000:02:00.0: BAR 4: assigned [mem 0x802000000-0x802003fff 64bit pref]
+ * [  433.561843] pci 0000:02:00.0: BAR 1: assigned [mem 0x81200000-0x81200fff]
+ * [  433.563130] [97] acpi:1591: pciback 0000:02:00.0: Adding to IOMMU failed: -19
+ * [  433.563136] [97] setup_irq:27: pciback 0000:02:00.0: runtime IRQ mapping not provided by arch
+ * [  433.563161] [97] acpi:1591: virtio-pci 0000:02:00.0: Adding to IOMMU failed: -19
+ * [  433.563164] [97] setup_irq:27: virtio-pci 0000:02:00.0: runtime IRQ mapping not provided by arch
+ * [  433.563197] virtio-pci 0000:02:00.0: enabling device (0000 -> 0002)
+ * [  433.565778] [97] acpi:190: ACPI: PCI: 0000:00:05[A] -> \_SB_.GSIF[0]
+ * [  433.565782] [97] acpi:327: virtio-pci 0000:02:00.0: Derived GSI INT A from 0000:00:05.1
+ * [  433.565786] [97] acpi:649: ACPI: \_SB_.GSIF: ACPI: PCI: Link is referenced
+ * [  433.565791] [97] acpi:466: virtio-pci 0000:02:00.0: PCI INT A -> Link[GSIF] -> GSI 21 (level, high) -> IRQ 21
+ * [  433.566517] [97] pci:4371: virtio-pci 0000:02:00.0: enabling bus mastering
+ * [  433.567195] [97] acpi:324: virtio virtio1: No ACPI support
+ * [  433.567502] [97] acpi:324: workqueue scsi_tmf_7: No ACPI support
+ * [  433.568580] scsi host7: Virtio SCSI HBA
+ * [  433.569371] [97] acpi:324: scsi host7: No ACPI support
+ * [  433.569420] [97] acpi:324: scsi_host host7: No ACPI support
+ * [  433.574553] scsi 7:0:1:0: Direct-Access     LIO-ORG  storage02        4.0  PQ: 0 ANSI: 6
+ * [  433.589101] [1935] acpi:324: scsi target7:0:1: No ACPI support
+ * [  433.589137] scsi 7:0:1:0: alua: supports implicit and explicit TPGS
+ * [  433.590341] scsi 7:0:1:0: alua: device naa.6001405428c34d0d8a342cdbb4597c72 port group 0 rel port 1
+ * [  433.591927] [1935] acpi:324: scsi 7:0:1:0: No ACPI support
+ * [  433.591985] [1935] acpi:324: scsi_device 7:0:1:0: No ACPI support
+ * [  433.592021] [1935] acpi:324: scsi_generic sg3: No ACPI support
+ * [  433.592093] [105] acpi:324: scsi_disk 7:0:1:0: No ACPI support
+ * [  433.592302] sd 7:0:1:0: Attached scsi generic sg3 type 0
+ * [  433.592332] sd 7:0:1:0: [sdc] 262144 512-byte logical blocks: (134 MB/128 MiB)
+ * [  433.593213] [1935] acpi:324: bsg 7:0:1:0: No ACPI support
+ * [  433.594767] sd 7:0:1:0: [sdc] Write Protect is off
+ * [  433.595651] sd 7:0:1:0: [sdc] Mode Sense: 43 00 10 08
+ * [  433.595722] sd 7:0:1:0: [sdc] Write cache: enabled, read cache: enabled, supports DPO and FUA
+ * [  433.597263] sd 7:0:1:0: alua: transition timeout set to 60 seconds
+ * [  433.597270] sd 7:0:1:0: alua: port group 00 state A non-preferred supports TOlUSNA
+ * [  433.703687] sd 7:0:1:0: [sdc] Optimal transfer size 8388608 bytes
+ * [  433.705139] [105] acpi:324: block sdc: No ACPI support
+ * [  433.705660] [105] acpi:324: bdi 8:32: No ACPI support
+ * [  433.706272] sd 7:0:1:0: [sdc] Attached SCSI disk
+ *
+ * [0] acpiphp_hotplug_notify
+ * [0] acpi_device_hotplug
+ * [0] acpi_hotplug_work_fn
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下调用acpi_device_hotplug():
+ *   - drivers/acpi/osl.c|1250| <<acpi_hotplug_work_fn>> acpi_device_hotplug(hpw->adev, hpw->src);
+ */
 void acpi_device_hotplug(struct acpi_device *adev, u32 src)
 {
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
@@ -567,12 +644,23 @@ static void acpi_scan_drop_device(acpi_handle handle, void *context)
 	mutex_unlock(&acpi_device_del_lock);
 }
 
+/*
+ * 在以下使用handle_to_device():
+ *   - drivers/acpi/scan.c|590| <<acpi_bus_get_device>> *device = handle_to_device(handle, NULL);
+ *   - drivers/acpi/scan.c|607| <<acpi_fetch_acpi_dev>> return handle_to_device(handle, NULL);
+ *   - drivers/acpi/scan.c|618| <<acpi_bus_get_acpi_device>> return handle_to_device(handle, get_acpi_device);
+ */
 static struct acpi_device *handle_to_device(acpi_handle handle,
 					    void (*callback)(void *))
 {
 	struct acpi_device *adev = NULL;
 	acpi_status status;
 
+	/*
+	 * 在以下调用acpi_get_data_full():
+	 *   - drivers/acpi/acpica/nsxfeval.c|979| <<acpi_get_data>> return acpi_get_data_full(obj_handle, handler, data, NULL);
+	 *   - drivers/acpi/scan.c|576| <<acpi_get_data>> status = acpi_get_data_full(handle, acpi_scan_drop_device, (void **)&adev, callback);
+	 */
 	status = acpi_get_data_full(handle, acpi_scan_drop_device,
 				    (void **)&adev, callback);
 	if (ACPI_FAILURE(status) || !adev) {
@@ -587,6 +675,12 @@ int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
 	if (!device)
 		return -EINVAL;
 
+	/*
+	 * 在以下使用handle_to_device():
+	 *   - drivers/acpi/scan.c|590| <<acpi_bus_get_device>> *device = handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|607| <<acpi_fetch_acpi_dev>> return handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|618| <<acpi_bus_get_acpi_device>> return handle_to_device(handle, get_acpi_device);
+	 */
 	*device = handle_to_device(handle, NULL);
 	if (!*device)
 		return -ENODEV;
@@ -604,6 +698,12 @@ EXPORT_SYMBOL(acpi_bus_get_device);
  */
 struct acpi_device *acpi_fetch_acpi_dev(acpi_handle handle)
 {
+	/*
+	 * 在以下使用handle_to_device():
+	 *   - drivers/acpi/scan.c|590| <<acpi_bus_get_device>> *device = handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|607| <<acpi_fetch_acpi_dev>> return handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|618| <<acpi_bus_get_acpi_device>> return handle_to_device(handle, get_acpi_device);
+	 */
 	return handle_to_device(handle, NULL);
 }
 EXPORT_SYMBOL_GPL(acpi_fetch_acpi_dev);
@@ -613,8 +713,22 @@ static void get_acpi_device(void *dev)
 	acpi_dev_get(dev);
 }
 
+/*
+ * 在以下调用acpi_bus_get_acpi_device():
+ *   - drivers/acpi/bus.c|508| <<acpi_bus_notify>> adev = acpi_bus_get_acpi_device(handle);
+ *   - drivers/acpi/device_pm.c|447| <<acpi_pm_notify_handler>> adev = acpi_bus_get_acpi_device(handle);
+ *   - drivers/acpi/irq.c|127| <<acpi_get_irq_source_fwhandle>> device = acpi_bus_get_acpi_device(handle);
+ *   - drivers/acpi/scan.c|2223| <<acpi_dev_get_first_consumer_dev_cb>> adev = acpi_bus_get_acpi_device(dep->consumer);
+ *   - drivers/acpi/scan.c|2276| <<acpi_scan_clear_dep>> struct acpi_device *adev = acpi_bus_get_acpi_device(dep->consumer);
+ */
 struct acpi_device *acpi_bus_get_acpi_device(acpi_handle handle)
 {
+	/*
+	 * 在以下使用handle_to_device():
+	 *   - drivers/acpi/scan.c|590| <<acpi_bus_get_device>> *device = handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|607| <<acpi_fetch_acpi_dev>> return handle_to_device(handle, NULL);
+	 *   - drivers/acpi/scan.c|618| <<acpi_bus_get_acpi_device>> return handle_to_device(handle, get_acpi_device);
+	 */
 	return handle_to_device(handle, get_acpi_device);
 }
 
diff --git a/drivers/pci/hotplug/acpiphp_glue.c b/drivers/pci/hotplug/acpiphp_glue.c
index f031302ad401..59ad53caa2fc 100644
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@ -56,6 +56,10 @@ static void free_bridge(struct kref *kref);
  *
  * Call under acpi_hp_context_lock.
  */
+/*
+ * 在以下使用acpiphp_init_context():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|255| <<acpiphp_add_context>> context = acpiphp_init_context(adev);
+ */
 static struct acpiphp_context *acpiphp_init_context(struct acpi_device *adev)
 {
 	struct acpiphp_context *context;
@@ -117,12 +121,25 @@ static inline void put_bridge(struct acpiphp_bridge *bridge)
 	kref_put(&bridge->ref, free_bridge);
 }
 
+/*
+ * 在以下调用acpiphp_grab_context():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|195| <<acpiphp_post_dock_fixup>> struct acpiphp_context *context = acpiphp_grab_context(adev);
+ *   - drivers/pci/hotplug/acpiphp_glue.c|861| <<acpiphp_hotplug_notify>> context = acpiphp_grab_context(adev);
+ */
 static struct acpiphp_context *acpiphp_grab_context(struct acpi_device *adev)
 {
 	struct acpiphp_context *context;
 
 	acpi_lock_hp_context();
 
+	/*
+	 * struct acpiphp_context {
+	 *     struct acpi_hotplug_context hp;
+	 *     struct acpiphp_func func;
+	 *     struct acpiphp_bridge *bridge;
+	 *     unsigned int refcount;
+	 * };
+	 */
 	context = acpiphp_get_context(adev);
 	if (!context)
 		goto unlock;
@@ -223,6 +240,10 @@ static void acpiphp_post_dock_fixup(struct acpi_device *adev)
  * @data: The object's parent ACPIPHP bridge.
  * @rv: Not used.
  */
+/*
+ * 在以下使用acpiphp_add_context():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|916| <<acpiphp_enumerate_slots>> acpiphp_add_context, NULL, bridge, NULL);
+ */
 static acpi_status acpiphp_add_context(acpi_handle handle, u32 lvl, void *data,
 				       void **rv)
 {
@@ -771,10 +792,31 @@ void acpiphp_check_host_bridge(struct acpi_device *adev)
 
 static int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot);
 
+/*
+ * 在以下调用hotplug_event():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|836| <<acpiphp_hotplug_notify>> hotplug_event(type, context);
+ */
 static void hotplug_event(u32 type, struct acpiphp_context *context)
 {
+	/*
+	 * struct acpiphp_context *context:
+	 * -> struct acpi_hotplug_context hp;
+	 *    -> struct acpi_device *self;
+	 */
 	acpi_handle handle = context->hp.self->handle;
 	struct acpiphp_func *func = &context->func;
+	/*
+	 * struct acpiphp_slot {
+	 *     struct list_head node;
+	 *     struct pci_bus *bus;
+	 *     struct list_head funcs;          one slot may have different
+         *                                      objects (i.e. for each function)
+	 *     struct slot *slot;
+	 *
+	 *     u8              device;         // pci device# 
+	 *     u32             flags;          // see below 
+	 * };
+	 */
 	struct acpiphp_slot *slot = func->slot;
 	struct acpiphp_bridge *bridge;
 
@@ -825,14 +867,34 @@ static void hotplug_event(u32 type, struct acpiphp_context *context)
 		put_bridge(bridge);
 }
 
+/*
+ * [0] acpiphp_hotplug_notify
+ * [0] acpi_device_hotplug
+ * [0] acpi_hotplug_work_fn
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * 在以下使用acpiphp_hotplug_notify():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|72| <<acpiphp_init_context>> context->hp.notify = acpiphp_hotplug_notify;
+ */
 static int acpiphp_hotplug_notify(struct acpi_device *adev, u32 type)
 {
 	struct acpiphp_context *context;
 
+	/*
+	 * 在以下调用acpiphp_grab_context():
+	 *   - drivers/pci/hotplug/acpiphp_glue.c|195| <<acpiphp_post_dock_fixup>> struct acpiphp_context *context = acpiphp_grab_context(adev);
+	 *   - drivers/pci/hotplug/acpiphp_glue.c|861| <<acpiphp_hotplug_notify>> context = acpiphp_grab_context(adev);
+	 */
 	context = acpiphp_grab_context(adev);
 	if (!context)
 		return -ENODATA;
 
+	/*
+	 * 只在此处调用
+	 */
 	hotplug_event(type, context);
 	acpiphp_let_context_go(context);
 	return 0;
@@ -845,6 +907,35 @@ static int acpiphp_hotplug_notify(struct acpi_device *adev, u32 type)
  * A "slot" is an object associated with a PCI device number.  All functions
  * (PCI devices) with the same bus and device number belong to the same slot.
  */
+/*
+ * [0] acpiphp_init_context
+ * [0] acpiphp_add_context
+ * [0] acpi_ns_walk_namespace
+ * [0] acpi_walk_namespace
+ * [0] acpiphp_enumerate_slots
+ * [0] acpi_pci_add_bus
+ * [0] pci_alloc_child_bus
+ * [0] pci_scan_bridge_extend
+ * [0] pci_scan_child_bus_extend
+ * [0] acpi_pci_root_create
+ * [0] pci_acpi_scan_root
+ * [0] acpi_pci_root_add
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_scan
+ * [0] acpi_scan_init
+ * [0] acpi_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * 在以下调用acpiphp_enumerate_slots():
+ *   - drivers/pci/pci-acpi.c|1170| <<acpi_pci_add_bus>> acpiphp_enumerate_slots(bus);
+ *
+ * acpiphp_enumerate_slots()针对每一个bus调用一次
+ */
 void acpiphp_enumerate_slots(struct pci_bus *bus)
 {
 	struct acpiphp_bridge *bridge;
diff --git a/virt/kvm/eventfd.c b/virt/kvm/eventfd.c
index 37e3a49f4e76..3d7df8542e01 100644
--- a/virt/kvm/eventfd.c
+++ b/virt/kvm/eventfd.c
@@ -338,6 +338,9 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
 
 		mutex_lock(&kvm->irqfds.resampler_lock);
 
+		/*
+		 * 似乎resampler_list也基本不怎么用
+		 */
 		list_for_each_entry(resampler,
 				    &kvm->irqfds.resampler_list, link) {
 			if (resampler->notifier.gsi == irqfd->gsi) {
@@ -448,6 +451,10 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
 	return ret;
 }
 
+/*
+ * 在以下使用kvm_irq_has_notifier():
+ *   - arch/x86/kvm/ioapic.c|448| <<kvm_ioapic_scan_entry>> kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||
+ */
 bool kvm_irq_has_notifier(struct kvm *kvm, unsigned irqchip, unsigned pin)
 {
 	struct kvm_irq_ack_notifier *kian;
@@ -455,6 +462,9 @@ bool kvm_irq_has_notifier(struct kvm *kvm, unsigned irqchip, unsigned pin)
 
 	idx = srcu_read_lock(&kvm->irq_srcu);
 	gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	/*
+	 * 似乎irq_ack_notifier_list不怎么用
+	 */
 	if (gsi != -1)
 		hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,
 					  link, srcu_read_lock_held(&kvm->irq_srcu))
diff --git a/virt/kvm/irqchip.c b/virt/kvm/irqchip.c
index 79dcd4cd5c60..38b03de2e145 100644
--- a/virt/kvm/irqchip.c
+++ b/virt/kvm/irqchip.c
@@ -75,6 +75,12 @@ int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi)
 int kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,
 		bool line_status)
 {
+	/*
+	 * #define KVM_IRQCHIP_PIC_MASTER   0
+	 * #define KVM_IRQCHIP_PIC_SLAVE    1
+	 * #define KVM_IRQCHIP_IOAPIC       2
+	 * #define KVM_NR_IRQCHIPS          3
+	 */
 	struct kvm_kernel_irq_routing_entry irq_set[KVM_NR_IRQCHIPS];
 	int ret = -1, i, idx;
 
@@ -170,6 +176,41 @@ bool __weak kvm_arch_can_set_irq_routing(struct kvm *kvm)
 	return true;
 }
 
+/*
+ * 265 把irq从CPU=5换到CPU=6上.
+ * 266
+ * 267        CPU 5/KVM-51857   [011] ..... 435912.873065: vfio_pci_set_msi_trigger <-vfio_pci_core_ioctl
+ * 268        CPU 5/KVM-51857   [011] ..... 435912.873068: vfio_msi_set_vector_signal <-vfio_msi_set_block
+ * 269        CPU 5/KVM-51857   [011] ..... 435912.873069: irq_bypass_unregister_producer <-vfio_msi_set_vector_signal
+ * 270        CPU 5/KVM-51857   [011] ..... 435912.873070: kvm_arch_irq_bypass_del_producer <-__disconnect
+ * 271        CPU 5/KVM-51857   [011] ..... 435912.873070: vmx_pi_update_irte <-kvm_arch_irq_bypass_del_producer
+ * 272        CPU 5/KVM-51857   [011] ..... 435912.873102: irq_bypass_register_producer <-vfio_msi_set_vector_signal
+ * 273
+ * 274        CPU 5/KVM-51857   [011] ..... 435912.873255: kvm_set_irq_routing <-kvm_vm_ioctl
+ * 275        CPU 5/KVM-51857   [011] ..... 435912.873263: kvm_irq_routing_update <-kvm_set_irq_routing
+ * 276        CPU 5/KVM-51857   [011] d.... 435912.873263: irqfd_update <-kvm_irq_routing_update
+ * 277        CPU 5/KVM-51857   [011] d.... 435912.873264: kvm_arch_update_irqfd_routing <-kvm_irq_routing_update
+ * 278        CPU 5/KVM-51857   [011] d.... 435912.873264: vmx_pi_update_irte <-kvm_irq_routing_update
+ * 279        CPU 5/KVM-51857   [011] d.... 435912.873266: irqfd_update <-kvm_irq_routing_update
+ * 280        CPU 5/KVM-51857   [011] d.... 435912.873266: irqfd_update <-kvm_irq_routing_update
+ * 281        CPU 5/KVM-51857   [011] d.... 435912.873266: kvm_arch_update_irqfd_routing <-kvm_irq_routing_update
+ * 282        CPU 5/KVM-51857   [011] d.... 435912.873266: vmx_pi_update_irte <-kvm_irq_routing_update
+ * 283
+ * 284        CPU 5/KVM-51857   [011] ..... 435912.873290: vfio_pci_set_msi_trigger <-vfio_pci_core_ioctl
+ * 285        CPU 5/KVM-51857   [011] ..... 435912.873291: vfio_msi_set_vector_signal <-vfio_msi_set_block
+ * 286        CPU 5/KVM-51857   [011] ..... 435912.873291: irq_bypass_unregister_producer <-vfio_msi_set_vector_signal
+ * 287        CPU 5/KVM-51857   [011] ..... 435912.873311: irq_bypass_register_producer <-vfio_msi_set_vector_signal
+ * 288        CPU 5/KVM-51857   [011] ..... 435912.873312: kvm_arch_irq_bypass_add_producer <-__connect
+ * 289        CPU 5/KVM-51857   [011] ..... 435912.873312: vmx_pi_update_irte <-kvm_arch_irq_bypass_add_producer
+ *
+ * Add或者Del vCPU会调用:
+ *
+ * kvm_set_irq_routing
+ * kvm_vm_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 int kvm_set_irq_routing(struct kvm *kvm,
 			const struct kvm_irq_routing_entry *ue,
 			unsigned nr,
-- 
2.39.5 (Apple Git-154)

