From 2ce39823049beb96069e736059b29c42ac22fb72 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 26 Jul 2021 09:42:46 -0700
Subject: [PATCH 1/1] linux v5.13

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/include/asm/kvm_host.h     |  6 ++++
 arch/x86/include/asm/pvclock-abi.h  |  9 ++++++
 arch/x86/kvm/lapic.c                |  4 +++
 arch/x86/kvm/vmx/vmx.c              |  6 ++++
 arch/x86/kvm/x86.c                  |  6 ++++
 drivers/cpuidle/poll_state.c        |  7 +++++
 drivers/iommu/intel/dmar.c          | 30 ++++++++++++++++++++
 drivers/iommu/intel/irq_remapping.c | 43 +++++++++++++++++++++++++++++
 drivers/misc/pvpanic/pvpanic.c      | 26 +++++++++++++++++
 include/linux/intel-iommu.h         |  5 ++++
 10 files changed, 142 insertions(+)

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 9c7ced0e3171..334a05d3e8fc 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -697,6 +697,12 @@ struct kvm_vcpu_arch {
 	struct gfn_to_hva_cache pv_time;
 	bool pv_time_enabled;
 	/* set guest stopped flag in pvclock flags field */
+	/*
+	 * 在以下使用kvm_vcpu_arch->pvclock_set_guest_stopped_request:
+	 *   - arch/x86/kvm/x86.c|2765| <<kvm_setup_pvclock_page>> if (vcpu->pvclock_set_guest_stopped_request) {
+	 *   - arch/x86/kvm/x86.c|2767| <<kvm_setup_pvclock_page>> vcpu->pvclock_set_guest_stopped_request = false;
+	 *   - arch/x86/kvm/x86.c|4767| <<kvm_set_guest_paused>> vcpu->arch.pvclock_set_guest_stopped_request = true;
+	 */
 	bool pvclock_set_guest_stopped_request;
 
 	struct {
diff --git a/arch/x86/include/asm/pvclock-abi.h b/arch/x86/include/asm/pvclock-abi.h
index 1436226efe3e..88a11a704af0 100644
--- a/arch/x86/include/asm/pvclock-abi.h
+++ b/arch/x86/include/asm/pvclock-abi.h
@@ -41,6 +41,15 @@ struct pvclock_wall_clock {
 } __attribute__((__packed__));
 
 #define PVCLOCK_TSC_STABLE_BIT	(1 << 0)
+/*
+ * 在以下使用PVCLOCK_GUEST_STOPPED:
+ *   - arch/x86/kernel/kvmclock.c|152| <<kvm_check_and_clear_guest_paused>> if ((src->pvti.flags & PVCLOCK_GUEST_STOPPED) != 0) {
+ *   - arch/x86/kernel/kvmclock.c|153| <<kvm_check_and_clear_guest_paused>> src->pvti.flags &= ~PVCLOCK_GUEST_STOPPED;
+ *   - arch/x86/kernel/pvclock.c|80| <<pvclock_clocksource_read>> if (unlikely((flags & PVCLOCK_GUEST_STOPPED) != 0)) {
+ *   - arch/x86/kernel/pvclock.c|81| <<pvclock_clocksource_read>> src->flags &= ~PVCLOCK_GUEST_STOPPED;
+ *   - arch/x86/kvm/x86.c|2769| <<kvm_setup_pvclock_page>> vcpu->hv_clock.flags |= (guest_hv_clock.flags & PVCLOCK_GUEST_STOPPED);
+ *   - arch/x86/kvm/x86.c|2772| <<kvm_setup_pvclock_page>> vcpu->hv_clock.flags |= PVCLOCK_GUEST_STOPPED;
+ */
 #define PVCLOCK_GUEST_STOPPED	(1 << 1)
 /* PVCLOCK_COUNTS_FROM_ZERO broke ABI and can't be used anymore. */
 #define PVCLOCK_COUNTS_FROM_ZERO (1 << 2)
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 17fa4ab1b834..9644ce6637b5 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -2181,6 +2181,10 @@ void kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)
 EXPORT_SYMBOL_GPL(kvm_lapic_set_eoi);
 
 /* emulate APIC access in a trap manner */
+/*
+ * called by:
+ *   - arch/x86/kvm/vmx/vmx.c|5287| <<handle_apic_write>> kvm_apic_write_nodecode(vcpu, offset);
+ */
 void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)
 {
 	u32 val = 0;
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index c2a779b688e6..cbbfd38c9362 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -7771,6 +7771,12 @@ static __init void vmx_setup_user_return_msrs(void)
 		kvm_add_user_return_msr(vmx_uret_msrs_list[i]);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|10652| <<kvm_arch_hardware_setup>> r = ops->hardware_setup();
+ *
+ * struct kvm_x86_init_ops.hardware_setup = hardware_setup()
+ */
 static __init int hardware_setup(void)
 {
 	unsigned long host_bndcfgs;
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index e0f4a46649d7..6728e0fc5231 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -2722,6 +2722,12 @@ u64 get_kvmclock_ns(struct kvm *kvm)
 	return ret;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|2868| <<kvm_guest_time_update>> kvm_setup_pvclock_page(v, &vcpu->pv_time, 0);
+ *   - arch/x86/kvm/x86.c|2870| <<kvm_guest_time_update>> kvm_setup_pvclock_page(v, &vcpu->xen.vcpu_info_cache,
+ *   - arch/x86/kvm/x86.c|2873| <<kvm_guest_time_update>> kvm_setup_pvclock_page(v, &vcpu->xen.vcpu_time_info_cache, 0);
+ */
 static void kvm_setup_pvclock_page(struct kvm_vcpu *v,
 				   struct gfn_to_hva_cache *cache,
 				   unsigned int offset)
diff --git a/drivers/cpuidle/poll_state.c b/drivers/cpuidle/poll_state.c
index f7e83613ae94..57637c9de6cb 100644
--- a/drivers/cpuidle/poll_state.c
+++ b/drivers/cpuidle/poll_state.c
@@ -10,6 +10,13 @@
 
 #define POLL_IDLE_RELAX_COUNT	200
 
+/*
+ * called by:
+ *   - drivers/cpuidle/cpuidle.c|237| <<cpuidle_enter_state>> entered_state = target_state->enter(dev, drv, index);
+ *
+ * 在以下使用poll_idle():
+ *   - drivers/cpuidle/poll_state.c|55| <<cpuidle_poll_state_init>> state->enter = poll_idle;
+ */
 static int __cpuidle poll_idle(struct cpuidle_device *dev,
 			       struct cpuidle_driver *drv, int index)
 {
diff --git a/drivers/iommu/intel/dmar.c b/drivers/iommu/intel/dmar.c
index 84057cb9596c..eed94b655907 100644
--- a/drivers/iommu/intel/dmar.c
+++ b/drivers/iommu/intel/dmar.c
@@ -56,6 +56,21 @@ struct dmar_res_callback {
  * 2) Use RCU in interrupt context
  */
 DECLARE_RWSEM(dmar_global_lock);
+/*
+ * 在以下使用dmar_drhd_units:
+ *   - drivers/iommu/intel/cap_audit.c|149| <<cap_audit_static>> if (list_empty(&dmar_drhd_units))
+ *   - drivers/iommu/intel/dmar.c|77| <<dmar_register_drhd_unit>> list_add_tail_rcu(&drhd->list, &dmar_drhd_units);
+ *   - drivers/iommu/intel/dmar.c|79| <<dmar_register_drhd_unit>> list_add_rcu(&drhd->list, &dmar_drhd_units);
+ *   - drivers/iommu/intel/dmar.c|397| <<dmar_find_dmaru>> list_for_each_entry_rcu(dmaru, &dmar_drhd_units, list,
+ *   - drivers/iommu/intel/dmar.c|812| <<dmar_dev_scope_init>> if (list_empty(&dmar_drhd_units)) {
+ *   - drivers/iommu/intel/dmar.c|853| <<dmar_table_init>> } else if (list_empty(&dmar_drhd_units)) {
+ *   - drivers/iommu/intel/dmar.c|2127| <<dmar_free_unused_resources>> if (dmar_dev_scope_status != 1 && !list_empty(&dmar_drhd_units))
+ *   - drivers/iommu/intel/dmar.c|2131| <<dmar_free_unused_resources>> list_for_each_entry_safe(dmaru, dmaru_n, &dmar_drhd_units, list) {
+ *   - include/linux/dmar.h|74| <<for_each_drhd_unit>> list_for_each_entry_rcu(drhd, &dmar_drhd_units, list, \
+ *   - include/linux/dmar.h|78| <<for_each_active_drhd_unit>> list_for_each_entry_rcu(drhd, &dmar_drhd_units, list, \
+ *   - include/linux/dmar.h|83| <<for_each_active_iommu>> list_for_each_entry_rcu(drhd, &dmar_drhd_units, list, \
+ *   - include/linux/dmar.h|88| <<for_each_iommu>> list_for_each_entry_rcu(drhd, &dmar_drhd_units, list, \
+ */
 LIST_HEAD(dmar_drhd_units);
 
 struct acpi_table_header * __initdata dmar_tbl;
@@ -1819,6 +1834,10 @@ static const char *irq_remap_fault_reasons[] =
 	"Blocked an interrupt request due to source-id verification failure",
 };
 
+/*
+ * called by:
+ *   - drivers/iommu/intel/dmar.c|1913| <<dmar_fault_do_one>> reason = dmar_get_fault_reason(fault_reason, &fault_type);
+ */
 static const char *dmar_get_fault_reason(u8 fault_reason, int *fault_type)
 {
 	if (fault_reason >= 0x20 && (fault_reason - 0x20 <
@@ -1903,6 +1922,10 @@ void dmar_msi_read(int irq, struct msi_msg *msg)
 	raw_spin_unlock_irqrestore(&iommu->register_lock, flag);
 }
 
+/*
+ * called by:
+ *   - drivers/iommu/intel/dmar.c|1991| <<dmar_fault>> dmar_fault_do_one(iommu, type, fault_reason,
+ */
 static int dmar_fault_do_one(struct intel_iommu *iommu, int type,
 		u8 fault_reason, u32 pasid, u16 source_id,
 		unsigned long long addr)
@@ -1927,6 +1950,13 @@ static int dmar_fault_do_one(struct intel_iommu *iommu, int type,
 }
 
 #define PRIMARY_FAULT_REG_LEN (16)
+/*
+ * 在以下使用dmar_fault():
+ *   - drivers/iommu/intel/dmar.c|2027| <<dmar_set_interrupt>> ret = request_irq(irq, dmar_fault, IRQF_NO_THREAD, iommu->name, iommu);
+ *   - drivers/iommu/intel/dmar.c|2054| <<enable_drhd_fault_handling>> dmar_fault(iommu->irq, iommu);
+ *   - drivers/iommu/intel/iommu.c|2905| <<intel_iommu_init_qi>> dmar_fault(-1, iommu);
+ *   - drivers/iommu/intel/irq_remapping.c|593| <<intel_setup_irq_remapping>> dmar_fault(-1, iommu);
+ */
 irqreturn_t dmar_fault(int irq, void *dev_id)
 {
 	struct intel_iommu *iommu = dev_id;
diff --git a/drivers/iommu/intel/irq_remapping.c b/drivers/iommu/intel/irq_remapping.c
index f912fe45bea2..8c37bc33d00e 100644
--- a/drivers/iommu/intel/irq_remapping.c
+++ b/drivers/iommu/intel/irq_remapping.c
@@ -470,6 +470,11 @@ static int iommu_load_old_irte(struct intel_iommu *iommu)
 }
 
 
+/*
+ * called by:
+ *   - drivers/iommu/intel/irq_remapping.c|618| <<intel_setup_irq_remapping>> iommu_set_irq_remapping(iommu, eim_mode);
+ *   - drivers/iommu/intel/irq_remapping.c|1072| <<reenable_irq_remapping>> iommu_set_irq_remapping(iommu, eim);
+ */
 static void iommu_set_irq_remapping(struct intel_iommu *iommu, int mode)
 {
 	unsigned long flags;
@@ -1104,6 +1109,10 @@ void intel_irq_remap_add_device(struct dmar_pci_notify_info *info)
 	dev_set_msi_domain(&info->dev->dev, map_dev_to_ir(info->dev));
 }
 
+/*
+ * called by:
+ *   - drivers/iommu/intel/irq_remapping.c|1285| <<intel_irq_remapping_prepare_irte>> prepare_irte(irte, irq_cfg->vector, irq_cfg->dest_apicid);
+ */
 static void prepare_irte(struct irte *irte, int vector, unsigned int dest)
 {
 	memset(irte, 0, sizeof(*irte));
@@ -1187,6 +1196,23 @@ intel_ir_set_affinity(struct irq_data *data, const struct cpumask *mask,
 	return IRQ_SET_MASK_OK_DONE;
 }
 
+/*
+ * [0] intel_ir_compose_msi_msg
+ * [0] irq_chip_compose_msi_msg
+ * [0] msi_domain_activate
+ * [0] __irq_domain_activate_irq
+ * [0] irq_domain_activate_irq
+ * [0] irq_startup
+ * [0] __setup_irq
+ * [0] request_threaded_irq
+ * [0] pci_request_irq
+ * [0] queue_request_irq
+ * [0] nvme_reset_work
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ */
 static void intel_ir_compose_msi_msg(struct irq_data *irq_data,
 				     struct msi_msg *msg)
 {
@@ -1254,6 +1280,23 @@ static void fill_msi_msg(struct msi_msg *msg, u32 index, u32 subhandle)
 	msg->arch_data.dmar_subhandle = subhandle;
 }
 
+/*
+ * [0] intel_irq_remapping_alloc
+ * [0] intel_irq_remapping_alloc
+ * [0] msi_domain_alloc
+ * [0] __irq_domain_alloc_irqs
+ * [0] __msi_domain_alloc_irqs
+ * [0] __pci_enable_msix_range
+ * [0] pci_alloc_irq_vectors_affinity
+ * [0] nvme_reset_work
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/iommu/intel/irq_remapping.c|1381| <<intel_irq_remapping_alloc>> intel_irq_remapping_prepare_irte(ird, irq_cfg, info, index, i);
+ */
 static void intel_irq_remapping_prepare_irte(struct intel_ir_data *data,
 					     struct irq_cfg *irq_cfg,
 					     struct irq_alloc_info *info,
diff --git a/drivers/misc/pvpanic/pvpanic.c b/drivers/misc/pvpanic/pvpanic.c
index 65f70a4da8c0..3e299e3f2945 100644
--- a/drivers/misc/pvpanic/pvpanic.c
+++ b/drivers/misc/pvpanic/pvpanic.c
@@ -25,6 +25,13 @@ MODULE_AUTHOR("Mihai Carabas <mihai.carabas@oracle.com>");
 MODULE_DESCRIPTION("pvpanic device driver ");
 MODULE_LICENSE("GPL");
 
+/*
+ * 在以下使用pvpanic_list:
+ *   - drivers/misc/pvpanic/pvpanic.c|37| <<pvpanic_send_event>> list_for_each_entry(pi_cur, &pvpanic_list, list) {
+ *   - drivers/misc/pvpanic/pvpanic.c|69| <<pvpanic_probe>> list_add(&pi->list, &pvpanic_list);
+ *   - drivers/misc/pvpanic/pvpanic.c|84| <<pvpanic_remove>> list_for_each_entry_safe(pi_cur, pi_next, &pvpanic_list, list) {
+ *   - drivers/misc/pvpanic/pvpanic.c|96| <<pvpanic_init>> INIT_LIST_HEAD(&pvpanic_list);
+ */
 static struct list_head pvpanic_list;
 static spinlock_t pvpanic_lock;
 
@@ -60,6 +67,25 @@ static struct notifier_block pvpanic_panic_nb = {
 	.priority = 1, /* let this called before broken drm_fb_helper */
 };
 
+/*
+ * [0] pvpanic_probe
+ * [0] platform_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/misc/pvpanic/pvpanic-mmio.c|109| <<pvpanic_mmio_probe>> return pvpanic_probe(pi);
+ *   - drivers/misc/pvpanic/pvpanic-pci.c|102| <<pvpanic_pci_probe>> return pvpanic_probe(pi);
+ */
 int pvpanic_probe(struct pvpanic_instance *pi)
 {
 	if (!pi || !pi->base)
diff --git a/include/linux/intel-iommu.h b/include/linux/intel-iommu.h
index 03faf20a6817..0a0c23d021f8 100644
--- a/include/linux/intel-iommu.h
+++ b/include/linux/intel-iommu.h
@@ -82,6 +82,11 @@
 #define DMAR_IQA_REG	0x90	/* Invalidation queue addr register */
 #define DMAR_ICS_REG	0x9c	/* Invalidation complete status register */
 #define DMAR_IQER_REG	0xb0	/* Invalidation queue error record register */
+/*
+ * 在以下使用DMAR_IRTA_REG:
+ *   - drivers/iommu/intel/irq_remapping.c|440| <<iommu_load_old_irte>> irta = dmar_readq(iommu->reg + DMAR_IRTA_REG);
+ *   - drivers/iommu/intel/irq_remapping.c|483| <<iommu_set_irq_remapping>> dmar_writeq(iommu->reg + DMAR_IRTA_REG,
+ */
 #define DMAR_IRTA_REG	0xb8    /* Interrupt remapping table addr register */
 #define DMAR_PQH_REG	0xc0	/* Page request queue head register */
 #define DMAR_PQT_REG	0xc8	/* Page request queue tail register */
-- 
2.17.1

