From 80b43b49f34c3270eef45132d4fa158106853452 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 9 Dec 2024 09:33:38 -0800
Subject: [PATCH 1/1] linux-v6.12

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/kvm/lapic.c                   |  18 +
 arch/x86/kvm/x86.c                     |  26 +
 block/blk-merge.c                      |   9 +
 drivers/pci/setup-res.c                |  19 +
 drivers/scsi/scsi_lib.c                |  49 ++
 drivers/scsi/sd.c                      |   4 +
 drivers/scsi/virtio_scsi.c             | 103 ++++
 drivers/target/target_core_transport.c |  35 ++
 drivers/vhost/net.c                    |  82 +++
 drivers/vhost/scsi.c                   | 707 +++++++++++++++++++++++++
 drivers/vhost/vhost.c                  | 583 ++++++++++++++++++++
 drivers/vhost/vhost.h                  |  51 ++
 drivers/virtio/virtio_ring.c           | 106 ++++
 include/linux/blk-mq.h                 |  18 +
 include/scsi/scsi_cmnd.h               |  11 +
 include/uapi/linux/vhost_types.h       |  14 +
 include/uapi/linux/virtio_ring.h       |  16 +
 17 files changed, 1851 insertions(+)

diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 95c6beb8c..7bc949c12 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -535,6 +535,10 @@ static inline void kvm_apic_set_dfr(struct kvm_lapic *apic, u32 val)
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|2608| <<kvm_lapic_set_base>> kvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);
+ */
 static inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u32 id)
 {
 	u32 ldr = kvm_apic_calc_x2apic_ldr(id);
@@ -2577,6 +2581,12 @@ u64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)
 	return (tpr & 0xf0) >> 4;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|2738| <<kvm_lapic_reset>> kvm_lapic_set_base(vcpu, msr_val);
+ *   - arch/x86/kvm/lapic.c|3079| <<kvm_apic_set_state>> kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
+ *   - arch/x86/kvm/x86.c|697| <<kvm_set_apic_base>> kvm_lapic_set_base(vcpu, msr_info->data);
+ */
 void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)
 {
 	u64 old_value = vcpu->arch.apic_base;
@@ -2723,6 +2733,10 @@ void kvm_inhibit_apic_access_page(struct kvm_vcpu *vcpu)
 	kvm_vcpu_srcu_read_lock(vcpu);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|12413| <<kvm_vcpu_reset>> kvm_lapic_reset(vcpu, init_event);
+ */
 void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
@@ -3055,6 +3069,10 @@ static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|5120| <<kvm_vcpu_ioctl_get_lapic>> return kvm_apic_get_state(vcpu, s);
+ */
 int kvm_apic_get_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 {
 	memcpy(s->regs, vcpu->arch.apic->regs, sizeof(*s));
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 83fe0a781..679de04fb 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -678,6 +678,11 @@ enum lapic_mode kvm_get_apic_mode(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_get_apic_mode);
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|3893| <<kvm_set_msr_common(MSR_IA32_APICBASE)>> return kvm_set_apic_base(vcpu, msr_info);
+ *   - arch/x86/kvm/x86.c|11900| <<__set_sregs_common>> if (kvm_set_apic_base(vcpu, &apic_base_msr))
+ */
 int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 {
 	enum lapic_mode old_mode = kvm_get_apic_mode(vcpu);
@@ -2511,6 +2516,10 @@ static inline bool gtod_is_based_on_tsc(int mode)
 }
 #endif
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|2713| <<__kvm_synchronize_tsc>> kvm_track_tsc_matching(vcpu, !matched);
+ */
 static void kvm_track_tsc_matching(struct kvm_vcpu *vcpu, bool new_generation)
 {
 #ifdef CONFIG_X86_64
@@ -2666,6 +2675,11 @@ static inline bool kvm_check_tsc_unstable(void)
  * offset for the vcpu and tracks the TSC matching generation that the vcpu
  * participates in.
  */
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|2782| <<kvm_synchronize_tsc>> __kvm_synchronize_tsc(vcpu, offset, data, ns, matched);
+ *   - arch/x86/kvm/x86.c|5759| <<kvm_arch_tsc_set_attr>> __kvm_synchronize_tsc(vcpu, offset, tsc, ns, matched);
+ */
 static void __kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 offset, u64 tsc,
 				  u64 ns, bool matched)
 {
@@ -2713,6 +2727,11 @@ static void __kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 offset, u64 tsc,
 	kvm_track_tsc_matching(vcpu, !matched);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|3946| <<kvm_set_msr_common>> kvm_synchronize_tsc(vcpu, &data);
+ *   - arch/x86/kvm/x86.c|12350| <<kvm_arch_vcpu_postcreate>> kvm_synchronize_tsc(vcpu, NULL);
+ */
 static void kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 *user_value)
 {
 	u64 data = user_value ? *user_value : 0;
@@ -12385,6 +12404,13 @@ void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
 	kvfree(vcpu->arch.cpuid_entries);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|3374| <<kvm_apic_accept_events>> kvm_vcpu_reset(vcpu, true);
+ *   - arch/x86/kvm/svm/svm.c|2225| <<shutdown_interception>> kvm_vcpu_reset(vcpu, true);
+ *   - arch/x86/kvm/x86.c|10865| <<vcpu_enter_guest(KVM_REQ_UPDATE_PROTECTED_GUEST_STATE)>> kvm_vcpu_reset(vcpu, true);
+ *   - arch/x86/kvm/x86.c|12321| <<kvm_arch_vcpu_create>> kvm_vcpu_reset(vcpu, false);
+ */
 void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
 {
 	struct kvm_cpuid_entry2 *cpuid_0x1;
diff --git a/block/blk-merge.c b/block/blk-merge.c
index ad763ec31..49276ae1e 100644
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@ -573,6 +573,15 @@ static int __blk_bios_map_sg(struct request_queue *q, struct bio *bio,
  * map a request to scatterlist, return number of sg entries setup. Caller
  * must make sure sg can hold rq->nr_phys_segments entries
  */
+/*
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1140| <<scsi_alloc_sgtables>> count = __blk_rq_map_sg(rq->q, rq, cmd->sdb.table.sgl, &last_sg);
+ *   - include/linux/blk-mq.h|1175| <<blk_rq_map_sg>> return __blk_rq_map_sg(q, rq, sglist, &last_sg);
+ *
+ * 注释:
+ * map a request to scatterlist, return number of sg entries setup. Caller
+ * must make sure sg can hold rq->nr_phys_segments entries
+ */
 int __blk_rq_map_sg(struct request_queue *q, struct request *rq,
 		struct scatterlist *sglist, struct scatterlist **last_sg)
 {
diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index c6d933ddf..53149ec4a 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -198,6 +198,10 @@ resource_size_t __weak pcibios_retrieve_fw_addr(struct pci_dev *dev, int idx)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/pci/setup-res.c|355| <<pci_assign_resource>> ret = pci_revert_fw_address(res, dev, resno, size);
+ */
 static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 		int resno, resource_size_t size)
 {
@@ -324,6 +328,21 @@ static int _pci_assign_resource(struct pci_dev *dev, int resno,
 	return ret;
 }
 
+/*
+ * called by:
+ *   - drivers/bcma/driver_pci_host.c|571| <<bcma_core_pci_fixup_addresses>> err = pci_assign_resource(dev, pos);
+ *   - drivers/bus/mhi/host/pci_generic.c|910| <<mhi_pci_claim>> err = pci_assign_resource(pdev, bar_num);
+ *   - drivers/char/agp/efficeon-agp.c|389| <<agp_efficeon_probe>> if (pci_assign_resource(pdev, 0)) {
+ *   - drivers/char/agp/intel-agp.c|778| <<agp_intel_probe>> if (pci_assign_resource(pdev, 0)) {
+ *   - drivers/mtd/maps/l440gx.c|112| <<init_l440gx>> if (pci_assign_resource(pm_dev, PIIXE_IOBASE_RESOURCE) != 0) {
+ *   - drivers/net/wireless/ath/ath11k/pci.c|514| <<ath11k_pci_claim>> ret = pci_assign_resource(pdev, ATH11K_PCI_BAR_NUM);
+ *   - drivers/net/wireless/ath/ath12k/pci.c|857| <<ath12k_pci_claim>> ret = pci_assign_resource(pdev, ATH12K_PCI_BAR_NUM);
+ *   - drivers/net/wireless/intel/iwlwifi/pcie/trans.c|3542| <<iwl_trans_pcie_alloc>> ret = pci_assign_resource(pdev, 0);
+ *   - drivers/parisc/dino.c|636| <<dino_fixup_bus>> WARN_ON(pci_assign_resource(bus->self, i));
+ *   - drivers/pci/rom.c|143| <<pci_map_rom>> if (res->parent == NULL && pci_assign_resource(pdev, PCI_ROM_RESOURCE))
+ *   - drivers/pci/setup-bus.c|251| <<reassign_resources_sorted>> if (pci_assign_resource(add_res->dev, idx))
+ *   - drivers/pci/setup-bus.c|289| <<assign_requested_resources_sorted>> pci_assign_resource(dev_res->dev, idx)) {
+ */
 int pci_assign_resource(struct pci_dev *dev, int resno)
 {
 	struct resource *res = dev->resource + resno;
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index adee6f60c..3a4e53fe8 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -1106,6 +1106,15 @@ static inline bool scsi_cmd_needs_dma_drain(struct scsi_device *sdev,
  * * BLK_STS_RESOURCE - if the failure is retryable
  * * BLK_STS_IOERR    - if the failure is fatal
  */
+/*
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1273| <<scsi_setup_scsi_cmnd>> blk_status_t ret = scsi_alloc_sgtables(cmd);
+ *   - drivers/scsi/sd.c|940| <<sd_setup_unmap_cmnd>> return scsi_alloc_sgtables(cmd);
+ *   - drivers/scsi/sd.c|1025| <<sd_setup_write_same16_cmnd>> return scsi_alloc_sgtables(cmd);
+ *   - drivers/scsi/sd.c|1052| <<sd_setup_write_same10_cmnd>> return scsi_alloc_sgtables(cmd);
+ *   - drivers/scsi/sd.c|1339| <<sd_setup_read_write_cmnd>> ret = scsi_alloc_sgtables(cmd);
+ *   - drivers/scsi/sr.c|366| <<sr_init_command>> ret = scsi_alloc_sgtables(SCpnt);
+ */
 blk_status_t scsi_alloc_sgtables(struct scsi_cmnd *cmd)
 {
 	struct scsi_device *sdev = cmd->device;
@@ -1137,6 +1146,15 @@ blk_status_t scsi_alloc_sgtables(struct scsi_cmnd *cmd)
 	 * Next, walk the list, and fill in the addresses and sizes of
 	 * each segment.
 	 */
+	/*
+	 * called by:
+	 *   - drivers/scsi/scsi_lib.c|1140| <<scsi_alloc_sgtables>> count = __blk_rq_map_sg(rq->q, rq, cmd->sdb.table.sgl, &last_sg);
+	 *   - include/linux/blk-mq.h|1175| <<blk_rq_map_sg>> return __blk_rq_map_sg(q, rq, sglist, &last_sg);
+	 *
+	 * 注释:
+	 * map a request to scatterlist, return number of sg entries setup. Caller
+	 * must make sure sg can hold rq->nr_phys_segments entries
+	 */
 	count = __blk_rq_map_sg(rq->q, rq, cmd->sdb.table.sgl, &last_sg);
 
 	if (blk_rq_bytes(rq) & rq->q->limits.dma_pad_mask) {
@@ -1238,6 +1256,11 @@ static void scsi_cleanup_rq(struct request *rq)
 	}
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_error.c|2465| <<scsi_ioctl_reset>> scsi_init_command(dev, scmd);
+ *   - drivers/scsi/scsi_lib.c|1635| <<scsi_prepare_cmd>> scsi_init_command(sdev, cmd);
+ */
 /* Called before a request is prepared. See also scsi_mq_prep_fn(). */
 void scsi_init_command(struct scsi_device *dev, struct scsi_cmnd *cmd)
 {
@@ -1624,6 +1647,10 @@ static unsigned int scsi_mq_inline_sgl_size(struct Scsi_Host *shost)
 		sizeof(struct scatterlist);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1825| <<scsi_queue_rq>> ret = scsi_prepare_cmd(req);
+ */
 static blk_status_t scsi_prepare_cmd(struct request *req)
 {
 	struct scsi_cmnd *cmd = blk_mq_rq_to_pdu(req);
@@ -1661,7 +1688,19 @@ static blk_status_t scsi_prepare_cmd(struct request *req)
 	else
 		cmd->sc_data_direction = DMA_NONE;
 
+	/*
+	 * struct scatterlist *sg;
+	 */
 	sg = (void *)cmd + sizeof(struct scsi_cmnd) + shost->hostt->cmd_size;
+	/*
+	 * struct scsi_cmnd *cmd:
+	 * -> struct scsi_data_buffer sdb;
+	 *    -> struct sg_table table;
+	 *       -> struct scatterlist *sgl;        // the list
+	 *       -> unsigned int nents;             // number of mapped entries
+	 *       -> unsigned int orig_nents;        // original size of list
+	 *    -> unsigned length;
+	 */
 	cmd->sdb.table.sgl = sg;
 
 	if (scsi_host_get_prot(shost)) {
@@ -1688,6 +1727,9 @@ static blk_status_t scsi_prepare_cmd(struct request *req)
 	/* Usually overridden by the ULP */
 	cmd->allowed = 0;
 	memset(cmd->cmnd, 0, sizeof(cmd->cmnd));
+	/*
+	 * sd_init_command()
+	 */
 	return scsi_cmd_to_driver(cmd)->init_command(cmd);
 }
 
@@ -1787,6 +1829,10 @@ static int scsi_mq_get_rq_budget_token(struct request *req)
 	return cmd->budget_token;
 }
 
+/*
+ * struct blk_mq_ops scsi_mq_ops_no_commit.queue_rq = scsi_queue_rq,
+ * struct blk_mq_ops scsi_mq_ops.queue_rq = scsi_queue_rq,
+ */
 static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
 			 const struct blk_mq_queue_data *bd)
 {
@@ -1821,6 +1867,9 @@ static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
 	if (!scsi_host_queue_ready(q, shost, sdev, cmd))
 		goto out_dec_target_busy;
 
+	/*
+	 * don't call prep for this one
+	 */
 	if (!(req->rq_flags & RQF_DONTPREP)) {
 		ret = scsi_prepare_cmd(req);
 		if (ret != BLK_STS_OK)
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index ca4bc0ac7..f75de4a43 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -1316,6 +1316,10 @@ static blk_status_t sd_setup_atomic_cmnd(struct scsi_cmnd *cmd,
 	return BLK_STS_OK;
 }
 
+/*
+ * 处理REQ_OP_READ和REQ_OP_WRITE:
+ *   - drivers/scsi/sd.c|1457| <<sd_init_command(REQ_OP_READ|REQ_OP_WRITE)>> return sd_setup_read_write_cmnd(cmd);
+ */
 static blk_status_t sd_setup_read_write_cmnd(struct scsi_cmnd *cmd)
 {
 	struct request *rq = scsi_cmd_to_rq(cmd);
diff --git a/drivers/scsi/virtio_scsi.c b/drivers/scsi/virtio_scsi.c
index 8471f38b7..bb28d487a 100644
--- a/drivers/scsi/virtio_scsi.c
+++ b/drivers/scsi/virtio_scsi.c
@@ -426,6 +426,10 @@ static void virtscsi_event_done(struct virtqueue *vq)
 	virtscsi_vq_done(vscsi, &vscsi->event_vq, virtscsi_complete_event);
 };
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|505| <<virtscsi_add_cmd>> err = __virtscsi_add_cmd(vq->vq, cmd, req_size, resp_size);
+ */
 static int __virtscsi_add_cmd(struct virtqueue *vq,
 			    struct virtio_scsi_cmd *cmd,
 			    size_t req_size, size_t resp_size)
@@ -444,6 +448,18 @@ static int __virtscsi_add_cmd(struct virtqueue *vq,
 			in = &sc->sdb.table;
 	}
 
+	/*
+	 * 关于 cmd->sdb.table.sgl = sg;
+	 *
+	 * struct scsi_cmnd *cmd:
+	 * -> struct scsi_data_buffer sdb;
+	 *    -> struct sg_table table;
+	 *       -> struct scatterlist *sgl;        // the list
+	 *       -> unsigned int nents;             // number of mapped entries
+	 *       -> unsigned int orig_nents;        // original size of list
+	 *    -> unsigned length;
+	 */
+
 	/* Request header.  */
 	sg_init_one(&req, &cmd->req, req_size);
 	sgs[out_num++] = &req;
@@ -468,6 +484,31 @@ static int __virtscsi_add_cmd(struct virtqueue *vq,
 		sgs[out_num + in_num++] = in->sgl;
 	}
 
+	/*
+	 * 在scsi_alloc_sgtables()中把request给map到scsi_cmnd上的
+	 *
+	 * struct scsi_cmnd *cmd:
+	 * -> struct scsi_data_buffer sdb;
+	 *    -> struct sg_table table;
+	 *       -> struct scatterlist *sgl;        // the list
+	 *       -> unsigned int nents;             // number of mapped entries
+	 *       -> unsigned int orig_nents;        // original size of list
+	 *    -> unsigned length;
+	 *
+	 * 假设没有prot
+	 *
+	 * struct scatterlist *sgs[6].
+	 *
+	 * 如果是READ的
+	 * sgs[0] : request header
+	 * sgs[1] : response header
+	 * sgs[2] : sc->sdb.table.sgl (in buffer)
+	 *
+	 * 如果是WRITE的
+	 * sgs[0] : request header
+	 * sgs[1] : sc->sdb.table.sgl (out buffer)
+	 * sgs[2] : response header
+	 */
 	return virtqueue_add_sgs(vq, sgs, out_num, in_num, cmd, GFP_ATOMIC);
 }
 
@@ -492,6 +533,11 @@ static void virtscsi_kick_vq(struct virtio_scsi_vq *vq)
  * @resp_size	: size of the response buffer
  * @kick	: whether to kick the virtqueue immediately
  */
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|602| <<virtscsi_queuecommand>> ret = virtscsi_add_cmd(req_vq, cmd, req_size, sizeof(cmd->resp.cmd), kick);
+ *   - drivers/scsi/virtio_scsi.c|620| <<virtscsi_tmf>> if (virtscsi_add_cmd(&vscsi->ctrl_vq, cmd, sizeof cmd->req.tmf, sizeof cmd->resp.tmf, true) < 0)
+ */
 static int virtscsi_add_cmd(struct virtio_scsi_vq *vq,
 			     struct virtio_scsi_cmd *cmd,
 			     size_t req_size, size_t resp_size,
@@ -513,11 +559,34 @@ static int virtscsi_add_cmd(struct virtio_scsi_vq *vq,
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|538| <<virtio_scsi_init_hdr_pi>> virtio_scsi_init_hdr(vdev, (struct virtio_scsi_cmd_req *)cmd_pi, sc);
+ *   - drivers/scsi/virtio_scsi.c|596| <<virtscsi_queuecommand>> virtio_scsi_init_hdr(vscsi->vdev, &cmd->req.cmd, sc);
+ */
 static void virtio_scsi_init_hdr(struct virtio_device *vdev,
 				 struct virtio_scsi_cmd_req *cmd,
 				 struct scsi_cmnd *sc)
 {
+	/*
+	 * // SCSI command request, followed by data-out
+	 * struct virtio_scsi_cmd_req {
+	 *     __u8 lun[8];            // Logical Unit Number
+	 *     __virtio64 tag;         // Command identifier
+	 *     __u8 task_attr;         // Task attribute
+	 *     __u8 prio;              // SAM command priority field
+	 *     __u8 crn;
+	 *     __u8 cdb[VIRTIO_SCSI_CDB_SIZE];
+	 * } __attribute__((packed));
+	 */
 	cmd->lun[0] = 1;
+	/*
+	 * struct scsi_cmnd *sc:
+	 * -> struct scsi_device *device;
+	 *    -> unsigned int id;
+	 *    -> unsigned int channel;
+	 *    -> u64 lun;
+	 */
 	cmd->lun[1] = sc->device->id;
 	cmd->lun[2] = (sc->device->lun >> 8) | 0x40;
 	cmd->lun[3] = sc->device->lun & 0xff;
@@ -562,6 +631,17 @@ static struct virtio_scsi_vq *virtscsi_pick_vq_mq(struct virtio_scsi *vscsi,
 	return &vscsi->req_vqs[hwq];
 }
 
+/*
+ * 关于 cmd->sdb.table.sgl = sg;
+ *
+ * struct scsi_cmnd *cmd:
+ * -> struct scsi_data_buffer sdb;
+ *    -> struct sg_table table;
+ *       -> struct scatterlist *sgl;        // the list
+ *       -> unsigned int nents;             // number of mapped entries
+ *       -> unsigned int orig_nents;        // original size of list
+ *    -> unsigned length;
+ */
 static int virtscsi_queuecommand(struct Scsi_Host *shost,
 				 struct scsi_cmnd *sc)
 {
@@ -593,7 +673,30 @@ static int virtscsi_queuecommand(struct Scsi_Host *shost,
 	} else
 #endif
 	{
+		/*
+		 * 46 struct virtio_scsi_cmd {
+		 * 47         struct scsi_cmnd *sc;
+		 * 48         struct completion *comp;
+		 * 49         union {
+		 * 50                 struct virtio_scsi_cmd_req       cmd;
+		 * 51                 struct virtio_scsi_cmd_req_pi    cmd_pi;
+		 * 52                 struct virtio_scsi_ctrl_tmf_req  tmf;
+		 * 53                 struct virtio_scsi_ctrl_an_req   an;
+		 * 54         } req;  
+		 * 55         union { 
+		 * 56                 struct virtio_scsi_cmd_resp      cmd;
+		 * 57                 struct virtio_scsi_ctrl_tmf_resp tmf;
+		 * 58                 struct virtio_scsi_ctrl_an_resp  an;
+		 * 59                 struct virtio_scsi_event         evt; 
+		 * 60         } resp; 
+		 * 61 } ____cacheline_aligned_in_smp;
+		 *
+		 * 初始化virtio的header
+		 */
 		virtio_scsi_init_hdr(vscsi->vdev, &cmd->req.cmd, sc);
+		/*
+		 * 初始化virtio的header中的cdb
+		 */
 		memcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);
 		req_size = sizeof(cmd->req.cmd);
 	}
diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c
index 05d29201b..2c6daa9d3 100644
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@ -1685,6 +1685,17 @@ transport_generic_map_mem_to_cmd(struct se_cmd *cmd, struct scatterlist *sgl,
  * return code and handle failures. This will never fail for other drivers,
  * and the return code can be ignored.
  */
+/*
+ * called by:
+ *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1596| <<srpt_handle_cmd>> rc = target_init_cmd(cmd, ch->sess, &send_ioctx->sense_data[0],
+ *   - drivers/scsi/elx/efct/efct_lio.c|1381| <<efct_scsi_recv_cmd>> rc = target_init_cmd(se_cmd, se_sess, &io->tgt_io.sense_buffer[0],
+ *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|479| <<tcm_qla2xxx_handle_cmd>> rc = target_init_cmd(se_cmd, se_sess, &cmd->sense_buffer[0],
+ *   - drivers/target/loopback/tcm_loop.c|147| <<tcm_loop_target_queue_cmd>> target_init_cmd(se_cmd, tl_nexus->se_sess, &tl_cmd->tl_sense_buf[0],
+ *   - drivers/target/target_core_transport.c|1836| <<target_submit_cmd>> rc = target_init_cmd(se_cmd, se_sess, sense, unpacked_lun, data_length,
+ *   - drivers/target/tcm_fc/tfc_cmd.c|546| <<ft_send_work>> if (target_init_cmd(&cmd->se_cmd, cmd->sess->se_sess,
+ *   - drivers/vhost/scsi.c|1009| <<vhost_scsi_target_queue_cmd>> target_init_cmd(se_cmd, tv_nexus->tvn_se_sess, &cmd->tvc_sense_buf[0],
+ *   - drivers/xen/xen-scsiback.c|428| <<scsiback_cmd_exec>> target_init_cmd(se_cmd, sess, pending_req->sense_buffer,
+ */
 int target_init_cmd(struct se_cmd *se_cmd, struct se_session *se_sess,
 		    unsigned char *sense, u64 unpacked_lun,
 		    u32 data_length, int task_attr, int data_dir, int flags)
@@ -1742,6 +1753,17 @@ EXPORT_SYMBOL_GPL(target_init_cmd);
  * If failure is returned, lio will the callers queue_status to complete
  * the cmd.
  */
+/*
+ * called by:
+ *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1605| <<srpt_handle_cmd>> if (target_submit_prep(cmd, srp_cmd->cdb, sg, sg_cnt, NULL, 0, NULL, 0,
+ *   - drivers/scsi/elx/efct/efct_lio.c|1390| <<efct_scsi_recv_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0,
+ *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|485| <<tcm_qla2xxx_handle_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0, NULL, 0,
+ *   - drivers/target/loopback/tcm_loop.c|151| <<tcm_loop_target_queue_cmd>> if (target_submit_prep(se_cmd, sc->cmnd, scsi_sglist(sc),
+ *   - drivers/target/target_core_transport.c|1853| <<target_submit_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0, NULL, 0,
+ *   - drivers/target/tcm_fc/tfc_cmd.c|552| <<ft_send_work>> if (target_submit_prep(&cmd->se_cmd, fcp->fc_cdb, NULL, 0, NULL, 0,
+ *   - drivers/vhost/scsi.c|1032| <<vhost_scsi_target_queue_cmd>> if (target_submit_prep(se_cmd, cmd->tvc_cdb, sg_ptr,
+ *   - drivers/xen/xen-scsiback.c|432| <<scsiback_cmd_exec>> if (target_submit_prep(se_cmd, pending_req->cmnd, pending_req->sgl,
+ */
 int target_submit_prep(struct se_cmd *se_cmd, unsigned char *cdb,
 		       struct scatterlist *sgl, u32 sgl_count,
 		       struct scatterlist *sgl_bidi, u32 sgl_bidi_count,
@@ -1926,6 +1948,19 @@ static void target_queue_submission(struct se_cmd *se_cmd)
  * target_submit_prep or something similar must have been called on the cmd,
  * and this must be called from process context.
  */
+/*
+ * called by:
+ *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1609| <<srpt_handle_cmd>> target_submit(cmd);
+ *   - drivers/scsi/elx/efct/efct_lio.c|1394| <<efct_scsi_recv_cmd>> target_submit(se_cmd);
+ *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|489| <<tcm_qla2xxx_handle_cmd>> target_submit(se_cmd);
+ *   - drivers/target/iscsi/iscsi_target_erl1.c|950| <<iscsit_execute_cmd>> return target_submit(&cmd->se_cmd);
+ *   - drivers/target/iscsi/iscsi_target_tmr.c|321| <<iscsit_task_reassign_complete_read>> target_submit(se_cmd);
+ *   - drivers/target/loopback/tcm_loop.c|157| <<tcm_loop_target_queue_cmd>> target_submit(se_cmd);
+ *   - drivers/target/target_core_transport.c|1857| <<target_submit_cmd>> target_submit(se_cmd);
+ *   - drivers/target/tcm_fc/tfc_cmd.c|556| <<ft_send_work>> target_submit(&cmd->se_cmd);
+ *   - drivers/vhost/scsi.c|1037| <<vhost_scsi_target_queue_cmd>> target_submit(se_cmd);
+ *   - drivers/xen/xen-scsiback.c|436| <<scsiback_cmd_exec>> target_submit(se_cmd);
+ */
 int target_submit(struct se_cmd *se_cmd)
 {
 	const struct target_core_fabric_ops *tfo = se_cmd->se_sess->se_tpg->se_tpg_tfo;
diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index f16279351..b45fc1891 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -963,6 +963,11 @@ static void handle_tx(struct vhost_net *net)
 	mutex_unlock(&vq->mutex);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|994| <<vhost_net_rx_peek_head_len>> int len = peek_head_len(rnvq, sk);
+ *   - drivers/vhost/net.c|1002| <<vhost_net_rx_peek_head_len>> len = peek_head_len(rnvq, sk);
+ */
 static int peek_head_len(struct vhost_net_virtqueue *rvq, struct sock *sk)
 {
 	struct sk_buff *head;
@@ -984,6 +989,10 @@ static int peek_head_len(struct vhost_net_virtqueue *rvq, struct sock *sk)
 	return len;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1150| <<handle_rx>> sock_len = vhost_net_rx_peek_head_len(net, sock->sk,
+ */
 static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk,
 				      bool *busyloop_intr)
 {
@@ -1015,6 +1024,10 @@ static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk,
  * @quota       - headcount quota, 1 for big buffer
  *	returns number of buffer heads allocated, negative on error
  */
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1156| <<handle_rx>> headcount = get_rx_bufs(vq, vq->heads + nvq->done_idx, vhost_len, &in, vq_log, &log, likely(mergeable) ? UIO_MAXIOV : 1);
+ */
 static int get_rx_bufs(struct vhost_virtqueue *vq,
 		       struct vring_used_elem *heads,
 		       int datalen,
@@ -1038,6 +1051,27 @@ static int get_rx_bufs(struct vhost_virtqueue *vq,
 			r = -ENOBUFS;
 			goto err;
 		}
+		/*
+		 * called by:
+		 *   - drivers/vhost/net.c|583| <<vhost_net_tx_get_vq_desc>> int r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+		 *   - drivers/vhost/net.c|595| <<vhost_net_tx_get_vq_desc>> r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+		 *   - drivers/vhost/net.c|1041| <<get_rx_bufs>> r = vhost_get_vq_desc(vq, vq->iov + seg, ARRAY_SIZE(vq->iov) - seg, &out, &in, log, log_num);
+		 *   - drivers/vhost/scsi.c|481| <<vhost_scsi_do_evt_work>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+		 *   - drivers/vhost/scsi.c|966| <<vhost_scsi_get_desc>> vc->head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &vc->out, &vc->in, NULL, NULL);
+		 *   - drivers/vhost/test.c|61| <<handle_vq>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+		 *   - drivers/vhost/vsock.c|127| <<vhost_transport_do_send_pkt>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+		 *   - drivers/vhost/vsock.c|509| <<vhost_vsock_handle_tx_kick>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+		 *
+		 * 注释:
+		 * This looks in the virtqueue and for the first available buffer, and converts
+		 * it to an iovec for convenient access.  Since descriptors consist of some
+		 * number of output then some number of input descriptors, it's actually two
+		 * iovecs, but we pack them into one and note how many of each there were.
+		 *
+		 * This function returns the descriptor number found, or vq->num (which is
+		 * never a valid descriptor number) if none was found.  A negative code is
+		 * returned on error.
+		 */
 		r = vhost_get_vq_desc(vq, vq->iov + seg,
 				      ARRAY_SIZE(vq->iov) - seg, &out,
 				      &in, log, log_num);
@@ -1089,6 +1123,12 @@ static void handle_rx(struct vhost_net *net)
 	struct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];
 	struct vhost_virtqueue *vq = &nvq->vq;
 	unsigned in, log;
+	/*
+	 * struct vhost_log {
+	 *     u64 addr;
+	 *     u64 len;
+	 * };
+	 */
 	struct vhost_log *vq_log;
 	struct msghdr msg = {
 		.msg_name = NULL,
@@ -1113,10 +1153,20 @@ static void handle_rx(struct vhost_net *net)
 	int recv_pkts = 0;
 
 	mutex_lock_nested(&vq->mutex, VHOST_NET_VQ_RX);
+	/*
+	 * struct socket *sock;
+	 */
 	sock = vhost_vq_get_backend(vq);
 	if (!sock)
 		goto out;
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/net.c|951| <<handle_tx>> if (!vq_meta_prefetch(vq))
+	 *   - drivers/vhost/net.c|1120| <<handle_rx>> if (!vq_meta_prefetch(vq))
+	 *   - drivers/vhost/vsock.c|103| <<vhost_transport_do_send_pkt>> if (!vq_meta_prefetch(vq))
+	 *   - drivers/vhost/vsock.c|494| <<vhost_vsock_handle_tx_kick>> if (!vq_meta_prefetch(vq))
+	 */
 	if (!vq_meta_prefetch(vq))
 		goto out;
 
@@ -1126,6 +1176,25 @@ static void handle_rx(struct vhost_net *net)
 	vhost_hlen = nvq->vhost_hlen;
 	sock_hlen = nvq->sock_hlen;
 
+	/*
+	 * 在以下使用vhost_virtqueue->log:
+	 *   - drivers/vhost/vhost.c|652| <<vhost_dev_init>> vq->log = NULL;
+	 *   - drivers/vhost/net.c|1180| <<handle_rx>> vq_log = unlikely(vhost_has_feature(vq, VHOST_F_LOG_ALL)) ? vq->log : NULL;
+	 *   - drivers/vhost/vhost.c|543| <<vhost_vq_free_iovecs>> kfree(vq->log);
+	 *   - drivers/vhost/vhost.c|544| <<vhost_vq_free_iovecs>> vq->log = NULL;
+	 *   - drivers/vhost/vhost.c|560| <<vhost_dev_alloc_iovecs>> vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log), GFP_KERNEL);
+	 *   - drivers/vhost/vhost.c|564| <<vhost_dev_alloc_iovecs>> if (!vq->indirect || !vq->log || !vq->heads)
+	 *
+	 *
+	 * 注释: Log all write descriptors. Can be changed while device is active.
+	 *
+	 * struct vhost_log {
+	 *     u64 addr;
+	 *     u64 len;
+	 * };
+	 *
+	 * struct vhost_log *vq_log;
+	 */
 	vq_log = unlikely(vhost_has_feature(vq, VHOST_F_LOG_ALL)) ?
 		vq->log : NULL;
 	mergeable = vhost_has_feature(vq, VIRTIO_NET_F_MRG_RXBUF);
@@ -1137,6 +1206,13 @@ static void handle_rx(struct vhost_net *net)
 			break;
 		sock_len += sock_hlen;
 		vhost_len = sock_len + vhost_hlen;
+		/*
+		 * struct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];
+		 * struct vhost_virtqueue *vq = &nvq->vq;
+		 *
+		 * @log         - vhost log
+		 * @log_num     - log offset
+		 */
 		headcount = get_rx_bufs(vq, vq->heads + nvq->done_idx,
 					vhost_len, &in, vq_log, &log,
 					likely(mergeable) ? UIO_MAXIOV : 1);
@@ -1215,6 +1291,12 @@ static void handle_rx(struct vhost_net *net)
 		nvq->done_idx += headcount;
 		if (nvq->done_idx > VHOST_NET_BATCH)
 			vhost_net_signal_used(nvq);
+		/*
+		 * struct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];
+		 * struct vhost_virtqueue *vq = &nvq->vq;
+		 *
+		 * 只在此处调用vhost_log_write()
+		 */
 		if (unlikely(vq_log))
 			vhost_log_write(vq, vq_log, log, vhost_len,
 					vq->iov, in);
diff --git a/drivers/vhost/scsi.c b/drivers/vhost/scsi.c
index 718fa4e0b..b201bba0f 100644
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@ -41,7 +41,22 @@
 
 #define VHOST_SCSI_VERSION  "v0.1"
 #define VHOST_SCSI_NAMELEN 256
+/*
+ * 在以下使用VHOST_SCSI_MAX_CDB_SIZE:
+ *   - drivers/vhost/scsi.c|44| <<global>> #define VHOST_SCSI_MAX_CDB_SIZE 32
+ *   - drivers/vhost/scsi.c|158| <<"struct vhost_scsi_cmd">> unsigned char tvc_cdb[VHOST_SCSI_MAX_CDB_SIZE];
+ *   - drivers/vhost/scsi.c|910| <<vhost_scsi_get_cmd>> memcpy(cmd->tvc_cdb, cdb, VHOST_SCSI_MAX_CDB_SIZE);
+ *   - drivers/vhost/scsi.c|1717| <<vhost_scsi_handle_vq>> if (unlikely(scsi_command_size(cdb) > VHOST_SCSI_MAX_CDB_SIZE)) {
+ *   - drivers/vhost/scsi.c|1720| <<vhost_scsi_handle_vq>> vq_err(vq, ... scsi_command_size(cdb), VHOST_SCSI_MAX_CDB_SIZE);
+ */
 #define VHOST_SCSI_MAX_CDB_SIZE 32
+/*
+ * 在以下使用VHOST_SCSI_PREALLOC_SGLS:
+ *   - drivers/vhost/scsi.c|45| <<global>> #define VHOST_SCSI_PREALLOC_SGLS 2048
+ *   - drivers/vhost/scsi.c|3217| <<global>> struct target_core_fabric_ops vhost_scsi_ops.max_data_sg_nents = VHOST_SCSI_PREALLOC_SGLS,
+ *   - drivers/vhost/scsi.c|1134| <<vhost_scsi_mapal>> sgl_count = vhost_scsi_calc_sgls(data_iter, data_bytes, VHOST_SCSI_PREALLOC_SGLS);
+ *   - drivers/vhost/scsi.c|2229| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_sgl = kcalloc(VHOST_SCSI_PREALLOC_SGLS, sizeof(struct scatterlist), GFP_KERNEL);
+ */
 #define VHOST_SCSI_PREALLOC_SGLS 2048
 #define VHOST_SCSI_PREALLOC_UPAGES 2048
 #define VHOST_SCSI_PREALLOC_PROT_SGLS 2048
@@ -50,8 +65,24 @@
  * Using this limit prevents one virtqueue from starving others with
  * request.
  */
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|2606| <<vhost_scsi_open>> vhost_dev_init(&vs->dev, vqs, nvqs, UIO_MAXIOV, VHOST_SCSI_WEIGHT, 0, true, NULL);
+ */
 #define VHOST_SCSI_WEIGHT 256
 
+/*
+ * 在以下使用vhost_scsi_inflight->comp:
+ *   - drivers/vhost/scsi.c|354| <<vhost_scsi_done_inflight>> complete(&inflight->comp);
+ *   - drivers/vhost/scsi.c|378| <<vhost_scsi_init_inflight>> init_completion(&new_inflight->comp);
+ *   - drivers/vhost/scsi.c|2181| <<vhost_scsi_flush>> wait_for_completion(&vs->old_inflight[i]->comp);
+ *
+ * 在以下使用vhost_scsi_inflight->kref:
+ *   - drivers/vhost/scsi.c|377| <<vhost_scsi_init_inflight>> kref_init(&new_inflight->kref);
+ *   - drivers/vhost/scsi.c|392| <<vhost_scsi_get_inflight>> kref_get(&inflight->kref); 
+ *   - drivers/vhost/scsi.c|399| <<vhost_scsi_put_inflight>> kref_put(&inflight->kref, vhost_scsi_done_inflight);
+ *   - drivers/vhost/scsi.c|2174| <<vhost_scsi_flush>> kref_put(&vs->old_inflight[i]->kref, vhost_scsi_done_inflight);
+ */
 struct vhost_scsi_inflight {
 	/* Wait for the flush operation to finish */
 	struct completion comp;
@@ -60,10 +91,25 @@ struct vhost_scsi_inflight {
 };
 
 struct vhost_scsi_cmd {
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_vq_desc:
+	 *   - drivers/vhost/scsi.c|670| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+	 *   - drivers/vhost/scsi.c|1471| <<vhost_scsi_handle_vq>> cmd->tvc_vq_desc = vc.head;
+	 *
+	 * 注释: Descriptor from vhost_get_vq_desc() for virt_queue segment
+	 */
 	/* Descriptor from vhost_get_vq_desc() for virt_queue segment */
 	int tvc_vq_desc;
 	/* virtio-scsi initiator task attribute */
 	int tvc_task_attr;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_in_iovs:
+	 *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST,
+	 *                  cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+	 *   - drivers/vhost/scsi.c|1600| <<vhost_scsi_handle_vq>> cmd->tvc_in_iovs = vc.in;
+	 *
+	 * 注释: virtio-scsi response incoming iovecs
+	 */
 	/* virtio-scsi response incoming iovecs */
 	int tvc_in_iovs;
 	/* virtio-scsi initiator data direction */
@@ -72,24 +118,89 @@ struct vhost_scsi_cmd {
 	u32 tvc_exp_data_len;
 	/* The Tag from include/linux/virtio_scsi.h:struct virtio_scsi_cmd_req */
 	u64 tvc_tag;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_sgl_count:
+	 *   - drivers/vhost/scsi.c|470| <<vhost_scsi_release_cmd_res>> if (tv_cmd->tvc_sgl_count) {
+	 *   - drivers/vhost/scsi.c|471| <<vhost_scsi_release_cmd_res>> for (i = 0; i < tv_cmd->tvc_sgl_count; i++) {
+	 *   - drivers/vhost/scsi.c|740| <<vhost_scsi_copy_sgl_to_iov>> for (i = 0; i < cmd->tvc_sgl_count; i++) {
+	 *   - drivers/vhost/scsi.c|976| <<vhost_scsi_map_to_sgl>> if (... cmd->tvc_sgl_count > BIO_MAX_VECS) {
+	 *   - drivers/vhost/scsi.c|1154| <<vhost_scsi_mapal>> cmd->tvc_sgl_count = sgl_count;
+	 *   - drivers/vhost/scsi.c|1156| <<vhost_scsi_mapal>> cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1159| <<vhost_scsi_mapal>> cmd->tvc_sgl_count, false);
+	 *   - drivers/vhost/scsi.c|1161| <<vhost_scsi_mapal>> sg_init_table(cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1166| <<vhost_scsi_mapal>> ret = vhost_scsi_copy_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1170| <<vhost_scsi_mapal>> cmd->tvc_sgl_count = 0;
+	 *   - drivers/vhost/scsi.c|1204| <<vhost_scsi_target_queue_cmd>> if (cmd->tvc_sgl_count) {
+	 *   - drivers/vhost/scsi.c|1245| <<vhost_scsi_target_queue_cmd>> target_init_cmd(se_cmd, tv_nexus->tvn_se_sess, &cmd->tvc_sense_buf[0], cmd->tvc_sgl_count, NULL, 0, sg_prot_ptr,
+	 */
 	/* The number of scatterlists associated with this cmd */
 	u32 tvc_sgl_count;
 	u32 tvc_prot_sgl_count;
 	/* Saved unpacked SCSI LUN for vhost_scsi_target_queue_cmd() */
 	u32 tvc_lun;
+	/*
+	 * 在以下使用vhost_scsi_cmd->copied_iov:
+	 *   - drivers/vhost/scsi.c|374| <<vhost_scsi_release_cmd_res>> if (tv_cmd->copied_iov)
+	 *   - drivers/vhost/scsi.c|881| <<vhost_scsi_copy_iov_to_sgl>> cmd->copied_iov = 1;
+	 */
 	u32 copied_iov:1;
 	const void *saved_iter_addr;
 	struct iov_iter saved_iter;
 	/* Pointer to the SGL formatted memory from virtio-scsi */
+	/*
+	 * 在以下使用vhost_virtqueue->tvc_sgl:
+	 *   - drivers/vhost/scsi.c|411| <<vhost_scsi_release_cmd_res>> __free_page(sg_page(&tv_cmd->tvc_sgl[i]));
+	 *   - drivers/vhost/scsi.c|413| <<vhost_scsi_release_cmd_res>> put_page(sg_page(&tv_cmd->tvc_sgl[i]));
+	 *   - drivers/vhost/scsi.c|646| <<vhost_scsi_copy_sgl_to_iov>> struct scatterlist *sg = cmd->tvc_sgl;
+	 *   - drivers/vhost/scsi.c|808| <<vhost_scsi_get_cmd>> sg = cmd->tvc_sgl;
+	 *   - drivers/vhost/scsi.c|813| <<vhost_scsi_get_cmd>> cmd->tvc_sgl = sg;
+	 *   - drivers/vhost/scsi.c|1054| <<vhost_scsi_mapal>> sg_init_table(cmd->tvc_sgl, sgl_count);
+	 *   - drivers/vhost/scsi.c|1057| <<vhost_scsi_mapal>> cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1059| <<vhost_scsi_mapal>> ret = vhost_scsi_map_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl, cmd->tvc_sgl_count, false);
+	 *   - drivers/vhost/scsi.c|1062| <<vhost_scsi_mapal>> sg_init_table(cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1066| <<vhost_scsi_mapal>> ret = vhost_scsi_copy_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1106| <<vhost_scsi_target_queue_cmd>> sg_ptr = cmd->tvc_sgl;
+	 *   - drivers/vhost/scsi.c|2087| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_sgl);
+	 *   - drivers/vhost/scsi.c|2134| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_sgl = kcalloc(VHOST_SCSI_PREALLOC_SGLS, sizeof(struct scatterlist), GFP_KERNEL);
+	 *   - drivers/vhost/scsi.c|2137| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_sgl) {
+	 */
 	struct scatterlist *tvc_sgl;
 	struct scatterlist *tvc_prot_sgl;
 	struct page **tvc_upages;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_resp_iov:
+	 *   - drivers/vhost/scsi.c|687| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST, cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+	 *   - drivers/vhost/scsi.c|751| <<vhost_scsi_get_cmd>> tvc_resp_iov = cmd->tvc_resp_iov;
+	 *   - drivers/vhost/scsi.c|764| <<vhost_scsi_get_cmd>> cmd->tvc_resp_iov = tvc_resp_iov;
+	 *   - drivers/vhost/scsi.c|1599| <<vhost_scsi_handle_vq>> cmd->tvc_resp_iov[i] = vq->iov[vc.out + i];
+	 *   - drivers/vhost/scsi.c|2015| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_resp_iov);
+	 *   - drivers/vhost/scsi.c|2075| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_resp_iov = kcalloc(UIO_MAXIOV, sizeof(struct iovec), GFP_KERNEL);
+	 *   - drivers/vhost/scsi.c|2078| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_resp_iov) {
+	 *
+	 * 注释: Pointer to response header iovec 
+	 */
 	/* Pointer to response header iovec */
 	struct iovec *tvc_resp_iov;
 	/* Pointer to vhost_scsi for our device */
 	struct vhost_scsi *tvc_vhost;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_vq:
+	 *   - drivers/vhost/scsi.c|415| <<vhost_scsi_release_cmd_res>> struct vhost_scsi_virtqueue *svq = container_of(tv_cmd->tvc_vq,
+	 *                                    struct vhost_scsi_virtqueue, vq);
+	 *   - drivers/vhost/scsi.c|478| <<vhost_scsi_release_cmd>> struct vhost_scsi_virtqueue *svq = container_of(cmd->tvc_vq,
+	 *                                    struct vhost_scsi_virtqueue, vq);
+	 *   - drivers/vhost/scsi.c|734| <<vhost_scsi_complete_cmd_work>> v_rsp.resid = cpu_to_vhost32(cmd->tvc_vq, se_cmd->residual_count);
+	 *   - drivers/vhost/scsi.c|738| <<vhost_scsi_complete_cmd_work>> v_rsp.sense_len = cpu_to_vhost32(cmd->tvc_vq, se_cmd->scsi_sense_length);
+	 *   - drivers/vhost/scsi.c|778| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+	 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_handle_vq>> cmd->tvc_vq = vq;
+	 */
 	/* Pointer to vhost_virtqueue for the cmd */
 	struct vhost_virtqueue *tvc_vq;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_nexus:
+	 *   - drivers/vhost/scsi.c|952| <<vhost_scsi_get_cmd>> cmd->tvc_nexus = tv_nexus;
+	 *   - drivers/vhost/scsi.c|1245| <<vhost_scsi_target_queue_cmd>> tv_nexus = cmd->tvc_nexus;
+	 */
 	/* Pointer to vhost nexus memory */
 	struct vhost_scsi_nexus *tvc_nexus;
 	/* The TCM I/O descriptor that is accessed via container_of() */
@@ -184,7 +295,27 @@ struct vhost_scsi_virtqueue {
 	 * Writers must also take dev mutex and flush under it.
 	 */
 	int inflight_idx;
+	/*
+	 * 在以下使用vhost_scsi_virtqueue->scsi_cmds:
+	 *   - drivers/vhost/scsi.c|667| <<vhost_scsi_get_cmd>> cmd = &svq->scsi_cmds[tag];
+	 *   - drivers/vhost/scsi.c|1660| <<vhost_scsi_destroy_vq_cmds>> if (!svq->scsi_cmds)
+	 *   - drivers/vhost/scsi.c|1664| <<vhost_scsi_destroy_vq_cmds>> tv_cmd = &svq->scsi_cmds[i];
+	 *   - drivers/vhost/scsi.c|1673| <<vhost_scsi_destroy_vq_cmds>> kfree(svq->scsi_cmds);
+	 *   - drivers/vhost/scsi.c|1674| <<vhost_scsi_destroy_vq_cmds>> svq->scsi_cmds = NULL;
+	 *   - drivers/vhost/scsi.c|1684| <<vhost_scsi_setup_vq_cmds>> if (svq->scsi_cmds)
+	 *   - drivers/vhost/scsi.c|1692| <<vhost_scsi_setup_vq_cmds>> svq->scsi_cmds = kcalloc(max_cmds, sizeof(*tv_cmd), GFP_KERNEL);
+	 *   - drivers/vhost/scsi.c|1693| <<vhost_scsi_setup_vq_cmds>> if (!svq->scsi_cmds) {
+	 *   - drivers/vhost/scsi.c|1699| <<vhost_scsi_setup_vq_cmds>> tv_cmd = &svq->scsi_cmds[i];
+	 */
 	struct vhost_scsi_cmd *scsi_cmds;
+	/*
+	 * 在以下使用vhost_scsi_virtqueue->scsi_tags:
+	 *   - drivers/vhost/scsi.c|520| <<vhost_scsi_release_cmd_res>> sbitmap_clear_bit(&svq->scsi_tags, se_cmd->map_tag);
+	 *   - drivers/vhost/scsi.c|931| <<vhost_scsi_get_cmd>> tag = sbitmap_get(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2234| <<vhost_scsi_destroy_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2253| <<vhost_scsi_setup_vq_cmds>> if (sbitmap_init_node(&svq->scsi_tags, max_cmds, -1, GFP_KERNEL,
+	 *   - drivers/vhost/scsi.c|2268| <<vhost_scsi_setup_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 */
 	struct sbitmap scsi_tags;
 	int max_cmds;
 
@@ -201,7 +332,17 @@ struct vhost_scsi {
 	struct vhost_scsi_virtqueue *vqs;
 	struct vhost_scsi_inflight **old_inflight;
 
+	/*
+	 * 在以下使用vhost_scsi->vs_event_work:
+	 *   - drivers/vhost/scsi.c|1553| <<vhost_scsi_send_evt>> if (!vhost_vq_work_queue(vq, &vs->vs_event_work))
+	 *   - drivers/vhost/scsi.c|1997| <<vhost_scsi_open>> vhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);
+	 */
 	struct vhost_work vs_event_work; /* evt injection work item */
+	/*
+	 * 在以下使用vhost_scsi->vs_event_list:
+	 *   - drivers/vhost/scsi.c|527| <<vhost_scsi_complete_events>> llnode = llist_del_all(&vs->vs_event_list);
+	 *   - drivers/vhost/scsi.c|1552| <<vhost_scsi_send_evt>> llist_add(&evt->list, &vs->vs_event_list);
+	 */
 	struct llist_head vs_event_list; /* evt injection queue */
 
 	bool vs_events_missed; /* any missed events, protected by vq->mutex */
@@ -232,6 +373,13 @@ struct vhost_scsi_ctx {
 	size_t out_size, in_size;
 	u8 *target, *lunp;
 	void *req;
+	/*
+	 * 在以下使用vhost_scsi_ctx->out_iter:
+	 *   - drivers/vhost/scsi.c|1071| <<vhost_scsi_get_desc>> iov_iter_init(&vc->out_iter, ITER_SOURCE, vq->iov, vc->out, vc->out_size);
+	 *   - drivers/vhost/scsi.c|1103| <<vhost_scsi_get_req>> if (unlikely(!copy_from_iter_full(vc->req, vc->req_size, &vc->out_iter))) {
+	 *   - drivers/vhost/scsi.c|1284| <<vhost_scsi_handle_vq>> data_iter = vc.out_iter;
+	 *   - drivers/vhost/scsi.c|1574| <<vhost_scsi_ctl_handle_vq>> if (unlikely(!copy_from_iter_full(vc.req, typ_size, &vc.out_iter))) {
+	 */
 	struct iov_iter out_iter;
 };
 
@@ -240,8 +388,19 @@ struct vhost_scsi_ctx {
  * configfs management operations.
  */
 static DEFINE_MUTEX(vhost_scsi_mutex);
+/*
+ * 在以下使用vhost_scsi_list:
+ *   - drivers/vhost/scsi.c|378| <<global>> static LIST_HEAD(vhost_scsi_list);
+ *   - drivers/vhost/scsi.c|2353| <<vhost_scsi_set_endpoint>> list_for_each_entry(tpg, &vhost_scsi_list, tv_tpg_list) {
+ *   - drivers/vhost/scsi.c|3135| <<vhost_scsi_make_tpg>> list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
+ */
 static LIST_HEAD(vhost_scsi_list);
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|430| <<vhost_scsi_put_inflight>> kref_put(&inflight->kref, vhost_scsi_done_inflight);
+ *   - drivers/vhost/scsi.c|2205| <<vhost_scsi_flush>> kref_put(&vs->old_inflight[i]->kref, vhost_scsi_done_inflight);
+ */
 static void vhost_scsi_done_inflight(struct kref *kref)
 {
 	struct vhost_scsi_inflight *inflight;
@@ -250,6 +409,11 @@ static void vhost_scsi_done_inflight(struct kref *kref)
 	complete(&inflight->comp);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|2197| <<vhost_scsi_flush>> vhost_scsi_init_inflight(vs, vs->old_inflight);
+ *   - drivers/vhost/scsi.c|2639| <<vhost_scsi_open>> vhost_scsi_init_inflight(vs, NULL);
+ */
 static void vhost_scsi_init_inflight(struct vhost_scsi *vs,
 				    struct vhost_scsi_inflight *old_inflight[])
 {
@@ -277,6 +441,11 @@ static void vhost_scsi_init_inflight(struct vhost_scsi *vs,
 	}
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|953| <<vhost_scsi_get_cmd>> cmd->inflight = vhost_scsi_get_inflight(vq);
+ *   - drivers/vhost/scsi.c|1955| <<vhost_scsi_handle_tmf>> tmf->inflight = vhost_scsi_get_inflight(vq);
+ */
 static struct vhost_scsi_inflight *
 vhost_scsi_get_inflight(struct vhost_virtqueue *vq)
 {
@@ -290,16 +459,28 @@ vhost_scsi_get_inflight(struct vhost_virtqueue *vq)
 	return inflight;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|521| <<vhost_scsi_release_cmd_res>> vhost_scsi_put_inflight(inflight);
+ *   - drivers/vhost/scsi.c|529| <<vhost_scsi_release_tmf_res>> vhost_scsi_put_inflight(inflight);
+ */
 static void vhost_scsi_put_inflight(struct vhost_scsi_inflight *inflight)
 {
 	kref_put(&inflight->kref, vhost_scsi_done_inflight);
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_check_true(struct se_portal_group *se_tpg)
 {
 	return 1;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static char *vhost_scsi_get_fabric_wwn(struct se_portal_group *se_tpg)
 {
 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
@@ -309,6 +490,9 @@ static char *vhost_scsi_get_fabric_wwn(struct se_portal_group *se_tpg)
 	return &tport->tport_name[0];
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static u16 vhost_scsi_get_tpgt(struct se_portal_group *se_tpg)
 {
 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
@@ -316,6 +500,9 @@ static u16 vhost_scsi_get_tpgt(struct se_portal_group *se_tpg)
 	return tpg->tport_tpgt;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_check_prot_fabric_only(struct se_portal_group *se_tpg)
 {
 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
@@ -324,10 +511,27 @@ static int vhost_scsi_check_prot_fabric_only(struct se_portal_group *se_tpg)
 	return tpg->tv_fabric_prot_type;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|405| <<vhost_scsi_drop_cmds>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+ *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> vhost_scsi_release_cmd_res(se_cmd);
+ *   - drivers/vhost/scsi.c|1549| <<vhost_scsi_handle_vq>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+ */
 static void vhost_scsi_release_cmd_res(struct se_cmd *se_cmd)
 {
 	struct vhost_scsi_cmd *tv_cmd = container_of(se_cmd,
 				struct vhost_scsi_cmd, tvc_se_cmd);
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_vq:
+	 *   - drivers/vhost/scsi.c|415| <<vhost_scsi_release_cmd_res>> struct vhost_scsi_virtqueue *svq = container_of(tv_cmd->tvc_vq,
+	 *                                    struct vhost_scsi_virtqueue, vq);
+	 *   - drivers/vhost/scsi.c|478| <<vhost_scsi_release_cmd>> struct vhost_scsi_virtqueue *svq = container_of(cmd->tvc_vq,
+	 *                                    struct vhost_scsi_virtqueue, vq);
+	 *   - drivers/vhost/scsi.c|734| <<vhost_scsi_complete_cmd_work>> v_rsp.resid = cpu_to_vhost32(cmd->tvc_vq, se_cmd->residual_count);
+	 *   - drivers/vhost/scsi.c|738| <<vhost_scsi_complete_cmd_work>> v_rsp.sense_len = cpu_to_vhost32(cmd->tvc_vq, se_cmd->scsi_sense_length);
+	 *   - drivers/vhost/scsi.c|778| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+	 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_handle_vq>> cmd->tvc_vq = vq;
+	 */
 	struct vhost_scsi_virtqueue *svq = container_of(tv_cmd->tvc_vq,
 				struct vhost_scsi_virtqueue, vq);
 	struct vhost_scsi_inflight *inflight = tv_cmd->inflight;
@@ -335,6 +539,11 @@ static void vhost_scsi_release_cmd_res(struct se_cmd *se_cmd)
 
 	if (tv_cmd->tvc_sgl_count) {
 		for (i = 0; i < tv_cmd->tvc_sgl_count; i++) {
+			/*
+			 * 在以下使用vhost_scsi_cmd->copied_iov:
+			 *   - drivers/vhost/scsi.c|374| <<vhost_scsi_release_cmd_res>> if (tv_cmd->copied_iov)
+			 *   - drivers/vhost/scsi.c|881| <<vhost_scsi_copy_iov_to_sgl>> cmd->copied_iov = 1;
+			 */
 			if (tv_cmd->copied_iov)
 				__free_page(sg_page(&tv_cmd->tvc_sgl[i]));
 			else
@@ -359,6 +568,10 @@ static void vhost_scsi_release_tmf_res(struct vhost_scsi_tmf *tmf)
 	vhost_scsi_put_inflight(inflight);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|462| <<vhost_scsi_release_cmd>> vhost_scsi_drop_cmds(svq);
+ */
 static void vhost_scsi_drop_cmds(struct vhost_scsi_virtqueue *svq)
 {
 	struct vhost_scsi_cmd *cmd, *t;
@@ -369,6 +582,9 @@ static void vhost_scsi_drop_cmds(struct vhost_scsi_virtqueue *svq)
 		vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops.release_cmd = vhost_scsi_release_cmd()
+ */
 static void vhost_scsi_release_cmd(struct se_cmd *se_cmd)
 {
 	if (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) {
@@ -388,6 +604,9 @@ static void vhost_scsi_release_cmd(struct se_cmd *se_cmd)
 	}
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_write_pending(struct se_cmd *se_cmd)
 {
 	/* Go ahead and process the write immediately */
@@ -395,18 +614,27 @@ static int vhost_scsi_write_pending(struct se_cmd *se_cmd)
 	return 0;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_queue_data_in(struct se_cmd *se_cmd)
 {
 	transport_generic_free_cmd(se_cmd, 0);
 	return 0;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_queue_status(struct se_cmd *se_cmd)
 {
 	transport_generic_free_cmd(se_cmd, 0);
 	return 0;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static void vhost_scsi_queue_tm_rsp(struct se_cmd *se_cmd)
 {
 	struct vhost_scsi_tmf *tmf = container_of(se_cmd, struct vhost_scsi_tmf,
@@ -416,6 +644,9 @@ static void vhost_scsi_queue_tm_rsp(struct se_cmd *se_cmd)
 	transport_generic_free_cmd(&tmf->se_cmd, 0);
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static void vhost_scsi_aborted_task(struct se_cmd *se_cmd)
 {
 	return;
@@ -453,11 +684,18 @@ vhost_scsi_allocate_evt(struct vhost_scsi *vs,
 	return evt;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_check_stop_free(struct se_cmd *se_cmd)
 {
 	return target_put_sess_cmd(se_cmd);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|521| <<vhost_scsi_complete_events>> vhost_scsi_do_evt_work(vs, evt);
+ */
 static void
 vhost_scsi_do_evt_work(struct vhost_scsi *vs, struct vhost_scsi_evt *evt)
 {
@@ -474,6 +712,27 @@ vhost_scsi_do_evt_work(struct vhost_scsi *vs, struct vhost_scsi_evt *evt)
 
 again:
 	vhost_disable_notify(&vs->dev, vq);
+	/*
+	 * called by:
+	 *   - drivers/vhost/net.c|583| <<vhost_net_tx_get_vq_desc>> int r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+	 *   - drivers/vhost/net.c|595| <<vhost_net_tx_get_vq_desc>> r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+	 *   - drivers/vhost/net.c|1041| <<get_rx_bufs>> r = vhost_get_vq_desc(vq, vq->iov + seg, ARRAY_SIZE(vq->iov) - seg, &out, &in, log, log_num);
+	 *   - drivers/vhost/scsi.c|481| <<vhost_scsi_do_evt_work>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/scsi.c|966| <<vhost_scsi_get_desc>> vc->head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &vc->out, &vc->in, NULL, NULL);
+	 *   - drivers/vhost/test.c|61| <<handle_vq>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/vsock.c|127| <<vhost_transport_do_send_pkt>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/vsock.c|509| <<vhost_vsock_handle_tx_kick>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *
+	 * 注释:
+	 * This looks in the virtqueue and for the first available buffer, and converts
+	 * it to an iovec for convenient access.  Since descriptors consist of some
+	 * number of output then some number of input descriptors, it's actually two
+	 * iovecs, but we pack them into one and note how many of each there were.
+	 *
+	 * This function returns the descriptor number found, or vq->num (which is
+	 * never a valid descriptor number) if none was found.  A negative code is
+	 * returned on error.
+	 */
 	head = vhost_get_vq_desc(vq, vq->iov,
 			ARRAY_SIZE(vq->iov), &out, &in,
 			NULL, NULL);
@@ -508,6 +767,11 @@ vhost_scsi_do_evt_work(struct vhost_scsi *vs, struct vhost_scsi_evt *evt)
 		vq_err(vq, "Faulted on vhost_scsi_send_event\n");
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|531| <<vhost_scsi_evt_work>> vhost_scsi_complete_events(vs, false);
+ *   - drivers/vhost/scsi.c|1533| <<vhost_scsi_send_evt>> vhost_scsi_complete_events(vs, true);
+ */
 static void vhost_scsi_complete_events(struct vhost_scsi *vs, bool drop)
 {
 	struct vhost_virtqueue *vq = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;
@@ -524,6 +788,10 @@ static void vhost_scsi_complete_events(struct vhost_scsi *vs, bool drop)
 	mutex_unlock(&vq->mutex);
 }
 
+/*
+ * 在以下使用vhost_scsi_evt_work():
+ *   - drivers/vhost/scsi.c|1997| <<vhost_scsi_open>> vhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);
+ */
 static void vhost_scsi_evt_work(struct vhost_work *work)
 {
 	struct vhost_scsi *vs = container_of(work, struct vhost_scsi,
@@ -558,6 +826,10 @@ static int vhost_scsi_copy_sgl_to_iov(struct vhost_scsi_cmd *cmd)
  * This is scheduled in the vhost work queue so we are called with the owner
  * process mm and can access the vring.
  */
+/*
+ * 在以下使用vhost_scsi_complete_cmd_work():
+ *   - drivers/vhost/scsi.c|2006| <<vhost_scsi_open>> vhost_work_init(&svq->completion_work, vhost_scsi_complete_cmd_work);
+ */
 static void vhost_scsi_complete_cmd_work(struct vhost_work *work)
 {
 	struct vhost_scsi_virtqueue *svq = container_of(work,
@@ -571,11 +843,27 @@ static void vhost_scsi_complete_cmd_work(struct vhost_work *work)
 	int ret;
 
 	llnode = llist_del_all(&svq->completion_list);
+	/*
+	 * struct vhost_scsi_cmd *cmd, *t;
+	 */
 	llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list) {
+		/*
+		 * struct se_cmd *se_cmd;
+		 */
 		se_cmd = &cmd->tvc_se_cmd;
 
 		pr_debug("%s tv_cmd %p resid %u status %#02x\n", __func__,
 			cmd, se_cmd->residual_count, se_cmd->scsi_status);
+		/*
+		 * struct virtio_scsi_cmd_resp {
+		 *     __virtio32 sense_len;           // Sense data length
+		 *     __virtio32 resid;               // Residual bytes in data buffer
+		 *     __virtio16 status_qualifier;    // Status qualifier
+		 *     __u8 status;            // Command completion status
+		 *     __u8 response;          // Response values
+		 *     __u8 sense[VIRTIO_SCSI_SENSE_SIZE];
+		 * } __attribute__((packed));
+		 */
 		memset(&v_rsp, 0, sizeof(v_rsp));
 
 		if (cmd->saved_iter_addr && vhost_scsi_copy_sgl_to_iov(cmd)) {
@@ -591,16 +879,60 @@ static void vhost_scsi_complete_cmd_work(struct vhost_work *work)
 			       se_cmd->scsi_sense_length);
 		}
 
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_resp_iov:
+		 *   - drivers/vhost/scsi.c|687| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST, cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+		 *   - drivers/vhost/scsi.c|751| <<vhost_scsi_get_cmd>> tvc_resp_iov = cmd->tvc_resp_iov;
+		 *   - drivers/vhost/scsi.c|764| <<vhost_scsi_get_cmd>> cmd->tvc_resp_iov = tvc_resp_iov;
+		 *   - drivers/vhost/scsi.c|1599| <<vhost_scsi_handle_vq>> cmd->tvc_resp_iov[i] = vq->iov[vc.out + i];
+		 *   - drivers/vhost/scsi.c|2015| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_resp_iov);
+		 *   - drivers/vhost/scsi.c|2075| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_resp_iov = kcalloc(UIO_MAXIOV, sizeof(struct iovec), GFP_KERNEL);
+		 *   - drivers/vhost/scsi.c|2078| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_resp_iov) {
+		 *
+		 * 注释: Pointer to response header iovec
+		 *
+		 *
+		 * 在以下使用vhost_scsi_cmd->tvc_in_iovs:
+		 *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST,
+		 *                  cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+		 *   - drivers/vhost/scsi.c|1600| <<vhost_scsi_handle_vq>> cmd->tvc_in_iovs = vc.in;
+		 */
 		iov_iter_init(&iov_iter, ITER_DEST, cmd->tvc_resp_iov,
 			      cmd->tvc_in_iovs, sizeof(v_rsp));
+		/*
+		 * struct virtio_scsi_cmd_resp v_rsp;
+		 */
 		ret = copy_to_iter(&v_rsp, sizeof(v_rsp), &iov_iter);
 		if (likely(ret == sizeof(v_rsp))) {
 			signal = true;
 
+			/*
+			 * 在以下使用vhost_scsi_cmd->tvc_vq:
+			 *   - drivers/vhost/scsi.c|415| <<vhost_scsi_release_cmd_res>> struct vhost_scsi_virtqueue *svq = container_of(tv_cmd->tvc_vq,
+			 *                                    struct vhost_scsi_virtqueue, vq);
+			 *   - drivers/vhost/scsi.c|478| <<vhost_scsi_release_cmd>> struct vhost_scsi_virtqueue *svq = container_of(cmd->tvc_vq,
+			 *                                    struct vhost_scsi_virtqueue, vq);
+			 *   - drivers/vhost/scsi.c|734| <<vhost_scsi_complete_cmd_work>> v_rsp.resid = cpu_to_vhost32(cmd->tvc_vq, se_cmd->residual_count);
+			 *   - drivers/vhost/scsi.c|738| <<vhost_scsi_complete_cmd_work>> v_rsp.sense_len = cpu_to_vhost32(cmd->tvc_vq, se_cmd->scsi_sense_length);
+			 *   - drivers/vhost/scsi.c|778| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+			 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_handle_vq>> cmd->tvc_vq = vq;
+			 *
+			 * 在以下使用vhost_scsi_cmd->tvc_vq_desc:
+			 *   - drivers/vhost/scsi.c|670| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+			 *   - drivers/vhost/scsi.c|1471| <<vhost_scsi_handle_vq>> cmd->tvc_vq_desc = vc.head;
+			 *
+			 * 注释: Descriptor from vhost_get_vq_desc() for virt_queue segment
+			 */
 			vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
 		} else
 			pr_err("Faulted on virtio_scsi_cmd_resp\n");
 
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|405| <<vhost_scsi_drop_cmds>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+		 *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> vhost_scsi_release_cmd_res(se_cmd);
+		 *   - drivers/vhost/scsi.c|1549| <<vhost_scsi_handle_vq>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+		 */
 		vhost_scsi_release_cmd_res(se_cmd);
 	}
 
@@ -608,6 +940,13 @@ static void vhost_scsi_complete_cmd_work(struct vhost_work *work)
 		vhost_signal(&svq->vs->dev, &svq->vq);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1260| <<vhost_scsi_handle_vq>> cmd = vhost_scsi_get_cmd(vq, tpg, cdb, tag, lun, task_attr, exp_data_len + prot_bytes, data_direction);
+ *
+ * 核心思想是返回cmd = &svq->scsi_cmds[tag];
+ * 简单的初始化, 然后: memcpy(cmd->tvc_cdb, cdb, VHOST_SCSI_MAX_CDB_SIZE);
+ */
 static struct vhost_scsi_cmd *
 vhost_scsi_get_cmd(struct vhost_virtqueue *vq, struct vhost_scsi_tpg *tpg,
 		   unsigned char *cdb, u64 scsi_tag, u16 lun, u8 task_attr,
@@ -663,6 +1002,10 @@ vhost_scsi_get_cmd(struct vhost_virtqueue *vq, struct vhost_scsi_tpg *tpg,
  *
  * Returns the number of scatterlist entries used or -errno on error.
  */
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|838| <<vhost_scsi_map_iov_to_sgl>> ret = vhost_scsi_map_to_sgl(cmd, iter, sg, is_prot);
+ */
 static int
 vhost_scsi_map_to_sgl(struct vhost_scsi_cmd *cmd,
 		      struct iov_iter *iter,
@@ -750,6 +1093,10 @@ vhost_scsi_calc_sgls(struct iov_iter *iter, size_t bytes, int max_sgls)
 	return sgl_count;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|975| <<vhost_scsi_mapal>> ret = vhost_scsi_copy_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl, cmd->tvc_sgl_count);
+ */
 static int
 vhost_scsi_copy_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,
 			   struct scatterlist *sg, int sg_count)
@@ -783,6 +1130,11 @@ vhost_scsi_copy_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,
 		len -= nbytes;
 	}
 
+	/*
+	 * 在以下使用vhost_scsi_cmd->copied_iov:
+	 *   - drivers/vhost/scsi.c|374| <<vhost_scsi_release_cmd_res>> if (tv_cmd->copied_iov)
+	 *   - drivers/vhost/scsi.c|881| <<vhost_scsi_copy_iov_to_sgl>> cmd->copied_iov = 1;
+	 */
 	cmd->copied_iov = 1;
 	return 0;
 
@@ -796,6 +1148,11 @@ vhost_scsi_copy_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,
 	return -ENOMEM;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|879| <<vhost_scsi_mapal>> ret = vhost_scsi_map_iov_to_sgl(cmd, prot_iter, cmd->tvc_prot_sgl, cmd->tvc_prot_sgl_count, true);
+ *   - drivers/vhost/scsi.c|897| <<vhost_scsi_mapal>> ret = vhost_scsi_map_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl, cmd->tvc_sgl_count, false);
+ */
 static int
 vhost_scsi_map_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,
 			  struct scatterlist *sg, int sg_count, bool is_prot)
@@ -828,6 +1185,10 @@ vhost_scsi_map_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1280| <<vhost_scsi_handle_vq>> if (unlikely(vhost_scsi_mapal(cmd, prot_bytes, &prot_iter, exp_data_len, &data_iter))) {
+ */
 static int
 vhost_scsi_mapal(struct vhost_scsi_cmd *cmd,
 		 size_t prot_bytes, struct iov_iter *prot_iter,
@@ -868,6 +1229,9 @@ vhost_scsi_mapal(struct vhost_scsi_cmd *cmd,
 					cmd->tvc_sgl_count, false);
 	if (ret == -EINVAL) {
 		sg_init_table(cmd->tvc_sgl, cmd->tvc_sgl_count);
+		/*
+		 * 只在此处调用
+		 */
 		ret = vhost_scsi_copy_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl,
 						 cmd->tvc_sgl_count);
 	}
@@ -896,6 +1260,10 @@ static int vhost_scsi_to_tcm_attr(int attr)
 	return TCM_SIMPLE_TAG;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1472| <<vhost_scsi_handle_vq>> vhost_scsi_target_queue_cmd(cmd);
+ */
 static void vhost_scsi_target_queue_cmd(struct vhost_scsi_cmd *cmd)
 {
 	struct se_cmd *se_cmd = &cmd->tvc_se_cmd;
@@ -916,16 +1284,51 @@ static void vhost_scsi_target_queue_cmd(struct vhost_scsi_cmd *cmd)
 	tv_nexus = cmd->tvc_nexus;
 
 	se_cmd->tag = 0;
+	/*
+	 * called by:
+	 *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1596| <<srpt_handle_cmd>> rc = target_init_cmd(cmd, ch->sess, &send_ioctx->sense_data[0],
+	 *   - drivers/scsi/elx/efct/efct_lio.c|1381| <<efct_scsi_recv_cmd>> rc = target_init_cmd(se_cmd, se_sess, &io->tgt_io.sense_buffer[0],
+	 *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|479| <<tcm_qla2xxx_handle_cmd>> rc = target_init_cmd(se_cmd, se_sess, &cmd->sense_buffer[0],
+	 *   - drivers/target/loopback/tcm_loop.c|147| <<tcm_loop_target_queue_cmd>> target_init_cmd(se_cmd, tl_nexus->se_sess, &tl_cmd->tl_sense_buf[0],
+	 *   - drivers/target/target_core_transport.c|1836| <<target_submit_cmd>> rc = target_init_cmd(se_cmd, se_sess, sense, unpacked_lun, data_length,
+	 *   - drivers/target/tcm_fc/tfc_cmd.c|546| <<ft_send_work>> if (target_init_cmd(&cmd->se_cmd, cmd->sess->se_sess,
+	 *   - drivers/vhost/scsi.c|1009| <<vhost_scsi_target_queue_cmd>> target_init_cmd(se_cmd, tv_nexus->tvn_se_sess, &cmd->tvc_sense_buf[0],
+	 *   - drivers/xen/xen-scsiback.c|428| <<scsiback_cmd_exec>> target_init_cmd(se_cmd, sess, pending_req->sense_buffer,
+	 */
 	target_init_cmd(se_cmd, tv_nexus->tvn_se_sess, &cmd->tvc_sense_buf[0],
 			cmd->tvc_lun, cmd->tvc_exp_data_len,
 			vhost_scsi_to_tcm_attr(cmd->tvc_task_attr),
 			cmd->tvc_data_direction, TARGET_SCF_ACK_KREF);
 
+	/*
+	 * called by:
+	 *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1605| <<srpt_handle_cmd>> if (target_submit_prep(cmd, srp_cmd->cdb, sg, sg_cnt, NULL, 0, NULL, 0,
+	 *   - drivers/scsi/elx/efct/efct_lio.c|1390| <<efct_scsi_recv_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0,
+	 *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|485| <<tcm_qla2xxx_handle_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0, NULL, 0,
+	 *   - drivers/target/loopback/tcm_loop.c|151| <<tcm_loop_target_queue_cmd>> if (target_submit_prep(se_cmd, sc->cmnd, scsi_sglist(sc),
+	 *   - drivers/target/target_core_transport.c|1853| <<target_submit_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0, NULL, 0,
+	 *   - drivers/target/tcm_fc/tfc_cmd.c|552| <<ft_send_work>> if (target_submit_prep(&cmd->se_cmd, fcp->fc_cdb, NULL, 0, NULL, 0,
+	 *   - drivers/vhost/scsi.c|1032| <<vhost_scsi_target_queue_cmd>> if (target_submit_prep(se_cmd, cmd->tvc_cdb, sg_ptr,
+	 *   - drivers/xen/xen-scsiback.c|432| <<scsiback_cmd_exec>> if (target_submit_prep(se_cmd, pending_req->cmnd, pending_req->sgl,
+	 */
 	if (target_submit_prep(se_cmd, cmd->tvc_cdb, sg_ptr,
 			       cmd->tvc_sgl_count, NULL, 0, sg_prot_ptr,
 			       cmd->tvc_prot_sgl_count, GFP_KERNEL))
 		return;
 
+	/*
+	 * called by:
+	 *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1609| <<srpt_handle_cmd>> target_submit(cmd);
+	 *   - drivers/scsi/elx/efct/efct_lio.c|1394| <<efct_scsi_recv_cmd>> target_submit(se_cmd);
+	 *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|489| <<tcm_qla2xxx_handle_cmd>> target_submit(se_cmd);
+	 *   - drivers/target/iscsi/iscsi_target_erl1.c|950| <<iscsit_execute_cmd>> return target_submit(&cmd->se_cmd);
+	 *   - drivers/target/iscsi/iscsi_target_tmr.c|321| <<iscsit_task_reassign_complete_read>> target_submit(se_cmd);
+	 *   - drivers/target/loopback/tcm_loop.c|157| <<tcm_loop_target_queue_cmd>> target_submit(se_cmd);
+	 *   - drivers/target/target_core_transport.c|1857| <<target_submit_cmd>> target_submit(se_cmd);
+	 *   - drivers/target/tcm_fc/tfc_cmd.c|556| <<ft_send_work>> target_submit(&cmd->se_cmd);
+	 *   - drivers/vhost/scsi.c|1037| <<vhost_scsi_target_queue_cmd>> target_submit(se_cmd);
+	 *   - drivers/xen/xen-scsiback.c|436| <<scsiback_cmd_exec>> target_submit(se_cmd);
+	 */
 	target_submit(se_cmd);
 }
 
@@ -948,12 +1351,48 @@ vhost_scsi_send_bad_target(struct vhost_scsi *vs,
 		pr_err("Faulted on virtio_scsi_cmd_resp\n");
 }
 
+/*
+ * struct vhost_scsi_ctx {
+ *     int head;
+ *     unsigned int out, in;
+ *     size_t req_size, rsp_size;
+ *     size_t out_size, in_size;
+ *     u8 *target, *lunp;
+ *     void *req;
+ *     struct iov_iter out_iter;
+ * };
+ *
+ * called by:
+ *   - drivers/vhost/scsi.c|1193| <<vhost_scsi_handle_vq>> ret = vhost_scsi_get_desc(vs, vq, &vc);
+ *   - drivers/vhost/scsi.c|1526| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_get_desc(vs, vq, &vc);
+ */
 static int
 vhost_scsi_get_desc(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 		    struct vhost_scsi_ctx *vc)
 {
 	int ret = -ENXIO;
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/net.c|583| <<vhost_net_tx_get_vq_desc>> int r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+	 *   - drivers/vhost/net.c|595| <<vhost_net_tx_get_vq_desc>> r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+	 *   - drivers/vhost/net.c|1041| <<get_rx_bufs>> r = vhost_get_vq_desc(vq, vq->iov + seg, ARRAY_SIZE(vq->iov) - seg, &out, &in, log, log_num);
+	 *   - drivers/vhost/scsi.c|481| <<vhost_scsi_do_evt_work>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/scsi.c|966| <<vhost_scsi_get_desc>> vc->head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &vc->out, &vc->in, NULL, NULL);
+	 *   - drivers/vhost/test.c|61| <<handle_vq>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/vsock.c|127| <<vhost_transport_do_send_pkt>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/vsock.c|509| <<vhost_vsock_handle_tx_kick>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *
+	 * 注释:
+	 * This looks in the virtqueue and for the first available buffer, and converts
+	 * it to an iovec for convenient access.  Since descriptors consist of some
+	 * number of output then some number of input descriptors, it's actually two
+	 * iovecs, but we pack them into one and note how many of each there were.
+	 *
+	 * This function returns the descriptor number found, or vq->num (which is
+	 * never a valid descriptor number) if none was found.  A negative code is
+	 * returned on error.
+	 */
 	vc->head = vhost_get_vq_desc(vq, vq->iov,
 				     ARRAY_SIZE(vq->iov), &vc->out, &vc->in,
 				     NULL, NULL);
@@ -991,6 +1430,13 @@ vhost_scsi_get_desc(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 	 * point at the start of the outgoing WRITE payload, if
 	 * DMA_TO_DEVICE is set.
 	 */
+	/*
+	 * 在以下使用vhost_scsi_ctx->out_iter:
+	 *   - drivers/vhost/scsi.c|1071| <<vhost_scsi_get_desc>> iov_iter_init(&vc->out_iter, ITER_SOURCE, vq->iov, vc->out, vc->out_size);
+	 *   - drivers/vhost/scsi.c|1103| <<vhost_scsi_get_req>> if (unlikely(!copy_from_iter_full(vc->req, vc->req_size, &vc->out_iter))) {
+	 *   - drivers/vhost/scsi.c|1284| <<vhost_scsi_handle_vq>> data_iter = vc.out_iter;
+	 *   - drivers/vhost/scsi.c|1574| <<vhost_scsi_ctl_handle_vq>> if (unlikely(!copy_from_iter_full(vc.req, typ_size, &vc.out_iter))) {
+	 */
 	iov_iter_init(&vc->out_iter, ITER_SOURCE, vq->iov, vc->out, vc->out_size);
 	ret = 0;
 
@@ -1016,12 +1462,40 @@ vhost_scsi_chk_size(struct vhost_virtqueue *vq, struct vhost_scsi_ctx *vc)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1258| <<vhost_scsi_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+ *   - drivers/vhost/scsi.c|1621| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+ *
+ * 核心思想:
+ * 1. 把req_size的内容(header?)从vc->out_iter拷贝到vq->req
+ * 2. 根据target把vs_tpg[*vc->target]设置到函数的参数
+ */
 static int
 vhost_scsi_get_req(struct vhost_virtqueue *vq, struct vhost_scsi_ctx *vc,
 		   struct vhost_scsi_tpg **tpgp)
 {
 	int ret = -EIO;
 
+	/*
+	 * struct vhost_scsi_ctx {
+	 *     int head;  
+	 *     unsigned int out, in;
+	 *     size_t req_size, rsp_size;
+	 *     size_t out_size, in_size;
+	 *     u8 *target, *lunp;
+	 *     void *req;
+	 *     struct iov_iter out_iter;
+	 * };
+	 *
+	 * 在以下使用vhost_scsi_ctx->out_iter:
+	 *   - drivers/vhost/scsi.c|1071| <<vhost_scsi_get_desc>> iov_iter_init(&vc->out_iter, ITER_SOURCE, vq->iov, vc->out, vc->out_size);
+	 *   - drivers/vhost/scsi.c|1103| <<vhost_scsi_get_req>> if (unlikely(!copy_from_iter_full(vc->req, vc->req_size, &vc->out_iter))) {
+	 *   - drivers/vhost/scsi.c|1284| <<vhost_scsi_handle_vq>> data_iter = vc.out_iter;
+	 *   - drivers/vhost/scsi.c|1574| <<vhost_scsi_ctl_handle_vq>> if (unlikely(!copy_from_iter_full(vc.req, typ_size, &vc.out_iter))) {
+	 *
+	 * 从out_iter把req_size的header?拷贝到vc->req
+	 */
 	if (unlikely(!copy_from_iter_full(vc->req, vc->req_size,
 					  &vc->out_iter))) {
 		vq_err(vq, "Faulted on copy_from_iter_full\n");
@@ -1054,10 +1528,52 @@ static u16 vhost_buf_to_lun(u8 *lun_buf)
 	return ((lun_buf[2] << 8) | lun_buf[3]) & 0x3FFF;
 }
 
+/*
+ * 关于virtio-scsi下发的request
+ *
+ * 在scsi_alloc_sgtables()中把request给map到scsi_cmnd上的
+ *
+ * struct scsi_cmnd *cmd:
+ * -> struct scsi_data_buffer sdb;
+ *    -> struct sg_table table;
+ *       -> struct scatterlist *sgl;        // the list
+ *       -> unsigned int nents;             // number of mapped entries
+ *       -> unsigned int orig_nents;        // original size of list
+ *    -> unsigned length;
+ *
+ * 假设没有prot
+ *
+ * struct scatterlist *sgs[6].
+ *
+ * 如果是READ的
+ * sgs[0] : request header
+ * sgs[1] : response header
+ * sgs[2] : sc->sdb.table.sgl (in buffer)
+ *
+ * 如果是WRITE的
+ * sgs[0] : request header
+ * sgs[1] : sc->sdb.table.sgl (out buffer)
+ * sgs[2] : response header
+ *
+ *
+ * called by:
+ *   - drivers/vhost/scsi.c|1611| <<vhost_scsi_handle_kick>> vhost_scsi_handle_vq(vs, vq);
+ */
 static void
 vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 {
 	struct vhost_scsi_tpg **vs_tpg, *tpg;
+	/*
+	 * // SCSI command request, followed by data-out
+	 * struct virtio_scsi_cmd_req {
+	 *     __u8 lun[8];            // Logical Unit Number
+	 *     __virtio64 tag;         // Command identifier
+	 *     __u8 task_attr;         // Task attribute
+	 *     __u8 prio;              // SAM command priority field
+	 *     __u8 crn;
+	 *     __u8 cdb[VIRTIO_SCSI_CDB_SIZE];
+	 * } __attribute__((packed));
+	 */
 	struct virtio_scsi_cmd_req v_req;
 	struct virtio_scsi_cmd_req_pi v_req_pi;
 	struct vhost_scsi_ctx vc;
@@ -1076,16 +1592,37 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 	 * We can handle the vq only after the endpoint is setup by calling the
 	 * VHOST_SCSI_SET_ENDPOINT ioctl.
 	 */
+	/*
+	 * struct vhost_scsi_tpg **vs_tpg, *tpg;
+	 */
 	vs_tpg = vhost_vq_get_backend(vq);
 	if (!vs_tpg)
 		goto out;
 
+	/*
+	 * struct vhost_scsi_ctx {
+	 *     int head;
+	 *     unsigned int out, in;
+	 *     size_t req_size, rsp_size;
+	 *     size_t out_size, in_size;
+	 *     u8 *target, *lunp;
+	 *     void *req;
+	 *     struct iov_iter out_iter;
+	 * };
+	 *
+	 * struct vhost_scsi_ctx vc:
+	 */
 	memset(&vc, 0, sizeof(vc));
 	vc.rsp_size = sizeof(struct virtio_scsi_cmd_resp);
 
 	vhost_disable_notify(&vs->dev, vq);
 
 	do {
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|1193| <<vhost_scsi_handle_vq>> ret = vhost_scsi_get_desc(vs, vq, &vc);
+		 *   - drivers/vhost/scsi.c|1526| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_get_desc(vs, vq, &vc);
+		 */
 		ret = vhost_scsi_get_desc(vs, vq, &vc);
 		if (ret)
 			goto err;
@@ -1100,6 +1637,17 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 			vc.lunp = &v_req_pi.lun[0];
 			vc.target = &v_req_pi.lun[1];
 		} else {
+			/*
+			 * struct vhost_scsi_ctx {
+			 *     int head;
+			 *     unsigned int out, in;
+			 *     size_t req_size, rsp_size;
+			 *     size_t out_size, in_size;
+			 *     u8 *target, *lunp;
+			 *     void *req;
+			 *     struct iov_iter out_iter;
+			 * };
+			 */
 			vc.req = &v_req;
 			vc.req_size = sizeof(v_req);
 			vc.lunp = &v_req.lun[0];
@@ -1115,6 +1663,15 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		if (ret)
 			goto err;
 
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|1258| <<vhost_scsi_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+		 *   - drivers/vhost/scsi.c|1621| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+		 *
+		 * 核心思想:
+		 * 1. 把req_size的内容(header?)从vc->out_iter拷贝到vq->req
+		 * 2. 根据target把vs_tpg[*vc->target]设置到函数的参数
+		 */
 		ret = vhost_scsi_get_req(vq, &vc, &tpg);
 		if (ret)
 			goto err;
@@ -1138,14 +1695,37 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		 */
 		prot_bytes = 0;
 
+		/*
+		 * 如果是READ的
+		 * sgs[0] : request header
+		 * sgs[1] : response header
+		 * sgs[2] : sc->sdb.table.sgl (in buffer)
+		 *
+		 * 如果是WRITE的
+		 * sgs[0] : request header
+		 * sgs[1] : sc->sdb.table.sgl (out buffer)
+		 * sgs[2] : response header
+		 */
 		if (vc.out_size > vc.req_size) {
+			/*
+			 * WRITE
+			 */
 			data_direction = DMA_TO_DEVICE;
 			exp_data_len = vc.out_size - vc.req_size;
 			data_iter = vc.out_iter;
 		} else if (vc.in_size > vc.rsp_size) {
+			/*
+			 * READ
+			 */
 			data_direction = DMA_FROM_DEVICE;
 			exp_data_len = vc.in_size - vc.rsp_size;
 
+			/*
+			 * struct vhost_virtqueue *vq:
+			 * -> struct iovec iov[UIO_MAXIOV];
+			 * -> struct iovec iotlb_iov[64];
+			 * -> struct iovec *indirect;
+			 */
 			iov_iter_init(&in_iter, ITER_DEST, &vq->iov[vc.out], vc.in,
 				      vc.rsp_size + exp_data_len);
 			iov_iter_advance(&in_iter, vc.rsp_size);
@@ -1194,6 +1774,19 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 			cdb = &v_req_pi.cdb[0];
 			lun = vhost_buf_to_lun(v_req_pi.lun);
 		} else {
+			/*
+			 * // SCSI command request, followed by data-out
+			 * struct virtio_scsi_cmd_req {
+			 *     __u8 lun[8];            // Logical Unit Number
+			 *     __virtio64 tag;         // Command identifier
+			 *     __u8 task_attr;         // Task attribute
+			 *     __u8 prio;              // SAM command priority field
+			 *     __u8 crn;
+			 *     __u8 cdb[VIRTIO_SCSI_CDB_SIZE];
+			 * } __attribute__((packed));
+			 *
+			 * struct virtio_scsi_cmd_req v_req;
+			 */
 			tag = vhost64_to_cpu(vq, v_req.tag);
 			task_attr = v_req.task_attr;
 			cdb = &v_req.cdb[0];
@@ -1212,6 +1805,12 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 				scsi_command_size(cdb), VHOST_SCSI_MAX_CDB_SIZE);
 				goto err;
 		}
+		/*
+		 * 只在此处调用
+		 *
+		 * 核心思想是返回cmd = &svq->scsi_cmds[tag];
+		 * 简单的初始化, 然后: memcpy(cmd->tvc_cdb, cdb, VHOST_SCSI_MAX_CDB_SIZE);
+		 */
 		cmd = vhost_scsi_get_cmd(vq, tpg, cdb, tag, lun, task_attr,
 					 exp_data_len + prot_bytes,
 					 data_direction);
@@ -1220,10 +1819,30 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 			       PTR_ERR(cmd));
 			goto err;
 		}
+		/*
+		 * struct vhost_scsi_cmd *cmd;
+		 */
 		cmd->tvc_vhost = vs;
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_vq:
+		 *   - drivers/vhost/scsi.c|415| <<vhost_scsi_release_cmd_res>> struct vhost_scsi_virtqueue *svq = container_of(tv_cmd->tvc_vq,
+		 *                                    struct vhost_scsi_virtqueue, vq);
+		 *   - drivers/vhost/scsi.c|478| <<vhost_scsi_release_cmd>> struct vhost_scsi_virtqueue *svq = container_of(cmd->tvc_vq,
+		 *                                    struct vhost_scsi_virtqueue, vq);
+		 *   - drivers/vhost/scsi.c|734| <<vhost_scsi_complete_cmd_work>> v_rsp.resid = cpu_to_vhost32(cmd->tvc_vq, se_cmd->residual_count);
+		 *   - drivers/vhost/scsi.c|738| <<vhost_scsi_complete_cmd_work>> v_rsp.sense_len = cpu_to_vhost32(cmd->tvc_vq, se_cmd->scsi_sense_length);
+		 *   - drivers/vhost/scsi.c|778| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+		 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_handle_vq>> cmd->tvc_vq = vq;
+		 */
 		cmd->tvc_vq = vq;
 		for (i = 0; i < vc.in ; i++)
 			cmd->tvc_resp_iov[i] = vq->iov[vc.out + i];
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_in_iovs:
+		 *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST,
+		 *                  cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+		 *   - drivers/vhost/scsi.c|1600| <<vhost_scsi_handle_vq>> cmd->tvc_in_iovs = vc.in;
+		 */
 		cmd->tvc_in_iovs = vc.in;
 
 		pr_debug("vhost_scsi got command opcode: %#02x, lun: %d\n",
@@ -1231,11 +1850,23 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		pr_debug("cmd: %p exp_data_len: %d, prot_bytes: %d data_direction:"
 			 " %d\n", cmd, exp_data_len, prot_bytes, data_direction);
 
+		/*
+		 * 这里很重要, 用到data_iter!!!
+		 */
 		if (data_direction != DMA_NONE) {
+			/*
+			 * 只在这里调用
+			 */
 			if (unlikely(vhost_scsi_mapal(cmd, prot_bytes,
 						      &prot_iter, exp_data_len,
 						      &data_iter))) {
 				vq_err(vq, "Failed to map iov to sgl\n");
+				/*
+				 * called by:
+				 *   - drivers/vhost/scsi.c|405| <<vhost_scsi_drop_cmds>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+				 *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> vhost_scsi_release_cmd_res(se_cmd);
+				 *   - drivers/vhost/scsi.c|1549| <<vhost_scsi_handle_vq>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+				 */
 				vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
 				goto err;
 			}
@@ -1245,7 +1876,17 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		 * complete the virtio-scsi request in TCM callback context via
 		 * vhost_scsi_queue_data_in() and vhost_scsi_queue_status()
 		 */
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_vq_desc:
+		 *   - drivers/vhost/scsi.c|670| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+		 *   - drivers/vhost/scsi.c|1471| <<vhost_scsi_handle_vq>> cmd->tvc_vq_desc = vc.head;
+		 *
+		 * 注释: Descriptor from vhost_get_vq_desc() for virt_queue segment
+		 */
 		cmd->tvc_vq_desc = vc.head;
+		/*
+		 * 只在此处调用
+		 */
 		vhost_scsi_target_queue_cmd(cmd);
 		ret = 0;
 err:
@@ -1286,6 +1927,10 @@ vhost_scsi_send_tmf_resp(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 		pr_err("Faulted on virtio_scsi_ctrl_tmf_resp\n");
 }
 
+/*
+ * 在以下使用vhost_scsi_tmf_resp_work():
+ *   - drivers/vhost/scsi.c|1373| <<vhost_scsi_handle_tmf>> vhost_work_init(&tmf->vwork, vhost_scsi_tmf_resp_work);
+ */
 static void vhost_scsi_tmf_resp_work(struct vhost_work *work)
 {
 	struct vhost_scsi_tmf *tmf = container_of(work, struct vhost_scsi_tmf,
@@ -1470,6 +2115,11 @@ vhost_scsi_ctl_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		vc.req += typ_size;
 		vc.req_size -= typ_size;
 
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|1258| <<vhost_scsi_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+		 *   - drivers/vhost/scsi.c|1621| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+		 */
 		ret = vhost_scsi_get_req(vq, &vc, &tpg);
 		if (ret)
 			goto err;
@@ -1504,6 +2154,11 @@ static void vhost_scsi_ctl_handle_kick(struct vhost_work *work)
 	vhost_scsi_ctl_handle_vq(vs, vq);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1547| <<vhost_scsi_evt_handle_kick>> vhost_scsi_send_evt(vs, vq, NULL, NULL, VIRTIO_SCSI_T_NO_EVENT,
+ *   - drivers/vhost/scsi.c|2175| <<vhost_scsi_do_plug>> vhost_scsi_send_evt(vs, vq, tpg, lun, VIRTIO_SCSI_T_TRANSPORT_RESET, reason);
+ */
 static void
 vhost_scsi_send_evt(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 		    struct vhost_scsi_tpg *tpg, struct se_lun *lun,
@@ -1533,6 +2188,10 @@ vhost_scsi_send_evt(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 		vhost_scsi_complete_events(vs, true);
 }
 
+/*
+ * 在以下使用vhost_scsi_evt_handle_kick():
+ *   - drivers/vhost/scsi.c|2005| <<vhost_scsi_open>> vs->vqs[VHOST_SCSI_VQ_EVT].vq.handle_kick = vhost_scsi_evt_handle_kick;
+ */
 static void vhost_scsi_evt_handle_kick(struct vhost_work *work)
 {
 	struct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,
@@ -1543,6 +2202,11 @@ static void vhost_scsi_evt_handle_kick(struct vhost_work *work)
 	if (!vhost_vq_get_backend(vq))
 		goto out;
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|1547| <<vhost_scsi_evt_handle_kick>> vhost_scsi_send_evt(vs, vq, NULL, NULL, VIRTIO_SCSI_T_NO_EVENT,
+	 *   - drivers/vhost/scsi.c|2175| <<vhost_scsi_do_plug>> vhost_scsi_send_evt(vs, vq, tpg, lun, VIRTIO_SCSI_T_TRANSPORT_RESET, reason);
+	 */
 	if (vs->vs_events_missed)
 		vhost_scsi_send_evt(vs, vq, NULL, NULL, VIRTIO_SCSI_T_NO_EVENT,
 				    0);
@@ -1550,6 +2214,10 @@ static void vhost_scsi_evt_handle_kick(struct vhost_work *work)
 	mutex_unlock(&vq->mutex);
 }
 
+/*
+ * 在以下使用vhost_scsi_handle_kick():
+ *   - drivers/vhost/scsi.c|2014| <<vhost_scsi_open>> svq->vq.handle_kick = vhost_scsi_handle_kick;
+ */
 static void vhost_scsi_handle_kick(struct vhost_work *work)
 {
 	struct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,
@@ -1607,6 +2275,10 @@ static void vhost_scsi_destroy_vq_cmds(struct vhost_virtqueue *vq)
 	svq->scsi_cmds = NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1830| <<vhost_scsi_set_endpoint>> ret = vhost_scsi_setup_vq_cmds(vq, vq->num);
+ */
 static int vhost_scsi_setup_vq_cmds(struct vhost_virtqueue *vq, int max_cmds)
 {
 	struct vhost_scsi_virtqueue *svq = container_of(vq,
@@ -1622,6 +2294,14 @@ static int vhost_scsi_setup_vq_cmds(struct vhost_virtqueue *vq, int max_cmds)
 		return -ENOMEM;
 	svq->max_cmds = max_cmds;
 
+	/*
+	 * max_cmds实际是vq->num
+	 *
+	 * struct vhost_scsi_virtqueue *svq:
+	 * -> struct vhost_scsi_cmd *scsi_cmds;      
+	 * -> struct sbitmap scsi_tags;              
+	 * -> int max_cmds;
+	 */
 	svq->scsi_cmds = kcalloc(max_cmds, sizeof(*tv_cmd), GFP_KERNEL);
 	if (!svq->scsi_cmds) {
 		sbitmap_free(&svq->scsi_tags);
@@ -2188,6 +2868,9 @@ static void vhost_scsi_hotunplug(struct vhost_scsi_tpg *tpg, struct se_lun *lun)
 	vhost_scsi_do_plug(tpg, lun, false);
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_port_link(struct se_portal_group *se_tpg,
 			       struct se_lun *lun)
 {
@@ -2202,6 +2885,9 @@ static int vhost_scsi_port_link(struct se_portal_group *se_tpg,
 	return 0;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static void vhost_scsi_port_unlink(struct se_portal_group *se_tpg,
 				  struct se_lun *lun)
 {
@@ -2248,6 +2934,9 @@ static ssize_t vhost_scsi_tpg_attrib_fabric_prot_type_show(
 
 CONFIGFS_ATTR(vhost_scsi_tpg_attrib_, fabric_prot_type);
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static struct configfs_attribute *vhost_scsi_tpg_attrib_attrs[] = {
 	&vhost_scsi_tpg_attrib_attr_fabric_prot_type,
 	NULL,
@@ -2440,11 +3129,17 @@ static ssize_t vhost_scsi_tpg_nexus_store(struct config_item *item,
 
 CONFIGFS_ATTR(vhost_scsi_tpg_, nexus);
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static struct configfs_attribute *vhost_scsi_tpg_attrs[] = {
 	&vhost_scsi_tpg_attr_nexus,
 	NULL,
 };
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static struct se_portal_group *
 vhost_scsi_make_tpg(struct se_wwn *wwn, const char *name)
 {
@@ -2482,6 +3177,9 @@ vhost_scsi_make_tpg(struct se_wwn *wwn, const char *name)
 	return &tpg->se_tpg;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static void vhost_scsi_drop_tpg(struct se_portal_group *se_tpg)
 {
 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
@@ -2501,6 +3199,9 @@ static void vhost_scsi_drop_tpg(struct se_portal_group *se_tpg)
 	kfree(tpg);
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static struct se_wwn *
 vhost_scsi_make_tport(struct target_fabric_configfs *tf,
 		     struct config_group *group,
@@ -2562,6 +3263,9 @@ vhost_scsi_make_tport(struct target_fabric_configfs *tf,
 	return &tport->tport_wwn;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static void vhost_scsi_drop_tport(struct se_wwn *wwn)
 {
 	struct vhost_scsi_tport *tport = container_of(wwn,
@@ -2584,6 +3288,9 @@ vhost_scsi_wwn_version_show(struct config_item *item, char *page)
 
 CONFIGFS_ATTR_RO(vhost_scsi_wwn_, version);
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static struct configfs_attribute *vhost_scsi_wwn_attrs[] = {
 	&vhost_scsi_wwn_attr_version,
 	NULL,
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 9ac25d08f..7495c1b11 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -46,7 +46,48 @@ enum {
 	VHOST_MEMORY_F_LOG = 0x1,
 };
 
+/*
+ * struct vring_desc {
+ *     __virtio64 addr;
+ *     __virtio32 len;
+ *     __virtio16 flags;
+ *     __virtio16 next;
+ * };
+ *
+ * struct vring_avail {
+ *     __virtio16 flags;
+ *     __virtio16 idx;
+ *     __virtio16 ring[];
+ * };
+ *
+ * struct vring_used_elem {
+ *     __virtio32 id;
+ *     __virtio32 len;
+ * };
+ *
+ * struct vring_used {
+ *     __virtio16 flags;
+ *     __virtio16 idx;
+ *     vring_used_elem_t ring[];
+ * };
+ *
+ *
+ * struct vhost_virtqueue *vq:
+ * -> vring_desc_t __user *desc;
+ * -> vring_avail_t __user *avail;
+ * -> vring_used_t __user *used;
+ *
+ * 在以下使用vhost_used_event():
+ *   - drivers/vhost/vhost.c|1397| <<vhost_get_used_event>> return vhost_get_avail(vq, *event, vhost_used_event(vq))
+ */
 #define vhost_used_event(vq) ((__virtio16 __user *)&vq->avail->ring[vq->num])
+/*
+ * 在以下使用vhost_avail_event():
+ *   - drivers/vhost/vhost.c|1286| <<vhost_put_avail_event>> vhost_avail_event(vq));
+ *   - drivers/vhost/vhost.c|2402| <<vhost_update_avail_event>> used = vhost_avail_event(vq);
+ *   - drivers/vhost/vhost.c|2404| <<vhost_update_avail_event>> sizeof *vhost_avail_event(vq));
+ *   - drivers/vhost/vhost.c|2939| <<vhost_enable_notify>> vhost_avail_event(vq), r);
+ */
 #define vhost_avail_event(vq) ((__virtio16 __user *)&vq->used->ring[vq->num])
 
 #ifdef CONFIG_VHOST_CROSS_ENDIAN_LEGACY
@@ -140,6 +181,12 @@ static void vhost_reset_is_le(struct vhost_virtqueue *vq)
 
 struct vhost_flush_struct {
 	struct vhost_work work;
+	/*
+	 * 在以下使用vhost_flush_struct->wait_event:
+	 *   - drivers/vhost/vhost.c|151| <<vhost_flush_work>> complete(&s->wait_event);
+	 *   - drivers/vhost/vhost.c|279| <<__vhost_worker_flush>> init_completion(&flush.wait_event);
+	 *   - drivers/vhost/vhost.c|288| <<__vhost_worker_flush>> wait_for_completion(&flush.wait_event);
+	 */
 	struct completion wait_event;
 };
 
@@ -148,6 +195,12 @@ static void vhost_flush_work(struct vhost_work *work)
 	struct vhost_flush_struct *s;
 
 	s = container_of(work, struct vhost_flush_struct, work);
+	/*
+	 * 在以下使用vhost_flush_struct->wait_event:
+	 *   - drivers/vhost/vhost.c|151| <<vhost_flush_work>> complete(&s->wait_event);
+	 *   - drivers/vhost/vhost.c|279| <<__vhost_worker_flush>> init_completion(&flush.wait_event);
+	 *   - drivers/vhost/vhost.c|288| <<__vhost_worker_flush>> wait_for_completion(&flush.wait_event);
+	 */
 	complete(&s->wait_event);
 }
 
@@ -178,6 +231,15 @@ static int vhost_poll_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1352| <<vhost_scsi_handle_tmf>> vhost_work_init(&tmf->vwork, vhost_scsi_tmf_resp_work);
+ *   - drivers/vhost/scsi.c|1990| <<vhost_scsi_open>> vhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);
+ *   - drivers/vhost/scsi.c|2005| <<vhost_scsi_open>> vhost_work_init(&svq->completion_work,
+ *   - drivers/vhost/vhost.c|200| <<vhost_poll_init>> vhost_work_init(&poll->work, fn);
+ *   - drivers/vhost/vhost.c|280| <<__vhost_worker_flush>> vhost_work_init(&flush.work, vhost_flush_work);
+ *   - drivers/vhost/vsock.c|687| <<vhost_vsock_dev_open>> vhost_work_init(&vsock->send_pkt_work, vhost_transport_send_pkt_work);
+ */
 void vhost_work_init(struct vhost_work *work, vhost_work_fn_t fn)
 {
 	clear_bit(VHOST_WORK_QUEUED, &work->flags);
@@ -269,6 +331,12 @@ EXPORT_SYMBOL_GPL(vhost_vq_work_queue);
  *
  * The worker's flush_mutex must be held.
  */
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|295| <<vhost_worker_flush>> __vhost_worker_flush(worker);
+ *   - drivers/vhost/vhost.c|757| <<__vhost_vq_attach_worker>> __vhost_worker_flush(old_worker);
+ *   - drivers/vhost/vhost.c|816| <<vhost_free_worker>> __vhost_worker_flush(worker);
+ */
 static void __vhost_worker_flush(struct vhost_worker *worker)
 {
 	struct vhost_flush_struct flush;
@@ -285,10 +353,20 @@ static void __vhost_worker_flush(struct vhost_worker *worker)
 	 * mutex to force cleanup.
 	 */
 	mutex_unlock(&worker->mutex);
+	/*
+	 * 在以下使用vhost_flush_struct->wait_event:
+	 *   - drivers/vhost/vhost.c|151| <<vhost_flush_work>> complete(&s->wait_event);
+	 *   - drivers/vhost/vhost.c|279| <<__vhost_worker_flush>> init_completion(&flush.wait_event);
+	 *   - drivers/vhost/vhost.c|288| <<__vhost_worker_flush>> wait_for_completion(&flush.wait_event);
+	 */
 	wait_for_completion(&flush.wait_event);
 	mutex_lock(&worker->mutex);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|305| <<vhost_dev_flush>> vhost_worker_flush(worker);
+ */
 static void vhost_worker_flush(struct vhost_worker *worker)
 {
 	mutex_lock(&worker->mutex);
@@ -296,6 +374,17 @@ static void vhost_worker_flush(struct vhost_worker *worker)
 	mutex_unlock(&worker->mutex);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1359| <<vhost_net_flush>> vhost_dev_flush(&n->dev);
+ *   - drivers/vhost/net.c|1550| <<vhost_net_set_backend>> vhost_dev_flush(&n->dev);
+ *   - drivers/vhost/scsi.c|1323| <<vhost_scsi_tmf_flush_work>> vhost_dev_flush(vq->dev);
+ *   - drivers/vhost/scsi.c|1593| <<vhost_scsi_flush>> vhost_dev_flush(&vs->dev);
+ *   - drivers/vhost/test.c|149| <<vhost_test_flush>> vhost_dev_flush(&n->dev);
+ *   - drivers/vhost/vhost.c|1003| <<vhost_dev_stop>> vhost_dev_flush(dev);
+ *   - drivers/vhost/vhost.c|2092| <<vhost_vring_ioctl>> vhost_dev_flush(vq->poll.dev);
+ *   - drivers/vhost/vsock.c|697| <<vhost_vsock_flush>> vhost_dev_flush(&vsock->dev);
+ */
 void vhost_dev_flush(struct vhost_dev *dev)
 {
 	struct vhost_worker *worker;
@@ -457,6 +546,10 @@ static void vhost_vq_free_iovecs(struct vhost_virtqueue *vq)
 	vq->heads = NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|1043| <<vhost_dev_set_owner>> err = vhost_dev_alloc_iovecs(dev);
+ */
 /* Helper to allocate iovec buffers for all vqs. */
 static long vhost_dev_alloc_iovecs(struct vhost_dev *dev)
 {
@@ -468,6 +561,12 @@ static long vhost_dev_alloc_iovecs(struct vhost_dev *dev)
 		vq->indirect = kmalloc_array(UIO_MAXIOV,
 					     sizeof(*vq->indirect),
 					     GFP_KERNEL);
+		/*
+		 * 在以下使用vhost_dev->iov_limit:
+		 *   - drivers/vhost/vhost.c|639| <<vhost_dev_init>> dev->iov_limit = iov_limit;
+		 *   - drivers/vhost/vhost.c|560| <<vhost_dev_alloc_iovecs>> vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log), GFP_KERNEL);
+		 *   - drivers/vhost/vhost.c|562| <<vhost_dev_alloc_iovecs>> vq->heads = kmalloc_array(dev->iov_limit, sizeof(*vq->heads), GFP_KERNEL);
+		 */
 		vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log),
 					GFP_KERNEL);
 		vq->heads = kmalloc_array(dev->iov_limit, sizeof(*vq->heads),
@@ -530,6 +629,14 @@ static size_t vhost_get_desc_size(struct vhost_virtqueue *vq,
 	return sizeof(*vq->desc) * num;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1389| <<vhost_net_open>> vhost_dev_init(dev, vqs, VHOST_NET_VQ_MAX, UIO_MAXIOV + VHOST_NET_BATCH, VHOST_NET_PKT_WEIGHT, VHOST_NET_WEIGHT, true, NULL);
+ *   - drivers/vhost/scsi.c|2016| <<vhost_scsi_open>> vhost_dev_init(&vs->dev, vqs, nvqs, UIO_MAXIOV, VHOST_SCSI_WEIGHT, 0, true, NULL);
+ *   - drivers/vhost/test.c|122| <<vhost_test_open>> vhost_dev_init(dev, vqs, VHOST_TEST_VQ_MAX, UIO_MAXIOV, VHOST_TEST_PKT_WEIGHT, VHOST_TEST_WEIGHT, true, NULL);
+ *   - drivers/vhost/vdpa.c|1433| <<vhost_vdpa_open>> vhost_dev_init(dev, vqs, nvqs, 0, 0, 0, false, vhost_vdpa_process_iotlb_msg);
+ *   - drivers/vhost/vsock.c|681| <<vhost_vsock_dev_open>> vhost_dev_init(&vsock->dev, vqs, ARRAY_SIZE(vsock->vqs), UIO_MAXIOV, VHOST_VSOCK_PKT_WEIGHT, VHOST_VSOCK_WEIGHT, true, NULL);
+ */
 void vhost_dev_init(struct vhost_dev *dev,
 		    struct vhost_virtqueue **vqs, int nvqs,
 		    int iov_limit, int weight, int byte_weight,
@@ -547,6 +654,12 @@ void vhost_dev_init(struct vhost_dev *dev,
 	dev->umem = NULL;
 	dev->iotlb = NULL;
 	dev->mm = NULL;
+	/*
+	 * 在以下使用vhost_dev->iov_limit:
+	 *   - drivers/vhost/vhost.c|639| <<vhost_dev_init>> dev->iov_limit = iov_limit;
+	 *   - drivers/vhost/vhost.c|560| <<vhost_dev_alloc_iovecs>> vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log), GFP_KERNEL);
+	 *   - drivers/vhost/vhost.c|562| <<vhost_dev_alloc_iovecs>> vq->heads = kmalloc_array(dev->iov_limit, sizeof(*vq->heads), GFP_KERNEL);
+	 */
 	dev->iov_limit = iov_limit;
 	dev->weight = weight;
 	dev->byte_weight = byte_weight;
@@ -1301,6 +1414,10 @@ static inline int vhost_put_used_flags(struct vhost_virtqueue *vq)
 			      &vq->used->flags);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|3181| <<vhost_add_used_n>> if (vhost_put_used_idx(vq)) {
+ */
 static inline int vhost_put_used_idx(struct vhost_virtqueue *vq)
 
 {
@@ -1731,10 +1848,20 @@ static bool iotlb_access_ok(struct vhost_virtqueue *vq,
 	return true;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|951| <<handle_tx>> if (!vq_meta_prefetch(vq))
+ *   - drivers/vhost/net.c|1120| <<handle_rx>> if (!vq_meta_prefetch(vq))
+ *   - drivers/vhost/vsock.c|103| <<vhost_transport_do_send_pkt>> if (!vq_meta_prefetch(vq))
+ *   - drivers/vhost/vsock.c|494| <<vhost_vsock_handle_tx_kick>> if (!vq_meta_prefetch(vq))
+ */
 int vq_meta_prefetch(struct vhost_virtqueue *vq)
 {
 	unsigned int num = vq->num;
 
+	/*
+	 * 反正一般的vhost-scsi返回NULL
+	 */
 	if (!vq->iotlb)
 		return 1;
 
@@ -1879,6 +2006,10 @@ static long vhost_vring_set_num(struct vhost_dev *d,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2074| <<vhost_vring_set_num_addr(VHOST_SET_VRING_ADDR)>> r = vhost_vring_set_addr(d, vq, argp);
+ */
 static long vhost_vring_set_addr(struct vhost_dev *d,
 				 struct vhost_virtqueue *vq,
 				 void __user *argp)
@@ -1922,9 +2053,36 @@ static long vhost_vring_set_addr(struct vhost_dev *d,
 			return -EINVAL;
 	}
 
+	/*
+	 *  在以下使用vhost_virtqueue->log_used:
+	 *   - drivers/vhost/vhost.c|461| <<vhost_vq_reset>> vq->log_used = false;
+	 *   - drivers/vhost/vhost.c|1879| <<vq_log_access_ok>> vq_log_used_access_ok(vq, log_base, vq->log_used, vq->log_addr);
+	 *   - drivers/vhost/vhost.c|2024| <<vhost_vring_set_addr>> vq->log_used = !!(a.flags & (0x1 << VHOST_VRING_F_LOG));
+	 *   - drivers/vhost/vhost.c|2591| <<vhost_update_used_flags>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|2612| <<vhost_update_avail_event>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3035| <<__vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3082| <<vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 */
 	vq->log_used = !!(a.flags & (0x1 << VHOST_VRING_F_LOG));
 	vq->desc = (void __user *)(unsigned long)a.desc_user_addr;
 	vq->avail = (void __user *)(unsigned long)a.avail_user_addr;
+	/*
+	 * 这是来自QEMU-9.1的设置和使用:
+	 * 在以下设置vhost_virtqueue->used_phys:
+	 *   - hw/virtio/vhost.c|1594| <<vhost_virtqueue_start>> vq->used_phys = a = virtio_queue_get_used_addr(vdev, idx);
+	 * 在以下使用vhost_virtqueue->used_phys:
+	 *   - hw/virtio/vhost-vdpa.c|1535| <<vhost_vdpa_vq_get_addr>> addr->used_user_addr = (uint64_t)(unsigned long )vq->used_phys;
+	 *   - hw/virtio/vhost.c|382| <<vhost_sync_dirty_bitmap>> if (!vq->used_phys && !vq->used_size) {
+	 *   - hw/virtio/vhost.c|388| <<vhost_sync_dirty_bitmap>> hwaddr used_phys = vq->used_phys, used_size = vq->used_size;
+	 *   - hw/virtio/vhost.c|428| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr,
+	 *          vq->used_phys, range_get_last(vq->used_phys, vq->used_size));
+	 *   - hw/virtio/vhost.c|429| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr,
+	 *          vq->used_phys, range_get_last(vq->used_phys, vq->used_size));
+	 *   - hw/virtio/vhost.c|774| <<vhost_verify_ring_mappings>> r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys, vq->used_size,
+	 *   - hw/virtio/vhost.c|1206| <<vhost_virtqueue_set_addr>> addr.log_guest_addr = vq->used_phys;
+	 *   - hw/virtio/vhost.c|2473| <<vhost_dev_start>> vhost_device_iotlb_miss(hdev, vq->used_phys, true);
+	 *   - hw/virtio/virtio-qmp.c|833| <<qmp_x_query_virtio_vhost_queue_status>> status->used_phys = hdev->vqs[queue].used_phys;
+	 */
 	vq->log_addr = a.log_guest_addr;
 	vq->used = (void __user *)(unsigned long)a.used_user_addr;
 
@@ -2094,6 +2252,11 @@ long vhost_vring_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *arg
 }
 EXPORT_SYMBOL_GPL(vhost_vring_ioctl);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1626| <<vhost_net_set_features>> if (vhost_init_device_iotlb(&n->dev))
+ *   - drivers/vhost/vsock.c|812| <<vhost_vsock_set_features>> if (vhost_init_device_iotlb(&vsock->dev))
+ */
 int vhost_init_device_iotlb(struct vhost_dev *d)
 {
 	struct vhost_iotlb *niotlb, *oiotlb;
@@ -2121,6 +2284,14 @@ int vhost_init_device_iotlb(struct vhost_dev *d)
 }
 EXPORT_SYMBOL_GPL(vhost_init_device_iotlb);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1773| <<vhost_net_ioctl>> r = vhost_dev_ioctl(&n->dev, ioctl, argp);
+ *   - drivers/vhost/scsi.c|2112| <<vhost_scsi_ioctl>> r = vhost_dev_ioctl(&vs->dev, ioctl, argp);
+ *   - drivers/vhost/test.c|345| <<vhost_test_ioctl>> r = vhost_dev_ioctl(&n->dev, ioctl, argp);
+ *   - drivers/vhost/vdpa.c|888| <<vhost_vdpa_unlocked_ioctl>> r = vhost_dev_ioctl(&v->vdev, cmd, argp);
+ *   - drivers/vhost/vsock.c|877| <<vhost_vsock_dev_ioctl>> r = vhost_dev_ioctl(&vsock->dev, ioctl, argp);
+ */
 /* Caller must have device mutex */
 long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)
 {
@@ -2197,6 +2368,10 @@ EXPORT_SYMBOL_GPL(vhost_dev_ioctl);
  * (instruction directly accesses the data, with an exception table entry
  * returning -EFAULT). See Documentation/arch/x86/exception-tables.rst.
  */
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2234| <<log_write>> r = set_bit_to_user(bit, (void __user *)(unsigned long )log);
+ */
 static int set_bit_to_user(int nr, void __user *addr)
 {
 	unsigned long log = (unsigned long)addr;
@@ -2216,9 +2391,20 @@ static int set_bit_to_user(int nr, void __user *addr)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2265| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+ *   - drivers/vhost/vhost.c|2290| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+ *   - drivers/vhost/vhost.c|2327| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+ *
+ * 全部的caller都是写入vq->log_base
+ */
 static int log_write(void __user *log_base,
 		     u64 write_address, u64 write_length)
 {
+	/*
+	 * #define VHOST_PAGE_SIZE 0x1000
+	 */
 	u64 write_page = write_address / VHOST_PAGE_SIZE;
 	int r;
 
@@ -2231,6 +2417,9 @@ static int log_write(void __user *log_base,
 		int bit = write_page % 8;
 		if ((u64)(unsigned long)log != log)
 			return -EFAULT;
+		/*
+		 * 只在此处调用
+		 */
 		r = set_bit_to_user(bit, (void __user *)(unsigned long)log);
 		if (r < 0)
 			return r;
@@ -2242,6 +2431,38 @@ static int log_write(void __user *log_base,
 	return r;
 }
 
+/*
+ *  7 struct vhost_iotlb_map {
+ *  8         struct rb_node rb;
+ *  9         struct list_head link;
+ * 10         u64 start;
+ * 11         u64 last;
+ * 12         u64 size;
+ * 13         u64 addr;
+ * 14 #define VHOST_MAP_RO 0x1
+ * 15 #define VHOST_MAP_WO 0x2
+ * 16 #define VHOST_MAP_RW 0x3
+ * 17         u32 perm;
+ * 18         u32 flags_padding;
+ * 19         u64 __subtree_last;
+ * 20         void *opaque;
+ * 21 };
+ * 22
+ * 23 #define VHOST_IOTLB_FLAG_RETIRE 0x1
+ * 24
+ * 25 struct vhost_iotlb {
+ * 26         struct rb_root_cached root;
+ * 27         struct list_head list;
+ * 28         unsigned int limit;
+ * 29         unsigned int nmaps;
+ * 30         unsigned int flags;
+ * 31 };
+ *
+ *
+ * called by:
+ *   - drivers/vhost/vhost.c|2298| <<log_used>> ret = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+ *   - drivers/vhost/vhost.c|2317| <<vhost_log_write>> r = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+ */
 static int log_write_hva(struct vhost_virtqueue *vq, u64 hva, u64 len)
 {
 	struct vhost_iotlb *umem = vq->umem;
@@ -2262,6 +2483,40 @@ static int log_write_hva(struct vhost_virtqueue *vq, u64 hva, u64 len)
 			start = max(u->addr, hva);
 			end = min(u->addr - 1 + u->size, hva - 1 + len);
 			l = end - start + 1;
+			/*
+			 *  7 struct vhost_iotlb_map {
+			 *  8         struct rb_node rb;
+			 *  9         struct list_head link;
+			 * 10         u64 start;
+			 * 11         u64 last;
+			 * 12         u64 size;
+			 * 13         u64 addr; 
+			 * 14 #define VHOST_MAP_RO 0x1        
+			 * 15 #define VHOST_MAP_WO 0x2        
+			 * 16 #define VHOST_MAP_RW 0x3
+			 * 17         u32 perm;         
+			 * 18         u32 flags_padding;
+			 * 19         u64 __subtree_last;
+			 * 20         void *opaque;
+			 * 21 };
+			 *
+			 * 在以下使用vhost_virtqueue->log_base:
+			 *   - drivers/vhost/vhost.c|466| <<vhost_vq_reset>> vq->log_base = NULL;
+			 *   - drivers/vhost/vhost.c|1223| <<memory_access_ok>> ok = vq_memory_access_ok(d->vqs[i]->log_base, umem, log);
+			 *   - drivers/vhost/vhost.c|1886| <<vhost_vq_access_ok>> if (!vq_log_access_ok(vq, vq->log_base))
+			 *   - drivers/vhost/vhost.c|2018| <<vhost_vring_set_addr>> if (!vq_log_used_access_ok(vq, vq->log_base, a.flags & (0x1 << VHOST_VRING_F_LOG), a.log_guest_addr))
+			 *   - drivers/vhost/vhost.c|2269| <<vhost_dev_ioctl(VHOST_SET_LOG_BASE)>> vq->log_base = base;
+			 *   - drivers/vhost/vhost.c|2384| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+			 *   - drivers/vhost/vhost.c|2422| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+			 *   - drivers/vhost/vhost.c|2474| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+			 *
+			 * called by:
+			 *   - drivers/vhost/vhost.c|2265| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+			 *   - drivers/vhost/vhost.c|2290| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+			 *   - drivers/vhost/vhost.c|2327| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+			 *
+			 * 全部的caller都是写入vq->log_base
+			 */
 			r = log_write(vq->log_base,
 				      u->start + start - u->addr,
 				      l);
@@ -2281,20 +2536,73 @@ static int log_write_hva(struct vhost_virtqueue *vq, u64 hva, u64 len)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2353| <<vhost_update_used_flags>> log_used(vq, (used - (void __user *)vq->used), sizeof vq->used->flags);
+ *   - drivers/vhost/vhost.c|2371| <<vhost_update_avail_event>> log_used(vq, (used - (void __user *)vq->used), sizeof *vhost_avail_event(vq));
+ *   - drivers/vhost/vhost.c|2734| <<__vhost_add_used_n>> log_used(vq, ((void __user *)used - (void __user *)vq->used), count * sizeof *used);
+ *   - drivers/vhost/vhost.c|2776| <<vhost_add_used_n>> log_used(vq, offsetof(struct vring_used, idx), sizeof vq->used->idx);
+ */
 static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
 {
+	/*
+	 * struct vhost_virtqueue *vq:
+	 * -> void __user *log_base;
+	 * -> struct vhost_log *log;
+	 * -> struct iovec log_iov[64];
+	 */
 	struct iovec *iov = vq->log_iov;
 	int i, ret;
 
+	/*
+	 * 在以下使用vhost_virtqueue->log_base:
+	 *   - drivers/vhost/vhost.c|466| <<vhost_vq_reset>> vq->log_base = NULL;
+	 *   - drivers/vhost/vhost.c|1223| <<memory_access_ok>> ok = vq_memory_access_ok(d->vqs[i]->log_base, umem, log);
+	 *   - drivers/vhost/vhost.c|1886| <<vhost_vq_access_ok>> if (!vq_log_access_ok(vq, vq->log_base))
+	 *   - drivers/vhost/vhost.c|2018| <<vhost_vring_set_addr>> if (!vq_log_used_access_ok(vq, vq->log_base, a.flags & (0x1 << VHOST_VRING_F_LOG), a.log_guest_addr))
+	 *   - drivers/vhost/vhost.c|2269| <<vhost_dev_ioctl(VHOST_SET_LOG_BASE)>> vq->log_base = base;
+	 *   - drivers/vhost/vhost.c|2384| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+	 *   - drivers/vhost/vhost.c|2422| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+	 *   - drivers/vhost/vhost.c|2474| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+	 *
+	 * 在以下使用vhost_virtqueue->log_addr:
+	 *   - drivers/vhost/vhost.c|373| <<vhost_vq_reset>> vq->log_addr = -1ull;
+	 *   - drivers/vhost/vhost.c|1780| <<vq_log_access_ok>> vq_log_used_access_ok(vq, log_base, vq->log_used, vq->log_addr);
+	 *   - drivers/vhost/vhost.c|1928| <<vhost_vring_set_addr>> vq->log_addr = a.log_guest_addr;
+	 *   - drivers/vhost/vhost.c|2312| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+	 *
+	 *
+	 * called by:
+	 *   - drivers/vhost/vhost.c|2265| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+	 *   - drivers/vhost/vhost.c|2290| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+	 *   - drivers/vhost/vhost.c|2327| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+	 *
+	 * 全部的caller都是写入vq->log_base
+	 */
 	if (!vq->iotlb)
 		return log_write(vq->log_base, vq->log_addr + used_offset, len);
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/vhost.c|1169| <<vhost_copy_to_user>> ret = translate_desc(vq, (u64)(uintptr_t)to, size, vq->iotlb_iov,
+	 *   - drivers/vhost/vhost.c|1204| <<vhost_copy_from_user>> ret = translate_desc(vq, (u64)(uintptr_t)from, size, vq->iotlb_iov,
+	 *   - drivers/vhost/vhost.c|1229| <<__vhost_get_user_slow>> ret = translate_desc(vq, (u64)(uintptr_t)addr, size, vq->iotlb_iov,
+	 *   - drivers/vhost/vhost.c|2320| <<log_used>> ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
+	 *   - drivers/vhost/vhost.c|2528| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+	 *   - drivers/vhost/vhost.c|2569| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+	 *   - drivers/vhost/vhost.c|2688| <<vhost_get_vq_desc>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+	 */
 	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
 			     len, iov, 64, VHOST_ACCESS_WO);
 	if (ret < 0)
 		return ret;
 
 	for (i = 0; i < ret; i++) {
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2298| <<log_used>> ret = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+		 *   - drivers/vhost/vhost.c|2317| <<vhost_log_write>> r = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+		 */
 		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
 				    iov[i].iov_len);
 		if (ret)
@@ -2304,6 +2612,10 @@ static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1219| <<handle_rx>> vhost_log_write(vq, vq_log, log, vhost_len, vq->iov, in);
+ */
 int vhost_log_write(struct vhost_virtqueue *vq, struct vhost_log *log,
 		    unsigned int log_num, u64 len, struct iovec *iov, int count)
 {
@@ -2314,6 +2626,11 @@ int vhost_log_write(struct vhost_virtqueue *vq, struct vhost_log *log,
 
 	if (vq->iotlb) {
 		for (i = 0; i < count; i++) {
+			/*
+			 * called by:
+			 *   - drivers/vhost/vhost.c|2298| <<log_used>> ret = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+			 *   - drivers/vhost/vhost.c|2317| <<vhost_log_write>> r = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+			 */
 			r = log_write_hva(vq, (uintptr_t)iov[i].iov_base,
 					  iov[i].iov_len);
 			if (r < 0)
@@ -2324,6 +2641,22 @@ int vhost_log_write(struct vhost_virtqueue *vq, struct vhost_log *log,
 
 	for (i = 0; i < log_num; ++i) {
 		u64 l = min(log[i].len, len);
+		/*
+		 * 在以下使用vhost_virtqueue->log_base:
+		 *   - drivers/vhost/vhost.c|466| <<vhost_vq_reset>> vq->log_base = NULL;
+		 *   - drivers/vhost/vhost.c|1223| <<memory_access_ok>> ok = vq_memory_access_ok(d->vqs[i]->log_base, umem, log);
+		 *   - drivers/vhost/vhost.c|1886| <<vhost_vq_access_ok>> if (!vq_log_access_ok(vq, vq->log_base))
+		 *   - drivers/vhost/vhost.c|2018| <<vhost_vring_set_addr>> if (!vq_log_used_access_ok(vq, vq->log_base, a.flags & (0x1 << VHOST_VRING_F_LOG), a.log_guest_addr))
+		 *   - drivers/vhost/vhost.c|2269| <<vhost_dev_ioctl(VHOST_SET_LOG_BASE)>> vq->log_base = base;
+		 *   - drivers/vhost/vhost.c|2384| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+		 *   - drivers/vhost/vhost.c|2422| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+		 *   - drivers/vhost/vhost.c|2474| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+		 *
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2265| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+		 *   - drivers/vhost/vhost.c|2290| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+		 *   - drivers/vhost/vhost.c|2327| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+		 */
 		r = log_write(vq->log_base, log[i].addr, l);
 		if (r < 0)
 			return r;
@@ -2340,6 +2673,12 @@ int vhost_log_write(struct vhost_virtqueue *vq, struct vhost_log *log,
 }
 EXPORT_SYMBOL_GPL(vhost_log_write);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2422| <<vhost_vq_init_access>> r = vhost_update_used_flags(vq);
+ *   - drivers/vhost/vhost.c|2929| <<vhost_enable_notify>> r = vhost_update_used_flags(vq);
+ *   - drivers/vhost/vhost.c|2965| <<vhost_disable_notify>> r = vhost_update_used_flags(vq);
+ */
 static int vhost_update_used_flags(struct vhost_virtqueue *vq)
 {
 	void __user *used;
@@ -2358,6 +2697,10 @@ static int vhost_update_used_flags(struct vhost_virtqueue *vq)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2936| <<vhost_enable_notify>> r = vhost_update_avail_event(vq);
+ */
 static int vhost_update_avail_event(struct vhost_virtqueue *vq)
 {
 	if (vhost_put_avail_event(vq))
@@ -2376,6 +2719,14 @@ static int vhost_update_avail_event(struct vhost_virtqueue *vq)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1519| <<vhost_net_set_backend>> r = vhost_vq_init_access(vq);
+ *   - drivers/vhost/scsi.c|1786| <<vhost_scsi_set_endpoint>> vhost_vq_init_access(vq);
+ *   - drivers/vhost/test.c|197| <<vhost_test_run>> r = vhost_vq_init_access(&n->vqs[index]);
+ *   - drivers/vhost/test.c|290| <<vhost_test_set_backend>> r = vhost_vq_init_access(vq);
+ *   - drivers/vhost/vsock.c|589| <<vhost_vsock_start>> ret = vhost_vq_init_access(vq);
+ */
 int vhost_vq_init_access(struct vhost_virtqueue *vq)
 {
 	__virtio16 last_used_idx;
@@ -2411,6 +2762,16 @@ int vhost_vq_init_access(struct vhost_virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(vhost_vq_init_access);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|1169| <<vhost_copy_to_user>> ret = translate_desc(vq, (u64)(uintptr_t)to, size, vq->iotlb_iov,
+ *   - drivers/vhost/vhost.c|1204| <<vhost_copy_from_user>> ret = translate_desc(vq, (u64)(uintptr_t)from, size, vq->iotlb_iov,
+ *   - drivers/vhost/vhost.c|1229| <<__vhost_get_user_slow>> ret = translate_desc(vq, (u64)(uintptr_t)addr, size, vq->iotlb_iov,
+ *   - drivers/vhost/vhost.c|2320| <<log_used>> ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
+ *   - drivers/vhost/vhost.c|2528| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+ *   - drivers/vhost/vhost.c|2569| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+ *   - drivers/vhost/vhost.c|2688| <<vhost_get_vq_desc>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+ */
 static int translate_desc(struct vhost_virtqueue *vq, u64 addr, u32 len,
 			  struct iovec iov[], int iov_size, int access)
 {
@@ -2459,6 +2820,11 @@ static int translate_desc(struct vhost_virtqueue *vq, u64 addr, u32 len,
 /* Each buffer in the virtqueues is actually a chain of descriptors.  This
  * function returns the next descriptor in the chain,
  * or -1U if we're at the end. */
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2917| <<get_indirect>> } while ((i = next_desc(vq, &desc)) != -1);
+ *   - drivers/vhost/vhost.c|3066| <<vhost_get_vq_desc>> } while ((i = next_desc(vq, &desc)) != -1);
+ */
 static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)
 {
 	unsigned int next;
@@ -2561,6 +2927,11 @@ static int get_indirect(struct vhost_virtqueue *vq,
 			}
 			*out_num += ret;
 		}
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2917| <<get_indirect>> } while ((i = next_desc(vq, &desc)) != -1);
+		 *   - drivers/vhost/vhost.c|3066| <<vhost_get_vq_desc>> } while ((i = next_desc(vq, &desc)) != -1);
+		 */
 	} while ((i = next_desc(vq, &desc)) != -1);
 	return 0;
 }
@@ -2573,6 +2944,27 @@ static int get_indirect(struct vhost_virtqueue *vq,
  * This function returns the descriptor number found, or vq->num (which is
  * never a valid descriptor number) if none was found.  A negative code is
  * returned on error. */
+/*
+ * called by:
+ *   - drivers/vhost/net.c|583| <<vhost_net_tx_get_vq_desc>> int r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+ *   - drivers/vhost/net.c|595| <<vhost_net_tx_get_vq_desc>> r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+ *   - drivers/vhost/net.c|1041| <<get_rx_bufs>> r = vhost_get_vq_desc(vq, vq->iov + seg, ARRAY_SIZE(vq->iov) - seg, &out, &in, log, log_num);
+ *   - drivers/vhost/scsi.c|481| <<vhost_scsi_do_evt_work>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+ *   - drivers/vhost/scsi.c|966| <<vhost_scsi_get_desc>> vc->head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &vc->out, &vc->in, NULL, NULL);
+ *   - drivers/vhost/test.c|61| <<handle_vq>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+ *   - drivers/vhost/vsock.c|127| <<vhost_transport_do_send_pkt>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+ *   - drivers/vhost/vsock.c|509| <<vhost_vsock_handle_tx_kick>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+ *
+ * 注释:
+ * This looks in the virtqueue and for the first available buffer, and converts
+ * it to an iovec for convenient access.  Since descriptors consist of some
+ * number of output then some number of input descriptors, it's actually two
+ * iovecs, but we pack them into one and note how many of each there were.
+ *
+ * This function returns the descriptor number found, or vq->num (which is
+ * never a valid descriptor number) if none was found.  A negative code is
+ * returned on error.
+ */
 int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 		      struct iovec iov[], unsigned int iov_size,
 		      unsigned int *out_num, unsigned int *in_num,
@@ -2649,10 +3041,36 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			continue;
 		}
 
+		/*
+		 * 在以下使用VRING_DESC_F_WRITE:
+		 *   - drivers/vhost/vhost.c|2898| <<get_indirect>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+		 *   - drivers/vhost/vhost.c|3044| <<vhost_get_vq_desc>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+		 *   - drivers/vhost/vringh.c|373| <<__vringh_iov>> if (desc.flags & cpu_to_vringh16(vrh, VRING_DESC_F_WRITE))
+		 *   - drivers/virtio/virtio_ring.c|456| <<vring_unmap_one_split_indirect>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|475| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|484| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|670| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i, addr, sg->length,
+		 *                                             VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+		 *   - drivers/virtio/virtio_ring.c|1266| <<vring_unmap_extra_packed>> dma_unmap_single(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|1274| <<vring_unmap_extra_packed>> dma_unmap_page(vring_dma_dev(vq),... (flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|1292| <<vring_unmap_desc_packed>> dma_unmap_page(vring_dma_dev(vq), ... (flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|1350| <<virtqueue_add_indirect_packed>> desc[i].flags = cpu_to_le16(n < out_sgs ? 0 : VRING_DESC_F_WRITE);
+		 *   - drivers/virtio/virtio_ring.c|1504| <<virtqueue_add_packed>> flags = cpu_to_le16(... (n < out_sgs ? 0 : VRING_DESC_F_WRITE));
+		 */
 		if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
 			access = VHOST_ACCESS_WO;
 		else
 			access = VHOST_ACCESS_RO;
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|1169| <<vhost_copy_to_user>> ret = translate_desc(vq, (u64)(uintptr_t)to, size, vq->iotlb_iov,
+		 *   - drivers/vhost/vhost.c|1204| <<vhost_copy_from_user>> ret = translate_desc(vq, (u64)(uintptr_t)from, size, vq->iotlb_iov,
+		 *   - drivers/vhost/vhost.c|1229| <<__vhost_get_user_slow>> ret = translate_desc(vq, (u64)(uintptr_t)addr, size, vq->iotlb_iov,
+		 *   - drivers/vhost/vhost.c|2320| <<log_used>> ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
+		 *   - drivers/vhost/vhost.c|2528| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+		 *   - drivers/vhost/vhost.c|2569| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+		 *   - drivers/vhost/vhost.c|2688| <<vhost_get_vq_desc>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+		 */
 		ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
 				     vhost32_to_cpu(vq, desc.len), iov + iov_count,
 				     iov_size - iov_count, access);
@@ -2667,6 +3085,14 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			 * increment that count. */
 			*in_num += ret;
 			if (unlikely(log && ret)) {
+				/*
+				 * struct vring_desc {
+				 *     __virtio64 addr; 
+				 *     __virtio32 len;          
+				 *     __virtio16 flags;               
+				 *     __virtio16 next;         
+				 * };
+				 */
 				log[*log_num].addr = vhost64_to_cpu(vq, desc.addr);
 				log[*log_num].len = vhost32_to_cpu(vq, desc.len);
 				++*log_num;
@@ -2681,6 +3107,11 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			}
 			*out_num += ret;
 		}
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2917| <<get_indirect>> } while ((i = next_desc(vq, &desc)) != -1);
+		 *   - drivers/vhost/vhost.c|3066| <<vhost_get_vq_desc>> } while ((i = next_desc(vq, &desc)) != -1);
+		 */
 	} while ((i = next_desc(vq, &desc)) != -1);
 
 	/* On success, increment avail index. */
@@ -2693,6 +3124,15 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 }
 EXPORT_SYMBOL_GPL(vhost_get_vq_desc);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|793| <<handle_tx_copy>> vhost_discard_vq_desc(vq, 1);
+ *   - drivers/vhost/net.c|814| <<handle_tx_copy>> vhost_discard_vq_desc(vq, 1);
+ *   - drivers/vhost/net.c|922| <<handle_tx_zerocopy>> vhost_discard_vq_desc(vq, 1);
+ *   - drivers/vhost/net.c|1081| <<get_rx_bufs>> vhost_discard_vq_desc(vq, headcount);
+ *   - drivers/vhost/net.c|1188| <<handle_rx>> vhost_discard_vq_desc(vq, headcount);
+ *   - drivers/vhost/net.c|1212| <<handle_rx>> vhost_discard_vq_desc(vq, headcount);
+ */
 /* Reverse the effect of vhost_get_vq_desc. Useful for error handling. */
 void vhost_discard_vq_desc(struct vhost_virtqueue *vq, int n)
 {
@@ -2700,6 +3140,13 @@ void vhost_discard_vq_desc(struct vhost_virtqueue *vq, int n)
 }
 EXPORT_SYMBOL_GPL(vhost_discard_vq_desc);
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|609| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+ *   - drivers/vhost/vhost.c|2868| <<vhost_add_used_and_signal>> vhost_add_used(vq, head, len);
+ *   - drivers/vhost/vsock.c|216| <<vhost_transport_do_send_pkt>> vhost_add_used(vq, head, sizeof(*hdr) + payload_len);
+ *   - drivers/vhost/vsock.c|543| <<vhost_vsock_handle_tx_kick>> vhost_add_used(vq, head, 0);
+ */
 /* After we've used one of their buffers, we tell them about it.  We'll then
  * want to notify the guest, using eventfd. */
 int vhost_add_used(struct vhost_virtqueue *vq, unsigned int head, int len)
@@ -2709,10 +3156,22 @@ int vhost_add_used(struct vhost_virtqueue *vq, unsigned int head, int len)
 		cpu_to_vhost32(vq, len)
 	};
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|609| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+	 *   - drivers/vhost/vhost.c|2868| <<vhost_add_used_and_signal>> vhost_add_used(vq, head, len);
+	 *   - drivers/vhost/vsock.c|216| <<vhost_transport_do_send_pkt>> vhost_add_used(vq, head, sizeof(*hdr) + payload_len);
+	 *   - drivers/vhost/vsock.c|543| <<vhost_vsock_handle_tx_kick>> vhost_add_used(vq, head, 0);
+	 */
 	return vhost_add_used_n(vq, &heads, 1);
 }
 EXPORT_SYMBOL_GPL(vhost_add_used);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2790| <<vhost_add_used_n>> r = __vhost_add_used_n(vq, heads, n);
+ *   - drivers/vhost/vhost.c|2796| <<vhost_add_used_n>> r = __vhost_add_used_n(vq, heads, count);
+ */
 static int __vhost_add_used_n(struct vhost_virtqueue *vq,
 			    struct vring_used_elem *heads,
 			    unsigned count)
@@ -2747,6 +3206,16 @@ static int __vhost_add_used_n(struct vhost_virtqueue *vq,
 
 /* After we've used one of their buffers, we tell them about it.  We'll then
  * want to notify the guest, using eventfd. */
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2744| <<vhost_add_used>> return vhost_add_used_n(vq, &heads, 1);
+ *   - drivers/vhost/vhost.c|2878| <<vhost_add_used_and_signal_n>> vhost_add_used_n(vq, heads, count);
+ *
+ * struct vring_used_elem {
+ *     __virtio32 id;
+ *     __virtio32 len;
+ * };
+ */
 int vhost_add_used_n(struct vhost_virtqueue *vq, struct vring_used_elem *heads,
 		     unsigned count)
 {
@@ -2761,17 +3230,51 @@ int vhost_add_used_n(struct vhost_virtqueue *vq, struct vring_used_elem *heads,
 		heads += n;
 		count -= n;
 	}
+	/*
+	 * called by:
+	 *   - drivers/vhost/vhost.c|2790| <<vhost_add_used_n>> r = __vhost_add_used_n(vq, heads, n);
+	 *   - drivers/vhost/vhost.c|2796| <<vhost_add_used_n>> r = __vhost_add_used_n(vq, heads, count);
+	 */
 	r = __vhost_add_used_n(vq, heads, count);
 
 	/* Make sure buffer is written before we update index. */
 	smp_wmb();
+	/*
+	 * 只在此处调用
+	 */
 	if (vhost_put_used_idx(vq)) {
 		vq_err(vq, "Failed to increment used idx");
 		return -EFAULT;
 	}
+	/*
+	 * 在以下使用vhost_virtqueue->log_used:
+	 *   - drivers/vhost/vhost.c|461| <<vhost_vq_reset>> vq->log_used = false;
+	 *   - drivers/vhost/vhost.c|1879| <<vq_log_access_ok>> vq_log_used_access_ok(vq, log_base, vq->log_used, vq->log_addr);
+	 *   - drivers/vhost/vhost.c|2024| <<vhost_vring_set_addr>> vq->log_used = !!(a.flags & (0x1 << VHOST_VRING_F_LOG));
+	 *   - drivers/vhost/vhost.c|2591| <<vhost_update_used_flags>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|2612| <<vhost_update_avail_event>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3035| <<__vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3082| <<vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 */
 	if (unlikely(vq->log_used)) {
 		/* Make sure used idx is seen before log. */
 		smp_wmb();
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2353| <<vhost_update_used_flags>> log_used(vq, (used - (void __user *)vq->used), sizeof vq->used->flags);
+		 *   - drivers/vhost/vhost.c|2371| <<vhost_update_avail_event>> log_used(vq, (used - (void __user *)vq->used), sizeof *vhost_avail_event(vq));
+		 *   - drivers/vhost/vhost.c|2734| <<__vhost_add_used_n>> log_used(vq, ((void __user *)used - (void __user *)vq->used), count * sizeof *used);
+		 *   - drivers/vhost/vhost.c|2776| <<vhost_add_used_n>> log_used(vq, offsetof(struct vring_used, idx), sizeof vq->used->idx);
+		 *
+		 * 定义:
+		 * static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len) {}
+		 *
+		 * struct vring_used {
+		 *     __virtio16 flags;
+		 *     __virtio16 idx;
+		 *     vring_used_elem_t ring[];
+		 * };
+		 */
 		/* Log used index update. */
 		log_used(vq, offsetof(struct vring_used, idx),
 			 sizeof vq->used->idx);
@@ -2782,6 +3285,10 @@ int vhost_add_used_n(struct vhost_virtqueue *vq, struct vring_used_elem *heads,
 }
 EXPORT_SYMBOL_GPL(vhost_add_used_n);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2875| <<vhost_signal>> if (vq->call_ctx.ctx && vhost_notify(dev, vq))
+ */
 static bool vhost_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 {
 	__u16 old, new;
@@ -2819,6 +3326,14 @@ static bool vhost_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 	return vring_need_event(vhost16_to_cpu(vq, event), new, old);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|617| <<vhost_scsi_complete_cmd_work>> vhost_signal(&svq->vs->dev, &svq->vq);
+ *   - drivers/vhost/vhost.c|2886| <<vhost_add_used_and_signal>> vhost_signal(dev, vq);
+ *   - drivers/vhost/vhost.c|2901| <<vhost_add_used_and_signal_n>> vhost_signal(dev, vq);
+ *   - drivers/vhost/vsock.c|251| <<vhost_transport_do_send_pkt>> vhost_signal(&vsock->dev, vq);
+ *   - drivers/vhost/vsock.c|549| <<vhost_vsock_handle_tx_kick>> vhost_signal(&vsock->dev, vq);
+ */
 /* This actually signals the guest, using eventfd. */
 void vhost_signal(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 {
@@ -2828,6 +3343,15 @@ void vhost_signal(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(vhost_signal);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|931| <<handle_tx_zerocopy>> vhost_add_used_and_signal(&net->dev, vq, head, 0);
+ *   - drivers/vhost/scsi.c|510| <<vhost_scsi_do_evt_work>> vhost_add_used_and_signal(&vs->dev, vq, head, 0);
+ *   - drivers/vhost/scsi.c|955| <<vhost_scsi_send_bad_target>> vhost_add_used_and_signal(&vs->dev, vq, head, 0);
+ *   - drivers/vhost/scsi.c|1293| <<vhost_scsi_send_tmf_resp>> vhost_add_used_and_signal(&vs->dev, vq, vq_desc, 0);
+ *   - drivers/vhost/scsi.c|1392| <<vhost_scsi_send_an_resp>> vhost_add_used_and_signal(&vs->dev, vq, vc->head, 0);
+ *   - drivers/vhost/test.c|87| <<handle_vq>> vhost_add_used_and_signal(&n->dev, vq, head, 0);
+ */
 /* And here's the combo meal deal.  Supersize me! */
 void vhost_add_used_and_signal(struct vhost_dev *dev,
 			       struct vhost_virtqueue *vq,
@@ -2838,6 +3362,11 @@ void vhost_add_used_and_signal(struct vhost_dev *dev,
 }
 EXPORT_SYMBOL_GPL(vhost_add_used_and_signal);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|376| <<vhost_zerocopy_signal_used>> vhost_add_used_and_signal_n(vq->dev, vq,
+ *   - drivers/vhost/net.c|460| <<vhost_net_signal_used>> vhost_add_used_and_signal_n(dev, vq, vq->heads, nvq->done_idx);
+ */
 /* multi-buffer version of vhost_add_used_and_signal */
 void vhost_add_used_and_signal_n(struct vhost_dev *dev,
 				 struct vhost_virtqueue *vq,
@@ -2848,6 +3377,13 @@ void vhost_add_used_and_signal_n(struct vhost_dev *dev,
 }
 EXPORT_SYMBOL_GPL(vhost_add_used_and_signal_n);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|515| <<vhost_net_busy_poll_try_queue>> if (!vhost_vq_avail_empty(&net->dev, vq)) {
+ *   - drivers/vhost/net.c|557| <<vhost_net_busy_poll>> !vhost_vq_avail_empty(&net->dev, rvq)) ||
+ *   - drivers/vhost/net.c|558| <<vhost_net_busy_poll>> !vhost_vq_avail_empty(&net->dev, tvq))
+ *   - drivers/vhost/net.c|657| <<tx_can_batch>> !vhost_vq_avail_empty(vq->dev, vq);
+ */
 /* return true if we're sure that avaiable ring is empty */
 bool vhost_vq_avail_empty(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 {
@@ -2863,6 +3399,20 @@ bool vhost_vq_avail_empty(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(vhost_vq_avail_empty);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|517| <<vhost_net_busy_poll_try_queue>> } else if (unlikely(vhost_enable_notify(&net->dev, vq))) {
+ *   - drivers/vhost/net.c|569| <<vhost_net_busy_poll>> vhost_enable_notify(&net->dev, rvq);
+ *   - drivers/vhost/net.c|774| <<handle_tx_copy>> } else if (unlikely(vhost_enable_notify(&net->dev,
+ *   - drivers/vhost/net.c|868| <<handle_tx_zerocopy>> } else if (unlikely(vhost_enable_notify(&net->dev, vq))) {
+ *   - drivers/vhost/net.c|1150| <<handle_rx>> } else if (unlikely(vhost_enable_notify(&net->dev, vq))) {
+ *   - drivers/vhost/scsi.c|489| <<vhost_scsi_do_evt_work>> if (vhost_enable_notify(&vs->dev, vq))
+ *   - drivers/vhost/scsi.c|979| <<vhost_scsi_get_desc>> if (unlikely(vhost_enable_notify(&vs->dev, vq))) {
+ *   - drivers/vhost/test.c|70| <<handle_vq>> if (unlikely(vhost_enable_notify(&n->dev, vq))) {
+ *   - drivers/vhost/vsock.c|123| <<vhost_transport_do_send_pkt>> vhost_enable_notify(&vsock->dev, vq);
+ *   - drivers/vhost/vsock.c|139| <<vhost_transport_do_send_pkt>> if (unlikely(vhost_enable_notify(&vsock->dev, vq))) {
+ *   - drivers/vhost/vsock.c|515| <<vhost_vsock_handle_tx_kick>> if (unlikely(vhost_enable_notify(&vsock->dev, vq))) {
+ */
 /* OK, now we need to know about added descriptors. */
 bool vhost_enable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 {
@@ -2879,6 +3429,9 @@ bool vhost_enable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 			return false;
 		}
 	} else {
+		/*
+		 * 只在此处调用
+		 */
 		r = vhost_update_avail_event(vq);
 		if (r) {
 			vq_err(vq, "Failed to update avail event index at %p: %d\n",
@@ -2899,6 +3452,26 @@ bool vhost_enable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(vhost_enable_notify);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|518| <<vhost_net_busy_poll_try_queue>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|541| <<vhost_net_busy_poll>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|776| <<handle_tx_copy>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|869| <<handle_tx_zerocopy>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|954| <<handle_tx>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|1123| <<handle_rx>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|1153| <<handle_rx>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/scsi.c|480| <<vhost_scsi_do_evt_work>> vhost_disable_notify(&vs->dev, vq);
+ *   - drivers/vhost/scsi.c|980| <<vhost_scsi_get_desc>> vhost_disable_notify(&vs->dev, vq);
+ *   - drivers/vhost/scsi.c|1095| <<vhost_scsi_handle_vq>> vhost_disable_notify(&vs->dev, vq);
+ *   - drivers/vhost/scsi.c|1420| <<vhost_scsi_ctl_handle_vq>> vhost_disable_notify(&vs->dev, vq);
+ *   - drivers/vhost/test.c|58| <<handle_vq>> vhost_disable_notify(&n->dev, vq);
+ *   - drivers/vhost/test.c|71| <<handle_vq>> vhost_disable_notify(&n->dev, vq);
+ *   - drivers/vhost/vsock.c|107| <<vhost_transport_do_send_pkt>> vhost_disable_notify(&vsock->dev, vq);
+ *   - drivers/vhost/vsock.c|140| <<vhost_transport_do_send_pkt>> vhost_disable_notify(&vsock->dev, vq);
+ *   - drivers/vhost/vsock.c|497| <<vhost_vsock_handle_tx_kick>> vhost_disable_notify(&vsock->dev, vq);
+ *   - drivers/vhost/vsock.c|516| <<vhost_vsock_handle_tx_kick>> vhost_disable_notify(&vsock->dev, vq);
+ */
 /* We don't need to be notified again. */
 void vhost_disable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 {
@@ -2908,6 +3481,12 @@ void vhost_disable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 		return;
 	vq->used_flags |= VRING_USED_F_NO_NOTIFY;
 	if (!vhost_has_feature(vq, VIRTIO_RING_F_EVENT_IDX)) {
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2422| <<vhost_vq_init_access>> r = vhost_update_used_flags(vq);
+		 *   - drivers/vhost/vhost.c|2929| <<vhost_enable_notify>> r = vhost_update_used_flags(vq);
+		 *   - drivers/vhost/vhost.c|2965| <<vhost_disable_notify>> r = vhost_update_used_flags(vq);
+		 */
 		r = vhost_update_used_flags(vq);
 		if (r)
 			vq_err(vq, "Failed to disable notification at %p: %d\n",
@@ -2916,6 +3495,10 @@ void vhost_disable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(vhost_disable_notify);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|1653| <<vhost_iotlb_miss>> node = vhost_new_msg(vq, v2 ? VHOST_IOTLB_MSG_V2 : VHOST_IOTLB_MSG);
+ */
 /* Create a new message. */
 struct vhost_msg_node *vhost_new_msg(struct vhost_virtqueue *vq, int type)
 {
diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h
index bb75a292d..0cee2cc4b 100644
--- a/drivers/vhost/vhost.h
+++ b/drivers/vhost/vhost.h
@@ -122,7 +122,24 @@ struct vhost_virtqueue {
 	bool signalled_used_valid;
 
 	/* Log writes to used structure. */
+	/*
+	 * 在以下使用vhost_virtqueue->log_used:
+	 *   - drivers/vhost/vhost.c|461| <<vhost_vq_reset>> vq->log_used = false;
+	 *   - drivers/vhost/vhost.c|1879| <<vq_log_access_ok>> vq_log_used_access_ok(vq, log_base, vq->log_used, vq->log_addr);
+	 *   - drivers/vhost/vhost.c|2024| <<vhost_vring_set_addr>> vq->log_used = !!(a.flags & (0x1 << VHOST_VRING_F_LOG));
+	 *   - drivers/vhost/vhost.c|2591| <<vhost_update_used_flags>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|2612| <<vhost_update_avail_event>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3035| <<__vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3082| <<vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 */
 	bool log_used;
+	/*
+	 * 在以下使用vhost_virtqueue->log_addr:
+	 *   - drivers/vhost/vhost.c|373| <<vhost_vq_reset>> vq->log_addr = -1ull;
+	 *   - drivers/vhost/vhost.c|1780| <<vq_log_access_ok>> vq_log_used_access_ok(vq, log_base, vq->log_used, vq->log_addr);
+	 *   - drivers/vhost/vhost.c|1928| <<vhost_vring_set_addr>> vq->log_addr = a.log_guest_addr;
+	 *   - drivers/vhost/vhost.c|2312| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+	 */
 	u64 log_addr;
 
 	struct iovec iov[UIO_MAXIOV];
@@ -136,8 +153,36 @@ struct vhost_virtqueue {
 	u64 acked_features;
 	u64 acked_backend_features;
 	/* Log write descriptors */
+	/*
+	 * 在以下使用vhost_virtqueue->log_base:
+	 *   - drivers/vhost/vhost.c|466| <<vhost_vq_reset>> vq->log_base = NULL;
+	 *   - drivers/vhost/vhost.c|1223| <<memory_access_ok>> ok = vq_memory_access_ok(d->vqs[i]->log_base, umem, log);
+	 *   - drivers/vhost/vhost.c|1886| <<vhost_vq_access_ok>> if (!vq_log_access_ok(vq, vq->log_base))
+	 *   - drivers/vhost/vhost.c|2018| <<vhost_vring_set_addr>> if (!vq_log_used_access_ok(vq, vq->log_base, a.flags & (0x1 << VHOST_VRING_F_LOG), a.log_guest_addr))
+	 *   - drivers/vhost/vhost.c|2269| <<vhost_dev_ioctl(VHOST_SET_LOG_BASE)>> vq->log_base = base;
+	 *   - drivers/vhost/vhost.c|2384| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+	 *   - drivers/vhost/vhost.c|2422| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+	 *   - drivers/vhost/vhost.c|2474| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+	 */
 	void __user *log_base;
+	/*
+	 * 在以下使用vhost_virtqueue->log:
+	 *   - drivers/vhost/vhost.c|652| <<vhost_dev_init>> vq->log = NULL;
+	 *   - drivers/vhost/net.c|1180| <<handle_rx>> vq_log = unlikely(vhost_has_feature(vq, VHOST_F_LOG_ALL)) ? vq->log : NULL;
+	 *   - drivers/vhost/vhost.c|543| <<vhost_vq_free_iovecs>> kfree(vq->log);
+	 *   - drivers/vhost/vhost.c|544| <<vhost_vq_free_iovecs>> vq->log = NULL;
+	 *   - drivers/vhost/vhost.c|560| <<vhost_dev_alloc_iovecs>> vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log), GFP_KERNEL);
+	 *   - drivers/vhost/vhost.c|564| <<vhost_dev_alloc_iovecs>> if (!vq->indirect || !vq->log || !vq->heads)
+	 *
+	 * 像是一个临时数组
+	 */
 	struct vhost_log *log;
+	/*
+	 * 在以下使用vhost_virtqueue->log_iov[64]:
+	 *   - drivers/vhost/vhost.c|2485| <<log_used>> struct iovec *iov = vq->log_iov;
+	 *
+	 * 那似乎和vhost_virtqueue->log_base还有vhost_virtqueue->log没有关系
+	 */
 	struct iovec log_iov[64];
 
 	/* Ring endianness. Defaults to legacy native endianness.
@@ -171,6 +216,12 @@ struct vhost_dev {
 	struct list_head read_list;
 	struct list_head pending_list;
 	wait_queue_head_t wait;
+	/*
+	 * 在以下使用vhost_dev->iov_limit:
+	 *   - drivers/vhost/vhost.c|639| <<vhost_dev_init>> dev->iov_limit = iov_limit;
+	 *   - drivers/vhost/vhost.c|560| <<vhost_dev_alloc_iovecs>> vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log), GFP_KERNEL);
+	 *   - drivers/vhost/vhost.c|562| <<vhost_dev_alloc_iovecs>> vq->heads = kmalloc_array(dev->iov_limit, sizeof(*vq->heads), GFP_KERNEL);
+	 */
 	int iov_limit;
 	int weight;
 	int byte_weight;
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index 98374ed7c..7b08e554d 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -465,6 +465,22 @@ static unsigned int vring_unmap_one_split(const struct vring_virtqueue *vq,
 
 	flags = extra[i].flags;
 
+	/*
+	 * 在以下使用VRING_DESC_F_WRITE:
+	 *   - drivers/vhost/vhost.c|2898| <<get_indirect>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+	 *   - drivers/vhost/vhost.c|3044| <<vhost_get_vq_desc>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+	 *   - drivers/vhost/vringh.c|373| <<__vringh_iov>> if (desc.flags & cpu_to_vringh16(vrh, VRING_DESC_F_WRITE))
+	 *   - drivers/virtio/virtio_ring.c|456| <<vring_unmap_one_split_indirect>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|475| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|484| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|670| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i, addr, sg->length,
+	 *                                             VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+	 *   - drivers/virtio/virtio_ring.c|1266| <<vring_unmap_extra_packed>> dma_unmap_single(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|1274| <<vring_unmap_extra_packed>> dma_unmap_page(vring_dma_dev(vq),... (flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|1292| <<vring_unmap_desc_packed>> dma_unmap_page(vring_dma_dev(vq), ... (flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|1350| <<virtqueue_add_indirect_packed>> desc[i].flags = cpu_to_le16(n < out_sgs ? 0 : VRING_DESC_F_WRITE);
+	 *   - drivers/virtio/virtio_ring.c|1504| <<virtqueue_add_packed>> flags = cpu_to_le16(... (n < out_sgs ? 0 : VRING_DESC_F_WRITE));
+	 */
 	if (flags & VRING_DESC_F_INDIRECT) {
 		if (!vq->use_dma_api)
 			goto out;
@@ -541,6 +557,36 @@ static inline unsigned int virtqueue_add_desc_split(struct virtqueue *vq,
 	return next;
 }
 
+/*
+ * 关于virtio-scsi下发的request
+ *
+ * 在scsi_alloc_sgtables()中把request给map到scsi_cmnd上的
+ *
+ * struct scsi_cmnd *cmd:
+ * -> struct scsi_data_buffer sdb;
+ *    -> struct sg_table table;
+ *       -> struct scatterlist *sgl;        // the list
+ *       -> unsigned int nents;             // number of mapped entries
+ *       -> unsigned int orig_nents;        // original size of list
+ *    -> unsigned length;
+ *
+ * 假设没有prot
+ *
+ * struct scatterlist *sgs[6].
+ *
+ * 如果是READ的
+ * sgs[0] : request header
+ * sgs[1] : response header
+ * sgs[2] : sc->sdb.table.sgl (in buffer)
+ *
+ * 如果是WRITE的
+ * sgs[0] : request header
+ * sgs[1] : sc->sdb.table.sgl (out buffer)
+ * sgs[2] : response header
+ *
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|2210| <<virtqueue_add>> virtqueue_add_split(_vq, sgs, total_sg, out_sgs, in_sgs, data, ctx, gfp);
+ */
 static inline int virtqueue_add_split(struct virtqueue *_vq,
 				      struct scatterlist *sgs[],
 				      unsigned int total_sg,
@@ -634,6 +680,22 @@ static inline int virtqueue_add_split(struct virtqueue *_vq,
 			/* Note that we trust indirect descriptor
 			 * table since it use stream DMA mapping.
 			 */
+			/*
+			 * 在以下使用VRING_DESC_F_WRITE:
+			 *   - drivers/vhost/vhost.c|2898| <<get_indirect>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+			 *   - drivers/vhost/vhost.c|3044| <<vhost_get_vq_desc>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+			 *   - drivers/vhost/vringh.c|373| <<__vringh_iov>> if (desc.flags & cpu_to_vringh16(vrh, VRING_DESC_F_WRITE))
+			 *   - drivers/virtio/virtio_ring.c|456| <<vring_unmap_one_split_indirect>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|475| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|484| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|670| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i, addr, sg->length,
+			 *                                             VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+			 *   - drivers/virtio/virtio_ring.c|1266| <<vring_unmap_extra_packed>> dma_unmap_single(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|1274| <<vring_unmap_extra_packed>> dma_unmap_page(vring_dma_dev(vq),... (flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|1292| <<vring_unmap_desc_packed>> dma_unmap_page(vring_dma_dev(vq), ... (flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|1350| <<virtqueue_add_indirect_packed>> desc[i].flags = cpu_to_le16(n < out_sgs ? 0 : VRING_DESC_F_WRITE);
+			 *   - drivers/virtio/virtio_ring.c|1504| <<virtqueue_add_packed>> flags = cpu_to_le16(... (n < out_sgs ? 0 : VRING_DESC_F_WRITE));
+			 */
 			i = virtqueue_add_desc_split(_vq, desc, i, addr,
 						     sg->length,
 						     VRING_DESC_F_NEXT |
@@ -2194,6 +2256,13 @@ static int virtqueue_enable_after_reset(struct virtqueue *_vq)
  * Generic functions and exported symbols.
  */
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|2244| <<virtqueue_add_sgs>> return virtqueue_add(_vq, sgs, total_sg, out_sgs, in_sgs, data, NULL, gfp);
+ *   - drivers/virtio/virtio_ring.c|2267| <<virtqueue_add_outbuf>> return virtqueue_add(vq, &sg, num, 1, 0, data, NULL, gfp);
+ *   - drivers/virtio/virtio_ring.c|2289| <<virtqueue_add_inbuf>> return virtqueue_add(vq, &sg, num, 0, 1, data, NULL, gfp);
+ *   - drivers/virtio/virtio_ring.c|2313| <<virtqueue_add_inbuf_ctx>> return virtqueue_add(vq, &sg, num, 0, 1, data, ctx, gfp);
+ */
 static inline int virtqueue_add(struct virtqueue *_vq,
 				struct scatterlist *sgs[],
 				unsigned int total_sg,
@@ -2225,6 +2294,36 @@ static inline int virtqueue_add(struct virtqueue *_vq,
  *
  * Returns zero or a negative error (ie. ENOSPC, ENOMEM, EIO).
  */
+/*
+ * called by:
+ *   - arch/um/drivers/virt-pci.c|135| <<um_pci_send_cmd>> ret = virtqueue_add_sgs(dev->cmd_vq, sgs_list,
+ *   - drivers/block/virtio_blk.c|158| <<virtblk_add_req>> return virtqueue_add_sgs(vq, sgs, num_out, num_in, vbr, GFP_ATOMIC); 
+ *   - drivers/crypto/virtio/virtio_crypto_akcipher_algs.c|272| <<__virtio_crypto_akcipher_do_req>> ret = virtqueue_add_sgs(data_vq->vq, sgs, num_out, num_in, vc_req, GFP_ATOMIC);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|59| <<virtio_crypto_ctrl_vq_request>> err = virtqueue_add_sgs(vcrypto->ctrl_vq, sgs, out_sgs, in_sgs, vc_ctrl_req, GFP_ATOMIC);
+ *   - drivers/crypto/virtio/virtio_crypto_skcipher_algs.c|449| <<__virtio_crypto_skcipher_do_req>> err = virtqueue_add_sgs(data_vq->vq, sgs, num_out,
+ *   - drivers/firmware/arm_scmi/transports/virtio.c|523| <<virtio_send_message>> rc = virtqueue_add_sgs(vioch->vqueue, sgs, 1, 1, msg, GFP_ATOMIC);
+ *   - drivers/gpio/gpio-virtio.c|93| <<_virtio_gpio_req>> ret = virtqueue_add_sgs(vgpio->request_vq, sgs, 1, 1, line, GFP_KERNEL);
+ *   - drivers/gpio/gpio-virtio.c|222| <<virtio_gpio_irq_prepare>> ret = virtqueue_add_sgs(vgpio->event_vq, sgs, 1, 1, irq_line, GFP_ATOMIC);
+ *   - drivers/gpu/drm/virtio/virtgpu_vq.c|357| <<virtio_gpu_queue_ctrl_sgs>> ret = virtqueue_add_sgs(vq, sgs, outcnt, incnt, vbuf, GFP_ATOMIC);
+ *   - drivers/gpu/drm/virtio/virtgpu_vq.c|466| <<virtio_gpu_queue_cursor>> ret = virtqueue_add_sgs(vq, sgs, outcnt, 0, vbuf, GFP_ATOMIC);
+ *   - drivers/i2c/busses/i2c-virtio.c|100| <<virtio_i2c_prepare_reqs>> if (virtqueue_add_sgs(vq, sgs, outcnt, incnt, &reqs[i], GFP_KERNEL)) {
+ *   - drivers/iommu/virtio-iommu.c|247| <<__viommu_add_req>> ret = virtqueue_add_sgs(vq, sg, 1, 1, req, GFP_ATOMIC);
+ *   - drivers/iommu/virtio-iommu.c|251| <<__viommu_add_req>> ret = virtqueue_add_sgs(vq, sg, 1, 1, req, GFP_ATOMIC);
+ *   - drivers/net/virtio_net.c|3271| <<virtnet_send_command_reply>> ret = virtqueue_add_sgs(vi->cvq, sgs, out_num, in_num, vi, GFP_ATOMIC);
+ *   - drivers/nvdimm/nd_virtio.c|78| <<virtio_pmem_flush>> while ((err = virtqueue_add_sgs(vpmem->req_vq, sgs, 1, 1, req_data,
+ *   - drivers/scsi/virtio_scsi.c|471| <<__virtscsi_add_cmd>> return virtqueue_add_sgs(vq, sgs, out_num, in_num, cmd, GFP_ATOMIC);
+ *   - drivers/virtio/virtio_mem.c|1405| <<virtio_mem_send_request>> rc = virtqueue_add_sgs(vm->vq, sgs, 1, 1, vm, GFP_KERNEL);
+ *   - drivers/virtio/virtio_pci_modern.c|90| <<virtqueue_exec_admin_cmd>> ret = virtqueue_add_sgs(vq, sgs, out_num, in_num, cmd, GFP_KERNEL);
+ *   - fs/fuse/virtio_fs.c|1434| <<virtio_fs_enqueue_req>> ret = virtqueue_add_sgs(vq, sgs, out_sgs, in_sgs, req, GFP_ATOMIC);
+ *   - net/9p/trans_virtio.c|281| <<p9_virtio_request>> err = virtqueue_add_sgs(chan->vq, sgs, out_sgs, in_sgs, req,
+ *   - net/9p/trans_virtio.c|509| <<p9_virtio_zc_request>> err = virtqueue_add_sgs(chan->vq, sgs, out_sgs, in_sgs, req,
+ *   - net/vmw_vsock/virtio_transport.c|143| <<virtio_transport_send_skb>> ret = virtqueue_add_sgs(vq, sgs, out_sg, in_sg, skb, gfp);
+ *   - net/vmw_vsock/virtio_transport.c|326| <<virtio_vsock_rx_fill>> ret = virtqueue_add_sgs(vq, &p, 0, 1, skb, GFP_KERNEL);
+ *   - sound/virtio/virtio_card.c|41| <<virtsnd_event_send>> if (virtqueue_add_sgs(vqueue, psgs, 0, 1, event, gfp) || !notify)
+ *   - sound/virtio/virtio_ctl_msg.c|151| <<virtsnd_ctl_msg_send>> rc = virtqueue_add_sgs(queue->vqueue, psgs, nouts, nins, msg,
+ *   - sound/virtio/virtio_pcm_msg.c|234| <<virtsnd_pcm_msg_send>> rc = virtqueue_add_sgs(vqueue, psgs, 2, 1, msg,
+ *   - sound/virtio/virtio_pcm_msg.c|237| <<virtsnd_pcm_msg_send>> rc = virtqueue_add_sgs(vqueue, psgs, 1, 2, msg,
+ */
 int virtqueue_add_sgs(struct virtqueue *_vq,
 		      struct scatterlist *sgs[],
 		      unsigned int out_sgs,
@@ -2241,6 +2340,13 @@ int virtqueue_add_sgs(struct virtqueue *_vq,
 		for (sg = sgs[i]; sg; sg = sg_next(sg))
 			total_sg++;
 	}
+	/*
+	 * called by:
+	 *   - drivers/virtio/virtio_ring.c|2244| <<virtqueue_add_sgs>> return virtqueue_add(_vq, sgs, total_sg, out_sgs, in_sgs, data, NULL, gfp);
+	 *   - drivers/virtio/virtio_ring.c|2267| <<virtqueue_add_outbuf>> return virtqueue_add(vq, &sg, num, 1, 0, data, NULL, gfp);
+	 *   - drivers/virtio/virtio_ring.c|2289| <<virtqueue_add_inbuf>> return virtqueue_add(vq, &sg, num, 0, 1, data, NULL, gfp);
+	 *   - drivers/virtio/virtio_ring.c|2313| <<virtqueue_add_inbuf_ctx>> return virtqueue_add(vq, &sg, num, 0, 1, data, ctx, gfp);
+	 */
 	return virtqueue_add(_vq, sgs, total_sg, out_sgs, in_sgs,
 			     data, NULL, gfp);
 }
diff --git a/include/linux/blk-mq.h b/include/linux/blk-mq.h
index 4fecf46ef..a7ba3ad25 100644
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@ -1167,6 +1167,24 @@ static inline unsigned short blk_rq_nr_discard_segments(struct request *rq)
 
 int __blk_rq_map_sg(struct request_queue *q, struct request *rq,
 		struct scatterlist *sglist, struct scatterlist **last_sg);
+/*
+ * called by:
+ *   - block/bsg-lib.c|222| <<bsg_map_buffer>> buf->sg_cnt = blk_rq_map_sg(req->q, req, buf->sg_list);
+ *   - drivers/block/mtip32xx/mtip32xx.c|2059| <<mtip_hw_submit_io>> nents = blk_rq_map_sg(hctx->queue, rq, command->sg);
+ *   - drivers/block/rnbd/rnbd-clt.c|1013| <<rnbd_client_xfer_request>> sg_cnt = blk_rq_map_sg(dev->queue, rq, iu->sgt.sgl);
+ *   - drivers/block/sunvdc.c|488| <<__send_request>> nsg = blk_rq_map_sg(req->q, req, sg);
+ *   - drivers/block/virtio_blk.c|230| <<virtblk_map_data>> return blk_rq_map_sg(hctx->queue, req, vbr->sg_table.sgl);
+ *   - drivers/block/xen-blkfront.c|754| <<blkif_queue_rw_req>> num_sg = blk_rq_map_sg(req->q, req, rinfo->shadow[id].sg);
+ *   - drivers/memstick/core/ms_block.c|1907| <<msb_io_work>> blk_rq_map_sg(msb->queue, req, sg);
+ *   - drivers/memstick/core/mspro_block.c|630| <<mspro_block_issue_req>> msb->seg_count = blk_rq_map_sg(msb->block_req->q,
+ *   - drivers/mmc/core/queue.c|526| <<mmc_queue_map_sg>> return blk_rq_map_sg(mq->queue, req, mqrq->sg);
+ *   - drivers/mtd/ubi/block.c|202| <<ubiblock_read>> blk_rq_map_sg(req->q, req, pdu->usgl.sg);
+ *   - drivers/nvme/host/apple.c|528| <<apple_nvme_map_data>> iod->nents = blk_rq_map_sg(req->q, req, iod->sg);
+ *   - drivers/nvme/host/fc.c|2614| <<nvme_fc_map_data>> op->nents = blk_rq_map_sg(rq->q, rq, freq->sg_table.sgl);
+ *   - drivers/nvme/host/pci.c|798| <<nvme_map_data>> iod->sgt.orig_nents = blk_rq_map_sg(req->q, req, iod->sgt.sgl);
+ *   - drivers/nvme/host/rdma.c|1485| <<nvme_rdma_dma_map_req>> req->data_sgl.nents = blk_rq_map_sg(rq->q, rq,
+ *   - drivers/nvme/target/loop.c|165| <<nvme_loop_queue_rq>> iod->req.sg_cnt = blk_rq_map_sg(req->q, req, iod->sg_table.sgl);
+ */
 static inline int blk_rq_map_sg(struct request_queue *q, struct request *rq,
 		struct scatterlist *sglist)
 {
diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
index 8ecfb9404..9cef67514 100644
--- a/include/scsi/scsi_cmnd.h
+++ b/include/scsi/scsi_cmnd.h
@@ -180,6 +180,17 @@ static inline void scsi_dma_unmap(struct scsi_cmnd *cmd) { }
 
 static inline unsigned scsi_sg_count(struct scsi_cmnd *cmd)
 {
+	/*
+	 * 关于 cmd->sdb.table.sgl = sg;
+	 *
+	 * struct scsi_cmnd *cmd:
+	 * -> struct scsi_data_buffer sdb;
+	 *    -> struct sg_table table;
+	 *       -> struct scatterlist *sgl;        // the list
+	 *       -> unsigned int nents;             // number of mapped entries
+	 *       -> unsigned int orig_nents;        // original size of list
+	 *    -> unsigned length;
+	 */
 	return cmd->sdb.table.nents;
 }
 
diff --git a/include/uapi/linux/vhost_types.h b/include/uapi/linux/vhost_types.h
index d7656908f..dbe5231da 100644
--- a/include/uapi/linux/vhost_types.h
+++ b/include/uapi/linux/vhost_types.h
@@ -164,6 +164,20 @@ struct vhost_vdpa_iova_range {
 };
 
 /* Feature bits */
+/*
+ * 在以下使用VHOST_F_LOG_ALL:
+ *   - drivers/vhost/vhost.h|301| <<global>> (1ULL << VHOST_F_LOG_ALL) |
+ *   - drivers/vhost/net.c|1188| <<handle_rx>> vq_log = unlikely(vhost_has_feature(vq, VHOST_F_LOG_ALL)) ?
+ *   - drivers/vhost/net.c|1693| <<vhost_net_set_features>> if ((features & (1 << VHOST_F_LOG_ALL)) &&
+ *   - drivers/vhost/scsi.c|1946| <<vhost_scsi_set_features>> if ((features & (1 << VHOST_F_LOG_ALL)) &&
+ *   - drivers/vhost/test.c|246| <<vhost_test_set_features>> if ((features & (1 << VHOST_F_LOG_ALL)) &&
+ *   - drivers/vhost/vhost.c|1220| <<memory_access_ok>> log = log_all || vhost_has_feature(d->vqs[i], VHOST_F_LOG_ALL);
+ *   - drivers/vhost/vhost.c|1878| <<vq_log_access_ok>> vhost_has_feature(vq, VHOST_F_LOG_ALL)) &&
+ *   - drivers/vhost/vsock.c|806| <<vhost_vsock_set_features>> if ((features & (1 << VHOST_F_LOG_ALL)) &&
+ *
+ * VHOST_F_LOG_ALL用来Log all write descriptors. Can be changed while device is active.
+ * 是给dev->feature用的
+ */
 /* Log all write descriptors. Can be changed while device is active. */
 #define VHOST_F_LOG_ALL 26
 /* vhost-net should add virtio_net_hdr for RX, and strip for TX packets. */
diff --git a/include/uapi/linux/virtio_ring.h b/include/uapi/linux/virtio_ring.h
index f8c20d3de..5538949d8 100644
--- a/include/uapi/linux/virtio_ring.h
+++ b/include/uapi/linux/virtio_ring.h
@@ -37,6 +37,22 @@
 #include <linux/types.h>
 #include <linux/virtio_types.h>
 
+/*
+ * 在以下使用VRING_DESC_F_WRITE:
+ *   - drivers/vhost/vhost.c|2898| <<get_indirect>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+ *   - drivers/vhost/vhost.c|3044| <<vhost_get_vq_desc>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+ *   - drivers/vhost/vringh.c|373| <<__vringh_iov>> if (desc.flags & cpu_to_vringh16(vrh, VRING_DESC_F_WRITE))
+ *   - drivers/virtio/virtio_ring.c|456| <<vring_unmap_one_split_indirect>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|475| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|484| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|670| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i, addr, sg->length,
+ *                                             VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+ *   - drivers/virtio/virtio_ring.c|1266| <<vring_unmap_extra_packed>> dma_unmap_single(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|1274| <<vring_unmap_extra_packed>> dma_unmap_page(vring_dma_dev(vq),... (flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|1292| <<vring_unmap_desc_packed>> dma_unmap_page(vring_dma_dev(vq), ... (flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|1350| <<virtqueue_add_indirect_packed>> desc[i].flags = cpu_to_le16(n < out_sgs ? 0 : VRING_DESC_F_WRITE);
+ *   - drivers/virtio/virtio_ring.c|1504| <<virtqueue_add_packed>> flags = cpu_to_le16(... (n < out_sgs ? 0 : VRING_DESC_F_WRITE));
+ */
 /* This marks a buffer as continuing via the next field. */
 #define VRING_DESC_F_NEXT	1
 /* This marks a buffer as write-only (otherwise read-only). */
-- 
2.39.5 (Apple Git-154)

