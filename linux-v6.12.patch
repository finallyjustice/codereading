From bf9bb5b7783eb40a9a1a64d972b60245d35ef159 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Fri, 13 Dec 2024 10:22:27 -0800
Subject: [PATCH 1/1] linux-v6.12

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/kvm/lapic.c                   |   18 +
 arch/x86/kvm/x86.c                     |   26 +
 block/blk-merge.c                      |    9 +
 drivers/pci/setup-res.c                |   19 +
 drivers/scsi/scsi_lib.c                |   49 +
 drivers/scsi/sd.c                      |    4 +
 drivers/scsi/virtio_scsi.c             |  396 ++++++
 drivers/target/target_core_transport.c |   56 +
 drivers/vhost/iotlb.c                  |    7 +
 drivers/vhost/net.c                    |  107 ++
 drivers/vhost/scsi.c                   | 1736 ++++++++++++++++++++++++
 drivers/vhost/vhost.c                  |  966 +++++++++++++
 drivers/vhost/vhost.h                  |  174 +++
 drivers/vhost/vsock.c                  |   10 +
 drivers/virtio/virtio_ring.c           |  278 ++++
 include/linux/blk-mq.h                 |   18 +
 include/linux/virtio_config.h          |   36 +
 include/scsi/scsi_cmnd.h               |   11 +
 include/uapi/linux/vhost_types.h       |   14 +
 include/uapi/linux/virtio_ring.h       |   16 +
 include/uapi/linux/virtio_scsi.h       |    7 +
 lib/iov_iter.c                         |   28 +
 22 files changed, 3985 insertions(+)

diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 95c6beb8c..7bc949c12 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -535,6 +535,10 @@ static inline void kvm_apic_set_dfr(struct kvm_lapic *apic, u32 val)
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|2608| <<kvm_lapic_set_base>> kvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);
+ */
 static inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u32 id)
 {
 	u32 ldr = kvm_apic_calc_x2apic_ldr(id);
@@ -2577,6 +2581,12 @@ u64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)
 	return (tpr & 0xf0) >> 4;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|2738| <<kvm_lapic_reset>> kvm_lapic_set_base(vcpu, msr_val);
+ *   - arch/x86/kvm/lapic.c|3079| <<kvm_apic_set_state>> kvm_lapic_set_base(vcpu, vcpu->arch.apic_base);
+ *   - arch/x86/kvm/x86.c|697| <<kvm_set_apic_base>> kvm_lapic_set_base(vcpu, msr_info->data);
+ */
 void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)
 {
 	u64 old_value = vcpu->arch.apic_base;
@@ -2723,6 +2733,10 @@ void kvm_inhibit_apic_access_page(struct kvm_vcpu *vcpu)
 	kvm_vcpu_srcu_read_lock(vcpu);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|12413| <<kvm_vcpu_reset>> kvm_lapic_reset(vcpu, init_event);
+ */
 void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
@@ -3055,6 +3069,10 @@ static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|5120| <<kvm_vcpu_ioctl_get_lapic>> return kvm_apic_get_state(vcpu, s);
+ */
 int kvm_apic_get_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 {
 	memcpy(s->regs, vcpu->arch.apic->regs, sizeof(*s));
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 83fe0a781..679de04fb 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -678,6 +678,11 @@ enum lapic_mode kvm_get_apic_mode(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_get_apic_mode);
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|3893| <<kvm_set_msr_common(MSR_IA32_APICBASE)>> return kvm_set_apic_base(vcpu, msr_info);
+ *   - arch/x86/kvm/x86.c|11900| <<__set_sregs_common>> if (kvm_set_apic_base(vcpu, &apic_base_msr))
+ */
 int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 {
 	enum lapic_mode old_mode = kvm_get_apic_mode(vcpu);
@@ -2511,6 +2516,10 @@ static inline bool gtod_is_based_on_tsc(int mode)
 }
 #endif
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|2713| <<__kvm_synchronize_tsc>> kvm_track_tsc_matching(vcpu, !matched);
+ */
 static void kvm_track_tsc_matching(struct kvm_vcpu *vcpu, bool new_generation)
 {
 #ifdef CONFIG_X86_64
@@ -2666,6 +2675,11 @@ static inline bool kvm_check_tsc_unstable(void)
  * offset for the vcpu and tracks the TSC matching generation that the vcpu
  * participates in.
  */
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|2782| <<kvm_synchronize_tsc>> __kvm_synchronize_tsc(vcpu, offset, data, ns, matched);
+ *   - arch/x86/kvm/x86.c|5759| <<kvm_arch_tsc_set_attr>> __kvm_synchronize_tsc(vcpu, offset, tsc, ns, matched);
+ */
 static void __kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 offset, u64 tsc,
 				  u64 ns, bool matched)
 {
@@ -2713,6 +2727,11 @@ static void __kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 offset, u64 tsc,
 	kvm_track_tsc_matching(vcpu, !matched);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|3946| <<kvm_set_msr_common>> kvm_synchronize_tsc(vcpu, &data);
+ *   - arch/x86/kvm/x86.c|12350| <<kvm_arch_vcpu_postcreate>> kvm_synchronize_tsc(vcpu, NULL);
+ */
 static void kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 *user_value)
 {
 	u64 data = user_value ? *user_value : 0;
@@ -12385,6 +12404,13 @@ void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
 	kvfree(vcpu->arch.cpuid_entries);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|3374| <<kvm_apic_accept_events>> kvm_vcpu_reset(vcpu, true);
+ *   - arch/x86/kvm/svm/svm.c|2225| <<shutdown_interception>> kvm_vcpu_reset(vcpu, true);
+ *   - arch/x86/kvm/x86.c|10865| <<vcpu_enter_guest(KVM_REQ_UPDATE_PROTECTED_GUEST_STATE)>> kvm_vcpu_reset(vcpu, true);
+ *   - arch/x86/kvm/x86.c|12321| <<kvm_arch_vcpu_create>> kvm_vcpu_reset(vcpu, false);
+ */
 void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
 {
 	struct kvm_cpuid_entry2 *cpuid_0x1;
diff --git a/block/blk-merge.c b/block/blk-merge.c
index ad763ec31..49276ae1e 100644
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@ -573,6 +573,15 @@ static int __blk_bios_map_sg(struct request_queue *q, struct bio *bio,
  * map a request to scatterlist, return number of sg entries setup. Caller
  * must make sure sg can hold rq->nr_phys_segments entries
  */
+/*
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1140| <<scsi_alloc_sgtables>> count = __blk_rq_map_sg(rq->q, rq, cmd->sdb.table.sgl, &last_sg);
+ *   - include/linux/blk-mq.h|1175| <<blk_rq_map_sg>> return __blk_rq_map_sg(q, rq, sglist, &last_sg);
+ *
+ * 注释:
+ * map a request to scatterlist, return number of sg entries setup. Caller
+ * must make sure sg can hold rq->nr_phys_segments entries
+ */
 int __blk_rq_map_sg(struct request_queue *q, struct request *rq,
 		struct scatterlist *sglist, struct scatterlist **last_sg)
 {
diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c
index c6d933ddf..53149ec4a 100644
--- a/drivers/pci/setup-res.c
+++ b/drivers/pci/setup-res.c
@@ -198,6 +198,10 @@ resource_size_t __weak pcibios_retrieve_fw_addr(struct pci_dev *dev, int idx)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/pci/setup-res.c|355| <<pci_assign_resource>> ret = pci_revert_fw_address(res, dev, resno, size);
+ */
 static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
 		int resno, resource_size_t size)
 {
@@ -324,6 +328,21 @@ static int _pci_assign_resource(struct pci_dev *dev, int resno,
 	return ret;
 }
 
+/*
+ * called by:
+ *   - drivers/bcma/driver_pci_host.c|571| <<bcma_core_pci_fixup_addresses>> err = pci_assign_resource(dev, pos);
+ *   - drivers/bus/mhi/host/pci_generic.c|910| <<mhi_pci_claim>> err = pci_assign_resource(pdev, bar_num);
+ *   - drivers/char/agp/efficeon-agp.c|389| <<agp_efficeon_probe>> if (pci_assign_resource(pdev, 0)) {
+ *   - drivers/char/agp/intel-agp.c|778| <<agp_intel_probe>> if (pci_assign_resource(pdev, 0)) {
+ *   - drivers/mtd/maps/l440gx.c|112| <<init_l440gx>> if (pci_assign_resource(pm_dev, PIIXE_IOBASE_RESOURCE) != 0) {
+ *   - drivers/net/wireless/ath/ath11k/pci.c|514| <<ath11k_pci_claim>> ret = pci_assign_resource(pdev, ATH11K_PCI_BAR_NUM);
+ *   - drivers/net/wireless/ath/ath12k/pci.c|857| <<ath12k_pci_claim>> ret = pci_assign_resource(pdev, ATH12K_PCI_BAR_NUM);
+ *   - drivers/net/wireless/intel/iwlwifi/pcie/trans.c|3542| <<iwl_trans_pcie_alloc>> ret = pci_assign_resource(pdev, 0);
+ *   - drivers/parisc/dino.c|636| <<dino_fixup_bus>> WARN_ON(pci_assign_resource(bus->self, i));
+ *   - drivers/pci/rom.c|143| <<pci_map_rom>> if (res->parent == NULL && pci_assign_resource(pdev, PCI_ROM_RESOURCE))
+ *   - drivers/pci/setup-bus.c|251| <<reassign_resources_sorted>> if (pci_assign_resource(add_res->dev, idx))
+ *   - drivers/pci/setup-bus.c|289| <<assign_requested_resources_sorted>> pci_assign_resource(dev_res->dev, idx)) {
+ */
 int pci_assign_resource(struct pci_dev *dev, int resno)
 {
 	struct resource *res = dev->resource + resno;
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index adee6f60c..3a4e53fe8 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -1106,6 +1106,15 @@ static inline bool scsi_cmd_needs_dma_drain(struct scsi_device *sdev,
  * * BLK_STS_RESOURCE - if the failure is retryable
  * * BLK_STS_IOERR    - if the failure is fatal
  */
+/*
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1273| <<scsi_setup_scsi_cmnd>> blk_status_t ret = scsi_alloc_sgtables(cmd);
+ *   - drivers/scsi/sd.c|940| <<sd_setup_unmap_cmnd>> return scsi_alloc_sgtables(cmd);
+ *   - drivers/scsi/sd.c|1025| <<sd_setup_write_same16_cmnd>> return scsi_alloc_sgtables(cmd);
+ *   - drivers/scsi/sd.c|1052| <<sd_setup_write_same10_cmnd>> return scsi_alloc_sgtables(cmd);
+ *   - drivers/scsi/sd.c|1339| <<sd_setup_read_write_cmnd>> ret = scsi_alloc_sgtables(cmd);
+ *   - drivers/scsi/sr.c|366| <<sr_init_command>> ret = scsi_alloc_sgtables(SCpnt);
+ */
 blk_status_t scsi_alloc_sgtables(struct scsi_cmnd *cmd)
 {
 	struct scsi_device *sdev = cmd->device;
@@ -1137,6 +1146,15 @@ blk_status_t scsi_alloc_sgtables(struct scsi_cmnd *cmd)
 	 * Next, walk the list, and fill in the addresses and sizes of
 	 * each segment.
 	 */
+	/*
+	 * called by:
+	 *   - drivers/scsi/scsi_lib.c|1140| <<scsi_alloc_sgtables>> count = __blk_rq_map_sg(rq->q, rq, cmd->sdb.table.sgl, &last_sg);
+	 *   - include/linux/blk-mq.h|1175| <<blk_rq_map_sg>> return __blk_rq_map_sg(q, rq, sglist, &last_sg);
+	 *
+	 * 注释:
+	 * map a request to scatterlist, return number of sg entries setup. Caller
+	 * must make sure sg can hold rq->nr_phys_segments entries
+	 */
 	count = __blk_rq_map_sg(rq->q, rq, cmd->sdb.table.sgl, &last_sg);
 
 	if (blk_rq_bytes(rq) & rq->q->limits.dma_pad_mask) {
@@ -1238,6 +1256,11 @@ static void scsi_cleanup_rq(struct request *rq)
 	}
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_error.c|2465| <<scsi_ioctl_reset>> scsi_init_command(dev, scmd);
+ *   - drivers/scsi/scsi_lib.c|1635| <<scsi_prepare_cmd>> scsi_init_command(sdev, cmd);
+ */
 /* Called before a request is prepared. See also scsi_mq_prep_fn(). */
 void scsi_init_command(struct scsi_device *dev, struct scsi_cmnd *cmd)
 {
@@ -1624,6 +1647,10 @@ static unsigned int scsi_mq_inline_sgl_size(struct Scsi_Host *shost)
 		sizeof(struct scatterlist);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1825| <<scsi_queue_rq>> ret = scsi_prepare_cmd(req);
+ */
 static blk_status_t scsi_prepare_cmd(struct request *req)
 {
 	struct scsi_cmnd *cmd = blk_mq_rq_to_pdu(req);
@@ -1661,7 +1688,19 @@ static blk_status_t scsi_prepare_cmd(struct request *req)
 	else
 		cmd->sc_data_direction = DMA_NONE;
 
+	/*
+	 * struct scatterlist *sg;
+	 */
 	sg = (void *)cmd + sizeof(struct scsi_cmnd) + shost->hostt->cmd_size;
+	/*
+	 * struct scsi_cmnd *cmd:
+	 * -> struct scsi_data_buffer sdb;
+	 *    -> struct sg_table table;
+	 *       -> struct scatterlist *sgl;        // the list
+	 *       -> unsigned int nents;             // number of mapped entries
+	 *       -> unsigned int orig_nents;        // original size of list
+	 *    -> unsigned length;
+	 */
 	cmd->sdb.table.sgl = sg;
 
 	if (scsi_host_get_prot(shost)) {
@@ -1688,6 +1727,9 @@ static blk_status_t scsi_prepare_cmd(struct request *req)
 	/* Usually overridden by the ULP */
 	cmd->allowed = 0;
 	memset(cmd->cmnd, 0, sizeof(cmd->cmnd));
+	/*
+	 * sd_init_command()
+	 */
 	return scsi_cmd_to_driver(cmd)->init_command(cmd);
 }
 
@@ -1787,6 +1829,10 @@ static int scsi_mq_get_rq_budget_token(struct request *req)
 	return cmd->budget_token;
 }
 
+/*
+ * struct blk_mq_ops scsi_mq_ops_no_commit.queue_rq = scsi_queue_rq,
+ * struct blk_mq_ops scsi_mq_ops.queue_rq = scsi_queue_rq,
+ */
 static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
 			 const struct blk_mq_queue_data *bd)
 {
@@ -1821,6 +1867,9 @@ static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
 	if (!scsi_host_queue_ready(q, shost, sdev, cmd))
 		goto out_dec_target_busy;
 
+	/*
+	 * don't call prep for this one
+	 */
 	if (!(req->rq_flags & RQF_DONTPREP)) {
 		ret = scsi_prepare_cmd(req);
 		if (ret != BLK_STS_OK)
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index ca4bc0ac7..f75de4a43 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -1316,6 +1316,10 @@ static blk_status_t sd_setup_atomic_cmnd(struct scsi_cmnd *cmd,
 	return BLK_STS_OK;
 }
 
+/*
+ * 处理REQ_OP_READ和REQ_OP_WRITE:
+ *   - drivers/scsi/sd.c|1457| <<sd_init_command(REQ_OP_READ|REQ_OP_WRITE)>> return sd_setup_read_write_cmnd(cmd);
+ */
 static blk_status_t sd_setup_read_write_cmnd(struct scsi_cmnd *cmd)
 {
 	struct request *rq = scsi_cmd_to_rq(cmd);
diff --git a/drivers/scsi/virtio_scsi.c b/drivers/scsi/virtio_scsi.c
index 8471f38b7..34e225399 100644
--- a/drivers/scsi/virtio_scsi.c
+++ b/drivers/scsi/virtio_scsi.c
@@ -33,7 +33,22 @@
 
 #include "sd.h"
 
+/*
+ * [    0.651247] bug: vring_create_virtqueue() name=control, index=0, num=128
+ * [    0.652706] bug: vring_create_virtqueue() name=event, index=1, num=128
+ * [    0.654241] bug: vring_create_virtqueue() name=request, index=2, num=128
+ * [    0.655833] bug: vring_create_virtqueue() name=request, index=3, num=128
+ * [    0.657375] bug: vring_create_virtqueue() name=request, index=4, num=128
+ * [    0.658933] bug: vring_create_virtqueue() name=request, index=5, num=128
+ */
+
 #define VIRTIO_SCSI_MEMPOOL_SZ 64
+/*
+ * 在以下使用VIRTIO_SCSI_EVENT_LEN:
+ *   - drivers/scsi/virtio_scsi.c|81| <<global>> struct virtio_scsi_event_node event_list[VIRTIO_SCSI_EVENT_LEN];
+ *   - drivers/scsi/virtio_scsi.c|302| <<virtscsi_kick_event_all>> for (i = 0; i < VIRTIO_SCSI_EVENT_LEN; i++) {
+ *   - drivers/scsi/virtio_scsi.c|319| <<virtscsi_cancel_event_work>> for (i = 0; i < VIRTIO_SCSI_EVENT_LEN; i++)
+ */
 #define VIRTIO_SCSI_EVENT_LEN 8
 #define VIRTIO_SCSI_VQ_BASE 2
 
@@ -77,6 +92,12 @@ struct virtio_scsi_vq {
 struct virtio_scsi {
 	struct virtio_device *vdev;
 
+	/*
+	 * 在以下使用virtio_scsi->event_list[VIRTIO_SCSI_EVENT_LEN]:
+	 *   - drivers/scsi/virtio_scsi.c|303| <<virtscsi_kick_event_all>> vscsi->event_list[i].vscsi = vscsi;
+	 *   - drivers/scsi/virtio_scsi.c|304| <<virtscsi_kick_event_all>> virtscsi_kick_event(vscsi, &vscsi->event_list[i]);
+	 *   - drivers/scsi/virtio_scsi.c|320| <<virtscsi_cancel_event_work>> cancel_work_sync(&vscsi->event_list[i].work);
+	 */
 	/* Get some buffers ready for event vq */
 	struct virtio_scsi_event_node event_list[VIRTIO_SCSI_EVENT_LEN];
 
@@ -88,7 +109,24 @@ struct virtio_scsi {
 	/* Protected by event_vq lock */
 	bool stop_events;
 
+	/*
+	 * 在以下使用virtio_scsi->ctrl_vq:
+	 *   - drivers/scsi/virtio_scsi.c|228| <<virtscsi_ctrl_done>> virtscsi_vq_done(vscsi, &vscsi->ctrl_vq, virtscsi_complete_free);
+	 *   - drivers/scsi/virtio_scsi.c|762| <<virtscsi_tmf>> if (virtscsi_add_cmd(&vscsi->ctrl_vq, cmd, sizeof cmd->req.tmf, sizeof cmd->resp.tmf, true) < 0)
+	 *   - drivers/scsi/virtio_scsi.c|1069| <<virtscsi_init>> virtscsi_init_vq(&vscsi->ctrl_vq, vqs[0]);
+	 */
 	struct virtio_scsi_vq ctrl_vq;
+	/*
+	 * 在以下使用virtio_scsi->event_vq:
+	 *   - drivers/scsi/virtio_scsi.c|248| <<virtscsi_kick_event>> spin_lock_irqsave(&vscsi->event_vq.vq_lock, flags);
+	 *   - drivers/scsi/virtio_scsi.c|253| <<virtscsi_kick_event>> err = virtqueue_add_inbuf(vscsi->event_vq.vq, &sg, 1, event_node, GFP_ATOMIC);
+	 *   - drivers/scsi/virtio_scsi.c|256| <<virtscsi_kick_event>> virtqueue_kick(vscsi->event_vq.vq);
+	 *   - drivers/scsi/virtio_scsi.c|258| <<virtscsi_kick_event>> spin_unlock_irqrestore(&vscsi->event_vq.vq_lock, flags);
+	 *   - drivers/scsi/virtio_scsi.c|285| <<virtscsi_cancel_event_work>> spin_lock_irq(&vscsi->event_vq.vq_lock);
+	 *   - drivers/scsi/virtio_scsi.c|287| <<virtscsi_cancel_event_work>> spin_unlock_irq(&vscsi->event_vq.vq_lock);
+	 *   - drivers/scsi/virtio_scsi.c|460| <<virtscsi_event_done>> virtscsi_vq_done(vscsi, &vscsi->event_vq, virtscsi_complete_event);
+	 *   - drivers/scsi/virtio_scsi.c|1070| <<virtscsi_init>> virtscsi_init_vq(&vscsi->event_vq, vqs[1]);
+	 */
 	struct virtio_scsi_vq event_vq;
 	struct virtio_scsi_vq req_vqs[];
 };
@@ -112,10 +150,28 @@ static void virtscsi_compute_resid(struct scsi_cmnd *sc, u32 resid)
  *
  * Called with vq_lock held.
  */
+/*
+ * 在以下使用virtscsi_complete_cmd():
+ *   - drivers/scsi/virtio_scsi.c|247| <<virtscsi_req_done>> virtscsi_vq_done(vscsi, req_vq, virtscsi_complete_cmd);
+ *   - drivers/scsi/virtio_scsi.c|257| <<virtscsi_poll_requests>> virtscsi_complete_cmd);
+ *   - drivers/scsi/virtio_scsi.c|844| <<virtscsi_queuecommand>> virtscsi_complete_cmd(vscsi, cmd);
+ *   - drivers/scsi/virtio_scsi.c|1077| <<virtscsi_mq_poll>> virtscsi_complete_cmd(vscsi, buf);
+ */
 static void virtscsi_complete_cmd(struct virtio_scsi *vscsi, void *buf)
 {
 	struct virtio_scsi_cmd *cmd = buf;
 	struct scsi_cmnd *sc = cmd->sc;
+	/*
+	 * // Response, followed by sense data and data-in
+	 * struct virtio_scsi_cmd_resp {
+	 *     __virtio32 sense_len;           // Sense data length
+	 *     __virtio32 resid;               // Residual bytes in data buffer
+	 *     __virtio16 status_qualifier;    // Status qualifier
+	 *     __u8 status;            // Command completion status
+	 *     __u8 response;          // Response values
+	 *     __u8 sense[VIRTIO_SCSI_SENSE_SIZE];
+	 * } __attribute__((packed));
+	 */
 	struct virtio_scsi_cmd_resp *resp = &cmd->resp.cmd;
 
 	dev_dbg(&sc->device->sdev_gendev,
@@ -135,6 +191,13 @@ static void virtscsi_complete_cmd(struct virtio_scsi *vscsi, void *buf)
 		set_host_byte(sc, DID_ABORT);
 		break;
 	case VIRTIO_SCSI_S_BAD_TARGET:
+		/*
+		 * 在以下使用VIRTIO_SCSI_S_BAD_TARGET:
+		 *   - drivers/scsi/virtio_scsi.c|193| <<virtscsi_complete_cmd>> case VIRTIO_SCSI_S_BAD_TARGET:
+		 *   - drivers/scsi/virtio_scsi.c|879| <<virtscsi_queuecommand>> cmd->resp.cmd.response = VIRTIO_SCSI_S_BAD_TARGET;
+		 *   - drivers/vhost/scsi.c|1111| <<vhost_scsi_complete_cmd_work>> v_rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
+		 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_send_bad_target>> rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
+		 */
 		set_host_byte(sc, DID_BAD_TARGET);
 		break;
 	case VIRTIO_SCSI_S_RESET:
@@ -173,6 +236,13 @@ static void virtscsi_complete_cmd(struct virtio_scsi *vscsi, void *buf)
 	scsi_done(sc);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|202| <<virtscsi_req_done>> virtscsi_vq_done(vscsi, req_vq, virtscsi_complete_cmd);
+ *   - drivers/scsi/virtio_scsi.c|211| <<virtscsi_poll_requests>> virtscsi_vq_done(vscsi, &vscsi->req_vqs[i], virtscsi_complete_cmd);
+ *   - drivers/scsi/virtio_scsi.c|228| <<virtscsi_ctrl_done>> virtscsi_vq_done(vscsi, &vscsi->ctrl_vq, virtscsi_complete_free);
+ *   - drivers/scsi/virtio_scsi.c|460| <<virtscsi_event_done>> virtscsi_vq_done(vscsi, &vscsi->event_vq, virtscsi_complete_event);
+ */
 static void virtscsi_vq_done(struct virtio_scsi *vscsi,
 			     struct virtio_scsi_vq *virtscsi_vq,
 			     void (*fn)(struct virtio_scsi *vscsi, void *buf))
@@ -225,11 +295,22 @@ static void virtscsi_ctrl_done(struct virtqueue *vq)
 	struct Scsi_Host *sh = virtio_scsi_host(vq->vdev);
 	struct virtio_scsi *vscsi = shost_priv(sh);
 
+	/*
+	 * 在以下使用virtio_scsi->ctrl_vq:
+	 *   - drivers/scsi/virtio_scsi.c|228| <<virtscsi_ctrl_done>> virtscsi_vq_done(vscsi, &vscsi->ctrl_vq, virtscsi_complete_free);
+	 *   - drivers/scsi/virtio_scsi.c|762| <<virtscsi_tmf>> if (virtscsi_add_cmd(&vscsi->ctrl_vq, cmd, sizeof cmd->req.tmf, sizeof cmd->resp.tmf, true) < 0)
+	 *   - drivers/scsi/virtio_scsi.c|1069| <<virtscsi_init>> virtscsi_init_vq(&vscsi->ctrl_vq, vqs[0]);
+	 */
 	virtscsi_vq_done(vscsi, &vscsi->ctrl_vq, virtscsi_complete_free);
 };
 
 static void virtscsi_handle_event(struct work_struct *work);
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|261| <<virtscsi_kick_event_all>> virtscsi_kick_event(vscsi, &vscsi->event_list[i]);
+ *   - drivers/scsi/virtio_scsi.c|410| <<virtscsi_handle_event>> virtscsi_kick_event(vscsi, event_node);
+ */
 static int virtscsi_kick_event(struct virtio_scsi *vscsi,
 			       struct virtio_scsi_event_node *event_node)
 {
@@ -238,10 +319,23 @@ static int virtscsi_kick_event(struct virtio_scsi *vscsi,
 	unsigned long flags;
 
 	INIT_WORK(&event_node->work, virtscsi_handle_event);
+	/*
+	 * struct virtio_scsi_event {
+	 *     __virtio32 event;
+	 *     __u8 lun[8];
+	 *     __virtio32 reason;
+	 * } __attribute__((packed));
+	 *
+	 * struct virtio_scsi_event_node *event_node:
+	 * -> struct virtio_scsi_event event;
+	 */
 	sg_init_one(&sg, &event_node->event, sizeof(struct virtio_scsi_event));
 
 	spin_lock_irqsave(&vscsi->event_vq.vq_lock, flags);
 
+	/*
+	 * 很多调用
+	 */
 	err = virtqueue_add_inbuf(vscsi->event_vq.vq, &sg, 1, event_node,
 				  GFP_ATOMIC);
 	if (!err)
@@ -252,10 +346,24 @@ static int virtscsi_kick_event(struct virtio_scsi *vscsi,
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|1130| <<virtscsi_probe>> virtscsi_kick_event_all(vscsi);
+ *   - drivers/scsi/virtio_scsi.c|1175| <<virtscsi_restore>> virtscsi_kick_event_all(vscsi);
+ */
 static int virtscsi_kick_event_all(struct virtio_scsi *vscsi)
 {
 	int i;
 
+	/*
+	 * 在以下使用virtio_scsi->event_list[VIRTIO_SCSI_EVENT_LEN]:
+	 *   - drivers/scsi/virtio_scsi.c|303| <<virtscsi_kick_event_all>> vscsi->event_list[i].vscsi = vscsi;
+	 *   - drivers/scsi/virtio_scsi.c|304| <<virtscsi_kick_event_all>> virtscsi_kick_event(vscsi, &vscsi->event_list[i]);
+	 *   - drivers/scsi/virtio_scsi.c|320| <<virtscsi_cancel_event_work>> cancel_work_sync(&vscsi->event_list[i].work);
+	 *
+	 * struct virtio_scsi *vscsi:
+	 * -> struct virtio_scsi_event_node event_list[VIRTIO_SCSI_EVENT_LEN];
+	 */
 	for (i = 0; i < VIRTIO_SCSI_EVENT_LEN; i++) {
 		vscsi->event_list[i].vscsi = vscsi;
 		virtscsi_kick_event(vscsi, &vscsi->event_list[i]);
@@ -273,6 +381,12 @@ static void virtscsi_cancel_event_work(struct virtio_scsi *vscsi)
 	vscsi->stop_events = true;
 	spin_unlock_irq(&vscsi->event_vq.vq_lock);
 
+	/*
+	 * 在以下使用virtio_scsi->event_list[VIRTIO_SCSI_EVENT_LEN]:
+	 *   - drivers/scsi/virtio_scsi.c|303| <<virtscsi_kick_event_all>> vscsi->event_list[i].vscsi = vscsi;
+	 *   - drivers/scsi/virtio_scsi.c|304| <<virtscsi_kick_event_all>> virtscsi_kick_event(vscsi, &vscsi->event_list[i]);
+	 *   - drivers/scsi/virtio_scsi.c|320| <<virtscsi_cancel_event_work>> cancel_work_sync(&vscsi->event_list[i].work);
+	 */
 	for (i = 0; i < VIRTIO_SCSI_EVENT_LEN; i++)
 		cancel_work_sync(&vscsi->event_list[i].work);
 }
@@ -376,8 +490,25 @@ static int virtscsi_rescan_hotunplug(struct virtio_scsi *vscsi)
 	return 0;
 }
 
+/*
+ * 在以下使用virtscsi_handle_event():
+ *   - drivers/scsi/virtio_scsi.c|245| <<virtscsi_kick_event>> INIT_WORK(&event_node->work, virtscsi_handle_event);
+ */
 static void virtscsi_handle_event(struct work_struct *work)
 {
+	/*
+	 * struct virtio_scsi_event {
+	 *     __virtio32 event;
+	 *     __u8 lun[8];
+	 *     __virtio32 reason;
+	 * } __attribute__((packed));
+	 *
+	 * struct virtio_scsi_event_node {
+	 *     struct virtio_scsi *vscsi;
+	 *     struct virtio_scsi_event event;
+	 *     struct work_struct work;
+	 * };
+	 */
 	struct virtio_scsi_event_node *event_node =
 		container_of(work, struct virtio_scsi_event_node, work);
 	struct virtio_scsi *vscsi = event_node->vscsi;
@@ -395,6 +526,19 @@ static void virtscsi_handle_event(struct work_struct *work)
 		scsi_scan_host(virtio_scsi_host(vscsi->vdev));
 	}
 
+	/*
+	 * // Events.
+	 * #define VIRTIO_SCSI_T_EVENTS_MISSED            0x80000000
+	 * #define VIRTIO_SCSI_T_NO_EVENT                 0
+	 * #define VIRTIO_SCSI_T_TRANSPORT_RESET          1
+	 * #define VIRTIO_SCSI_T_ASYNC_NOTIFY             2
+	 * #define VIRTIO_SCSI_T_PARAM_CHANGE             3
+	 *
+	 * // Reasons of transport reset event
+	 * #define VIRTIO_SCSI_EVT_RESET_HARD             0
+	 * #define VIRTIO_SCSI_EVT_RESET_RESCAN           1
+	 * #define VIRTIO_SCSI_EVT_RESET_REMOVED          2
+	 */
 	switch (virtio32_to_cpu(vscsi->vdev, event->event)) {
 	case VIRTIO_SCSI_T_NO_EVENT:
 		break;
@@ -410,6 +554,10 @@ static void virtscsi_handle_event(struct work_struct *work)
 	virtscsi_kick_event(vscsi, event_node);
 }
 
+/*
+ * 在以下使用virtscsi_complete_event():
+ *   - drivers/scsi/virtio_scsi.c|426| <<virtscsi_event_done>> virtscsi_vq_done(vscsi, &vscsi->event_vq, virtscsi_complete_event);
+ */
 static void virtscsi_complete_event(struct virtio_scsi *vscsi, void *buf)
 {
 	struct virtio_scsi_event_node *event_node = buf;
@@ -418,6 +566,10 @@ static void virtscsi_complete_event(struct virtio_scsi *vscsi, void *buf)
 		queue_work(system_freezable_wq, &event_node->work);
 }
 
+/*
+ * 在以下使用virtscsi_event_done():
+ *   - drivers/scsi/virtio_scsi.c|1020| <<virtscsi_init>> vqs_info[1].callback = virtscsi_event_done;
+ */
 static void virtscsi_event_done(struct virtqueue *vq)
 {
 	struct Scsi_Host *sh = virtio_scsi_host(vq->vdev);
@@ -426,6 +578,10 @@ static void virtscsi_event_done(struct virtqueue *vq)
 	virtscsi_vq_done(vscsi, &vscsi->event_vq, virtscsi_complete_event);
 };
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|505| <<virtscsi_add_cmd>> err = __virtscsi_add_cmd(vq->vq, cmd, req_size, resp_size);
+ */
 static int __virtscsi_add_cmd(struct virtqueue *vq,
 			    struct virtio_scsi_cmd *cmd,
 			    size_t req_size, size_t resp_size)
@@ -444,6 +600,18 @@ static int __virtscsi_add_cmd(struct virtqueue *vq,
 			in = &sc->sdb.table;
 	}
 
+	/*
+	 * 关于 cmd->sdb.table.sgl = sg;
+	 *
+	 * struct scsi_cmnd *cmd:
+	 * -> struct scsi_data_buffer sdb;
+	 *    -> struct sg_table table;
+	 *       -> struct scatterlist *sgl;        // the list
+	 *       -> unsigned int nents;             // number of mapped entries
+	 *       -> unsigned int orig_nents;        // original size of list
+	 *    -> unsigned length;
+	 */
+
 	/* Request header.  */
 	sg_init_one(&req, &cmd->req, req_size);
 	sgs[out_num++] = &req;
@@ -456,6 +624,25 @@ static int __virtscsi_add_cmd(struct virtqueue *vq,
 		sgs[out_num++] = out->sgl;
 	}
 
+	/*
+	 * 61 struct virtio_scsi_cmd {
+	 * 62         struct scsi_cmnd *sc;
+	 * 63         struct completion *comp;
+	 * 64         union {
+	 * 65                 struct virtio_scsi_cmd_req       cmd;
+	 * 66                 struct virtio_scsi_cmd_req_pi    cmd_pi;
+	 * 67                 struct virtio_scsi_ctrl_tmf_req  tmf;
+	 * 68                 struct virtio_scsi_ctrl_an_req   an;
+	 * 69         } req;
+	 * 70         union {
+	 * 71                 struct virtio_scsi_cmd_resp      cmd;
+	 * 72                 struct virtio_scsi_ctrl_tmf_resp tmf;
+	 * 73                 struct virtio_scsi_ctrl_an_resp  an;
+	 * 74                 struct virtio_scsi_event         evt;
+	 * 75         } resp;
+	 * 76 } ____cacheline_aligned_in_smp;
+	 */
+
 	/* Response header.  */
 	sg_init_one(&resp, &cmd->resp, resp_size);
 	sgs[out_num + in_num++] = &resp;
@@ -468,6 +655,31 @@ static int __virtscsi_add_cmd(struct virtqueue *vq,
 		sgs[out_num + in_num++] = in->sgl;
 	}
 
+	/*
+	 * 在scsi_alloc_sgtables()中把request给map到scsi_cmnd上的
+	 *
+	 * struct scsi_cmnd *cmd:
+	 * -> struct scsi_data_buffer sdb;
+	 *    -> struct sg_table table;
+	 *       -> struct scatterlist *sgl;        // the list
+	 *       -> unsigned int nents;             // number of mapped entries
+	 *       -> unsigned int orig_nents;        // original size of list
+	 *    -> unsigned length;
+	 *
+	 * 假设没有prot
+	 *
+	 * struct scatterlist *sgs[6].
+	 *
+	 * 如果是READ的
+	 * sgs[0] : request header
+	 * sgs[1] : response header
+	 * sgs[2] : sc->sdb.table.sgl (in buffer)
+	 *
+	 * 如果是WRITE的
+	 * sgs[0] : request header
+	 * sgs[1] : sc->sdb.table.sgl (out buffer)
+	 * sgs[2] : response header
+	 */
 	return virtqueue_add_sgs(vq, sgs, out_num, in_num, cmd, GFP_ATOMIC);
 }
 
@@ -492,6 +704,11 @@ static void virtscsi_kick_vq(struct virtio_scsi_vq *vq)
  * @resp_size	: size of the response buffer
  * @kick	: whether to kick the virtqueue immediately
  */
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|602| <<virtscsi_queuecommand>> ret = virtscsi_add_cmd(req_vq, cmd, req_size, sizeof(cmd->resp.cmd), kick);
+ *   - drivers/scsi/virtio_scsi.c|620| <<virtscsi_tmf>> if (virtscsi_add_cmd(&vscsi->ctrl_vq, cmd, sizeof cmd->req.tmf, sizeof cmd->resp.tmf, true) < 0)
+ */
 static int virtscsi_add_cmd(struct virtio_scsi_vq *vq,
 			     struct virtio_scsi_cmd *cmd,
 			     size_t req_size, size_t resp_size,
@@ -502,6 +719,9 @@ static int virtscsi_add_cmd(struct virtio_scsi_vq *vq,
 	bool needs_kick = false;
 
 	spin_lock_irqsave(&vq->vq_lock, flags);
+	/*
+	 * 只在此处调用
+	 */
 	err = __virtscsi_add_cmd(vq->vq, cmd, req_size, resp_size);
 	if (!err && kick)
 		needs_kick = virtqueue_kick_prepare(vq->vq);
@@ -513,11 +733,34 @@ static int virtscsi_add_cmd(struct virtio_scsi_vq *vq,
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|538| <<virtio_scsi_init_hdr_pi>> virtio_scsi_init_hdr(vdev, (struct virtio_scsi_cmd_req *)cmd_pi, sc);
+ *   - drivers/scsi/virtio_scsi.c|596| <<virtscsi_queuecommand>> virtio_scsi_init_hdr(vscsi->vdev, &cmd->req.cmd, sc);
+ */
 static void virtio_scsi_init_hdr(struct virtio_device *vdev,
 				 struct virtio_scsi_cmd_req *cmd,
 				 struct scsi_cmnd *sc)
 {
+	/*
+	 * // SCSI command request, followed by data-out
+	 * struct virtio_scsi_cmd_req {
+	 *     __u8 lun[8];            // Logical Unit Number
+	 *     __virtio64 tag;         // Command identifier
+	 *     __u8 task_attr;         // Task attribute
+	 *     __u8 prio;              // SAM command priority field
+	 *     __u8 crn;
+	 *     __u8 cdb[VIRTIO_SCSI_CDB_SIZE];
+	 * } __attribute__((packed));
+	 */
 	cmd->lun[0] = 1;
+	/*
+	 * struct scsi_cmnd *sc:
+	 * -> struct scsi_device *device;
+	 *    -> unsigned int id;
+	 *    -> unsigned int channel;
+	 *    -> u64 lun;
+	 */
 	cmd->lun[1] = sc->device->id;
 	cmd->lun[2] = (sc->device->lun >> 8) | 0x40;
 	cmd->lun[3] = sc->device->lun & 0xff;
@@ -562,6 +805,17 @@ static struct virtio_scsi_vq *virtscsi_pick_vq_mq(struct virtio_scsi *vscsi,
 	return &vscsi->req_vqs[hwq];
 }
 
+/*
+ * 关于 cmd->sdb.table.sgl = sg;
+ *
+ * struct scsi_cmnd *cmd:
+ * -> struct scsi_data_buffer sdb;
+ *    -> struct sg_table table;
+ *       -> struct scatterlist *sgl;        // the list
+ *       -> unsigned int nents;             // number of mapped entries
+ *       -> unsigned int orig_nents;        // original size of list
+ *    -> unsigned length;
+ */
 static int virtscsi_queuecommand(struct Scsi_Host *shost,
 				 struct scsi_cmnd *sc)
 {
@@ -593,14 +847,49 @@ static int virtscsi_queuecommand(struct Scsi_Host *shost,
 	} else
 #endif
 	{
+		/*
+		 * 46 struct virtio_scsi_cmd {
+		 * 47         struct scsi_cmnd *sc;
+		 * 48         struct completion *comp;
+		 * 49         union {
+		 * 50                 struct virtio_scsi_cmd_req       cmd;
+		 * 51                 struct virtio_scsi_cmd_req_pi    cmd_pi;
+		 * 52                 struct virtio_scsi_ctrl_tmf_req  tmf;
+		 * 53                 struct virtio_scsi_ctrl_an_req   an;
+		 * 54         } req;  
+		 * 55         union { 
+		 * 56                 struct virtio_scsi_cmd_resp      cmd;
+		 * 57                 struct virtio_scsi_ctrl_tmf_resp tmf;
+		 * 58                 struct virtio_scsi_ctrl_an_resp  an;
+		 * 59                 struct virtio_scsi_event         evt; 
+		 * 60         } resp; 
+		 * 61 } ____cacheline_aligned_in_smp;
+		 *
+		 * 初始化virtio的header
+		 */
 		virtio_scsi_init_hdr(vscsi->vdev, &cmd->req.cmd, sc);
+		/*
+		 * 初始化virtio的header中的cdb
+		 */
 		memcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);
 		req_size = sizeof(cmd->req.cmd);
 	}
 
 	kick = (sc->flags & SCMD_LAST) != 0;
+	/*
+	 * called by:
+	 *   - drivers/scsi/virtio_scsi.c|602| <<virtscsi_queuecommand>> ret = virtscsi_add_cmd(req_vq, cmd, req_size, sizeof(cmd->resp.cmd), kick);
+	 *   - drivers/scsi/virtio_scsi.c|620| <<virtscsi_tmf>> if (virtscsi_add_cmd(&vscsi->ctrl_vq, cmd, sizeof cmd->req.tmf, sizeof cmd->resp.tmf, true) < 0)
+	 */
 	ret = virtscsi_add_cmd(req_vq, cmd, req_size, sizeof(cmd->resp.cmd), kick);
 	if (ret == -EIO) {
+		/*
+		 * 在以下使用VIRTIO_SCSI_S_BAD_TARGET:
+		 *   - drivers/scsi/virtio_scsi.c|193| <<virtscsi_complete_cmd>> case VIRTIO_SCSI_S_BAD_TARGET:
+		 *   - drivers/scsi/virtio_scsi.c|879| <<virtscsi_queuecommand>> cmd->resp.cmd.response = VIRTIO_SCSI_S_BAD_TARGET;
+		 *   - drivers/vhost/scsi.c|1111| <<vhost_scsi_complete_cmd_work>> v_rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
+		 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_send_bad_target>> rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
+		 */
 		cmd->resp.cmd.response = VIRTIO_SCSI_S_BAD_TARGET;
 		spin_lock_irqsave(&req_vq->vq_lock, flags);
 		virtscsi_complete_cmd(vscsi, cmd);
@@ -611,17 +900,50 @@ static int virtscsi_queuecommand(struct Scsi_Host *shost,
 	return 0;
 }
 
+/*
+ * 61 struct virtio_scsi_cmd {
+ * 62         struct scsi_cmnd *sc;
+ * 63         struct completion *comp;
+ * 64         union {
+ * 65                 struct virtio_scsi_cmd_req       cmd;
+ * 66                 struct virtio_scsi_cmd_req_pi    cmd_pi;
+ * 67                 struct virtio_scsi_ctrl_tmf_req  tmf;
+ * 68                 struct virtio_scsi_ctrl_an_req   an;
+ * 69         } req;
+ * 70         union {
+ * 71                 struct virtio_scsi_cmd_resp      cmd;
+ * 72                 struct virtio_scsi_ctrl_tmf_resp tmf;
+ * 73                 struct virtio_scsi_ctrl_an_resp  an;
+ * 74                 struct virtio_scsi_event         evt;
+ * 75         } resp;
+ * 76 } ____cacheline_aligned_in_smp;
+ *
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|768| <<virtscsi_device_reset>> return virtscsi_tmf(vscsi, cmd);
+ *   - drivers/scsi/virtio_scsi.c|826| <<virtscsi_abort>> return virtscsi_tmf(vscsi, cmd);
+ */
 static int virtscsi_tmf(struct virtio_scsi *vscsi, struct virtio_scsi_cmd *cmd)
 {
 	DECLARE_COMPLETION_ONSTACK(comp);
 	int ret = FAILED;
 
 	cmd->comp = &comp;
+	/*
+	 * 在以下使用virtio_scsi->ctrl_vq:
+	 *   - drivers/scsi/virtio_scsi.c|228| <<virtscsi_ctrl_done>> virtscsi_vq_done(vscsi, &vscsi->ctrl_vq, virtscsi_complete_free);
+	 *   - drivers/scsi/virtio_scsi.c|762| <<virtscsi_tmf>> if (virtscsi_add_cmd(&vscsi->ctrl_vq, cmd, sizeof cmd->req.tmf, sizeof cmd->resp.tmf, true) < 0)
+	 *   - drivers/scsi/virtio_scsi.c|1069| <<virtscsi_init>> virtscsi_init_vq(&vscsi->ctrl_vq, vqs[0]);
+	 */
 	if (virtscsi_add_cmd(&vscsi->ctrl_vq, cmd,
 			      sizeof cmd->req.tmf, sizeof cmd->resp.tmf, true) < 0)
 		goto out;
 
 	wait_for_completion(&comp);
+	/*
+	 * struct virtio_scsi_ctrl_tmf_resp {
+	 *     __u8 response;
+	 * } __attribute__((packed));
+	 */
 	if (cmd->resp.tmf.response == VIRTIO_SCSI_S_OK ||
 	    cmd->resp.tmf.response == VIRTIO_SCSI_S_FUNCTION_SUCCEEDED)
 		ret = SUCCESS;
@@ -662,6 +984,11 @@ static int virtscsi_device_reset(struct scsi_cmnd *sc)
 		.lun[2] = (sc->device->lun >> 8) | 0x40,
 		.lun[3] = sc->device->lun & 0xff,
 	};
+	/*
+	 * called by:
+	 *   - drivers/scsi/virtio_scsi.c|768| <<virtscsi_device_reset>> return virtscsi_tmf(vscsi, cmd);
+	 *   - drivers/scsi/virtio_scsi.c|826| <<virtscsi_abort>> return virtscsi_tmf(vscsi, cmd);
+	 */
 	return virtscsi_tmf(vscsi, cmd);
 }
 
@@ -700,6 +1027,9 @@ static int virtscsi_change_queue_depth(struct scsi_device *sdev, int qdepth)
 	return scsi_change_queue_depth(sdev, min(max_depth, qdepth));
 }
 
+/*
+ * struct scsi_host_template virtscsi_host_template.eh_abort_handler = virtscsi_abort()
+ */
 static int virtscsi_abort(struct scsi_cmnd *sc)
 {
 	struct virtio_scsi *vscsi = shost_priv(sc->device->host);
@@ -711,6 +1041,34 @@ static int virtscsi_abort(struct scsi_cmnd *sc)
 		return FAILED;
 
 	memset(cmd, 0, sizeof(*cmd));
+	/*
+	 * // Controlq type codes.
+	 * #define VIRTIO_SCSI_T_TMF                      0
+	 * #define VIRTIO_SCSI_T_AN_QUERY                 1
+	 * #define VIRTIO_SCSI_T_AN_SUBSCRIBE             2
+	 *
+	 * // Valid TMF subtypes.
+	 * #define VIRTIO_SCSI_T_TMF_ABORT_TASK           0
+	 * #define VIRTIO_SCSI_T_TMF_ABORT_TASK_SET       1
+	 * #define VIRTIO_SCSI_T_TMF_CLEAR_ACA            2
+	 * #define VIRTIO_SCSI_T_TMF_CLEAR_TASK_SET       3
+	 * #define VIRTIO_SCSI_T_TMF_I_T_NEXUS_RESET      4
+	 * #define VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET   5
+	 * #define VIRTIO_SCSI_T_TMF_QUERY_TASK           6
+	 * #define VIRTIO_SCSI_T_TMF_QUERY_TASK_SET       7
+	 *
+	 * 75 // Task Management Request
+	 * 76 struct virtio_scsi_ctrl_tmf_req {
+	 * 77         __virtio32 type;
+	 * 78         __virtio32 subtype;
+	 * 79         __u8 lun[8];
+	 * 80         __virtio64 tag;
+	 * 81 } __attribute__((packed));
+	 * 82
+	 * 83 struct virtio_scsi_ctrl_tmf_resp {
+	 * 84         __u8 response;
+	 * 85 } __attribute__((packed));
+	 */
 	cmd->req.tmf = (struct virtio_scsi_ctrl_tmf_req){
 		.type = VIRTIO_SCSI_T_TMF,
 		.subtype = VIRTIO_SCSI_T_TMF_ABORT_TASK,
@@ -720,6 +1078,11 @@ static int virtscsi_abort(struct scsi_cmnd *sc)
 		.lun[3] = sc->device->lun & 0xff,
 		.tag = cpu_to_virtio64(vscsi->vdev, (unsigned long)sc),
 	};
+	/*
+	 * called by:
+	 *   - drivers/scsi/virtio_scsi.c|768| <<virtscsi_device_reset>> return virtscsi_tmf(vscsi, cmd);
+	 *   - drivers/scsi/virtio_scsi.c|826| <<virtscsi_abort>> return virtscsi_tmf(vscsi, cmd);
+	 */
 	return virtscsi_tmf(vscsi, cmd);
 }
 
@@ -808,6 +1171,15 @@ static const struct scsi_host_template virtscsi_host_template = {
 	.track_queue_depth = 1,
 };
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|1104| <<virtscsi_probe>> num_queues = virtscsi_config_get(vdev, num_queues) ? : 1;
+ *   - drivers/scsi/virtio_scsi.c|1107| <<virtscsi_probe>> num_targets = virtscsi_config_get(vdev, max_target) + 1;
+ *   - drivers/scsi/virtio_scsi.c|1114| <<virtscsi_probe>> sg_elems = virtscsi_config_get(vdev, seg_max) ?: 1;
+ *   - drivers/scsi/virtio_scsi.c|1131| <<virtscsi_probe>> cmd_per_lun = virtscsi_config_get(vdev, cmd_per_lun) ?: 1;
+ *   - drivers/scsi/virtio_scsi.c|1133| <<virtscsi_probe>> shost->max_sectors = virtscsi_config_get(vdev, max_sectors) ?: 0xFFFF;
+ *   - drivers/scsi/virtio_scsi.c|1138| <<virtscsi_probe>> shost->max_lun = virtscsi_config_get(vdev, max_lun) + 1 + 0x4000;
+ */
 #define virtscsi_config_get(vdev, fld) \
 	({ \
 		__virtio_native_type(struct virtio_scsi_config, fld) __val; \
@@ -815,12 +1187,23 @@ static const struct scsi_host_template virtscsi_host_template = {
 		__val; \
 	})
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|1075| <<virtscsi_init>> virtscsi_config_set(vdev, cdb_size, VIRTIO_SCSI_CDB_SIZE);
+ *   - drivers/scsi/virtio_scsi.c|1076| <<virtscsi_init>> virtscsi_config_set(vdev, sense_size, VIRTIO_SCSI_SENSE_SIZE);
+ */
 #define virtscsi_config_set(vdev, fld, val) \
 	do { \
 		__virtio_native_type(struct virtio_scsi_config, fld) __val = (val); \
 		virtio_cwrite(vdev, struct virtio_scsi_config, fld, &__val); \
 	} while(0)
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|1069| <<virtscsi_init>> virtscsi_init_vq(&vscsi->ctrl_vq, vqs[0]);
+ *   - drivers/scsi/virtio_scsi.c|1070| <<virtscsi_init>> virtscsi_init_vq(&vscsi->event_vq, vqs[1]);
+ *   - drivers/scsi/virtio_scsi.c|1072| <<virtscsi_init>> virtscsi_init_vq(&vscsi->req_vqs[i - VIRTIO_SCSI_VQ_BASE], vqs[i]);
+ */
 static void virtscsi_init_vq(struct virtio_scsi_vq *virtscsi_vq,
 			     struct virtqueue *vq)
 {
@@ -835,6 +1218,11 @@ static void virtscsi_remove_vqs(struct virtio_device *vdev)
 	vdev->config->del_vqs(vdev);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|1122| <<virtscsi_probe>> err = virtscsi_init(vdev, vscsi);
+ *   - drivers/scsi/virtio_scsi.c|1202| <<virtscsi_restore>> err = virtscsi_init(vdev, vscsi);
+ */
 static int virtscsi_init(struct virtio_device *vdev,
 			 struct virtio_scsi *vscsi)
 {
@@ -902,6 +1290,14 @@ static int virtscsi_init(struct virtio_device *vdev,
 	return err;
 }
 
+/*
+ * [    0.651247] bug: vring_create_virtqueue() name=control, index=0, num=128
+ * [    0.652706] bug: vring_create_virtqueue() name=event, index=1, num=128
+ * [    0.654241] bug: vring_create_virtqueue() name=request, index=2, num=128
+ * [    0.655833] bug: vring_create_virtqueue() name=request, index=3, num=128
+ * [    0.657375] bug: vring_create_virtqueue() name=request, index=4, num=128
+ * [    0.658933] bug: vring_create_virtqueue() name=request, index=5, num=128
+ */
 static int virtscsi_probe(struct virtio_device *vdev)
 {
 	struct Scsi_Host *shost;
diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c
index 05d29201b..0866a8c8b 100644
--- a/drivers/target/target_core_transport.c
+++ b/drivers/target/target_core_transport.c
@@ -1637,6 +1637,11 @@ static int __target_submit(struct se_cmd *cmd)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/target/target_core_transport.c|1808| <<target_submit_prep>> rc = transport_generic_map_mem_to_cmd(se_cmd, sgl, sgl_count,
+ *   - drivers/target/target_core_xcopy.c|540| <<target_xcopy_setup_pt_cmd>> if (transport_generic_map_mem_to_cmd(cmd, xop->xop_data_sg,
+ */
 sense_reason_t
 transport_generic_map_mem_to_cmd(struct se_cmd *cmd, struct scatterlist *sgl,
 		u32 sgl_count, struct scatterlist *sgl_bidi, u32 sgl_bidi_count)
@@ -1655,6 +1660,11 @@ transport_generic_map_mem_to_cmd(struct se_cmd *cmd, struct scatterlist *sgl,
 		return TCM_INVALID_CDB_FIELD;
 	}
 
+	/*
+	 * struct se_cmd *cmd:
+	 * -> struct scatterlist *t_data_sg;
+	 * -> struct scatterlist *t_data_sg_orig;
+	 */
 	cmd->t_data_sg = sgl;
 	cmd->t_data_nents = sgl_count;
 	cmd->t_bidi_data_sg = sgl_bidi;
@@ -1685,6 +1695,17 @@ transport_generic_map_mem_to_cmd(struct se_cmd *cmd, struct scatterlist *sgl,
  * return code and handle failures. This will never fail for other drivers,
  * and the return code can be ignored.
  */
+/*
+ * called by:
+ *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1596| <<srpt_handle_cmd>> rc = target_init_cmd(cmd, ch->sess, &send_ioctx->sense_data[0],
+ *   - drivers/scsi/elx/efct/efct_lio.c|1381| <<efct_scsi_recv_cmd>> rc = target_init_cmd(se_cmd, se_sess, &io->tgt_io.sense_buffer[0],
+ *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|479| <<tcm_qla2xxx_handle_cmd>> rc = target_init_cmd(se_cmd, se_sess, &cmd->sense_buffer[0],
+ *   - drivers/target/loopback/tcm_loop.c|147| <<tcm_loop_target_queue_cmd>> target_init_cmd(se_cmd, tl_nexus->se_sess, &tl_cmd->tl_sense_buf[0],
+ *   - drivers/target/target_core_transport.c|1836| <<target_submit_cmd>> rc = target_init_cmd(se_cmd, se_sess, sense, unpacked_lun, data_length,
+ *   - drivers/target/tcm_fc/tfc_cmd.c|546| <<ft_send_work>> if (target_init_cmd(&cmd->se_cmd, cmd->sess->se_sess,
+ *   - drivers/vhost/scsi.c|1009| <<vhost_scsi_target_queue_cmd>> target_init_cmd(se_cmd, tv_nexus->tvn_se_sess, &cmd->tvc_sense_buf[0],
+ *   - drivers/xen/xen-scsiback.c|428| <<scsiback_cmd_exec>> target_init_cmd(se_cmd, sess, pending_req->sense_buffer,
+ */
 int target_init_cmd(struct se_cmd *se_cmd, struct se_session *se_sess,
 		    unsigned char *sense, u64 unpacked_lun,
 		    u32 data_length, int task_attr, int data_dir, int flags)
@@ -1742,6 +1763,17 @@ EXPORT_SYMBOL_GPL(target_init_cmd);
  * If failure is returned, lio will the callers queue_status to complete
  * the cmd.
  */
+/*
+ * called by:
+ *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1605| <<srpt_handle_cmd>> if (target_submit_prep(cmd, srp_cmd->cdb, sg, sg_cnt, NULL, 0, NULL, 0,
+ *   - drivers/scsi/elx/efct/efct_lio.c|1390| <<efct_scsi_recv_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0,
+ *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|485| <<tcm_qla2xxx_handle_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0, NULL, 0,
+ *   - drivers/target/loopback/tcm_loop.c|151| <<tcm_loop_target_queue_cmd>> if (target_submit_prep(se_cmd, sc->cmnd, scsi_sglist(sc),
+ *   - drivers/target/target_core_transport.c|1853| <<target_submit_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0, NULL, 0,
+ *   - drivers/target/tcm_fc/tfc_cmd.c|552| <<ft_send_work>> if (target_submit_prep(&cmd->se_cmd, fcp->fc_cdb, NULL, 0, NULL, 0,
+ *   - drivers/vhost/scsi.c|1032| <<vhost_scsi_target_queue_cmd>> if (target_submit_prep(se_cmd, cmd->tvc_cdb, sg_ptr,
+ *   - drivers/xen/xen-scsiback.c|432| <<scsiback_cmd_exec>> if (target_submit_prep(se_cmd, pending_req->cmnd, pending_req->sgl,
+ */
 int target_submit_prep(struct se_cmd *se_cmd, unsigned char *cdb,
 		       struct scatterlist *sgl, u32 sgl_count,
 		       struct scatterlist *sgl_bidi, u32 sgl_bidi_count,
@@ -1926,6 +1958,19 @@ static void target_queue_submission(struct se_cmd *se_cmd)
  * target_submit_prep or something similar must have been called on the cmd,
  * and this must be called from process context.
  */
+/*
+ * called by:
+ *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1609| <<srpt_handle_cmd>> target_submit(cmd);
+ *   - drivers/scsi/elx/efct/efct_lio.c|1394| <<efct_scsi_recv_cmd>> target_submit(se_cmd);
+ *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|489| <<tcm_qla2xxx_handle_cmd>> target_submit(se_cmd);
+ *   - drivers/target/iscsi/iscsi_target_erl1.c|950| <<iscsit_execute_cmd>> return target_submit(&cmd->se_cmd);
+ *   - drivers/target/iscsi/iscsi_target_tmr.c|321| <<iscsit_task_reassign_complete_read>> target_submit(se_cmd);
+ *   - drivers/target/loopback/tcm_loop.c|157| <<tcm_loop_target_queue_cmd>> target_submit(se_cmd);
+ *   - drivers/target/target_core_transport.c|1857| <<target_submit_cmd>> target_submit(se_cmd);
+ *   - drivers/target/tcm_fc/tfc_cmd.c|556| <<ft_send_work>> target_submit(&cmd->se_cmd);
+ *   - drivers/vhost/scsi.c|1037| <<vhost_scsi_target_queue_cmd>> target_submit(se_cmd);
+ *   - drivers/xen/xen-scsiback.c|436| <<scsiback_cmd_exec>> target_submit(se_cmd);
+ */
 int target_submit(struct se_cmd *se_cmd)
 {
 	const struct target_core_fabric_ops *tfo = se_cmd->se_sess->se_tpg->se_tpg_tfo;
@@ -1976,6 +2021,17 @@ static void target_complete_tmr_failure(struct work_struct *work)
  * Callable from all contexts.
  **/
 
+/*
+ * called by:
+ *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1667| <<srpt_handle_tsk_mgmt>> rc = target_submit_tmr(&send_ioctx->cmd, sess, NULL,
+ *   - drivers/scsi/elx/efct/efct_lio.c|1449| <<efct_scsi_recv_tmf>> rc = target_submit_tmr(&ocp->cmd, se_sess, NULL, lun, ocp, tmr_func,
+ *   - drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c|2799| <<ibmvscsis_parse_task>> rc = target_submit_tmr(&cmd->se_cmd, nexus->se_sess, NULL,
+ *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|617| <<tcm_qla2xxx_handle_tmr>> return target_submit_tmr(se_cmd, sess->se_sess, NULL, lun, mcmd,
+ *   - drivers/target/loopback/tcm_loop.c|216| <<tcm_loop_issue_tmr>> rc = target_submit_tmr(se_cmd, se_sess, tl_cmd->tl_sense_buf, lun,
+ *   - drivers/target/tcm_fc/tfc_cmd.c|365| <<ft_send_tm>> rc = target_submit_tmr(&cmd->se_cmd, cmd->sess->se_sess,
+ *   - drivers/vhost/scsi.c|2014| <<vhost_scsi_handle_tmf>> if (target_submit_tmr(&tmf->se_cmd, tpg->tpg_nexus->tvn_se_sess, NULL,
+ *   - drivers/xen/xen-scsiback.c|626| <<scsiback_device_action>> rc = target_submit_tmr(&pending_req->se_cmd, nexus->tvn_se_sess,
+ */
 int target_submit_tmr(struct se_cmd *se_cmd, struct se_session *se_sess,
 		unsigned char *sense, u64 unpacked_lun,
 		void *fabric_tmr_ptr, unsigned char tm_type,
diff --git a/drivers/vhost/iotlb.c b/drivers/vhost/iotlb.c
index ea61330a3..fbe08a19d 100644
--- a/drivers/vhost/iotlb.c
+++ b/drivers/vhost/iotlb.c
@@ -149,6 +149,13 @@ EXPORT_SYMBOL_GPL(vhost_iotlb_init);
  *
  * Returns an error is memory allocation fails
  */
+/*
+ * called by:
+ *   - drivers/vdpa/mlx5/core/mr.c|787| <<_mlx5_vdpa_create_mr>> mr->iotlb = vhost_iotlb_alloc(0, 0);
+ *   - drivers/vdpa/mlx5/core/resources.c|232| <<init_ctrl_vq>> mvdev->cvq.iotlb = vhost_iotlb_alloc(0, 0);
+ *   - drivers/vdpa/vdpa_user/iova_domain.c|592| <<vduse_domain_create>> domain->iotlb = vhost_iotlb_alloc(0, 0);
+ *   - drivers/vhost/vhost.c|1114| <<iotlb_alloc>> return vhost_iotlb_alloc(max_iotlb_entries, VHOST_IOTLB_FLAG_RETIRE);
+ */
 struct vhost_iotlb *vhost_iotlb_alloc(unsigned int limit, unsigned int flags)
 {
 	struct vhost_iotlb *iotlb = kzalloc(sizeof(*iotlb), GFP_KERNEL);
diff --git a/drivers/vhost/net.c b/drivers/vhost/net.c
index f16279351..2cf13ceaf 100644
--- a/drivers/vhost/net.c
+++ b/drivers/vhost/net.c
@@ -963,6 +963,11 @@ static void handle_tx(struct vhost_net *net)
 	mutex_unlock(&vq->mutex);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|994| <<vhost_net_rx_peek_head_len>> int len = peek_head_len(rnvq, sk);
+ *   - drivers/vhost/net.c|1002| <<vhost_net_rx_peek_head_len>> len = peek_head_len(rnvq, sk);
+ */
 static int peek_head_len(struct vhost_net_virtqueue *rvq, struct sock *sk)
 {
 	struct sk_buff *head;
@@ -984,6 +989,10 @@ static int peek_head_len(struct vhost_net_virtqueue *rvq, struct sock *sk)
 	return len;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1150| <<handle_rx>> sock_len = vhost_net_rx_peek_head_len(net, sock->sk,
+ */
 static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk,
 				      bool *busyloop_intr)
 {
@@ -1015,6 +1024,11 @@ static int vhost_net_rx_peek_head_len(struct vhost_net *net, struct sock *sk,
  * @quota       - headcount quota, 1 for big buffer
  *	returns number of buffer heads allocated, negative on error
  */
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1156| <<handle_rx>> headcount = get_rx_bufs(vq, vq->heads + nvq->done_idx, vhost_len, &in,
+ *                   vq_log, &log, likely(mergeable) ? UIO_MAXIOV : 1);
+ */
 static int get_rx_bufs(struct vhost_virtqueue *vq,
 		       struct vring_used_elem *heads,
 		       int datalen,
@@ -1038,6 +1052,29 @@ static int get_rx_bufs(struct vhost_virtqueue *vq,
 			r = -ENOBUFS;
 			goto err;
 		}
+		/*
+		 * called by:
+		 *   - drivers/vhost/net.c|583| <<vhost_net_tx_get_vq_desc>> int r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+		 *   - drivers/vhost/net.c|595| <<vhost_net_tx_get_vq_desc>> r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+		 *   - drivers/vhost/net.c|1041| <<get_rx_bufs>> r = vhost_get_vq_desc(vq, vq->iov + seg, ARRAY_SIZE(vq->iov) - seg, &out, &in, log, log_num);
+		 *   - drivers/vhost/scsi.c|481| <<vhost_scsi_do_evt_work>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+		 *   - drivers/vhost/scsi.c|966| <<vhost_scsi_get_desc>> vc->head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &vc->out, &vc->in, NULL, NULL);
+		 *   - drivers/vhost/test.c|61| <<handle_vq>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+		 *   - drivers/vhost/vsock.c|127| <<vhost_transport_do_send_pkt>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+		 *   - drivers/vhost/vsock.c|509| <<vhost_vsock_handle_tx_kick>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+		 *
+		 * 注释:
+		 * This looks in the virtqueue and for the first available buffer, and converts
+		 * it to an iovec for convenient access.  Since descriptors consist of some
+		 * number of output then some number of input descriptors, it's actually two
+		 * iovecs, but we pack them into one and note how many of each there were.
+		 *
+		 * This function returns the descriptor number found, or vq->num (which is
+		 * never a valid descriptor number) if none was found.  A negative code is
+		 * returned on error.
+		 *
+		 * 返回值是这个request的在desc table中的head index
+		 */
 		r = vhost_get_vq_desc(vq, vq->iov + seg,
 				      ARRAY_SIZE(vq->iov) - seg, &out,
 				      &in, log, log_num);
@@ -1060,6 +1097,9 @@ static int get_rx_bufs(struct vhost_virtqueue *vq,
 			log += *log_num;
 		}
 		heads[headcount].id = cpu_to_vhost32(vq, d);
+		/*
+		 * Total number of bytes covered by an iovec.
+		 */
 		len = iov_length(vq->iov + seg, in);
 		heads[headcount].len = cpu_to_vhost32(vq, len);
 		datalen -= len;
@@ -1089,6 +1129,12 @@ static void handle_rx(struct vhost_net *net)
 	struct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];
 	struct vhost_virtqueue *vq = &nvq->vq;
 	unsigned in, log;
+	/*
+	 * struct vhost_log {
+	 *     u64 addr;
+	 *     u64 len;
+	 * };
+	 */
 	struct vhost_log *vq_log;
 	struct msghdr msg = {
 		.msg_name = NULL,
@@ -1113,10 +1159,20 @@ static void handle_rx(struct vhost_net *net)
 	int recv_pkts = 0;
 
 	mutex_lock_nested(&vq->mutex, VHOST_NET_VQ_RX);
+	/*
+	 * struct socket *sock;
+	 */
 	sock = vhost_vq_get_backend(vq);
 	if (!sock)
 		goto out;
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/net.c|951| <<handle_tx>> if (!vq_meta_prefetch(vq))
+	 *   - drivers/vhost/net.c|1120| <<handle_rx>> if (!vq_meta_prefetch(vq))
+	 *   - drivers/vhost/vsock.c|103| <<vhost_transport_do_send_pkt>> if (!vq_meta_prefetch(vq))
+	 *   - drivers/vhost/vsock.c|494| <<vhost_vsock_handle_tx_kick>> if (!vq_meta_prefetch(vq))
+	 */
 	if (!vq_meta_prefetch(vq))
 		goto out;
 
@@ -1126,17 +1182,49 @@ static void handle_rx(struct vhost_net *net)
 	vhost_hlen = nvq->vhost_hlen;
 	sock_hlen = nvq->sock_hlen;
 
+	/*
+	 * 在以下使用vhost_virtqueue->log:
+	 *   - drivers/vhost/vhost.c|652| <<vhost_dev_init>> vq->log = NULL;
+	 *   - drivers/vhost/net.c|1180| <<handle_rx>> vq_log = unlikely(vhost_has_feature(vq, VHOST_F_LOG_ALL)) ? vq->log : NULL;
+	 *   - drivers/vhost/vhost.c|543| <<vhost_vq_free_iovecs>> kfree(vq->log);
+	 *   - drivers/vhost/vhost.c|544| <<vhost_vq_free_iovecs>> vq->log = NULL;
+	 *   - drivers/vhost/vhost.c|560| <<vhost_dev_alloc_iovecs>> vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log), GFP_KERNEL);
+	 *   - drivers/vhost/vhost.c|564| <<vhost_dev_alloc_iovecs>> if (!vq->indirect || !vq->log || !vq->heads)
+	 *
+	 *
+	 * 注释: Log all write descriptors. Can be changed while device is active.
+	 *
+	 * struct vhost_log {
+	 *     u64 addr;
+	 *     u64 len;
+	 * };
+	 *
+	 * struct vhost_log *vq_log;
+	 */
 	vq_log = unlikely(vhost_has_feature(vq, VHOST_F_LOG_ALL)) ?
 		vq->log : NULL;
 	mergeable = vhost_has_feature(vq, VIRTIO_NET_F_MRG_RXBUF);
 
 	do {
+		/*
+		 * 猜测返回的是packet的长度
+		 */
 		sock_len = vhost_net_rx_peek_head_len(net, sock->sk,
 						      &busyloop_intr);
 		if (!sock_len)
 			break;
+		/*
+		 * 下面加上virtio header??
+		 */
 		sock_len += sock_hlen;
 		vhost_len = sock_len + vhost_hlen;
+		/*
+		 * struct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];
+		 * struct vhost_virtqueue *vq = &nvq->vq;
+		 *
+		 * @log         - vhost log
+		 * @log_num     - log offset
+		 */
 		headcount = get_rx_bufs(vq, vq->heads + nvq->done_idx,
 					vhost_len, &in, vq_log, &log,
 					likely(mergeable) ? UIO_MAXIOV : 1);
@@ -1160,6 +1248,9 @@ static void handle_rx(struct vhost_net *net)
 		busyloop_intr = false;
 		if (nvq->rx_ring)
 			msg.msg_control = vhost_net_buf_consume(&nvq->rxq);
+		/*
+		 * 不太可能发生
+		 */
 		/* On overrun, truncate and discard */
 		if (unlikely(headcount > UIO_MAXIOV)) {
 			iov_iter_init(&msg.msg_iter, ITER_DEST, vq->iov, 1, 1);
@@ -1169,6 +1260,8 @@ static void handle_rx(struct vhost_net *net)
 			continue;
 		}
 		/* We don't need to be notified again. */
+		/*
+		 */
 		iov_iter_init(&msg.msg_iter, ITER_DEST, vq->iov, in, vhost_len);
 		fixup = msg.msg_iter;
 		if (unlikely((vhost_hlen))) {
@@ -1177,6 +1270,9 @@ static void handle_rx(struct vhost_net *net)
 			 */
 			iov_iter_advance(&msg.msg_iter, vhost_hlen);
 		}
+		/*
+		 * struct msghdr msg
+		 */
 		err = sock->ops->recvmsg(sock, &msg,
 					 sock_len, MSG_DONTWAIT | MSG_TRUNC);
 		/* Userspace might have consumed the packet meanwhile:
@@ -1215,6 +1311,12 @@ static void handle_rx(struct vhost_net *net)
 		nvq->done_idx += headcount;
 		if (nvq->done_idx > VHOST_NET_BATCH)
 			vhost_net_signal_used(nvq);
+		/*
+		 * struct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];
+		 * struct vhost_virtqueue *vq = &nvq->vq;
+		 *
+		 * 只在此处调用vhost_log_write()
+		 */
 		if (unlikely(vq_log))
 			vhost_log_write(vq, vq_log, log, vhost_len,
 					vq->iov, in);
@@ -1623,6 +1725,11 @@ static int vhost_net_set_features(struct vhost_net *n, u64 features)
 		goto out_unlock;
 
 	if ((features & (1ULL << VIRTIO_F_ACCESS_PLATFORM))) {
+		/*
+		 * called by:
+		 *   - drivers/vhost/net.c|1626| <<vhost_net_set_features>> if (vhost_init_device_iotlb(&n->dev))
+		 *   - drivers/vhost/vsock.c|812| <<vhost_vsock_set_features>> if (vhost_init_device_iotlb(&vsock->dev))
+		 */
 		if (vhost_init_device_iotlb(&n->dev))
 			goto out_unlock;
 	}
diff --git a/drivers/vhost/scsi.c b/drivers/vhost/scsi.c
index 718fa4e0b..013b44cd4 100644
--- a/drivers/vhost/scsi.c
+++ b/drivers/vhost/scsi.c
@@ -39,9 +39,58 @@
 
 #include "vhost.h"
 
+/*
+ * vhost_scsi_handle_kick()
+ * -> vhost_scsi_handle_vq()
+ *    -> vhost_scsi_get_desc()
+ *       -> vhost_get_vq_desc()
+ *
+ *
+ * vhost_scsi_ctl_handle_kick()
+ * -> vhost_scsi_ctl_handle_vq()
+ *    -> vhost_scsi_get_desc()
+ *       -> vhost_get_vq_desc()
+ *
+ *
+ * vhost_scsi_evt_work() or vhost_scsi_send_evt()
+ * -> vhost_scsi_complete_events()
+ *    -> vhost_scsi_do_evt_work()
+ *       -> vhost_get_vq_desc()
+ *
+ *
+ * 所有的vhost直接用iov_base的地方:
+ *   - drivers/vhost/net.c|1292| <<handle_rx>> vq_err(vq, "Unable to write vnet_hdr ""at addr %p\n", vq->iov->iov_base);
+ *   - drivers/vhost/scsi.c|930| <<vhost_scsi_do_evt_work>> eventp = vq->iov[out].iov_base;
+ *     稍后调用 ret = __copy_to_user(eventp, event, sizeof(*event));
+ *   - drivers/vhost/scsi.c|1643| <<vhost_scsi_send_bad_target>> resp = vq->iov[out].iov_base;
+ *     稍后调用 ret = __copy_to_user(resp, &rsp, sizeof(rsp));
+ *   - drivers/vhost/vhost.c|1435| <<__vhost_get_user_slow>> return vq->iotlb_iov[0].iov_base;
+ *   - drivers/vhost/vhost.c|2718| <<log_used>> ret = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+ *     log_write_hva()中稍后只是用地址作计算
+ *   - drivers/vhost/vhost.c|2746| <<vhost_log_write>> r = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+ *     log_write_hva()中稍后只是用地址作计算
+ *   - drivers/vhost/vhost.c|2968| <<translate_desc>> _iov->iov_base = (void __user *)(unsigned long )
+ *     在caller中作为struct iovec iov[]返回
+ */
+
 #define VHOST_SCSI_VERSION  "v0.1"
 #define VHOST_SCSI_NAMELEN 256
+/*
+ * 在以下使用VHOST_SCSI_MAX_CDB_SIZE:
+ *   - drivers/vhost/scsi.c|44| <<global>> #define VHOST_SCSI_MAX_CDB_SIZE 32
+ *   - drivers/vhost/scsi.c|158| <<"struct vhost_scsi_cmd">> unsigned char tvc_cdb[VHOST_SCSI_MAX_CDB_SIZE];
+ *   - drivers/vhost/scsi.c|910| <<vhost_scsi_get_cmd>> memcpy(cmd->tvc_cdb, cdb, VHOST_SCSI_MAX_CDB_SIZE);
+ *   - drivers/vhost/scsi.c|1717| <<vhost_scsi_handle_vq>> if (unlikely(scsi_command_size(cdb) > VHOST_SCSI_MAX_CDB_SIZE)) {
+ *   - drivers/vhost/scsi.c|1720| <<vhost_scsi_handle_vq>> vq_err(vq, ... scsi_command_size(cdb), VHOST_SCSI_MAX_CDB_SIZE);
+ */
 #define VHOST_SCSI_MAX_CDB_SIZE 32
+/*
+ * 在以下使用VHOST_SCSI_PREALLOC_SGLS:
+ *   - drivers/vhost/scsi.c|45| <<global>> #define VHOST_SCSI_PREALLOC_SGLS 2048
+ *   - drivers/vhost/scsi.c|3217| <<global>> struct target_core_fabric_ops vhost_scsi_ops.max_data_sg_nents = VHOST_SCSI_PREALLOC_SGLS,
+ *   - drivers/vhost/scsi.c|1134| <<vhost_scsi_mapal>> sgl_count = vhost_scsi_calc_sgls(data_iter, data_bytes, VHOST_SCSI_PREALLOC_SGLS);
+ *   - drivers/vhost/scsi.c|2229| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_sgl = kcalloc(VHOST_SCSI_PREALLOC_SGLS, sizeof(struct scatterlist), GFP_KERNEL);
+ */
 #define VHOST_SCSI_PREALLOC_SGLS 2048
 #define VHOST_SCSI_PREALLOC_UPAGES 2048
 #define VHOST_SCSI_PREALLOC_PROT_SGLS 2048
@@ -50,8 +99,24 @@
  * Using this limit prevents one virtqueue from starving others with
  * request.
  */
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|2606| <<vhost_scsi_open>> vhost_dev_init(&vs->dev, vqs, nvqs, UIO_MAXIOV, VHOST_SCSI_WEIGHT, 0, true, NULL);
+ */
 #define VHOST_SCSI_WEIGHT 256
 
+/*
+ * 在以下使用vhost_scsi_inflight->comp:
+ *   - drivers/vhost/scsi.c|354| <<vhost_scsi_done_inflight>> complete(&inflight->comp);
+ *   - drivers/vhost/scsi.c|378| <<vhost_scsi_init_inflight>> init_completion(&new_inflight->comp);
+ *   - drivers/vhost/scsi.c|2181| <<vhost_scsi_flush>> wait_for_completion(&vs->old_inflight[i]->comp);
+ *
+ * 在以下使用vhost_scsi_inflight->kref:
+ *   - drivers/vhost/scsi.c|377| <<vhost_scsi_init_inflight>> kref_init(&new_inflight->kref);
+ *   - drivers/vhost/scsi.c|392| <<vhost_scsi_get_inflight>> kref_get(&inflight->kref); 
+ *   - drivers/vhost/scsi.c|399| <<vhost_scsi_put_inflight>> kref_put(&inflight->kref, vhost_scsi_done_inflight);
+ *   - drivers/vhost/scsi.c|2174| <<vhost_scsi_flush>> kref_put(&vs->old_inflight[i]->kref, vhost_scsi_done_inflight);
+ */
 struct vhost_scsi_inflight {
 	/* Wait for the flush operation to finish */
 	struct completion comp;
@@ -60,44 +125,185 @@ struct vhost_scsi_inflight {
 };
 
 struct vhost_scsi_cmd {
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_vq_desc:
+	 *   - drivers/vhost/scsi.c|670| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+	 *   - drivers/vhost/scsi.c|1471| <<vhost_scsi_handle_vq>> cmd->tvc_vq_desc = vc.head;
+	 *
+	 * 注释: Descriptor from vhost_get_vq_desc() for virt_queue segment
+	 * 应该就是对应的virtio_scsi request的desc的第一个的index
+	 */
 	/* Descriptor from vhost_get_vq_desc() for virt_queue segment */
 	int tvc_vq_desc;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_task_attr:
+	 *   - drivers/vhost/scsi.c|1111| <<vhost_scsi_get_cmd>> cmd->tvc_task_attr = task_attr;
+	 *   - drivers/vhost/scsi.c|1476| <<vhost_scsi_target_queue_cmd>> vhost_scsi_to_tcm_attr(cmd->tvc_task_attr),
+	 */
 	/* virtio-scsi initiator task attribute */
 	int tvc_task_attr;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_in_iovs:
+	 *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST,
+	 *                  cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+	 *   - drivers/vhost/scsi.c|1600| <<vhost_scsi_handle_vq>> cmd->tvc_in_iovs = vc.in;
+	 *
+	 * 注释: virtio-scsi response incoming iovecs
+	 * 应该是需要返回的in的desc的指向的那些地址(包括response和要读的data的)数目!!!
+	 * 是数目!!!
+	 */
 	/* virtio-scsi response incoming iovecs */
 	int tvc_in_iovs;
 	/* virtio-scsi initiator data direction */
 	enum dma_data_direction tvc_data_direction;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_exp_data_len:
+	 *   - drivers/vhost/scsi.c|1055| <<vhost_scsi_get_cmd>> cmd->tvc_exp_data_len = exp_data_len;
+	 *   - drivers/vhost/scsi.c|1418| <<vhost_scsi_target_queue_cmd>> target_init_cmd(se_cmd, ... cmd->tvc_lun, cmd->tvc_exp_data_len,
+	 */
 	/* Expected data transfer length from virtio-scsi header */
 	u32 tvc_exp_data_len;
 	/* The Tag from include/linux/virtio_scsi.h:struct virtio_scsi_cmd_req */
 	u64 tvc_tag;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_sgl_count:
+	 *   - drivers/vhost/scsi.c|470| <<vhost_scsi_release_cmd_res>> if (tv_cmd->tvc_sgl_count) {
+	 *   - drivers/vhost/scsi.c|471| <<vhost_scsi_release_cmd_res>> for (i = 0; i < tv_cmd->tvc_sgl_count; i++) {
+	 *   - drivers/vhost/scsi.c|740| <<vhost_scsi_copy_sgl_to_iov>> for (i = 0; i < cmd->tvc_sgl_count; i++) {
+	 *   - drivers/vhost/scsi.c|976| <<vhost_scsi_map_to_sgl>> if (... cmd->tvc_sgl_count > BIO_MAX_VECS) {
+	 *   - drivers/vhost/scsi.c|1154| <<vhost_scsi_mapal>> cmd->tvc_sgl_count = sgl_count;
+	 *   - drivers/vhost/scsi.c|1156| <<vhost_scsi_mapal>> cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1159| <<vhost_scsi_mapal>> cmd->tvc_sgl_count, false);
+	 *   - drivers/vhost/scsi.c|1161| <<vhost_scsi_mapal>> sg_init_table(cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1166| <<vhost_scsi_mapal>> ret = vhost_scsi_copy_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1170| <<vhost_scsi_mapal>> cmd->tvc_sgl_count = 0;
+	 *   - drivers/vhost/scsi.c|1204| <<vhost_scsi_target_queue_cmd>> if (cmd->tvc_sgl_count) {
+	 *   - drivers/vhost/scsi.c|1245| <<vhost_scsi_target_queue_cmd>> target_init_cmd(se_cmd, tv_nexus->tvn_se_sess,
+	 *                 &cmd->tvc_sense_buf[0], cmd->tvc_sgl_count, NULL, 0, sg_prot_ptr,
+	 */
 	/* The number of scatterlists associated with this cmd */
 	u32 tvc_sgl_count;
 	u32 tvc_prot_sgl_count;
 	/* Saved unpacked SCSI LUN for vhost_scsi_target_queue_cmd() */
 	u32 tvc_lun;
+	/*
+	 * 在以下使用vhost_scsi_cmd->copied_iov:
+	 *   - drivers/vhost/scsi.c|374| <<vhost_scsi_release_cmd_res>> if (tv_cmd->copied_iov)
+	 *   - drivers/vhost/scsi.c|881| <<vhost_scsi_copy_iov_to_sgl>> cmd->copied_iov = 1;
+	 */
 	u32 copied_iov:1;
 	const void *saved_iter_addr;
+	/*
+	 * 在以下使用vhost_scsi_cmd->saved_iter:
+	 *   - drivers/vhost/scsi.c|822| <<vhost_scsi_copy_sgl_to_iov>> struct iov_iter *iter = &cmd->saved_iter;
+	 *   - drivers/vhost/scsi.c|1128| <<vhost_scsi_copy_iov_to_sgl>> cmd->saved_iter_addr = dup_iter(&cmd->saved_iter, iter, GFP_KERNEL);
+	 */
 	struct iov_iter saved_iter;
 	/* Pointer to the SGL formatted memory from virtio-scsi */
+	/*
+	 * 在以下使用vhost_virtqueue->tvc_sgl:
+	 *   - drivers/vhost/scsi.c|411| <<vhost_scsi_release_cmd_res>> __free_page(sg_page(&tv_cmd->tvc_sgl[i]));
+	 *   - drivers/vhost/scsi.c|413| <<vhost_scsi_release_cmd_res>> put_page(sg_page(&tv_cmd->tvc_sgl[i]));
+	 *   - drivers/vhost/scsi.c|646| <<vhost_scsi_copy_sgl_to_iov>> struct scatterlist *sg = cmd->tvc_sgl;
+	 *   - drivers/vhost/scsi.c|808| <<vhost_scsi_get_cmd>> sg = cmd->tvc_sgl;
+	 *   - drivers/vhost/scsi.c|813| <<vhost_scsi_get_cmd>> cmd->tvc_sgl = sg;
+	 *   - drivers/vhost/scsi.c|1054| <<vhost_scsi_mapal>> sg_init_table(cmd->tvc_sgl, sgl_count);
+	 *   - drivers/vhost/scsi.c|1057| <<vhost_scsi_mapal>> cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1059| <<vhost_scsi_mapal>> ret = vhost_scsi_map_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl, cmd->tvc_sgl_count, false);
+	 *   - drivers/vhost/scsi.c|1062| <<vhost_scsi_mapal>> sg_init_table(cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1066| <<vhost_scsi_mapal>> ret = vhost_scsi_copy_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl, cmd->tvc_sgl_count);
+	 *   - drivers/vhost/scsi.c|1106| <<vhost_scsi_target_queue_cmd>> sg_ptr = cmd->tvc_sgl;
+	 *   - drivers/vhost/scsi.c|2087| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_sgl);
+	 *   - drivers/vhost/scsi.c|2134| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_sgl = kcalloc(VHOST_SCSI_PREALLOC_SGLS, sizeof(struct scatterlist), GFP_KERNEL);
+	 *   - drivers/vhost/scsi.c|2137| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_sgl) {
+	 */
 	struct scatterlist *tvc_sgl;
 	struct scatterlist *tvc_prot_sgl;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_upages:
+	 *   - drivers/vhost/scsi.c|997| <<vhost_scsi_get_cmd>> pages = cmd->tvc_upages;
+	 *   - drivers/vhost/scsi.c|1002| <<vhost_scsi_get_cmd>> cmd->tvc_upages = pages;
+	 *   - drivers/vhost/scsi.c|1033| <<vhost_scsi_map_to_sgl>> struct page **pages = cmd->tvc_upages;
+	 *   - drivers/vhost/scsi.c|2460| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_upages);
+	 *   - drivers/vhost/scsi.c|2513| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_upages = kcalloc(VHOST_SCSI_PREALLOC_UPAGES,
+	 *                                         sizeof(struct page *), GFP_KERNEL);
+	 *   - drivers/vhost/scsi.c|2516| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_upages) {
+	 */
 	struct page **tvc_upages;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_resp_iov:
+	 *   - drivers/vhost/scsi.c|687| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST, cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+	 *   - drivers/vhost/scsi.c|751| <<vhost_scsi_get_cmd>> tvc_resp_iov = cmd->tvc_resp_iov;
+	 *   - drivers/vhost/scsi.c|764| <<vhost_scsi_get_cmd>> cmd->tvc_resp_iov = tvc_resp_iov;
+	 *   - drivers/vhost/scsi.c|1599| <<vhost_scsi_handle_vq>> cmd->tvc_resp_iov[i] = vq->iov[vc.out + i];
+	 *   - drivers/vhost/scsi.c|2015| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_resp_iov);
+	 *   - drivers/vhost/scsi.c|2075| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_resp_iov = kcalloc(UIO_MAXIOV, sizeof(struct iovec), GFP_KERNEL);
+	 *   - drivers/vhost/scsi.c|2078| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_resp_iov) {
+	 *
+	 * 注释: Pointer to response header iovec
+	 * 存储的所有的response(header和数据的)iov, 是一对一的copy
+	 * 不是指针
+	 */
 	/* Pointer to response header iovec */
 	struct iovec *tvc_resp_iov;
+	/*
+	 * 只在一处使用vhost_scsi_cmd->tvc_vhost:
+	 *   - drivers/vhost/scsi.c|1961| <<vhost_scsi_handle_vq>> cmd->tvc_vhost = vs;
+	 */
 	/* Pointer to vhost_scsi for our device */
 	struct vhost_scsi *tvc_vhost;
+	/*
+	 * 在以下设置vhost_scsi_cmd->tvc_vq:
+	 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_handle_vq>> cmd->tvc_vq = vq;
+	 * 在以下使用vhost_scsi_cmd->tvc_vq:
+	 *   - drivers/vhost/scsi.c|415| <<vhost_scsi_release_cmd_res>> struct vhost_scsi_virtqueue *svq = container_of(tv_cmd->tvc_vq,
+	 *                                    struct vhost_scsi_virtqueue, vq);
+	 *   - drivers/vhost/scsi.c|478| <<vhost_scsi_release_cmd>> struct vhost_scsi_virtqueue *svq = container_of(cmd->tvc_vq,
+	 *                                    struct vhost_scsi_virtqueue, vq);
+	 *   - drivers/vhost/scsi.c|734| <<vhost_scsi_complete_cmd_work>> v_rsp.resid = cpu_to_vhost32(cmd->tvc_vq, se_cmd->residual_count);
+	 *   - drivers/vhost/scsi.c|738| <<vhost_scsi_complete_cmd_work>> v_rsp.sense_len = cpu_to_vhost32(cmd->tvc_vq, se_cmd->scsi_sense_length);
+	 *   - drivers/vhost/scsi.c|778| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+	 */
 	/* Pointer to vhost_virtqueue for the cmd */
 	struct vhost_virtqueue *tvc_vq;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_nexus:
+	 *   - drivers/vhost/scsi.c|952| <<vhost_scsi_get_cmd>> cmd->tvc_nexus = tv_nexus;
+	 *   - drivers/vhost/scsi.c|1245| <<vhost_scsi_target_queue_cmd>> tv_nexus = cmd->tvc_nexus;
+	 */
 	/* Pointer to vhost nexus memory */
 	struct vhost_scsi_nexus *tvc_nexus;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_se_cmd:
+	 *   - drivers/vhost/scsi.c|615| <<vhost_scsi_drop_cmds>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+	 *   - drivers/vhost/scsi.c|909| <<vhost_scsi_complete_cmd_work>> se_cmd = &cmd->tvc_se_cmd;
+	 *   - drivers/vhost/scsi.c|1051| <<vhost_scsi_get_cmd>> cmd->tvc_se_cmd.map_tag = tag;
+	 *   - drivers/vhost/scsi.c|1388| <<vhost_scsi_target_queue_cmd>> struct se_cmd *se_cmd = &cmd->tvc_se_cmd;
+	 *   - drivers/vhost/scsi.c|2006| <<vhost_scsi_handle_vq>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+	 */
 	/* The TCM I/O descriptor that is accessed via container_of() */
 	struct se_cmd tvc_se_cmd;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_cdb[VHOST_SCSI_MAX_CDB_SIZE]:
+	 *   - drivers/vhost/scsi.c|1061| <<vhost_scsi_get_cmd>> memcpy(cmd->tvc_cdb, cdb, VHOST_SCSI_MAX_CDB_SIZE);
+	 *   - drivers/vhost/scsi.c|1433| <<vhost_scsi_target_queue_cmd>> if (target_submit_prep(se_cmd, cmd->tvc_cdb, sg_ptr,
+	 *   - drivers/vhost/scsi.c|1985| <<vhost_scsi_handle_vq>> pr_debug("vhost_scsi ... cmd->tvc_cdb[0], cmd->tvc_lun);
+	 */
 	/* Copy of the incoming SCSI command descriptor block (CDB) */
 	unsigned char tvc_cdb[VHOST_SCSI_MAX_CDB_SIZE];
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_sense_buf[TRANSPORT_SENSE_BUFFER]:
+	 *   - drivers/vhost/scsi.c|934| <<vhost_scsi_complete_cmd_work>> memcpy(v_rsp.sense, cmd->tvc_sense_buf,
+	 *   - drivers/vhost/scsi.c|1417| <<vhost_scsi_target_queue_cmd>> target_init_cmd(se_cmd, tv_nexus->tvn_se_sess, &cmd->tvc_sense_buf[0],
+	 */
 	/* Sense buffer that will be mapped into outgoing status */
 	unsigned char tvc_sense_buf[TRANSPORT_SENSE_BUFFER];
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_completion_list:
+	 *   - drivers/vhost/scsi.c|614| <<vhost_scsi_drop_cmds>> llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list)
+	 *   - drivers/vhost/scsi.c|634| <<vhost_scsi_release_cmd>> llist_add(&cmd->tvc_completion_list, &svq->completion_list);
+	 *   - drivers/vhost/scsi.c|905| <<vhost_scsi_complete_cmd_work>> llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list) {
+	 */
 	/* Completed commands list, serviced from vhost worker thread */
 	struct llist_node tvc_completion_list;
 	/* Used to track inflight cmd */
@@ -128,6 +334,13 @@ struct vhost_scsi_tpg {
 	struct vhost_scsi_tport *tport;
 	/* Returned by vhost_scsi_make_tpg() */
 	struct se_portal_group se_tpg;
+	/*
+	 * 在以下使用vhost_scsi_tpg->vhost_scsi:
+	 *   - drivers/vhost/scsi.c|3338| <<vhost_scsi_set_endpoint>> tpg->vhost_scsi = vs;
+	 *   - drivers/vhost/scsi.c|3400| <<vhost_scsi_set_endpoint>> tpg->vhost_scsi = NULL;
+	 *   - drivers/vhost/scsi.c|3497| <<vhost_scsi_clear_endpoint>> tpg->vhost_scsi = NULL;
+	 *   - drivers/vhost/scsi.c|3789| <<vhost_scsi_do_plug>> struct vhost_scsi *vs = tpg->vhost_scsi;
+	 */
 	/* Pointer back to vhost_scsi, protected by tv_tpg_mutex */
 	struct vhost_scsi *vhost_scsi;
 };
@@ -184,10 +397,35 @@ struct vhost_scsi_virtqueue {
 	 * Writers must also take dev mutex and flush under it.
 	 */
 	int inflight_idx;
+	/*
+	 * 在以下使用vhost_scsi_virtqueue->scsi_cmds:
+	 *   - drivers/vhost/scsi.c|667| <<vhost_scsi_get_cmd>> cmd = &svq->scsi_cmds[tag];
+	 *   - drivers/vhost/scsi.c|1660| <<vhost_scsi_destroy_vq_cmds>> if (!svq->scsi_cmds)
+	 *   - drivers/vhost/scsi.c|1664| <<vhost_scsi_destroy_vq_cmds>> tv_cmd = &svq->scsi_cmds[i];
+	 *   - drivers/vhost/scsi.c|1673| <<vhost_scsi_destroy_vq_cmds>> kfree(svq->scsi_cmds);
+	 *   - drivers/vhost/scsi.c|1674| <<vhost_scsi_destroy_vq_cmds>> svq->scsi_cmds = NULL;
+	 *   - drivers/vhost/scsi.c|1684| <<vhost_scsi_setup_vq_cmds>> if (svq->scsi_cmds)
+	 *   - drivers/vhost/scsi.c|1692| <<vhost_scsi_setup_vq_cmds>> svq->scsi_cmds = kcalloc(max_cmds, sizeof(*tv_cmd), GFP_KERNEL);
+	 *   - drivers/vhost/scsi.c|1693| <<vhost_scsi_setup_vq_cmds>> if (!svq->scsi_cmds) {
+	 *   - drivers/vhost/scsi.c|1699| <<vhost_scsi_setup_vq_cmds>> tv_cmd = &svq->scsi_cmds[i];
+	 */
 	struct vhost_scsi_cmd *scsi_cmds;
+	/*
+	 * 在以下使用vhost_scsi_virtqueue->scsi_tags:
+	 *   - drivers/vhost/scsi.c|520| <<vhost_scsi_release_cmd_res>> sbitmap_clear_bit(&svq->scsi_tags, se_cmd->map_tag);
+	 *   - drivers/vhost/scsi.c|931| <<vhost_scsi_get_cmd>> tag = sbitmap_get(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2234| <<vhost_scsi_destroy_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2253| <<vhost_scsi_setup_vq_cmds>> if (sbitmap_init_node(&svq->scsi_tags, max_cmds, -1, GFP_KERNEL,
+	 *   - drivers/vhost/scsi.c|2268| <<vhost_scsi_setup_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 */
 	struct sbitmap scsi_tags;
 	int max_cmds;
 
+	/*
+	 * 在以下使用vhost_scsi_virtqueue->completion_work:
+	 *   - drivers/vhost/scsi.c|753| <<vhost_scsi_release_cmd>> if (!vhost_vq_work_queue(&svq->vq, &svq->completion_work))
+	 *   - drivers/vhost/scsi.c|3397| <<vhost_scsi_open>> vhost_work_init(&svq->completion_work, vhost_scsi_complete_cmd_work);
+	 */
 	struct vhost_work completion_work;
 	struct llist_head completion_list;
 };
@@ -201,15 +439,58 @@ struct vhost_scsi {
 	struct vhost_scsi_virtqueue *vqs;
 	struct vhost_scsi_inflight **old_inflight;
 
+	/*
+	 * 在以下使用vhost_scsi->vs_event_work:
+	 *   - drivers/vhost/scsi.c|1553| <<vhost_scsi_send_evt>> if (!vhost_vq_work_queue(vq, &vs->vs_event_work))
+	 *   - drivers/vhost/scsi.c|1997| <<vhost_scsi_open>> vhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);
+	 */
 	struct vhost_work vs_event_work; /* evt injection work item */
+	/*
+	 * 在以下使用vhost_scsi->vs_event_list:
+	 *   - drivers/vhost/scsi.c|527| <<vhost_scsi_complete_events>> llnode = llist_del_all(&vs->vs_event_list);
+	 *   - drivers/vhost/scsi.c|1552| <<vhost_scsi_send_evt>> llist_add(&evt->list, &vs->vs_event_list);
+	 */
 	struct llist_head vs_event_list; /* evt injection queue */
 
+	/*
+	 * 在以下使用vhost_scsi->vs_events_missed:
+	 *   - drivers/vhost/scsi.c|761| <<vhost_scsi_allocate_evt>> vs->vs_events_missed = true;
+	 *   - drivers/vhost/scsi.c|768| <<vhost_scsi_allocate_evt>> vs->vs_events_missed = true;
+	 *   - drivers/vhost/scsi.c|801| <<vhost_scsi_do_evt_work>> vs->vs_events_missed = true;
+	 *   - drivers/vhost/scsi.c|834| <<vhost_scsi_do_evt_work>> vs->vs_events_missed = true;
+	 *   - drivers/vhost/scsi.c|840| <<vhost_scsi_do_evt_work>> vs->vs_events_missed = true;
+	 *   - drivers/vhost/scsi.c|847| <<vhost_scsi_do_evt_work>> vs->vs_events_missed = true;
+	 *   - drivers/vhost/scsi.c|851| <<vhost_scsi_do_evt_work>> if (vs->vs_events_missed) {
+	 *   - drivers/vhost/scsi.c|853| <<vhost_scsi_do_evt_work>> vs->vs_events_missed = false;
+	 *   - drivers/vhost/scsi.c|2614| <<vhost_scsi_evt_handle_kick>> if (vs->vs_events_missed)
+	 *   - drivers/vhost/scsi.c|3157| <<vhost_scsi_open>> vs->vs_events_missed = false;
+	 *   - drivers/vhost/scsi.c|3247| <<vhost_scsi_ioctl(VHOST_SCSI_SET_EVENTS_MISSED)>> vs->vs_events_missed = events_missed;
+	 *   - drivers/vhost/scsi.c|3252| <<vhost_scsi_ioctl(VHOST_SCSI_GET_EVENTS_MISSED)>> events_missed = vs->vs_events_missed;
+	 */
 	bool vs_events_missed; /* any missed events, protected by vq->mutex */
+	/*
+	 * 在以下使用vhost_scsi->vs_events_nr:
+	 *   - drivers/vhost/scsi.c|768| <<vhost_scsi_free_evt>> vs->vs_events_nr--;
+	 *   - drivers/vhost/scsi.c|783| <<vhost_scsi_allocate_evt>> if (vs->vs_events_nr > VHOST_SCSI_MAX_EVENT) {
+	 *   - drivers/vhost/scsi.c|797| <<vhost_scsi_allocate_evt>> vs->vs_events_nr++;
+	 *   - drivers/vhost/scsi.c|3118| <<vhost_scsi_clear_endpoint>> WARN_ON(vs->vs_events_nr);
+	 *   - drivers/vhost/scsi.c|3192| <<vhost_scsi_open>> vs->vs_events_nr = 0;
+	 */
 	int vs_events_nr; /* num of pending events, protected by vq->mutex */
 };
 
 struct vhost_scsi_tmf {
+	/*
+	 * 在以下使用vhost_scsi_tmf->vwork:
+	 *   - drivers/vhost/scsi.c|2359| <<vhost_scsi_tmf_flush_work>> if (!vhost_vq_work_queue(vq, &tmf->vwork))
+	 *   - drivers/vhost/scsi.c|2406| <<vhost_scsi_handle_tmf>> vhost_work_init(&tmf->vwork, vhost_scsi_tmf_resp_work);
+	 */
 	struct vhost_work vwork;
+	/*
+	 * 在以下使用vhost_scsi_tmf->flush_work:
+	 *   - drivers/vhost/scsi.c|724| <<vhost_scsi_release_cmd>> schedule_work(&tmf->flush_work);
+	 *   - drivers/vhost/scsi.c|2405| <<vhost_scsi_handle_tmf>> INIT_WORK(&tmf->flush_work, vhost_scsi_tmf_flush_work);
+	 */
 	struct work_struct flush_work;
 	struct vhost_scsi *vhost;
 	struct vhost_scsi_virtqueue *svq;
@@ -217,8 +498,26 @@ struct vhost_scsi_tmf {
 	struct se_cmd se_cmd;
 	u8 scsi_resp;
 	struct vhost_scsi_inflight *inflight;
+	/*
+	 * 在以下使用vhost_scsi_tmf->resp_iov:
+	 *   - drivers/vhost/scsi.c|2350| <<vhost_scsi_send_tmf_resp>> iov_iter_init(&iov_iter, ITER_DEST, resp_iov, in_iovs, sizeof(rsp));
+	 *   - drivers/vhost/scsi.c|2382| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq, tmf->in_iovs,
+	 *                                        tmf->vq_desc, &tmf->resp_iov, resp_code);
+	 *   - drivers/vhost/scsi.c|2470| <<vhost_scsi_handle_tmf>> tmf->resp_iov = vq->iov[vc->out];
+	 */
 	struct iovec resp_iov;
+	/*
+	 * 在以下使用vhost_scsi_tmf->in_iovs:
+	 *   - drivers/vhost/scsi.c|2381| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq, tmf->in_iovs,
+	 *   - drivers/vhost/scsi.c|2472| <<vhost_scsi_handle_tmf>> tmf->in_iovs = vc->in;
+	 */
 	int in_iovs;
+	/*
+	 * 在以下使用vhost_scsi_tmf->vq_desc:
+	 *   - drivers/vhost/scsi.c|2382| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq, tmf->in_iovs,
+	 *                                        tmf->vq_desc, &tmf->resp_iov, resp_code);
+	 *   - drivers/vhost/scsi.c|2471| <<vhost_scsi_handle_tmf>> tmf->vq_desc = vc->head;
+	 */
 	int vq_desc;
 };
 
@@ -227,11 +526,48 @@ struct vhost_scsi_tmf {
  */
 struct vhost_scsi_ctx {
 	int head;
+	/*
+	 * 在以下使用vhost_scsi_ctx->in:
+	 *   - drivers/vhost/scsi.c|1802| <<vhost_scsi_get_desc>> vc->head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &vc->out, &vc->in, 
+	 *   - drivers/vhost/scsi.c|1806| <<vhost_scsi_get_desc>> pr_debug("vhost_get_vq_desc: head: %d, out: %u in: %u\n", vc->head, vc->out, vc->in);
+	 *   - drivers/vhost/scsi.c|1826| <<vhost_scsi_get_desc>> vc->in_size = iov_length(&vq->iov[vc->out], vc->in);
+	 *   - drivers/vhost/scsi.c|2155| <<vhost_scsi_handle_vq>> iov_iter_init(&in_iter, ITER_DEST, &vq->iov[vc.out], vc.in, vc.rsp_size + exp_data_len);
+	 *   - drivers/vhost/scsi.c|2278| <<vhost_scsi_handle_vq>> for (i = 0; i < vc.in ; i++)
+	 *   - drivers/vhost/scsi.c|2286| <<vhost_scsi_handle_vq>> cmd->tvc_in_iovs = vc.in;
+	 *   - drivers/vhost/scsi.c|2524| <<vhost_scsi_handle_tmf>> tmf->in_iovs = vc->in;
+	 *   - drivers/vhost/scsi.c|2562| <<vhost_scsi_handle_tmf>> vhost_scsi_send_tmf_resp(vs, vq, vc->in, vc->head, &vq->iov[vc->out],
+	 *   - drivers/vhost/scsi.c|2624| <<vhost_scsi_send_an_resp>> iov_iter_init(&iov_iter, ITER_DEST, &vq->iov[vc->out], vc->in, sizeof(rsp));
+	 */
 	unsigned int out, in;
 	size_t req_size, rsp_size;
+	/*
+	 * 在以下设置vhost_scsi_ctx->out_size:
+	 *   - drivers/vhost/scsi.c|1825| <<vhost_scsi_get_desc>> vc->out_size = iov_length(vq->iov, vc->out);
+	 * 在以下使用vhost_scsi_ctx->out_size:
+	 *   - drivers/vhost/scsi.c|1845| <<vhost_scsi_get_desc>> iov_iter_init(&vc->out_iter, ITER_SOURCE, vq->iov, vc->out, vc->out_size);
+	 *   - drivers/vhost/scsi.c|1865| <<vhost_scsi_chk_size>> } else if (unlikely(vc->out_size < vc->req_size)) {
+	 *   - drivers/vhost/scsi.c|1868| <<vhost_scsi_chk_size>> vq_err(vq, ... vc->req_size, vc->out_size);
+	 *   - drivers/vhost/scsi.c|2135| <<vhost_scsi_handle_vq>> if (vc.out_size > vc.req_size) {
+	 *   - drivers/vhost/scsi.c|2140| <<vhost_scsi_handle_vq>> exp_data_len = vc.out_size - vc.req_size;
+	 *
+	 * 在以下设置vhost_scsi_ctx->in_size:
+	 *   - drivers/vhost/scsi.c|1826| <<vhost_scsi_get_desc>> vc->in_size = iov_length(&vq->iov[vc->out], vc->in);
+	 * 在以下使用vhost_scsi_ctx->in_size:
+	 *   - drivers/vhost/scsi.c|1860| <<vhost_scsi_chk_size>> if (unlikely(vc->in_size < vc->rsp_size)) {
+	 *   - drivers/vhost/scsi.c|1863| <<vhost_scsi_chk_size>> vq_err(vq, ... vc->rsp_size, vc->in_size);
+	 *   - drivers/vhost/scsi.c|2142| <<vhost_scsi_handle_vq>> } else if (vc.in_size > vc.rsp_size) {
+	 *   - drivers/vhost/scsi.c|2147| <<vhost_scsi_handle_vq>> exp_data_len = vc.in_size - vc.rsp_size;
+	 */
 	size_t out_size, in_size;
 	u8 *target, *lunp;
 	void *req;
+	/*
+	 * 在以下使用vhost_scsi_ctx->out_iter:
+	 *   - drivers/vhost/scsi.c|1071| <<vhost_scsi_get_desc>> iov_iter_init(&vc->out_iter, ITER_SOURCE, vq->iov, vc->out, vc->out_size);
+	 *   - drivers/vhost/scsi.c|1103| <<vhost_scsi_get_req>> if (unlikely(!copy_from_iter_full(vc->req, vc->req_size, &vc->out_iter))) {
+	 *   - drivers/vhost/scsi.c|1284| <<vhost_scsi_handle_vq>> data_iter = vc.out_iter;
+	 *   - drivers/vhost/scsi.c|1574| <<vhost_scsi_ctl_handle_vq>> if (unlikely(!copy_from_iter_full(vc.req, typ_size, &vc.out_iter))) {
+	 */
 	struct iov_iter out_iter;
 };
 
@@ -240,8 +576,19 @@ struct vhost_scsi_ctx {
  * configfs management operations.
  */
 static DEFINE_MUTEX(vhost_scsi_mutex);
+/*
+ * 在以下使用vhost_scsi_list:
+ *   - drivers/vhost/scsi.c|378| <<global>> static LIST_HEAD(vhost_scsi_list);
+ *   - drivers/vhost/scsi.c|2353| <<vhost_scsi_set_endpoint>> list_for_each_entry(tpg, &vhost_scsi_list, tv_tpg_list) {
+ *   - drivers/vhost/scsi.c|3135| <<vhost_scsi_make_tpg>> list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
+ */
 static LIST_HEAD(vhost_scsi_list);
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|430| <<vhost_scsi_put_inflight>> kref_put(&inflight->kref, vhost_scsi_done_inflight);
+ *   - drivers/vhost/scsi.c|2205| <<vhost_scsi_flush>> kref_put(&vs->old_inflight[i]->kref, vhost_scsi_done_inflight);
+ */
 static void vhost_scsi_done_inflight(struct kref *kref)
 {
 	struct vhost_scsi_inflight *inflight;
@@ -250,6 +597,11 @@ static void vhost_scsi_done_inflight(struct kref *kref)
 	complete(&inflight->comp);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|2197| <<vhost_scsi_flush>> vhost_scsi_init_inflight(vs, vs->old_inflight);
+ *   - drivers/vhost/scsi.c|2639| <<vhost_scsi_open>> vhost_scsi_init_inflight(vs, NULL);
+ */
 static void vhost_scsi_init_inflight(struct vhost_scsi *vs,
 				    struct vhost_scsi_inflight *old_inflight[])
 {
@@ -277,6 +629,11 @@ static void vhost_scsi_init_inflight(struct vhost_scsi *vs,
 	}
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|953| <<vhost_scsi_get_cmd>> cmd->inflight = vhost_scsi_get_inflight(vq);
+ *   - drivers/vhost/scsi.c|1955| <<vhost_scsi_handle_tmf>> tmf->inflight = vhost_scsi_get_inflight(vq);
+ */
 static struct vhost_scsi_inflight *
 vhost_scsi_get_inflight(struct vhost_virtqueue *vq)
 {
@@ -290,16 +647,28 @@ vhost_scsi_get_inflight(struct vhost_virtqueue *vq)
 	return inflight;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|521| <<vhost_scsi_release_cmd_res>> vhost_scsi_put_inflight(inflight);
+ *   - drivers/vhost/scsi.c|529| <<vhost_scsi_release_tmf_res>> vhost_scsi_put_inflight(inflight);
+ */
 static void vhost_scsi_put_inflight(struct vhost_scsi_inflight *inflight)
 {
 	kref_put(&inflight->kref, vhost_scsi_done_inflight);
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_check_true(struct se_portal_group *se_tpg)
 {
 	return 1;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static char *vhost_scsi_get_fabric_wwn(struct se_portal_group *se_tpg)
 {
 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
@@ -309,6 +678,9 @@ static char *vhost_scsi_get_fabric_wwn(struct se_portal_group *se_tpg)
 	return &tport->tport_name[0];
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static u16 vhost_scsi_get_tpgt(struct se_portal_group *se_tpg)
 {
 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
@@ -316,6 +688,9 @@ static u16 vhost_scsi_get_tpgt(struct se_portal_group *se_tpg)
 	return tpg->tport_tpgt;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_check_prot_fabric_only(struct se_portal_group *se_tpg)
 {
 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
@@ -324,10 +699,27 @@ static int vhost_scsi_check_prot_fabric_only(struct se_portal_group *se_tpg)
 	return tpg->tv_fabric_prot_type;
 }
 
+/*
+ * 在以下调用vhost_scsi_release_cmd_res():
+ *   - drivers/vhost/scsi.c|405| <<vhost_scsi_drop_cmds>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+ *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> vhost_scsi_release_cmd_res(se_cmd);
+ *   - drivers/vhost/scsi.c|1549| <<vhost_scsi_handle_vq>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+ */
 static void vhost_scsi_release_cmd_res(struct se_cmd *se_cmd)
 {
 	struct vhost_scsi_cmd *tv_cmd = container_of(se_cmd,
 				struct vhost_scsi_cmd, tvc_se_cmd);
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_vq:
+	 *   - drivers/vhost/scsi.c|415| <<vhost_scsi_release_cmd_res>> struct vhost_scsi_virtqueue *svq = container_of(tv_cmd->tvc_vq,
+	 *                                    struct vhost_scsi_virtqueue, vq);
+	 *   - drivers/vhost/scsi.c|478| <<vhost_scsi_release_cmd>> struct vhost_scsi_virtqueue *svq = container_of(cmd->tvc_vq,
+	 *                                    struct vhost_scsi_virtqueue, vq);
+	 *   - drivers/vhost/scsi.c|734| <<vhost_scsi_complete_cmd_work>> v_rsp.resid = cpu_to_vhost32(cmd->tvc_vq, se_cmd->residual_count);
+	 *   - drivers/vhost/scsi.c|738| <<vhost_scsi_complete_cmd_work>> v_rsp.sense_len = cpu_to_vhost32(cmd->tvc_vq, se_cmd->scsi_sense_length);
+	 *   - drivers/vhost/scsi.c|778| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+	 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_handle_vq>> cmd->tvc_vq = vq;
+	 */
 	struct vhost_scsi_virtqueue *svq = container_of(tv_cmd->tvc_vq,
 				struct vhost_scsi_virtqueue, vq);
 	struct vhost_scsi_inflight *inflight = tv_cmd->inflight;
@@ -335,6 +727,11 @@ static void vhost_scsi_release_cmd_res(struct se_cmd *se_cmd)
 
 	if (tv_cmd->tvc_sgl_count) {
 		for (i = 0; i < tv_cmd->tvc_sgl_count; i++) {
+			/*
+			 * 在以下使用vhost_scsi_cmd->copied_iov:
+			 *   - drivers/vhost/scsi.c|374| <<vhost_scsi_release_cmd_res>> if (tv_cmd->copied_iov)
+			 *   - drivers/vhost/scsi.c|881| <<vhost_scsi_copy_iov_to_sgl>> cmd->copied_iov = 1;
+			 */
 			if (tv_cmd->copied_iov)
 				__free_page(sg_page(&tv_cmd->tvc_sgl[i]));
 			else
@@ -347,10 +744,29 @@ static void vhost_scsi_release_cmd_res(struct se_cmd *se_cmd)
 			put_page(sg_page(&tv_cmd->tvc_prot_sgl[i]));
 	}
 
+	/*
+	 * 在以下使用vhost_scsi_virtqueue->scsi_tags:
+	 *   - drivers/vhost/scsi.c|520| <<vhost_scsi_release_cmd_res>> sbitmap_clear_bit(&svq->scsi_tags, se_cmd->map_tag);
+	 *   - drivers/vhost/scsi.c|931| <<vhost_scsi_get_cmd>> tag = sbitmap_get(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2234| <<vhost_scsi_destroy_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2253| <<vhost_scsi_setup_vq_cmds>> if (sbitmap_init_node(&svq->scsi_tags, max_cmds, -1, GFP_KERNEL,
+	 *   - drivers/vhost/scsi.c|2268| <<vhost_scsi_setup_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 */
 	sbitmap_clear_bit(&svq->scsi_tags, se_cmd->map_tag);
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|521| <<vhost_scsi_release_cmd_res>> vhost_scsi_put_inflight(inflight);
+	 *   - drivers/vhost/scsi.c|529| <<vhost_scsi_release_tmf_res>> vhost_scsi_put_inflight(inflight);
+	 */
 	vhost_scsi_put_inflight(inflight);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|2328| <<vhost_scsi_tmf_resp_work>> vhost_scsi_release_tmf_res(tmf);
+ *   - drivers/vhost/scsi.c|2342| <<vhost_scsi_tmf_flush_work>> vhost_scsi_release_tmf_res(tmf);
+ *   - drivers/vhost/scsi.c|2396| <<vhost_scsi_handle_tmf>> vhost_scsi_release_tmf_res(tmf);
+ */
 static void vhost_scsi_release_tmf_res(struct vhost_scsi_tmf *tmf)
 {
 	struct vhost_scsi_inflight *inflight = tmf->inflight;
@@ -359,22 +775,45 @@ static void vhost_scsi_release_tmf_res(struct vhost_scsi_tmf *tmf)
 	vhost_scsi_put_inflight(inflight);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|462| <<vhost_scsi_release_cmd>> vhost_scsi_drop_cmds(svq);
+ */
 static void vhost_scsi_drop_cmds(struct vhost_scsi_virtqueue *svq)
 {
 	struct vhost_scsi_cmd *cmd, *t;
 	struct llist_node *llnode;
 
 	llnode = llist_del_all(&svq->completion_list);
+	/*
+	 * 在以下调用vhost_scsi_release_cmd_res():
+	 *   - drivers/vhost/scsi.c|405| <<vhost_scsi_drop_cmds>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+	 *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> vhost_scsi_release_cmd_res(se_cmd);
+	 *   - drivers/vhost/scsi.c|1549| <<vhost_scsi_handle_vq>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+	 *
+	 * 在以下使用vhost_scsi_cmd->tvc_completion_list:
+	 *   - drivers/vhost/scsi.c|614| <<vhost_scsi_drop_cmds>> llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list)
+	 *   - drivers/vhost/scsi.c|634| <<vhost_scsi_release_cmd>> llist_add(&cmd->tvc_completion_list, &svq->completion_list);
+	 *   - drivers/vhost/scsi.c|905| <<vhost_scsi_complete_cmd_work>> llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list) {
+	 */
 	llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list)
 		vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops.release_cmd = vhost_scsi_release_cmd()
+ */
 static void vhost_scsi_release_cmd(struct se_cmd *se_cmd)
 {
 	if (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) {
 		struct vhost_scsi_tmf *tmf = container_of(se_cmd,
 					struct vhost_scsi_tmf, se_cmd);
 
+		/*
+		 * 在以下使用vhost_scsi_tmf->flush_work:
+		 *   - drivers/vhost/scsi.c|724| <<vhost_scsi_release_cmd>> schedule_work(&tmf->flush_work);
+		 *   - drivers/vhost/scsi.c|2405| <<vhost_scsi_handle_tmf>> INIT_WORK(&tmf->flush_work, vhost_scsi_tmf_flush_work);
+		 */
 		schedule_work(&tmf->flush_work);
 	} else {
 		struct vhost_scsi_cmd *cmd = container_of(se_cmd,
@@ -382,12 +821,26 @@ static void vhost_scsi_release_cmd(struct se_cmd *se_cmd)
 		struct vhost_scsi_virtqueue *svq =  container_of(cmd->tvc_vq,
 					struct vhost_scsi_virtqueue, vq);
 
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_completion_list:
+		 *   - drivers/vhost/scsi.c|614| <<vhost_scsi_drop_cmds>> llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list)
+		 *   - drivers/vhost/scsi.c|634| <<vhost_scsi_release_cmd>> llist_add(&cmd->tvc_completion_list, &svq->completion_list);
+		 *   - drivers/vhost/scsi.c|905| <<vhost_scsi_complete_cmd_work>> llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list) {
+		 */
 		llist_add(&cmd->tvc_completion_list, &svq->completion_list);
+		/*
+		 * 在以下使用vhost_scsi_virtqueue->completion_work:
+		 *   - drivers/vhost/scsi.c|753| <<vhost_scsi_release_cmd>> if (!vhost_vq_work_queue(&svq->vq, &svq->completion_work))
+		 *   - drivers/vhost/scsi.c|3397| <<vhost_scsi_open>> vhost_work_init(&svq->completion_work, vhost_scsi_complete_cmd_work);
+		 */
 		if (!vhost_vq_work_queue(&svq->vq, &svq->completion_work))
 			vhost_scsi_drop_cmds(svq);
 	}
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_write_pending(struct se_cmd *se_cmd)
 {
 	/* Go ahead and process the write immediately */
@@ -395,18 +848,27 @@ static int vhost_scsi_write_pending(struct se_cmd *se_cmd)
 	return 0;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_queue_data_in(struct se_cmd *se_cmd)
 {
 	transport_generic_free_cmd(se_cmd, 0);
 	return 0;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_queue_status(struct se_cmd *se_cmd)
 {
 	transport_generic_free_cmd(se_cmd, 0);
 	return 0;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static void vhost_scsi_queue_tm_rsp(struct se_cmd *se_cmd)
 {
 	struct vhost_scsi_tmf *tmf = container_of(se_cmd, struct vhost_scsi_tmf,
@@ -416,17 +878,28 @@ static void vhost_scsi_queue_tm_rsp(struct se_cmd *se_cmd)
 	transport_generic_free_cmd(&tmf->se_cmd, 0);
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static void vhost_scsi_aborted_task(struct se_cmd *se_cmd)
 {
 	return;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|898| <<vhost_scsi_complete_events>> vhost_scsi_free_evt(vs, evt);
+ */
 static void vhost_scsi_free_evt(struct vhost_scsi *vs, struct vhost_scsi_evt *evt)
 {
 	vs->vs_events_nr--;
 	kfree(evt);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|2557| <<vhost_scsi_send_evt>> evt = vhost_scsi_allocate_evt(vs, event, reason);
+ */
 static struct vhost_scsi_evt *
 vhost_scsi_allocate_evt(struct vhost_scsi *vs,
 		       u32 event, u32 reason)
@@ -453,16 +926,48 @@ vhost_scsi_allocate_evt(struct vhost_scsi *vs,
 	return evt;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_check_stop_free(struct se_cmd *se_cmd)
 {
 	return target_put_sess_cmd(se_cmd);
 }
 
+/*
+ * 关于event queue的处理:
+ * vhost_scsi_send_evt()
+ * -> vhost_vq_work_queue(vq, &vs->vs_event_work)
+ *    -> vhost_scsi_evt_work()
+ *       -> vhost_scsi_complete_events(false)
+ *          -> vhost_scsi_do_evt_work()
+ *             -> __copy_to_user(eventp, event, sizeof(*event))
+ *             -> vhost_add_used_and_signal(&vs->dev, vq, head, 0);
+ *          -> vhost_scsi_free_evt()
+ *
+ * called by:
+ *   - drivers/vhost/scsi.c|521| <<vhost_scsi_complete_events>> vhost_scsi_do_evt_work(vs, evt);
+ */
 static void
 vhost_scsi_do_evt_work(struct vhost_scsi *vs, struct vhost_scsi_evt *evt)
 {
+	/*
+	 * struct vhost_scsi_evt {
+	 *     // event to be sent to guest
+	 *     struct virtio_scsi_event event;
+	 *     // event list, serviced from vhost worker thread
+	 *     struct llist_node list;
+	 * };
+	 */
 	struct vhost_virtqueue *vq = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;
 	struct virtio_scsi_event *event = &evt->event;
+	/*
+	 * struct virtio_scsi_event {
+	 *     __virtio32 event;
+	 *     __u8 lun[8];
+	 *     __virtio32 reason;
+	 * } __attribute__((packed));
+	 */
 	struct virtio_scsi_event __user *eventp;
 	unsigned out, in;
 	int head, ret;
@@ -474,6 +979,29 @@ vhost_scsi_do_evt_work(struct vhost_scsi *vs, struct vhost_scsi_evt *evt)
 
 again:
 	vhost_disable_notify(&vs->dev, vq);
+	/*
+	 * called by:
+	 *   - drivers/vhost/net.c|583| <<vhost_net_tx_get_vq_desc>> int r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+	 *   - drivers/vhost/net.c|595| <<vhost_net_tx_get_vq_desc>> r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+	 *   - drivers/vhost/net.c|1041| <<get_rx_bufs>> r = vhost_get_vq_desc(vq, vq->iov + seg, ARRAY_SIZE(vq->iov) - seg, &out, &in, log, log_num);
+	 *   - drivers/vhost/scsi.c|481| <<vhost_scsi_do_evt_work>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/scsi.c|966| <<vhost_scsi_get_desc>> vc->head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &vc->out, &vc->in, NULL, NULL);
+	 *   - drivers/vhost/test.c|61| <<handle_vq>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/vsock.c|127| <<vhost_transport_do_send_pkt>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/vsock.c|509| <<vhost_vsock_handle_tx_kick>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *
+	 * 注释:
+	 * This looks in the virtqueue and for the first available buffer, and converts
+	 * it to an iovec for convenient access.  Since descriptors consist of some
+	 * number of output then some number of input descriptors, it's actually two
+	 * iovecs, but we pack them into one and note how many of each there were.
+	 *
+	 * This function returns the descriptor number found, or vq->num (which is
+	 * never a valid descriptor number) if none was found.  A negative code is
+	 * returned on error.
+	 *
+	 * 返回值是这个request的在desc table中的head index
+	 */
 	head = vhost_get_vq_desc(vq, vq->iov,
 			ARRAY_SIZE(vq->iov), &out, &in,
 			NULL, NULL);
@@ -488,6 +1016,15 @@ vhost_scsi_do_evt_work(struct vhost_scsi *vs, struct vhost_scsi_evt *evt)
 		return;
 	}
 
+	/*
+	 * 上面的out应该是0
+	 * 可是你这里凭什么判断没有accross iov???
+	 * 根据translate_desc():
+	 * 给一个addr和len, 返回一个数组的iovec[]
+	 * 虽然是一个addr和一个len, 但是产生的iovec可能是多个
+	 * 一个地址和长度完了可以有多个iovec[]
+	 * 返回值: 最后产生的iovec[]的数目
+	 */
 	if ((vq->iov[out].iov_len != sizeof(struct virtio_scsi_event))) {
 		vq_err(vq, "Expecting virtio_scsi_event, got %zu bytes\n",
 				vq->iov[out].iov_len);
@@ -500,6 +1037,15 @@ vhost_scsi_do_evt_work(struct vhost_scsi *vs, struct vhost_scsi_evt *evt)
 		vs->vs_events_missed = false;
 	}
 
+	/*
+	 * struct virtio_scsi_event {
+	 *     __virtio32 event;
+	 *     __u8 lun[8];
+	 *     __virtio32 reason;
+	 * } __attribute__((packed));
+	 *
+	 * struct virtio_scsi_event __user *eventp;
+	 */
 	eventp = vq->iov[out].iov_base;
 	ret = __copy_to_user(eventp, event, sizeof(*event));
 	if (!ret)
@@ -508,6 +1054,15 @@ vhost_scsi_do_evt_work(struct vhost_scsi *vs, struct vhost_scsi_evt *evt)
 		vq_err(vq, "Faulted on vhost_scsi_send_event\n");
 }
 
+/*
+ * 在以下使用vhost_scsi->vs_event_work:
+ *   - drivers/vhost/scsi.c|1553| <<vhost_scsi_send_evt>> if (!vhost_vq_work_queue(vq, &vs->vs_event_work))
+ *   - drivers/vhost/scsi.c|1997| <<vhost_scsi_open>> vhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);
+ *
+ * called by:
+ *   - drivers/vhost/scsi.c|531| <<vhost_scsi_evt_work>> vhost_scsi_complete_events(vs, false);
+ *   - drivers/vhost/scsi.c|1533| <<vhost_scsi_send_evt>> vhost_scsi_complete_events(vs, true);
+ */
 static void vhost_scsi_complete_events(struct vhost_scsi *vs, bool drop)
 {
 	struct vhost_virtqueue *vq = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;
@@ -515,6 +1070,15 @@ static void vhost_scsi_complete_events(struct vhost_scsi *vs, bool drop)
 	struct llist_node *llnode;
 
 	mutex_lock(&vq->mutex);
+	/*
+	 * 在以下使用vhost_scsi->vs_event_work:
+	 *   - drivers/vhost/scsi.c|1553| <<vhost_scsi_send_evt>> if (!vhost_vq_work_queue(vq, &vs->vs_event_work))
+	 *   - drivers/vhost/scsi.c|1997| <<vhost_scsi_open>> vhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);
+	 *
+	 * 在以下使用vhost_scsi->vs_event_list:
+	 *   - drivers/vhost/scsi.c|527| <<vhost_scsi_complete_events>> llnode = llist_del_all(&vs->vs_event_list);
+	 *   - drivers/vhost/scsi.c|1552| <<vhost_scsi_send_evt>> llist_add(&evt->list, &vs->vs_event_list);
+	 */
 	llnode = llist_del_all(&vs->vs_event_list);
 	llist_for_each_entry_safe(evt, t, llnode, list) {
 		if (!drop)
@@ -524,6 +1088,24 @@ static void vhost_scsi_complete_events(struct vhost_scsi *vs, bool drop)
 	mutex_unlock(&vq->mutex);
 }
 
+/*
+ * 关于event queue的处理:
+ * vhost_scsi_send_evt()
+ * -> vhost_vq_work_queue(vq, &vs->vs_event_work)
+ *    -> vhost_scsi_evt_work()
+ *       -> vhost_scsi_complete_events(false)
+ *          -> vhost_scsi_do_evt_work()
+ *             -> __copy_to_user(eventp, event, sizeof(*event))
+ *             -> vhost_add_used_and_signal(&vs->dev, vq, head, 0);
+ *          -> vhost_scsi_free_evt()
+ *
+ * 在以下使用vhost_scsi->vs_event_work:
+ *   - drivers/vhost/scsi.c|1553| <<vhost_scsi_send_evt>> if (!vhost_vq_work_queue(vq, &vs->vs_event_work))
+ *   - drivers/vhost/scsi.c|1997| <<vhost_scsi_open>> vhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);
+ *
+ * 在以下使用vhost_scsi_evt_work():
+ *   - drivers/vhost/scsi.c|1997| <<vhost_scsi_open>> vhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);
+ */
 static void vhost_scsi_evt_work(struct vhost_work *work)
 {
 	struct vhost_scsi *vs = container_of(work, struct vhost_scsi,
@@ -533,6 +1115,11 @@ static void vhost_scsi_evt_work(struct vhost_work *work)
 
 static int vhost_scsi_copy_sgl_to_iov(struct vhost_scsi_cmd *cmd)
 {
+	/*
+	 * 在以下使用vhost_scsi_cmd->saved_iter:
+	 *   - drivers/vhost/scsi.c|822| <<vhost_scsi_copy_sgl_to_iov>> struct iov_iter *iter = &cmd->saved_iter;
+	 *   - drivers/vhost/scsi.c|1128| <<vhost_scsi_copy_iov_to_sgl>> cmd->saved_iter_addr = dup_iter(&cmd->saved_iter, iter, GFP_KERNEL);
+	 */
 	struct iov_iter *iter = &cmd->saved_iter;
 	struct scatterlist *sg = cmd->tvc_sgl;
 	struct page *page;
@@ -558,6 +1145,10 @@ static int vhost_scsi_copy_sgl_to_iov(struct vhost_scsi_cmd *cmd)
  * This is scheduled in the vhost work queue so we are called with the owner
  * process mm and can access the vring.
  */
+/*
+ * 在以下使用vhost_scsi_complete_cmd_work():
+ *   - drivers/vhost/scsi.c|2006| <<vhost_scsi_open>> vhost_work_init(&svq->completion_work, vhost_scsi_complete_cmd_work);
+ */
 static void vhost_scsi_complete_cmd_work(struct vhost_work *work)
 {
 	struct vhost_scsi_virtqueue *svq = container_of(work,
@@ -571,14 +1162,42 @@ static void vhost_scsi_complete_cmd_work(struct vhost_work *work)
 	int ret;
 
 	llnode = llist_del_all(&svq->completion_list);
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_completion_list:
+	 *   - drivers/vhost/scsi.c|614| <<vhost_scsi_drop_cmds>> llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list)
+	 *   - drivers/vhost/scsi.c|634| <<vhost_scsi_release_cmd>> llist_add(&cmd->tvc_completion_list, &svq->completion_list);
+	 *   - drivers/vhost/scsi.c|905| <<vhost_scsi_complete_cmd_work>> llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list) {
+	 *
+	 * struct vhost_scsi_cmd *cmd, *t;
+	 */
 	llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list) {
+		/*
+		 * struct se_cmd *se_cmd;
+		 */
 		se_cmd = &cmd->tvc_se_cmd;
 
 		pr_debug("%s tv_cmd %p resid %u status %#02x\n", __func__,
 			cmd, se_cmd->residual_count, se_cmd->scsi_status);
+		/*
+		 * struct virtio_scsi_cmd_resp {
+		 *     __virtio32 sense_len;           // Sense data length
+		 *     __virtio32 resid;               // Residual bytes in data buffer
+		 *     __virtio16 status_qualifier;    // Status qualifier
+		 *     __u8 status;            // Command completion status
+		 *     __u8 response;          // Response values
+		 *     __u8 sense[VIRTIO_SCSI_SENSE_SIZE];
+		 * } __attribute__((packed));
+		 */
 		memset(&v_rsp, 0, sizeof(v_rsp));
 
 		if (cmd->saved_iter_addr && vhost_scsi_copy_sgl_to_iov(cmd)) {
+			/*
+			 * 在以下使用VIRTIO_SCSI_S_BAD_TARGET:
+			 *   - drivers/scsi/virtio_scsi.c|193| <<virtscsi_complete_cmd>> case VIRTIO_SCSI_S_BAD_TARGET:
+			 *   - drivers/scsi/virtio_scsi.c|879| <<virtscsi_queuecommand>> cmd->resp.cmd.response = VIRTIO_SCSI_S_BAD_TARGET;
+			 *   - drivers/vhost/scsi.c|1111| <<vhost_scsi_complete_cmd_work>> v_rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
+			 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_send_bad_target>> rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
+			 */
 			v_rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
 		} else {
 			v_rsp.resid = cpu_to_vhost32(cmd->tvc_vq,
@@ -591,16 +1210,60 @@ static void vhost_scsi_complete_cmd_work(struct vhost_work *work)
 			       se_cmd->scsi_sense_length);
 		}
 
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_resp_iov:
+		 *   - drivers/vhost/scsi.c|687| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST, cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+		 *   - drivers/vhost/scsi.c|751| <<vhost_scsi_get_cmd>> tvc_resp_iov = cmd->tvc_resp_iov;
+		 *   - drivers/vhost/scsi.c|764| <<vhost_scsi_get_cmd>> cmd->tvc_resp_iov = tvc_resp_iov;
+		 *   - drivers/vhost/scsi.c|1599| <<vhost_scsi_handle_vq>> cmd->tvc_resp_iov[i] = vq->iov[vc.out + i];
+		 *   - drivers/vhost/scsi.c|2015| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_resp_iov);
+		 *   - drivers/vhost/scsi.c|2075| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_resp_iov = kcalloc(UIO_MAXIOV, sizeof(struct iovec), GFP_KERNEL);
+		 *   - drivers/vhost/scsi.c|2078| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_resp_iov) {
+		 *
+		 * 注释: Pointer to response header iovec
+		 *
+		 *
+		 * 在以下使用vhost_scsi_cmd->tvc_in_iovs:
+		 *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST,
+		 *                  cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+		 *   - drivers/vhost/scsi.c|1600| <<vhost_scsi_handle_vq>> cmd->tvc_in_iovs = vc.in;
+		 */
 		iov_iter_init(&iov_iter, ITER_DEST, cmd->tvc_resp_iov,
 			      cmd->tvc_in_iovs, sizeof(v_rsp));
+		/*
+		 * struct virtio_scsi_cmd_resp v_rsp;
+		 */
 		ret = copy_to_iter(&v_rsp, sizeof(v_rsp), &iov_iter);
 		if (likely(ret == sizeof(v_rsp))) {
 			signal = true;
 
+			/*
+			 * 在以下使用vhost_scsi_cmd->tvc_vq:
+			 *   - drivers/vhost/scsi.c|415| <<vhost_scsi_release_cmd_res>> struct vhost_scsi_virtqueue *svq = container_of(tv_cmd->tvc_vq,
+			 *                                    struct vhost_scsi_virtqueue, vq);
+			 *   - drivers/vhost/scsi.c|478| <<vhost_scsi_release_cmd>> struct vhost_scsi_virtqueue *svq = container_of(cmd->tvc_vq,
+			 *                                    struct vhost_scsi_virtqueue, vq);
+			 *   - drivers/vhost/scsi.c|734| <<vhost_scsi_complete_cmd_work>> v_rsp.resid = cpu_to_vhost32(cmd->tvc_vq, se_cmd->residual_count);
+			 *   - drivers/vhost/scsi.c|738| <<vhost_scsi_complete_cmd_work>> v_rsp.sense_len = cpu_to_vhost32(cmd->tvc_vq, se_cmd->scsi_sense_length);
+			 *   - drivers/vhost/scsi.c|778| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+			 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_handle_vq>> cmd->tvc_vq = vq;
+			 *
+			 * 在以下使用vhost_scsi_cmd->tvc_vq_desc:
+			 *   - drivers/vhost/scsi.c|670| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+			 *   - drivers/vhost/scsi.c|1471| <<vhost_scsi_handle_vq>> cmd->tvc_vq_desc = vc.head;
+			 *
+			 * 注释: Descriptor from vhost_get_vq_desc() for virt_queue segment
+			 */
 			vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
 		} else
 			pr_err("Faulted on virtio_scsi_cmd_resp\n");
 
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|405| <<vhost_scsi_drop_cmds>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+		 *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> vhost_scsi_release_cmd_res(se_cmd);
+		 *   - drivers/vhost/scsi.c|1549| <<vhost_scsi_handle_vq>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+		 */
 		vhost_scsi_release_cmd_res(se_cmd);
 	}
 
@@ -608,6 +1271,14 @@ static void vhost_scsi_complete_cmd_work(struct vhost_work *work)
 		vhost_signal(&svq->vs->dev, &svq->vq);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1260| <<vhost_scsi_handle_vq>> cmd = vhost_scsi_get_cmd(vq, tpg, cdb, tag,
+ *          lun, task_attr, exp_data_len + prot_bytes, data_direction);
+ *
+ * 核心思想是返回cmd = &svq->scsi_cmds[tag];
+ * 简单的初始化, 然后: memcpy(cmd->tvc_cdb, cdb, VHOST_SCSI_MAX_CDB_SIZE);
+ */
 static struct vhost_scsi_cmd *
 vhost_scsi_get_cmd(struct vhost_virtqueue *vq, struct vhost_scsi_tpg *tpg,
 		   unsigned char *cdb, u64 scsi_tag, u16 lun, u8 task_attr,
@@ -628,6 +1299,14 @@ vhost_scsi_get_cmd(struct vhost_virtqueue *vq, struct vhost_scsi_tpg *tpg,
 		return ERR_PTR(-EIO);
 	}
 
+	/*
+	 * 在以下使用vhost_scsi_virtqueue->scsi_tags:
+	 *   - drivers/vhost/scsi.c|520| <<vhost_scsi_release_cmd_res>> sbitmap_clear_bit(&svq->scsi_tags, se_cmd->map_tag);
+	 *   - drivers/vhost/scsi.c|931| <<vhost_scsi_get_cmd>> tag = sbitmap_get(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2234| <<vhost_scsi_destroy_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2253| <<vhost_scsi_setup_vq_cmds>> if (sbitmap_init_node(&svq->scsi_tags, max_cmds, -1, GFP_KERNEL,
+	 *   - drivers/vhost/scsi.c|2268| <<vhost_scsi_setup_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 */
 	tag = sbitmap_get(&svq->scsi_tags);
 	if (tag < 0) {
 		pr_err("Unable to obtain tag for vhost_scsi_cmd\n");
@@ -637,8 +1316,21 @@ vhost_scsi_get_cmd(struct vhost_virtqueue *vq, struct vhost_scsi_tpg *tpg,
 	cmd = &svq->scsi_cmds[tag];
 	sg = cmd->tvc_sgl;
 	prot_sg = cmd->tvc_prot_sgl;
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_upages:
+	 *   - drivers/vhost/scsi.c|997| <<vhost_scsi_get_cmd>> pages = cmd->tvc_upages;
+	 *   - drivers/vhost/scsi.c|1002| <<vhost_scsi_get_cmd>> cmd->tvc_upages = pages;
+	 *   - drivers/vhost/scsi.c|1033| <<vhost_scsi_map_to_sgl>> struct page **pages = cmd->tvc_upages;
+	 *   - drivers/vhost/scsi.c|2460| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_upages);
+	 *   - drivers/vhost/scsi.c|2513| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_upages = kcalloc(VHOST_SCSI_PREALLOC_UPAGES,
+	 *                                         sizeof(struct page *), GFP_KERNEL);
+	 *   - drivers/vhost/scsi.c|2516| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_upages) {
+	 */
 	pages = cmd->tvc_upages;
 	tvc_resp_iov = cmd->tvc_resp_iov;
+	/*
+	 * 这里对command进行了清0
+	 */
 	memset(cmd, 0, sizeof(*cmd));
 	cmd->tvc_sgl = sg;
 	cmd->tvc_prot_sgl = prot_sg;
@@ -651,6 +1343,20 @@ vhost_scsi_get_cmd(struct vhost_virtqueue *vq, struct vhost_scsi_tpg *tpg,
 	cmd->tvc_data_direction = data_direction;
 	cmd->tvc_nexus = tv_nexus;
 	cmd->inflight = vhost_scsi_get_inflight(vq);
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_resp_iov:
+	 *   - drivers/vhost/scsi.c|687| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST, cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+	 *   - drivers/vhost/scsi.c|751| <<vhost_scsi_get_cmd>> tvc_resp_iov = cmd->tvc_resp_iov;
+	 *   - drivers/vhost/scsi.c|764| <<vhost_scsi_get_cmd>> cmd->tvc_resp_iov = tvc_resp_iov;
+	 *   - drivers/vhost/scsi.c|1599| <<vhost_scsi_handle_vq>> cmd->tvc_resp_iov[i] = vq->iov[vc.out + i];
+	 *   - drivers/vhost/scsi.c|2015| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_resp_iov);
+	 *   - drivers/vhost/scsi.c|2075| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_resp_iov = kcalloc(UIO_MAXIOV, sizeof(struct iovec), GFP_KERNEL);
+	 *   - drivers/vhost/scsi.c|2078| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_resp_iov) {
+	 *
+	 * 注释: Pointer to response header iovec
+	 * 存储的所有的response(header和数据的)iov, 是一对一的copy
+	 * 不是指针
+	 */
 	cmd->tvc_resp_iov = tvc_resp_iov;
 
 	memcpy(cmd->tvc_cdb, cdb, VHOST_SCSI_MAX_CDB_SIZE);
@@ -663,12 +1369,26 @@ vhost_scsi_get_cmd(struct vhost_virtqueue *vq, struct vhost_scsi_tpg *tpg,
  *
  * Returns the number of scatterlist entries used or -errno on error.
  */
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|838| <<vhost_scsi_map_iov_to_sgl>> ret = vhost_scsi_map_to_sgl(cmd, iter, sg, is_prot);
+ */
 static int
 vhost_scsi_map_to_sgl(struct vhost_scsi_cmd *cmd,
 		      struct iov_iter *iter,
 		      struct scatterlist *sgl,
 		      bool is_prot)
 {
+	/*
+	 * 在以下使用vhost_scsi_cmd->tvc_upages:
+	 *   - drivers/vhost/scsi.c|997| <<vhost_scsi_get_cmd>> pages = cmd->tvc_upages;
+	 *   - drivers/vhost/scsi.c|1002| <<vhost_scsi_get_cmd>> cmd->tvc_upages = pages;
+	 *   - drivers/vhost/scsi.c|1033| <<vhost_scsi_map_to_sgl>> struct page **pages = cmd->tvc_upages;
+	 *   - drivers/vhost/scsi.c|2460| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_upages);
+	 *   - drivers/vhost/scsi.c|2513| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_upages = kcalloc(VHOST_SCSI_PREALLOC_UPAGES,
+	 *                                         sizeof(struct page *), GFP_KERNEL);
+	 *   - drivers/vhost/scsi.c|2516| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_upages) {
+	 */
 	struct page **pages = cmd->tvc_upages;
 	struct scatterlist *sg = sgl;
 	ssize_t bytes, mapped_bytes;
@@ -730,6 +1450,13 @@ vhost_scsi_map_to_sgl(struct vhost_scsi_cmd *cmd,
 	return -EINVAL;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1218| <<vhost_scsi_mapal>> sgl_count = vhost_scsi_calc_sgls(prot_iter, prot_bytes, VHOST_SCSI_PREALLOC_PROT_SGLS);
+ *   - drivers/vhost/scsi.c|1236| <<vhost_scsi_mapal>> sgl_count = vhost_scsi_calc_sgls(data_iter, data_bytes, VHOST_SCSI_PREALLOC_SGLS);
+ *
+ * 根据iov_iter来计算sgl的数目
+ */
 static int
 vhost_scsi_calc_sgls(struct iov_iter *iter, size_t bytes, int max_sgls)
 {
@@ -750,6 +1477,10 @@ vhost_scsi_calc_sgls(struct iov_iter *iter, size_t bytes, int max_sgls)
 	return sgl_count;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|975| <<vhost_scsi_mapal>> ret = vhost_scsi_copy_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl, cmd->tvc_sgl_count);
+ */
 static int
 vhost_scsi_copy_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,
 			   struct scatterlist *sg, int sg_count)
@@ -760,6 +1491,11 @@ vhost_scsi_copy_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,
 	int i;
 
 	if (cmd->tvc_data_direction == DMA_FROM_DEVICE) {
+		/*
+		 * 在以下使用vhost_scsi_cmd->saved_iter:
+		 *   - drivers/vhost/scsi.c|822| <<vhost_scsi_copy_sgl_to_iov>> struct iov_iter *iter = &cmd->saved_iter;
+		 *   - drivers/vhost/scsi.c|1128| <<vhost_scsi_copy_iov_to_sgl>> cmd->saved_iter_addr = dup_iter(&cmd->saved_iter, iter, GFP_KERNEL);
+		 */
 		cmd->saved_iter_addr = dup_iter(&cmd->saved_iter, iter,
 						GFP_KERNEL);
 		if (!cmd->saved_iter_addr)
@@ -783,6 +1519,11 @@ vhost_scsi_copy_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,
 		len -= nbytes;
 	}
 
+	/*
+	 * 在以下使用vhost_scsi_cmd->copied_iov:
+	 *   - drivers/vhost/scsi.c|374| <<vhost_scsi_release_cmd_res>> if (tv_cmd->copied_iov)
+	 *   - drivers/vhost/scsi.c|881| <<vhost_scsi_copy_iov_to_sgl>> cmd->copied_iov = 1;
+	 */
 	cmd->copied_iov = 1;
 	return 0;
 
@@ -796,6 +1537,11 @@ vhost_scsi_copy_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,
 	return -ENOMEM;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|879| <<vhost_scsi_mapal>> ret = vhost_scsi_map_iov_to_sgl(cmd, prot_iter, cmd->tvc_prot_sgl, cmd->tvc_prot_sgl_count, true);
+ *   - drivers/vhost/scsi.c|897| <<vhost_scsi_mapal>> ret = vhost_scsi_map_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl, cmd->tvc_sgl_count, false);
+ */
 static int
 vhost_scsi_map_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,
 			  struct scatterlist *sg, int sg_count, bool is_prot)
@@ -828,6 +1574,10 @@ vhost_scsi_map_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1280| <<vhost_scsi_handle_vq>> if (unlikely(vhost_scsi_mapal(cmd, prot_bytes, &prot_iter, exp_data_len, &data_iter))) {
+ */
 static int
 vhost_scsi_mapal(struct vhost_scsi_cmd *cmd,
 		 size_t prot_bytes, struct iov_iter *prot_iter,
@@ -836,6 +1586,13 @@ vhost_scsi_mapal(struct vhost_scsi_cmd *cmd,
 	int sgl_count, ret;
 
 	if (prot_bytes) {
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|1218| <<vhost_scsi_mapal>> sgl_count = vhost_scsi_calc_sgls(prot_iter, prot_bytes, VHOST_SCSI_PREALLOC_PROT_SGLS);
+		 *   - drivers/vhost/scsi.c|1236| <<vhost_scsi_mapal>> sgl_count = vhost_scsi_calc_sgls(data_iter, data_bytes, VHOST_SCSI_PREALLOC_SGLS);
+		 *
+		 * 根据iov_iter来计算sgl的数目
+		 */
 		sgl_count = vhost_scsi_calc_sgls(prot_iter, prot_bytes,
 						 VHOST_SCSI_PREALLOC_PROT_SGLS);
 		if (sgl_count < 0)
@@ -854,20 +1611,47 @@ vhost_scsi_mapal(struct vhost_scsi_cmd *cmd,
 			return ret;
 		}
 	}
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|1218| <<vhost_scsi_mapal>> sgl_count = vhost_scsi_calc_sgls(prot_iter, prot_bytes, VHOST_SCSI_PREALLOC_PROT_SGLS);
+	 *   - drivers/vhost/scsi.c|1236| <<vhost_scsi_mapal>> sgl_count = vhost_scsi_calc_sgls(data_iter, data_bytes, VHOST_SCSI_PREALLOC_SGLS);
+	 *
+	 * 根据iov_iter来计算sgl的数目
+	 */
 	sgl_count = vhost_scsi_calc_sgls(data_iter, data_bytes,
 					 VHOST_SCSI_PREALLOC_SGLS);
 	if (sgl_count < 0)
 		return sgl_count;
 
+	/*
+	 * struct vhost_scsi_cmd *cmd:
+	 * -> u32 tvc_sgl_count;
+	 * -> u32 tvc_prot_sgl_count;
+	 * -> struct scatterlist *tvc_sgl;
+	 * -> struct scatterlist *tvc_prot_sgl;
+	 */
 	sg_init_table(cmd->tvc_sgl, sgl_count);
 	cmd->tvc_sgl_count = sgl_count;
 	pr_debug("%s data_sg %p data_sgl_count %u\n", __func__,
 		  cmd->tvc_sgl, cmd->tvc_sgl_count);
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|879| <<vhost_scsi_mapal>> ret = vhost_scsi_map_iov_to_sgl(cmd, prot_iter, cmd->tvc_prot_sgl, cmd->tvc_prot_sgl_count, true);
+	 *   - drivers/vhost/scsi.c|897| <<vhost_scsi_mapal>> ret = vhost_scsi_map_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl, cmd->tvc_sgl_count, false);
+	 */
 	ret = vhost_scsi_map_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl,
 					cmd->tvc_sgl_count, false);
 	if (ret == -EINVAL) {
 		sg_init_table(cmd->tvc_sgl, cmd->tvc_sgl_count);
+		/*
+		 * 不同:
+		 * 在以下使用vhost_scsi_cmd->copied_iov:
+		 *   - drivers/vhost/scsi.c|374| <<vhost_scsi_release_cmd_res>> if (tv_cmd->copied_iov)
+		 *   - drivers/vhost/scsi.c|881| <<vhost_scsi_copy_iov_to_sgl>> cmd->copied_iov = 1;
+		 *
+		 * 只在此处调用
+		 */
 		ret = vhost_scsi_copy_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl,
 						 cmd->tvc_sgl_count);
 	}
@@ -896,6 +1680,10 @@ static int vhost_scsi_to_tcm_attr(int attr)
 	return TCM_SIMPLE_TAG;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1472| <<vhost_scsi_handle_vq>> vhost_scsi_target_queue_cmd(cmd);
+ */
 static void vhost_scsi_target_queue_cmd(struct vhost_scsi_cmd *cmd)
 {
 	struct se_cmd *se_cmd = &cmd->tvc_se_cmd;
@@ -916,19 +1704,69 @@ static void vhost_scsi_target_queue_cmd(struct vhost_scsi_cmd *cmd)
 	tv_nexus = cmd->tvc_nexus;
 
 	se_cmd->tag = 0;
+	/*
+	 * called by:
+	 *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1596| <<srpt_handle_cmd>> rc = target_init_cmd(cmd, ch->sess, &send_ioctx->sense_data[0],
+	 *   - drivers/scsi/elx/efct/efct_lio.c|1381| <<efct_scsi_recv_cmd>> rc = target_init_cmd(se_cmd, se_sess, &io->tgt_io.sense_buffer[0],
+	 *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|479| <<tcm_qla2xxx_handle_cmd>> rc = target_init_cmd(se_cmd, se_sess, &cmd->sense_buffer[0],
+	 *   - drivers/target/loopback/tcm_loop.c|147| <<tcm_loop_target_queue_cmd>> target_init_cmd(se_cmd, tl_nexus->se_sess, &tl_cmd->tl_sense_buf[0],
+	 *   - drivers/target/target_core_transport.c|1836| <<target_submit_cmd>> rc = target_init_cmd(se_cmd, se_sess, sense, unpacked_lun, data_length,
+	 *   - drivers/target/tcm_fc/tfc_cmd.c|546| <<ft_send_work>> if (target_init_cmd(&cmd->se_cmd, cmd->sess->se_sess,
+	 *   - drivers/vhost/scsi.c|1009| <<vhost_scsi_target_queue_cmd>> target_init_cmd(se_cmd, tv_nexus->tvn_se_sess, &cmd->tvc_sense_buf[0],
+	 *   - drivers/xen/xen-scsiback.c|428| <<scsiback_cmd_exec>> target_init_cmd(se_cmd, sess, pending_req->sense_buffer,
+	 */
 	target_init_cmd(se_cmd, tv_nexus->tvn_se_sess, &cmd->tvc_sense_buf[0],
 			cmd->tvc_lun, cmd->tvc_exp_data_len,
 			vhost_scsi_to_tcm_attr(cmd->tvc_task_attr),
 			cmd->tvc_data_direction, TARGET_SCF_ACK_KREF);
 
+	/*
+	 * called by:
+	 *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1605| <<srpt_handle_cmd>> if (target_submit_prep(cmd, srp_cmd->cdb, sg, sg_cnt, NULL, 0, NULL, 0,
+	 *   - drivers/scsi/elx/efct/efct_lio.c|1390| <<efct_scsi_recv_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0,
+	 *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|485| <<tcm_qla2xxx_handle_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0, NULL, 0,
+	 *   - drivers/target/loopback/tcm_loop.c|151| <<tcm_loop_target_queue_cmd>> if (target_submit_prep(se_cmd, sc->cmnd, scsi_sglist(sc),
+	 *   - drivers/target/target_core_transport.c|1853| <<target_submit_cmd>> if (target_submit_prep(se_cmd, cdb, NULL, 0, NULL, 0, NULL, 0,
+	 *   - drivers/target/tcm_fc/tfc_cmd.c|552| <<ft_send_work>> if (target_submit_prep(&cmd->se_cmd, fcp->fc_cdb, NULL, 0, NULL, 0,
+	 *   - drivers/vhost/scsi.c|1032| <<vhost_scsi_target_queue_cmd>> if (target_submit_prep(se_cmd, cmd->tvc_cdb, sg_ptr,
+	 *   - drivers/xen/xen-scsiback.c|432| <<scsiback_cmd_exec>> if (target_submit_prep(se_cmd, pending_req->cmnd, pending_req->sgl,
+	 */
 	if (target_submit_prep(se_cmd, cmd->tvc_cdb, sg_ptr,
 			       cmd->tvc_sgl_count, NULL, 0, sg_prot_ptr,
 			       cmd->tvc_prot_sgl_count, GFP_KERNEL))
 		return;
 
+	/*
+	 * called by:
+	 *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1609| <<srpt_handle_cmd>> target_submit(cmd);
+	 *   - drivers/scsi/elx/efct/efct_lio.c|1394| <<efct_scsi_recv_cmd>> target_submit(se_cmd);
+	 *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|489| <<tcm_qla2xxx_handle_cmd>> target_submit(se_cmd);
+	 *   - drivers/target/iscsi/iscsi_target_erl1.c|950| <<iscsit_execute_cmd>> return target_submit(&cmd->se_cmd);
+	 *   - drivers/target/iscsi/iscsi_target_tmr.c|321| <<iscsit_task_reassign_complete_read>> target_submit(se_cmd);
+	 *   - drivers/target/loopback/tcm_loop.c|157| <<tcm_loop_target_queue_cmd>> target_submit(se_cmd);
+	 *   - drivers/target/target_core_transport.c|1857| <<target_submit_cmd>> target_submit(se_cmd);
+	 *   - drivers/target/tcm_fc/tfc_cmd.c|556| <<ft_send_work>> target_submit(&cmd->se_cmd);
+	 *   - drivers/vhost/scsi.c|1037| <<vhost_scsi_target_queue_cmd>> target_submit(se_cmd);
+	 *   - drivers/xen/xen-scsiback.c|436| <<scsiback_cmd_exec>> target_submit(se_cmd);
+	 */
 	target_submit(se_cmd);
 }
 
+/*
+ * 如果是READ的
+ * sgs[0] : request header
+ * sgs[1] : response header
+ * sgs[2] : sc->sdb.table.sgl (in buffer)
+ *
+ * 如果是WRITE的
+ * sgs[0] : request header
+ * sgs[1] : sc->sdb.table.sgl (out buffer)
+ * sgs[2] : response header
+ *
+ * called by:
+ *   - drivers/vhost/scsi.c|1920| <<vhost_scsi_handle_vq>> vhost_scsi_send_bad_target(vs, vq, vc.head, vc.out);
+ *   - drivers/vhost/scsi.c|2163| <<vhost_scsi_ctl_handle_vq>> vhost_scsi_send_bad_target(vs, vq, vc.head, vc.out);
+ */
 static void
 vhost_scsi_send_bad_target(struct vhost_scsi *vs,
 			   struct vhost_virtqueue *vq,
@@ -938,22 +1776,96 @@ vhost_scsi_send_bad_target(struct vhost_scsi *vs,
 	struct virtio_scsi_cmd_resp rsp;
 	int ret;
 
+	/*
+	 * 在以下使用VIRTIO_SCSI_S_BAD_TARGET:
+	 *   - drivers/scsi/virtio_scsi.c|193| <<virtscsi_complete_cmd>> case VIRTIO_SCSI_S_BAD_TARGET:
+	 *   - drivers/scsi/virtio_scsi.c|879| <<virtscsi_queuecommand>> cmd->resp.cmd.response = VIRTIO_SCSI_S_BAD_TARGET;
+	 *   - drivers/vhost/scsi.c|1111| <<vhost_scsi_complete_cmd_work>> v_rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
+	 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_send_bad_target>> rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
+	 */
 	memset(&rsp, 0, sizeof(rsp));
 	rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
+	/*
+	 * vhost_scsi_send_an_resp()用的copy_to_iter()
+	 * vhost_scsi_send_bad_target()直接拷贝
+	 * 耍猴呢???!!!
+	 *
+	 * struct vhost_virtqueue *vq:
+	 * -> struct iovec iov[UIO_MAXIOV];
+	 *
+	 * 17 struct iovec
+	 * 18 {        
+	 * 19         void __user *iov_base;  // BSD uses caddr_t (1003.1g requires void *)
+	 * 20         __kernel_size_t iov_len; // Must be size_t (1003.1g)
+	 * 21 };
+	 */
 	resp = vq->iov[out].iov_base;
 	ret = __copy_to_user(resp, &rsp, sizeof(rsp));
+	/*
+	 * called by:
+	 *   - drivers/vhost/net.c|931| <<handle_tx_zerocopy>> vhost_add_used_and_signal(&net->dev, vq, head, 0);
+	 *   - drivers/vhost/scsi.c|510| <<vhost_scsi_do_evt_work>> vhost_add_used_and_signal(&vs->dev, vq, head, 0);
+	 *   - drivers/vhost/scsi.c|955| <<vhost_scsi_send_bad_target>> vhost_add_used_and_signal(&vs->dev, vq, head, 0);
+	 *   - drivers/vhost/scsi.c|1293| <<vhost_scsi_send_tmf_resp>> vhost_add_used_and_signal(&vs->dev, vq, vq_desc, 0);
+	 *   - drivers/vhost/scsi.c|1392| <<vhost_scsi_send_an_resp>> vhost_add_used_and_signal(&vs->dev, vq, vc->head, 0);
+	 *   - drivers/vhost/test.c|87| <<handle_vq>> vhost_add_used_and_signal(&n->dev, vq, head, 0);
+	 */
 	if (!ret)
 		vhost_add_used_and_signal(&vs->dev, vq, head, 0);
 	else
 		pr_err("Faulted on virtio_scsi_cmd_resp\n");
 }
 
+/*
+ * struct vhost_scsi_ctx {
+ *     int head;
+ *     unsigned int out, in;
+ *     size_t req_size, rsp_size;
+ *     size_t out_size, in_size;
+ *     u8 *target, *lunp;
+ *     void *req;
+ *     struct iov_iter out_iter;
+ * };
+ *
+ * called by:
+ *   - drivers/vhost/scsi.c|1193| <<vhost_scsi_handle_vq>> ret = vhost_scsi_get_desc(vs, vq, &vc);
+ *   - drivers/vhost/scsi.c|1526| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_get_desc(vs, vq, &vc);
+ */
 static int
 vhost_scsi_get_desc(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 		    struct vhost_scsi_ctx *vc)
 {
 	int ret = -ENXIO;
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/net.c|583| <<vhost_net_tx_get_vq_desc>> int r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+	 *   - drivers/vhost/net.c|595| <<vhost_net_tx_get_vq_desc>> r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+	 *   - drivers/vhost/net.c|1041| <<get_rx_bufs>> r = vhost_get_vq_desc(vq, vq->iov + seg, ARRAY_SIZE(vq->iov) - seg, &out, &in, log, log_num);
+	 *   - drivers/vhost/scsi.c|481| <<vhost_scsi_do_evt_work>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/scsi.c|966| <<vhost_scsi_get_desc>> vc->head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &vc->out, &vc->in, NULL, NULL);
+	 *   - drivers/vhost/test.c|61| <<handle_vq>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/vsock.c|127| <<vhost_transport_do_send_pkt>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *   - drivers/vhost/vsock.c|509| <<vhost_vsock_handle_tx_kick>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+	 *
+	 * 注释:
+	 * This looks in the virtqueue and for the first available buffer, and converts
+	 * it to an iovec for convenient access.  Since descriptors consist of some
+	 * number of output then some number of input descriptors, it's actually two
+	 * iovecs, but we pack them into one and note how many of each there were.
+	 *
+	 * This function returns the descriptor number found, or vq->num (which is
+	 * never a valid descriptor number) if none was found.  A negative code is
+	 * returned on error.
+	 *
+	 * 返回值是这个request的在desc table中的head index
+	 *
+	 * 里面会调用translate_desc().
+	 * 给一个addr和len, 返回一个数组的iovec[]
+	 * 虽然是一个addr和一个len, 但是产生的iovec可能是多个
+	 * 一个地址和长度完了可以有多个iovec[]
+	 * 返回值: 最后产生的iovec[]的数目
+	 */
 	vc->head = vhost_get_vq_desc(vq, vq->iov,
 				     ARRAY_SIZE(vq->iov), &vc->out, &vc->in,
 				     NULL, NULL);
@@ -978,6 +1890,15 @@ vhost_scsi_get_desc(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 	 * Get the size of request and response buffers.
 	 * FIXME: Not correct for BIDI operation
 	 */
+	/*
+	 * 在以下设置vhost_scsi_ctx->in_size:
+	 *   - drivers/vhost/scsi.c|1826| <<vhost_scsi_get_desc>> vc->in_size = iov_length(&vq->iov[vc->out], vc->in);
+	 * 在以下使用vhost_scsi_ctx->in_size:
+	 *   - drivers/vhost/scsi.c|1860| <<vhost_scsi_chk_size>> if (unlikely(vc->in_size < vc->rsp_size)) {
+	 *   - drivers/vhost/scsi.c|1863| <<vhost_scsi_chk_size>> vq_err(vq, ... vc->rsp_size, vc->in_size);
+	 *   - drivers/vhost/scsi.c|2142| <<vhost_scsi_handle_vq>> } else if (vc.in_size > vc.rsp_size) {
+	 *   - drivers/vhost/scsi.c|2147| <<vhost_scsi_handle_vq>> exp_data_len = vc.in_size - vc.rsp_size;
+	 */
 	vc->out_size = iov_length(vq->iov, vc->out);
 	vc->in_size = iov_length(&vq->iov[vc->out], vc->in);
 
@@ -991,6 +1912,13 @@ vhost_scsi_get_desc(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 	 * point at the start of the outgoing WRITE payload, if
 	 * DMA_TO_DEVICE is set.
 	 */
+	/*
+	 * 在以下使用vhost_scsi_ctx->out_iter:
+	 *   - drivers/vhost/scsi.c|1071| <<vhost_scsi_get_desc>> iov_iter_init(&vc->out_iter, ITER_SOURCE, vq->iov, vc->out, vc->out_size);
+	 *   - drivers/vhost/scsi.c|1103| <<vhost_scsi_get_req>> if (unlikely(!copy_from_iter_full(vc->req, vc->req_size, &vc->out_iter))) {
+	 *   - drivers/vhost/scsi.c|1284| <<vhost_scsi_handle_vq>> data_iter = vc.out_iter;
+	 *   - drivers/vhost/scsi.c|1574| <<vhost_scsi_ctl_handle_vq>> if (unlikely(!copy_from_iter_full(vc.req, typ_size, &vc.out_iter))) {
+	 */
 	iov_iter_init(&vc->out_iter, ITER_SOURCE, vq->iov, vc->out, vc->out_size);
 	ret = 0;
 
@@ -998,9 +1926,23 @@ vhost_scsi_get_desc(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 	return ret;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1680| <<vhost_scsi_handle_vq>> ret = vhost_scsi_chk_size(vq, &vc);
+ *   - drivers/vhost/scsi.c|2130| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_chk_size(vq, &vc);
+ */
 static int
 vhost_scsi_chk_size(struct vhost_virtqueue *vq, struct vhost_scsi_ctx *vc)
 {
+	/*
+	 * 在以下设置vhost_scsi_ctx->in_size:
+	 *   - drivers/vhost/scsi.c|1826| <<vhost_scsi_get_desc>> vc->in_size = iov_length(&vq->iov[vc->out], vc->in);
+	 * 在以下使用vhost_scsi_ctx->in_size:
+	 *   - drivers/vhost/scsi.c|1860| <<vhost_scsi_chk_size>> if (unlikely(vc->in_size < vc->rsp_size)) {
+	 *   - drivers/vhost/scsi.c|1863| <<vhost_scsi_chk_size>> vq_err(vq, ... vc->rsp_size, vc->in_size);
+	 *   - drivers/vhost/scsi.c|2142| <<vhost_scsi_handle_vq>> } else if (vc.in_size > vc.rsp_size) {
+	 *   - drivers/vhost/scsi.c|2147| <<vhost_scsi_handle_vq>> exp_data_len = vc.in_size - vc.rsp_size;
+	 */
 	if (unlikely(vc->in_size < vc->rsp_size)) {
 		vq_err(vq,
 		       "Response buf too small, need min %zu bytes got %zu",
@@ -1016,12 +1958,40 @@ vhost_scsi_chk_size(struct vhost_virtqueue *vq, struct vhost_scsi_ctx *vc)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1258| <<vhost_scsi_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+ *   - drivers/vhost/scsi.c|1621| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+ *
+ * 核心思想:
+ * 1. 把req_size的内容(header?)从vc->out_iter拷贝到vq->req
+ * 2. 根据target把vs_tpg[*vc->target]设置到函数的参数
+ */
 static int
 vhost_scsi_get_req(struct vhost_virtqueue *vq, struct vhost_scsi_ctx *vc,
 		   struct vhost_scsi_tpg **tpgp)
 {
 	int ret = -EIO;
 
+	/*
+	 * struct vhost_scsi_ctx {
+	 *     int head;  
+	 *     unsigned int out, in;
+	 *     size_t req_size, rsp_size;
+	 *     size_t out_size, in_size;
+	 *     u8 *target, *lunp;
+	 *     void *req;
+	 *     struct iov_iter out_iter;
+	 * };
+	 *
+	 * 在以下使用vhost_scsi_ctx->out_iter:
+	 *   - drivers/vhost/scsi.c|1071| <<vhost_scsi_get_desc>> iov_iter_init(&vc->out_iter, ITER_SOURCE, vq->iov, vc->out, vc->out_size);
+	 *   - drivers/vhost/scsi.c|1103| <<vhost_scsi_get_req>> if (unlikely(!copy_from_iter_full(vc->req, vc->req_size, &vc->out_iter))) {
+	 *   - drivers/vhost/scsi.c|1284| <<vhost_scsi_handle_vq>> data_iter = vc.out_iter;
+	 *   - drivers/vhost/scsi.c|1574| <<vhost_scsi_ctl_handle_vq>> if (unlikely(!copy_from_iter_full(vc.req, typ_size, &vc.out_iter))) {
+	 *
+	 * 从out_iter把req_size的header?拷贝到vc->req
+	 */
 	if (unlikely(!copy_from_iter_full(vc->req, vc->req_size,
 					  &vc->out_iter))) {
 		vq_err(vq, "Faulted on copy_from_iter_full\n");
@@ -1049,15 +2019,64 @@ vhost_scsi_get_req(struct vhost_virtqueue *vq, struct vhost_scsi_ctx *vc,
 	return ret;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1803| <<vhost_scsi_handle_vq>> lun = vhost_buf_to_lun(v_req_pi.lun);
+ *   - drivers/vhost/scsi.c|1821| <<vhost_scsi_handle_vq>> lun = vhost_buf_to_lun(v_req.lun);
+ *   - drivers/vhost/scsi.c|2054| <<vhost_scsi_handle_tmf>> if (target_submit_tmr(&tmf->se_cmd, tpg->tpg_nexus->tvn_se_sess, NULL,
+ *                                      vhost_buf_to_lun(vtmf->lun), NULL,
+ */
 static u16 vhost_buf_to_lun(u8 *lun_buf)
 {
 	return ((lun_buf[2] << 8) | lun_buf[3]) & 0x3FFF;
 }
 
+/*
+ * 关于virtio-scsi下发的request
+ *
+ * 在scsi_alloc_sgtables()中把request给map到scsi_cmnd上的
+ *
+ * struct scsi_cmnd *cmd:
+ * -> struct scsi_data_buffer sdb;
+ *    -> struct sg_table table;
+ *       -> struct scatterlist *sgl;        // the list
+ *       -> unsigned int nents;             // number of mapped entries
+ *       -> unsigned int orig_nents;        // original size of list
+ *    -> unsigned length;
+ *
+ * 假设没有prot
+ *
+ * struct scatterlist *sgs[6].
+ *
+ * 如果是READ的
+ * sgs[0] : request header
+ * sgs[1] : response header
+ * sgs[2] : sc->sdb.table.sgl (in buffer)
+ *
+ * 如果是WRITE的
+ * sgs[0] : request header
+ * sgs[1] : sc->sdb.table.sgl (out buffer)
+ * sgs[2] : response header
+ *
+ *
+ * called by:
+ *   - drivers/vhost/scsi.c|1611| <<vhost_scsi_handle_kick>> vhost_scsi_handle_vq(vs, vq);
+ */
 static void
 vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 {
 	struct vhost_scsi_tpg **vs_tpg, *tpg;
+	/*
+	 * // SCSI command request, followed by data-out
+	 * struct virtio_scsi_cmd_req {
+	 *     __u8 lun[8];            // Logical Unit Number
+	 *     __virtio64 tag;         // Command identifier
+	 *     __u8 task_attr;         // Task attribute
+	 *     __u8 prio;              // SAM command priority field
+	 *     __u8 crn;
+	 *     __u8 cdb[VIRTIO_SCSI_CDB_SIZE];
+	 * } __attribute__((packed));
+	 */
 	struct virtio_scsi_cmd_req v_req;
 	struct virtio_scsi_cmd_req_pi v_req_pi;
 	struct vhost_scsi_ctx vc;
@@ -1076,16 +2095,46 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 	 * We can handle the vq only after the endpoint is setup by calling the
 	 * VHOST_SCSI_SET_ENDPOINT ioctl.
 	 */
+	/*
+	 * struct vhost_scsi_tpg **vs_tpg, *tpg;
+	 */
 	vs_tpg = vhost_vq_get_backend(vq);
 	if (!vs_tpg)
 		goto out;
 
+	/*
+	 * struct vhost_scsi_ctx {
+	 *     int head;
+	 *     unsigned int out, in;
+	 *     size_t req_size, rsp_size;
+	 *     size_t out_size, in_size;
+	 *     u8 *target, *lunp;
+	 *     void *req;
+	 *     struct iov_iter out_iter;
+	 * };
+	 *
+	 * struct vhost_scsi_ctx vc:
+	 */
 	memset(&vc, 0, sizeof(vc));
 	vc.rsp_size = sizeof(struct virtio_scsi_cmd_resp);
 
 	vhost_disable_notify(&vs->dev, vq);
 
+	/*
+	 * 这里的循环结束的条件是likely(!vhost_exceeds_weight(vq, ++c, 0))
+	 * 也就是说每次肯定完成一个command
+	 */
 	do {
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|1193| <<vhost_scsi_handle_vq>> ret = vhost_scsi_get_desc(vs, vq, &vc);
+		 *   - drivers/vhost/scsi.c|1526| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_get_desc(vs, vq, &vc);
+		 *
+		 * 这里面会调用:
+		 * 1783         vc->head = vhost_get_vq_desc(vq, vq->iov,
+		 * 1784                                      ARRAY_SIZE(vq->iov), &vc->out, &vc->in,
+		 * 1785                                      NULL, NULL);
+		 */
 		ret = vhost_scsi_get_desc(vs, vq, &vc);
 		if (ret)
 			goto err;
@@ -1100,6 +2149,17 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 			vc.lunp = &v_req_pi.lun[0];
 			vc.target = &v_req_pi.lun[1];
 		} else {
+			/*
+			 * struct vhost_scsi_ctx {
+			 *     int head;
+			 *     unsigned int out, in;
+			 *     size_t req_size, rsp_size;
+			 *     size_t out_size, in_size;
+			 *     u8 *target, *lunp;
+			 *     void *req;
+			 *     struct iov_iter out_iter;
+			 * };
+			 */
 			vc.req = &v_req;
 			vc.req_size = sizeof(v_req);
 			vc.lunp = &v_req.lun[0];
@@ -1115,6 +2175,15 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		if (ret)
 			goto err;
 
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|1258| <<vhost_scsi_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+		 *   - drivers/vhost/scsi.c|1621| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+		 *
+		 * 核心思想:
+		 * 1. 把req_size的内容(header?)从vc->out_iter拷贝到vq->req
+		 * 2. 根据target把vs_tpg[*vc->target]设置到函数的参数
+		 */
 		ret = vhost_scsi_get_req(vq, &vc, &tpg);
 		if (ret)
 			goto err;
@@ -1138,14 +2207,46 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		 */
 		prot_bytes = 0;
 
+		/*
+		 * 如果是READ的
+		 * sgs[0] : request header
+		 * sgs[1] : response header
+		 * sgs[2] : sc->sdb.table.sgl (in buffer)
+		 *
+		 * 如果是WRITE的
+		 * sgs[0] : request header
+		 * sgs[1] : sc->sdb.table.sgl (out buffer)
+		 * sgs[2] : response header
+		 */
 		if (vc.out_size > vc.req_size) {
+			/*
+			 * WRITE
+			 */
 			data_direction = DMA_TO_DEVICE;
 			exp_data_len = vc.out_size - vc.req_size;
 			data_iter = vc.out_iter;
 		} else if (vc.in_size > vc.rsp_size) {
+			/*
+			 * 在以下设置vhost_scsi_ctx->in_size:
+			 *   - drivers/vhost/scsi.c|1826| <<vhost_scsi_get_desc>> vc->in_size = iov_length(&vq->iov[vc->out], vc->in);
+			 * 在以下使用vhost_scsi_ctx->in_size:
+			 *   - drivers/vhost/scsi.c|1860| <<vhost_scsi_chk_size>> if (unlikely(vc->in_size < vc->rsp_size)) {
+			 *   - drivers/vhost/scsi.c|1863| <<vhost_scsi_chk_size>> vq_err(vq, ... vc->rsp_size, vc->in_size);
+			 *   - drivers/vhost/scsi.c|2142| <<vhost_scsi_handle_vq>> } else if (vc.in_size > vc.rsp_size) {
+			 *   - drivers/vhost/scsi.c|2147| <<vhost_scsi_handle_vq>> exp_data_len = vc.in_size - vc.rsp_size;
+			 */
+			/*
+			 * READ
+			 */
 			data_direction = DMA_FROM_DEVICE;
 			exp_data_len = vc.in_size - vc.rsp_size;
 
+			/*
+			 * struct vhost_virtqueue *vq:
+			 * -> struct iovec iov[UIO_MAXIOV];
+			 * -> struct iovec iotlb_iov[64];
+			 * -> struct iovec *indirect;
+			 */
 			iov_iter_init(&in_iter, ITER_DEST, &vq->iov[vc.out], vc.in,
 				      vc.rsp_size + exp_data_len);
 			iov_iter_advance(&in_iter, vc.rsp_size);
@@ -1194,6 +2295,19 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 			cdb = &v_req_pi.cdb[0];
 			lun = vhost_buf_to_lun(v_req_pi.lun);
 		} else {
+			/*
+			 * // SCSI command request, followed by data-out
+			 * struct virtio_scsi_cmd_req {
+			 *     __u8 lun[8];            // Logical Unit Number
+			 *     __virtio64 tag;         // Command identifier
+			 *     __u8 task_attr;         // Task attribute
+			 *     __u8 prio;              // SAM command priority field
+			 *     __u8 crn;
+			 *     __u8 cdb[VIRTIO_SCSI_CDB_SIZE];
+			 * } __attribute__((packed));
+			 *
+			 * struct virtio_scsi_cmd_req v_req;
+			 */
 			tag = vhost64_to_cpu(vq, v_req.tag);
 			task_attr = v_req.task_attr;
 			cdb = &v_req.cdb[0];
@@ -1212,6 +2326,12 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 				scsi_command_size(cdb), VHOST_SCSI_MAX_CDB_SIZE);
 				goto err;
 		}
+		/*
+		 * 只在此处调用
+		 *
+		 * 核心思想是返回cmd = &svq->scsi_cmds[tag];
+		 * 简单的初始化, 然后: memcpy(cmd->tvc_cdb, cdb, VHOST_SCSI_MAX_CDB_SIZE);
+		 */
 		cmd = vhost_scsi_get_cmd(vq, tpg, cdb, tag, lun, task_attr,
 					 exp_data_len + prot_bytes,
 					 data_direction);
@@ -1220,10 +2340,44 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 			       PTR_ERR(cmd));
 			goto err;
 		}
+		/*
+		 * struct vhost_scsi_cmd *cmd;
+		 */
 		cmd->tvc_vhost = vs;
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_vq:
+		 *   - drivers/vhost/scsi.c|415| <<vhost_scsi_release_cmd_res>> struct vhost_scsi_virtqueue *svq = container_of(tv_cmd->tvc_vq,
+		 *                                    struct vhost_scsi_virtqueue, vq);
+		 *   - drivers/vhost/scsi.c|478| <<vhost_scsi_release_cmd>> struct vhost_scsi_virtqueue *svq = container_of(cmd->tvc_vq,
+		 *                                    struct vhost_scsi_virtqueue, vq);
+		 *   - drivers/vhost/scsi.c|734| <<vhost_scsi_complete_cmd_work>> v_rsp.resid = cpu_to_vhost32(cmd->tvc_vq, se_cmd->residual_count);
+		 *   - drivers/vhost/scsi.c|738| <<vhost_scsi_complete_cmd_work>> v_rsp.sense_len = cpu_to_vhost32(cmd->tvc_vq, se_cmd->scsi_sense_length);
+		 *   - drivers/vhost/scsi.c|778| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+		 *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_handle_vq>> cmd->tvc_vq = vq;
+		 */
 		cmd->tvc_vq = vq;
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_resp_iov:
+		 *   - drivers/vhost/scsi.c|687| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST, cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+		 *   - drivers/vhost/scsi.c|751| <<vhost_scsi_get_cmd>> tvc_resp_iov = cmd->tvc_resp_iov;
+		 *   - drivers/vhost/scsi.c|764| <<vhost_scsi_get_cmd>> cmd->tvc_resp_iov = tvc_resp_iov;
+		 *   - drivers/vhost/scsi.c|1599| <<vhost_scsi_handle_vq>> cmd->tvc_resp_iov[i] = vq->iov[vc.out + i];
+		 *   - drivers/vhost/scsi.c|2015| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_resp_iov);
+		 *   - drivers/vhost/scsi.c|2075| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_resp_iov = kcalloc(UIO_MAXIOV, sizeof(struct iovec), GFP_KERNEL);
+		 *   - drivers/vhost/scsi.c|2078| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_resp_iov) {
+		 *
+		 * 注释: Pointer to response header iovec
+		 * 存储的所有的response(header和数据的)iov, 是一对一的copy
+		 * 不是指针
+		 */
 		for (i = 0; i < vc.in ; i++)
 			cmd->tvc_resp_iov[i] = vq->iov[vc.out + i];
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_in_iovs:
+		 *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST,
+		 *                  cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+		 *   - drivers/vhost/scsi.c|1600| <<vhost_scsi_handle_vq>> cmd->tvc_in_iovs = vc.in;
+		 */
 		cmd->tvc_in_iovs = vc.in;
 
 		pr_debug("vhost_scsi got command opcode: %#02x, lun: %d\n",
@@ -1231,11 +2385,23 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		pr_debug("cmd: %p exp_data_len: %d, prot_bytes: %d data_direction:"
 			 " %d\n", cmd, exp_data_len, prot_bytes, data_direction);
 
+		/*
+		 * 这里很重要, 用到data_iter!!!
+		 */
 		if (data_direction != DMA_NONE) {
+			/*
+			 * 只在这里调用
+			 */
 			if (unlikely(vhost_scsi_mapal(cmd, prot_bytes,
 						      &prot_iter, exp_data_len,
 						      &data_iter))) {
 				vq_err(vq, "Failed to map iov to sgl\n");
+				/*
+				 * called by:
+				 *   - drivers/vhost/scsi.c|405| <<vhost_scsi_drop_cmds>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+				 *   - drivers/vhost/scsi.c|688| <<vhost_scsi_complete_cmd_work>> vhost_scsi_release_cmd_res(se_cmd);
+				 *   - drivers/vhost/scsi.c|1549| <<vhost_scsi_handle_vq>> vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
+				 */
 				vhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);
 				goto err;
 			}
@@ -1245,7 +2411,17 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		 * complete the virtio-scsi request in TCM callback context via
 		 * vhost_scsi_queue_data_in() and vhost_scsi_queue_status()
 		 */
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_vq_desc:
+		 *   - drivers/vhost/scsi.c|670| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+		 *   - drivers/vhost/scsi.c|1471| <<vhost_scsi_handle_vq>> cmd->tvc_vq_desc = vc.head;
+		 *
+		 * 注释: Descriptor from vhost_get_vq_desc() for virt_queue segment
+		 */
 		cmd->tvc_vq_desc = vc.head;
+		/*
+		 * 只在此处调用
+		 */
 		vhost_scsi_target_queue_cmd(cmd);
 		ret = 0;
 err:
@@ -1264,6 +2440,13 @@ vhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 	mutex_unlock(&vq->mutex);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1963| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq,
+ *                                     tmf->in_iovs, tmf->vq_desc, &tmf->resp_iov, resp_code);
+ *   - drivers/vhost/scsi.c|2025| <<vhost_scsi_handle_tmf>> vhost_scsi_send_tmf_resp(vs, vq, vc->in, vc->head,
+ *                                     &vq->iov[vc->out], VIRTIO_SCSI_S_FUNCTION_REJECTED);
+ */
 static void
 vhost_scsi_send_tmf_resp(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 			 int in_iovs, int vq_desc, struct iovec *resp_iov,
@@ -1277,6 +2460,13 @@ vhost_scsi_send_tmf_resp(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 	memset(&rsp, 0, sizeof(rsp));
 	rsp.response = tmf_resp_code;
 
+	/*
+	 * 在以下使用vhost_scsi_tmf->resp_iov:
+	 *   - drivers/vhost/scsi.c|2350| <<vhost_scsi_send_tmf_resp>> iov_iter_init(&iov_iter, ITER_DEST, resp_iov, in_iovs, sizeof(rsp));
+	 *   - drivers/vhost/scsi.c|2382| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq, tmf->in_iovs,
+	 *                                        tmf->vq_desc, &tmf->resp_iov, resp_code);
+	 *   - drivers/vhost/scsi.c|2470| <<vhost_scsi_handle_tmf>> tmf->resp_iov = vq->iov[vc->out];
+	 */
 	iov_iter_init(&iov_iter, ITER_DEST, resp_iov, in_iovs, sizeof(rsp));
 
 	ret = copy_to_iter(&rsp, sizeof(rsp), &iov_iter);
@@ -1286,6 +2476,10 @@ vhost_scsi_send_tmf_resp(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 		pr_err("Faulted on virtio_scsi_ctrl_tmf_resp\n");
 }
 
+/*
+ * 在以下使用vhost_scsi_tmf_resp_work():
+ *   - drivers/vhost/scsi.c|1373| <<vhost_scsi_handle_tmf>> vhost_work_init(&tmf->vwork, vhost_scsi_tmf_resp_work);
+ */
 static void vhost_scsi_tmf_resp_work(struct vhost_work *work)
 {
 	struct vhost_scsi_tmf *tmf = container_of(work, struct vhost_scsi_tmf,
@@ -1297,11 +2491,41 @@ static void vhost_scsi_tmf_resp_work(struct vhost_work *work)
 	else
 		resp_code = VIRTIO_SCSI_S_FUNCTION_REJECTED;
 
+	/*
+	 * 在以下使用vhost_scsi_tmf->vq_desc:
+	 *   - drivers/vhost/scsi.c|2382| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq, tmf->in_iovs,
+	 *                                        tmf->vq_desc, &tmf->resp_iov, resp_code);
+	 *   - drivers/vhost/scsi.c|2471| <<vhost_scsi_handle_tmf>> tmf->vq_desc = vc->head;
+	 *
+	 * 在以下使用vhost_scsi_tmf->in_iovs:
+	 *   - drivers/vhost/scsi.c|2381| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq, tmf->in_iovs,
+	 *   - drivers/vhost/scsi.c|2472| <<vhost_scsi_handle_tmf>> tmf->in_iovs = vc->in;
+	 *
+	 * 在以下调用vhost_scsi_send_tmf_resp():
+	 *   - drivers/vhost/scsi.c|1963| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq,
+	 *                                     tmf->in_iovs, tmf->vq_desc, &tmf->resp_iov, resp_code);
+	 *   - drivers/vhost/scsi.c|2025| <<vhost_scsi_handle_tmf>> vhost_scsi_send_tmf_resp(vs, vq, vc->in, vc->head,
+	 *                                     &vq->iov[vc->out], VIRTIO_SCSI_S_FUNCTION_REJECTED);
+	 */
 	vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq, tmf->in_iovs,
 				 tmf->vq_desc, &tmf->resp_iov, resp_code);
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|2328| <<vhost_scsi_tmf_resp_work>> vhost_scsi_release_tmf_res(tmf);
+	 *   - drivers/vhost/scsi.c|2342| <<vhost_scsi_tmf_flush_work>> vhost_scsi_release_tmf_res(tmf);
+	 *   - drivers/vhost/scsi.c|2396| <<vhost_scsi_handle_tmf>> vhost_scsi_release_tmf_res(tmf);
+	 */
 	vhost_scsi_release_tmf_res(tmf);
 }
 
+/*
+ * 在以下使用vhost_scsi_tmf->flush_work:
+ *   - drivers/vhost/scsi.c|724| <<vhost_scsi_release_cmd>> schedule_work(&tmf->flush_work);
+ *   - drivers/vhost/scsi.c|2405| <<vhost_scsi_handle_tmf>> INIT_WORK(&tmf->flush_work, vhost_scsi_tmf_flush_work);
+ *
+ * 在以下使用vhost_scsi_tmf_flush_work():
+ *   - drivers/vhost/scsi.c|2405| <<vhost_scsi_handle_tmf>> INIT_WORK(&tmf->flush_work, vhost_scsi_tmf_flush_work);
+ */
 static void vhost_scsi_tmf_flush_work(struct work_struct *work)
 {
 	struct vhost_scsi_tmf *tmf = container_of(work, struct vhost_scsi_tmf,
@@ -1312,10 +2536,24 @@ static void vhost_scsi_tmf_flush_work(struct work_struct *work)
 	 * send our response.
 	 */
 	vhost_dev_flush(vq->dev);
+	/*
+	 * 在以下调用vhost_scsi_release_tmf_res():
+	 *   - drivers/vhost/scsi.c|2328| <<vhost_scsi_tmf_resp_work>> vhost_scsi_release_tmf_res(tmf);
+	 *   - drivers/vhost/scsi.c|2342| <<vhost_scsi_tmf_flush_work>> vhost_scsi_release_tmf_res(tmf);
+	 *   - drivers/vhost/scsi.c|2396| <<vhost_scsi_handle_tmf>> vhost_scsi_release_tmf_res(tmf);
+	 *
+	 * 在以下使用vhost_scsi_tmf->vwork:
+	 *   - drivers/vhost/scsi.c|2359| <<vhost_scsi_tmf_flush_work>> if (!vhost_vq_work_queue(vq, &tmf->vwork))
+	 *   - drivers/vhost/scsi.c|2406| <<vhost_scsi_handle_tmf>> vhost_work_init(&tmf->vwork, vhost_scsi_tmf_resp_work);
+	 */
 	if (!vhost_vq_work_queue(vq, &tmf->vwork))
 		vhost_scsi_release_tmf_res(tmf);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|2150| <<vhost_scsi_ctl_handle_vq>> vhost_scsi_handle_tmf(vs, tpg, vq, &v_req.tmf, &vc);
+ */
 static void
 vhost_scsi_handle_tmf(struct vhost_scsi *vs, struct vhost_scsi_tpg *tpg,
 		      struct vhost_virtqueue *vq,
@@ -1324,6 +2562,21 @@ vhost_scsi_handle_tmf(struct vhost_scsi *vs, struct vhost_scsi_tpg *tpg,
 {
 	struct vhost_scsi_virtqueue *svq = container_of(vq,
 					struct vhost_scsi_virtqueue, vq);
+	/*
+	 * struct vhost_scsi_tmf {
+	 *     struct vhost_work vwork;
+	 *     struct work_struct flush_work;
+	 *     struct vhost_scsi *vhost;
+	 *     struct vhost_scsi_virtqueue *svq;
+	 *
+	 *     struct se_cmd se_cmd;
+	 *     u8 scsi_resp;
+	 *     struct vhost_scsi_inflight *inflight;
+	 *     struct iovec resp_iov;
+	 *     int in_iovs;
+	 *     int vq_desc;
+	 * };
+	 */
 	struct vhost_scsi_tmf *tmf;
 
 	if (vhost32_to_cpu(vq, vtmf->subtype) !=
@@ -1343,15 +2596,50 @@ vhost_scsi_handle_tmf(struct vhost_scsi *vs, struct vhost_scsi_tpg *tpg,
 	vhost_work_init(&tmf->vwork, vhost_scsi_tmf_resp_work);
 	tmf->vhost = vs;
 	tmf->svq = svq;
+	/*
+	 * 在以下使用vhost_scsi_tmf->resp_iov:
+	 *   - drivers/vhost/scsi.c|2350| <<vhost_scsi_send_tmf_resp>> iov_iter_init(&iov_iter, ITER_DEST, resp_iov, in_iovs, sizeof(rsp));
+	 *   - drivers/vhost/scsi.c|2382| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq, tmf->in_iovs,
+	 *                                        tmf->vq_desc, &tmf->resp_iov, resp_code);
+	 *   - drivers/vhost/scsi.c|2470| <<vhost_scsi_handle_tmf>> tmf->resp_iov = vq->iov[vc->out];
+	 */
 	tmf->resp_iov = vq->iov[vc->out];
+	/*
+	 * 在以下使用vhost_scsi_tmf->vq_desc:
+	 *   - drivers/vhost/scsi.c|2382| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq, tmf->in_iovs,
+	 *                                        tmf->vq_desc, &tmf->resp_iov, resp_code);
+	 *   - drivers/vhost/scsi.c|2471| <<vhost_scsi_handle_tmf>> tmf->vq_desc = vc->head;
+	 */
 	tmf->vq_desc = vc->head;
+	/*
+	 * 在以下使用vhost_scsi_tmf->in_iovs:
+	 *   - drivers/vhost/scsi.c|2381| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq, tmf->in_iovs,
+	 *   - drivers/vhost/scsi.c|2472| <<vhost_scsi_handle_tmf>> tmf->in_iovs = vc->in;
+	 */
 	tmf->in_iovs = vc->in;
 	tmf->inflight = vhost_scsi_get_inflight(vq);
 
+	/*
+	 * called by:
+	 *   - drivers/infiniband/ulp/srpt/ib_srpt.c|1667| <<srpt_handle_tsk_mgmt>> rc = target_submit_tmr(&send_ioctx->cmd, sess, NULL,
+	 *   - drivers/scsi/elx/efct/efct_lio.c|1449| <<efct_scsi_recv_tmf>> rc = target_submit_tmr(&ocp->cmd, se_sess, NULL, lun, ocp, tmr_func,
+	 *   - drivers/scsi/ibmvscsi_tgt/ibmvscsi_tgt.c|2799| <<ibmvscsis_parse_task>> rc = target_submit_tmr(&cmd->se_cmd, nexus->se_sess, NULL,
+	 *   - drivers/scsi/qla2xxx/tcm_qla2xxx.c|617| <<tcm_qla2xxx_handle_tmr>> return target_submit_tmr(se_cmd, sess->se_sess, NULL, lun, mcmd,
+	 *   - drivers/target/loopback/tcm_loop.c|216| <<tcm_loop_issue_tmr>> rc = target_submit_tmr(se_cmd, se_sess, tl_cmd->tl_sense_buf, lun,
+	 *   - drivers/target/tcm_fc/tfc_cmd.c|365| <<ft_send_tm>> rc = target_submit_tmr(&cmd->se_cmd, cmd->sess->se_sess,
+	 *   - drivers/vhost/scsi.c|2014| <<vhost_scsi_handle_tmf>> if (target_submit_tmr(&tmf->se_cmd, tpg->tpg_nexus->tvn_se_sess, NULL,
+	 *   - drivers/xen/xen-scsiback.c|626| <<scsiback_device_action>> rc = target_submit_tmr(&pending_req->se_cmd, nexus->tvn_se_sess,
+	 */
 	if (target_submit_tmr(&tmf->se_cmd, tpg->tpg_nexus->tvn_se_sess, NULL,
 			      vhost_buf_to_lun(vtmf->lun), NULL,
 			      TMR_LUN_RESET, GFP_KERNEL, 0,
 			      TARGET_SCF_ACK_KREF) < 0) {
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|2328| <<vhost_scsi_tmf_resp_work>> vhost_scsi_release_tmf_res(tmf);
+		 *   - drivers/vhost/scsi.c|2342| <<vhost_scsi_tmf_flush_work>> vhost_scsi_release_tmf_res(tmf);
+		 *   - drivers/vhost/scsi.c|2396| <<vhost_scsi_handle_tmf>> vhost_scsi_release_tmf_res(tmf);
+		 */
 		vhost_scsi_release_tmf_res(tmf);
 		goto send_reject;
 	}
@@ -1359,15 +2647,63 @@ vhost_scsi_handle_tmf(struct vhost_scsi *vs, struct vhost_scsi_tpg *tpg,
 	return;
 
 send_reject:
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|1963| <<vhost_scsi_tmf_resp_work>> vhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq,
+	 *                                     tmf->in_iovs, tmf->vq_desc, &tmf->resp_iov, resp_code);
+	 *   - drivers/vhost/scsi.c|2025| <<vhost_scsi_handle_tmf>> vhost_scsi_send_tmf_resp(vs, vq, vc->in, vc->head,
+	 *                                     &vq->iov[vc->out], VIRTIO_SCSI_S_FUNCTION_REJECTED);
+	 */
 	vhost_scsi_send_tmf_resp(vs, vq, vc->in, vc->head, &vq->iov[vc->out],
 				 VIRTIO_SCSI_S_FUNCTION_REJECTED);
 }
 
+/*
+ *  75 // Task Management Request
+ *  76 struct virtio_scsi_ctrl_tmf_req { 
+ *  77         __virtio32 type;
+ *  78         __virtio32 subtype;
+ *  79         __u8 lun[8];
+ *  80         __virtio64 tag;
+ *  81 } __attribute__((packed));
+ *  82 
+ *  83 struct virtio_scsi_ctrl_tmf_resp {
+ *  84         __u8 response;
+ *  85 } __attribute__((packed));
+ *  86 
+ *  87 // Asynchronous notification query/subscription
+ *  88 struct virtio_scsi_ctrl_an_req {
+ *  89         __virtio32 type; 
+ *  90         __u8 lun[8];
+ *  91         __virtio32 event_requested;
+ *  92 } __attribute__((packed));
+ *  93 
+ *  94 struct virtio_scsi_ctrl_an_resp {
+ *  95         __virtio32 event_actual;
+ *  96         __u8 response;
+ *  97 } __attribute__((packed));
+ *  98 
+ *  99 struct virtio_scsi_event {
+ * 100         __virtio32 event;
+ * 101         __u8 lun[8];
+ * 102         __virtio32 reason;
+ * 103 } __attribute__((packed)); 
+ *
+ *
+ * called by:
+ *   - drivers/vhost/scsi.c|2152| <<vhost_scsi_ctl_handle_vq>> vhost_scsi_send_an_resp(vs, vq, &vc);
+ */
 static void
 vhost_scsi_send_an_resp(struct vhost_scsi *vs,
 			struct vhost_virtqueue *vq,
 			struct vhost_scsi_ctx *vc)
 {
+	/*
+	 * struct virtio_scsi_ctrl_an_resp {
+	 *     __virtio32 event_actual;
+	 *     __u8 response;
+	 * } __attribute__((packed));
+	 */
 	struct virtio_scsi_ctrl_an_resp rsp;
 	struct iov_iter iov_iter;
 	int ret;
@@ -1376,15 +2712,40 @@ vhost_scsi_send_an_resp(struct vhost_scsi *vs,
 	memset(&rsp, 0, sizeof(rsp));	/* event_actual = 0 */
 	rsp.response = VIRTIO_SCSI_S_OK;
 
+	/*
+	 * #define ITER_SOURCE     1       // == WRITE
+	 * #define ITER_DEST       0       // == READ
+	 */
 	iov_iter_init(&iov_iter, ITER_DEST, &vq->iov[vc->out], vc->in, sizeof(rsp));
 
+	/*
+	 * vhost_scsi_send_an_resp()用的copy_to_iter()
+	 * vhost_scsi_send_bad_target()直接拷贝
+	 * 耍猴呢???!!!
+	 *
+	 *
+	 * 这里写入了resp的内存
+	 */
 	ret = copy_to_iter(&rsp, sizeof(rsp), &iov_iter);
+	/*
+	 * 在以下调用vhost_add_used_and_signal():
+	 *   - drivers/vhost/net.c|931| <<handle_tx_zerocopy>> vhost_add_used_and_signal(&net->dev, vq, head, 0);
+	 *   - drivers/vhost/scsi.c|510| <<vhost_scsi_do_evt_work>> vhost_add_used_and_signal(&vs->dev, vq, head, 0);
+	 *   - drivers/vhost/scsi.c|955| <<vhost_scsi_send_bad_target>> vhost_add_used_and_signal(&vs->dev, vq, head, 0);
+	 *   - drivers/vhost/scsi.c|1293| <<vhost_scsi_send_tmf_resp>> vhost_add_used_and_signal(&vs->dev, vq, vq_desc, 0);
+	 *   - drivers/vhost/scsi.c|1392| <<vhost_scsi_send_an_resp>> vhost_add_used_and_signal(&vs->dev, vq, vc->head, 0);
+	 *   - drivers/vhost/test.c|87| <<handle_vq>> vhost_add_used_and_signal(&n->dev, vq, head, 0);
+	 */
 	if (likely(ret == sizeof(rsp)))
 		vhost_add_used_and_signal(&vs->dev, vq, vc->head, 0);
 	else
 		pr_err("Faulted on virtio_scsi_ctrl_an_resp\n");
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|2162| <<vhost_scsi_ctl_handle_kick>> vhost_scsi_ctl_handle_vq(vs, vq);
+ */
 static void
 vhost_scsi_ctl_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 {
@@ -1411,6 +2772,16 @@ vhost_scsi_ctl_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 	vhost_disable_notify(&vs->dev, vq);
 
 	do {
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|1193| <<vhost_scsi_handle_vq>> ret = vhost_scsi_get_desc(vs, vq, &vc);
+		 *   - drivers/vhost/scsi.c|1526| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_get_desc(vs, vq, &vc);
+		 *
+		 * 会调用下面的:
+		 * 1783         vc->head = vhost_get_vq_desc(vq, vq->iov,
+		 * 1784                                      ARRAY_SIZE(vq->iov), &vc->out, &vc->in,
+		 * 1785                                      NULL, NULL);
+		 */
 		ret = vhost_scsi_get_desc(vs, vq, &vc);
 		if (ret)
 			goto err;
@@ -1434,6 +2805,12 @@ vhost_scsi_ctl_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 			continue;
 		}
 
+		/*
+		 * // Controlq type codes.
+		 * #define VIRTIO_SCSI_T_TMF                      0
+		 * #define VIRTIO_SCSI_T_AN_QUERY                 1
+		 * #define VIRTIO_SCSI_T_AN_SUBSCRIBE             2
+		 */
 		switch (vhost32_to_cpu(vq, v_req.type)) {
 		case VIRTIO_SCSI_T_TMF:
 			vc.req = &v_req.tmf;
@@ -1460,6 +2837,11 @@ vhost_scsi_ctl_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		 * Check for a sane response buffer so we can report
 		 * early errors back to the guest.
 		 */
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|1680| <<vhost_scsi_handle_vq>> ret = vhost_scsi_chk_size(vq, &vc);
+		 *   - drivers/vhost/scsi.c|2130| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_chk_size(vq, &vc);
+		 */
 		ret = vhost_scsi_chk_size(vq, &vc);
 		if (ret)
 			goto err;
@@ -1470,10 +2852,27 @@ vhost_scsi_ctl_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		vc.req += typ_size;
 		vc.req_size -= typ_size;
 
+		/*
+		 * called by:
+		 *   - drivers/vhost/scsi.c|1258| <<vhost_scsi_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+		 *   - drivers/vhost/scsi.c|1621| <<vhost_scsi_ctl_handle_vq>> ret = vhost_scsi_get_req(vq, &vc, &tpg);
+		 *
+		 * 核心思想:
+		 * 1. 把req_size的内容(header?)从vc->out_iter拷贝到vq->req
+		 * 2. 根据target把vs_tpg[*vc->target]设置到函数的参数
+		 */
 		ret = vhost_scsi_get_req(vq, &vc, &tpg);
 		if (ret)
 			goto err;
 
+		/*
+		 * 只在下面调用vhost_scsi_send_an_resp()
+		 *
+		 * // Controlq type codes.
+		 * #define VIRTIO_SCSI_T_TMF                      0
+		 * #define VIRTIO_SCSI_T_AN_QUERY                 1
+		 * #define VIRTIO_SCSI_T_AN_SUBSCRIBE             2
+		 */
 		if (v_req.type == VIRTIO_SCSI_T_TMF)
 			vhost_scsi_handle_tmf(vs, tpg, vq, &v_req.tmf, &vc);
 		else
@@ -1485,6 +2884,11 @@ vhost_scsi_ctl_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 		 * EIO:    Respond with bad target
 		 * EAGAIN: Pending request
 		 */
+		/*
+		 * 在以下调用vhost_scsi_send_bad_target():
+		 *   - drivers/vhost/scsi.c|1920| <<vhost_scsi_handle_vq>> vhost_scsi_send_bad_target(vs, vq, vc.head, vc.out);
+		 *   - drivers/vhost/scsi.c|2163| <<vhost_scsi_ctl_handle_vq>> vhost_scsi_send_bad_target(vs, vq, vc.head, vc.out);
+		 */
 		if (ret == -ENXIO)
 			break;
 		else if (ret == -EIO)
@@ -1494,6 +2898,14 @@ vhost_scsi_ctl_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)
 	mutex_unlock(&vq->mutex);
 }
 
+/*
+ * 2670         vs->vqs[VHOST_SCSI_VQ_CTL].vq.handle_kick = vhost_scsi_ctl_handle_kick;
+ * 2671         vs->vqs[VHOST_SCSI_VQ_EVT].vq.handle_kick = vhost_scsi_evt_handle_kick;
+ * 2672         for (i = VHOST_SCSI_VQ_IO; i < nvqs; i++) {
+ * ... ...
+ * 2680                 svq->vq.handle_kick = vhost_scsi_handle_kick;
+ * 2681         }
+ */
 static void vhost_scsi_ctl_handle_kick(struct vhost_work *work)
 {
 	struct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,
@@ -1501,16 +2913,51 @@ static void vhost_scsi_ctl_handle_kick(struct vhost_work *work)
 	struct vhost_scsi *vs = container_of(vq->dev, struct vhost_scsi, dev);
 
 	pr_debug("%s: The handling func for control queue.\n", __func__);
+	/*
+	 * 只在此处调用
+	 */
 	vhost_scsi_ctl_handle_vq(vs, vq);
 }
 
+/*
+ * 关于event queue的处理:
+ * vhost_scsi_send_evt()
+ * -> vhost_vq_work_queue(vq, &vs->vs_event_work)
+ *    -> vhost_scsi_evt_work()
+ *       -> vhost_scsi_complete_events(false)
+ *          -> vhost_scsi_do_evt_work()
+ *             -> __copy_to_user(eventp, event, sizeof(*event))
+ *             -> vhost_add_used_and_signal(&vs->dev, vq, head, 0);
+ *          -> vhost_scsi_free_evt()
+ *
+ * called by:
+ *   - drivers/vhost/scsi.c|1547| <<vhost_scsi_evt_handle_kick>> vhost_scsi_send_evt(vs, vq, NULL, NULL, VIRTIO_SCSI_T_NO_EVENT,
+ *   - drivers/vhost/scsi.c|2175| <<vhost_scsi_do_plug>> vhost_scsi_send_evt(vs, vq, tpg, lun, VIRTIO_SCSI_T_TRANSPORT_RESET, reason);
+ */
 static void
 vhost_scsi_send_evt(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 		    struct vhost_scsi_tpg *tpg, struct se_lun *lun,
 		    u32 event, u32 reason)
 {
+	/*
+	 * struct virtio_scsi_event {
+	 *     __virtio32 event;
+	 *     __u8 lun[8];
+	 *     __virtio32 reason;
+	 * } __attribute__((packed));
+	 *
+	 * 290 struct vhost_scsi_evt {
+	 * 291         // event to be sent to guest
+	 * 292         struct virtio_scsi_event event;
+	 * 293         // event list, serviced from vhost worker thread
+	 * 294         struct llist_node list;
+	 * 295 };
+	 */
 	struct vhost_scsi_evt *evt;
 
+	/*
+	 * 只在这里调用
+	 */
 	evt = vhost_scsi_allocate_evt(vs, event, reason);
 	if (!evt)
 		return;
@@ -1528,11 +2975,41 @@ vhost_scsi_send_evt(struct vhost_scsi *vs, struct vhost_virtqueue *vq,
 		evt->event.lun[3] = lun->unpacked_lun & 0xFF;
 	}
 
+	/*
+	 * 在以下使用vhost_scsi->vs_event_work:
+	 *   - drivers/vhost/scsi.c|1553| <<vhost_scsi_send_evt>> if (!vhost_vq_work_queue(vq, &vs->vs_event_work))
+	 *   - drivers/vhost/scsi.c|1997| <<vhost_scsi_open>> vhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);
+	 *
+	 * 在以下使用vhost_scsi->vs_event_list:
+	 *   - drivers/vhost/scsi.c|527| <<vhost_scsi_complete_events>> llnode = llist_del_all(&vs->vs_event_list);
+	 *   - drivers/vhost/scsi.c|1552| <<vhost_scsi_send_evt>> llist_add(&evt->list, &vs->vs_event_list);
+	 */
 	llist_add(&evt->list, &vs->vs_event_list);
+	/*
+	 * 如果可以queue_work, work会调用:
+	 *
+	 * vhost_scsi_evt_work()
+	 * -> vhost_scsi_complete_events(false)
+	 *
+	 * 不然现在就调用vhost_scsi_complete_events(true)
+	 *
+	 * true和false关系到是否drop
+	 */
 	if (!vhost_vq_work_queue(vq, &vs->vs_event_work))
 		vhost_scsi_complete_events(vs, true);
 }
 
+/*
+ * 2670         vs->vqs[VHOST_SCSI_VQ_CTL].vq.handle_kick = vhost_scsi_ctl_handle_kick;
+ * 2671         vs->vqs[VHOST_SCSI_VQ_EVT].vq.handle_kick = vhost_scsi_evt_handle_kick;
+ * 2672         for (i = VHOST_SCSI_VQ_IO; i < nvqs; i++) {
+ * ... ...
+ * 2680                 svq->vq.handle_kick = vhost_scsi_handle_kick;
+ * 2681         }
+ *
+ * 在以下使用vhost_scsi_evt_handle_kick():
+ *   - drivers/vhost/scsi.c|2005| <<vhost_scsi_open>> vs->vqs[VHOST_SCSI_VQ_EVT].vq.handle_kick = vhost_scsi_evt_handle_kick;
+ */
 static void vhost_scsi_evt_handle_kick(struct vhost_work *work)
 {
 	struct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,
@@ -1543,6 +3020,11 @@ static void vhost_scsi_evt_handle_kick(struct vhost_work *work)
 	if (!vhost_vq_get_backend(vq))
 		goto out;
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|1547| <<vhost_scsi_evt_handle_kick>> vhost_scsi_send_evt(vs, vq, NULL, NULL, VIRTIO_SCSI_T_NO_EVENT,
+	 *   - drivers/vhost/scsi.c|2175| <<vhost_scsi_do_plug>> vhost_scsi_send_evt(vs, vq, tpg, lun, VIRTIO_SCSI_T_TRANSPORT_RESET, reason);
+	 */
 	if (vs->vs_events_missed)
 		vhost_scsi_send_evt(vs, vq, NULL, NULL, VIRTIO_SCSI_T_NO_EVENT,
 				    0);
@@ -1550,15 +3032,62 @@ static void vhost_scsi_evt_handle_kick(struct vhost_work *work)
 	mutex_unlock(&vq->mutex);
 }
 
+/*
+ * 关于virtio-scsi下发的request
+ *
+ * 在scsi_alloc_sgtables()中把request给map到scsi_cmnd上的
+ *
+ * struct scsi_cmnd *cmd:
+ * -> struct scsi_data_buffer sdb;
+ *    -> struct sg_table table;
+ *       -> struct scatterlist *sgl;        // the list
+ *       -> unsigned int nents;             // number of mapped entries
+ *       -> unsigned int orig_nents;        // original size of list
+ *    -> unsigned length;
+ *
+ * 假设没有prot
+ *
+ * struct scatterlist *sgs[6].
+ *      
+ * 如果是READ的                                 
+ * sgs[0] : request header
+ * sgs[1] : response header
+ * sgs[2] : sc->sdb.table.sgl (in buffer)
+ *      
+ * 如果是WRITE的
+ * sgs[0] : request header
+ * sgs[1] : sc->sdb.table.sgl (out buffer)
+ * sgs[2] : response header
+ *
+ *
+ * 2670         vs->vqs[VHOST_SCSI_VQ_CTL].vq.handle_kick = vhost_scsi_ctl_handle_kick;
+ * 2671         vs->vqs[VHOST_SCSI_VQ_EVT].vq.handle_kick = vhost_scsi_evt_handle_kick;
+ * 2672         for (i = VHOST_SCSI_VQ_IO; i < nvqs; i++) {
+ * ... ...
+ * 2680                 svq->vq.handle_kick = vhost_scsi_handle_kick;
+ * 2681         }
+ *
+ * 在以下使用vhost_scsi_handle_kick():
+ *   - drivers/vhost/scsi.c|2014| <<vhost_scsi_open>> svq->vq.handle_kick = vhost_scsi_handle_kick;
+ */
 static void vhost_scsi_handle_kick(struct vhost_work *work)
 {
 	struct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,
 						poll.work);
 	struct vhost_scsi *vs = container_of(vq->dev, struct vhost_scsi, dev);
 
+	/*
+	 * 只在此处调用.
+	 */
 	vhost_scsi_handle_vq(vs, vq);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|2655| <<vhost_scsi_set_endpoint>> vhost_scsi_flush(vs);
+ *   - drivers/vhost/scsi.c|2741| <<vhost_scsi_clear_endpoint>> vhost_scsi_flush(vs);
+ *   - drivers/vhost/scsi.c|2775| <<vhost_scsi_clear_endpoint>> vhost_scsi_flush(vs);
+ */
 /* Callers must hold dev mutex */
 static void vhost_scsi_flush(struct vhost_scsi *vs)
 {
@@ -1583,6 +3112,12 @@ static void vhost_scsi_flush(struct vhost_scsi *vs)
 		wait_for_completion(&vs->old_inflight[i]->comp);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|2645| <<vhost_scsi_setup_vq_cmds>> vhost_scsi_destroy_vq_cmds(vq);
+ *   - drivers/vhost/scsi.c|2769| <<vhost_scsi_set_endpoint>> vhost_scsi_destroy_vq_cmds(&vs->vqs[i].vq);
+ *   - drivers/vhost/scsi.c|2851| <<vhost_scsi_clear_endpoint>> vhost_scsi_destroy_vq_cmds(vq);
+ */
 static void vhost_scsi_destroy_vq_cmds(struct vhost_virtqueue *vq)
 {
 	struct vhost_scsi_virtqueue *svq = container_of(vq,
@@ -1602,11 +3137,23 @@ static void vhost_scsi_destroy_vq_cmds(struct vhost_virtqueue *vq)
 		kfree(tv_cmd->tvc_resp_iov);
 	}
 
+	/*
+	 * 在以下使用vhost_scsi_virtqueue->scsi_tags:
+	 *   - drivers/vhost/scsi.c|520| <<vhost_scsi_release_cmd_res>> sbitmap_clear_bit(&svq->scsi_tags, se_cmd->map_tag);
+	 *   - drivers/vhost/scsi.c|931| <<vhost_scsi_get_cmd>> tag = sbitmap_get(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2234| <<vhost_scsi_destroy_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2253| <<vhost_scsi_setup_vq_cmds>> if (sbitmap_init_node(&svq->scsi_tags, max_cmds, -1, GFP_KERNEL,
+	 *   - drivers/vhost/scsi.c|2268| <<vhost_scsi_setup_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 */
 	sbitmap_free(&svq->scsi_tags);
 	kfree(svq->scsi_cmds);
 	svq->scsi_cmds = NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1830| <<vhost_scsi_set_endpoint>> ret = vhost_scsi_setup_vq_cmds(vq, vq->num);
+ */
 static int vhost_scsi_setup_vq_cmds(struct vhost_virtqueue *vq, int max_cmds)
 {
 	struct vhost_scsi_virtqueue *svq = container_of(vq,
@@ -1614,14 +3161,42 @@ static int vhost_scsi_setup_vq_cmds(struct vhost_virtqueue *vq, int max_cmds)
 	struct vhost_scsi_cmd *tv_cmd;
 	unsigned int i;
 
+	/*
+	 * 在以下使用vhost_scsi_virtqueue->scsi_cmds:
+	 *   - drivers/vhost/scsi.c|667| <<vhost_scsi_get_cmd>> cmd = &svq->scsi_cmds[tag];
+	 *   - drivers/vhost/scsi.c|1660| <<vhost_scsi_destroy_vq_cmds>> if (!svq->scsi_cmds)
+	 *   - drivers/vhost/scsi.c|1664| <<vhost_scsi_destroy_vq_cmds>> tv_cmd = &svq->scsi_cmds[i];
+	 *   - drivers/vhost/scsi.c|1673| <<vhost_scsi_destroy_vq_cmds>> kfree(svq->scsi_cmds);
+	 *   - drivers/vhost/scsi.c|1674| <<vhost_scsi_destroy_vq_cmds>> svq->scsi_cmds = NULL;
+	 *   - drivers/vhost/scsi.c|1684| <<vhost_scsi_setup_vq_cmds>> if (svq->scsi_cmds)
+	 *   - drivers/vhost/scsi.c|1692| <<vhost_scsi_setup_vq_cmds>> svq->scsi_cmds = kcalloc(max_cmds, sizeof(*tv_cmd), GFP_KERNEL);
+	 *   - drivers/vhost/scsi.c|1693| <<vhost_scsi_setup_vq_cmds>> if (!svq->scsi_cmds) {
+	 *   - drivers/vhost/scsi.c|1699| <<vhost_scsi_setup_vq_cmds>> tv_cmd = &svq->scsi_cmds[i];
+	 */
 	if (svq->scsi_cmds)
 		return 0;
 
+	/*
+	 * 在以下使用vhost_scsi_virtqueue->scsi_tags:
+	 *   - drivers/vhost/scsi.c|520| <<vhost_scsi_release_cmd_res>> sbitmap_clear_bit(&svq->scsi_tags, se_cmd->map_tag);
+	 *   - drivers/vhost/scsi.c|931| <<vhost_scsi_get_cmd>> tag = sbitmap_get(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2234| <<vhost_scsi_destroy_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 *   - drivers/vhost/scsi.c|2253| <<vhost_scsi_setup_vq_cmds>> if (sbitmap_init_node(&svq->scsi_tags, max_cmds, -1, GFP_KERNEL,
+	 *   - drivers/vhost/scsi.c|2268| <<vhost_scsi_setup_vq_cmds>> sbitmap_free(&svq->scsi_tags);
+	 */
 	if (sbitmap_init_node(&svq->scsi_tags, max_cmds, -1, GFP_KERNEL,
 			      NUMA_NO_NODE, false, true))
 		return -ENOMEM;
 	svq->max_cmds = max_cmds;
 
+	/*
+	 * max_cmds实际是vq->num
+	 *
+	 * struct vhost_scsi_virtqueue *svq:
+	 * -> struct vhost_scsi_cmd *scsi_cmds;      
+	 * -> struct sbitmap scsi_tags;              
+	 * -> int max_cmds;
+	 */
 	svq->scsi_cmds = kcalloc(max_cmds, sizeof(*tv_cmd), GFP_KERNEL);
 	if (!svq->scsi_cmds) {
 		sbitmap_free(&svq->scsi_tags);
@@ -1639,6 +3214,16 @@ static int vhost_scsi_setup_vq_cmds(struct vhost_virtqueue *vq, int max_cmds)
 			goto out;
 		}
 
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_upages:
+		 *   - drivers/vhost/scsi.c|997| <<vhost_scsi_get_cmd>> pages = cmd->tvc_upages;
+		 *   - drivers/vhost/scsi.c|1002| <<vhost_scsi_get_cmd>> cmd->tvc_upages = pages;
+		 *   - drivers/vhost/scsi.c|1033| <<vhost_scsi_map_to_sgl>> struct page **pages = cmd->tvc_upages;
+		 *   - drivers/vhost/scsi.c|2460| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_upages);
+		 *   - drivers/vhost/scsi.c|2513| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_upages = kcalloc(VHOST_SCSI_PREALLOC_UPAGES,
+		 *                                         sizeof(struct page *), GFP_KERNEL);
+		 *   - drivers/vhost/scsi.c|2516| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_upages) {
+		 */
 		tv_cmd->tvc_upages = kcalloc(VHOST_SCSI_PREALLOC_UPAGES,
 					     sizeof(struct page *),
 					     GFP_KERNEL);
@@ -1647,6 +3232,20 @@ static int vhost_scsi_setup_vq_cmds(struct vhost_virtqueue *vq, int max_cmds)
 			goto out;
 		}
 
+		/*
+		 * 在以下使用vhost_scsi_cmd->tvc_resp_iov:
+		 *   - drivers/vhost/scsi.c|687| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST, cmd->tvc_resp_iov, cmd->tvc_in_iovs, sizeof(v_rsp));
+		 *   - drivers/vhost/scsi.c|751| <<vhost_scsi_get_cmd>> tvc_resp_iov = cmd->tvc_resp_iov;
+		 *   - drivers/vhost/scsi.c|764| <<vhost_scsi_get_cmd>> cmd->tvc_resp_iov = tvc_resp_iov;
+		 *   - drivers/vhost/scsi.c|1599| <<vhost_scsi_handle_vq>> cmd->tvc_resp_iov[i] = vq->iov[vc.out + i];
+		 *   - drivers/vhost/scsi.c|2015| <<vhost_scsi_destroy_vq_cmds>> kfree(tv_cmd->tvc_resp_iov);
+		 *   - drivers/vhost/scsi.c|2075| <<vhost_scsi_setup_vq_cmds>> tv_cmd->tvc_resp_iov = kcalloc(UIO_MAXIOV, sizeof(struct iovec), GFP_KERNEL);
+		 *   - drivers/vhost/scsi.c|2078| <<vhost_scsi_setup_vq_cmds>> if (!tv_cmd->tvc_resp_iov) {
+		 *
+		 * 注释: Pointer to response header iovec
+		 * 存储的所有的response(header和数据的)iov, 是一对一的copy
+		 * 不是指针
+		 */
 		tv_cmd->tvc_resp_iov = kcalloc(UIO_MAXIOV,
 					       sizeof(struct iovec),
 					       GFP_KERNEL);
@@ -1709,6 +3308,12 @@ vhost_scsi_set_endpoint(struct vhost_scsi *vs,
 		memcpy(vs_tpg, vs->vs_tpg, len);
 
 	mutex_lock(&vhost_scsi_mutex);
+	/*
+	 * 在以下使用vhost_scsi_list:
+	 *   - drivers/vhost/scsi.c|378| <<global>> static LIST_HEAD(vhost_scsi_list);
+	 *   - drivers/vhost/scsi.c|2353| <<vhost_scsi_set_endpoint>> list_for_each_entry(tpg, &vhost_scsi_list, tv_tpg_list) {
+	 *   - drivers/vhost/scsi.c|3135| <<vhost_scsi_make_tpg>> list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
+	 */
 	list_for_each_entry(tpg, &vhost_scsi_list, tv_tpg_list) {
 		mutex_lock(&tpg->tv_tpg_mutex);
 		if (!tpg->tpg_nexus) {
@@ -1743,6 +3348,13 @@ vhost_scsi_set_endpoint(struct vhost_scsi *vs,
 				goto undepend;
 			}
 			tpg->tv_tpg_vhost_count++;
+			/*
+			 * 在以下使用vhost_scsi_tpg->vhost_scsi:
+			 *   - drivers/vhost/scsi.c|3338| <<vhost_scsi_set_endpoint>> tpg->vhost_scsi = vs;
+			 *   - drivers/vhost/scsi.c|3400| <<vhost_scsi_set_endpoint>> tpg->vhost_scsi = NULL;
+			 *   - drivers/vhost/scsi.c|3497| <<vhost_scsi_clear_endpoint>> tpg->vhost_scsi = NULL;
+			 *   - drivers/vhost/scsi.c|3789| <<vhost_scsi_do_plug>> struct vhost_scsi *vs = tpg->vhost_scsi;
+			 */
 			tpg->vhost_scsi = vs;
 			vs_tpg[tpg->tport_tpgt] = tpg;
 			match = true;
@@ -1760,6 +3372,9 @@ vhost_scsi_set_endpoint(struct vhost_scsi *vs,
 			if (!vhost_vq_is_setup(vq))
 				continue;
 
+			/*
+			 * 只在此处调用
+			 */
 			ret = vhost_scsi_setup_vq_cmds(vq, vq->num);
 			if (ret)
 				goto destroy_vq_cmds;
@@ -1781,6 +3396,12 @@ vhost_scsi_set_endpoint(struct vhost_scsi *vs,
 	 * Act as synchronize_rcu to make sure access to
 	 * old vs->vs_tpg is finished.
 	 */
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|2655| <<vhost_scsi_set_endpoint>> vhost_scsi_flush(vs);
+	 *   - drivers/vhost/scsi.c|2741| <<vhost_scsi_clear_endpoint>> vhost_scsi_flush(vs);
+	 *   - drivers/vhost/scsi.c|2775| <<vhost_scsi_clear_endpoint>> vhost_scsi_flush(vs);
+	 */
 	vhost_scsi_flush(vs);
 	kfree(vs->vs_tpg);
 	vs->vs_tpg = vs_tpg;
@@ -1796,6 +3417,13 @@ vhost_scsi_set_endpoint(struct vhost_scsi *vs,
 		tpg = vs_tpg[i];
 		if (tpg) {
 			mutex_lock(&tpg->tv_tpg_mutex);
+			/*
+			 * 在以下使用vhost_scsi_tpg->vhost_scsi:
+			 *   - drivers/vhost/scsi.c|3338| <<vhost_scsi_set_endpoint>> tpg->vhost_scsi = vs;
+			 *   - drivers/vhost/scsi.c|3400| <<vhost_scsi_set_endpoint>> tpg->vhost_scsi = NULL;
+			 *   - drivers/vhost/scsi.c|3497| <<vhost_scsi_clear_endpoint>> tpg->vhost_scsi = NULL;
+			 *   - drivers/vhost/scsi.c|3789| <<vhost_scsi_do_plug>> struct vhost_scsi *vs = tpg->vhost_scsi;
+			 */
 			tpg->vhost_scsi = NULL;
 			tpg->tv_tpg_vhost_count--;
 			mutex_unlock(&tpg->tv_tpg_mutex);
@@ -1866,6 +3494,12 @@ vhost_scsi_clear_endpoint(struct vhost_scsi *vs,
 		vhost_vq_set_backend(vq, NULL);
 		mutex_unlock(&vq->mutex);
 	}
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|2655| <<vhost_scsi_set_endpoint>> vhost_scsi_flush(vs);
+	 *   - drivers/vhost/scsi.c|2741| <<vhost_scsi_clear_endpoint>> vhost_scsi_flush(vs);
+	 *   - drivers/vhost/scsi.c|2775| <<vhost_scsi_clear_endpoint>> vhost_scsi_flush(vs);
+	 */
 	/* Make sure cmds are not running before tearing them down. */
 	vhost_scsi_flush(vs);
 
@@ -1887,6 +3521,13 @@ vhost_scsi_clear_endpoint(struct vhost_scsi *vs,
 		mutex_lock(&tpg->tv_tpg_mutex);
 
 		tpg->tv_tpg_vhost_count--;
+		/*
+		 * 在以下使用vhost_scsi_tpg->vhost_scsi:
+		 *   - drivers/vhost/scsi.c|3338| <<vhost_scsi_set_endpoint>> tpg->vhost_scsi = vs;
+		 *   - drivers/vhost/scsi.c|3400| <<vhost_scsi_set_endpoint>> tpg->vhost_scsi = NULL;
+		 *   - drivers/vhost/scsi.c|3497| <<vhost_scsi_clear_endpoint>> tpg->vhost_scsi = NULL;
+		 *   - drivers/vhost/scsi.c|3789| <<vhost_scsi_do_plug>> struct vhost_scsi *vs = tpg->vhost_scsi;
+		 */
 		tpg->vhost_scsi = NULL;
 		vs->vs_tpg[target] = NULL;
 
@@ -1901,6 +3542,12 @@ vhost_scsi_clear_endpoint(struct vhost_scsi *vs,
 	 * Act as synchronize_rcu to make sure access to
 	 * old vs->vs_tpg is finished.
 	 */
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|2655| <<vhost_scsi_set_endpoint>> vhost_scsi_flush(vs);
+	 *   - drivers/vhost/scsi.c|2741| <<vhost_scsi_clear_endpoint>> vhost_scsi_flush(vs);
+	 *   - drivers/vhost/scsi.c|2775| <<vhost_scsi_clear_endpoint>> vhost_scsi_flush(vs);
+	 */
 	vhost_scsi_flush(vs);
 	kfree(vs->vs_tpg);
 	vs->vs_tpg = NULL;
@@ -1913,6 +3560,9 @@ vhost_scsi_clear_endpoint(struct vhost_scsi *vs,
 	return ret;
 }
 
+/*
+ * 处理VHOST_SET_FEATURES.
+ */
 static int vhost_scsi_set_features(struct vhost_scsi *vs, u64 features)
 {
 	struct vhost_virtqueue *vq;
@@ -1931,6 +3581,16 @@ static int vhost_scsi_set_features(struct vhost_scsi *vs, u64 features)
 	for (i = 0; i < vs->dev.nvqs; i++) {
 		vq = &vs->vqs[i].vq;
 		mutex_lock(&vq->mutex);
+		/*
+		 * 在以下使用vhost_virtqueue->acked_features:
+		 *   - drivers/vhost/net.c|1737| <<vhost_net_set_features>> n->vqs[i].vq.acked_features = features;
+		 *   - drivers/vhost/scsi.c|2976| <<vhost_scsi_set_features>> vq->acked_features = features;
+		 *   - drivers/vhost/test.c|253| <<vhost_test_set_features>> vq->acked_features = features;
+		 *   - drivers/vhost/vdpa.c|491| <<vhost_vdpa_set_features>> vq->acked_features = actual_features;
+		 *   - drivers/vhost/vhost.c|464| <<vhost_vq_reset>> vq->acked_features = 0;
+		 *   - drivers/vhost/vhost.h|356| <<vhost_has_feature>> return vq->acked_features & (1ULL << bit);
+		 *   - drivers/vhost/vsock.c|821| <<vhost_vsock_set_features>> vq->acked_features = features;
+		 */
 		vq->acked_features = features;
 		mutex_unlock(&vq->mutex);
 	}
@@ -1964,6 +3624,10 @@ static int vhost_scsi_open(struct inode *inode, struct file *f)
 	if (!vs->old_inflight)
 		goto err_inflight;
 
+	/*
+	 * struct vhost_scsi
+	 * -> struct vhost_scsi_virtqueue *vqs;
+	 */
 	vs->vqs = kmalloc_array(nvqs, sizeof(*vs->vqs),
 				GFP_KERNEL | __GFP_ZERO);
 	if (!vs->vqs)
@@ -1988,6 +3652,11 @@ static int vhost_scsi_open(struct inode *inode, struct file *f)
 		vqs[i] = &svq->vq;
 		svq->vs = vs;
 		init_llist_head(&svq->completion_list);
+		/*
+		 * 在以下使用vhost_scsi_virtqueue->completion_work:
+		 *   - drivers/vhost/scsi.c|753| <<vhost_scsi_release_cmd>> if (!vhost_vq_work_queue(&svq->vq, &svq->completion_work))
+		 *   - drivers/vhost/scsi.c|3397| <<vhost_scsi_open>> vhost_work_init(&svq->completion_work, vhost_scsi_complete_cmd_work);
+		 */
 		vhost_work_init(&svq->completion_work,
 				vhost_scsi_complete_cmd_work);
 		svq->vq.handle_kick = vhost_scsi_handle_kick;
@@ -2145,11 +3814,23 @@ static char *vhost_scsi_dump_proto_id(struct vhost_scsi_tport *tport)
 	return "Unknown";
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|3160| <<vhost_scsi_hotplug>> vhost_scsi_do_plug(tpg, lun, true);
+ *   - drivers/vhost/scsi.c|3165| <<vhost_scsi_hotunplug>> vhost_scsi_do_plug(tpg, lun, false);
+ */
 static void
 vhost_scsi_do_plug(struct vhost_scsi_tpg *tpg,
 		  struct se_lun *lun, bool plug)
 {
 
+	/*
+	 * 在以下使用vhost_scsi_tpg->vhost_scsi:
+	 *   - drivers/vhost/scsi.c|3338| <<vhost_scsi_set_endpoint>> tpg->vhost_scsi = vs;
+	 *   - drivers/vhost/scsi.c|3400| <<vhost_scsi_set_endpoint>> tpg->vhost_scsi = NULL;
+	 *   - drivers/vhost/scsi.c|3497| <<vhost_scsi_clear_endpoint>> tpg->vhost_scsi = NULL;
+	 *   - drivers/vhost/scsi.c|3789| <<vhost_scsi_do_plug>> struct vhost_scsi *vs = tpg->vhost_scsi;
+	 */
 	struct vhost_scsi *vs = tpg->vhost_scsi;
 	struct vhost_virtqueue *vq;
 	u32 reason;
@@ -2171,6 +3852,24 @@ vhost_scsi_do_plug(struct vhost_scsi_tpg *tpg,
 	if (!vhost_vq_get_backend(vq))
 		goto unlock;
 
+	/*
+	 * // Events.
+	 * #define VIRTIO_SCSI_T_EVENTS_MISSED            0x80000000
+	 * #define VIRTIO_SCSI_T_NO_EVENT                 0
+	 * #define VIRTIO_SCSI_T_TRANSPORT_RESET          1
+	 * #define VIRTIO_SCSI_T_ASYNC_NOTIFY             2
+	 * #define VIRTIO_SCSI_T_PARAM_CHANGE             3
+	 *
+	 * // Reasons of transport reset event
+	 * #define VIRTIO_SCSI_EVT_RESET_HARD             0
+	 * #define VIRTIO_SCSI_EVT_RESET_RESCAN           1
+	 * #define VIRTIO_SCSI_EVT_RESET_REMOVED          2
+	 *
+	 *
+	 * called by:
+	 *   - drivers/vhost/scsi.c|1547| <<vhost_scsi_evt_handle_kick>> vhost_scsi_send_evt(vs, vq, NULL, NULL, VIRTIO_SCSI_T_NO_EVENT,
+	 *   - drivers/vhost/scsi.c|2175| <<vhost_scsi_do_plug>> vhost_scsi_send_evt(vs, vq, tpg, lun, VIRTIO_SCSI_T_TRANSPORT_RESET, reason);
+	 */
 	if (vhost_has_feature(vq, VIRTIO_SCSI_F_HOTPLUG))
 		vhost_scsi_send_evt(vs, vq, tpg, lun,
 				   VIRTIO_SCSI_T_TRANSPORT_RESET, reason);
@@ -2178,6 +3877,10 @@ vhost_scsi_do_plug(struct vhost_scsi_tpg *tpg,
 	mutex_unlock(&vq->mutex);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|3179| <<vhost_scsi_port_link>> vhost_scsi_hotplug(tpg, lun);
+ */
 static void vhost_scsi_hotplug(struct vhost_scsi_tpg *tpg, struct se_lun *lun)
 {
 	vhost_scsi_do_plug(tpg, lun, true);
@@ -2188,6 +3891,9 @@ static void vhost_scsi_hotunplug(struct vhost_scsi_tpg *tpg, struct se_lun *lun)
 	vhost_scsi_do_plug(tpg, lun, false);
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static int vhost_scsi_port_link(struct se_portal_group *se_tpg,
 			       struct se_lun *lun)
 {
@@ -2202,6 +3908,9 @@ static int vhost_scsi_port_link(struct se_portal_group *se_tpg,
 	return 0;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static void vhost_scsi_port_unlink(struct se_portal_group *se_tpg,
 				  struct se_lun *lun)
 {
@@ -2248,6 +3957,9 @@ static ssize_t vhost_scsi_tpg_attrib_fabric_prot_type_show(
 
 CONFIGFS_ATTR(vhost_scsi_tpg_attrib_, fabric_prot_type);
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static struct configfs_attribute *vhost_scsi_tpg_attrib_attrs[] = {
 	&vhost_scsi_tpg_attrib_attr_fabric_prot_type,
 	NULL,
@@ -2440,11 +4152,17 @@ static ssize_t vhost_scsi_tpg_nexus_store(struct config_item *item,
 
 CONFIGFS_ATTR(vhost_scsi_tpg_, nexus);
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static struct configfs_attribute *vhost_scsi_tpg_attrs[] = {
 	&vhost_scsi_tpg_attr_nexus,
 	NULL,
 };
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static struct se_portal_group *
 vhost_scsi_make_tpg(struct se_wwn *wwn, const char *name)
 {
@@ -2476,12 +4194,21 @@ vhost_scsi_make_tpg(struct se_wwn *wwn, const char *name)
 		return NULL;
 	}
 	mutex_lock(&vhost_scsi_mutex);
+	/*
+	 * 在以下使用vhost_scsi_list:
+	 *   - drivers/vhost/scsi.c|378| <<global>> static LIST_HEAD(vhost_scsi_list);
+	 *   - drivers/vhost/scsi.c|2353| <<vhost_scsi_set_endpoint>> list_for_each_entry(tpg, &vhost_scsi_list, tv_tpg_list) {
+	 *   - drivers/vhost/scsi.c|3135| <<vhost_scsi_make_tpg>> list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
+	 */
 	list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
 	mutex_unlock(&vhost_scsi_mutex);
 
 	return &tpg->se_tpg;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static void vhost_scsi_drop_tpg(struct se_portal_group *se_tpg)
 {
 	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
@@ -2501,6 +4228,9 @@ static void vhost_scsi_drop_tpg(struct se_portal_group *se_tpg)
 	kfree(tpg);
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static struct se_wwn *
 vhost_scsi_make_tport(struct target_fabric_configfs *tf,
 		     struct config_group *group,
@@ -2562,6 +4292,9 @@ vhost_scsi_make_tport(struct target_fabric_configfs *tf,
 	return &tport->tport_wwn;
 }
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static void vhost_scsi_drop_tport(struct se_wwn *wwn)
 {
 	struct vhost_scsi_tport *tport = container_of(wwn,
@@ -2584,6 +4317,9 @@ vhost_scsi_wwn_version_show(struct config_item *item, char *page)
 
 CONFIGFS_ATTR_RO(vhost_scsi_wwn_, version);
 
+/*
+ * struct target_core_fabric_ops vhost_scsi_ops
+ */
 static struct configfs_attribute *vhost_scsi_wwn_attrs[] = {
 	&vhost_scsi_wwn_attr_version,
 	NULL,
diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c
index 9ac25d08f..d091f2b53 100644
--- a/drivers/vhost/vhost.c
+++ b/drivers/vhost/vhost.c
@@ -33,6 +33,22 @@
 
 #include "vhost.h"
 
+/*
+ * 所有的vhost直接用iov_base的地方:
+ *   - drivers/vhost/net.c|1292| <<handle_rx>> vq_err(vq, "Unable to write vnet_hdr ""at addr %p\n", vq->iov->iov_base);
+ *   - drivers/vhost/scsi.c|930| <<vhost_scsi_do_evt_work>> eventp = vq->iov[out].iov_base;
+ *     稍后调用 ret = __copy_to_user(eventp, event, sizeof(*event));
+ *   - drivers/vhost/scsi.c|1643| <<vhost_scsi_send_bad_target>> resp = vq->iov[out].iov_base;
+ *     稍后调用 ret = __copy_to_user(resp, &rsp, sizeof(rsp));
+ *   - drivers/vhost/vhost.c|1435| <<__vhost_get_user_slow>> return vq->iotlb_iov[0].iov_base;
+ *   - drivers/vhost/vhost.c|2718| <<log_used>> ret = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+ *     log_write_hva()中稍后只是用地址作计算
+ *   - drivers/vhost/vhost.c|2746| <<vhost_log_write>> r = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+ *     log_write_hva()中稍后只是用地址作计算
+ *   - drivers/vhost/vhost.c|2968| <<translate_desc>> _iov->iov_base = (void __user *)(unsigned long )
+ *     在caller中作为struct iovec iov[]返回
+ */
+
 static ushort max_mem_regions = 64;
 module_param(max_mem_regions, ushort, 0444);
 MODULE_PARM_DESC(max_mem_regions,
@@ -46,7 +62,48 @@ enum {
 	VHOST_MEMORY_F_LOG = 0x1,
 };
 
+/*
+ * struct vring_desc {
+ *     __virtio64 addr;
+ *     __virtio32 len;
+ *     __virtio16 flags;
+ *     __virtio16 next;
+ * };
+ *
+ * struct vring_avail {
+ *     __virtio16 flags;
+ *     __virtio16 idx;
+ *     __virtio16 ring[];
+ * };
+ *
+ * struct vring_used_elem {
+ *     __virtio32 id;
+ *     __virtio32 len;
+ * };
+ *
+ * struct vring_used {
+ *     __virtio16 flags;
+ *     __virtio16 idx;
+ *     vring_used_elem_t ring[];
+ * };
+ *
+ *
+ * struct vhost_virtqueue *vq:
+ * -> vring_desc_t __user *desc;
+ * -> vring_avail_t __user *avail;
+ * -> vring_used_t __user *used;
+ *
+ * 在以下使用vhost_used_event():
+ *   - drivers/vhost/vhost.c|1397| <<vhost_get_used_event>> return vhost_get_avail(vq, *event, vhost_used_event(vq))
+ */
 #define vhost_used_event(vq) ((__virtio16 __user *)&vq->avail->ring[vq->num])
+/*
+ * 在以下使用vhost_avail_event():
+ *   - drivers/vhost/vhost.c|1286| <<vhost_put_avail_event>> vhost_avail_event(vq));
+ *   - drivers/vhost/vhost.c|2402| <<vhost_update_avail_event>> used = vhost_avail_event(vq);
+ *   - drivers/vhost/vhost.c|2404| <<vhost_update_avail_event>> sizeof *vhost_avail_event(vq));
+ *   - drivers/vhost/vhost.c|2939| <<vhost_enable_notify>> vhost_avail_event(vq), r);
+ */
 #define vhost_avail_event(vq) ((__virtio16 __user *)&vq->used->ring[vq->num])
 
 #ifdef CONFIG_VHOST_CROSS_ENDIAN_LEGACY
@@ -140,6 +197,12 @@ static void vhost_reset_is_le(struct vhost_virtqueue *vq)
 
 struct vhost_flush_struct {
 	struct vhost_work work;
+	/*
+	 * 在以下使用vhost_flush_struct->wait_event:
+	 *   - drivers/vhost/vhost.c|151| <<vhost_flush_work>> complete(&s->wait_event);
+	 *   - drivers/vhost/vhost.c|279| <<__vhost_worker_flush>> init_completion(&flush.wait_event);
+	 *   - drivers/vhost/vhost.c|288| <<__vhost_worker_flush>> wait_for_completion(&flush.wait_event);
+	 */
 	struct completion wait_event;
 };
 
@@ -148,6 +211,12 @@ static void vhost_flush_work(struct vhost_work *work)
 	struct vhost_flush_struct *s;
 
 	s = container_of(work, struct vhost_flush_struct, work);
+	/*
+	 * 在以下使用vhost_flush_struct->wait_event:
+	 *   - drivers/vhost/vhost.c|151| <<vhost_flush_work>> complete(&s->wait_event);
+	 *   - drivers/vhost/vhost.c|279| <<__vhost_worker_flush>> init_completion(&flush.wait_event);
+	 *   - drivers/vhost/vhost.c|288| <<__vhost_worker_flush>> wait_for_completion(&flush.wait_event);
+	 */
 	complete(&s->wait_event);
 }
 
@@ -178,6 +247,15 @@ static int vhost_poll_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|1352| <<vhost_scsi_handle_tmf>> vhost_work_init(&tmf->vwork, vhost_scsi_tmf_resp_work);
+ *   - drivers/vhost/scsi.c|1990| <<vhost_scsi_open>> vhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);
+ *   - drivers/vhost/scsi.c|2005| <<vhost_scsi_open>> vhost_work_init(&svq->completion_work,
+ *   - drivers/vhost/vhost.c|200| <<vhost_poll_init>> vhost_work_init(&poll->work, fn);
+ *   - drivers/vhost/vhost.c|280| <<__vhost_worker_flush>> vhost_work_init(&flush.work, vhost_flush_work);
+ *   - drivers/vhost/vsock.c|687| <<vhost_vsock_dev_open>> vhost_work_init(&vsock->send_pkt_work, vhost_transport_send_pkt_work);
+ */
 void vhost_work_init(struct vhost_work *work, vhost_work_fn_t fn)
 {
 	clear_bit(VHOST_WORK_QUEUED, &work->flags);
@@ -233,6 +311,11 @@ void vhost_poll_stop(struct vhost_poll *poll)
 }
 EXPORT_SYMBOL_GPL(vhost_poll_stop);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|336| <<vhost_vq_work_queue>> vhost_worker_queue(worker, work);
+ *   - drivers/vhost/vhost.c|366| <<__vhost_worker_flush>> vhost_worker_queue(worker, &flush.work);
+ */
 static void vhost_worker_queue(struct vhost_worker *worker,
 			       struct vhost_work *work)
 {
@@ -246,6 +329,16 @@ static void vhost_worker_queue(struct vhost_worker *worker,
 	}
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|738| <<vhost_scsi_release_cmd>> if (!vhost_vq_work_queue(&svq->vq, &svq->completion_work))
+ *   - drivers/vhost/scsi.c|2359| <<vhost_scsi_tmf_flush_work>> if (!vhost_vq_work_queue(vq, &tmf->vwork))
+ *   - drivers/vhost/scsi.c|2778| <<vhost_scsi_send_evt>> if (!vhost_vq_work_queue(vq, &vs->vs_event_work))
+ *   - drivers/vhost/vhost.c|432| <<vhost_poll_queue>> vhost_vq_work_queue(poll->vq, &poll->work);
+ *   - drivers/vhost/vhost.h|288| <<vhost_poll_queue>> bool vhost_vq_work_queue(struct vhost_virtqueue *vq, struct vhost_work *work);
+ *   - drivers/vhost/vsock.c|292| <<vhost_transport_send_pkt>> vhost_vq_work_queue(&vsock->vqs[VSOCK_VQ_RX], &vsock->send_pkt_work);
+ *   - drivers/vhost/vsock.c|600| <<vhost_vsock_start>> vhost_vq_work_queue(&vsock->vqs[VSOCK_VQ_RX], &vsock->send_pkt_work);
+ */
 bool vhost_vq_work_queue(struct vhost_virtqueue *vq, struct vhost_work *work)
 {
 	struct vhost_worker *worker;
@@ -269,6 +362,12 @@ EXPORT_SYMBOL_GPL(vhost_vq_work_queue);
  *
  * The worker's flush_mutex must be held.
  */
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|295| <<vhost_worker_flush>> __vhost_worker_flush(worker);
+ *   - drivers/vhost/vhost.c|757| <<__vhost_vq_attach_worker>> __vhost_worker_flush(old_worker);
+ *   - drivers/vhost/vhost.c|816| <<vhost_free_worker>> __vhost_worker_flush(worker);
+ */
 static void __vhost_worker_flush(struct vhost_worker *worker)
 {
 	struct vhost_flush_struct flush;
@@ -285,10 +384,20 @@ static void __vhost_worker_flush(struct vhost_worker *worker)
 	 * mutex to force cleanup.
 	 */
 	mutex_unlock(&worker->mutex);
+	/*
+	 * 在以下使用vhost_flush_struct->wait_event:
+	 *   - drivers/vhost/vhost.c|151| <<vhost_flush_work>> complete(&s->wait_event);
+	 *   - drivers/vhost/vhost.c|279| <<__vhost_worker_flush>> init_completion(&flush.wait_event);
+	 *   - drivers/vhost/vhost.c|288| <<__vhost_worker_flush>> wait_for_completion(&flush.wait_event);
+	 */
 	wait_for_completion(&flush.wait_event);
 	mutex_lock(&worker->mutex);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|305| <<vhost_dev_flush>> vhost_worker_flush(worker);
+ */
 static void vhost_worker_flush(struct vhost_worker *worker)
 {
 	mutex_lock(&worker->mutex);
@@ -296,6 +405,17 @@ static void vhost_worker_flush(struct vhost_worker *worker)
 	mutex_unlock(&worker->mutex);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1359| <<vhost_net_flush>> vhost_dev_flush(&n->dev);
+ *   - drivers/vhost/net.c|1550| <<vhost_net_set_backend>> vhost_dev_flush(&n->dev);
+ *   - drivers/vhost/scsi.c|1323| <<vhost_scsi_tmf_flush_work>> vhost_dev_flush(vq->dev);
+ *   - drivers/vhost/scsi.c|1593| <<vhost_scsi_flush>> vhost_dev_flush(&vs->dev);
+ *   - drivers/vhost/test.c|149| <<vhost_test_flush>> vhost_dev_flush(&n->dev);
+ *   - drivers/vhost/vhost.c|1003| <<vhost_dev_stop>> vhost_dev_flush(dev);
+ *   - drivers/vhost/vhost.c|2092| <<vhost_vring_ioctl>> vhost_dev_flush(vq->poll.dev);
+ *   - drivers/vhost/vsock.c|697| <<vhost_vsock_flush>> vhost_dev_flush(&vsock->dev);
+ */
 void vhost_dev_flush(struct vhost_dev *dev)
 {
 	struct vhost_worker *worker;
@@ -373,6 +493,12 @@ static void vhost_vq_reset(struct vhost_dev *dev,
 	vq->log_addr = -1ull;
 	vq->private_data = NULL;
 	vq->acked_features = 0;
+	/*
+	 * 在以下使用vhost_virtqueue->acked_backend_features:
+	 *   - drivers/vhost/vhost.c|465| <<vhost_vq_reset>> vq->acked_backend_features = 0;
+	 *   - drivers/vhost/vhost.c|3746| <<vhost_set_backend_features>> vq->acked_backend_features = features;
+	 *   - drivers/vhost/vhost.h|361| <<vhost_backend_has_feature>> return vq->acked_backend_features & (1ULL << bit);
+	 */
 	vq->acked_backend_features = 0;
 	vq->log_base = NULL;
 	vq->error_ctx = NULL;
@@ -449,6 +575,17 @@ static void vhost_worker_killed(void *data)
 
 static void vhost_vq_free_iovecs(struct vhost_virtqueue *vq)
 {
+	/*
+	 * 在以下使用vhost_virtqueue->indirect:
+	 * drivers/vhost/vhost.c|688| <<vhost_dev_init>> vq->indirect = NULL;
+	 *   - drivers/vhost/vhost.c|541| <<vhost_vq_free_iovecs>> kfree(vq->indirect);
+	 *   - drivers/vhost/vhost.c|542| <<vhost_vq_free_iovecs>> vq->indirect = NULL;
+	 *   - drivers/vhost/vhost.c|561| <<vhost_dev_alloc_iovecs>> vq->indirect = kmalloc_array(UIO_MAXIOV,
+	 *   - drivers/vhost/vhost.c|562| <<vhost_dev_alloc_iovecs>> sizeof(*vq->indirect),
+	 *   - drivers/vhost/vhost.c|574| <<vhost_dev_alloc_iovecs>> if (!vq->indirect || !vq->log || !vq->heads)
+	 *   - drivers/vhost/vhost.c|2873| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+	 *   - drivers/vhost/vhost.c|2880| <<get_indirect>> iov_iter_init(&from, ITER_SOURCE, vq->indirect, ret, len);
+	 */
 	kfree(vq->indirect);
 	vq->indirect = NULL;
 	kfree(vq->log);
@@ -457,6 +594,10 @@ static void vhost_vq_free_iovecs(struct vhost_virtqueue *vq)
 	vq->heads = NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|1043| <<vhost_dev_set_owner>> err = vhost_dev_alloc_iovecs(dev);
+ */
 /* Helper to allocate iovec buffers for all vqs. */
 static long vhost_dev_alloc_iovecs(struct vhost_dev *dev)
 {
@@ -465,9 +606,38 @@ static long vhost_dev_alloc_iovecs(struct vhost_dev *dev)
 
 	for (i = 0; i < dev->nvqs; ++i) {
 		vq = dev->vqs[i];
+		/*
+		 * 在以下使用vhost_virtqueue->indirect:
+		 * drivers/vhost/vhost.c|688| <<vhost_dev_init>> vq->indirect = NULL;
+		 *   - drivers/vhost/vhost.c|541| <<vhost_vq_free_iovecs>> kfree(vq->indirect);
+		 *   - drivers/vhost/vhost.c|542| <<vhost_vq_free_iovecs>> vq->indirect = NULL;
+		 *   - drivers/vhost/vhost.c|561| <<vhost_dev_alloc_iovecs>> vq->indirect = kmalloc_array(UIO_MAXIOV,
+		 *   - drivers/vhost/vhost.c|562| <<vhost_dev_alloc_iovecs>> sizeof(*vq->indirect),
+		 *   - drivers/vhost/vhost.c|574| <<vhost_dev_alloc_iovecs>> if (!vq->indirect || !vq->log || !vq->heads)
+		 *   - drivers/vhost/vhost.c|2873| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+		 *   - drivers/vhost/vhost.c|2880| <<get_indirect>> iov_iter_init(&from, ITER_SOURCE, vq->indirect, ret, len);
+		 */
 		vq->indirect = kmalloc_array(UIO_MAXIOV,
 					     sizeof(*vq->indirect),
 					     GFP_KERNEL);
+		/*
+		 * 在以下调用vhost_dev_init():
+		 *   - drivers/vhost/net.c|1389| <<vhost_net_open>> vhost_dev_init(dev, vqs, VHOST_NET_VQ_MAX,
+		 *                       UIO_MAXIOV + VHOST_NET_BATCH, VHOST_NET_PKT_WEIGHT, VHOST_NET_WEIGHT, true, NULL);
+		 *   - drivers/vhost/scsi.c|2016| <<vhost_scsi_open>> vhost_dev_init(&vs->dev, vqs, nvqs,
+		 *                       UIO_MAXIOV, VHOST_SCSI_WEIGHT, 0, true, NULL);
+		 *   - drivers/vhost/test.c|122| <<vhost_test_open>> vhost_dev_init(dev, vqs, VHOST_TEST_VQ_MAX,
+		 *                       UIO_MAXIOV, VHOST_TEST_PKT_WEIGHT, VHOST_TEST_WEIGHT, true, NULL);
+		 *   - drivers/vhost/vdpa.c|1433| <<vhost_vdpa_open>> vhost_dev_init(dev, vqs, nvqs, 0,
+		 *                       0, 0, false, vhost_vdpa_process_iotlb_msg);
+		 *   - drivers/vhost/vsock.c|681| <<vhost_vsock_dev_open>> vhost_dev_init(&vsock->dev, vqs,
+		 *        ARRAY_SIZE(vsock->vqs), UIO_MAXIOV, VHOST_VSOCK_PKT_WEIGHT, VHOST_VSOCK_WEIGHT, true, NULL);
+		 *
+		 * 在以下使用vhost_dev->iov_limit:
+		 *   - drivers/vhost/vhost.c|639| <<vhost_dev_init>> dev->iov_limit = iov_limit;
+		 *   - drivers/vhost/vhost.c|560| <<vhost_dev_alloc_iovecs>> vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log), GFP_KERNEL);
+		 *   - drivers/vhost/vhost.c|562| <<vhost_dev_alloc_iovecs>> vq->heads = kmalloc_array(dev->iov_limit, sizeof(*vq->heads), GFP_KERNEL);
+		 */
 		vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log),
 					GFP_KERNEL);
 		vq->heads = kmalloc_array(dev->iov_limit, sizeof(*vq->heads),
@@ -491,6 +661,17 @@ static void vhost_dev_free_iovecs(struct vhost_dev *dev)
 		vhost_vq_free_iovecs(dev->vqs[i]);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|826| <<handle_tx_copy>> } while (likely(!vhost_exceeds_weight(vq, ++sent_pkts, total_len)));
+ *   - drivers/vhost/net.c|935| <<handle_tx_zerocopy>> } while (likely(!vhost_exceeds_weight(vq, ++sent_pkts, total_len)));
+ *   - drivers/vhost/net.c|1304| <<handle_rx>> } while (likely(!vhost_exceeds_weight(vq, ++recv_pkts, total_len)));
+ *   - drivers/vhost/scsi.c|1921| <<vhost_scsi_handle_vq>> } while (likely(!vhost_exceeds_weight(vq, ++c, 0)));
+ *   - drivers/vhost/scsi.c|2164| <<vhost_scsi_ctl_handle_vq>> } while (likely(!vhost_exceeds_weight(vq, ++c, 0)));
+ *   - drivers/vhost/test.c|89| <<handle_vq>> if (unlikely(vhost_exceeds_weight(vq, 0, total_len)))
+ *   - drivers/vhost/vsock.c|249| <<vhost_transport_do_send_pkt>> } while (likely(!vhost_exceeds_weight(vq, ++pkts, total_len)));
+ *   - drivers/vhost/vsock.c|545| <<vhost_vsock_handle_tx_kick>> } while (likely(!vhost_exceeds_weight(vq, ++pkts, total_len)));
+ */
 bool vhost_exceeds_weight(struct vhost_virtqueue *vq,
 			  int pkts, int total_len)
 {
@@ -530,6 +711,19 @@ static size_t vhost_get_desc_size(struct vhost_virtqueue *vq,
 	return sizeof(*vq->desc) * num;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1389| <<vhost_net_open>> vhost_dev_init(dev, vqs, VHOST_NET_VQ_MAX,
+ *                       UIO_MAXIOV + VHOST_NET_BATCH, VHOST_NET_PKT_WEIGHT, VHOST_NET_WEIGHT, true, NULL);
+ *   - drivers/vhost/scsi.c|2016| <<vhost_scsi_open>> vhost_dev_init(&vs->dev, vqs, nvqs,
+ *                       UIO_MAXIOV, VHOST_SCSI_WEIGHT, 0, true, NULL);
+ *   - drivers/vhost/test.c|122| <<vhost_test_open>> vhost_dev_init(dev, vqs, VHOST_TEST_VQ_MAX,
+ *                       UIO_MAXIOV, VHOST_TEST_PKT_WEIGHT, VHOST_TEST_WEIGHT, true, NULL);
+ *   - drivers/vhost/vdpa.c|1433| <<vhost_vdpa_open>> vhost_dev_init(dev, vqs, nvqs, 0,
+ *                       0, 0, false, vhost_vdpa_process_iotlb_msg);
+ *   - drivers/vhost/vsock.c|681| <<vhost_vsock_dev_open>> vhost_dev_init(&vsock->dev, vqs,
+ *        ARRAY_SIZE(vsock->vqs), UIO_MAXIOV, VHOST_VSOCK_PKT_WEIGHT, VHOST_VSOCK_WEIGHT, true, NULL);
+ */
 void vhost_dev_init(struct vhost_dev *dev,
 		    struct vhost_virtqueue **vqs, int nvqs,
 		    int iov_limit, int weight, int byte_weight,
@@ -547,6 +741,12 @@ void vhost_dev_init(struct vhost_dev *dev,
 	dev->umem = NULL;
 	dev->iotlb = NULL;
 	dev->mm = NULL;
+	/*
+	 * 在以下使用vhost_dev->iov_limit:
+	 *   - drivers/vhost/vhost.c|639| <<vhost_dev_init>> dev->iov_limit = iov_limit;
+	 *   - drivers/vhost/vhost.c|560| <<vhost_dev_alloc_iovecs>> vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log), GFP_KERNEL);
+	 *   - drivers/vhost/vhost.c|562| <<vhost_dev_alloc_iovecs>> vq->heads = kmalloc_array(dev->iov_limit, sizeof(*vq->heads), GFP_KERNEL);
+	 */
 	dev->iov_limit = iov_limit;
 	dev->weight = weight;
 	dev->byte_weight = byte_weight;
@@ -963,14 +1163,33 @@ long vhost_dev_set_owner(struct vhost_dev *dev)
 }
 EXPORT_SYMBOL_GPL(vhost_dev_set_owner);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|1120| <<vhost_dev_reset_owner_prepare>> return iotlb_alloc();
+ *   - drivers/vhost/vhost.c|1989| <<vhost_set_memory>> newumem = iotlb_alloc();
+ *   - drivers/vhost/vhost.c|2307| <<vhost_init_device_iotlb>> niotlb = iotlb_alloc();
+ */
 static struct vhost_iotlb *iotlb_alloc(void)
 {
+	/*
+	 * called by:
+	 *   - drivers/vdpa/mlx5/core/mr.c|787| <<_mlx5_vdpa_create_mr>> mr->iotlb = vhost_iotlb_alloc(0, 0);
+	 *   - drivers/vdpa/mlx5/core/resources.c|232| <<init_ctrl_vq>> mvdev->cvq.iotlb = vhost_iotlb_alloc(0, 0);
+	 *   - drivers/vdpa/vdpa_user/iova_domain.c|592| <<vduse_domain_create>> domain->iotlb = vhost_iotlb_alloc(0, 0);
+	 *   - drivers/vhost/vhost.c|1114| <<iotlb_alloc>> return vhost_iotlb_alloc(max_iotlb_entries, VHOST_IOTLB_FLAG_RETIRE);
+	 */
 	return vhost_iotlb_alloc(max_iotlb_entries,
 				 VHOST_IOTLB_FLAG_RETIRE);
 }
 
 struct vhost_iotlb *vhost_dev_reset_owner_prepare(void)
 {
+	/*
+	 * called by:
+	 *   - drivers/vhost/vhost.c|1120| <<vhost_dev_reset_owner_prepare>> return iotlb_alloc();
+	 *   - drivers/vhost/vhost.c|1989| <<vhost_set_memory>> newumem = iotlb_alloc();
+	 *   - drivers/vhost/vhost.c|2307| <<vhost_init_device_iotlb>> niotlb = iotlb_alloc();
+	 */
 	return iotlb_alloc();
 }
 EXPORT_SYMBOL_GPL(vhost_dev_reset_owner_prepare);
@@ -1166,6 +1385,12 @@ static int vhost_copy_to_user(struct vhost_virtqueue *vq, void __user *to,
 		if (uaddr)
 			return __copy_to_user(uaddr, from, size);
 
+		/*
+		 * 给一个addr和len, 返回一个数组的iovec[]
+		 * 虽然是一个addr和一个len, 但是产生的iovec可能是多个
+		 * 一个地址和长度完了可以有多个iovec[]
+		 * 返回值: 最后产生的iovec[]的数目
+		 */
 		ret = translate_desc(vq, (u64)(uintptr_t)to, size, vq->iotlb_iov,
 				     ARRAY_SIZE(vq->iotlb_iov),
 				     VHOST_ACCESS_WO);
@@ -1180,6 +1405,10 @@ static int vhost_copy_to_user(struct vhost_virtqueue *vq, void __user *to,
 	return ret;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|1642| <<vhost_get_desc>> return vhost_copy_from_user(vq, desc, vq->desc + idx, sizeof(*desc));
+ */
 static int vhost_copy_from_user(struct vhost_virtqueue *vq, void *to,
 				void __user *from, unsigned size)
 {
@@ -1201,6 +1430,12 @@ static int vhost_copy_from_user(struct vhost_virtqueue *vq, void *to,
 		if (uaddr)
 			return __copy_from_user(to, uaddr, size);
 
+		/*
+		 * 给一个addr和len, 返回一个数组的iovec[]
+		 * 虽然是一个addr和一个len, 但是产生的iovec可能是多个
+		 * 一个地址和长度完了可以有多个iovec[]
+		 * 返回值: 最后产生的iovec[]的数目
+		 */
 		ret = translate_desc(vq, (u64)(uintptr_t)from, size, vq->iotlb_iov,
 				     ARRAY_SIZE(vq->iotlb_iov),
 				     VHOST_ACCESS_RO);
@@ -1226,6 +1461,12 @@ static void __user *__vhost_get_user_slow(struct vhost_virtqueue *vq,
 {
 	int ret;
 
+	/*
+	 * 给一个addr和len, 返回一个数组的iovec[]
+	 * 虽然是一个addr和一个len, 但是产生的iovec可能是多个
+	 * 一个地址和长度完了可以有多个iovec[]
+	 * 返回值: 最后产生的iovec[]的数目
+	 */
 	ret = translate_desc(vq, (u64)(uintptr_t)addr, size, vq->iotlb_iov,
 			     ARRAY_SIZE(vq->iotlb_iov),
 			     VHOST_ACCESS_RO);
@@ -1301,6 +1542,10 @@ static inline int vhost_put_used_flags(struct vhost_virtqueue *vq)
 			      &vq->used->flags);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|3181| <<vhost_add_used_n>> if (vhost_put_used_idx(vq)) {
+ */
 static inline int vhost_put_used_idx(struct vhost_virtqueue *vq)
 
 {
@@ -1403,9 +1648,21 @@ static inline int vhost_get_used_idx(struct vhost_virtqueue *vq,
 	return vhost_get_used(vq, *idx, &vq->used->idx);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|3053| <<vhost_get_vq_desc>> ret = vhost_get_desc(vq, &desc, i);
+ *
+ * struct vhost_virtqueue *vq:
+ * -> vring_desc_t __user *desc;
+ * -> vring_avail_t __user *avail;
+ * -> vring_used_t __user *used;
+ */
 static inline int vhost_get_desc(struct vhost_virtqueue *vq,
 				 struct vring_desc *desc, int idx)
 {
+	/*
+	 * 只在此处调用
+	 */
 	return vhost_copy_from_user(vq, desc, vq->desc + idx, sizeof(*desc));
 }
 
@@ -1731,10 +1988,20 @@ static bool iotlb_access_ok(struct vhost_virtqueue *vq,
 	return true;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|951| <<handle_tx>> if (!vq_meta_prefetch(vq))
+ *   - drivers/vhost/net.c|1120| <<handle_rx>> if (!vq_meta_prefetch(vq))
+ *   - drivers/vhost/vsock.c|103| <<vhost_transport_do_send_pkt>> if (!vq_meta_prefetch(vq))
+ *   - drivers/vhost/vsock.c|494| <<vhost_vsock_handle_tx_kick>> if (!vq_meta_prefetch(vq))
+ */
 int vq_meta_prefetch(struct vhost_virtqueue *vq)
 {
 	unsigned int num = vq->num;
 
+	/*
+	 * 反正一般的vhost-scsi返回NULL
+	 */
 	if (!vq->iotlb)
 		return 1;
 
@@ -1791,6 +2058,11 @@ bool vhost_vq_access_ok(struct vhost_virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(vhost_vq_access_ok);
 
+/*
+ * struct vhost_dev:
+ * -> struct vhost_iotlb *umem;
+ * -> struct vhost_iotlb *iotlb;
+ */
 static long vhost_set_memory(struct vhost_dev *d, struct vhost_memory __user *m)
 {
 	struct vhost_memory mem, *newmem;
@@ -1817,6 +2089,12 @@ static long vhost_set_memory(struct vhost_dev *d, struct vhost_memory __user *m)
 		return -EFAULT;
 	}
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/vhost.c|1120| <<vhost_dev_reset_owner_prepare>> return iotlb_alloc();
+	 *   - drivers/vhost/vhost.c|1989| <<vhost_set_memory>> newumem = iotlb_alloc();
+	 *   - drivers/vhost/vhost.c|2307| <<vhost_init_device_iotlb>> niotlb = iotlb_alloc();
+	 */
 	newumem = iotlb_alloc();
 	if (!newumem) {
 		kvfree(newmem);
@@ -1879,6 +2157,10 @@ static long vhost_vring_set_num(struct vhost_dev *d,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2074| <<vhost_vring_set_num_addr(VHOST_SET_VRING_ADDR)>> r = vhost_vring_set_addr(d, vq, argp);
+ */
 static long vhost_vring_set_addr(struct vhost_dev *d,
 				 struct vhost_virtqueue *vq,
 				 void __user *argp)
@@ -1922,9 +2204,36 @@ static long vhost_vring_set_addr(struct vhost_dev *d,
 			return -EINVAL;
 	}
 
+	/*
+	 *  在以下使用vhost_virtqueue->log_used:
+	 *   - drivers/vhost/vhost.c|461| <<vhost_vq_reset>> vq->log_used = false;
+	 *   - drivers/vhost/vhost.c|1879| <<vq_log_access_ok>> vq_log_used_access_ok(vq, log_base, vq->log_used, vq->log_addr);
+	 *   - drivers/vhost/vhost.c|2024| <<vhost_vring_set_addr>> vq->log_used = !!(a.flags & (0x1 << VHOST_VRING_F_LOG));
+	 *   - drivers/vhost/vhost.c|2591| <<vhost_update_used_flags>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|2612| <<vhost_update_avail_event>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3035| <<__vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3082| <<vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 */
 	vq->log_used = !!(a.flags & (0x1 << VHOST_VRING_F_LOG));
 	vq->desc = (void __user *)(unsigned long)a.desc_user_addr;
 	vq->avail = (void __user *)(unsigned long)a.avail_user_addr;
+	/*
+	 * 这是来自QEMU-9.1的设置和使用:
+	 * 在以下设置vhost_virtqueue->used_phys:
+	 *   - hw/virtio/vhost.c|1594| <<vhost_virtqueue_start>> vq->used_phys = a = virtio_queue_get_used_addr(vdev, idx);
+	 * 在以下使用vhost_virtqueue->used_phys:
+	 *   - hw/virtio/vhost-vdpa.c|1535| <<vhost_vdpa_vq_get_addr>> addr->used_user_addr = (uint64_t)(unsigned long )vq->used_phys;
+	 *   - hw/virtio/vhost.c|382| <<vhost_sync_dirty_bitmap>> if (!vq->used_phys && !vq->used_size) {
+	 *   - hw/virtio/vhost.c|388| <<vhost_sync_dirty_bitmap>> hwaddr used_phys = vq->used_phys, used_size = vq->used_size;
+	 *   - hw/virtio/vhost.c|428| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr,
+	 *          vq->used_phys, range_get_last(vq->used_phys, vq->used_size));
+	 *   - hw/virtio/vhost.c|429| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr,
+	 *          vq->used_phys, range_get_last(vq->used_phys, vq->used_size));
+	 *   - hw/virtio/vhost.c|774| <<vhost_verify_ring_mappings>> r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys, vq->used_size,
+	 *   - hw/virtio/vhost.c|1206| <<vhost_virtqueue_set_addr>> addr.log_guest_addr = vq->used_phys;
+	 *   - hw/virtio/vhost.c|2473| <<vhost_dev_start>> vhost_device_iotlb_miss(hdev, vq->used_phys, true);
+	 *   - hw/virtio/virtio-qmp.c|833| <<qmp_x_query_virtio_vhost_queue_status>> status->used_phys = hdev->vqs[queue].used_phys;
+	 */
 	vq->log_addr = a.log_guest_addr;
 	vq->used = (void __user *)(unsigned long)a.used_user_addr;
 
@@ -2094,15 +2403,31 @@ long vhost_vring_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *arg
 }
 EXPORT_SYMBOL_GPL(vhost_vring_ioctl);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1626| <<vhost_net_set_features>> if (vhost_init_device_iotlb(&n->dev))
+ *   - drivers/vhost/vsock.c|812| <<vhost_vsock_set_features>> if (vhost_init_device_iotlb(&vsock->dev))
+ */
 int vhost_init_device_iotlb(struct vhost_dev *d)
 {
 	struct vhost_iotlb *niotlb, *oiotlb;
 	int i;
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/vhost.c|1120| <<vhost_dev_reset_owner_prepare>> return iotlb_alloc();
+	 *   - drivers/vhost/vhost.c|1989| <<vhost_set_memory>> newumem = iotlb_alloc();
+	 *   - drivers/vhost/vhost.c|2307| <<vhost_init_device_iotlb>> niotlb = iotlb_alloc();
+	 */
 	niotlb = iotlb_alloc();
 	if (!niotlb)
 		return -ENOMEM;
 
+	/*
+	 * struct vhost_dev:
+	 * -> struct vhost_iotlb *umem;
+	 * -> struct vhost_iotlb *iotlb;
+	 */
 	oiotlb = d->iotlb;
 	d->iotlb = niotlb;
 
@@ -2121,6 +2446,14 @@ int vhost_init_device_iotlb(struct vhost_dev *d)
 }
 EXPORT_SYMBOL_GPL(vhost_init_device_iotlb);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1773| <<vhost_net_ioctl>> r = vhost_dev_ioctl(&n->dev, ioctl, argp);
+ *   - drivers/vhost/scsi.c|2112| <<vhost_scsi_ioctl>> r = vhost_dev_ioctl(&vs->dev, ioctl, argp);
+ *   - drivers/vhost/test.c|345| <<vhost_test_ioctl>> r = vhost_dev_ioctl(&n->dev, ioctl, argp);
+ *   - drivers/vhost/vdpa.c|888| <<vhost_vdpa_unlocked_ioctl>> r = vhost_dev_ioctl(&v->vdev, cmd, argp);
+ *   - drivers/vhost/vsock.c|877| <<vhost_vsock_dev_ioctl>> r = vhost_dev_ioctl(&vsock->dev, ioctl, argp);
+ */
 /* Caller must have device mutex */
 long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)
 {
@@ -2197,6 +2530,10 @@ EXPORT_SYMBOL_GPL(vhost_dev_ioctl);
  * (instruction directly accesses the data, with an exception table entry
  * returning -EFAULT). See Documentation/arch/x86/exception-tables.rst.
  */
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2234| <<log_write>> r = set_bit_to_user(bit, (void __user *)(unsigned long )log);
+ */
 static int set_bit_to_user(int nr, void __user *addr)
 {
 	unsigned long log = (unsigned long)addr;
@@ -2216,9 +2553,20 @@ static int set_bit_to_user(int nr, void __user *addr)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2265| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+ *   - drivers/vhost/vhost.c|2290| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+ *   - drivers/vhost/vhost.c|2327| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+ *
+ * 全部的caller都是写入vq->log_base
+ */
 static int log_write(void __user *log_base,
 		     u64 write_address, u64 write_length)
 {
+	/*
+	 * #define VHOST_PAGE_SIZE 0x1000
+	 */
 	u64 write_page = write_address / VHOST_PAGE_SIZE;
 	int r;
 
@@ -2231,6 +2579,9 @@ static int log_write(void __user *log_base,
 		int bit = write_page % 8;
 		if ((u64)(unsigned long)log != log)
 			return -EFAULT;
+		/*
+		 * 只在此处调用
+		 */
 		r = set_bit_to_user(bit, (void __user *)(unsigned long)log);
 		if (r < 0)
 			return r;
@@ -2242,6 +2593,38 @@ static int log_write(void __user *log_base,
 	return r;
 }
 
+/*
+ *  7 struct vhost_iotlb_map {
+ *  8         struct rb_node rb;
+ *  9         struct list_head link;
+ * 10         u64 start;
+ * 11         u64 last;
+ * 12         u64 size;
+ * 13         u64 addr;
+ * 14 #define VHOST_MAP_RO 0x1
+ * 15 #define VHOST_MAP_WO 0x2
+ * 16 #define VHOST_MAP_RW 0x3
+ * 17         u32 perm;
+ * 18         u32 flags_padding;
+ * 19         u64 __subtree_last;
+ * 20         void *opaque;
+ * 21 };
+ * 22
+ * 23 #define VHOST_IOTLB_FLAG_RETIRE 0x1
+ * 24
+ * 25 struct vhost_iotlb {
+ * 26         struct rb_root_cached root;
+ * 27         struct list_head list;
+ * 28         unsigned int limit;
+ * 29         unsigned int nmaps;
+ * 30         unsigned int flags;
+ * 31 };
+ *
+ *
+ * called by:
+ *   - drivers/vhost/vhost.c|2298| <<log_used>> ret = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+ *   - drivers/vhost/vhost.c|2317| <<vhost_log_write>> r = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+ */
 static int log_write_hva(struct vhost_virtqueue *vq, u64 hva, u64 len)
 {
 	struct vhost_iotlb *umem = vq->umem;
@@ -2262,6 +2645,40 @@ static int log_write_hva(struct vhost_virtqueue *vq, u64 hva, u64 len)
 			start = max(u->addr, hva);
 			end = min(u->addr - 1 + u->size, hva - 1 + len);
 			l = end - start + 1;
+			/*
+			 *  7 struct vhost_iotlb_map {
+			 *  8         struct rb_node rb;
+			 *  9         struct list_head link;
+			 * 10         u64 start;
+			 * 11         u64 last;
+			 * 12         u64 size;
+			 * 13         u64 addr; 
+			 * 14 #define VHOST_MAP_RO 0x1        
+			 * 15 #define VHOST_MAP_WO 0x2        
+			 * 16 #define VHOST_MAP_RW 0x3
+			 * 17         u32 perm;         
+			 * 18         u32 flags_padding;
+			 * 19         u64 __subtree_last;
+			 * 20         void *opaque;
+			 * 21 };
+			 *
+			 * 在以下使用vhost_virtqueue->log_base:
+			 *   - drivers/vhost/vhost.c|466| <<vhost_vq_reset>> vq->log_base = NULL;
+			 *   - drivers/vhost/vhost.c|1223| <<memory_access_ok>> ok = vq_memory_access_ok(d->vqs[i]->log_base, umem, log);
+			 *   - drivers/vhost/vhost.c|1886| <<vhost_vq_access_ok>> if (!vq_log_access_ok(vq, vq->log_base))
+			 *   - drivers/vhost/vhost.c|2018| <<vhost_vring_set_addr>> if (!vq_log_used_access_ok(vq, vq->log_base, a.flags & (0x1 << VHOST_VRING_F_LOG), a.log_guest_addr))
+			 *   - drivers/vhost/vhost.c|2269| <<vhost_dev_ioctl(VHOST_SET_LOG_BASE)>> vq->log_base = base;
+			 *   - drivers/vhost/vhost.c|2384| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+			 *   - drivers/vhost/vhost.c|2422| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+			 *   - drivers/vhost/vhost.c|2474| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+			 *
+			 * called by:
+			 *   - drivers/vhost/vhost.c|2265| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+			 *   - drivers/vhost/vhost.c|2290| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+			 *   - drivers/vhost/vhost.c|2327| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+			 *
+			 * 全部的caller都是写入vq->log_base
+			 */
 			r = log_write(vq->log_base,
 				      u->start + start - u->addr,
 				      l);
@@ -2281,20 +2698,78 @@ static int log_write_hva(struct vhost_virtqueue *vq, u64 hva, u64 len)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2353| <<vhost_update_used_flags>> log_used(vq, (used - (void __user *)vq->used), sizeof vq->used->flags);
+ *   - drivers/vhost/vhost.c|2371| <<vhost_update_avail_event>> log_used(vq, (used - (void __user *)vq->used), sizeof *vhost_avail_event(vq));
+ *   - drivers/vhost/vhost.c|2734| <<__vhost_add_used_n>> log_used(vq, ((void __user *)used - (void __user *)vq->used), count * sizeof *used);
+ *   - drivers/vhost/vhost.c|2776| <<vhost_add_used_n>> log_used(vq, offsetof(struct vring_used, idx), sizeof vq->used->idx);
+ */
 static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
 {
+	/*
+	 * struct vhost_virtqueue *vq:
+	 * -> void __user *log_base;
+	 * -> struct vhost_log *log;
+	 * -> struct iovec log_iov[64];
+	 */
 	struct iovec *iov = vq->log_iov;
 	int i, ret;
 
+	/*
+	 * 在以下使用vhost_virtqueue->log_base:
+	 *   - drivers/vhost/vhost.c|466| <<vhost_vq_reset>> vq->log_base = NULL;
+	 *   - drivers/vhost/vhost.c|1223| <<memory_access_ok>> ok = vq_memory_access_ok(d->vqs[i]->log_base, umem, log);
+	 *   - drivers/vhost/vhost.c|1886| <<vhost_vq_access_ok>> if (!vq_log_access_ok(vq, vq->log_base))
+	 *   - drivers/vhost/vhost.c|2018| <<vhost_vring_set_addr>> if (!vq_log_used_access_ok(vq, vq->log_base, a.flags & (0x1 << VHOST_VRING_F_LOG), a.log_guest_addr))
+	 *   - drivers/vhost/vhost.c|2269| <<vhost_dev_ioctl(VHOST_SET_LOG_BASE)>> vq->log_base = base;
+	 *   - drivers/vhost/vhost.c|2384| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+	 *   - drivers/vhost/vhost.c|2422| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+	 *   - drivers/vhost/vhost.c|2474| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+	 *
+	 * 在以下使用vhost_virtqueue->log_addr:
+	 *   - drivers/vhost/vhost.c|373| <<vhost_vq_reset>> vq->log_addr = -1ull;
+	 *   - drivers/vhost/vhost.c|1780| <<vq_log_access_ok>> vq_log_used_access_ok(vq, log_base, vq->log_used, vq->log_addr);
+	 *   - drivers/vhost/vhost.c|1928| <<vhost_vring_set_addr>> vq->log_addr = a.log_guest_addr;
+	 *   - drivers/vhost/vhost.c|2312| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+	 *
+	 *
+	 * called by:
+	 *   - drivers/vhost/vhost.c|2265| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+	 *   - drivers/vhost/vhost.c|2290| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+	 *   - drivers/vhost/vhost.c|2327| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+	 *
+	 * 全部的caller都是写入vq->log_base
+	 */
 	if (!vq->iotlb)
 		return log_write(vq->log_base, vq->log_addr + used_offset, len);
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/vhost.c|1169| <<vhost_copy_to_user>> ret = translate_desc(vq, (u64)(uintptr_t)to, size, vq->iotlb_iov,
+	 *   - drivers/vhost/vhost.c|1204| <<vhost_copy_from_user>> ret = translate_desc(vq, (u64)(uintptr_t)from, size, vq->iotlb_iov,
+	 *   - drivers/vhost/vhost.c|1229| <<__vhost_get_user_slow>> ret = translate_desc(vq, (u64)(uintptr_t)addr, size, vq->iotlb_iov,
+	 *   - drivers/vhost/vhost.c|2320| <<log_used>> ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
+	 *   - drivers/vhost/vhost.c|2528| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+	 *   - drivers/vhost/vhost.c|2569| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+	 *   - drivers/vhost/vhost.c|2688| <<vhost_get_vq_desc>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+	 *
+	 * 给一个addr和len, 返回一个数组的iovec[]
+	 * 虽然是一个addr和一个len, 但是产生的iovec可能是多个
+	 * 一个地址和长度完了可以有多个iovec[]
+	 * 返回值: 最后产生的iovec[]的数目
+	 */
 	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
 			     len, iov, 64, VHOST_ACCESS_WO);
 	if (ret < 0)
 		return ret;
 
 	for (i = 0; i < ret; i++) {
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2298| <<log_used>> ret = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+		 *   - drivers/vhost/vhost.c|2317| <<vhost_log_write>> r = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+		 */
 		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
 				    iov[i].iov_len);
 		if (ret)
@@ -2304,6 +2779,10 @@ static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1219| <<handle_rx>> vhost_log_write(vq, vq_log, log, vhost_len, vq->iov, in);
+ */
 int vhost_log_write(struct vhost_virtqueue *vq, struct vhost_log *log,
 		    unsigned int log_num, u64 len, struct iovec *iov, int count)
 {
@@ -2314,6 +2793,11 @@ int vhost_log_write(struct vhost_virtqueue *vq, struct vhost_log *log,
 
 	if (vq->iotlb) {
 		for (i = 0; i < count; i++) {
+			/*
+			 * called by:
+			 *   - drivers/vhost/vhost.c|2298| <<log_used>> ret = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+			 *   - drivers/vhost/vhost.c|2317| <<vhost_log_write>> r = log_write_hva(vq, (uintptr_t)iov[i].iov_base, iov[i].iov_len);
+			 */
 			r = log_write_hva(vq, (uintptr_t)iov[i].iov_base,
 					  iov[i].iov_len);
 			if (r < 0)
@@ -2324,6 +2808,22 @@ int vhost_log_write(struct vhost_virtqueue *vq, struct vhost_log *log,
 
 	for (i = 0; i < log_num; ++i) {
 		u64 l = min(log[i].len, len);
+		/*
+		 * 在以下使用vhost_virtqueue->log_base:
+		 *   - drivers/vhost/vhost.c|466| <<vhost_vq_reset>> vq->log_base = NULL;
+		 *   - drivers/vhost/vhost.c|1223| <<memory_access_ok>> ok = vq_memory_access_ok(d->vqs[i]->log_base, umem, log);
+		 *   - drivers/vhost/vhost.c|1886| <<vhost_vq_access_ok>> if (!vq_log_access_ok(vq, vq->log_base))
+		 *   - drivers/vhost/vhost.c|2018| <<vhost_vring_set_addr>> if (!vq_log_used_access_ok(vq, vq->log_base, a.flags & (0x1 << VHOST_VRING_F_LOG), a.log_guest_addr))
+		 *   - drivers/vhost/vhost.c|2269| <<vhost_dev_ioctl(VHOST_SET_LOG_BASE)>> vq->log_base = base;
+		 *   - drivers/vhost/vhost.c|2384| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+		 *   - drivers/vhost/vhost.c|2422| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+		 *   - drivers/vhost/vhost.c|2474| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+		 *
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2265| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+		 *   - drivers/vhost/vhost.c|2290| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+		 *   - drivers/vhost/vhost.c|2327| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+		 */
 		r = log_write(vq->log_base, log[i].addr, l);
 		if (r < 0)
 			return r;
@@ -2340,6 +2840,12 @@ int vhost_log_write(struct vhost_virtqueue *vq, struct vhost_log *log,
 }
 EXPORT_SYMBOL_GPL(vhost_log_write);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2422| <<vhost_vq_init_access>> r = vhost_update_used_flags(vq);
+ *   - drivers/vhost/vhost.c|2929| <<vhost_enable_notify>> r = vhost_update_used_flags(vq);
+ *   - drivers/vhost/vhost.c|2965| <<vhost_disable_notify>> r = vhost_update_used_flags(vq);
+ */
 static int vhost_update_used_flags(struct vhost_virtqueue *vq)
 {
 	void __user *used;
@@ -2358,6 +2864,10 @@ static int vhost_update_used_flags(struct vhost_virtqueue *vq)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2936| <<vhost_enable_notify>> r = vhost_update_avail_event(vq);
+ */
 static int vhost_update_avail_event(struct vhost_virtqueue *vq)
 {
 	if (vhost_put_avail_event(vq))
@@ -2376,6 +2886,14 @@ static int vhost_update_avail_event(struct vhost_virtqueue *vq)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1519| <<vhost_net_set_backend>> r = vhost_vq_init_access(vq);
+ *   - drivers/vhost/scsi.c|1786| <<vhost_scsi_set_endpoint>> vhost_vq_init_access(vq);
+ *   - drivers/vhost/test.c|197| <<vhost_test_run>> r = vhost_vq_init_access(&n->vqs[index]);
+ *   - drivers/vhost/test.c|290| <<vhost_test_set_backend>> r = vhost_vq_init_access(vq);
+ *   - drivers/vhost/vsock.c|589| <<vhost_vsock_start>> ret = vhost_vq_init_access(vq);
+ */
 int vhost_vq_init_access(struct vhost_virtqueue *vq)
 {
 	__virtio16 last_used_idx;
@@ -2411,11 +2929,52 @@ int vhost_vq_init_access(struct vhost_virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(vhost_vq_init_access);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|1169| <<vhost_copy_to_user>> ret = translate_desc(vq, (u64)(uintptr_t)to, size, vq->iotlb_iov,
+ *   - drivers/vhost/vhost.c|1204| <<vhost_copy_from_user>> ret = translate_desc(vq, (u64)(uintptr_t)from, size, vq->iotlb_iov,
+ *   - drivers/vhost/vhost.c|1229| <<__vhost_get_user_slow>> ret = translate_desc(vq, (u64)(uintptr_t)addr, size, vq->iotlb_iov,
+ *   - drivers/vhost/vhost.c|2320| <<log_used>> ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
+ *   - drivers/vhost/vhost.c|2528| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+ *   - drivers/vhost/vhost.c|2569| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+ *   - drivers/vhost/vhost.c|2688| <<vhost_get_vq_desc>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+ *
+ * 给一个addr和len, 返回一个数组的iovec[]
+ * 虽然是一个addr和一个len, 但是产生的iovec可能是多个
+ * 一个地址和长度完了可以有多个iovec[]
+ * 返回值: 最后产生的iovec[]的数目
+ */
 static int translate_desc(struct vhost_virtqueue *vq, u64 addr, u32 len,
 			  struct iovec iov[], int iov_size, int access)
 {
+	/*
+	 * struct vhost_iotlb_map {
+	 *     struct rb_node rb;
+	 *     struct list_head link;
+	 *     u64 start;
+	 *     u64 last;
+	 *     u64 size;
+	 *     u64 addr;
+	 * #define VHOST_MAP_RO 0x1
+	 * #define VHOST_MAP_WO 0x2
+	 * #define VHOST_MAP_RW 0x3
+	 *     u32 perm;
+	 *     u32 flags_padding;
+	 *     u64 __subtree_last;
+	 *     void *opaque;
+	 * };
+	 */
 	const struct vhost_iotlb_map *map;
 	struct vhost_dev *dev = vq->dev;
+	/*
+	 * struct vhost_iotlb {
+	 *     struct rb_root_cached root;
+	 *     struct list_head list;
+	 *     unsigned int limit;
+	 *     unsigned int nmaps;
+	 *     unsigned int flags;
+	 * };
+	 */
 	struct vhost_iotlb *umem = dev->iotlb ? dev->iotlb : dev->umem;
 	struct iovec *_iov;
 	u64 s = 0, last = addr + len - 1;
@@ -2442,6 +3001,23 @@ static int translate_desc(struct vhost_virtqueue *vq, u64 addr, u32 len,
 		}
 
 		_iov = iov + ret;
+		/*
+		 * struct vhost_iotlb_map {
+		 *     struct rb_node rb;
+		 *     struct list_head link;
+		 *     u64 start;
+		 *     u64 last;
+		 *     u64 size;
+		 *     u64 addr;
+		 * #define VHOST_MAP_RO 0x1
+		 * #define VHOST_MAP_WO 0x2
+		 * #define VHOST_MAP_RW 0x3
+		 *     u32 perm;
+		 *     u32 flags_padding;
+		 *     u64 __subtree_last;
+		 *     void *opaque;
+		 * };
+		 */
 		size = map->size - addr + map->start;
 		_iov->iov_len = min((u64)len - s, size);
 		_iov->iov_base = (void __user *)(unsigned long)
@@ -2459,6 +3035,11 @@ static int translate_desc(struct vhost_virtqueue *vq, u64 addr, u32 len,
 /* Each buffer in the virtqueues is actually a chain of descriptors.  This
  * function returns the next descriptor in the chain,
  * or -1U if we're at the end. */
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2917| <<get_indirect>> } while ((i = next_desc(vq, &desc)) != -1);
+ *   - drivers/vhost/vhost.c|3066| <<vhost_get_vq_desc>> } while ((i = next_desc(vq, &desc)) != -1);
+ */
 static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)
 {
 	unsigned int next;
@@ -2472,6 +3053,13 @@ static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)
 	return next;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|3060| <<vhost_get_vq_desc>> ret = get_indirect(vq, iov, iov_size,
+ *                              out_num, in_num, log, log_num, &desc);
+ *
+ * 一般来说, iov_size是iov[]的最大长度
+ */
 static int get_indirect(struct vhost_virtqueue *vq,
 			struct iovec iov[], unsigned int iov_size,
 			unsigned int *out_num, unsigned int *in_num,
@@ -2485,6 +3073,9 @@ static int get_indirect(struct vhost_virtqueue *vq,
 	int ret, access;
 
 	/* Sanity check */
+	/*
+	 * 不能有余数, indirect desc的len必须是若干desc
+	 */
 	if (unlikely(len % sizeof desc)) {
 		vq_err(vq, "Invalid length in indirect descriptor: "
 		       "len 0x%llx not multiple of 0x%zx\n",
@@ -2493,6 +3084,34 @@ static int get_indirect(struct vhost_virtqueue *vq,
 		return -EINVAL;
 	}
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/vhost.c|1169| <<vhost_copy_to_user>> ret = translate_desc(vq, (u64)(uintptr_t)to, size, vq->iotlb_iov,
+	 *   - drivers/vhost/vhost.c|1204| <<vhost_copy_from_user>> ret = translate_desc(vq, (u64)(uintptr_t)from, size, vq->iotlb_iov,
+	 *   - drivers/vhost/vhost.c|1229| <<__vhost_get_user_slow>> ret = translate_desc(vq, (u64)(uintptr_t)addr, size, vq->iotlb_iov,
+	 *   - drivers/vhost/vhost.c|2320| <<log_used>> ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
+	 *   - drivers/vhost/vhost.c|2528| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+	 *   - drivers/vhost/vhost.c|2569| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+	 *   - drivers/vhost/vhost.c|2688| <<vhost_get_vq_desc>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+	 *
+	 * 在以下使用vhost_virtqueue->indirect:
+	 * drivers/vhost/vhost.c|688| <<vhost_dev_init>> vq->indirect = NULL;
+	 *   - drivers/vhost/vhost.c|541| <<vhost_vq_free_iovecs>> kfree(vq->indirect);
+	 *   - drivers/vhost/vhost.c|542| <<vhost_vq_free_iovecs>> vq->indirect = NULL;
+	 *   - drivers/vhost/vhost.c|561| <<vhost_dev_alloc_iovecs>> vq->indirect = kmalloc_array(UIO_MAXIOV,
+	 *   - drivers/vhost/vhost.c|562| <<vhost_dev_alloc_iovecs>> sizeof(*vq->indirect),
+	 *   - drivers/vhost/vhost.c|574| <<vhost_dev_alloc_iovecs>> if (!vq->indirect || !vq->log || !vq->heads)
+	 *   - drivers/vhost/vhost.c|2873| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+	 *   - drivers/vhost/vhost.c|2880| <<get_indirect>> iov_iter_init(&from, ITER_SOURCE, vq->indirect, ret, len);
+	 *
+	 * struct vhost_virtqueue *vq:
+	 * -> struct iovec *indirect;
+	 *
+	 * 给一个addr和len, 返回一个数组的iovec[]
+	 * 虽然是一个addr和一个len, 但是产生的iovec可能是多个
+	 * 一个地址和长度完了可以有多个iovec[]
+	 * 返回值: 最后产生的iovec[]的数目
+	 */
 	ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
 			     UIO_MAXIOV, VHOST_ACCESS_RO);
 	if (unlikely(ret < 0)) {
@@ -2510,6 +3129,10 @@ static int get_indirect(struct vhost_virtqueue *vq,
 		return -E2BIG;
 	}
 
+	/*
+	 * 这里循环的条件:
+	 * (i = next_desc(vq, &desc)) != -1)
+	 */
 	do {
 		unsigned iov_count = *in_num + *out_num;
 		if (unlikely(++found > count)) {
@@ -2518,11 +3141,18 @@ static int get_indirect(struct vhost_virtqueue *vq,
 			       i, count);
 			return -EINVAL;
 		}
+		/*
+		 * 每次从from拷贝出来一个desc
+		 * struct vring_desc desc;
+		 */
 		if (unlikely(!copy_from_iter_full(&desc, sizeof(desc), &from))) {
 			vq_err(vq, "Failed indirect descriptor: idx %d, %zx\n",
 			       i, (size_t)vhost64_to_cpu(vq, indirect->addr) + i * sizeof desc);
 			return -EINVAL;
 		}
+		/*
+		 * 不支持nested indirect!
+		 */
 		if (unlikely(desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_INDIRECT))) {
 			vq_err(vq, "Nested indirect descriptor: idx %d, %zx\n",
 			       i, (size_t)vhost64_to_cpu(vq, indirect->addr) + i * sizeof desc);
@@ -2534,6 +3164,25 @@ static int get_indirect(struct vhost_virtqueue *vq,
 		else
 			access = VHOST_ACCESS_RO;
 
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|1169| <<vhost_copy_to_user>> ret = translate_desc(vq, (u64)(uintptr_t)to, size, vq->iotlb_iov,
+		 *   - drivers/vhost/vhost.c|1204| <<vhost_copy_from_user>> ret = translate_desc(vq, (u64)(uintptr_t)from, size, vq->iotlb_iov,
+		 *   - drivers/vhost/vhost.c|1229| <<__vhost_get_user_slow>> ret = translate_desc(vq, (u64)(uintptr_t)addr, size, vq->iotlb_iov,
+		 *   - drivers/vhost/vhost.c|2320| <<log_used>> ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
+		 *   - drivers/vhost/vhost.c|2528| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+		 *   - drivers/vhost/vhost.c|2569| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+		 *   - drivers/vhost/vhost.c|2688| <<vhost_get_vq_desc>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+		 *
+		 * struct iovec iov[]来自参数
+		 *
+		 * ret返回的翻译的iov的数目
+		 *
+		 * 给一个addr和len, 返回一个数组的iovec[]
+		 * 虽然是一个addr和一个len, 但是产生的iovec可能是多个
+		 * 一个地址和长度完了可以有多个iovec[]
+		 * 返回值: 最后产生的iovec[]的数目
+		 */
 		ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
 				     vhost32_to_cpu(vq, desc.len), iov + iov_count,
 				     iov_size - iov_count, access);
@@ -2552,6 +3201,19 @@ static int get_indirect(struct vhost_virtqueue *vq,
 				++*log_num;
 			}
 		} else {
+			/*
+			 * 如果是READ的
+			 * sgs[0] : request header
+			 * sgs[1] : response header
+			 * sgs[2] : sc->sdb.table.sgl (in buffer)
+			 *
+			 * 如果是WRITE的
+			 * sgs[0] : request header
+			 * sgs[1] : sc->sdb.table.sgl (out buffer)
+			 * sgs[2] : response header
+			 *
+			 * in之后不能再有out的buffer了!!!
+			 */
 			/* If it's an output descriptor, they're all supposed
 			 * to come before any input descriptors. */
 			if (unlikely(*in_num)) {
@@ -2561,6 +3223,11 @@ static int get_indirect(struct vhost_virtqueue *vq,
 			}
 			*out_num += ret;
 		}
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2917| <<get_indirect>> } while ((i = next_desc(vq, &desc)) != -1);
+		 *   - drivers/vhost/vhost.c|3066| <<vhost_get_vq_desc>> } while ((i = next_desc(vq, &desc)) != -1);
+		 */
 	} while ((i = next_desc(vq, &desc)) != -1);
 	return 0;
 }
@@ -2573,6 +3240,46 @@ static int get_indirect(struct vhost_virtqueue *vq,
  * This function returns the descriptor number found, or vq->num (which is
  * never a valid descriptor number) if none was found.  A negative code is
  * returned on error. */
+/*
+ * vhost_scsi_handle_kick()
+ * -> vhost_scsi_get_desc()
+ *    -> vhost_get_vq_desc()
+ *
+ *
+ * vhost_scsi_ctl_handle_kick()
+ * -> vhost_scsi_ctl_handle_vq()
+ *    -> vhost_scsi_get_desc()
+ *       -> vhost_get_vq_desc()
+ *
+ *
+ * vhost_scsi_evt_work() or vhost_scsi_send_evt()
+ * -> vhost_scsi_complete_events()
+ *    -> vhost_scsi_do_evt_work()
+ *       -> vhost_get_vq_desc()
+ *
+ *
+ * called by:
+ *   - drivers/vhost/net.c|583| <<vhost_net_tx_get_vq_desc>> int r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+ *   - drivers/vhost/net.c|595| <<vhost_net_tx_get_vq_desc>> r = vhost_get_vq_desc(tvq, tvq->iov, ARRAY_SIZE(tvq->iov), out_num, in_num, NULL, NULL);
+ *   - drivers/vhost/net.c|1041| <<get_rx_bufs>> r = vhost_get_vq_desc(vq, vq->iov + seg, ARRAY_SIZE(vq->iov) - seg, &out, &in, log, log_num);
+ *   - drivers/vhost/scsi.c|481| <<vhost_scsi_do_evt_work>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+ *   - drivers/vhost/scsi.c|966| <<vhost_scsi_get_desc>> vc->head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &vc->out, &vc->in, NULL, NULL);
+ *   - drivers/vhost/test.c|61| <<handle_vq>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+ *   - drivers/vhost/vsock.c|127| <<vhost_transport_do_send_pkt>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+ *   - drivers/vhost/vsock.c|509| <<vhost_vsock_handle_tx_kick>> head = vhost_get_vq_desc(vq, vq->iov, ARRAY_SIZE(vq->iov), &out, &in, NULL, NULL);
+ *
+ * 注释:
+ * This looks in the virtqueue and for the first available buffer, and converts
+ * it to an iovec for convenient access.  Since descriptors consist of some
+ * number of output then some number of input descriptors, it's actually two
+ * iovecs, but we pack them into one and note how many of each there were.
+ *
+ * This function returns the descriptor number found, or vq->num (which is
+ * never a valid descriptor number) if none was found.  A negative code is
+ * returned on error.
+ *
+ * 返回值是这个request的在desc table中的head index
+ */
 int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 		      struct iovec iov[], unsigned int iov_size,
 		      unsigned int *out_num, unsigned int *in_num,
@@ -2595,6 +3302,16 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 
 	/* Grab the next descriptor number they're advertising, and increment
 	 * the index we've seen. */
+	/*
+	 * struct vring_avail {
+	 *     __virtio16 flags;
+	 *     __virtio16 idx;
+	 *     __virtio16 ring[];
+	 *
+	 * 从avail的ring里根据next avail index, 选择一个slot
+	 * slot就是一个desc的index
+	 * };
+	 */
 	if (unlikely(vhost_get_avail_head(vq, &ring_head, last_avail_idx))) {
 		vq_err(vq, "Failed to read head: idx %d address %p\n",
 		       last_avail_idx,
@@ -2602,6 +3319,9 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 		return -EFAULT;
 	}
 
+	/*
+	 * avail ring中指向的下一个desc
+	 */
 	head = vhost16_to_cpu(vq, ring_head);
 
 	/* If their number is silly, that's an error. */
@@ -2630,6 +3350,14 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			       i, vq->num, head);
 			return -EINVAL;
 		}
+		/*
+		 * 只在此处调用, 把vq->desc[i]拷贝到desc
+		 *
+		 * struct vhost_virtqueue *vq:
+		 * -> vring_desc_t __user *desc;
+		 * -> vring_avail_t __user *avail;
+		 * -> vring_used_t __user *used;
+		 */
 		ret = vhost_get_desc(vq, &desc, i);
 		if (unlikely(ret)) {
 			vq_err(vq, "Failed to get descriptor: idx %d addr %p\n",
@@ -2637,6 +3365,9 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			return -EFAULT;
 		}
 		if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_INDIRECT)) {
+			/*
+			 * 只在此处调用get_indirect()
+			 */
 			ret = get_indirect(vq, iov, iov_size,
 					   out_num, in_num,
 					   log, log_num, &desc);
@@ -2646,13 +3377,48 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 						"in indirect descriptor at idx %d\n", i);
 				return ret;
 			}
+			/*
+			 * 如果是INDIRECT这里直接continue了!
+			 * 不会translate也就不会产生iovec!
+			 */
 			continue;
 		}
 
+		/*
+		 * 在以下使用VRING_DESC_F_WRITE:
+		 *   - drivers/vhost/vhost.c|2898| <<get_indirect>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+		 *   - drivers/vhost/vhost.c|3044| <<vhost_get_vq_desc>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+		 *   - drivers/vhost/vringh.c|373| <<__vringh_iov>> if (desc.flags & cpu_to_vringh16(vrh, VRING_DESC_F_WRITE))
+		 *   - drivers/virtio/virtio_ring.c|456| <<vring_unmap_one_split_indirect>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|475| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|484| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|670| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i, addr, sg->length,
+		 *                                             VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+		 *   - drivers/virtio/virtio_ring.c|1266| <<vring_unmap_extra_packed>> dma_unmap_single(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|1274| <<vring_unmap_extra_packed>> dma_unmap_page(vring_dma_dev(vq),... (flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|1292| <<vring_unmap_desc_packed>> dma_unmap_page(vring_dma_dev(vq), ... (flags & VRING_DESC_F_WRITE) ?
+		 *   - drivers/virtio/virtio_ring.c|1350| <<virtqueue_add_indirect_packed>> desc[i].flags = cpu_to_le16(n < out_sgs ? 0 : VRING_DESC_F_WRITE);
+		 *   - drivers/virtio/virtio_ring.c|1504| <<virtqueue_add_packed>> flags = cpu_to_le16(... (n < out_sgs ? 0 : VRING_DESC_F_WRITE));
+		 */
 		if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
 			access = VHOST_ACCESS_WO;
 		else
 			access = VHOST_ACCESS_RO;
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|1169| <<vhost_copy_to_user>> ret = translate_desc(vq, (u64)(uintptr_t)to, size, vq->iotlb_iov,
+		 *   - drivers/vhost/vhost.c|1204| <<vhost_copy_from_user>> ret = translate_desc(vq, (u64)(uintptr_t)from, size, vq->iotlb_iov,
+		 *   - drivers/vhost/vhost.c|1229| <<__vhost_get_user_slow>> ret = translate_desc(vq, (u64)(uintptr_t)addr, size, vq->iotlb_iov,
+		 *   - drivers/vhost/vhost.c|2320| <<log_used>> ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
+		 *   - drivers/vhost/vhost.c|2528| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+		 *   - drivers/vhost/vhost.c|2569| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+		 *   - drivers/vhost/vhost.c|2688| <<vhost_get_vq_desc>> ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
+		 *
+		 * 给一个addr和len, 返回一个数组的iovec[]
+		 * 虽然是一个addr和一个len, 但是产生的iovec可能是多个
+		 * 一个地址和长度完了可以有多个iovec[]
+		 * 返回值: 最后产生的iovec[]的数目
+		 */
 		ret = translate_desc(vq, vhost64_to_cpu(vq, desc.addr),
 				     vhost32_to_cpu(vq, desc.len), iov + iov_count,
 				     iov_size - iov_count, access);
@@ -2667,11 +3433,32 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			 * increment that count. */
 			*in_num += ret;
 			if (unlikely(log && ret)) {
+				/*
+				 * struct vring_desc {
+				 *     __virtio64 addr; 
+				 *     __virtio32 len;          
+				 *     __virtio16 flags;               
+				 *     __virtio16 next;         
+				 * };
+				 */
 				log[*log_num].addr = vhost64_to_cpu(vq, desc.addr);
 				log[*log_num].len = vhost32_to_cpu(vq, desc.len);
 				++*log_num;
 			}
 		} else {
+			/*
+			 * 如果是READ的
+			 * sgs[0] : request header
+			 * sgs[1] : response header
+			 * sgs[2] : sc->sdb.table.sgl (in buffer)
+			 *
+			 * 如果是WRITE的
+			 * sgs[0] : request header
+			 * sgs[1] : sc->sdb.table.sgl (out buffer)
+			 * sgs[2] : response header
+			 *
+			 * in之后不能再有out的buffer了!!!
+			 */
 			/* If it's an output descriptor, they're all supposed
 			 * to come before any input descriptors. */
 			if (unlikely(*in_num)) {
@@ -2681,6 +3468,13 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 			}
 			*out_num += ret;
 		}
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2917| <<get_indirect>> } while ((i = next_desc(vq, &desc)) != -1);
+		 *   - drivers/vhost/vhost.c|3066| <<vhost_get_vq_desc>> } while ((i = next_desc(vq, &desc)) != -1);
+		 *
+		 * 如果是indirect的话, 一般就没有next
+		 */
 	} while ((i = next_desc(vq, &desc)) != -1);
 
 	/* On success, increment avail index. */
@@ -2693,6 +3487,15 @@ int vhost_get_vq_desc(struct vhost_virtqueue *vq,
 }
 EXPORT_SYMBOL_GPL(vhost_get_vq_desc);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|793| <<handle_tx_copy>> vhost_discard_vq_desc(vq, 1);
+ *   - drivers/vhost/net.c|814| <<handle_tx_copy>> vhost_discard_vq_desc(vq, 1);
+ *   - drivers/vhost/net.c|922| <<handle_tx_zerocopy>> vhost_discard_vq_desc(vq, 1);
+ *   - drivers/vhost/net.c|1081| <<get_rx_bufs>> vhost_discard_vq_desc(vq, headcount);
+ *   - drivers/vhost/net.c|1188| <<handle_rx>> vhost_discard_vq_desc(vq, headcount);
+ *   - drivers/vhost/net.c|1212| <<handle_rx>> vhost_discard_vq_desc(vq, headcount);
+ */
 /* Reverse the effect of vhost_get_vq_desc. Useful for error handling. */
 void vhost_discard_vq_desc(struct vhost_virtqueue *vq, int n)
 {
@@ -2700,19 +3503,46 @@ void vhost_discard_vq_desc(struct vhost_virtqueue *vq, int n)
 }
 EXPORT_SYMBOL_GPL(vhost_discard_vq_desc);
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|609| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+ *   - drivers/vhost/vhost.c|2868| <<vhost_add_used_and_signal>> vhost_add_used(vq, head, len);
+ *   - drivers/vhost/vsock.c|216| <<vhost_transport_do_send_pkt>> vhost_add_used(vq, head, sizeof(*hdr) + payload_len);
+ *   - drivers/vhost/vsock.c|543| <<vhost_vsock_handle_tx_kick>> vhost_add_used(vq, head, 0);
+ */
 /* After we've used one of their buffers, we tell them about it.  We'll then
  * want to notify the guest, using eventfd. */
 int vhost_add_used(struct vhost_virtqueue *vq, unsigned int head, int len)
 {
+	/*
+	 * struct vring_used_elem {
+	 *     // Index of start of used descriptor chain.
+	 *     __virtio32 id;
+	 *     // Total length of the descriptor chain which was used (written to)
+	 *     __virtio32 len;
+	 * };
+	 */
 	struct vring_used_elem heads = {
 		cpu_to_vhost32(vq, head),
 		cpu_to_vhost32(vq, len)
 	};
 
+	/*
+	 * called by:
+	 *   - drivers/vhost/scsi.c|609| <<vhost_scsi_complete_cmd_work>> vhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);
+	 *   - drivers/vhost/vhost.c|2868| <<vhost_add_used_and_signal>> vhost_add_used(vq, head, len);
+	 *   - drivers/vhost/vsock.c|216| <<vhost_transport_do_send_pkt>> vhost_add_used(vq, head, sizeof(*hdr) + payload_len);
+	 *   - drivers/vhost/vsock.c|543| <<vhost_vsock_handle_tx_kick>> vhost_add_used(vq, head, 0);
+	 */
 	return vhost_add_used_n(vq, &heads, 1);
 }
 EXPORT_SYMBOL_GPL(vhost_add_used);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2790| <<vhost_add_used_n>> r = __vhost_add_used_n(vq, heads, n);
+ *   - drivers/vhost/vhost.c|2796| <<vhost_add_used_n>> r = __vhost_add_used_n(vq, heads, count);
+ */
 static int __vhost_add_used_n(struct vhost_virtqueue *vq,
 			    struct vring_used_elem *heads,
 			    unsigned count)
@@ -2747,6 +3577,16 @@ static int __vhost_add_used_n(struct vhost_virtqueue *vq,
 
 /* After we've used one of their buffers, we tell them about it.  We'll then
  * want to notify the guest, using eventfd. */
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2744| <<vhost_add_used>> return vhost_add_used_n(vq, &heads, 1);
+ *   - drivers/vhost/vhost.c|2878| <<vhost_add_used_and_signal_n>> vhost_add_used_n(vq, heads, count);
+ *
+ * struct vring_used_elem {
+ *     __virtio32 id;
+ *     __virtio32 len;
+ * };
+ */
 int vhost_add_used_n(struct vhost_virtqueue *vq, struct vring_used_elem *heads,
 		     unsigned count)
 {
@@ -2761,17 +3601,51 @@ int vhost_add_used_n(struct vhost_virtqueue *vq, struct vring_used_elem *heads,
 		heads += n;
 		count -= n;
 	}
+	/*
+	 * called by:
+	 *   - drivers/vhost/vhost.c|2790| <<vhost_add_used_n>> r = __vhost_add_used_n(vq, heads, n);
+	 *   - drivers/vhost/vhost.c|2796| <<vhost_add_used_n>> r = __vhost_add_used_n(vq, heads, count);
+	 */
 	r = __vhost_add_used_n(vq, heads, count);
 
 	/* Make sure buffer is written before we update index. */
 	smp_wmb();
+	/*
+	 * 只在此处调用
+	 */
 	if (vhost_put_used_idx(vq)) {
 		vq_err(vq, "Failed to increment used idx");
 		return -EFAULT;
 	}
+	/*
+	 * 在以下使用vhost_virtqueue->log_used:
+	 *   - drivers/vhost/vhost.c|461| <<vhost_vq_reset>> vq->log_used = false;
+	 *   - drivers/vhost/vhost.c|1879| <<vq_log_access_ok>> vq_log_used_access_ok(vq, log_base, vq->log_used, vq->log_addr);
+	 *   - drivers/vhost/vhost.c|2024| <<vhost_vring_set_addr>> vq->log_used = !!(a.flags & (0x1 << VHOST_VRING_F_LOG));
+	 *   - drivers/vhost/vhost.c|2591| <<vhost_update_used_flags>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|2612| <<vhost_update_avail_event>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3035| <<__vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3082| <<vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 */
 	if (unlikely(vq->log_used)) {
 		/* Make sure used idx is seen before log. */
 		smp_wmb();
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2353| <<vhost_update_used_flags>> log_used(vq, (used - (void __user *)vq->used), sizeof vq->used->flags);
+		 *   - drivers/vhost/vhost.c|2371| <<vhost_update_avail_event>> log_used(vq, (used - (void __user *)vq->used), sizeof *vhost_avail_event(vq));
+		 *   - drivers/vhost/vhost.c|2734| <<__vhost_add_used_n>> log_used(vq, ((void __user *)used - (void __user *)vq->used), count * sizeof *used);
+		 *   - drivers/vhost/vhost.c|2776| <<vhost_add_used_n>> log_used(vq, offsetof(struct vring_used, idx), sizeof vq->used->idx);
+		 *
+		 * 定义:
+		 * static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len) {}
+		 *
+		 * struct vring_used {
+		 *     __virtio16 flags;
+		 *     __virtio16 idx;
+		 *     vring_used_elem_t ring[];
+		 * };
+		 */
 		/* Log used index update. */
 		log_used(vq, offsetof(struct vring_used, idx),
 			 sizeof vq->used->idx);
@@ -2782,6 +3656,10 @@ int vhost_add_used_n(struct vhost_virtqueue *vq, struct vring_used_elem *heads,
 }
 EXPORT_SYMBOL_GPL(vhost_add_used_n);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|2875| <<vhost_signal>> if (vq->call_ctx.ctx && vhost_notify(dev, vq))
+ */
 static bool vhost_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 {
 	__u16 old, new;
@@ -2819,6 +3697,14 @@ static bool vhost_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 	return vring_need_event(vhost16_to_cpu(vq, event), new, old);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/scsi.c|617| <<vhost_scsi_complete_cmd_work>> vhost_signal(&svq->vs->dev, &svq->vq);
+ *   - drivers/vhost/vhost.c|2886| <<vhost_add_used_and_signal>> vhost_signal(dev, vq);
+ *   - drivers/vhost/vhost.c|2901| <<vhost_add_used_and_signal_n>> vhost_signal(dev, vq);
+ *   - drivers/vhost/vsock.c|251| <<vhost_transport_do_send_pkt>> vhost_signal(&vsock->dev, vq);
+ *   - drivers/vhost/vsock.c|549| <<vhost_vsock_handle_tx_kick>> vhost_signal(&vsock->dev, vq);
+ */
 /* This actually signals the guest, using eventfd. */
 void vhost_signal(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 {
@@ -2828,6 +3714,15 @@ void vhost_signal(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(vhost_signal);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|931| <<handle_tx_zerocopy>> vhost_add_used_and_signal(&net->dev, vq, head, 0);
+ *   - drivers/vhost/scsi.c|510| <<vhost_scsi_do_evt_work>> vhost_add_used_and_signal(&vs->dev, vq, head, 0);
+ *   - drivers/vhost/scsi.c|955| <<vhost_scsi_send_bad_target>> vhost_add_used_and_signal(&vs->dev, vq, head, 0);
+ *   - drivers/vhost/scsi.c|1293| <<vhost_scsi_send_tmf_resp>> vhost_add_used_and_signal(&vs->dev, vq, vq_desc, 0);
+ *   - drivers/vhost/scsi.c|1392| <<vhost_scsi_send_an_resp>> vhost_add_used_and_signal(&vs->dev, vq, vc->head, 0);
+ *   - drivers/vhost/test.c|87| <<handle_vq>> vhost_add_used_and_signal(&n->dev, vq, head, 0);
+ */
 /* And here's the combo meal deal.  Supersize me! */
 void vhost_add_used_and_signal(struct vhost_dev *dev,
 			       struct vhost_virtqueue *vq,
@@ -2838,6 +3733,11 @@ void vhost_add_used_and_signal(struct vhost_dev *dev,
 }
 EXPORT_SYMBOL_GPL(vhost_add_used_and_signal);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|376| <<vhost_zerocopy_signal_used>> vhost_add_used_and_signal_n(vq->dev, vq,
+ *   - drivers/vhost/net.c|460| <<vhost_net_signal_used>> vhost_add_used_and_signal_n(dev, vq, vq->heads, nvq->done_idx);
+ */
 /* multi-buffer version of vhost_add_used_and_signal */
 void vhost_add_used_and_signal_n(struct vhost_dev *dev,
 				 struct vhost_virtqueue *vq,
@@ -2848,6 +3748,13 @@ void vhost_add_used_and_signal_n(struct vhost_dev *dev,
 }
 EXPORT_SYMBOL_GPL(vhost_add_used_and_signal_n);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|515| <<vhost_net_busy_poll_try_queue>> if (!vhost_vq_avail_empty(&net->dev, vq)) {
+ *   - drivers/vhost/net.c|557| <<vhost_net_busy_poll>> !vhost_vq_avail_empty(&net->dev, rvq)) ||
+ *   - drivers/vhost/net.c|558| <<vhost_net_busy_poll>> !vhost_vq_avail_empty(&net->dev, tvq))
+ *   - drivers/vhost/net.c|657| <<tx_can_batch>> !vhost_vq_avail_empty(vq->dev, vq);
+ */
 /* return true if we're sure that avaiable ring is empty */
 bool vhost_vq_avail_empty(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 {
@@ -2863,6 +3770,20 @@ bool vhost_vq_avail_empty(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(vhost_vq_avail_empty);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|517| <<vhost_net_busy_poll_try_queue>> } else if (unlikely(vhost_enable_notify(&net->dev, vq))) {
+ *   - drivers/vhost/net.c|569| <<vhost_net_busy_poll>> vhost_enable_notify(&net->dev, rvq);
+ *   - drivers/vhost/net.c|774| <<handle_tx_copy>> } else if (unlikely(vhost_enable_notify(&net->dev,
+ *   - drivers/vhost/net.c|868| <<handle_tx_zerocopy>> } else if (unlikely(vhost_enable_notify(&net->dev, vq))) {
+ *   - drivers/vhost/net.c|1150| <<handle_rx>> } else if (unlikely(vhost_enable_notify(&net->dev, vq))) {
+ *   - drivers/vhost/scsi.c|489| <<vhost_scsi_do_evt_work>> if (vhost_enable_notify(&vs->dev, vq))
+ *   - drivers/vhost/scsi.c|979| <<vhost_scsi_get_desc>> if (unlikely(vhost_enable_notify(&vs->dev, vq))) {
+ *   - drivers/vhost/test.c|70| <<handle_vq>> if (unlikely(vhost_enable_notify(&n->dev, vq))) {
+ *   - drivers/vhost/vsock.c|123| <<vhost_transport_do_send_pkt>> vhost_enable_notify(&vsock->dev, vq);
+ *   - drivers/vhost/vsock.c|139| <<vhost_transport_do_send_pkt>> if (unlikely(vhost_enable_notify(&vsock->dev, vq))) {
+ *   - drivers/vhost/vsock.c|515| <<vhost_vsock_handle_tx_kick>> if (unlikely(vhost_enable_notify(&vsock->dev, vq))) {
+ */
 /* OK, now we need to know about added descriptors. */
 bool vhost_enable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 {
@@ -2879,6 +3800,9 @@ bool vhost_enable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 			return false;
 		}
 	} else {
+		/*
+		 * 只在此处调用
+		 */
 		r = vhost_update_avail_event(vq);
 		if (r) {
 			vq_err(vq, "Failed to update avail event index at %p: %d\n",
@@ -2899,6 +3823,26 @@ bool vhost_enable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(vhost_enable_notify);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|518| <<vhost_net_busy_poll_try_queue>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|541| <<vhost_net_busy_poll>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|776| <<handle_tx_copy>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|869| <<handle_tx_zerocopy>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|954| <<handle_tx>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|1123| <<handle_rx>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/net.c|1153| <<handle_rx>> vhost_disable_notify(&net->dev, vq);
+ *   - drivers/vhost/scsi.c|480| <<vhost_scsi_do_evt_work>> vhost_disable_notify(&vs->dev, vq);
+ *   - drivers/vhost/scsi.c|980| <<vhost_scsi_get_desc>> vhost_disable_notify(&vs->dev, vq);
+ *   - drivers/vhost/scsi.c|1095| <<vhost_scsi_handle_vq>> vhost_disable_notify(&vs->dev, vq);
+ *   - drivers/vhost/scsi.c|1420| <<vhost_scsi_ctl_handle_vq>> vhost_disable_notify(&vs->dev, vq);
+ *   - drivers/vhost/test.c|58| <<handle_vq>> vhost_disable_notify(&n->dev, vq);
+ *   - drivers/vhost/test.c|71| <<handle_vq>> vhost_disable_notify(&n->dev, vq);
+ *   - drivers/vhost/vsock.c|107| <<vhost_transport_do_send_pkt>> vhost_disable_notify(&vsock->dev, vq);
+ *   - drivers/vhost/vsock.c|140| <<vhost_transport_do_send_pkt>> vhost_disable_notify(&vsock->dev, vq);
+ *   - drivers/vhost/vsock.c|497| <<vhost_vsock_handle_tx_kick>> vhost_disable_notify(&vsock->dev, vq);
+ *   - drivers/vhost/vsock.c|516| <<vhost_vsock_handle_tx_kick>> vhost_disable_notify(&vsock->dev, vq);
+ */
 /* We don't need to be notified again. */
 void vhost_disable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 {
@@ -2908,6 +3852,12 @@ void vhost_disable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 		return;
 	vq->used_flags |= VRING_USED_F_NO_NOTIFY;
 	if (!vhost_has_feature(vq, VIRTIO_RING_F_EVENT_IDX)) {
+		/*
+		 * called by:
+		 *   - drivers/vhost/vhost.c|2422| <<vhost_vq_init_access>> r = vhost_update_used_flags(vq);
+		 *   - drivers/vhost/vhost.c|2929| <<vhost_enable_notify>> r = vhost_update_used_flags(vq);
+		 *   - drivers/vhost/vhost.c|2965| <<vhost_disable_notify>> r = vhost_update_used_flags(vq);
+		 */
 		r = vhost_update_used_flags(vq);
 		if (r)
 			vq_err(vq, "Failed to disable notification at %p: %d\n",
@@ -2916,6 +3866,10 @@ void vhost_disable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(vhost_disable_notify);
 
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|1653| <<vhost_iotlb_miss>> node = vhost_new_msg(vq, v2 ? VHOST_IOTLB_MSG_V2 : VHOST_IOTLB_MSG);
+ */
 /* Create a new message. */
 struct vhost_msg_node *vhost_new_msg(struct vhost_virtqueue *vq, int type)
 {
@@ -2958,6 +3912,12 @@ struct vhost_msg_node *vhost_dequeue_msg(struct vhost_dev *dev,
 }
 EXPORT_SYMBOL_GPL(vhost_dequeue_msg);
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1807| <<vhost_net_ioctl>> vhost_set_backend_features(&n->dev, features);
+  4 drivers/vhost/vdpa.c|811| <<vhost_vdpa_unlocked_ioctl>> vhost_set_backend_features(&v->vdev, features);
+ *   - drivers/vhost/vsock.c|873| <<vhost_vsock_dev_ioctl>> vhost_set_backend_features(&vsock->dev, features);
+ */
 void vhost_set_backend_features(struct vhost_dev *dev, u64 features)
 {
 	struct vhost_virtqueue *vq;
@@ -2967,6 +3927,12 @@ void vhost_set_backend_features(struct vhost_dev *dev, u64 features)
 	for (i = 0; i < dev->nvqs; ++i) {
 		vq = dev->vqs[i];
 		mutex_lock(&vq->mutex);
+		/*
+		 * 在以下使用vhost_virtqueue->acked_backend_features:
+		 *   - drivers/vhost/vhost.c|465| <<vhost_vq_reset>> vq->acked_backend_features = 0;
+		 *   - drivers/vhost/vhost.c|3746| <<vhost_set_backend_features>> vq->acked_backend_features = features;
+		 *   - drivers/vhost/vhost.h|361| <<vhost_backend_has_feature>> return vq->acked_backend_features & (1ULL << bit);
+		 */
 		vq->acked_backend_features = features;
 		mutex_unlock(&vq->mutex);
 	}
diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h
index bb75a292d..67a654461 100644
--- a/drivers/vhost/vhost.h
+++ b/drivers/vhost/vhost.h
@@ -122,22 +122,94 @@ struct vhost_virtqueue {
 	bool signalled_used_valid;
 
 	/* Log writes to used structure. */
+	/*
+	 * 在以下使用vhost_virtqueue->log_used:
+	 *   - drivers/vhost/vhost.c|461| <<vhost_vq_reset>> vq->log_used = false;
+	 *   - drivers/vhost/vhost.c|1879| <<vq_log_access_ok>> vq_log_used_access_ok(vq, log_base, vq->log_used, vq->log_addr);
+	 *   - drivers/vhost/vhost.c|2024| <<vhost_vring_set_addr>> vq->log_used = !!(a.flags & (0x1 << VHOST_VRING_F_LOG));
+	 *   - drivers/vhost/vhost.c|2591| <<vhost_update_used_flags>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|2612| <<vhost_update_avail_event>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3035| <<__vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 *   - drivers/vhost/vhost.c|3082| <<vhost_add_used_n>> if (unlikely(vq->log_used)) {
+	 */
 	bool log_used;
+	/*
+	 * 在以下使用vhost_virtqueue->log_addr:
+	 *   - drivers/vhost/vhost.c|373| <<vhost_vq_reset>> vq->log_addr = -1ull;
+	 *   - drivers/vhost/vhost.c|1780| <<vq_log_access_ok>> vq_log_used_access_ok(vq, log_base, vq->log_used, vq->log_addr);
+	 *   - drivers/vhost/vhost.c|1928| <<vhost_vring_set_addr>> vq->log_addr = a.log_guest_addr;
+	 *   - drivers/vhost/vhost.c|2312| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+	 */
 	u64 log_addr;
 
 	struct iovec iov[UIO_MAXIOV];
 	struct iovec iotlb_iov[64];
+	/*
+	 * 在以下使用vhost_virtqueue->indirect:
+	 * drivers/vhost/vhost.c|688| <<vhost_dev_init>> vq->indirect = NULL;
+	 *   - drivers/vhost/vhost.c|541| <<vhost_vq_free_iovecs>> kfree(vq->indirect);
+	 *   - drivers/vhost/vhost.c|542| <<vhost_vq_free_iovecs>> vq->indirect = NULL;
+	 *   - drivers/vhost/vhost.c|561| <<vhost_dev_alloc_iovecs>> vq->indirect = kmalloc_array(UIO_MAXIOV,
+	 *   - drivers/vhost/vhost.c|562| <<vhost_dev_alloc_iovecs>> sizeof(*vq->indirect),
+	 *   - drivers/vhost/vhost.c|574| <<vhost_dev_alloc_iovecs>> if (!vq->indirect || !vq->log || !vq->heads)
+	 *   - drivers/vhost/vhost.c|2873| <<get_indirect>> ret = translate_desc(vq, vhost64_to_cpu(vq, indirect->addr), len, vq->indirect,
+	 *   - drivers/vhost/vhost.c|2880| <<get_indirect>> iov_iter_init(&from, ITER_SOURCE, vq->indirect, ret, len);
+	 */
 	struct iovec *indirect;
 	struct vring_used_elem *heads;
 	/* Protected by virtqueue mutex. */
 	struct vhost_iotlb *umem;
 	struct vhost_iotlb *iotlb;
 	void *private_data;
+	/*
+	 * 在以下使用vhost_virtqueue->acked_features:
+	 *   - drivers/vhost/net.c|1737| <<vhost_net_set_features>> n->vqs[i].vq.acked_features = features;
+	 *   - drivers/vhost/scsi.c|2976| <<vhost_scsi_set_features>> vq->acked_features = features;
+	 *   - drivers/vhost/test.c|253| <<vhost_test_set_features>> vq->acked_features = features;
+	 *   - drivers/vhost/vdpa.c|491| <<vhost_vdpa_set_features>> vq->acked_features = actual_features;
+	 *   - drivers/vhost/vhost.c|464| <<vhost_vq_reset>> vq->acked_features = 0;
+	 *   - drivers/vhost/vhost.h|356| <<vhost_has_feature>> return vq->acked_features & (1ULL << bit);
+	 *   - drivers/vhost/vsock.c|821| <<vhost_vsock_set_features>> vq->acked_features = features;
+	 */
 	u64 acked_features;
+	/*
+	 * 在以下使用vhost_virtqueue->acked_backend_features:
+	 *   - drivers/vhost/vhost.c|465| <<vhost_vq_reset>> vq->acked_backend_features = 0;
+	 *   - drivers/vhost/vhost.c|3746| <<vhost_set_backend_features>> vq->acked_backend_features = features;
+	 *   - drivers/vhost/vhost.h|361| <<vhost_backend_has_feature>> return vq->acked_backend_features & (1ULL << bit);
+	 */
 	u64 acked_backend_features;
 	/* Log write descriptors */
+	/*
+	 * 在以下使用vhost_virtqueue->log_base:
+	 *   - drivers/vhost/vhost.c|466| <<vhost_vq_reset>> vq->log_base = NULL;
+	 *   - drivers/vhost/vhost.c|1223| <<memory_access_ok>> ok = vq_memory_access_ok(d->vqs[i]->log_base, umem, log);
+	 *   - drivers/vhost/vhost.c|1886| <<vhost_vq_access_ok>> if (!vq_log_access_ok(vq, vq->log_base))
+	 *   - drivers/vhost/vhost.c|2018| <<vhost_vring_set_addr>> if (!vq_log_used_access_ok(vq, vq->log_base, a.flags & (0x1 << VHOST_VRING_F_LOG), a.log_guest_addr))
+	 *   - drivers/vhost/vhost.c|2269| <<vhost_dev_ioctl(VHOST_SET_LOG_BASE)>> vq->log_base = base;
+	 *   - drivers/vhost/vhost.c|2384| <<log_write_hva>> r = log_write(vq->log_base, u->start + start - u->addr, l);
+	 *   - drivers/vhost/vhost.c|2422| <<log_used>> return log_write(vq->log_base, vq->log_addr + used_offset, len);
+	 *   - drivers/vhost/vhost.c|2474| <<vhost_log_write>> r = log_write(vq->log_base, log[i].addr, l);
+	 */
 	void __user *log_base;
+	/*
+	 * 在以下使用vhost_virtqueue->log:
+	 *   - drivers/vhost/vhost.c|652| <<vhost_dev_init>> vq->log = NULL;
+	 *   - drivers/vhost/net.c|1180| <<handle_rx>> vq_log = unlikely(vhost_has_feature(vq, VHOST_F_LOG_ALL)) ? vq->log : NULL;
+	 *   - drivers/vhost/vhost.c|543| <<vhost_vq_free_iovecs>> kfree(vq->log);
+	 *   - drivers/vhost/vhost.c|544| <<vhost_vq_free_iovecs>> vq->log = NULL;
+	 *   - drivers/vhost/vhost.c|560| <<vhost_dev_alloc_iovecs>> vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log), GFP_KERNEL);
+	 *   - drivers/vhost/vhost.c|564| <<vhost_dev_alloc_iovecs>> if (!vq->indirect || !vq->log || !vq->heads)
+	 *
+	 * 像是一个临时数组
+	 */
 	struct vhost_log *log;
+	/*
+	 * 在以下使用vhost_virtqueue->log_iov[64]:
+	 *   - drivers/vhost/vhost.c|2485| <<log_used>> struct iovec *iov = vq->log_iov;
+	 *
+	 * 那似乎和vhost_virtqueue->log_base还有vhost_virtqueue->log没有关系
+	 */
 	struct iovec log_iov[64];
 
 	/* Ring endianness. Defaults to legacy native endianness.
@@ -171,6 +243,12 @@ struct vhost_dev {
 	struct list_head read_list;
 	struct list_head pending_list;
 	wait_queue_head_t wait;
+	/*
+	 * 在以下使用vhost_dev->iov_limit:
+	 *   - drivers/vhost/vhost.c|639| <<vhost_dev_init>> dev->iov_limit = iov_limit;
+	 *   - drivers/vhost/vhost.c|560| <<vhost_dev_alloc_iovecs>> vq->log = kmalloc_array(dev->iov_limit, sizeof(*vq->log), GFP_KERNEL);
+	 *   - drivers/vhost/vhost.c|562| <<vhost_dev_alloc_iovecs>> vq->heads = kmalloc_array(dev->iov_limit, sizeof(*vq->heads), GFP_KERNEL);
+	 */
 	int iov_limit;
 	int weight;
 	int byte_weight;
@@ -253,6 +331,14 @@ void vhost_iotlb_map_free(struct vhost_iotlb *iotlb,
 				eventfd_signal((vq)->error_ctx);\
 	} while (0)
 
+/*
+ * 在以下使用VHOST_FEATURES:
+ *   - drivers/vhost/net.c|73| <<global>> VHOST_NET_FEATURES = VHOST_FEATURES |
+ *   - drivers/vhost/scsi.c|305| <<global>> VHOST_SCSI_FEATURES = VHOST_FEATURES | (1ULL << VIRTIO_SCSI_F_HOTPLUG) |
+ *   - drivers/vhost/vsock.c|33| <<global>> VHOST_VSOCK_FEATURES = VHOST_FEATURES |
+ *   - drivers/vhost/test.c|331| <<vhost_test_ioctl>> features = VHOST_FEATURES;
+ *   - drivers/vhost/test.c|338| <<vhost_test_ioctl>> if (features & ~VHOST_FEATURES)
+ */
 enum {
 	VHOST_FEATURES = (1ULL << VIRTIO_F_NOTIFY_ON_EMPTY) |
 			 (1ULL << VIRTIO_RING_F_INDIRECT_DESC) |
@@ -270,6 +356,22 @@ enum {
  *
  * Context: Need to call with vq->mutex acquired.
  */
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1443| <<vhost_net_stop_vq>> vhost_vq_set_backend(vq, NULL);
+ *   - drivers/vhost/net.c|1617| <<vhost_net_set_backend>> vhost_vq_set_backend(vq, sock);
+ *   - drivers/vhost/net.c|1658| <<vhost_net_set_backend>> vhost_vq_set_backend(vq, oldsock);
+ *   - drivers/vhost/scsi.c|2795| <<vhost_scsi_set_endpoint>> vhost_vq_set_backend(vq, vs_tpg);
+ *   - drivers/vhost/scsi.c|2896| <<vhost_scsi_clear_endpoint>> vhost_vq_set_backend(vq, NULL);
+ *   - drivers/vhost/test.c|137| <<vhost_test_stop_vq>> vhost_vq_set_backend(vq, NULL);
+ *   - drivers/vhost/test.c|195| <<vhost_test_run>> vhost_vq_set_backend(vq, priv);
+ *   - drivers/vhost/test.c|287| <<vhost_test_set_backend>> vhost_vq_set_backend(vq, NULL);
+ *   - drivers/vhost/test.c|289| <<vhost_test_set_backend>> vhost_vq_set_backend(vq, backend);
+ *   - drivers/vhost/vsock.c|588| <<vhost_vsock_start>> vhost_vq_set_backend(vq, vsock);
+ *   - drivers/vhost/vsock.c|606| <<vhost_vsock_start>> vhost_vq_set_backend(vq, NULL);
+ *   - drivers/vhost/vsock.c|613| <<vhost_vsock_start>> vhost_vq_set_backend(vq, NULL);
+ *   - drivers/vhost/vsock.c|638| <<vhost_vsock_stop>> vhost_vq_set_backend(vq, NULL);
+ */
 static inline void vhost_vq_set_backend(struct vhost_virtqueue *vq,
 					void *private_data)
 {
@@ -284,18 +386,90 @@ static inline void vhost_vq_set_backend(struct vhost_virtqueue *vq,
  * Context: Need to call with vq->mutex acquired.
  * Return: Private data previously set with vhost_vq_set_backend.
  */
+/*
+ * called by:
+ *   - drivers/vhost/net.c|432| <<vhost_net_disable_vq>> if (!vhost_vq_get_backend(vq))
+ *   - drivers/vhost/net.c|445| <<vhost_net_enable_vq>> sock = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/net.c|542| <<vhost_net_busy_poll>> sock = vhost_vq_get_backend(rvq);
+ *   - drivers/vhost/net.c|588| <<vhost_net_tx_get_vq_desc>> if (!vhost_sock_zcopy(vhost_vq_get_backend(tvq)))
+ *   - drivers/vhost/net.c|590| <<vhost_net_tx_get_vq_desc>> vhost_vq_get_backend(tvq),
+ *   - drivers/vhost/net.c|668| <<vhost_net_build_xdp>> struct socket *sock = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/net.c|947| <<handle_tx>> sock = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/net.c|1163| <<handle_rx>> sock = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/net.c|1441| <<vhost_net_stop_vq>> sock = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/net.c|1607| <<vhost_net_set_backend>> oldsock = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/scsi.c|741| <<vhost_scsi_do_evt_work>> if (!vhost_vq_get_backend(vq)) {
+ *   - drivers/vhost/scsi.c|1639| <<vhost_scsi_get_req>> vs_tpg = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/scsi.c|1734| <<vhost_scsi_handle_vq>> vs_tpg = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/scsi.c|2272| <<vhost_scsi_ctl_handle_vq>> if (!vhost_vq_get_backend(vq))
+ *   - drivers/vhost/scsi.c|2487| <<vhost_scsi_evt_handle_kick>> if (!vhost_vq_get_backend(vq))
+ *   - drivers/vhost/scsi.c|2821| <<vhost_scsi_set_endpoint>> if (!vhost_vq_get_backend(&vs->vqs[i].vq))
+ *   - drivers/vhost/scsi.c|3218| <<vhost_scsi_do_plug>> if (!vhost_vq_get_backend(vq))
+ *   - drivers/vhost/test.c|52| <<handle_vq>> private = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/test.c|136| <<vhost_test_stop_vq>> private = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/test.c|194| <<vhost_test_run>> oldpriv = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/test.c|286| <<vhost_test_set_backend>> backend = vhost_vq_get_backend(vq);
+ *   - drivers/vhost/vhost.c|884| <<__vhost_vq_attach_worker>> if (!vhost_vq_get_backend(vq) && !vq->kick) {
+ *   - drivers/vhost/vsock.c|100| <<vhost_transport_do_send_pkt>> if (!vhost_vq_get_backend(vq))
+ *   - drivers/vhost/vsock.c|491| <<vhost_vsock_handle_tx_kick>> if (!vhost_vq_get_backend(vq))
+ *   - drivers/vhost/vsock.c|587| <<vhost_vsock_start>> if (!vhost_vq_get_backend(vq)) {
+ */
 static inline void *vhost_vq_get_backend(struct vhost_virtqueue *vq)
 {
 	return vq->private_data;
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/net.c|1202| <<handle_rx>> vq_log = unlikely(vhost_has_feature(vq, VHOST_F_LOG_ALL)) ? 
+ *   - drivers/vhost/net.c|1204| <<handle_rx>> mergeable = vhost_has_feature(vq, VIRTIO_NET_F_MRG_RXBUF);
+ *   - drivers/vhost/scsi.c|1723| <<vhost_scsi_handle_vq>> bool t10_pi = vhost_has_feature(vq, VIRTIO_SCSI_F_T10_PI);
+ *   - drivers/vhost/scsi.c|3239| <<vhost_scsi_do_plug>> if (vhost_has_feature(vq, VIRTIO_SCSI_F_HOTPLUG))
+ *   - drivers/vhost/vdpa.c|701| <<vhost_vdpa_vring_ioctl>> if (vhost_has_feature(vq, VIRTIO_F_RING_PACKED)) {
+ *   - drivers/vhost/vdpa.c|740| <<vhost_vdpa_vring_ioctl>> if (vhost_has_feature(vq, VIRTIO_F_RING_PACKED)) {
+ *   - drivers/vhost/vhost.c|152| <<vhost_init_is_le>> vq->is_le = vhost_has_feature(vq, VIRTIO_F_VERSION_1) || !vq->user_be;
+ *   - drivers/vhost/vhost.c|172| <<vhost_init_is_le>> vq->is_le = vhost_has_feature(vq, VIRTIO_F_VERSION_1)
+ *   - drivers/vhost/vhost.c|645| <<vhost_get_avail_size>> vhost_has_feature(vq, VIRTIO_RING_F_EVENT_IDX) ? 2 : 0;
+ *   - drivers/vhost/vhost.c|654| <<vhost_get_used_size>> vhost_has_feature(vq, VIRTIO_RING_F_EVENT_IDX) ? 2 : 0;
+ *   - drivers/vhost/vhost.c|1296| <<memory_access_ok>> log = log_all || vhost_has_feature(d->vqs[i], VHOST_F_LOG_ALL);
+ *   - drivers/vhost/vhost.c|1967| <<vq_log_access_ok>> vhost_has_feature(vq, VHOST_F_LOG_ALL)) &&
+ *   - drivers/vhost/vhost.c|2222| <<vhost_vring_ioctl>> if (vhost_has_feature(vq, VIRTIO_F_RING_PACKED)) {
+ *   - drivers/vhost/vhost.c|2237| <<vhost_vring_ioctl>> if (vhost_has_feature(vq, VIRTIO_F_RING_PACKED))
+ *   - drivers/vhost/vhost.c|3495| <<vhost_notify>> if (vhost_has_feature(vq, VIRTIO_F_NOTIFY_ON_EMPTY) &&
+ *   - drivers/vhost/vhost.c|3499| <<vhost_notify>> if (!vhost_has_feature(vq, VIRTIO_RING_F_EVENT_IDX)) {
+ *   - drivers/vhost/vhost.c|3617| <<vhost_enable_notify>> if (!vhost_has_feature(vq, VIRTIO_RING_F_EVENT_IDX)) {
+ *   - drivers/vhost/vhost.c|3676| <<vhost_disable_notify>> if (!vhost_has_feature(vq, VIRTIO_RING_F_EVENT_IDX)) {
+ */
 static inline bool vhost_has_feature(struct vhost_virtqueue *vq, int bit)
 {
+	/*
+	 * 在以下使用vhost_virtqueue->acked_features:
+	 *   - drivers/vhost/net.c|1737| <<vhost_net_set_features>> n->vqs[i].vq.acked_features = features;
+	 *   - drivers/vhost/scsi.c|2976| <<vhost_scsi_set_features>> vq->acked_features = features;
+	 *   - drivers/vhost/test.c|253| <<vhost_test_set_features>> vq->acked_features = features;
+	 *   - drivers/vhost/vdpa.c|491| <<vhost_vdpa_set_features>> vq->acked_features = actual_features;
+	 *   - drivers/vhost/vhost.c|464| <<vhost_vq_reset>> vq->acked_features = 0;
+	 *   - drivers/vhost/vhost.h|356| <<vhost_has_feature>> return vq->acked_features & (1ULL << bit);
+	 *   - drivers/vhost/vsock.c|821| <<vhost_vsock_set_features>> vq->acked_features = features;
+	 */
 	return vq->acked_features & (1ULL << bit);
 }
 
+/*
+ * called by:
+ *   - drivers/vhost/vdpa.c|237| <<_compat_vdpa_reset>> flags |= !vhost_backend_has_feature(v->vdev.vqs[0],
+ *                                    VHOST_BACKEND_F_IOTLB_PERSIST) ? VDPA_RESET_F_CLEAN_MAP : 0;
+ *   - drivers/vhost/vhost.c|1698| <<vhost_chr_write_iter>> if (vhost_backend_has_feature(dev->vqs[0], VHOST_BACKEND_F_IOTLB_ASID)) {
+ *   - drivers/vhost/vhost.c|1829| <<vhost_iotlb_miss>> bool v2 = vhost_backend_has_feature(vq, VHOST_BACKEND_F_IOTLB_MSG_V2);
+ */
 static inline bool vhost_backend_has_feature(struct vhost_virtqueue *vq, int bit)
 {
+	/*
+	 * 在以下使用vhost_virtqueue->acked_backend_features:
+	 *   - drivers/vhost/vhost.c|465| <<vhost_vq_reset>> vq->acked_backend_features = 0;
+	 *   - drivers/vhost/vhost.c|3746| <<vhost_set_backend_features>> vq->acked_backend_features = features;
+	 *   - drivers/vhost/vhost.h|361| <<vhost_backend_has_feature>> return vq->acked_backend_features & (1ULL << bit);
+	 */
 	return vq->acked_backend_features & (1ULL << bit);
 }
 
diff --git a/drivers/vhost/vsock.c b/drivers/vhost/vsock.c
index 802153e23..4efda0901 100644
--- a/drivers/vhost/vsock.c
+++ b/drivers/vhost/vsock.c
@@ -818,6 +818,16 @@ static int vhost_vsock_set_features(struct vhost_vsock *vsock, u64 features)
 	for (i = 0; i < ARRAY_SIZE(vsock->vqs); i++) {
 		vq = &vsock->vqs[i];
 		mutex_lock(&vq->mutex);
+		/*
+		 * 在以下使用vhost_virtqueue->acked_features:
+		 *   - drivers/vhost/net.c|1737| <<vhost_net_set_features>> n->vqs[i].vq.acked_features = features;
+		 *   - drivers/vhost/scsi.c|2976| <<vhost_scsi_set_features>> vq->acked_features = features;
+		 *   - drivers/vhost/test.c|253| <<vhost_test_set_features>> vq->acked_features = features;
+		 *   - drivers/vhost/vdpa.c|491| <<vhost_vdpa_set_features>> vq->acked_features = actual_features;
+		 *   - drivers/vhost/vhost.c|464| <<vhost_vq_reset>> vq->acked_features = 0;
+		 *   - drivers/vhost/vhost.h|356| <<vhost_has_feature>> return vq->acked_features & (1ULL << bit);
+		 *   - drivers/vhost/vsock.c|821| <<vhost_vsock_set_features>> vq->acked_features = features;
+		 */
 		vq->acked_features = features;
 		mutex_unlock(&vq->mutex);
 	}
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index 98374ed7c..ecf8c02aa 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -69,6 +69,14 @@
 
 struct vring_desc_state_split {
 	void *data;			/* Data for callback. */
+	/*
+	 * 在以下使用vring_desc_state_split->indir_desc:
+	 *   - drivers/virtio/virtio_ring.c|782| <<virtqueue_add_split>> vq->split.desc_state[head].indir_desc = desc;
+	 *   - drivers/virtio/virtio_ring.c|784| <<virtqueue_add_split>> vq->split.desc_state[head].indir_desc = ctx;
+	 *   - drivers/virtio/virtio_ring.c|893| <<detach_buf_split>> struct vring_desc *indir_desc = vq->split.desc_state[head].indir_desc;
+	 *   - drivers/virtio/virtio_ring.c|912| <<detach_buf_split>> vq->split.desc_state[head].indir_desc = NULL;
+	 *   - drivers/virtio/virtio_ring.c|914| <<detach_buf_split>> *ctx = vq->split.desc_state[head].indir_desc;
+	 */
 	struct vring_desc *indir_desc;	/* Indirect descriptor, if any. */
 };
 
@@ -100,6 +108,23 @@ struct vring_virtqueue_split {
 	u16 avail_idx_shadow;
 
 	/* Per-descriptor state. */
+	/*
+	 * 在以下使用vring_virtqueue_split->desc_state:
+	 *   - drivers/virtio/virtio_ring.c|756| <<virtqueue_add_split>> vq->split.desc_state[head].data = data;
+	 *   - drivers/virtio/virtio_ring.c|758| <<virtqueue_add_split>> vq->split.desc_state[head].indir_desc = desc;
+	 *   - drivers/virtio/virtio_ring.c|760| <<virtqueue_add_split>> vq->split.desc_state[head].indir_desc = ctx;
+	 *   - drivers/virtio/virtio_ring.c|849| <<detach_buf_split>> vq->split.desc_state[head].data = NULL;
+	 *   - drivers/virtio/virtio_ring.c|869| <<detach_buf_split>> vq->split.desc_state[head].indir_desc;
+	 *   - drivers/virtio/virtio_ring.c|888| <<detach_buf_split>> vq->split.desc_state[head].indir_desc = NULL;
+	 *   - drivers/virtio/virtio_ring.c|890| <<detach_buf_split>> *ctx = vq->split.desc_state[head].indir_desc;
+	 *   - drivers/virtio/virtio_ring.c|935| <<virtqueue_get_buf_ctx_split>> if (unlikely(!vq->split.desc_state[i].data)) {
+	 *   - drivers/virtio/virtio_ring.c|941| <<virtqueue_get_buf_ctx_split>> ret = vq->split.desc_state[i].data;
+	 *   - drivers/virtio/virtio_ring.c|1060| <<virtqueue_detach_unused_buf_split>> if (!vq->split.desc_state[i].data)
+	 *   - drivers/virtio/virtio_ring.c|1063| <<virtqueue_detach_unused_buf_split>> buf = vq->split.desc_state[i].data;
+	 *   - drivers/virtio/virtio_ring.c|1145| <<vring_alloc_state_extra_split>> vring_split->desc_state = state;
+	 *   - drivers/virtio/virtio_ring.c|1163| <<vring_free_split>> kfree(vring_split->desc_state);
+	 *   - drivers/virtio/virtio_ring.c|3067| <<vring_free>> kfree(vq->split.desc_state);
+	 */
 	struct vring_desc_state_split *desc_state;
 	struct vring_desc_extra *desc_extra;
 
@@ -362,6 +387,13 @@ static struct device *vring_dma_dev(const struct vring_virtqueue *vq)
 	return vq->dma_dev;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|697| <<virtqueue_add_split>> if (vring_map_one_sg(vq, sg, DMA_TO_DEVICE, &addr))
+ *   - drivers/virtio/virtio_ring.c|716| <<virtqueue_add_split>> if (vring_map_one_sg(vq, sg, DMA_FROM_DEVICE, &addr))
+ *   - drivers/virtio/virtio_ring.c|1448| <<virtqueue_add_indirect_packed>> if (vring_map_one_sg(vq, sg, n < out_sgs ?
+ *   - drivers/virtio/virtio_ring.c|1601| <<virtqueue_add_packed>> if (vring_map_one_sg(vq, sg, n < out_sgs ?
+ */
 /* Map one sg entry. */
 static int vring_map_one_sg(const struct vring_virtqueue *vq, struct scatterlist *sg,
 			    enum dma_data_direction direction, dma_addr_t *addr)
@@ -397,6 +429,13 @@ static int vring_map_one_sg(const struct vring_virtqueue *vq, struct scatterlist
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|754| <<virtqueue_add_split>> dma_addr_t addr = vring_map_single(vq, desc,
+ *                                           total_sg * sizeof(struct vring_desc), DMA_TO_DEVICE);
+ *   - drivers/virtio/virtio_ring.c|1461| <<virtqueue_add_indirect_packed>> addr = vring_map_single(vq, desc,
+ *                       total_sg * sizeof(struct vring_packed_desc), DMA_TO_DEVICE);
+ */
 static dma_addr_t vring_map_single(const struct vring_virtqueue *vq,
 				   void *cpu_addr, size_t size,
 				   enum dma_data_direction direction)
@@ -465,6 +504,22 @@ static unsigned int vring_unmap_one_split(const struct vring_virtqueue *vq,
 
 	flags = extra[i].flags;
 
+	/*
+	 * 在以下使用VRING_DESC_F_WRITE:
+	 *   - drivers/vhost/vhost.c|2898| <<get_indirect>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+	 *   - drivers/vhost/vhost.c|3044| <<vhost_get_vq_desc>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+	 *   - drivers/vhost/vringh.c|373| <<__vringh_iov>> if (desc.flags & cpu_to_vringh16(vrh, VRING_DESC_F_WRITE))
+	 *   - drivers/virtio/virtio_ring.c|456| <<vring_unmap_one_split_indirect>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|475| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|484| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|670| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i, addr, sg->length,
+	 *                                             VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+	 *   - drivers/virtio/virtio_ring.c|1266| <<vring_unmap_extra_packed>> dma_unmap_single(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|1274| <<vring_unmap_extra_packed>> dma_unmap_page(vring_dma_dev(vq),... (flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|1292| <<vring_unmap_desc_packed>> dma_unmap_page(vring_dma_dev(vq), ... (flags & VRING_DESC_F_WRITE) ?
+	 *   - drivers/virtio/virtio_ring.c|1350| <<virtqueue_add_indirect_packed>> desc[i].flags = cpu_to_le16(n < out_sgs ? 0 : VRING_DESC_F_WRITE);
+	 *   - drivers/virtio/virtio_ring.c|1504| <<virtqueue_add_packed>> flags = cpu_to_le16(... (n < out_sgs ? 0 : VRING_DESC_F_WRITE));
+	 */
 	if (flags & VRING_DESC_F_INDIRECT) {
 		if (!vq->use_dma_api)
 			goto out;
@@ -512,6 +567,15 @@ static struct vring_desc *alloc_indirect_split(struct virtqueue *_vq,
 	return desc;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|718| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i,
+ *                  addr, sg->length, VRING_DESC_F_NEXT, indirect);
+ *   - drivers/virtio/virtio_ring.c|753| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i,
+ *                  addr, sg->length, VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+ *   - drivers/virtio/virtio_ring.c|778| <<virtqueue_add_split>> virtqueue_add_desc_split(_vq, vq->split.vring.desc,
+ *                  head, addr, total_sg * sizeof(struct vring_desc), VRING_DESC_F_INDIRECT, false);
+ */
 static inline unsigned int virtqueue_add_desc_split(struct virtqueue *vq,
 						    struct vring_desc *desc,
 						    unsigned int i,
@@ -541,6 +605,36 @@ static inline unsigned int virtqueue_add_desc_split(struct virtqueue *vq,
 	return next;
 }
 
+/*
+ * 关于virtio-scsi下发的request
+ *
+ * 在scsi_alloc_sgtables()中把request给map到scsi_cmnd上的
+ *
+ * struct scsi_cmnd *cmd:
+ * -> struct scsi_data_buffer sdb;
+ *    -> struct sg_table table;
+ *       -> struct scatterlist *sgl;        // the list
+ *       -> unsigned int nents;             // number of mapped entries
+ *       -> unsigned int orig_nents;        // original size of list
+ *    -> unsigned length;
+ *
+ * 假设没有prot
+ *
+ * struct scatterlist *sgs[6].
+ *
+ * 如果是READ的
+ * sgs[0] : request header
+ * sgs[1] : response header
+ * sgs[2] : sc->sdb.table.sgl (in buffer)
+ *
+ * 如果是WRITE的
+ * sgs[0] : request header
+ * sgs[1] : sc->sdb.table.sgl (out buffer)
+ * sgs[2] : response header
+ *
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|2210| <<virtqueue_add>> virtqueue_add_split(_vq, sgs, total_sg, out_sgs, in_sgs, data, ctx, gfp);
+ */
 static inline int virtqueue_add_split(struct virtqueue *_vq,
 				      struct scatterlist *sgs[],
 				      unsigned int total_sg,
@@ -552,6 +646,14 @@ static inline int virtqueue_add_split(struct virtqueue *_vq,
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
 	struct scatterlist *sg;
+	/*
+	 * struct vring_desc {
+	 *     __virtio64 addr;
+	 *     __virtio32 len;
+	 *     __virtio16 flags;
+	 *     __virtio16 next;
+	 * };
+	 */
 	struct vring_desc *desc;
 	unsigned int i, n, avail, descs_used, prev, err_idx;
 	int head;
@@ -607,6 +709,10 @@ static inline int virtqueue_add_split(struct virtqueue *_vq,
 		return -ENOSPC;
 	}
 
+	/*
+	 * 一共两个循环
+	 * 第一个循环
+	 */
 	for (n = 0; n < out_sgs; n++) {
 		for (sg = sgs[n]; sg; sg = sg_next(sg)) {
 			dma_addr_t addr;
@@ -615,6 +721,15 @@ static inline int virtqueue_add_split(struct virtqueue *_vq,
 				goto unmap_release;
 
 			prev = i;
+			/*
+			 * called by:
+			 *   - drivers/virtio/virtio_ring.c|718| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i,
+			 *                  addr, sg->length, VRING_DESC_F_NEXT, indirect);
+			 *   - drivers/virtio/virtio_ring.c|753| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i,
+			 *                  addr, sg->length, VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+			 *   - drivers/virtio/virtio_ring.c|778| <<virtqueue_add_split>> virtqueue_add_desc_split(_vq, vq->split.vring.desc,
+			 *                  head, addr, total_sg * sizeof(struct vring_desc), VRING_DESC_F_INDIRECT, false);
+			 */
 			/* Note that we trust indirect descriptor
 			 * table since it use stream DMA mapping.
 			 */
@@ -623,6 +738,9 @@ static inline int virtqueue_add_split(struct virtqueue *_vq,
 						     indirect);
 		}
 	}
+	/*
+	 * 第二个循环
+	 */
 	for (; n < (out_sgs + in_sgs); n++) {
 		for (sg = sgs[n]; sg; sg = sg_next(sg)) {
 			dma_addr_t addr;
@@ -634,6 +752,30 @@ static inline int virtqueue_add_split(struct virtqueue *_vq,
 			/* Note that we trust indirect descriptor
 			 * table since it use stream DMA mapping.
 			 */
+			/*
+			 * 在以下使用VRING_DESC_F_WRITE:
+			 *   - drivers/vhost/vhost.c|2898| <<get_indirect>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+			 *   - drivers/vhost/vhost.c|3044| <<vhost_get_vq_desc>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+			 *   - drivers/vhost/vringh.c|373| <<__vringh_iov>> if (desc.flags & cpu_to_vringh16(vrh, VRING_DESC_F_WRITE))
+			 *   - drivers/virtio/virtio_ring.c|456| <<vring_unmap_one_split_indirect>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|475| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|484| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|670| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i, addr, sg->length,
+			 *                                             VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+			 *   - drivers/virtio/virtio_ring.c|1266| <<vring_unmap_extra_packed>> dma_unmap_single(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|1274| <<vring_unmap_extra_packed>> dma_unmap_page(vring_dma_dev(vq),... (flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|1292| <<vring_unmap_desc_packed>> dma_unmap_page(vring_dma_dev(vq), ... (flags & VRING_DESC_F_WRITE) ?
+			 *   - drivers/virtio/virtio_ring.c|1350| <<virtqueue_add_indirect_packed>> desc[i].flags = cpu_to_le16(n < out_sgs ? 0 : VRING_DESC_F_WRITE);
+			 *   - drivers/virtio/virtio_ring.c|1504| <<virtqueue_add_packed>> flags = cpu_to_le16(... (n < out_sgs ? 0 : VRING_DESC_F_WRITE));
+			 *
+			 * called by:           
+			 *   - drivers/virtio/virtio_ring.c|718| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i,
+			 *                  addr, sg->length, VRING_DESC_F_NEXT, indirect);
+			 *   - drivers/virtio/virtio_ring.c|753| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i,
+			 *                  addr, sg->length, VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+			 *   - drivers/virtio/virtio_ring.c|778| <<virtqueue_add_split>> virtqueue_add_desc_split(_vq, vq->split.vring.desc,
+			 *                  head, addr, total_sg * sizeof(struct vring_desc), VRING_DESC_F_INDIRECT, false);
+			 */
 			i = virtqueue_add_desc_split(_vq, desc, i, addr,
 						     sg->length,
 						     VRING_DESC_F_NEXT |
@@ -659,6 +801,15 @@ static inline int virtqueue_add_split(struct virtqueue *_vq,
 			goto unmap_release;
 		}
 
+		/*
+		 * called by:
+		 *   - drivers/virtio/virtio_ring.c|718| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i,
+		 *                  addr, sg->length, VRING_DESC_F_NEXT, indirect);
+		 *   - drivers/virtio/virtio_ring.c|753| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i,
+		 *                  addr, sg->length, VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+		 *   - drivers/virtio/virtio_ring.c|778| <<virtqueue_add_split>> virtqueue_add_desc_split(_vq, vq->split.vring.desc,
+		 *                  head, addr, total_sg * sizeof(struct vring_desc), VRING_DESC_F_INDIRECT, false);
+		 */
 		virtqueue_add_desc_split(_vq, vq->split.vring.desc,
 					 head, addr,
 					 total_sg * sizeof(struct vring_desc),
@@ -675,8 +826,23 @@ static inline int virtqueue_add_split(struct virtqueue *_vq,
 	else
 		vq->free_head = i;
 
+	/*
+	 * struct vring_virtqueue *vq:
+	 * -> struct vring_virtqueue_split split;
+	 *    -> struct vring_desc_state_split *desc_state;
+	 *       -> void *data;
+	 *       -> struct vring_desc *indir_desc;
+	 */
 	/* Store token and indirect buffer state. */
 	vq->split.desc_state[head].data = data;
+	/*
+	 * 在以下使用vring_desc_state_split->indir_desc:
+	 *   - drivers/virtio/virtio_ring.c|782| <<virtqueue_add_split>> vq->split.desc_state[head].indir_desc = desc;
+	 *   - drivers/virtio/virtio_ring.c|784| <<virtqueue_add_split>> vq->split.desc_state[head].indir_desc = ctx;
+	 *   - drivers/virtio/virtio_ring.c|893| <<detach_buf_split>> struct vring_desc *indir_desc = vq->split.desc_state[head].indir_desc;
+	 *   - drivers/virtio/virtio_ring.c|912| <<detach_buf_split>> vq->split.desc_state[head].indir_desc = NULL;
+	 *   - drivers/virtio/virtio_ring.c|914| <<detach_buf_split>> *ctx = vq->split.desc_state[head].indir_desc;
+	 */
 	if (indirect)
 		vq->split.desc_state[head].indir_desc = desc;
 	else
@@ -1049,9 +1215,28 @@ static void virtqueue_vring_attach_split(struct vring_virtqueue *vq,
 	vq->free_head = 0;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|1271| <<virtqueue_resize_split>> err = vring_alloc_state_extra_split(&vring_split);
+ *   - drivers/virtio/virtio_ring.c|2798| <<__vring_new_virtqueue>> err = vring_alloc_state_extra_split(vring_split);
+ */
 static int vring_alloc_state_extra_split(struct vring_virtqueue_split *vring_split)
 {
+	/*
+	 * struct vring_desc_state_split {
+	 *     void *data;                     // Data for callback.
+	 *     struct vring_desc *indir_desc;  // Indirect descriptor, if any.
+	 * };
+	 */
 	struct vring_desc_state_split *state;
+	/*
+	 * struct vring_desc_extra {
+	 *     dma_addr_t addr;                // Descriptor DMA addr.
+	 *     u32 len;                        // Descriptor length.
+	 *     u16 flags;                      // Descriptor flags.
+	 *     u16 next;                       // The next desc state in a list.
+	 * };
+	 */
 	struct vring_desc_extra *extra;
 	u32 num = vring_split->vring.num;
 
@@ -1138,6 +1323,11 @@ static int vring_alloc_queue_split(struct vring_virtqueue_split *vring_split,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|2813| <<vring_create_virtqueue>> return vring_create_virtqueue_split(index, num, vring_align,
+ *   - drivers/virtio/virtio_ring.c|2838| <<vring_create_virtqueue_dma>> return vring_create_virtqueue_split(index, num, vring_align,
+ */
 static struct virtqueue *vring_create_virtqueue_split(
 	unsigned int index,
 	unsigned int num,
@@ -1888,6 +2078,11 @@ static void *virtqueue_detach_unused_buf_packed(struct virtqueue *_vq)
 	return NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|1168| <<vring_alloc_state_extra_split>> extra = vring_alloc_desc_extra(num);
+ *   - drivers/virtio/virtio_ring.c|2112| <<vring_alloc_state_extra_packed>> extra = vring_alloc_desc_extra(num);
+ */
 static struct vring_desc_extra *vring_alloc_desc_extra(unsigned int num)
 {
 	struct vring_desc_extra *desc_extra;
@@ -2194,6 +2389,13 @@ static int virtqueue_enable_after_reset(struct virtqueue *_vq)
  * Generic functions and exported symbols.
  */
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|2244| <<virtqueue_add_sgs>> return virtqueue_add(_vq, sgs, total_sg, out_sgs, in_sgs, data, NULL, gfp);
+ *   - drivers/virtio/virtio_ring.c|2267| <<virtqueue_add_outbuf>> return virtqueue_add(vq, &sg, num, 1, 0, data, NULL, gfp);
+ *   - drivers/virtio/virtio_ring.c|2289| <<virtqueue_add_inbuf>> return virtqueue_add(vq, &sg, num, 0, 1, data, NULL, gfp);
+ *   - drivers/virtio/virtio_ring.c|2313| <<virtqueue_add_inbuf_ctx>> return virtqueue_add(vq, &sg, num, 0, 1, data, ctx, gfp);
+ */
 static inline int virtqueue_add(struct virtqueue *_vq,
 				struct scatterlist *sgs[],
 				unsigned int total_sg,
@@ -2225,6 +2427,36 @@ static inline int virtqueue_add(struct virtqueue *_vq,
  *
  * Returns zero or a negative error (ie. ENOSPC, ENOMEM, EIO).
  */
+/*
+ * called by:
+ *   - arch/um/drivers/virt-pci.c|135| <<um_pci_send_cmd>> ret = virtqueue_add_sgs(dev->cmd_vq, sgs_list,
+ *   - drivers/block/virtio_blk.c|158| <<virtblk_add_req>> return virtqueue_add_sgs(vq, sgs, num_out, num_in, vbr, GFP_ATOMIC); 
+ *   - drivers/crypto/virtio/virtio_crypto_akcipher_algs.c|272| <<__virtio_crypto_akcipher_do_req>> ret = virtqueue_add_sgs(data_vq->vq, sgs, num_out, num_in, vc_req, GFP_ATOMIC);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|59| <<virtio_crypto_ctrl_vq_request>> err = virtqueue_add_sgs(vcrypto->ctrl_vq, sgs, out_sgs, in_sgs, vc_ctrl_req, GFP_ATOMIC);
+ *   - drivers/crypto/virtio/virtio_crypto_skcipher_algs.c|449| <<__virtio_crypto_skcipher_do_req>> err = virtqueue_add_sgs(data_vq->vq, sgs, num_out,
+ *   - drivers/firmware/arm_scmi/transports/virtio.c|523| <<virtio_send_message>> rc = virtqueue_add_sgs(vioch->vqueue, sgs, 1, 1, msg, GFP_ATOMIC);
+ *   - drivers/gpio/gpio-virtio.c|93| <<_virtio_gpio_req>> ret = virtqueue_add_sgs(vgpio->request_vq, sgs, 1, 1, line, GFP_KERNEL);
+ *   - drivers/gpio/gpio-virtio.c|222| <<virtio_gpio_irq_prepare>> ret = virtqueue_add_sgs(vgpio->event_vq, sgs, 1, 1, irq_line, GFP_ATOMIC);
+ *   - drivers/gpu/drm/virtio/virtgpu_vq.c|357| <<virtio_gpu_queue_ctrl_sgs>> ret = virtqueue_add_sgs(vq, sgs, outcnt, incnt, vbuf, GFP_ATOMIC);
+ *   - drivers/gpu/drm/virtio/virtgpu_vq.c|466| <<virtio_gpu_queue_cursor>> ret = virtqueue_add_sgs(vq, sgs, outcnt, 0, vbuf, GFP_ATOMIC);
+ *   - drivers/i2c/busses/i2c-virtio.c|100| <<virtio_i2c_prepare_reqs>> if (virtqueue_add_sgs(vq, sgs, outcnt, incnt, &reqs[i], GFP_KERNEL)) {
+ *   - drivers/iommu/virtio-iommu.c|247| <<__viommu_add_req>> ret = virtqueue_add_sgs(vq, sg, 1, 1, req, GFP_ATOMIC);
+ *   - drivers/iommu/virtio-iommu.c|251| <<__viommu_add_req>> ret = virtqueue_add_sgs(vq, sg, 1, 1, req, GFP_ATOMIC);
+ *   - drivers/net/virtio_net.c|3271| <<virtnet_send_command_reply>> ret = virtqueue_add_sgs(vi->cvq, sgs, out_num, in_num, vi, GFP_ATOMIC);
+ *   - drivers/nvdimm/nd_virtio.c|78| <<virtio_pmem_flush>> while ((err = virtqueue_add_sgs(vpmem->req_vq, sgs, 1, 1, req_data,
+ *   - drivers/scsi/virtio_scsi.c|471| <<__virtscsi_add_cmd>> return virtqueue_add_sgs(vq, sgs, out_num, in_num, cmd, GFP_ATOMIC);
+ *   - drivers/virtio/virtio_mem.c|1405| <<virtio_mem_send_request>> rc = virtqueue_add_sgs(vm->vq, sgs, 1, 1, vm, GFP_KERNEL);
+ *   - drivers/virtio/virtio_pci_modern.c|90| <<virtqueue_exec_admin_cmd>> ret = virtqueue_add_sgs(vq, sgs, out_num, in_num, cmd, GFP_KERNEL);
+ *   - fs/fuse/virtio_fs.c|1434| <<virtio_fs_enqueue_req>> ret = virtqueue_add_sgs(vq, sgs, out_sgs, in_sgs, req, GFP_ATOMIC);
+ *   - net/9p/trans_virtio.c|281| <<p9_virtio_request>> err = virtqueue_add_sgs(chan->vq, sgs, out_sgs, in_sgs, req,
+ *   - net/9p/trans_virtio.c|509| <<p9_virtio_zc_request>> err = virtqueue_add_sgs(chan->vq, sgs, out_sgs, in_sgs, req,
+ *   - net/vmw_vsock/virtio_transport.c|143| <<virtio_transport_send_skb>> ret = virtqueue_add_sgs(vq, sgs, out_sg, in_sg, skb, gfp);
+ *   - net/vmw_vsock/virtio_transport.c|326| <<virtio_vsock_rx_fill>> ret = virtqueue_add_sgs(vq, &p, 0, 1, skb, GFP_KERNEL);
+ *   - sound/virtio/virtio_card.c|41| <<virtsnd_event_send>> if (virtqueue_add_sgs(vqueue, psgs, 0, 1, event, gfp) || !notify)
+ *   - sound/virtio/virtio_ctl_msg.c|151| <<virtsnd_ctl_msg_send>> rc = virtqueue_add_sgs(queue->vqueue, psgs, nouts, nins, msg,
+ *   - sound/virtio/virtio_pcm_msg.c|234| <<virtsnd_pcm_msg_send>> rc = virtqueue_add_sgs(vqueue, psgs, 2, 1, msg,
+ *   - sound/virtio/virtio_pcm_msg.c|237| <<virtsnd_pcm_msg_send>> rc = virtqueue_add_sgs(vqueue, psgs, 1, 2, msg,
+ */
 int virtqueue_add_sgs(struct virtqueue *_vq,
 		      struct scatterlist *sgs[],
 		      unsigned int out_sgs,
@@ -2241,6 +2473,13 @@ int virtqueue_add_sgs(struct virtqueue *_vq,
 		for (sg = sgs[i]; sg; sg = sg_next(sg))
 			total_sg++;
 	}
+	/*
+	 * called by:
+	 *   - drivers/virtio/virtio_ring.c|2244| <<virtqueue_add_sgs>> return virtqueue_add(_vq, sgs, total_sg, out_sgs, in_sgs, data, NULL, gfp);
+	 *   - drivers/virtio/virtio_ring.c|2267| <<virtqueue_add_outbuf>> return virtqueue_add(vq, &sg, num, 1, 0, data, NULL, gfp);
+	 *   - drivers/virtio/virtio_ring.c|2289| <<virtqueue_add_inbuf>> return virtqueue_add(vq, &sg, num, 0, 1, data, NULL, gfp);
+	 *   - drivers/virtio/virtio_ring.c|2313| <<virtqueue_add_inbuf_ctx>> return virtqueue_add(vq, &sg, num, 0, 1, data, ctx, gfp);
+	 */
 	return virtqueue_add(_vq, sgs, total_sg, out_sgs, in_sgs,
 			     data, NULL, gfp);
 }
@@ -2281,6 +2520,30 @@ EXPORT_SYMBOL_GPL(virtqueue_add_outbuf);
  *
  * Returns zero or a negative error (ie. ENOSPC, ENOMEM, EIO).
  */
+/*
+ * called by:
+ *   - arch/um/drivers/virt-pci.c|479| <<um_pci_irq_vq_addbuf>> if (virtqueue_add_inbuf(vq, sg, 1, buf, GFP_ATOMIC))
+ *   - drivers/bluetooth/virtio_bt.c|42| <<virtbt_add_inbuf>> err = virtqueue_add_inbuf(vq, sg, 1, skb, GFP_KERNEL);
+ *   - drivers/char/hw_random/virtio-rng.c|61| <<request_entropy>> virtqueue_add_inbuf(vi->vq, &sg, 1, vi->data, GFP_KERNEL);
+ *   - drivers/char/virtio_console.c|489| <<add_inbuf>> ret = virtqueue_add_inbuf(vq, sg, 1, buf, GFP_ATOMIC);
+ *   - drivers/firmware/arm_scmi/transports/virtio.c|241| <<scmi_vio_feed_vq_rx>> rc = virtqueue_add_inbuf(vioch->vqueue, &sg_in, 1, msg, GFP_ATOMIC);
+ *   - drivers/iommu/virtio-iommu.c|630| <<viommu_event_handler>> ret = virtqueue_add_inbuf(vq, sg, 1, evt, GFP_ATOMIC);
+ *   - drivers/iommu/virtio-iommu.c|1111| <<viommu_fill_evtq>> ret = virtqueue_add_inbuf(vq, sg, 1, &evts[i], GFP_KERNEL);
+ *   - drivers/misc/nsm.c|214| <<nsm_sendrecv_msg_locked>> rc = virtqueue_add_inbuf(vq, &sg_in, 1, msg->resp.data, GFP_KERNEL);
+ *   - drivers/net/virtio_net.c|1377| <<virtnet_add_recvbuf_xsk>> err = virtqueue_add_inbuf(rq->vq, rq->sg, 1, xsk_buffs[i], gfp);
+ *   - drivers/net/virtio_net.c|2505| <<add_recvbuf_big>> err = virtqueue_add_inbuf(rq->vq, rq->sg, vi->big_packets_num_skbfrags + 2,
+ *   - drivers/net/wireless/virtual/mac80211_hwsim.c|6611| <<hwsim_virtio_rx_work>> err = virtqueue_add_inbuf(vq, sg, 1, skb, GFP_ATOMIC);
+ *   - drivers/net/wireless/virtual/mac80211_hwsim.c|6650| <<fill_vq>> err = virtqueue_add_inbuf(vq, sg, 1, skb, GFP_KERNEL);
+ *   - drivers/rpmsg/virtio_rpmsg_bus.c|768| <<rpmsg_recv_single>> err = virtqueue_add_inbuf(vrp->rvq, &sg, 1, msg, GFP_KERNEL);
+ *   - drivers/rpmsg/virtio_rpmsg_bus.c|942| <<rpmsg_probe>> err = virtqueue_add_inbuf(vrp->rvq, &sg, 1, cpu_addr,
+ *   - drivers/scsi/virtio_scsi.c|245| <<virtscsi_kick_event>> err = virtqueue_add_inbuf(vscsi->event_vq.vq, &sg, 1, event_node,
+ *   - drivers/virtio/virtio_balloon.c|208| <<virtballoon_free_page_report>> err = virtqueue_add_inbuf(vq, sg, nents, vb, GFP_NOWAIT | __GFP_NOWARN);
+ *   - drivers/virtio/virtio_balloon.c|720| <<get_free_page_and_send>> err = virtqueue_add_inbuf(vq, &sg, 1, p, GFP_KERNEL);
+ *   - drivers/virtio/virtio_input.c|30| <<virtinput_queue_evtbuf>> virtqueue_add_inbuf(vi->evt, sg, 1, evtbuf, GFP_ATOMIC);
+ *   - net/vmw_vsock/virtio_transport.c|393| <<virtio_vsock_event_fill_one>> return virtqueue_add_inbuf(vq, &sg, 1, event, GFP_KERNEL);
+ *   - tools/virtio/vhost_net_test.c|359| <<run_rx_test>> r = virtqueue_add_inbuf(vq->vq, &sl, 1,
+ *   - tools/virtio/vringh_test.c|388| <<bool>> err = virtqueue_add_inbuf(vq, sg, num_sg, dbuf, GFP_KERNEL);
+ */
 int virtqueue_add_inbuf(struct virtqueue *vq,
 			struct scatterlist *sg, unsigned int num,
 			void *data,
@@ -2662,6 +2925,21 @@ static struct virtqueue *__vring_new_virtqueue(unsigned int index,
 	return &vq->vq;
 }
 
+/*
+ * called by:
+ *   - arch/um/drivers/virtio_uml.c|958| <<vu_setup_vq>> vq = vring_create_virtqueue(index, num, PAGE_SIZE, vdev, true, true,
+ *   - drivers/s390/virtio/virtio_ccw.c|578| <<virtio_ccw_setup_vq>> vq = vring_create_virtqueue(i, info->num, KVM_VIRTIO_CCW_RING_ALIGN,
+ *   - drivers/virtio/virtio_mmio.c|416| <<vm_setup_vq>> vq = vring_create_virtqueue(index, num, VIRTIO_MMIO_VRING_ALIGN, vdev,
+ *   - drivers/virtio/virtio_pci_legacy.c|131| <<setup_vq>> vq = vring_create_virtqueue(index, num,
+ *   - drivers/virtio/virtio_pci_modern.c|599| <<setup_vq>> vq = vring_create_virtqueue(index, num,
+ *
+ * [    0.651247] bug: vring_create_virtqueue() name=control, index=0, num=128
+ * [    0.652706] bug: vring_create_virtqueue() name=event, index=1, num=128
+ * [    0.654241] bug: vring_create_virtqueue() name=request, index=2, num=128
+ * [    0.655833] bug: vring_create_virtqueue() name=request, index=3, num=128
+ * [    0.657375] bug: vring_create_virtqueue() name=request, index=4, num=128
+ * [    0.658933] bug: vring_create_virtqueue() name=request, index=5, num=128
+ */
 struct virtqueue *vring_create_virtqueue(
 	unsigned int index,
 	unsigned int num,
diff --git a/include/linux/blk-mq.h b/include/linux/blk-mq.h
index 4fecf46ef..a7ba3ad25 100644
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@ -1167,6 +1167,24 @@ static inline unsigned short blk_rq_nr_discard_segments(struct request *rq)
 
 int __blk_rq_map_sg(struct request_queue *q, struct request *rq,
 		struct scatterlist *sglist, struct scatterlist **last_sg);
+/*
+ * called by:
+ *   - block/bsg-lib.c|222| <<bsg_map_buffer>> buf->sg_cnt = blk_rq_map_sg(req->q, req, buf->sg_list);
+ *   - drivers/block/mtip32xx/mtip32xx.c|2059| <<mtip_hw_submit_io>> nents = blk_rq_map_sg(hctx->queue, rq, command->sg);
+ *   - drivers/block/rnbd/rnbd-clt.c|1013| <<rnbd_client_xfer_request>> sg_cnt = blk_rq_map_sg(dev->queue, rq, iu->sgt.sgl);
+ *   - drivers/block/sunvdc.c|488| <<__send_request>> nsg = blk_rq_map_sg(req->q, req, sg);
+ *   - drivers/block/virtio_blk.c|230| <<virtblk_map_data>> return blk_rq_map_sg(hctx->queue, req, vbr->sg_table.sgl);
+ *   - drivers/block/xen-blkfront.c|754| <<blkif_queue_rw_req>> num_sg = blk_rq_map_sg(req->q, req, rinfo->shadow[id].sg);
+ *   - drivers/memstick/core/ms_block.c|1907| <<msb_io_work>> blk_rq_map_sg(msb->queue, req, sg);
+ *   - drivers/memstick/core/mspro_block.c|630| <<mspro_block_issue_req>> msb->seg_count = blk_rq_map_sg(msb->block_req->q,
+ *   - drivers/mmc/core/queue.c|526| <<mmc_queue_map_sg>> return blk_rq_map_sg(mq->queue, req, mqrq->sg);
+ *   - drivers/mtd/ubi/block.c|202| <<ubiblock_read>> blk_rq_map_sg(req->q, req, pdu->usgl.sg);
+ *   - drivers/nvme/host/apple.c|528| <<apple_nvme_map_data>> iod->nents = blk_rq_map_sg(req->q, req, iod->sg);
+ *   - drivers/nvme/host/fc.c|2614| <<nvme_fc_map_data>> op->nents = blk_rq_map_sg(rq->q, rq, freq->sg_table.sgl);
+ *   - drivers/nvme/host/pci.c|798| <<nvme_map_data>> iod->sgt.orig_nents = blk_rq_map_sg(req->q, req, iod->sgt.sgl);
+ *   - drivers/nvme/host/rdma.c|1485| <<nvme_rdma_dma_map_req>> req->data_sgl.nents = blk_rq_map_sg(rq->q, rq,
+ *   - drivers/nvme/target/loop.c|165| <<nvme_loop_queue_rq>> iod->req.sg_cnt = blk_rq_map_sg(req->q, req, iod->sg_table.sgl);
+ */
 static inline int blk_rq_map_sg(struct request_queue *q, struct request *rq,
 		struct scatterlist *sglist)
 {
diff --git a/include/linux/virtio_config.h b/include/linux/virtio_config.h
index 169c7d367..06f184d5a 100644
--- a/include/linux/virtio_config.h
+++ b/include/linux/virtio_config.h
@@ -268,6 +268,42 @@ void virtio_synchronize_cbs(struct virtio_device *dev)
  *
  * Note: vqs are enabled automatically after probe returns.
  */
+/*
+ * called by:
+ *   - arch/um/drivers/virt-pci.c|584| <<um_pci_init_vqs>> virtio_device_ready(dev->vdev);
+ *   - drivers/block/virtio_blk.c|1530| <<virtblk_probe>> virtio_device_ready(vdev);
+ *   - drivers/block/virtio_blk.c|1619| <<virtblk_restore>> virtio_device_ready(vdev);
+ *   - drivers/bluetooth/virtio_bt.c|367| <<virtbt_probe>> virtio_device_ready(vdev);
+ *   - drivers/char/hw_random/virtio-rng.c|161| <<probe_common>> virtio_device_ready(vdev);
+ *   - drivers/char/virtio_console.c|2027| <<virtcons_probe>> virtio_device_ready(portdev->vdev);
+ *   - drivers/char/virtio_console.c|2139| <<virtcons_restore>> virtio_device_ready(portdev->vdev);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|453| <<virtcrypto_probe>> virtio_device_ready(vdev);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|547| <<virtcrypto_restore>> virtio_device_ready(vdev);
+ *   - drivers/gpio/gpio-virtio.c|617| <<virtio_gpio_probe>> virtio_device_ready(vdev);
+ *   - drivers/gpu/drm/virtio/virtgpu_kms.c|247| <<virtio_gpu_init>> virtio_device_ready(vgdev->vdev);
+ *   - drivers/iommu/virtio-iommu.c|1189| <<viommu_probe>> virtio_device_ready(vdev);
+ *   - drivers/net/caif/caif_virtio.c|736| <<cfv_probe>> virtio_device_ready(vdev);
+ *   - drivers/net/virtio_net.c|5452| <<virtnet_restore_up>> virtio_device_ready(vdev);
+ *   - drivers/net/virtio_net.c|6622| <<virtnet_probe>> virtio_device_ready(vdev);
+ *   - drivers/net/wireless/virtual/mac80211_hwsim.c|6693| <<hwsim_virtio_probe>> virtio_device_ready(vdev);
+ *   - drivers/nvdimm/virtio_pmem.c|120| <<virtio_pmem_probe>> virtio_device_ready(vdev);
+ *   - drivers/rpmsg/virtio_rpmsg_bus.c|990| <<rpmsg_probe>> virtio_device_ready(vdev);
+ *   - drivers/scsi/virtio_scsi.c|1161| <<virtscsi_probe>> virtio_device_ready(vdev);
+ *   - drivers/scsi/virtio_scsi.c|1206| <<virtscsi_restore>> virtio_device_ready(vdev);
+ *   - drivers/virtio/virtio.c|347| <<virtio_dev_probe>> virtio_device_ready(dev);
+ *   - drivers/virtio/virtio.c|591| <<virtio_device_restore>> virtio_device_ready(dev);
+ *   - drivers/virtio/virtio_balloon.c|1083| <<virtballoon_probe>> virtio_device_ready(vdev);
+ *   - drivers/virtio/virtio_balloon.c|1170| <<virtballoon_restore>> virtio_device_ready(vdev);
+ *   - drivers/virtio/virtio_input.c|318| <<virtinput_probe>> virtio_device_ready(vdev);
+ *   - drivers/virtio/virtio_input.c|381| <<virtinput_restore>> virtio_device_ready(vdev);
+ *   - drivers/virtio/virtio_mem.c|2873| <<virtio_mem_probe>> virtio_device_ready(vdev);
+ *   - drivers/virtio/virtio_mem.c|3024| <<virtio_mem_restore>> virtio_device_ready(vdev);
+ *   - fs/fuse/virtio_fs.c|1144| <<virtio_fs_probe>> virtio_device_ready(vdev);
+ *   - net/9p/trans_virtio.c|655| <<p9_virtio_probe>> virtio_device_ready(vdev);
+ *   - net/vmw_vsock/virtio_transport.c|679| <<virtio_vsock_vqs_init>> virtio_device_ready(vdev);
+ *   - sound/virtio/virtio_card.c|330| <<virtsnd_probe>> virtio_device_ready(vdev);
+ *   - sound/virtio/virtio_card.c|419| <<virtsnd_restore>> virtio_device_ready(vdev);
+ */
 static inline
 void virtio_device_ready(struct virtio_device *dev)
 {
diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
index 8ecfb9404..9cef67514 100644
--- a/include/scsi/scsi_cmnd.h
+++ b/include/scsi/scsi_cmnd.h
@@ -180,6 +180,17 @@ static inline void scsi_dma_unmap(struct scsi_cmnd *cmd) { }
 
 static inline unsigned scsi_sg_count(struct scsi_cmnd *cmd)
 {
+	/*
+	 * 关于 cmd->sdb.table.sgl = sg;
+	 *
+	 * struct scsi_cmnd *cmd:
+	 * -> struct scsi_data_buffer sdb;
+	 *    -> struct sg_table table;
+	 *       -> struct scatterlist *sgl;        // the list
+	 *       -> unsigned int nents;             // number of mapped entries
+	 *       -> unsigned int orig_nents;        // original size of list
+	 *    -> unsigned length;
+	 */
 	return cmd->sdb.table.nents;
 }
 
diff --git a/include/uapi/linux/vhost_types.h b/include/uapi/linux/vhost_types.h
index d7656908f..dbe5231da 100644
--- a/include/uapi/linux/vhost_types.h
+++ b/include/uapi/linux/vhost_types.h
@@ -164,6 +164,20 @@ struct vhost_vdpa_iova_range {
 };
 
 /* Feature bits */
+/*
+ * 在以下使用VHOST_F_LOG_ALL:
+ *   - drivers/vhost/vhost.h|301| <<global>> (1ULL << VHOST_F_LOG_ALL) |
+ *   - drivers/vhost/net.c|1188| <<handle_rx>> vq_log = unlikely(vhost_has_feature(vq, VHOST_F_LOG_ALL)) ?
+ *   - drivers/vhost/net.c|1693| <<vhost_net_set_features>> if ((features & (1 << VHOST_F_LOG_ALL)) &&
+ *   - drivers/vhost/scsi.c|1946| <<vhost_scsi_set_features>> if ((features & (1 << VHOST_F_LOG_ALL)) &&
+ *   - drivers/vhost/test.c|246| <<vhost_test_set_features>> if ((features & (1 << VHOST_F_LOG_ALL)) &&
+ *   - drivers/vhost/vhost.c|1220| <<memory_access_ok>> log = log_all || vhost_has_feature(d->vqs[i], VHOST_F_LOG_ALL);
+ *   - drivers/vhost/vhost.c|1878| <<vq_log_access_ok>> vhost_has_feature(vq, VHOST_F_LOG_ALL)) &&
+ *   - drivers/vhost/vsock.c|806| <<vhost_vsock_set_features>> if ((features & (1 << VHOST_F_LOG_ALL)) &&
+ *
+ * VHOST_F_LOG_ALL用来Log all write descriptors. Can be changed while device is active.
+ * 是给dev->feature用的
+ */
 /* Log all write descriptors. Can be changed while device is active. */
 #define VHOST_F_LOG_ALL 26
 /* vhost-net should add virtio_net_hdr for RX, and strip for TX packets. */
diff --git a/include/uapi/linux/virtio_ring.h b/include/uapi/linux/virtio_ring.h
index f8c20d3de..5538949d8 100644
--- a/include/uapi/linux/virtio_ring.h
+++ b/include/uapi/linux/virtio_ring.h
@@ -37,6 +37,22 @@
 #include <linux/types.h>
 #include <linux/virtio_types.h>
 
+/*
+ * 在以下使用VRING_DESC_F_WRITE:
+ *   - drivers/vhost/vhost.c|2898| <<get_indirect>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+ *   - drivers/vhost/vhost.c|3044| <<vhost_get_vq_desc>> if (desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_WRITE))
+ *   - drivers/vhost/vringh.c|373| <<__vringh_iov>> if (desc.flags & cpu_to_vringh16(vrh, VRING_DESC_F_WRITE))
+ *   - drivers/virtio/virtio_ring.c|456| <<vring_unmap_one_split_indirect>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|475| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|484| <<vring_unmap_one_split>> dma_unmap_page(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|670| <<virtqueue_add_split>> i = virtqueue_add_desc_split(_vq, desc, i, addr, sg->length,
+ *                                             VRING_DESC_F_NEXT | VRING_DESC_F_WRITE, indirect);
+ *   - drivers/virtio/virtio_ring.c|1266| <<vring_unmap_extra_packed>> dma_unmap_single(vring_dma_dev(vq), ...(flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|1274| <<vring_unmap_extra_packed>> dma_unmap_page(vring_dma_dev(vq),... (flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|1292| <<vring_unmap_desc_packed>> dma_unmap_page(vring_dma_dev(vq), ... (flags & VRING_DESC_F_WRITE) ?
+ *   - drivers/virtio/virtio_ring.c|1350| <<virtqueue_add_indirect_packed>> desc[i].flags = cpu_to_le16(n < out_sgs ? 0 : VRING_DESC_F_WRITE);
+ *   - drivers/virtio/virtio_ring.c|1504| <<virtqueue_add_packed>> flags = cpu_to_le16(... (n < out_sgs ? 0 : VRING_DESC_F_WRITE));
+ */
 /* This marks a buffer as continuing via the next field. */
 #define VRING_DESC_F_NEXT	1
 /* This marks a buffer as write-only (otherwise read-only). */
diff --git a/include/uapi/linux/virtio_scsi.h b/include/uapi/linux/virtio_scsi.h
index 0abaae402..494a3e3f8 100644
--- a/include/uapi/linux/virtio_scsi.h
+++ b/include/uapi/linux/virtio_scsi.h
@@ -125,6 +125,13 @@ struct virtio_scsi_config {
 #define VIRTIO_SCSI_S_OK                       0
 #define VIRTIO_SCSI_S_OVERRUN                  1
 #define VIRTIO_SCSI_S_ABORTED                  2
+/*
+ * 在以下使用VIRTIO_SCSI_S_BAD_TARGET:
+ *   - drivers/scsi/virtio_scsi.c|193| <<virtscsi_complete_cmd>> case VIRTIO_SCSI_S_BAD_TARGET:
+ *   - drivers/scsi/virtio_scsi.c|879| <<virtscsi_queuecommand>> cmd->resp.cmd.response = VIRTIO_SCSI_S_BAD_TARGET;
+ *   - drivers/vhost/scsi.c|1111| <<vhost_scsi_complete_cmd_work>> v_rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
+ *   - drivers/vhost/scsi.c|1678| <<vhost_scsi_send_bad_target>> rsp.response = VIRTIO_SCSI_S_BAD_TARGET;
+ */
 #define VIRTIO_SCSI_S_BAD_TARGET               3
 #define VIRTIO_SCSI_S_RESET                    4
 #define VIRTIO_SCSI_S_BUSY                     5
diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index 908e75a28..488fd36d9 100644
--- a/lib/iov_iter.c
+++ b/lib/iov_iter.c
@@ -159,6 +159,34 @@ size_t fault_in_iov_iter_writeable(const struct iov_iter *i, size_t size)
 }
 EXPORT_SYMBOL(fault_in_iov_iter_writeable);
 
+/*
+ * called by:
+ *   - lib/iov_iter.c|177| <<global>> EXPORT_SYMBOL(iov_iter_init);
+ *   - drivers/acpi/pfr_update.c|458| <<pfru_write>> iov_iter_init(&iter, ITER_SOURCE, &iov, 1, len);
+ *   - drivers/fsi/fsi-sbefifo.c|845| <<sbefifo_user_read>> iov_iter_init(&resp_iter, ITER_DEST, &resp_iov, 1, len);
+ *   - drivers/net/ppp/ppp_generic.c|486| <<ppp_read>> iov_iter_init(&to, ITER_DEST, &iov, 1, count);
+ *   - drivers/vhost/net.c|617| <<init_iov_iter>> iov_iter_init(iter, ITER_SOURCE, vq->iov, out, len);
+ *   - drivers/vhost/net.c|1256| <<handle_rx>> iov_iter_init(&msg.msg_iter, ITER_DEST, vq->iov, 1, 1);
+ *   - drivers/vhost/net.c|1265| <<handle_rx>> iov_iter_init(&msg.msg_iter, ITER_DEST, vq->iov, in, vhost_len);
+ *   - drivers/vhost/scsi.c|1105| <<vhost_scsi_complete_cmd_work>> iov_iter_init(&iov_iter, ITER_DEST, cmd->tvc_resp_iov,
+ *   - drivers/vhost/scsi.c|1762| <<vhost_scsi_get_desc>> iov_iter_init(&vc->out_iter, ITER_SOURCE, vq->iov, vc->out, vc->out_size);
+ *   - drivers/vhost/scsi.c|2067| <<vhost_scsi_handle_vq>> iov_iter_init(&in_iter, ITER_DEST, &vq->iov[vc.out], vc.in,
+ *   - drivers/vhost/scsi.c|2280| <<vhost_scsi_send_tmf_resp>> iov_iter_init(&iov_iter, ITER_DEST, resp_iov, in_iovs, sizeof(rsp));
+ *   - drivers/vhost/scsi.c|2457| <<vhost_scsi_send_an_resp>> iov_iter_init(&iov_iter, ITER_DEST, &vq->iov[vc->out], vc->in, sizeof(rsp));
+ *   - drivers/vhost/vhost.c|1363| <<vhost_copy_to_user>> iov_iter_init(&t, ITER_DEST, vq->iotlb_iov, ret, size);
+ *   - drivers/vhost/vhost.c|1408| <<vhost_copy_from_user>> iov_iter_init(&f, ITER_SOURCE, vq->iotlb_iov, ret, size);
+ *   - drivers/vhost/vhost.c|3079| <<get_indirect>> iov_iter_init(&from, ITER_SOURCE, vq->indirect, ret, len);
+ *   - drivers/vhost/vringh.c|1204| <<copy_from_iotlb>> iov_iter_init(&iter, ITER_SOURCE, ivec.iov.iovec, ret,
+ *   - drivers/vhost/vringh.c|1250| <<copy_to_iotlb>> iov_iter_init(&iter, ITER_DEST, ivec.iov.iovec, ret,
+ *   - drivers/vhost/vsock.c|159| <<vhost_transport_do_send_pkt>> iov_iter_init(&iov_iter, ITER_DEST, &vq->iov[out], in, iov_len);
+ *   - drivers/vhost/vsock.c|352| <<vhost_vsock_alloc_skb>> iov_iter_init(&iov_iter, ITER_SOURCE, vq->iov, out, len);
+ *   - fs/fuse/ioctl.c|327| <<fuse_do_ioctl>> iov_iter_init(&ii, ITER_SOURCE, in_iov, in_iovs, in_size);
+ *   - fs/fuse/ioctl.c|394| <<fuse_do_ioctl>> iov_iter_init(&ii, ITER_DEST, out_iov, out_iovs, transferred);
+ *   - fs/seq_file.c|159| <<seq_read>> iov_iter_init(&iter, ITER_DEST, &iov, 1, size);
+ *   - io_uring/net.c|633| <<io_send>> iov_iter_init(&kmsg->msg.msg_iter, ITER_SOURCE,
+ *   - io_uring/net.c|1101| <<io_recv_buf_select>> iov_iter_init(&kmsg->msg.msg_iter, ITER_DEST, arg.iovs, ret,
+ *  - lib/iov_iter.c|1487| <<__import_iovec>> iov_iter_init(i, type, iov, nr_segs, total_len);
+ */
 void iov_iter_init(struct iov_iter *i, unsigned int direction,
 			const struct iovec *iov, unsigned long nr_segs,
 			size_t count)
-- 
2.39.5 (Apple Git-154)

