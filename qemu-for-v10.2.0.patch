From d2af48d36007957e82965b86fe4a25307afb29e7 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 11 Feb 2026 13:42:48 -0800
Subject: [PATCH 1/1] qemu for v10.2.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-accel-ops.c                 |  69 ++
 accel/kvm/kvm-all.c                       | 116 +++
 accel/tcg/plugin-gen.c                    |   4 +
 backends/hostmem-ram.c                    |  30 +
 backends/hostmem.c                        |  46 +
 contrib/plugins/cache.c                   |   4 +
 dump/dump.c                               |  18 +
 gdbstub/system.c                          |  18 +
 hw/arm/virt-acpi-build.c                  |   8 +
 hw/core/cpu-common.c                      |   5 +
 hw/core/machine-qmp-cmds.c                |   7 +
 hw/core/machine.c                         |  43 +
 hw/core/reset.c                           |  30 +
 hw/core/resettable.c                      |  51 ++
 hw/hyperv/hv-balloon-our_range_memslots.c |  18 +
 hw/hyperv/hv-balloon.c                    |  25 +
 hw/i386/acpi-build.c                      |   8 +
 hw/i386/amd_iommu.c                       |   9 +
 hw/i386/intel_iommu.c                     |   9 +
 hw/i386/isapc.c                           |   7 +
 hw/i386/kvm/clock.c                       | 518 +++++++++++
 hw/i386/microvm.c                         |  16 +
 hw/i386/pc.c                              |  23 +
 hw/i386/pc_piix.c                         |   7 +
 hw/i386/pc_q35.c                          |   7 +
 hw/intc/ioapic.c                          |  18 +
 hw/pci/pci.c                              |  47 +
 hw/vfio/migration.c                       |  69 ++
 hw/vfio/pci.c                             |  14 +
 hw/vfio/vfio-migration-internal.h         |   9 +
 hw/virtio/virtio-balloon-pci.c            |  51 ++
 hw/virtio/virtio-balloon.c                | 991 ++++++++++++++++++++++
 hw/virtio/virtio-pci.c                    |  86 ++
 hw/xen/xen-hvm-common.c                   |   8 +
 include/accel/accel-cpu-ops.h             |  45 +
 include/hw/i386/x86.h                     |   9 +
 include/hw/virtio/virtio-balloon.h        | 111 +++
 include/migration/register.h              |  10 +
 migration/block-dirty-bitmap.c            |  10 +
 migration/channel.c                       |   8 +
 migration/colo.c                          |  83 ++
 migration/cpr-exec.c                      |  18 +
 migration/exec.c                          |   8 +
 migration/fd.c                            |   8 +
 migration/file.c                          |   8 +
 migration/global_state.c                  |   5 +
 migration/migration.c                     | 494 +++++++++++
 migration/migration.h                     |   9 +
 migration/multifd.c                       |   4 +
 migration/options.c                       |   4 +
 migration/postcopy-ram.c                  |  17 +
 migration/ram.c                           |  72 ++
 migration/savevm.c                        | 280 ++++++
 migration/socket.c                        |   8 +
 migration/tls.c                           |   8 +
 monitor/qmp-cmds.c                        |  18 +
 qom/object_interfaces.c                   |  14 +
 replay/replay-debugging.c                 |  18 +
 system/balloon.c                          |  52 ++
 system/cpus.c                             | 213 +++++
 system/main.c                             |  23 +
 system/memory.c                           |  47 +
 system/physmem.c                          | 137 +++
 system/runstate.c                         | 173 ++++
 system/vl.c                               |  16 +
 target/i386/cpu.c                         | 104 +++
 target/i386/cpu.h                         |  30 +
 target/i386/kvm/kvm.c                     | 285 +++++++
 target/i386/kvm/tdx.c                     |  61 ++
 target/i386/machine.c                     |  30 +
 ui/vnc.c                                  |   5 +
 util/main-loop.c                          |  18 +
 72 files changed, 4852 insertions(+)

diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index 8ed6945c2..922d38f10 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -27,6 +27,11 @@
 #include <linux/kvm.h>
 #include "kvm-cpus.h"
 
+/*
+ * 在以下使用kvm_vcpu_thread_fn():
+ *   - accel/kvm/kvm-accel-ops.c|73| <<kvm_start_vcpu_thread>>
+ *        qemu_thread_create(cpu->thread, thread_name, kvm_vcpu_thread_fn, cpu, QEMU_THREAD_JOINABLE);
+ */
 static void *kvm_vcpu_thread_fn(void *arg)
 {
     CPUState *cpu = arg;
@@ -64,6 +69,25 @@ static void *kvm_vcpu_thread_fn(void *arg)
     return NULL;
 }
 
+/*
+ * 在以下使用AccelOpsClass->create_vcpu_thread:
+ *   - accel/hvf/hvf-accel-ops.c|375| <<hvf_accel_ops_class_init>> ops->create_vcpu_thread = hvf_start_vcpu_thread;
+ *   - accel/kvm/kvm-accel-ops.c|98| <<kvm_accel_ops_class_init>> ops->create_vcpu_thread = kvm_start_vcpu_thread;
+ *   - accel/mshv/mshv-all.c|708| <<mshv_accel_ops_class_init>> ops->create_vcpu_thread = mshv_start_vcpu_thread;
+ *   - accel/qtest/qtest.c|68| <<qtest_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+ *   - accel/tcg/tcg-accel-ops.c|206| <<tcg_accel_ops_init>> ops->create_vcpu_thread = mttcg_start_vcpu_thread;
+ *   - accel/tcg/tcg-accel-ops.c|210| <<tcg_accel_ops_init>> ops->create_vcpu_thread = rr_start_vcpu_thread;
+ *   - accel/xen/xen-all.c|156| <<xen_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+ *   - system/cpus.c|771| <<cpus_register_accel>> assert(ops->create_vcpu_thread != NULL);
+ *   - system/cpus.c|801| <<qemu_init_vcpu>> g_assert(cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL);
+ *   - system/cpus.c|802| <<qemu_init_vcpu>> cpus_accel->create_vcpu_thread(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|86| <<nvmm_accel_ops_class_init>> ops->create_vcpu_thread = nvmm_start_vcpu_thread;
+ *   - target/i386/whpx/whpx-accel-ops.c|88| <<whpx_accel_ops_class_init>> ops->create_vcpu_thread = whpx_start_vcpu_thread;
+ *
+ *
+ * 在以下使用kvm_start_vcpu_thread():
+ *   - accel/kvm/kvm-accel-ops.c|98| <<kvm_accel_ops_class_init>> ops->create_vcpu_thread = kvm_start_vcpu_thread;
+ */
 static void kvm_start_vcpu_thread(CPUState *cpu)
 {
     char thread_name[VCPU_THREAD_NAME_SIZE];
@@ -95,11 +119,56 @@ static void kvm_accel_ops_class_init(ObjectClass *oc, const void *data)
 {
     AccelOpsClass *ops = ACCEL_OPS_CLASS(oc);
 
+    /*
+     * 在以下使用AccelOpsClass->create_vcpu_thread:
+     *   - accel/hvf/hvf-accel-ops.c|375| <<hvf_accel_ops_class_init>> ops->create_vcpu_thread = hvf_start_vcpu_thread;
+     *   - accel/kvm/kvm-accel-ops.c|98| <<kvm_accel_ops_class_init>> ops->create_vcpu_thread = kvm_start_vcpu_thread;
+     *   - accel/mshv/mshv-all.c|708| <<mshv_accel_ops_class_init>> ops->create_vcpu_thread = mshv_start_vcpu_thread;
+     *   - accel/qtest/qtest.c|68| <<qtest_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+     *   - accel/tcg/tcg-accel-ops.c|206| <<tcg_accel_ops_init>> ops->create_vcpu_thread = mttcg_start_vcpu_thread;
+     *   - accel/tcg/tcg-accel-ops.c|210| <<tcg_accel_ops_init>> ops->create_vcpu_thread = rr_start_vcpu_thread;
+     *   - accel/xen/xen-all.c|156| <<xen_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+     *   - system/cpus.c|771| <<cpus_register_accel>> assert(ops->create_vcpu_thread != NULL);
+     *   - system/cpus.c|801| <<qemu_init_vcpu>> g_assert(cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL);
+     *   - system/cpus.c|802| <<qemu_init_vcpu>> cpus_accel->create_vcpu_thread(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|86| <<nvmm_accel_ops_class_init>> ops->create_vcpu_thread = nvmm_start_vcpu_thread;
+     *   - target/i386/whpx/whpx-accel-ops.c|88| <<whpx_accel_ops_class_init>> ops->create_vcpu_thread = whpx_start_vcpu_thread;
+     */
     ops->create_vcpu_thread = kvm_start_vcpu_thread;
     ops->cpu_thread_is_idle = kvm_vcpu_thread_is_idle;
     ops->cpus_are_resettable = kvm_cpus_are_resettable;
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_reset():
+     *   - accel/hvf/hvf-accel-ops.c|379| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - accel/mshv/mshv-all.c|710| <<mshv_accel_ops_class_init>> ops->synchronize_post_reset = mshv_cpu_synchronize_post_reset;
+     *   - system/cpus.c|179| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - system/cpus.c|180| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|90| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|93| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|380| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - accel/mshv/mshv-all.c|709| <<mshv_accel_ops_class_init>> ops->synchronize_post_init = mshv_cpu_synchronize_post_init;
+     *   - system/cpus.c|223| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|224| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|91| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|94| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|113| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - accel/mshv/mshv-all.c|711| <<mshv_accel_ops_class_init>> ops->synchronize_state = mshv_cpu_synchronize;
+     *   - system/cpus.c|183| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|184| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     ops->synchronize_state = kvm_cpu_synchronize_state;
     ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
     ops->handle_interrupt = generic_handle_interrupt;
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 28006d73c..80b8e8b0c 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -447,6 +447,10 @@ static int kvm_unpark_vcpu(KVMState *s, unsigned long vcpu_id)
     return kvm_fd;
 }
 
+/*
+ * 在以下使用kvm_reset_parked_vcpus():
+ *   - accel/kvm/kvm-all.c|2974| <<kvm_cpu_synchronize_post_reset>> kvm_reset_parked_vcpus(kvm_state);
+ */
 static void kvm_reset_parked_vcpus(KVMState *s)
 {
     struct KVMParkedVcpu *cpu;
@@ -557,6 +561,10 @@ void kvm_destroy_vcpu(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用kvm_init_vcpu():
+ *   - accel/kvm/kvm-accel-ops.c|42| <<kvm_vcpu_thread_fn>> r = kvm_init_vcpu(cpu, &error_fatal);
+ */
 int kvm_init_vcpu(CPUState *cpu, Error **errp)
 {
     KVMState *s = kvm_state;
@@ -2931,6 +2939,31 @@ static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_state():
+ *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+ *   - accel/kvm/kvm-accel-ops.c|113| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - accel/mshv/mshv-all.c|711| <<mshv_accel_ops_class_init>> ops->synchronize_state = mshv_cpu_synchronize;
+ *   - system/cpus.c|183| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+ *   - system/cpus.c|184| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+ *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+ *
+ *
+ * 在以下使用kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-accel-ops.c|113| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - accel/kvm/kvm-all.c|3325| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+ *   - target/arm/kvm.c|1431| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/arm/kvm.c|2458| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+ *   - target/i386/kvm/kvm.c|5683| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5702| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5721| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5726| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6289| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+ *   - target/loongarch/kvm/kvm.c|1383| <<kvm_loongarch_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/riscv/kvm/kvm-cpu.c|1700| <<kvm_riscv_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/s390x/kvm/kvm.c|1910| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+ */
 void kvm_cpu_synchronize_state(CPUState *cpu)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
@@ -2938,10 +2971,19 @@ void kvm_cpu_synchronize_state(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用kvm_cpu_synchronize_put():
+ *   - accel/kvm/kvm-all.c|2992| <<do_kvm_cpu_synchronize_post_reset>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_RESET_STATE, "after reset")) {
+ *   - accel/kvm/kvm-all.c|3026| <<do_kvm_cpu_synchronize_post_init>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_FULL_STATE, "after init")) {
+ *   - accel/kvm/kvm-all.c|3239| <<kvm_cpu_exec>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_RUNTIME_STATE, "at runtime")) {
+ */
 static bool kvm_cpu_synchronize_put(CPUState *cpu, KvmPutState state,
                                     const char *desc)
 {
     Error *err = NULL;
+    /*
+     * 只在这里调用
+     */
     int ret = kvm_arch_put_registers(cpu, state, &err);
     if (ret) {
         if (err) {
@@ -2966,22 +3008,69 @@ static void do_kvm_cpu_synchronize_post_reset(CPUState *cpu, run_on_cpu_data arg
     }
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_post_reset():
+ *   - accel/hvf/hvf-accel-ops.c|379| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+ *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+ *   - accel/mshv/mshv-all.c|710| <<mshv_accel_ops_class_init>> ops->synchronize_post_reset = mshv_cpu_synchronize_post_reset;
+ *   - system/cpus.c|179| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+ *   - system/cpus.c|180| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|90| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+ *   - target/i386/whpx/whpx-accel-ops.c|93| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+ *
+ *
+ * 在以下使用kvm_cpu_synchronize_post_reset():
+ *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+ */
 void kvm_cpu_synchronize_post_reset(CPUState *cpu)
 {
+    /*
+     * 在以下使用kvm_cpu_synchronize_put():
+     *   - accel/kvm/kvm-all.c|2992| <<do_kvm_cpu_synchronize_post_reset>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_RESET_STATE, "after reset")) {
+     *   - accel/kvm/kvm-all.c|3026| <<do_kvm_cpu_synchronize_post_init>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_FULL_STATE, "after init")) {
+     *   - accel/kvm/kvm-all.c|3239| <<kvm_cpu_exec>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_RUNTIME_STATE, "at runtime")) {
+     */
     run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
 
     if (cpu == first_cpu) {
+        /*
+	 * 只在这里使用
+	 */
         kvm_reset_parked_vcpus(kvm_state);
     }
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-all.c|3038| <<kvm_cpu_synchronize_post_init>> run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
 {
+    /*
+     * 在以下使用kvm_cpu_synchronize_put():
+     *   - accel/kvm/kvm-all.c|2992| <<do_kvm_cpu_synchronize_post_reset>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_RESET_STATE, "after reset")) {
+     *   - accel/kvm/kvm-all.c|3026| <<do_kvm_cpu_synchronize_post_init>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_FULL_STATE, "after init")) {
+     *   - accel/kvm/kvm-all.c|3239| <<kvm_cpu_exec>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_RUNTIME_STATE, "at runtime")) {
+     */
     if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_FULL_STATE, "after init")) {
         exit(1);
     }
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_post_init():
+ *   - accel/hvf/hvf-accel-ops.c|380| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+ *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ *   - accel/mshv/mshv-all.c|709| <<mshv_accel_ops_class_init>> ops->synchronize_post_init = mshv_cpu_synchronize_post_init;
+ *   - system/cpus.c|223| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+ *   - system/cpus.c|224| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|91| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+ *   - target/i386/whpx/whpx-accel-ops.c|94| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+ *
+ *
+ * 在以下使用kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ */
 void kvm_cpu_synchronize_post_init(CPUState *cpu)
 {
     if (!kvm_state->guest_state_protected) {
@@ -3141,8 +3230,29 @@ int kvm_convert_memory(hwaddr start, hwaddr size, bool to_private)
              */
             goto out_unref;
         }
+        /*
+	 * 在以下使用ram_block_discard_range():
+         *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+         *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+         *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+         *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+         *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+         *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+         *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+         *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+         *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+	 */
         ret = ram_block_discard_range(rb, offset, size);
     } else {
+        /*
+	 * 只在这里调用
+	 */
         ret = ram_block_discard_guest_memfd_range(rb, offset, size);
     }
 
@@ -3169,6 +3279,12 @@ int kvm_cpu_exec(CPUState *cpu)
         MemTxAttrs attrs;
 
         if (cpu->vcpu_dirty) {
+            /*
+	     * 在以下使用kvm_cpu_synchronize_put():
+             *   - accel/kvm/kvm-all.c|2992| <<do_kvm_cpu_synchronize_post_reset>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_RESET_STATE, "after reset")) {
+             *   - accel/kvm/kvm-all.c|3026| <<do_kvm_cpu_synchronize_post_init>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_FULL_STATE, "after init")) {
+             *   - accel/kvm/kvm-all.c|3239| <<kvm_cpu_exec>> if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_RUNTIME_STATE, "at runtime")) {
+	     */
             if (!kvm_cpu_synchronize_put(cpu, KVM_PUT_RUNTIME_STATE,
                                          "at runtime")) {
                 ret = -1;
diff --git a/accel/tcg/plugin-gen.c b/accel/tcg/plugin-gen.c
index 1ffcb4b2d..793d5d384 100644
--- a/accel/tcg/plugin-gen.c
+++ b/accel/tcg/plugin-gen.c
@@ -290,6 +290,10 @@ static void inject_mem_cb(struct qemu_plugin_dyn_cb *cb,
     }
 }
 
+/*
+ * 在以下使用plugin_gen_inject():
+ *   - accel/tcg/plugin-gen.c|505| <<plugin_gen_tb_end>> plugin_gen_inject(ptb);
+ */
 static void plugin_gen_inject(struct qemu_plugin_tb *plugin_tb)
 {
     TCGOp *op, *next;
diff --git a/backends/hostmem-ram.c b/backends/hostmem-ram.c
index 062b1abb1..66047bbf2 100644
--- a/backends/hostmem-ram.c
+++ b/backends/hostmem-ram.c
@@ -16,6 +16,36 @@
 #include "qemu/module.h"
 #include "qom/object_interfaces.h"
 
+/*
+ * (gdb) bt
+ * #0  ram_block_add (new_block=0x55555783b8a0, errp=0x7fffffffcf50) at ../system/physmem.c:2169
+ * #1  0x0000555555c1a742 in qemu_ram_alloc_internal (size=32212254720, max_size=32212254720, resized=0x0, host=0x0, ram_flags=0, mr=0x555557708470
+ * #2  0x0000555555c1a87b in qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffd000) at ../system/physmem.c:2578
+ * #3  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #4  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem-ram.c:34
+ * #5  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem.c:345
+ * #6  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../qom/object_interfaces.c:30
+ * #7  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1101
+ * #8  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1698
+ * #9  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #10 0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #11 0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd508) at ../system/vl.c:3850
+ * #12 0x000055555606daca in main (argc=25, argv=0x7fffffffd508) at ../system/main.c:71
+ *
+ *
+ * (gdb) bt
+ * #0  qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffcf30) at ../system/physmem.c:2576
+ * #1  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #2  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem-ram.c:34
+ * #3  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem.c:345
+ * #4  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../qom/object_interfaces.c:30
+ * #5  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1101
+ * #6  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1698
+ * #7  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #8  0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #9  0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd438) at ../system/vl.c:3850
+ * #10 0x000055555606daca in main (argc=25, argv=0x7fffffffd438) at ../system/main.c:71
+ */
 static bool
 ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
diff --git a/backends/hostmem.c b/backends/hostmem.c
index 35734d6f4..855a540a2 100644
--- a/backends/hostmem.c
+++ b/backends/hostmem.c
@@ -56,6 +56,19 @@ host_memory_backend_get_size(Object *obj, Visitor *v, const char *name,
     visit_type_size(v, name, &value, errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  host_memory_backend_set_size (obj=0x555557708400, v=0x55555783b660, name=0x5555561f01b8 "size", opaque=0x0, errp=0x7fffffffd110) at ../backends/hostmem.c:62
+ * #1  0x0000555555f33bde in object_property_set (obj=0x555557708400, name=0x5555561f01b8 "size", v=0x55555783b660, errp=0x7fffffffd110) at ../qom/object.c:1450
+ * #2  0x0000555555f38a94 in object_property_set_qobject (obj=0x555557708400, name=0x5555561f01b8 "size", value=0x5555577cc000, errp=0x7fffffffd110) at ../qom/qom-qobject.c:28
+ * #3  0x0000555555f3410f in object_property_set_int (obj=0x555557708400, name=0x5555561f01b8 "size", value=32212254720, errp=0x7fffffffd110) at ../qom/object.c:1553
+ * #4  0x000055555597420f in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1091
+ * #5  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1698
+ * #6  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #7  0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #8  0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd438) at ../system/vl.c:3850
+ * #9  0x000055555606daca in main (argc=25, argv=0x7fffffffd438) at ../system/main.c:71
+ */
 static void
 host_memory_backend_set_size(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
@@ -329,6 +342,36 @@ size_t host_memory_backend_pagesize(HostMemoryBackend *memdev)
     return pagesize;
 }
 
+/*
+ * (gdb) bt
+ * #0  ram_block_add (new_block=0x55555783b8a0, errp=0x7fffffffcf50) at ../system/physmem.c:2169
+ * #1  0x0000555555c1a742 in qemu_ram_alloc_internal (size=32212254720, max_size=32212254720, resized=0x0, host=0x0, ram_flags=0, mr=0x555557708470
+ * #2  0x0000555555c1a87b in qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffd000) at ../system/physmem.c:2578
+ * #3  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #4  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem-ram.c:34
+ * #5  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem.c:345
+ * #6  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../qom/object_interfaces.c:30
+ * #7  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1101
+ * #8  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1698
+ * #9  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #10 0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #11 0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd508) at ../system/vl.c:3850
+ * #12 0x000055555606daca in main (argc=25, argv=0x7fffffffd508) at ../system/main.c:71
+ *
+ *
+ * (gdb) bt
+ * #0  qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffcf30) at ../system/physmem.c:2576
+ * #1  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #2  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem-ram.c:34
+ * #3  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem.c:345
+ * #4  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../qom/object_interfaces.c:30
+ * #5  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1101
+ * #6  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1698
+ * #7  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #8  0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #9  0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd438) at ../system/vl.c:3850
+ * #10 0x000055555606daca in main (argc=25, argv=0x7fffffffd438) at ../system/main.c:71
+ */
 static void
 host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)
 {
@@ -342,6 +385,9 @@ host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)
     if (!bc->alloc) {
         return;
     }
+    /*
+     * ram_backend_memory_alloc
+     */
     if (!bc->alloc(backend, errp)) {
         return;
     }
diff --git a/contrib/plugins/cache.c b/contrib/plugins/cache.c
index 56508587d..09b89adb1 100644
--- a/contrib/plugins/cache.c
+++ b/contrib/plugins/cache.c
@@ -385,6 +385,10 @@ static bool access_cache(Cache *cache, uint64_t addr)
     return false;
 }
 
+/*
+ * 在以下是他vcpu_mem_access():
+ *   - contrib/plugins/cache.c|493| <<vcpu_tb_trans>> qemu_plugin_register_vcpu_mem_cb(insn, vcpu_mem_access,
+ */
 static void vcpu_mem_access(unsigned int vcpu_index, qemu_plugin_meminfo_t info,
                             uint64_t vaddr, void *userdata)
 {
diff --git a/dump/dump.c b/dump/dump.c
index 15bbcc0c6..634eac320 100644
--- a/dump/dump.c
+++ b/dump/dump.c
@@ -111,6 +111,24 @@ static int dump_cleanup(DumpState *s)
         if (s->detached) {
             bql_lock();
         }
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+         *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|899| <<vm_resume>> vm_start();
+	 */
         vm_start();
         if (s->detached) {
             bql_unlock();
diff --git a/gdbstub/system.c b/gdbstub/system.c
index e2220c1ae..67f83379d 100644
--- a/gdbstub/system.c
+++ b/gdbstub/system.c
@@ -548,6 +548,24 @@ void gdb_continue(void)
 {
     if (!runstate_needs_reset()) {
         trace_gdbstub_op_continue();
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+         *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|899| <<vm_resume>> vm_start();
+	 */
         vm_start();
     }
 }
diff --git a/hw/arm/virt-acpi-build.c b/hw/arm/virt-acpi-build.c
index 200e2a1da..bf999fe87 100644
--- a/hw/arm/virt-acpi-build.c
+++ b/hw/arm/virt-acpi-build.c
@@ -1298,6 +1298,14 @@ static void acpi_ram_update(MemoryRegion *mr, GArray *data)
 {
     uint32_t size = acpi_data_len(data);
 
+    /*
+     * 在以下使用memory_region_ram_resize():
+     *   - hw/arm/virt-acpi-build.c|1303| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/i386/acpi-build.c|2130| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/loongarch/virt-acpi-build.c|645| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/nvram/fw_cfg.c|631| <<fw_cfg_update_mr>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/riscv/virt-acpi-build.c|958| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     */
     /* Make sure RAM size is correct - in case it got changed
      * e.g. by migration */
     memory_region_ram_resize(mr, size, &error_abort);
diff --git a/hw/core/cpu-common.c b/hw/core/cpu-common.c
index 8c306c89e..c91489063 100644
--- a/hw/core/cpu-common.c
+++ b/hw/core/cpu-common.c
@@ -262,6 +262,11 @@ static void cpu_common_realizefn(DeviceState *dev, Error **errp)
     }
 
     if (dev->hotplugged) {
+        /*
+	 * 非s390x在以下使用cpu_synchronize_post_init():
+         *   - hw/core/cpu-common.c|265| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+         *   - system/cpus.c|168| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+	 */
         cpu_synchronize_post_init(cpu);
         cpu_resume(cpu);
     }
diff --git a/hw/core/machine-qmp-cmds.c b/hw/core/machine-qmp-cmds.c
index 28dfd3e15..6d180cfd9 100644
--- a/hw/core/machine-qmp-cmds.c
+++ b/hw/core/machine-qmp-cmds.c
@@ -302,6 +302,13 @@ UuidInfo *qmp_query_uuid(Error **errp)
 
 void qmp_system_reset(Error **errp)
 {
+    /*
+     * 在以下使用SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET:
+     *   - hw/core/machine-qmp-cmds.c|305| <<qmp_system_reset>> qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
+     *   - ui/vnc.c|2544| <<protocol_client_msg>> qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
+     *
+     * 很多对qemu_system_reset_request的调用
+     */
     qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
 }
 
diff --git a/hw/core/machine.c b/hw/core/machine.c
index 27372bb01..9ac71e133 100644
--- a/hw/core/machine.c
+++ b/hw/core/machine.c
@@ -1655,6 +1655,20 @@ static bool is_cpu_type_supported(const MachineState *machine, Error **errp)
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffcf30) at ../system/physmem.c:2576
+ * #1  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #2  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem-ram.c:34
+ * #3  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem.c:345
+ * #4  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../qom/object_interfaces.c:30
+ * #5  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1101
+ * #6  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1698
+ * #7  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #8  0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #9  0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd438) at ../system/vl.c:3850
+ * #10 0x000055555606daca in main (argc=25, argv=0x7fffffffd438) at ../system/main.c:71
+ */
 void machine_run_board_init(MachineState *machine, const char *mem_path, Error **errp)
 {
     ERRP_GUARD();
@@ -1777,8 +1791,19 @@ static void handle_machine_dumpdtb(MachineState *ms)
 #endif
 }
 
+/*
+ * 在以下使用qdev_machine_creation_done():
+ *   - system/vl.c|2784| <<qemu_machine_creation_done>> qdev_machine_creation_done();
+ */
 void qdev_machine_creation_done(void)
 {
+    /*
+     * 在以下使用cpu_synchronize_all_post_init():
+     *   - hw/core/machine.c|1782| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|2203| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3289| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3305| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+     */
     cpu_synchronize_all_post_init();
 
     if (current_machine->boot_config.once) {
@@ -1802,6 +1827,16 @@ void qdev_machine_creation_done(void)
      * to be reset. Note that this will *not* reset any Device objects
      * which are not attached to some part of the qbus tree!
      */
+    /*
+     * 在以下使用qemu_register_resettable():
+     *   - hw/core/machine.c|1805| <<qdev_machine_creation_done>> qemu_register_resettable(OBJECT(sysbus_get_default()));
+     *   - hw/core/reset.c|102| <<qemu_register_reset>> qemu_register_resettable(obj);
+     *   - hw/core/reset.c|113| <<qemu_register_reset_nosnapshotload>> qemu_register_resettable(obj);
+     *   - hw/loongarch/virt.c|1145| <<virt_cpu_plug>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/misc/vmcoreinfo.c|68| <<vmcoreinfo_realize>> qemu_register_resettable(OBJECT(s));
+     *   - hw/virtio/virtio-balloon.c|970| <<virtio_balloon_device_realize>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/virtio/virtio-mem.c|1150| <<virtio_mem_device_realize>> qemu_register_resettable(obj);
+     */
     qemu_register_resettable(OBJECT(sysbus_get_default()));
 
     notifier_list_notify(&machine_init_done_notifiers, NULL);
@@ -1822,6 +1857,14 @@ void qdev_machine_creation_done(void)
        reading from the other reads, because timer polling functions query
        clock values from the log. */
     replay_checkpoint(CHECKPOINT_RESET);
+    /*
+     * 在以下使用qemu_system_reset():
+     *   - hw/core/machine.c|1825| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+     *   - hw/xen/xen-hvm-common.c|614| <<cpu_handle_ioreq>> qemu_system_reset(request);
+     *   - migration/savevm.c|3463| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+     *   - system/runstate.c|982| <<main_loop_should_exit>> qemu_system_reset(request);
+     *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+     */
     qemu_system_reset(SHUTDOWN_CAUSE_NONE);
     register_global_state();
 }
diff --git a/hw/core/reset.c b/hw/core/reset.c
index 65f82fa43..b9d67eff0 100644
--- a/hw/core/reset.c
+++ b/hw/core/reset.c
@@ -99,6 +99,16 @@ void qemu_register_reset(QEMUResetHandler *func, void *opaque)
 
     lr->func = func;
     lr->opaque = opaque;
+    /*
+     * 在以下使用qemu_register_resettable():
+     *   - hw/core/machine.c|1805| <<qdev_machine_creation_done>> qemu_register_resettable(OBJECT(sysbus_get_default()));
+     *   - hw/core/reset.c|102| <<qemu_register_reset>> qemu_register_resettable(obj);
+     *   - hw/core/reset.c|113| <<qemu_register_reset_nosnapshotload>> qemu_register_resettable(obj);
+     *   - hw/loongarch/virt.c|1145| <<virt_cpu_plug>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/misc/vmcoreinfo.c|68| <<vmcoreinfo_realize>> qemu_register_resettable(OBJECT(s));
+     *   - hw/virtio/virtio-balloon.c|970| <<virtio_balloon_device_realize>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/virtio/virtio-mem.c|1150| <<virtio_mem_device_realize>> qemu_register_resettable(obj);
+     */
     qemu_register_resettable(obj);
 }
 
@@ -110,6 +120,16 @@ void qemu_register_reset_nosnapshotload(QEMUResetHandler *func, void *opaque)
     lr->func = func;
     lr->opaque = opaque;
     lr->skip_on_snapshot_load = true;
+    /*
+     * 在以下使用qemu_register_resettable():
+     *   - hw/core/machine.c|1805| <<qdev_machine_creation_done>> qemu_register_resettable(OBJECT(sysbus_get_default()));
+     *   - hw/core/reset.c|102| <<qemu_register_reset>> qemu_register_resettable(obj);
+     *   - hw/core/reset.c|113| <<qemu_register_reset_nosnapshotload>> qemu_register_resettable(obj);
+     *   - hw/loongarch/virt.c|1145| <<virt_cpu_plug>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/misc/vmcoreinfo.c|68| <<vmcoreinfo_realize>> qemu_register_resettable(OBJECT(s));
+     *   - hw/virtio/virtio-balloon.c|970| <<virtio_balloon_device_realize>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/virtio/virtio-mem.c|1150| <<virtio_mem_device_realize>> qemu_register_resettable(obj);
+     */
     qemu_register_resettable(obj);
 }
 
@@ -160,6 +180,16 @@ void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
     }
 }
 
+/*
+ * 在以下使用qemu_register_resettable():
+ *   - hw/core/machine.c|1805| <<qdev_machine_creation_done>> qemu_register_resettable(OBJECT(sysbus_get_default()));
+ *   - hw/core/reset.c|102| <<qemu_register_reset>> qemu_register_resettable(obj);
+ *   - hw/core/reset.c|113| <<qemu_register_reset_nosnapshotload>> qemu_register_resettable(obj);
+ *   - hw/loongarch/virt.c|1145| <<virt_cpu_plug>> qemu_register_resettable(OBJECT(dev));
+ *   - hw/misc/vmcoreinfo.c|68| <<vmcoreinfo_realize>> qemu_register_resettable(OBJECT(s));
+ *   - hw/virtio/virtio-balloon.c|970| <<virtio_balloon_device_realize>> qemu_register_resettable(OBJECT(dev));
+ *   - hw/virtio/virtio-mem.c|1150| <<virtio_mem_device_realize>> qemu_register_resettable(obj);
+ */
 void qemu_register_resettable(Object *obj)
 {
     resettable_container_add(get_root_reset_container(), obj);
diff --git a/hw/core/resettable.c b/hw/core/resettable.c
index 5cdb4a4f8..8c350ba24 100644
--- a/hw/core/resettable.c
+++ b/hw/core/resettable.c
@@ -36,7 +36,30 @@ static void resettable_phase_exit(Object *obj, void *opaque, ResetType type);
  * iothread mutex to ensure only one reset operation is in a progress at a
  * given time.
  */
+/*
+ * 在以下使用enter_phase_in_progress:
+ *   - hw/core/resettable.c|52| <<resettable_assert_reset>> assert(!enter_phase_in_progress);
+ *   - hw/core/resettable.c|54| <<resettable_assert_reset>> enter_phase_in_progress = true;
+ *   - hw/core/resettable.c|56| <<resettable_assert_reset>> enter_phase_in_progress = false;
+ *   - hw/core/resettable.c|72| <<resettable_release_reset>> assert(!enter_phase_in_progress);
+ *   - hw/core/resettable.c|238| <<resettable_change_parent>> assert(!enter_phase_in_progress && !exit_phase_in_progress);
+ */
 static bool enter_phase_in_progress;
+/*
+ * 在以下使用exit_phase_in_progress:
+ *   - hw/core/resettable.c|74| <<resettable_release_reset>> exit_phase_in_progress += 1;
+ *   - hw/core/resettable.c|76| <<resettable_release_reset>> exit_phase_in_progress -= 1;
+ *
+ * 在以下使用ResettableState->exit_phase_in_progress:
+ *   - hw/core/resettable.c|110| <<resettable_phase_enter>> assert(!s->exit_phase_in_progress);
+ *   - hw/core/resettable.c|162| <<resettable_phase_hold>> assert(!s->exit_phase_in_progress);
+ *   - hw/core/resettable.c|192| <<resettable_phase_exit>> assert(!s->exit_phase_in_progress);
+ *   - hw/core/resettable.c|196| <<resettable_phase_exit>> s->exit_phase_in_progress = true;
+ *   - hw/core/resettable.c|206| <<resettable_phase_exit>> s->exit_phase_in_progress = false;
+ *   - hw/core/resettable.c|238| <<resettable_change_parent>> assert(!enter_phase_in_progress && !exit_phase_in_progress);
+
+include/hw/resettable.h|144| <<DECLARE_CLASS_CHECKERS>> bool exit_phase_in_progress;
+ */
 static unsigned exit_phase_in_progress;
 
 void resettable_reset(Object *obj, ResetType type)
@@ -55,6 +78,12 @@ void resettable_assert_reset(Object *obj, ResetType type)
     resettable_phase_enter(obj, NULL, type);
     enter_phase_in_progress = false;
 
+    /*
+     * 在以下使用resettable_phase_hold():
+     *   - hw/core/resettable.c|58| <<resettable_assert_reset>> resettable_phase_hold(obj, NULL, type);
+     *   - hw/core/resettable.c|155| <<resettable_phase_hold>> resettable_child_foreach(rc, obj, resettable_phase_hold, NULL, type);
+     *   - hw/core/resettable.c|236| <<resettable_change_parent>> resettable_phase_hold(obj, NULL, RESET_TYPE_COLD);
+     */
     resettable_phase_hold(obj, NULL, type);
 
     trace_resettable_reset_assert_end(obj);
@@ -140,6 +169,12 @@ static void resettable_phase_enter(Object *obj, void *opaque, ResetType type)
     trace_resettable_phase_enter_end(obj, obj_typename, s->count);
 }
 
+/*
+ * 在以下使用resettable_phase_hold():
+ *   - hw/core/resettable.c|58| <<resettable_assert_reset>> resettable_phase_hold(obj, NULL, type);
+ *   - hw/core/resettable.c|155| <<resettable_phase_hold>> resettable_child_foreach(rc, obj, resettable_phase_hold, NULL, type);
+ *   - hw/core/resettable.c|236| <<resettable_change_parent>> resettable_phase_hold(obj, NULL, RESET_TYPE_COLD);
+ */
 static void resettable_phase_hold(Object *obj, void *opaque, ResetType type)
 {
     ResettableClass *rc = RESETTABLE_GET_CLASS(obj);
@@ -151,6 +186,12 @@ static void resettable_phase_hold(Object *obj, void *opaque, ResetType type)
 
     trace_resettable_phase_hold_begin(obj, obj_typename, s->count, type);
 
+    /*
+     * 在以下使用resettable_phase_hold():
+     *   - hw/core/resettable.c|58| <<resettable_assert_reset>> resettable_phase_hold(obj, NULL, type);
+     *   - hw/core/resettable.c|155| <<resettable_phase_hold>> resettable_child_foreach(rc, obj, resettable_phase_hold, NULL, type);
+     *   - hw/core/resettable.c|236| <<resettable_change_parent>> resettable_phase_hold(obj, NULL, RESET_TYPE_COLD);
+     */
     /* handle children first */
     resettable_child_foreach(rc, obj, resettable_phase_hold, NULL, type);
 
@@ -233,6 +274,12 @@ void resettable_change_parent(Object *obj, Object *newp, Object *oldp)
      * hold phase is not pending.
      */
     if (oldp_count && s->hold_phase_pending) {
+        /*
+	 * 在以下使用resettable_phase_hold():
+	 *   - hw/core/resettable.c|58| <<resettable_assert_reset>> resettable_phase_hold(obj, NULL, type);
+	 *   - hw/core/resettable.c|155| <<resettable_phase_hold>> resettable_child_foreach(rc, obj, resettable_phase_hold, NULL, type);
+	 *   - hw/core/resettable.c|236| <<resettable_change_parent>> resettable_phase_hold(obj, NULL, RESET_TYPE_COLD);
+	 */
         resettable_phase_hold(obj, NULL, RESET_TYPE_COLD);
     }
     /* if oldp is more reset than newp */
@@ -241,6 +288,10 @@ void resettable_change_parent(Object *obj, Object *newp, Object *oldp)
     }
 }
 
+/*
+ * 在以下使用resettable_cold_reset_fn():
+ *   - hw/s390x/ipl.c|284| <<s390_ipl_realize>> qemu_register_reset(resettable_cold_reset_fn, dev);
+ */
 void resettable_cold_reset_fn(void *opaque)
 {
     resettable_reset((Object *) opaque, RESET_TYPE_COLD);
diff --git a/hw/hyperv/hv-balloon-our_range_memslots.c b/hw/hyperv/hv-balloon-our_range_memslots.c
index 1fc95e164..09b443f53 100644
--- a/hw/hyperv/hv-balloon-our_range_memslots.c
+++ b/hw/hyperv/hv-balloon-our_range_memslots.c
@@ -151,6 +151,24 @@ void hvb_our_range_memslots_free(OurRangeMemslots *our_range)
 
     hostmem_mr = memslots->slots[0].alias;
     rb = hostmem_mr->ram_block;
+    /*
+     * 在以下使用ram_block_discard_range():
+     *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+     *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+     *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+     *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+     *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+     *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+     *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+     *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+     *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+     *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+     *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+     *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+     *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+     *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+     *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+     */
     ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
 
     our_range_memslots_free_memslots(our_range);
diff --git a/hw/hyperv/hv-balloon.c b/hw/hyperv/hv-balloon.c
index 2d6d7db4e..a2c5d6700 100644
--- a/hw/hyperv/hv-balloon.c
+++ b/hw/hyperv/hv-balloon.c
@@ -860,6 +860,24 @@ static gboolean hv_balloon_handle_remove_host_addr_node(gpointer key,
                            HV_BALLOON_PAGE_SIZE);
         discard_size = MAX(discard_size, 1);
 
+        /*
+	 * 在以下使用ram_block_discard_range():
+         *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+         *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+         *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+         *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+         *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+         *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+         *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+         *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+         *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+	 */
         if (ram_block_discard_range(rb, rb_offset, discard_size *
                                     HV_BALLOON_PAGE_SIZE) != 0) {
             warn_report("guest reported removed page failed discard");
@@ -1483,6 +1501,13 @@ static void hv_balloon_vmdev_realize(VMBusDevice *vdev, Error **errp)
 
     balloon->state = S_WAIT_RESET;
 
+    /*
+     * 在以下使用qemu_add_balloon_handler():
+     *   - hw/hyperv/hv-balloon.c|1504| <<hv_balloon_vmdev_realize>>
+     *         ret = qemu_add_balloon_handler(hv_balloon_to_target, hv_balloon_stat, balloon);
+     *   - hw/virtio/virtio-balloon.c|1317| <<virtio_balloon_device_realize>>
+     *         ret = qemu_add_balloon_handler(virtio_balloon_to_target, virtio_balloon_stat, s);
+     */
     ret = qemu_add_balloon_handler(hv_balloon_to_target, hv_balloon_stat,
                                    balloon);
     if (ret < 0) {
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 9446a9f86..ec5ae3ff6 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -2126,6 +2126,14 @@ static void acpi_ram_update(MemoryRegion *mr, GArray *data)
 {
     uint32_t size = acpi_data_len(data);
 
+    /*
+     * 在以下使用memory_region_ram_resize():
+     *   - hw/arm/virt-acpi-build.c|1303| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/i386/acpi-build.c|2130| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/loongarch/virt-acpi-build.c|645| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/nvram/fw_cfg.c|631| <<fw_cfg_update_mr>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/riscv/virt-acpi-build.c|958| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     */
     /* Make sure RAM size is correct - in case it got changed e.g. by migration */
     memory_region_ram_resize(mr, size, &error_abort);
 
diff --git a/hw/i386/amd_iommu.c b/hw/i386/amd_iommu.c
index d689a06ec..90a7b20a0 100644
--- a/hw/i386/amd_iommu.c
+++ b/hw/i386/amd_iommu.c
@@ -2573,6 +2573,15 @@ static void amdvi_sysbus_realize(DeviceState *dev, Error **errp)
     memory_region_add_subregion_overlap(&s->mr_sys, AMDVI_INT_ADDR_FIRST,
                                         &s->mr_ir, 1);
 
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     /* Pseudo address space under root PCI bus. */
     x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
 
diff --git a/hw/i386/intel_iommu.c b/hw/i386/intel_iommu.c
index 78b142cce..ff761e97b 100644
--- a/hw/i386/intel_iommu.c
+++ b/hw/i386/intel_iommu.c
@@ -5456,6 +5456,15 @@ static void vtd_realize(DeviceState *dev, Error **errp)
                                                   g_free, vtd_hiod_destroy);
     vtd_init(s);
     pci_setup_iommu(bus, &vtd_iommu_ops, dev);
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     /* Pseudo address space under root PCI bus. */
     x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
 }
diff --git a/hw/i386/isapc.c b/hw/i386/isapc.c
index 1ba9ae22c..1c28951e6 100644
--- a/hw/i386/isapc.c
+++ b/hw/i386/isapc.c
@@ -90,6 +90,13 @@ static void pc_init_isa(MachineState *machine)
     x86_cpus_init(x86ms, pcmc->default_cpu_version);
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用kvmclock_create():
+	 *   - hw/i386/isapc.c|93| <<pc_init_isa>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+	 *   - hw/i386/pc_piix.c|190| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+	 */
         kvmclock_create(pcmc->kvmclock_create_always);
     }
 
diff --git a/hw/i386/kvm/clock.c b/hw/i386/kvm/clock.c
index f56382717..fd89379af 100644
--- a/hw/i386/kvm/clock.c
+++ b/hw/i386/kvm/clock.c
@@ -29,6 +29,53 @@
 #include <linux/kvm.h>
 #include "qom/object.h"
 
+/*
+ * 每一个vCPU的创建.
+ *
+ * kvm_arch_init_vcpu()
+ * -> kvm_arch_set_tsc_khz() -> 如果tsc-frequency设置了, 就更新KVM
+ * -> 如果没有tsc-frequency, 用env->tsc_khz=KVM_GET_TSC_KHZ
+ *
+ * 也就是说, env->tsc_khz要么被tsc-frequency设置,
+ * 要么来自per-vcpu的KVM_GET_TSC_KHZ
+ *
+ *
+ * QEMU创建结束
+ *
+ * qdev_machine_creation_done()
+ * -> cpu_synchronize_all_post_init()
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ *
+ *
+ * 这是hotplug一个vCPU的时候
+ *
+ * cpu_common_realizefn()
+ * -> cpu_synchronize_post_init() 只有hotplug的时候调用
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ *
+ *
+ * 这是迁移的时候在target
+ *
+ * qemu_loadvm_state()
+ * -> cpu_synchronize_all_post_init()
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ */
+
 #define TYPE_KVM_CLOCK "kvmclock"
 OBJECT_DECLARE_SIMPLE_TYPE(KVMClockState, KVM_CLOCK)
 
@@ -38,14 +85,44 @@ struct KVMClockState {
     /*< public >*/
 
     uint64_t clock;
+    /*
+     * 在以下使用KVMClockState->clock_valid:
+     *   - hw/i386/kvm/clock.c|254| <<kvmclock_vm_state_change>> s->clock_valid = false;
+     *   - hw/i386/kvm/clock.c|271| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+     *   - hw/i386/kvm/clock.c|301| <<kvmclock_vm_state_change>> s->clock_valid = true;
+     */
     bool clock_valid;
 
+    /*
+     * 在以下使用KVMClockState->runstate_paused:
+     *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> s->runstate_paused = runstate_check(RUN_STATE_PAUSED);
+     *   - hw/i386/kvm/clock.c|288| <<kvmclock_pre_save>> if (!s->runstate_paused) {
+     *
+     * 注释:
+     * whether the 'clock' value was obtained in the 'paused' state
+     */
     /* whether the 'clock' value was obtained in the 'paused' state */
     bool runstate_paused;
 
+    /*
+     * 在以下使用KVMClockState->mach_use_reliable_get_clock:
+     *   - hw/i386/kvm/clock.c|313| <<global>> mach_use_reliable_get_clock, true),
+     *   - hw/i386/kvm/clock.c|243| <<kvmclock_clock_is_reliable_needed>> return s->mach_use_reliable_get_clock;
+     */
     /* whether machine type supports reliable KVM_GET_CLOCK */
     bool mach_use_reliable_get_clock;
 
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *  - hw/i386/kvm/clock.c|252| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *  - hw/i386/kvm/clock.c|151| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *  - hw/i386/kvm/clock.c|182| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *  - hw/i386/kvm/clock.c|265| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     *
+     * 注释:
+     * whether the 'clock' value was obtained in a host with
+     * reliable KVM_GET_CLOCK
+     */
     /* whether the 'clock' value was obtained in a host with
      * reliable KVM_GET_CLOCK */
     bool clock_is_reliable;
@@ -62,6 +139,12 @@ struct pvclock_vcpu_time_info {
     uint8_t    pad[2];
 } __attribute__((__packed__)); /* 32 bytes */
 
+/*
+ * 在以下使用kvmclock_current_nsec():
+ *   - hw/i386/kvm/clock.c|183| <<kvmclock_vm_state_change>> uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
+ *
+ * 读取vCPU 0的PVTI, 用env->tsc计算时间
+ */
 static uint64_t kvmclock_current_nsec(KVMClockState *s)
 {
     CPUState *cpu = first_cpu;
@@ -74,6 +157,10 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     uint64_t nsec_hi;
     uint64_t nsec;
 
+    /*
+     * 很多调用
+     * 这里等于kvm_arch_get_registers()
+     */
     cpu_synchronize_state(cpu);
 
     if (!(env->system_time_msr & 1ULL)) {
@@ -97,11 +184,84 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     return nsec + time.system_time;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用kvm_update_clock():
+ *   - hw/i386/kvm/clock.c|215| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|234| <<kvmclock_realize>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|289| <<kvmclock_pre_save>> kvm_update_clock(s);
+ *
+ * 通过KVM_GET_CLOCK存到KVMClockState->clock
+ */
 static void kvm_update_clock(KVMClockState *s)
 {
+    /*
+     * struct kvm_clock_data {
+     *     __u64 clock;
+     *     __u32 flags;
+     *     __u32 pad0;
+     *     __u64 realtime;
+     *     __u64 host_tsc;
+     *     __u32 pad[4];
+     * };
+     */
     struct kvm_clock_data data;
     int ret;
 
+    /*
+     * 在两个地方使用KVM_GET_CLOCK:
+     *   - hw/i386/kvm/clock.c|152| <<kvm_update_clock>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     *   - target/i386/kvm/xen-emu.c|990| <<kvm_get_current_ns>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     */
     ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
     if (ret < 0) {
         fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(-ret));
@@ -148,9 +308,125 @@ static void kvm_update_clock(KVMClockState *s)
      *       if !kvm_has_adjust_clock_stable() then
      *               read from memory
      */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *  - hw/i386/kvm/clock.c|252| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *  - hw/i386/kvm/clock.c|151| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *  - hw/i386/kvm/clock.c|182| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *  - hw/i386/kvm/clock.c|265| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     *
+     * 注释:
+     * whether the 'clock' value was obtained in a host with
+     * reliable KVM_GET_CLOCK
+     *
+     * 查看host是否支持KVM_CLOCK_TSC_STABLE
+     * 是host, 不是某个VM
+     */
     s->clock_is_reliable = kvm_has_adjust_clock_stable();
 }
 
+/*
+ * 创建的时候这个调用一次.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ * 这个调用#vCPU次.
+ *
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x5555578c3250, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c3250) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c3250) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c3250) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c3250) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555578cd7d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 迁移到文件的时候.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 从文件迁移到VM.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ * 然后下面调用#vCPU次.
+ *
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x5555578c3250, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c3250) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c3250) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c3250) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c3250) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555578cd7d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 从QEMU quit的时候
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_SHUTDOWN) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_SHUTDOWN) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_SHUTDOWN, send_stop=false) at ../system/cpus.c:300
+ * #3  0x0000555555c08bec in vm_shutdown () at ../system/cpus.c:322
+ * #4  0x0000555555c38ee9 in qemu_cleanup (status=0) at ../system/runstate.c:981
+ * #5  0x00005555560829d2 in qemu_default_main (opaque=0x0) at ../system/main.c:51
+ * #6  0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ */
+/*
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x55555790c330, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x55555790c330) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x55555790c330) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x55555790c330) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x55555790c330) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555579159d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用do_kvmclock_ctrl():
+ *   - hw/i386/kvm/clock.c|199| <<kvmclock_vm_state_change>> run_on_cpu(cpu, do_kvmclock_ctrl, RUN_ON_CPU_NULL);
+ */
 static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
 {
     int ret = kvm_vcpu_ioctl(cpu, KVM_KVMCLOCK_CTRL, 0);
@@ -160,6 +436,109 @@ static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
     }
 }
 
+/*
+ * 启动的时候
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e2f in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d3a in vm_prepare_start (step_pending=false) at ../system/cpus.c:780
+ * #3  0x0000555555c09d75 in vm_start () at ../system/cpus.c:787
+ * #4  0x0000555555c8be6d in qmp_cont (errp=0x7fffffffc750) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c86052 in hmp_cont (mon=0x5555578622a0, qdict=0x555558142820) at ../monitor/hmp-cmds.c:145
+ * #6  0x0000555555c89d89 in handle_hmp_command_exec (mon=0x5555578622a0, cmd=0x55555742d8b0 <hmp_cmds+1680>, qdict=0x555558142820) at ../monitor/hmp.c:1106
+ * #7  0x0000555555c89fd4 in handle_hmp_command (mon=0x5555578622a0, cmdline=0x555557883d74 "") at ../monitor/hmp.c:1158
+ * #8  0x0000555555c87059 in monitor_command_cb (opaque=0x5555578622a0, cmdline=0x555557883d70 "cont", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #9  0x0000555556185448 in readline_handle_byte (rs=0x555557883d70, ch=13) at ../util/readline.c:427
+ * #10 0x0000555555c8ac2b in monitor_read (opaque=0x5555578622a0, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", size=1) at ../monitor/hmp.c:1390
+ * #11 0x0000555556078410 in qemu_chr_be_write_impl (s=0x55555773e300, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:214
+ * #12 0x0000555556078481 in qemu_chr_be_write (s=0x55555773e300, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:226
+ * #13 0x000055555607b483 in fd_chr_read (chan=0x55555783fdc0, cond=G_IO_IN, opaque=0x55555773e300) at ../chardev/char-fd.c:72
+ * #14 0x0000555555f4a47a in qio_channel_fd_source_dispatch (source=0x555558455a20, callback=0x55555607b344 <fd_chr_read>, user_data=0x55555773e300)
+ *     at ../io/channel-watch.c:84
+ * #15 0x00007ffff6fd3854 in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #17 0x0000555556172240 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561722ce in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:310
+ * #19 0x00005555561723fd in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c38d08 in qemu_main_loop () at ../system/runstate.c:905
+ * #21 0x0000555556082abe in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x0000555556082b78 in main (argc=22, argv=0x7fffffffdc68) at ../system/main.c:93
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ *
+ * 迁移的时候在Source上的调用:
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 迁移的时候在Target上的调用:
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ *
+ * 这是迁移在Target上的.
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x5555582b37e0) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用kvmclock_vm_state_change():
+ *   - hw/i386/kvm/clock.c|236| <<kvmclock_realize>> qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
+ */
 static void kvmclock_vm_state_change(void *opaque, bool running,
                                      RunState state)
 {
@@ -171,11 +550,25 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
     if (running) {
         struct kvm_clock_data data = {};
 
+        /*
+	 * 在以下使用KVMClockState->clock_is_reliable:
+         *  - hw/i386/kvm/clock.c|252| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+         *  - hw/i386/kvm/clock.c|151| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+         *  - hw/i386/kvm/clock.c|182| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+         *  - hw/i386/kvm/clock.c|265| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+         *
+         * 注释:
+         * whether the 'clock' value was obtained in a host with
+         * reliable KVM_GET_CLOCK
+	 */
         /*
          * If the host where s->clock was read did not support reliable
          * KVM_GET_CLOCK, read kvmclock value from memory.
          */
         if (!s->clock_is_reliable) {
+            /*
+	     * 读取vCPU 0的PVTI, 用env->tsc计算时间
+	     */
             uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
             /* We can't rely on the saved clock value, just discard it */
             if (pvclock_via_mem) {
@@ -183,6 +576,12 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
             }
         }
 
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|254| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|271| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|301| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         s->clock_valid = false;
 
         data.clock = s->clock;
@@ -200,20 +599,52 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
         }
     } else {
 
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|254| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|271| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|301| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         if (s->clock_valid) {
             return;
         }
 
+        /*
+	 * 在以下使用KVMClockState->runstate_paused:
+         *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> s->runstate_paused = runstate_check(RUN_STATE_PAUSED);
+         *   - hw/i386/kvm/clock.c|288| <<kvmclock_pre_save>> if (!s->runstate_paused) {
+         *
+         * 注释:
+         * whether the 'clock' value was obtained in the 'paused' state
+	 */
         s->runstate_paused = runstate_check(RUN_STATE_PAUSED);
 
+	/*
+	 * 只在这里调用
+	 * 核心是在每个vCPU kvm_get_tsc()
+	 */
         kvm_synchronize_all_tsc();
 
+        /*
+	 * 在以下使用kvm_update_clock():
+         *   - hw/i386/kvm/clock.c|215| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+         *   - hw/i386/kvm/clock.c|234| <<kvmclock_realize>> kvm_update_clock(s);
+         *   - hw/i386/kvm/clock.c|289| <<kvmclock_pre_save>> kvm_update_clock(s);
+         *
+         * 通过KVM_GET_CLOCK存到KVMClockState->clock
+	 */
         kvm_update_clock(s);
         /*
          * If the VM is stopped, declare the clock state valid to
          * avoid re-reading it on next vmsave (which would return
          * a different value). Will be reset when the VM is continued.
          */
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|254| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|271| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|301| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         s->clock_valid = true;
     }
 }
@@ -227,15 +658,32 @@ static void kvmclock_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用kvm_update_clock():
+     *   - hw/i386/kvm/clock.c|215| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+     *   - hw/i386/kvm/clock.c|234| <<kvmclock_realize>> kvm_update_clock(s);
+     *   - hw/i386/kvm/clock.c|289| <<kvmclock_pre_save>> kvm_update_clock(s);
+     *
+     * 通过KVM_GET_CLOCK存到KVMClockState->clock
+     */
     kvm_update_clock(s);
 
     qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
 }
 
+/*
+ * 在以下使用kvmclock_clock_is_reliable_needed():
+ *   - hw/i386/kvm/clock.c|250| <<global>> .needed = kvmclock_clock_is_reliable_needed,
+ */
 static bool kvmclock_clock_is_reliable_needed(void *opaque)
 {
     KVMClockState *s = opaque;
 
+    /*
+     * 在以下使用KVMClockState->mach_use_reliable_get_clock:
+     *   - hw/i386/kvm/clock.c|313| <<global>> mach_use_reliable_get_clock, true),
+     *   - hw/i386/kvm/clock.c|243| <<kvmclock_clock_is_reliable_needed>> return s->mach_use_reliable_get_clock;
+     */
     return s->mach_use_reliable_get_clock;
 }
 
@@ -250,6 +698,42 @@ static const VMStateDescription kvmclock_reliable_get_clock = {
     }
 };
 
+/*
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x55555790d7e0,
+ *     version_id=1, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x555557dad630, se=0x555557902320, vmdesc=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x555557dad630, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:282
+ * #1  0x0000555555f40775 in vmstate_save_state_v (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x55555790d7e0,
+ *     version_id=1, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:407
+ * #2  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:395
+ * #3  0x0000555555c79ef9 in vmstate_save (f=0x555557dad630, se=0x555557902320, vmdesc=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/savevm.c:1052
+ * #4  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x555557dad630, in_postcopy=false) at ../migration/savevm.c:1669
+ * #5  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1712
+ * #6  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 /*
  * When migrating, assume the source has an unreliable
  * KVM_GET_CLOCK unless told otherwise.
@@ -258,6 +742,17 @@ static int kvmclock_pre_load(void *opaque)
 {
     KVMClockState *s = opaque;
 
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *  - hw/i386/kvm/clock.c|252| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *  - hw/i386/kvm/clock.c|151| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *  - hw/i386/kvm/clock.c|182| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *  - hw/i386/kvm/clock.c|265| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     *
+     * 注释:
+     * whether the 'clock' value was obtained in a host with
+     * reliable KVM_GET_CLOCK
+     */
     s->clock_is_reliable = false;
 
     return 0;
@@ -281,7 +776,23 @@ static int kvmclock_pre_save(void *opaque)
 {
     KVMClockState *s = opaque;
 
+    /*
+     * 在以下使用KVMClockState->runstate_paused:
+     *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> s->runstate_paused = runstate_check(RUN_STATE_PAUSED);
+     *   - hw/i386/kvm/clock.c|288| <<kvmclock_pre_save>> if (!s->runstate_paused) {
+     *
+     * 注释:
+     * whether the 'clock' value was obtained in the 'paused' state
+     */
     if (!s->runstate_paused) {
+        /*
+	 * 在以下使用kvm_update_clock():
+         *   - hw/i386/kvm/clock.c|215| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+         *   - hw/i386/kvm/clock.c|234| <<kvmclock_realize>> kvm_update_clock(s);
+         *   - hw/i386/kvm/clock.c|289| <<kvmclock_pre_save>> kvm_update_clock(s);
+         *
+         * 通过KVM_GET_CLOCK存到KVMClockState->clock
+	 */
         kvm_update_clock(s);
     }
 
@@ -325,6 +836,13 @@ static const TypeInfo kvmclock_info = {
     .class_init    = kvmclock_class_init,
 };
 
+/*
+ * 在以下使用kvmclock_create():
+ *   - hw/i386/isapc.c|93| <<pc_init_isa>> kvmclock_create(pcmc->kvmclock_create_always);
+ *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+ *   - hw/i386/pc_piix.c|190| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+ *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+ */
 /* Note: Must be called after VCPU initialization. */
 void kvmclock_create(bool create_always)
 {
diff --git a/hw/i386/microvm.c b/hw/i386/microvm.c
index 94d22a232..fbb4d1748 100644
--- a/hw/i386/microvm.c
+++ b/hw/i386/microvm.c
@@ -182,6 +182,13 @@ static void microvm_devices_init(MicrovmMachineState *mms)
     }
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用kvmclock_create():
+	 *   - hw/i386/isapc.c|93| <<pc_init_isa>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+	 *   - hw/i386/pc_piix.c|190| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+	 */
         kvmclock_create(true);
     }
 
@@ -340,6 +347,15 @@ static void microvm_memory_init(MicrovmMachineState *mms)
     }
 
     x86ms->fw_cfg = fw_cfg;
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     x86ms->ioapic_as = &address_space_memory;
 }
 
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index f8b919cb6..d06b5afb7 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1007,6 +1007,15 @@ void pc_memory_init(PCMachineState *pcms,
     }
     x86ms->fw_cfg = fw_cfg;
 
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     /* Init default IOAPIC address space */
     x86ms->ioapic_as = &address_space_memory;
 
@@ -1702,6 +1711,11 @@ static void pc_machine_initfn(Object *obj)
     }
 }
 
+/*
+ * 在以下使用pc_machine_reset():
+ *   - hw/i386/pc.c|1734| <<pc_machine_wakeup>> pc_machine_reset(machine, RESET_TYPE_WAKEUP);
+ *   - hw/i386/pc.c|1763| <<pc_machine_class_init>> mc->reset = pc_machine_reset;
+ */
 static void pc_machine_reset(MachineState *machine, ResetType type)
 {
     CPUState *cs;
@@ -1719,10 +1733,19 @@ static void pc_machine_reset(MachineState *machine, ResetType type)
     }
 }
 
+/*
+ * 在以下使用pc_machine_wakeup():
+ *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> mc->wakeup = pc_machine_wakeup;
+ */
 static void pc_machine_wakeup(MachineState *machine)
 {
     cpu_synchronize_all_states();
     pc_machine_reset(machine, RESET_TYPE_WAKEUP);
+    /*
+     * 在以下使用cpu_synchronize_all_post_reset():
+     *   - hw/i386/pc.c|1735| <<pc_machine_wakeup>> cpu_synchronize_all_post_reset();
+     *   - system/runstate.c|621| <<qemu_system_reset>> cpu_synchronize_all_post_reset();
+     */
     cpu_synchronize_all_post_reset();
 }
 
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index 7b3611e97..6464e23e7 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -187,6 +187,13 @@ static void pc_init1(MachineState *machine, const char *pci_type)
     x86_cpus_init(x86ms, pcmc->default_cpu_version);
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用kvmclock_create():
+	 *   - hw/i386/isapc.c|93| <<pc_init_isa>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+	 *   - hw/i386/pc_piix.c|190| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+	 */
         kvmclock_create(pcmc->kvmclock_create_always);
     }
 
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index 6015e639d..cabd749de 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -194,6 +194,13 @@ static void pc_q35_init(MachineState *machine)
     x86_cpus_init(x86ms, pcmc->default_cpu_version);
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用kvmclock_create():
+	 *   - hw/i386/isapc.c|93| <<pc_init_isa>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+	 *   - hw/i386/pc_piix.c|190| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+	 */
         kvmclock_create(pcmc->kvmclock_create_always);
     }
 
diff --git a/hw/intc/ioapic.c b/hw/intc/ioapic.c
index 38e438464..2975e21a0 100644
--- a/hw/intc/ioapic.c
+++ b/hw/intc/ioapic.c
@@ -96,6 +96,15 @@ static void ioapic_entry_parse(uint64_t entry, struct ioapic_entry_info *info)
 
 static void ioapic_service(IOAPICCommonState *s)
 {
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
     struct ioapic_entry_info info;
     uint8_t i;
@@ -137,6 +146,15 @@ static void ioapic_service(IOAPICCommonState *s)
                 }
 #endif
 
+                /*
+		 * 在以下使用X86MachineState->ioapic_as:
+                 *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+                 *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+                 *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+                 *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+                 *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+                 *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+		 */
                 /* No matter whether IR is enabled, we translate
                  * the IOAPIC message into a MSI one, and its
                  * address space will decide whether we need a
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index b1eba348e..4513c035b 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -55,6 +55,53 @@
 #include "hw/xen/xen.h"
 #include "hw/i386/kvm/xen_evtchn.h"
 
+/*
+ * main_system_bus
+ * ----------------------------------
+ *        |
+ *        |
+ *   i440FX-pcihost
+ *        |
+ *        |
+ *  pci.0 |
+ * -------------------------------------------------
+ *         |                |                    |
+ *         |                |                    |
+ *  vhost-scsi-pci   virtio-balloon-pci   virtio-crypto-pci
+ *                          |
+ *                          |
+ *       per-device virtio-bus |
+ *         -----------------------------------
+ *                   virtio-balloon-device
+ *
+ *
+ *
+ *                              main_system_bus
+ * --------------------------------------------------------------
+ *                                     |
+ *                              i440FX-pci-host
+ *                                     |
+ *                                     |
+ *                            pci.0    |
+ * ----------------------------------------------------------------------------
+ *   |            |              |                 |                     |
+ *   |            |              |                 |                     |
+ * i440FX        PIIX3         e1000            piix3-ide             PIIX4_PM
+ *                |
+ *                |
+ *         isa.0  |
+ *     -------------------------------------------------
+ *         |            |           |              |
+ *         |            |           |              |
+ *     kvm-i8259    kvm-i8259    isa-fdc        kvm-pit
+ *                                  |
+ *                                  |
+ *                    floppy-bus.0  |
+ *                          -------------------
+ *                                  |
+ *                               floppy
+ */
+
 bool pci_available = true;
 
 static char *pcibus_get_dev_path(DeviceState *dev);
diff --git a/hw/vfio/migration.c b/hw/vfio/migration.c
index 4c06e3db9..a26ff986c 100644
--- a/hw/vfio/migration.c
+++ b/hw/vfio/migration.c
@@ -89,6 +89,10 @@ mig_state_to_qapi_state(enum vfio_device_mig_state state)
     }
 }
 
+/*
+ * 在以下使用vfio_migration_send_event():
+ *   - hw/vfio/migration.c|121| <<vfio_migration_set_device_state>> vfio_migration_send_event(vbasedev);
+ */
 static void vfio_migration_send_event(VFIODevice *vbasedev)
 {
     VFIOMigration *migration = vbasedev->migration;
@@ -109,6 +113,12 @@ static void vfio_migration_send_event(VFIODevice *vbasedev)
         dev->id, qom_path, mig_state_to_qapi_state(migration->device_state));
 }
 
+/*
+ * 在以下使用vfio_migration_set_device_state():
+ *   - hw/vfio/migration.c|182| <<vfio_migration_set_state>> vfio_migration_set_device_state(vbasedev, recover_state);
+ *   - hw/vfio/migration.c|187| <<vfio_migration_set_state>> vfio_migration_set_device_state(vbasedev, new_state);
+ *   - hw/vfio/migration.c|211| <<vfio_migration_set_state>> vfio_migration_set_device_state(vbasedev, VFIO_DEVICE_STATE_RUNNING);
+ */
 static void vfio_migration_set_device_state(VFIODevice *vbasedev,
                                             enum vfio_device_mig_state state)
 {
@@ -118,9 +128,20 @@ static void vfio_migration_set_device_state(VFIODevice *vbasedev,
                                           mig_state_to_str(state));
 
     migration->device_state = state;
+    /*
+     * 只在这里调用
+     */
     vfio_migration_send_event(vbasedev);
 }
 
+/*
+ * 在以下使用vfio_migration_set_state():
+ *   - hw/vfio/migration-multifd.c|708| <<vfio_multifd_save_complete_precopy_thread>> if (vfio_migration_set_state(vbasedev, VFIO_DEVICE_STATE_STOP_COPY,
+ *   - hw/vfio/migration.c|226| <<vfio_migration_set_state_or_reset>> return vfio_migration_set_state(vbasedev, new_state,
+ *   - hw/vfio/migration.c|478| <<vfio_save_setup>> ret = vfio_migration_set_state(vbasedev, VFIO_DEVICE_STATE_PRE_COPY,
+ *   - hw/vfio/migration.c|649| <<vfio_save_complete_precopy>> ret = vfio_migration_set_state(vbasedev, VFIO_DEVICE_STATE_STOP_COPY,
+ *   - hw/vfio/migration.c|705| <<vfio_load_setup>> ret = vfio_migration_set_state(vbasedev, VFIO_DEVICE_STATE_RESUMING,
+ */
 int vfio_migration_set_state(VFIODevice *vbasedev,
                              enum vfio_device_mig_state new_state,
                              enum vfio_device_mig_state recover_state,
@@ -343,11 +364,25 @@ static int vfio_query_precopy_size(VFIOMigration *migration)
     return 0;
 }
 
+/*
+ * 在以下使用vfio_save_block():
+ *   - hw/vfio/migration.c|613| <<vfio_save_iterate>> data_size = vfio_save_block(f, migration);
+ *   - hw/vfio/migration.c|657| <<vfio_save_complete_precopy>> data_size = vfio_save_block(f, vbasedev->migration);
+ */
 /* Returns the size of saved data on success and -errno on error */
 static ssize_t vfio_save_block(QEMUFile *f, VFIOMigration *migration)
 {
     ssize_t data_size;
 
+    /*
+     * 在以下使用VFIOMigration->data_buffer:
+     *   - hw/vfio/migration.c|351| <<vfio_save_block>> data_size = read(migration->data_fd, migration->data_buffer,
+     *   - hw/vfio/migration.c|377| <<vfio_save_block>> qemu_put_buffer(f, migration->data_buffer, data_size);
+     *   - hw/vfio/migration.c|465| <<vfio_save_setup>> migration->data_buffer = g_try_malloc0(migration->data_buffer_size);
+     *   - hw/vfio/migration.c|466| <<vfio_save_setup>> if (!migration->data_buffer) {
+     *   - hw/vfio/migration.c|532| <<vfio_save_cleanup>> g_free(migration->data_buffer);
+     *   - hw/vfio/migration.c|533| <<vfio_save_cleanup>> migration->data_buffer = NULL;
+     */
     data_size = read(migration->data_fd, migration->data_buffer,
                      migration->data_buffer_size);
     if (data_size < 0) {
@@ -462,6 +497,15 @@ static int vfio_save_setup(QEMUFile *f, void *opaque, Error **errp)
     vfio_query_stop_copy_size(vbasedev, &stop_copy_size);
     migration->data_buffer_size = MIN(VFIO_MIG_DEFAULT_DATA_BUFFER_SIZE,
                                       stop_copy_size);
+    /*
+     * 在以下使用VFIOMigration->data_buffer:
+     *   - hw/vfio/migration.c|351| <<vfio_save_block>> data_size = read(migration->data_fd, migration->data_buffer,
+     *   - hw/vfio/migration.c|377| <<vfio_save_block>> qemu_put_buffer(f, migration->data_buffer, data_size);
+     *   - hw/vfio/migration.c|465| <<vfio_save_setup>> migration->data_buffer = g_try_malloc0(migration->data_buffer_size);
+     *   - hw/vfio/migration.c|466| <<vfio_save_setup>> if (!migration->data_buffer) {
+     *   - hw/vfio/migration.c|532| <<vfio_save_cleanup>> g_free(migration->data_buffer);
+     *   - hw/vfio/migration.c|533| <<vfio_save_cleanup>> migration->data_buffer = NULL;
+     */
     migration->data_buffer = g_try_malloc0(migration->data_buffer_size);
     if (!migration->data_buffer) {
         error_setg(errp, "%s: Failed to allocate migration data buffer",
@@ -529,6 +573,15 @@ static void vfio_save_cleanup(void *opaque)
         }
     }
 
+    /*
+     * 在以下使用VFIOMigration->data_buffer:
+     *   - hw/vfio/migration.c|351| <<vfio_save_block>> data_size = read(migration->data_fd, migration->data_buffer,
+     *   - hw/vfio/migration.c|377| <<vfio_save_block>> qemu_put_buffer(f, migration->data_buffer, data_size);
+     *   - hw/vfio/migration.c|465| <<vfio_save_setup>> migration->data_buffer = g_try_malloc0(migration->data_buffer_size);
+     *   - hw/vfio/migration.c|466| <<vfio_save_setup>> if (!migration->data_buffer) {
+     *   - hw/vfio/migration.c|532| <<vfio_save_cleanup>> g_free(migration->data_buffer);
+     *   - hw/vfio/migration.c|533| <<vfio_save_cleanup>> migration->data_buffer = NULL;
+     */
     g_free(migration->data_buffer);
     migration->data_buffer = NULL;
     migration->precopy_init_size = 0;
@@ -599,6 +652,16 @@ static bool vfio_is_active_iterate(void *opaque)
  * in the worst case it will exceed by 1MB). However, if the buffer size is
  * later changed to a bigger value, migration rate should be enforced here.
  */
+/*
+ * 在以下使用SaveVMHandlers->save_live_iterate:
+ *   - hw/ppc/spapr.c|2572| <<global>> .save_live_iterate = htab_save_iterate,
+ *   - hw/s390x/s390-stattrib.c|340| <<global>> .save_live_iterate = cmma_save_iterate,
+ *   - hw/vfio/migration.c|834| <<global>> .save_live_iterate = vfio_save_iterate,
+ *   - migration/block-dirty-bitmap.c|1255| <<global>> .save_live_iterate = dirty_bitmap_save_iterate,
+ *   - migration/ram.c|4695| <<global>> .save_live_iterate = ram_save_iterate,
+ *   - migration/savevm.c|1448| <<qemu_savevm_state_iterate>> if (!se->ops || !se->ops->save_live_iterate) {
+ *   - migration/savevm.c|1476| <<qemu_savevm_state_iterate>> ret = se->ops->save_live_iterate(f, se->opaque);
+ */
 static int vfio_save_iterate(QEMUFile *f, void *opaque)
 {
     VFIODevice *vbasedev = opaque;
@@ -1126,6 +1189,12 @@ void vfio_migration_reset_bytes_transferred(void)
     qatomic_set(&bytes_transferred, 0);
 }
 
+/*
+ * 在以下使用vfio_migration_add_bytes_transferred():
+ *   - hw/vfio/migration-multifd.c|674| <<vfio_save_complete_precopy_thread_config_state>> vfio_migration_add_bytes_transferred(packet_len);
+ *   - hw/vfio/migration-multifd.c|744| <<vfio_multifd_save_complete_precopy_thread>> vfio_migration_add_bytes_transferred(packet_size);
+ *   - hw/vfio/migration.c|378| <<vfio_save_block>> vfio_migration_add_bytes_transferred(data_size);
+ */
 void vfio_migration_add_bytes_transferred(unsigned long val)
 {
     qatomic_add(&bytes_transferred, val);
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index b46b1305a..119853164 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -2817,6 +2817,16 @@ static const VMStateDescription vmstate_vfio_pci_config = {
     }
 };
 
+/*
+ * 2894 static VFIODeviceOps vfio_pci_ops = {
+ * 2895     .vfio_compute_needs_reset = vfio_pci_compute_needs_reset,
+ * 2896     .vfio_hot_reset_multi = vfio_pci_hot_reset_multi,
+ * 2897     .vfio_eoi = vfio_pci_intx_eoi,
+ * 2898     .vfio_get_object = vfio_pci_get_object,
+ * 2899     .vfio_save_config = vfio_pci_save_config,
+ * 2900     .vfio_load_config = vfio_pci_load_config,
+ * 2901 };
+ */
 static int vfio_pci_save_config(VFIODevice *vbasedev, QEMUFile *f, Error **errp)
 {
     VFIOPCIDevice *vdev = container_of(vbasedev, VFIOPCIDevice, vbasedev);
@@ -2891,6 +2901,10 @@ void vfio_sub_page_bar_update_mappings(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * 在以下使用vfio_pci_ops:
+ *   - hw/vfio/pci.c|3645| <<vfio_pci_init>> vfio_device_init(vbasedev, VFIO_DEVICE_TYPE_PCI, &vfio_pci_ops,
+ */
 static VFIODeviceOps vfio_pci_ops = {
     .vfio_compute_needs_reset = vfio_pci_compute_needs_reset,
     .vfio_hot_reset_multi = vfio_pci_hot_reset_multi,
diff --git a/hw/vfio/vfio-migration-internal.h b/hw/vfio/vfio-migration-internal.h
index 814fbd9eb..708ea059d 100644
--- a/hw/vfio/vfio-migration-internal.h
+++ b/hw/vfio/vfio-migration-internal.h
@@ -42,6 +42,15 @@ typedef struct VFIOMigration {
     NotifierWithReturn migration_state;
     uint32_t device_state;
     int data_fd;
+    /*
+     * 在以下使用VFIOMigration->data_buffer:
+     *   - hw/vfio/migration.c|351| <<vfio_save_block>> data_size = read(migration->data_fd, migration->data_buffer,
+     *   - hw/vfio/migration.c|377| <<vfio_save_block>> qemu_put_buffer(f, migration->data_buffer, data_size);
+     *   - hw/vfio/migration.c|465| <<vfio_save_setup>> migration->data_buffer = g_try_malloc0(migration->data_buffer_size); 
+     *   - hw/vfio/migration.c|466| <<vfio_save_setup>> if (!migration->data_buffer) { 
+     *   - hw/vfio/migration.c|532| <<vfio_save_cleanup>> g_free(migration->data_buffer);
+     *   - hw/vfio/migration.c|533| <<vfio_save_cleanup>> migration->data_buffer = NULL;
+     */
     void *data_buffer;
     size_t data_buffer_size;
     uint64_t mig_flags;
diff --git a/hw/virtio/virtio-balloon-pci.c b/hw/virtio/virtio-balloon-pci.c
index 96e88b6b8..de8df8195 100644
--- a/hw/virtio/virtio-balloon-pci.c
+++ b/hw/virtio/virtio-balloon-pci.c
@@ -21,6 +21,53 @@
 #include "qemu/module.h"
 #include "qom/object.h"
 
+/*
+ * main_system_bus
+ * ----------------------------------
+ *        |
+ *        |
+ *   i440FX-pcihost
+ *        |
+ *        |
+ *  pci.0 |
+ * -------------------------------------------------
+ *         |                |                    |
+ *         |                |                    |
+ *  vhost-scsi-pci   virtio-balloon-pci   virtio-crypto-pci
+ *                          |
+ *                          |
+ *       per-device virtio-bus |
+ *         -----------------------------------
+ *                   virtio-balloon-device
+ * 
+ *
+ *
+ *                              main_system_bus
+ * --------------------------------------------------------------
+ *                                     |
+ *                              i440FX-pci-host
+ *                                     |
+ *                                     |
+ *                            pci.0    |
+ * ----------------------------------------------------------------------------
+ *   |            |              |                 |                     |
+ *   |            |              |                 |                     |
+ * i440FX        PIIX3         e1000            piix3-ide             PIIX4_PM
+ *                |
+ *                |
+ *         isa.0  |
+ *     -------------------------------------------------
+ *         |            |           |              |
+ *         |            |           |              |
+ *     kvm-i8259    kvm-i8259    isa-fdc        kvm-pit
+ *                                  |
+ *                                  |
+ *                    floppy-bus.0  |
+ *                          -------------------
+ *                                  |
+ *                               floppy
+ */
+
 typedef struct VirtIOBalloonPCI VirtIOBalloonPCI;
 
 /*
@@ -52,6 +99,10 @@ static void virtio_balloon_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
     }
 
     vpci_dev->class_code = PCI_CLASS_OTHERS;
+    /*
+     * VirtIOPCIProxy *vpci_dev:
+     * -> VirtioBusState bus;
+     */
     qdev_realize(vdev, BUS(&vpci_dev->bus), errp);
 }
 
diff --git a/hw/virtio/virtio-balloon.c b/hw/virtio/virtio-balloon.c
index 02cdd807d..07bbf244d 100644
--- a/hw/virtio/virtio-balloon.c
+++ b/hw/virtio/virtio-balloon.c
@@ -36,6 +36,52 @@
 #include "hw/virtio/virtio-bus.h"
 #include "hw/virtio/virtio-access.h"
 
+/*
+ * 1. "guest-stats"只在"guest-stats-polling-interval"(VirtIOBallon->stats_poll_interval)不为0的时候使用.
+ *
+ * 2. "free-page-hint"主要给live migration dirty track用的.
+ * live migration的时候QEMU通知virtio-balloon的callback.
+ *
+ * 3. iothread在"free-page-hint"的时候用, 必须用.
+ *
+ * 4. PartiallyBalloonedPage帮助在inflation的时候对于host page是hugepage的,
+ * 必须完全凑够一个huage page才行. 凑不够就不inflate.
+ *
+ * 5. Inflation有两种情况.
+ * 对于普通的page使用madvise(QEMU_MADV_REMOVE或者QEMU_MADV_DONTNEED).
+ * 对于fd的page使用fallocate(FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE).
+ *
+ * 6. Deflation使用madvise(QEMU_MADV_WILLNEED).
+ *
+ * 7. Free page reporting根据情况时候madvise或者fallocate.
+ */
+
+/*
+ * 根据测试, 没有internal, last-update就不变
+ * (qemu) qom-get /machine/peripheral/balloon0 guest-stats
+ * {
+ *     "stats": {
+ *         "stat-htlb-pgalloc": 0,
+ *         "stat-swap-out": 0,
+ *         "stat-alloc-stalls": 18446744073709551615,
+ *         "stat-available-memory": 7551688704,
+ *         "stat-direct-reclaims": 18446744073709551615,
+ *         "stat-direct-scans": 18446744073709551615,
+ *         "stat-htlb-pgfail": 0,
+ *         "stat-free-memory": 7607328768,
+ *         "stat-minor-faults": 325065,
+ *         "stat-major-faults": 636,
+ *         "stat-total-memory": 8025051136,
+ *         "stat-oom-kills": 18446744073709551615,
+ *         "stat-async-reclaims": 18446744073709551615,
+ *         "stat-swap-in": 0,
+ *         "stat-async-scans": 18446744073709551615,
+ *         "stat-disk-caches": 155353088
+ *     },
+ *     "last-update": 1770071149
+ * }
+ */
+
 #define BALLOON_PAGE_SIZE  (1 << VIRTIO_BALLOON_PFN_SHIFT)
 
 typedef struct PartiallyBalloonedPage {
@@ -43,6 +89,12 @@ typedef struct PartiallyBalloonedPage {
     unsigned long *bitmap;
 } PartiallyBalloonedPage;
 
+/*
+ * 在以下使用virtio_balloon_pbp_free():
+ *   - hw/virtio/virtio-balloon.c|183| <<balloon_inflate_page>> virtio_balloon_pbp_free(pbp);
+ *   - hw/virtio/virtio-balloon.c|222| <<balloon_inflate_page>> virtio_balloon_pbp_free(pbp);
+ *   - hw/virtio/virtio-balloon.c|770| <<virtio_balloon_handle_output>> virtio_balloon_pbp_free(&pbp);
+ */
 static void virtio_balloon_pbp_free(PartiallyBalloonedPage *pbp)
 {
     if (!pbp->bitmap) {
@@ -52,6 +104,10 @@ static void virtio_balloon_pbp_free(PartiallyBalloonedPage *pbp)
     pbp->bitmap = NULL;
 }
 
+/*
+ * 在以下使用virtio_balloon_pbp_alloc():
+ *   - hw/virtio/virtio-balloon.c|126| <<balloon_inflate_page>> virtio_balloon_pbp_alloc(pbp, base_gpa, subpages);
+ */
 static void virtio_balloon_pbp_alloc(PartiallyBalloonedPage *pbp,
                                      ram_addr_t base_gpa,
                                      long subpages)
@@ -60,12 +116,21 @@ static void virtio_balloon_pbp_alloc(PartiallyBalloonedPage *pbp,
     pbp->bitmap = bitmap_new(subpages);
 }
 
+/*
+ * 在以下使用virtio_balloon_pbp_matches():
+ *   - return pbp->base_gpa == base_gpa;
+ */
 static bool virtio_balloon_pbp_matches(PartiallyBalloonedPage *pbp,
                                        ram_addr_t base_gpa)
 {
     return pbp->base_gpa == base_gpa;
 }
 
+/*
+ * 在以下使用virtio_balloon_inhibited():
+ *   - hw/virtio/virtio-balloon.c|623| <<virtio_balloon_handle_report>> if (virtio_balloon_inhibited() || dev->poison_val) {
+ *   - hw/virtio/virtio-balloon.c|746| <<virtio_balloon_handle_output>> if (!virtio_balloon_inhibited()) {
+ */
 static bool virtio_balloon_inhibited(void)
 {
     /*
@@ -76,6 +141,18 @@ static bool virtio_balloon_inhibited(void)
             migration_in_bg_snapshot();
 }
 
+/*
+ * #define BALLOON_PAGE_SIZE  (1 << VIRTIO_BALLOON_PFN_SHIFT)
+ *
+ * typedef struct PartiallyBalloonedPage {
+ *     ram_addr_t base_gpa;
+ *     unsigned long *bitmap;
+ * } PartiallyBalloonedPage;
+ *
+ *
+ * 在以下使用balloon_inflate_page():
+ *   - hw/virtio/virtio-balloon.c|448| <<virtio_balloon_handle_output>> balloon_inflate_page(s, section.mr,
+ */
 static void balloon_inflate_page(VirtIOBalloon *balloon,
                                  MemoryRegion *mr, hwaddr mr_offset,
                                  PartiallyBalloonedPage *pbp)
@@ -91,9 +168,30 @@ static void balloon_inflate_page(VirtIOBalloon *balloon,
     rb = qemu_ram_block_from_host(addr, false, &rb_offset);
     rb_page_size = qemu_ram_pagesize(rb);
 
+    /*
+     * rb_page_size应该是host的fd内存的page size
+     */
     if (rb_page_size == BALLOON_PAGE_SIZE) {
         /* Easy case */
 
+        /*
+	 * 在以下使用ram_block_discard_range():
+         *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+         *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+         *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+         *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+         *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+         *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+         *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+         *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+         *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+	 */
         ram_block_discard_range(rb, rb_offset, rb_page_size);
         /* We ignore errors from ram_block_discard_range(), because it
          * has already reported them, and failing to discard a balloon
@@ -123,6 +221,9 @@ static void balloon_inflate_page(VirtIOBalloon *balloon,
     }
 
     if (!pbp->bitmap) {
+        /*
+	 * 只在这里调用virtio_balloon_pbp_alloc()
+	 */
         virtio_balloon_pbp_alloc(pbp, base_gpa, subpages);
     }
 
@@ -133,6 +234,24 @@ static void balloon_inflate_page(VirtIOBalloon *balloon,
         /* We've accumulated a full host page, we can actually discard
          * it now */
 
+        /*
+	 * 在以下使用ram_block_discard_range():
+         *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+         *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+         *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+         *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+         *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+         *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+         *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+         *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+         *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+	 */
         ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
         /* We ignore errors from ram_block_discard_range(), because it
          * has already reported them, and failing to discard a balloon
@@ -141,6 +260,10 @@ static void balloon_inflate_page(VirtIOBalloon *balloon,
     }
 }
 
+/*
+ * 在以下使用balloon_deflate_page():
+ *   - hw/virtio/virtio-balloon.c|751| <<virtio_balloon_handle_output>> balloon_deflate_page(s, section.mr, section.offset_within_region);
+ */
 static void balloon_deflate_page(VirtIOBalloon *balloon,
                                  MemoryRegion *mr, hwaddr mr_offset)
 {
@@ -204,6 +327,12 @@ G_STATIC_ASSERT(G_N_ELEMENTS(balloon_stat_names) == VIRTIO_BALLOON_S_NR);
  * stale values stick around in case the guest reports a subset of the supported
  * statistics.
  */
+/*
+ * 在以下使用reset_stats():
+ *   - hw/virtio/virtio-balloon.c|596| <<virtio_balloon_receive_stats>> reset_stats(s);
+ *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_device_realize>> reset_stats(s);
+ *   - hw/virtio/virtio-balloon.c|1465| <<virtio_balloon_reset_enter>> reset_stats(s);
+ */
 static inline void reset_stats(VirtIOBalloon *dev)
 {
     int i;
@@ -216,42 +345,173 @@ static bool balloon_stats_supported(const VirtIOBalloon *s)
     return virtio_vdev_has_feature(vdev, VIRTIO_BALLOON_F_STATS_VQ);
 }
 
+/*
+ * 在以下使用balloon_stats_enabled():
+ *   - hw/virtio/virtio-balloon.c|326| <<balloon_stats_destroy_timer>> if (balloon_stats_enabled(s)) {
+ *   - hw/virtio/virtio-balloon.c|574| <<balloon_stats_set_poll_interval>> if (balloon_stats_enabled(s)) {
+ *   - hw/virtio/virtio-balloon.c|857| <<virtio_balloon_receive_stats>> if (balloon_stats_enabled(s)) {
+ *   - hw/virtio/virtio-balloon.c|1600| <<virtio_balloon_post_load_device>> if (balloon_stats_enabled(s)) {
+ */
 static bool balloon_stats_enabled(const VirtIOBalloon *s)
 {
+    /*
+     * 在以下使用VirtIOBalloon->stats_poll_interval:
+     *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+     *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+     *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+     *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+     *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     */
     return s->stats_poll_interval > 0;
 }
 
+/*
+ * 在以下使用balloon_stats_destroy_timer():
+ *   - hw/virtio/virtio-balloon.c|570| <<balloon_stats_set_poll_interval>> balloon_stats_destroy_timer(s);
+ *   - hw/virtio/virtio-balloon.c|1785| <<virtio_balloon_device_unrealize>> balloon_stats_destroy_timer(s);
+ */
 static void balloon_stats_destroy_timer(VirtIOBalloon *s)
 {
     if (balloon_stats_enabled(s)) {
+        /*
+	 * 在以下使用VirtIOBalloon->stats_timer:
+         *   - hw/virtio/virtio-balloon.c|292| <<balloon_stats_destroy_timer>> timer_free(s->stats_timer);
+         *   - hw/virtio/virtio-balloon.c|293| <<balloon_stats_destroy_timer>> s->stats_timer = NULL;
+         *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_change_timer>> timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000);
+         *   - hw/virtio/virtio-balloon.c|471| <<balloon_stats_set_poll_interval>> g_assert(s->stats_timer == NULL);
+         *   - hw/virtio/virtio-balloon.c|472| <<balloon_stats_set_poll_interval>> s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
+	 */
         timer_free(s->stats_timer);
         s->stats_timer = NULL;
+        /*
+	 * 在以下使用VirtIOBalloon->stats_poll_interval:
+         *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+         *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+         *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+         *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+         *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+	 */
         s->stats_poll_interval = 0;
     }
 }
 
+/*
+ * 在以下使用balloon_stats_change_timer():
+ *   - hw/virtio/virtio-balloon.c|334| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+ *   - hw/virtio/virtio-balloon.c|466| <<balloon_stats_set_poll_interval>> balloon_stats_change_timer(s, value);
+ *   - hw/virtio/virtio-balloon.c|474| <<balloon_stats_set_poll_interval>> balloon_stats_change_timer(s, 0);
+ *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+ *   - hw/virtio/virtio-balloon.c|1348| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+ */
 static void balloon_stats_change_timer(VirtIOBalloon *s, int64_t secs)
 {
+    /*
+     * 在以下使用VirtIOBalloon->stats_timer:
+     *   - hw/virtio/virtio-balloon.c|292| <<balloon_stats_destroy_timer>> timer_free(s->stats_timer);
+     *   - hw/virtio/virtio-balloon.c|293| <<balloon_stats_destroy_timer>> s->stats_timer = NULL;
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_change_timer>> timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000);
+     *   - hw/virtio/virtio-balloon.c|471| <<balloon_stats_set_poll_interval>> g_assert(s->stats_timer == NULL);
+     *   - hw/virtio/virtio-balloon.c|472| <<balloon_stats_set_poll_interval>> s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
+     */
     timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000);
 }
 
+/*
+ * 在以下使用balloon_stats_poll_cb():
+ *   - hw/virtio/virtio-balloon.c|504| <<balloon_stats_set_poll_interval>> s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
+ */
 static void balloon_stats_poll_cb(void *opaque)
 {
     VirtIOBalloon *s = opaque;
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
 
     if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+        /*
+	 * 在以下使用VirtIOBalloon->stats_poll_interval:
+         *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+         *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+         *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+         *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+         *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+	 */
         /* re-schedule */
         balloon_stats_change_timer(s, s->stats_poll_interval);
         return;
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_vq_elem:
+     *   - hw/virtio/virtio-balloon.c|344| <<balloon_stats_poll_cb>> if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|364| <<balloon_stats_poll_cb>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|365| <<balloon_stats_poll_cb>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|695| <<virtio_balloon_receive_stats>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|699| <<virtio_balloon_receive_stats>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|702| <<virtio_balloon_receive_stats>> s->stats_vq_elem = elem;
+     *   - hw/virtio/virtio-balloon.c|1582| <<virtio_balloon_device_reset>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|1583| <<virtio_balloon_device_reset>> virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|1584| <<virtio_balloon_device_reset>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|1585| <<virtio_balloon_device_reset>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|1595| <<virtio_balloon_set_status>> if (!s->stats_vq_elem && vdev->vm_running &&
+     *
+     * virtio-balloon使用virtqueue_push()的地方:
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|594| <<virtio_balloon_handle_report>> virtqueue_push(vq, elem, 0);
+     *   - hw/virtio/virtio-balloon.c|664| <<virtio_balloon_handle_output>> virtqueue_push(vq, elem, 0);
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|872| <<get_free_page_hints>> virtqueue_push(vq, elem, 0);
+     */
     virtqueue_push(s->svq, s->stats_vq_elem, 0);
     virtio_notify(vdev, s->svq);
     g_free(s->stats_vq_elem);
     s->stats_vq_elem = NULL;
 }
 
+/*
+ * 根据测试, 没有internal, last-update就不变
+ * (qemu) qom-get /machine/peripheral/balloon0 guest-stats
+ * {
+ *     "stats": {
+ *         "stat-htlb-pgalloc": 0,
+ *         "stat-swap-out": 0,
+ *         "stat-alloc-stalls": 18446744073709551615,
+ *         "stat-available-memory": 7551688704,
+ *         "stat-direct-reclaims": 18446744073709551615,
+ *         "stat-direct-scans": 18446744073709551615,
+ *         "stat-htlb-pgfail": 0,
+ *         "stat-free-memory": 7607328768,
+ *         "stat-minor-faults": 325065,
+ *         "stat-major-faults": 636,
+ *         "stat-total-memory": 8025051136,
+ *         "stat-oom-kills": 18446744073709551615,
+ *         "stat-async-reclaims": 18446744073709551615,
+ *         "stat-swap-in": 0,
+ *         "stat-async-scans": 18446744073709551615,
+ *         "stat-disk-caches": 155353088
+ *     },
+ *     "last-update": 1770071149
+ * }
+ *
+ *
+ * 在以下使用balloon_stats_get_all():
+ *   - hw/virtio/virtio-balloon.c|1494| <<virtio_balloon_instance_init>> balloon_stats_get_all, NULL, NULL, NULL);
+ *
+ * 1497     object_property_add(obj, "guest-stats", "guest statistics",
+ * 1498                         balloon_stats_get_all, NULL, NULL, NULL);
+ */
 static void balloon_stats_get_all(Object *obj, Visitor *v, const char *name,
                                   void *opaque, Error **errp)
 {
@@ -262,6 +522,13 @@ static void balloon_stats_get_all(Object *obj, Visitor *v, const char *name,
     if (!visit_start_struct(v, name, NULL, 0, errp)) {
         return;
     }
+    /*
+     * 在以下使用VirtIOBalloon->stats_last_update:
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_get_all>> if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
+     *   - hw/virtio/virtio-balloon.c|608| <<virtio_balloon_receive_stats>> s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
+     *   - hw/virtio/virtio-balloon.c|1332| <<virtio_balloon_device_realize>> s->stats_last_update = 0;
+     *   - hw/virtio/virtio-balloon.c|1466| <<virtio_balloon_reset_enter>> s->stats_last_update = 0;
+     */
     if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
         goto out_end;
     }
@@ -290,9 +557,30 @@ static void balloon_stats_get_poll_interval(Object *obj, Visitor *v,
                                             Error **errp)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(obj);
+    /*
+     * 在以下使用VirtIOBalloon->stats_poll_interval:
+     *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+     *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+     *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+     *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+     *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     */
     visit_type_int(v, name, &s->stats_poll_interval, errp);
 }
 
+/*
+ * 在以下使用balloon_stats_set_poll_interval():
+ *   - hw/virtio/virtio-balloon.c|1470| <<virtio_balloon_instance_init>> balloon_stats_set_poll_interval,
+ *
+ * 1491     object_property_add(obj, "guest-stats-polling-interval", "int",
+ * 1492                         balloon_stats_get_poll_interval,
+ * 1493                         balloon_stats_set_poll_interval,
+ * 1494                         NULL, NULL);
+ */
 static void balloon_stats_set_poll_interval(Object *obj, Visitor *v,
                                             const char *name, void *opaque,
                                             Error **errp)
@@ -314,6 +602,18 @@ static void balloon_stats_set_poll_interval(Object *obj, Visitor *v,
         return;
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_poll_interval:
+     *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+     *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+     *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+     *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+     *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     */
     if (value == s->stats_poll_interval) {
         return;
     }
@@ -331,6 +631,14 @@ static void balloon_stats_set_poll_interval(Object *obj, Visitor *v,
         return;
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_timer:
+     *   - hw/virtio/virtio-balloon.c|292| <<balloon_stats_destroy_timer>> timer_free(s->stats_timer);
+     *   - hw/virtio/virtio-balloon.c|293| <<balloon_stats_destroy_timer>> s->stats_timer = NULL;
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_change_timer>> timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000);
+     *   - hw/virtio/virtio-balloon.c|471| <<balloon_stats_set_poll_interval>> g_assert(s->stats_timer == NULL);
+     *   - hw/virtio/virtio-balloon.c|472| <<balloon_stats_set_poll_interval>> s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
+     */
     /* create a new timer */
     g_assert(s->stats_timer == NULL);
     s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
@@ -338,11 +646,23 @@ static void balloon_stats_set_poll_interval(Object *obj, Visitor *v,
     balloon_stats_change_timer(s, 0);
 }
 
+/*
+ * 在以下使用virtio_balloon_handle_report():
+ *   - hw/virtio/virtio-balloon.c|960| <<virtio_balloon_device_realize>>
+ *      s->reporting_vq = virtio_add_queue(vdev, 32, virtio_balloon_handle_report);
+ */
 static void virtio_balloon_handle_report(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBalloon *dev = VIRTIO_BALLOON(vdev);
     VirtQueueElement *elem;
 
+    /*
+     * virtio-balloon使用virtqueue_pop()的地方:
+     *   - hw/virtio/virtio-balloon.c|398| <<virtio_balloon_handle_report>> while ((elem = virtqueue_pop(vq, sizeof(VirtQueueElement)))) {
+     *   - hw/virtio/virtio-balloon.c|488| <<virtio_balloon_handle_output>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|543| <<virtio_balloon_receive_stats>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|624| <<get_free_page_hints>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     */
     while ((elem = virtqueue_pop(vq, sizeof(VirtQueueElement)))) {
         unsigned int i;
 
@@ -389,16 +709,47 @@ static void virtio_balloon_handle_report(VirtIODevice *vdev, VirtQueue *vq)
                 continue;
             }
 
+            /*
+	     * 在以下使用ram_block_discard_range():
+             *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+             *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+             *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+             *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+             *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+             *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+             *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+             *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+             *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+             *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+             *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+             *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+             *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+             *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+             *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+	     */
             ram_block_discard_range(rb, ram_offset, size);
         }
 
 skip_element:
+        /*
+	 * virtio-balloon使用virtqueue_push()的地方:
+         *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+         *   - hw/virtio/virtio-balloon.c|594| <<virtio_balloon_handle_report>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|664| <<virtio_balloon_handle_output>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+         *   - hw/virtio/virtio-balloon.c|872| <<get_free_page_hints>> virtqueue_push(vq, elem, 0);
+	 */
         virtqueue_push(vq, elem, 0);
         virtio_notify(vdev, vq);
         g_free(elem);
     }
 }
 
+/*
+ * 在以下使用virtio_balloon_handle_output():
+ *   - hw/virtio/virtio-balloon.c|893| <<virtio_balloon_device_realize>> s->ivq = virtio_add_queue(vdev, 128, virtio_balloon_handle_output);
+ *   - hw/virtio/virtio-balloon.c|894| <<virtio_balloon_device_realize>> s->dvq = virtio_add_queue(vdev, 128, virtio_balloon_handle_output);
+ */
 static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
@@ -406,10 +757,25 @@ static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)
     MemoryRegionSection section;
 
     for (;;) {
+        /*
+	 * #define BALLOON_PAGE_SIZE  (1 << VIRTIO_BALLOON_PFN_SHIFT)
+	 *
+	 * typedef struct PartiallyBalloonedPage {
+	 *     ram_addr_t base_gpa;
+	 *     unsigned long *bitmap;
+	 * } PartiallyBalloonedPage;
+	 */
         PartiallyBalloonedPage pbp = {};
         size_t offset = 0;
         uint32_t pfn;
 
+        /*
+	 * virtio-balloon使用virtqueue_pop()的地方:
+         *   - hw/virtio/virtio-balloon.c|398| <<virtio_balloon_handle_report>> while ((elem = virtqueue_pop(vq, sizeof(VirtQueueElement)))) {
+         *   - hw/virtio/virtio-balloon.c|488| <<virtio_balloon_handle_output>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+         *   - hw/virtio/virtio-balloon.c|543| <<virtio_balloon_receive_stats>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+	 *   - hw/virtio/virtio-balloon.c|624| <<get_free_page_hints>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+	 */
         elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
         if (!elem) {
             break;
@@ -451,6 +817,14 @@ static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)
             memory_region_unref(section.mr);
         }
 
+        /*
+	 * virtio-balloon使用virtqueue_push()的地方:
+         *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+         *   - hw/virtio/virtio-balloon.c|594| <<virtio_balloon_handle_report>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|664| <<virtio_balloon_handle_output>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+         *   - hw/virtio/virtio-balloon.c|872| <<get_free_page_hints>> virtqueue_push(vq, elem, 0);
+	 */
         virtqueue_push(vq, elem, 0);
         virtio_notify(vdev, vq);
         g_free(elem);
@@ -458,6 +832,11 @@ static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)
     }
 }
 
+/*
+ * 在以下使用virtio_balloon_receive_stats():
+ *   - hw/virtio/virtio-balloon.c|1274| <<virtio_balloon_device_realize>> s->svq = virtio_add_queue(vdev, 128, virtio_balloon_receive_stats);
+ *   - hw/virtio/virtio-balloon.c|1388| <<virtio_balloon_set_status>> virtio_balloon_receive_stats(vdev, s->svq);
+ */
 static void virtio_balloon_receive_stats(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
@@ -465,18 +844,49 @@ static void virtio_balloon_receive_stats(VirtIODevice *vdev, VirtQueue *vq)
     VirtIOBalloonStat stat;
     size_t offset = 0;
 
+    /*
+     * virtio-balloon使用virtqueue_pop()的地方:
+     *   - hw/virtio/virtio-balloon.c|398| <<virtio_balloon_handle_report>> while ((elem = virtqueue_pop(vq, sizeof(VirtQueueElement)))) {
+     *   - hw/virtio/virtio-balloon.c|488| <<virtio_balloon_handle_output>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|543| <<virtio_balloon_receive_stats>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|624| <<get_free_page_hints>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     */
     elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
     if (!elem) {
         goto out;
     }
 
     if (s->stats_vq_elem != NULL) {
+        /*
+	 * virtio-balloon使用virtqueue_push()的地方:
+         *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+         *   - hw/virtio/virtio-balloon.c|594| <<virtio_balloon_handle_report>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|664| <<virtio_balloon_handle_output>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+	 *   - hw/virtio/virtio-balloon.c|872| <<get_free_page_hints>> virtqueue_push(vq, elem, 0);
+	 */
         /* This should never happen if the driver follows the spec. */
         virtqueue_push(vq, s->stats_vq_elem, 0);
         virtio_notify(vdev, vq);
         g_free(s->stats_vq_elem);
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_vq_elem:
+     *   - hw/virtio/virtio-balloon.c|344| <<balloon_stats_poll_cb>> if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|364| <<balloon_stats_poll_cb>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|365| <<balloon_stats_poll_cb>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|695| <<virtio_balloon_receive_stats>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|699| <<virtio_balloon_receive_stats>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|702| <<virtio_balloon_receive_stats>> s->stats_vq_elem = elem;
+     *   - hw/virtio/virtio-balloon.c|1582| <<virtio_balloon_device_reset>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|1583| <<virtio_balloon_device_reset>> virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|1584| <<virtio_balloon_device_reset>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|1585| <<virtio_balloon_device_reset>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|1595| <<virtio_balloon_set_status>> if (!s->stats_vq_elem && vdev->vm_running &&
+     */
     s->stats_vq_elem = elem;
 
     /* Initialize the stats to get rid of any stale values.  This is only
@@ -495,21 +905,64 @@ static void virtio_balloon_receive_stats(VirtIODevice *vdev, VirtQueue *vq)
             s->stats[tag] = val;
     }
     s->stats_vq_offset = offset;
+    /*
+     * 在以下使用VirtIOBalloon->stats_last_update:
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_get_all>> if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
+     *   - hw/virtio/virtio-balloon.c|608| <<virtio_balloon_receive_stats>> s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
+     *   - hw/virtio/virtio-balloon.c|1332| <<virtio_balloon_device_realize>> s->stats_last_update = 0;
+     *   - hw/virtio/virtio-balloon.c|1466| <<virtio_balloon_reset_enter>> s->stats_last_update = 0;
+     */
     s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
 
 out:
     if (balloon_stats_enabled(s)) {
+        /*
+	 * 在以下使用VirtIOBalloon->stats_poll_interval:
+         *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+         *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+         *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+         *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+         *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+	 */
         balloon_stats_change_timer(s, s->stats_poll_interval);
     }
 }
 
+/*
+ * 在以下使用virtio_balloon_handle_free_page_vq():
+ *   - hw/virtio/virtio-balloon.c|1008| <<virtio_balloon_device_realize>> virtio_balloon_handle_free_page_vq);
+ *
+ * 1015     if (virtio_has_feature(s->host_features, VIRTIO_BALLOON_F_FREE_PAGE_HINT)) {
+ * 1016         s->free_page_vq = virtio_add_queue(vdev, VIRTQUEUE_MAX_SIZE,
+ * 1017                                            virtio_balloon_handle_free_page_vq);
+ * 1018         precopy_add_notifier(&s->free_page_hint_notify);
+ */
 static void virtio_balloon_handle_free_page_vq(VirtIODevice *vdev,
                                                VirtQueue *vq)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
+    /*
+     * 在以下使用VirtIOBalloon->free_page_bh:
+     *   - hw/virtio/virtio-balloon.c|582| <<virtio_balloon_handle_free_page_vq>> qemu_bh_schedule(s->free_page_bh);
+     *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+     *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+     *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+     *   - hw/virtio/virtio-balloon.c|1043| <<virtio_balloon_device_unrealize>> if (s->free_page_bh) {
+     *   - hw/virtio/virtio-balloon.c|1044| <<virtio_balloon_device_unrealize>> qemu_bh_delete(s->free_page_bh);
+     *
+     * 处理的函数: virtio_ballloon_get_free_page_hints()
+     */
     qemu_bh_schedule(s->free_page_bh);
 }
 
+/*
+ * 在以下使用get_free_page_hints():
+ *   - hw/virtio/virtio-balloon.c|648| <<virtio_ballloon_get_free_page_hints>> continue_to_get_hints = get_free_page_hints(dev);
+ */
 static bool get_free_page_hints(VirtIOBalloon *dev)
 {
     VirtQueueElement *elem;
@@ -522,6 +975,13 @@ static bool get_free_page_hints(VirtIOBalloon *dev)
         qemu_cond_wait(&dev->free_page_cond, &dev->free_page_lock);
     }
 
+    /*
+     * virtio-balloon使用virtqueue_pop()的地方:
+     *   - hw/virtio/virtio-balloon.c|398| <<virtio_balloon_handle_report>> while ((elem = virtqueue_pop(vq, sizeof(VirtQueueElement)))) {
+     *   - hw/virtio/virtio-balloon.c|488| <<virtio_balloon_handle_output>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|543| <<virtio_balloon_receive_stats>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|624| <<get_free_page_hints>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     */
     elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
     if (!elem) {
         return false;
@@ -538,6 +998,38 @@ static bool get_free_page_hints(VirtIOBalloon *dev)
             ret = false;
             goto out;
         }
+	/*
+	 * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+         *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+         *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+         *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+         *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+         * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+         *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+         *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+         *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+         *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+         *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+         *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+         *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+	 *
+	 * 在以下使用VirtIOBalloon->free_page_hint_status:
+         *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+         *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+         *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+         *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+         *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+         *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+         *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+         *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+         *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+         *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+         *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+         *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+         *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+         *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+         *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+	 */
         if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
             id == dev->free_page_hint_cmd_id) {
             dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
@@ -552,17 +1044,49 @@ static bool get_free_page_hints(VirtIOBalloon *dev)
 
     if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
         for (i = 0; i < elem->in_num; i++) {
+            /*
+	     * 注释:
+	     * This function clears bits of the free pages reported by the caller from the
+	     * migration dirty bitmap. @addr is the host address corresponding to the
+	     * start of the continuous guest free pages, and @len is the total bytes of
+	     * those pages.
+	     */
             qemu_guest_free_page_hint(elem->in_sg[i].iov_base,
                                       elem->in_sg[i].iov_len);
         }
     }
 
 out:
+    /*
+     * virtio-balloon使用virtqueue_push()的地方:
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|594| <<virtio_balloon_handle_report>> virtqueue_push(vq, elem, 0);
+     *   - hw/virtio/virtio-balloon.c|664| <<virtio_balloon_handle_output>> virtqueue_push(vq, elem, 0);
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|872| <<get_free_page_hints>> virtqueue_push(vq, elem, 0);
+     */
     virtqueue_push(vq, elem, 0);
     g_free(elem);
     return ret;
 }
 
+/*
+ * 在以下使用VirtIOBalloon->free_page_bh:
+ *   - hw/virtio/virtio-balloon.c|582| <<virtio_balloon_handle_free_page_vq>> qemu_bh_schedule(s->free_page_bh);
+ *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+ *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+ *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+ *   - hw/virtio/virtio-balloon.c|1043| <<virtio_balloon_device_unrealize>> if (s->free_page_bh) {
+ *   - hw/virtio/virtio-balloon.c|1044| <<virtio_balloon_device_unrealize>> qemu_bh_delete(s->free_page_bh);
+ *
+ * 处理的函数: virtio_ballloon_get_free_page_hints()
+ *
+ *
+ * 在以下使用virtio_ballloon_get_free_page_hints():
+ *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+ *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+ *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+ */
 static void virtio_ballloon_get_free_page_hints(void *opaque)
 {
     VirtIOBalloon *dev = opaque;
@@ -570,9 +1094,30 @@ static void virtio_ballloon_get_free_page_hints(void *opaque)
     VirtQueue *vq = dev->free_page_vq;
     bool continue_to_get_hints;
 
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     do {
         qemu_mutex_lock(&dev->free_page_lock);
         virtio_queue_set_notification(vq, 0);
+        /*
+	 * 只在这里调用
+	 */
         continue_to_get_hints = get_free_page_hints(dev);
         qemu_mutex_unlock(&dev->free_page_lock);
         virtio_notify(vdev, vq);
@@ -585,6 +1130,13 @@ static void virtio_ballloon_get_free_page_hints(void *opaque)
     virtio_queue_set_notification(vq, 1);
 }
 
+/*
+ * 在以下使用virtio_balloon_free_page_support()
+ *   - hw/virtio/virtio-balloon.c|1159| <<global>> .needed = virtio_balloon_free_page_support,
+ *   - hw/virtio/virtio-balloon.c|891| <<virtio_balloon_free_page_hint_notify>> if (!virtio_balloon_free_page_support(dev)) {
+ *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_reset>> if (virtio_balloon_free_page_support(s)) {
+ *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_set_status>> if (virtio_balloon_free_page_support(s)) {
+ */
 static bool virtio_balloon_free_page_support(void *opaque)
 {
     VirtIOBalloon *s = opaque;
@@ -593,28 +1145,89 @@ static bool virtio_balloon_free_page_support(void *opaque)
     return virtio_vdev_has_feature(vdev, VIRTIO_BALLOON_F_FREE_PAGE_HINT);
 }
 
+/*
+ * 在以下使用virtio_balloon_free_page_start():
+ *   - hw/virtio/virtio-balloon.c|971| <<virtio_balloon_free_page_hint_notify>> virtio_balloon_free_page_start(dev);
+ */
 static void virtio_balloon_free_page_start(VirtIOBalloon *s)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
 
     qemu_mutex_lock(&s->free_page_lock);
 
+    /*
+     * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+     *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+     *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+     *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     */
     if (s->free_page_hint_cmd_id == UINT_MAX) {
         s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
     } else {
         s->free_page_hint_cmd_id++;
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
     qemu_mutex_unlock(&s->free_page_lock);
 
     virtio_notify_config(vdev);
 }
 
+/*
+ * 在以下使用virtio_balloon_free_page_stop():
+ *   - hw/virtio/virtio-balloon.c|967| <<virtio_balloon_free_page_hint_notify>> virtio_balloon_free_page_stop(dev);
+ *   - hw/virtio/virtio-balloon.c|1338| <<virtio_balloon_device_unrealize>> virtio_balloon_free_page_stop(s);
+ *   - hw/virtio/virtio-balloon.c|1368| <<virtio_balloon_device_reset>> virtio_balloon_free_page_stop(s);
+ */
 static void virtio_balloon_free_page_stop(VirtIOBalloon *s)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
 
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
         /*
          * The lock also guarantees us that the
@@ -632,10 +1245,32 @@ static void virtio_balloon_free_page_stop(VirtIOBalloon *s)
     }
 }
 
+/*
+ * 在以下使用virtio_balloon_free_page_done():
+ *   - hw/virtio/virtio-balloon.c|983| <<virtio_balloon_free_page_hint_notify>> virtio_balloon_free_page_done(dev);
+ */
 static void virtio_balloon_free_page_done(VirtIOBalloon *s)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
 
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
         /* See virtio_balloon_free_page_stop() */
         qemu_mutex_lock(&s->free_page_lock);
@@ -645,6 +1280,82 @@ static void virtio_balloon_free_page_done(VirtIOBalloon *s)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_balloon_free_page_hint_notify (n=0x555558509d50, data=0x7ffdd4dfd664, errp=0x7ffdd4dfd690)
+ * #1  0x00005555561610d1 in notifier_with_return_list_notify (list=0x55555751aa08 <precopy_notifier_list>
+ * #2  0x0000555555c774d1 in precopy_notify (reason=PRECOPY_NOTIFY_BEFORE_BITMAP_SYNC, errp=0x7ffdd4dfd690)
+ * #3  0x0000555555c794a1 in migration_bitmap_sync_precopy (last_stage=false) at ../migration/ram.c:1200
+ * #4  0x0000555555c7d33a in ram_init_bitmaps (rs=0x7ffdc4000c00, errp=0x7ffdd4dfd828)
+ * #5  0x0000555555c7d425 in ram_init_all (rsp=0x55555751aa00 <ram_state>, errp=0x7ffdd4dfd828) 
+ * #6  0x0000555555c7dbec in ram_save_setup (f=0x555557acc8d0, opaque=0x55555751aa00 <ram_state>
+ * #7  0x0000555555c86a22 in qemu_savevm_state_setup (f=0x555557acc8d0, errp=0x7ffdd4dfd828)
+ * #8  0x0000555555c65bdb in migration_thread (opaque=0x5555578cfbe0) at ../migration/migration.c:3810
+ * #9  0x00005555561580bb in qemu_thread_start (args=0x555557f59960) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff6c9a1da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4fcb8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  virtio_balloon_free_page_hint_notify (n=0x555558509d50, data=0x7ffdd4dfd664, errp=0x7ffdd4dfd690)
+ * #1  0x00005555561610d1 in notifier_with_return_list_notify (list=0x55555751aa08 <precopy_notifier_list>
+ * #2  0x0000555555c774d1 in precopy_notify (reason=PRECOPY_NOTIFY_AFTER_BITMAP_SYNC, errp=0x7ffdd4dfd690)
+ * #3  0x0000555555c794df in migration_bitmap_sync_precopy (last_stage=false) at ../migration/ram.c:1207
+ * #4  0x0000555555c7d33a in ram_init_bitmaps (rs=0x7ffdc4000c00, errp=0x7ffdd4dfd828)
+ * #5  0x0000555555c7d425 in ram_init_all (rsp=0x55555751aa00 <ram_state>, errp=0x7ffdd4dfd828)
+ * #6  0x0000555555c7dbec in ram_save_setup (f=0x555557acc8d0, opaque=0x55555751aa00 <ram_state>
+ * #7  0x0000555555c86a22 in qemu_savevm_state_setup (f=0x555557acc8d0, errp=0x7ffdd4dfd828)
+ * #8  0x0000555555c65bdb in migration_thread (opaque=0x5555578cfbe0) at ../migration/migration.c:3810
+ * #9  0x00005555561580bb in qemu_thread_start (args=0x555557f59960) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff6c9a1da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4fcb8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  virtio_balloon_free_page_hint_notify (n=0x555558509d50, data=0x7ffdd4dfd774, errp=0x7ffdd4dfd828)
+ * #1  0x00005555561610d1 in notifier_with_return_list_notify (list=0x55555751aa08 <precopy_notifier_list>
+ * #2  0x0000555555c774d1 in precopy_notify (reason=PRECOPY_NOTIFY_SETUP, errp=0x7ffdd4dfd828)
+ * #3  0x0000555555c86a8a in qemu_savevm_state_setup (f=0x555557acc8d0, errp=0x7ffdd4dfd828)
+ * #4  0x0000555555c65bdb in migration_thread (opaque=0x5555578cfbe0) at ../migration/migration.c:3810
+ * #5  0x00005555561580bb in qemu_thread_start (args=0x555557f59960) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff6c9a1da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4fcb8d3 in clone () from /lib64/libc.so.6
+ * 
+ * (gdb) bt
+ * #0  virtio_balloon_free_page_hint_notify (n=0x555558509d50, data=0x7ffdd4dfd6d4, errp=0x7ffdd4dfd700)
+ * #1  0x00005555561610d1 in notifier_with_return_list_notify (list=0x55555751aa08 <precopy_notifier_list>
+ * #2  0x0000555555c774d1 in precopy_notify (reason=PRECOPY_NOTIFY_AFTER_BITMAP_SYNC, errp=0x7ffdd4dfd700)
+ * #3  0x0000555555c794df in migration_bitmap_sync_precopy (last_stage=false) at ../migration/ram.c:1207
+ * #4  0x0000555555c7e94c in ram_state_pending_exact (opaque=0x55555751aa00 <ram_state>,
+ * #5  0x0000555555c87892 in qemu_savevm_state_pending_exact (must_precopy=0x7ffdd4dfd7c8,
+ * #6  0x0000555555c65474 in migration_iteration_run (s=0x5555578cfbe0) at ../migration/migration.c:3514
+ * #7  0x0000555555c65c8e in migration_thread (opaque=0x5555578cfbe0) at ../migration/migration.c:3834
+ * #8  0x00005555561580bb in qemu_thread_start (args=0x555557f59960) at ../util/qemu-thread-posix.c:393
+ * #9  0x00007ffff6c9a1da in start_thread () from /lib64/libpthread.so.0
+ * #10 0x00007ffff4fcb8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  virtio_balloon_free_page_hint_notify (n=0x555558509d50, data=0x7ffdd4dfd6b4, errp=0x7ffdd4dfd6d0)
+ * #1  0x00005555561610d1 in notifier_with_return_list_notify (list=0x55555751aa08 <precopy_notifier_list>,
+ * #2  0x0000555555c774d1 in precopy_notify (reason=PRECOPY_NOTIFY_COMPLETE, errp=0x7ffdd4dfd6d0)
+ * #3  0x0000555555c5dcbf in precopy_notify_complete () at ../migration/migration.c:157
+ * #4  0x0000555555c64434 in migration_switchover_start (s=0x5555578cfbe0, errp=0x7ffdd4dfd700)
+ * #5  0x0000555555c644e4 in migration_completion_precopy (s=0x5555578cfbe0)
+ * #6  0x0000555555c645d4 in migration_completion (s=0x5555578cfbe0) at ../migration/migration.c:3064
+ * #7  0x0000555555c6554f in migration_iteration_run (s=0x5555578cfbe0) at ../migration/migration.c:3542
+ * #8  0x0000555555c65c8e in migration_thread (opaque=0x5555578cfbe0) at ../migration/migration.c:3834
+ * #9  0x00005555561580bb in qemu_thread_start (args=0x555557f59960) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff6c9a1da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4fcb8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用VirtIOBalloon->free_page_hint_notify:
+ *   - hw/virtio/virtio-balloon.c|961| <<virtio_balloon_free_page_hint_notify>> VirtIOBalloon *dev = container_of(n, VirtIOBalloon, free_page_hint_notify);
+ *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+ *   - hw/virtio/virtio-balloon.c|1367| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+ *   - hw/virtio/virtio-balloon.c|1491| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+ *
+ * 在以下使用virtio_balloon_free_page_hint_notify():
+ *   - hw/virtio/virtio-balloon.c|1396| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+ */
 static int
 virtio_balloon_free_page_hint_notify(NotifierWithReturn *n, void *data,
                                      Error **errp)
@@ -653,6 +1364,13 @@ virtio_balloon_free_page_hint_notify(NotifierWithReturn *n, void *data,
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
     PrecopyNotifyData *pnd = data;
 
+    /*
+     * 在以下使用virtio_balloon_free_page_support()
+     *   - hw/virtio/virtio-balloon.c|1159| <<global>> .needed = virtio_balloon_free_page_support,
+     *   - hw/virtio/virtio-balloon.c|891| <<virtio_balloon_free_page_hint_notify>> if (!virtio_balloon_free_page_support(dev)) {
+     *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_reset>> if (virtio_balloon_free_page_support(s)) {
+     *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_set_status>> if (virtio_balloon_free_page_support(s)) {
+     */
     if (!virtio_balloon_free_page_support(dev)) {
         /*
          * This is an optimization provided to migration, so just return 0 to
@@ -704,6 +1422,12 @@ virtio_balloon_free_page_hint_notify(NotifierWithReturn *n, void *data,
     return 0;
 }
 
+/*
+ * 在以下使用virtio_balloon_config_size():
+ *   - hw/virtio/virtio-balloon.c|816| <<virtio_balloon_get_config>> memcpy(config_data, &config, virtio_balloon_config_size(dev));
+ *   - hw/virtio/virtio-balloon.c|849| <<virtio_balloon_set_config>> memcpy(&config, config_data, virtio_balloon_config_size(dev));
+ *   - hw/virtio/virtio-balloon.c|984| <<virtio_balloon_device_realize>> virtio_init(vdev, VIRTIO_ID_BALLOON, virtio_balloon_config_size(s));
+ */
 static size_t virtio_balloon_config_size(VirtIOBalloon *s)
 {
     uint64_t features = s->host_features;
@@ -717,6 +1441,21 @@ static size_t virtio_balloon_config_size(VirtIOBalloon *s)
     if (virtio_has_feature(features, VIRTIO_BALLOON_F_FREE_PAGE_HINT)) {
         return offsetof(struct virtio_balloon_config, poison_val);
     }
+    /*
+     * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+     *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+     *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+     *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     */
     return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
 }
 
@@ -729,6 +1468,39 @@ static void virtio_balloon_get_config(VirtIODevice *vdev, uint8_t *config_data)
     config.actual = cpu_to_le32(dev->actual);
     config.poison_val = cpu_to_le32(dev->poison_val);
 
+    /*
+     * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+     *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+     *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+     *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *
+     *
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
         config.free_page_hint_cmd_id =
                        cpu_to_le32(dev->free_page_hint_cmd_id);
@@ -744,6 +1516,12 @@ static void virtio_balloon_get_config(VirtIODevice *vdev, uint8_t *config_data)
     memcpy(config_data, &config, virtio_balloon_config_size(dev));
 }
 
+/*
+ * 在以下使用get_current_ram_size():
+ *   - hw/virtio/virtio-balloon.c|1282| <<virtio_balloon_set_config>> ram_addr_t vm_ram_size = get_current_ram_size();
+ *   - hw/virtio/virtio-balloon.c|1338| <<virtio_balloon_stat>> info->actual = get_current_ram_size() - ((uint64_t) dev->actual <<
+ *   - hw/virtio/virtio-balloon.c|1351| <<virtio_balloon_to_target>> ram_addr_t vm_ram_size = get_current_ram_size();
+ */
 static ram_addr_t get_current_ram_size(void)
 {
     MachineState *machine = MACHINE(qdev_get_machine());
@@ -754,6 +1532,11 @@ static ram_addr_t get_current_ram_size(void)
     }
 }
 
+/*
+ * 在以下使用virtio_balloon_page_poison_support():
+ *   - hw/virtio/virtio-balloon.c|1401| <<global>> .needed = virtio_balloon_page_poison_support,
+ *   - hw/virtio/virtio-balloon.c|1319| <<virtio_balloon_set_config>> if (virtio_balloon_page_poison_support(dev)) {
+ */
 static bool virtio_balloon_page_poison_support(void *opaque)
 {
     VirtIOBalloon *s = opaque;
@@ -762,17 +1545,55 @@ static bool virtio_balloon_page_poison_support(void *opaque)
     return virtio_vdev_has_feature(vdev, VIRTIO_BALLOON_F_PAGE_POISON);
 }
 
+/*
+ * 在以下使用virtio_balloon_set_config():
+ *   - hw/virtio/virtio-balloon.c|1076| <<virtio_balloon_class_init>> vdc->set_config = virtio_balloon_set_config;
+ */
 static void virtio_balloon_set_config(VirtIODevice *vdev,
                                       const uint8_t *config_data)
 {
     VirtIOBalloon *dev = VIRTIO_BALLOON(vdev);
     struct virtio_balloon_config config;
     uint32_t oldactual = dev->actual;
+    /*
+     * 在以下使用get_current_ram_size():
+     *   - hw/virtio/virtio-balloon.c|1282| <<virtio_balloon_set_config>> ram_addr_t vm_ram_size = get_current_ram_size();
+     *   - hw/virtio/virtio-balloon.c|1338| <<virtio_balloon_stat>> info->actual = get_current_ram_size() - ((uint64_t) dev->actual <<
+     *   - hw/virtio/virtio-balloon.c|1351| <<virtio_balloon_to_target>> ram_addr_t vm_ram_size = get_current_ram_size();
+     */
     ram_addr_t vm_ram_size = get_current_ram_size();
 
     memcpy(&config, config_data, virtio_balloon_config_size(dev));
     dev->actual = le32_to_cpu(config.actual);
     if (dev->actual != oldactual) {
+        /*
+	 * qapi的代码
+	 * 1154 ##
+	 * 1155 # @BALLOON_CHANGE:
+	 * 1156 #
+	 * 1157 # Emitted when the guest changes the actual BALLOON level.  This value
+	 * 1158 # is equivalent to the @actual field return by the `query-balloon`
+	 * 1159 # command
+	 * 1160 #
+	 * 1161 # @actual: the logical size of the VM in bytes.  Formula used:
+	 * 1162 #     logical_vm_size = vm_ram_size - balloon_size
+	 * 1163 #
+	 * 1164 # .. note:: This event is rate-limited.
+	 * 1165 #
+	 * 1166 # Since: 1.2
+	 * 1167 #
+	 * 1168 # .. qmp-example::
+	 * 1169 #
+	 * 1170 #     <- { "event": "BALLOON_CHANGE",
+	 * 1171 #          "data": { "actual": 944766976 },
+	 * 1172 #          "timestamp": { "seconds": 1267020223, "microseconds": 435656 } }
+	 * 1173 ##
+	 * 1174 { 'event': 'BALLOON_CHANGE',
+	 * 1175   'data': { 'actual': 'int' } }
+	 *
+	 * 只在这里使用
+	 * 重点"This event is rate-limited"
+	 */
         qapi_event_send_balloon_change(vm_ram_size -
                         ((ram_addr_t) dev->actual << VIRTIO_BALLOON_PFN_SHIFT));
     }
@@ -796,14 +1617,31 @@ static uint64_t virtio_balloon_get_features(VirtIODevice *vdev, uint64_t f,
 static void virtio_balloon_stat(void *opaque, BalloonInfo *info)
 {
     VirtIOBalloon *dev = opaque;
+    /*
+     * 在以下使用get_current_ram_size():
+     *   - hw/virtio/virtio-balloon.c|1282| <<virtio_balloon_set_config>> ram_addr_t vm_ram_size = get_current_ram_size();
+     *   - hw/virtio/virtio-balloon.c|1338| <<virtio_balloon_stat>> info->actual = get_current_ram_size() - ((uint64_t) dev->actual <<
+     *   - hw/virtio/virtio-balloon.c|1351| <<virtio_balloon_to_target>> ram_addr_t vm_ram_size = get_current_ram_size();
+     */
     info->actual = get_current_ram_size() - ((uint64_t) dev->actual <<
                                              VIRTIO_BALLOON_PFN_SHIFT);
 }
 
+/*
+ * 在以下使用virtio_balloon_to_target():
+ *   - hw/virtio/virtio-balloon.c|889| <<virtio_balloon_device_realize>>
+ *          ret = qemu_add_balloon_handler(virtio_balloon_to_target, virtio_balloon_stat, s);
+ */
 static void virtio_balloon_to_target(void *opaque, ram_addr_t target)
 {
     VirtIOBalloon *dev = VIRTIO_BALLOON(opaque);
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+    /*
+     * 在以下使用get_current_ram_size():
+     *   - hw/virtio/virtio-balloon.c|1282| <<virtio_balloon_set_config>> ram_addr_t vm_ram_size = get_current_ram_size();
+     *   - hw/virtio/virtio-balloon.c|1338| <<virtio_balloon_stat>> info->actual = get_current_ram_size() - ((uint64_t) dev->actual <<
+     *   - hw/virtio/virtio-balloon.c|1351| <<virtio_balloon_to_target>> ram_addr_t vm_ram_size = get_current_ram_size();
+     */
     ram_addr_t vm_ram_size = get_current_ram_size();
 
     if (target > vm_ram_size) {
@@ -821,6 +1659,18 @@ static int virtio_balloon_post_load_device(void *opaque, int version_id)
     VirtIOBalloon *s = VIRTIO_BALLOON(opaque);
 
     if (balloon_stats_enabled(s)) {
+        /*
+	 * 在以下使用VirtIOBalloon->stats_poll_interval:
+	 *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+	 *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+         *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+         *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+         *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+	 */
         balloon_stats_change_timer(s, s->stats_poll_interval);
     }
     return 0;
@@ -874,6 +1724,13 @@ static void virtio_balloon_device_realize(DeviceState *dev, Error **errp)
 
     virtio_init(vdev, VIRTIO_ID_BALLOON, virtio_balloon_config_size(s));
 
+    /*
+     * 在以下使用qemu_add_balloon_handler():
+     *   - hw/hyperv/hv-balloon.c|1504| <<hv_balloon_vmdev_realize>>
+     *         ret = qemu_add_balloon_handler(hv_balloon_to_target, hv_balloon_stat, balloon);
+     *   - hw/virtio/virtio-balloon.c|1317| <<virtio_balloon_device_realize>>
+     *         ret = qemu_add_balloon_handler(virtio_balloon_to_target, virtio_balloon_stat, s);
+     */
     ret = qemu_add_balloon_handler(virtio_balloon_to_target,
                                    virtio_balloon_stat, s);
 
@@ -897,9 +1754,27 @@ static void virtio_balloon_device_realize(DeviceState *dev, Error **errp)
     if (virtio_has_feature(s->host_features, VIRTIO_BALLOON_F_FREE_PAGE_HINT)) {
         s->free_page_vq = virtio_add_queue(vdev, VIRTQUEUE_MAX_SIZE,
                                            virtio_balloon_handle_free_page_vq);
+        /*
+	 * 在以下使用VirtIOBalloon->free_page_hint_notify:
+         *   - hw/virtio/virtio-balloon.c|961| <<virtio_balloon_free_page_hint_notify>> VirtIOBalloon *dev = container_of(n, VirtIOBalloon, free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1367| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1491| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+	 */
         precopy_add_notifier(&s->free_page_hint_notify);
 
         object_ref(OBJECT(s->iothread));
+        /*
+	 * 在以下使用VirtIOBalloon->free_page_bh:
+         *   - hw/virtio/virtio-balloon.c|582| <<virtio_balloon_handle_free_page_vq>> qemu_bh_schedule(s->free_page_bh);
+         *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+         *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+         *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+         *   - hw/virtio/virtio-balloon.c|1043| <<virtio_balloon_device_unrealize>> if (s->free_page_bh) {
+         *   - hw/virtio/virtio-balloon.c|1044| <<virtio_balloon_device_unrealize>> qemu_bh_delete(s->free_page_bh);
+         *
+         * 处理的函数: virtio_ballloon_get_free_page_hints()
+	 */
         s->free_page_bh = aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
                                              virtio_ballloon_get_free_page_hints, s,
                                              &dev->mem_reentrancy_guard);
@@ -910,8 +1785,31 @@ static void virtio_balloon_device_realize(DeviceState *dev, Error **errp)
                                            virtio_balloon_handle_report);
     }
 
+    /*
+     * 在以下使用reset_stats():
+     *   - hw/virtio/virtio-balloon.c|596| <<virtio_balloon_receive_stats>> reset_stats(s);
+     *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_device_realize>> reset_stats(s);
+     *   - hw/virtio/virtio-balloon.c|1465| <<virtio_balloon_reset_enter>> reset_stats(s);
+     */
     reset_stats(s);
+    /*
+     * 在以下使用VirtIOBalloon->stats_last_update:
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_get_all>> if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
+     *   - hw/virtio/virtio-balloon.c|608| <<virtio_balloon_receive_stats>> s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
+     *   - hw/virtio/virtio-balloon.c|1332| <<virtio_balloon_device_realize>> s->stats_last_update = 0;
+     *   - hw/virtio/virtio-balloon.c|1466| <<virtio_balloon_reset_enter>> s->stats_last_update = 0;
+     */
     s->stats_last_update = 0;
+    /*
+     * 在以下使用qemu_register_resettable():
+     *   - hw/core/machine.c|1805| <<qdev_machine_creation_done>> qemu_register_resettable(OBJECT(sysbus_get_default()));
+     *   - hw/core/reset.c|102| <<qemu_register_reset>> qemu_register_resettable(obj);
+     *   - hw/core/reset.c|113| <<qemu_register_reset_nosnapshotload>> qemu_register_resettable(obj);
+     *   - hw/loongarch/virt.c|1145| <<virt_cpu_plug>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/misc/vmcoreinfo.c|68| <<vmcoreinfo_realize>> qemu_register_resettable(OBJECT(s));
+     *   - hw/virtio/virtio-balloon.c|970| <<virtio_balloon_device_realize>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/virtio/virtio-mem.c|1150| <<virtio_mem_device_realize>> qemu_register_resettable(obj);
+     */
     qemu_register_resettable(OBJECT(dev));
 }
 
@@ -921,10 +1819,28 @@ static void virtio_balloon_device_unrealize(DeviceState *dev)
     VirtIOBalloon *s = VIRTIO_BALLOON(dev);
 
     qemu_unregister_resettable(OBJECT(dev));
+    /*
+     * 在以下使用VirtIOBalloon->free_page_bh:
+     *   - hw/virtio/virtio-balloon.c|582| <<virtio_balloon_handle_free_page_vq>> qemu_bh_schedule(s->free_page_bh);
+     *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+     *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+     *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+     *   - hw/virtio/virtio-balloon.c|1043| <<virtio_balloon_device_unrealize>> if (s->free_page_bh) {
+     *   - hw/virtio/virtio-balloon.c|1044| <<virtio_balloon_device_unrealize>> qemu_bh_delete(s->free_page_bh);
+     *
+     * 处理的函数: virtio_ballloon_get_free_page_hints()
+     */
     if (s->free_page_bh) {
         qemu_bh_delete(s->free_page_bh);
         object_unref(OBJECT(s->iothread));
         virtio_balloon_free_page_stop(s);
+        /*
+	 * 在以下使用VirtIOBalloon->free_page_hint_notify:
+         *   - hw/virtio/virtio-balloon.c|961| <<virtio_balloon_free_page_hint_notify>> VirtIOBalloon *dev = container_of(n, VirtIOBalloon, free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1367| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1491| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+	 */
         precopy_remove_notifier(&s->free_page_hint_notify);
     }
     balloon_stats_destroy_timer(s);
@@ -946,10 +1862,33 @@ static void virtio_balloon_device_reset(VirtIODevice *vdev)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
 
+    /*
+     * 在以下使用virtio_balloon_free_page_support()
+     *   - hw/virtio/virtio-balloon.c|1159| <<global>> .needed = virtio_balloon_free_page_support,
+     *   - hw/virtio/virtio-balloon.c|891| <<virtio_balloon_free_page_hint_notify>> if (!virtio_balloon_free_page_support(dev)) {
+     *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_reset>> if (virtio_balloon_free_page_support(s)) {
+     *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_set_status>> if (virtio_balloon_free_page_support(s)) {
+     */
     if (virtio_balloon_free_page_support(s)) {
         virtio_balloon_free_page_stop(s);
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_vq_elem:
+     *   - hw/virtio/virtio-balloon.c|344| <<balloon_stats_poll_cb>> if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|364| <<balloon_stats_poll_cb>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|365| <<balloon_stats_poll_cb>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|695| <<virtio_balloon_receive_stats>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|699| <<virtio_balloon_receive_stats>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|702| <<virtio_balloon_receive_stats>> s->stats_vq_elem = elem;
+     *   - hw/virtio/virtio-balloon.c|1582| <<virtio_balloon_device_reset>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|1583| <<virtio_balloon_device_reset>> virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|1584| <<virtio_balloon_device_reset>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|1585| <<virtio_balloon_device_reset>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|1595| <<virtio_balloon_set_status>> if (!s->stats_vq_elem && vdev->vm_running &&
+     */
     if (s->stats_vq_elem != NULL) {
         virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
         g_free(s->stats_vq_elem);
@@ -963,6 +1902,22 @@ static int virtio_balloon_set_status(VirtIODevice *vdev, uint8_t status)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_vq_elem:
+     *   - hw/virtio/virtio-balloon.c|344| <<balloon_stats_poll_cb>> if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|364| <<balloon_stats_poll_cb>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|365| <<balloon_stats_poll_cb>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|695| <<virtio_balloon_receive_stats>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|699| <<virtio_balloon_receive_stats>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|702| <<virtio_balloon_receive_stats>> s->stats_vq_elem = elem;
+     *   - hw/virtio/virtio-balloon.c|1582| <<virtio_balloon_device_reset>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|1583| <<virtio_balloon_device_reset>> virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|1584| <<virtio_balloon_device_reset>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|1585| <<virtio_balloon_device_reset>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|1595| <<virtio_balloon_set_status>> if (!s->stats_vq_elem && vdev->vm_running &&
+     */
     if (!s->stats_vq_elem && vdev->vm_running &&
         (status & VIRTIO_CONFIG_S_DRIVER_OK) && virtqueue_rewind(s->svq, 1)) {
         /* poll stats queue for the element we have discarded when the VM
@@ -970,6 +1925,13 @@ static int virtio_balloon_set_status(VirtIODevice *vdev, uint8_t status)
         virtio_balloon_receive_stats(vdev, s->svq);
     }
 
+    /*
+     * 在以下使用virtio_balloon_free_page_support()
+     *   - hw/virtio/virtio-balloon.c|1159| <<global>> .needed = virtio_balloon_free_page_support,
+     *   - hw/virtio/virtio-balloon.c|891| <<virtio_balloon_free_page_hint_notify>> if (!virtio_balloon_free_page_support(dev)) {
+     *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_reset>> if (virtio_balloon_free_page_support(s)) {
+     *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_set_status>> if (virtio_balloon_free_page_support(s)) {
+     */
     if (virtio_balloon_free_page_support(s)) {
         /*
          * The VM is woken up and the iothread was blocked, so signal it to
@@ -1010,6 +1972,13 @@ static void virtio_balloon_reset_enter(Object *obj, ResetType type)
     }
 
     reset_stats(s);
+    /*
+     * 在以下使用VirtIOBalloon->stats_last_update:
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_get_all>> if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
+     *   - hw/virtio/virtio-balloon.c|608| <<virtio_balloon_receive_stats>> s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
+     *   - hw/virtio/virtio-balloon.c|1332| <<virtio_balloon_device_realize>> s->stats_last_update = 0;
+     *   - hw/virtio/virtio-balloon.c|1466| <<virtio_balloon_reset_enter>> s->stats_last_update = 0;
+     */
     s->stats_last_update = 0;
 }
 
@@ -1019,7 +1988,29 @@ static void virtio_balloon_instance_init(Object *obj)
 
     qemu_mutex_init(&s->free_page_lock);
     qemu_cond_init(&s->free_page_cond);
+    /*
+     * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+     *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+     *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+     *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     */
     s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_notify:
+     *   - hw/virtio/virtio-balloon.c|961| <<virtio_balloon_free_page_hint_notify>> VirtIOBalloon *dev = container_of(n, VirtIOBalloon, free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1367| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1491| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+     */
     s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
 
     object_property_add(obj, "guest-stats", "guest statistics",
diff --git a/hw/virtio/virtio-pci.c b/hw/virtio/virtio-pci.c
index 99cb30fe5..e6a8a27c9 100644
--- a/hw/virtio/virtio-pci.c
+++ b/hw/virtio/virtio-pci.c
@@ -43,6 +43,53 @@
 #include "system/replay.h"
 #include "trace.h"
 
+/*
+ * main_system_bus
+ * ----------------------------------
+ *        |
+ *        |
+ *   i440FX-pcihost
+ *        |
+ *        |
+ *  pci.0 |
+ * -------------------------------------------------
+ *         |                |                    |
+ *         |                |                    |
+ *  vhost-scsi-pci   virtio-balloon-pci   virtio-crypto-pci
+ *                          |
+ *                          |
+ *       per-device virtio-bus |
+ *         -----------------------------------
+ *                   virtio-balloon-device
+ *
+ *
+ *
+ *                              main_system_bus
+ * --------------------------------------------------------------
+ *                                     |
+ *                              i440FX-pci-host
+ *                                     |
+ *                                     |
+ *                            pci.0    |
+ * ----------------------------------------------------------------------------
+ *   |            |              |                 |                     |
+ *   |            |              |                 |                     |
+ * i440FX        PIIX3         e1000            piix3-ide             PIIX4_PM
+ *                |
+ *                |
+ *         isa.0  |
+ *     -------------------------------------------------
+ *         |            |           |              |
+ *         |            |           |              |
+ *     kvm-i8259    kvm-i8259    isa-fdc        kvm-pit
+ *                                  |
+ *                                  |
+ *                    floppy-bus.0  |
+ *                          -------------------
+ *                                  |
+ *                               floppy
+ */
+
 #define VIRTIO_PCI_REGION_SIZE(dev)     VIRTIO_PCI_CONFIG_OFF(msix_present(dev))
 
 #undef VIRTIO_PCI_CONFIG
@@ -442,6 +489,13 @@ static void virtio_ioport_write(void *opaque, uint32_t addr, uint32_t val)
     case VIRTIO_PCI_QUEUE_PFN:
         pa = (hwaddr)val << VIRTIO_PCI_QUEUE_ADDR_SHIFT;
         if (pa == 0) {
+            /*
+	     * 在以下使用virtio_pci_reset():
+             *   - hw/virtio/virtio-pci.c|445| <<virtio_ioport_write(VIRTIO_PCI_QUEUE_PFN)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|477| <<virtio_ioport_write(VIRTIO_PCI_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|1691| <<virtio_pci_common_write(VIRTIO_PCI_COMMON_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|2421| <<virtio_pci_bus_reset_hold>> virtio_pci_reset(qdev);
+	     */
             virtio_pci_reset(DEVICE(proxy));
         }
         else
@@ -474,6 +528,13 @@ static void virtio_ioport_write(void *opaque, uint32_t addr, uint32_t val)
         }
 
         if (vdev->status == 0) {
+            /*
+	     * 在以下使用virtio_pci_reset():
+	     *   - hw/virtio/virtio-pci.c|445| <<virtio_ioport_write(VIRTIO_PCI_QUEUE_PFN)>> virtio_pci_reset(DEVICE(proxy));
+	     *   - hw/virtio/virtio-pci.c|477| <<virtio_ioport_write(VIRTIO_PCI_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+	     *   - hw/virtio/virtio-pci.c|1691| <<virtio_pci_common_write(VIRTIO_PCI_COMMON_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+	     *   - hw/virtio/virtio-pci.c|2421| <<virtio_pci_bus_reset_hold>> virtio_pci_reset(qdev);
+	     */
             virtio_pci_reset(DEVICE(proxy));
         }
 
@@ -1688,6 +1749,13 @@ static void virtio_pci_common_write(void *opaque, hwaddr addr,
         }
 
         if (vdev->status == 0) {
+            /*
+	     * 在以下使用virtio_pci_reset():
+             *   - hw/virtio/virtio-pci.c|445| <<virtio_ioport_write(VIRTIO_PCI_QUEUE_PFN)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|477| <<virtio_ioport_write(VIRTIO_PCI_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|1691| <<virtio_pci_common_write(VIRTIO_PCI_COMMON_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|2421| <<virtio_pci_bus_reset_hold>> virtio_pci_reset(qdev);
+	     */
             virtio_pci_reset(DEVICE(proxy));
         }
 
@@ -2370,6 +2438,13 @@ static void virtio_pci_exit(PCIDevice *pci_dev)
     }
 }
 
+/*
+ * 在以下使用virtio_pci_reset():
+ *   - hw/virtio/virtio-pci.c|445| <<virtio_ioport_write(VIRTIO_PCI_QUEUE_PFN)>> virtio_pci_reset(DEVICE(proxy));
+ *   - hw/virtio/virtio-pci.c|477| <<virtio_ioport_write(VIRTIO_PCI_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+ *   - hw/virtio/virtio-pci.c|1691| <<virtio_pci_common_write(VIRTIO_PCI_COMMON_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+ *   - hw/virtio/virtio-pci.c|2421| <<virtio_pci_bus_reset_hold>> virtio_pci_reset(qdev);
+ */
 static void virtio_pci_reset(DeviceState *qdev)
 {
     VirtIOPCIProxy *proxy = VIRTIO_PCI(qdev);
@@ -2409,6 +2484,10 @@ static bool virtio_pci_no_soft_reset(PCIDevice *dev)
            (pmcsr & PCI_PM_CTRL_STATE_MASK) == 3;
 }
 
+/*
+ * 在以下使用virtio_pci_bus_reset_hold():
+ *   - hw/virtio/virtio-pci.c|2507| <<virtio_pci_class_init>> rc->phases.hold = virtio_pci_bus_reset_hold;
+ */
 static void virtio_pci_bus_reset_hold(Object *obj, ResetType type)
 {
     PCIDevice *dev = PCI_DEVICE(obj);
@@ -2418,6 +2497,13 @@ static void virtio_pci_bus_reset_hold(Object *obj, ResetType type)
         return;
     }
 
+    /*
+     * 在以下使用virtio_pci_reset():
+     *   - hw/virtio/virtio-pci.c|445| <<virtio_ioport_write(VIRTIO_PCI_QUEUE_PFN)>> virtio_pci_reset(DEVICE(proxy));
+     *   - hw/virtio/virtio-pci.c|477| <<virtio_ioport_write(VIRTIO_PCI_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+     *   - hw/virtio/virtio-pci.c|1691| <<virtio_pci_common_write(VIRTIO_PCI_COMMON_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+     *   - hw/virtio/virtio-pci.c|2421| <<virtio_pci_bus_reset_hold>> virtio_pci_reset(qdev);
+     */
     virtio_pci_reset(qdev);
 
     if (pci_is_express(dev)) {
diff --git a/hw/xen/xen-hvm-common.c b/hw/xen/xen-hvm-common.c
index b40ae0b3a..93c5ebb1b 100644
--- a/hw/xen/xen-hvm-common.c
+++ b/hw/xen/xen-hvm-common.c
@@ -611,6 +611,14 @@ static void cpu_handle_ioreq(void *opaque)
             }
             request = qemu_reset_requested_get();
             if (request) {
+                /*
+		 * 在以下使用qemu_system_reset():
+                 *   - hw/core/machine.c|1825| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+                 *   - hw/xen/xen-hvm-common.c|614| <<cpu_handle_ioreq>> qemu_system_reset(request);
+                 *   - migration/savevm.c|3463| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+                 *   - system/runstate.c|982| <<main_loop_should_exit>> qemu_system_reset(request);
+                 *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+		 */
                 qemu_system_reset(request);
                 destroy_hvm_domain(true);
             }
diff --git a/include/accel/accel-cpu-ops.h b/include/accel/accel-cpu-ops.h
index 067476491..6a571df15 100644
--- a/include/accel/accel-cpu-ops.h
+++ b/include/accel/accel-cpu-ops.h
@@ -37,6 +37,21 @@ struct AccelOpsClass {
     bool (*cpus_are_resettable)(void);
     void (*cpu_reset_hold)(CPUState *cpu);
 
+    /*
+     * 在以下使用AccelOpsClass->create_vcpu_thread:
+     *   - accel/hvf/hvf-accel-ops.c|375| <<hvf_accel_ops_class_init>> ops->create_vcpu_thread = hvf_start_vcpu_thread;
+     *   - accel/kvm/kvm-accel-ops.c|98| <<kvm_accel_ops_class_init>> ops->create_vcpu_thread = kvm_start_vcpu_thread;
+     *   - accel/mshv/mshv-all.c|708| <<mshv_accel_ops_class_init>> ops->create_vcpu_thread = mshv_start_vcpu_thread;
+     *   - accel/qtest/qtest.c|68| <<qtest_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+     *   - accel/tcg/tcg-accel-ops.c|206| <<tcg_accel_ops_init>> ops->create_vcpu_thread = mttcg_start_vcpu_thread;
+     *   - accel/tcg/tcg-accel-ops.c|210| <<tcg_accel_ops_init>> ops->create_vcpu_thread = rr_start_vcpu_thread;
+     *   - accel/xen/xen-all.c|156| <<xen_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+     *   - system/cpus.c|771| <<cpus_register_accel>> assert(ops->create_vcpu_thread != NULL);
+     *   - system/cpus.c|801| <<qemu_init_vcpu>> g_assert(cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL);
+     *   - system/cpus.c|802| <<qemu_init_vcpu>> cpus_accel->create_vcpu_thread(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|86| <<nvmm_accel_ops_class_init>> ops->create_vcpu_thread = nvmm_start_vcpu_thread;
+     *   - target/i386/whpx/whpx-accel-ops.c|88| <<whpx_accel_ops_class_init>> ops->create_vcpu_thread = whpx_start_vcpu_thread;
+     */
     void (*create_vcpu_thread)(CPUState *cpu); /* MANDATORY NON-NULL */
     void (*kick_vcpu_thread)(CPUState *cpu);
     bool (*cpu_thread_is_idle)(CPUState *cpu);
@@ -49,7 +64,27 @@ struct AccelOpsClass {
      * Request to synchronize QEMU vCPU registers to the hardware accelerator
      * (QEMU is the reference).
      */
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_reset():
+     *   - accel/hvf/hvf-accel-ops.c|379| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - accel/mshv/mshv-all.c|710| <<mshv_accel_ops_class_init>> ops->synchronize_post_reset = mshv_cpu_synchronize_post_reset;
+     *   - system/cpus.c|179| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - system/cpus.c|180| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|90| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|93| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     void (*synchronize_post_reset)(CPUState *cpu);
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|380| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - accel/mshv/mshv-all.c|709| <<mshv_accel_ops_class_init>> ops->synchronize_post_init = mshv_cpu_synchronize_post_init;
+     *   - system/cpus.c|223| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|224| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|91| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|94| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     void (*synchronize_post_init)(CPUState *cpu);
     /**
      * synchronize_state:
@@ -59,6 +94,16 @@ struct AccelOpsClass {
      * Request to synchronize QEMU vCPU registers from the hardware accelerator
      * (the hardware accelerator is the reference).
      */
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|113| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - accel/mshv/mshv-all.c|711| <<mshv_accel_ops_class_init>> ops->synchronize_state = mshv_cpu_synchronize;
+     *   - system/cpus.c|183| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|184| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     void (*synchronize_state)(CPUState *cpu);
     void (*synchronize_pre_loadvm)(CPUState *cpu);
 
diff --git a/include/hw/i386/x86.h b/include/hw/i386/x86.h
index 8755cad50..30ceb73de 100644
--- a/include/hw/i386/x86.h
+++ b/include/hw/i386/x86.h
@@ -85,6 +85,15 @@ struct X86MachineState {
      * Address space used by IOAPIC device. All IOAPIC interrupts
      * will be translated to MSI messages in the address space.
      */
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     AddressSpace *ioapic_as;
 
     /*
diff --git a/include/hw/virtio/virtio-balloon.h b/include/hw/virtio/virtio-balloon.h
index 0456c211c..9b0f016f9 100644
--- a/include/hw/virtio/virtio-balloon.h
+++ b/include/hw/virtio/virtio-balloon.h
@@ -44,20 +44,105 @@ enum virtio_balloon_free_page_hint_status {
 struct VirtIOBalloon {
     VirtIODevice parent_obj;
     VirtQueue *ivq, *dvq, *svq, *free_page_vq, *reporting_vq;
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     uint32_t free_page_hint_status;
     uint32_t num_pages;
     uint32_t actual;
+    /*
+     * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+     *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+     *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+     *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     */
     uint32_t free_page_hint_cmd_id;
     uint64_t stats[VIRTIO_BALLOON_S_NR];
+    /*
+     * 在以下使用VirtIOBalloon->stats_vq_elem:
+     *   - hw/virtio/virtio-balloon.c|344| <<balloon_stats_poll_cb>> if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|364| <<balloon_stats_poll_cb>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|365| <<balloon_stats_poll_cb>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|695| <<virtio_balloon_receive_stats>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|699| <<virtio_balloon_receive_stats>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|702| <<virtio_balloon_receive_stats>> s->stats_vq_elem = elem;
+     *   - hw/virtio/virtio-balloon.c|1582| <<virtio_balloon_device_reset>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|1583| <<virtio_balloon_device_reset>> virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|1584| <<virtio_balloon_device_reset>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|1585| <<virtio_balloon_device_reset>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|1595| <<virtio_balloon_set_status>> if (!s->stats_vq_elem && vdev->vm_running &&
+     */
     VirtQueueElement *stats_vq_elem;
     size_t stats_vq_offset;
+    /*
+     * 在以下使用VirtIOBalloon->stats_timer:
+     *   - hw/virtio/virtio-balloon.c|292| <<balloon_stats_destroy_timer>> timer_free(s->stats_timer);
+     *   - hw/virtio/virtio-balloon.c|293| <<balloon_stats_destroy_timer>> s->stats_timer = NULL;
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_change_timer>> timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000);
+     *   - hw/virtio/virtio-balloon.c|471| <<balloon_stats_set_poll_interval>> g_assert(s->stats_timer == NULL);
+     *   - hw/virtio/virtio-balloon.c|472| <<balloon_stats_set_poll_interval>> s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
+     */
     QEMUTimer *stats_timer;
     IOThread *iothread;
+    /*
+     * 在以下使用VirtIOBalloon->free_page_bh:
+     *   - hw/virtio/virtio-balloon.c|582| <<virtio_balloon_handle_free_page_vq>> qemu_bh_schedule(s->free_page_bh);
+     *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+     *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+     *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+     *   - hw/virtio/virtio-balloon.c|1043| <<virtio_balloon_device_unrealize>> if (s->free_page_bh) {
+     *   - hw/virtio/virtio-balloon.c|1044| <<virtio_balloon_device_unrealize>> qemu_bh_delete(s->free_page_bh);
+     *
+     * 处理的函数: virtio_ballloon_get_free_page_hints()
+     */
     QEMUBH *free_page_bh;
     /*
      * Lock to synchronize threads to access the free page reporting related
      * fields (e.g. free_page_hint_status).
      */
+    /*
+     * 在以下使用VirtIOBalloon->free_page_lock:
+     *   - hw/virtio/virtio-balloon.c|535| <<get_free_page_hints>> qemu_cond_wait(&dev->free_page_cond, &dev->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|587| <<virtio_ballloon_get_free_page_hints>> qemu_mutex_lock(&dev->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|590| <<virtio_ballloon_get_free_page_hints>> qemu_mutex_unlock(&dev->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|613| <<virtio_balloon_free_page_start>> qemu_mutex_lock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|622| <<virtio_balloon_free_page_start>> qemu_mutex_unlock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|637| <<virtio_balloon_free_page_stop>> qemu_mutex_lock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|643| <<virtio_balloon_free_page_stop>> qemu_mutex_unlock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|654| <<virtio_balloon_free_page_done>> qemu_mutex_lock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_balloon_free_page_done>> qemu_mutex_unlock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|1029| <<virtio_balloon_set_status>> qemu_mutex_lock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|1032| <<virtio_balloon_set_status>> qemu_mutex_unlock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|1037| <<virtio_balloon_set_status>> qemu_mutex_lock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|1039| <<virtio_balloon_set_status>> qemu_mutex_unlock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|1070| <<virtio_balloon_instance_init>> qemu_mutex_init(&s->free_page_lock);
+     */
     QemuMutex free_page_lock;
     QemuCond  free_page_cond;
     /*
@@ -65,8 +150,34 @@ struct VirtIOBalloon {
      * stopped.
      */
     bool block_iothread;
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_notify:
+     *   - hw/virtio/virtio-balloon.c|961| <<virtio_balloon_free_page_hint_notify>> VirtIOBalloon *dev = container_of(n, VirtIOBalloon, free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1367| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1491| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+     */
     NotifierWithReturn free_page_hint_notify;
+    /*
+     * 在以下使用VirtIOBalloon->stats_last_update:
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_get_all>> if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
+     *   - hw/virtio/virtio-balloon.c|608| <<virtio_balloon_receive_stats>> s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
+     *   - hw/virtio/virtio-balloon.c|1332| <<virtio_balloon_device_realize>> s->stats_last_update = 0;
+     *   - hw/virtio/virtio-balloon.c|1466| <<virtio_balloon_reset_enter>> s->stats_last_update = 0;
+     */
     int64_t stats_last_update;
+    /*
+     * 在以下使用VirtIOBalloon->stats_poll_interval:
+     *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+     *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+     *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+     *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+     *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     */
     int64_t stats_poll_interval;
     uint32_t host_features;
 
diff --git a/include/migration/register.h b/include/migration/register.h
index ae79794cd..cee0354f4 100644
--- a/include/migration/register.h
+++ b/include/migration/register.h
@@ -177,6 +177,16 @@ typedef struct SaveVMHandlers {
      *         1 that there is no more data to send and
      *         negative to indicate an error.
      */
+    /*
+     * 在以下使用SaveVMHandlers->save_live_iterate:
+     *   - hw/ppc/spapr.c|2572| <<global>> .save_live_iterate = htab_save_iterate,
+     *   - hw/s390x/s390-stattrib.c|340| <<global>> .save_live_iterate = cmma_save_iterate,
+     *   - hw/vfio/migration.c|834| <<global>> .save_live_iterate = vfio_save_iterate,
+     *   - migration/block-dirty-bitmap.c|1255| <<global>> .save_live_iterate = dirty_bitmap_save_iterate,
+     *   - migration/ram.c|4695| <<global>> .save_live_iterate = ram_save_iterate,
+     *   - migration/savevm.c|1448| <<qemu_savevm_state_iterate>> if (!se->ops || !se->ops->save_live_iterate) {
+     *   - migration/savevm.c|1476| <<qemu_savevm_state_iterate>> ret = se->ops->save_live_iterate(f, se->opaque);
+     */
     int (*save_live_iterate)(QEMUFile *f, void *opaque);
 
     /* This runs outside the BQL!  */
diff --git a/migration/block-dirty-bitmap.c b/migration/block-dirty-bitmap.c
index a061aad81..283d1dcac 100644
--- a/migration/block-dirty-bitmap.c
+++ b/migration/block-dirty-bitmap.c
@@ -727,6 +727,16 @@ static void dirty_bitmap_save_cleanup(void *opaque)
     dirty_bitmap_do_save_cleanup(s);
 }
 
+/*
+ * 在以下使用SaveVMHandlers->save_live_iterate:
+ *   - hw/ppc/spapr.c|2572| <<global>> .save_live_iterate = htab_save_iterate,
+ *   - hw/s390x/s390-stattrib.c|340| <<global>> .save_live_iterate = cmma_save_iterate,
+ *   - hw/vfio/migration.c|834| <<global>> .save_live_iterate = vfio_save_iterate,
+ *   - migration/block-dirty-bitmap.c|1255| <<global>> .save_live_iterate = dirty_bitmap_save_iterate,
+ *   - migration/ram.c|4695| <<global>> .save_live_iterate = ram_save_iterate,
+ *   - migration/savevm.c|1448| <<qemu_savevm_state_iterate>> if (!se->ops || !se->ops->save_live_iterate) {
+ *   - migration/savevm.c|1476| <<qemu_savevm_state_iterate>> ret = se->ops->save_live_iterate(f, se->opaque);
+ */
 static int dirty_bitmap_save_iterate(QEMUFile *f, void *opaque)
 {
     DBMSaveState *s = &((DBMState *)opaque)->save;
diff --git a/migration/channel.c b/migration/channel.c
index 462cc183e..34f39a8a8 100644
--- a/migration/channel.c
+++ b/migration/channel.c
@@ -30,6 +30,14 @@
  *
  * @ioc: Channel to which we are connecting
  */
+/*
+ * 在以下使用migration_channel_process_incoming():
+ *   - migration/exec.c|66| <<exec_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/fd.c|81| <<fd_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/file.c|132| <<file_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+ *   - migration/socket.c|132| <<socket_accept_incoming_migration>> migration_channel_process_incoming(QIO_CHANNEL(cioc));
+ *   - migration/tls.c|69| <<migration_tls_incoming_handshake>> migration_channel_process_incoming(ioc);
+ */
 void migration_channel_process_incoming(QIOChannel *ioc)
 {
     MigrationState *s = migrate_get_current();
diff --git a/migration/colo.c b/migration/colo.c
index db783f6fa..fc6c36b77 100644
--- a/migration/colo.c
+++ b/migration/colo.c
@@ -471,6 +471,9 @@ static int colo_do_checkpoint_transaction(MigrationState *s,
      * TODO: We may need a timeout mechanism to prevent COLO process
      * to be blocked here.
      */
+    /*
+     * 只在这里调用
+     */
     qemu_savevm_live_state(s->to_dst_file);
 
     qemu_fflush(fb);
@@ -512,6 +515,24 @@ static int colo_do_checkpoint_transaction(MigrationState *s,
     ret = 0;
 
     bql_lock();
+    /*
+     * 在以下使用vm_start():
+     *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+     *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+     *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+     *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+     *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+     *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+     *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+     *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+     *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+     *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+     *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+     *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+     *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+     *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+     *   - system/cpus.c|899| <<vm_resume>> vm_start();
+     */
     vm_start();
     bql_unlock();
     trace_colo_vm_state_change("stop", "run");
@@ -571,6 +592,24 @@ static void colo_process_checkpoint(MigrationState *s)
         goto out;
     }
 
+    /*
+     * 在以下使用vm_start():
+     *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+     *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+     *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+     *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+     *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+     *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+     *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+     *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+     *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+     *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+     *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+     *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+     *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+     *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+     *   - system/cpus.c|899| <<vm_resume>> vm_start();
+     */
     vm_start();
     bql_unlock();
     trace_colo_vm_state_change("stop", "run");
@@ -686,6 +725,14 @@ static void colo_incoming_process_checkpoint(MigrationIncomingState *mis,
 
     bql_lock();
     cpu_synchronize_all_states();
+    /*
+     * 在以下使用qemu_loadvm_state_main():
+     *   - migration/colo.c|728| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis, errp);
+     *   - migration/postcopy-ram.c|2134| <<postcopy_listen_thread>> load_res = qemu_loadvm_state_main(f, mis, &local_err);
+     *   - migration/savevm.c|2473| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis, errp);
+     *   - migration/savevm.c|3226| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+     *   - migration/savevm.c|3318| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+     */
     ret = qemu_loadvm_state_main(mis->from_src_file, mis, errp);
     bql_unlock();
 
@@ -762,6 +809,24 @@ static void colo_incoming_process_checkpoint(MigrationIncomingState *mis,
     }
 
     vmstate_loading = false;
+    /*
+     * 在以下使用vm_start():
+     *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+     *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+     *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+     *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+     *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+     *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+     *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+     *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+     *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+     *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+     *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+     *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+     *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+     *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+     *   - system/cpus.c|899| <<vm_resume>> vm_start();
+     */
     vm_start();
     bql_unlock();
     trace_colo_vm_state_change("stop", "run");
@@ -870,6 +935,24 @@ static void *colo_process_incoming_thread(void *opaque)
         bql_unlock();
         goto out;
     }
+    /*
+     * 在以下使用vm_start():
+     *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+     *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+     *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+     *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+     *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+     *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+     *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+     *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+     *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+     *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+     *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+     *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+     *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+     *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+     *   - system/cpus.c|899| <<vm_resume>> vm_start();
+     */
     vm_start();
     bql_unlock();
     trace_colo_vm_state_change("stop", "run");
diff --git a/migration/cpr-exec.c b/migration/cpr-exec.c
index 0b8344a86..32f5d20bc 100644
--- a/migration/cpr-exec.c
+++ b/migration/cpr-exec.c
@@ -172,6 +172,24 @@ static void cpr_exec_cb(void *opaque)
     }
 
     if (runstate_is_live(s->vm_old_state)) {
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+         *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|899| <<vm_resume>> vm_start();
+	 */
         vm_start();
     }
 }
diff --git a/migration/exec.c b/migration/exec.c
index 20e6cccf8..68d4c534c 100644
--- a/migration/exec.c
+++ b/migration/exec.c
@@ -63,6 +63,14 @@ static gboolean exec_accept_incoming_migration(QIOChannel *ioc,
                                                GIOCondition condition,
                                                gpointer opaque)
 {
+    /*
+     * 在以下使用migration_channel_process_incoming():
+     *   - migration/exec.c|66| <<exec_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/fd.c|81| <<fd_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/file.c|132| <<file_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/socket.c|132| <<socket_accept_incoming_migration>> migration_channel_process_incoming(QIO_CHANNEL(cioc));
+     *   - migration/tls.c|69| <<migration_tls_incoming_handshake>> migration_channel_process_incoming(ioc);
+     */
     migration_channel_process_incoming(ioc);
     object_unref(OBJECT(ioc));
     return G_SOURCE_REMOVE;
diff --git a/migration/fd.c b/migration/fd.c
index 9bf9be6ac..8a0608f57 100644
--- a/migration/fd.c
+++ b/migration/fd.c
@@ -78,6 +78,14 @@ static gboolean fd_accept_incoming_migration(QIOChannel *ioc,
                                              GIOCondition condition,
                                              gpointer opaque)
 {
+    /*
+     * 在以下使用migration_channel_process_incoming():
+     *   - migration/exec.c|66| <<exec_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/fd.c|81| <<fd_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/file.c|132| <<file_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/socket.c|132| <<socket_accept_incoming_migration>> migration_channel_process_incoming(QIO_CHANNEL(cioc));
+     *   - migration/tls.c|69| <<migration_tls_incoming_handshake>> migration_channel_process_incoming(ioc);
+     */
     migration_channel_process_incoming(ioc);
     object_unref(OBJECT(ioc));
     return G_SOURCE_REMOVE;
diff --git a/migration/file.c b/migration/file.c
index bb8031e3c..6d5a48ce4 100644
--- a/migration/file.c
+++ b/migration/file.c
@@ -129,6 +129,14 @@ static gboolean file_accept_incoming_migration(QIOChannel *ioc,
                                                GIOCondition condition,
                                                gpointer opaque)
 {
+    /*
+     * 在以下使用migration_channel_process_incoming():
+     *   - migration/exec.c|66| <<exec_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/fd.c|81| <<fd_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/file.c|132| <<file_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/socket.c|132| <<socket_accept_incoming_migration>> migration_channel_process_incoming(QIO_CHANNEL(cioc));
+     *   - migration/tls.c|69| <<migration_tls_incoming_handshake>> migration_channel_process_incoming(ioc);
+     */
     migration_channel_process_incoming(ioc);
     object_unref(OBJECT(ioc));
     return G_SOURCE_REMOVE;
diff --git a/migration/global_state.c b/migration/global_state.c
index c1f90fce0..f3415164a 100644
--- a/migration/global_state.c
+++ b/migration/global_state.c
@@ -50,6 +50,11 @@ static void global_state_do_store(RunState state)
     memset(global_state.unused, 0, sizeof(global_state.unused));
 }
 
+/*
+ * 在以下使用global_state_store():
+ *    - migration/migration.c|343| <<migration_stop_vm>> global_state_store();
+ *    - migration/savevm.c|3274| <<save_snapshot>> global_state_store();
+ */
 void global_state_store(void)
 {
     global_state_do_store(runstate_get());
diff --git a/migration/migration.c b/migration/migration.c
index b316ee01a..fb7fbd662 100644
--- a/migration/migration.c
+++ b/migration/migration.c
@@ -109,6 +109,10 @@ static bool close_return_path_on_source(MigrationState *s);
 static void migration_completion_end(MigrationState *s);
 static void migrate_hup_delete(MigrationState *s);
 
+/*
+ * 在以下使用migration_downtime_start():
+ *   - migration/migration.c|340| <<migration_stop_vm>> migration_downtime_start(s);
+ */
 static void migration_downtime_start(MigrationState *s)
 {
     trace_vmstate_downtime_checkpoint("src-downtime-start");
@@ -283,15 +287,82 @@ static gint page_request_addr_cmp(gconstpointer ap, gconstpointer bp)
     return (a > b) - (a < b);
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用migration_stop_vm():
+ *   - migration/migration.c|2849| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+ *   - migration/migration.c|3152| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+ *   - migration/migration.c|4127| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+ *   - migration/migration.c|4271| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+ */
 static int migration_stop_vm(MigrationState *s, RunState state)
 {
     int ret;
 
+    /*
+     * 只在这里调用
+     */
     migration_downtime_start(s);
 
     s->vm_old_state = runstate_get();
     global_state_store();
 
+    /*
+     * 在以下使用vm_stop_force_state():
+     *   - migration/colo.c|216| <<colo_do_failover>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/colo.c|432| <<colo_do_checkpoint_transaction>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/colo.c|668| <<colo_incoming_process_checkpoint>> vm_stop_force_state(RUN_STATE_COLO);
+     *   - migration/migration.c|345| <<migration_stop_vm>> ret = vm_stop_force_state(state);
+     */
     ret = vm_stop_force_state(state);
 
     trace_vmstate_downtime_checkpoint("src-vm-stopped");
@@ -345,6 +416,10 @@ typedef struct {
     void *opaque;
 } MigrationBH;
 
+/*
+ * 在以下使用migration_bh_dispatch_bh():
+ *   - migration/migration.c|439| <<migration_bh_schedule>> QEMUBH *bh = qemu_bh_new(migration_bh_dispatch_bh, migbh);
+ */
 static void migration_bh_dispatch_bh(void *opaque)
 {
     MigrationState *s = migrate_get_current();
@@ -361,6 +436,15 @@ static void migration_bh_dispatch_bh(void *opaque)
     g_free(migbh);
 }
 
+/*
+ * 在以下使用migration_bh_schedule():
+ *   - migration/migration.c|1054| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+ *   - migration/migration.c|3953| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+ *   - migration/migration.c|3981| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+ *   - migration/migration.c|4333| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+ *   - migration/postcopy-ram.c|2190| <<postcopy_listen_thread>> migration_bh_schedule(postcopy_listen_thread_bh, NULL);
+ *   - migration/savevm.c|2271| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+ */
 void migration_bh_schedule(QEMUBHFunc *cb, void *opaque)
 {
     MigrationState *s = migrate_get_current();
@@ -500,6 +584,10 @@ void migration_incoming_state_destroy(void)
     yank_unregister_instance(MIGRATION_YANK_INSTANCE);
 }
 
+/*
+ * 在以下使用migrate_generate_event():
+ *   - migration/migration.c|1557| <<migrate_set_state>> migrate_generate_event(new_state);
+ */
 static void migrate_generate_event(MigrationStatus new_state)
 {
     if (migrate_events()) {
@@ -811,6 +899,32 @@ static void qemu_start_incoming_migration(const char *uri, bool has_channels,
     cpr_state_close();
 }
 
+/*
+ * 这是迁移在Target上的.
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x5555582b37e0) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用process_incoming_migration_bh():
+ *   - migration/migration.c|1054| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+ */
 static void process_incoming_migration_bh(void *opaque)
 {
     MigrationIncomingState *mis = opaque;
@@ -844,15 +958,83 @@ static void process_incoming_migration_bh(void *opaque)
              * metadata.  If error, don't restart the VM yet.
              */
             if (migration_block_activate(NULL)) {
+                /*
+		 * 在以下使用vm_start():
+                 *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+                 *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+		 *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+                 *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+                 *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+                 *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+                 *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+                 *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+                 *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+                 *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+                 *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+                 *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+                 *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+                 *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+                 *   - system/cpus.c|899| <<vm_resume>> vm_start();
+		 */
                 vm_start();
             }
         } else {
+            /*
+	     * 在以下使用runstate_set():
+             *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+             *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+             *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+             *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+             *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+             *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+             *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+             *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+             *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+             *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+             *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+             *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+             *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	     */
             runstate_set(RUN_STATE_PAUSED);
         }
     } else if (migration_incoming_colo_enabled()) {
         migration_incoming_disable_colo();
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+         *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|899| <<vm_resume>> vm_start();
+	 */
         vm_start();
     } else {
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         runstate_set(global_state_get_runstate());
     }
     trace_vmstate_downtime_checkpoint("dst-precopy-bh-vm-started");
@@ -866,6 +1048,31 @@ static void process_incoming_migration_bh(void *opaque)
     migration_incoming_state_destroy();
 }
 
+/*
+ * (gdb) bt
+ * #0  ram_load (f=0x5555578d3200, opaque=0x555557524aa0 <ram_state>, version_id=4) at ../migration/ram.c:4327
+ * #1  0x0000555555c79a9d in vmstate_load (f=0x5555578d3200, se=0x5555575e3220) at ../migration/savevm.c:970
+ * #2  0x0000555555c7da30 in qemu_loadvm_section_part_end (f=0x5555578d3200, type=2 '\002') at ../migration/savevm.c:2796
+ * #3  0x0000555555c7e40d in qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3056
+ * #4  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #5  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #6  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #7  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #8  0x00007fffffffc7e0 in ?? ()
+ * #9  0x0000000000000000 in ?? ()
+ *
+ *
+ * (gdb) bt
+ * #0  process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:873
+ * #1  0x0000555556174e10 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #2  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #3  0x00007fffffffc7e0 in ?? ()
+ * #4  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用process_incoming_migration_co():
+ *   - migration/migration.c|1093| <<migration_incoming_process>> Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
+ */
 static void coroutine_fn
 process_incoming_migration_co(void *opaque)
 {
@@ -882,6 +1089,12 @@ process_incoming_migration_co(void *opaque)
                       MIGRATION_STATUS_ACTIVE);
 
     mis->loadvm_co = qemu_coroutine_self();
+    /*
+     * 在以下使用qemu_loadvm_state():
+     *   - migration/migration.c|1071| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file, &local_err);
+     *   - migration/savevm.c|3504| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f, errp);
+     *   - migration/savevm.c|3590| <<load_snapshot>> ret = qemu_loadvm_state(f, errp);
+     */
     ret = qemu_loadvm_state(mis->from_src_file, &local_err);
     mis->loadvm_co = NULL;
 
@@ -908,6 +1121,15 @@ process_incoming_migration_co(void *opaque)
         colo_incoming_co();
     }
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|1054| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3953| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3981| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4333| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/postcopy-ram.c|2190| <<postcopy_listen_thread>> migration_bh_schedule(postcopy_listen_thread_bh, NULL);
+     *   - migration/savevm.c|2271| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(process_incoming_migration_bh, mis);
     goto out;
 
@@ -945,6 +1167,11 @@ static void migration_incoming_setup(QEMUFile *f)
     qemu_file_set_blocking(f, false, &error_abort);
 }
 
+/*
+ * 在以下使用migration_incoming_process():
+ *   - migration/migration.c|1136| <<migration_fd_process_incoming>> migration_incoming_process();
+ *   - migration/migration.c|1239| <<migration_ioc_process_incoming>> migration_incoming_process();
+ */
 void migration_incoming_process(void)
 {
     Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
@@ -984,6 +1211,10 @@ static bool postcopy_try_recover(void)
     return false;
 }
 
+/*
+ * 在以下使用migration_fd_process_incoming():
+ *   - migration/rdma.c|3886| <<rdma_accept_incoming_migration>> migration_fd_process_incoming(f);
+ */
 void migration_fd_process_incoming(QEMUFile *f)
 {
     migration_incoming_setup(f);
@@ -1009,6 +1240,10 @@ static bool migration_has_main_and_multifd_channels(void)
     return true;
 }
 
+/*
+ * 在以下使用migration_ioc_process_incoming():
+ *   - migration/channel.c|46| <<migration_channel_process_incoming>> migration_ioc_process_incoming(ioc, &local_err);
+ */
 void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -1630,6 +1865,15 @@ void migration_cancel(void)
         }
         /* If the migration is paused, kick it out of the pause */
         if (old_state == MIGRATION_STATUS_PRE_SWITCHOVER) {
+            /*
+	     * 在以下使用MigrationState->pause_event:
+             *   - migration/migration.c|1719| <<migration_cancel>> qemu_event_set(&s->pause_event);
+             *   - migration/migration.c|2456| <<qmp_migrate_continue>> qemu_event_set(&s->pause_event);
+             *   - migration/migration.c|3045| <<migration_switchover_prepare>> qemu_event_reset(&s->pause_event);
+             *   - migration/migration.c|3051| <<migration_switchover_prepare>> qemu_event_wait(&s->pause_event);
+             *   - migration/migration.c|4322| <<migration_instance_finalize>> qemu_event_destroy(&ms->pause_event);
+             *   - migration/migration.c|4338| <<migration_instance_init>> qemu_event_init(&ms->pause_event, false);
+	     */
             qemu_event_set(&s->pause_event);
         }
         migrate_set_state(&s->state, old_state, MIGRATION_STATUS_CANCELLING);
@@ -2359,6 +2603,10 @@ void qmp_migrate_cancel(Error **errp)
     migration_cancel();
 }
 
+/*
+ * 在以下使用qmp_migrate_continue():
+ *   - migration/migration-hmp-cmds.c|506| <<hmp_migrate_continue>> qmp_migrate_continue(val, &err);
+ */
 void qmp_migrate_continue(MigrationStatus state, Error **errp)
 {
     MigrationState *s = migrate_get_current();
@@ -2367,6 +2615,15 @@ void qmp_migrate_continue(MigrationStatus state, Error **errp)
                    MigrationStatus_str(s->state));
         return;
     }
+    /*
+     * 在以下使用MigrationState->pause_event:
+     *   - migration/migration.c|1719| <<migration_cancel>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|2456| <<qmp_migrate_continue>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|3045| <<migration_switchover_prepare>> qemu_event_reset(&s->pause_event);
+     *   - migration/migration.c|3051| <<migration_switchover_prepare>> qemu_event_wait(&s->pause_event);
+     *   - migration/migration.c|4322| <<migration_instance_finalize>> qemu_event_destroy(&ms->pause_event);
+     *   - migration/migration.c|4338| <<migration_instance_init>> qemu_event_init(&ms->pause_event, false);
+     */
     qemu_event_set(&s->pause_event);
 }
 
@@ -2760,12 +3017,24 @@ static int postcopy_start(MigrationState *ms, Error **errp)
     bql_lock();
     trace_postcopy_start_set_run();
 
+    /*
+     * 在以下使用migration_stop_vm():
+     *   - migration/migration.c|2849| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|3152| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|4127| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+     *   - migration/migration.c|4271| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     */
     ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
     if (ret < 0) {
         error_setg_errno(errp, -ret, "%s: Failed to stop the VM", __func__);
         goto fail;
     }
 
+    /*
+     * 在以下使用migration_switchover_start():
+     *   - migration/migration.c|2855| <<postcopy_start>> if (!migration_switchover_start(ms, errp)) {
+     *   - migration/migration.c|3158| <<migration_completion_precopy>> if (!migration_switchover_start(s, NULL)) {
+     */
     if (!migration_switchover_start(ms, errp)) {
         goto fail;
     }
@@ -2774,6 +3043,11 @@ static int postcopy_start(MigrationState *ms, Error **errp)
      * Cause any non-postcopiable, but iterative devices to
      * send out their final data.
      */
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy_iterable():
+     *   - migration/migration.c|2863| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_iterable(ms->to_dst_file, true);
+     *   - migration/savevm.c|1729| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_iterable(f, false);
+     */
     ret = qemu_savevm_state_complete_precopy_iterable(ms->to_dst_file, true);
     if (ret) {
         error_setg(errp, "Postcopy save non-postcopiable iterables failed");
@@ -2817,6 +3091,12 @@ static int postcopy_start(MigrationState *ms, Error **errp)
      */
     qemu_savevm_send_postcopy_listen(fb);
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+     *   - migration/migration.c|2906| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+     *   - migration/migration.c|4131| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+     *   - migration/savevm.c|1735| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+     */
     ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
     if (ret) {
         error_setg(errp, "Postcopy save non-iterable device states failed");
@@ -2931,6 +3211,10 @@ fail:
  *
  * Returns: true on success, false on interruptions.
  */
+/*
+ * 在以下使用migration_switchover_prepare():
+ *   - migration/migration.c|3069| <<migration_switchover_start>> if (!migration_switchover_prepare(s)) {
+ */
 static bool migration_switchover_prepare(MigrationState *s)
 {
     /* Concurrent cancellation?  Quit */
@@ -2946,6 +3230,9 @@ static bool migration_switchover_prepare(MigrationState *s)
     assert(migration_is_active());
 
     /* If the pre stage not requested, directly switch to DEVICE */
+    /*
+     * 只在这里使用migrate_pause_before_switchover()
+     */
     if (!migrate_pause_before_switchover()) {
         migrate_set_state(&s->state, s->state, MIGRATION_STATUS_DEVICE);
         return true;
@@ -2956,12 +3243,30 @@ static bool migration_switchover_prepare(MigrationState *s)
      * it's possible that someone could have issued multiple migrate_continue
      * and the event is incorrectly set at this point so reset it.
      */
+    /*
+     * 在以下使用MigrationState->pause_event:
+     *   - migration/migration.c|1719| <<migration_cancel>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|2456| <<qmp_migrate_continue>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|3045| <<migration_switchover_prepare>> qemu_event_reset(&s->pause_event);
+     *   - migration/migration.c|3051| <<migration_switchover_prepare>> qemu_event_wait(&s->pause_event);
+     *   - migration/migration.c|4322| <<migration_instance_finalize>> qemu_event_destroy(&ms->pause_event);
+     *   - migration/migration.c|4338| <<migration_instance_init>> qemu_event_init(&ms->pause_event, false);
+     */
     qemu_event_reset(&s->pause_event);
 
     /* Update [POSTCOPY_]ACTIVE to PRE_SWITCHOVER */
     migrate_set_state(&s->state, s->state, MIGRATION_STATUS_PRE_SWITCHOVER);
     bql_unlock();
 
+    /*
+     * 在以下使用MigrationState->pause_event:
+     *   - migration/migration.c|1719| <<migration_cancel>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|2456| <<qmp_migrate_continue>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|3045| <<migration_switchover_prepare>> qemu_event_reset(&s->pause_event);
+     *   - migration/migration.c|3051| <<migration_switchover_prepare>> qemu_event_wait(&s->pause_event);
+     *   - migration/migration.c|4322| <<migration_instance_finalize>> qemu_event_destroy(&ms->pause_event);
+     *   - migration/migration.c|4338| <<migration_instance_init>> qemu_event_init(&ms->pause_event, false);
+     */
     qemu_event_wait(&s->pause_event);
 
     bql_lock();
@@ -2976,6 +3281,11 @@ static bool migration_switchover_prepare(MigrationState *s)
     return s->state == MIGRATION_STATUS_DEVICE;
 }
 
+/*
+ * 在以下使用migration_switchover_start():
+ *   - migration/migration.c|2855| <<postcopy_start>> if (!migration_switchover_start(ms, errp)) {
+ *   - migration/migration.c|3158| <<migration_completion_precopy>> if (!migration_switchover_start(s, NULL)) {
+ */
 static bool migration_switchover_start(MigrationState *s, Error **errp)
 {
     ERRP_GUARD();
@@ -3006,6 +3316,56 @@ static bool migration_switchover_start(MigrationState *s, Error **errp)
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 static int migration_completion_precopy(MigrationState *s)
 {
     int ret;
@@ -3013,17 +3373,35 @@ static int migration_completion_precopy(MigrationState *s)
     bql_lock();
 
     if (!migrate_mode_is_cpr(s)) {
+        /*
+	 * 在以下使用migration_stop_vm():
+         *   - migration/migration.c|2849| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+         *   - migration/migration.c|3152| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+         *   - migration/migration.c|4127| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+         *   - migration/migration.c|4271| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 */
         ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
         if (ret < 0) {
             goto out_unlock;
         }
     }
 
+    /*
+     * 在以下使用migration_switchover_start():
+     *   - migration/migration.c|2855| <<postcopy_start>> if (!migration_switchover_start(ms, errp)) {
+     *   - migration/migration.c|3158| <<migration_completion_precopy>> if (!migration_switchover_start(s, NULL)) {
+     */
     if (!migration_switchover_start(s, NULL)) {
         ret = -EFAULT;
         goto out_unlock;
     }
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy():
+     *   - migration/migration.c|3163| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+     *   - migration/savevm.c|1839| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+     *   - migration/savevm.c|1865| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+     */
     ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
 out_unlock:
     bql_unlock();
@@ -3548,6 +3926,10 @@ static MigIterateState migration_iteration_run(MigrationState *s)
     return MIG_ITERATE_RESUME;
 }
 
+/*
+ * 在以下使用migration_iteration_finish():
+ *   - migration/migration.c|4270| <<migration_thread>> migration_iteration_finish(s);
+ */
 static void migration_iteration_finish(MigrationState *s)
 {
     Error *local_err = NULL;
@@ -3565,6 +3947,22 @@ static void migration_iteration_finish(MigrationState *s)
 
     switch (s->state) {
     case MIGRATION_STATUS_COMPLETED:
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         runstate_set(RUN_STATE_POSTMIGRATE);
         break;
     case MIGRATION_STATUS_COLO:
@@ -3599,10 +3997,44 @@ static void migration_iteration_finish(MigrationState *s)
         }
         if (runstate_is_live(s->vm_old_state)) {
             if (!runstate_check(RUN_STATE_SHUTDOWN)) {
+                /*
+		 * 在以下使用vm_start():
+                 *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+                 *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+                 *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+                 *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+                 *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+                 *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+                 *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+                 *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+                 *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+                 *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+                 *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+                 *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+                 *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+                 *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+                 *   - system/cpus.c|899| <<vm_resume>> vm_start();
+		 */
                 vm_start();
             }
         } else {
             if (runstate_check(RUN_STATE_FINISH_MIGRATE)) {
+                /*
+		 * 在以下使用runstate_set():
+                 *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+		 *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+		 *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+		 *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+		 *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+                 *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+                 *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+                 *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+                 *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+                 *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+                 *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+                 *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+                 *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+		 */
                 runstate_set(s->vm_old_state);
             }
         }
@@ -3614,6 +4046,15 @@ static void migration_iteration_finish(MigrationState *s)
         break;
     }
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|1054| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3953| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3981| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4333| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/postcopy-ram.c|2190| <<postcopy_listen_thread>> migration_bh_schedule(postcopy_listen_thread_bh, NULL);
+     *   - migration/savevm.c|2271| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(migration_cleanup_bh, s);
     bql_unlock();
 }
@@ -3872,6 +4313,12 @@ static void bg_migration_vm_start_bh(void *opaque)
 {
     MigrationState *s = opaque;
 
+    /*
+     * 在以下使用vm_resume():
+     *   - migration/migration.c|4211| <<bg_migration_vm_start_bh>> vm_resume(s->vm_old_state);
+     *   - migration/savevm.c|3396| <<save_snapshot>> vm_resume(saved_state);
+     *   - migration/savevm.c|3593| <<load_snapshot_resume>> vm_resume(state);
+     */
     vm_resume(s->vm_old_state);
     migration_downtime_end(s);
 }
@@ -3956,10 +4403,23 @@ static void *bg_migration_thread(void *opaque)
 
     bql_lock();
 
+    /*
+     * 在以下使用migration_stop_vm():
+     *   - migration/migration.c|2849| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|3152| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     *   - migration/migration.c|4127| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+     *   - migration/migration.c|4271| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+     */
     if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
         goto fail;
     }
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+     *   - migration/migration.c|2906| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+     *   - migration/migration.c|4131| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+     *   - migration/savevm.c|1735| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+     */
     if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
         goto fail;
     }
@@ -3981,6 +4441,15 @@ static void *bg_migration_thread(void *opaque)
      * calling VM state change notifiers from vm_start() would initiate
      * writes to virtio VQs memory which is in write-protected region.
      */
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|1054| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3953| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3981| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4333| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/postcopy-ram.c|2190| <<postcopy_listen_thread>> migration_bh_schedule(postcopy_listen_thread_bh, NULL);
+     *   - migration/savevm.c|2271| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(bg_migration_vm_start_bh, s);
     bql_unlock();
 
@@ -4100,6 +4569,13 @@ void migration_connect(MigrationState *s, Error *error_in)
     }
 
     if (migrate_mode_is_cpr(s)) {
+        /*
+	 * 在以下使用migration_stop_vm():
+         *   - migration/migration.c|2849| <<postcopy_start>> ret = migration_stop_vm(ms, RUN_STATE_FINISH_MIGRATE);
+         *   - migration/migration.c|3152| <<migration_completion_precopy>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+         *   - migration/migration.c|4127| <<bg_migration_thread>> if (migration_stop_vm(s, RUN_STATE_PAUSED)) {
+         *   - migration/migration.c|4271| <<migration_connect>> ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
+	 */
         ret = migration_stop_vm(s, RUN_STATE_FINISH_MIGRATE);
         if (ret < 0) {
             error_setg(&local_err, "migration_stop_vm failed, error %d", -ret);
@@ -4151,6 +4627,15 @@ static void migration_instance_finalize(Object *obj)
     qemu_mutex_destroy(&ms->qemu_file_lock);
     qemu_sem_destroy(&ms->wait_unplug_sem);
     qemu_sem_destroy(&ms->rate_limit_sem);
+    /*
+     * 在以下使用MigrationState->pause_event:
+     *   - migration/migration.c|1719| <<migration_cancel>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|2456| <<qmp_migrate_continue>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|3045| <<migration_switchover_prepare>> qemu_event_reset(&s->pause_event);
+     *   - migration/migration.c|3051| <<migration_switchover_prepare>> qemu_event_wait(&s->pause_event);
+     *   - migration/migration.c|4322| <<migration_instance_finalize>> qemu_event_destroy(&ms->pause_event);
+     *   - migration/migration.c|4338| <<migration_instance_init>> qemu_event_init(&ms->pause_event, false);
+     */
     qemu_event_destroy(&ms->pause_event);
     qemu_sem_destroy(&ms->postcopy_pause_sem);
     qemu_sem_destroy(&ms->rp_state.rp_sem);
@@ -4167,6 +4652,15 @@ static void migration_instance_init(Object *obj)
     ms->state = MIGRATION_STATUS_NONE;
     ms->mbps = -1;
     ms->pages_per_second = -1;
+    /*
+     * 在以下使用MigrationState->pause_event:
+     *   - migration/migration.c|1719| <<migration_cancel>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|2456| <<qmp_migrate_continue>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|3045| <<migration_switchover_prepare>> qemu_event_reset(&s->pause_event);
+     *   - migration/migration.c|3051| <<migration_switchover_prepare>> qemu_event_wait(&s->pause_event);
+     *   - migration/migration.c|4322| <<migration_instance_finalize>> qemu_event_destroy(&ms->pause_event);
+     *   - migration/migration.c|4338| <<migration_instance_init>> qemu_event_init(&ms->pause_event, false);
+     */
     qemu_event_init(&ms->pause_event, false);
     qemu_mutex_init(&ms->error_mutex);
 
diff --git a/migration/migration.h b/migration/migration.h
index 213b33fe6..cd8047128 100644
--- a/migration/migration.h
+++ b/migration/migration.h
@@ -379,6 +379,15 @@ struct MigrationState {
     /* Migration is waiting for guest to unplug device */
     QemuSemaphore wait_unplug_sem;
 
+    /*
+     * 在以下使用MigrationState->pause_event:
+     *   - migration/migration.c|1719| <<migration_cancel>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|2456| <<qmp_migrate_continue>> qemu_event_set(&s->pause_event);
+     *   - migration/migration.c|3045| <<migration_switchover_prepare>> qemu_event_reset(&s->pause_event);
+     *   - migration/migration.c|3051| <<migration_switchover_prepare>> qemu_event_wait(&s->pause_event);
+     *   - migration/migration.c|4322| <<migration_instance_finalize>> qemu_event_destroy(&ms->pause_event);
+     *   - migration/migration.c|4338| <<migration_instance_init>> qemu_event_init(&ms->pause_event, false);
+     */
     /* Migration is paused due to pause-before-switchover */
     QemuEvent pause_event;
 
diff --git a/migration/multifd.c b/migration/multifd.c
index 3203dc98e..7f09e3765 100644
--- a/migration/multifd.c
+++ b/migration/multifd.c
@@ -1526,6 +1526,10 @@ bool multifd_recv_all_channels_created(void)
  * Try to receive all multifd channels to get ready for the migration.
  * Sets @errp when failing to receive the current channel.
  */
+/*
+ * 在以下使用multifd_recv_new_channel():
+ *   - migration/migration.c|1287| <<migration_ioc_process_incoming>> multifd_recv_new_channel(ioc, &local_err);
+ */
 void multifd_recv_new_channel(QIOChannel *ioc, Error **errp)
 {
     MultiFDRecvParams *p;
diff --git a/migration/options.c b/migration/options.c
index e78324b80..6c5163d20 100644
--- a/migration/options.c
+++ b/migration/options.c
@@ -283,6 +283,10 @@ bool migrate_multifd(void)
     return s->capabilities[MIGRATION_CAPABILITY_MULTIFD];
 }
 
+/*
+ * 在以下使用migrate_pause_before_switchover():
+ *   - migration/migration.c|3035| <<migration_switchover_prepare>> if (!migrate_pause_before_switchover()) {
+ */
 bool migrate_pause_before_switchover(void)
 {
     MigrationState *s = migrate_get_current();
diff --git a/migration/postcopy-ram.c b/migration/postcopy-ram.c
index 715ef021a..4082619b4 100644
--- a/migration/postcopy-ram.c
+++ b/migration/postcopy-ram.c
@@ -2130,6 +2130,14 @@ static void *postcopy_listen_thread(void *opaque)
      */
     qemu_file_set_blocking(f, true, &error_fatal);
 
+    /*
+     * 在以下使用qemu_loadvm_state_main():
+     *   - migration/colo.c|728| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis, errp);
+     *   - migration/postcopy-ram.c|2134| <<postcopy_listen_thread>> load_res = qemu_loadvm_state_main(f, mis, &local_err);
+     *   - migration/savevm.c|2473| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis, errp);
+     *   - migration/savevm.c|3226| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+     *   - migration/savevm.c|3318| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+     */
     /* TODO: sanity check that only postcopiable data will be loaded here */
     load_res = qemu_loadvm_state_main(f, mis, &local_err);
 
@@ -2187,6 +2195,15 @@ out:
     rcu_unregister_thread();
     postcopy_state_set(POSTCOPY_INCOMING_END);
 
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|1054| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3953| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3981| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4333| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/postcopy-ram.c|2190| <<postcopy_listen_thread>> migration_bh_schedule(postcopy_listen_thread_bh, NULL);
+     *   - migration/savevm.c|2271| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(postcopy_listen_thread_bh, NULL);
 
     object_unref(OBJECT(migr));
diff --git a/migration/ram.c b/migration/ram.c
index 29f016cb2..d696a5345 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -448,21 +448,41 @@ static bool postcopy_has_request(RAMState *rs)
     return !QSIMPLEQ_EMPTY_ATOMIC(&rs->src_page_requests);
 }
 
+/*
+ * 在以下使用precopy_infrastructure_init():
+ *   - system/runstate.c|1116| <<qemu_init_subsystems>> precopy_infrastructure_init();
+ */
 void precopy_infrastructure_init(void)
 {
     notifier_with_return_list_init(&precopy_notifier_list);
 }
 
+/*
+ * 在以下使用precopy_add_notifier():
+ *   - hw/virtio/virtio-balloon.c|1226| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+ */
 void precopy_add_notifier(NotifierWithReturn *n)
 {
     notifier_with_return_list_add(&precopy_notifier_list, n);
 }
 
+/*
+ * 在以下使用precopy_remove_notifier():
+ *   - hw/virtio/virtio-balloon.c|1286| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+ */
 void precopy_remove_notifier(NotifierWithReturn *n)
 {
     notifier_with_return_remove(n);
 }
 
+/*
+ * 在以下使用precopy_notify():
+ *   - migration/migration.c|157| <<precopy_notify_complete>> if (precopy_notify(PRECOPY_NOTIFY_COMPLETE, &local_err)) {
+ *   - migration/ram.c|1200| <<migration_bitmap_sync_precopy>> if (precopy_notify(PRECOPY_NOTIFY_BEFORE_BITMAP_SYNC, &local_err)) {
+ *   - migration/ram.c|1207| <<migration_bitmap_sync_precopy>> if (precopy_notify(PRECOPY_NOTIFY_AFTER_BITMAP_SYNC, &local_err)) {
+ *   - migration/savevm.c|1406| <<qemu_savevm_state_setup>> return precopy_notify(PRECOPY_NOTIFY_SETUP, errp);
+ *   - migration/savevm.c|1795| <<qemu_savevm_state_cleanup>> if (precopy_notify(PRECOPY_NOTIFY_CLEANUP, &local_err)) {
+ */
 int precopy_notify(PrecopyNotifyReason reason, Error **errp)
 {
     PrecopyNotifyData pnd;
@@ -2744,6 +2764,24 @@ int ram_discard_range(const char *rbname, uint64_t start, size_t length)
                      length >> qemu_target_page_bits());
     }
 
+    /*
+     * 在以下使用ram_block_discard_range():
+     *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+     *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+     *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+     *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+     *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+     *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+     *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+     *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+     *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+     *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+     *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+     *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+     *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+     *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+     *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+     */
     return ram_block_discard_range(rb, start, length);
 }
 
@@ -2965,6 +3003,10 @@ static void ram_state_resume_prepare(RAMState *rs, QEMUFile *out)
  * start of the continuous guest free pages, and @len is the total bytes of
  * those pages.
  */
+/*
+ * 在以下使用qemu_guest_free_page_hint():
+ *   - hw/virtio/virtio-balloon.c|686| <<get_free_page_hints>> qemu_guest_free_page_hint(elem->in_sg[i].iov_base,
+ */
 void qemu_guest_free_page_hint(void *addr, size_t len)
 {
     RAMBlock *block;
@@ -3251,6 +3293,16 @@ void ramblock_set_file_bmap_atomic(RAMBlock *block, ram_addr_t offset, bool set)
  * @f: QEMUFile where to send the data
  * @opaque: RAMState pointer
  */
+/*
+ * 在以下使用SaveVMHandlers->save_live_iterate:
+ *   - hw/ppc/spapr.c|2572| <<global>> .save_live_iterate = htab_save_iterate,
+ *   - hw/s390x/s390-stattrib.c|340| <<global>> .save_live_iterate = cmma_save_iterate,
+ *   - hw/vfio/migration.c|834| <<global>> .save_live_iterate = vfio_save_iterate,
+ *   - migration/block-dirty-bitmap.c|1255| <<global>> .save_live_iterate = dirty_bitmap_save_iterate,
+ *   - migration/ram.c|4695| <<global>> .save_live_iterate = ram_save_iterate,
+ *   - migration/savevm.c|1448| <<qemu_savevm_state_iterate>> if (!se->ops || !se->ops->save_live_iterate) {
+ *   - migration/savevm.c|1476| <<qemu_savevm_state_iterate>> ret = se->ops->save_live_iterate(f, se->opaque);
+ */
 static int ram_save_iterate(QEMUFile *f, void *opaque)
 {
     RAMState **temp = opaque;
@@ -4195,6 +4247,10 @@ static void parse_ramblock_mapped_ram(QEMUFile *f, RAMBlock *block,
     qemu_set_offset(f, block->pages_offset + length, SEEK_SET);
 }
 
+/*
+ * 在以下使用parse_ramblock():
+ *   - migration/ram.c|4334| <<parse_ramblocks>> ret = parse_ramblock(f, block, length);
+ */
 static int parse_ramblock(QEMUFile *f, RAMBlock *block, ram_addr_t length)
 {
     int ret = 0;
@@ -4279,6 +4335,9 @@ static int parse_ramblocks(QEMUFile *f, ram_addr_t total_ram_bytes)
 
         block = qemu_ram_block_by_name(id);
         if (block) {
+            /*
+	     * 只在这里调用
+	     */
             ret = parse_ramblock(f, block, length);
         } else {
             error_report("Unknown ramblock \"%s\", cannot accept "
@@ -4459,6 +4518,19 @@ static int ram_load_precopy(QEMUFile *f)
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  ram_load (f=0x5555578d3200, opaque=0x555557524aa0 <ram_state>, version_id=4) at ../migration/ram.c:4327
+ * #1  0x0000555555c79a9d in vmstate_load (f=0x5555578d3200, se=0x5555575e3220) at ../migration/savevm.c:970
+ * #2  0x0000555555c7da30 in qemu_loadvm_section_part_end (f=0x5555578d3200, type=2 '\002') at ../migration/savevm.c:2796
+ * #3  0x0000555555c7e40d in qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3056
+ * #4  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #5  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #6  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #7  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #8  0x00007fffffffc7e0 in ?? ()
+ * #9  0x0000000000000000 in ?? ()
+ */
 static int ram_load(QEMUFile *f, void *opaque, int version_id)
 {
     int ret = 0;
diff --git a/migration/savevm.c b/migration/savevm.c
index 62cc2ce25..fa4e43afa 100644
--- a/migration/savevm.c
+++ b/migration/savevm.c
@@ -963,6 +963,19 @@ void vmstate_unregister(VMStateIf *obj, const VMStateDescription *vmsd,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  ram_load (f=0x5555578d3200, opaque=0x555557524aa0 <ram_state>, version_id=4) at ../migration/ram.c:4327
+ * #1  0x0000555555c79a9d in vmstate_load (f=0x5555578d3200, se=0x5555575e3220) at ../migration/savevm.c:970
+ * #2  0x0000555555c7da30 in qemu_loadvm_section_part_end (f=0x5555578d3200, type=2 '\002') at ../migration/savevm.c:2796
+ * #3  0x0000555555c7e40d in qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3056
+ * #4  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #5  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #6  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #7  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #8  0x00007fffffffc7e0 in ?? ()
+ * #9  0x0000000000000000 in ?? ()
+ */
 static int vmstate_load(QEMUFile *f, SaveStateEntry *se, Error **errp)
 {
     int ret;
@@ -1473,6 +1486,16 @@ int qemu_savevm_state_iterate(QEMUFile *f, bool postcopy)
 
         save_section_header(f, se, QEMU_VM_SECTION_PART);
 
+        /*
+	 * 在以下使用SaveVMHandlers->save_live_iterate:
+	 *   - hw/ppc/spapr.c|2572| <<global>> .save_live_iterate = htab_save_iterate,
+         *   - hw/s390x/s390-stattrib.c|340| <<global>> .save_live_iterate = cmma_save_iterate,
+         *   - hw/vfio/migration.c|834| <<global>> .save_live_iterate = vfio_save_iterate,
+         *   - migration/block-dirty-bitmap.c|1255| <<global>> .save_live_iterate = dirty_bitmap_save_iterate,
+         *   - migration/ram.c|4695| <<global>> .save_live_iterate = ram_save_iterate,
+         *   - migration/savevm.c|1448| <<qemu_savevm_state_iterate>> if (!se->ops || !se->ops->save_live_iterate) {
+         *   - migration/savevm.c|1476| <<qemu_savevm_state_iterate>> ret = se->ops->save_live_iterate(f, se->opaque);
+	 */
         ret = se->ops->save_live_iterate(f, se->opaque);
         trace_savevm_section_end(se->idstr, se->section_id, ret);
         save_section_footer(f, se);
@@ -1586,6 +1609,11 @@ bool qemu_savevm_state_postcopy_prepare(QEMUFile *f, Error **errp)
     return true;
 }
 
+/*
+ * 在以下使用qemu_savevm_state_complete_precopy_iterable():
+ *   - migration/migration.c|2863| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_iterable(ms->to_dst_file, true);
+ *   - migration/savevm.c|1729| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_iterable(f, false);
+ */
 int qemu_savevm_state_complete_precopy_iterable(QEMUFile *f, bool in_postcopy)
 {
     int64_t start_ts_each, end_ts_each;
@@ -1657,6 +1685,12 @@ ret_fail_abort_threads:
     return -1;
 }
 
+/*
+ * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+ *   - migration/migration.c|2906| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+ *   - migration/migration.c|4131| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+ *   - migration/savevm.c|1735| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+ */
 int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
                                                     bool in_postcopy)
 {
@@ -1712,16 +1746,33 @@ int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
     return 0;
 }
 
+/*
+ * 在以下使用qemu_savevm_state_complete_precopy():
+ *   - migration/migration.c|3163| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+ *   - migration/savevm.c|1839| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+ *   - migration/savevm.c|1865| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+ */
 int qemu_savevm_state_complete_precopy(QEMUFile *f, bool iterable_only)
 {
     int ret;
 
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy_iterable():
+     *   - migration/migration.c|2863| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_iterable(ms->to_dst_file, true);
+     *   - migration/savevm.c|1729| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_iterable(f, false);
+     */
     ret = qemu_savevm_state_complete_precopy_iterable(f, false);
     if (ret) {
         return ret;
     }
 
     if (!iterable_only) {
+        /*
+	 * 在以下使用qemu_savevm_state_complete_precopy_non_iterable():
+	 *   - migration/migration.c|2906| <<postcopy_start>> ret = qemu_savevm_state_complete_precopy_non_iterable(fb, true);
+         *   - migration/migration.c|4131| <<bg_migration_thread>> if (qemu_savevm_state_complete_precopy_non_iterable(fb, false)) {
+         *   - migration/savevm.c|1735| <<qemu_savevm_state_complete_precopy>> ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
+	 */
         ret = qemu_savevm_state_complete_precopy_non_iterable(f, false);
         if (ret) {
             return ret;
@@ -1794,6 +1845,10 @@ void qemu_savevm_state_cleanup(void)
     }
 }
 
+/*
+ * 在以下使用qemu_savevm_state():
+ *   - migration/savevm.c|3304| <<save_snapshot>> ret = qemu_savevm_state(f, errp);
+ */
 static int qemu_savevm_state(QEMUFile *f, Error **errp)
 {
     int ret;
@@ -1826,6 +1881,12 @@ static int qemu_savevm_state(QEMUFile *f, Error **errp)
     ret = qemu_file_get_error(f);
     if (ret == 0) {
         qemu_savevm_maybe_send_switchover_start(f);
+        /*
+	 * 在以下使用qemu_savevm_state_complete_precopy():
+	 *   - migration/migration.c|3163| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+	 *   - migration/savevm.c|1839| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+	 *   - migration/savevm.c|1865| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+	 */
         qemu_savevm_state_complete_precopy(f, false);
         ret = qemu_file_get_error(f);
     }
@@ -1849,9 +1910,19 @@ cleanup:
     return ret;
 }
 
+/*
+ * 在以下使用qemu_savevm_live_state():
+ *   - migration/colo.c|474| <<colo_do_checkpoint_transaction>> qemu_savevm_live_state(s->to_dst_file);
+ */
 void qemu_savevm_live_state(QEMUFile *f)
 {
     /* save QEMU_VM_SECTION_END section */
+    /*
+     * 在以下使用qemu_savevm_state_complete_precopy():
+     *   - migration/migration.c|3163| <<migration_completion_precopy>> ret = qemu_savevm_state_complete_precopy(s->to_dst_file, false);
+     *   - migration/savevm.c|1839| <<qemu_savevm_state>> qemu_savevm_state_complete_precopy(f, false);
+     *   - migration/savevm.c|1865| <<qemu_savevm_live_state>> qemu_savevm_state_complete_precopy(f, true);
+     */
     qemu_savevm_state_complete_precopy(f, true);
     qemu_put_byte(f, QEMU_VM_EOF);
 }
@@ -2120,6 +2191,10 @@ static int loadvm_postcopy_handle_listen(MigrationIncomingState *mis,
     return rc;
 }
 
+/*
+ * 在以下使用loadvm_postcopy_handle_run_bh():
+ *   - migration/savevm.c|2300| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+ */
 static void loadvm_postcopy_handle_run_bh(void *opaque)
 {
     MigrationIncomingState *mis = opaque;
@@ -2129,6 +2204,13 @@ static void loadvm_postcopy_handle_run_bh(void *opaque)
     /* TODO we should move all of this lot into postcopy_ram.c or a shared code
      * in migration.c
      */
+    /*
+     * 在以下使用cpu_synchronize_all_post_init():
+     *   - hw/core/machine.c|1782| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|2203| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3289| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3305| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+     */
     cpu_synchronize_all_post_init();
 
     trace_vmstate_downtime_checkpoint("dst-postcopy-bh-cpu-synced");
@@ -2149,9 +2231,43 @@ static void loadvm_postcopy_handle_run_bh(void *opaque)
         trace_vmstate_downtime_checkpoint("dst-postcopy-bh-cache-invalidated");
 
         if (success) {
+            /*
+	     * 在以下使用vm_start():
+             *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+             *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+             *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+             *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+             *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+             *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+             *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+             *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+             *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+             *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+             *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+             *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+             *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+             *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+             *   - system/cpus.c|899| <<vm_resume>> vm_start();
+	     */
             vm_start();
         }
     } else {
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         /* leave it paused and let management decide when to start the CPU */
         runstate_set(RUN_STATE_PAUSED);
     }
@@ -2159,6 +2275,10 @@ static void loadvm_postcopy_handle_run_bh(void *opaque)
     trace_vmstate_downtime_checkpoint("dst-postcopy-bh-vm-started");
 }
 
+/*
+ * 在以下使用loadvm_postcopy_handle_run():
+ *   - migration/savevm.c|2652| <<loadvm_process_command>> return loadvm_postcopy_handle_run(mis, errp);
+ */
 /* After all discards we can start running and asking for pages */
 static int loadvm_postcopy_handle_run(MigrationIncomingState *mis, Error **errp)
 {
@@ -2176,6 +2296,15 @@ static int loadvm_postcopy_handle_run(MigrationIncomingState *mis, Error **errp)
                           MIGRATION_STATUS_POSTCOPY_ACTIVE);
     }
     postcopy_state_set(POSTCOPY_INCOMING_RUNNING);
+    /*
+     * 在以下使用migration_bh_schedule():
+     *   - migration/migration.c|1054| <<process_incoming_migration_co>> migration_bh_schedule(process_incoming_migration_bh, mis);
+     *   - migration/migration.c|3953| <<migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|3981| <<bg_migration_iteration_finish>> migration_bh_schedule(migration_cleanup_bh, s);
+     *   - migration/migration.c|4333| <<bg_migration_thread>> migration_bh_schedule(bg_migration_vm_start_bh, s);
+     *   - migration/postcopy-ram.c|2190| <<postcopy_listen_thread>> migration_bh_schedule(postcopy_listen_thread_bh, NULL);
+     *   - migration/savevm.c|2271| <<loadvm_postcopy_handle_run>> migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
+     */
     migration_bh_schedule(loadvm_postcopy_handle_run_bh, mis);
 
     /* We need to finish reading the stream from the package
@@ -2349,6 +2478,14 @@ static int loadvm_handle_cmd_packaged(MigrationIncomingState *mis, Error **errp)
         qemu_coroutine_yield();
     } while (1);
 
+    /*
+     * 在以下使用qemu_loadvm_state_main():
+     *   - migration/colo.c|728| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis, errp);
+     *   - migration/postcopy-ram.c|2134| <<postcopy_listen_thread>> load_res = qemu_loadvm_state_main(f, mis, &local_err);
+     *   - migration/savevm.c|2473| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis, errp);
+     *   - migration/savevm.c|3226| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+     *   - migration/savevm.c|3318| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+     */
     ret = qemu_loadvm_state_main(packf, mis, errp);
     trace_loadvm_handle_cmd_packaged_main(ret);
     qemu_fclose(packf);
@@ -2449,6 +2586,10 @@ static int loadvm_postcopy_handle_switchover_start(Error **errp)
  * LOADVM_QUIT All good, but exit the loop
  * <0          Error
  */
+/*
+ * 在以下使用loadvm_process_command():
+ *   - migration/savevm.c|3135| <<qemu_loadvm_state_main>> ret = loadvm_process_command(f, errp);
+ */
 static int loadvm_process_command(QEMUFile *f, Error **errp)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -2674,6 +2815,19 @@ qemu_loadvm_section_start_full(QEMUFile *f, uint8_t type, Error **errp)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  ram_load (f=0x5555578d3200, opaque=0x555557524aa0 <ram_state>, version_id=4) at ../migration/ram.c:4327
+ * #1  0x0000555555c79a9d in vmstate_load (f=0x5555578d3200, se=0x5555575e3220) at ../migration/savevm.c:970
+ * #2  0x0000555555c7da30 in qemu_loadvm_section_part_end (f=0x5555578d3200, type=2 '\002') at ../migration/savevm.c:2796
+ * #3  0x0000555555c7e40d in qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3056
+ * #4  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #5  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #6  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #7  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #8  0x00007fffffffc7e0 in ?? ()
+ * #9  0x0000000000000000 in ?? ()
+ */
 static int
 qemu_loadvm_section_part_end(QEMUFile *f, uint8_t type, Error **errp)
 {
@@ -2949,6 +3103,26 @@ static bool postcopy_pause_incoming(MigrationIncomingState *mis)
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  ram_load (f=0x5555578d3200, opaque=0x555557524aa0 <ram_state>, version_id=4) at ../migration/ram.c:4327
+ * #1  0x0000555555c79a9d in vmstate_load (f=0x5555578d3200, se=0x5555575e3220) at ../migration/savevm.c:970
+ * #2  0x0000555555c7da30 in qemu_loadvm_section_part_end (f=0x5555578d3200, type=2 '\002') at ../migration/savevm.c:2796
+ * #3  0x0000555555c7e40d in qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3056
+ * #4  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #5  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #6  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #7  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #8  0x00007fffffffc7e0 in ?? ()
+ * #9  0x0000000000000000 in ?? ()
+ *
+ * 在以下使用qemu_loadvm_state_main():
+ *   - migration/colo.c|728| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis, errp);
+ *   - migration/postcopy-ram.c|2134| <<postcopy_listen_thread>> load_res = qemu_loadvm_state_main(f, mis, &local_err);
+ *   - migration/savevm.c|2473| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis, errp);
+ *   - migration/savevm.c|3226| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+ *   - migration/savevm.c|3318| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+ */
 int qemu_loadvm_state_main(QEMUFile *f, MigrationIncomingState *mis,
                            Error **errp)
 {
@@ -3030,6 +3204,25 @@ out:
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  ram_load (f=0x5555578d3200, opaque=0x555557524aa0 <ram_state>, version_id=4) at ../migration/ram.c:4327
+ * #1  0x0000555555c79a9d in vmstate_load (f=0x5555578d3200, se=0x5555575e3220) at ../migration/savevm.c:970
+ * #2  0x0000555555c7da30 in qemu_loadvm_section_part_end (f=0x5555578d3200, type=2 '\002') at ../migration/savevm.c:2796
+ * #3  0x0000555555c7e40d in qemu_loadvm_state_main (f=0x5555578d3200, mis=0x5555575e2e00) at ../migration/savevm.c:3056
+ * #4  0x0000555555c7e5bc in qemu_loadvm_state (f=0x5555578d3200) at ../migration/savevm.c:3136
+ * #5  0x0000555555c600a0 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:884
+ * #6  0x0000555556174d17 in coroutine_trampoline (i0=1468467552, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #7  0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #8  0x00007fffffffc7e0 in ?? ()
+ * #9  0x0000000000000000 in ?? ()
+ *
+ *
+ * 在以下使用qemu_loadvm_state():
+ *   - migration/migration.c|1071| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file, &local_err);
+ *   - migration/savevm.c|3504| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f, errp);
+ *   - migration/savevm.c|3590| <<load_snapshot>> ret = qemu_loadvm_state(f, errp);
+ */
 int qemu_loadvm_state(QEMUFile *f, Error **errp)
 {
     MigrationState *s = migrate_get_current();
@@ -3057,6 +3250,14 @@ int qemu_loadvm_state(QEMUFile *f, Error **errp)
 
     cpu_synchronize_all_pre_loadvm();
 
+    /*
+     * 在以下使用qemu_loadvm_state_main():
+     *   - migration/colo.c|728| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis, errp);
+     *   - migration/postcopy-ram.c|2134| <<postcopy_listen_thread>> load_res = qemu_loadvm_state_main(f, mis, &local_err);
+     *   - migration/savevm.c|2473| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis, errp);
+     *   - migration/savevm.c|3226| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+     *   - migration/savevm.c|3318| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+     */
     ret = qemu_loadvm_state_main(f, mis, errp);
     qemu_event_set(&mis->main_thread_load_event);
 
@@ -3127,22 +3328,48 @@ int qemu_loadvm_state(QEMUFile *f, Error **errp)
         }
     }
 
+    /*
+     * 在以下使用cpu_synchronize_all_post_init():
+     *   - hw/core/machine.c|1782| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|2203| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3289| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3305| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+     */
     cpu_synchronize_all_post_init();
 
     return ret;
 }
 
+/*
+ * 在以下使用qemu_load_device_state():
+ *   - migration/colo.c|770| <<colo_incoming_process_checkpoint>> ret = qemu_load_device_state(fb, errp);
+ */
 int qemu_load_device_state(QEMUFile *f, Error **errp)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
     int ret;
 
+    /*
+     * 在以下使用qemu_loadvm_state_main():
+     *   - migration/colo.c|728| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis, errp);
+     *   - migration/postcopy-ram.c|2134| <<postcopy_listen_thread>> load_res = qemu_loadvm_state_main(f, mis, &local_err);
+     *   - migration/savevm.c|2473| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis, errp);
+     *   - migration/savevm.c|3226| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+     *   - migration/savevm.c|3318| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis, errp);
+     */
     /* Load QEMU_VM_SECTION_FULL section */
     ret = qemu_loadvm_state_main(f, mis, errp);
     if (ret < 0) {
         return ret;
     }
 
+    /*
+     * 在以下使用cpu_synchronize_all_post_init():
+     *   - hw/core/machine.c|1782| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|2203| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3289| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+     *   - migration/savevm.c|3305| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+     */
     cpu_synchronize_all_post_init();
     return 0;
 }
@@ -3275,6 +3502,9 @@ bool save_snapshot(const char *name, bool overwrite, const char *vmstate,
         error_setg(errp, "Could not open VM state file");
         goto the_end;
     }
+    /*
+     * 只在这里调用
+     */
     ret = qemu_savevm_state(f, errp);
     vm_state_size = qemu_file_transferred(f);
     ret2 = qemu_fclose(f);
@@ -3298,6 +3528,12 @@ bool save_snapshot(const char *name, bool overwrite, const char *vmstate,
  the_end:
     bdrv_drain_all_end();
 
+    /*
+     * 在以下使用vm_resume():
+     *   - migration/migration.c|4211| <<bg_migration_vm_start_bh>> vm_resume(s->vm_old_state);
+     *   - migration/savevm.c|3396| <<save_snapshot>> vm_resume(saved_state);
+     *   - migration/savevm.c|3593| <<load_snapshot_resume>> vm_resume(state);
+     */
     vm_resume(saved_state);
     return ret == 0;
 }
@@ -3345,6 +3581,24 @@ void qmp_xen_save_devices_state(const char *filename, bool has_live, bool live,
 
  the_end:
     if (saved_vm_running) {
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+         *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|899| <<vm_resume>> vm_start();
+	 */
         vm_start();
     }
 }
@@ -3373,6 +3627,12 @@ void qmp_xen_load_devices_state(const char *filename, Error **errp)
     f = qemu_file_new_input(QIO_CHANNEL(ioc));
     object_unref(OBJECT(ioc));
 
+    /*
+     * 在以下使用qemu_loadvm_state():
+     *   - migration/migration.c|1071| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file, &local_err);
+     *   - migration/savevm.c|3504| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f, errp);
+     *   - migration/savevm.c|3590| <<load_snapshot>> ret = qemu_loadvm_state(f, errp);
+     */
     ret = qemu_loadvm_state(f, errp);
     qemu_fclose(f);
     if (ret < 0) {
@@ -3444,6 +3704,14 @@ bool load_snapshot(const char *name, const char *vmstate,
         goto err_drain;
     }
 
+    /*
+     * 在以下使用qemu_system_reset():
+     *   - hw/core/machine.c|1825| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+     *   - hw/xen/xen-hvm-common.c|614| <<cpu_handle_ioreq>> qemu_system_reset(request);
+     *   - migration/savevm.c|3463| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+     *   - system/runstate.c|982| <<main_loop_should_exit>> qemu_system_reset(request);
+     *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+     */
     qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
     mis->from_src_file = f;
 
@@ -3451,6 +3719,12 @@ bool load_snapshot(const char *name, const char *vmstate,
         ret = -EINVAL;
         goto err_drain;
     }
+    /*
+     * 在以下使用qemu_loadvm_state():
+     *   - migration/migration.c|1071| <<process_incoming_migration_co>> ret = qemu_loadvm_state(mis->from_src_file, &local_err);
+     *   - migration/savevm.c|3504| <<qmp_xen_load_devices_state>> ret = qemu_loadvm_state(f, errp);
+     *   - migration/savevm.c|3590| <<load_snapshot>> ret = qemu_loadvm_state(f, errp);
+     */
     ret = qemu_loadvm_state(f, errp);
     migration_incoming_state_destroy();
 
@@ -3469,6 +3743,12 @@ err_drain:
 
 void load_snapshot_resume(RunState state)
 {
+    /*
+     * 在以下使用vm_resume():
+     *   - migration/migration.c|4211| <<bg_migration_vm_start_bh>> vm_resume(s->vm_old_state);
+     *   - migration/savevm.c|3396| <<save_snapshot>> vm_resume(saved_state);
+     *   - migration/savevm.c|3593| <<load_snapshot_resume>> vm_resume(state);
+     */
     vm_resume(state);
     if (state == RUN_STATE_RUNNING && runstate_get() == RUN_STATE_SUSPENDED) {
         qemu_system_wakeup_request(QEMU_WAKEUP_REASON_OTHER, &error_abort);
diff --git a/migration/socket.c b/migration/socket.c
index 9e379bf56..7e568049d 100644
--- a/migration/socket.c
+++ b/migration/socket.c
@@ -129,6 +129,14 @@ static void socket_accept_incoming_migration(QIONetListener *listener,
     }
 
     qio_channel_set_name(QIO_CHANNEL(cioc), "migration-socket-incoming");
+    /*
+     * 在以下使用migration_channel_process_incoming():
+     *   - migration/exec.c|66| <<exec_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/fd.c|81| <<fd_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/file.c|132| <<file_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+     *   - migration/socket.c|132| <<socket_accept_incoming_migration>> migration_channel_process_incoming(QIO_CHANNEL(cioc));
+     *   - migration/tls.c|69| <<migration_tls_incoming_handshake>> migration_channel_process_incoming(ioc);
+     */
     migration_channel_process_incoming(QIO_CHANNEL(cioc));
 }
 
diff --git a/migration/tls.c b/migration/tls.c
index 284a6194b..61067cc3b 100644
--- a/migration/tls.c
+++ b/migration/tls.c
@@ -66,6 +66,14 @@ static void migration_tls_incoming_handshake(QIOTask *task,
         error_report_err(err);
     } else {
         trace_migration_tls_incoming_handshake_complete();
+        /*
+	 * 在以下使用migration_channel_process_incoming():
+         *   - migration/exec.c|66| <<exec_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+         *   - migration/fd.c|81| <<fd_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+         *   - migration/file.c|132| <<file_accept_incoming_migration>> migration_channel_process_incoming(ioc);
+         *   - migration/socket.c|132| <<socket_accept_incoming_migration>> migration_channel_process_incoming(QIO_CHANNEL(cioc));
+         *   - migration/tls.c|69| <<migration_tls_incoming_handshake>> migration_channel_process_incoming(ioc);
+	 */
         migration_channel_process_incoming(ioc);
     }
     object_unref(OBJECT(ioc));
diff --git a/monitor/qmp-cmds.c b/monitor/qmp-cmds.c
index 1ca44fbd7..6b7338208 100644
--- a/monitor/qmp-cmds.c
+++ b/monitor/qmp-cmds.c
@@ -109,6 +109,24 @@ void qmp_cont(Error **errp)
             error_propagate(errp, local_err);
             return;
         }
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+         *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|899| <<vm_resume>> vm_start();
+	 */
         vm_start();
     }
 }
diff --git a/qom/object_interfaces.c b/qom/object_interfaces.c
index 415cbee8c..b40c9789f 100644
--- a/qom/object_interfaces.c
+++ b/qom/object_interfaces.c
@@ -21,6 +21,20 @@
 #include "qemu/config-file.h"
 #include "qemu/keyval.h"
 
+/*
+ * (gdb) bt
+ * #0  qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffcf30) at ../system/physmem.c:2576
+ * #1  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #2  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem-ram.c:34
+ * #3  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem.c:345
+ * #4  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../qom/object_interfaces.c:30
+ * #5  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1101
+ * #6  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1698
+ * #7  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #8  0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #9  0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd438) at ../system/vl.c:3850
+ * #10 0x000055555606daca in main (argc=25, argv=0x7fffffffd438) at ../system/main.c:71
+ */
 bool user_creatable_complete(UserCreatable *uc, Error **errp)
 {
     UserCreatableClass *ucc = USER_CREATABLE_GET_CLASS(uc);
diff --git a/replay/replay-debugging.c b/replay/replay-debugging.c
index 110536400..7fbed6dec 100644
--- a/replay/replay-debugging.c
+++ b/replay/replay-debugging.c
@@ -197,6 +197,24 @@ static void replay_seek(int64_t icount, QEMUTimerCB callback, Error **errp)
     }
     if (replay_get_current_icount() <= icount) {
         replay_break(icount, callback, NULL);
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+         *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|899| <<vm_resume>> vm_start();
+	 */
         vm_start();
     } else {
         error_setg(errp, "cannot seek to the specified instruction count");
diff --git a/system/balloon.c b/system/balloon.c
index 311fa5058..2b1e102b8 100644
--- a/system/balloon.c
+++ b/system/balloon.c
@@ -33,6 +33,15 @@
 #include "qapi/qmp/qerror.h"
 #include "trace.h"
 
+/*
+ * 在以下使用balloon_event_fn:
+ *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+ *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+ *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+ *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+ *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+ *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+ */
 static QEMUBalloonEvent *balloon_event_fn;
 static QEMUBalloonStatus *balloon_stat_fn;
 static void *balloon_opaque;
@@ -44,6 +53,15 @@ static bool have_balloon(Error **errp)
                   "Using KVM without synchronous MMU, balloon unavailable");
         return false;
     }
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     if (!balloon_event_fn) {
         error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,
                   "No balloon device has been activated");
@@ -52,6 +70,13 @@ static bool have_balloon(Error **errp)
     return true;
 }
 
+/*
+ * 在以下使用qemu_add_balloon_handler():
+ *   - hw/hyperv/hv-balloon.c|1504| <<hv_balloon_vmdev_realize>>
+ *         ret = qemu_add_balloon_handler(hv_balloon_to_target, hv_balloon_stat, balloon);
+ *   - hw/virtio/virtio-balloon.c|1317| <<virtio_balloon_device_realize>>
+ *         ret = qemu_add_balloon_handler(virtio_balloon_to_target, virtio_balloon_stat, s);
+ */
 int qemu_add_balloon_handler(QEMUBalloonEvent *event_func,
                              QEMUBalloonStatus *stat_func, void *opaque)
 {
@@ -61,6 +86,15 @@ int qemu_add_balloon_handler(QEMUBalloonEvent *event_func,
          */
         return -1;
     }
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     balloon_event_fn = event_func;
     balloon_stat_fn = stat_func;
     balloon_opaque = opaque;
@@ -72,6 +106,15 @@ void qemu_remove_balloon_handler(void *opaque)
     if (balloon_opaque != opaque) {
         return;
     }
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     balloon_event_fn = NULL;
     balloon_stat_fn = NULL;
     balloon_opaque = NULL;
@@ -102,5 +145,14 @@ void qmp_balloon(int64_t value, Error **errp)
     }
 
     trace_balloon_event(balloon_opaque, value);
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     balloon_event_fn(balloon_opaque, value);
 }
diff --git a/system/cpus.c b/system/cpus.c
index ef2d2f241..24e3203e7 100644
--- a/system/cpus.c
+++ b/system/cpus.c
@@ -140,20 +140,43 @@ void cpu_synchronize_all_states(void)
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_post_reset():
+ *   - hw/i386/pc.c|1735| <<pc_machine_wakeup>> cpu_synchronize_all_post_reset();
+ *   - system/runstate.c|621| <<qemu_system_reset>> cpu_synchronize_all_post_reset();
+ */
 void cpu_synchronize_all_post_reset(void)
 {
     CPUState *cpu;
 
     CPU_FOREACH(cpu) {
+        /*
+	 * 在以下使用cpu_synchronize_post_reset():
+         *   - system/cpus.c|148| <<cpu_synchronize_all_post_reset>> cpu_synchronize_post_reset(cpu);
+         *   - target/s390x/sigp.c|375| <<sigp_initial_cpu_reset>> cpu_synchronize_post_reset(cs);
+         *   - target/s390x/sigp.c|385| <<sigp_cpu_reset>> cpu_synchronize_post_reset(cs);
+	 */
         cpu_synchronize_post_reset(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_post_init():
+ *   - hw/core/machine.c|1782| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|2203| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3289| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3305| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+ */
 void cpu_synchronize_all_post_init(void)
 {
     CPUState *cpu;
 
     CPU_FOREACH(cpu) {
+        /*
+	 * 非s390x在以下使用cpu_synchronize_post_init():
+         *   - hw/core/cpu-common.c|265| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+         *   - system/cpus.c|168| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+	 */
         cpu_synchronize_post_init(cpu);
     }
 }
@@ -169,20 +192,63 @@ void cpu_synchronize_all_pre_loadvm(void)
 
 void cpu_synchronize_state(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|113| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - accel/mshv/mshv-all.c|711| <<mshv_accel_ops_class_init>> ops->synchronize_state = mshv_cpu_synchronize;
+     *   - system/cpus.c|183| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|184| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     if (cpus_accel->synchronize_state) {
         cpus_accel->synchronize_state(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_post_reset():
+ *   - system/cpus.c|148| <<cpu_synchronize_all_post_reset>> cpu_synchronize_post_reset(cpu);
+ *   - target/s390x/sigp.c|375| <<sigp_initial_cpu_reset>> cpu_synchronize_post_reset(cs);
+ *   - target/s390x/sigp.c|385| <<sigp_cpu_reset>> cpu_synchronize_post_reset(cs);
+ */
 void cpu_synchronize_post_reset(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_reset():
+     *   - accel/hvf/hvf-accel-ops.c|379| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - accel/mshv/mshv-all.c|710| <<mshv_accel_ops_class_init>> ops->synchronize_post_reset = mshv_cpu_synchronize_post_reset;
+     *   - system/cpus.c|179| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - system/cpus.c|180| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|90| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|93| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     if (cpus_accel->synchronize_post_reset) {
         cpus_accel->synchronize_post_reset(cpu);
     }
 }
 
+/*
+ * 非s390x在以下使用cpu_synchronize_post_init():
+ *   - hw/core/cpu-common.c|265| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+ *   - system/cpus.c|168| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+ */
 void cpu_synchronize_post_init(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init():
+     *   - accel/hvf/hvf-accel-ops.c|380| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|112| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - accel/mshv/mshv-all.c|709| <<mshv_accel_ops_class_init>> ops->synchronize_post_init = mshv_cpu_synchronize_post_init;
+     *   - system/cpus.c|223| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|224| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|91| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|94| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     *
+     * kvm_cpu_synchronize_post_init()
+     */
     if (cpus_accel->synchronize_post_init) {
         cpus_accel->synchronize_post_init(cpu);
     }
@@ -298,6 +364,22 @@ static int do_vm_stop(RunState state, bool send_stop)
 
     if (runstate_is_live(oldstate)) {
         vm_was_suspended = (oldstate == RUN_STATE_SUSPENDED);
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         runstate_set(state);
         cpu_disable_ticks();
         if (oldstate == RUN_STATE_RUNNING) {
@@ -724,6 +806,21 @@ void qemu_init_vcpu(CPUState *cpu)
 
     /* accelerators all implement the AccelOpsClass */
     g_assert(cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL);
+    /*
+     * 在以下使用AccelOpsClass->create_vcpu_thread:
+     *   - accel/hvf/hvf-accel-ops.c|375| <<hvf_accel_ops_class_init>> ops->create_vcpu_thread = hvf_start_vcpu_thread;
+     *   - accel/kvm/kvm-accel-ops.c|98| <<kvm_accel_ops_class_init>> ops->create_vcpu_thread = kvm_start_vcpu_thread;
+     *   - accel/mshv/mshv-all.c|708| <<mshv_accel_ops_class_init>> ops->create_vcpu_thread = mshv_start_vcpu_thread;
+     *   - accel/qtest/qtest.c|68| <<qtest_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+     *   - accel/tcg/tcg-accel-ops.c|206| <<tcg_accel_ops_init>> ops->create_vcpu_thread = mttcg_start_vcpu_thread;
+     *   - accel/tcg/tcg-accel-ops.c|210| <<tcg_accel_ops_init>> ops->create_vcpu_thread = rr_start_vcpu_thread;
+     *   - accel/xen/xen-all.c|156| <<xen_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+     *   - system/cpus.c|771| <<cpus_register_accel>> assert(ops->create_vcpu_thread != NULL);
+     *   - system/cpus.c|801| <<qemu_init_vcpu>> g_assert(cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL);
+     *   - system/cpus.c|802| <<qemu_init_vcpu>> cpus_accel->create_vcpu_thread(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|86| <<nvmm_accel_ops_class_init>> ops->create_vcpu_thread = nvmm_start_vcpu_thread;
+     *   - target/i386/whpx/whpx-accel-ops.c|88| <<whpx_accel_ops_class_init>> ops->create_vcpu_thread = whpx_start_vcpu_thread;
+     */
     cpus_accel->create_vcpu_thread(cpu);
 
     while (!cpu->created) {
@@ -731,6 +828,13 @@ void qemu_init_vcpu(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用cpu_stop_current():
+ *   - hw/ppc/spapr_rtas.c|79| <<rtas_power_off>> cpu_stop_current();
+ *   - system/cpus.c|804| <<vm_stop>> cpu_stop_current();
+ *   - system/runstate.c|791| <<qemu_system_reset_request>> cpu_stop_current();
+ *   - system/runstate.c|825| <<qemu_system_suspend_request>> cpu_stop_current();
+ */
 void cpu_stop_current(void)
 {
     if (current_cpu) {
@@ -748,6 +852,13 @@ int vm_stop(RunState state)
          * FIXME: should not return to device code in case
          * vm_stop() has been requested.
          */
+        /*
+	 * 在以下使用cpu_stop_current():
+         *   - hw/ppc/spapr_rtas.c|79| <<rtas_power_off>> cpu_stop_current();
+         *   - system/cpus.c|804| <<vm_stop>> cpu_stop_current();
+         *   - system/runstate.c|791| <<qemu_system_reset_request>> cpu_stop_current();
+         *   - system/runstate.c|825| <<qemu_system_suspend_request>> cpu_stop_current();
+	 */
         cpu_stop_current();
         return 0;
     }
@@ -760,6 +871,11 @@ int vm_stop(RunState state)
  * Returns 0 if the vCPUs should be restarted, -1 on an error condition,
  * and 1 otherwise.
  */
+/*
+ * 在以下使用vm_prepare_start():
+ *   - gdbstub/system.c|573| <<gdb_continue_partial>> if (vm_prepare_start(step_requested)) {
+ *   - system/cpus.c|886| <<vm_start>> if (!vm_prepare_start(false)) {
+ */
 int vm_prepare_start(bool step_pending)
 {
     int ret = vm_was_suspended ? 1 : 0;
@@ -792,12 +908,46 @@ int vm_prepare_start(bool step_pending)
     qapi_event_send_resume();
 
     cpu_enable_ticks();
+    /*
+     * 在以下使用runstate_set():
+     *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+     *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+     *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+     *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+     *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+     *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+     *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+     *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+     *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+     *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+     *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+     */
     runstate_set(state);
     vm_state_notify(1, state);
     vm_was_suspended = false;
     return ret;
 }
 
+/*
+ * 在以下使用vm_start():
+ *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+ *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+ *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+ *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+ *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+ *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+ *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+ *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+ *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+ *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+ *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+ *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+ *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+ *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+ *   - system/cpus.c|899| <<vm_resume>> vm_start();
+ */
 void vm_start(void)
 {
     if (!vm_prepare_start(false)) {
@@ -805,23 +955,86 @@ void vm_start(void)
     }
 }
 
+/*
+ * 在以下使用vm_resume():
+ *   - migration/migration.c|4211| <<bg_migration_vm_start_bh>> vm_resume(s->vm_old_state);
+ *   - migration/savevm.c|3396| <<save_snapshot>> vm_resume(saved_state);
+ *   - migration/savevm.c|3593| <<load_snapshot_resume>> vm_resume(state);
+ */
 void vm_resume(RunState state)
 {
     if (runstate_is_live(state)) {
+        /*
+	 * 在以下使用vm_start():
+         *   - dump/dump.c|114| <<dump_cleanup>> vm_start();
+         *   - gdbstub/system.c|551| <<gdb_continue>> vm_start();
+         *   - migration/colo.c|518| <<colo_do_checkpoint_transaction>> vm_start();
+         *   - migration/colo.c|577| <<colo_process_checkpoint>> vm_start();
+         *   - migration/colo.c|768| <<colo_incoming_process_checkpoint>> vm_start();
+         *   - migration/colo.c|876| <<colo_process_incoming_thread>> vm_start();
+         *   - migration/cpr-exec.c|175| <<cpr_exec_cb>> vm_start();
+         *   - migration/migration.c|922| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|945| <<process_incoming_migration_bh>> vm_start();
+         *   - migration/migration.c|3868| <<migration_iteration_finish>> vm_start();
+         *   - migration/savevm.c|2210| <<loadvm_postcopy_handle_run_bh>> vm_start();
+         *   - migration/savevm.c|3425| <<qmp_xen_save_devices_state>> vm_start();
+         *   - monitor/qmp-cmds.c|112| <<qmp_cont>> vm_start();
+         *   - replay/replay-debugging.c|200| <<replay_seek>> vm_start();
+         *   - system/cpus.c|899| <<vm_resume>> vm_start();
+	 */
         vm_start();
     } else {
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         runstate_set(state);
     }
 }
 
 /* does a state transition even if the VM is already stopped,
    current state is forgotten forever */
+/*
+ * 在以下使用vm_stop_force_state():
+ *   - migration/colo.c|216| <<colo_do_failover>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/colo.c|432| <<colo_do_checkpoint_transaction>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/colo.c|668| <<colo_incoming_process_checkpoint>> vm_stop_force_state(RUN_STATE_COLO);
+ *   - migration/migration.c|345| <<migration_stop_vm>> ret = vm_stop_force_state(state);
+ */
 int vm_stop_force_state(RunState state)
 {
     if (runstate_is_live(runstate_get())) {
         return vm_stop(state);
     } else {
         int ret;
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         runstate_set(state);
 
         bdrv_drain_all();
diff --git a/system/main.c b/system/main.c
index b8f7157cc..a435c394b 100644
--- a/system/main.c
+++ b/system/main.c
@@ -41,6 +41,11 @@
 #include <CoreFoundation/CoreFoundation.h>
 #endif
 
+/*
+ * 在以下使用qemu_default_main():
+ *   - system/main.c|90| <<main>> qemu_default_main, NULL, QEMU_THREAD_DETACHED);
+ *   - system/main.c|93| <<main>> qemu_default_main(NULL);
+ */
 static void *qemu_default_main(void *opaque)
 {
     int status;
@@ -55,6 +60,15 @@ static void *qemu_default_main(void *opaque)
     exit(status);
 }
 
+/*
+ * 在以下使用qemu_main函数指针:
+ *   - system/main.c|58| <<global>> int (*qemu_main)(void );
+ *   - system/main.c|66| <<global>> int (*qemu_main)(void ) = os_darwin_cfrunloop_main;
+ *   - system/main.c|87| <<main>> if (qemu_main) {
+ *   - system/main.c|91| <<main>> return qemu_main();
+ *   - ui/gtk.c|2611| <<gtk_display_init>> qemu_main = NULL;
+ *   - ui/sdl2.c|955| <<sdl2_display_init>> qemu_main = NULL;
+ */
 int (*qemu_main)(void);
 
 #ifdef CONFIG_DARWIN
@@ -84,6 +98,15 @@ int main(int argc, char **argv)
     bql_unlock();
     replay_mutex_unlock();
 
+    /*
+     * 在以下使用qemu_main函数指针:
+     *   - system/main.c|58| <<global>> int (*qemu_main)(void );
+     *   - system/main.c|66| <<global>> int (*qemu_main)(void ) = os_darwin_cfrunloop_main;
+     *   - system/main.c|87| <<main>> if (qemu_main) {
+     *   - system/main.c|91| <<main>> return qemu_main();
+     *   - ui/gtk.c|2611| <<gtk_display_init>> qemu_main = NULL;
+     *   - ui/sdl2.c|955| <<sdl2_display_init>> qemu_main = NULL;
+     */
     if (qemu_main) {
         QemuThread main_loop_thread;
         qemu_thread_create(&main_loop_thread, "qemu_main",
diff --git a/system/memory.c b/system/memory.c
index 8b84661ae..33a8517e5 100644
--- a/system/memory.c
+++ b/system/memory.c
@@ -1582,6 +1582,36 @@ bool memory_region_init_ram_nomigrate(MemoryRegion *mr,
                                                   size, 0, errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  ram_block_add (new_block=0x55555783b8a0, errp=0x7fffffffcf50) at ../system/physmem.c:2169
+ * #1  0x0000555555c1a742 in qemu_ram_alloc_internal (size=32212254720, max_size=32212254720, resized=0x0, host=0x0, ram_flags=0, mr=0x555557708470
+ * #2  0x0000555555c1a87b in qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffd000) at ../system/physmem.c:2578
+ * #3  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #4  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem-ram.c:34
+ * #5  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem.c:345
+ * #6  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../qom/object_interfaces.c:30
+ * #7  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1101
+ * #8  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1698
+ * #9  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #10 0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #11 0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd508) at ../system/vl.c:3850
+ * #12 0x000055555606daca in main (argc=25, argv=0x7fffffffd508) at ../system/main.c:71
+ *
+ *
+ * (gdb) bt
+ * #0  qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffcf30) at ../system/physmem.c:2576
+ * #1  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #2  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem-ram.c:34
+ * #3  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem.c:345
+ * #4  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../qom/object_interfaces.c:30
+ * #5  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1101
+ * #6  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1698
+ * #7  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #8  0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #9  0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd438) at ../system/vl.c:3850
+ * #10 0x000055555606daca in main (argc=25, argv=0x7fffffffd438) at ../system/main.c:71
+ */
 bool memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
                                             Object *owner,
                                             const char *name,
@@ -1604,6 +1634,10 @@ bool memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
     return true;
 }
 
+/*
+ * 在以下使用memory_region_init_resizeable_ram():
+ *   - hw/core/loader.c|1039| <<rom_set_mr>> memory_region_init_resizeable_ram(rom->mr, owner, name,
+ */
 bool memory_region_init_resizeable_ram(MemoryRegion *mr,
                                        Object *owner,
                                        const char *name,
@@ -2466,6 +2500,14 @@ ram_addr_t memory_region_get_ram_addr(MemoryRegion *mr)
     return mr->ram_block ? mr->ram_block->offset : RAM_ADDR_INVALID;
 }
 
+/*
+ * 在以下使用memory_region_ram_resize():
+ *   - hw/arm/virt-acpi-build.c|1303| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+ *   - hw/i386/acpi-build.c|2130| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+ *   - hw/loongarch/virt-acpi-build.c|645| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+ *   - hw/nvram/fw_cfg.c|631| <<fw_cfg_update_mr>> memory_region_ram_resize(mr, size, &error_abort);
+ *   - hw/riscv/virt-acpi-build.c|958| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+ */
 void memory_region_ram_resize(MemoryRegion *mr, ram_addr_t newsize, Error **errp)
 {
     assert(mr->ram_block);
@@ -2835,6 +2877,11 @@ bool memory_region_is_mapped(MemoryRegion *mr)
 /* Same as memory_region_find, but it does not add a reference to the
  * returned region.  It must be called from an RCU critical section.
  */
+/*
+ * 在以下使用memory_region_find_rcu():
+ *   - system/memory.c|2888| <<memory_region_find>> ret = memory_region_find_rcu(mr, addr, size);
+ *   - system/memory.c|2927| <<memory_region_present>> mr = memory_region_find_rcu(container, addr, 1).mr;
+ */
 static MemoryRegionSection memory_region_find_rcu(MemoryRegion *mr,
                                                   hwaddr addr, uint64_t size)
 {
diff --git a/system/physmem.c b/system/physmem.c
index c9869e404..e5b9c138a 100644
--- a/system/physmem.c
+++ b/system/physmem.c
@@ -2034,6 +2034,11 @@ static int memory_try_enable_merging(void *addr, size_t len)
  * resize callback to update device state and/or add assertions to detect
  * misuse, if necessary.
  */
+/*
+ * 在以下使用qemu_ram_resize():
+ *   - migration/ram.c|4275| <<parse_ramblock>> ret = qemu_ram_resize(block, length, &local_err);
+ *   - system/memory.c|2503| <<memory_region_ram_resize>> qemu_ram_resize(mr->ram_block, newsize, errp);
+ */
 int qemu_ram_resize(RAMBlock *block, ram_addr_t newsize, Error **errp)
 {
     const ram_addr_t oldsize = block->used_length;
@@ -2165,6 +2170,27 @@ static void dirty_memory_extend(ram_addr_t new_ram_size)
     ram_list.num_dirty_blocks = new_num_blocks;
 }
 
+/*
+ * (gdb) bt
+ * #0  ram_block_add (new_block=0x55555783b8a0, errp=0x7fffffffcf50) at ../system/physmem.c:2169
+ * #1  0x0000555555c1a742 in qemu_ram_alloc_internal (size=32212254720, max_size=32212254720, resized=0x0, host=0x0, ram_flags=0, mr=0x555557708470
+ * #2  0x0000555555c1a87b in qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffd000) at ../system/physmem.c:2578
+ * #3  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #4  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem-ram.c:34
+ * #5  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem.c:345
+ * #6  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../qom/object_interfaces.c:30
+ * #7  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1101
+ * #8  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1698
+ * #9  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #10 0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #11 0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd508) at ../system/vl.c:3850
+ * #12 0x000055555606daca in main (argc=25, argv=0x7fffffffd508) at ../system/main.c:71
+ *
+ *
+ * 在以下使用ram_block_add():
+ *   - system/physmem.c|2389| <<qemu_ram_alloc_from_fd>> ram_block_add(new_block, &local_err);
+ *   - system/physmem.c|2563| <<qemu_ram_alloc_internal>> ram_block_add(new_block, &local_err);
+ */
 static void ram_block_add(RAMBlock *new_block, Error **errp)
 {
     const bool noreserve = qemu_ram_is_noreserve(new_block);
@@ -2475,6 +2501,28 @@ static int qemu_ram_get_shared_fd(const char *name, bool *reused, Error **errp)
 }
 #endif
 
+/*
+ * (gdb) bt
+ * #0  ram_block_add (new_block=0x55555783b8a0, errp=0x7fffffffcf50) at ../system/physmem.c:2169
+ * #1  0x0000555555c1a742 in qemu_ram_alloc_internal (size=32212254720, max_size=32212254720, resized=0x0, host=0x0, ram_flags=0, mr=0x555557708470
+ * #2  0x0000555555c1a87b in qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffd000) at ../system/physmem.c:2578
+ * #3  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #4  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem-ram.c:34
+ * #5  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem.c:345
+ * #6  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../qom/object_interfaces.c:30
+ * #7  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1101
+ * #8  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1698
+ * #9  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #10 0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #11 0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd508) at ../system/vl.c:3850
+ * #12 0x000055555606daca in main (argc=25, argv=0x7fffffffd508) at ../system/main.c:71
+ *
+ *
+ * 在以下使用qemu_ram_alloc_internal():
+ *   - system/physmem.c|2569| <<qemu_ram_alloc_from_ptr>> return qemu_ram_alloc_internal(size, size, NULL, host, RAM_PREALLOC, mr,
+ *   - system/physmem.c|2578| <<qemu_ram_alloc>> return qemu_ram_alloc_internal(size, size, NULL, NULL, ram_flags, mr, errp);
+ *   - system/physmem.c|2585| <<qemu_ram_alloc_resizeable>> return qemu_ram_alloc_internal(size, maxsz, resized, NULL,
+ */
 static
 RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                   qemu_ram_resize_cb resized,
@@ -2570,6 +2618,55 @@ RAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
                                    errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  ram_block_add (new_block=0x55555783b8a0, errp=0x7fffffffcf50) at ../system/physmem.c:2169
+ * #1  0x0000555555c1a742 in qemu_ram_alloc_internal (size=32212254720, max_size=32212254720, resized=0x0, host=0x0, ram_flags=0, mr=0x555557708470
+ * #2  0x0000555555c1a87b in qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffd000) at ../system/physmem.c:2578
+ * #3  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #4  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem-ram.c:34
+ * #5  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../backends/hostmem.c:345
+ * #6  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd1e0) at ../qom/object_interfaces.c:30
+ * #7  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1101
+ * #8  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd1e0) at ../hw/core/machine.c:1698
+ * #9  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #10 0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #11 0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd508) at ../system/vl.c:3850
+ * #12 0x000055555606daca in main (argc=25, argv=0x7fffffffd508) at ../system/main.c:71
+ *
+ *
+ * (gdb) bt
+ * #0  qemu_ram_alloc (size=32212254720, ram_flags=8192, mr=0x555557708470, errp=0x7fffffffcf30) at ../system/physmem.c:2576
+ * #1  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x555557708470, owner=0x555557708400, name=0x555557555a20 "pc.ram", size=32212254720
+ * #2  0x0000555555c318cf in ram_backend_memory_alloc (backend=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem-ram.c:34
+ * #3  0x0000555555c3266c in host_memory_backend_memory_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../backends/hostmem.c:345
+ * #4  0x0000555555f37931 in user_creatable_complete (uc=0x555557708400, errp=0x7fffffffd110) at ../qom/object_interfaces.c:30
+ * #5  0x000055555597429d in create_default_memdev (ms=0x5555577c23b0, path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1101
+ * #6  0x0000555555976375 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1698
+ * #7  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #8  0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #9  0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd438) at ../system/vl.c:3850
+ * #10 0x000055555606daca in main (argc=25, argv=0x7fffffffd438) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  qemu_ram_alloc (size=131072, ram_flags=0, mr=0x5555576322e0, errp=0x7fffffffce30) at ../system/physmem.c:2576
+ * #1  0x0000555555c0a2fb in memory_region_init_ram_flags_nomigrate (mr=0x5555576322e0, owner=0x0, name=0x5555562f65d7 "pc.rom", size=131072
+ * #2  0x0000555555c0a260 in memory_region_init_ram_nomigrate (mr=0x5555576322e0, owner=0x0, name=0x5555562f65d7 "pc.rom", size=131072
+ * #3  0x0000555555c10cff in memory_region_init_ram (mr=0x5555576322e0, owner=0x0, name=0x5555562f65d7 "pc.rom", size=131072
+ * #4  0x0000555555e01d97 in pc_memory_init (pcms=0x5555577c23b0, system_memory=0x55555770f800, rom_memory=0x555557554bc0, pci_hole64_size=34359738368)
+ * #5  0x0000555555de8a50 in pc_q35_init (machine=0x5555577c23b0) at ../hw/i386/pc_q35.c:209
+ * #6  0x0000555555de9386 in pc_q35_machine_10_2_init (machine=0x5555577c23b0) at ../hw/i386/pc_q35.c:382
+ * #7  0x0000555555976519 in machine_run_board_init (machine=0x5555577c23b0, mem_path=0x0, errp=0x7fffffffd110) at ../hw/core/machine.c:1744
+ * #8  0x0000555555bf62de in qemu_init_board () at ../system/vl.c:2716
+ * #9  0x0000555555bf6674 in qmp_x_exit_preconfig (errp=0x5555574cce80 <error_fatal>) at ../system/vl.c:2810
+ * #10 0x0000555555bf9181 in qemu_init (argc=25, argv=0x7fffffffd438) at ../system/vl.c:3850
+ * #11 0x000055555606daca in main (argc=25, argv=0x7fffffffd438) at ../system/main.c:71
+ *
+ *
+ * 在以下使用qemu_ram_alloc():
+ *   - system/memory.c|1597| <<memory_region_init_ram_flags_nomigrate>> mr->ram_block = qemu_ram_alloc(size, ram_flags, mr, &err);
+ *   - system/memory.c|1767| <<memory_region_init_rom_device_nomigrate>> mr->ram_block = qemu_ram_alloc(size, 0, mr, &err);
+ */
 RAMBlock *qemu_ram_alloc(ram_addr_t size, uint32_t ram_flags,
                          MemoryRegion *mr, Error **errp)
 {
@@ -2578,6 +2675,10 @@ RAMBlock *qemu_ram_alloc(ram_addr_t size, uint32_t ram_flags,
     return qemu_ram_alloc_internal(size, size, NULL, NULL, ram_flags, mr, errp);
 }
 
+/*
+ * 在以下使用qemu_ram_alloc_resizeable():
+ *   - system/memory.c|1652| <<memory_region_init_resizeable_ram>> mr->ram_block = qemu_ram_alloc_resizeable(size, max_size, resized,
+ */
 RAMBlock *qemu_ram_alloc_resizeable(ram_addr_t size, ram_addr_t maxsz,
                                     qemu_ram_resize_cb resized,
                                     MemoryRegion *mr, Error **errp)
@@ -2686,6 +2787,24 @@ void qemu_ram_remap(ram_addr_t addr)
             } else if (xen_enabled()) {
                 abort();
             } else {
+                /*
+		 * 在以下使用ram_block_discard_range():
+                 *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+                 *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+                 *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+                 *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+                 *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+                 *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+                 *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+                 *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+                 *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+                 *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+                 *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+                 *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+                 *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+                 *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+                 *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+		 */
                 if (ram_block_discard_range(block, offset, page_size) != 0) {
                     /*
                      * Fall back to using mmap() only for anonymous mapping,
@@ -4091,6 +4210,24 @@ int qemu_ram_foreach_block(RAMBlockIterFunc func, void *opaque)
  * Returns: 0 on success, none-0 on failure
  *
  */
+/*
+ * 在以下使用ram_block_discard_range():
+ *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+ *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+ *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+ *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+ *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+ *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+ *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+ *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+ *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+ *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+ *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+ *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+ *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+ *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+ *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+ */
 int ram_block_discard_range(RAMBlock *rb, uint64_t offset, size_t length)
 {
     int ret = -1;
diff --git a/system/runstate.c b/system/runstate.c
index e3ec16ab7..82c46520b 100644
--- a/system/runstate.c
+++ b/system/runstate.c
@@ -64,6 +64,18 @@
 static NotifierList exit_notifiers =
     NOTIFIER_LIST_INITIALIZER(exit_notifiers);
 
+/*
+ * 在以下使用current_run_state:
+ *   - system/runstate.c|67| <<global>> static RunState current_run_state = RUN_STATE_PRELAUNCH;
+ *   - system/runstate.c|193| <<runstate_check>> return current_run_state == state;
+ *   - system/runstate.c|232| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+ *   - system/runstate.c|235| <<runstate_set>> if (current_run_state == new_state) {
+ *   - system/runstate.c|239| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+ *   - system/runstate.c|241| <<runstate_set>> RunState_str(current_run_state),
+ *   - system/runstate.c|246| <<runstate_set>> current_run_state = new_state;
+ *   - system/runstate.c|251| <<runstate_get>> return current_run_state;
+ *   - system/runstate.c|270| <<qmp_query_status>> info->status = current_run_state;
+ */
 static RunState current_run_state = RUN_STATE_PRELAUNCH;
 
 /* We use RUN_STATE__MAX but any invalid value will do */
@@ -190,6 +202,18 @@ static bool runstate_valid_transitions[RUN_STATE__MAX][RUN_STATE__MAX];
 
 bool runstate_check(RunState state)
 {
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|67| <<global>> static RunState current_run_state = RUN_STATE_PRELAUNCH;
+     *   - system/runstate.c|193| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|232| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|235| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|239| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|241| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|246| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|251| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|270| <<qmp_query_status>> info->status = current_run_state;
+     */
     return current_run_state == state;
 }
 
@@ -224,11 +248,39 @@ static void runstate_init(void)
     qemu_mutex_init(&vmstop_lock);
 }
 
+/*
+ * 在以下使用runstate_set():
+ *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+ *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+ *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+ *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+ *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+ *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+ *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+ *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+ *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+ *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+ *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+ *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+ *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+ */
 /* This function will abort() on invalid state transitions */
 void runstate_set(RunState new_state)
 {
     assert(new_state < RUN_STATE__MAX);
 
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|67| <<global>> static RunState current_run_state = RUN_STATE_PRELAUNCH;
+     *   - system/runstate.c|193| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|232| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|235| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|239| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|241| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|246| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|251| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|270| <<qmp_query_status>> info->status = current_run_state;
+     */
     trace_runstate_set(current_run_state, RunState_str(current_run_state),
                        new_state, RunState_str(new_state));
 
@@ -248,6 +300,18 @@ void runstate_set(RunState new_state)
 
 RunState runstate_get(void)
 {
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|67| <<global>> static RunState current_run_state = RUN_STATE_PRELAUNCH;
+     *   - system/runstate.c|193| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|232| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|235| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|239| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|241| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|246| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|251| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|270| <<qmp_query_status>> info->status = current_run_state;
+     */
     return current_run_state;
 }
 
@@ -267,6 +331,18 @@ StatusInfo *qmp_query_status(Error **errp)
     StatusInfo *info = g_malloc0(sizeof(*info));
 
     info->running = runstate_is_running();
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|67| <<global>> static RunState current_run_state = RUN_STATE_PRELAUNCH;
+     *   - system/runstate.c|193| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|232| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|235| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|239| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|241| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|246| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|251| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|270| <<qmp_query_status>> info->status = current_run_state;
+     */
     info->status = current_run_state;
 
     return info;
@@ -504,6 +580,14 @@ static int qemu_debug_requested(void)
 /*
  * Reset the VM. Issue an event unless @reason is SHUTDOWN_CAUSE_NONE.
  */
+/*
+ * 在以下使用qemu_system_reset():
+ *   - hw/core/machine.c|1825| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+ *   - hw/xen/xen-hvm-common.c|614| <<cpu_handle_ioreq>> qemu_system_reset(request);
+ *   - migration/savevm.c|3463| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+ *   - system/runstate.c|982| <<main_loop_should_exit>> qemu_system_reset(request);
+ *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+ */
 void qemu_system_reset(ShutdownCause reason)
 {
     MachineClass *mc;
@@ -542,6 +626,11 @@ void qemu_system_reset(ShutdownCause reason)
      * it does _more_  than cpu_synchronize_all_post_reset().
      */
     if (cpus_are_resettable()) {
+        /*
+	 * 在以下使用cpu_synchronize_all_post_reset():
+	 *   - hw/i386/pc.c|1735| <<pc_machine_wakeup>> cpu_synchronize_all_post_reset();
+	 *   - system/runstate.c|621| <<qemu_system_reset>> cpu_synchronize_all_post_reset();
+	 */
         cpu_synchronize_all_post_reset();
     } else {
         assert(runstate_check(RUN_STATE_PRELAUNCH));
@@ -688,6 +777,9 @@ void qemu_system_guest_pvshutdown(void)
     qemu_system_shutdown_request(SHUTDOWN_CAUSE_GUEST_SHUTDOWN);
 }
 
+/*
+ * 很多调用
+ */
 void qemu_system_reset_request(ShutdownCause reason)
 {
     if (reboot_action == REBOOT_ACTION_SHUTDOWN &&
@@ -699,6 +791,13 @@ void qemu_system_reset_request(ShutdownCause reason)
     } else {
         reset_requested = reason;
     }
+    /*
+     * 在以下使用cpu_stop_current():
+     *   - hw/ppc/spapr_rtas.c|79| <<rtas_power_off>> cpu_stop_current();
+     *   - system/cpus.c|804| <<vm_stop>> cpu_stop_current();
+     *   - system/runstate.c|791| <<qemu_system_reset_request>> cpu_stop_current();
+     *   - system/runstate.c|825| <<qemu_system_suspend_request>> cpu_stop_current();
+     */
     cpu_stop_current();
     qemu_notify_event();
 }
@@ -707,6 +806,22 @@ static void qemu_system_suspend(void)
 {
     pause_all_vcpus();
     notifier_list_notify(&suspend_notifiers, NULL);
+    /*
+     * 在以下使用runstate_set():
+     *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+     *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+     *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+     *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+     *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+     *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+     *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+     *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+     *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+     *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+     *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+     */
     runstate_set(RUN_STATE_SUSPENDED);
     qapi_event_send_suspend();
 }
@@ -717,6 +832,13 @@ void qemu_system_suspend_request(void)
         return;
     }
     suspend_requested = 1;
+    /*
+     * 在以下使用cpu_stop_current():
+     *   - hw/ppc/spapr_rtas.c|79| <<rtas_power_off>> cpu_stop_current();
+     *   - system/cpus.c|804| <<vm_stop>> cpu_stop_current();
+     *   - system/runstate.c|791| <<qemu_system_reset_request>> cpu_stop_current();
+     *   - system/runstate.c|825| <<qemu_system_suspend_request>> cpu_stop_current();
+     */
     cpu_stop_current();
     qemu_notify_event();
 }
@@ -738,6 +860,22 @@ void qemu_system_wakeup_request(WakeupReason reason, Error **errp)
     if (!(wakeup_reason_mask & (1 << reason))) {
         return;
     }
+    /*
+     * 在以下使用runstate_set():
+     *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+     *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+     *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+     *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+     *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+     *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+     *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+     *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+     *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+     *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+     *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+     */
     runstate_set(RUN_STATE_RUNNING);
     wakeup_reason = reason;
     qemu_notify_event();
@@ -836,6 +974,10 @@ void qemu_system_debug_request(void)
     qemu_notify_event();
 }
 
+/*
+ * 在以下使用main_loop_should_exit():
+ *   - system/runstate.c|1031| <<qemu_main_loop>> while (!main_loop_should_exit(&status)) {
+ */
 static bool main_loop_should_exit(int *status)
 {
     RunState r;
@@ -866,6 +1008,14 @@ static bool main_loop_should_exit(int *status)
     request = qemu_reset_requested();
     if (request) {
         pause_all_vcpus();
+        /*
+	 * 在以下使用qemu_system_reset():
+	 *   - hw/core/machine.c|1825| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+	 *   - hw/xen/xen-hvm-common.c|614| <<cpu_handle_ioreq>> qemu_system_reset(request);
+	 *   - migration/savevm.c|3463| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+	 *   - system/runstate.c|982| <<main_loop_should_exit>> qemu_system_reset(request);
+	 *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+	 */
         qemu_system_reset(request);
         resume_all_vcpus();
         /*
@@ -875,6 +1025,22 @@ static bool main_loop_should_exit(int *status)
         if (!runstate_check(RUN_STATE_RUNNING) &&
                 !runstate_check(RUN_STATE_INMIGRATE) &&
                 !runstate_check(RUN_STATE_FINISH_MIGRATE)) {
+            /*
+	     * 在以下使用runstate_set():
+             *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+             *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+             *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+             *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+             *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+             *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+             *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+             *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+             *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+             *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+             *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+             *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+             *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	     */
             runstate_set(RUN_STATE_PRELAUNCH);
         }
     }
@@ -895,10 +1061,17 @@ static bool main_loop_should_exit(int *status)
     return false;
 }
 
+/*
+ * 在以下使用qemu_main_loop():
+ *   - system/main.c|50| <<qemu_default_main>> status = qemu_main_loop();
+ */
 int qemu_main_loop(void)
 {
     int status = EXIT_SUCCESS;
 
+    /*
+     * 只在这里调用main_loop_should_exit()
+     */
     while (!main_loop_should_exit(&status)) {
         main_loop_wait(false);
     }
diff --git a/system/vl.c b/system/vl.c
index 5091fe52d..a88128d08 100644
--- a/system/vl.c
+++ b/system/vl.c
@@ -3546,6 +3546,22 @@ void qemu_init(int argc, char **argv)
                 break;
             case QEMU_OPTION_incoming:
                 if (!incoming) {
+                    /*
+		     * 在以下使用runstate_set():
+                     *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+                     *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+                     *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+                     *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+                     *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+                     *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+                     *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+                     *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+                     *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+		     *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+		     *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+		     *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+		     *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+		     */
                     runstate_set(RUN_STATE_INMIGRATE);
                 }
                 incoming_option_parse(optarg);
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 641777578..ad00b88bf 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -2128,6 +2128,21 @@ static uint64_t x86_cpu_get_migratable_flags(X86CPU *cpu, FeatureWord w)
         }
     }
 
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     /* when tsc-khz is set explicitly, invtsc is migratable */
     if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
         r |= CPUID_APM_INVTSC;
@@ -7055,6 +7070,67 @@ static void x86_cpuid_get_tsc_freq(Object *obj, Visitor *v, const char *name,
     visit_type_int(v, name, &value, errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_cpuid_set_tsc_freq (obj=0x5555574c2ff0, v=0x5555574ce7f0,
+ * #1  0x0000555555d19a58 in object_property_set (obj=obj@entry=0x5555574c2ff0,
+ * #2  0x0000555555d19db3 in object_property_parse (errp=0x7fffffffceb0,
+ * #3  object_apply_global_props (obj=0x5555574c2ff0, props=0x5555571daa60,
+ * #4  0x0000555555d17b78 in object_post_init_with_type (ti=0x5555571d23d0,
+ * #5  object_post_init_with_type (obj=0x5555574c2ff0, ti=0x555557172a00)
+ * #6  0x0000555555d18ebc in object_post_init_with_type (ti=0x5555571ba030,
+ * #7  object_post_init_with_type (ti=0x5555571cde80, obj=0x5555574c2ff0)
+ * #8  object_post_init_with_type (ti=0x5555571ce1e0, obj=0x5555574c2ff0)
+ * #9  object_initialize_with_type (obj=0x5555574c2ff0, size=<optimized out>,
+ * #10 0x0000555555d190b9 in object_new_with_type (type=0x5555571ce1e0)
+ * #11 0x0000555555c3b714 in x86_cpu_new (errp=<optimized out>, apic_id=0,
+ * #12 x86_cpus_init (x86ms=x86ms@entry=0x555557448ff0, default_cpu_version=<optimized out>)
+ * #13 0x0000555555c40c6a in pc_q35_init (machine=0x555557448ff0) at ../hw/i386/pc_q35.c:194
+ * #14 0x00005555559481d4 in machine_run_board_init (machine=<optimized out>,
+ * #15 0x0000555555aec598 in qemu_init_board () at ../system/vl.c:2716
+ * #16 qmp_x_exit_preconfig (errp=0x555557154930 <error_fatal>) at ../system/vl.c:2810
+ * #17 0x0000555555aeff29 in qemu_init (argc=<optimized out>, argv=<optimized out>)
+ * #18 0x00005555558916b9 in main (argc=<optimized out>, argv=<optimized out>)
+ *
+ * (gdb) bt
+ * #0  x86_cpuid_set_tsc_freq (obj=0x5555575135d0, v=0x555557c18010,
+ * #1  0x0000555555d19a58 in object_property_set (obj=obj@entry=0x5555575135d0,
+ * #2  0x0000555555d19db3 in object_property_parse (errp=0x7fffffffbec0, string=<optimized out>,
+ * #3  object_apply_global_props (obj=0x5555575135d0, props=0x5555571daa60, errp=0x0)
+ * #4  0x0000555555d17b78 in object_post_init_with_type (ti=0x5555571d23d0, obj=0x5555575135d0)
+ * #5  object_post_init_with_type (obj=0x5555575135d0, ti=0x555557172a00) at ../qom/object.c:435
+ * #6  0x0000555555d18ebc in object_post_init_with_type (ti=0x5555571ba030, obj=0x5555575135d0)
+ * #7  object_post_init_with_type (ti=0x5555571cde80, obj=0x5555575135d0) at ../qom/object.c:435
+ * #8  object_post_init_with_type (ti=0x5555571ce1e0, obj=0x5555575135d0) at ../qom/object.c:435
+ * #9  object_initialize_with_type (obj=0x5555575135d0, size=<optimized out>, type=0x5555571ce1e0)
+ * #10 0x0000555555d190b9 in object_new_with_type (type=0x5555571ce1e0) at ../qom/object.c:774
+ * #11 0x0000555555d136c9 in qdev_new (name=name@entry=0x5555574cf610 "host-x86_64-cpu")
+ * #12 0x0000555555b108d1 in qdev_device_add_from_qdict (opts=opts@entry=0x5555574f6400,
+ * #13 0x0000555555b10ff2 in qdev_device_add (opts=opts@entry=0x555557ea51a0,
+ * #14 0x0000555555b114d3 in hmp_device_add (mon=0x555557466090, qdict=<optimized out>)
+ * #15 0x0000555555b581a9 in handle_hmp_command_exec (cmd=<optimized out>, cmd=<optimized out>,
+ * #16 handle_hmp_command_exec (qdict=0x5555574db000, cmd=0x555557034b60 <hmp_cmds+1920>,
+ * #17 handle_hmp_command (mon=mon@entry=0x555557466090, cmdline=<optimized out>,
+ * #18 0x0000555555b5828d in monitor_command_cb (opaque=0x555557466090,
+ * #19 0x0000555555eb8f94 in readline_handle_byte (rs=0x555557482f70, ch=<optimized out>)
+ * #20 0x0000555555b582db in monitor_read (opaque=0x555557466090, buf=<optimized out>,
+ * #21 0x0000555555df2c6d in fd_chr_read (chan=0x55555743dc40, cond=<optimized out>,
+ * #22 0x00007ffff7eb7854 in g_main_dispatch (context=0x5555571de320) at ../glib/gmain.c:3325
+ * #23 g_main_context_dispatch (context=0x5555571de320) at ../glib/gmain.c:4043
+ * #24 0x0000555555ead908 in glib_pollfds_poll () at ../util/main-loop.c:290
+ * #25 os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:313
+ * #26 main_loop_wait (nonblocking=nonblocking@entry=0) at ../util/main-loop.c:592
+ * #27 0x0000555555b15959 in qemu_main_loop () at ../system/runstate.c:903
+ * #28 0x0000555555df795c in qemu_default_main (opaque=opaque@entry=0x0) at ../system/main.c:50
+ * #29 0x0000555555891715 in main (argc=<optimized out>, argv=<optimized out>)
+ *
+ * 在以下使用x86_cpuid_set_tsc_freq():
+ *   - target/i386/cpu.c|10149| <<x86_cpu_common_class_init>> x86_cpuid_set_tsc_freq, NULL, NULL);
+ *
+ * 10181     object_class_property_add(oc, "tsc-frequency", "int",
+ * 10182                               x86_cpuid_get_tsc_freq,
+ * 10183                               x86_cpuid_set_tsc_freq, NULL, NULL);
+ */
 static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, const char *name,
                                    void *opaque, Error **errp)
 {
@@ -7071,6 +7147,27 @@ static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, const char *name,
         return;
     }
 
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     *
+     *
+     * 三个设置env->tsc_khz的地方:
+     *   - target/i386/cpu.c|7112| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/hvf/hvf.c|188| <<init_tsc_freq>> env->tsc_khz = tsc_freq / 1000;
+     *   - target/i386/kvm/kvm.c|2200| <<kvm_arch_init_vcpu>> env->tsc_khz = r;
+     */
     cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
 }
 
@@ -8614,6 +8711,10 @@ static bool cpuid_has_xsave_feature(CPUX86State *env, const ExtSaveArea *esa)
     return false;
 }
 
+/*
+ * 在以下使用x86_cpu_reset_hold():
+ *   - target/i386/cpu.c|10094| <<x86_cpu_common_class_init>> resettable_class_set_parent_phases(rc, NULL, x86_cpu_reset_hold, NULL,
+ */
 static void x86_cpu_reset_hold(Object *obj, ResetType type)
 {
     CPUState *cs = CPU(obj);
@@ -8628,6 +8729,9 @@ static void x86_cpu_reset_hold(Object *obj, ResetType type)
         xcc->parent_phases.hold(obj, type);
     }
 
+    /*
+     * 只在这里使用end_reset_fields
+     */
     memset(env, 0, offsetof(CPUX86State, end_reset_fields));
 
     if (tcg_enabled()) {
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index cee1f692a..6da5bac45 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -2058,6 +2058,10 @@ typedef struct CPUArchState {
     uint64_t msr_rapl_power_unit;
     uint64_t msr_pkg_energy_status;
 
+    /*
+     * 在以下使用CPUX86State->end_reset_fields(CPUArchState):
+     *   - target/i386/cpu.c|8631| <<x86_cpu_reset_hold>> memset(env, 0, offsetof(CPUX86State, end_reset_fields));
+     */
     /* Fields up to this point are cleared by a CPU reset */
     struct {} end_reset_fields;
 
@@ -2111,8 +2115,34 @@ typedef struct CPUArchState {
     uint8_t triple_fault_pending;
     uint32_t ins_len;
     uint32_t sipi_vector;
+    /*
+     * 在以下使用CPUX86State->tsc_valid(CPUArchState):
+     *   - target/i386/kvm/kvm.c|307| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|311| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|846| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4483| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4485| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2130| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     bool tsc_valid;
     int64_t tsc_khz;
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     int64_t user_tsc_khz; /* for sanity check only */
     uint64_t apic_bus_freq;
     uint64_t tsc;
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 60c798113..4da838a6f 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -73,6 +73,53 @@
 
 #include CONFIG_DEVICES
 
+/*
+ * 每一个vCPU的创建.
+ *
+ * kvm_arch_init_vcpu()
+ * -> kvm_arch_set_tsc_khz() -> 如果tsc-frequency设置了, 就更新KVM
+ * -> 如果没有tsc-frequency, 用env->tsc_khz=KVM_GET_TSC_KHZ
+ *
+ * 也就是说, env->tsc_khz要么被tsc-frequency设置,
+ * 要么来自per-vcpu的KVM_GET_TSC_KHZ
+ *
+ *
+ * QEMU创建结束
+ *
+ * qdev_machine_creation_done()
+ * -> cpu_synchronize_all_post_init()
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ * 
+ *
+ * 这是hotplug一个vCPU的时候
+ * 
+ * cpu_common_realizefn()
+ * -> cpu_synchronize_post_init() 只有hotplug的时候调用
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ *
+ *
+ * 这是迁移的时候在target
+ *
+ * qemu_loadvm_state()
+ * -> cpu_synchronize_all_post_init()
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ */
+
 //#define DEBUG_KVM
 
 #ifdef DEBUG_KVM
@@ -297,6 +344,10 @@ bool kvm_hv_vpindex_settable(void)
     return hv_vpindex_settable;
 }
 
+/*
+ * 在以下使用kvm_get_tsc():
+ *   - target/i386/kvm/kvm.c|324| <<do_kvm_synchronize_tsc>> kvm_get_tsc(cpu);
+ */
 static int kvm_get_tsc(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -304,6 +355,17 @@ static int kvm_get_tsc(CPUState *cs)
     uint64_t value;
     int ret;
 
+    /*
+     * 在以下使用CPUX86State->tsc_valid(CPUArchState):
+     *   - target/i386/kvm/kvm.c|307| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|311| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|846| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4483| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4485| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2130| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     if (env->tsc_valid) {
         return 0;
     }
@@ -319,11 +381,19 @@ static int kvm_get_tsc(CPUState *cs)
     return 0;
 }
 
+/*
+ * 在以下使用do_kvm_synchronize_tsc():
+ *   - target/i386/kvm/kvm.c|333| <<kvm_synchronize_all_tsc>> run_on_cpu(cpu, do_kvm_synchronize_tsc, RUN_ON_CPU_NULL);
+ */
 static inline void do_kvm_synchronize_tsc(CPUState *cpu, run_on_cpu_data arg)
 {
     kvm_get_tsc(cpu);
 }
 
+/*
+ * 在以下使用kvm_synchronize_all_tsc():
+ *   - hw/i386/kvm/clock.c|285| <<kvmclock_vm_state_change>> kvm_synchronize_all_tsc();
+ */
 void kvm_synchronize_all_tsc(void)
 {
     CPUState *cpu;
@@ -838,11 +908,26 @@ static void kvm_queue_exception(CPUX86State *env,
     }
 }
 
+/*
+ * 在以下使用cpu_update_state():
+ *   - target/i386/kvm/kvm.c|2333| <<kvm_arch_init_vcpu>> cpu->vmsentry = qemu_add_vm_change_state_handler(cpu_update_state, env);
+ */
 static void cpu_update_state(void *opaque, bool running, RunState state)
 {
     CPUX86State *env = opaque;
 
     if (running) {
+        /*
+         * 在以下使用CPUX86State->tsc_valid(CPUArchState):
+         *   - target/i386/kvm/kvm.c|307| <<kvm_get_tsc>> if (env->tsc_valid) {
+         *   - target/i386/kvm/kvm.c|311| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/kvm/kvm.c|846| <<cpu_update_state>> env->tsc_valid = false;
+         *   - target/i386/kvm/kvm.c|4483| <<kvm_get_msrs>> if (!env->tsc_valid) {
+         *   - target/i386/kvm/kvm.c|4485| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+         *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/whpx/whpx-all.c|2130| <<whpx_cpu_update_state>> env->tsc_valid = false;
+	 */
         env->tsc_valid = false;
     }
 }
@@ -868,6 +953,10 @@ static bool hyperv_enabled(X86CPU *cpu)
  * Check whether target_freq is within conservative
  * ntp correctable bounds (250ppm) of freq
  */
+/*
+ * 在以下使用freq_within_bounds():
+ *   - target/i386/kvm/kvm.c|972| <<kvm_arch_set_tsc_khz>> if (cur_freq != -ENOTSUP && freq_within_bounds(cur_freq, env->tsc_khz)) {
+ */
 static inline bool freq_within_bounds(int freq, int target_freq)
 {
         int max_freq = freq + (freq * 250 / 1000000);
@@ -880,6 +969,65 @@ static inline bool freq_within_bounds(int freq, int target_freq)
         return false;
 }
 
+/*
+ * 每一个vCPU的创建.
+ *
+ * kvm_arch_init_vcpu()
+ * -> kvm_arch_set_tsc_khz() -> 如果tsc-frequency设置了, 就更新KVM
+ * -> 如果没有tsc-frequency, 用env->tsc_khz=KVM_GET_TSC_KHZ
+ *
+ * 也就是说, env->tsc_khz要么被tsc-frequency设置,
+ * 要么来自per-vcpu的KVM_GET_TSC_KHZ
+ *
+ *
+ * QEMU创建结束
+ *
+ * qdev_machine_creation_done()
+ * -> cpu_synchronize_all_post_init()
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ * 
+ *
+ * 这是hotplug一个vCPU的时候
+ * 
+ * cpu_common_realizefn()
+ * -> cpu_synchronize_post_init() 只有hotplug的时候调用
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ *
+ *
+ * 这是迁移的时候在target
+ *
+ * qemu_loadvm_state()
+ * -> cpu_synchronize_all_post_init()
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ */
+
+/*
+ * 在以下使用kvm_arch_set_tsc_khz():
+ *   - target/i386/kvm/kvm.c|2185| <<kvm_arch_init_vcpu>> r = kvm_arch_set_tsc_khz(cs);
+ *   - target/i386/kvm/kvm.c|5440| <<kvm_arch_put_registers>> kvm_arch_set_tsc_khz(cpu);
+ *
+ * kvm_arch_set_tsc_khz()会用KVM_GET_TSC_KHZ
+ * 但是不设置env->tsc_khz
+ * 三个设置env->tsc_khz的地方:
+ *   - target/i386/cpu.c|7112| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+ *   - target/i386/hvf/hvf.c|188| <<init_tsc_freq>> env->tsc_khz = tsc_freq / 1000;
+ *   - target/i386/kvm/kvm.c|2200| <<kvm_arch_init_vcpu>> env->tsc_khz = r;
+ */
 static int kvm_arch_set_tsc_khz(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -896,10 +1044,22 @@ static int kvm_arch_set_tsc_khz(CPUState *cs)
         return 0;
     }
 
+    /*
+     * 三个设置env->tsc_khz的地方:
+     *   - target/i386/cpu.c|7112| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/hvf/hvf.c|188| <<init_tsc_freq>> env->tsc_khz = tsc_freq / 1000;
+     *   - target/i386/kvm/kvm.c|2200| <<kvm_arch_init_vcpu>> env->tsc_khz = r;
+     */
     if (!env->tsc_khz) {
         return 0;
     }
 
+    /*
+     * 在以下使用KVM_GET_TSC_KHZ:
+     *   - target/i386/kvm/kvm.c|942| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) : -ENOTSUP;
+     *   - target/i386/kvm/kvm.c|973| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :
+     *   - target/i386/kvm/kvm.c|2197| <<kvm_arch_init_vcpu>> kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :
+     */
     cur_freq = kvm_check_extension(cs->kvm_state, KVM_CAP_GET_TSC_KHZ) ?
                kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) : -ENOTSUP;
 
@@ -918,6 +1078,11 @@ static int kvm_arch_set_tsc_khz(CPUState *cs)
         set_ioctl = true;
     }
 
+    /*
+     * 在以下使用KVM_SET_TSC_KHZ:
+     *   - target/i386/kvm/kvm.c|922| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :
+     *   - target/i386/kvm/tdx.c|1027| <<tdx_pre_create_vcpu>> r = kvm_vm_ioctl(kvm_state, KVM_SET_TSC_KHZ, env->tsc_khz);
+     */
     r = set_ioctl ?
         kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :
         -ENOTSUP;
@@ -926,6 +1091,12 @@ static int kvm_arch_set_tsc_khz(CPUState *cs)
         /* When KVM_SET_TSC_KHZ fails, it's an error only if the current
          * TSC frequency doesn't match the one we want.
          */
+        /*
+	 * 在以下使用KVM_GET_TSC_KHZ:
+	 *   - target/i386/kvm/kvm.c|942| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) : -ENOTSUP;
+	 *   - target/i386/kvm/kvm.c|973| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :
+	 *   - target/i386/kvm/kvm.c|2197| <<kvm_arch_init_vcpu>> kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :
+	 */
         cur_freq = kvm_check_extension(cs->kvm_state, KVM_CAP_GET_TSC_KHZ) ?
                    kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :
                    -ENOTSUP;
@@ -946,6 +1117,21 @@ static bool tsc_is_stable_and_known(CPUX86State *env)
     if (!env->tsc_khz) {
         return false;
     }
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     return (env->features[FEAT_8000_0007_EDX] & CPUID_APM_INVTSC)
         || env->user_tsc_khz;
 }
@@ -2077,6 +2263,10 @@ full:
     abort();
 }
 
+/*
+ * 在以下使用kvm_arch_pre_create_vcpu():
+ *   - accel/kvm/kvm-all.c|576| <<kvm_init_vcpu>> ret = kvm_arch_pre_create_vcpu(cpu, errp);
+ */
 int kvm_arch_pre_create_vcpu(CPUState *cpu, Error **errp)
 {
     if (is_tdx_vm()) {
@@ -2086,6 +2276,10 @@ int kvm_arch_pre_create_vcpu(CPUState *cpu, Error **errp)
     return 0;
 }
 
+/*
+ * 在以下使用kvm_arch_init_vcpu():
+ *   - accel/kvm/kvm-all.c|620| <<kvm_init_vcpu>> ret = kvm_arch_init_vcpu(cpu);
+ */
 int kvm_arch_init_vcpu(CPUState *cs)
 {
     struct {
@@ -2124,21 +2318,51 @@ int kvm_arch_init_vcpu(CPUState *cs)
 
     has_xsave2 = kvm_check_extension(cs->kvm_state, KVM_CAP_XSAVE2);
 
+    /*
+     * 在以下使用kvm_arch_set_tsc_khz():
+     *   - target/i386/kvm/kvm.c|2185| <<kvm_arch_init_vcpu>> r = kvm_arch_set_tsc_khz(cs);
+     *   - target/i386/kvm/kvm.c|5440| <<kvm_arch_put_registers>> kvm_arch_set_tsc_khz(cpu);
+     *
+     * kvm_arch_set_tsc_khz()会用KVM_GET_TSC_KHZ
+     * 但是不设置env->tsc_khz
+     * 三个设置env->tsc_khz的地方:
+     *   - target/i386/cpu.c|7112| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/hvf/hvf.c|188| <<init_tsc_freq>> env->tsc_khz = tsc_freq / 1000;
+     *   - target/i386/kvm/kvm.c|2200| <<kvm_arch_init_vcpu>> env->tsc_khz = r;
+     */
     r = kvm_arch_set_tsc_khz(cs);
     if (r < 0) {
         return r;
     }
 
+    /*
+     * 三个设置env->tsc_khz的地方:
+     *   - target/i386/cpu.c|7112| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/hvf/hvf.c|188| <<init_tsc_freq>> env->tsc_khz = tsc_freq / 1000;
+     *   - target/i386/kvm/kvm.c|2200| <<kvm_arch_init_vcpu>> env->tsc_khz = r;
+     */
     /* vcpu's TSC frequency is either specified by user, or following
      * the value used by KVM if the former is not present. In the
      * latter case, we query it from KVM and record in env->tsc_khz,
      * so that vcpu's TSC frequency can be migrated later via this field.
      */
     if (!env->tsc_khz) {
+        /*
+	 * 在以下使用KVM_GET_TSC_KHZ:
+	 *   - target/i386/kvm/kvm.c|942| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) : -ENOTSUP;
+         *   - target/i386/kvm/kvm.c|973| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :
+         *   - target/i386/kvm/kvm.c|2197| <<kvm_arch_init_vcpu>> kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :
+	 */
         r = kvm_check_extension(cs->kvm_state, KVM_CAP_GET_TSC_KHZ) ?
             kvm_vcpu_ioctl(cs, KVM_GET_TSC_KHZ) :
             -ENOTSUP;
         if (r > 0) {
+            /*
+	     * 三个设置env->tsc_khz的地方:
+	     *   - target/i386/cpu.c|7112| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+	     *   - target/i386/hvf/hvf.c|188| <<init_tsc_freq>> env->tsc_khz = tsc_freq / 1000;
+	     *   - target/i386/kvm/kvm.c|2200| <<kvm_arch_init_vcpu>> env->tsc_khz = r;
+	     */
             env->tsc_khz = r;
         }
     }
@@ -2209,6 +2433,21 @@ int kvm_arch_init_vcpu(CPUState *cs)
             (!!(env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_RDTSCP) << 2));
         /* default=0 (emulate if necessary) */
         c->ebx = 0;
+        /*
+	 * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+	 *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+         *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+         *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+         *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+         *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+         *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+         *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+         *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+         *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+         *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+         *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+         *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+	 */
         /* guest tsc frequency */
         c->ecx = env->user_tsc_khz;
         /* guest tsc incarnation (migration count) */
@@ -2330,6 +2569,21 @@ int kvm_arch_init_vcpu(CPUState *cs)
         has_msr_mcg_ext_ctl = has_msr_feature_control = true;
     }
 
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     if (!env->user_tsc_khz) {
         if ((env->features[FEAT_8000_0007_EDX] & CPUID_APM_INVTSC) &&
             invtsc_mig_blocker == NULL) {
@@ -2455,6 +2709,10 @@ void kvm_arch_after_reset_vcpu(X86CPU *cpu)
     }
 }
 
+/*
+ * 在以下使用kvm_arch_reset_parked_vcpu():
+ *   - accel/kvm/kvm-all.c|459| <<kvm_reset_parked_vcpus>> kvm_arch_reset_parked_vcpu(cpu->vcpu_id, cpu->kvm_fd);
+ */
 void kvm_arch_reset_parked_vcpu(unsigned long vcpu_id, int kvm_fd)
 {
     g_autofree struct kvm_msrs *msrs = NULL;
@@ -4471,6 +4729,17 @@ static int kvm_get_msrs(X86CPU *cpu)
     if (has_msr_virt_ssbd) {
         kvm_msr_entry_add(cpu, MSR_VIRT_SSBD, 0);
     }
+    /*
+     * 在以下使用CPUX86State->tsc_valid(CPUArchState):
+     *   - target/i386/kvm/kvm.c|307| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|311| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|846| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4483| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4485| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2130| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     if (!env->tsc_valid) {
         kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);
         env->tsc_valid = !runstate_is_running();
@@ -5293,6 +5562,10 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * 在以下使用kvm_arch_put_registers():
+ *   - accel/kvm/kvm-all.c|2974| <<kvm_cpu_synchronize_put>> int ret = kvm_arch_put_registers(cpu, state, &err);
+ */
 int kvm_arch_put_registers(CPUState *cpu, KvmPutState level, Error **errp)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -5334,6 +5607,18 @@ int kvm_arch_put_registers(CPUState *cpu, KvmPutState level, Error **errp)
          * unless the user explicitly asked for a more strict TSC
          * setting (e.g. using an explicit "tsc-freq" option).
          */
+        /*
+	 * 在以下使用kvm_arch_set_tsc_khz():
+         *   - target/i386/kvm/kvm.c|2185| <<kvm_arch_init_vcpu>> r = kvm_arch_set_tsc_khz(cs);
+         *   - target/i386/kvm/kvm.c|5440| <<kvm_arch_put_registers>> kvm_arch_set_tsc_khz(cpu);
+	 *
+	 * kvm_arch_set_tsc_khz()会用KVM_GET_TSC_KHZ
+         * 但是不设置env->tsc_khz
+         * 三个设置env->tsc_khz的地方:
+         *   - target/i386/cpu.c|7112| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+         *   - target/i386/hvf/hvf.c|188| <<init_tsc_freq>> env->tsc_khz = tsc_freq / 1000;
+         *   - target/i386/kvm/kvm.c|2200| <<kvm_arch_init_vcpu>> env->tsc_khz = r;
+	 */
         kvm_arch_set_tsc_khz(cpu);
     }
 
diff --git a/target/i386/kvm/tdx.c b/target/i386/kvm/tdx.c
index dbf0fa2c9..ad7be068c 100644
--- a/target/i386/kvm/tdx.c
+++ b/target/i386/kvm/tdx.c
@@ -978,6 +978,57 @@ static void tdx_filter_cpuid(struct kvm_cpuid2 *cpuids)
     cpuids->nent = dest_cnt++;
 }
 
+/*
+ * 每一个vCPU的创建.
+ *
+ * kvm_arch_init_vcpu()
+ * -> kvm_arch_set_tsc_khz() -> 如果tsc-frequency设置了, 就更新KVM
+ * -> 如果没有tsc-frequency, 用env->tsc_khz=KVM_GET_TSC_KHZ
+ *
+ * 也就是说, env->tsc_khz要么被tsc-frequency设置,
+ * 要么来自per-vcpu的KVM_GET_TSC_KHZ
+ *
+ *
+ * QEMU创建结束
+ *
+ * qdev_machine_creation_done()
+ * -> cpu_synchronize_all_post_init()
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ *
+ *
+ * 这是hotplug一个vCPU的时候
+ *
+ * cpu_common_realizefn()
+ * -> cpu_synchronize_post_init() 只有hotplug的时候调用
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ *
+ *
+ * 这是迁移的时候在target
+ *
+ * qemu_loadvm_state()
+ * -> cpu_synchronize_all_post_init()
+ *    -> ops->synchronize_post_init = kvm_cpu_synchronize_post_init()
+ *       -> do_kvm_cpu_synchronize_post_init()
+ *          -> kvm_cpu_synchronize_put()
+ *             -> kvm_arch_put_registers()
+ *                -> kvm_arch_set_tsc_khz()
+ *                   -> KVM_SET_TSC_KHZ
+ */
+
+/*
+ * 在以下使用tdx_pre_create_vcpu():
+ *   - target/i386/kvm/kvm.c|2269| <<kvm_arch_pre_create_vcpu>> return tdx_pre_create_vcpu(cpu, errp);
+ */
 int tdx_pre_create_vcpu(CPUState *cpu, Error **errp)
 {
     X86CPU *x86cpu = X86_CPU(cpu);
@@ -989,6 +1040,11 @@ int tdx_pre_create_vcpu(CPUState *cpu, Error **errp)
     int r = 0;
 
     QEMU_LOCK_GUARD(&tdx_guest->lock);
+    /*
+     * 在以下使用TdxGuest->initialized:
+     *   - target/i386/kvm/tdx.c|1043| <<tdx_pre_create_vcpu>> if (tdx_guest->initialized) {
+     *   - target/i386/kvm/tdx.c|1175| <<tdx_pre_create_vcpu>> tdx_guest->initialized = true;
+     */
     if (tdx_guest->initialized) {
         return r;
     }
@@ -1023,6 +1079,11 @@ int tdx_pre_create_vcpu(CPUState *cpu, Error **errp)
         return -EINVAL;
     }
 
+    /*
+     * 在以下使用KVM_SET_TSC_KHZ:
+     *   - target/i386/kvm/kvm.c|922| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :
+     *   - target/i386/kvm/tdx.c|1027| <<tdx_pre_create_vcpu>> r = kvm_vm_ioctl(kvm_state, KVM_SET_TSC_KHZ, env->tsc_khz);
+     */
     /* it's safe even env->tsc_khz is 0. KVM uses host's tsc_khz in this case */
     r = kvm_vm_ioctl(kvm_state, KVM_SET_TSC_KHZ, env->tsc_khz);
     if (r < 0) {
diff --git a/target/i386/machine.c b/target/i386/machine.c
index 45b7cea80..186bcf754 100644
--- a/target/i386/machine.c
+++ b/target/i386/machine.c
@@ -317,6 +317,21 @@ static int cpu_post_load(void *opaque, int version_id)
     CPUX86State *env = &cpu->env;
     int i;
 
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     if (env->tsc_khz && env->user_tsc_khz &&
         env->tsc_khz != env->user_tsc_khz) {
         error_report("Mismatch between user-specified TSC frequency and "
@@ -924,6 +939,21 @@ static int hyperv_reenlightenment_post_load(void *opaque, int version_id)
     X86CPU *cpu = opaque;
     CPUX86State *env = &cpu->env;
 
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     /*
      * KVM doesn't fully support re-enlightenment notifications so we need to
      * make sure TSC frequency doesn't change upon migration.
diff --git a/ui/vnc.c b/ui/vnc.c
index e6bcf0e1c..3195ee888 100644
--- a/ui/vnc.c
+++ b/ui/vnc.c
@@ -2541,6 +2541,11 @@ static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)
                 send_xvp_message(vs, VNC_XVP_CODE_FAIL);
                 break;
             case VNC_XVP_ACTION_RESET:
+                /*
+		 * 在以下使用SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET:
+                 *   - hw/core/machine-qmp-cmds.c|305| <<qmp_system_reset>> qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
+                 *   - ui/vnc.c|2544| <<protocol_client_msg>> qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
+		 */
                 qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
                 break;
             default:
diff --git a/util/main-loop.c b/util/main-loop.c
index b462598f7..15756bb44 100644
--- a/util/main-loop.c
+++ b/util/main-loop.c
@@ -133,6 +133,12 @@ static int qemu_signal_init(Error **errp)
 #endif
 
 static AioContext *qemu_aio_context;
+/*
+ * 在以下使用qemu_notify_bh:
+ *   - util/main-loop.c|136| <<global>> static QEMUBH *qemu_notify_bh;
+ *   - util/main-loop.c|155| <<qemu_notify_event>> qemu_bh_schedule(qemu_notify_bh);
+ *   - util/main-loop.c|177| <<qemu_init_main_loop>> qemu_notify_bh = qemu_bh_new(notify_event_cb, NULL);
+ */
 static QEMUBH *qemu_notify_bh;
 
 static void notify_event_cb(void *opaque)
@@ -152,6 +158,12 @@ void qemu_notify_event(void)
     if (!qemu_aio_context) {
         return;
     }
+    /*
+     * 在以下使用qemu_notify_bh:
+     *   - util/main-loop.c|136| <<global>> static QEMUBH *qemu_notify_bh;
+     *   - util/main-loop.c|155| <<qemu_notify_event>> qemu_bh_schedule(qemu_notify_bh);
+     *   - util/main-loop.c|177| <<qemu_init_main_loop>> qemu_notify_bh = qemu_bh_new(notify_event_cb, NULL);
+     */
     qemu_bh_schedule(qemu_notify_bh);
 }
 
@@ -174,6 +186,12 @@ int qemu_init_main_loop(Error **errp)
         return -EMFILE;
     }
     qemu_set_current_aio_context(qemu_aio_context);
+    /*
+     * 在以下使用qemu_notify_bh:
+     *   - util/main-loop.c|136| <<global>> static QEMUBH *qemu_notify_bh;
+     *   - util/main-loop.c|155| <<qemu_notify_event>> qemu_bh_schedule(qemu_notify_bh);
+     *   - util/main-loop.c|177| <<qemu_init_main_loop>> qemu_notify_bh = qemu_bh_new(notify_event_cb, NULL);
+     */
     qemu_notify_bh = qemu_bh_new(notify_event_cb, NULL);
     gpollfds = g_array_new(FALSE, FALSE, sizeof(GPollFD));
     src = aio_get_g_source(qemu_aio_context);
-- 
2.50.1 (Apple Git-155)

