From 13cc9d46f92c4975560b9dfa9ef24cc1d0fadb3f Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Thu, 5 Feb 2026 17:11:46 -0800
Subject: [PATCH 1/1] qemu for v10.2.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-accel-ops.c                 |  20 +
 accel/kvm/kvm-all.c                       |  67 ++
 accel/tcg/plugin-gen.c                    |   4 +
 contrib/plugins/cache.c                   |   4 +
 hw/core/machine-qmp-cmds.c                |   7 +
 hw/core/machine.c                         |  18 +
 hw/core/reset.c                           |  30 +
 hw/core/resettable.c                      |  51 ++
 hw/hyperv/hv-balloon-our_range_memslots.c |  18 +
 hw/hyperv/hv-balloon.c                    |  25 +
 hw/i386/amd_iommu.c                       |   9 +
 hw/i386/intel_iommu.c                     |   9 +
 hw/i386/isapc.c                           |   7 +
 hw/i386/kvm/clock.c                       | 471 ++++++++++
 hw/i386/microvm.c                         |  16 +
 hw/i386/pc.c                              |  23 +
 hw/i386/pc_piix.c                         |   7 +
 hw/i386/pc_q35.c                          |   7 +
 hw/intc/ioapic.c                          |  18 +
 hw/pci/pci.c                              |  47 +
 hw/vfio/migration.c                       |  69 ++
 hw/vfio/pci.c                             |  14 +
 hw/vfio/vfio-migration-internal.h         |   9 +
 hw/virtio/virtio-balloon-pci.c            |  51 ++
 hw/virtio/virtio-balloon.c                | 991 ++++++++++++++++++++++
 hw/virtio/virtio-pci.c                    |  86 ++
 hw/xen/xen-hvm-common.c                   |   8 +
 include/accel/accel-cpu-ops.h             |  20 +
 include/hw/i386/x86.h                     |   9 +
 include/hw/virtio/virtio-balloon.h        | 111 +++
 include/migration/register.h              |  10 +
 migration/block-dirty-bitmap.c            |  10 +
 migration/migration.c                     | 168 ++++
 migration/ram.c                           |  52 ++
 migration/savevm.c                        |  34 +
 system/balloon.c                          |  52 ++
 system/cpus.c                             | 120 +++
 system/main.c                             |  23 +
 system/memory.c                           |   5 +
 system/physmem.c                          |  36 +
 system/runstate.c                         | 173 ++++
 system/vl.c                               |  16 +
 target/i386/cpu.c                         |  45 +
 target/i386/cpu.h                         |  30 +
 target/i386/kvm/kvm.c                     | 103 +++
 target/i386/kvm/tdx.c                     |   5 +
 target/i386/machine.c                     |  30 +
 ui/vnc.c                                  |   5 +
 util/main-loop.c                          |  18 +
 49 files changed, 3161 insertions(+)

diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index 8ed6945c2..e3edff0a3 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -98,8 +98,28 @@ static void kvm_accel_ops_class_init(ObjectClass *oc, const void *data)
     ops->create_vcpu_thread = kvm_start_vcpu_thread;
     ops->cpu_thread_is_idle = kvm_vcpu_thread_is_idle;
     ops->cpus_are_resettable = kvm_cpus_are_resettable;
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_reset():
+     *   - accel/hvf/hvf-accel-ops.c|379| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - accel/mshv/mshv-all.c|710| <<mshv_accel_ops_class_init>> ops->synchronize_post_reset = mshv_cpu_synchronize_post_reset;
+     *   - system/cpus.c|179| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - system/cpus.c|180| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|90| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|93| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
     ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|113| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - accel/mshv/mshv-all.c|711| <<mshv_accel_ops_class_init>> ops->synchronize_state = mshv_cpu_synchronize;
+     *   - system/cpus.c|183| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|184| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     ops->synchronize_state = kvm_cpu_synchronize_state;
     ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
     ops->handle_interrupt = generic_handle_interrupt;
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 28006d73c..d00874afa 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -447,6 +447,10 @@ static int kvm_unpark_vcpu(KVMState *s, unsigned long vcpu_id)
     return kvm_fd;
 }
 
+/*
+ * 在以下使用kvm_reset_parked_vcpus():
+ *   - accel/kvm/kvm-all.c|2974| <<kvm_cpu_synchronize_post_reset>> kvm_reset_parked_vcpus(kvm_state);
+ */
 static void kvm_reset_parked_vcpus(KVMState *s)
 {
     struct KVMParkedVcpu *cpu;
@@ -2931,6 +2935,31 @@ static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_state():
+ *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+ *   - accel/kvm/kvm-accel-ops.c|113| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - accel/mshv/mshv-all.c|711| <<mshv_accel_ops_class_init>> ops->synchronize_state = mshv_cpu_synchronize;
+ *   - system/cpus.c|183| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+ *   - system/cpus.c|184| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+ *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+ *
+ *
+ * 在以下使用kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-accel-ops.c|113| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - accel/kvm/kvm-all.c|3325| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+ *   - target/arm/kvm.c|1431| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/arm/kvm.c|2458| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+ *   - target/i386/kvm/kvm.c|5683| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5702| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5721| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5726| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6289| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+ *   - target/loongarch/kvm/kvm.c|1383| <<kvm_loongarch_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/riscv/kvm/kvm-cpu.c|1700| <<kvm_riscv_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/s390x/kvm/kvm.c|1910| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+ */
 void kvm_cpu_synchronize_state(CPUState *cpu)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
@@ -2966,11 +2995,28 @@ static void do_kvm_cpu_synchronize_post_reset(CPUState *cpu, run_on_cpu_data arg
     }
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_post_reset():
+ *   - accel/hvf/hvf-accel-ops.c|379| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+ *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+ *   - accel/mshv/mshv-all.c|710| <<mshv_accel_ops_class_init>> ops->synchronize_post_reset = mshv_cpu_synchronize_post_reset;
+ *   - system/cpus.c|179| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+ *   - system/cpus.c|180| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|90| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+ *   - target/i386/whpx/whpx-accel-ops.c|93| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+ *
+ *
+ * 在以下使用kvm_cpu_synchronize_post_reset():
+ *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+ */
 void kvm_cpu_synchronize_post_reset(CPUState *cpu)
 {
     run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
 
     if (cpu == first_cpu) {
+        /*
+	 * 只在这里使用
+	 */
         kvm_reset_parked_vcpus(kvm_state);
     }
 }
@@ -3141,8 +3187,29 @@ int kvm_convert_memory(hwaddr start, hwaddr size, bool to_private)
              */
             goto out_unref;
         }
+        /*
+	 * 在以下使用ram_block_discard_range():
+         *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+         *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+         *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+         *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+         *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+         *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+         *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+         *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+         *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+	 */
         ret = ram_block_discard_range(rb, offset, size);
     } else {
+        /*
+	 * 只在这里调用
+	 */
         ret = ram_block_discard_guest_memfd_range(rb, offset, size);
     }
 
diff --git a/accel/tcg/plugin-gen.c b/accel/tcg/plugin-gen.c
index 1ffcb4b2d..793d5d384 100644
--- a/accel/tcg/plugin-gen.c
+++ b/accel/tcg/plugin-gen.c
@@ -290,6 +290,10 @@ static void inject_mem_cb(struct qemu_plugin_dyn_cb *cb,
     }
 }
 
+/*
+ * 在以下使用plugin_gen_inject():
+ *   - accel/tcg/plugin-gen.c|505| <<plugin_gen_tb_end>> plugin_gen_inject(ptb);
+ */
 static void plugin_gen_inject(struct qemu_plugin_tb *plugin_tb)
 {
     TCGOp *op, *next;
diff --git a/contrib/plugins/cache.c b/contrib/plugins/cache.c
index 56508587d..09b89adb1 100644
--- a/contrib/plugins/cache.c
+++ b/contrib/plugins/cache.c
@@ -385,6 +385,10 @@ static bool access_cache(Cache *cache, uint64_t addr)
     return false;
 }
 
+/*
+ * 在以下是他vcpu_mem_access():
+ *   - contrib/plugins/cache.c|493| <<vcpu_tb_trans>> qemu_plugin_register_vcpu_mem_cb(insn, vcpu_mem_access,
+ */
 static void vcpu_mem_access(unsigned int vcpu_index, qemu_plugin_meminfo_t info,
                             uint64_t vaddr, void *userdata)
 {
diff --git a/hw/core/machine-qmp-cmds.c b/hw/core/machine-qmp-cmds.c
index 28dfd3e15..6d180cfd9 100644
--- a/hw/core/machine-qmp-cmds.c
+++ b/hw/core/machine-qmp-cmds.c
@@ -302,6 +302,13 @@ UuidInfo *qmp_query_uuid(Error **errp)
 
 void qmp_system_reset(Error **errp)
 {
+    /*
+     * 在以下使用SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET:
+     *   - hw/core/machine-qmp-cmds.c|305| <<qmp_system_reset>> qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
+     *   - ui/vnc.c|2544| <<protocol_client_msg>> qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
+     *
+     * 很多对qemu_system_reset_request的调用
+     */
     qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
 }
 
diff --git a/hw/core/machine.c b/hw/core/machine.c
index 27372bb01..de2b92669 100644
--- a/hw/core/machine.c
+++ b/hw/core/machine.c
@@ -1802,6 +1802,16 @@ void qdev_machine_creation_done(void)
      * to be reset. Note that this will *not* reset any Device objects
      * which are not attached to some part of the qbus tree!
      */
+    /*
+     * 在以下使用qemu_register_resettable():
+     *   - hw/core/machine.c|1805| <<qdev_machine_creation_done>> qemu_register_resettable(OBJECT(sysbus_get_default()));
+     *   - hw/core/reset.c|102| <<qemu_register_reset>> qemu_register_resettable(obj);
+     *   - hw/core/reset.c|113| <<qemu_register_reset_nosnapshotload>> qemu_register_resettable(obj);
+     *   - hw/loongarch/virt.c|1145| <<virt_cpu_plug>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/misc/vmcoreinfo.c|68| <<vmcoreinfo_realize>> qemu_register_resettable(OBJECT(s));
+     *   - hw/virtio/virtio-balloon.c|970| <<virtio_balloon_device_realize>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/virtio/virtio-mem.c|1150| <<virtio_mem_device_realize>> qemu_register_resettable(obj);
+     */
     qemu_register_resettable(OBJECT(sysbus_get_default()));
 
     notifier_list_notify(&machine_init_done_notifiers, NULL);
@@ -1822,6 +1832,14 @@ void qdev_machine_creation_done(void)
        reading from the other reads, because timer polling functions query
        clock values from the log. */
     replay_checkpoint(CHECKPOINT_RESET);
+    /*
+     * 在以下使用qemu_system_reset():
+     *   - hw/core/machine.c|1825| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+     *   - hw/xen/xen-hvm-common.c|614| <<cpu_handle_ioreq>> qemu_system_reset(request);
+     *   - migration/savevm.c|3463| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+     *   - system/runstate.c|982| <<main_loop_should_exit>> qemu_system_reset(request);
+     *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+     */
     qemu_system_reset(SHUTDOWN_CAUSE_NONE);
     register_global_state();
 }
diff --git a/hw/core/reset.c b/hw/core/reset.c
index 65f82fa43..b9d67eff0 100644
--- a/hw/core/reset.c
+++ b/hw/core/reset.c
@@ -99,6 +99,16 @@ void qemu_register_reset(QEMUResetHandler *func, void *opaque)
 
     lr->func = func;
     lr->opaque = opaque;
+    /*
+     * 在以下使用qemu_register_resettable():
+     *   - hw/core/machine.c|1805| <<qdev_machine_creation_done>> qemu_register_resettable(OBJECT(sysbus_get_default()));
+     *   - hw/core/reset.c|102| <<qemu_register_reset>> qemu_register_resettable(obj);
+     *   - hw/core/reset.c|113| <<qemu_register_reset_nosnapshotload>> qemu_register_resettable(obj);
+     *   - hw/loongarch/virt.c|1145| <<virt_cpu_plug>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/misc/vmcoreinfo.c|68| <<vmcoreinfo_realize>> qemu_register_resettable(OBJECT(s));
+     *   - hw/virtio/virtio-balloon.c|970| <<virtio_balloon_device_realize>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/virtio/virtio-mem.c|1150| <<virtio_mem_device_realize>> qemu_register_resettable(obj);
+     */
     qemu_register_resettable(obj);
 }
 
@@ -110,6 +120,16 @@ void qemu_register_reset_nosnapshotload(QEMUResetHandler *func, void *opaque)
     lr->func = func;
     lr->opaque = opaque;
     lr->skip_on_snapshot_load = true;
+    /*
+     * 在以下使用qemu_register_resettable():
+     *   - hw/core/machine.c|1805| <<qdev_machine_creation_done>> qemu_register_resettable(OBJECT(sysbus_get_default()));
+     *   - hw/core/reset.c|102| <<qemu_register_reset>> qemu_register_resettable(obj);
+     *   - hw/core/reset.c|113| <<qemu_register_reset_nosnapshotload>> qemu_register_resettable(obj);
+     *   - hw/loongarch/virt.c|1145| <<virt_cpu_plug>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/misc/vmcoreinfo.c|68| <<vmcoreinfo_realize>> qemu_register_resettable(OBJECT(s));
+     *   - hw/virtio/virtio-balloon.c|970| <<virtio_balloon_device_realize>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/virtio/virtio-mem.c|1150| <<virtio_mem_device_realize>> qemu_register_resettable(obj);
+     */
     qemu_register_resettable(obj);
 }
 
@@ -160,6 +180,16 @@ void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
     }
 }
 
+/*
+ * 在以下使用qemu_register_resettable():
+ *   - hw/core/machine.c|1805| <<qdev_machine_creation_done>> qemu_register_resettable(OBJECT(sysbus_get_default()));
+ *   - hw/core/reset.c|102| <<qemu_register_reset>> qemu_register_resettable(obj);
+ *   - hw/core/reset.c|113| <<qemu_register_reset_nosnapshotload>> qemu_register_resettable(obj);
+ *   - hw/loongarch/virt.c|1145| <<virt_cpu_plug>> qemu_register_resettable(OBJECT(dev));
+ *   - hw/misc/vmcoreinfo.c|68| <<vmcoreinfo_realize>> qemu_register_resettable(OBJECT(s));
+ *   - hw/virtio/virtio-balloon.c|970| <<virtio_balloon_device_realize>> qemu_register_resettable(OBJECT(dev));
+ *   - hw/virtio/virtio-mem.c|1150| <<virtio_mem_device_realize>> qemu_register_resettable(obj);
+ */
 void qemu_register_resettable(Object *obj)
 {
     resettable_container_add(get_root_reset_container(), obj);
diff --git a/hw/core/resettable.c b/hw/core/resettable.c
index 5cdb4a4f8..8c350ba24 100644
--- a/hw/core/resettable.c
+++ b/hw/core/resettable.c
@@ -36,7 +36,30 @@ static void resettable_phase_exit(Object *obj, void *opaque, ResetType type);
  * iothread mutex to ensure only one reset operation is in a progress at a
  * given time.
  */
+/*
+ * 在以下使用enter_phase_in_progress:
+ *   - hw/core/resettable.c|52| <<resettable_assert_reset>> assert(!enter_phase_in_progress);
+ *   - hw/core/resettable.c|54| <<resettable_assert_reset>> enter_phase_in_progress = true;
+ *   - hw/core/resettable.c|56| <<resettable_assert_reset>> enter_phase_in_progress = false;
+ *   - hw/core/resettable.c|72| <<resettable_release_reset>> assert(!enter_phase_in_progress);
+ *   - hw/core/resettable.c|238| <<resettable_change_parent>> assert(!enter_phase_in_progress && !exit_phase_in_progress);
+ */
 static bool enter_phase_in_progress;
+/*
+ * 在以下使用exit_phase_in_progress:
+ *   - hw/core/resettable.c|74| <<resettable_release_reset>> exit_phase_in_progress += 1;
+ *   - hw/core/resettable.c|76| <<resettable_release_reset>> exit_phase_in_progress -= 1;
+ *
+ * 在以下使用ResettableState->exit_phase_in_progress:
+ *   - hw/core/resettable.c|110| <<resettable_phase_enter>> assert(!s->exit_phase_in_progress);
+ *   - hw/core/resettable.c|162| <<resettable_phase_hold>> assert(!s->exit_phase_in_progress);
+ *   - hw/core/resettable.c|192| <<resettable_phase_exit>> assert(!s->exit_phase_in_progress);
+ *   - hw/core/resettable.c|196| <<resettable_phase_exit>> s->exit_phase_in_progress = true;
+ *   - hw/core/resettable.c|206| <<resettable_phase_exit>> s->exit_phase_in_progress = false;
+ *   - hw/core/resettable.c|238| <<resettable_change_parent>> assert(!enter_phase_in_progress && !exit_phase_in_progress);
+
+include/hw/resettable.h|144| <<DECLARE_CLASS_CHECKERS>> bool exit_phase_in_progress;
+ */
 static unsigned exit_phase_in_progress;
 
 void resettable_reset(Object *obj, ResetType type)
@@ -55,6 +78,12 @@ void resettable_assert_reset(Object *obj, ResetType type)
     resettable_phase_enter(obj, NULL, type);
     enter_phase_in_progress = false;
 
+    /*
+     * 在以下使用resettable_phase_hold():
+     *   - hw/core/resettable.c|58| <<resettable_assert_reset>> resettable_phase_hold(obj, NULL, type);
+     *   - hw/core/resettable.c|155| <<resettable_phase_hold>> resettable_child_foreach(rc, obj, resettable_phase_hold, NULL, type);
+     *   - hw/core/resettable.c|236| <<resettable_change_parent>> resettable_phase_hold(obj, NULL, RESET_TYPE_COLD);
+     */
     resettable_phase_hold(obj, NULL, type);
 
     trace_resettable_reset_assert_end(obj);
@@ -140,6 +169,12 @@ static void resettable_phase_enter(Object *obj, void *opaque, ResetType type)
     trace_resettable_phase_enter_end(obj, obj_typename, s->count);
 }
 
+/*
+ * 在以下使用resettable_phase_hold():
+ *   - hw/core/resettable.c|58| <<resettable_assert_reset>> resettable_phase_hold(obj, NULL, type);
+ *   - hw/core/resettable.c|155| <<resettable_phase_hold>> resettable_child_foreach(rc, obj, resettable_phase_hold, NULL, type);
+ *   - hw/core/resettable.c|236| <<resettable_change_parent>> resettable_phase_hold(obj, NULL, RESET_TYPE_COLD);
+ */
 static void resettable_phase_hold(Object *obj, void *opaque, ResetType type)
 {
     ResettableClass *rc = RESETTABLE_GET_CLASS(obj);
@@ -151,6 +186,12 @@ static void resettable_phase_hold(Object *obj, void *opaque, ResetType type)
 
     trace_resettable_phase_hold_begin(obj, obj_typename, s->count, type);
 
+    /*
+     * 在以下使用resettable_phase_hold():
+     *   - hw/core/resettable.c|58| <<resettable_assert_reset>> resettable_phase_hold(obj, NULL, type);
+     *   - hw/core/resettable.c|155| <<resettable_phase_hold>> resettable_child_foreach(rc, obj, resettable_phase_hold, NULL, type);
+     *   - hw/core/resettable.c|236| <<resettable_change_parent>> resettable_phase_hold(obj, NULL, RESET_TYPE_COLD);
+     */
     /* handle children first */
     resettable_child_foreach(rc, obj, resettable_phase_hold, NULL, type);
 
@@ -233,6 +274,12 @@ void resettable_change_parent(Object *obj, Object *newp, Object *oldp)
      * hold phase is not pending.
      */
     if (oldp_count && s->hold_phase_pending) {
+        /*
+	 * 在以下使用resettable_phase_hold():
+	 *   - hw/core/resettable.c|58| <<resettable_assert_reset>> resettable_phase_hold(obj, NULL, type);
+	 *   - hw/core/resettable.c|155| <<resettable_phase_hold>> resettable_child_foreach(rc, obj, resettable_phase_hold, NULL, type);
+	 *   - hw/core/resettable.c|236| <<resettable_change_parent>> resettable_phase_hold(obj, NULL, RESET_TYPE_COLD);
+	 */
         resettable_phase_hold(obj, NULL, RESET_TYPE_COLD);
     }
     /* if oldp is more reset than newp */
@@ -241,6 +288,10 @@ void resettable_change_parent(Object *obj, Object *newp, Object *oldp)
     }
 }
 
+/*
+ * 在以下使用resettable_cold_reset_fn():
+ *   - hw/s390x/ipl.c|284| <<s390_ipl_realize>> qemu_register_reset(resettable_cold_reset_fn, dev);
+ */
 void resettable_cold_reset_fn(void *opaque)
 {
     resettable_reset((Object *) opaque, RESET_TYPE_COLD);
diff --git a/hw/hyperv/hv-balloon-our_range_memslots.c b/hw/hyperv/hv-balloon-our_range_memslots.c
index 1fc95e164..09b443f53 100644
--- a/hw/hyperv/hv-balloon-our_range_memslots.c
+++ b/hw/hyperv/hv-balloon-our_range_memslots.c
@@ -151,6 +151,24 @@ void hvb_our_range_memslots_free(OurRangeMemslots *our_range)
 
     hostmem_mr = memslots->slots[0].alias;
     rb = hostmem_mr->ram_block;
+    /*
+     * 在以下使用ram_block_discard_range():
+     *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+     *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+     *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+     *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+     *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+     *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+     *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+     *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+     *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+     *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+     *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+     *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+     *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+     *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+     *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+     */
     ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
 
     our_range_memslots_free_memslots(our_range);
diff --git a/hw/hyperv/hv-balloon.c b/hw/hyperv/hv-balloon.c
index 2d6d7db4e..a2c5d6700 100644
--- a/hw/hyperv/hv-balloon.c
+++ b/hw/hyperv/hv-balloon.c
@@ -860,6 +860,24 @@ static gboolean hv_balloon_handle_remove_host_addr_node(gpointer key,
                            HV_BALLOON_PAGE_SIZE);
         discard_size = MAX(discard_size, 1);
 
+        /*
+	 * 在以下使用ram_block_discard_range():
+         *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+         *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+         *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+         *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+         *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+         *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+         *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+         *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+         *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+	 */
         if (ram_block_discard_range(rb, rb_offset, discard_size *
                                     HV_BALLOON_PAGE_SIZE) != 0) {
             warn_report("guest reported removed page failed discard");
@@ -1483,6 +1501,13 @@ static void hv_balloon_vmdev_realize(VMBusDevice *vdev, Error **errp)
 
     balloon->state = S_WAIT_RESET;
 
+    /*
+     * 在以下使用qemu_add_balloon_handler():
+     *   - hw/hyperv/hv-balloon.c|1504| <<hv_balloon_vmdev_realize>>
+     *         ret = qemu_add_balloon_handler(hv_balloon_to_target, hv_balloon_stat, balloon);
+     *   - hw/virtio/virtio-balloon.c|1317| <<virtio_balloon_device_realize>>
+     *         ret = qemu_add_balloon_handler(virtio_balloon_to_target, virtio_balloon_stat, s);
+     */
     ret = qemu_add_balloon_handler(hv_balloon_to_target, hv_balloon_stat,
                                    balloon);
     if (ret < 0) {
diff --git a/hw/i386/amd_iommu.c b/hw/i386/amd_iommu.c
index d689a06ec..90a7b20a0 100644
--- a/hw/i386/amd_iommu.c
+++ b/hw/i386/amd_iommu.c
@@ -2573,6 +2573,15 @@ static void amdvi_sysbus_realize(DeviceState *dev, Error **errp)
     memory_region_add_subregion_overlap(&s->mr_sys, AMDVI_INT_ADDR_FIRST,
                                         &s->mr_ir, 1);
 
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     /* Pseudo address space under root PCI bus. */
     x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
 
diff --git a/hw/i386/intel_iommu.c b/hw/i386/intel_iommu.c
index 78b142cce..ff761e97b 100644
--- a/hw/i386/intel_iommu.c
+++ b/hw/i386/intel_iommu.c
@@ -5456,6 +5456,15 @@ static void vtd_realize(DeviceState *dev, Error **errp)
                                                   g_free, vtd_hiod_destroy);
     vtd_init(s);
     pci_setup_iommu(bus, &vtd_iommu_ops, dev);
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     /* Pseudo address space under root PCI bus. */
     x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
 }
diff --git a/hw/i386/isapc.c b/hw/i386/isapc.c
index 1ba9ae22c..1c28951e6 100644
--- a/hw/i386/isapc.c
+++ b/hw/i386/isapc.c
@@ -90,6 +90,13 @@ static void pc_init_isa(MachineState *machine)
     x86_cpus_init(x86ms, pcmc->default_cpu_version);
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用kvmclock_create():
+	 *   - hw/i386/isapc.c|93| <<pc_init_isa>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+	 *   - hw/i386/pc_piix.c|190| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+	 */
         kvmclock_create(pcmc->kvmclock_create_always);
     }
 
diff --git a/hw/i386/kvm/clock.c b/hw/i386/kvm/clock.c
index f56382717..56f48755c 100644
--- a/hw/i386/kvm/clock.c
+++ b/hw/i386/kvm/clock.c
@@ -38,14 +38,44 @@ struct KVMClockState {
     /*< public >*/
 
     uint64_t clock;
+    /*
+     * 在以下使用KVMClockState->clock_valid:
+     *   - hw/i386/kvm/clock.c|254| <<kvmclock_vm_state_change>> s->clock_valid = false;
+     *   - hw/i386/kvm/clock.c|271| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+     *   - hw/i386/kvm/clock.c|301| <<kvmclock_vm_state_change>> s->clock_valid = true;
+     */
     bool clock_valid;
 
+    /*
+     * 在以下使用KVMClockState->runstate_paused:
+     *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> s->runstate_paused = runstate_check(RUN_STATE_PAUSED);
+     *   - hw/i386/kvm/clock.c|288| <<kvmclock_pre_save>> if (!s->runstate_paused) {
+     *
+     * 注释:
+     * whether the 'clock' value was obtained in the 'paused' state
+     */
     /* whether the 'clock' value was obtained in the 'paused' state */
     bool runstate_paused;
 
+    /*
+     * 在以下使用KVMClockState->mach_use_reliable_get_clock:
+     *   - hw/i386/kvm/clock.c|313| <<global>> mach_use_reliable_get_clock, true),
+     *   - hw/i386/kvm/clock.c|243| <<kvmclock_clock_is_reliable_needed>> return s->mach_use_reliable_get_clock;
+     */
     /* whether machine type supports reliable KVM_GET_CLOCK */
     bool mach_use_reliable_get_clock;
 
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *  - hw/i386/kvm/clock.c|252| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *  - hw/i386/kvm/clock.c|151| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *  - hw/i386/kvm/clock.c|182| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *  - hw/i386/kvm/clock.c|265| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     *
+     * 注释:
+     * whether the 'clock' value was obtained in a host with
+     * reliable KVM_GET_CLOCK
+     */
     /* whether the 'clock' value was obtained in a host with
      * reliable KVM_GET_CLOCK */
     bool clock_is_reliable;
@@ -62,6 +92,12 @@ struct pvclock_vcpu_time_info {
     uint8_t    pad[2];
 } __attribute__((__packed__)); /* 32 bytes */
 
+/*
+ * 在以下使用kvmclock_current_nsec():
+ *   - hw/i386/kvm/clock.c|183| <<kvmclock_vm_state_change>> uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
+ *
+ * 读取vCPU 0的PVTI, 用env->tsc计算时间
+ */
 static uint64_t kvmclock_current_nsec(KVMClockState *s)
 {
     CPUState *cpu = first_cpu;
@@ -74,6 +110,10 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     uint64_t nsec_hi;
     uint64_t nsec;
 
+    /*
+     * 很多调用
+     * 这里等于kvm_arch_get_registers()
+     */
     cpu_synchronize_state(cpu);
 
     if (!(env->system_time_msr & 1ULL)) {
@@ -97,11 +137,84 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     return nsec + time.system_time;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用kvm_update_clock():
+ *   - hw/i386/kvm/clock.c|215| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|234| <<kvmclock_realize>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|289| <<kvmclock_pre_save>> kvm_update_clock(s);
+ *
+ * 通过KVM_GET_CLOCK存到KVMClockState->clock
+ */
 static void kvm_update_clock(KVMClockState *s)
 {
+    /*
+     * struct kvm_clock_data {
+     *     __u64 clock;
+     *     __u32 flags;
+     *     __u32 pad0;
+     *     __u64 realtime;
+     *     __u64 host_tsc;
+     *     __u32 pad[4];
+     * };
+     */
     struct kvm_clock_data data;
     int ret;
 
+    /*
+     * 在两个地方使用KVM_GET_CLOCK:
+     *   - hw/i386/kvm/clock.c|152| <<kvm_update_clock>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     *   - target/i386/kvm/xen-emu.c|990| <<kvm_get_current_ns>> ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
+     */
     ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);
     if (ret < 0) {
         fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(-ret));
@@ -148,9 +261,125 @@ static void kvm_update_clock(KVMClockState *s)
      *       if !kvm_has_adjust_clock_stable() then
      *               read from memory
      */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *  - hw/i386/kvm/clock.c|252| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *  - hw/i386/kvm/clock.c|151| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *  - hw/i386/kvm/clock.c|182| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *  - hw/i386/kvm/clock.c|265| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     *
+     * 注释:
+     * whether the 'clock' value was obtained in a host with
+     * reliable KVM_GET_CLOCK
+     *
+     * 查看host是否支持KVM_CLOCK_TSC_STABLE
+     * 是host, 不是某个VM
+     */
     s->clock_is_reliable = kvm_has_adjust_clock_stable();
 }
 
+/*
+ * 创建的时候这个调用一次.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ * 这个调用#vCPU次.
+ *
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x5555578c3250, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c3250) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c3250) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c3250) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c3250) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555578cd7d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 迁移到文件的时候.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 从文件迁移到VM.
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ * 然后下面调用#vCPU次.
+ *
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x5555578c3250, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x5555578c3250) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x5555578c3250) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x5555578c3250) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x5555578c3250) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555578cd7d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 从QEMU quit的时候
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_SHUTDOWN) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_SHUTDOWN) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_SHUTDOWN, send_stop=false) at ../system/cpus.c:300
+ * #3  0x0000555555c08bec in vm_shutdown () at ../system/cpus.c:322
+ * #4  0x0000555555c38ee9 in qemu_cleanup (status=0) at ../system/runstate.c:981
+ * #5  0x00005555560829d2 in qemu_default_main (opaque=0x0) at ../system/main.c:51
+ * #6  0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ */
+/*
+ * (gdb) bt
+ * #0  do_kvmclock_ctrl (cpu=0x55555790c330, data=...) at ../hw/i386/kvm/clock.c:156
+ * #1  0x0000555555895eca in process_queued_cpu_work (cpu=0x55555790c330) at ../cpu-common.c:374
+ * #2  0x0000555555c09060 in qemu_wait_io_event_common (cpu=0x55555790c330) at ../system/cpus.c:453
+ * #3  0x0000555555c090f9 in qemu_wait_io_event (cpu=0x55555790c330) at ../system/cpus.c:471
+ * #4  0x0000555555f28a16 in kvm_vcpu_thread_fn (arg=0x55555790c330) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555556155700 in qemu_thread_start (args=0x5555579159d0) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用do_kvmclock_ctrl():
+ *   - hw/i386/kvm/clock.c|199| <<kvmclock_vm_state_change>> run_on_cpu(cpu, do_kvmclock_ctrl, RUN_ON_CPU_NULL);
+ */
 static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
 {
     int ret = kvm_vcpu_ioctl(cpu, KVM_KVMCLOCK_CTRL, 0);
@@ -160,6 +389,109 @@ static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
     }
 }
 
+/*
+ * 启动的时候
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e2f in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d3a in vm_prepare_start (step_pending=false) at ../system/cpus.c:780
+ * #3  0x0000555555c09d75 in vm_start () at ../system/cpus.c:787
+ * #4  0x0000555555c8be6d in qmp_cont (errp=0x7fffffffc750) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c86052 in hmp_cont (mon=0x5555578622a0, qdict=0x555558142820) at ../monitor/hmp-cmds.c:145
+ * #6  0x0000555555c89d89 in handle_hmp_command_exec (mon=0x5555578622a0, cmd=0x55555742d8b0 <hmp_cmds+1680>, qdict=0x555558142820) at ../monitor/hmp.c:1106
+ * #7  0x0000555555c89fd4 in handle_hmp_command (mon=0x5555578622a0, cmdline=0x555557883d74 "") at ../monitor/hmp.c:1158
+ * #8  0x0000555555c87059 in monitor_command_cb (opaque=0x5555578622a0, cmdline=0x555557883d70 "cont", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #9  0x0000555556185448 in readline_handle_byte (rs=0x555557883d70, ch=13) at ../util/readline.c:427
+ * #10 0x0000555555c8ac2b in monitor_read (opaque=0x5555578622a0, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", size=1) at ../monitor/hmp.c:1390
+ * #11 0x0000555556078410 in qemu_chr_be_write_impl (s=0x55555773e300, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:214
+ * #12 0x0000555556078481 in qemu_chr_be_write (s=0x55555773e300, buf=0x7fffffffc9b0 "\r\311\377\377\377\177", len=1) at ../chardev/char.c:226
+ * #13 0x000055555607b483 in fd_chr_read (chan=0x55555783fdc0, cond=G_IO_IN, opaque=0x55555773e300) at ../chardev/char-fd.c:72
+ * #14 0x0000555555f4a47a in qio_channel_fd_source_dispatch (source=0x555558455a20, callback=0x55555607b344 <fd_chr_read>, user_data=0x55555773e300)
+ *     at ../io/channel-watch.c:84
+ * #15 0x00007ffff6fd3854 in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #17 0x0000555556172240 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561722ce in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:310
+ * #19 0x00005555561723fd in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c38d08 in qemu_main_loop () at ../system/runstate.c:905
+ * #21 0x0000555556082abe in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x0000555556082b78 in main (argc=22, argv=0x7fffffffdc68) at ../system/main.c:93
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c8bdc9 in qmp_cont (errp=0x0) at ../monitor/qmp-cmds.c:112
+ * #5  0x0000555555c044c8 in qmp_x_exit_preconfig (errp=0x555557527c40 <error_fatal>) at ../system/vl.c:2833
+ * #6  0x0000555555c06e99 in qemu_init (argc=21, argv=0x7fffffffdc78) at ../system/vl.c:3840
+ * #7  0x0000555556082a15 in main (argc=21, argv=0x7fffffffdc78) at ../system/main.c:71
+ *
+ *
+ * 迁移的时候在Source上的调用:
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #2  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #3  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #4  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #5  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #6  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555584739c0) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 迁移的时候在Target上的调用:
+ *
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x555557c70250) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555581bf030) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdc58) at ../system/main.c:93
+ *
+ *
+ * 这是迁移在Target上的.
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555577ff000, running=true, state=RUN_STATE_RUNNING) at ../hw/i386/kvm/clock.c:165
+ * #1  0x0000555555c37e20 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:372
+ * #2  0x0000555555c09d2b in vm_prepare_start (step_pending=false) at ../system/cpus.c:778
+ * #3  0x0000555555c09d66 in vm_start () at ../system/cpus.c:785
+ * #4  0x0000555555c5ff6a in process_incoming_migration_bh (opaque=0x5555575e2e00) at ../migration/migration.c:845
+ * #5  0x0000555555c5ecf2 in migration_bh_dispatch_bh (opaque=0x5555582b37e0) at ../migration/migration.c:361
+ * #6  0x000055555617033a in aio_bh_call (bh=0x5555584575a0) at ../util/async.c:172
+ * #7  0x0000555556170488 in aio_bh_poll (ctx=0x5555575e4060) at ../util/async.c:219
+ * #8  0x0000555556150002 in aio_dispatch (ctx=0x5555575e4060) at ../util/aio-posix.c:436
+ * #9  0x0000555556170957 in aio_ctx_dispatch (source=0x5555575e4060, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #10 0x00007ffff6fd394b in g_main_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:3325
+ * #11 g_main_context_dispatch (context=0x5555575e44b0) at ../glib/gmain.c:4043
+ * #12 0x0000555556172147 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #13 0x00005555561721d5 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #14 0x0000555556172304 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #15 0x0000555555c38cf9 in qemu_main_loop () at ../system/runstate.c:905
+ * #16 0x00005555560829c5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #17 0x0000555556082a7f in main (argc=23, argv=0x7fffffffdbf8) at ../system/main.c:93
+ *
+ *
+ * 在以下使用kvmclock_vm_state_change():
+ *   - hw/i386/kvm/clock.c|236| <<kvmclock_realize>> qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
+ */
 static void kvmclock_vm_state_change(void *opaque, bool running,
                                      RunState state)
 {
@@ -171,11 +503,25 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
     if (running) {
         struct kvm_clock_data data = {};
 
+        /*
+	 * 在以下使用KVMClockState->clock_is_reliable:
+         *  - hw/i386/kvm/clock.c|252| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+         *  - hw/i386/kvm/clock.c|151| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+         *  - hw/i386/kvm/clock.c|182| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+         *  - hw/i386/kvm/clock.c|265| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+         *
+         * 注释:
+         * whether the 'clock' value was obtained in a host with
+         * reliable KVM_GET_CLOCK
+	 */
         /*
          * If the host where s->clock was read did not support reliable
          * KVM_GET_CLOCK, read kvmclock value from memory.
          */
         if (!s->clock_is_reliable) {
+            /*
+	     * 读取vCPU 0的PVTI, 用env->tsc计算时间
+	     */
             uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
             /* We can't rely on the saved clock value, just discard it */
             if (pvclock_via_mem) {
@@ -183,6 +529,12 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
             }
         }
 
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|254| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|271| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|301| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         s->clock_valid = false;
 
         data.clock = s->clock;
@@ -200,20 +552,52 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
         }
     } else {
 
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|254| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|271| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|301| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         if (s->clock_valid) {
             return;
         }
 
+        /*
+	 * 在以下使用KVMClockState->runstate_paused:
+         *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> s->runstate_paused = runstate_check(RUN_STATE_PAUSED);
+         *   - hw/i386/kvm/clock.c|288| <<kvmclock_pre_save>> if (!s->runstate_paused) {
+         *
+         * 注释:
+         * whether the 'clock' value was obtained in the 'paused' state
+	 */
         s->runstate_paused = runstate_check(RUN_STATE_PAUSED);
 
+	/*
+	 * 只在这里调用
+	 * 核心是在每个vCPU kvm_get_tsc()
+	 */
         kvm_synchronize_all_tsc();
 
+        /*
+	 * 在以下使用kvm_update_clock():
+         *   - hw/i386/kvm/clock.c|215| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+         *   - hw/i386/kvm/clock.c|234| <<kvmclock_realize>> kvm_update_clock(s);
+         *   - hw/i386/kvm/clock.c|289| <<kvmclock_pre_save>> kvm_update_clock(s);
+         *
+         * 通过KVM_GET_CLOCK存到KVMClockState->clock
+	 */
         kvm_update_clock(s);
         /*
          * If the VM is stopped, declare the clock state valid to
          * avoid re-reading it on next vmsave (which would return
          * a different value). Will be reset when the VM is continued.
          */
+        /*
+	 * 在以下使用KVMClockState->clock_valid:
+         *   - hw/i386/kvm/clock.c|254| <<kvmclock_vm_state_change>> s->clock_valid = false;
+         *   - hw/i386/kvm/clock.c|271| <<kvmclock_vm_state_change>> if (s->clock_valid) {
+         *   - hw/i386/kvm/clock.c|301| <<kvmclock_vm_state_change>> s->clock_valid = true;
+	 */
         s->clock_valid = true;
     }
 }
@@ -227,15 +611,32 @@ static void kvmclock_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用kvm_update_clock():
+     *   - hw/i386/kvm/clock.c|215| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+     *   - hw/i386/kvm/clock.c|234| <<kvmclock_realize>> kvm_update_clock(s);
+     *   - hw/i386/kvm/clock.c|289| <<kvmclock_pre_save>> kvm_update_clock(s);
+     *
+     * 通过KVM_GET_CLOCK存到KVMClockState->clock
+     */
     kvm_update_clock(s);
 
     qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
 }
 
+/*
+ * 在以下使用kvmclock_clock_is_reliable_needed():
+ *   - hw/i386/kvm/clock.c|250| <<global>> .needed = kvmclock_clock_is_reliable_needed,
+ */
 static bool kvmclock_clock_is_reliable_needed(void *opaque)
 {
     KVMClockState *s = opaque;
 
+    /*
+     * 在以下使用KVMClockState->mach_use_reliable_get_clock:
+     *   - hw/i386/kvm/clock.c|313| <<global>> mach_use_reliable_get_clock, true),
+     *   - hw/i386/kvm/clock.c|243| <<kvmclock_clock_is_reliable_needed>> return s->mach_use_reliable_get_clock;
+     */
     return s->mach_use_reliable_get_clock;
 }
 
@@ -250,6 +651,42 @@ static const VMStateDescription kvmclock_reliable_get_clock = {
     }
 };
 
+/*
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x55555790d7e0,
+ *     version_id=1, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x555557dad630, se=0x555557902320, vmdesc=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x555557dad630, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:282
+ * #1  0x0000555555f40775 in vmstate_save_state_v (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x55555790d7e0,
+ *     version_id=1, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:407
+ * #2  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x555557dad630, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/vmstate.c:395
+ * #3  0x0000555555c79ef9 in vmstate_save (f=0x555557dad630, se=0x555557902320, vmdesc=0x55555790d7e0, errp=0x7ffe38e9c4b8) at ../migration/savevm.c:1052
+ * #4  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x555557dad630, in_postcopy=false) at ../migration/savevm.c:1669
+ * #5  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x555557dad630, iterable_only=false) at ../migration/savevm.c:1712
+ * #6  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #7  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #8  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #9  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #10 0x0000555556155700 in qemu_thread_start (args=0x5555580beb40) at ../util/qemu-thread-posix.c:393
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 /*
  * When migrating, assume the source has an unreliable
  * KVM_GET_CLOCK unless told otherwise.
@@ -258,6 +695,17 @@ static int kvmclock_pre_load(void *opaque)
 {
     KVMClockState *s = opaque;
 
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *  - hw/i386/kvm/clock.c|252| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *  - hw/i386/kvm/clock.c|151| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *  - hw/i386/kvm/clock.c|182| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *  - hw/i386/kvm/clock.c|265| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     *
+     * 注释:
+     * whether the 'clock' value was obtained in a host with
+     * reliable KVM_GET_CLOCK
+     */
     s->clock_is_reliable = false;
 
     return 0;
@@ -281,7 +729,23 @@ static int kvmclock_pre_save(void *opaque)
 {
     KVMClockState *s = opaque;
 
+    /*
+     * 在以下使用KVMClockState->runstate_paused:
+     *   - hw/i386/kvm/clock.c|211| <<kvmclock_vm_state_change>> s->runstate_paused = runstate_check(RUN_STATE_PAUSED);
+     *   - hw/i386/kvm/clock.c|288| <<kvmclock_pre_save>> if (!s->runstate_paused) {
+     *
+     * 注释:
+     * whether the 'clock' value was obtained in the 'paused' state
+     */
     if (!s->runstate_paused) {
+        /*
+	 * 在以下使用kvm_update_clock():
+         *   - hw/i386/kvm/clock.c|215| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+         *   - hw/i386/kvm/clock.c|234| <<kvmclock_realize>> kvm_update_clock(s);
+         *   - hw/i386/kvm/clock.c|289| <<kvmclock_pre_save>> kvm_update_clock(s);
+         *
+         * 通过KVM_GET_CLOCK存到KVMClockState->clock
+	 */
         kvm_update_clock(s);
     }
 
@@ -325,6 +789,13 @@ static const TypeInfo kvmclock_info = {
     .class_init    = kvmclock_class_init,
 };
 
+/*
+ * 在以下使用kvmclock_create():
+ *   - hw/i386/isapc.c|93| <<pc_init_isa>> kvmclock_create(pcmc->kvmclock_create_always);
+ *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+ *   - hw/i386/pc_piix.c|190| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+ *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+ */
 /* Note: Must be called after VCPU initialization. */
 void kvmclock_create(bool create_always)
 {
diff --git a/hw/i386/microvm.c b/hw/i386/microvm.c
index 94d22a232..fbb4d1748 100644
--- a/hw/i386/microvm.c
+++ b/hw/i386/microvm.c
@@ -182,6 +182,13 @@ static void microvm_devices_init(MicrovmMachineState *mms)
     }
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用kvmclock_create():
+	 *   - hw/i386/isapc.c|93| <<pc_init_isa>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+	 *   - hw/i386/pc_piix.c|190| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+	 */
         kvmclock_create(true);
     }
 
@@ -340,6 +347,15 @@ static void microvm_memory_init(MicrovmMachineState *mms)
     }
 
     x86ms->fw_cfg = fw_cfg;
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     x86ms->ioapic_as = &address_space_memory;
 }
 
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index f8b919cb6..d06b5afb7 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1007,6 +1007,15 @@ void pc_memory_init(PCMachineState *pcms,
     }
     x86ms->fw_cfg = fw_cfg;
 
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     /* Init default IOAPIC address space */
     x86ms->ioapic_as = &address_space_memory;
 
@@ -1702,6 +1711,11 @@ static void pc_machine_initfn(Object *obj)
     }
 }
 
+/*
+ * 在以下使用pc_machine_reset():
+ *   - hw/i386/pc.c|1734| <<pc_machine_wakeup>> pc_machine_reset(machine, RESET_TYPE_WAKEUP);
+ *   - hw/i386/pc.c|1763| <<pc_machine_class_init>> mc->reset = pc_machine_reset;
+ */
 static void pc_machine_reset(MachineState *machine, ResetType type)
 {
     CPUState *cs;
@@ -1719,10 +1733,19 @@ static void pc_machine_reset(MachineState *machine, ResetType type)
     }
 }
 
+/*
+ * 在以下使用pc_machine_wakeup():
+ *   - hw/i386/pc.c|1764| <<pc_machine_class_init>> mc->wakeup = pc_machine_wakeup;
+ */
 static void pc_machine_wakeup(MachineState *machine)
 {
     cpu_synchronize_all_states();
     pc_machine_reset(machine, RESET_TYPE_WAKEUP);
+    /*
+     * 在以下使用cpu_synchronize_all_post_reset():
+     *   - hw/i386/pc.c|1735| <<pc_machine_wakeup>> cpu_synchronize_all_post_reset();
+     *   - system/runstate.c|621| <<qemu_system_reset>> cpu_synchronize_all_post_reset();
+     */
     cpu_synchronize_all_post_reset();
 }
 
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index 7b3611e97..6464e23e7 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -187,6 +187,13 @@ static void pc_init1(MachineState *machine, const char *pci_type)
     x86_cpus_init(x86ms, pcmc->default_cpu_version);
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用kvmclock_create():
+	 *   - hw/i386/isapc.c|93| <<pc_init_isa>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+	 *   - hw/i386/pc_piix.c|190| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+	 */
         kvmclock_create(pcmc->kvmclock_create_always);
     }
 
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index 6015e639d..cabd749de 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -194,6 +194,13 @@ static void pc_q35_init(MachineState *machine)
     x86_cpus_init(x86ms, pcmc->default_cpu_version);
 
     if (kvm_enabled()) {
+        /*
+	 * 在以下使用kvmclock_create():
+	 *   - hw/i386/isapc.c|93| <<pc_init_isa>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/microvm.c|185| <<microvm_devices_init>> kvmclock_create(true);
+	 *   - hw/i386/pc_piix.c|190| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+	 *   - hw/i386/pc_q35.c|197| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+	 */
         kvmclock_create(pcmc->kvmclock_create_always);
     }
 
diff --git a/hw/intc/ioapic.c b/hw/intc/ioapic.c
index 38e438464..2975e21a0 100644
--- a/hw/intc/ioapic.c
+++ b/hw/intc/ioapic.c
@@ -96,6 +96,15 @@ static void ioapic_entry_parse(uint64_t entry, struct ioapic_entry_info *info)
 
 static void ioapic_service(IOAPICCommonState *s)
 {
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
     struct ioapic_entry_info info;
     uint8_t i;
@@ -137,6 +146,15 @@ static void ioapic_service(IOAPICCommonState *s)
                 }
 #endif
 
+                /*
+		 * 在以下使用X86MachineState->ioapic_as:
+                 *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+                 *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+                 *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+                 *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+                 *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+                 *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+		 */
                 /* No matter whether IR is enabled, we translate
                  * the IOAPIC message into a MSI one, and its
                  * address space will decide whether we need a
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index b1eba348e..4513c035b 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -55,6 +55,53 @@
 #include "hw/xen/xen.h"
 #include "hw/i386/kvm/xen_evtchn.h"
 
+/*
+ * main_system_bus
+ * ----------------------------------
+ *        |
+ *        |
+ *   i440FX-pcihost
+ *        |
+ *        |
+ *  pci.0 |
+ * -------------------------------------------------
+ *         |                |                    |
+ *         |                |                    |
+ *  vhost-scsi-pci   virtio-balloon-pci   virtio-crypto-pci
+ *                          |
+ *                          |
+ *       per-device virtio-bus |
+ *         -----------------------------------
+ *                   virtio-balloon-device
+ *
+ *
+ *
+ *                              main_system_bus
+ * --------------------------------------------------------------
+ *                                     |
+ *                              i440FX-pci-host
+ *                                     |
+ *                                     |
+ *                            pci.0    |
+ * ----------------------------------------------------------------------------
+ *   |            |              |                 |                     |
+ *   |            |              |                 |                     |
+ * i440FX        PIIX3         e1000            piix3-ide             PIIX4_PM
+ *                |
+ *                |
+ *         isa.0  |
+ *     -------------------------------------------------
+ *         |            |           |              |
+ *         |            |           |              |
+ *     kvm-i8259    kvm-i8259    isa-fdc        kvm-pit
+ *                                  |
+ *                                  |
+ *                    floppy-bus.0  |
+ *                          -------------------
+ *                                  |
+ *                               floppy
+ */
+
 bool pci_available = true;
 
 static char *pcibus_get_dev_path(DeviceState *dev);
diff --git a/hw/vfio/migration.c b/hw/vfio/migration.c
index 4c06e3db9..a26ff986c 100644
--- a/hw/vfio/migration.c
+++ b/hw/vfio/migration.c
@@ -89,6 +89,10 @@ mig_state_to_qapi_state(enum vfio_device_mig_state state)
     }
 }
 
+/*
+ * 在以下使用vfio_migration_send_event():
+ *   - hw/vfio/migration.c|121| <<vfio_migration_set_device_state>> vfio_migration_send_event(vbasedev);
+ */
 static void vfio_migration_send_event(VFIODevice *vbasedev)
 {
     VFIOMigration *migration = vbasedev->migration;
@@ -109,6 +113,12 @@ static void vfio_migration_send_event(VFIODevice *vbasedev)
         dev->id, qom_path, mig_state_to_qapi_state(migration->device_state));
 }
 
+/*
+ * 在以下使用vfio_migration_set_device_state():
+ *   - hw/vfio/migration.c|182| <<vfio_migration_set_state>> vfio_migration_set_device_state(vbasedev, recover_state);
+ *   - hw/vfio/migration.c|187| <<vfio_migration_set_state>> vfio_migration_set_device_state(vbasedev, new_state);
+ *   - hw/vfio/migration.c|211| <<vfio_migration_set_state>> vfio_migration_set_device_state(vbasedev, VFIO_DEVICE_STATE_RUNNING);
+ */
 static void vfio_migration_set_device_state(VFIODevice *vbasedev,
                                             enum vfio_device_mig_state state)
 {
@@ -118,9 +128,20 @@ static void vfio_migration_set_device_state(VFIODevice *vbasedev,
                                           mig_state_to_str(state));
 
     migration->device_state = state;
+    /*
+     * 只在这里调用
+     */
     vfio_migration_send_event(vbasedev);
 }
 
+/*
+ * 在以下使用vfio_migration_set_state():
+ *   - hw/vfio/migration-multifd.c|708| <<vfio_multifd_save_complete_precopy_thread>> if (vfio_migration_set_state(vbasedev, VFIO_DEVICE_STATE_STOP_COPY,
+ *   - hw/vfio/migration.c|226| <<vfio_migration_set_state_or_reset>> return vfio_migration_set_state(vbasedev, new_state,
+ *   - hw/vfio/migration.c|478| <<vfio_save_setup>> ret = vfio_migration_set_state(vbasedev, VFIO_DEVICE_STATE_PRE_COPY,
+ *   - hw/vfio/migration.c|649| <<vfio_save_complete_precopy>> ret = vfio_migration_set_state(vbasedev, VFIO_DEVICE_STATE_STOP_COPY,
+ *   - hw/vfio/migration.c|705| <<vfio_load_setup>> ret = vfio_migration_set_state(vbasedev, VFIO_DEVICE_STATE_RESUMING,
+ */
 int vfio_migration_set_state(VFIODevice *vbasedev,
                              enum vfio_device_mig_state new_state,
                              enum vfio_device_mig_state recover_state,
@@ -343,11 +364,25 @@ static int vfio_query_precopy_size(VFIOMigration *migration)
     return 0;
 }
 
+/*
+ * 在以下使用vfio_save_block():
+ *   - hw/vfio/migration.c|613| <<vfio_save_iterate>> data_size = vfio_save_block(f, migration);
+ *   - hw/vfio/migration.c|657| <<vfio_save_complete_precopy>> data_size = vfio_save_block(f, vbasedev->migration);
+ */
 /* Returns the size of saved data on success and -errno on error */
 static ssize_t vfio_save_block(QEMUFile *f, VFIOMigration *migration)
 {
     ssize_t data_size;
 
+    /*
+     * 在以下使用VFIOMigration->data_buffer:
+     *   - hw/vfio/migration.c|351| <<vfio_save_block>> data_size = read(migration->data_fd, migration->data_buffer,
+     *   - hw/vfio/migration.c|377| <<vfio_save_block>> qemu_put_buffer(f, migration->data_buffer, data_size);
+     *   - hw/vfio/migration.c|465| <<vfio_save_setup>> migration->data_buffer = g_try_malloc0(migration->data_buffer_size);
+     *   - hw/vfio/migration.c|466| <<vfio_save_setup>> if (!migration->data_buffer) {
+     *   - hw/vfio/migration.c|532| <<vfio_save_cleanup>> g_free(migration->data_buffer);
+     *   - hw/vfio/migration.c|533| <<vfio_save_cleanup>> migration->data_buffer = NULL;
+     */
     data_size = read(migration->data_fd, migration->data_buffer,
                      migration->data_buffer_size);
     if (data_size < 0) {
@@ -462,6 +497,15 @@ static int vfio_save_setup(QEMUFile *f, void *opaque, Error **errp)
     vfio_query_stop_copy_size(vbasedev, &stop_copy_size);
     migration->data_buffer_size = MIN(VFIO_MIG_DEFAULT_DATA_BUFFER_SIZE,
                                       stop_copy_size);
+    /*
+     * 在以下使用VFIOMigration->data_buffer:
+     *   - hw/vfio/migration.c|351| <<vfio_save_block>> data_size = read(migration->data_fd, migration->data_buffer,
+     *   - hw/vfio/migration.c|377| <<vfio_save_block>> qemu_put_buffer(f, migration->data_buffer, data_size);
+     *   - hw/vfio/migration.c|465| <<vfio_save_setup>> migration->data_buffer = g_try_malloc0(migration->data_buffer_size);
+     *   - hw/vfio/migration.c|466| <<vfio_save_setup>> if (!migration->data_buffer) {
+     *   - hw/vfio/migration.c|532| <<vfio_save_cleanup>> g_free(migration->data_buffer);
+     *   - hw/vfio/migration.c|533| <<vfio_save_cleanup>> migration->data_buffer = NULL;
+     */
     migration->data_buffer = g_try_malloc0(migration->data_buffer_size);
     if (!migration->data_buffer) {
         error_setg(errp, "%s: Failed to allocate migration data buffer",
@@ -529,6 +573,15 @@ static void vfio_save_cleanup(void *opaque)
         }
     }
 
+    /*
+     * 在以下使用VFIOMigration->data_buffer:
+     *   - hw/vfio/migration.c|351| <<vfio_save_block>> data_size = read(migration->data_fd, migration->data_buffer,
+     *   - hw/vfio/migration.c|377| <<vfio_save_block>> qemu_put_buffer(f, migration->data_buffer, data_size);
+     *   - hw/vfio/migration.c|465| <<vfio_save_setup>> migration->data_buffer = g_try_malloc0(migration->data_buffer_size);
+     *   - hw/vfio/migration.c|466| <<vfio_save_setup>> if (!migration->data_buffer) {
+     *   - hw/vfio/migration.c|532| <<vfio_save_cleanup>> g_free(migration->data_buffer);
+     *   - hw/vfio/migration.c|533| <<vfio_save_cleanup>> migration->data_buffer = NULL;
+     */
     g_free(migration->data_buffer);
     migration->data_buffer = NULL;
     migration->precopy_init_size = 0;
@@ -599,6 +652,16 @@ static bool vfio_is_active_iterate(void *opaque)
  * in the worst case it will exceed by 1MB). However, if the buffer size is
  * later changed to a bigger value, migration rate should be enforced here.
  */
+/*
+ * 在以下使用SaveVMHandlers->save_live_iterate:
+ *   - hw/ppc/spapr.c|2572| <<global>> .save_live_iterate = htab_save_iterate,
+ *   - hw/s390x/s390-stattrib.c|340| <<global>> .save_live_iterate = cmma_save_iterate,
+ *   - hw/vfio/migration.c|834| <<global>> .save_live_iterate = vfio_save_iterate,
+ *   - migration/block-dirty-bitmap.c|1255| <<global>> .save_live_iterate = dirty_bitmap_save_iterate,
+ *   - migration/ram.c|4695| <<global>> .save_live_iterate = ram_save_iterate,
+ *   - migration/savevm.c|1448| <<qemu_savevm_state_iterate>> if (!se->ops || !se->ops->save_live_iterate) {
+ *   - migration/savevm.c|1476| <<qemu_savevm_state_iterate>> ret = se->ops->save_live_iterate(f, se->opaque);
+ */
 static int vfio_save_iterate(QEMUFile *f, void *opaque)
 {
     VFIODevice *vbasedev = opaque;
@@ -1126,6 +1189,12 @@ void vfio_migration_reset_bytes_transferred(void)
     qatomic_set(&bytes_transferred, 0);
 }
 
+/*
+ * 在以下使用vfio_migration_add_bytes_transferred():
+ *   - hw/vfio/migration-multifd.c|674| <<vfio_save_complete_precopy_thread_config_state>> vfio_migration_add_bytes_transferred(packet_len);
+ *   - hw/vfio/migration-multifd.c|744| <<vfio_multifd_save_complete_precopy_thread>> vfio_migration_add_bytes_transferred(packet_size);
+ *   - hw/vfio/migration.c|378| <<vfio_save_block>> vfio_migration_add_bytes_transferred(data_size);
+ */
 void vfio_migration_add_bytes_transferred(unsigned long val)
 {
     qatomic_add(&bytes_transferred, val);
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index b46b1305a..119853164 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -2817,6 +2817,16 @@ static const VMStateDescription vmstate_vfio_pci_config = {
     }
 };
 
+/*
+ * 2894 static VFIODeviceOps vfio_pci_ops = {
+ * 2895     .vfio_compute_needs_reset = vfio_pci_compute_needs_reset,
+ * 2896     .vfio_hot_reset_multi = vfio_pci_hot_reset_multi,
+ * 2897     .vfio_eoi = vfio_pci_intx_eoi,
+ * 2898     .vfio_get_object = vfio_pci_get_object,
+ * 2899     .vfio_save_config = vfio_pci_save_config,
+ * 2900     .vfio_load_config = vfio_pci_load_config,
+ * 2901 };
+ */
 static int vfio_pci_save_config(VFIODevice *vbasedev, QEMUFile *f, Error **errp)
 {
     VFIOPCIDevice *vdev = container_of(vbasedev, VFIOPCIDevice, vbasedev);
@@ -2891,6 +2901,10 @@ void vfio_sub_page_bar_update_mappings(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * 在以下使用vfio_pci_ops:
+ *   - hw/vfio/pci.c|3645| <<vfio_pci_init>> vfio_device_init(vbasedev, VFIO_DEVICE_TYPE_PCI, &vfio_pci_ops,
+ */
 static VFIODeviceOps vfio_pci_ops = {
     .vfio_compute_needs_reset = vfio_pci_compute_needs_reset,
     .vfio_hot_reset_multi = vfio_pci_hot_reset_multi,
diff --git a/hw/vfio/vfio-migration-internal.h b/hw/vfio/vfio-migration-internal.h
index 814fbd9eb..708ea059d 100644
--- a/hw/vfio/vfio-migration-internal.h
+++ b/hw/vfio/vfio-migration-internal.h
@@ -42,6 +42,15 @@ typedef struct VFIOMigration {
     NotifierWithReturn migration_state;
     uint32_t device_state;
     int data_fd;
+    /*
+     * 在以下使用VFIOMigration->data_buffer:
+     *   - hw/vfio/migration.c|351| <<vfio_save_block>> data_size = read(migration->data_fd, migration->data_buffer,
+     *   - hw/vfio/migration.c|377| <<vfio_save_block>> qemu_put_buffer(f, migration->data_buffer, data_size);
+     *   - hw/vfio/migration.c|465| <<vfio_save_setup>> migration->data_buffer = g_try_malloc0(migration->data_buffer_size); 
+     *   - hw/vfio/migration.c|466| <<vfio_save_setup>> if (!migration->data_buffer) { 
+     *   - hw/vfio/migration.c|532| <<vfio_save_cleanup>> g_free(migration->data_buffer);
+     *   - hw/vfio/migration.c|533| <<vfio_save_cleanup>> migration->data_buffer = NULL;
+     */
     void *data_buffer;
     size_t data_buffer_size;
     uint64_t mig_flags;
diff --git a/hw/virtio/virtio-balloon-pci.c b/hw/virtio/virtio-balloon-pci.c
index 96e88b6b8..de8df8195 100644
--- a/hw/virtio/virtio-balloon-pci.c
+++ b/hw/virtio/virtio-balloon-pci.c
@@ -21,6 +21,53 @@
 #include "qemu/module.h"
 #include "qom/object.h"
 
+/*
+ * main_system_bus
+ * ----------------------------------
+ *        |
+ *        |
+ *   i440FX-pcihost
+ *        |
+ *        |
+ *  pci.0 |
+ * -------------------------------------------------
+ *         |                |                    |
+ *         |                |                    |
+ *  vhost-scsi-pci   virtio-balloon-pci   virtio-crypto-pci
+ *                          |
+ *                          |
+ *       per-device virtio-bus |
+ *         -----------------------------------
+ *                   virtio-balloon-device
+ * 
+ *
+ *
+ *                              main_system_bus
+ * --------------------------------------------------------------
+ *                                     |
+ *                              i440FX-pci-host
+ *                                     |
+ *                                     |
+ *                            pci.0    |
+ * ----------------------------------------------------------------------------
+ *   |            |              |                 |                     |
+ *   |            |              |                 |                     |
+ * i440FX        PIIX3         e1000            piix3-ide             PIIX4_PM
+ *                |
+ *                |
+ *         isa.0  |
+ *     -------------------------------------------------
+ *         |            |           |              |
+ *         |            |           |              |
+ *     kvm-i8259    kvm-i8259    isa-fdc        kvm-pit
+ *                                  |
+ *                                  |
+ *                    floppy-bus.0  |
+ *                          -------------------
+ *                                  |
+ *                               floppy
+ */
+
 typedef struct VirtIOBalloonPCI VirtIOBalloonPCI;
 
 /*
@@ -52,6 +99,10 @@ static void virtio_balloon_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
     }
 
     vpci_dev->class_code = PCI_CLASS_OTHERS;
+    /*
+     * VirtIOPCIProxy *vpci_dev:
+     * -> VirtioBusState bus;
+     */
     qdev_realize(vdev, BUS(&vpci_dev->bus), errp);
 }
 
diff --git a/hw/virtio/virtio-balloon.c b/hw/virtio/virtio-balloon.c
index 02cdd807d..07bbf244d 100644
--- a/hw/virtio/virtio-balloon.c
+++ b/hw/virtio/virtio-balloon.c
@@ -36,6 +36,52 @@
 #include "hw/virtio/virtio-bus.h"
 #include "hw/virtio/virtio-access.h"
 
+/*
+ * 1. "guest-stats"只在"guest-stats-polling-interval"(VirtIOBallon->stats_poll_interval)不为0的时候使用.
+ *
+ * 2. "free-page-hint"主要给live migration dirty track用的.
+ * live migration的时候QEMU通知virtio-balloon的callback.
+ *
+ * 3. iothread在"free-page-hint"的时候用, 必须用.
+ *
+ * 4. PartiallyBalloonedPage帮助在inflation的时候对于host page是hugepage的,
+ * 必须完全凑够一个huage page才行. 凑不够就不inflate.
+ *
+ * 5. Inflation有两种情况.
+ * 对于普通的page使用madvise(QEMU_MADV_REMOVE或者QEMU_MADV_DONTNEED).
+ * 对于fd的page使用fallocate(FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE).
+ *
+ * 6. Deflation使用madvise(QEMU_MADV_WILLNEED).
+ *
+ * 7. Free page reporting根据情况时候madvise或者fallocate.
+ */
+
+/*
+ * 根据测试, 没有internal, last-update就不变
+ * (qemu) qom-get /machine/peripheral/balloon0 guest-stats
+ * {
+ *     "stats": {
+ *         "stat-htlb-pgalloc": 0,
+ *         "stat-swap-out": 0,
+ *         "stat-alloc-stalls": 18446744073709551615,
+ *         "stat-available-memory": 7551688704,
+ *         "stat-direct-reclaims": 18446744073709551615,
+ *         "stat-direct-scans": 18446744073709551615,
+ *         "stat-htlb-pgfail": 0,
+ *         "stat-free-memory": 7607328768,
+ *         "stat-minor-faults": 325065,
+ *         "stat-major-faults": 636,
+ *         "stat-total-memory": 8025051136,
+ *         "stat-oom-kills": 18446744073709551615,
+ *         "stat-async-reclaims": 18446744073709551615,
+ *         "stat-swap-in": 0,
+ *         "stat-async-scans": 18446744073709551615,
+ *         "stat-disk-caches": 155353088
+ *     },
+ *     "last-update": 1770071149
+ * }
+ */
+
 #define BALLOON_PAGE_SIZE  (1 << VIRTIO_BALLOON_PFN_SHIFT)
 
 typedef struct PartiallyBalloonedPage {
@@ -43,6 +89,12 @@ typedef struct PartiallyBalloonedPage {
     unsigned long *bitmap;
 } PartiallyBalloonedPage;
 
+/*
+ * 在以下使用virtio_balloon_pbp_free():
+ *   - hw/virtio/virtio-balloon.c|183| <<balloon_inflate_page>> virtio_balloon_pbp_free(pbp);
+ *   - hw/virtio/virtio-balloon.c|222| <<balloon_inflate_page>> virtio_balloon_pbp_free(pbp);
+ *   - hw/virtio/virtio-balloon.c|770| <<virtio_balloon_handle_output>> virtio_balloon_pbp_free(&pbp);
+ */
 static void virtio_balloon_pbp_free(PartiallyBalloonedPage *pbp)
 {
     if (!pbp->bitmap) {
@@ -52,6 +104,10 @@ static void virtio_balloon_pbp_free(PartiallyBalloonedPage *pbp)
     pbp->bitmap = NULL;
 }
 
+/*
+ * 在以下使用virtio_balloon_pbp_alloc():
+ *   - hw/virtio/virtio-balloon.c|126| <<balloon_inflate_page>> virtio_balloon_pbp_alloc(pbp, base_gpa, subpages);
+ */
 static void virtio_balloon_pbp_alloc(PartiallyBalloonedPage *pbp,
                                      ram_addr_t base_gpa,
                                      long subpages)
@@ -60,12 +116,21 @@ static void virtio_balloon_pbp_alloc(PartiallyBalloonedPage *pbp,
     pbp->bitmap = bitmap_new(subpages);
 }
 
+/*
+ * 在以下使用virtio_balloon_pbp_matches():
+ *   - return pbp->base_gpa == base_gpa;
+ */
 static bool virtio_balloon_pbp_matches(PartiallyBalloonedPage *pbp,
                                        ram_addr_t base_gpa)
 {
     return pbp->base_gpa == base_gpa;
 }
 
+/*
+ * 在以下使用virtio_balloon_inhibited():
+ *   - hw/virtio/virtio-balloon.c|623| <<virtio_balloon_handle_report>> if (virtio_balloon_inhibited() || dev->poison_val) {
+ *   - hw/virtio/virtio-balloon.c|746| <<virtio_balloon_handle_output>> if (!virtio_balloon_inhibited()) {
+ */
 static bool virtio_balloon_inhibited(void)
 {
     /*
@@ -76,6 +141,18 @@ static bool virtio_balloon_inhibited(void)
             migration_in_bg_snapshot();
 }
 
+/*
+ * #define BALLOON_PAGE_SIZE  (1 << VIRTIO_BALLOON_PFN_SHIFT)
+ *
+ * typedef struct PartiallyBalloonedPage {
+ *     ram_addr_t base_gpa;
+ *     unsigned long *bitmap;
+ * } PartiallyBalloonedPage;
+ *
+ *
+ * 在以下使用balloon_inflate_page():
+ *   - hw/virtio/virtio-balloon.c|448| <<virtio_balloon_handle_output>> balloon_inflate_page(s, section.mr,
+ */
 static void balloon_inflate_page(VirtIOBalloon *balloon,
                                  MemoryRegion *mr, hwaddr mr_offset,
                                  PartiallyBalloonedPage *pbp)
@@ -91,9 +168,30 @@ static void balloon_inflate_page(VirtIOBalloon *balloon,
     rb = qemu_ram_block_from_host(addr, false, &rb_offset);
     rb_page_size = qemu_ram_pagesize(rb);
 
+    /*
+     * rb_page_size应该是host的fd内存的page size
+     */
     if (rb_page_size == BALLOON_PAGE_SIZE) {
         /* Easy case */
 
+        /*
+	 * 在以下使用ram_block_discard_range():
+         *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+         *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+         *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+         *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+         *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+         *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+         *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+         *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+         *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+	 */
         ram_block_discard_range(rb, rb_offset, rb_page_size);
         /* We ignore errors from ram_block_discard_range(), because it
          * has already reported them, and failing to discard a balloon
@@ -123,6 +221,9 @@ static void balloon_inflate_page(VirtIOBalloon *balloon,
     }
 
     if (!pbp->bitmap) {
+        /*
+	 * 只在这里调用virtio_balloon_pbp_alloc()
+	 */
         virtio_balloon_pbp_alloc(pbp, base_gpa, subpages);
     }
 
@@ -133,6 +234,24 @@ static void balloon_inflate_page(VirtIOBalloon *balloon,
         /* We've accumulated a full host page, we can actually discard
          * it now */
 
+        /*
+	 * 在以下使用ram_block_discard_range():
+         *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+         *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+         *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+         *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+         *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+         *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+         *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+         *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+         *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+         *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+         *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+         *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+	 */
         ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
         /* We ignore errors from ram_block_discard_range(), because it
          * has already reported them, and failing to discard a balloon
@@ -141,6 +260,10 @@ static void balloon_inflate_page(VirtIOBalloon *balloon,
     }
 }
 
+/*
+ * 在以下使用balloon_deflate_page():
+ *   - hw/virtio/virtio-balloon.c|751| <<virtio_balloon_handle_output>> balloon_deflate_page(s, section.mr, section.offset_within_region);
+ */
 static void balloon_deflate_page(VirtIOBalloon *balloon,
                                  MemoryRegion *mr, hwaddr mr_offset)
 {
@@ -204,6 +327,12 @@ G_STATIC_ASSERT(G_N_ELEMENTS(balloon_stat_names) == VIRTIO_BALLOON_S_NR);
  * stale values stick around in case the guest reports a subset of the supported
  * statistics.
  */
+/*
+ * 在以下使用reset_stats():
+ *   - hw/virtio/virtio-balloon.c|596| <<virtio_balloon_receive_stats>> reset_stats(s);
+ *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_device_realize>> reset_stats(s);
+ *   - hw/virtio/virtio-balloon.c|1465| <<virtio_balloon_reset_enter>> reset_stats(s);
+ */
 static inline void reset_stats(VirtIOBalloon *dev)
 {
     int i;
@@ -216,42 +345,173 @@ static bool balloon_stats_supported(const VirtIOBalloon *s)
     return virtio_vdev_has_feature(vdev, VIRTIO_BALLOON_F_STATS_VQ);
 }
 
+/*
+ * 在以下使用balloon_stats_enabled():
+ *   - hw/virtio/virtio-balloon.c|326| <<balloon_stats_destroy_timer>> if (balloon_stats_enabled(s)) {
+ *   - hw/virtio/virtio-balloon.c|574| <<balloon_stats_set_poll_interval>> if (balloon_stats_enabled(s)) {
+ *   - hw/virtio/virtio-balloon.c|857| <<virtio_balloon_receive_stats>> if (balloon_stats_enabled(s)) {
+ *   - hw/virtio/virtio-balloon.c|1600| <<virtio_balloon_post_load_device>> if (balloon_stats_enabled(s)) {
+ */
 static bool balloon_stats_enabled(const VirtIOBalloon *s)
 {
+    /*
+     * 在以下使用VirtIOBalloon->stats_poll_interval:
+     *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+     *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+     *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+     *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+     *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     */
     return s->stats_poll_interval > 0;
 }
 
+/*
+ * 在以下使用balloon_stats_destroy_timer():
+ *   - hw/virtio/virtio-balloon.c|570| <<balloon_stats_set_poll_interval>> balloon_stats_destroy_timer(s);
+ *   - hw/virtio/virtio-balloon.c|1785| <<virtio_balloon_device_unrealize>> balloon_stats_destroy_timer(s);
+ */
 static void balloon_stats_destroy_timer(VirtIOBalloon *s)
 {
     if (balloon_stats_enabled(s)) {
+        /*
+	 * 在以下使用VirtIOBalloon->stats_timer:
+         *   - hw/virtio/virtio-balloon.c|292| <<balloon_stats_destroy_timer>> timer_free(s->stats_timer);
+         *   - hw/virtio/virtio-balloon.c|293| <<balloon_stats_destroy_timer>> s->stats_timer = NULL;
+         *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_change_timer>> timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000);
+         *   - hw/virtio/virtio-balloon.c|471| <<balloon_stats_set_poll_interval>> g_assert(s->stats_timer == NULL);
+         *   - hw/virtio/virtio-balloon.c|472| <<balloon_stats_set_poll_interval>> s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
+	 */
         timer_free(s->stats_timer);
         s->stats_timer = NULL;
+        /*
+	 * 在以下使用VirtIOBalloon->stats_poll_interval:
+         *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+         *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+         *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+         *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+         *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+	 */
         s->stats_poll_interval = 0;
     }
 }
 
+/*
+ * 在以下使用balloon_stats_change_timer():
+ *   - hw/virtio/virtio-balloon.c|334| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+ *   - hw/virtio/virtio-balloon.c|466| <<balloon_stats_set_poll_interval>> balloon_stats_change_timer(s, value);
+ *   - hw/virtio/virtio-balloon.c|474| <<balloon_stats_set_poll_interval>> balloon_stats_change_timer(s, 0);
+ *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+ *   - hw/virtio/virtio-balloon.c|1348| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+ */
 static void balloon_stats_change_timer(VirtIOBalloon *s, int64_t secs)
 {
+    /*
+     * 在以下使用VirtIOBalloon->stats_timer:
+     *   - hw/virtio/virtio-balloon.c|292| <<balloon_stats_destroy_timer>> timer_free(s->stats_timer);
+     *   - hw/virtio/virtio-balloon.c|293| <<balloon_stats_destroy_timer>> s->stats_timer = NULL;
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_change_timer>> timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000);
+     *   - hw/virtio/virtio-balloon.c|471| <<balloon_stats_set_poll_interval>> g_assert(s->stats_timer == NULL);
+     *   - hw/virtio/virtio-balloon.c|472| <<balloon_stats_set_poll_interval>> s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
+     */
     timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000);
 }
 
+/*
+ * 在以下使用balloon_stats_poll_cb():
+ *   - hw/virtio/virtio-balloon.c|504| <<balloon_stats_set_poll_interval>> s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
+ */
 static void balloon_stats_poll_cb(void *opaque)
 {
     VirtIOBalloon *s = opaque;
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
 
     if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+        /*
+	 * 在以下使用VirtIOBalloon->stats_poll_interval:
+         *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+         *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+         *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+         *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+         *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+	 */
         /* re-schedule */
         balloon_stats_change_timer(s, s->stats_poll_interval);
         return;
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_vq_elem:
+     *   - hw/virtio/virtio-balloon.c|344| <<balloon_stats_poll_cb>> if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|364| <<balloon_stats_poll_cb>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|365| <<balloon_stats_poll_cb>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|695| <<virtio_balloon_receive_stats>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|699| <<virtio_balloon_receive_stats>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|702| <<virtio_balloon_receive_stats>> s->stats_vq_elem = elem;
+     *   - hw/virtio/virtio-balloon.c|1582| <<virtio_balloon_device_reset>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|1583| <<virtio_balloon_device_reset>> virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|1584| <<virtio_balloon_device_reset>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|1585| <<virtio_balloon_device_reset>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|1595| <<virtio_balloon_set_status>> if (!s->stats_vq_elem && vdev->vm_running &&
+     *
+     * virtio-balloon使用virtqueue_push()的地方:
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|594| <<virtio_balloon_handle_report>> virtqueue_push(vq, elem, 0);
+     *   - hw/virtio/virtio-balloon.c|664| <<virtio_balloon_handle_output>> virtqueue_push(vq, elem, 0);
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|872| <<get_free_page_hints>> virtqueue_push(vq, elem, 0);
+     */
     virtqueue_push(s->svq, s->stats_vq_elem, 0);
     virtio_notify(vdev, s->svq);
     g_free(s->stats_vq_elem);
     s->stats_vq_elem = NULL;
 }
 
+/*
+ * 根据测试, 没有internal, last-update就不变
+ * (qemu) qom-get /machine/peripheral/balloon0 guest-stats
+ * {
+ *     "stats": {
+ *         "stat-htlb-pgalloc": 0,
+ *         "stat-swap-out": 0,
+ *         "stat-alloc-stalls": 18446744073709551615,
+ *         "stat-available-memory": 7551688704,
+ *         "stat-direct-reclaims": 18446744073709551615,
+ *         "stat-direct-scans": 18446744073709551615,
+ *         "stat-htlb-pgfail": 0,
+ *         "stat-free-memory": 7607328768,
+ *         "stat-minor-faults": 325065,
+ *         "stat-major-faults": 636,
+ *         "stat-total-memory": 8025051136,
+ *         "stat-oom-kills": 18446744073709551615,
+ *         "stat-async-reclaims": 18446744073709551615,
+ *         "stat-swap-in": 0,
+ *         "stat-async-scans": 18446744073709551615,
+ *         "stat-disk-caches": 155353088
+ *     },
+ *     "last-update": 1770071149
+ * }
+ *
+ *
+ * 在以下使用balloon_stats_get_all():
+ *   - hw/virtio/virtio-balloon.c|1494| <<virtio_balloon_instance_init>> balloon_stats_get_all, NULL, NULL, NULL);
+ *
+ * 1497     object_property_add(obj, "guest-stats", "guest statistics",
+ * 1498                         balloon_stats_get_all, NULL, NULL, NULL);
+ */
 static void balloon_stats_get_all(Object *obj, Visitor *v, const char *name,
                                   void *opaque, Error **errp)
 {
@@ -262,6 +522,13 @@ static void balloon_stats_get_all(Object *obj, Visitor *v, const char *name,
     if (!visit_start_struct(v, name, NULL, 0, errp)) {
         return;
     }
+    /*
+     * 在以下使用VirtIOBalloon->stats_last_update:
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_get_all>> if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
+     *   - hw/virtio/virtio-balloon.c|608| <<virtio_balloon_receive_stats>> s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
+     *   - hw/virtio/virtio-balloon.c|1332| <<virtio_balloon_device_realize>> s->stats_last_update = 0;
+     *   - hw/virtio/virtio-balloon.c|1466| <<virtio_balloon_reset_enter>> s->stats_last_update = 0;
+     */
     if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
         goto out_end;
     }
@@ -290,9 +557,30 @@ static void balloon_stats_get_poll_interval(Object *obj, Visitor *v,
                                             Error **errp)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(obj);
+    /*
+     * 在以下使用VirtIOBalloon->stats_poll_interval:
+     *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+     *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+     *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+     *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+     *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     */
     visit_type_int(v, name, &s->stats_poll_interval, errp);
 }
 
+/*
+ * 在以下使用balloon_stats_set_poll_interval():
+ *   - hw/virtio/virtio-balloon.c|1470| <<virtio_balloon_instance_init>> balloon_stats_set_poll_interval,
+ *
+ * 1491     object_property_add(obj, "guest-stats-polling-interval", "int",
+ * 1492                         balloon_stats_get_poll_interval,
+ * 1493                         balloon_stats_set_poll_interval,
+ * 1494                         NULL, NULL);
+ */
 static void balloon_stats_set_poll_interval(Object *obj, Visitor *v,
                                             const char *name, void *opaque,
                                             Error **errp)
@@ -314,6 +602,18 @@ static void balloon_stats_set_poll_interval(Object *obj, Visitor *v,
         return;
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_poll_interval:
+     *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+     *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+     *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+     *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+     *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     */
     if (value == s->stats_poll_interval) {
         return;
     }
@@ -331,6 +631,14 @@ static void balloon_stats_set_poll_interval(Object *obj, Visitor *v,
         return;
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_timer:
+     *   - hw/virtio/virtio-balloon.c|292| <<balloon_stats_destroy_timer>> timer_free(s->stats_timer);
+     *   - hw/virtio/virtio-balloon.c|293| <<balloon_stats_destroy_timer>> s->stats_timer = NULL;
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_change_timer>> timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000);
+     *   - hw/virtio/virtio-balloon.c|471| <<balloon_stats_set_poll_interval>> g_assert(s->stats_timer == NULL);
+     *   - hw/virtio/virtio-balloon.c|472| <<balloon_stats_set_poll_interval>> s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
+     */
     /* create a new timer */
     g_assert(s->stats_timer == NULL);
     s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
@@ -338,11 +646,23 @@ static void balloon_stats_set_poll_interval(Object *obj, Visitor *v,
     balloon_stats_change_timer(s, 0);
 }
 
+/*
+ * 在以下使用virtio_balloon_handle_report():
+ *   - hw/virtio/virtio-balloon.c|960| <<virtio_balloon_device_realize>>
+ *      s->reporting_vq = virtio_add_queue(vdev, 32, virtio_balloon_handle_report);
+ */
 static void virtio_balloon_handle_report(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBalloon *dev = VIRTIO_BALLOON(vdev);
     VirtQueueElement *elem;
 
+    /*
+     * virtio-balloon使用virtqueue_pop()的地方:
+     *   - hw/virtio/virtio-balloon.c|398| <<virtio_balloon_handle_report>> while ((elem = virtqueue_pop(vq, sizeof(VirtQueueElement)))) {
+     *   - hw/virtio/virtio-balloon.c|488| <<virtio_balloon_handle_output>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|543| <<virtio_balloon_receive_stats>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|624| <<get_free_page_hints>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     */
     while ((elem = virtqueue_pop(vq, sizeof(VirtQueueElement)))) {
         unsigned int i;
 
@@ -389,16 +709,47 @@ static void virtio_balloon_handle_report(VirtIODevice *vdev, VirtQueue *vq)
                 continue;
             }
 
+            /*
+	     * 在以下使用ram_block_discard_range():
+             *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+             *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+             *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+             *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+             *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+             *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+             *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+             *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+             *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+             *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+             *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+             *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+             *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+             *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+             *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+	     */
             ram_block_discard_range(rb, ram_offset, size);
         }
 
 skip_element:
+        /*
+	 * virtio-balloon使用virtqueue_push()的地方:
+         *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+         *   - hw/virtio/virtio-balloon.c|594| <<virtio_balloon_handle_report>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|664| <<virtio_balloon_handle_output>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+         *   - hw/virtio/virtio-balloon.c|872| <<get_free_page_hints>> virtqueue_push(vq, elem, 0);
+	 */
         virtqueue_push(vq, elem, 0);
         virtio_notify(vdev, vq);
         g_free(elem);
     }
 }
 
+/*
+ * 在以下使用virtio_balloon_handle_output():
+ *   - hw/virtio/virtio-balloon.c|893| <<virtio_balloon_device_realize>> s->ivq = virtio_add_queue(vdev, 128, virtio_balloon_handle_output);
+ *   - hw/virtio/virtio-balloon.c|894| <<virtio_balloon_device_realize>> s->dvq = virtio_add_queue(vdev, 128, virtio_balloon_handle_output);
+ */
 static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
@@ -406,10 +757,25 @@ static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)
     MemoryRegionSection section;
 
     for (;;) {
+        /*
+	 * #define BALLOON_PAGE_SIZE  (1 << VIRTIO_BALLOON_PFN_SHIFT)
+	 *
+	 * typedef struct PartiallyBalloonedPage {
+	 *     ram_addr_t base_gpa;
+	 *     unsigned long *bitmap;
+	 * } PartiallyBalloonedPage;
+	 */
         PartiallyBalloonedPage pbp = {};
         size_t offset = 0;
         uint32_t pfn;
 
+        /*
+	 * virtio-balloon使用virtqueue_pop()的地方:
+         *   - hw/virtio/virtio-balloon.c|398| <<virtio_balloon_handle_report>> while ((elem = virtqueue_pop(vq, sizeof(VirtQueueElement)))) {
+         *   - hw/virtio/virtio-balloon.c|488| <<virtio_balloon_handle_output>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+         *   - hw/virtio/virtio-balloon.c|543| <<virtio_balloon_receive_stats>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+	 *   - hw/virtio/virtio-balloon.c|624| <<get_free_page_hints>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+	 */
         elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
         if (!elem) {
             break;
@@ -451,6 +817,14 @@ static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)
             memory_region_unref(section.mr);
         }
 
+        /*
+	 * virtio-balloon使用virtqueue_push()的地方:
+         *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+         *   - hw/virtio/virtio-balloon.c|594| <<virtio_balloon_handle_report>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|664| <<virtio_balloon_handle_output>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+         *   - hw/virtio/virtio-balloon.c|872| <<get_free_page_hints>> virtqueue_push(vq, elem, 0);
+	 */
         virtqueue_push(vq, elem, 0);
         virtio_notify(vdev, vq);
         g_free(elem);
@@ -458,6 +832,11 @@ static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)
     }
 }
 
+/*
+ * 在以下使用virtio_balloon_receive_stats():
+ *   - hw/virtio/virtio-balloon.c|1274| <<virtio_balloon_device_realize>> s->svq = virtio_add_queue(vdev, 128, virtio_balloon_receive_stats);
+ *   - hw/virtio/virtio-balloon.c|1388| <<virtio_balloon_set_status>> virtio_balloon_receive_stats(vdev, s->svq);
+ */
 static void virtio_balloon_receive_stats(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
@@ -465,18 +844,49 @@ static void virtio_balloon_receive_stats(VirtIODevice *vdev, VirtQueue *vq)
     VirtIOBalloonStat stat;
     size_t offset = 0;
 
+    /*
+     * virtio-balloon使用virtqueue_pop()的地方:
+     *   - hw/virtio/virtio-balloon.c|398| <<virtio_balloon_handle_report>> while ((elem = virtqueue_pop(vq, sizeof(VirtQueueElement)))) {
+     *   - hw/virtio/virtio-balloon.c|488| <<virtio_balloon_handle_output>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|543| <<virtio_balloon_receive_stats>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|624| <<get_free_page_hints>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     */
     elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
     if (!elem) {
         goto out;
     }
 
     if (s->stats_vq_elem != NULL) {
+        /*
+	 * virtio-balloon使用virtqueue_push()的地方:
+         *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+         *   - hw/virtio/virtio-balloon.c|594| <<virtio_balloon_handle_report>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|664| <<virtio_balloon_handle_output>> virtqueue_push(vq, elem, 0);
+         *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+	 *   - hw/virtio/virtio-balloon.c|872| <<get_free_page_hints>> virtqueue_push(vq, elem, 0);
+	 */
         /* This should never happen if the driver follows the spec. */
         virtqueue_push(vq, s->stats_vq_elem, 0);
         virtio_notify(vdev, vq);
         g_free(s->stats_vq_elem);
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_vq_elem:
+     *   - hw/virtio/virtio-balloon.c|344| <<balloon_stats_poll_cb>> if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|364| <<balloon_stats_poll_cb>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|365| <<balloon_stats_poll_cb>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|695| <<virtio_balloon_receive_stats>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|699| <<virtio_balloon_receive_stats>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|702| <<virtio_balloon_receive_stats>> s->stats_vq_elem = elem;
+     *   - hw/virtio/virtio-balloon.c|1582| <<virtio_balloon_device_reset>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|1583| <<virtio_balloon_device_reset>> virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|1584| <<virtio_balloon_device_reset>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|1585| <<virtio_balloon_device_reset>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|1595| <<virtio_balloon_set_status>> if (!s->stats_vq_elem && vdev->vm_running &&
+     */
     s->stats_vq_elem = elem;
 
     /* Initialize the stats to get rid of any stale values.  This is only
@@ -495,21 +905,64 @@ static void virtio_balloon_receive_stats(VirtIODevice *vdev, VirtQueue *vq)
             s->stats[tag] = val;
     }
     s->stats_vq_offset = offset;
+    /*
+     * 在以下使用VirtIOBalloon->stats_last_update:
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_get_all>> if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
+     *   - hw/virtio/virtio-balloon.c|608| <<virtio_balloon_receive_stats>> s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
+     *   - hw/virtio/virtio-balloon.c|1332| <<virtio_balloon_device_realize>> s->stats_last_update = 0;
+     *   - hw/virtio/virtio-balloon.c|1466| <<virtio_balloon_reset_enter>> s->stats_last_update = 0;
+     */
     s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
 
 out:
     if (balloon_stats_enabled(s)) {
+        /*
+	 * 在以下使用VirtIOBalloon->stats_poll_interval:
+         *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+         *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+         *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+         *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+         *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+	 */
         balloon_stats_change_timer(s, s->stats_poll_interval);
     }
 }
 
+/*
+ * 在以下使用virtio_balloon_handle_free_page_vq():
+ *   - hw/virtio/virtio-balloon.c|1008| <<virtio_balloon_device_realize>> virtio_balloon_handle_free_page_vq);
+ *
+ * 1015     if (virtio_has_feature(s->host_features, VIRTIO_BALLOON_F_FREE_PAGE_HINT)) {
+ * 1016         s->free_page_vq = virtio_add_queue(vdev, VIRTQUEUE_MAX_SIZE,
+ * 1017                                            virtio_balloon_handle_free_page_vq);
+ * 1018         precopy_add_notifier(&s->free_page_hint_notify);
+ */
 static void virtio_balloon_handle_free_page_vq(VirtIODevice *vdev,
                                                VirtQueue *vq)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
+    /*
+     * 在以下使用VirtIOBalloon->free_page_bh:
+     *   - hw/virtio/virtio-balloon.c|582| <<virtio_balloon_handle_free_page_vq>> qemu_bh_schedule(s->free_page_bh);
+     *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+     *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+     *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+     *   - hw/virtio/virtio-balloon.c|1043| <<virtio_balloon_device_unrealize>> if (s->free_page_bh) {
+     *   - hw/virtio/virtio-balloon.c|1044| <<virtio_balloon_device_unrealize>> qemu_bh_delete(s->free_page_bh);
+     *
+     * 处理的函数: virtio_ballloon_get_free_page_hints()
+     */
     qemu_bh_schedule(s->free_page_bh);
 }
 
+/*
+ * 在以下使用get_free_page_hints():
+ *   - hw/virtio/virtio-balloon.c|648| <<virtio_ballloon_get_free_page_hints>> continue_to_get_hints = get_free_page_hints(dev);
+ */
 static bool get_free_page_hints(VirtIOBalloon *dev)
 {
     VirtQueueElement *elem;
@@ -522,6 +975,13 @@ static bool get_free_page_hints(VirtIOBalloon *dev)
         qemu_cond_wait(&dev->free_page_cond, &dev->free_page_lock);
     }
 
+    /*
+     * virtio-balloon使用virtqueue_pop()的地方:
+     *   - hw/virtio/virtio-balloon.c|398| <<virtio_balloon_handle_report>> while ((elem = virtqueue_pop(vq, sizeof(VirtQueueElement)))) {
+     *   - hw/virtio/virtio-balloon.c|488| <<virtio_balloon_handle_output>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|543| <<virtio_balloon_receive_stats>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     *   - hw/virtio/virtio-balloon.c|624| <<get_free_page_hints>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+     */
     elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
     if (!elem) {
         return false;
@@ -538,6 +998,38 @@ static bool get_free_page_hints(VirtIOBalloon *dev)
             ret = false;
             goto out;
         }
+	/*
+	 * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+         *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+         *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+         *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+         *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+         * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+         *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+         *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+         *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+         *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+         *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+         *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+         *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+	 *
+	 * 在以下使用VirtIOBalloon->free_page_hint_status:
+         *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+         *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+         *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+         *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+         *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+         *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+         *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+         *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+         *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+         *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+         *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+         *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+         *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+         *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+         *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+	 */
         if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
             id == dev->free_page_hint_cmd_id) {
             dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
@@ -552,17 +1044,49 @@ static bool get_free_page_hints(VirtIOBalloon *dev)
 
     if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
         for (i = 0; i < elem->in_num; i++) {
+            /*
+	     * 注释:
+	     * This function clears bits of the free pages reported by the caller from the
+	     * migration dirty bitmap. @addr is the host address corresponding to the
+	     * start of the continuous guest free pages, and @len is the total bytes of
+	     * those pages.
+	     */
             qemu_guest_free_page_hint(elem->in_sg[i].iov_base,
                                       elem->in_sg[i].iov_len);
         }
     }
 
 out:
+    /*
+     * virtio-balloon使用virtqueue_push()的地方:
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|594| <<virtio_balloon_handle_report>> virtqueue_push(vq, elem, 0);
+     *   - hw/virtio/virtio-balloon.c|664| <<virtio_balloon_handle_output>> virtqueue_push(vq, elem, 0);
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|872| <<get_free_page_hints>> virtqueue_push(vq, elem, 0);
+     */
     virtqueue_push(vq, elem, 0);
     g_free(elem);
     return ret;
 }
 
+/*
+ * 在以下使用VirtIOBalloon->free_page_bh:
+ *   - hw/virtio/virtio-balloon.c|582| <<virtio_balloon_handle_free_page_vq>> qemu_bh_schedule(s->free_page_bh);
+ *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+ *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+ *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+ *   - hw/virtio/virtio-balloon.c|1043| <<virtio_balloon_device_unrealize>> if (s->free_page_bh) {
+ *   - hw/virtio/virtio-balloon.c|1044| <<virtio_balloon_device_unrealize>> qemu_bh_delete(s->free_page_bh);
+ *
+ * 处理的函数: virtio_ballloon_get_free_page_hints()
+ *
+ *
+ * 在以下使用virtio_ballloon_get_free_page_hints():
+ *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+ *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+ *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+ */
 static void virtio_ballloon_get_free_page_hints(void *opaque)
 {
     VirtIOBalloon *dev = opaque;
@@ -570,9 +1094,30 @@ static void virtio_ballloon_get_free_page_hints(void *opaque)
     VirtQueue *vq = dev->free_page_vq;
     bool continue_to_get_hints;
 
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     do {
         qemu_mutex_lock(&dev->free_page_lock);
         virtio_queue_set_notification(vq, 0);
+        /*
+	 * 只在这里调用
+	 */
         continue_to_get_hints = get_free_page_hints(dev);
         qemu_mutex_unlock(&dev->free_page_lock);
         virtio_notify(vdev, vq);
@@ -585,6 +1130,13 @@ static void virtio_ballloon_get_free_page_hints(void *opaque)
     virtio_queue_set_notification(vq, 1);
 }
 
+/*
+ * 在以下使用virtio_balloon_free_page_support()
+ *   - hw/virtio/virtio-balloon.c|1159| <<global>> .needed = virtio_balloon_free_page_support,
+ *   - hw/virtio/virtio-balloon.c|891| <<virtio_balloon_free_page_hint_notify>> if (!virtio_balloon_free_page_support(dev)) {
+ *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_reset>> if (virtio_balloon_free_page_support(s)) {
+ *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_set_status>> if (virtio_balloon_free_page_support(s)) {
+ */
 static bool virtio_balloon_free_page_support(void *opaque)
 {
     VirtIOBalloon *s = opaque;
@@ -593,28 +1145,89 @@ static bool virtio_balloon_free_page_support(void *opaque)
     return virtio_vdev_has_feature(vdev, VIRTIO_BALLOON_F_FREE_PAGE_HINT);
 }
 
+/*
+ * 在以下使用virtio_balloon_free_page_start():
+ *   - hw/virtio/virtio-balloon.c|971| <<virtio_balloon_free_page_hint_notify>> virtio_balloon_free_page_start(dev);
+ */
 static void virtio_balloon_free_page_start(VirtIOBalloon *s)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
 
     qemu_mutex_lock(&s->free_page_lock);
 
+    /*
+     * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+     *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+     *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+     *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     */
     if (s->free_page_hint_cmd_id == UINT_MAX) {
         s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
     } else {
         s->free_page_hint_cmd_id++;
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
     qemu_mutex_unlock(&s->free_page_lock);
 
     virtio_notify_config(vdev);
 }
 
+/*
+ * 在以下使用virtio_balloon_free_page_stop():
+ *   - hw/virtio/virtio-balloon.c|967| <<virtio_balloon_free_page_hint_notify>> virtio_balloon_free_page_stop(dev);
+ *   - hw/virtio/virtio-balloon.c|1338| <<virtio_balloon_device_unrealize>> virtio_balloon_free_page_stop(s);
+ *   - hw/virtio/virtio-balloon.c|1368| <<virtio_balloon_device_reset>> virtio_balloon_free_page_stop(s);
+ */
 static void virtio_balloon_free_page_stop(VirtIOBalloon *s)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
 
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
         /*
          * The lock also guarantees us that the
@@ -632,10 +1245,32 @@ static void virtio_balloon_free_page_stop(VirtIOBalloon *s)
     }
 }
 
+/*
+ * 在以下使用virtio_balloon_free_page_done():
+ *   - hw/virtio/virtio-balloon.c|983| <<virtio_balloon_free_page_hint_notify>> virtio_balloon_free_page_done(dev);
+ */
 static void virtio_balloon_free_page_done(VirtIOBalloon *s)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
 
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
         /* See virtio_balloon_free_page_stop() */
         qemu_mutex_lock(&s->free_page_lock);
@@ -645,6 +1280,82 @@ static void virtio_balloon_free_page_done(VirtIOBalloon *s)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_balloon_free_page_hint_notify (n=0x555558509d50, data=0x7ffdd4dfd664, errp=0x7ffdd4dfd690)
+ * #1  0x00005555561610d1 in notifier_with_return_list_notify (list=0x55555751aa08 <precopy_notifier_list>
+ * #2  0x0000555555c774d1 in precopy_notify (reason=PRECOPY_NOTIFY_BEFORE_BITMAP_SYNC, errp=0x7ffdd4dfd690)
+ * #3  0x0000555555c794a1 in migration_bitmap_sync_precopy (last_stage=false) at ../migration/ram.c:1200
+ * #4  0x0000555555c7d33a in ram_init_bitmaps (rs=0x7ffdc4000c00, errp=0x7ffdd4dfd828)
+ * #5  0x0000555555c7d425 in ram_init_all (rsp=0x55555751aa00 <ram_state>, errp=0x7ffdd4dfd828) 
+ * #6  0x0000555555c7dbec in ram_save_setup (f=0x555557acc8d0, opaque=0x55555751aa00 <ram_state>
+ * #7  0x0000555555c86a22 in qemu_savevm_state_setup (f=0x555557acc8d0, errp=0x7ffdd4dfd828)
+ * #8  0x0000555555c65bdb in migration_thread (opaque=0x5555578cfbe0) at ../migration/migration.c:3810
+ * #9  0x00005555561580bb in qemu_thread_start (args=0x555557f59960) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff6c9a1da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4fcb8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  virtio_balloon_free_page_hint_notify (n=0x555558509d50, data=0x7ffdd4dfd664, errp=0x7ffdd4dfd690)
+ * #1  0x00005555561610d1 in notifier_with_return_list_notify (list=0x55555751aa08 <precopy_notifier_list>
+ * #2  0x0000555555c774d1 in precopy_notify (reason=PRECOPY_NOTIFY_AFTER_BITMAP_SYNC, errp=0x7ffdd4dfd690)
+ * #3  0x0000555555c794df in migration_bitmap_sync_precopy (last_stage=false) at ../migration/ram.c:1207
+ * #4  0x0000555555c7d33a in ram_init_bitmaps (rs=0x7ffdc4000c00, errp=0x7ffdd4dfd828)
+ * #5  0x0000555555c7d425 in ram_init_all (rsp=0x55555751aa00 <ram_state>, errp=0x7ffdd4dfd828)
+ * #6  0x0000555555c7dbec in ram_save_setup (f=0x555557acc8d0, opaque=0x55555751aa00 <ram_state>
+ * #7  0x0000555555c86a22 in qemu_savevm_state_setup (f=0x555557acc8d0, errp=0x7ffdd4dfd828)
+ * #8  0x0000555555c65bdb in migration_thread (opaque=0x5555578cfbe0) at ../migration/migration.c:3810
+ * #9  0x00005555561580bb in qemu_thread_start (args=0x555557f59960) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff6c9a1da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4fcb8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  virtio_balloon_free_page_hint_notify (n=0x555558509d50, data=0x7ffdd4dfd774, errp=0x7ffdd4dfd828)
+ * #1  0x00005555561610d1 in notifier_with_return_list_notify (list=0x55555751aa08 <precopy_notifier_list>
+ * #2  0x0000555555c774d1 in precopy_notify (reason=PRECOPY_NOTIFY_SETUP, errp=0x7ffdd4dfd828)
+ * #3  0x0000555555c86a8a in qemu_savevm_state_setup (f=0x555557acc8d0, errp=0x7ffdd4dfd828)
+ * #4  0x0000555555c65bdb in migration_thread (opaque=0x5555578cfbe0) at ../migration/migration.c:3810
+ * #5  0x00005555561580bb in qemu_thread_start (args=0x555557f59960) at ../util/qemu-thread-posix.c:393
+ * #6  0x00007ffff6c9a1da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4fcb8d3 in clone () from /lib64/libc.so.6
+ * 
+ * (gdb) bt
+ * #0  virtio_balloon_free_page_hint_notify (n=0x555558509d50, data=0x7ffdd4dfd6d4, errp=0x7ffdd4dfd700)
+ * #1  0x00005555561610d1 in notifier_with_return_list_notify (list=0x55555751aa08 <precopy_notifier_list>
+ * #2  0x0000555555c774d1 in precopy_notify (reason=PRECOPY_NOTIFY_AFTER_BITMAP_SYNC, errp=0x7ffdd4dfd700)
+ * #3  0x0000555555c794df in migration_bitmap_sync_precopy (last_stage=false) at ../migration/ram.c:1207
+ * #4  0x0000555555c7e94c in ram_state_pending_exact (opaque=0x55555751aa00 <ram_state>,
+ * #5  0x0000555555c87892 in qemu_savevm_state_pending_exact (must_precopy=0x7ffdd4dfd7c8,
+ * #6  0x0000555555c65474 in migration_iteration_run (s=0x5555578cfbe0) at ../migration/migration.c:3514
+ * #7  0x0000555555c65c8e in migration_thread (opaque=0x5555578cfbe0) at ../migration/migration.c:3834
+ * #8  0x00005555561580bb in qemu_thread_start (args=0x555557f59960) at ../util/qemu-thread-posix.c:393
+ * #9  0x00007ffff6c9a1da in start_thread () from /lib64/libpthread.so.0
+ * #10 0x00007ffff4fcb8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  virtio_balloon_free_page_hint_notify (n=0x555558509d50, data=0x7ffdd4dfd6b4, errp=0x7ffdd4dfd6d0)
+ * #1  0x00005555561610d1 in notifier_with_return_list_notify (list=0x55555751aa08 <precopy_notifier_list>,
+ * #2  0x0000555555c774d1 in precopy_notify (reason=PRECOPY_NOTIFY_COMPLETE, errp=0x7ffdd4dfd6d0)
+ * #3  0x0000555555c5dcbf in precopy_notify_complete () at ../migration/migration.c:157
+ * #4  0x0000555555c64434 in migration_switchover_start (s=0x5555578cfbe0, errp=0x7ffdd4dfd700)
+ * #5  0x0000555555c644e4 in migration_completion_precopy (s=0x5555578cfbe0)
+ * #6  0x0000555555c645d4 in migration_completion (s=0x5555578cfbe0) at ../migration/migration.c:3064
+ * #7  0x0000555555c6554f in migration_iteration_run (s=0x5555578cfbe0) at ../migration/migration.c:3542
+ * #8  0x0000555555c65c8e in migration_thread (opaque=0x5555578cfbe0) at ../migration/migration.c:3834
+ * #9  0x00005555561580bb in qemu_thread_start (args=0x555557f59960) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff6c9a1da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4fcb8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * 在以下使用VirtIOBalloon->free_page_hint_notify:
+ *   - hw/virtio/virtio-balloon.c|961| <<virtio_balloon_free_page_hint_notify>> VirtIOBalloon *dev = container_of(n, VirtIOBalloon, free_page_hint_notify);
+ *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+ *   - hw/virtio/virtio-balloon.c|1367| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+ *   - hw/virtio/virtio-balloon.c|1491| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+ *
+ * 在以下使用virtio_balloon_free_page_hint_notify():
+ *   - hw/virtio/virtio-balloon.c|1396| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+ */
 static int
 virtio_balloon_free_page_hint_notify(NotifierWithReturn *n, void *data,
                                      Error **errp)
@@ -653,6 +1364,13 @@ virtio_balloon_free_page_hint_notify(NotifierWithReturn *n, void *data,
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
     PrecopyNotifyData *pnd = data;
 
+    /*
+     * 在以下使用virtio_balloon_free_page_support()
+     *   - hw/virtio/virtio-balloon.c|1159| <<global>> .needed = virtio_balloon_free_page_support,
+     *   - hw/virtio/virtio-balloon.c|891| <<virtio_balloon_free_page_hint_notify>> if (!virtio_balloon_free_page_support(dev)) {
+     *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_reset>> if (virtio_balloon_free_page_support(s)) {
+     *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_set_status>> if (virtio_balloon_free_page_support(s)) {
+     */
     if (!virtio_balloon_free_page_support(dev)) {
         /*
          * This is an optimization provided to migration, so just return 0 to
@@ -704,6 +1422,12 @@ virtio_balloon_free_page_hint_notify(NotifierWithReturn *n, void *data,
     return 0;
 }
 
+/*
+ * 在以下使用virtio_balloon_config_size():
+ *   - hw/virtio/virtio-balloon.c|816| <<virtio_balloon_get_config>> memcpy(config_data, &config, virtio_balloon_config_size(dev));
+ *   - hw/virtio/virtio-balloon.c|849| <<virtio_balloon_set_config>> memcpy(&config, config_data, virtio_balloon_config_size(dev));
+ *   - hw/virtio/virtio-balloon.c|984| <<virtio_balloon_device_realize>> virtio_init(vdev, VIRTIO_ID_BALLOON, virtio_balloon_config_size(s));
+ */
 static size_t virtio_balloon_config_size(VirtIOBalloon *s)
 {
     uint64_t features = s->host_features;
@@ -717,6 +1441,21 @@ static size_t virtio_balloon_config_size(VirtIOBalloon *s)
     if (virtio_has_feature(features, VIRTIO_BALLOON_F_FREE_PAGE_HINT)) {
         return offsetof(struct virtio_balloon_config, poison_val);
     }
+    /*
+     * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+     *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+     *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+     *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     */
     return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
 }
 
@@ -729,6 +1468,39 @@ static void virtio_balloon_get_config(VirtIODevice *vdev, uint8_t *config_data)
     config.actual = cpu_to_le32(dev->actual);
     config.poison_val = cpu_to_le32(dev->poison_val);
 
+    /*
+     * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+     *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+     *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+     *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *
+     *
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
         config.free_page_hint_cmd_id =
                        cpu_to_le32(dev->free_page_hint_cmd_id);
@@ -744,6 +1516,12 @@ static void virtio_balloon_get_config(VirtIODevice *vdev, uint8_t *config_data)
     memcpy(config_data, &config, virtio_balloon_config_size(dev));
 }
 
+/*
+ * 在以下使用get_current_ram_size():
+ *   - hw/virtio/virtio-balloon.c|1282| <<virtio_balloon_set_config>> ram_addr_t vm_ram_size = get_current_ram_size();
+ *   - hw/virtio/virtio-balloon.c|1338| <<virtio_balloon_stat>> info->actual = get_current_ram_size() - ((uint64_t) dev->actual <<
+ *   - hw/virtio/virtio-balloon.c|1351| <<virtio_balloon_to_target>> ram_addr_t vm_ram_size = get_current_ram_size();
+ */
 static ram_addr_t get_current_ram_size(void)
 {
     MachineState *machine = MACHINE(qdev_get_machine());
@@ -754,6 +1532,11 @@ static ram_addr_t get_current_ram_size(void)
     }
 }
 
+/*
+ * 在以下使用virtio_balloon_page_poison_support():
+ *   - hw/virtio/virtio-balloon.c|1401| <<global>> .needed = virtio_balloon_page_poison_support,
+ *   - hw/virtio/virtio-balloon.c|1319| <<virtio_balloon_set_config>> if (virtio_balloon_page_poison_support(dev)) {
+ */
 static bool virtio_balloon_page_poison_support(void *opaque)
 {
     VirtIOBalloon *s = opaque;
@@ -762,17 +1545,55 @@ static bool virtio_balloon_page_poison_support(void *opaque)
     return virtio_vdev_has_feature(vdev, VIRTIO_BALLOON_F_PAGE_POISON);
 }
 
+/*
+ * 在以下使用virtio_balloon_set_config():
+ *   - hw/virtio/virtio-balloon.c|1076| <<virtio_balloon_class_init>> vdc->set_config = virtio_balloon_set_config;
+ */
 static void virtio_balloon_set_config(VirtIODevice *vdev,
                                       const uint8_t *config_data)
 {
     VirtIOBalloon *dev = VIRTIO_BALLOON(vdev);
     struct virtio_balloon_config config;
     uint32_t oldactual = dev->actual;
+    /*
+     * 在以下使用get_current_ram_size():
+     *   - hw/virtio/virtio-balloon.c|1282| <<virtio_balloon_set_config>> ram_addr_t vm_ram_size = get_current_ram_size();
+     *   - hw/virtio/virtio-balloon.c|1338| <<virtio_balloon_stat>> info->actual = get_current_ram_size() - ((uint64_t) dev->actual <<
+     *   - hw/virtio/virtio-balloon.c|1351| <<virtio_balloon_to_target>> ram_addr_t vm_ram_size = get_current_ram_size();
+     */
     ram_addr_t vm_ram_size = get_current_ram_size();
 
     memcpy(&config, config_data, virtio_balloon_config_size(dev));
     dev->actual = le32_to_cpu(config.actual);
     if (dev->actual != oldactual) {
+        /*
+	 * qapi的代码
+	 * 1154 ##
+	 * 1155 # @BALLOON_CHANGE:
+	 * 1156 #
+	 * 1157 # Emitted when the guest changes the actual BALLOON level.  This value
+	 * 1158 # is equivalent to the @actual field return by the `query-balloon`
+	 * 1159 # command
+	 * 1160 #
+	 * 1161 # @actual: the logical size of the VM in bytes.  Formula used:
+	 * 1162 #     logical_vm_size = vm_ram_size - balloon_size
+	 * 1163 #
+	 * 1164 # .. note:: This event is rate-limited.
+	 * 1165 #
+	 * 1166 # Since: 1.2
+	 * 1167 #
+	 * 1168 # .. qmp-example::
+	 * 1169 #
+	 * 1170 #     <- { "event": "BALLOON_CHANGE",
+	 * 1171 #          "data": { "actual": 944766976 },
+	 * 1172 #          "timestamp": { "seconds": 1267020223, "microseconds": 435656 } }
+	 * 1173 ##
+	 * 1174 { 'event': 'BALLOON_CHANGE',
+	 * 1175   'data': { 'actual': 'int' } }
+	 *
+	 * 只在这里使用
+	 * 重点"This event is rate-limited"
+	 */
         qapi_event_send_balloon_change(vm_ram_size -
                         ((ram_addr_t) dev->actual << VIRTIO_BALLOON_PFN_SHIFT));
     }
@@ -796,14 +1617,31 @@ static uint64_t virtio_balloon_get_features(VirtIODevice *vdev, uint64_t f,
 static void virtio_balloon_stat(void *opaque, BalloonInfo *info)
 {
     VirtIOBalloon *dev = opaque;
+    /*
+     * 在以下使用get_current_ram_size():
+     *   - hw/virtio/virtio-balloon.c|1282| <<virtio_balloon_set_config>> ram_addr_t vm_ram_size = get_current_ram_size();
+     *   - hw/virtio/virtio-balloon.c|1338| <<virtio_balloon_stat>> info->actual = get_current_ram_size() - ((uint64_t) dev->actual <<
+     *   - hw/virtio/virtio-balloon.c|1351| <<virtio_balloon_to_target>> ram_addr_t vm_ram_size = get_current_ram_size();
+     */
     info->actual = get_current_ram_size() - ((uint64_t) dev->actual <<
                                              VIRTIO_BALLOON_PFN_SHIFT);
 }
 
+/*
+ * 在以下使用virtio_balloon_to_target():
+ *   - hw/virtio/virtio-balloon.c|889| <<virtio_balloon_device_realize>>
+ *          ret = qemu_add_balloon_handler(virtio_balloon_to_target, virtio_balloon_stat, s);
+ */
 static void virtio_balloon_to_target(void *opaque, ram_addr_t target)
 {
     VirtIOBalloon *dev = VIRTIO_BALLOON(opaque);
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
+    /*
+     * 在以下使用get_current_ram_size():
+     *   - hw/virtio/virtio-balloon.c|1282| <<virtio_balloon_set_config>> ram_addr_t vm_ram_size = get_current_ram_size();
+     *   - hw/virtio/virtio-balloon.c|1338| <<virtio_balloon_stat>> info->actual = get_current_ram_size() - ((uint64_t) dev->actual <<
+     *   - hw/virtio/virtio-balloon.c|1351| <<virtio_balloon_to_target>> ram_addr_t vm_ram_size = get_current_ram_size();
+     */
     ram_addr_t vm_ram_size = get_current_ram_size();
 
     if (target > vm_ram_size) {
@@ -821,6 +1659,18 @@ static int virtio_balloon_post_load_device(void *opaque, int version_id)
     VirtIOBalloon *s = VIRTIO_BALLOON(opaque);
 
     if (balloon_stats_enabled(s)) {
+        /*
+	 * 在以下使用VirtIOBalloon->stats_poll_interval:
+	 *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+	 *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+         *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+         *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+         *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+         *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+         *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+	 */
         balloon_stats_change_timer(s, s->stats_poll_interval);
     }
     return 0;
@@ -874,6 +1724,13 @@ static void virtio_balloon_device_realize(DeviceState *dev, Error **errp)
 
     virtio_init(vdev, VIRTIO_ID_BALLOON, virtio_balloon_config_size(s));
 
+    /*
+     * 在以下使用qemu_add_balloon_handler():
+     *   - hw/hyperv/hv-balloon.c|1504| <<hv_balloon_vmdev_realize>>
+     *         ret = qemu_add_balloon_handler(hv_balloon_to_target, hv_balloon_stat, balloon);
+     *   - hw/virtio/virtio-balloon.c|1317| <<virtio_balloon_device_realize>>
+     *         ret = qemu_add_balloon_handler(virtio_balloon_to_target, virtio_balloon_stat, s);
+     */
     ret = qemu_add_balloon_handler(virtio_balloon_to_target,
                                    virtio_balloon_stat, s);
 
@@ -897,9 +1754,27 @@ static void virtio_balloon_device_realize(DeviceState *dev, Error **errp)
     if (virtio_has_feature(s->host_features, VIRTIO_BALLOON_F_FREE_PAGE_HINT)) {
         s->free_page_vq = virtio_add_queue(vdev, VIRTQUEUE_MAX_SIZE,
                                            virtio_balloon_handle_free_page_vq);
+        /*
+	 * 在以下使用VirtIOBalloon->free_page_hint_notify:
+         *   - hw/virtio/virtio-balloon.c|961| <<virtio_balloon_free_page_hint_notify>> VirtIOBalloon *dev = container_of(n, VirtIOBalloon, free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1367| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1491| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+	 */
         precopy_add_notifier(&s->free_page_hint_notify);
 
         object_ref(OBJECT(s->iothread));
+        /*
+	 * 在以下使用VirtIOBalloon->free_page_bh:
+         *   - hw/virtio/virtio-balloon.c|582| <<virtio_balloon_handle_free_page_vq>> qemu_bh_schedule(s->free_page_bh);
+         *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+         *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+         *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+         *   - hw/virtio/virtio-balloon.c|1043| <<virtio_balloon_device_unrealize>> if (s->free_page_bh) {
+         *   - hw/virtio/virtio-balloon.c|1044| <<virtio_balloon_device_unrealize>> qemu_bh_delete(s->free_page_bh);
+         *
+         * 处理的函数: virtio_ballloon_get_free_page_hints()
+	 */
         s->free_page_bh = aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
                                              virtio_ballloon_get_free_page_hints, s,
                                              &dev->mem_reentrancy_guard);
@@ -910,8 +1785,31 @@ static void virtio_balloon_device_realize(DeviceState *dev, Error **errp)
                                            virtio_balloon_handle_report);
     }
 
+    /*
+     * 在以下使用reset_stats():
+     *   - hw/virtio/virtio-balloon.c|596| <<virtio_balloon_receive_stats>> reset_stats(s);
+     *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_device_realize>> reset_stats(s);
+     *   - hw/virtio/virtio-balloon.c|1465| <<virtio_balloon_reset_enter>> reset_stats(s);
+     */
     reset_stats(s);
+    /*
+     * 在以下使用VirtIOBalloon->stats_last_update:
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_get_all>> if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
+     *   - hw/virtio/virtio-balloon.c|608| <<virtio_balloon_receive_stats>> s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
+     *   - hw/virtio/virtio-balloon.c|1332| <<virtio_balloon_device_realize>> s->stats_last_update = 0;
+     *   - hw/virtio/virtio-balloon.c|1466| <<virtio_balloon_reset_enter>> s->stats_last_update = 0;
+     */
     s->stats_last_update = 0;
+    /*
+     * 在以下使用qemu_register_resettable():
+     *   - hw/core/machine.c|1805| <<qdev_machine_creation_done>> qemu_register_resettable(OBJECT(sysbus_get_default()));
+     *   - hw/core/reset.c|102| <<qemu_register_reset>> qemu_register_resettable(obj);
+     *   - hw/core/reset.c|113| <<qemu_register_reset_nosnapshotload>> qemu_register_resettable(obj);
+     *   - hw/loongarch/virt.c|1145| <<virt_cpu_plug>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/misc/vmcoreinfo.c|68| <<vmcoreinfo_realize>> qemu_register_resettable(OBJECT(s));
+     *   - hw/virtio/virtio-balloon.c|970| <<virtio_balloon_device_realize>> qemu_register_resettable(OBJECT(dev));
+     *   - hw/virtio/virtio-mem.c|1150| <<virtio_mem_device_realize>> qemu_register_resettable(obj);
+     */
     qemu_register_resettable(OBJECT(dev));
 }
 
@@ -921,10 +1819,28 @@ static void virtio_balloon_device_unrealize(DeviceState *dev)
     VirtIOBalloon *s = VIRTIO_BALLOON(dev);
 
     qemu_unregister_resettable(OBJECT(dev));
+    /*
+     * 在以下使用VirtIOBalloon->free_page_bh:
+     *   - hw/virtio/virtio-balloon.c|582| <<virtio_balloon_handle_free_page_vq>> qemu_bh_schedule(s->free_page_bh);
+     *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+     *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+     *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+     *   - hw/virtio/virtio-balloon.c|1043| <<virtio_balloon_device_unrealize>> if (s->free_page_bh) {
+     *   - hw/virtio/virtio-balloon.c|1044| <<virtio_balloon_device_unrealize>> qemu_bh_delete(s->free_page_bh);
+     *
+     * 处理的函数: virtio_ballloon_get_free_page_hints()
+     */
     if (s->free_page_bh) {
         qemu_bh_delete(s->free_page_bh);
         object_unref(OBJECT(s->iothread));
         virtio_balloon_free_page_stop(s);
+        /*
+	 * 在以下使用VirtIOBalloon->free_page_hint_notify:
+         *   - hw/virtio/virtio-balloon.c|961| <<virtio_balloon_free_page_hint_notify>> VirtIOBalloon *dev = container_of(n, VirtIOBalloon, free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1367| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+         *   - hw/virtio/virtio-balloon.c|1491| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+	 */
         precopy_remove_notifier(&s->free_page_hint_notify);
     }
     balloon_stats_destroy_timer(s);
@@ -946,10 +1862,33 @@ static void virtio_balloon_device_reset(VirtIODevice *vdev)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
 
+    /*
+     * 在以下使用virtio_balloon_free_page_support()
+     *   - hw/virtio/virtio-balloon.c|1159| <<global>> .needed = virtio_balloon_free_page_support,
+     *   - hw/virtio/virtio-balloon.c|891| <<virtio_balloon_free_page_hint_notify>> if (!virtio_balloon_free_page_support(dev)) {
+     *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_reset>> if (virtio_balloon_free_page_support(s)) {
+     *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_set_status>> if (virtio_balloon_free_page_support(s)) {
+     */
     if (virtio_balloon_free_page_support(s)) {
         virtio_balloon_free_page_stop(s);
     }
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_vq_elem:
+     *   - hw/virtio/virtio-balloon.c|344| <<balloon_stats_poll_cb>> if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|364| <<balloon_stats_poll_cb>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|365| <<balloon_stats_poll_cb>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|695| <<virtio_balloon_receive_stats>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|699| <<virtio_balloon_receive_stats>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|702| <<virtio_balloon_receive_stats>> s->stats_vq_elem = elem;
+     *   - hw/virtio/virtio-balloon.c|1582| <<virtio_balloon_device_reset>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|1583| <<virtio_balloon_device_reset>> virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|1584| <<virtio_balloon_device_reset>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|1585| <<virtio_balloon_device_reset>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|1595| <<virtio_balloon_set_status>> if (!s->stats_vq_elem && vdev->vm_running &&
+     */
     if (s->stats_vq_elem != NULL) {
         virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
         g_free(s->stats_vq_elem);
@@ -963,6 +1902,22 @@ static int virtio_balloon_set_status(VirtIODevice *vdev, uint8_t status)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
 
+    /*
+     * 在以下使用VirtIOBalloon->stats_vq_elem:
+     *   - hw/virtio/virtio-balloon.c|344| <<balloon_stats_poll_cb>> if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|364| <<balloon_stats_poll_cb>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|365| <<balloon_stats_poll_cb>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|695| <<virtio_balloon_receive_stats>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|699| <<virtio_balloon_receive_stats>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|702| <<virtio_balloon_receive_stats>> s->stats_vq_elem = elem;
+     *   - hw/virtio/virtio-balloon.c|1582| <<virtio_balloon_device_reset>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|1583| <<virtio_balloon_device_reset>> virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|1584| <<virtio_balloon_device_reset>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|1585| <<virtio_balloon_device_reset>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|1595| <<virtio_balloon_set_status>> if (!s->stats_vq_elem && vdev->vm_running &&
+     */
     if (!s->stats_vq_elem && vdev->vm_running &&
         (status & VIRTIO_CONFIG_S_DRIVER_OK) && virtqueue_rewind(s->svq, 1)) {
         /* poll stats queue for the element we have discarded when the VM
@@ -970,6 +1925,13 @@ static int virtio_balloon_set_status(VirtIODevice *vdev, uint8_t status)
         virtio_balloon_receive_stats(vdev, s->svq);
     }
 
+    /*
+     * 在以下使用virtio_balloon_free_page_support()
+     *   - hw/virtio/virtio-balloon.c|1159| <<global>> .needed = virtio_balloon_free_page_support,
+     *   - hw/virtio/virtio-balloon.c|891| <<virtio_balloon_free_page_hint_notify>> if (!virtio_balloon_free_page_support(dev)) {
+     *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_reset>> if (virtio_balloon_free_page_support(s)) {
+     *   - hw/virtio/virtio-balloon.c|1331| <<virtio_balloon_set_status>> if (virtio_balloon_free_page_support(s)) {
+     */
     if (virtio_balloon_free_page_support(s)) {
         /*
          * The VM is woken up and the iothread was blocked, so signal it to
@@ -1010,6 +1972,13 @@ static void virtio_balloon_reset_enter(Object *obj, ResetType type)
     }
 
     reset_stats(s);
+    /*
+     * 在以下使用VirtIOBalloon->stats_last_update:
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_get_all>> if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
+     *   - hw/virtio/virtio-balloon.c|608| <<virtio_balloon_receive_stats>> s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
+     *   - hw/virtio/virtio-balloon.c|1332| <<virtio_balloon_device_realize>> s->stats_last_update = 0;
+     *   - hw/virtio/virtio-balloon.c|1466| <<virtio_balloon_reset_enter>> s->stats_last_update = 0;
+     */
     s->stats_last_update = 0;
 }
 
@@ -1019,7 +1988,29 @@ static void virtio_balloon_instance_init(Object *obj)
 
     qemu_mutex_init(&s->free_page_lock);
     qemu_cond_init(&s->free_page_cond);
+    /*
+     * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+     *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+     *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+     *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     */
     s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_notify:
+     *   - hw/virtio/virtio-balloon.c|961| <<virtio_balloon_free_page_hint_notify>> VirtIOBalloon *dev = container_of(n, VirtIOBalloon, free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1367| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1491| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+     */
     s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
 
     object_property_add(obj, "guest-stats", "guest statistics",
diff --git a/hw/virtio/virtio-pci.c b/hw/virtio/virtio-pci.c
index 99cb30fe5..e6a8a27c9 100644
--- a/hw/virtio/virtio-pci.c
+++ b/hw/virtio/virtio-pci.c
@@ -43,6 +43,53 @@
 #include "system/replay.h"
 #include "trace.h"
 
+/*
+ * main_system_bus
+ * ----------------------------------
+ *        |
+ *        |
+ *   i440FX-pcihost
+ *        |
+ *        |
+ *  pci.0 |
+ * -------------------------------------------------
+ *         |                |                    |
+ *         |                |                    |
+ *  vhost-scsi-pci   virtio-balloon-pci   virtio-crypto-pci
+ *                          |
+ *                          |
+ *       per-device virtio-bus |
+ *         -----------------------------------
+ *                   virtio-balloon-device
+ *
+ *
+ *
+ *                              main_system_bus
+ * --------------------------------------------------------------
+ *                                     |
+ *                              i440FX-pci-host
+ *                                     |
+ *                                     |
+ *                            pci.0    |
+ * ----------------------------------------------------------------------------
+ *   |            |              |                 |                     |
+ *   |            |              |                 |                     |
+ * i440FX        PIIX3         e1000            piix3-ide             PIIX4_PM
+ *                |
+ *                |
+ *         isa.0  |
+ *     -------------------------------------------------
+ *         |            |           |              |
+ *         |            |           |              |
+ *     kvm-i8259    kvm-i8259    isa-fdc        kvm-pit
+ *                                  |
+ *                                  |
+ *                    floppy-bus.0  |
+ *                          -------------------
+ *                                  |
+ *                               floppy
+ */
+
 #define VIRTIO_PCI_REGION_SIZE(dev)     VIRTIO_PCI_CONFIG_OFF(msix_present(dev))
 
 #undef VIRTIO_PCI_CONFIG
@@ -442,6 +489,13 @@ static void virtio_ioport_write(void *opaque, uint32_t addr, uint32_t val)
     case VIRTIO_PCI_QUEUE_PFN:
         pa = (hwaddr)val << VIRTIO_PCI_QUEUE_ADDR_SHIFT;
         if (pa == 0) {
+            /*
+	     * 在以下使用virtio_pci_reset():
+             *   - hw/virtio/virtio-pci.c|445| <<virtio_ioport_write(VIRTIO_PCI_QUEUE_PFN)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|477| <<virtio_ioport_write(VIRTIO_PCI_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|1691| <<virtio_pci_common_write(VIRTIO_PCI_COMMON_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|2421| <<virtio_pci_bus_reset_hold>> virtio_pci_reset(qdev);
+	     */
             virtio_pci_reset(DEVICE(proxy));
         }
         else
@@ -474,6 +528,13 @@ static void virtio_ioport_write(void *opaque, uint32_t addr, uint32_t val)
         }
 
         if (vdev->status == 0) {
+            /*
+	     * 在以下使用virtio_pci_reset():
+	     *   - hw/virtio/virtio-pci.c|445| <<virtio_ioport_write(VIRTIO_PCI_QUEUE_PFN)>> virtio_pci_reset(DEVICE(proxy));
+	     *   - hw/virtio/virtio-pci.c|477| <<virtio_ioport_write(VIRTIO_PCI_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+	     *   - hw/virtio/virtio-pci.c|1691| <<virtio_pci_common_write(VIRTIO_PCI_COMMON_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+	     *   - hw/virtio/virtio-pci.c|2421| <<virtio_pci_bus_reset_hold>> virtio_pci_reset(qdev);
+	     */
             virtio_pci_reset(DEVICE(proxy));
         }
 
@@ -1688,6 +1749,13 @@ static void virtio_pci_common_write(void *opaque, hwaddr addr,
         }
 
         if (vdev->status == 0) {
+            /*
+	     * 在以下使用virtio_pci_reset():
+             *   - hw/virtio/virtio-pci.c|445| <<virtio_ioport_write(VIRTIO_PCI_QUEUE_PFN)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|477| <<virtio_ioport_write(VIRTIO_PCI_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|1691| <<virtio_pci_common_write(VIRTIO_PCI_COMMON_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+             *   - hw/virtio/virtio-pci.c|2421| <<virtio_pci_bus_reset_hold>> virtio_pci_reset(qdev);
+	     */
             virtio_pci_reset(DEVICE(proxy));
         }
 
@@ -2370,6 +2438,13 @@ static void virtio_pci_exit(PCIDevice *pci_dev)
     }
 }
 
+/*
+ * 在以下使用virtio_pci_reset():
+ *   - hw/virtio/virtio-pci.c|445| <<virtio_ioport_write(VIRTIO_PCI_QUEUE_PFN)>> virtio_pci_reset(DEVICE(proxy));
+ *   - hw/virtio/virtio-pci.c|477| <<virtio_ioport_write(VIRTIO_PCI_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+ *   - hw/virtio/virtio-pci.c|1691| <<virtio_pci_common_write(VIRTIO_PCI_COMMON_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+ *   - hw/virtio/virtio-pci.c|2421| <<virtio_pci_bus_reset_hold>> virtio_pci_reset(qdev);
+ */
 static void virtio_pci_reset(DeviceState *qdev)
 {
     VirtIOPCIProxy *proxy = VIRTIO_PCI(qdev);
@@ -2409,6 +2484,10 @@ static bool virtio_pci_no_soft_reset(PCIDevice *dev)
            (pmcsr & PCI_PM_CTRL_STATE_MASK) == 3;
 }
 
+/*
+ * 在以下使用virtio_pci_bus_reset_hold():
+ *   - hw/virtio/virtio-pci.c|2507| <<virtio_pci_class_init>> rc->phases.hold = virtio_pci_bus_reset_hold;
+ */
 static void virtio_pci_bus_reset_hold(Object *obj, ResetType type)
 {
     PCIDevice *dev = PCI_DEVICE(obj);
@@ -2418,6 +2497,13 @@ static void virtio_pci_bus_reset_hold(Object *obj, ResetType type)
         return;
     }
 
+    /*
+     * 在以下使用virtio_pci_reset():
+     *   - hw/virtio/virtio-pci.c|445| <<virtio_ioport_write(VIRTIO_PCI_QUEUE_PFN)>> virtio_pci_reset(DEVICE(proxy));
+     *   - hw/virtio/virtio-pci.c|477| <<virtio_ioport_write(VIRTIO_PCI_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+     *   - hw/virtio/virtio-pci.c|1691| <<virtio_pci_common_write(VIRTIO_PCI_COMMON_STATUS)>> virtio_pci_reset(DEVICE(proxy));
+     *   - hw/virtio/virtio-pci.c|2421| <<virtio_pci_bus_reset_hold>> virtio_pci_reset(qdev);
+     */
     virtio_pci_reset(qdev);
 
     if (pci_is_express(dev)) {
diff --git a/hw/xen/xen-hvm-common.c b/hw/xen/xen-hvm-common.c
index b40ae0b3a..93c5ebb1b 100644
--- a/hw/xen/xen-hvm-common.c
+++ b/hw/xen/xen-hvm-common.c
@@ -611,6 +611,14 @@ static void cpu_handle_ioreq(void *opaque)
             }
             request = qemu_reset_requested_get();
             if (request) {
+                /*
+		 * 在以下使用qemu_system_reset():
+                 *   - hw/core/machine.c|1825| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+                 *   - hw/xen/xen-hvm-common.c|614| <<cpu_handle_ioreq>> qemu_system_reset(request);
+                 *   - migration/savevm.c|3463| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+                 *   - system/runstate.c|982| <<main_loop_should_exit>> qemu_system_reset(request);
+                 *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+		 */
                 qemu_system_reset(request);
                 destroy_hvm_domain(true);
             }
diff --git a/include/accel/accel-cpu-ops.h b/include/accel/accel-cpu-ops.h
index 067476491..aa8bd6140 100644
--- a/include/accel/accel-cpu-ops.h
+++ b/include/accel/accel-cpu-ops.h
@@ -49,6 +49,16 @@ struct AccelOpsClass {
      * Request to synchronize QEMU vCPU registers to the hardware accelerator
      * (QEMU is the reference).
      */
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_reset():
+     *   - accel/hvf/hvf-accel-ops.c|379| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - accel/mshv/mshv-all.c|710| <<mshv_accel_ops_class_init>> ops->synchronize_post_reset = mshv_cpu_synchronize_post_reset;
+     *   - system/cpus.c|179| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - system/cpus.c|180| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|90| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|93| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     void (*synchronize_post_reset)(CPUState *cpu);
     void (*synchronize_post_init)(CPUState *cpu);
     /**
@@ -59,6 +69,16 @@ struct AccelOpsClass {
      * Request to synchronize QEMU vCPU registers from the hardware accelerator
      * (the hardware accelerator is the reference).
      */
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|113| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - accel/mshv/mshv-all.c|711| <<mshv_accel_ops_class_init>> ops->synchronize_state = mshv_cpu_synchronize;
+     *   - system/cpus.c|183| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|184| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     void (*synchronize_state)(CPUState *cpu);
     void (*synchronize_pre_loadvm)(CPUState *cpu);
 
diff --git a/include/hw/i386/x86.h b/include/hw/i386/x86.h
index 8755cad50..30ceb73de 100644
--- a/include/hw/i386/x86.h
+++ b/include/hw/i386/x86.h
@@ -85,6 +85,15 @@ struct X86MachineState {
      * Address space used by IOAPIC device. All IOAPIC interrupts
      * will be translated to MSI messages in the address space.
      */
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     AddressSpace *ioapic_as;
 
     /*
diff --git a/include/hw/virtio/virtio-balloon.h b/include/hw/virtio/virtio-balloon.h
index 0456c211c..9b0f016f9 100644
--- a/include/hw/virtio/virtio-balloon.h
+++ b/include/hw/virtio/virtio-balloon.h
@@ -44,20 +44,105 @@ enum virtio_balloon_free_page_hint_status {
 struct VirtIOBalloon {
     VirtIODevice parent_obj;
     VirtQueue *ivq, *dvq, *svq, *free_page_vq, *reporting_vq;
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_status:
+     *   - hw/virtio/virtio-balloon.c|945| <<global>> VMSTATE_UINT32(free_page_hint_status, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|613| <<get_free_page_hints>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED &&
+     *   - hw/virtio/virtio-balloon.c|615| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_START;
+     *   - hw/virtio/virtio-balloon.c|616| <<get_free_page_hints>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|621| <<get_free_page_hints>> dev->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|625| <<get_free_page_hints>> if (elem->in_num && dev->free_page_hint_status == FREE_PAGE_HINT_S_START) {
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_ballloon_get_free_page_hints>> dev->free_page_hint_status == FREE_PAGE_HINT_S_START);
+     *   - hw/virtio/virtio-balloon.c|680| <<virtio_balloon_free_page_start>> s->free_page_hint_status = FREE_PAGE_HINT_S_REQUESTED;
+     *   - hw/virtio/virtio-balloon.c|690| <<virtio_balloon_free_page_stop>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|701| <<virtio_balloon_free_page_stop>> s->free_page_hint_status = FREE_PAGE_HINT_S_STOP;
+     *   - hw/virtio/virtio-balloon.c|711| <<virtio_balloon_free_page_done>> if (s->free_page_hint_status != FREE_PAGE_HINT_S_DONE) {
+     *   - hw/virtio/virtio-balloon.c|714| <<virtio_balloon_free_page_done>> s->free_page_hint_status = FREE_PAGE_HINT_S_DONE;
+     *   - hw/virtio/virtio-balloon.c|804| <<virtio_balloon_get_config>> if (dev->free_page_hint_status == FREE_PAGE_HINT_S_REQUESTED) {
+     *   - hw/virtio/virtio-balloon.c|807| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_STOP) {
+     *   - hw/virtio/virtio-balloon.c|810| <<virtio_balloon_get_config>> } else if (dev->free_page_hint_status == FREE_PAGE_HINT_S_DONE) {
+     */
     uint32_t free_page_hint_status;
     uint32_t num_pages;
     uint32_t actual;
+    /*
+     * 在以下使用virtio_balloon_config->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|792| <<virtio_balloon_config_size>> return offsetof(struct virtio_balloon_config, free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|805| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|808| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     *   - hw/virtio/virtio-balloon.c|811| <<virtio_balloon_get_config>> config.free_page_hint_cmd_id =
+     * 在以下使用VirtIOBaloon->free_page_hint_cmd_id:
+     *   - hw/virtio/virtio-balloon.c|944| <<global>> VMSTATE_UINT32(free_page_hint_cmd_id, VirtIOBalloon),
+     *   - hw/virtio/virtio-balloon.c|614| <<get_free_page_hints>> id == dev->free_page_hint_cmd_id) {
+     *   - hw/virtio/virtio-balloon.c|674| <<virtio_balloon_free_page_start>> if (s->free_page_hint_cmd_id == UINT_MAX) {
+     *   - hw/virtio/virtio-balloon.c|675| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     *   - hw/virtio/virtio-balloon.c|677| <<virtio_balloon_free_page_start>> s->free_page_hint_cmd_id++;
+     *   - hw/virtio/virtio-balloon.c|806| <<virtio_balloon_get_config>> cpu_to_le32(dev->free_page_hint_cmd_id);
+     *   - hw/virtio/virtio-balloon.c|1141| <<virtio_balloon_instance_init>> s->free_page_hint_cmd_id = VIRTIO_BALLOON_FREE_PAGE_HINT_CMD_ID_MIN;
+     */
     uint32_t free_page_hint_cmd_id;
     uint64_t stats[VIRTIO_BALLOON_S_NR];
+    /*
+     * 在以下使用VirtIOBalloon->stats_vq_elem:
+     *   - hw/virtio/virtio-balloon.c|344| <<balloon_stats_poll_cb>> if (s->stats_vq_elem == NULL || !balloon_stats_supported(s)) {
+     *   - hw/virtio/virtio-balloon.c|362| <<balloon_stats_poll_cb>> virtqueue_push(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|364| <<balloon_stats_poll_cb>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|365| <<balloon_stats_poll_cb>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|695| <<virtio_balloon_receive_stats>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|697| <<virtio_balloon_receive_stats>> virtqueue_push(vq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|699| <<virtio_balloon_receive_stats>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|702| <<virtio_balloon_receive_stats>> s->stats_vq_elem = elem;
+     *   - hw/virtio/virtio-balloon.c|1582| <<virtio_balloon_device_reset>> if (s->stats_vq_elem != NULL) {
+     *   - hw/virtio/virtio-balloon.c|1583| <<virtio_balloon_device_reset>> virtqueue_unpop(s->svq, s->stats_vq_elem, 0);
+     *   - hw/virtio/virtio-balloon.c|1584| <<virtio_balloon_device_reset>> g_free(s->stats_vq_elem);
+     *   - hw/virtio/virtio-balloon.c|1585| <<virtio_balloon_device_reset>> s->stats_vq_elem = NULL;
+     *   - hw/virtio/virtio-balloon.c|1595| <<virtio_balloon_set_status>> if (!s->stats_vq_elem && vdev->vm_running &&
+     */
     VirtQueueElement *stats_vq_elem;
     size_t stats_vq_offset;
+    /*
+     * 在以下使用VirtIOBalloon->stats_timer:
+     *   - hw/virtio/virtio-balloon.c|292| <<balloon_stats_destroy_timer>> timer_free(s->stats_timer);
+     *   - hw/virtio/virtio-balloon.c|293| <<balloon_stats_destroy_timer>> s->stats_timer = NULL;
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_change_timer>> timer_mod(s->stats_timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) + secs * 1000);
+     *   - hw/virtio/virtio-balloon.c|471| <<balloon_stats_set_poll_interval>> g_assert(s->stats_timer == NULL);
+     *   - hw/virtio/virtio-balloon.c|472| <<balloon_stats_set_poll_interval>> s->stats_timer = timer_new_ms(QEMU_CLOCK_VIRTUAL, balloon_stats_poll_cb, s);
+     */
     QEMUTimer *stats_timer;
     IOThread *iothread;
+    /*
+     * 在以下使用VirtIOBalloon->free_page_bh:
+     *   - hw/virtio/virtio-balloon.c|582| <<virtio_balloon_handle_free_page_vq>> qemu_bh_schedule(s->free_page_bh);
+     *   - hw/virtio/virtio-balloon.c|1012| <<virtio_balloon_device_realize>> s->free_page_bh =
+     *                             aio_bh_new_guarded(iothread_get_aio_context(s->iothread),
+     *                             virtio_ballloon_get_free_page_hints, s, &dev->mem_reentrancy_guard);
+     *   - hw/virtio/virtio-balloon.c|1043| <<virtio_balloon_device_unrealize>> if (s->free_page_bh) {
+     *   - hw/virtio/virtio-balloon.c|1044| <<virtio_balloon_device_unrealize>> qemu_bh_delete(s->free_page_bh);
+     *
+     * 处理的函数: virtio_ballloon_get_free_page_hints()
+     */
     QEMUBH *free_page_bh;
     /*
      * Lock to synchronize threads to access the free page reporting related
      * fields (e.g. free_page_hint_status).
      */
+    /*
+     * 在以下使用VirtIOBalloon->free_page_lock:
+     *   - hw/virtio/virtio-balloon.c|535| <<get_free_page_hints>> qemu_cond_wait(&dev->free_page_cond, &dev->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|587| <<virtio_ballloon_get_free_page_hints>> qemu_mutex_lock(&dev->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|590| <<virtio_ballloon_get_free_page_hints>> qemu_mutex_unlock(&dev->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|613| <<virtio_balloon_free_page_start>> qemu_mutex_lock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|622| <<virtio_balloon_free_page_start>> qemu_mutex_unlock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|637| <<virtio_balloon_free_page_stop>> qemu_mutex_lock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|643| <<virtio_balloon_free_page_stop>> qemu_mutex_unlock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|654| <<virtio_balloon_free_page_done>> qemu_mutex_lock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|656| <<virtio_balloon_free_page_done>> qemu_mutex_unlock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|1029| <<virtio_balloon_set_status>> qemu_mutex_lock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|1032| <<virtio_balloon_set_status>> qemu_mutex_unlock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|1037| <<virtio_balloon_set_status>> qemu_mutex_lock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|1039| <<virtio_balloon_set_status>> qemu_mutex_unlock(&s->free_page_lock);
+     *   - hw/virtio/virtio-balloon.c|1070| <<virtio_balloon_instance_init>> qemu_mutex_init(&s->free_page_lock);
+     */
     QemuMutex free_page_lock;
     QemuCond  free_page_cond;
     /*
@@ -65,8 +150,34 @@ struct VirtIOBalloon {
      * stopped.
      */
     bool block_iothread;
+    /*
+     * 在以下使用VirtIOBalloon->free_page_hint_notify:
+     *   - hw/virtio/virtio-balloon.c|961| <<virtio_balloon_free_page_hint_notify>> VirtIOBalloon *dev = container_of(n, VirtIOBalloon, free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1307| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1367| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+     *   - hw/virtio/virtio-balloon.c|1491| <<virtio_balloon_instance_init>> s->free_page_hint_notify.notify = virtio_balloon_free_page_hint_notify;
+     */
     NotifierWithReturn free_page_hint_notify;
+    /*
+     * 在以下使用VirtIOBalloon->stats_last_update:
+     *   - hw/virtio/virtio-balloon.c|312| <<balloon_stats_get_all>> if (!visit_type_int(v, "last-update", &s->stats_last_update, errp)) {
+     *   - hw/virtio/virtio-balloon.c|608| <<virtio_balloon_receive_stats>> s->stats_last_update = g_get_real_time() / G_USEC_PER_SEC;
+     *   - hw/virtio/virtio-balloon.c|1332| <<virtio_balloon_device_realize>> s->stats_last_update = 0;
+     *   - hw/virtio/virtio-balloon.c|1466| <<virtio_balloon_reset_enter>> s->stats_last_update = 0;
+     */
     int64_t stats_last_update;
+    /*
+     * 在以下使用VirtIOBalloon->stats_poll_interval:
+     *   - hw/virtio/virtio-balloon.c|274| <<balloon_stats_enabled>> return s->stats_poll_interval > 0;
+     *   - hw/virtio/virtio-balloon.c|282| <<balloon_stats_destroy_timer>> s->stats_poll_interval = 0;
+     *   - hw/virtio/virtio-balloon.c|298| <<balloon_stats_poll_cb>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|360| <<balloon_stats_get_poll_interval>> visit_type_int(v, name, &s->stats_poll_interval, errp);
+     *   - hw/virtio/virtio-balloon.c|393| <<balloon_stats_set_poll_interval>> if (value == s->stats_poll_interval) {
+     *   - hw/virtio/virtio-balloon.c|405| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|413| <<balloon_stats_set_poll_interval>> s->stats_poll_interval = value;
+     *   - hw/virtio/virtio-balloon.c|639| <<virtio_balloon_receive_stats>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     *   - hw/virtio/virtio-balloon.c|1264| <<virtio_balloon_post_load_device>> balloon_stats_change_timer(s, s->stats_poll_interval);
+     */
     int64_t stats_poll_interval;
     uint32_t host_features;
 
diff --git a/include/migration/register.h b/include/migration/register.h
index ae79794cd..cee0354f4 100644
--- a/include/migration/register.h
+++ b/include/migration/register.h
@@ -177,6 +177,16 @@ typedef struct SaveVMHandlers {
      *         1 that there is no more data to send and
      *         negative to indicate an error.
      */
+    /*
+     * 在以下使用SaveVMHandlers->save_live_iterate:
+     *   - hw/ppc/spapr.c|2572| <<global>> .save_live_iterate = htab_save_iterate,
+     *   - hw/s390x/s390-stattrib.c|340| <<global>> .save_live_iterate = cmma_save_iterate,
+     *   - hw/vfio/migration.c|834| <<global>> .save_live_iterate = vfio_save_iterate,
+     *   - migration/block-dirty-bitmap.c|1255| <<global>> .save_live_iterate = dirty_bitmap_save_iterate,
+     *   - migration/ram.c|4695| <<global>> .save_live_iterate = ram_save_iterate,
+     *   - migration/savevm.c|1448| <<qemu_savevm_state_iterate>> if (!se->ops || !se->ops->save_live_iterate) {
+     *   - migration/savevm.c|1476| <<qemu_savevm_state_iterate>> ret = se->ops->save_live_iterate(f, se->opaque);
+     */
     int (*save_live_iterate)(QEMUFile *f, void *opaque);
 
     /* This runs outside the BQL!  */
diff --git a/migration/block-dirty-bitmap.c b/migration/block-dirty-bitmap.c
index a061aad81..283d1dcac 100644
--- a/migration/block-dirty-bitmap.c
+++ b/migration/block-dirty-bitmap.c
@@ -727,6 +727,16 @@ static void dirty_bitmap_save_cleanup(void *opaque)
     dirty_bitmap_do_save_cleanup(s);
 }
 
+/*
+ * 在以下使用SaveVMHandlers->save_live_iterate:
+ *   - hw/ppc/spapr.c|2572| <<global>> .save_live_iterate = htab_save_iterate,
+ *   - hw/s390x/s390-stattrib.c|340| <<global>> .save_live_iterate = cmma_save_iterate,
+ *   - hw/vfio/migration.c|834| <<global>> .save_live_iterate = vfio_save_iterate,
+ *   - migration/block-dirty-bitmap.c|1255| <<global>> .save_live_iterate = dirty_bitmap_save_iterate,
+ *   - migration/ram.c|4695| <<global>> .save_live_iterate = ram_save_iterate,
+ *   - migration/savevm.c|1448| <<qemu_savevm_state_iterate>> if (!se->ops || !se->ops->save_live_iterate) {
+ *   - migration/savevm.c|1476| <<qemu_savevm_state_iterate>> ret = se->ops->save_live_iterate(f, se->opaque);
+ */
 static int dirty_bitmap_save_iterate(QEMUFile *f, void *opaque)
 {
     DBMSaveState *s = &((DBMState *)opaque)->save;
diff --git a/migration/migration.c b/migration/migration.c
index b316ee01a..db4edb3e4 100644
--- a/migration/migration.c
+++ b/migration/migration.c
@@ -283,6 +283,56 @@ static gint page_request_addr_cmp(gconstpointer ap, gconstpointer bp)
     return (a > b) - (a < b);
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 static int migration_stop_vm(MigrationState *s, RunState state)
 {
     int ret;
@@ -500,6 +550,10 @@ void migration_incoming_state_destroy(void)
     yank_unregister_instance(MIGRATION_YANK_INSTANCE);
 }
 
+/*
+ * 在以下使用migrate_generate_event():
+ *   - migration/migration.c|1557| <<migrate_set_state>> migrate_generate_event(new_state);
+ */
 static void migrate_generate_event(MigrationStatus new_state)
 {
     if (migrate_events()) {
@@ -847,12 +901,44 @@ static void process_incoming_migration_bh(void *opaque)
                 vm_start();
             }
         } else {
+            /*
+	     * 在以下使用runstate_set():
+             *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+             *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+             *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+             *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+             *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+             *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+             *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+             *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+             *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+             *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+             *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+             *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+             *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	     */
             runstate_set(RUN_STATE_PAUSED);
         }
     } else if (migration_incoming_colo_enabled()) {
         migration_incoming_disable_colo();
         vm_start();
     } else {
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         runstate_set(global_state_get_runstate());
     }
     trace_vmstate_downtime_checkpoint("dst-precopy-bh-vm-started");
@@ -3006,6 +3092,56 @@ static bool migration_switchover_start(MigrationState *s, Error **errp)
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x5555578f8060) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c0887a in cpu_synchronize_state (cpu=0x5555578f8060) at ../system/cpus.c:173
+ * #2  0x0000555555c08659 in cpu_synchronize_all_states () at ../system/cpus.c:139
+ * #3  0x0000555555c7b684 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555578d2800, in_postcopy=false) at ../migration/savevm.c:1659
+ * #4  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555578d2800, iterable_only=false) at ../migration/savevm.c:1712
+ * #5  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #6  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #7  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #8  0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #9  0x0000555556155700 in qemu_thread_start (args=0x5555582b6740) at ../util/qemu-thread-posix.c:393
+ * #10 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #11 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e023a6 in kvmclock_vm_state_change (opaque=0x5555577ff000, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/i386/kvm/clock.c:211
+ * #2  0x0000555555c37f11 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:392
+ * #3  0x0000555555c08bab in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:300
+ * #4  0x0000555555c09c5a in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:737
+ * #5  0x0000555555c09dcc in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:804
+ * #6  0x0000555555c5ea6f in migration_stop_vm (s=0x5555575e27f0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:299
+ * #7  0x0000555555c64db5 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2981
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555577ff000) at ../hw/i386/kvm/clock.c:101
+ * #1  0x0000555555e024db in kvmclock_pre_save (opaque=0x5555577ff000) at ../hw/i386/kvm/clock.c:285
+ * #2  0x0000555555f40775 in vmstate_save_state_v (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000, vmdesc=0x5555579c0f70,
+ *     version_id=1, errp=0x7ffe358d84b8) at ../migration/vmstate.c:407
+ * #3  0x0000555555f406d2 in vmstate_save_state_with_err (f=0x5555579b4c00, vmsd=0x555557375d80 <kvmclock_vmsd>, opaque=0x5555577ff000,
+ *     vmdesc_id=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/vmstate.c:395
+ * #4  0x0000555555c79ef9 in vmstate_save (f=0x5555579b4c00, se=0x555557916b30, vmdesc=0x5555579c0f70, errp=0x7ffe358d84b8) at ../migration/savevm.c:1052
+ * #5  0x0000555555c7b6e1 in qemu_savevm_state_complete_precopy_non_iterable (f=0x5555579b4c00, in_postcopy=false) at ../migration/savevm.c:1669
+ * #6  0x0000555555c7b8a2 in qemu_savevm_state_complete_precopy (f=0x5555579b4c00, iterable_only=false) at ../migration/savevm.c:1712
+ * #7  0x0000555555c64df7 in migration_completion_precopy (s=0x5555575e27f0) at ../migration/migration.c:2992
+ * #8  0x0000555555c64ebf in migration_completion (s=0x5555575e27f0) at ../migration/migration.c:3029
+ * #9  0x0000555555c65dc2 in migration_iteration_run (s=0x5555575e27f0) at ../migration/migration.c:3494
+ * #10 0x0000555555c664bf in migration_thread (opaque=0x5555575e27f0) at ../migration/migration.c:3767
+ * #11 0x0000555556155700 in qemu_thread_start (args=0x55555790b800) at ../util/qemu-thread-posix.c:393
+ * #12 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #13 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 static int migration_completion_precopy(MigrationState *s)
 {
     int ret;
@@ -3565,6 +3701,22 @@ static void migration_iteration_finish(MigrationState *s)
 
     switch (s->state) {
     case MIGRATION_STATUS_COMPLETED:
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         runstate_set(RUN_STATE_POSTMIGRATE);
         break;
     case MIGRATION_STATUS_COLO:
@@ -3603,6 +3755,22 @@ static void migration_iteration_finish(MigrationState *s)
             }
         } else {
             if (runstate_check(RUN_STATE_FINISH_MIGRATE)) {
+                /*
+		 * 在以下使用runstate_set():
+                 *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+		 *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+		 *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+		 *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+		 *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+                 *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+                 *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+                 *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+                 *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+                 *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+                 *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+                 *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+                 *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+		 */
                 runstate_set(s->vm_old_state);
             }
         }
diff --git a/migration/ram.c b/migration/ram.c
index 29f016cb2..71f37d19c 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -448,21 +448,41 @@ static bool postcopy_has_request(RAMState *rs)
     return !QSIMPLEQ_EMPTY_ATOMIC(&rs->src_page_requests);
 }
 
+/*
+ * 在以下使用precopy_infrastructure_init():
+ *   - system/runstate.c|1116| <<qemu_init_subsystems>> precopy_infrastructure_init();
+ */
 void precopy_infrastructure_init(void)
 {
     notifier_with_return_list_init(&precopy_notifier_list);
 }
 
+/*
+ * 在以下使用precopy_add_notifier():
+ *   - hw/virtio/virtio-balloon.c|1226| <<virtio_balloon_device_realize>> precopy_add_notifier(&s->free_page_hint_notify);
+ */
 void precopy_add_notifier(NotifierWithReturn *n)
 {
     notifier_with_return_list_add(&precopy_notifier_list, n);
 }
 
+/*
+ * 在以下使用precopy_remove_notifier():
+ *   - hw/virtio/virtio-balloon.c|1286| <<virtio_balloon_device_unrealize>> precopy_remove_notifier(&s->free_page_hint_notify);
+ */
 void precopy_remove_notifier(NotifierWithReturn *n)
 {
     notifier_with_return_remove(n);
 }
 
+/*
+ * 在以下使用precopy_notify():
+ *   - migration/migration.c|157| <<precopy_notify_complete>> if (precopy_notify(PRECOPY_NOTIFY_COMPLETE, &local_err)) {
+ *   - migration/ram.c|1200| <<migration_bitmap_sync_precopy>> if (precopy_notify(PRECOPY_NOTIFY_BEFORE_BITMAP_SYNC, &local_err)) {
+ *   - migration/ram.c|1207| <<migration_bitmap_sync_precopy>> if (precopy_notify(PRECOPY_NOTIFY_AFTER_BITMAP_SYNC, &local_err)) {
+ *   - migration/savevm.c|1406| <<qemu_savevm_state_setup>> return precopy_notify(PRECOPY_NOTIFY_SETUP, errp);
+ *   - migration/savevm.c|1795| <<qemu_savevm_state_cleanup>> if (precopy_notify(PRECOPY_NOTIFY_CLEANUP, &local_err)) {
+ */
 int precopy_notify(PrecopyNotifyReason reason, Error **errp)
 {
     PrecopyNotifyData pnd;
@@ -2744,6 +2764,24 @@ int ram_discard_range(const char *rbname, uint64_t start, size_t length)
                      length >> qemu_target_page_bits());
     }
 
+    /*
+     * 在以下使用ram_block_discard_range():
+     *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+     *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+     *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+     *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+     *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+     *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+     *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+     *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+     *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+     *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+     *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+     *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+     *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+     *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+     *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+     */
     return ram_block_discard_range(rb, start, length);
 }
 
@@ -2965,6 +3003,10 @@ static void ram_state_resume_prepare(RAMState *rs, QEMUFile *out)
  * start of the continuous guest free pages, and @len is the total bytes of
  * those pages.
  */
+/*
+ * 在以下使用qemu_guest_free_page_hint():
+ *   - hw/virtio/virtio-balloon.c|686| <<get_free_page_hints>> qemu_guest_free_page_hint(elem->in_sg[i].iov_base,
+ */
 void qemu_guest_free_page_hint(void *addr, size_t len)
 {
     RAMBlock *block;
@@ -3251,6 +3293,16 @@ void ramblock_set_file_bmap_atomic(RAMBlock *block, ram_addr_t offset, bool set)
  * @f: QEMUFile where to send the data
  * @opaque: RAMState pointer
  */
+/*
+ * 在以下使用SaveVMHandlers->save_live_iterate:
+ *   - hw/ppc/spapr.c|2572| <<global>> .save_live_iterate = htab_save_iterate,
+ *   - hw/s390x/s390-stattrib.c|340| <<global>> .save_live_iterate = cmma_save_iterate,
+ *   - hw/vfio/migration.c|834| <<global>> .save_live_iterate = vfio_save_iterate,
+ *   - migration/block-dirty-bitmap.c|1255| <<global>> .save_live_iterate = dirty_bitmap_save_iterate,
+ *   - migration/ram.c|4695| <<global>> .save_live_iterate = ram_save_iterate,
+ *   - migration/savevm.c|1448| <<qemu_savevm_state_iterate>> if (!se->ops || !se->ops->save_live_iterate) {
+ *   - migration/savevm.c|1476| <<qemu_savevm_state_iterate>> ret = se->ops->save_live_iterate(f, se->opaque);
+ */
 static int ram_save_iterate(QEMUFile *f, void *opaque)
 {
     RAMState **temp = opaque;
diff --git a/migration/savevm.c b/migration/savevm.c
index 62cc2ce25..e288c8337 100644
--- a/migration/savevm.c
+++ b/migration/savevm.c
@@ -1473,6 +1473,16 @@ int qemu_savevm_state_iterate(QEMUFile *f, bool postcopy)
 
         save_section_header(f, se, QEMU_VM_SECTION_PART);
 
+        /*
+	 * 在以下使用SaveVMHandlers->save_live_iterate:
+	 *   - hw/ppc/spapr.c|2572| <<global>> .save_live_iterate = htab_save_iterate,
+         *   - hw/s390x/s390-stattrib.c|340| <<global>> .save_live_iterate = cmma_save_iterate,
+         *   - hw/vfio/migration.c|834| <<global>> .save_live_iterate = vfio_save_iterate,
+         *   - migration/block-dirty-bitmap.c|1255| <<global>> .save_live_iterate = dirty_bitmap_save_iterate,
+         *   - migration/ram.c|4695| <<global>> .save_live_iterate = ram_save_iterate,
+         *   - migration/savevm.c|1448| <<qemu_savevm_state_iterate>> if (!se->ops || !se->ops->save_live_iterate) {
+         *   - migration/savevm.c|1476| <<qemu_savevm_state_iterate>> ret = se->ops->save_live_iterate(f, se->opaque);
+	 */
         ret = se->ops->save_live_iterate(f, se->opaque);
         trace_savevm_section_end(se->idstr, se->section_id, ret);
         save_section_footer(f, se);
@@ -2152,6 +2162,22 @@ static void loadvm_postcopy_handle_run_bh(void *opaque)
             vm_start();
         }
     } else {
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         /* leave it paused and let management decide when to start the CPU */
         runstate_set(RUN_STATE_PAUSED);
     }
@@ -3444,6 +3470,14 @@ bool load_snapshot(const char *name, const char *vmstate,
         goto err_drain;
     }
 
+    /*
+     * 在以下使用qemu_system_reset():
+     *   - hw/core/machine.c|1825| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+     *   - hw/xen/xen-hvm-common.c|614| <<cpu_handle_ioreq>> qemu_system_reset(request);
+     *   - migration/savevm.c|3463| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+     *   - system/runstate.c|982| <<main_loop_should_exit>> qemu_system_reset(request);
+     *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+     */
     qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
     mis->from_src_file = f;
 
diff --git a/system/balloon.c b/system/balloon.c
index 311fa5058..2b1e102b8 100644
--- a/system/balloon.c
+++ b/system/balloon.c
@@ -33,6 +33,15 @@
 #include "qapi/qmp/qerror.h"
 #include "trace.h"
 
+/*
+ * 在以下使用balloon_event_fn:
+ *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+ *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+ *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+ *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+ *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+ *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+ */
 static QEMUBalloonEvent *balloon_event_fn;
 static QEMUBalloonStatus *balloon_stat_fn;
 static void *balloon_opaque;
@@ -44,6 +53,15 @@ static bool have_balloon(Error **errp)
                   "Using KVM without synchronous MMU, balloon unavailable");
         return false;
     }
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     if (!balloon_event_fn) {
         error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,
                   "No balloon device has been activated");
@@ -52,6 +70,13 @@ static bool have_balloon(Error **errp)
     return true;
 }
 
+/*
+ * 在以下使用qemu_add_balloon_handler():
+ *   - hw/hyperv/hv-balloon.c|1504| <<hv_balloon_vmdev_realize>>
+ *         ret = qemu_add_balloon_handler(hv_balloon_to_target, hv_balloon_stat, balloon);
+ *   - hw/virtio/virtio-balloon.c|1317| <<virtio_balloon_device_realize>>
+ *         ret = qemu_add_balloon_handler(virtio_balloon_to_target, virtio_balloon_stat, s);
+ */
 int qemu_add_balloon_handler(QEMUBalloonEvent *event_func,
                              QEMUBalloonStatus *stat_func, void *opaque)
 {
@@ -61,6 +86,15 @@ int qemu_add_balloon_handler(QEMUBalloonEvent *event_func,
          */
         return -1;
     }
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     balloon_event_fn = event_func;
     balloon_stat_fn = stat_func;
     balloon_opaque = opaque;
@@ -72,6 +106,15 @@ void qemu_remove_balloon_handler(void *opaque)
     if (balloon_opaque != opaque) {
         return;
     }
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     balloon_event_fn = NULL;
     balloon_stat_fn = NULL;
     balloon_opaque = NULL;
@@ -102,5 +145,14 @@ void qmp_balloon(int64_t value, Error **errp)
     }
 
     trace_balloon_event(balloon_opaque, value);
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     balloon_event_fn(balloon_opaque, value);
 }
diff --git a/system/cpus.c b/system/cpus.c
index ef2d2f241..77213be96 100644
--- a/system/cpus.c
+++ b/system/cpus.c
@@ -140,11 +140,22 @@ void cpu_synchronize_all_states(void)
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_post_reset():
+ *   - hw/i386/pc.c|1735| <<pc_machine_wakeup>> cpu_synchronize_all_post_reset();
+ *   - system/runstate.c|621| <<qemu_system_reset>> cpu_synchronize_all_post_reset();
+ */
 void cpu_synchronize_all_post_reset(void)
 {
     CPUState *cpu;
 
     CPU_FOREACH(cpu) {
+        /*
+	 * 在以下使用cpu_synchronize_post_reset():
+         *   - system/cpus.c|148| <<cpu_synchronize_all_post_reset>> cpu_synchronize_post_reset(cpu);
+         *   - target/s390x/sigp.c|375| <<sigp_initial_cpu_reset>> cpu_synchronize_post_reset(cs);
+         *   - target/s390x/sigp.c|385| <<sigp_cpu_reset>> cpu_synchronize_post_reset(cs);
+	 */
         cpu_synchronize_post_reset(cpu);
     }
 }
@@ -169,13 +180,39 @@ void cpu_synchronize_all_pre_loadvm(void)
 
 void cpu_synchronize_state(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state():
+     *   - accel/hvf/hvf-accel-ops.c|381| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|113| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - accel/mshv/mshv-all.c|711| <<mshv_accel_ops_class_init>> ops->synchronize_state = mshv_cpu_synchronize;
+     *   - system/cpus.c|183| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|184| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     if (cpus_accel->synchronize_state) {
         cpus_accel->synchronize_state(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_post_reset():
+ *   - system/cpus.c|148| <<cpu_synchronize_all_post_reset>> cpu_synchronize_post_reset(cpu);
+ *   - target/s390x/sigp.c|375| <<sigp_initial_cpu_reset>> cpu_synchronize_post_reset(cs);
+ *   - target/s390x/sigp.c|385| <<sigp_cpu_reset>> cpu_synchronize_post_reset(cs);
+ */
 void cpu_synchronize_post_reset(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_reset():
+     *   - accel/hvf/hvf-accel-ops.c|379| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|101| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - accel/mshv/mshv-all.c|710| <<mshv_accel_ops_class_init>> ops->synchronize_post_reset = mshv_cpu_synchronize_post_reset;
+     *   - system/cpus.c|179| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - system/cpus.c|180| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|90| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|93| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     if (cpus_accel->synchronize_post_reset) {
         cpus_accel->synchronize_post_reset(cpu);
     }
@@ -298,6 +335,22 @@ static int do_vm_stop(RunState state, bool send_stop)
 
     if (runstate_is_live(oldstate)) {
         vm_was_suspended = (oldstate == RUN_STATE_SUSPENDED);
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         runstate_set(state);
         cpu_disable_ticks();
         if (oldstate == RUN_STATE_RUNNING) {
@@ -731,6 +784,13 @@ void qemu_init_vcpu(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用cpu_stop_current():
+ *   - hw/ppc/spapr_rtas.c|79| <<rtas_power_off>> cpu_stop_current();
+ *   - system/cpus.c|804| <<vm_stop>> cpu_stop_current();
+ *   - system/runstate.c|791| <<qemu_system_reset_request>> cpu_stop_current();
+ *   - system/runstate.c|825| <<qemu_system_suspend_request>> cpu_stop_current();
+ */
 void cpu_stop_current(void)
 {
     if (current_cpu) {
@@ -748,6 +808,13 @@ int vm_stop(RunState state)
          * FIXME: should not return to device code in case
          * vm_stop() has been requested.
          */
+        /*
+	 * 在以下使用cpu_stop_current():
+         *   - hw/ppc/spapr_rtas.c|79| <<rtas_power_off>> cpu_stop_current();
+         *   - system/cpus.c|804| <<vm_stop>> cpu_stop_current();
+         *   - system/runstate.c|791| <<qemu_system_reset_request>> cpu_stop_current();
+         *   - system/runstate.c|825| <<qemu_system_suspend_request>> cpu_stop_current();
+	 */
         cpu_stop_current();
         return 0;
     }
@@ -760,6 +827,11 @@ int vm_stop(RunState state)
  * Returns 0 if the vCPUs should be restarted, -1 on an error condition,
  * and 1 otherwise.
  */
+/*
+ * 在以下使用vm_prepare_start():
+ *   - gdbstub/system.c|573| <<gdb_continue_partial>> if (vm_prepare_start(step_requested)) {
+ *   - system/cpus.c|886| <<vm_start>> if (!vm_prepare_start(false)) {
+ */
 int vm_prepare_start(bool step_pending)
 {
     int ret = vm_was_suspended ? 1 : 0;
@@ -792,6 +864,22 @@ int vm_prepare_start(bool step_pending)
     qapi_event_send_resume();
 
     cpu_enable_ticks();
+    /*
+     * 在以下使用runstate_set():
+     *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+     *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+     *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+     *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+     *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+     *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+     *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+     *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+     *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+     *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+     *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+     */
     runstate_set(state);
     vm_state_notify(1, state);
     vm_was_suspended = false;
@@ -810,6 +898,22 @@ void vm_resume(RunState state)
     if (runstate_is_live(state)) {
         vm_start();
     } else {
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         runstate_set(state);
     }
 }
@@ -822,6 +926,22 @@ int vm_stop_force_state(RunState state)
         return vm_stop(state);
     } else {
         int ret;
+        /*
+	 * 在以下使用runstate_set():
+         *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+         *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+         *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+         *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+         *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+         *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+         *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+         *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+         *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+         *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+         *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+         *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	 */
         runstate_set(state);
 
         bdrv_drain_all();
diff --git a/system/main.c b/system/main.c
index b8f7157cc..a435c394b 100644
--- a/system/main.c
+++ b/system/main.c
@@ -41,6 +41,11 @@
 #include <CoreFoundation/CoreFoundation.h>
 #endif
 
+/*
+ * 在以下使用qemu_default_main():
+ *   - system/main.c|90| <<main>> qemu_default_main, NULL, QEMU_THREAD_DETACHED);
+ *   - system/main.c|93| <<main>> qemu_default_main(NULL);
+ */
 static void *qemu_default_main(void *opaque)
 {
     int status;
@@ -55,6 +60,15 @@ static void *qemu_default_main(void *opaque)
     exit(status);
 }
 
+/*
+ * 在以下使用qemu_main函数指针:
+ *   - system/main.c|58| <<global>> int (*qemu_main)(void );
+ *   - system/main.c|66| <<global>> int (*qemu_main)(void ) = os_darwin_cfrunloop_main;
+ *   - system/main.c|87| <<main>> if (qemu_main) {
+ *   - system/main.c|91| <<main>> return qemu_main();
+ *   - ui/gtk.c|2611| <<gtk_display_init>> qemu_main = NULL;
+ *   - ui/sdl2.c|955| <<sdl2_display_init>> qemu_main = NULL;
+ */
 int (*qemu_main)(void);
 
 #ifdef CONFIG_DARWIN
@@ -84,6 +98,15 @@ int main(int argc, char **argv)
     bql_unlock();
     replay_mutex_unlock();
 
+    /*
+     * 在以下使用qemu_main函数指针:
+     *   - system/main.c|58| <<global>> int (*qemu_main)(void );
+     *   - system/main.c|66| <<global>> int (*qemu_main)(void ) = os_darwin_cfrunloop_main;
+     *   - system/main.c|87| <<main>> if (qemu_main) {
+     *   - system/main.c|91| <<main>> return qemu_main();
+     *   - ui/gtk.c|2611| <<gtk_display_init>> qemu_main = NULL;
+     *   - ui/sdl2.c|955| <<sdl2_display_init>> qemu_main = NULL;
+     */
     if (qemu_main) {
         QemuThread main_loop_thread;
         qemu_thread_create(&main_loop_thread, "qemu_main",
diff --git a/system/memory.c b/system/memory.c
index 8b84661ae..90ebf2567 100644
--- a/system/memory.c
+++ b/system/memory.c
@@ -2835,6 +2835,11 @@ bool memory_region_is_mapped(MemoryRegion *mr)
 /* Same as memory_region_find, but it does not add a reference to the
  * returned region.  It must be called from an RCU critical section.
  */
+/*
+ * 在以下使用memory_region_find_rcu():
+ *   - system/memory.c|2888| <<memory_region_find>> ret = memory_region_find_rcu(mr, addr, size);
+ *   - system/memory.c|2927| <<memory_region_present>> mr = memory_region_find_rcu(container, addr, 1).mr;
+ */
 static MemoryRegionSection memory_region_find_rcu(MemoryRegion *mr,
                                                   hwaddr addr, uint64_t size)
 {
diff --git a/system/physmem.c b/system/physmem.c
index c9869e404..67a9cccba 100644
--- a/system/physmem.c
+++ b/system/physmem.c
@@ -2686,6 +2686,24 @@ void qemu_ram_remap(ram_addr_t addr)
             } else if (xen_enabled()) {
                 abort();
             } else {
+                /*
+		 * 在以下使用ram_block_discard_range():
+                 *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+                 *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+                 *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+                 *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+                 *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+                 *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+                 *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+                 *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+                 *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+                 *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+                 *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+                 *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+                 *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+                 *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+                 *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+		 */
                 if (ram_block_discard_range(block, offset, page_size) != 0) {
                     /*
                      * Fall back to using mmap() only for anonymous mapping,
@@ -4091,6 +4109,24 @@ int qemu_ram_foreach_block(RAMBlockIterFunc func, void *opaque)
  * Returns: 0 on success, none-0 on failure
  *
  */
+/*
+ * 在以下使用ram_block_discard_range():
+ *   - accel/kvm/kvm-all.c|3190| <<kvm_convert_memory>> ret = ram_block_discard_range(rb, offset, size);
+ *   - hw/hyperv/hv-balloon-our_range_memslots.c|154| <<hvb_our_range_memslots_free>> ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+ *   - hw/hyperv/hv-balloon.c|863| <<hv_balloon_handle_remove_host_addr_node>> if (ram_block_discard_range(rb, rb_offset, discard_size *
+ *   - hw/virtio/virtio-balloon.c|105| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_offset, rb_page_size);
+ *   - hw/virtio/virtio-balloon.c|144| <<balloon_inflate_page>> ram_block_discard_range(rb, rb_aligned_offset, rb_page_size);
+ *   - hw/virtio/virtio-balloon.c|405| <<virtio_balloon_handle_report>> ram_block_discard_range(rb, ram_offset, size);
+ *   - hw/virtio/virtio-mem.c|592| <<virtio_mem_set_block_state>> if (ram_block_discard_range(rb, offset, size)) {
+ *   - hw/virtio/virtio-mem.c|646| <<virtio_mem_set_block_state>> ram_block_discard_range(vmem->memdev->mr.ram_block, offset, size);
+ *   - hw/virtio/virtio-mem.c|742| <<virtio_mem_unplug_all>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+ *   - hw/virtio/virtio-mem.c|1086| <<virtio_mem_device_realize>> ret = ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb));
+ *   - hw/virtio/virtio-mem.c|1183| <<virtio_mem_discard_range_cb>> return ram_block_discard_range(rb, offset, size) ? -EINVAL : 0;
+ *   - hw/virtio/virtio-mem.c|1321| <<virtio_mem_post_load_early>> if (ram_block_discard_range(rb, 0, qemu_ram_get_used_length(rb))) {
+ *   - migration/ram.c|2747| <<ram_discard_range>> return ram_block_discard_range(rb, start, length);
+ *   - system/physmem.c|2689| <<qemu_ram_remap>> if (ram_block_discard_range(block, offset, page_size) != 0) {
+ *   - target/i386/kvm/tdx.c|379| <<tdx_finalize_vm>> ram_block_discard_range(ram_block, 0, ram_block->max_length);
+ */
 int ram_block_discard_range(RAMBlock *rb, uint64_t offset, size_t length)
 {
     int ret = -1;
diff --git a/system/runstate.c b/system/runstate.c
index e3ec16ab7..82c46520b 100644
--- a/system/runstate.c
+++ b/system/runstate.c
@@ -64,6 +64,18 @@
 static NotifierList exit_notifiers =
     NOTIFIER_LIST_INITIALIZER(exit_notifiers);
 
+/*
+ * 在以下使用current_run_state:
+ *   - system/runstate.c|67| <<global>> static RunState current_run_state = RUN_STATE_PRELAUNCH;
+ *   - system/runstate.c|193| <<runstate_check>> return current_run_state == state;
+ *   - system/runstate.c|232| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+ *   - system/runstate.c|235| <<runstate_set>> if (current_run_state == new_state) {
+ *   - system/runstate.c|239| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+ *   - system/runstate.c|241| <<runstate_set>> RunState_str(current_run_state),
+ *   - system/runstate.c|246| <<runstate_set>> current_run_state = new_state;
+ *   - system/runstate.c|251| <<runstate_get>> return current_run_state;
+ *   - system/runstate.c|270| <<qmp_query_status>> info->status = current_run_state;
+ */
 static RunState current_run_state = RUN_STATE_PRELAUNCH;
 
 /* We use RUN_STATE__MAX but any invalid value will do */
@@ -190,6 +202,18 @@ static bool runstate_valid_transitions[RUN_STATE__MAX][RUN_STATE__MAX];
 
 bool runstate_check(RunState state)
 {
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|67| <<global>> static RunState current_run_state = RUN_STATE_PRELAUNCH;
+     *   - system/runstate.c|193| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|232| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|235| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|239| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|241| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|246| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|251| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|270| <<qmp_query_status>> info->status = current_run_state;
+     */
     return current_run_state == state;
 }
 
@@ -224,11 +248,39 @@ static void runstate_init(void)
     qemu_mutex_init(&vmstop_lock);
 }
 
+/*
+ * 在以下使用runstate_set():
+ *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+ *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+ *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+ *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+ *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+ *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+ *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+ *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+ *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+ *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+ *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+ *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+ *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+ */
 /* This function will abort() on invalid state transitions */
 void runstate_set(RunState new_state)
 {
     assert(new_state < RUN_STATE__MAX);
 
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|67| <<global>> static RunState current_run_state = RUN_STATE_PRELAUNCH;
+     *   - system/runstate.c|193| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|232| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|235| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|239| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|241| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|246| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|251| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|270| <<qmp_query_status>> info->status = current_run_state;
+     */
     trace_runstate_set(current_run_state, RunState_str(current_run_state),
                        new_state, RunState_str(new_state));
 
@@ -248,6 +300,18 @@ void runstate_set(RunState new_state)
 
 RunState runstate_get(void)
 {
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|67| <<global>> static RunState current_run_state = RUN_STATE_PRELAUNCH;
+     *   - system/runstate.c|193| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|232| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|235| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|239| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|241| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|246| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|251| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|270| <<qmp_query_status>> info->status = current_run_state;
+     */
     return current_run_state;
 }
 
@@ -267,6 +331,18 @@ StatusInfo *qmp_query_status(Error **errp)
     StatusInfo *info = g_malloc0(sizeof(*info));
 
     info->running = runstate_is_running();
+    /*
+     * 在以下使用current_run_state:
+     *   - system/runstate.c|67| <<global>> static RunState current_run_state = RUN_STATE_PRELAUNCH;
+     *   - system/runstate.c|193| <<runstate_check>> return current_run_state == state;
+     *   - system/runstate.c|232| <<runstate_set>> trace_runstate_set(current_run_state, RunState_str(current_run_state),
+     *   - system/runstate.c|235| <<runstate_set>> if (current_run_state == new_state) {
+     *   - system/runstate.c|239| <<runstate_set>> if (!runstate_valid_transitions[current_run_state][new_state]) {
+     *   - system/runstate.c|241| <<runstate_set>> RunState_str(current_run_state),
+     *   - system/runstate.c|246| <<runstate_set>> current_run_state = new_state;
+     *   - system/runstate.c|251| <<runstate_get>> return current_run_state;
+     *   - system/runstate.c|270| <<qmp_query_status>> info->status = current_run_state;
+     */
     info->status = current_run_state;
 
     return info;
@@ -504,6 +580,14 @@ static int qemu_debug_requested(void)
 /*
  * Reset the VM. Issue an event unless @reason is SHUTDOWN_CAUSE_NONE.
  */
+/*
+ * 在以下使用qemu_system_reset():
+ *   - hw/core/machine.c|1825| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+ *   - hw/xen/xen-hvm-common.c|614| <<cpu_handle_ioreq>> qemu_system_reset(request);
+ *   - migration/savevm.c|3463| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+ *   - system/runstate.c|982| <<main_loop_should_exit>> qemu_system_reset(request);
+ *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+ */
 void qemu_system_reset(ShutdownCause reason)
 {
     MachineClass *mc;
@@ -542,6 +626,11 @@ void qemu_system_reset(ShutdownCause reason)
      * it does _more_  than cpu_synchronize_all_post_reset().
      */
     if (cpus_are_resettable()) {
+        /*
+	 * 在以下使用cpu_synchronize_all_post_reset():
+	 *   - hw/i386/pc.c|1735| <<pc_machine_wakeup>> cpu_synchronize_all_post_reset();
+	 *   - system/runstate.c|621| <<qemu_system_reset>> cpu_synchronize_all_post_reset();
+	 */
         cpu_synchronize_all_post_reset();
     } else {
         assert(runstate_check(RUN_STATE_PRELAUNCH));
@@ -688,6 +777,9 @@ void qemu_system_guest_pvshutdown(void)
     qemu_system_shutdown_request(SHUTDOWN_CAUSE_GUEST_SHUTDOWN);
 }
 
+/*
+ * 很多调用
+ */
 void qemu_system_reset_request(ShutdownCause reason)
 {
     if (reboot_action == REBOOT_ACTION_SHUTDOWN &&
@@ -699,6 +791,13 @@ void qemu_system_reset_request(ShutdownCause reason)
     } else {
         reset_requested = reason;
     }
+    /*
+     * 在以下使用cpu_stop_current():
+     *   - hw/ppc/spapr_rtas.c|79| <<rtas_power_off>> cpu_stop_current();
+     *   - system/cpus.c|804| <<vm_stop>> cpu_stop_current();
+     *   - system/runstate.c|791| <<qemu_system_reset_request>> cpu_stop_current();
+     *   - system/runstate.c|825| <<qemu_system_suspend_request>> cpu_stop_current();
+     */
     cpu_stop_current();
     qemu_notify_event();
 }
@@ -707,6 +806,22 @@ static void qemu_system_suspend(void)
 {
     pause_all_vcpus();
     notifier_list_notify(&suspend_notifiers, NULL);
+    /*
+     * 在以下使用runstate_set():
+     *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+     *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+     *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+     *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+     *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+     *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+     *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+     *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+     *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+     *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+     *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+     */
     runstate_set(RUN_STATE_SUSPENDED);
     qapi_event_send_suspend();
 }
@@ -717,6 +832,13 @@ void qemu_system_suspend_request(void)
         return;
     }
     suspend_requested = 1;
+    /*
+     * 在以下使用cpu_stop_current():
+     *   - hw/ppc/spapr_rtas.c|79| <<rtas_power_off>> cpu_stop_current();
+     *   - system/cpus.c|804| <<vm_stop>> cpu_stop_current();
+     *   - system/runstate.c|791| <<qemu_system_reset_request>> cpu_stop_current();
+     *   - system/runstate.c|825| <<qemu_system_suspend_request>> cpu_stop_current();
+     */
     cpu_stop_current();
     qemu_notify_event();
 }
@@ -738,6 +860,22 @@ void qemu_system_wakeup_request(WakeupReason reason, Error **errp)
     if (!(wakeup_reason_mask & (1 << reason))) {
         return;
     }
+    /*
+     * 在以下使用runstate_set():
+     *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+     *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+     *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+     *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+     *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+     *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+     *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+     *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+     *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+     *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+     *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+     *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+     */
     runstate_set(RUN_STATE_RUNNING);
     wakeup_reason = reason;
     qemu_notify_event();
@@ -836,6 +974,10 @@ void qemu_system_debug_request(void)
     qemu_notify_event();
 }
 
+/*
+ * 在以下使用main_loop_should_exit():
+ *   - system/runstate.c|1031| <<qemu_main_loop>> while (!main_loop_should_exit(&status)) {
+ */
 static bool main_loop_should_exit(int *status)
 {
     RunState r;
@@ -866,6 +1008,14 @@ static bool main_loop_should_exit(int *status)
     request = qemu_reset_requested();
     if (request) {
         pause_all_vcpus();
+        /*
+	 * 在以下使用qemu_system_reset():
+	 *   - hw/core/machine.c|1825| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+	 *   - hw/xen/xen-hvm-common.c|614| <<cpu_handle_ioreq>> qemu_system_reset(request);
+	 *   - migration/savevm.c|3463| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+	 *   - system/runstate.c|982| <<main_loop_should_exit>> qemu_system_reset(request);
+	 *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+	 */
         qemu_system_reset(request);
         resume_all_vcpus();
         /*
@@ -875,6 +1025,22 @@ static bool main_loop_should_exit(int *status)
         if (!runstate_check(RUN_STATE_RUNNING) &&
                 !runstate_check(RUN_STATE_INMIGRATE) &&
                 !runstate_check(RUN_STATE_FINISH_MIGRATE)) {
+            /*
+	     * 在以下使用runstate_set():
+             *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+             *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+             *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+             *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+             *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+             *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+             *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+             *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+             *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+             *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+             *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+             *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+             *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+	     */
             runstate_set(RUN_STATE_PRELAUNCH);
         }
     }
@@ -895,10 +1061,17 @@ static bool main_loop_should_exit(int *status)
     return false;
 }
 
+/*
+ * 在以下使用qemu_main_loop():
+ *   - system/main.c|50| <<qemu_default_main>> status = qemu_main_loop();
+ */
 int qemu_main_loop(void)
 {
     int status = EXIT_SUCCESS;
 
+    /*
+     * 只在这里调用main_loop_should_exit()
+     */
     while (!main_loop_should_exit(&status)) {
         main_loop_wait(false);
     }
diff --git a/system/vl.c b/system/vl.c
index 5091fe52d..a88128d08 100644
--- a/system/vl.c
+++ b/system/vl.c
@@ -3546,6 +3546,22 @@ void qemu_init(int argc, char **argv)
                 break;
             case QEMU_OPTION_incoming:
                 if (!incoming) {
+                    /*
+		     * 在以下使用runstate_set():
+                     *   - migration/migration.c|850| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+                     *   - migration/migration.c|856| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+                     *   - migration/migration.c|3568| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+                     *   - migration/migration.c|3606| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+                     *   - migration/savevm.c|2156| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+                     *   - system/cpus.c|301| <<do_vm_stop>> runstate_set(state);
+                     *   - system/cpus.c|795| <<vm_prepare_start>> runstate_set(state);
+                     *   - system/cpus.c|813| <<vm_resume>> runstate_set(state);
+                     *   - system/cpus.c|825| <<vm_stop_force_state>> runstate_set(state);
+		     *   - system/runstate.c|710| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+		     *   - system/runstate.c|741| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+		     *   - system/runstate.c|878| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+		     *   - system/vl.c|3549| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+		     */
                     runstate_set(RUN_STATE_INMIGRATE);
                 }
                 incoming_option_parse(optarg);
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 641777578..665c4b001 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -2128,6 +2128,21 @@ static uint64_t x86_cpu_get_migratable_flags(X86CPU *cpu, FeatureWord w)
         }
     }
 
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     /* when tsc-khz is set explicitly, invtsc is migratable */
     if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
         r |= CPUID_APM_INVTSC;
@@ -7055,6 +7070,14 @@ static void x86_cpuid_get_tsc_freq(Object *obj, Visitor *v, const char *name,
     visit_type_int(v, name, &value, errp);
 }
 
+/*
+ * 在以下使用x86_cpuid_set_tsc_freq():
+ *   - target/i386/cpu.c|10149| <<x86_cpu_common_class_init>> x86_cpuid_set_tsc_freq, NULL, NULL);
+ *
+ * 10181     object_class_property_add(oc, "tsc-frequency", "int",
+ * 10182                               x86_cpuid_get_tsc_freq,
+ * 10183                               x86_cpuid_set_tsc_freq, NULL, NULL);
+ */
 static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, const char *name,
                                    void *opaque, Error **errp)
 {
@@ -7071,6 +7094,21 @@ static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, const char *name,
         return;
     }
 
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
 }
 
@@ -8614,6 +8652,10 @@ static bool cpuid_has_xsave_feature(CPUX86State *env, const ExtSaveArea *esa)
     return false;
 }
 
+/*
+ * 在以下使用x86_cpu_reset_hold():
+ *   - target/i386/cpu.c|10094| <<x86_cpu_common_class_init>> resettable_class_set_parent_phases(rc, NULL, x86_cpu_reset_hold, NULL,
+ */
 static void x86_cpu_reset_hold(Object *obj, ResetType type)
 {
     CPUState *cs = CPU(obj);
@@ -8628,6 +8670,9 @@ static void x86_cpu_reset_hold(Object *obj, ResetType type)
         xcc->parent_phases.hold(obj, type);
     }
 
+    /*
+     * 只在这里使用end_reset_fields
+     */
     memset(env, 0, offsetof(CPUX86State, end_reset_fields));
 
     if (tcg_enabled()) {
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index cee1f692a..6da5bac45 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -2058,6 +2058,10 @@ typedef struct CPUArchState {
     uint64_t msr_rapl_power_unit;
     uint64_t msr_pkg_energy_status;
 
+    /*
+     * 在以下使用CPUX86State->end_reset_fields(CPUArchState):
+     *   - target/i386/cpu.c|8631| <<x86_cpu_reset_hold>> memset(env, 0, offsetof(CPUX86State, end_reset_fields));
+     */
     /* Fields up to this point are cleared by a CPU reset */
     struct {} end_reset_fields;
 
@@ -2111,8 +2115,34 @@ typedef struct CPUArchState {
     uint8_t triple_fault_pending;
     uint32_t ins_len;
     uint32_t sipi_vector;
+    /*
+     * 在以下使用CPUX86State->tsc_valid(CPUArchState):
+     *   - target/i386/kvm/kvm.c|307| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|311| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|846| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4483| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4485| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2130| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     bool tsc_valid;
     int64_t tsc_khz;
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     int64_t user_tsc_khz; /* for sanity check only */
     uint64_t apic_bus_freq;
     uint64_t tsc;
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 60c798113..d99e754ab 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -297,6 +297,10 @@ bool kvm_hv_vpindex_settable(void)
     return hv_vpindex_settable;
 }
 
+/*
+ * 在以下使用kvm_get_tsc():
+ *   - target/i386/kvm/kvm.c|324| <<do_kvm_synchronize_tsc>> kvm_get_tsc(cpu);
+ */
 static int kvm_get_tsc(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -304,6 +308,17 @@ static int kvm_get_tsc(CPUState *cs)
     uint64_t value;
     int ret;
 
+    /*
+     * 在以下使用CPUX86State->tsc_valid(CPUArchState):
+     *   - target/i386/kvm/kvm.c|307| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|311| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|846| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4483| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4485| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2130| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     if (env->tsc_valid) {
         return 0;
     }
@@ -319,11 +334,19 @@ static int kvm_get_tsc(CPUState *cs)
     return 0;
 }
 
+/*
+ * 在以下使用do_kvm_synchronize_tsc():
+ *   - target/i386/kvm/kvm.c|333| <<kvm_synchronize_all_tsc>> run_on_cpu(cpu, do_kvm_synchronize_tsc, RUN_ON_CPU_NULL);
+ */
 static inline void do_kvm_synchronize_tsc(CPUState *cpu, run_on_cpu_data arg)
 {
     kvm_get_tsc(cpu);
 }
 
+/*
+ * 在以下使用kvm_synchronize_all_tsc():
+ *   - hw/i386/kvm/clock.c|285| <<kvmclock_vm_state_change>> kvm_synchronize_all_tsc();
+ */
 void kvm_synchronize_all_tsc(void)
 {
     CPUState *cpu;
@@ -838,11 +861,26 @@ static void kvm_queue_exception(CPUX86State *env,
     }
 }
 
+/*
+ * 在以下使用cpu_update_state():
+ *   - target/i386/kvm/kvm.c|2333| <<kvm_arch_init_vcpu>> cpu->vmsentry = qemu_add_vm_change_state_handler(cpu_update_state, env);
+ */
 static void cpu_update_state(void *opaque, bool running, RunState state)
 {
     CPUX86State *env = opaque;
 
     if (running) {
+        /*
+         * 在以下使用CPUX86State->tsc_valid(CPUArchState):
+         *   - target/i386/kvm/kvm.c|307| <<kvm_get_tsc>> if (env->tsc_valid) {
+         *   - target/i386/kvm/kvm.c|311| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/kvm/kvm.c|846| <<cpu_update_state>> env->tsc_valid = false;
+         *   - target/i386/kvm/kvm.c|4483| <<kvm_get_msrs>> if (!env->tsc_valid) {
+         *   - target/i386/kvm/kvm.c|4485| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+         *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+         *   - target/i386/whpx/whpx-all.c|2130| <<whpx_cpu_update_state>> env->tsc_valid = false;
+	 */
         env->tsc_valid = false;
     }
 }
@@ -918,6 +956,11 @@ static int kvm_arch_set_tsc_khz(CPUState *cs)
         set_ioctl = true;
     }
 
+    /*
+     * 在以下使用KVM_SET_TSC_KHZ:
+     *   - target/i386/kvm/kvm.c|922| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :
+     *   - target/i386/kvm/tdx.c|1027| <<tdx_pre_create_vcpu>> r = kvm_vm_ioctl(kvm_state, KVM_SET_TSC_KHZ, env->tsc_khz);
+     */
     r = set_ioctl ?
         kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :
         -ENOTSUP;
@@ -946,6 +989,21 @@ static bool tsc_is_stable_and_known(CPUX86State *env)
     if (!env->tsc_khz) {
         return false;
     }
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     return (env->features[FEAT_8000_0007_EDX] & CPUID_APM_INVTSC)
         || env->user_tsc_khz;
 }
@@ -2209,6 +2267,21 @@ int kvm_arch_init_vcpu(CPUState *cs)
             (!!(env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_RDTSCP) << 2));
         /* default=0 (emulate if necessary) */
         c->ebx = 0;
+        /*
+	 * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+	 *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+         *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+         *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+         *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+         *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+         *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+         *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+         *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+         *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+         *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+         *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+         *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+	 */
         /* guest tsc frequency */
         c->ecx = env->user_tsc_khz;
         /* guest tsc incarnation (migration count) */
@@ -2330,6 +2403,21 @@ int kvm_arch_init_vcpu(CPUState *cs)
         has_msr_mcg_ext_ctl = has_msr_feature_control = true;
     }
 
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     if (!env->user_tsc_khz) {
         if ((env->features[FEAT_8000_0007_EDX] & CPUID_APM_INVTSC) &&
             invtsc_mig_blocker == NULL) {
@@ -2455,6 +2543,10 @@ void kvm_arch_after_reset_vcpu(X86CPU *cpu)
     }
 }
 
+/*
+ * 在以下使用kvm_arch_reset_parked_vcpu():
+ *   - accel/kvm/kvm-all.c|459| <<kvm_reset_parked_vcpus>> kvm_arch_reset_parked_vcpu(cpu->vcpu_id, cpu->kvm_fd);
+ */
 void kvm_arch_reset_parked_vcpu(unsigned long vcpu_id, int kvm_fd)
 {
     g_autofree struct kvm_msrs *msrs = NULL;
@@ -4471,6 +4563,17 @@ static int kvm_get_msrs(X86CPU *cpu)
     if (has_msr_virt_ssbd) {
         kvm_msr_entry_add(cpu, MSR_VIRT_SSBD, 0);
     }
+    /*
+     * 在以下使用CPUX86State->tsc_valid(CPUArchState):
+     *   - target/i386/kvm/kvm.c|307| <<kvm_get_tsc>> if (env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|311| <<kvm_get_tsc>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/kvm/kvm.c|846| <<cpu_update_state>> env->tsc_valid = false;
+     *   - target/i386/kvm/kvm.c|4483| <<kvm_get_msrs>> if (!env->tsc_valid) {
+     *   - target/i386/kvm/kvm.c|4485| <<kvm_get_msrs>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|612| <<whpx_get_registers>> if (!env->tsc_valid) {
+     *   - target/i386/whpx/whpx-all.c|614| <<whpx_get_registers>> env->tsc_valid = !runstate_is_running();
+     *   - target/i386/whpx/whpx-all.c|2130| <<whpx_cpu_update_state>> env->tsc_valid = false;
+     */
     if (!env->tsc_valid) {
         kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);
         env->tsc_valid = !runstate_is_running();
diff --git a/target/i386/kvm/tdx.c b/target/i386/kvm/tdx.c
index dbf0fa2c9..0b27adab7 100644
--- a/target/i386/kvm/tdx.c
+++ b/target/i386/kvm/tdx.c
@@ -1023,6 +1023,11 @@ int tdx_pre_create_vcpu(CPUState *cpu, Error **errp)
         return -EINVAL;
     }
 
+    /*
+     * 在以下使用KVM_SET_TSC_KHZ:
+     *   - target/i386/kvm/kvm.c|922| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :
+     *   - target/i386/kvm/tdx.c|1027| <<tdx_pre_create_vcpu>> r = kvm_vm_ioctl(kvm_state, KVM_SET_TSC_KHZ, env->tsc_khz);
+     */
     /* it's safe even env->tsc_khz is 0. KVM uses host's tsc_khz in this case */
     r = kvm_vm_ioctl(kvm_state, KVM_SET_TSC_KHZ, env->tsc_khz);
     if (r < 0) {
diff --git a/target/i386/machine.c b/target/i386/machine.c
index 45b7cea80..186bcf754 100644
--- a/target/i386/machine.c
+++ b/target/i386/machine.c
@@ -317,6 +317,21 @@ static int cpu_post_load(void *opaque, int version_id)
     CPUX86State *env = &cpu->env;
     int i;
 
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     if (env->tsc_khz && env->user_tsc_khz &&
         env->tsc_khz != env->user_tsc_khz) {
         error_report("Mismatch between user-specified TSC frequency and "
@@ -924,6 +939,21 @@ static int hyperv_reenlightenment_post_load(void *opaque, int version_id)
     X86CPU *cpu = opaque;
     CPUX86State *env = &cpu->env;
 
+    /*
+     * 在以下使用CPUX86State->user_tsc_khz(CPUArchState):
+     *   - target/i386/cpu.c|2132| <<x86_cpu_get_migratable_flags>> if ((w == FEAT_8000_0007_EDX) && env->user_tsc_khz) {
+     *   - target/i386/cpu.c|7074| <<x86_cpuid_set_tsc_freq>> cpu->env.tsc_khz = cpu->env.user_tsc_khz = value / 1000;
+     *   - target/i386/kvm/kvm.c|993| <<tsc_is_stable_and_known>> return (env->features[FEAT_8000_0007_EDX] &
+     *                                                  CPUID_APM_INVTSC) || env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2256| <<kvm_arch_init_vcpu>> c->ecx = env->user_tsc_khz;
+     *   - target/i386/kvm/kvm.c|2376| <<kvm_arch_init_vcpu>> if (!env->user_tsc_khz) {
+     *   - target/i386/machine.c|320| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|321| <<cpu_post_load>> if (env->tsc_khz &&
+     *                      env->user_tsc_khz && env->tsc_khz != env->user_tsc_khz) {
+     *   - target/i386/machine.c|932| <<hyperv_reenlightenment_post_load>>
+     *             if ((env->msr_hv_reenlightenment_control & HV_REENLIGHTENMENT_ENABLE_BIT) && !env->user_tsc_khz) {
+     */
     /*
      * KVM doesn't fully support re-enlightenment notifications so we need to
      * make sure TSC frequency doesn't change upon migration.
diff --git a/ui/vnc.c b/ui/vnc.c
index e6bcf0e1c..3195ee888 100644
--- a/ui/vnc.c
+++ b/ui/vnc.c
@@ -2541,6 +2541,11 @@ static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)
                 send_xvp_message(vs, VNC_XVP_CODE_FAIL);
                 break;
             case VNC_XVP_ACTION_RESET:
+                /*
+		 * 在以下使用SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET:
+                 *   - hw/core/machine-qmp-cmds.c|305| <<qmp_system_reset>> qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
+                 *   - ui/vnc.c|2544| <<protocol_client_msg>> qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
+		 */
                 qemu_system_reset_request(SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET);
                 break;
             default:
diff --git a/util/main-loop.c b/util/main-loop.c
index b462598f7..15756bb44 100644
--- a/util/main-loop.c
+++ b/util/main-loop.c
@@ -133,6 +133,12 @@ static int qemu_signal_init(Error **errp)
 #endif
 
 static AioContext *qemu_aio_context;
+/*
+ * 在以下使用qemu_notify_bh:
+ *   - util/main-loop.c|136| <<global>> static QEMUBH *qemu_notify_bh;
+ *   - util/main-loop.c|155| <<qemu_notify_event>> qemu_bh_schedule(qemu_notify_bh);
+ *   - util/main-loop.c|177| <<qemu_init_main_loop>> qemu_notify_bh = qemu_bh_new(notify_event_cb, NULL);
+ */
 static QEMUBH *qemu_notify_bh;
 
 static void notify_event_cb(void *opaque)
@@ -152,6 +158,12 @@ void qemu_notify_event(void)
     if (!qemu_aio_context) {
         return;
     }
+    /*
+     * 在以下使用qemu_notify_bh:
+     *   - util/main-loop.c|136| <<global>> static QEMUBH *qemu_notify_bh;
+     *   - util/main-loop.c|155| <<qemu_notify_event>> qemu_bh_schedule(qemu_notify_bh);
+     *   - util/main-loop.c|177| <<qemu_init_main_loop>> qemu_notify_bh = qemu_bh_new(notify_event_cb, NULL);
+     */
     qemu_bh_schedule(qemu_notify_bh);
 }
 
@@ -174,6 +186,12 @@ int qemu_init_main_loop(Error **errp)
         return -EMFILE;
     }
     qemu_set_current_aio_context(qemu_aio_context);
+    /*
+     * 在以下使用qemu_notify_bh:
+     *   - util/main-loop.c|136| <<global>> static QEMUBH *qemu_notify_bh;
+     *   - util/main-loop.c|155| <<qemu_notify_event>> qemu_bh_schedule(qemu_notify_bh);
+     *   - util/main-loop.c|177| <<qemu_init_main_loop>> qemu_notify_bh = qemu_bh_new(notify_event_cb, NULL);
+     */
     qemu_notify_bh = qemu_bh_new(notify_event_cb, NULL);
     gpollfds = g_array_new(FALSE, FALSE, sizeof(GPollFD));
     src = aio_get_g_source(qemu_aio_context);
-- 
2.50.1 (Apple Git-155)

