From 39d52e421b0aa2ed987dfda83e178cd6d0bce7fb Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Sun, 18 Jan 2026 21:39:17 -0800
Subject: [PATCH 1/1] qemu for v10.2.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-all.c        |  7 ++++++
 accel/tcg/plugin-gen.c     |  4 ++++
 contrib/plugins/cache.c    |  4 ++++
 hw/i386/amd_iommu.c        |  9 ++++++++
 hw/i386/intel_iommu.c      |  9 ++++++++
 hw/i386/microvm.c          |  9 ++++++++
 hw/i386/pc.c               |  9 ++++++++
 hw/intc/ioapic.c           | 18 +++++++++++++++
 hw/virtio/virtio-balloon.c | 17 ++++++++++++++
 include/hw/i386/x86.h      |  9 ++++++++
 system/balloon.c           | 45 ++++++++++++++++++++++++++++++++++++++
 target/i386/kvm/kvm.c      |  5 +++++
 target/i386/kvm/tdx.c      |  5 +++++
 13 files changed, 150 insertions(+)

diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 28006d73c..bdc42d563 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -447,6 +447,10 @@ static int kvm_unpark_vcpu(KVMState *s, unsigned long vcpu_id)
     return kvm_fd;
 }
 
+/*
+ * 在以下使用kvm_reset_parked_vcpus():
+ *   - accel/kvm/kvm-all.c|2974| <<kvm_cpu_synchronize_post_reset>> kvm_reset_parked_vcpus(kvm_state);
+ */
 static void kvm_reset_parked_vcpus(KVMState *s)
 {
     struct KVMParkedVcpu *cpu;
@@ -2971,6 +2975,9 @@ void kvm_cpu_synchronize_post_reset(CPUState *cpu)
     run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
 
     if (cpu == first_cpu) {
+        /*
+	 * 只在这里使用
+	 */
         kvm_reset_parked_vcpus(kvm_state);
     }
 }
diff --git a/accel/tcg/plugin-gen.c b/accel/tcg/plugin-gen.c
index 1ffcb4b2d..793d5d384 100644
--- a/accel/tcg/plugin-gen.c
+++ b/accel/tcg/plugin-gen.c
@@ -290,6 +290,10 @@ static void inject_mem_cb(struct qemu_plugin_dyn_cb *cb,
     }
 }
 
+/*
+ * 在以下使用plugin_gen_inject():
+ *   - accel/tcg/plugin-gen.c|505| <<plugin_gen_tb_end>> plugin_gen_inject(ptb);
+ */
 static void plugin_gen_inject(struct qemu_plugin_tb *plugin_tb)
 {
     TCGOp *op, *next;
diff --git a/contrib/plugins/cache.c b/contrib/plugins/cache.c
index 56508587d..09b89adb1 100644
--- a/contrib/plugins/cache.c
+++ b/contrib/plugins/cache.c
@@ -385,6 +385,10 @@ static bool access_cache(Cache *cache, uint64_t addr)
     return false;
 }
 
+/*
+ * 在以下是他vcpu_mem_access():
+ *   - contrib/plugins/cache.c|493| <<vcpu_tb_trans>> qemu_plugin_register_vcpu_mem_cb(insn, vcpu_mem_access,
+ */
 static void vcpu_mem_access(unsigned int vcpu_index, qemu_plugin_meminfo_t info,
                             uint64_t vaddr, void *userdata)
 {
diff --git a/hw/i386/amd_iommu.c b/hw/i386/amd_iommu.c
index d689a06ec..90a7b20a0 100644
--- a/hw/i386/amd_iommu.c
+++ b/hw/i386/amd_iommu.c
@@ -2573,6 +2573,15 @@ static void amdvi_sysbus_realize(DeviceState *dev, Error **errp)
     memory_region_add_subregion_overlap(&s->mr_sys, AMDVI_INT_ADDR_FIRST,
                                         &s->mr_ir, 1);
 
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     /* Pseudo address space under root PCI bus. */
     x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
 
diff --git a/hw/i386/intel_iommu.c b/hw/i386/intel_iommu.c
index 78b142cce..ff761e97b 100644
--- a/hw/i386/intel_iommu.c
+++ b/hw/i386/intel_iommu.c
@@ -5456,6 +5456,15 @@ static void vtd_realize(DeviceState *dev, Error **errp)
                                                   g_free, vtd_hiod_destroy);
     vtd_init(s);
     pci_setup_iommu(bus, &vtd_iommu_ops, dev);
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     /* Pseudo address space under root PCI bus. */
     x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
 }
diff --git a/hw/i386/microvm.c b/hw/i386/microvm.c
index 94d22a232..589e0d712 100644
--- a/hw/i386/microvm.c
+++ b/hw/i386/microvm.c
@@ -340,6 +340,15 @@ static void microvm_memory_init(MicrovmMachineState *mms)
     }
 
     x86ms->fw_cfg = fw_cfg;
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     x86ms->ioapic_as = &address_space_memory;
 }
 
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index f8b919cb6..3bb93d737 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1007,6 +1007,15 @@ void pc_memory_init(PCMachineState *pcms,
     }
     x86ms->fw_cfg = fw_cfg;
 
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     /* Init default IOAPIC address space */
     x86ms->ioapic_as = &address_space_memory;
 
diff --git a/hw/intc/ioapic.c b/hw/intc/ioapic.c
index 38e438464..2975e21a0 100644
--- a/hw/intc/ioapic.c
+++ b/hw/intc/ioapic.c
@@ -96,6 +96,15 @@ static void ioapic_entry_parse(uint64_t entry, struct ioapic_entry_info *info)
 
 static void ioapic_service(IOAPICCommonState *s)
 {
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
     struct ioapic_entry_info info;
     uint8_t i;
@@ -137,6 +146,15 @@ static void ioapic_service(IOAPICCommonState *s)
                 }
 #endif
 
+                /*
+		 * 在以下使用X86MachineState->ioapic_as:
+                 *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+                 *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+                 *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+                 *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+                 *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+                 *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+		 */
                 /* No matter whether IR is enabled, we translate
                  * the IOAPIC message into a MSI one, and its
                  * address space will decide whether we need a
diff --git a/hw/virtio/virtio-balloon.c b/hw/virtio/virtio-balloon.c
index 02cdd807d..92fbb4a78 100644
--- a/hw/virtio/virtio-balloon.c
+++ b/hw/virtio/virtio-balloon.c
@@ -399,6 +399,11 @@ skip_element:
     }
 }
 
+/*
+ * 在以下使用virtio_balloon_handle_output():
+ *   - hw/virtio/virtio-balloon.c|893| <<virtio_balloon_device_realize>> s->ivq = virtio_add_queue(vdev, 128, virtio_balloon_handle_output);
+ *   - hw/virtio/virtio-balloon.c|894| <<virtio_balloon_device_realize>> s->dvq = virtio_add_queue(vdev, 128, virtio_balloon_handle_output);
+ */
 static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBalloon *s = VIRTIO_BALLOON(vdev);
@@ -762,6 +767,10 @@ static bool virtio_balloon_page_poison_support(void *opaque)
     return virtio_vdev_has_feature(vdev, VIRTIO_BALLOON_F_PAGE_POISON);
 }
 
+/*
+ * 在以下使用virtio_balloon_set_config():
+ *   - hw/virtio/virtio-balloon.c|1076| <<virtio_balloon_class_init>> vdc->set_config = virtio_balloon_set_config;
+ */
 static void virtio_balloon_set_config(VirtIODevice *vdev,
                                       const uint8_t *config_data)
 {
@@ -773,6 +782,9 @@ static void virtio_balloon_set_config(VirtIODevice *vdev,
     memcpy(&config, config_data, virtio_balloon_config_size(dev));
     dev->actual = le32_to_cpu(config.actual);
     if (dev->actual != oldactual) {
+        /*
+	 * 只在这里使用
+	 */
         qapi_event_send_balloon_change(vm_ram_size -
                         ((ram_addr_t) dev->actual << VIRTIO_BALLOON_PFN_SHIFT));
     }
@@ -800,6 +812,11 @@ static void virtio_balloon_stat(void *opaque, BalloonInfo *info)
                                              VIRTIO_BALLOON_PFN_SHIFT);
 }
 
+/*
+ * 在以下使用virtio_balloon_to_target():
+ *   - hw/virtio/virtio-balloon.c|889| <<virtio_balloon_device_realize>>
+ *          ret = qemu_add_balloon_handler(virtio_balloon_to_target, virtio_balloon_stat, s);
+ */
 static void virtio_balloon_to_target(void *opaque, ram_addr_t target)
 {
     VirtIOBalloon *dev = VIRTIO_BALLOON(opaque);
diff --git a/include/hw/i386/x86.h b/include/hw/i386/x86.h
index 8755cad50..30ceb73de 100644
--- a/include/hw/i386/x86.h
+++ b/include/hw/i386/x86.h
@@ -85,6 +85,15 @@ struct X86MachineState {
      * Address space used by IOAPIC device. All IOAPIC interrupts
      * will be translated to MSI messages in the address space.
      */
+    /*
+     * 在以下使用X86MachineState->ioapic_as:
+     *   - hw/i386/amd_iommu.c|2577| <<amdvi_sysbus_realize>> x86ms->ioapic_as = amdvi_host_dma_iommu(bus, s, AMDVI_IOAPIC_SB_DEVID);
+     *   - hw/i386/intel_iommu.c|5460| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+     *   - hw/i386/microvm.c|343| <<microvm_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/i386/pc.c|1011| <<pc_memory_init>> x86ms->ioapic_as = &address_space_memory;
+     *   - hw/intc/ioapic.c|99| <<ioapic_service>> AddressSpace *ioapic_as = X86_MACHINE(qdev_get_machine())->ioapic_as;
+     *   - hw/intc/ioapic.c|144| <<ioapic_service>> stl_le_phys(ioapic_as, info.addr, info.data);
+     */
     AddressSpace *ioapic_as;
 
     /*
diff --git a/system/balloon.c b/system/balloon.c
index 311fa5058..2b6c596a4 100644
--- a/system/balloon.c
+++ b/system/balloon.c
@@ -33,6 +33,15 @@
 #include "qapi/qmp/qerror.h"
 #include "trace.h"
 
+/*
+ * 在以下使用balloon_event_fn:
+ *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+ *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+ *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+ *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+ *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+ *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+ */
 static QEMUBalloonEvent *balloon_event_fn;
 static QEMUBalloonStatus *balloon_stat_fn;
 static void *balloon_opaque;
@@ -44,6 +53,15 @@ static bool have_balloon(Error **errp)
                   "Using KVM without synchronous MMU, balloon unavailable");
         return false;
     }
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     if (!balloon_event_fn) {
         error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,
                   "No balloon device has been activated");
@@ -61,6 +79,15 @@ int qemu_add_balloon_handler(QEMUBalloonEvent *event_func,
          */
         return -1;
     }
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     balloon_event_fn = event_func;
     balloon_stat_fn = stat_func;
     balloon_opaque = opaque;
@@ -72,6 +99,15 @@ void qemu_remove_balloon_handler(void *opaque)
     if (balloon_opaque != opaque) {
         return;
     }
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn;
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     balloon_event_fn = NULL;
     balloon_stat_fn = NULL;
     balloon_opaque = NULL;
@@ -102,5 +138,14 @@ void qmp_balloon(int64_t value, Error **errp)
     }
 
     trace_balloon_event(balloon_opaque, value);
+    /*
+     * 在以下使用balloon_event_fn:
+     *   - system/balloon.c|36| <<global>> static QEMUBalloonEvent *balloon_event_fn
+     *   - system/balloon.c|47| <<have_balloon>> if (!balloon_event_fn) {
+     *   - system/balloon.c|58| <<qemu_add_balloon_handler>> if (balloon_event_fn || balloon_stat_fn || balloon_opaque) {
+     *   - system/balloon.c|64| <<qemu_add_balloon_handler>> balloon_event_fn = event_func;
+     *   - system/balloon.c|75| <<qemu_remove_balloon_handler>> balloon_event_fn = NULL;
+     *   - system/balloon.c|105| <<qmp_balloon>> balloon_event_fn(balloon_opaque, value);
+     */
     balloon_event_fn(balloon_opaque, value);
 }
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 60c798113..13c97cb48 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -918,6 +918,11 @@ static int kvm_arch_set_tsc_khz(CPUState *cs)
         set_ioctl = true;
     }
 
+    /*
+     * 在以下使用KVM_SET_TSC_KHZ:
+     *   - target/i386/kvm/kvm.c|922| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :
+     *   - target/i386/kvm/tdx.c|1027| <<tdx_pre_create_vcpu>> r = kvm_vm_ioctl(kvm_state, KVM_SET_TSC_KHZ, env->tsc_khz);
+     */
     r = set_ioctl ?
         kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :
         -ENOTSUP;
diff --git a/target/i386/kvm/tdx.c b/target/i386/kvm/tdx.c
index dbf0fa2c9..0b27adab7 100644
--- a/target/i386/kvm/tdx.c
+++ b/target/i386/kvm/tdx.c
@@ -1023,6 +1023,11 @@ int tdx_pre_create_vcpu(CPUState *cpu, Error **errp)
         return -EINVAL;
     }
 
+    /*
+     * 在以下使用KVM_SET_TSC_KHZ:
+     *   - target/i386/kvm/kvm.c|922| <<kvm_arch_set_tsc_khz>> kvm_vcpu_ioctl(cs, KVM_SET_TSC_KHZ, env->tsc_khz) :
+     *   - target/i386/kvm/tdx.c|1027| <<tdx_pre_create_vcpu>> r = kvm_vm_ioctl(kvm_state, KVM_SET_TSC_KHZ, env->tsc_khz);
+     */
     /* it's safe even env->tsc_khz is 0. KVM uses host's tsc_khz in this case */
     r = kvm_vm_ioctl(kvm_state, KVM_SET_TSC_KHZ, env->tsc_khz);
     if (r < 0) {
-- 
2.50.1 (Apple Git-155)

