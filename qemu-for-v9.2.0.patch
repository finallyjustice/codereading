From e8e02c9876759378178ab09bb513fc7b3d6e33b7 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 20 Jan 2025 22:07:51 -0800
Subject: [PATCH 1/1] qemu for v9.2.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 backends/hostmem-ram.c      |   4 +
 hw/net/virtio-net.c         |  11 ++
 hw/pci/msix.c               |   9 ++
 hw/scsi/vhost-scsi-common.c |   3 +
 hw/virtio/vhost-user.c      |  10 ++
 hw/virtio/vhost.c           | 216 +++++++++++++++++++++++++++++++
 hw/virtio/virtio.c          |  19 +++
 include/exec/ramblock.h     |  56 ++++++++
 include/hw/pci/pci_device.h |  10 ++
 include/hw/virtio/vhost.h   |  19 +++
 migration/migration.c       |  21 +++
 migration/migration.h       |   7 +
 migration/multifd-nocomp.c  |  20 +++
 migration/options.c         |  33 +++++
 migration/qemu-file.c       | 110 ++++++++++++++++
 migration/ram.c             | 249 ++++++++++++++++++++++++++++++++++++
 migration/savevm.c          |  79 ++++++++++++
 system/memory.c             |   8 ++
 system/physmem.c            |  97 ++++++++++++++
 19 files changed, 981 insertions(+)

diff --git a/backends/hostmem-ram.c b/backends/hostmem-ram.c
index f7d81af78..bccb6b43e 100644
--- a/backends/hostmem-ram.c
+++ b/backends/hostmem-ram.c
@@ -16,6 +16,10 @@
 #include "qemu/module.h"
 #include "qom/object_interfaces.h"
 
+/*
+ * 在以下使用ram_backend_memory_alloc():
+ *   - backends/hostmem-ram.c|44| <<ram_backend_class_init>> bc->alloc = ram_backend_memory_alloc;
+ */
 static bool
 ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index 6e8c51a2d..bdae06685 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -222,6 +222,11 @@ static bool virtio_net_started(VirtIONet *n, uint8_t status)
         (n->status & VIRTIO_NET_S_LINK_UP) && vdev->vm_running;
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|240| <<virtio_net_announce_timer>> virtio_net_announce_notify(n);
+ *   - hw/net/virtio-net.c|259| <<virtio_net_announce>> virtio_net_announce_notify(n);
+ */
 static void virtio_net_announce_notify(VirtIONet *net)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(net);
@@ -240,6 +245,9 @@ static void virtio_net_announce_timer(void *opaque)
     virtio_net_announce_notify(n);
 }
 
+/*
+ * NetClientInfo net_virtio_info.announce = virtio_net_announce()
+ */
 static void virtio_net_announce(NetClientState *nc)
 {
     VirtIONet *n = qemu_get_nic_opaque(nc);
@@ -439,6 +447,9 @@ static void virtio_net_set_status(struct VirtIODevice *vdev, uint8_t status)
     }
 }
 
+/*
+ * NetClientInfo net_virtio_inf.link_status_changed = virtio_net_set_link_status()
+ */
 static void virtio_net_set_link_status(NetClientState *nc)
 {
     VirtIONet *n = qemu_get_nic_opaque(nc);
diff --git a/hw/pci/msix.c b/hw/pci/msix.c
index 487e49834..8e5316a24 100644
--- a/hw/pci/msix.c
+++ b/hw/pci/msix.c
@@ -615,6 +615,15 @@ static void msix_unset_notifier_for_vector(PCIDevice *dev, unsigned int vector)
     dev->msix_vector_release_notifier(dev, vector);
 }
 
+/*
+ * called by:
+ *   - hw/misc/ivshmem.c|775| <<ivshmem_enable_irqfd>> if (msix_set_vector_notifiers(pdev,
+ *            ivshmem_vector_unmask, ivshmem_vector_mask, ivshmem_vector_poll)) {
+ *   - hw/vfio/pci.c|686| <<vfio_msix_enable>> if (msix_set_vector_notifiers(&vdev->pdev,
+ *            vfio_msix_vector_use, vfio_msix_vector_release, NULL)) {
+ *   - hw/virtio/virtio-pci.c|1290| <<virtio_pci_set_guest_notifiers>> r = msix_set_vector_notifiers(&proxy->pci_dev,
+ *            virtio_pci_vector_unmask, virtio_pci_vector_mask, virtio_pci_vector_poll);
+ */
 int msix_set_vector_notifiers(PCIDevice *dev,
                               MSIVectorUseNotifier use_notifier,
                               MSIVectorReleaseNotifier release_notifier,
diff --git a/hw/scsi/vhost-scsi-common.c b/hw/scsi/vhost-scsi-common.c
index 4c8637045..652390edb 100644
--- a/hw/scsi/vhost-scsi-common.c
+++ b/hw/scsi/vhost-scsi-common.c
@@ -78,6 +78,9 @@ int vhost_scsi_common_start(VHostSCSICommon *vsc, Error **errp)
         }
     }
 
+    /*
+     * 里面会调用vhost_dev_set_features()
+     */
     ret = vhost_dev_start(&vsc->dev, vdev, true);
     if (ret < 0) {
         error_setg_errno(errp, -ret, "Error starting vhost dev");
diff --git a/hw/virtio/vhost-user.c b/hw/virtio/vhost-user.c
index f170f0b25..21a7dae8e 100644
--- a/hw/virtio/vhost-user.c
+++ b/hw/virtio/vhost-user.c
@@ -502,6 +502,11 @@ static void vhost_user_fill_msg_region(VhostUserMemoryRegion *dst,
     dst->mmap_offset = mmap_offset;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost-user.c|923| <<vhost_user_set_mem_table_postcopy>> ret = vhost_user_fill_set_mem_table_msg(u, dev, &msg, fds, &fd_num,
+ *   - hw/virtio/vhost-user.c|1041| <<vhost_user_set_mem_table>> ret = vhost_user_fill_set_mem_table_msg(u, dev, &msg, fds, &fd_num,
+ */
 static int vhost_user_fill_set_mem_table_msg(struct vhost_user *u,
                                              struct vhost_dev *dev,
                                              VhostUserMsg *msg,
@@ -1038,6 +1043,11 @@ static int vhost_user_set_mem_table(struct vhost_dev *dev,
             return ret;
         }
     } else {
+	/*
+	 * called by:
+	 *   - hw/virtio/vhost-user.c|923| <<vhost_user_set_mem_table_postcopy>> ret = vhost_user_fill_set_mem_table_msg(u, dev, &msg, fds, &fd_num,
+	 *   - hw/virtio/vhost-user.c|1041| <<vhost_user_set_mem_table>> ret = vhost_user_fill_set_mem_table_msg(u, dev, &msg, fds, &fd_num,
+	 */
         ret = vhost_user_fill_set_mem_table_msg(u, dev, &msg, fds, &fd_num,
                                                 false);
         if (ret < 0) {
diff --git a/hw/virtio/vhost.c b/hw/virtio/vhost.c
index c40f48ac4..a36fcc1dd 100644
--- a/hw/virtio/vhost.c
+++ b/hw/virtio/vhost.c
@@ -338,6 +338,86 @@ static int vhost_set_backend_type(struct vhost_dev *dev,
     return r;
 }
 
+/*
+ * 关于cancel migration.
+ *
+ * vhost_net启动的时候.
+ *
+ * (gdb) bt
+ * #0  vhost_dev_set_features (dev=0x555557686cc0, enable_log=false) at ../hw/virtio/vhost.c:989
+ * #1  0x0000555555b94909 in vhost_dev_start (hdev=0x555557686cc0, vdev=0x555558428ba0, vrings=false) at ../hw/virtio/vhost.c:2082
+ * #2  0x0000555555a47c24 in vhost_net_start_one (net=0x555557686cc0, dev=0x555558428ba0) at ../hw/net/vhost_net.c:280
+ * #3  0x0000555555a48278 in vhost_net_start (dev=0x555558428ba0, ncs=0x555558459418, data_queue_pairs=2, cvq=0) at ../hw/net/vhost_net.c:421
+ * #4  0x0000555555df0a1b in virtio_net_vhost_status (n=0x555558428ba0, status=15 '\017') at ../hw/net/virtio-net.c:311
+ * #5  0x0000555555df0d2b in virtio_net_set_status (vdev=0x555558428ba0, status=15 '\017') at ../hw/net/virtio-net.c:393
+ * #6  0x0000555555e33c08 in virtio_set_status (vdev=0x555558428ba0, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #7  0x0000555555b7b531 in virtio_pci_common_write (opaque=0x555558420720, addr=20, val=15, size=1) at ../hw/virtio/virtio-pci.c:1608
+ * #8  0x0000555555e63c32 in memory_region_write_accessor (mr=0x555558421310, addr=20, value=0x7fffe9ed43f8, size=1, shift=0, mask=255, attrs=...)
+ *     at ../system/memory.c:497
+ * #9  0x0000555555e63f79 in access_with_adjusted_size (addr=20, value=0x7fffe9ed43f8, size=1, access_size_min=1, access_size_max=4,
+ *     access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x555558421310, attrs=...) at ../system/memory.c:573
+ * #10 0x0000555555e674ae in memory_region_dispatch_write (mr=0x555558421310, addr=20, data=15, op=MO_8, attrs=...) at ../system/memory.c:1521
+ * #11 0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff0036028 "\017", len=1, mr_addr=20, l=0x7fffe9ed44e0, mr=0x555558421310)
+ *     at ../system/physmem.c:2803
+ * #12 0x0000555555e76cae in flatview_write_continue (fv=0x7ffe4c000fc0, addr=4261412884, attrs=..., ptr=0x7ffff0036028, len=1, mr_addr=20, l=1,
+ *     mr=0x555558421310) at ../system/physmem.c:2833
+ * #13 0x0000555555e76dd6 in flatview_write (fv=0x7ffe4c000fc0, addr=4261412884, attrs=..., buf=0x7ffff0036028, len=1) at ../system/physmem.c:2864
+ * #14 0x0000555555e77250 in address_space_write (as=0x555557328200 <address_space_memory>, addr=4261412884, attrs=..., buf=0x7ffff0036028, len=1)
+ *     at ../system/physmem.c:2984
+ * #15 0x0000555555e772c8 in address_space_rw (as=0x555557328200 <address_space_memory>, addr=4261412884, attrs=..., buf=0x7ffff0036028, len=1,
+ *     is_write=true) at ../system/physmem.c:2994
+ * #16 0x0000555555ed4d63 in kvm_cpu_exec (cpu=0x5555577413a0) at ../accel/kvm/kvm-all.c:3075
+ * #17 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x5555577413a0) at ../accel/kvm/kvm-accel-ops.c:50
+ * #18 0x000055555616b040 in qemu_thread_start (args=0x55555774a370) at ../util/qemu-thread-posix.c:541
+ * #19 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #20 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * vhost_net开始迁移的时候.
+ *
+ * (gdb) bt
+ * #0  vhost_dev_set_features (dev=0x555557686cc0, enable_log=true) at ../hw/virtio/vhost.c:989
+ * #1  0x0000555555b919e5 in vhost_dev_set_log (dev=0x555557686cc0, enable_log=true) at ../hw/virtio/vhost.c:1024
+#2  0x0000555555b91c5a in vhost_migration_log (listener=0x555557686cc8, enable=true) at ../hw/virtio/vhost.c:1093
+#3  0x0000555555b91ccf in vhost_log_global_start (listener=0x555557686cc8, errp=0x7ffe2fbfa628) at ../hw/virtio/vhost.c:1125
+#4  0x0000555555e6b859 in memory_global_dirty_log_do_start (errp=0x7ffe2fbfa628) at ../system/memory.c:2902
+#5  0x0000555555e6b98d in memory_global_dirty_log_start (flags=1, errp=0x7ffe2fbfa628) at ../system/memory.c:2941
+#6  0x0000555555e84d5d in ram_init_bitmaps (rs=0x7ffe20007d40, errp=0x7ffe2fbfa628) at ../migration/ram.c:2782
+#7  0x0000555555e84e6e in ram_init_all (rsp=0x555557328500 <ram_state>, errp=0x7ffe2fbfa628) at ../migration/ram.c:2816
+#8  0x0000555555e854fc in ram_save_setup (f=0x555557674610, opaque=0x555557328500 <ram_state>, errp=0x7ffe2fbfa628) at ../migration/ram.c:3010
+#9  0x0000555555c2fe16 in qemu_savevm_state_setup (f=0x555557674610, errp=0x7ffe2fbfa628) at ../migration/savevm.c:1346
+#10 0x0000555555c19305 in migration_thread (opaque=0x5555573fe000) at ../migration/migration.c:3507
+#11 0x000055555616b040 in qemu_thread_start (args=0x555557753b70) at ../util/qemu-thread-posix.c:541
+#12 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+#13 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+
+vhost_net cancel迁移的时候.
+
+(gdb) bt
+#0  vhost_dev_set_features (dev=0x5555573f9850, enable_log=false) at ../hw/virtio/vhost.c:989
+#1  0x0000555555b919e5 in vhost_dev_set_log (dev=0x5555573f9850, enable_log=false) at ../hw/virtio/vhost.c:1024
+#2  0x0000555555b91c0f in vhost_migration_log (listener=0x5555573f9858, enable=false) at ../hw/virtio/vhost.c:1086
+#3  0x0000555555b91d0c in vhost_log_global_stop (listener=0x5555573f9858) at ../hw/virtio/vhost.c:1136
+#4  0x0000555555e6bacd in memory_global_dirty_log_do_stop (flags=1) at ../system/memory.c:2966
+#5  0x0000555555e6bc06 in memory_global_dirty_log_stop (flags=1) at ../system/memory.c:3012
+#6  0x0000555555e84004 in ram_save_cleanup (opaque=0x555557328500 <ram_state>) at ../migration/ram.c:2383
+#7  0x0000555555c30c66 in qemu_savevm_state_cleanup () at ../migration/savevm.c:1699
+#8  0x0000555555c1494a in migrate_fd_cleanup (s=0x5555573fe000) at ../migration/migration.c:1409
+#9  0x0000555555c14b5e in migrate_fd_cleanup_bh (opaque=0x5555573fe000) at ../migration/migration.c:1456
+#10 0x0000555555c120bb in migration_bh_dispatch_bh (opaque=0x7ffe20002cf0) at ../migration/migration.c:284
+#11 0x0000555556186520 in aio_bh_call (bh=0x7ffe2011c7d0) at ../util/async.c:171
+#12 0x000055555618666e in aio_bh_poll (ctx=0x5555573fd770) at ../util/async.c:218
+#13 0x0000555556165595 in aio_dispatch (ctx=0x5555573fd770) at ../util/aio-posix.c:423
+#14 0x0000555556186b3d in aio_ctx_dispatch (source=0x5555573fd770, callback=0x0, user_data=0x0) at ../util/async.c:360
+#15 0x00007ffff6fd494b in g_main_dispatch (context=0x5555573fdcb0) at ../glib/gmain.c:3325
+#16 g_main_context_dispatch (context=0x5555573fdcb0) at ../glib/gmain.c:4043
+#17 0x0000555556188215 in glib_pollfds_poll () at ../util/main-loop.c:287
+#18 0x00005555561882a3 in os_host_main_loop_wait (timeout=942440) at ../util/main-loop.c:310
+#19 0x00005555561883d2 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+#20 0x0000555555be0f17 in qemu_main_loop () at ../system/runstate.c:826
+#21 0x0000555556093994 in qemu_default_main () at ../system/main.c:37
+#22 0x00005555560939d1 in main (argc=16, argv=0x7fffffffdc68) at ../system/main.c:48
+ */
+
 static struct vhost_log *vhost_log_alloc(uint64_t size, bool share)
 {
     Error *err = NULL;
@@ -367,6 +447,11 @@ static struct vhost_log *vhost_log_alloc(uint64_t size, bool share)
     return log;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|443| <<vhost_dev_log_resize>> struct vhost_log *log = vhost_log_get(dev->vhost_ops->backend_type,
+ *   - hw/virtio/vhost.c|2114| <<vhost_dev_start>> hdev->log = vhost_log_get(hdev->vhost_ops->backend_type,
+ */
 static struct vhost_log *vhost_log_get(VhostBackendType backend_type,
                                        uint64_t size, bool share)
 {
@@ -391,6 +476,13 @@ static struct vhost_log *vhost_log_get(VhostBackendType backend_type,
     return log;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|455| <<vhost_dev_log_resize>> vhost_log_put(dev, true);
+ *   - hw/virtio/vhost.c|1139| <<vhost_migration_log>> vhost_log_put(dev, false);
+ *   - hw/virtio/vhost.c|2168| <<vhost_dev_start>> vhost_log_put(hdev, false);
+ *   - hw/virtio/vhost.c|2225| <<vhost_dev_stop>> vhost_log_put(hdev, true);
+ */
 static void vhost_log_put(struct vhost_dev *dev, bool sync)
 {
     struct vhost_log *log = dev->log;
@@ -438,8 +530,19 @@ static bool vhost_dev_log_is_shared(struct vhost_dev *dev)
            dev->vhost_ops->vhost_requires_shm_log(dev);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|715| <<vhost_commit>> vhost_dev_log_resize(dev, log_size + VHOST_LOG_BUFFER);
+ *   - hw/virtio/vhost.c|723| <<vhost_commit>> vhost_dev_log_resize(dev, log_size);
+ *   - hw/virtio/vhost.c|1141| <<vhost_migration_log>> vhost_dev_log_resize(dev, vhost_get_log_size(dev));
+ */
 static inline void vhost_dev_log_resize(struct vhost_dev *dev, uint64_t size)
 {
+    /*
+     * called by:
+     *   - hw/virtio/vhost.c|443| <<vhost_dev_log_resize>> struct vhost_log *log = vhost_log_get(dev->vhost_ops->backend_type,
+     *   - hw/virtio/vhost.c|2114| <<vhost_dev_start>> hdev->log = vhost_log_get(hdev->vhost_ops->backend_type,
+     */
     struct vhost_log *log = vhost_log_get(dev->vhost_ops->backend_type,
                                           size, vhost_dev_log_is_shared(dev));
     uint64_t log_base = (uintptr_t)log->log;
@@ -447,11 +550,23 @@ static inline void vhost_dev_log_resize(struct vhost_dev *dev, uint64_t size)
 
     /* inform backend of log switching, this must be done before
        releasing the current log, to ensure no logging is lost */
+    /*
+     * vhost_kernel_set_log_base() -> VHOST_SET_LOG_BASE
+     * vhost_user_set_log_base()
+     * vhost_vdpa_set_log_base()
+     */
     r = dev->vhost_ops->vhost_set_log_base(dev, log_base, log);
     if (r < 0) {
         VHOST_OPS_DEBUG(r, "vhost_set_log_base failed");
     }
 
+    /*
+     * called by:
+     *   - hw/virtio/vhost.c|455| <<vhost_dev_log_resize>> vhost_log_put(dev, true);
+     *   - hw/virtio/vhost.c|1139| <<vhost_migration_log>> vhost_log_put(dev, false);
+     *   - hw/virtio/vhost.c|2168| <<vhost_dev_start>> vhost_log_put(hdev, false);
+     *   - hw/virtio/vhost.c|2225| <<vhost_dev_stop>> vhost_log_put(hdev, true);
+     */
     vhost_log_put(dev, true);
     dev->log = log;
     dev->log_size = size;
@@ -954,6 +1069,55 @@ void vhost_toggle_device_iotlb(VirtIODevice *vdev)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_kernel_set_vring_addr (dev=0x5555573f9c50, addr=0x7fffe3dfefd0) at ../hw/virtio/vhost-backend.c:110
+ * #1  0x0000555555b917d9 in vhost_virtqueue_set_addr (dev=0x5555573f9c50, vq=0x5555573f9f60, idx=1, enable_log=false) at ../hw/virtio/vhost.c:979
+ * #2  0x0000555555b92541 in vhost_virtqueue_start (dev=0x5555573f9c50, vdev=0x555558419170, vq=0x5555573f9f60, idx=3) at ../hw/virtio/vhost.c:1321
+ * #3  0x0000555555b949e8 in vhost_dev_start (hdev=0x5555573f9c50, vdev=0x555558419170, vrings=false) at ../hw/virtio/vhost.c:2097
+ * #4  0x0000555555a47c24 in vhost_net_start_one (net=0x5555573f9c50, dev=0x555558419170) at ../hw/net/vhost_net.c:280
+ * #5  0x0000555555a48278 in vhost_net_start (dev=0x555558419170, ncs=0x555558424898, data_queue_pairs=2, cvq=0) at ../hw/net/vhost_net.c:421
+ * #6  0x0000555555df0a1b in virtio_net_vhost_status (n=0x555558419170, status=15 '\017') at ../hw/net/virtio-net.c:311
+ * #7  0x0000555555df0d2b in virtio_net_set_status (vdev=0x555558419170, status=15 '\017') at ../hw/net/virtio-net.c:393
+ * #8  0x0000555555e33c08 in virtio_set_status (vdev=0x555558419170, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #9  0x0000555555b7b531 in virtio_pci_common_write (opaque=0x555558410cf0, addr=20, val=15, size=1) at ../hw/virtio/virtio-pci.c:1608
+ * #10 0x0000555555e63c32 in memory_region_write_accessor (mr=0x5555584118e0, addr=20, value=0x7fffe3dff3f8, size=1, shift=0, mask=255, attrs=...)
+ *                           at ../system/memory.c:497
+ * #11 0x0000555555e63f79 in access_with_adjusted_size (addr=20, value=0x7fffe3dff3f8, size=1, access_size_min=1, access_size_max=4,
+ *                           access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x5555584118e0, attrs=...) at ../system/memory.c:573
+ * #12 0x0000555555e674ae in memory_region_dispatch_write (mr=0x5555584118e0, addr=20, data=15, op=MO_8, attrs=...) at ../system/memory.c:1521
+ * #13 0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff7e39028 "\017", len=1, mr_addr=20,
+ *                           l=0x7fffe3dff4e0, mr=0x5555584118e0) at ../system/physmem.c:2803
+ * #14 0x0000555555e76cae in flatview_write_continue (fv=0x7ffe542b6060, addr=4261412884, attrs=..., ptr=0x7ffff7e39028, len=1, mr_addr=20,
+ *                           l=1, mr=0x5555584118e0) at ../system/physmem.c:2833
+ * #15 0x0000555555e76dd6 in flatview_write (fv=0x7ffe542b6060, addr=4261412884, attrs=..., buf=0x7ffff7e39028, len=1) at ../system/physmem.c:2864
+ * #16 0x0000555555e77250 in address_space_write (as=0x555557328200 <address_space_memory>, addr=4261412884, attrs=..., buf=0x7ffff7e39028, len=1)
+ *                           at ../system/physmem.c:2984
+ * #17 0x0000555555e772c8 in address_space_rw (as=0x555557328200 <address_space_memory>, addr=4261412884, attrs=..., buf=0x7ffff7e39028, len=1,
+ *                           is_write=true) at ../system/physmem.c:2994
+ * #18 0x0000555555ed4d63 in kvm_cpu_exec (cpu=0x555557748910) at ../accel/kvm/kvm-all.c:3075
+ * #19 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x555557748910) at ../accel/kvm/kvm-accel-ops.c:50
+ * #20 0x000055555616b040 in qemu_thread_start (args=0x555557752230) at ../util/qemu-thread-posix.c:541
+ * #21 0x00007ffff5c081da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #22 0x00007ffff3839e73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_set_vring_addr (dev=0x5555573f9c50, addr=0x7ffe253ff350) at ../hw/virtio/vhost-backend.c:110
+ * #1  0x0000555555b917d9 in vhost_virtqueue_set_addr (dev=0x5555573f9c50, vq=0x5555573f9f60, idx=1, enable_log=true) at ../hw/virtio/vhost.c:979
+ * #2  0x0000555555b91a76 in vhost_dev_set_log (dev=0x5555573f9c50, enable_log=true) at ../hw/virtio/vhost.c:1040
+ * #3  0x0000555555b91c5a in vhost_migration_log (listener=0x5555573f9c58, enable=true) at ../hw/virtio/vhost.c:1093
+ * #4  0x0000555555b91ccf in vhost_log_global_start (listener=0x5555573f9c58, errp=0x7ffe253ff628) at ../hw/virtio/vhost.c:1125
+ * #5  0x0000555555e6b859 in memory_global_dirty_log_do_start (errp=0x7ffe253ff628) at ../system/memory.c:2902
+ * #6  0x0000555555e6b98d in memory_global_dirty_log_start (flags=1, errp=0x7ffe253ff628) at ../system/memory.c:2941
+ * #7  0x0000555555e84d5d in ram_init_bitmaps (rs=0x7fffdc008420, errp=0x7ffe253ff628) at ../migration/ram.c:2782
+ * #8  0x0000555555e84e6e in ram_init_all (rsp=0x555557328500 <ram_state>, errp=0x7ffe253ff628) at ../migration/ram.c:2816
+ * #9  0x0000555555e854fc in ram_save_setup (f=0x555557671f70, opaque=0x555557328500 <ram_state>, errp=0x7ffe253ff628) at ../migration/ram.c:3010
+ * #10 0x0000555555c2fe16 in qemu_savevm_state_setup (f=0x555557671f70, errp=0x7ffe253ff628) at ../migration/savevm.c:1346
+ * #11 0x0000555555c19305 in migration_thread (opaque=0x5555573fe6a0) at ../migration/migration.c:3507
+ * #12 0x000055555616b040 in qemu_thread_start (args=0x555558115c40) at ../util/qemu-thread-posix.c:541
+ * #13 0x00007ffff5c081da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #14 0x00007ffff3839e73 in clone () from /lib/../lib64/libc.so.6
+ */
 static int vhost_virtqueue_set_addr(struct vhost_dev *dev,
                                     struct vhost_virtqueue *vq,
                                     unsigned idx, bool enable_log)
@@ -983,6 +1147,13 @@ static int vhost_virtqueue_set_addr(struct vhost_dev *dev,
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|1188| <<vhost_dev_set_log>> r = vhost_dev_set_features(dev, enable_log);
+ *   - hw/virtio/vhost.c|1230| <<vhost_dev_set_log>> vhost_dev_set_features(dev, dev->log_enabled);
+ *   - hw/virtio/vhost.c|2118| <<vhost_dev_prepare_inflight>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+ *   - hw/virtio/vhost.c|2200| <<vhost_dev_start>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+ */
 static int vhost_dev_set_features(struct vhost_dev *dev,
                                   bool enable_log)
 {
@@ -1016,6 +1187,11 @@ out:
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|1153| <<vhost_migration_log>> r = vhost_dev_set_log(dev, false);
+ *   - hw/virtio/vhost.c|1160| <<vhost_migration_log>> r = vhost_dev_set_log(dev, true);
+ */
 static int vhost_dev_set_log(struct vhost_dev *dev, bool enable_log)
 {
     int r, i, idx;
@@ -1068,6 +1244,11 @@ err_features:
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|1192| <<vhost_log_global_start>> r = vhost_migration_log(listener, true);
+ *   - hw/virtio/vhost.c|1203| <<vhost_log_global_stop>> r = vhost_migration_log(listener, false);
+ */
 static int vhost_migration_log(MemoryListener *listener, bool enable)
 {
     struct vhost_dev *dev = container_of(listener, struct vhost_dev,
@@ -1083,12 +1264,23 @@ static int vhost_migration_log(MemoryListener *listener, bool enable)
 
     r = 0;
     if (!enable) {
+        /*
+	 * called by:
+	 *   - hw/virtio/vhost.c|1153| <<vhost_migration_log>> r = vhost_dev_set_log(dev, false);
+	 *   - hw/virtio/vhost.c|1160| <<vhost_migration_log>> r = vhost_dev_set_log(dev, true);
+	 */
         r = vhost_dev_set_log(dev, false);
         if (r < 0) {
             goto check_dev_state;
         }
         vhost_log_put(dev, false);
     } else {
+        /*
+	 * called by:
+	 *   - hw/virtio/vhost.c|715| <<vhost_commit>> vhost_dev_log_resize(dev, log_size + VHOST_LOG_BUFFER);
+	 *   - hw/virtio/vhost.c|723| <<vhost_commit>> vhost_dev_log_resize(dev, log_size);
+	 *   - hw/virtio/vhost.c|1141| <<vhost_migration_log>> vhost_dev_log_resize(dev, vhost_get_log_size(dev));
+	 */
         vhost_dev_log_resize(dev, vhost_get_log_size(dev));
         r = vhost_dev_set_log(dev, true);
         if (r < 0) {
@@ -1097,6 +1289,25 @@ static int vhost_migration_log(MemoryListener *listener, bool enable)
     }
 
 check_dev_state:
+    /*
+     * 在以下设置vhost_dev->log_enabled;
+     *   - hw/virtio/vhost.c|1261| <<vhost_migration_log>> dev->log_enabled = enable;
+     *   - hw/virtio/vhost.c|1301| <<vhost_migration_log>> dev->log_enabled = enable;
+     *   - hw/virtio/vhost.c|1316| <<vhost_migration_log>> dev->log_enabled = false;
+     *   - hw/virtio/vhost.c|1817| <<vhost_dev_init>> hdev->log_enabled = false;
+     * 在以下使用vhost_dev->log_enabled;
+     *   - hw/virtio/vhost.c|203| <<vhost_sync_dirty_bitmap>> if (!dev->log_enabled || !dev->started) {
+     *   - hw/virtio/vhost.c|817| <<vhost_commit>> if (!dev->log_enabled) {
+     *   - hw/virtio/vhost.c|1240| <<vhost_dev_set_log>> vhost_virtqueue_set_addr(dev, dev->vqs + i, idx, dev->log_enabled);
+     *   - hw/virtio/vhost.c|1242| <<vhost_dev_set_log>> vhost_dev_set_features(dev, dev->log_enabled);
+     *   - hw/virtio/vhost.c|1257| <<vhost_migration_log>> if (enable == dev->log_enabled) {
+     *   - hw/virtio/vhost.c|1522| <<vhost_virtqueue_start>> r = vhost_virtqueue_set_addr(dev, vq, vhost_vq_index, dev->log_enabled);
+     *   - hw/virtio/vhost.c|2145| <<vhost_dev_prepare_inflight>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     *   - hw/virtio/vhost.c|2227| <<vhost_dev_start>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     *   - hw/virtio/vhost.c|2262| <<vhost_dev_start>> if (hdev->log_enabled) {
+     *   - hw/virtio/virtio-hmp-cmds.c|171| <<hmp_virtio_status>> s->vhost_dev->log_enabled ? "true" : "false");
+     *   - hw/virtio/virtio-qmp.c|791| <<qmp_x_query_virtio_status>> status->vhost_dev->log_enabled = hdev->log_enabled;
+     */
     dev->log_enabled = enable;
     /*
      * vhost-user-* devices could change their state during log
@@ -1248,6 +1459,11 @@ out:
     return ret;
 }
 
+/*
+ * called by:
+ *   - hw/net/vhost_net.c|766| <<vhost_net_virtqueue_restart>> r = vhost_virtqueue_start(&net->dev,
+ *   - hw/virtio/vhost.c|2252| <<vhost_dev_start>> r = vhost_virtqueue_start(hdev,
+ */
 int vhost_virtqueue_start(struct vhost_dev *dev,
                           struct VirtIODevice *vdev,
                           struct vhost_virtqueue *vq,
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index f12c4aa81..3f4ec09d7 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -2719,6 +2719,25 @@ void virtio_notify(VirtIODevice *vdev, VirtQueue *vq)
     virtio_irq(vq);
 }
 
+/*
+ * called by:
+ *   - hw/block/vhost-user-blk.c|106| <<vhost_user_blk_sync_config>> virtio_notify_config(vdev);
+ *   - hw/block/virtio-blk.c|1360| <<virtio_resize_cb>> virtio_notify_config(vdev);
+ *   - hw/char/virtio-serial-bus.c|1004| <<virtser_port_device_plug>> virtio_notify_config(VIRTIO_DEVICE(hotplug_dev));
+ *   - hw/display/virtio-gpu-base.c|86| <<virtio_gpu_notify_event>> virtio_notify_config(&g->parent_obj);
+ *   - hw/input/virtio-input.c|183| <<virtio_input_set_config>> virtio_notify_config(vdev);
+ *   - hw/net/virtio-net.c|231| <<virtio_net_announce_notify>> virtio_notify_config(vdev);
+ *   - hw/net/virtio-net.c|454| <<virtio_net_set_link_status>> virtio_notify_config(vdev);
+ *   - hw/virtio/vhost-user-base.c|165| <<vub_config_notifier>> virtio_notify_config(dev->vdev);
+ *   - hw/virtio/vhost-user-vsock.c|48| <<vuv_handle_config_change>> virtio_notify_config(dev->vdev);
+ *   - hw/virtio/virtio-balloon.c|610| <<virtio_balloon_free_page_start>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-balloon.c|630| <<virtio_balloon_free_page_stop>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-balloon.c|643| <<virtio_balloon_free_page_done>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-balloon.c|813| <<virtio_balloon_to_target>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio-mem.c|1598| <<virtio_mem_set_requested_size>> virtio_notify_config(VIRTIO_DEVICE(vmem));
+ *   - hw/virtio/virtio.c|3723| <<virtio_config_guest_notifier_read>> virtio_notify_config(vdev);
+ *   - hw/virtio/virtio.c|3917| <<virtio_error>> virtio_notify_config(vdev);
+ */
 void virtio_notify_config(VirtIODevice *vdev)
 {
     if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK))
diff --git a/include/exec/ramblock.h b/include/exec/ramblock.h
index 0babd105c..9a6debdd3 100644
--- a/include/exec/ramblock.h
+++ b/include/exec/ramblock.h
@@ -24,6 +24,62 @@
 #include "qemu/rcu.h"
 #include "exec/ramlist.h"
 
+/*
+ * (gdb) p *(RAMBlock *)0x555557712270
+ * $4 = {rcu = {next = 0x0, func = 0x0}, mr = 0x5555575482e0, host = 0x7ffee3e00000 "S\377", colo_cache = 0x0, offset = 0, used_length = 4294967296, max_length = 4294967296,
+ *   resized = 0x0, flags = 16, idstr = "pc.ram", '\000' <repeats 249 times>, next = {le_next = 0x55555801c100, le_prev = 0x555557334880 <ram_list+64>},
+ *   ramblock_notifiers = {lh_first = 0x0}, fd = -1, fd_offset = 0, guest_memfd = -1, page_size = 4096, bmap = 0x0, file_bmap = 0x0, bitmap_offset = 0, pages_offset = 0,
+ *   receivedmap = 0x0, clear_bmap = 0x0, clear_bmap_shift = 0 '\000', postcopy_length = 0}
+ *
+ * (gdb) p *(RAMBlock *)0x55555801c100
+ * $5 = {rcu = {next = 0x0, func = 0x0}, mr = 0x55555800a0d0, host = 0x7ffee2c00000 "", colo_cache = 0x0, offset = 4295491584, used_length = 16777216, max_length = 16777216,
+ *   resized = 0x0, flags = 16, idstr = "0000:00:02.0/vga.vram", '\000' <repeats 234 times>, next = {le_next = 0x555557b2c820, le_prev = 0x5555577123c0},
+ *   ramblock_notifiers = {lh_first = 0x0}, fd = -1, fd_offset = 0, guest_memfd = -1, page_size = 4096, bmap = 0x0, file_bmap = 0x0, bitmap_offset = 0, pages_offset = 0,
+ *   receivedmap = 0x0, clear_bmap = 0x0, clear_bmap_shift = 0 '\000', postcopy_length = 0}
+ *
+ * (gdb) p *(RAMBlock *)0x555557b2c820
+ * $6 = {rcu = {next = 0x0, func = 0x0}, mr = 0x55555742c000, host = 0x7fffe8600000 "FACS@", colo_cache = 0x0, offset = 4312793088, used_length = 131072,
+ *   max_length = 2097152, resized = 0x5555559402c4 <fw_cfg_resized>, flags = 20, idstr = "/rom@etc/acpi/tables", '\000' <repeats 235 times>, next = {
+ *     le_next = 0x555557b19940, le_prev = 0x55555801c250}, ramblock_notifiers = {lh_first = 0x0}, fd = -1, fd_offset = 0, guest_memfd = -1, page_size = 4096, bmap = 0x0,
+ *   file_bmap = 0x0, bitmap_offset = 0, pages_offset = 0, receivedmap = 0x0, clear_bmap = 0x0, clear_bmap_shift = 0 '\000', postcopy_length = 0}
+ *
+ * (gdb) p *(RAMBlock *)0x555557b19940
+ * $7 = {rcu = {next = 0x0, func = 0x0}, mr = 0x5555576793a0, host = 0x7fffe9000000 "", colo_cache = 0x0, offset = 4294967296, used_length = 262144, max_length = 262144,
+ *   resized = 0x0, flags = 16, idstr = "pc.bios", '\000' <repeats 248 times>, next = {le_next = 0x5555585cf3a0, le_prev = 0x555557b2c970}, ramblock_notifiers = {
+ *     lh_first = 0x0}, fd = -1, fd_offset = 0, guest_memfd = -1, page_size = 4096, bmap = 0x0, file_bmap = 0x0, bitmap_offset = 0, pages_offset = 0, receivedmap = 0x0,
+ *   clear_bmap = 0x0, clear_bmap_shift = 0 '\000', postcopy_length = 0}
+ *
+ * (gdb) p *(RAMBlock *)0x5555585cf3a0
+ * $8 = {rcu = {next = 0x0, func = 0x0}, mr = 0x555558446d50, host = 0x7fffe8a00000 "U\252\207", <incomplete sequence \351\242>, colo_cache = 0x0, offset = 4312530944,
+ *   used_length = 262144, max_length = 262144, resized = 0x0, flags = 16, idstr = "0000:00:03.0/virtio-net-pci.rom", '\000' <repeats 224 times>, next = {
+ *     le_next = 0x555557680e90, le_prev = 0x555557b19a90}, ramblock_notifiers = {lh_first = 0x0}, fd = -1, fd_offset = 0, guest_memfd = -1, page_size = 4096, bmap = 0x0,
+ *   file_bmap = 0x0, bitmap_offset = 0, pages_offset = 0, receivedmap = 0x0, clear_bmap = 0x0, clear_bmap_shift = 0 '\000', postcopy_length = 0}
+ *
+ * (gdb) p *(RAMBlock *)0x555557680e90
+ * $9 = {rcu = {next = 0x0, func = 0x0}, mr = 0x555557565000, host = 0x7fffe8e00000 "", colo_cache = 0x0, offset = 4295229440, used_length = 131072, max_length = 131072,
+ *   resized = 0x0, flags = 16, idstr = "pc.rom", '\000' <repeats 249 times>, next = {le_next = 0x5555581e99c0, le_prev = 0x5555585cf4f0}, ramblock_notifiers = {
+ *     lh_first = 0x0}, fd = -1, fd_offset = 0, guest_memfd = -1, page_size = 4096, bmap = 0x0, file_bmap = 0x0, bitmap_offset = 0, pages_offset = 0, receivedmap = 0x0,
+ *   clear_bmap = 0x0, clear_bmap_shift = 0 '\000', postcopy_length = 0}
+ *
+ * (gdb) p *(RAMBlock *)0x5555581e99c0
+ * $10 = {rcu = {next = 0x0, func = 0x0}, mr = 0x555558009f20, host = 0x7fffe8c00000 "U\252M\351\220U\211", colo_cache = 0x0, offset = 4312268800, used_length = 65536,
+ *   max_length = 65536, resized = 0x0, flags = 16, idstr = "0000:00:02.0/vga.rom", '\000' <repeats 235 times>, next = {le_next = 0x555557b2c3f0, le_prev = 0x555557680fe0},
+ *   ramblock_notifiers = {lh_first = 0x0}, fd = -1, fd_offset = 0, guest_memfd = -1, page_size = 4096, bmap = 0x0, file_bmap = 0x0, bitmap_offset = 0, pages_offset = 0,
+ *   receivedmap = 0x0, clear_bmap = 0x0, clear_bmap_shift = 0 '\000', postcopy_length = 0}
+ *
+ * (gdb) p *(RAMBlock *)0x555557b2c3f0
+ * $11 = {rcu = {next = 0x0, func = 0x0}, mr = 0x5555578920d0, host = 0x7fffe8400000 "\001", colo_cache = 0x0, offset = 4314890240, used_length = 4096, max_length = 65536,
+ *   resized = 0x5555559402c4 <fw_cfg_resized>, flags = 20, idstr = "/rom@etc/table-loader", '\000' <repeats 234 times>, next = {le_next = 0x55555780b600,
+ *     le_prev = 0x5555581e9b10}, ramblock_notifiers = {lh_first = 0x0}, fd = -1, fd_offset = 0, guest_memfd = -1, page_size = 4096, bmap = 0x0, file_bmap = 0x0,
+ *   bitmap_offset = 0, pages_offset = 0, receivedmap = 0x0, clear_bmap = 0x0, clear_bmap_shift = 0 '\000', postcopy_length = 0}
+ *
+ * (gdb) p *(RAMBlock *)0x55555780b600
+ * $12 = {rcu = {next = 0x0, func = 0x0}, mr = 0x555557b67eb0, host = 0x7fffe8200000 "RSD PTR ", colo_cache = 0x0, offset = 4315152384, used_length = 4096,
+ *   max_length = 4096, resized = 0x5555559402c4 <fw_cfg_resized>, flags = 20, idstr = "/rom@etc/acpi/rsdp", '\000' <repeats 237 times>, next = {le_next = 0x0,
+ *     le_prev = 0x555557b2c540}, ramblock_notifiers = {lh_first = 0x0}, fd = -1, fd_offset = 0, guest_memfd = -1, page_size = 4096, bmap = 0x0, file_bmap = 0x0,
+ *   bitmap_offset = 0, pages_offset = 0, receivedmap = 0x0, clear_bmap = 0x0, clear_bmap_shift = 0 '\000', postcopy_length = 0}
+ */
+
 struct RAMBlock {
     struct rcu_head rcu;
     struct MemoryRegion *mr;
diff --git a/include/hw/pci/pci_device.h b/include/hw/pci/pci_device.h
index 8eaf0d58b..1c286ab7f 100644
--- a/include/hw/pci/pci_device.h
+++ b/include/hw/pci/pci_device.h
@@ -156,6 +156,16 @@ struct PCIDevice {
     /* MSI-X notifiers */
     MSIVectorUseNotifier msix_vector_use_notifier;
     MSIVectorReleaseNotifier msix_vector_release_notifier;
+    /*
+     * 在以下使用PCIDevice->msix_vector_poll_notifier:
+     *   - hw/pci/msix.c|251| <<msix_pba_mmio_read>> if (dev->msix_vector_poll_notifier) {
+     *   - hw/pci/msix.c|254| <<msix_pba_mmio_read>> dev->msix_vector_poll_notifier(dev, vector_start, vector_end);
+     *   - hw/pci/msix.c|629| <<msix_set_vector_notifiers>> dev->msix_vector_poll_notifier = poll_notifier;
+     *   - hw/pci/msix.c|640| <<msix_set_vector_notifiers>> if (dev->msix_vector_poll_notifier) {
+     *   - hw/pci/msix.c|641| <<msix_set_vector_notifiers>> dev->msix_vector_poll_notifier(dev, 0, dev->msix_entries_nr);
+     *   - hw/pci/msix.c|651| <<msix_set_vector_notifiers>> dev->msix_vector_poll_notifier = NULL;
+     *   - hw/pci/msix.c|670| <<msix_unset_vector_notifiers>> dev->msix_vector_poll_notifier = NULL;
+     */
     MSIVectorPollNotifier msix_vector_poll_notifier;
 
     /* SPDM */
diff --git a/include/hw/virtio/vhost.h b/include/hw/virtio/vhost.h
index 461c168c3..ff4f012bd 100644
--- a/include/hw/virtio/vhost.h
+++ b/include/hw/virtio/vhost.h
@@ -122,6 +122,25 @@ struct vhost_dev {
     uint64_t backend_cap;
     /* @started: is the vhost device started? */
     bool started;
+    /*
+     * 在以下设置vhost_dev->log_enabled;
+     *   - hw/virtio/vhost.c|1261| <<vhost_migration_log>> dev->log_enabled = enable;
+     *   - hw/virtio/vhost.c|1301| <<vhost_migration_log>> dev->log_enabled = enable;
+     *   - hw/virtio/vhost.c|1316| <<vhost_migration_log>> dev->log_enabled = false;
+     *   - hw/virtio/vhost.c|1817| <<vhost_dev_init>> hdev->log_enabled = false;
+     * 在以下使用vhost_dev->log_enabled;
+     *   - hw/virtio/vhost.c|203| <<vhost_sync_dirty_bitmap>> if (!dev->log_enabled || !dev->started) {
+     *   - hw/virtio/vhost.c|817| <<vhost_commit>> if (!dev->log_enabled) {
+     *   - hw/virtio/vhost.c|1240| <<vhost_dev_set_log>> vhost_virtqueue_set_addr(dev, dev->vqs + i, idx, dev->log_enabled);
+     *   - hw/virtio/vhost.c|1242| <<vhost_dev_set_log>> vhost_dev_set_features(dev, dev->log_enabled);
+     *   - hw/virtio/vhost.c|1257| <<vhost_migration_log>> if (enable == dev->log_enabled) {
+     *   - hw/virtio/vhost.c|1522| <<vhost_virtqueue_start>> r = vhost_virtqueue_set_addr(dev, vq, vhost_vq_index, dev->log_enabled);
+     *   - hw/virtio/vhost.c|2145| <<vhost_dev_prepare_inflight>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     *   - hw/virtio/vhost.c|2227| <<vhost_dev_start>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     *   - hw/virtio/vhost.c|2262| <<vhost_dev_start>> if (hdev->log_enabled) {
+     *   - hw/virtio/virtio-hmp-cmds.c|171| <<hmp_virtio_status>> s->vhost_dev->log_enabled ? "true" : "false");
+     *   - hw/virtio/virtio-qmp.c|791| <<qmp_x_query_virtio_status>> status->vhost_dev->log_enabled = hdev->log_enabled;
+     */
     bool log_enabled;
     uint64_t log_size;
     Error *migration_blocker;
diff --git a/migration/migration.c b/migration/migration.c
index 8c5bd0a75..1e0b8c5ad 100644
--- a/migration/migration.c
+++ b/migration/migration.c
@@ -783,6 +783,23 @@ static void process_incoming_migration_bh(void *opaque)
     migration_incoming_state_destroy();
 }
 
+/*
+ * Target QEMU.
+ * (gdb) bt
+ * #0  0x00007ffff52bf413 in __memmove_avx_unaligned_erms_rtm () from /lib64/libc.so.6
+ * #1  0x0000555555f59607 in qemu_get_buffer (f=0x555557804800, buf=0x7ffee8000000 "\002", size=4096) at ../migration/qemu-file.c:644
+ * #2  0x0000555555e8adc4 in ram_load_precopy (f=0x555557804800) at ../migration/ram.c:4228
+ * #3  0x0000555555e8af76 in ram_load (f=0x555557804800, opaque=0x555557334c60 <ram_state>, version_id=4) at ../migration/ram.c:4307
+ * #4  0x0000555555c2ee96 in vmstate_load (f=0x555557804800, se=0x555557711b10) at ../migration/savevm.c:937
+ * #5  0x0000555555c32c88 in qemu_loadvm_section_part_end (f=0x555557804800, type=2 '\002') at ../migration/savevm.c:2672
+ * #6  0x0000555555c334b8 in qemu_loadvm_state_main (f=0x555557804800, mis=0x5555574093d0) at ../migration/savevm.c:2880
+ * #7  0x0000555555c33652 in qemu_loadvm_state (f=0x555557804800) at ../migration/savevm.c:2957
+ * #8  0x0000555555c13760 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:803
+ * #9  0x0000555556192d6f in coroutine_trampoline (i0=1466557760, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #10 0x00007ffff5233120 in ?? () from /lib64/libc.so.6
+ * #11 0x00007fffffffc7d0 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ */
 static void coroutine_fn
 process_incoming_migration_co(void *opaque)
 {
@@ -3213,6 +3230,10 @@ typedef enum {
  * Return true if continue to the next iteration directly, false
  * otherwise.
  */
+/*
+ * called by:
+ *   migration/migration.c|3513| <<migration_thread>> MigIterateState iter_state = migration_iteration_run(s);
+ */
 static MigIterateState migration_iteration_run(MigrationState *s)
 {
     uint64_t must_precopy, can_postcopy, pending_size;
diff --git a/migration/migration.h b/migration/migration.h
index 3857905c0..1b1743d1b 100644
--- a/migration/migration.h
+++ b/migration/migration.h
@@ -470,6 +470,13 @@ struct MigrationState {
      */
     bool switchover_acked;
     /* Is this a rdma migration */
+    /*
+     * 在以下使用MigrationState->rdma_migration:
+     *   - migration/migration.c|1703| <<migrate_init>> s->rdma_migration = false;
+     *   - migration/options.c|367| <<migrate_rdma>> return s->rdma_migration;
+     *   - migration/rdma.c|4101| <<rdma_start_incoming_migration>> s->rdma_migration = true;
+     *   - migration/rdma.c|4176| <<rdma_start_outgoing_migration>> s->rdma_migration = true;
+     */
     bool rdma_migration;
 };
 
diff --git a/migration/multifd-nocomp.c b/migration/multifd-nocomp.c
index 55191152f..46daea58d 100644
--- a/migration/multifd-nocomp.c
+++ b/migration/multifd-nocomp.c
@@ -298,11 +298,31 @@ static inline bool multifd_queue_full(MultiFDPages_t *pages)
     return pages->num == multifd_ram_page_count();
 }
 
+/*
+ * called by:
+ *   - migration/multifd-nocomp.c|322| <<multifd_queue_page>> multifd_enqueue(pages, offset);
+ *   - migration/multifd-nocomp.c|342| <<multifd_queue_page>> multifd_enqueue(pages, offset);
+ */
 static inline void multifd_enqueue(MultiFDPages_t *pages, ram_addr_t offset)
 {
+    /*
+     * 76 typedef struct {
+     * 77     // number of used pages
+     * 78     uint32_t num;
+     * 79     // number of normal pages
+     * 80     uint32_t normal_num;
+     * 81     RAMBlock *block;
+     * 82     // offset of each page
+     * 83     ram_addr_t offset[];
+     * 84 } MultiFDPages_t;
+     */
     pages->offset[pages->num++] = offset;
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|1384| <<ram_save_multifd_page>> if (!multifd_queue_page(block, offset)) {
+ */
 /* Returns true if enqueue successful, false otherwise */
 bool multifd_queue_page(RAMBlock *block, ram_addr_t offset)
 {
diff --git a/migration/options.c b/migration/options.c
index ad8d6989a..2a29dbefe 100644
--- a/migration/options.c
+++ b/migration/options.c
@@ -304,6 +304,32 @@ bool migrate_rdma_pin_all(void)
     return s->capabilities[MIGRATION_CAPABILITY_RDMA_PIN_ALL];
 }
 
+/*
+ * 默认:
+ * (qemu) info migrate_capabilities
+ * xbzrle: off
+ * rdma-pin-all: off
+ * auto-converge: off
+ * zero-blocks: off
+ * events: off
+ * postcopy-ram: off
+ * x-colo: off
+ * release-ram: off
+ * return-path: off
+ * pause-before-switchover: off
+ * multifd: off
+ * dirty-bitmaps: off
+ * postcopy-blocktime: off
+ * late-block-activate: off
+ * x-ignore-shared: off
+ * validate-uuid: off
+ * background-snapshot: off
+ * zero-copy-send: off
+ * postcopy-preempt: off
+ * switchover-ack: off
+ * dirty-limit: off
+ * mapped-ram: off
+ */
 bool migrate_release_ram(void)
 {
     MigrationState *s = migrate_get_current();
@@ -364,6 +390,13 @@ bool migrate_rdma(void)
 {
     MigrationState *s = migrate_get_current();
 
+    /*
+     * 在以下使用MigrationState->rdma_migration:
+     *   - migration/migration.c|1703| <<migrate_init>> s->rdma_migration = false;
+     *   - migration/options.c|367| <<migrate_rdma>> return s->rdma_migration;
+     *   - migration/rdma.c|4101| <<rdma_start_incoming_migration>> s->rdma_migration = true;
+     *   - migration/rdma.c|4176| <<rdma_start_outgoing_migration>> s->rdma_migration = true;
+     */
     return s->rdma_migration;
 }
 
diff --git a/migration/qemu-file.c b/migration/qemu-file.c
index b6d2f588b..d01dcfa94 100644
--- a/migration/qemu-file.c
+++ b/migration/qemu-file.c
@@ -421,6 +421,10 @@ static void add_buf_to_iovec(QEMUFile *f, size_t len)
     }
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|1306| <<save_normal_page>> qemu_put_buffer_async(file, buf, TARGET_PAGE_SIZE,
+ */
 void qemu_put_buffer_async(QEMUFile *f, const uint8_t *buf, size_t size,
                            bool may_free)
 {
@@ -431,6 +435,55 @@ void qemu_put_buffer_async(QEMUFile *f, const uint8_t *buf, size_t size,
     add_to_iovec(f, buf, size, may_free);
 }
 
+/*
+ * called by:
+ *   - hw/display/virtio-gpu.c|1244| <<virtio_gpu_save>> qemu_put_buffer(f, (void *)pixman_image_get_data(res->image),
+ *   - hw/intc/s390_flic_kvm.c|446| <<kvm_flic_save>> qemu_put_buffer(f, (uint8_t *) buf,
+ *   - hw/pci/msix.c|486| <<msix_save>> qemu_put_buffer(f, dev->msix_table, n * PCI_MSIX_ENTRY_SIZE);
+ *   - hw/pci/msix.c|487| <<msix_save>> qemu_put_buffer(f, dev->msix_pba, DIV_ROUND_UP(n, 8));
+ *   - hw/pci/pci.c|692| <<put_pci_config_device>> qemu_put_buffer(f, *v, size);
+ *   - hw/pci/shpc.c|766| <<shpc_save>> qemu_put_buffer(f, d->shpc->config, SHPC_SIZEOF(d));
+ *   - hw/ppc/spapr.c|2175| <<htab_save_chunk>> qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),
+ *   - hw/s390x/s390-skeys.c|375| <<s390_storage_keys_save>> qemu_put_buffer(f, buf, cur_pages);
+ *   - hw/scsi/mptsas.c|1221| <<mptsas_save_request>> qemu_put_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));
+ *   - hw/scsi/scsi-bus.c|1828| <<put_scsi_req>> qemu_put_buffer(f, req->cmd.buf, sizeof(req->cmd.buf));
+ *   - hw/scsi/scsi-disk.c|166| <<scsi_disk_save_request>> qemu_put_buffer(f, r->iov.iov_base, r->iov.iov_len);
+ *   - hw/scsi/scsi-disk.c|170| <<scsi_disk_save_request>> qemu_put_buffer(f, r->iov.iov_base, r->iov.iov_len);
+ *   - hw/scsi/scsi-generic.c|51| <<scsi_generic_save_request>> qemu_put_buffer(f, r->buf, r->req.cmd.xfer);
+ *   - hw/usb/redirect.c|2254| <<usbredir_put_parser>> qemu_put_buffer(f, data, len);
+ *   - hw/usb/redirect.c|2320| <<usbredir_put_bufpq>> qemu_put_buffer(f, bufp->data + bufp->offset, len);
+ *   - hw/vfio/migration.c|391| <<vfio_save_block>> qemu_put_buffer(f, migration->data_buffer, data_size);
+ *   - hw/virtio/vhost.c|2520| <<vhost_save_backend_state>> qemu_put_buffer(f, transfer_buf, read_ret);
+ *   - hw/virtio/virtio.c|2181| <<qemu_put_virtqueue_element>> qemu_put_buffer(f, (uint8_t *)&data, sizeof(VirtQueueElementOld));
+ *   - hw/virtio/virtio.c|3042| <<virtio_save>> qemu_put_buffer(f, vdev->config, vdev->config_len);
+ *   - migration/block-dirty-bitmap.c|461| <<send_bitmap_bits>> qemu_put_buffer(f, buf, buf_size);
+ *   - migration/colo.c|485| <<colo_do_checkpoint_transaction>> qemu_put_buffer(s->to_dst_file, bioc->data, bioc->usage);
+ *   - migration/migration.c|455| <<migrate_send_rp_message>> qemu_put_buffer(mis->to_src_file, data, len);
+ *   - migration/migration.c|2869| <<bg_migration_completion>> qemu_put_buffer(s->to_dst_file, s->bioc->data, s->bioc->usage);
+ *   - migration/qemu-file.c|807| <<qemu_put_counted_string>> qemu_put_buffer(f, (const uint8_t *)str, len);
+ *   - migration/ram.c|327| <<ramblock_recv_bitmap_send>> qemu_put_buffer(file, (const uint8_t *)le_bitmap, size);
+ *   - migration/ram.c|534| <<save_page_header>> qemu_put_buffer(f, (uint8_t *)block->idstr, len);
+ *   - migration/ram.c|699| <<save_xbzrle_page>> qemu_put_buffer(file, XBZRLE.encoded_buf, encoded_len);
+ *   - migration/ram.c|1261| <<save_normal_page>> qemu_put_buffer(file, buf, TARGET_PAGE_SIZE);
+ *   - migration/ram.c|2995| <<mapped_ram_setup_ramblock>> qemu_put_buffer(file, (uint8_t *) header, header_size);
+ *   - migration/ram.c|3072| <<ram_save_setup>> qemu_put_buffer(f, (uint8_t *)block->idstr, strlen(block->idstr));
+ *   - migration/savevm.c|413| <<put_capability>> qemu_put_buffer(f, (uint8_t *)capability_str, len);
+ *   - migration/savevm.c|975| <<save_section_header>> qemu_put_buffer(f, (uint8_t *)se->idstr, len);
+ *   - migration/savevm.c|1051| <<qemu_savevm_command_send>> qemu_put_buffer(f, data, len);
+ *   - migration/savevm.c|1104| <<qemu_savevm_send_packaged>> qemu_put_buffer(f, buf, len);
+ *   - migration/savevm.c|1574| <<qemu_savevm_state_complete_precopy_non_iterable>> qemu_put_buffer(f, (uint8_t *)json_writer_get(vmdesc), vmdesc_len);
+ *   - migration/vmstate-types.c|464| <<put_buffer>> qemu_put_buffer(f, v, size);
+ *   - migration/vmstate-types.c|500| <<put_unused_buffer>> qemu_put_buffer(f, buf, block_len);
+ *   - migration/vmstate.c|550| <<vmstate_subsection_save>> qemu_put_buffer(f, (uint8_t *)vmsdsub->name, len);
+ *   - net/slirp.c|392| <<net_slirp_stream_write>> qemu_put_buffer(f, buf, size);
+ *   - target/ppc/kvm.c|2730| <<kvmppc_save_htab>> qemu_put_buffer(f, (void *)(head + 1),
+ *   - tests/unit/test-vmstate.c|81| <<save_buffer>> qemu_put_buffer(fsave, buf, buf_size);
+ *   - tests/unit/test-vmstate.c|113| <<load_vmstate_one>> qemu_put_buffer(f, wire, size);
+ *   - tests/unit/test-vmstate.c|768| <<test_load_q>> qemu_put_buffer(fsave, wire_q, sizeof(wire_q));
+ *   - tests/unit/test-vmstate.c|1124| <<test_gtree_load_domain>> qemu_put_buffer(fsave, first_domain_dump, sizeof(first_domain_dump));
+ *   - tests/unit/test-vmstate.c|1239| <<test_gtree_load_iommu>> qemu_put_buffer(fsave, iommu_dump, sizeof(iommu_dump));
+ *   - tests/unit/test-vmstate.c|1374| <<test_load_qlist>> qemu_put_buffer(fsave, qlist_dump, sizeof(qlist_dump));
+ */
 void qemu_put_buffer(QEMUFile *f, const uint8_t *buf, size_t size)
 {
     size_t l;
@@ -628,6 +681,63 @@ size_t coroutine_mixed_fn qemu_peek_buffer(QEMUFile *f, uint8_t **buf, size_t si
  * return as many as it managed to read (assuming blocking fd's which
  * all current QEMUFile are)
  */
+/*
+ * called by:
+ *   - hw/display/virtio-gpu.c|1333| <<virtio_gpu_load>> qemu_get_buffer(f, (void *)pixman_image_get_data(res->image),
+ *   - hw/intc/s390_flic_kvm.c|487| <<kvm_flic_load>> if (qemu_get_buffer(f, (uint8_t *) buf, len) != len) {
+ *   - hw/pci/msix.c|501| <<msix_load>> qemu_get_buffer(f, dev->msix_table, n * PCI_MSIX_ENTRY_SIZE);
+ *   - hw/pci/msix.c|502| <<msix_load>> qemu_get_buffer(f, dev->msix_pba, DIV_ROUND_UP(n, 8));
+ *   - hw/pci/pci.c|659| <<get_pci_config_device>> qemu_get_buffer(f, config, size);
+ *   - hw/pci/shpc.c|775| <<shpc_load>> int ret = qemu_get_buffer(f, d->shpc->config, SHPC_SIZEOF(d));
+ *   - hw/ppc/spapr.c|2452| <<htab_load>> qemu_get_buffer(f, HPTE(spapr->htab, index),
+ *   - hw/s390x/s390-skeys.c|433| <<s390_storage_keys_load>> qemu_get_buffer(f, buf, cur_count);
+ *   - hw/s390x/s390-stattrib.c|138| <<cmma_load>> qemu_get_buffer(f, buf, count);
+ *   - hw/scsi/mptsas.c|1238| <<mptsas_load_request>> qemu_get_buffer(f, (unsigned char *)&req->scsi_io, sizeof(req->scsi_io));
+ *   - hw/scsi/scsi-bus.c|1862| <<get_scsi_requests>> qemu_get_buffer(f, buf, sizeof(buf));
+ *   - hw/scsi/scsi-disk.c|194| <<scsi_disk_load_request>> qemu_get_buffer(f, r->iov.iov_base, r->iov.iov_len);
+ *   - hw/scsi/scsi-disk.c|200| <<scsi_disk_load_request>> qemu_get_buffer(f, r->iov.iov_base, r->iov.iov_len);
+ *   - hw/scsi/scsi-generic.c|62| <<scsi_generic_load_request>> qemu_get_buffer(f, r->buf, r->req.cmd.xfer);
+ *   - hw/usb/redirect.c|2288| <<usbredir_get_parser>> qemu_get_buffer(f, data, len);
+ *   - hw/usb/redirect.c|2348| <<usbredir_get_bufpq>> qemu_get_buffer(f, bufp->data, bufp->len);
+ *   - hw/virtio/vhost.c|2607| <<vhost_load_backend_state>> if (qemu_get_buffer(f, transfer_buf, this_chunk_size) <
+ *   - hw/virtio/virtio.c|2106| <<qemu_get_virtqueue_element>> qemu_get_buffer(f, (uint8_t *)&data, sizeof(VirtQueueElementOld));
+ *   - hw/virtio/virtio.c|3270| <<virtio_load>> qemu_get_buffer(f, vdev->config, MIN(config_len, vdev->config_len));
+ *   - migration/block-dirty-bitmap.c|1015| <<dirty_bitmap_load_bits>> ret = qemu_get_buffer(f, buf, buf_size);
+ *   - migration/colo.c|710| <<colo_incoming_process_checkpoint>> total_size = qemu_get_buffer(mis->from_src_file, bioc->data, value);
+ *   - migration/migration.c|2320| <<source_return_path_thread>> res = qemu_get_buffer(rp, buf, header_len);
+ *   - migration/qemu-file.c|740| <<qemu_get_buffer_in_place>> return qemu_get_buffer(f, *buf, size);
+ *   - migration/qemu-file.c|843| <<qemu_get_counted_string>> size_t res = qemu_get_buffer(f, (uint8_t *)buf, len);
+ *   - migration/ram.c|3097| <<mapped_ram_read_header>> ret = qemu_get_buffer(file, (uint8_t *)header, header_size);
+ *   - migration/ram.c|3546| <<ram_block_from_stream>> qemu_get_buffer(f, (uint8_t *)id, len);
+ *   - migration/ram.c|3920| <<ram_load_postcopy>> qemu_get_buffer(f, page_buffer, TARGET_PAGE_SIZE);
+ *   - migration/ram.c|4236| <<parse_ramblocks>> qemu_get_buffer(f, (uint8_t *)id, len);
+ *   - migration/ram.c|4375| <<ram_load_precopy>> qemu_get_buffer(f, host, TARGET_PAGE_SIZE);
+ *   - migration/ram.c|4548| <<ram_dirty_bitmap_reload>> size = qemu_get_buffer(file, (uint8_t *)le_bitmap, local_size);
+ *   - migration/savevm.c|392| <<get_capability>> qemu_get_buffer(f, (uint8_t *)capability_str, len);
+ *   - migration/savevm.c|2316| <<loadvm_handle_cmd_packaged>> ret = qemu_get_buffer(mis->from_src_file,
+ *   - migration/savevm.c|3014| <<qemu_loadvm_state>> qemu_get_buffer(f, buf, read_chunk);
+ *   - migration/vmstate-types.c|456| <<get_buffer>> qemu_get_buffer(f, v, size);
+ *   - migration/vmstate-types.c|486| <<get_unused_buffer>> qemu_get_buffer(f, buf, block_len);
+ *   - net/slirp.c|384| <<net_slirp_stream_read>> return qemu_get_buffer(f, buf, size);
+ *   - target/ppc/kvm.c|2756| <<kvmppc_load_htab_chunk>> qemu_get_buffer(f, (void *)(buf + 1), HASH_PTE_SIZE_64 * n_valid);
+ *   - tests/unit/test-vmstate.c|92| <<compare_vmstate>> g_assert_cmpint(qemu_get_buffer(f, result, size), ==, size);
+ *
+ * Target QEMU.
+ * (gdb) bt
+ * #0  0x00007ffff52bf413 in __memmove_avx_unaligned_erms_rtm () from /lib64/libc.so.6
+ * #1  0x0000555555f59607 in qemu_get_buffer (f=0x555557804800, buf=0x7ffee8000000 "\002", size=4096) at ../migration/qemu-file.c:644
+ * #2  0x0000555555e8adc4 in ram_load_precopy (f=0x555557804800) at ../migration/ram.c:4228
+ * #3  0x0000555555e8af76 in ram_load (f=0x555557804800, opaque=0x555557334c60 <ram_state>, version_id=4) at ../migration/ram.c:4307
+ * #4  0x0000555555c2ee96 in vmstate_load (f=0x555557804800, se=0x555557711b10) at ../migration/savevm.c:937
+ * #5  0x0000555555c32c88 in qemu_loadvm_section_part_end (f=0x555557804800, type=2 '\002') at ../migration/savevm.c:2672
+ * #6  0x0000555555c334b8 in qemu_loadvm_state_main (f=0x555557804800, mis=0x5555574093d0) at ../migration/savevm.c:2880
+ * #7  0x0000555555c33652 in qemu_loadvm_state (f=0x555557804800) at ../migration/savevm.c:2957
+ * #8  0x0000555555c13760 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:803
+ * #9  0x0000555556192d6f in coroutine_trampoline (i0=1466557760, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #10 0x00007ffff5233120 in ?? () from /lib64/libc.so.6
+ * #11 0x00007fffffffc7d0 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ */
 size_t coroutine_mixed_fn qemu_get_buffer(QEMUFile *f, uint8_t *buf, size_t size)
 {
     size_t pending = size;
diff --git a/migration/ram.c b/migration/ram.c
index 05ff9eb32..99f1c3e87 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -362,6 +362,16 @@ struct RAMState {
     int uffdio_fd;
     /* total ram size in bytes */
     uint64_t ram_bytes_total;
+    /*
+     * 在以下使用RAMState->last_seen_block:
+     *   - migration/ram.c|1312| <<find_dirty_block>> if (pss->complete_round && pss->block == rs->last_seen_block &&
+     *   - migration/ram.c|2260| <<ram_find_and_save_block>> if (!rs->last_seen_block) {
+     *   - migration/ram.c|2261| <<ram_find_and_save_block>> rs->last_seen_block = QLIST_FIRST_RCU(&ram_list.blocks);
+     *   - migration/ram.c|2265| <<ram_find_and_save_block>> pss_init(pss, rs->last_seen_block, rs->last_page);
+     *   - migration/ram.c|2288| <<ram_find_and_save_block>> rs->last_seen_block = pss->block;
+     *   - migration/ram.c|2408| <<ram_state_reset>> rs->last_seen_block = NULL;
+     *   - migration/ram.c|2601| <<ram_postcopy_send_discard_bitmap>> rs->last_seen_block = NULL;
+     */
     /* Last block that we have visited searching for dirty pages */
     RAMBlock *last_seen_block;
     /* Last dirty target page we have sent */
@@ -383,6 +393,13 @@ struct RAMState {
     uint64_t xbzrle_pages_prev;
     /* Amount of xbzrle encoded bytes since the beginning of the period */
     uint64_t xbzrle_bytes_prev;
+    /*
+     * 在以下使用RAMState->xbzrle_started:
+     *   - migration/ram.c|1240| <<save_zero_page>> if (rs->xbzrle_started) {
+     *   - migration/ram.c|1340| <<ram_save_page>> if (rs->xbzrle_started && !migration_in_postcopy()) {
+     *   - migration/ram.c|1428| <<find_dirty_block>> rs->xbzrle_started = true;
+     *   - migration/ram.c|2516| <<ram_state_reset>> rs->xbzrle_started = false;
+     */
     /* Are we really using XBZRLE (e.g., after the first round). */
     bool xbzrle_started;
     /* Are we on the last stage of migration */
@@ -456,6 +473,16 @@ uint64_t ram_bytes_remaining(void)
                        0;
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|706| <<save_xbzrle_page>> ram_transferred_add(bytes_xbzrle);
+ *   - migration/ram.c|1192| <<save_zero_page>> ram_transferred_add(len);
+ *   - migration/ram.c|1254| <<save_normal_page>> ram_transferred_add(save_page_header(pss, pss->pss_channel, block,
+ *   - migration/ram.c|1264| <<save_normal_page>> ram_transferred_add(TARGET_PAGE_SIZE);
+ *   - migration/ram.c|3142| <<ram_save_file_bmap>> ram_transferred_add(bitmap_size);
+ *   - migration/ram.c|3265| <<ram_save_iterate>> ram_transferred_add(8);
+ *   - migration/rdma.c|2219| <<qemu_rdma_write_one>> ram_transferred_add(sge.length);
+ */
 void ram_transferred_add(uint64_t bytes)
 {
     if (runstate_is_running()) {
@@ -506,6 +533,12 @@ static bool pss_overlap(PageSearchStatus *pss1, PageSearchStatus *pss2)
  * @offset: offset inside the block for the page
  *          in the lower bits, it contains flags
  */
+/*
+ * called by:
+ *   - migration/ram.c|695| <<save_xbzrle_page>> bytes_xbzrle = save_page_header(pss, pss->pss_channel, block,
+ *   - migration/ram.c|1188| <<save_zero_page>> len += save_page_header(pss, file, pss->block, offset | RAM_SAVE_FLAG_ZERO);
+ *   - migration/ram.c|1254| <<save_normal_page>> ram_transferred_add(save_page_header(pss, pss->pss_channel, block,
+ */
 static size_t save_page_header(PageSearchStatus *pss, QEMUFile *f,
                                RAMBlock *block, ram_addr_t offset)
 {
@@ -709,6 +742,12 @@ static int save_xbzrle_page(RAMState *rs, PageSearchStatus *pss,
  *
  * @pss: the current page search status
  */
+/*
+ * called by:
+ *   - migration/ram.c|1310| <<find_dirty_block>> pss_find_next_dirty(pss);
+ *   - migration/ram.c|2131| <<ram_save_host_page_urgent>> pss_find_next_dirty(pss);
+ *   - migration/ram.c|2216| <<ram_save_host_page>> pss_find_next_dirty(pss);
+ */
 static void pss_find_next_dirty(PageSearchStatus *pss)
 {
     RAMBlock *rb = pss->block;
@@ -730,6 +769,25 @@ static void pss_find_next_dirty(PageSearchStatus *pss)
         size = MIN(size, pss->host_page_end);
     }
 
+    /*
+     * 116 struct PageSearchStatus {
+     * 117     // The migration channel used for a specific host page
+     * 118     QEMUFile    *pss_channel;
+     * 119     // Last block from where we have sent data
+     * 120     RAMBlock *last_sent_block;
+     * 121     // Current block being searched
+     * 122     RAMBlock    *block;
+     * 123     // Current page to search from
+     * 124     unsigned long page;
+     * 125     // Set once we wrap around
+     * 126     bool         complete_round;
+     * 127     // Whether we're sending a host page
+     * 128     bool          host_page_sending;
+     * 129     // The start/end of current host page.  Invalid if host_page_sending==false
+     * 130     unsigned long host_page_start;
+     * 131     unsigned long host_page_end;
+     * 132 };
+     */
     pss->page = find_next_bit(bitmap, size, pss->page);
 }
 
@@ -1109,6 +1167,11 @@ void migration_bitmap_sync_precopy(bool last_stage)
     }
 }
 
+/*
+ * called by:
+ *   - migration/multifd-zero-page.c|73| <<multifd_send_zero_page_detect>> ram_release_page(rb->idstr, offset);
+ *   - migration/ram.c|1191| <<save_zero_page>> ram_release_page(pss->block->idstr, offset);
+ */
 void ram_release_page(const char *rbname, uint64_t offset)
 {
     if (!migrate_release_ram() || !migration_in_postcopy()) {
@@ -1127,9 +1190,20 @@ void ram_release_page(const char *rbname, uint64_t offset)
  * @pss: current PSS channel
  * @offset: offset inside the block for the page
  */
+/*
+ * called by:
+ *   - migration/ram.c|2040| <<ram_save_target_page_legacy>> if (save_zero_page(rs, pss, offset)) {
+ *   - migration/ram.c|2065| <<ram_save_target_page_multifd>> if (save_zero_page(rs, pss, offset)) {
+ */
 static int save_zero_page(RAMState *rs, PageSearchStatus *pss,
                           ram_addr_t offset)
 {
+    /*
+     * PageSearchStatus *pss:
+     * -> RAMBlock *block;
+     *    -> struct MemoryRegion *mr;
+     *    -> uint8_t *host;
+     */
     uint8_t *p = pss->block->host + offset;
     QEMUFile *file = pss->pss_channel;
     int len = 0;
@@ -1154,6 +1228,16 @@ static int save_zero_page(RAMState *rs, PageSearchStatus *pss,
     qemu_put_byte(file, 0);
     len += 1;
     ram_release_page(pss->block->idstr, offset);
+    /*
+     * called by:
+     *   - migration/ram.c|706| <<save_xbzrle_page>> ram_transferred_add(bytes_xbzrle);
+     *   - migration/ram.c|1192| <<save_zero_page>> ram_transferred_add(len);
+     *   - migration/ram.c|1254| <<save_normal_page>> ram_transferred_add(save_page_header(pss, pss->pss_channel, block,
+     *   - migration/ram.c|1264| <<save_normal_page>> ram_transferred_add(TARGET_PAGE_SIZE);
+     *   - migration/ram.c|3142| <<ram_save_file_bmap>> ram_transferred_add(bitmap_size);
+     *   - migration/ram.c|3265| <<ram_save_iterate>> ram_transferred_add(8);
+     *   - migration/rdma.c|2219| <<qemu_rdma_write_one>> ram_transferred_add(sge.length);
+     */
     ram_transferred_add(len);
 
     /*
@@ -1206,6 +1290,10 @@ static bool control_save_page(PageSearchStatus *pss,
  * @buf: the page to be sent
  * @async: send to page asyncly
  */
+/*
+ * called by:
+ *   - migration/ram.c|1360| <<ram_save_page>> pages = save_normal_page(pss, block, offset, p, send_async);
+ */
 static int save_normal_page(PageSearchStatus *pss, RAMBlock *block,
                             ram_addr_t offset, uint8_t *buf, bool async)
 {
@@ -1216,6 +1304,17 @@ static int save_normal_page(PageSearchStatus *pss, RAMBlock *block,
                            block->pages_offset + offset);
         set_bit(offset >> TARGET_PAGE_BITS, block->file_bmap);
     } else {
+        /*
+	 * 在以下使用RAM_SAVE_FLAG_PAGE:
+	 *   - migration/ram.c|87| <<global>> #define RAM_SAVE_FLAG_PAGE 0x08
+	 *   - migration/ram.c|1308| <<save_normal_page>> ram_transferred_add(save_page_header(pss,
+	 *                      pss->pss_channel, block, offset | RAM_SAVE_FLAG_PAGE));
+	 *   - migration/ram.c|3839| <<ram_load_postcopy>> if (flags & (RAM_SAVE_FLAG_ZERO | RAM_SAVE_FLAG_PAGE)) {
+	 *   - migration/ram.c|3916| <<ram_load_postcopy>> case RAM_SAVE_FLAG_PAGE:
+	 *   - migration/ram.c|4292| <<ram_load_precopy>> RAM_SAVE_FLAG_PAGE | RAM_SAVE_FLAG_XBZRLE |
+	 *   - migration/ram.c|4329| <<ram_load_precopy>> if (flags & (RAM_SAVE_FLAG_ZERO | RAM_SAVE_FLAG_PAGE |
+	 *   - migration/ram.c|4395| <<ram_load_precopy>> case RAM_SAVE_FLAG_PAGE:
+	 */
         ram_transferred_add(save_page_header(pss, pss->pss_channel, block,
                                              offset | RAM_SAVE_FLAG_PAGE));
         if (async) {
@@ -1243,6 +1342,10 @@ static int save_normal_page(PageSearchStatus *pss, RAMBlock *block,
  * @block: block that contains the page we want to send
  * @offset: offset inside the block for the page
  */
+/*
+ * called by:
+ *   - migration/ram.c|2098| <<ram_save_target_page_legacy>> return ram_save_page(rs, pss);
+ */
 static int ram_save_page(RAMState *rs, PageSearchStatus *pss)
 {
     int pages = -1;
@@ -1256,6 +1359,13 @@ static int ram_save_page(RAMState *rs, PageSearchStatus *pss)
     trace_ram_save_page(block->idstr, (uint64_t)offset, p);
 
     XBZRLE_cache_lock();
+    /*
+     * 在以下使用RAMState->xbzrle_started:
+     *   - migration/ram.c|1240| <<save_zero_page>> if (rs->xbzrle_started) {
+     *   - migration/ram.c|1340| <<ram_save_page>> if (rs->xbzrle_started && !migration_in_postcopy()) {
+     *   - migration/ram.c|1428| <<find_dirty_block>> rs->xbzrle_started = true;
+     *   - migration/ram.c|2516| <<ram_state_reset>> rs->xbzrle_started = false;
+     */
     if (rs->xbzrle_started && !migration_in_postcopy()) {
         pages = save_xbzrle_page(rs, pss, &p, current_addr,
                                  block, offset);
@@ -1269,6 +1379,9 @@ static int ram_save_page(RAMState *rs, PageSearchStatus *pss)
 
     /* XBZRLE overflow or normal page */
     if (pages == -1) {
+        /*
+	 * 只在此处调用
+	 */
         pages = save_normal_page(pss, block, offset, p, send_async);
     }
 
@@ -1993,19 +2106,43 @@ int ram_save_queue_pages(const char *rbname, ram_addr_t start, ram_addr_t len,
  * @rs: current RAM state
  * @pss: data about the page we want to send
  */
+/*
+ * 3156     migration_ops = g_malloc0(sizeof(MigrationOps));
+ * 3157 
+ * 3158     if (migrate_multifd()) {
+ * 3159         multifd_ram_save_setup();
+ * 3160         migration_ops->ram_save_target_page = ram_save_target_page_multifd;
+ * 3161     } else {
+ * 3162         migration_ops->ram_save_target_page = ram_save_target_page_legacy;
+ * 3163     }
+ *
+ * 在以下使用ram_save_target_page_legacy():
+ *   - migration/ram.c|3108| <<ram_save_setup>> migration_ops->ram_save_target_page = ram_save_target_page_legacy;
+ */
 static int ram_save_target_page_legacy(RAMState *rs, PageSearchStatus *pss)
 {
     ram_addr_t offset = ((ram_addr_t)pss->page) << TARGET_PAGE_BITS;
     int res;
 
+    /*
+     * 不支持rdma不用
+     */
     if (control_save_page(pss, offset, &res)) {
         return res;
     }
 
+    /*
+     * called by:
+     *   - migration/ram.c|2040| <<ram_save_target_page_legacy>> if (save_zero_page(rs, pss, offset)) {
+     *   - migration/ram.c|2065| <<ram_save_target_page_multifd>> if (save_zero_page(rs, pss, offset)) {
+     */
     if (save_zero_page(rs, pss, offset)) {
         return 1;
     }
 
+    /*
+     * 只在此处调用
+     */
     return ram_save_page(rs, pss);
 }
 
@@ -2235,6 +2372,11 @@ static int ram_save_host_page(RAMState *rs, PageSearchStatus *pss)
  * On systems where host-page-size > target-page-size it will send all the
  * pages in a host page that are dirty.
  */
+/*
+ * called by:
+ *   - migration/ram.c|3168| <<ram_save_iterate>> pages = ram_find_and_save_block(rs);
+ *   - migration/ram.c|3267| <<ram_save_complete>> pages = ram_find_and_save_block(rs);
+ */
 static int ram_find_and_save_block(RAMState *rs)
 {
     PageSearchStatus *pss = &rs->pss[RAM_CHANNEL_PRECOPY];
@@ -2769,6 +2911,10 @@ static void migration_bitmap_clear_discarded_pages(RAMState *rs)
     }
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|2816| <<ram_init_all>> if (!ram_init_bitmaps(*rsp, errp)) {
+ */
 static bool ram_init_bitmaps(RAMState *rs, Error **errp)
 {
     bool ret = true;
@@ -3779,6 +3925,17 @@ int ram_load_postcopy(QEMUFile *f, int channel)
             break;
 
         case RAM_SAVE_FLAG_PAGE:
+            /*
+	     * 在以下使用RAM_SAVE_FLAG_PAGE:
+	     *   - migration/ram.c|87| <<global>> #define RAM_SAVE_FLAG_PAGE 0x08
+	     *   - migration/ram.c|1308| <<save_normal_page>> ram_transferred_add(save_page_header(pss,
+	     *                      pss->pss_channel, block, offset | RAM_SAVE_FLAG_PAGE));
+	     *   - migration/ram.c|3839| <<ram_load_postcopy>> if (flags & (RAM_SAVE_FLAG_ZERO | RAM_SAVE_FLAG_PAGE)) {
+	     *   - migration/ram.c|3916| <<ram_load_postcopy>> case RAM_SAVE_FLAG_PAGE:
+	     *   - migration/ram.c|4292| <<ram_load_precopy>> RAM_SAVE_FLAG_PAGE | RAM_SAVE_FLAG_XBZRLE |
+	     *   - migration/ram.c|4329| <<ram_load_precopy>> if (flags & (RAM_SAVE_FLAG_ZERO | RAM_SAVE_FLAG_PAGE |
+	     *   - migration/ram.c|4395| <<ram_load_precopy>> case RAM_SAVE_FLAG_PAGE:
+	     */
             tmp_page->all_zero = false;
             if (!matches_target_page_size) {
                 /* For huge pages, we always use temporary buffer */
@@ -3906,6 +4063,10 @@ static size_t ram_load_multifd_pages(void *host_addr, size_t size,
     return size;
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|4010| <<parse_ramblock_mapped_ram>> if (!read_ramblock_mapped_ram(f, block, num_pages, bitmap, errp)) {
+ */
 static bool read_ramblock_mapped_ram(QEMUFile *f, RAMBlock *block,
                                      long num_pages, unsigned long *bitmap,
                                      Error **errp)
@@ -3961,6 +4122,10 @@ err:
     return false;
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|4031| <<parse_ramblock>> parse_ramblock_mapped_ram(f, block, length, &local_err);
+ */
 static void parse_ramblock_mapped_ram(QEMUFile *f, RAMBlock *block,
                                       ram_addr_t length, Error **errp)
 {
@@ -4008,6 +4173,10 @@ static void parse_ramblock_mapped_ram(QEMUFile *f, RAMBlock *block,
     return;
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|4104| <<parse_ramblocks>> ret = parse_ramblock(f, block, length);
+ */
 static int parse_ramblock(QEMUFile *f, RAMBlock *block, ram_addr_t length)
 {
     int ret = 0;
@@ -4075,6 +4244,10 @@ static int parse_ramblock(QEMUFile *f, RAMBlock *block, ram_addr_t length)
     return ret;
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|4351| <<ram_load_precopy>> ret = parse_ramblocks(f, addr);
+ */
 static int parse_ramblocks(QEMUFile *f, ram_addr_t total_ram_bytes)
 {
     int ret = 0;
@@ -4114,6 +4287,39 @@ static int parse_ramblocks(QEMUFile *f, ram_addr_t total_ram_bytes)
  *
  * @f: QEMUFile where to send the data
  */
+/*
+ * (gdb) bt
+ * #0  ram_load_precopy (f=0x555557804800) at ../migration/ram.c:4119
+ * #1  0x0000555555e8af76 in ram_load (f=0x555557804800, opaque=0x555557334c60 <ram_state>, version_id=4) at ../migration/ram.c:4307
+ * #2  0x0000555555c2ee96 in vmstate_load (f=0x555557804800, se=0x555557711b10) at ../migration/savevm.c:937
+ * #3  0x0000555555c32a8e in qemu_loadvm_section_start_full (f=0x555557804800, type=1 '\001') at ../migration/savevm.c:2619
+ * #4  0x0000555555c33498 in qemu_loadvm_state_main (f=0x555557804800, mis=0x5555574093d0) at ../migration/savevm.c:2873
+ * #5  0x0000555555c33652 in qemu_loadvm_state (f=0x555557804800) at ../migration/savevm.c:2957
+ * #6  0x0000555555c13760 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:803
+ * #7  0x0000555556192d6f in coroutine_trampoline (i0=1466557760, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #8  0x00007ffff5233120 in ?? () from /lib64/libc.so.6
+ * #9  0x00007fffffffc7d0 in ?? ()
+ * #10 0x0000000000000000 in ?? ()
+ *
+ * Target QEMU.
+ * (gdb) bt
+ * #0  0x00007ffff52bf413 in __memmove_avx_unaligned_erms_rtm () from /lib64/libc.so.6
+ * #1  0x0000555555f59607 in qemu_get_buffer (f=0x555557804800, buf=0x7ffee8000000 "\002", size=4096) at ../migration/qemu-file.c:644
+ * #2  0x0000555555e8adc4 in ram_load_precopy (f=0x555557804800) at ../migration/ram.c:4228
+ * #3  0x0000555555e8af76 in ram_load (f=0x555557804800, opaque=0x555557334c60 <ram_state>, version_id=4) at ../migration/ram.c:4307
+ * #4  0x0000555555c2ee96 in vmstate_load (f=0x555557804800, se=0x555557711b10) at ../migration/savevm.c:937
+ * #5  0x0000555555c32c88 in qemu_loadvm_section_part_end (f=0x555557804800, type=2 '\002') at ../migration/savevm.c:2672
+ * #6  0x0000555555c334b8 in qemu_loadvm_state_main (f=0x555557804800, mis=0x5555574093d0) at ../migration/savevm.c:2880
+ * #7  0x0000555555c33652 in qemu_loadvm_state (f=0x555557804800) at ../migration/savevm.c:2957
+ * #8  0x0000555555c13760 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:803
+ * #9  0x0000555556192d6f in coroutine_trampoline (i0=1466557760, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #10 0x00007ffff5233120 in ?? () from /lib64/libc.so.6
+ * #11 0x00007fffffffc7d0 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ *
+ * called by:
+ *   - migration/ram.c|4454| <<ram_load>> ret = ram_load_precopy(f);
+ */
 static int ram_load_precopy(QEMUFile *f)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -4158,6 +4364,17 @@ static int ram_load_precopy(QEMUFile *f)
             break;
         }
 
+	/*
+	 * 在以下使用RAM_SAVE_FLAG_PAGE:
+	 *   - migration/ram.c|87| <<global>> #define RAM_SAVE_FLAG_PAGE 0x08
+	 *   - migration/ram.c|1308| <<save_normal_page>> ram_transferred_add(save_page_header(pss,
+	 *                      pss->pss_channel, block, offset | RAM_SAVE_FLAG_PAGE));
+	 *   - migration/ram.c|3839| <<ram_load_postcopy>> if (flags & (RAM_SAVE_FLAG_ZERO | RAM_SAVE_FLAG_PAGE)) {
+	 *   - migration/ram.c|3916| <<ram_load_postcopy>> case RAM_SAVE_FLAG_PAGE:
+	 *   - migration/ram.c|4292| <<ram_load_precopy>> RAM_SAVE_FLAG_PAGE | RAM_SAVE_FLAG_XBZRLE |
+	 *   - migration/ram.c|4329| <<ram_load_precopy>> if (flags & (RAM_SAVE_FLAG_ZERO | RAM_SAVE_FLAG_PAGE |
+	 *   - migration/ram.c|4395| <<ram_load_precopy>> case RAM_SAVE_FLAG_PAGE:
+	 */
         if (flags & (RAM_SAVE_FLAG_ZERO | RAM_SAVE_FLAG_PAGE |
                      RAM_SAVE_FLAG_XBZRLE)) {
             RAMBlock *block = ram_block_from_stream(mis, f, flags,
@@ -4272,6 +4489,38 @@ static int ram_load_precopy(QEMUFile *f)
     return ret;
 }
 
+/*
+ * Target QEMU.
+ * (gdb) bt
+ * #0  0x00007ffff52bf413 in __memmove_avx_unaligned_erms_rtm () from /lib64/libc.so.6
+ * #1  0x0000555555f59607 in qemu_get_buffer (f=0x555557804800, buf=0x7ffee8000000 "\002", size=4096) at ../migration/qemu-file.c:644
+ * #2  0x0000555555e8adc4 in ram_load_precopy (f=0x555557804800) at ../migration/ram.c:4228
+ * #3  0x0000555555e8af76 in ram_load (f=0x555557804800, opaque=0x555557334c60 <ram_state>, version_id=4) at ../migration/ram.c:4307
+ * #4  0x0000555555c2ee96 in vmstate_load (f=0x555557804800, se=0x555557711b10) at ../migration/savevm.c:937
+ * #5  0x0000555555c32c88 in qemu_loadvm_section_part_end (f=0x555557804800, type=2 '\002') at ../migration/savevm.c:2672
+ * #6  0x0000555555c334b8 in qemu_loadvm_state_main (f=0x555557804800, mis=0x5555574093d0) at ../migration/savevm.c:2880
+ * #7  0x0000555555c33652 in qemu_loadvm_state (f=0x555557804800) at ../migration/savevm.c:2957
+ * #8  0x0000555555c13760 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:803
+ * #9  0x0000555556192d6f in coroutine_trampoline (i0=1466557760, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #10 0x00007ffff5233120 in ?? () from /lib64/libc.so.6
+ * #11 0x00007fffffffc7d0 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ *
+ * 4704 static SaveVMHandlers savevm_ram_handlers = {
+ * 4705     .save_setup = ram_save_setup,
+ * 4706     .save_live_iterate = ram_save_iterate,
+ * 4707     .save_live_complete_postcopy = ram_save_complete,
+ * 4708     .save_live_complete_precopy = ram_save_complete,
+ * 4709     .has_postcopy = ram_has_postcopy,
+ * 4710     .state_pending_exact = ram_state_pending_exact,
+ * 4711     .state_pending_estimate = ram_state_pending_estimate,
+ * 4712     .load_state = ram_load,
+ * 4713     .save_cleanup = ram_save_cleanup,
+ * 4714     .load_setup = ram_load_setup,
+ * 4715     .load_cleanup = ram_load_cleanup,
+ * 4716     .resume_prepare = ram_resume_prepare,
+ * 4717 };
+ */
 static int ram_load(QEMUFile *f, void *opaque, int version_id)
 {
     int ret = 0;
diff --git a/migration/savevm.c b/migration/savevm.c
index 98821c812..e71fabd6d 100644
--- a/migration/savevm.c
+++ b/migration/savevm.c
@@ -930,6 +930,23 @@ void vmstate_unregister(VMStateIf *obj, const VMStateDescription *vmsd,
     }
 }
 
+/*
+ * Target QEMU.
+ * (gdb) bt
+ * #0  0x00007ffff52bf413 in __memmove_avx_unaligned_erms_rtm () from /lib64/libc.so.6
+ * #1  0x0000555555f59607 in qemu_get_buffer (f=0x555557804800, buf=0x7ffee8000000 "\002", size=4096) at ../migration/qemu-file.c:644
+ * #2  0x0000555555e8adc4 in ram_load_precopy (f=0x555557804800) at ../migration/ram.c:4228
+ * #3  0x0000555555e8af76 in ram_load (f=0x555557804800, opaque=0x555557334c60 <ram_state>, version_id=4) at ../migration/ram.c:4307
+ * #4  0x0000555555c2ee96 in vmstate_load (f=0x555557804800, se=0x555557711b10) at ../migration/savevm.c:937
+ * #5  0x0000555555c32c88 in qemu_loadvm_section_part_end (f=0x555557804800, type=2 '\002') at ../migration/savevm.c:2672
+ * #6  0x0000555555c334b8 in qemu_loadvm_state_main (f=0x555557804800, mis=0x5555574093d0) at ../migration/savevm.c:2880
+ * #7  0x0000555555c33652 in qemu_loadvm_state (f=0x555557804800) at ../migration/savevm.c:2957
+ * #8  0x0000555555c13760 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:803
+ * #9  0x0000555556192d6f in coroutine_trampoline (i0=1466557760, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #10 0x00007ffff5233120 in ?? () from /lib64/libc.so.6
+ * #11 0x00007fffffffc7d0 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ */
 static int vmstate_load(QEMUFile *f, SaveStateEntry *se)
 {
     trace_vmstate_load(se->idstr, se->vmsd ? se->vmsd->name : "(old)");
@@ -2558,6 +2575,10 @@ static bool check_section_footer(QEMUFile *f, SaveStateEntry *se)
     return true;
 }
 
+/*
+ * called by:
+ *   - migration/savevm.c|2873| <<qemu_loadvm_state_main>> ret = qemu_loadvm_section_start_full(f, section_type);
+ */
 static int
 qemu_loadvm_section_start_full(QEMUFile *f, uint8_t type)
 {
@@ -2636,6 +2657,23 @@ qemu_loadvm_section_start_full(QEMUFile *f, uint8_t type)
     return 0;
 }
 
+/*
+ * Target QEMU.
+ * (gdb) bt
+ * #0  0x00007ffff52bf413 in __memmove_avx_unaligned_erms_rtm () from /lib64/libc.so.6
+ * #1  0x0000555555f59607 in qemu_get_buffer (f=0x555557804800, buf=0x7ffee8000000 "\002", size=4096) at ../migration/qemu-file.c:644
+ * #2  0x0000555555e8adc4 in ram_load_precopy (f=0x555557804800) at ../migration/ram.c:4228
+ * #3  0x0000555555e8af76 in ram_load (f=0x555557804800, opaque=0x555557334c60 <ram_state>, version_id=4) at ../migration/ram.c:4307
+ * #4  0x0000555555c2ee96 in vmstate_load (f=0x555557804800, se=0x555557711b10) at ../migration/savevm.c:937
+ * #5  0x0000555555c32c88 in qemu_loadvm_section_part_end (f=0x555557804800, type=2 '\002') at ../migration/savevm.c:2672
+ * #6  0x0000555555c334b8 in qemu_loadvm_state_main (f=0x555557804800, mis=0x5555574093d0) at ../migration/savevm.c:2880
+ * #7  0x0000555555c33652 in qemu_loadvm_state (f=0x555557804800) at ../migration/savevm.c:2957
+ * #8  0x0000555555c13760 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:803
+ * #9  0x0000555556192d6f in coroutine_trampoline (i0=1466557760, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #10 0x00007ffff5233120 in ?? () from /lib64/libc.so.6
+ * #11 0x00007fffffffc7d0 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ */
 static int
 qemu_loadvm_section_part_end(QEMUFile *f, uint8_t type)
 {
@@ -2852,6 +2890,30 @@ static bool postcopy_pause_incoming(MigrationIncomingState *mis)
     return true;
 }
 
+/*
+ * Target QEMU.
+ * (gdb) bt
+ * #0  0x00007ffff52bf413 in __memmove_avx_unaligned_erms_rtm () from /lib64/libc.so.6
+ * #1  0x0000555555f59607 in qemu_get_buffer (f=0x555557804800, buf=0x7ffee8000000 "\002", size=4096) at ../migration/qemu-file.c:644
+ * #2  0x0000555555e8adc4 in ram_load_precopy (f=0x555557804800) at ../migration/ram.c:4228
+ * #3  0x0000555555e8af76 in ram_load (f=0x555557804800, opaque=0x555557334c60 <ram_state>, version_id=4) at ../migration/ram.c:4307
+ * #4  0x0000555555c2ee96 in vmstate_load (f=0x555557804800, se=0x555557711b10) at ../migration/savevm.c:937
+ * #5  0x0000555555c32c88 in qemu_loadvm_section_part_end (f=0x555557804800, type=2 '\002') at ../migration/savevm.c:2672
+ * #6  0x0000555555c334b8 in qemu_loadvm_state_main (f=0x555557804800, mis=0x5555574093d0) at ../migration/savevm.c:2880
+ * #7  0x0000555555c33652 in qemu_loadvm_state (f=0x555557804800) at ../migration/savevm.c:2957
+ * #8  0x0000555555c13760 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:803
+ * #9  0x0000555556192d6f in coroutine_trampoline (i0=1466557760, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #10 0x00007ffff5233120 in ?? () from /lib64/libc.so.6
+ * #11 0x00007fffffffc7d0 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ *
+ * called by:
+ *   - migration/colo.c|686| <<colo_incoming_process_checkpoint>> ret = qemu_loadvm_state_main(mis->from_src_file, mis);
+ *   - migration/savevm.c|1999| <<postcopy_ram_listen_thread>> load_res = qemu_loadvm_state_main(f, mis);
+ *   - migration/savevm.c|2351| <<loadvm_handle_cmd_packaged>> ret = qemu_loadvm_state_main(packf, mis);
+ *   - migration/savevm.c|2957| <<qemu_loadvm_state>> ret = qemu_loadvm_state_main(f, mis);
+ *   - migration/savevm.c|3020| <<qemu_load_device_state>> ret = qemu_loadvm_state_main(f, mis);
+ */
 int qemu_loadvm_state_main(QEMUFile *f, MigrationIncomingState *mis)
 {
     uint8_t section_type;
@@ -2927,6 +2989,23 @@ out:
     return ret;
 }
 
+/*
+ * Target QEMU.
+ * (gdb) bt
+ * #0  0x00007ffff52bf413 in __memmove_avx_unaligned_erms_rtm () from /lib64/libc.so.6
+ * #1  0x0000555555f59607 in qemu_get_buffer (f=0x555557804800, buf=0x7ffee8000000 "\002", size=4096) at ../migration/qemu-file.c:644
+ * #2  0x0000555555e8adc4 in ram_load_precopy (f=0x555557804800) at ../migration/ram.c:4228
+ * #3  0x0000555555e8af76 in ram_load (f=0x555557804800, opaque=0x555557334c60 <ram_state>, version_id=4) at ../migration/ram.c:4307
+ * #4  0x0000555555c2ee96 in vmstate_load (f=0x555557804800, se=0x555557711b10) at ../migration/savevm.c:937
+ * #5  0x0000555555c32c88 in qemu_loadvm_section_part_end (f=0x555557804800, type=2 '\002') at ../migration/savevm.c:2672
+ * #6  0x0000555555c334b8 in qemu_loadvm_state_main (f=0x555557804800, mis=0x5555574093d0) at ../migration/savevm.c:2880
+ * #7  0x0000555555c33652 in qemu_loadvm_state (f=0x555557804800) at ../migration/savevm.c:2957
+ * #8  0x0000555555c13760 in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:803
+ * #9  0x0000555556192d6f in coroutine_trampoline (i0=1466557760, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #10 0x00007ffff5233120 in ?? () from /lib64/libc.so.6
+ * #11 0x00007fffffffc7d0 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ */
 int qemu_loadvm_state(QEMUFile *f)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
diff --git a/system/memory.c b/system/memory.c
index 85f6834cb..3f1695f37 100644
--- a/system/memory.c
+++ b/system/memory.c
@@ -1588,6 +1588,14 @@ bool memory_region_init_ram_nomigrate(MemoryRegion *mr,
                                                   size, 0, errp);
 }
 
+/*
+ * clled by:
+ *   - backends/hostmem-ram.c|34| <<ram_backend_memory_alloc>> return memory_region_init_ram_flags_nomigrate(&backend->mr, OBJECT(backend),
+ *   - hw/m68k/next-cube.c|1013| <<next_cube_init>> memory_region_init_ram_flags_nomigrate(&m->bmapm1, NULL, "next.bmapmem",
+ *   - system/memory.c|1587| <<memory_region_init_ram_nomigrate>> return memory_region_init_ram_flags_nomigrate(mr, owner, name,
+ *   - system/memory.c|1748| <<memory_region_init_rom_nomigrate>> if (!memory_region_init_ram_flags_nomigrate(mr, owner, name,
+ *   - system/memory.c|3718| <<memory_region_init_ram_guest_memfd>> if (!memory_region_init_ram_flags_nomigrate(mr, owner, name, size,
+ */
 bool memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
                                             Object *owner,
                                             const char *name,
diff --git a/system/physmem.c b/system/physmem.c
index dc1db3a38..9b369630e 100644
--- a/system/physmem.c
+++ b/system/physmem.c
@@ -84,6 +84,43 @@
 
 //#define DEBUG_SUBPAGE
 
+/*
+ * 在以下使用ram_list:
+ *   - system/physmem.c|949| <<global>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - hw/core/numa.c|846| <<ram_block_notifier_add>> QLIST_INSERT_HEAD(&ram_list.ramblock_notifiers, n, next);
+ *   - hw/core/numa.c|868| <<ram_block_notify_add>> QLIST_FOREACH_SAFE(notifier, &ram_list.ramblock_notifiers, next, next) {
+ *   - hw/core/numa.c|880| <<ram_block_notify_remove>> QLIST_FOREACH_SAFE(notifier, &ram_list.ramblock_notifiers, next, next) {
+ *   - hw/core/numa.c|892| <<ram_block_notify_resize>> QLIST_FOREACH_SAFE(notifier, &ram_list.ramblock_notifiers, next, next) {
+ *   - include/exec/ram_addr.h|169| <<cpu_physical_memory_get_dirty>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - include/exec/ram_addr.h|210| <<cpu_physical_memory_all_dirty>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - include/exec/ram_addr.h|283| <<cpu_physical_memory_set_dirty_flag>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - include/exec/ram_addr.h|306| <<cpu_physical_memory_set_dirty_range>> blocks[i] = qatomic_rcu_read(&ram_list.dirty_memory[i]);
+ *   - include/exec/ram_addr.h|376| <<cpu_physical_memory_set_dirty_lebitmap>> qatomic_rcu_read(&ram_list.dirty_memory[i])->blocks;
+ *   - include/exec/ram_addr.h|500| <<cpu_physical_memory_sync_dirty_bitmap>> &ram_list.dirty_memory[DIRTY_MEMORY_MIGRATION])->blocks;
+ *   - include/exec/ramlist.h|61| <<INTERNAL_RAMBLOCK_FOREACH>> QLIST_FOREACH_RCU(block, &ram_list.blocks, next)
+ *   - migration/ram.c|1342| <<find_dirty_block>> pss->block = QLIST_FIRST_RCU(&ram_list.blocks);
+ *   - migration/ram.c|2256| <<ram_find_and_save_block>> rs->last_seen_block = QLIST_FIRST_RCU(&ram_list.blocks);
+ *   - migration/ram.c|2405| <<ram_state_reset>> rs->last_version = ram_list.version;
+ *   - migration/ram.c|3145| <<ram_save_iterate>> if (ram_list.version != rs->last_version) {
+ *   - migration/ram.c|3863| <<colo_flush_ram_cache>> block = QLIST_FIRST_RCU(&ram_list.blocks);
+ *   - system/physmem.c|819| <<qemu_get_ram_block>> block = qatomic_rcu_read(&ram_list.mru_block);
+ *   - system/physmem.c|849| <<qemu_get_ram_block>> ram_list.mru_block = block;
+ *   - system/physmem.c|893| <<cpu_physical_memory_test_and_clear_dirty>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - system/physmem.c|1148| <<qemu_mutex_lock_ramlist>> qemu_mutex_lock(&ram_list.mutex);
+ *   - system/physmem.c|1153| <<qemu_mutex_unlock_ramlist>> qemu_mutex_unlock(&ram_list.mutex);
+ *   - system/physmem.c|1492| <<find_ram_offset>> if (QLIST_EMPTY_RCU(&ram_list.blocks)) {
+ *   - system/physmem.c|1792| <<dirty_memory_extend>> unsigned int old_num_blocks = ram_list.num_dirty_blocks;
+ *   - system/physmem.c|1807| <<dirty_memory_extend>> old_blocks = qatomic_rcu_read(&ram_list.dirty_memory[i]);
+ *   - system/physmem.c|1820| <<dirty_memory_extend>> qatomic_rcu_set(&ram_list.dirty_memory[i], new_blocks);
+ *   - system/physmem.c|1827| <<dirty_memory_extend>> ram_list.num_dirty_blocks = new_num_blocks;
+ *   - system/physmem.c|1907| <<ram_block_add>> QLIST_INSERT_HEAD_RCU(&ram_list.blocks, new_block, next);
+ *   - system/physmem.c|1909| <<ram_block_add>> ram_list.mru_block = NULL;
+ *   - system/physmem.c|1913| <<ram_block_add>> ram_list.version++;
+ *   - system/physmem.c|2161| <<qemu_ram_free>> ram_list.mru_block = NULL;
+ *   - system/physmem.c|2164| <<qemu_ram_free>> ram_list.version++;
+ *   - system/physmem.c|2313| <<qemu_ram_block_from_host>> block = qatomic_rcu_read(&ram_list.mru_block);
+ *   - system/physmem.c|3129| <<cpu_exec_init_all>> qemu_mutex_init(&ram_list.mutex);
+ */
 /* ram_list is read under rcu_read_lock()/rcu_read_unlock().  Writes
  * are protected by the ramlist lock.
  */
@@ -1827,6 +1864,51 @@ static void dirty_memory_extend(ram_addr_t new_ram_size)
     ram_list.num_dirty_blocks = new_num_blocks;
 }
 
+/*
+ * 如果只是普通的"-m xxxx"
+ *
+ * (gdb) bt
+ * #0  ram_block_add (new_block=0x555557712270, errp=0x7fffffffd688) at ../system/physmem.c:1831
+ * #1  0x0000555555e77d15 in qemu_ram_alloc_internal (size=4294967296, max_size=4294967296, resized=0x0, host=0x0, ram_flags=0, mr=0x5555575482e0, errp=0x7fffffffd720)
+ *     at ../system/physmem.c:2092
+ * #2  0x0000555555e77e41 in qemu_ram_alloc (size=4294967296, ram_flags=0, mr=0x5555575482e0, errp=0x7fffffffd720) at ../system/physmem.c:2112
+ * #3  0x0000555555e69caa in memory_region_init_ram_flags_nomigrate (mr=0x5555575482e0, owner=0x555557548270, name=0x555557407540 "pc.ram", size=4294967296, ram_flags=0,
+ *     errp=0x7fffffffd848) at ../system/memory.c:1603
+ * #4  0x0000555555bf0197 in ram_backend_memory_alloc (backend=0x555557548270, errp=0x7fffffffd848) at ../backends/hostmem-ram.c:34
+ * #5  0x0000555555bf0fee in host_memory_backend_memory_complete (uc=0x555557548270, errp=0x7fffffffd848) at ../backends/hostmem.c:345
+ * #6  0x0000555555efe460 in user_creatable_complete (uc=0x555557548270, errp=0x7fffffffd900) at ../qom/object_interfaces.c:28
+ * #7  0x00005555559475a1 in create_default_memdev (ms=0x5555576791f0, path=0x0, errp=0x7fffffffd900) at ../hw/core/machine.c:1046
+ * #8  0x0000555555949399 in machine_run_board_init (machine=0x5555576791f0, mem_path=0x0, errp=0x7fffffffd900) at ../hw/core/machine.c:1584
+ * #9  0x0000555555be76cb in qemu_init_board () at ../system/vl.c:2632
+ * #10 0x0000555555be7a2b in qmp_x_exit_preconfig (errp=0x555557350860 <error_fatal>) at ../system/vl.c:2718
+ * #11 0x0000555555bea569 in qemu_init (argc=18, argv=0x7fffffffdbf8) at ../system/vl.c:3753
+ * #12 0x000055555609a086 in main (argc=18, argv=0x7fffffffdbf8) at ../system/main.c:47
+ *
+ * (gdb) bt
+ * #0  ram_block_add (new_block=0x555557680e90, errp=0x7fffffffd558) at ../system/physmem.c:1831
+ * #1  0x0000555555e77d15 in qemu_ram_alloc_internal (size=131072, max_size=131072, resized=0x0, host=0x0, ram_flags=0, mr=0x555557565000, errp=0x7fffffffd5f0)
+ *     at ../system/physmem.c:2092
+ * #2  0x0000555555e77e41 in qemu_ram_alloc (size=131072, ram_flags=0, mr=0x555557565000, errp=0x7fffffffd5f0) at ../system/physmem.c:2112
+ * #3  0x0000555555e69caa in memory_region_init_ram_flags_nomigrate (mr=0x555557565000, owner=0x0, name=0x55555635dacf "pc.rom", size=131072, ram_flags=0,
+ *     errp=0x555557350860 <error_fatal>) at ../system/memory.c:1603
+ * #4  0x0000555555e69c0f in memory_region_init_ram_nomigrate (mr=0x555557565000, owner=0x0, name=0x55555635dacf "pc.rom", size=131072, errp=0x555557350860 <error_fatal>)
+ *     at ../system/memory.c:1587
+ * #5  0x0000555555e705f4 in memory_region_init_ram (mr=0x555557565000, owner=0x0, name=0x55555635dacf "pc.rom", size=131072, errp=0x555557350860 <error_fatal>)
+ *     at ../system/memory.c:3695
+ * #6  0x0000555555d1d904 in pc_memory_init (pcms=0x5555576791f0, system_memory=0x5555575feae0, rom_memory=0x555557407190, pci_hole64_size=2147483648) at ../hw/i386/pc.c:975
+ * #7  0x0000555555cf82d9 in pc_init1 (machine=0x5555576791f0, pci_type=0x5555563555ea "i440FX") at ../hw/i386/pc_piix.c:225
+ * #8  0x0000555555cf8c82 in pc_i440fx_init (machine=0x5555576791f0) at ../hw/i386/pc_piix.c:445
+ * #9  0x0000555555cf8e7a in pc_i440fx_machine_9_2_init (machine=0x5555576791f0) at ../hw/i386/pc_piix.c:484
+ * #10 0x0000555555949537 in machine_run_board_init (machine=0x5555576791f0, mem_path=0x0, errp=0x7fffffffd900) at ../hw/core/machine.c:1630
+ * #11 0x0000555555be76cb in qemu_init_board () at ../system/vl.c:2632
+ * #12 0x0000555555be7a2b in qmp_x_exit_preconfig (errp=0x555557350860 <error_fatal>) at ../system/vl.c:2718
+ * #13 0x0000555555bea569 in qemu_init (argc=18, argv=0x7fffffffdbf8) at ../system/vl.c:3753
+ * #14 0x000055555609a086 in main (argc=18, argv=0x7fffffffdbf8) at ../system/main.c:47
+ *
+ * called by:
+ *   - system/physmem.c|2001| <<qemu_ram_alloc_from_fd>> ram_block_add(new_block, &local_err);
+ *   - system/physmem.c|2092| <<qemu_ram_alloc_from_fd>> ram_block_add(new_block, &local_err);
+ */
 static void ram_block_add(RAMBlock *new_block, Error **errp)
 {
     const bool noreserve = qemu_ram_is_noreserve(new_block);
@@ -2105,6 +2187,21 @@ RAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
                                    errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_ram_alloc (size=4294967296, ram_flags=0, mr=0x5555575482e0, errp=0x7fffffffd720) at ../system/physmem.c:2111
+ * #1  0x0000555555e69caa in memory_region_init_ram_flags_nomigrate (mr=0x5555575482e0, owner=0x555557548270, name=0x555557407540 "pc.ram", size=4294967296, ram_flags=0,
+ *     errp=0x7fffffffd848) at ../system/memory.c:1603
+ * #2  0x0000555555bf0197 in ram_backend_memory_alloc (backend=0x555557548270, errp=0x7fffffffd848) at ../backends/hostmem-ram.c:34
+ * #3  0x0000555555bf0fee in host_memory_backend_memory_complete (uc=0x555557548270, errp=0x7fffffffd848) at ../backends/hostmem.c:345
+ * #4  0x0000555555efe460 in user_creatable_complete (uc=0x555557548270, errp=0x7fffffffd900) at ../qom/object_interfaces.c:28
+ * #5  0x00005555559475a1 in create_default_memdev (ms=0x5555576791f0, path=0x0, errp=0x7fffffffd900) at ../hw/core/machine.c:1046
+ * #6  0x0000555555949399 in machine_run_board_init (machine=0x5555576791f0, mem_path=0x0, errp=0x7fffffffd900) at ../hw/core/machine.c:1584
+ * #7  0x0000555555be76cb in qemu_init_board () at ../system/vl.c:2632
+ * #8  0x0000555555be7a2b in qmp_x_exit_preconfig (errp=0x555557350860 <error_fatal>) at ../system/vl.c:2718
+ * #9  0x0000555555bea569 in qemu_init (argc=18, argv=0x7fffffffdbf8) at ../system/vl.c:3753
+ * #10 0x000055555609a086 in main (argc=18, argv=0x7fffffffdbf8) at ../system/main.c:47
+ */
 RAMBlock *qemu_ram_alloc(ram_addr_t size, uint32_t ram_flags,
                          MemoryRegion *mr, Error **errp)
 {
-- 
2.39.5 (Apple Git-154)

