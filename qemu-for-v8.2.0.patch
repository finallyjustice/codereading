From f22af83c02cc18f928588fdb0796b68a0913cf2e Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Fri, 23 Feb 2024 02:08:23 -0800
Subject: [PATCH 1/1] qemu for v8.2.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-accel-ops.c     |   3 +
 accel/kvm/kvm-all.c           |  50 +++++++
 backends/hostmem-file.c       |  64 +++++++++
 backends/hostmem-memfd.c      |   4 +
 backends/hostmem-ram.c        |  20 +++
 backends/hostmem.c            |  76 ++++++++++
 block/block-backend.c         |  30 ++++
 block/file-posix.c            |  14 ++
 block/io.c                    |   9 ++
 cpu-common.c                  |  10 ++
 hw/core/cpu-common.c          |   5 +
 hw/core/qdev.c                |  25 ++++
 hw/i386/kvm/apic.c            |  11 ++
 hw/i386/x86.c                 |  27 ++++
 hw/intc/apic_common.c         |  28 ++++
 hw/vfio/helpers.c             |   6 +
 hw/vfio/pci.c                 |   4 +
 hw/virtio/vhost.c             | 259 ++++++++++++++++++++++++++++++++++
 include/hw/core/cpu.h         |  29 ++++
 include/hw/virtio/vhost.h     |  19 +++
 include/qemu/thread-context.h |   8 ++
 include/sysemu/hostmem.h      |  18 +++
 migration/ram.c               |   5 +
 monitor/hmp.c                 |  21 +++
 monitor/qmp.c                 |  15 ++
 qapi/qmp-dispatch.c           |  29 ++++
 qom/qom-qmp-cmds.c            |  46 ++++++
 system/cpus.c                 |  29 ++++
 system/main.c                 |   4 +
 system/memory.c               | 136 ++++++++++++++++++
 system/physmem.c              |  89 ++++++++++++
 system/runstate.c             |   4 +
 system/vl.c                   |   4 +
 target/i386/kvm/kvm.c         |  88 ++++++++++++
 util/main-loop.c              |  56 ++++++++
 util/mmap-alloc.c             |  56 ++++++++
 util/oslib-posix.c            | 139 ++++++++++++++++++
 util/qemu-config.c            |  43 +++++-
 util/qemu-timer.c             |   4 +
 util/thread-context.c         |  68 +++++++++
 40 files changed, 1554 insertions(+), 1 deletion(-)

diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index 6195150a0..54b4fbf99 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -48,6 +48,9 @@ static void *kvm_vcpu_thread_fn(void *arg)
 
     do {
         if (cpu_can_run(cpu)) {
+            /*
+	     * 调用主函数
+	     */
             r = kvm_cpu_exec(cpu);
             if (r == EXCP_DEBUG) {
                 cpu_handle_guest_debug(cpu);
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index e39a810a4..e4548f796 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -289,6 +289,12 @@ int kvm_physical_memory_addr_from_host(KVMState *s, void *ram,
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|493| <<kvm_slot_update_flags>> return kvm_set_user_memory_region(kml, mem, false);
+ *   - accel/kvm/kvm-all.c|1342| <<kvm_set_phys_mem>> err = kvm_set_user_memory_region(kml, mem, false);
+ *   - accel/kvm/kvm-all.c|1366| <<kvm_set_phys_mem>> err = kvm_set_user_memory_region(kml, mem, true);
+ */
 static int kvm_set_user_memory_region(KVMMemoryListener *kml, KVMSlot *slot, bool new)
 {
     KVMState *s = kvm_state;
@@ -1266,6 +1272,11 @@ void kvm_set_max_memslot_size(hwaddr max_slot_size)
     kvm_max_slot_size = max_slot_size;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1565| <<kvm_region_commit>> kvm_set_phys_mem(kml, &u1->section, false);
+ *   - accel/kvm/kvm-all.c|1575| <<kvm_region_commit>> kvm_set_phys_mem(kml, &u1->section, true);
+ */
 /* Called with KVMMemoryListener.slots_lock held */
 static void kvm_set_phys_mem(KVMMemoryListener *kml,
                              MemoryRegionSection *section, bool add)
@@ -2697,6 +2708,10 @@ bool kvm_cpu_check_are_resettable(void)
     return kvm_arch_cpu_check_are_resettable();
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2728| <<kvm_cpu_synchronize_state>> run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
 {
     if (!cpu->vcpu_dirty) {
@@ -2711,6 +2726,18 @@ static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2995| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+ *   - target/arm/kvm64.c|1117| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+ *   - target/arm/kvm64.c|1187| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4872| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4891| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4909| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4914| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5385| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+ *   - target/s390x/kvm/kvm.c|1928| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+ */
 void kvm_cpu_synchronize_state(CPUState *cpu)
 {
     if (!cpu->vcpu_dirty) {
@@ -2718,6 +2745,17 @@ void kvm_cpu_synchronize_state(CPUState *cpu)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  do_kvm_cpu_synchronize_post_reset (cpu=0x55555735de90, arg=...) at ../accel/kvm/kvm-all.c:2723
+ * #1  0x000055555586a857 in process_queued_cpu_work (cpu=0x55555735de90) at ../cpu-common.c:360
+ * #2  0x0000555555b6047f in qemu_wait_io_event_common (cpu=0x55555735de90) at ../system/cpus.c:419
+ * #3  0x0000555555b60510 in qemu_wait_io_event (cpu=0x55555735de90) at ../system/cpus.c:437
+ * #4  0x0000555555df631e in kvm_vcpu_thread_fn (arg=0x55555735de90) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x00005555560017cc in qemu_thread_start (args=0x555557367a30) at ../util/qemu-thread-posix.c:541
+ * #6  0x00007ffff749f812 in start_thread () at /lib64/libc.so.6
+ * #7  0x00007ffff743f450 in clone3 () at /lib64/libc.so.6
+ */
 static void do_kvm_cpu_synchronize_post_reset(CPUState *cpu, run_on_cpu_data arg)
 {
     int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE);
@@ -2735,6 +2773,10 @@ void kvm_cpu_synchronize_post_reset(CPUState *cpu)
     run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-all.c|2762| <<kvm_cpu_synchronize_post_init>> run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
 {
     int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);
@@ -2746,6 +2788,10 @@ static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
     cpu->vcpu_dirty = false;
 }
 
+/*
+ * 在以下使用kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-accel-ops.c|104| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ */
 void kvm_cpu_synchronize_post_init(CPUState *cpu)
 {
     run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
@@ -2816,6 +2862,10 @@ static void kvm_eat_signals(CPUState *cpu)
     } while (sigismember(&chkset, SIG_IPI));
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|51| <<kvm_vcpu_thread_fn>> r = kvm_cpu_exec(cpu);
+ */
 int kvm_cpu_exec(CPUState *cpu)
 {
     struct kvm_run *run = cpu->kvm_run;
diff --git a/backends/hostmem-file.c b/backends/hostmem-file.c
index 361d4a810..5ad3aa626 100644
--- a/backends/hostmem-file.c
+++ b/backends/hostmem-file.c
@@ -36,6 +36,28 @@ struct HostMemoryBackendFile {
     OnOffAuto rom;
 };
 
+/*
+ * 非常一部分的例子:
+ *   - backends/hostmem-epc.c|60| <<sgx_epc_backend_class_init>> bc->alloc = sgx_epc_backend_memory_alloc;
+ *   - backends/hostmem-file.c|275| <<file_backend_class_init>> bc->alloc = file_backend_memory_alloc;
+ *   - backends/hostmem-memfd.c|139| <<memfd_backend_class_init>> bc->alloc = memfd_backend_memory_alloc;
+ *   - backends/hostmem-ram.c|43| <<ram_backend_class_init>> bc->alloc = ram_backend_memory_alloc;
+ *
+ * 一个例子:
+ * host_memory_backend_memory_complete()
+ * -> bc->alloc = file_backend_memory_alloc()
+ *    -> memory_region_init_ram_from_file()
+ *       -> qemu_ram_alloc_from_file()
+ *          -> qemu_ram_alloc_from_fd()
+ *             -> file_ram_alloc() 
+ *                -> qemu_ram_mmap()
+ *                   -> mmap_activate()
+ *                      -> mmap()
+ *                -> "unable to map backing store for guest RAM"
+ *
+ * 在以下使用file_backend_memory_alloc():
+ *   - backends/hostmem-file.c|275| <<file_backend_class_init>> bc->alloc = file_backend_memory_alloc;
+ */
 static void
 file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
@@ -43,6 +65,19 @@ file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
     error_setg(errp, "backend '%s' not supported on this host",
                object_get_typename(OBJECT(backend)));
 #else
+    /*
+     * struct HostMemoryBackendFile {
+     *     HostMemoryBackend parent_obj;
+     *
+     *     char *mem_path;
+     *     uint64_t align;
+     *     uint64_t offset;
+     *     bool discard_data;
+     *     bool is_pmem;
+     *     bool readonly;
+     *     OnOffAuto rom;
+     * };
+     */
     HostMemoryBackendFile *fb = MEMORY_BACKEND_FILE(backend);
     uint32_t ram_flags;
     gchar *name;
@@ -79,6 +114,12 @@ file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
         assert(false);
     }
 
+    /*
+     * called by:
+     *   - backends/hostmem-file.c|117| <<file_backend_memory_alloc>> name = host_memory_backend_get_name(backend);
+     *   - backends/hostmem-memfd.c|59| <<memfd_backend_memory_alloc>> name = host_memory_backend_get_name(backend);
+     *   - backends/hostmem-ram.c|30| <<ram_backend_memory_alloc>> name = host_memory_backend_get_name(backend);
+     */
     name = host_memory_backend_get_name(backend);
     ram_flags = backend->share ? RAM_SHARED : 0;
     ram_flags |= fb->readonly ? RAM_READONLY_FD : 0;
@@ -86,6 +127,9 @@ file_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
     ram_flags |= backend->reserve ? 0 : RAM_NORESERVE;
     ram_flags |= fb->is_pmem ? RAM_PMEM : 0;
     ram_flags |= RAM_NAMED_FILE;
+    /*
+     * 只在此处调用
+     */
     memory_region_init_ram_from_file(&backend->mr, OBJECT(backend), name,
                                      backend->size, fb->align, ram_flags,
                                      fb->mem_path, fb->offset, errp);
@@ -228,6 +272,10 @@ static void file_memory_backend_set_readonly(Object *obj, bool value,
     fb->readonly = value;
 }
 
+/*
+ * 347     object_class_property_add(oc, "rom", "OnOffAuto",
+ * 348         file_memory_backend_get_rom, file_memory_backend_set_rom, NULL, NULL);
+ */
 static void file_memory_backend_get_rom(Object *obj, Visitor *v,
                                         const char *name, void *opaque,
                                         Error **errp)
@@ -238,6 +286,10 @@ static void file_memory_backend_get_rom(Object *obj, Visitor *v,
     visit_type_OnOffAuto(v, name, &rom, errp);
 }
 
+/*
+ * 347     object_class_property_add(oc, "rom", "OnOffAuto",
+ * 348         file_memory_backend_get_rom, file_memory_backend_set_rom, NULL, NULL);
+ */
 static void file_memory_backend_set_rom(Object *obj, Visitor *v,
                                         const char *name, void *opaque,
                                         Error **errp)
@@ -254,6 +306,10 @@ static void file_memory_backend_set_rom(Object *obj, Visitor *v,
     visit_type_OnOffAuto(v, name, &fb->rom, errp);
 }
 
+/*
+ * 在以下使用file_backend_unparent():
+ *   - backends/hostmem-file.c|320| <<file_backend_class_init>> oc->unparent = file_backend_unparent;
+ */
 static void file_backend_unparent(Object *obj)
 {
     HostMemoryBackend *backend = MEMORY_BACKEND(obj);
@@ -309,6 +365,14 @@ static void file_backend_instance_finalize(Object *o)
     g_free(fb->mem_path);
 }
 
+/*
+ * -object thread-context,id=tc01,node-affinity=0 \
+ * -object memory-backend-file,id=ram01,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=0,policy=bind,prealloc-context=tc01 \
+ * -numa node,nodeid=0,cpus=0-1,memdev=ram01 \
+ * -object thread-context,id=tc02,node-affinity=1 \
+ * -object memory-backend-file,id=ram02,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=1,policy=bind,prealloc-context=tc02 \
+ * -numa node,nodeid=1,cpus=2-3,memdev=ram02 \
+ */
 static const TypeInfo file_backend_info = {
     .name = TYPE_MEMORY_BACKEND_FILE,
     .parent = TYPE_MEMORY_BACKEND,
diff --git a/backends/hostmem-memfd.c b/backends/hostmem-memfd.c
index 3fc85c3db..5dfd594e0 100644
--- a/backends/hostmem-memfd.c
+++ b/backends/hostmem-memfd.c
@@ -31,6 +31,10 @@ struct HostMemoryBackendMemfd {
     bool seal;
 };
 
+/*
+ * 在以下使用memfd_backend_memory_alloc():
+ *   - backends/hostmem-memfd.c|135| <<memfd_backend_class_init>> bc->alloc = memfd_backend_memory_alloc;
+ */
 static void
 memfd_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
diff --git a/backends/hostmem-ram.c b/backends/hostmem-ram.c
index b8e55cdbd..511faa5f6 100644
--- a/backends/hostmem-ram.c
+++ b/backends/hostmem-ram.c
@@ -16,6 +16,26 @@
 #include "qemu/module.h"
 #include "qom/object_interfaces.h"
 
+/*
+ * 如果只是普通的"-m xxxx"
+ * (gdb) bt
+ * #0  qemu_ram_mmap (fd=-1, size=137438953472, align=2097152, qemu_map_flags=0, map_offset=0) at ../util/mmap-alloc.c:253
+ * #1  0x0000555555ffae09 in qemu_anon_ram_alloc (size=137438953472, alignment=0x55555723f100, shared=false, noreserve=false) at ../util/oslib-posix.c:193
+ * #2  0x0000555555d9d25e in ram_block_add (new_block=0x55555732f2a0, errp=0x7fffffffdb28) at ../system/physmem.c:1830
+ * #3  0x0000555555d9dbf9 in qemu_ram_alloc_internal (size=137438953472, max_size=137438953472, resized=0x0, host=0x0, ram_flags=0, mr=0x55555723f070, errp=0x7fffffffdbc0) at ../system/physmem.c:2034
+ * #4  0x0000555555d9dd06 in qemu_ram_alloc (size=137438953472, ram_flags=0, mr=0x55555723f070, errp=0x7fffffffdbc0) at ../system/physmem.c:2054
+ * #5  0x0000555555d91807 in memory_region_init_ram_flags_nomigrate (mr=0x55555723f070, owner=0x55555723f000, name=0x5555570507d0 "pc.ram", size=137438953472, ram_flags=0, errp=0x7fffffffdc30)
+ *     at ../system/memory.c:1570
+ * #6  0x0000555555b7c406 in ram_backend_memory_alloc (backend=0x55555723f000, errp=0x7fffffffdc30) at ../backends/hostmem-ram.c:33
+ * #7  0x0000555555b7d0de in host_memory_backend_memory_complete (uc=0x55555723f000, errp=0x7fffffffdca8) at ../backends/hostmem.c:332
+ * #8  0x0000555555e121a2 in user_creatable_complete (uc=0x55555723f000, errp=0x7fffffffdd80) at ../qom/object_interfaces.c:28
+ * #9  0x0000555555922d73 in create_default_memdev (ms=0x5555572b7580, path=0x0, errp=0x7fffffffdd80) at ../hw/core/machine.c:1380
+ * #10 0x0000555555922f9d in machine_run_board_init (machine=0x5555572b7580, mem_path=0x0, errp=0x7fffffffdd80) at ../hw/core/machine.c:1432
+ * #11 0x0000555555b74388 in qemu_init_board () at ../system/vl.c:2613
+ * #12 0x0000555555b7460d in qmp_x_exit_preconfig (errp=0x555556fc8340 <error_fatal>) at ../system/vl.c:2704
+ * #13 0x0000555555b76fec in qemu_init (argc=19, argv=0x7fffffffe0a8) at ../system/vl.c:3753
+ * #14 0x0000555555e01cbf in main (argc=19, argv=0x7fffffffe0a8) at ../system/main.c:47
+ */
 static void
 ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
diff --git a/backends/hostmem.c b/backends/hostmem.c
index 747e7838c..393a83e2d 100644
--- a/backends/hostmem.c
+++ b/backends/hostmem.c
@@ -34,6 +34,12 @@ QEMU_BUILD_BUG_ON(HOST_MEM_POLICY_BIND != MPOL_BIND);
 QEMU_BUILD_BUG_ON(HOST_MEM_POLICY_INTERLEAVE != MPOL_INTERLEAVE);
 #endif
 
+/*
+ * called by:
+ *   - backends/hostmem-file.c|117| <<file_backend_memory_alloc>> name = host_memory_backend_get_name(backend);
+ *   - backends/hostmem-memfd.c|59| <<memfd_backend_memory_alloc>> name = host_memory_backend_get_name(backend);
+ *   - backends/hostmem-ram.c|30| <<ram_backend_memory_alloc>> name = host_memory_backend_get_name(backend);
+ */
 char *
 host_memory_backend_get_name(HostMemoryBackend *backend)
 {
@@ -44,6 +50,12 @@ host_memory_backend_get_name(HostMemoryBackend *backend)
     return object_get_canonical_path(OBJECT(backend));
 }
 
+/*
+ * 562     object_class_property_add(oc, "size", "int",
+ * 563         host_memory_backend_get_size,
+ * 564         host_memory_backend_set_size,
+ * 565         NULL, NULL);
+ */
 static void
 host_memory_backend_get_size(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
@@ -54,6 +66,12 @@ host_memory_backend_get_size(Object *obj, Visitor *v, const char *name,
     visit_type_size(v, name, &value, errp);
 }
 
+/*
+ * 562     object_class_property_add(oc, "size", "int",
+ * 563         host_memory_backend_get_size,
+ * 564         host_memory_backend_set_size,
+ * 565         NULL, NULL);
+ */
 static void
 host_memory_backend_set_size(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
@@ -271,6 +289,9 @@ static void host_memory_backend_set_prealloc_threads(Object *obj, Visitor *v,
     backend->prealloc_threads = value;
 }
 
+/*
+ * TypeInfo host_memory_backend_info.instance_init = host_memory_backend_init()
+ */
 static void host_memory_backend_init(Object *obj)
 {
     HostMemoryBackend *backend = MEMORY_BACKEND(obj);
@@ -283,6 +304,9 @@ static void host_memory_backend_init(Object *obj)
     backend->prealloc_threads = machine->smp.cpus;
 }
 
+/*
+ * TypeInfo host_memory_backend_info.instance_post_init = host_memory_backend_post_init()
+ */
 static void host_memory_backend_post_init(Object *obj)
 {
     object_apply_compat_props(obj);
@@ -319,6 +343,42 @@ size_t host_memory_backend_pagesize(HostMemoryBackend *memdev)
     return pagesize;
 }
 
+/*
+ * 在下面的例子调用2次:
+ *
+ * -object thread-context,id=tc01,node-affinity=0 \
+ * -object memory-backend-file,id=ram01,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=0,policy=bind,prealloc-context=tc01 \
+ * -numa node,nodeid=0,cpus=0-1,memdev=ram01 \
+ * -object thread-context,id=tc02,node-affinity=1 \
+ * -object memory-backend-file,id=ram02,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=1,policy=bind,prealloc-context=tc02 \
+ * -numa node,nodeid=1,cpus=2-3,memdev=ram02 \
+ *
+ * (gdb) bt
+ * #0  host_memory_backend_memory_complete (uc=0x555557245e50, errp=0x7fffffffda08) at ../backends/hostmem.c:324
+ * #1  0x0000555555e121a2 in user_creatable_complete (uc=0x555557245e50, errp=0x7fffffffda68) at ../qom/object_interfaces.c:28
+ * #2  0x0000555555e1262e in user_creatable_add_type (type=0x5555562af104 "memory-backend-file", id=0x555557053f10 "ram-node0", qdict=0x5555572d6b70,
+ *                                     v=0x5555572d0d90, errp=0x7fffffffda80) at ../qom/object_interfaces.c:125
+ * #3  0x0000555555e127d4 in user_creatable_add_qapi (options=0x555557053bc0, errp=0x555556fc8340 <error_fatal>) at ../qom/object_interfaces.c:157
+ * #4  0x0000555555b7231c in object_option_foreach_add (type_opt_predicate=0x555555b7295d <object_create_late>) at ../system/vl.c:1792
+ * #5  0x0000555555b729e4 in qemu_create_late_backends () at ../system/vl.c:2011
+ * #6  0x0000555555b76f4c in qemu_init (argc=31, argv=0x7fffffffde38) at ../system/vl.c:3727
+ * #7  0x0000555555e01cbf in main (argc=31, argv=0x7fffffffde38) at ../system/main.c:47
+ *
+ * 在以下使用host_memory_backend_memory_complete():
+ *   - backends/hostmem.c|488| <<host_memory_backend_class_init>> ucc->complete = host_memory_backend_memory_complete;
+ *
+ * 一个例子:
+ * host_memory_backend_memory_complete()
+ * -> bc->alloc = file_backend_memory_alloc()
+ *    -> memory_region_init_ram_from_file()
+ *       -> qemu_ram_alloc_from_file()
+ *          -> qemu_ram_alloc_from_fd()
+ *             -> file_ram_alloc() 
+ *                -> qemu_ram_mmap()
+ *                   -> mmap_activate()
+ *                      -> mmap()
+ *                -> "unable to map backing store for guest RAM"
+ */
 static void
 host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)
 {
@@ -328,6 +388,13 @@ host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)
     void *ptr;
     uint64_t sz;
 
+    /*
+     * 非常一部分的例子:
+     *   - backends/hostmem-epc.c|60| <<sgx_epc_backend_class_init>> bc->alloc = sgx_epc_backend_memory_alloc;
+     *   - backends/hostmem-file.c|275| <<file_backend_class_init>> bc->alloc = file_backend_memory_alloc;
+     *   - backends/hostmem-memfd.c|139| <<memfd_backend_class_init>> bc->alloc = memfd_backend_memory_alloc;
+     *   - backends/hostmem-ram.c|43| <<ram_backend_class_init>> bc->alloc = ram_backend_memory_alloc;
+     */
     if (bc->alloc) {
         bc->alloc(backend, &local_err);
         if (local_err) {
@@ -557,6 +624,15 @@ host_memory_backend_class_init(ObjectClass *oc, void *data)
         host_memory_backend_set_use_canonical_path);
 }
 
+/*
+ * -object thread-context,id=tc01,node-affinity=0 \
+ * -object memory-backend-file,id=ram01,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=0,policy=bind,prealloc-context=tc01 \
+ * -numa node,nodeid=0,cpus=0-1,memdev=ram01 \
+ * -object thread-context,id=tc02,node-affinity=1 \
+ * -object memory-backend-file,id=ram02,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=1,policy=bind,prealloc-context=tc02 \
+ * -numa node,nodeid=1,cpus=2-3,memdev=ram02 \
+ */
+
 static const TypeInfo host_memory_backend_info = {
     .name = TYPE_MEMORY_BACKEND,
     .parent = TYPE_OBJECT,
diff --git a/block/block-backend.c b/block/block-backend.c
index ec2114880..ee8897184 100644
--- a/block/block-backend.c
+++ b/block/block-backend.c
@@ -1590,6 +1590,15 @@ static void blk_aio_complete_bh(void *opaque)
     blk_aio_complete(acb);
 }
 
+/*
+ * called by:
+ *   - block/block-backend.c|1655| <<blk_aio_pwrite_zeroes>> return blk_aio_prwv(blk, offset, bytes, NULL, blk_aio_write_entry,
+ *   - block/block-backend.c|1726| <<blk_aio_preadv>> return blk_aio_prwv(blk, offset, qiov->size, qiov, blk_aio_read_entry, flags, cb, opaque);
+ *   - block/block-backend.c|1736| <<blk_aio_pwritev>> return blk_aio_prwv(blk, offset, qiov->size, qiov, blk_aio_write_entry, flags, cb, opaque);
+ *   - block/block-backend.c|1795| <<blk_aio_ioctl>> return blk_aio_prwv(blk, req, 0, buf, blk_aio_ioctl_entry, 0, cb, opaque);
+ *   - block/block-backend.c|1830| <<blk_aio_pdiscard>> return blk_aio_prwv(blk, offset, bytes, NULL, blk_aio_pdiscard_entry, 0,
+ *   - block/block-backend.c|1874| <<blk_aio_flush>> return blk_aio_prwv(blk, 0, 0, NULL, blk_aio_flush_entry, 0, cb, opaque);
+ */
 static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset,
                                 int64_t bytes,
                                 void *iobuf, CoroutineEntry co_entry,
@@ -1727,6 +1736,27 @@ BlockAIOCB *blk_aio_preadv(BlockBackend *blk, int64_t offset,
                         blk_aio_read_entry, flags, cb, opaque);
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/xen-block.c|398| <<xen_block_do_aio>> blk_aio_pwritev(dataplane->blk, request->start, &request->v, 0,
+ *   - hw/block/m25p80.c|562| <<flash_sync_page>> blk_aio_pwritev(s->blk, page * s->pi->page_size, iov, 0,
+ *   - hw/block/m25p80.c|578| <<flash_sync_area>> blk_aio_pwritev(s->blk, off, iov, 0, blk_sync_complete, iov);
+ *   - hw/block/virtio-blk.c|411| <<submit_requests>> blk_aio_pwritev(blk, sector_num << BDRV_SECTOR_BITS, qiov,
+ *   - hw/ide/core.c|1101| <<ide_sector_write>> s->pio_aiocb = blk_aio_pwritev(s->blk, sector_num << BDRV_SECTOR_BITS,
+ *   - hw/nvme/ctrl.c|1465| <<nvme_blk_write>> req->aiocb = blk_aio_pwritev(blk, offset, &req->sg.iov, 0, cb, req);
+ *   - hw/nvme/ctrl.c|2917| <<nvme_copy_out_cb>> iocb->aiocb = blk_aio_pwritev(ns->blkconf.blk, nvme_moff(ns, iocb->slba),
+ *   - hw/nvme/ctrl.c|3011| <<nvme_copy_in_completed_cb>> iocb->aiocb = blk_aio_pwritev(ns->blkconf.blk, nvme_l2b(ns, iocb->slba),
+ *   - hw/nvme/dif.c|530| <<nvme_dif_rw_mdata_out_cb>> req->aiocb = blk_aio_pwritev(blk, offset, &ctx->mdata.iov, 0,
+ *   - hw/nvme/dif.c|701| <<nvme_dif_rw>> req->aiocb = blk_aio_pwritev(ns->blkconf.blk, offset, &ctx->data.iov, 0,
+ *   - hw/scsi/scsi-disk.c|1846| <<scsi_write_same_complete>> r->req.aiocb = blk_aio_pwritev(s->qdev.conf.blk,
+ *   - hw/scsi/scsi-disk.c|1920| <<scsi_disk_emulate_write_same>> r->req.aiocb = blk_aio_pwritev(s->qdev.conf.blk,
+ *   - hw/scsi/scsi-disk.c|3109| <<scsi_dma_writev>> return blk_aio_pwritev(s->qdev.conf.blk, offset, iov, 0, cb, cb_opaque);
+ *   - qemu-img.c|4497| <<bench_cb>> acb = blk_aio_pwritev(b->blk, offset, b->qiov, 0, bench_cb, b);
+ *   - qemu-io-cmds.c|663| <<do_aio_writev>> blk_aio_pwritev(blk, offset, qiov, flags, aio_rw_done, &async_ret);
+ *   - qemu-io-cmds.c|1699| <<aio_write_f>> blk_aio_pwritev(blk, ctx->offset, &ctx->qiov, ctx->flags,
+ *   - system/dma-helpers.c|265| <<dma_blk_write_io_func>> return blk_aio_pwritev(blk, offset, iov, 0, cb, cb_opaque);
+ *   - tests/unit/test-replication.c|113| <<test_blk_write>> blk_aio_pwritev(blk, offset, &qiov, 0, blk_rw_done, &async_ret);
+ */
 BlockAIOCB *blk_aio_pwritev(BlockBackend *blk, int64_t offset,
                             QEMUIOVector *qiov, BdrvRequestFlags flags,
                             BlockCompletionFunc *cb, void *opaque)
diff --git a/block/file-posix.c b/block/file-posix.c
index b862406c7..cd366e4ba 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -1762,6 +1762,14 @@ static ssize_t handle_aiocb_rw_linear(RawPosixAIOData *aiocb, char *buf)
     return offset;
 }
 
+/*
+ * (gdb) bt
+ * #0  handle_aiocb_rw (opaque=0x7f25a45ea810) at ../block/file-posix.c:1767
+ * #1  0x00005579c6e1f097 in worker_thread (opaque=0x5579c95d2ec0) at ../util/thread-pool.c:111
+ * #2  0x00005579c6e027f2 in qemu_thread_start (args=0x5579c9ff0bb0) at ../util/qemu-thread-posix.c:541
+ * #3  0x00007f27bddc3ea5 in start_thread () at /lib64/libpthread.so.0
+ * #4  0x00007f27bdaec9fd in clone () at /lib64/libc.so.6
+ */
 static int handle_aiocb_rw(void *opaque)
 {
     RawPosixAIOData *aiocb = opaque;
@@ -2444,6 +2452,12 @@ static bool bdrv_qiov_is_aligned(BlockDriverState *bs, QEMUIOVector *qiov)
     return true;
 }
 
+/*
+ * called by:
+ *   - block/file-posix.c|2542| <<raw_co_preadv>> return raw_co_prw(bs, &offset, bytes, qiov, QEMU_AIO_READ);
+ *   - block/file-posix.c|2549| <<raw_co_pwritev>> return raw_co_prw(bs, &offset, bytes, qiov, QEMU_AIO_WRITE);
+ *   - block/file-posix.c|3532| <<raw_co_zone_append>> return raw_co_prw(bs, offset, len, qiov, QEMU_AIO_ZONE_APPEND);
+ */
 static int coroutine_fn raw_co_prw(BlockDriverState *bs, int64_t *offset_ptr,
                                    uint64_t bytes, QEMUIOVector *qiov, int type)
 {
diff --git a/block/io.c b/block/io.c
index 7e62fabbf..df2882c83 100644
--- a/block/io.c
+++ b/block/io.c
@@ -2239,6 +2239,15 @@ int coroutine_fn bdrv_co_pwritev(BdrvChild *child,
     return bdrv_co_pwritev_part(child, offset, bytes, qiov, 0, flags);
 }
 
+/*
+ * called by:
+ *   - block/block-backend.c|1450| <<blk_co_do_pwritev_part>> ret = bdrv_co_pwritev_part(blk->root, offset, bytes, qiov, qiov_offset,
+ *   - block/copy-on-read.c|191| <<cor_co_pwritev_part>> return bdrv_co_pwritev_part(bs->file, offset, bytes, qiov, qiov_offset,
+ *   - block/filter-compress.c|82| <<compress_co_pwritev_part>> return bdrv_co_pwritev_part(bs->file, offset, bytes, qiov, qiov_offset,
+ *   - block/io.c|2239| <<bdrv_co_pwritev>> return bdrv_co_pwritev_part(child, offset, bytes, qiov, 0, flags);
+ *   - block/preallocate.c|418| <<preallocate_co_pwritev_part>> return bdrv_co_pwritev_part(bs->file, offset, bytes, qiov, qiov_offset,
+ *   - block/qcow2.c|2623| <<qcow2_co_pwritev_task>> ret = bdrv_co_pwritev_part(s->data_file, host_offset,
+ */
 int coroutine_fn bdrv_co_pwritev_part(BdrvChild *child,
     int64_t offset, int64_t bytes, QEMUIOVector *qiov, size_t qiov_offset,
     BdrvRequestFlags flags)
diff --git a/cpu-common.c b/cpu-common.c
index c81fd72d1..204ac8fe1 100644
--- a/cpu-common.c
+++ b/cpu-common.c
@@ -130,6 +130,12 @@ struct qemu_work_item {
     bool free, exclusive, done;
 };
 
+/*
+ * called by:
+ *   - cpu-common.c|159| <<do_run_on_cpu>> queue_work_on_cpu(cpu, &wi);
+ *   - cpu-common.c|177| <<async_run_on_cpu>> queue_work_on_cpu(cpu, wi);
+ *   - cpu-common.c|331| <<async_safe_run_on_cpu>> queue_work_on_cpu(cpu, wi);
+ */
 static void queue_work_on_cpu(CPUState *cpu, struct qemu_work_item *wi)
 {
     qemu_mutex_lock(&cpu->work_mutex);
@@ -140,6 +146,10 @@ static void queue_work_on_cpu(CPUState *cpu, struct qemu_work_item *wi)
     qemu_cpu_kick(cpu);
 }
 
+/*
+ * called by:
+ *   - system/cpus.c|399| <<run_on_cpu>> do_run_on_cpu(cpu, func, data, &qemu_global_mutex);
+ */
 void do_run_on_cpu(CPUState *cpu, run_on_cpu_func func, run_on_cpu_data data,
                    QemuMutex *mutex)
 {
diff --git a/hw/core/cpu-common.c b/hw/core/cpu-common.c
index 82dae51a5..276b326c6 100644
--- a/hw/core/cpu-common.c
+++ b/hw/core/cpu-common.c
@@ -210,6 +210,11 @@ static void cpu_common_realizefn(DeviceState *dev, Error **errp)
     }
 
     if (dev->hotplugged) {
+        /*
+	 * x86_64的调用
+	 *   - hw/core/cpu-common.c|213| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+	 *   - system/cpus.c|155| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+	 */
         cpu_synchronize_post_init(cpu);
         cpu_resume(cpu);
     }
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index 43d863b0c..034316af9 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -881,11 +881,36 @@ Object *qdev_get_machine(void)
 
 static MachineInitPhase machine_phase;
 
+/*
+ * called by:
+ *   - hw/core/machine-qmp-cmds.c|141| <<qmp_set_numa_node>> if (phase_check(PHASE_MACHINE_INITIALIZED)) {
+ *   - hw/core/machine.c|1519| <<qemu_add_machine_init_done_notifier>> if (phase_check(PHASE_MACHINE_READY)) {
+ *   - hw/core/qdev.c|656| <<device_initfn>> if (phase_check(PHASE_MACHINE_READY)) {
+ *   - hw/pci/pci.c|1205| <<do_pci_register_device>> if (phase_check(PHASE_MACHINE_READY)) {
+ *   - hw/remote/machine.c|84| <<remote_machine_set_vfio_user>> if (phase_check(PHASE_MACHINE_CREATED)) {
+ *   - hw/remote/vfio-user-obj.c|735| <<vfu_object_init_ctx>> !phase_check(PHASE_MACHINE_READY)) {
+ *   - hw/remote/vfio-user-obj.c|864| <<vfu_object_init>> if (!phase_check(PHASE_MACHINE_READY)) {
+ *   - hw/usb/core.c|100| <<usb_wakeup>> if (!phase_check(PHASE_MACHINE_READY)) {
+ *   - monitor/hmp.c|218| <<cmd_available>> return phase_check(PHASE_MACHINE_READY) || cmd_can_preconfig(cmd);
+ *   - system/qdev-monitor.c|261| <<qdev_get_device_class>> (phase_check(PHASE_MACHINE_READY) && !dc->hotpluggable)) {
+ *   - system/qdev-monitor.c|671| <<qdev_device_add_from_qdict>> if (phase_check(PHASE_MACHINE_READY) && bus && !qbus_is_hotpluggable(bus)) {
+ *   - system/qdev-monitor.c|685| <<qdev_device_add_from_qdict>> if (phase_check(PHASE_MACHINE_READY)) {
+ *   - system/qdev-monitor.c|1146| <<qmp_command_available>> if (!phase_check(PHASE_MACHINE_READY) &&
+ *   - system/vl.c|2699| <<qmp_x_exit_preconfig>> if (phase_check(PHASE_MACHINE_INITIALIZED)) {
+ *   - ui/console.c|403| <<qemu_console_register>> } else if (!QEMU_IS_GRAPHIC_CONSOLE(c) || phase_check(PHASE_MACHINE_READY)) {
+ */
 bool phase_check(MachineInitPhase phase)
 {
     return machine_phase >= phase;
 }
 
+/*
+ * called by:
+ *   - hw/core/machine.c|1510| <<machine_run_board_init>> phase_advance(PHASE_MACHINE_INITIALIZED);
+ *   - hw/core/machine.c|1542| <<qdev_machine_creation_done>> phase_advance(PHASE_MACHINE_READY);
+ *   - system/vl.c|3691| <<qemu_init>> phase_advance(PHASE_MACHINE_CREATED);
+ *   - system/vl.c|3698| <<qemu_init>> phase_advance(PHASE_ACCEL_CREATED);
+ */
 void phase_advance(MachineInitPhase phase)
 {
     assert(machine_phase == phase - 1);
diff --git a/hw/i386/kvm/apic.c b/hw/i386/kvm/apic.c
index 1e89ca089..2e8be09c4 100644
--- a/hw/i386/kvm/apic.c
+++ b/hw/i386/kvm/apic.c
@@ -155,6 +155,17 @@ static void kvm_apic_post_load(APICCommonState *s)
     run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
 }
 
+/*
+ * (gdb) bt
+ * #0  do_inject_external_nmi (cpu=0x5555573a4d30, data=...) at ../hw/i386/kvm/apic.c:160
+ * #1  0x000055555586a857 in process_queued_cpu_work (cpu=0x5555573a4d30) at ../cpu-common.c:360
+ * #2  0x0000555555b6047f in qemu_wait_io_event_common (cpu=0x5555573a4d30) at ../system/cpus.c:419
+ * #3  0x0000555555b60510 in qemu_wait_io_event (cpu=0x5555573a4d30) at ../system/cpus.c:437
+ * #4  0x0000555555df631e in kvm_vcpu_thread_fn (arg=0x5555573a4d30) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x00005555560017cc in qemu_thread_start (args=0x5555573aed40) at ../util/qemu-thread-posix.c:541
+ * #6  0x00007ffff749f812 in start_thread () at /lib64/libc.so.6
+ * #7  0x00007ffff743f450 in clone3 () at /lib64/libc.so.6
+ */
 static void do_inject_external_nmi(CPUState *cpu, run_on_cpu_data data)
 {
     APICCommonState *s = data.host_ptr;
diff --git a/hw/i386/x86.c b/hw/i386/x86.c
index 2b6291ad8..ca372ca89 100644
--- a/hw/i386/x86.c
+++ b/hw/i386/x86.c
@@ -508,6 +508,33 @@ const CPUArchIdList *x86_possible_cpu_arch_ids(MachineState *ms)
     return ms->possible_cpus;
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_nmi (n=0x5555572bf2d0, cpu_index=2, errp=0x7fffffffce88) at ../hw/i386/x86.c:512
+ * #1  0x0000555555924607 in do_nmi (o=0x5555572bf2d0, opaque=0x7fffffffce80) at ../hw/core/nmi.c:45
+ * #2  0x0000555555e0f14e in do_object_child_foreach (obj=0x5555572bf7f0, fn=0x555555924594 <do_nmi>, opaque=0x7fffffffce80, recurse=false) at ../qom/object.c:1135
+ * #3  0x0000555555e0f1e4 in object_child_foreach (obj=0x5555572bf7f0, fn=0x555555924594 <do_nmi>, opaque=0x7fffffffce80) at ../qom/object.c:1153
+ * #4  0x000055555592465f in nmi_children (o=0x5555572bf7f0, ns=0x7fffffffce80) at ../hw/core/nmi.c:57
+ * #5  0x00005555559246a9 in nmi_monitor_handle (cpu_index=2, errp=0x7fffffffcee0) at ../hw/core/nmi.c:68
+ * #6  0x0000555555b61397 in qmp_inject_nmi (errp=0x7fffffffcee0) at ../system/cpus.c:827
+ * #7  0x000055555591eeea in hmp_nmi (mon=0x5555572d5bd0, qdict=0x55555813ce70) at ../hw/core/machine-hmp-cmds.c:233
+ * #8  0x0000555555bc5c9a in handle_hmp_command_exec (mon=0x5555572d5bd0, cmd=0x555556ee43e0 <hmp_cmds+5440>, qdict=0x55555813ce70) at ../monitor/hmp.c:1106
+ * #9  0x0000555555bc5ec7 in handle_hmp_command (mon=0x5555572d5bd0, cmdline=0x55555733c2a3 "") at ../monitor/hmp.c:1158
+ * #10 0x0000555555bc32df in monitor_command_cb (opaque=0x5555572d5bd0, cmdline=0x55555733c2a0 "nmi", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #11 0x0000555556032b80 in readline_handle_byte (rs=0x55555733c2a0, ch=13) at ../util/readline.c:419
+ * #12 0x0000555555bc698a in monitor_read (opaque=0x5555572d5bd0, buf=0x7fffffffd140 "\rЯd\376\177", size=1) at ../monitor/hmp.c:1390
+ * #13 0x0000555555f32a60 in qemu_chr_be_write_impl (s=0x555557100740, buf=0x7fffffffd140 "\rЯd\376\177", len=1) at ../chardev/char.c:202
+ * #14 0x0000555555f32ac4 in qemu_chr_be_write (s=0x555557100740, buf=0x7fffffffd140 "\rЯd\376\177", len=1) at ../chardev/char.c:214
+ * #15 0x0000555555f355da in fd_chr_read (chan=0x5555572a0670, cond=G_IO_IN, opaque=0x555557100740) at ../chardev/char-fd.c:72
+ * #16 0x0000555555e21ca2 in qio_channel_fd_source_dispatch (source=0x55555743df90, callback=0x555555f354b0 <fd_chr_read>, user_data=0x555557100740) at ../io/channel-watch.c:84
+ * #17 0x00007ffff7b33e2f in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #18 0x000055555601b933 in glib_pollfds_poll () at ../util/main-loop.c:290
+ * #19 0x000055555601b9b0 in os_host_main_loop_wait (timeout=142674550) at ../util/main-loop.c:313
+ * #20 0x000055555601babe in main_loop_wait (nonblocking=0) at ../util/main-loop.c:592
+ * #21 0x0000555555b6ea18 in qemu_main_loop () at ../system/runstate.c:782
+ * #22 0x0000555555e02d7d in qemu_default_main () at ../system/main.c:37
+ * #23 0x0000555555e02db8 in main (argc=23, argv=0x7fffffffe448) at ../system/main.c:48
+ */
 static void x86_nmi(NMIState *n, int cpu_index, Error **errp)
 {
     /* cpu index isn't used */
diff --git a/hw/intc/apic_common.c b/hw/intc/apic_common.c
index bccb4241c..0b7b4ea1a 100644
--- a/hw/intc/apic_common.c
+++ b/hw/intc/apic_common.c
@@ -121,6 +121,34 @@ void apic_handle_tpr_access_report(DeviceState *dev, target_ulong ip,
     vapic_report_tpr_access(s->vapic, CPU(s->cpu), ip, access);
 }
 
+/*
+ * (gdb) bt
+ * #0  apic_deliver_nmi (dev=0x5555570cb940) at ../hw/intc/apic_common.c:126
+ * #1  0x0000555555c34f91 in x86_nmi (n=0x5555572bf2d0, cpu_index=2, errp=0x7fffffffce88) at ../hw/i386/x86.c:522
+ * #2  0x0000555555924607 in do_nmi (o=0x5555572bf2d0, opaque=0x7fffffffce80) at ../hw/core/nmi.c:45
+ * #3  0x0000555555e0f14e in do_object_child_foreach (obj=0x5555572bf7f0, fn=0x555555924594 <do_nmi>, opaque=0x7fffffffce80, recurse=false) at ../qom/object.c:1135
+ * #4  0x0000555555e0f1e4 in object_child_foreach (obj=0x5555572bf7f0, fn=0x555555924594 <do_nmi>, opaque=0x7fffffffce80) at ../qom/object.c:1153
+ * #5  0x000055555592465f in nmi_children (o=0x5555572bf7f0, ns=0x7fffffffce80) at ../hw/core/nmi.c:57
+ * #6  0x00005555559246a9 in nmi_monitor_handle (cpu_index=2, errp=0x7fffffffcee0) at ../hw/core/nmi.c:68
+ * #7  0x0000555555b61397 in qmp_inject_nmi (errp=0x7fffffffcee0) at ../system/cpus.c:827
+ * #8  0x000055555591eeea in hmp_nmi (mon=0x5555572d5bd0, qdict=0x55555813ce70) at ../hw/core/machine-hmp-cmds.c:233
+ * #9  0x0000555555bc5c9a in handle_hmp_command_exec (mon=0x5555572d5bd0, cmd=0x555556ee43e0 <hmp_cmds+5440>, qdict=0x55555813ce70) at ../monitor/hmp.c:1106
+ * #10 0x0000555555bc5ec7 in handle_hmp_command (mon=0x5555572d5bd0, cmdline=0x55555733c2a3 "") at ../monitor/hmp.c:1158
+ * #11 0x0000555555bc32df in monitor_command_cb (opaque=0x5555572d5bd0, cmdline=0x55555733c2a0 "nmi", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #12 0x0000555556032b80 in readline_handle_byte (rs=0x55555733c2a0, ch=13) at ../util/readline.c:419
+ * #13 0x0000555555bc698a in monitor_read (opaque=0x5555572d5bd0, buf=0x7fffffffd140 "\rЯd\376\177", size=1) at ../monitor/hmp.c:1390
+ * #14 0x0000555555f32a60 in qemu_chr_be_write_impl (s=0x555557100740, buf=0x7fffffffd140 "\rЯd\376\177", len=1) at ../chardev/char.c:202
+ * #15 0x0000555555f32ac4 in qemu_chr_be_write (s=0x555557100740, buf=0x7fffffffd140 "\rЯd\376\177", len=1) at ../chardev/char.c:214
+ * #16 0x0000555555f355da in fd_chr_read (chan=0x5555572a0670, cond=G_IO_IN, opaque=0x555557100740) at ../chardev/char-fd.c:72
+ * #17 0x0000555555e21ca2 in qio_channel_fd_source_dispatch (source=0x55555743df90, callback=0x555555f354b0 <fd_chr_read>, user_data=0x555557100740) at ../io/channel-watch.c:84
+ * #18 0x00007ffff7b33e2f in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #19 0x000055555601b933 in glib_pollfds_poll () at ../util/main-loop.c:290
+ * #20 0x000055555601b9b0 in os_host_main_loop_wait (timeout=142674550) at ../util/main-loop.c:313
+ * #21 0x000055555601babe in main_loop_wait (nonblocking=0) at ../util/main-loop.c:592
+ * #22 0x0000555555b6ea18 in qemu_main_loop () at ../system/runstate.c:782
+ * #23 0x0000555555e02d7d in qemu_default_main () at ../system/main.c:37
+ * #24 0x0000555555e02db8 in main (argc=23, argv=0x7fffffffe448) at ../system/main.c:48
+ */
 void apic_deliver_nmi(DeviceState *dev)
 {
     APICCommonState *s = APIC_COMMON(dev);
diff --git a/hw/vfio/helpers.c b/hw/vfio/helpers.c
index 168847e7c..0cdc735cc 100644
--- a/hw/vfio/helpers.c
+++ b/hw/vfio/helpers.c
@@ -398,6 +398,12 @@ static void vfio_subregion_unmap(VFIORegion *region, int index)
     region->mmaps[index].mmap = NULL;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/display.c|449| <<vfio_display_region_update>> ret = vfio_region_mmap(&dpy->region.buffer);
+ *   - hw/vfio/pci.c|1775| <<vfio_bar_register>> if (vfio_region_mmap(&bar->region)) {
+ *   - hw/vfio/platform.c|622| <<vfio_platform_realize>> if (vfio_region_mmap(vdev->regions[i])) {
+ */
 int vfio_region_mmap(VFIORegion *region)
 {
     int i, prot = 0;
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index c62c02f7b..a14e3b7f9 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -1755,6 +1755,10 @@ static void vfio_bars_prepare(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1789| <<vfio_bars_register>> vfio_bar_register(vdev, i);
+ */
 static void vfio_bar_register(VFIOPCIDevice *vdev, int nr)
 {
     VFIOBAR *bar = &vdev->bars[nr];
diff --git a/hw/virtio/vhost.c b/hw/virtio/vhost.c
index 2c9ac7946..bde064570 100644
--- a/hw/virtio/vhost.c
+++ b/hw/virtio/vhost.c
@@ -43,6 +43,13 @@
     do { } while (0)
 #endif
 
+/*
+ * 在以下使用static的vhost_log:
+ *   - hw/virtio/vhost.c|406| <<vhost_log_get>> struct vhost_log *log = share ? vhost_log_shm : vhost_log;
+ *   - hw/virtio/vhost.c|413| <<vhost_log_get>> vhost_log = log;
+ *   - hw/virtio/vhost.c|444| <<vhost_log_put>> if (vhost_log == log) {
+ *   - hw/virtio/vhost.c|446| <<vhost_log_put>> vhost_log = NULL;
+ */
 static struct vhost_log *vhost_log;
 static struct vhost_log *vhost_log_shm;
 
@@ -86,6 +93,12 @@ unsigned int vhost_get_free_memslots(void)
     return free;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|171| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr, reg->guest_phys_addr, range_get_last(reg->guest_phys_addr, reg->memory_size));
+ *   - hw/virtio/vhost.c|218| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr, phys, range_get_last(phys, s));
+ *   - hw/virtio/vhost.c|224| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr, vq->used_phys, range_get_last(vq->used_phys, vq->used_size));
+ */
 static void vhost_dev_sync_region(struct vhost_dev *dev,
                                   MemoryRegionSection *section,
                                   uint64_t mfirst, uint64_t mlast,
@@ -149,6 +162,47 @@ bool vhost_dev_has_iommu(struct vhost_dev *dev)
     }
 }
 
+/*
+ * 连vnc会
+ * (gdb) bt
+ * #0  vhost_sync_dirty_bitmap (dev=0x555557056990, section=0x7fffffffdf50, first=0, last=18446744073709551615) at ../hw/virtio/vhost.c:156
+ * #1  0x0000555555b262c8 in vhost_log_sync (listener=0x555557056998, section=0x7fffffffdf50) at ../hw/virtio/vhost.c:237
+ * #2  0x0000555555d9457b in memory_region_sync_dirty_bitmap (mr=0x555557c553d0, last_stage=false) at ../system/memory.c:2279
+ * #3  0x0000555555d94994 in memory_region_snapshot_and_clear_dirty (mr=0x555557c553d0, addr=0, size=4096000, client=0) at ../system/memory.c:2354
+ * #4  0x0000555555969a55 in vga_draw_graphic (s=0x555557c553c0, full_update=0) at ../hw/display/vga.c:1668
+ * #5  0x000055555596a015 in vga_update_display (opaque=0x555557c553c0) at ../hw/display/vga.c:1791
+ * #6  0x000055555586de25 in graphic_hw_update (con=0x555557d71040) at ../ui/console.c:143
+ * #7  0x000055555588a147 in vnc_refresh (dcl=0x5555580a4250) at ../ui/vnc.c:3204
+ * #8  0x000055555586fd7f in dpy_refresh (s=0x5555572dbb20) at ../ui/console.c:959
+ * #9  0x000055555586dbb1 in gui_update (opaque=0x5555572dbb20) at ../ui/console.c:89
+ * #10 0x00005555560204da in timerlist_run_timers (timer_list=0x55555705ad00) at ../util/qemu-timer.c:576
+ * #11 0x0000555556020584 in qemu_clock_run_timers (type=QEMU_CLOCK_REALTIME) at ../util/qemu-timer.c:590
+ * #12 0x0000555556020845 in qemu_clock_run_all_timers () at ../util/qemu-timer.c:672
+ * #13 0x000055555601bb00 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:603
+ * #14 0x0000555555b6ea18 in qemu_main_loop () at ../system/runstate.c:782
+ * #15 0x0000555555e02d7d in qemu_default_main () at ../system/main.c:37
+ * #16 0x0000555555e02db8 in main (argc=23, argv=0x7fffffffe448) at ../system/main.c:48
+ *
+ * (gdb) bt
+ * #0  vhost_sync_dirty_bitmap (dev=0x555557056990, section=0x7ffe42b2a5b0, first=0, last=18446744073709551615) at ../hw/virtio/vhost.c:156
+ * #1  0x0000555555b262c8 in vhost_log_sync (listener=0x555557056998, section=0x7ffe42b2a5b0) at ../hw/virtio/vhost.c:237
+ * #2  0x0000555555d9457b in memory_region_sync_dirty_bitmap (mr=0x0, last_stage=false) at ../system/memory.c:2279
+ * #3  0x0000555555d96484 in memory_global_dirty_log_sync (last_stage=false) at ../system/memory.c:2885
+ * #4  0x0000555555da947e in migration_bitmap_sync (rs=0x7ffe38002270, last_stage=false) at ../migration/ram.c:1046
+ * #5  0x0000555555da96b6 in migration_bitmap_sync_precopy (rs=0x7ffe38002270, last_stage=false) at ../migration/ram.c:1094
+ * #6  0x0000555555dac854 in ram_init_bitmaps (rs=0x7ffe38002270) at ../migration/ram.c:2811
+ * #7  0x0000555555dac8f3 in ram_init_all (rsp=0x555556fba420 <ram_state>) at ../migration/ram.c:2834
+ * #8  0x0000555555dacc28 in ram_save_setup (f=0x5555572c9a30, opaque=0x555556fba420 <ram_state>) at ../migration/ram.c:2947
+ * #9  0x0000555555bb55e0 in qemu_savevm_state_setup (f=0x5555572c9a30) at ../migration/savevm.c:1345
+ * #10 0x0000555555b9f3d4 in migration_thread (opaque=0x555557058db0) at ../migration/migration.c:3340
+ * #11 0x00005555560017cc in qemu_thread_start (args=0x5555578610b0) at ../util/qemu-thread-posix.c:541
+ * #12 0x00007ffff749f812 in start_thread () at /lib64/libc.so.6
+ * #13 0x00007ffff743f450 in clone3 () at /lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/virtio/vhost.c|237| <<vhost_log_sync>> vhost_sync_dirty_bitmap(dev, section, 0x0, ~0x0ULL);
+ *   - hw/virtio/vhost.c|247| <<vhost_log_sync_range>> vhost_sync_dirty_bitmap(dev, section, first, last);
+ */
 static int vhost_sync_dirty_bitmap(struct vhost_dev *dev,
                                    MemoryRegionSection *section,
                                    hwaddr first,
@@ -166,6 +220,17 @@ static int vhost_sync_dirty_bitmap(struct vhost_dev *dev,
     start_addr = MAX(first, start_addr);
     end_addr = MIN(last, end_addr);
 
+    /*
+     * struct vhost_dev *dev:
+     * -> struct vhost_memory *mem;
+     *    -> uint32_t nregions;
+     *    -> uint32_t padding;
+     *    -> struct vhost_memory_region regions[];
+     *       -> uint64_t guest_phys_addr;
+     *       -> uint64_t memory_size; // bytes
+     *       -> uint64_t userspace_addr;
+     *       -> uint64_t flags_padding; // No flags are currently specified.
+     */
     for (i = 0; i < dev->mem->nregions; ++i) {
         struct vhost_memory_region *reg = dev->mem->regions + i;
         vhost_dev_sync_region(dev, section, start_addr, end_addr,
@@ -229,6 +294,37 @@ static int vhost_sync_dirty_bitmap(struct vhost_dev *dev,
     return 0;
 }
 
+/*
+ * 在以下使用log_sync:
+ *   - accel/hvf/hvf-accel-ops.c|312| <<global>> .log_sync = hvf_log_sync,
+ *   - hw/i386/xen/xen-hvm.c|467| <<global>> .log_sync = xen_log_sync,
+ *   - hw/vfio/common.c|1348| <<global>> .log_sync = vfio_listener_log_sync,
+ *   - target/i386/nvmm/nvmm-all.c|1129| <<global>> .log_sync = nvmm_log_sync,
+ *   - target/i386/whpx/whpx-all.c|2413| <<global>> .log_sync = whpx_log_sync,
+ *   - accel/kvm/kvm-all.c|1758| <<kvm_memory_listener_register>> kml->listener.log_sync = kvm_log_sync;
+ *   - hw/arm/xen_arm.c|46| <<OBJECT_DECLARE_SIMPLE_TYPE>> .log_sync = NULL,
+ *   - hw/virtio/vhost.c|1507| <<vhost_dev_init>> .log_sync = vhost_log_sync,
+ *   - system/memory.c|2307| <<memory_region_sync_dirty_bitmap>> if (listener->log_sync) {
+ *   - system/memory.c|2313| <<memory_region_sync_dirty_bitmap>> listener->log_sync(listener, &mrs);
+ *   - system/memory.c|3088| <<memory_listener_register>> assert(!(listener->log_sync && listener->log_sync_global));
+ *
+ * 1514     hdev->memory_listener = (MemoryListener) {
+ * 1515         .name = "vhost",          
+ * 1516         .begin = vhost_begin,
+ * 1517         .commit = vhost_commit,
+ * 1518         .region_add = vhost_region_addnop,
+ * 1519         .region_nop = vhost_region_addnop,
+ * 1520         .log_start = vhost_log_start,
+ * 1521         .log_stop = vhost_log_stop,
+ * 1522         .log_sync = vhost_log_sync,
+ * 1523         .log_global_start = vhost_log_global_start,
+ * 1524         .log_global_stop = vhost_log_global_stop,
+ * 1525         .priority = MEMORY_LISTENER_PRIORITY_DEV_BACKEND
+ * 1526     };
+ *
+ * 在以下使用vhost_log_sync():
+ *   - hw/virtio/vhost.c|1507| <<vhost_dev_init>> .log_sync = vhost_log_sync,
+ */
 static void vhost_log_sync(MemoryListener *listener,
                           MemoryRegionSection *section)
 {
@@ -237,6 +333,10 @@ static void vhost_log_sync(MemoryListener *listener,
     vhost_sync_dirty_bitmap(dev, section, 0x0, ~0x0ULL);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|352| <<vhost_log_put>> vhost_log_sync_range(dev, 0, dev->log_size * VHOST_LOG_CHUNK - 1);
+ */
 static void vhost_log_sync_range(struct vhost_dev *dev,
                                  hwaddr first, hwaddr last)
 {
@@ -337,6 +437,13 @@ static struct vhost_log *vhost_log_get(uint64_t size, bool share)
     return log;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|390| <<vhost_dev_log_resize>> vhost_log_put(dev, true);
+ *   - hw/virtio/vhost.c|1016| <<vhost_migration_log>> vhost_log_put(dev, false);
+ *   - hw/virtio/vhost.c|2081| <<vhost_dev_start>> vhost_log_put(hdev, false);
+ *   - hw/virtio/vhost.c|2138| <<vhost_dev_stop>> vhost_log_put(hdev, true);
+ */
 static void vhost_log_put(struct vhost_dev *dev, bool sync)
 {
     struct vhost_log *log = dev->log;
@@ -556,6 +663,48 @@ static void vhost_begin(MemoryListener *listener)
     dev->n_tmp_sections = 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_commit (listener=0x555557056998) at ../hw/virtio/vhost.c:561
+ * #1  0x0000555555d9189e in memory_region_transaction_commit () at ../system/memory.c:1137
+ * #2  0x0000555555d959ec in memory_region_del_subregion (mr=0x55555713c800, subregion=0x55555785c340) at ../system/memory.c:2680
+ * #3  0x0000555555a4a8b7 in pci_update_mappings (d=0x55555785a190) at ../hw/pci/pci.c:1539
+ * #4  0x0000555555a4ad39 in pci_default_write_config (d=0x55555785a190, addr=4, val_in=256, l=2) at ../hw/pci/pci.c:1607
+ * #5  0x0000555555a4f838 in pci_host_config_write_common (pci_dev=0x55555785a190, addr=4, limit=256, val=256, len=2) at ../hw/pci/pci_host.c:96
+ * #6  0x0000555555a4fa5e in pci_data_write (s=0x5555573e55f0, addr=2147485956, val=256, len=2) at ../hw/pci/pci_host.c:138
+ * #7  0x0000555555a4fbf5 in pci_host_data_write (opaque=0x5555573af0a0, addr=0, val=256, len=2) at ../hw/pci/pci_host.c:188
+ * #8  0x0000555555d8f37d in memory_region_write_accessor (mr=0x5555573af4e0, addr=0, value=0x7ffe67dfe5a8, size=2, shift=0, mask=65535, attrs=...) at ../system/memory.c:497
+ * #9  0x0000555555d8f692 in access_with_adjusted_size (addr=0, value=0x7ffe67dfe5a8, size=2, access_size_min=1, access_size_max=4, access_fn=
+ *                             0x555555d8f287 <memory_region_write_accessor>, mr=0x5555573af4e0, attrs=...) at ../system/memory.c:573
+ * #10 0x0000555555d92776 in memory_region_dispatch_write (mr=0x5555573af4e0, addr=0, data=256, op=MO_16, attrs=...) at ../system/memory.c:1521
+ * #11 0x0000555555da00c4 in flatview_write_continue (fv=0x7fffe8032220, addr=3324, attrs=..., ptr=0x7ffff42a3000, len=2, addr1=0, l=2, mr=0x5555573af4e0) at ../system/physmem.c:2714
+ * #12 0x0000555555da0227 in flatview_write (fv=0x7fffe8032220, addr=3324, attrs=..., buf=0x7ffff42a3000, len=2) at ../system/physmem.c:2756
+ * #13 0x0000555555da05d7 in address_space_write (as=0x555556fba0a0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff42a3000, len=2) at ../system/physmem.c:2863
+ * #14 0x0000555555da0644 in address_space_rw (as=0x555556fba0a0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff42a3000, len=2, is_write=true) at ../system/physmem.c:2873
+ * #15 0x0000555555df2d18 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff42a3000, direction=1, size=2, count=1) at ../accel/kvm/kvm-all.c:2632
+ * #16 0x0000555555df35bb in kvm_cpu_exec (cpu=0x55555739b350) at ../accel/kvm/kvm-all.c:2905
+ * #17 0x0000555555df62fa in kvm_vcpu_thread_fn (arg=0x55555739b350) at ../accel/kvm/kvm-accel-ops.c:51
+ * #18 0x00005555560017cc in qemu_thread_start (args=0x5555573a42b0) at ../util/qemu-thread-posix.c:541
+ * #19 0x00007ffff749f812 in start_thread () at /lib64/libc.so.6
+ * #20 0x00007ffff743f450 in clone3 () at /lib64/libc.so.6
+ *
+ * 1606     hdev->memory_listener = (MemoryListener) {
+ * 1607         .name = "vhost",
+ * 1608         .begin = vhost_begin,
+ * 1609         .commit = vhost_commit,
+ * 1610         .region_add = vhost_region_addnop,
+ * 1611         .region_nop = vhost_region_addnop,
+ * 1612         .log_start = vhost_log_start,
+ * 1613         .log_stop = vhost_log_stop,
+ * 1614         .log_sync = vhost_log_sync,
+ * 1615         .log_global_start = vhost_log_global_start,
+ * 1616         .log_global_stop = vhost_log_global_stop,
+ * 1617         .priority = MEMORY_LISTENER_PRIORITY_DEV_BACKEND
+ * 1618     };
+ *
+ * 在以下使用vhost_commit():
+ *   - hw/virtio/vhost.c|1591| <<vhost_dev_init>> .commit = vhost_commit,
+ */
 static void vhost_commit(MemoryListener *listener)
 {
     struct vhost_dev *dev = container_of(listener, struct vhost_dev,
@@ -598,6 +747,13 @@ static void vhost_commit(MemoryListener *listener)
     /* Rebuild the regions list from the new sections list */
     regions_size = offsetof(struct vhost_memory, regions) +
                        dev->n_mem_sections * sizeof dev->mem->regions[0];
+    /*
+     * struct vhost_dev *dev:
+     * -> struct vhost_memory *mem;
+     *    -> uint32_t nregions;
+     *    -> uint32_t padding;
+     *    -> struct vhost_memory_region regions[];
+     */
     dev->mem = g_realloc(dev->mem, regions_size);
     dev->mem->nregions = dev->n_mem_sections;
 
@@ -609,6 +765,14 @@ static void vhost_commit(MemoryListener *listener)
     }
 
     for (i = 0; i < dev->n_mem_sections; i++) {
+        /*
+	 * struct vhost_memory_region {
+	 *     uint64_t guest_phys_addr;
+	 *     uint64_t memory_size; // bytes
+	 *     uint64_t userspace_addr;
+	 *     uint64_t flags_padding; // No flags are currently specified.
+	 * };
+	 */
         struct vhost_memory_region *cur_vmr = dev->mem->regions + i;
         struct MemoryRegionSection *mrs = dev->mem_sections + i;
 
@@ -675,6 +839,28 @@ out:
  * and for each region (via the _add and _nop methods) to
  * join neighbours.
  */
+/*
+ * (gdb) bt
+ * #0  vhost_region_add_section (dev=0x5555572db030, section=0x7fffffffdcc0) at ../hw/virtio/vhost.c:681
+ * #1  0x0000555555b27839 in vhost_region_addnop (listener=0x5555572db038, section=0x7fffffffdcc0) at ../hw/virtio/vhost.c:794
+ * #2  0x0000555555d9138d in address_space_update_topology_pass (as=0x555556fba100 <address_space_memory>, old_view=0x555557711610, new_view=0x55555772cf90, adding=true) at ../system/memory.c:1004
+ * #3  0x0000555555d9168d in address_space_set_flatview (as=0x555556fba100 <address_space_memory>) at ../system/memory.c:1080
+ * #4  0x0000555555d91846 in memory_region_transaction_commit () at ../system/memory.c:1132
+ * #5  0x0000555555d95725 in memory_region_update_container_subregions (subregion=0x5555570a8c00) at ../system/memory.c:2630
+ * #6  0x0000555555d957d0 in memory_region_add_subregion_common (mr=0x5555572c8400, offset=0, subregion=0x5555570a8c00) at ../system/memory.c:2645
+ * #7  0x0000555555d9580c in memory_region_add_subregion (mr=0x5555572c8400, offset=0, subregion=0x5555570a8c00) at ../system/memory.c:2653
+ * #8  0x0000555555c5dc59 in pc_memory_init (pcms=0x5555572bf2d0, system_memory=0x5555572c8400, rom_memory=0x5555570fc6e0, pci_hole64_size=2147483648) at ../hw/i386/pc.c:954
+ * #9  0x0000555555c3f9e7 in pc_init1 (machine=0x5555572bf2d0, host_type=0x555556219858 "i440FX-pcihost", pci_type=0x555556219851 "i440FX") at ../hw/i386/pc_piix.c:246
+ * #10 0x0000555555c405d7 in pc_init_v8_2 (machine=0x5555572bf2d0) at ../hw/i386/pc_piix.c:555
+ * #11 0x00005555559243b5 in machine_run_board_init (machine=0x5555572bf2d0, mem_path=0x0, errp=0x7fffffffe120) at ../hw/core/machine.c:1509
+ * #12 0x0000555555b75478 in qemu_init_board () at ../system/vl.c:2613
+ * #13 0x0000555555b756fd in qmp_x_exit_preconfig (errp=0x555556fce260 <error_fatal>) at ../system/vl.c:2704
+ * #14 0x0000555555b780dc in qemu_init (argc=23, argv=0x7fffffffe448) at ../system/vl.c:3753
+ * #15 0x0000555555e02daf in main (argc=23, argv=0x7fffffffe448) at ../system/main.c:47
+ *
+ * called by:
+ *   - hw/virtio/vhost.c|934| <<vhost_region_addnop>> vhost_region_add_section(dev, section);
+ */
 static void vhost_region_add_section(struct vhost_dev *dev,
                                      MemoryRegionSection *section)
 {
@@ -770,6 +956,15 @@ static void vhost_region_add_section(struct vhost_dev *dev,
 
     if (need_add) {
         ++dev->n_tmp_sections;
+	/*
+	 * 在以下使用vhost_dev->tmp_sections:
+	 *   - hw/virtio/vhost.c|662| <<vhost_begin>> dev->tmp_sections = NULL;
+	 *   - hw/virtio/vhost.c|702| <<vhost_commit>> dev->mem_sections = dev->tmp_sections;
+	 *   - hw/virtio/vhost.c|856| <<vhost_region_add_section>> MemoryRegionSection *prev_sec = dev->tmp_sections +
+	 *   - hw/virtio/vhost.c|913| <<vhost_region_add_section>> dev->tmp_sections = g_renew(MemoryRegionSection, dev->tmp_sections,
+	 *   - hw/virtio/vhost.c|915| <<vhost_region_add_section>> dev->tmp_sections[dev->n_tmp_sections - 1] = *section;
+	 *   - hw/virtio/vhost.c|919| <<vhost_region_add_section>> dev->tmp_sections[dev->n_tmp_sections - 1].fv = NULL;
+	 */
         dev->tmp_sections = g_renew(MemoryRegionSection, dev->tmp_sections,
                                     dev->n_tmp_sections);
         dev->tmp_sections[dev->n_tmp_sections - 1] = *section;
@@ -781,6 +976,70 @@ static void vhost_region_add_section(struct vhost_dev *dev,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_region_add_section (dev=0x5555572db3d0, section=0x7ffe66dfc1d0) at ../hw/virtio/vhost.c:681
+ * #1  0x0000555555b27839 in vhost_region_addnop (listener=0x5555572db3d8, section=0x7ffe66dfc1d0) at ../hw/virtio/vhost.c:794
+ * #2  0x0000555555d91169 in address_space_update_topology_pass (as=0x555556fba100 <address_space_memory>, old_view=0x7fffec2ab0a0, new_view=0x7ffe5c054f00, adding=true) at ../system/memory.c:985
+ * #3  0x0000555555d9168d in address_space_set_flatview (as=0x555556fba100 <address_space_memory>) at ../system/memory.c:1080
+ * #4  0x0000555555d91846 in memory_region_transaction_commit () at ../system/memory.c:1132
+ * #5  0x0000555555d959ec in memory_region_del_subregion (mr=0x55555713c800, subregion=0x55555785cce0) at ../system/memory.c:2680
+ * #6  0x0000555555a4a8b7 in pci_update_mappings (d=0x55555785ab30) at ../hw/pci/pci.c:1539
+ * #7  0x0000555555a4ad39 in pci_default_write_config (d=0x55555785ab30, addr=4, val_in=256, l=2) at ../hw/pci/pci.c:1607
+ * #8  0x0000555555a4f838 in pci_host_config_write_common (pci_dev=0x55555785ab30, addr=4, limit=256, val=256, len=2) at ../hw/pci/pci_host.c:96
+ * #9  0x0000555555a4fa5e in pci_data_write (s=0x5555573e6060, addr=2147485956, val=256, len=2) at ../hw/pci/pci_host.c:138
+ * #10 0x0000555555a4fbf5 in pci_host_data_write (opaque=0x5555573afb10, addr=0, val=256, len=2) at ../hw/pci/pci_host.c:188
+ * #11 0x0000555555d8f37d in memory_region_write_accessor (mr=0x5555573aff50, addr=0, value=0x7ffe66dfc5a8, size=2, shift=0, mask=65535, attrs=...) at ../system/memory.c:497
+ * #12 0x0000555555d8f692 in access_with_adjusted_size (addr=0, value=0x7ffe66dfc5a8, size=2, access_size_min=1, access_size_max=4, access_fn=
+ *                                    0x555555d8f287 <memory_region_write_accessor>, mr=0x5555573aff50, attrs=...) at ../system/memory.c:573
+ * #13 0x0000555555d92776 in memory_region_dispatch_write (mr=0x5555573aff50, addr=0, data=256, op=MO_16, attrs=...) at ../system/memory.c:1521
+ * #14 0x0000555555da00c4 in flatview_write_continue (fv=0x7fffec281390, addr=3324, attrs=..., ptr=0x7ffff42a0000, len=2, addr1=0, l=2, mr=0x5555573aff50) at ../system/physmem.c:2714
+ * #15 0x0000555555da0227 in flatview_write (fv=0x7fffec281390, addr=3324, attrs=..., buf=0x7ffff42a0000, len=2) at ../system/physmem.c:2756
+ * #16 0x0000555555da05d7 in address_space_write (as=0x555556fba0a0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff42a0000, len=2) at ../system/physmem.c:2863
+ * #17 0x0000555555da0644 in address_space_rw (as=0x555556fba0a0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff42a0000, len=2, is_write=true) at ../system/physmem.c:2873
+ * #18 0x0000555555df2d18 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff42a0000, direction=1, size=2, count=1) at ../accel/kvm/kvm-all.c:2632
+ * #19 0x0000555555df35bb in kvm_cpu_exec (cpu=0x5555573a4d30) at ../accel/kvm/kvm-all.c:2905
+ * #20 0x0000555555df62fa in kvm_vcpu_thread_fn (arg=0x5555573a4d30) at ../accel/kvm/kvm-accel-ops.c:51
+ * #21 0x00005555560017cc in qemu_thread_start (args=0x5555573aed40) at ../util/qemu-thread-posix.c:541
+ * #22 0x00007ffff749f812 in start_thread () at /lib64/libc.so.6
+ * #23 0x00007ffff743f450 in clone3 () at /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  vhost_region_add_section (dev=0x5555572db030, section=0x7fffffffdcc0) at ../hw/virtio/vhost.c:681
+ * #1  0x0000555555b27839 in vhost_region_addnop (listener=0x5555572db038, section=0x7fffffffdcc0) at ../hw/virtio/vhost.c:794
+ * #2  0x0000555555d9138d in address_space_update_topology_pass (as=0x555556fba100 <address_space_memory>, old_view=0x555557711610, new_view=0x55555772cf90, adding=true) at ../system/memory.c:1004
+ * #3  0x0000555555d9168d in address_space_set_flatview (as=0x555556fba100 <address_space_memory>) at ../system/memory.c:1080
+ * #4  0x0000555555d91846 in memory_region_transaction_commit () at ../system/memory.c:1132
+ * #5  0x0000555555d95725 in memory_region_update_container_subregions (subregion=0x5555570a8c00) at ../system/memory.c:2630
+ * #6  0x0000555555d957d0 in memory_region_add_subregion_common (mr=0x5555572c8400, offset=0, subregion=0x5555570a8c00) at ../system/memory.c:2645
+ * #7  0x0000555555d9580c in memory_region_add_subregion (mr=0x5555572c8400, offset=0, subregion=0x5555570a8c00) at ../system/memory.c:2653
+ * #8  0x0000555555c5dc59 in pc_memory_init (pcms=0x5555572bf2d0, system_memory=0x5555572c8400, rom_memory=0x5555570fc6e0, pci_hole64_size=2147483648) at ../hw/i386/pc.c:954
+ * #9  0x0000555555c3f9e7 in pc_init1 (machine=0x5555572bf2d0, host_type=0x555556219858 "i440FX-pcihost", pci_type=0x555556219851 "i440FX") at ../hw/i386/pc_piix.c:246
+ * #10 0x0000555555c405d7 in pc_init_v8_2 (machine=0x5555572bf2d0) at ../hw/i386/pc_piix.c:555
+ * #11 0x00005555559243b5 in machine_run_board_init (machine=0x5555572bf2d0, mem_path=0x0, errp=0x7fffffffe120) at ../hw/core/machine.c:1509
+ * #12 0x0000555555b75478 in qemu_init_board () at ../system/vl.c:2613
+ * #13 0x0000555555b756fd in qmp_x_exit_preconfig (errp=0x555556fce260 <error_fatal>) at ../system/vl.c:2704
+ * #14 0x0000555555b780dc in qemu_init (argc=23, argv=0x7fffffffe448) at ../system/vl.c:3753
+ * #15 0x0000555555e02daf in main (argc=23, argv=0x7fffffffe448) at ../system/main.c:47
+ *
+ * 在以下使用vhost_region_addnop():
+ *   - hw/virtio/vhost.c|1684| <<vhost_dev_init>> .region_add = vhost_region_addnop,
+ *   - hw/virtio/vhost.c|1685| <<vhost_dev_init>> .region_nop = vhost_region_addnop,
+ *
+ * 1680     hdev->memory_listener = (MemoryListener) {
+ * 1681         .name = "vhost",
+ * 1682         .begin = vhost_begin,
+ * 1683         .commit = vhost_commit,
+ * 1684         .region_add = vhost_region_addnop,
+ * 1685         .region_nop = vhost_region_addnop,
+ * 1686         .log_start = vhost_log_start,
+ * 1687         .log_stop = vhost_log_stop,
+ * 1688         .log_sync = vhost_log_sync,
+ * 1689         .log_global_start = vhost_log_global_start,
+ * 1690         .log_global_stop = vhost_log_global_stop,
+ * 1691         .priority = MEMORY_LISTENER_PRIORITY_DEV_BACKEND
+ * 1692     };
+ */
 /* Used for both add and nop callbacks */
 static void vhost_region_addnop(MemoryListener *listener,
                                 MemoryRegionSection *section)
diff --git a/include/hw/core/cpu.h b/include/hw/core/cpu.h
index c0c832041..44fccfc4d 100644
--- a/include/hw/core/cpu.h
+++ b/include/hw/core/cpu.h
@@ -546,6 +546,35 @@ struct CPUState {
     int32_t exception_index;
 
     AccelCPUState *accel;
+    /*
+     * 在以下设置CPUState->vcpu_dirty:
+     *   - accel/hvf/hvf-accel-ops.c|209| <<do_hvf_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/hvf/hvf-accel-ops.c|224| <<do_hvf_cpu_synchronize_set_dirty>> cpu->vcpu_dirty = true;
+     *   - accel/hvf/hvf-accel-ops.c|405| <<hvf_init_vcpu>> cpu->vcpu_dirty = 1;
+     *   - accel/kvm/kvm-all.c|417| <<kvm_init_vcpu>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|2721| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|2741| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|2761| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|2775| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|2869| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/arm/hvf/hvf.c|806| <<flush_cpu_state>> cpu->vcpu_dirty = false;
+     *   - target/i386/hvf/hvf.c|424| <<hvf_vcpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/i386/nvmm/nvmm-all.c|511| <<nvmm_io_callback>> current_cpu->vcpu_dirty = false;
+     *   - target/i386/nvmm/nvmm-all.c|520| <<nvmm_mem_callback>> current_cpu->vcpu_dirty = false;
+     *   - target/i386/nvmm/nvmm-all.c|733| <<nvmm_vcpu_loop>> cpu->vcpu_dirty = false;
+     *   - target/i386/nvmm/nvmm-all.c|831| <<do_nvmm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - target/i386/nvmm/nvmm-all.c|838| <<do_nvmm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - target/i386/nvmm/nvmm-all.c|845| <<do_nvmm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - target/i386/nvmm/nvmm-all.c|851| <<do_nvmm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - target/i386/nvmm/nvmm-all.c|986| <<nvmm_init_vcpu>> cpu->vcpu_dirty = true;
+     *   - target/i386/whpx/whpx-all.c|846| <<whpx_emu_setreg_callback>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|1724| <<whpx_vcpu_run>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|2074| <<do_whpx_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - target/i386/whpx/whpx-all.c|2082| <<do_whpx_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|2089| <<do_whpx_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|2095| <<do_whpx_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - target/i386/whpx/whpx-all.c|2244| <<whpx_init_vcpu>> cpu->vcpu_dirty = true;
+     */
     /* shared by kvm and hvf */
     bool vcpu_dirty;
 
diff --git a/include/hw/virtio/vhost.h b/include/hw/virtio/vhost.h
index 02477788d..be194fe0d 100644
--- a/include/hw/virtio/vhost.h
+++ b/include/hw/virtio/vhost.h
@@ -81,8 +81,27 @@ struct vhost_dev {
     MemoryListener iommu_listener;
     struct vhost_memory *mem;
     int n_mem_sections;
+    /*
+     * 在以下使用vhost_dev->mem_sections:
+     *   - hw/virtio/vhost.c|346| <<vhost_log_sync_range>> MemoryRegionSection *section = &dev->mem_sections[i];
+     *   - hw/virtio/vhost.c|700| <<vhost_commit>> old_sections = dev->mem_sections;
+     *   - hw/virtio/vhost.c|702| <<vhost_commit>> dev->mem_sections = dev->tmp_sections;
+     *   - hw/virtio/vhost.c|711| <<vhost_commit>> if (!MemoryRegionSection_eq(&old_sections[i], &dev->mem_sections[i])) {
+     *   - hw/virtio/vhost.c|753| <<vhost_commit>> struct MemoryRegionSection *mrs = dev->mem_sections + i;
+     *   - hw/virtio/vhost.c|1678| <<vhost_dev_init>> hdev->mem_sections = NULL;
+     *   - hw/virtio/vhost.c|1741| <<vhost_dev_cleanup>> g_free(hdev->mem_sections);
+     */
     MemoryRegionSection *mem_sections;
     int n_tmp_sections;
+    /*
+     * 在以下使用vhost_dev->tmp_sections:
+     *   - hw/virtio/vhost.c|662| <<vhost_begin>> dev->tmp_sections = NULL;
+     *   - hw/virtio/vhost.c|702| <<vhost_commit>> dev->mem_sections = dev->tmp_sections;
+     *   - hw/virtio/vhost.c|856| <<vhost_region_add_section>> MemoryRegionSection *prev_sec = dev->tmp_sections +
+     *   - hw/virtio/vhost.c|913| <<vhost_region_add_section>> dev->tmp_sections = g_renew(MemoryRegionSection, dev->tmp_sections,
+     *   - hw/virtio/vhost.c|915| <<vhost_region_add_section>> dev->tmp_sections[dev->n_tmp_sections - 1] = *section;
+     *   - hw/virtio/vhost.c|919| <<vhost_region_add_section>> dev->tmp_sections[dev->n_tmp_sections - 1].fv = NULL;
+     */
     MemoryRegionSection *tmp_sections;
     struct vhost_virtqueue *vqs;
     unsigned int nvqs;
diff --git a/include/qemu/thread-context.h b/include/qemu/thread-context.h
index 2ebd6b7fe..b459c99a0 100644
--- a/include/qemu/thread-context.h
+++ b/include/qemu/thread-context.h
@@ -35,6 +35,14 @@ struct ThreadContext {
 
     /* Semaphore to wait for context thread action. */
     QemuSemaphore sem;
+    /*
+     * 在以下使用ThreadContext->sem_thread:
+     *   - util/thread-context.c|117| <<thread_context_run>> qemu_sem_wait(&tc->sem_thread);
+     *   - util/thread-context.c|345| <<thread_context_instance_init>> qemu_sem_init(&tc->sem_thread, 0);
+     *   - util/thread-context.c|355| <<thread_context_instance_finalize>> qemu_sem_post(&tc->sem_thread);
+     *   - util/thread-context.c|359| <<thread_context_instance_finalize>> qemu_sem_destroy(&tc->sem_thread);
+     *   - util/thread-context.c|402| <<thread_context_create_thread>> qemu_sem_post(&tc->sem_thread);
+     */
     /* Semaphore to wait for action in context thread. */
     QemuSemaphore sem_thread;
     /* Mutex to synchronize requests. */
diff --git a/include/sysemu/hostmem.h b/include/sysemu/hostmem.h
index 39326f1d4..abd9bdbb6 100644
--- a/include/sysemu/hostmem.h
+++ b/include/sysemu/hostmem.h
@@ -66,7 +66,25 @@ struct HostMemoryBackend {
     uint64_t size;
     bool merge, dump, use_canonical_path;
     bool prealloc, is_mapped, share, reserve;
+    /*
+     * 在以下使用HostMemoryBackend->prealloc_threads:
+     *   - backends/hostmem.c|258| <<host_memory_backend_set_prealloc>> qemu_prealloc_mem(fd, ptr, sz, backend->prealloc_threads, backend->prealloc_context, &local_err);
+     *   - backends/hostmem.c|272| <<host_memory_backend_get_prealloc_threads>> visit_type_uint32(v, name, &backend->prealloc_threads, errp);
+     *   - backends/hostmem.c|289| <<host_memory_backend_set_prealloc_threads>> backend->prealloc_threads = value;
+     *   - backends/hostmem.c|304| <<host_memory_backend_init>> backend->prealloc_threads = machine->smp.cpus;
+     *   - backends/hostmem.c|470| <<host_memory_backend_memory_complete>> qemu_prealloc_mem(memory_region_get_fd(&backend->mr), ptr, sz, backend->prealloc_threads, backend->prealloc_context, &local_err);
+     */
     uint32_t prealloc_threads;
+    /*
+     * 在以下使用HostMemoryBackend->prealloc_context:
+     *   - backends/hostmem.c|259| <<host_memory_backend_set_prealloc>> backend->prealloc_context, &local_err);
+     *   - backends/hostmem.c|471| <<host_memory_backend_memory_complete>> backend->prealloc_context, &local_err);
+     *   - backends/hostmem.c|580| <<host_memory_backend_class_init>> TYPE_THREAD_CONTEXT, offsetof(HostMemoryBackend, prealloc_context),
+     *
+     * 579     object_class_property_add_link(oc, "prealloc-context",
+     * 580         TYPE_THREAD_CONTEXT, offsetof(HostMemoryBackend, prealloc_context),
+     * 581         object_property_allow_set_link, OBJ_PROP_LINK_STRONG);
+     */
     ThreadContext *prealloc_context;
     DECLARE_BITMAP(host_nodes, MAX_NODES + 1);
     HostMemPolicy policy;
diff --git a/migration/ram.c b/migration/ram.c
index 8c7886ab7..c38bb2955 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -1031,6 +1031,11 @@ static void migration_trigger_throttle(RAMState *rs)
     }
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|1094| <<migration_bitmap_sync_precopy>> migration_bitmap_sync(rs, last_stage);
+ *   - migration/ram.c|2622| <<ram_postcopy_send_discard_bitmap>> migration_bitmap_sync(rs, false);
+ */
 static void migration_bitmap_sync(RAMState *rs, bool last_stage)
 {
     RAMBlock *block;
diff --git a/monitor/hmp.c b/monitor/hmp.c
index 69c1b7e98..a846bc4a3 100644
--- a/monitor/hmp.c
+++ b/monitor/hmp.c
@@ -1173,6 +1173,27 @@ void handle_hmp_command(MonitorHMP *mon, const char *cmdline)
     qobject_unref(qdict);
 }
 
+/*
+ * (gdb) bt
+ * #0  cmd_completion (mon=0x555556846620, name=0x5555574f6f60 "", list=0x55555609d9a2 "balloon") at ../monitor/hmp.c:1174
+ * #1  0x0000555555acd505 in monitor_find_completion_by_table (mon=0x555556846620, cmd_table=0x5555566f7740 <hmp_info_cmds>, args=0x7fffffffc9e8, nb_args=1) at ../monitor/hmp.c:1284
+ * #2  0x0000555555acd5a5 in monitor_find_completion_by_table (mon=0x555556846620, cmd_table=0x5555566f8aa0 <hmp_cmds>, args=0x7fffffffc9e0, nb_args=2) at ../monitor/hmp.c:1301
+ * #3  0x0000555555acd90d in monitor_find_completion (opaque=0x555556846620, cmdline=0x55555718d000 "info ") at ../monitor/hmp.c:1380
+ * #4  0x0000555555f1906b in readline_completion (rs=0x555556ac0f10) at ../util/readline.c:307
+ * #5  0x0000555555f19505 in readline_handle_byte (rs=0x555556ac0f10, ch=9) at ../util/readline.c:395
+ * #6  0x0000555555acd9a8 in monitor_read (opaque=0x555556846620, buf=0x7fffffffcbf0 "\t\322\377\377\377\177", size=1) at ../monitor/hmp.c:1393
+ * #7  0x0000555555e31613 in qemu_chr_be_write_impl (s=0x555556a66ab0, buf=0x7fffffffcbf0 "\t\322\377\377\377\177", len=1) at ../chardev/char.c:201
+ * #8  0x0000555555e31677 in qemu_chr_be_write (s=0x555556a66ab0, buf=0x7fffffffcbf0 "\t\322\377\377\377\177", len=1) at ../chardev/char.c:213
+ * #9  0x0000555555e340a4 in fd_chr_read (chan=0x555556a66bc0, cond=G_IO_IN, opaque=0x555556a66ab0) at ../chardev/char-fd.c:72
+ * #10 0x0000555555d335b4 in qio_channel_fd_source_dispatch (source=0x5555578075c0, callback=0x555555e33f7a <fd_chr_read>, user_data=0x555556a66ab0) at ../io/channel-watch.c:84
+ * #11 0x00007ffff6c40119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #12 0x0000555555f12010 in glib_pollfds_poll () at ../util/main-loop.c:297
+ * #13 0x0000555555f1208a in os_host_main_loop_wait (timeout=1000000000) at ../util/main-loop.c:320
+ * #14 0x0000555555f1218f in main_loop_wait (nonblocking=0) at ../util/main-loop.c:596
+ * #15 0x0000555555a7a05e in qemu_main_loop () at ../softmmu/runstate.c:734
+ * #16 0x000055555581fe62 in qemu_main (argc=20, argv=0x7fffffffded8, envp=0x0) at ../softmmu/main.c:38
+ * #17 0x000055555581fe94 in main (argc=20, argv=0x7fffffffded8) at ../softmmu/main.c:47
+ */
 static void cmd_completion(MonitorHMP *mon, const char *name, const char *list)
 {
     const char *p, *pstart;
diff --git a/monitor/qmp.c b/monitor/qmp.c
index 6eee450fe..31817a002 100644
--- a/monitor/qmp.c
+++ b/monitor/qmp.c
@@ -378,6 +378,21 @@ void qmp_dispatcher_co_wake(void)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  handle_qmp_command (opaque=0x5555567fb9a0, req=0x7fffe0003740, err=0x0) at ../monitor/qmp.c:346
+ * #1  0x0000555555d27063 in json_message_process_token (lexer=lexer@entry=0x5555567fba60, input=0x555556777720, type=<optimized out>, x=<optimized out>, y=<optimized out>) at ../qobject/json-streamer.c:99
+ * #2  0x0000555555d57fbf in json_lexer_feed_char (lexer=lexer@entry=0x5555567fba60, ch=125 '}', flush=flush@entry=false) at ../qobject/json-lexer.c:313
+ * #3  0x0000555555d58119 in json_lexer_feed (lexer=0x5555567fba60, buffer=<optimized out>, size=<optimized out>) at ../qobject/json-lexer.c:350
+ * #4  0x0000555555c9a07e in tcp_chr_read (chan=<optimized out>, cond=<optimized out>, opaque=<optimized out>) at ../chardev/char-socket.c:508
+ * #5  0x00007ffff6c40119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #6  0x00007ffff6c40478 in g_main_context_iterate.isra () at /lib64/libglib-2.0.so.0
+ * #7  0x00007ffff6c4074a in g_main_loop_run () at /lib64/libglib-2.0.so.0
+ * #8  0x0000555555bfb9c9 in iothread_run (opaque=opaque@entry=0x5555567fbb00) at ../iothread.c:74
+ * #9  0x0000555555d2fd09 in qemu_thread_start (args=0x7fffee5ef950) at ../util/qemu-thread-posix.c:504
+ * #10 0x00007ffff53d0ea5 in start_thread () at /lib64/libpthread.so.0
+ * #11 0x00007ffff50f99fd in clone () at /lib64/libc.so.6
+ */
 static void handle_qmp_command(void *opaque, QObject *req, Error *err)
 {
     MonitorQMP *mon = opaque;
diff --git a/qapi/qmp-dispatch.c b/qapi/qmp-dispatch.c
index 555528b6b..95b2774d2 100644
--- a/qapi/qmp-dispatch.c
+++ b/qapi/qmp-dispatch.c
@@ -130,6 +130,35 @@ static void do_qmp_dispatch_bh(void *opaque)
     aio_co_wake(data->co);
 }
 
+/*
+ * (gdb) bt
+ * #0  qmp_dispatch (cmds=0x5555565525a0 <qmp_cap_negotiation_commands>, request=0x7fffe0003740, allow_oob=false, cur_mon=0x5555567fb9a0)
+ *                   at ../qapi/qmp-dispatch.c:139
+ * #1  0x0000555555ca2414 in monitor_qmp_dispatch (mon=0x5555567fb9a0, req=<optimized out>) at ../monitor/qmp.c:144
+ * #2  0x0000555555ca2df2 in monitor_qmp_dispatcher_co (data=<optimized out>) at ../monitor/qmp.c:318
+ * #3  0x0000555555d41c2b in coroutine_trampoline (i0=<optimized out>, i1=<optimized out>) at ../util/coroutine-ucontext.c:177
+ * #4  0x00007ffff5043190 in __start_context () at /lib64/libc.so.6
+ * #5  0x00007fffffffd1b0 in  ()
+ * #6  0x0000000000000000 in  ()
+ *
+ * 在json的message换成oob的样子.
+ *
+ * (gdb) bt
+ * #0  qmp_dispatch (cmds=0x5555565525b0 <qmp_commands>, request=0x7fffe0003710, allow_oob=false, cur_mon=cur_mon@entry=0x5555567fb9a0) at ../qapi/qmp-dispatch.c:141
+ * #1  0x0000555555ca2414 in monitor_qmp_dispatch (mon=0x5555567fb9a0, req=<optimized out>) at ../monitor/qmp.c:144
+ * #2  0x0000555555ca2756 in handle_qmp_command (opaque=0x5555567fb9a0, req=0x7fffe0003710, err=<optimized out>) at ../monitor/qmp.c:371
+ * #3  0x0000555555d27103 in json_message_process_token (lexer=lexer@entry=0x5555567fba60, input=0x555556777720, type=<optimized out>, x=<optimized out>, y=<optimized out>) at ../qobject/json-streamer.c:99
+ * #4  0x0000555555d5805f in json_lexer_feed_char (lexer=lexer@entry=0x5555567fba60, ch=125 '}', flush=flush@entry=false) at ../qobject/json-lexer.c:313
+ * #5  0x0000555555d581b9 in json_lexer_feed (lexer=0x5555567fba60, buffer=<optimized out>, size=<optimized out>) at ../qobject/json-lexer.c:350
+ * #6  0x0000555555c9a07e in tcp_chr_read (chan=<optimized out>, cond=<optimized out>, opaque=<optimized out>) at ../chardev/char-socket.c:508
+ * #7  0x00007ffff6c40119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #8  0x00007ffff6c40478 in g_main_context_iterate.isra () at /lib64/libglib-2.0.so.0
+ * #9  0x00007ffff6c4074a in g_main_loop_run () at /lib64/libglib-2.0.so.0
+ * #10 0x0000555555bfb9c9 in iothread_run (opaque=opaque@entry=0x5555567fbb00) at ../iothread.c:74
+ * #11 0x0000555555d2fda9 in qemu_thread_start (args=0x7fffee5ef950) at ../util/qemu-thread-posix.c:504
+ * #12 0x00007ffff53d0ea5 in start_thread () at /lib64/libpthread.so.0
+ * #13 0x00007ffff50f99fd in clone () at /lib64/libc.so.6
+ */
 /*
  * Runs outside of coroutine context for OOB commands, but in coroutine
  * context for everything else.
diff --git a/qom/qom-qmp-cmds.c b/qom/qom-qmp-cmds.c
index 7c087299d..3e67272b1 100644
--- a/qom/qom-qmp-cmds.c
+++ b/qom/qom-qmp-cmds.c
@@ -75,6 +75,52 @@ void qmp_qom_set(const char *path, const char *property, QObject *value,
     object_property_set_qobject(obj, property, value, errp);
 }
 
+/*
+ * 使用oob的时候
+ *
+ * { "execute": "qmp_capabilities", "arguments": { "enable": ["oob"] } }
+ * { "exec-oob": "qom-get", "arguments": { "path": "/machine/peripheral-anon/device[0]", "property": "queue-size" } }
+ *
+ * (gdb) bt
+ * #0  qmp_qom_get (path=0x7fffe0004ab0 "/machine/peripheral-anon/device[0]", property=0x7fffe00027c0 "queue-size", errp=errp@entry=0x7fffee5ee538) at ../qom/qom-qmp-cmds.c:82
+ * #1  0x0000555555cfe9cb in qmp_marshal_qom_get (args=<optimized out>, ret=0x7fffee5ee5d8, errp=0x7fffee5ee5d0) at qapi/qapi-commands-qom.c:131
+ * #2  0x0000555555d23c8c in qmp_dispatch (cmds=0x5555565525b0 <qmp_commands>, request=<optimized out>, allow_oob=<optimized out>, cur_mon=cur_mon@entry=0x5555567fb9a0) at ../qapi/qmp-dispatch.c:212
+ * #3  0x0000555555ca2414 in monitor_qmp_dispatch (mon=0x5555567fb9a0, req=<optimized out>) at ../monitor/qmp.c:145
+ * #4  0x0000555555ca2756 in handle_qmp_command (opaque=0x5555567fb9a0, req=0x7fffe00027e0, err=<optimized out>) at ../monitor/qmp.c:372
+ * #5  0x0000555555d27143 in json_message_process_token (lexer=lexer@entry=0x5555567fba60, input=0x555556777720, type=<optimized out>, x=<optimized out>, y=<optimized out>) at ../qobject/json-streamer.c:99
+ * #6  0x0000555555d5809f in json_lexer_feed_char (lexer=lexer@entry=0x5555567fba60, ch=125 '}', flush=flush@entry=false) at ../qobject/json-lexer.c:313
+ * #7  0x0000555555d581f9 in json_lexer_feed (lexer=0x5555567fba60, buffer=<optimized out>, size=<optimized out>) at ../qobject/json-lexer.c:350
+ * #8  0x0000555555c9a07e in tcp_chr_read (chan=<optimized out>, cond=<optimized out>, opaque=<optimized out>) at ../chardev/char-socket.c:508
+ * #9  0x00007ffff6c40119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #10 0x00007ffff6c40478 in g_main_context_iterate.isra () at /lib64/libglib-2.0.so.0
+ * #11 0x00007ffff6c4074a in g_main_loop_run () at /lib64/libglib-2.0.so.0
+ * #12 0x0000555555bfb9c9 in iothread_run (opaque=opaque@entry=0x5555567fbb00) at ../iothread.c:74
+ * #13 0x0000555555d2fde9 in qemu_thread_start (args=0x7fffee5ef950) at ../util/qemu-thread-posix.c:504
+ * #14 0x00007ffff53d0ea5 in start_thread () at /lib64/libpthread.so.0
+ * #15 0x00007ffff50f99fd in clone () at /lib64/libc.so.6
+ *
+ * 不使用oob的时候
+ *
+ * { "execute": "qmp_capabilities" }
+ * { "execute": "qom-get", "arguments": { "path": "/machine/peripheral-anon/device[0]", "property": "queue-size" } }
+ *
+ * (gdb) bt
+ * #0  qmp_qom_get (path=0x555556c38880 "/machine/peripheral-anon/device[0]", property=0x555556d9e560 "queue-size", errp=errp@entry=0x7fffffffd8a8) at ../qom/qom-qmp-cmds.c:82
+ * #1  0x0000555555cfe9cb in qmp_marshal_qom_get (args=<optimized out>, ret=0x7ffff7fcbea8, errp=0x7ffff7fcbea0) at qapi/qapi-commands-qom.c:131
+ * #2  0x0000555555d23379 in do_qmp_dispatch_bh (opaque=0x7ffff7fcbeb0) at ../qapi/qmp-dispatch.c:130
+ * #3  0x0000555555d3ff84 in aio_bh_call (bh=0x555556c74520) at ../util/async.c:178
+ * #4  aio_bh_poll (ctx=ctx@entry=0x5555565cac30) at ../util/async.c:178
+ * #5  0x0000555555d2cc1e in aio_dispatch (ctx=0x5555565cac30) at ../util/aio-posix.c:421
+ * #6  0x0000555555d3fbee in aio_ctx_dispatch (source=<optimized out>, callback=<optimized out>, user_data=<optimized out>) at ../util/async.c:320
+ * #7  0x00007ffff6c40119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #8  0x0000555555d4bea0 in glib_pollfds_poll () at ../util/main-loop.c:297
+ * #9  os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:320
+ * #10 main_loop_wait (nonblocking=nonblocking@entry=0) at ../util/main-loop.c:596
+ * #11 0x00005555559d1181 in qemu_main_loop () at ../softmmu/runstate.c:734
+ * #12 0x0000555555825f5c in qemu_main (argc=<optimized out>, argv=<optimized out>, envp=<optimized out>) at ../softmmu/main.c:38
+ * #13 0x00007ffff501d555 in __libc_start_main () at /lib64/libc.so.6
+ * #14 0x0000555555825e8a in _start () at ../softmmu/main.c:47
+ */
 QObject *qmp_qom_get(const char *path, const char *property, Error **errp)
 {
     Object *obj;
diff --git a/system/cpus.c b/system/cpus.c
index a444a747f..1945936f8 100644
--- a/system/cpus.c
+++ b/system/cpus.c
@@ -138,6 +138,11 @@ void cpu_synchronize_all_states(void)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc.c|1784| <<pc_machine_wakeup>> cpu_synchronize_all_post_reset();
+ *   - system/runstate.c|504| <<qemu_system_reset>> cpu_synchronize_all_post_reset();
+ */
 void cpu_synchronize_all_post_reset(void)
 {
     CPUState *cpu;
@@ -147,6 +152,13 @@ void cpu_synchronize_all_post_reset(void)
     }
 }
 
+/*
+ * called by:
+ *   - hw/core/machine.c|1531| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|2145| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3003| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3020| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+ */
 void cpu_synchronize_all_post_init(void)
 {
     CPUState *cpu;
@@ -179,6 +191,23 @@ void cpu_synchronize_post_reset(CPUState *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - hw/core/cpu-common.c|213| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+ *   - system/cpus.c|155| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+ *   - target/s390x/gdbstub.c|90| <<cpu_write_ac_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|197| <<cpu_write_c_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|233| <<cpu_write_virt_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|237| <<cpu_write_virt_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|241| <<cpu_write_virt_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|245| <<cpu_write_virt_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|281| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|285| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|289| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|293| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|317| <<cpu_write_gs_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/sigp.c|298| <<sigp_set_prefix>> cpu_synchronize_post_init(cs);
+ */
 void cpu_synchronize_post_init(CPUState *cpu)
 {
     if (cpus_accel->synchronize_post_init) {
diff --git a/system/main.c b/system/main.c
index 9b91d21ea..193770869 100644
--- a/system/main.c
+++ b/system/main.c
@@ -30,6 +30,10 @@
 #include <SDL.h>
 #endif
 
+/*
+ * 在以下使用qemu_default_main():
+ *   - system/main.c|43| <<global>> int (*qemu_main)(void ) = qemu_default_main;
+ */
 int qemu_default_main(void)
 {
     int status;
diff --git a/system/memory.c b/system/memory.c
index 798b6c0a1..5b02c7f28 100644
--- a/system/memory.c
+++ b/system/memory.c
@@ -941,6 +941,52 @@ static void flat_range_coalesced_io_add(FlatRange *fr, AddressSpace *as)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_region_add_section (dev=0x5555572db3d0, section=0x7ffe66dfc1d0) at ../hw/virtio/vhost.c:681
+ * #1  0x0000555555b27839 in vhost_region_addnop (listener=0x5555572db3d8, section=0x7ffe66dfc1d0) at ../hw/virtio/vhost.c:794
+ * #2  0x0000555555d91169 in address_space_update_topology_pass (as=0x555556fba100 <address_space_memory>, old_view=0x7fffec2ab0a0, new_view=0x7ffe5c054f00, adding=true) at ../system/memory.c:985
+ * #3  0x0000555555d9168d in address_space_set_flatview (as=0x555556fba100 <address_space_memory>) at ../system/memory.c:1080
+ * #4  0x0000555555d91846 in memory_region_transaction_commit () at ../system/memory.c:1132
+ * #5  0x0000555555d959ec in memory_region_del_subregion (mr=0x55555713c800, subregion=0x55555785cce0) at ../system/memory.c:2680
+ * #6  0x0000555555a4a8b7 in pci_update_mappings (d=0x55555785ab30) at ../hw/pci/pci.c:1539
+ * #7  0x0000555555a4ad39 in pci_default_write_config (d=0x55555785ab30, addr=4, val_in=256, l=2) at ../hw/pci/pci.c:1607
+ * #8  0x0000555555a4f838 in pci_host_config_write_common (pci_dev=0x55555785ab30, addr=4, limit=256, val=256, len=2) at ../hw/pci/pci_host.c:96
+ * #9  0x0000555555a4fa5e in pci_data_write (s=0x5555573e6060, addr=2147485956, val=256, len=2) at ../hw/pci/pci_host.c:138
+ * #10 0x0000555555a4fbf5 in pci_host_data_write (opaque=0x5555573afb10, addr=0, val=256, len=2) at ../hw/pci/pci_host.c:188
+ * #11 0x0000555555d8f37d in memory_region_write_accessor (mr=0x5555573aff50, addr=0, value=0x7ffe66dfc5a8, size=2, shift=0, mask=65535, attrs=...) at ../system/memory.c:497
+ * #12 0x0000555555d8f692 in access_with_adjusted_size (addr=0, value=0x7ffe66dfc5a8, size=2, access_size_min=1, access_size_max=4, access_fn=
+ *                                    0x555555d8f287 <memory_region_write_accessor>, mr=0x5555573aff50, attrs=...) at ../system/memory.c:573
+ * #13 0x0000555555d92776 in memory_region_dispatch_write (mr=0x5555573aff50, addr=0, data=256, op=MO_16, attrs=...) at ../system/memory.c:1521
+ * #14 0x0000555555da00c4 in flatview_write_continue (fv=0x7fffec281390, addr=3324, attrs=..., ptr=0x7ffff42a0000, len=2, addr1=0, l=2, mr=0x5555573aff50) at ../system/physmem.c:2714
+ * #15 0x0000555555da0227 in flatview_write (fv=0x7fffec281390, addr=3324, attrs=..., buf=0x7ffff42a0000, len=2) at ../system/physmem.c:2756
+ * #16 0x0000555555da05d7 in address_space_write (as=0x555556fba0a0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff42a0000, len=2) at ../system/physmem.c:2863
+ * #17 0x0000555555da0644 in address_space_rw (as=0x555556fba0a0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff42a0000, len=2, is_write=true) at ../system/physmem.c:2873
+ * #18 0x0000555555df2d18 in kvm_handle_io (port=3324, attrs=..., data=0x7ffff42a0000, direction=1, size=2, count=1) at ../accel/kvm/kvm-all.c:2632
+ * #19 0x0000555555df35bb in kvm_cpu_exec (cpu=0x5555573a4d30) at ../accel/kvm/kvm-all.c:2905
+ * #20 0x0000555555df62fa in kvm_vcpu_thread_fn (arg=0x5555573a4d30) at ../accel/kvm/kvm-accel-ops.c:51
+ * #21 0x00005555560017cc in qemu_thread_start (args=0x5555573aed40) at ../util/qemu-thread-posix.c:541
+ * #22 0x00007ffff749f812 in start_thread () at /lib64/libc.so.6
+ * #23 0x00007ffff743f450 in clone3 () at /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  vhost_region_add_section (dev=0x5555572db030, section=0x7fffffffdcc0) at ../hw/virtio/vhost.c:681
+ * #1  0x0000555555b27839 in vhost_region_addnop (listener=0x5555572db038, section=0x7fffffffdcc0) at ../hw/virtio/vhost.c:794
+ * #2  0x0000555555d9138d in address_space_update_topology_pass (as=0x555556fba100 <address_space_memory>, old_view=0x555557711610, new_view=0x55555772cf90, adding=true) at ../system/memory.c:1004
+ * #3  0x0000555555d9168d in address_space_set_flatview (as=0x555556fba100 <address_space_memory>) at ../system/memory.c:1080
+ * #4  0x0000555555d91846 in memory_region_transaction_commit () at ../system/memory.c:1132
+ * #5  0x0000555555d95725 in memory_region_update_container_subregions (subregion=0x5555570a8c00) at ../system/memory.c:2630
+ * #6  0x0000555555d957d0 in memory_region_add_subregion_common (mr=0x5555572c8400, offset=0, subregion=0x5555570a8c00) at ../system/memory.c:2645
+ * #7  0x0000555555d9580c in memory_region_add_subregion (mr=0x5555572c8400, offset=0, subregion=0x5555570a8c00) at ../system/memory.c:2653
+ * #8  0x0000555555c5dc59 in pc_memory_init (pcms=0x5555572bf2d0, system_memory=0x5555572c8400, rom_memory=0x5555570fc6e0, pci_hole64_size=2147483648) at ../hw/i386/pc.c:954
+ * #9  0x0000555555c3f9e7 in pc_init1 (machine=0x5555572bf2d0, host_type=0x555556219858 "i440FX-pcihost", pci_type=0x555556219851 "i440FX") at ../hw/i386/pc_piix.c:246
+ * #10 0x0000555555c405d7 in pc_init_v8_2 (machine=0x5555572bf2d0) at ../hw/i386/pc_piix.c:555
+ * #11 0x00005555559243b5 in machine_run_board_init (machine=0x5555572bf2d0, mem_path=0x0, errp=0x7fffffffe120) at ../hw/core/machine.c:1509
+ * #12 0x0000555555b75478 in qemu_init_board () at ../system/vl.c:2613
+ * #13 0x0000555555b756fd in qmp_x_exit_preconfig (errp=0x555556fce260 <error_fatal>) at ../system/vl.c:2704
+ * #14 0x0000555555b780dc in qemu_init (argc=23, argv=0x7fffffffe448) at ../system/vl.c:3753
+ * #15 0x0000555555e02daf in main (argc=23, argv=0x7fffffffe448) at ../system/main.c:47
+ */
 static void address_space_update_topology_pass(AddressSpace *as,
                                                const FlatView *old_view,
                                                const FlatView *new_view,
@@ -1134,6 +1180,9 @@ void memory_region_transaction_commit(void)
             }
             memory_region_update_pending = false;
             ioeventfd_update_pending = false;
+	    /*
+	     * 在这里commit!
+	     */
             MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);
         } else if (ioeventfd_update_pending) {
             QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
@@ -1546,6 +1595,19 @@ void memory_region_init_io(MemoryRegion *mr,
     mr->terminates = true;
 }
 
+/*
+ * called by:
+ *   - hw/block/onenand.c|814| <<onenand_realize>> memory_region_init_ram_nomigrate(&s->ram, OBJECT(s), "onenand.ram",
+ *   - hw/display/tcx.c|819| <<tcx_realizefn>> memory_region_init_ram_nomigrate(&s->vram_mem, OBJECT(s), "tcx.vram",
+ *   - hw/display/vga.c|2219| <<vga_common_init>> memory_region_init_ram_nomigrate(&s->vram, obj, "vga.vram", s->vram_size,
+ *   - hw/sparc/sun4m.c|582| <<idreg_realize>> memory_region_init_ram_nomigrate(&s->mem, OBJECT(ds), "sun4m.idreg",
+ *   - hw/sparc/sun4m.c|636| <<afx_realize>> memory_region_init_ram_nomigrate(&s->mem, OBJECT(ds), "sun4m.afx", 4,
+ *   - hw/sparc/sun4m.c|720| <<prom_realize>> memory_region_init_ram_nomigrate(&s->prom, OBJECT(ds), "sun4m.prom",
+ *   - hw/sparc64/sun4u.c|459| <<prom_realize>> memory_region_init_ram_nomigrate(&s->prom, OBJECT(ds), "sun4u.prom",
+ *   - hw/sparc64/sun4u.c|509| <<ram_realize>> memory_region_init_ram_nomigrate(&d->ram, OBJECT(d), "sun4u.ram", d->size,
+ *   - hw/xtensa/xtfpga.c|162| <<xtfpga_net_init>> memory_region_init_ram_nomigrate(ram, OBJECT(s), "open_eth.ram", 16 * KiB,
+ *   - system/memory.c|3588| <<memory_region_init_ram>> memory_region_init_ram_nomigrate(mr, owner, name, size, &err);
+ */
 void memory_region_init_ram_nomigrate(MemoryRegion *mr,
                                       Object *owner,
                                       const char *name,
@@ -1555,6 +1617,13 @@ void memory_region_init_ram_nomigrate(MemoryRegion *mr,
     memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
 }
 
+/*
+ * called by:
+ *   - backends/hostmem-ram.c|33| <<ram_backend_memory_alloc>> memory_region_init_ram_flags_nomigrate(&backend->mr, OBJECT(backend), name,
+ *   - hw/m68k/next-cube.c|1087| <<next_cube_init>> memory_region_init_ram_flags_nomigrate(bmapm1, NULL, "next.bmapmem", 64,
+ *   - system/memory.c|1555| <<memory_region_init_ram_nomigrate>> memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
+ *   - system/memory.c|1721| <<memory_region_init_rom_nomigrate>> memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
+ */
 void memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
                                             Object *owner,
                                             const char *name,
@@ -1600,6 +1669,10 @@ void memory_region_init_resizeable_ram(MemoryRegion *mr,
 }
 
 #ifdef CONFIG_POSIX
+/*
+ * called by:
+ *   - backends/hostmem-file.c|89| <<file_backend_memory_alloc>> memory_region_init_ram_from_file(&backend->mr, OBJECT(backend), name,
+ */
 void memory_region_init_ram_from_file(MemoryRegion *mr,
                                       Object *owner,
                                       const char *name,
@@ -1617,6 +1690,9 @@ void memory_region_init_ram_from_file(MemoryRegion *mr,
     mr->terminates = true;
     mr->destructor = memory_region_destructor_ram;
     mr->align = align;
+    /*
+     * 只在此处调用
+     */
     mr->ram_block = qemu_ram_alloc_from_file(size, mr, ram_flags, path,
                                              offset, &err);
     if (err) {
@@ -1626,6 +1702,13 @@ void memory_region_init_ram_from_file(MemoryRegion *mr,
     }
 }
 
+/*
+ * called by:
+ *   - backends/hostmem-epc.c|41| <<sgx_epc_backend_memory_alloc>> memory_region_init_ram_from_fd(&backend->mr, OBJECT(backend),
+ *   - backends/hostmem-memfd.c|58| <<memfd_backend_memory_alloc>> memory_region_init_ram_from_fd(&backend->mr, OBJECT(backend), name,
+ *   - hw/misc/ivshmem.c|499| <<process_msg_shmem>> memory_region_init_ram_from_fd(&s->server_bar2, OBJECT(s), "ivshmem.bar2",
+ *   - hw/remote/memory.c|46| <<remote_sysmem_reconfig>> memory_region_init_ram_from_fd(subregion, NULL,
+ */
 void memory_region_init_ram_from_fd(MemoryRegion *mr,
                                     Object *owner,
                                     const char *name,
@@ -2244,6 +2327,18 @@ void memory_region_set_log(MemoryRegion *mr, bool log, unsigned client)
     memory_region_transaction_commit();
 }
 
+/*
+ * 部分调用的例子:
+ *   - hw/arm/virt-acpi-build.c|1068| <<acpi_ram_update>> memory_region_set_dirty(mr, 0, size);
+ *   - hw/hyperv/hyperv.c|286| <<cpu_post_msg>> memory_region_set_dirty(&synic->msg_page_mr, 0, sizeof(*synic->msg_page));
+ *   - hw/hyperv/hyperv.c|363| <<hyperv_set_event_flag>> memory_region_set_dirty(&synic->event_page_mr, 0,
+ *   - hw/i386/acpi-build.c|2733| <<acpi_ram_update>> memory_region_set_dirty(mr, 0, size);
+ *   - hw/i386/kvm/xen_gnttab.c|257| <<gnt_unref>> memory_region_set_dirty(mrs->mr, mrs->offset_within_region,
+ *   - hw/i386/xen/xen-hvm.c|397| <<xen_sync_dirty_bitmap>> memory_region_set_dirty(framebuffer, 0, size);
+ *   - hw/i386/xen/xen-hvm.c|410| <<xen_sync_dirty_bitmap>> memory_region_set_dirty(framebuffer,
+ *   - hw/virtio/vhost.c|133| <<vhost_dev_sync_region>> memory_region_set_dirty(section->mr, mr_offset, VHOST_LOG_PAGE);
+ *   - target/i386/kvm/xen-emu.c|1911| <<kvm_get_xen_state>> memory_region_set_dirty(mrs.mr, mrs.offset_within_region,
+ */
 void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
                              hwaddr size)
 {
@@ -2257,6 +2352,11 @@ void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
  * If memory region `mr' is NULL, do global sync.  Otherwise, sync
  * dirty bitmap for the specified memory region.
  */
+/*
+ * called by:
+ *   - system/memory.c|2388| <<memory_region_snapshot_and_clear_dirty>> memory_region_sync_dirty_bitmap(mr, false);
+ *   - system/memory.c|2919| <<memory_global_dirty_log_sync>> memory_region_sync_dirty_bitmap(NULL, last_stage);
+ */
 static void memory_region_sync_dirty_bitmap(MemoryRegion *mr, bool last_stage)
 {
     MemoryListener *listener;
@@ -2880,6 +2980,14 @@ bool memory_region_present(MemoryRegion *container, hwaddr addr)
     return mr && mr != container;
 }
 
+/*
+ * called by:
+ *   - migration/dirtyrate.c|110| <<global_dirty_log_sync>> memory_global_dirty_log_sync(false);
+ *   - migration/dirtyrate.c|622| <<calculate_dirtyrate_dirty_bitmap>> memory_global_dirty_log_sync(false);
+ *   - migration/ram.c|1046| <<migration_bitmap_sync>> memory_global_dirty_log_sync(last_stage);
+ *   - migration/ram.c|3459| <<colo_incoming_start_dirty_log>> memory_global_dirty_log_sync(false);
+ *   - migration/ram.c|3752| <<colo_flush_ram_cache>> memory_global_dirty_log_sync(false);
+ */
 void memory_global_dirty_log_sync(bool last_stage)
 {
     memory_region_sync_dirty_bitmap(NULL, last_stage);
@@ -3562,6 +3670,34 @@ void mtree_info(bool flatview, bool dispatch_tree, bool owner, bool disabled)
     }
 }
 
+/*
+ * 部分调用的例子:
+ *   - hw/arm/vexpress.c|386| <<a15_daughterboard_init>> memory_region_init_ram(&vms->a15sram, NULL, "vexpress.a15sram", 0x10000,
+ *   - hw/arm/vexpress.c|672| <<vexpress_common_init>> memory_region_init_ram(&vms->sram, NULL, "vexpress.sram", sram_size,
+ *   - hw/arm/vexpress.c|677| <<vexpress_common_init>> memory_region_init_ram(&vms->vram, NULL, "vexpress.vram", vram_size,
+ *   - hw/arm/virt.c|1580| <<create_tag_ram>> memory_region_init_ram(tagram, NULL, name, size / 32, &error_fatal);
+ *   - hw/arm/virt.c|1594| <<create_secure_ram>> memory_region_init_ram(secram, NULL, "virt.secure-ram", size,
+ *   - hw/arm/virt.c|1993| <<virt_cpu_post_init>> memory_region_init_ram(pvtime, NULL, "pvtime", pvtime_size, NULL);
+ *   - hw/arm/xen_arm.c|114| <<xen_init_ram>> memory_region_init_ram(&ram_memory, NULL, "xen.ram", block_len,
+ *   - hw/hyperv/hyperv.c|110| <<synic_realize>> memory_region_init_ram(&synic->msg_page_mr, obj, msgp_name,
+ *   - hw/hyperv/hyperv.c|112| <<synic_realize>> memory_region_init_ram(&synic->event_page_mr, obj, eventp_name,
+ *   - hw/i386/kvm/xen_gnttab.c|77| <<xen_gnttab_realize>> memory_region_init_ram(&s->gnt_frames, OBJECT(dev), "xen:grant_table",
+ *   - hw/i386/kvm/xen_overlay.c|94| <<xen_overlay_realize>> memory_region_init_ram(&s->shinfo_mem, OBJECT(dev), "xen:shared_info",
+ *   - hw/i386/kvm/xen_primary_console.c|60| <<xen_primary_console_realize>> memory_region_init_ram(&s->console_page, OBJECT(dev), "xen:console_page",
+ *   - hw/i386/kvm/xen_xenstore.c|123| <<xen_xenstore_realize>> memory_region_init_ram(&s->xenstore_page, OBJECT(dev), "xen:xenstore_page",
+ *   - hw/i386/pc.c|1040| <<pc_memory_init>> memory_region_init_ram(option_rom_mr, NULL, "pc.rom", PC_ROM_SIZE,
+ *   - hw/i386/pc_sysfw.c|57| <<pc_isa_bios_init>> memory_region_init_ram(isa_bios, NULL, "isa-bios", isa_bios_size,
+ *   - hw/i386/x86.c|1158| <<x86_bios_rom_init>> memory_region_init_ram(bios, NULL, "pc.bios", bios_size, &error_fatal);
+ *   - hw/i386/xen/xen-hvm.c|152| <<xen_ram_init>> memory_region_init_ram(&ram_memory, NULL, "xen.ram", block_len,
+ *   - hw/openrisc/openrisc_sim.c|310| <<openrisc_sim_init>> memory_region_init_ram(ram, NULL, "openrisc.ram", ram_size, &error_fatal);
+ *   - hw/openrisc/virt.c|496| <<openrisc_virt_init>> memory_region_init_ram(ram, NULL, "openrisc.ram", ram_size, &error_fatal);
+ *   - hw/riscv/microchip_pfsoc.c|220| <<microchip_pfsoc_soc_realize>> memory_region_init_ram(rsvd0_mem, NULL, "microchip.pfsoc.rsvd0_mem",
+ *   - hw/riscv/microchip_pfsoc.c|227| <<microchip_pfsoc_soc_realize>> memory_region_init_ram(e51_dtim_mem, NULL, "microchip.pfsoc.e51_dtim_mem",
+ *   - hw/riscv/microchip_pfsoc.c|272| <<microchip_pfsoc_soc_realize>> memory_region_init_ram(l2lim_mem, NULL, "microchip.pfsoc.l2lim",
+ *   - hw/riscv/sifive_u.c|546| <<sifive_u_machine_init>> memory_region_init_ram(flash0, NULL, "riscv.sifive.u.flash0",
+ *   - hw/riscv/sifive_u.c|825| <<sifive_u_soc_realize>> memory_region_init_ram(l2lim_mem, NULL, "riscv.sifive.u.l2lim",
+ *   - hw/xen/xen_pt_load_rom.c|67| <<pci_assign_dev_load_option_rom>> memory_region_init_ram(&dev->rom, owner, name, dev->romsize, &error_abort);
+ */
 void memory_region_init_ram(MemoryRegion *mr,
                             Object *owner,
                             const char *name,
diff --git a/system/physmem.c b/system/physmem.c
index a63853a7b..46ae2d672 100644
--- a/system/physmem.c
+++ b/system/physmem.c
@@ -1285,6 +1285,11 @@ static int64_t get_file_align(int fd)
     return align;
 }
 
+/*
+ * called by:
+ *   - system/physmem.c|1991| <<qemu_ram_alloc_from_file>> fd = file_ram_open(mem_path, memory_region_name(mr),
+ *   - system/physmem.c|2003| <<qemu_ram_alloc_from_file>> fd = file_ram_open(mem_path, memory_region_name(mr), true,
+ */
 static int file_ram_open(const char *path,
                          const char *region_name,
                          bool readonly,
@@ -1366,6 +1371,47 @@ static int file_ram_open(const char *path,
     return fd;
 }
 
+/*
+ * -object thread-context,id=tc01,node-affinity=0 \
+ * -object memory-backend-file,id=ram01,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=0,policy=bind,prealloc-context=tc01 \
+ * -numa node,nodeid=0,cpus=0-1,memdev=ram01 \
+ * -object thread-context,id=tc02,node-affinity=1 \
+ * -object memory-backend-file,id=ram02,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=1,policy=bind,prealloc-context=tc02 \
+ * -numa node,nodeid=1,cpus=2-3,memdev=ram02 \
+ *
+ * (gdb) bt
+ * #0  file_ram_alloc (block=0x5555570507a0, memory=68719476736, fd=12, truncate=true, offset=0, errp=0x7fffffffd8f0) at ../system/physmem.c:1379
+ * #1  0x0000555555d9d7e6 in qemu_ram_alloc_from_fd (size=68719476736, mr=0x555557245ec0, ram_flags=512, fd=12, offset=0, errp=0x7fffffffd8f0) at ../system/physmem.c:1941
+ * #2  0x0000555555d9da02 in qemu_ram_alloc_from_file (size=68719476736, mr=0x555557245ec0, ram_flags=512, mem_path=0x5555572ceda0 "/dev/hugepages/libvirt/qemu", offset=0,
+ *                                 errp=0x7fffffffd8f0) at ../system/physmem.c:1994
+ * #3  0x0000555555d91a1e in memory_region_init_ram_from_file (mr=0x555557245ec0, owner=0x555557245e50, name=0x555557051f90 "ram-node0", size=68719476736, align=0,
+ *                                 ram_flags=512, path=0x5555572ceda0 "/dev/hugepages/libvirt/qemu", offset=0, errp=0x7fffffffd990) at ../system/memory.c:1620
+ * #4  0x0000555555b7ee52 in file_backend_memory_alloc (backend=0x555557245e50, errp=0x7fffffffd990) at ../backends/hostmem-file.c:89
+ * #5  0x0000555555b7d0de in host_memory_backend_memory_complete (uc=0x555557245e50, errp=0x7fffffffda08) at ../backends/hostmem.c:332
+ * #6  0x0000555555e121a2 in user_creatable_complete (uc=0x555557245e50, errp=0x7fffffffda68) at ../qom/object_interfaces.c:28
+ * #7  0x0000555555e1262e in user_creatable_add_type (type=0x5555562af104 "memory-backend-file", id=0x555557053f10 "ram-node0", qdict=0x5555572d6b70, v=0x5555572d0d90,
+ *                                 errp=0x7fffffffda80) at ../qom/object_interfaces.c:125
+ * #8  0x0000555555e127d4 in user_creatable_add_qapi (options=0x555557053bc0, errp=0x555556fc8340 <error_fatal>) at ../qom/object_interfaces.c:157
+ * #9  0x0000555555b7231c in object_option_foreach_add (type_opt_predicate=0x555555b7295d <object_create_late>) at ../system/vl.c:1792
+ * #10 0x0000555555b729e4 in qemu_create_late_backends () at ../system/vl.c:2011
+ * #11 0x0000555555b76f4c in qemu_init (argc=31, argv=0x7fffffffde38) at ../system/vl.c:3727
+ * #12 0x0000555555e01cbf in main (argc=31, argv=0x7fffffffde38) at ../system/main.c:47
+ *
+ * 一个例子:
+ * host_memory_backend_memory_complete()
+ * -> bc->alloc = file_backend_memory_alloc()
+ *    -> memory_region_init_ram_from_file()
+ *       -> qemu_ram_alloc_from_file()
+ *          -> qemu_ram_alloc_from_fd()
+ *             -> file_ram_alloc() 
+ *                -> qemu_ram_mmap()
+ *                   -> mmap_activate()
+ *                      -> mmap()
+ *                -> "unable to map backing store for guest RAM"
+ *
+ * called by:
+ *   - system/physmem.c|1941| <<qemu_ram_alloc_from_fd>> new_block->host = file_ram_alloc(new_block, size, fd, !file_size, offset, errp);
+ */
 static void *file_ram_alloc(RAMBlock *block,
                             ram_addr_t memory,
                             int fd,
@@ -1803,6 +1849,11 @@ static void dirty_memory_extend(ram_addr_t old_ram_size,
     }
 }
 
+/*
+ * called by:
+ *   - system/physmem.c|1957| <<qemu_ram_alloc_from_fd>> ram_block_add(new_block, &local_err);
+ *   - system/physmem.c|2047| <<qemu_ram_alloc_internal>> ram_block_add(new_block, &local_err);
+ */
 static void ram_block_add(RAMBlock *new_block, Error **errp)
 {
     const bool noreserve = qemu_ram_is_noreserve(new_block);
@@ -1892,6 +1943,11 @@ static void ram_block_add(RAMBlock *new_block, Error **errp)
 }
 
 #ifdef CONFIG_POSIX
+/*
+ * called by:
+ *   - system/memory.c|1644| <<memory_region_init_ram_from_fd>> mr->ram_block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, offset,
+ *   - system/physmem.c|1994| <<qemu_ram_alloc_from_file>> block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, offset, errp);
+ */
 RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
                                  uint32_t ram_flags, int fd, off_t offset,
                                  Error **errp)
@@ -1938,6 +1994,12 @@ RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
     new_block->used_length = size;
     new_block->max_length = size;
     new_block->flags = ram_flags;
+    /*
+     * RAMBlock *new_block;
+     * -> uint8_t *host;
+     *
+     * 只在这里调用
+     */
     new_block->host = file_ram_alloc(new_block, size, fd, !file_size, offset,
                                      errp);
     if (!new_block->host) {
@@ -1956,6 +2018,22 @@ RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
 }
 
 
+/*
+ * called by:
+ *   - system/memory.c|1620| <<memory_region_init_ram_from_file>> mr->ram_block = qemu_ram_alloc_from_file(size, mr, ram_flags, path,
+ *
+ * 一个例子:
+ * host_memory_backend_memory_complete()
+ * -> bc->alloc = file_backend_memory_alloc()
+ *    -> memory_region_init_ram_from_file()
+ *       -> qemu_ram_alloc_from_file()
+ *          -> qemu_ram_alloc_from_fd()
+ *             -> file_ram_alloc()
+ *                -> qemu_ram_mmap()
+ *                   -> mmap_activate()
+ *                      -> mmap()
+ *                -> "unable to map backing store for guest RAM"
+ */
 RAMBlock *qemu_ram_alloc_from_file(ram_addr_t size, MemoryRegion *mr,
                                    uint32_t ram_flags, const char *mem_path,
                                    off_t offset, Error **errp)
@@ -1991,6 +2069,11 @@ RAMBlock *qemu_ram_alloc_from_file(ram_addr_t size, MemoryRegion *mr,
         return NULL;
     }
 
+    /*
+     * called by:
+     *   - system/memory.c|1644| <<memory_region_init_ram_from_fd>> mr->ram_block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, offset,
+     *   - system/physmem.c|1994| <<qemu_ram_alloc_from_file>> block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, offset, errp);
+     */
     block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, offset, errp);
     if (!block) {
         if (created) {
@@ -2004,6 +2087,12 @@ RAMBlock *qemu_ram_alloc_from_file(ram_addr_t size, MemoryRegion *mr,
 }
 #endif
 
+/*
+ * called by:
+ *   - system/physmem.c|2059| <<qemu_ram_alloc_from_ptr>> return qemu_ram_alloc_internal(size, size, NULL, host, RAM_PREALLOC, mr,
+ *   - system/physmem.c|2067| <<qemu_ram_alloc>> return qemu_ram_alloc_internal(size, size, NULL, NULL, ram_flags, mr, errp);
+ *   - system/physmem.c|2076| <<qemu_ram_alloc_resizeable>> return qemu_ram_alloc_internal(size, maxsz, resized, NULL,
+ */
 static
 RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                   void (*resized)(const char*,
diff --git a/system/runstate.c b/system/runstate.c
index ea9d6c2a3..f1323a687 100644
--- a/system/runstate.c
+++ b/system/runstate.c
@@ -774,6 +774,10 @@ static bool main_loop_should_exit(int *status)
     return false;
 }
 
+/*
+ * called by:
+ *   - system/main.c|37| <<qemu_default_main>> status = qemu_main_loop();
+ */
 int qemu_main_loop(void)
 {
     int status = EXIT_SUCCESS;
diff --git a/system/vl.c b/system/vl.c
index 2bcd9efb9..2641e1bcf 100644
--- a/system/vl.c
+++ b/system/vl.c
@@ -2000,6 +2000,10 @@ static bool object_create_late(const char *type)
     return !object_create_early(type) && !object_create_pre_sandbox(type);
 }
 
+/*
+ * called by:
+ *   - system/vl.c|3727| <<qemu_init>> qemu_create_late_backends();
+ */
 static void qemu_create_late_backends(void)
 {
     if (qtest_chrdev) {
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 4ce80555b..734b7d670 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -4286,6 +4286,10 @@ static int kvm_get_mp_state(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|4753| <<kvm_arch_get_registers>> ret = kvm_get_apic(cpu);
+ */
 static int kvm_get_apic(X86CPU *cpu)
 {
     DeviceState *apic = cpu->apic_state;
@@ -4303,6 +4307,72 @@ static int kvm_get_apic(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_post_init (cpu=0x555557ffdca0) at ../accel/kvm/kvm-all.c:2751
+ * #1  0x0000555555b4d8cc in cpu_synchronize_post_init (cpu=0x555557ffdca0) at ../system/cpus.c:185
+ * #2  0x0000555555860dfd in cpu_common_realizefn (dev=0x555557ffdca0, errp=0x7fffffffc450) at ../hw/core/cpu-common.c:213
+ * #3  0x0000555555c66ea8 in x86_cpu_realizefn (dev=0x555557ffdca0, errp=0x7fffffffc510) at ../target/i386/cpu.c:7462
+ * #4  0x0000555555c604c0 in max_x86_cpu_realize (dev=0x555557ffdca0, errp=0x7fffffffc510) at ../target/i386/cpu.c:4956
+ * #5  0x0000555555ddbbaa in device_set_realized (obj=0x555557ffdca0, value=true, errp=0x7fffffffc850) at ../hw/core/qdev.c:510
+ * #6  0x0000555555de5938 in property_set_bool (obj=0x555557ffdca0, v=0x5555577627f0, name=0x555556209d19 "realized", opaque=0x555556fec8c0, errp=0x7fffffffc850) at ../qom/object.c:2305
+ * #7  0x0000555555de393e in object_property_set (obj=0x555557ffdca0, name=0x555556209d19 "realized", v=0x5555577627f0, errp=0x7fffffffc850) at ../qom/object.c:1435
+ * #8  0x0000555555de7d2a in object_property_set_qobject (obj=0x555557ffdca0, name=0x555556209d19 "realized", value=0x555557b6dac0, errp=0x7fffffffc850) at ../qom/qom-qobject.c:28
+ * #9  0x0000555555de3ca3 in object_property_set_bool (obj=0x555557ffdca0, name=0x555556209d19 "realized", value=true, errp=0x7fffffffc850) at ../qom/object.c:1504
+ * #10 0x0000555555ddb3aa in qdev_realize (dev=0x555557ffdca0, bus=0x0, errp=0x7fffffffc850) at ../hw/core/qdev.c:292
+ * #11 0x0000555555b558ae in qdev_device_add_from_qdict (opts=0x555557e41390, from_json=false, errp=0x7fffffffc850) at ../system/qdev-monitor.c:719
+ * #12 0x0000555555b5594c in qdev_device_add (opts=0x555557bf44a0, errp=0x7fffffffc850) at ../system/qdev-monitor.c:738
+ * #13 0x0000555555b55f60 in qmp_device_add (qdict=0x555557e40370, ret_data=0x0, errp=0x7fffffffc850) at ../system/qdev-monitor.c:860
+ * #14 0x0000555555b56370 in hmp_device_add (mon=0x555557242b30, qdict=0x555557e40370) at ../system/qdev-monitor.c:968
+ * #15 0x0000555555bb0241 in handle_hmp_command_exec (mon=0x555557242b30, cmd=0x555556e732e0 <hmp_cmds+1920>, qdict=0x555557e40370) at ../monitor/hmp.c:1106
+ * #16 0x0000555555bb046e in handle_hmp_command (mon=0x555557242b30, cmdline=0x55555727c88b "host-x86_64-cpu,id=core4,socket-id=0,core-id=2,thread-id=0") at ../monitor/hmp.c:1158
+ * #17 0x0000555555bad95a in monitor_command_cb (opaque=0x555557242b30, cmdline=0x55555727c880 "device_add host-x86_64-cpu,id=core4,socket-id=0,core-id=2,thread-id=0", readline_opaque=0x0)
+ *                                               at ../monitor/hmp.c:47
+ * #18 0x0000555556001e9f in readline_handle_byte (rs=0x55555727c880, ch=13) at ../util/readline.c:419
+ * #19 0x0000555555bb0f19 in monitor_read (opaque=0x555557242b30, buf=0x7fffffffcab0 "\r\322\377\377\377\177", size=1) at ../monitor/hmp.c:1390
+ * #20 0x0000555555f06291 in qemu_chr_be_write_impl (s=0x555557240470, buf=0x7fffffffcab0 "\r\322\377\377\377\177", len=1) at ../chardev/char.c:202
+ * #21 0x0000555555f062f5 in qemu_chr_be_write (s=0x555557240470, buf=0x7fffffffcab0 "\r\322\377\377\377\177", len=1) at ../chardev/char.c:214
+ * #22 0x0000555555f08ca2 in fd_chr_read (chan=0x5555572403e0, cond=G_IO_IN, opaque=0x555557240470) at ../chardev/char-fd.c:72
+ * #23 0x0000555555df4fa8 in qio_channel_fd_source_dispatch (source=0x5555573ee7a0, callback=0x555555f08b78 <fd_chr_read>, user_data=0x555557240470) at ../io/channel-watch.c:84
+ * #24 0x00007ffff69ef119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #25 0x0000555555feb300 in glib_pollfds_poll () at ../util/main-loop.c:290
+ * #26 0x0000555555feb37a in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:313
+ * #27 0x0000555555feb47f in main_loop_wait (nonblocking=0) at ../util/main-loop.c:592
+ * #28 0x0000555555b5be98 in qemu_main_loop () at ../system/runstate.c:782
+ * #29 0x0000555555dd6e12 in qemu_default_main () at ../system/main.c:37
+ * #30 0x0000555555dd6e4d in main (argc=22, argv=0x7fffffffdd78) at ../system/main.c:48
+ *
+ * Thread 35 "CPU 2/KVM" hit Breakpoint 5, do_kvm_cpu_synchronize_post_init (cpu=0x555557ffdca0, arg=...) at ../accel/kvm/kvm-all.c:2740
+ * 2740	    int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);
+ * (gdb) bt
+ * #0  do_kvm_cpu_synchronize_post_init (cpu=0x555557ffdca0, arg=...) at ../accel/kvm/kvm-all.c:2740
+ * #1  0x0000555555863186 in process_queued_cpu_work (cpu=0x555557ffdca0) at ../cpu-common.c:360
+ * #2  0x0000555555b4deb4 in qemu_wait_io_event_common (cpu=0x555557ffdca0) at ../system/cpus.c:419
+ * #3  0x0000555555b4df46 in qemu_wait_io_event (cpu=0x555557ffdca0) at ../system/cpus.c:437
+ * #4  0x0000555555dca699 in kvm_vcpu_thread_fn (arg=0x555557ffdca0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x0000555555fd1784 in qemu_thread_start (args=0x5555574bea40) at ../util/qemu-thread-posix.c:541
+ * #6  0x00007ffff5395ea5 in start_thread () at /lib64/libpthread.so.0
+ * #7  0x00007ffff50be9fd in clone () at /lib64/libc.so.6
+ *
+ * Thread 35 "CPU 2/KVM" hit Breakpoint 3, kvm_put_vcpu_events (cpu=0x555557ffdca0, level=3) at ../target/i386/kvm/kvm.c:4307
+ * 4307	{
+ * (gdb) bt
+ * #0  kvm_put_vcpu_events (cpu=0x555557ffdca0, level=3) at ../target/i386/kvm/kvm.c:4307
+ * #1  0x0000555555c00838 in kvm_arch_put_registers (cpu=0x555557ffdca0, level=3) at ../target/i386/kvm/kvm.c:4620
+ * #2  0x0000555555dc74f7 in do_kvm_cpu_synchronize_post_init (cpu=0x555557ffdca0, arg=...) at ../accel/kvm/kvm-all.c:2740
+ * #3  0x0000555555863186 in process_queued_cpu_work (cpu=0x555557ffdca0) at ../cpu-common.c:360
+ * #4  0x0000555555b4deb4 in qemu_wait_io_event_common (cpu=0x555557ffdca0) at ../system/cpus.c:419
+ * #5  0x0000555555b4df46 in qemu_wait_io_event (cpu=0x555557ffdca0) at ../system/cpus.c:437
+ * #6  0x0000555555dca699 in kvm_vcpu_thread_fn (arg=0x555557ffdca0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #7  0x0000555555fd1784 in qemu_thread_start (args=0x5555574bea40) at ../util/qemu-thread-posix.c:541
+ * #8  0x00007ffff5395ea5 in start_thread () at /lib64/libpthread.so.0
+ * #9  0x00007ffff50be9fd in clone () at /lib64/libc.so.6
+ */
+
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|4620| <<kvm_arch_put_registers>> ret = kvm_put_vcpu_events(x86_cpu, level);
+ */
 static int kvm_put_vcpu_events(X86CPU *cpu, int level)
 {
     CPUState *cs = CPU(cpu);
@@ -4551,6 +4621,12 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2734| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE);
+ *   - accel/kvm/kvm-all.c|2751| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);
+ *   - accel/kvm/kvm-all.c|2853| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);
+ */
 int kvm_arch_put_registers(CPUState *cpu, int level)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -4848,6 +4924,10 @@ MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
     return cpu_get_mem_attrs(env);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2849| <<kvm_cpu_exec>> if (kvm_arch_process_async_events(cpu)) {
+ */
 int kvm_arch_process_async_events(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -5124,6 +5204,10 @@ void kvm_arch_update_guest_debug(CPUState *cpu, struct kvm_guest_debug *dbg)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|5258| <<kvm_filter_msr>> if (!kvm_install_msr_filters(s)) {
+ */
 static bool kvm_install_msr_filters(KVMState *s)
 {
     uint64_t zero = 0;
@@ -5162,6 +5246,10 @@ static bool kvm_install_msr_filters(KVMState *s)
     return true;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2707| <<kvm_arch_init>> r = kvm_filter_msr(s, MSR_CORE_THREAD_COUNT, kvm_rdmsr_core_thread_count, NULL);
+ */
 bool kvm_filter_msr(KVMState *s, uint32_t msr, QEMURDMSRHandler *rdmsr,
                     QEMUWRMSRHandler *wrmsr)
 {
diff --git a/util/main-loop.c b/util/main-loop.c
index 797b640c4..8fad8e3d8 100644
--- a/util/main-loop.c
+++ b/util/main-loop.c
@@ -293,6 +293,10 @@ static void glib_pollfds_poll(void)
 
 #define MAX_MAIN_LOOP_SPIN (1000)
 
+/*
+ * called by:
+ *   - util/main-loop.c|596| <<main_loop_wait>> ret = os_host_main_loop_wait(timeout_ns);
+ */
 static int os_host_main_loop_wait(int64_t timeout)
 {
     GMainContext *context = g_main_context_default();
@@ -305,6 +309,9 @@ static int os_host_main_loop_wait(int64_t timeout)
     qemu_mutex_unlock_iothread();
     replay_mutex_unlock();
 
+    /*
+     * 这里就是等
+     */
     ret = qemu_poll_ns((GPollFD *)gpollfds->data, gpollfds->len, timeout);
 
     replay_mutex_lock();
@@ -547,6 +554,14 @@ static int os_host_main_loop_wait(int64_t timeout)
 }
 #endif
 
+/*
+ * 在以下使用main_loop_poll_notifiers:
+ *   - util/main-loop.c|550| <<global>> static NotifierList main_loop_poll_notifiers = NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
+ *   - util/main-loop.c|551| <<global>> NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
+ *   - util/main-loop.c|555| <<main_loop_poll_add_notifier>> notifier_list_add(&main_loop_poll_notifiers, notify);
+ *   - util/main-loop.c|580| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+ *   - util/main-loop.c|594| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+ */
 static NotifierList main_loop_poll_notifiers =
     NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
 
@@ -560,6 +575,31 @@ void main_loop_poll_remove_notifier(Notifier *notify)
     notifier_remove(notify);
 }
 
+/*
+ * called by:
+ *   - qemu-img.c|2148| <<convert_do_copy>> main_loop_wait(false);
+ *   - qemu-img.c|4743| <<img_bench>> main_loop_wait(false);
+ *   - qemu-io-cmds.c|651| <<do_aio_readv>> main_loop_wait(false);
+ *   - qemu-io-cmds.c|665| <<do_aio_writev>> main_loop_wait(false);
+ *   - qemu-io-cmds.c|1884| <<do_aio_zone_append>> main_loop_wait(false);
+ *   - qemu-io-cmds.c|2632| <<sleep_f>> main_loop_wait(false);
+ *   - qemu-io.c|453| <<command_loop>> main_loop_wait(false);
+ *   - qemu-nbd.c|1209| <<main>> main_loop_wait(false);
+ *   - scsi/qemu-pr-helper.c|1069| <<main>> main_loop_wait(false);
+ *   - storage-daemon/qemu-storage-daemon.c|434| <<main>> main_loop_wait(false);
+ *   - system/runstate.c|782| <<qemu_main_loop>> main_loop_wait(false);
+ *   - tests/qtest/fuzz/fuzz.c|50| <<flush_events>> main_loop_wait(false);
+ *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> main_loop_wait(true);
+ *   - tests/unit/test-char.c|34| <<main_loop>> main_loop_wait(false);
+ *   - tests/unit/test-char.c|837| <<char_socket_server_test>> main_loop_wait(false);
+ *   - tests/unit/test-char.c|860| <<char_socket_server_test>> main_loop_wait(false);
+ *   - tests/unit/test-char.c|1044| <<char_socket_client_test>> main_loop_wait(false);
+ *   - tests/unit/test-char.c|1067| <<char_socket_client_test>> main_loop_wait(false);
+ *   - tests/unit/test-replication.c|78| <<test_blk_read>> main_loop_wait(false);
+ *   - tests/unit/test-replication.c|115| <<test_blk_write>> main_loop_wait(false);
+ *   - tests/unit/test-util-filemonitor.c|85| <<qemu_file_monitor_test_event_loop>> main_loop_wait(true);
+ *   - ui/gtk-clipboard.c|55| <<gd_clipboard_get_data>> main_loop_wait(false);
+ */
 void main_loop_wait(int nonblocking)
 {
     MainLoopPoll mlpoll = {
@@ -576,6 +616,14 @@ void main_loop_wait(int nonblocking)
 
     /* poll any events */
     g_array_set_size(gpollfds, 0); /* reset for new iteration */
+    /*
+     * 在以下使用main_loop_poll_notifiers:
+     *   - util/main-loop.c|550| <<global>> static NotifierList main_loop_poll_notifiers = NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
+     *   - util/main-loop.c|551| <<global>> NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
+     *   - util/main-loop.c|555| <<main_loop_poll_add_notifier>> notifier_list_add(&main_loop_poll_notifiers, notify);
+     *   - util/main-loop.c|580| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+     *   - util/main-loop.c|594| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+     */
     /* XXX: separate device handlers from system ones */
     notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
 
@@ -591,6 +639,14 @@ void main_loop_wait(int nonblocking)
 
     ret = os_host_main_loop_wait(timeout_ns);
     mlpoll.state = ret < 0 ? MAIN_LOOP_POLL_ERR : MAIN_LOOP_POLL_OK;
+    /*
+     * 在以下使用main_loop_poll_notifiers:
+     *   - util/main-loop.c|550| <<global>> static NotifierList main_loop_poll_notifiers = NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
+     *   - util/main-loop.c|551| <<global>> NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
+     *   - util/main-loop.c|555| <<main_loop_poll_add_notifier>> notifier_list_add(&main_loop_poll_notifiers, notify);
+     *   - util/main-loop.c|580| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+     *   - util/main-loop.c|594| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+     */
     notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
 
     if (icount_enabled()) {
diff --git a/util/mmap-alloc.c b/util/mmap-alloc.c
index ed14f9c64..13e305de0 100644
--- a/util/mmap-alloc.c
+++ b/util/mmap-alloc.c
@@ -174,6 +174,9 @@ static void *mmap_reserve(size_t size, int fd)
     flags |= MAP_ANONYMOUS;
 #endif
 
+    /*
+     * 没用fd!!!
+     */
     return mmap(0, size, PROT_NONE, flags, fd, 0);
 }
 
@@ -181,6 +184,10 @@ static void *mmap_reserve(size_t size, int fd)
  * Activate memory in a reserved region from the given fd (if any), to make
  * it accessible.
  */
+/*
+ * called by:
+ *   - util/mmap-alloc.c|320| <<qemu_ram_mmap>> ptr = mmap_activate(guardptr + offset, size, fd, qemu_map_flags,
+ */
 static void *mmap_activate(void *ptr, size_t size, int fd,
                            uint32_t qemu_map_flags, off_t map_offset)
 {
@@ -244,6 +251,52 @@ static inline size_t mmap_guard_pagesize(int fd)
 #endif
 }
 
+/*
+ * map bios的例子:
+ * (gdb) bt
+ * #0  qemu_ram_mmap (fd=-1, size=262144, align=2097152, qemu_map_flags=0, map_offset=0) at ../util/mmap-alloc.c:253
+ * #1  0x0000555555ffae09 in qemu_anon_ram_alloc (size=262144, alignment=0x5555570543a0, shared=false, noreserve=false) at ../util/oslib-posix.c:193
+ * #2  0x0000555555d9d25e in ram_block_add (new_block=0x5555573d5380, errp=0x7fffffffd638) at ../system/physmem.c:1830
+ * #3  0x0000555555d9dbf9 in qemu_ram_alloc_internal (size=262144, max_size=262144, resized=0x0, host=0x0, ram_flags=0, mr=0x555557054310, errp=0x7fffffffd6d0) at ../system/physmem.c:2034
+ * #4  0x0000555555d9dd06 in qemu_ram_alloc (size=262144, ram_flags=0, mr=0x555557054310, errp=0x7fffffffd6d0) at ../system/physmem.c:2054
+ * #5  0x0000555555d91807 in memory_region_init_ram_flags_nomigrate (mr=0x555557054310, owner=0x0, name=0x5555562131c0 "pc.bios", size=262144, ram_flags=0, errp=0x7fffffffd768) at ../system/memory.c:1570
+ * #6  0x0000555555d91779 in memory_region_init_ram_nomigrate (mr=0x555557054310, owner=0x0, name=0x5555562131c0 "pc.bios", size=262144, errp=0x7fffffffd768) at ../system/memory.c:1555
+ * #7  0x0000555555d9753f in memory_region_init_ram (mr=0x555557054310, owner=0x0, name=0x5555562131c0 "pc.bios", size=262144, errp=0x555556fc8340 <error_fatal>) at ../system/memory.c:3574
+ * #8  0x0000555555c35872 in x86_bios_rom_init (ms=0x5555572bb3d0, default_firmware=0x55555621e06e "bios.bin", rom_memory=0x555557054b60, isapc_ram_fw=false) at ../hw/i386/x86.c:1158
+ * #9  0x0000555555c5fe82 in pc_system_firmware_init (pcms=0x5555572bb3d0, rom_memory=0x555557054b60) at ../hw/i386/pc_sysfw.c:232
+ * #10 0x0000555555c5cfef in pc_memory_init (pcms=0x5555572bb3d0, system_memory=0x5555571832e0, rom_memory=0x555557054b60, pci_hole64_size=34359738368) at ../hw/i386/pc.c:1037
+ * #11 0x0000555555c4652f in pc_q35_init (machine=0x5555572bb3d0) at ../hw/i386/pc_q35.c:222
+ * #12 0x0000555555c46e8a in pc_init_v8_2 (machine=0x5555572bb3d0) at ../hw/i386/pc_q35.c:392
+ * #13 0x00005555559232c5 in machine_run_board_init (machine=0x5555572bb3d0, mem_path=0x0, errp=0x7fffffffdb10) at ../hw/core/machine.c:1509
+ * #14 0x0000555555b74388 in qemu_init_board () at ../system/vl.c:2613
+ * #15 0x0000555555b7460d in qmp_x_exit_preconfig (errp=0x555556fc8340 <error_fatal>) at ../system/vl.c:2704
+ * #16 0x0000555555b76fec in qemu_init (argc=31, argv=0x7fffffffde38) at ../system/vl.c:3753
+ * #17 0x0000555555e01cbf in main (argc=31, argv=0x7fffffffde38) at ../system/main.c:47
+ *
+ * map rom的例子:
+ * (gdb) bt
+ * #0  qemu_ram_mmap (fd=-1, size=131072, align=2097152, qemu_map_flags=0, map_offset=0) at ../util/mmap-alloc.c:253
+ * #1  0x0000555555ffae09 in qemu_anon_ram_alloc (size=131072, alignment=0x5555570533d0, shared=false, noreserve=false) at ../util/oslib-posix.c:193
+ * #2  0x0000555555d9d25e in ram_block_add (new_block=0x5555572c1d40, errp=0x7fffffffd708) at ../system/physmem.c:1830
+ * #3  0x0000555555d9dbf9 in qemu_ram_alloc_internal (size=131072, max_size=131072, resized=0x0, host=0x0, ram_flags=0, mr=0x555557053340, errp=0x7fffffffd7a0) at ../system/physmem.c:2034
+ * #4  0x0000555555d9dd06 in qemu_ram_alloc (size=131072, ram_flags=0, mr=0x555557053340, errp=0x7fffffffd7a0) at ../system/physmem.c:2054
+ * #5  0x0000555555d91807 in memory_region_init_ram_flags_nomigrate (mr=0x555557053340, owner=0x0, name=0x55555621d44f "pc.rom", size=131072, ram_flags=0, errp=0x7fffffffd838) at ../system/memory.c:1570
+ * #6  0x0000555555d91779 in memory_region_init_ram_nomigrate (mr=0x555557053340, owner=0x0, name=0x55555621d44f "pc.rom", size=131072, errp=0x7fffffffd838) at ../system/memory.c:1555
+ * #7  0x0000555555d9753f in memory_region_init_ram (mr=0x555557053340, owner=0x0, name=0x55555621d44f "pc.rom", size=131072, errp=0x555556fc8340 <error_fatal>) at ../system/memory.c:3574
+ * #8  0x0000555555c5d021 in pc_memory_init (pcms=0x5555572bb3d0, system_memory=0x5555571832e0, rom_memory=0x555557054b60, pci_hole64_size=34359738368) at ../hw/i386/pc.c:1040
+ * #9  0x0000555555c4652f in pc_q35_init (machine=0x5555572bb3d0) at ../hw/i386/pc_q35.c:222
+ * #10 0x0000555555c46e8a in pc_init_v8_2 (machine=0x5555572bb3d0) at ../hw/i386/pc_q35.c:392
+ * #11 0x00005555559232c5 in machine_run_board_init (machine=0x5555572bb3d0, mem_path=0x0, errp=0x7fffffffdb10) at ../hw/core/machine.c:1509
+ * #12 0x0000555555b74388 in qemu_init_board () at ../system/vl.c:2613
+ * #13 0x0000555555b7460d in qmp_x_exit_preconfig (errp=0x555556fc8340 <error_fatal>) at ../system/vl.c:2704
+ * #14 0x0000555555b76fec in qemu_init (argc=31, argv=0x7fffffffde38) at ../system/vl.c:3753
+ * #15 0x0000555555e01cbf in main (argc=31, argv=0x7fffffffde38) at ../system/main.c:47
+ */
+/*
+ * called by:
+ *   - system/physmem.c|1437| <<file_ram_alloc>> area = qemu_ram_mmap(fd, memory, block->mr->align, qemu_map_flags, offset);
+ *   - util/oslib-posix.c|193| <<qemu_anon_ram_alloc>> void *ptr = qemu_ram_mmap(-1, size, align, qemu_map_flags, 0);
+ */
 void *qemu_ram_mmap(int fd,
                     size_t size,
                     size_t align,
@@ -260,6 +313,9 @@ void *qemu_ram_mmap(int fd,
      */
     total = size + align;
 
+    /*
+     * 不用fd, 先用MAP_ANONYMOUS分配一些
+     */
     guardptr = mmap_reserve(total, fd);
     if (guardptr == MAP_FAILED) {
         return MAP_FAILED;
diff --git a/util/oslib-posix.c b/util/oslib-posix.c
index e86fd64e0..993a6a937 100644
--- a/util/oslib-posix.c
+++ b/util/oslib-posix.c
@@ -288,6 +288,16 @@ void qemu_set_tty_echo(int fd, bool echo)
     tcsetattr(fd, TCSANOW, &tty);
 }
 
+/*
+ * 在&sigbus_handler()调用siglongjmp(thread->env, 1);
+ *
+ * 在以下真正goto/jmp
+ * qemu_prealloc_mem()
+ * -> touch_all_pages()
+ *    -> do_touch_pages()
+ *       -> sigsetjmp(memset_args->env, 1)
+ *       -> for: *(volatile char *)addr = *addr;
+ */
 #ifdef CONFIG_LINUX
 static void sigbus_handler(int signal, siginfo_t *siginfo, void *ctx)
 #else /* CONFIG_LINUX */
@@ -327,6 +337,37 @@ static void sigbus_handler(int signal)
     warn_report("qemu_prealloc_mem: unrelated SIGBUS detected and ignored");
 }
 
+/*
+ * 597 void qemu_prealloc_mem(int fd, char *area, size_t sz, int max_threads,
+ * 598                        ThreadContext *tc, Error **errp)
+ * 599 {
+ * 624         memset(&act, 0, sizeof(act));
+ * 625 #ifdef CONFIG_LINUX
+ * 626         act.sa_sigaction = &sigbus_handler;
+ * 627         act.sa_flags = SA_SIGINFO;
+ * 628 #else  // CONFIG_LINUX
+ * 629         act.sa_handler = &sigbus_handler;
+ * 630         act.sa_flags = 0;
+ * 631 #endif // CONFIG_LINUX
+ * 632 
+ * 633        //
+ * 634        // The sigaction() system call is used to change the action taken by a
+ * 635        // process on receipt of a specific signal.
+ * 636        //
+ * 637         ret = sigaction(SIGBUS, &act, &sigbus_oldact);
+ *
+ * 在以下使用do_touch_pages():
+ *   - util/oslib-posix.c|482| <<touch_all_pages>> touch_fn = do_touch_pages;
+ *
+ * 在&sigbus_handler()调用siglongjmp(thread->env, 1);
+ *
+ * 在以下真正goto/jmp
+ * qemu_prealloc_mem()
+ * -> touch_all_pages()
+ *    -> do_touch_pages()
+ *       -> sigsetjmp(memset_args->env, 1)
+ *       -> for: *(volatile char *)addr = *addr;
+ */
 static void *do_touch_pages(void *arg)
 {
     MemsetThread *memset_args = (MemsetThread *)arg;
@@ -412,11 +453,48 @@ static inline int get_memset_num_threads(size_t hpagesize, size_t numpages,
     return ret;
 }
 
+/*
+ * -object thread-context,id=tc01,node-affinity=0 \
+ * -object memory-backend-file,id=ram01,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=0,policy=bind,prealloc-context=tc01 \
+ * -numa node,nodeid=0,cpus=0-1,memdev=ram01 \
+ * -object thread-context,id=tc02,node-affinity=1 \
+ * -object memory-backend-file,id=ram02,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=1,policy=bind,prealloc-context=tc02 \
+ * -numa node,nodeid=1,cpus=2-3,memdev=ram02 \
+ *
+ * Thread 8 "touch_pages" hit Breakpoint 1, do_madv_populate_write_pages (arg=0x5555570521d0) at ../util/oslib-posix.c:378
+ * 378	    MemsetThread *memset_args = (MemsetThread *)arg;
+ * (gdb) info threads 
+ *   Id   Target Id                                           Frame 
+ *   1    Thread 0x7ffff7460c80 (LWP 20402) "qemu-system-x86" 0x00007ffff772a3aa in __futex_abstimed_wait_common () from /lib64/libc.so.6
+ *   2    Thread 0x7ffff745f640 (LWP 20406) "qemu-system-x86" 0x00007ffff76cce5d in syscall () from /lib64/libc.so.6
+ *   3    Thread 0x7ffff6b5d640 (LWP 20407) "TC tc-ram-node0" 0x00007ffff772a3aa in __futex_abstimed_wait_common () from /lib64/libc.so.6
+ *   4    Thread 0x7ffff635c640 (LWP 20408) "TC tc-ram-node1" 0x00007ffff772a3aa in __futex_abstimed_wait_common () from /lib64/libc.so.6
+ *   6    Thread 0x7fffe7fff640 (LWP 20412) "touch_pages"     0x00007ffff76cceeb in madvise () from /lib64/libc.so.6
+ *   7    Thread 0x7fffe77fe640 (LWP 20413) "touch_pages"     0x0000555555ffb4d0 in do_madv_populate_write_pages (arg=0x5555570520e0) at ../util/oslib-posix.c:378
+ *   8    Thread 0x7fffe6ffd640 (LWP 20414) "touch_pages"     do_madv_populate_write_pages (arg=0x5555570521d0) at ../util/oslib-posix.c:378
+ *   9    Thread 0x7fffe67fc640 (LWP 20415) "touch_pages"     0x00007ffff77d5dd7 in mmap64 () from /lib64/libc.so.6
+ * (gdb) bt
+ * #0  do_madv_populate_write_pages (arg=0x5555570521d0) at ../util/oslib-posix.c:378
+ * #1  0x0000555555ffd7bb in qemu_thread_start (args=0x7fffe8000ea0) at ../util/qemu-thread-posix.c:541
+ * #2  0x00007ffff772d812 in start_thread () at /lib64/libc.so.6
+ * #3  0x00007ffff76cd450 in clone3 () at /lib64/libc.so.6
+ *
+ * called by:
+ *   - util/oslib-posix.c|542| <<qemu_prealloc_mem>> ret = touch_all_pages(area, hpagesize, numpages, max_threads, tc, use_madv_populate_write);
+ */
 static int touch_all_pages(char *area, size_t hpagesize, size_t numpages,
                            int max_threads, ThreadContext *tc,
                            bool use_madv_populate_write)
 {
     static gsize initialized = 0;
+    /*
+     * typedef struct MemsetContext {
+     *     bool all_threads_created;
+     *     bool any_thread_failed;
+     *     struct MemsetThread *threads;
+     *     int num_threads;
+     * } MemsetContext;
+     */
     MemsetContext context = {
         .num_threads = get_memset_num_threads(hpagesize, numpages, max_threads),
     };
@@ -491,12 +569,62 @@ static int touch_all_pages(char *area, size_t hpagesize, size_t numpages,
     return ret;
 }
 
+/*
+ * called by:
+ *   - util/oslib-posix.c|558| <<qemu_prealloc_mem>> use_madv_populate_write = madv_populate_write_possible(area, hpagesize);
+ */
 static bool madv_populate_write_possible(char *area, size_t pagesize)
 {
+    /*
+     * 对于madvise():
+     * RETURN VALUE
+     * On success, madvise() returns zero.  On error, it returns -1 and  errno is set appropriately.
+     */
     return !qemu_madvise(area, pagesize, QEMU_MADV_POPULATE_WRITE) ||
            errno != EINVAL;
 }
 
+/*
+ * 程序的例子.
+ * #include <stdio.h>
+ * #include <time.h>
+ * #include <signal.h>
+ * #include <unistd.h>
+ *
+ * void alarm_handler(int signal)
+ * {
+ *     printf("This is alarm!\n");
+ * }
+ *
+ * int main(int argc, char **argv)
+ * {
+ *     int i = 0;
+ *     struct sigaction sa;
+ *
+ *     sa.sa_handler = alarm_handler;
+ *     sa.sa_flags = 0;
+ *
+ *     if(sigaction(SIGALRM, &sa, NULL))
+ *     {
+ *         printf("sigaction error!\n");
+ *         return -1;
+ *     }
+ *
+ *     alarm(5);
+ *
+ *     while(1);
+ *     printf("Hello World!\n");
+ *
+ *     return 0;
+ * }
+ */
+/*
+ * called by:
+ *   - backends/hostmem.c|240| <<host_memory_backend_set_prealloc>> qemu_prealloc_mem(fd, ptr, sz, backend->prealloc_threads,
+ *   - backends/hostmem.c|402| <<host_memory_backend_memory_complete>> qemu_prealloc_mem(memory_region_get_fd(&backend->mr), ptr, sz,
+ *   - hw/virtio/virtio-mem.c|608| <<virtio_mem_set_block_state>> qemu_prealloc_mem(fd, area, size, 1, NULL, &local_err);
+ *   - hw/virtio/virtio-mem.c|1252| <<virtio_mem_prealloc_range_cb>> qemu_prealloc_mem(fd, area, size, 1, NULL, &local_err);
+ */
 void qemu_prealloc_mem(int fd, char *area, size_t sz, int max_threads,
                        ThreadContext *tc, Error **errp)
 {
@@ -507,6 +635,10 @@ void qemu_prealloc_mem(int fd, char *area, size_t sz, int max_threads,
     bool use_madv_populate_write;
     struct sigaction act;
 
+    /*
+     * #define MADV_POPULATE_READ      22      // populate (prefault) page tables readable
+     * #define MADV_POPULATE_WRITE     23      // populate (prefault) page tables writable
+     */
     /*
      * Sense on every invocation, as MADV_POPULATE_WRITE cannot be used for
      * some special mappings, such as mapping /dev/mem.
@@ -529,6 +661,10 @@ void qemu_prealloc_mem(int fd, char *area, size_t sz, int max_threads,
         act.sa_flags = 0;
 #endif /* CONFIG_LINUX */
 
+	/*
+	 * The sigaction() system call is used to change the action taken by a
+	 * process on receipt of a specific signal.
+	 */
         ret = sigaction(SIGBUS, &act, &sigbus_oldact);
         if (ret) {
             qemu_mutex_unlock(&sigbus_mutex);
@@ -538,6 +674,9 @@ void qemu_prealloc_mem(int fd, char *area, size_t sz, int max_threads,
         }
     }
 
+    /*
+     * 只在这里调用
+     */
     /* touch pages simultaneously */
     ret = touch_all_pages(area, hpagesize, numpages, max_threads, tc,
                           use_madv_populate_write);
diff --git a/util/qemu-config.c b/util/qemu-config.c
index 42076efe1..0c1c1621b 100644
--- a/util/qemu-config.c
+++ b/util/qemu-config.c
@@ -9,13 +9,44 @@
 #include "qemu/config-file.h"
 #include "hw/boards.h"
 
+/*
+ * 在以下使用vm_config_groups[48]:
+ *   - util/qemu-config.c|36| <<qemu_find_opts>> ret = find_list(vm_config_groups, group, &local_err);
+ *   - util/qemu-config.c|228| <<qmp_query_command_line_options>> for (i = 0; vm_config_groups[i] != NULL; i++) {
+ *   - util/qemu-config.c|229| <<qmp_query_command_line_options>> if (!option || !strcmp(option, vm_config_groups[i]->name)) {
+ *   - util/qemu-config.c|231| <<qmp_query_command_line_options>> info->option = g_strdup(vm_config_groups[i]->name);
+ *   - util/qemu-config.c|232| <<qmp_query_command_line_options>> if (!strcmp("drive", vm_config_groups[i]->name)) {
+ *   - util/qemu-config.c|236| <<qmp_query_command_line_options>> query_option_descs(vm_config_groups[i]->desc);
+ *   - util/qemu-config.c|258| <<qemu_find_opts_err>> return find_list(vm_config_groups, group, errp);
+ *   - util/qemu-config.c|281| <<qemu_add_opts>> entries = ARRAY_SIZE(vm_config_groups);
+ *   - util/qemu-config.c|284| <<qemu_add_opts>> if (vm_config_groups[i] == NULL) {
+ *   - util/qemu-config.c|285| <<qemu_add_opts>> vm_config_groups[i] = list;
+ *   - util/qemu-config.c|396| <<qemu_read_config_file>> ret = qemu_config_foreach(f, cb, vm_config_groups, filename, errp);
+ */
 static QemuOptsList *vm_config_groups[48];
+/*
+ * 在以下使用drive_config_groups[5]:
+ *   - util/qemu-config.c|133| <<get_drive_infolist>> for (i = 0; drive_config_groups[i] != NULL; i++) {
+ *   - util/qemu-config.c|135| <<get_drive_infolist>> head = query_option_descs(drive_config_groups[i]->desc);
+ *   - util/qemu-config.c|137| <<get_drive_infolist>> cur = query_option_descs(drive_config_groups[i]->desc);
+ *   - util/qemu-config.c|265| <<qemu_add_drive_opts>> entries = ARRAY_SIZE(drive_config_groups);
+ *   - util/qemu-config.c|268| <<qemu_add_drive_opts>> if (drive_config_groups[i] == NULL) {
+ *   - util/qemu-config.c|269| <<qemu_add_drive_opts>> drive_config_groups[i] = list;
+ */
 static QemuOptsList *drive_config_groups[5];
 
+/*
+ * called by:
+ *   - util/qemu-config.c|36| <<qemu_find_opts>> ret = find_list(vm_config_groups, group, &local_err);
+ *   - util/qemu-config.c|258| <<qemu_find_opts_err>> return find_list(vm_config_groups, group, errp);
+ *   - util/qemu-config.c|373| <<qemu_config_do_parse>> list = find_list(lists, group, errp);
+ *
+ * 在二维的QemuOptsList **lists寻找和group内容相等的QemuOptsList
+ */
 static QemuOptsList *find_list(QemuOptsList **lists, const char *group,
                                Error **errp)
 {
-    int i;
+    nt i;
 
     qemu_load_module_for_opts(group);
     for (i = 0; lists[i] != NULL; i++) {
@@ -28,6 +59,11 @@ static QemuOptsList *find_list(QemuOptsList **lists, const char *group,
     return lists[i];
 }
 
+/*
+ * 很多的调用, 各种module
+ *
+ * 在vm_config_groups寻找对应group(char *)的QemuOptsList
+ */
 QemuOptsList *qemu_find_opts(const char *group)
 {
     QemuOptsList *ret;
@@ -46,6 +82,11 @@ QemuOpts *qemu_find_opts_singleton(const char *group)
     QemuOptsList *list;
     QemuOpts *opts;
 
+    /*
+     * 很多的调用, 各种module
+     *
+     * 在vm_config_groups寻找对应group(char *)的QemuOptsList
+     */
     list = qemu_find_opts(group);
     assert(list);
     opts = qemu_opts_find(list, NULL);
diff --git a/util/qemu-timer.c b/util/qemu-timer.c
index 6a0de33dd..7f9497b57 100644
--- a/util/qemu-timer.c
+++ b/util/qemu-timer.c
@@ -662,6 +662,10 @@ uint64_t timer_expire_time_ns(QEMUTimer *ts)
     return timer_pending(ts) ? ts->expire_time : -1;
 }
 
+/*
+ * called by:
+ *   - util/main-loop.c|603| <<main_loop_wait>> qemu_clock_run_all_timers();
+ */
 bool qemu_clock_run_all_timers(void)
 {
     bool progress = false;
diff --git a/util/thread-context.c b/util/thread-context.c
index 2bc7883b9..84d3b49dd 100644
--- a/util/thread-context.c
+++ b/util/thread-context.c
@@ -39,6 +39,42 @@ typedef struct ThreadContextCmdNew {
     int mode;
 } ThreadContextCmdNew;
 
+/*
+ * -object thread-context,id=tc01,node-affinity=0 \
+ * -object memory-backend-file,id=ram01,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=0,policy=bind,prealloc-context=tc01 \
+ * -numa node,nodeid=0,cpus=0-1,memdev=ram01 \
+ * -object thread-context,id=tc02,node-affinity=1 \
+ * -object memory-backend-file,id=ram02,mem-path=/dev/hugepages/libvirt/qemu,prealloc=true,size=68719476736,host-nodes=1,policy=bind,prealloc-context=tc02 \
+ * -numa node,nodeid=1,cpus=2-3,memdev=ram02 \
+ *
+ * Thread 8 "touch_pages" hit Breakpoint 1, do_madv_populate_write_pages (arg=0x5555570521d0) at ../util/oslib-posix.c:378
+ * 378      MemsetThread *memset_args = (MemsetThread *)arg;
+ * (gdb) info threads 
+ *   Id   Target Id                                           Frame 
+ *   1    Thread 0x7ffff7460c80 (LWP 20402) "qemu-system-x86" 0x00007ffff772a3aa in __futex_abstimed_wait_common () from /lib64/libc.so.6
+ *   2    Thread 0x7ffff745f640 (LWP 20406) "qemu-system-x86" 0x00007ffff76cce5d in syscall () from /lib64/libc.so.6
+ *   3    Thread 0x7ffff6b5d640 (LWP 20407) "TC tc-ram-node0" 0x00007ffff772a3aa in __futex_abstimed_wait_common () from /lib64/libc.so.6
+ *   4    Thread 0x7ffff635c640 (LWP 20408) "TC tc-ram-node1" 0x00007ffff772a3aa in __futex_abstimed_wait_common () from /lib64/libc.so.6
+ *   6    Thread 0x7fffe7fff640 (LWP 20412) "touch_pages"     0x00007ffff76cceeb in madvise () from /lib64/libc.so.6
+ *   7    Thread 0x7fffe77fe640 (LWP 20413) "touch_pages"     0x0000555555ffb4d0 in do_madv_populate_write_pages (arg=0x5555570520e0) at ../util/oslib-posix.c:378
+ * 8    Thread 0x7fffe6ffd640 (LWP 20414) "touch_pages"     do_madv_populate_write_pages (arg=0x5555570521d0) at ../util/oslib-posix.c:378
+ *   9    Thread 0x7fffe67fc640 (LWP 20415) "touch_pages"     0x00007ffff77d5dd7 in mmap64 () from /lib64/libc.so.6
+ * (gdb) bt
+ * #0  do_madv_populate_write_pages (arg=0x5555570521d0) at ../util/oslib-posix.c:378
+ * #1  0x0000555555ffd7bb in qemu_thread_start (args=0x7fffe8000ea0) at ../util/qemu-thread-posix.c:541
+ * #2  0x00007ffff772d812 in start_thread () at /lib64/libc.so.6
+ * #3  0x00007ffff76cd450 in clone3 () at /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  thread_context_run (opaque=0x555557051600) at ../util/thread-context.c:44
+ * #1  0x0000555555ffd7bb in qemu_thread_start (args=0x55555705a6c0) at ../util/qemu-thread-posix.c:541
+ * #2  0x00007ffff772d812 in start_thread () at /lib64/libc.so.6
+ * #3  0x00007ffff76cd450 in clone3 () at /lib64/libc.so.6
+ *
+ * 在以下使用thread_context_run():
+ *   - util/thread-context.c|256| <<thread_context_instance_complete>> qemu_thread_create(&tc->thread, thread_name, thread_context_run, tc, QEMU_THREAD_JOINABLE);
+ */
 static void *thread_context_run(void *opaque)
 {
     ThreadContext *tc = opaque;
@@ -78,6 +114,14 @@ static void *thread_context_run(void *opaque)
         default:
             g_assert_not_reached();
         }
+	/*
+	 * 在以下使用ThreadContext->sem_thread:
+	 *   - util/thread-context.c|117| <<thread_context_run>> qemu_sem_wait(&tc->sem_thread);
+	 *   - util/thread-context.c|345| <<thread_context_instance_init>> qemu_sem_init(&tc->sem_thread, 0);
+	 *   - util/thread-context.c|355| <<thread_context_instance_finalize>> qemu_sem_post(&tc->sem_thread);
+	 *   - util/thread-context.c|359| <<thread_context_instance_finalize>> qemu_sem_destroy(&tc->sem_thread);
+	 *   - util/thread-context.c|402| <<thread_context_create_thread>> qemu_sem_post(&tc->sem_thread);
+	 */
         qemu_sem_wait(&tc->sem_thread);
     }
 }
@@ -245,6 +289,18 @@ static void thread_context_get_thread_id(Object *obj, Visitor *v,
     visit_type_uint64(v, name, &value, errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  thread_context_instance_complete (uc=0x555557051600, errp=0x7fffffffd9d8) at ../util/thread-context.c:250
+ * #1  0x0000555555e121a2 in user_creatable_complete (uc=0x555557051600, errp=0x7fffffffda38) at ../qom/object_interfaces.c:28
+ * #2  0x0000555555e1262e in user_creatable_add_type (type=0x5555562af1a1 "thread-context", id=0x555557053760 "tc-ram-node0", qdict=0x555557055730, v=0x555557056920, errp=0x7fffffffda50)
+ *                                                   at ../qom/object_interfaces.c:125
+ * #3  0x0000555555e127d4 in user_creatable_add_qapi (options=0x555557053550, errp=0x555556fc8340 <error_fatal>) at ../qom/object_interfaces.c:157
+ * #4  0x0000555555b7231c in object_option_foreach_add (type_opt_predicate=0x555555b725bb <object_create_pre_sandbox>) at ../system/vl.c:1792
+ * #5  0x0000555555b73fff in qemu_process_early_options () at ../system/vl.c:2488
+ * #6  0x0000555555b76de2 in qemu_init (argc=33, argv=0x7fffffffde18) at ../system/vl.c:3650
+ * #7  0x0000555555e01cbf in main (argc=33, argv=0x7fffffffde18) at ../system/main.c:47
+ */
 static void thread_context_instance_complete(UserCreatable *uc, Error **errp)
 {
     ThreadContext *tc = THREAD_CONTEXT(uc);
@@ -331,6 +387,10 @@ static void thread_context_register_types(void)
 }
 type_init(thread_context_register_types)
 
+/*
+ * called by:
+ *   - util/oslib-posix.c|461| <<touch_all_pages>> thread_context_create_thread(tc, &context.threads[i].pgthread, "touch_pages", touch_fn, &context.threads[i], QEMU_THREAD_JOINABLE);
+ */
 void thread_context_create_thread(ThreadContext *tc, QemuThread *thread,
                                   const char *name,
                                   void *(*start_routine)(void *), void *arg,
@@ -347,6 +407,14 @@ void thread_context_create_thread(ThreadContext *tc, QemuThread *thread,
     qemu_mutex_lock(&tc->mutex);
     tc->thread_cmd = TC_CMD_NEW;
     tc->thread_cmd_data = &data;
+    /*
+     * 在以下使用ThreadContext->sem_thread:
+     *   - util/thread-context.c|117| <<thread_context_run>> qemu_sem_wait(&tc->sem_thread);
+     *   - util/thread-context.c|345| <<thread_context_instance_init>> qemu_sem_init(&tc->sem_thread, 0);
+     *   - util/thread-context.c|355| <<thread_context_instance_finalize>> qemu_sem_post(&tc->sem_thread);
+     *   - util/thread-context.c|359| <<thread_context_instance_finalize>> qemu_sem_destroy(&tc->sem_thread);
+     *   - util/thread-context.c|402| <<thread_context_create_thread>> qemu_sem_post(&tc->sem_thread);
+     */
     qemu_sem_post(&tc->sem_thread);
 
     while (tc->thread_cmd != TC_CMD_NONE) {
-- 
2.34.1

