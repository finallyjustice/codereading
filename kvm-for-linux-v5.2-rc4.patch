From 0868c83e7332bb0fa22e801405ca265bfb6c07e9 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Thu, 20 Jun 2019 22:22:09 +0800
Subject: [PATCH 1/1] kvm for linux v5.2-rc4

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/kernel/crash.c   | 12 ++++++++++++
 arch/x86/kvm/cpuid.c      |  5 +++++
 arch/x86/kvm/cpuid.h      |  9 +++++++++
 arch/x86/kvm/lapic.c      | 27 +++++++++++++++++++++++++++
 arch/x86/kvm/mmu.c        |  4 ++++
 arch/x86/kvm/vmx/vmcs12.h |  1 +
 arch/x86/kvm/vmx/vmx.c    |  3 +++
 arch/x86/kvm/x86.c        |  4 ++++
 virt/kvm/irqchip.c        | 26 ++++++++++++++++++++++++++
 virt/kvm/kvm_main.c       |  8 ++++++++
 10 files changed, 99 insertions(+)

diff --git a/arch/x86/kernel/crash.c b/arch/x86/kernel/crash.c
index 576b2e1..bbd3702 100644
--- a/arch/x86/kernel/crash.c
+++ b/arch/x86/kernel/crash.c
@@ -54,15 +54,27 @@ struct crash_memmap_data {
  *
  * protected by rcu.
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/crash.c|66| <<cpu_crash_vmclear_loaded_vmcss>> do_vmclear_operation = rcu_dereference(crash_vmclear_loaded_vmcss);
+ *   - arch/x86/kvm/vmx/vmx.c|7748| <<vmx_exit>> RCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);
+ *   - arch/x86/kvm/vmx/vmx.c|7834| <<vmx_init>> rcu_assign_pointer(crash_vmclear_loaded_vmcss,
+ */
 crash_vmclear_fn __rcu *crash_vmclear_loaded_vmcss = NULL;
 EXPORT_SYMBOL_GPL(crash_vmclear_loaded_vmcss);
 unsigned long crash_zero_bytes;
 
+/*
+ * called by:
+ *   - arch/x86/kernel/crash.c|89| <<kdump_nmi_callback>> cpu_crash_vmclear_loaded_vmcss();
+ *   - arch/x86/kernel/crash.c|156| <<native_machine_crash_shutdown>> cpu_crash_vmclear_loaded_vmcss();
+ */
 static inline void cpu_crash_vmclear_loaded_vmcss(void)
 {
 	crash_vmclear_fn *do_vmclear_operation = NULL;
 
 	rcu_read_lock();
+	/* 在vmx_init()中设置为 crash_vmclear_local_loaded_vmcss() */
 	do_vmclear_operation = rcu_dereference(crash_vmclear_loaded_vmcss);
 	if (do_vmclear_operation)
 		do_vmclear_operation();
diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c
index e18a9f9..e2af392 100644
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@ -956,6 +956,11 @@ bool kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx,
 }
 EXPORT_SYMBOL_GPL(kvm_cpuid);
 
+/*
+ * called by:
+ *   - arch/x86/kvm/svm.c|3904| <<cpuid_interception>> return kvm_emulate_cpuid(&svm->vcpu);
+ *   - arch/x86/kvm/vmx/vmx.c|4832| <<handle_cpuid>> return kvm_emulate_cpuid(vcpu);
+ */
 int kvm_emulate_cpuid(struct kvm_vcpu *vcpu)
 {
 	u32 eax, ebx, ecx, edx;
diff --git a/arch/x86/kvm/cpuid.h b/arch/x86/kvm/cpuid.h
index 9a327d5..a4a71cd 100644
--- a/arch/x86/kvm/cpuid.h
+++ b/arch/x86/kvm/cpuid.h
@@ -156,11 +156,20 @@ static inline int guest_cpuid_stepping(struct kvm_vcpu *vcpu)
 	return x86_stepping(best->eax);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|2695| <<kvm_set_msr_common>> !supports_cpuid_fault(vcpu)))
+ */
 static inline bool supports_cpuid_fault(struct kvm_vcpu *vcpu)
 {
 	return vcpu->arch.msr_platform_info & MSR_PLATFORM_INFO_CPUID_FAULT;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/cpuid.c|963| <<kvm_emulate_cpuid>> if (cpuid_fault_enabled(vcpu) && !kvm_require_cpl(vcpu, 0))
+ *   - arch/x86/kvm/x86.c|2688| <<kvm_set_msr_common>> cpuid_fault_enabled(vcpu)))
+ */
 static inline bool cpuid_fault_enabled(struct kvm_vcpu *vcpu)
 {
 	return vcpu->arch.msr_misc_features_enables &
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 4924f83..06d27d5 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -102,7 +102,26 @@ static inline int __apic_test_and_clear_vector(int vec, void *bitmap)
 	return __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
 }
 
+/*
+ * used by:
+ *   - arch/x86/kvm/lapic.c|2055| <<kvm_free_lapic>> static_key_slow_dec_deferred(&apic_hw_disabled);
+ *   - arch/x86/kvm/lapic.c|2132| <<kvm_lapic_set_base>> static_key_slow_dec_deferred(&apic_hw_disabled);
+ *   - arch/x86/kvm/lapic.c|2134| <<kvm_lapic_set_base>> static_key_slow_inc(&apic_hw_disabled.key);
+ *   - arch/x86/kvm/lapic.c|2762| <<kvm_lapic_init>> jump_label_rate_limit(&apic_hw_disabled, HZ);
+ *   - arch/x86/kvm/lapic.c|2768| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_hw_disabled);
+ *   - arch/x86/kvm/lapic.h|170| <<kvm_apic_hw_enabled>> if (static_key_false(&apic_hw_disabled.key))
+ */
 struct static_key_deferred apic_hw_disabled __read_mostly;
+/*
+ * used by:
+ *   - arch/x86/kvm/lapic.c|256| <<apic_set_spiv>> static_key_slow_dec_deferred(&apic_sw_disabled);
+ *   - arch/x86/kvm/lapic.c|258| <<apic_set_spiv>> static_key_slow_inc(&apic_sw_disabled.key);
+ *   - arch/x86/kvm/lapic.c|2058| <<kvm_free_lapic>> static_key_slow_dec_deferred(&apic_sw_disabled);
+ *   - arch/x86/kvm/lapic.c|2329| <<kvm_create_lapic>> static_key_slow_inc(&apic_sw_disabled.key);
+ *   - arch/x86/kvm/lapic.c|2763| <<kvm_lapic_init>> jump_label_rate_limit(&apic_sw_disabled, HZ);
+ *   - arch/x86/kvm/lapic.c|2769| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_sw_disabled);
+ *   - arch/x86/kvm/lapic.h|179| <<kvm_apic_sw_enabled>> if (static_key_false(&apic_sw_disabled.key))
+ */
 struct static_key_deferred apic_sw_disabled __read_mostly;
 
 static inline int apic_enabled(struct kvm_lapic *apic)
@@ -2756,6 +2775,10 @@ void kvm_apic_accept_events(struct kvm_vcpu *vcpu)
 	}
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|7052| <<kvm_arch_init>> kvm_lapic_init();
+ */
 void kvm_lapic_init(void)
 {
 	/* do not patch jump label more than once per second */
@@ -2763,6 +2786,10 @@ void kvm_lapic_init(void)
 	jump_label_rate_limit(&apic_sw_disabled, HZ);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/x86.c|7076| <<kvm_arch_exit>> kvm_lapic_exit();
+ */
 void kvm_lapic_exit(void)
 {
 	static_key_deferred_flush(&apic_hw_disabled);
diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c
index 1e9ba81..f6aa628 100644
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@ -5998,6 +5998,10 @@ static void mmu_destroy_caches(void)
 	kmem_cache_destroy(mmu_page_header_cache);
 }
 
+/*
+ * called by only:
+ *   - arch/x86/kvm/x86.c|7034| <<kvm_arch_init>> r = kvm_mmu_module_init();
+ */
 int kvm_mmu_module_init(void)
 {
 	int ret = -ENOMEM;
diff --git a/arch/x86/kvm/vmx/vmcs12.h b/arch/x86/kvm/vmx/vmcs12.h
index 3a74242..350cb9e8 100644
--- a/arch/x86/kvm/vmx/vmcs12.h
+++ b/arch/x86/kvm/vmx/vmcs12.h
@@ -218,6 +218,7 @@ struct __packed vmcs12 {
 	BUILD_BUG_ON_MSG(offsetof(struct vmcs12, field) != (loc),	\
 		"Offset of " #field " in struct vmcs12 has changed.")
 
+/* 只被vmx_init()调用 */
 static inline void vmx_check_vmcs12_offsets(void)
 {
 	CHECK_OFFSET(hdr, 0);
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index b93e36d..7c0ea91 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -4827,6 +4827,9 @@ static void vmx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)
 	vmcs_writel(GUEST_DR7, val);
 }
 
+/*
+ * kvm_vmx_exit_handlers[EXIT_REASON_CPUID] = handle_cpuid()
+ */
 static int handle_cpuid(struct kvm_vcpu *vcpu)
 {
 	return kvm_emulate_cpuid(vcpu);
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 83aefd7..8d2f9fc 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -6983,6 +6983,10 @@ static struct notifier_block pvclock_gtod_notifier = {
 };
 #endif
 
+/*
+ * called by only:
+ *   - virt/kvm/kvm_main.c|4233| <<kvm_init>> r = kvm_arch_init(opaque);
+ */
 int kvm_arch_init(void *opaque)
 {
 	int r;
diff --git a/virt/kvm/irqchip.c b/virt/kvm/irqchip.c
index 2e6fc7c..b705eb7 100644
--- a/virt/kvm/irqchip.c
+++ b/virt/kvm/irqchip.c
@@ -19,6 +19,11 @@
 #include <trace/events/kvm.h>
 #include "irq.h"
 
+/*
+ * called by:
+ *   - virt/kvm/eventfd.c|261| <<irqfd_update>> n_entries = kvm_irq_map_gsi(kvm, entries, irqfd->gsi);
+ *   - virt/kvm/irqchip.c|84| <<kvm_set_irq>> i = kvm_irq_map_gsi(kvm, irq_set, irq);
+ */
 int kvm_irq_map_gsi(struct kvm *kvm,
 		    struct kvm_kernel_irq_routing_entry *entries, int gsi)
 {
@@ -46,6 +51,10 @@ int kvm_irq_map_chip_pin(struct kvm *kvm, unsigned irqchip, unsigned pin)
 	return irq_rt->chip[irqchip][pin];
 }
 
+/*
+ * called by:
+ *   - virt/kvm/kvm_main.c|3282| <<kvm_vm_ioctl>> r = kvm_send_userspace_msi(kvm, &msi);
+ */
 int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi)
 {
 	struct kvm_kernel_irq_routing_entry route;
@@ -68,6 +77,17 @@ int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi)
  *  = 0   Interrupt was coalesced (previous irq is still pending)
  *  > 0   Number of CPUs interrupt was delivered to
  */
+/*
+ * x86下调用:
+ *   - arch/x86/kvm/i8254.c|250| <<pit_do_work>> kvm_set_irq(kvm, pit->irq_source_id, 0, 1, false);
+ *   - arch/x86/kvm/i8254.c|251| <<pit_do_work>> kvm_set_irq(kvm, pit->irq_source_id, 0, 0, false);
+ *   - arch/x86/kvm/x86.c|4553| <<kvm_vm_ioctl_irq_line>> irq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,
+ *   - virt/kvm/eventfd.c|61| <<irqfd_inject>> kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID, irqfd->gsi, 1,
+ *   - virt/kvm/eventfd.c|63| <<irqfd_inject>> kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID, irqfd->gsi, 0,
+ *   - virt/kvm/eventfd.c|66| <<irqfd_inject>> kvm_set_irq(kvm, KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
+ *   - virt/kvm/eventfd.c|87| <<irqfd_resampler_ack>> kvm_set_irq(kvm, KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
+ *   - virt/kvm/eventfd.c|112| <<irqfd_resampler_shutdown>> kvm_set_irq(kvm, KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
+ */
 int kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,
 		bool line_status)
 {
@@ -166,6 +186,12 @@ bool __weak kvm_arch_can_set_irq_routing(struct kvm *kvm)
 	return true;
 }
 
+/*
+ * x86下调用:
+ *   - arch/x86/kvm/irq_comm.c|379| <<kvm_setup_default_irq_routing>> return kvm_set_irq_routing(kvm, default_routing,
+ *   - arch/x86/kvm/irq_comm.c|387| <<kvm_setup_empty_irq_routing>> return kvm_set_irq_routing(kvm, empty_routing, 0, 0);
+ *   - virt/kvm/kvm_main.c|3338| <<kvm_vm_ioctl>> r = kvm_set_irq_routing(kvm, entries, routing.nr,
+ */
 int kvm_set_irq_routing(struct kvm *kvm,
 			const struct kvm_irq_routing_entry *ue,
 			unsigned nr,
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index ca54b09..db0c17c 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -3464,6 +3464,9 @@ static int kvm_dev_ioctl_create_vm(unsigned long type)
 	return r;
 }
 
+/*
+ * struct file_operations kvm_chardev_ops.unlocked_ioctl = kvm_dev_ioctl()
+ */
 static long kvm_dev_ioctl(struct file *filp,
 			  unsigned int ioctl, unsigned long arg)
 {
@@ -4224,6 +4227,11 @@ static void kvm_sched_out(struct preempt_notifier *pn,
 	kvm_arch_vcpu_put(vcpu);
 }
 
+/*
+ * x86下调用:
+ *   - arch/x86/kvm/svm.c|7290| <<svm_init>> return kvm_init(&svm_x86_ops, sizeof(struct vcpu_svm),
+ *   - arch/x86/kvm/vmx/vmx.c|7813| <<vmx_init>> r = kvm_init(&vmx_x86_ops, sizeof(struct vcpu_vmx),
+ */
 int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,
 		  struct module *module)
 {
-- 
2.7.4

