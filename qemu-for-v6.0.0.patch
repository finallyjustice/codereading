From 21ed2c60b3a456f61e42bc486de32c39f1d0228e Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Sun, 10 Jul 2022 20:55:37 -0700
Subject: [PATCH 1/1] qemu for v6.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-all.c                         | 172 ++++++
 block.c                                     |   7 +
 block/accounting.c                          |  90 +++
 block/block-backend.c                       | 123 ++++
 block/curl.c                                |  76 +++
 block/file-posix.c                          |  49 ++
 block/linux-aio.c                           |   6 +
 hw/acpi/cpu.c                               |   8 +
 hw/acpi/cpu_hotplug.c                       |   4 +
 hw/acpi/generic_event_device.c              |   5 +
 hw/core/cpu.c                               |   4 +
 hw/core/machine.c                           |  19 +
 hw/core/nmi.c                               |  11 +
 hw/core/qdev.c                              |   6 +
 hw/i386/intel_iommu.c                       |  49 ++
 hw/i386/kvm/clock.c                         |  48 ++
 hw/i386/x86-iommu.c                         |  26 +
 hw/misc/pvpanic.c                           |   9 +
 hw/pci/msi.c                                |   3 +
 hw/pci/msix.c                               |  31 +
 hw/pci/pci.c                                |  23 +
 hw/remote/iohub.c                           |   8 +
 hw/remote/machine.c                         |  13 +
 hw/remote/memory.c                          |   9 +
 hw/remote/message.c                         |  14 +
 hw/remote/mpqemu-link.c                     |  32 +
 hw/remote/proxy-memory-listener.c           |  27 +
 hw/remote/proxy.c                           |  47 ++
 hw/remote/remote-obj.c                      |  52 ++
 hw/scsi/emulation.c                         |   5 +
 hw/scsi/scsi-bus.c                          | 394 +++++++++++++
 hw/scsi/scsi-disk.c                         | 617 ++++++++++++++++++++
 hw/scsi/scsi-generic.c                      |  56 ++
 hw/scsi/virtio-scsi-dataplane.c             |   9 +
 hw/scsi/virtio-scsi.c                       | 389 ++++++++++++
 hw/vfio/pci.c                               |  14 +
 hw/virtio/vhost.c                           |  41 ++
 hw/virtio/virtio-pci.c                      |  71 +++
 hw/virtio/virtio-pci.h                      |   9 +
 hw/virtio/virtio.c                          | 130 +++++
 include/block/accounting.h                  |   5 +
 include/hw/core/cpu.h                       |  29 +
 include/hw/misc/pvpanic.h                   |   7 +
 include/hw/pci/pci.h                        |  21 +
 include/hw/remote/mpqemu-link.h             |   6 +
 include/hw/scsi/scsi.h                      |  27 +
 include/hw/virtio/virtio-scsi.h             |  22 +
 include/qemu/timer.h                        |  21 +
 include/scsi/utils.h                        |   6 +
 include/standard-headers/linux/virtio_pci.h |   5 +
 include/sysemu/accel-ops.h                  |  16 +
 include/sysemu/dma.h                        |  16 +
 include/sysemu/kvm.h                        |  16 +
 net/tap-linux.c                             |   4 +
 scsi/utils.c                                |   5 +
 softmmu/cpus.c                              |   9 +
 softmmu/dma-helpers.c                       |  19 +
 softmmu/qdev-monitor.c                      |  22 +
 softmmu/runstate.c                          |  23 +
 target/i386/cpu.c                           |  20 +
 target/i386/kvm/kvm.c                       |  29 +
 target/i386/monitor.c                       |  20 +
 target/i386/xsave_helper.c                  |   5 +
 util/coroutine-ucontext.c                   |  10 +
 util/qemu-sockets.c                         |   5 +
 65 files changed, 3074 insertions(+)

diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index b6d9f92f1..a9f18565b 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -115,7 +115,22 @@ struct KVMState
 #ifdef KVM_CAP_IRQ_ROUTING
     struct kvm_irq_routing *irq_routes;
     int nr_allocated_irq_routes;
+    /*
+     * 在以下使用KVMState->used_gsi_bitmap:
+     *   - accel/kvm/kvm-all.c|1392| <<set_gsi>> set_bit(gsi, s->used_gsi_bitmap);
+     *   - accel/kvm/kvm-all.c|1397| <<clear_gsi>> clear_bit(gsi, s->used_gsi_bitmap);
+     *   - accel/kvm/kvm-all.c|1407| <<kvm_init_irq_routing>> s->used_gsi_bitmap = bitmap_new(gsi_count);
+     *   - accel/kvm/kvm-all.c|1585| <<kvm_irqchip_get_virq>> next_virq = find_first_zero_bit(s->used_gsi_bitmap, s->gsi_count);
+     */
     unsigned long *used_gsi_bitmap;
+    /*
+     * 在以下使用KVMState->gsi_count:
+     *   - accel/kvm/kvm-all.c|1408| <<kvm_init_irq_routing>> s->gsi_count = gsi_count;
+     *   - accel/kvm/kvm-all.c|1503| <<kvm_irqchip_add_irq_route>> assert(pin < s->gsi_count);
+     *   - accel/kvm/kvm-all.c|1580| <<kvm_irqchip_get_virq>> if (!kvm_direct_msi_allowed && s->irq_routes->nr == s->gsi_count) {
+     *   - accel/kvm/kvm-all.c|1585| <<kvm_irqchip_get_virq>> next_virq = find_first_zero_bit(s->used_gsi_bitmap, s->gsi_count);
+     *   - accel/kvm/kvm-all.c|1586| <<kvm_irqchip_get_virq>> if (next_virq >= s->gsi_count) {
+     */
     unsigned int gsi_count;
     QTAILQ_HEAD(, KVMMSIRoute) msi_hashtab[KVM_MSI_HASHTAB_SIZE];
 #endif
@@ -139,6 +154,14 @@ bool kvm_eventfds_allowed;
 bool kvm_irqfds_allowed;
 bool kvm_resamplefds_allowed;
 bool kvm_msi_via_irqfd_allowed;
+/*
+ * 在以下使用kvm_gsi_routing_allowed:
+ *   - hw/intc/arm_gic_kvm.c|589| <<kvm_arm_gic_realize>> kvm_gsi_routing_allowed = true;
+ *   - hw/intc/arm_gicv3_kvm.c|859| <<kvm_arm_gicv3_realize>> kvm_gsi_routing_allowed = true;
+ *   - hw/intc/openpic_kvm.c|253| <<kvm_openpic_realize>> kvm_gsi_routing_allowed = true;
+ *   - target/i386/kvm/kvm.c|4623| <<kvm_arch_init_irq_routing>> kvm_gsi_routing_allowed = true;
+ *   - target/s390x/kvm.c|2010| <<kvm_arch_init_irq_routing>> kvm_gsi_routing_allowed = true;
+ */
 bool kvm_gsi_routing_allowed;
 bool kvm_gsi_direct_mapping;
 bool kvm_allowed;
@@ -1420,6 +1443,15 @@ void kvm_init_irq_routing(KVMState *s)
     kvm_arch_init_irq_routing(s);
 }
 
+/*
+ * 使用KVM_SET_GSI_ROUTING将KVMState->irq_routes给commit到kernel
+ * KVMState *s:
+ * -> struct kvm_irq_routing *irq_routes;
+ *    -> __u32 nr;
+ *    -> __u32 flags;
+ *    -> struct kvm_irq_routing_entry entries[0];
+ * -> int nr_allocated_irq_routes;
+ */
 void kvm_irqchip_commit_routes(KVMState *s)
 {
     int ret;
@@ -1434,10 +1466,27 @@ void kvm_irqchip_commit_routes(KVMState *s)
 
     s->irq_routes->flags = 0;
     trace_kvm_irqchip_commit_routes();
+    /*
+     * KVMState *s:
+     * -> struct kvm_irq_routing *irq_routes;
+     *    -> __u32 nr;
+     *    -> __u32 flags;
+     *    -> struct kvm_irq_routing_entry entries[0];
+     * -> int nr_allocated_irq_routes;
+     */
     ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);
     assert(ret == 0);
 }
 
+/*
+ * 把参数kvm_irq_routing_entry加入s->irq_routes->entries[n]
+ * KVMState *s:
+ * -> struct kvm_irq_routing *irq_routes;
+ *    -> __u32 nr;
+ *    -> __u32 flags;
+ *    -> struct kvm_irq_routing_entry entries[0];
+ * -> int nr_allocated_irq_routes;
+ */
 static void kvm_add_routing_entry(KVMState *s,
                                   struct kvm_irq_routing_entry *entry)
 {
@@ -1455,6 +1504,14 @@ static void kvm_add_routing_entry(KVMState *s,
         s->nr_allocated_irq_routes = n;
     }
     n = s->irq_routes->nr++;
+    /*
+     * KVMState *s:
+     * -> struct kvm_irq_routing *irq_routes;
+     *    -> __u32 nr;
+     *    -> __u32 flags;
+     *    -> struct kvm_irq_routing_entry entries[0];
+     * -> int nr_allocated_irq_routes;
+     */
     new = &s->irq_routes->entries[n];
 
     *new = *entry;
@@ -1486,6 +1543,16 @@ static int kvm_update_routing_entry(KVMState *s,
     return -ESRCH;
 }
 
+/*
+ * called by:
+ *   - hw/i386/kvm/ioapic.c|33| <<kvm_pc_setup_irq_routing>> kvm_irqchip_add_irq_route(s, i, KVM_IRQCHIP_PIC_MASTER, i);
+ *   - hw/i386/kvm/ioapic.c|36| <<kvm_pc_setup_irq_routing>> kvm_irqchip_add_irq_route(s, i, KVM_IRQCHIP_PIC_SLAVE, i - 8);
+ *   - hw/i386/kvm/ioapic.c|41| <<kvm_pc_setup_irq_routing>> kvm_irqchip_add_irq_route(s, i, KVM_IRQCHIP_IOAPIC, 2);
+ *   - hw/i386/kvm/ioapic.c|43| <<kvm_pc_setup_irq_routing>> kvm_irqchip_add_irq_route(s, i, KVM_IRQCHIP_IOAPIC, i);
+ *   - hw/intc/arm_gic_kvm.c|586| <<kvm_arm_gic_realize>> kvm_irqchip_add_irq_route(kvm_state, i, 0, i);
+ *   - hw/intc/arm_gicv3_kvm.c|856| <<kvm_arm_gicv3_realize>> kvm_irqchip_add_irq_route(kvm_state, i, 0, i);
+ *   - hw/intc/openpic_kvm.c|249| <<kvm_openpic_realize>> kvm_irqchip_add_irq_route(kvm_state, i, 0, i);
+ */
 void kvm_irqchip_add_irq_route(KVMState *s, int irq, int irqchip, int pin)
 {
     struct kvm_irq_routing_entry e = {};
@@ -1557,6 +1624,13 @@ static void kvm_flush_dynamic_msi_routes(KVMState *s)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1627| <<kvm_irqchip_send_msi>> virq = kvm_irqchip_get_virq(s);
+ *   - accel/kvm/kvm-all.c|1677| <<kvm_irqchip_add_msi_route>> virq = kvm_irqchip_get_virq(s);
+ *   - accel/kvm/kvm-all.c|1798| <<kvm_irqchip_add_adapter_route>> virq = kvm_irqchip_get_virq(s);
+ *   - accel/kvm/kvm-all.c|1828| <<kvm_irqchip_add_hv_sint_route>> virq = kvm_irqchip_get_virq(s);
+ */
 static int kvm_irqchip_get_virq(KVMState *s)
 {
     int next_virq;
@@ -1639,6 +1713,13 @@ int kvm_irqchip_send_msi(KVMState *s, MSIMessage msg)
     return kvm_set_irq(s, route->kroute.gsi, 1);
 }
 
+/*
+ * called by:
+ *   - hw/misc/ivshmem.c|432| <<ivshmem_add_kvm_msi_virq>> ret = kvm_irqchip_add_msi_route(kvm_state, vector, pdev);
+ *   - hw/vfio/pci.c|426| <<vfio_add_kvm_msi_virq>> virq = kvm_irqchip_add_msi_route(kvm_state, vector_n, &vdev->pdev);
+ *   - hw/virtio/virtio-pci.c|676| <<kvm_virtio_pci_vq_vector_use>> ret = kvm_irqchip_add_msi_route(kvm_state, vector, &proxy->pci_dev);
+ *   - target/i386/kvm/kvm.c|4631| <<kvm_arch_init_irq_routing>> if (kvm_irqchip_add_msi_route(s, 0, NULL) < 0) {
+ */
 int kvm_irqchip_add_msi_route(KVMState *s, int vector, PCIDevice *dev)
 {
     struct kvm_irq_routing_entry kroute = {};
@@ -1650,6 +1731,9 @@ int kvm_irqchip_add_msi_route(KVMState *s, int vector, PCIDevice *dev)
     }
 
     if (kvm_gsi_direct_mapping()) {
+        /*
+	 * x86下直接abort()
+	 */
         return kvm_arch_msi_data_to_gsi(msg.data);
     }
 
@@ -1663,6 +1747,12 @@ int kvm_irqchip_add_msi_route(KVMState *s, int vector, PCIDevice *dev)
     }
 
     kroute.gsi = virq;
+    /*
+     * #define KVM_IRQ_ROUTING_IRQCHIP 1
+     * #define KVM_IRQ_ROUTING_MSI 2
+     * #define KVM_IRQ_ROUTING_S390_ADAPTER 3
+     * #define KVM_IRQ_ROUTING_HV_SINT 4
+     */
     kroute.type = KVM_IRQ_ROUTING_MSI;
     kroute.flags = 0;
     kroute.u.msi.address_lo = (uint32_t)msg.address;
@@ -1680,8 +1770,26 @@ int kvm_irqchip_add_msi_route(KVMState *s, int vector, PCIDevice *dev)
     trace_kvm_irqchip_add_msi_route(dev ? dev->name : (char *)"N/A",
                                     vector, virq);
 
+    /*
+     * 把参数kvm_irq_routing_entry加入s->irq_routes->entries[n]
+     * KVMState *s:
+     * -> struct kvm_irq_routing *irq_routes;
+     *    -> __u32 nr;
+     *    -> __u32 flags;
+     *    -> struct kvm_irq_routing_entry entries[0];
+     * -> int nr_allocated_irq_routes;
+     */
     kvm_add_routing_entry(s, &kroute);
     kvm_arch_add_msi_route_post(&kroute, vector, dev);
+    /*
+     * 使用KVM_SET_GSI_ROUTING将KVMState->irq_routes给commit到kernel
+     * KVMState *s:
+     * -> struct kvm_irq_routing *irq_routes;
+     *    -> __u32 nr;
+     *    -> __u32 flags;
+     *    -> struct kvm_irq_routing_entry entries[0];
+     * -> int nr_allocated_irq_routes;
+     */
     kvm_irqchip_commit_routes(s);
 
     return virq;
@@ -1719,6 +1827,11 @@ int kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg,
     return kvm_update_routing_entry(s, &kroute);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1995| <<kvm_irqchip_add_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, rn, virq, true);
+ *   - accel/kvm/kvm-all.c|2001| <<kvm_irqchip_remove_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, NULL, virq, false);
+ */
 static int kvm_irqchip_assign_irqfd(KVMState *s, EventNotifier *event,
                                     EventNotifier *resample, int virq,
                                     bool assign)
@@ -1868,6 +1981,19 @@ int kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg)
 }
 #endif /* !KVM_CAP_IRQ_ROUTING */
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1892| <<kvm_irqchip_add_irqfd_notifier>> return kvm_irqchip_add_irqfd_notifier_gsi(s, n, rn, GPOINTER_TO_INT(gsi));
+ *   - accel/stubs/kvm-stub.c|125| <<kvm_irqchip_add_irqfd_notifier_gsi>> int kvm_irqchip_add_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,
+ *   - hw/hyperv/hyperv.c|409| <<hyperv_sint_route_new>> r = kvm_irqchip_add_irqfd_notifier_gsi(kvm_state,
+ *   - hw/misc/ivshmem.c|296| <<ivshmem_vector_unmask>> ret = kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL, v->virq);
+ *   - hw/misc/ivshmem.c|464| <<setup_interrupt>> kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL,
+ *   - hw/remote/proxy.c|52| <<proxy_intx_update>> kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &dev->intr,
+ *   - hw/s390x/virtio-ccw.c|1001| <<virtio_ccw_add_irqfd>> return kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, notifier, NULL,
+ *   - hw/vfio/pci.c|137| <<vfio_intx_enable_kvm>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state,
+ *   - hw/vfio/pci.c|432| <<vfio_add_kvm_msi_virq>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+ *   - hw/virtio/virtio-pci.c|703| <<kvm_virtio_pci_irqfd_use>> return kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL, irqfd->virq);
+ */
 int kvm_irqchip_add_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,
                                        EventNotifier *rn, int virq)
 {
@@ -2323,6 +2449,10 @@ bool kvm_cpu_check_are_resettable(void)
     return kvm_arch_cpu_check_are_resettable();
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2458| <<kvm_cpu_synchronize_state>> run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
 {
     if (!cpu->vcpu_dirty) {
@@ -2331,8 +2461,50 @@ static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
+/*
+ * 在以下使用kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-accel-ops.c|84| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - accel/kvm/kvm-all.c|2673| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+ *   - target/arm/kvm64.c|1428| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+ *   - target/arm/kvm64.c|1498| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4264| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4283| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4301| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4306| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4611| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+ *   - target/s390x/kvm.c|1958| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+ */
 void kvm_cpu_synchronize_state(CPUState *cpu)
 {
+    /*
+     * 在以下修改CPUSTate->vcpu_dirty:
+     *   - accel/kvm/kvm-all.c|462| <<kvm_init_vcpu>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|2455| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|2482| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|2493| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|2503| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|2586| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/i386/hax/hax-all.c|229| <<hax_init_vcpu>> cpu->vcpu_dirty = true;
+     *   - target/i386/hax/hax-all.c|628| <<do_hax_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - target/i386/hax/hax-all.c|644| <<do_hax_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - target/i386/hax/hax-all.c|657| <<do_hax_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - target/i386/hax/hax-all.c|644| <<do_hax_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - target/i386/hax/hax-all.c|657| <<do_hax_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - target/i386/hax/hax-all.c|667| <<do_hax_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - target/i386/hvf/hvf.c|284| <<do_hvf_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - target/i386/hvf/hvf.c|299| <<do_hvf_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - target/i386/hvf/hvf.c|311| <<do_hvf_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - target/i386/hvf/hvf.c|322| <<do_hvf_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - target/i386/hvf/hvf.c|536| <<hvf_init_vcpu>> cpu->vcpu_dirty = 1;
+     *   - target/i386/hvf/hvf.c|708| <<hvf_vcpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|675| <<whpx_emu_setreg_callback>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|987| <<whpx_vcpu_run>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|1265| <<do_whpx_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - target/i386/whpx/whpx-all.c|1273| <<do_whpx_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|1280| <<do_whpx_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|1286| <<do_whpx_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - target/i386/whpx/whpx-all.c|1439| <<whpx_init_vcpu>> cpu->vcpu_dirty = true;
+     */
     if (!cpu->vcpu_dirty) {
         run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);
     }
diff --git a/block.c b/block.c
index c5b887cec..642374fd4 100644
--- a/block.c
+++ b/block.c
@@ -3245,6 +3245,13 @@ out:
  * should be opened. If specified, neither options nor a filename may be given,
  * nor can an existing BDS be reused (that is, *pbs has to be NULL).
  */
+/*
+ * called by:
+ *   - block.c|3015| <<bdrv_open_backing_file>> backing_hd = bdrv_open_inherit(backing_filename, reference, options, 0, bs,
+ *   - block.c|3079| <<bdrv_open_child_bs>> bs = bdrv_open_inherit(filename, reference, image_options, 0,
+ *   - block.c|3158| <<bdrv_open_blockdev_ref>> bs = bdrv_open_inherit(NULL, reference, qdict, 0, NULL, NULL, 0, errp);
+ *   - block.c|3537| <<bdrv_open>> return bdrv_open_inherit(filename, reference, options, flags, NULL,
+ */
 static BlockDriverState *bdrv_open_inherit(const char *filename,
                                            const char *reference,
                                            QDict *options, int flags,
diff --git a/block/accounting.c b/block/accounting.c
index 2030851d7..ec74d94bc 100644
--- a/block/accounting.c
+++ b/block/accounting.c
@@ -84,6 +84,51 @@ BlockAcctTimedStats *block_acct_interval_next(BlockAcctStats *stats,
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/xen-block.c|377| <<xen_block_do_aio>> block_acct_start(blk_get_stats(dataplane->blk), &request->acct,
+ *   - hw/block/dataplane/xen-block.c|390| <<xen_block_do_aio>> block_acct_start(blk_get_stats(dataplane->blk), &request->acct,
+ *   - hw/block/nvme-dif.c|454| <<nvme_dif_rw>> block_acct_start(blk_get_stats(blk), &req->acct, ctx->data.iov.size,
+ *   - hw/block/nvme-dif.c|500| <<nvme_dif_rw>> block_acct_start(blk_get_stats(blk), &req->acct, ctx->data.iov.size,
+ *   - hw/block/nvme.c|2294| <<nvme_copy_in_complete>> block_acct_start(blk_get_stats(ns->blkconf.blk), &req->acct, 0,
+ *   - hw/block/nvme.c|2626| <<nvme_verify>> block_acct_start(blk_get_stats(blk), &req->acct, ctx->data.iov.size,
+ *   - hw/block/nvme.c|2723| <<nvme_copy>> block_acct_start(blk_get_stats(ns->blkconf.blk), &req->acct, 0,
+ *   - hw/block/nvme.c|2845| <<nvme_compare>> block_acct_start(blk_get_stats(blk), &req->acct, data_len,
+ *   - hw/block/nvme.c|2869| <<nvme_flush>> block_acct_start(blk_get_stats(req->ns->blkconf.blk), &req->acct, 0,
+ *   - hw/block/nvme.c|2890| <<nvme_flush>> block_acct_start(blk_get_stats(ns->blkconf.blk), &ctx->acct, 0,
+ *   - hw/block/nvme.c|2971| <<nvme_read>> block_acct_start(blk_get_stats(blk), &req->acct, data_size,
+ *   - hw/block/nvme.c|3097| <<nvme_do_write>> block_acct_start(blk_get_stats(blk), &req->acct, data_size,
+ *   - hw/block/virtio-blk.c|504| <<virtio_blk_handle_flush>> block_acct_start(blk_get_stats(s->blk), &req->acct, 0,
+ *   - hw/block/virtio-blk.c|587| <<virtio_blk_handle_discard_write_zeroes>> block_acct_start(blk_get_stats(s->blk), &req->acct, bytes,
+ *   - hw/block/virtio-blk.c|683| <<virtio_blk_handle_request>> block_acct_start(blk_get_stats(s->blk), &req->acct, req->qiov.size,
+ *   - hw/ide/atapi.c|93| <<cd_read_sector_sync>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/atapi.c|165| <<cd_read_sector>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/atapi.c|310| <<ide_atapi_cmd_reply>> block_acct_start(blk_get_stats(s->blk), &s->acct, size,
+ *   - hw/ide/atapi.c|432| <<ide_atapi_cmd_read_dma>> block_acct_start(blk_get_stats(s->blk), &s->acct, s->packet_transfer_size,
+ *   - hw/ide/core.c|475| <<ide_issue_trim_cb>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|796| <<ide_sector_read>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|968| <<ide_sector_start_dma>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|972| <<ide_sector_start_dma>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|1071| <<ide_sector_write>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|1107| <<ide_flush_cache>> block_acct_start(blk_get_stats(s->blk), &s->acct, 0, BLOCK_ACCT_FLUSH);
+ *   - hw/ide/macio.c|228| <<pmac_ide_transfer>> block_acct_start(blk_get_stats(s->blk), &s->acct, io->len,
+ *   - hw/ide/macio.c|237| <<pmac_ide_transfer>> block_acct_start(blk_get_stats(s->blk), &s->acct, io->len,
+ *   - hw/ide/macio.c|241| <<pmac_ide_transfer>> block_acct_start(blk_get_stats(s->blk), &s->acct, io->len,
+ *   - hw/scsi/scsi-disk.c|444| <<scsi_write_do_fua>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - hw/scsi/scsi-disk.c|652| <<scsi_do_read>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|757| <<scsi_read_data>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - hw/scsi/scsi-disk.c|858| <<scsi_write_data>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|1843| <<scsi_disk_emulate_mode_select>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - hw/scsi/scsi-disk.c|1907| <<scsi_unmap_complete_noio>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|2035| <<scsi_write_same_complete>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|2086| <<scsi_disk_emulate_write_same>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|2111| <<scsi_disk_emulate_write_same>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|2382| <<scsi_disk_emulate_command>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - qemu-io-cmds.c|1519| <<aio_read_f>> block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,
+ *   - qemu-io-cmds.c|1664| <<aio_write_f>> block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,
+ *   - qemu-io-cmds.c|1677| <<aio_flush_f>> block_acct_start(blk_get_stats(blk), &cookie, 0, BLOCK_ACCT_FLUSH);
+ *   - softmmu/dma-helpers.c|350| <<dma_acct_start>> block_acct_start(blk_get_stats(blk), cookie, sg->size, type);
+ */
 void block_acct_start(BlockAcctStats *stats, BlockAcctCookie *cookie,
                       int64_t bytes, enum BlockAcctType type)
 {
@@ -182,11 +227,21 @@ void block_latency_histograms_clear(BlockAcctStats *stats)
     }
 }
 
+/*
+ * called by:
+ *   - block/accounting.c|228| <<block_acct_done>> block_account_one_io(stats, cookie, false);
+ *   - block/accounting.c|233| <<block_acct_failed>> block_account_one_io(stats, cookie, true);
+ */
 static void block_account_one_io(BlockAcctStats *stats, BlockAcctCookie *cookie,
                                  bool failed)
 {
     BlockAcctTimedStats *s;
     int64_t time_ns = qemu_clock_get_ns(clock_type);
+    /*
+     * 在以下使用BlockAcctCookie->start_time_ns:
+     *   - block/accounting.c|93| <<block_acct_start>> cookie->start_time_ns = qemu_clock_get_ns(clock_type);
+     *   - block/accounting.c|190| <<block_account_one_io>> int64_t latency_ns = time_ns - cookie->start_time_ns;
+     */
     int64_t latency_ns = time_ns - cookie->start_time_ns;
 
     if (qtest_enabled()) {
@@ -223,6 +278,41 @@ static void block_account_one_io(BlockAcctStats *stats, BlockAcctCookie *cookie,
     cookie->type = BLOCK_ACCT_NONE;
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/xen-block.c|303| <<xen_block_complete_aio>> block_acct_done(blk_get_stats(dataplane->blk), &request->acct);
+ *   - hw/block/nvme.c|1792| <<nvme_misc_cb>> block_acct_done(stats, acct);
+ *   - hw/block/nvme.c|1812| <<nvme_rw_complete_cb>> block_acct_done(stats, acct);
+ *   - hw/block/nvme.c|1927| <<nvme_aio_flush_cb>> block_acct_done(stats, acct);
+ *   - hw/block/nvme.c|1968| <<nvme_verify_cb>> block_acct_done(stats, acct);
+ *   - hw/block/nvme.c|2146| <<nvme_copy_complete_cb>> block_acct_done(blk_get_stats(ns->blkconf.blk), &req->acct);
+ *   - hw/block/nvme.c|2203| <<nvme_copy_in_complete>> block_acct_done(blk_get_stats(ns->blkconf.blk), &req->acct);
+ *   - hw/block/nvme.c|2488| <<nvme_compare_data_cb>> block_acct_done(stats, acct);
+ *   - hw/block/virtio-blk.c|153| <<virtio_blk_rw_complete>> block_acct_done(blk_get_stats(s->blk), &req->acct);
+ *   - hw/block/virtio-blk.c|172| <<virtio_blk_flush_complete>> block_acct_done(blk_get_stats(s->blk), &req->acct);
+ *   - hw/block/virtio-blk.c|195| <<virtio_blk_discard_write_zeroes_complete>> block_acct_done(blk_get_stats(s->blk), &req->acct);
+ *   - hw/ide/ahci.c|1017| <<ncq_finish>> block_acct_done(blk_get_stats(ncq_tfs->drive->port.ifs[0].blk),
+ *   - hw/ide/atapi.c|118| <<cd_read_sector_sync>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/atapi.c|138| <<cd_read_sector_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/atapi.c|415| <<ide_atapi_cmd_read_dma_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|447| <<ide_issue_trim_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|751| <<ide_sector_read_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|955| <<ide_dma_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|1013| <<ide_sector_write_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|1091| <<ide_flush_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/macio.c|128| <<pmac_ide_atapi_transfer_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/macio.c|212| <<pmac_ide_transfer_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/scsi/scsi-disk.c|402| <<scsi_aio_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|529| <<scsi_dma_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|582| <<scsi_read_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|674| <<scsi_do_read_cb>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|802| <<scsi_write_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|1950| <<scsi_unmap_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|2028| <<scsi_write_same_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - qemu-io-cmds.c|1360| <<aio_write_done>> block_acct_done(blk_get_stats(ctx->blk), &ctx->acct);
+ *   - qemu-io-cmds.c|1402| <<aio_read_done>> block_acct_done(blk_get_stats(ctx->blk), &ctx->acct);
+ *   - qemu-io-cmds.c|1679| <<aio_flush_f>> block_acct_done(blk_get_stats(blk), &cookie);
+ */
 void block_acct_done(BlockAcctStats *stats, BlockAcctCookie *cookie)
 {
     block_account_one_io(stats, cookie, false);
diff --git a/block/block-backend.c b/block/block-backend.c
index 413af51f3..5d5a59be8 100644
--- a/block/block-backend.c
+++ b/block/block-backend.c
@@ -1182,6 +1182,12 @@ static void coroutine_fn blk_wait_while_drained(BlockBackend *blk)
 }
 
 /* To be called between exactly one pair of blk_inc/dec_in_flight() */
+/*
+ * called by:
+ *   - block/block-backend.c|1223| <<blk_co_preadv>> ret = blk_do_preadv(blk, offset, bytes, qiov, flags);
+ *   - block/block-backend.c|1300| <<blk_read_entry>> rwco->ret = blk_do_preadv(rwco->blk, rwco->offset, qiov->size,
+ *   - block/block-backend.c|1464| <<blk_aio_read_entry>> rwco->ret = blk_do_preadv(rwco->blk, rwco->offset, acb->bytes,
+ */
 static int coroutine_fn
 blk_do_preadv(BlockBackend *blk, int64_t offset, unsigned int bytes,
               QEMUIOVector *qiov, BdrvRequestFlags flags)
@@ -1391,6 +1397,13 @@ typedef struct BlkAioEmAIOCB {
     BlockAIOCB common;
     BlkRwCo rwco;
     int bytes;
+    /*
+     * 在以下使用BlkAioEmAIOCB->has_returned:
+     *   - block/block-backend.c|1417| <<blk_aio_complete>> if (acb->has_returned) {
+     *   - block/block-backend.c|1427| <<blk_aio_complete_bh>> assert(acb->has_returned);
+     *   - block/block-backend.c|1449| <<blk_aio_prwv>> acb->has_returned = false;
+     *   - block/block-backend.c|1454| <<blk_aio_prwv>> acb->has_returned = true;
+     */
     bool has_returned;
 } BlkAioEmAIOCB;
 
@@ -1406,9 +1419,23 @@ static const AIOCBInfo blk_aio_em_aiocb_info = {
     .get_aio_context    = blk_aio_em_aiocb_get_aio_context,
 };
 
+/*
+ * called by:
+ *   - block/block-backend.c|1435| <<blk_aio_complete_bh>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1505| <<blk_aio_read_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1517| <<blk_aio_write_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1705| <<blk_aio_ioctl_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1736| <<blk_aio_pdiscard_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1790| <<blk_aio_flush_entry>> blk_aio_complete(acb);
+ */
 static void blk_aio_complete(BlkAioEmAIOCB *acb)
 {
     if (acb->has_returned) {
+        /*
+	 * BlkAioEmAIOCB *acb:
+	 * -> BlkRwCo rwco;
+	 *    -> int ret;
+	 */
         acb->common.cb(acb->common.opaque, acb->rwco.ret);
         blk_dec_in_flight(acb->rwco.blk);
         qemu_aio_unref(acb);
@@ -1422,6 +1449,15 @@ static void blk_aio_complete_bh(void *opaque)
     blk_aio_complete(acb);
 }
 
+/*
+ * called by:
+ *   - block/block-backend.c|1491| <<blk_aio_pwrite_zeroes>> return blk_aio_prwv(blk, offset, count, NULL, blk_aio_write_entry,
+ *   - block/block-backend.c|1616| <<blk_aio_preadv>> return blk_aio_prwv(blk, offset, qiov->size, qiov,
+ *   - block/block-backend.c|1624| <<blk_aio_pwritev>> return blk_aio_prwv(blk, offset, qiov->size, qiov,
+ *   - block/block-backend.c|1678| <<blk_aio_ioctl>> return blk_aio_prwv(blk, req, 0, buf, blk_aio_ioctl_entry, 0, cb, opaque);
+ *   - block/block-backend.c|1710| <<blk_aio_pdiscard>> return blk_aio_prwv(blk, offset, bytes, NULL, blk_aio_pdiscard_entry, 0,
+ *   - block/block-backend.c|1763| <<blk_aio_flush>> return blk_aio_prwv(blk, 0, 0, NULL, blk_aio_flush_entry, 0, cb, opaque);
+ */
 static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset, int bytes,
                                 void *iobuf, CoroutineEntry co_entry,
                                 BdrvRequestFlags flags,
@@ -1454,6 +1490,23 @@ static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset, int bytes,
     return &acb->common;
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555ca1540 in virtio_scsi_complete_req (req=0x7fffe8005ec0) at ../hw/scsi/virtio-scsi.c:70
+ * #1  0x0000555555ca2600 in virtio_scsi_complete_cmd_req (req=0x7fffe8005ec0) at ../hw/scsi/virtio-scsi.c:500
+ * #2  0x0000555555ca28a1 in virtio_scsi_command_complete (r=0x7fffe80035d0, resid=0) at ../hw/scsi/virtio-scsi.c:571
+ * #3  0x0000555555898034 in scsi_req_complete (req=0x7fffe80035d0, status=0) at ../hw/scsi/scsi-bus.c:1515
+ * #4  0x000055555591a4a5 in scsi_dma_complete_noio (r=0x7fffe80035d0, ret=0) at ../hw/scsi/scsi-disk.c:345
+ * #5  0x000055555591a5b5 in scsi_dma_complete (opaque=0x7fffe80035d0, ret=0) at ../hw/scsi/scsi-disk.c:366
+ * #6  0x000055555592a674 in dma_complete (dbs=0x7fffe80029f0, ret=0) at ../softmmu/dma-helpers.c:121
+ * #7  0x000055555592a721 in dma_blk_cb (opaque=0x7fffe80029f0, ret=0) at ../softmmu/dma-helpers.c:139
+ * #8  0x0000555555d99856 in blk_aio_complete (acb=0x7fffe80011a0) at ../block/block-backend.c:1412
+ * #9  0x0000555555d99a7a in blk_aio_read_entry (opaque=0x7fffe80011a0) at ../block/block-backend.c:1466
+ * #10 0x0000555555ea6c42 in coroutine_trampoline (i0=-402644032, i1=32767) at ../util/coroutine-ucontext.c:173
+ * #11 0x00007ffff50a2190 in __start_context () at /lib64/libc.so.6
+ * #12 0x00007fffee6dbc60 in  ()
+ * #13 0x0000000000000000 in  ()
+ */
 static void blk_aio_read_entry(void *opaque)
 {
     BlkAioEmAIOCB *acb = opaque;
@@ -1533,6 +1586,76 @@ int64_t blk_nb_sectors(BlockBackend *blk)
     return bdrv_nb_sectors(blk_bs(blk));
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555d99d1a in blk_aio_preadv (blk=0x555556b7b000, offset=6471196672, qiov=0x555556e90b08, flags=0, cb=0x555555b97d4a <virtio_blk_rw_complete>, opaque=0x555556e90a70) at ../block/block-backend.c:1540
+ * #1  0x0000555555b98865 in submit_requests (blk=0x555556b7b000, mrb=0x7fffffffda10, start=0, num_reqs=1, niov=-1) at ../hw/block/virtio-blk.c:426
+ * #2  0x0000555555b9893c in virtio_blk_submit_multireq (blk=0x555556b7b000, mrb=0x7fffffffda10) at ../hw/block/virtio-blk.c:456
+ * #3  0x0000555555b99862 in virtio_blk_handle_vq (s=0x55555796bc90, vq=0x555557974eb0) at ../hw/block/virtio-blk.c:800
+ * #4  0x0000555555c6c670 in virtio_blk_data_plane_handle_output (vdev=0x55555796bc90, vq=0x555557974eb0) at ../hw/block/dataplane/virtio-blk.c:165
+ * #5  0x0000555555c1b72b in virtio_queue_notify_aio_vq (vq=0x555557974eb0) at ../hw/virtio/virtio.c:2326
+ * #6  0x0000555555c1e575 in virtio_queue_host_notifier_aio_read (n=0x555557974f2c) at ../hw/virtio/virtio.c:3533
+ * #7  0x0000555555ec79f5 in aio_dispatch_handler (ctx=0x55555696caa0, node=0x7ffee8021e60) at ../util/aio-posix.c:329
+ * #8  0x0000555555ec7bae in aio_dispatch_handlers (ctx=0x55555696caa0) at ../util/aio-posix.c:372
+ * #9  0x0000555555ec7c04 in aio_dispatch (ctx=0x55555696caa0) at ../util/aio-posix.c:382
+ * #10 0x0000555555e9cb19 in aio_ctx_dispatch (source=0x55555696caa0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #11 0x00007ffff743c099 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #12 0x0000555555ead61b in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #13 0x0000555555ead695 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:254
+ * #14 0x0000555555ead79d in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #15 0x0000555555b9c37f in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #16 0x0000555555819412 in main (argc=28, argv=0x7fffffffdee8, envp=0x7fffffffdfd0) at ../softmmu/main.c:50
+ *
+ * (gdb) bt
+ * #0  0x0000555555d99d1a in blk_aio_preadv (blk=0x555556b6e140, offset=0, qiov=0x555556ea10e0, flags=0, cb=0x55555592a693 <dma_blk_cb>, opaque=0x555556ea1080) at ../block/block-backend.c:1540
+ * #1  0x0000555555921204 in scsi_dma_readv (offset=0, iov=0x555556ea10e0, cb=0x55555592a693 <dma_blk_cb>, cb_opaque=0x555556ea1080, opaque=0x555557b0e9a0) at ../hw/scsi/scsi-disk.c:2969
+ * #2  0x000055555592aa33 in dma_blk_cb (opaque=0x555556ea1080, ret=0) at ../softmmu/dma-helpers.c:191
+ * #3  0x000055555592acb2 in dma_blk_io (ctx=0x55555696caa0, sg=0x5555577cc448, offset=0, align=512, io_func=0x55555592118f <scsi_dma_readv>, io_func_opaque=0x555557b0e9a0, cb=0x55555591a4b6 <scsi_dma_complete>, opaque=0x555557b0e9a0, dir=DMA_DIRECTION_FROM_DEVICE) at ../softmmu/dma-helpers.c:255
+ * #4  0x000055555591a977 in scsi_do_read (r=0x555557b0e9a0, ret=0) at ../hw/scsi/scsi-disk.c:424
+ * #5  0x000055555591ad4d in scsi_read_data (req=0x555557b0e9a0) at ../hw/scsi/scsi-disk.c:496
+ * #6  0x0000555555897a43 in scsi_req_continue (req=0x555557b0e9a0) at ../hw/scsi/scsi-bus.c:1394
+ * #7  0x0000555555ca2c3b in virtio_scsi_handle_cmd_req_submit (s=0x555557833620, req=0x5555577cc400) at ../hw/scsi/virtio-scsi.c:669
+ * #8  0x0000555555ca2e97 in virtio_scsi_handle_cmd_vq (s=0x555557833620, vq=0x55555783ad40) at ../hw/scsi/virtio-scsi.c:713
+ * #9  0x0000555555c37f04 in virtio_scsi_data_plane_handle_cmd (vdev=0x555557833620, vq=0x55555783ad40) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #10 0x0000555555c1b72b in virtio_queue_notify_aio_vq (vq=0x55555783ad40) at ../hw/virtio/virtio.c:2326
+ * #11 0x0000555555c1e575 in virtio_queue_host_notifier_aio_read (n=0x55555783adbc) at ../hw/virtio/virtio.c:3533
+ * #12 0x0000555555ec79f5 in aio_dispatch_handler (ctx=0x55555696caa0, node=0x7ffedc004cd0) at ../util/aio-posix.c:329
+ * #13 0x0000555555ec7bae in aio_dispatch_handlers (ctx=0x55555696caa0) at ../util/aio-posix.c:372
+ * #14 0x0000555555ec7c04 in aio_dispatch (ctx=0x55555696caa0) at ../util/aio-posix.c:382
+ * #15 0x0000555555e9cb19 in aio_ctx_dispatch (source=0x55555696caa0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #16 0x00007ffff743c099 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #17 0x0000555555ead61b in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #18 0x0000555555ead695 in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:254
+ * #19 0x0000555555ead79d in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #20 0x0000555555b9c37f in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #21 0x0000555555819412 in main (argc=28, argv=0x7fffffffdee8, envp=0x7fffffffdfd0) at ../softmmu/main.c:50
+ *
+ * called by:
+ *   - hw/block/dataplane/xen-block.c|380| <<xen_block_do_aio>> blk_aio_preadv(dataplane->blk, request->start, &request->v, 0,
+ *   - hw/block/nvme-dif.c|331| <<nvme_dif_rw_mdata_in_cb>> req->aiocb = blk_aio_preadv(blk, offset, &ctx->mdata.iov, 0,
+ *   - hw/block/nvme-dif.c|457| <<nvme_dif_rw>> req->aiocb = blk_aio_preadv(ns->blkconf.blk, offset, &ctx->data.iov, 0,
+ *   - hw/block/nvme.c|1234| <<nvme_blk_read>> req->aiocb = blk_aio_preadv(blk, offset, &req->sg.iov, 0, cb, req);
+ *   - hw/block/nvme.c|2019| <<nvme_verify_mdata_in_cb>> req->aiocb = blk_aio_preadv(blk, offset, &ctx->mdata.iov, 0,
+ *   - hw/block/nvme.c|2483| <<nvme_compare_data_cb>> req->aiocb = blk_aio_preadv(blk, offset, &ctx->mdata.iov, 0,
+ *   - hw/block/nvme.c|2629| <<nvme_verify>> req->aiocb = blk_aio_preadv(ns->blkconf.blk, offset, &ctx->data.iov, 0,
+ *   - hw/block/nvme.c|2750| <<nvme_copy>> blk_aio_preadv(ns->blkconf.blk, offset, &in_ctx->iov, 0,
+ *   - hw/block/nvme.c|2767| <<nvme_copy>> blk_aio_preadv(ns->blkconf.blk, offset, &in_ctx->iov, 0,
+ *   - hw/block/nvme.c|2847| <<nvme_compare>> req->aiocb = blk_aio_preadv(blk, offset, &ctx->data.iov, 0,
+ *   - hw/block/virtio-blk.c|426| <<submit_requests>> blk_aio_preadv(blk, sector_num << BDRV_SECTOR_BITS, qiov, 0,
+ *   - hw/ide/core.c|687| <<ide_buffered_readv>> aioreq = blk_aio_preadv(s->blk, sector_num << BDRV_SECTOR_BITS,
+ *   - hw/scsi/scsi-disk.c|2969| <<scsi_dma_readv>> return blk_aio_preadv(s->qdev.conf.blk, offset, iov, 0, cb, cb_opaque);
+ *   - migration/block.c|336| <<mig_save_device_bulk>> blk->aiocb = blk_aio_preadv(bb, cur_sector * BDRV_SECTOR_SIZE, &blk->qiov,
+ *   - migration/block.c|561| <<mig_save_device_dirty>> blk->aiocb = blk_aio_preadv(bmds->blk,
+ *   - qemu-img.c|4255| <<bench_cb>> acb = blk_aio_preadv(b->blk, offset, b->qiov, 0, bench_cb, b);
+ *   - qemu-io-cmds.c|668| <<do_aio_readv>> blk_aio_preadv(blk, offset, qiov, 0, aio_rw_done, &async_ret);
+ *   - qemu-io-cmds.c|1521| <<aio_read_f>> blk_aio_preadv(blk, ctx->offset, &ctx->qiov, 0, aio_read_done, ctx);
+ *   - softmmu/dma-helpers.c|266| <<dma_blk_read_io_func>> return blk_aio_preadv(blk, offset, iov, 0, cb, cb_opaque);
+ *   - tests/unit/test-bdrv-drain.c|229| <<test_drv_cb_common>> acb = blk_aio_preadv(blk, 0, &qiov, 0, aio_ret_cb, &aio_ret);
+ *   - tests/unit/test-bdrv-drain.c|686| <<test_iothread_common>> acb = blk_aio_preadv(blk, 0, &qiov, 0, test_iothread_aio_cb, &aio_ret);
+ *   - tests/unit/test-bdrv-drain.c|688| <<test_iothread_common>> acb = blk_aio_preadv(blk, 0, &qiov, 0, aio_ret_cb, &aio_ret);
+ *   - tests/unit/test-bdrv-drain.c|1414| <<test_detach_indirect>> acb = blk_aio_preadv(blk, 0, &qiov, 0, detach_by_parent_aio_cb, NULL);
+ *   - tests/unit/test-replication.c|76| <<test_blk_read>> blk_aio_preadv(blk, offset, &qiov, 0, blk_rw_done, &async_ret);
+ */
 BlockAIOCB *blk_aio_preadv(BlockBackend *blk, int64_t offset,
                            QEMUIOVector *qiov, BdrvRequestFlags flags,
                            BlockCompletionFunc *cb, void *opaque)
diff --git a/block/curl.c b/block/curl.c
index 50e741a0d..32bcd45da 100644
--- a/block/curl.c
+++ b/block/curl.c
@@ -106,6 +106,12 @@ typedef struct BDRVCURLState {
     bool sslverify;
     uint64_t timeout;
     char *cookie;
+    /*
+     * 在以下使用BDRVURLState->accept_range:
+     *   - block/curl.c|230| <<curl_header_cb>> s->accept_range = true;
+     *   - block/curl.c|764| <<curl_open>> s->accept_range = false;
+     *   - block/curl.c|795| <<curl_open>> && !s->accept_range) {
+     */
     bool accept_range;
     AioContext *aio_context;
     QemuMutex mutex;
@@ -197,10 +203,59 @@ static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,
 }
 
 /* Called from curl_multi_do_locked, with s->mutex held.  */
+/*
+ * (gdb) bt
+ * #0  curl_header_cb (ptr=0x555555962620, size=1, nmemb=17, opaque=0x555555956a20) at ../block/curl.c:203
+ * #1  0x00007ffff6ba9b6a in Curl_client_write () from /lib64/libcurl.so.4
+ * #2  0x00007ffff6ba8285 in Curl_http_readwrite_headers () from /lib64/libcurl.so.4
+ * #3  0x00007ffff6bbdd40 in Curl_readwrite () from /lib64/libcurl.so.4
+ * #4  0x00007ffff6bc7dbb in multi_runsingle () from /lib64/libcurl.so.4
+ * #5  0x00007ffff6bc8761 in curl_multi_perform () from /lib64/libcurl.so.4
+ * #6  0x00007ffff6bbf973 in curl_easy_perform () from /lib64/libcurl.so.4
+ * #7  0x000055555558c12b in curl_open (bs=0x55555594f5f0, options=<optimized out>, flags=<optimized out>, errp=0x7fffffffdb80) at ../block/curl.c:769
+ * #8  0x00005555555dec36 in bdrv_open_driver (bs=bs@entry=0x55555594f5f0, drv=drv@entry=0x55555590bbe0 <bdrv_https>, node_name=<optimized out>, options=options@entry=0x555555954c60,
+ *                               open_flags=16384, errp=errp@entry=0x7fffffffdc30) at ../block.c:1528
+ * #9  0x00005555555e3132 in bdrv_open_common (errp=0x7fffffffdc30, options=0x555555954c60, file=0x0, bs=0x55555594f5f0) at ../block.c:1802
+ * #10 bdrv_open_inherit (filename=<optimized out>, filename@entry=0x7fffffffe388 "https://www/test.iso", reference=<optimized out>, options=0x555555954c60,
+ *                           flags=<optimized out>, flags@entry=0, parent=parent@entry=0x555555947f50, child_class=child_class@entry=0x555555906ea0 <child_of_bds>, child_role=19,
+ *                           errp=0x7fffffffdd90) at ../block.c:3444
+ * #11 0x00005555555e3f3a in bdrv_open_child_bs (filename=filename@entry=0x7fffffffe388 "https://www/test.iso", options=options@entry=0x55555594d3e0,
+ *                               bdref_key=bdref_key@entry=0x5555556be49c "file", parent=parent@entry=0x555555947f50, child_class=child_class@entry=0x555555906ea0 <child_of_bds>,
+ *                               child_role=child_role@entry=19, allow_none=true, errp=0x7fffffffdd90) at ../block.c:3079
+ * #12 0x00005555555e371b in bdrv_open_inherit (filename=filename@entry=0x7fffffffe388 "https://www/test.iso", reference=reference@entry=0x0, options=0x55555594d3e0,
+ *                               options@entry=0x555555946be0, flags=<optimized out>, flags@entry=65792, parent=parent@entry=0x0, child_class=child_class@entry=0x0, child_role=0,
+ *                               errp=0x7fffffffde80) at ../block.c:3391
+ * #13 0x00005555555e4203 in bdrv_open (filename=filename@entry=0x7fffffffe388 "https://www/test.iso", reference=reference@entry=0x0, options=options@entry=0x555555946be0,
+ *                               flags=flags@entry=65792, errp=errp@entry=0x7fffffffde80) at ../block.c:3537
+ * #14 0x00005555555a0f06 in blk_new_open (filename=0x7fffffffe388 "https://www/test.iso", reference=0x0, options=0x555555946be0, flags=65792, errp=0x7fffffffde80) at ../block/block-backend.c:421
+ * #15 0x000055555557b27b in img_open_file (filename=0x7fffffffe388 "https://www/test.iso", options=0x555555946be0, fmt=<optimized out>, flags=65792,
+ *                               writethrough=<optimized out>, force_share=<optimized out>, quiet=<optimized out>) at ../qemu-img.c:397
+ * #16 0x000055555557b492 in img_open (image_opts=false, force_share=false, quiet=<optimized out>, writethrough=<optimized out>, flags=65792, fmt=<optimized out>,
+ *                               filename=0x7fffffffe388 "https://www/test.iso") at ../qemu-img.c:442
+ * #17 img_open (image_opts=<optimized out>, filename=0x7fffffffe388 "https://www/test.iso", fmt=<optimized out>, flags=65792, writethrough=<optimized out>, quiet=<optimized out>,
+ *                               force_share=false) at ../qemu-img.c:422
+ * #18 0x000055555557b6f5 in collect_image_info_list (force_share=<optimized out>, chain=false, fmt=0x0, filename=0x7fffffffe388 "https://www/test.iso", image_opts=false) at ../qemu-img.c:2813
+ * #19 img_info (argc=<optimized out>, argv=<optimized out>) at ../qemu-img.c:2932
+ * #20 0x000055555557845c in main (argc=2, argv=<optimized out>) at ../qemu-img.c:5375
+ *
+ * called by:
+ *   - block/curl.c|785| <<curl_open>> curl_easy_setopt(state->curl, CURLOPT_HEADERFUNCTION, curl_header_cb);
+ */
 static size_t curl_header_cb(void *ptr, size_t size, size_t nmemb, void *opaque)
 {
     BDRVCURLState *s = opaque;
     size_t realsize = size * nmemb;
+    /*
+     * 猜测此时ptr是以下的
+     * HTTP/1.1 200 OK
+     * Date: Mon, 09 Aug 2021 21:52:58 GMT
+     * Server: Apache/x.x.x () OpenSSL/x.x.2k-fips
+     * Last-Modified: Mon, 24 May 2021 17:20:54 GMT
+     * ETag: "111100000-y123412343456"
+     * Accept-Ranges: bytes
+     * Content-Length: 9931063296
+     * Content-Type: application/octet-stream
+     */
     const char *header = (char *)ptr;
     const char *end = header + realsize;
     const char *accept_ranges = "accept-ranges:";
@@ -210,6 +265,9 @@ static size_t curl_header_cb(void *ptr, size_t size, size_t nmemb, void *opaque)
         && g_ascii_strncasecmp(header, accept_ranges,
                                strlen(accept_ranges)) == 0) {
 
+        /*
+	 * returns a pointer to the first occurrence of the character
+	 */
         char *p = strchr(header, ':') + 1;
 
         /* Skip whitespace between the header name and value. */
@@ -227,6 +285,12 @@ static size_t curl_header_cb(void *ptr, size_t size, size_t nmemb, void *opaque)
             }
 
             if (p == end || !*p) {
+                /*
+		 * 在以下使用BDRVURLState->accept_range:
+		 *   - block/curl.c|230| <<curl_header_cb>> s->accept_range = true;
+		 *   - block/curl.c|764| <<curl_open>> s->accept_range = false;
+		 *   - block/curl.c|795| <<curl_open>> && !s->accept_range) {
+		 */
                 s->accept_range = true;
             }
         }
@@ -761,6 +825,12 @@ static int curl_open(BlockDriverState *bs, QDict *options, int flags,
         goto out;
     }
 
+    /*
+     * 在以下使用BDRVURLState->accept_range:
+     *   - block/curl.c|230| <<curl_header_cb>> s->accept_range = true;
+     *   - block/curl.c|764| <<curl_open>> s->accept_range = false;
+     *   - block/curl.c|795| <<curl_open>> && !s->accept_range) {
+     */
     s->accept_range = false;
     curl_easy_setopt(state->curl, CURLOPT_NOBODY, 1);
     curl_easy_setopt(state->curl, CURLOPT_HEADERFUNCTION,
@@ -790,6 +860,12 @@ static int curl_open(BlockDriverState *bs, QDict *options, int flags,
 
     s->len = d;
 
+    /*
+     * 在以下使用BDRVURLState->accept_range:
+     *   - block/curl.c|230| <<curl_header_cb>> s->accept_range = true;
+     *   - block/curl.c|764| <<curl_open>> s->accept_range = false;
+     *   - block/curl.c|795| <<curl_open>> && !s->accept_range) {
+     */
     if ((!strncasecmp(s->url, "http://", strlen("http://"))
         || !strncasecmp(s->url, "https://", strlen("https://")))
         && !s->accept_range) {
diff --git a/block/file-posix.c b/block/file-posix.c
index 20e14f8e9..e33719dc9 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -1173,6 +1173,10 @@ static void raw_reopen_abort(BDRVReopenState *state)
     s->reopen_state = NULL;
 }
 
+/*
+ * called by:
+ *   - block/file-posix.c|1247| <<raw_refresh_limits>> int ret = sg_get_max_transfer_length(s->fd);
+ */
 static int sg_get_max_transfer_length(int fd)
 {
 #ifdef BLKSECTGET
@@ -1188,6 +1192,10 @@ static int sg_get_max_transfer_length(int fd)
 #endif
 }
 
+/*
+ * called by:
+ *   - block/file-posix.c|1253| <<raw_refresh_limits>> ret = sg_get_max_segments(s->fd);
+ */
 static int sg_get_max_segments(int fd)
 {
 #ifdef CONFIG_LINUX
@@ -1486,6 +1494,16 @@ static ssize_t handle_aiocb_rw_linear(RawPosixAIOData *aiocb, char *buf)
     return offset;
 }
 
+/*
+ * Thread 9 "worker" hit Breakpoint 1, handle_aiocb_rw (opaque=0x7ffed1ada6f0) at ../block/file-posix.c:1491
+ * 1491	    RawPosixAIOData *aiocb = opaque;
+ * (gdb) bt
+ * #0  0x0000555555dec45d in handle_aiocb_rw (opaque=0x7ffed1ada6f0) at ../block/file-posix.c:1491
+ * #1  0x0000555555eb0285 in worker_thread (opaque=0x555556b7b5d0) at ../util/thread-pool.c:104
+ * #2  0x0000555555e8d7ea in qemu_thread_start (args=0x55555752b970) at ../util/qemu-thread-posix.c:521
+ * #3  0x00007ffff542fea5 in start_thread () at /lib64/libpthread.so.0
+ * #4  0x00007ffff51589fd in clone () at /lib64/libc.so.6
+ */
 static int handle_aiocb_rw(void *opaque)
 {
     RawPosixAIOData *aiocb = opaque;
@@ -1986,6 +2004,37 @@ static int coroutine_fn raw_thread_pool_submit(BlockDriverState *bs,
     return thread_pool_submit_co(pool, func, arg);
 }
 
+/*
+ * Thread 1 "qemu-system-x86" hit Breakpoint 1, raw_co_prw (bs=0x555556915380, offset=540160, bytes=16896, qiov=0x555556c20188, type=1) at ../block/file-posix.c:1991
+ * 1991	{
+ * (gdb) bt
+ * #0  0x0000555555bfa120 in raw_co_prw (bs=0x555556915380, offset=540160, bytes=16896, qiov=0x555556c20188, type=1) at ../block/file-posix.c:1991
+ * #1  0x0000555555bf125b in bdrv_driver_preadv
+ *     (bs=bs@entry=0x555556915380, offset=offset@entry=540160, bytes=bytes@entry=16896, qiov=qiov@entry=0x555556c20188, qiov_offset=qiov_offset@entry=0, flags=flags@entry=0) at ../block/io.c:1158
+ * #2  0x0000555555bf5b60 in bdrv_aligned_preadv (child=child@entry=0x55555691aec0, req=req@entry=0x7ffed22e2950, offset=540160, bytes=16896, align=<optimized out>, qiov=0x555556c20188, qiov_offset=0, flags=0)
+ *     at ../block/io.c:1545
+ * #3  0x0000555555bf6269 in bdrv_co_preadv_part (child=0x55555691aec0, offset=<optimized out>, offset@entry=540160, bytes=<optimized out>, bytes@entry=16896, qiov=<optimized out>,
+ *     qiov@entry=0x555556c20188, qiov_offset=<optimized out>, qiov_offset@entry=0, flags=flags@entry=0) at ../block/io.c:1816
+ * #4  0x0000555555c00c72 in qcow2_co_preadv_task (qiov_offset=0, qiov=<optimized out>, bytes=16896, offset=<optimized out>, host_offset=540160, subc_type=<optimized out>, bs=0x55555690e070)
+ *     at ../block/qcow2.c:2263
+ * #5  0x0000555555c00c72 in qcow2_co_preadv_task_entry (task=<optimized out>) at ../block/qcow2.c:2279
+ * #6  0x0000555555bfe92e in qcow2_add_task
+ *     (bs=bs@entry=0x55555690e070, pool=pool@entry=0x0, func=func@entry=0x555555c00bc0 <qcow2_co_preadv_task_entry>, subcluster_type=QCOW2_SUBCLUSTER_NORMAL, host_offset=540160, offset=offset@entry=1064448, bytes=16896, qiov=0x555556c20188, qiov_offset=0, l2meta=0x0) at ../block/qcow2.c:2221
+ * #7  0x0000555555c004d9 in qcow2_co_preadv_part (bs=0x55555690e070, offset=1064448, bytes=16896, qiov=0x555556c20188, qiov_offset=0, flags=<optimized out>) at ../block/qcow2.c:2322
+ * #8  0x0000555555bf11ec in bdrv_driver_preadv
+ *     (bs=bs@entry=0x55555690e070, offset=offset@entry=1064448, bytes=bytes@entry=16896, qiov=qiov@entry=0x555556c20188, qiov_offset=qiov_offset@entry=0, flags=flags@entry=0) at ../block/io.c:1148
+ * #9  0x0000555555bf5b60 in bdrv_aligned_preadv (child=child@entry=0x55555691cec0, req=req@entry=0x7ffed22e2e40, offset=1064448, bytes=16896, align=<optimized out>, qiov=0x555556c20188, qiov_offset=0, flags=0)
+ *     at ../block/io.c:1545
+ * #10 0x0000555555bf6269 in bdrv_co_preadv_part (child=0x55555691cec0, offset=<optimized out>, offset@entry=1064448, bytes=<optimized out>, bytes@entry=16896, qiov=<optimized out>,
+ *     qiov@entry=0x555556c20188, qiov_offset=<optimized out>, qiov_offset@entry=0, flags=flags@entry=0) at ../block/io.c:1816
+ * #11 0x0000555555bf638b in bdrv_co_preadv (child=<optimized out>, offset=offset@entry=1064448, bytes=bytes@entry=16896, qiov=qiov@entry=0x555556c20188, flags=flags@entry=0) at ../block/io.c:1766
+ * #12 0x0000555555bd4120 in blk_do_preadv (blk=0x5555568fdc30, offset=1064448, bytes=16896, qiov=0x555556c20188, flags=0) at ../block/block-backend.c:1211
+ * #13 0x0000555555bd42b6 in blk_aio_read_entry (opaque=0x5555576e3310) at ../block/block-backend.c:1464
+ * #14 0x0000555555cf1dfb in coroutine_trampoline (i0=<optimized out>, i1=<optimized out>) at ../util/coroutine-ucontext.c:173
+ * #15 0x00007ffff50a4190 in __start_context () at /lib64/libc.so.6
+ * #16 0x00007fffffffd1d0 in  ()
+ * #17 0x0000000000000000 in  ()
+ */
 static int coroutine_fn raw_co_prw(BlockDriverState *bs, uint64_t offset,
                                    uint64_t bytes, QEMUIOVector *qiov, int type)
 {
diff --git a/block/linux-aio.c b/block/linux-aio.c
index 3c0527c2b..9884d4fe1 100644
--- a/block/linux-aio.c
+++ b/block/linux-aio.c
@@ -277,6 +277,12 @@ static void ioq_init(LaioQueue *io_q)
     io_q->blocked = false;
 }
 
+/*
+ * called by:
+ *   - block/linux-aio.c|236| <<qemu_laio_process_completions_and_submit>> ioq_submit(s);
+ *   - block/linux-aio.c|344| <<laio_io_unplug>> ioq_submit(s);
+ *   - block/linux-aio.c|375| <<laio_do_submit>> ioq_submit(s);
+ */
 static void ioq_submit(LinuxAioState *s)
 {
     int ret, len;
diff --git a/hw/acpi/cpu.c b/hw/acpi/cpu.c
index e2317be54..f24368d77 100644
--- a/hw/acpi/cpu.c
+++ b/hw/acpi/cpu.c
@@ -7,6 +7,10 @@
 #include "trace.h"
 #include "sysemu/numa.h"
 
+/*
+ * https://zhuanlan.zhihu.com/p/113296734
+ */
+
 #define ACPI_CPU_HOTPLUG_REG_LEN 12
 #define ACPI_CPU_SELECTOR_OFFSET_WR 0
 #define ACPI_CPU_FLAGS_OFFSET_RW 4
@@ -341,6 +345,10 @@ const VMStateDescription vmstate_cpu_hotplug = {
 #define CPU_EJECT_EVENT   "CEJ0"
 #define CPU_FW_EJECT_EVENT "CEJF"
 
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|1468| <<build_dsdt>> build_cpus_aml(dsdt, machine, opts, pm->cpu_hp_io_base,
+ */
 void build_cpus_aml(Aml *table, MachineState *machine, CPUHotplugFeatures opts,
                     hwaddr io_base,
                     const char *res_root,
diff --git a/hw/acpi/cpu_hotplug.c b/hw/acpi/cpu_hotplug.c
index 53654f863..9f217136d 100644
--- a/hw/acpi/cpu_hotplug.c
+++ b/hw/acpi/cpu_hotplug.c
@@ -103,6 +103,10 @@ void acpi_switch_to_modern_cphp(AcpiCpuHotplug *gpe_cpu,
     cpu_hotplug_hw_init(parent, gpe_cpu->device, cpuhp_state, io_port);
 }
 
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|1461| <<build_dsdt>> build_legacy_cpu_hotplug_aml(dsdt, machine, pm->cpu_hp_io_base);
+ */
 void build_legacy_cpu_hotplug_aml(Aml *ctx, MachineState *machine,
                                   uint16_t io_base)
 {
diff --git a/hw/acpi/generic_event_device.c b/hw/acpi/generic_event_device.c
index 5454be67d..040582d83 100644
--- a/hw/acpi/generic_event_device.c
+++ b/hw/acpi/generic_event_device.c
@@ -38,6 +38,11 @@ static const uint32_t ged_supported_events[] = {
  * affected by the interrupt. This way, we can support up to 32 events
  * with a unique interrupt.
  */
+/*
+ * called by:
+ *   - hw/arm/virt-acpi-build.c|624| <<build_dsdt>> build_ged_aml(scope, "\\_SB."GED_DEVICE,
+ *   - hw/i386/acpi-microvm.c|130| <<build_dsdt_microvm>> build_ged_aml(sb_scope, GED_DEVICE, x86ms->acpi_dev,
+ */
 void build_ged_aml(Aml *table, const char *name, HotplugHandler *hotplug_dev,
                    uint32_t ged_irq, AmlRegionSpace rs, hwaddr ged_base)
 {
diff --git a/hw/core/cpu.c b/hw/core/cpu.c
index 00330ba07..feb7b1b2e 100644
--- a/hw/core/cpu.c
+++ b/hw/core/cpu.c
@@ -50,6 +50,10 @@ CPUState *cpu_by_arch_id(int64_t id)
     return NULL;
 }
 
+/*
+ * called by:
+ *   - target/s390x/cpu.c|216| <<s390_cpu_realizefn>> if (cpu_exists(cpu->env.core_id)) {
+ */
 bool cpu_exists(int64_t id)
 {
     return !!cpu_by_arch_id(id);
diff --git a/hw/core/machine.c b/hw/core/machine.c
index 40def7818..4dd4385f5 100644
--- a/hw/core/machine.c
+++ b/hw/core/machine.c
@@ -1236,6 +1236,25 @@ void machine_run_board_init(MachineState *machine)
 static NotifierList machine_init_done_notifiers =
     NOTIFIER_LIST_INITIALIZER(machine_init_done_notifiers);
 
+/*
+ * called by:
+ *   - hw/acpi/piix4.c|516| <<piix4_pm_realize>> qemu_add_machine_init_done_notifier(&s->machine_ready);
+ *   - hw/arm/virt.c|2113| <<machvirt_init>> qemu_add_machine_init_done_notifier(&vms->machine_done);
+ *   - hw/core/machine.c|961| <<machine_initfn>> qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);
+ *   - hw/i386/intel_iommu.c|3850| <<vtd_realize>> qemu_add_machine_init_done_notifier(&vtd_machine_done_notify);
+ *   - hw/i386/microvm.c|669| <<microvm_machine_initfn>> qemu_add_machine_init_done_notifier(&mms->machine_done);
+ *   - hw/i386/pc.c|821| <<pc_guest_info_init>> qemu_add_machine_init_done_notifier(&pcms->machine_done);
+ *   - hw/intc/ioapic.c|470| <<ioapic_realize>> qemu_add_machine_init_done_notifier(&s->machine_done);
+ *   - hw/isa/lpc_ich9.c|702| <<ich9_lpc_realize>> qemu_add_machine_init_done_notifier(&lpc->machine_ready);
+ *   - hw/nvram/fw_cfg.c|1143| <<fw_cfg_common_realize>> qemu_add_machine_init_done_notifier(&s->machine_ready);
+ *   - hw/pci/pci.c|128| <<pci_bus_realize>> qemu_add_machine_init_done_notifier(&bus->machine_done);
+ *   - hw/ppc/e500.c|651| <<ppce500_prep_device_tree>> qemu_add_machine_init_done_notifier(&p->notifier);
+ *   - hw/remote/remote-obj.c|146| <<remote_object_init>> qemu_add_machine_init_done_notifier(&o->machine_done);
+ *   - target/arm/kvm.c|392| <<kvm_arm_register_device>> qemu_add_machine_init_done_notifier(&notify);
+ *   - target/i386/cpu.c|6906| <<x86_cpu_realizefn>> qemu_add_machine_init_done_notifier(&cpu->machine_done);
+ *   - target/i386/kvm/kvm.c|2244| <<kvm_arch_init>> qemu_add_machine_init_done_notifier(&smram_machine_done);
+ *   - target/i386/sev.c|800| <<sev_kvm_init>> qemu_add_machine_init_done_notifier(&sev_machine_done_notify);
+ */
 void qemu_add_machine_init_done_notifier(Notifier *notify)
 {
     notifier_list_add(&machine_init_done_notifiers, notify);
diff --git a/hw/core/nmi.c b/hw/core/nmi.c
index 481c4b3c7..42112adba 100644
--- a/hw/core/nmi.c
+++ b/hw/core/nmi.c
@@ -53,11 +53,22 @@ static int do_nmi(Object *o, void *opaque)
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/core/nmi.c|51| <<do_nmi>> nmi_children(o, ns);
+ *   - hw/core/nmi.c|69| <<nmi_monitor_handle>> nmi_children(object_get_root(), &ns);
+ */
 static void nmi_children(Object *o, struct do_nmi_s *ns)
 {
     object_child_foreach(o, do_nmi, ns);
 }
 
+/*
+ * called by:
+ *   - hw/ipmi/ipmi.c|63| <<ipmi_do_hw_op>> nmi_monitor_handle(0, NULL);
+ *   - hw/watchdog/watchdog.c|138| <<watchdog_perform_action>> nmi_monitor_handle(0, NULL);
+ *   - softmmu/cpus.c|803| <<qmp_inject_nmi>> nmi_monitor_handle(monitor_get_cpu_index(monitor_cur()), errp);
+ */
 void nmi_monitor_handle(int cpu_index, Error **errp)
 {
     struct do_nmi_s ns = {
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index cefc5eaa0..601ffb786 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -106,6 +106,12 @@ static bool bus_check_address(BusState *bus, DeviceState *child, Error **errp)
     return !bc->check_address || bc->check_address(bus, child, errp);
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev.c|382| <<qdev_realize>> if (!qdev_set_parent_bus(dev, bus, errp)) {
+ *   - hw/net/virtio-net.c|3127| <<failover_replug_primary>> qdev_set_parent_bus(dev, primary_bus, &error_abort);
+ *   - hw/sd/core.c|257| <<sdbus_reparent_card>> qdev_set_parent_bus(DEVICE(card), &to->qbus, &error_abort);
+ */
 bool qdev_set_parent_bus(DeviceState *dev, BusState *bus, Error **errp)
 {
     BusState *old_parent_bus = dev->parent_bus;
diff --git a/hw/i386/intel_iommu.c b/hw/i386/intel_iommu.c
index 6be8f3291..3e863971c 100644
--- a/hw/i386/intel_iommu.c
+++ b/hw/i386/intel_iommu.c
@@ -51,6 +51,12 @@
 /* pe operations */
 #define VTD_PE_GET_TYPE(pe) ((pe)->val[0] & VTD_SM_PASID_ENTRY_PGTT)
 #define VTD_PE_GET_LEVEL(pe) (2 + (((pe)->val[0] >> 2) & VTD_SM_PASID_ENTRY_AW))
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|1733| <<vtd_do_iommu_translate>> VTD_PE_GET_FPD_ERR(ret_fr, is_fpd_set, s, source_id, addr, is_write);
+ *   - hw/i386/intel_iommu.c|1741| <<vtd_do_iommu_translate>> VTD_PE_GET_FPD_ERR(ret_fr, is_fpd_set, s, source_id, addr, is_write);
+ *   - hw/i386/intel_iommu.c|1777| <<vtd_do_iommu_translate>> VTD_PE_GET_FPD_ERR(ret_fr, is_fpd_set, s, source_id, addr, is_write);
+ */
 #define VTD_PE_GET_FPD_ERR(ret_fr, is_fpd_set, s, source_id, addr, is_write) {\
     if (ret_fr) {                                                             \
         ret_fr = -ret_fr;                                                     \
@@ -424,6 +430,10 @@ static void vtd_set_frcd_and_update_ppf(IntelIOMMUState *s, uint16_t index)
 }
 
 /* Must not update F field now, should be done later */
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|510| <<vtd_report_dmar_fault>> vtd_record_frcd(s, s->next_frcd_reg, source_id, addr, fault, is_write);
+ */
 static void vtd_record_frcd(IntelIOMMUState *s, uint16_t index,
                             uint16_t source_id, hwaddr addr,
                             VTDFaultReason fault, bool is_write)
@@ -463,6 +473,10 @@ static bool vtd_try_collapse_fault(IntelIOMMUState *s, uint16_t source_id)
 }
 
 /* Log and report an DMAR (address translation) fault to software */
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|60| <<VTD_PE_GET_FPD_ERR>> vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write); \
+ */
 static void vtd_report_dmar_fault(IntelIOMMUState *s, uint16_t source_id,
                                   hwaddr addr, VTDFaultReason fault,
                                   bool is_write)
@@ -1682,6 +1696,10 @@ out:
  *
  * Returns true if translation is successful, otherwise false.
  */
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|2994| <<vtd_iommu_translate>> success = vtd_do_iommu_translate(vtd_as, vtd_as->bus, vtd_as->devfn,
+ */
 static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,
                                    uint8_t devfn, hwaddr addr, bool is_write,
                                    IOMMUTLBEntry *entry)
@@ -2197,6 +2215,10 @@ static void vtd_handle_gcmd_ire(IntelIOMMUState *s, bool en)
 }
 
 /* Handle write to Global Command Register */
+/*
+ * 处理DMAR_GCMD_REG:
+ *   - hw/i386/intel_iommu.c|2761| <<vtd_mem_write>> vtd_handle_gcmd_write(s);
+ */
 static void vtd_handle_gcmd_write(IntelIOMMUState *s)
 {
     uint32_t status = vtd_get_long_raw(s, DMAR_GSTS_REG);
@@ -2969,6 +2991,10 @@ static void vtd_mem_write(void *opaque, hwaddr addr,
     }
 }
 
+/*
+ * 在以下使用vtd_iommu_translate():
+ *   - hw/i386/intel_iommu.c|3915| <<vtd_iommu_memory_region_class_init>> imrc->translate = vtd_iommu_translate;
+ */
 static IOMMUTLBEntry vtd_iommu_translate(IOMMUMemoryRegion *iommu, hwaddr addr,
                                          IOMMUAccessFlags flag, int iommu_idx)
 {
@@ -3106,6 +3132,10 @@ static Property vtd_properties[] = {
 };
 
 /* Read IRTE entry with specific index */
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|3200| <<vtd_remap_irq_get>> ret = vtd_irte_get(iommu, index, &irte, sid);
+ */
 static int vtd_irte_get(IntelIOMMUState *iommu, uint16_t index,
                         VTD_IR_TableEntry *entry, uint16_t sid)
 {
@@ -3121,6 +3151,12 @@ static int vtd_irte_get(IntelIOMMUState *iommu, uint16_t index,
         return -VTD_FR_IR_INDEX_OVER;
     }
 
+    /*
+     * struct IntelIOMMUState *iommu:
+     * -> bool intr_enabled;    // Whether guest enabled IR
+     * -> dma_addr_t intr_root; // Interrupt remapping table pointer
+     * -> uint32_t intr_size;   // Number of IR table entries
+     */
     addr = iommu->intr_root + index * sizeof(*entry);
     if (dma_memory_read(&address_space_memory, addr, entry,
                         sizeof(*entry))) {
@@ -3191,6 +3227,10 @@ static int vtd_irte_get(IntelIOMMUState *iommu, uint16_t index,
 }
 
 /* Fetch IRQ information of specific IR index */
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|3273| <<vtd_interrupt_remap_msi>> ret = vtd_remap_irq_get(iommu, index, &irq, sid);
+ */
 static int vtd_remap_irq_get(IntelIOMMUState *iommu, uint16_t index,
                              X86IOMMUIrq *irq, uint16_t sid)
 {
@@ -3222,6 +3262,11 @@ static int vtd_remap_irq_get(IntelIOMMUState *iommu, uint16_t index,
 }
 
 /* Interrupt remapping for MSI/MSI-X entry */
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|3324| <<vtd_int_remap>> return vtd_interrupt_remap_msi(INTEL_IOMMU_DEVICE(iommu),
+ *   - hw/i386/intel_iommu.c|3351| <<vtd_mem_ir_write>> ret = vtd_interrupt_remap_msi(opaque, &from, &to, sid);
+ */
 static int vtd_interrupt_remap_msi(IntelIOMMUState *iommu,
                                    MSIMessage *origin,
                                    MSIMessage *translated,
@@ -3318,6 +3363,10 @@ out:
     return 0;
 }
 
+/*
+ * 在以下使用vtd_int_remap():
+ *   - hw/i386/intel_iommu.c|3863| <<vtd_class_init>> x86_class->int_remap = vtd_int_remap;
+ */
 static int vtd_int_remap(X86IOMMUState *iommu, MSIMessage *src,
                          MSIMessage *dst, uint16_t sid)
 {
diff --git a/hw/i386/kvm/clock.c b/hw/i386/kvm/clock.c
index 51872dd84..ab3821590 100644
--- a/hw/i386/kvm/clock.c
+++ b/hw/i386/kvm/clock.c
@@ -50,6 +50,13 @@ struct KVMClockState {
 
     /* whether the 'clock' value was obtained in a host with
      * reliable KVM_GET_CLOCK */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|250| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|153| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|180| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|263| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     bool clock_is_reliable;
 };
 
@@ -64,6 +71,10 @@ struct pvclock_vcpu_time_info {
     uint8_t    pad[2];
 } __attribute__((__packed__)); /* 32 bytes */
 
+/*
+ * called by:
+ *   - hw/i386/kvm/clock.c|202| <<kvmclock_vm_state_change>> uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
+ */
 static uint64_t kvmclock_current_nsec(KVMClockState *s)
 {
     CPUState *cpu = first_cpu;
@@ -150,6 +161,13 @@ static void kvm_update_clock(KVMClockState *s)
      *       if !kvm_has_adjust_clock_stable() then
      *               read from memory
      */
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|250| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|153| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|180| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|263| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     s->clock_is_reliable = kvm_has_adjust_clock_stable();
 }
 
@@ -162,6 +180,16 @@ static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
     }
 }
 
+/*
+ * 启动执行
+ * kvmclock_vm_state_change() running=1
+ *
+ * 然后
+ * (qemu) stop
+ * kvmclock_vm_state_change() running=0
+ * (qemu) cont
+ * kvmclock_vm_state_change() running=1
+ */
 static void kvmclock_vm_state_change(void *opaque, bool running,
                                      RunState state)
 {
@@ -177,6 +205,13 @@ static void kvmclock_vm_state_change(void *opaque, bool running,
          * If the host where s->clock was read did not support reliable
          * KVM_GET_CLOCK, read kvmclock value from memory.
          */
+	/*
+	 * 在以下使用KVMClockState->clock_is_reliable:
+	 *   - hw/i386/kvm/clock.c|250| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+	 *   - hw/i386/kvm/clock.c|153| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+	 *   - hw/i386/kvm/clock.c|180| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+	 *   - hw/i386/kvm/clock.c|263| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+	 */
         if (!s->clock_is_reliable) {
             uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
             /* We can't rely on the saved clock value, just discard it */
@@ -260,6 +295,13 @@ static int kvmclock_pre_load(void *opaque)
 {
     KVMClockState *s = opaque;
 
+    /*
+     * 在以下使用KVMClockState->clock_is_reliable:
+     *   - hw/i386/kvm/clock.c|250| <<global>> VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+     *   - hw/i386/kvm/clock.c|153| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+     *   - hw/i386/kvm/clock.c|180| <<kvmclock_vm_state_change>> if (!s->clock_is_reliable) {
+     *   - hw/i386/kvm/clock.c|263| <<kvmclock_pre_load>> s->clock_is_reliable = false;
+     */
     s->clock_is_reliable = false;
 
     return 0;
@@ -329,6 +371,12 @@ static const TypeInfo kvmclock_info = {
 };
 
 /* Note: Must be called after VCPU initialization. */
+/*
+ * called by:
+ *   - hw/i386/microvm.c|184| <<microvm_devices_init>> kvmclock_create(true);
+ *   - hw/i386/pc_piix.c|162| <<pc_init1>> kvmclock_create(pcmc->kvmclock_create_always);
+ *   - hw/i386/pc_q35.c|182| <<pc_q35_init>> kvmclock_create(pcmc->kvmclock_create_always);
+ */
 void kvmclock_create(bool create_always)
 {
     X86CPU *cpu = X86_CPU(first_cpu);
diff --git a/hw/i386/x86-iommu.c b/hw/i386/x86-iommu.c
index 5f4301639..11719b888 100644
--- a/hw/i386/x86-iommu.c
+++ b/hw/i386/x86-iommu.c
@@ -94,6 +94,21 @@ static void x86_iommu_set_default(X86IOMMUState *x86_iommu)
     x86_iommu_default = x86_iommu;
 }
 
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|2005| <<build_dmar_q35>> X86IOMMUState *iommu = x86_iommu_get_default();
+ *   - hw/i386/acpi-build.c|2182| <<build_amd_iommu>> AMDVIState *s = AMD_IOMMU_DEVICE(x86_iommu_get_default());
+ *   - hw/i386/acpi-build.c|2229| <<build_amd_iommu>> if (x86_iommu_ir_supported(x86_iommu_get_default())) {
+ *   - hw/i386/acpi-build.c|2264| <<build_amd_iommu>> if (x86_iommu_ir_supported(x86_iommu_get_default())) {
+ *   - hw/i386/acpi-build.c|2433| <<acpi_build>> if (x86_iommu_get_default()) {
+ *   - hw/i386/intel_iommu.c|3825| <<vtd_machine_done_notify_one>> IntelIOMMUState *iommu = INTEL_IOMMU_DEVICE(x86_iommu_get_default());
+ *   - hw/i386/pc.c|1666| <<pc_hotplug_allowed>> X86IOMMUState *iommu = x86_iommu_get_default();
+ *   - hw/i386/x86-iommu-stub.c|30| <<x86_iommu_get_default>> X86IOMMUState *x86_iommu_get_default(void )
+ *   - hw/intc/ioapic.c|437| <<ioapic_machine_done_notify>> X86IOMMUState *iommu = x86_iommu_get_default();
+ *   - include/hw/i386/x86-iommu.h|141| <<OBJECT_DECLARE_TYPE>> X86IOMMUState *x86_iommu_get_default(void );
+ *   - target/i386/kvm/kvm.c|4697| <<kvm_arch_fixup_msi_route>> X86IOMMUState *iommu = x86_iommu_get_default();
+ *   - target/i386/kvm/kvm.c|4820| <<kvm_arch_add_msi_route_post>> X86IOMMUState *iommu = x86_iommu_get_default();
+ */
 X86IOMMUState *x86_iommu_get_default(void)
 {
     return x86_iommu_default;
@@ -156,6 +171,17 @@ static void x86_iommu_class_init(ObjectClass *klass, void *data)
     device_class_set_props(dc, x86_iommu_properties);
 }
 
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|2012| <<build_dmar_q35>> if (x86_iommu_ir_supported(iommu)) {
+ *   - hw/i386/acpi-build.c|2229| <<build_amd_iommu>> if (x86_iommu_ir_supported(x86_iommu_get_default())) {
+ *   - hw/i386/acpi-build.c|2264| <<build_amd_iommu>> if (x86_iommu_ir_supported(x86_iommu_get_default())) {
+ *   - hw/i386/amd_iommu.c|1239| <<amdvi_int_remap_msi>> if (!x86_iommu_ir_supported(X86_IOMMU_DEVICE(iommu))) {
+ *   - hw/i386/intel_iommu.c|3679| <<vtd_init>> if (x86_iommu_ir_supported(x86_iommu)) {
+ *   - hw/i386/intel_iommu.c|3785| <<vtd_decide_config>> if (s->intr_eim == ON_OFF_AUTO_ON && !x86_iommu_ir_supported(x86_iommu)) {
+ *   - hw/i386/intel_iommu.c|3792| <<vtd_decide_config>> && x86_iommu_ir_supported(x86_iommu) ?
+ *   - hw/i386/x86-iommu.c|146| <<x86_iommu_realize>> if (x86_iommu_ir_supported(x86_iommu) && irq_all_kernel) {
+ */
 bool x86_iommu_ir_supported(X86IOMMUState *s)
 {
     return s->intr_supported == ON_OFF_AUTO_ON;
diff --git a/hw/misc/pvpanic.c b/hw/misc/pvpanic.c
index e2cb4a5d2..f211a0d57 100644
--- a/hw/misc/pvpanic.c
+++ b/hw/misc/pvpanic.c
@@ -22,6 +22,10 @@
 #include "hw/misc/pvpanic.h"
 #include "qom/object.h"
 
+/*
+ * called by:
+ *   - hw/misc/pvpanic.c|55| <<pvpanic_write>> handle_event(val);
+ */
 static void handle_event(int event)
 {
     static bool logged;
@@ -64,6 +68,11 @@ static const MemoryRegionOps pvpanic_ops = {
     },
 };
 
+/*
+ * called by:
+ *   - hw/misc/pvpanic-isa.c|43| <<pvpanic_isa_initfn>> pvpanic_setup_io(&s->pvpanic, DEVICE(s), 1);
+ *   - hw/misc/pvpanic-pci.c|51| <<pvpanic_pci_realizefn>> pvpanic_setup_io(&s->pvpanic, DEVICE(s), 2);
+ */
 void pvpanic_setup_io(PVPanicState *s, DeviceState *dev, unsigned size)
 {
     memory_region_init_io(&s->mr, OBJECT(dev), &pvpanic_ops, s, "pvpanic", size);
diff --git a/hw/pci/msi.c b/hw/pci/msi.c
index 47d2b0f33..53ffe9b43 100644
--- a/hw/pci/msi.c
+++ b/hw/pci/msi.c
@@ -337,6 +337,9 @@ void msi_send_message(PCIDevice *dev, MSIMessage msg)
     MemTxAttrs attrs = {};
 
     attrs.requester_id = pci_requester_id(dev);
+    /*
+     * kvm_apic_mem_write()
+     */
     address_space_stl_le(&dev->bus_master_as, msg.address, msg.data,
                          attrs, NULL);
 }
diff --git a/hw/pci/msix.c b/hw/pci/msix.c
index ae9331cd0..af04729f4 100644
--- a/hw/pci/msix.c
+++ b/hw/pci/msix.c
@@ -110,6 +110,18 @@ static void msix_fire_vector_notifier(PCIDevice *dev,
         dev->msix_vector_release_notifier(dev, vector);
     } else {
         msg = msix_get_message(dev, vector);
+        /*
+	 * 在以下设置PCIDevie->msix_vector_use_notifier:
+         *   - hw/pci/msix.c|597| <<msix_set_vector_notifiers>> dev->msix_vector_use_notifier = use_notifier;
+         *   - hw/pci/msix.c|619| <<msix_set_vector_notifiers>> dev->msix_vector_use_notifier = NULL;
+         *   - hw/pci/msix.c|637| <<msix_unset_vector_notifiers>> dev->msix_vector_use_notifier = NULL;
+         * 在以下使用PCIDevie->msix_vector_use_notifier:
+         *   - hw/misc/ivshmem.c|795| <<ivshmem_disable_irqfd>> if (!pdev->msix_vector_use_notifier) {
+         *   - hw/pci/msix.c|106| <<msix_fire_vector_notifier>> if (!dev->msix_vector_use_notifier) {
+         *   - hw/pci/msix.c|113| <<msix_fire_vector_notifier>> ret = dev->msix_vector_use_notifier(dev, vector, msg);
+         *   - hw/pci/msix.c|571| <<msix_set_notifier_for_vector>> return dev->msix_vector_use_notifier(dev, vector, msg);
+         *   - hw/pci/msix.c|628| <<msix_unset_vector_notifiers>> assert(dev->msix_vector_use_notifier &&
+	 */
         ret = dev->msix_vector_use_notifier(dev, vector, msg);
         assert(ret >= 0);
     }
@@ -136,6 +148,11 @@ static bool msix_masked(PCIDevice *dev)
     return dev->config[dev->msix_cap + MSIX_CONTROL_OFFSET] & MSIX_MASKALL_MASK;
 }
 
+/*
+ * called by:
+ *   - hw/pci/msix.c|171| <<msix_write_config>> msix_update_function_masked(dev);
+ *   - hw/pci/msix.c|483| <<msix_load>> msix_update_function_masked(dev);
+ */
 static void msix_update_function_masked(PCIDevice *dev)
 {
     dev->msix_function_masked = !msix_enabled(dev) || msix_masked(dev);
@@ -451,6 +468,11 @@ void msix_save(PCIDevice *dev, QEMUFile *f)
 }
 
 /* Should be called after restoring the config space. */
+/*
+ * called by:
+ *   - hw/pci/msix.c|665| <<get_msix_state>> msix_load(pv, f);
+ *   - hw/virtio/virtio-pci.c|184| <<virtio_pci_load_config>> msix_load(&proxy->pci_dev, f);
+ */
 void msix_load(PCIDevice *dev, QEMUFile *f)
 {
     unsigned n = dev->msix_entries_nr;
@@ -579,6 +601,15 @@ static void msix_unset_notifier_for_vector(PCIDevice *dev, unsigned int vector)
     dev->msix_vector_release_notifier(dev, vector);
 }
 
+/*
+ * called by:
+ *   - hw/misc/ivshmem.c|775| <<ivshmem_enable_irqfd>> if (msix_set_vector_notifiers(pdev,
+ *   - hw/vfio/pci.c|608| <<vfio_msix_enable>> if (msix_set_vector_notifiers(pdev, vfio_msix_vector_use,
+ *   - hw/virtio/virtio-pci.c|1025| <<virtio_pci_set_guest_notifiers>> r = msix_set_vector_notifiers(&proxy->pci_dev,
+ *                                         virtio_pci_vector_unmask,
+ *                                         virtio_pci_vector_mask,
+ *                                         virtio_pci_vector_poll);
+ */
 int msix_set_vector_notifiers(PCIDevice *dev,
                               MSIVectorUseNotifier use_notifier,
                               MSIVectorReleaseNotifier release_notifier,
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index 8f35e13a0..39510ed71 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -476,6 +476,16 @@ void pci_root_bus_cleanup(PCIBus *bus)
     qbus_unrealize(BUS(bus));
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_q35.c|248| <<pc_q35_init>> pci_bus_irqs(host_bus, ich9_lpc_set_irq, ich9_lpc_map_irq, ich9_lpc,
+ *   - hw/isa/piix3.c|383| <<piix3_create>> pci_bus_irqs(pci_bus, xen_piix3_set_irq, xen_pci_slot_get_pirq,
+ *   - hw/isa/piix3.c|389| <<piix3_create>> pci_bus_irqs(pci_bus, piix3_set_irq, pci_slot_get_pirq,
+ *   - hw/pci-host/prep.c|261| <<raven_pcihost_realizefn>> pci_bus_irqs(&s->pci_bus, raven_set_irq, raven_map_irq, s, PCI_NUM_PINS);
+ *   - hw/pci-host/versatile.c|425| <<pci_vpb_realize>> pci_bus_irqs(&s->pci_bus, pci_vpb_set_irq, mapfn, s->irq, 4);
+ *   - hw/pci/pci.c|510| <<pci_register_root_bus>> pci_bus_irqs(bus, set_irq, map_irq, irq_opaque, nirq);
+ *   - hw/remote/machine.c|56| <<remote_machine_init>> pci_bus_irqs(pci_host->bus, remote_iohub_set_irq, remote_iohub_map_irq,
+ */
 void pci_bus_irqs(PCIBus *bus, pci_set_irq_fn set_irq, pci_map_irq_fn map_irq,
                   void *irq_opaque, int nirq)
 {
@@ -1846,6 +1856,10 @@ static PciInfo *qmp_query_pci_bus(PCIBus *bus, int bus_num)
     return info;
 }
 
+/*
+ * called by:
+ *   - monitor/hmp-cmds.c|884| <<hmp_info_pci>> info_list = qmp_query_pci(&err);
+ */
 PciInfoList *qmp_query_pci(Error **errp)
 {
     PciInfoList *head = NULL, **tail = &head;
@@ -2674,6 +2688,12 @@ static void pci_device_class_base_init(ObjectClass *klass, void *data)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|101| <<pci_init_bus_master>> AddressSpace *dma_as = pci_device_iommu_address_space(pci_dev);
+ *   - hw/vfio/pci.c|2838| <<vfio_realize>> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
+ *   - target/arm/kvm.c|997| <<kvm_arch_fixup_msi_route>> AddressSpace *as = pci_device_iommu_address_space(dev);
+ */
 AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
 {
     PCIBus *bus = pci_get_bus(dev);
@@ -2819,6 +2839,9 @@ MSIMessage pci_get_msi_message(PCIDevice *dev, int vector)
 {
     MSIMessage msg;
     if (msix_enabled(dev)) {
+        /*
+	 * 从PCIDevice->msix_table[]获取msix message
+	 */
         msg = msix_get_message(dev, vector);
     } else if (msi_enabled(dev)) {
         msg = msi_get_message(dev, vector);
diff --git a/hw/remote/iohub.c b/hw/remote/iohub.c
index e4ff131a6..070d5b9ce 100644
--- a/hw/remote/iohub.c
+++ b/hw/remote/iohub.c
@@ -53,6 +53,10 @@ int remote_iohub_map_irq(PCIDevice *pci_dev, int intx)
     return pci_dev->devfn;
 }
 
+/*
+ * 在以下使用remote_iohub_set_irq():
+ *   - hw/remote/machine.c|56| <<remote_machine_init>> pci_bus_irqs(pci_host->bus, remote_iohub_set_irq, remote_iohub_map_irq,
+ */
 void remote_iohub_set_irq(void *opaque, int pirq, int level)
 {
     RemoteIOHubState *iohub = opaque;
@@ -90,6 +94,10 @@ static void intr_resample_handler(void *opaque)
     }
 }
 
+/*
+ * 处理MPQEMU_CMD_SET_IRQFD:
+ *   - hw/remote/message.c|77| <<mpqemu_remote_msg_loop_co>> process_set_irqfd_msg(pci_dev, &msg);
+ */
 void process_set_irqfd_msg(PCIDevice *pci_dev, MPQemuMsg *msg)
 {
     RemoteMachineState *machine = REMOTE_MACHINE(current_machine);
diff --git a/hw/remote/machine.c b/hw/remote/machine.c
index c0ab4f528..1ba882b9d 100644
--- a/hw/remote/machine.c
+++ b/hw/remote/machine.c
@@ -53,6 +53,16 @@ static void remote_machine_init(MachineState *machine)
 
     remote_iohub_init(&s->iohub);
 
+    /*
+     * called by:
+     *   - hw/i386/pc_q35.c|248| <<pc_q35_init>> pci_bus_irqs(host_bus, ich9_lpc_set_irq, ich9_lpc_map_irq, ich9_lpc,
+     *   - hw/isa/piix3.c|383| <<piix3_create>> pci_bus_irqs(pci_bus, xen_piix3_set_irq, xen_pci_slot_get_pirq,
+     *   - hw/isa/piix3.c|389| <<piix3_create>> pci_bus_irqs(pci_bus, piix3_set_irq, pci_slot_get_pirq,
+     *   - hw/pci-host/prep.c|261| <<raven_pcihost_realizefn>> pci_bus_irqs(&s->pci_bus, raven_set_irq, raven_map_irq, s, PCI_NUM_PINS);
+     *   - hw/pci-host/versatile.c|425| <<pci_vpb_realize>> pci_bus_irqs(&s->pci_bus, pci_vpb_set_irq, mapfn, s->irq, 4);
+     *   - hw/pci/pci.c|510| <<pci_register_root_bus>> pci_bus_irqs(bus, set_irq, map_irq, irq_opaque, nirq);
+     *   - hw/remote/machine.c|56| <<remote_machine_init>> pci_bus_irqs(pci_host->bus, remote_iohub_set_irq, remote_iohub_map_irq,
+     */
     pci_bus_irqs(pci_host->bus, remote_iohub_set_irq, remote_iohub_map_irq,
                  &s->iohub, REMOTE_IOHUB_NB_PIRQS);
 }
@@ -65,6 +75,9 @@ static void remote_machine_class_init(ObjectClass *oc, void *data)
     mc->desc = "Experimental remote machine";
 }
 
+/*
+ * TYPE_REMOTE_MACHINE应该直接由qemu cmdline调用吧
+ */
 static const TypeInfo remote_machine = {
     .name = TYPE_REMOTE_MACHINE,
     .parent = TYPE_MACHINE,
diff --git a/hw/remote/memory.c b/hw/remote/memory.c
index 32085b1e0..0547cfb4c 100644
--- a/hw/remote/memory.c
+++ b/hw/remote/memory.c
@@ -16,6 +16,11 @@
 #include "exec/ram_addr.h"
 #include "qapi/error.h"
 
+/*
+ * called by:
+ *   - hw/remote/memory.c|43| <<remote_sysmem_reconfig>> remote_sysmem_reset();
+ *   - hw/remote/memory.c|57| <<remote_sysmem_reconfig>> remote_sysmem_reset();
+ */
 static void remote_sysmem_reset(void)
 {
     MemoryRegion *sysmem, *subregion, *next;
@@ -30,6 +35,10 @@ static void remote_sysmem_reset(void)
     }
 }
 
+/*
+ * 处理MPQEMU_CMD_SYNC_SYSMEM:
+ *   - hw/remote/message.c|74| <<mpqemu_remote_msg_loop_co>> remote_sysmem_reconfig(&msg, &local_err);
+ */
 void remote_sysmem_reconfig(MPQemuMsg *msg, Error **errp)
 {
     ERRP_GUARD();
diff --git a/hw/remote/message.c b/hw/remote/message.c
index 11d729845..0b11cf121 100644
--- a/hw/remote/message.c
+++ b/hw/remote/message.c
@@ -30,6 +30,10 @@ static void process_bar_read(QIOChannel *ioc, MPQemuMsg *msg, Error **errp);
 static void process_device_reset_msg(QIOChannel *ioc, PCIDevice *dev,
                                      Error **errp);
 
+/*
+ * 在以下使用mpqemu_remote_msg_loop_co():
+ *   - hw/remote/remote-obj.c|125| <<remote_object_machine_done>> co = qemu_coroutine_create(mpqemu_remote_msg_loop_co, comdev);
+ */
 void coroutine_fn mpqemu_remote_msg_loop_co(void *data)
 {
     g_autofree RemoteCommDev *com = (RemoteCommDev *)data;
@@ -70,6 +74,12 @@ void coroutine_fn mpqemu_remote_msg_loop_co(void *data)
             remote_sysmem_reconfig(&msg, &local_err);
             break;
         case MPQEMU_CMD_SET_IRQFD:
+	    /*
+	     * 在以下使用MPQEMU_CMD_SET_IRQFD:
+	     *   - hw/remote/message.c|76| <<mpqemu_remote_msg_loop_co>> case MPQEMU_CMD_SET_IRQFD:
+	     *   - hw/remote/mpqemu-link.c|257| <<mpqemu_msg_valid>> case MPQEMU_CMD_SET_IRQFD:
+	     *   - hw/remote/proxy.c|62| <<setup_irqfd>> msg.cmd = MPQEMU_CMD_SET_IRQFD;
+	     */
             process_set_irqfd_msg(pci_dev, &msg);
             break;
         case MPQEMU_CMD_DEVICE_RESET:
@@ -213,6 +223,10 @@ fail:
     }
 }
 
+/*
+ * 处理MPQEMU_CMD_DEVICE_RESET:
+ *   - hw/remote/message.c|76| <<mpqemu_remote_msg_loop_co>> process_device_reset_msg(com->ioc, pci_dev, &local_err);
+ */
 static void process_device_reset_msg(QIOChannel *ioc, PCIDevice *dev,
                                      Error **errp)
 {
diff --git a/hw/remote/mpqemu-link.c b/hw/remote/mpqemu-link.c
index 9ce31526e..a2212b6b9 100644
--- a/hw/remote/mpqemu-link.c
+++ b/hw/remote/mpqemu-link.c
@@ -32,6 +32,17 @@
  *   will block IOThread;
  * Returns true if no errors were encountered, false otherwise.
  */
+/*
+ * called by:
+ *   - hw/remote/message.c|122| <<process_config_write>> if (!mpqemu_msg_send(&ret, ioc, NULL)) {
+ *   - hw/remote/message.c|146| <<process_config_read>> if (!mpqemu_msg_send(&ret, ioc, NULL)) {
+ *   - hw/remote/message.c|183| <<process_bar_write>> if (!mpqemu_msg_send(&ret, ioc, NULL)) {
+ *   - hw/remote/message.c|220| <<process_bar_read>> if (!mpqemu_msg_send(&ret, ioc, NULL)) {
+ *   - hw/remote/message.c|243| <<process_device_reset_msg>> mpqemu_msg_send(&ret, ioc, errp);
+ *   - hw/remote/mpqemu-link.c|202| <<mpqemu_msg_send_and_await_reply>> if (!mpqemu_msg_send(msg, pdev->ioc, errp)) {
+ *   - hw/remote/proxy-memory-listener.c|218| <<proxy_memory_listener_commit>> if (!mpqemu_msg_send(&msg, proxy_listener->ioc, &local_err)) {
+ *   - hw/remote/proxy.c|73| <<setup_irqfd>> if (!mpqemu_msg_send(&msg, dev->ioc, &local_err)) {
+ */
 bool mpqemu_msg_send(MPQemuMsg *msg, QIOChannel *ioc, Error **errp)
 {
     ERRP_GUARD();
@@ -94,6 +105,11 @@ bool mpqemu_msg_send(MPQemuMsg *msg, QIOChannel *ioc, Error **errp)
  * - From IOThread within co-routine context, outside of co-routine context
  *   will block IOThread;
  */
+/*
+ * called by:
+ *   - hw/remote/mpqemu-link.c|133| <<mpqemu_msg_recv>> len = mpqemu_read(ioc, msg, MPQEMU_MSG_HDR_SIZE, &fds, &nfds, errp);
+ *   - hw/remote/mpqemu-link.c|150| <<mpqemu_msg_recv>> len = mpqemu_read(ioc, &msg->data, msg->size, NULL, NULL, errp);
+ */
 static ssize_t mpqemu_read(QIOChannel *ioc, void *buf, size_t len, int **fds,
                            size_t *nfds, Error **errp)
 {
@@ -122,6 +138,11 @@ static ssize_t mpqemu_read(QIOChannel *ioc, void *buf, size_t len, int **fds,
     return (ret <= 0) ? ret : iov.iov_len;
 }
 
+/*
+ * called by:
+ *   - hw/remote/message.c|49| <<mpqemu_remote_msg_loop_co>> if (!mpqemu_msg_recv(&msg, com->ioc, &local_err)) {
+ *   - hw/remote/mpqemu-link.c|206| <<mpqemu_msg_send_and_await_reply>> if (!mpqemu_msg_recv(&msg_reply, pdev->ioc, errp)) {
+ */
 bool mpqemu_msg_recv(MPQemuMsg *msg, QIOChannel *ioc, Error **errp)
 {
     ERRP_GUARD();
@@ -189,6 +210,12 @@ fail:
  * Called from VCPU thread in non-coroutine context.
  * Used by the Proxy object to communicate to remote processes.
  */
+/*
+ * called by:
+ *   - hw/remote/proxy.c|194| <<config_op_send>> ret = mpqemu_msg_send_and_await_reply(&msg, pdev, &local_err);
+ *   - hw/remote/proxy.c|292| <<send_bar_access_msg>> ret = mpqemu_msg_send_and_await_reply(&msg, pdev, &local_err);
+ *   - hw/remote/proxy.c|421| <<proxy_device_reset>> mpqemu_msg_send_and_await_reply(&msg, pdev, &local_err);
+ */
 uint64_t mpqemu_msg_send_and_await_reply(MPQemuMsg *msg, PCIProxyDev *pdev,
                                          Error **errp)
 {
@@ -216,6 +243,11 @@ uint64_t mpqemu_msg_send_and_await_reply(MPQemuMsg *msg, PCIProxyDev *pdev,
     return msg_reply.data.u64;
 }
 
+/*
+ * called by:
+ *   - hw/remote/message.c|53| <<mpqemu_remote_msg_loop_co>> if (!mpqemu_msg_valid(&msg)) {
+ *   - hw/remote/mpqemu-link.c|210| <<mpqemu_msg_send_and_await_reply>> if (!mpqemu_msg_valid(&msg_reply) || msg_reply.cmd != MPQEMU_CMD_RET) {
+ */
 bool mpqemu_msg_valid(MPQemuMsg *msg)
 {
     if (msg->cmd >= MPQEMU_CMD_MAX && msg->cmd < 0) {
diff --git a/hw/remote/proxy-memory-listener.c b/hw/remote/proxy-memory-listener.c
index af1fa6f5a..ebc4c7a39 100644
--- a/hw/remote/proxy-memory-listener.c
+++ b/hw/remote/proxy-memory-listener.c
@@ -29,6 +29,11 @@
  *
  */
 
+/*
+ * called by:
+ *   - hw/remote/proxy-memory-listener.c|222| <<proxy_memory_listener_deconfigure>> proxy_memory_listener_reset(&proxy_listener->listener);
+ *   - hw/remote/proxy-memory-listener.c|237| <<proxy_memory_listener_configure>> proxy_listener->listener.begin = proxy_memory_listener_reset;
+ */
 static void proxy_memory_listener_reset(MemoryListener *listener)
 {
     ProxyMemoryListener *proxy_listener = container_of(listener,
@@ -45,6 +50,13 @@ static void proxy_memory_listener_reset(MemoryListener *listener)
     proxy_listener->n_mr_sections = 0;
 }
 
+/*
+ * called by:
+ *   - hw/remote/proxy-memory-listener.c|75| <<proxy_mrs_can_merge>> if (get_fd_from_hostaddr(host, NULL) !=
+ *   - hw/remote/proxy-memory-listener.c|76| <<proxy_mrs_can_merge>> get_fd_from_hostaddr(prev_host, NULL)) {
+ *   - hw/remote/proxy-memory-listener.c|103| <<try_merge>> if (get_fd_from_hostaddr(mrs_host, NULL) < 0) {
+ *   - hw/remote/proxy-memory-listener.c|196| <<proxy_memory_listener_commit>> msg.fds[region] = get_fd_from_hostaddr(host_addr, &offset);
+ */
 static int get_fd_from_hostaddr(uint64_t host, ram_addr_t *offset)
 {
     MemoryRegion *mr;
@@ -187,6 +199,13 @@ static void proxy_memory_listener_commit(MemoryListener *listener)
     }
 
     for (region = 0; region < proxy_listener->n_mr_sections; region++) {
+        /*
+	 * ProxyMemoryListener *proxy_listener:
+	 * -> MemoryListener listener;
+	 * -> int n_mr_sections;
+	 * -> MemoryRegionSection *mr_sections;
+	 * -> QIOChannel *ioc;
+	 */
         section = &proxy_listener->mr_sections[region];
         msg.data.sync_sysmem.gpas[region] =
             section->offset_within_address_space;
@@ -201,6 +220,10 @@ static void proxy_memory_listener_commit(MemoryListener *listener)
     }
 }
 
+/*
+ * called by:
+ *   - hw/remote/proxy.c|162| <<pci_proxy_dev_exit>> proxy_memory_listener_deconfigure(&dev->proxy_listener);
+ */
 void proxy_memory_listener_deconfigure(ProxyMemoryListener *proxy_listener)
 {
     memory_listener_unregister(&proxy_listener->listener);
@@ -208,6 +231,10 @@ void proxy_memory_listener_deconfigure(ProxyMemoryListener *proxy_listener)
     proxy_memory_listener_reset(&proxy_listener->listener);
 }
 
+/*
+ * called by:
+ *   - hw/remote/proxy.c|116| <<pci_proxy_dev_realize>> proxy_memory_listener_configure(&dev->proxy_listener, dev->ioc);
+ */
 void proxy_memory_listener_configure(ProxyMemoryListener *proxy_listener,
                                      QIOChannel *ioc)
 {
diff --git a/hw/remote/proxy.c b/hw/remote/proxy.c
index 4fa4be079..214fb63e3 100644
--- a/hw/remote/proxy.c
+++ b/hw/remote/proxy.c
@@ -28,6 +28,11 @@
 static void probe_pci_info(PCIDevice *dev, Error **errp);
 static void proxy_device_reset(DeviceState *dev);
 
+/*
+ * 在以下使用proxy_intx_update():
+ *   - hw/remote/proxy.c|74| <<setup_irqfd>> proxy_intx_update(pci_dev);
+ *   - hw/remote/proxy.c|76| <<setup_irqfd>> pci_device_set_intx_routing_notifier(pci_dev, proxy_intx_update);
+ */
 static void proxy_intx_update(PCIDevice *pci_dev)
 {
     PCIProxyDev *dev = PCI_PROXY_DEV(pci_dev);
@@ -101,6 +106,28 @@ static void pci_proxy_dev_realize(PCIDevice *device, Error **errp)
         return;
     }
 
+    /*
+     * qio_channel_new_fd:
+     * @fd: the file descriptor
+     * @errp: pointer to a NULL-initialized error object
+     *
+     * Create a channel for performing I/O on the file
+     * descriptor @fd. The particular subclass of QIOChannel
+     * that is returned will depend on what underlying object
+     * the file descriptor is associated with. It may be either
+     * a QIOChannelSocket or a QIOChannelFile instance. Upon
+     * success, the returned QIOChannel instance will own
+     * the @fd file descriptor, and take responsibility for
+     * closing it when no longer required. On failure, the
+     * caller is responsible for closing @fd.
+     *
+     * Returns: the channel object, or NULL on error
+     *
+     *
+     * PCIProxyDev *dev:
+     * -> QIOChannel *ioc;
+     * -> ProxyMemoryListener proxy_listener;
+     */
     dev->ioc = qio_channel_new_fd(fd, errp);
 
     error_setg(&dev->migration_blocker, "%s does not support migration",
@@ -138,6 +165,19 @@ static void pci_proxy_dev_exit(PCIDevice *pdev)
     event_notifier_cleanup(&dev->resample);
 }
 
+/*
+ * called by:
+ *   - hw/remote/proxy.c|173| <<pci_proxy_read_config>> config_op_send(PCI_PROXY_DEV(d), addr, &val, len, MPQEMU_CMD_PCI_CFGREAD);
+ *   - hw/remote/proxy.c|188| <<pci_proxy_write_config>> config_op_send(PCI_PROXY_DEV(d), addr, &val, len, MPQEMU_CMD_PCI_CFGWRITE);
+ *   - hw/remote/proxy.c|298| <<probe_pci_info>> config_op_send(pdev, PCI_VENDOR_ID, &val, 2, MPQEMU_CMD_PCI_CFGREAD);
+ *   - hw/remote/proxy.c|301| <<probe_pci_info>> config_op_send(pdev, PCI_DEVICE_ID, &val, 2, MPQEMU_CMD_PCI_CFGREAD);
+ *   - hw/remote/proxy.c|304| <<probe_pci_info>> config_op_send(pdev, PCI_CLASS_DEVICE, &val, 2, MPQEMU_CMD_PCI_CFGREAD);
+ *   - hw/remote/proxy.c|307| <<probe_pci_info>> config_op_send(pdev, PCI_SUBSYSTEM_ID, &val, 2, MPQEMU_CMD_PCI_CFGREAD);
+ *   - hw/remote/proxy.c|336| <<probe_pci_info>> config_op_send(pdev, PCI_BASE_ADDRESS_0 + (4 * i), &orig_val, 4,
+ *   - hw/remote/proxy.c|339| <<probe_pci_info>> config_op_send(pdev, PCI_BASE_ADDRESS_0 + (4 * i), &new_val, 4,
+ *   - hw/remote/proxy.c|341| <<probe_pci_info>> config_op_send(pdev, PCI_BASE_ADDRESS_0 + (4 * i), &new_val, 4,
+ *   - hw/remote/proxy.c|344| <<probe_pci_info>> config_op_send(pdev, PCI_BASE_ADDRESS_0 + (4 * i), &orig_val, 4,
+ */
 static void config_op_send(PCIProxyDev *pdev, uint32_t addr, uint32_t *val,
                            int len, unsigned int op)
 {
@@ -208,6 +248,9 @@ static void pci_proxy_dev_class_init(ObjectClass *klass, void *data)
     device_class_set_props(dc, proxy_properties);
 }
 
+/*
+ * qemu command line用的, main VM的
+ */
 static const TypeInfo pci_proxy_dev_type_info = {
     .name          = TYPE_PCI_PROXY_DEV,
     .parent        = TYPE_PCI_DEVICE,
@@ -276,6 +319,10 @@ static uint64_t proxy_bar_read(void *opaque, hwaddr addr, unsigned size)
     return val;
 }
 
+/*
+ * 在以下使用proxy_mr_ops:
+ *   - hw/remote/proxy.c|374| <<probe_pci_info>> &proxy_mr_ops, &pdev->region[i],
+ */
 const MemoryRegionOps proxy_mr_ops = {
     .read = proxy_bar_read,
     .write = proxy_bar_write,
diff --git a/hw/remote/remote-obj.c b/hw/remote/remote-obj.c
index 4f2125421..4ba760505 100644
--- a/hw/remote/remote-obj.c
+++ b/hw/remote/remote-obj.c
@@ -49,6 +49,19 @@ struct RemoteObject {
     DeviceListener listener;
 };
 
+/*
+ * (gdb) bt
+ * #0  0x00005555558ccdd4 in remote_object_set_fd (obj=0x555556b68fe0, str=0x555556b6a200 "10", errp=0x7fffffffdd18) at ../hw/remote/remote-obj.c:70
+ * #1  0x0000555555d13ff4 in property_set_str (obj=0x555556b68fe0, v= 0x555556b6a340, name=0x555556b6a290 "fd", opaque=0x555556ad1fe0, errp=0x7fffffffdd18) at ../qom/object.c:2180
+ * #2  0x0000555555d12385 in object_property_set (obj=0x555556b68fe0, name=0x555556b6a290 "fd", v=0x555556b6a340, errp=0x7fffffffdd70) at ../qom/object.c:1402
+ * #3  0x0000555555d159e9 in user_creatable_add_type (type=0x5555562b883c "x-remote-object", id=0x55555696ad90 "robj1", qdict=0x555556b690c0, v=0x555556b6a340, errp=0x7fffffffdd90)
+ *                        at ../qom/object_interfaces.c:85
+ * #4  0x0000555555d15c52 in user_creatable_add_qapi (options=0x55555696aae0, errp=0x5555568dfef8 <error_fatal>) at ../qom/object_interfaces.c:137
+ * #5  0x0000555555ccd908 in object_option_foreach_add (type_opt_predicate=0x555555ccdb80 <object_create_early>) at ../softmmu/vl.c:1702
+ * #6  0x0000555555ccdfc8 in qemu_create_early_backends () at ../softmmu/vl.c:1874
+ * #7  0x0000555555cd1df7 in qemu_init (argc=9, argv=0x7fffffffe0e8, envp=0x7fffffffe138) at ../softmmu/vl.c:3550
+ * #8  0x000055555581966d in main (argc=9, argv=0x7fffffffe0e8, envp=0x7fffffffe138) at ../softmmu/main.c:49
+ */
 static void remote_object_set_fd(Object *obj, const char *str, Error **errp)
 {
     RemoteObject *o = REMOTE_OBJECT(obj);
@@ -97,6 +110,10 @@ static void remote_object_machine_done(Notifier *notifier, void *data)
     RemoteCommDev *comdev = NULL;
     Error *err = NULL;
 
+    /*
+     * RemoteObject *o:
+     * -> char *devid;
+     */
     dev = qdev_find_recursive(sysbus_get_default(), o->devid);
     if (!dev || !object_dynamic_cast(OBJECT(dev), TYPE_PCI_DEVICE)) {
         error_report("%s is not a PCI device", o->devid);
@@ -143,9 +160,31 @@ static void remote_object_init(Object *obj)
     k->nr_devs++;
 
     o->machine_done.notify = remote_object_machine_done;
+    /*
+     * called by:
+     *   - hw/acpi/piix4.c|516| <<piix4_pm_realize>> qemu_add_machine_init_done_notifier(&s->machine_ready);
+     *   - hw/arm/virt.c|2113| <<machvirt_init>> qemu_add_machine_init_done_notifier(&vms->machine_done);
+     *   - hw/core/machine.c|961| <<machine_initfn>> qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);
+     *   - hw/i386/intel_iommu.c|3850| <<vtd_realize>> qemu_add_machine_init_done_notifier(&vtd_machine_done_notify);
+     *   - hw/i386/microvm.c|669| <<microvm_machine_initfn>> qemu_add_machine_init_done_notifier(&mms->machine_done);
+     *   - hw/i386/pc.c|821| <<pc_guest_info_init>> qemu_add_machine_init_done_notifier(&pcms->machine_done);
+     *   - hw/intc/ioapic.c|470| <<ioapic_realize>> qemu_add_machine_init_done_notifier(&s->machine_done);
+     *   - hw/isa/lpc_ich9.c|702| <<ich9_lpc_realize>> qemu_add_machine_init_done_notifier(&lpc->machine_ready);
+     *   - hw/nvram/fw_cfg.c|1143| <<fw_cfg_common_realize>> qemu_add_machine_init_done_notifier(&s->machine_ready);
+     *   - hw/pci/pci.c|128| <<pci_bus_realize>> qemu_add_machine_init_done_notifier(&bus->machine_done);
+     *   - hw/ppc/e500.c|651| <<ppce500_prep_device_tree>> qemu_add_machine_init_done_notifier(&p->notifier);
+     *   - hw/remote/remote-obj.c|146| <<remote_object_init>> qemu_add_machine_init_done_notifier(&o->machine_done);
+     *   - target/arm/kvm.c|392| <<kvm_arm_register_device>> qemu_add_machine_init_done_notifier(&notify);
+     *   - target/i386/cpu.c|6906| <<x86_cpu_realizefn>> qemu_add_machine_init_done_notifier(&cpu->machine_done);
+     *   - target/i386/kvm/kvm.c|2244| <<kvm_arch_init>> qemu_add_machine_init_done_notifier(&smram_machine_done);
+     *   - target/i386/sev.c|800| <<sev_kvm_init>> qemu_add_machine_init_done_notifier(&sev_machine_done_notify);
+     */
     qemu_add_machine_init_done_notifier(&o->machine_done);
 }
 
+/*
+ * TypeInfo remote_object_info.instance_finalize = remote_object_finalize()
+ */
 static void remote_object_finalize(Object *obj)
 {
     RemoteObjectClass *k = REMOTE_OBJECT_GET_CLASS(obj);
@@ -181,6 +220,19 @@ static void remote_object_class_init(ObjectClass *klass, void *data)
                                   remote_object_set_devid);
 }
 
+/*
+ * test的例子:
+ *  35         # Create remote process
+ *  36         remote_vm = self.get_vm()
+ *  37         remote_vm.add_args('-machine', 'x-remote')
+ *  38         remote_vm.add_args('-nodefaults')
+ *  39         remote_vm.add_args('-device', 'lsi53c895a,id=lsi1')
+ *  40         remote_vm.add_args('-object', 'x-remote-object,id=robj1,'
+ *  41                            'devid=lsi1,fd='+str(remote_sock.fileno()))
+ *  42         remote_vm.launch()
+ *
+ * 似乎是qemu cmdline
+ */
 static const TypeInfo remote_object_info = {
     .name = TYPE_REMOTE_OBJECT,
     .parent = TYPE_OBJECT,
diff --git a/hw/scsi/emulation.c b/hw/scsi/emulation.c
index 06d62f3c3..d672ad89a 100644
--- a/hw/scsi/emulation.c
+++ b/hw/scsi/emulation.c
@@ -3,6 +3,11 @@
 #include "qemu/bswap.h"
 #include "hw/scsi/emulation.h"
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|996| <<scsi_disk_emulate_vpd_page>> buflen += scsi_emulate_block_limits(outbuf + buflen, &bl);
+ *   - hw/scsi/scsi-generic.c|244| <<scsi_generic_emulate_block_limits>> len = scsi_emulate_block_limits(buf + 4, &bl);
+ */
 int scsi_emulate_block_limits(uint8_t *outbuf, const SCSIBlockLimits *bl)
 {
     /* required VPD size with unmap support */
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 2a0a98cac..05dc5fec7 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -24,6 +24,12 @@ static void scsi_target_free_buf(SCSIRequest *req);
 
 static int next_scsi_bus;
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|73| <<scsi_device_find>> return do_scsi_device_find(bus, channel, id, lun, false);
+ *   - hw/scsi/scsi-bus.c|84| <<scsi_device_get>> d = do_scsi_device_find(bus, channel, id, lun, false);
+ *   - hw/scsi/scsi-bus.c|241| <<scsi_bus_is_address_free>> d = do_scsi_device_find(bus, channel, target, lun, true);
+ */
 static SCSIDevice *do_scsi_device_find(SCSIBus *bus,
                                        int channel, int id, int lun,
                                        bool include_unrealized)
@@ -31,6 +37,11 @@ static SCSIDevice *do_scsi_device_find(SCSIBus *bus,
     BusChild *kid;
     SCSIDevice *retval = NULL;
 
+    /*
+     * SCSIBus *bus:
+     * -> BusState qbus;
+     *    -> QTAILQ_HEAD(, BusChild) children;
+     */
     QTAILQ_FOREACH_RCU(kid, &bus->qbus.children, sibling) {
         DeviceState *qdev = kid->child;
         SCSIDevice *dev = SCSI_DEVICE(qdev);
@@ -67,12 +78,35 @@ static SCSIDevice *do_scsi_device_find(SCSIBus *bus,
     return retval;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/esp.c|212| <<esp_select>> s->current_dev = scsi_device_find(&s->bus, 0, target, 0);
+ *   - hw/scsi/esp.c|294| <<do_busid_cmd>> current_lun = scsi_device_find(&s->bus, 0, s->current_dev->id, lun);
+ *   - hw/scsi/lsi53c895a.c|858| <<lsi_do_command>> dev = scsi_device_find(&s->bus, 0, id, s->current_lun);
+ *   - hw/scsi/lsi53c895a.c|1308| <<lsi_execute_script>> if (!scsi_device_find(&s->bus, 0, id, 0)) {
+ *   - hw/scsi/megasas.c|1125| <<megasas_dcmd_pd_get_info>> sdev = scsi_device_find(&s->bus, 0, target_id, lun_id);
+ *   - hw/scsi/megasas.c|1302| <<megasas_dcmd_ld_get_info>> sdev = scsi_device_find(&s->bus, 0, ld_id, 0);
+ *   - hw/scsi/megasas.c|1686| <<megasas_handle_scsi>> sdev = scsi_device_find(&s->bus, 0, target_id, lun_id);
+ *   - hw/scsi/megasas.c|1759| <<megasas_handle_io>> sdev = scsi_device_find(&s->bus, 0, target_id, lun_id);
+ *   - hw/scsi/mptconfig.c|400| <<mptsas_phy_get_device>> SCSIDevice *d = scsi_device_find(&s->bus, 0, i, 0);
+ *   - hw/scsi/mptconfig.c|569| <<mptsas_device_addr_get>> } while (i < MPTSAS_NUM_PORTS && !scsi_device_find(&s->bus, 0, i, 0));
+ *   - hw/scsi/mptsas.c|274| <<mptsas_scsi_device_find>> *sdev = scsi_device_find(&s->bus, bus, target, lun[1]);
+ *   - hw/scsi/spapr_vscsi.c|178| <<vscsi_device_find>> return scsi_device_find(bus, channel, id, *lun);
+ *   - hw/scsi/vmw_pvscsi.c|645| <<pvscsi_device_find>> return scsi_device_find(&s->bus, channel, target, *target_lun);
+ *   - hw/usb/dev-storage.c|343| <<usb_msd_handle_control>> scsi_dev = scsi_device_find(&s->bus, 0, 0, maxlun+1);
+ *   - hw/usb/dev-storage.c|400| <<usb_msd_handle_data>> scsi_dev = scsi_device_find(&s->bus, 0, 0, cbw.lun);
+ *   - hw/usb/dev-uas.c|479| <<usb_uas_get_dev>> return scsi_device_find(&uas->bus, 0, 0, usb_uas_get_lun(lun64));
+ */
 SCSIDevice *scsi_device_find(SCSIBus *bus, int channel, int id, int lun)
 {
     RCU_READ_LOCK_GUARD();
     return do_scsi_device_find(bus, channel, id, lun, false);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|45| <<virtio_scsi_device_get>> return scsi_device_get(&s->bus, 0, lun[1], virtio_scsi_get_lun(lun));
+ */
 SCSIDevice *scsi_device_get(SCSIBus *bus, int channel, int id, int lun)
 {
     SCSIDevice *d;
@@ -100,6 +134,11 @@ static void scsi_device_unrealize(SCSIDevice *s)
     }
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|3473| <<scsi_block_parse_cdb>> return scsi_bus_parse_cdb(&s->qdev, cmd, buf, hba_private);
+ *   - hw/scsi/scsi-generic.c|835| <<scsi_generic_parse_cdb>> return scsi_bus_parse_cdb(dev, cmd, buf, hba_private);
+ */
 int scsi_bus_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf,
                        void *hba_private)
 {
@@ -114,10 +153,40 @@ int scsi_bus_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf,
     return rc;
 }
 
+/*
+ * (gdb) bt
+ * #0  scsi_block_new_request (d=0x5555579602d0, tag=3263207184, lun=0, buf=0x555557317c0f "(", hba_private=0x555557317b30) at ../hw/scsi/scsi-disk.c:2930
+ * #1  0x00005555559a5701 in scsi_device_alloc_req (s=0x5555579602d0, tag=3263207184, lun=0, buf=0x555557317c0f "(", hba_private=0x555557317b30) at ../hw/scsi/scsi-bus.c:122
+ * #2  0x00005555559a73a4 in scsi_req_new (d=0x5555579602d0, tag=3263207184, lun=0, buf=0x555557317c0f "(", hba_private=0x555557317b30) at ../hw/scsi/scsi-bus.c:757
+ * #3  0x0000555555b8eace in virtio_scsi_handle_cmd_req_prepare (s=0x5555577e0680, req=0x555557317b30) at ../hw/scsi/virtio-scsi.c:602
+ * #4  0x0000555555b8ec6e in virtio_scsi_handle_cmd_vq (s=0x5555577e0680, vq=0x5555577e85f0) at ../hw/scsi/virtio-scsi.c:646
+ * #5  0x0000555555c6d983 in virtio_scsi_data_plane_handle_cmd (vdev=0x5555577e0680, vq=0x5555577e85f0) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #6  0x0000555555c88332 in virtio_queue_notify_aio_vq (vq=0x5555577e85f0) at ../hw/virtio/virtio.c:2326
+ * #7  0x0000555555c8b175 in virtio_queue_host_notifier_aio_read (n=0x5555577e866c) at ../hw/virtio/virtio.c:3533
+ * #8  0x0000555555e6e50b in aio_dispatch_handler (ctx=0x5555567358b0, node=0x7ff7d40074e0) at ../util/aio-posix.c:329
+ * #9  0x0000555555e6e6c4 in aio_dispatch_handlers (ctx=0x5555567358b0) at ../util/aio-posix.c:372
+ * #10 0x0000555555e6e71a in aio_dispatch (ctx=0x5555567358b0) at ../util/aio-posix.c:382
+ * #11 0x0000555555e7dad0 in aio_ctx_dispatch (source=0x5555567358b0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #12 0x00007ffff7652119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #13 0x0000555555e68900 in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #14 0x0000555555e6897a in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:254
+ * #15 0x0000555555e68a82 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #16 0x0000555555c28e82 in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #17 0x0000555555814ba2 in main (argc=26, argv=0x7fffffffdd48, envp=0x7fffffffde20) at ../softmmu/main.c:50
+ *
+ * called by:
+ *   - hw/scsi/scsi-bus.c|758| <<scsi_req_new>> req = scsi_device_alloc_req(d, tag, lun, buf, hba_private);
+ */
 static SCSIRequest *scsi_device_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t lun,
                                           uint8_t *buf, void *hba_private)
 {
     SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
+    /*
+     *  - hw/scsi/scsi-disk.c|3230| <<scsi_hd_class_initfn>> sc->alloc_req = scsi_new_request;
+     *  - hw/scsi/scsi-disk.c|3265| <<scsi_cd_class_initfn>> sc->alloc_req = scsi_new_request;
+     *  - hw/scsi/scsi-disk.c|3302| <<scsi_block_class_initfn>> sc->alloc_req = scsi_block_new_request;
+     *  - hw/scsi/scsi-generic.c|832| <<scsi_generic_class_initfn>> sc->alloc_req = scsi_new_request;
+     */
     if (sc->alloc_req) {
         return sc->alloc_req(s, tag, lun, buf, hba_private);
     }
@@ -125,6 +194,12 @@ static SCSIRequest *scsi_device_alloc_req(SCSIDevice *s, uint32_t tag, uint32_t
     return NULL;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/megasas.c|2237| <<megasas_soft_reset>> scsi_device_unit_attention_reported(sdev);
+ *   - hw/scsi/scsi-bus.c|666| <<scsi_target_send_command>> scsi_device_unit_attention_reported(req->dev);
+ *   - hw/scsi/scsi-bus.c|949| <<scsi_req_get_sense>> scsi_device_unit_attention_reported(req->dev);
+ */
 void scsi_device_unit_attention_reported(SCSIDevice *s)
 {
     SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
@@ -134,6 +209,20 @@ void scsi_device_unit_attention_reported(SCSIDevice *s)
 }
 
 /* Create a scsi bus, and attach devices to it.  */
+/*
+ * called by:
+ *   - hw/scsi/esp-pci.c|391| <<esp_pci_scsi_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);
+ *   - hw/scsi/esp.c|1300| <<sysbus_esp_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), dev, &esp_scsi_info, NULL);
+ *   - hw/scsi/lsi53c895a.c|2312| <<lsi_scsi_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), d, &lsi_scsi_info, NULL);
+ *   - hw/scsi/megasas.c|2419| <<megasas_scsi_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),
+ *   - hw/scsi/mptsas.c|1318| <<mptsas_scsi_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);
+ *   - hw/scsi/spapr_vscsi.c|1220| <<spapr_vscsi_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),
+ *   - hw/scsi/virtio-scsi.c|1392| <<virtio_scsi_device_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), dev,
+ *   - hw/scsi/vmw_pvscsi.c|1183| <<pvscsi_realizefn>> scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(pci_dev),
+ *   - hw/usb/dev-storage-bot.c|39| <<usb_msd_bot_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),
+ *   - hw/usb/dev-storage-classic.c|67| <<usb_msd_storage_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),
+ *   - hw/usb/dev-uas.c|929| <<usb_uas_realize>> scsi_bus_new(&uas->bus, sizeof(uas->bus), DEVICE(dev),
+ */
 void scsi_bus_new(SCSIBus *bus, size_t bus_size, DeviceState *host,
                   const SCSIBusInfo *info, const char *bus_name)
 {
@@ -174,6 +263,10 @@ static void scsi_dma_restart_bh(void *opaque)
     object_unref(OBJECT(s));
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|304| <<scsi_handle_rw_error>> scsi_req_retry(&r->req);
+ */
 void scsi_req_retry(SCSIRequest *req)
 {
     /* No need to save a reference, because scsi_dma_restart_bh just
@@ -197,6 +290,12 @@ static void scsi_dma_restart_cb(void *opaque, bool running, RunState state)
     }
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|280| <<scsi_bus_check_address>> if (!scsi_bus_is_address_free(bus, dev->channel, dev->id, dev->lun, &d)) {
+ *   - hw/scsi/scsi-bus.c|321| <<scsi_qdev_realize>> is_free = scsi_bus_is_address_free(bus, dev->channel, ++id, dev->lun, NULL);
+ *   - hw/scsi/scsi-bus.c|331| <<scsi_qdev_realize>> is_free = scsi_bus_is_address_free(bus, dev->channel, dev->id, ++lun, NULL);
+ */
 static bool scsi_bus_is_address_free(SCSIBus *bus,
 				     int channel, int target, int lun,
 				     SCSIDevice **p_dev)
@@ -246,6 +345,25 @@ static bool scsi_bus_check_address(BusState *qbus, DeviceState *qdev, Error **er
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  scsi_hd_realize (dev=0x5555578e0f00, errp=0x7fffffffd840) at ../hw/scsi/scsi-disk.c:2428
+ * #1  0x0000555555a7e085 in scsi_device_realize (s=0x5555578e0f00, errp=0x7fffffffd840) at ../hw/scsi/scsi-bus.c:91
+ * #2  0x0000555555a7e997 in scsi_qdev_realize (qdev=0x5555578e0f00, errp=0x7fffffffd8b0) at ../hw/scsi/scsi-bus.c:282
+ * #3  0x0000555555dddf92 in device_set_realized (obj=0x5555578e0f00, value=true, errp=0x7fffffffd9b8) at ../hw/core/qdev.c:761
+ * #4  0x0000555555cdef50 in property_set_bool (obj=0x5555578e0f00, v=0x5555578e12e0, name=0x555556069f41 "realized", opaque=0x55555673b9c0, errp=0x7fffffffd9b8) at ../qom/object.c:2257
+ * #5  0x0000555555cdd047 in object_property_set (obj=0x5555578e0f00, name=0x555556069f41 "realized", v=0x5555578e12e0, errp=0x5555566c8a90 <error_fatal>) at ../qom/object.c:1402
+ * #6  0x0000555555cd9a3b in object_property_set_qobject (obj=0x5555578e0f00, name=0x555556069f41 "realized", value=0x5555578e12c0, errp=0x5555566c8a90 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #7  0x0000555555cdd3aa in object_property_set_bool (obj=0x5555578e0f00, name=0x555556069f41 "realized", value=true, errp=0x5555566c8a90 <error_fatal>) at ../qom/object.c:1472
+ * #8  0x0000555555ddd01d in qdev_realize (dev=0x5555578e0f00, bus=0x55555777db00, errp=0x5555566c8a90 <error_fatal>) at ../hw/core/qdev.c:389
+ * #9  0x0000555555abd739 in qdev_device_add (opts=0x555556734f00, errp=0x5555566c8a90 <error_fatal>) at ../softmmu/qdev-monitor.c:674
+ * #10 0x0000555555cba109 in device_init_func (opaque=0x0, opts=0x555556734f00, errp=0x5555566c8a90 <error_fatal>) at ../softmmu/vl.c:1211
+ * #11 0x0000555555e8025f in qemu_opts_foreach (list=0x5555565ea200 <qemu_device_opts>, func=0x555555cba0e2 <device_init_func>, opaque=0x0, errp=0x5555566c8a90 <error_fatal>) at ../util/qemu-option.c:1167
+ * #12 0x0000555555cbd1e7 in qemu_create_cli_devices () at ../softmmu/vl.c:2541
+ * #13 0x0000555555cbd30a in qmp_x_exit_preconfig (errp=0x5555566c8a90 <error_fatal>) at ../softmmu/vl.c:2589
+ * #14 0x0000555555cbfa18 in qemu_init (argc=18, argv=0x7fffffffde38, envp=0x7fffffffded0) at ../softmmu/vl.c:3611
+ * #15 0x0000555555814b9d in main (argc=18, argv=0x7fffffffde38, envp=0x7fffffffded0) at ../softmmu/main.c:49
+ */
 static void scsi_qdev_realize(DeviceState *qdev, Error **errp)
 {
     SCSIDevice *dev = SCSI_DEVICE(qdev);
@@ -304,6 +422,11 @@ static void scsi_qdev_unrealize(DeviceState *qdev)
 }
 
 /* handle legacy '-drive if=scsi,...' cmd line args */
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|436| <<scsi_bus_legacy_handle_cmdline>> scsi_bus_legacy_add_drive(bus, blk_by_legacy_dinfo(dinfo),
+ *   - hw/usb/dev-storage-classic.c|69| <<usb_msd_storage_realize>> scsi_dev = scsi_bus_legacy_add_drive(&s->bus, blk, 0, !!s->removable,
+ */
 SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, BlockBackend *blk,
                                       int unit, bool removable, int bootindex,
                                       bool share_rw,
@@ -503,6 +626,10 @@ static bool scsi_target_emulate_report_luns(SCSITargetReq *r)
     return true;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|713| <<scsi_target_send_command>> if (!scsi_target_emulate_inquiry(r)) {
+ */
 static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
 {
     assert(r->req.dev->lun != r->req.lun);
@@ -665,6 +792,10 @@ static void scsi_target_free_buf(SCSIRequest *req)
     g_free(r->buf);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|890| <<scsi_req_new>> ops = &reqops_target_command;
+ */
 static const struct SCSIReqOps reqops_target_command = {
     .size         = sizeof(SCSITargetReq),
     .send_command = scsi_target_send_command,
@@ -674,6 +805,16 @@ static const struct SCSIReqOps reqops_target_command = {
 };
 
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|906| <<scsi_req_new>> req = scsi_req_alloc(&reqops_invalid_opcode, d, tag, lun, hba_private);
+ *   - hw/scsi/scsi-bus.c|917| <<scsi_req_new>> req = scsi_req_alloc(&reqops_invalid_field, d, tag, lun, hba_private);
+ *   - hw/scsi/scsi-bus.c|919| <<scsi_req_new>> req = scsi_req_alloc(ops, d, tag, lun, hba_private);
+ *   - hw/scsi/scsi-disk.c|2966| <<scsi_new_request>> req = scsi_req_alloc(ops, &s->qdev, tag, lun, hba_private);
+ *   - hw/scsi/scsi-disk.c|3459| <<scsi_block_new_request>> return scsi_req_alloc(&scsi_generic_req_ops, &s->qdev, tag, lun,
+ *   - hw/scsi/scsi-disk.c|3462| <<scsi_block_new_request>> return scsi_req_alloc(&scsi_block_dma_reqops, &s->qdev, tag, lun,
+ *   - hw/scsi/scsi-generic.c|821| <<scsi_new_request>> return scsi_req_alloc(&scsi_generic_req_ops, d, tag, lun, hba_private);
+ */
 SCSIRequest *scsi_req_alloc(const SCSIReqOps *reqops, SCSIDevice *d,
                             uint32_t tag, uint32_t lun, void *hba_private)
 {
@@ -701,6 +842,43 @@ SCSIRequest *scsi_req_alloc(const SCSIReqOps *reqops, SCSIDevice *d,
     return req;
 }
 
+/*
+ * (gdb) bt
+ * #0  scsi_block_new_request (d=0x5555579602d0, tag=3263207184, lun=0, buf=0x555557317c0f "(", hba_private=0x555557317b30) at ../hw/scsi/scsi-disk.c:2930
+ * #1  0x00005555559a5701 in scsi_device_alloc_req (s=0x5555579602d0, tag=3263207184, lun=0, buf=0x555557317c0f "(", hba_private=0x555557317b30) at ../hw/scsi/scsi-bus.c:122
+ * #2  0x00005555559a73a4 in scsi_req_new (d=0x5555579602d0, tag=3263207184, lun=0, buf=0x555557317c0f "(", hba_private=0x555557317b30) at ../hw/scsi/scsi-bus.c:757
+ * #3  0x0000555555b8eace in virtio_scsi_handle_cmd_req_prepare (s=0x5555577e0680, req=0x555557317b30) at ../hw/scsi/virtio-scsi.c:602
+ * #4  0x0000555555b8ec6e in virtio_scsi_handle_cmd_vq (s=0x5555577e0680, vq=0x5555577e85f0) at ../hw/scsi/virtio-scsi.c:646
+ * #5  0x0000555555c6d983 in virtio_scsi_data_plane_handle_cmd (vdev=0x5555577e0680, vq=0x5555577e85f0) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #6  0x0000555555c88332 in virtio_queue_notify_aio_vq (vq=0x5555577e85f0) at ../hw/virtio/virtio.c:2326
+ * #7  0x0000555555c8b175 in virtio_queue_host_notifier_aio_read (n=0x5555577e866c) at ../hw/virtio/virtio.c:3533
+ * #8  0x0000555555e6e50b in aio_dispatch_handler (ctx=0x5555567358b0, node=0x7ff7d40074e0) at ../util/aio-posix.c:329
+ * #9  0x0000555555e6e6c4 in aio_dispatch_handlers (ctx=0x5555567358b0) at ../util/aio-posix.c:372
+ * #10 0x0000555555e6e71a in aio_dispatch (ctx=0x5555567358b0) at ../util/aio-posix.c:382
+ * #11 0x0000555555e7dad0 in aio_ctx_dispatch (source=0x5555567358b0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #12 0x00007ffff7652119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #13 0x0000555555e68900 in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #14 0x0000555555e6897a in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:254
+ * #15 0x0000555555e68a82 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #16 0x0000555555c28e82 in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #17 0x0000555555814ba2 in main (argc=26, argv=0x7fffffffdd48, envp=0x7fffffffde20) at ../softmmu/main.c:50
+ *
+ * called by:
+ *   - hw/scsi/esp.c|295| <<do_busid_cmd>> s->current_req = scsi_req_new(current_lun, 0, lun, buf, s);
+ *   - hw/scsi/lsi53c895a.c|867| <<lsi_do_command>> s->current->req = scsi_req_new(dev, s->current->tag, s->current_lun, buf,
+ *   - hw/scsi/megasas.c|1043| <<megasas_pd_get_info_submit>> cmd->req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);
+ *   - hw/scsi/megasas.c|1061| <<megasas_pd_get_info_submit>> cmd->req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);
+ *   - hw/scsi/megasas.c|1242| <<megasas_ld_get_info_submit>> cmd->req = scsi_req_new(sdev, cmd->index, lun, cdb, cmd);
+ *   - hw/scsi/megasas.c|1715| <<megasas_handle_scsi>> cmd->req = scsi_req_new(sdev, cmd->index, lun_id, cdb, cmd);
+ *   - hw/scsi/megasas.c|1789| <<megasas_handle_io>> cmd->req = scsi_req_new(sdev, cmd->index,
+ *   - hw/scsi/mptsas.c|318| <<mptsas_process_scsi_io_request>> req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,
+ *   - hw/scsi/scsi-bus.c|1780| <<get_scsi_requests>> req = scsi_req_new(s, tag, lun, buf, NULL);
+ *   - hw/scsi/spapr_vscsi.c|805| <<vscsi_queue_cmd>> req->sreq = scsi_req_new(sdev, req->qtag, lun, srp->cmd.cdb, req);
+ *   - hw/scsi/virtio-scsi.c|652| <<virtio_scsi_handle_cmd_req_prepare>> req->sreq = scsi_req_new(d, req->req.cmd.tag,
+ *   - hw/scsi/vmw_pvscsi.c|727| <<pvscsi_process_request_descriptor>> r->sreq = scsi_req_new(d, descr->context, r->lun, descr->cdb, r);
+ *   - hw/usb/dev-storage.c|418| <<usb_msd_handle_data>> s->req = scsi_req_new(scsi_dev, tag, cbw.lun, cbw.cmd, NULL);
+ *   - hw/usb/dev-uas.c|730| <<usb_uas_command>> req->req = scsi_req_new(req->dev, req->tag,
+ */
 SCSIRequest *scsi_req_new(SCSIDevice *d, uint32_t tag, uint32_t lun,
                           uint8_t *buf, void *hba_private)
 {
@@ -735,6 +913,9 @@ SCSIRequest *scsi_req_new(SCSIDevice *d, uint32_t tag, uint32_t lun,
     if (ops != NULL || !sc->parse_cdb) {
         ret = scsi_req_parse_cdb(d, &cmd, buf);
     } else {
+        /*
+	 * virtio_scsi_parse_cdb()
+	 */
         ret = sc->parse_cdb(d, &cmd, buf, hba_private);
     }
 
@@ -826,6 +1007,15 @@ static void scsi_clear_unit_attention(SCSIRequest *req)
     *ua = SENSE_CODE(NO_SENSE);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/megasas.c|362| <<megasas_copy_sense>> sense_len = scsi_req_get_sense(cmd->req, sense_buf,
+ *   - hw/scsi/mptsas.c|1145| <<mptsas_command_complete>> sense_len = scsi_req_get_sense(sreq, sense_buf, SCSI_SENSE_BUF_SIZE);
+ *   - hw/scsi/spapr_vscsi.c|567| <<vscsi_command_complete>> req->senselen = scsi_req_get_sense(req->sreq, req->sense,
+ *   - hw/scsi/virtio-scsi.c|797| <<virtio_scsi_command_complete>> sense_len = scsi_req_get_sense(r, sense, sizeof(sense));
+ *   - hw/scsi/vmw_pvscsi.c|573| <<pvscsi_command_complete>> scsi_req_get_sense(pvscsi_req->sreq, sense, sizeof(sense));
+ *   - hw/usb/dev-uas.c|423| <<usb_uas_queue_sense>> slen = scsi_req_get_sense(req->req, st->status.sense.sense_data,
+ */
 int scsi_req_get_sense(SCSIRequest *req, uint8_t *buf, int len)
 {
     int ret;
@@ -854,18 +1044,48 @@ int scsi_req_get_sense(SCSIRequest *req, uint8_t *buf, int len)
     return ret;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|729| <<scsi_target_send_command>> r->len = scsi_device_get_sense(r->req.dev, r->buf,
+ */
 int scsi_device_get_sense(SCSIDevice *dev, uint8_t *buf, int len, bool fixed)
 {
     return scsi_convert_sense(dev->sense, dev->sense_len, buf, len, fixed);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|422| <<scsi_invalid_field>> scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-bus.c|436| <<scsi_invalid_command>> scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
+ *   - hw/scsi/scsi-bus.c|451| <<scsi_unit_attention>> scsi_req_build_sense(req, req->dev->unit_attention);
+ *   - hw/scsi/scsi-bus.c|453| <<scsi_unit_attention>> scsi_req_build_sense(req, req->bus->unit_attention);
+ *   - hw/scsi/scsi-bus.c|613| <<scsi_target_send_command>> scsi_req_build_sense(req, SENSE_CODE(LUN_NOT_SUPPORTED));
+ *   - hw/scsi/scsi-bus.c|649| <<scsi_target_send_command>> scsi_req_build_sense(req, SENSE_CODE(INVALID_OPCODE));
+ *   - hw/scsi/scsi-bus.c|653| <<scsi_target_send_command>> scsi_req_build_sense(req, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-bus.c|1616| <<scsi_req_complete_failed>> scsi_req_build_sense(req, sense);
+ *   - hw/scsi/scsi-disk.c|166| <<scsi_check_condition>> scsi_req_build_sense(&r->req, sense);
+ *   - hw/scsi/scsi-disk.c|290| <<scsi_handle_rw_error>> scsi_req_build_sense(&r->req, sense);
+ *   - hw/scsi/scsi-generic.c|89| <<scsi_command_complete_noio>> scsi_req_build_sense(&r->req, sense);
+ */
 void scsi_req_build_sense(SCSIRequest *req, SCSISense sense)
 {
     trace_scsi_req_build_sense(req->dev->id, req->lun, req->tag,
                                sense.key, sense.asc, sense.ascq);
+    /*
+     * 在以下设置SCSIRequest->sense_len:
+     *   - hw/scsi/scsi-bus.c|954| <<scsi_req_build_sense>> req->sense_len = scsi_build_sense(req->sense, sense);
+     *   - hw/scsi/scsi-bus.c|1696| <<scsi_req_complete>> req->sense_len = 0;
+     *   - hw/scsi/scsi-disk.c|3427| <<scsi_block_update_sense>> r->req.sense_len = MIN(br->io_header.sb_len_wr, sizeof(r->req.sense));
+     *   - hw/scsi/scsi-generic.c|99| <<scsi_command_complete_noio>> r->req.sense_len = io_hdr->sb_len_wr;
+     */
     req->sense_len = scsi_build_sense(req->sense, sense);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|1092| <<scsi_req_enqueue>> scsi_req_enqueue_internal(req);
+ *   - hw/scsi/scsi-bus.c|2040| <<get_scsi_requests>> scsi_req_enqueue_internal(req);
+ */
 static void scsi_req_enqueue_internal(SCSIRequest *req)
 {
     assert(!req->enqueued);
@@ -876,9 +1096,30 @@ static void scsi_req_enqueue_internal(SCSIRequest *req)
         req->sg = NULL;
     }
     req->enqueued = true;
+    /*
+     * SCSIRequest *req:
+     * -> SCSIDevice *dev;
+     *    -> QTAILQ_HEAD(, SCSIRequest) requests;
+     */
     QTAILQ_INSERT_TAIL(&req->dev->requests, req, next);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/esp.c|296| <<do_busid_cmd>> datalen = scsi_req_enqueue(s->current_req);
+ *   - hw/scsi/lsi53c895a.c|870| <<lsi_do_command>> n = scsi_req_enqueue(s->current->req);
+ *   - hw/scsi/megasas.c|1053| <<megasas_pd_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+ *   - hw/scsi/megasas.c|1069| <<megasas_pd_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+ *   - hw/scsi/megasas.c|1252| <<megasas_ld_get_info_submit>> len = scsi_req_enqueue(cmd->req);
+ *   - hw/scsi/megasas.c|1636| <<megasas_enqueue_req>> len = scsi_req_enqueue(cmd->req);
+ *   - hw/scsi/mptsas.c|344| <<mptsas_process_scsi_io_request>> if (scsi_req_enqueue(req->sreq)) {
+ *   - hw/scsi/scsi-bus.c|166| <<scsi_dma_restart_bh>> scsi_req_enqueue(req);
+ *   - hw/scsi/spapr_vscsi.c|806| <<vscsi_queue_cmd>> n = scsi_req_enqueue(req->sreq);
+ *   - hw/scsi/virtio-scsi.c|673| <<virtio_scsi_handle_cmd_req_submit>> if (scsi_req_enqueue(sreq)) {
+ *   - hw/scsi/vmw_pvscsi.c|744| <<pvscsi_process_request_descriptor>> n = scsi_req_enqueue(r->sreq);
+ *   - hw/usb/dev-storage.c|422| <<usb_msd_handle_data>> len = scsi_req_enqueue(s->req);
+ *   - hw/usb/dev-uas.c|736| <<usb_uas_command>> len = scsi_req_enqueue(req->req);
+ */
 int32_t scsi_req_enqueue(SCSIRequest *req)
 {
     int32_t rc;
@@ -886,11 +1127,29 @@ int32_t scsi_req_enqueue(SCSIRequest *req)
     assert(!req->retry);
     scsi_req_enqueue_internal(req);
     scsi_req_ref(req);
+    /*
+     * send_command()的例子:
+     *   - scsi_invalid_field()
+     *   - scsi_unit_attention()
+     *   - scsi_target_send_command()
+     *   - scsi_disk_emulate_command()
+     *   - scsi_disk_dma_command()
+     *   - scsi_block_dma_command()
+     *   - scsi_send_command()
+     */
     rc = req->ops->send_command(req, req->cmd.buf);
     scsi_req_unref(req);
     return rc;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|165| <<scsi_dma_restart_bh>> scsi_req_dequeue(req);
+ *   - hw/scsi/scsi-bus.c|1478| <<scsi_req_complete_failed>> scsi_req_dequeue(req);
+ *   - hw/scsi/scsi-bus.c|1514| <<scsi_req_complete>> scsi_req_dequeue(req);
+ *   - hw/scsi/scsi-bus.c|1553| <<scsi_req_cancel_async>> scsi_req_dequeue(req);
+ *   - hw/scsi/scsi-bus.c|1571| <<scsi_req_cancel>> scsi_req_dequeue(req);
+ */
 static void scsi_req_dequeue(SCSIRequest *req)
 {
     trace_scsi_req_dequeue(req->dev->id, req->lun, req->tag);
@@ -1307,6 +1566,12 @@ static void scsi_cmd_xfer_mode(SCSICommand *cmd)
     }
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|149| <<scsi_bus_parse_cdb>> rc = scsi_req_parse_cdb(dev, cmd, buf);
+ *   - hw/scsi/scsi-bus.c|896| <<scsi_req_new>> ret = scsi_req_parse_cdb(d, &cmd, buf);
+ *   - hw/scsi/scsi-disk.c|3475| <<scsi_block_parse_cdb>> return scsi_req_parse_cdb(&s->qdev, cmd, buf);
+ */
 int scsi_req_parse_cdb(SCSIDevice *dev, SCSICommand *cmd, uint8_t *buf)
 {
     int rc;
@@ -1379,6 +1644,34 @@ void scsi_req_unref(SCSIRequest *req)
     }
 }
 
+/*
+ * called by:
+ *   - hw/scsi/esp.c|317| <<do_busid_cmd>> scsi_req_continue(s->current_req);
+ *   - hw/scsi/esp.c|527| <<do_dma_pdma_cb>> scsi_req_continue(s->current_req);
+ *   - hw/scsi/esp.c|540| <<do_dma_pdma_cb>> scsi_req_continue(s->current_req);
+ *   - hw/scsi/esp.c|678| <<esp_do_dma>> scsi_req_continue(s->current_req);
+ *   - hw/scsi/esp.c|752| <<esp_do_nodma>> scsi_req_continue(s->current_req);
+ *   - hw/scsi/lsi53c895a.c|663| <<lsi_do_dma>> scsi_req_continue(s->current->req);
+ *   - hw/scsi/lsi53c895a.c|877| <<lsi_do_command>> scsi_req_continue(s->current->req);
+ *   - hw/scsi/megasas.c|1056| <<megasas_pd_get_info_submit>> scsi_req_continue(cmd->req);
+ *   - hw/scsi/megasas.c|1072| <<megasas_pd_get_info_submit>> scsi_req_continue(cmd->req);
+ *   - hw/scsi/megasas.c|1255| <<megasas_ld_get_info_submit>> scsi_req_continue(cmd->req);
+ *   - hw/scsi/megasas.c|1660| <<megasas_enqueue_req>> scsi_req_continue(cmd->req);
+ *   - hw/scsi/megasas.c|1829| <<megasas_xfer_complete>> scsi_req_continue(req);
+ *   - hw/scsi/megasas.c|1844| <<megasas_xfer_complete>> scsi_req_continue(req);
+ *   - hw/scsi/megasas.c|1850| <<megasas_xfer_complete>> scsi_req_continue(req);
+ *   - hw/scsi/mptsas.c|345| <<mptsas_process_scsi_io_request>> scsi_req_continue(req->sreq);
+ *   - hw/scsi/scsi-bus.c|162| <<scsi_dma_restart_bh>> scsi_req_continue(req);
+ *   - hw/scsi/scsi-bus.c|1428| <<scsi_req_data>> scsi_req_continue(req);
+ *   - hw/scsi/spapr_vscsi.c|550| <<vscsi_transfer_data>> scsi_req_continue(sreq);
+ *   - hw/scsi/spapr_vscsi.c|826| <<vscsi_queue_cmd>> scsi_req_continue(req->sreq);
+ *   - hw/scsi/virtio-scsi.c|674| <<virtio_scsi_handle_cmd_req_submit>> scsi_req_continue(sreq);
+ *   - hw/scsi/vmw_pvscsi.c|747| <<pvscsi_process_request_descriptor>> scsi_req_continue(r->sreq);
+ *   - hw/usb/dev-storage.c|194| <<usb_msd_copy_data>> scsi_req_continue(s->req);
+ *   - hw/usb/dev-storage.c|424| <<usb_msd_handle_data>> scsi_req_continue(s->req);
+ *   - hw/usb/dev-uas.c|516| <<usb_uas_copy_data>> scsi_req_continue(req->req);
+ *   - hw/usb/dev-uas.c|739| <<usb_uas_command>> scsi_req_continue(req->req);
+ */
 /* Tell the device that we finished processing this chunk of I/O.  It
    will start the next chunk or complete the command.  */
 void scsi_req_continue(SCSIRequest *req)
@@ -1387,6 +1680,9 @@ void scsi_req_continue(SCSIRequest *req)
         trace_scsi_req_continue_canceled(req->dev->id, req->lun, req->tag);
         return;
     }
+    /*
+     * 这个trace只在这里调用
+     */
     trace_scsi_req_continue(req->dev->id, req->lun, req->tag);
     if (req->cmd.mode == SCSI_XFER_TO_DEV) {
         req->ops->write_data(req);
@@ -1428,6 +1724,11 @@ void scsi_req_data(SCSIRequest *req, int len)
     scsi_req_continue(req);
 }
 
+/*
+ * called by:
+ *   - hw/usb/dev-storage.c|420| <<usb_msd_handle_data>> scsi_req_print(s->req);
+ *   - hw/usb/dev-uas.c|734| <<usb_uas_command>> scsi_req_print(req->req);
+ */
 void scsi_req_print(SCSIRequest *req)
 {
     FILE *fp = stderr;
@@ -1456,6 +1757,11 @@ void scsi_req_print(SCSIRequest *req)
     }
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|3014| <<scsi_block_sgio_complete>> scsi_req_complete_failed(&r->req, io_hdr->host_status);
+ *   - hw/scsi/scsi-generic.c|92| <<scsi_command_complete_noio>> scsi_req_complete_failed(&r->req, io_hdr->host_status);
+ */
 void scsi_req_complete_failed(SCSIRequest *req, int host_status)
 {
     SCSISense sense;
@@ -1464,7 +1770,21 @@ void scsi_req_complete_failed(SCSIRequest *req, int host_status)
     assert(req->status == -1 && req->host_status == -1);
     assert(req->ops != &reqops_unit_attention);
 
+    /*
+     * virtio_scsi_command_failed()
+     */
     if (!req->bus->info->fail) {
+        /*
+	 * 在以下设置SCSIRequest->host_status:
+	 *   - hw/scsi/scsi-bus.c|729| <<scsi_req_alloc>> req->host_status = -1;
+	 *   - hw/scsi/scsi-bus.c|1622| <<scsi_req_complete_failed>> req->host_status = host_status;
+	 *   - hw/scsi/scsi-bus.c|1672| <<scsi_req_complete>> req->host_status = SCSI_HOST_OK;
+	 *
+	 * SCSIRequest *req:
+	 * -> int16_t host_status;
+	 * -> uint8_t sense[SCSI_SENSE_BUF_SIZE];
+	 * -> uint32_t sense_len;
+	 */
         status = scsi_sense_from_host_status(req->host_status, &sense);
         if (status == CHECK_CONDITION) {
             scsi_req_build_sense(req, sense);
@@ -1483,6 +1803,42 @@ void scsi_req_complete_failed(SCSIRequest *req, int host_status)
     scsi_req_unref(req);
 }
 
+/*
+ * (gdb) bt
+ * #0  scsi_req_complete (req=0x555556d4ae60, status=0) at ../hw/scsi/scsi-bus.c:1460
+ * #1  0x0000555555a851cd in scsi_dma_complete_noio (r=0x555556d4ae60, ret=0) at ../hw/scsi/scsi-disk.c:345
+ * #2  0x0000555555a852dd in scsi_dma_complete (opaque=0x555556d4ae60, ret=0) at ../hw/scsi/scsi-disk.c:366
+ * #3  0x00005555558d9659 in dma_complete (dbs=0x55555763ef50, ret=0) at ../softmmu/dma-helpers.c:121
+ * #4  0x00005555558d9706 in dma_blk_cb (opaque=0x55555763ef50, ret=0) at ../softmmu/dma-helpers.c:139
+ * #5  0x0000555555d6ccc9 in blk_aio_complete (acb=0x555556d4ec60) at ../block/block-backend.c:1412
+ * #6  0x0000555555d6ceeb in blk_aio_read_entry (opaque=0x555556d4ec60) at ../block/block-backend.c:1466
+ * #7  0x0000555555e6f99a in coroutine_trampoline (i0=-939497792, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #8  0x00007ffff5c8c190 in __start_context () at /lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/scsi/scsi-bus.c|403| <<scsi_invalid_field>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|417| <<scsi_invalid_command>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|435| <<scsi_unit_attention>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|594| <<scsi_target_send_command>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|630| <<scsi_target_send_command>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|634| <<scsi_target_send_command>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|639| <<scsi_target_send_command>> scsi_req_complete(req, GOOD);
+ *   - hw/scsi/scsi-bus.c|654| <<scsi_target_read_data>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-bus.c|1573| <<scsi_req_complete_failed>> scsi_req_complete(req, status);
+ *   - hw/scsi/scsi-disk.c|133| <<scsi_check_condition>> scsi_req_complete(&r->req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-disk.c|252| <<scsi_handle_rw_error>> scsi_req_complete(&r->req, status);
+ *   - hw/scsi/scsi-disk.c|294| <<scsi_aio_complete>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|341| <<scsi_write_do_fua>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|358| <<scsi_dma_complete_noio>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|515| <<scsi_read_data>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|1472| <<scsi_disk_emulate_read_data>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|1630| <<scsi_disk_emulate_mode_select>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|1701| <<scsi_unmap_complete_noio>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|1829| <<scsi_write_same_complete>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|2204| <<scsi_disk_emulate_command>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|2330| <<scsi_disk_dma_command>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-generic.c|104| <<scsi_command_complete_noio>> scsi_req_complete(&r->req, status);
+ */
 void scsi_req_complete(SCSIRequest *req, int status)
 {
     assert(req->status == -1 && req->host_status == -1);
@@ -1495,6 +1851,14 @@ void scsi_req_complete(SCSIRequest *req, int status)
     }
 
     if (req->sense_len) {
+        /*
+	 * SCSIRequest *req:
+	 * -> SCSIDevice *dev;
+	 *    -> SCSISense unit_attention;
+	 *    -> bool sense_is_ua;
+	 *    -> uint8_t sense[SCSI_SENSE_BUF_SIZE];
+	 *    -> uint32_t sense_len;
+	 */
         memcpy(req->dev->sense, req->sense, req->sense_len);
         req->dev->sense_len = req->sense_len;
         req->dev->sense_is_ua = (req->ops == &reqops_unit_attention);
@@ -1512,6 +1876,9 @@ void scsi_req_complete(SCSIRequest *req, int status)
 
     scsi_req_ref(req);
     scsi_req_dequeue(req);
+    /*
+     * virtio_scsi_command_complete()
+     */
     req->bus->info->complete(req, req->resid);
 
     /* Cancelled requests might end up being completed instead of cancelled */
@@ -1559,6 +1926,25 @@ void scsi_req_cancel_async(SCSIRequest *req, Notifier *notifier)
     }
 }
 
+/*
+ * called by:
+ *   - hw/scsi/esp-pci.c|100| <<esp_pci_handle_abort>> scsi_req_cancel(s->current_req);
+ *   - hw/scsi/esp.c|209| <<esp_select>> scsi_req_cancel(s->current_req);
+ *   - hw/scsi/lsi53c895a.c|1033| <<lsi_do_msgout>> scsi_req_cancel(current_req->req);
+ *   - hw/scsi/lsi53c895a.c|1058| <<lsi_do_msgout>> scsi_req_cancel(s->current->req);
+ *   - hw/scsi/lsi53c895a.c|1070| <<lsi_do_msgout>> scsi_req_cancel(p->req);
+ *   - hw/scsi/megasas.c|628| <<megasas_abort_command>> scsi_req_cancel(cmd->req);
+ *   - hw/scsi/spapr_vscsi.c|544| <<vscsi_transfer_data>> scsi_req_cancel(req->sreq);
+ *   - hw/scsi/spapr_vscsi.c|858| <<vscsi_process_tsk_mgmt>> scsi_req_cancel(tmpreq->sreq);
+ *   - hw/scsi/spapr_vscsi.c|888| <<vscsi_process_tsk_mgmt>> scsi_req_cancel(tmpreq->sreq);
+ *   - hw/scsi/vmw_pvscsi.c|732| <<pvscsi_process_request_descriptor>> scsi_req_cancel(r->sreq);
+ *   - hw/scsi/vmw_pvscsi.c|739| <<pvscsi_process_request_descriptor>> scsi_req_cancel(r->sreq);
+ *   - hw/scsi/vmw_pvscsi.c|850| <<pvscsi_on_cmd_abort>> scsi_req_cancel(r->sreq);
+ *   - hw/usb/dev-storage.c|307| <<usb_msd_handle_reset>> scsi_req_cancel(s->req);
+ *   - hw/usb/dev-storage.c|370| <<usb_msd_cancel_io>> scsi_req_cancel(s->req);
+ *   - hw/usb/dev-uas.c|643| <<usb_uas_handle_reset>> scsi_req_cancel(req->req);
+ *   - hw/usb/dev-uas.c|786| <<usb_uas_task>> scsi_req_cancel(req->req);
+ */
 void scsi_req_cancel(SCSIRequest *req)
 {
     trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);
@@ -1814,6 +2200,14 @@ static void scsi_dev_instance_init(Object *obj)
                                   &s->qdev);
 }
 
+/*
+ * 有三个继承了TYPE_SCSI_DISK_BASE(scsi_disk_base_info):
+ * "scsi-cd"    : scsi_cd_info
+ * "scsi-hd"    : scsi_hd_info
+ * "scsi-block" : scsi_block_info
+ *
+ * TYPE_SCSI_DEVICE是scsi_device_type_info
+ */
 static const TypeInfo scsi_device_type_info = {
     .name = TYPE_SCSI_DEVICE,
     .parent = TYPE_DEVICE,
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index 3580e7ee6..ed4ca1cc4 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -54,6 +54,9 @@
 #define DEFAULT_MAX_UNMAP_SIZE      (1 * GiB)
 #define DEFAULT_MAX_IO_SIZE         INT_MAX     /* 2 GB - 1 block */
 
+/*
+ * TypeInfo scsi_disk_base_info
+ */
 #define TYPE_SCSI_DISK_BASE         "scsi-disk-base"
 
 OBJECT_DECLARE_TYPE(SCSIDiskState, SCSIDiskClass, SCSI_DISK_BASE)
@@ -110,6 +113,44 @@ struct SCSIDiskState {
     uint16_t rotation_rate;
 };
 
+/*
+ * (gdb) bt
+ * #0  scsi_read_data (req=0x555556d47800) at ../hw/scsi/scsi-disk.c:461
+ * #1  0x00005555559a89c5 in scsi_req_continue (req=0x555556d47800) at ../hw/scsi/scsi-bus.c:1393
+ * #2  0x0000555555b8ebc8 in virtio_scsi_handle_cmd_req_submit (s=0x5555577e0680, req=0x555556d4c020) at ../hw/scsi/virtio-scsi.c:624
+ * #3  0x0000555555b8ee24 in virtio_scsi_handle_cmd_vq (s=0x5555577e0680, vq=0x5555577e85f0) at ../hw/scsi/virtio-scsi.c:668
+ * #4  0x0000555555c6d983 in virtio_scsi_data_plane_handle_cmd (vdev=0x5555577e0680, vq=0x5555577e85f0) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #5  0x0000555555c88332 in virtio_queue_notify_aio_vq (vq=0x5555577e85f0) at ../hw/virtio/virtio.c:2326
+ * #6  0x0000555555c8b175 in virtio_queue_host_notifier_aio_read (n=0x5555577e866c) at ../hw/virtio/virtio.c:3533
+ * #7  0x0000555555e6e50b in aio_dispatch_handler (ctx=0x5555567358b0, node=0x7ff7d40074e0) at ../util/aio-posix.c:329
+ * #8  0x0000555555e6e6c4 in aio_dispatch_handlers (ctx=0x5555567358b0) at ../util/aio-posix.c:372
+ * #9  0x0000555555e6e71a in aio_dispatch (ctx=0x5555567358b0) at ../util/aio-posix.c:382
+ * #10 0x0000555555e7dad0 in aio_ctx_dispatch (source=0x5555567358b0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #11 0x00007ffff7652119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #12 0x0000555555e68900 in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #13 0x0000555555e6897a in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:254
+ * #14 0x0000555555e68a82 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #15 0x0000555555c28e82 in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #16 0x0000555555814ba2 in main (argc=26, argv=0x7fffffffdd48, envp=0x7fffffffde20) at ../softmmu/main.c:50
+ *
+ * (gdb) bt
+ * #0  scsi_free_request (req=0x555556d47800) at ../hw/scsi/scsi-disk.c:114
+ * #1  0x00005555559a88db in scsi_req_unref (req=0x555556d47800) at ../hw/scsi/scsi-bus.c:1373
+ * #2  0x0000555555a851dc in scsi_dma_complete_noio (r=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:349
+ * #3  0x0000555555a852dd in scsi_dma_complete (opaque=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:366
+ * #4  0x00005555558d9659 in dma_complete (dbs=0x555556d49d40, ret=0) at ../softmmu/dma-helpers.c:121
+ * #5  0x00005555558d9706 in dma_blk_cb (opaque=0x555556d49d40, ret=0) at ../softmmu/dma-helpers.c:139
+ * #6  0x0000555555a8b4e4 in scsi_block_sgio_complete (opaque=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:2714
+ * #7  0x0000555555d6ccc9 in blk_aio_complete (acb=0x5555570a5c60) at ../block/block-backend.c:1412
+ * #8  0x0000555555d6d3a7 in blk_aio_ioctl_entry (opaque=0x5555570a5c60) at ../block/block-backend.c:1596
+ * #9  0x0000555555e6f99a in coroutine_trampoline (i0=-737825824, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #10 0x00007ffff5c8c190 in __start_context () at /lib64/libc.so.6
+ * #11 0x00007ff7ecd34b10 in  ()
+ * #12 0x0000000000000000 in  ()
+ *
+ * SCSIReqOps scsi_disk_emulate_reqops.free_req = scsi_free_request()
+ * SCSIReqOps scsi_disk_dma_reqops.free_req = scsi_free_request()
+ */
 static void scsi_free_request(SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
@@ -118,6 +159,39 @@ static void scsi_free_request(SCSIRequest *req)
 }
 
 /* Helper function for command completion with sense.  */
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|1082| <<scsi_read_disc_information>> scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-disk.c|1123| <<scsi_read_dvd_structure>> scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-disk.c|1129| <<scsi_read_dvd_structure>> scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));
+ *   - hw/scsi/scsi-disk.c|1133| <<scsi_read_dvd_structure>> scsi_check_condition(r, SENSE_CODE(INCOMPATIBLE_FORMAT));
+ *   - hw/scsi/scsi-disk.c|1539| <<scsi_disk_emulate_mode_sense>> scsi_check_condition(r, SENSE_CODE(SAVING_PARAMS_NOT_SUPPORTED));
+ *   - hw/scsi/scsi-disk.c|1621| <<scsi_disk_emulate_start_stop>> scsi_check_condition(r,
+ *   - hw/scsi/scsi-disk.c|1755| <<mode_select_pages>> scsi_check_condition(r, SENSE_CODE(INVALID_PARAM));
+ *   - hw/scsi/scsi-disk.c|1759| <<mode_select_pages>> scsi_check_condition(r, SENSE_CODE(INVALID_PARAM_LEN));
+ *   - hw/scsi/scsi-disk.c|1815| <<scsi_disk_emulate_mode_select>> scsi_check_condition(r, SENSE_CODE(INVALID_PARAM));
+ *   - hw/scsi/scsi-disk.c|1819| <<scsi_disk_emulate_mode_select>> scsi_check_condition(r, SENSE_CODE(INVALID_PARAM_LEN));
+ *   - hw/scsi/scsi-disk.c|1823| <<scsi_disk_emulate_mode_select>> scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-disk.c|1865| <<scsi_unmap_complete_noio>> scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));
+ *   - hw/scsi/scsi-disk.c|1945| <<scsi_disk_emulate_unmap>> scsi_check_condition(r, SENSE_CODE(WRITE_PROTECTED));
+ *   - hw/scsi/scsi-disk.c|1961| <<scsi_disk_emulate_unmap>> scsi_check_condition(r, SENSE_CODE(INVALID_PARAM_LEN));
+ *   - hw/scsi/scsi-disk.c|1966| <<scsi_disk_emulate_unmap>> scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-disk.c|2030| <<scsi_disk_emulate_write_same>> scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-disk.c|2035| <<scsi_disk_emulate_write_same>> scsi_check_condition(r, SENSE_CODE(WRITE_PROTECTED));
+ *   - hw/scsi/scsi-disk.c|2039| <<scsi_disk_emulate_write_same>> scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));
+ *   - hw/scsi/scsi-disk.c|2111| <<scsi_disk_emulate_write_data>> scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-disk.c|2154| <<scsi_disk_emulate_command>> scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));
+ *   - hw/scsi/scsi-disk.c|2236| <<scsi_disk_emulate_command>> scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));
+ *   - hw/scsi/scsi-disk.c|2305| <<scsi_disk_emulate_command>> scsi_check_condition(r, SENSE_CODE(LUN_NOT_READY));
+ *   - hw/scsi/scsi-disk.c|2379| <<scsi_disk_emulate_command>> scsi_check_condition(r, SENSE_CODE(INVALID_OPCODE));
+ *   - hw/scsi/scsi-disk.c|2396| <<scsi_disk_emulate_command>> scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-disk.c|2401| <<scsi_disk_emulate_command>> scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));
+ *   - hw/scsi/scsi-disk.c|2443| <<scsi_disk_dma_command>> scsi_check_condition(r, SENSE_CODE(NO_MEDIUM));
+ *   - hw/scsi/scsi-disk.c|2496| <<scsi_disk_dma_command>> scsi_check_condition(r, SENSE_CODE(WRITE_PROTECTED));
+ *   - hw/scsi/scsi-disk.c|2522| <<scsi_disk_dma_command>> scsi_check_condition(r, SENSE_CODE(INVALID_FIELD));
+ *   - hw/scsi/scsi-disk.c|2525| <<scsi_disk_dma_command>> scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));
+ *   - hw/scsi/scsi-disk.c|3406| <<scsi_block_dma_command>> scsi_check_condition(&r->req, SENSE_CODE(INVALID_FIELD));
+ */
 static void scsi_check_condition(SCSIDiskReq *r, SCSISense sense)
 {
     trace_scsi_disk_check_condition(r->req.tag, sense.key, sense.asc,
@@ -126,6 +200,12 @@ static void scsi_check_condition(SCSIDiskReq *r, SCSISense sense)
     scsi_req_complete(&r->req, CHECK_CONDITION);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|214| <<scsi_disk_load_request>> scsi_init_iovec(r, r->buflen);
+ *   - hw/scsi/scsi-disk.c|541| <<scsi_do_read>> scsi_init_iovec(r, SCSI_DMA_BUF_SIZE);
+ *   - hw/scsi/scsi-disk.c|671| <<scsi_write_complete_noio>> scsi_init_iovec(r, SCSI_DMA_BUF_SIZE);
+ */
 static void scsi_init_iovec(SCSIDiskReq *r, size_t size)
 {
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
@@ -138,6 +218,9 @@ static void scsi_init_iovec(SCSIDiskReq *r, size_t size)
     qemu_iovec_init_external(&r->qiov, &r->iov, 1);
 }
 
+/*
+ * SCSIReqOps scsi_disk_dma_reqops.save_request = scsi_disk_save_request()
+ */
 static void scsi_disk_save_request(QEMUFile *f, SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
@@ -156,6 +239,9 @@ static void scsi_disk_save_request(QEMUFile *f, SCSIRequest *req)
     }
 }
 
+/*
+ * SCSIReqOps scsi_disk_dma_reqops.load_request = scsi_disk_load_request()
+ */
 static void scsi_disk_load_request(QEMUFile *f, SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
@@ -186,6 +272,11 @@ static void scsi_disk_load_request(QEMUFile *f, SCSIRequest *req)
  * scsi_handle_rw_error always manages its reference counts, independent
  * of the return value.
  */
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|341| <<scsi_disk_req_check_error>> return scsi_handle_rw_error(r, ret, acct_failed);
+ *   - hw/scsi/scsi-disk.c|3093| <<scsi_block_sgio_complete>> if (scsi_handle_rw_error(r, ret, true)) {
+ */
 static bool scsi_handle_rw_error(SCSIDiskReq *r, int ret, bool acct_failed)
 {
     bool is_read = (r->req.cmd.mode == SCSI_XFER_FROM_DEV);
@@ -205,6 +296,11 @@ static bool scsi_handle_rw_error(SCSIDiskReq *r, int ret, bool acct_failed)
         status = ret;
         if (status == CHECK_CONDITION) {
             req_has_sense = true;
+            /*
+	     * SCSIDiskReq *r:
+	     * -> SCSIRequest req;
+	     *    -> uint8_t sense[SCSI_SENSE_BUF_SIZE];
+	     */
             error = scsi_sense_buf_to_errno(r->req.sense, sizeof(r->req.sense));
         } else {
             error = EINVAL;
@@ -251,6 +347,32 @@ static bool scsi_handle_rw_error(SCSIDiskReq *r, int ret, bool acct_failed)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  scsi_req_build_sense (req=0x7ff7e4005630, sense=...) at ../hw/scsi/scsi-bus.c:864
+ * #1  0x0000555555a3a42e in scsi_handle_rw_error (r=0x7ff7e4005630, ret=-19, acct_failed=false) at ../hw/scsi/scsi-disk.c:237
+ * #2  0x0000555555a3a4ee in scsi_disk_req_check_error (r=0x7ff7e4005630, ret=-19, acct_failed=false) at ../hw/scsi/scsi-disk.c:262
+ * #3  0x0000555555a3a831 in scsi_dma_complete_noio (r=0x7ff7e4005630, ret=-19) at ../hw/scsi/scsi-disk.c:335
+ * #4  0x0000555555a3a9a3 in scsi_dma_complete (opaque=0x7ff7e4005630, ret=-19) at ../hw/scsi/scsi-disk.c:366
+ * #5  0x000055555587a9be in dma_complete (dbs=0x7ff7e4000f30, ret=-19) at ../softmmu/dma-helpers.c:121
+ * #6  0x000055555587aa6b in dma_blk_cb (opaque=0x7ff7e4000f30, ret=-19) at ../softmmu/dma-helpers.c:139
+ * #7  0x0000555555a40c1a in scsi_block_sgio_complete (opaque=0x7ff7e4005630, ret=-19) at ../hw/scsi/scsi-disk.c:2722
+ * #8  0x0000555555d6f839 in blk_aio_complete (acb=0x7ff7e40074e0) at ../block/block-backend.c:1402
+ * #9  0x0000555555d6ffcf in blk_aio_ioctl_entry (opaque=0x7ff7e40074e0) at ../block/block-backend.c:1589
+ * #10 0x0000555555ec8c30 in coroutine_trampoline (i0=-1476358608, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #11 0x00007ffff5a88190 in __start_context () at /lib64/libc.so.6
+ * #12 0x00007ff7afffd980 in  ()
+ * #13 0x0000000000000000 in  ()
+ *
+ * called by:
+ *   - hw/scsi/scsi-disk.c|329| <<scsi_aio_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+ *   - hw/scsi/scsi-disk.c|388| <<scsi_dma_complete_noio>> if (scsi_disk_req_check_error(r, ret, false)) {
+ *   - hw/scsi/scsi-disk.c|442| <<scsi_read_complete_noio>> if (scsi_disk_req_check_error(r, ret, false)) {
+ *   - hw/scsi/scsi-disk.c|517| <<scsi_do_read>> if (scsi_disk_req_check_error(r, ret, false)) {
+ *   - hw/scsi/scsi-disk.c|666| <<scsi_write_complete_noio>> if (scsi_disk_req_check_error(r, ret, false)) {
+ *   - hw/scsi/scsi-disk.c|1842| <<scsi_unmap_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+ *   - hw/scsi/scsi-disk.c|1920| <<scsi_write_same_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+ */
 static bool scsi_disk_req_check_error(SCSIDiskReq *r, int ret, bool acct_failed)
 {
     if (r->req.io_canceled) {
@@ -329,6 +451,23 @@ static void scsi_write_do_fua(SCSIDiskReq *r)
     scsi_req_unref(&r->req);
 }
 
+/*
+ * (gdb) bt
+ * #0  scsi_req_build_sense (req=0x7ff7e4005630, sense=...) at ../hw/scsi/scsi-bus.c:864
+ * #1  0x0000555555a3a42e in scsi_handle_rw_error (r=0x7ff7e4005630, ret=-19, acct_failed=false) at ../hw/scsi/scsi-disk.c:237
+ * #2  0x0000555555a3a4ee in scsi_disk_req_check_error (r=0x7ff7e4005630, ret=-19, acct_failed=false) at ../hw/scsi/scsi-disk.c:262
+ * #3  0x0000555555a3a831 in scsi_dma_complete_noio (r=0x7ff7e4005630, ret=-19) at ../hw/scsi/scsi-disk.c:335
+ * #4  0x0000555555a3a9a3 in scsi_dma_complete (opaque=0x7ff7e4005630, ret=-19) at ../hw/scsi/scsi-disk.c:366
+ * #5  0x000055555587a9be in dma_complete (dbs=0x7ff7e4000f30, ret=-19) at ../softmmu/dma-helpers.c:121
+ * #6  0x000055555587aa6b in dma_blk_cb (opaque=0x7ff7e4000f30, ret=-19) at ../softmmu/dma-helpers.c:139
+ * #7  0x0000555555a40c1a in scsi_block_sgio_complete (opaque=0x7ff7e4005630, ret=-19) at ../hw/scsi/scsi-disk.c:2722
+ * #8  0x0000555555d6f839 in blk_aio_complete (acb=0x7ff7e40074e0) at ../block/block-backend.c:1402
+ * #9  0x0000555555d6ffcf in blk_aio_ioctl_entry (opaque=0x7ff7e40074e0) at ../block/block-backend.c:1589
+ * #10 0x0000555555ec8c30 in coroutine_trampoline (i0=-1476358608, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #11 0x00007ffff5a88190 in __start_context () at /lib64/libc.so.6
+ * #12 0x00007ff7afffd980 in  ()
+ * #13 0x0000000000000000 in  ()
+ */
 static void scsi_dma_complete_noio(SCSIDiskReq *r, int ret)
 {
     assert(r->req.aiocb == NULL);
@@ -349,6 +488,32 @@ done:
     scsi_req_unref(&r->req);
 }
 
+/*
+ * (gdb) bt
+ * #0  0x0000555555a851ee in scsi_dma_complete (opaque=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:353
+ * #1  0x00005555558d9659 in dma_complete (dbs=0x555557094340, ret=0) at ../softmmu/dma-helpers.c:121
+ * #2  0x00005555558d9706 in dma_blk_cb (opaque=0x555557094340, ret=0) at ../softmmu/dma-helpers.c:139
+ * #3  0x0000555555a8b4e4 in scsi_block_sgio_complete (opaque=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:2714
+ * #4  0x0000555555d6ccc9 in blk_aio_complete (acb=0x5555570a5c60) at ../block/block-backend.c:1412
+ * #5  0x0000555555d6d3a7 in blk_aio_ioctl_entry (opaque=0x5555570a5c60) at ../block/block-backend.c:1596
+ * #6  0x0000555555e6f99a in coroutine_trampoline (i0=-536823856, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #7  0x00007ffff5c8c190 in __start_context () at /lib64/libc.so.6
+ * #8  0x00007ff7ef539b10 in  ()
+ * #9  0x0000000000000000 in  ()
+ *
+ * called by:
+ *   - hw/scsi/scsi-disk.c|456| <<scsi_do_read>> sdc->dma_readv, r, scsi_dma_complete, r,
+ *   - hw/scsi/scsi-disk.c|622| <<scsi_write_data>> sdc->dma_writev, r, scsi_dma_complete, r,
+ *
+ * 458         r->req.aiocb = dma_blk_io(blk_get_aio_context(s->qdev.conf.blk),
+ * 459                                   r->req.sg, r->sector << BDRV_SECTOR_BITS,
+ * 460                                   BDRV_SECTOR_SIZE,
+ * 461                                   sdc->dma_readv, r, scsi_dma_complete, r,
+ * 462                                   DMA_DIRECTION_FROM_DEVICE);
+ *
+ * 640         r->req.aiocb = sdc->dma_writev(r->sector << BDRV_SECTOR_BITS, &r->qiov,
+ * 641                                        scsi_write_complete, r, r);
+ */
 static void scsi_dma_complete(void *opaque, int ret)
 {
     SCSIDiskReq *r = (SCSIDiskReq *)opaque;
@@ -367,6 +532,12 @@ static void scsi_dma_complete(void *opaque, int ret)
     aio_context_release(blk_get_aio_context(s->qdev.conf.blk));
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|491| <<scsi_read_complete>> scsi_read_complete_noio(r, ret);
+ *   - hw/scsi/scsi-disk.c|651| <<scsi_read_data>> scsi_read_complete_noio(r, -EINVAL);
+ *   - hw/scsi/scsi-disk.c|656| <<scsi_read_data>> scsi_read_complete_noio(r, -ENOMEDIUM);
+ */
 static void scsi_read_complete_noio(SCSIDiskReq *r, int ret)
 {
     uint32_t n;
@@ -385,6 +556,17 @@ done:
     scsi_req_unref(&r->req);
 }
 
+/*
+ * 在scsi-disk.c的定义:
+ *   - hw/scsi/scsi-disk.c|388| <<scsi_read_complete>> static void scsi_read_complete(void *opaque, int ret)
+ * 在scsi-disk.c的使用:
+ *   - hw/scsi/scsi-disk.c|439| <<scsi_do_read>> r->req.aiocb = sdc->dma_readv(r->sector << BDRV_SECTOR_BITS, &r->qiov, scsi_read_complete, r, r);
+ *
+ * 在scsi-generic.c的定义:
+ *   - hw/scsi/scsi-generic.c|252| <<scsi_read_complete>> static void scsi_read_complete(void * opaque, int ret)
+ * 在scsi-generic.c的使用:
+ *   - hw/scsi/scsi-generic.c|363| <<scsi_read_data>> ret = execute_command(s->conf.blk, r, SG_DXFER_FROM_DEV, scsi_read_complete);
+ */
 static void scsi_read_complete(void *opaque, int ret)
 {
     SCSIDiskReq *r = (SCSIDiskReq *)opaque;
@@ -405,6 +587,31 @@ static void scsi_read_complete(void *opaque, int ret)
 }
 
 /* Actually issue a read to the block device.  */
+/*
+ * (gdb) bt
+ * #0  scsi_do_read (r=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:409
+ * #1  0x0000555555a85a6a in scsi_read_data (req=0x555556d47800) at ../hw/scsi/scsi-disk.c:496
+ * #2  0x00005555559a89c5 in scsi_req_continue (req=0x555556d47800) at ../hw/scsi/scsi-bus.c:1393
+ * #3  0x0000555555b8ebc8 in virtio_scsi_handle_cmd_req_submit (s=0x5555577e0680, req=0x5555570338a0) at ../hw/scsi/virtio-scsi.c:624
+ * #4  0x0000555555b8ee24 in virtio_scsi_handle_cmd_vq (s=0x5555577e0680, vq=0x5555577e82d0) at ../hw/scsi/virtio-scsi.c:668
+ * #5  0x0000555555c6d983 in virtio_scsi_data_plane_handle_cmd (vdev=0x5555577e0680, vq=0x5555577e82d0) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #6  0x0000555555c88332 in virtio_queue_notify_aio_vq (vq=0x5555577e82d0) at ../hw/virtio/virtio.c:2326
+ * #7  0x0000555555c8b175 in virtio_queue_host_notifier_aio_read (n=0x5555577e834c) at ../hw/virtio/virtio.c:3533
+ * #8  0x0000555555e6e50b in aio_dispatch_handler (ctx=0x5555567358b0, node=0x7ff7b401fd90) at ../util/aio-posix.c:329
+ * #9  0x0000555555e6e6c4 in aio_dispatch_handlers (ctx=0x5555567358b0) at ../util/aio-posix.c:372
+ * #10 0x0000555555e6e71a in aio_dispatch (ctx=0x5555567358b0) at ../util/aio-posix.c:382
+ * #11 0x0000555555e7dad0 in aio_ctx_dispatch (source=0x5555567358b0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #12 0x00007ffff7652119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #13 0x0000555555e68900 in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #14 0x0000555555e6897a in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:254
+ * #15 0x0000555555e68a82 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #16 0x0000555555c28e82 in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #17 0x0000555555814ba2 in main (argc=26, argv=0x7fffffffdd48, envp=0x7fffffffde20) at ../softmmu/main.c:50
+ *
+ * called by:
+ *   - hw/scsi/scsi-disk.c|455| <<scsi_do_read_cb>> scsi_do_read(opaque, ret);
+ *   - hw/scsi/scsi-disk.c|496| <<scsi_read_data>> scsi_do_read(r, 0);
+ */
 static void scsi_do_read(SCSIDiskReq *r, int ret)
 {
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
@@ -418,9 +625,23 @@ static void scsi_do_read(SCSIDiskReq *r, int ret)
     /* The request is used as the AIO opaque value, so add a ref.  */
     scsi_req_ref(&r->req);
 
+    /*
+     * 测试scsi-block的使用r->req.sg != NULL
+     */
     if (r->req.sg) {
         dma_acct_start(s->qdev.conf.blk, &r->acct, r->req.sg, BLOCK_ACCT_READ);
         r->req.resid -= r->req.sg->size;
+        /*
+	 * 在以下调用dma_blk_io():
+	 *   - hw/ide/core.c|943| <<ide_dma_cb>> s->bus->dma->aiocb = dma_blk_io(blk_get_aio_context(s->blk),
+	 *   - hw/ide/macio.c|193| <<pmac_ide_transfer_cb>> s->bus->dma->aiocb = dma_blk_io(blk_get_aio_context(s->blk), &s->sg,
+	 *   - hw/scsi/scsi-disk.c|453| <<scsi_do_read>> r->req.aiocb = dma_blk_io(blk_get_aio_context(s->qdev.conf.blk),
+	 *   - hw/scsi/scsi-disk.c|619| <<scsi_write_data>> r->req.aiocb = dma_blk_io(blk_get_aio_context(s->qdev.conf.blk),
+	 *   - softmmu/dma-helpers.c|273| <<dma_blk_read>> return dma_blk_io(blk_get_aio_context(blk), sg, offset, align,
+	 *   - softmmu/dma-helpers.c|291| <<dma_blk_write>> return dma_blk_io(blk_get_aio_context(blk), sg, offset, align,
+	 *
+	 * 在scsi-block的使用sdc->dma_readv = scsi_block_dma_readv()
+	 */
         r->req.aiocb = dma_blk_io(blk_get_aio_context(s->qdev.conf.blk),
                                   r->req.sg, r->sector << BDRV_SECTOR_BITS,
                                   BDRV_SECTOR_SIZE,
@@ -456,7 +677,51 @@ static void scsi_do_read_cb(void *opaque, int ret)
     aio_context_release(blk_get_aio_context(s->qdev.conf.blk));
 }
 
+/*
+ * SCSIDiskReq *r:
+ * -> SCSIRequest req;
+ *    -> SCSIBus           *bus;
+ *    -> SCSIDevice        *dev;
+ *    -> const SCSIReqOps  *ops;
+ *    -> uint32_t          refcount;
+ *    -> uint32_t          tag;
+ *    ->uint32_t          lun;
+ *    ->int16_t           status;
+ *    -> SCSICommand       cmd;
+ *       -> uint8_t buf[SCSI_CMD_BUF_SIZE];
+ *       -> int len;
+ *       -> size_t xfer;
+ *       -> uint64_t lba;
+ *       -> enum SCSIXferMode mode;
+ * -> uint64_t sector;
+ * -> uint32_t sector_count;
+ * -> uint32_t buflen;
+ * -> bool started;
+ */
+
 /* Read more data from scsi device into buffer.  */
+/*
+ * (gdb) bt
+ * #0  scsi_read_data (req=0x5555573bc400) at ../hw/scsi/scsi-disk.c:461
+ * #1  0x00005555559a89c5 in scsi_req_continue (req=0x5555573bc400) at ../hw/scsi/scsi-bus.c:1393
+ * #2  0x0000555555b8ebc8 in virtio_scsi_handle_cmd_req_submit (s=0x5555577dfb80, req=0x5555577e07d0) at ../hw/scsi/virtio-scsi.c:624
+ * #3  0x0000555555b8ee24 in virtio_scsi_handle_cmd_vq (s=0x5555577dfb80, vq=0x5555577e7690) at ../hw/scsi/virtio-scsi.c:668
+ * #4  0x0000555555c6d983 in virtio_scsi_data_plane_handle_cmd (vdev=0x5555577dfb80, vq=0x5555577e7690) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #5  0x0000555555c88332 in virtio_queue_notify_aio_vq (vq=0x5555577e7690) at ../hw/virtio/virtio.c:2326
+ * #6  0x0000555555c8b175 in virtio_queue_host_notifier_aio_read (n=0x5555577e770c) at ../hw/virtio/virtio.c:3533
+ * #7  0x0000555555e6e50b in aio_dispatch_handler (ctx=0x5555567358b0, node=0x7ff7d8007e00) at ../util/aio-posix.c:329
+ * #8  0x0000555555e6e6c4 in aio_dispatch_handlers (ctx=0x5555567358b0) at ../util/aio-posix.c:372
+ * #9  0x0000555555e6e71a in aio_dispatch (ctx=0x5555567358b0) at ../util/aio-posix.c:382
+ * #10 0x0000555555e7dad0 in aio_ctx_dispatch (source=0x5555567358b0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #11 0x00007ffff7652119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #12 0x0000555555e68900 in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #13 0x0000555555e6897a in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:254
+ * #14 0x0000555555e68a82 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #15 0x0000555555c28e82 in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #16 0x0000555555814ba2 in main (argc=26, argv=0x7fffffffdd48, envp=0x7fffffffde20) at ../softmmu/main.c:50
+ *
+ * SCSIReqOps scsi_disk_dma_reqops.read_data = scsi_read_data()
+ */
 static void scsi_read_data(SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
@@ -540,6 +805,9 @@ static void scsi_write_complete(void * opaque, int ret)
     aio_context_release(blk_get_aio_context(s->qdev.conf.blk));
 }
 
+/*
+ * SCSIReqOps scsi_disk_dma_reqops.write_data = scsi_write_data()
+ */
 static void scsi_write_data(SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
@@ -595,6 +863,10 @@ static void scsi_write_data(SCSIRequest *req)
 }
 
 /* Return a pointer to the data buffer.  */
+/*
+ * SCSIReqOps scsi_disk_emulate_reqops.get_buf = scsi_get_buf()
+ * SCSIReqOps scsi_disk_dma_reqops.get_buf = scsi_get_buf()
+ */
 static uint8_t *scsi_get_buf(SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
@@ -1332,6 +1604,10 @@ static int scsi_disk_emulate_mode_sense(SCSIDiskReq *r, uint8_t *outbuf)
     return buflen;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|1989| <<scsi_disk_emulate_command>> buflen = scsi_disk_emulate_read_toc(req, outbuf);
+ */
 static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)
 {
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
@@ -1395,6 +1671,9 @@ static int scsi_disk_emulate_start_stop(SCSIDiskReq *r)
     return 0;
 }
 
+/*
+ * SCSIReqOps scsi_disk_emulate_reqops.read_data = scsi_disk_emulate_read_data()
+ */
 static void scsi_disk_emulate_read_data(SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
@@ -1645,6 +1924,15 @@ done:
     g_free(data);
 }
 
+/*
+ * 在以下使用scsi_unmap_complete():
+ *   - hw/scsi/scsi-disk.c|1677| <<scsi_unmap_complete_noio>> scsi_unmap_complete, data);
+ *
+ * 1674         r->req.aiocb = blk_aio_pdiscard(s->qdev.conf.blk,
+ * 1675                                         r->sector * BDRV_SECTOR_SIZE,
+ * 1676                                         r->sector_count * BDRV_SECTOR_SIZE,
+ * 1677                                         scsi_unmap_complete, data);
+ */
 static void scsi_unmap_complete(void *opaque, int ret)
 {
     UnmapCBData *data = opaque;
@@ -1828,6 +2116,9 @@ static void scsi_disk_emulate_write_same(SCSIDiskReq *r, uint8_t *inbuf)
                                    scsi_write_same_complete, data);
 }
 
+/*
+ * SCSIReqOps scsi_disk_emulate_reqops.write_data = scsi_disk_emulate_write_data()
+ */
 static void scsi_disk_emulate_write_data(SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
@@ -1869,6 +2160,9 @@ static void scsi_disk_emulate_write_data(SCSIRequest *req)
     }
 }
 
+/*
+ * SCSIReqOps scsi_disk_emulate_reqops.send_command = scsi_disk_emulate_command()
+ */
 static int32_t scsi_disk_emulate_command(SCSIRequest *req, uint8_t *buf)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
@@ -2151,6 +2445,28 @@ illegal_lba:
    (eg. disk reads), negative for transfers to the device (eg. disk writes),
    and zero if the command does not transfer any data.  */
 
+/*
+ * (gdb) bt
+ * #0  scsi_disk_dma_command (req=0x555556c5e0e0, buf=0x555556c5e118 "(") at ../hw/scsi/scsi-disk.c:2155
+ * #1  0x00005555559a791f in scsi_req_enqueue (req=0x555556c5e0e0) at ../hw/scsi/scsi-bus.c:888
+ * #2  0x0000555555b8ebb8 in virtio_scsi_handle_cmd_req_submit (s=0x5555577dfb80, req=0x5555573bc400) at ../hw/scsi/virtio-scsi.c:623
+ * #3  0x0000555555b8ee24 in virtio_scsi_handle_cmd_vq (s=0x5555577dfb80, vq=0x5555577e77d0) at ../hw/scsi/virtio-scsi.c:668
+ * #4  0x0000555555c6d983 in virtio_scsi_data_plane_handle_cmd (vdev=0x5555577dfb80, vq=0x5555577e77d0) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #5  0x0000555555c88332 in virtio_queue_notify_aio_vq (vq=0x5555577e77d0) at ../hw/virtio/virtio.c:2326
+ * #6  0x0000555555c8b175 in virtio_queue_host_notifier_aio_read (n=0x5555577e784c) at ../hw/virtio/virtio.c:3533
+ * #7  0x0000555555e6e50b in aio_dispatch_handler (ctx=0x5555567358b0, node=0x7ff7d80083f0) at ../util/aio-posix.c:329
+ * #8  0x0000555555e6e6c4 in aio_dispatch_handlers (ctx=0x5555567358b0) at ../util/aio-posix.c:372
+ * #9  0x0000555555e6e71a in aio_dispatch (ctx=0x5555567358b0) at ../util/aio-posix.c:382
+ * #10 0x0000555555e7dad0 in aio_ctx_dispatch (source=0x5555567358b0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #11 0x00007ffff7652119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #12 0x0000555555e68900 in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #13 0x0000555555e6897a in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:254
+ * #14 0x0000555555e68a82 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #15 0x0000555555c28e82 in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #16 0x0000555555814ba2 in main (argc=26, argv=0x7fffffffdd48, envp=0x7fffffffde20) at ../softmmu/main.c:50
+ *
+ * SCSIReqOps scsi_disk_dma_reqops.send_command = scsi_disk_dma_comman()
+ */
 static int32_t scsi_disk_dma_command(SCSIRequest *req, uint8_t *buf)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
@@ -2183,6 +2499,27 @@ static int32_t scsi_disk_dma_command(SCSIRequest *req, uint8_t *buf)
         if (!check_lba_range(s, r->req.cmd.lba, len)) {
             goto illegal_lba;
         }
+        /*
+	 * SCSIDiskReq *r:
+	 * -> SCSIRequest req;
+	 *    -> SCSIBus           *bus;
+	 *    -> SCSIDevice        *dev;
+	 *    -> const SCSIReqOps  *ops;
+	 *    -> uint32_t          refcount;
+	 *    -> uint32_t          tag;
+	 *    ->uint32_t          lun;
+	 *    ->int16_t           status;
+	 *    -> SCSICommand       cmd;
+	 *       -> uint8_t buf[SCSI_CMD_BUF_SIZE];
+	 *       -> int len;
+	 *       -> size_t xfer;
+	 *       -> uint64_t lba;
+	 *       -> enum SCSIXferMode mode;
+	 * -> uint64_t sector;
+	 * -> uint32_t sector_count;
+	 * -> uint32_t buflen;
+	 * -> bool started;
+	 */
         r->sector = r->req.cmd.lba * (s->qdev.blocksize / BDRV_SECTOR_SIZE);
         r->sector_count = len * (s->qdev.blocksize / BDRV_SECTOR_SIZE);
         break;
@@ -2320,6 +2657,10 @@ static const BlockDevOps scsi_disk_removable_block_ops = {
     .resize_cb = scsi_disk_resize_cb,
 };
 
+/*
+ * 在以下使用scsi_disk_block_ops:
+ *   - hw/scsi/scsi-disk.c|2435| <<scsi_realize>> blk_set_dev_ops(s->qdev.conf.blk, &scsi_disk_block_ops, s);
+ */
 static const BlockDevOps scsi_disk_block_ops = {
     .resize_cb = scsi_disk_resize_cb,
 };
@@ -2333,6 +2674,12 @@ static void scsi_disk_unit_attention_reported(SCSIDevice *dev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|2465| <<scsi_hd_realize>> scsi_realize(&s->qdev, errp);
+ *   - hw/scsi/scsi-disk.c|2494| <<scsi_cd_realize>> scsi_realize(&s->qdev, errp);
+ *   - hw/scsi/scsi-disk.c|2744| <<scsi_block_realize>> scsi_realize(&s->qdev, errp);
+ */
 static void scsi_realize(SCSIDevice *dev, Error **errp)
 {
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);
@@ -2424,6 +2771,28 @@ static void scsi_unrealize(SCSIDevice *dev)
     del_boot_device_lchs(&dev->qdev, NULL);
 }
 
+/*
+ * (gdb) bt
+ * #0  scsi_hd_realize (dev=0x5555578e0f00, errp=0x7fffffffd840) at ../hw/scsi/scsi-disk.c:2428
+ * #1  0x0000555555a7e085 in scsi_device_realize (s=0x5555578e0f00, errp=0x7fffffffd840) at ../hw/scsi/scsi-bus.c:91
+ * #2  0x0000555555a7e997 in scsi_qdev_realize (qdev=0x5555578e0f00, errp=0x7fffffffd8b0) at ../hw/scsi/scsi-bus.c:282
+ * #3  0x0000555555dddf92 in device_set_realized (obj=0x5555578e0f00, value=true, errp=0x7fffffffd9b8) at ../hw/core/qdev.c:761
+ * #4  0x0000555555cdef50 in property_set_bool (obj=0x5555578e0f00, v=0x5555578e12e0, name=0x555556069f41 "realized", opaque=0x55555673b9c0, errp=0x7fffffffd9b8) at ../qom/object.c:2257
+ * #5  0x0000555555cdd047 in object_property_set (obj=0x5555578e0f00, name=0x555556069f41 "realized", v=0x5555578e12e0, errp=0x5555566c8a90 <error_fatal>) at ../qom/object.c:1402
+ * #6  0x0000555555cd9a3b in object_property_set_qobject (obj=0x5555578e0f00, name=0x555556069f41 "realized", value=0x5555578e12c0, errp=0x5555566c8a90 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #7  0x0000555555cdd3aa in object_property_set_bool (obj=0x5555578e0f00, name=0x555556069f41 "realized", value=true, errp=0x5555566c8a90 <error_fatal>) at ../qom/object.c:1472
+ * #8  0x0000555555ddd01d in qdev_realize (dev=0x5555578e0f00, bus=0x55555777db00, errp=0x5555566c8a90 <error_fatal>) at ../hw/core/qdev.c:389
+ * #9  0x0000555555abd739 in qdev_device_add (opts=0x555556734f00, errp=0x5555566c8a90 <error_fatal>) at ../softmmu/qdev-monitor.c:674
+ * #10 0x0000555555cba109 in device_init_func (opaque=0x0, opts=0x555556734f00, errp=0x5555566c8a90 <error_fatal>) at ../softmmu/vl.c:1211
+ * #11 0x0000555555e8025f in qemu_opts_foreach (list=0x5555565ea200 <qemu_device_opts>, func=0x555555cba0e2 <device_init_func>, opaque=0x0, errp=0x5555566c8a90 <error_fatal>) at ../util/qemu-option.c:1167
+ * #12 0x0000555555cbd1e7 in qemu_create_cli_devices () at ../softmmu/vl.c:2541
+ * #13 0x0000555555cbd30a in qmp_x_exit_preconfig (errp=0x5555566c8a90 <error_fatal>) at ../softmmu/vl.c:2589
+ * #14 0x0000555555cbfa18 in qemu_init (argc=18, argv=0x7fffffffde38, envp=0x7fffffffded0) at ../softmmu/vl.c:3611
+ * #15 0x0000555555814b9d in main (argc=18, argv=0x7fffffffde38, envp=0x7fffffffded0) at ../softmmu/main.c:49
+ *
+ * 在以下使用scsi_hd_realize():
+ *   - hw/scsi/scsi-disk.c|3161| <<scsi_hd_class_initfn>> sc->realize = scsi_hd_realize;
+ */
 static void scsi_hd_realize(SCSIDevice *dev, Error **errp)
 {
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);
@@ -2477,6 +2846,38 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
 }
 
 
+/*
+ * 在以下使用scsi_disk_reqops_dispatch[256]:
+ *   - hw/scsi/scsi-disk.c|2597| <<scsi_new_request>> ops = scsi_disk_reqops_dispatch[command];
+ *
+ * 在以下使用scsi_disk_emulate_reqops:
+ *   - hw/scsi/scsi-disk.c|2603| <<scsi_new_request>> ops = &scsi_disk_emulate_reqops;
+ *   - hw/scsi/scsi-disk.c|2524| scsi_disk_reqops_dispatch[TEST_UNIT_READY] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2525| scsi_disk_reqops_dispatch[INQUIRY] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2526| scsi_disk_reqops_dispatch[MODE_SENSE] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2527| scsi_disk_reqops_dispatch[MODE_SENSE_10] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2528| scsi_disk_reqops_dispatch[START_STOP] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2529| scsi_disk_reqops_dispatch[ALLOW_MEDIUM_REMOVAL] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2530| scsi_disk_reqops_dispatch[READ_CAPACITY_10] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2531| scsi_disk_reqops_dispatch[READ_TOC] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2532| scsi_disk_reqops_dispatch[READ_DVD_STRUCTURE] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2533| scsi_disk_reqops_dispatch[READ_DISC_INFORMATION] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2534| scsi_disk_reqops_dispatch[GET_CONFIGURATION] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2535| scsi_disk_reqops_dispatch[GET_EVENT_STATUS_NOTIFICATION] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2536| scsi_disk_reqops_dispatch[MECHANISM_STATUS] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2537| scsi_disk_reqops_dispatch[SERVICE_ACTION_IN_16] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2538| scsi_disk_reqops_dispatch[REQUEST_SENSE] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2539| scsi_disk_reqops_dispatch[SYNCHRONIZE_CACHE] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2540| scsi_disk_reqops_dispatch[SEEK_10] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2541| scsi_disk_reqops_dispatch[MODE_SELECT] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2542| scsi_disk_reqops_dispatch[MODE_SELECT_10] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2543| scsi_disk_reqops_dispatch[UNMAP] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2544| scsi_disk_reqops_dispatch[WRITE_SAME_10] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2545| scsi_disk_reqops_dispatch[WRITE_SAME_16] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2546| scsi_disk_reqops_dispatch[VERIFY_10] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2547| scsi_disk_reqops_dispatch[VERIFY_12] = &scsi_disk_emulate_reqops,
+ *   - hw/scsi/scsi-disk.c|2548| scsi_disk_reqops_dispatch[VERIFY_16] = &scsi_disk_emulate_reqops,
+ */
 static const SCSIReqOps scsi_disk_emulate_reqops = {
     .size         = sizeof(SCSIDiskReq),
     .free_req     = scsi_free_request,
@@ -2486,6 +2887,23 @@ static const SCSIReqOps scsi_disk_emulate_reqops = {
     .get_buf      = scsi_get_buf,
 };
 
+/*
+ * 在以下使用scsi_disk_reqops_dispatch[256]:
+ *   - hw/scsi/scsi-disk.c|2597| <<scsi_new_request>> ops = scsi_disk_reqops_dispatch[command];
+ *
+ * 在以下使用scsi_disk_dma_reqops:
+ *   - hw/scsi/scsi-disk.c|2550| scsi_disk_reqops_dispatch[READ_6] = &scsi_disk_dma_reqops,
+ *   - hw/scsi/scsi-disk.c|2551| scsi_disk_reqops_dispatch[READ_10] = &scsi_disk_dma_reqops,
+ *   - hw/scsi/scsi-disk.c|2552| scsi_disk_reqops_dispatch[READ_12] = &scsi_disk_dma_reqops,
+ *   - hw/scsi/scsi-disk.c|2553| scsi_disk_reqops_dispatch[READ_16] = &scsi_disk_dma_reqops,
+ *   - hw/scsi/scsi-disk.c|2554| scsi_disk_reqops_dispatch[WRITE_6] = &scsi_disk_dma_reqops,
+ *   - hw/scsi/scsi-disk.c|2555| scsi_disk_reqops_dispatch[WRITE_10] = &scsi_disk_dma_reqops,
+ *   - hw/scsi/scsi-disk.c|2556| scsi_disk_reqops_dispatch[WRITE_12] = &scsi_disk_dma_reqops,
+ *   - hw/scsi/scsi-disk.c|2557| scsi_disk_reqops_dispatch[WRITE_16] = &scsi_disk_dma_reqops,
+ *   - hw/scsi/scsi-disk.c|2558| scsi_disk_reqops_dispatch[WRITE_VERIFY_10] = &scsi_disk_dma_reqops,
+ *   - hw/scsi/scsi-disk.c|2559| scsi_disk_reqops_dispatch[WRITE_VERIFY_12] = &scsi_disk_dma_reqops,
+ *   - hw/scsi/scsi-disk.c|2560| scsi_disk_reqops_dispatch[WRITE_VERIFY_16] = &scsi_disk_dma_reqops,
+ */
 static const SCSIReqOps scsi_disk_dma_reqops = {
     .size         = sizeof(SCSIDiskReq),
     .free_req     = scsi_free_request,
@@ -2497,6 +2915,10 @@ static const SCSIReqOps scsi_disk_dma_reqops = {
     .save_request = scsi_disk_save_request,
 };
 
+/*
+ * 在以下使用scsi_disk_reqops_dispatch[256]:
+ *   - hw/scsi/scsi-disk.c|2597| <<scsi_new_request>> ops = scsi_disk_reqops_dispatch[command];
+ */
 static const SCSIReqOps *const scsi_disk_reqops_dispatch[256] = {
     [TEST_UNIT_READY]                 = &scsi_disk_emulate_reqops,
     [INQUIRY]                         = &scsi_disk_emulate_reqops,
@@ -2554,6 +2976,18 @@ static void scsi_disk_new_request_dump(uint32_t lun, uint32_t tag, uint8_t *buf)
     g_free(line_buffer);
 }
 
+/*
+ * 在scsi-disk.c的定义:
+ *   - hw/scsi/scsi-disk.c|2562| <<scsi_new_request>> static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag, uint32_t lun,
+ * 在scsi-disk.c的使用:
+ *   - hw/scsi/scsi-disk.c|3061| <<scsi_hd_class_initfn>> sc->alloc_req = scsi_new_request;
+ *   - hw/scsi/scsi-disk.c|3092| <<scsi_cd_class_initfn>> sc->alloc_req = scsi_new_request;
+ *
+ * 在scsi-generic.c的定义:
+ *   - hw/scsi/scsi-generic.c|766| <<scsi_new_request>> static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag, uint32_t lun,
+ * 在scsi-generic.c的使用:
+ *   - hw/scsi/scsi-generic.c|792| <<scsi_generic_class_initfn>> sc->alloc_req = scsi_new_request;
+ */
 static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag, uint32_t lun,
                                      uint8_t *buf, void *hba_private)
 {
@@ -2677,15 +3111,63 @@ typedef struct SCSIBlockReq {
     void *cb_opaque;
 } SCSIBlockReq;
 
+/*
+ * (gdb) bt
+ * #0  scsi_free_request (req=0x555556d47800) at ../hw/scsi/scsi-disk.c:114
+ * #1  0x00005555559a88db in scsi_req_unref (req=0x555556d47800) at ../hw/scsi/scsi-bus.c:1373
+ * #2  0x0000555555a851dc in scsi_dma_complete_noio (r=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:349
+ * #3  0x0000555555a852dd in scsi_dma_complete (opaque=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:366
+ * #4  0x00005555558d9659 in dma_complete (dbs=0x555556d49d40, ret=0) at ../softmmu/dma-helpers.c:121
+ * #5  0x00005555558d9706 in dma_blk_cb (opaque=0x555556d49d40, ret=0) at ../softmmu/dma-helpers.c:139
+ * #6  0x0000555555a8b4e4 in scsi_block_sgio_complete (opaque=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:2714
+ * #7  0x0000555555d6ccc9 in blk_aio_complete (acb=0x5555570a5c60) at ../block/block-backend.c:1412
+ * #8  0x0000555555d6d3a7 in blk_aio_ioctl_entry (opaque=0x5555570a5c60) at ../block/block-backend.c:1596
+ * #9  0x0000555555e6f99a in coroutine_trampoline (i0=-737825824, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #10 0x00007ffff5c8c190 in __start_context () at /lib64/libc.so.6
+ * #11 0x00007ff7ecd34b10 in  ()
+ * #12 0x0000000000000000 in  ()
+ *
+ * (gdb) bt
+ * #0  scsi_block_sgio_complete (opaque=0x5555576e3740, ret=0) at ../hw/scsi/scsi-disk.c:2681
+ * #1  0x0000555555d6ccc9 in blk_aio_complete (acb=0x555556d4eba0) at ../block/block-backend.c:1412
+ * #2  0x0000555555d6d3a7 in blk_aio_ioctl_entry (opaque=0x555556d4eba0) at ../block/block-backend.c:1596
+ * #3  0x0000555555e6f99a in coroutine_trampoline (i0=-536867360, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #4  0x00007ffff5c8c190 in __start_context () at /lib64/libc.so.6
+ * #5  0x00007ff7ef539b10 in  ()
+ * #6  0x0000000000000000 in  ()
+ *
+ * 如果是bk_aio_complete()来的, ret来自
+ * BlkAioEmAIOCB *acb:
+ * -> BlkRwCo rwco;
+ *    -> int ret;
+ *
+ * 在以下使用scsi_block_sgio_complete():
+ *   - hw/scsi/scsi-disk.c|3142| <<scsi_block_do_sgio>> aiocb = blk_aio_ioctl(s->qdev.conf.blk, SG_IO, io_header, scsi_block_sgio_complete, req);
+ */
 static void scsi_block_sgio_complete(void *opaque, int ret)
 {
     SCSIBlockReq *req = (SCSIBlockReq *)opaque;
     SCSIDiskReq *r = &req->req;
     SCSIDevice *s = r->req.dev;
+    /*
+     * typedef struct sg_io_hdr:
+     * -> unsigned short int host_status;
+     */
     sg_io_hdr_t *io_hdr = &req->io_header;
 
     if (ret == 0) {
+        /*
+	 * 在以下设置SCSIRequest->host_status:
+	 *   - hw/scsi/scsi-bus.c|729| <<scsi_req_alloc>> req->host_status = -1;
+	 *   - hw/scsi/scsi-bus.c|1622| <<scsi_req_complete_failed>> req->host_status = host_status;
+	 *   - hw/scsi/scsi-bus.c|1672| <<scsi_req_complete>> req->host_status = SCSI_HOST_OK;
+	 */
         if (io_hdr->host_status != SCSI_HOST_OK) {
+            /*
+	     * 在以下调用scsi_req_complete_failed():
+	     *   - hw/scsi/scsi-disk.c|3014| <<scsi_block_sgio_complete>> scsi_req_complete_failed(&r->req, io_hdr->host_status);
+	     *   - hw/scsi/scsi-generic.c|92| <<scsi_command_complete_noio>> scsi_req_complete_failed(&r->req, io_hdr->host_status);
+	     */
             scsi_req_complete_failed(&r->req, io_hdr->host_status);
             scsi_req_unref(&r->req);
             return;
@@ -2711,9 +3193,43 @@ static void scsi_block_sgio_complete(void *opaque, int ret)
         }
     }
 
+    /*
+     * scsi-block READ_10的使用是dma_blk_cb()
+     */
     req->cb(req->cb_opaque, ret);
 }
 
+/*
+ * (gdb) bt
+ * #0  scsi_block_do_sgio (req=0x555556d47800, offset=0, iov=0x55555763efb0, direction=-3, cb=0x5555558d9678 <dma_blk_cb>, opaque=0x55555763ef50) at ../hw/scsi/scsi-disk.c:2721
+ * #1  0x0000555555a8ba63 in scsi_block_dma_readv (offset=0, iov=0x55555763efb0, cb=0x5555558d9678 <dma_blk_cb>, cb_opaque=0x55555763ef50, opaque=0x555556d47800) at ../hw/scsi/scsi-disk.c:2815
+ * #2  0x00005555558d9a12 in dma_blk_cb (opaque=0x55555763ef50, ret=0) at ../softmmu/dma-helpers.c:191
+ * #3  0x00005555558d9c8e in dma_blk_io (ctx=0x5555567358b0, sg=0x5555570338e8, offset=0, align=512, io_func=0x555555a8ba18 <scsi_block_dma_readv>,
+ *                                       io_func_opaque=0x555556d47800, cb=0x555555a851de <scsi_dma_complete>, opaque=0x555556d47800, dir=DMA_DIRECTION_FROM_DEVICE)
+ *                                       at ../softmmu/dma-helpers.c:255
+ * #4  0x0000555555a8569d in scsi_do_read (r=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:424
+ * #5  0x0000555555a85a6a in scsi_read_data (req=0x555556d47800) at ../hw/scsi/scsi-disk.c:496
+ * #6  0x00005555559a89c5 in scsi_req_continue (req=0x555556d47800) at ../hw/scsi/scsi-bus.c:1393
+ * #7  0x0000555555b8ebc8 in virtio_scsi_handle_cmd_req_submit (s=0x5555577e0680, req=0x5555570338a0) at ../hw/scsi/virtio-scsi.c:624
+ * #8  0x0000555555b8ee24 in virtio_scsi_handle_cmd_vq (s=0x5555577e0680, vq=0x5555577e82d0) at ../hw/scsi/virtio-scsi.c:668
+ * #9  0x0000555555c6d983 in virtio_scsi_data_plane_handle_cmd (vdev=0x5555577e0680, vq=0x5555577e82d0) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #10 0x0000555555c88332 in virtio_queue_notify_aio_vq (vq=0x5555577e82d0) at ../hw/virtio/virtio.c:2326
+ * #11 0x0000555555c8b175 in virtio_queue_host_notifier_aio_read (n=0x5555577e834c) at ../hw/virtio/virtio.c:3533
+ * #12 0x0000555555e6e50b in aio_dispatch_handler (ctx=0x5555567358b0, node=0x7ff7b401fd90) at ../util/aio-posix.c:329
+ * #13 0x0000555555e6e6c4 in aio_dispatch_handlers (ctx=0x5555567358b0) at ../util/aio-posix.c:372
+ * #14 0x0000555555e6e71a in aio_dispatch (ctx=0x5555567358b0) at ../util/aio-posix.c:382
+ * #15 0x0000555555e7dad0 in aio_ctx_dispatch (source=0x5555567358b0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #16 0x00007ffff7652119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #17 0x0000555555e68900 in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #18 0x0000555555e6897a in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:254
+ * #19 0x0000555555e68a82 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #20 0x0000555555c28e82 in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #21 0x0000555555814ba2 in main (argc=26, argv=0x7fffffffdd48, envp=0x7fffffffde20) at ../softmmu/main.c:50
+ *
+ * 在以下使用scsi_block_do_sgio():
+ *   - hw/scsi/scsi-disk.c|2846| <<scsi_block_dma_readv>> return scsi_block_do_sgio(r, offset, iov,
+ *   - hw/scsi/scsi-disk.c|2856| <<scsi_block_dma_writev>> return scsi_block_do_sgio(r, offset, iov,
+ */
 static BlockAIOCB *scsi_block_do_sgio(SCSIBlockReq *req,
                                       int64_t offset, QEMUIOVector *iov,
                                       int direction,
@@ -2788,6 +3304,14 @@ static BlockAIOCB *scsi_block_do_sgio(SCSIBlockReq *req,
 
     /* The rest is as in scsi-generic.c.  */
     io_header->mx_sb_len = sizeof(r->req.sense);
+    /*
+     * sg_io_hdr_t *io_header = &req->io_header;
+     * -> unsigned char * sbp;
+     *
+     * SCSIDiskReq *r = &req->req;
+     * -> SCSIRequest req;
+     *    -> uint8_t sense[SCSI_SENSE_BUF_SIZE];
+     */
     io_header->sbp = r->req.sense;
     io_header->timeout = s->qdev.io_timeout * 1000;
     io_header->usr_ptr = r;
@@ -2806,6 +3330,35 @@ static bool scsi_block_no_fua(SCSICommand *cmd)
     return false;
 }
 
+/*
+ * (gdb) bt
+ * #0  scsi_block_dma_readv (offset=0, iov=0x55555763efb0, cb=0x5555558d9678 <dma_blk_cb>, cb_opaque=0x55555763ef50, opaque=0x555556d47800) at ../hw/scsi/scsi-disk.c:2814
+ * #1  0x00005555558d9a12 in dma_blk_cb (opaque=0x55555763ef50, ret=0) at ../softmmu/dma-helpers.c:191
+ * #2  0x00005555558d9c8e in dma_blk_io (ctx=0x5555567358b0, sg=0x5555570338e8, offset=0, align=512, io_func=0x555555a8ba18 <scsi_block_dma_readv>,
+ *                                       io_func_opaque=0x555556d47800, cb=0x555555a851de <scsi_dma_complete>, opaque=0x555556d47800, dir=DMA_DIRECTION_FROM_DEVICE)
+ *                                       at ../softmmu/dma-helpers.c:255
+ * #3  0x0000555555a8569d in scsi_do_read (r=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:424
+ * #4  0x0000555555a85a6a in scsi_read_data (req=0x555556d47800) at ../hw/scsi/scsi-disk.c:496
+ * #5  0x00005555559a89c5 in scsi_req_continue (req=0x555556d47800) at ../hw/scsi/scsi-bus.c:1393
+ * #6  0x0000555555b8ebc8 in virtio_scsi_handle_cmd_req_submit (s=0x5555577e0680, req=0x5555570338a0) at ../hw/scsi/virtio-scsi.c:624
+ * #7  0x0000555555b8ee24 in virtio_scsi_handle_cmd_vq (s=0x5555577e0680, vq=0x5555577e84b0) at ../hw/scsi/virtio-scsi.c:668
+ * #8  0x0000555555c6d983 in virtio_scsi_data_plane_handle_cmd (vdev=0x5555577e0680, vq=0x5555577e84b0) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #9  0x0000555555c88332 in virtio_queue_notify_aio_vq (vq=0x5555577e84b0) at ../hw/virtio/virtio.c:2326
+ * #10 0x0000555555c8b175 in virtio_queue_host_notifier_aio_read (n=0x5555577e852c) at ../hw/virtio/virtio.c:3533
+ * #11 0x0000555555e6e50b in aio_dispatch_handler (ctx=0x5555567358b0, node=0x7ff7b401feb0) at ../util/aio-posix.c:329
+ * #12 0x0000555555e6e6c4 in aio_dispatch_handlers (ctx=0x5555567358b0) at ../util/aio-posix.c:372
+ * #13 0x0000555555e6e71a in aio_dispatch (ctx=0x5555567358b0) at ../util/aio-posix.c:382
+ * #14 0x0000555555e7dad0 in aio_ctx_dispatch (source=0x5555567358b0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #15 0x00007ffff7652119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #16 0x0000555555e68900 in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #17 0x0000555555e6897a in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:254
+ * #18 0x0000555555e68a82 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #19 0x0000555555c28e82 in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #20 0x0000555555814ba2 in main (argc=26, argv=0x7fffffffdd48, envp=0x7fffffffde20) at ../softmmu/main.c:50
+ *
+ * 在以下使用scsi_block_dma_readv():
+ *   - hw/scsi/scsi-disk.c|3169| <<scsi_block_class_initfn>> sdc->dma_readv = scsi_block_dma_readv;
+ */
 static BlockAIOCB *scsi_block_dma_readv(int64_t offset,
                                         QEMUIOVector *iov,
                                         BlockCompletionFunc *cb, void *cb_opaque,
@@ -2871,6 +3424,26 @@ static bool scsi_block_is_passthrough(SCSIDiskState *s, uint8_t *buf)
 }
 
 
+/*
+ * (gdb) bt
+ * #0  scsi_block_dma_command (req=0x555556943f90, buf=0x555556943fc8 "(") at ../hw/scsi/scsi-disk.c:2875
+ * #1  0x00005555559a791f in scsi_req_enqueue (req=0x555556943f90) at ../hw/scsi/scsi-bus.c:888
+ * #2  0x0000555555b8ebb8 in virtio_scsi_handle_cmd_req_submit (s=0x5555577e0680, req=0x555556d52070) at ../hw/scsi/virtio-scsi.c:623
+ * #3  0x0000555555b8ee24 in virtio_scsi_handle_cmd_vq (s=0x5555577e0680, vq=0x5555577e80f0) at ../hw/scsi/virtio-scsi.c:668
+ * #4  0x0000555555c6d983 in virtio_scsi_data_plane_handle_cmd (vdev=0x5555577e0680, vq=0x5555577e80f0) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #5  0x0000555555c88332 in virtio_queue_notify_aio_vq (vq=0x5555577e80f0) at ../hw/virtio/virtio.c:2326
+ * #6  0x0000555555c8b175 in virtio_queue_host_notifier_aio_read (n=0x5555577e816c) at ../hw/virtio/virtio.c:3533
+ * #7  0x0000555555e6e50b in aio_dispatch_handler (ctx=0x5555567358b0, node=0x7ff7d4007e70) at ../util/aio-posix.c:329
+ * #8  0x0000555555e6e6c4 in aio_dispatch_handlers (ctx=0x5555567358b0) at ../util/aio-posix.c:372
+ * #9  0x0000555555e6e71a in aio_dispatch (ctx=0x5555567358b0) at ../util/aio-posix.c:382
+ * #10 0x0000555555e7dad0 in aio_ctx_dispatch (source=0x5555567358b0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #11 0x00007ffff7652119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #12 0x0000555555e68900 in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #13 0x0000555555e6897a in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:254
+ * #14 0x0000555555e68a82 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #15 0x0000555555c28e82 in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #16 0x0000555555814ba2 in main (argc=26, argv=0x7fffffffdd48, envp=0x7fffffffde20) at ../softmmu/main.c:50
+ */
 static int32_t scsi_block_dma_command(SCSIRequest *req, uint8_t *buf)
 {
     SCSIBlockReq *r = (SCSIBlockReq *)req;
@@ -2913,6 +3486,10 @@ static int32_t scsi_block_dma_command(SCSIRequest *req, uint8_t *buf)
     return scsi_disk_dma_command(req, buf);
 }
 
+/*
+ * 在以下使用scsi_block_dma_reqops:
+ *   - hw/scsi/scsi-disk.c|2968| <<scsi_block_new_request>> return scsi_req_alloc(&scsi_block_dma_reqops, &s->qdev, tag, lun,
+ */
 static const SCSIReqOps scsi_block_dma_reqops = {
     .size         = sizeof(SCSIBlockReq),
     .free_req     = scsi_free_request,
@@ -2924,6 +3501,30 @@ static const SCSIReqOps scsi_block_dma_reqops = {
     .save_request = scsi_disk_save_request,
 };
 
+/*
+ * (gdb) bt
+ * #0  scsi_block_new_request (d=0x5555579602d0, tag=3263207184, lun=0, buf=0x555557317c0f "(", hba_private=0x555557317b30) at ../hw/scsi/scsi-disk.c:2930
+ * #1  0x00005555559a5701 in scsi_device_alloc_req (s=0x5555579602d0, tag=3263207184, lun=0, buf=0x555557317c0f "(", hba_private=0x555557317b30) at ../hw/scsi/scsi-bus.c:122
+ * #2  0x00005555559a73a4 in scsi_req_new (d=0x5555579602d0, tag=3263207184, lun=0, buf=0x555557317c0f "(", hba_private=0x555557317b30) at ../hw/scsi/scsi-bus.c:757
+ * #3  0x0000555555b8eace in virtio_scsi_handle_cmd_req_prepare (s=0x5555577e0680, req=0x555557317b30) at ../hw/scsi/virtio-scsi.c:602
+ * #4  0x0000555555b8ec6e in virtio_scsi_handle_cmd_vq (s=0x5555577e0680, vq=0x5555577e85f0) at ../hw/scsi/virtio-scsi.c:646
+ * #5  0x0000555555c6d983 in virtio_scsi_data_plane_handle_cmd (vdev=0x5555577e0680, vq=0x5555577e85f0) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #6  0x0000555555c88332 in virtio_queue_notify_aio_vq (vq=0x5555577e85f0) at ../hw/virtio/virtio.c:2326
+ * #7  0x0000555555c8b175 in virtio_queue_host_notifier_aio_read (n=0x5555577e866c) at ../hw/virtio/virtio.c:3533
+ * #8  0x0000555555e6e50b in aio_dispatch_handler (ctx=0x5555567358b0, node=0x7ff7d40074e0) at ../util/aio-posix.c:329
+ * #9  0x0000555555e6e6c4 in aio_dispatch_handlers (ctx=0x5555567358b0) at ../util/aio-posix.c:372
+ * #10 0x0000555555e6e71a in aio_dispatch (ctx=0x5555567358b0) at ../util/aio-posix.c:382
+ * #11 0x0000555555e7dad0 in aio_ctx_dispatch (source=0x5555567358b0, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #12 0x00007ffff7652119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #13 0x0000555555e68900 in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #14 0x0000555555e6897a in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:254
+ * #15 0x0000555555e68a82 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #16 0x0000555555c28e82 in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #17 0x0000555555814ba2 in main (argc=26, argv=0x7fffffffdd48, envp=0x7fffffffde20) at ../softmmu/main.c:50
+ *
+ * 在以下使用scsi_block_new_request():
+ *   - hw/scsi/scsi-disk.c|3159| <<scsi_block_class_initfn>> sc->alloc_req = scsi_block_new_request;
+ */
 static SCSIRequest *scsi_block_new_request(SCSIDevice *d, uint32_t tag,
                                            uint32_t lun, uint8_t *buf,
                                            void *hba_private)
@@ -2939,6 +3540,10 @@ static SCSIRequest *scsi_block_new_request(SCSIDevice *d, uint32_t tag,
     }
 }
 
+/*
+ * 在以下使用scsi_block_parse_cdb():
+ *   - hw/scsi/scsi-disk.c|3662| <<scsi_block_class_initfn>> sc->parse_cdb = scsi_block_parse_cdb;
+ */
 static int scsi_block_parse_cdb(SCSIDevice *d, SCSICommand *cmd,
                                   uint8_t *buf, void *hba_private)
 {
@@ -2991,6 +3596,14 @@ static void scsi_disk_base_class_initfn(ObjectClass *klass, void *data)
     sdc->need_fua_emulation = scsi_is_cmd_fua;
 }
 
+/*
+ * 有三个继承了TYPE_SCSI_DISK_BASE(scsi_disk_base_info):
+ * "scsi-cd"    : scsi_cd_info
+ * "scsi-hd"    : scsi_hd_info
+ * "scsi-block" : scsi_block_info
+ *
+ * TYPE_SCSI_DEVICE是scsi_device_type_info
+ */
 static const TypeInfo scsi_disk_base_info = {
     .name          = TYPE_SCSI_DISK_BASE,
     .parent        = TYPE_SCSI_DEVICE,
@@ -3060,6 +3673,10 @@ static void scsi_hd_class_initfn(ObjectClass *klass, void *data)
     dc->vmsd  = &vmstate_scsi_disk_state;
 }
 
+/*
+ * 在以下使用scsi_hd_info:
+ *   - hw/scsi/scsi-disk.c|3173| <<scsi_disk_register_types>> type_register_static(&scsi_hd_info);
+ */
 static const TypeInfo scsi_hd_info = {
     .name          = "scsi-hd",
     .parent        = TYPE_SCSI_DISK_BASE,
diff --git a/hw/scsi/scsi-generic.c b/hw/scsi/scsi-generic.c
index 98c30c5d5..2a742b95e 100644
--- a/hw/scsi/scsi-generic.c
+++ b/hw/scsi/scsi-generic.c
@@ -71,6 +71,18 @@ static void scsi_free_request(SCSIRequest *req)
 }
 
 /* Helper function for command completion.  */
+/*
+ * called by:
+ *   - hw/scsi/scsi-generic.c|118| <<scsi_command_complete>> scsi_command_complete_noio(r, ret);
+ *   - hw/scsi/scsi-generic.c|275| <<scsi_read_complete>> scsi_command_complete_noio(r, ret);
+ *   - hw/scsi/scsi-generic.c|314| <<scsi_read_complete>> scsi_command_complete_noio(r, 0);
+ *   - hw/scsi/scsi-generic.c|369| <<scsi_read_data>> scsi_command_complete_noio(r, 0);
+ *   - hw/scsi/scsi-generic.c|376| <<scsi_read_data>> scsi_command_complete_noio(r, ret);
+ *   - hw/scsi/scsi-generic.c|393| <<scsi_write_complete>> scsi_command_complete_noio(r, ret);
+ *   - hw/scsi/scsi-generic.c|403| <<scsi_write_complete>> scsi_command_complete_noio(r, ret);
+ *   - hw/scsi/scsi-generic.c|428| <<scsi_write_data>> scsi_command_complete_noio(r, ret);
+ *   - hw/scsi/scsi-generic.c|479| <<scsi_send_command>> scsi_command_complete_noio(r, ret);
+ */
 static void scsi_command_complete_noio(SCSIGenericReq *r, int ret)
 {
     int status;
@@ -147,6 +159,10 @@ static int execute_command(BlockBackend *blk,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-generic.c|358| <<scsi_read_complete>> scsi_handle_inquiry_reply(r, s);
+ */
 static void scsi_handle_inquiry_reply(SCSIGenericReq *r, SCSIDevice *s)
 {
     uint8_t page, page_idx;
@@ -249,6 +265,17 @@ static int scsi_generic_emulate_block_limits(SCSIGenericReq *r, SCSIDevice *s)
     return r->buflen;
 }
 
+/*
+ * 在scsi-disk.c的定义:
+ *   - hw/scsi/scsi-disk.c|388| <<scsi_read_complete>> static void scsi_read_complete(void *opaque, int ret)
+ * 在scsi-disk.c的使用:
+ *   - hw/scsi/scsi-disk.c|439| <<scsi_do_read>> r->req.aiocb = sdc->dma_readv(r->sector << BDRV_SECTOR_BITS, &r->qiov, scsi_read_complete, r, r);
+ *
+ * 在scsi-generic.c的定义:
+ *   - hw/scsi/scsi-generic.c|252| <<scsi_read_complete>> static void scsi_read_complete(void * opaque, int ret)
+ * 在scsi-generic.c的使用:
+ *   - hw/scsi/scsi-generic.c|363| <<scsi_read_data>> ret = execute_command(s->conf.blk, r, SG_DXFER_FROM_DEV, scsi_read_complete);
+ */
 static void scsi_read_complete(void * opaque, int ret)
 {
     SCSIGenericReq *r = (SCSIGenericReq *)opaque;
@@ -520,6 +547,13 @@ static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)
     return -EINVAL;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|2608| <<get_device_type>> ret = scsi_SG_IO_FROM_DEV(s->qdev.conf.blk, cmd, sizeof(cmd),
+ *   - hw/scsi/scsi-generic.c|572| <<scsi_generic_set_vpd_bl_emulation>> ret = scsi_SG_IO_FROM_DEV(s->conf.blk, cmd, sizeof(cmd),
+ *   - hw/scsi/scsi-generic.c|608| <<scsi_generic_read_device_identification>> ret = scsi_SG_IO_FROM_DEV(s->conf.blk, cmd, sizeof(cmd),
+ *   - hw/scsi/scsi-generic.c|660| <<get_stream_blocksize>> ret = scsi_SG_IO_FROM_DEV(blk, cmd, sizeof(cmd), buf, sizeof(buf), 6);
+ */
 int scsi_SG_IO_FROM_DEV(BlockBackend *blk, uint8_t *cmd, uint8_t cmd_size,
                         uint8_t *buf, uint8_t buf_size, uint32_t timeout)
 {
@@ -636,6 +670,11 @@ static void scsi_generic_read_device_identification(SCSIDevice *s)
     }
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-disk.c|2678| <<scsi_block_realize>> scsi_generic_read_device_inquiry(&s->qdev);
+ *   - hw/scsi/scsi-generic.c|752| <<scsi_generic_realize>> scsi_generic_read_device_inquiry(s);
+ */
 void scsi_generic_read_device_inquiry(SCSIDevice *s)
 {
     scsi_generic_read_device_identification(s);
@@ -752,6 +791,11 @@ static void scsi_generic_realize(SCSIDevice *s, Error **errp)
     scsi_generic_read_device_inquiry(s);
 }
 
+/*
+ * 在以下使用scsi_generic_req_ops:
+ *   - hw/scsi/scsi-disk.c|2951| <<scsi_block_new_request>> return scsi_req_alloc(&scsi_generic_req_ops, &s->qdev, tag, lun,
+ *   - hw/scsi/scsi-generic.c|781| <<scsi_new_request>> return scsi_req_alloc(&scsi_generic_req_ops, d, tag, lun, hba_private);
+ */
 const SCSIReqOps scsi_generic_req_ops = {
     .size         = sizeof(SCSIGenericReq),
     .free_req     = scsi_free_request,
@@ -763,6 +807,18 @@ const SCSIReqOps scsi_generic_req_ops = {
     .save_request = scsi_generic_save_request,
 };
 
+/*
+ * 在scsi-disk.c的定义:
+ *   - hw/scsi/scsi-disk.c|2562| <<scsi_new_request>> static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag, uint32_t lun,
+ * 在scsi-disk.c的使用:
+ *   - hw/scsi/scsi-disk.c|3061| <<scsi_hd_class_initfn>> sc->alloc_req = scsi_new_request;
+ *   - hw/scsi/scsi-disk.c|3092| <<scsi_cd_class_initfn>> sc->alloc_req = scsi_new_request;
+ *
+ * 在scsi-generic.c的定义:
+ *   - hw/scsi/scsi-generic.c|766| <<scsi_new_request>> static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag, uint32_t lun,
+ * 在scsi-generic.c的使用:
+ *   - hw/scsi/scsi-generic.c|792| <<scsi_generic_class_initfn>> sc->alloc_req = scsi_new_request;
+ */
 static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag, uint32_t lun,
                                      uint8_t *buf, void *hba_private)
 {
diff --git a/hw/scsi/virtio-scsi-dataplane.c b/hw/scsi/virtio-scsi-dataplane.c
index 4ad879340..3610af069 100644
--- a/hw/scsi/virtio-scsi-dataplane.c
+++ b/hw/scsi/virtio-scsi-dataplane.c
@@ -22,6 +22,10 @@
 #include "hw/virtio/virtio-access.h"
 
 /* Context: QEMU global mutex held */
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|1397| <<virtio_scsi_device_realize>> virtio_scsi_dataplane_setup(s, errp);
+ */
 void virtio_scsi_dataplane_setup(VirtIOSCSI *s, Error **errp)
 {
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);
@@ -58,6 +62,11 @@ static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,
     virtio_scsi_acquire(s);
     if (!s->dataplane_fenced) {
         assert(s->ctx && s->dataplane_started);
+	/*
+	 * 在以下使用virtio_scsi_handle_cmd_vq():
+	 *   - hw/scsi/virtio-scsi-dataplane.c|61| <<virtio_scsi_data_plane_handle_cmd>> progress = virtio_scsi_handle_cmd_vq(s, vq);
+	 *   - hw/scsi/virtio-scsi.c|763| <<virtio_scsi_handle_cmd>> virtio_scsi_handle_cmd_vq(s, vq);
+	 */
         progress = virtio_scsi_handle_cmd_vq(s, vq);
     }
     virtio_scsi_release(s);
diff --git a/hw/scsi/virtio-scsi.c b/hw/scsi/virtio-scsi.c
index 6d8073028..bef36d9c3 100644
--- a/hw/scsi/virtio-scsi.c
+++ b/hw/scsi/virtio-scsi.c
@@ -29,11 +29,81 @@
 #include "hw/virtio/virtio-access.h"
 #include "trace.h"
 
+/*
+ * 下发IO和完成IO的地方
+ *
+ * qemu-6.0.0
+ *
+ * req->ops->send_command = scsi_block_dma_command() -> scsi_disk_dma_command()
+ * 
+ * req->ops->read_data = scsi_read_data()
+ * -> scsi_do_read()
+ *    -> dma_blk_io() # BlockAIOCB->cb = scsi_dma_complete
+ *       -> sdc->dma_readv = scsi_block_dma_readv()
+ *          -> scsi_block_do_sgio()
+ *             -> blk_aio_ioctl(SG_IO) # cb = scsi_block_sgio_complete
+ *
+ * blk_aio_complete()
+ * -> scsi_block_sgio_complete()
+ *    -> scsi_req_complete_failed()
+ *    -> req->cb = dma_blk_cb()
+ *       -> dma_complete()
+ *          -> scsi_dma_complete()
+ *             -> scsi_dma_complete_noio()
+ *                -> scsi_req_complete()
+ *                   -> req->bus->info->complete = virtio_scsi_command_complete()
+ *
+ *
+ * (gdb) bt
+ * #0  0x0000555555a851ee in scsi_dma_complete (opaque=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:353
+ * #1  0x00005555558d9659 in dma_complete (dbs=0x555557094340, ret=0) at ../softmmu/dma-helpers.c:121
+ * #2  0x00005555558d9706 in dma_blk_cb (opaque=0x555557094340, ret=0) at ../softmmu/dma-helpers.c:139
+ * #3  0x0000555555a8b4e4 in scsi_block_sgio_complete (opaque=0x555556d47800, ret=0) at ../hw/scsi/scsi-disk.c:2714
+ * #4  0x0000555555d6ccc9 in blk_aio_complete (acb=0x5555570a5c60) at ../block/block-backend.c:1412
+ * #5  0x0000555555d6d3a7 in blk_aio_ioctl_entry (opaque=0x5555570a5c60) at ../block/block-backend.c:1596
+ * #6  0x0000555555e6f99a in coroutine_trampoline (i0=-536823856, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #7  0x00007ffff5c8c190 in __start_context () at /lib64/libc.so.6
+ * #8  0x00007ff7ef539b10 in  ()
+ * #9  0x0000000000000000 in  ()
+ *
+ * --------------------------
+ *
+ * qemu-5.2.0
+ *
+ * req->ops->send_command = scsi_block_dma_command() -> scsi_disk_dma_command()
+ *
+ * req->ops->read_data = scsi_read_data()
+ * -> scsi_do_read()
+ *    -> dma_blk_io() # BlockAIOCB->cb = scsi_dma_complete
+ *       -> sdc->dma_readv = scsi_block_dma_readv() # cb = scsi_dma_complete()
+ *          -> scsi_block_do_sgio()
+ *             -> blk_aio_ioctl(SG_IO) # cb = scsi_dma_complete()
+ *
+ *
+ * (gdb) bt
+ * #0  0x00005555558199a3 in scsi_req_complete (req=0x555557055000, status=0) at ../hw/scsi/scsi-bus.c:1456
+ * #1  0x0000555555a52f28 in scsi_dma_complete_noio (r=0x555557055000, ret=0) at ../hw/scsi/scsi-disk.c:275
+ * #2  0x0000555555a53035 in scsi_dma_complete (opaque=0x555557055000, ret=0) at ../hw/scsi/scsi-disk.c:296
+ * #3  0x000055555595db55 in dma_complete (dbs=0x555556ef5940, ret=0) at ../softmmu/dma-helpers.c:120
+ * #4  0x000055555595dc02 in dma_blk_cb (opaque=0x555556ef5940, ret=0) at ../softmmu/dma-helpers.c:138
+ * #5  0x0000555555cdf122 in blk_aio_complete (acb=0x55555729ea00) at ../block/block-backend.c:1412
+ * #6  0x0000555555cdf7ea in blk_aio_ioctl_entry (opaque=0x55555729ea00) at ../block/block-backend.c:1596
+ * #7  0x0000555555e327ab in coroutine_trampoline (i0=-469733232, i1=32759) at ../util/coroutine-ucontext.c:173
+ * #8  0x00007ffff5ea2190 in __start_context () at /lib64/libc.so.6
+ * #9  0x00007ff7eed38b10 in  ()
+ * #10 0x0000000000000000 in  ()
+ */
+
 static inline int virtio_scsi_get_lun(uint8_t *lun)
 {
     return ((lun[2] << 8) | lun[3]) & 0x3FFF;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|345| <<virtio_scsi_do_tmf>> SCSIDevice *d = virtio_scsi_device_get(s, req->req.tmf.lun);
+ *   - hw/scsi/virtio-scsi.c|787| <<virtio_scsi_handle_cmd_req_prepare>> d = virtio_scsi_device_get(s, req->req.cmd.lun);
+ */
 static inline SCSIDevice *virtio_scsi_device_get(VirtIOSCSI *s, uint8_t *lun)
 {
     if (lun[0] != 1) {
@@ -42,9 +112,21 @@ static inline SCSIDevice *virtio_scsi_device_get(VirtIOSCSI *s, uint8_t *lun)
     if (lun[2] != 0 && !(lun[2] >= 0x40 && lun[2] < 0x80)) {
         return NULL;
     }
+    /*
+     * 在VM的driver中:
+     * cmd->lun[0] = 1;
+     * cmd->lun[1] = sc->device->id;
+     * cmd->lun[2] = (sc->device->lun >> 8) | 0x40;
+     * cmd->lun[3] = sc->device->lun & 0xff;
+     */
     return scsi_device_get(&s->bus, 0, lun[1], virtio_scsi_get_lun(lun));
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|186| <<virtio_scsi_pop_req>> virtio_scsi_init_req(s, vq, req);
+ *   - hw/scsi/virtio-scsi.c|215| <<virtio_scsi_load_request>> virtio_scsi_init_req(s, vs->cmd_vqs[n], req);
+ */
 void virtio_scsi_init_req(VirtIOSCSI *s, VirtQueue *vq, VirtIOSCSIReq *req)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
@@ -53,11 +135,39 @@ void virtio_scsi_init_req(VirtIOSCSI *s, VirtQueue *vq, VirtIOSCSIReq *req)
 
     req->vq = vq;
     req->dev = s;
+    /*
+     * 在以下使用VirtIOSCSIReq->qsgl:
+     *   - hw/scsi/virtio-scsi.c|126| <<virtio_scsi_init_req>> qemu_sglist_init(&req->qsgl, DEVICE(s), 8, vdev->dma_as);
+     *   - hw/scsi/virtio-scsi.c|134| <<virtio_scsi_free_req>> qemu_sglist_destroy(&req->qsgl);
+     *   - hw/scsi/virtio-scsi.c|145| <<virtio_scsi_complete_req>> virtqueue_push(vq, &req->elem, req->qsgl.size + req->resp_iov.size);
+     *   - hw/scsi/virtio-scsi.c|169| <<qemu_sgl_concat>> QEMUSGList *qsgl = &req->qsgl;
+     *   - hw/scsi/virtio-scsi.c|176| <<qemu_sgl_concat>> qemu_sglist_add(qsgl, *addr + skip, iov->iov_len - skip);
+     *   - hw/scsi/virtio-scsi.c|710| <<virtio_scsi_parse_cdb>> cmd->xfer = req->qsgl.size;
+     *   - hw/scsi/virtio-scsi.c|719| <<virtio_scsi_get_sg_list>> return &req->qsgl;
+     *   - hw/scsi/virtio-scsi.c|817| <<virtio_scsi_handle_cmd_req_prepare>> req->sreq->cmd.xfer > req->qsgl.size)) {
+     */
     qemu_sglist_init(&req->qsgl, DEVICE(s), 8, vdev->dma_as);
+    /*
+     * 在以下使用VirtIOSCSIReq->resp_iov:
+     *   - hw/scsi/virtio-scsi.c|127| <<virtio_scsi_init_req>> offsetof(VirtIOSCSIReq, resp_iov) + sizeof(req->resp_iov);
+     *   - hw/scsi/virtio-scsi.c|132| <<virtio_scsi_init_req>> qemu_iovec_init(&req->resp_iov, 1);
+     *   - hw/scsi/virtio-scsi.c|138| <<virtio_scsi_free_req>> qemu_iovec_destroy(&req->resp_iov);
+     *   - hw/scsi/virtio-scsi.c|149| <<virtio_scsi_complete_req>> qemu_iovec_from_buf(&req->resp_iov, 0, &req->resp, req->resp_size);
+     *   - hw/scsi/virtio-scsi.c|150| <<virtio_scsi_complete_req>> virtqueue_push(vq, &req->elem, req->qsgl.size + req->resp_iov.size);
+     *   - hw/scsi/virtio-scsi.c|213| <<virtio_scsi_parse_req>> if (qemu_iovec_concat_iov(&req->resp_iov,
+     *   - hw/scsi/virtio-scsi.c|702| <<virtio_scsi_command_complete>> sense_len = MIN(sense_len, req->resp_iov.size - sizeof(req->resp.cmd));
+     *   - hw/scsi/virtio-scsi.c|703| <<virtio_scsi_command_complete>> qemu_iovec_from_buf(&req->resp_iov, sizeof(req->resp.cmd),
+     */
     qemu_iovec_init(&req->resp_iov, 1);
     memset((uint8_t *)req + zero_skip, 0, sizeof(*req) - zero_skip);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|161| <<virtio_scsi_complete_req>> virtio_scsi_free_req(req);
+ *   - hw/scsi/virtio-scsi.c|168| <<virtio_scsi_bad_req>> virtio_scsi_free_req(req);
+ *   - hw/scsi/virtio-scsi.c|940| <<virtio_scsi_handle_cmd_vq>> virtio_scsi_free_req(req);
+ */
 void virtio_scsi_free_req(VirtIOSCSIReq *req)
 {
     qemu_iovec_destroy(&req->resp_iov);
@@ -65,6 +175,13 @@ void virtio_scsi_free_req(VirtIOSCSIReq *req)
     g_free(req);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|336| <<virtio_scsi_cancel_notify>> virtio_scsi_complete_req(req);
+ *   - hw/scsi/virtio-scsi.c|551| <<virtio_scsi_handle_ctrl_req>> virtio_scsi_complete_req(req);
+ *   - hw/scsi/virtio-scsi.c|603| <<virtio_scsi_complete_cmd_req>> virtio_scsi_complete_req(req);
+ *   - hw/scsi/virtio-scsi.c|1080| <<virtio_scsi_push_event>> virtio_scsi_complete_req(req);
+ */
 static void virtio_scsi_complete_req(VirtIOSCSIReq *req)
 {
     VirtIOSCSI *s = req->dev;
@@ -86,6 +203,14 @@ static void virtio_scsi_complete_req(VirtIOSCSIReq *req)
     virtio_scsi_free_req(req);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|555| <<virtio_scsi_handle_ctrl_req>> virtio_scsi_bad_req(req);
+ *   - hw/scsi/virtio-scsi.c|563| <<virtio_scsi_handle_ctrl_req>> virtio_scsi_bad_req(req);
+ *   - hw/scsi/virtio-scsi.c|573| <<virtio_scsi_handle_ctrl_req>> virtio_scsi_bad_req(req);
+ *   - hw/scsi/virtio-scsi.c|842| <<virtio_scsi_handle_cmd_req_prepare>> virtio_scsi_bad_req(req);
+ *   - hw/scsi/virtio-scsi.c|1100| <<virtio_scsi_push_event>> virtio_scsi_bad_req(req);
+ */
 static void virtio_scsi_bad_req(VirtIOSCSIReq *req)
 {
     virtio_error(VIRTIO_DEVICE(req->dev), "wrong size for virtio-scsi headers");
@@ -93,6 +218,11 @@ static void virtio_scsi_bad_req(VirtIOSCSIReq *req)
     virtio_scsi_free_req(req);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|282| <<virtio_scsi_parse_req>> out_size = qemu_sgl_concat(req, req->elem.out_sg,
+ *   - hw/scsi/virtio-scsi.c|285| <<virtio_scsi_parse_req>> in_size = qemu_sgl_concat(req, req->elem.in_sg,
+ */
 static size_t qemu_sgl_concat(VirtIOSCSIReq *req, struct iovec *iov,
                               hwaddr *addr, int num, size_t skip)
 {
@@ -116,12 +246,39 @@ static size_t qemu_sgl_concat(VirtIOSCSIReq *req, struct iovec *iov,
     return copied;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|293| <<virtio_scsi_load_request>> if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICmdReq) + vs->cdb_size,
+ *   - hw/scsi/virtio-scsi.c|506| <<virtio_scsi_handle_ctrl_req>> if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlTMFReq),
+ *   - hw/scsi/virtio-scsi.c|516| <<virtio_scsi_handle_ctrl_req>> if (virtio_scsi_parse_req(req, sizeof(VirtIOSCSICtrlANReq),
+ *   - hw/scsi/virtio-scsi.c|761| <<virtio_scsi_handle_cmd_req_prepare>> rc = virtio_scsi_parse_req(req, sizeof(VirtIOSCSICmdReq) + vs->cdb_size,
+ *   - hw/scsi/virtio-scsi.c|1025| <<virtio_scsi_push_event>> if (virtio_scsi_parse_req(req, 0, sizeof(VirtIOSCSIEvent))) {
+ */
 static int virtio_scsi_parse_req(VirtIOSCSIReq *req,
                                  unsigned req_size, unsigned resp_size)
 {
     VirtIODevice *vdev = (VirtIODevice *) req->dev;
     size_t in_size, out_size;
 
+    /*
+     * request是out, response是in
+     *
+     * VirtIOSCSIReq *req:
+     * -> VirtQueueElement elem;
+     *    -> unsigned int out_num;
+     *    -> unsigned int in_num;
+     *    -> hwaddr *in_addr;
+     *    -> hwaddr *out_addr;
+     *    -> struct iovec *in_sg;
+     *    -> struct iovec *out_sg;
+     *       -> void *iov_base;
+     *       -> size_t iov_len;
+     * -> union {
+     *        VirtIOSCSICmdReq      cmd;
+     *        VirtIOSCSICtrlTMFReq  tmf;
+     *        VirtIOSCSICtrlANReq   an;
+     * } req;
+     */
     if (iov_to_buf(req->elem.out_sg, req->elem.out_num, 0,
                    &req->req, req_size) < req_size) {
         return -EINVAL;
@@ -174,6 +331,12 @@ static int virtio_scsi_parse_req(VirtIOSCSIReq *req,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|543| <<virtio_scsi_handle_ctrl_vq>> while ((req = virtio_scsi_pop_req(s, vq))) {
+ *   - hw/scsi/virtio-scsi.c|879| <<virtio_scsi_handle_cmd_vq>> while ((req = virtio_scsi_pop_req(s, vq))) {
+ *   - hw/scsi/virtio-scsi.c|998| <<virtio_scsi_push_event>> req = virtio_scsi_pop_req(s, vs->event_vq);
+ */
 static VirtIOSCSIReq *virtio_scsi_pop_req(VirtIOSCSI *s, VirtQueue *vq)
 {
     VirtIOSCSICommon *vs = (VirtIOSCSICommon *)s;
@@ -187,6 +350,9 @@ static VirtIOSCSIReq *virtio_scsi_pop_req(VirtIOSCSI *s, VirtQueue *vq)
     return req;
 }
 
+/*
+ * struct SCSIBusInfo virtio_scsi_scsi_info.save_request = virtio_scsi_save_request()
+ */
 static void virtio_scsi_save_request(QEMUFile *f, SCSIRequest *sreq)
 {
     VirtIOSCSIReq *req = sreq->hba_private;
@@ -199,6 +365,9 @@ static void virtio_scsi_save_request(QEMUFile *f, SCSIRequest *sreq)
     qemu_put_virtqueue_element(vdev, f, &req->elem);
 }
 
+/*
+ * struct SCSIBusInfo virtio_scsi_scsi_info.load_request = virtio_scsi_load_request()
+ */
 static void *virtio_scsi_load_request(QEMUFile *f, SCSIRequest *sreq)
 {
     SCSIBus *bus = sreq->bus;
@@ -233,6 +402,11 @@ typedef struct {
     VirtIOSCSIReq  *tmf_req;
 } VirtIOSCSICancelNotifier;
 
+/*
+ * 在以下使用virtio_scsi_cancel_notify():
+ *   - hw/scsi/virtio-scsi.c|471| <<virtio_scsi_do_tmf>> notifier->notifier.notify = virtio_scsi_cancel_notify;
+ *   - hw/scsi/virtio-scsi.c|519| <<virtio_scsi_do_tmf>> notifier->notifier.notify = virtio_scsi_cancel_notify;
+ */
 static void virtio_scsi_cancel_notify(Notifier *notifier, void *data)
 {
     VirtIOSCSICancelNotifier *n = container_of(notifier,
@@ -249,6 +423,11 @@ static void virtio_scsi_cancel_notify(Notifier *notifier, void *data)
     g_free(n);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|275| <<virtio_scsi_do_tmf>> virtio_scsi_ctx_check(s, d);
+ *   - hw/scsi/virtio-scsi.c|655| <<virtio_scsi_handle_cmd_req_prepare>> virtio_scsi_ctx_check(s, d);
+ */
 static inline void virtio_scsi_ctx_check(VirtIOSCSI *s, SCSIDevice *d)
 {
     if (s->dataplane_started && d && blk_is_available(d->conf.blk)) {
@@ -259,6 +438,10 @@ static inline void virtio_scsi_ctx_check(VirtIOSCSI *s, SCSIDevice *d)
 /* Return 0 if the request is ready to be completed and return to guest;
  * -EINPROGRESS if the request is submitted and will be completed later, in the
  *  case of async cancellation. */
+/*
+ * 处理VIRTIO_SCSI_T_TMF:
+ *   - hw/scsi/virtio-scsi.c|585| <<virtio_scsi_handle_ctrl_req>> r = virtio_scsi_do_tmf(s, req);
+ */
 static int virtio_scsi_do_tmf(VirtIOSCSI *s, VirtIOSCSIReq *req)
 {
     SCSIDevice *d = virtio_scsi_device_get(s, req->req.tmf.lun);
@@ -408,6 +591,10 @@ fail:
     return ret;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|634| <<virtio_scsi_handle_ctrl_vq>> virtio_scsi_handle_ctrl_req(s, req);
+ */
 static void virtio_scsi_handle_ctrl_req(VirtIOSCSI *s, VirtIOSCSIReq *req)
 {
     VirtIODevice *vdev = (VirtIODevice *)s;
@@ -487,6 +674,15 @@ static void virtio_scsi_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
     virtio_scsi_release(s);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|626| <<virtio_scsi_command_failed>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|664| <<virtio_scsi_command_complete>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|704| <<virtio_scsi_request_cancelled>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|718| <<virtio_scsi_fail_cmd_req>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|760| <<virtio_scsi_handle_cmd_req_prepare>> virtio_scsi_complete_cmd_req(req);
+ *   - hw/scsi/virtio-scsi.c|789| <<virtio_scsi_handle_cmd_req_prepare>> virtio_scsi_complete_cmd_req(req);
+ */
 static void virtio_scsi_complete_cmd_req(VirtIOSCSIReq *req)
 {
     trace_virtio_scsi_cmd_resp(virtio_scsi_get_lun(req->req.cmd.lun),
@@ -500,6 +696,12 @@ static void virtio_scsi_complete_cmd_req(VirtIOSCSIReq *req)
     virtio_scsi_complete_req(req);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|1645| <<scsi_req_complete_failed>> req->bus->info->fail(req);
+ *
+ * struct SCSIBusInfo virtio_scsi_scsi_info.fail = virtio_scsi_command_failed()
+ */
 static void virtio_scsi_command_failed(SCSIRequest *r)
 {
     VirtIOSCSIReq *req = r->hba_private;
@@ -508,6 +710,17 @@ static void virtio_scsi_command_failed(SCSIRequest *r)
         return;
     }
 
+    /*
+     * VirtIOSCSIReq *req:
+     * -> union resp:
+     *    -> VirtIOSCSICmdResp cmd (struct virtio_scsi_cmd_resp):
+     *       -> __virtio32 sense_len;           // Sense data length
+     *       -> __virtio32 resid;               // Residual bytes in data buffer
+     *       -> __virtio16 status_qualifier;    // Status qualifier
+     *       -> uint8_t status;         // Command completion status
+     *       -> uint8_t response;               // Response values
+     *       -> uint8_t sense[VIRTIO_SCSI_SENSE_SIZE];
+     */
     req->resp.cmd.status = GOOD;
     switch (r->host_status) {
     case SCSI_HOST_NO_LUN:
@@ -545,6 +758,9 @@ static void virtio_scsi_command_failed(SCSIRequest *r)
     virtio_scsi_complete_cmd_req(req);
 }
 
+/*
+ * struct SCSIBusInfo virtio_scsi_scsi_info.complete = virtio_scsi_command_complete()
+ */
 static void virtio_scsi_command_complete(SCSIRequest *r, size_t resid)
 {
     VirtIOSCSIReq *req = r->hba_private;
@@ -557,7 +773,23 @@ static void virtio_scsi_command_complete(SCSIRequest *r, size_t resid)
     }
 
     req->resp.cmd.response = VIRTIO_SCSI_S_OK;
+    /*
+     * 从scsi_req_complete_failed()-->scsi_req_complete()过来的时候
+     * 如果有sense, SCSIRequest->status可能是CHECK_CONDITION
+     */
     req->resp.cmd.status = r->status;
+    /*
+     * VirtIOSCSIReq *req = r->hba_private:
+     * -> QEMUIOVector resp_iov;
+     * -> union resp:
+     *    -> VirtIOSCSICmdResp cmd; (等同struct virtio_scsi_cmd_resp)
+     *       -> __virtio32 sense_len;           // Sense data length
+     *       -> __virtio32 resid;               // Residual bytes in data buffer
+     *       -> __virtio16 status_qualifier;    // Status qualifier
+     *       -> uint8_t status;         // Command completion status
+     *       -> uint8_t response;               // Response values
+     *       -> uint8_t sense[VIRTIO_SCSI_SENSE_SIZE];
+     */
     if (req->resp.cmd.status == GOOD) {
         req->resp.cmd.resid = virtio_tswap32(vdev, resid);
     } else {
@@ -571,6 +803,9 @@ static void virtio_scsi_command_complete(SCSIRequest *r, size_t resid)
     virtio_scsi_complete_cmd_req(req);
 }
 
+/*
+ * struct SCSIBusInfo virtio_scsi_scsi_info.parse_cdb = virtio_scsi_parse_cdb()
+ */
 static int virtio_scsi_parse_cdb(SCSIDevice *dev, SCSICommand *cmd,
                                  uint8_t *buf, void *hba_private)
 {
@@ -589,13 +824,30 @@ static int virtio_scsi_parse_cdb(SCSIDevice *dev, SCSICommand *cmd,
     return 0;
 }
 
+/*
+ * struct SCSIBusInfo virtio_scsi_scsi_info.get_sg_list = virtio_scsi_get_sg_list()
+ */
 static QEMUSGList *virtio_scsi_get_sg_list(SCSIRequest *r)
 {
     VirtIOSCSIReq *req = r->hba_private;
 
+    /*
+     * 在以下使用VirtIOSCSIReq->qsgl:
+     *   - hw/scsi/virtio-scsi.c|126| <<virtio_scsi_init_req>> qemu_sglist_init(&req->qsgl, DEVICE(s), 8, vdev->dma_as);
+     *   - hw/scsi/virtio-scsi.c|134| <<virtio_scsi_free_req>> qemu_sglist_destroy(&req->qsgl);
+     *   - hw/scsi/virtio-scsi.c|145| <<virtio_scsi_complete_req>> virtqueue_push(vq, &req->elem, req->qsgl.size + req->resp_iov.size);
+     *   - hw/scsi/virtio-scsi.c|169| <<qemu_sgl_concat>> QEMUSGList *qsgl = &req->qsgl;
+     *   - hw/scsi/virtio-scsi.c|176| <<qemu_sgl_concat>> qemu_sglist_add(qsgl, *addr + skip, iov->iov_len - skip);
+     *   - hw/scsi/virtio-scsi.c|710| <<virtio_scsi_parse_cdb>> cmd->xfer = req->qsgl.size;
+     *   - hw/scsi/virtio-scsi.c|719| <<virtio_scsi_get_sg_list>> return &req->qsgl;
+     *   - hw/scsi/virtio-scsi.c|817| <<virtio_scsi_handle_cmd_req_prepare>> req->sreq->cmd.xfer > req->qsgl.size)) {
+     */
     return &req->qsgl;
 }
 
+/*
+ * struct SCSIBusInfo virtio_scsi_scsi_info.cancel = virtio_scsi_request_cancelled()
+ */
 static void virtio_scsi_request_cancelled(SCSIRequest *r)
 {
     VirtIOSCSIReq *req = r->hba_private;
@@ -611,18 +863,49 @@ static void virtio_scsi_request_cancelled(SCSIRequest *r)
     virtio_scsi_complete_cmd_req(req);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|656| <<virtio_scsi_handle_cmd_req_prepare>> virtio_scsi_fail_cmd_req(req);
+ *
+ * virtio_scsi_handle_cmd_vq()
+ * -> virtio_scsi_handle_cmd_req_prepare()
+ *    -> virtio_scsi_fail_cmd_req()
+ */
 static void virtio_scsi_fail_cmd_req(VirtIOSCSIReq *req)
 {
     req->resp.cmd.response = VIRTIO_SCSI_S_FAILURE;
     virtio_scsi_complete_cmd_req(req);
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|724| <<virtio_scsi_handle_cmd_vq>> ret = virtio_scsi_handle_cmd_req_prepare(s, req);
+ */
 static int virtio_scsi_handle_cmd_req_prepare(VirtIOSCSI *s, VirtIOSCSIReq *req)
 {
     VirtIOSCSICommon *vs = &s->parent_obj;
     SCSIDevice *d;
     int rc;
 
+    /*
+     * // SCSI command request, followed by data-out
+     * VirtIOSCSICmdReq (struct virtio_scsi_cmd_req):
+     * -> uint8_t lun[8];         // Logical Unit Number
+     * -> __virtio64 tag;         // Command identifier
+     * -> uint8_t task_attr;              // Task attribute
+     * -> uint8_t prio;           // SAM command priority field
+     * -> uint8_t crn;
+     * -> uint8_t cdb[VIRTIO_SCSI_CDB_SIZE];
+     *
+     * // Response, followed by sense data and data-in
+     * VirtIOSCSICmdResp (struct virtio_scsi_cmd_resp):
+     * -> __virtio32 sense_len;           // Sense data length
+     * -> __virtio32 resid;               // Residual bytes in data buffer
+     * -> __virtio16 status_qualifier;    // Status qualifier
+     * -> uint8_t status;         // Command completion status
+     * -> uint8_t response;               // Response values
+     * -> uint8_t sense[VIRTIO_SCSI_SENSE_SIZE];
+     */
     rc = virtio_scsi_parse_req(req, sizeof(VirtIOSCSICmdReq) + vs->cdb_size,
                                sizeof(VirtIOSCSICmdResp) + vs->sense_size);
     if (rc < 0) {
@@ -637,6 +920,18 @@ static int virtio_scsi_handle_cmd_req_prepare(VirtIOSCSI *s, VirtIOSCSIReq *req)
     trace_virtio_scsi_cmd_req(virtio_scsi_get_lun(req->req.cmd.lun),
                               req->req.cmd.tag, req->req.cmd.cdb[0]);
 
+    /*
+     * VirtIOSCSIReq *req:
+     * -> union resp:
+     * -> union req:
+     *    -> VirtIOSCSICmdReq cmd (virtio_scsi_cmd_req);
+     *       -> uint8_t lun[8];         // Logical Unit Number
+     *       -> __virtio64 tag;         / Command identifier
+     *       -> uint8_t task_attr;              // Task attribute
+     *       -> uint8_t prio;           // SAM command priority field
+     *       -> uint8_t crn;
+     *       -> uint8_t cdb[VIRTIO_SCSI_CDB_SIZE];
+     */
     d = virtio_scsi_device_get(s, req->req.cmd.lun);
     if (!d) {
         req->resp.cmd.response = VIRTIO_SCSI_S_BAD_TARGET;
@@ -644,6 +939,23 @@ static int virtio_scsi_handle_cmd_req_prepare(VirtIOSCSI *s, VirtIOSCSIReq *req)
         return -ENOENT;
     }
     virtio_scsi_ctx_check(s, d);
+    /*
+     * 在以下使用scsi_req_new():
+     *   - hw/scsi/esp.c|295| <<do_busid_cmd>> s->current_req = scsi_req_new(current_lun, 0, lun, buf, s);
+     *   - hw/scsi/lsi53c895a.c|867| <<lsi_do_command>> s->current->req = scsi_req_new(dev, s->current->tag, s->current_lun, buf,
+     *   - hw/scsi/megasas.c|1043| <<megasas_pd_get_info_submit>> cmd->req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);
+     *   - hw/scsi/megasas.c|1061| <<megasas_pd_get_info_submit>> cmd->req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);
+     *   - hw/scsi/megasas.c|1242| <<megasas_ld_get_info_submit>> cmd->req = scsi_req_new(sdev, cmd->index, lun, cdb, cmd);
+     *   - hw/scsi/megasas.c|1715| <<megasas_handle_scsi>> cmd->req = scsi_req_new(sdev, cmd->index, lun_id, cdb, cmd);
+     *   - hw/scsi/megasas.c|1789| <<megasas_handle_io>> cmd->req = scsi_req_new(sdev, cmd->index,
+     *   - hw/scsi/mptsas.c|318| <<mptsas_process_scsi_io_request>> req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,
+     *   - hw/scsi/scsi-bus.c|1780| <<get_scsi_requests>> req = scsi_req_new(s, tag, lun, buf, NULL);
+     *   - hw/scsi/spapr_vscsi.c|805| <<vscsi_queue_cmd>> req->sreq = scsi_req_new(sdev, req->qtag, lun, srp->cmd.cdb, req);
+     *   - hw/scsi/virtio-scsi.c|652| <<virtio_scsi_handle_cmd_req_prepare>> req->sreq = scsi_req_new(d, req->req.cmd.tag,
+     *   - hw/scsi/vmw_pvscsi.c|727| <<pvscsi_process_request_descriptor>> r->sreq = scsi_req_new(d, descr->context, r->lun, descr->cdb, r);
+     *   - hw/usb/dev-storage.c|418| <<usb_msd_handle_data>> s->req = scsi_req_new(scsi_dev, tag, cbw.lun, cbw.cmd, NULL);
+     *   - hw/usb/dev-uas.c|730| <<usb_uas_command>> req->req = scsi_req_new(req->dev, req->tag,
+     */
     req->sreq = scsi_req_new(d, req->req.cmd.tag,
                              virtio_scsi_get_lun(req->req.cmd.lun),
                              req->req.cmd.cdb, req);
@@ -662,6 +974,10 @@ static int virtio_scsi_handle_cmd_req_prepare(VirtIOSCSI *s, VirtIOSCSIReq *req)
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|903| <<virtio_scsi_handle_cmd_vq>> virtio_scsi_handle_cmd_req_submit(s, req);
+ */
 static void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)
 {
     SCSIRequest *sreq = req->sreq;
@@ -672,6 +988,38 @@ static void virtio_scsi_handle_cmd_req_submit(VirtIOSCSI *s, VirtIOSCSIReq *req)
     scsi_req_unref(sreq);
 }
 
+/*
+ * Thread 1 "qemu-system-x86" hit Breakpoint 2, virtio_scsi_handle_cmd_vq (s=0x5555578148c0, vq=0x55555781bf40) at ../hw/scsi/virtio-scsi.c:676
+ * 676	{
+ * (gdb) bt
+ * #0  0x0000555555ca2c71 in virtio_scsi_handle_cmd_vq (s=0x5555578148c0, vq=0x55555781bf40) at ../hw/scsi/virtio-scsi.c:676
+ * #1  0x0000555555c37f04 in virtio_scsi_data_plane_handle_cmd (vdev=0x5555578148c0, vq=0x55555781bf40) at ../hw/scsi/virtio-scsi-dataplane.c:61
+ * #2  0x0000555555c1b72b in virtio_queue_notify_aio_vq (vq=0x55555781bf40) at ../hw/virtio/virtio.c:2326
+ * #3  0x0000555555c1e575 in virtio_queue_host_notifier_aio_read (n=0x55555781bfbc) at ../hw/virtio/virtio.c:3533
+ * #4  0x0000555555ec79f5 in aio_dispatch_handler (ctx=0x55555696c740, node=0x7ffedc004680) at ../util/aio-posix.c:329
+ * #5  0x0000555555ec7bae in aio_dispatch_handlers (ctx=0x55555696c740) at ../util/aio-posix.c:372
+ * #6  0x0000555555ec7c04 in aio_dispatch (ctx=0x55555696c740) at ../util/aio-posix.c:382
+ * #7  0x0000555555e9cb19 in aio_ctx_dispatch (source=0x55555696c740, callback=0x0, user_data=0x0) at ../util/async.c:306
+ * #8  0x00007ffff743c099 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #9  0x0000555555ead61b in glib_pollfds_poll () at ../util/main-loop.c:231
+ * #10 0x0000555555ead695 in os_host_main_loop_wait (timeout=2000000) at ../util/main-loop.c:254
+ * #11 0x0000555555ead79d in main_loop_wait (nonblocking=0) at ../util/main-loop.c:530
+ * #12 0x0000555555b9c37f in qemu_main_loop () at ../softmmu/runstate.c:725
+ * #13 0x0000555555819412 in main (argc=24, argv=0x7fffffffdf68, envp=0x7fffffffe030) at ../softmmu/main.c:50
+ * (gdb) info threads 
+ *   Id   Target Id                                           Frame 
+ * * 1    Thread 0x7ffff7fcbc80 (LWP 28445) "qemu-system-x86" virtio_scsi_handle_cmd_vq (s=0x5555578148c0, vq=0x55555781bf40) at ../hw/scsi/virtio-scsi.c:676
+ *   2    Thread 0x7fffeeede700 (LWP 28449) "qemu-system-x86" 0x00007ffff5152d19 in syscall () from /lib64/libc.so.6
+ *   4    Thread 0x7ffeed7ff700 (LWP 28460) "CPU 0/KVM"       0x00007ffff514f397 in ioctl () from /lib64/libc.so.6
+ *   5    Thread 0x7ffeecffe700 (LWP 28461) "CPU 1/KVM"       0x00007ffff514f397 in ioctl () from /lib64/libc.so.6
+ *   6    Thread 0x7ffee7fff700 (LWP 28462) "CPU 2/KVM"       0x00007ffff514f397 in ioctl () from /lib64/libc.so.6
+ *   7    Thread 0x7ffee77fe700 (LWP 28463) "CPU 3/KVM"       0x00007ffff514f397 in ioctl () from /lib64/libc.so.6
+ *   8    Thread 0x7ffee53ff700 (LWP 28464) "vnc_worker"      0x00007ffff5433a35 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0
+ *
+ * called by:
+ *   - hw/scsi/virtio-scsi-dataplane.c|61| <<virtio_scsi_data_plane_handle_cmd>> progress = virtio_scsi_handle_cmd_vq(s, vq);
+ *   - hw/scsi/virtio-scsi.c|763| <<virtio_scsi_handle_cmd>> virtio_scsi_handle_cmd_vq(s, vq);
+ */
 bool virtio_scsi_handle_cmd_vq(VirtIOSCSI *s, VirtQueue *vq)
 {
     VirtIOSCSIReq *req, *next;
@@ -686,10 +1034,16 @@ bool virtio_scsi_handle_cmd_vq(VirtIOSCSI *s, VirtQueue *vq)
             virtio_queue_set_notification(vq, 0);
         }
 
+	/*
+	 * VirtIOSCSIReq *req:
+	 */
         while ((req = virtio_scsi_pop_req(s, vq))) {
             progress = true;
             ret = virtio_scsi_handle_cmd_req_prepare(s, req);
             if (!ret) {
+                /*
+		 * 正确的是到这里
+		 */
                 QTAILQ_INSERT_TAIL(&reqs, req, next);
             } else if (ret == -EINVAL) {
                 /* The device is broken and shouldn't process any request */
@@ -731,6 +1085,10 @@ static void virtio_scsi_handle_cmd(VirtIODevice *vdev, VirtQueue *vq)
     virtio_scsi_release(s);
 }
 
+/*
+ * 在以下使用virtio_scsi_get_config():
+ *   - hw/scsi/virtio-scsi.c|1432| <<virtio_scsi_common_class_init>> vdc->get_config = virtio_scsi_get_config;
+ */
 static void virtio_scsi_get_config(VirtIODevice *vdev,
                                    uint8_t *config)
 {
@@ -866,6 +1224,9 @@ static void virtio_scsi_handle_event(VirtIODevice *vdev, VirtQueue *vq)
     virtio_scsi_release(s);
 }
 
+/*
+ * struct SCSIBusInfo virtio_scsi_scsi_info.change = virtio_scsi_change()
+ */
 static void virtio_scsi_change(SCSIBus *bus, SCSIDevice *dev, SCSISense sense)
 {
     VirtIOSCSI *s = container_of(bus, VirtIOSCSI, bus);
@@ -946,6 +1307,10 @@ static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,
     }
 }
 
+/*
+ * 在以下使用virtio_scsi_scsi_info:
+ *   - hw/scsi/virtio-scsi.c|1309| <<virtio_scsi_device_realize>> scsi_bus_new(&s->bus, sizeof(s->bus), dev, &virtio_scsi_scsi_info, vdev->bus_name);
+ */
 static struct SCSIBusInfo virtio_scsi_scsi_info = {
     .tcq = true,
     .max_channel = VIRTIO_SCSI_MAX_CHANNEL,
@@ -962,6 +1327,12 @@ static struct SCSIBusInfo virtio_scsi_scsi_info = {
     .load_request = virtio_scsi_load_request,
 };
 
+/*
+ * called by:
+ *   - hw/scsi/vhost-scsi.c|194| <<vhost_scsi_realize>> virtio_scsi_common_realize(dev,
+ *   - hw/scsi/vhost-user-scsi.c|106| <<vhost_user_scsi_realize>> virtio_scsi_common_realize(dev, vhost_dummy_handle_output,
+ *   - hw/scsi/virtio-scsi.c|1250| <<virtio_scsi_device_realize>> virtio_scsi_common_realize(dev,
+ */
 void virtio_scsi_common_realize(DeviceState *dev,
                                 VirtIOHandleOutput ctrl,
                                 VirtIOHandleOutput evt,
@@ -1019,6 +1390,24 @@ static void virtio_scsi_device_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * VirtIOSCSI *s:
+     * -> VirtIOSCSICommon parent_obj;
+     *    -> VirtIODevice parent_obj;
+     *    -> VirtIOSCSIConf conf;
+     *    -> uint32_t sense_size;
+     *    -> uint32_t cdb_size;
+     *    -> VirtQueue *ctrl_vq;
+     *    -> VirtQueue *event_vq;
+     *    -> VirtQueue **cmd_vqs;
+     * -> SCSIBus bus;
+     *    -> BusState qbus;
+     *       -> int num_children;
+     *       -> QTAILQ_HEAD(, BusChild) children;
+     *    -> int busnr;
+     *    -> SCSISense unit_attention;
+     *    -> const SCSIBusInfo *info;
+     */
     scsi_bus_new(&s->bus, sizeof(s->bus), dev,
                  &virtio_scsi_scsi_info, vdev->bus_name);
     /* override default SCSI bus hotplug-handler, with virtio-scsi's one */
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 5c65aa0a9..1349f6fff 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -455,6 +455,11 @@ static void vfio_update_kvm_msi_virq(VFIOMSIVector *vector, MSIMessage msg,
     kvm_irqchip_commit_routes(kvm_state);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|541| <<vfio_msix_vector_use>> return vfio_msix_vector_do_use(pdev, nr, &msg, vfio_msi_interrupt);
+ *   - hw/vfio/pci.c|605| <<vfio_msix_enable>> vfio_msix_vector_do_use(pdev, max_vec, NULL, NULL);
+ */
 static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
                                    MSIMessage *msg, IOHandler *handler)
 {
@@ -567,6 +572,11 @@ static void vfio_msix_vector_release(PCIDevice *pdev, unsigned int nr)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1187| <<vfio_pci_write_config>> vfio_msix_enable(vdev);
+ *   - hw/vfio/pci.c|2462| <<vfio_pci_load_config>> vfio_msix_enable(vdev);
+ */
 static void vfio_msix_enable(VFIOPCIDevice *vdev)
 {
     PCIDevice *pdev = &vdev->pdev;
@@ -2465,6 +2475,10 @@ static int vfio_pci_load_config(VFIODevice *vbasedev, QEMUFile *f)
     return ret;
 }
 
+/*
+ * 在以下使用vfio_pci_ops:
+ *   - hw/vfio/pci.c|2810| <<vfio_realize>> vdev->vbasedev.ops = &vfio_pci_ops;
+ */
 static VFIODeviceOps vfio_pci_ops = {
     .vfio_compute_needs_reset = vfio_pci_compute_needs_reset,
     .vfio_hot_reset_multi = vfio_pci_hot_reset_multi,
diff --git a/hw/virtio/vhost.c b/hw/virtio/vhost.c
index e2163a0d6..ff23bad8d 100644
--- a/hw/virtio/vhost.c
+++ b/hw/virtio/vhost.c
@@ -277,6 +277,16 @@ static inline void vhost_dev_log_resize(struct vhost_dev *dev, uint64_t size)
     dev->log_size = size;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|297| <<vhost_memory_map>> if (!vhost_dev_has_iommu(dev)) {
+ *   - hw/virtio/vhost.c|308| <<vhost_memory_unmap>> if (!vhost_dev_has_iommu(dev)) {
+ *   - hw/virtio/vhost.c|353| <<vhost_verify_ring_mappings>> if (vhost_dev_has_iommu(dev)) {
+ *   - hw/virtio/vhost.c|809| <<vhost_dev_set_features>> if (!vhost_dev_has_iommu(dev)) {
+ *   - hw/virtio/vhost.c|1754| <<vhost_dev_start>> if (vhost_dev_has_iommu(hdev)) {
+ *   - hw/virtio/vhost.c|1796| <<vhost_dev_start>> if (vhost_dev_has_iommu(hdev) &&
+ *   - hw/virtio/vhost.c|1843| <<vhost_dev_stop>> if (vhost_dev_has_iommu(hdev)) {
+ */
 static int vhost_dev_has_iommu(struct vhost_dev *dev)
 {
     VirtIODevice *vdev = dev->vdev;
@@ -764,6 +774,10 @@ static void vhost_iommu_region_del(MemoryListener *listener,
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|1123| <<vhost_virtqueue_start>> r = vhost_virtqueue_set_addr(dev, vq, vhost_vq_index, dev->log_enabled);
+ */
 static int vhost_virtqueue_set_addr(struct vhost_dev *dev,
                                     struct vhost_virtqueue *vq,
                                     unsigned idx, bool enable_log)
@@ -1050,6 +1064,33 @@ out:
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  0x000055be200149a4 in vhost_virtqueue_start (dev=0x55be21df0890, vdev=0x55be22b90300, vq=0x55be21df0b50, idx=3) at ../hw/virtio/vhost.c:1057
+ * #1  0x000055be20016891 in vhost_dev_start (hdev=0x55be21df0890, vdev=0x55be22b90300) at ../hw/virtio/vhost.c:1734
+ * #2  0x000055be1fccc8b5 in vhost_net_start_one (net=0x55be21df0890, dev=0x55be22b90300) at ../hw/net/vhost_net.c:246
+ * #3  0x000055be1fcccd73 in vhost_net_start (dev=0x55be22b90300, ncs=0x55be22baac80, total_queues=2) at ../hw/net/vhost_net.c:351
+ * #4  0x000055be200095e1 in virtio_net_vhost_status (n=0x55be22b90300, status=15 '\017') at ../hw/net/virtio-net.c:288
+ * #5  0x000055be2000988c in virtio_net_set_status (vdev=0x55be22b90300, status=15 '\017') at ../hw/net/virtio-net.c:369
+ * #6  0x000055be1ffd07f0 in virtio_set_status (vdev=0x55be22b90300, val=15 '\017') at ../hw/virtio/virtio.c:1958
+ * #7  0x000055be1fc7d0af in virtio_pci_common_write (opaque=0x55be22b88160, addr=20, val=15, size=1) at ../hw/virtio/virtio-pci.c:1260
+ * #8  0x000055be2003abd3 in memory_region_write_accessor (mr=0x55be22b88b50, addr=20, value=0x7f68777fd6c8, size=1, shift=0, mask=255, attrs=...) at ../softmmu/memory.c:491
+ * #9  0x000055be2003adf7 in access_with_adjusted_size (addr=20, value=0x7f68777fd6c8, size=1, access_size_min=1, access_size_max=4, access_fn= 0x55be2003aaee <memory_region_write_accessor>,
+ *                              mr=0x55be22b88b50, attrs=...) at ../softmmu/memory.c:552
+ * #10 0x000055be2003ddf6 in memory_region_dispatch_write (mr=0x55be22b88b50, addr=20, data=15, op=MO_8, attrs=...) at ../softmmu/memory.c:1502
+ * #11 0x000055be2006a2cc in flatview_write_continue (fv=0x7f686c008230, addr=4261412884, attrs=..., ptr=0x7f69877a2028, len=1, addr1=20, l=1, mr=0x55be22b88b50) at ../softmmu/physmem.c:2746
+ * #12 0x000055be2006a411 in flatview_write (fv=0x7f686c008230, addr=4261412884, attrs=..., buf=0x7f69877a2028, len=1) at ../softmmu/physmem.c:2786
+ * #13 0x000055be2006a77d in address_space_write (as=0x55be20c94bc0 <address_space_memory>, addr=4261412884, attrs=..., buf=0x7f69877a2028, len=1) at ../softmmu/physmem.c:2878
+ * #14 0x000055be2006a7ea in address_space_rw (as=0x55be20c94bc0 <address_space_memory>, addr=4261412884, attrs=..., buf=0x7f69877a2028, len=1, is_write=true) at ../softmmu/physmem.c:2888
+ * #15 0x000055be1fff59c6 in kvm_cpu_exec (cpu=0x55be21e89650) at ../accel/kvm/kvm-all.c:2517
+ * #16 0x000055be20037aa9 in kvm_vcpu_thread_fn (arg=0x55be21e89650) at ../accel/kvm/kvm-accel-ops.c:49
+ * #17 0x000055be202437ea in qemu_thread_start (args=0x55be21e96780) at ../util/qemu-thread-posix.c:521
+ * #18 0x00007f6984be0ea5 in start_thread () at /lib64/libpthread.so.0
+ * #19 0x00007f69849098cd in clone () at /lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/virtio/vhost.c|1734| <<vhost_dev_start>> r = vhost_virtqueue_start(hdev,
+ */
 static int vhost_virtqueue_start(struct vhost_dev *dev,
                                 struct VirtIODevice *vdev,
                                 struct vhost_virtqueue *vq,
diff --git a/hw/virtio/virtio-pci.c b/hw/virtio/virtio-pci.c
index b321604d9..7c8bba54d 100644
--- a/hw/virtio/virtio-pci.c
+++ b/hw/virtio/virtio-pci.c
@@ -665,6 +665,10 @@ static uint32_t virtio_read_config(PCIDevice *pci_dev,
     return pci_default_read_config(pci_dev, address, len);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|736| <<kvm_virtio_pci_vector_use>> ret = kvm_virtio_pci_vq_vector_use(proxy, queue_no, vector);
+ */
 static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,
                                         unsigned int queue_no,
                                         unsigned int vector)
@@ -692,6 +696,11 @@ static void kvm_virtio_pci_vq_vector_release(VirtIOPCIProxy *proxy,
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|744| <<kvm_virtio_pci_vector_use>> ret = kvm_virtio_pci_irqfd_use(proxy, queue_no, vector);
+ *   - hw/virtio/virtio-pci.c|828| <<virtio_pci_vq_vector_unmask>> ret = kvm_virtio_pci_irqfd_use(proxy, queue_no, vector);
+ */
 static int kvm_virtio_pci_irqfd_use(VirtIOPCIProxy *proxy,
                                  unsigned int queue_no,
                                  unsigned int vector)
@@ -717,6 +726,10 @@ static void kvm_virtio_pci_irqfd_release(VirtIOPCIProxy *proxy,
     assert(ret == 0);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1020| <<virtio_pci_set_guest_notifiers>> r = kvm_virtio_pci_vector_use(proxy, nvqs);
+ */
 static int kvm_virtio_pci_vector_use(VirtIOPCIProxy *proxy, int nvqs)
 {
     PCIDevice *dev = &proxy->pci_dev;
@@ -733,6 +746,9 @@ static int kvm_virtio_pci_vector_use(VirtIOPCIProxy *proxy, int nvqs)
         if (vector >= msix_nr_vectors_allocated(dev)) {
             continue;
         }
+        /*
+	 * 这里的vector是queue vector, 是0, 1, 2 ...
+	 */
         ret = kvm_virtio_pci_vq_vector_use(proxy, queue_no, vector);
         if (ret < 0) {
             goto undo;
@@ -972,12 +988,51 @@ static bool virtio_pci_query_guest_notifiers(DeviceState *d)
     return msix_enabled(&proxy->pci_dev);
 }
 
+/*
+ * called by:
+ *   - backends/cryptodev-vhost.c|201| <<cryptodev_vhost_start>> r = k->set_guest_notifiers(qbus->parent, total_queues, true);
+ *   - backends/cryptodev-vhost.c|235| <<cryptodev_vhost_start>> e = k->set_guest_notifiers(qbus->parent, total_queues, false);
+ *   - backends/cryptodev-vhost.c|262| <<cryptodev_vhost_stop>> r = k->set_guest_notifiers(qbus->parent, total_queues, false);
+ *   - backends/vhost-user.c|81| <<vhost_user_backend_start>> ret = k->set_guest_notifiers(qbus->parent, b->dev.nvqs, true);
+ *   - backends/vhost-user.c|107| <<vhost_user_backend_start>> k->set_guest_notifiers(qbus->parent, b->dev.nvqs, false);
+ *   - backends/vhost-user.c|126| <<vhost_user_backend_stop>> ret = k->set_guest_notifiers(qbus->parent,
+ *   - hw/block/dataplane/virtio-blk.c|194| <<virtio_blk_data_plane_start>> r = k->set_guest_notifiers(qbus->parent, nvqs, true);
+ *   - hw/block/dataplane/virtio-blk.c|317| <<virtio_blk_data_plane_stop>> k->set_guest_notifiers(qbus->parent, nvqs, false);
+ *   - hw/block/vhost-user-blk.c|130| <<vhost_user_blk_start>> ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, true);
+ *   - hw/block/vhost-user-blk.c|176| <<vhost_user_blk_start>> k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);
+ *   - hw/block/vhost-user-blk.c|200| <<vhost_user_blk_stop>> ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);
+ *   - hw/net/vhost_net.c|343| <<vhost_net_start>> r = k->set_guest_notifiers(qbus->parent, total_queues * 2, true);
+ *   - hw/net/vhost_net.c|374| <<vhost_net_start>> e = k->set_guest_notifiers(qbus->parent, total_queues * 2, false);
+ *   - hw/net/vhost_net.c|395| <<vhost_net_stop>> r = k->set_guest_notifiers(qbus->parent, total_queues * 2, false);
+ *   - hw/scsi/vhost-scsi-common.c|47| <<vhost_scsi_common_start>> ret = k->set_guest_notifiers(qbus->parent, vsc->dev.nvqs, true);
+ *   - hw/scsi/vhost-scsi-common.c|91| <<vhost_scsi_common_start>> k->set_guest_notifiers(qbus->parent, vsc->dev.nvqs, false);
+ *   - hw/scsi/vhost-scsi-common.c|107| <<vhost_scsi_common_stop>> ret = k->set_guest_notifiers(qbus->parent, vsc->dev.nvqs, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|150| <<virtio_scsi_dataplane_start>> rc = k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, true);
+ *   - hw/scsi/virtio-scsi-dataplane.c|193| <<virtio_scsi_dataplane_start>> k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|234| <<virtio_scsi_dataplane_stop>> k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, false);
+ *   - hw/virtio/vhost-user-fs.c|70| <<vuf_start>> ret = k->set_guest_notifiers(qbus->parent, fs->vhost_dev.nvqs, true);
+ *   - hw/virtio/vhost-user-fs.c|95| <<vuf_start>> k->set_guest_notifiers(qbus->parent, fs->vhost_dev.nvqs, false);
+ *   - hw/virtio/vhost-user-fs.c|113| <<vuf_stop>> ret = k->set_guest_notifiers(qbus->parent, fs->vhost_dev.nvqs, false);
+ *   - hw/virtio/vhost-vsock-common.c|40| <<vhost_vsock_common_start>> ret = k->set_guest_notifiers(qbus->parent, vvc->vhost_dev.nvqs, true);
+ *   - hw/virtio/vhost-vsock-common.c|65| <<vhost_vsock_common_start>> k->set_guest_notifiers(qbus->parent, vvc->vhost_dev.nvqs, false);
+ *   - hw/virtio/vhost-vsock-common.c|84| <<vhost_vsock_common_stop>> ret = k->set_guest_notifiers(qbus->parent, vvc->vhost_dev.nvqs, false);
+ *
+ * 在以下使用virtio_pci_set_guest_notifiers():
+ *   - hw/virtio/virtio-pci.c|2179| <<virtio_pci_bus_class_init>> k->set_guest_notifiers = virtio_pci_set_guest_notifiers;
+ */
 static int virtio_pci_set_guest_notifiers(DeviceState *d, int nvqs, bool assign)
 {
     VirtIOPCIProxy *proxy = to_virtio_pci_proxy(d);
     VirtIODevice *vdev = virtio_bus_get_device(&proxy->bus);
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
     int r, n;
+    /*
+     * kvm_msi_via_irqfd_enabled:
+     *
+     * Returns: true if we can route a PCI MSI (Message Signaled Interrupt)
+     * to a KVM CPU via an irqfd. This requires that the kernel supports
+     * this and that we're running in a configuration that permits it.
+     */
     bool with_irqfd = msix_enabled(&proxy->pci_dev) &&
         kvm_msi_via_irqfd_enabled();
 
@@ -986,6 +1041,15 @@ static int virtio_pci_set_guest_notifiers(DeviceState *d, int nvqs, bool assign)
     /* When deassigning, pass a consistent nvqs value
      * to avoid leaking notifiers.
      */
+    /*
+     * 在以下使用VirtIOPCIProxy->nvqs_with_notifiers:
+     *   - hw/virtio/virtio-pci.c|876| <<virtio_pci_vector_unmask>> if (index < proxy->nvqs_with_notifiers) {
+     *   - hw/virtio/virtio-pci.c|892| <<virtio_pci_vector_unmask>> if (index < proxy->nvqs_with_notifiers) {
+     *   - hw/virtio/virtio-pci.c|913| <<virtio_pci_vector_mask>> if (index < proxy->nvqs_with_notifiers) {
+     *   - hw/virtio/virtio-pci.c|932| <<virtio_pci_vector_poll>> for (queue_no = 0; queue_no < proxy->nvqs_with_notifiers; queue_no++) {
+     *   - hw/virtio/virtio-pci.c|1034| <<virtio_pci_set_guest_notifiers>> assert(assign || nvqs == proxy->nvqs_with_notifiers);
+     *   - hw/virtio/virtio-pci.c|1036| <<virtio_pci_set_guest_notifiers>> proxy->nvqs_with_notifiers = nvqs;
+     */
     assert(assign || nvqs == proxy->nvqs_with_notifiers);
 
     proxy->nvqs_with_notifiers = nvqs;
@@ -1014,6 +1078,13 @@ static int virtio_pci_set_guest_notifiers(DeviceState *d, int nvqs, bool assign)
     /* Must set vector notifier after guest notifier has been assigned */
     if ((with_irqfd || k->guest_notifier_mask) && assign) {
         if (with_irqfd) {
+            /*
+	     * VirtIOPCIProxy *proxy:
+	     * -> VirtIOIRQFD *vector_irqfd;
+	     *    -> MSIMessage msg;
+	     *    -> int virq;
+	     *    -> unsigned int users;
+	     */
             proxy->vector_irqfd =
                 g_malloc0(sizeof(*proxy->vector_irqfd) *
                           msix_nr_vectors_allocated(&proxy->pci_dev));
diff --git a/hw/virtio/virtio-pci.h b/hw/virtio/virtio-pci.h
index 2446dcd9a..a7038adf6 100644
--- a/hw/virtio/virtio-pci.h
+++ b/hw/virtio/virtio-pci.h
@@ -154,6 +154,15 @@ struct VirtIOPCIProxy {
     VirtIOPCIQueue vqs[VIRTIO_QUEUE_MAX];
 
     VirtIOIRQFD *vector_irqfd;
+    /*
+     * 在以下使用VirtIOPCIProxy->nvqs_with_notifiers:
+     *   - hw/virtio/virtio-pci.c|876| <<virtio_pci_vector_unmask>> if (index < proxy->nvqs_with_notifiers) {
+     *   - hw/virtio/virtio-pci.c|892| <<virtio_pci_vector_unmask>> if (index < proxy->nvqs_with_notifiers) {
+     *   - hw/virtio/virtio-pci.c|913| <<virtio_pci_vector_mask>> if (index < proxy->nvqs_with_notifiers) {
+     *   - hw/virtio/virtio-pci.c|932| <<virtio_pci_vector_poll>> for (queue_no = 0; queue_no < proxy->nvqs_with_notifiers; queue_no++) {
+     *   - hw/virtio/virtio-pci.c|1034| <<virtio_pci_set_guest_notifiers>> assert(assign || nvqs == proxy->nvqs_with_notifiers);
+     *   - hw/virtio/virtio-pci.c|1036| <<virtio_pci_set_guest_notifiers>> proxy->nvqs_with_notifiers = nvqs;
+     */
     int nvqs_with_notifiers;
     VirtioBusState bus;
 };
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index 07f4e60b3..065ee7034 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -232,6 +232,14 @@ void virtio_queue_update_rings(VirtIODevice *vdev, int n)
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|985| <<virtqueue_split_read_next_desc>> vring_split_desc_read(vdev, desc, desc_cache, *next);
+ *   - hw/virtio/virtio.c|1024| <<virtqueue_split_get_avail_bytes>> vring_split_desc_read(vdev, &desc, desc_cache, i);
+ *   - hw/virtio/virtio.c|1050| <<virtqueue_split_get_avail_bytes>> vring_split_desc_read(vdev, &desc, desc_cache, i);
+ *   - hw/virtio/virtio.c|1469| <<virtqueue_split_pop>> vring_split_desc_read(vdev, &desc, desc_cache, i);
+ *   - hw/virtio/virtio.c|1487| <<virtqueue_split_pop>> vring_split_desc_read(vdev, &desc, desc_cache, i);
+ */
 static void vring_split_desc_read(VirtIODevice *vdev, VRingDesc *desc,
                                   MemoryRegionCache *cache, int i)
 {
@@ -941,6 +949,12 @@ static int virtqueue_num_heads(VirtQueue *vq, unsigned int idx)
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1020| <<virtqueue_split_get_avail_bytes>> if (!virtqueue_get_head(vq, idx++, &i)) {
+ *   - hw/virtio/virtio.c|1447| <<virtqueue_split_pop>> if (!virtqueue_get_head(vq, vq->last_avail_idx++, &head)) {
+ *   - hw/virtio/virtio.c|1761| <<virtqueue_split_drop_all>> if (!virtqueue_get_head(vq, vq->last_avail_idx, &elem.index)) {
+ */
 static bool virtqueue_get_head(VirtQueue *vq, unsigned int idx,
                                unsigned int *head)
 {
@@ -1295,6 +1309,13 @@ int virtqueue_avail_bytes(VirtQueue *vq, unsigned int in_bytes,
     return in_bytes <= in_total && out_bytes <= out_total;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1520| <<virtqueue_split_pop>> map_ok = virtqueue_map_desc(vdev, &in_num, addr + out_num,
+ *   - hw/virtio/virtio.c|1529| <<virtqueue_split_pop>> map_ok = virtqueue_map_desc(vdev, &out_num, addr, iov,
+ *   - hw/virtio/virtio.c|1664| <<virtqueue_packed_pop>> map_ok = virtqueue_map_desc(vdev, &in_num, addr + out_num,
+ *   - hw/virtio/virtio.c|1673| <<virtqueue_packed_pop>> map_ok = virtqueue_map_desc(vdev, &out_num, addr, iov,
+ */
 static bool virtqueue_map_desc(VirtIODevice *vdev, unsigned int *p_num_sg,
                                hwaddr *addr, struct iovec *iov,
                                unsigned int max_num_sg, bool is_write,
@@ -1318,6 +1339,11 @@ static bool virtqueue_map_desc(VirtIODevice *vdev, unsigned int *p_num_sg,
             goto out;
         }
 
+        /*
+	 * struct iovec *iov:
+	 * -> void *iov_base;
+	 * -> size_t iov_len;
+	 */
         iov[num_sg].iov_base = dma_memory_map(vdev->dma_as, pa, &len,
                                               is_write ?
                                               DMA_DIRECTION_FROM_DEVICE :
@@ -1389,6 +1415,14 @@ void virtqueue_map(VirtIODevice *vdev, VirtQueueElement *elem)
                                                                         false);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1526| <<virtqueue_split_pop>> elem = virtqueue_alloc_element(sz, out_num, in_num);
+ *   - hw/virtio/virtio.c|1652| <<virtqueue_packed_pop>> elem = virtqueue_alloc_element(sz, out_num, in_num);
+ *   - hw/virtio/virtio.c|1832| <<qemu_get_virtqueue_element>> elem = virtqueue_alloc_element(sz, data.out_num, data.in_num);
+ *   - subprojects/libvhost-user/libvhost-user.c|2501| <<virtqueue_alloc_element>> virtqueue_alloc_element(size_t sz,
+ *   - subprojects/libvhost-user/libvhost-user.c|2596| <<vu_queue_map_desc>> elem = virtqueue_alloc_element(sz, out_num, in_num);
+ */
 static void *virtqueue_alloc_element(size_t sz, unsigned out_num, unsigned in_num)
 {
     VirtQueueElement *elem;
@@ -1444,6 +1478,9 @@ static void *virtqueue_split_pop(VirtQueue *vq, size_t sz)
         goto done;
     }
 
+    /*
+     * unsigned int head;
+     */
     if (!virtqueue_get_head(vq, vq->last_avail_idx++, &head)) {
         goto done;
     }
@@ -1465,6 +1502,13 @@ static void *virtqueue_split_pop(VirtQueue *vq, size_t sz)
         goto done;
     }
 
+    /*
+     * VRingDesc desc;
+     * -> uint64_t addr;
+     * -> uint32_t len;
+     * -> uint16_t flags;
+     * -> uint16_t next;
+     */
     desc_cache = &caches->desc;
     vring_split_desc_read(vdev, &desc, desc_cache, i);
     if (desc.flags & VRING_DESC_F_INDIRECT) {
@@ -1484,6 +1528,13 @@ static void *virtqueue_split_pop(VirtQueue *vq, size_t sz)
 
         max = desc.len / sizeof(VRingDesc);
         i = 0;
+        /*
+	 * VRingDesc desc;
+	 * -> uint64_t addr;
+	 * -> uint32_t len;
+         * -> uint16_t flags;
+         * -> uint16_t next;
+	 */
         vring_split_desc_read(vdev, &desc, desc_cache, i);
     }
 
@@ -1491,6 +1542,13 @@ static void *virtqueue_split_pop(VirtQueue *vq, size_t sz)
     do {
         bool map_ok;
 
+	/*
+	 * unsigned out_num, in_num, elem_entries;
+	 * hwaddr addr[VIRTQUEUE_MAX_SIZE];
+	 * struct iovec iov[VIRTQUEUE_MAX_SIZE];
+	 * -> void *iov_base; 
+	 * -> size_t iov_len;
+	 */
         if (desc.flags & VRING_DESC_F_WRITE) {
             map_ok = virtqueue_map_desc(vdev, &in_num, addr + out_num,
                                         iov + out_num,
@@ -1501,6 +1559,12 @@ static void *virtqueue_split_pop(VirtQueue *vq, size_t sz)
                 virtio_error(vdev, "Incorrect order for descriptors");
                 goto err_undo_map;
             }
+            /*
+	     * 把desc给map到iov的数组
+	     * struct iovec *iov:
+	     * -> void *iov_base;
+	     * -> size_t iov_len;
+	     */
             map_ok = virtqueue_map_desc(vdev, &out_num, addr, iov,
                                         VIRTQUEUE_MAX_SIZE, false,
                                         desc.addr, desc.len);
@@ -1526,6 +1590,22 @@ static void *virtqueue_split_pop(VirtQueue *vq, size_t sz)
     elem = virtqueue_alloc_element(sz, out_num, in_num);
     elem->index = head;
     elem->ndescs = 1;
+    /*
+     * VirtQueueElement *elem:
+     * -> unsigned int index;
+     * -> unsigned int len;
+     * -> unsigned int ndescs;
+     * -> unsigned int out_num;
+     * -> unsigned int in_num;
+     * -> hwaddr *in_addr;
+     * -> hwaddr *out_addr;
+     * -> struct iovec *in_sg;
+     *    -> void *iov_base; 
+     *    -> size_t iov_len;
+     * -> struct iovec *out_sg;
+     *    -> void *iov_base; 
+     *    -> size_t iov_len;
+     */
     for (i = 0; i < out_num; i++) {
         elem->out_addr[i] = addr[i];
         elem->out_sg[i] = iov[i];
@@ -1683,6 +1763,37 @@ err_undo_map:
     goto done;
 }
 
+/*
+ * called by:
+ *   - hw/9pfs/virtio-9p-device.c|52| <<handle_9p_output>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/block/virtio-blk.c|258| <<virtio_blk_get_request>> VirtIOBlockReq *req = virtqueue_pop(vq, sizeof(VirtIOBlockReq));
+ *   - hw/char/virtio-serial-bus.c|117| <<write_to_port>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/char/virtio-serial-bus.c|142| <<discard_vq_data>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/char/virtio-serial-bus.c|176| <<do_flush_queued_data>> port->elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/char/virtio-serial-bus.c|235| <<send_control_msg>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/char/virtio-serial-bus.c|473| <<control_out>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/display/virtio-gpu.c|875| <<virtio_gpu_handle_ctrl>> cmd = virtqueue_pop(vq, sizeof(struct virtio_gpu_ctrl_command));
+ *   - hw/display/virtio-gpu.c|881| <<virtio_gpu_handle_ctrl>> cmd = virtqueue_pop(vq, sizeof(struct virtio_gpu_ctrl_command));
+ *   - hw/display/virtio-gpu.c|910| <<virtio_gpu_handle_cursor>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/input/virtio-input.c|48| <<virtio_input_send>> elem = virtqueue_pop(vinput->evt, sizeof(VirtQueueElement));
+ *   - hw/input/virtio-input.c|86| <<virtio_input_handle_sts>> elem = virtqueue_pop(vinput->sts, sizeof(VirtQueueElement));
+ *   - hw/net/virtio-net.c|1352| <<virtio_net_handle_ctrl>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/net/virtio-net.c|1696| <<virtio_net_receive_rcu>> elem = virtqueue_pop(q->rx_vq, sizeof(VirtQueueElement));
+ *   - hw/net/virtio-net.c|2426| <<virtio_net_flush_tx>> elem = virtqueue_pop(q->tx_vq, sizeof(VirtQueueElement));
+ *   - hw/scsi/virtio-scsi.c|252| <<virtio_scsi_pop_req>> req = virtqueue_pop(vq, sizeof(VirtIOSCSIReq) + vs->cdb_size);
+ *   - hw/virtio/vhost-vsock-common.c|123| <<vhost_vsock_common_send_transport_reset>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/virtio/virtio-balloon.c|332| <<virtio_balloon_handle_report>> while ((elem = virtqueue_pop(vq, sizeof(VirtQueueElement)))) {
+ *   - hw/virtio/virtio-balloon.c|399| <<virtio_balloon_handle_output>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/virtio/virtio-balloon.c|455| <<virtio_balloon_receive_stats>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/virtio/virtio-balloon.c|517| <<get_free_page_hints>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/virtio/virtio-crypto.c|233| <<virtio_crypto_handle_ctrl>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/virtio/virtio-crypto.c|417| <<virtio_crypto_get_request>> VirtIOCryptoReq *req = virtqueue_pop(vq, sizeof(VirtIOCryptoReq));
+ *   - hw/virtio/virtio-iommu.c|600| <<virtio_iommu_handle_command>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/virtio/virtio-iommu.c|679| <<virtio_iommu_report_fault>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/virtio/virtio-mem.c|389| <<virtio_mem_handle_request>> elem = virtqueue_pop(vq, sizeof(VirtQueueElement));
+ *   - hw/virtio/virtio-pmem.c|76| <<virtio_pmem_flush>> req_data = virtqueue_pop(vq, sizeof(VirtIODeviceRequest));
+ *   - hw/virtio/virtio-rng.c|72| <<chr_read>> elem = virtqueue_pop(vrng->vq, sizeof(VirtQueueElement));
+ */
 void *virtqueue_pop(VirtQueue *vq, size_t sz)
 {
     if (virtio_device_disabled(vq->vdev)) {
@@ -1933,6 +2044,18 @@ static int virtio_validate_features(VirtIODevice *vdev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/vhost-user-blk.c|535| <<vhost_user_blk_device_unrealize>> virtio_set_status(vdev, 0);
+ *   - hw/s390x/virtio-ccw.c|535| <<virtio_ccw_cb>> if (virtio_set_status(vdev, status) == 0) {
+ *   - hw/virtio/virtio-mmio.c|425| <<virtio_mmio_write>> virtio_set_status(vdev, value & 0xff);
+ *   - hw/virtio/virtio-pci.c|333| <<virtio_ioport_write>> virtio_set_status(vdev, val & 0xFF);
+ *   - hw/virtio/virtio-pci.c|618| <<virtio_write_config>> virtio_set_status(vdev, vdev->status & ~VIRTIO_CONFIG_S_DRIVER_OK);
+ *   - hw/virtio/virtio-pci.c|1331| <<virtio_pci_common_write>> virtio_set_status(vdev, val & 0xFF);
+ *   - hw/virtio/virtio.c|2102| <<virtio_reset>> virtio_set_status(vdev, 0);
+ *   - hw/virtio/virtio.c|3331| <<virtio_vmstate_change>> virtio_set_status(vdev, vdev->status);
+ *   - hw/virtio/virtio.c|3339| <<virtio_vmstate_change>> virtio_set_status(vdev, vdev->status);
+ */
 int virtio_set_status(VirtIODevice *vdev, uint8_t val)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -3526,6 +3649,13 @@ EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
     return &vq->guest_notifier;
 }
 
+/*
+ * 在以下使用virtio_queue_host_notifier_aio_read():
+ *   - hw/virtio/virtio.c|3570| <<virtio_queue_aio_set_host_notifier_handler>> aio_set_event_notifier(ctx, &vq->host_notifier, true,
+ *                                                                               virtio_queue_host_notifier_aio_read,
+ *                                                                               virtio_queue_host_notifier_aio_poll);
+ *   - hw/virtio/virtio.c|3579| <<virtio_queue_aio_set_host_notifier_handler>> virtio_queue_host_notifier_aio_read(&vq->host_notifier);
+ */
 static void virtio_queue_host_notifier_aio_read(EventNotifier *n)
 {
     VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
diff --git a/include/block/accounting.h b/include/block/accounting.h
index 878b4c358..fb30ba815 100644
--- a/include/block/accounting.h
+++ b/include/block/accounting.h
@@ -95,6 +95,11 @@ struct BlockAcctStats {
 
 typedef struct BlockAcctCookie {
     int64_t bytes;
+    /*
+     * 在以下使用BlockAcctCookie->start_time_ns:
+     *   - block/accounting.c|93| <<block_acct_start>> cookie->start_time_ns = qemu_clock_get_ns(clock_type);
+     *   - block/accounting.c|190| <<block_account_one_io>> int64_t latency_ns = time_ns - cookie->start_time_ns; 
+     */
     int64_t start_time_ns;
     enum BlockAcctType type;
 } BlockAcctCookie;
diff --git a/include/hw/core/cpu.h b/include/hw/core/cpu.h
index c68bc3ba8..e4ae74fbd 100644
--- a/include/hw/core/cpu.h
+++ b/include/hw/core/cpu.h
@@ -419,6 +419,35 @@ struct CPUState {
     int32_t exception_index;
 
     /* shared by kvm, hax and hvf */
+    /*
+     * 在以下修改CPUSTate->vcpu_dirty:
+     *   - accel/kvm/kvm-all.c|462| <<kvm_init_vcpu>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|2455| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|2482| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|2493| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|2503| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|2586| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/i386/hax/hax-all.c|229| <<hax_init_vcpu>> cpu->vcpu_dirty = true;
+     *   - target/i386/hax/hax-all.c|628| <<do_hax_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - target/i386/hax/hax-all.c|644| <<do_hax_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - target/i386/hax/hax-all.c|657| <<do_hax_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - target/i386/hax/hax-all.c|644| <<do_hax_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - target/i386/hax/hax-all.c|657| <<do_hax_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - target/i386/hax/hax-all.c|667| <<do_hax_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - target/i386/hvf/hvf.c|284| <<do_hvf_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - target/i386/hvf/hvf.c|299| <<do_hvf_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - target/i386/hvf/hvf.c|311| <<do_hvf_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - target/i386/hvf/hvf.c|322| <<do_hvf_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - target/i386/hvf/hvf.c|536| <<hvf_init_vcpu>> cpu->vcpu_dirty = 1;
+     *   - target/i386/hvf/hvf.c|708| <<hvf_vcpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|675| <<whpx_emu_setreg_callback>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|987| <<whpx_vcpu_run>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|1265| <<do_whpx_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - target/i386/whpx/whpx-all.c|1273| <<do_whpx_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|1280| <<do_whpx_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - target/i386/whpx/whpx-all.c|1286| <<do_whpx_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - target/i386/whpx/whpx-all.c|1439| <<whpx_init_vcpu>> cpu->vcpu_dirty = true;
+     */
     bool vcpu_dirty;
 
     /* Used to keep track of an outstanding cpu throttle thread for migration
diff --git a/include/hw/misc/pvpanic.h b/include/hw/misc/pvpanic.h
index ca3c5bb53..fe0b056b5 100644
--- a/include/hw/misc/pvpanic.h
+++ b/include/hw/misc/pvpanic.h
@@ -27,6 +27,13 @@
 #define PVPANIC_F_CRASHLOADED   1
 
 /* The pv event value */
+/*
+ * 在以下使用PVPANIC_PANICKED:
+ *   - hw/misc/pvpanic-isa.c|68| <<global>> DEFINE_PROP_UINT8("events", PVPanicISAState, pvpanic.events, PVPANIC_PANICKED | PVPANIC_CRASHLOADED),
+ *   - hw/misc/pvpanic-pci.c|57| <<global>> DEFINE_PROP_UINT8("events", PVPanicPCIState, pvpanic.events, PVPANIC_PANICKED | PVPANIC_CRASHLOADED),
+ *   - hw/misc/pvpanic.c|29| <<handle_event>> if (event & ~(PVPANIC_PANICKED | PVPANIC_CRASHLOADED) && !logged) {
+ *   - hw/misc/pvpanic.c|34| <<handle_event>> if (event & PVPANIC_PANICKED) {
+ */
 #define PVPANIC_PANICKED        (1 << PVPANIC_F_PANICKED)
 #define PVPANIC_CRASHLOADED     (1 << PVPANIC_F_CRASHLOADED)
 
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 6be4e0c46..a6af2e51d 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -329,6 +329,15 @@ struct PCIDevice {
     /* Reference-count for entries actually in use by driver. */
     unsigned *msix_entry_used;
     /* MSIX function mask set or MSIX disabled */
+    /*
+     * 在以下使用PCIDevice->msix_function_masked:
+     *   - hw/pci/msix.c|97| <<msix_is_masked>> return msix_vector_masked(dev, vector, dev->msix_function_masked);
+     *   - hw/pci/msix.c|153| <<msix_update_function_masked>> dev->msix_function_masked = !msix_enabled(dev) || msix_masked(dev);
+     *   - hw/pci/msix.c|170| <<msix_write_config>> was_masked = dev->msix_function_masked;
+     *   - hw/pci/msix.c|179| <<msix_write_config>> if (dev->msix_function_masked == was_masked) {
+     *   - hw/pci/msix.c|337| <<msix_init>> dev->msix_function_masked = true;
+     *   - hw/vfio/pci.c|598| <<vfio_msix_enable>> if (!pdev->msix_function_masked) {
+     */
     bool msix_function_masked;
     /* Version id needed for VMState */
     int32_t version_id;
@@ -353,6 +362,18 @@ struct PCIDevice {
     PCIINTxRoutingNotifier intx_routing_notifier;
 
     /* MSI-X notifiers */
+    /*
+     * 在以下设置PCIDevie->msix_vector_use_notifier:
+     *   - hw/pci/msix.c|597| <<msix_set_vector_notifiers>> dev->msix_vector_use_notifier = use_notifier;
+     *   - hw/pci/msix.c|619| <<msix_set_vector_notifiers>> dev->msix_vector_use_notifier = NULL;
+     *   - hw/pci/msix.c|637| <<msix_unset_vector_notifiers>> dev->msix_vector_use_notifier = NULL;
+     * 在以下使用PCIDevie->msix_vector_use_notifier:
+     *   - hw/misc/ivshmem.c|795| <<ivshmem_disable_irqfd>> if (!pdev->msix_vector_use_notifier) {
+     *   - hw/pci/msix.c|106| <<msix_fire_vector_notifier>> if (!dev->msix_vector_use_notifier) {
+     *   - hw/pci/msix.c|113| <<msix_fire_vector_notifier>> ret = dev->msix_vector_use_notifier(dev, vector, msg);
+     *   - hw/pci/msix.c|571| <<msix_set_notifier_for_vector>> return dev->msix_vector_use_notifier(dev, vector, msg);
+     *   - hw/pci/msix.c|628| <<msix_unset_vector_notifiers>> assert(dev->msix_vector_use_notifier &&
+     */
     MSIVectorUseNotifier msix_vector_use_notifier;
     MSIVectorReleaseNotifier msix_vector_release_notifier;
     MSIVectorPollNotifier msix_vector_poll_notifier;
diff --git a/include/hw/remote/mpqemu-link.h b/include/hw/remote/mpqemu-link.h
index 4ec091588..89345fd85 100644
--- a/include/hw/remote/mpqemu-link.h
+++ b/include/hw/remote/mpqemu-link.h
@@ -39,6 +39,12 @@ typedef enum {
     MPQEMU_CMD_PCI_CFGREAD,
     MPQEMU_CMD_BAR_WRITE,
     MPQEMU_CMD_BAR_READ,
+    /*
+     * 在以下使用MPQEMU_CMD_SET_IRQFD:
+     *   - hw/remote/message.c|76| <<mpqemu_remote_msg_loop_co>> case MPQEMU_CMD_SET_IRQFD:
+     *   - hw/remote/mpqemu-link.c|257| <<mpqemu_msg_valid>> case MPQEMU_CMD_SET_IRQFD:
+     *   - hw/remote/proxy.c|62| <<setup_irqfd>> msg.cmd = MPQEMU_CMD_SET_IRQFD;
+     */
     MPQEMU_CMD_SET_IRQFD,
     MPQEMU_CMD_DEVICE_RESET,
     MPQEMU_CMD_MAX,
diff --git a/include/hw/scsi/scsi.h b/include/hw/scsi/scsi.h
index 0b726bc78..096421a3b 100644
--- a/include/hw/scsi/scsi.h
+++ b/include/hw/scsi/scsi.h
@@ -28,6 +28,19 @@ struct SCSIRequest {
     uint32_t          tag;
     uint32_t          lun;
     int16_t           status;
+    /*
+     * 在以下设置SCSIRequest->host_status:
+     *   - hw/scsi/scsi-bus.c|729| <<scsi_req_alloc>> req->host_status = -1;
+     *   - hw/scsi/scsi-bus.c|1622| <<scsi_req_complete_failed>> req->host_status = host_status;
+     *   - hw/scsi/scsi-bus.c|1672| <<scsi_req_complete>> req->host_status = SCSI_HOST_OK;
+     * 在以下使用SCSIRequest->host_status:
+     *   - hw/scsi/scsi-bus.c|1610| <<scsi_req_complete_failed>> assert(req->status == -1 && req->host_status == -1);
+     *   - hw/scsi/scsi-bus.c|1614| <<scsi_req_complete_failed>> status = scsi_sense_from_host_status(req->host_status, &sense);
+     *   - hw/scsi/scsi-bus.c|1670| <<scsi_req_complete>> assert(req->status == -1 && req->host_status == -1);
+     *   - hw/scsi/scsi-bus.c|1860| <<put_scsi_requests>> assert(req->status == -1 && req->host_status == -1);
+     *   - hw/scsi/virtio-scsi.c|522| <<virtio_scsi_command_failed>> switch (r->host_status) {
+     *   - hw/scsi/vmw_pvscsi.c|525| <<pvscsi_command_failed>> switch (req->host_status) {
+     */
     int16_t           host_status;
     void              *hba_private;
     size_t            resid;
@@ -41,6 +54,20 @@ struct SCSIRequest {
      * */
 
     uint8_t           sense[SCSI_SENSE_BUF_SIZE];
+    /*
+     * 在以下设置SCSIRequest->sense_len:
+     *   - hw/scsi/scsi-bus.c|954| <<scsi_req_build_sense>> req->sense_len = scsi_build_sense(req->sense, sense);
+     *   - hw/scsi/scsi-bus.c|1696| <<scsi_req_complete>> req->sense_len = 0;
+     *   - hw/scsi/scsi-disk.c|3427| <<scsi_block_update_sense>> r->req.sense_len = MIN(br->io_header.sb_len_wr, sizeof(r->req.sense));
+     *   - hw/scsi/scsi-generic.c|99| <<scsi_command_complete_noio>> r->req.sense_len = io_hdr->sb_len_wr;
+     * 在以下使用SCSIRequest->sense_len:
+     *   - hw/scsi/scsi-bus.c|908| <<scsi_req_get_sense>> if (!req->sense_len) {
+     *   - hw/scsi/scsi-bus.c|912| <<scsi_req_get_sense>> ret = scsi_convert_sense(req->sense, req->sense_len, buf, len, true);
+     *   - hw/scsi/scsi-bus.c|1694| <<scsi_req_complete>> assert(req->sense_len <= sizeof(req->sense));
+     *   - hw/scsi/scsi-bus.c|1699| <<scsi_req_complete>> if (req->sense_len) {
+     *   - hw/scsi/scsi-bus.c|1708| <<scsi_req_complete>> memcpy(req->dev->sense, req->sense, req->sense_len);
+     *   - hw/scsi/scsi-bus.c|1709| <<scsi_req_complete>> req->dev->sense_len = req->sense_len;
+     */
     uint32_t          sense_len;
     bool              enqueued;
     bool              io_canceled;
diff --git a/include/hw/virtio/virtio-scsi.h b/include/hw/virtio/virtio-scsi.h
index 543681bc1..32bc08b19 100644
--- a/include/hw/virtio/virtio-scsi.h
+++ b/include/hw/virtio/virtio-scsi.h
@@ -103,7 +103,29 @@ typedef struct VirtIOSCSIReq {
 
     VirtIOSCSI *dev;
     VirtQueue *vq;
+    /*
+     * 在以下使用VirtIOSCSIReq->qsgl:
+     *   - hw/scsi/virtio-scsi.c|126| <<virtio_scsi_init_req>> qemu_sglist_init(&req->qsgl, DEVICE(s), 8, vdev->dma_as);
+     *   - hw/scsi/virtio-scsi.c|134| <<virtio_scsi_free_req>> qemu_sglist_destroy(&req->qsgl);
+     *   - hw/scsi/virtio-scsi.c|145| <<virtio_scsi_complete_req>> virtqueue_push(vq, &req->elem, req->qsgl.size + req->resp_iov.size);
+     *   - hw/scsi/virtio-scsi.c|169| <<qemu_sgl_concat>> QEMUSGList *qsgl = &req->qsgl;
+     *   - hw/scsi/virtio-scsi.c|176| <<qemu_sgl_concat>> qemu_sglist_add(qsgl, *addr + skip, iov->iov_len - skip);
+     *   - hw/scsi/virtio-scsi.c|710| <<virtio_scsi_parse_cdb>> cmd->xfer = req->qsgl.size;
+     *   - hw/scsi/virtio-scsi.c|719| <<virtio_scsi_get_sg_list>> return &req->qsgl;
+     *   - hw/scsi/virtio-scsi.c|817| <<virtio_scsi_handle_cmd_req_prepare>> req->sreq->cmd.xfer > req->qsgl.size)) {
+     */
     QEMUSGList qsgl;
+    /*
+     * 在以下使用VirtIOSCSIReq->resp_iov:
+     *   - hw/scsi/virtio-scsi.c|127| <<virtio_scsi_init_req>> offsetof(VirtIOSCSIReq, resp_iov) + sizeof(req->resp_iov);
+     *   - hw/scsi/virtio-scsi.c|132| <<virtio_scsi_init_req>> qemu_iovec_init(&req->resp_iov, 1);
+     *   - hw/scsi/virtio-scsi.c|138| <<virtio_scsi_free_req>> qemu_iovec_destroy(&req->resp_iov);
+     *   - hw/scsi/virtio-scsi.c|149| <<virtio_scsi_complete_req>> qemu_iovec_from_buf(&req->resp_iov, 0, &req->resp, req->resp_size);
+     *   - hw/scsi/virtio-scsi.c|150| <<virtio_scsi_complete_req>> virtqueue_push(vq, &req->elem, req->qsgl.size + req->resp_iov.size);
+     *   - hw/scsi/virtio-scsi.c|213| <<virtio_scsi_parse_req>> if (qemu_iovec_concat_iov(&req->resp_iov,
+     *   - hw/scsi/virtio-scsi.c|702| <<virtio_scsi_command_complete>> sense_len = MIN(sense_len, req->resp_iov.size - sizeof(req->resp.cmd));
+     *   - hw/scsi/virtio-scsi.c|703| <<virtio_scsi_command_complete>> qemu_iovec_from_buf(&req->resp_iov, sizeof(req->resp.cmd),
+     */
     QEMUIOVector resp_iov;
 
     union {
diff --git a/include/qemu/timer.h b/include/qemu/timer.h
index 88ef11468..3cadbe974 100644
--- a/include/qemu/timer.h
+++ b/include/qemu/timer.h
@@ -829,6 +829,27 @@ static inline int64_t get_clock(void)
 
 extern int use_rt_clock;
 
+/*
+ * called by:
+ *   - include/qemu/timer.h|988| <<cpu_get_host_ticks>> return get_clock();
+ *   - include/qemu/timer.h|995| <<profile_getclock>> return get_clock();
+ *   - semihosting/arm-compat-semi.c|1261| <<do_common_semihosting>> elapsed = get_clock() - clock_start;
+ *   - softmmu/cpu-timers.c|82| <<cpu_get_clock_locked>> time += get_clock();
+ *   - softmmu/cpu-timers.c|115| <<cpu_enable_ticks>> timers_state.cpu_clock_offset -= get_clock();
+ *   - trace/simple.c|174| <<writeout_thread>> dropped.rec.timestamp_ns = get_clock();
+ *   - trace/simple.c|217| <<trace_record_start>> uint64_t timestamp_ns = get_clock();
+ *   - util/qemu-timer-common.c|46| <<init_get_clock>> clock_start = get_clock();
+ *   - util/qemu-timer-common.c|61| <<init_get_clock>> clock_start = get_clock();
+ *   - util/qemu-timer.c|634| <<qemu_clock_get_ns>> return get_clock();
+ *   - util/qsp.c|366| <<QSP_GEN_VOID>> t0 = get_clock(); \
+ *   - util/qsp.c|368| <<QSP_GEN_VOID>> t1 = get_clock(); \
+ *   - util/qsp.c|381| <<QSP_GEN_RET1>> t0 = get_clock(); \
+ *   - util/qsp.c|383| <<QSP_GEN_RET1>> t1 = get_clock(); \
+ *   - util/qsp.c|408| <<qsp_cond_wait>> t0 = get_clock();
+ *   - util/qsp.c|410| <<qsp_cond_wait>> t1 = get_clock();
+ *   - util/qsp.c|424| <<qsp_cond_timedwait>> t0 = get_clock();
+ *   - util/qsp.c|426| <<qsp_cond_timedwait>> t1 = get_clock();
+ */
 static inline int64_t get_clock(void)
 {
     if (use_rt_clock) {
diff --git a/include/scsi/utils.h b/include/scsi/utils.h
index d5c8efa16..2fa96941e 100644
--- a/include/scsi/utils.h
+++ b/include/scsi/utils.h
@@ -21,6 +21,12 @@ enum SCSIHostStatus {
     SCSI_HOST_NO_LUN,
     SCSI_HOST_BUSY,
     SCSI_HOST_TIME_OUT,
+    /*
+     * 在以下使用SCSI_HOST_BAD_RESPONSE:
+     *   - hw/scsi/virtio-scsi.c|533| <<virtio_scsi_command_failed>> case SCSI_HOST_BAD_RESPONSE:
+     *   - hw/scsi/vmw_pvscsi.c|536| <<pvscsi_command_failed>> case SCSI_HOST_BAD_RESPONSE:
+     *   - scsi/utils.c|635| <<scsi_sense_from_host_status>> case SCSI_HOST_BAD_RESPONSE:
+     */
     SCSI_HOST_BAD_RESPONSE,
     SCSI_HOST_ABORTED,
     SCSI_HOST_ERROR = 0x07,
diff --git a/include/standard-headers/linux/virtio_pci.h b/include/standard-headers/linux/virtio_pci.h
index db7a8e2fc..9a50619d1 100644
--- a/include/standard-headers/linux/virtio_pci.h
+++ b/include/standard-headers/linux/virtio_pci.h
@@ -73,6 +73,11 @@
 /* A 16-bit vector for configuration changes. */
 #define VIRTIO_MSI_CONFIG_VECTOR        20
 /* A 16-bit vector for selected queue notifications. */
+/*
+ * 在以下使用VIRTIO_MSI_QUEUE_VECTOR:
+ *   - hw/virtio/virtio-pci.c|360| <<virtio_ioport_write>> case VIRTIO_MSI_QUEUE_VECTOR:
+ *   - hw/virtio/virtio-pci.c|409| <<virtio_ioport_read>> case VIRTIO_MSI_QUEUE_VECTOR:
+ */
 #define VIRTIO_MSI_QUEUE_VECTOR         22
 
 /* The remaining space is defined by each driver as the per-driver
diff --git a/include/sysemu/accel-ops.h b/include/sysemu/accel-ops.h
index 032f6979d..90310bbf2 100644
--- a/include/sysemu/accel-ops.h
+++ b/include/sysemu/accel-ops.h
@@ -28,6 +28,22 @@ struct AccelOpsClass {
     /* initialization function called when accel is chosen */
     void (*ops_init)(AccelOpsClass *ops);
 
+    /*
+     * 在以下设置AccelOpsClass->create_vcpu_thread:
+     *   - accel/kvm/kvm-accel-ops.c|81| <<kvm_accel_ops_class_init>> ops->create_vcpu_thread = kvm_start_vcpu_thread;
+     *   - accel/qtest/qtest.c|53| <<qtest_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+     *   - accel/tcg/tcg-accel-ops.c|98| <<tcg_accel_ops_init>> ops->create_vcpu_thread = mttcg_start_vcpu_thread;
+     *   - accel/tcg/tcg-accel-ops.c|102| <<tcg_accel_ops_init>> ops->create_vcpu_thread = rr_start_vcpu_thread;
+     *   - accel/tcg/tcg-accel-ops.c|108| <<tcg_accel_ops_init>> ops->create_vcpu_thread = rr_start_vcpu_thread;
+     *   - accel/xen/xen-all.c|222| <<xen_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+     *   - target/i386/hax/hax-accel-ops.c|81| <<hax_accel_ops_class_init>> ops->create_vcpu_thread = hax_start_vcpu_thread;
+     * 在以下使用AccelOpsClass->create_vcpu_thread:
+     *   - softmmu/cpus.c|605| <<cpus_register_accel>> assert(ops->create_vcpu_thread != NULL);
+     *   - softmmu/cpus.c|627| <<qemu_init_vcpu>> g_assert(cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL);
+     *   - softmmu/cpus.c|628| <<qemu_init_vcpu>> cpus_accel->create_vcpu_thread(cpu);
+     *   - target/i386/hvf/hvf-accel-ops.c|128| <<hvf_accel_ops_class_init>> ops->create_vcpu_thread = hvf_start_vcpu_thread;
+     *   - target/i386/whpx/whpx-accel-ops.c|90| <<whpx_accel_ops_class_init>> ops->create_vcpu_thread = whpx_start_vcpu_thread;
+     */
     void (*create_vcpu_thread)(CPUState *cpu); /* MANDATORY NON-NULL */
     void (*kick_vcpu_thread)(CPUState *cpu);
 
diff --git a/include/sysemu/dma.h b/include/sysemu/dma.h
index 3201e7901..6955facd0 100644
--- a/include/sysemu/dma.h
+++ b/include/sysemu/dma.h
@@ -192,6 +192,22 @@ MemTxResult dma_memory_set(AddressSpace *as, dma_addr_t addr,
  * @len: pointer to length of buffer; updated on return
  * @dir: indicates the transfer direction
  */
+/*
+ * called by:
+ *   - hw/display/virtio-gpu.c|644| <<virtio_gpu_create_mapping_iov>> (*iov)[i].iov_base = dma_memory_map(VIRTIO_DEVICE(g)->dma_as,
+ *   - hw/display/virtio-gpu.c|1054| <<virtio_gpu_load>> dma_memory_map(VIRTIO_DEVICE(g)->dma_as,
+ *   - hw/hyperv/vmbus.c|376| <<gpadl_iter_io>> iter->map = dma_memory_map(iter->as, maddr, &mlen, iter->dir);
+ *   - hw/hyperv/vmbus.c|493| <<vmbus_map_sgl>> iov[ret_cnt].iov_base = dma_memory_map(sgl->as, a, &l, dir);
+ *   - hw/hyperv/vmbus.c|568| <<ringbuf_map_hdr>> rb = dma_memory_map(ringbuf->as, ringbuf->rb_addr, &mlen,
+ *   - hw/ide/ahci.c|252| <<map_page>> *ptr = dma_memory_map(as, addr, &len, DMA_DIRECTION_FROM_DEVICE);
+ *   - hw/ide/ahci.c|941| <<ahci_populate_sglist>> if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,
+ *   - hw/ide/ahci.c|1303| <<handle_cmd>> cmd_fis = dma_memory_map(s->as, tbl_addr, &cmd_len,
+ *   - hw/usb/libhw.c|39| <<usb_packet_map>> mem = dma_memory_map(sgl->as, base, &xlen, dir);
+ *   - hw/virtio/virtio.c|1335| <<virtqueue_map_desc>> iov[num_sg].iov_base = dma_memory_map(vdev->dma_as, pa, &len,
+ *   - hw/virtio/virtio.c|1384| <<virtqueue_map_iovec>> sg[i].iov_base = dma_memory_map(vdev->dma_as,
+ *   - include/hw/pci/pci.h|891| <<pci_dma_map>> buf = dma_memory_map(pci_get_address_space(dev), addr, plen, dir);
+ *   - softmmu/dma-helpers.c|157| <<dma_blk_cb>> mem = dma_memory_map(dbs->sg->as, cur_addr, &cur_len, dbs->dir);
+ */
 static inline void *dma_memory_map(AddressSpace *as,
                                    dma_addr_t addr, dma_addr_t *len,
                                    DMADirection dir)
diff --git a/include/sysemu/kvm.h b/include/sysemu/kvm.h
index a1ab1ee12..d3417bf9e 100644
--- a/include/sysemu/kvm.h
+++ b/include/sysemu/kvm.h
@@ -434,6 +434,22 @@ int kvm_vm_check_extension(KVMState *s, unsigned int extension);
         kvm_vm_ioctl(s, KVM_ENABLE_CAP, &cap);                       \
     })
 
+/*
+ * called by:
+ *   - hw/intc/openpic_kvm.c|262| <<kvm_openpic_connect_vcpu>> return kvm_vcpu_enable_cap(cs, KVM_CAP_IRQ_MPIC, 0, opp->fd,
+ *   - hw/intc/spapr_xive_kvm.c|169| <<kvmppc_xive_cpu_connect>> ret = kvm_vcpu_enable_cap(tctx->cs, KVM_CAP_PPC_IRQ_XIVE, 0, xive->fd,
+ *   - hw/intc/xics_kvm.c|166| <<icp_kvm_realize>> ret = kvm_vcpu_enable_cap(cs, KVM_CAP_IRQ_XICS, 0, kernel_xics_fd, vcpu_id);
+ *   - target/i386/kvm/kvm.c|1187| <<hyperv_handle_properties>> r = kvm_vcpu_enable_cap(cs, KVM_CAP_HYPERV_ENLIGHTENED_VMCS, 0,
+ *   - target/i386/kvm/kvm.c|1443| <<hyperv_init_vcpu>> ret = kvm_vcpu_enable_cap(cs, synic_cap, 0);
+ *   - target/mips/kvm.c|74| <<kvm_arch_init_vcpu>> ret = kvm_vcpu_enable_cap(cs, KVM_CAP_MIPS_FPU, 0, 0);
+ *   - target/mips/kvm.c|83| <<kvm_arch_init_vcpu>> ret = kvm_vcpu_enable_cap(cs, KVM_CAP_MIPS_MSA, 0, 0);
+ *   - target/ppc/kvm.c|230| <<kvm_booke206_tlb_init>> ret = kvm_vcpu_enable_cap(cs, KVM_CAP_SW_TLB, 0, (uintptr_t)&cfg);
+ *   - target/ppc/kvm.c|1780| <<kvmppc_booke_watchdog_enable>> ret = kvm_vcpu_enable_cap(cs, KVM_CAP_PPC_BOOKE_WATCHDOG, 0);
+ *   - target/ppc/kvm.c|2052| <<kvmppc_set_papr>> ret = kvm_vcpu_enable_cap(cs, KVM_CAP_PPC_PAPR, 0);
+ *   - target/ppc/kvm.c|2075| <<kvmppc_set_mpic_proxy>> ret = kvm_vcpu_enable_cap(cs, KVM_CAP_PPC_EPR, 0, mpic_proxy);
+ *   - target/ppc/kvm.c|2091| <<kvmppc_set_fwnmi>> return kvm_vcpu_enable_cap(cs, KVM_CAP_PPC_FWNMI, 0);
+ *   - target/s390x/kvm.c|1998| <<kvm_s390_enable_css_support>> r = kvm_vcpu_enable_cap(CPU(cpu), KVM_CAP_S390_CSS_SUPPORT, 0);
+ */
 #define kvm_vcpu_enable_cap(cpu, capability, cap_flags, ...)         \
     ({                                                               \
         struct kvm_enable_cap cap = {                                \
diff --git a/net/tap-linux.c b/net/tap-linux.c
index b0635e9e3..ec705384f 100644
--- a/net/tap-linux.c
+++ b/net/tap-linux.c
@@ -236,6 +236,10 @@ int tap_fd_set_vnet_be(int fd, int is_be)
     abort();
 }
 
+/*
+ * called by:
+ *   - net/tap.c|306| <<tap_set_offload>> tap_fd_set_offload(s->fd, csum, tso4, tso6, ecn, ufo);
+ */
 void tap_fd_set_offload(int fd, int csum, int tso4,
                         int tso6, int ecn, int ufo)
 {
diff --git a/scsi/utils.c b/scsi/utils.c
index 357b03667..42d3c3e14 100644
--- a/scsi/utils.c
+++ b/scsi/utils.c
@@ -620,6 +620,11 @@ int scsi_sense_from_errno(int errno_value, SCSISense *sense)
     }
 }
 
+/*
+ * called by:
+ *   - hw/scsi/scsi-bus.c|1614| <<scsi_req_complete_failed>> status = scsi_sense_from_host_status(req->host_status, &sense);
+ *   - scsi/qemu-pr-helper.c|159| <<do_sgio_worker>> status = scsi_sense_from_host_status(io_hdr.host_status, &sense_code);
+ */
 int scsi_sense_from_host_status(uint8_t host_status,
                                 SCSISense *sense)
 {
diff --git a/softmmu/cpus.c b/softmmu/cpus.c
index a7ee43118..6d1b49880 100644
--- a/softmmu/cpus.c
+++ b/softmmu/cpus.c
@@ -589,6 +589,11 @@ void resume_all_vcpus(void)
     }
 }
 
+/*
+ * called by:
+ *   - hw/ppc/pnv_core.c|270| <<pnv_core_cpu_unrealize>> cpu_remove_sync(CPU(cpu));
+ *   - target/i386/cpu.c|6973| <<x86_cpu_unrealizefn>> cpu_remove_sync(CPU(dev));
+ */
 void cpu_remove_sync(CPUState *cpu)
 {
     cpu->stop = true;
@@ -798,6 +803,10 @@ exit:
     fclose(f);
 }
 
+/*
+ * called by:
+ *   - monitor/hmp-cmds.c|1105| <<hmp_nmi>> qmp_inject_nmi(&err);
+ */
 void qmp_inject_nmi(Error **errp)
 {
     nmi_monitor_handle(monitor_get_cpu_index(monitor_cur()), errp);
diff --git a/softmmu/dma-helpers.c b/softmmu/dma-helpers.c
index 7d766a5e8..10b72e4c8 100644
--- a/softmmu/dma-helpers.c
+++ b/softmmu/dma-helpers.c
@@ -111,6 +111,10 @@ static void dma_blk_unmap(DMAAIOCB *dbs)
     qemu_iovec_reset(&dbs->iov);
 }
 
+/*
+ * called by:
+ *   - softmmu/dma-helpers.c|139| <<dma_blk_cb>> dma_complete(dbs, ret);
+ */
 static void dma_complete(DMAAIOCB *dbs, int ret)
 {
     trace_dma_complete(dbs, ret, dbs->common.cb);
@@ -124,6 +128,12 @@ static void dma_complete(DMAAIOCB *dbs, int ret)
     qemu_aio_unref(dbs);
 }
 
+/*
+ * 在以下使用dma_blk_cb():
+ *   - softmmu/dma-helpers.c|99| <<reschedule_dma>> dma_blk_cb(dbs, 0);
+ *   - softmmu/dma-helpers.c|196| <<dma_blk_cb>> dbs->acb = dbs->io_func(dbs->offset, &dbs->iov, dma_blk_cb, dbs, dbs->io_func_opaque);
+ *   - softmmu/dma-helpers.c|268| <<dma_blk_io>> dma_blk_cb(dbs, 0);
+ */
 static void dma_blk_cb(void *opaque, int ret)
 {
     DMAAIOCB *dbs = (DMAAIOCB *)opaque;
@@ -230,6 +240,15 @@ static const AIOCBInfo dma_aiocb_info = {
     .get_aio_context    = dma_get_aio_context,
 };
 
+/*
+ * called by:
+ *   - hw/ide/core.c|943| <<ide_dma_cb>> s->bus->dma->aiocb = dma_blk_io(blk_get_aio_context(s->blk),
+ *   - hw/ide/macio.c|193| <<pmac_ide_transfer_cb>> s->bus->dma->aiocb = dma_blk_io(blk_get_aio_context(s->blk), &s->sg,
+ *   - hw/scsi/scsi-disk.c|453| <<scsi_do_read>> r->req.aiocb = dma_blk_io(blk_get_aio_context(s->qdev.conf.blk),
+ *   - hw/scsi/scsi-disk.c|619| <<scsi_write_data>> r->req.aiocb = dma_blk_io(blk_get_aio_context(s->qdev.conf.blk),
+ *   - softmmu/dma-helpers.c|273| <<dma_blk_read>> return dma_blk_io(blk_get_aio_context(blk), sg, offset, align,
+ *   - softmmu/dma-helpers.c|291| <<dma_blk_write>> return dma_blk_io(blk_get_aio_context(blk), sg, offset, align,
+ */
 BlockAIOCB *dma_blk_io(AioContext *ctx,
     QEMUSGList *sg, uint64_t offset, uint32_t align,
     DMAIOFunc *io_func, void *io_func_opaque,
diff --git a/softmmu/qdev-monitor.c b/softmmu/qdev-monitor.c
index a9955b97a..fd5c63e9e 100644
--- a/softmmu/qdev-monitor.c
+++ b/softmmu/qdev-monitor.c
@@ -583,6 +583,25 @@ void qdev_set_id(DeviceState *dev, const char *id)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  scsi_hd_realize (dev=0x5555578e0f00, errp=0x7fffffffd840) at ../hw/scsi/scsi-disk.c:2428
+ * #1  0x0000555555a7e085 in scsi_device_realize (s=0x5555578e0f00, errp=0x7fffffffd840) at ../hw/scsi/scsi-bus.c:91
+ * #2  0x0000555555a7e997 in scsi_qdev_realize (qdev=0x5555578e0f00, errp=0x7fffffffd8b0) at ../hw/scsi/scsi-bus.c:282
+ * #3  0x0000555555dddf92 in device_set_realized (obj=0x5555578e0f00, value=true, errp=0x7fffffffd9b8) at ../hw/core/qdev.c:761
+ * #4  0x0000555555cdef50 in property_set_bool (obj=0x5555578e0f00, v=0x5555578e12e0, name=0x555556069f41 "realized", opaque=0x55555673b9c0, errp=0x7fffffffd9b8) at ../qom/object.c:2257
+ * #5  0x0000555555cdd047 in object_property_set (obj=0x5555578e0f00, name=0x555556069f41 "realized", v=0x5555578e12e0, errp=0x5555566c8a90 <error_fatal>) at ../qom/object.c:1402
+ * #6  0x0000555555cd9a3b in object_property_set_qobject (obj=0x5555578e0f00, name=0x555556069f41 "realized", value=0x5555578e12c0, errp=0x5555566c8a90 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #7  0x0000555555cdd3aa in object_property_set_bool (obj=0x5555578e0f00, name=0x555556069f41 "realized", value=true, errp=0x5555566c8a90 <error_fatal>) at ../qom/object.c:1472
+ * #8  0x0000555555ddd01d in qdev_realize (dev=0x5555578e0f00, bus=0x55555777db00, errp=0x5555566c8a90 <error_fatal>) at ../hw/core/qdev.c:389
+ * #9  0x0000555555abd739 in qdev_device_add (opts=0x555556734f00, errp=0x5555566c8a90 <error_fatal>) at ../softmmu/qdev-monitor.c:674
+ * #10 0x0000555555cba109 in device_init_func (opaque=0x0, opts=0x555556734f00, errp=0x5555566c8a90 <error_fatal>) at ../softmmu/vl.c:1211
+ * #11 0x0000555555e8025f in qemu_opts_foreach (list=0x5555565ea200 <qemu_device_opts>, func=0x555555cba0e2 <device_init_func>, opaque=0x0, errp=0x5555566c8a90 <error_fatal>) at ../util/qemu-option.c:1167
+ * #12 0x0000555555cbd1e7 in qemu_create_cli_devices () at ../softmmu/vl.c:2541
+ * #13 0x0000555555cbd30a in qmp_x_exit_preconfig (errp=0x5555566c8a90 <error_fatal>) at ../softmmu/vl.c:2589
+ * #14 0x0000555555cbfa18 in qemu_init (argc=18, argv=0x7fffffffde38, envp=0x7fffffffded0) at ../softmmu/vl.c:3611
+ * #15 0x0000555555814b9d in main (argc=18, argv=0x7fffffffde38, envp=0x7fffffffded0) at ../softmmu/main.c:49
+ */
 DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
 {
     DeviceClass *dc;
@@ -647,6 +666,9 @@ DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
     }
 
     /* create device */
+    /*
+     * DeviceState *dev = NULL;
+     */
     dev = qdev_new(driver);
 
     /* Check whether the hotplug is allowed by the machine */
diff --git a/softmmu/runstate.c b/softmmu/runstate.c
index ce8977c6a..ea56b6244 100644
--- a/softmmu/runstate.c
+++ b/softmmu/runstate.c
@@ -430,6 +430,13 @@ static int qemu_debug_requested(void)
 /*
  * Reset the VM. Issue an event unless @reason is SHUTDOWN_CAUSE_NONE.
  */
+/*
+ * called by:
+ *   - hw/core/machine.c|1311| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+ *   - hw/i386/xen/xen-hvm.c|1202| <<cpu_handle_ioreq>> qemu_system_reset(request);
+ *   - migration/savevm.c|3048| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+ *   - softmmu/runstate.c|703| <<main_loop_should_exit>> qemu_system_reset(request);
+ */
 void qemu_system_reset(ShutdownCause reason)
 {
     MachineClass *mc;
@@ -463,6 +470,18 @@ static void qemu_system_wakeup(void)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2721| <<kvm_cpu_exec>> qemu_system_guest_panicked(cpu_get_crash_info(cpu));
+ *   - hw/misc/pvpanic.c|35| <<handle_event>> qemu_system_guest_panicked(NULL);
+ *   - hw/ppc/spapr.c|3353| <<spapr_do_system_reset_on_cpu>> qemu_system_guest_panicked(NULL);
+ *   - hw/ppc/spapr_events.c|838| <<spapr_mce_dispatch_elog>> qemu_system_guest_panicked(NULL);
+ *   - hw/ppc/spapr_events.c|896| <<spapr_mce_req_event>> qemu_system_guest_panicked(NULL);
+ *   - hw/ppc/spapr_rtas.c|355| <<rtas_ibm_os_term>> qemu_system_guest_panicked(NULL);
+ *   - target/i386/whpx/whpx-all.c|1245| <<whpx_vcpu_run>> qemu_system_guest_panicked(cpu_get_crash_info(cpu));
+ *   - target/s390x/helper.c|102| <<s390_handle_wait>> qemu_system_guest_panicked(cpu_get_crash_info(cs));
+ *   - target/s390x/kvm.c|1712| <<unmanageable_intercept>> qemu_system_guest_panicked(cpu_get_crash_info(cs));
+ */
 void qemu_system_guest_panicked(GuestPanicInformation *info)
 {
     qemu_log_mask(LOG_GUEST_ERROR, "Guest crashed");
@@ -511,6 +530,10 @@ void qemu_system_guest_panicked(GuestPanicInformation *info)
     }
 }
 
+/*
+ * called by:
+ *   - hw/misc/pvpanic.c|40| <<handle_event>> qemu_system_guest_crashloaded(NULL);
+ */
 void qemu_system_guest_crashloaded(GuestPanicInformation *info)
 {
     qemu_log_mask(LOG_GUEST_ERROR, "Guest crash loaded");
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index ad99cad0e..189b620f7 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -1453,6 +1453,21 @@ typedef struct ExtSaveArea {
     uint32_t offset, size;
 } ExtSaveArea;
 
+/*
+ * 在以下使用x86_ext_save_areas[]:
+ *   - target/i386/cpu.c|1506| <<xsave_area_size>> for (i = 0; i < ARRAY_SIZE(x86_ext_save_areas); i++) {
+ *   - target/i386/cpu.c|1507| <<xsave_area_size>> const ExtSaveArea *esa = &x86_ext_save_areas[i];
+ *   - target/i386/cpu.c|4817| <<x86_cpu_feature_name>> if (comp < ARRAY_SIZE(x86_ext_save_areas) &&
+ *   - target/i386/cpu.c|4818| <<x86_cpu_feature_name>> x86_ext_save_areas[comp].bits) {
+ *   - target/i386/cpu.c|4819| <<x86_cpu_feature_name>> w = x86_ext_save_areas[comp].feature;
+ *   - target/i386/cpu.c|4820| <<x86_cpu_feature_name>> bitnr = ctz32(x86_ext_save_areas[comp].bits);
+ *   - target/i386/cpu.c|5874| <<cpu_x86_cpuid>> } else if (count < ARRAY_SIZE(x86_ext_save_areas)) {
+ *   - target/i386/cpu.c|5876| <<cpu_x86_cpuid>> const ExtSaveArea *esa = &x86_ext_save_areas[count];
+ *   - target/i386/cpu.c|6207| <<x86_cpu_reset>> for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {
+ *   - target/i386/cpu.c|6208| <<x86_cpu_reset>> const ExtSaveArea *esa = &x86_ext_save_areas[i];
+ *   - target/i386/cpu.c|6440| <<x86_cpu_enable_xsave_components>> for (i = 0; i < ARRAY_SIZE(x86_ext_save_areas); i++) {
+ *   - target/i386/cpu.c|6441| <<x86_cpu_enable_xsave_components>> const ExtSaveArea *esa = &x86_ext_save_areas[i];
+ */
 static const ExtSaveArea x86_ext_save_areas[] = {
     [XSTATE_FP_BIT] = {
         /* x87 FP state component is always enabled if XSAVE is supported */
@@ -1498,6 +1513,11 @@ static const ExtSaveArea x86_ext_save_areas[] = {
             .size = sizeof(XSavePKRU) },
 };
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|5862| <<cpu_x86_cpuid>> *ecx = xsave_area_size(x86_cpu_xsave_components(cpu));
+ *   - target/i386/cpu.c|5871| <<cpu_x86_cpuid>> *ebx = kvm_enabled() ? *ecx : xsave_area_size(env->xcr0);
+ */
 static uint32_t xsave_area_size(uint64_t mask)
 {
     int i;
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 7fe9f5271..c293255d9 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -182,6 +182,11 @@ bool kvm_has_x2apic_api(void)
     return has_x2apic_api;
 }
 
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|3800| <<vtd_decide_config>> if (!kvm_enable_x2apic()) {
+ *   - target/i386/cpu.c|5304| <<x86_cpu_load_model>> } else if (kvm_irqchip_is_split() && kvm_enable_x2apic()) {
+ */
 bool kvm_enable_x2apic(void)
 {
     return MEMORIZE(
@@ -3689,6 +3694,10 @@ static int kvm_get_mp_state(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|4116| <<kvm_arch_get_registers>> ret = kvm_get_apic(cpu);
+ */
 static int kvm_get_apic(X86CPU *cpu)
 {
     DeviceState *apic = cpu->apic_state;
@@ -4613,6 +4622,10 @@ bool kvm_arch_stop_on_emulation_error(CPUState *cs)
            ((env->segs[R_CS].selector  & 3) != 3);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1435| <<kvm_init_irq_routing>> kvm_arch_init_irq_routing(s);
+ */
 void kvm_arch_init_irq_routing(KVMState *s)
 {
     /* We know at this point that we're using the in-kernel
@@ -4736,6 +4749,14 @@ struct MSIRouteEntry {
 };
 
 /* List of used GSI routes */
+/*
+ * 在以下使用msi_route_list:
+ *   - target/i386/kvm/kvm.c|4743| <<QLIST_HEAD>> static QLIST_HEAD(, MSIRouteEntry) msi_route_list = \
+ *   - target/i386/kvm/kvm.c|4744| <<QLIST_HEAD>> QLIST_HEAD_INITIALIZER(msi_route_list);
+ *   - target/i386/kvm/kvm.c|4755| <<kvm_update_msi_routes_all>> QLIST_FOREACH(entry, &msi_route_list, list) {
+ *   - target/i386/kvm/kvm.c|4793| <<kvm_arch_add_msi_route_post>> QLIST_INSERT_HEAD(&msi_route_list, entry, list);
+ *   - target/i386/kvm/kvm.c|4814| <<kvm_arch_release_virq_post>> QLIST_FOREACH_SAFE(entry, &msi_route_list, list, next) {
+ */
 static QLIST_HEAD(, MSIRouteEntry) msi_route_list = \
     QLIST_HEAD_INITIALIZER(msi_route_list);
 
@@ -4786,6 +4807,14 @@ int kvm_arch_add_msi_route_post(struct kvm_irq_routing_entry *route,
     entry->dev = dev;
     entry->vector = vector;
     entry->virq = route->gsi;
+    /*
+     * 在以下使用msi_route_list:
+     *   - target/i386/kvm/kvm.c|4743| <<QLIST_HEAD>> static QLIST_HEAD(, MSIRouteEntry) msi_route_list = \
+     *   - target/i386/kvm/kvm.c|4744| <<QLIST_HEAD>> QLIST_HEAD_INITIALIZER(msi_route_list);
+     *   - target/i386/kvm/kvm.c|4755| <<kvm_update_msi_routes_all>> QLIST_FOREACH(entry, &msi_route_list, list) {
+     *   - target/i386/kvm/kvm.c|4793| <<kvm_arch_add_msi_route_post>> QLIST_INSERT_HEAD(&msi_route_list, entry, list);
+     *   - target/i386/kvm/kvm.c|4814| <<kvm_arch_release_virq_post>> QLIST_FOREACH_SAFE(entry, &msi_route_list, list, next) {
+     */
     QLIST_INSERT_HEAD(&msi_route_list, entry, list);
 
     trace_kvm_x86_add_msi_route(route->gsi);
diff --git a/target/i386/monitor.c b/target/i386/monitor.c
index 5994408be..a117cd9e4 100644
--- a/target/i386/monitor.c
+++ b/target/i386/monitor.c
@@ -650,6 +650,26 @@ const MonitorDef *target_monitor_defs(void)
     return monitor_defs;
 }
 
+/*
+ * (qemu) info lapic 1
+ * dumping local APIC state for CPU 1
+ *
+ * LVT0     0x00010700 active-hi edge  masked                      ExtINT (vec 0)
+ * LVT1     0x00010400 active-hi edge  masked                      NMI
+ * LVTPC    0x00000400 active-hi edge                              NMI
+ * LVTERR   0x000000fe active-hi edge                              Fixed  (vec 254)
+ * LVTTHMR  0x00010000 active-hi edge  masked                      Fixed  (vec 0)
+ * LVTT     0x000400ec active-hi edge                 tsc-deadline Fixed  (vec 236)
+ * Timer    DCR=0x0 (divide by 2) initial_count = 0 current_count = 0
+ * SPIV     0x000001ff APIC enabled, focus=off, spurious vec 255
+ * ICR      0x000000fb physical edge de-assert no-shorthand
+ * ICR2     0x00000000 cpu 0 (X2APIC ID)
+ * ESR      0x00000000
+ * ISR      (none)
+ * IRR      36 236 251 253
+ *
+ * APR 0x00 TPR 0x10 DFR 0x0f LDR 0x00 PPR 0x10
+ */
 void hmp_info_local_apic(Monitor *mon, const QDict *qdict)
 {
     CPUState *cs;
diff --git a/target/i386/xsave_helper.c b/target/i386/xsave_helper.c
index 818115e7d..9a0aeb311 100644
--- a/target/i386/xsave_helper.c
+++ b/target/i386/xsave_helper.c
@@ -6,6 +6,11 @@
 
 #include "cpu.h"
 
+/*
+ * called by:
+ *   - target/i386/hvf/x86hvf.c|82| <<hvf_put_xsave>> x86_cpu_xsave_all_areas(X86_CPU(cpu_state), xsave);
+ *   - target/i386/kvm/kvm.c|2446| <<kvm_put_xsave>> x86_cpu_xsave_all_areas(cpu, xsave);
+ */
 void x86_cpu_xsave_all_areas(X86CPU *cpu, X86XSaveArea *buf)
 {
     CPUX86State *env = &cpu->env;
diff --git a/util/coroutine-ucontext.c b/util/coroutine-ucontext.c
index 904b37519..072111a0c 100644
--- a/util/coroutine-ucontext.c
+++ b/util/coroutine-ucontext.c
@@ -145,6 +145,10 @@ void start_switch_fiber_tsan(void **fake_stack_save,
 #endif
 }
 
+/*
+ * called by:
+ *   - util/coroutine-ucontext.c|220| <<qemu_coroutine_new>> makecontext(&uc, (void (*)(void ))coroutine_trampoline,
+ */
 static void coroutine_trampoline(int i0, int i1)
 {
     union cc_arg arg;
@@ -288,6 +292,12 @@ void qemu_coroutine_delete(Coroutine *co_)
  * return in thread B, and so we might be in a different thread
  * context each time round the loop.
  */
+/*
+ * called by:
+ *   - util/coroutine-ucontext.c|174| <<coroutine_trampoline>> qemu_coroutine_switch(co, co->caller, COROUTINE_TERMINATE);
+ *   - util/qemu-coroutine.c|147| <<qemu_aio_coroutine_enter>> ret = qemu_coroutine_switch(from, to, COROUTINE_ENTER);
+ *   - util/qemu-coroutine.c|193| <<qemu_coroutine_yield>> qemu_coroutine_switch(self, to, COROUTINE_YIELD);
+ */
 CoroutineAction __attribute__((noinline))
 qemu_coroutine_switch(Coroutine *from_, Coroutine *to_,
                       CoroutineAction action)
diff --git a/util/qemu-sockets.c b/util/qemu-sockets.c
index 8af0278f1..98b75de82 100644
--- a/util/qemu-sockets.c
+++ b/util/qemu-sockets.c
@@ -1064,6 +1064,11 @@ int unix_listen(const char *str, Error **errp)
     return sock;
 }
 
+/*
+ * called by:
+ *   - tests/qtest/test-filter-redirector.c|109| <<test_redirector_tx>> recv_sock = unix_connect(sock_path1, NULL);
+ *   - tests/qtest/test-filter-redirector.c|189| <<test_redirector_rx>> send_sock = unix_connect(sock_path1, NULL);
+ */
 int unix_connect(const char *path, Error **errp)
 {
     UnixSocketAddress *saddr;
-- 
2.17.1

