From b6897ab9b09cc159e43ec8d2358da637e25b3001 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 6 May 2019 11:25:41 +0800
Subject: [PATCH 1/1] xen comment for xen-4.12.0

xen-4.12.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 xen/arch/x86/domain.c              |  4 ++
 xen/arch/x86/hvm/hvm.c             |  8 ++++
 xen/arch/x86/hvm/vmx/vmcs.c        | 89 ++++++++++++++++++++++++++++++++++++++
 xen/arch/x86/hvm/vmx/vmx.c         | 11 +++++
 xen/arch/x86/mm/hap/hap.c          |  4 ++
 xen/common/domain.c                | 10 +++++
 xen/include/asm-x86/hvm/vmx/vmcs.h |  9 ++++
 xen/include/asm-x86/paging.h       |  5 +++
 8 files changed, 140 insertions(+)

diff --git a/xen/arch/x86/domain.c b/xen/arch/x86/domain.c
index 8d579e2..6f6c92c 100644
--- a/xen/arch/x86/domain.c
+++ b/xen/arch/x86/domain.c
@@ -338,6 +338,10 @@ void arch_vcpu_regs_init(struct vcpu *v)
     v->arch.dr7 = X86_DR7_DEFAULT;
 }
 
+/*
+ * called only by:
+ *   - common/domain.c|179| <<vcpu_create>> if ( arch_vcpu_create(v) != 0 )
+ */
 int arch_vcpu_create(struct vcpu *v)
 {
     struct domain *d = v->domain;
diff --git a/xen/arch/x86/hvm/hvm.c b/xen/arch/x86/hvm/hvm.c
index 8adbb61..9b2424d 100644
--- a/xen/arch/x86/hvm/hvm.c
+++ b/xen/arch/x86/hvm/hvm.c
@@ -142,6 +142,10 @@ static struct notifier_block cpu_nfb = {
     .notifier_call = cpu_callback
 };
 
+/*
+ * used by only:
+ *   - arch/x86/hvm/hvm.c|206| <<global>> presmp_initcall(hvm_enable);
+ */
 static int __init hvm_enable(void)
 {
     const struct hvm_function_table *fns = NULL;
@@ -1487,6 +1491,10 @@ static int __init hvm_register_CPU_save_and_restore(void)
 }
 __initcall(hvm_register_CPU_save_and_restore);
 
+/*
+ * called only by:
+ *   - arch/x86/domain.c|369| <<arch_vcpu_create>> rc = hvm_vcpu_initialise(v);
+ */
 int hvm_vcpu_initialise(struct vcpu *v)
 {
     int rc;
diff --git a/xen/arch/x86/hvm/vmx/vmcs.c b/xen/arch/x86/hvm/vmx/vmcs.c
index 74f2a08..fb85a30 100644
--- a/xen/arch/x86/hvm/vmx/vmcs.c
+++ b/xen/arch/x86/hvm/vmx/vmcs.c
@@ -42,6 +42,33 @@
 #include <asm/tboot.h>
 #include <asm/apic.h>
 
+/*
+ * 'xl debug-keys v'可以打印出所有的vmcs
+ *
+ *
+ * 3处会初始化vmcs的地方 (主要最后一处)
+ *
+ * hvm_cpu_up()
+ *  -> vmx_cpu_up()
+ *      -> _vmx_cpu_up(bool bsp) --> bsp == false
+ *          -> vmx_init_vmcs_config()
+ *
+ *
+ * presmp_initcall(hvm_enable)
+ *  -> hvm_enable()
+ *      -> start_vmx()
+ *          -> _vmx_cpu_up() --> bsp == true
+ *              -> vmx_init_vmcs_config()
+ *
+ *
+ * vcpu_create(vcpu_id)
+ *  -> arch_vcpu_create(vcpu)
+ *      -> hvm_vcpu_initialise(vcpu)
+ *          -> vmx_function_table.vcpu_initialise = vmx_vcpu_initialise(vcpu)
+ *              -> vmx_create_vmcs(vcpu)
+ *                  -> construct_vmcs()
+ */
+
 static bool_t __read_mostly opt_vpid_enabled = 1;
 boolean_param("vpid", opt_vpid_enabled);
 
@@ -166,6 +193,10 @@ static bool_t cap_check(const char *name, u32 expected, u32 saw)
     return saw != expected;
 }
 
+/*
+ * calle by only:
+ *   - arch/x86/hvm/vmx/vmcs.c|645| <<_vmx_cpu_up>> if ( (rc = vmx_init_vmcs_config()) != 0 )
+ */
 static int vmx_init_vmcs_config(void)
 {
     u32 vmx_basic_msr_low, vmx_basic_msr_high, min, opt;
@@ -598,6 +629,30 @@ void vmx_cpu_dead(unsigned int cpu)
     vmx_pi_desc_fixup(cpu);
 }
 
+/*
+ * 在测试机上有4个cpu, 第0个(bsp=true)和其他3个不一样
+ *
+ * 在CPU 0上执行
+ * [0] _vmx_cpu_up
+ * [0] smp_send_call_function_mask
+ * [0] on_selected_cpus
+ * [0] mwait-idle.c#mwait_idle_cpu_init
+ * [0] start_vmx
+ * [0] hvm.c#hvm_enable
+ * [0] do_presmp_initcalls
+ * [0] __start_xen
+ * [0] __high_start
+ *
+ * 在剩下的3个非bsp的cpu分别执行
+ * [0] _vmx_cpu_up
+ * [0] alloc_direct_apic_vector
+ * [0] intel_mcheck_init
+ * [0] start_secondary
+ *
+ * called by:
+ *   - arch/x86/hvm/vmx/vmcs.c|697| <<vmx_cpu_up>> return _vmx_cpu_up(false);
+ *   - arch/x86/hvm/vmx/vmx.c|2446| <<start_vmx>> if ( _vmx_cpu_up(true) )
+ */
 int _vmx_cpu_up(bool bsp)
 {
     u32 eax, edx;
@@ -688,6 +743,13 @@ int _vmx_cpu_up(bool bsp)
     return 0;
 }
 
+/*
+ * called by:
+ *   - arch/arm/platform.c|104| <<platform_cpu_up>> return platform->cpu_up(cpu);
+ *   - include/asm-x86/hvm/hvm.h|530| <<hvm_cpu_up>> return (hvm_funcs.cpu_up ? hvm_funcs.cpu_up() : 0);
+ *
+ * struct hvm_function_table vmx_function_table.cpu_up = vmx_cpu_up()
+ */
 int vmx_cpu_up()
 {
     return _vmx_cpu_up(false);
@@ -981,6 +1043,21 @@ static void pi_desc_init(struct vcpu *v)
     v->arch.hvm.vmx.pi_desc.ndst = APIC_INVALID_DEST;
 }
 
+/*
+ * 对于2个vcpu的hvm, 被调用两次
+ *
+ * [0] vmx_create_vmcs
+ * [0] vmx.c#vmx_vcpu_initialise
+ * [0] vlapic_init
+ * [0] hvm_vcpu_initialise
+ * [0] vcpu_init_fpu
+ * [0] arch_vcpu_create
+ * [0] vcpu_create
+ * [0] do_domctl
+ *
+ * called by only:
+ *   - arch/x86/hvm/vmx/vmcs.c|1781| <<vmx_create_vmcs>> if ( (rc = construct_vmcs(v)) != 0 )
+ */
 static int construct_vmcs(struct vcpu *v)
 {
     struct domain *d = v->domain;
@@ -1019,6 +1096,14 @@ static int construct_vmcs(struct vcpu *v)
 
     if ( paging_mode_hap(d) )
     {
+        /*
+	 * hap一般hvm下都是打开的!
+	 */
+
+        /*
+         * 这里取消了invlpg和cr3的访问,
+	 * 所以调用invlpg和访问cr3就不会trap了
+         */
         v->arch.hvm.vmx.exec_control &= ~(CPU_BASED_INVLPG_EXITING |
                                           CPU_BASED_CR3_LOAD_EXITING |
                                           CPU_BASED_CR3_STORE_EXITING);
@@ -1726,6 +1811,10 @@ void vmx_domain_update_eptp(struct domain *d)
     ept_sync_domain(p2m);
 }
 
+/*
+ * called only by:
+ *   - arch/x86/hvm/vmx/vmx.c|434| <<vmx_vcpu_initialise>> if ( (rc = vmx_create_vmcs(v)) != 0 )
+ */
 int vmx_create_vmcs(struct vcpu *v)
 {
     struct vmx_vcpu *vmx = &v->arch.hvm.vmx;
diff --git a/xen/arch/x86/hvm/vmx/vmx.c b/xen/arch/x86/hvm/vmx/vmx.c
index 725dd88..989b6a6 100644
--- a/xen/arch/x86/hvm/vmx/vmx.c
+++ b/xen/arch/x86/hvm/vmx/vmx.c
@@ -421,6 +421,13 @@ static void vmx_domain_destroy(struct domain *d)
     vmx_free_vlapic_mapping(d);
 }
 
+/*
+ * struct hvm_function_table vmx_function_table.vcpu_initialise = vmx_vcpu_initialise()
+ *
+ * called by:
+ *   - arch/arm/processor.c|39| <<processor_vcpu_initialise>> this_cpu(processor)->vcpu_initialise(v);
+ *   - arch/x86/hvm/hvm.c|1513| <<hvm_vcpu_initialise>> if ( (rc = hvm_funcs.vcpu_initialise(v)) != 0 )
+ */
 static int vmx_vcpu_initialise(struct vcpu *v)
 {
     int rc;
@@ -2439,6 +2446,10 @@ static void pi_notification_interrupt(struct cpu_user_regs *regs)
 static void __init lbr_tsx_fixup_check(void);
 static void __init bdw_erratum_bdf14_fixup_check(void);
 
+/*
+ * called by:
+ *   - arch/x86/hvm/hvm.c|150| <<hvm_enable>> fns = start_vmx();
+ */
 const struct hvm_function_table * __init start_vmx(void)
 {
     set_in_cr4(X86_CR4_VMXE);
diff --git a/xen/arch/x86/mm/hap/hap.c b/xen/arch/x86/mm/hap/hap.c
index 412a442..1758c9e 100644
--- a/xen/arch/x86/mm/hap/hap.c
+++ b/xen/arch/x86/mm/hap/hap.c
@@ -438,6 +438,10 @@ void hap_domain_init(struct domain *d)
     paging_log_dirty_init(d, &hap_ops);
 }
 
+/*
+ * called by only:
+ *   - arch/x86/mm/paging.c|847| <<paging_enable>> return hap_enable(d, mode);
+ */
 /* return 0 for success, -errno for failure */
 int hap_enable(struct domain *d, u32 mode)
 {
diff --git a/xen/common/domain.c b/xen/common/domain.c
index 32bca8d..674212a 100644
--- a/xen/common/domain.c
+++ b/xen/common/domain.c
@@ -134,6 +134,16 @@ static void vcpu_destroy(struct vcpu *v)
     free_vcpu_struct(v);
 }
 
+/*
+ * called by:
+ *   - arch/arm/domain_build.c|83| <<alloc_dom0_vcpu0>> return vcpu_create(dom0, 0, 0);
+ *   - arch/arm/domain_build.c|1992| <<construct_domain>> if ( vcpu_create(d, i, cpu) == NULL )
+ *   - arch/arm/domain_build.c|2029| <<construct_domU>> if ( vcpu_create(d, 0, 0) == NULL )
+ *   - arch/x86/dom0_build.c|206| <<dom0_setup_vcpu>> struct vcpu *v = vcpu_create(d, vcpu_id, cpu);
+ *   - common/domctl.c|565| <<do_domctl():XEN_DOMCTL_max_vcpus>> if ( vcpu_create(d, i, cpu) == NULL )
+ *   - common/schedule.c|1648| <<cpu_schedule_up>> vcpu_create(idle_vcpu[0]->domain, cpu, cpu);
+ *   - common/schedule.c|1821| <<scheduler_init>> if ( vcpu_create(idle_domain, 0, 0) == NULL )
+ */
 struct vcpu *vcpu_create(
     struct domain *d, unsigned int vcpu_id, unsigned int cpu_id)
 {
diff --git a/xen/include/asm-x86/hvm/vmx/vmcs.h b/xen/include/asm-x86/hvm/vmx/vmcs.h
index b3e8001..4da9802 100644
--- a/xen/include/asm-x86/hvm/vmx/vmcs.h
+++ b/xen/include/asm-x86/hvm/vmx/vmcs.h
@@ -194,6 +194,15 @@ void vmx_vmcs_reload(struct vcpu *v);
 #define CPU_BASED_VIRTUAL_INTR_PENDING        0x00000004
 #define CPU_BASED_USE_TSC_OFFSETING           0x00000008
 #define CPU_BASED_HLT_EXITING                 0x00000080
+/*
+ * used by:
+ *   - arch/x86/hvm/vmx/vmcs.c|196| <<vmx_init_vmcs_config>> CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vmcs.c|309| <<vmx_init_vmcs_config>> if ( must_be_one & (CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vmcs.c|1022| <<construct_vmcs>> v->arch.hvm.vmx.exec_control &= ~(CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vvmx.c|2152| <<nvmx_msr_read_intercept>> CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vvmx.c|2173| <<nvmx_msr_read_intercept>> CPU_BASED_INVLPG_EXITING);
+ *   - arch/x86/hvm/vmx/vvmx.c|2533| <<nvmx_n2_vmexit_handler>> if ( ctrl & CPU_BASED_INVLPG_EXITING )
+ */
 #define CPU_BASED_INVLPG_EXITING              0x00000200
 #define CPU_BASED_MWAIT_EXITING               0x00000400
 #define CPU_BASED_RDPMC_EXITING               0x00000800
diff --git a/xen/include/asm-x86/paging.h b/xen/include/asm-x86/paging.h
index 18a7eae..3469b29 100644
--- a/xen/include/asm-x86/paging.h
+++ b/xen/include/asm-x86/paging.h
@@ -46,6 +46,11 @@
 #define PG_SH_enable   0
 #define PG_SH_forced   0
 #endif
+/*
+ * used by:
+ *   - arch/x86/mm/hap/hap.c|505| <<hap_enable>> d->arch.paging.mode = mode | PG_HAP_enable;
+ *   - include/asm-x86/paging.h|69| <<paging_mode_hap>> #define paging_mode_hap(_d) (!!((_d)->arch.paging.mode & PG_HAP_enable))
+ */
 #define PG_HAP_enable  (1U << PG_HAP_shift)
 
 /* common paging mode bits */
-- 
2.7.4

