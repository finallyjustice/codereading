From 606775e39c388bb1e3b01fcc9acde26dfc436ab6 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 15 May 2019 15:34:31 +0800
Subject: [PATCH 1/1] xen comment for xen-4.12.0

xen-4.12.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 xen/arch/x86/domain.c              |  4 ++
 xen/arch/x86/hvm/hvm.c             |  8 ++++
 xen/arch/x86/hvm/vioapic.c         | 13 ++++++
 xen/arch/x86/hvm/vlapic.c          | 61 ++++++++++++++++++++++++++
 xen/arch/x86/hvm/vmx/vmcs.c        | 89 ++++++++++++++++++++++++++++++++++++++
 xen/arch/x86/hvm/vmx/vmx.c         | 11 +++++
 xen/arch/x86/hvm/vpic.c            | 26 +++++++++++
 xen/arch/x86/hvm/vpt.c             | 57 ++++++++++++++++++++++++
 xen/arch/x86/mm/hap/hap.c          |  4 ++
 xen/common/domain.c                | 10 +++++
 xen/include/asm-x86/hvm/vlapic.h   | 14 ++++++
 xen/include/asm-x86/hvm/vmx/vmcs.h |  9 ++++
 xen/include/asm-x86/paging.h       |  5 +++
 13 files changed, 311 insertions(+)

diff --git a/xen/arch/x86/domain.c b/xen/arch/x86/domain.c
index 8d579e2..6f6c92c 100644
--- a/xen/arch/x86/domain.c
+++ b/xen/arch/x86/domain.c
@@ -338,6 +338,10 @@ void arch_vcpu_regs_init(struct vcpu *v)
     v->arch.dr7 = X86_DR7_DEFAULT;
 }
 
+/*
+ * called only by:
+ *   - common/domain.c|179| <<vcpu_create>> if ( arch_vcpu_create(v) != 0 )
+ */
 int arch_vcpu_create(struct vcpu *v)
 {
     struct domain *d = v->domain;
diff --git a/xen/arch/x86/hvm/hvm.c b/xen/arch/x86/hvm/hvm.c
index 8adbb61..9b2424d 100644
--- a/xen/arch/x86/hvm/hvm.c
+++ b/xen/arch/x86/hvm/hvm.c
@@ -142,6 +142,10 @@ static struct notifier_block cpu_nfb = {
     .notifier_call = cpu_callback
 };
 
+/*
+ * used by only:
+ *   - arch/x86/hvm/hvm.c|206| <<global>> presmp_initcall(hvm_enable);
+ */
 static int __init hvm_enable(void)
 {
     const struct hvm_function_table *fns = NULL;
@@ -1487,6 +1491,10 @@ static int __init hvm_register_CPU_save_and_restore(void)
 }
 __initcall(hvm_register_CPU_save_and_restore);
 
+/*
+ * called only by:
+ *   - arch/x86/domain.c|369| <<arch_vcpu_create>> rc = hvm_vcpu_initialise(v);
+ */
 int hvm_vcpu_initialise(struct vcpu *v)
 {
     int rc;
diff --git a/xen/arch/x86/hvm/vioapic.c b/xen/arch/x86/hvm/vioapic.c
index 9c25f72..fa0fb5d 100644
--- a/xen/arch/x86/hvm/vioapic.c
+++ b/xen/arch/x86/hvm/vioapic.c
@@ -375,6 +375,12 @@ static const struct hvm_mmio_ops vioapic_mmio_ops = {
     .write = vioapic_write
 };
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vioapic.c|434| <<vioapic_deliver>> ioapic_inj_irq(vioapic, target, vector, trig_mode, delivery_mode);
+ *   - arch/x86/hvm/vioapic.c|452| <<vioapic_deliver>> ioapic_inj_irq(vioapic, vcpu_vlapic(v), vector,
+ *   - arch/x86/hvm/vioapic.c|461| <<vioapic_deliver>> ioapic_inj_irq(vioapic, vcpu_vlapic(v), vector,
+ */
 static void ioapic_inj_irq(
     struct hvm_vioapic *vioapic,
     struct vlapic *target,
@@ -396,6 +402,13 @@ static inline int pit_channel0_enabled(void)
     return pt_active(&current->domain->arch.vpit.pt0);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vioapic.c|266| <<vioapic_write_redirent>> vioapic_deliver(vioapic, idx);
+ *   - arch/x86/hvm/vioapic.c|507| <<vioapic_irq_positive_edge>> vioapic_deliver(vioapic, pin);
+ *   - arch/x86/hvm/vioapic.c|512| <<vioapic_irq_positive_edge>> vioapic_deliver(vioapic, pin);
+ *   - arch/x86/hvm/vioapic.c|551| <<vioapic_update_EOI>> vioapic_deliver(vioapic, pin);
+ */
 static void vioapic_deliver(struct hvm_vioapic *vioapic, unsigned int pin)
 {
     uint16_t dest = vioapic->redirtbl[pin].fields.dest_id;
diff --git a/xen/arch/x86/hvm/vlapic.c b/xen/arch/x86/hvm/vlapic.c
index a1a43cd..b69a6fe 100644
--- a/xen/arch/x86/hvm/vlapic.c
+++ b/xen/arch/x86/hvm/vlapic.c
@@ -149,6 +149,17 @@ bool vlapic_test_irq(const struct vlapic *vlapic, uint8_t vec)
     return vlapic_test_vector(vec, &vlapic->regs->data[APIC_IRR]);
 }
 
+/*
+ * called by:
+ *   - arch/x86/cpu/vpmu.c|324| <<vpmu_do_interrupt>> vlapic_set_irq(vlapic, vlapic_lvtpc & APIC_VECTOR_MASK, 0);
+ *   - arch/x86/hvm/irq.c|322| <<hvm_assert_evtchn_irq>> vlapic_set_irq(vcpu_vlapic(v), vector, 0);
+ *   - arch/x86/hvm/svm/svm.c|947| <<svm_lwp_interrupt>> vlapic_set_irq(
+ *   - arch/x86/hvm/vioapic.c|391| <<ioapic_inj_irq>> vlapic_set_irq(target, vector, trig_mode);
+ *   - arch/x86/hvm/vlapic.c|135| <<vlapic_error>> vlapic_set_irq(vlapic, lvterr & APIC_VECTOR_MASK, 0);
+ *   - arch/x86/hvm/vlapic.c|352| <<vlapic_accept_irq>> vlapic_set_irq(vlapic, vector, 0);
+ *   - arch/x86/hvm/vmsi.c|58| <<vmsi_inj_irq>> vlapic_set_irq(target, vector, trig_mode);
+ *   - arch/x86/hvm/vpt.c|384| <<pt_update_irq>> vlapic_set_irq(vcpu_vlapic(v), irq, 0);
+ */
 void vlapic_set_irq(struct vlapic *vlapic, uint8_t vec, uint8_t trig)
 {
     struct vcpu *target = vlapic_vcpu(vlapic);
@@ -775,6 +786,15 @@ static void vlapic_update_timer(struct vlapic *vlapic, uint32_t lvtt,
     }
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/viridian/synic.c|88| <<viridian_synic_wrmsr>> vlapic_reg_write(v, APIC_ICR2, val >> 32);
+ *   - arch/x86/hvm/viridian/synic.c|89| <<viridian_synic_wrmsr>> vlapic_reg_write(v, APIC_ICR, val);
+ *   - arch/x86/hvm/viridian/synic.c|93| <<viridian_synic_wrmsr>> vlapic_reg_write(v, APIC_TASKPRI, val);
+ *   - arch/x86/hvm/vlapic.c|951| <<vlapic_mmio_write>> vlapic_reg_write(v, offset, val);
+ *   - arch/x86/hvm/vlapic.c|971| <<vlapic_apicv_write>> vlapic_reg_write(v, offset, val);
+ *   - arch/x86/hvm/vlapic.c|1056| <<guest_wrmsr_x2apic>> vlapic_reg_write(v, offset, msr_content);
+ */
 void vlapic_reg_write(struct vcpu *v, unsigned int reg, uint32_t val)
 {
     struct vlapic *vlapic = vcpu_vlapic(v);
@@ -1234,6 +1254,12 @@ void vlapic_tdt_msr_set(struct vlapic *vlapic, uint64_t value)
                 vlapic->hw.tdt_msr, guest_tsc);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vlapic.c|1290| <<vlapic_accept_pic_intr>> v ? __vlapic_accept_pic_intr(v) : -1);
+ *   - arch/x86/hvm/vlapic.c|1293| <<vlapic_accept_pic_intr>> __vlapic_accept_pic_intr(v));
+ *   - arch/x86/hvm/vlapic.c|1312| <<vlapic_adjust_i8259_target>> if ( __vlapic_accept_pic_intr(v) )
+ */
 static int __vlapic_accept_pic_intr(struct vcpu *v)
 {
     struct domain *d = v->domain;
@@ -1273,6 +1299,14 @@ int vlapic_accept_pic_intr(struct vcpu *v)
             __vlapic_accept_pic_intr(v));
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vioapic.c|257| <<vioapic_write_redirent>> vlapic_adjust_i8259_target(d);
+ *   - arch/x86/hvm/vlapic.c|863| <<vlapic_reg_write>> vlapic_adjust_i8259_target(v->domain);
+ *   - arch/x86/hvm/vlapic.c|1573| <<lapic_load_regs>> vlapic_adjust_i8259_target(d);
+ *
+ * 目前还不明白, 这个函数控制8259的中断发到哪一个apic?
+ */
 void vlapic_adjust_i8259_target(struct domain *d)
 {
     struct vcpu *v;
@@ -1293,6 +1327,11 @@ void vlapic_adjust_i8259_target(struct domain *d)
     pt_adjust_global_vcpu_target(v);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/irq.c|533| <<hvm_vcpu_has_pending_irq>> vector = vlapic_has_pending_irq(v);
+ *   - arch/x86/hvm/vmx/vvmx.c|1322| <<nvmx_update_apicv>> rvi = vlapic_has_pending_irq(v);
+ */
 int vlapic_has_pending_irq(struct vcpu *v)
 {
     struct vlapic *vlapic = vcpu_vlapic(v);
@@ -1372,6 +1411,11 @@ bool_t is_vlapic_lvtpc_enabled(struct vlapic *vlapic)
 }
 
 /* Reset the VLAPIC back to its init state. */
+/*
+ * called by:
+ *   - arch/x86/hvm/vlapic.c|300| <<vlapic_init_sipi_one>> vlapic_do_init(vcpu_vlapic(target));
+ *   - arch/x86/hvm/vlapic.c|1428| <<vlapic_reset>> vlapic_do_init(vlapic);
+ */
 static void vlapic_do_init(struct vlapic *vlapic)
 {
     int i;
@@ -1413,6 +1457,12 @@ static void vlapic_do_init(struct vlapic *vlapic)
 }
 
 /* Reset the VLAPIC back to its power-on/reset state. */
+/*
+ * called by:
+ *   - arch/x86/hvm/hvm.c|3946| <<hvm_s3_suspend>> vlapic_reset(vcpu_vlapic(v));
+ *   - arch/x86/hvm/vlapic.c|1139| <<guest_wrmsr_apic_base>> vlapic_reset(vlapic);
+ *   - arch/x86/hvm/vlapic.c|1630| <<vlapic_init>> vlapic_reset(vlapic);
+ */
 void vlapic_reset(struct vlapic *vlapic)
 {
     const struct vcpu *v = vlapic_vcpu(vlapic);
@@ -1580,6 +1630,10 @@ HVM_REGISTER_SAVE_RESTORE(LAPIC, lapic_save_hidden,
 HVM_REGISTER_SAVE_RESTORE(LAPIC_REGS, lapic_save_regs,
                           lapic_load_regs, 1, HVMSR_PER_VCPU);
 
+/*
+ * called by only:
+ *   - arch/x86/hvm/hvm.c|1505| <<hvm_vcpu_initialise>> rc = vlapic_init(v);
+ */
 int vlapic_init(struct vcpu *v)
 {
     struct vlapic *vlapic = vcpu_vlapic(v);
@@ -1588,6 +1642,13 @@ int vlapic_init(struct vcpu *v)
 
     if ( !has_vlapic(v->domain) )
     {
+        /*
+	 * VLAPIC_HW_DISABLED在以下被使用:
+	 *   - arch/x86/hvm/vlapic.c|1140| <<guest_wrmsr_apic_base>> vlapic->hw.disabled &= ~VLAPIC_HW_DISABLED;
+	 *   - arch/x86/hvm/vlapic.c|1145| <<guest_wrmsr_apic_base>> vlapic->hw.disabled |= VLAPIC_HW_DISABLED;
+	 *   - arch/x86/hvm/vlapic.c|1591| <<vlapic_init>> vlapic->hw.disabled = VLAPIC_HW_DISABLED;
+	 *   - include/asm-x86/hvm/vlapic.h|48| <<vlapic_hw_disabled>> #define vlapic_hw_disabled(vlapic) ((vlapic)->hw.disabled & VLAPIC_HW_DISABLED)
+	 */
         vlapic->hw.disabled = VLAPIC_HW_DISABLED;
         return 0;
     }
diff --git a/xen/arch/x86/hvm/vmx/vmcs.c b/xen/arch/x86/hvm/vmx/vmcs.c
index 74f2a08..fb85a30 100644
--- a/xen/arch/x86/hvm/vmx/vmcs.c
+++ b/xen/arch/x86/hvm/vmx/vmcs.c
@@ -42,6 +42,33 @@
 #include <asm/tboot.h>
 #include <asm/apic.h>
 
+/*
+ * 'xl debug-keys v'可以打印出所有的vmcs
+ *
+ *
+ * 3处会初始化vmcs的地方 (主要最后一处)
+ *
+ * hvm_cpu_up()
+ *  -> vmx_cpu_up()
+ *      -> _vmx_cpu_up(bool bsp) --> bsp == false
+ *          -> vmx_init_vmcs_config()
+ *
+ *
+ * presmp_initcall(hvm_enable)
+ *  -> hvm_enable()
+ *      -> start_vmx()
+ *          -> _vmx_cpu_up() --> bsp == true
+ *              -> vmx_init_vmcs_config()
+ *
+ *
+ * vcpu_create(vcpu_id)
+ *  -> arch_vcpu_create(vcpu)
+ *      -> hvm_vcpu_initialise(vcpu)
+ *          -> vmx_function_table.vcpu_initialise = vmx_vcpu_initialise(vcpu)
+ *              -> vmx_create_vmcs(vcpu)
+ *                  -> construct_vmcs()
+ */
+
 static bool_t __read_mostly opt_vpid_enabled = 1;
 boolean_param("vpid", opt_vpid_enabled);
 
@@ -166,6 +193,10 @@ static bool_t cap_check(const char *name, u32 expected, u32 saw)
     return saw != expected;
 }
 
+/*
+ * calle by only:
+ *   - arch/x86/hvm/vmx/vmcs.c|645| <<_vmx_cpu_up>> if ( (rc = vmx_init_vmcs_config()) != 0 )
+ */
 static int vmx_init_vmcs_config(void)
 {
     u32 vmx_basic_msr_low, vmx_basic_msr_high, min, opt;
@@ -598,6 +629,30 @@ void vmx_cpu_dead(unsigned int cpu)
     vmx_pi_desc_fixup(cpu);
 }
 
+/*
+ * 在测试机上有4个cpu, 第0个(bsp=true)和其他3个不一样
+ *
+ * 在CPU 0上执行
+ * [0] _vmx_cpu_up
+ * [0] smp_send_call_function_mask
+ * [0] on_selected_cpus
+ * [0] mwait-idle.c#mwait_idle_cpu_init
+ * [0] start_vmx
+ * [0] hvm.c#hvm_enable
+ * [0] do_presmp_initcalls
+ * [0] __start_xen
+ * [0] __high_start
+ *
+ * 在剩下的3个非bsp的cpu分别执行
+ * [0] _vmx_cpu_up
+ * [0] alloc_direct_apic_vector
+ * [0] intel_mcheck_init
+ * [0] start_secondary
+ *
+ * called by:
+ *   - arch/x86/hvm/vmx/vmcs.c|697| <<vmx_cpu_up>> return _vmx_cpu_up(false);
+ *   - arch/x86/hvm/vmx/vmx.c|2446| <<start_vmx>> if ( _vmx_cpu_up(true) )
+ */
 int _vmx_cpu_up(bool bsp)
 {
     u32 eax, edx;
@@ -688,6 +743,13 @@ int _vmx_cpu_up(bool bsp)
     return 0;
 }
 
+/*
+ * called by:
+ *   - arch/arm/platform.c|104| <<platform_cpu_up>> return platform->cpu_up(cpu);
+ *   - include/asm-x86/hvm/hvm.h|530| <<hvm_cpu_up>> return (hvm_funcs.cpu_up ? hvm_funcs.cpu_up() : 0);
+ *
+ * struct hvm_function_table vmx_function_table.cpu_up = vmx_cpu_up()
+ */
 int vmx_cpu_up()
 {
     return _vmx_cpu_up(false);
@@ -981,6 +1043,21 @@ static void pi_desc_init(struct vcpu *v)
     v->arch.hvm.vmx.pi_desc.ndst = APIC_INVALID_DEST;
 }
 
+/*
+ * 对于2个vcpu的hvm, 被调用两次
+ *
+ * [0] vmx_create_vmcs
+ * [0] vmx.c#vmx_vcpu_initialise
+ * [0] vlapic_init
+ * [0] hvm_vcpu_initialise
+ * [0] vcpu_init_fpu
+ * [0] arch_vcpu_create
+ * [0] vcpu_create
+ * [0] do_domctl
+ *
+ * called by only:
+ *   - arch/x86/hvm/vmx/vmcs.c|1781| <<vmx_create_vmcs>> if ( (rc = construct_vmcs(v)) != 0 )
+ */
 static int construct_vmcs(struct vcpu *v)
 {
     struct domain *d = v->domain;
@@ -1019,6 +1096,14 @@ static int construct_vmcs(struct vcpu *v)
 
     if ( paging_mode_hap(d) )
     {
+        /*
+	 * hap一般hvm下都是打开的!
+	 */
+
+        /*
+         * 这里取消了invlpg和cr3的访问,
+	 * 所以调用invlpg和访问cr3就不会trap了
+         */
         v->arch.hvm.vmx.exec_control &= ~(CPU_BASED_INVLPG_EXITING |
                                           CPU_BASED_CR3_LOAD_EXITING |
                                           CPU_BASED_CR3_STORE_EXITING);
@@ -1726,6 +1811,10 @@ void vmx_domain_update_eptp(struct domain *d)
     ept_sync_domain(p2m);
 }
 
+/*
+ * called only by:
+ *   - arch/x86/hvm/vmx/vmx.c|434| <<vmx_vcpu_initialise>> if ( (rc = vmx_create_vmcs(v)) != 0 )
+ */
 int vmx_create_vmcs(struct vcpu *v)
 {
     struct vmx_vcpu *vmx = &v->arch.hvm.vmx;
diff --git a/xen/arch/x86/hvm/vmx/vmx.c b/xen/arch/x86/hvm/vmx/vmx.c
index 725dd88..989b6a6 100644
--- a/xen/arch/x86/hvm/vmx/vmx.c
+++ b/xen/arch/x86/hvm/vmx/vmx.c
@@ -421,6 +421,13 @@ static void vmx_domain_destroy(struct domain *d)
     vmx_free_vlapic_mapping(d);
 }
 
+/*
+ * struct hvm_function_table vmx_function_table.vcpu_initialise = vmx_vcpu_initialise()
+ *
+ * called by:
+ *   - arch/arm/processor.c|39| <<processor_vcpu_initialise>> this_cpu(processor)->vcpu_initialise(v);
+ *   - arch/x86/hvm/hvm.c|1513| <<hvm_vcpu_initialise>> if ( (rc = hvm_funcs.vcpu_initialise(v)) != 0 )
+ */
 static int vmx_vcpu_initialise(struct vcpu *v)
 {
     int rc;
@@ -2439,6 +2446,10 @@ static void pi_notification_interrupt(struct cpu_user_regs *regs)
 static void __init lbr_tsx_fixup_check(void);
 static void __init bdw_erratum_bdf14_fixup_check(void);
 
+/*
+ * called by:
+ *   - arch/x86/hvm/hvm.c|150| <<hvm_enable>> fns = start_vmx();
+ */
 const struct hvm_function_table * __init start_vmx(void)
 {
     set_in_cr4(X86_CR4_VMXE);
diff --git a/xen/arch/x86/hvm/vpic.c b/xen/arch/x86/hvm/vpic.c
index 3f3fb7a..6eec184 100644
--- a/xen/arch/x86/hvm/vpic.c
+++ b/xen/arch/x86/hvm/vpic.c
@@ -61,6 +61,12 @@ static int vpic_get_priority(struct hvm_hw_vpic *vpic, uint8_t mask)
 }
 
 /* Return the PIC's highest priority pending interrupt. Return -1 if none. */
+/*
+ * called by:
+ *   - arch/x86/hvm/vpic.c|101| <<vpic_update_int_output>> irq = vpic_get_highest_priority_irq(vpic);
+ *   - arch/x86/hvm/vpic.c|166| <<vpic_intack>> irq = vpic_get_highest_priority_irq(vpic);
+ *   - arch/x86/hvm/vpic.c|173| <<vpic_intack>> irq = vpic_get_highest_priority_irq(vpic);
+ */
 static int vpic_get_highest_priority_irq(struct hvm_hw_vpic *vpic)
 {
     int cur_priority, priority, irq;
@@ -92,6 +98,16 @@ static int vpic_get_highest_priority_irq(struct hvm_hw_vpic *vpic)
     return (priority < cur_priority) ? irq : -1;
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpic.c|127| <<vpic_update_int_output>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|134| <<vpic_update_int_output>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|154| <<__vpic_intack>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|261| <<vpic_ioport_write>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|304| <<vpic_ioport_write>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|464| <<vpic_irq_positive_edge>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|482| <<vpic_irq_negative_edge>> vpic_update_int_output(vpic);
+ */
 static void vpic_update_int_output(struct hvm_hw_vpic *vpic)
 {
     int irq;
@@ -154,6 +170,11 @@ static void __vpic_intack(struct hvm_hw_vpic *vpic, int irq)
     vpic_update_int_output(vpic);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpic.c|317| <<vpic_ioport_read>> return vpic_intack(vpic);
+ *   - arch/x86/hvm/vpic.c|497| <<vpic_ack_pending_irq>> irq = vpic_intack(vpic);
+ */
 static int vpic_intack(struct hvm_hw_vpic *vpic)
 {
     int irq = -1;
@@ -335,6 +356,11 @@ static int vpic_intercept_pic_io(
         return X86EMUL_OKAY;
     }
 
+    /*
+     * vpic的声明:
+     *
+     * struct hvm_hw_vpic     vpic[2];
+     */
     vpic = &current->domain->arch.hvm.vpic[port >> 7];
 
     if ( dir == IOREQ_WRITE )
diff --git a/xen/arch/x86/hvm/vpt.c b/xen/arch/x86/hvm/vpt.c
index ecd25d7..ba6ecf6 100644
--- a/xen/arch/x86/hvm/vpt.c
+++ b/xen/arch/x86/hvm/vpt.c
@@ -58,6 +58,11 @@ uint64_t hvm_get_guest_time_fixed(const struct vcpu *v, uint64_t at_tsc)
     return now + v->arch.hvm.stime_offset;
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|213| <<pt_thaw_time>> hvm_set_guest_time(v, v->arch.hvm.guest_time);
+ *   - arch/x86/hvm/vpt.c|304| <<pt_irq_fired>> hvm_set_guest_time(v, pt->last_plt_gtime);
+ */
 void hvm_set_guest_time(struct vcpu *v, u64 guest_time)
 {
     u64 offset = guest_time - hvm_get_guest_time(v);
@@ -75,6 +80,10 @@ void hvm_set_guest_time(struct vcpu *v, u64 guest_time)
     }
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|427| <<is_pt_irq>> (intack.vector == pt_irq_vector(pt, intack.source)) )
+ */
 static int pt_irq_vector(struct periodic_time *pt, enum hvm_intsrc src)
 {
     struct vcpu *v = pt->vcpu;
@@ -171,6 +180,12 @@ static void pt_unlock(struct periodic_time *pt)
     spin_unlock(&pt->vcpu->arch.hvm.tm_lock);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|247| <<pt_restore_timer>> pt_process_missed_ticks(pt);
+ *   - arch/x86/hvm/vpt.c|287| <<pt_irq_fired>> pt_process_missed_ticks(pt);
+ *   - arch/x86/hvm/vpt.c|296| <<pt_irq_fired>> pt_process_missed_ticks(pt);
+ */
 static void pt_process_missed_ticks(struct periodic_time *pt)
 {
     s_time_t missed_ticks, now = NOW();
@@ -265,6 +280,11 @@ static void pt_timer_fn(void *data)
     pt_unlock(pt);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|410| <<pt_update_irq>> pt_irq_fired(v, pt);
+ *   - arch/x86/hvm/vpt.c|472| <<pt_intr_post>> pt_irq_fired(v, pt);
+ */
 static void pt_irq_fired(struct vcpu *v, struct periodic_time *pt)
 {
     pt->irq_issued = false;
@@ -300,6 +320,11 @@ static void pt_irq_fired(struct vcpu *v, struct periodic_time *pt)
         hvm_set_guest_time(v, pt->last_plt_gtime);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/svm/intr.c|146| <<svm_intr_assist>> pt_update_irq(v);
+ *   - arch/x86/hvm/vmx/intr.c|248| <<vmx_intr_assist>> pt_vector = pt_update_irq(v);
+ */
 int pt_update_irq(struct vcpu *v)
 {
     struct list_head *head = &v->arch.hvm.tm_list;
@@ -415,6 +440,10 @@ int pt_update_irq(struct vcpu *v)
     return pt_vector;
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|445| <<pt_intr_post>> pt = is_pt_irq(v, intack);
+ */
 static struct periodic_time *is_pt_irq(
     struct vcpu *v, struct hvm_intack intack)
 {
@@ -431,6 +460,13 @@ static struct periodic_time *is_pt_irq(
     return NULL;
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/svm/intr.c|217| <<svm_intr_assist>> pt_intr_post(v, intack);
+ *   - arch/x86/hvm/vmx/intr.c|206| <<nvmx_intr_intercept>> pt_intr_post(v, intack);
+ *   - arch/x86/hvm/vmx/intr.c|390| <<vmx_intr_assist>> pt_intr_post(v, intack);
+ *   - arch/x86/hvm/vmx/intr.c|396| <<vmx_intr_assist>> pt_intr_post(v, intack);
+ */
 void pt_intr_post(struct vcpu *v, struct hvm_intack intack)
 {
     struct periodic_time *pt;
@@ -473,6 +509,17 @@ void pt_migrate(struct vcpu *v)
     spin_unlock(&v->arch.hvm.tm_lock);
 }
 
+/*
+ * called by:
+ *   - arch/x86/emul-i8254.c|193| <<pit_load_count>> create_periodic_time(v, &pit->pt0, period, period, 0, pit_time_fired,
+ *   - arch/x86/emul-i8254.c|200| <<pit_load_count>> create_periodic_time(v, &pit->pt0, period, 0, 0, pit_time_fired,
+ *   - arch/x86/hvm/hpet.c|312| <<hpet_set_timer>> create_periodic_time(vhpet_vcpu(h), &h->pt[tn],
+ *   - arch/x86/hvm/rtc.c|158| <<rtc_timer_update>> create_periodic_time(v, &s->pt, delta, period,
+ *   - arch/x86/hvm/vlapic.c|749| <<vlapic_update_timer>> create_periodic_time(current, &vlapic->pt, delta,
+ *   - arch/x86/hvm/vlapic.c|1202| <<vlapic_tdt_msr_set>> create_periodic_time(v, &vlapic->pt, delta, 0,
+ *   - arch/x86/hvm/vlapic.c|1216| <<vlapic_tdt_msr_set>> create_periodic_time(v, &vlapic->pt, 0, 0,
+ *   - arch/x86/hvm/vlapic.c|1453| <<lapic_rearm>> create_periodic_time(vlapic_vcpu(s), &s->pt, period,
+ */
 void create_periodic_time(
     struct vcpu *v, struct periodic_time *pt, uint64_t delta,
     uint64_t period, uint8_t irq, time_cb *cb, void *data, bool level)
@@ -562,6 +609,12 @@ void destroy_periodic_time(struct periodic_time *pt)
     kill_timer(&pt->timer);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|625| <<pt_adjust_global_vcpu_target>> pt_adjust_vcpu(&vpit->pt0, v);
+ *   - arch/x86/hvm/vpt.c|631| <<pt_adjust_global_vcpu_target>> pt_adjust_vcpu(&pl_time->vrtc.pt, v);
+ *   - arch/x86/hvm/vpt.c|636| <<pt_adjust_global_vcpu_target>> pt_adjust_vcpu(&pl_time->vhpet.pt[i], v);
+ */
 static void pt_adjust_vcpu(struct periodic_time *pt, struct vcpu *v)
 {
     int on_list;
@@ -590,6 +643,10 @@ static void pt_adjust_vcpu(struct periodic_time *pt, struct vcpu *v)
     spin_unlock(&v->arch.hvm.tm_lock);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vlapic.c|1293| <<vlapic_adjust_i8259_target>> pt_adjust_global_vcpu_target(v);
+ */
 void pt_adjust_global_vcpu_target(struct vcpu *v)
 {
     struct PITState *vpit;
diff --git a/xen/arch/x86/mm/hap/hap.c b/xen/arch/x86/mm/hap/hap.c
index 412a442..1758c9e 100644
--- a/xen/arch/x86/mm/hap/hap.c
+++ b/xen/arch/x86/mm/hap/hap.c
@@ -438,6 +438,10 @@ void hap_domain_init(struct domain *d)
     paging_log_dirty_init(d, &hap_ops);
 }
 
+/*
+ * called by only:
+ *   - arch/x86/mm/paging.c|847| <<paging_enable>> return hap_enable(d, mode);
+ */
 /* return 0 for success, -errno for failure */
 int hap_enable(struct domain *d, u32 mode)
 {
diff --git a/xen/common/domain.c b/xen/common/domain.c
index 32bca8d..674212a 100644
--- a/xen/common/domain.c
+++ b/xen/common/domain.c
@@ -134,6 +134,16 @@ static void vcpu_destroy(struct vcpu *v)
     free_vcpu_struct(v);
 }
 
+/*
+ * called by:
+ *   - arch/arm/domain_build.c|83| <<alloc_dom0_vcpu0>> return vcpu_create(dom0, 0, 0);
+ *   - arch/arm/domain_build.c|1992| <<construct_domain>> if ( vcpu_create(d, i, cpu) == NULL )
+ *   - arch/arm/domain_build.c|2029| <<construct_domU>> if ( vcpu_create(d, 0, 0) == NULL )
+ *   - arch/x86/dom0_build.c|206| <<dom0_setup_vcpu>> struct vcpu *v = vcpu_create(d, vcpu_id, cpu);
+ *   - common/domctl.c|565| <<do_domctl():XEN_DOMCTL_max_vcpus>> if ( vcpu_create(d, i, cpu) == NULL )
+ *   - common/schedule.c|1648| <<cpu_schedule_up>> vcpu_create(idle_vcpu[0]->domain, cpu, cpu);
+ *   - common/schedule.c|1821| <<scheduler_init>> if ( vcpu_create(idle_domain, 0, 0) == NULL )
+ */
 struct vcpu *vcpu_create(
     struct domain *d, unsigned int vcpu_id, unsigned int cpu_id)
 {
diff --git a/xen/include/asm-x86/hvm/vlapic.h b/xen/include/asm-x86/hvm/vlapic.h
index dde66b4..593553d 100644
--- a/xen/include/asm-x86/hvm/vlapic.h
+++ b/xen/include/asm-x86/hvm/vlapic.h
@@ -42,7 +42,21 @@
  *  2. 'Software disable': via APIC_SPIV[8].
  *     APIC is visible but does not respond to interrupt messages.
  */
+/*
+ * used by:
+ *   - arch/x86/hvm/vlapic.c|1140| <<guest_wrmsr_apic_base>> vlapic->hw.disabled &= ~VLAPIC_HW_DISABLED;
+ *   - arch/x86/hvm/vlapic.c|1145| <<guest_wrmsr_apic_base>> vlapic->hw.disabled |= VLAPIC_HW_DISABLED;
+ *   - arch/x86/hvm/vlapic.c|1591| <<vlapic_init>> vlapic->hw.disabled = VLAPIC_HW_DISABLED;
+ *   - include/asm-x86/hvm/vlapic.h|48| <<vlapic_hw_disabled>> #define vlapic_hw_disabled(vlapic) ((vlapic)->hw.disabled & VLAPIC_HW_DISABLED)
+ */
 #define VLAPIC_HW_DISABLED              0x1
+/*
+ * used by:
+ *   - arch/x86/hvm/vlapic.c|814| <<vlapic_reg_write>> vlapic->hw.disabled |= VLAPIC_SW_DISABLED;
+ *   - arch/x86/hvm/vlapic.c|825| <<vlapic_reg_write>> vlapic->hw.disabled &= ~VLAPIC_SW_DISABLED;
+ *   - arch/x86/hvm/vlapic.c|1409| <<vlapic_do_init>> vlapic->hw.disabled |= VLAPIC_SW_DISABLED;
+ *   - include/asm-x86/hvm/vlapic.h|47| <<vlapic_sw_disabled>> #define vlapic_sw_disabled(vlapic) ((vlapic)->hw.disabled & VLAPIC_SW_DISABLED)
+ */
 #define VLAPIC_SW_DISABLED              0x2
 #define vlapic_sw_disabled(vlapic) ((vlapic)->hw.disabled & VLAPIC_SW_DISABLED)
 #define vlapic_hw_disabled(vlapic) ((vlapic)->hw.disabled & VLAPIC_HW_DISABLED)
diff --git a/xen/include/asm-x86/hvm/vmx/vmcs.h b/xen/include/asm-x86/hvm/vmx/vmcs.h
index b3e8001..4da9802 100644
--- a/xen/include/asm-x86/hvm/vmx/vmcs.h
+++ b/xen/include/asm-x86/hvm/vmx/vmcs.h
@@ -194,6 +194,15 @@ void vmx_vmcs_reload(struct vcpu *v);
 #define CPU_BASED_VIRTUAL_INTR_PENDING        0x00000004
 #define CPU_BASED_USE_TSC_OFFSETING           0x00000008
 #define CPU_BASED_HLT_EXITING                 0x00000080
+/*
+ * used by:
+ *   - arch/x86/hvm/vmx/vmcs.c|196| <<vmx_init_vmcs_config>> CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vmcs.c|309| <<vmx_init_vmcs_config>> if ( must_be_one & (CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vmcs.c|1022| <<construct_vmcs>> v->arch.hvm.vmx.exec_control &= ~(CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vvmx.c|2152| <<nvmx_msr_read_intercept>> CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vvmx.c|2173| <<nvmx_msr_read_intercept>> CPU_BASED_INVLPG_EXITING);
+ *   - arch/x86/hvm/vmx/vvmx.c|2533| <<nvmx_n2_vmexit_handler>> if ( ctrl & CPU_BASED_INVLPG_EXITING )
+ */
 #define CPU_BASED_INVLPG_EXITING              0x00000200
 #define CPU_BASED_MWAIT_EXITING               0x00000400
 #define CPU_BASED_RDPMC_EXITING               0x00000800
diff --git a/xen/include/asm-x86/paging.h b/xen/include/asm-x86/paging.h
index 18a7eae..3469b29 100644
--- a/xen/include/asm-x86/paging.h
+++ b/xen/include/asm-x86/paging.h
@@ -46,6 +46,11 @@
 #define PG_SH_enable   0
 #define PG_SH_forced   0
 #endif
+/*
+ * used by:
+ *   - arch/x86/mm/hap/hap.c|505| <<hap_enable>> d->arch.paging.mode = mode | PG_HAP_enable;
+ *   - include/asm-x86/paging.h|69| <<paging_mode_hap>> #define paging_mode_hap(_d) (!!((_d)->arch.paging.mode & PG_HAP_enable))
+ */
 #define PG_HAP_enable  (1U << PG_HAP_shift)
 
 /* common paging mode bits */
-- 
2.7.4

