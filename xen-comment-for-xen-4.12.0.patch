From 7b03a7336e17a48364cd84a93249f4b75763accf Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 5 Jun 2019 05:50:23 +0800
Subject: [PATCH 1/1] xen comment for xen-4.12.0

xen-4.12.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 xen/arch/x86/domain.c              |   4 +
 xen/arch/x86/emul-i8254.c          |  49 ++++++++++++
 xen/arch/x86/hvm/hvm.c             |   8 ++
 xen/arch/x86/hvm/vioapic.c         |  13 ++++
 xen/arch/x86/hvm/vlapic.c          |  69 +++++++++++++++++
 xen/arch/x86/hvm/vmx/vmcs.c        |  89 +++++++++++++++++++++
 xen/arch/x86/hvm/vmx/vmx.c         |  11 +++
 xen/arch/x86/hvm/vpic.c            |  26 +++++++
 xen/arch/x86/hvm/vpt.c             | 154 +++++++++++++++++++++++++++++++++++++
 xen/arch/x86/irq.c                 |  66 ++++++++++++++++
 xen/arch/x86/mm/hap/hap.c          |   4 +
 xen/common/domain.c                |  10 +++
 xen/common/timer.c                 |  46 +++++++++++
 xen/include/asm-x86/hvm/vcpu.h     |  14 ++++
 xen/include/asm-x86/hvm/vlapic.h   |  14 ++++
 xen/include/asm-x86/hvm/vmx/vmcs.h |   9 +++
 xen/include/asm-x86/hvm/vpt.h      |  30 ++++++++
 xen/include/asm-x86/irq.h          |  23 ++++++
 xen/include/asm-x86/paging.h       |   5 ++
 19 files changed, 644 insertions(+)

diff --git a/xen/arch/x86/domain.c b/xen/arch/x86/domain.c
index 8d579e2..6f6c92c 100644
--- a/xen/arch/x86/domain.c
+++ b/xen/arch/x86/domain.c
@@ -338,6 +338,10 @@ void arch_vcpu_regs_init(struct vcpu *v)
     v->arch.dr7 = X86_DR7_DEFAULT;
 }
 
+/*
+ * called only by:
+ *   - common/domain.c|179| <<vcpu_create>> if ( arch_vcpu_create(v) != 0 )
+ */
 int arch_vcpu_create(struct vcpu *v)
 {
     struct domain *d = v->domain;
diff --git a/xen/arch/x86/emul-i8254.c b/xen/arch/x86/emul-i8254.c
index 73be418..a7991ec 100644
--- a/xen/arch/x86/emul-i8254.c
+++ b/xen/arch/x86/emul-i8254.c
@@ -38,7 +38,11 @@
 #include <asm/hvm/vpt.h>
 #include <asm/current.h>
 
+/* 参数的x是struct domain */
 #define domain_vpit(x) (&(x)->arch.vpit)
+/*
+ * domain_vpit()的参数是(x)->domain, 不是x
+ */
 #define vcpu_vpit(x)   (domain_vpit((x)->domain))
 #define vpit_domain(x) (container_of((x), struct domain, arch.vpit))
 #define vpit_vcpu(x)   (pt_global_vcpu_target(vpit_domain(x)))
@@ -56,6 +60,14 @@ static int handle_speaker_io(
 #define get_guest_time(v) \
    (is_hvm_vcpu(v) ? hvm_get_guest_time(v) : (u64)get_s_time())
 
+/*
+ * used by:
+ *   - arch/x86/emul-i8254.c|226| <<pit_latch_count>> c->latched_count = pit_get_count(pit, channel);
+ *   - arch/x86/emul-i8254.c|369| <<pit_ioport_read>> count = pit_get_count(pit, addr);
+ *   - arch/x86/emul-i8254.c|373| <<pit_ioport_read>> count = pit_get_count(pit, addr);
+ *   - arch/x86/emul-i8254.c|377| <<pit_ioport_read>> count = pit_get_count(pit, addr);
+ *   - arch/x86/emul-i8254.c|382| <<pit_ioport_read>> count = pit_get_count(pit, addr);
+ */
 static int pit_get_count(PITState *pit, int channel)
 {
     uint64_t d;
@@ -163,6 +175,14 @@ static void pit_time_fired(struct vcpu *v, void *priv)
     *count_load_time = get_guest_time(v);
 }
 
+/*
+ * called by:
+ *   - arch/x86/emul-i8254.c|302| <<pit_ioport_write>> pit_load_count(pit, addr, val);
+ *   - arch/x86/emul-i8254.c|305| <<pit_ioport_write>> pit_load_count(pit, addr, val << 8);
+ *   - arch/x86/emul-i8254.c|312| <<pit_ioport_write>> pit_load_count(pit, addr, s->write_latch | (val << 8));
+ *   - arch/x86/emul-i8254.c|439| <<pit_load>> pit_load_count(pit, i, pit->hw.channels[i].count);
+ *   - arch/x86/emul-i8254.c|477| <<pit_reset>> pit_load_count(pit, i, 0);
+ */
 static void pit_load_count(PITState *pit, int channel, int val)
 {
     u32 period;
@@ -237,6 +257,10 @@ static void pit_latch_status(PITState *pit, int channel)
     }
 }
 
+/*
+ * called by:
+ *   - arch/x86/emul-i8254.c|521| <<handle_pit_io>> pit_ioport_write(vpit, port, *val);
+ */
 static void pit_ioport_write(struct PITState *pit, uint32_t addr, uint32_t val)
 {
     int channel, access;
@@ -391,6 +415,10 @@ void pit_stop_channel0_irq(PITState *pit)
     spin_unlock(&pit->lock);
 }
 
+/*
+ * used by:
+ *   - arch/x86/emul-i8254.c|466| <<global>> HVM_REGISTER_SAVE_RESTORE(PIT, pit_save, pit_load, 1, HVMSR_PER_DOM);
+ */
 static int pit_save(struct vcpu *v, hvm_domain_context_t *h)
 {
     struct domain *d = v->domain;
@@ -409,6 +437,10 @@ static int pit_save(struct vcpu *v, hvm_domain_context_t *h)
     return rc;
 }
 
+/*
+ * used by:
+ *   - arch/x86/emul-i8254.c|466| <<global>> HVM_REGISTER_SAVE_RESTORE(PIT, pit_save, pit_load, 1, HVMSR_PER_DOM);
+ */
 static int pit_load(struct domain *d, hvm_domain_context_t *h)
 {
     PITState *pit = domain_vpit(d);
@@ -442,6 +474,11 @@ static int pit_load(struct domain *d, hvm_domain_context_t *h)
 HVM_REGISTER_SAVE_RESTORE(PIT, pit_save, pit_load, 1, HVMSR_PER_DOM);
 #endif
 
+/*
+ * called by:
+ *   - arch/x86/emul-i8254.c|489| <<pit_init>> pit_reset(d);
+ *   - arch/x86/hvm/hvm.c|3953| <<hvm_s3_suspend>> pit_reset(d);
+ */
 void pit_reset(struct domain *d)
 {
     PITState *pit = domain_vpit(d);
@@ -471,8 +508,15 @@ void pit_reset(struct domain *d)
     spin_unlock(&pit->lock);
 }
 
+/*
+ * called by only:
+ *   - arch/x86/domain.c|612| <<arch_domain_create>> pit_init(d, cpu_khz);
+ */
 void pit_init(struct domain *d, unsigned long cpu_khz)
 {
+    /*
+     * domain->arch.vpit
+     */
     PITState *pit = domain_vpit(d);
 
     if ( !has_vpit(d) )
@@ -504,6 +548,11 @@ void pit_deinit(struct domain *d)
 }
 
 /* the intercept action for PIT DM retval:0--not handled; 1--handled */  
+/*
+ * used by:
+ *   - arch/x86/emul-i8254.c|498| <<pit_init>> register_portio_handler(d, PIT_BASE, 4, handle_pit_io);
+ *   - arch/x86/emul-i8254.c|605| <<pv_pit_handler>> handle_pit_io(ioreq.dir, port, 1, &val);
+ */
 static int handle_pit_io(
     int dir, unsigned int port, unsigned int bytes, uint32_t *val)
 {
diff --git a/xen/arch/x86/hvm/hvm.c b/xen/arch/x86/hvm/hvm.c
index 8adbb61..9b2424d 100644
--- a/xen/arch/x86/hvm/hvm.c
+++ b/xen/arch/x86/hvm/hvm.c
@@ -142,6 +142,10 @@ static struct notifier_block cpu_nfb = {
     .notifier_call = cpu_callback
 };
 
+/*
+ * used by only:
+ *   - arch/x86/hvm/hvm.c|206| <<global>> presmp_initcall(hvm_enable);
+ */
 static int __init hvm_enable(void)
 {
     const struct hvm_function_table *fns = NULL;
@@ -1487,6 +1491,10 @@ static int __init hvm_register_CPU_save_and_restore(void)
 }
 __initcall(hvm_register_CPU_save_and_restore);
 
+/*
+ * called only by:
+ *   - arch/x86/domain.c|369| <<arch_vcpu_create>> rc = hvm_vcpu_initialise(v);
+ */
 int hvm_vcpu_initialise(struct vcpu *v)
 {
     int rc;
diff --git a/xen/arch/x86/hvm/vioapic.c b/xen/arch/x86/hvm/vioapic.c
index 9c25f72..fa0fb5d 100644
--- a/xen/arch/x86/hvm/vioapic.c
+++ b/xen/arch/x86/hvm/vioapic.c
@@ -375,6 +375,12 @@ static const struct hvm_mmio_ops vioapic_mmio_ops = {
     .write = vioapic_write
 };
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vioapic.c|434| <<vioapic_deliver>> ioapic_inj_irq(vioapic, target, vector, trig_mode, delivery_mode);
+ *   - arch/x86/hvm/vioapic.c|452| <<vioapic_deliver>> ioapic_inj_irq(vioapic, vcpu_vlapic(v), vector,
+ *   - arch/x86/hvm/vioapic.c|461| <<vioapic_deliver>> ioapic_inj_irq(vioapic, vcpu_vlapic(v), vector,
+ */
 static void ioapic_inj_irq(
     struct hvm_vioapic *vioapic,
     struct vlapic *target,
@@ -396,6 +402,13 @@ static inline int pit_channel0_enabled(void)
     return pt_active(&current->domain->arch.vpit.pt0);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vioapic.c|266| <<vioapic_write_redirent>> vioapic_deliver(vioapic, idx);
+ *   - arch/x86/hvm/vioapic.c|507| <<vioapic_irq_positive_edge>> vioapic_deliver(vioapic, pin);
+ *   - arch/x86/hvm/vioapic.c|512| <<vioapic_irq_positive_edge>> vioapic_deliver(vioapic, pin);
+ *   - arch/x86/hvm/vioapic.c|551| <<vioapic_update_EOI>> vioapic_deliver(vioapic, pin);
+ */
 static void vioapic_deliver(struct hvm_vioapic *vioapic, unsigned int pin)
 {
     uint16_t dest = vioapic->redirtbl[pin].fields.dest_id;
diff --git a/xen/arch/x86/hvm/vlapic.c b/xen/arch/x86/hvm/vlapic.c
index a1a43cd..af1d080 100644
--- a/xen/arch/x86/hvm/vlapic.c
+++ b/xen/arch/x86/hvm/vlapic.c
@@ -149,6 +149,17 @@ bool vlapic_test_irq(const struct vlapic *vlapic, uint8_t vec)
     return vlapic_test_vector(vec, &vlapic->regs->data[APIC_IRR]);
 }
 
+/*
+ * called by:
+ *   - arch/x86/cpu/vpmu.c|324| <<vpmu_do_interrupt>> vlapic_set_irq(vlapic, vlapic_lvtpc & APIC_VECTOR_MASK, 0);
+ *   - arch/x86/hvm/irq.c|322| <<hvm_assert_evtchn_irq>> vlapic_set_irq(vcpu_vlapic(v), vector, 0);
+ *   - arch/x86/hvm/svm/svm.c|947| <<svm_lwp_interrupt>> vlapic_set_irq(
+ *   - arch/x86/hvm/vioapic.c|391| <<ioapic_inj_irq>> vlapic_set_irq(target, vector, trig_mode);
+ *   - arch/x86/hvm/vlapic.c|135| <<vlapic_error>> vlapic_set_irq(vlapic, lvterr & APIC_VECTOR_MASK, 0);
+ *   - arch/x86/hvm/vlapic.c|352| <<vlapic_accept_irq>> vlapic_set_irq(vlapic, vector, 0);
+ *   - arch/x86/hvm/vmsi.c|58| <<vmsi_inj_irq>> vlapic_set_irq(target, vector, trig_mode);
+ *   - arch/x86/hvm/vpt.c|384| <<pt_update_irq>> vlapic_set_irq(vcpu_vlapic(v), irq, 0);
+ */
 void vlapic_set_irq(struct vlapic *vlapic, uint8_t vec, uint8_t trig)
 {
     struct vcpu *target = vlapic_vcpu(vlapic);
@@ -775,6 +786,15 @@ static void vlapic_update_timer(struct vlapic *vlapic, uint32_t lvtt,
     }
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/viridian/synic.c|88| <<viridian_synic_wrmsr>> vlapic_reg_write(v, APIC_ICR2, val >> 32);
+ *   - arch/x86/hvm/viridian/synic.c|89| <<viridian_synic_wrmsr>> vlapic_reg_write(v, APIC_ICR, val);
+ *   - arch/x86/hvm/viridian/synic.c|93| <<viridian_synic_wrmsr>> vlapic_reg_write(v, APIC_TASKPRI, val);
+ *   - arch/x86/hvm/vlapic.c|951| <<vlapic_mmio_write>> vlapic_reg_write(v, offset, val);
+ *   - arch/x86/hvm/vlapic.c|971| <<vlapic_apicv_write>> vlapic_reg_write(v, offset, val);
+ *   - arch/x86/hvm/vlapic.c|1056| <<guest_wrmsr_x2apic>> vlapic_reg_write(v, offset, msr_content);
+ */
 void vlapic_reg_write(struct vcpu *v, unsigned int reg, uint32_t val)
 {
     struct vlapic *vlapic = vcpu_vlapic(v);
@@ -1234,6 +1254,12 @@ void vlapic_tdt_msr_set(struct vlapic *vlapic, uint64_t value)
                 vlapic->hw.tdt_msr, guest_tsc);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vlapic.c|1290| <<vlapic_accept_pic_intr>> v ? __vlapic_accept_pic_intr(v) : -1);
+ *   - arch/x86/hvm/vlapic.c|1293| <<vlapic_accept_pic_intr>> __vlapic_accept_pic_intr(v));
+ *   - arch/x86/hvm/vlapic.c|1312| <<vlapic_adjust_i8259_target>> if ( __vlapic_accept_pic_intr(v) )
+ */
 static int __vlapic_accept_pic_intr(struct vcpu *v)
 {
     struct domain *d = v->domain;
@@ -1258,6 +1284,10 @@ static int __vlapic_accept_pic_intr(struct vcpu *v)
              ((lvt0 & (APIC_MODE_MASK|APIC_LVT_MASKED)) == APIC_DM_EXTINT) ||
              /* LAPIC is fully disabled? */
              vlapic_hw_disabled(vlapic)));
+
+    /*
+     * 上面APIC_DM_EXTINT = 0x00700
+     */
 }
 
 int vlapic_accept_pic_intr(struct vcpu *v)
@@ -1273,6 +1303,14 @@ int vlapic_accept_pic_intr(struct vcpu *v)
             __vlapic_accept_pic_intr(v));
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vioapic.c|257| <<vioapic_write_redirent>> vlapic_adjust_i8259_target(d);
+ *   - arch/x86/hvm/vlapic.c|863| <<vlapic_reg_write>> vlapic_adjust_i8259_target(v->domain);
+ *   - arch/x86/hvm/vlapic.c|1573| <<lapic_load_regs>> vlapic_adjust_i8259_target(d);
+ *
+ * 目前还不明白, 这个函数控制8259的中断发到哪一个apic?
+ */
 void vlapic_adjust_i8259_target(struct domain *d)
 {
     struct vcpu *v;
@@ -1289,10 +1327,19 @@ void vlapic_adjust_i8259_target(struct domain *d)
  found:
     if ( d->arch.hvm.i8259_target == v )
         return;
+    /*
+     * hvm是struct hvm_domain
+     * i8259_target是struct vcpu
+     */
     d->arch.hvm.i8259_target = v;
     pt_adjust_global_vcpu_target(v);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/irq.c|533| <<hvm_vcpu_has_pending_irq>> vector = vlapic_has_pending_irq(v);
+ *   - arch/x86/hvm/vmx/vvmx.c|1322| <<nvmx_update_apicv>> rvi = vlapic_has_pending_irq(v);
+ */
 int vlapic_has_pending_irq(struct vcpu *v)
 {
     struct vlapic *vlapic = vcpu_vlapic(v);
@@ -1372,6 +1419,11 @@ bool_t is_vlapic_lvtpc_enabled(struct vlapic *vlapic)
 }
 
 /* Reset the VLAPIC back to its init state. */
+/*
+ * called by:
+ *   - arch/x86/hvm/vlapic.c|300| <<vlapic_init_sipi_one>> vlapic_do_init(vcpu_vlapic(target));
+ *   - arch/x86/hvm/vlapic.c|1428| <<vlapic_reset>> vlapic_do_init(vlapic);
+ */
 static void vlapic_do_init(struct vlapic *vlapic)
 {
     int i;
@@ -1413,6 +1465,12 @@ static void vlapic_do_init(struct vlapic *vlapic)
 }
 
 /* Reset the VLAPIC back to its power-on/reset state. */
+/*
+ * called by:
+ *   - arch/x86/hvm/hvm.c|3946| <<hvm_s3_suspend>> vlapic_reset(vcpu_vlapic(v));
+ *   - arch/x86/hvm/vlapic.c|1139| <<guest_wrmsr_apic_base>> vlapic_reset(vlapic);
+ *   - arch/x86/hvm/vlapic.c|1630| <<vlapic_init>> vlapic_reset(vlapic);
+ */
 void vlapic_reset(struct vlapic *vlapic)
 {
     const struct vcpu *v = vlapic_vcpu(vlapic);
@@ -1580,6 +1638,10 @@ HVM_REGISTER_SAVE_RESTORE(LAPIC, lapic_save_hidden,
 HVM_REGISTER_SAVE_RESTORE(LAPIC_REGS, lapic_save_regs,
                           lapic_load_regs, 1, HVMSR_PER_VCPU);
 
+/*
+ * called by only:
+ *   - arch/x86/hvm/hvm.c|1505| <<hvm_vcpu_initialise>> rc = vlapic_init(v);
+ */
 int vlapic_init(struct vcpu *v)
 {
     struct vlapic *vlapic = vcpu_vlapic(v);
@@ -1588,6 +1650,13 @@ int vlapic_init(struct vcpu *v)
 
     if ( !has_vlapic(v->domain) )
     {
+        /*
+	 * VLAPIC_HW_DISABLED在以下被使用:
+	 *   - arch/x86/hvm/vlapic.c|1140| <<guest_wrmsr_apic_base>> vlapic->hw.disabled &= ~VLAPIC_HW_DISABLED;
+	 *   - arch/x86/hvm/vlapic.c|1145| <<guest_wrmsr_apic_base>> vlapic->hw.disabled |= VLAPIC_HW_DISABLED;
+	 *   - arch/x86/hvm/vlapic.c|1591| <<vlapic_init>> vlapic->hw.disabled = VLAPIC_HW_DISABLED;
+	 *   - include/asm-x86/hvm/vlapic.h|48| <<vlapic_hw_disabled>> #define vlapic_hw_disabled(vlapic) ((vlapic)->hw.disabled & VLAPIC_HW_DISABLED)
+	 */
         vlapic->hw.disabled = VLAPIC_HW_DISABLED;
         return 0;
     }
diff --git a/xen/arch/x86/hvm/vmx/vmcs.c b/xen/arch/x86/hvm/vmx/vmcs.c
index 74f2a08..fb85a30 100644
--- a/xen/arch/x86/hvm/vmx/vmcs.c
+++ b/xen/arch/x86/hvm/vmx/vmcs.c
@@ -42,6 +42,33 @@
 #include <asm/tboot.h>
 #include <asm/apic.h>
 
+/*
+ * 'xl debug-keys v'可以打印出所有的vmcs
+ *
+ *
+ * 3处会初始化vmcs的地方 (主要最后一处)
+ *
+ * hvm_cpu_up()
+ *  -> vmx_cpu_up()
+ *      -> _vmx_cpu_up(bool bsp) --> bsp == false
+ *          -> vmx_init_vmcs_config()
+ *
+ *
+ * presmp_initcall(hvm_enable)
+ *  -> hvm_enable()
+ *      -> start_vmx()
+ *          -> _vmx_cpu_up() --> bsp == true
+ *              -> vmx_init_vmcs_config()
+ *
+ *
+ * vcpu_create(vcpu_id)
+ *  -> arch_vcpu_create(vcpu)
+ *      -> hvm_vcpu_initialise(vcpu)
+ *          -> vmx_function_table.vcpu_initialise = vmx_vcpu_initialise(vcpu)
+ *              -> vmx_create_vmcs(vcpu)
+ *                  -> construct_vmcs()
+ */
+
 static bool_t __read_mostly opt_vpid_enabled = 1;
 boolean_param("vpid", opt_vpid_enabled);
 
@@ -166,6 +193,10 @@ static bool_t cap_check(const char *name, u32 expected, u32 saw)
     return saw != expected;
 }
 
+/*
+ * calle by only:
+ *   - arch/x86/hvm/vmx/vmcs.c|645| <<_vmx_cpu_up>> if ( (rc = vmx_init_vmcs_config()) != 0 )
+ */
 static int vmx_init_vmcs_config(void)
 {
     u32 vmx_basic_msr_low, vmx_basic_msr_high, min, opt;
@@ -598,6 +629,30 @@ void vmx_cpu_dead(unsigned int cpu)
     vmx_pi_desc_fixup(cpu);
 }
 
+/*
+ * 在测试机上有4个cpu, 第0个(bsp=true)和其他3个不一样
+ *
+ * 在CPU 0上执行
+ * [0] _vmx_cpu_up
+ * [0] smp_send_call_function_mask
+ * [0] on_selected_cpus
+ * [0] mwait-idle.c#mwait_idle_cpu_init
+ * [0] start_vmx
+ * [0] hvm.c#hvm_enable
+ * [0] do_presmp_initcalls
+ * [0] __start_xen
+ * [0] __high_start
+ *
+ * 在剩下的3个非bsp的cpu分别执行
+ * [0] _vmx_cpu_up
+ * [0] alloc_direct_apic_vector
+ * [0] intel_mcheck_init
+ * [0] start_secondary
+ *
+ * called by:
+ *   - arch/x86/hvm/vmx/vmcs.c|697| <<vmx_cpu_up>> return _vmx_cpu_up(false);
+ *   - arch/x86/hvm/vmx/vmx.c|2446| <<start_vmx>> if ( _vmx_cpu_up(true) )
+ */
 int _vmx_cpu_up(bool bsp)
 {
     u32 eax, edx;
@@ -688,6 +743,13 @@ int _vmx_cpu_up(bool bsp)
     return 0;
 }
 
+/*
+ * called by:
+ *   - arch/arm/platform.c|104| <<platform_cpu_up>> return platform->cpu_up(cpu);
+ *   - include/asm-x86/hvm/hvm.h|530| <<hvm_cpu_up>> return (hvm_funcs.cpu_up ? hvm_funcs.cpu_up() : 0);
+ *
+ * struct hvm_function_table vmx_function_table.cpu_up = vmx_cpu_up()
+ */
 int vmx_cpu_up()
 {
     return _vmx_cpu_up(false);
@@ -981,6 +1043,21 @@ static void pi_desc_init(struct vcpu *v)
     v->arch.hvm.vmx.pi_desc.ndst = APIC_INVALID_DEST;
 }
 
+/*
+ * 对于2个vcpu的hvm, 被调用两次
+ *
+ * [0] vmx_create_vmcs
+ * [0] vmx.c#vmx_vcpu_initialise
+ * [0] vlapic_init
+ * [0] hvm_vcpu_initialise
+ * [0] vcpu_init_fpu
+ * [0] arch_vcpu_create
+ * [0] vcpu_create
+ * [0] do_domctl
+ *
+ * called by only:
+ *   - arch/x86/hvm/vmx/vmcs.c|1781| <<vmx_create_vmcs>> if ( (rc = construct_vmcs(v)) != 0 )
+ */
 static int construct_vmcs(struct vcpu *v)
 {
     struct domain *d = v->domain;
@@ -1019,6 +1096,14 @@ static int construct_vmcs(struct vcpu *v)
 
     if ( paging_mode_hap(d) )
     {
+        /*
+	 * hap一般hvm下都是打开的!
+	 */
+
+        /*
+         * 这里取消了invlpg和cr3的访问,
+	 * 所以调用invlpg和访问cr3就不会trap了
+         */
         v->arch.hvm.vmx.exec_control &= ~(CPU_BASED_INVLPG_EXITING |
                                           CPU_BASED_CR3_LOAD_EXITING |
                                           CPU_BASED_CR3_STORE_EXITING);
@@ -1726,6 +1811,10 @@ void vmx_domain_update_eptp(struct domain *d)
     ept_sync_domain(p2m);
 }
 
+/*
+ * called only by:
+ *   - arch/x86/hvm/vmx/vmx.c|434| <<vmx_vcpu_initialise>> if ( (rc = vmx_create_vmcs(v)) != 0 )
+ */
 int vmx_create_vmcs(struct vcpu *v)
 {
     struct vmx_vcpu *vmx = &v->arch.hvm.vmx;
diff --git a/xen/arch/x86/hvm/vmx/vmx.c b/xen/arch/x86/hvm/vmx/vmx.c
index 725dd88..989b6a6 100644
--- a/xen/arch/x86/hvm/vmx/vmx.c
+++ b/xen/arch/x86/hvm/vmx/vmx.c
@@ -421,6 +421,13 @@ static void vmx_domain_destroy(struct domain *d)
     vmx_free_vlapic_mapping(d);
 }
 
+/*
+ * struct hvm_function_table vmx_function_table.vcpu_initialise = vmx_vcpu_initialise()
+ *
+ * called by:
+ *   - arch/arm/processor.c|39| <<processor_vcpu_initialise>> this_cpu(processor)->vcpu_initialise(v);
+ *   - arch/x86/hvm/hvm.c|1513| <<hvm_vcpu_initialise>> if ( (rc = hvm_funcs.vcpu_initialise(v)) != 0 )
+ */
 static int vmx_vcpu_initialise(struct vcpu *v)
 {
     int rc;
@@ -2439,6 +2446,10 @@ static void pi_notification_interrupt(struct cpu_user_regs *regs)
 static void __init lbr_tsx_fixup_check(void);
 static void __init bdw_erratum_bdf14_fixup_check(void);
 
+/*
+ * called by:
+ *   - arch/x86/hvm/hvm.c|150| <<hvm_enable>> fns = start_vmx();
+ */
 const struct hvm_function_table * __init start_vmx(void)
 {
     set_in_cr4(X86_CR4_VMXE);
diff --git a/xen/arch/x86/hvm/vpic.c b/xen/arch/x86/hvm/vpic.c
index 3f3fb7a..6eec184 100644
--- a/xen/arch/x86/hvm/vpic.c
+++ b/xen/arch/x86/hvm/vpic.c
@@ -61,6 +61,12 @@ static int vpic_get_priority(struct hvm_hw_vpic *vpic, uint8_t mask)
 }
 
 /* Return the PIC's highest priority pending interrupt. Return -1 if none. */
+/*
+ * called by:
+ *   - arch/x86/hvm/vpic.c|101| <<vpic_update_int_output>> irq = vpic_get_highest_priority_irq(vpic);
+ *   - arch/x86/hvm/vpic.c|166| <<vpic_intack>> irq = vpic_get_highest_priority_irq(vpic);
+ *   - arch/x86/hvm/vpic.c|173| <<vpic_intack>> irq = vpic_get_highest_priority_irq(vpic);
+ */
 static int vpic_get_highest_priority_irq(struct hvm_hw_vpic *vpic)
 {
     int cur_priority, priority, irq;
@@ -92,6 +98,16 @@ static int vpic_get_highest_priority_irq(struct hvm_hw_vpic *vpic)
     return (priority < cur_priority) ? irq : -1;
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpic.c|127| <<vpic_update_int_output>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|134| <<vpic_update_int_output>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|154| <<__vpic_intack>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|261| <<vpic_ioport_write>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|304| <<vpic_ioport_write>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|464| <<vpic_irq_positive_edge>> vpic_update_int_output(vpic);
+ *   - arch/x86/hvm/vpic.c|482| <<vpic_irq_negative_edge>> vpic_update_int_output(vpic);
+ */
 static void vpic_update_int_output(struct hvm_hw_vpic *vpic)
 {
     int irq;
@@ -154,6 +170,11 @@ static void __vpic_intack(struct hvm_hw_vpic *vpic, int irq)
     vpic_update_int_output(vpic);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpic.c|317| <<vpic_ioport_read>> return vpic_intack(vpic);
+ *   - arch/x86/hvm/vpic.c|497| <<vpic_ack_pending_irq>> irq = vpic_intack(vpic);
+ */
 static int vpic_intack(struct hvm_hw_vpic *vpic)
 {
     int irq = -1;
@@ -335,6 +356,11 @@ static int vpic_intercept_pic_io(
         return X86EMUL_OKAY;
     }
 
+    /*
+     * vpic的声明:
+     *
+     * struct hvm_hw_vpic     vpic[2];
+     */
     vpic = &current->domain->arch.hvm.vpic[port >> 7];
 
     if ( dir == IOREQ_WRITE )
diff --git a/xen/arch/x86/hvm/vpt.c b/xen/arch/x86/hvm/vpt.c
index ecd25d7..78f9c26 100644
--- a/xen/arch/x86/hvm/vpt.c
+++ b/xen/arch/x86/hvm/vpt.c
@@ -23,9 +23,22 @@
 #include <asm/apic.h>
 #include <asm/mc146818rtc.h>
 
+/*
+ * used by:
+ *   - arch/x86/hvm/vpt.c|201| <<pt_process_missed_ticks>> if ( mode_is(pt->vcpu->domain, no_missed_ticks_pending) )
+ *   - arch/x86/hvm/vpt.c|210| <<pt_freeze_time>> if ( !mode_is(v->domain, delay_for_missed_ticks) )
+ *   - arch/x86/hvm/vpt.c|218| <<pt_thaw_time>> if ( !mode_is(v->domain, delay_for_missed_ticks) )
+ *   - arch/x86/hvm/vpt.c|299| <<pt_irq_fired>> else if ( mode_is(v->domain, one_missed_tick_pending) ||
+ *   - arch/x86/hvm/vpt.c|300| <<pt_irq_fired>> mode_is(v->domain, no_missed_ticks_pending) )
+ *   - arch/x86/hvm/vpt.c|318| <<pt_irq_fired>> if ( mode_is(v->domain, delay_for_missed_ticks) &&
+ */
 #define mode_is(d, name) \
     ((d)->arch.hvm.params[HVM_PARAM_TIMER_MODE] == HVMPTM_##name)
 
+/*
+ * called only by:
+ *   - arch/x86/hvm/hvm.c|654| <<hvm_domain_initialise>> hvm_init_guest_time(d);
+ */
 void hvm_init_guest_time(struct domain *d)
 {
     struct pl_time *pl = d->arch.hvm.pl_time;
@@ -35,6 +48,12 @@ void hvm_init_guest_time(struct domain *d)
     pl->last_guest_time = 0;
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/hvm.c|412| <<hvm_set_guest_tsc_fixed>> tsc = hvm_get_guest_time_fixed(v, at_tsc);
+ *   - arch/x86/hvm/hvm.c|451| <<hvm_get_guest_tsc_fixed>> tsc = hvm_get_guest_time_fixed(v, at_tsc);
+ *   - include/asm-x86/hvm/hvm.h|357| <<hvm_get_guest_time>> #define hvm_get_guest_time(v) hvm_get_guest_time_fixed(v, 0)
+ */
 uint64_t hvm_get_guest_time_fixed(const struct vcpu *v, uint64_t at_tsc)
 {
     struct pl_time *pl = v->domain->arch.hvm.pl_time;
@@ -58,6 +77,11 @@ uint64_t hvm_get_guest_time_fixed(const struct vcpu *v, uint64_t at_tsc)
     return now + v->arch.hvm.stime_offset;
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|213| <<pt_thaw_time>> hvm_set_guest_time(v, v->arch.hvm.guest_time);
+ *   - arch/x86/hvm/vpt.c|304| <<pt_irq_fired>> hvm_set_guest_time(v, pt->last_plt_gtime);
+ */
 void hvm_set_guest_time(struct vcpu *v, u64 guest_time)
 {
     u64 offset = guest_time - hvm_get_guest_time(v);
@@ -75,16 +99,35 @@ void hvm_set_guest_time(struct vcpu *v, u64 guest_time)
     }
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|427| <<is_pt_irq>> (intack.vector == pt_irq_vector(pt, intack.source)) )
+ *
+ * hvm_intsrc src有以下种类:
+ * - hvm_intsrc_none,
+ * - hvm_intsrc_pic,
+ * - hvm_intsrc_lapic,
+ * - hvm_intsrc_nmi,
+ * - hvm_intsrc_mce,
+ * - hvm_intsrc_vector
+ */
 static int pt_irq_vector(struct periodic_time *pt, enum hvm_intsrc src)
 {
     struct vcpu *v = pt->vcpu;
     unsigned int gsi, isa_irq;
     int vector;
 
+    /*
+     * source的种类:
+     *   #define PTSRC_isa    1 // ISA time source
+     *   #define PTSRC_lapic  2 // LAPIC time source
+     *   #define PTSRC_ioapic 3 // IOAPIC time source
+     */
     if ( pt->source == PTSRC_lapic )
         return pt->irq;
 
     isa_irq = pt->irq;
+    /* #define hvm_isa_irq_to_gsi(isa_irq) ((isa_irq) ? : 2) */
     gsi = hvm_isa_irq_to_gsi(isa_irq);
 
     if ( src == hvm_intsrc_pic )
@@ -104,6 +147,10 @@ static int pt_irq_vector(struct periodic_time *pt, enum hvm_intsrc src)
     return vector;
 }
 
+/*
+ * called by only:
+ *   - arch/x86/hvm/vpt.c|380| <<pt_update_irq>> if ( (pt->irq != RTC_IRQ || !pt->priv) && pt_irq_masked(pt) &&
+ */
 static int pt_irq_masked(struct periodic_time *pt)
 {
     struct vcpu *v = pt->vcpu;
@@ -127,6 +174,7 @@ static int pt_irq_masked(struct periodic_time *pt)
         if ( !(pic_imr & (1 << (pt->irq & 7))) && vlapic_accept_pic_intr(v) )
             return 0;
 
+	/* #define hvm_isa_irq_to_gsi(isa_irq) ((isa_irq) ? : 2) */
         gsi = hvm_isa_irq_to_gsi(pt->irq);
     }
 
@@ -171,6 +219,12 @@ static void pt_unlock(struct periodic_time *pt)
     spin_unlock(&pt->vcpu->arch.hvm.tm_lock);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|247| <<pt_restore_timer>> pt_process_missed_ticks(pt);
+ *   - arch/x86/hvm/vpt.c|287| <<pt_irq_fired>> pt_process_missed_ticks(pt);
+ *   - arch/x86/hvm/vpt.c|296| <<pt_irq_fired>> pt_process_missed_ticks(pt);
+ */
 static void pt_process_missed_ticks(struct periodic_time *pt)
 {
     s_time_t missed_ticks, now = NOW();
@@ -250,6 +304,10 @@ void pt_restore_timer(struct vcpu *v)
     spin_unlock(&v->arch.hvm.tm_lock);
 }
 
+/*
+ * used by only:
+ *   - arch/x86/hvm/vpt.c|621| <<create_periodic_time>> init_timer(&pt->timer, pt_timer_fn, pt, v->processor);
+ */
 static void pt_timer_fn(void *data)
 {
     struct periodic_time *pt = data;
@@ -265,6 +323,11 @@ static void pt_timer_fn(void *data)
     pt_unlock(pt);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|410| <<pt_update_irq>> pt_irq_fired(v, pt);
+ *   - arch/x86/hvm/vpt.c|472| <<pt_intr_post>> pt_irq_fired(v, pt);
+ */
 static void pt_irq_fired(struct vcpu *v, struct periodic_time *pt)
 {
     pt->irq_issued = false;
@@ -287,6 +350,17 @@ static void pt_irq_fired(struct vcpu *v, struct periodic_time *pt)
     else
     {
         pt->last_plt_gtime += pt->period;
+        /*
+	 * pending_intr_nr在以下设置:
+	 *   - arch/x86/hvm/vpt.c|243| <<pt_process_missed_ticks>> pt->pending_intr_nr += missed_ticks;
+	 *   - arch/x86/hvm/vpt.c|295| <<pt_restore_timer>> if ( pt->pending_intr_nr == 0 )
+	 *   - arch/x86/hvm/vpt.c|317| <<pt_timer_fn>> pt->pending_intr_nr++;
+	 *   - arch/x86/hvm/vpt.c|340| <<pt_irq_fired>> pt->pending_intr_nr = 0;
+	 *   - arch/x86/hvm/vpt.c|347| <<pt_irq_fired>> pt->pending_intr_nr = 0;
+	 *   - arch/x86/hvm/vpt.c|353| <<pt_irq_fired>> if ( --pt->pending_intr_nr == 0 )
+	 *   - arch/x86/hvm/vpt.c|588| <<create_periodic_time>> pt->pending_intr_nr = 0;
+	 *   - arch/x86/hvm/vpt.c|668| <<destroy_periodic_time>> pt->pending_intr_nr = 0;
+	 */
         if ( --pt->pending_intr_nr == 0 )
         {
             pt_process_missed_ticks(pt);
@@ -300,6 +374,11 @@ static void pt_irq_fired(struct vcpu *v, struct periodic_time *pt)
         hvm_set_guest_time(v, pt->last_plt_gtime);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/svm/intr.c|146| <<svm_intr_assist>> pt_update_irq(v);
+ *   - arch/x86/hvm/vmx/intr.c|248| <<vmx_intr_assist>> pt_vector = pt_update_irq(v);
+ */
 int pt_update_irq(struct vcpu *v)
 {
     struct list_head *head = &v->arch.hvm.tm_list;
@@ -415,6 +494,10 @@ int pt_update_irq(struct vcpu *v)
     return pt_vector;
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|445| <<pt_intr_post>> pt = is_pt_irq(v, intack);
+ */
 static struct periodic_time *is_pt_irq(
     struct vcpu *v, struct hvm_intack intack)
 {
@@ -431,6 +514,13 @@ static struct periodic_time *is_pt_irq(
     return NULL;
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/svm/intr.c|217| <<svm_intr_assist>> pt_intr_post(v, intack);
+ *   - arch/x86/hvm/vmx/intr.c|206| <<nvmx_intr_intercept>> pt_intr_post(v, intack);
+ *   - arch/x86/hvm/vmx/intr.c|390| <<vmx_intr_assist>> pt_intr_post(v, intack);
+ *   - arch/x86/hvm/vmx/intr.c|396| <<vmx_intr_assist>> pt_intr_post(v, intack);
+ */
 void pt_intr_post(struct vcpu *v, struct hvm_intack intack)
 {
     struct periodic_time *pt;
@@ -460,6 +550,10 @@ void pt_intr_post(struct vcpu *v, struct hvm_intack intack)
         cb(v, cb_priv);
 }
 
+/*
+ * used by only:
+ *   - arch/x86/hvm/hvm.c|467| <<hvm_migrate_timers>> pt_migrate(v);
+ */
 void pt_migrate(struct vcpu *v)
 {
     struct list_head *head = &v->arch.hvm.tm_list;
@@ -473,6 +567,17 @@ void pt_migrate(struct vcpu *v)
     spin_unlock(&v->arch.hvm.tm_lock);
 }
 
+/*
+ * called by:
+ *   - arch/x86/emul-i8254.c|193| <<pit_load_count>> create_periodic_time(v, &pit->pt0, period, period, 0, pit_time_fired,
+ *   - arch/x86/emul-i8254.c|200| <<pit_load_count>> create_periodic_time(v, &pit->pt0, period, 0, 0, pit_time_fired,
+ *   - arch/x86/hvm/hpet.c|312| <<hpet_set_timer>> create_periodic_time(vhpet_vcpu(h), &h->pt[tn],
+ *   - arch/x86/hvm/rtc.c|158| <<rtc_timer_update>> create_periodic_time(v, &s->pt, delta, period,
+ *   - arch/x86/hvm/vlapic.c|749| <<vlapic_update_timer>> create_periodic_time(current, &vlapic->pt, delta,
+ *   - arch/x86/hvm/vlapic.c|1202| <<vlapic_tdt_msr_set>> create_periodic_time(v, &vlapic->pt, delta, 0,
+ *   - arch/x86/hvm/vlapic.c|1216| <<vlapic_tdt_msr_set>> create_periodic_time(v, &vlapic->pt, 0, 0,
+ *   - arch/x86/hvm/vlapic.c|1453| <<lapic_rearm>> create_periodic_time(vlapic_vcpu(s), &s->pt, period,
+ */
 void create_periodic_time(
     struct vcpu *v, struct periodic_time *pt, uint64_t delta,
     uint64_t period, uint8_t irq, time_cb *cb, void *data, bool level)
@@ -542,6 +647,25 @@ void create_periodic_time(
     spin_unlock(&v->arch.hvm.tm_lock);
 }
 
+/*
+ * callled by:
+ *   - arch/x86/emul-i8254.c|205| <<pit_load_count>> destroy_periodic_time(&pit->pt0);
+ *   - arch/x86/emul-i8254.c|390| <<pit_stop_channel0_irq>> destroy_periodic_time(&pit->pt0);
+ *   - arch/x86/emul-i8254.c|457| <<pit_reset>> destroy_periodic_time(&pit->pt0);
+ *   - arch/x86/emul-i8254.c|502| <<pit_deinit>> destroy_periodic_time(&pit->pt0);
+ *   - arch/x86/hvm/hpet.c|214| <<hpet_stop_timer>> destroy_periodic_time(&h->pt[tn]);
+ *   - arch/x86/hvm/hpet.c|282| <<hpet_set_timer>> destroy_periodic_time(&h->pt[tn]);
+ *   - arch/x86/hvm/rtc.c|95| <<rtc_pf_callback>> destroy_periodic_time(&s->pt);
+ *   - arch/x86/hvm/rtc.c|169| <<rtc_timer_update>> destroy_periodic_time(&s->pt);
+ *   - arch/x86/hvm/rtc.c|522| <<rtc_ioport_write>> destroy_periodic_time(&s->pt);
+ *   - arch/x86/hvm/rtc.c|797| <<rtc_reset>> destroy_periodic_time(&s->pt);
+ *   - arch/x86/hvm/rtc.c|845| <<rtc_deinit>> destroy_periodic_time(&s->pt);
+ *   - arch/x86/hvm/vlapic.c|779| <<vlapic_update_timer>> destroy_periodic_time(&vlapic->pt);
+ *   - arch/x86/hvm/vlapic.c|1245| <<vlapic_tdt_msr_set>> destroy_periodic_time(&vlapic->pt);
+ *   - arch/x86/hvm/vlapic.c|1464| <<vlapic_do_init>> destroy_periodic_time(&vlapic->pt);
+ *   - arch/x86/hvm/vlapic.c|1711| <<vlapic_destroy>> destroy_periodic_time(&vlapic->pt);
+ *   - arch/x86/hvm/vpt.c|584| <<create_periodic_time>> destroy_periodic_time(pt);
+ */
 void destroy_periodic_time(struct periodic_time *pt)
 {
     /* Was this structure previously initialised by create_periodic_time()? */
@@ -562,6 +686,15 @@ void destroy_periodic_time(struct periodic_time *pt)
     kill_timer(&pt->timer);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|625| <<pt_adjust_global_vcpu_target>> pt_adjust_vcpu(&vpit->pt0, v);
+ *   - arch/x86/hvm/vpt.c|631| <<pt_adjust_global_vcpu_target>> pt_adjust_vcpu(&pl_time->vrtc.pt, v);
+ *   - arch/x86/hvm/vpt.c|636| <<pt_adjust_global_vcpu_target>> pt_adjust_vcpu(&pl_time->vhpet.pt[i], v);
+ *
+ * 只有一条调用路径:
+ * vlapic_adjust_i8259_target() --> pt_adjust_global_vcpu_target() --> pt_adjust_vcpu()
+ */
 static void pt_adjust_vcpu(struct periodic_time *pt, struct vcpu *v)
 {
     int on_list;
@@ -590,6 +723,10 @@ static void pt_adjust_vcpu(struct periodic_time *pt, struct vcpu *v)
     spin_unlock(&v->arch.hvm.tm_lock);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vlapic.c|1293| <<vlapic_adjust_i8259_target>> pt_adjust_global_vcpu_target(v);
+ */
 void pt_adjust_global_vcpu_target(struct vcpu *v)
 {
     struct PITState *vpit;
@@ -618,6 +755,13 @@ void pt_adjust_global_vcpu_target(struct vcpu *v)
 }
 
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vpt.c|768| <<pt_may_unmask_irq>> pt_resume(&d->arch.vpit.pt0);
+ *   - arch/x86/hvm/vpt.c|769| <<pt_may_unmask_irq>> pt_resume(&d->arch.hvm.pl_time->vrtc.pt);
+ *   - arch/x86/hvm/vpt.c|771| <<pt_may_unmask_irq>> pt_resume(&d->arch.hvm.pl_time->vhpet.pt[i]);
+ *   - arch/x86/hvm/vpt.c|775| <<pt_may_unmask_irq>> pt_resume(vlapic_pt);
+ */
 static void pt_resume(struct periodic_time *pt)
 {
     if ( pt->vcpu == NULL )
@@ -633,6 +777,16 @@ static void pt_resume(struct periodic_time *pt)
     pt_unlock(pt);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hvm/vioapic.c|290| <<vioapic_write_redirent>> pt_may_unmask_irq(d, NULL);
+ *   - arch/x86/hvm/vlapic.c|846| <<vlapic_reg_write>> pt_may_unmask_irq(vlapic_domain(vlapic), &vlapic->pt);
+ *   - arch/x86/hvm/vlapic.c|884| <<vlapic_reg_write>> pt_may_unmask_irq(v->domain, NULL);
+ *   - arch/x86/hvm/vlapic.c|887| <<vlapic_reg_write>> pt_may_unmask_irq(NULL, &vlapic->pt);
+ *   - arch/x86/hvm/vlapic.c|1161| <<guest_wrmsr_apic_base>> pt_may_unmask_irq(vlapic_domain(vlapic), &vlapic->pt);
+ *   - arch/x86/hvm/vlapic.c|1166| <<guest_wrmsr_apic_base>> pt_may_unmask_irq(vlapic_domain(vlapic), NULL);
+ *   - arch/x86/hvm/vpic.c|330| <<vpic_ioport_write>> pt_may_unmask_irq(vpic_domain(vpic), NULL);
+ */
 void pt_may_unmask_irq(struct domain *d, struct periodic_time *vlapic_pt)
 {
     int i;
diff --git a/xen/arch/x86/irq.c b/xen/arch/x86/irq.c
index 23b4f42..211d796 100644
--- a/xen/arch/x86/irq.c
+++ b/xen/arch/x86/irq.c
@@ -48,6 +48,29 @@ static DECLARE_BITMAP(used_vectors, NR_VECTORS);
 
 static DEFINE_SPINLOCK(vector_lock);
 
+/*
+ * used by:
+ *   - arch/x86/irq.c|51| <<global>> DEFINE_PER_CPU(vector_irq_t, vector_irq);
+ *   - include/asm-x86/irq.h|52| <<global>> DECLARE_PER_CPU(vector_irq_t, vector_irq);
+ *   - arch/x86/i8259.c|106| <<_disable_8259A_irq>> per_cpu(vector_irq, 0)[LEGACY_VECTOR(irq)] = ~irq;
+ *   - arch/x86/i8259.c|122| <<enable_8259A_irq>> per_cpu(vector_irq, 0)[LEGACY_VECTOR(desc->irq)] = desc->irq;
+ *   - arch/x86/i8259.c|350| <<init_IRQ>> per_cpu(vector_irq, cpu)[FIRST_LEGACY_VECTOR + irq] = irq;
+ *   - arch/x86/i8259.c|355| <<init_IRQ>> per_cpu(vector_irq, cpu)[IRQ0_VECTOR] = 0;
+ *   - arch/x86/irq.c|134| <<__bind_irq_vector>> per_cpu(vector_irq, cpu)[vector] = irq;
+ *   - arch/x86/irq.c|258| <<__clear_irq_vector>> ASSERT( per_cpu(vector_irq, cpu)[vector] == irq );
+ *   - arch/x86/irq.c|259| <<__clear_irq_vector>> per_cpu(vector_irq, cpu)[vector] = ~irq;
+ *   - arch/x86/irq.c|283| <<__clear_irq_vector>> ASSERT( per_cpu(vector_irq, cpu)[old_vector] == irq );
+ *   - arch/x86/irq.c|285| <<__clear_irq_vector>> per_cpu(vector_irq, cpu)[old_vector] = ~irq;
+ *   - arch/x86/irq.c|359| <<init_irq_data>> this_cpu(vector_irq)[vector] = INT_MIN;
+ *   - arch/x86/irq.c|515| <<__assign_irq_vector>> if (per_cpu(vector_irq, new_cpu)[vector] >= 0)
+ *   - arch/x86/irq.c|527| <<__assign_irq_vector>> per_cpu(vector_irq, new_cpu)[vector] = irq;
+ *   - arch/x86/irq.c|577| <<setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = INT_MIN;
+ *   - arch/x86/irq.c|591| <<setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = irq;
+ *   - arch/x86/irq.c|651| <<irq_move_cleanup_interrupt>> irq = __get_cpu_var(vector_irq)[vector];
+ *   - arch/x86/irq.c|689| <<irq_move_cleanup_interrupt>> __get_cpu_var(vector_irq)[vector] = ~irq;
+ *   - arch/x86/irq.c|821| <<do_IRQ>> int irq = __get_cpu_var(vector_irq[vector]);
+ *   - arch/x86/smpboot.c|1376| <<smp_intr_init>> per_cpu(vector_irq, cpu)[vector] = irq;
+ */
 DEFINE_PER_CPU(vector_irq_t, vector_irq);
 
 DEFINE_PER_CPU(struct cpu_user_regs *, __irq_regs);
@@ -791,6 +814,16 @@ uint8_t alloc_hipriority_vector(void)
     return next++;
 }
 
+/*
+ * used by:
+ *   - arch/x86/irq.c|817| <<global>> static void (*direct_apic_vector[NR_VECTORS])(struct cpu_user_regs *);
+ *   - arch/x86/irq.c|821| <<set_direct_apic_vector>> BUG_ON(direct_apic_vector[vector] != NULL);
+ *   - arch/x86/irq.c|822| <<set_direct_apic_vector>> direct_apic_vector[vector] = handler;
+ *   - arch/x86/irq.c|875| <<do_IRQ>> if (direct_apic_vector[vector] != NULL) {
+ *   - arch/x86/irq.c|876| <<do_IRQ>> (*direct_apic_vector[vector])(regs);
+ *   - arch/x86/irq.c|2393| <<dump_irqs>> if ( direct_apic_vector[i] )
+ *   - arch/x86/irq.c|2394| <<dump_irqs>> printk(" %#02x -> %ps()\n", i, direct_apic_vector[i]);
+ */
 static void (*direct_apic_vector[NR_VECTORS])(struct cpu_user_regs *);
 void set_direct_apic_vector(
     uint8_t vector, void (*handler)(struct cpu_user_regs *))
@@ -818,6 +851,29 @@ void do_IRQ(struct cpu_user_regs *regs)
     uint32_t          tsc_in;
     struct irq_desc  *desc;
     unsigned int      vector = (u8)regs->entry_vector;
+    /*
+     * percpu的vector_irq[]在以下使用:
+     *   - arch/x86/irq.c|51| <<global>> DEFINE_PER_CPU(vector_irq_t, vector_irq);
+     *   - include/asm-x86/irq.h|52| <<global>> DECLARE_PER_CPU(vector_irq_t, vector_irq);
+     *   - arch/x86/i8259.c|106| <<_disable_8259A_irq>> per_cpu(vector_irq, 0)[LEGACY_VECTOR(irq)] = ~irq;
+     *   - arch/x86/i8259.c|122| <<enable_8259A_irq>> per_cpu(vector_irq, 0)[LEGACY_VECTOR(desc->irq)] = desc->irq;
+     *   - arch/x86/i8259.c|350| <<init_IRQ>> per_cpu(vector_irq, cpu)[FIRST_LEGACY_VECTOR + irq] = irq;
+     *   - arch/x86/i8259.c|355| <<init_IRQ>> per_cpu(vector_irq, cpu)[IRQ0_VECTOR] = 0;
+     *   - arch/x86/irq.c|134| <<__bind_irq_vector>> per_cpu(vector_irq, cpu)[vector] = irq;
+     *   - arch/x86/irq.c|258| <<__clear_irq_vector>> ASSERT( per_cpu(vector_irq, cpu)[vector] == irq );
+     *   - arch/x86/irq.c|259| <<__clear_irq_vector>> per_cpu(vector_irq, cpu)[vector] = ~irq;
+     *   - arch/x86/irq.c|283| <<__clear_irq_vector>> ASSERT( per_cpu(vector_irq, cpu)[old_vector] == irq );
+     *   - arch/x86/irq.c|285| <<__clear_irq_vector>> per_cpu(vector_irq, cpu)[old_vector] = ~irq;
+     *   - arch/x86/irq.c|359| <<init_irq_data>> this_cpu(vector_irq)[vector] = INT_MIN;
+     *   - arch/x86/irq.c|515| <<__assign_irq_vector>> if (per_cpu(vector_irq, new_cpu)[vector] >= 0)
+     *   - arch/x86/irq.c|527| <<__assign_irq_vector>> per_cpu(vector_irq, new_cpu)[vector] = irq;
+     *   - arch/x86/irq.c|577| <<setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = INT_MIN;
+     *   - arch/x86/irq.c|591| <<setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = irq;
+     *   - arch/x86/irq.c|651| <<irq_move_cleanup_interrupt>> irq = __get_cpu_var(vector_irq)[vector];
+     *   - arch/x86/irq.c|689| <<irq_move_cleanup_interrupt>> __get_cpu_var(vector_irq)[vector] = ~irq;
+     *   - arch/x86/irq.c|821| <<do_IRQ>> int irq = __get_cpu_var(vector_irq[vector]);
+     *   - arch/x86/smpboot.c|1376| <<smp_intr_init>> per_cpu(vector_irq, cpu)[vector] = irq;
+     */
     int irq = __get_cpu_var(vector_irq[vector]);
     struct cpu_user_regs *old_regs = set_irq_regs(regs);
     
@@ -826,6 +882,16 @@ void do_IRQ(struct cpu_user_regs *regs)
     irq_enter();
 
     if (irq < 0) {
+        /*
+	 * direct_apic_vector[]在以下使用:
+	 *   - arch/x86/irq.c|817| <<global>> static void (*direct_apic_vector[NR_VECTORS])(struct cpu_user_regs *);
+	 *   - arch/x86/irq.c|821| <<set_direct_apic_vector>> BUG_ON(direct_apic_vector[vector] != NULL);
+	 *   - arch/x86/irq.c|822| <<set_direct_apic_vector>> direct_apic_vector[vector] = handler;
+	 *   - arch/x86/irq.c|875| <<do_IRQ>> if (direct_apic_vector[vector] != NULL) {
+	 *   - arch/x86/irq.c|876| <<do_IRQ>> (*direct_apic_vector[vector])(regs);
+	 *   - arch/x86/irq.c|2393| <<dump_irqs>> if ( direct_apic_vector[i] )
+	 *   - arch/x86/irq.c|2394| <<dump_irqs>> printk(" %#02x -> %ps()\n", i, direct_apic_vector[i]);
+	 */
         if (direct_apic_vector[vector] != NULL) {
             (*direct_apic_vector[vector])(regs);
         } else {
diff --git a/xen/arch/x86/mm/hap/hap.c b/xen/arch/x86/mm/hap/hap.c
index 412a442..1758c9e 100644
--- a/xen/arch/x86/mm/hap/hap.c
+++ b/xen/arch/x86/mm/hap/hap.c
@@ -438,6 +438,10 @@ void hap_domain_init(struct domain *d)
     paging_log_dirty_init(d, &hap_ops);
 }
 
+/*
+ * called by only:
+ *   - arch/x86/mm/paging.c|847| <<paging_enable>> return hap_enable(d, mode);
+ */
 /* return 0 for success, -errno for failure */
 int hap_enable(struct domain *d, u32 mode)
 {
diff --git a/xen/common/domain.c b/xen/common/domain.c
index 32bca8d..674212a 100644
--- a/xen/common/domain.c
+++ b/xen/common/domain.c
@@ -134,6 +134,16 @@ static void vcpu_destroy(struct vcpu *v)
     free_vcpu_struct(v);
 }
 
+/*
+ * called by:
+ *   - arch/arm/domain_build.c|83| <<alloc_dom0_vcpu0>> return vcpu_create(dom0, 0, 0);
+ *   - arch/arm/domain_build.c|1992| <<construct_domain>> if ( vcpu_create(d, i, cpu) == NULL )
+ *   - arch/arm/domain_build.c|2029| <<construct_domU>> if ( vcpu_create(d, 0, 0) == NULL )
+ *   - arch/x86/dom0_build.c|206| <<dom0_setup_vcpu>> struct vcpu *v = vcpu_create(d, vcpu_id, cpu);
+ *   - common/domctl.c|565| <<do_domctl():XEN_DOMCTL_max_vcpus>> if ( vcpu_create(d, i, cpu) == NULL )
+ *   - common/schedule.c|1648| <<cpu_schedule_up>> vcpu_create(idle_vcpu[0]->domain, cpu, cpu);
+ *   - common/schedule.c|1821| <<scheduler_init>> if ( vcpu_create(idle_domain, 0, 0) == NULL )
+ */
 struct vcpu *vcpu_create(
     struct domain *d, unsigned int vcpu_id, unsigned int cpu_id)
 {
diff --git a/xen/common/timer.c b/xen/common/timer.c
index 376581b..eabacf3 100644
--- a/xen/common/timer.c
+++ b/xen/common/timer.c
@@ -152,6 +152,10 @@ static int remove_from_list(struct timer **pprev, struct timer *t)
     return (_pprev == pprev);
 }
 
+/*
+ * called by:
+ *   - common/timer.c|211| <<add_entry>> return add_to_list(&timers->list, t);
+ */
 static int add_to_list(struct timer **pprev, struct timer *t)
 {
     struct timer *curr, **_pprev = pprev;
@@ -192,6 +196,12 @@ static int remove_entry(struct timer *t)
     return rc;
 }
 
+/*
+ * called by:
+ *   - common/timer.c|220| <<activate_timer>> if ( add_entry(timer) )
+ *   - common/timer.c|499| <<timer_softirq_action>> add_entry(t);
+ *   - common/timer.c|584| <<migrate_timers_from_cpu>> notify |= add_entry(t);
+ */
 static int add_entry(struct timer *t)
 {
     struct timers *timers = &per_cpu(timers, t->cpu);
@@ -211,6 +221,11 @@ static int add_entry(struct timer *t)
     return add_to_list(&timers->list, t);
 }
 
+/*
+ * called by:
+ *   - common/timer.c|315| <<set_timer>> activate_timer(timer);
+ *   - common/timer.c|395| <<migrate_timer>> activate_timer(timer);
+ */
 static inline void activate_timer(struct timer *timer)
 {
     ASSERT(timer->status == TIMER_STATUS_inactive);
@@ -281,6 +296,37 @@ static bool_t active_timer(struct timer *timer)
 }
 
 
+/*
+ * called by:
+ *   - arch/x86/cpu/mcheck/amd_nonfatal.c|244| <<amd_nonfatal_mcheck_init>> init_timer(&mce_timer, mce_amd_work_fn, NULL, 0);
+ *   - arch/x86/cpu/mcheck/non-fatal.c|109| <<init_nonfatal_mce_checker>> init_timer(&mce_timer, mce_work_fn, NULL, 0);
+ *   - arch/x86/hvm/pmtimer.c|367| <<pmtimer_init>> init_timer(&s->timer, pmt_timer_callback, s, v->processor);
+ *   - arch/x86/hvm/rtc.c|811| <<rtc_init>> init_timer(&s->update_timer, rtc_update_timer, s, smp_processor_id());
+ *   - arch/x86/hvm/rtc.c|812| <<rtc_init>> init_timer(&s->update_timer2, rtc_update_timer2, s, smp_processor_id());
+ *   - arch/x86/hvm/rtc.c|813| <<rtc_init>> init_timer(&s->alarm_timer, rtc_alarm_cb, s, smp_processor_id());
+ *   - arch/x86/hvm/vpt.c|633| <<create_periodic_time>> init_timer(&pt->timer, pt_timer_fn, pt, v->processor);
+ *   - arch/x86/irq.c|958| <<irq_ratelimit_init>> init_timer(&irq_ratelimit_timer, irq_ratelimit_timer_fn, NULL, 0);
+ *   - arch/x86/irq.c|1628| <<pirq_guest_bind>> init_timer(&action->eoi_timer, irq_guest_eoi_timer_fn, desc, 0);
+ *   - arch/x86/nmi.c|439| <<cpu_nmi_callback>> init_timer(&per_cpu(nmi_timer, cpu), nmi_timer_fn, NULL, cpu);
+ *   - arch/x86/time.c|1752| <<try_platform_timer_tail>> init_timer(&plt_overflow_timer, plt_overflow, NULL, 0);
+ *   - arch/x86/time.c|1761| <<try_platform_timer_tail>> init_timer(&calibration_timer, time_calibration, NULL, 0);
+ *   - common/rcupdate.c|566| <<rcu_init_percpu_data>> init_timer(&rdp->idle_timer, rcu_idle_timer_handler, rdp, cpu);
+ *   - common/sched_credit.c|592| <<init_pdata>> init_timer(&prv->master_ticker, csched_acct, prv, cpu);
+ *   - common/sched_credit.c|600| <<init_pdata>> init_timer(&spc->ticker, csched_tick, (void *)(unsigned long )cpu, cpu);
+ *   - common/sched_credit2.c|3063| <<csched2_alloc_domdata>> init_timer(&sdom->repl_timer, replenish_domain_budget, sdom,
+ *   - common/sched_rt.c|720| <<rt_init_pdata>> init_timer(&prv->repl_timer, repl_timer_handler, (void *)ops, cpu);
+ *   - common/sched_rt.c|759| <<rt_switch_sched>> init_timer(&prv->repl_timer, repl_timer_handler, (void *)new_ops, cpu);
+ *   - common/schedule.c|266| <<sched_init_vcpu>> init_timer(&v->periodic_timer, vcpu_periodic_timer_fn,
+ *   - common/schedule.c|268| <<sched_init_vcpu>> init_timer(&v->singleshot_timer, vcpu_singleshot_timer_fn,
+ *   - common/schedule.c|270| <<sched_init_vcpu>> init_timer(&v->poll_timer, poll_timer_fn,
+ *   - common/schedule.c|1164| <<watchdog_domain_init>> init_timer(&d->watchdog_timer[i], domain_watchdog_timeout, d, 0);
+ *   - common/schedule.c|1640| <<cpu_schedule_up>> init_timer(&sd->s_timer, s_timer_fn, NULL, cpu);
+ *   - drivers/char/ehci-dbgp.c|1361| <<ehci_dbgp_init_postirq>> init_timer(&dbgp->timer, ehci_dbgp_poll, port, 0);
+ *   - drivers/char/ns16550.c|752| <<ns16550_init_postirq>> init_timer(&uart->timer, ns16550_poll, port, 0);
+ *   - drivers/char/ns16550.c|753| <<ns16550_init_postirq>> init_timer(&uart->resume_timer, ns16550_delayed_resume, port, 0);
+ *   - drivers/cpufreq/cpufreq_ondemand.c|192| <<dbs_timer_init>> init_timer(&per_cpu(dbs_timer, dbs_info->cpu), do_dbs_timer,
+ *   - drivers/passthrough/io.c|566| <<pt_irq_create_bind>> init_timer(&pirq_dpci->timer, pt_irq_time_out, pirq_dpci, 0);
+ */
 void init_timer(
     struct timer *timer,
     void        (*function)(void *),
diff --git a/xen/include/asm-x86/hvm/vcpu.h b/xen/include/asm-x86/hvm/vcpu.h
index 6c84d5a..09f3ac2 100644
--- a/xen/include/asm-x86/hvm/vcpu.h
+++ b/xen/include/asm-x86/hvm/vcpu.h
@@ -167,6 +167,20 @@ struct hvm_vcpu {
 
     /* Lock and list for virtual platform timers. */
     spinlock_t          tm_lock;
+    /*
+     * used by:
+     *   - arch/x86/domain.c|1740| <<context_switch>> if ( is_hvm_domain(prevd) && !list_empty(&prev->arch.hvm.tm_list) )
+     *   - arch/x86/hvm/hvm.c|1506| <<hvm_vcpu_initialise>> INIT_LIST_HEAD(&v->arch.hvm.tm_list);
+     *   - arch/x86/hvm/vpt.c|269| <<pt_save_timer>> struct list_head *head = &v->arch.hvm.tm_list;
+     *   - arch/x86/hvm/vpt.c|288| <<pt_restore_timer>> struct list_head *head = &v->arch.hvm.tm_list;
+     *   - arch/x86/hvm/vpt.c|373| <<pt_update_irq>> struct list_head *head = &v->arch.hvm.tm_list;
+     *   - arch/x86/hvm/vpt.c|466| <<pt_update_irq>> list_for_each_entry ( pt, &v->arch.hvm.tm_list, list )
+     *   - arch/x86/hvm/vpt.c|493| <<is_pt_irq>> struct list_head *head = &v->arch.hvm.tm_list;
+     *   - arch/x86/hvm/vpt.c|548| <<pt_migrate>> struct list_head *head = &v->arch.hvm.tm_list;
+     *   - arch/x86/hvm/vpt.c|631| <<create_periodic_time>> list_add(&pt->list, &v->arch.hvm.tm_list);
+     *   - arch/x86/hvm/vpt.c|708| <<pt_adjust_vcpu>> list_add(&pt->list, &v->arch.hvm.tm_list);
+     *   - arch/x86/hvm/vpt.c|756| <<pt_resume>> list_add(&pt->list, &pt->vcpu->arch.hvm.tm_list);
+     */
     struct list_head    tm_list;
 
     bool                flag_dr_dirty;
diff --git a/xen/include/asm-x86/hvm/vlapic.h b/xen/include/asm-x86/hvm/vlapic.h
index dde66b4..593553d 100644
--- a/xen/include/asm-x86/hvm/vlapic.h
+++ b/xen/include/asm-x86/hvm/vlapic.h
@@ -42,7 +42,21 @@
  *  2. 'Software disable': via APIC_SPIV[8].
  *     APIC is visible but does not respond to interrupt messages.
  */
+/*
+ * used by:
+ *   - arch/x86/hvm/vlapic.c|1140| <<guest_wrmsr_apic_base>> vlapic->hw.disabled &= ~VLAPIC_HW_DISABLED;
+ *   - arch/x86/hvm/vlapic.c|1145| <<guest_wrmsr_apic_base>> vlapic->hw.disabled |= VLAPIC_HW_DISABLED;
+ *   - arch/x86/hvm/vlapic.c|1591| <<vlapic_init>> vlapic->hw.disabled = VLAPIC_HW_DISABLED;
+ *   - include/asm-x86/hvm/vlapic.h|48| <<vlapic_hw_disabled>> #define vlapic_hw_disabled(vlapic) ((vlapic)->hw.disabled & VLAPIC_HW_DISABLED)
+ */
 #define VLAPIC_HW_DISABLED              0x1
+/*
+ * used by:
+ *   - arch/x86/hvm/vlapic.c|814| <<vlapic_reg_write>> vlapic->hw.disabled |= VLAPIC_SW_DISABLED;
+ *   - arch/x86/hvm/vlapic.c|825| <<vlapic_reg_write>> vlapic->hw.disabled &= ~VLAPIC_SW_DISABLED;
+ *   - arch/x86/hvm/vlapic.c|1409| <<vlapic_do_init>> vlapic->hw.disabled |= VLAPIC_SW_DISABLED;
+ *   - include/asm-x86/hvm/vlapic.h|47| <<vlapic_sw_disabled>> #define vlapic_sw_disabled(vlapic) ((vlapic)->hw.disabled & VLAPIC_SW_DISABLED)
+ */
 #define VLAPIC_SW_DISABLED              0x2
 #define vlapic_sw_disabled(vlapic) ((vlapic)->hw.disabled & VLAPIC_SW_DISABLED)
 #define vlapic_hw_disabled(vlapic) ((vlapic)->hw.disabled & VLAPIC_HW_DISABLED)
diff --git a/xen/include/asm-x86/hvm/vmx/vmcs.h b/xen/include/asm-x86/hvm/vmx/vmcs.h
index b3e8001..4da9802 100644
--- a/xen/include/asm-x86/hvm/vmx/vmcs.h
+++ b/xen/include/asm-x86/hvm/vmx/vmcs.h
@@ -194,6 +194,15 @@ void vmx_vmcs_reload(struct vcpu *v);
 #define CPU_BASED_VIRTUAL_INTR_PENDING        0x00000004
 #define CPU_BASED_USE_TSC_OFFSETING           0x00000008
 #define CPU_BASED_HLT_EXITING                 0x00000080
+/*
+ * used by:
+ *   - arch/x86/hvm/vmx/vmcs.c|196| <<vmx_init_vmcs_config>> CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vmcs.c|309| <<vmx_init_vmcs_config>> if ( must_be_one & (CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vmcs.c|1022| <<construct_vmcs>> v->arch.hvm.vmx.exec_control &= ~(CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vvmx.c|2152| <<nvmx_msr_read_intercept>> CPU_BASED_INVLPG_EXITING |
+ *   - arch/x86/hvm/vmx/vvmx.c|2173| <<nvmx_msr_read_intercept>> CPU_BASED_INVLPG_EXITING);
+ *   - arch/x86/hvm/vmx/vvmx.c|2533| <<nvmx_n2_vmexit_handler>> if ( ctrl & CPU_BASED_INVLPG_EXITING )
+ */
 #define CPU_BASED_INVLPG_EXITING              0x00000200
 #define CPU_BASED_MWAIT_EXITING               0x00000400
 #define CPU_BASED_RDPMC_EXITING               0x00000800
diff --git a/xen/include/asm-x86/hvm/vpt.h b/xen/include/asm-x86/hvm/vpt.h
index 99169dd..09d4316 100644
--- a/xen/include/asm-x86/hvm/vpt.h
+++ b/xen/include/asm-x86/hvm/vpt.h
@@ -49,8 +49,38 @@ struct periodic_time {
     u8 source;                  /* PTSRC_ */
     u8 irq;
     struct vcpu *vcpu;          /* vcpu timer interrupt delivers to */
+    /*
+     * used by:
+     *   - arch/x86/hvm/vpt.c|241| <<pt_process_missed_ticks>> pt->do_not_freeze = !pt->pending_intr_nr;
+     *   - arch/x86/hvm/vpt.c|243| <<pt_process_missed_ticks>> pt->pending_intr_nr += missed_ticks;
+     *   - arch/x86/hvm/vpt.c|295| <<pt_restore_timer>> if ( pt->pending_intr_nr == 0 )
+     *   - arch/x86/hvm/vpt.c|317| <<pt_timer_fn>> pt->pending_intr_nr++;
+     *   - arch/x86/hvm/vpt.c|340| <<pt_irq_fired>> pt->pending_intr_nr = 0;
+     *   - arch/x86/hvm/vpt.c|347| <<pt_irq_fired>> pt->pending_intr_nr = 0;
+     *   - arch/x86/hvm/vpt.c|353| <<pt_irq_fired>> if ( --pt->pending_intr_nr == 0 )
+     *   - arch/x86/hvm/vpt.c|356| <<pt_irq_fired>> if ( pt->pending_intr_nr == 0 )
+     *   - arch/x86/hvm/vpt.c|385| <<pt_update_irq>> if ( pt->pending_intr_nr )
+     *   - arch/x86/hvm/vpt.c|498| <<is_pt_irq>> if ( pt->pending_intr_nr && pt->irq_issued &&
+     *   - arch/x86/hvm/vpt.c|588| <<create_periodic_time>> pt->pending_intr_nr = 0;
+     *   - arch/x86/hvm/vpt.c|668| <<destroy_periodic_time>> pt->pending_intr_nr = 0;
+     *   - arch/x86/hvm/vpt.c|753| <<pt_resume>> if ( pt->pending_intr_nr && !pt->on_list )
+     *   - include/asm-x86/hvm/vpt.h|160| <<pt_active>> #define pt_active(pt) ((pt)->on_list || (pt)->pending_intr_nr)
+     */
     u32 pending_intr_nr;        /* pending timer interrupts */
     u64 period;                 /* frequency in ns */
+    /*
+     * used by:
+     *   - arch/x86/hvm/vpt.c|235| <<pt_process_missed_ticks>> missed_ticks = now - pt->scheduled;
+     *   - arch/x86/hvm/vpt.c|244| <<pt_process_missed_ticks>> pt->scheduled += missed_ticks * pt->period;
+     *   - arch/x86/hvm/vpt.c|298| <<pt_restore_timer>> set_timer(&pt->timer, pt->scheduled);
+     *   - arch/x86/hvm/vpt.c|318| <<pt_timer_fn>> pt->scheduled += pt->period;
+     *   - arch/x86/hvm/vpt.c|348| <<pt_irq_fired>> set_timer(&pt->timer, pt->scheduled);
+     *   - arch/x86/hvm/vpt.c|357| <<pt_irq_fired>> set_timer(&pt->timer, pt->scheduled);
+     *   - arch/x86/hvm/vpt.c|607| <<create_periodic_time>> pt->scheduled = NOW() + delta;
+     *   - arch/x86/hvm/vpt.c|613| <<create_periodic_time>> pt->scheduled = align_timer(pt->scheduled, pt->period);
+     *   - arch/x86/hvm/vpt.c|623| <<create_periodic_time>> pt->scheduled += delta >> 1;
+     *   - arch/x86/hvm/vpt.c|634| <<create_periodic_time>> set_timer(&pt->timer, pt->scheduled);
+     */
     s_time_t scheduled;         /* scheduled timer interrupt */
     u64 last_plt_gtime;         /* platform time when last IRQ is injected */
     struct timer timer;         /* ac_timer */
diff --git a/xen/include/asm-x86/irq.h b/xen/include/asm-x86/irq.h
index 4b39997..be4aac6 100644
--- a/xen/include/asm-x86/irq.h
+++ b/xen/include/asm-x86/irq.h
@@ -49,6 +49,29 @@ struct arch_irq_desc {
 #define IRQ_VECTOR_UNASSIGNED (-1)
 
 typedef int vector_irq_t[NR_VECTORS];
+/*
+ * used by:
+ *   - arch/x86/irq.c|51| <<global>> DEFINE_PER_CPU(vector_irq_t, vector_irq);
+ *   - include/asm-x86/irq.h|52| <<global>> DECLARE_PER_CPU(vector_irq_t, vector_irq);
+ *   - arch/x86/i8259.c|106| <<_disable_8259A_irq>> per_cpu(vector_irq, 0)[LEGACY_VECTOR(irq)] = ~irq;
+ *   - arch/x86/i8259.c|122| <<enable_8259A_irq>> per_cpu(vector_irq, 0)[LEGACY_VECTOR(desc->irq)] = desc->irq;
+ *   - arch/x86/i8259.c|350| <<init_IRQ>> per_cpu(vector_irq, cpu)[FIRST_LEGACY_VECTOR + irq] = irq;
+ *   - arch/x86/i8259.c|355| <<init_IRQ>> per_cpu(vector_irq, cpu)[IRQ0_VECTOR] = 0;
+ *   - arch/x86/irq.c|134| <<__bind_irq_vector>> per_cpu(vector_irq, cpu)[vector] = irq;
+ *   - arch/x86/irq.c|258| <<__clear_irq_vector>> ASSERT( per_cpu(vector_irq, cpu)[vector] == irq );
+ *   - arch/x86/irq.c|259| <<__clear_irq_vector>> per_cpu(vector_irq, cpu)[vector] = ~irq;
+ *   - arch/x86/irq.c|283| <<__clear_irq_vector>> ASSERT( per_cpu(vector_irq, cpu)[old_vector] == irq );
+ *   - arch/x86/irq.c|285| <<__clear_irq_vector>> per_cpu(vector_irq, cpu)[old_vector] = ~irq;
+ *   - arch/x86/irq.c|359| <<init_irq_data>> this_cpu(vector_irq)[vector] = INT_MIN;
+ *   - arch/x86/irq.c|515| <<__assign_irq_vector>> if (per_cpu(vector_irq, new_cpu)[vector] >= 0)
+ *   - arch/x86/irq.c|527| <<__assign_irq_vector>> per_cpu(vector_irq, new_cpu)[vector] = irq;
+ *   - arch/x86/irq.c|577| <<setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = INT_MIN;
+ *   - arch/x86/irq.c|591| <<setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = irq;
+ *   - arch/x86/irq.c|651| <<irq_move_cleanup_interrupt>> irq = __get_cpu_var(vector_irq)[vector];
+ *   - arch/x86/irq.c|689| <<irq_move_cleanup_interrupt>> __get_cpu_var(vector_irq)[vector] = ~irq;
+ *   - arch/x86/irq.c|821| <<do_IRQ>> int irq = __get_cpu_var(vector_irq[vector]);
+ *   - arch/x86/smpboot.c|1376| <<smp_intr_init>> per_cpu(vector_irq, cpu)[vector] = irq;
+ */
 DECLARE_PER_CPU(vector_irq_t, vector_irq);
 
 extern bool opt_noirqbalance;
diff --git a/xen/include/asm-x86/paging.h b/xen/include/asm-x86/paging.h
index 18a7eae..3469b29 100644
--- a/xen/include/asm-x86/paging.h
+++ b/xen/include/asm-x86/paging.h
@@ -46,6 +46,11 @@
 #define PG_SH_enable   0
 #define PG_SH_forced   0
 #endif
+/*
+ * used by:
+ *   - arch/x86/mm/hap/hap.c|505| <<hap_enable>> d->arch.paging.mode = mode | PG_HAP_enable;
+ *   - include/asm-x86/paging.h|69| <<paging_mode_hap>> #define paging_mode_hap(_d) (!!((_d)->arch.paging.mode & PG_HAP_enable))
+ */
 #define PG_HAP_enable  (1U << PG_HAP_shift)
 
 /* common paging mode bits */
-- 
2.7.4

