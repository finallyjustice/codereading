From 96e4014acdf532853d1218599400af6e81c316f5 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Fri, 14 Aug 2020 13:58:42 -0700
Subject: [PATCH 1/1] linux-2.6.32-754.30.2

linux-2.6.32-754.30.2

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 drivers/net/virtio_net.c     | 265 ++++++++++++++++++++++
 drivers/virtio/virtio.c      |   3 +
 drivers/virtio/virtio_ring.c | 428 +++++++++++++++++++++++++++++++++++
 include/linux/irq.h          |  57 +++++
 include/linux/netdevice.h    |  19 ++
 include/linux/virtio.h       |  11 +
 include/linux/virtio_pci.h   |   6 +
 include/linux/virtio_ring.h  | 105 +++++++++
 kernel/irq/chip.c            |  15 ++
 kernel/irq/spurious.c        |   9 +
 net/core/dev.c               |  14 ++
 11 files changed, 932 insertions(+)

diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index a887b152..b02c006a 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -74,6 +74,26 @@ struct receive_queue {
 	struct napi_struct napi;
 
 	/* Number of input buffers, and max we've ever had. */
+	/*
+	 * 使用receive_queue->max的地方:
+	 *   - drivers/net/virtio_net.c|625| <<try_fill_recv>> if (unlikely(rq->num > rq->max))
+	 *   - drivers/net/virtio_net.c|626| <<try_fill_recv>> rq->max = rq->num;
+	 *   - drivers/net/virtio_net.c|697| <<virtnet_poll>> if (rq->num < rq->max / 2) {
+	 *
+	 *
+	 * 在以下修改receive_queue->num:
+	 *   - drivers/net/virtio_net.c|442| <<receive_mergeable>> --rq->num;
+	 *   - drivers/net/virtio_net.c|457| <<receive_mergeable>> --rq->num;
+	 *   - drivers/net/virtio_net.c|691| <<try_fill_recv>> ++rq->num;
+	 *   - drivers/net/virtio_net.c|787| <<virtnet_poll>> --rq->num;
+	 *   - drivers/net/virtio_net.c|1570| <<free_unused_bufs>> --vi->rq[i].num;
+	 * 在以下使用receive_queue->num:
+	 *   - drivers/net/virtio_net.c|699| <<try_fill_recv>> if (unlikely(rq->num > rq->max))
+	 *   - drivers/net/virtio_net.c|700| <<try_fill_recv>> rq->max = rq->num;
+	 *   - drivers/net/virtio_net.c|797| <<virtnet_poll>> if (rq->num < rq->max / 2) {
+	 *   - drivers/net/virtio_net.c|1572| <<free_unused_bufs>> BUG_ON(vi->rq[i].num != 0);
+	 *   - drivers/net/virtio_net.c|1864| <<virtnet_probe>> if (vi->rq[i].num == 0) {
+	 */
 	unsigned int num, max;
 
 	/* Chain pages by the private ptr. */
@@ -105,12 +125,37 @@ struct virtnet_info
 	u16 max_queue_pairs;
 
 	/* # of queue pairs currently used by the driver */
+	/*
+	 * 在以下修改virtnet_info->curr_queue_pairs:
+	 *   - drivers/net/virtio_net.c|1023| <<virtnet_set_queues>> vi->curr_queue_pairs = queue_pairs;
+	 *   - drivers/net/virtio_net.c|1701| <<virtnet_probe>> vi->curr_queue_pairs = 1;
+	 * 在以下使用virtnet_info->curr_queue_pairs:
+	 *   - drivers/net/virtio_net.c|651| <<refill_work>> for (i = 0; i < vi->curr_queue_pairs; i++) {
+	 *   - drivers/net/virtio_net.c|708| <<virtnet_open>> if (i < vi->curr_queue_pairs)
+	 *   - drivers/net/virtio_net.c|876| <<virtnet_netpoll>> for (i = 0; i < vi->curr_queue_pairs; i++)
+	 *   - drivers/net/virtio_net.c|1164| <<virtnet_clean_affinity>> ++i % vi->curr_queue_pairs;
+	 *   - drivers/net/virtio_net.c|1178| <<virtnet_set_affinity>> if (vi->curr_queue_pairs == 1 ||
+	 *   - drivers/net/virtio_net.c|1251| <<virtnet_get_channels>> channels->combined_count = vi->curr_queue_pairs;
+	 *   - drivers/net/virtio_net.c|1719| <<virtnet_probe>> for (i = 0; i < vi->curr_queue_pairs; i++) {
+	 *   - drivers/net/virtio_net.c|1852| <<virtnet_restore>> for (i = 0; i < vi->curr_queue_pairs; i++)
+	 *   - drivers/net/virtio_net.c|1861| <<virtnet_restore>> virtnet_set_queues(vi, vi->curr_queue_pairs);
+	 */
 	u16 curr_queue_pairs;
 
 	/* I like... big packets and I cannot lie! */
 	bool big_packets;
 
 	/* Host will merge rx buffers for big packets (shake it! shake it!) */
+	/*
+	 * 在以下使用virtnet_info->mergeable_rx_bufs:
+	 *   - drivers/net/virtio_net.c|267| <<page_to_skb>> if (vi->mergeable_rx_bufs) {
+	 *   - drivers/net/virtio_net.c|397| <<receive_buf>> if (vi->mergeable_rx_bufs || vi->big_packets)
+	 *   - drivers/net/virtio_net.c|403| <<receive_buf>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|582| <<try_fill_recv>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|761| <<xmit_skb>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|1380| <<free_unused_bufs>> if (vi->mergeable_rx_bufs || vi->big_packets)
+	 *   - drivers/net/virtio_net.c|1636| <<virtnet_probe>> vi->mergeable_rx_bufs = true;
+	 */
 	bool mergeable_rx_bufs;
 
 	/* Has control virtqueue */
@@ -123,6 +168,19 @@ struct virtnet_info
 	struct virtnet_stats __percpu *stats;
 
 	/* Work struct for refilling if we run low on memory. */
+	/*
+	 * drivers/net/virtio_net.c|742| <<refill_work>> container_of(work, struct virtnet_info, refill.work);
+ 60 drivers/net/virtio_net.c|757| <<refill_work>> schedule_delayed_work(&vi->refill, HZ/2);
+ 61 drivers/net/virtio_net.c|799| <<virtnet_poll>> queue_delayed_work(vi->st_wq, &vi->refill, 0);
+ 62 drivers/net/virtio_net.c|826| <<virtnet_open>> schedule_delayed_work(&vi->refill, 0);
+ 63 drivers/net/virtio_net.c|1162| <<virtnet_set_queues>> schedule_delayed_work(&vi->refill, 0);
+ 64 drivers/net/virtio_net.c|1174| <<virtnet_close>> cancel_delayed_work_sync(&vi->refill);
+ 65 drivers/net/virtio_net.c|1672| <<virtnet_alloc_queues>> INIT_DELAYED_WORK(&vi->refill, refill_work);
+ 66 drivers/net/virtio_net.c|1805| <<virtnet_probe>> INIT_DELAYED_WORK(&vi->refill, refill_work);
+ 67 drivers/net/virtio_net.c|1897| <<virtnet_probe>> cancel_delayed_work_sync(&vi->refill);
+ 68 drivers/net/virtio_net.c|1963| <<virtnet_freeze>> cancel_delayed_work_sync(&vi->refill);
+	 *   - drivers/net/virtio_net.c|1995| <<virtnet_restore>> queue_delayed_work(vi->st_wq, &vi->refill, 0);
+	 */
 	struct delayed_work refill;
 
 	/* Work struct for config space updates */
@@ -182,8 +240,14 @@ static int rxq2vq(int rxq)
 	return rxq * 2;
 }
 
+/*
+ * 返回共享的共享的char cb[48];
+ */
 static inline struct skb_vnet_hdr *skb_vnet_hdr(struct sk_buff *skb)
 {
+	/*
+	 * 共享的char cb[48];
+	 */
 	return (struct skb_vnet_hdr *)skb->cb;
 }
 
@@ -191,6 +255,19 @@ static inline struct skb_vnet_hdr *skb_vnet_hdr(struct sk_buff *skb)
  * private is used to chain pages for big packets, put the whole
  * most recent used list in the beginning for reuse
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|357| <<page_to_skb>> give_pages(rq, page);
+ *   - drivers/net/virtio_net.c|387| <<receive_big>> give_pages(rq, page);
+ *   - drivers/net/virtio_net.c|433| <<receive_mergeable>> give_pages(rq, page);
+ *   - drivers/net/virtio_net.c|443| <<receive_mergeable>> give_pages(rq, page);
+ *   - drivers/net/virtio_net.c|468| <<receive_buf>> give_pages(rq, buf);
+ *   - drivers/net/virtio_net.c|585| <<add_recvbuf_big>> give_pages(rq, list);
+ *   - drivers/net/virtio_net.c|597| <<add_recvbuf_big>> give_pages(rq, list);
+ *   - drivers/net/virtio_net.c|615| <<add_recvbuf_big>> give_pages(rq, first);
+ *   - drivers/net/virtio_net.c|641| <<add_recvbuf_mergeable>> give_pages(rq, page);
+ *   - drivers/net/virtio_net.c|1528| <<free_unused_bufs>> give_pages(&vi->rq[i], buf);
+ */
 static void give_pages(struct receive_queue *rq, struct page *page)
 {
 	struct page *end;
@@ -201,8 +278,19 @@ static void give_pages(struct receive_queue *rq, struct page *page)
 	rq->pages = page;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|551| <<add_recvbuf_big>> first = get_a_page(rq, gfp);
+ *   - drivers/net/virtio_net.c|564| <<add_recvbuf_big>> first = get_a_page(rq, gfp);
+ *   - drivers/net/virtio_net.c|598| <<add_recvbuf_mergeable>> page = get_a_page(rq, gfp);
+ *   - drivers/net/virtio_net.c|1477| <<free_receive_bufs>> __free_pages(get_a_page(&vi->rq[i], GFP_KERNEL), 0);
+ *
+ * 如果receive_queue->pages上有page, 拿出来
+ * 否则分配新的struct page
+ */
 static struct page *get_a_page(struct receive_queue *rq, gfp_t gfp_mask)
 {
+	/* struct page *pages; */
 	struct page *p = rq->pages;
 
 	if (p) {
@@ -214,6 +302,10 @@ static struct page *get_a_page(struct receive_queue *rq, gfp_t gfp_mask)
 	return p;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|1552| <<virtnet_find_vqs>> callbacks[txq2vq(i)] = skb_xmit_done;
+ */
 static void skb_xmit_done(struct virtqueue *vq)
 {
 	struct virtnet_info *vi = vq->vdev->priv;
@@ -225,6 +317,11 @@ static void skb_xmit_done(struct virtqueue *vq)
 	netif_wake_subqueue(vi->dev, vq2txq(vq));
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|320| <<page_to_skb>> set_skb_frag(skb, page, offset, &len);
+ *   - drivers/net/virtio_net.c|396| <<receive_mergeable>> set_skb_frag(skb, page, 0, &len);
+ */
 static void set_skb_frag(struct sk_buff *skb, struct page *page,
 			 unsigned int offset, unsigned int *len)
 {
@@ -244,6 +341,14 @@ static void set_skb_frag(struct sk_buff *skb, struct page *page,
 }
 
 /* Called from bottom half context */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|347| <<receive_big>> struct sk_buff *skb = page_to_skb(rq, page, len);
+ *   - drivers/net/virtio_net.c|372| <<receive_mergeable>> struct sk_buff *skb = page_to_skb(rq, page, len);
+ *
+ * page->private可能串着一个或者多个page
+ * 把这些page copy成一个skb
+ */
 static struct sk_buff *page_to_skb(struct receive_queue *rq,
 				   struct page *page, unsigned int len)
 {
@@ -262,6 +367,9 @@ static struct sk_buff *page_to_skb(struct receive_queue *rq,
 
 	skb_reserve(skb, NET_IP_ALIGN);
 
+	/*
+	 * 返回共享的共享的char cb[48];
+	 */
 	hdr = skb_vnet_hdr(skb);
 
 	if (vi->mergeable_rx_bufs) {
@@ -326,6 +434,10 @@ err:
 	return NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|435| <<receive_buf>> skb = receive_mergeable(dev, rq, buf, len);
+ */
 static struct sk_buff *receive_mergeable(struct net_device *dev,
 					 struct receive_queue *rq,
 					 void *buf,
@@ -383,6 +495,10 @@ err_buf:
 	return NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|718| <<virtnet_poll>> receive_buf(rq, buf, len);
+ */
 static void receive_buf(struct receive_queue *rq, void *buf, unsigned int len)
 {
 	struct virtnet_info *vi = rq->vq->vdev->priv;
@@ -547,6 +663,10 @@ static int add_recvbuf_big(struct receive_queue *rq, gfp_t gfp)
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|614| <<try_fill_recv>> err = add_recvbuf_mergeable(rq, gfp);
+ */
 static int add_recvbuf_mergeable(struct receive_queue *rq, gfp_t gfp)
 {
 	struct page *page;
@@ -556,6 +676,10 @@ static int add_recvbuf_mergeable(struct receive_queue *rq, gfp_t gfp)
 	if (!page)
 		return -ENOMEM;
 
+	/*
+	 * struct receive_queue:
+	 *   -> struct scatterlist sg[MAX_SKB_FRAGS + 2];
+	 */
 	sg_init_one(rq->sg, page_address(page), PAGE_SIZE);
 
 	err = virtqueue_add_buf(rq->vq, rq->sg, 0, 1, page);
@@ -572,6 +696,14 @@ static int add_recvbuf_mergeable(struct receive_queue *rq, gfp_t gfp)
  * before we're receiving packets, or from refill_work which is
  * careful to disable receiving (using napi_disable).
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|676| <<refill_work>> still_empty = !try_fill_recv(rq, GFP_KERNEL);
+ *   - drivers/net/virtio_net.c|714| <<virtnet_poll>> if (!try_fill_recv(rq, GFP_ATOMIC))
+ *   - drivers/net/virtio_net.c|741| <<virtnet_open>> if (!try_fill_recv(&vi->rq[i], GFP_KERNEL))
+ *   - drivers/net/virtio_net.c|1767| <<virtnet_probe>> try_fill_recv(&vi->rq[i], GFP_KERNEL);
+ *   - drivers/net/virtio_net.c|1900| <<virtnet_restore>> if (!try_fill_recv(&vi->rq[i], GFP_KERNEL))
+ */
 static bool try_fill_recv(struct receive_queue *rq, gfp_t gfp)
 {
 	struct virtnet_info *vi = rq->vq->vdev->priv;
@@ -589,8 +721,28 @@ static bool try_fill_recv(struct receive_queue *rq, gfp_t gfp)
 		oom = err == -ENOMEM;
 		if (err < 0)
 			break;
+		/*
+		 * 在以下修改receive_queue->num:
+		 *   - drivers/net/virtio_net.c|442| <<receive_mergeable>> --rq->num;
+		 *   - drivers/net/virtio_net.c|457| <<receive_mergeable>> --rq->num;
+		 *   - drivers/net/virtio_net.c|691| <<try_fill_recv>> ++rq->num;
+		 *   - drivers/net/virtio_net.c|787| <<virtnet_poll>> --rq->num;
+		 *   - drivers/net/virtio_net.c|1570| <<free_unused_bufs>> --vi->rq[i].num;
+		 * 在以下使用receive_queue->num:
+		 *   - drivers/net/virtio_net.c|699| <<try_fill_recv>> if (unlikely(rq->num > rq->max))
+		 *   - drivers/net/virtio_net.c|700| <<try_fill_recv>> rq->max = rq->num;
+		 *   - drivers/net/virtio_net.c|797| <<virtnet_poll>> if (rq->num < rq->max / 2) {
+		 *   - drivers/net/virtio_net.c|1572| <<free_unused_bufs>> BUG_ON(vi->rq[i].num != 0);
+		 *   - drivers/net/virtio_net.c|1864| <<virtnet_probe>> if (vi->rq[i].num == 0) {
+		 */
 		++rq->num;
 	} while (err > 0);
+	/*
+	 * 使用receive_queue->max的地方:
+	 *   - drivers/net/virtio_net.c|625| <<try_fill_recv>> if (unlikely(rq->num > rq->max))
+	 *   - drivers/net/virtio_net.c|626| <<try_fill_recv>> rq->max = rq->num;
+	 *   - drivers/net/virtio_net.c|697| <<virtnet_poll>> if (rq->num < rq->max / 2) {
+	 */
 	if (unlikely(rq->num > rq->max))
 		rq->max = rq->num;
 	virtqueue_kick(rq->vq);
@@ -609,6 +761,12 @@ static void skb_recv_done(struct virtqueue *rvq)
 	}
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|745| <<refill_work>> virtnet_napi_enable(rq);
+ *   - drivers/net/virtio_net.c|811| <<virtnet_open>> virtnet_napi_enable(&vi->rq[i]);
+ *   - drivers/net/virtio_net.c|1968| <<virtnet_restore>> virtnet_napi_enable(&vi->rq[i]);
+ */
 static void virtnet_napi_enable(struct receive_queue *rq)
 {
 	napi_enable(&rq->napi);
@@ -625,6 +783,11 @@ static void virtnet_napi_enable(struct receive_queue *rq)
 	}
 }
 
+/*
+ * 在以下使用refill_work():
+ *   - drivers/net/virtio_net.c|1672| <<virtnet_alloc_queues>> INIT_DELAYED_WORK(&vi->refill, refill_work);
+ *   - drivers/net/virtio_net.c|1805| <<virtnet_probe>> INIT_DELAYED_WORK(&vi->refill, refill_work);
+ */
 static void refill_work(struct work_struct *work)
 {
 	struct virtnet_info *vi =
@@ -647,6 +810,10 @@ static void refill_work(struct work_struct *work)
 	}
 }
 
+/*
+ * 在以下使用virtnet_poll():
+ *   - drivers/net/virtio_net.c|1565| <<virtnet_alloc_queues>> netif_napi_add(vi->dev, &vi->rq[i].napi, virtnet_poll,
+ */
 static int virtnet_poll(struct napi_struct *napi, int budget)
 {
 	struct receive_queue *rq =
@@ -656,13 +823,42 @@ static int virtnet_poll(struct napi_struct *napi, int budget)
 	unsigned int r, len, received = 0;
 
 again:
+	/*
+	 * 这里有两种情况 ...
+	 * 1. received < budget
+	 * 2. received >= budget
+	 */
 	while (received < budget &&
 	       (buf = virtqueue_get_buf(rq->vq, &len)) != NULL) {
 		receive_buf(rq, buf, len);
+		/*
+		 * 在以下修改receive_queue->num:
+		 *   - drivers/net/virtio_net.c|442| <<receive_mergeable>> --rq->num;
+		 *   - drivers/net/virtio_net.c|457| <<receive_mergeable>> --rq->num;
+		 *   - drivers/net/virtio_net.c|691| <<try_fill_recv>> ++rq->num;
+		 *   - drivers/net/virtio_net.c|787| <<virtnet_poll>> --rq->num;
+		 *   - drivers/net/virtio_net.c|1570| <<free_unused_bufs>> --vi->rq[i].num;
+		 * 在以下使用receive_queue->num:
+		 *   - drivers/net/virtio_net.c|699| <<try_fill_recv>> if (unlikely(rq->num > rq->max))
+		 *   - drivers/net/virtio_net.c|700| <<try_fill_recv>> rq->max = rq->num;
+		 *   - drivers/net/virtio_net.c|797| <<virtnet_poll>> if (rq->num < rq->max / 2) {
+		 *   - drivers/net/virtio_net.c|1572| <<free_unused_bufs>> BUG_ON(vi->rq[i].num != 0);
+		 *   - drivers/net/virtio_net.c|1864| <<virtnet_probe>> if (vi->rq[i].num == 0) {
+		 *
+		 * 比如:
+		 *   num = 213,
+		 *   max = 256, 
+		 */
 		--rq->num;
 		received++;
 	}
 
+	/*
+	 * 使用receive_queue->max的地方:
+	 *   - drivers/net/virtio_net.c|625| <<try_fill_recv>> if (unlikely(rq->num > rq->max))
+	 *   - drivers/net/virtio_net.c|626| <<try_fill_recv>> rq->max = rq->num;
+	 *   - drivers/net/virtio_net.c|697| <<virtnet_poll>> if (rq->num < rq->max / 2) {
+	 */
 	if (rq->num < rq->max / 2) {
 		if (!try_fill_recv(rq, GFP_ATOMIC))
 			queue_delayed_work(vi->st_wq, &vi->refill, 0);
@@ -699,6 +895,11 @@ static int virtnet_open(struct net_device *dev)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|923| <<start_xmit>> free_old_xmit_skbs(sq);
+ *   - drivers/net/virtio_net.c|958| <<start_xmit>> capacity += free_old_xmit_skbs(sq);
+ */
 static unsigned int free_old_xmit_skbs(struct send_queue *sq)
 {
 	struct sk_buff *skb;
@@ -722,8 +923,17 @@ static unsigned int free_old_xmit_skbs(struct send_queue *sq)
 
 static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 {
+	/*
+	 * 返回共享的共享的char cb[48];
+	 */
 	struct skb_vnet_hdr *hdr = skb_vnet_hdr(skb);
 	const unsigned char *dest = ((struct ethhdr *)skb->data)->h_dest;
+	/*
+	 * struct send_queue:
+	 *  -> struct virtqueue *vq;
+	 *      -> struct virtio_device *vdev;
+	 *          -> void *priv;
+	 */
 	struct virtnet_info *vi = sq->vq->vdev->priv;
 
 	pr_debug("%s: xmit %p %pM\n", vi->dev->name, skb, dest);
@@ -758,12 +968,32 @@ static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 	hdr->mhdr.num_buffers = 0;
 
 	/* Encode metadata header at front. */
+	/*
+	 * struct skb_vnet_hdr {
+	 *     union {
+	 *         struct virtio_net_hdr hdr;
+	 *         struct virtio_net_hdr_mrg_rxbuf mhdr;
+	 *     };
+	 *     unsigned int num_sg;
+	 * };
+	 *
+	 * struct send_queue:
+	 *   -> // TX: fragments + linear part + virtio header
+	 *   -> struct scatterlist sg[MAX_SKB_FRAGS + 2];
+	 */
 	if (vi->mergeable_rx_bufs)
 		sg_set_buf(sq->sg, &hdr->mhdr, sizeof hdr->mhdr);
 	else
 		sg_set_buf(sq->sg, &hdr->hdr, sizeof hdr->hdr);
 
+	/*
+	 * !! 注意最后的+1
+	 */
 	hdr->num_sg = skb_to_sgvec(skb, sq->sg + 1, 0, skb->len) + 1;
+	/*
+	 * 输入是sq->sg[若干个]
+	 * 实际是hdr->num_sg个
+	 */
 	return virtqueue_add_buf(sq->vq, sq->sg, hdr->num_sg,
 				 0, skb);
 }
@@ -838,6 +1068,17 @@ static void virtnet_netpoll(struct net_device *dev)
  * supported by the hypervisor, as indicated by feature bits, should
  * never fail unless improperly formated.
  */
+/*
+ * called by:
+ *   - rivers/net/virtio_net.c|955| <<virtnet_set_mac_address>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,
+ *   - drivers/net/virtio_net.c|1013| <<virtnet_ack_link_announce>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_ANNOUNCE,
+ *   - drivers/net/virtio_net.c|1037| <<virtnet_set_queues>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MQ,
+ *   - drivers/net/virtio_net.c|1087| <<virtnet_set_rx_mode>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_RX,
+ *   - drivers/net/virtio_net.c|1095| <<virtnet_set_rx_mode>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_RX,
+ *   - drivers/net/virtio_net.c|1132| <<virtnet_set_rx_mode>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,
+ *   - drivers/net/virtio_net.c|1147| <<virtnet_vlan_rx_add_vid>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_VLAN,
+ *   - drivers/net/virtio_net.c|1159| <<virtnet_vlan_rx_kill_vid>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_VLAN,
+ */
 static bool virtnet_send_command(struct virtnet_info *vi, u8 class, u8 cmd,
 				 struct scatterlist *data, int out, int in)
 {
@@ -957,6 +1198,11 @@ static void virtnet_ack_link_announce(struct virtnet_info *vi)
 	rtnl_unlock();
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|1234| <<virtnet_set_channels>> err = virtnet_set_queues(vi, queue_pairs);
+ *   - drivers/net/virtio_net.c|1861| <<virtnet_restore>> virtnet_set_queues(vi, vi->curr_queue_pairs);
+ */
 static int virtnet_set_queues(struct virtnet_info *vi, u16 queue_pairs)
 {
 	struct scatterlist sg;
@@ -1362,6 +1608,11 @@ static void free_receive_bufs(struct virtnet_info *vi)
 	}
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|1860| <<virtnet_probe>> free_unused_bufs(vi);
+ *   - drivers/net/virtio_net.c|1910| <<remove_vq_common>> free_unused_bufs(vi);
+ */
 static void free_unused_bufs(struct virtnet_info *vi)
 {
 	void *buf;
@@ -1632,6 +1883,20 @@ static int virtnet_probe(struct virtio_device *vdev)
 	    || virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_ECN))
 		vi->big_packets = true;
 
+	/*
+	 * 在以下使用virtnet_info->mergeable_rx_bufs:
+	 *   - drivers/net/virtio_net.c|267| <<page_to_skb>> if (vi->mergeable_rx_bufs) {
+	 *   - drivers/net/virtio_net.c|397| <<receive_buf>> if (vi->mergeable_rx_bufs || vi->big_packets)
+	 *   - drivers/net/virtio_net.c|403| <<receive_buf>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|582| <<try_fill_recv>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|761| <<xmit_skb>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|1380| <<free_unused_bufs>> if (vi->mergeable_rx_bufs || vi->big_packets)
+	 *   - drivers/net/virtio_net.c|1636| <<virtnet_probe>> vi->mergeable_rx_bufs = true;
+	 *
+	 * 例子
+	 * # cat /sys/bus/virtio/devices/virtio1/features 
+	 * 1100011111111111111101110000110000000000000000000000000000000000
+	 */
 	if (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))
 		vi->mergeable_rx_bufs = true;
 
diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c
index a64a087b..5ab9827d 100644
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@ -47,6 +47,9 @@ static ssize_t features_show(struct device *_d,
 	len += sprintf(buf+len, "\n");
 	return len;
 }
+/*
+ * struct bus_type virtio_bus.dev_attrs = virtio_dev_attrs[]
+ */
 static struct device_attribute virtio_dev_attrs[] = {
 	__ATTR_RO(device),
 	__ATTR_RO(vendor),
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index 6de0ffae..916ab9bb 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -80,19 +80,74 @@ struct vring_virtqueue
 	bool broken;
 
 	/* Host supports indirect buffers */
+	/*
+	 * 在以下使用vring_virtqueue->indirect:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|263| <<virtqueue_add_buf>> if (vq->indirect)
+	 *   - drivers/virtio/virtio_ring.c|595| <<vring_new_virtqueue>> vq->indirect = virtio_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC);
+	 */
 	bool indirect;
 
 	/* Host publishes avail event idx */
 	bool event;
 
 	/* Number of free buffers */
+	/*
+	 * 在以下修改vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|150| <<vring_add_indirect>> vq->num_free--;
+	 *   - drivers/virtio/virtio_ring.c|227| <<virtqueue_add_buf>> vq->num_free -= out + in;
+	 *   - drivers/virtio/virtio_ring.c|346| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|352| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|603| <<vring_new_virtqueue>> vq->num_free = num;
+	 * 在以下使用vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|214| <<virtqueue_add_buf>> if (vq->num_free < out + in) {
+	 *   - drivers/virtio/virtio_ring.c|216| <<virtqueue_add_buf>> out + in, vq->num_free);
+	 *   - drivers/virtio/virtio_ring.c|264| <<virtqueue_add_buf>> return vq->num_free ? vq->vring.num : 0;
+	 *   - drivers/virtio/virtio_ring.c|265| <<virtqueue_add_buf>> return vq->num_free;
+	 *   - drivers/virtio/virtio_ring.c|532| <<virtqueue_detach_unused_buf>> BUG_ON(vq->num_free != vq->vring.num);
+	 */
 	unsigned int num_free;
 	/* Head of free buffer list. */
+	/*
+	 * 在以下修改vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|159| <<vring_add_indirect>> vq->free_head = vq->vring.desc[head].next;
+	 *   - drivers/virtio/virtio_ring.c|248| <<virtqueue_add_buf>> vq->free_head = i;
+	 *   - drivers/virtio/virtio_ring.c|350| <<detach_buf>> vq->free_head = head;
+	 *   - drivers/virtio/virtio_ring.c|604| <<vring_new_virtqueue>> vq->free_head = 0;
+	 *
+	 * 在以下使用vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|153| <<vring_add_indirect>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|229| <<virtqueue_add_buf>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|230| <<virtqueue_add_buf>> for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
+	 *   - drivers/virtio/virtio_ring.c|349| <<detach_buf>> vq->vring.desc[i].next = vq->free_head;
+	 */
 	unsigned int free_head;
 	/* Number we've added since last sync. */
+	/*
+	 * 在以下使用vring_virtqueue->num_added:
+	 *   - drivers/virtio/virtio_ring.c|373| <<virtqueue_add_buf>> avail = (vq->vring.avail->idx + vq->num_added++) % vq->vring.num;
+	 *   - drivers/virtio/virtio_ring.c|423| <<virtqueue_kick_prepare>> new = vq->vring.avail->idx = old + vq->num_added;
+	 *   - drivers/virtio/virtio_ring.c|424| <<virtqueue_kick_prepare>> vq->num_added = 0;
+	 *   - drivers/virtio/virtio_ring.c|889| <<vring_new_virtqueue>> vq->num_added = 0;
+	 */
 	unsigned int num_added;
 
 	/* Last used index we've seen. */
+	/*
+	 * 在以下修改vring_virtqueue->last_used_idx:
+	 *   - drivers/virtio/virtio_ring.c|636| <<virtqueue_get_buf>> vq->last_used_idx++;
+	 *   - drivers/virtio/virtio_ring.c|910| <<vring_new_virtqueue>> vq->last_used_idx = 0;
+	 * 在以下使用vring_virtqueue->last_used_idx:
+	 *   - drivers/virtio/virtio_ring.c|576| <<more_used>> return vq->last_used_idx != vq->vring.used->idx;
+	 *   - drivers/virtio/virtio_ring.c|621| <<virtqueue_get_buf>> i = vq->vring.used->ring[vq->last_used_idx%vq->vring.num].id;
+	 *   - drivers/virtio/virtio_ring.c|622| <<virtqueue_get_buf>> *len = vq->vring.used->ring[vq->last_used_idx%vq->vring.num].len;
+	 *   - drivers/virtio/virtio_ring.c|641| <<virtqueue_get_buf>> vring_used_event(&vq->vring) = vq->last_used_idx;
+	 *   - drivers/virtio/virtio_ring.c|726| <<virtqueue_enable_cb_prepare>> vring_used_event(&vq->vring) = last_used_idx = vq->last_used_idx;
+	 *   - drivers/virtio/virtio_ring.c|795| <<virtqueue_enable_cb_delayed>> bufs = (u16)(vq->vring.avail->idx - vq->last_used_idx) * 3 / 4;
+	 *   - drivers/virtio/virtio_ring.c|796| <<virtqueue_enable_cb_delayed>> vring_used_event(&vq->vring) = vq->last_used_idx + bufs;
+	 *   - drivers/virtio/virtio_ring.c|798| <<virtqueue_enable_cb_delayed>> if (unlikely((u16)(vq->vring.used->idx - vq->last_used_idx) > bufs)) {
+	 */
 	u16 last_used_idx;
 
 	/* How to notify other side. FIXME: commonalize hcalls! */
@@ -113,6 +168,10 @@ struct vring_virtqueue
 #define to_vvq(_vq) container_of(_vq, struct vring_virtqueue, vq)
 
 /* Set up an indirect table of descriptors and add it to the queue. */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|206| <<virtqueue_add_buf>> head = vring_add_indirect(vq, sg, out, in);
+ */
 static int vring_add_indirect(struct vring_virtqueue *vq,
 			      struct scatterlist sg[],
 			      unsigned int out,
@@ -147,6 +206,24 @@ static int vring_add_indirect(struct vring_virtqueue *vq,
 	desc[i-1].next = 0;
 
 	/* We're about to use a buffer */
+	/*
+	 * 在以下修改vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|150| <<vring_add_indirect>> vq->num_free--;
+	 *   - drivers/virtio/virtio_ring.c|227| <<virtqueue_add_buf>> vq->num_free -= out + in;
+	 *   - drivers/virtio/virtio_ring.c|346| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|352| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|603| <<vring_new_virtqueue>> vq->num_free = num;
+	 *
+	 * 在以下使用vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|214| <<virtqueue_add_buf>> if (vq->num_free < out + in) {
+	 *   - drivers/virtio/virtio_ring.c|216| <<virtqueue_add_buf>> out + in, vq->num_free);
+	 *   - drivers/virtio/virtio_ring.c|264| <<virtqueue_add_buf>> return vq->num_free ? vq->vring.num : 0;
+	 *   - drivers/virtio/virtio_ring.c|265| <<virtqueue_add_buf>> return vq->num_free;
+	 *   - drivers/virtio/virtio_ring.c|532| <<virtqueue_detach_unused_buf>> BUG_ON(vq->num_free != vq->vring.num);
+	 *
+	 * indirect的时候只需要一个entry (element):
+	 */
 	vq->num_free--;
 
 	/* Use a single buffer which doesn't continue */
@@ -156,11 +233,32 @@ static int vring_add_indirect(struct vring_virtqueue *vq,
 	vq->vring.desc[head].len = i * sizeof(struct vring_desc);
 
 	/* Update free pointer */
+	/*
+	 * 在以下修改vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|159| <<vring_add_indirect>> vq->free_head = vq->vring.desc[head].next;
+	 *   - drivers/virtio/virtio_ring.c|248| <<virtqueue_add_buf>> vq->free_head = i;
+	 *   - drivers/virtio/virtio_ring.c|350| <<detach_buf>> vq->free_head = head;
+	 *   - drivers/virtio/virtio_ring.c|604| <<vring_new_virtqueue>> vq->free_head = 0;
+	 *
+	 * 在以下使用vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|153| <<vring_add_indirect>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|229| <<virtqueue_add_buf>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|230| <<virtqueue_add_buf>> for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
+	 *   - drivers/virtio/virtio_ring.c|349| <<detach_buf>> vq->vring.desc[i].next = vq->free_head;
+	 */
 	vq->free_head = vq->vring.desc[head].next;
 
 	return head;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|192| <<vq2txq>> return (virtqueue_get_queue_index(vq) - 1) / 2;
+ *   - drivers/net/virtio_net.c|202| <<vq2rxq>> return virtqueue_get_queue_index(vq) / 2;
+ *   - drivers/scsi/virtio_scsi.c|236| <<virtscsi_req_done>> int index = virtqueue_get_queue_index(vq) - VIRTIO_SCSI_VQ_BASE;
+ *   - drivers/virtio/virtio_pci.c|187| <<vp_notify>> iowrite16(virtqueue_get_queue_index(vq),
+ *   - drivers/virtio/virtio_pci.c|456| <<vp_del_vq>> iowrite16(virtqueue_get_queue_index(vq),
+ */
 int virtqueue_get_queue_index(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -168,12 +266,34 @@ int virtqueue_get_queue_index(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_queue_index);
 
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|167| <<do_req>> if (virtqueue_add_buf(vblk->vq, vblk->sg, out, in, vbr) < 0) {
+ *   - drivers/char/hw_random/virtio-rng.c|54| <<register_buffer>> if (virtqueue_add_buf(vq, &sg, 0, 1, random_data) < 0)
+ *   - drivers/char/virtio_console.c|424| <<add_inbuf>> ret = virtqueue_add_buf(vq, sg, 0, 1, buf);
+ *   - drivers/char/virtio_console.c|491| <<__send_control_msg>> if (virtqueue_add_buf(vq, sg, 1, 0, &cpkt) >= 0) {
+ *   - drivers/char/virtio_console.c|541| <<__send_to_port>> ret = virtqueue_add_buf(out_vq, sg, nents, 0, data);
+ *   - drivers/net/virtio_net.c|513| <<add_recvbuf_small>> err = virtqueue_add_buf(rq->vq, rq->sg, 0, 2, skb);
+ *   - drivers/net/virtio_net.c|558| <<add_recvbuf_big>> err = virtqueue_add_buf(rq->vq, rq->sg, 0, MAX_SKB_FRAGS + 2,
+ *   - drivers/net/virtio_net.c|577| <<add_recvbuf_mergeable>> err = virtqueue_add_buf(rq->vq, rq->sg, 0, 1, page);
+ *   - drivers/net/virtio_net.c|792| <<xmit_skb>> return virtqueue_add_buf(sq->vq, sq->sg, hdr->num_sg,
+ *   - drivers/net/virtio_net.c|892| <<virtnet_send_command>> BUG_ON(virtqueue_add_buf(vi->cvq, sg, out, in, vi) < 0);
+ *   - drivers/scsi/virtio_scsi.c|316| <<virtscsi_kick_event>> ret = virtqueue_add_buf(vscsi->event_vq.vq, &sg, 0, 1, event_node);
+ *   - drivers/scsi/virtio_scsi.c|505| <<virtscsi_kick_cmd>> ret = virtqueue_add_buf(vq->vq, tgt->sg, out_num, in_num, cmd);
+ *   - drivers/virtio/virtio_balloon.c|109| <<tell_host>> if (virtqueue_add_buf(vq, &sg, 1, 0, vb) < 0)
+ *   - drivers/virtio/virtio_balloon.c|254| <<stats_handle_request>> if (virtqueue_add_buf(vq, &sg, 1, 0, vb) < 0)
+ *   - drivers/virtio/virtio_balloon.c|339| <<init_vqs>> if (virtqueue_add_buf(vb->stats_vq,
+ *   - net/9p/trans_virtio.c|203| <<p9_virtio_request>> if (virtqueue_add_buf(chan->vq, chan->sg, out, in, req->tc) < 0) {
+ */
 int virtqueue_add_buf(struct virtqueue *_vq,
 		  struct scatterlist sg[],
 		  unsigned int out,
 		  unsigned int in,
 		  void *data)
 {
+	/*
+	 * struct vring_virtqueue包含virtqueue
+	 */
 	struct vring_virtqueue *vq = to_vvq(_vq);
 	unsigned int i, avail, head, uninitialized_var(prev);
 
@@ -183,7 +303,16 @@ int virtqueue_add_buf(struct virtqueue *_vq,
 
 	/* If the host supports indirect descriptor tables, and we have multiple
 	 * buffers, then go indirect. FIXME: tune this threshold */
+	/*
+	 * 在以下使用vring_virtqueue->indirect:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|263| <<virtqueue_add_buf>> if (vq->indirect)
+	 *   - drivers/virtio/virtio_ring.c|595| <<vring_new_virtqueue>> vq->indirect = virtio_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC);
+	 */
 	if (vq->indirect && (out + in) > 1 && vq->num_free) {
+		/*
+		 * 只在这里被调用
+		 */
 		head = vring_add_indirect(vq, sg, out, in);
 		if (head != vq->vring.num)
 			goto add_head;
@@ -192,6 +321,21 @@ int virtqueue_add_buf(struct virtqueue *_vq,
 	BUG_ON(out + in > vq->vring.num);
 	BUG_ON(out + in == 0);
 
+	/*
+	 * 在以下修改vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|150| <<vring_add_indirect>> vq->num_free--;
+	 *   - drivers/virtio/virtio_ring.c|227| <<virtqueue_add_buf>> vq->num_free -= out + in;
+	 *   - drivers/virtio/virtio_ring.c|346| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|352| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|603| <<vring_new_virtqueue>> vq->num_free = num;
+	 * 在以下使用vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|214| <<virtqueue_add_buf>> if (vq->num_free < out + in) {
+	 *   - drivers/virtio/virtio_ring.c|216| <<virtqueue_add_buf>> out + in, vq->num_free);
+	 *   - drivers/virtio/virtio_ring.c|264| <<virtqueue_add_buf>> return vq->num_free ? vq->vring.num : 0;
+	 *   - drivers/virtio/virtio_ring.c|265| <<virtqueue_add_buf>> return vq->num_free;
+	 *   - drivers/virtio/virtio_ring.c|532| <<virtqueue_detach_unused_buf>> BUG_ON(vq->num_free != vq->vring.num);
+	 */
 	if (vq->num_free < out + in) {
 		pr_debug("Can't add buf len %i - avail = %i\n",
 			 out + in, vq->num_free);
@@ -205,8 +349,36 @@ int virtqueue_add_buf(struct virtqueue *_vq,
 	}
 
 	/* We're about to use some buffers from the free list. */
+	/*
+	 * 在以下修改vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|150| <<vring_add_indirect>> vq->num_free--;
+	 *   - drivers/virtio/virtio_ring.c|227| <<virtqueue_add_buf>> vq->num_free -= out + in;
+	 *   - drivers/virtio/virtio_ring.c|346| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|352| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|603| <<vring_new_virtqueue>> vq->num_free = num;
+	 * 在以下使用vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|214| <<virtqueue_add_buf>> if (vq->num_free < out + in) {
+	 *   - drivers/virtio/virtio_ring.c|216| <<virtqueue_add_buf>> out + in, vq->num_free);
+	 *   - drivers/virtio/virtio_ring.c|264| <<virtqueue_add_buf>> return vq->num_free ? vq->vring.num : 0;
+	 *   - drivers/virtio/virtio_ring.c|265| <<virtqueue_add_buf>> return vq->num_free;
+	 *   - drivers/virtio/virtio_ring.c|532| <<virtqueue_detach_unused_buf>> BUG_ON(vq->num_free != vq->vring.num);
+	 */
 	vq->num_free -= out + in;
 
+	/*
+	 * 在以下修改vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|159| <<vring_add_indirect>> vq->free_head = vq->vring.desc[head].next;
+	 *   - drivers/virtio/virtio_ring.c|248| <<virtqueue_add_buf>> vq->free_head = i;
+	 *   - drivers/virtio/virtio_ring.c|350| <<detach_buf>> vq->free_head = head;
+	 *   - drivers/virtio/virtio_ring.c|604| <<vring_new_virtqueue>> vq->free_head = 0;
+	 *
+	 * 在以下使用vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|153| <<vring_add_indirect>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|229| <<virtqueue_add_buf>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|230| <<virtqueue_add_buf>> for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
+	 *   - drivers/virtio/virtio_ring.c|349| <<detach_buf>> vq->vring.desc[i].next = vq->free_head;
+	 */
 	head = vq->free_head;
 	for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
 		vq->vring.desc[i].flags = VRING_DESC_F_NEXT;
@@ -234,6 +406,21 @@ add_head:
 
 	/* Put entry in available array (but don't update avail->idx until they
 	 * do sync).  FIXME: avoid modulus here? */
+	/*
+	 * struct vring_virtqueue *vq:
+	 *  -> struct virtqueue vq;
+	 *  -> struct vring vring;
+	 *      -> unsigned int num;
+	 *      -> struct vring_desc *desc;
+	 *      -> struct vring_avail *avail;
+	 *	    -> __u16 flags;
+	 *	    -> __u16 idx;
+	 *	    -> __u16 ring[];
+	 *      -> struct vring_used *used;
+	 *	    -> __u16 flags;
+	 *	    -> __u16 idx;
+	 *	    -> struct vring_used_elem ring[];
+	 */
 	avail = (vq->vring.avail->idx + vq->num_added++) % vq->vring.num;
 	vq->vring.avail->ring[avail] = head;
 
@@ -241,12 +428,37 @@ add_head:
 	END_USE(vq);
 
 	/* If we're indirect, we can fit many (assuming not OOM). */
+	/*
+	 * indirect的话一个entry可以放入好多的entry, 所以有一个就行
+	 */
 	if (vq->indirect)
 		return vq->num_free ? vq->vring.num : 0;
+	/*
+	 * 在以下修改vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|150| <<vring_add_indirect>> vq->num_free--;
+	 *   - drivers/virtio/virtio_ring.c|227| <<virtqueue_add_buf>> vq->num_free -= out + in;
+	 *   - drivers/virtio/virtio_ring.c|346| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|352| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|603| <<vring_new_virtqueue>> vq->num_free = num;
+	 * 在以下使用vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|214| <<virtqueue_add_buf>> if (vq->num_free < out + in) {
+	 *   - drivers/virtio/virtio_ring.c|216| <<virtqueue_add_buf>> out + in, vq->num_free);
+	 *   - drivers/virtio/virtio_ring.c|264| <<virtqueue_add_buf>> return vq->num_free ? vq->vring.num : 0;
+	 *   - drivers/virtio/virtio_ring.c|265| <<virtqueue_add_buf>> return vq->num_free;
+	 *   - drivers/virtio/virtio_ring.c|532| <<virtqueue_detach_unused_buf>> BUG_ON(vq->num_free != vq->vring.num);
+	 */
 	return vq->num_free;
 }
 EXPORT_SYMBOL_GPL(virtqueue_add_buf);
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|508| <<virtscsi_kick_cmd>> ret = virtqueue_kick_prepare(vq->vq);
+ *   - drivers/virtio/virtio_ring.c|452| <<virtqueue_kick>> if (virtqueue_kick_prepare(vq))
+ *
+ * 当vq->event的时候不被VRING_USED_F_NO_NOTIFY影响
+ */
 bool virtqueue_kick_prepare(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -265,7 +477,18 @@ bool virtqueue_kick_prepare(struct virtqueue *_vq)
 	/* Need to update avail index before checking if we should notify */
 	virtio_mb();
 
+	/*
+	 * VIRTIO_RING_F_EVENT_IDX:
+	 *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+	 *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+	 *
+	 * vring_avail_event():
+	 *   返回used的最后一个元素, 告诉前端驱动后端处理到哪个avail ring上的元素了
+	 */
 	if (vq->event) {
+		/*
+		 * 相当于当event_idx + 1 > old的时候返回true
+		 */
 		needs_kick = vring_need_event(vring_avail_event(&vq->vring),
 					      new, old);
 	} else {
@@ -282,6 +505,11 @@ EXPORT_SYMBOL_GPL(virtqueue_kick_prepare);
  *
  * This does not need to be serialized.
  */
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|513| <<virtscsi_kick_cmd>> virtqueue_notify(vq->vq);
+ *   - drivers/virtio/virtio_ring.c|453| <<virtqueue_kick>> virtqueue_notify(vq);
+ */
 void virtqueue_notify(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -301,6 +529,22 @@ EXPORT_SYMBOL_GPL(virtqueue_notify);
  * Caller must ensure we don't call this with other virtqueue
  * operations at the same time (except where noted).
  */
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|195| <<do_virtblk_request>> virtqueue_kick(vblk->vq);
+ *   - drivers/char/hw_random/virtio-rng.c|57| <<register_buffer>> virtqueue_kick(vq);
+ *   - drivers/char/virtio_console.c|425| <<add_inbuf>> virtqueue_kick(vq);
+ *   - drivers/char/virtio_console.c|492| <<__send_control_msg>> virtqueue_kick(vq);
+ *   - drivers/char/virtio_console.c|544| <<__send_to_port>> virtqueue_kick(out_vq);
+ *   - drivers/net/virtio_net.c|701| <<try_fill_recv>> virtqueue_kick(rq->vq);
+ *   - drivers/net/virtio_net.c|951| <<start_xmit>> virtqueue_kick(sq->vq);
+ *   - drivers/net/virtio_net.c|1029| <<virtnet_send_command>> virtqueue_kick(vi->cvq);
+ *   - drivers/scsi/virtio_scsi.c|318| <<virtscsi_kick_event>> virtqueue_kick(vscsi->event_vq.vq);
+ *   - drivers/virtio/virtio_balloon.c|111| <<tell_host>> virtqueue_kick(vq);
+ *   - drivers/virtio/virtio_balloon.c|256| <<stats_handle_request>> virtqueue_kick(vq);
+ *   - drivers/virtio/virtio_balloon.c|342| <<init_vqs>> virtqueue_kick(vb->stats_vq);
+ *   - net/9p/trans_virtio.c|209| <<p9_virtio_request>> virtqueue_kick(chan->vq);
+ */
 void virtqueue_kick(struct virtqueue *vq)
 {
 	if (virtqueue_kick_prepare(vq))
@@ -308,6 +552,11 @@ void virtqueue_kick(struct virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_kick);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|523| <<virtqueue_get_buf>> detach_buf(vq, i);
+ *   - drivers/virtio/virtio_ring.c|653| <<virtqueue_detach_unused_buf>> detach_buf(vq, i);
+ */
 static void detach_buf(struct vring_virtqueue *vq, unsigned int head)
 {
 	unsigned int i;
@@ -322,22 +571,78 @@ static void detach_buf(struct vring_virtqueue *vq, unsigned int head)
 	if (vq->vring.desc[i].flags & VRING_DESC_F_INDIRECT)
 		kfree(phys_to_virt(vq->vring.desc[i].addr));
 
+	/*
+	 * centos上rx的flags都是2
+	 */
 	while (vq->vring.desc[i].flags & VRING_DESC_F_NEXT) {
 		i = vq->vring.desc[i].next;
 		vq->num_free++;
 	}
 
 	vq->vring.desc[i].next = vq->free_head;
+	/*
+	 * 在以下修改vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|159| <<vring_add_indirect>> vq->free_head = vq->vring.desc[head].next;
+	 *   - drivers/virtio/virtio_ring.c|248| <<virtqueue_add_buf>> vq->free_head = i;
+	 *   - drivers/virtio/virtio_ring.c|350| <<detach_buf>> vq->free_head = head;
+	 *   - drivers/virtio/virtio_ring.c|604| <<vring_new_virtqueue>> vq->free_head = 0;
+	 *
+	 * 在以下使用vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|153| <<vring_add_indirect>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|229| <<virtqueue_add_buf>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|230| <<virtqueue_add_buf>> for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
+	 *   - drivers/virtio/virtio_ring.c|349| <<detach_buf>> vq->vring.desc[i].next = vq->free_head;
+	 */
 	vq->free_head = head;
 	/* Plus final descriptor */
+	/*
+	 * 在以下修改vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|150| <<vring_add_indirect>> vq->num_free--;
+	 *   - drivers/virtio/virtio_ring.c|227| <<virtqueue_add_buf>> vq->num_free -= out + in;
+	 *   - drivers/virtio/virtio_ring.c|346| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|352| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|603| <<vring_new_virtqueue>> vq->num_free = num;
+	 * 在以下使用vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|214| <<virtqueue_add_buf>> if (vq->num_free < out + in) {
+	 *   - drivers/virtio/virtio_ring.c|216| <<virtqueue_add_buf>> out + in, vq->num_free);
+	 *   - drivers/virtio/virtio_ring.c|264| <<virtqueue_add_buf>> return vq->num_free ? vq->vring.num : 0;
+	 *   - drivers/virtio/virtio_ring.c|265| <<virtqueue_add_buf>> return vq->num_free;
+	 *   - drivers/virtio/virtio_ring.c|532| <<virtqueue_detach_unused_buf>> BUG_ON(vq->num_free != vq->vring.num);
+	 */
 	vq->num_free++;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|579| <<virtqueue_get_buf>> if (!more_used(vq)) {
+ *   - drivers/virtio/virtio_ring.c|806| <<vring_interrupt>> if (!more_used(vq)) {
+ */
 static inline bool more_used(const struct vring_virtqueue *vq)
 {
 	return vq->last_used_idx != vq->vring.used->idx;
 }
 
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|65| <<blk_done>> while ((vbr = virtqueue_get_buf(vblk->vq, &len)) != NULL) {
+ *   - drivers/char/hw_random/virtio-rng.c|41| <<random_recv_done>> if (!virtqueue_get_buf(vq, &len))
+ *   - drivers/char/virtio_console.c|402| <<get_inbuf>> buf = virtqueue_get_buf(port->in_vq, &len);
+ *   - drivers/char/virtio_console.c|493| <<__send_control_msg>> while (!virtqueue_get_buf(vq, &len))
+ *   - drivers/char/virtio_console.c|520| <<reclaim_consumed_buffers>> while ((buf = virtqueue_get_buf(port->out_vq, &len))) {
+ *   - drivers/char/virtio_console.c|566| <<__send_to_port>> while (!virtqueue_get_buf(out_vq, &len))
+ *   - drivers/char/virtio_console.c|1647| <<control_work_handler>> while ((buf = virtqueue_get_buf(vq, &len))) {
+ *   - drivers/char/virtio_console.c|1854| <<remove_controlq_data>> while ((buf = virtqueue_get_buf(portdev->c_ivq, &len)))
+ *   - drivers/net/virtio_net.c|381| <<receive_mergeable>> page = virtqueue_get_buf(rq->vq, &len);
+ *   - drivers/net/virtio_net.c|400| <<receive_mergeable>> buf = virtqueue_get_buf(rq->vq, &len);
+ *   - drivers/net/virtio_net.c|691| <<virtnet_poll>> (buf = virtqueue_get_buf(rq->vq, &len)) != NULL) {
+ *   - drivers/net/virtio_net.c|740| <<free_old_xmit_skbs>> while ((skb = virtqueue_get_buf(sq->vq, &len)) != NULL) {
+ *   - drivers/net/virtio_net.c|946| <<virtnet_send_command>> while (!virtqueue_get_buf(vi->cvq, &tmp))
+ *   - drivers/scsi/virtio_scsi.c|226| <<virtscsi_vq_done>> while ((buf = virtqueue_get_buf(vq, &len)) != NULL)
+ *   - drivers/virtio/virtio_balloon.c|95| <<balloon_ack>> vb = virtqueue_get_buf(vq, &len);
+ *   - drivers/virtio/virtio_balloon.c|237| <<stats_request>> vb = virtqueue_get_buf(vq, &len);
+ *   - net/9p/trans_virtio.c|131| <<req_done>> while ((rc = virtqueue_get_buf(chan->vq, &len)) != NULL) {
+ */
 void *virtqueue_get_buf(struct virtqueue *_vq, unsigned int *len)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -375,6 +680,20 @@ void *virtqueue_get_buf(struct virtqueue *_vq, unsigned int *len)
 	/* detach_buf clears data, so grab it now. */
 	ret = vq->data[i];
 	detach_buf(vq, i);
+	/*
+	 * 在以下修改vring_virtqueue->last_used_idx:
+	 *   - drivers/virtio/virtio_ring.c|636| <<virtqueue_get_buf>> vq->last_used_idx++;
+	 *   - drivers/virtio/virtio_ring.c|910| <<vring_new_virtqueue>> vq->last_used_idx = 0;
+	 * 在以下使用vring_virtqueue->last_used_idx:
+	 *   - drivers/virtio/virtio_ring.c|576| <<more_used>> return vq->last_used_idx != vq->vring.used->idx;
+	 *   - drivers/virtio/virtio_ring.c|621| <<virtqueue_get_buf>> i = vq->vring.used->ring[vq->last_used_idx%vq->vring.num].id;
+	 *   - drivers/virtio/virtio_ring.c|622| <<virtqueue_get_buf>> *len = vq->vring.used->ring[vq->last_used_idx%vq->vring.num].len;
+	 *   - drivers/virtio/virtio_ring.c|641| <<virtqueue_get_buf>> vring_used_event(&vq->vring) = vq->last_used_idx;
+	 *   - drivers/virtio/virtio_ring.c|726| <<virtqueue_enable_cb_prepare>> vring_used_event(&vq->vring) = last_used_idx = vq->last_used_idx;
+	 *   - drivers/virtio/virtio_ring.c|795| <<virtqueue_enable_cb_delayed>> bufs = (u16)(vq->vring.avail->idx - vq->last_used_idx) * 3 / 4;
+	 *   - drivers/virtio/virtio_ring.c|796| <<virtqueue_enable_cb_delayed>> vring_used_event(&vq->vring) = vq->last_used_idx + bufs;
+	 *   - drivers/virtio/virtio_ring.c|798| <<virtqueue_enable_cb_delayed>> if (unlikely((u16)(vq->vring.used->idx - vq->last_used_idx) > bufs)) {
+	 */
 	vq->last_used_idx++;
 	/* If we expect an interrupt for the next entry, tell host
 	 * by writing event index and flush out the write before
@@ -389,10 +708,35 @@ void *virtqueue_get_buf(struct virtqueue *_vq, unsigned int *len)
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_buf);
 
+/*
+ * called by:
+ *   - drivers/char/virtio_console.c|2021| <<virtcons_freeze>> virtqueue_disable_cb(portdev->c_ivq);
+ *   - drivers/char/virtio_console.c|2027| <<virtcons_freeze>> virtqueue_disable_cb(portdev->c_ivq);
+ *   - drivers/char/virtio_console.c|2031| <<virtcons_freeze>> virtqueue_disable_cb(port->in_vq);
+ *   - drivers/char/virtio_console.c|2032| <<virtcons_freeze>> virtqueue_disable_cb(port->out_vq);
+ *   - drivers/net/virtio_net.c|281| <<skb_xmit_done>> virtqueue_disable_cb(vq);
+ *   - drivers/net/virtio_net.c|712| <<skb_recv_done>> virtqueue_disable_cb(rvq);
+ *   - drivers/net/virtio_net.c|726| <<virtnet_napi_enable>> virtqueue_disable_cb(rq->vq);
+ *   - drivers/net/virtio_net.c|792| <<virtnet_poll>> virtqueue_disable_cb(rq->vq);
+ *   - drivers/net/virtio_net.c|961| <<start_xmit>> virtqueue_disable_cb(sq->vq);
+ *   - drivers/net/virtio_net.c|1934| <<virtnet_freeze>> virtqueue_disable_cb(vi->cvq);
+ *   - drivers/scsi/virtio_scsi.c|225| <<virtscsi_vq_done>> virtqueue_disable_cb(vq);
+ */
 void virtqueue_disable_cb(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
 
+	/*
+	 * 在以下使用VRING_AVAIL_F_NO_INTERRUPT:
+	 *   - drivers/vhost/vhost.c|1467| <<vhost_notify>> return !(flags & VRING_AVAIL_F_NO_INTERRUPT);
+	 *   - drivers/virtio/virtio_ring.c|528| <<virtqueue_get_buf>> if (!(vq->vring.avail->flags & VRING_AVAIL_F_NO_INTERRUPT)) {
+	 *   - drivers/virtio/virtio_ring.c|542| <<virtqueue_disable_cb>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|570| <<virtqueue_enable_cb_prepare>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|625| <<virtqueue_enable_cb_delayed>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|739| <<vring_new_virtqueue>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+	 *
+	 * vhost有VIRTIO_RING_F_EVENT_IDX就不会依赖VRING_AVAIL_F_NO_INTERRUPT
+	 */
 	vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
 }
 EXPORT_SYMBOL_GPL(virtqueue_disable_cb);
@@ -409,6 +753,11 @@ EXPORT_SYMBOL_GPL(virtqueue_disable_cb);
  * Caller must ensure we don't call this with other virtqueue
  * operations at the same time (except where noted).
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|788| <<virtnet_poll>> r = virtqueue_enable_cb_prepare(rq->vq);
+ *   - drivers/virtio/virtio_ring.c|689| <<virtqueue_enable_cb>> unsigned last_used_idx = virtqueue_enable_cb_prepare(_vq);
+ */
 unsigned virtqueue_enable_cb_prepare(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -421,7 +770,22 @@ unsigned virtqueue_enable_cb_prepare(struct virtqueue *_vq)
 	/* Depending on the VIRTIO_RING_F_EVENT_IDX feature, we need to
 	 * either clear the flags bit or point the event index at the next
 	 * entry. Always do both to keep code simple. */
+	/*
+	 * 在以下使用VRING_AVAIL_F_NO_INTERRUPT:
+	 *   - drivers/vhost/vhost.c|1467| <<vhost_notify>> return !(flags & VRING_AVAIL_F_NO_INTERRUPT);
+	 *   - drivers/virtio/virtio_ring.c|528| <<virtqueue_get_buf>> if (!(vq->vring.avail->flags & VRING_AVAIL_F_NO_INTERRUPT)) {
+	 *   - drivers/virtio/virtio_ring.c|542| <<virtqueue_disable_cb>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|570| <<virtqueue_enable_cb_prepare>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|625| <<virtqueue_enable_cb_delayed>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|739| <<vring_new_virtqueue>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+	 */
 	vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	/*
+	 * called by:
+	 *   - drivers/virtio/virtio_ring.c|529| <<virtqueue_get_buf>> vring_used_event(&vq->vring) = vq->last_used_idx;
+	 *   - drivers/virtio/virtio_ring.c|571| <<virtqueue_enable_cb_prepare>> vring_used_event(&vq->vring) = last_used_idx = vq->last_used_idx;
+	 *   - drivers/virtio/virtio_ring.c|628| <<virtqueue_enable_cb_delayed>> vring_used_event(&vq->vring) = vq->last_used_idx + bufs;
+	 */
 	vring_used_event(&vq->vring) = last_used_idx = vq->last_used_idx;
 	END_USE(vq);
 	return last_used_idx;
@@ -437,6 +801,11 @@ EXPORT_SYMBOL_GPL(virtqueue_enable_cb_prepare);
  *
  * This does not need to be serialized.
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|790| <<virtnet_poll>> if (unlikely(virtqueue_poll(rq->vq, r)) &&
+ *   - drivers/virtio/virtio_ring.c|662| <<virtqueue_enable_cb>> return !virtqueue_poll(_vq, last_used_idx);
+ */
 bool virtqueue_poll(struct virtqueue *_vq, unsigned last_used_idx)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -457,6 +826,10 @@ EXPORT_SYMBOL_GPL(virtqueue_poll);
  * Caller must ensure we don't call this with other virtqueue
  * operations at the same time (except where noted).
  */
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|228| <<virtscsi_vq_done>> } while (!virtqueue_enable_cb(vq));
+ */
 bool virtqueue_enable_cb(struct virtqueue *_vq)
 {
 	unsigned last_used_idx = virtqueue_enable_cb_prepare(_vq);
@@ -464,6 +837,10 @@ bool virtqueue_enable_cb(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_enable_cb);
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|961| <<start_xmit>> if (unlikely(!virtqueue_enable_cb_delayed(sq->vq))) {
+ */
 bool virtqueue_enable_cb_delayed(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -491,6 +868,15 @@ bool virtqueue_enable_cb_delayed(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_enable_cb_delayed);
 
+/*
+ * called by:
+ *   - drivers/char/virtio_console.c|1402| <<add_port>> while ((buf = virtqueue_detach_unused_buf(port->in_vq)))
+ *   - drivers/char/virtio_console.c|1435| <<remove_port_data>> while ((buf = virtqueue_detach_unused_buf(port->in_vq)))
+ *   - drivers/char/virtio_console.c|1443| <<remove_port_data>> while ((buf = virtqueue_detach_unused_buf(port->out_vq)))
+ *   - drivers/char/virtio_console.c|1857| <<remove_controlq_data>> while ((buf = virtqueue_detach_unused_buf(portdev->c_ivq)))
+ *   - drivers/net/virtio_net.c|1537| <<free_unused_bufs>> while ((buf = virtqueue_detach_unused_buf(vq)) != NULL)
+ *   - drivers/net/virtio_net.c|1544| <<free_unused_bufs>> while ((buf = virtqueue_detach_unused_buf(vq)) != NULL) {
+ */
 void *virtqueue_detach_unused_buf(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -517,6 +903,13 @@ void *virtqueue_detach_unused_buf(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_detach_unused_buf);
 
+/*
+ * called by:
+ *   - drivers/lguest/lguest_device.c|306| <<lg_find_vq>> err = request_irq(lvq->config.irq, vring_interrupt, IRQF_SHARED,
+ *   - drivers/s390/kvm/kvm_virtio.c|358| <<kvm_extint_handler>> vring_interrupt(0, vq);
+ *   - drivers/virtio/virtio_pci.c|210| <<vp_vring_interrupt>> if (vring_interrupt(irq, info->vq) == IRQ_HANDLED)
+ *   - drivers/virtio/virtio_pci.c|553| <<vp_try_to_find_vqs>> vring_interrupt, 0,
+ */
 irqreturn_t vring_interrupt(int irq, void *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -537,6 +930,12 @@ irqreturn_t vring_interrupt(int irq, void *_vq)
 }
 EXPORT_SYMBOL_GPL(vring_interrupt);
 
+/*
+ * called by:
+ *   - drivers/lguest/lguest_device.c|288| <<lg_find_vq>> vq = vring_new_virtqueue(index, lvq->config.num, LGUEST_VRING_ALIGN, vdev,
+ *   - drivers/s390/kvm/kvm_virtio.c|196| <<kvm_find_vq>> vq = vring_new_virtqueue(index, config->num, KVM_S390_VIRTIO_RING_ALIGN,
+ *   - drivers/virtio/virtio_pci.c|411| <<setup_vq>> vq = vring_new_virtqueue(index, info->num, VIRTIO_PCI_VRING_ALIGN, vdev,
+ */
 struct virtqueue *vring_new_virtqueue(unsigned int index,
 				      unsigned int num,
 				      unsigned int vring_align,
@@ -559,6 +958,12 @@ struct virtqueue *vring_new_virtqueue(unsigned int index,
 	if (!vq)
 		return NULL;
 
+	/*
+	 * vring_align是VIRTIO_PCI_VRING_ALIGN:
+	 *   - drivers/virtio/virtio_pci.c|399| <<setup_vq>> size = PAGE_ALIGN(vring_size(num, VIRTIO_PCI_VRING_ALIGN));
+	 *   - drivers/virtio/virtio_pci.c|411| <<setup_vq>> vq = vring_new_virtqueue(index, info->num, VIRTIO_PCI_VRING_ALIGN, vdev,
+	 *   - drivers/virtio/virtio_pci.c|471| <<vp_del_vq>> size = PAGE_ALIGN(vring_size(info->num, VIRTIO_PCI_VRING_ALIGN));
+	 */
 	vring_init(&vq->vring, num, pages, vring_align);
 	vq->vq.callback = callback;
 	vq->vq.vdev = vdev;
@@ -577,6 +982,15 @@ struct virtqueue *vring_new_virtqueue(unsigned int index,
 	vq->event = virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);
 
 	/* No callback?  Tell other side not to bother us. */
+	/*
+	 * 在以下使用VRING_AVAIL_F_NO_INTERRUPT:
+	 *   - drivers/vhost/vhost.c|1467| <<vhost_notify>> return !(flags & VRING_AVAIL_F_NO_INTERRUPT);
+	 *   - drivers/virtio/virtio_ring.c|528| <<virtqueue_get_buf>> if (!(vq->vring.avail->flags & VRING_AVAIL_F_NO_INTERRUPT)) {
+	 *   - drivers/virtio/virtio_ring.c|542| <<virtqueue_disable_cb>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|570| <<virtqueue_enable_cb_prepare>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|625| <<virtqueue_enable_cb_delayed>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|739| <<vring_new_virtqueue>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+	 */
 	if (!callback)
 		vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
 
@@ -593,6 +1007,14 @@ struct virtqueue *vring_new_virtqueue(unsigned int index,
 }
 EXPORT_SYMBOL_GPL(vring_new_virtqueue);
 
+/*
+ * called by:
+ *   - drivers/lguest/lguest_device.c|319| <<lg_find_vq>> vring_del_virtqueue(vq);
+ *   - drivers/lguest/lguest_device.c|336| <<lg_del_vq>> vring_del_virtqueue(vq);
+ *   - drivers/s390/kvm/kvm_virtio.c|224| <<kvm_del_vq>> vring_del_virtqueue(vq);
+ *   - drivers/virtio/virtio_pci.c|437| <<setup_vq>> vring_del_virtqueue(vq);
+ *   - drivers/virtio/virtio_pci.c|466| <<vp_del_vq>> vring_del_virtqueue(vq);
+ */
 void vring_del_virtqueue(struct virtqueue *vq)
 {
 	list_del(&vq->list);
@@ -601,6 +1023,12 @@ void vring_del_virtqueue(struct virtqueue *vq)
 EXPORT_SYMBOL_GPL(vring_del_virtqueue);
 
 /* Manipulates transport-specific feature bits. */
+/*
+ * called by:
+ *   - drivers/lguest/lguest_device.c|124| <<lg_finalize_features>> vring_transport_features(vdev);
+ *   - drivers/s390/kvm/kvm_virtio.c|99| <<kvm_finalize_features>> vring_transport_features(vdev);
+ *   - drivers/virtio/virtio_pci.c|122| <<vp_finalize_features>> vring_transport_features(vdev);
+ */
 void vring_transport_features(struct virtio_device *vdev)
 {
 	unsigned int i;
diff --git a/include/linux/irq.h b/include/linux/irq.h
index 621fd755..15d21204 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -50,8 +50,62 @@ typedef	void (*irq_flow_handler_t)(unsigned int irq,
 #define IRQ_TYPE_PROBE		0x00000010	/* Probing in progress */
 
 /* Internal flags */
+/*
+ * x86下修改IRQ_INPROGRESS的地方:
+ *   - arch/x86/kernel/visws_quirks.c|461| <<startup_cobalt_irq>> desc->status &= ~(IRQ_DISABLED | IRQ_INPROGRESS | IRQ_WAITING);
+ *   - kernel/irq/chip.c|394| <<handle_nested_irq>> desc->status |= IRQ_INPROGRESS;
+ *   - kernel/irq/chip.c|402| <<handle_nested_irq>> desc->status &= ~IRQ_INPROGRESS;
+ *   - kernel/irq/chip.c|438| <<handle_simple_irq>> desc->status |= IRQ_INPROGRESS;
+ *   - kernel/irq/chip.c|446| <<handle_simple_irq>> desc->status &= ~IRQ_INPROGRESS;
+ *   - kernel/irq/chip.c|483| <<handle_level_irq>> desc->status |= IRQ_INPROGRESS;
+ *   - kernel/irq/chip.c|491| <<handle_level_irq>> desc->status &= ~IRQ_INPROGRESS;
+ *   - kernel/irq/chip.c|538| <<handle_fasteoi_irq>> desc->status |= IRQ_INPROGRESS;
+ *   - kernel/irq/chip.c|547| <<handle_fasteoi_irq>> desc->status &= ~IRQ_INPROGRESS;
+ *   - kernel/irq/chip.c|595| <<handle_edge_irq>> desc->status |= IRQ_INPROGRESS;
+ *   - kernel/irq/chip.c|627| <<handle_edge_irq>> desc->status &= ~IRQ_INPROGRESS;
+ *   - kernel/irq/handle.c|494| <<__do_IRQ>> status |= IRQ_INPROGRESS;
+ *   - kernel/irq/handle.c|531| <<__do_IRQ>> desc->status &= ~IRQ_INPROGRESS;
+ *   - kernel/irq/manage.c|836| <<__setup_irq>> IRQ_INPROGRESS | IRQ_SPURIOUS_DISABLED);
+ *   - kernel/irq/spurious.c|44| <<try_one_irq>> desc->status |= IRQ_INPROGRESS;
+ *   - kernel/irq/spurious.c|76| <<try_one_irq>> desc->status &= ~IRQ_INPROGRESS;
+ * x86下使用IRQ_INPROGRESS的地方:
+ *   - arch/x86/kernel/visws_quirks.c|460| <<startup_cobalt_irq>> if ((desc->status & (IRQ_DISABLED | IRQ_INPROGRESS | IRQ_WAITING)))
+ *   - arch/x86/kernel/visws_quirks.c|483| <<end_cobalt_irq>> if (!(desc->status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+ *   - kernel/irq/chip.c|429| <<handle_simple_irq>> if (unlikely(desc->status & IRQ_INPROGRESS))
+ *   - kernel/irq/chip.c|470| <<handle_level_irq>> if (unlikely(desc->status & IRQ_INPROGRESS))
+ *   - kernel/irq/chip.c|520| <<handle_fasteoi_irq>> if (unlikely(desc->status & IRQ_INPROGRESS))
+ *   - kernel/irq/chip.c|582| <<handle_edge_irq>> if (unlikely((desc->status & (IRQ_INPROGRESS | IRQ_DISABLED)) ||
+ *   - kernel/irq/handle.c|491| <<__do_IRQ>> if (likely(!(status & (IRQ_DISABLED | IRQ_INPROGRESS)))) {
+ *   - kernel/irq/internals.h|82| <<print_irq_desc>> P(IRQ_INPROGRESS);
+ *   - kernel/irq/manage.c|45| <<synchronize_irq>> while (desc->status & IRQ_INPROGRESS)
+ *   - kernel/irq/manage.c|54| <<synchronize_irq>> } while (status & IRQ_INPROGRESS);
+ *   - kernel/irq/spurious.c|33| <<try_one_irq>> if (desc->status & IRQ_INPROGRESS) {
+ */
 #define IRQ_INPROGRESS		0x00000100	/* IRQ handler active - do not enter! */
 #define IRQ_DISABLED		0x00000200	/* IRQ disabled - do not enter! */
+/*
+ * x86在以下使用IRQ_PENDING:
+ *   - kernel/irq/autoprobe.c|80| <<probe_irq_on>> desc->status |= IRQ_PENDING;
+ *   - kernel/irq/chip.c|532| <<handle_fasteoi_irq>> desc->status |= IRQ_PENDING;
+ *   - kernel/irq/chip.c|539| <<handle_fasteoi_irq>> desc->status &= ~IRQ_PENDING;
+ *   - kernel/irq/chip.c|584| <<handle_edge_irq>> desc->status |= (IRQ_PENDING | IRQ_MASKED);
+ *   - kernel/irq/chip.c|612| <<handle_edge_irq>> (IRQ_PENDING | IRQ_MASKED | IRQ_DISABLED)) ==
+ *   - kernel/irq/chip.c|613| <<handle_edge_irq>> (IRQ_PENDING | IRQ_MASKED))) {
+ *   - kernel/irq/chip.c|618| <<handle_edge_irq>> desc->status &= ~IRQ_PENDING;
+ *   - kernel/irq/chip.c|625| <<handle_edge_irq>> } while ((desc->status & (IRQ_PENDING | IRQ_DISABLED)) == IRQ_PENDING);
+ *   - kernel/irq/handle.c|484| <<__do_IRQ>> status |= IRQ_PENDING;
+ *   - kernel/irq/handle.c|493| <<__do_IRQ>> status &= ~IRQ_PENDING;
+ *   - kernel/irq/handle.c|527| <<__do_IRQ>> if (likely(!(desc->status & IRQ_PENDING)))
+ *   - kernel/irq/handle.c|529| <<__do_IRQ>> desc->status &= ~IRQ_PENDING;
+ *   - kernel/irq/internals.h|84| <<print_irq_desc>> P(IRQ_PENDING);
+ *   - kernel/irq/manage.c|660| <<irq_thread>> desc->status |= IRQ_PENDING;
+ *   - kernel/irq/pm.c|75| <<check_wakeup_irqs>> if ((desc->status & IRQ_WAKEUP) && (desc->status & IRQ_PENDING))
+ *   - kernel/irq/resend.c|70| <<check_irq_resend>> if ((status & (IRQ_LEVEL | IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
+ *   - kernel/irq/resend.c|71| <<check_irq_resend>> desc->status = (status & ~IRQ_PENDING) | IRQ_REPLAY;
+ *   - kernel/irq/spurious.c|39| <<try_one_irq>> desc->status |= IRQ_PENDING;
+ *   - kernel/irq/spurious.c|66| <<try_one_irq>> while ((desc->status & IRQ_PENDING) && action) {
+ *   - kernel/irq/spurious.c|74| <<try_one_irq>> desc->status &= ~IRQ_PENDING;
+ */
 #define IRQ_PENDING		0x00000400	/* IRQ pending - replay on enable */
 #define IRQ_REPLAY		0x00000800	/* IRQ has been replayed but not acked yet */
 #define IRQ_AUTODETECT		0x00001000	/* IRQ is being autodetected */
@@ -318,6 +372,9 @@ static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *de
 #ifdef CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ
 	desc->handle_irq(irq, desc);
 #else
+	/*
+	 * handle_edge_irq()
+	 */
 	if (likely(desc->handle_irq))
 		desc->handle_irq(irq, desc);
 	else
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 3b8c627c..6181f2cf 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -376,10 +376,29 @@ struct napi_struct {
 
 enum
 {
+	/*
+	 * 在以下使用NAPI_STATE_SCHED:
+	 *   - drivers/net/cxgb3/sge.c|2470| <<napi_is_scheduled>> return test_bit(NAPI_STATE_SCHED, &napi->state);
+	 *   - include/linux/netdevice.h|474| <<napi_schedule_prep>> !test_and_set_bit(NAPI_STATE_SCHED, &n->state);
+	 *   - include/linux/netdevice.h|563| <<napi_enable>> BUG_ON(!test_bit(NAPI_STATE_SCHED, &n->state));
+	 *   - include/linux/netdevice.h|565| <<napi_enable>> clear_bit(NAPI_STATE_SCHED, &n->state);
+	 *   - include/linux/netdevice.h|580| <<napi_synchronize>> while (test_bit(NAPI_STATE_SCHED, &n->state))
+	 *   - net/core/dev.c|3907| <<__napi_complete>> BUG_ON(!test_bit(NAPI_STATE_SCHED, &n->state));
+	 *   - net/core/dev.c|3911| <<__napi_complete>> clear_bit(NAPI_STATE_SCHED, &n->state);
+	 *   - net/core/dev.c|4045| <<__netif_napi_add>> set_bit(NAPI_STATE_SCHED, &napi->state);
+	 *   - net/core/dev.c|4066| <<napi_disable>> while (test_and_set_bit(NAPI_STATE_SCHED, &n->state))
+	 *   - net/core/dev.c|4157| <<net_rx_action>> if (test_bit(NAPI_STATE_SCHED, &n->state)) {
+	 *   - net/core/netpoll.c|137| <<poll_one_napi>> if (!test_bit(NAPI_STATE_SCHED, &napi->state))
+	 */
 	NAPI_STATE_SCHED,	/* Poll is scheduled */
 	NAPI_STATE_DISABLE,	/* Disable pending */
 	NAPI_STATE_NPSVC,	/* Netpoll - don't dequeue from poll_list */
 	NAPI_STATE_HASHED,	/* In NAPI hash */
+	/*
+	 * 在以下使用NAPI_STATE_EXT:
+	 *   - include/linux/netdevice.h|374| <<NAPI_STRUCT_HAS>> (test_bit(NAPI_STATE_EXT, &__n->state) && \
+	 *   - net/core/dev.c|4023| <<__netif_napi_add>> set_bit(NAPI_STATE_EXT, &napi->state);
+	 */
 	NAPI_STATE_EXT,		/* Extended napi_struct */
 };
 
diff --git a/include/linux/virtio.h b/include/linux/virtio.h
index 7fcf33a9..386286e8 100644
--- a/include/linux/virtio.h
+++ b/include/linux/virtio.h
@@ -143,6 +143,17 @@ void virtio_config_changed(struct virtio_device *dev);
 struct virtio_driver {
 	struct device_driver driver;
 	const struct virtio_device_id *id_table;
+	/*
+	 * 在以下使用virtio_driver->features_table[]:
+	 *   - drivers/block/virtio_blk.c|632| <<global>> .feature_table = features,
+	 *   - drivers/char/virtio_console.c|2081| <<global>> .feature_table = features,
+	 *   - drivers/net/virtio_net.c|1870| <<global>> .feature_table = features,
+	 *   - drivers/scsi/virtio_scsi.c|1036| <<global>> .feature_table = features,
+	 *   - drivers/virtio/virtio_balloon.c|444| <<global>> .feature_table = features,
+	 *   - drivers/virtio/virtio.c|107| <<virtio_check_driver_offered_feature>> if (drv->feature_table[i] == fbit)
+	 *   - drivers/virtio/virtio.c|168| <<virtio_dev_probe>> unsigned int f = drv->feature_table[i];
+	 *   - drivers/virtio/virtio.c|223| <<register_virtio_driver>> BUG_ON(driver->feature_table_size && !driver->feature_table);
+	 */
 	const unsigned int *feature_table;
 	unsigned int feature_table_size;
 	int (*probe)(struct virtio_device *dev);
diff --git a/include/linux/virtio_pci.h b/include/linux/virtio_pci.h
index 9a3d7c48..075496d9 100644
--- a/include/linux/virtio_pci.h
+++ b/include/linux/virtio_pci.h
@@ -68,5 +68,11 @@
 
 /* The alignment to use between consumer and producer parts of vring.
  * x86 pagesize again. */
+/*
+ * 在以下使用VIRTIO_PCI_VRING_ALIGN:
+ *   - drivers/virtio/virtio_pci.c|399| <<setup_vq>> size = PAGE_ALIGN(vring_size(num, VIRTIO_PCI_VRING_ALIGN));
+ *   - drivers/virtio/virtio_pci.c|411| <<setup_vq>> vq = vring_new_virtqueue(index, info->num, VIRTIO_PCI_VRING_ALIGN, vdev,
+ *   - drivers/virtio/virtio_pci.c|471| <<vp_del_vq>> size = PAGE_ALIGN(vring_size(info->num, VIRTIO_PCI_VRING_ALIGN));
+ */
 #define VIRTIO_PCI_VRING_ALIGN		4096
 #endif
diff --git a/include/linux/virtio_ring.h b/include/linux/virtio_ring.h
index e86e134f..1d73d435 100644
--- a/include/linux/virtio_ring.h
+++ b/include/linux/virtio_ring.h
@@ -13,6 +13,13 @@
 /* This marks a buffer as continuing via the next field. */
 #define VRING_DESC_F_NEXT	1
 /* This marks a buffer as write-only (otherwise read-only). */
+/*
+ * 在以下使用VRING_DESC_F_WRITE:
+ *   - drivers/vhost/vhost.c|1174| <<get_indirect>> if (desc.flags & VRING_DESC_F_WRITE) {
+ *   - drivers/vhost/vhost.c|1295| <<vhost_get_vq_desc>> if (desc.flags & VRING_DESC_F_WRITE) {
+ *   - drivers/virtio/virtio_ring.c|176| <<vring_add_indirect>> desc[i].flags = VRING_DESC_F_NEXT|VRING_DESC_F_WRITE;
+ *   - drivers/virtio/virtio_ring.c|332| <<virtqueue_add_buf>> vq->vring.desc[i].flags = VRING_DESC_F_NEXT|VRING_DESC_F_WRITE;
+ */
 #define VRING_DESC_F_WRITE	2
 /* This means the buffer contains a list of buffer descriptors. */
 #define VRING_DESC_F_INDIRECT	4
@@ -20,10 +27,28 @@
 /* The Host uses this in used->flags to advise the Guest: don't kick me when
  * you add a buffer.  It's unreliable, so it's simply an optimization.  Guest
  * will still kick if it's out of buffers. */
+/*
+ * 在以下使用VRING_USED_F_NO_NOTIFY:
+ *   - drivers/vhost/vhost.c|1321| <<vhost_get_vq_desc>> BUG_ON(!(vq->used_flags & VRING_USED_F_NO_NOTIFY));
+ *   - drivers/vhost/vhost.c|1515| <<vhost_enable_notify>> if (!(vq->used_flags & VRING_USED_F_NO_NOTIFY))
+ *   - drivers/vhost/vhost.c|1517| <<vhost_enable_notify>> vq->used_flags &= ~VRING_USED_F_NO_NOTIFY;
+ *   - drivers/vhost/vhost.c|1550| <<vhost_disable_notify>> if (vq->used_flags & VRING_USED_F_NO_NOTIFY)
+ *   - drivers/vhost/vhost.c|1552| <<vhost_disable_notify>> vq->used_flags |= VRING_USED_F_NO_NOTIFY;
+ *   - drivers/virtio/virtio_ring.c|418| <<virtqueue_kick_prepare>> needs_kick = !(vq->vring.used->flags & VRING_USED_F_NO_NOTIFY);
+ */
 #define VRING_USED_F_NO_NOTIFY	1
 /* The Guest uses this in avail->flags to advise the Host: don't interrupt me
  * when you consume a buffer.  It's unreliable, so it's simply an
  * optimization.  */
+/*
+ * 在以下使用VRING_AVAIL_F_NO_INTERRUPT:
+ *   - drivers/vhost/vhost.c|1467| <<vhost_notify>> return !(flags & VRING_AVAIL_F_NO_INTERRUPT);
+ *   - drivers/virtio/virtio_ring.c|528| <<virtqueue_get_buf>> if (!(vq->vring.avail->flags & VRING_AVAIL_F_NO_INTERRUPT)) {
+ *   - drivers/virtio/virtio_ring.c|542| <<virtqueue_disable_cb>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+ *   - drivers/virtio/virtio_ring.c|570| <<virtqueue_enable_cb_prepare>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+ *   - drivers/virtio/virtio_ring.c|625| <<virtqueue_enable_cb_delayed>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+ *   - drivers/virtio/virtio_ring.c|739| <<vring_new_virtqueue>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+ */
 #define VRING_AVAIL_F_NO_INTERRUPT	1
 
 /* We support indirect buffer descriptors */
@@ -33,6 +58,20 @@
  * at the end of the avail ring. Host should ignore the avail->flags field. */
 /* The Host publishes the avail index for which it expects a kick
  * at the end of the used ring. Guest should ignore the used->flags field. */
+/*
+ * 在以下使用VIRTIO_RING_F_EVENT_IDX:
+ *   - drivers/vhost/vhost.c|566| <<vq_access_ok>> size_t s = vhost_has_feature(d, VIRTIO_RING_F_EVENT_IDX) ? 2 : 0;
+ *   - drivers/vhost/vhost.c|586| <<vq_log_access_ok>> size_t s = vhost_has_feature(d, VIRTIO_RING_F_EVENT_IDX) ? 2 : 0;
+ *   - drivers/vhost/vhost.c|1461| <<vhost_notify>> if (!vhost_has_feature(dev, VIRTIO_RING_F_EVENT_IDX)) {
+ *   - drivers/vhost/vhost.c|1518| <<vhost_enable_notify>> if (!vhost_has_feature(dev, VIRTIO_RING_F_EVENT_IDX)) {
+ *   - drivers/vhost/vhost.c|1553| <<vhost_disable_notify>> if (!vhost_has_feature(dev, VIRTIO_RING_F_EVENT_IDX)) {
+ *   - drivers/virtio/virtio_ring.c|723| <<vring_new_virtqueue>> vq->event = virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);
+ *   - drivers/virtio/virtio_ring.c|758| <<vring_transport_features>> case VIRTIO_RING_F_EVENT_IDX:
+ *
+ * VIRTIO_RING_F_EVENT_IDX:
+ *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+ *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+ */
 #define VIRTIO_RING_F_EVENT_IDX		29
 
 /* Virtio ring descriptors: 16 bytes.  These can chain together via "next". */
@@ -103,21 +142,80 @@ struct vring {
  */
 /* We publish the used event index at the end of the available ring, and vice
  * versa. They are at the end for backwards compatibility. */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|529| <<virtqueue_get_buf>> vring_used_event(&vq->vring) = vq->last_used_idx;
+ *   - drivers/virtio/virtio_ring.c|571| <<virtqueue_enable_cb_prepare>> vring_used_event(&vq->vring) = last_used_idx = vq->last_used_idx;
+ *   - drivers/virtio/virtio_ring.c|628| <<virtqueue_enable_cb_delayed>> vring_used_event(&vq->vring) = vq->last_used_idx + bufs;
+ */
 #define vring_used_event(vr) ((vr)->avail->ring[(vr)->num])
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|415| <<virtqueue_kick_prepare>> needs_kick = vring_need_event(vring_avail_event(&vq->vring),
+ */
 #define vring_avail_event(vr) (*(__u16 *)&(vr)->used->ring[(vr)->num])
 
+/*
+ * vring_align是VIRTIO_PCI_VRING_ALIGN: 4096
+ *
+ * 假设p = 0xffff8800b4c44000, num = 256
+ *
+ * vr->desc = 0xffff8800b4c44000
+ * vr->avail = p + 0x10 * 256 = p + 4096 = 0xffff8800b4c45000
+ * vr->used = 0xffff8800b4c46000
+ */
 static inline void vring_init(struct vring *vr, unsigned int num, void *p,
 			      unsigned long align)
 {
 	vr->num = num;
 	vr->desc = p;
 	vr->avail = p + num*sizeof(struct vring_desc);
+	/*
+	 * align是VIRTIO_PCI_VRING_ALIGN: 4096
+	 *
+	 * struct vring *vr:
+	 *  -> struct vring_avail *avail;
+	 *      -> __u16 flags;
+	 *      -> __u16 idx;
+	 *      -> __u16 ring[];
+	 */
 	vr->used = (void *)(((unsigned long)&vr->avail->ring[num] + align-1)
 			    & ~(align - 1));
 }
 
+/*
+ * called by:
+ *   - drivers/lguest/lguest_device.c|276| <<lg_find_vq>> DIV_ROUND_UP(vring_size(lvq->config.num,
+ *   - drivers/s390/kvm/kvm_virtio.c|191| <<kvm_find_vq>> vring_size(config->num,
+ *   - drivers/s390/kvm/kvm_virtio.c|214| <<kvm_find_vq>> vring_size(config->num,
+ *   - drivers/s390/kvm/kvm_virtio.c|226| <<kvm_del_vq>> vring_size(config->num,
+ *   - drivers/virtio/virtio_pci.c|399| <<setup_vq>> size = PAGE_ALIGN(vring_size(num, VIRTIO_PCI_VRING_ALIGN));
+ *   - drivers/virtio/virtio_pci.c|471| <<vp_del_vq>> size = PAGE_ALIGN(vring_size(info->num, VIRTIO_PCI_VRING_ALIGN));
+ */
 static inline unsigned vring_size(unsigned int num, unsigned long align)
 {
+	/*
+	 * struct vring {
+	 *     unsigned int num;
+	 *     struct vring_desc *desc;
+	 *     struct vring_avail *avail;
+	 *         __u16 flags;
+	 *         __u16 idx;
+	 *         __u16 ring[];
+	 *     struct vring_used *used;
+	 *         __u16 flags;
+	 *         __u16 idx;
+	 *         struct vring_used_elem ring[];
+	 *
+	 *
+	 *  - sizeof(struct vring_desc) * num
+	 *  - sizeof(__u16) * (2 + num) ---> 不明白为什么不是3!!!
+	 *  ... align ...  ----> align是VIRTIO_PCI_VRING_ALIGN: 4096
+	 *  - sizeof(__u16) * 3 + sizeof(struct vring_used_elem) * num
+	 * };
+	 *
+	 * !!! align是VIRTIO_PCI_VRING_ALIGN: 4096 !!!
+	 */
 	return ((sizeof(struct vring_desc) * num + sizeof(__u16) * (2 + num)
 		 + align - 1) & ~(align - 1))
 		+ sizeof(__u16) * 3 + sizeof(struct vring_used_elem) * num;
@@ -127,6 +225,13 @@ static inline unsigned vring_size(unsigned int num, unsigned long align)
 /* Assuming a given event_idx value from the other size, if
  * we have just incremented index from old to new_idx,
  * should we trigger an event? */
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|1481| <<vhost_notify>> return vring_need_event(event, new, old);
+ *   - drivers/virtio/virtio_ring.c|415| <<virtqueue_kick_prepare>> needs_kick = vring_need_event(vring_avail_event(&vq->vring),
+ *
+ * 相当于当event_idx + 1 > old的时候返回true
+ */
 static inline int vring_need_event(__u16 event_idx, __u16 new_idx, __u16 old)
 {
 	/* Note: Xen has similar logic for notification hold-off
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index cc97927c..d511c52b 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -350,12 +350,24 @@ void irq_chip_set_defaults(struct irq_chip *chip)
 		chip->end = dummy_irq_chip.end;
 }
 
+/*
+ * called by:
+ *   - kernel/irq/chip.c|462| <<handle_level_irq>> mask_ack_irq(desc, irq);
+ *   - kernel/irq/chip.c|579| <<handle_edge_irq>> mask_ack_irq(desc, irq);
+ *   - kernel/irq/chip.c|685| <<__set_irq_handler>> mask_ack_irq(desc, irq);
+ */
 static inline void mask_ack_irq(struct irq_desc *desc, int irq)
 {
 	if (desc->chip->mask_ack)
 		desc->chip->mask_ack(irq);
 	else {
+		/*
+		 * mask_msi_irq()
+		 */
 		desc->chip->mask(irq);
+		/*
+		 * ack_apic_edge()
+		 */
 		if (desc->chip->ack)
 			desc->chip->ack(irq);
 	}
@@ -582,6 +594,9 @@ handle_edge_irq(unsigned int irq, struct irq_desc *desc)
 	kstat_incr_irqs_this_cpu(irq, desc);
 
 	/* Start handling the irq */
+	/*
+	 * ack_apic_edge()
+	 */
 	if (desc->chip->ack)
 		desc->chip->ack(irq);
 
diff --git a/kernel/irq/spurious.c b/kernel/irq/spurious.c
index bd7273e6..c966a5c8 100644
--- a/kernel/irq/spurious.c
+++ b/kernel/irq/spurious.c
@@ -23,6 +23,11 @@ static DEFINE_TIMER(poll_spurious_irq_timer, poll_spurious_irqs, 0, 0);
 /*
  * Recovery handler for misrouted interrupts.
  */
+/*
+ * called by:
+ *   - kernel/irq/spurious.c|100| <<misrouted_irq>> if (try_one_irq(i, desc))
+ *   - kernel/irq/spurious.c|125| <<poll_all_shared_irqs>> try_one_irq(i, desc);
+ */
 static int try_one_irq(int irq, struct irq_desc *desc)
 {
 	struct irqaction *action;
@@ -85,6 +90,10 @@ static int try_one_irq(int irq, struct irq_desc *desc)
 	return ok;
 }
 
+/*
+ * called by:
+ *   - kernel/irq/spurious.c|248| <<note_interrupt>> int ok = misrouted_irq(irq);
+ */
 static int misrouted_irq(int irq)
 {
 	struct irq_desc *desc;
diff --git a/net/core/dev.c b/net/core/dev.c
index 5f75a7d0..06df4761 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -4154,6 +4154,20 @@ static void net_rx_action(struct softirq_action *h)
 		 * accidently calling ->poll() when NAPI is not scheduled.
 		 */
 		work = 0;
+		/*
+		 * 在以下使用NAPI_STATE_SCHED:
+		 *   - drivers/net/cxgb3/sge.c|2470| <<napi_is_scheduled>> return test_bit(NAPI_STATE_SCHED, &napi->state);
+		 *   - include/linux/netdevice.h|474| <<napi_schedule_prep>> !test_and_set_bit(NAPI_STATE_SCHED, &n->state);
+		 *   - include/linux/netdevice.h|563| <<napi_enable>> BUG_ON(!test_bit(NAPI_STATE_SCHED, &n->state));
+		 *   - include/linux/netdevice.h|565| <<napi_enable>> clear_bit(NAPI_STATE_SCHED, &n->state);
+		 *   - include/linux/netdevice.h|580| <<napi_synchronize>> while (test_bit(NAPI_STATE_SCHED, &n->state))
+		 *   - net/core/dev.c|3907| <<__napi_complete>> BUG_ON(!test_bit(NAPI_STATE_SCHED, &n->state));
+		 *   - net/core/dev.c|3911| <<__napi_complete>> clear_bit(NAPI_STATE_SCHED, &n->state);
+		 *   - net/core/dev.c|4045| <<__netif_napi_add>> set_bit(NAPI_STATE_SCHED, &napi->state);
+		 *   - net/core/dev.c|4066| <<napi_disable>> while (test_and_set_bit(NAPI_STATE_SCHED, &n->state))
+		 *   - net/core/dev.c|4157| <<net_rx_action>> if (test_bit(NAPI_STATE_SCHED, &n->state)) {
+		 *   - net/core/netpoll.c|137| <<poll_one_napi>> if (!test_bit(NAPI_STATE_SCHED, &napi->state))
+		 */
 		if (test_bit(NAPI_STATE_SCHED, &n->state)) {
 			work = n->poll(n, weight);
 			trace_napi_poll(n);
-- 
2.17.1

