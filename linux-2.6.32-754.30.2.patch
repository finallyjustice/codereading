From be2a1441b0219ffe283a10087fe4fdf14a4e834c Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Thu, 23 Jul 2020 14:35:41 -0700
Subject: [PATCH 1/1] linux-2.6.32-754.30.2

linux-2.6.32-754.30.2

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 drivers/net/virtio_net.c     | 185 ++++++++++++++++++
 drivers/virtio/virtio.c      |   3 +
 drivers/virtio/virtio_ring.c | 350 +++++++++++++++++++++++++++++++++++
 include/linux/virtio.h       |  11 ++
 include/linux/virtio_pci.h   |   6 +
 include/linux/virtio_ring.h  | 105 +++++++++++
 6 files changed, 660 insertions(+)

diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index a887b152..2c49fb43 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -105,12 +105,37 @@ struct virtnet_info
 	u16 max_queue_pairs;
 
 	/* # of queue pairs currently used by the driver */
+	/*
+	 * 在以下修改virtnet_info->curr_queue_pairs:
+	 *   - drivers/net/virtio_net.c|1023| <<virtnet_set_queues>> vi->curr_queue_pairs = queue_pairs;
+	 *   - drivers/net/virtio_net.c|1701| <<virtnet_probe>> vi->curr_queue_pairs = 1;
+	 * 在以下使用virtnet_info->curr_queue_pairs:
+	 *   - drivers/net/virtio_net.c|651| <<refill_work>> for (i = 0; i < vi->curr_queue_pairs; i++) {
+	 *   - drivers/net/virtio_net.c|708| <<virtnet_open>> if (i < vi->curr_queue_pairs)
+	 *   - drivers/net/virtio_net.c|876| <<virtnet_netpoll>> for (i = 0; i < vi->curr_queue_pairs; i++)
+	 *   - drivers/net/virtio_net.c|1164| <<virtnet_clean_affinity>> ++i % vi->curr_queue_pairs;
+	 *   - drivers/net/virtio_net.c|1178| <<virtnet_set_affinity>> if (vi->curr_queue_pairs == 1 ||
+	 *   - drivers/net/virtio_net.c|1251| <<virtnet_get_channels>> channels->combined_count = vi->curr_queue_pairs;
+	 *   - drivers/net/virtio_net.c|1719| <<virtnet_probe>> for (i = 0; i < vi->curr_queue_pairs; i++) {
+	 *   - drivers/net/virtio_net.c|1852| <<virtnet_restore>> for (i = 0; i < vi->curr_queue_pairs; i++)
+	 *   - drivers/net/virtio_net.c|1861| <<virtnet_restore>> virtnet_set_queues(vi, vi->curr_queue_pairs);
+	 */
 	u16 curr_queue_pairs;
 
 	/* I like... big packets and I cannot lie! */
 	bool big_packets;
 
 	/* Host will merge rx buffers for big packets (shake it! shake it!) */
+	/*
+	 * 在以下使用virtnet_info->mergeable_rx_bufs:
+	 *   - drivers/net/virtio_net.c|267| <<page_to_skb>> if (vi->mergeable_rx_bufs) {
+	 *   - drivers/net/virtio_net.c|397| <<receive_buf>> if (vi->mergeable_rx_bufs || vi->big_packets)
+	 *   - drivers/net/virtio_net.c|403| <<receive_buf>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|582| <<try_fill_recv>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|761| <<xmit_skb>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|1380| <<free_unused_bufs>> if (vi->mergeable_rx_bufs || vi->big_packets)
+	 *   - drivers/net/virtio_net.c|1636| <<virtnet_probe>> vi->mergeable_rx_bufs = true;
+	 */
 	bool mergeable_rx_bufs;
 
 	/* Has control virtqueue */
@@ -182,8 +207,14 @@ static int rxq2vq(int rxq)
 	return rxq * 2;
 }
 
+/*
+ * 返回共享的共享的char cb[48];
+ */
 static inline struct skb_vnet_hdr *skb_vnet_hdr(struct sk_buff *skb)
 {
+	/*
+	 * 共享的char cb[48];
+	 */
 	return (struct skb_vnet_hdr *)skb->cb;
 }
 
@@ -191,6 +222,19 @@ static inline struct skb_vnet_hdr *skb_vnet_hdr(struct sk_buff *skb)
  * private is used to chain pages for big packets, put the whole
  * most recent used list in the beginning for reuse
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|357| <<page_to_skb>> give_pages(rq, page);
+ *   - drivers/net/virtio_net.c|387| <<receive_big>> give_pages(rq, page);
+ *   - drivers/net/virtio_net.c|433| <<receive_mergeable>> give_pages(rq, page);
+ *   - drivers/net/virtio_net.c|443| <<receive_mergeable>> give_pages(rq, page);
+ *   - drivers/net/virtio_net.c|468| <<receive_buf>> give_pages(rq, buf);
+ *   - drivers/net/virtio_net.c|585| <<add_recvbuf_big>> give_pages(rq, list);
+ *   - drivers/net/virtio_net.c|597| <<add_recvbuf_big>> give_pages(rq, list);
+ *   - drivers/net/virtio_net.c|615| <<add_recvbuf_big>> give_pages(rq, first);
+ *   - drivers/net/virtio_net.c|641| <<add_recvbuf_mergeable>> give_pages(rq, page);
+ *   - drivers/net/virtio_net.c|1528| <<free_unused_bufs>> give_pages(&vi->rq[i], buf);
+ */
 static void give_pages(struct receive_queue *rq, struct page *page)
 {
 	struct page *end;
@@ -201,8 +245,19 @@ static void give_pages(struct receive_queue *rq, struct page *page)
 	rq->pages = page;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|551| <<add_recvbuf_big>> first = get_a_page(rq, gfp);
+ *   - drivers/net/virtio_net.c|564| <<add_recvbuf_big>> first = get_a_page(rq, gfp);
+ *   - drivers/net/virtio_net.c|598| <<add_recvbuf_mergeable>> page = get_a_page(rq, gfp);
+ *   - drivers/net/virtio_net.c|1477| <<free_receive_bufs>> __free_pages(get_a_page(&vi->rq[i], GFP_KERNEL), 0);
+ *
+ * 如果receive_queue->pages上有page, 拿出来
+ * 否则分配新的struct page
+ */
 static struct page *get_a_page(struct receive_queue *rq, gfp_t gfp_mask)
 {
+	/* struct page *pages; */
 	struct page *p = rq->pages;
 
 	if (p) {
@@ -214,6 +269,10 @@ static struct page *get_a_page(struct receive_queue *rq, gfp_t gfp_mask)
 	return p;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|1552| <<virtnet_find_vqs>> callbacks[txq2vq(i)] = skb_xmit_done;
+ */
 static void skb_xmit_done(struct virtqueue *vq)
 {
 	struct virtnet_info *vi = vq->vdev->priv;
@@ -225,6 +284,11 @@ static void skb_xmit_done(struct virtqueue *vq)
 	netif_wake_subqueue(vi->dev, vq2txq(vq));
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|320| <<page_to_skb>> set_skb_frag(skb, page, offset, &len);
+ *   - drivers/net/virtio_net.c|396| <<receive_mergeable>> set_skb_frag(skb, page, 0, &len);
+ */
 static void set_skb_frag(struct sk_buff *skb, struct page *page,
 			 unsigned int offset, unsigned int *len)
 {
@@ -244,6 +308,14 @@ static void set_skb_frag(struct sk_buff *skb, struct page *page,
 }
 
 /* Called from bottom half context */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|347| <<receive_big>> struct sk_buff *skb = page_to_skb(rq, page, len);
+ *   - drivers/net/virtio_net.c|372| <<receive_mergeable>> struct sk_buff *skb = page_to_skb(rq, page, len);
+ *
+ * page->private可能串着一个或者多个page
+ * 把这些page copy成一个skb
+ */
 static struct sk_buff *page_to_skb(struct receive_queue *rq,
 				   struct page *page, unsigned int len)
 {
@@ -262,6 +334,9 @@ static struct sk_buff *page_to_skb(struct receive_queue *rq,
 
 	skb_reserve(skb, NET_IP_ALIGN);
 
+	/*
+	 * 返回共享的共享的char cb[48];
+	 */
 	hdr = skb_vnet_hdr(skb);
 
 	if (vi->mergeable_rx_bufs) {
@@ -326,6 +401,10 @@ err:
 	return NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|435| <<receive_buf>> skb = receive_mergeable(dev, rq, buf, len);
+ */
 static struct sk_buff *receive_mergeable(struct net_device *dev,
 					 struct receive_queue *rq,
 					 void *buf,
@@ -383,6 +462,10 @@ err_buf:
 	return NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|718| <<virtnet_poll>> receive_buf(rq, buf, len);
+ */
 static void receive_buf(struct receive_queue *rq, void *buf, unsigned int len)
 {
 	struct virtnet_info *vi = rq->vq->vdev->priv;
@@ -547,6 +630,10 @@ static int add_recvbuf_big(struct receive_queue *rq, gfp_t gfp)
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|614| <<try_fill_recv>> err = add_recvbuf_mergeable(rq, gfp);
+ */
 static int add_recvbuf_mergeable(struct receive_queue *rq, gfp_t gfp)
 {
 	struct page *page;
@@ -556,6 +643,10 @@ static int add_recvbuf_mergeable(struct receive_queue *rq, gfp_t gfp)
 	if (!page)
 		return -ENOMEM;
 
+	/*
+	 * struct receive_queue:
+	 *   -> struct scatterlist sg[MAX_SKB_FRAGS + 2];
+	 */
 	sg_init_one(rq->sg, page_address(page), PAGE_SIZE);
 
 	err = virtqueue_add_buf(rq->vq, rq->sg, 0, 1, page);
@@ -572,6 +663,14 @@ static int add_recvbuf_mergeable(struct receive_queue *rq, gfp_t gfp)
  * before we're receiving packets, or from refill_work which is
  * careful to disable receiving (using napi_disable).
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|676| <<refill_work>> still_empty = !try_fill_recv(rq, GFP_KERNEL);
+ *   - drivers/net/virtio_net.c|714| <<virtnet_poll>> if (!try_fill_recv(rq, GFP_ATOMIC))
+ *   - drivers/net/virtio_net.c|741| <<virtnet_open>> if (!try_fill_recv(&vi->rq[i], GFP_KERNEL))
+ *   - drivers/net/virtio_net.c|1767| <<virtnet_probe>> try_fill_recv(&vi->rq[i], GFP_KERNEL);
+ *   - drivers/net/virtio_net.c|1900| <<virtnet_restore>> if (!try_fill_recv(&vi->rq[i], GFP_KERNEL))
+ */
 static bool try_fill_recv(struct receive_queue *rq, gfp_t gfp)
 {
 	struct virtnet_info *vi = rq->vq->vdev->priv;
@@ -591,6 +690,12 @@ static bool try_fill_recv(struct receive_queue *rq, gfp_t gfp)
 			break;
 		++rq->num;
 	} while (err > 0);
+	/*
+	 * 使用receive_queue->max的地方:
+	 *   - drivers/net/virtio_net.c|625| <<try_fill_recv>> if (unlikely(rq->num > rq->max))
+	 *   - drivers/net/virtio_net.c|626| <<try_fill_recv>> rq->max = rq->num;
+	 *   - drivers/net/virtio_net.c|697| <<virtnet_poll>> if (rq->num < rq->max / 2) {
+	 */
 	if (unlikely(rq->num > rq->max))
 		rq->max = rq->num;
 	virtqueue_kick(rq->vq);
@@ -609,6 +714,12 @@ static void skb_recv_done(struct virtqueue *rvq)
 	}
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|745| <<refill_work>> virtnet_napi_enable(rq);
+ *   - drivers/net/virtio_net.c|811| <<virtnet_open>> virtnet_napi_enable(&vi->rq[i]);
+ *   - drivers/net/virtio_net.c|1968| <<virtnet_restore>> virtnet_napi_enable(&vi->rq[i]);
+ */
 static void virtnet_napi_enable(struct receive_queue *rq)
 {
 	napi_enable(&rq->napi);
@@ -647,6 +758,10 @@ static void refill_work(struct work_struct *work)
 	}
 }
 
+/*
+ * 在以下使用virtnet_poll():
+ *   - drivers/net/virtio_net.c|1565| <<virtnet_alloc_queues>> netif_napi_add(vi->dev, &vi->rq[i].napi, virtnet_poll,
+ */
 static int virtnet_poll(struct napi_struct *napi, int budget)
 {
 	struct receive_queue *rq =
@@ -663,6 +778,12 @@ again:
 		received++;
 	}
 
+	/*
+	 * 使用receive_queue->max的地方:
+	 *   - drivers/net/virtio_net.c|625| <<try_fill_recv>> if (unlikely(rq->num > rq->max))
+	 *   - drivers/net/virtio_net.c|626| <<try_fill_recv>> rq->max = rq->num;
+	 *   - drivers/net/virtio_net.c|697| <<virtnet_poll>> if (rq->num < rq->max / 2) {
+	 */
 	if (rq->num < rq->max / 2) {
 		if (!try_fill_recv(rq, GFP_ATOMIC))
 			queue_delayed_work(vi->st_wq, &vi->refill, 0);
@@ -699,6 +820,11 @@ static int virtnet_open(struct net_device *dev)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|923| <<start_xmit>> free_old_xmit_skbs(sq);
+ *   - drivers/net/virtio_net.c|958| <<start_xmit>> capacity += free_old_xmit_skbs(sq);
+ */
 static unsigned int free_old_xmit_skbs(struct send_queue *sq)
 {
 	struct sk_buff *skb;
@@ -722,8 +848,17 @@ static unsigned int free_old_xmit_skbs(struct send_queue *sq)
 
 static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 {
+	/*
+	 * 返回共享的共享的char cb[48];
+	 */
 	struct skb_vnet_hdr *hdr = skb_vnet_hdr(skb);
 	const unsigned char *dest = ((struct ethhdr *)skb->data)->h_dest;
+	/*
+	 * struct send_queue:
+	 *  -> struct virtqueue *vq;
+	 *      -> struct virtio_device *vdev;
+	 *          -> void *priv;
+	 */
 	struct virtnet_info *vi = sq->vq->vdev->priv;
 
 	pr_debug("%s: xmit %p %pM\n", vi->dev->name, skb, dest);
@@ -758,12 +893,32 @@ static int xmit_skb(struct send_queue *sq, struct sk_buff *skb)
 	hdr->mhdr.num_buffers = 0;
 
 	/* Encode metadata header at front. */
+	/*
+	 * struct skb_vnet_hdr {
+	 *     union {
+	 *         struct virtio_net_hdr hdr;
+	 *         struct virtio_net_hdr_mrg_rxbuf mhdr;
+	 *     };
+	 *     unsigned int num_sg;
+	 * };
+	 *
+	 * struct send_queue:
+	 *   -> // TX: fragments + linear part + virtio header
+	 *   -> struct scatterlist sg[MAX_SKB_FRAGS + 2];
+	 */
 	if (vi->mergeable_rx_bufs)
 		sg_set_buf(sq->sg, &hdr->mhdr, sizeof hdr->mhdr);
 	else
 		sg_set_buf(sq->sg, &hdr->hdr, sizeof hdr->hdr);
 
+	/*
+	 * !! 注意最后的+1
+	 */
 	hdr->num_sg = skb_to_sgvec(skb, sq->sg + 1, 0, skb->len) + 1;
+	/*
+	 * 输入是sq->sg[若干个]
+	 * 实际是hdr->num_sg个
+	 */
 	return virtqueue_add_buf(sq->vq, sq->sg, hdr->num_sg,
 				 0, skb);
 }
@@ -838,6 +993,17 @@ static void virtnet_netpoll(struct net_device *dev)
  * supported by the hypervisor, as indicated by feature bits, should
  * never fail unless improperly formated.
  */
+/*
+ * called by:
+ *   - rivers/net/virtio_net.c|955| <<virtnet_set_mac_address>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,
+ *   - drivers/net/virtio_net.c|1013| <<virtnet_ack_link_announce>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_ANNOUNCE,
+ *   - drivers/net/virtio_net.c|1037| <<virtnet_set_queues>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MQ,
+ *   - drivers/net/virtio_net.c|1087| <<virtnet_set_rx_mode>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_RX,
+ *   - drivers/net/virtio_net.c|1095| <<virtnet_set_rx_mode>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_RX,
+ *   - drivers/net/virtio_net.c|1132| <<virtnet_set_rx_mode>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_MAC,
+ *   - drivers/net/virtio_net.c|1147| <<virtnet_vlan_rx_add_vid>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_VLAN,
+ *   - drivers/net/virtio_net.c|1159| <<virtnet_vlan_rx_kill_vid>> if (!virtnet_send_command(vi, VIRTIO_NET_CTRL_VLAN,
+ */
 static bool virtnet_send_command(struct virtnet_info *vi, u8 class, u8 cmd,
 				 struct scatterlist *data, int out, int in)
 {
@@ -957,6 +1123,11 @@ static void virtnet_ack_link_announce(struct virtnet_info *vi)
 	rtnl_unlock();
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|1234| <<virtnet_set_channels>> err = virtnet_set_queues(vi, queue_pairs);
+ *   - drivers/net/virtio_net.c|1861| <<virtnet_restore>> virtnet_set_queues(vi, vi->curr_queue_pairs);
+ */
 static int virtnet_set_queues(struct virtnet_info *vi, u16 queue_pairs)
 {
 	struct scatterlist sg;
@@ -1632,6 +1803,20 @@ static int virtnet_probe(struct virtio_device *vdev)
 	    || virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_ECN))
 		vi->big_packets = true;
 
+	/*
+	 * 在以下使用virtnet_info->mergeable_rx_bufs:
+	 *   - drivers/net/virtio_net.c|267| <<page_to_skb>> if (vi->mergeable_rx_bufs) {
+	 *   - drivers/net/virtio_net.c|397| <<receive_buf>> if (vi->mergeable_rx_bufs || vi->big_packets)
+	 *   - drivers/net/virtio_net.c|403| <<receive_buf>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|582| <<try_fill_recv>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|761| <<xmit_skb>> if (vi->mergeable_rx_bufs)
+	 *   - drivers/net/virtio_net.c|1380| <<free_unused_bufs>> if (vi->mergeable_rx_bufs || vi->big_packets)
+	 *   - drivers/net/virtio_net.c|1636| <<virtnet_probe>> vi->mergeable_rx_bufs = true;
+	 *
+	 * 例子
+	 * # cat /sys/bus/virtio/devices/virtio1/features 
+	 * 1100011111111111111101110000110000000000000000000000000000000000
+	 */
 	if (virtio_has_feature(vdev, VIRTIO_NET_F_MRG_RXBUF))
 		vi->mergeable_rx_bufs = true;
 
diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c
index a64a087b..5ab9827d 100644
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@ -47,6 +47,9 @@ static ssize_t features_show(struct device *_d,
 	len += sprintf(buf+len, "\n");
 	return len;
 }
+/*
+ * struct bus_type virtio_bus.dev_attrs = virtio_dev_attrs[]
+ */
 static struct device_attribute virtio_dev_attrs[] = {
 	__ATTR_RO(device),
 	__ATTR_RO(vendor),
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index 6de0ffae..22a01324 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -80,16 +80,57 @@ struct vring_virtqueue
 	bool broken;
 
 	/* Host supports indirect buffers */
+	/*
+	 * 在以下使用vring_virtqueue->indirect:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|263| <<virtqueue_add_buf>> if (vq->indirect)
+	 *   - drivers/virtio/virtio_ring.c|595| <<vring_new_virtqueue>> vq->indirect = virtio_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC);
+	 */
 	bool indirect;
 
 	/* Host publishes avail event idx */
 	bool event;
 
 	/* Number of free buffers */
+	/*
+	 * 在以下修改vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|150| <<vring_add_indirect>> vq->num_free--;
+	 *   - drivers/virtio/virtio_ring.c|227| <<virtqueue_add_buf>> vq->num_free -= out + in;
+	 *   - drivers/virtio/virtio_ring.c|346| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|352| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|603| <<vring_new_virtqueue>> vq->num_free = num;
+	 * 在以下使用vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|214| <<virtqueue_add_buf>> if (vq->num_free < out + in) {
+	 *   - drivers/virtio/virtio_ring.c|216| <<virtqueue_add_buf>> out + in, vq->num_free);
+	 *   - drivers/virtio/virtio_ring.c|264| <<virtqueue_add_buf>> return vq->num_free ? vq->vring.num : 0;
+	 *   - drivers/virtio/virtio_ring.c|265| <<virtqueue_add_buf>> return vq->num_free;
+	 *   - drivers/virtio/virtio_ring.c|532| <<virtqueue_detach_unused_buf>> BUG_ON(vq->num_free != vq->vring.num);
+	 */
 	unsigned int num_free;
 	/* Head of free buffer list. */
+	/*
+	 * 在以下修改vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|159| <<vring_add_indirect>> vq->free_head = vq->vring.desc[head].next;
+	 *   - drivers/virtio/virtio_ring.c|248| <<virtqueue_add_buf>> vq->free_head = i;
+	 *   - drivers/virtio/virtio_ring.c|350| <<detach_buf>> vq->free_head = head;
+	 *   - drivers/virtio/virtio_ring.c|604| <<vring_new_virtqueue>> vq->free_head = 0;
+	 *
+	 * 在以下使用vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|153| <<vring_add_indirect>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|229| <<virtqueue_add_buf>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|230| <<virtqueue_add_buf>> for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
+	 *   - drivers/virtio/virtio_ring.c|349| <<detach_buf>> vq->vring.desc[i].next = vq->free_head;
+	 */
 	unsigned int free_head;
 	/* Number we've added since last sync. */
+	/*
+	 * 在以下使用vring_virtqueue->num_added:
+	 *   - drivers/virtio/virtio_ring.c|373| <<virtqueue_add_buf>> avail = (vq->vring.avail->idx + vq->num_added++) % vq->vring.num;
+	 *   - drivers/virtio/virtio_ring.c|423| <<virtqueue_kick_prepare>> new = vq->vring.avail->idx = old + vq->num_added;
+	 *   - drivers/virtio/virtio_ring.c|424| <<virtqueue_kick_prepare>> vq->num_added = 0;
+	 *   - drivers/virtio/virtio_ring.c|889| <<vring_new_virtqueue>> vq->num_added = 0;
+	 */
 	unsigned int num_added;
 
 	/* Last used index we've seen. */
@@ -113,6 +154,10 @@ struct vring_virtqueue
 #define to_vvq(_vq) container_of(_vq, struct vring_virtqueue, vq)
 
 /* Set up an indirect table of descriptors and add it to the queue. */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|206| <<virtqueue_add_buf>> head = vring_add_indirect(vq, sg, out, in);
+ */
 static int vring_add_indirect(struct vring_virtqueue *vq,
 			      struct scatterlist sg[],
 			      unsigned int out,
@@ -147,6 +192,24 @@ static int vring_add_indirect(struct vring_virtqueue *vq,
 	desc[i-1].next = 0;
 
 	/* We're about to use a buffer */
+	/*
+	 * 在以下修改vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|150| <<vring_add_indirect>> vq->num_free--;
+	 *   - drivers/virtio/virtio_ring.c|227| <<virtqueue_add_buf>> vq->num_free -= out + in;
+	 *   - drivers/virtio/virtio_ring.c|346| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|352| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|603| <<vring_new_virtqueue>> vq->num_free = num;
+	 *
+	 * 在以下使用vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|214| <<virtqueue_add_buf>> if (vq->num_free < out + in) {
+	 *   - drivers/virtio/virtio_ring.c|216| <<virtqueue_add_buf>> out + in, vq->num_free);
+	 *   - drivers/virtio/virtio_ring.c|264| <<virtqueue_add_buf>> return vq->num_free ? vq->vring.num : 0;
+	 *   - drivers/virtio/virtio_ring.c|265| <<virtqueue_add_buf>> return vq->num_free;
+	 *   - drivers/virtio/virtio_ring.c|532| <<virtqueue_detach_unused_buf>> BUG_ON(vq->num_free != vq->vring.num);
+	 *
+	 * indirect的时候只需要一个entry (element):
+	 */
 	vq->num_free--;
 
 	/* Use a single buffer which doesn't continue */
@@ -156,11 +219,32 @@ static int vring_add_indirect(struct vring_virtqueue *vq,
 	vq->vring.desc[head].len = i * sizeof(struct vring_desc);
 
 	/* Update free pointer */
+	/*
+	 * 在以下修改vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|159| <<vring_add_indirect>> vq->free_head = vq->vring.desc[head].next;
+	 *   - drivers/virtio/virtio_ring.c|248| <<virtqueue_add_buf>> vq->free_head = i;
+	 *   - drivers/virtio/virtio_ring.c|350| <<detach_buf>> vq->free_head = head;
+	 *   - drivers/virtio/virtio_ring.c|604| <<vring_new_virtqueue>> vq->free_head = 0;
+	 *
+	 * 在以下使用vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|153| <<vring_add_indirect>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|229| <<virtqueue_add_buf>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|230| <<virtqueue_add_buf>> for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
+	 *   - drivers/virtio/virtio_ring.c|349| <<detach_buf>> vq->vring.desc[i].next = vq->free_head;
+	 */
 	vq->free_head = vq->vring.desc[head].next;
 
 	return head;
 }
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|192| <<vq2txq>> return (virtqueue_get_queue_index(vq) - 1) / 2;
+ *   - drivers/net/virtio_net.c|202| <<vq2rxq>> return virtqueue_get_queue_index(vq) / 2;
+ *   - drivers/scsi/virtio_scsi.c|236| <<virtscsi_req_done>> int index = virtqueue_get_queue_index(vq) - VIRTIO_SCSI_VQ_BASE;
+ *   - drivers/virtio/virtio_pci.c|187| <<vp_notify>> iowrite16(virtqueue_get_queue_index(vq),
+ *   - drivers/virtio/virtio_pci.c|456| <<vp_del_vq>> iowrite16(virtqueue_get_queue_index(vq),
+ */
 int virtqueue_get_queue_index(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -168,12 +252,34 @@ int virtqueue_get_queue_index(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_queue_index);
 
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|167| <<do_req>> if (virtqueue_add_buf(vblk->vq, vblk->sg, out, in, vbr) < 0) {
+ *   - drivers/char/hw_random/virtio-rng.c|54| <<register_buffer>> if (virtqueue_add_buf(vq, &sg, 0, 1, random_data) < 0)
+ *   - drivers/char/virtio_console.c|424| <<add_inbuf>> ret = virtqueue_add_buf(vq, sg, 0, 1, buf);
+ *   - drivers/char/virtio_console.c|491| <<__send_control_msg>> if (virtqueue_add_buf(vq, sg, 1, 0, &cpkt) >= 0) {
+ *   - drivers/char/virtio_console.c|541| <<__send_to_port>> ret = virtqueue_add_buf(out_vq, sg, nents, 0, data);
+ *   - drivers/net/virtio_net.c|513| <<add_recvbuf_small>> err = virtqueue_add_buf(rq->vq, rq->sg, 0, 2, skb);
+ *   - drivers/net/virtio_net.c|558| <<add_recvbuf_big>> err = virtqueue_add_buf(rq->vq, rq->sg, 0, MAX_SKB_FRAGS + 2,
+ *   - drivers/net/virtio_net.c|577| <<add_recvbuf_mergeable>> err = virtqueue_add_buf(rq->vq, rq->sg, 0, 1, page);
+ *   - drivers/net/virtio_net.c|792| <<xmit_skb>> return virtqueue_add_buf(sq->vq, sq->sg, hdr->num_sg,
+ *   - drivers/net/virtio_net.c|892| <<virtnet_send_command>> BUG_ON(virtqueue_add_buf(vi->cvq, sg, out, in, vi) < 0);
+ *   - drivers/scsi/virtio_scsi.c|316| <<virtscsi_kick_event>> ret = virtqueue_add_buf(vscsi->event_vq.vq, &sg, 0, 1, event_node);
+ *   - drivers/scsi/virtio_scsi.c|505| <<virtscsi_kick_cmd>> ret = virtqueue_add_buf(vq->vq, tgt->sg, out_num, in_num, cmd);
+ *   - drivers/virtio/virtio_balloon.c|109| <<tell_host>> if (virtqueue_add_buf(vq, &sg, 1, 0, vb) < 0)
+ *   - drivers/virtio/virtio_balloon.c|254| <<stats_handle_request>> if (virtqueue_add_buf(vq, &sg, 1, 0, vb) < 0)
+ *   - drivers/virtio/virtio_balloon.c|339| <<init_vqs>> if (virtqueue_add_buf(vb->stats_vq,
+ *   - net/9p/trans_virtio.c|203| <<p9_virtio_request>> if (virtqueue_add_buf(chan->vq, chan->sg, out, in, req->tc) < 0) {
+ */
 int virtqueue_add_buf(struct virtqueue *_vq,
 		  struct scatterlist sg[],
 		  unsigned int out,
 		  unsigned int in,
 		  void *data)
 {
+	/*
+	 * struct vring_virtqueue包含virtqueue
+	 */
 	struct vring_virtqueue *vq = to_vvq(_vq);
 	unsigned int i, avail, head, uninitialized_var(prev);
 
@@ -183,7 +289,16 @@ int virtqueue_add_buf(struct virtqueue *_vq,
 
 	/* If the host supports indirect descriptor tables, and we have multiple
 	 * buffers, then go indirect. FIXME: tune this threshold */
+	/*
+	 * 在以下使用vring_virtqueue->indirect:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|263| <<virtqueue_add_buf>> if (vq->indirect)
+	 *   - drivers/virtio/virtio_ring.c|595| <<vring_new_virtqueue>> vq->indirect = virtio_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC);
+	 */
 	if (vq->indirect && (out + in) > 1 && vq->num_free) {
+		/*
+		 * 只在这里被调用
+		 */
 		head = vring_add_indirect(vq, sg, out, in);
 		if (head != vq->vring.num)
 			goto add_head;
@@ -207,6 +322,19 @@ int virtqueue_add_buf(struct virtqueue *_vq,
 	/* We're about to use some buffers from the free list. */
 	vq->num_free -= out + in;
 
+	/*
+	 * 在以下修改vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|159| <<vring_add_indirect>> vq->free_head = vq->vring.desc[head].next;
+	 *   - drivers/virtio/virtio_ring.c|248| <<virtqueue_add_buf>> vq->free_head = i;
+	 *   - drivers/virtio/virtio_ring.c|350| <<detach_buf>> vq->free_head = head;
+	 *   - drivers/virtio/virtio_ring.c|604| <<vring_new_virtqueue>> vq->free_head = 0;
+	 *
+	 * 在以下使用vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|153| <<vring_add_indirect>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|229| <<virtqueue_add_buf>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|230| <<virtqueue_add_buf>> for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
+	 *   - drivers/virtio/virtio_ring.c|349| <<detach_buf>> vq->vring.desc[i].next = vq->free_head;
+	 */
 	head = vq->free_head;
 	for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
 		vq->vring.desc[i].flags = VRING_DESC_F_NEXT;
@@ -234,6 +362,21 @@ add_head:
 
 	/* Put entry in available array (but don't update avail->idx until they
 	 * do sync).  FIXME: avoid modulus here? */
+	/*
+	 * struct vring_virtqueue *vq:
+	 *  -> struct virtqueue vq;
+	 *  -> struct vring vring;
+	 *      -> unsigned int num;
+	 *      -> struct vring_desc *desc;
+	 *      -> struct vring_avail *avail;
+	 *	    -> __u16 flags;
+	 *	    -> __u16 idx;
+	 *	    -> __u16 ring[];
+	 *      -> struct vring_used *used;
+	 *	    -> __u16 flags;
+	 *	    -> __u16 idx;
+	 *	    -> struct vring_used_elem ring[];
+	 */
 	avail = (vq->vring.avail->idx + vq->num_added++) % vq->vring.num;
 	vq->vring.avail->ring[avail] = head;
 
@@ -241,12 +384,37 @@ add_head:
 	END_USE(vq);
 
 	/* If we're indirect, we can fit many (assuming not OOM). */
+	/*
+	 * indirect的话一个entry可以放入好多的entry, 所以有一个就行
+	 */
 	if (vq->indirect)
 		return vq->num_free ? vq->vring.num : 0;
+	/*
+	 * 在以下修改vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|150| <<vring_add_indirect>> vq->num_free--;
+	 *   - drivers/virtio/virtio_ring.c|227| <<virtqueue_add_buf>> vq->num_free -= out + in;
+	 *   - drivers/virtio/virtio_ring.c|346| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|352| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|603| <<vring_new_virtqueue>> vq->num_free = num;
+	 * 在以下使用vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|214| <<virtqueue_add_buf>> if (vq->num_free < out + in) {
+	 *   - drivers/virtio/virtio_ring.c|216| <<virtqueue_add_buf>> out + in, vq->num_free);
+	 *   - drivers/virtio/virtio_ring.c|264| <<virtqueue_add_buf>> return vq->num_free ? vq->vring.num : 0;
+	 *   - drivers/virtio/virtio_ring.c|265| <<virtqueue_add_buf>> return vq->num_free;
+	 *   - drivers/virtio/virtio_ring.c|532| <<virtqueue_detach_unused_buf>> BUG_ON(vq->num_free != vq->vring.num);
+	 */
 	return vq->num_free;
 }
 EXPORT_SYMBOL_GPL(virtqueue_add_buf);
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|508| <<virtscsi_kick_cmd>> ret = virtqueue_kick_prepare(vq->vq);
+ *   - drivers/virtio/virtio_ring.c|452| <<virtqueue_kick>> if (virtqueue_kick_prepare(vq))
+ *
+ * 当vq->event的时候不被VRING_USED_F_NO_NOTIFY影响
+ */
 bool virtqueue_kick_prepare(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -265,7 +433,18 @@ bool virtqueue_kick_prepare(struct virtqueue *_vq)
 	/* Need to update avail index before checking if we should notify */
 	virtio_mb();
 
+	/*
+	 * VIRTIO_RING_F_EVENT_IDX:
+	 *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+	 *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+	 *
+	 * vring_avail_event():
+	 *   返回used的最后一个元素, 告诉前端驱动后端处理到哪个avail ring上的元素了
+	 */
 	if (vq->event) {
+		/*
+		 * 相当于当event_idx + 1 > old的时候返回true
+		 */
 		needs_kick = vring_need_event(vring_avail_event(&vq->vring),
 					      new, old);
 	} else {
@@ -282,6 +461,11 @@ EXPORT_SYMBOL_GPL(virtqueue_kick_prepare);
  *
  * This does not need to be serialized.
  */
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|513| <<virtscsi_kick_cmd>> virtqueue_notify(vq->vq);
+ *   - drivers/virtio/virtio_ring.c|453| <<virtqueue_kick>> virtqueue_notify(vq);
+ */
 void virtqueue_notify(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -301,6 +485,22 @@ EXPORT_SYMBOL_GPL(virtqueue_notify);
  * Caller must ensure we don't call this with other virtqueue
  * operations at the same time (except where noted).
  */
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|195| <<do_virtblk_request>> virtqueue_kick(vblk->vq);
+ *   - drivers/char/hw_random/virtio-rng.c|57| <<register_buffer>> virtqueue_kick(vq);
+ *   - drivers/char/virtio_console.c|425| <<add_inbuf>> virtqueue_kick(vq);
+ *   - drivers/char/virtio_console.c|492| <<__send_control_msg>> virtqueue_kick(vq);
+ *   - drivers/char/virtio_console.c|544| <<__send_to_port>> virtqueue_kick(out_vq);
+ *   - drivers/net/virtio_net.c|701| <<try_fill_recv>> virtqueue_kick(rq->vq);
+ *   - drivers/net/virtio_net.c|951| <<start_xmit>> virtqueue_kick(sq->vq);
+ *   - drivers/net/virtio_net.c|1029| <<virtnet_send_command>> virtqueue_kick(vi->cvq);
+ *   - drivers/scsi/virtio_scsi.c|318| <<virtscsi_kick_event>> virtqueue_kick(vscsi->event_vq.vq);
+ *   - drivers/virtio/virtio_balloon.c|111| <<tell_host>> virtqueue_kick(vq);
+ *   - drivers/virtio/virtio_balloon.c|256| <<stats_handle_request>> virtqueue_kick(vq);
+ *   - drivers/virtio/virtio_balloon.c|342| <<init_vqs>> virtqueue_kick(vb->stats_vq);
+ *   - net/9p/trans_virtio.c|209| <<p9_virtio_request>> virtqueue_kick(chan->vq);
+ */
 void virtqueue_kick(struct virtqueue *vq)
 {
 	if (virtqueue_kick_prepare(vq))
@@ -308,6 +508,11 @@ void virtqueue_kick(struct virtqueue *vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_kick);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|523| <<virtqueue_get_buf>> detach_buf(vq, i);
+ *   - drivers/virtio/virtio_ring.c|653| <<virtqueue_detach_unused_buf>> detach_buf(vq, i);
+ */
 static void detach_buf(struct vring_virtqueue *vq, unsigned int head)
 {
 	unsigned int i;
@@ -328,16 +533,69 @@ static void detach_buf(struct vring_virtqueue *vq, unsigned int head)
 	}
 
 	vq->vring.desc[i].next = vq->free_head;
+	/*
+	 * 在以下修改vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|159| <<vring_add_indirect>> vq->free_head = vq->vring.desc[head].next;
+	 *   - drivers/virtio/virtio_ring.c|248| <<virtqueue_add_buf>> vq->free_head = i;
+	 *   - drivers/virtio/virtio_ring.c|350| <<detach_buf>> vq->free_head = head;
+	 *   - drivers/virtio/virtio_ring.c|604| <<vring_new_virtqueue>> vq->free_head = 0;
+	 *
+	 * 在以下使用vring_virtqueue->free_head:
+	 *   - drivers/virtio/virtio_ring.c|153| <<vring_add_indirect>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|229| <<virtqueue_add_buf>> head = vq->free_head;
+	 *   - drivers/virtio/virtio_ring.c|230| <<virtqueue_add_buf>> for (i = vq->free_head; out; i = vq->vring.desc[i].next, out--) {
+	 *   - drivers/virtio/virtio_ring.c|349| <<detach_buf>> vq->vring.desc[i].next = vq->free_head;
+	 */
 	vq->free_head = head;
 	/* Plus final descriptor */
+	/*
+	 * 在以下修改vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|150| <<vring_add_indirect>> vq->num_free--;
+	 *   - drivers/virtio/virtio_ring.c|227| <<virtqueue_add_buf>> vq->num_free -= out + in;
+	 *   - drivers/virtio/virtio_ring.c|346| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|352| <<detach_buf>> vq->num_free++;
+	 *   - drivers/virtio/virtio_ring.c|603| <<vring_new_virtqueue>> vq->num_free = num;
+	 * 在以下使用vring_virtqueue->num_free:
+	 *   - drivers/virtio/virtio_ring.c|205| <<virtqueue_add_buf>> if (vq->indirect && (out + in) > 1 && vq->num_free) {
+	 *   - drivers/virtio/virtio_ring.c|214| <<virtqueue_add_buf>> if (vq->num_free < out + in) {
+	 *   - drivers/virtio/virtio_ring.c|216| <<virtqueue_add_buf>> out + in, vq->num_free);
+	 *   - drivers/virtio/virtio_ring.c|264| <<virtqueue_add_buf>> return vq->num_free ? vq->vring.num : 0;
+	 *   - drivers/virtio/virtio_ring.c|265| <<virtqueue_add_buf>> return vq->num_free;
+	 *   - drivers/virtio/virtio_ring.c|532| <<virtqueue_detach_unused_buf>> BUG_ON(vq->num_free != vq->vring.num);
+	 */
 	vq->num_free++;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|579| <<virtqueue_get_buf>> if (!more_used(vq)) {
+ *   - drivers/virtio/virtio_ring.c|806| <<vring_interrupt>> if (!more_used(vq)) {
+ */
 static inline bool more_used(const struct vring_virtqueue *vq)
 {
 	return vq->last_used_idx != vq->vring.used->idx;
 }
 
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|65| <<blk_done>> while ((vbr = virtqueue_get_buf(vblk->vq, &len)) != NULL) {
+ *   - drivers/char/hw_random/virtio-rng.c|41| <<random_recv_done>> if (!virtqueue_get_buf(vq, &len))
+ *   - drivers/char/virtio_console.c|402| <<get_inbuf>> buf = virtqueue_get_buf(port->in_vq, &len);
+ *   - drivers/char/virtio_console.c|493| <<__send_control_msg>> while (!virtqueue_get_buf(vq, &len))
+ *   - drivers/char/virtio_console.c|520| <<reclaim_consumed_buffers>> while ((buf = virtqueue_get_buf(port->out_vq, &len))) {
+ *   - drivers/char/virtio_console.c|566| <<__send_to_port>> while (!virtqueue_get_buf(out_vq, &len))
+ *   - drivers/char/virtio_console.c|1647| <<control_work_handler>> while ((buf = virtqueue_get_buf(vq, &len))) {
+ *   - drivers/char/virtio_console.c|1854| <<remove_controlq_data>> while ((buf = virtqueue_get_buf(portdev->c_ivq, &len)))
+ *   - drivers/net/virtio_net.c|381| <<receive_mergeable>> page = virtqueue_get_buf(rq->vq, &len);
+ *   - drivers/net/virtio_net.c|400| <<receive_mergeable>> buf = virtqueue_get_buf(rq->vq, &len);
+ *   - drivers/net/virtio_net.c|691| <<virtnet_poll>> (buf = virtqueue_get_buf(rq->vq, &len)) != NULL) {
+ *   - drivers/net/virtio_net.c|740| <<free_old_xmit_skbs>> while ((skb = virtqueue_get_buf(sq->vq, &len)) != NULL) {
+ *   - drivers/net/virtio_net.c|946| <<virtnet_send_command>> while (!virtqueue_get_buf(vi->cvq, &tmp))
+ *   - drivers/scsi/virtio_scsi.c|226| <<virtscsi_vq_done>> while ((buf = virtqueue_get_buf(vq, &len)) != NULL)
+ *   - drivers/virtio/virtio_balloon.c|95| <<balloon_ack>> vb = virtqueue_get_buf(vq, &len);
+ *   - drivers/virtio/virtio_balloon.c|237| <<stats_request>> vb = virtqueue_get_buf(vq, &len);
+ *   - net/9p/trans_virtio.c|131| <<req_done>> while ((rc = virtqueue_get_buf(chan->vq, &len)) != NULL) {
+ */
 void *virtqueue_get_buf(struct virtqueue *_vq, unsigned int *len)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -389,10 +647,33 @@ void *virtqueue_get_buf(struct virtqueue *_vq, unsigned int *len)
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_buf);
 
+/*
+ * called by:
+ *   - drivers/char/virtio_console.c|2021| <<virtcons_freeze>> virtqueue_disable_cb(portdev->c_ivq);
+ *   - drivers/char/virtio_console.c|2027| <<virtcons_freeze>> virtqueue_disable_cb(portdev->c_ivq);
+ *   - drivers/char/virtio_console.c|2031| <<virtcons_freeze>> virtqueue_disable_cb(port->in_vq);
+ *   - drivers/char/virtio_console.c|2032| <<virtcons_freeze>> virtqueue_disable_cb(port->out_vq);
+ *   - drivers/net/virtio_net.c|281| <<skb_xmit_done>> virtqueue_disable_cb(vq);
+ *   - drivers/net/virtio_net.c|712| <<skb_recv_done>> virtqueue_disable_cb(rvq);
+ *   - drivers/net/virtio_net.c|726| <<virtnet_napi_enable>> virtqueue_disable_cb(rq->vq);
+ *   - drivers/net/virtio_net.c|792| <<virtnet_poll>> virtqueue_disable_cb(rq->vq);
+ *   - drivers/net/virtio_net.c|961| <<start_xmit>> virtqueue_disable_cb(sq->vq);
+ *   - drivers/net/virtio_net.c|1934| <<virtnet_freeze>> virtqueue_disable_cb(vi->cvq);
+ *   - drivers/scsi/virtio_scsi.c|225| <<virtscsi_vq_done>> virtqueue_disable_cb(vq);
+ */
 void virtqueue_disable_cb(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
 
+	/*
+	 * 在以下使用VRING_AVAIL_F_NO_INTERRUPT:
+	 *   - drivers/vhost/vhost.c|1467| <<vhost_notify>> return !(flags & VRING_AVAIL_F_NO_INTERRUPT);
+	 *   - drivers/virtio/virtio_ring.c|528| <<virtqueue_get_buf>> if (!(vq->vring.avail->flags & VRING_AVAIL_F_NO_INTERRUPT)) {
+	 *   - drivers/virtio/virtio_ring.c|542| <<virtqueue_disable_cb>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|570| <<virtqueue_enable_cb_prepare>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|625| <<virtqueue_enable_cb_delayed>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|739| <<vring_new_virtqueue>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+	 */
 	vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
 }
 EXPORT_SYMBOL_GPL(virtqueue_disable_cb);
@@ -409,6 +690,11 @@ EXPORT_SYMBOL_GPL(virtqueue_disable_cb);
  * Caller must ensure we don't call this with other virtqueue
  * operations at the same time (except where noted).
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|788| <<virtnet_poll>> r = virtqueue_enable_cb_prepare(rq->vq);
+ *   - drivers/virtio/virtio_ring.c|689| <<virtqueue_enable_cb>> unsigned last_used_idx = virtqueue_enable_cb_prepare(_vq);
+ */
 unsigned virtqueue_enable_cb_prepare(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -437,6 +723,11 @@ EXPORT_SYMBOL_GPL(virtqueue_enable_cb_prepare);
  *
  * This does not need to be serialized.
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|790| <<virtnet_poll>> if (unlikely(virtqueue_poll(rq->vq, r)) &&
+ *   - drivers/virtio/virtio_ring.c|662| <<virtqueue_enable_cb>> return !virtqueue_poll(_vq, last_used_idx);
+ */
 bool virtqueue_poll(struct virtqueue *_vq, unsigned last_used_idx)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -457,6 +748,10 @@ EXPORT_SYMBOL_GPL(virtqueue_poll);
  * Caller must ensure we don't call this with other virtqueue
  * operations at the same time (except where noted).
  */
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|228| <<virtscsi_vq_done>> } while (!virtqueue_enable_cb(vq));
+ */
 bool virtqueue_enable_cb(struct virtqueue *_vq)
 {
 	unsigned last_used_idx = virtqueue_enable_cb_prepare(_vq);
@@ -464,6 +759,10 @@ bool virtqueue_enable_cb(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_enable_cb);
 
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|961| <<start_xmit>> if (unlikely(!virtqueue_enable_cb_delayed(sq->vq))) {
+ */
 bool virtqueue_enable_cb_delayed(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -491,6 +790,15 @@ bool virtqueue_enable_cb_delayed(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_enable_cb_delayed);
 
+/*
+ * called by:
+ *   - drivers/char/virtio_console.c|1402| <<add_port>> while ((buf = virtqueue_detach_unused_buf(port->in_vq)))
+ *   - drivers/char/virtio_console.c|1435| <<remove_port_data>> while ((buf = virtqueue_detach_unused_buf(port->in_vq)))
+ *   - drivers/char/virtio_console.c|1443| <<remove_port_data>> while ((buf = virtqueue_detach_unused_buf(port->out_vq)))
+ *   - drivers/char/virtio_console.c|1857| <<remove_controlq_data>> while ((buf = virtqueue_detach_unused_buf(portdev->c_ivq)))
+ *   - drivers/net/virtio_net.c|1537| <<free_unused_bufs>> while ((buf = virtqueue_detach_unused_buf(vq)) != NULL)
+ *   - drivers/net/virtio_net.c|1544| <<free_unused_bufs>> while ((buf = virtqueue_detach_unused_buf(vq)) != NULL) {
+ */
 void *virtqueue_detach_unused_buf(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -517,6 +825,13 @@ void *virtqueue_detach_unused_buf(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_detach_unused_buf);
 
+/*
+ * called by:
+ *   - drivers/lguest/lguest_device.c|306| <<lg_find_vq>> err = request_irq(lvq->config.irq, vring_interrupt, IRQF_SHARED,
+ *   - drivers/s390/kvm/kvm_virtio.c|358| <<kvm_extint_handler>> vring_interrupt(0, vq);
+ *   - drivers/virtio/virtio_pci.c|210| <<vp_vring_interrupt>> if (vring_interrupt(irq, info->vq) == IRQ_HANDLED)
+ *   - drivers/virtio/virtio_pci.c|553| <<vp_try_to_find_vqs>> vring_interrupt, 0,
+ */
 irqreturn_t vring_interrupt(int irq, void *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -537,6 +852,12 @@ irqreturn_t vring_interrupt(int irq, void *_vq)
 }
 EXPORT_SYMBOL_GPL(vring_interrupt);
 
+/*
+ * called by:
+ *   - drivers/lguest/lguest_device.c|288| <<lg_find_vq>> vq = vring_new_virtqueue(index, lvq->config.num, LGUEST_VRING_ALIGN, vdev,
+ *   - drivers/s390/kvm/kvm_virtio.c|196| <<kvm_find_vq>> vq = vring_new_virtqueue(index, config->num, KVM_S390_VIRTIO_RING_ALIGN,
+ *   - drivers/virtio/virtio_pci.c|411| <<setup_vq>> vq = vring_new_virtqueue(index, info->num, VIRTIO_PCI_VRING_ALIGN, vdev,
+ */
 struct virtqueue *vring_new_virtqueue(unsigned int index,
 				      unsigned int num,
 				      unsigned int vring_align,
@@ -559,6 +880,12 @@ struct virtqueue *vring_new_virtqueue(unsigned int index,
 	if (!vq)
 		return NULL;
 
+	/*
+	 * vring_align是VIRTIO_PCI_VRING_ALIGN:
+	 *   - drivers/virtio/virtio_pci.c|399| <<setup_vq>> size = PAGE_ALIGN(vring_size(num, VIRTIO_PCI_VRING_ALIGN));
+	 *   - drivers/virtio/virtio_pci.c|411| <<setup_vq>> vq = vring_new_virtqueue(index, info->num, VIRTIO_PCI_VRING_ALIGN, vdev,
+	 *   - drivers/virtio/virtio_pci.c|471| <<vp_del_vq>> size = PAGE_ALIGN(vring_size(info->num, VIRTIO_PCI_VRING_ALIGN));
+	 */
 	vring_init(&vq->vring, num, pages, vring_align);
 	vq->vq.callback = callback;
 	vq->vq.vdev = vdev;
@@ -577,6 +904,15 @@ struct virtqueue *vring_new_virtqueue(unsigned int index,
 	vq->event = virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);
 
 	/* No callback?  Tell other side not to bother us. */
+	/*
+	 * 在以下使用VRING_AVAIL_F_NO_INTERRUPT:
+	 *   - drivers/vhost/vhost.c|1467| <<vhost_notify>> return !(flags & VRING_AVAIL_F_NO_INTERRUPT);
+	 *   - drivers/virtio/virtio_ring.c|528| <<virtqueue_get_buf>> if (!(vq->vring.avail->flags & VRING_AVAIL_F_NO_INTERRUPT)) {
+	 *   - drivers/virtio/virtio_ring.c|542| <<virtqueue_disable_cb>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|570| <<virtqueue_enable_cb_prepare>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|625| <<virtqueue_enable_cb_delayed>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|739| <<vring_new_virtqueue>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+	 */
 	if (!callback)
 		vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
 
@@ -593,6 +929,14 @@ struct virtqueue *vring_new_virtqueue(unsigned int index,
 }
 EXPORT_SYMBOL_GPL(vring_new_virtqueue);
 
+/*
+ * called by:
+ *   - drivers/lguest/lguest_device.c|319| <<lg_find_vq>> vring_del_virtqueue(vq);
+ *   - drivers/lguest/lguest_device.c|336| <<lg_del_vq>> vring_del_virtqueue(vq);
+ *   - drivers/s390/kvm/kvm_virtio.c|224| <<kvm_del_vq>> vring_del_virtqueue(vq);
+ *   - drivers/virtio/virtio_pci.c|437| <<setup_vq>> vring_del_virtqueue(vq);
+ *   - drivers/virtio/virtio_pci.c|466| <<vp_del_vq>> vring_del_virtqueue(vq);
+ */
 void vring_del_virtqueue(struct virtqueue *vq)
 {
 	list_del(&vq->list);
@@ -601,6 +945,12 @@ void vring_del_virtqueue(struct virtqueue *vq)
 EXPORT_SYMBOL_GPL(vring_del_virtqueue);
 
 /* Manipulates transport-specific feature bits. */
+/*
+ * called by:
+ *   - drivers/lguest/lguest_device.c|124| <<lg_finalize_features>> vring_transport_features(vdev);
+ *   - drivers/s390/kvm/kvm_virtio.c|99| <<kvm_finalize_features>> vring_transport_features(vdev);
+ *   - drivers/virtio/virtio_pci.c|122| <<vp_finalize_features>> vring_transport_features(vdev);
+ */
 void vring_transport_features(struct virtio_device *vdev)
 {
 	unsigned int i;
diff --git a/include/linux/virtio.h b/include/linux/virtio.h
index 7fcf33a9..386286e8 100644
--- a/include/linux/virtio.h
+++ b/include/linux/virtio.h
@@ -143,6 +143,17 @@ void virtio_config_changed(struct virtio_device *dev);
 struct virtio_driver {
 	struct device_driver driver;
 	const struct virtio_device_id *id_table;
+	/*
+	 * 在以下使用virtio_driver->features_table[]:
+	 *   - drivers/block/virtio_blk.c|632| <<global>> .feature_table = features,
+	 *   - drivers/char/virtio_console.c|2081| <<global>> .feature_table = features,
+	 *   - drivers/net/virtio_net.c|1870| <<global>> .feature_table = features,
+	 *   - drivers/scsi/virtio_scsi.c|1036| <<global>> .feature_table = features,
+	 *   - drivers/virtio/virtio_balloon.c|444| <<global>> .feature_table = features,
+	 *   - drivers/virtio/virtio.c|107| <<virtio_check_driver_offered_feature>> if (drv->feature_table[i] == fbit)
+	 *   - drivers/virtio/virtio.c|168| <<virtio_dev_probe>> unsigned int f = drv->feature_table[i];
+	 *   - drivers/virtio/virtio.c|223| <<register_virtio_driver>> BUG_ON(driver->feature_table_size && !driver->feature_table);
+	 */
 	const unsigned int *feature_table;
 	unsigned int feature_table_size;
 	int (*probe)(struct virtio_device *dev);
diff --git a/include/linux/virtio_pci.h b/include/linux/virtio_pci.h
index 9a3d7c48..075496d9 100644
--- a/include/linux/virtio_pci.h
+++ b/include/linux/virtio_pci.h
@@ -68,5 +68,11 @@
 
 /* The alignment to use between consumer and producer parts of vring.
  * x86 pagesize again. */
+/*
+ * 在以下使用VIRTIO_PCI_VRING_ALIGN:
+ *   - drivers/virtio/virtio_pci.c|399| <<setup_vq>> size = PAGE_ALIGN(vring_size(num, VIRTIO_PCI_VRING_ALIGN));
+ *   - drivers/virtio/virtio_pci.c|411| <<setup_vq>> vq = vring_new_virtqueue(index, info->num, VIRTIO_PCI_VRING_ALIGN, vdev,
+ *   - drivers/virtio/virtio_pci.c|471| <<vp_del_vq>> size = PAGE_ALIGN(vring_size(info->num, VIRTIO_PCI_VRING_ALIGN));
+ */
 #define VIRTIO_PCI_VRING_ALIGN		4096
 #endif
diff --git a/include/linux/virtio_ring.h b/include/linux/virtio_ring.h
index e86e134f..1d73d435 100644
--- a/include/linux/virtio_ring.h
+++ b/include/linux/virtio_ring.h
@@ -13,6 +13,13 @@
 /* This marks a buffer as continuing via the next field. */
 #define VRING_DESC_F_NEXT	1
 /* This marks a buffer as write-only (otherwise read-only). */
+/*
+ * 在以下使用VRING_DESC_F_WRITE:
+ *   - drivers/vhost/vhost.c|1174| <<get_indirect>> if (desc.flags & VRING_DESC_F_WRITE) {
+ *   - drivers/vhost/vhost.c|1295| <<vhost_get_vq_desc>> if (desc.flags & VRING_DESC_F_WRITE) {
+ *   - drivers/virtio/virtio_ring.c|176| <<vring_add_indirect>> desc[i].flags = VRING_DESC_F_NEXT|VRING_DESC_F_WRITE;
+ *   - drivers/virtio/virtio_ring.c|332| <<virtqueue_add_buf>> vq->vring.desc[i].flags = VRING_DESC_F_NEXT|VRING_DESC_F_WRITE;
+ */
 #define VRING_DESC_F_WRITE	2
 /* This means the buffer contains a list of buffer descriptors. */
 #define VRING_DESC_F_INDIRECT	4
@@ -20,10 +27,28 @@
 /* The Host uses this in used->flags to advise the Guest: don't kick me when
  * you add a buffer.  It's unreliable, so it's simply an optimization.  Guest
  * will still kick if it's out of buffers. */
+/*
+ * 在以下使用VRING_USED_F_NO_NOTIFY:
+ *   - drivers/vhost/vhost.c|1321| <<vhost_get_vq_desc>> BUG_ON(!(vq->used_flags & VRING_USED_F_NO_NOTIFY));
+ *   - drivers/vhost/vhost.c|1515| <<vhost_enable_notify>> if (!(vq->used_flags & VRING_USED_F_NO_NOTIFY))
+ *   - drivers/vhost/vhost.c|1517| <<vhost_enable_notify>> vq->used_flags &= ~VRING_USED_F_NO_NOTIFY;
+ *   - drivers/vhost/vhost.c|1550| <<vhost_disable_notify>> if (vq->used_flags & VRING_USED_F_NO_NOTIFY)
+ *   - drivers/vhost/vhost.c|1552| <<vhost_disable_notify>> vq->used_flags |= VRING_USED_F_NO_NOTIFY;
+ *   - drivers/virtio/virtio_ring.c|418| <<virtqueue_kick_prepare>> needs_kick = !(vq->vring.used->flags & VRING_USED_F_NO_NOTIFY);
+ */
 #define VRING_USED_F_NO_NOTIFY	1
 /* The Guest uses this in avail->flags to advise the Host: don't interrupt me
  * when you consume a buffer.  It's unreliable, so it's simply an
  * optimization.  */
+/*
+ * 在以下使用VRING_AVAIL_F_NO_INTERRUPT:
+ *   - drivers/vhost/vhost.c|1467| <<vhost_notify>> return !(flags & VRING_AVAIL_F_NO_INTERRUPT);
+ *   - drivers/virtio/virtio_ring.c|528| <<virtqueue_get_buf>> if (!(vq->vring.avail->flags & VRING_AVAIL_F_NO_INTERRUPT)) {
+ *   - drivers/virtio/virtio_ring.c|542| <<virtqueue_disable_cb>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+ *   - drivers/virtio/virtio_ring.c|570| <<virtqueue_enable_cb_prepare>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+ *   - drivers/virtio/virtio_ring.c|625| <<virtqueue_enable_cb_delayed>> vq->vring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+ *   - drivers/virtio/virtio_ring.c|739| <<vring_new_virtqueue>> vq->vring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+ */
 #define VRING_AVAIL_F_NO_INTERRUPT	1
 
 /* We support indirect buffer descriptors */
@@ -33,6 +58,20 @@
  * at the end of the avail ring. Host should ignore the avail->flags field. */
 /* The Host publishes the avail index for which it expects a kick
  * at the end of the used ring. Guest should ignore the used->flags field. */
+/*
+ * 在以下使用VIRTIO_RING_F_EVENT_IDX:
+ *   - drivers/vhost/vhost.c|566| <<vq_access_ok>> size_t s = vhost_has_feature(d, VIRTIO_RING_F_EVENT_IDX) ? 2 : 0;
+ *   - drivers/vhost/vhost.c|586| <<vq_log_access_ok>> size_t s = vhost_has_feature(d, VIRTIO_RING_F_EVENT_IDX) ? 2 : 0;
+ *   - drivers/vhost/vhost.c|1461| <<vhost_notify>> if (!vhost_has_feature(dev, VIRTIO_RING_F_EVENT_IDX)) {
+ *   - drivers/vhost/vhost.c|1518| <<vhost_enable_notify>> if (!vhost_has_feature(dev, VIRTIO_RING_F_EVENT_IDX)) {
+ *   - drivers/vhost/vhost.c|1553| <<vhost_disable_notify>> if (!vhost_has_feature(dev, VIRTIO_RING_F_EVENT_IDX)) {
+ *   - drivers/virtio/virtio_ring.c|723| <<vring_new_virtqueue>> vq->event = virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);
+ *   - drivers/virtio/virtio_ring.c|758| <<vring_transport_features>> case VIRTIO_RING_F_EVENT_IDX:
+ *
+ * VIRTIO_RING_F_EVENT_IDX:
+ *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+ *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+ */
 #define VIRTIO_RING_F_EVENT_IDX		29
 
 /* Virtio ring descriptors: 16 bytes.  These can chain together via "next". */
@@ -103,21 +142,80 @@ struct vring {
  */
 /* We publish the used event index at the end of the available ring, and vice
  * versa. They are at the end for backwards compatibility. */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|529| <<virtqueue_get_buf>> vring_used_event(&vq->vring) = vq->last_used_idx;
+ *   - drivers/virtio/virtio_ring.c|571| <<virtqueue_enable_cb_prepare>> vring_used_event(&vq->vring) = last_used_idx = vq->last_used_idx;
+ *   - drivers/virtio/virtio_ring.c|628| <<virtqueue_enable_cb_delayed>> vring_used_event(&vq->vring) = vq->last_used_idx + bufs;
+ */
 #define vring_used_event(vr) ((vr)->avail->ring[(vr)->num])
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|415| <<virtqueue_kick_prepare>> needs_kick = vring_need_event(vring_avail_event(&vq->vring),
+ */
 #define vring_avail_event(vr) (*(__u16 *)&(vr)->used->ring[(vr)->num])
 
+/*
+ * vring_align是VIRTIO_PCI_VRING_ALIGN: 4096
+ *
+ * 假设p = 0xffff8800b4c44000, num = 256
+ *
+ * vr->desc = 0xffff8800b4c44000
+ * vr->avail = p + 0x10 * 256 = p + 4096 = 0xffff8800b4c45000
+ * vr->used = 0xffff8800b4c46000
+ */
 static inline void vring_init(struct vring *vr, unsigned int num, void *p,
 			      unsigned long align)
 {
 	vr->num = num;
 	vr->desc = p;
 	vr->avail = p + num*sizeof(struct vring_desc);
+	/*
+	 * align是VIRTIO_PCI_VRING_ALIGN: 4096
+	 *
+	 * struct vring *vr:
+	 *  -> struct vring_avail *avail;
+	 *      -> __u16 flags;
+	 *      -> __u16 idx;
+	 *      -> __u16 ring[];
+	 */
 	vr->used = (void *)(((unsigned long)&vr->avail->ring[num] + align-1)
 			    & ~(align - 1));
 }
 
+/*
+ * called by:
+ *   - drivers/lguest/lguest_device.c|276| <<lg_find_vq>> DIV_ROUND_UP(vring_size(lvq->config.num,
+ *   - drivers/s390/kvm/kvm_virtio.c|191| <<kvm_find_vq>> vring_size(config->num,
+ *   - drivers/s390/kvm/kvm_virtio.c|214| <<kvm_find_vq>> vring_size(config->num,
+ *   - drivers/s390/kvm/kvm_virtio.c|226| <<kvm_del_vq>> vring_size(config->num,
+ *   - drivers/virtio/virtio_pci.c|399| <<setup_vq>> size = PAGE_ALIGN(vring_size(num, VIRTIO_PCI_VRING_ALIGN));
+ *   - drivers/virtio/virtio_pci.c|471| <<vp_del_vq>> size = PAGE_ALIGN(vring_size(info->num, VIRTIO_PCI_VRING_ALIGN));
+ */
 static inline unsigned vring_size(unsigned int num, unsigned long align)
 {
+	/*
+	 * struct vring {
+	 *     unsigned int num;
+	 *     struct vring_desc *desc;
+	 *     struct vring_avail *avail;
+	 *         __u16 flags;
+	 *         __u16 idx;
+	 *         __u16 ring[];
+	 *     struct vring_used *used;
+	 *         __u16 flags;
+	 *         __u16 idx;
+	 *         struct vring_used_elem ring[];
+	 *
+	 *
+	 *  - sizeof(struct vring_desc) * num
+	 *  - sizeof(__u16) * (2 + num) ---> 不明白为什么不是3!!!
+	 *  ... align ...  ----> align是VIRTIO_PCI_VRING_ALIGN: 4096
+	 *  - sizeof(__u16) * 3 + sizeof(struct vring_used_elem) * num
+	 * };
+	 *
+	 * !!! align是VIRTIO_PCI_VRING_ALIGN: 4096 !!!
+	 */
 	return ((sizeof(struct vring_desc) * num + sizeof(__u16) * (2 + num)
 		 + align - 1) & ~(align - 1))
 		+ sizeof(__u16) * 3 + sizeof(struct vring_used_elem) * num;
@@ -127,6 +225,13 @@ static inline unsigned vring_size(unsigned int num, unsigned long align)
 /* Assuming a given event_idx value from the other size, if
  * we have just incremented index from old to new_idx,
  * should we trigger an event? */
+/*
+ * called by:
+ *   - drivers/vhost/vhost.c|1481| <<vhost_notify>> return vring_need_event(event, new, old);
+ *   - drivers/virtio/virtio_ring.c|415| <<virtqueue_kick_prepare>> needs_kick = vring_need_event(vring_avail_event(&vq->vring),
+ *
+ * 相当于当event_idx + 1 > old的时候返回true
+ */
 static inline int vring_need_event(__u16 event_idx, __u16 new_idx, __u16 old)
 {
 	/* Note: Xen has similar logic for notification hold-off
-- 
2.17.1

