From d79996b972ea6a5d708ee23a4480b4aea15deb7f Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 19 Sep 2022 09:59:13 -0700
Subject: [PATCH 1/1] qemu for v7.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/accel-softmmu.c           |  13 +++
 accel/dummy-cpus.c              |   4 +
 accel/kvm/kvm-accel-ops.c       |   8 ++
 accel/kvm/kvm-all.c             |  31 ++++++
 backends/hostmem-ram.c          |   7 ++
 block/file-posix.c              |   8 ++
 hw/block/virtio-blk.c           |  10 ++
 hw/core/qdev-properties.c       |  30 ++++++
 hw/i386/intel_iommu.c           |  33 ++++++
 hw/isa/piix3.c                  |  46 ++++++++
 hw/net/vhost_net.c              |   4 +
 hw/net/virtio-net.c             |   5 +
 hw/pci/pci.c                    |   4 +
 hw/scsi/virtio-scsi-dataplane.c |   4 +
 hw/virtio/virtio.c              |  13 +++
 include/exec/memory.h           |  38 +++++++
 include/hw/qdev-core.h          |  15 +++
 monitor/hmp.c                   |   7 ++
 monitor/monitor.c               |  11 ++
 qom/object.c                    |  92 ++++++++++++++++
 softmmu/cpus.c                  |  27 +++++
 softmmu/memory.c                | 183 ++++++++++++++++++++++++++++++++
 softmmu/physmem.c               |  16 +++
 stubs/trace-control.c           |   7 ++
 target/i386/cpu.c               | 170 +++++++++++++++++++++++++++++
 target/i386/helper.c            |  10 ++
 target/i386/host-cpu.c          |   4 +
 target/i386/kvm/kvm.c           |  75 +++++++++++++
 trace/control.c                 |  27 +++++
 trace/qmp.c                     |   4 +
 trace/simple.c                  |  19 ++++
 util/log.c                      | 119 +++++++++++++++++++++
 32 files changed, 1044 insertions(+)

diff --git a/accel/accel-softmmu.c b/accel/accel-softmmu.c
index 67276e4f5..c081b6ea3 100644
--- a/accel/accel-softmmu.c
+++ b/accel/accel-softmmu.c
@@ -47,6 +47,19 @@ int accel_init_machine(AccelState *accel, MachineState *ms)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|249| <<kvm_get_max_memslots>> KVMState *s = KVM_STATE(current_accel());
+ *   - accel/kvm/kvm-all.c|2312| <<kvm_vcpu_id_is_valid>> KVMState *s = KVM_STATE(current_accel());
+ *   - accel/tcg/tcg-all.c|115| <<tcg_init_machine>> TCGState *s = TCG_STATE(current_accel());
+ *   - bsd-user/main.c|454| <<main>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - hw/ppc/pef.c|85| <<kvmppc_svm_off>> rc = kvm_vm_ioctl(KVM_STATE(current_accel()), KVM_PPC_SVM_OFF);
+ *   - linux-user/main.c|738| <<main>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - softmmu/memory.c|3338| <<mtree_info_flatview>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - softmmu/vl.c|2427| <<configure_accelerators>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - target/i386/kvm/kvm.c|171| <<kvm_x2apic_api_set_flags>> KVMState *s = KVM_STATE(current_accel());
+ *   - target/ppc/kvm.c|268| <<kvm_get_radix_page_info>> KVMState *s = KVM_STATE(current_accel());
+ */
 AccelState *current_accel(void)
 {
     return current_machine->accelerator;
diff --git a/accel/dummy-cpus.c b/accel/dummy-cpus.c
index 10429fdfb..e2cdf195a 100644
--- a/accel/dummy-cpus.c
+++ b/accel/dummy-cpus.c
@@ -58,6 +58,10 @@ static void *dummy_cpu_thread_fn(void *arg)
     return NULL;
 }
 
+/*
+ * 在以下使用dummy_start_vcpu_thread():
+ *   - accel/qtest/qtest.c|53| <<qtest_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+ */
 void dummy_start_vcpu_thread(CPUState *cpu)
 {
     char thread_name[VCPU_THREAD_NAME_SIZE];
diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index c4244a23c..231c7ec11 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -24,6 +24,10 @@
 
 #include "kvm-cpus.h"
 
+/*
+ * 在以下使用kvm_vcpu_thread_fn():
+ *   - accel/kvm/kvm-accel-ops.c|77| <<kvm_start_vcpu_thread>> qemu_thread_create(cpu->thread, thread_name, kvm_vcpu_thread_fn,
+ */
 static void *kvm_vcpu_thread_fn(void *arg)
 {
     CPUState *cpu = arg;
@@ -61,6 +65,10 @@ static void *kvm_vcpu_thread_fn(void *arg)
     return NULL;
 }
 
+/*
+ * 在以下使用kvm_start_vcpu_thread():
+ *   - accel/kvm/kvm-accel-ops.c|91| <<kvm_accel_ops_class_init>> ops->create_vcpu_thread = kvm_start_vcpu_thread;
+ */
 static void kvm_start_vcpu_thread(CPUState *cpu)
 {
     char thread_name[VCPU_THREAD_NAME_SIZE];
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 5f1377ca0..f332a468f 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -431,6 +431,10 @@ err:
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|57| <<kvm_vcpu_thread_fn>> kvm_destroy_vcpu(cpu);
+ */
 void kvm_destroy_vcpu(CPUState *cpu)
 {
     if (do_kvm_destroy_vcpu(cpu) < 0) {
@@ -439,6 +443,10 @@ void kvm_destroy_vcpu(CPUState *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|468| <<kvm_init_vcpu>> ret = kvm_get_vcpu(s, kvm_arch_vcpu_id(cpu));
+ */
 static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id)
 {
     struct KVMParkedVcpu *cpu;
@@ -457,6 +465,10 @@ static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id)
     return kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)vcpu_id);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|40| <<kvm_vcpu_thread_fn>> r = kvm_init_vcpu(cpu, &error_fatal);
+ */
 int kvm_init_vcpu(CPUState *cpu, Error **errp)
 {
     KVMState *s = kvm_state;
@@ -2785,6 +2797,13 @@ void kvm_cpu_synchronize_pre_loadvm(CPUState *cpu)
 #ifdef KVM_HAVE_MCE_INJECTION
 static __thread void *pending_sigbus_addr;
 static __thread int pending_sigbus_code;
+/*
+ * 在以下使用have_sigbus_pending:
+ *   - accel/kvm/kvm-all.c|2900| <<kvm_cpu_exec>> if (unlikely(have_sigbus_pending)) {
+ *   - accel/kvm/kvm-all.c|2904| <<kvm_cpu_exec>> have_sigbus_pending = false;
+ *   - accel/kvm/kvm-all.c|3437| <<kvm_on_sigbus_vcpu>> if (have_sigbus_pending) {
+ *   - accel/kvm/kvm-all.c|3440| <<kvm_on_sigbus_vcpu>> have_sigbus_pending = true;
+ */
 static __thread bool have_sigbus_pending;
 #endif
 
@@ -2837,6 +2856,10 @@ static void kvm_eat_signals(CPUState *cpu)
     } while (sigismember(&chkset, SIG_IPI));
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|49| <<kvm_vcpu_thread_fn>> r = kvm_cpu_exec(cpu);
+ */
 int kvm_cpu_exec(CPUState *cpu)
 {
     struct kvm_run *run = cpu->kvm_run;
@@ -3411,6 +3434,10 @@ void kvm_init_cpu_signals(CPUState *cpu)
 }
 
 /* Called asynchronously in VCPU thread.  */
+/*
+ * called by:
+ *   - softmmu/cpus.c|341| <<sigbus_handler>> if (kvm_on_sigbus_vcpu(current_cpu, siginfo->si_code, siginfo->si_addr)) {
+ */
 int kvm_on_sigbus_vcpu(CPUState *cpu, int code, void *addr)
 {
 #ifdef KVM_HAVE_MCE_INJECTION
@@ -3428,6 +3455,10 @@ int kvm_on_sigbus_vcpu(CPUState *cpu, int code, void *addr)
 }
 
 /* Called synchronously (via signalfd) in main thread.  */
+/*
+ * called by:
+ *   - softmmu/cpus.c|346| <<sigbus_handler>> if (kvm_on_sigbus(siginfo->si_code, siginfo->si_addr)) {
+ */
 int kvm_on_sigbus(int code, void *addr)
 {
 #ifdef KVM_HAVE_MCE_INJECTION
diff --git a/backends/hostmem-ram.c b/backends/hostmem-ram.c
index b8e55cdbd..3e3ccda47 100644
--- a/backends/hostmem-ram.c
+++ b/backends/hostmem-ram.c
@@ -16,6 +16,10 @@
 #include "qemu/module.h"
 #include "qom/object_interfaces.h"
 
+/*
+ * 在以下使用ram_backend_memory_alloc():
+ *   - backends/hostmem-ram.c|43| <<ram_backend_class_init>> bc->alloc = ram_backend_memory_alloc;
+ */
 static void
 ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
@@ -43,6 +47,9 @@ ram_backend_class_init(ObjectClass *oc, void *data)
     bc->alloc = ram_backend_memory_alloc;
 }
 
+/*
+ * parent是host_memory_backend_info
+ */
 static const TypeInfo ram_backend_info = {
     .name = TYPE_MEMORY_BACKEND_RAM,
     .parent = TYPE_MEMORY_BACKEND,
diff --git a/block/file-posix.c b/block/file-posix.c
index 39a3d6dbe..70c172bc2 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -1176,6 +1176,10 @@ static void raw_reopen_abort(BDRVReopenState *state)
     s->reopen_state = NULL;
 }
 
+/*
+ * called by:
+ *   - block/file-posix.c|1285| <<raw_refresh_limits>> int ret = hdev_get_max_hw_transfer(s->fd, &st);
+ */
 static int hdev_get_max_hw_transfer(int fd, struct stat *st)
 {
 #ifdef BLKSECTGET
@@ -1196,6 +1200,10 @@ static int hdev_get_max_hw_transfer(int fd, struct stat *st)
 #endif
 }
 
+/*
+ * called by:
+ *   - block/file-posix.c|1291| <<raw_refresh_limits>> ret = hdev_get_max_segments(s->fd, &st);
+ */
 static int hdev_get_max_segments(int fd, struct stat *st)
 {
 #ifdef CONFIG_LINUX
diff --git a/hw/block/virtio-blk.c b/hw/block/virtio-blk.c
index 540c38f82..a0c13275c 100644
--- a/hw/block/virtio-blk.c
+++ b/hw/block/virtio-blk.c
@@ -819,6 +819,12 @@ static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
     virtio_blk_handle_vq(s, vq);
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|236| <<virtio_blk_data_plane_start>> virtio_blk_process_queued_requests(vblk, false);
+ *   - hw/block/dataplane/virtio-blk.c|274| <<virtio_blk_data_plane_start>> virtio_blk_process_queued_requests(vblk, false);
+ *   - hw/block/virtio-blk.c|863| <<virtio_blk_dma_restart_bh>> virtio_blk_process_queued_requests(s, true);
+ */
 void virtio_blk_process_queued_requests(VirtIOBlock *s, bool is_bh)
 {
     VirtIOBlockReq *req = s->rq;
@@ -853,6 +859,10 @@ void virtio_blk_process_queued_requests(VirtIOBlock *s, bool is_bh)
     aio_context_release(blk_get_aio_context(s->conf.conf.blk));
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|883| <<virtio_blk_dma_restart_cb>> s->bh = aio_bh_new(blk_get_aio_context(s->conf.conf.blk), virtio_blk_dma_restart_bh, s);
+ */
 static void virtio_blk_dma_restart_bh(void *opaque)
 {
     VirtIOBlock *s = opaque;
diff --git a/hw/core/qdev-properties.c b/hw/core/qdev-properties.c
index c34aac6eb..b941ba96e 100644
--- a/hw/core/qdev-properties.c
+++ b/hw/core/qdev-properties.c
@@ -720,6 +720,14 @@ void qdev_prop_set_enum(DeviceState *dev, const char *name, int value)
                             &error_abort);
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev-properties.c|736| <<qdev_prop_register_global>> g_ptr_array_add(global_props(), prop);
+ *   - hw/core/qdev-properties.c|742| <<qdev_find_global_prop>> GPtrArray *props = global_props();
+ *   - hw/core/qdev-properties.c|760| <<qdev_prop_check_globals>> for (i = 0; i < global_props()->len; i++) {
+ *   - hw/core/qdev-properties.c|765| <<qdev_prop_check_globals>> prop = g_ptr_array_index(global_props(), i);
+ *   - hw/core/qdev-properties.c|790| <<qdev_prop_set_globals>> object_apply_global_props(OBJECT(dev), global_props(),
+ */
 static GPtrArray *global_props(void)
 {
     static GPtrArray *gp;
@@ -785,6 +793,28 @@ int qdev_prop_check_globals(void)
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:791
+ * #1  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #2  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #3  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #4  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #5  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #7  0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #8  0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #9  0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #10 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #11 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #12 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #13 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #14 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #15 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #16 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #17 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #18 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 void qdev_prop_set_globals(DeviceState *dev)
 {
     object_apply_global_props(OBJECT(dev), global_props(),
diff --git a/hw/i386/intel_iommu.c b/hw/i386/intel_iommu.c
index c64aa81a8..a119aa753 100644
--- a/hw/i386/intel_iommu.c
+++ b/hw/i386/intel_iommu.c
@@ -3352,6 +3352,39 @@ static MemTxResult vtd_mem_ir_read(void *opaque, hwaddr addr,
     return MEMTX_OK;
 }
 
+/*
+ * (gdb) bt
+ * #0  vtd_mem_ir_write (opaque=0x55555779aaa0, addr=600, value=0, size=4, attrs=...) at ../hw/i386/intel_iommu.c:3358
+ * #1  0x0000555555bd9047 in memory_region_write_with_attrs_accessor (mr=0x55555779aff0, addr=600, value=0x7ffe6e3fe338, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:513
+ * #2  0x0000555555bd9186 in access_with_adjusted_size (addr=600, value=0x7ffe6e3fe338, size=4, access_size_min=4, access_size_max=4, access_fn=
+ *     0x555555bd8f4d <memory_region_write_with_attrs_accessor>, mr=0x55555779aff0, attrs=...) at ../softmmu/memory.c:554
+ * #3  0x0000555555bdc2ba in memory_region_dispatch_write (mr=0x55555779aff0, addr=600, data=0, op=MO_32, attrs=...) at ../softmmu/memory.c:1521
+ * #4  0x0000555555beb2a2 in address_space_stl_internal (as=0x55555767da30, addr=4276093528, val=0, attrs=..., result=0x0, endian=DEVICE_LITTLE_ENDIAN) at /home/zhang/kvm/test/qemu-7.0.0/memory_ldst.c.inc:319
+ * #5  0x0000555555beb3d9 in address_space_stl_le (as=0x55555767da30, addr=4276093528, val=0, attrs=..., result=0x0) at /home/zhang/kvm/test/qemu-7.0.0/memory_ldst.c.inc:357
+ * #6  0x0000555555a3810a in msi_send_message (dev=0x55555767d800, msg=...) at ../hw/pci/msi.c:340
+ * #7  0x0000555555a39990 in msix_notify (dev=0x55555767d800, vector=0) at ../hw/pci/msix.c:503
+ * #8  0x00005555559ed349 in e1000e_msix_notify_one (core=0x555557680670, cause=1048576, int_cfg=2148141320) at ../hw/net/e1000e_core.c:2000
+ * #9  0x00005555559ed473 in e1000e_msix_notify (core=0x555557680670, causes=1048576) at ../hw/net/e1000e_core.c:2030
+ * #10 0x00005555559ed778 in e1000e_send_msi (core=0x555557680670, msix=true) at ../hw/net/e1000e_core.c:2124
+ * #11 0x00005555559ed8df in e1000e_update_interrupt_state (core=0x555557680670) at ../hw/net/e1000e_core.c:2169
+ * #12 0x00005555559ed988 in e1000e_set_interrupt_cause (core=0x555557680670, val=1048576) at ../hw/net/e1000e_core.c:2192
+ * #13 0x00005555559ee184 in e1000e_set_ics (core=0x555557680670, index=50, val=1048576) at ../hw/net/e1000e_core.c:2450
+ * #14 0x00005555559eedc5 in e1000e_core_write (core=0x555557680670, addr=200, val=1048576, size=4) at ../hw/net/e1000e_core.c:3259
+ * #15 0x00005555559dfe92 in e1000e_mmio_write (opaque=0x55555767d800, addr=200, val=1048576, size=4) at ../hw/net/e1000e.c:111
+ * #16 0x0000555555bd8f42 in memory_region_write_accessor (mr=0x555557680220, addr=200, value=0x7ffe6e3fe6e8, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:492
+ * #17 0x0000555555bd9186 in access_with_adjusted_size (addr=200, value=0x7ffe6e3fe6e8, size=4, access_size_min=4, access_size_max=4, access_fn=
+ *     0x555555bd8e4c <memory_region_write_accessor>, mr=0x555557680220, attrs=...) at ../softmmu/memory.c:554
+ * #18 0x0000555555bdc27c in memory_region_dispatch_write (mr=0x555557680220, addr=200, data=1048576, op=MO_32, attrs=...) at ../softmmu/memory.c:1514
+ * #19 0x0000555555be974a in flatview_write_continue (fv=0x7ffe68000980, addr=4273471688, attrs=..., ptr=0x7ffff7ff2028, len=4, addr1=200, l=4, mr=0x555557680220) at ../softmmu/physmem.c:2814
+ * #20 0x0000555555be98ad in flatview_write (fv=0x7ffe68000980, addr=4273471688, attrs=..., buf=0x7ffff7ff2028, len=4) at ../softmmu/physmem.c:2856
+ * #21 0x0000555555be9c5d in address_space_write (as=0x55555677b440 <address_space_memory>, addr=4273471688, attrs=..., buf=0x7ffff7ff2028, len=4) at ../softmmu/physmem.c:2952
+ * #22 0x0000555555be9cca in address_space_rw (as=0x55555677b440 <address_space_memory>, addr=4273471688, attrs=..., buf=0x7ffff7ff2028, len=4, is_write=true) at ../softmmu/physmem.c:2962
+ * #23 0x0000555555d1175f in kvm_cpu_exec (cpu=0x555556a7eb60) at ../accel/kvm/kvm-all.c:2929
+ * #24 0x0000555555d1354e in kvm_vcpu_thread_fn (arg=0x555556a7eb60) at ../accel/kvm/kvm-accel-ops.c:49
+ * #25 0x0000555555efbfb0 in qemu_thread_start (args=0x555556a8eea0) at ../util/qemu-thread-posix.c:556
+ * #26 0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #27 0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ */
 static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,
                                     uint64_t value, unsigned size,
                                     MemTxAttrs attrs)
diff --git a/hw/isa/piix3.c b/hw/isa/piix3.c
index dab901c9a..8e88c5ae9 100644
--- a/hw/isa/piix3.c
+++ b/hw/isa/piix3.c
@@ -61,6 +61,31 @@ static void piix3_set_irq_level_internal(PIIX3State *piix3, int pirq, int level)
     piix3->pic_levels |= mask * !!level;
 }
 
+/*
+ * (gdb) bt
+ * #0  piix3_set_irq_level (piix3=0x555556f80b80, pirq=2, level=1) at ../hw/isa/piix3.c:68
+ * #1  0x00005555559bf2fa in piix3_set_irq (opaque=0x555556f80b80, pirq=2, level=1) at ../hw/isa/piix3.c:81
+ * #2  0x0000555555a3b42d in pci_bus_change_irq_level (bus=0x555556be4030, irq_num=2, change=1) at ../hw/pci/pci.c:268
+ * #3  0x0000555555a3b4a4 in pci_change_irq_level (pci_dev=0x55555752c200, irq_num=2, change=1) at ../hw/pci/pci.c:281
+ * #4  0x0000555555a3e944 in pci_irq_handler (opaque=0x55555752c200, irq_num=0, level=1) at ../hw/pci/pci.c:1551
+ * #5  0x0000555555a3e9dc in pci_set_irq (pci_dev=0x55555752c200, level=1) at ../hw/pci/pci.c:1565
+ * #6  0x00005555559d4845 in set_interrupt_cause (s=0x55555752c200, index=0, val=16) at ../hw/net/e1000.c:338
+ * #7  0x00005555559d48cd in set_ics (s=0x55555752c200, index=50, val=16) at ../hw/net/e1000.c:356
+ * #8  0x00005555559d6f18 in e1000_mmio_write (opaque=0x55555752c200, addr=200, val=16, size=4) at ../hw/net/e1000.c:1331
+ * #9  0x0000555555bd8f42 in memory_region_write_accessor (mr=0x55555752ec20, addr=200, value=0x7ffdee7fe6e8, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:492
+ * #10 0x0000555555bd9186 in access_with_adjusted_size (addr=200, value=0x7ffdee7fe6e8, size=4, access_size_min=4, access_size_max=4, access_fn=
+ *     0x555555bd8e4c <memory_region_write_accessor>, mr=0x55555752ec20, attrs=...) at ../softmmu/memory.c:554
+ * #11 0x0000555555bdc27c in memory_region_dispatch_write (mr=0x55555752ec20, addr=200, data=16, op=MO_32, attrs=...) at ../softmmu/memory.c:1514
+ * #12 0x0000555555be974a in flatview_write_continue (fv=0x7ffde4000ee0, addr=4273733832, attrs=..., ptr=0x7ffff7ff2028, len=4, addr1=200, l=4, mr=0x55555752ec20) at ../softmmu/physmem.c:2814
+ * #13 0x0000555555be98ad in flatview_write (fv=0x7ffde4000ee0, addr=4273733832, attrs=..., buf=0x7ffff7ff2028, len=4) at ../softmmu/physmem.c:2856
+ * #14 0x0000555555be9c5d in address_space_write (as=0x555556779440 <address_space_memory>, addr=4273733832, attrs=..., buf=0x7ffff7ff2028, len=4) at ../softmmu/physmem.c:2952
+ * #15 0x0000555555be9cca in address_space_rw (as=0x555556779440 <address_space_memory>, addr=4273733832, attrs=..., buf=0x7ffff7ff2028, len=4, is_write=true) at ../softmmu/physmem.c:2962
+ * #16 0x0000555555d1175f in kvm_cpu_exec (cpu=0x555556a5d260) at ../accel/kvm/kvm-all.c:2929
+ * #17 0x0000555555d1354e in kvm_vcpu_thread_fn (arg=0x555556a5d260) at ../accel/kvm/kvm-accel-ops.c:49
+ * #18 0x0000555555efbfb0 in qemu_thread_start (args=0x555556a6d5b0) at ../util/qemu-thread-posix.c:556
+ * #19 0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #20 0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ */
 static void piix3_set_irq_level(PIIX3State *piix3, int pirq, int level)
 {
     int pic_irq;
@@ -109,6 +134,27 @@ static void piix3_update_irq_levels(PIIX3State *piix3)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  piix3_write_config (dev=0x555556f80b80, address=16, val=4294967295, len=4) at ../hw/isa/piix3.c:115
+ * #1  0x0000555555a43a13 in pci_host_config_write_common (pci_dev=0x555556f80b80, addr=16, limit=256, val=4294967295, len=4) at ../hw/pci/pci_host.c:85
+ * #2  0x0000555555a43bb7 in pci_data_write (s=0x555556be4030, addr=2147485712, val=4294967295, len=4) at ../hw/pci/pci_host.c:124
+ * #3  0x0000555555a43cdd in pci_host_data_write (opaque=0x555556be2fc0, addr=0, val=4294967295, len=4) at ../hw/pci/pci_host.c:171
+ * #4  0x0000555555bd8f42 in memory_region_write_accessor (mr=0x555556be33f0, addr=0, value=0x7ffdee7fe6a8, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:492
+ * #5  0x0000555555bd9186 in access_with_adjusted_size (addr=0, value=0x7ffdee7fe6a8, size=4, access_size_min=1, access_size_max=4, access_fn=
+ *     0x555555bd8e4c <memory_region_write_accessor>, mr=0x555556be33f0, attrs=...) at ../softmmu/memory.c:554
+ * #6  0x0000555555bdc27c in memory_region_dispatch_write (mr=0x555556be33f0, addr=0, data=4294967295, op=MO_32, attrs=...) at ../softmmu/memory.c:1514
+ * #7  0x0000555555be974a in flatview_write_continue (fv=0x7ffde80433c0, addr=3324, attrs=..., ptr=0x7ffff7ff3000, len=4, addr1=0, l=4, mr=0x555556be33f0) at ../softmmu/physmem.c:2814
+ * #8  0x0000555555be98ad in flatview_write (fv=0x7ffde80433c0, addr=3324, attrs=..., buf=0x7ffff7ff3000, len=4) at ../softmmu/physmem.c:2856
+ * #9  0x0000555555be9c5d in address_space_write (as=0x5555567793e0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff3000, len=4) at ../softmmu/physmem.c:2952
+ * #10 0x0000555555be9cca in address_space_rw (as=0x5555567793e0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff3000, len=4, is_write=true) at ../softmmu/physmem.c:2962
+ * #11 0x0000555555d10f9b in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7ff3000, direction=1, size=4, count=1) at ../accel/kvm/kvm-all.c:2668
+ * #12 0x0000555555d11712 in kvm_cpu_exec (cpu=0x555556a5d260) at ../accel/kvm/kvm-all.c:2919
+ * #13 0x0000555555d1354e in kvm_vcpu_thread_fn (arg=0x555556a5d260) at ../accel/kvm/kvm-accel-ops.c:49
+ * #14 0x0000555555efbfb0 in qemu_thread_start (args=0x555556a6d5b0) at ../util/qemu-thread-posix.c:556
+ * #15 0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #16 0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ */
 static void piix3_write_config(PCIDevice *dev,
                                uint32_t address, uint32_t val, int len)
 {
diff --git a/hw/net/vhost_net.c b/hw/net/vhost_net.c
index 30379d2ca..aea053a26 100644
--- a/hw/net/vhost_net.c
+++ b/hw/net/vhost_net.c
@@ -316,6 +316,10 @@ static void vhost_net_stop_one(struct vhost_net *net,
     vhost_dev_disable_notifiers(&net->dev, dev);
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|295| <<virtio_net_vhost_status>> r = vhost_net_start(vdev, n->nic->ncs, queue_pairs, cvq);
+ */
 int vhost_net_start(VirtIODevice *dev, NetClientState *ncs,
                     int data_queue_pairs, int cvq)
 {
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index 1067e72b3..96086dd3c 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -287,6 +287,11 @@ static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)
         }
 
         n->vhost_started = 1;
+	/*
+	 * VirtIONet *n:
+	 * -> NICState *nic;
+	 *    -> NetClientState *ncs;
+	 */
         r = vhost_net_start(vdev, n->nic->ncs, queue_pairs, cvq);
         if (r < 0) {
             error_report("unable to start vhost net: %d: "
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index dae9119bf..e0c2b27c3 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -278,6 +278,10 @@ static void pci_change_irq_level(PCIDevice *pci_dev, int irq_num, int change)
             break;
         pci_dev = bus->parent_dev;
     }
+    /*
+     * e1000的map是pci_slot_get_pirq()
+     * e1000的set是piix3_set_irq()
+     */
     pci_bus_change_irq_level(bus, irq_num, change);
 }
 
diff --git a/hw/scsi/virtio-scsi-dataplane.c b/hw/scsi/virtio-scsi-dataplane.c
index 29575cbaf..8f850e0dc 100644
--- a/hw/scsi/virtio-scsi-dataplane.c
+++ b/hw/scsi/virtio-scsi-dataplane.c
@@ -81,6 +81,10 @@ static void virtio_scsi_dataplane_stop_bh(void *opaque)
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * 在以下使用virtio_scsi_dataplane_start():
+ *   - hw/scsi/virtio-scsi.c|1106| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ */
 int virtio_scsi_dataplane_start(VirtIODevice *vdev)
 {
     int i;
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index 9d637e043..efe5dd3eb 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -1887,6 +1887,14 @@ void qemu_put_virtqueue_element(VirtIODevice *vdev, QEMUFile *f,
 }
 
 /* virtio device */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1906| <<virtio_update_irq>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ *   - hw/virtio/virtio.c|2000| <<virtio_reset>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|2528| <<virtio_irq>> virtio_notify_vector(vq->vdev, vq->vector);
+ *   - hw/virtio/virtio.c|2550| <<virtio_notify_config>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|3051| <<virtio_load>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ */
 static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
@@ -2522,6 +2530,11 @@ void virtio_notify_irqfd(VirtIODevice *vdev, VirtQueue *vq)
     event_notifier_set(&vq->guest_notifier);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|2540| <<virtio_notify>> virtio_irq(vq);
+ *   - hw/virtio/virtio.c|3471| <<virtio_queue_guest_notifier_read>> virtio_irq(vq);
+ */
 static void virtio_irq(VirtQueue *vq)
 {
     virtio_set_isr(vq->vdev, 0x1);
diff --git a/include/exec/memory.h b/include/exec/memory.h
index 4d5997e6b..f665af8ea 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -755,6 +755,25 @@ struct MemoryRegion {
     QTAILQ_ENTRY(MemoryRegion) subregions_link;
     QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;
     const char *name;
+    /*
+     * 在以下使用AddressSpace->ioeventfd_nb:
+     *   - softmmu/memory.c|880| <<address_space_update_ioeventfds>> ioeventfd_max = QEMU_ALIGN_UP(as->ioeventfd_nb, 4);
+     *   - softmmu/memory.c|914| <<address_space_update_ioeventfds>> as->ioeventfds, as->ioeventfd_nb);
+     *   - softmmu/memory.c|918| <<address_space_update_ioeventfds>> as->ioeventfd_nb = ioeventfd_nb;
+     *   - softmmu/memory.c|3095| <<address_space_init>> as->ioeventfd_nb = 0;
+     * 在以下使用MemoryRegion->ioeventfd_nb:
+     *   - softmmu/memory.c|2567| <<memory_region_add_eventfd>> ++mr->ioeventfd_nb;
+     *   - softmmu/memory.c|2605| <<memory_region_del_eventfd>> --mr->ioeventfd_nb;
+     *   - softmmu/memory.c|896| <<address_space_update_ioeventfds>> for (i = 0; i < fr->mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|1556| <<memory_region_dispatch_write_eventfds>> for (i = 0; i < mr->ioeventfd_nb; i++) {
+     *   - softmmu/memory.c|2562| <<memory_region_add_eventfd>> for (i = 0; i < mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|2569| <<memory_region_add_eventfd>> sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);
+     *   - softmmu/memory.c|2571| <<memory_region_add_eventfd>> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));
+     *   - softmmu/memory.c|2597| <<memory_region_del_eventfd>> for (i = 0; i < mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|2602| <<memory_region_del_eventfd>> assert(i != mr->ioeventfd_nb);
+     *   - softmmu/memory.c|2604| <<memory_region_del_eventfd>> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb - (i+1)));
+     *   - softmmu/memory.c|2607| <<memory_region_del_eventfd>> sizeof(*mr->ioeventfds)*mr->ioeventfd_nb + 1);
+     */
     unsigned ioeventfd_nb;
     MemoryRegionIoeventfd *ioeventfds;
     RamDiscardManager *rdm; /* Only for RAM */
@@ -1040,6 +1059,25 @@ struct AddressSpace {
     /* Accessed via RCU.  */
     struct FlatView *current_map;
 
+    /*
+     * 在以下使用AddressSpace->ioeventfd_nb:
+     *   - softmmu/memory.c|880| <<address_space_update_ioeventfds>> ioeventfd_max = QEMU_ALIGN_UP(as->ioeventfd_nb, 4);
+     *   - softmmu/memory.c|914| <<address_space_update_ioeventfds>> as->ioeventfds, as->ioeventfd_nb);
+     *   - softmmu/memory.c|918| <<address_space_update_ioeventfds>> as->ioeventfd_nb = ioeventfd_nb;
+     *   - softmmu/memory.c|3095| <<address_space_init>> as->ioeventfd_nb = 0;
+     * 在以下使用MemoryRegion->ioeventfd_nb:
+     *   - softmmu/memory.c|2567| <<memory_region_add_eventfd>> ++mr->ioeventfd_nb;
+     *   - softmmu/memory.c|2605| <<memory_region_del_eventfd>> --mr->ioeventfd_nb;
+     *   - softmmu/memory.c|896| <<address_space_update_ioeventfds>> for (i = 0; i < fr->mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|1556| <<memory_region_dispatch_write_eventfds>> for (i = 0; i < mr->ioeventfd_nb; i++) {
+     *   - softmmu/memory.c|2562| <<memory_region_add_eventfd>> for (i = 0; i < mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|2569| <<memory_region_add_eventfd>> sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);
+     *   - softmmu/memory.c|2571| <<memory_region_add_eventfd>> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));
+     *   - softmmu/memory.c|2597| <<memory_region_del_eventfd>> for (i = 0; i < mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|2602| <<memory_region_del_eventfd>> assert(i != mr->ioeventfd_nb);
+     *   - softmmu/memory.c|2604| <<memory_region_del_eventfd>> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb - (i+1)));
+     *   - softmmu/memory.c|2607| <<memory_region_del_eventfd>> sizeof(*mr->ioeventfds)*mr->ioeventfd_nb + 1);
+     */
     int ioeventfd_nb;
     struct MemoryRegionIoeventfd *ioeventfds;
     QTAILQ_HEAD(, MemoryListener) listeners;
diff --git a/include/hw/qdev-core.h b/include/hw/qdev-core.h
index 92c3d6520..87a4c8b95 100644
--- a/include/hw/qdev-core.h
+++ b/include/hw/qdev-core.h
@@ -213,6 +213,21 @@ struct DeviceListener {
 };
 
 #define TYPE_BUS "bus"
+/*
+ * 215 #define DECLARE_OBJ_CHECKERS(InstanceType, ClassType, OBJ_NAME, TYPENAME) \
+ * 216     DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \
+ * 217     \
+ * 218     DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME)
+ *
+ * 193 #define DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME) \
+ * 194     static inline G_GNUC_UNUSED ClassType * \
+ * 195     OBJ_NAME##_GET_CLASS(const void *obj) \
+ * 196     { return OBJECT_GET_CLASS(ClassType, obj, TYPENAME); } \
+ * 197     \
+ * 198     static inline G_GNUC_UNUSED ClassType * \
+ * 199     OBJ_NAME##_CLASS(const void *klass) \
+ * 200     { return OBJECT_CLASS_CHECK(ClassType, klass, TYPENAME); }
+ */
 DECLARE_OBJ_CHECKERS(BusState, BusClass,
                      BUS, TYPE_BUS)
 
diff --git a/monitor/hmp.c b/monitor/hmp.c
index 24fd2e5f3..7a2a4cc97 100644
--- a/monitor/hmp.c
+++ b/monitor/hmp.c
@@ -274,6 +274,13 @@ static void help_cmd_dump(Monitor *mon, const HMPCommand *cmds,
     }
 }
 
+/*
+ * called by:
+ *   - monitor/misc.c|173| <<do_help_cmd>> help_cmd(mon, qdict_get_try_str(qdict, "name"));
+ *   - monitor/misc.c|215| <<hmp_trace_file>> help_cmd(mon, "trace-file");
+ *   - monitor/misc.c|222| <<hmp_info_help>> help_cmd(mon, "info");
+ *   - monitor/misc.c|438| <<hmp_log>> help_cmd(mon, "log");
+ */
 void help_cmd(Monitor *mon, const char *name)
 {
     char *args[MAX_ARGS];
diff --git a/monitor/monitor.c b/monitor/monitor.c
index 21c7a6875..53add961a 100644
--- a/monitor/monitor.c
+++ b/monitor/monitor.c
@@ -110,6 +110,17 @@ Monitor *monitor_cur(void)
  * resetting it to NULL is required before the coroutine terminates,
  * otherwise a stale entry would remain in the hash table.
  */
+/*
+ * called by:
+ *   - monitor/hmp.c|1125| <<handle_hmp_command_co>> monitor_set_cur(qemu_coroutine_self(), NULL);
+ *   - monitor/hmp.c|1161| <<handle_hmp_command>> Monitor *old_mon = monitor_set_cur(qemu_coroutine_self(), &mon->common);
+ *   - monitor/hmp.c|1163| <<handle_hmp_command>> monitor_set_cur(qemu_coroutine_self(), old_mon);
+ *   - monitor/hmp.c|1172| <<handle_hmp_command>> monitor_set_cur(co, &mon->common);
+ *   - qapi/qmp-dispatch.c|127| <<do_qmp_dispatch_bh>> monitor_set_cur(qemu_coroutine_self(), data->cur_mon);
+ *   - qapi/qmp-dispatch.c|129| <<do_qmp_dispatch_bh>> monitor_set_cur(qemu_coroutine_self(), NULL);
+ *   - qapi/qmp-dispatch.c|209| <<qmp_dispatch>> monitor_set_cur(qemu_coroutine_self(), cur_mon);
+ *   - qapi/qmp-dispatch.c|211| <<qmp_dispatch>> monitor_set_cur(qemu_coroutine_self(), NULL);
+ */
 Monitor *monitor_set_cur(Coroutine *co, Monitor *mon)
 {
     Monitor *old_monitor = monitor_cur();
diff --git a/qom/object.c b/qom/object.c
index d34608558..cf1b2dde4 100644
--- a/qom/object.c
+++ b/qom/object.c
@@ -389,6 +389,30 @@ static void object_post_init_with_type(Object *obj, TypeImpl *ti)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1646
+ * #1  0x0000555555d28d33 in object_apply_global_props (obj=0x555556a5f460, props=0x5555569b8f00, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:412
+ * #2  0x0000555555d20e5c in qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:790
+ * #3  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #4  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #5  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #7  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #9  0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #10 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #11 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #12 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #13 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #14 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #15 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #16 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #17 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #18 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #19 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #20 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 bool object_apply_global_props(Object *obj, const GPtrArray *props,
                                Error **errp)
 {
@@ -409,6 +433,10 @@ bool object_apply_global_props(Object *obj, const GPtrArray *props,
             continue;
         }
         p->used = true;
+	/*
+	 * Thread 1 "qemu-system-x86" hit Breakpoint 11, object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1646
+	 *    Visitor *v = string_input_visitor_new(string);
+	 */
         if (!object_property_parse(obj, p->property, p->value, &err)) {
             error_prepend(&err, "can't apply global %s.%s=%s: ",
                           p->driver, p->property, p->value);
@@ -1391,6 +1419,31 @@ bool object_property_get(Object *obj, const char *name, Visitor *v,
     return !err;
 }
 
+/*
+ * (gdb) bt
+ * #0  object_property_set (obj=0x555556a5f460, name=0x55555680db00 "x2apic", v=0x555556a6e980, errp=0x7fffffffd878) at ../qom/object.c:1400
+ * #1  0x0000555555d2b91e in object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1647
+ * #2  0x0000555555d28d33 in object_apply_global_props (obj=0x555556a5f460, props=0x5555569b8f00, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:412
+ * #3  0x0000555555d20e5c in qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:790
+ * #4  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #5  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #7  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #9  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #10 0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #11 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #12 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #13 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #14 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #15 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #16 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #17 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #18 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #19 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #20 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #21 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 bool object_property_set(Object *obj, const char *name, Visitor *v,
                          Error **errp)
 {
@@ -1405,6 +1458,12 @@ bool object_property_set(Object *obj, const char *name, Visitor *v,
         error_setg(errp, QERR_PERMISSION_DENIED);
         return false;
     }
+    /*
+     * (gdb) p *prop
+     * $8 = {name = 0x555556817690 "x2apic", type = 0x5555568176b0 "bool", description = 0x0,
+     * get = 0x555555b6d930 <x86_cpu_get_bit_prop>, set = 0x555555b6d9de <x86_cpu_set_bit_prop>,
+     * resolve = 0x0, release = 0x0, init = 0x0, opaque = 0x555556817610, defval = 0x0}
+     */
     prop->set(obj, v, name, prop->opaque, errp);
     return !*errp;
 }
@@ -1640,6 +1699,39 @@ int object_property_get_enum(Object *obj, const char *name,
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1646
+ * #1  0x0000555555d28d33 in object_apply_global_props (obj=0x555556a5f460, props=0x5555569b8f00, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:412
+ * #2  0x0000555555d20e5c in qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:790
+ * #3  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #4  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #5  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #7  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #9  0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #10 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #11 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #12 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #13 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #14 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #15 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #16 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #17 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #18 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #19 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #20 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * called by:
+ *   - hw/i386/sgx.c|308| <<pc_machine_init_sgx_epc>> object_property_parse(obj, SGX_EPC_MEMDEV_PROP, list->value->memdev,
+ *   - qom/object.c|412| <<object_apply_global_props>> if (!object_property_parse(obj, p->property, p->value, &err)) {
+ *   - qom/object.c|845| <<object_set_propv>> if (!object_property_parse(obj, propname, value, errp)) {
+ *   - qom/qom-hmp-cmds.c|59| <<hmp_qom_set>> object_property_parse(obj, property, value, &err);
+ *   - softmmu/vl.c|1694| <<object_parse_property_opt>> if (!object_property_parse(obj, name, value, errp)) {
+ *   - target/i386/cpu.c|5085| <<x86_cpu_apply_props>> object_property_parse(OBJECT(cpu), pv->prop, pv->value,
+ *   - target/i386/cpu.c|5112| <<x86_cpu_apply_version_props>> object_property_parse(OBJECT(cpu), p->prop, p->value,
+ */
 bool object_property_parse(Object *obj, const char *name,
                            const char *string, Error **errp)
 {
diff --git a/softmmu/cpus.c b/softmmu/cpus.c
index 7b75bb66d..ac471f9fc 100644
--- a/softmmu/cpus.c
+++ b/softmmu/cpus.c
@@ -618,6 +618,30 @@ void cpus_register_accel(const AccelOpsClass *ops)
     cpus_accel = ops;
 }
 
+/*
+ * called by:
+ *   - accel/tcg/user-exec-stub.c|15| <<qemu_init_vcpu>> void qemu_init_vcpu(CPUState *cpu)
+ *   - target/alpha/cpu.c|69| <<alpha_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/arm/cpu.c|1975| <<arm_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/avr/cpu.c|101| <<avr_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/cris/cpu.c|138| <<cris_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/hexagon/cpu.c|303| <<hexagon_cpu_realize>> qemu_init_vcpu(cs);
+ *   - target/hppa/cpu.c|107| <<hppa_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/i386/cpu.c|6670| <<x86_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/m68k/cpu.c|301| <<m68k_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/microblaze/cpu.c|202| <<mb_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/mips/cpu.c|484| <<mips_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/nios2/cpu.c|121| <<nios2_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/openrisc/cpu.c|108| <<openrisc_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/ppc/cpu_init.c|6839| <<ppc_cpu_realize>> qemu_init_vcpu(cs);
+ *   - target/riscv/cpu.c|686| <<riscv_cpu_realize>> qemu_init_vcpu(cs);
+ *   - target/rx/cpu.c|121| <<rx_cpu_realize>> qemu_init_vcpu(cs);
+ *   - target/s390x/cpu.c|214| <<s390_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/sh4/cpu.c|206| <<superh_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/sparc/cpu.c|774| <<sparc_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/tricore/cpu.c|96| <<tricore_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/xtensa/cpu.c|155| <<xtensa_cpu_realizefn>> qemu_init_vcpu(cs);
+ */
 void qemu_init_vcpu(CPUState *cpu)
 {
     MachineState *ms = MACHINE(qdev_get_machine());
@@ -637,6 +661,9 @@ void qemu_init_vcpu(CPUState *cpu)
 
     /* accelerators all implement the AccelOpsClass */
     g_assert(cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL);
+    /*
+     * kvm_start_vcpu_thread()
+     */
     cpus_accel->create_vcpu_thread(cpu);
 
     while (!cpu->created) {
diff --git a/softmmu/memory.c b/softmmu/memory.c
index bfa5d5178..927ff78bd 100644
--- a/softmmu/memory.c
+++ b/softmmu/memory.c
@@ -36,8 +36,40 @@
 
 //#define DEBUG_UNASSIGNED
 
+/*
+ * 在以下使用memory_region_transaction_depth:
+ *   - softmmu/memory.c|1121| <<memory_region_transaction_begin>> ++memory_region_transaction_depth;
+ *   - softmmu/memory.c|1128| <<memory_region_transaction_commit>> assert(memory_region_transaction_depth);
+ *   - softmmu/memory.c|1131| <<memory_region_transaction_commit>> --memory_region_transaction_depth;
+ *   - softmmu/memory.c|1132| <<memory_region_transaction_commit>> if (!memory_region_transaction_depth) {
+ */
 static unsigned memory_region_transaction_depth;
+/*
+ * 在以下使用memory_region_update_pending:
+ *   - softmmu/memory.c|1133| <<memory_region_transaction_commit>> if (memory_region_update_pending) {
+ * 在以下设置memory_region_update_pending:
+ *   - softmmu/memory.c|1142| <<memory_region_transaction_commit>> memory_region_update_pending = false;
+ *   - softmmu/memory.c|2186| <<memory_region_set_log>> memory_region_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2316| <<memory_region_set_readonly>> memory_region_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2326| <<memory_region_set_nonvolatile>> memory_region_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2336| <<memory_region_rom_device_set_romd>> memory_region_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2588| <<memory_region_update_container_subregions>> memory_region_update_pending |= mr->enabled && subregion->enabled;
+ *   - softmmu/memory.c|2638| <<memory_region_del_subregion>> memory_region_update_pending |= mr->enabled && subregion->enabled;
+ *   - softmmu/memory.c|2649| <<memory_region_set_enabled>> memory_region_update_pending = true;
+ *   - softmmu/memory.c|2665| <<memory_region_set_size>> memory_region_update_pending = true;
+ *   - softmmu/memory.c|2701| <<memory_region_set_alias_offset>> memory_region_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2872| <<memory_global_dirty_log_start>> memory_region_update_pending = true;
+ *   - softmmu/memory.c|2887| <<memory_global_dirty_log_do_stop>> memory_region_update_pending = true;
+ */
 static bool memory_region_update_pending;
+/*
+ * 在以下使用ioeventfd_update_pending:
+ *   - softmmu/memory.c|1143| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - softmmu/memory.c|1145| <<memory_region_transaction_commit>> } else if (ioeventfd_update_pending) {
+ *   - softmmu/memory.c|1149| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - softmmu/memory.c|2533| <<memory_region_add_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2568| <<memory_region_del_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ */
 static bool ioeventfd_update_pending;
 unsigned int global_dirty_tracking;
 
@@ -576,6 +608,12 @@ static AddressSpace *memory_region_to_address_space(MemoryRegion *mr)
 /* Render a memory region into the global view.  Ranges in @view obscure
  * ranges in @mr.
  */
+/*
+ * called by:
+ *   - softmmu/memory.c|613| <<render_memory_region>> render_memory_region(view, mr->alias, base, clip,
+ *   - softmmu/memory.c|620| <<render_memory_region>> render_memory_region(view, subregion, base, clip,
+ *   - softmmu/memory.c|736| <<generate_memory_topology>> render_memory_region(view, mr, int128_zero(),
+ */
 static void render_memory_region(FlatView *view,
                                  MemoryRegion *mr,
                                  Int128 base,
@@ -725,6 +763,12 @@ static MemoryRegion *memory_region_get_flatview_root(MemoryRegion *mr)
 }
 
 /* Render a memory topology into a list of disjoint absolute ranges. */
+/*
+ * called by:
+ *   - softmmu/memory.c|1010| <<flatviews_init>> empty_view = generate_memory_topology(NULL);
+ *   - softmmu/memory.c|1037| <<flatviews_reset>> generate_memory_topology(physmr);
+ *   - softmmu/memory.c|1092| <<address_space_update_topology>> generate_memory_topology(physmr);
+ */
 static FlatView *generate_memory_topology(MemoryRegion *mr)
 {
     int i;
@@ -751,6 +795,10 @@ static FlatView *generate_memory_topology(MemoryRegion *mr)
     return view;
 }
 
+/*
+ * called by:
+ *   - softmmu/memory.c|861| <<address_space_update_ioeventfds>> address_space_add_del_ioeventfds(as, ioeventfds, ioeventfd_nb,
+ */
 static void address_space_add_del_ioeventfds(AddressSpace *as,
                                              MemoryRegionIoeventfd *fds_new,
                                              unsigned fds_new_nb,
@@ -814,6 +862,44 @@ FlatView *address_space_get_flatview(AddressSpace *as)
     return view;
 }
 
+/*
+ * (gdb) bt
+ * #0  address_space_update_ioeventfds (as=0x555556f87760) at ../softmmu/memory.c:818
+ * #1  0x0000555555b8c861 in address_space_init (as=0x555556f87760, root=0x555556a4dee0, name=0x555556f877c0 "cpu-memory-8") at ../softmmu/memory.c:3013
+ * #2  0x0000555555b90b8b in cpu_address_space_init (cpu=0x5555571b41f0, asidx=0, prefix=0x555555fd78d7 "cpu-memory", mr=0x555556a4dee0) at ../softmmu/physmem.c:737
+ * #3  0x0000555555884593 in qemu_init_vcpu (cpu=0x5555571b41f0) at ../softmmu/cpus.c:635
+ * #4  0x0000555555b1a5ad in x86_cpu_realizefn (dev=0x5555571b41f0, errp=0x7fffffffc5d0) at ../target/i386/cpu.c:6533
+ * #5  0x0000555555cba932 in device_set_realized (obj=0x5555571b41f0, value=true, errp=0x7fffffffc910) at ../hw/core/qdev.c:531
+ * #6  0x0000555555cc3099 in property_set_bool (obj=0x5555571b41f0, v=0x555556c1f4a0, name=0x5555560acbf9 "realized", opaque=0x55555684b700, errp=0x7fffffffc910) at ../qom/object.c:2273
+ * #7  0x0000555555cc10e0 in object_property_set (obj=0x5555571b41f0, name=0x5555560acbf9 "realized", v=0x555556c1f4a0, errp=0x7fffffffc910) at ../qom/object.c:1408
+ * #8  0x0000555555cc548b in object_property_set_qobject (obj=0x5555571b41f0, name=0x5555560acbf9 "realized", value=0x5555573e5b30, errp=0x7fffffffc910) at ../qom/qom-qobject.c:28
+ * #9  0x0000555555cc1445 in object_property_set_bool (obj=0x5555571b41f0, name=0x5555560acbf9 "realized", value=true, errp=0x7fffffffc910) at ../qom/object.c:1477
+ * #10 0x0000555555cba1fa in qdev_realize (dev=0x5555571b41f0, bus=0x0, errp=0x7fffffffc910) at ../hw/core/qdev.c:333
+ * #11 0x0000555555889855 in qdev_device_add_from_qdict (opts=0x555557283200, from_json=false, errp=0x7fffffffc910) at ../softmmu/qdev-monitor.c:713
+ * #12 0x00005555558898f3 in qdev_device_add (opts=0x555556847b20, errp=0x7fffffffc910) at ../softmmu/qdev-monitor.c:732
+ * #13 0x0000555555889f07 in qmp_device_add (qdict=0x555557246270, ret_data=0x0, errp=0x7fffffffc910) at ../softmmu/qdev-monitor.c:854
+ * #14 0x000055555588a2f9 in hmp_device_add (mon=0x555556a6beb0, qdict=0x555557246270) at ../softmmu/qdev-monitor.c:958
+ * #15 0x00005555558d146d in handle_hmp_command_exec (mon=0x555556a6beb0, cmd=0x5555566b39b0 <hmp_cmds+1840>, qdict=0x555557246270) at ../monitor/hmp.c:1103
+ * #16 0x00005555558d169a in handle_hmp_command (mon=0x555556a6beb0, cmdline=0x555556a942fb "host-x86_64-cpu,id=core8,socket-id=0,core-id=8,thread-id=0") at ../monitor/hmp.c:1155
+ * #17 0x00005555558cebb3 in monitor_command_cb (opaque=0x555556a6beb0, cmdline=0x555556a942f0 "device_add host-x86_64-cpu,id=core8,socket-id=0,core-id=8,thread-id=0", readline_opaque=0x0) at ../monitor/hmp.c:49
+ * #18 0x0000555555f50c8c in readline_handle_byte (rs=0x555556a942f0, ch=13) at ../util/readline.c:411
+ * #19 0x00005555558d21d4 in monitor_read (opaque=0x555556a6beb0, buf=0x7fffffffcb70 "\r\323\377\377\377\177", size=1) at ../monitor/hmp.c:1393
+ * #20 0x0000555555db4d99 in qemu_chr_be_write_impl (s=0x555556a59100, buf=0x7fffffffcb70 "\r\323\377\377\377\177", len=1) at ../chardev/char.c:201
+ * #21 0x0000555555db4dfd in qemu_chr_be_write (s=0x555556a59100, buf=0x7fffffffcb70 "\r\323\377\377\377\177", len=1) at ../chardev/char.c:213
+ * #22 0x0000555555db782a in fd_chr_read (chan=0x555556a591c0, cond=G_IO_IN, opaque=0x555556a59100) at ../chardev/char-fd.c:73
+ * #23 0x0000555555cc99aa in qio_channel_fd_source_dispatch (source=0x55555732ff00, callback=0x555555db7700 <fd_chr_read>, user_data=0x555556a59100) at ../io/channel-watch.c:84
+ * #24 0x00007ffff6e56119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #25 0x0000555555f4a2ea in glib_pollfds_poll () at ../util/main-loop.c:232
+ * #26 0x0000555555f4a364 in os_host_main_loop_wait (timeout=101746127) at ../util/main-loop.c:255
+ * #27 0x0000555555f4a469 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:531
+ * #28 0x000055555588bdcf in qemu_main_loop () at ../softmmu/runstate.c:727
+ * #29 0x0000555555836ed2 in main (argc=26, argv=0x7fffffffde18, envp=0x7fffffffdef0) at ../softmmu/main.c:50
+ *
+ * called by:
+ *   - softmmu/memory.c|1172| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+ *   - softmmu/memory.c|1187| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+ *   - softmmu/memory.c|3101| <<address_space_init>> address_space_update_ioeventfds(as);
+ */
 static void address_space_update_ioeventfds(AddressSpace *as)
 {
     FlatView *view;
@@ -833,6 +919,17 @@ static void address_space_update_ioeventfds(AddressSpace *as)
     ioeventfds = g_new(MemoryRegionIoeventfd, ioeventfd_max);
 
     view = address_space_get_flatview(as);
+    /*
+     * FlatView *view;
+     * -> FlatRange *ranges;
+     *    -> MemoryRegion *mr;
+     *       -> unsigned ioeventfd_nb;
+     *       -> MemoryRegionIoeventfd *ioeventfds;
+     *          -> AddrRange addr; 
+     *          -> bool match_data;
+     *          -> uint64_t data;
+     *          -> EventNotifier *e;
+     */
     FOR_EACH_FLAT_RANGE(fr, view) {
         for (i = 0; i < fr->mr->ioeventfd_nb; ++i) {
             tmp = addrrange_shift(fr->mr->ioeventfds[i].addr,
@@ -981,6 +1078,11 @@ static void address_space_update_topology_pass(AddressSpace *as,
     }
 }
 
+/*
+ * called by:
+ *   - softmmu/memory.c|1027| <<flatviews_reset>> flatviews_init();
+ *   - softmmu/memory.c|1090| <<address_space_update_topology>> flatviews_init();
+ */
 static void flatviews_init(void)
 {
     static FlatView *empty_view;
@@ -1068,6 +1170,10 @@ static void address_space_set_flatview(AddressSpace *as)
     }
 }
 
+/*
+ * called by:
+ *   - softmmu/memory.c|3039| <<address_space_init>> address_space_update_topology(as);
+ */
 static void address_space_update_topology(AddressSpace *as)
 {
     MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
@@ -1085,6 +1191,46 @@ void memory_region_transaction_begin(void)
     ++memory_region_transaction_depth;
 }
 
+/*
+ * (gdb) bt
+ * #0  memory_region_transaction_commit () at ../softmmu/memory.c:1092
+ * #1  0x0000555555b88e84 in memory_region_finalize (obj=0x55555777c2a0) at ../softmmu/memory.c:1764
+ * #2  0x0000555555cbf9b1 in object_deinit (obj=0x55555777c2a0, type=0x55555682cce0) at ../qom/object.c:675
+ * #3  0x0000555555cbfa23 in object_finalize (data=0x55555777c2a0) at ../qom/object.c:689
+ * #4  0x0000555555cc0840 in object_unref (objptr=0x55555777c2a0) at ../qom/object.c:1192
+ * #5  0x0000555555cc1ea6 in object_finalize_child_property (obj=0x55555777c210, name=0x5555570d1420 "kvm-apic-msi[0]", opaque=0x55555777c2a0) at ../qom/object.c:1735
+ * #6  0x0000555555cbf7bc in object_property_del_all (obj=0x55555777c210) at ../qom/object.c:627
+ * #7  0x0000555555cbfa10 in object_finalize (data=0x55555777c210) at ../qom/object.c:688
+ * #8  0x0000555555cc0840 in object_unref (objptr=0x55555777c210) at ../qom/object.c:1192
+ * #9  0x0000555555cc1ea6 in object_finalize_child_property (obj=0x5555571b41f0, name=0x555556d810f0 "lapic", opaque=0x55555777c210) at ../qom/object.c:1735
+ * #10 0x0000555555cbf8a5 in object_property_del_child (obj=0x5555571b41f0, child=0x55555777c210) at ../qom/object.c:649
+ * #11 0x0000555555cbf980 in object_unparent (obj=0x55555777c210) at ../qom/object.c:668
+ * #12 0x0000555555b1a73b in x86_cpu_unrealizefn (dev=0x5555571b41f0) at ../target/i386/cpu.c:6583
+ * #13 0x0000555555cbac37 in device_set_realized (obj=0x5555571b41f0, value=false, errp=0x555556792858 <error_abort>) at ../hw/core/qdev.c:620
+ * #14 0x0000555555cc3099 in property_set_bool (obj=0x5555571b41f0, v=0x7ffe4c000d00, name=0x5555560acbf9 "realized", opaque=0x55555684b700, errp=0x555556792858 <error_abort>) at ../qom/object.c:2273
+ * #15 0x0000555555cc10e0 in object_property_set (obj=0x5555571b41f0, name=0x5555560acbf9 "realized", v=0x7ffe4c000d00, errp=0x555556792858 <error_abort>) at ../qom/object.c:1408
+ * #16 0x0000555555cc548b in object_property_set_qobject (obj=0x5555571b41f0, name=0x5555560acbf9 "realized", value=0x7ffe4c0009a0, errp=0x555556792858 <error_abort>) at ../qom/qom-qobject.c:28
+ * #17 0x0000555555cc1445 in object_property_set_bool (obj=0x5555571b41f0, name=0x5555560acbf9 "realized", value=false, errp=0x555556792858 <error_abort>) at ../qom/object.c:1477
+ * #18 0x0000555555cba267 in qdev_unrealize (dev=0x5555571b41f0) at ../hw/core/qdev.c:347
+ * #19 0x0000555555ae07c1 in x86_cpu_unplug_cb (hotplug_dev=0x555556a44c10, dev=0x5555571b41f0, errp=0x0) at ../hw/i386/x86.c:241
+ * #20 0x0000555555b03d83 in pc_machine_device_unplug_cb (hotplug_dev=0x555556a44c10, dev=0x5555571b41f0, errp=0x0) at ../hw/i386/pc.c:1406
+ * #21 0x0000555555cbdc9a in hotplug_handler_unplug (plug_handler=0x555556a44c10, plugged_dev=0x5555571b41f0, errp=0x0) at ../hw/core/hotplug.c:56
+ * #22 0x00005555558fc4e8 in cpu_hotplug_wr (opaque=0x5555577a0370, addr=4, data=8, size=1) at ../hw/acpi/cpu.c:146
+ * #23 0x0000555555b851ef in memory_region_write_accessor (mr=0x5555577a0370, addr=4, value=0x7ffe66dfc6a8, size=1, shift=0, mask=255, attrs=...) at ../softmmu/memory.c:492
+ * #24 0x0000555555b85433 in access_with_adjusted_size (addr=4, value=0x7ffe66dfc6a8, size=1, access_size_min=1, access_size_max=4, access_fn=
+ * 0x555555b850f9 <memory_region_write_accessor>, mr=0x5555577a0370, attrs=...) at ../softmmu/memory.c:554
+ * #25 0x0000555555b88529 in memory_region_dispatch_write (mr=0x5555577a0370, addr=4, data=8, op=MO_8, attrs=...) at ../softmmu/memory.c:1514
+ * #26 0x0000555555b95764 in flatview_write_continue (fv=0x7ffe48617940, addr=44804, attrs=..., ptr=0x7ffff7e01000, len=1, addr1=4, l=1, mr=0x5555577a0370) at ../softmmu/physmem.c:2814
+ * #27 0x0000555555b958c7 in flatview_write (fv=0x7ffe48617940, addr=44804, attrs=..., buf=0x7ffff7e01000, len=1) at ../softmmu/physmem.c:2856
+ * #28 0x0000555555b95c77 in address_space_write (as=0x555556773440 <address_space_io>, addr=44804, attrs=..., buf=0x7ffff7e01000, len=1) at ../softmmu/physmem.c:2952
+ * #29 0x0000555555b95ce4 in address_space_rw (as=0x555556773440 <address_space_io>, addr=44804, attrs=..., buf=0x7ffff7e01000, len=1, is_write=true) at ../softmmu/physmem.c:2962
+ * #30 0x0000555555ca9b49 in kvm_handle_io (port=44804, attrs=..., data=0x7ffff7e01000, direction=1, size=1, count=1) at ../accel/kvm/kvm-all.c:2668
+ * #31 0x0000555555caa2c0 in kvm_cpu_exec (cpu=0x555556b23770) at ../accel/kvm/kvm-all.c:2919
+ * #32 0x0000555555cac0fc in kvm_vcpu_thread_fn (arg=0x555556b23770) at ../accel/kvm/kvm-accel-ops.c:49
+ * #33 0x0000555555f26257 in qemu_thread_start (args=0x555556b32ac0) at ../util/qemu-thread-posix.c:556
+ * #34 0x00007ffff55eeea5 in start_thread () at /lib64/libpthread.so.0
+ * #35 0x00007ffff53179fd in clone () at /lib64/libc.so.6
+ */
 void memory_region_transaction_commit(void)
 {
     AddressSpace *as;
@@ -1101,12 +1247,26 @@ void memory_region_transaction_commit(void)
 
             QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
                 address_space_set_flatview(as);
+                /*
+		 * called by:
+		 *   - softmmu/memory.c|1172| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+		 *   - softmmu/memory.c|1187| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+		 *   - softmmu/memory.c|3101| <<address_space_init>> address_space_update_ioeventfds(as);
+		 */
                 address_space_update_ioeventfds(as);
             }
             memory_region_update_pending = false;
             ioeventfd_update_pending = false;
             MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);
         } else if (ioeventfd_update_pending) {
+            /*
+	     * 在以下使用ioeventfd_update_pending:
+	     *   - softmmu/memory.c|1143| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+	     *   - softmmu/memory.c|1145| <<memory_region_transaction_commit>> } else if (ioeventfd_update_pending) {
+	     *   - softmmu/memory.c|1149| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+	     *   - softmmu/memory.c|2533| <<memory_region_add_eventfd>> ioeventfd_update_pending |= mr->enabled;
+	     *   - softmmu/memory.c|2568| <<memory_region_del_eventfd>> ioeventfd_update_pending |= mr->enabled;
+	     */
             QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
                 address_space_update_ioeventfds(as);
             }
@@ -1158,6 +1318,11 @@ static char *memory_region_escape_name(const char *name)
     return escaped;
 }
 
+/*
+ * called by:
+ *   - softmmu/memory.c|1195| <<memory_region_init>> memory_region_do_init(mr, owner, name, size);
+ *   - softmmu/memory.c|1746| <<memory_region_init_iommu>> memory_region_do_init(mr, owner, name, size);
+ */
 static void memory_region_do_init(MemoryRegion *mr,
                                   Object *owner,
                                   const char *name,
@@ -1548,6 +1713,13 @@ void memory_region_init_ram_nomigrate(MemoryRegion *mr,
     memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
 }
 
+/*
+ * called by:
+ *   - backends/hostmem-ram.c|33| <<ram_backend_memory_alloc>> memory_region_init_ram_flags_nomigrate(&backend->mr, OBJECT(backend), name,
+ *   - hw/m68k/next-cube.c|987| <<next_cube_init>> memory_region_init_ram_flags_nomigrate(bmapm1, NULL, "next.bmapmem", 64,
+ *   - softmmu/memory.c|1548| <<memory_region_init_ram_nomigrate>> memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
+ *   - softmmu/memory.c|1699| <<memory_region_init_rom_nomigrate>> memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
+ */
 void memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
                                             Object *owner,
                                             const char *name,
@@ -2444,6 +2616,17 @@ void memory_region_clear_flush_coalesced(MemoryRegion *mr)
 
 static bool userspace_eventfd_warning;
 
+/*
+ * called by:
+ *   - hw/misc/ivshmem.c|365| <<ivshmem_add_eventfd>> memory_region_add_eventfd(&s->ivshmem_mmio,
+ *   - hw/misc/pci-testdev.c|113| <<pci_testdev_start>> memory_region_add_eventfd(test->mr,
+ *   - hw/vfio/pci-quirks.c|401| <<vfio_ioeventfd_init>> memory_region_add_eventfd(ioeventfd->mr, ioeventfd->addr, ioeventfd->size,
+ *   - hw/virtio/virtio-mmio.c|52| <<virtio_mmio_ioeventfd_assign>> memory_region_add_eventfd(&proxy->iomem, VIRTIO_MMIO_QUEUE_NOTIFY, 4,
+ *   - hw/virtio/virtio-pci.c|250| <<virtio_pci_ioeventfd_assign>> memory_region_add_eventfd(modern_mr, modern_addr, 0,
+ *   - hw/virtio/virtio-pci.c|253| <<virtio_pci_ioeventfd_assign>> memory_region_add_eventfd(modern_mr, modern_addr, 2,
+ *   - hw/virtio/virtio-pci.c|257| <<virtio_pci_ioeventfd_assign>> memory_region_add_eventfd(modern_notify_mr, 0, 2,
+ *   - hw/virtio/virtio-pci.c|262| <<virtio_pci_ioeventfd_assign>> memory_region_add_eventfd(legacy_mr, legacy_addr, 2,
+ */
 void memory_region_add_eventfd(MemoryRegion *mr,
                                hwaddr addr,
                                unsigned size,
diff --git a/softmmu/physmem.c b/softmmu/physmem.c
index 4e1b27a20..c2663a0c9 100644
--- a/softmmu/physmem.c
+++ b/softmmu/physmem.c
@@ -1960,6 +1960,11 @@ static void dirty_memory_extend(ram_addr_t old_ram_size,
     }
 }
 
+/*
+ * called by:
+ *   - softmmu/physmem.c|2104| <<qemu_ram_alloc_from_fd>> ram_block_add(new_block, &local_err);
+ *   - softmmu/physmem.c|2169| <<qemu_ram_alloc_internal>> ram_block_add(new_block, &local_err);
+ */
 static void ram_block_add(RAMBlock *new_block, Error **errp)
 {
     const bool noreserve = qemu_ram_is_noreserve(new_block);
@@ -2139,6 +2144,12 @@ RAMBlock *qemu_ram_alloc_from_file(ram_addr_t size, MemoryRegion *mr,
 }
 #endif
 
+/*
+ * called by:
+ *   - softmmu/physmem.c|2181| <<qemu_ram_alloc_from_ptr>> return qemu_ram_alloc_internal(size, size, NULL, host, RAM_PREALLOC, mr,
+ *   - softmmu/physmem.c|2189| <<qemu_ram_alloc>> return qemu_ram_alloc_internal(size, size, NULL, NULL, ram_flags, mr, errp);
+ *   - softmmu/physmem.c|2198| <<qemu_ram_alloc_resizeable>> return qemu_ram_alloc_internal(size, maxsz, resized, NULL,
+ */
 static
 RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                   void (*resized)(const char*,
@@ -2175,6 +2186,11 @@ RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
     return new_block;
 }
 
+/*
+ * called by:
+ *   - softmmu/memory.c|1563| <<memory_region_init_ram_flags_nomigrate>> mr->ram_block = qemu_ram_alloc(size, ram_flags, mr, &err);
+ *   - softmmu/memory.c|1719| <<memory_region_init_rom_device_nomigrate>> mr->ram_block = qemu_ram_alloc(size, 0, mr, &err);
+ */
 RAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
                                    MemoryRegion *mr, Error **errp)
 {
diff --git a/stubs/trace-control.c b/stubs/trace-control.c
index 7f856e5c2..b9fa2e8e3 100644
--- a/stubs/trace-control.c
+++ b/stubs/trace-control.c
@@ -16,6 +16,13 @@ void trace_event_set_state_dynamic_init(TraceEvent *ev, bool state)
     trace_event_set_state_dynamic(ev, state);
 }
 
+/*
+ * called by:
+ *   - stubs/trace-control.c|16| <<trace_event_set_state_dynamic_init>> trace_event_set_state_dynamic(ev, state);
+ *   - trace/control-target.c|36| <<trace_event_set_state_dynamic>> void trace_event_set_state_dynamic(TraceEvent *ev, bool state)
+ *   - trace/control.c|188| <<do_trace_enable_events>> trace_event_set_state_dynamic(ev, enable);
+ *   - trace/qmp.c|165| <<qmp_trace_event_set_state>> trace_event_set_state_dynamic(ev, enable);
+ */
 void trace_event_set_state_dynamic(TraceEvent *ev, bool state)
 {
     bool state_pre;
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index cb6b5467d..1a023388c 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -673,6 +673,22 @@ void x86_cpu_vendor_words2str(char *dst, uint32_t vendor1,
 #define TCG_SGX_12_0_EBX_FEATURES 0
 #define TCG_SGX_12_1_EAX_FEATURES 0
 
+/*
+ * 在以下使用feature_word_info[FEATURE_WORDS]:
+ *   - target/i386/cpu-sysemu.c|68| <<x86_cpu_static_props>> FeatureWordInfo *fi = &feature_word_info[w];
+ *   - target/i386/cpu.c|1467| <<x86_cpu_get_migratable_flags>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|4350| <<mark_unavailable_features>> FeatureWordInfo *f = &feature_word_info[w];
+ *   - target/i386/cpu.c|4600| <<x86_cpu_get_feature_words>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|4653| <<x86_cpu_feature_name>> name = feature_word_info[w].feat_names[bitnr];
+ *   - target/i386/cpu.c|4654| <<x86_cpu_feature_name>> assert(bitnr < 32 || !(name && feature_word_info[w].type == CPUID_FEATURE_WORD));
+ *   - target/i386/cpu.c|4931| <<x86_cpu_list>> for (i = 0; i < ARRAY_SIZE(feature_word_info); i++) {
+ *   - target/i386/cpu.c|4932| <<x86_cpu_list>> FeatureWordInfo *fw = &feature_word_info[i];
+ *   - target/i386/cpu.c|4992| <<x86_cpu_get_supported_feature_word>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|6051| <<x86_cpu_adjust_feat_level>> FeatureWordInfo *fi = &feature_word_info[w];
+ *   - target/i386/cpu.c|6055| <<x86_cpu_adjust_feat_level>> assert(feature_word_info[w].type == CPUID_FEATURE_WORD);
+ *   - target/i386/cpu.c|6184| <<x86_cpu_expand_features>> ~feature_word_info[w].no_autoenable_flags;
+ *   - target/i386/cpu.c|6671| <<x86_cpu_register_feature_bit_props>> FeatureWordInfo *fi = &feature_word_info[w];
+ */
 FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
     [FEAT_1_EDX] = {
         .type = CPUID_FEATURE_WORD,
@@ -1780,6 +1796,11 @@ static const CPUCaches epyc_milan_cache_info = {
  *  PT in VMX operation
  */
 
+/*
+ * 在以下使用builtin_x86_defs[]:
+ *   - target/i386/cpu.c|7134| <<x86_cpu_register_types>> for (i = 0; i < ARRAY_SIZE(builtin_x86_defs); i++) {
+ *   - target/i386/cpu.c|7135| <<x86_cpu_register_types>> x86_register_cpudef_types(&builtin_x86_defs[i]);
+ */
 static const X86CPUDefinition builtin_x86_defs[] = {
     {
         .name = "qemu64",
@@ -4338,6 +4359,13 @@ static bool x86_cpu_have_filtered_features(X86CPU *cpu)
     return false;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|6304| <<x86_cpu_expand_features>> mark_unavailable_features(cpu, d->to.index,
+ *   - target/i386/cpu.c|6339| <<x86_cpu_expand_features>> mark_unavailable_features(cpu, FEAT_7_0_EBX,
+ *   - target/i386/cpu.c|6420| <<x86_cpu_filter_features>> mark_unavailable_features(cpu, w, unavailable_features, prefix);
+ *   - target/i386/cpu.c|6447| <<x86_cpu_filter_features>> mark_unavailable_features(cpu, FEAT_7_0_EBX, CPUID_7_0_EBX_INTEL_PT, prefix);
+ */
 static void mark_unavailable_features(X86CPU *cpu, FeatureWord w, uint64_t mask,
                                       const char *verbose_prefix)
 {
@@ -4345,6 +4373,10 @@ static void mark_unavailable_features(X86CPU *cpu, FeatureWord w, uint64_t mask,
     FeatureWordInfo *f = &feature_word_info[w];
     int i;
 
+    /*
+     * 在下面设置force_features:
+     *   - target/i386/cpu.c|7099| <<global>> DEFINE_PROP_BOOL("x-force-features", X86CPU, force_features, false),
+     */
     if (!cpu->force_features) {
         env->features[w] &= ~mask;
     }
@@ -4655,6 +4687,16 @@ static const char *x86_cpu_feature_name(FeatureWord w, int bitnr)
  * feat=on|feat even if the later is parsed after +-feat
  * (i.e. "-x2apic,x2apic=on" will result in x2apic disabled)
  */
+/*
+ * 在以下使用minus_features:
+ *   - target/i386/cpu.c|4719| <<x86_cpu_parse_featurestr>> minus_features = g_list_append(minus_features,
+ *   - target/i386/cpu.c|4741| <<x86_cpu_parse_featurestr>> if (g_list_find_custom(minus_features, name, compare_string)) {
+ *   - target/i386/cpu.c|6192| <<x86_cpu_expand_features>> for (l = minus_features; l; l = l->next) {
+ *   - target/sparc/cpu.c|124| <<sparc_cpu_parse_features>> GList *l, *plus_features = NULL, *minus_features = NULL;
+ *   - target/sparc/cpu.c|150| <<sparc_cpu_parse_features>> minus_features = g_list_append(minus_features,
+ *   - target/sparc/cpu.c|192| <<sparc_cpu_parse_features>> for (l = minus_features; l; l = l->next) {
+ *   - target/sparc/cpu.c|196| <<sparc_cpu_parse_features>> g_list_free_full(minus_features, g_free);
+ */
 static GList *plus_features, *minus_features;
 
 static gint compare_string(gconstpointer a, gconstpointer b)
@@ -4664,6 +4706,16 @@ static gint compare_string(gconstpointer a, gconstpointer b)
 
 /* Parse "+feature,-feature,feature=foo" CPU feature string
  */
+/*
+ * (gdb) bt
+ * #0  x86_cpu_parse_featurestr (typename=0x5555567f4ae0 "host-x86_64-cpu", features=0x55555680e620 "-x2apic", errp=0x55555679a800 <error_fatal>) at ../target/i386/cpu.c:4669
+ * #1  0x0000555555bf2f64 in parse_cpu_option (cpu_option=0x7fffffffe290 "host,-x2apic") at ../cpu.c:265
+ * #2  0x0000555555899305 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3761
+ * #3  0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * 在以下使用x86_cpu_parse_featurestr():
+ *   - target/i386/cpu.c|7071| <<x86_cpu_common_class_init>> cc->parse_features = x86_cpu_parse_featurestr;
+ */
 static void x86_cpu_parse_featurestr(const char *typename, char *features,
                                      Error **errp)
 {
@@ -4739,6 +4791,10 @@ static void x86_cpu_parse_featurestr(const char *typename, char *features,
             name = "tsc-frequency";
         }
 
+	/*
+	 * (gdb) p *prop
+	 * $2 = {driver = 0x5555567f4ae0 "host-x86_64-cpu", property = 0x55555680d990 "x2apic", value = 0x55555680d9b0 "off", used = false, optional = false}
+	 */
         prop = g_new0(typeof(*prop), 1);
         prop->driver = typename;
         prop->property = g_strdup(name);
@@ -4755,6 +4811,11 @@ static void x86_cpu_parse_featurestr(const char *typename, char *features,
 static void x86_cpu_filter_features(X86CPU *cpu, bool verbose);
 
 /* Build a list with the name of all features on a feature word array */
+/*
+ * called by:
+ *   - target/i386/cpu.c|4803| <<x86_cpu_get_unavailable_features>> x86_cpu_list_feature_names(xc->filtered_features, &result);
+ *   - target/i386/cpu.c|4836| <<x86_cpu_class_check_missing_features>> x86_cpu_list_feature_names(xc->filtered_features, tail);
+ */
 static void x86_cpu_list_feature_names(FeatureWordArray features,
                                        strList **list)
 {
@@ -4911,6 +4972,10 @@ static void x86_cpu_list_entry(gpointer data, gpointer user_data)
 }
 
 /* list available CPU models and flags */
+/*
+ * 在以下使用x86_cpu_list:
+ *   - target/i386/cpu.h|2095| <<cpu_list>> #define cpu_list x86_cpu_list
+ */
 void x86_cpu_list(void)
 {
     int i, j;
@@ -4981,6 +5046,12 @@ CpuDefinitionInfoList *qmp_query_cpu_definitions(Error **errp)
     return cpu_list;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|6286| <<x86_cpu_expand_features>> x86_cpu_get_supported_feature_word(w, cpu->migratable) &
+ *   - target/i386/cpu.c|6406| <<x86_cpu_filter_features>> x86_cpu_get_supported_feature_word(w, false);
+ *   - target/i386/kvm/kvm-cpu.c|105| <<kvm_cpu_xsave_init>> if ((x86_cpu_get_supported_feature_word(esa->feature, false) & esa->bits)
+ */
 uint64_t x86_cpu_get_supported_feature_word(FeatureWord w,
                                             bool migratable_only)
 {
@@ -5042,6 +5113,10 @@ void x86_cpu_apply_props(X86CPU *cpu, PropValue *props)
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|5128| <<x86_cpu_load_model>> x86_cpu_apply_version_props(cpu, model);
+ */
 static void x86_cpu_apply_version_props(X86CPU *cpu, X86CPUModel *model)
 {
     const X86CPUVersionDefinition *vdef;
@@ -5074,6 +5149,10 @@ static void x86_cpu_apply_version_props(X86CPU *cpu, X86CPUModel *model)
  * Load data from X86CPUDefinition into a X86CPU object.
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
+/*
+ * called by:
+ *   - target/i386/cpu.c|6745| <<x86_cpu_initfn>> x86_cpu_load_model(cpu, xcc->model);
+ */
 static void x86_cpu_load_model(X86CPU *cpu, X86CPUModel *model)
 {
     const X86CPUDefinition *def = model->cpudef;
@@ -5169,6 +5248,10 @@ static void x86_register_cpu_model_type(const char *name, X86CPUModel *model)
  * "max", "base" and subclasses ("host") are not registered here.
  * See x86_cpu_register_types for all model registrations.
  */
+/*
+ * called by:
+ *   - target/i386/cpu.c|7140| <<x86_cpu_register_types>> x86_register_cpudef_types(&builtin_x86_defs[i]);
+ */
 static void x86_register_cpudef_types(const X86CPUDefinition *def)
 {
     X86CPUModel *m;
@@ -5219,6 +5302,29 @@ uint32_t cpu_x86_virtual_addr_width(CPUX86State *env)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/fw_cfg.c|166| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 1, 0, &unused, &unused, &ecx, &edx);
+ *   - hw/i386/fw_cfg.c|178| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 0x7, 0, &unused, &ebx, &ecx, &unused);
+ *   - target/i386/hvf/hvf.c|377| <<hvf_cpu_x86_cpuid>> cpu_x86_cpuid(env, index, count, eax, ebx, ecx, edx);
+ *   - target/i386/kvm/kvm.c|1716| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, 0, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|1743| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1755| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1779| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1807| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1829| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1842| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1849| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1864| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, 0x0a, 0, &eax, &unused, &unused, &edx);
+ *   - target/i386/kvm/kvm.c|1888| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, 0x80000000, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|1904| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1920| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1934| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, 0xC0000000, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|1945| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/tcg/fpu_helper.c|2932| <<helper_xsetbv>> cpu_x86_cpuid(env, 0x0d, 0, &ena_lo, &dummy, &dummy, &ena_hi);
+ *   - target/i386/tcg/misc_helper.c|56| <<helper_cpuid>> cpu_x86_cpuid(env, (uint32_t)env->regs[R_EAX], (uint32_t)env->regs[R_ECX],
+ *   - target/i386/whpx/whpx-all.c|1217| <<whpx_vcpu_run>> cpu_x86_cpuid(env, cpuid_fn, 0, (UINT32 *)&rax, (UINT32 *)&rbx,
+ */
 void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,
                    uint32_t *eax, uint32_t *ebx,
                    uint32_t *ecx, uint32_t *edx)
@@ -6139,9 +6245,35 @@ static void x86_cpu_enable_xsave_components(X86CPU *cpu)
  *   any CPUID data based on host capabilities.
  */
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_expand_features (cpu=0x555556a5f460, errp=0x7fffffffd790) at ../target/i386/cpu.c:6147
+ * #1  0x0000555555b6d14e in x86_cpu_realizefn (dev=0x555556a5f460, errp=0x7fffffffd810) at ../target/i386/cpu.c:6381
+ * #2  0x0000555555d2325a in device_set_realized (obj=0x555556a5f460, value=true, errp=0x7fffffffd920) at ../hw/core/qdev.c:531
+ * #3  0x0000555555d2cd6c in property_set_bool (obj=0x555556a5f460, v=0x555556a6e980, name=0x5555560c1221 "realized", opaque=0x555556812500, errp=0x7fffffffd920) at ../qom/object.c:2273
+ * #4  0x0000555555d2adb3 in object_property_set (obj=0x555556a5f460, name=0x5555560c1221 "realized", v=0x555556a6e980, errp=0x7fffffffd920) at ../qom/object.c:1408
+ * #5  0x0000555555d2f15e in object_property_set_qobject (obj=0x555556a5f460, name=0x5555560c1221 "realized", value=0x555556a6be10, errp=0x55555679a800 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #6  0x0000555555d2b118 in object_property_set_bool (obj=0x555556a5f460, name=0x5555560c1221 "realized", value=true, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:1477
+ * #7  0x0000555555d22b22 in qdev_realize (dev=0x555556a5f460, bus=0x0, errp=0x55555679a800 <error_fatal>) at ../hw/core/qdev.c:333
+ * #8  0x0000555555b2e017 in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:101
+ * #9  0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #10 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #11 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #12 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #13 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #14 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #15 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #16 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 /* Expand CPU configuration data, based on configured features
  * and host/accelerator capabilities when appropriate.
  */
+/*
+ * called by:
+ *   - target/i386/cpu-sysemu.c|165| <<x86_cpu_from_model>> x86_cpu_expand_features(xc, &err);
+ *   - target/i386/cpu.c|4853| <<x86_cpu_class_check_missing_features>> x86_cpu_expand_features(xc, &err);
+ *   - target/i386/cpu.c|6501| <<x86_cpu_realizefn>> x86_cpu_expand_features(cpu, &local_err);
+ */
 void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
 {
     CPUX86State *env = &cpu->env;
@@ -6280,6 +6412,11 @@ void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
  *
  * Returns: 0 if all flags are supported by the host, non-zero otherwise.
  */
+/*
+ * called by:
+ *   - target/i386/cpu.c|4863| <<x86_cpu_class_check_missing_features>> x86_cpu_filter_features(xc, false);
+ *   - target/i386/cpu.c|6495| <<x86_cpu_realizefn>> x86_cpu_filter_features(cpu, cpu->check_cpuid || cpu->enforce_cpuid);
+ */
 static void x86_cpu_filter_features(X86CPU *cpu, bool verbose)
 {
     CPUX86State *env = &cpu->env;
@@ -6620,6 +6757,13 @@ static void x86_cpu_set_bit_prop(Object *obj, Visitor *v, const char *name,
     }
 
     if (value) {
+        /*
+	 * X86CPU *cpu (等价struct ArchCPU):
+	 * -> CPUX86State env;
+	 *    -> FeatureWordArray features;
+	 *    // Features that were explicitly enabled/disabled
+         *    -> FeatureWordArray user_features;
+	 */
         cpu->env.features[fp->w] |= fp->mask;
     } else {
         cpu->env.features[fp->w] &= ~fp->mask;
@@ -6633,6 +6777,25 @@ static void x86_cpu_set_bit_prop(Object *obj, Visitor *v, const char *name,
  * multiple bits in the same FeatureWord. In that case, the getter will return
  * true only if all bits are set.
  */
+/*
+ * (gdb) bt
+ * #0  x86_cpu_register_bit_prop (xcc=0x555556812140, prop_name=0x55555607a689 "x2apic", w=FEAT_1_ECX, bitnr=21) at ../target/i386/cpu.c:6641
+ * #1  0x0000555555b6dd1e in x86_cpu_register_feature_bit_props (xcc=0x555556812140, w=FEAT_1_ECX, bitnr=21) at ../target/i386/cpu.c:6681
+ * #2  0x0000555555b6e9ec in x86_cpu_common_class_init (oc=0x555556812140, data=0x0) at ../target/i386/cpu.c:7095
+ * #3  0x0000555555d28b97 in type_initialize (ti=0x5555567e1470) at ../qom/object.c:366
+ * #4  0x0000555555d28902 in type_initialize (ti=0x5555567ea7e0) at ../qom/object.c:314
+ * #5  0x0000555555d2a0fa in object_class_foreach_tramp (key=0x5555567ea960, value=0x5555567ea7e0, opaque=0x7fffffffdb90) at ../qom/object.c:1071
+ * #6  0x00007ffff6e46710 in g_hash_table_foreach () at /lib64/libglib-2.0.so.0
+ * #7  0x0000555555d2a1d9 in object_class_foreach (fn=0x555555d2a336 <object_class_get_list_tramp>, implements_type=0x555555faee84 "machine", include_abstract=false, opaque=0x7fffffffdbe0) at ../qom/object.c:1093
+ * #8  0x0000555555d2a3b1 in object_class_get_list (implements_type=0x555555faee84 "machine", include_abstract=false) at ../qom/object.c:1150
+ * #9  0x0000555555894512 in select_machine (qdict=0x55555680c600, errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:1661
+ * #10 0x00005555558956a4 in qemu_create_machine (qdict=0x55555680c600) at ../softmmu/vl.c:2146
+ * #11 0x00005555558991e5 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3708
+ * #12 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * called by:
+ *   - target/i386/cpu.c|6763| <<x86_cpu_register_feature_bit_props>> x86_cpu_register_bit_prop(xcc, name, w, bitnr);
+ */
 static void x86_cpu_register_bit_prop(X86CPUClass *xcc,
                                       const char *prop_name,
                                       FeatureWord w,
@@ -6686,6 +6849,9 @@ static void x86_cpu_post_initfn(Object *obj)
     accel_cpu_instance_init(CPU(obj));
 }
 
+/*
+ * const TypeInfo x86_cpu_type_info.instance_init = x86_cpu_initfn()
+ */
 static void x86_cpu_initfn(Object *obj)
 {
     X86CPU *cpu = X86_CPU(obj);
@@ -6873,6 +7039,10 @@ void x86_update_hflags(CPUX86State *env)
     env->hflags = hflags;
 }
 
+/*
+ * 在以下使用x86_cpu_properties[]:
+ *   - target/i386/cpu.c|7114| <<x86_cpu_common_class_init>> device_class_set_props(dc, x86_cpu_properties);
+ */
 static Property x86_cpu_properties[] = {
 #ifdef CONFIG_USER_ONLY
     /* apic_id = 0 by default for *-user, see commit 9886e834 */
diff --git a/target/i386/helper.c b/target/i386/helper.c
index fa409e9c4..e8cfa9f29 100644
--- a/target/i386/helper.c
+++ b/target/i386/helper.c
@@ -355,6 +355,11 @@ static void emit_guest_memory_failure(MemoryFailureAction action, bool ar,
                                    &mff);
 }
 
+/*
+ * called by:
+ *   - target/i386/helper.c|482| <<cpu_x86_inject_mce>> run_on_cpu(cs, do_inject_x86_mce, RUN_ON_CPU_HOST_PTR(&params));
+ *   - target/i386/helper.c|495| <<cpu_x86_inject_mce>> run_on_cpu(other_cs, do_inject_x86_mce, RUN_ON_CPU_HOST_PTR(&params));
+ */
 static void do_inject_x86_mce(CPUState *cs, run_on_cpu_data data)
 {
     MCEInjectionParams *params = data.host_ptr;
@@ -444,6 +449,11 @@ static void do_inject_x86_mce(CPUState *cs, run_on_cpu_data data)
     emit_guest_memory_failure(MEMORY_FAILURE_ACTION_INJECT, ar, recursive);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|629| <<kvm_mce_inject>> cpu_x86_inject_mce(NULL, cpu, 9, status, mcg_status, paddr,
+ *   - target/i386/monitor.c|599| <<hmp_mce>> cpu_x86_inject_mce(mon, cpu, bank, status, mcg_status, addr, misc,
+ */
 void cpu_x86_inject_mce(Monitor *mon, X86CPU *cpu, int bank,
                         uint64_t status, uint64_t mcg_status, uint64_t addr,
                         uint64_t misc, int flags)
diff --git a/target/i386/host-cpu.c b/target/i386/host-cpu.c
index 10f8aba86..8f2b9c32d 100644
--- a/target/i386/host-cpu.c
+++ b/target/i386/host-cpu.c
@@ -50,6 +50,10 @@ static void host_cpu_enable_cpu_pm(X86CPU *cpu)
     env->features[FEAT_1_ECX] |= CPUID_EXT_MONITOR;
 }
 
+/*
+ * called by:
+ *   - target/i386/host-cpu.c|92| <<host_cpu_realizefn>> uint32_t phys_bits = host_cpu_adjust_phys_bits(cpu);
+ */
 static uint32_t host_cpu_adjust_phys_bits(X86CPU *cpu)
 {
     uint32_t host_phys_bits = host_cpu_phys_bits();
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 9cf8e0366..bff256a5c 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -191,6 +191,11 @@ bool kvm_has_x2apic_api(void)
     return has_x2apic_api;
 }
 
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|3785| <<vtd_decide_config>> if (!kvm_enable_x2apic()) {
+ *   - target/i386/kvm/kvm-cpu.c|174| <<kvm_cpu_instance_init>> } else if (kvm_irqchip_is_split() && kvm_enable_x2apic()) {
+ */
 bool kvm_enable_x2apic(void)
 {
     return MEMORIZE(
@@ -249,8 +254,40 @@ void kvm_synchronize_all_tsc(void)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  try_get_cpuid (s=0x55555680c600, max=64) at ../target/i386/kvm/kvm.c:257
+ * #1  0x0000555555b144dc in get_supported_cpuid (s=0x55555680c600) at ../target/i386/kvm/kvm.c:288
+ * #2  0x0000555555b146d2 in kvm_arch_get_supported_cpuid (s=0x55555680c600, function=0, index=0, reg=0) at ../target/i386/kvm/kvm.c:356
+ * #3  0x0000555555b219d1 in kvm_cpu_max_instance_init (cpu=0x555556a5f390) at ../target/i386/kvm/kvm-cpu.c:77
+ * #4  0x0000555555b21cb6 in kvm_cpu_instance_init (cs=0x555556a5f390) at ../target/i386/kvm/kvm-cpu.c:183
+ * #5  0x0000555555ce9da1 in accel_cpu_instance_init (cpu=0x555556a5f390) at ../accel/accel-common.c:110
+ * #6  0x0000555555b6dd3b in x86_cpu_post_initfn (obj=0x555556a5f390) at ../target/i386/cpu.c:6686
+ * #7  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567e1470) at ../qom/object.c:384
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567f4600) at ../qom/object.c:388
+ * #9  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567f4960) at ../qom/object.c:388
+ * #10 0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f390, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #11 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #12 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #13 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #14 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #15 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #16 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #17 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #18 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #19 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #20 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #21 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 {
+    /*
+     * struct kvm_cpuid2 {
+     *     __u32 nent;
+     *     __u32 padding;
+     *     struct kvm_cpuid_entry2 entries[0];
+     * };
+     */
     struct kvm_cpuid2 *cpuid;
     int r, size;
 
@@ -277,6 +314,10 @@ static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 /* Run KVM_GET_SUPPORTED_CPUID ioctl(), allocating a buffer large enough
  * for all entries.
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|386| <<kvm_arch_get_supported_cpuid>> cpuid = get_supported_cpuid(s);
+ */
 static struct kvm_cpuid2 *get_supported_cpuid(KVMState *s)
 {
     struct kvm_cpuid2 *cpuid;
@@ -558,6 +599,10 @@ static int kvm_get_mce_cap_supported(KVMState *s, uint64_t *mce_cap,
     return -ENOSYS;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|676| <<kvm_arch_on_sigbus_vcpu>> kvm_mce_inject(cpu, paddr, code);
+ */
 static void kvm_mce_inject(X86CPU *cpu, hwaddr paddr, int code)
 {
     CPUState *cs = CPU(cpu);
@@ -597,6 +642,10 @@ static void emit_hypervisor_memory_failure(MemoryFailureAction action, bool ar)
                                    &mff);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|695| <<kvm_arch_on_sigbus_vcpu>> hardware_memory_error(addr);
+ */
 static void hardware_memory_error(void *host_addr)
 {
     emit_hypervisor_memory_failure(MEMORY_FAILURE_ACTION_FATAL, true);
@@ -604,6 +653,11 @@ static void hardware_memory_error(void *host_addr)
     exit(1);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2902| <<kvm_cpu_exec>> kvm_arch_on_sigbus_vcpu(cpu, pending_sigbus_code,
+ *   - accel/kvm/kvm-all.c|3455| <<kvm_on_sigbus>> kvm_arch_on_sigbus_vcpu(first_cpu, code, addr);
+ */
 void kvm_arch_on_sigbus_vcpu(CPUState *c, int code, void *addr)
 {
     X86CPU *cpu = X86_CPU(c);
@@ -1617,6 +1671,15 @@ static void kvm_init_xsave(CPUX86State *env)
            env->xsave_buf_len);
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_arch_init_vcpu (cs=0x555556a5f460) at ../target/i386/kvm/kvm.c:1621
+ * #1  0x0000555555d0c631 in kvm_init_vcpu (cpu=0x555556a5f460, errp=0x55555679a800 <error_fatal>) at ../accel/kvm/kvm-all.c:516
+ * #2  0x0000555555d13504 in kvm_vcpu_thread_fn (arg=0x555556a5f460) at ../accel/kvm/kvm-accel-ops.c:40
+ * #3  0x0000555555efbfb0 in qemu_thread_start (args=0x555556a6f3a0) at ../util/qemu-thread-posix.c:556
+ * #4  0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #5  0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ */
 int kvm_arch_init_vcpu(CPUState *cs)
 {
     struct {
@@ -2033,6 +2096,12 @@ int kvm_arch_init_vcpu(CPUState *cs)
     cpuid_data.cpuid.nent = cpuid_i;
 
     cpuid_data.cpuid.padding = 0;
+    /*
+     * struct {
+     *     struct kvm_cpuid2 cpuid;
+     *     struct kvm_cpuid_entry2 entries[KVM_MAX_CPUID_ENTRIES];
+     * } cpuid_data;
+     */
     r = kvm_vcpu_ioctl(cs, KVM_SET_CPUID2, &cpuid_data);
     if (r) {
         goto fail;
@@ -4328,6 +4397,12 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2763| <<do_kvm_cpu_synchronize_post_reset>> kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE);
+ *   - accel/kvm/kvm-all.c|2774| <<do_kvm_cpu_synchronize_post_init>> kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);
+ *   - accel/kvm/kvm-all.c|2867| <<kvm_cpu_exec>> kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);
+ */
 int kvm_arch_put_registers(CPUState *cpu, int level)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
diff --git a/trace/control.c b/trace/control.c
index 6c77cc631..789797e35 100644
--- a/trace/control.c
+++ b/trace/control.c
@@ -35,6 +35,14 @@ typedef struct TraceEventGroup {
     TraceEvent **events;
 } TraceEventGroup;
 
+/*
+ * 在以下使用event_groups:
+ *   - trace/control.c|82| <<trace_event_register_group>> event_groups = g_renew(TraceEventGroup, event_groups, nevent_groups + 1);
+ *   - trace/control.c|83| <<trace_event_register_group>> event_groups[nevent_groups].events = events;
+ *   - trace/control.c|130| <<trace_event_iter_next>> event_groups[iter->group].events[iter->event] != NULL) {
+ *   - trace/control.c|131| <<trace_event_iter_next>> TraceEvent *ev = event_groups[iter->group].events[iter->event];
+ *   - trace/control.c|134| <<trace_event_iter_next>> if (event_groups[iter->group].events[iter->event] == NULL) {
+ */
 static TraceEventGroup *event_groups;
 static size_t nevent_groups;
 static uint32_t next_id;
@@ -63,6 +71,15 @@ QemuOptsList qemu_trace_opts = {
 };
 
 
+/*
+ * (gdb) bt
+ * #0  trace_event_register_group (events=0x5555567419c0 <root_trace_events>) at ../trace/control.c:69
+ * #1  0x0000555555e537df in trace_root_register_events () at trace/trace-root.c:490
+ * #2  0x0000555555f26bea in module_call_init (type=MODULE_INIT_TRACE) at ../util/module.c:108
+ * #3  0x000055555588be62 in qemu_init_subsystems () at ../softmmu/runstate.c:755
+ * #4  0x000055555589265e in qemu_init (argc=16, argv=0x7fffffffdf38, envp=0x7fffffffdfc0) at ../softmmu/vl.c:2820
+ * #5  0x0000555555836ecd in main (argc=16, argv=0x7fffffffdf38, envp=0x7fffffffdfc0) at ../softmmu/main.c:49
+ */
 void trace_event_register_group(TraceEvent **events)
 {
     size_t i;
@@ -149,6 +166,10 @@ TraceEvent *trace_event_iter_next(TraceEventIter *iter)
     return NULL;
 }
 
+/*
+ * called by:
+ *   - trace/control.c|220| <<trace_enable_events>> trace_list_events(stdout);
+ */
 void trace_list_events(FILE *f)
 {
     TraceEventIter iter;
@@ -197,6 +218,12 @@ static void do_trace_enable_events(const char *line_buf)
     }
 }
 
+/*
+ * called by:
+ *   - trace/control.c|255| <<trace_init_events>> trace_enable_events(line_buf);
+ *   - trace/control.c|341| <<trace_opt_parse>> trace_enable_events(qemu_opt_get(opts, "enable"));
+ *   - util/log.c|468| <<qemu_str_to_log_mask>> trace_enable_events((*tmp) + 6);
+ */
 void trace_enable_events(const char *line_buf)
 {
     if (is_help_option(line_buf)) {
diff --git a/trace/qmp.c b/trace/qmp.c
index 3b4f4702b..2ad349046 100644
--- a/trace/qmp.c
+++ b/trace/qmp.c
@@ -66,6 +66,10 @@ static bool check_events(bool has_vcpu, bool ignore_unavailable, bool is_pattern
     }
 }
 
+/*
+ * called by:
+ *   - monitor/misc.c|375| <<hmp_info_trace_events>> events = qmp_trace_event_get_state(name, has_vcpu, vcpu, &local_err);
+ */
 TraceEventInfoList *qmp_trace_event_get_state(const char *name,
                                               bool has_vcpu, int64_t vcpu,
                                               Error **errp)
diff --git a/trace/simple.c b/trace/simple.c
index 18af590cf..78316b1f4 100644
--- a/trace/simple.c
+++ b/trace/simple.c
@@ -253,6 +253,17 @@ static void read_from_buffer(unsigned int idx, void *dataptr, size_t size)
     }
 }
 
+/*
+ * called by:
+ *   - trace/simple.c|201| <<trace_record_write_u64>> rec->rec_off = write_to_buffer(rec->rec_off, &val, sizeof(uint64_t));
+ *   - trace/simple.c|207| <<trace_record_write_str>> rec->rec_off = write_to_buffer(rec->rec_off, &slen, sizeof(slen));
+ *   - trace/simple.c|209| <<trace_record_write_str>> rec->rec_off = write_to_buffer(rec->rec_off, (void *)s, slen);
+ *   - trace/simple.c|234| <<trace_record_start>> rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));
+ *   - trace/simple.c|235| <<trace_record_start>> rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));
+ *   - trace/simple.c|236| <<trace_record_start>> rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));
+ *   - trace/simple.c|237| <<trace_record_start>> rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));
+ *   - trace/simple.c|275| <<trace_record_finish>> write_to_buffer(rec->tbuf_idx, &record, sizeof(TraceRecord));
+ */
 static unsigned int write_to_buffer(unsigned int idx, void *dataptr, size_t size)
 {
     uint8_t *data_ptr = dataptr;
@@ -305,6 +316,14 @@ static int st_write_event_mapping(TraceEventIter *iter)
  *
  * @enable: enable if %true, else disable.
  */
+/*
+ * called by:
+ *   - monitor/misc.c|204| <<hmp_trace_file>> st_set_trace_file_enabled(true);
+ *   - monitor/misc.c|206| <<hmp_trace_file>> st_set_trace_file_enabled(false);
+ *   - trace/control.c|254| <<trace_init_file>> st_set_trace_file_enabled(true);
+ *   - trace/simple.c|361| <<st_set_trace_file>> bool saved_enable = st_set_trace_file_enabled(false);
+ *   - trace/simple.c|372| <<st_set_trace_file>> st_set_trace_file_enabled(saved_enable);
+ */
 bool st_set_trace_file_enabled(bool enable)
 {
     TraceEventIter iter;
diff --git a/util/log.c b/util/log.c
index 2ee1500be..81d2d53f9 100644
--- a/util/log.c
+++ b/util/log.c
@@ -27,7 +27,25 @@
 #include "qemu/thread.h"
 #include "qemu/lockable.h"
 
+/*
+ * 在以下使用logfilename:
+ *   - util/log.c|116| <<qemu_set_log>> if (qemu_loglevel && (!is_daemonized() || logfilename)) {
+ *   - util/log.c|126| <<qemu_set_log>> if (logfilename) {
+ *   - util/log.c|127| <<qemu_set_log>> logfile->fd = fopen(logfilename, log_append ? "a" : "w");
+ *   - util/log.c|130| <<qemu_set_log>> perror(logfilename);
+ *   - util/log.c|194| <<qemu_set_log_filename>> g_free(logfilename);
+ *   - util/log.c|195| <<qemu_set_log_filename>> logfilename = NULL;
+ *   - util/log.c|205| <<qemu_set_log_filename>> logfilename = g_strdup_printf(filename, getpid());
+ *   - util/log.c|208| <<qemu_set_log_filename>> logfilename = g_strdup(filename);
+ */
 static char *logfilename;
+/*
+ * 在以下使用qemu_logfile_mutex:
+ *   - util/log.c|62| <<qemu_logfile_init>> qemu_mutex_init(&qemu_logfile_mutex);
+ *   - util/log.c|119| <<qemu_set_log>> QEMU_LOCK_GUARD(&qemu_logfile_mutex);
+ *   - util/log.c|356| <<qemu_log_close>> qemu_mutex_lock(&qemu_logfile_mutex);
+ *   - util/log.c|363| <<qemu_log_close>> qemu_mutex_unlock(&qemu_logfile_mutex);
+ */
 static QemuMutex qemu_logfile_mutex;
 QemuLogFile *qemu_logfile;
 int qemu_loglevel;
@@ -35,6 +53,18 @@ static int log_append = 0;
 static GArray *debug_regions;
 
 /* Return the number of characters emitted.  */
+/*
+ * (gdb) bt
+ * #0  qemu_log (fmt=0x55c1c4e201b8 "%d@%zu.%06zu:kvm_vcpu_ioctl cpu_index %d, type 0x%x, arg %p\n") at ../util/log.c:129
+ * #1  0x000055c1c4a7bf75 in _nocheck__trace_kvm_vcpu_ioctl (cpu_index=3, type=44672, arg=0x0) at /home/zhang/kvm/test/qemu/accel/kvm/trace-events:6
+ * #2  0x000055c1c4a7bfdb in trace_kvm_vcpu_ioctl (cpu_index=3, type=44672, arg=0x0) at trace/trace-accel_kvm.h:173
+ * #3  0x000055c1c4a83926 in kvm_vcpu_ioctl (cpu=0x55c1c5d0fb60, type=44672) at ../accel/kvm/kvm-all.c:3088
+ * #4  0x000055c1c4a831b1 in kvm_cpu_exec (cpu=0x55c1c5d0fb60) at ../accel/kvm/kvm-all.c:2904
+ * #5  0x000055c1c4a85fe0 in kvm_vcpu_thread_fn (arg=0x55c1c5d0fb60) at ../accel/kvm/kvm-accel-ops.c:49
+ * #6  0x000055c1c4c61514 in qemu_thread_start (args=0x55c1c5d1ed50) at ../util/qemu-thread-posix.c:504
+ * #7  0x00007f6366bd2ea5 in start_thread () at /lib64/libpthread.so.0
+ * #8  0x00007f63668fb9fd in clone () at /lib64/libc.so.6
+ */
 int qemu_log(const char *fmt, ...)
 {
     int ret = 0;
@@ -72,9 +102,30 @@ static void qemu_logfile_free(QemuLogFile *logfile)
     g_free(logfile);
 }
 
+/*
+ * 在以下使用log_uses_own_buffers:
+ *   - util/log.c|141| <<qemu_set_log>> if (log_uses_own_buffers) {
+ *   - util/log.c|160| <<qemu_log_needs_buffers>> log_uses_own_buffers = true;
+ */
 static bool log_uses_own_buffers;
 
 /* enable or disable low levels log */
+/*
+ * called by:
+ *   - bsd-user/main.c|418| <<main>> qemu_set_log(mask);
+ *   - linux-user/main.c|683| <<main>> qemu_set_log(log_mask);
+ *   - monitor/misc.c|442| <<hmp_log>> qemu_set_log(mask);
+ *   - qemu-img.c|5445| <<main>> qemu_set_log(LOG_TRACE);
+ *   - qemu-io.c|637| <<main>> qemu_set_log(LOG_TRACE);
+ *   - qemu-nbd.c|807| <<main>> qemu_set_log(LOG_TRACE);
+ *   - scsi/qemu-pr-helper.c|1004| <<main>> qemu_set_log(LOG_TRACE);
+ *   - softmmu/vl.c|2572| <<qemu_process_early_options>> qemu_set_log(mask);
+ *   - softmmu/vl.c|2574| <<qemu_process_early_options>> qemu_set_log(0);
+ *   - storage-daemon/qemu-storage-daemon.c|395| <<main>> qemu_set_log(LOG_TRACE);
+ *   - target/hexagon/translate.c|879| <<hexagon_translate_init>> qemu_set_log(qemu_loglevel);
+ *   - tests/unit/test-logging.c|126| <<test_logfile_write>> qemu_set_log(CPU_LOG_TB_OUT_ASM);
+ *   - util/log.c|175| <<qemu_set_log_filename>> qemu_set_log(qemu_loglevel);
+ */
 void qemu_set_log(int log_flags)
 {
     bool need_to_open_file = false;
@@ -139,6 +190,11 @@ void qemu_set_log(int log_flags)
     }
 }
 
+/*
+ * called by:
+ *   - bsd-user/main.c|408| <<main>> qemu_log_needs_buffers();
+ *   - linux-user/main.c|682| <<main>> qemu_log_needs_buffers();
+ */
 void qemu_log_needs_buffers(void)
 {
     log_uses_own_buffers = true;
@@ -151,6 +207,18 @@ void qemu_log_needs_buffers(void)
  *
  * filename may be NULL. In that case, log output is sent to stderr
  */
+/*
+ * called by:
+ *   - bsd-user/main.c|409| <<main>> qemu_set_log_filename(log_file, &error_fatal);
+ *   - linux-user/main.c|260| <<handle_arg_log_filename>> qemu_set_log_filename(arg, &error_fatal);
+ *   - monitor/misc.c|422| <<hmp_logfile>> qemu_set_log_filename(qdict_get_str(qdict, "filename"), &err);
+ *   - softmmu/vl.c|2563| <<qemu_process_early_options>> qemu_set_log_filename(log_file, &error_fatal);
+ *   - tests/unit/test-logging.c|94| <<set_log_path_tmp>> qemu_set_log_filename(file_path, errp);
+ *   - tests/unit/test-logging.c|134| <<test_logfile_write>> qemu_set_log_filename(file_path, &error_abort);
+ *   - tests/unit/test-logging.c|143| <<test_logfile_write>> qemu_set_log_filename(file_path1, &error_abort);
+ *   - tests/unit/test-logging.c|165| <<test_logfile_lock>> qemu_set_log_filename(file_path, &error_abort);
+ *   - trace/control.c|264| <<trace_init_file>> qemu_set_log_filename(trace_opts_file, &error_fatal);
+ */
 void qemu_set_log_filename(const char *filename, Error **errp)
 {
     g_free(logfilename);
@@ -177,6 +245,16 @@ void qemu_set_log_filename(const char *filename, Error **errp)
 
 /* Returns true if addr is in our debug filter or no filter defined
  */
+/*
+ * called by:
+ *   - accel/tcg/cpu-exec.c|208| <<log_cpu_exec>> && qemu_log_in_addr_range(pc)) {
+ *   - accel/tcg/translate-all.c|1530| <<tb_gen_code>> qemu_log_in_addr_range(tb->pc)) {
+ *   - accel/tcg/translator.c|141| <<translator_loop>> && qemu_log_in_addr_range(db->pc_first)) {
+ *   - include/qemu/log.h|134| <<qemu_log_mask_and_addr>> qemu_log_in_addr_range(ADDR)) { \
+ *   - tcg/tcg.c|4202| <<tcg_gen_code>> && qemu_log_in_addr_range(tb->pc))) {
+ *   - tcg/tcg.c|4247| <<tcg_gen_code>> && qemu_log_in_addr_range(tb->pc))) {
+ *   - tcg/tcg.c|4268| <<tcg_gen_code>> && qemu_log_in_addr_range(tb->pc))) {
+ */
 bool qemu_log_in_addr_range(uint64_t addr)
 {
     if (debug_regions) {
@@ -194,6 +272,11 @@ bool qemu_log_in_addr_range(uint64_t addr)
 }
 
 
+/*
+ * called by:
+ *   - linux-user/main.c|255| <<handle_arg_dfilter>> qemu_set_dfilter_ranges(arg, &error_fatal);
+ *   - softmmu/vl.c|3058| <<qemu_init>> qemu_set_dfilter_ranges(optarg, &error_fatal);
+ */
 void qemu_set_dfilter_ranges(const char *filter_spec, Error **errp)
 {
     gchar **ranges = g_strsplit(filter_spec, ",", 0);
@@ -267,6 +350,15 @@ out:
 }
 
 /* fflush() the log file */
+/*
+ * called by:
+ *   - accel/tcg/translate-all.c|1592| <<tb_gen_code>> qemu_log_flush();
+ *   - cpu.c|408| <<cpu_abort>> qemu_log_flush();
+ *   - hw/net/can/can_sja1000.c|263| <<can_display_msg>> qemu_log_flush();
+ *   - hw/xen/xen_pvdev.c|229| <<xen_pv_printf>> qemu_log_flush();
+ *   - net/can/can_socketcan.c|90| <<can_host_socketcan_display_msg>> qemu_log_flush();
+ *   - tcg/tcg.c|783| <<tcg_prologue_init>> qemu_log_flush();
+ */
 void qemu_log_flush(void)
 {
     QemuLogFile *logfile;
@@ -280,6 +372,13 @@ void qemu_log_flush(void)
 }
 
 /* Close the log file */
+/*
+ * called by:
+ *   - cpu.c|410| <<cpu_abort>> qemu_log_close();
+ *   - tests/unit/test-logging.c|175| <<test_logfile_lock>> qemu_log_close();
+ *   - tests/unit/test-logging.c|213| <<main>> qemu_log_close();
+ *   - util/log.c|190| <<qemu_set_log_filename>> qemu_log_close();
+ */
 void qemu_log_close(void)
 {
     QemuLogFile *logfile;
@@ -294,6 +393,13 @@ void qemu_log_close(void)
     qemu_mutex_unlock(&qemu_logfile_mutex);
 }
 
+/*
+ * 在以下使用qemu_log_items[]:
+ *   - monitor/hmp.c|296| <<help_cmd>> for (item = qemu_log_items; item->mask != 0; item++) {
+ *   - util/log.c|381| <<qemu_str_to_log_mask>> for (item = qemu_log_items; item->mask != 0; item++) {
+ *   - util/log.c|390| <<qemu_str_to_log_mask>> for (item = qemu_log_items; item->mask != 0; item++) {
+ *   - util/log.c|413| <<qemu_print_log_usage>> for (item = qemu_log_items; item->mask != 0; item++) {
+ */
 const QEMULogItem qemu_log_items[] = {
     { CPU_LOG_TB_OUT_ASM, "out_asm",
       "show generated host assembly code for each compiled TB" },
@@ -338,6 +444,13 @@ const QEMULogItem qemu_log_items[] = {
 };
 
 /* takes a comma separated list of log masks. Return 0 if error. */
+/*
+ * called by:
+ *   - bsd-user/main.c|413| <<main>> mask = qemu_str_to_log_mask(log_mask);
+ *   - linux-user/main.c|246| <<handle_arg_log>> last_log_mask = qemu_str_to_log_mask(arg);
+ *   - monitor/misc.c|436| <<hmp_log>> mask = qemu_str_to_log_mask(items);
+ *   - softmmu/vl.c|2567| <<qemu_process_early_options>> mask = qemu_str_to_log_mask(log_mask);
+ */
 int qemu_str_to_log_mask(const char *str)
 {
     const QEMULogItem *item;
@@ -375,6 +488,12 @@ int qemu_str_to_log_mask(const char *str)
     return 0;
 }
 
+/*
+ * called by:
+ *   - bsd-user/main.c|415| <<main>> qemu_print_log_usage(stdout);
+ *   - linux-user/main.c|248| <<handle_arg_log>> qemu_print_log_usage(stdout);
+ *   - softmmu/vl.c|2569| <<qemu_process_early_options>> qemu_print_log_usage(stdout);
+ */
 void qemu_print_log_usage(FILE *f)
 {
     const QEMULogItem *item;
-- 
2.17.1

