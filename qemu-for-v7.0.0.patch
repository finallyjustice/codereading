From a7fe09ea0572c4bd4f350618f37e7808f3b058f7 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 22 Aug 2022 18:02:30 -0700
Subject: [PATCH 1/1] qemu for v7.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/accel-softmmu.c           |  13 +++
 accel/dummy-cpus.c              |   4 +
 accel/kvm/kvm-accel-ops.c       |   8 ++
 accel/kvm/kvm-all.c             |  16 +++
 backends/hostmem-ram.c          |   7 ++
 block/file-posix.c              |   8 ++
 hw/core/qdev-properties.c       |  30 ++++++
 hw/i386/intel_iommu.c           |  33 +++++++
 hw/isa/piix3.c                  |  46 +++++++++
 hw/net/vhost_net.c              |   4 +
 hw/net/virtio-net.c             |   5 +
 hw/pci/pci.c                    |   4 +
 hw/scsi/virtio-scsi-dataplane.c |   4 +
 hw/virtio/virtio.c              |  13 +++
 include/hw/qdev-core.h          |  15 +++
 qom/object.c                    |  92 +++++++++++++++++
 softmmu/cpus.c                  |  27 +++++
 softmmu/memory.c                |  12 +++
 softmmu/physmem.c               |  16 +++
 target/i386/cpu.c               | 170 ++++++++++++++++++++++++++++++++
 target/i386/host-cpu.c          |   4 +
 target/i386/kvm/kvm.c           |  62 ++++++++++++
 22 files changed, 593 insertions(+)

diff --git a/accel/accel-softmmu.c b/accel/accel-softmmu.c
index 67276e4f5..c081b6ea3 100644
--- a/accel/accel-softmmu.c
+++ b/accel/accel-softmmu.c
@@ -47,6 +47,19 @@ int accel_init_machine(AccelState *accel, MachineState *ms)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|249| <<kvm_get_max_memslots>> KVMState *s = KVM_STATE(current_accel());
+ *   - accel/kvm/kvm-all.c|2312| <<kvm_vcpu_id_is_valid>> KVMState *s = KVM_STATE(current_accel());
+ *   - accel/tcg/tcg-all.c|115| <<tcg_init_machine>> TCGState *s = TCG_STATE(current_accel());
+ *   - bsd-user/main.c|454| <<main>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - hw/ppc/pef.c|85| <<kvmppc_svm_off>> rc = kvm_vm_ioctl(KVM_STATE(current_accel()), KVM_PPC_SVM_OFF);
+ *   - linux-user/main.c|738| <<main>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - softmmu/memory.c|3338| <<mtree_info_flatview>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - softmmu/vl.c|2427| <<configure_accelerators>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - target/i386/kvm/kvm.c|171| <<kvm_x2apic_api_set_flags>> KVMState *s = KVM_STATE(current_accel());
+ *   - target/ppc/kvm.c|268| <<kvm_get_radix_page_info>> KVMState *s = KVM_STATE(current_accel());
+ */
 AccelState *current_accel(void)
 {
     return current_machine->accelerator;
diff --git a/accel/dummy-cpus.c b/accel/dummy-cpus.c
index 10429fdfb..e2cdf195a 100644
--- a/accel/dummy-cpus.c
+++ b/accel/dummy-cpus.c
@@ -58,6 +58,10 @@ static void *dummy_cpu_thread_fn(void *arg)
     return NULL;
 }
 
+/*
+ * 在以下使用dummy_start_vcpu_thread():
+ *   - accel/qtest/qtest.c|53| <<qtest_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+ */
 void dummy_start_vcpu_thread(CPUState *cpu)
 {
     char thread_name[VCPU_THREAD_NAME_SIZE];
diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index c4244a23c..231c7ec11 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -24,6 +24,10 @@
 
 #include "kvm-cpus.h"
 
+/*
+ * 在以下使用kvm_vcpu_thread_fn():
+ *   - accel/kvm/kvm-accel-ops.c|77| <<kvm_start_vcpu_thread>> qemu_thread_create(cpu->thread, thread_name, kvm_vcpu_thread_fn,
+ */
 static void *kvm_vcpu_thread_fn(void *arg)
 {
     CPUState *cpu = arg;
@@ -61,6 +65,10 @@ static void *kvm_vcpu_thread_fn(void *arg)
     return NULL;
 }
 
+/*
+ * 在以下使用kvm_start_vcpu_thread():
+ *   - accel/kvm/kvm-accel-ops.c|91| <<kvm_accel_ops_class_init>> ops->create_vcpu_thread = kvm_start_vcpu_thread;
+ */
 static void kvm_start_vcpu_thread(CPUState *cpu)
 {
     char thread_name[VCPU_THREAD_NAME_SIZE];
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 5f1377ca0..34f40942a 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -431,6 +431,10 @@ err:
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|57| <<kvm_vcpu_thread_fn>> kvm_destroy_vcpu(cpu);
+ */
 void kvm_destroy_vcpu(CPUState *cpu)
 {
     if (do_kvm_destroy_vcpu(cpu) < 0) {
@@ -439,6 +443,10 @@ void kvm_destroy_vcpu(CPUState *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|468| <<kvm_init_vcpu>> ret = kvm_get_vcpu(s, kvm_arch_vcpu_id(cpu));
+ */
 static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id)
 {
     struct KVMParkedVcpu *cpu;
@@ -457,6 +465,10 @@ static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id)
     return kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)vcpu_id);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|40| <<kvm_vcpu_thread_fn>> r = kvm_init_vcpu(cpu, &error_fatal);
+ */
 int kvm_init_vcpu(CPUState *cpu, Error **errp)
 {
     KVMState *s = kvm_state;
@@ -2837,6 +2849,10 @@ static void kvm_eat_signals(CPUState *cpu)
     } while (sigismember(&chkset, SIG_IPI));
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|49| <<kvm_vcpu_thread_fn>> r = kvm_cpu_exec(cpu);
+ */
 int kvm_cpu_exec(CPUState *cpu)
 {
     struct kvm_run *run = cpu->kvm_run;
diff --git a/backends/hostmem-ram.c b/backends/hostmem-ram.c
index b8e55cdbd..3e3ccda47 100644
--- a/backends/hostmem-ram.c
+++ b/backends/hostmem-ram.c
@@ -16,6 +16,10 @@
 #include "qemu/module.h"
 #include "qom/object_interfaces.h"
 
+/*
+ * 在以下使用ram_backend_memory_alloc():
+ *   - backends/hostmem-ram.c|43| <<ram_backend_class_init>> bc->alloc = ram_backend_memory_alloc;
+ */
 static void
 ram_backend_memory_alloc(HostMemoryBackend *backend, Error **errp)
 {
@@ -43,6 +47,9 @@ ram_backend_class_init(ObjectClass *oc, void *data)
     bc->alloc = ram_backend_memory_alloc;
 }
 
+/*
+ * parent是host_memory_backend_info
+ */
 static const TypeInfo ram_backend_info = {
     .name = TYPE_MEMORY_BACKEND_RAM,
     .parent = TYPE_MEMORY_BACKEND,
diff --git a/block/file-posix.c b/block/file-posix.c
index 39a3d6dbe..70c172bc2 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -1176,6 +1176,10 @@ static void raw_reopen_abort(BDRVReopenState *state)
     s->reopen_state = NULL;
 }
 
+/*
+ * called by:
+ *   - block/file-posix.c|1285| <<raw_refresh_limits>> int ret = hdev_get_max_hw_transfer(s->fd, &st);
+ */
 static int hdev_get_max_hw_transfer(int fd, struct stat *st)
 {
 #ifdef BLKSECTGET
@@ -1196,6 +1200,10 @@ static int hdev_get_max_hw_transfer(int fd, struct stat *st)
 #endif
 }
 
+/*
+ * called by:
+ *   - block/file-posix.c|1291| <<raw_refresh_limits>> ret = hdev_get_max_segments(s->fd, &st);
+ */
 static int hdev_get_max_segments(int fd, struct stat *st)
 {
 #ifdef CONFIG_LINUX
diff --git a/hw/core/qdev-properties.c b/hw/core/qdev-properties.c
index c34aac6eb..b941ba96e 100644
--- a/hw/core/qdev-properties.c
+++ b/hw/core/qdev-properties.c
@@ -720,6 +720,14 @@ void qdev_prop_set_enum(DeviceState *dev, const char *name, int value)
                             &error_abort);
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev-properties.c|736| <<qdev_prop_register_global>> g_ptr_array_add(global_props(), prop);
+ *   - hw/core/qdev-properties.c|742| <<qdev_find_global_prop>> GPtrArray *props = global_props();
+ *   - hw/core/qdev-properties.c|760| <<qdev_prop_check_globals>> for (i = 0; i < global_props()->len; i++) {
+ *   - hw/core/qdev-properties.c|765| <<qdev_prop_check_globals>> prop = g_ptr_array_index(global_props(), i);
+ *   - hw/core/qdev-properties.c|790| <<qdev_prop_set_globals>> object_apply_global_props(OBJECT(dev), global_props(),
+ */
 static GPtrArray *global_props(void)
 {
     static GPtrArray *gp;
@@ -785,6 +793,28 @@ int qdev_prop_check_globals(void)
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:791
+ * #1  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #2  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #3  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #4  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #5  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #7  0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #8  0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #9  0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #10 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #11 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #12 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #13 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #14 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #15 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #16 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #17 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #18 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 void qdev_prop_set_globals(DeviceState *dev)
 {
     object_apply_global_props(OBJECT(dev), global_props(),
diff --git a/hw/i386/intel_iommu.c b/hw/i386/intel_iommu.c
index c64aa81a8..a119aa753 100644
--- a/hw/i386/intel_iommu.c
+++ b/hw/i386/intel_iommu.c
@@ -3352,6 +3352,39 @@ static MemTxResult vtd_mem_ir_read(void *opaque, hwaddr addr,
     return MEMTX_OK;
 }
 
+/*
+ * (gdb) bt
+ * #0  vtd_mem_ir_write (opaque=0x55555779aaa0, addr=600, value=0, size=4, attrs=...) at ../hw/i386/intel_iommu.c:3358
+ * #1  0x0000555555bd9047 in memory_region_write_with_attrs_accessor (mr=0x55555779aff0, addr=600, value=0x7ffe6e3fe338, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:513
+ * #2  0x0000555555bd9186 in access_with_adjusted_size (addr=600, value=0x7ffe6e3fe338, size=4, access_size_min=4, access_size_max=4, access_fn=
+ *     0x555555bd8f4d <memory_region_write_with_attrs_accessor>, mr=0x55555779aff0, attrs=...) at ../softmmu/memory.c:554
+ * #3  0x0000555555bdc2ba in memory_region_dispatch_write (mr=0x55555779aff0, addr=600, data=0, op=MO_32, attrs=...) at ../softmmu/memory.c:1521
+ * #4  0x0000555555beb2a2 in address_space_stl_internal (as=0x55555767da30, addr=4276093528, val=0, attrs=..., result=0x0, endian=DEVICE_LITTLE_ENDIAN) at /home/zhang/kvm/test/qemu-7.0.0/memory_ldst.c.inc:319
+ * #5  0x0000555555beb3d9 in address_space_stl_le (as=0x55555767da30, addr=4276093528, val=0, attrs=..., result=0x0) at /home/zhang/kvm/test/qemu-7.0.0/memory_ldst.c.inc:357
+ * #6  0x0000555555a3810a in msi_send_message (dev=0x55555767d800, msg=...) at ../hw/pci/msi.c:340
+ * #7  0x0000555555a39990 in msix_notify (dev=0x55555767d800, vector=0) at ../hw/pci/msix.c:503
+ * #8  0x00005555559ed349 in e1000e_msix_notify_one (core=0x555557680670, cause=1048576, int_cfg=2148141320) at ../hw/net/e1000e_core.c:2000
+ * #9  0x00005555559ed473 in e1000e_msix_notify (core=0x555557680670, causes=1048576) at ../hw/net/e1000e_core.c:2030
+ * #10 0x00005555559ed778 in e1000e_send_msi (core=0x555557680670, msix=true) at ../hw/net/e1000e_core.c:2124
+ * #11 0x00005555559ed8df in e1000e_update_interrupt_state (core=0x555557680670) at ../hw/net/e1000e_core.c:2169
+ * #12 0x00005555559ed988 in e1000e_set_interrupt_cause (core=0x555557680670, val=1048576) at ../hw/net/e1000e_core.c:2192
+ * #13 0x00005555559ee184 in e1000e_set_ics (core=0x555557680670, index=50, val=1048576) at ../hw/net/e1000e_core.c:2450
+ * #14 0x00005555559eedc5 in e1000e_core_write (core=0x555557680670, addr=200, val=1048576, size=4) at ../hw/net/e1000e_core.c:3259
+ * #15 0x00005555559dfe92 in e1000e_mmio_write (opaque=0x55555767d800, addr=200, val=1048576, size=4) at ../hw/net/e1000e.c:111
+ * #16 0x0000555555bd8f42 in memory_region_write_accessor (mr=0x555557680220, addr=200, value=0x7ffe6e3fe6e8, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:492
+ * #17 0x0000555555bd9186 in access_with_adjusted_size (addr=200, value=0x7ffe6e3fe6e8, size=4, access_size_min=4, access_size_max=4, access_fn=
+ *     0x555555bd8e4c <memory_region_write_accessor>, mr=0x555557680220, attrs=...) at ../softmmu/memory.c:554
+ * #18 0x0000555555bdc27c in memory_region_dispatch_write (mr=0x555557680220, addr=200, data=1048576, op=MO_32, attrs=...) at ../softmmu/memory.c:1514
+ * #19 0x0000555555be974a in flatview_write_continue (fv=0x7ffe68000980, addr=4273471688, attrs=..., ptr=0x7ffff7ff2028, len=4, addr1=200, l=4, mr=0x555557680220) at ../softmmu/physmem.c:2814
+ * #20 0x0000555555be98ad in flatview_write (fv=0x7ffe68000980, addr=4273471688, attrs=..., buf=0x7ffff7ff2028, len=4) at ../softmmu/physmem.c:2856
+ * #21 0x0000555555be9c5d in address_space_write (as=0x55555677b440 <address_space_memory>, addr=4273471688, attrs=..., buf=0x7ffff7ff2028, len=4) at ../softmmu/physmem.c:2952
+ * #22 0x0000555555be9cca in address_space_rw (as=0x55555677b440 <address_space_memory>, addr=4273471688, attrs=..., buf=0x7ffff7ff2028, len=4, is_write=true) at ../softmmu/physmem.c:2962
+ * #23 0x0000555555d1175f in kvm_cpu_exec (cpu=0x555556a7eb60) at ../accel/kvm/kvm-all.c:2929
+ * #24 0x0000555555d1354e in kvm_vcpu_thread_fn (arg=0x555556a7eb60) at ../accel/kvm/kvm-accel-ops.c:49
+ * #25 0x0000555555efbfb0 in qemu_thread_start (args=0x555556a8eea0) at ../util/qemu-thread-posix.c:556
+ * #26 0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #27 0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ */
 static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,
                                     uint64_t value, unsigned size,
                                     MemTxAttrs attrs)
diff --git a/hw/isa/piix3.c b/hw/isa/piix3.c
index dab901c9a..8e88c5ae9 100644
--- a/hw/isa/piix3.c
+++ b/hw/isa/piix3.c
@@ -61,6 +61,31 @@ static void piix3_set_irq_level_internal(PIIX3State *piix3, int pirq, int level)
     piix3->pic_levels |= mask * !!level;
 }
 
+/*
+ * (gdb) bt
+ * #0  piix3_set_irq_level (piix3=0x555556f80b80, pirq=2, level=1) at ../hw/isa/piix3.c:68
+ * #1  0x00005555559bf2fa in piix3_set_irq (opaque=0x555556f80b80, pirq=2, level=1) at ../hw/isa/piix3.c:81
+ * #2  0x0000555555a3b42d in pci_bus_change_irq_level (bus=0x555556be4030, irq_num=2, change=1) at ../hw/pci/pci.c:268
+ * #3  0x0000555555a3b4a4 in pci_change_irq_level (pci_dev=0x55555752c200, irq_num=2, change=1) at ../hw/pci/pci.c:281
+ * #4  0x0000555555a3e944 in pci_irq_handler (opaque=0x55555752c200, irq_num=0, level=1) at ../hw/pci/pci.c:1551
+ * #5  0x0000555555a3e9dc in pci_set_irq (pci_dev=0x55555752c200, level=1) at ../hw/pci/pci.c:1565
+ * #6  0x00005555559d4845 in set_interrupt_cause (s=0x55555752c200, index=0, val=16) at ../hw/net/e1000.c:338
+ * #7  0x00005555559d48cd in set_ics (s=0x55555752c200, index=50, val=16) at ../hw/net/e1000.c:356
+ * #8  0x00005555559d6f18 in e1000_mmio_write (opaque=0x55555752c200, addr=200, val=16, size=4) at ../hw/net/e1000.c:1331
+ * #9  0x0000555555bd8f42 in memory_region_write_accessor (mr=0x55555752ec20, addr=200, value=0x7ffdee7fe6e8, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:492
+ * #10 0x0000555555bd9186 in access_with_adjusted_size (addr=200, value=0x7ffdee7fe6e8, size=4, access_size_min=4, access_size_max=4, access_fn=
+ *     0x555555bd8e4c <memory_region_write_accessor>, mr=0x55555752ec20, attrs=...) at ../softmmu/memory.c:554
+ * #11 0x0000555555bdc27c in memory_region_dispatch_write (mr=0x55555752ec20, addr=200, data=16, op=MO_32, attrs=...) at ../softmmu/memory.c:1514
+ * #12 0x0000555555be974a in flatview_write_continue (fv=0x7ffde4000ee0, addr=4273733832, attrs=..., ptr=0x7ffff7ff2028, len=4, addr1=200, l=4, mr=0x55555752ec20) at ../softmmu/physmem.c:2814
+ * #13 0x0000555555be98ad in flatview_write (fv=0x7ffde4000ee0, addr=4273733832, attrs=..., buf=0x7ffff7ff2028, len=4) at ../softmmu/physmem.c:2856
+ * #14 0x0000555555be9c5d in address_space_write (as=0x555556779440 <address_space_memory>, addr=4273733832, attrs=..., buf=0x7ffff7ff2028, len=4) at ../softmmu/physmem.c:2952
+ * #15 0x0000555555be9cca in address_space_rw (as=0x555556779440 <address_space_memory>, addr=4273733832, attrs=..., buf=0x7ffff7ff2028, len=4, is_write=true) at ../softmmu/physmem.c:2962
+ * #16 0x0000555555d1175f in kvm_cpu_exec (cpu=0x555556a5d260) at ../accel/kvm/kvm-all.c:2929
+ * #17 0x0000555555d1354e in kvm_vcpu_thread_fn (arg=0x555556a5d260) at ../accel/kvm/kvm-accel-ops.c:49
+ * #18 0x0000555555efbfb0 in qemu_thread_start (args=0x555556a6d5b0) at ../util/qemu-thread-posix.c:556
+ * #19 0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #20 0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ */
 static void piix3_set_irq_level(PIIX3State *piix3, int pirq, int level)
 {
     int pic_irq;
@@ -109,6 +134,27 @@ static void piix3_update_irq_levels(PIIX3State *piix3)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  piix3_write_config (dev=0x555556f80b80, address=16, val=4294967295, len=4) at ../hw/isa/piix3.c:115
+ * #1  0x0000555555a43a13 in pci_host_config_write_common (pci_dev=0x555556f80b80, addr=16, limit=256, val=4294967295, len=4) at ../hw/pci/pci_host.c:85
+ * #2  0x0000555555a43bb7 in pci_data_write (s=0x555556be4030, addr=2147485712, val=4294967295, len=4) at ../hw/pci/pci_host.c:124
+ * #3  0x0000555555a43cdd in pci_host_data_write (opaque=0x555556be2fc0, addr=0, val=4294967295, len=4) at ../hw/pci/pci_host.c:171
+ * #4  0x0000555555bd8f42 in memory_region_write_accessor (mr=0x555556be33f0, addr=0, value=0x7ffdee7fe6a8, size=4, shift=0, mask=4294967295, attrs=...) at ../softmmu/memory.c:492
+ * #5  0x0000555555bd9186 in access_with_adjusted_size (addr=0, value=0x7ffdee7fe6a8, size=4, access_size_min=1, access_size_max=4, access_fn=
+ *     0x555555bd8e4c <memory_region_write_accessor>, mr=0x555556be33f0, attrs=...) at ../softmmu/memory.c:554
+ * #6  0x0000555555bdc27c in memory_region_dispatch_write (mr=0x555556be33f0, addr=0, data=4294967295, op=MO_32, attrs=...) at ../softmmu/memory.c:1514
+ * #7  0x0000555555be974a in flatview_write_continue (fv=0x7ffde80433c0, addr=3324, attrs=..., ptr=0x7ffff7ff3000, len=4, addr1=0, l=4, mr=0x555556be33f0) at ../softmmu/physmem.c:2814
+ * #8  0x0000555555be98ad in flatview_write (fv=0x7ffde80433c0, addr=3324, attrs=..., buf=0x7ffff7ff3000, len=4) at ../softmmu/physmem.c:2856
+ * #9  0x0000555555be9c5d in address_space_write (as=0x5555567793e0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff3000, len=4) at ../softmmu/physmem.c:2952
+ * #10 0x0000555555be9cca in address_space_rw (as=0x5555567793e0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff3000, len=4, is_write=true) at ../softmmu/physmem.c:2962
+ * #11 0x0000555555d10f9b in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7ff3000, direction=1, size=4, count=1) at ../accel/kvm/kvm-all.c:2668
+ * #12 0x0000555555d11712 in kvm_cpu_exec (cpu=0x555556a5d260) at ../accel/kvm/kvm-all.c:2919
+ * #13 0x0000555555d1354e in kvm_vcpu_thread_fn (arg=0x555556a5d260) at ../accel/kvm/kvm-accel-ops.c:49
+ * #14 0x0000555555efbfb0 in qemu_thread_start (args=0x555556a6d5b0) at ../util/qemu-thread-posix.c:556
+ * #15 0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #16 0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ */
 static void piix3_write_config(PCIDevice *dev,
                                uint32_t address, uint32_t val, int len)
 {
diff --git a/hw/net/vhost_net.c b/hw/net/vhost_net.c
index 30379d2ca..aea053a26 100644
--- a/hw/net/vhost_net.c
+++ b/hw/net/vhost_net.c
@@ -316,6 +316,10 @@ static void vhost_net_stop_one(struct vhost_net *net,
     vhost_dev_disable_notifiers(&net->dev, dev);
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|295| <<virtio_net_vhost_status>> r = vhost_net_start(vdev, n->nic->ncs, queue_pairs, cvq);
+ */
 int vhost_net_start(VirtIODevice *dev, NetClientState *ncs,
                     int data_queue_pairs, int cvq)
 {
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index 1067e72b3..96086dd3c 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -287,6 +287,11 @@ static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)
         }
 
         n->vhost_started = 1;
+	/*
+	 * VirtIONet *n:
+	 * -> NICState *nic;
+	 *    -> NetClientState *ncs;
+	 */
         r = vhost_net_start(vdev, n->nic->ncs, queue_pairs, cvq);
         if (r < 0) {
             error_report("unable to start vhost net: %d: "
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index dae9119bf..e0c2b27c3 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -278,6 +278,10 @@ static void pci_change_irq_level(PCIDevice *pci_dev, int irq_num, int change)
             break;
         pci_dev = bus->parent_dev;
     }
+    /*
+     * e1000的map是pci_slot_get_pirq()
+     * e1000的set是piix3_set_irq()
+     */
     pci_bus_change_irq_level(bus, irq_num, change);
 }
 
diff --git a/hw/scsi/virtio-scsi-dataplane.c b/hw/scsi/virtio-scsi-dataplane.c
index 29575cbaf..8f850e0dc 100644
--- a/hw/scsi/virtio-scsi-dataplane.c
+++ b/hw/scsi/virtio-scsi-dataplane.c
@@ -81,6 +81,10 @@ static void virtio_scsi_dataplane_stop_bh(void *opaque)
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * 在以下使用virtio_scsi_dataplane_start():
+ *   - hw/scsi/virtio-scsi.c|1106| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ */
 int virtio_scsi_dataplane_start(VirtIODevice *vdev)
 {
     int i;
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index 9d637e043..efe5dd3eb 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -1887,6 +1887,14 @@ void qemu_put_virtqueue_element(VirtIODevice *vdev, QEMUFile *f,
 }
 
 /* virtio device */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1906| <<virtio_update_irq>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ *   - hw/virtio/virtio.c|2000| <<virtio_reset>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|2528| <<virtio_irq>> virtio_notify_vector(vq->vdev, vq->vector);
+ *   - hw/virtio/virtio.c|2550| <<virtio_notify_config>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|3051| <<virtio_load>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ */
 static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
@@ -2522,6 +2530,11 @@ void virtio_notify_irqfd(VirtIODevice *vdev, VirtQueue *vq)
     event_notifier_set(&vq->guest_notifier);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|2540| <<virtio_notify>> virtio_irq(vq);
+ *   - hw/virtio/virtio.c|3471| <<virtio_queue_guest_notifier_read>> virtio_irq(vq);
+ */
 static void virtio_irq(VirtQueue *vq)
 {
     virtio_set_isr(vq->vdev, 0x1);
diff --git a/include/hw/qdev-core.h b/include/hw/qdev-core.h
index 92c3d6520..87a4c8b95 100644
--- a/include/hw/qdev-core.h
+++ b/include/hw/qdev-core.h
@@ -213,6 +213,21 @@ struct DeviceListener {
 };
 
 #define TYPE_BUS "bus"
+/*
+ * 215 #define DECLARE_OBJ_CHECKERS(InstanceType, ClassType, OBJ_NAME, TYPENAME) \
+ * 216     DECLARE_INSTANCE_CHECKER(InstanceType, OBJ_NAME, TYPENAME) \
+ * 217     \
+ * 218     DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME)
+ *
+ * 193 #define DECLARE_CLASS_CHECKERS(ClassType, OBJ_NAME, TYPENAME) \
+ * 194     static inline G_GNUC_UNUSED ClassType * \
+ * 195     OBJ_NAME##_GET_CLASS(const void *obj) \
+ * 196     { return OBJECT_GET_CLASS(ClassType, obj, TYPENAME); } \
+ * 197     \
+ * 198     static inline G_GNUC_UNUSED ClassType * \
+ * 199     OBJ_NAME##_CLASS(const void *klass) \
+ * 200     { return OBJECT_CLASS_CHECK(ClassType, klass, TYPENAME); }
+ */
 DECLARE_OBJ_CHECKERS(BusState, BusClass,
                      BUS, TYPE_BUS)
 
diff --git a/qom/object.c b/qom/object.c
index d34608558..cf1b2dde4 100644
--- a/qom/object.c
+++ b/qom/object.c
@@ -389,6 +389,30 @@ static void object_post_init_with_type(Object *obj, TypeImpl *ti)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1646
+ * #1  0x0000555555d28d33 in object_apply_global_props (obj=0x555556a5f460, props=0x5555569b8f00, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:412
+ * #2  0x0000555555d20e5c in qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:790
+ * #3  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #4  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #5  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #7  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #9  0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #10 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #11 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #12 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #13 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #14 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #15 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #16 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #17 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #18 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #19 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #20 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 bool object_apply_global_props(Object *obj, const GPtrArray *props,
                                Error **errp)
 {
@@ -409,6 +433,10 @@ bool object_apply_global_props(Object *obj, const GPtrArray *props,
             continue;
         }
         p->used = true;
+	/*
+	 * Thread 1 "qemu-system-x86" hit Breakpoint 11, object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1646
+	 *    Visitor *v = string_input_visitor_new(string);
+	 */
         if (!object_property_parse(obj, p->property, p->value, &err)) {
             error_prepend(&err, "can't apply global %s.%s=%s: ",
                           p->driver, p->property, p->value);
@@ -1391,6 +1419,31 @@ bool object_property_get(Object *obj, const char *name, Visitor *v,
     return !err;
 }
 
+/*
+ * (gdb) bt
+ * #0  object_property_set (obj=0x555556a5f460, name=0x55555680db00 "x2apic", v=0x555556a6e980, errp=0x7fffffffd878) at ../qom/object.c:1400
+ * #1  0x0000555555d2b91e in object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1647
+ * #2  0x0000555555d28d33 in object_apply_global_props (obj=0x555556a5f460, props=0x5555569b8f00, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:412
+ * #3  0x0000555555d20e5c in qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:790
+ * #4  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #5  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #7  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #9  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #10 0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #11 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #12 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #13 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #14 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #15 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #16 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #17 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #18 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #19 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #20 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #21 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 bool object_property_set(Object *obj, const char *name, Visitor *v,
                          Error **errp)
 {
@@ -1405,6 +1458,12 @@ bool object_property_set(Object *obj, const char *name, Visitor *v,
         error_setg(errp, QERR_PERMISSION_DENIED);
         return false;
     }
+    /*
+     * (gdb) p *prop
+     * $8 = {name = 0x555556817690 "x2apic", type = 0x5555568176b0 "bool", description = 0x0,
+     * get = 0x555555b6d930 <x86_cpu_get_bit_prop>, set = 0x555555b6d9de <x86_cpu_set_bit_prop>,
+     * resolve = 0x0, release = 0x0, init = 0x0, opaque = 0x555556817610, defval = 0x0}
+     */
     prop->set(obj, v, name, prop->opaque, errp);
     return !*errp;
 }
@@ -1640,6 +1699,39 @@ int object_property_get_enum(Object *obj, const char *name,
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1646
+ * #1  0x0000555555d28d33 in object_apply_global_props (obj=0x555556a5f460, props=0x5555569b8f00, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:412
+ * #2  0x0000555555d20e5c in qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:790
+ * #3  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #4  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #5  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #7  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #9  0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #10 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #11 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #12 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #13 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #14 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #15 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #16 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #17 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #18 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #19 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #20 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * called by:
+ *   - hw/i386/sgx.c|308| <<pc_machine_init_sgx_epc>> object_property_parse(obj, SGX_EPC_MEMDEV_PROP, list->value->memdev,
+ *   - qom/object.c|412| <<object_apply_global_props>> if (!object_property_parse(obj, p->property, p->value, &err)) {
+ *   - qom/object.c|845| <<object_set_propv>> if (!object_property_parse(obj, propname, value, errp)) {
+ *   - qom/qom-hmp-cmds.c|59| <<hmp_qom_set>> object_property_parse(obj, property, value, &err);
+ *   - softmmu/vl.c|1694| <<object_parse_property_opt>> if (!object_property_parse(obj, name, value, errp)) {
+ *   - target/i386/cpu.c|5085| <<x86_cpu_apply_props>> object_property_parse(OBJECT(cpu), pv->prop, pv->value,
+ *   - target/i386/cpu.c|5112| <<x86_cpu_apply_version_props>> object_property_parse(OBJECT(cpu), p->prop, p->value,
+ */
 bool object_property_parse(Object *obj, const char *name,
                            const char *string, Error **errp)
 {
diff --git a/softmmu/cpus.c b/softmmu/cpus.c
index 7b75bb66d..ac471f9fc 100644
--- a/softmmu/cpus.c
+++ b/softmmu/cpus.c
@@ -618,6 +618,30 @@ void cpus_register_accel(const AccelOpsClass *ops)
     cpus_accel = ops;
 }
 
+/*
+ * called by:
+ *   - accel/tcg/user-exec-stub.c|15| <<qemu_init_vcpu>> void qemu_init_vcpu(CPUState *cpu)
+ *   - target/alpha/cpu.c|69| <<alpha_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/arm/cpu.c|1975| <<arm_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/avr/cpu.c|101| <<avr_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/cris/cpu.c|138| <<cris_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/hexagon/cpu.c|303| <<hexagon_cpu_realize>> qemu_init_vcpu(cs);
+ *   - target/hppa/cpu.c|107| <<hppa_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/i386/cpu.c|6670| <<x86_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/m68k/cpu.c|301| <<m68k_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/microblaze/cpu.c|202| <<mb_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/mips/cpu.c|484| <<mips_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/nios2/cpu.c|121| <<nios2_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/openrisc/cpu.c|108| <<openrisc_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/ppc/cpu_init.c|6839| <<ppc_cpu_realize>> qemu_init_vcpu(cs);
+ *   - target/riscv/cpu.c|686| <<riscv_cpu_realize>> qemu_init_vcpu(cs);
+ *   - target/rx/cpu.c|121| <<rx_cpu_realize>> qemu_init_vcpu(cs);
+ *   - target/s390x/cpu.c|214| <<s390_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/sh4/cpu.c|206| <<superh_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/sparc/cpu.c|774| <<sparc_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/tricore/cpu.c|96| <<tricore_cpu_realizefn>> qemu_init_vcpu(cs);
+ *   - target/xtensa/cpu.c|155| <<xtensa_cpu_realizefn>> qemu_init_vcpu(cs);
+ */
 void qemu_init_vcpu(CPUState *cpu)
 {
     MachineState *ms = MACHINE(qdev_get_machine());
@@ -637,6 +661,9 @@ void qemu_init_vcpu(CPUState *cpu)
 
     /* accelerators all implement the AccelOpsClass */
     g_assert(cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL);
+    /*
+     * kvm_start_vcpu_thread()
+     */
     cpus_accel->create_vcpu_thread(cpu);
 
     while (!cpu->created) {
diff --git a/softmmu/memory.c b/softmmu/memory.c
index bfa5d5178..8a965bc4a 100644
--- a/softmmu/memory.c
+++ b/softmmu/memory.c
@@ -1158,6 +1158,11 @@ static char *memory_region_escape_name(const char *name)
     return escaped;
 }
 
+/*
+ * called by:
+ *   - softmmu/memory.c|1195| <<memory_region_init>> memory_region_do_init(mr, owner, name, size);
+ *   - softmmu/memory.c|1746| <<memory_region_init_iommu>> memory_region_do_init(mr, owner, name, size);
+ */
 static void memory_region_do_init(MemoryRegion *mr,
                                   Object *owner,
                                   const char *name,
@@ -1548,6 +1553,13 @@ void memory_region_init_ram_nomigrate(MemoryRegion *mr,
     memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
 }
 
+/*
+ * called by:
+ *   - backends/hostmem-ram.c|33| <<ram_backend_memory_alloc>> memory_region_init_ram_flags_nomigrate(&backend->mr, OBJECT(backend), name,
+ *   - hw/m68k/next-cube.c|987| <<next_cube_init>> memory_region_init_ram_flags_nomigrate(bmapm1, NULL, "next.bmapmem", 64,
+ *   - softmmu/memory.c|1548| <<memory_region_init_ram_nomigrate>> memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
+ *   - softmmu/memory.c|1699| <<memory_region_init_rom_nomigrate>> memory_region_init_ram_flags_nomigrate(mr, owner, name, size, 0, errp);
+ */
 void memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
                                             Object *owner,
                                             const char *name,
diff --git a/softmmu/physmem.c b/softmmu/physmem.c
index 4e1b27a20..c2663a0c9 100644
--- a/softmmu/physmem.c
+++ b/softmmu/physmem.c
@@ -1960,6 +1960,11 @@ static void dirty_memory_extend(ram_addr_t old_ram_size,
     }
 }
 
+/*
+ * called by:
+ *   - softmmu/physmem.c|2104| <<qemu_ram_alloc_from_fd>> ram_block_add(new_block, &local_err);
+ *   - softmmu/physmem.c|2169| <<qemu_ram_alloc_internal>> ram_block_add(new_block, &local_err);
+ */
 static void ram_block_add(RAMBlock *new_block, Error **errp)
 {
     const bool noreserve = qemu_ram_is_noreserve(new_block);
@@ -2139,6 +2144,12 @@ RAMBlock *qemu_ram_alloc_from_file(ram_addr_t size, MemoryRegion *mr,
 }
 #endif
 
+/*
+ * called by:
+ *   - softmmu/physmem.c|2181| <<qemu_ram_alloc_from_ptr>> return qemu_ram_alloc_internal(size, size, NULL, host, RAM_PREALLOC, mr,
+ *   - softmmu/physmem.c|2189| <<qemu_ram_alloc>> return qemu_ram_alloc_internal(size, size, NULL, NULL, ram_flags, mr, errp);
+ *   - softmmu/physmem.c|2198| <<qemu_ram_alloc_resizeable>> return qemu_ram_alloc_internal(size, maxsz, resized, NULL,
+ */
 static
 RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                   void (*resized)(const char*,
@@ -2175,6 +2186,11 @@ RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
     return new_block;
 }
 
+/*
+ * called by:
+ *   - softmmu/memory.c|1563| <<memory_region_init_ram_flags_nomigrate>> mr->ram_block = qemu_ram_alloc(size, ram_flags, mr, &err);
+ *   - softmmu/memory.c|1719| <<memory_region_init_rom_device_nomigrate>> mr->ram_block = qemu_ram_alloc(size, 0, mr, &err);
+ */
 RAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
                                    MemoryRegion *mr, Error **errp)
 {
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index cb6b5467d..1a023388c 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -673,6 +673,22 @@ void x86_cpu_vendor_words2str(char *dst, uint32_t vendor1,
 #define TCG_SGX_12_0_EBX_FEATURES 0
 #define TCG_SGX_12_1_EAX_FEATURES 0
 
+/*
+ * 在以下使用feature_word_info[FEATURE_WORDS]:
+ *   - target/i386/cpu-sysemu.c|68| <<x86_cpu_static_props>> FeatureWordInfo *fi = &feature_word_info[w];
+ *   - target/i386/cpu.c|1467| <<x86_cpu_get_migratable_flags>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|4350| <<mark_unavailable_features>> FeatureWordInfo *f = &feature_word_info[w];
+ *   - target/i386/cpu.c|4600| <<x86_cpu_get_feature_words>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|4653| <<x86_cpu_feature_name>> name = feature_word_info[w].feat_names[bitnr];
+ *   - target/i386/cpu.c|4654| <<x86_cpu_feature_name>> assert(bitnr < 32 || !(name && feature_word_info[w].type == CPUID_FEATURE_WORD));
+ *   - target/i386/cpu.c|4931| <<x86_cpu_list>> for (i = 0; i < ARRAY_SIZE(feature_word_info); i++) {
+ *   - target/i386/cpu.c|4932| <<x86_cpu_list>> FeatureWordInfo *fw = &feature_word_info[i];
+ *   - target/i386/cpu.c|4992| <<x86_cpu_get_supported_feature_word>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|6051| <<x86_cpu_adjust_feat_level>> FeatureWordInfo *fi = &feature_word_info[w];
+ *   - target/i386/cpu.c|6055| <<x86_cpu_adjust_feat_level>> assert(feature_word_info[w].type == CPUID_FEATURE_WORD);
+ *   - target/i386/cpu.c|6184| <<x86_cpu_expand_features>> ~feature_word_info[w].no_autoenable_flags;
+ *   - target/i386/cpu.c|6671| <<x86_cpu_register_feature_bit_props>> FeatureWordInfo *fi = &feature_word_info[w];
+ */
 FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
     [FEAT_1_EDX] = {
         .type = CPUID_FEATURE_WORD,
@@ -1780,6 +1796,11 @@ static const CPUCaches epyc_milan_cache_info = {
  *  PT in VMX operation
  */
 
+/*
+ * 在以下使用builtin_x86_defs[]:
+ *   - target/i386/cpu.c|7134| <<x86_cpu_register_types>> for (i = 0; i < ARRAY_SIZE(builtin_x86_defs); i++) {
+ *   - target/i386/cpu.c|7135| <<x86_cpu_register_types>> x86_register_cpudef_types(&builtin_x86_defs[i]);
+ */
 static const X86CPUDefinition builtin_x86_defs[] = {
     {
         .name = "qemu64",
@@ -4338,6 +4359,13 @@ static bool x86_cpu_have_filtered_features(X86CPU *cpu)
     return false;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|6304| <<x86_cpu_expand_features>> mark_unavailable_features(cpu, d->to.index,
+ *   - target/i386/cpu.c|6339| <<x86_cpu_expand_features>> mark_unavailable_features(cpu, FEAT_7_0_EBX,
+ *   - target/i386/cpu.c|6420| <<x86_cpu_filter_features>> mark_unavailable_features(cpu, w, unavailable_features, prefix);
+ *   - target/i386/cpu.c|6447| <<x86_cpu_filter_features>> mark_unavailable_features(cpu, FEAT_7_0_EBX, CPUID_7_0_EBX_INTEL_PT, prefix);
+ */
 static void mark_unavailable_features(X86CPU *cpu, FeatureWord w, uint64_t mask,
                                       const char *verbose_prefix)
 {
@@ -4345,6 +4373,10 @@ static void mark_unavailable_features(X86CPU *cpu, FeatureWord w, uint64_t mask,
     FeatureWordInfo *f = &feature_word_info[w];
     int i;
 
+    /*
+     * 在下面设置force_features:
+     *   - target/i386/cpu.c|7099| <<global>> DEFINE_PROP_BOOL("x-force-features", X86CPU, force_features, false),
+     */
     if (!cpu->force_features) {
         env->features[w] &= ~mask;
     }
@@ -4655,6 +4687,16 @@ static const char *x86_cpu_feature_name(FeatureWord w, int bitnr)
  * feat=on|feat even if the later is parsed after +-feat
  * (i.e. "-x2apic,x2apic=on" will result in x2apic disabled)
  */
+/*
+ * 在以下使用minus_features:
+ *   - target/i386/cpu.c|4719| <<x86_cpu_parse_featurestr>> minus_features = g_list_append(minus_features,
+ *   - target/i386/cpu.c|4741| <<x86_cpu_parse_featurestr>> if (g_list_find_custom(minus_features, name, compare_string)) {
+ *   - target/i386/cpu.c|6192| <<x86_cpu_expand_features>> for (l = minus_features; l; l = l->next) {
+ *   - target/sparc/cpu.c|124| <<sparc_cpu_parse_features>> GList *l, *plus_features = NULL, *minus_features = NULL;
+ *   - target/sparc/cpu.c|150| <<sparc_cpu_parse_features>> minus_features = g_list_append(minus_features,
+ *   - target/sparc/cpu.c|192| <<sparc_cpu_parse_features>> for (l = minus_features; l; l = l->next) {
+ *   - target/sparc/cpu.c|196| <<sparc_cpu_parse_features>> g_list_free_full(minus_features, g_free);
+ */
 static GList *plus_features, *minus_features;
 
 static gint compare_string(gconstpointer a, gconstpointer b)
@@ -4664,6 +4706,16 @@ static gint compare_string(gconstpointer a, gconstpointer b)
 
 /* Parse "+feature,-feature,feature=foo" CPU feature string
  */
+/*
+ * (gdb) bt
+ * #0  x86_cpu_parse_featurestr (typename=0x5555567f4ae0 "host-x86_64-cpu", features=0x55555680e620 "-x2apic", errp=0x55555679a800 <error_fatal>) at ../target/i386/cpu.c:4669
+ * #1  0x0000555555bf2f64 in parse_cpu_option (cpu_option=0x7fffffffe290 "host,-x2apic") at ../cpu.c:265
+ * #2  0x0000555555899305 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3761
+ * #3  0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * 在以下使用x86_cpu_parse_featurestr():
+ *   - target/i386/cpu.c|7071| <<x86_cpu_common_class_init>> cc->parse_features = x86_cpu_parse_featurestr;
+ */
 static void x86_cpu_parse_featurestr(const char *typename, char *features,
                                      Error **errp)
 {
@@ -4739,6 +4791,10 @@ static void x86_cpu_parse_featurestr(const char *typename, char *features,
             name = "tsc-frequency";
         }
 
+	/*
+	 * (gdb) p *prop
+	 * $2 = {driver = 0x5555567f4ae0 "host-x86_64-cpu", property = 0x55555680d990 "x2apic", value = 0x55555680d9b0 "off", used = false, optional = false}
+	 */
         prop = g_new0(typeof(*prop), 1);
         prop->driver = typename;
         prop->property = g_strdup(name);
@@ -4755,6 +4811,11 @@ static void x86_cpu_parse_featurestr(const char *typename, char *features,
 static void x86_cpu_filter_features(X86CPU *cpu, bool verbose);
 
 /* Build a list with the name of all features on a feature word array */
+/*
+ * called by:
+ *   - target/i386/cpu.c|4803| <<x86_cpu_get_unavailable_features>> x86_cpu_list_feature_names(xc->filtered_features, &result);
+ *   - target/i386/cpu.c|4836| <<x86_cpu_class_check_missing_features>> x86_cpu_list_feature_names(xc->filtered_features, tail);
+ */
 static void x86_cpu_list_feature_names(FeatureWordArray features,
                                        strList **list)
 {
@@ -4911,6 +4972,10 @@ static void x86_cpu_list_entry(gpointer data, gpointer user_data)
 }
 
 /* list available CPU models and flags */
+/*
+ * 在以下使用x86_cpu_list:
+ *   - target/i386/cpu.h|2095| <<cpu_list>> #define cpu_list x86_cpu_list
+ */
 void x86_cpu_list(void)
 {
     int i, j;
@@ -4981,6 +5046,12 @@ CpuDefinitionInfoList *qmp_query_cpu_definitions(Error **errp)
     return cpu_list;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|6286| <<x86_cpu_expand_features>> x86_cpu_get_supported_feature_word(w, cpu->migratable) &
+ *   - target/i386/cpu.c|6406| <<x86_cpu_filter_features>> x86_cpu_get_supported_feature_word(w, false);
+ *   - target/i386/kvm/kvm-cpu.c|105| <<kvm_cpu_xsave_init>> if ((x86_cpu_get_supported_feature_word(esa->feature, false) & esa->bits)
+ */
 uint64_t x86_cpu_get_supported_feature_word(FeatureWord w,
                                             bool migratable_only)
 {
@@ -5042,6 +5113,10 @@ void x86_cpu_apply_props(X86CPU *cpu, PropValue *props)
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|5128| <<x86_cpu_load_model>> x86_cpu_apply_version_props(cpu, model);
+ */
 static void x86_cpu_apply_version_props(X86CPU *cpu, X86CPUModel *model)
 {
     const X86CPUVersionDefinition *vdef;
@@ -5074,6 +5149,10 @@ static void x86_cpu_apply_version_props(X86CPU *cpu, X86CPUModel *model)
  * Load data from X86CPUDefinition into a X86CPU object.
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
+/*
+ * called by:
+ *   - target/i386/cpu.c|6745| <<x86_cpu_initfn>> x86_cpu_load_model(cpu, xcc->model);
+ */
 static void x86_cpu_load_model(X86CPU *cpu, X86CPUModel *model)
 {
     const X86CPUDefinition *def = model->cpudef;
@@ -5169,6 +5248,10 @@ static void x86_register_cpu_model_type(const char *name, X86CPUModel *model)
  * "max", "base" and subclasses ("host") are not registered here.
  * See x86_cpu_register_types for all model registrations.
  */
+/*
+ * called by:
+ *   - target/i386/cpu.c|7140| <<x86_cpu_register_types>> x86_register_cpudef_types(&builtin_x86_defs[i]);
+ */
 static void x86_register_cpudef_types(const X86CPUDefinition *def)
 {
     X86CPUModel *m;
@@ -5219,6 +5302,29 @@ uint32_t cpu_x86_virtual_addr_width(CPUX86State *env)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/fw_cfg.c|166| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 1, 0, &unused, &unused, &ecx, &edx);
+ *   - hw/i386/fw_cfg.c|178| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 0x7, 0, &unused, &ebx, &ecx, &unused);
+ *   - target/i386/hvf/hvf.c|377| <<hvf_cpu_x86_cpuid>> cpu_x86_cpuid(env, index, count, eax, ebx, ecx, edx);
+ *   - target/i386/kvm/kvm.c|1716| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, 0, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|1743| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1755| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1779| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1807| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1829| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1842| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1849| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1864| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, 0x0a, 0, &eax, &unused, &unused, &edx);
+ *   - target/i386/kvm/kvm.c|1888| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, 0x80000000, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|1904| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1920| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|1934| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, 0xC0000000, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|1945| <<kvm_arch_init_vcpu>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/tcg/fpu_helper.c|2932| <<helper_xsetbv>> cpu_x86_cpuid(env, 0x0d, 0, &ena_lo, &dummy, &dummy, &ena_hi);
+ *   - target/i386/tcg/misc_helper.c|56| <<helper_cpuid>> cpu_x86_cpuid(env, (uint32_t)env->regs[R_EAX], (uint32_t)env->regs[R_ECX],
+ *   - target/i386/whpx/whpx-all.c|1217| <<whpx_vcpu_run>> cpu_x86_cpuid(env, cpuid_fn, 0, (UINT32 *)&rax, (UINT32 *)&rbx,
+ */
 void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,
                    uint32_t *eax, uint32_t *ebx,
                    uint32_t *ecx, uint32_t *edx)
@@ -6139,9 +6245,35 @@ static void x86_cpu_enable_xsave_components(X86CPU *cpu)
  *   any CPUID data based on host capabilities.
  */
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_expand_features (cpu=0x555556a5f460, errp=0x7fffffffd790) at ../target/i386/cpu.c:6147
+ * #1  0x0000555555b6d14e in x86_cpu_realizefn (dev=0x555556a5f460, errp=0x7fffffffd810) at ../target/i386/cpu.c:6381
+ * #2  0x0000555555d2325a in device_set_realized (obj=0x555556a5f460, value=true, errp=0x7fffffffd920) at ../hw/core/qdev.c:531
+ * #3  0x0000555555d2cd6c in property_set_bool (obj=0x555556a5f460, v=0x555556a6e980, name=0x5555560c1221 "realized", opaque=0x555556812500, errp=0x7fffffffd920) at ../qom/object.c:2273
+ * #4  0x0000555555d2adb3 in object_property_set (obj=0x555556a5f460, name=0x5555560c1221 "realized", v=0x555556a6e980, errp=0x7fffffffd920) at ../qom/object.c:1408
+ * #5  0x0000555555d2f15e in object_property_set_qobject (obj=0x555556a5f460, name=0x5555560c1221 "realized", value=0x555556a6be10, errp=0x55555679a800 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #6  0x0000555555d2b118 in object_property_set_bool (obj=0x555556a5f460, name=0x5555560c1221 "realized", value=true, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:1477
+ * #7  0x0000555555d22b22 in qdev_realize (dev=0x555556a5f460, bus=0x0, errp=0x55555679a800 <error_fatal>) at ../hw/core/qdev.c:333
+ * #8  0x0000555555b2e017 in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:101
+ * #9  0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #10 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #11 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #12 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #13 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #14 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #15 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #16 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 /* Expand CPU configuration data, based on configured features
  * and host/accelerator capabilities when appropriate.
  */
+/*
+ * called by:
+ *   - target/i386/cpu-sysemu.c|165| <<x86_cpu_from_model>> x86_cpu_expand_features(xc, &err);
+ *   - target/i386/cpu.c|4853| <<x86_cpu_class_check_missing_features>> x86_cpu_expand_features(xc, &err);
+ *   - target/i386/cpu.c|6501| <<x86_cpu_realizefn>> x86_cpu_expand_features(cpu, &local_err);
+ */
 void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
 {
     CPUX86State *env = &cpu->env;
@@ -6280,6 +6412,11 @@ void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
  *
  * Returns: 0 if all flags are supported by the host, non-zero otherwise.
  */
+/*
+ * called by:
+ *   - target/i386/cpu.c|4863| <<x86_cpu_class_check_missing_features>> x86_cpu_filter_features(xc, false);
+ *   - target/i386/cpu.c|6495| <<x86_cpu_realizefn>> x86_cpu_filter_features(cpu, cpu->check_cpuid || cpu->enforce_cpuid);
+ */
 static void x86_cpu_filter_features(X86CPU *cpu, bool verbose)
 {
     CPUX86State *env = &cpu->env;
@@ -6620,6 +6757,13 @@ static void x86_cpu_set_bit_prop(Object *obj, Visitor *v, const char *name,
     }
 
     if (value) {
+        /*
+	 * X86CPU *cpu (等价struct ArchCPU):
+	 * -> CPUX86State env;
+	 *    -> FeatureWordArray features;
+	 *    // Features that were explicitly enabled/disabled
+         *    -> FeatureWordArray user_features;
+	 */
         cpu->env.features[fp->w] |= fp->mask;
     } else {
         cpu->env.features[fp->w] &= ~fp->mask;
@@ -6633,6 +6777,25 @@ static void x86_cpu_set_bit_prop(Object *obj, Visitor *v, const char *name,
  * multiple bits in the same FeatureWord. In that case, the getter will return
  * true only if all bits are set.
  */
+/*
+ * (gdb) bt
+ * #0  x86_cpu_register_bit_prop (xcc=0x555556812140, prop_name=0x55555607a689 "x2apic", w=FEAT_1_ECX, bitnr=21) at ../target/i386/cpu.c:6641
+ * #1  0x0000555555b6dd1e in x86_cpu_register_feature_bit_props (xcc=0x555556812140, w=FEAT_1_ECX, bitnr=21) at ../target/i386/cpu.c:6681
+ * #2  0x0000555555b6e9ec in x86_cpu_common_class_init (oc=0x555556812140, data=0x0) at ../target/i386/cpu.c:7095
+ * #3  0x0000555555d28b97 in type_initialize (ti=0x5555567e1470) at ../qom/object.c:366
+ * #4  0x0000555555d28902 in type_initialize (ti=0x5555567ea7e0) at ../qom/object.c:314
+ * #5  0x0000555555d2a0fa in object_class_foreach_tramp (key=0x5555567ea960, value=0x5555567ea7e0, opaque=0x7fffffffdb90) at ../qom/object.c:1071
+ * #6  0x00007ffff6e46710 in g_hash_table_foreach () at /lib64/libglib-2.0.so.0
+ * #7  0x0000555555d2a1d9 in object_class_foreach (fn=0x555555d2a336 <object_class_get_list_tramp>, implements_type=0x555555faee84 "machine", include_abstract=false, opaque=0x7fffffffdbe0) at ../qom/object.c:1093
+ * #8  0x0000555555d2a3b1 in object_class_get_list (implements_type=0x555555faee84 "machine", include_abstract=false) at ../qom/object.c:1150
+ * #9  0x0000555555894512 in select_machine (qdict=0x55555680c600, errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:1661
+ * #10 0x00005555558956a4 in qemu_create_machine (qdict=0x55555680c600) at ../softmmu/vl.c:2146
+ * #11 0x00005555558991e5 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3708
+ * #12 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * called by:
+ *   - target/i386/cpu.c|6763| <<x86_cpu_register_feature_bit_props>> x86_cpu_register_bit_prop(xcc, name, w, bitnr);
+ */
 static void x86_cpu_register_bit_prop(X86CPUClass *xcc,
                                       const char *prop_name,
                                       FeatureWord w,
@@ -6686,6 +6849,9 @@ static void x86_cpu_post_initfn(Object *obj)
     accel_cpu_instance_init(CPU(obj));
 }
 
+/*
+ * const TypeInfo x86_cpu_type_info.instance_init = x86_cpu_initfn()
+ */
 static void x86_cpu_initfn(Object *obj)
 {
     X86CPU *cpu = X86_CPU(obj);
@@ -6873,6 +7039,10 @@ void x86_update_hflags(CPUX86State *env)
     env->hflags = hflags;
 }
 
+/*
+ * 在以下使用x86_cpu_properties[]:
+ *   - target/i386/cpu.c|7114| <<x86_cpu_common_class_init>> device_class_set_props(dc, x86_cpu_properties);
+ */
 static Property x86_cpu_properties[] = {
 #ifdef CONFIG_USER_ONLY
     /* apic_id = 0 by default for *-user, see commit 9886e834 */
diff --git a/target/i386/host-cpu.c b/target/i386/host-cpu.c
index 10f8aba86..8f2b9c32d 100644
--- a/target/i386/host-cpu.c
+++ b/target/i386/host-cpu.c
@@ -50,6 +50,10 @@ static void host_cpu_enable_cpu_pm(X86CPU *cpu)
     env->features[FEAT_1_ECX] |= CPUID_EXT_MONITOR;
 }
 
+/*
+ * called by:
+ *   - target/i386/host-cpu.c|92| <<host_cpu_realizefn>> uint32_t phys_bits = host_cpu_adjust_phys_bits(cpu);
+ */
 static uint32_t host_cpu_adjust_phys_bits(X86CPU *cpu)
 {
     uint32_t host_phys_bits = host_cpu_phys_bits();
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 9cf8e0366..b5b0b6ffc 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -191,6 +191,11 @@ bool kvm_has_x2apic_api(void)
     return has_x2apic_api;
 }
 
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|3785| <<vtd_decide_config>> if (!kvm_enable_x2apic()) {
+ *   - target/i386/kvm/kvm-cpu.c|174| <<kvm_cpu_instance_init>> } else if (kvm_irqchip_is_split() && kvm_enable_x2apic()) {
+ */
 bool kvm_enable_x2apic(void)
 {
     return MEMORIZE(
@@ -249,8 +254,40 @@ void kvm_synchronize_all_tsc(void)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  try_get_cpuid (s=0x55555680c600, max=64) at ../target/i386/kvm/kvm.c:257
+ * #1  0x0000555555b144dc in get_supported_cpuid (s=0x55555680c600) at ../target/i386/kvm/kvm.c:288
+ * #2  0x0000555555b146d2 in kvm_arch_get_supported_cpuid (s=0x55555680c600, function=0, index=0, reg=0) at ../target/i386/kvm/kvm.c:356
+ * #3  0x0000555555b219d1 in kvm_cpu_max_instance_init (cpu=0x555556a5f390) at ../target/i386/kvm/kvm-cpu.c:77
+ * #4  0x0000555555b21cb6 in kvm_cpu_instance_init (cs=0x555556a5f390) at ../target/i386/kvm/kvm-cpu.c:183
+ * #5  0x0000555555ce9da1 in accel_cpu_instance_init (cpu=0x555556a5f390) at ../accel/accel-common.c:110
+ * #6  0x0000555555b6dd3b in x86_cpu_post_initfn (obj=0x555556a5f390) at ../target/i386/cpu.c:6686
+ * #7  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567e1470) at ../qom/object.c:384
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567f4600) at ../qom/object.c:388
+ * #9  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567f4960) at ../qom/object.c:388
+ * #10 0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f390, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #11 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #12 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #13 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #14 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #15 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #16 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #17 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #18 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #19 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #20 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #21 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 {
+    /*
+     * struct kvm_cpuid2 {
+     *     __u32 nent;
+     *     __u32 padding;
+     *     struct kvm_cpuid_entry2 entries[0];
+     * };
+     */
     struct kvm_cpuid2 *cpuid;
     int r, size;
 
@@ -277,6 +314,10 @@ static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 /* Run KVM_GET_SUPPORTED_CPUID ioctl(), allocating a buffer large enough
  * for all entries.
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|386| <<kvm_arch_get_supported_cpuid>> cpuid = get_supported_cpuid(s);
+ */
 static struct kvm_cpuid2 *get_supported_cpuid(KVMState *s)
 {
     struct kvm_cpuid2 *cpuid;
@@ -1617,6 +1658,15 @@ static void kvm_init_xsave(CPUX86State *env)
            env->xsave_buf_len);
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_arch_init_vcpu (cs=0x555556a5f460) at ../target/i386/kvm/kvm.c:1621
+ * #1  0x0000555555d0c631 in kvm_init_vcpu (cpu=0x555556a5f460, errp=0x55555679a800 <error_fatal>) at ../accel/kvm/kvm-all.c:516
+ * #2  0x0000555555d13504 in kvm_vcpu_thread_fn (arg=0x555556a5f460) at ../accel/kvm/kvm-accel-ops.c:40
+ * #3  0x0000555555efbfb0 in qemu_thread_start (args=0x555556a6f3a0) at ../util/qemu-thread-posix.c:556
+ * #4  0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #5  0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ */
 int kvm_arch_init_vcpu(CPUState *cs)
 {
     struct {
@@ -2033,6 +2083,12 @@ int kvm_arch_init_vcpu(CPUState *cs)
     cpuid_data.cpuid.nent = cpuid_i;
 
     cpuid_data.cpuid.padding = 0;
+    /*
+     * struct {
+     *     struct kvm_cpuid2 cpuid;
+     *     struct kvm_cpuid_entry2 entries[KVM_MAX_CPUID_ENTRIES];
+     * } cpuid_data;
+     */
     r = kvm_vcpu_ioctl(cs, KVM_SET_CPUID2, &cpuid_data);
     if (r) {
         goto fail;
@@ -4328,6 +4384,12 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2763| <<do_kvm_cpu_synchronize_post_reset>> kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE);
+ *   - accel/kvm/kvm-all.c|2774| <<do_kvm_cpu_synchronize_post_init>> kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);
+ *   - accel/kvm/kvm-all.c|2867| <<kvm_cpu_exec>> kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);
+ */
 int kvm_arch_put_registers(CPUState *cpu, int level)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
-- 
2.17.1

