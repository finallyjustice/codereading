From a9b428693b97fb9237f4de36740bc3d4e62b4ac8 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Sun, 10 Jul 2022 21:02:52 -0700
Subject: [PATCH 1/1] qemu for v7.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/accel-softmmu.c           | 13 ++++++++++++
 accel/dummy-cpus.c              |  4 ++++
 accel/kvm/kvm-accel-ops.c       |  8 ++++++++
 accel/kvm/kvm-all.c             | 16 +++++++++++++++
 block/file-posix.c              |  8 ++++++++
 hw/net/vhost_net.c              |  4 ++++
 hw/net/virtio-net.c             |  5 +++++
 hw/scsi/virtio-scsi-dataplane.c |  4 ++++
 hw/virtio/virtio.c              | 13 ++++++++++++
 target/i386/cpu.c               | 36 +++++++++++++++++++++++++++++++++
 target/i386/host-cpu.c          |  4 ++++
 target/i386/kvm/kvm.c           |  6 ++++++
 12 files changed, 121 insertions(+)

diff --git a/accel/accel-softmmu.c b/accel/accel-softmmu.c
index 67276e4f5..c081b6ea3 100644
--- a/accel/accel-softmmu.c
+++ b/accel/accel-softmmu.c
@@ -47,6 +47,19 @@ int accel_init_machine(AccelState *accel, MachineState *ms)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|249| <<kvm_get_max_memslots>> KVMState *s = KVM_STATE(current_accel());
+ *   - accel/kvm/kvm-all.c|2312| <<kvm_vcpu_id_is_valid>> KVMState *s = KVM_STATE(current_accel());
+ *   - accel/tcg/tcg-all.c|115| <<tcg_init_machine>> TCGState *s = TCG_STATE(current_accel());
+ *   - bsd-user/main.c|454| <<main>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - hw/ppc/pef.c|85| <<kvmppc_svm_off>> rc = kvm_vm_ioctl(KVM_STATE(current_accel()), KVM_PPC_SVM_OFF);
+ *   - linux-user/main.c|738| <<main>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - softmmu/memory.c|3338| <<mtree_info_flatview>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - softmmu/vl.c|2427| <<configure_accelerators>> AccelClass *ac = ACCEL_GET_CLASS(current_accel());
+ *   - target/i386/kvm/kvm.c|171| <<kvm_x2apic_api_set_flags>> KVMState *s = KVM_STATE(current_accel());
+ *   - target/ppc/kvm.c|268| <<kvm_get_radix_page_info>> KVMState *s = KVM_STATE(current_accel());
+ */
 AccelState *current_accel(void)
 {
     return current_machine->accelerator;
diff --git a/accel/dummy-cpus.c b/accel/dummy-cpus.c
index 10429fdfb..e2cdf195a 100644
--- a/accel/dummy-cpus.c
+++ b/accel/dummy-cpus.c
@@ -58,6 +58,10 @@ static void *dummy_cpu_thread_fn(void *arg)
     return NULL;
 }
 
+/*
+ * 在以下使用dummy_start_vcpu_thread():
+ *   - accel/qtest/qtest.c|53| <<qtest_accel_ops_class_init>> ops->create_vcpu_thread = dummy_start_vcpu_thread;
+ */
 void dummy_start_vcpu_thread(CPUState *cpu)
 {
     char thread_name[VCPU_THREAD_NAME_SIZE];
diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index c4244a23c..231c7ec11 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -24,6 +24,10 @@
 
 #include "kvm-cpus.h"
 
+/*
+ * 在以下使用kvm_vcpu_thread_fn():
+ *   - accel/kvm/kvm-accel-ops.c|77| <<kvm_start_vcpu_thread>> qemu_thread_create(cpu->thread, thread_name, kvm_vcpu_thread_fn,
+ */
 static void *kvm_vcpu_thread_fn(void *arg)
 {
     CPUState *cpu = arg;
@@ -61,6 +65,10 @@ static void *kvm_vcpu_thread_fn(void *arg)
     return NULL;
 }
 
+/*
+ * 在以下使用kvm_start_vcpu_thread():
+ *   - accel/kvm/kvm-accel-ops.c|91| <<kvm_accel_ops_class_init>> ops->create_vcpu_thread = kvm_start_vcpu_thread;
+ */
 static void kvm_start_vcpu_thread(CPUState *cpu)
 {
     char thread_name[VCPU_THREAD_NAME_SIZE];
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 5f1377ca0..34f40942a 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -431,6 +431,10 @@ err:
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|57| <<kvm_vcpu_thread_fn>> kvm_destroy_vcpu(cpu);
+ */
 void kvm_destroy_vcpu(CPUState *cpu)
 {
     if (do_kvm_destroy_vcpu(cpu) < 0) {
@@ -439,6 +443,10 @@ void kvm_destroy_vcpu(CPUState *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|468| <<kvm_init_vcpu>> ret = kvm_get_vcpu(s, kvm_arch_vcpu_id(cpu));
+ */
 static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id)
 {
     struct KVMParkedVcpu *cpu;
@@ -457,6 +465,10 @@ static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id)
     return kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)vcpu_id);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|40| <<kvm_vcpu_thread_fn>> r = kvm_init_vcpu(cpu, &error_fatal);
+ */
 int kvm_init_vcpu(CPUState *cpu, Error **errp)
 {
     KVMState *s = kvm_state;
@@ -2837,6 +2849,10 @@ static void kvm_eat_signals(CPUState *cpu)
     } while (sigismember(&chkset, SIG_IPI));
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|49| <<kvm_vcpu_thread_fn>> r = kvm_cpu_exec(cpu);
+ */
 int kvm_cpu_exec(CPUState *cpu)
 {
     struct kvm_run *run = cpu->kvm_run;
diff --git a/block/file-posix.c b/block/file-posix.c
index 39a3d6dbe..70c172bc2 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -1176,6 +1176,10 @@ static void raw_reopen_abort(BDRVReopenState *state)
     s->reopen_state = NULL;
 }
 
+/*
+ * called by:
+ *   - block/file-posix.c|1285| <<raw_refresh_limits>> int ret = hdev_get_max_hw_transfer(s->fd, &st);
+ */
 static int hdev_get_max_hw_transfer(int fd, struct stat *st)
 {
 #ifdef BLKSECTGET
@@ -1196,6 +1200,10 @@ static int hdev_get_max_hw_transfer(int fd, struct stat *st)
 #endif
 }
 
+/*
+ * called by:
+ *   - block/file-posix.c|1291| <<raw_refresh_limits>> ret = hdev_get_max_segments(s->fd, &st);
+ */
 static int hdev_get_max_segments(int fd, struct stat *st)
 {
 #ifdef CONFIG_LINUX
diff --git a/hw/net/vhost_net.c b/hw/net/vhost_net.c
index 30379d2ca..aea053a26 100644
--- a/hw/net/vhost_net.c
+++ b/hw/net/vhost_net.c
@@ -316,6 +316,10 @@ static void vhost_net_stop_one(struct vhost_net *net,
     vhost_dev_disable_notifiers(&net->dev, dev);
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|295| <<virtio_net_vhost_status>> r = vhost_net_start(vdev, n->nic->ncs, queue_pairs, cvq);
+ */
 int vhost_net_start(VirtIODevice *dev, NetClientState *ncs,
                     int data_queue_pairs, int cvq)
 {
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index 1067e72b3..96086dd3c 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -287,6 +287,11 @@ static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)
         }
 
         n->vhost_started = 1;
+	/*
+	 * VirtIONet *n:
+	 * -> NICState *nic;
+	 *    -> NetClientState *ncs;
+	 */
         r = vhost_net_start(vdev, n->nic->ncs, queue_pairs, cvq);
         if (r < 0) {
             error_report("unable to start vhost net: %d: "
diff --git a/hw/scsi/virtio-scsi-dataplane.c b/hw/scsi/virtio-scsi-dataplane.c
index 29575cbaf..8f850e0dc 100644
--- a/hw/scsi/virtio-scsi-dataplane.c
+++ b/hw/scsi/virtio-scsi-dataplane.c
@@ -81,6 +81,10 @@ static void virtio_scsi_dataplane_stop_bh(void *opaque)
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * 在以下使用virtio_scsi_dataplane_start():
+ *   - hw/scsi/virtio-scsi.c|1106| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ */
 int virtio_scsi_dataplane_start(VirtIODevice *vdev)
 {
     int i;
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index 9d637e043..efe5dd3eb 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -1887,6 +1887,14 @@ void qemu_put_virtqueue_element(VirtIODevice *vdev, QEMUFile *f,
 }
 
 /* virtio device */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1906| <<virtio_update_irq>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ *   - hw/virtio/virtio.c|2000| <<virtio_reset>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|2528| <<virtio_irq>> virtio_notify_vector(vq->vdev, vq->vector);
+ *   - hw/virtio/virtio.c|2550| <<virtio_notify_config>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|3051| <<virtio_load>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ */
 static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
@@ -2522,6 +2530,11 @@ void virtio_notify_irqfd(VirtIODevice *vdev, VirtQueue *vq)
     event_notifier_set(&vq->guest_notifier);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|2540| <<virtio_notify>> virtio_irq(vq);
+ *   - hw/virtio/virtio.c|3471| <<virtio_queue_guest_notifier_read>> virtio_irq(vq);
+ */
 static void virtio_irq(VirtQueue *vq)
 {
     virtio_set_isr(vq->vdev, 0x1);
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index cb6b5467d..69a8f7425 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -673,6 +673,22 @@ void x86_cpu_vendor_words2str(char *dst, uint32_t vendor1,
 #define TCG_SGX_12_0_EBX_FEATURES 0
 #define TCG_SGX_12_1_EAX_FEATURES 0
 
+/*
+ * 在以下使用feature_word_info[FEATURE_WORDS]:
+ *   - target/i386/cpu-sysemu.c|68| <<x86_cpu_static_props>> FeatureWordInfo *fi = &feature_word_info[w];
+ *   - target/i386/cpu.c|1467| <<x86_cpu_get_migratable_flags>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|4350| <<mark_unavailable_features>> FeatureWordInfo *f = &feature_word_info[w];
+ *   - target/i386/cpu.c|4600| <<x86_cpu_get_feature_words>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|4653| <<x86_cpu_feature_name>> name = feature_word_info[w].feat_names[bitnr];
+ *   - target/i386/cpu.c|4654| <<x86_cpu_feature_name>> assert(bitnr < 32 || !(name && feature_word_info[w].type == CPUID_FEATURE_WORD));
+ *   - target/i386/cpu.c|4931| <<x86_cpu_list>> for (i = 0; i < ARRAY_SIZE(feature_word_info); i++) {
+ *   - target/i386/cpu.c|4932| <<x86_cpu_list>> FeatureWordInfo *fw = &feature_word_info[i];
+ *   - target/i386/cpu.c|4992| <<x86_cpu_get_supported_feature_word>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|6051| <<x86_cpu_adjust_feat_level>> FeatureWordInfo *fi = &feature_word_info[w];
+ *   - target/i386/cpu.c|6055| <<x86_cpu_adjust_feat_level>> assert(feature_word_info[w].type == CPUID_FEATURE_WORD);
+ *   - target/i386/cpu.c|6184| <<x86_cpu_expand_features>> ~feature_word_info[w].no_autoenable_flags;
+ *   - target/i386/cpu.c|6671| <<x86_cpu_register_feature_bit_props>> FeatureWordInfo *fi = &feature_word_info[w];
+ */
 FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
     [FEAT_1_EDX] = {
         .type = CPUID_FEATURE_WORD,
@@ -1780,6 +1796,11 @@ static const CPUCaches epyc_milan_cache_info = {
  *  PT in VMX operation
  */
 
+/*
+ * 在以下使用builtin_x86_defs[]:
+ *   - target/i386/cpu.c|7134| <<x86_cpu_register_types>> for (i = 0; i < ARRAY_SIZE(builtin_x86_defs); i++) {
+ *   - target/i386/cpu.c|7135| <<x86_cpu_register_types>> x86_register_cpudef_types(&builtin_x86_defs[i]);
+ */
 static const X86CPUDefinition builtin_x86_defs[] = {
     {
         .name = "qemu64",
@@ -5042,6 +5063,10 @@ void x86_cpu_apply_props(X86CPU *cpu, PropValue *props)
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|5128| <<x86_cpu_load_model>> x86_cpu_apply_version_props(cpu, model);
+ */
 static void x86_cpu_apply_version_props(X86CPU *cpu, X86CPUModel *model)
 {
     const X86CPUVersionDefinition *vdef;
@@ -5074,6 +5099,10 @@ static void x86_cpu_apply_version_props(X86CPU *cpu, X86CPUModel *model)
  * Load data from X86CPUDefinition into a X86CPU object.
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
+/*
+ * called by:
+ *   - target/i386/cpu.c|6745| <<x86_cpu_initfn>> x86_cpu_load_model(cpu, xcc->model);
+ */
 static void x86_cpu_load_model(X86CPU *cpu, X86CPUModel *model)
 {
     const X86CPUDefinition *def = model->cpudef;
@@ -5169,6 +5198,10 @@ static void x86_register_cpu_model_type(const char *name, X86CPUModel *model)
  * "max", "base" and subclasses ("host") are not registered here.
  * See x86_cpu_register_types for all model registrations.
  */
+/*
+ * called by:
+ *   - target/i386/cpu.c|7140| <<x86_cpu_register_types>> x86_register_cpudef_types(&builtin_x86_defs[i]);
+ */
 static void x86_register_cpudef_types(const X86CPUDefinition *def)
 {
     X86CPUModel *m;
@@ -6686,6 +6719,9 @@ static void x86_cpu_post_initfn(Object *obj)
     accel_cpu_instance_init(CPU(obj));
 }
 
+/*
+ * const TypeInfo x86_cpu_type_info.instance_init = x86_cpu_initfn()
+ */
 static void x86_cpu_initfn(Object *obj)
 {
     X86CPU *cpu = X86_CPU(obj);
diff --git a/target/i386/host-cpu.c b/target/i386/host-cpu.c
index 10f8aba86..8f2b9c32d 100644
--- a/target/i386/host-cpu.c
+++ b/target/i386/host-cpu.c
@@ -50,6 +50,10 @@ static void host_cpu_enable_cpu_pm(X86CPU *cpu)
     env->features[FEAT_1_ECX] |= CPUID_EXT_MONITOR;
 }
 
+/*
+ * called by:
+ *   - target/i386/host-cpu.c|92| <<host_cpu_realizefn>> uint32_t phys_bits = host_cpu_adjust_phys_bits(cpu);
+ */
 static uint32_t host_cpu_adjust_phys_bits(X86CPU *cpu)
 {
     uint32_t host_phys_bits = host_cpu_phys_bits();
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 9cf8e0366..be6a062c0 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -4328,6 +4328,12 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2763| <<do_kvm_cpu_synchronize_post_reset>> kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE);
+ *   - accel/kvm/kvm-all.c|2774| <<do_kvm_cpu_synchronize_post_init>> kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);
+ *   - accel/kvm/kvm-all.c|2867| <<kvm_cpu_exec>> kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);
+ */
 int kvm_arch_put_registers(CPUState *cpu, int level)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
-- 
2.17.1

