From efc6665317338e3c8159c19364be62486dc0d5f1 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang@oracle.com>
Date: Thu, 22 Nov 2018 16:07:06 +0800
Subject: [PATCH 1/1] virtio comment for linux-4.19.3

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
Signed-off-by: Dongli Zhang <dongli.zhang@oracle.com>
---
 drivers/block/virtio_blk.c         |  92 ++++++++++++++++++++++++++
 drivers/virtio/virtio.c            | 129 +++++++++++++++++++++++++++++++++++++
 drivers/virtio/virtio_pci_common.c |  86 +++++++++++++++++++++++++
 include/linux/virtio.h             |   4 ++
 4 files changed, 311 insertions(+)

diff --git a/drivers/block/virtio_blk.c b/drivers/block/virtio_blk.c
index 23752dc..078b388 100644
--- a/drivers/block/virtio_blk.c
+++ b/drivers/block/virtio_blk.c
@@ -422,6 +422,12 @@ static void virtblk_config_changed_work(struct work_struct *work)
 	kobject_uevent_env(&disk_to_dev(vblk->disk)->kobj, KOBJ_CHANGE, envp);
 }
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio.c|181| <<__virtio_config_changed>> drv->config_changed(dev);
+ *
+ * struct virtio_driver virtio_blk.config_changed = virtblk_config_changed()
+ */
 static void virtblk_config_changed(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -624,6 +630,52 @@ static const struct blk_mq_ops virtio_mq_ops = {
 static unsigned int virtblk_queue_depth;
 module_param_named(queue_depth, virtblk_queue_depth, uint, 0444);
 
+/*
+ * 初始化的时候:
+ * [0] virtblk_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtblk_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] bus_probe_device
+ * [0] device_add
+ * [0] register_virtio_device
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct virtio_driver virtio_blk.probe = virtblk_probe()
+ */
 static int virtblk_probe(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk;
@@ -812,6 +864,31 @@ static int virtblk_probe(struct virtio_device *vdev)
 	return err;
 }
 
+/*
+ * hotplug的时候:
+ * [0] virtblk_remove
+ * [0] virtio_dev_remove
+ * [0] device_release_driver_internal
+ * [0] bus_remove_device
+ * [0] device_del
+ * [0] device_unregister
+ * [0] unregister_virtio_device
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct virtio_driver virtio_blk.remove = virtblk_remove()
+ */
 static void virtblk_remove(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -841,6 +918,9 @@ static void virtblk_remove(struct virtio_device *vdev)
 }
 
 #ifdef CONFIG_PM_SLEEP
+/*
+ * struct virtio_driver virtio_blk.freeze = virtblk_freeze()
+ */
 static int virtblk_freeze(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -857,6 +937,9 @@ static int virtblk_freeze(struct virtio_device *vdev)
 	return 0;
 }
 
+/*
+ * struct virtio_driver virtio_blk.restore = virtblk_restore()
+ */
 static int virtblk_restore(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -873,11 +956,17 @@ static int virtblk_restore(struct virtio_device *vdev)
 }
 #endif
 
+/*
+ * struct virtio_driver virtio_blk.id_table = id_table
+ */
 static const struct virtio_device_id id_table[] = {
 	{ VIRTIO_ID_BLOCK, VIRTIO_DEV_ANY_ID },
 	{ 0 },
 };
 
+/*
+ * struct virtio_driver virtio_blk.feature_table_legacy = features_legacy
+ */
 static unsigned int features_legacy[] = {
 	VIRTIO_BLK_F_SEG_MAX, VIRTIO_BLK_F_SIZE_MAX, VIRTIO_BLK_F_GEOMETRY,
 	VIRTIO_BLK_F_RO, VIRTIO_BLK_F_BLK_SIZE,
@@ -888,6 +977,9 @@ static unsigned int features_legacy[] = {
 	VIRTIO_BLK_F_MQ,
 }
 ;
+/*
+ * struct virtio_driver virtio_blk.feature_table = features
+ */
 static unsigned int features[] = {
 	VIRTIO_BLK_F_SEG_MAX, VIRTIO_BLK_F_SIZE_MAX, VIRTIO_BLK_F_GEOMETRY,
 	VIRTIO_BLK_F_RO, VIRTIO_BLK_F_BLK_SIZE,
diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c
index 59e36ef..4a4eb7f 100644
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@ -58,6 +58,7 @@ static ssize_t features_show(struct device *_d,
 }
 static DEVICE_ATTR_RO(features);
 
+/* 用在下面的ATTRIBUTE_GROUPS(virtio_dev) */
 static struct attribute *virtio_dev_attrs[] = {
 	&dev_attr_device.attr,
 	&dev_attr_vendor.attr,
@@ -66,6 +67,13 @@ static struct attribute *virtio_dev_attrs[] = {
 	&dev_attr_features.attr,
 	NULL,
 };
+/*
+ * static const struct attribute_group virtio_dev_group = {
+ *     .attrs = virtio_dev_attrs,
+ * };
+ *
+ * struct bus_type virtio_bus.dev_groups = virtio_dev_group
+ */
 ATTRIBUTE_GROUPS(virtio_dev);
 
 static inline int virtio_id_match(const struct virtio_device *dev,
@@ -79,6 +87,46 @@ static inline int virtio_id_match(const struct virtio_device *dev,
 
 /* This looks through all the IDs a driver claims to support.  If any of them
  * match, we return 1 and the kernel will call virtio_dev_probe(). */
+/*
+ * 初始化的时候:
+ * [0] virtio_dev_match
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_dev_match+0x19/0x70
+ * [0] __device_attach_driver+0x34/0xa0
+ * [0] bus_for_each_drv+0x5f/0xb0
+ * [0] __device_attach+0xd4/0x130
+ * [0] bus_probe_device+0x85/0xa0
+ * [0] device_add+0x3be/0x650
+ * [0] register_virtio_device+0xb7/0x100
+ * [0] virtio_pci_probe+0xbd/0x150
+ * [0] local_pci_probe+0x3f/0x90
+ * [0] pci_device_probe+0xdd/0x170
+ * [0] really_probe+0x231/0x2d0
+ * [0] driver_probe_device+0x4a/0xe0
+ * [0] bus_for_each_drv+0x5f/0xb0
+ * [0] __device_attach+0xd4/0x130
+ * [0] pci_bus_add_device+0x45/0x90
+ * [0] pci_bus_add_devices+0x31/0x70
+ * [0] pciehp_configure_device+0x8e/0x130
+ * [0] pciehp_handle_presence_or_link_change+0x288/0x4d0
+ * [0] pciehp_ist+0x1ae/0x1c0
+ * [0] irq_thread_fn+0x1c/0x60
+ * [0] irq_thread+0x12f/0x190
+ * [0] kthread+0xf3/0x130
+ * [0] ret_from_fork+0x35/0x40
+ *
+ * struct bus_type virtio_bus.match = virtio_dev_match()
+ */
 static int virtio_dev_match(struct device *_dv, struct device_driver *_dr)
 {
 	unsigned int i;
@@ -92,6 +140,9 @@ static int virtio_dev_match(struct device *_dv, struct device_driver *_dr)
 	return 0;
 }
 
+/*
+ * struct bus_type virtio_bus.uevent = virtio_uevent()
+ */
 static int virtio_uevent(struct device *_dv, struct kobj_uevent_env *env)
 {
 	struct virtio_device *dev = dev_to_virtio(_dv);
@@ -187,6 +238,50 @@ int virtio_finalize_features(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_finalize_features);
 
+/*
+ * 初始化的时候:
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] bus_probe_device
+ * [0] device_add
+ * [0] register_virtio_device
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0]ret_from_fork
+ *
+ * struct bus_type virtio_bus.probe = virtio_dev_probe()
+ */
 static int virtio_dev_probe(struct device *_d)
 {
 	int err, i;
@@ -262,6 +357,30 @@ static int virtio_dev_probe(struct device *_d)
 
 }
 
+/*
+ * hotplug的时候:
+ * [0] virtio_dev_remove
+ * [0] device_release_driver_internal
+ * [0] bus_remove_device
+ * [0] device_del
+ * [0] device_unregister
+ * [0] unregister_virtio_device
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct bus_type virtio_bus.remove = virtio_dev_remove()
+ */
 static int virtio_dev_remove(struct device *_d)
 {
 	struct virtio_device *dev = dev_to_virtio(_d);
@@ -364,6 +483,11 @@ void unregister_virtio_device(struct virtio_device *dev)
 EXPORT_SYMBOL_GPL(unregister_virtio_device);
 
 #ifdef CONFIG_PM_SLEEP
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|467| <<virtio_pci_freeze>> ret = virtio_device_freeze(&vp_dev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1320| <<virtio_ccw_freeze>> return virtio_device_freeze(&vcdev->vdev);
+ */
 int virtio_device_freeze(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
@@ -379,6 +503,11 @@ int virtio_device_freeze(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_device_freeze);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|485| <<virtio_pci_restore>> return virtio_device_restore(&vp_dev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1332| <<virtio_ccw_restore>> return virtio_device_restore(&vcdev->vdev);
+ */
 int virtio_device_restore(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
diff --git a/drivers/virtio/virtio_pci_common.c b/drivers/virtio/virtio_pci_common.c
index 465a6f5..52ef210 100644
--- a/drivers/virtio/virtio_pci_common.c
+++ b/drivers/virtio/virtio_pci_common.c
@@ -19,6 +19,16 @@
 
 #include "virtio_pci_common.h"
 
+/*
+ * 2个virtio-blk(每个2个queue)的例子:
+ *  24:          0          0   PCI-MSI 49152-edge      virtio0-config
+ *  25:       1245          0   PCI-MSI 49153-edge      virtio0-req.0
+ *  26:          0       1617   PCI-MSI 49154-edge      virtio0-req.1
+ *  27:          0          0   PCI-MSI 65536-edge      virtio1-config
+ *  28:         35          0   PCI-MSI 65537-edge      virtio1-req.0
+ *  29:          0         34   PCI-MSI 65538-edge      virtio1-req.1
+ */
+
 static bool force_legacy = false;
 
 #if IS_ENABLED(CONFIG_VIRTIO_PCI_LEGACY)
@@ -28,6 +38,11 @@ MODULE_PARM_DESC(force_legacy,
 #endif
 
 /* wait for pending irq handlers */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_legacy.c|102| <<vp_reset>> vp_synchronize_vectors(vdev);
+ *   - drivers/virtio/virtio_pci_modern.c|297| <<vp_reset>> vp_synchronize_vectors(vdev);
+ */
 void vp_synchronize_vectors(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -82,6 +97,11 @@ static irqreturn_t vp_vring_interrupt(int irq, void *opaque)
  * the callback may notify the host which results in the host attempting to
  * raise an interrupt that we would then mask once we acknowledged the
  * interrupt. */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|370| <<vp_find_vqs_intx>> err = request_irq(vp_dev->pci_dev->irq, vp_interrupt, IRQF_SHARED,
+ *                                                                                    dev_name(&vdev->dev), vp_dev);
+ */
 static irqreturn_t vp_interrupt(int irq, void *opaque)
 {
 	struct virtio_pci_device *vp_dev = opaque;
@@ -485,6 +505,9 @@ static int virtio_pci_restore(struct device *dev)
 	return virtio_device_restore(&vp_dev->vdev);
 }
 
+/*
+ * struct pci_driver virtio_pci_driver.drive.pm = virtio_pci_pm_ops
+ */
 static const struct dev_pm_ops virtio_pci_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(virtio_pci_freeze, virtio_pci_restore)
 };
@@ -492,6 +515,9 @@ static const struct dev_pm_ops virtio_pci_pm_ops = {
 
 
 /* Qumranet donated their vendor ID for devices 0x1000 thru 0x10FF. */
+/*
+ * struct pci_driver virtio_pci_driver.id_table = virtio_pci_id_table
+ */
 static const struct pci_device_id virtio_pci_id_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_ANY_ID) },
 	{ 0 }
@@ -510,6 +536,43 @@ static void virtio_pci_release_dev(struct device *_d)
 	kfree(vp_dev);
 }
 
+/*
+ * 初始化的时候:
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct pci_driver virtio_pci_driver.probe = virtio_pci_probe()
+ */
 static int virtio_pci_probe(struct pci_dev *pci_dev,
 			    const struct pci_device_id *id)
 {
@@ -517,6 +580,9 @@ static int virtio_pci_probe(struct pci_dev *pci_dev,
 	int rc;
 
 	/* allocate our structure and fill it out */
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 */
 	vp_dev = kzalloc(sizeof(struct virtio_pci_device), GFP_KERNEL);
 	if (!vp_dev)
 		return -ENOMEM;
@@ -572,6 +638,23 @@ static int virtio_pci_probe(struct pci_dev *pci_dev,
 	return rc;
 }
 
+/*
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct pci_driver virtio_pci_driver.remove = virtio_pci_remove()
+ */
 static void virtio_pci_remove(struct pci_dev *pci_dev)
 {
 	struct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);
@@ -590,6 +673,9 @@ static void virtio_pci_remove(struct pci_dev *pci_dev)
 	put_device(dev);
 }
 
+/*
+ * struct pci_driver virtio_pci_driver.sriov_configure = virtio_pci_sriov_configure()
+ */
 static int virtio_pci_sriov_configure(struct pci_dev *pci_dev, int num_vfs)
 {
 	struct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);
diff --git a/include/linux/virtio.h b/include/linux/virtio.h
index fa1b5da..68a8b70 100644
--- a/include/linux/virtio.h
+++ b/include/linux/virtio.h
@@ -188,6 +188,10 @@ struct virtio_driver {
 	int (*probe)(struct virtio_device *dev);
 	void (*scan)(struct virtio_device *dev);
 	void (*remove)(struct virtio_device *dev);
+	/*
+	 * called only by:
+	 *   - drivers/virtio/virtio.c|181| <<__virtio_config_changed>> drv->config_changed(dev);
+	 */
 	void (*config_changed)(struct virtio_device *dev);
 #ifdef CONFIG_PM
 	int (*freeze)(struct virtio_device *dev);
-- 
2.7.4

