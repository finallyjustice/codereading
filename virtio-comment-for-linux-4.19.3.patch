From b9b3d1f5b0cd568b61037e0bc4c86d26342b5a6e Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang@oracle.com>
Date: Wed, 28 Nov 2018 15:58:47 +0800
Subject: [PATCH 1/1] virtio comment for linux-4.19.3

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 drivers/block/virtio_blk.c         | 215 ++++++++++++
 drivers/virtio/virtio.c            | 182 ++++++++++
 drivers/virtio/virtio_pci_common.c | 402 ++++++++++++++++++++++
 drivers/virtio/virtio_pci_common.h |  84 +++++
 drivers/virtio/virtio_pci_legacy.c | 241 ++++++++++++++
 drivers/virtio/virtio_pci_modern.c | 230 +++++++++++++
 drivers/virtio/virtio_ring.c       | 660 +++++++++++++++++++++++++++++++++++++
 include/linux/virtio.h             |  34 ++
 include/linux/virtio_config.h      |  73 ++++
 include/uapi/linux/vhost.h         |   2 +
 include/uapi/linux/virtio_pci.h    |   7 +
 include/uapi/linux/virtio_ring.h   |  41 +++
 12 files changed, 2171 insertions(+)

diff --git a/drivers/block/virtio_blk.c b/drivers/block/virtio_blk.c
index 23752dc..c8db53b 100644
--- a/drivers/block/virtio_blk.c
+++ b/drivers/block/virtio_blk.c
@@ -40,6 +40,16 @@ struct virtio_blk {
 	struct blk_mq_tag_set tag_set;
 
 	/* Process context for config space updates */
+	/*
+	 * 设置为virtblk_config_changed_work()的地方:
+	 *   - drivers/block/virtio_blk.c|726| <<virtblk_probe>> INIT_WORK(&vblk->config_work, virtblk_config_changed_work);
+	 *
+	 * 调用的地方:
+	 *   - drivers/block/virtio_blk.c|422| <<virtblk_config_changed_work>> container_of(work, struct virtio_blk, config_work);
+	 *   - drivers/block/virtio_blk.c|440| <<virtblk_config_changed>> queue_work(virtblk_wq, &vblk->config_work);
+	 *   - drivers/block/virtio_blk.c|904| <<virtblk_remove>> flush_work(&vblk->config_work);
+	 *   - drivers/block/virtio_blk.c|937| <<virtblk_freeze>> flush_work(&vblk->config_work);
+	 */
 	struct work_struct config_work;
 
 	/* What host tells us, plus 2 for header & tailer. */
@@ -50,6 +60,10 @@ struct virtio_blk {
 
 	/* num of vqs */
 	int num_vqs;
+	/*
+	 * 在以下被分配:
+	 *   - drivers/block/virtio_blk.c|476| <<init_vq>> vqs = kmalloc_array(num_vqs, sizeof(*vqs), GFP_KERNEL);
+	 */
 	struct virtio_blk_vq *vqs;
 };
 
@@ -64,6 +78,11 @@ struct virtblk_req {
 	struct scatterlist sg[];
 };
 
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|186| <<virtblk_request_done>> blk_mq_end_request(req, virtblk_result(vbr));
+ *   - drivers/block/virtio_blk.c|310| <<virtblk_get_id>> err = blk_status_to_errno(virtblk_result(blk_mq_rq_to_pdu(req)));
+ */
 static inline blk_status_t virtblk_result(struct virtblk_req *vbr)
 {
 	switch (vbr->status) {
@@ -150,6 +169,10 @@ static inline void virtblk_scsi_request_done(struct request *req)
 #define virtblk_ioctl	NULL
 #endif /* CONFIG_VIRTIO_BLK_SCSI */
 
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|290| <<virtio_queue_rq>> err = virtblk_add_req(vblk->vqs[qid].vq, vbr, vbr->sg, num);
+ */
 static int virtblk_add_req(struct virtqueue *vq, struct virtblk_req *vbr,
 		struct scatterlist *data_sg, bool have_data)
 {
@@ -172,6 +195,9 @@ static int virtblk_add_req(struct virtqueue *vq, struct virtblk_req *vbr,
 	return virtqueue_add_sgs(vq, sgs, num_out, num_in, vbr, GFP_ATOMIC);
 }
 
+/*
+ * struct blk_mq_ops virtio_mq_ops.complete = virtblk_request_done()
+ */
 static inline void virtblk_request_done(struct request *req)
 {
 	struct virtblk_req *vbr = blk_mq_rq_to_pdu(req);
@@ -186,6 +212,20 @@ static inline void virtblk_request_done(struct request *req)
 	blk_mq_end_request(req, virtblk_result(vbr));
 }
 
+/*
+ * [0] dump_stack
+ * [0] virtblk_done
+ * [0] vring_interrupt
+ * [0] __handle_irq_event_percpu
+ * [0] handle_irq_event_percpu
+ * [0] handle_irq_event
+ * [0] handle_edge_irq
+ * [0] handle_irq
+ * [0] do_IRQ
+ * [0] common_interrupt
+ *
+ * 在drivers/block/virtio_blk.c|527| <<init_vq>> callbacks[i] = virtblk_done;
+ */
 static void virtblk_done(struct virtqueue *vq)
 {
 	struct virtio_blk *vblk = vq->vdev->priv;
@@ -198,6 +238,12 @@ static void virtblk_done(struct virtqueue *vq)
 	spin_lock_irqsave(&vblk->vqs[qid].lock, flags);
 	do {
 		virtqueue_disable_cb(vq);
+		/*
+		 * 取出used中下一个元素, 参数的len返回vq->vring.used->ring[last_used].len
+		 * 把用到的desc的地址都回收 (自己unmap或通过iommu)
+		 * 函数返回vq->desc_state[i].data
+		 * 不过virtqueue_get_buf_ctx()的ctx是NULL
+		 */
 		while ((vbr = virtqueue_get_buf(vblk->vqs[qid].vq, &len)) != NULL) {
 			struct request *req = blk_mq_rq_from_pdu(vbr);
 
@@ -214,6 +260,9 @@ static void virtblk_done(struct virtqueue *vq)
 	spin_unlock_irqrestore(&vblk->vqs[qid].lock, flags);
 }
 
+/*
+ * struct blk_mq_ops virtio_mq_ops.queue_rq = virtio_queue_rq()
+ */
 static blk_status_t virtio_queue_rq(struct blk_mq_hw_ctx *hctx,
 			   const struct blk_mq_queue_data *bd)
 {
@@ -411,6 +460,16 @@ static void virtblk_update_capacity(struct virtio_blk *vblk, bool resize)
 	set_capacity(vblk->disk, capacity);
 }
 
+/*
+ * 设置为virtblk_config_changed_work()的地方:
+ *   - drivers/block/virtio_blk.c|726| <<virtblk_probe>> INIT_WORK(&vblk->config_work, virtblk_config_changed_work);
+ *
+ * 调用的地方:
+ *   - drivers/block/virtio_blk.c|422| <<virtblk_config_changed_work>> container_of(work, struct virtio_blk, config_work);
+ *   - drivers/block/virtio_blk.c|440| <<virtblk_config_changed>> queue_work(virtblk_wq, &vblk->config_work);
+ *   - drivers/block/virtio_blk.c|904| <<virtblk_remove>> flush_work(&vblk->config_work);
+ *   - drivers/block/virtio_blk.c|937| <<virtblk_freeze>> flush_work(&vblk->config_work);
+ */
 static void virtblk_config_changed_work(struct work_struct *work)
 {
 	struct virtio_blk *vblk =
@@ -422,6 +481,12 @@ static void virtblk_config_changed_work(struct work_struct *work)
 	kobject_uevent_env(&disk_to_dev(vblk->disk)->kobj, KOBJ_CHANGE, envp);
 }
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio.c|181| <<__virtio_config_changed>> drv->config_changed(dev);
+ *
+ * struct virtio_driver virtio_blk.config_changed = virtblk_config_changed()
+ */
 static void virtblk_config_changed(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -440,18 +505,38 @@ static int init_vq(struct virtio_blk *vblk)
 	struct virtio_device *vdev = vblk->vdev;
 	struct irq_affinity desc = { 0, };
 
+	/*
+	 * 最终通过virtio_device->config->get()获取 
+	 * 设置config的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops;
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	err = virtio_cread_feature(vdev, VIRTIO_BLK_F_MQ,
 				   struct virtio_blk_config, num_queues,
 				   &num_vqs);
 	if (err)
 		num_vqs = 1;
 
+	/*
+	 * vqs(struct virtio_blk_vq)是数组(struct virtio_blk_vq *vqs),这里分配了num_vqs个实体
+	 */
 	vblk->vqs = kmalloc_array(num_vqs, sizeof(*vblk->vqs), GFP_KERNEL);
 	if (!vblk->vqs)
 		return -ENOMEM;
 
+	/*
+	 * 这里的names也是分配指针数组
+	 */
 	names = kmalloc_array(num_vqs, sizeof(*names), GFP_KERNEL);
+	/*
+	 * callbacks也是分配指针数组
+	 */
 	callbacks = kmalloc_array(num_vqs, sizeof(*callbacks), GFP_KERNEL);
+	/*
+	 * 分配struct virtqueue的指针数组
+	 */
 	vqs = kmalloc_array(num_vqs, sizeof(*vqs), GFP_KERNEL);
 	if (!names || !callbacks || !vqs) {
 		err = -ENOMEM;
@@ -465,6 +550,12 @@ static int init_vq(struct virtio_blk *vblk)
 	}
 
 	/* Discover virtqueues and write information to configuration.  */
+	/*
+	 * 此时,
+	 *   vqs: num_vqs个struct virtqueue指针
+	 *   callbacks: num_vqs个函数指针, 每个指向virtblk_done()
+	 *   names: num_vqs个指针, 每个指向对应的vblk->vqs[i].name
+	 */
 	err = virtio_find_vqs(vdev, num_vqs, vqs, callbacks, names, &desc);
 	if (err)
 		goto out;
@@ -582,6 +673,9 @@ static const struct device_attribute dev_attr_cache_type_rw =
 	__ATTR(cache_type, 0644,
 	       virtblk_cache_type_show, virtblk_cache_type_store);
 
+/*
+ * struct blk_mq_ops virtio_mq_ops.init_request = virtblk_init_request()
+ */
 static int virtblk_init_request(struct blk_mq_tag_set *set, struct request *rq,
 		unsigned int hctx_idx, unsigned int numa_node)
 {
@@ -595,6 +689,9 @@ static int virtblk_init_request(struct blk_mq_tag_set *set, struct request *rq,
 	return 0;
 }
 
+/*
+ * struct blk_mq_ops virtio_mq_ops.map_queues = virtblk_map_queues()
+ */
 static int virtblk_map_queues(struct blk_mq_tag_set *set)
 {
 	struct virtio_blk *vblk = set->driver_data;
@@ -603,6 +700,9 @@ static int virtblk_map_queues(struct blk_mq_tag_set *set)
 }
 
 #ifdef CONFIG_VIRTIO_BLK_SCSI
+/*
+ * struct blk_mq_ops virtio_mq_ops.initialize_rq_fn = virtblk_initialize_rq()
+ */
 static void virtblk_initialize_rq(struct request *req)
 {
 	struct virtblk_req *vbr = blk_mq_rq_to_pdu(req);
@@ -624,6 +724,52 @@ static const struct blk_mq_ops virtio_mq_ops = {
 static unsigned int virtblk_queue_depth;
 module_param_named(queue_depth, virtblk_queue_depth, uint, 0444);
 
+/*
+ * 初始化的时候:
+ * [0] virtblk_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtblk_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] bus_probe_device
+ * [0] device_add
+ * [0] register_virtio_device
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct virtio_driver virtio_blk.probe = virtblk_probe()
+ */
 static int virtblk_probe(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk;
@@ -634,6 +780,13 @@ static int virtblk_probe(struct virtio_device *vdev)
 	u16 min_io_size;
 	u8 physical_block_exp, alignment_offset;
 
+	/*
+	 * 设置virtio_device->config的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	if (!vdev->config->get) {
 		dev_err(&vdev->dev, "%s failure: config access disabled\n",
 			__func__);
@@ -647,6 +800,14 @@ static int virtblk_probe(struct virtio_device *vdev)
 	index = err;
 
 	/* We need to know how many segments before we allocate. */
+	/*
+	 * 最终通过virtio_device->config->get()获取
+	 * 设置config的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops;
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	err = virtio_cread_feature(vdev, VIRTIO_BLK_F_SEG_MAX,
 				   struct virtio_blk_config, seg_max,
 				   &sg_elems);
@@ -666,6 +827,13 @@ static int virtblk_probe(struct virtio_device *vdev)
 	vblk->vdev = vdev;
 	vblk->sg_elems = sg_elems;
 
+	/*
+	 * 调用的地方:
+	 *   - drivers/block/virtio_blk.c|422| <<virtblk_config_changed_work>> container_of(work, struct virtio_blk, config_work);
+	 *   - drivers/block/virtio_blk.c|440| <<virtblk_config_changed>> queue_work(virtblk_wq, &vblk->config_work);
+	 *   - drivers/block/virtio_blk.c|904| <<virtblk_remove>> flush_work(&vblk->config_work);
+	 *   - drivers/block/virtio_blk.c|937| <<virtblk_freeze>> flush_work(&vblk->config_work);
+	 */
 	INIT_WORK(&vblk->config_work, virtblk_config_changed_work);
 
 	err = init_vq(vblk);
@@ -728,9 +896,16 @@ static int virtblk_probe(struct virtio_device *vdev)
 		set_disk_ro(vblk->disk, 1);
 
 	/* We can handle whatever the host told us to handle. */
+	/*
+	 * Enables a low level driver to set an upper limit on the number of
+	 *    hw data segments in a request.
+	 */
 	blk_queue_max_segments(q, vblk->sg_elems-2);
 
 	/* No real sector limit. */
+	/*
+	 * set max sectors for a request for this queue
+	 */
 	blk_queue_max_hw_sectors(q, -1U);
 
 	/* Host can optionally specify maximum segment size and number of
@@ -812,6 +987,31 @@ static int virtblk_probe(struct virtio_device *vdev)
 	return err;
 }
 
+/*
+ * hotplug的时候:
+ * [0] virtblk_remove
+ * [0] virtio_dev_remove
+ * [0] device_release_driver_internal
+ * [0] bus_remove_device
+ * [0] device_del
+ * [0] device_unregister
+ * [0] unregister_virtio_device
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct virtio_driver virtio_blk.remove = virtblk_remove()
+ */
 static void virtblk_remove(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -841,6 +1041,9 @@ static void virtblk_remove(struct virtio_device *vdev)
 }
 
 #ifdef CONFIG_PM_SLEEP
+/*
+ * struct virtio_driver virtio_blk.freeze = virtblk_freeze()
+ */
 static int virtblk_freeze(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -857,6 +1060,9 @@ static int virtblk_freeze(struct virtio_device *vdev)
 	return 0;
 }
 
+/*
+ * struct virtio_driver virtio_blk.restore = virtblk_restore()
+ */
 static int virtblk_restore(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -873,11 +1079,17 @@ static int virtblk_restore(struct virtio_device *vdev)
 }
 #endif
 
+/*
+ * struct virtio_driver virtio_blk.id_table = id_table
+ */
 static const struct virtio_device_id id_table[] = {
 	{ VIRTIO_ID_BLOCK, VIRTIO_DEV_ANY_ID },
 	{ 0 },
 };
 
+/*
+ * struct virtio_driver virtio_blk.feature_table_legacy = features_legacy
+ */
 static unsigned int features_legacy[] = {
 	VIRTIO_BLK_F_SEG_MAX, VIRTIO_BLK_F_SIZE_MAX, VIRTIO_BLK_F_GEOMETRY,
 	VIRTIO_BLK_F_RO, VIRTIO_BLK_F_BLK_SIZE,
@@ -888,6 +1100,9 @@ static unsigned int features_legacy[] = {
 	VIRTIO_BLK_F_MQ,
 }
 ;
+/*
+ * struct virtio_driver virtio_blk.feature_table = features
+ */
 static unsigned int features[] = {
 	VIRTIO_BLK_F_SEG_MAX, VIRTIO_BLK_F_SIZE_MAX, VIRTIO_BLK_F_GEOMETRY,
 	VIRTIO_BLK_F_RO, VIRTIO_BLK_F_BLK_SIZE,
diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c
index 59e36ef..35831da 100644
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@ -58,6 +58,7 @@ static ssize_t features_show(struct device *_d,
 }
 static DEVICE_ATTR_RO(features);
 
+/* 用在下面的ATTRIBUTE_GROUPS(virtio_dev) */
 static struct attribute *virtio_dev_attrs[] = {
 	&dev_attr_device.attr,
 	&dev_attr_vendor.attr,
@@ -66,8 +67,19 @@ static struct attribute *virtio_dev_attrs[] = {
 	&dev_attr_features.attr,
 	NULL,
 };
+/*
+ * static const struct attribute_group virtio_dev_group = {
+ *     .attrs = virtio_dev_attrs,
+ * };
+ *
+ * struct bus_type virtio_bus.dev_groups = virtio_dev_group
+ */
 ATTRIBUTE_GROUPS(virtio_dev);
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio.c|138| <<virtio_dev_match>> if (virtio_id_match(dev, &ids[i]))
+ */
 static inline int virtio_id_match(const struct virtio_device *dev,
 				  const struct virtio_device_id *id)
 {
@@ -79,6 +91,46 @@ static inline int virtio_id_match(const struct virtio_device *dev,
 
 /* This looks through all the IDs a driver claims to support.  If any of them
  * match, we return 1 and the kernel will call virtio_dev_probe(). */
+/*
+ * 初始化的时候:
+ * [0] virtio_dev_match
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_dev_match+0x19/0x70
+ * [0] __device_attach_driver+0x34/0xa0
+ * [0] bus_for_each_drv+0x5f/0xb0
+ * [0] __device_attach+0xd4/0x130
+ * [0] bus_probe_device+0x85/0xa0
+ * [0] device_add+0x3be/0x650
+ * [0] register_virtio_device+0xb7/0x100
+ * [0] virtio_pci_probe+0xbd/0x150
+ * [0] local_pci_probe+0x3f/0x90
+ * [0] pci_device_probe+0xdd/0x170
+ * [0] really_probe+0x231/0x2d0
+ * [0] driver_probe_device+0x4a/0xe0
+ * [0] bus_for_each_drv+0x5f/0xb0
+ * [0] __device_attach+0xd4/0x130
+ * [0] pci_bus_add_device+0x45/0x90
+ * [0] pci_bus_add_devices+0x31/0x70
+ * [0] pciehp_configure_device+0x8e/0x130
+ * [0] pciehp_handle_presence_or_link_change+0x288/0x4d0
+ * [0] pciehp_ist+0x1ae/0x1c0
+ * [0] irq_thread_fn+0x1c/0x60
+ * [0] irq_thread+0x12f/0x190
+ * [0] kthread+0xf3/0x130
+ * [0] ret_from_fork+0x35/0x40
+ *
+ * struct bus_type virtio_bus.match = virtio_dev_match()
+ */
 static int virtio_dev_match(struct device *_dv, struct device_driver *_dr)
 {
 	unsigned int i;
@@ -92,6 +144,9 @@ static int virtio_dev_match(struct device *_dv, struct device_driver *_dr)
 	return 0;
 }
 
+/*
+ * struct bus_type virtio_bus.uevent = virtio_uevent()
+ */
 static int virtio_uevent(struct device *_dv, struct kobj_uevent_env *env)
 {
 	struct virtio_device *dev = dev_to_virtio(_dv);
@@ -120,6 +175,11 @@ void virtio_check_driver_offered_feature(const struct virtio_device *vdev,
 }
 EXPORT_SYMBOL_GPL(virtio_check_driver_offered_feature);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|189| <<virtio_config_changed>> __virtio_config_changed(dev);
+ *   - drivers/virtio/virtio.c|207| <<virtio_config_enable>> __virtio_config_changed(dev);
+ */
 static void __virtio_config_changed(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
@@ -130,6 +190,13 @@ static void __virtio_config_changed(struct virtio_device *dev)
 		drv->config_changed(dev);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|72| <<vp_config_changed>> virtio_config_changed(&vp_dev->vdev);
+ *   - drivers/virtio/virtio_mmio.c|300| <<vm_interrupt>> virtio_config_changed(&vm_dev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1076| <<virtio_ccw_int_handler>> virtio_config_changed(&vcdev->vdev);
+ *   - drivers/misc/mic/vop/vop_main.c|548| <<_vop_handle_config_change>> virtio_config_changed(&vdev->vdev);
+ */
 void virtio_config_changed(struct virtio_device *dev)
 {
 	unsigned long flags;
@@ -140,6 +207,11 @@ void virtio_config_changed(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_config_changed);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|405| <<virtio_dev_remove>> virtio_config_disable(dev);
+ *   - drivers/virtio/virtio.c|531| <<virtio_device_freeze>> virtio_config_disable(dev);
+ */
 void virtio_config_disable(struct virtio_device *dev)
 {
 	spin_lock_irq(&dev->config_lock);
@@ -148,6 +220,11 @@ void virtio_config_disable(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_config_disable);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|367| <<virtio_dev_probe>> virtio_config_enable(dev);
+ *   - drivers/virtio/virtio.c|583| <<virtio_device_restore>> virtio_config_enable(dev);
+ */
 void virtio_config_enable(struct virtio_device *dev)
 {
 	spin_lock_irq(&dev->config_lock);
@@ -161,6 +238,13 @@ EXPORT_SYMBOL_GPL(virtio_config_enable);
 
 void virtio_add_status(struct virtio_device *dev, unsigned int status)
 {
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	dev->config->set_status(dev, dev->config->get_status(dev) | status);
 }
 EXPORT_SYMBOL_GPL(virtio_add_status);
@@ -187,6 +271,50 @@ int virtio_finalize_features(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_finalize_features);
 
+/*
+ * 初始化的时候:
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] bus_probe_device
+ * [0] device_add
+ * [0] register_virtio_device
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0]ret_from_fork
+ *
+ * struct bus_type virtio_bus.probe = virtio_dev_probe()
+ */
 static int virtio_dev_probe(struct device *_d)
 {
 	int err, i;
@@ -262,6 +390,30 @@ static int virtio_dev_probe(struct device *_d)
 
 }
 
+/*
+ * hotplug的时候:
+ * [0] virtio_dev_remove
+ * [0] device_release_driver_internal
+ * [0] bus_remove_device
+ * [0] device_del
+ * [0] device_unregister
+ * [0] unregister_virtio_device
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct bus_type virtio_bus.remove = virtio_dev_remove()
+ */
 static int virtio_dev_remove(struct device *_d)
 {
 	struct virtio_device *dev = dev_to_virtio(_d);
@@ -312,8 +464,21 @@ EXPORT_SYMBOL_GPL(unregister_virtio_driver);
  *
  * Returns: 0 on suceess, -error on failure
  */
+/*
+ * 其实就被一个用的到的调用:
+ *   - drivers/virtio/virtio_pci_common.c|624| <<virtio_pci_probe>> rc = register_virtio_device(&vp_dev->vdev);
+ *
+ * 其他的用不到:
+ *   - drivers/virtio/virtio_mmio.c|601| <<virtio_mmio_probe>> rc = register_virtio_device(&vm_dev->vdev);
+ *   - drivers/misc/mic/vop/vop_main.c|501| <<_vop_add_device>> ret = register_virtio_device(&vdev->vdev);
+ *   - drivers/remoteproc/remoteproc_virtio.c|328| <<rproc_add_virtio_dev>> ret = register_virtio_device(vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1261| <<virtio_ccw_online>> ret = register_virtio_device(&vcdev->vdev);
+ */
 int register_virtio_device(struct virtio_device *dev)
 {
+	/*
+	 * 参数dev被包含在struct virtio_pci_device
+	 */
 	int err;
 
 	dev->dev.bus = &virtio_bus;
@@ -333,6 +498,13 @@ int register_virtio_device(struct virtio_device *dev)
 
 	/* We always start by resetting the device, in case a previous
 	 * driver messed it up.  This also tests that code path a little. */
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	dev->config->reset(dev);
 
 	/* Acknowledge that we've seen the device. */
@@ -364,6 +536,11 @@ void unregister_virtio_device(struct virtio_device *dev)
 EXPORT_SYMBOL_GPL(unregister_virtio_device);
 
 #ifdef CONFIG_PM_SLEEP
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|467| <<virtio_pci_freeze>> ret = virtio_device_freeze(&vp_dev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1320| <<virtio_ccw_freeze>> return virtio_device_freeze(&vcdev->vdev);
+ */
 int virtio_device_freeze(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
@@ -379,6 +556,11 @@ int virtio_device_freeze(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_device_freeze);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|485| <<virtio_pci_restore>> return virtio_device_restore(&vp_dev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1332| <<virtio_ccw_restore>> return virtio_device_restore(&vcdev->vdev);
+ */
 int virtio_device_restore(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
diff --git a/drivers/virtio/virtio_pci_common.c b/drivers/virtio/virtio_pci_common.c
index 465a6f5..1a07712 100644
--- a/drivers/virtio/virtio_pci_common.c
+++ b/drivers/virtio/virtio_pci_common.c
@@ -19,6 +19,21 @@
 
 #include "virtio_pci_common.h"
 
+/*
+ * 2个virtio-blk(每个2个queue)的例子:
+ *  24:          0          0   PCI-MSI 49152-edge      virtio0-config
+ *  25:       1245          0   PCI-MSI 49153-edge      virtio0-req.0
+ *  26:          0       1617   PCI-MSI 49154-edge      virtio0-req.1
+ *  27:          0          0   PCI-MSI 65536-edge      virtio1-config
+ *  28:         35          0   PCI-MSI 65537-edge      virtio1-req.0
+ *  29:          0         34   PCI-MSI 65538-edge      virtio1-req.1
+ *
+ * legacy的例子:
+ *  24:          0          0   PCI-MSI 65536-edge      virtio0-config
+ *  25:       1547          0   PCI-MSI 65537-edge      virtio0-req.0
+ *  26:          0       1286   PCI-MSI 65538-edge      virtio0-req.1
+ */
+
 static bool force_legacy = false;
 
 #if IS_ENABLED(CONFIG_VIRTIO_PCI_LEGACY)
@@ -28,11 +43,35 @@ MODULE_PARM_DESC(force_legacy,
 #endif
 
 /* wait for pending irq handlers */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_legacy.c|102| <<vp_reset>> vp_synchronize_vectors(vdev);
+ *   - drivers/virtio/virtio_pci_modern.c|297| <<vp_reset>> vp_synchronize_vectors(vdev);
+ *
+ * 等待所有属于这个设备的pending的irq handler完成
+ */
 void vp_synchronize_vectors(struct virtio_device *vdev)
 {
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 把struct virtio_device转换成struct virtio_pci_device
+	 */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	int i;
 
+	/*
+	 * synchronize_irq():
+	 *   This function waits for any pending IRQ handlers for this interrupt
+	 *   to complete before returning. If you use this function while
+	 *   holding a resource the IRQ handler may need you will deadlock.
+	 *   This function may be called - with care - from IRQ context.
+	 */
+
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|283| <<vp_del_vqs>> vp_dev->intx_enabled = 0;
+	 *   - drivers/virtio/virtio_pci_common.c|401| <<vp_find_vqs_intx>> vp_dev->intx_enabled = 1;
+	 */
 	if (vp_dev->intx_enabled)
 		synchronize_irq(vp_dev->pci_dev->irq);
 
@@ -41,15 +80,38 @@ void vp_synchronize_vectors(struct virtio_device *vdev)
 }
 
 /* the notify function used when creating a virt queue */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_legacy.c|141| <<setup_vq>> vp_notify, callback, name);
+ *   - drivers/virtio/virtio_pci_modern.c|347| <<setup_vq>> vp_notify, callback, name);
+ *
+ * 把virtqueue->index写入virtqueue->priv,通知backend
+ */
 bool vp_notify(struct virtqueue *vq)
 {
 	/* we write the queue's selector into the notification register to
 	 * signal the other end */
+	/*
+	 * priv设置的地方:
+	 *   - drivers/virtio/virtio_pci_legacy.c|157| <<setup_vq>> vq->priv = (void __force *)vp_dev->ioaddr + VIRTIO_PCI_QUEUE_NOTIFY;
+	 *   - drivers/virtio/virtio_pci_modern.c|372| <<setup_vq>> vq->priv = (void __force *)vp_dev->notify_base +
+	 *                                                                  off * vp_dev->notify_offset_multiplier;
+	 *   - drivers/virtio/virtio_pci_modern.c|375| <<setup_vq>> vq->priv = (void __force *)map_capability(vp_dev->pci_dev,
+	 *                                                                                    vp_dev->notify_map_cap, 2, 2,
+	 *                                                                                    off * vp_dev->notify_offset_multiplier, 2,
+	 *                                                                                    NULL);
+	 *   - drivers/virtio/virtio_mmio.c|438| <<vm_setup_vq>> vq->priv = info;
+	 */
 	iowrite16(vq->index, (void __iomem *)vq->priv);
 	return true;
 }
 
 /* Handle a configuration change: Tell driver if it wants to know. */
+/*
+ * 作为中断处理的一个实现,被以下调用或使用:
+ *   - drivers/virtio/virtio_pci_common.c|157| <<vp_interrupt>> vp_config_changed(irq, opaque);
+ *   - drivers/virtio/virtio_pci_common.c|208| <<vp_request_msix_vectors>> vp_config_changed, 0, vp_dev->msix_names[v],
+ */
 static irqreturn_t vp_config_changed(int irq, void *opaque)
 {
 	struct virtio_pci_device *vp_dev = opaque;
@@ -59,6 +121,11 @@ static irqreturn_t vp_config_changed(int irq, void *opaque)
 }
 
 /* Notify all virtqueues on an interrupt. */
+/*
+ * 作为中断处理的一个实现,被以下调用或使用:
+ *   - drivers/virtio/virtio_pci_common.c|159| <<vp_interrupt>> return vp_vring_interrupt(irq, opaque);
+ *   - drivers/virtio/virtio_pci_common.c|227| <<vp_request_msix_vectors>> vp_vring_interrupt, 0, vp_dev->msix_names[v],
+ */
 static irqreturn_t vp_vring_interrupt(int irq, void *opaque)
 {
 	struct virtio_pci_device *vp_dev = opaque;
@@ -82,6 +149,13 @@ static irqreturn_t vp_vring_interrupt(int irq, void *opaque)
  * the callback may notify the host which results in the host attempting to
  * raise an interrupt that we would then mask once we acknowledged the
  * interrupt. */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|370| <<vp_find_vqs_intx>> err = request_irq(vp_dev->pci_dev->irq, vp_interrupt, IRQF_SHARED,
+ *                                                                                    dev_name(&vdev->dev), vp_dev);
+ *
+ * 只用来作为intx的中断处理函数(在request_irq注册)
+ */
 static irqreturn_t vp_interrupt(int irq, void *opaque)
 {
 	struct virtio_pci_device *vp_dev = opaque;
@@ -102,15 +176,37 @@ static irqreturn_t vp_interrupt(int irq, void *opaque)
 	return vp_vring_interrupt(irq, opaque);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|336| <<vp_find_vqs_msix>> err = vp_request_msix_vectors(vdev, nvectors, per_vq_vectors,
+ *
+ * 核心思想是分配nvectors个vector(irq)
+ * 第一个给config用, 中断函数是vp_config_changed()
+ * 如果per_vq_vectors=false, 后面的给所有的queue用, 中断函数是vp_vring_interrupt()
+ *
+ * 函数结束的时候virtio_pci_device->msix_used_vectors是实际用了的vector的数量
+ */
 static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 				   bool per_vq_vectors, struct irq_affinity *desc)
 {
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 把struct virtio_device转换成struct virtio_pci_device
+	 */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	const char *name = dev_name(&vp_dev->vdev.dev);
 	unsigned flags = PCI_IRQ_MSIX;
 	unsigned i, v;
 	int err = -ENOMEM;
 
+	/*
+	 * Number of available vectors
+	 *
+	 * 从vp_find_vqs_msix()进来的时候, nvectors是需要用到的vector的数量
+	 * 此时nvectors是一共需要的vector的数量
+	 * 1. 如果不是per-queue, 则一共2个: 一个给所有queue, 一个给config
+	 * 2. 如果是per-queue, 每个queue一个, 然后多一个给config
+	 */
 	vp_dev->msix_vectors = nvectors;
 
 	vp_dev->msix_names = kmalloc_array(nvectors,
@@ -133,6 +229,9 @@ static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 		desc->pre_vectors++; /* virtio config vector */
 	}
 
+	/*
+	 * 分配中断 vector!!!
+	 */
 	err = pci_alloc_irq_vectors_affinity(vp_dev->pci_dev, nvectors,
 					     nvectors, flags, desc);
 	if (err < 0)
@@ -140,16 +239,49 @@ static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 	vp_dev->msix_enabled = 1;
 
 	/* Set the vector used for configuration */
+	/*
+	 * Vectors allocated, excluding per-vq vectors if any
+	 *
+	 * 在以下被修改, 只在vp_request_msix_vectors()被增加:
+	 *   - drivers/virtio/virtio_pci_common.c|257| <<vp_request_msix_vectors>> ++vp_dev->msix_used_vectors;
+	 *   - drivers/virtio/virtio_pci_common.c|290| <<vp_request_msix_vectors>> ++vp_dev->msix_used_vectors;
+	 *   - drivers/virtio/virtio_pci_common.c|431| <<vp_del_vqs>> vp_dev->msix_used_vectors = 0;
+	 *
+	 * 所以开始的时候应该是0??
+	 */
 	v = vp_dev->msix_used_vectors;
+	/*
+	 * 第一个中断(vector)给config, 中断函数是vp_config_changed()
+	 */
 	snprintf(vp_dev->msix_names[v], sizeof *vp_dev->msix_names,
 		 "%s-config", name);
+	/*
+	 * pci_irq_vector(): return Linux IRQ number of a device vector
+	 */
 	err = request_irq(pci_irq_vector(vp_dev->pci_dev, v),
 			  vp_config_changed, 0, vp_dev->msix_names[v],
 			  vp_dev);
 	if (err)
 		goto error;
+	/*
+	 * 在以下被修改, 只在vp_request_msix_vectors()被增加:
+	 *   - drivers/virtio/virtio_pci_common.c|257| <<vp_request_msix_vectors>> ++vp_dev->msix_used_vectors;
+	 *   - drivers/virtio/virtio_pci_common.c|290| <<vp_request_msix_vectors>> ++vp_dev->msix_used_vectors;
+	 *   - drivers/virtio/virtio_pci_common.c|431| <<vp_del_vqs>> vp_dev->msix_used_vectors = 0;
+	 */
 	++vp_dev->msix_used_vectors;
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的vp_config_vector()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|263| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+	 *   - drivers/virtio/virtio_pci_modern.c|709| <<virtio_pci_modern_probe>> vp_dev->config_vector = vp_config_vector;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|224| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+	 *   - drivers/virtio/virtio_pci_common.c|344| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+	 *
+	 * 确认激活vector???
+	 */
 	v = vp_dev->config_vector(vp_dev, v);
 	/* Verify we had enough resources to assign the vector */
 	if (v == VIRTIO_MSI_NO_VECTOR) {
@@ -157,6 +289,9 @@ static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 		goto error;
 	}
 
+	/*
+	 * 如果不是per-queue, 刚才剩下的vector给per-queue用, 中断函数是vp_vring_interrupt()
+	 */
 	if (!per_vq_vectors) {
 		/* Shared vector for all VQs */
 		v = vp_dev->msix_used_vectors;
@@ -174,6 +309,19 @@ static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|385| <<vp_find_vqs_msix>> vqs[i] = vp_setup_vq(vdev, i, callbacks[i], names[i],
+ *   - drivers/virtio/virtio_pci_common.c|442| <<vp_find_vqs_intx>> vqs[i] = vp_setup_vq(vdev, i, callbacks[i], names[i],
+ *
+ * 不管是legacy还是modern
+ * 这个函数针对某一个queue
+ * 分配并初始化vring_virtqueue, 返回其包含的virtqueue
+ * 会分配ring buffer, 初始化包含的vring和virtqueue
+ * 把ring buffer的地址告诉backend!
+ * 为这个queue设置msi vector为msix_vec
+ * 这个函数还会分配一个virtio_pci_vq_info,初始化设置为virtio_pci_device->vqs[index]
+ */
 static struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,
 				     void (*callback)(struct virtqueue *vq),
 				     const char *name,
@@ -189,6 +337,22 @@ static struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,
 	if (!info)
 		return ERR_PTR(-ENOMEM);
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的setup_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|273| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|719| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+	 *                                                                                   msix_vec);
+	 *
+	 * 不管是legacy还是modern
+	 * 这个函数针对某一个queue
+	 * 分配并初始化vring_virtqueue, 返回其包含的virtqueue
+	 * 会分配ring buffer, 初始化包含的vring和virtqueue
+	 * 把ring buffer的地址告诉backend!
+	 * 为这个queue设置msi vector为msix_vec
+	 */
 	vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
 			      msix_vec);
 	if (IS_ERR(vq))
@@ -197,6 +361,9 @@ static struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,
 	info->vq = vq;
 	if (callback) {
 		spin_lock_irqsave(&vp_dev->lock, flags);
+		/*
+		 * 把这个函数内分配的virtio_pci_vq_info挂载到virtio_pci_device->virtqueues
+		 */
 		list_add(&info->node, &vp_dev->virtqueues);
 		spin_unlock_irqrestore(&vp_dev->lock, flags);
 	} else {
@@ -211,6 +378,24 @@ static struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,
 	return vq;
 }
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio_pci_common.c|307| <<vp_del_vqs>> vp_del_vq(vq);
+ *
+ * 删除某个virtuque, 从virtio_pci_device->virtqueues链表上删除virtio_pci_vq_info
+ *
+ * 如果是legacy:
+ * 针对某一个queue, 给定其virtio_pci_vq_info作为输入
+ * 如果用的msix, 告诉backend没有msi vector
+ * 告诉backend ring buffer的基地址是0
+ * 释放vring_virtqueue并在virtio_device->vqs链表移除
+ *
+ * 如果是modern:
+ * 针对某一个queue, 给定其virtio_pci_vq_info作为输入
+ * 如果用的msix, 告诉backend没有msi vector
+ * unmap通知backend的priv内存区域
+ * 释放vring_virtqueue并在virtio_device->vqs链表移除
+ */
 static void vp_del_vq(struct virtqueue *vq)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vq->vdev);
@@ -218,14 +403,42 @@ static void vp_del_vq(struct virtqueue *vq)
 	unsigned long flags;
 
 	spin_lock_irqsave(&vp_dev->lock, flags);
+	/*
+	 * 从virtio_pci_device->virtqueues链表上删除virtio_pci_vq_info
+	 */
 	list_del(&info->node);
 	spin_unlock_irqrestore(&vp_dev->lock, flags);
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的del_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|283| <<virtio_pci_legacy_probe>> vp_dev->del_vq = del_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|729| <<virtio_pci_modern_probe>> vp_dev->del_vq = del_vq;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+	 *
+	 * 如果是legacy:
+	 * 针对某一个queue, 给定其virtio_pci_vq_info作为输入
+	 * 如果用的msix, 告诉backend没有msi vector
+	 * 告诉backend ring buffer的基地址是0
+	 * 释放vring_virtqueue并在virtio_device->vqs链表移除
+	 *
+	 * 如果是modern:
+	 * 针对某一个queue, 给定其virtio_pci_vq_info作为输入
+	 * 如果用的msix, 告诉backend没有msi vector
+	 * unmap通知backend的priv内存区域
+	 * 释放vring_virtqueue并在virtio_device->vqs链表移除
+	 */
 	vp_dev->del_vq(info);
 	kfree(info);
 }
 
 /* the config->del_vqs() implementation */
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.del_vqs = vp_del_vqs()
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.del_vqs = vp_del_vqs()
+ * struct virtio_config_ops virtio_pci_config_ops.del_vqs = vp_del_vqs()
+ */
 void vp_del_vqs(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -261,6 +474,15 @@ void vp_del_vqs(struct virtio_device *vdev)
 
 	if (vp_dev->msix_enabled) {
 		/* Disable the vector used for configuration */
+		/*
+		 * 设置的地方 (legacy和modern用的不同的vp_config_vector()):
+		 *   - drivers/virtio/virtio_pci_legacy.c|263| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+		 *   - drivers/virtio/virtio_pci_modern.c|709| <<virtio_pci_modern_probe>> vp_dev->config_vector = vp_config_vector;
+		 *
+		 * 调用的地方:
+		 *   - drivers/virtio/virtio_pci_common.c|224| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+		 *   - drivers/virtio/virtio_pci_common.c|344| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+		 */
 		vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
 
 		pci_free_irq_vectors(vp_dev->pci_dev);
@@ -277,16 +499,29 @@ void vp_del_vqs(struct virtio_device *vdev)
 	vp_dev->vqs = NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|533| <<vp_find_vqs>> err = vp_find_vqs_msix(vdev, nvqs, vqs, callbacks, names, true, ctx, desc);
+ *   - drivers/virtio/virtio_pci_common.c|537| <<vp_find_vqs>> err = vp_find_vqs_msix(vdev, nvqs, vqs, callbacks, names, false, ctx, desc);
+ */
 static int vp_find_vqs_msix(struct virtio_device *vdev, unsigned nvqs,
 		struct virtqueue *vqs[], vq_callback_t *callbacks[],
 		const char * const names[], bool per_vq_vectors,
 		const bool *ctx,
 		struct irq_affinity *desc)
 {
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 把struct virtio_device转换成struct virtio_pci_device
+	 */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	u16 msix_vec;
 	int i, err, nvectors, allocated_vectors;
 
+	/*
+	 * vp_dev->vqs是struct virtio_pci_vq_info **vqs
+	 * 等于是分配了nvqs个指针
+	 */
 	vp_dev->vqs = kcalloc(nvqs, sizeof(*vp_dev->vqs), GFP_KERNEL);
 	if (!vp_dev->vqs)
 		return -ENOMEM;
@@ -302,13 +537,42 @@ static int vp_find_vqs_msix(struct virtio_device *vdev, unsigned nvqs,
 		nvectors = 2;
 	}
 
+	/*
+	 * 此时nvectors是一共需要的vector的数量
+	 * 1. 如果不是per-queue, 则一共2个: 一个给所有queue, 一个给config
+	 * 2. 如果是per-queue, 每个queue一个, 然后多一个给config
+	 */
+
+	/*
+	 * 核心思想是分配nvectors个vector(irq)
+	 * 第一个给config用, 中断函数是vp_config_changed()
+	 * 如果per_vq_vectors=false, 后面的给所有的queue用, 中断函数是vp_vring_interrupt()
+	 *
+	 * 函数结束的时候virtio_pci_device->msix_used_vectors是实际用了的vector的数量
+	 *
+	 * 如果per_vq_vectors=true, 下面才会继续为每个queue设置中断函数
+	 */
 	err = vp_request_msix_vectors(vdev, nvectors, per_vq_vectors,
 				      per_vq_vectors ? desc : NULL);
 	if (err)
 		goto error_find;
 
 	vp_dev->per_vq_vectors = per_vq_vectors;
+	/*
+	 * 在以下被修改, 只在vp_request_msix_vectors()被增加:
+	 *   - drivers/virtio/virtio_pci_common.c|257| <<vp_request_msix_vectors>> ++vp_dev->msix_used_vectors;
+	 *   - drivers/virtio/virtio_pci_common.c|290| <<vp_request_msix_vectors>> ++vp_dev->msix_used_vectors;
+	 *   - drivers/virtio/virtio_pci_common.c|431| <<vp_del_vqs>> vp_dev->msix_used_vectors = 0;
+	 *
+	 * 在vp_request_msix_vectors()结束的时候virtio_pci_device->msix_used_vectors是实际用了的vector的数量
+	 */
 	allocated_vectors = vp_dev->msix_used_vectors;
+
+	/*
+	 * 如果vp_dev->per_vq_vectors=true, 测试的此时vp_dev->msix_used_vectors=1,
+	 * 下面的for循环继续为每个queue设置中断函数vring_interrupt()
+	 */
+
 	for (i = 0; i < nvqs; ++i) {
 		if (!names[i]) {
 			vqs[i] = NULL;
@@ -351,6 +615,10 @@ static int vp_find_vqs_msix(struct virtio_device *vdev, unsigned nvqs,
 	return err;
 }
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio_pci_common.c|440| <<vp_find_vqs>> return vp_find_vqs_intx(vdev, nvqs, vqs, callbacks, names, ctx);
+ */
 static int vp_find_vqs_intx(struct virtio_device *vdev, unsigned nvqs,
 		struct virtqueue *vqs[], vq_callback_t *callbacks[],
 		const char * const names[], const bool *ctx)
@@ -390,6 +658,9 @@ static int vp_find_vqs_intx(struct virtio_device *vdev, unsigned nvqs,
 }
 
 /* the config->find_vqs() implementation */
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.find_vqs = vp_find_vqs()
+ */
 int vp_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 		struct virtqueue *vqs[], vq_callback_t *callbacks[],
 		const char * const names[], const bool *ctx,
@@ -409,6 +680,11 @@ int vp_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 	return vp_find_vqs_intx(vdev, nvqs, vqs, callbacks, names, ctx);
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.bus_name = vp_bus_name()
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.bus_name = vp_bus_name()
+ * struct virtio_config_ops virtio_pci_config_ops.bus_name = vp_bus_name()
+ */
 const char *vp_bus_name(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -421,6 +697,11 @@ const char *vp_bus_name(struct virtio_device *vdev)
  * - OR over all affinities for shared MSI
  * - ignore the affinity request if we're using INTX
  */
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.set_vq_affinity = vp_set_vq_affinity()
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.set_vq_affinity = vp_set_vq_affinity()
+ * struct virtio_config_ops virtio_pci_config_ops.set_vq_affinity = vp_set_vq_affinity()
+ */
 int vp_set_vq_affinity(struct virtqueue *vq, const struct cpumask *cpu_mask)
 {
 	struct virtio_device *vdev = vq->vdev;
@@ -445,6 +726,11 @@ int vp_set_vq_affinity(struct virtqueue *vq, const struct cpumask *cpu_mask)
 	return 0;
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.get_vq_affinity = vp_get_vq_affinity()
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.get_vq_affinity = vp_get_vq_affinity()
+ * struct virtio_config_ops virtio_pci_config_ops.get_vq_affinity = vp_get_vq_affinity()
+ */
 const struct cpumask *vp_get_vq_affinity(struct virtio_device *vdev, int index)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -458,6 +744,10 @@ const struct cpumask *vp_get_vq_affinity(struct virtio_device *vdev, int index)
 }
 
 #ifdef CONFIG_PM_SLEEP
+/*
+ * used only by:
+ *   - drivers/virtio/virtio_pci_common.c|544| <<global>> SET_SYSTEM_SLEEP_PM_OPS(virtio_pci_freeze, virtio_pci_restore)
+ */
 static int virtio_pci_freeze(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -471,6 +761,10 @@ static int virtio_pci_freeze(struct device *dev)
 	return ret;
 }
 
+/*
+ * used only by:
+ *   - drivers/virtio/virtio_pci_common.c|544| <<global>> SET_SYSTEM_SLEEP_PM_OPS(virtio_pci_freeze, virtio_pci_restore)
+ */
 static int virtio_pci_restore(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -485,6 +779,9 @@ static int virtio_pci_restore(struct device *dev)
 	return virtio_device_restore(&vp_dev->vdev);
 }
 
+/*
+ * struct pci_driver virtio_pci_driver.drive.pm = virtio_pci_pm_ops
+ */
 static const struct dev_pm_ops virtio_pci_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(virtio_pci_freeze, virtio_pci_restore)
 };
@@ -492,6 +789,9 @@ static const struct dev_pm_ops virtio_pci_pm_ops = {
 
 
 /* Qumranet donated their vendor ID for devices 0x1000 thru 0x10FF. */
+/*
+ * struct pci_driver virtio_pci_driver.id_table = virtio_pci_id_table
+ */
 static const struct pci_device_id virtio_pci_id_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_ANY_ID) },
 	{ 0 }
@@ -499,9 +799,19 @@ static const struct pci_device_id virtio_pci_id_table[] = {
 
 MODULE_DEVICE_TABLE(pci, virtio_pci_id_table);
 
+/*
+ * used only by:
+ *   - drivers/virtio/virtio_pci_common.c|597| <<virtio_pci_probe>> vp_dev->vdev.dev.release = virtio_pci_release_dev;
+ *
+ * struct virtio_device包含struct device
+ * struct virtio_pci_device包含struct virtio_device
+ * 于是根据struct device找到struct virtio_pci_device并释放
+ */
 static void virtio_pci_release_dev(struct device *_d)
 {
+	/* struct virtio_device包含struct device */
 	struct virtio_device *vdev = dev_to_virtio(_d);
+	/* struct virtio_pci_device包含struct virtio_device */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 
 	/* As struct device is a kobject, it's not safe to
@@ -510,6 +820,43 @@ static void virtio_pci_release_dev(struct device *_d)
 	kfree(vp_dev);
 }
 
+/*
+ * 初始化的时候:
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct pci_driver virtio_pci_driver.probe = virtio_pci_probe()
+ */
 static int virtio_pci_probe(struct pci_dev *pci_dev,
 			    const struct pci_device_id *id)
 {
@@ -517,18 +864,42 @@ static int virtio_pci_probe(struct pci_dev *pci_dev,
 	int rc;
 
 	/* allocate our structure and fill it out */
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 */
 	vp_dev = kzalloc(sizeof(struct virtio_pci_device), GFP_KERNEL);
+	/*
+	 * qemu是否可以回收干净??
+	 */
 	if (!vp_dev)
 		return -ENOMEM;
 
+	/* 把pci_dev->dev->driver_data设置为vp_dev (virtio_pci_device) */
 	pci_set_drvdata(pci_dev, vp_dev);
+	/*
+	 * vp_dev->vdev是struct virtio_device
+	 * vp_dev->vdev.dev是struct device
+	 */
 	vp_dev->vdev.dev.parent = &pci_dev->dev;
+	/*
+	 * struct virtio_device包含struct device
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 于是根据struct device找到struct virtio_pci_device并释放
+	 */
 	vp_dev->vdev.dev.release = virtio_pci_release_dev;
 	vp_dev->pci_dev = pci_dev;
 	INIT_LIST_HEAD(&vp_dev->virtqueues);
 	spin_lock_init(&vp_dev->lock);
 
 	/* enable the device */
+	/*
+	 * Initialize device before it's used by a driver. Ask low-level code
+	 *  to enable I/O and memory. Wake up the device if it was suspended.
+	 *  Beware, this function can fail.
+	 *
+	 *  Note we don't actually enable the device many times if we call
+	 *  this function repeatedly (we just increment the count).
+	 */
 	rc = pci_enable_device(pci_dev);
 	if (rc)
 		goto err_enable_device;
@@ -541,6 +912,11 @@ static int virtio_pci_probe(struct pci_dev *pci_dev,
 		if (rc)
 			goto err_probe;
 	} else {
+		/*
+		 * 先尝试modern,
+		 * 如果在qemu的-device的命令行加入"disable-modern=true",则会rc=-19
+		 * 然后调用legacy
+		 */
 		rc = virtio_pci_modern_probe(vp_dev);
 		if (rc == -ENODEV)
 			rc = virtio_pci_legacy_probe(vp_dev);
@@ -572,6 +948,23 @@ static int virtio_pci_probe(struct pci_dev *pci_dev,
 	return rc;
 }
 
+/*
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct pci_driver virtio_pci_driver.remove = virtio_pci_remove()
+ */
 static void virtio_pci_remove(struct pci_dev *pci_dev)
 {
 	struct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);
@@ -590,6 +983,15 @@ static void virtio_pci_remove(struct pci_dev *pci_dev)
 	put_device(dev);
 }
 
+/*
+ * called by:
+ *   - drivers/pci/pci-sysfs.c|608| <<sriov_numvfs_store>> ret = pdev->driver->sriov_configure(pdev, 0);
+ *   - drivers/pci/pci-sysfs.c|620| <<sriov_numvfs_store>> ret = pdev->driver->sriov_configure(pdev, num_vfs);
+ *
+ * struct pci_driver virtio_pci_driver.sriov_configure = virtio_pci_sriov_configure()
+ *
+ * 没看到怎么使用
+ */
 static int virtio_pci_sriov_configure(struct pci_dev *pci_dev, int num_vfs)
 {
 	struct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);
diff --git a/drivers/virtio/virtio_pci_common.h b/drivers/virtio/virtio_pci_common.h
index 0227100..6e307d3 100644
--- a/drivers/virtio/virtio_pci_common.h
+++ b/drivers/virtio/virtio_pci_common.h
@@ -49,14 +49,41 @@ struct virtio_pci_device {
 
 	/* In legacy mode, these two point to within ->legacy. */
 	/* Where to read and clear interrupt */
+	/*
+	 * 在以下被map(modern的capability是VIRTIO_PCI_CAP_ISR_CFG):
+	 *   - drivers/virtio/virtio_pci_legacy.c|414| <<virtio_pci_legacy_probe>> vp_dev->isr = vp_dev->ioaddr + VIRTIO_PCI_ISR;
+	 *   - drivers/virtio/virtio_pci_modern.c|774| <<virtio_pci_modern_probe>> vp_dev->isr = map_capability(pci_dev, isr, sizeof(u8), 1,
+	 */
 	u8 __iomem *isr;
 
 	/* Modern only fields */
 	/* The IO mapping for the PCI config space (non-legacy mode) */
+	/*
+	 * 在以下被map为VIRTIO_PCI_CAP_COMMON_CFG:
+	 *   - drivers/virtio/virtio_pci_modern.c|768| <<virtio_pci_modern_probe>>
+	 *            vp_dev->common = map_capability(pci_dev, common,
+	 *                                            sizeof(struct virtio_pci_common_cfg), 4,
+	 *                                            0, sizeof(struct virtio_pci_common_cfg),
+	 *                                            NULL);
+	 */
 	struct virtio_pci_common_cfg __iomem *common;
 	/* Device-specific data (non-legacy mode)  */
+	/*
+	 * 在以下被map为VIRTIO_PCI_CAP_DEVICE_CFG:
+	 * drivers/virtio/virtio_pci_modern.c|773| <<virtio_pci_modern_probe>>
+	 *                         vp_dev->device = map_capability(pci_dev, device, 0, 4,
+	 *                                                         0, PAGE_SIZE,
+	 *                                                         &vp_dev->device_len);
+	 */
 	void __iomem *device;
 	/* Base of vq notifications (non-legacy mode). */
+	/*
+	 * 在以下被map为VIRTIO_PCI_CAP_NOTIFY_CFG:
+	 *   - drivers/virtio/virtio_pci_modern.c|809| <<virtio_pci_modern_probe>>
+	 *                   vp_dev->notify_base = map_capability(pci_dev, notify, 2, 2,
+	 *                                                        0, notify_length,
+	 *                                                        &vp_dev->notify_len);
+	 */
 	void __iomem *notify_base;
 
 	/* So we can sanity-check accesses. */
@@ -73,6 +100,14 @@ struct virtio_pci_device {
 
 	/* Legacy only field */
 	/* the IO mapping for the PCI config space */
+	/*
+	 * 在virtio_pci_legacy_probe()用以下函数获得:
+	 *   - vp_dev->ioaddr = pci_iomap(pci_dev, 0, 0);
+	 *
+	 * region 0   --  virtio legacy io bar
+	 * region 1   --  msi-x bar
+	 * region 4+5 --  virtio modern memory (64bit) bar
+	 */
 	void __iomem *ioaddr;
 
 	/* a list of queues so we can dispatch IRQs */
@@ -83,7 +118,20 @@ struct virtio_pci_device {
 	struct virtio_pci_vq_info **vqs;
 
 	/* MSI-X support */
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|171| <<vp_request_msix_vectors>> vp_dev->msix_enabled = 1;
+	 *   - drivers/virtio/virtio_pci_common.c|298| <<vp_del_vqs>> vp_dev->msix_enabled = 0;
+	 *
+	 * 应该是在qemu的参数设置"-device virtio-blk-pci"的"vectors="设置
+	 * 如果vectors的数目不够,就不用msix了
+	 */
 	int msix_enabled;
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|283| <<vp_del_vqs>> vp_dev->intx_enabled = 0;
+	 *   - drivers/virtio/virtio_pci_common.c|401| <<vp_find_vqs_intx>> vp_dev->intx_enabled = 1;
+	 */
 	int intx_enabled;
 	cpumask_var_t *msix_affinity_masks;
 	/* Name strings for interrupts. This size should be enough,
@@ -92,11 +140,26 @@ struct virtio_pci_device {
 	/* Number of available vectors */
 	unsigned msix_vectors;
 	/* Vectors allocated, excluding per-vq vectors if any */
+	/*
+	 * 在以下被修改, 只在vp_request_msix_vectors()被增加:
+	 *   - drivers/virtio/virtio_pci_common.c|257| <<vp_request_msix_vectors>> ++vp_dev->msix_used_vectors;
+	 *   - drivers/virtio/virtio_pci_common.c|290| <<vp_request_msix_vectors>> ++vp_dev->msix_used_vectors;
+	 *   - drivers/virtio/virtio_pci_common.c|431| <<vp_del_vqs>> vp_dev->msix_used_vectors = 0;
+	 */
 	unsigned msix_used_vectors;
 
 	/* Whether we have vector per vq */
 	bool per_vq_vectors;
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的setup_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|273| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|719| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+	 * 
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+	 *                                                                                   msix_vec);
+	 */
 	struct virtqueue *(*setup_vq)(struct virtio_pci_device *vp_dev,
 				      struct virtio_pci_vq_info *info,
 				      unsigned idx,
@@ -104,8 +167,25 @@ struct virtio_pci_device {
 				      const char *name,
 				      bool ctx,
 				      u16 msix_vec);
+	/*
+	 * 设置的地方 (legacy和modern用的不同的del_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|283| <<virtio_pci_legacy_probe>> vp_dev->del_vq = del_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|729| <<virtio_pci_modern_probe>> vp_dev->del_vq = del_vq;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+	 */
 	void (*del_vq)(struct virtio_pci_vq_info *info);
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的vp_config_vector()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|263| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+	 *   - drivers/virtio/virtio_pci_modern.c|709| <<virtio_pci_modern_probe>> vp_dev->config_vector = vp_config_vector;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|224| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+	 *   - drivers/virtio/virtio_pci_common.c|344| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+	 */
 	u16 (*config_vector)(struct virtio_pci_device *vp_dev, u16 vector);
 };
 
@@ -118,6 +198,10 @@ enum {
 };
 
 /* Convert a generic virtio device to our structure */
+/*
+ * struct virtio_pci_device包含struct virtio_device
+ * 把struct virtio_device转换成struct virtio_pci_device
+ */
 static struct virtio_pci_device *to_vp_device(struct virtio_device *vdev)
 {
 	return container_of(vdev, struct virtio_pci_device, vdev);
diff --git a/drivers/virtio/virtio_pci_legacy.c b/drivers/virtio/virtio_pci_legacy.c
index de062fb..96b57d6 100644
--- a/drivers/virtio/virtio_pci_legacy.c
+++ b/drivers/virtio/virtio_pci_legacy.c
@@ -20,16 +20,44 @@
 #include "virtio_pci_common.h"
 
 /* virtio config->get_features() implementation */
+/*
+ * called only by:
+ *   - drivers/virtio/virtio.c|331| <<virtio_dev_probe>> device_features = dev->config->get_features(dev);
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.get_features = vp_get_features()
+ *
+ * 从bar0读取VIRTIO_PCI_HOST_FEATURES
+ */
 static u64 vp_get_features(struct virtio_device *vdev)
 {
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 把struct virtio_device转换成struct virtio_pci_device
+	 */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 
 	/* When someone needs more than 32 feature bits, we'll need to
 	 * steal a bit to indicate that the rest are somewhere else. */
+	/*
+	 * vp_dev->ioaddr是在virtio_pci_legacy_probe()用以下获得的:
+	 *   - vp_dev->ioaddr = pci_iomap(pci_dev, 0, 0);
+	 *
+	 * region 0   --  virtio legacy io bar
+	 * region 1   --  msi-x bar
+	 * region 4+5 --  virtio modern memory (64bit) bar
+	 */
 	return ioread32(vp_dev->ioaddr + VIRTIO_PCI_HOST_FEATURES);
 }
 
 /* virtio config->finalize_features() implementation */
+/*
+ * called only by:
+ *   -  drivers/virtio/virtio.c|254| <<virtio_finalize_features>> int ret = dev->config->finalize_features(dev);
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.finalize_features = vp_finalize_features()
+ *
+ * 核心思想是把virtio_device->features写入bar0的VIRTIO_PCI_GUEST_FEATURES
+ */
 static int vp_finalize_features(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -41,16 +69,42 @@ static int vp_finalize_features(struct virtio_device *vdev)
 	BUG_ON((u32)vdev->features != vdev->features);
 
 	/* We only support 32 feature bits. */
+	/*
+	 * vp_dev->ioaddr是在virtio_pci_legacy_probe()用以下获得的:
+	 *   - vp_dev->ioaddr = pci_iomap(pci_dev, 0, 0);
+	 *
+	 * region 0   --  virtio legacy io bar
+	 * region 1   --  msi-x bar
+	 * region 4+5 --  virtio modern memory (64bit) bar
+	 */
 	iowrite32(vdev->features, vp_dev->ioaddr + VIRTIO_PCI_GUEST_FEATURES);
 
 	return 0;
 }
 
 /* virtio config->get() implementation */
+/*
+ * called by:
+ *   - include/linux/virtio_config.h|364| <<__virtio_cread_many>> vdev->config->get(vdev, offset + bytes * i,
+ *   - include/linux/virtio_config.h|382| <<virtio_cread8>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+ *   - include/linux/virtio_config.h|396| <<virtio_cread16>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+ *   - include/linux/virtio_config.h|411| <<virtio_cread32>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+ *   - net/vmw_vsock/virtio_transport.c|428| <<virtio_vsock_update_guest_cid>> vdev->config->get(vdev, offsetof(struct virtio_vsock_config, guest_cid),
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.get = vp_get()
+ *
+ * 获得bar0中offset指向的len大小的配置写入输出的buf
+ * offset是从bar0中的device specific configuration中的
+ */
 static void vp_get(struct virtio_device *vdev, unsigned offset,
 		   void *buf, unsigned len)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
+	/*
+	 * VIRTIO_PCI_CONFIG():
+	 *   如果virtio_pci_device->msix_enabled=true返回24, 否则返回20
+	 *   如果virtio_pci_device->msix_enabled则支持VIRTIO_MSI_CONFIG_VECTOR和VIRTIO_MSI_QUEUE_VECTOR
+	 */
 	void __iomem *ioaddr = vp_dev->ioaddr +
 				VIRTIO_PCI_CONFIG(vp_dev) + offset;
 	u8 *ptr = buf;
@@ -62,10 +116,27 @@ static void vp_get(struct virtio_device *vdev, unsigned offset,
 
 /* the config->set() implementation.  it's symmetric to the config->get()
  * implementation */
+/*
+ * called by:
+ *   - include/linux/virtio_config.h|389| <<virtio_cwrite8>> vdev->config->set(vdev, offset, &val, sizeof(val));
+ *   - include/linux/virtio_config.h|404| <<virtio_cwrite16>> vdev->config->set(vdev, offset, &val, sizeof(val));
+ *   - include/linux/virtio_config.h|419| <<virtio_cwrite32>> vdev->config->set(vdev, offset, &val, sizeof(val));
+ *   - include/linux/virtio_config.h|434| <<virtio_cwrite64>> vdev->config->set(vdev, offset, &val, sizeof(val));
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.set = vp_set()
+ *
+ * 把buf(len大小)写入获得bar0中offset指向的地址
+ * offset是从bar0中的device specific configuration中的
+ */
 static void vp_set(struct virtio_device *vdev, unsigned offset,
 		   const void *buf, unsigned len)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
+	/*
+	 * VIRTIO_PCI_CONFIG():
+	 *   如果virtio_pci_device->msix_enabled=true返回24, 否则返回20
+	 *   如果virtio_pci_device->msix_enabled则支持VIRTIO_MSI_CONFIG_VECTOR和VIRTIO_MSI_QUEUE_VECTOR
+	 */
 	void __iomem *ioaddr = vp_dev->ioaddr +
 				VIRTIO_PCI_CONFIG(vp_dev) + offset;
 	const u8 *ptr = buf;
@@ -76,12 +147,36 @@ static void vp_set(struct virtio_device *vdev, unsigned offset,
 }
 
 /* config->{get,set}_status() implementations */
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|31| <<status_show>> return sprintf(buf, "0x%08x\n", dev->config->get_status(dev));
+ *   - drivers/virtio/virtio.c|248| <<virtio_add_status>> dev->config->set_status(dev, dev->config->get_status(dev) | status);
+ *   - drivers/virtio/virtio.c|264| <<virtio_finalize_features>> status = dev->config->get_status(dev);
+ *   - drivers/virtio/virtio.c|378| <<virtio_dev_probe>> if (!(dev->config->get_status(dev) & VIRTIO_CONFIG_S_DRIVER_OK))
+ *   - drivers/virtio/virtio.c|427| <<virtio_dev_remove>> WARN_ON_ONCE(dev->config->get_status(dev));
+ *   - drivers/virtio/virtio.c|550| <<virtio_device_freeze>> dev->failed = dev->config->get_status(dev) & VIRTIO_CONFIG_S_FAILED;
+ *   - drivers/virtio/virtio_pci_common.c|862| <<virtio_pci_sriov_configure>> if (!(vdev->config->get_status(vdev) & VIRTIO_CONFIG_S_DRIVER_OK))
+ *   - include/linux/virtio_config.h|220| <<virtio_device_ready>> unsigned status = dev->config->get_status(dev);
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.get_status = vp_get_status()
+ *
+ * 读取返回bar0中的VIRTIO_PCI_STATUS
+ */
 static u8 vp_get_status(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	return ioread8(vp_dev->ioaddr + VIRTIO_PCI_STATUS);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|248| <<virtio_add_status>> dev->config->set_status(dev, dev->config->get_status(dev) | status);
+ *   - include/linux/virtio_config.h|249| <<virtio_device_ready>> dev->config->set_status(dev, status | VIRTIO_CONFIG_S_DRIVER_OK);
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.set_status = vp_set_status()
+ *
+ * 写入bar0中的VIRTIO_PCI_STATUS
+ */
 static void vp_set_status(struct virtio_device *vdev, u8 status)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -90,6 +185,35 @@ static void vp_set_status(struct virtio_device *vdev, u8 status)
 	iowrite8(status, vp_dev->ioaddr + VIRTIO_PCI_STATUS);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|508| <<register_virtio_device>> dev->config->reset(dev);
+ *   - drivers/virtio/virtio.c|571| <<virtio_device_restore>> dev->config->reset(dev);
+ *   - drivers/block/virtio_blk.c|907| <<virtblk_remove>> vdev->config->reset(vdev);
+ *   - drivers/block/virtio_blk.c|929| <<virtblk_freeze>> vdev->config->reset(vdev);
+ *   - drivers/scsi/virtio_scsi.c|781| <<virtscsi_remove_vqs>> vdev->config->reset(vdev);
+ *   - drivers/net/virtio_net.c|3040| <<virtnet_probe>> vi->vdev->config->reset(vdev);
+ *   - drivers/net/virtio_net.c|3056| <<remove_vq_common>> vi->vdev->config->reset(vi->vdev);
+ *   - drivers/virtio/virtio_balloon.c|638| <<remove_common>> vb->vdev->config->reset(vb->vdev);
+ *   - drivers/virtio/virtio_input.c|324| <<virtinput_remove>> vdev->config->reset(vdev);
+ *   - drivers/char/hw_random/virtio-rng.c|149| <<remove_common>> vdev->config->reset(vdev);
+ *   - drivers/char/virtio_console.c|1987| <<virtcons_remove>> vdev->config->reset(vdev);
+ *   - drivers/char/virtio_console.c|2170| <<virtcons_freeze>> vdev->config->reset(vdev);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|419| <<virtcrypto_probe>> vcrypto->vdev->config->reset(vdev);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|451| <<virtcrypto_remove>> vdev->config->reset(vdev);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|471| <<virtcrypto_freeze>> vdev->config->reset(vdev);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|507| <<virtcrypto_restore>> vcrypto->vdev->config->reset(vdev);
+ *   - drivers/net/caif/caif_virtio.c|763| <<cfv_remove>> vdev->config->reset(vdev);
+ *   - drivers/rpmsg/virtio_rpmsg_bus.c|1005| <<rpmsg_remove>> vdev->config->reset(vdev);
+ *   - net/9p/trans_virtio.c|715| <<p9_virtio_remove>> vdev->config->reset(vdev);
+ *   - net/vmw_vsock/virtio_transport.c|640| <<virtio_vsock_remove>> vdev->config->reset(vdev);
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.reset = vp_reset()
+ *
+ * 先把0写入bar0的VIRTIO_PCI_STATUS
+ * 然后读一下bar0的VIRTIO_PCI_STATUS (flush一下写)
+ * 最后等待所有属于这个设备的pending的irq handler完成
+ */
 static void vp_reset(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -99,9 +223,21 @@ static void vp_reset(struct virtio_device *vdev)
 	 * including MSi-X interrupts, if any. */
 	ioread8(vp_dev->ioaddr + VIRTIO_PCI_STATUS);
 	/* Flush pending VQ/configuration callbacks. */
+	/* 等待所有属于这个设备的pending的irq handler完成 */
 	vp_synchronize_vectors(vdev);
 }
 
+/*
+ * 被以下使用:
+ *   - drivers/virtio/virtio_pci_legacy.c|394| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+ *
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|238| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+ *   - drivers/virtio/virtio_pci_common.c|389| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+ *
+ * 把vector写入bar0的VIRTIO_MSI_CONFIG_VECTOR然后再读出来
+ * 再读出来应该是查看是否生效吧
+ */
 static u16 vp_config_vector(struct virtio_pci_device *vp_dev, u16 vector)
 {
 	/* Setup the vector used for configuration events */
@@ -111,6 +247,20 @@ static u16 vp_config_vector(struct virtio_pci_device *vp_dev, u16 vector)
 	return ioread16(vp_dev->ioaddr + VIRTIO_MSI_CONFIG_VECTOR);
 }
 
+/*
+ * 在以下被使用:
+ *   - drivers/virtio/virtio_pci_legacy.c|310| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+ *
+ * 调用的地方:
+ *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+ *                                                                                   msix_vec);
+ *
+ * 这个函数针对某一个queue
+ * 分配并初始化vring_virtqueue, 返回其包含的virtqueue
+ * 会分配ring buffer, 初始化包含的vring和virtqueue
+ * 把ring buffer的地址告诉backend!
+ * 为这个queue设置msi vector为msix_vec
+ */
 static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 				  struct virtio_pci_vq_info *info,
 				  unsigned index,
@@ -125,9 +275,15 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	u64 q_pfn;
 
 	/* Select the queue we're interested in */
+	/*
+	 * virtio_pci_device->ioaddr是bar0
+	 */
 	iowrite16(index, vp_dev->ioaddr + VIRTIO_PCI_QUEUE_SEL);
 
 	/* Check if queue is either not available or already active. */
+	/*
+	 * num是queue size
+	 */
 	num = ioread16(vp_dev->ioaddr + VIRTIO_PCI_QUEUE_NUM);
 	if (!num || ioread32(vp_dev->ioaddr + VIRTIO_PCI_QUEUE_PFN))
 		return ERR_PTR(-ENOENT);
@@ -135,6 +291,10 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	info->msix_vector = msix_vec;
 
 	/* create the vring */
+	/*
+	 * 分配并初始化vring_virtqueue, 返回其包含的virtqueue
+	 * 会分配ring buffer, 初始化包含的vring和virtqueue
+	 */
 	vq = vring_create_virtqueue(index, num,
 				    VIRTIO_PCI_VRING_ALIGN, &vp_dev->vdev,
 				    true, false, ctx,
@@ -142,6 +302,13 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	if (!vq)
 		return ERR_PTR(-ENOMEM);
 
+	/*
+	 * virtqueue_get_desc_addr():
+	 *     ring buffer是一个包含desc,avail和used等其他指针作为一个连续的内存
+	 *     返回desc的基地址
+	 *
+	 * 这里q_pfn是desc的基地址的pfn
+	 */
 	q_pfn = virtqueue_get_desc_addr(vq) >> VIRTIO_PCI_QUEUE_ADDR_SHIFT;
 	if (q_pfn >> 32) {
 		dev_err(&vp_dev->pci_dev->dev,
@@ -152,10 +319,16 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	}
 
 	/* activate the queue */
+	/*
+	 * 把ring buffer的地址告诉backend!
+	 */
 	iowrite32(q_pfn, vp_dev->ioaddr + VIRTIO_PCI_QUEUE_PFN);
 
 	vq->priv = (void __force *)vp_dev->ioaddr + VIRTIO_PCI_QUEUE_NOTIFY;
 
+	/*
+	 * 确认这个queue就是用msix_vec!
+	 */
 	if (msix_vec != VIRTIO_MSI_NO_VECTOR) {
 		iowrite16(msix_vec, vp_dev->ioaddr + VIRTIO_MSI_QUEUE_VECTOR);
 		msix_vec = ioread16(vp_dev->ioaddr + VIRTIO_MSI_QUEUE_VECTOR);
@@ -174,6 +347,18 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	return ERR_PTR(err);
 }
 
+/*
+ * 只在以下被使用:
+ *   - drivers/virtio/virtio_pci_legacy.c|335| <<virtio_pci_legacy_probe>> vp_dev->del_vq = del_vq;
+ *
+ * 调用的地方:
+ *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+ *
+ * 针对某一个queue, 给定其virtio_pci_vq_info作为输入
+ * 如果用的msix, 告诉backend没有msi vector
+ * 告诉backend ring buffer的基地址是0
+ * 释放vring_virtqueue并在virtio_device->vqs链表移除
+ */
 static void del_vq(struct virtio_pci_vq_info *info)
 {
 	struct virtqueue *vq = info->vq;
@@ -182,6 +367,9 @@ static void del_vq(struct virtio_pci_vq_info *info)
 	iowrite16(vq->index, vp_dev->ioaddr + VIRTIO_PCI_QUEUE_SEL);
 
 	if (vp_dev->msix_enabled) {
+		/*
+		 * 告诉backend没有msi vector了
+		 */
 		iowrite16(VIRTIO_MSI_NO_VECTOR,
 			  vp_dev->ioaddr + VIRTIO_MSI_QUEUE_VECTOR);
 		/* Flush the write out to device */
@@ -189,11 +377,19 @@ static void del_vq(struct virtio_pci_vq_info *info)
 	}
 
 	/* Select and deactivate the queue */
+	/*
+	 * 告诉backend ring buffer的基地址是0
+	 */
 	iowrite32(0, vp_dev->ioaddr + VIRTIO_PCI_QUEUE_PFN);
 
+	/* 释放vring_virtqueue并在virtio_device->vqs链表移除 */
 	vring_del_virtqueue(vq);
 }
 
+/*
+ * 只被以下使用:
+ *   - drivers/virtio/virtio_pci_legacy.c|289| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+ */
 static const struct virtio_config_ops virtio_pci_config_ops = {
 	.get		= vp_get,
 	.set		= vp_set,
@@ -210,6 +406,10 @@ static const struct virtio_config_ops virtio_pci_config_ops = {
 };
 
 /* the PCI probing function */
+/*
+ * 只被virtio_pci_probe()在两处调用:
+ *   - drivers/virtio/virtio_pci_common.c|756| <<virtio_pci_probe>> rc = virtio_pci_legacy_probe(vp_dev);
+ */
 int virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)
 {
 	struct pci_dev *pci_dev = vp_dev->pci_dev;
@@ -258,10 +458,46 @@ int virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)
 	vp_dev->vdev.id.vendor = pci_dev->subsystem_vendor;
 	vp_dev->vdev.id.device = pci_dev->subsystem_device;
 
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	vp_dev->vdev.config = &virtio_pci_config_ops;
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的vp_config_vector()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|263| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+	 *   - drivers/virtio/virtio_pci_modern.c|709| <<virtio_pci_modern_probe>> vp_dev->config_vector = vp_config_vector;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|224| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+	 *   - drivers/virtio/virtio_pci_common.c|344| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+	 *
+	 * 把vector写入bar0的VIRTIO_MSI_CONFIG_VECTOR然后再读出来
+	 * 再读出来应该是查看是否生效吧
+	 */
 	vp_dev->config_vector = vp_config_vector;
+	/*
+	 * 设置的地方 (legacy和modern用的不同的setup_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|273| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|719| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+	 * 
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+	 *                                                                                   msix_vec);
+	 */
 	vp_dev->setup_vq = setup_vq;
+	/*
+	 * 设置的地方 (legacy和modern用的不同的del_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|283| <<virtio_pci_legacy_probe>> vp_dev->del_vq = del_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|729| <<virtio_pci_modern_probe>> vp_dev->del_vq = del_vq;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+	 */
 	vp_dev->del_vq = del_vq;
 
 	return 0;
@@ -271,6 +507,11 @@ int virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)
 	return rc;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|781| <<virtio_pci_probe>> virtio_pci_legacy_remove(vp_dev);
+ *   - drivers/virtio/virtio_pci_common.c|821| <<virtio_pci_remove>> virtio_pci_legacy_remove(vp_dev);
+ */
 void virtio_pci_legacy_remove(struct virtio_pci_device *vp_dev)
 {
 	struct pci_dev *pci_dev = vp_dev->pci_dev;
diff --git a/drivers/virtio/virtio_pci_modern.c b/drivers/virtio/virtio_pci_modern.c
index 07571da..6125320 100644
--- a/drivers/virtio/virtio_pci_modern.c
+++ b/drivers/virtio/virtio_pci_modern.c
@@ -65,6 +65,26 @@ static void vp_iowrite64_twopart(u64 val,
 	vp_iowrite32(val >> 32, hi);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_modern.c|420| <<setup_vq>> vq->priv = (void __force *)map_capability(vp_dev->pci_dev,
+ *                                                                                                    vp_dev->notify_map_cap, 2, 2,
+ *                                                                                                    off * vp_dev->notify_offset_multiplier, 2,
+ *                                                                                                    NULL);
+ *   - drivers/virtio/virtio_pci_modern.c|727| <<virtio_pci_modern_probe>> vp_dev->common = map_capability(pci_dev, common,
+ *                                                                                                         sizeof(struct virtio_pci_common_cfg), 4,
+ *                                                                                                         0, sizeof(struct virtio_pci_common_cfg),
+ *                                                                                                         NULL);
+ *   - drivers/virtio/virtio_pci_modern.c|733| <<virtio_pci_modern_probe>> vp_dev->isr = map_capability(pci_dev, isr, sizeof(u8), 1,
+ *                                                                                                      0, 1,
+ *                                                                                                      NULL);
+ *   - drivers/virtio/virtio_pci_modern.c|760| <<virtio_pci_modern_probe>> vp_dev->notify_base = map_capability(pci_dev, notify, 2, 2,
+ *                                                                                                              0, notify_length,
+ *                                                                                                              &vp_dev->notify_len);
+ *   - drivers/virtio/virtio_pci_modern.c|773| <<virtio_pci_modern_probe>> vp_dev->device = map_capability(pci_dev, device, 0, 4,
+ *                                                                                                         0, PAGE_SIZE,
+ *                                                                                                         &vp_dev->device_len);
+ */
 static void __iomem *map_capability(struct pci_dev *dev, int off,
 				    size_t minlen,
 				    u32 align,
@@ -140,8 +160,19 @@ static void __iomem *map_capability(struct pci_dev *dev, int off,
 }
 
 /* virtio config->get_features() implementation */
+/*
+ * called only by:
+ *   - drivers/virtio/virtio.c|331| <<virtio_dev_probe>> device_features = dev->config->get_features(dev);
+ *
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.get_features = vp_get_features()
+ * struct virtio_config_ops virtio_pci_config_ops.get_features = vp_get_features()
+ */
 static u64 vp_get_features(struct virtio_device *vdev)
 {
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 把struct virtio_device转换成struct virtio_pci_device
+	 */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	u64 features;
 
@@ -153,6 +184,10 @@ static u64 vp_get_features(struct virtio_device *vdev)
 	return features;
 }
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio_pci_modern.c|207| <<vp_finalize_features>> vp_transport_features(vdev, features);
+ */
 static void vp_transport_features(struct virtio_device *vdev, u64 features)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -164,6 +199,10 @@ static void vp_transport_features(struct virtio_device *vdev, u64 features)
 }
 
 /* virtio config->finalize_features() implementation */
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.finalize_features = vp_finalize_features()
+ * struct virtio_config_ops virtio_pci_config_ops.finalize_features = vp_finalize_features()
+ */
 static int vp_finalize_features(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -190,9 +229,19 @@ static int vp_finalize_features(struct virtio_device *vdev)
 }
 
 /* virtio config->get() implementation */
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.get = vp_get()
+ *
+ * 把VIRTIO_PCI_CAP_DEVICE_CFG这个capability的offset的len的内容读入buf
+ * 这个capability被map在virtio_pci_device->device
+ */
 static void vp_get(struct virtio_device *vdev, unsigned offset,
 		   void *buf, unsigned len)
 {
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 把struct virtio_device转换成struct virtio_pci_device
+	 */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	u8 b;
 	__le16 w;
@@ -200,6 +249,10 @@ static void vp_get(struct virtio_device *vdev, unsigned offset,
 
 	BUG_ON(offset + len > vp_dev->device_len);
 
+	/*
+	 * virtio_pci_device->device是VIRTIO_PCI_CAP_DEVICE_CFG的capability
+	 */
+
 	switch (len) {
 	case 1:
 		b = ioread8(vp_dev->device + offset);
@@ -226,9 +279,19 @@ static void vp_get(struct virtio_device *vdev, unsigned offset,
 
 /* the config->set() implementation.  it's symmetric to the config->get()
  * implementation */
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.set = vp_set()
+ *
+ * 把buf的len长度的内容写入offset在VIRTIO_PCI_CAP_DEVICE_CFG这个capability的位置
+ * 这个capability被map在virtio_pci_device->device
+ */
 static void vp_set(struct virtio_device *vdev, unsigned offset,
 		   const void *buf, unsigned len)
 {
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 把struct virtio_device转换成struct virtio_pci_device
+	 */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	u8 b;
 	__le16 w;
@@ -236,6 +299,10 @@ static void vp_set(struct virtio_device *vdev, unsigned offset,
 
 	BUG_ON(offset + len > vp_dev->device_len);
 
+	/*
+	 * virtio_pci_device->device是VIRTIO_PCI_CAP_DEVICE_CFG的capability
+	 */
+
 	switch (len) {
 	case 1:
 		memcpy(&b, buf, sizeof b);
@@ -260,6 +327,10 @@ static void vp_set(struct virtio_device *vdev, unsigned offset,
 	}
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.generation = vp_generation()
+ * struct virtio_config_ops virtio_pci_config_ops.generation = vp_generation()
+ */
 static u32 vp_generation(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -267,12 +338,20 @@ static u32 vp_generation(struct virtio_device *vdev)
 }
 
 /* config->{get,set}_status() implementations */
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.get_status = vp_get_status()
+ * struct virtio_config_ops virtio_pci_config_ops.get_status = vp_get_status()
+ */
 static u8 vp_get_status(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	return vp_ioread8(&vp_dev->common->device_status);
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.set_status = vp_set_status()
+ * struct virtio_config_ops virtio_pci_config_ops.set_status = vp_set_status()
+ */
 static void vp_set_status(struct virtio_device *vdev, u8 status)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -281,6 +360,10 @@ static void vp_set_status(struct virtio_device *vdev, u8 status)
 	vp_iowrite8(status, &vp_dev->common->device_status);
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.reset = vp_reset()
+ * struct virtio_config_ops virtio_pci_config_ops.reset = vp_reset()
+ */
 static void vp_reset(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -294,6 +377,7 @@ static void vp_reset(struct virtio_device *vdev)
 	while (vp_ioread8(&vp_dev->common->device_status))
 		msleep(1);
 	/* Flush pending VQ/configuration callbacks. */
+	/* 等待所有属于这个设备的pending的irq handler完成 */
 	vp_synchronize_vectors(vdev);
 }
 
@@ -306,6 +390,23 @@ static u16 vp_config_vector(struct virtio_pci_device *vp_dev, u16 vector)
 	return vp_ioread16(&vp_dev->common->msix_config);
 }
 
+/*
+ * 只在以下被调用:
+ *   - drivers/virtio/virtio_pci_modern.c|742| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+ *
+ * 设置的地方 (legacy和modern用的不同的setup_vq()):
+ *   - drivers/virtio/virtio_pci_legacy.c|273| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+ *   - drivers/virtio/virtio_pci_modern.c|719| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+ * 
+ * 调用的地方:
+ *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+ *
+ * 这个函数针对某一个queue
+ * 分配并初始化vring_virtqueue, 返回其包含的virtqueue
+ * 会分配ring buffer, 初始化包含的vring和virtqueue
+ * 把ring buffer的地址告诉backend!
+ * 为这个queue设置msi vector为msix_vecmsix_vec);
+ */
 static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 				  struct virtio_pci_vq_info *info,
 				  unsigned index,
@@ -314,6 +415,14 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 				  bool ctx,
 				  u16 msix_vec)
 {
+	/*
+	 * 在以下被map为VIRTIO_PCI_CAP_COMMON_CFG:
+	 *   - drivers/virtio/virtio_pci_modern.c|768| <<virtio_pci_modern_probe>>
+	 *            vp_dev->common = map_capability(pci_dev, common,
+	 *                                            sizeof(struct virtio_pci_common_cfg), 4,
+	 *                                            0, sizeof(struct virtio_pci_common_cfg),
+	 *                                            NULL);
+	 */
 	struct virtio_pci_common_cfg __iomem *cfg = vp_dev->common;
 	struct virtqueue *vq;
 	u16 num, off;
@@ -326,6 +435,7 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	vp_iowrite16(index, &cfg->queue_select);
 
 	/* Check if queue is either not available or already active. */
+	/* queue中有多少个desc?? */
 	num = vp_ioread16(&cfg->queue_size);
 	if (!num || vp_ioread16(&cfg->queue_enable))
 		return ERR_PTR(-ENOENT);
@@ -341,6 +451,10 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	info->msix_vector = msix_vec;
 
 	/* create the vring */
+	/*
+	 * 分配并初始化vring_virtqueue, 返回其包含的virtqueue
+	 * 会分配ring buffer, 初始化包含的vring和virtqueue
+	 */
 	vq = vring_create_virtqueue(index, num,
 				    SMP_CACHE_BYTES, &vp_dev->vdev,
 				    true, true, ctx,
@@ -402,6 +516,10 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	return ERR_PTR(err);
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.find_vqs = vp_modern_find_vqs()
+ * struct virtio_config_ops virtio_pci_config_ops.find_vqs = vp_modern_find_vqs()
+ */
 static int vp_modern_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 			      struct virtqueue *vqs[],
 			      vq_callback_t *callbacks[],
@@ -426,6 +544,18 @@ static int vp_modern_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 	return 0;
 }
 
+/*
+ * 只在以下被使用:
+ *   - drivers/virtio/virtio_pci_modern.c|763| <<virtio_pci_modern_probe>> vp_dev->del_vq = del_vq;
+ *
+ * 调用的地方:
+ *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+ *
+ * 针对某一个queue, 给定其virtio_pci_vq_info作为输入
+ * 如果用的msix, 告诉backend没有msi vector
+ * unmap通知backend的priv内存区域
+ * 释放vring_virtqueue并在virtio_device->vqs链表移除
+ */
 static void del_vq(struct virtio_pci_vq_info *info)
 {
 	struct virtqueue *vq = info->vq;
@@ -434,18 +564,29 @@ static void del_vq(struct virtio_pci_vq_info *info)
 	vp_iowrite16(vq->index, &vp_dev->common->queue_select);
 
 	if (vp_dev->msix_enabled) {
+		/*
+		 * 如果用的msix, 告诉backend没有msi vector
+		 */
 		vp_iowrite16(VIRTIO_MSI_NO_VECTOR,
 			     &vp_dev->common->queue_msix_vector);
 		/* Flush the write out to device */
 		vp_ioread16(&vp_dev->common->queue_msix_vector);
 	}
 
+	/*
+	 * unmap通知backend的priv内存区域
+	 */
 	if (!vp_dev->notify_base)
 		pci_iounmap(vp_dev->pci_dev, (void __force __iomem *)vq->priv);
 
+	/* 释放vring_virtqueue并在virtio_device->vqs链表移除 */
 	vring_del_virtqueue(vq);
 }
 
+/*
+ * used by only:
+ *   - drivers/virtio/virtio_pci_modern.c|836| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+ */
 static const struct virtio_config_ops virtio_pci_config_nodev_ops = {
 	.get		= NULL,
 	.set		= NULL,
@@ -462,6 +603,10 @@ static const struct virtio_config_ops virtio_pci_config_nodev_ops = {
 	.get_vq_affinity = vp_get_vq_affinity,
 };
 
+/*
+ * used only by:
+ *   - drivers/virtio/virtio_pci_modern.c|827| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+ */
 static const struct virtio_config_ops virtio_pci_config_ops = {
 	.get		= vp_get,
 	.set		= vp_set,
@@ -486,6 +631,25 @@ static const struct virtio_config_ops virtio_pci_config_ops = {
  *
  * Returns offset of the capability, or 0.
  */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_modern.c|662| <<virtio_pci_modern_probe>> common = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_COMMON_CFG,
+ *                                                                                                             IORESOURCE_IO | IORESOURCE_MEM,
+ *                                                                                                             &vp_dev->modern_bars);
+ *   - drivers/virtio/virtio_pci_modern.c|672| <<virtio_pci_modern_probe>> isr = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_ISR_CFG,
+ *                                                                                                          IORESOURCE_IO | IORESOURCE_MEM,
+ *                                                                                                          &vp_dev->modern_bars);
+ *   - drivers/virtio/virtio_pci_modern.c|675| <<virtio_pci_modern_probe>> notify = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_NOTIFY_CFG,
+ *                                                                                                             IORESOURCE_IO | IORESOURCE_MEM,
+ *                                                                                                             &vp_dev->modern_bars);
+ *   - drivers/virtio/virtio_pci_modern.c|695| <<virtio_pci_modern_probe>> device = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_DEVICE_CFG,
+ *                                                                                                             IORESOURCE_IO | IORESOURCE_MEM,
+ *                                                                                                             &vp_dev->modern_bars);
+ *
+ * 寻找cfg_type类型所代表的capability, 把相应的bar写入参数*bars中
+ * 返回找到的capability的pos, 否则返回0
+ * capability的例子: VIRTIO_PCI_CAP_COMMON_CFG等
+ */
 static inline int virtio_pci_find_capability(struct pci_dev *dev, u8 cfg_type,
 					     u32 ioresource_types, int *bars)
 {
@@ -581,6 +745,10 @@ static inline void check_offsets(void)
 }
 
 /* the PCI probing function */
+/*
+ * 被virtio_pci_probe()在两处调用:
+ *   - drivers/virtio/virtio_pci_common.c|771| <<virtio_pci_probe>> rc = virtio_pci_modern_probe(vp_dev);
+ */
 int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 {
 	struct pci_dev *pci_dev = vp_dev->pci_dev;
@@ -606,6 +774,10 @@ int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 	vp_dev->vdev.id.vendor = pci_dev->subsystem_vendor;
 
 	/* check for a common config: if not, use legacy mode (bar 0). */
+	/*
+	 * 寻找VIRTIO_PCI_CAP_COMMON_CFG类型所代表的capability, 把相应的bar写入参数vp_dev->modern_bars中
+	 * 返回找到的capability的pos到common(int), 否则返回0
+	 */
 	common = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_COMMON_CFG,
 					    IORESOURCE_IO | IORESOURCE_MEM,
 					    &vp_dev->modern_bars);
@@ -616,9 +788,17 @@ int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 	}
 
 	/* If common is there, these should be too... */
+	/*
+	 * 寻找VIRTIO_PCI_CAP_ISR_CFG类型所代表的capability, 把相应的bar写入参数vp_dev->modern_bars中
+	 * 返回找到的capability的pos到isr(int), 否则返回0
+	 */
 	isr = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_ISR_CFG,
 					 IORESOURCE_IO | IORESOURCE_MEM,
 					 &vp_dev->modern_bars);
+	/*
+	 * 寻找VIRTIO_PCI_CAP_NOTIFY_CFG类型所代表的capability, 把相应的bar写入参数vp_dev->modern_bars中
+	 * 返回找到的capability的pos到notify(int), 否则返回0
+	 */
 	notify = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_NOTIFY_CFG,
 					    IORESOURCE_IO | IORESOURCE_MEM,
 					    &vp_dev->modern_bars);
@@ -639,10 +819,15 @@ int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 	/* Device capability is only mandatory for devices that have
 	 * device-specific configuration.
 	 */
+	/*
+	 * 寻找VIRTIO_PCI_CAP_DEVICE_CFG类型所代表的capability, 把相应的bar写入参数vp_dev->modern_bars中
+	 * 返回找到的capability的pos到device(int), 否则返回0
+	 */
 	device = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_DEVICE_CFG,
 					    IORESOURCE_IO | IORESOURCE_MEM,
 					    &vp_dev->modern_bars);
 
+	/* 申请vp_dev->modern_bars上每一个bit所指向的bar */
 	err = pci_request_selected_regions(pci_dev, vp_dev->modern_bars,
 					   "virtio-pci-modern");
 	if (err)
@@ -701,13 +886,53 @@ int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 		if (!vp_dev->device)
 			goto err_map_device;
 
+		/*
+		 * 设置的地方:
+		 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+		 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+		 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+		 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+		 */
 		vp_dev->vdev.config = &virtio_pci_config_ops;
 	} else {
+		/*
+		 * 设置的地方:
+		 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops;
+		 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+		 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+		 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+		 */
 		vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
 	}
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的vp_config_vector()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|263| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+	 *   - drivers/virtio/virtio_pci_modern.c|709| <<virtio_pci_modern_probe>> vp_dev->config_vector = vp_config_vector;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|224| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+	 *   - drivers/virtio/virtio_pci_common.c|344| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+	 */
 	vp_dev->config_vector = vp_config_vector;
+	/*
+	 * 设置的地方 (legacy和modern用的不同的setup_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|273| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|719| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+	 * 
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+	 *                                                                                   msix_vec);
+	 */
 	vp_dev->setup_vq = setup_vq;
+	/*
+	 * 设置的地方 (legacy和modern用的不同的del_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|283| <<virtio_pci_legacy_probe>> vp_dev->del_vq = del_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|729| <<virtio_pci_modern_probe>> vp_dev->del_vq = del_vq;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+	 */
 	vp_dev->del_vq = del_vq;
 
 	return 0;
@@ -723,6 +948,11 @@ int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|791| <<virtio_pci_probe>> virtio_pci_modern_remove(vp_dev);
+ *   - drivers/virtio/virtio_pci_common.c|831| <<virtio_pci_remove>> virtio_pci_modern_remove(vp_dev);
+ */
 void virtio_pci_modern_remove(struct virtio_pci_device *vp_dev)
 {
 	struct pci_dev *pci_dev = vp_dev->pci_dev;
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index 814b395..7021a7b 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -70,12 +70,31 @@ struct vring_virtqueue {
 	bool weak_barriers;
 
 	/* Other side has made a mess, don't try any more. */
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_ring.c|52| <<BAD_RING>> (_vq)->broken = true; \
+	 *   - drivers/virtio/virtio_ring.c|822| <<virtqueue_notify>> vq->broken = true;
+	 *   - __vring_new_virtqueue()设置为false
+	 *   - drivers/virtio/virtio_ring.c|1544| <<virtio_break_device>> vq->broken = true;
+	 */
 	bool broken;
 
 	/* Host supports indirect buffers */
+	/*
+	 * 在以下被设置:
+	 *   - drivers/virtio/virtio_ring.c|1092| <<bool>> vq->indirect = virtio_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC) &&
+	 */
 	bool indirect;
 
 	/* Host publishes avail event idx */
+	/*
+	 * 在__vring_new_virtqueue()设置:
+	 *   - vq->event = virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);
+	 *
+	 * VIRTIO_RING_F_EVENT_IDX:
+	 *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+	 *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+	 */
 	bool event;
 
 	/* Head of free buffer list. */
@@ -87,17 +106,49 @@ struct vring_virtqueue {
 	u16 last_used_idx;
 
 	/* Last written value to avail->flags */
+	/*
+	 * 修改的地方:
+	 *   - drivers/virtio/virtio_ring.c|1106| <<virtqueue_disable_cb>> vq->avail_flags_shadow |= VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|1144| <<virtqueue_enable_cb_prepare>> vq->avail_flags_shadow &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|1239| <<virtqueue_enable_cb_delayed>> vq->avail_flags_shadow &= ~VRING_AVAIL_F_NO_INTERRUPT;
+	 *   - drivers/virtio/virtio_ring.c|1439| <<bool>> vq->avail_flags_shadow |= VRING_AVAIL_F_NO_INTERRUPT;
+	 */
 	u16 avail_flags_shadow;
 
 	/* Last written value to avail->idx in guest byte order */
+	/*
+	 * 增加的地方:
+	 *   - drivers/virtio/virtio_ring.c|552| <<virtqueue_add>> vq->avail_idx_shadow++;
+	 *
+	 * 减少的地方:
+	 *   - drivers/virtio/virtio_ring.c|1161| <<virtqueue_detach_unused_buf>> vq->avail_idx_shadow--;
+	 */
 	u16 avail_idx_shadow;
 
 	/* How to notify other side. FIXME: commonalize hcalls! */
+	/*
+	 * 在__vring_new_virtqueue()使用如下设置:
+	 *   - vq->notify = notify;
+	 *
+	 * 例子就是vp_notify()
+	 */
 	bool (*notify)(struct virtqueue *vq);
 
 	/* DMA, allocation, and size information */
+	/*
+	 * 设置为true的地方:
+	 *   - vring_create_virtqueue()
+	 */
 	bool we_own_ring;
+	/*
+	 * 在vring_create_virtqueue()被初始化为ring buffer的大小
+	 * 是desc,avail和used等其他指针作为一个连续的内存的大小
+	 */
 	size_t queue_size_in_bytes;
+	/*
+	 * 在vring_create_virtqueue()被初始化为ring buffer的基地址
+	 * 是desc,avail和used等其他指针作为一个连续的内存
+	 */
 	dma_addr_t queue_dma_addr;
 
 #ifdef DEBUG
@@ -110,9 +161,14 @@ struct vring_virtqueue {
 #endif
 
 	/* Per-descriptor state. */
+	/*
+	 * 在__vring_new_virtqueue()和vring_virtqueue一起分配
+	 * 放在vring_virtqueue个元素
+	 */
 	struct vring_desc_state desc_state[];
 };
 
+/* vring_virtqueue包含virtqueue和vring */
 #define to_vvq(_vq) container_of(_vq, struct vring_virtqueue, vq)
 
 /*
@@ -141,8 +197,22 @@ struct vring_virtqueue {
  * unconditionally on data path.
  */
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|183| <<vring_map_one_sg>> if (!vring_use_dma_api(vq->vq.vdev))
+ *   - drivers/virtio/virtio_ring.c|200| <<vring_map_single>> if (!vring_use_dma_api(vq->vq.vdev))
+ *   - drivers/virtio/virtio_ring.c|212| <<vring_unmap_one>> if (!vring_use_dma_api(vq->vq.vdev))
+ *   - drivers/virtio/virtio_ring.c|235| <<vring_mapping_error>> if (!vring_use_dma_api(vq->vq.vdev))
+ *   - drivers/virtio/virtio_ring.c|1028| <<vring_alloc_queue>> if (vring_use_dma_api(vdev)) {
+ *   - drivers/virtio/virtio_ring.c|1060| <<vring_free_queue>> if (vring_use_dma_api(vdev)) {
+ *
+ * 返回true说明支持iommu (VIRTIO_F_IOMMU_PLATFORM)
+ */
 static bool vring_use_dma_api(struct virtio_device *vdev)
 {
+	/*
+	 * 查看是否支持VIRTIO_F_IOMMU_PLATFORM
+	 */
 	if (!virtio_has_iommu_quirk(vdev))
 		return true;
 
@@ -166,20 +236,51 @@ static bool vring_use_dma_api(struct virtio_device *vdev)
  * making all of the arch DMA ops work on the vring device itself
  * is a mess.  For now, we use the parent device for DMA ops.
  */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|191| <<vring_map_one_sg>> return dma_map_page(vring_dma_dev(vq),
+ *   - drivers/virtio/virtio_ring.c|203| <<vring_map_single>> return dma_map_single(vring_dma_dev(vq),
+ *   - drivers/virtio/virtio_ring.c|218| <<vring_unmap_one>> dma_unmap_single(vring_dma_dev(vq),
+ *   - drivers/virtio/virtio_ring.c|224| <<vring_unmap_one>> dma_unmap_page(vring_dma_dev(vq),
+ *   - drivers/virtio/virtio_ring.c|238| <<vring_mapping_error>> return dma_mapping_error(vring_dma_dev(vq), addr);
+ *
+ * 给一个vring_virtqueue作为输入,先通过vring_virtqueue包含的virtqueue找到virtio_device
+ * virtio_device->dev.parent是对应的pci_dev的dev
+ */
 static inline struct device *vring_dma_dev(const struct vring_virtqueue *vq)
 {
+	/*
+	 * vq->vq.vdev是virtio_device类型
+	 *
+	 * parent是struct pci_dev的dev
+	 * pci_dev->dev->driver_data设置为virtio_pci_device
+	 * virtio_pci_device包含virtio_device
+	 */
 	return vq->vq.vdev->dev.parent;
 }
 
 /* Map one sg entry. */
+/*
+ * 如果不支持iommu(VIRTIO_F_IOMMU_PLATFORM),直接返回scatterlist的物理地址
+ * 否则,会间接调用iommu的ops->map_page(), map到iommu分配的地址
+ */
 static dma_addr_t vring_map_one_sg(const struct vring_virtqueue *vq,
 				   struct scatterlist *sg,
 				   enum dma_data_direction direction)
 {
+	/*
+	 * 返回true说明支持iommu (VIRTIO_F_IOMMU_PLATFORM)
+	 *
+	 * 如果不支持iommu,直接返回scatterlist的物理地址
+	 */
 	if (!vring_use_dma_api(vq->vq.vdev))
 		return (dma_addr_t)sg_phys(sg);
 
 	/*
+	 * 否则,会间接调用iommu的ops->map_page(), map到iommu分配的地址
+	 */
+
+	/*
 	 * We can't use dma_map_sg, because we don't use scatterlists in
 	 * the way it expects (we don't guarantee that the scatterlist
 	 * will exist for the lifetime of the mapping).
@@ -189,22 +290,42 @@ static dma_addr_t vring_map_one_sg(const struct vring_virtqueue *vq,
 			    direction);
 }
 
+/*
+ * 如果不支持iommu(VIRTIO_F_IOMMU_PLATFORM),直接返回虚拟地址的物理地址
+ * 否则,会间接调用iommu的ops->map_page(), map到iommu分配的地址
+ */
 static dma_addr_t vring_map_single(const struct vring_virtqueue *vq,
 				   void *cpu_addr, size_t size,
 				   enum dma_data_direction direction)
 {
+	/*
+	 * 返回true说明支持iommu (VIRTIO_F_IOMMU_PLATFORM)
+	 *
+	 * 如果不支持iommu,直接返回虚拟地址的物理地址
+	 */
 	if (!vring_use_dma_api(vq->vq.vdev))
 		return (dma_addr_t)virt_to_phys(cpu_addr);
 
+	/*
+	 * 否则,会间接调用iommu的ops->map_page(), map到iommu分配的地址
+	 */
 	return dma_map_single(vring_dma_dev(vq),
 			      cpu_addr, size, direction);
 }
 
+/*
+ * 如果不支持iommu(VIRTIO_F_IOMMU_PLATFORM),直接返回就行
+ * 否则,根据vring_desc->flags是否有VRING_DESC_F_INDIRECT决定调用dma_unmap_single()还是dma_unmap_page()
+ */
 static void vring_unmap_one(const struct vring_virtqueue *vq,
 			    struct vring_desc *desc)
 {
 	u16 flags;
 
+	/*
+	 * 返回true说明支持iommu (VIRTIO_F_IOMMU_PLATFORM)
+	 * 直接返回就行
+	 */
 	if (!vring_use_dma_api(vq->vq.vdev))
 		return;
 
@@ -225,15 +346,32 @@ static void vring_unmap_one(const struct vring_virtqueue *vq,
 	}
 }
 
+/*
+ * 如果不支持iommu(VIRTIO_F_IOMMU_PLATFORM),直接返回0就行
+ * 否则,会间接调用iommu的ops->mapping_error()
+ */
 static int vring_mapping_error(const struct vring_virtqueue *vq,
 			       dma_addr_t addr)
 {
+	/*
+	 * 返回true说明支持iommu (VIRTIO_F_IOMMU_PLATFORM)
+	 * 直接返回0,什么也不做
+	 */
 	if (!vring_use_dma_api(vq->vq.vdev))
 		return 0;
 
+	/*
+	 * 否则,会间接调用iommu的ops->mapping_error()
+	 */
 	return dma_mapping_error(vring_dma_dev(vq), addr);
 }
 
+/*
+ * called by only:
+ *   - drivers/virtio/virtio_ring.c|342| <<virtqueue_add>> desc = alloc_indirect(_vq, total_sg, gfp);
+ *
+ * 分配total_sg个struct vring_desc,初始化把数组元素用desc[i].next链起来,返回基地址
+ */
 static struct vring_desc *alloc_indirect(struct virtqueue *_vq,
 					 unsigned int total_sg, gfp_t gfp)
 {
@@ -256,6 +394,16 @@ static struct vring_desc *alloc_indirect(struct virtqueue *_vq,
 	return desc;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|553| <<virtqueue_add_sgs>> return virtqueue_add(_vq, sgs, total_sg, out_sgs, in_sgs,
+ *   - drivers/virtio/virtio_ring.c|576| <<virtqueue_add_outbuf>> return virtqueue_add(vq, &sg, num, 1, 0, data, NULL, gfp);
+ *   - drivers/virtio/virtio_ring.c|598| <<virtqueue_add_inbuf>> return virtqueue_add(vq, &sg, num, 0, 1, data, NULL, gfp);
+ *   - drivers/virtio/virtio_ring.c|622| <<virtqueue_add_inbuf_ctx>> return virtqueue_add(vq, &sg, num, 0, 1, data, ctx, gfp);
+ *
+ * 主函数,把sgs[]中的每个scatterlist数组添加到ring buffer,
+ * 参数的data是vq->desc_state[head].data
+ */
 static inline int virtqueue_add(struct virtqueue *_vq,
 				struct scatterlist *sgs[],
 				unsigned int total_sg,
@@ -297,10 +445,19 @@ static inline int virtqueue_add(struct virtqueue *_vq,
 
 	BUG_ON(total_sg == 0);
 
+	/*
+	 * free_head是desc中下个可用的
+	 */
 	head = vq->free_head;
 
 	/* If the host supports indirect descriptor tables, and we have multiple
 	 * buffers, then go indirect. FIXME: tune this threshold */
+	/*
+	 * vq->indirect在以下被设置:
+	 *   - drivers/virtio/virtio_ring.c|1092| <<bool>> vq->indirect = virtio_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC) &&
+	 *
+	 * vq->vq.num_free是剩余的desc数量
+	 */
 	if (vq->indirect && total_sg > 1 && vq->vq.num_free)
 		desc = alloc_indirect(_vq, total_sg, gfp);
 	else {
@@ -308,6 +465,10 @@ static inline int virtqueue_add(struct virtqueue *_vq,
 		WARN_ON_ONCE(total_sg > vq->vring.num && !vq->indirect);
 	}
 
+	/*
+	 * desc不为NULL说明上面用了indirect
+	 * 否则没用indirect
+	 */
 	if (desc) {
 		/* Use a single buffer which doesn't continue */
 		indirect = true;
@@ -327,6 +488,10 @@ static inline int virtqueue_add(struct virtqueue *_vq,
 		/* FIXME: for historical reasons, we force a notify here if
 		 * there are outgoing parts to the buffer.  Presumably the
 		 * host should service the ring ASAP. */
+		/*
+		 * notify()在__vring_new_virtqueue()使用如下设置:
+		 *   - vq->notify = notify;
+		 */
 		if (out_sgs)
 			vq->notify(&vq->vq);
 		if (indirect)
@@ -337,6 +502,10 @@ static inline int virtqueue_add(struct virtqueue *_vq,
 
 	for (n = 0; n < out_sgs; n++) {
 		for (sg = sgs[n]; sg; sg = sg_next(sg)) {
+			/*
+			 * 如果不支持iommu(VIRTIO_F_IOMMU_PLATFORM),直接返回scatterlist的物理地址
+			 * 否则,会间接调用iommu的ops->map_page(), map到iommu分配的地址
+			 */
 			dma_addr_t addr = vring_map_one_sg(vq, sg, DMA_TO_DEVICE);
 			if (vring_mapping_error(vq, addr))
 				goto unmap_release;
@@ -350,6 +519,10 @@ static inline int virtqueue_add(struct virtqueue *_vq,
 	}
 	for (; n < (out_sgs + in_sgs); n++) {
 		for (sg = sgs[n]; sg; sg = sg_next(sg)) {
+			/*
+			 * 如果不支持iommu(VIRTIO_F_IOMMU_PLATFORM),直接返回scatterlist的物理地址
+			 * 否则,会间接调用iommu的ops->map_page(), map到iommu分配的地址
+			 */
 			dma_addr_t addr = vring_map_one_sg(vq, sg, DMA_FROM_DEVICE);
 			if (vring_mapping_error(vq, addr))
 				goto unmap_release;
@@ -448,6 +621,17 @@ static inline int virtqueue_add(struct virtqueue *_vq,
  *
  * Returns zero or a negative error (ie. ENOSPC, ENOMEM, EIO).
  */
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|111| <<virtblk_add_req_scsi>> return virtqueue_add_sgs(vq, sgs, num_out, num_in, vbr, GFP_ATOMIC);
+ *   - drivers/block/virtio_blk.c|172| <<virtblk_add_req>> return virtqueue_add_sgs(vq, sgs, num_out, num_in, vbr, GFP_ATOMIC);
+ *   - drivers/net/virtio_net.c|1602| <<virtnet_send_command>> virtqueue_add_sgs(vi->cvq, sgs, out_num, 1, vi, GFP_ATOMIC);
+ *   - drivers/scsi/virtio_scsi.c|462| <<virtscsi_add_cmd>> return virtqueue_add_sgs(vq, sgs, out_num, in_num, cmd, GFP_ATOMIC);
+ *
+ * 把sgs[]中的每个scatterlist数组添加到ring buffer,
+ * 参数的data是vq->desc_state[head].data
+ * ctx是NULL
+ */
 int virtqueue_add_sgs(struct virtqueue *_vq,
 		      struct scatterlist *sgs[],
 		      unsigned int out_sgs,
@@ -458,11 +642,19 @@ int virtqueue_add_sgs(struct virtqueue *_vq,
 	unsigned int i, total_sg = 0;
 
 	/* Count them first. */
+	/*
+	 * 统计一共多少个scatterlist
+	 */
 	for (i = 0; i < out_sgs + in_sgs; i++) {
 		struct scatterlist *sg;
 		for (sg = sgs[i]; sg; sg = sg_next(sg))
 			total_sg++;
 	}
+	/*
+	 * 主函数,把sgs[]中的每个scatterlist数组添加到ring buffer,
+	 * 参数的data是vq->desc_state[head].data
+	 * ctx是NULL
+	 */
 	return virtqueue_add(_vq, sgs, total_sg, out_sgs, in_sgs,
 			     data, NULL, gfp);
 }
@@ -481,11 +673,35 @@ EXPORT_SYMBOL_GPL(virtqueue_add_sgs);
  *
  * Returns zero or a negative error (ie. ENOSPC, ENOMEM, EIO).
  */
+/*
+ * called by:
+ *   - drivers/char/virtio_console.c|580| <<__send_control_msg>> if (virtqueue_add_outbuf(vq, sg, 1, &portdev->cpkt, GFP_ATOMIC) == 0) {
+ *   - drivers/char/virtio_console.c|632| <<__send_to_port>> err = virtqueue_add_outbuf(out_vq, sg, nents, data, GFP_ATOMIC);
+ *   - drivers/net/caif/caif_virtio.c|575| <<cfv_netdev_tx>> ret = virtqueue_add_outbuf(cfv->vq_tx, &sg, 1, buf_info, GFP_ATOMIC);
+ *   - drivers/net/virtio_net.c|461| <<__virtnet_xdp_xmit_one>> err = virtqueue_add_outbuf(sq->vq, sq->sg, 1, xdpf, GFP_ATOMIC);
+ *   - drivers/net/virtio_net.c|1497| <<xmit_skb>> return virtqueue_add_outbuf(sq->vq, sq->sg, num_sg, skb, GFP_ATOMIC);
+ *   - drivers/rpmsg/virtio_rpmsg_bus.c|634| <<rpmsg_send_offchannel_raw>> err = virtqueue_add_outbuf(vrp->svq, &sg, 1, msg, GFP_KERNEL);
+ *   - drivers/virtio/virtio_balloon.c|116| <<tell_host>> virtqueue_add_outbuf(vq, &sg, 1, vb, GFP_KERNEL);
+ *   - drivers/virtio/virtio_balloon.c|319| <<stats_handle_request>> virtqueue_add_outbuf(vq, &sg, 1, vb, GFP_KERNEL);
+ *   - drivers/virtio/virtio_balloon.c|420| <<init_vqs>> err = virtqueue_add_outbuf(vb->stats_vq, &sg, 1, vb,
+ *   - drivers/virtio/virtio_input.c|76| <<virtinput_send_status>> rc = virtqueue_add_outbuf(vi->sts, sg, 1, stsbuf, GFP_ATOMIC);
+ *
+ * 把sg[]数组添加到ring buffer,
+ * 参数的data是vq->desc_state[head].data
+ * 只有一个out, 没有in
+ * ctx是NULL
+ */
 int virtqueue_add_outbuf(struct virtqueue *vq,
 			 struct scatterlist *sg, unsigned int num,
 			 void *data,
 			 gfp_t gfp)
 {
+	/*
+	 * 主函数,把sg[]数组添加到ring buffer,
+	 * 参数的data是vq->desc_state[head].data
+	 * 只有一个out, 没有in
+	 * ctx是NULL
+	 */
 	return virtqueue_add(vq, &sg, num, 1, 0, data, NULL, gfp);
 }
 EXPORT_SYMBOL_GPL(virtqueue_add_outbuf);
@@ -503,11 +719,23 @@ EXPORT_SYMBOL_GPL(virtqueue_add_outbuf);
  *
  * Returns zero or a negative error (ie. ENOSPC, ENOMEM, EIO).
  */
+/*
+ * 把sg[]数组添加到ring buffer,
+ * 参数的data是vq->desc_state[head].data
+ * 只有一个in, 没有out
+ * ctx是NULL
+ */
 int virtqueue_add_inbuf(struct virtqueue *vq,
 			struct scatterlist *sg, unsigned int num,
 			void *data,
 			gfp_t gfp)
 {
+	/*
+	 * 主函数,把sg[]数组添加到ring buffer,
+	 * 参数的data是vq->desc_state[head].data
+	 * 只有一个in, 没有out
+	 * ctx是NULL
+	 */
 	return virtqueue_add(vq, &sg, num, 0, 1, data, NULL, gfp);
 }
 EXPORT_SYMBOL_GPL(virtqueue_add_inbuf);
@@ -526,12 +754,24 @@ EXPORT_SYMBOL_GPL(virtqueue_add_inbuf);
  *
  * Returns zero or a negative error (ie. ENOSPC, ENOMEM, EIO).
  */
+/*
+ * 把sg[]数组添加到ring buffer,
+ * 参数的data是vq->desc_state[head].data
+ * 只有一个in, 没有out
+ * ctx被传送了(不一定是NULL了)
+ */
 int virtqueue_add_inbuf_ctx(struct virtqueue *vq,
 			struct scatterlist *sg, unsigned int num,
 			void *data,
 			void *ctx,
 			gfp_t gfp)
 {
+	/*
+	 * 主函数,把sg[]数组添加到ring buffer,
+	 * 参数的data是vq->desc_state[head].data
+	 * 只有一个in, 没有out
+	 * ctx被传送了(不一定是NULL了)
+	 */
 	return virtqueue_add(vq, &sg, num, 0, 1, data, ctx, gfp);
 }
 EXPORT_SYMBOL_GPL(virtqueue_add_inbuf_ctx);
@@ -547,6 +787,9 @@ EXPORT_SYMBOL_GPL(virtqueue_add_inbuf_ctx);
  * This is sometimes useful because the virtqueue_kick_prepare() needs
  * to be serialized, but the actual virtqueue_notify() call does not.
  */
+/*
+ * 检查ring buffer的指针们返回是否要kick另外一端
+ */
 bool virtqueue_kick_prepare(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -570,10 +813,28 @@ bool virtqueue_kick_prepare(struct virtqueue *_vq)
 	vq->last_add_time_valid = false;
 #endif
 
+	/*
+	 * 在__vring_new_virtqueue()设置:
+	 *   - vq->event = virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);
+	 *
+	 * VIRTIO_RING_F_EVENT_IDX:
+	 *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+	 *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+	 *
+	 * vring_avail_event():
+	 *   返回used的最后一个元素, 告诉前端驱动后端处理到哪个avail ring上的元素了
+	 */
 	if (vq->event) {
+		/*
+		 * 等价于event_idx >= old, 也就是第1个参数大于等于第3个参数
+		 * 也就是当后端处理到哪个avail ring上的元素了大于等于old
+		 */
 		needs_kick = vring_need_event(virtio16_to_cpu(_vq->vdev, vring_avail_event(&vq->vring)),
 					      new, old);
 	} else {
+		/*
+		 * 如果used的flag没有VRING_USED_F_NO_NOTIFY, 就要kick
+		 */
 		needs_kick = !(vq->vring.used->flags & cpu_to_virtio16(_vq->vdev, VRING_USED_F_NO_NOTIFY));
 	}
 	END_USE(vq);
@@ -589,6 +850,19 @@ EXPORT_SYMBOL_GPL(virtqueue_kick_prepare);
  *
  * Returns false if host notify failed or queue is broken, otherwise true.
  */
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|288| <<virtio_queue_rq>> virtqueue_notify(vblk->vqs[qid].vq);
+ *   - drivers/net/virtio_net.c|524| <<virtnet_xdp_xmit>> if (virtqueue_kick_prepare(sq->vq) && virtqueue_notify(sq->vq))
+ *   - drivers/net/virtio_net.c|1208| <<try_fill_recv>> if (virtqueue_kick_prepare(rq->vq) && virtqueue_notify(rq->vq)) {
+ *   - drivers/net/virtio_net.c|1396| <<virtnet_poll>> if (virtqueue_kick_prepare(sq->vq) && virtqueue_notify(sq->vq)) {
+ *   - drivers/net/virtio_net.c|1563| <<start_xmit>> if (virtqueue_kick_prepare(sq->vq) && virtqueue_notify(sq->vq)) {
+ *   - drivers/rpmsg/virtio_rpmsg_bus.c|976| <<rpmsg_probe>> virtqueue_notify(vrp->rvq);
+ *   - drivers/scsi/virtio_scsi.c|481| <<virtscsi_kick_cmd>> virtqueue_notify(vq->vq);
+ *   - drivers/virtio/virtio_ring.c|738| <<virtqueue_kick>> return virtqueue_notify(vq);
+ *
+ * 核心就是调用vring_virtqueue->notify(), 比如vp_notify()
+ */
 bool virtqueue_notify(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -597,6 +871,9 @@ bool virtqueue_notify(struct virtqueue *_vq)
 		return false;
 
 	/* Prod other side to tell it about changes. */
+	/*
+	 * 例子就是vp_notify()
+	 */
 	if (!vq->notify(_vq)) {
 		vq->broken = true;
 		return false;
@@ -617,14 +894,30 @@ EXPORT_SYMBOL_GPL(virtqueue_notify);
  *
  * Returns false if kick failed, otherwise true.
  */
+/*
+ * 检查ring buffer的指针们返回是否要kick另外一端
+ * 如果需要,调用vring_virtqueue->notify(), 比如vp_notify()
+ */
 bool virtqueue_kick(struct virtqueue *vq)
 {
+	/*
+	 * 检查ring buffer的指针们返回是否要kick另外一端
+	 */
 	if (virtqueue_kick_prepare(vq))
 		return virtqueue_notify(vq);
 	return true;
 }
 EXPORT_SYMBOL_GPL(virtqueue_kick);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|965| <<virtqueue_get_buf_ctx>> detach_buf(vq, i, ctx);
+ *   - drivers/virtio/virtio_ring.c|1160| <<virtqueue_detach_unused_buf>> detach_buf(vq, i, NULL);
+ *
+ * 把用到的desc的地址都回收 (自己unmap或通过iommu)
+ * 调用vring_unmap_one()
+ * detach_buf()会清空vq->desc_state[i].data
+ */
 static void detach_buf(struct vring_virtqueue *vq, unsigned int head,
 		       void **ctx)
 {
@@ -637,12 +930,19 @@ static void detach_buf(struct vring_virtqueue *vq, unsigned int head,
 	/* Put back on free list: unmap first-level descriptors and find end */
 	i = head;
 
+	/*
+	 * 只要desc还有next, 就一直回收
+	 */
 	while (vq->vring.desc[i].flags & nextflag) {
 		vring_unmap_one(vq, &vq->vring.desc[i]);
 		i = virtio16_to_cpu(vq->vq.vdev, vq->vring.desc[i].next);
 		vq->vq.num_free++;
 	}
 
+	/*
+	 * 如果不支持iommu(VIRTIO_F_IOMMU_PLATFORM),直接返回就行
+	 * 否则,根据vring_desc->flags是否有VRING_DESC_F_INDIRECT决定调用dma_unmap_single()还是dma_unmap_page()
+	 */
 	vring_unmap_one(vq, &vq->vring.desc[i]);
 	vq->vring.desc[i].next = cpu_to_virtio16(vq->vq.vdev, vq->free_head);
 	vq->free_head = head;
@@ -651,6 +951,12 @@ static void detach_buf(struct vring_virtqueue *vq, unsigned int head,
 	vq->vq.num_free++;
 
 	if (vq->indirect) {
+		/*
+		 * struct vring_desc_state {
+		 *	void *data;                     // Data for callback.
+		 *	struct vring_desc *indir_desc;  // Indirect descriptor, if any.
+		 * };
+		 */
 		struct vring_desc *indir_desc = vq->desc_state[head].indir_desc;
 		u32 len;
 
@@ -674,6 +980,13 @@ static void detach_buf(struct vring_virtqueue *vq, unsigned int head,
 	}
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|1002| <<virtqueue_get_buf_ctx>> if (!more_used(vq)) {
+ *   - drivers/virtio/virtio_ring.c|1309| <<vring_interrupt>> if (!more_used(vq)) {
+ *
+ * 是否还有没处理的used?
+ */
 static inline bool more_used(const struct vring_virtqueue *vq)
 {
 	return vq->last_used_idx != virtio16_to_cpu(vq->vq.vdev, vq->vring.used->idx);
@@ -695,6 +1008,16 @@ static inline bool more_used(const struct vring_virtqueue *vq)
  * Returns NULL if there are no used buffers, or the "data" token
  * handed to virtqueue_add_*().
  */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|1015| <<virtqueue_get_buf>> return virtqueue_get_buf_ctx(_vq, len, NULL);
+ *   - drivers/net/virtio_net.c|908| <<receive_mergeable>> buf = virtqueue_get_buf_ctx(rq->vq, &len, &ctx);
+ *   - drivers/net/virtio_net.c|1297| <<virtnet_receive>> (buf = virtqueue_get_buf_ctx(rq->vq, &len, &ctx))) {
+ *
+ * 取出used中下一个元素, 参数的len返回vq->vring.used->ring[last_used].len
+ * 把用到的desc的地址都回收 (自己unmap或通过iommu)
+ * 函数返回vq->desc_state[i].data
+ */
 void *virtqueue_get_buf_ctx(struct virtqueue *_vq, unsigned int *len,
 			    void **ctx)
 {
@@ -710,6 +1033,9 @@ void *virtqueue_get_buf_ctx(struct virtqueue *_vq, unsigned int *len,
 		return NULL;
 	}
 
+	/*
+	 * 是否还有没处理的used?
+	 */
 	if (!more_used(vq)) {
 		pr_debug("No more buffers in queue\n");
 		END_USE(vq);
@@ -734,6 +1060,11 @@ void *virtqueue_get_buf_ctx(struct virtqueue *_vq, unsigned int *len,
 
 	/* detach_buf clears data, so grab it now. */
 	ret = vq->desc_state[i].data;
+	/*
+	 * 把用到的desc的地址都回收 (自己unmap或通过iommu)
+	 * 调用vring_unmap_one()
+	 * detach_buf()会清空vq->desc_state[i].data
+	 */
 	detach_buf(vq, i, ctx);
 	vq->last_used_idx++;
 	/* If we expect an interrupt for the next entry, tell host
@@ -753,8 +1084,29 @@ void *virtqueue_get_buf_ctx(struct virtqueue *_vq, unsigned int *len,
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_buf_ctx);
 
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|201| <<virtblk_done>> while ((vbr = virtqueue_get_buf(vblk->vqs[qid].vq, &len)) != NULL) {
+ *   - drivers/scsi/virtio_scsi.c|222| <<virtscsi_vq_done>> while ((buf = virtqueue_get_buf(vq, &len)) != NULL)
+ *   - drivers/net/virtio_net.c|509| <<virtnet_xdp_xmit>> while ((xdpf_sent = virtqueue_get_buf(sq->vq, &len)) != NULL)
+ *   - drivers/net/virtio_net.c|577| <<xdp_linearize_page>> buf = virtqueue_get_buf(rq->vq, &buflen);
+ *   - drivers/net/virtio_net.c|968| <<receive_mergeable>> buf = virtqueue_get_buf(rq->vq, &len);
+ *   - drivers/net/virtio_net.c|1303| <<virtnet_receive>> (buf = virtqueue_get_buf(rq->vq, &len)) != NULL) {
+ *   - drivers/net/virtio_net.c|1334| <<free_old_xmit_skbs>> while ((skb = virtqueue_get_buf(sq->vq, &len)) != NULL) {
+ *   - drivers/net/virtio_net.c|1610| <<virtnet_send_command>> while (!virtqueue_get_buf(vi->cvq, &tmp) &&
+ *
+ * 取出used中下一个元素, 参数的len返回vq->vring.used->ring[last_used].len
+ * 把用到的desc的地址都回收 (自己unmap或通过iommu)
+ * 函数返回vq->desc_state[i].data
+ * 不过virtqueue_get_buf_ctx()的ctx是NULL
+ */
 void *virtqueue_get_buf(struct virtqueue *_vq, unsigned int *len)
 {
+	/*
+	 * 取出used中下一个元素, 参数的len返回vq->vring.used->ring[last_used].len
+	 * 把用到的desc的地址都回收 (自己unmap或通过iommu)
+	 * 函数返回vq->desc_state[i].data
+	 */
 	return virtqueue_get_buf_ctx(_vq, len, NULL);
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_buf);
@@ -767,6 +1119,10 @@ EXPORT_SYMBOL_GPL(virtqueue_get_buf);
  *
  * Unlike other operations, this need not be serialized.
  */
+/*
+ * 在avail的flags里设置VRING_AVAIL_F_NO_INTERRUPT,禁止后端中断前端
+ * 针对某个queue
+ */
 void virtqueue_disable_cb(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -792,6 +1148,14 @@ EXPORT_SYMBOL_GPL(virtqueue_disable_cb);
  * Caller must ensure we don't call this with other virtqueue
  * operations at the same time (except where noted).
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|322| <<virtqueue_napi_complete>> opaque = virtqueue_enable_cb_prepare(vq);
+ *   - drivers/virtio/virtio_ring.c|849| <<virtqueue_enable_cb>> unsigned last_used_idx = virtqueue_enable_cb_prepare(_vq);
+ *
+ * 如果禁止了这个queue的中断就重新启用VRING_AVAIL_F_NO_INTERRUPT
+ * 设置avail的最后一个元素为vq->last_used_idx并返回vq->last_used_idx
+ */
 unsigned virtqueue_enable_cb_prepare(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -804,11 +1168,31 @@ unsigned virtqueue_enable_cb_prepare(struct virtqueue *_vq)
 	/* Depending on the VIRTIO_RING_F_EVENT_IDX feature, we need to
 	 * either clear the flags bit or point the event index at the next
 	 * entry. Always do both to keep code simple. */
+	/*
+	 * 如果禁止了这个queue的中断就重新启用
+	 */
 	if (vq->avail_flags_shadow & VRING_AVAIL_F_NO_INTERRUPT) {
 		vq->avail_flags_shadow &= ~VRING_AVAIL_F_NO_INTERRUPT;
+		/*
+		 * 在__vring_new_virtqueue()设置:
+		 *   - vq->event = virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);
+		 *
+		 * VIRTIO_RING_F_EVENT_IDX:
+		 *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+		 *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+		 */
 		if (!vq->event)
 			vq->vring.avail->flags = cpu_to_virtio16(_vq->vdev, vq->avail_flags_shadow);
 	}
+	/*
+	 * 返回avail的最后的一个元素, 告诉后端,处理到那个used ring了
+	 *
+	 * VIRTIO_RING_F_EVENT_IDX:
+	 *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+	 *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+	 *
+	 * 这里其实是设置avail的最后一个元素为vq->last_used_idx
+	 */
 	vring_used_event(&vq->vring) = cpu_to_virtio16(_vq->vdev, last_used_idx = vq->last_used_idx);
 	END_USE(vq);
 	return last_used_idx;
@@ -824,6 +1208,13 @@ EXPORT_SYMBOL_GPL(virtqueue_enable_cb_prepare);
  *
  * This does not need to be serialized.
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|324| <<virtqueue_napi_complete>> if (unlikely(virtqueue_poll(vq, opaque)))
+ *   - drivers/virtio/virtio_ring.c|970| <<virtqueue_enable_cb>> return !virtqueue_poll(_vq, last_used_idx);
+ *
+ * 如果参数的last_used_idx不等于used的idx, 返回true
+ */
 bool virtqueue_poll(struct virtqueue *_vq, unsigned last_used_idx)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -844,9 +1235,34 @@ EXPORT_SYMBOL_GPL(virtqueue_poll);
  * Caller must ensure we don't call this with other virtqueue
  * operations at the same time (except where noted).
  */
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|209| <<virtblk_done>> } while (!virtqueue_enable_cb(vq));
+ *   - drivers/scsi/virtio_scsi.c|227| <<virtscsi_vq_done>> } while (!virtqueue_enable_cb(vq));
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|56| <<virtcrypto_dataq_callback>> } while (!virtqueue_enable_cb(vq));
+ *   - drivers/gpu/drm/virtio/virtgpu_vq.c|211| <<virtio_gpu_dequeue_ctrl_func>> } while (!virtqueue_enable_cb(vgdev->ctrlq.vq));
+ *   - drivers/gpu/drm/virtio/virtgpu_vq.c|253| <<virtio_gpu_dequeue_cursor_func>> } while (!virtqueue_enable_cb(vgdev->cursorq.vq));
+ *   - drivers/net/caif/caif_virtio.c|565| <<cfv_netdev_tx>> virtqueue_enable_cb(cfv->vq_tx);
+ *   - drivers/rpmsg/virtio_rpmsg_bus.c|488| <<rpmsg_upref_sleepers>> virtqueue_enable_cb(vrp->svq);
+ *   - net/vmw_vsock/virtio_transport.c|317| <<virtio_transport_tx_work>> } while (!virtqueue_enable_cb(vq));
+ *   - net/vmw_vsock/virtio_transport.c|378| <<virtio_transport_rx_work>> } while (!virtqueue_enable_cb(vq));
+ *   - net/vmw_vsock/virtio_transport.c|466| <<virtio_transport_event_work>> } while (!virtqueue_enable_cb(vq));
+ *
+ * 如果禁止了这个queue的中断就重新启用VRING_AVAIL_F_NO_INTERRUPT
+ * 设置avail的最后一个元素为vq->last_used_idx
+ * 如果vq->last_used_idx等于used的idx,返回true
+ */
 bool virtqueue_enable_cb(struct virtqueue *_vq)
 {
+	/*
+	 * 如果禁止了这个queue的中断就重新启用VRING_AVAIL_F_NO_INTERRUPT
+	 * 设置avail的最后一个元素为vq->last_used_idx并返回vq->last_used_idx
+	 */
 	unsigned last_used_idx = virtqueue_enable_cb_prepare(_vq);
+	/*
+	 * virtqueue_poll()
+	 *   如果参数的last_used_idx不等于used的idx, 返回true
+	 */
 	return !virtqueue_poll(_vq, last_used_idx);
 }
 EXPORT_SYMBOL_GPL(virtqueue_enable_cb);
@@ -864,6 +1280,11 @@ EXPORT_SYMBOL_GPL(virtqueue_enable_cb);
  * Caller must ensure we don't call this with other virtqueue
  * operations at the same time (except where noted).
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|1514| <<start_xmit>> virtqueue_enable_cb_delayed(sq->vq);
+ *   - drivers/net/virtio_net.c|1552| <<start_xmit>> unlikely(!virtqueue_enable_cb_delayed(sq->vq))) {
+ */
 bool virtqueue_enable_cb_delayed(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -906,6 +1327,17 @@ EXPORT_SYMBOL_GPL(virtqueue_enable_cb_delayed);
  * This is not valid on an active queue; it is useful only for device
  * shutdown.
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|2556| <<free_unused_bufs>> while ((buf = virtqueue_detach_unused_buf(vq)) != NULL) {
+ *   - drivers/net/virtio_net.c|2567| <<free_unused_bufs>> while ((buf = virtqueue_detach_unused_buf(vq)) != NULL) {
+ *   - drivers/char/virtio_console.c|1967| <<remove_vqs>> while ((buf = virtqueue_detach_unused_buf(vq)))
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|436| <<virtcrypto_free_unused_reqs>> while ((vc_req = virtqueue_detach_unused_buf(vq)) != NULL) {
+ *   - drivers/net/caif/caif_virtio.c|469| <<cfv_netdev_close>> while ((buf_info = virtqueue_detach_unused_buf(cfv->vq_tx)))
+ *   - drivers/virtio/virtio_input.c|325| <<virtinput_remove>> while ((buf = virtqueue_detach_unused_buf(vi->sts)) != NULL)
+ *   - net/vmw_vsock/virtio_transport.c|643| <<virtio_vsock_remove>> while ((pkt = virtqueue_detach_unused_buf(vsock->vqs[VSOCK_VQ_RX])))
+ *   - net/vmw_vsock/virtio_transport.c|648| <<virtio_vsock_remove>> while ((pkt = virtqueue_detach_unused_buf(vsock->vqs[VSOCK_VQ_TX])))
+ */
 void *virtqueue_detach_unused_buf(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -914,12 +1346,29 @@ void *virtqueue_detach_unused_buf(struct virtqueue *_vq)
 
 	START_USE(vq);
 
+	/*
+	 * 遍历ring buffer所有的vring_virtqueue->desc_state[i]!!!
+	 * 这个设计不如xen!
+	 */
 	for (i = 0; i < vq->vring.num; i++) {
 		if (!vq->desc_state[i].data)
 			continue;
 		/* detach_buf clears data, so grab it now. */
 		buf = vq->desc_state[i].data;
+		/*
+		 * 把用到的desc的地址都回收 (自己unmap或通过iommu)
+		 * 调用vring_unmap_one()
+		 *
+		 * detach_buf()会清空vq->desc_state[i].data
+		 */
 		detach_buf(vq, i, NULL);
+		/*
+		 * 增加的地方:
+		 *   - drivers/virtio/virtio_ring.c|552| <<virtqueue_add>> vq->avail_idx_shadow++;
+		 *
+		 * 减少的地方:
+		 *   - drivers/virtio/virtio_ring.c|1161| <<virtqueue_detach_unused_buf>> vq->avail_idx_shadow--;
+		 */
 		vq->avail_idx_shadow--;
 		vq->vring.avail->idx = cpu_to_virtio16(_vq->vdev, vq->avail_idx_shadow);
 		END_USE(vq);
@@ -933,10 +1382,18 @@ void *virtqueue_detach_unused_buf(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_detach_unused_buf);
 
+/*
+ * 中断处理函数的实现, 调用vring_virtqueue->vq.callback()
+ * callback的例子:
+ *   - block: virtblk_done()
+ *   - net: skb_xmit_done()和skb_recv_done()
+ *   - scsi: virtscsi_event_done()和virtscsi_ctrl_done()
+ */
 irqreturn_t vring_interrupt(int irq, void *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
 
+	/* 没有used work要处理 */
 	if (!more_used(vq)) {
 		pr_debug("virtqueue interrupt with no work for %p\n", vq);
 		return IRQ_NONE;
@@ -946,6 +1403,12 @@ irqreturn_t vring_interrupt(int irq, void *_vq)
 		return IRQ_HANDLED;
 
 	pr_debug("virtqueue callback for %p (%p)\n", vq, vq->vq.callback);
+	/*
+	 * callback的例子:
+	 *   - block: virtblk_done()
+	 *   - net: skb_xmit_done()和skb_recv_done()
+	 *   - scsi: virtscsi_event_done()和virtscsi_ctrl_done()
+	 */
 	if (vq->vq.callback)
 		vq->vq.callback(&vq->vq);
 
@@ -953,6 +1416,22 @@ irqreturn_t vring_interrupt(int irq, void *_vq)
 }
 EXPORT_SYMBOL_GPL(vring_interrupt);
 
+/*
+ * called by:
+ *   - vring_new_virtqueue()
+ *   - vring_create_virtqueue()
+ *
+ * 分配并简单初始化vring_virtqueue,后面跟着vring.num个struct vring_desc_state
+ * callback设置为vring_virtqueue->vq.callback
+ * 返回vring_virtqueue所包含的virtqueue
+ *
+ * callback的例子:
+ *   - block: virtblk_done()
+ *   - net: skb_xmit_done()和skb_recv_done()
+ *   - scsi: virtscsi_event_done()和virtscsi_ctrl_done()
+ * callback只被以下调用:
+ *   - drivers/virtio/virtio_ring.c|1181| <<vring_interrupt>> vq->vq.callback(&vq->vq);
+ */
 struct virtqueue *__vring_new_virtqueue(unsigned int index,
 					struct vring vring,
 					struct virtio_device *vdev,
@@ -971,6 +1450,15 @@ struct virtqueue *__vring_new_virtqueue(unsigned int index,
 		return NULL;
 
 	vq->vring = vring;
+	/*
+	 * callback的例子:
+	 *   - block: virtblk_done()
+	 *   - net: skb_xmit_done()和skb_recv_done()
+	 *   - scsi: virtscsi_event_done()和virtscsi_ctrl_done()
+	 *
+	 * 只被以下调用:
+	 *   - drivers/virtio/virtio_ring.c|1181| <<vring_interrupt>> vq->vq.callback(&vq->vq);
+	 */
 	vq->vq.callback = callback;
 	vq->vq.vdev = vdev;
 	vq->vq.name = name;
@@ -984,6 +1472,13 @@ struct virtqueue *__vring_new_virtqueue(unsigned int index,
 	vq->broken = false;
 	vq->last_used_idx = 0;
 	vq->avail_flags_shadow = 0;
+	/*
+	 * 增加的地方:
+	 *   - drivers/virtio/virtio_ring.c|552| <<virtqueue_add>> vq->avail_idx_shadow++;
+	 *
+	 * 减少的地方:
+	 *   - drivers/virtio/virtio_ring.c|1161| <<virtqueue_detach_unused_buf>> vq->avail_idx_shadow--;
+	 */
 	vq->avail_idx_shadow = 0;
 	vq->num_added = 0;
 	list_add_tail(&vq->vq.list, &vdev->vqs);
@@ -994,6 +1489,11 @@ struct virtqueue *__vring_new_virtqueue(unsigned int index,
 
 	vq->indirect = virtio_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC) &&
 		!context;
+	/*
+	 * VIRTIO_RING_F_EVENT_IDX:
+	 *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+	 *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+	 */
 	vq->event = virtio_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);
 
 	/* No callback?  Tell other side not to bother us. */
@@ -1013,9 +1513,21 @@ struct virtqueue *__vring_new_virtqueue(unsigned int index,
 }
 EXPORT_SYMBOL_GPL(__vring_new_virtqueue);
 
+/*
+ * 在vring_create_virtqueue()的两处被调用
+ *
+ * 分配size的内存,如果支持iommu(VIRTIO_F_IOMMU_PLATFORM), 可能间接调用ops->alloc
+ * 否则直接使用分配的物理地址
+ */
 static void *vring_alloc_queue(struct virtio_device *vdev, size_t size,
 			      dma_addr_t *dma_handle, gfp_t flag)
 {
+	/*
+	 * 返回true说明支持iommu (VIRTIO_F_IOMMU_PLATFORM)
+	 *
+	 * 如果支持iommu, 可能间接调用ops->alloc
+	 * 否则直接使用分配的物理地址
+	 */
 	if (vring_use_dma_api(vdev)) {
 		return dma_alloc_coherent(vdev->dev.parent, size,
 					  dma_handle, flag);
@@ -1045,9 +1557,20 @@ static void *vring_alloc_queue(struct virtio_device *vdev, size_t size,
 	}
 }
 
+/*
+ * called by:
+ *   - vring_del_virtqueue()
+ *   - vring_create_virtqueue()
+ *
+ * 释放size的内存,如果支持iommu, 可能间接调用ops->free
+ * 否则直接释放就行
+ */
 static void vring_free_queue(struct virtio_device *vdev, size_t size,
 			     void *queue, dma_addr_t dma_handle)
 {
+	/*
+	 * 返回true说明支持iommu (VIRTIO_F_IOMMU_PLATFORM)
+	 */
 	if (vring_use_dma_api(vdev)) {
 		dma_free_coherent(vdev->dev.parent, size, queue, dma_handle);
 	} else {
@@ -1055,6 +1578,25 @@ static void vring_free_queue(struct virtio_device *vdev, size_t size,
 	}
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_legacy.c|285| <<setup_vq>>
+ *                          vq = vring_create_virtqueue(index, num,
+ *                                                      VIRTIO_PCI_VRING_ALIGN, &vp_dev->vdev,
+ *                                                      true, false, ctx,
+ *                                                      vp_notify, callback, name);
+ *   - drivers/virtio/virtio_pci_modern.c|440| <<setup_vq>>
+ *                          vq = vring_create_virtqueue(index, num,
+ *                                                      SMP_CACHE_BYTES, &vp_dev->vdev,
+ *                                                      true, true, ctx,
+ *                                                      vp_notify, callback, name);
+ *   - drivers/virtio/virtio_mmio.c|390| <<vm_setup_vq>>
+ *                          vq = vring_create_virtqueue(index, num, VIRTIO_MMIO_VRING_ALIGN, vdev,
+ *                                                      true, true, ctx, vm_notify, callback, name);
+ *
+ * 分配并初始化vring_virtqueue, 返回其包含的virtqueue
+ * 会分配ring buffer, 初始化包含的vring和virtqueue
+ */
 struct virtqueue *vring_create_virtqueue(
 	unsigned int index,
 	unsigned int num,
@@ -1081,6 +1623,12 @@ struct virtqueue *vring_create_virtqueue(
 
 	/* TODO: allocate each queue chunk individually */
 	for (; num && vring_size(num, vring_align) > PAGE_SIZE; num /= 2) {
+		/*
+		 * 分配vring_size(num, vring_align)的内存,如果支持iommu(VIRTIO_F_IOMMU_PLATFORM), 可能间接调用ops->alloc
+		 * 否则直接使用分配的物理地址
+		 *
+		 * vring_size(): 分配desc,avail和used等其他指针作为一个连续的内存
+		 */
 		queue = vring_alloc_queue(vdev, vring_size(num, vring_align),
 					  &dma_addr,
 					  GFP_KERNEL|__GFP_NOWARN|__GFP_ZERO);
@@ -1100,17 +1648,45 @@ struct virtqueue *vring_create_virtqueue(
 		return NULL;
 
 	queue_size_in_bytes = vring_size(num, vring_align);
+	/*
+	 * queue是desc,avail和used等其他指针作为一个连续的内存
+	 * 让vring的指针们指向内存中对应的位置
+	 */
 	vring_init(&vring, num, queue, vring_align);
 
+	/*
+	 * 分配并简单初始化vring_virtqueue,后面跟着vring.num个struct vring_desc_state
+	 * 返回vring_virtqueue所包含的virtqueue
+	 *
+	 * callback的例子可以是vp_notify(pci)或者vm_notify(mmio)
+	 * callback被设置为vring_virtqueue->vq.callback
+	 *
+	 * callback的例子:
+	 *   - block: virtblk_done()
+	 *   - net: skb_xmit_done()和skb_recv_done()
+	 *   - scsi: virtscsi_event_done()和virtscsi_ctrl_done()
+	 */
 	vq = __vring_new_virtqueue(index, vring, vdev, weak_barriers, context,
 				   notify, callback, name);
 	if (!vq) {
+		/*
+		 * 释放queue_size_in_bytes的内存,如果支持iommu, 可能间接调用ops->free
+		 * 否则直接释放就行
+		 */
 		vring_free_queue(vdev, queue_size_in_bytes, queue,
 				 dma_addr);
 		return NULL;
 	}
 
+	/*
+	 * dma_addr是desc,avail和used等其他指针作为一个连续的内存
+	 * 也就是所有的ring buffer
+	 */
 	to_vvq(vq)->queue_dma_addr = dma_addr;
+	/*
+	 * queue_size_in_bytes是desc,avail和used等其他指针作为一个连续的内存的大小
+	 * 也就是所有ring buffer的大小
+	 */
 	to_vvq(vq)->queue_size_in_bytes = queue_size_in_bytes;
 	to_vvq(vq)->we_own_ring = true;
 
@@ -1118,6 +1694,15 @@ struct virtqueue *vring_create_virtqueue(
 }
 EXPORT_SYMBOL_GPL(vring_create_virtqueue);
 
+/*
+ * called by:
+ *   - drivers/misc/mic/vop/vop_main.c|312| <<vop_find_vq>> vq = vring_new_virtqueue(
+ *   - drivers/remoteproc/remoteproc_virtio.c|106| <<rp_find_vq>> vq = vring_new_virtqueue(id, len, rvring->align, vdev, false, ctx,
+ *   - drivers/s390/virtio/virtio_ccw.c|521| <<virtio_ccw_setup_vq>> vq = vring_new_virtqueue(i, info->num, KVM_VIRTIO_CCW_RING_ALIGN, vdev,
+ *
+ * 分配并初始化vring_virtqueue, 返回其包含的virtqueue
+ * 但是ring buffer和vring是caller分配的
+ */
 struct virtqueue *vring_new_virtqueue(unsigned int index,
 				      unsigned int num,
 				      unsigned int vring_align,
@@ -1130,17 +1715,33 @@ struct virtqueue *vring_new_virtqueue(unsigned int index,
 				      const char *name)
 {
 	struct vring vring;
+	/*
+	 * page是desc,avail和used等其他指针作为一个连续的内存
+	 * 让vring的指针们指向内存中对应的位置
+	 */
 	vring_init(&vring, num, pages, vring_align);
+	/*
+	 * 分配并简单初始化vring_virtqueue,后面跟着vring.num个struct vring_desc_state
+	 * callback设置为vring_virtqueue->vq.callback
+	 * 返回vring_virtqueue所包含的virtqueue
+	 */
 	return __vring_new_virtqueue(index, vring, vdev, weak_barriers, context,
 				     notify, callback, name);
 }
 EXPORT_SYMBOL_GPL(vring_new_virtqueue);
 
+/*
+ * 释放vring_virtqueue并在virtio_device->vqs链表移除
+ */
 void vring_del_virtqueue(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
 
 	if (vq->we_own_ring) {
+		/*
+		 * 释放size的内存,如果支持iommu, 可能间接调用ops->free
+		 * 否则直接释放就行
+		 */
 		vring_free_queue(vq->vq.vdev, vq->queue_size_in_bytes,
 				 vq->vring.desc, vq->queue_dma_addr);
 	}
@@ -1150,6 +1751,15 @@ void vring_del_virtqueue(struct virtqueue *_vq)
 EXPORT_SYMBOL_GPL(vring_del_virtqueue);
 
 /* Manipulates transport-specific feature bits. */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_legacy.c|66| <<vp_finalize_features>> vring_transport_features(vdev);
+ *   - drivers/virtio/virtio_pci_modern.c|212| <<vp_finalize_features>> vring_transport_features(vdev);
+ *   - drivers/virtio/virtio_mmio.c|131| <<vm_finalize_features>> vring_transport_features(vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|792| <<virtio_ccw_finalize_features>> vring_transport_features(vdev);
+ *   - drivers/misc/mic/vop/vop_main.c|142| <<vop_finalize_features>> vring_transport_features(vdev);
+ *   - drivers/remoteproc/remoteproc_virtio.c|213| <<rproc_virtio_finalize_features>> vring_transport_features(vdev);
+ */
 void vring_transport_features(struct virtio_device *vdev)
 {
 	unsigned int i;
@@ -1179,6 +1789,9 @@ EXPORT_SYMBOL_GPL(vring_transport_features);
  * Returns the size of the vring.  This is mainly used for boasting to
  * userspace.  Unlike other operations, this need not be serialized.
  */
+/*
+ * 返回vring.num, ring buffer的大小
+ */
 unsigned int virtqueue_get_vring_size(struct virtqueue *_vq)
 {
 
@@ -1188,10 +1801,29 @@ unsigned int virtqueue_get_vring_size(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_vring_size);
 
+/*
+ * called by:
+ *   - drivers/block/virtio_blk.c|207| <<virtblk_done>> if (unlikely(virtqueue_is_broken(vq)))
+ *   - drivers/char/virtio_console.c|583| <<__send_control_msg>> && !virtqueue_is_broken(vq))
+ *   - drivers/char/virtio_console.c|658| <<__send_to_port>> && !virtqueue_is_broken(out_vq))
+ *   - drivers/crypto/virtio/virtio_crypto_algs.c|195| <<virtio_crypto_alg_ablkcipher_init_session>> !virtqueue_is_broken(vcrypto->ctrl_vq))
+ *   - drivers/crypto/virtio/virtio_crypto_algs.c|264| <<virtio_crypto_alg_ablkcipher_close_session>> !virtqueue_is_broken(vcrypto->ctrl_vq))
+ *   - drivers/net/virtio_net.c|1611| <<virtnet_send_command>> !virtqueue_is_broken(vi->cvq))
+ *   - drivers/scsi/virtio_scsi.c|225| <<virtscsi_vq_done>> if (unlikely(virtqueue_is_broken(vq)))
+ *
+ * 返回包含参数virtqueue的vring_virtqueue->broken
+ */
 bool virtqueue_is_broken(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
 
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_ring.c|52| <<BAD_RING>> (_vq)->broken = true; \
+	 *   - drivers/virtio/virtio_ring.c|822| <<virtqueue_notify>> vq->broken = true;
+	 *   - __vring_new_virtqueue()设置为false
+	 *   - drivers/virtio/virtio_ring.c|1544| <<virtio_break_device>> vq->broken = true;
+	 */
 	return vq->broken;
 }
 EXPORT_SYMBOL_GPL(virtqueue_is_broken);
@@ -1200,6 +1832,14 @@ EXPORT_SYMBOL_GPL(virtqueue_is_broken);
  * This should prevent the device from being used, allowing drivers to
  * recover.  You may need to grab appropriate locks to flush.
  */
+/*
+ * 只被以下调用:
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|230| <<virtcrypto_update_status>> virtio_break_device(vcrypto->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1146| <<virtio_ccw_remove>> virtio_break_device(&vcdev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1163| <<virtio_ccw_offline>> virtio_break_device(&vcdev->vdev);
+ *
+ * 把virtio_device的vqs链表上所有的vring_virtqueue都设置成broken
+ */
 void virtio_break_device(struct virtio_device *dev)
 {
 	struct virtqueue *_vq;
@@ -1211,6 +1851,10 @@ void virtio_break_device(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_break_device);
 
+/*
+ * ring buffer是一个包含desc,avail和used等其他指针作为一个连续的内存
+ * 返回desc的基地址
+ */
 dma_addr_t virtqueue_get_desc_addr(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -1221,6 +1865,10 @@ dma_addr_t virtqueue_get_desc_addr(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_desc_addr);
 
+/*
+ * ring buffer是一个包含desc,avail和used等其他指针作为一个连续的内存
+ * 返回avail的基地址
+ */
 dma_addr_t virtqueue_get_avail_addr(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
@@ -1232,17 +1880,29 @@ dma_addr_t virtqueue_get_avail_addr(struct virtqueue *_vq)
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_avail_addr);
 
+/*
+ * ring buffer是一个包含desc,avail和used等其他指针作为一个连续的内存
+ * 返回used的基地址
+ */
 dma_addr_t virtqueue_get_used_addr(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
 
 	BUG_ON(!vq->we_own_ring);
 
+	/*
+	 * 在vring_create_virtqueue()被初始化为ring buffer的基地址
+	 * 是desc,avail和used等其他指针作为一个连续的内存
+	 */
 	return vq->queue_dma_addr +
 		((char *)vq->vring.used - (char *)vq->vring.desc);
 }
 EXPORT_SYMBOL_GPL(virtqueue_get_used_addr);
 
+/*
+ * vring_virtqueue包含vring和virtqueue
+ * 给一个virtqueue返回vring
+ */
 const struct vring *virtqueue_get_vring(struct virtqueue *vq)
 {
 	return &to_vvq(vq)->vring;
diff --git a/include/linux/virtio.h b/include/linux/virtio.h
index fa1b5da..56fb1b0 100644
--- a/include/linux/virtio.h
+++ b/include/linux/virtio.h
@@ -27,11 +27,31 @@
  */
 struct virtqueue {
 	struct list_head list;
+	/*
+	 * callback的例子:
+	 *   - block: virtblk_done()
+	 *   - net: skb_xmit_done()和skb_recv_done()
+	 *   - scsi: virtscsi_event_done()和virtscsi_ctrl_done()
+	 *
+	 * 只被以下调用:
+	 *   - drivers/virtio/virtio_ring.c|1181| <<vring_interrupt>> vq->vq.callback(&vq->vq);
+	 */
 	void (*callback)(struct virtqueue *vq);
 	const char *name;
 	struct virtio_device *vdev;
 	unsigned int index;
 	unsigned int num_free;
+	/*
+	 * priv设置的地方:
+	 *   - drivers/virtio/virtio_pci_legacy.c|157| <<setup_vq>> vq->priv = (void __force *)vp_dev->ioaddr + VIRTIO_PCI_QUEUE_NOTIFY;
+	 *   - drivers/virtio/virtio_pci_modern.c|372| <<setup_vq>> vq->priv = (void __force *)vp_dev->notify_base +
+	 *                                                                  off * vp_dev->notify_offset_multiplier;
+	 *   - drivers/virtio/virtio_pci_modern.c|375| <<setup_vq>> vq->priv = (void __force *)map_capability(vp_dev->pci_dev,
+	 *                                                                                    vp_dev->notify_map_cap, 2, 2,
+	 *                                                                                    off * vp_dev->notify_offset_multiplier, 2,
+	 *                                                                                    NULL);
+	 *   - drivers/virtio/virtio_mmio.c|438| <<vm_setup_vq>> vq->priv = info;
+	 */
 	void *priv;
 };
 
@@ -130,10 +150,20 @@ struct virtio_device {
 	spinlock_t config_lock;
 	struct device dev;
 	struct virtio_device_id id;
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	const struct virtio_config_ops *config;
 	const struct vringh_config_ops *vringh_config;
 	struct list_head vqs;
 	u64 features;
+	/*
+	 * 一个例子是在virtblk_probe()设置为struct virtio_blk
+	 */
 	void *priv;
 };
 
@@ -188,6 +218,10 @@ struct virtio_driver {
 	int (*probe)(struct virtio_device *dev);
 	void (*scan)(struct virtio_device *dev);
 	void (*remove)(struct virtio_device *dev);
+	/*
+	 * called only by:
+	 *   - drivers/virtio/virtio.c|181| <<__virtio_config_changed>> drv->config_changed(dev);
+	 */
 	void (*config_changed)(struct virtio_device *dev);
 #ifdef CONFIG_PM
 	int (*freeze)(struct virtio_device *dev);
diff --git a/include/linux/virtio_config.h b/include/linux/virtio_config.h
index 32baf8e..3fb1a70 100644
--- a/include/linux/virtio_config.h
+++ b/include/linux/virtio_config.h
@@ -63,19 +63,77 @@ struct irq_affinity;
  */
 typedef void vq_callback_t(struct virtqueue *);
 struct virtio_config_ops {
+	/*
+	 * called by:
+	 *   - include/linux/virtio_config.h|364| <<__virtio_cread_many>> vdev->config->get(vdev, offset + bytes * i,
+	 *   - include/linux/virtio_config.h|382| <<virtio_cread8>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+	 *   - include/linux/virtio_config.h|396| <<virtio_cread16>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+	 *   - include/linux/virtio_config.h|411| <<virtio_cread32>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+	 *   - net/vmw_vsock/virtio_transport.c|428| <<virtio_vsock_update_guest_cid>> vdev->config->get(vdev, offsetof(struct virtio_vsock_config, guest_cid),
+	 */
 	void (*get)(struct virtio_device *vdev, unsigned offset,
 		    void *buf, unsigned len);
+	/*
+	 * called by:
+	 *   - include/linux/virtio_config.h|389| <<virtio_cwrite8>> vdev->config->set(vdev, offset, &val, sizeof(val));
+	 *   - include/linux/virtio_config.h|404| <<virtio_cwrite16>> vdev->config->set(vdev, offset, &val, sizeof(val));
+	 *   - include/linux/virtio_config.h|419| <<virtio_cwrite32>> vdev->config->set(vdev, offset, &val, sizeof(val));
+	 *   - include/linux/virtio_config.h|434| <<virtio_cwrite64>> vdev->config->set(vdev, offset, &val, sizeof(val));
+	 */
 	void (*set)(struct virtio_device *vdev, unsigned offset,
 		    const void *buf, unsigned len);
 	u32 (*generation)(struct virtio_device *vdev);
+	/*
+	 * called by:
+	 *   - drivers/virtio/virtio.c|31| <<status_show>> return sprintf(buf, "0x%08x\n", dev->config->get_status(dev));
+	 *   - drivers/virtio/virtio.c|248| <<virtio_add_status>> dev->config->set_status(dev, dev->config->get_status(dev) | status);
+	 *   - drivers/virtio/virtio.c|264| <<virtio_finalize_features>> status = dev->config->get_status(dev);
+	 *   - drivers/virtio/virtio.c|378| <<virtio_dev_probe>> if (!(dev->config->get_status(dev) & VIRTIO_CONFIG_S_DRIVER_OK))
+	 *   - drivers/virtio/virtio.c|427| <<virtio_dev_remove>> WARN_ON_ONCE(dev->config->get_status(dev));
+	 *   - drivers/virtio/virtio.c|550| <<virtio_device_freeze>> dev->failed = dev->config->get_status(dev) & VIRTIO_CONFIG_S_FAILED;
+	 *   - drivers/virtio/virtio_pci_common.c|862| <<virtio_pci_sriov_configure>> if (!(vdev->config->get_status(vdev) & VIRTIO_CONFIG_S_DRIVER_OK))
+	 *   - include/linux/virtio_config.h|220| <<virtio_device_ready>> unsigned status = dev->config->get_status(dev);
+	 */
 	u8 (*get_status)(struct virtio_device *vdev);
+	/*
+	 * called by:
+	 *   - drivers/virtio/virtio.c|248| <<virtio_add_status>> dev->config->set_status(dev, dev->config->get_status(dev) | status);
+	 *   - include/linux/virtio_config.h|249| <<virtio_device_ready>> dev->config->set_status(dev, status | VIRTIO_CONFIG_S_DRIVER_OK);
+	 */
 	void (*set_status)(struct virtio_device *vdev, u8 status);
+	/*
+	 * called by:
+	 *   - drivers/virtio/virtio.c|508| <<register_virtio_device>> dev->config->reset(dev);
+	 *   - drivers/virtio/virtio.c|571| <<virtio_device_restore>> dev->config->reset(dev);
+	 *   - drivers/block/virtio_blk.c|907| <<virtblk_remove>> vdev->config->reset(vdev);
+	 *   - drivers/block/virtio_blk.c|929| <<virtblk_freeze>> vdev->config->reset(vdev);
+	 *   - drivers/scsi/virtio_scsi.c|781| <<virtscsi_remove_vqs>> vdev->config->reset(vdev);
+	 *   - drivers/net/virtio_net.c|3040| <<virtnet_probe>> vi->vdev->config->reset(vdev);
+	 *   - drivers/net/virtio_net.c|3056| <<remove_vq_common>> vi->vdev->config->reset(vi->vdev);
+	 *   - drivers/virtio/virtio_balloon.c|638| <<remove_common>> vb->vdev->config->reset(vb->vdev);
+	 *   - drivers/virtio/virtio_input.c|324| <<virtinput_remove>> vdev->config->reset(vdev);
+	 *   - drivers/char/hw_random/virtio-rng.c|149| <<remove_common>> vdev->config->reset(vdev);
+	 *   - drivers/char/virtio_console.c|1987| <<virtcons_remove>> vdev->config->reset(vdev);
+	 *   - drivers/char/virtio_console.c|2170| <<virtcons_freeze>> vdev->config->reset(vdev);
+	 *   - drivers/crypto/virtio/virtio_crypto_core.c|419| <<virtcrypto_probe>> vcrypto->vdev->config->reset(vdev);
+	 *   - drivers/crypto/virtio/virtio_crypto_core.c|451| <<virtcrypto_remove>> vdev->config->reset(vdev);
+	 *   - drivers/crypto/virtio/virtio_crypto_core.c|471| <<virtcrypto_freeze>> vdev->config->reset(vdev);
+	 *   - drivers/crypto/virtio/virtio_crypto_core.c|507| <<virtcrypto_restore>> vcrypto->vdev->config->reset(vdev);
+	 *   - drivers/net/caif/caif_virtio.c|763| <<cfv_remove>> vdev->config->reset(vdev);
+	 *   - drivers/rpmsg/virtio_rpmsg_bus.c|1005| <<rpmsg_remove>> vdev->config->reset(vdev);
+	 *   - net/9p/trans_virtio.c|715| <<p9_virtio_remove>> vdev->config->reset(vdev);
+	 *   - net/vmw_vsock/virtio_transport.c|640| <<virtio_vsock_remove>> vdev->config->reset(vdev);
+	 */
 	void (*reset)(struct virtio_device *vdev);
 	int (*find_vqs)(struct virtio_device *, unsigned nvqs,
 			struct virtqueue *vqs[], vq_callback_t *callbacks[],
 			const char * const names[], const bool *ctx,
 			struct irq_affinity *desc);
 	void (*del_vqs)(struct virtio_device *);
+	/*
+	 * called only by:
+	 *   - drivers/virtio/virtio.c|331| <<virtio_dev_probe>> device_features = dev->config->get_features(dev);
+	 */
 	u64 (*get_features)(struct virtio_device *vdev);
 	int (*finalize_features)(struct virtio_device *vdev);
 	const char *(*bus_name)(struct virtio_device *vdev);
@@ -189,6 +247,13 @@ int virtio_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 			const char * const names[],
 			struct irq_affinity *desc)
 {
+	/*
+	 * 设置config的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	return vdev->config->find_vqs(vdev, nvqs, vqs, callbacks, names, NULL, desc);
 }
 
@@ -431,6 +496,14 @@ static inline void virtio_cwrite64(struct virtio_device *vdev,
 }
 
 /* Conditional config space accessors. */
+/*
+ * 最终通过virtio_device->config->get()获取
+ * 设置config的地方:
+ *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops;
+ *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+ *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+ *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+ */
 #define virtio_cread_feature(vdev, fbit, structname, member, ptr)	\
 	({								\
 		int _r = 0;						\
diff --git a/include/uapi/linux/vhost.h b/include/uapi/linux/vhost.h
index 84c3de8..6ad0d32 100644
--- a/include/uapi/linux/vhost.h
+++ b/include/uapi/linux/vhost.h
@@ -158,8 +158,10 @@ struct vhost_memory {
  * for events. */
 
 /* Set eventfd to poll for added buffers */
+/* 设置host notifier */
 #define VHOST_SET_VRING_KICK _IOW(VHOST_VIRTIO, 0x20, struct vhost_vring_file)
 /* Set eventfd to signal when buffers have beed used */
+/* 设置guest notifier */
 #define VHOST_SET_VRING_CALL _IOW(VHOST_VIRTIO, 0x21, struct vhost_vring_file)
 /* Set eventfd to signal an error */
 #define VHOST_SET_VRING_ERR _IOW(VHOST_VIRTIO, 0x22, struct vhost_vring_file)
diff --git a/include/uapi/linux/virtio_pci.h b/include/uapi/linux/virtio_pci.h
index 90007a1..b003f47 100644
--- a/include/uapi/linux/virtio_pci.h
+++ b/include/uapi/linux/virtio_pci.h
@@ -79,6 +79,13 @@
  * configuration space */
 #define VIRTIO_PCI_CONFIG_OFF(msix_enabled)	((msix_enabled) ? 24 : 20)
 /* Deprecated: please use VIRTIO_PCI_CONFIG_OFF instead */
+/*
+ * 如果virtio_pci_device->msix_enabled=true返回24, 否则返回20
+ *
+ * virtio_pci_device->msix_enabled应该是在qemu的参数设置"-device virtio-blk-pci"的"vectors="设置
+ * 如果vectors的数目不够,就不用msix了
+ * 如果virtio_pci_device->msix_enabled则支持VIRTIO_MSI_CONFIG_VECTOR和VIRTIO_MSI_QUEUE_VECTOR
+ */
 #define VIRTIO_PCI_CONFIG(dev)	VIRTIO_PCI_CONFIG_OFF((dev)->msix_enabled)
 
 /* Virtio ABI version, this must match exactly */
diff --git a/include/uapi/linux/virtio_ring.h b/include/uapi/linux/virtio_ring.h
index 6d5d5fa..ea9f402 100644
--- a/include/uapi/linux/virtio_ring.h
+++ b/include/uapi/linux/virtio_ring.h
@@ -60,6 +60,11 @@
  * at the end of the avail ring. Host should ignore the avail->flags field. */
 /* The Host publishes the avail index for which it expects a kick
  * at the end of the used ring. Guest should ignore the used->flags field. */
+/*
+ * VIRTIO_RING_F_EVENT_IDX:
+ *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+ *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+ */
 #define VIRTIO_RING_F_EVENT_IDX		29
 
 /* Virtio ring descriptors: 16 bytes.  These can chain together via "next". */
@@ -137,9 +142,31 @@ struct vring {
  */
 /* We publish the used event index at the end of the available ring, and vice
  * versa. They are at the end for backwards compatibility. */
+/*
+ * 返回avail的最后的一个元素, 告诉后端,处理到那个used ring了
+ *
+ * VIRTIO_RING_F_EVENT_IDX:
+ *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+ *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+ */
 #define vring_used_event(vr) ((vr)->avail->ring[(vr)->num])
+/*
+ * 返回used的最后一个元素, 告诉前端驱动后端处理到哪个avail ring上的元素了
+ *
+ * VIRTIO_RING_F_EVENT_IDX:
+ *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+ *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+ */
 #define vring_avail_event(vr) (*(__virtio16 *)&(vr)->used->ring[(vr)->num])
 
+/*
+ * called by:
+ *   - vring_create_virtqueue()
+ *   - vring_new_virtqueue()
+ *
+ * p是desc,avail和used等其他指针作为一个连续的内存
+ * 让vring的指针们指向内存中对应的位置
+ */
 static inline void vring_init(struct vring *vr, unsigned int num, void *p,
 			      unsigned long align)
 {
@@ -150,6 +177,9 @@ static inline void vring_init(struct vring *vr, unsigned int num, void *p,
 		+ align-1) & ~(align - 1));
 }
 
+/*
+ * 分配desc,avail和used等其他指针作为一个连续的内存
+ */
 static inline unsigned vring_size(unsigned int num, unsigned long align)
 {
 	return ((sizeof(struct vring_desc) * num + sizeof(__virtio16) * (3 + num)
@@ -161,6 +191,14 @@ static inline unsigned vring_size(unsigned int num, unsigned long align)
 /* Assuming a given event_idx value from the other side, if
  * we have just incremented index from old to new_idx,
  * should we trigger an event? */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_ring.c|818| <<virtqueue_kick_prepare>> needs_kick = vring_need_event(virtio16_to_cpu(_vq->vdev, vring_avail_event(&vq->vring)),
+ *   - drivers/vhost/vhost.c|2281| <<vhost_notify>> return vring_need_event(vhost16_to_cpu(vq, event), new, old);
+ *   - drivers/vhost/vringh.c|488| <<__vringh_need_notify>> notify = vring_need_event(used_event,
+ *
+ * 等价于event_idx >= old, 也就是第1个参数大于等于第3个参数
+ */
 static inline int vring_need_event(__u16 event_idx, __u16 new_idx, __u16 old)
 {
 	/* Note: Xen has similar logic for notification hold-off
@@ -168,6 +206,9 @@ static inline int vring_need_event(__u16 event_idx, __u16 new_idx, __u16 old)
 	 * corresponding to event_idx + 1 and new_idx respectively.
 	 * Note also that req_event and req_prod in Xen start at 1,
 	 * event indexes in virtio start at 0. */
+	/*
+	 * 等价于event_idx >= old
+	 */
 	return (__u16)(new_idx - event_idx - 1) < (__u16)(new_idx - old);
 }
 
-- 
2.7.4

