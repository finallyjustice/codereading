From 6dcc79ebc6a02a528da780dd6ecf71db74aaaedf Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang@oracle.com>
Date: Fri, 23 Nov 2018 15:52:53 +0800
Subject: [PATCH 1/1] virtio comment for linux-4.19.3

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 drivers/block/virtio_blk.c         |  92 +++++++++++++
 drivers/virtio/virtio.c            | 182 +++++++++++++++++++++++++
 drivers/virtio/virtio_pci_common.c | 263 +++++++++++++++++++++++++++++++++++++
 drivers/virtio/virtio_pci_common.h |  51 +++++++
 drivers/virtio/virtio_pci_legacy.c | 203 ++++++++++++++++++++++++++++
 drivers/virtio/virtio_pci_modern.c | 161 +++++++++++++++++++++++
 drivers/virtio/virtio_ring.c       |   5 +
 include/linux/virtio.h             |  22 ++++
 include/linux/virtio_config.h      |  58 ++++++++
 include/uapi/linux/virtio_pci.h    |   7 +
 10 files changed, 1044 insertions(+)

diff --git a/drivers/block/virtio_blk.c b/drivers/block/virtio_blk.c
index 23752dc..078b388 100644
--- a/drivers/block/virtio_blk.c
+++ b/drivers/block/virtio_blk.c
@@ -422,6 +422,12 @@ static void virtblk_config_changed_work(struct work_struct *work)
 	kobject_uevent_env(&disk_to_dev(vblk->disk)->kobj, KOBJ_CHANGE, envp);
 }
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio.c|181| <<__virtio_config_changed>> drv->config_changed(dev);
+ *
+ * struct virtio_driver virtio_blk.config_changed = virtblk_config_changed()
+ */
 static void virtblk_config_changed(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -624,6 +630,52 @@ static const struct blk_mq_ops virtio_mq_ops = {
 static unsigned int virtblk_queue_depth;
 module_param_named(queue_depth, virtblk_queue_depth, uint, 0444);
 
+/*
+ * 初始化的时候:
+ * [0] virtblk_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtblk_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] bus_probe_device
+ * [0] device_add
+ * [0] register_virtio_device
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct virtio_driver virtio_blk.probe = virtblk_probe()
+ */
 static int virtblk_probe(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk;
@@ -812,6 +864,31 @@ static int virtblk_probe(struct virtio_device *vdev)
 	return err;
 }
 
+/*
+ * hotplug的时候:
+ * [0] virtblk_remove
+ * [0] virtio_dev_remove
+ * [0] device_release_driver_internal
+ * [0] bus_remove_device
+ * [0] device_del
+ * [0] device_unregister
+ * [0] unregister_virtio_device
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct virtio_driver virtio_blk.remove = virtblk_remove()
+ */
 static void virtblk_remove(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -841,6 +918,9 @@ static void virtblk_remove(struct virtio_device *vdev)
 }
 
 #ifdef CONFIG_PM_SLEEP
+/*
+ * struct virtio_driver virtio_blk.freeze = virtblk_freeze()
+ */
 static int virtblk_freeze(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -857,6 +937,9 @@ static int virtblk_freeze(struct virtio_device *vdev)
 	return 0;
 }
 
+/*
+ * struct virtio_driver virtio_blk.restore = virtblk_restore()
+ */
 static int virtblk_restore(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -873,11 +956,17 @@ static int virtblk_restore(struct virtio_device *vdev)
 }
 #endif
 
+/*
+ * struct virtio_driver virtio_blk.id_table = id_table
+ */
 static const struct virtio_device_id id_table[] = {
 	{ VIRTIO_ID_BLOCK, VIRTIO_DEV_ANY_ID },
 	{ 0 },
 };
 
+/*
+ * struct virtio_driver virtio_blk.feature_table_legacy = features_legacy
+ */
 static unsigned int features_legacy[] = {
 	VIRTIO_BLK_F_SEG_MAX, VIRTIO_BLK_F_SIZE_MAX, VIRTIO_BLK_F_GEOMETRY,
 	VIRTIO_BLK_F_RO, VIRTIO_BLK_F_BLK_SIZE,
@@ -888,6 +977,9 @@ static unsigned int features_legacy[] = {
 	VIRTIO_BLK_F_MQ,
 }
 ;
+/*
+ * struct virtio_driver virtio_blk.feature_table = features
+ */
 static unsigned int features[] = {
 	VIRTIO_BLK_F_SEG_MAX, VIRTIO_BLK_F_SIZE_MAX, VIRTIO_BLK_F_GEOMETRY,
 	VIRTIO_BLK_F_RO, VIRTIO_BLK_F_BLK_SIZE,
diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c
index 59e36ef..35831da 100644
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@ -58,6 +58,7 @@ static ssize_t features_show(struct device *_d,
 }
 static DEVICE_ATTR_RO(features);
 
+/* 用在下面的ATTRIBUTE_GROUPS(virtio_dev) */
 static struct attribute *virtio_dev_attrs[] = {
 	&dev_attr_device.attr,
 	&dev_attr_vendor.attr,
@@ -66,8 +67,19 @@ static struct attribute *virtio_dev_attrs[] = {
 	&dev_attr_features.attr,
 	NULL,
 };
+/*
+ * static const struct attribute_group virtio_dev_group = {
+ *     .attrs = virtio_dev_attrs,
+ * };
+ *
+ * struct bus_type virtio_bus.dev_groups = virtio_dev_group
+ */
 ATTRIBUTE_GROUPS(virtio_dev);
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio.c|138| <<virtio_dev_match>> if (virtio_id_match(dev, &ids[i]))
+ */
 static inline int virtio_id_match(const struct virtio_device *dev,
 				  const struct virtio_device_id *id)
 {
@@ -79,6 +91,46 @@ static inline int virtio_id_match(const struct virtio_device *dev,
 
 /* This looks through all the IDs a driver claims to support.  If any of them
  * match, we return 1 and the kernel will call virtio_dev_probe(). */
+/*
+ * 初始化的时候:
+ * [0] virtio_dev_match
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_dev_match+0x19/0x70
+ * [0] __device_attach_driver+0x34/0xa0
+ * [0] bus_for_each_drv+0x5f/0xb0
+ * [0] __device_attach+0xd4/0x130
+ * [0] bus_probe_device+0x85/0xa0
+ * [0] device_add+0x3be/0x650
+ * [0] register_virtio_device+0xb7/0x100
+ * [0] virtio_pci_probe+0xbd/0x150
+ * [0] local_pci_probe+0x3f/0x90
+ * [0] pci_device_probe+0xdd/0x170
+ * [0] really_probe+0x231/0x2d0
+ * [0] driver_probe_device+0x4a/0xe0
+ * [0] bus_for_each_drv+0x5f/0xb0
+ * [0] __device_attach+0xd4/0x130
+ * [0] pci_bus_add_device+0x45/0x90
+ * [0] pci_bus_add_devices+0x31/0x70
+ * [0] pciehp_configure_device+0x8e/0x130
+ * [0] pciehp_handle_presence_or_link_change+0x288/0x4d0
+ * [0] pciehp_ist+0x1ae/0x1c0
+ * [0] irq_thread_fn+0x1c/0x60
+ * [0] irq_thread+0x12f/0x190
+ * [0] kthread+0xf3/0x130
+ * [0] ret_from_fork+0x35/0x40
+ *
+ * struct bus_type virtio_bus.match = virtio_dev_match()
+ */
 static int virtio_dev_match(struct device *_dv, struct device_driver *_dr)
 {
 	unsigned int i;
@@ -92,6 +144,9 @@ static int virtio_dev_match(struct device *_dv, struct device_driver *_dr)
 	return 0;
 }
 
+/*
+ * struct bus_type virtio_bus.uevent = virtio_uevent()
+ */
 static int virtio_uevent(struct device *_dv, struct kobj_uevent_env *env)
 {
 	struct virtio_device *dev = dev_to_virtio(_dv);
@@ -120,6 +175,11 @@ void virtio_check_driver_offered_feature(const struct virtio_device *vdev,
 }
 EXPORT_SYMBOL_GPL(virtio_check_driver_offered_feature);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|189| <<virtio_config_changed>> __virtio_config_changed(dev);
+ *   - drivers/virtio/virtio.c|207| <<virtio_config_enable>> __virtio_config_changed(dev);
+ */
 static void __virtio_config_changed(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
@@ -130,6 +190,13 @@ static void __virtio_config_changed(struct virtio_device *dev)
 		drv->config_changed(dev);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|72| <<vp_config_changed>> virtio_config_changed(&vp_dev->vdev);
+ *   - drivers/virtio/virtio_mmio.c|300| <<vm_interrupt>> virtio_config_changed(&vm_dev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1076| <<virtio_ccw_int_handler>> virtio_config_changed(&vcdev->vdev);
+ *   - drivers/misc/mic/vop/vop_main.c|548| <<_vop_handle_config_change>> virtio_config_changed(&vdev->vdev);
+ */
 void virtio_config_changed(struct virtio_device *dev)
 {
 	unsigned long flags;
@@ -140,6 +207,11 @@ void virtio_config_changed(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_config_changed);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|405| <<virtio_dev_remove>> virtio_config_disable(dev);
+ *   - drivers/virtio/virtio.c|531| <<virtio_device_freeze>> virtio_config_disable(dev);
+ */
 void virtio_config_disable(struct virtio_device *dev)
 {
 	spin_lock_irq(&dev->config_lock);
@@ -148,6 +220,11 @@ void virtio_config_disable(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_config_disable);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|367| <<virtio_dev_probe>> virtio_config_enable(dev);
+ *   - drivers/virtio/virtio.c|583| <<virtio_device_restore>> virtio_config_enable(dev);
+ */
 void virtio_config_enable(struct virtio_device *dev)
 {
 	spin_lock_irq(&dev->config_lock);
@@ -161,6 +238,13 @@ EXPORT_SYMBOL_GPL(virtio_config_enable);
 
 void virtio_add_status(struct virtio_device *dev, unsigned int status)
 {
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	dev->config->set_status(dev, dev->config->get_status(dev) | status);
 }
 EXPORT_SYMBOL_GPL(virtio_add_status);
@@ -187,6 +271,50 @@ int virtio_finalize_features(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_finalize_features);
 
+/*
+ * 初始化的时候:
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] bus_probe_device
+ * [0] device_add
+ * [0] register_virtio_device
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0]ret_from_fork
+ *
+ * struct bus_type virtio_bus.probe = virtio_dev_probe()
+ */
 static int virtio_dev_probe(struct device *_d)
 {
 	int err, i;
@@ -262,6 +390,30 @@ static int virtio_dev_probe(struct device *_d)
 
 }
 
+/*
+ * hotplug的时候:
+ * [0] virtio_dev_remove
+ * [0] device_release_driver_internal
+ * [0] bus_remove_device
+ * [0] device_del
+ * [0] device_unregister
+ * [0] unregister_virtio_device
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct bus_type virtio_bus.remove = virtio_dev_remove()
+ */
 static int virtio_dev_remove(struct device *_d)
 {
 	struct virtio_device *dev = dev_to_virtio(_d);
@@ -312,8 +464,21 @@ EXPORT_SYMBOL_GPL(unregister_virtio_driver);
  *
  * Returns: 0 on suceess, -error on failure
  */
+/*
+ * 其实就被一个用的到的调用:
+ *   - drivers/virtio/virtio_pci_common.c|624| <<virtio_pci_probe>> rc = register_virtio_device(&vp_dev->vdev);
+ *
+ * 其他的用不到:
+ *   - drivers/virtio/virtio_mmio.c|601| <<virtio_mmio_probe>> rc = register_virtio_device(&vm_dev->vdev);
+ *   - drivers/misc/mic/vop/vop_main.c|501| <<_vop_add_device>> ret = register_virtio_device(&vdev->vdev);
+ *   - drivers/remoteproc/remoteproc_virtio.c|328| <<rproc_add_virtio_dev>> ret = register_virtio_device(vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1261| <<virtio_ccw_online>> ret = register_virtio_device(&vcdev->vdev);
+ */
 int register_virtio_device(struct virtio_device *dev)
 {
+	/*
+	 * 参数dev被包含在struct virtio_pci_device
+	 */
 	int err;
 
 	dev->dev.bus = &virtio_bus;
@@ -333,6 +498,13 @@ int register_virtio_device(struct virtio_device *dev)
 
 	/* We always start by resetting the device, in case a previous
 	 * driver messed it up.  This also tests that code path a little. */
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	dev->config->reset(dev);
 
 	/* Acknowledge that we've seen the device. */
@@ -364,6 +536,11 @@ void unregister_virtio_device(struct virtio_device *dev)
 EXPORT_SYMBOL_GPL(unregister_virtio_device);
 
 #ifdef CONFIG_PM_SLEEP
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|467| <<virtio_pci_freeze>> ret = virtio_device_freeze(&vp_dev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1320| <<virtio_ccw_freeze>> return virtio_device_freeze(&vcdev->vdev);
+ */
 int virtio_device_freeze(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
@@ -379,6 +556,11 @@ int virtio_device_freeze(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_device_freeze);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|485| <<virtio_pci_restore>> return virtio_device_restore(&vp_dev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1332| <<virtio_ccw_restore>> return virtio_device_restore(&vcdev->vdev);
+ */
 int virtio_device_restore(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
diff --git a/drivers/virtio/virtio_pci_common.c b/drivers/virtio/virtio_pci_common.c
index 465a6f5..c9d22f7 100644
--- a/drivers/virtio/virtio_pci_common.c
+++ b/drivers/virtio/virtio_pci_common.c
@@ -19,6 +19,21 @@
 
 #include "virtio_pci_common.h"
 
+/*
+ * 2个virtio-blk(每个2个queue)的例子:
+ *  24:          0          0   PCI-MSI 49152-edge      virtio0-config
+ *  25:       1245          0   PCI-MSI 49153-edge      virtio0-req.0
+ *  26:          0       1617   PCI-MSI 49154-edge      virtio0-req.1
+ *  27:          0          0   PCI-MSI 65536-edge      virtio1-config
+ *  28:         35          0   PCI-MSI 65537-edge      virtio1-req.0
+ *  29:          0         34   PCI-MSI 65538-edge      virtio1-req.1
+ *
+ * legacy的例子:
+ *  24:          0          0   PCI-MSI 65536-edge      virtio0-config
+ *  25:       1547          0   PCI-MSI 65537-edge      virtio0-req.0
+ *  26:          0       1286   PCI-MSI 65538-edge      virtio0-req.1
+ */
+
 static bool force_legacy = false;
 
 #if IS_ENABLED(CONFIG_VIRTIO_PCI_LEGACY)
@@ -28,11 +43,35 @@ MODULE_PARM_DESC(force_legacy,
 #endif
 
 /* wait for pending irq handlers */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_legacy.c|102| <<vp_reset>> vp_synchronize_vectors(vdev);
+ *   - drivers/virtio/virtio_pci_modern.c|297| <<vp_reset>> vp_synchronize_vectors(vdev);
+ *
+ * 等待所有属于这个设备的pending的irq handler完成
+ */
 void vp_synchronize_vectors(struct virtio_device *vdev)
 {
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 把struct virtio_device转换成struct virtio_pci_device
+	 */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	int i;
 
+	/*
+	 * synchronize_irq():
+	 *   This function waits for any pending IRQ handlers for this interrupt
+	 *   to complete before returning. If you use this function while
+	 *   holding a resource the IRQ handler may need you will deadlock.
+	 *   This function may be called - with care - from IRQ context.
+	 */
+
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|283| <<vp_del_vqs>> vp_dev->intx_enabled = 0;
+	 *   - drivers/virtio/virtio_pci_common.c|401| <<vp_find_vqs_intx>> vp_dev->intx_enabled = 1;
+	 */
 	if (vp_dev->intx_enabled)
 		synchronize_irq(vp_dev->pci_dev->irq);
 
@@ -41,15 +80,38 @@ void vp_synchronize_vectors(struct virtio_device *vdev)
 }
 
 /* the notify function used when creating a virt queue */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_legacy.c|141| <<setup_vq>> vp_notify, callback, name);
+ *   - drivers/virtio/virtio_pci_modern.c|347| <<setup_vq>> vp_notify, callback, name);
+ *
+ * 把virtqueue->index写入virtqueue->priv,通知backend
+ */
 bool vp_notify(struct virtqueue *vq)
 {
 	/* we write the queue's selector into the notification register to
 	 * signal the other end */
+	/*
+	 * priv设置的地方:
+	 *   - drivers/virtio/virtio_pci_legacy.c|157| <<setup_vq>> vq->priv = (void __force *)vp_dev->ioaddr + VIRTIO_PCI_QUEUE_NOTIFY;
+	 *   - drivers/virtio/virtio_pci_modern.c|372| <<setup_vq>> vq->priv = (void __force *)vp_dev->notify_base +
+	 *                                                                  off * vp_dev->notify_offset_multiplier;
+	 *   - drivers/virtio/virtio_pci_modern.c|375| <<setup_vq>> vq->priv = (void __force *)map_capability(vp_dev->pci_dev,
+	 *                                                                                    vp_dev->notify_map_cap, 2, 2,
+	 *                                                                                    off * vp_dev->notify_offset_multiplier, 2,
+	 *                                                                                    NULL);
+	 *   - drivers/virtio/virtio_mmio.c|438| <<vm_setup_vq>> vq->priv = info;
+	 */
 	iowrite16(vq->index, (void __iomem *)vq->priv);
 	return true;
 }
 
 /* Handle a configuration change: Tell driver if it wants to know. */
+/*
+ * 作为中断处理的一个实现,被以下调用或使用:
+ *   - drivers/virtio/virtio_pci_common.c|157| <<vp_interrupt>> vp_config_changed(irq, opaque);
+ *   - drivers/virtio/virtio_pci_common.c|208| <<vp_request_msix_vectors>> vp_config_changed, 0, vp_dev->msix_names[v],
+ */
 static irqreturn_t vp_config_changed(int irq, void *opaque)
 {
 	struct virtio_pci_device *vp_dev = opaque;
@@ -59,6 +121,11 @@ static irqreturn_t vp_config_changed(int irq, void *opaque)
 }
 
 /* Notify all virtqueues on an interrupt. */
+/*
+ * 作为中断处理的一个实现,被以下调用或使用:
+ *   - drivers/virtio/virtio_pci_common.c|159| <<vp_interrupt>> return vp_vring_interrupt(irq, opaque);
+ *   - drivers/virtio/virtio_pci_common.c|227| <<vp_request_msix_vectors>> vp_vring_interrupt, 0, vp_dev->msix_names[v],
+ */
 static irqreturn_t vp_vring_interrupt(int irq, void *opaque)
 {
 	struct virtio_pci_device *vp_dev = opaque;
@@ -82,6 +149,11 @@ static irqreturn_t vp_vring_interrupt(int irq, void *opaque)
  * the callback may notify the host which results in the host attempting to
  * raise an interrupt that we would then mask once we acknowledged the
  * interrupt. */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|370| <<vp_find_vqs_intx>> err = request_irq(vp_dev->pci_dev->irq, vp_interrupt, IRQF_SHARED,
+ *                                                                                    dev_name(&vdev->dev), vp_dev);
+ */
 static irqreturn_t vp_interrupt(int irq, void *opaque)
 {
 	struct virtio_pci_device *vp_dev = opaque;
@@ -102,6 +174,10 @@ static irqreturn_t vp_interrupt(int irq, void *opaque)
 	return vp_vring_interrupt(irq, opaque);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|336| <<vp_find_vqs_msix>> err = vp_request_msix_vectors(vdev, nvectors, per_vq_vectors,
+ */
 static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 				   bool per_vq_vectors, struct irq_affinity *desc)
 {
@@ -150,6 +226,15 @@ static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 		goto error;
 	++vp_dev->msix_used_vectors;
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的vp_config_vector()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|263| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+	 *   - drivers/virtio/virtio_pci_modern.c|709| <<virtio_pci_modern_probe>> vp_dev->config_vector = vp_config_vector;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|224| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+	 *   - drivers/virtio/virtio_pci_common.c|344| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+	 */
 	v = vp_dev->config_vector(vp_dev, v);
 	/* Verify we had enough resources to assign the vector */
 	if (v == VIRTIO_MSI_NO_VECTOR) {
@@ -174,6 +259,11 @@ static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|385| <<vp_find_vqs_msix>> vqs[i] = vp_setup_vq(vdev, i, callbacks[i], names[i],
+ *   - drivers/virtio/virtio_pci_common.c|442| <<vp_find_vqs_intx>> vqs[i] = vp_setup_vq(vdev, i, callbacks[i], names[i],
+ */
 static struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,
 				     void (*callback)(struct virtqueue *vq),
 				     const char *name,
@@ -189,6 +279,15 @@ static struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,
 	if (!info)
 		return ERR_PTR(-ENOMEM);
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的setup_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|273| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|719| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+	 *                                                                                   msix_vec);
+	 */
 	vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
 			      msix_vec);
 	if (IS_ERR(vq))
@@ -211,6 +310,10 @@ static struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,
 	return vq;
 }
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio_pci_common.c|307| <<vp_del_vqs>> vp_del_vq(vq);
+ */
 static void vp_del_vq(struct virtqueue *vq)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vq->vdev);
@@ -221,11 +324,24 @@ static void vp_del_vq(struct virtqueue *vq)
 	list_del(&info->node);
 	spin_unlock_irqrestore(&vp_dev->lock, flags);
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的del_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|283| <<virtio_pci_legacy_probe>> vp_dev->del_vq = del_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|729| <<virtio_pci_modern_probe>> vp_dev->del_vq = del_vq;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+	 */
 	vp_dev->del_vq(info);
 	kfree(info);
 }
 
 /* the config->del_vqs() implementation */
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.del_vqs = vp_del_vqs()
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.del_vqs = vp_del_vqs()
+ * struct virtio_config_ops virtio_pci_config_ops.del_vqs = vp_del_vqs()
+ */
 void vp_del_vqs(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -261,6 +377,15 @@ void vp_del_vqs(struct virtio_device *vdev)
 
 	if (vp_dev->msix_enabled) {
 		/* Disable the vector used for configuration */
+		/*
+		 * 设置的地方 (legacy和modern用的不同的vp_config_vector()):
+		 *   - drivers/virtio/virtio_pci_legacy.c|263| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+		 *   - drivers/virtio/virtio_pci_modern.c|709| <<virtio_pci_modern_probe>> vp_dev->config_vector = vp_config_vector;
+		 *
+		 * 调用的地方:
+		 *   - drivers/virtio/virtio_pci_common.c|224| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+		 *   - drivers/virtio/virtio_pci_common.c|344| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+		 */
 		vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
 
 		pci_free_irq_vectors(vp_dev->pci_dev);
@@ -351,6 +476,10 @@ static int vp_find_vqs_msix(struct virtio_device *vdev, unsigned nvqs,
 	return err;
 }
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio_pci_common.c|440| <<vp_find_vqs>> return vp_find_vqs_intx(vdev, nvqs, vqs, callbacks, names, ctx);
+ */
 static int vp_find_vqs_intx(struct virtio_device *vdev, unsigned nvqs,
 		struct virtqueue *vqs[], vq_callback_t *callbacks[],
 		const char * const names[], const bool *ctx)
@@ -390,6 +519,9 @@ static int vp_find_vqs_intx(struct virtio_device *vdev, unsigned nvqs,
 }
 
 /* the config->find_vqs() implementation */
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.find_vqs = vp_find_vqs()
+ */
 int vp_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 		struct virtqueue *vqs[], vq_callback_t *callbacks[],
 		const char * const names[], const bool *ctx,
@@ -409,6 +541,11 @@ int vp_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 	return vp_find_vqs_intx(vdev, nvqs, vqs, callbacks, names, ctx);
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.bus_name = vp_bus_name()
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.bus_name = vp_bus_name()
+ * struct virtio_config_ops virtio_pci_config_ops.bus_name = vp_bus_name()
+ */
 const char *vp_bus_name(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -421,6 +558,11 @@ const char *vp_bus_name(struct virtio_device *vdev)
  * - OR over all affinities for shared MSI
  * - ignore the affinity request if we're using INTX
  */
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.set_vq_affinity = vp_set_vq_affinity()
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.set_vq_affinity = vp_set_vq_affinity()
+ * struct virtio_config_ops virtio_pci_config_ops.set_vq_affinity = vp_set_vq_affinity()
+ */
 int vp_set_vq_affinity(struct virtqueue *vq, const struct cpumask *cpu_mask)
 {
 	struct virtio_device *vdev = vq->vdev;
@@ -445,6 +587,11 @@ int vp_set_vq_affinity(struct virtqueue *vq, const struct cpumask *cpu_mask)
 	return 0;
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.get_vq_affinity = vp_get_vq_affinity()
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.get_vq_affinity = vp_get_vq_affinity()
+ * struct virtio_config_ops virtio_pci_config_ops.get_vq_affinity = vp_get_vq_affinity()
+ */
 const struct cpumask *vp_get_vq_affinity(struct virtio_device *vdev, int index)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -458,6 +605,10 @@ const struct cpumask *vp_get_vq_affinity(struct virtio_device *vdev, int index)
 }
 
 #ifdef CONFIG_PM_SLEEP
+/*
+ * used only by:
+ *   - drivers/virtio/virtio_pci_common.c|544| <<global>> SET_SYSTEM_SLEEP_PM_OPS(virtio_pci_freeze, virtio_pci_restore)
+ */
 static int virtio_pci_freeze(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -471,6 +622,10 @@ static int virtio_pci_freeze(struct device *dev)
 	return ret;
 }
 
+/*
+ * used only by:
+ *   - drivers/virtio/virtio_pci_common.c|544| <<global>> SET_SYSTEM_SLEEP_PM_OPS(virtio_pci_freeze, virtio_pci_restore)
+ */
 static int virtio_pci_restore(struct device *dev)
 {
 	struct pci_dev *pci_dev = to_pci_dev(dev);
@@ -485,6 +640,9 @@ static int virtio_pci_restore(struct device *dev)
 	return virtio_device_restore(&vp_dev->vdev);
 }
 
+/*
+ * struct pci_driver virtio_pci_driver.drive.pm = virtio_pci_pm_ops
+ */
 static const struct dev_pm_ops virtio_pci_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(virtio_pci_freeze, virtio_pci_restore)
 };
@@ -492,6 +650,9 @@ static const struct dev_pm_ops virtio_pci_pm_ops = {
 
 
 /* Qumranet donated their vendor ID for devices 0x1000 thru 0x10FF. */
+/*
+ * struct pci_driver virtio_pci_driver.id_table = virtio_pci_id_table
+ */
 static const struct pci_device_id virtio_pci_id_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_ANY_ID) },
 	{ 0 }
@@ -499,9 +660,19 @@ static const struct pci_device_id virtio_pci_id_table[] = {
 
 MODULE_DEVICE_TABLE(pci, virtio_pci_id_table);
 
+/*
+ * used only by:
+ *   - drivers/virtio/virtio_pci_common.c|597| <<virtio_pci_probe>> vp_dev->vdev.dev.release = virtio_pci_release_dev;
+ *
+ * struct virtio_device包含struct device
+ * struct virtio_pci_device包含struct virtio_device
+ * 于是根据struct device找到struct virtio_pci_device并释放
+ */
 static void virtio_pci_release_dev(struct device *_d)
 {
+	/* struct virtio_device包含struct device */
 	struct virtio_device *vdev = dev_to_virtio(_d);
+	/* struct virtio_pci_device包含struct virtio_device */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 
 	/* As struct device is a kobject, it's not safe to
@@ -510,6 +681,43 @@ static void virtio_pci_release_dev(struct device *_d)
 	kfree(vp_dev);
 }
 
+/*
+ * 初始化的时候:
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct pci_driver virtio_pci_driver.probe = virtio_pci_probe()
+ */
 static int virtio_pci_probe(struct pci_dev *pci_dev,
 			    const struct pci_device_id *id)
 {
@@ -517,18 +725,42 @@ static int virtio_pci_probe(struct pci_dev *pci_dev,
 	int rc;
 
 	/* allocate our structure and fill it out */
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 */
 	vp_dev = kzalloc(sizeof(struct virtio_pci_device), GFP_KERNEL);
+	/*
+	 * qemu是否可以回收干净??
+	 */
 	if (!vp_dev)
 		return -ENOMEM;
 
+	/* 把pci_dev->dev->driver_data设置为vp_dev (virtio_pci_device) */
 	pci_set_drvdata(pci_dev, vp_dev);
+	/*
+	 * vp_dev->vdev是struct virtio_device
+	 * vp_dev->vdev.dev是struct device
+	 */
 	vp_dev->vdev.dev.parent = &pci_dev->dev;
+	/*
+	 * struct virtio_device包含struct device
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 于是根据struct device找到struct virtio_pci_device并释放
+	 */
 	vp_dev->vdev.dev.release = virtio_pci_release_dev;
 	vp_dev->pci_dev = pci_dev;
 	INIT_LIST_HEAD(&vp_dev->virtqueues);
 	spin_lock_init(&vp_dev->lock);
 
 	/* enable the device */
+	/*
+	 * Initialize device before it's used by a driver. Ask low-level code
+	 *  to enable I/O and memory. Wake up the device if it was suspended.
+	 *  Beware, this function can fail.
+	 *
+	 *  Note we don't actually enable the device many times if we call
+	 *  this function repeatedly (we just increment the count).
+	 */
 	rc = pci_enable_device(pci_dev);
 	if (rc)
 		goto err_enable_device;
@@ -541,6 +773,11 @@ static int virtio_pci_probe(struct pci_dev *pci_dev,
 		if (rc)
 			goto err_probe;
 	} else {
+		/*
+		 * 先尝试modern,
+		 * 如果在qemu的-device的命令行加入"disable-modern=true",则会rc=-19
+		 * 然后调用legacy
+		 */
 		rc = virtio_pci_modern_probe(vp_dev);
 		if (rc == -ENODEV)
 			rc = virtio_pci_legacy_probe(vp_dev);
@@ -572,6 +809,23 @@ static int virtio_pci_probe(struct pci_dev *pci_dev,
 	return rc;
 }
 
+/*
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct pci_driver virtio_pci_driver.remove = virtio_pci_remove()
+ */
 static void virtio_pci_remove(struct pci_dev *pci_dev)
 {
 	struct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);
@@ -590,6 +844,15 @@ static void virtio_pci_remove(struct pci_dev *pci_dev)
 	put_device(dev);
 }
 
+/*
+ * called by:
+ *   - drivers/pci/pci-sysfs.c|608| <<sriov_numvfs_store>> ret = pdev->driver->sriov_configure(pdev, 0);
+ *   - drivers/pci/pci-sysfs.c|620| <<sriov_numvfs_store>> ret = pdev->driver->sriov_configure(pdev, num_vfs);
+ *
+ * struct pci_driver virtio_pci_driver.sriov_configure = virtio_pci_sriov_configure()
+ *
+ * 没看到怎么使用
+ */
 static int virtio_pci_sriov_configure(struct pci_dev *pci_dev, int num_vfs)
 {
 	struct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);
diff --git a/drivers/virtio/virtio_pci_common.h b/drivers/virtio/virtio_pci_common.h
index 0227100..5db8e5f 100644
--- a/drivers/virtio/virtio_pci_common.h
+++ b/drivers/virtio/virtio_pci_common.h
@@ -73,6 +73,14 @@ struct virtio_pci_device {
 
 	/* Legacy only field */
 	/* the IO mapping for the PCI config space */
+	/*
+	 * 在virtio_pci_legacy_probe()用以下函数获得:
+	 *   - vp_dev->ioaddr = pci_iomap(pci_dev, 0, 0);
+	 *
+	 * region 0   --  virtio legacy io bar
+	 * region 1   --  msi-x bar
+	 * region 4+5 --  virtio modern memory (64bit) bar
+	 */
 	void __iomem *ioaddr;
 
 	/* a list of queues so we can dispatch IRQs */
@@ -83,7 +91,20 @@ struct virtio_pci_device {
 	struct virtio_pci_vq_info **vqs;
 
 	/* MSI-X support */
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|171| <<vp_request_msix_vectors>> vp_dev->msix_enabled = 1;
+	 *   - drivers/virtio/virtio_pci_common.c|298| <<vp_del_vqs>> vp_dev->msix_enabled = 0;
+	 *
+	 * 应该是在qemu的参数设置"-device virtio-blk-pci"的"vectors="设置
+	 * 如果vectors的数目不够,就不用msix了
+	 */
 	int msix_enabled;
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|283| <<vp_del_vqs>> vp_dev->intx_enabled = 0;
+	 *   - drivers/virtio/virtio_pci_common.c|401| <<vp_find_vqs_intx>> vp_dev->intx_enabled = 1;
+	 */
 	int intx_enabled;
 	cpumask_var_t *msix_affinity_masks;
 	/* Name strings for interrupts. This size should be enough,
@@ -97,6 +118,15 @@ struct virtio_pci_device {
 	/* Whether we have vector per vq */
 	bool per_vq_vectors;
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的setup_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|273| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|719| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+	 * 
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+	 *                                                                                   msix_vec);
+	 */
 	struct virtqueue *(*setup_vq)(struct virtio_pci_device *vp_dev,
 				      struct virtio_pci_vq_info *info,
 				      unsigned idx,
@@ -104,8 +134,25 @@ struct virtio_pci_device {
 				      const char *name,
 				      bool ctx,
 				      u16 msix_vec);
+	/*
+	 * 设置的地方 (legacy和modern用的不同的del_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|283| <<virtio_pci_legacy_probe>> vp_dev->del_vq = del_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|729| <<virtio_pci_modern_probe>> vp_dev->del_vq = del_vq;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+	 */
 	void (*del_vq)(struct virtio_pci_vq_info *info);
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的vp_config_vector()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|263| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+	 *   - drivers/virtio/virtio_pci_modern.c|709| <<virtio_pci_modern_probe>> vp_dev->config_vector = vp_config_vector;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|224| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+	 *   - drivers/virtio/virtio_pci_common.c|344| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+	 */
 	u16 (*config_vector)(struct virtio_pci_device *vp_dev, u16 vector);
 };
 
@@ -118,6 +165,10 @@ enum {
 };
 
 /* Convert a generic virtio device to our structure */
+/*
+ * struct virtio_pci_device包含struct virtio_device
+ * 把struct virtio_device转换成struct virtio_pci_device
+ */
 static struct virtio_pci_device *to_vp_device(struct virtio_device *vdev)
 {
 	return container_of(vdev, struct virtio_pci_device, vdev);
diff --git a/drivers/virtio/virtio_pci_legacy.c b/drivers/virtio/virtio_pci_legacy.c
index de062fb..7b8bc3e 100644
--- a/drivers/virtio/virtio_pci_legacy.c
+++ b/drivers/virtio/virtio_pci_legacy.c
@@ -20,16 +20,44 @@
 #include "virtio_pci_common.h"
 
 /* virtio config->get_features() implementation */
+/*
+ * called only by:
+ *   - drivers/virtio/virtio.c|331| <<virtio_dev_probe>> device_features = dev->config->get_features(dev);
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.get_features = vp_get_features()
+ *
+ * 从bar0读取VIRTIO_PCI_HOST_FEATURES
+ */
 static u64 vp_get_features(struct virtio_device *vdev)
 {
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 把struct virtio_device转换成struct virtio_pci_device
+	 */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 
 	/* When someone needs more than 32 feature bits, we'll need to
 	 * steal a bit to indicate that the rest are somewhere else. */
+	/*
+	 * vp_dev->ioaddr是在virtio_pci_legacy_probe()用以下获得的:
+	 *   - vp_dev->ioaddr = pci_iomap(pci_dev, 0, 0);
+	 *
+	 * region 0   --  virtio legacy io bar
+	 * region 1   --  msi-x bar
+	 * region 4+5 --  virtio modern memory (64bit) bar
+	 */
 	return ioread32(vp_dev->ioaddr + VIRTIO_PCI_HOST_FEATURES);
 }
 
 /* virtio config->finalize_features() implementation */
+/*
+ * called only by:
+ *   -  drivers/virtio/virtio.c|254| <<virtio_finalize_features>> int ret = dev->config->finalize_features(dev);
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.finalize_features = vp_finalize_features()
+ *
+ * 核心思想是把virtio_device->features写入bar0的VIRTIO_PCI_GUEST_FEATURES
+ */
 static int vp_finalize_features(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -41,16 +69,42 @@ static int vp_finalize_features(struct virtio_device *vdev)
 	BUG_ON((u32)vdev->features != vdev->features);
 
 	/* We only support 32 feature bits. */
+	/*
+	 * vp_dev->ioaddr是在virtio_pci_legacy_probe()用以下获得的:
+	 *   - vp_dev->ioaddr = pci_iomap(pci_dev, 0, 0);
+	 *
+	 * region 0   --  virtio legacy io bar
+	 * region 1   --  msi-x bar
+	 * region 4+5 --  virtio modern memory (64bit) bar
+	 */
 	iowrite32(vdev->features, vp_dev->ioaddr + VIRTIO_PCI_GUEST_FEATURES);
 
 	return 0;
 }
 
 /* virtio config->get() implementation */
+/*
+ * called by:
+ *   - include/linux/virtio_config.h|364| <<__virtio_cread_many>> vdev->config->get(vdev, offset + bytes * i,
+ *   - include/linux/virtio_config.h|382| <<virtio_cread8>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+ *   - include/linux/virtio_config.h|396| <<virtio_cread16>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+ *   - include/linux/virtio_config.h|411| <<virtio_cread32>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+ *   - net/vmw_vsock/virtio_transport.c|428| <<virtio_vsock_update_guest_cid>> vdev->config->get(vdev, offsetof(struct virtio_vsock_config, guest_cid),
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.get = vp_get()
+ *
+ * 获得bar0中offset指向的len大小的配置写入输出的buf
+ * offset是从bar0中的device specific configuration中的
+ */
 static void vp_get(struct virtio_device *vdev, unsigned offset,
 		   void *buf, unsigned len)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
+	/*
+	 * VIRTIO_PCI_CONFIG():
+	 *   如果virtio_pci_device->msix_enabled=true返回24, 否则返回20
+	 *   如果virtio_pci_device->msix_enabled则支持VIRTIO_MSI_CONFIG_VECTOR和VIRTIO_MSI_QUEUE_VECTOR
+	 */
 	void __iomem *ioaddr = vp_dev->ioaddr +
 				VIRTIO_PCI_CONFIG(vp_dev) + offset;
 	u8 *ptr = buf;
@@ -62,10 +116,27 @@ static void vp_get(struct virtio_device *vdev, unsigned offset,
 
 /* the config->set() implementation.  it's symmetric to the config->get()
  * implementation */
+/*
+ * called by:
+ *   - include/linux/virtio_config.h|389| <<virtio_cwrite8>> vdev->config->set(vdev, offset, &val, sizeof(val));
+ *   - include/linux/virtio_config.h|404| <<virtio_cwrite16>> vdev->config->set(vdev, offset, &val, sizeof(val));
+ *   - include/linux/virtio_config.h|419| <<virtio_cwrite32>> vdev->config->set(vdev, offset, &val, sizeof(val));
+ *   - include/linux/virtio_config.h|434| <<virtio_cwrite64>> vdev->config->set(vdev, offset, &val, sizeof(val));
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.set = vp_set()
+ *
+ * 把buf(len大小)写入获得bar0中offset指向的地址
+ * offset是从bar0中的device specific configuration中的
+ */
 static void vp_set(struct virtio_device *vdev, unsigned offset,
 		   const void *buf, unsigned len)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
+	/*
+	 * VIRTIO_PCI_CONFIG():
+	 *   如果virtio_pci_device->msix_enabled=true返回24, 否则返回20
+	 *   如果virtio_pci_device->msix_enabled则支持VIRTIO_MSI_CONFIG_VECTOR和VIRTIO_MSI_QUEUE_VECTOR
+	 */
 	void __iomem *ioaddr = vp_dev->ioaddr +
 				VIRTIO_PCI_CONFIG(vp_dev) + offset;
 	const u8 *ptr = buf;
@@ -76,12 +147,36 @@ static void vp_set(struct virtio_device *vdev, unsigned offset,
 }
 
 /* config->{get,set}_status() implementations */
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|31| <<status_show>> return sprintf(buf, "0x%08x\n", dev->config->get_status(dev));
+ *   - drivers/virtio/virtio.c|248| <<virtio_add_status>> dev->config->set_status(dev, dev->config->get_status(dev) | status);
+ *   - drivers/virtio/virtio.c|264| <<virtio_finalize_features>> status = dev->config->get_status(dev);
+ *   - drivers/virtio/virtio.c|378| <<virtio_dev_probe>> if (!(dev->config->get_status(dev) & VIRTIO_CONFIG_S_DRIVER_OK))
+ *   - drivers/virtio/virtio.c|427| <<virtio_dev_remove>> WARN_ON_ONCE(dev->config->get_status(dev));
+ *   - drivers/virtio/virtio.c|550| <<virtio_device_freeze>> dev->failed = dev->config->get_status(dev) & VIRTIO_CONFIG_S_FAILED;
+ *   - drivers/virtio/virtio_pci_common.c|862| <<virtio_pci_sriov_configure>> if (!(vdev->config->get_status(vdev) & VIRTIO_CONFIG_S_DRIVER_OK))
+ *   - include/linux/virtio_config.h|220| <<virtio_device_ready>> unsigned status = dev->config->get_status(dev);
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.get_status = vp_get_status()
+ *
+ * 读取返回bar0中的VIRTIO_PCI_STATUS
+ */
 static u8 vp_get_status(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	return ioread8(vp_dev->ioaddr + VIRTIO_PCI_STATUS);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|248| <<virtio_add_status>> dev->config->set_status(dev, dev->config->get_status(dev) | status);
+ *   - include/linux/virtio_config.h|249| <<virtio_device_ready>> dev->config->set_status(dev, status | VIRTIO_CONFIG_S_DRIVER_OK);
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.set_status = vp_set_status()
+ *
+ * 写入bar0中的VIRTIO_PCI_STATUS
+ */
 static void vp_set_status(struct virtio_device *vdev, u8 status)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -90,6 +185,35 @@ static void vp_set_status(struct virtio_device *vdev, u8 status)
 	iowrite8(status, vp_dev->ioaddr + VIRTIO_PCI_STATUS);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|508| <<register_virtio_device>> dev->config->reset(dev);
+ *   - drivers/virtio/virtio.c|571| <<virtio_device_restore>> dev->config->reset(dev);
+ *   - drivers/block/virtio_blk.c|907| <<virtblk_remove>> vdev->config->reset(vdev);
+ *   - drivers/block/virtio_blk.c|929| <<virtblk_freeze>> vdev->config->reset(vdev);
+ *   - drivers/scsi/virtio_scsi.c|781| <<virtscsi_remove_vqs>> vdev->config->reset(vdev);
+ *   - drivers/net/virtio_net.c|3040| <<virtnet_probe>> vi->vdev->config->reset(vdev);
+ *   - drivers/net/virtio_net.c|3056| <<remove_vq_common>> vi->vdev->config->reset(vi->vdev);
+ *   - drivers/virtio/virtio_balloon.c|638| <<remove_common>> vb->vdev->config->reset(vb->vdev);
+ *   - drivers/virtio/virtio_input.c|324| <<virtinput_remove>> vdev->config->reset(vdev);
+ *   - drivers/char/hw_random/virtio-rng.c|149| <<remove_common>> vdev->config->reset(vdev);
+ *   - drivers/char/virtio_console.c|1987| <<virtcons_remove>> vdev->config->reset(vdev);
+ *   - drivers/char/virtio_console.c|2170| <<virtcons_freeze>> vdev->config->reset(vdev);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|419| <<virtcrypto_probe>> vcrypto->vdev->config->reset(vdev);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|451| <<virtcrypto_remove>> vdev->config->reset(vdev);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|471| <<virtcrypto_freeze>> vdev->config->reset(vdev);
+ *   - drivers/crypto/virtio/virtio_crypto_core.c|507| <<virtcrypto_restore>> vcrypto->vdev->config->reset(vdev);
+ *   - drivers/net/caif/caif_virtio.c|763| <<cfv_remove>> vdev->config->reset(vdev);
+ *   - drivers/rpmsg/virtio_rpmsg_bus.c|1005| <<rpmsg_remove>> vdev->config->reset(vdev);
+ *   - net/9p/trans_virtio.c|715| <<p9_virtio_remove>> vdev->config->reset(vdev);
+ *   - net/vmw_vsock/virtio_transport.c|640| <<virtio_vsock_remove>> vdev->config->reset(vdev);
+ *
+ * struct virtio_config_ops virtio_pci_config_ops.reset = vp_reset()
+ *
+ * 先把0写入bar0的VIRTIO_PCI_STATUS
+ * 然后读一下bar0的VIRTIO_PCI_STATUS (flush一下写)
+ * 最后等待所有属于这个设备的pending的irq handler完成
+ */
 static void vp_reset(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -99,9 +223,21 @@ static void vp_reset(struct virtio_device *vdev)
 	 * including MSi-X interrupts, if any. */
 	ioread8(vp_dev->ioaddr + VIRTIO_PCI_STATUS);
 	/* Flush pending VQ/configuration callbacks. */
+	/* 等待所有属于这个设备的pending的irq handler完成 */
 	vp_synchronize_vectors(vdev);
 }
 
+/*
+ * 被以下使用:
+ *   - drivers/virtio/virtio_pci_legacy.c|394| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+ *
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|238| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+ *   - drivers/virtio/virtio_pci_common.c|389| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+ *
+ * 把vector写入bar0的VIRTIO_MSI_CONFIG_VECTOR然后再读出来
+ * 再读出来应该是查看是否生效吧
+ */
 static u16 vp_config_vector(struct virtio_pci_device *vp_dev, u16 vector)
 {
 	/* Setup the vector used for configuration events */
@@ -111,6 +247,14 @@ static u16 vp_config_vector(struct virtio_pci_device *vp_dev, u16 vector)
 	return ioread16(vp_dev->ioaddr + VIRTIO_MSI_CONFIG_VECTOR);
 }
 
+/*
+ * 在以下被使用:
+ *   - drivers/virtio/virtio_pci_legacy.c|310| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+ *
+ * 调用的地方:
+ *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+ *                                                                                   msix_vec);
+ */
 static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 				  struct virtio_pci_vq_info *info,
 				  unsigned index,
@@ -125,6 +269,9 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	u64 q_pfn;
 
 	/* Select the queue we're interested in */
+	/*
+	 * virtio_pci_device->ioaddr是bar0
+	 */
 	iowrite16(index, vp_dev->ioaddr + VIRTIO_PCI_QUEUE_SEL);
 
 	/* Check if queue is either not available or already active. */
@@ -174,6 +321,13 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	return ERR_PTR(err);
 }
 
+/*
+ * 只在以下被使用:
+ *   - drivers/virtio/virtio_pci_legacy.c|335| <<virtio_pci_legacy_probe>> vp_dev->del_vq = del_vq;
+ *
+ * 调用的地方:
+ *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+ */
 static void del_vq(struct virtio_pci_vq_info *info)
 {
 	struct virtqueue *vq = info->vq;
@@ -194,6 +348,10 @@ static void del_vq(struct virtio_pci_vq_info *info)
 	vring_del_virtqueue(vq);
 }
 
+/*
+ * 只被以下使用:
+ *   - drivers/virtio/virtio_pci_legacy.c|289| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+ */
 static const struct virtio_config_ops virtio_pci_config_ops = {
 	.get		= vp_get,
 	.set		= vp_set,
@@ -210,6 +368,10 @@ static const struct virtio_config_ops virtio_pci_config_ops = {
 };
 
 /* the PCI probing function */
+/*
+ * 只被virtio_pci_probe()在两处调用:
+ *   - drivers/virtio/virtio_pci_common.c|756| <<virtio_pci_probe>> rc = virtio_pci_legacy_probe(vp_dev);
+ */
 int virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)
 {
 	struct pci_dev *pci_dev = vp_dev->pci_dev;
@@ -258,10 +420,46 @@ int virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)
 	vp_dev->vdev.id.vendor = pci_dev->subsystem_vendor;
 	vp_dev->vdev.id.device = pci_dev->subsystem_device;
 
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	vp_dev->vdev.config = &virtio_pci_config_ops;
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的vp_config_vector()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|263| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+	 *   - drivers/virtio/virtio_pci_modern.c|709| <<virtio_pci_modern_probe>> vp_dev->config_vector = vp_config_vector;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|224| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+	 *   - drivers/virtio/virtio_pci_common.c|344| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+	 *
+	 * 把vector写入bar0的VIRTIO_MSI_CONFIG_VECTOR然后再读出来
+	 * 再读出来应该是查看是否生效吧
+	 */
 	vp_dev->config_vector = vp_config_vector;
+	/*
+	 * 设置的地方 (legacy和modern用的不同的setup_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|273| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|719| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+	 * 
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+	 *                                                                                   msix_vec);
+	 */
 	vp_dev->setup_vq = setup_vq;
+	/*
+	 * 设置的地方 (legacy和modern用的不同的del_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|283| <<virtio_pci_legacy_probe>> vp_dev->del_vq = del_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|729| <<virtio_pci_modern_probe>> vp_dev->del_vq = del_vq;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+	 */
 	vp_dev->del_vq = del_vq;
 
 	return 0;
@@ -271,6 +469,11 @@ int virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)
 	return rc;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|781| <<virtio_pci_probe>> virtio_pci_legacy_remove(vp_dev);
+ *   - drivers/virtio/virtio_pci_common.c|821| <<virtio_pci_remove>> virtio_pci_legacy_remove(vp_dev);
+ */
 void virtio_pci_legacy_remove(struct virtio_pci_device *vp_dev)
 {
 	struct pci_dev *pci_dev = vp_dev->pci_dev;
diff --git a/drivers/virtio/virtio_pci_modern.c b/drivers/virtio/virtio_pci_modern.c
index 07571da..76f6845 100644
--- a/drivers/virtio/virtio_pci_modern.c
+++ b/drivers/virtio/virtio_pci_modern.c
@@ -65,6 +65,26 @@ static void vp_iowrite64_twopart(u64 val,
 	vp_iowrite32(val >> 32, hi);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_modern.c|420| <<setup_vq>> vq->priv = (void __force *)map_capability(vp_dev->pci_dev,
+ *                                                                                                    vp_dev->notify_map_cap, 2, 2,
+ *                                                                                                    off * vp_dev->notify_offset_multiplier, 2,
+ *                                                                                                    NULL);
+ *   - drivers/virtio/virtio_pci_modern.c|727| <<virtio_pci_modern_probe>> vp_dev->common = map_capability(pci_dev, common,
+ *                                                                                                         sizeof(struct virtio_pci_common_cfg), 4,
+ *                                                                                                         0, sizeof(struct virtio_pci_common_cfg),
+ *                                                                                                         NULL);
+ *   - drivers/virtio/virtio_pci_modern.c|733| <<virtio_pci_modern_probe>> vp_dev->isr = map_capability(pci_dev, isr, sizeof(u8), 1,
+ *                                                                                                      0, 1,
+ *                                                                                                      NULL);
+ *   - drivers/virtio/virtio_pci_modern.c|760| <<virtio_pci_modern_probe>> vp_dev->notify_base = map_capability(pci_dev, notify, 2, 2,
+ *                                                                                                              0, notify_length,
+ *                                                                                                              &vp_dev->notify_len);
+ *   - drivers/virtio/virtio_pci_modern.c|773| <<virtio_pci_modern_probe>> vp_dev->device = map_capability(pci_dev, device, 0, 4,
+ *                                                                                                         0, PAGE_SIZE,
+ *                                                                                                         &vp_dev->device_len);
+ */
 static void __iomem *map_capability(struct pci_dev *dev, int off,
 				    size_t minlen,
 				    u32 align,
@@ -140,6 +160,13 @@ static void __iomem *map_capability(struct pci_dev *dev, int off,
 }
 
 /* virtio config->get_features() implementation */
+/*
+ * called only by:
+ *   - drivers/virtio/virtio.c|331| <<virtio_dev_probe>> device_features = dev->config->get_features(dev);
+ *
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.get_features = vp_get_features()
+ * struct virtio_config_ops virtio_pci_config_ops.get_features = vp_get_features()
+ */
 static u64 vp_get_features(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -164,6 +191,10 @@ static void vp_transport_features(struct virtio_device *vdev, u64 features)
 }
 
 /* virtio config->finalize_features() implementation */
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.finalize_features = vp_finalize_features()
+ * struct virtio_config_ops virtio_pci_config_ops.finalize_features = vp_finalize_features()
+ */
 static int vp_finalize_features(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -190,6 +221,9 @@ static int vp_finalize_features(struct virtio_device *vdev)
 }
 
 /* virtio config->get() implementation */
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.get = vp_get()
+ */
 static void vp_get(struct virtio_device *vdev, unsigned offset,
 		   void *buf, unsigned len)
 {
@@ -226,6 +260,9 @@ static void vp_get(struct virtio_device *vdev, unsigned offset,
 
 /* the config->set() implementation.  it's symmetric to the config->get()
  * implementation */
+/*
+ * struct virtio_config_ops virtio_pci_config_ops.set = vp_set()
+ */
 static void vp_set(struct virtio_device *vdev, unsigned offset,
 		   const void *buf, unsigned len)
 {
@@ -260,6 +297,10 @@ static void vp_set(struct virtio_device *vdev, unsigned offset,
 	}
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.generation = vp_generation()
+ * struct virtio_config_ops virtio_pci_config_ops.generation = vp_generation()
+ */
 static u32 vp_generation(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -267,12 +308,20 @@ static u32 vp_generation(struct virtio_device *vdev)
 }
 
 /* config->{get,set}_status() implementations */
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.get_status = vp_get_status()
+ * struct virtio_config_ops virtio_pci_config_ops.get_status = vp_get_status()
+ */
 static u8 vp_get_status(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	return vp_ioread8(&vp_dev->common->device_status);
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.set_status = vp_set_status()
+ * struct virtio_config_ops virtio_pci_config_ops.set_status = vp_set_status()
+ */
 static void vp_set_status(struct virtio_device *vdev, u8 status)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -281,6 +330,10 @@ static void vp_set_status(struct virtio_device *vdev, u8 status)
 	vp_iowrite8(status, &vp_dev->common->device_status);
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.reset = vp_reset()
+ * struct virtio_config_ops virtio_pci_config_ops.reset = vp_reset()
+ */
 static void vp_reset(struct virtio_device *vdev)
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
@@ -306,6 +359,18 @@ static u16 vp_config_vector(struct virtio_pci_device *vp_dev, u16 vector)
 	return vp_ioread16(&vp_dev->common->msix_config);
 }
 
+/*
+ * 只在以下被调用:
+ *   - drivers/virtio/virtio_pci_modern.c|742| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+ *
+ * 设置的地方 (legacy和modern用的不同的setup_vq()):
+ *   - drivers/virtio/virtio_pci_legacy.c|273| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+ *   - drivers/virtio/virtio_pci_modern.c|719| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+ * 
+ * 调用的地方:
+ *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+ *                                                                                   msix_vec);
+ */
 static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 				  struct virtio_pci_vq_info *info,
 				  unsigned index,
@@ -402,6 +467,10 @@ static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
 	return ERR_PTR(err);
 }
 
+/*
+ * struct virtio_config_ops virtio_pci_config_nodev_ops.find_vqs = vp_modern_find_vqs()
+ * struct virtio_config_ops virtio_pci_config_ops.find_vqs = vp_modern_find_vqs()
+ */
 static int vp_modern_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 			      struct virtqueue *vqs[],
 			      vq_callback_t *callbacks[],
@@ -426,6 +495,13 @@ static int vp_modern_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 	return 0;
 }
 
+/*
+ * 只在以下被使用:
+ *   - drivers/virtio/virtio_pci_modern.c|763| <<virtio_pci_modern_probe>> vp_dev->del_vq = del_vq;
+ *
+ * 调用的地方:
+ *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+ */
 static void del_vq(struct virtio_pci_vq_info *info)
 {
 	struct virtqueue *vq = info->vq;
@@ -486,6 +562,25 @@ static const struct virtio_config_ops virtio_pci_config_ops = {
  *
  * Returns offset of the capability, or 0.
  */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_modern.c|662| <<virtio_pci_modern_probe>> common = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_COMMON_CFG,
+ *                                                                                                             IORESOURCE_IO | IORESOURCE_MEM,
+ *                                                                                                             &vp_dev->modern_bars);
+ *   - drivers/virtio/virtio_pci_modern.c|672| <<virtio_pci_modern_probe>> isr = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_ISR_CFG,
+ *                                                                                                          IORESOURCE_IO | IORESOURCE_MEM,
+ *                                                                                                          &vp_dev->modern_bars);
+ *   - drivers/virtio/virtio_pci_modern.c|675| <<virtio_pci_modern_probe>> notify = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_NOTIFY_CFG,
+ *                                                                                                             IORESOURCE_IO | IORESOURCE_MEM,
+ *                                                                                                             &vp_dev->modern_bars);
+ *   - drivers/virtio/virtio_pci_modern.c|695| <<virtio_pci_modern_probe>> device = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_DEVICE_CFG,
+ *                                                                                                             IORESOURCE_IO | IORESOURCE_MEM,
+ *                                                                                                             &vp_dev->modern_bars);
+ *
+ * 寻找cfg_type类型所代表的capability, 把相应的bar写入参数*bars中
+ * 返回找到的capability的pos, 否则返回0
+ * capability的例子: VIRTIO_PCI_CAP_COMMON_CFG等
+ */
 static inline int virtio_pci_find_capability(struct pci_dev *dev, u8 cfg_type,
 					     u32 ioresource_types, int *bars)
 {
@@ -581,6 +676,10 @@ static inline void check_offsets(void)
 }
 
 /* the PCI probing function */
+/*
+ * 被virtio_pci_probe()在两处调用:
+ *   - drivers/virtio/virtio_pci_common.c|771| <<virtio_pci_probe>> rc = virtio_pci_modern_probe(vp_dev);
+ */
 int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 {
 	struct pci_dev *pci_dev = vp_dev->pci_dev;
@@ -606,6 +705,10 @@ int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 	vp_dev->vdev.id.vendor = pci_dev->subsystem_vendor;
 
 	/* check for a common config: if not, use legacy mode (bar 0). */
+	/*
+	 * 寻找VIRTIO_PCI_CAP_COMMON_CFG类型所代表的capability, 把相应的bar写入参数vp_dev->modern_bars中
+	 * 返回找到的capability的pos到common(int), 否则返回0
+	 */
 	common = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_COMMON_CFG,
 					    IORESOURCE_IO | IORESOURCE_MEM,
 					    &vp_dev->modern_bars);
@@ -616,9 +719,17 @@ int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 	}
 
 	/* If common is there, these should be too... */
+	/*
+	 * 寻找VIRTIO_PCI_CAP_ISR_CFG类型所代表的capability, 把相应的bar写入参数vp_dev->modern_bars中
+	 * 返回找到的capability的pos到isr(int), 否则返回0
+	 */
 	isr = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_ISR_CFG,
 					 IORESOURCE_IO | IORESOURCE_MEM,
 					 &vp_dev->modern_bars);
+	/*
+	 * 寻找VIRTIO_PCI_CAP_NOTIFY_CFG类型所代表的capability, 把相应的bar写入参数vp_dev->modern_bars中
+	 * 返回找到的capability的pos到notify(int), 否则返回0
+	 */
 	notify = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_NOTIFY_CFG,
 					    IORESOURCE_IO | IORESOURCE_MEM,
 					    &vp_dev->modern_bars);
@@ -639,10 +750,15 @@ int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 	/* Device capability is only mandatory for devices that have
 	 * device-specific configuration.
 	 */
+	/*
+	 * 寻找VIRTIO_PCI_CAP_DEVICE_CFG类型所代表的capability, 把相应的bar写入参数vp_dev->modern_bars中
+	 * 返回找到的capability的pos到device(int), 否则返回0
+	 */
 	device = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_DEVICE_CFG,
 					    IORESOURCE_IO | IORESOURCE_MEM,
 					    &vp_dev->modern_bars);
 
+	/* 申请vp_dev->modern_bars上每一个bit所指向的bar */
 	err = pci_request_selected_regions(pci_dev, vp_dev->modern_bars,
 					   "virtio-pci-modern");
 	if (err)
@@ -701,13 +817,53 @@ int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 		if (!vp_dev->device)
 			goto err_map_device;
 
+		/*
+		 * 设置的地方:
+		 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+		 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+		 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+		 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+		 */
 		vp_dev->vdev.config = &virtio_pci_config_ops;
 	} else {
+		/*
+		 * 设置的地方:
+		 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops;
+		 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+		 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+		 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+		 */
 		vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
 	}
 
+	/*
+	 * 设置的地方 (legacy和modern用的不同的vp_config_vector()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|263| <<virtio_pci_legacy_probe>> vp_dev->config_vector = vp_config_vector;
+	 *   - drivers/virtio/virtio_pci_modern.c|709| <<virtio_pci_modern_probe>> vp_dev->config_vector = vp_config_vector;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|224| <<vp_request_msix_vectors>> v = vp_dev->config_vector(vp_dev, v);
+	 *   - drivers/virtio/virtio_pci_common.c|344| <<vp_del_vqs>> vp_dev->config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
+	 */
 	vp_dev->config_vector = vp_config_vector;
+	/*
+	 * 设置的地方 (legacy和modern用的不同的setup_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|273| <<virtio_pci_legacy_probe>> vp_dev->setup_vq = setup_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|719| <<virtio_pci_modern_probe>> vp_dev->setup_vq = setup_vq;
+	 * 
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|277| <<vp_setup_vq>> vq = vp_dev->setup_vq(vp_dev, info, index, callback, name, ctx,
+	 *                                                                                   msix_vec);
+	 */
 	vp_dev->setup_vq = setup_vq;
+	/*
+	 * 设置的地方 (legacy和modern用的不同的del_vq()):
+	 *   - drivers/virtio/virtio_pci_legacy.c|283| <<virtio_pci_legacy_probe>> vp_dev->del_vq = del_vq;
+	 *   - drivers/virtio/virtio_pci_modern.c|729| <<virtio_pci_modern_probe>> vp_dev->del_vq = del_vq;
+	 *
+	 * 调用的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|322| <<vp_del_vq>> vp_dev->del_vq(info);
+	 */
 	vp_dev->del_vq = del_vq;
 
 	return 0;
@@ -723,6 +879,11 @@ int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|791| <<virtio_pci_probe>> virtio_pci_modern_remove(vp_dev);
+ *   - drivers/virtio/virtio_pci_common.c|831| <<virtio_pci_remove>> virtio_pci_modern_remove(vp_dev);
+ */
 void virtio_pci_modern_remove(struct virtio_pci_device *vp_dev)
 {
 	struct pci_dev *pci_dev = vp_dev->pci_dev;
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index 814b395..525d275 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -792,6 +792,11 @@ EXPORT_SYMBOL_GPL(virtqueue_disable_cb);
  * Caller must ensure we don't call this with other virtqueue
  * operations at the same time (except where noted).
  */
+/*
+ * called by:
+ *   - drivers/net/virtio_net.c|322| <<virtqueue_napi_complete>> opaque = virtqueue_enable_cb_prepare(vq);
+ *   - drivers/virtio/virtio_ring.c|849| <<virtqueue_enable_cb>> unsigned last_used_idx = virtqueue_enable_cb_prepare(_vq);
+ */
 unsigned virtqueue_enable_cb_prepare(struct virtqueue *_vq)
 {
 	struct vring_virtqueue *vq = to_vvq(_vq);
diff --git a/include/linux/virtio.h b/include/linux/virtio.h
index fa1b5da..2a8335e 100644
--- a/include/linux/virtio.h
+++ b/include/linux/virtio.h
@@ -32,6 +32,17 @@ struct virtqueue {
 	struct virtio_device *vdev;
 	unsigned int index;
 	unsigned int num_free;
+	/*
+	 * priv设置的地方:
+	 *   - drivers/virtio/virtio_pci_legacy.c|157| <<setup_vq>> vq->priv = (void __force *)vp_dev->ioaddr + VIRTIO_PCI_QUEUE_NOTIFY;
+	 *   - drivers/virtio/virtio_pci_modern.c|372| <<setup_vq>> vq->priv = (void __force *)vp_dev->notify_base +
+	 *                                                                  off * vp_dev->notify_offset_multiplier;
+	 *   - drivers/virtio/virtio_pci_modern.c|375| <<setup_vq>> vq->priv = (void __force *)map_capability(vp_dev->pci_dev,
+	 *                                                                                    vp_dev->notify_map_cap, 2, 2,
+	 *                                                                                    off * vp_dev->notify_offset_multiplier, 2,
+	 *                                                                                    NULL);
+	 *   - drivers/virtio/virtio_mmio.c|438| <<vm_setup_vq>> vq->priv = info;
+	 */
 	void *priv;
 };
 
@@ -130,6 +141,13 @@ struct virtio_device {
 	spinlock_t config_lock;
 	struct device dev;
 	struct virtio_device_id id;
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	const struct virtio_config_ops *config;
 	const struct vringh_config_ops *vringh_config;
 	struct list_head vqs;
@@ -188,6 +206,10 @@ struct virtio_driver {
 	int (*probe)(struct virtio_device *dev);
 	void (*scan)(struct virtio_device *dev);
 	void (*remove)(struct virtio_device *dev);
+	/*
+	 * called only by:
+	 *   - drivers/virtio/virtio.c|181| <<__virtio_config_changed>> drv->config_changed(dev);
+	 */
 	void (*config_changed)(struct virtio_device *dev);
 #ifdef CONFIG_PM
 	int (*freeze)(struct virtio_device *dev);
diff --git a/include/linux/virtio_config.h b/include/linux/virtio_config.h
index 32baf8e..215ab4a 100644
--- a/include/linux/virtio_config.h
+++ b/include/linux/virtio_config.h
@@ -63,19 +63,77 @@ struct irq_affinity;
  */
 typedef void vq_callback_t(struct virtqueue *);
 struct virtio_config_ops {
+	/*
+	 * called by:
+	 *   - include/linux/virtio_config.h|364| <<__virtio_cread_many>> vdev->config->get(vdev, offset + bytes * i,
+	 *   - include/linux/virtio_config.h|382| <<virtio_cread8>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+	 *   - include/linux/virtio_config.h|396| <<virtio_cread16>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+	 *   - include/linux/virtio_config.h|411| <<virtio_cread32>> vdev->config->get(vdev, offset, &ret, sizeof(ret));
+	 *   - net/vmw_vsock/virtio_transport.c|428| <<virtio_vsock_update_guest_cid>> vdev->config->get(vdev, offsetof(struct virtio_vsock_config, guest_cid),
+	 */
 	void (*get)(struct virtio_device *vdev, unsigned offset,
 		    void *buf, unsigned len);
+	/*
+	 * called by:
+	 *   - include/linux/virtio_config.h|389| <<virtio_cwrite8>> vdev->config->set(vdev, offset, &val, sizeof(val));
+	 *   - include/linux/virtio_config.h|404| <<virtio_cwrite16>> vdev->config->set(vdev, offset, &val, sizeof(val));
+	 *   - include/linux/virtio_config.h|419| <<virtio_cwrite32>> vdev->config->set(vdev, offset, &val, sizeof(val));
+	 *   - include/linux/virtio_config.h|434| <<virtio_cwrite64>> vdev->config->set(vdev, offset, &val, sizeof(val));
+	 */
 	void (*set)(struct virtio_device *vdev, unsigned offset,
 		    const void *buf, unsigned len);
 	u32 (*generation)(struct virtio_device *vdev);
+	/*
+	 * called by:
+	 *   - drivers/virtio/virtio.c|31| <<status_show>> return sprintf(buf, "0x%08x\n", dev->config->get_status(dev));
+	 *   - drivers/virtio/virtio.c|248| <<virtio_add_status>> dev->config->set_status(dev, dev->config->get_status(dev) | status);
+	 *   - drivers/virtio/virtio.c|264| <<virtio_finalize_features>> status = dev->config->get_status(dev);
+	 *   - drivers/virtio/virtio.c|378| <<virtio_dev_probe>> if (!(dev->config->get_status(dev) & VIRTIO_CONFIG_S_DRIVER_OK))
+	 *   - drivers/virtio/virtio.c|427| <<virtio_dev_remove>> WARN_ON_ONCE(dev->config->get_status(dev));
+	 *   - drivers/virtio/virtio.c|550| <<virtio_device_freeze>> dev->failed = dev->config->get_status(dev) & VIRTIO_CONFIG_S_FAILED;
+	 *   - drivers/virtio/virtio_pci_common.c|862| <<virtio_pci_sriov_configure>> if (!(vdev->config->get_status(vdev) & VIRTIO_CONFIG_S_DRIVER_OK))
+	 *   - include/linux/virtio_config.h|220| <<virtio_device_ready>> unsigned status = dev->config->get_status(dev);
+	 */
 	u8 (*get_status)(struct virtio_device *vdev);
+	/*
+	 * called by:
+	 *   - drivers/virtio/virtio.c|248| <<virtio_add_status>> dev->config->set_status(dev, dev->config->get_status(dev) | status);
+	 *   - include/linux/virtio_config.h|249| <<virtio_device_ready>> dev->config->set_status(dev, status | VIRTIO_CONFIG_S_DRIVER_OK);
+	 */
 	void (*set_status)(struct virtio_device *vdev, u8 status);
+	/*
+	 * called by:
+	 *   - drivers/virtio/virtio.c|508| <<register_virtio_device>> dev->config->reset(dev);
+	 *   - drivers/virtio/virtio.c|571| <<virtio_device_restore>> dev->config->reset(dev);
+	 *   - drivers/block/virtio_blk.c|907| <<virtblk_remove>> vdev->config->reset(vdev);
+	 *   - drivers/block/virtio_blk.c|929| <<virtblk_freeze>> vdev->config->reset(vdev);
+	 *   - drivers/scsi/virtio_scsi.c|781| <<virtscsi_remove_vqs>> vdev->config->reset(vdev);
+	 *   - drivers/net/virtio_net.c|3040| <<virtnet_probe>> vi->vdev->config->reset(vdev);
+	 *   - drivers/net/virtio_net.c|3056| <<remove_vq_common>> vi->vdev->config->reset(vi->vdev);
+	 *   - drivers/virtio/virtio_balloon.c|638| <<remove_common>> vb->vdev->config->reset(vb->vdev);
+	 *   - drivers/virtio/virtio_input.c|324| <<virtinput_remove>> vdev->config->reset(vdev);
+	 *   - drivers/char/hw_random/virtio-rng.c|149| <<remove_common>> vdev->config->reset(vdev);
+	 *   - drivers/char/virtio_console.c|1987| <<virtcons_remove>> vdev->config->reset(vdev);
+	 *   - drivers/char/virtio_console.c|2170| <<virtcons_freeze>> vdev->config->reset(vdev);
+	 *   - drivers/crypto/virtio/virtio_crypto_core.c|419| <<virtcrypto_probe>> vcrypto->vdev->config->reset(vdev);
+	 *   - drivers/crypto/virtio/virtio_crypto_core.c|451| <<virtcrypto_remove>> vdev->config->reset(vdev);
+	 *   - drivers/crypto/virtio/virtio_crypto_core.c|471| <<virtcrypto_freeze>> vdev->config->reset(vdev);
+	 *   - drivers/crypto/virtio/virtio_crypto_core.c|507| <<virtcrypto_restore>> vcrypto->vdev->config->reset(vdev);
+	 *   - drivers/net/caif/caif_virtio.c|763| <<cfv_remove>> vdev->config->reset(vdev);
+	 *   - drivers/rpmsg/virtio_rpmsg_bus.c|1005| <<rpmsg_remove>> vdev->config->reset(vdev);
+	 *   - net/9p/trans_virtio.c|715| <<p9_virtio_remove>> vdev->config->reset(vdev);
+	 *   - net/vmw_vsock/virtio_transport.c|640| <<virtio_vsock_remove>> vdev->config->reset(vdev);
+	 */
 	void (*reset)(struct virtio_device *vdev);
 	int (*find_vqs)(struct virtio_device *, unsigned nvqs,
 			struct virtqueue *vqs[], vq_callback_t *callbacks[],
 			const char * const names[], const bool *ctx,
 			struct irq_affinity *desc);
 	void (*del_vqs)(struct virtio_device *);
+	/*
+	 * called only by:
+	 *   - drivers/virtio/virtio.c|331| <<virtio_dev_probe>> device_features = dev->config->get_features(dev);
+	 */
 	u64 (*get_features)(struct virtio_device *vdev);
 	int (*finalize_features)(struct virtio_device *vdev);
 	const char *(*bus_name)(struct virtio_device *vdev);
diff --git a/include/uapi/linux/virtio_pci.h b/include/uapi/linux/virtio_pci.h
index 90007a1..b003f47 100644
--- a/include/uapi/linux/virtio_pci.h
+++ b/include/uapi/linux/virtio_pci.h
@@ -79,6 +79,13 @@
  * configuration space */
 #define VIRTIO_PCI_CONFIG_OFF(msix_enabled)	((msix_enabled) ? 24 : 20)
 /* Deprecated: please use VIRTIO_PCI_CONFIG_OFF instead */
+/*
+ * 如果virtio_pci_device->msix_enabled=true返回24, 否则返回20
+ *
+ * virtio_pci_device->msix_enabled应该是在qemu的参数设置"-device virtio-blk-pci"的"vectors="设置
+ * 如果vectors的数目不够,就不用msix了
+ * 如果virtio_pci_device->msix_enabled则支持VIRTIO_MSI_CONFIG_VECTOR和VIRTIO_MSI_QUEUE_VECTOR
+ */
 #define VIRTIO_PCI_CONFIG(dev)	VIRTIO_PCI_CONFIG_OFF((dev)->msix_enabled)
 
 /* Virtio ABI version, this must match exactly */
-- 
2.7.4

