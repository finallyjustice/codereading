From cfeb56443e13f8d9f7e823df6defefef00f7c8c5 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang@oracle.com>
Date: Fri, 23 Nov 2018 06:18:43 +0800
Subject: [PATCH 1/1] virtio comment for linux-4.19.3

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 drivers/block/virtio_blk.c         |  92 +++++++++++++++++++
 drivers/virtio/virtio.c            | 182 +++++++++++++++++++++++++++++++++++++
 drivers/virtio/virtio_pci_common.c | 155 +++++++++++++++++++++++++++++++
 drivers/virtio/virtio_pci_common.h |  14 +++
 include/linux/virtio.h             |  11 +++
 5 files changed, 454 insertions(+)

diff --git a/drivers/block/virtio_blk.c b/drivers/block/virtio_blk.c
index 23752dc..078b388 100644
--- a/drivers/block/virtio_blk.c
+++ b/drivers/block/virtio_blk.c
@@ -422,6 +422,12 @@ static void virtblk_config_changed_work(struct work_struct *work)
 	kobject_uevent_env(&disk_to_dev(vblk->disk)->kobj, KOBJ_CHANGE, envp);
 }
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio.c|181| <<__virtio_config_changed>> drv->config_changed(dev);
+ *
+ * struct virtio_driver virtio_blk.config_changed = virtblk_config_changed()
+ */
 static void virtblk_config_changed(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -624,6 +630,52 @@ static const struct blk_mq_ops virtio_mq_ops = {
 static unsigned int virtblk_queue_depth;
 module_param_named(queue_depth, virtblk_queue_depth, uint, 0444);
 
+/*
+ * 初始化的时候:
+ * [0] virtblk_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtblk_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] bus_probe_device
+ * [0] device_add
+ * [0] register_virtio_device
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct virtio_driver virtio_blk.probe = virtblk_probe()
+ */
 static int virtblk_probe(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk;
@@ -812,6 +864,31 @@ static int virtblk_probe(struct virtio_device *vdev)
 	return err;
 }
 
+/*
+ * hotplug的时候:
+ * [0] virtblk_remove
+ * [0] virtio_dev_remove
+ * [0] device_release_driver_internal
+ * [0] bus_remove_device
+ * [0] device_del
+ * [0] device_unregister
+ * [0] unregister_virtio_device
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct virtio_driver virtio_blk.remove = virtblk_remove()
+ */
 static void virtblk_remove(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -841,6 +918,9 @@ static void virtblk_remove(struct virtio_device *vdev)
 }
 
 #ifdef CONFIG_PM_SLEEP
+/*
+ * struct virtio_driver virtio_blk.freeze = virtblk_freeze()
+ */
 static int virtblk_freeze(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -857,6 +937,9 @@ static int virtblk_freeze(struct virtio_device *vdev)
 	return 0;
 }
 
+/*
+ * struct virtio_driver virtio_blk.restore = virtblk_restore()
+ */
 static int virtblk_restore(struct virtio_device *vdev)
 {
 	struct virtio_blk *vblk = vdev->priv;
@@ -873,11 +956,17 @@ static int virtblk_restore(struct virtio_device *vdev)
 }
 #endif
 
+/*
+ * struct virtio_driver virtio_blk.id_table = id_table
+ */
 static const struct virtio_device_id id_table[] = {
 	{ VIRTIO_ID_BLOCK, VIRTIO_DEV_ANY_ID },
 	{ 0 },
 };
 
+/*
+ * struct virtio_driver virtio_blk.feature_table_legacy = features_legacy
+ */
 static unsigned int features_legacy[] = {
 	VIRTIO_BLK_F_SEG_MAX, VIRTIO_BLK_F_SIZE_MAX, VIRTIO_BLK_F_GEOMETRY,
 	VIRTIO_BLK_F_RO, VIRTIO_BLK_F_BLK_SIZE,
@@ -888,6 +977,9 @@ static unsigned int features_legacy[] = {
 	VIRTIO_BLK_F_MQ,
 }
 ;
+/*
+ * struct virtio_driver virtio_blk.feature_table = features
+ */
 static unsigned int features[] = {
 	VIRTIO_BLK_F_SEG_MAX, VIRTIO_BLK_F_SIZE_MAX, VIRTIO_BLK_F_GEOMETRY,
 	VIRTIO_BLK_F_RO, VIRTIO_BLK_F_BLK_SIZE,
diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c
index 59e36ef..35831da 100644
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@ -58,6 +58,7 @@ static ssize_t features_show(struct device *_d,
 }
 static DEVICE_ATTR_RO(features);
 
+/* 用在下面的ATTRIBUTE_GROUPS(virtio_dev) */
 static struct attribute *virtio_dev_attrs[] = {
 	&dev_attr_device.attr,
 	&dev_attr_vendor.attr,
@@ -66,8 +67,19 @@ static struct attribute *virtio_dev_attrs[] = {
 	&dev_attr_features.attr,
 	NULL,
 };
+/*
+ * static const struct attribute_group virtio_dev_group = {
+ *     .attrs = virtio_dev_attrs,
+ * };
+ *
+ * struct bus_type virtio_bus.dev_groups = virtio_dev_group
+ */
 ATTRIBUTE_GROUPS(virtio_dev);
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio.c|138| <<virtio_dev_match>> if (virtio_id_match(dev, &ids[i]))
+ */
 static inline int virtio_id_match(const struct virtio_device *dev,
 				  const struct virtio_device_id *id)
 {
@@ -79,6 +91,46 @@ static inline int virtio_id_match(const struct virtio_device *dev,
 
 /* This looks through all the IDs a driver claims to support.  If any of them
  * match, we return 1 and the kernel will call virtio_dev_probe(). */
+/*
+ * 初始化的时候:
+ * [0] virtio_dev_match
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_dev_match+0x19/0x70
+ * [0] __device_attach_driver+0x34/0xa0
+ * [0] bus_for_each_drv+0x5f/0xb0
+ * [0] __device_attach+0xd4/0x130
+ * [0] bus_probe_device+0x85/0xa0
+ * [0] device_add+0x3be/0x650
+ * [0] register_virtio_device+0xb7/0x100
+ * [0] virtio_pci_probe+0xbd/0x150
+ * [0] local_pci_probe+0x3f/0x90
+ * [0] pci_device_probe+0xdd/0x170
+ * [0] really_probe+0x231/0x2d0
+ * [0] driver_probe_device+0x4a/0xe0
+ * [0] bus_for_each_drv+0x5f/0xb0
+ * [0] __device_attach+0xd4/0x130
+ * [0] pci_bus_add_device+0x45/0x90
+ * [0] pci_bus_add_devices+0x31/0x70
+ * [0] pciehp_configure_device+0x8e/0x130
+ * [0] pciehp_handle_presence_or_link_change+0x288/0x4d0
+ * [0] pciehp_ist+0x1ae/0x1c0
+ * [0] irq_thread_fn+0x1c/0x60
+ * [0] irq_thread+0x12f/0x190
+ * [0] kthread+0xf3/0x130
+ * [0] ret_from_fork+0x35/0x40
+ *
+ * struct bus_type virtio_bus.match = virtio_dev_match()
+ */
 static int virtio_dev_match(struct device *_dv, struct device_driver *_dr)
 {
 	unsigned int i;
@@ -92,6 +144,9 @@ static int virtio_dev_match(struct device *_dv, struct device_driver *_dr)
 	return 0;
 }
 
+/*
+ * struct bus_type virtio_bus.uevent = virtio_uevent()
+ */
 static int virtio_uevent(struct device *_dv, struct kobj_uevent_env *env)
 {
 	struct virtio_device *dev = dev_to_virtio(_dv);
@@ -120,6 +175,11 @@ void virtio_check_driver_offered_feature(const struct virtio_device *vdev,
 }
 EXPORT_SYMBOL_GPL(virtio_check_driver_offered_feature);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|189| <<virtio_config_changed>> __virtio_config_changed(dev);
+ *   - drivers/virtio/virtio.c|207| <<virtio_config_enable>> __virtio_config_changed(dev);
+ */
 static void __virtio_config_changed(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
@@ -130,6 +190,13 @@ static void __virtio_config_changed(struct virtio_device *dev)
 		drv->config_changed(dev);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|72| <<vp_config_changed>> virtio_config_changed(&vp_dev->vdev);
+ *   - drivers/virtio/virtio_mmio.c|300| <<vm_interrupt>> virtio_config_changed(&vm_dev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1076| <<virtio_ccw_int_handler>> virtio_config_changed(&vcdev->vdev);
+ *   - drivers/misc/mic/vop/vop_main.c|548| <<_vop_handle_config_change>> virtio_config_changed(&vdev->vdev);
+ */
 void virtio_config_changed(struct virtio_device *dev)
 {
 	unsigned long flags;
@@ -140,6 +207,11 @@ void virtio_config_changed(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_config_changed);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|405| <<virtio_dev_remove>> virtio_config_disable(dev);
+ *   - drivers/virtio/virtio.c|531| <<virtio_device_freeze>> virtio_config_disable(dev);
+ */
 void virtio_config_disable(struct virtio_device *dev)
 {
 	spin_lock_irq(&dev->config_lock);
@@ -148,6 +220,11 @@ void virtio_config_disable(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_config_disable);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio.c|367| <<virtio_dev_probe>> virtio_config_enable(dev);
+ *   - drivers/virtio/virtio.c|583| <<virtio_device_restore>> virtio_config_enable(dev);
+ */
 void virtio_config_enable(struct virtio_device *dev)
 {
 	spin_lock_irq(&dev->config_lock);
@@ -161,6 +238,13 @@ EXPORT_SYMBOL_GPL(virtio_config_enable);
 
 void virtio_add_status(struct virtio_device *dev, unsigned int status)
 {
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	dev->config->set_status(dev, dev->config->get_status(dev) | status);
 }
 EXPORT_SYMBOL_GPL(virtio_add_status);
@@ -187,6 +271,50 @@ int virtio_finalize_features(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_finalize_features);
 
+/*
+ * 初始化的时候:
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] bus_probe_device
+ * [0] device_add
+ * [0] register_virtio_device
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0]ret_from_fork
+ *
+ * struct bus_type virtio_bus.probe = virtio_dev_probe()
+ */
 static int virtio_dev_probe(struct device *_d)
 {
 	int err, i;
@@ -262,6 +390,30 @@ static int virtio_dev_probe(struct device *_d)
 
 }
 
+/*
+ * hotplug的时候:
+ * [0] virtio_dev_remove
+ * [0] device_release_driver_internal
+ * [0] bus_remove_device
+ * [0] device_del
+ * [0] device_unregister
+ * [0] unregister_virtio_device
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct bus_type virtio_bus.remove = virtio_dev_remove()
+ */
 static int virtio_dev_remove(struct device *_d)
 {
 	struct virtio_device *dev = dev_to_virtio(_d);
@@ -312,8 +464,21 @@ EXPORT_SYMBOL_GPL(unregister_virtio_driver);
  *
  * Returns: 0 on suceess, -error on failure
  */
+/*
+ * 其实就被一个用的到的调用:
+ *   - drivers/virtio/virtio_pci_common.c|624| <<virtio_pci_probe>> rc = register_virtio_device(&vp_dev->vdev);
+ *
+ * 其他的用不到:
+ *   - drivers/virtio/virtio_mmio.c|601| <<virtio_mmio_probe>> rc = register_virtio_device(&vm_dev->vdev);
+ *   - drivers/misc/mic/vop/vop_main.c|501| <<_vop_add_device>> ret = register_virtio_device(&vdev->vdev);
+ *   - drivers/remoteproc/remoteproc_virtio.c|328| <<rproc_add_virtio_dev>> ret = register_virtio_device(vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1261| <<virtio_ccw_online>> ret = register_virtio_device(&vcdev->vdev);
+ */
 int register_virtio_device(struct virtio_device *dev)
 {
+	/*
+	 * 参数dev被包含在struct virtio_pci_device
+	 */
 	int err;
 
 	dev->dev.bus = &virtio_bus;
@@ -333,6 +498,13 @@ int register_virtio_device(struct virtio_device *dev)
 
 	/* We always start by resetting the device, in case a previous
 	 * driver messed it up.  This also tests that code path a little. */
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	dev->config->reset(dev);
 
 	/* Acknowledge that we've seen the device. */
@@ -364,6 +536,11 @@ void unregister_virtio_device(struct virtio_device *dev)
 EXPORT_SYMBOL_GPL(unregister_virtio_device);
 
 #ifdef CONFIG_PM_SLEEP
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|467| <<virtio_pci_freeze>> ret = virtio_device_freeze(&vp_dev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1320| <<virtio_ccw_freeze>> return virtio_device_freeze(&vcdev->vdev);
+ */
 int virtio_device_freeze(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
@@ -379,6 +556,11 @@ int virtio_device_freeze(struct virtio_device *dev)
 }
 EXPORT_SYMBOL_GPL(virtio_device_freeze);
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|485| <<virtio_pci_restore>> return virtio_device_restore(&vp_dev->vdev);
+ *   - drivers/s390/virtio/virtio_ccw.c|1332| <<virtio_ccw_restore>> return virtio_device_restore(&vcdev->vdev);
+ */
 int virtio_device_restore(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
diff --git a/drivers/virtio/virtio_pci_common.c b/drivers/virtio/virtio_pci_common.c
index 465a6f5..e4e6a51 100644
--- a/drivers/virtio/virtio_pci_common.c
+++ b/drivers/virtio/virtio_pci_common.c
@@ -19,6 +19,16 @@
 
 #include "virtio_pci_common.h"
 
+/*
+ * 2个virtio-blk(每个2个queue)的例子:
+ *  24:          0          0   PCI-MSI 49152-edge      virtio0-config
+ *  25:       1245          0   PCI-MSI 49153-edge      virtio0-req.0
+ *  26:          0       1617   PCI-MSI 49154-edge      virtio0-req.1
+ *  27:          0          0   PCI-MSI 65536-edge      virtio1-config
+ *  28:         35          0   PCI-MSI 65537-edge      virtio1-req.0
+ *  29:          0         34   PCI-MSI 65538-edge      virtio1-req.1
+ */
+
 static bool force_legacy = false;
 
 #if IS_ENABLED(CONFIG_VIRTIO_PCI_LEGACY)
@@ -28,11 +38,35 @@ MODULE_PARM_DESC(force_legacy,
 #endif
 
 /* wait for pending irq handlers */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_legacy.c|102| <<vp_reset>> vp_synchronize_vectors(vdev);
+ *   - drivers/virtio/virtio_pci_modern.c|297| <<vp_reset>> vp_synchronize_vectors(vdev);
+ *
+ * 等待所有属于这个设备的pending的irq handler完成
+ */
 void vp_synchronize_vectors(struct virtio_device *vdev)
 {
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 把struct virtio_device转换成struct virtio_pci_device
+	 */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	int i;
 
+	/*
+	 * synchronize_irq():
+	 *   This function waits for any pending IRQ handlers for this interrupt
+	 *   to complete before returning. If you use this function while
+	 *   holding a resource the IRQ handler may need you will deadlock.
+	 *   This function may be called - with care - from IRQ context.
+	 */
+
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|283| <<vp_del_vqs>> vp_dev->intx_enabled = 0;
+	 *   - drivers/virtio/virtio_pci_common.c|401| <<vp_find_vqs_intx>> vp_dev->intx_enabled = 1;
+	 */
 	if (vp_dev->intx_enabled)
 		synchronize_irq(vp_dev->pci_dev->irq);
 
@@ -41,6 +75,11 @@ void vp_synchronize_vectors(struct virtio_device *vdev)
 }
 
 /* the notify function used when creating a virt queue */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_legacy.c|141| <<setup_vq>> vp_notify, callback, name);
+ *   - drivers/virtio/virtio_pci_modern.c|347| <<setup_vq>> vp_notify, callback, name);
+ */
 bool vp_notify(struct virtqueue *vq)
 {
 	/* we write the queue's selector into the notification register to
@@ -82,6 +121,11 @@ static irqreturn_t vp_vring_interrupt(int irq, void *opaque)
  * the callback may notify the host which results in the host attempting to
  * raise an interrupt that we would then mask once we acknowledged the
  * interrupt. */
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|370| <<vp_find_vqs_intx>> err = request_irq(vp_dev->pci_dev->irq, vp_interrupt, IRQF_SHARED,
+ *                                                                                    dev_name(&vdev->dev), vp_dev);
+ */
 static irqreturn_t vp_interrupt(int irq, void *opaque)
 {
 	struct virtio_pci_device *vp_dev = opaque;
@@ -102,6 +146,10 @@ static irqreturn_t vp_interrupt(int irq, void *opaque)
 	return vp_vring_interrupt(irq, opaque);
 }
 
+/*
+ * called by:
+ *   - drivers/virtio/virtio_pci_common.c|336| <<vp_find_vqs_msix>> err = vp_request_msix_vectors(vdev, nvectors, per_vq_vectors,
+ */
 static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 				   bool per_vq_vectors, struct irq_affinity *desc)
 {
@@ -351,6 +399,10 @@ static int vp_find_vqs_msix(struct virtio_device *vdev, unsigned nvqs,
 	return err;
 }
 
+/*
+ * called only by:
+ *   - drivers/virtio/virtio_pci_common.c|440| <<vp_find_vqs>> return vp_find_vqs_intx(vdev, nvqs, vqs, callbacks, names, ctx);
+ */
 static int vp_find_vqs_intx(struct virtio_device *vdev, unsigned nvqs,
 		struct virtqueue *vqs[], vq_callback_t *callbacks[],
 		const char * const names[], const bool *ctx)
@@ -485,6 +537,9 @@ static int virtio_pci_restore(struct device *dev)
 	return virtio_device_restore(&vp_dev->vdev);
 }
 
+/*
+ * struct pci_driver virtio_pci_driver.drive.pm = virtio_pci_pm_ops
+ */
 static const struct dev_pm_ops virtio_pci_pm_ops = {
 	SET_SYSTEM_SLEEP_PM_OPS(virtio_pci_freeze, virtio_pci_restore)
 };
@@ -492,6 +547,9 @@ static const struct dev_pm_ops virtio_pci_pm_ops = {
 
 
 /* Qumranet donated their vendor ID for devices 0x1000 thru 0x10FF. */
+/*
+ * struct pci_driver virtio_pci_driver.id_table = virtio_pci_id_table
+ */
 static const struct pci_device_id virtio_pci_id_table[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_REDHAT_QUMRANET, PCI_ANY_ID) },
 	{ 0 }
@@ -499,9 +557,19 @@ static const struct pci_device_id virtio_pci_id_table[] = {
 
 MODULE_DEVICE_TABLE(pci, virtio_pci_id_table);
 
+/*
+ * used only by:
+ *   - drivers/virtio/virtio_pci_common.c|597| <<virtio_pci_probe>> vp_dev->vdev.dev.release = virtio_pci_release_dev;
+ *
+ * struct virtio_device包含struct device
+ * struct virtio_pci_device包含struct virtio_device
+ * 于是根据struct device找到struct virtio_pci_device并释放
+ */
 static void virtio_pci_release_dev(struct device *_d)
 {
+	/* struct virtio_device包含struct device */
 	struct virtio_device *vdev = dev_to_virtio(_d);
+	/* struct virtio_pci_device包含struct virtio_device */
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 
 	/* As struct device is a kobject, it's not safe to
@@ -510,6 +578,43 @@ static void virtio_pci_release_dev(struct device *_d)
 	kfree(vp_dev);
 }
 
+/*
+ * 初始化的时候:
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * hotplug的时候:
+ * [0] virtio_pci_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] bus_for_each_drv
+ * [0] __device_attach
+ * [0] pci_bus_add_device
+ * [0] pci_bus_add_devices
+ * [0] pciehp_configure_device
+ * [0] pciehp_handle_presence_or_link_change
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct pci_driver virtio_pci_driver.probe = virtio_pci_probe()
+ */
 static int virtio_pci_probe(struct pci_dev *pci_dev,
 			    const struct pci_device_id *id)
 {
@@ -517,18 +622,42 @@ static int virtio_pci_probe(struct pci_dev *pci_dev,
 	int rc;
 
 	/* allocate our structure and fill it out */
+	/*
+	 * struct virtio_pci_device包含struct virtio_device
+	 */
 	vp_dev = kzalloc(sizeof(struct virtio_pci_device), GFP_KERNEL);
+	/*
+	 * qemu是否可以回收干净??
+	 */
 	if (!vp_dev)
 		return -ENOMEM;
 
+	/* 把pci_dev->dev->driver_data设置为vp_dev (virtio_pci_device) */
 	pci_set_drvdata(pci_dev, vp_dev);
+	/*
+	 * vp_dev->vdev是struct virtio_device
+	 * vp_dev->vdev.dev是struct device
+	 */
 	vp_dev->vdev.dev.parent = &pci_dev->dev;
+	/*
+	 * struct virtio_device包含struct device
+	 * struct virtio_pci_device包含struct virtio_device
+	 * 于是根据struct device找到struct virtio_pci_device并释放
+	 */
 	vp_dev->vdev.dev.release = virtio_pci_release_dev;
 	vp_dev->pci_dev = pci_dev;
 	INIT_LIST_HEAD(&vp_dev->virtqueues);
 	spin_lock_init(&vp_dev->lock);
 
 	/* enable the device */
+	/*
+	 * Initialize device before it's used by a driver. Ask low-level code
+	 *  to enable I/O and memory. Wake up the device if it was suspended.
+	 *  Beware, this function can fail.
+	 *
+	 *  Note we don't actually enable the device many times if we call
+	 *  this function repeatedly (we just increment the count).
+	 */
 	rc = pci_enable_device(pci_dev);
 	if (rc)
 		goto err_enable_device;
@@ -572,6 +701,23 @@ static int virtio_pci_probe(struct pci_dev *pci_dev,
 	return rc;
 }
 
+/*
+ * [0] virtio_pci_remove
+ * [0] pci_device_remove
+ * [0] device_release_driver_internal
+ * [0] pci_stop_bus_device
+ * [0] pci_stop_and_remove_bus_device
+ * [0] pciehp_unconfigure_device
+ * [0] pciehp_disable_slot
+ * [0] pciehp_handle_disable_request
+ * [0] pciehp_ist
+ * [0] irq_thread_fn
+ * [0] irq_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct pci_driver virtio_pci_driver.remove = virtio_pci_remove()
+ */
 static void virtio_pci_remove(struct pci_dev *pci_dev)
 {
 	struct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);
@@ -590,6 +736,15 @@ static void virtio_pci_remove(struct pci_dev *pci_dev)
 	put_device(dev);
 }
 
+/*
+ * called by:
+ *   - drivers/pci/pci-sysfs.c|608| <<sriov_numvfs_store>> ret = pdev->driver->sriov_configure(pdev, 0);
+ *   - drivers/pci/pci-sysfs.c|620| <<sriov_numvfs_store>> ret = pdev->driver->sriov_configure(pdev, num_vfs);
+ *
+ * struct pci_driver virtio_pci_driver.sriov_configure = virtio_pci_sriov_configure()
+ *
+ * 没看到怎么使用
+ */
 static int virtio_pci_sriov_configure(struct pci_dev *pci_dev, int num_vfs)
 {
 	struct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);
diff --git a/drivers/virtio/virtio_pci_common.h b/drivers/virtio/virtio_pci_common.h
index 0227100..6f1fd75 100644
--- a/drivers/virtio/virtio_pci_common.h
+++ b/drivers/virtio/virtio_pci_common.h
@@ -83,7 +83,17 @@ struct virtio_pci_device {
 	struct virtio_pci_vq_info **vqs;
 
 	/* MSI-X support */
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|171| <<vp_request_msix_vectors>> vp_dev->msix_enabled = 1;
+	 *   - drivers/virtio/virtio_pci_common.c|298| <<vp_del_vqs>> vp_dev->msix_enabled = 0;
+	 */
 	int msix_enabled;
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_pci_common.c|283| <<vp_del_vqs>> vp_dev->intx_enabled = 0;
+	 *   - drivers/virtio/virtio_pci_common.c|401| <<vp_find_vqs_intx>> vp_dev->intx_enabled = 1;
+	 */
 	int intx_enabled;
 	cpumask_var_t *msix_affinity_masks;
 	/* Name strings for interrupts. This size should be enough,
@@ -118,6 +128,10 @@ enum {
 };
 
 /* Convert a generic virtio device to our structure */
+/*
+ * struct virtio_pci_device包含struct virtio_device
+ * 把struct virtio_device转换成struct virtio_pci_device
+ */
 static struct virtio_pci_device *to_vp_device(struct virtio_device *vdev)
 {
 	return container_of(vdev, struct virtio_pci_device, vdev);
diff --git a/include/linux/virtio.h b/include/linux/virtio.h
index fa1b5da..a8c2a55 100644
--- a/include/linux/virtio.h
+++ b/include/linux/virtio.h
@@ -130,6 +130,13 @@ struct virtio_device {
 	spinlock_t config_lock;
 	struct device dev;
 	struct virtio_device_id id;
+	/*
+	 * 设置的地方:
+	 *   - drivers/virtio/virtio_mmio.c|546| <<virtio_mmio_probe>> vm_dev->vdev.config = &virtio_mmio_config_ops; 
+	 *   - drivers/virtio/virtio_pci_legacy.c|261| <<virtio_pci_legacy_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|704| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_ops;
+	 *   - drivers/virtio/virtio_pci_modern.c|706| <<virtio_pci_modern_probe>> vp_dev->vdev.config = &virtio_pci_config_nodev_ops;
+	 */
 	const struct virtio_config_ops *config;
 	const struct vringh_config_ops *vringh_config;
 	struct list_head vqs;
@@ -188,6 +195,10 @@ struct virtio_driver {
 	int (*probe)(struct virtio_device *dev);
 	void (*scan)(struct virtio_device *dev);
 	void (*remove)(struct virtio_device *dev);
+	/*
+	 * called only by:
+	 *   - drivers/virtio/virtio.c|181| <<__virtio_config_changed>> drv->config_changed(dev);
+	 */
 	void (*config_changed)(struct virtio_device *dev);
 #ifdef CONFIG_PM
 	int (*freeze)(struct virtio_device *dev);
-- 
2.7.4

