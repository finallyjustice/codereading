From b2df0dd8a181d5f317381f900c0f1bc8a367c4a0 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang@oracle.com>
Date: Wed, 12 Dec 2018 06:17:44 +0800
Subject: [PATCH 1/1] seabios: comment for seabios-1.12.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
Signed-off-by: Dongli Zhang <dongli.zhang@oracle.com>
---
 src/fw/pciinit.c | 50 ++++++++++++++++++++++++++++++++++++++++++++++++++
 src/hw/pci.c     | 14 ++++++++++++++
 2 files changed, 64 insertions(+)

diff --git a/src/fw/pciinit.c b/src/fw/pciinit.c
index c0634bc..0b68e69 100644
--- a/src/fw/pciinit.c
+++ b/src/fw/pciinit.c
@@ -73,6 +73,9 @@ struct pci_bus {
     struct pci_device *bus_dev;
 };
 
+/*
+ * 返回存储region_num这个bar在config space中的offset
+ */
 static u32 pci_bar(struct pci_device *pci, int region_num)
 {
     if (region_num != PCI_ROM_SLOT) {
@@ -84,9 +87,22 @@ static u32 pci_bar(struct pci_device *pci, int region_num)
     return type == PCI_HEADER_TYPE_BRIDGE ? PCI_ROM_ADDRESS1 : PCI_ROM_ADDRESS;
 }
 
+/*
+ * called by:
+ *   - src/fw/pciinit.c|221| <<storage_ide_setup>> pci_set_io_region_addr(pci, 0, PORT_ATA1_CMD_BASE, 0);
+ *   - src/fw/pciinit.c|222| <<storage_ide_setup>> pci_set_io_region_addr(pci, 1, PORT_ATA1_CTRL_BASE, 0);
+ *   - src/fw/pciinit.c|223| <<storage_ide_setup>> pci_set_io_region_addr(pci, 2, PORT_ATA2_CMD_BASE, 0);
+ *   - src/fw/pciinit.c|224| <<storage_ide_setup>> pci_set_io_region_addr(pci, 3, PORT_ATA2_CTRL_BASE, 0);
+ *   - src/fw/pciinit.c|238| <<pic_ibm_setup>> pci_set_io_region_addr(pci, 0, 0x80800000 + 0x00040000, 0);
+ *   - src/fw/pciinit.c|244| <<apple_macio_setup>> pci_set_io_region_addr(pci, 0, 0x80800000, 0);
+ *   - src/fw/pciinit.c|1059| <<pci_region_map_one_entry>> pci_set_io_region_addr(entry->dev, entry->bar, addr, entry->is64);
+ *
+ * 更新pci config space中某个bar的地址
+ */
 static void
 pci_set_io_region_addr(struct pci_device *pci, int bar, u64 addr, int is64)
 {
+    /* 返回存储bar在config space中的offset */
     u32 ofs = pci_bar(pci, bar);
     pci_config_writel(pci->bdf, ofs, addr);
     if (is64)
@@ -563,6 +579,12 @@ static u8 pci_find_resource_reserve_capability(u16 bdf)
  * Bus initialization
  ****************************************************************/
 
+/*
+ * called by:
+ *   - src/fw/pciinit.c|614| <<pci_bios_init_bus_rec>> pci_bios_init_bus_rec(secbus, pci_bus);
+ *   - src/fw/pciinit.c|655| <<pci_bios_init_bus>> pci_bios_init_bus_rec(0 , &pci_bus);
+ *   - src/fw/pciinit.c|660| <<pci_bios_init_bus>> pci_bios_init_bus_rec(pci_bus, &pci_bus);
+ */
 static void
 pci_bios_init_bus_rec(int bus, u8 *pci_bus)
 {
@@ -768,6 +790,11 @@ static void pci_region_migrate_64bit_entries(struct pci_region *from,
     }
 }
 
+/*
+ * called by:
+ *   - src/fw/pciinit.c|888| <<pci_bios_check_devices>> struct pci_region_entry *entry = pci_region_create_entry(
+ *   - src/fw/pciinit.c|975| <<pci_bios_check_devices>> struct pci_region_entry *entry = pci_region_create_entry(
+ */
 static struct pci_region_entry *
 pci_region_create_entry(struct pci_bus *bus, struct pci_device *dev,
                         int bar, u64 size, u64 align, int type, int is64)
@@ -1013,6 +1040,11 @@ static int pci_bios_init_root_regions_io(struct pci_bus *bus)
     return 0;
 }
 
+/*
+ * called by:
+ *   - src/fw/pciinit.c|1140| <<pci_bios_map_devices>> if (pci_bios_init_root_regions_mem(busses)) {
+ *   - src/fw/pciinit.c|1149| <<pci_bios_map_devices>> if (pci_bios_init_root_regions_mem(busses))
+ */
 static int pci_bios_init_root_regions_mem(struct pci_bus *bus)
 {
     struct pci_region *r_end = &bus->r[PCI_REGION_TYPE_PREFMEM];
@@ -1041,6 +1073,10 @@ static int pci_bios_init_root_regions_mem(struct pci_bus *bus)
 #define PCI_MEMORY_SHIFT        16
 #define PCI_PREF_MEMORY_SHIFT   16
 
+/*
+ * called by:
+ *   - src/fw/pciinit.c|1093| <<pci_region_map_entries>> pci_region_map_one_entry(entry, addr);
+ */
 static void
 pci_region_map_one_entry(struct pci_region_entry *entry, u64 addr)
 {
@@ -1074,6 +1110,12 @@ pci_region_map_one_entry(struct pci_region_entry *entry, u64 addr)
     }
 }
 
+/*
+ * called by:
+ *   - src/fw/pciinit.c|1154| <<pci_bios_map_devices>> pci_region_map_entries(busses, &r64_mem);
+ *   - src/fw/pciinit.c|1155| <<pci_bios_map_devices>> pci_region_map_entries(busses, &r64_pref);
+ *   - src/fw/pciinit.c|1165| <<pci_bios_map_devices>> pci_region_map_entries(busses, &busses[bus].r[type]);
+ */
 static void pci_region_map_entries(struct pci_bus *busses, struct pci_region *r)
 {
     struct hlist_node *n;
@@ -1090,6 +1132,10 @@ static void pci_region_map_entries(struct pci_bus *busses, struct pci_region *r)
     }
 }
 
+/*
+ * called by:
+ *   - src/fw/pciinit.c|1209| <<pci_setup>> pci_bios_map_devices(busses);
+ */
 static void pci_bios_map_devices(struct pci_bus *busses)
 {
     if (pci_bios_init_root_regions_io(busses))
@@ -1146,6 +1192,10 @@ static void pci_bios_map_devices(struct pci_bus *busses)
  * Main setup code
  ****************************************************************/
 
+/*
+ * 只被以下调用:
+ *   - src/fw/paravirt.c|165| <<qemu_platform_setup>> pci_setup();
+ */
 void
 pci_setup(void)
 {
diff --git a/src/hw/pci.c b/src/hw/pci.c
index 9855bad..eb54fcb 100644
--- a/src/hw/pci.c
+++ b/src/hw/pci.c
@@ -11,7 +11,13 @@
 #include "util.h" // udelay
 #include "x86.h" // outl
 
+/*
+ * pci用io port写的时候,先往addr寄存器写地址, 再往data寄存器写数据
+ */
+
+/* 在qemu中是MCH_HOST_BRIDGE_CONFIG_ADDR */
 #define PORT_PCI_CMD           0x0cf8
+/* 在qemu中是MCH_HOST_BRIDGE_CONFIG_DATA */
 #define PORT_PCI_DATA          0x0cfc
 
 void pci_config_writel(u16 bdf, u32 addr, u32 val)
@@ -114,6 +120,14 @@ pci_next(int bdf, int bus)
 int
 pci_probe_host(void)
 {
+    /*
+     * q35应该调用的qemu的pci_host_config_write()
+     *
+     * PCI规范使用从0CF8H~0CFFH 这8个I/O地址来访问所有设备的PCI配置空间.
+     * 这8个字节实际上构成了两个32位寄存器:0CF8H寄存器叫做"配置地址寄存器";
+     * 0CFCH叫做"配置数据寄存器".
+     * 当要访问配置空间的寄存器时,先向地址寄存器写上目标地址,然后就可以从数据寄存器中读写数据了.
+     */
     outl(0x80000000, PORT_PCI_CMD);
     if (inl(PORT_PCI_CMD) != 0x80000000) {
         dprintf(1, "Detected non-PCI system\n");
-- 
2.7.4

