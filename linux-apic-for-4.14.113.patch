From d18dbb913322b4e48d09a1b9ffa7fe31760136f6 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 3 Jun 2019 05:53:12 +0800
Subject: [PATCH 1/1] linux-apic-for-4.14.113

Signed-off-by: Dongli Zhang <dongli.zhang@oracle.com>
---
 arch/x86/include/asm/i8259.h       |  31 +++
 arch/x86/include/asm/io_apic.h     |  10 +
 arch/x86/include/asm/irq_vectors.h |   7 +
 arch/x86/kernel/apic/io_apic.c     | 438 +++++++++++++++++++++++++++++++++++++
 arch/x86/kernel/apic/msi.c         |  43 ++++
 arch/x86/kernel/apic/probe_64.c    |  13 ++
 arch/x86/kernel/apic/vector.c      |  96 ++++++++
 arch/x86/kernel/dumpstack.c        |   6 +
 arch/x86/kernel/hpet.c             |   9 +
 arch/x86/kernel/i8259.c            | 221 +++++++++++++++++++
 arch/x86/kernel/irq.c              |  25 +++
 arch/x86/kernel/irqinit.c          |  25 +++
 arch/x86/kernel/time.c             |  28 +++
 arch/x86/kernel/x86_init.c         |   7 +
 drivers/clocksource/i8253.c        |   4 +
 drivers/pci/msi.c                  |  76 +++++++
 include/linux/device.h             |  14 ++
 include/linux/irqdomain.h          |  30 +++
 include/linux/msi.h                |  11 +
 kernel/irq/chip.c                  |  11 +
 kernel/irq/irqdomain.c             | 132 +++++++++++
 kernel/irq/manage.c                |   7 +
 kernel/irq/msi.c                   |  82 +++++++
 kernel/irq_work.c                  |   6 +
 kernel/kexec_core.c                |  21 ++
 kernel/panic.c                     |   7 +
 kernel/time/tick-common.c          |   5 +
 kernel/time/tick-oneshot.c         |   9 +
 28 files changed, 1374 insertions(+)

diff --git a/arch/x86/include/asm/i8259.h b/arch/x86/include/asm/i8259.h
index 89789e8..909be79 100644
--- a/arch/x86/include/asm/i8259.h
+++ b/arch/x86/include/asm/i8259.h
@@ -8,7 +8,23 @@
 extern unsigned int cached_irq_mask;
 
 #define __byte(x, y)		(((unsigned char *)&(y))[x])
+/*
+ * 只使用, 不修改:
+ *   - arch/x86/kernel/i8259.c|113| <<mask_8259A_irq>> outb(cached_master_mask, PIC_MASTER_IMR);
+ *   - arch/x86/kernel/i8259.c|147| <<unmask_8259A_irq>> outb(cached_master_mask, PIC_MASTER_IMR);
+ *   - arch/x86/kernel/i8259.c|288| <<mask_and_ack_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+ *   - arch/x86/kernel/i8259.c|413| <<unmask_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+ *   - arch/x86/kernel/i8259.c|528| <<init_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+ */
 #define cached_master_mask	(__byte(0, cached_irq_mask))
+/*
+ * 只使用, 不修改:
+ *   - arch/x86/kernel/i8259.c|111| <<mask_8259A_irq>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+ *   - arch/x86/kernel/i8259.c|145| <<unmask_8259A_irq>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+ *   - arch/x86/kernel/i8259.c|281| <<mask_and_ack_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+ *   - arch/x86/kernel/i8259.c|414| <<unmask_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+ *   - arch/x86/kernel/i8259.c|529| <<init_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+ */
 #define cached_slave_mask	(__byte(1, cached_irq_mask))
 
 /* i8259A PIC registers */
@@ -61,9 +77,20 @@ struct legacy_pic {
 	void (*unmask)(unsigned int irq);
 	void (*mask_all)(void);
 	void (*restore_mask)(void);
+	/*
+	 * called by:
+	 *   - arch/x86/kernel/apic/io_apic.c|2166| <<check_timer>> legacy_pic->init(1);
+	 *   - arch/x86/kernel/apic/io_apic.c|2315| <<check_timer>> legacy_pic->init(0);
+	 *   - arch/x86/kernel/irqinit.c|68| <<init_ISA_irqs>> legacy_pic->init(0);
+	 */
 	void (*init)(int auto_eoi);
 	int (*probe)(void);
 	int (*irq_pending)(unsigned int irq);
+	/*
+	 * calld by:
+	 *   - arch/x86/kernel/apic/io_apic.c|1977| <<init_IO_APIC_traps>> legacy_pic->make_irq(irq);
+	 *   - arch/x86/kernel/apic/io_apic.c|2316| <<check_timer>> legacy_pic->make_irq(0);
+	 */
 	void (*make_irq)(unsigned int irq);
 };
 
@@ -75,6 +102,10 @@ static inline bool has_legacy_pic(void)
 	return legacy_pic != &null_legacy_pic;
 }
 
+/*
+ * 在default_legacy_pic返回NR_IRQS_LEGACY(16)
+ * 在null_legacy_pic返回0
+ */
 static inline int nr_legacy_irqs(void)
 {
 	return legacy_pic->nr_legacy_irqs;
diff --git a/arch/x86/include/asm/io_apic.h b/arch/x86/include/asm/io_apic.h
index 5c27e14..ad0a20d 100644
--- a/arch/x86/include/asm/io_apic.h
+++ b/arch/x86/include/asm/io_apic.h
@@ -150,6 +150,16 @@ extern unsigned long io_apic_irqs;
  * If we use the IO-APIC for IRQ routing, disable automatic
  * assignment of PCI IRQ's.
  */
+/*
+ * used by:
+ *   - arch/x86/pci/irq.c|898| <<pcibios_lookup_irq>> if (io_apic_assign_pci_irqs)
+ *   - arch/x86/pci/irq.c|1051| <<pcibios_fixup_irqs>> if (io_apic_assign_pci_irqs)
+ *   - arch/x86/pci/irq.c|1147| <<pcibios_irq_init>> if (io_apic_assign_pci_irqs)
+ *   - arch/x86/pci/irq.c|1153| <<pcibios_irq_init>> if (io_apic_assign_pci_irqs && pci_routeirq) {
+ *   - arch/x86/pci/irq.c|1198| <<pirq_enable_irq>> if (!io_apic_assign_pci_irqs && dev->irq)
+ *   - arch/x86/pci/irq.c|1201| <<pirq_enable_irq>> if (io_apic_assign_pci_irqs) {
+ *   - arch/x86/pci/irq.c|1275| <<pirq_disable_irq>> if (io_apic_assign_pci_irqs && !mp_should_keep_irq(&dev->dev) &&
+ */
 #define io_apic_assign_pci_irqs \
 	(mp_irq_entries && !skip_ioapic_setup && io_apic_irqs)
 
diff --git a/arch/x86/include/asm/irq_vectors.h b/arch/x86/include/asm/irq_vectors.h
index c20ffca..df116f4 100644
--- a/arch/x86/include/asm/irq_vectors.h
+++ b/arch/x86/include/asm/irq_vectors.h
@@ -53,6 +53,13 @@
  * Vectors 0x30-0x3f are used for ISA interrupts.
  *   round up to the next 16-vector boundary
  */
+/*
+ * FIRST_EXTERNAL_VECTOR = 0x20
+ * FIRST_EXTERNAL_VECTOR + 16 = 0x30 = 110000
+ * ~15 = ~1111 = 11110000
+ * ((FIRST_EXTERNAL_VECTOR + 16) & ~15) = 110000 & 11110000 = 110000 = 0x30
+ * 于是这里是输入一个irq, 返回0x30+irq, 也就是48+irq
+ */
 #define ISA_IRQ_VECTOR(irq)		(((FIRST_EXTERNAL_VECTOR + 16) & ~15) + irq)
 
 /*
diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c
index 96a8a68..f5e2e85 100644
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@ -79,6 +79,11 @@
 
 static DEFINE_RAW_SPINLOCK(ioapic_lock);
 static DEFINE_MUTEX(ioapic_mutex);
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/io_apic.c|2554| <<mp_irqdomain_create>> ioapic_dynirq_base = max(ioapic_dynirq_base,
+ *   - arch/x86/kernel/apic/io_apic.c|2659| <<arch_dynirq_lower_bound>> return ioapic_initialized ? ioapic_dynirq_base : gsi_top;
+ */
 static unsigned int ioapic_dynirq_base;
 static int ioapic_initialized;
 
@@ -88,6 +93,22 @@ struct irq_pin_list {
 };
 
 struct mp_chip_data {
+	/*
+	 * 使用的地方:
+	 *   - arch/x86/kernel/apic/io_apic.c|414| <<__add_pin_to_irq_node>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|426| <<__add_pin_to_irq_node>> list_add_tail(&entry->list, &data->irq_2_pin);
+	 *   - arch/x86/kernel/apic/io_apic.c|435| <<__remove_pin_from_irq>> list_for_each_entry_safe(entry, tmp, &data->irq_2_pin, list)
+	 *   - arch/x86/kernel/apic/io_apic.c|463| <<replace_pin_at_irq_node>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|488| <<io_apic_modify_irq>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|578| <<eoi_ioapic_pin>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|1410| <<print_IO_APICs>> if (list_empty(&data->irq_2_pin))
+	 *   - arch/x86/kernel/apic/io_apic.c|1414| <<print_IO_APICs>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|1763| <<io_apic_level_ack_pending>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|1930| <<ioapic_set_affinity>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|3113| <<mp_irqdomain_alloc>> INIT_LIST_HEAD(&data->irq_2_pin);
+	 *   - arch/x86/kernel/apic/io_apic.c|3151| <<mp_irqdomain_free>> WARN_ON(!list_empty(&data->irq_2_pin));
+	 *   - arch/x86/kernel/apic/io_apic.c|3165| <<mp_irqdomain_activate>> for_each_irq_pin(entry, data->irq_2_pin)
+	 */
 	struct list_head irq_2_pin;
 	struct IO_APIC_route_entry entry;
 	int trigger;
@@ -105,6 +126,15 @@ static struct ioapic {
 	/*
 	 * # of IRQ routing registers
 	 */
+	/*
+	 * used by:
+	 *   - arch/x86/kernel/apic/io_apic.c|73| <<for_each_pin>> for ((pin) = 0; (pin) < ioapics[(idx)].nr_registers; (pin)++)
+	 *   - arch/x86/kernel/apic/io_apic.c|240| <<alloc_ioapic_saved_registers>> size = sizeof(struct IO_APIC_route_entry) * ioapics[idx].nr_registers;
+	 *   - arch/x86/kernel/apic/io_apic.c|1324| <<print_IO_APICs>> ioapics[ioapic_idx].nr_registers);
+	 *   - arch/x86/kernel/apic/io_apic.c|2752| <<find_free_ioapic_entry>> if (ioapics[idx].nr_registers == 0)
+	 *   - arch/x86/kernel/apic/io_apic.c|2849| <<mp_register_ioapic>> ioapics[idx].nr_registers = entries;
+	 *   - arch/x86/kernel/apic/io_apic.c|2890| <<mp_unregister_ioapic>> ioapics[ioapic].nr_registers = 0;
+	 */
 	int nr_registers;
 	/*
 	 * Saved state during suspend/resume, or while enabling intr-remap.
@@ -176,6 +206,24 @@ int nr_ioapics;
 /* The one past the highest gsi number used */
 u32 gsi_top;
 
+/*
+ * 在以下被使用:
+ *   - mp_config_acpi_legacy_irqs()
+ *   - mp_save_irq()
+ *   - find_irq_entry()
+ *   - find_isa_irq_pin()
+ *   - find_isa_irq_apic()
+ *   - default_EISA_trigger()
+ *   - irq_polarity()
+ *   - irq_trigger()
+ *   - mp_map_pin_to_irq()
+ *   - pin_2_irq()
+ *   - IO_APIC_get_PCI_irq_vector()
+ *   - setup_ioapic_ids_from_mpc_nocheck()
+ *   - get_MP_intsrc_index()
+ *   - check_irq_src()
+ *   - replace_intsrc_all()
+ */
 /* MP IRQ source entries */
 struct mpc_intsrc mp_irqs[MAX_IRQ_SOURCES];
 
@@ -303,10 +351,18 @@ union entry_union {
 	struct IO_APIC_route_entry entry;
 };
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|322| <<ioapic_read_entry>> eu.entry = __ioapic_read_entry(apic, pin);
+ *   - arch/x86/kernel/apic/io_apic.c|516| <<__eoi_ioapic_pin>> entry = entry1 = __ioapic_read_entry(apic, pin);
+ */
 static struct IO_APIC_route_entry __ioapic_read_entry(int apic, int pin)
 {
 	union entry_union eu;
 
+	/*
+	 * 乘以2是因为一个entry是64 bits
+	 */
 	eu.w1 = io_apic_read(apic, 0x10 + 2 * pin);
 	eu.w2 = io_apic_read(apic, 0x11 + 2 * pin);
 
@@ -415,12 +471,32 @@ static void add_pin_to_irq_node(struct mp_chip_data *data,
 /*
  * Reroute an IRQ to a different pin.
  */
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/io_apic.c|2226| <<check_timer>> replace_pin_at_irq_node(data, node, apic1, pin1, apic2, pin2);
+ */
 static void __init replace_pin_at_irq_node(struct mp_chip_data *data, int node,
 					   int oldapic, int oldpin,
 					   int newapic, int newpin)
 {
 	struct irq_pin_list *entry;
 
+	/*
+	 * 使用的地方:
+	 *   - arch/x86/kernel/apic/io_apic.c|414| <<__add_pin_to_irq_node>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|426| <<__add_pin_to_irq_node>> list_add_tail(&entry->list, &data->irq_2_pin);
+	 *   - arch/x86/kernel/apic/io_apic.c|435| <<__remove_pin_from_irq>> list_for_each_entry_safe(entry, tmp, &data->irq_2_pin, list)
+	 *   - arch/x86/kernel/apic/io_apic.c|463| <<replace_pin_at_irq_node>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|488| <<io_apic_modify_irq>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|578| <<eoi_ioapic_pin>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|1410| <<print_IO_APICs>> if (list_empty(&data->irq_2_pin))
+	 *   - arch/x86/kernel/apic/io_apic.c|1414| <<print_IO_APICs>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|1763| <<io_apic_level_ack_pending>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|1930| <<ioapic_set_affinity>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|3113| <<mp_irqdomain_alloc>> INIT_LIST_HEAD(&data->irq_2_pin);
+	 *   - arch/x86/kernel/apic/io_apic.c|3151| <<mp_irqdomain_free>> WARN_ON(!list_empty(&data->irq_2_pin));
+	 *   - arch/x86/kernel/apic/io_apic.c|3165| <<mp_irqdomain_activate>> for_each_irq_pin(entry, data->irq_2_pin)
+	 */
 	for_each_irq_pin(entry, data->irq_2_pin) {
 		if (entry->apic == oldapic && entry->pin == oldpin) {
 			entry->apic = newapic;
@@ -465,6 +541,10 @@ static void io_apic_sync(struct irq_pin_list *entry)
 	readl(&io_apic->data);
 }
 
+/*
+ * struct irq_chip ioapic_chip.irq_mask = mask_ioapic_irq()
+ * struct irq_chip ioapic_ir_chip.irq_mask = mask_ioapic_irq()
+ */
 static void mask_ioapic_irq(struct irq_data *irq_data)
 {
 	struct mp_chip_data *data = irq_data->chip_data;
@@ -480,6 +560,10 @@ static void __unmask_ioapic(struct mp_chip_data *data)
 	io_apic_modify_irq(data, ~IO_APIC_REDIR_MASKED, 0, NULL);
 }
 
+/*
+ * struct irq_chip ioapic_chip.irq_unmask = unmask_ioapic_irq()
+ * struct irq_chip ioapic_ir_chip.irq_unmask = unmask_ioapic_irq()
+ */
 static void unmask_ioapic_irq(struct irq_data *irq_data)
 {
 	struct mp_chip_data *data = irq_data->chip_data;
@@ -541,6 +625,15 @@ static void eoi_ioapic_pin(int vector, struct mp_chip_data *data)
 	raw_spin_unlock_irqrestore(&ioapic_lock, flags);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|636| <<clear_IO_APIC>> clear_IO_APIC_pin(apic, pin);
+ *   - arch/x86/kernel/apic/io_apic.c|2033| <<unlock_ExtINT_logic>> clear_IO_APIC_pin(apic, pin);
+ *   - arch/x86/kernel/apic/io_apic.c|2062| <<unlock_ExtINT_logic>> clear_IO_APIC_pin(apic, pin);
+ *   - arch/x86/kernel/apic/io_apic.c|2209| <<check_timer>> clear_IO_APIC_pin(0, pin1);
+ *   - arch/x86/kernel/apic/io_apic.c|2214| <<check_timer>> clear_IO_APIC_pin(apic1, pin1);
+ *   - arch/x86/kernel/apic/io_apic.c|2239| <<check_timer>> clear_IO_APIC_pin(apic2, pin2);
+ */
 static void clear_IO_APIC_pin(unsigned int apic, unsigned int pin)
 {
 	struct IO_APIC_route_entry entry;
@@ -588,6 +681,11 @@ static void clear_IO_APIC_pin(unsigned int apic, unsigned int pin)
 		       mpc_ioapic_id(apic), pin);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|1410| <<enable_IO_APIC>> clear_IO_APIC();
+ *   - arch/x86/kernel/apic/io_apic.c|1449| <<disable_IO_APIC>> clear_IO_APIC();
+ */
 static void clear_IO_APIC (void)
 {
 	int apic, pin;
@@ -717,6 +815,9 @@ static int find_irq_entry(int ioapic_idx, int pin, int type)
 /*
  * Find the pin to which IRQ[irq] (ISA) is connected
  */
+/*
+ * 通过mptable读取
+ */
 static int __init find_isa_irq_pin(int irq, int type)
 {
 	int i;
@@ -733,6 +834,9 @@ static int __init find_isa_irq_pin(int irq, int type)
 	return -1;
 }
 
+/*
+ * 通过mptable读取
+ */
 static int __init find_isa_irq_apic(int irq, int type)
 {
 	int i;
@@ -1226,6 +1330,10 @@ void ioapic_zap_locks(void)
 	raw_spin_lock_init(&ioapic_lock);
 }
 
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/io_apic.c|1408| <<print_IO_APIC>> io_apic_print_entries(ioapic_idx, reg_01.bits.entries);
+ */
 static void io_apic_print_entries(unsigned int apic, unsigned int nr_entries)
 {
 	int i;
@@ -1312,6 +1420,10 @@ static void __init print_IO_APIC(int ioapic_idx)
 	io_apic_print_entries(ioapic_idx, reg_01.bits.entries);
 }
 
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/vector.c|993| <<print_ICs>> print_IO_APICs();
+ */
 void __init print_IO_APICs(void)
 {
 	int ioapic_idx;
@@ -1356,9 +1468,28 @@ void __init print_IO_APICs(void)
 	printk(KERN_INFO ".................................... done.\n");
 }
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/io_apic.c|1381| <<enable_IO_APIC>> ioapic_i8259.apic = apic;
+ *   - arch/x86/kernel/apic/io_apic.c|1382| <<enable_IO_APIC>> ioapic_i8259.pin = pin;
+ *   - arch/x86/kernel/apic/io_apic.c|1395| <<enable_IO_APIC>> if ((ioapic_i8259.pin == -1) && (i8259_pin >= 0)) {
+ *   - arch/x86/kernel/apic/io_apic.c|1397| <<enable_IO_APIC>> ioapic_i8259.pin = i8259_pin;
+ *   - arch/x86/kernel/apic/io_apic.c|1398| <<enable_IO_APIC>> ioapic_i8259.apic = i8259_apic;
+ *   - arch/x86/kernel/apic/io_apic.c|1401| <<enable_IO_APIC>> if (((ioapic_i8259.apic != i8259_apic) || (ioapic_i8259.pin != i8259_pin)) &&
+ *   - arch/x86/kernel/apic/io_apic.c|1402| <<enable_IO_APIC>> (i8259_pin >= 0) && (ioapic_i8259.pin >= 0))
+ *   - arch/x86/kernel/apic/io_apic.c|1420| <<native_disable_io_apic>> if (ioapic_i8259.pin != -1) {
+ *   - arch/x86/kernel/apic/io_apic.c|1434| <<native_disable_io_apic>> ioapic_write_entry(ioapic_i8259.apic, ioapic_i8259.pin, entry);
+ *   - arch/x86/kernel/apic/io_apic.c|1438| <<native_disable_io_apic>> disconnect_bsp_APIC(ioapic_i8259.pin != -1);
+ *   - arch/x86/kernel/apic/io_apic.c|2079| <<check_timer>> pin2 = ioapic_i8259.pin;
+ *   - arch/x86/kernel/apic/io_apic.c|2080| <<check_timer>> apic2 = ioapic_i8259.apic;
+ */
 /* Where if anywhere is the i8259 connect in external int mode */
 static struct { int pin, apic; } ioapic_i8259 = { -1, -1 };
 
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/apic.c|2361| <<apic_bsp_setup>> enable_IO_APIC();
+ */
 void __init enable_IO_APIC(void)
 {
 	int i8259_apic, i8259_pin;
@@ -1578,6 +1709,15 @@ void __init setup_ioapic_ids_from_mpc(void)
 }
 #endif
 
+/*
+ * 在以下设置:
+ *   - arch/x86/kernel/apic/io_apic.c|1699| <<notimercheck>> no_timer_check = 1; ---> "no_timer_check"参数!
+ *   - arch/x86/kernel/cpu/mshyperv.c|231| <<ms_hyperv_init_platform>> no_timer_check = 1;
+ *   - arch/x86/kernel/cpu/vmware.c|171| <<vmware_platform_setup>> no_timer_check = 1;
+ *   - arch/x86/kernel/kvm.c|298| <<paravirt_ops_setup>> no_timer_check = 1;
+ * 只在timer_irq_works()使用:
+ *   - arch/x86/kernel/apic/io_apic.c|1724| <<timer_irq_works>> if (no_timer_check)
+ */
 int no_timer_check __initdata;
 
 static int __init notimercheck(char *s)
@@ -1595,11 +1735,27 @@ __setup("no_timer_check", notimercheck);
  *	- if this function detects that timer IRQs are defunct, then we fall
  *	  back to ISA timer IRQs
  */
+/*
+ * 在timer_irq_works()中测试的时候会激活中断
+ */
 static int __init timer_irq_works(void)
 {
+	/*
+	 * jiffies和jiffies_64是一样的, 定义在
+	 * arch/x86/kernel/vmlinux.lds.S
+	 */
 	unsigned long t1 = jiffies;
 	unsigned long flags;
 
+	/*
+	 * 在以下设置:
+	 *   - arch/x86/kernel/apic/io_apic.c|1699| <<notimercheck>> no_timer_check = 1; ---> "no_timer_check"参数!
+	 *   - arch/x86/kernel/cpu/mshyperv.c|231| <<ms_hyperv_init_platform>> no_timer_check = 1;
+	 *   - arch/x86/kernel/cpu/vmware.c|171| <<vmware_platform_setup>> no_timer_check = 1;
+	 *   - arch/x86/kernel/kvm.c|298| <<paravirt_ops_setup>> no_timer_check = 1;
+	 * 只在timer_irq_works()使用:
+	 *   - arch/x86/kernel/apic/io_apic.c|1724| <<timer_irq_works>> if (no_timer_check)
+	 */
 	if (no_timer_check)
 		return 1;
 
@@ -1645,6 +1801,10 @@ static int __init timer_irq_works(void)
  * This is not complete - we should be able to fake
  * an edge even if it isn't on the 8259A...
  */
+/*
+ * struct irq_chip ioapic_chip.irq_startup = startup_ioapic_irq()
+ * struct irq_chip ioapic_ir_chip.irq_startup = startup_ioapic_irq()
+ */
 static unsigned int startup_ioapic_irq(struct irq_data *data)
 {
 	int was_pending = 0, irq = data->irq;
@@ -1742,6 +1902,9 @@ static inline void ioapic_irqd_unmask(struct irq_data *data, bool masked)
 }
 #endif
 
+/*
+ * struct irq_chip ioapic_chip.irq_eoi = ioapic_ack_level()
+ */
 static void ioapic_ack_level(struct irq_data *irq_data)
 {
 	struct irq_cfg *cfg = irqd_cfg(irq_data);
@@ -1808,6 +1971,9 @@ static void ioapic_ack_level(struct irq_data *irq_data)
 	ioapic_irqd_unmask(irq_data, masked);
 }
 
+/*
+ * struct irq_chip ioapic_ir_chip.irq_eoi = ioapic_ir_ack_level()
+ */
 static void ioapic_ir_ack_level(struct irq_data *irq_data)
 {
 	struct mp_chip_data *data = irq_data->chip_data;
@@ -1822,6 +1988,10 @@ static void ioapic_ir_ack_level(struct irq_data *irq_data)
 	eoi_ioapic_pin(data->entry.vector, data);
 }
 
+/*
+ * struct irq_chip ioapic_chip.irq_set_affinity = ioapic_set_affinity()
+ * struct irq_chip ioapic_ir_chip.irq_set_affinity = ioapic_set_affinity()
+ */
 static int ioapic_set_affinity(struct irq_data *irq_data,
 			       const struct cpumask *mask, bool force)
 {
@@ -1847,6 +2017,11 @@ static int ioapic_set_affinity(struct irq_data *irq_data,
 	return ret;
 }
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/io_apic.c|1446| <<print_IO_APICs>> if (chip != &ioapic_chip && chip != &ioapic_ir_chip)
+ *   - arch/x86/kernel/apic/io_apic.c|3296| <<mp_irqdomain_alloc>> &ioapic_chip : &ioapic_ir_chip;
+ */
 static struct irq_chip ioapic_chip __read_mostly = {
 	.name			= "IO-APIC",
 	.irq_startup		= startup_ioapic_irq,
@@ -1859,6 +2034,11 @@ static struct irq_chip ioapic_chip __read_mostly = {
 	.flags			= IRQCHIP_SKIP_SET_WAKE,
 };
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/io_apic.c|1446| <<print_IO_APICs>> if (chip != &ioapic_chip && chip != &ioapic_ir_chip)
+ *   - arch/x86/kernel/apic/io_apic.c|3296| <<mp_irqdomain_alloc>> &ioapic_chip : &ioapic_ir_chip;
+ */
 static struct irq_chip ioapic_ir_chip __read_mostly = {
 	.name			= "IR-IO-APIC",
 	.irq_startup		= startup_ioapic_irq,
@@ -1897,6 +2077,9 @@ static inline void init_IO_APIC_traps(void)
  * The local APIC irq-chip implementation:
  */
 
+/*
+ * struct irq_chip lapic_chip.irq_mask = mask_lapic_irq()
+ */
 static void mask_lapic_irq(struct irq_data *data)
 {
 	unsigned long v;
@@ -1905,6 +2088,9 @@ static void mask_lapic_irq(struct irq_data *data)
 	apic_write(APIC_LVT0, v | APIC_LVT_MASKED);
 }
 
+/*
+ * struct irq_chip lapic_chip.irq_unmask = unmask_lapic_irq()
+ */
 static void unmask_lapic_irq(struct irq_data *data)
 {
 	unsigned long v;
@@ -1913,11 +2099,18 @@ static void unmask_lapic_irq(struct irq_data *data)
 	apic_write(APIC_LVT0, v & ~APIC_LVT_MASKED);
 }
 
+/*
+ * struct irq_chip lapic_chip.irq_ack = ack_lapic_irq()
+ */
 static void ack_lapic_irq(struct irq_data *data)
 {
 	ack_APIC_irq();
 }
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/io_apic.c|2121| <<lapic_register_intr>> irq_set_chip_and_handler_name(irq, &lapic_chip, handle_edge_irq,
+ */
 static struct irq_chip lapic_chip __read_mostly = {
 	.name		= "local-APIC",
 	.irq_mask	= mask_lapic_irq,
@@ -1925,9 +2118,26 @@ static struct irq_chip lapic_chip __read_mostly = {
 	.irq_ack	= ack_lapic_irq,
 };
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|2278| <<check_timer>> lapic_register_intr(0);
+ */
 static void lapic_register_intr(int irq)
 {
 	irq_clear_status_flags(irq, IRQ_LEVEL);
+	/*
+	 * 在部分以下调用:
+	 *   - arch/x86/kernel/apic/io_apic.c|2056| <<lapic_register_intr>> irq_set_chip_and_handler_name(irq, &lapic_chip, handle_edge_irq,
+	 *   - kernel/irq/irqdomain.c|1797| <<irq_domain_set_info>> irq_set_chip_and_handler_name(virq, chip, handler, handler_name);
+	 *   - include/linux/irq.h|620| <<irq_set_chip_and_handler>> irq_set_chip_and_handler_name(irq, chip, handle, NULL);
+	 *   - drivers/xen/events/events_base.c|702| <<xen_bind_pirq_gsi_to_irq>> irq_set_chip_and_handler_name(irq, &xen_pirq_chip,
+	 *   - drivers/xen/events/events_base.c|705| <<xen_bind_pirq_gsi_to_irq>> irq_set_chip_and_handler_name(irq, &xen_pirq_chip,
+	 *   - drivers/xen/events/events_base.c|741| <<xen_bind_pirq_msi_to_irq>> irq_set_chip_and_handler_name(irq + i, &xen_pirq_chip, handle_edge_irq, name);
+	 *   - drivers/xen/events/events_base.c|846| <<bind_evtchn_to_irq>> irq_set_chip_and_handler_name(irq, &xen_dynamic_chip,
+	 *   - drivers/xen/events/events_base.c|884| <<bind_ipi_to_irq>> irq_set_chip_and_handler_name(irq, &xen_percpu_chip,
+	 *   - drivers/xen/events/events_base.c|976| <<bind_virq_to_irq>> irq_set_chip_and_handler_name(irq, &xen_percpu_chip,
+	 *   - drivers/xen/events/events_base.c|979| <<bind_virq_to_irq>> irq_set_chip_and_handler_name(irq, &xen_dynamic_chip,
+	 */
 	irq_set_chip_and_handler_name(irq, &lapic_chip, handle_edge_irq,
 				      "edge");
 }
@@ -1945,11 +2155,13 @@ static inline void __init unlock_ExtINT_logic(void)
 	struct IO_APIC_route_entry entry0, entry1;
 	unsigned char save_control, save_freq_select;
 
+	/* 通过mptable读取 */
 	pin  = find_isa_irq_pin(8, mp_INT);
 	if (pin == -1) {
 		WARN_ON_ONCE(1);
 		return;
 	}
+	/* 通过mptable读取 */
 	apic = find_isa_irq_apic(8, mp_INT);
 	if (apic == -1) {
 		WARN_ON_ONCE(1);
@@ -2027,8 +2239,28 @@ static int mp_alloc_timer_irq(int ioapic, int pin)
  *
  * FIXME: really need to revamp this for all platforms.
  */
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/io_apic.c|2312| <<setup_IO_APIC>> check_timer();
+ *
+ * 在之前给KVM的commit的中禁用了
+ * commit a90ede7b17d122acd58e6e1ff911be9dcf5263cc
+ * Author: Marcelo Tosatti <mtosatti@redhat.com>
+ * Date:   Wed Feb 11 22:45:42 2009 -0200
+ *
+ * KVM: x86: paravirt skip pit-through-ioapic boot check
+ *
+ * Skip the test which checks if the PIT is properly routed when
+ * using the IOAPIC, aimed at buggy hardware.
+ *
+ * Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
+ * Signed-off-by: Avi Kivity <avi@redhat.com>
+ */
 static inline void __init check_timer(void)
 {
+	/*
+	 * 获得irq 0的struct irq_desc *desc, 返回desc->irq_data
+	 */
 	struct irq_data *irq_data = irq_get_irq_data(0);
 	struct mp_chip_data *data = irq_data->chip_data;
 	struct irq_cfg *cfg = irqd_cfg(irq_data);
@@ -2042,6 +2274,18 @@ static inline void __init check_timer(void)
 	/*
 	 * get/set the timer IRQ vector:
 	 */
+	/*
+	 * legacy_pic可以是:
+	 *   - default_legacy_pic
+	 *   - null_legacy_pic
+	 *
+	 * 这里的参数0是irq
+	 *
+	 * 对于mask_8259A_irq(): 通过IMR寄存器在8259禁用某个irq line
+	 *
+	 * 对于8259, 由于从片串接到主片的IRQ2 pin上,
+	 * 从片的IRQ1 pin同时接到IRQ2和IRQ9 line
+	 */
 	legacy_pic->mask(0);
 
 	/*
@@ -2054,13 +2298,31 @@ static inline void __init check_timer(void)
 	 * automatically.
 	 */
 	apic_write(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
+	/*
+	 * init_8259A(): 1说明支持AEOI
+	 * 按照ICW要求的顺序初始化8259
+	 *   vector 0x30对应irq line 0
+	 *   vector 0x38对应irq line 8
+	 * 最后会根据cached_irq_mask屏蔽中断
+	 */
 	legacy_pic->init(1);
 
+	/* 通过mptable读取 */
 	pin1  = find_isa_irq_pin(0, mp_INT);
+	/* 通过mptable读取 */
 	apic1 = find_isa_irq_apic(0, mp_INT);
+	/* 从ioapic获取的 */
 	pin2  = ioapic_i8259.pin;
+	/* 从ioapic获取的 */
 	apic2 = ioapic_i8259.apic;
 
+	/*
+	 * 在测试xen domU中boot和kdump的例子都是:
+	 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=0 pin2=0
+	 *
+	 * 在8-thread的dell测试机kvm的VM里:
+	 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=-1 pin2=-1
+	 */
 	apic_printk(APIC_QUIET, KERN_INFO "..TIMER: vector=0x%02X "
 		    "apic1=%d pin1=%d apic2=%d pin2=%d\n",
 		    cfg->vector, apic1, pin1, apic2, pin2);
@@ -2072,6 +2334,14 @@ static inline void __init check_timer(void)
 	 * was found above, try it both directly and through the
 	 * 8259A.
 	 */
+	/*
+	 * 在测试xen domU中boot和kdump的例子都是:
+	 *
+	 * pin1 = 2
+	 * pin2 = 0
+	 *
+	 * 所以下面的no_pin1应该是0
+	 */
 	if (pin1 == -1) {
 		panic_if_irq_remap("BIOS bug: timer not connected to IO-APIC");
 		pin1 = pin2;
@@ -2088,17 +2358,43 @@ static inline void __init check_timer(void)
 			mp_alloc_timer_irq(apic1, pin1);
 		} else {
 			/*
+			 * 目前测试的kvm和xen都是执行这里
+			 *
+			 * 在测试xen domU中boot和kdump的例子都是:
+			 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=0 pin2=0
+			 */
+			/*
 			 * for edge trigger, it's already unmasked,
 			 * so only need to unmask if it is level-trigger
 			 * do we really have level trigger timer?
 			 */
 			int idx;
+			/*
+			 * 在测试xen domU中boot和kdump的例子都是:
+			 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=0 pin2=0
+			 *
+			 * 这里先尝试8254???
+			 * 就是8254!!!
+			 * 只有8254这一个pit
+			 */
 			idx = find_irq_entry(apic1, pin1, mp_INT);
 			if (idx != -1 && irq_trigger(idx))
 				unmask_ioapic_irq(irq_get_irq_data(0));
 		}
+		/*
+		 * irq_data来自一开始的:
+		 * struct irq_data *irq_data = irq_get_irq_data(0);
+		 */
 		irq_domain_deactivate_irq(irq_data);
 		irq_domain_activate_irq(irq_data);
+		/*
+		 * 先测试用ioapic处理的8254?? (pin 2接口)
+		 *
+		 * 在这里测试中:
+		 *   - 在8259上mask了irq 0
+		 *   - 在lapic上的lvt0禁用了8259
+		 *   - 在ioapic的pin 2 (irq line 2)上接收中断到irq 0 --> 当然是用 ioapic发的!!
+		 */
 		if (timer_irq_works()) {
 			if (disable_timer_pin_1 > 0)
 				clear_IO_APIC_pin(0, pin1);
@@ -2116,12 +2412,30 @@ static inline void __init check_timer(void)
 		apic_printk(APIC_QUIET, KERN_INFO
 			    "..... (found apic %d pin %d) ...\n", apic2, pin2);
 		/*
+		 * 在测试xen domU中boot和kdump的例子都是:
+		 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=0 pin2=0
+		 *
+		 * 下面用8259, 也就是pin 0接口, 定向到irq0
+		 */
+		/*
 		 * legacy devices should be connected to IO APIC #0
 		 */
 		replace_pin_at_irq_node(data, node, apic1, pin1, apic2, pin2);
 		irq_domain_deactivate_irq(irq_data);
 		irq_domain_activate_irq(irq_data);
+		/*
+		 * 对于unmask_8259A_irq(): 通过IMR寄存器在8259开通某个irq line
+		 */
 		legacy_pic->unmask(0);
+		/*
+		 * 这里测试的8259? pin 0接口
+		 *
+		 * 在这里的测试中:
+		 *   - 在8259上开通了irq 0
+		 *   - 在lapic上的lvt0依然禁用了8259???
+		 *   - 这里用io_apic发的???
+		 * 那中断是怎么发到cpu的????????
+		 */
 		if (timer_irq_works()) {
 			apic_printk(APIC_QUIET, KERN_INFO "....... works.\n");
 			goto out;
@@ -2138,10 +2452,23 @@ static inline void __init check_timer(void)
 	apic_printk(APIC_QUIET, KERN_INFO
 		    "...trying to set up timer as Virtual Wire IRQ...\n");
 
+	/*
+	 * 下面又要开启lapic的LVT0
+	 */
 	lapic_register_intr(0);
+	/*
+	 * 用APIC_DM_FIXED需要制定vector
+	 *
+	 * cfg来自函数一开始的
+	 * struct irq_data *irq_data = irq_get_irq_data(0);
+	 * struct irq_cfg *cfg = irqd_cfg(irq_data);
+	 */
 	apic_write(APIC_LVT0, APIC_DM_FIXED | cfg->vector);	/* Fixed mode */
 	legacy_pic->unmask(0);
 
+	/*
+	 *
+	 */
 	if (timer_irq_works()) {
 		apic_printk(APIC_QUIET, KERN_INFO "..... works.\n");
 		goto out;
@@ -2154,12 +2481,43 @@ static inline void __init check_timer(void)
 	apic_printk(APIC_QUIET, KERN_INFO
 		    "...trying to set up timer as ExtINT IRQ...\n");
 
+	/*
+	 * 下面用另外一种方式开启lapic的LVT0
+	 *
+	 * default_legacy_pic:
+	 *   init_8259A()
+	 *   make_8259A_irq()
+	 *
+	 * init_8259A(): 0说明不支持AEOI
+	 * 按照ICW要求的顺序初始化8259
+	 *   vector 0x30对应irq line 0
+	 *   vector 0x38对应irq line 8
+	 * 最后会根据cached_irq_mask屏蔽中断
+	 */
 	legacy_pic->init(0);
+	/*
+	 * make_8259A_irq()
+	 * 配置8259使某个irq line通过8259, 而不通过ioapic了
+	 * 这里在io_apic_irqs把某个irq line的bit清0, 说明不通过ioapic了
+	 * 通过下面设置中断的chip:
+	 *   - irq_set_chip_and_handler(irq, &i8259A_chip, handle_level_irq);
+	 *
+	 * io_apic_irqs是一个bitmap, 说明那个irq line是用的io_apic
+	 * used by:
+	 *   - arch/x86/include/asm/io_apic.h|147| <<IO_APIC_IRQ>> #define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1 << (x)) & io_apic_irqs))
+	 *   - arch/x86/include/asm/io_apic.h|154| <<io_apic_assign_pci_irqs>> (mp_irq_entries && !skip_ioapic_setup && io_apic_irqs)
+	 *   - arch/x86/kernel/apic/io_apic.c|284| <<arch_early_ioapic_init>> io_apic_irqs = ~0UL;
+	 *   - arch/x86/kernel/apic/io_apic.c|2427| <<setup_IO_APIC>> io_apic_irqs = nr_legacy_irqs() ? ~PIC_IRQS : ~0UL;
+	 *   - arch/x86/kernel/i8259.c|115| <<make_8259A_irq>> io_apic_irqs &= ~(1<<irq);
+	 */
 	legacy_pic->make_irq(0);
 	apic_write(APIC_LVT0, APIC_DM_EXTINT);
 
 	unlock_ExtINT_logic();
 
+	/*
+	 *
+	 */
 	if (timer_irq_works()) {
 		apic_printk(APIC_QUIET, KERN_INFO "..... works.\n");
 		goto out;
@@ -2195,6 +2553,11 @@ static inline void __init check_timer(void)
  */
 #define PIC_IRQS	(1UL << PIC_CASCADE_IR)
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|2583| <<setup_IO_APIC>> BUG_ON(mp_irqdomain_create(ioapic));
+ *   - arch/x86/kernel/apic/io_apic.c|3110| <<mp_register_ioapic>> if (mp_irqdomain_create(idx)) {
+ */
 static int mp_irqdomain_create(int ioapic)
 {
 	struct irq_alloc_info info;
@@ -2209,6 +2572,7 @@ static int mp_irqdomain_create(int ioapic)
 	if (cfg->type == IOAPIC_DOMAIN_INVALID)
 		return 0;
 
+	/* 就是清0 */
 	init_irq_alloc_info(&info, NULL);
 	info.type = X86_IRQ_ALLOC_TYPE_IOAPIC;
 	info.ioapic_id = mpc_ioapic_id(ioapic);
@@ -2222,11 +2586,23 @@ static int mp_irqdomain_create(int ioapic)
 	if (cfg->dev) {
 		fn = of_node_to_fwnode(cfg->dev);
 	} else {
+		/*
+		 * 在kvm上执行到这里
+		 *
+		 * 分配和初始化一个 struct fwnode_handle
+		 */
 		fn = irq_domain_alloc_named_id_fwnode(name, ioapic);
 		if (!fn)
 			return -ENOMEM;
 	}
 
+	/*
+	 * 这里cfg->ops可以是struct irq_domain_ops mp_ioapic_irqdomain_ops
+	 * hwirqs是ioapic的pin的数量
+	 * ioapic是ioapic的id
+	 *
+	 * 核心思想就是初始化一个struct irq_domain, 加入irq_domain_list
+	 */
 	ip->irqdomain = irq_domain_create_linear(fn, hwirqs, cfg->ops,
 						 (void *)(long)ioapic);
 
@@ -2255,6 +2631,10 @@ static void ioapic_destroy_irqdomain(int idx)
 	}
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/apic.c|2364| <<apic_bsp_setup>> setup_IO_APIC();
+ */
 void __init setup_IO_APIC(void)
 {
 	int ioapic;
@@ -2903,6 +3283,23 @@ static void mp_setup_entry(struct irq_cfg *cfg, struct mp_chip_data *data,
 		entry->mask = IOAPIC_UNMASKED;
 }
 
+/*
+ * [0] mp_irqdomain_alloc
+ * [0] __irq_domain_alloc_irqs
+ * [0] alloc_isa_irq_from_domain.isra.11
+ * [0] mp_map_pin_to_irq
+ * [0] setup_IO_APIC
+ * [0] apic_bsp_setup
+ * [0] native_smp_prepare_cpus
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - kernel/irq/irqdomain.c|1456| <<irq_domain_alloc_irqs_hierarchy>> return domain->ops->alloc(domain, irq_base, nr_irqs, arg);
+ *
+ * struct irq_domain_ops mp_ioapic_irqdomain_ops.alloc = mp_irqdomain_alloc()
+ */
 int mp_irqdomain_alloc(struct irq_domain *domain, unsigned int virq,
 		       unsigned int nr_irqs, void *arg)
 {
@@ -2928,6 +3325,9 @@ int mp_irqdomain_alloc(struct irq_domain *domain, unsigned int virq,
 	if (!data)
 		return -ENOMEM;
 
+	/*
+	 * info->ioapic_entry是struct IO_APIC_route_entry *ioapic_entry;
+	 */
 	info->ioapic_entry = &data->entry;
 	ret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, info);
 	if (ret < 0) {
@@ -2961,6 +3361,12 @@ int mp_irqdomain_alloc(struct irq_domain *domain, unsigned int virq,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - kernel/irq/irqdomain.c|1442| <<irq_domain_free_irqs_hierarchy>> domain->ops->free(domain, irq_base, nr_irqs);
+ *
+ * struct irq_domain_ops mp_ioapic_irqdomain_ops.free = mp_irqdomain_free()
+ */
 void mp_irqdomain_free(struct irq_domain *domain, unsigned int virq,
 		       unsigned int nr_irqs)
 {
@@ -2979,6 +3385,12 @@ void mp_irqdomain_free(struct irq_domain *domain, unsigned int virq,
 	irq_domain_free_irqs_top(domain, virq, nr_irqs);
 }
 
+/*
+ * called by:
+ *   - kernel/irq/irqdomain.c|1780| <<__irq_domain_activate_irq>> domain->ops->activate(domain, irq_data);
+ *
+ * struct irq_domain_ops mp_ioapic_irqdomain_ops.activate = mp_irqdomain_activate()
+ */
 void mp_irqdomain_activate(struct irq_domain *domain,
 			   struct irq_data *irq_data)
 {
@@ -2987,11 +3399,23 @@ void mp_irqdomain_activate(struct irq_domain *domain,
 	struct mp_chip_data *data = irq_data->chip_data;
 
 	raw_spin_lock_irqsave(&ioapic_lock, flags);
+	/*
+	 * struct irq_pin_list {
+	 *         struct list_head list;
+	 *         int apic, pin;
+	 * };
+	 */
 	for_each_irq_pin(entry, data->irq_2_pin)
 		__ioapic_write_entry(entry->apic, entry->pin, data->entry);
 	raw_spin_unlock_irqrestore(&ioapic_lock, flags);
 }
 
+/*
+ * called by:
+ *   - kernel/irq/irqdomain.c|1790| <<__irq_domain_deactivate_irq>> domain->ops->deactivate(domain, irq_data);
+ *
+ * struct irq_domain_ops mp_ioapic_irqdomain_ops.deactivate = mp_irqdomain_deactivate()
+ */
 void mp_irqdomain_deactivate(struct irq_domain *domain,
 			     struct irq_data *irq_data)
 {
@@ -3000,11 +3424,25 @@ void mp_irqdomain_deactivate(struct irq_domain *domain,
 			  (int)irq_data->hwirq);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|3230| <<mp_irqdomain_alloc>> ioapic = mp_irqdomain_ioapic_idx(domain);
+ *   - arch/x86/kernel/apic/io_apic.c|3282| <<mp_irqdomain_free>> __remove_pin_from_irq(data, mp_irqdomain_ioapic_idx(domain),
+ *   - arch/x86/kernel/apic/io_apic.c|3307| <<mp_irqdomain_deactivate>> ioapic_mask_entry(mp_irqdomain_ioapic_idx(domain),
+ *   - arch/x86/kernel/devicetree.c|218| <<dt_irqdomain_alloc>> tmp.ioapic_id = mpc_ioapic_id(mp_irqdomain_ioapic_idx(domain));
+ */
 int mp_irqdomain_ioapic_idx(struct irq_domain *domain)
 {
 	return (int)(long)domain->host_data;
 }
 
+/*
+ * used by:
+ *   - arch/x86/kernel/acpi/boot.c|453| <<acpi_parse_ioapic>> .ops = &mp_ioapic_irqdomain_ops,
+ *   - arch/x86/kernel/acpi/boot.c|805| <<acpi_register_ioapic>> .ops = &mp_ioapic_irqdomain_ops,
+ *   - arch/x86/kernel/mpparse.c|120| <<MP_ioapic_info>> .ops = &mp_ioapic_irqdomain_ops,
+ *   - arch/x86/platform/sfi/sfi.c|82| <<sfi_parse_ioapic>> .ops = &mp_ioapic_irqdomain_ops,
+ */
 const struct irq_domain_ops mp_ioapic_irqdomain_ops = {
 	.alloc		= mp_irqdomain_alloc,
 	.free		= mp_irqdomain_free,
diff --git a/arch/x86/kernel/apic/msi.c b/arch/x86/kernel/apic/msi.c
index f10e7f9..df7362f 100644
--- a/arch/x86/kernel/apic/msi.c
+++ b/arch/x86/kernel/apic/msi.c
@@ -24,6 +24,12 @@
 #include <asm/apic.h>
 #include <asm/irq_remapping.h>
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/msi.c|85| <<native_setup_msi_irqs>> domain = msi_default_domain;
+ *   - arch/x86/kernel/apic/msi.c|152| <<arch_init_msi_domain>> msi_default_domain =
+ *   - arch/x86/kernel/apic/msi.c|157| <<arch_init_msi_domain>> if (!msi_default_domain)
+ */
 static struct irq_domain *msi_default_domain;
 
 static void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
@@ -58,6 +64,9 @@ static void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
  * IRQ Chip for MSI PCI/PCI-X/PCI-Express Devices,
  * which implement the MSI or MSI-X Capability Structure.
  */
+/*
+ * struct msi_domain_info pci_msi_domain_info.chip = pci_msi_controller
+ */
 static struct irq_chip pci_msi_controller = {
 	.name			= "PCI-MSI",
 	.irq_unmask		= pci_msi_unmask_irq,
@@ -122,12 +131,20 @@ void pci_msi_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc)
 }
 EXPORT_SYMBOL_GPL(pci_msi_set_desc);
 
+/*
+ * struct msi_domain_info pci_msi_domain_info.ops = pci_msi_domain_ops
+ * struct msi_domain_info pci_msi_ir_domain_info.ops = pci_msi_domain_ops
+ */
 static struct msi_domain_ops pci_msi_domain_ops = {
 	.get_hwirq	= pci_msi_get_hwirq,
 	.msi_prepare	= pci_msi_prepare,
 	.set_desc	= pci_msi_set_desc,
 };
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/msi.c|159| <<arch_init_msi_domain>> pci_msi_create_irq_domain(fn, &pci_msi_domain_info,
+ */
 static struct msi_domain_info pci_msi_domain_info = {
 	.flags		= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
 			  MSI_FLAG_PCI_MSIX,
@@ -391,3 +408,29 @@ int hpet_assign_irq(struct irq_domain *domain, struct hpet_dev *dev,
 	return irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, &info);
 }
 #endif
+
+/*
+ * msi的struct irq_domain_ops的例子
+ *
+ * kernel/irq/msi.c
+ *
+ * 166 static const struct irq_domain_ops msi_domain_ops = {
+ * 167         .alloc          = msi_domain_alloc,
+ * 168         .free           = msi_domain_free,
+ * 169         .activate       = msi_domain_activate,
+ * 170         .deactivate     = msi_domain_deactivate,
+ * 171 };
+ *
+ *
+ * info的例子:
+ * struct msi_domain_info pci_msi_domain_info
+ *
+ * 148 static struct msi_domain_info pci_msi_domain_info = {
+ * 149         .flags          = MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
+ * 150                           MSI_FLAG_PCI_MSIX,
+ * 151         .ops            = &pci_msi_domain_ops,
+ * 152         .chip           = &pci_msi_controller,
+ * 153         .handler        = handle_edge_irq,
+ * 154         .handler_name   = "edge",
+ * 155 };
+ */
diff --git a/arch/x86/kernel/apic/probe_64.c b/arch/x86/kernel/apic/probe_64.c
index c303054..e714f47 100644
--- a/arch/x86/kernel/apic/probe_64.c
+++ b/arch/x86/kernel/apic/probe_64.c
@@ -25,6 +25,14 @@
 /*
  * Check the APIC IDs in bios_cpu_apicid and choose the APIC mode.
  */
+/*
+ * [0] default_setup_apic_routing
+ * [0] native_smp_prepare_cpus
+ * [0] xen_hvm_smp_prepare_cpus
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ */
 void __init default_setup_apic_routing(void)
 {
 	struct apic **drv;
@@ -32,6 +40,11 @@ void __init default_setup_apic_routing(void)
 	enable_IR_x2apic();
 
 	for (drv = __apicdrivers; drv < __apicdrivers_end; drv++) {
+		/*
+		 * apic=flat, drv=Xen PV
+		 * apic=flat, drv=physical flat
+		 * apic=flat, drv=flat
+		 */
 		if ((*drv)->probe && (*drv)->probe()) {
 			if (apic != *drv) {
 				apic = *drv;
diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c
index b958082..f112580 100644
--- a/arch/x86/kernel/apic/vector.c
+++ b/arch/x86/kernel/apic/vector.c
@@ -59,6 +59,7 @@ static struct apic_chip_data *apic_chip_data(struct irq_data *irq_data)
 	while (irq_data->parent_data)
 		irq_data = irq_data->parent_data;
 
+	/* void *chip_data */
 	return irq_data->chip_data;
 }
 
@@ -103,6 +104,58 @@ static void free_apic_chip_data(struct apic_chip_data *data)
 	}
 }
 
+/*
+ * [0] assign_irq_vector
+ * [0] x86_vector_alloc_irqs
+ * [0] msi_domain_alloc
+ * [0] __irq_domain_alloc_irqs
+ * [0] msi_domain_alloc_irqs
+ * [0] native_setup_msi_irqs
+ * [0] __pci_enable_msix_range
+ * [0] pci_alloc_irq_vectors_affinity
+ * [0] vp_find_vqs_msix
+ * [0] vp_find_vqs
+ * [0] vp_modern_find_vqs
+ * [0] virtscsi_init
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * [0] assign_irq_vector
+ * [0] msi_domain_set_affinity
+ * [0] irq_do_set_affinity
+ * [0] irq_startup
+ * [0] __setup_irq
+ * [0] request_threaded_irq
+ * [0] vp_find_vqs_msix
+ * [0] vp_find_vqs
+ * [0] vp_modern_find_vqs
+ * [0] virtscsi_init
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|244| <<assign_irq_vector>> err = __assign_irq_vector(irq, data, mask, irqdata);
+ */
 static int __assign_irq_vector(int irq, struct apic_chip_data *d,
 			       const struct cpumask *mask,
 			       struct irq_data *irqdata)
@@ -189,6 +242,9 @@ static int __assign_irq_vector(int irq, struct apic_chip_data *d,
 		/* Schedule the old vector for cleanup on all cpus */
 		if (d->cfg.vector)
 			cpumask_copy(d->old_domain, d->domain);
+		/*
+		 * 这里很重要, 为cpu设置vector-irq
+		 */
 		for_each_cpu(new_cpu, vector_searchmask)
 			per_cpu(vector_irq, new_cpu)[vector] = irq_to_desc(irq);
 		goto update;
@@ -233,6 +289,13 @@ static int __assign_irq_vector(int irq, struct apic_chip_data *d,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|255| <<assign_irq_vector_policy>> return assign_irq_vector(irq, data, info->mask, irqdata);
+ *   - arch/x86/kernel/apic/vector.c|257| <<assign_irq_vector_policy>> assign_irq_vector(irq, data, cpumask_of_node(node), irqdata) == 0)
+ *   - arch/x86/kernel/apic/vector.c|259| <<assign_irq_vector_policy>> return assign_irq_vector(irq, data, apic->target_cpus(), irqdata);
+ *   - arch/x86/kernel/apic/vector.c|560| <<apic_set_affinity>> err = assign_irq_vector(irq, data, dest, irq_data);
+ */
 static int assign_irq_vector(int irq, struct apic_chip_data *data,
 			     const struct cpumask *mask,
 			     struct irq_data *irqdata)
@@ -396,6 +459,10 @@ static const struct irq_domain_ops x86_vector_domain_ops = {
 	.free	= x86_vector_free_irqs,
 };
 
+/*
+ * called by only:
+ *   - kernel/irq/irqdesc.c|490| <<early_irq_init>> initcnt = arch_probe_nr_irqs();
+ */
 int __init arch_probe_nr_irqs(void)
 {
 	int nr;
@@ -471,6 +538,10 @@ int __init arch_early_irq_init(void)
 }
 
 /* Initialize vector_irq on a new cpu */
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|538| <<setup_vector_irq>> __setup_vector_irq(cpu);
+ */
 static void __setup_vector_irq(int cpu)
 {
 	struct apic_chip_data *data;
@@ -479,11 +550,23 @@ static void __setup_vector_irq(int cpu)
 
 	/* Mark the inuse vectors */
 	for_each_irq_desc(irq, desc) {
+		/*
+		 * struct irq_data来自irq_desc->irq_data
+		 * 是嵌入进去的, 不是指针
+		 */
 		struct irq_data *idata = irq_desc_get_irq_data(desc);
 
+		/* struct irq_data的void *chip_data */
 		data = apic_chip_data(idata);
 		if (!data || !cpumask_test_cpu(cpu, data->domain))
 			continue;
+		/*
+		 * struct irq_cfg {
+		 *         unsigned int dest_apicid;
+		 *         u8           vector;
+		 *         u8           old_vector;
+		 * };
+		 */
 		vector = data->cfg.vector;
 		per_cpu(vector_irq, cpu)[vector] = desc;
 	}
@@ -493,6 +576,7 @@ static void __setup_vector_irq(int cpu)
 		if (IS_ERR_OR_NULL(desc))
 			continue;
 
+		/* struct irq_data的void *chip_data */
 		data = apic_chip_data(irq_desc_get_irq_data(desc));
 		if (!cpumask_test_cpu(cpu, data->domain))
 			per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
@@ -502,6 +586,10 @@ static void __setup_vector_irq(int cpu)
 /*
  * Setup the vector to irq mappings. Must be called with vector_lock held.
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/smpboot.c|257| <<start_secondary>> setup_vector_irq(smp_processor_id());
+ */
 void setup_vector_irq(int cpu)
 {
 	int irq;
@@ -806,6 +894,10 @@ static void __init print_APIC_field(int base)
 	pr_cont("\n");
 }
 
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/vector.c|931| <<print_local_APICs>> smp_call_function_single(cpu, print_local_APIC, NULL, 1);
+ */
 static void __init print_local_APIC(void *dummy)
 {
 	unsigned int i, v, ver, maxlvt;
@@ -913,6 +1005,10 @@ static void __init print_local_APIC(void *dummy)
 	pr_cont("\n");
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|996| <<print_ICs>> print_local_APICs(show_lapic);
+ */
 static void __init print_local_APICs(int maxcpu)
 {
 	int cpu;
diff --git a/arch/x86/kernel/dumpstack.c b/arch/x86/kernel/dumpstack.c
index 224de37..aa6fef2 100644
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@ -273,6 +273,12 @@ NOKPROBE_SYMBOL(oops_begin);
 
 void __noreturn rewind_stack_do_exit(int signr);
 
+/*
+ * called by:
+ *   - arch/x86/kernel/dumpstack.c|360| <<die>> oops_end(flags, regs, sig);
+ *   - arch/x86/mm/fault.c|733| <<pgtable_bad>> oops_end(flags, regs, sig);
+ *   - arch/x86/mm/fault.c|846| <<no_context>> oops_end(flags, regs, sig);
+ */
 void oops_end(unsigned long flags, struct pt_regs *regs, int signr)
 {
 	if (regs && kexec_should_crash(current))
diff --git a/arch/x86/kernel/hpet.c b/arch/x86/kernel/hpet.c
index df767e6..364d9d7 100644
--- a/arch/x86/kernel/hpet.c
+++ b/arch/x86/kernel/hpet.c
@@ -899,6 +899,11 @@ static u32 *hpet_boot_cfg;
 /**
  * hpet_enable - Try to setup the HPET timer. Returns 1 on success.
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/hpet.c|1032| <<hpet_late_init>> hpet_enable();
+ *   - arch/x86/kernel/time.c|102| <<hpet_time_init>> if (!hpet_enable())
+ */
 int __init hpet_enable(void)
 {
 	u32 hpet_period, cfg, id;
@@ -1294,6 +1299,10 @@ int hpet_rtc_dropped_irq(void)
 }
 EXPORT_SYMBOL_GPL(hpet_rtc_dropped_irq);
 
+/*
+ * called only by:
+ *   - arch/x86/kernel/hpet.c|1334| <<hpet_rtc_interrupt>> hpet_rtc_timer_reinit();
+ */
 static void hpet_rtc_timer_reinit(void)
 {
 	unsigned int delta;
diff --git a/arch/x86/kernel/i8259.c b/arch/x86/kernel/i8259.c
index 02abc13..9b124eb 100644
--- a/arch/x86/kernel/i8259.c
+++ b/arch/x86/kernel/i8259.c
@@ -32,6 +32,11 @@
  */
 static void init_8259A(int auto_eoi);
 
+/*
+ * used by:
+ *   - arch/x86/kernel/i8259.c|346| <<i8259A_resume>> init_8259A(i8259A_auto_eoi);
+ *   - arch/x86/kernel/i8259.c|452| <<init_8259A>> i8259A_auto_eoi = auto_eoi;
+ */
 static int i8259A_auto_eoi;
 DEFINE_RAW_SPINLOCK(i8259A_lock);
 
@@ -42,6 +47,15 @@ DEFINE_RAW_SPINLOCK(i8259A_lock);
 /*
  * This contains the irq mask for both 8259A irq controllers,
  */
+/*
+ * used by:
+ *   - arch/x86/include/asm/i8259.h|11| <<cached_master_mask>> #define cached_master_mask (__byte(0, cached_irq_mask))
+ *   - arch/x86/include/asm/i8259.h|12| <<cached_slave_mask>> #define cached_slave_mask (__byte(1, cached_irq_mask))
+ *   - arch/x86/kernel/i8259.c|64| <<mask_8259A_irq>> cached_irq_mask |= mask;
+ *   - arch/x86/kernel/i8259.c|83| <<unmask_8259A_irq>> cached_irq_mask &= mask;
+ *   - arch/x86/kernel/i8259.c|171| <<mask_and_ack_8259A>> if (cached_irq_mask & irqmask)
+ *   - arch/x86/kernel/i8259.c|173| <<mask_and_ack_8259A>> cached_irq_mask |= irqmask;
+ */
 unsigned int cached_irq_mask = 0xffff;
 
 /*
@@ -53,13 +67,44 @@ unsigned int cached_irq_mask = 0xffff;
  * this 'mixed mode' IRQ handling costs nothing because it's only used
  * at IRQ setup time.
  */
+/*
+ * used by:
+ *   - arch/x86/include/asm/io_apic.h|147| <<IO_APIC_IRQ>> #define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1 << (x)) & io_apic_irqs))
+ *   - arch/x86/include/asm/io_apic.h|154| <<io_apic_assign_pci_irqs>> (mp_irq_entries && !skip_ioapic_setup && io_apic_irqs)
+ *   - arch/x86/kernel/apic/io_apic.c|284| <<arch_early_ioapic_init>> io_apic_irqs = ~0UL;
+ *   - arch/x86/kernel/apic/io_apic.c|2427| <<setup_IO_APIC>> io_apic_irqs = nr_legacy_irqs() ? ~PIC_IRQS : ~0UL;
+ *   - arch/x86/kernel/i8259.c|115| <<make_8259A_irq>> io_apic_irqs &= ~(1<<irq);
+ *
+ * 在I/O APIC的IRQ0线上链接着8259中断
+ *
+ * 下面是一个bitmap, 说明那个irq line是用的io_apic
+ */
 unsigned long io_apic_irqs;
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|1744| <<startup_ioapic_irq>> legacy_pic->mask(irq);
+ *   - arch/x86/kernel/apic/io_apic.c|2154| <<check_timer>> legacy_pic->mask(0);
+ *   - arch/x86/kernel/apic/io_apic.c|2285| <<check_timer>> legacy_pic->mask(0);
+ *   - arch/x86/kernel/apic/io_apic.c|2305| <<check_timer>> legacy_pic->mask(0);
+ *   - arch/x86/kernel/apic/io_apic.c|3115| <<mp_irqdomain_alloc>> legacy_pic->mask(virq);
+ *
+ * struct legacy_pic default_legacy_pic.mask = mask_8259A_irq()
+ *
+ * 通过IMR寄存器在8259禁用某个irq line
+ */
 static void mask_8259A_irq(unsigned int irq)
 {
 	unsigned int mask = 1 << irq;
 	unsigned long flags;
 
+	/*
+	 * unsigned int cached_irq_mask;
+	 * #define __byte(x, y)            (((unsigned char *)&(y))[x])
+	 * #define cached_master_mask      (__byte(0, cached_irq_mask))
+	 * #define cached_slave_mask       (__byte(1, cached_irq_mask))
+	 */
+
 	raw_spin_lock_irqsave(&i8259A_lock, flags);
 	cached_irq_mask |= mask;
 	if (irq & 8)
@@ -69,11 +114,26 @@ static void mask_8259A_irq(unsigned int irq)
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
 }
 
+/*
+ * struct irq_chip i8259A_chip.irq_mask = disable_8259A_irq()
+ * struct irq_chip i8259A_chip.irq_disable = disable_8259A_irq()
+ *
+ * 通过IMR寄存器在8259禁用某个通过irq_data定义的irq line
+ */
 static void disable_8259A_irq(struct irq_data *data)
 {
 	mask_8259A_irq(data->irq);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|2273| <<check_timer>> legacy_pic->unmask(0);
+ *   - arch/x86/kernel/apic/io_apic.c|2298| <<check_timer>> legacy_pic->unmask(0);
+ *
+ * struct legacy_pic default_legacy_pic.unmask = unmask_8259A_irq()
+ *
+ * 通过IMR寄存器在8259开通某个irq line
+ */
 static void unmask_8259A_irq(unsigned int irq)
 {
 	unsigned int mask = ~(1 << irq);
@@ -88,11 +148,24 @@ static void unmask_8259A_irq(unsigned int irq)
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
 }
 
+/*
+ * struct irq_chip i8259A_chip.irq_unmask = enable_8259A_irq()
+ *
+ * 通过IMR寄存器在8259开通某个irq line
+ */
 static void enable_8259A_irq(struct irq_data *data)
 {
 	unmask_8259A_irq(data->irq);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|1745| <<startup_ioapic_irq>> if (legacy_pic->irq_pending(irq))
+ *
+ * struct legacy_pic default_legacy_pic.irq_pending = i8259A_irq_pending()
+ *
+ * 通过cmd port获取某个irq line是否在pending
+ */
 static int i8259A_irq_pending(unsigned int irq)
 {
 	unsigned int mask = 1<<irq;
@@ -109,9 +182,32 @@ static int i8259A_irq_pending(unsigned int irq)
 	return ret;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|1977| <<init_IO_APIC_traps>> legacy_pic->make_irq(irq);
+ *   - arch/x86/kernel/apic/io_apic.c|2316| <<check_timer>> legacy_pic->make_irq(0);
+ *
+ * struct legacy_pic default_legacy_pic.make_irq = make_8259A_irq()
+ *
+ * 配置8259使某个irq line通过8259, 而不通过ioapic了
+ * 这里在io_apic_irqs把某个irq line的bit清0, 说明不通过ioapic了
+ * 通过下面设置中断的chip:
+ *   - irq_set_chip_and_handler(irq, &i8259A_chip, handle_level_irq);
+ */
 static void make_8259A_irq(unsigned int irq)
 {
 	disable_irq_nosync(irq);
+	/*
+	 * io_apic_irqs是一个bitmap, 说明那个irq line是用的io_apic
+	 * used by:
+	 *   - arch/x86/include/asm/io_apic.h|147| <<IO_APIC_IRQ>> #define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1 << (x)) & io_apic_irqs))
+	 *   - arch/x86/include/asm/io_apic.h|154| <<io_apic_assign_pci_irqs>> (mp_irq_entries && !skip_ioapic_setup && io_apic_irqs)
+	 *   - arch/x86/kernel/apic/io_apic.c|284| <<arch_early_ioapic_init>> io_apic_irqs = ~0UL;
+	 *   - arch/x86/kernel/apic/io_apic.c|2427| <<setup_IO_APIC>> io_apic_irqs = nr_legacy_irqs() ? ~PIC_IRQS : ~0UL;
+	 *   - arch/x86/kernel/i8259.c|115| <<make_8259A_irq>> io_apic_irqs &= ~(1<<irq);
+	 *
+	 * 这里把某个irq line的bit清0, 说明不通过ioapic了
+	 */
 	io_apic_irqs &= ~(1<<irq);
 	irq_set_chip_and_handler(irq, &i8259A_chip, handle_level_irq);
 	enable_irq(irq);
@@ -123,6 +219,10 @@ static void make_8259A_irq(unsigned int irq)
  * This has to be protected by the irq controller spinlock
  * before being called.
  */
+/*
+ * called by only:
+ *   - arch/x86/kernel/i8259.c|273| <<mask_and_ack_8259A>> if (i8259A_irq_real(irq))
+ */
 static inline int i8259A_irq_real(unsigned int irq)
 {
 	int value;
@@ -146,6 +246,9 @@ static inline int i8259A_irq_real(unsigned int irq)
  * first, _then_ send the EOI, and the order of EOI
  * to the two 8259s is important!
  */
+/*
+ * struct irq_chip i8259A_chip.irq_mask_ack = mask_and_ack_8259A()
+ */
 static void mask_and_ack_8259A(struct irq_data *data)
 {
 	unsigned int irq = data->irq;
@@ -220,6 +323,7 @@ static void mask_and_ack_8259A(struct irq_data *data)
 	}
 }
 
+/* struct legacy_pic default_legacy_pic.chip = i8259A_chip */
 struct irq_chip i8259A_chip = {
 	.name		= "XT-PIC",
 	.irq_mask	= disable_8259A_irq,
@@ -245,18 +349,27 @@ static void save_ELCR(char *trigger)
 	trigger[1] = inb(0x4d1) & 0xDE;
 }
 
+/*
+ * struct syscore_ops i8259_syscore_ops.resume = i8259A_resume()
+ */
 static void i8259A_resume(void)
 {
 	init_8259A(i8259A_auto_eoi);
 	restore_ELCR(irq_trigger);
 }
 
+/*
+ * struct syscore_ops i8259_syscore_ops.suspend = i8259A_suspend()
+ */
 static int i8259A_suspend(void)
 {
 	save_ELCR(irq_trigger);
 	return 0;
 }
 
+/*
+ * struct syscore_ops i8259_syscore_ops.shutdown = i8259A_shutdown()
+ */
 static void i8259A_shutdown(void)
 {
 	/* Put the i8259A into a quiescent state that
@@ -273,6 +386,9 @@ static struct syscore_ops i8259_syscore_ops = {
 	.shutdown = i8259A_shutdown,
 };
 
+/*
+ * struct legacy_pic default_legacy_pic.mask_all = mask_8259A()
+ */
 static void mask_8259A(void)
 {
 	unsigned long flags;
@@ -285,6 +401,9 @@ static void mask_8259A(void)
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
 }
 
+/*
+ * struct legacy_pic default_legacy_pic.restore_mask = unmask_8259A()
+ */
 static void unmask_8259A(void)
 {
 	unsigned long flags;
@@ -297,9 +416,20 @@ static void unmask_8259A(void)
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|423| <<arch_probe_nr_irqs>> return legacy_pic->probe();
+ *
+ * struct legacy_pic default_legacy_pic.probe = probe_8259A()
+ *
+ * 把slave的imr设置为全是1 (全部master)
+ * 把master除了irq 2全部mask (irq 2连接slave)
+ * 对于default_legacy_pic返回NR_IRQS_LEGACY(16)
+ */
 static int probe_8259A(void)
 {
 	unsigned long flags;
+	/* 除了第2个bit是0, 剩下全是1: 11111011*/
 	unsigned char probe_val = ~(1 << PIC_CASCADE_IR);
 	unsigned char new_val;
 	/*
@@ -320,44 +450,106 @@ static int probe_8259A(void)
 	}
 
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
+	/*
+	 * 在default_legacy_pic返回NR_IRQS_LEGACY(16)
+	 * 在null_legacy_pic返回0
+	 */
 	return nr_legacy_irqs();
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|2166| <<check_timer>> legacy_pic->init(1);
+ *   - arch/x86/kernel/apic/io_apic.c|2315| <<check_timer>> legacy_pic->init(0);
+ *   - arch/x86/kernel/irqinit.c|68| <<init_ISA_irqs>> legacy_pic->init(0);
+ *
+ * struct legacy_pic default_legacy_pic.init = init_8259A()
+ *
+ * 按照ICW要求的顺序初始化8259
+ *   vector 0x30对应irq line 0
+ *   vector 0x38对应irq line 8
+ * 最后会根据cached_irq_mask屏蔽中断
+ */
 static void init_8259A(int auto_eoi)
 {
 	unsigned long flags;
 
+	/* 主要在i8259A_resume()的时候使用 */
 	i8259A_auto_eoi = auto_eoi;
 
 	raw_spin_lock_irqsave(&i8259A_lock, flags);
 
+	/* 在8259 master上屏蔽所有中断 */
 	outb(0xff, PIC_MASTER_IMR);	/* mask all of 8259A-1 */
 
 	/*
+	 * 初始化按照如下顺序:
+	 * 1. master ICW1 (实际上ICW1的字是固定的 00010001 = 0x11)
+	 * 2. master ICW2
+	 * 3. master ICW3
+	 * 4. master ICW4
+	 * 5. slave  ICW1
+	 * 6. slave  ICW2
+	 * 7. slave  ICW3
+	 * 8. slave  ICW4
+	 */
+
+	/*
 	 * outb_pic - this has to work on a wide range of PC hardware.
 	 */
+	/*
+	 * 最后一位是1, 说明要求设置ICW4
+	 */
 	outb_pic(0x11, PIC_MASTER_CMD);	/* ICW1: select 8259A-1 init */
 
 	/* ICW2: 8259A-1 IR0-7 mapped to ISA_IRQ_VECTOR(0) */
+	/*
+	 * ISA_IRQ_VECTOR(0)
+	 * 输入一个irq, 返回0x30+irq, 也就是48+irq
+	 * 00110000
+	 *
+	 * 00110 000: 也就是说, vector 0x30对应irq line 0
+	 */
 	outb_pic(ISA_IRQ_VECTOR(0), PIC_MASTER_IMR);
 
 	/* 8259A-1 (the master) has a slave on IR2 */
+	/*
+	 * ICW3的master, 表示slave接入master的IRQ line 8
+	 */
 	outb_pic(1U << PIC_CASCADE_IR, PIC_MASTER_IMR);
 
+	/*
+	 * 对于支持aeoi, ICW4的master是00000011
+	 * 对于不支持aeoi, ICW4的master是00000001
+	 *
+	 * 这里总是不支持Special Full Nested Mode
+	 */
 	if (auto_eoi)	/* master does Auto EOI */
 		outb_pic(MASTER_ICW4_DEFAULT | PIC_ICW4_AEOI, PIC_MASTER_IMR);
 	else		/* master expects normal EOI */
 		outb_pic(MASTER_ICW4_DEFAULT, PIC_MASTER_IMR);
 
+	/*
+	 * 开始slave的ICW1
+	 */
 	outb_pic(0x11, PIC_SLAVE_CMD);	/* ICW1: select 8259A-2 init */
 
 	/* ICW2: 8259A-2 IR0-7 mapped to ISA_IRQ_VECTOR(8) */
+	/*
+	 * 111000
+	 *
+	 * 00111 000: 也就是说, vector 0x38对应irq line 0
+	 */
 	outb_pic(ISA_IRQ_VECTOR(8), PIC_SLAVE_IMR);
 	/* 8259A-2 is a slave on master's IR2 */
 	outb_pic(PIC_CASCADE_IR, PIC_SLAVE_IMR);
 	/* (slave's support for AEOI in flat mode is to be investigated) */
 	outb_pic(SLAVE_ICW4_DEFAULT, PIC_SLAVE_IMR);
 
+	/*
+	 * 在AEOI (Automatic End of Interrupt) 模式里, 8259在第2个INTA#结束后自动清ISR相应的bit,
+	 * 否则必须发送一个EOI命令给8259
+	 */
 	if (auto_eoi)
 		/*
 		 * In AEOI mode we just have to mask the interrupt
@@ -369,7 +561,29 @@ static void init_8259A(int auto_eoi)
 
 	udelay(100);		/* wait for 8259A to initialize */
 
+	/*
+	 * #define __byte(x, y)            (((unsigned char *)&(y))[x])
+	 * #define cached_master_mask      (__byte(0, cached_irq_mask))
+	 *
+	 * cached_master_mask只使用, 不修改:
+	 *   - arch/x86/kernel/i8259.c|113| <<mask_8259A_irq>> outb(cached_master_mask, PIC_MASTER_IMR);
+	 *   - arch/x86/kernel/i8259.c|147| <<unmask_8259A_irq>> outb(cached_master_mask, PIC_MASTER_IMR);
+	 *   - arch/x86/kernel/i8259.c|288| <<mask_and_ack_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+	 *   - arch/x86/kernel/i8259.c|413| <<unmask_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+	 *   - arch/x86/kernel/i8259.c|528| <<init_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+	 */
 	outb(cached_master_mask, PIC_MASTER_IMR); /* restore master IRQ mask */
+	/*
+	 * #define __byte(x, y)            (((unsigned char *)&(y))[x])
+	 * #define cached_slave_mask       (__byte(1, cached_irq_mask))
+	 *
+	 * cached_slave_mask只使用, 不修改:
+	 *   - arch/x86/kernel/i8259.c|111| <<mask_8259A_irq>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+	 *   - arch/x86/kernel/i8259.c|145| <<unmask_8259A_irq>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+	 *   - arch/x86/kernel/i8259.c|281| <<mask_and_ack_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+	 *   - arch/x86/kernel/i8259.c|414| <<unmask_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+	 *   - arch/x86/kernel/i8259.c|529| <<init_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+	 */
 	outb(cached_slave_mask, PIC_SLAVE_IMR);	  /* restore slave IRQ mask */
 
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
@@ -419,6 +633,13 @@ struct legacy_pic default_legacy_pic = {
 	.make_irq = make_8259A_irq,
 };
 
+/*
+ * used by:
+ *   - arch/x86/kernel/i8259.c|422| <<global>> struct legacy_pic *legacy_pic = &default_legacy_pic;
+ *   - arch/x86/kernel/acpi/boot.c|1387| <<acpi_reduced_hw_init>> legacy_pic = &null_legacy_pic;
+ *   - arch/x86/kernel/i8259.c|319| <<probe_8259A>> legacy_pic = &null_legacy_pic;
+ *   - arch/x86/platform/intel-mid/intel-mid.c|200| <<x86_intel_mid_early_setup>> legacy_pic = &null_legacy_pic;
+ */
 struct legacy_pic *legacy_pic = &default_legacy_pic;
 EXPORT_SYMBOL(legacy_pic);
 
diff --git a/arch/x86/kernel/irq.c b/arch/x86/kernel/irq.c
index 3c2326b..65096ee 100644
--- a/arch/x86/kernel/irq.c
+++ b/arch/x86/kernel/irq.c
@@ -207,6 +207,31 @@ u64 arch_irq_stat(void)
 	return sum;
 }
 
+/*
+ * vector_irq在以下使用:
+ *   - arch/x86/kernel/apic/vector.c|183| <<__assign_irq_vector>> if (!IS_ERR_OR_NULL(per_cpu(vector_irq, new_cpu)[vector]))
+ *   - arch/x86/kernel/apic/vector.c|193| <<__assign_irq_vector>> per_cpu(vector_irq, new_cpu)[vector] = irq_to_desc(irq);
+ *   - arch/x86/kernel/apic/vector.c|272| <<clear_irq_vector>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|289| <<clear_irq_vector>> if (per_cpu(vector_irq, cpu)[vector] != desc)
+ *   - arch/x86/kernel/apic/vector.c|291| <<clear_irq_vector>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|492| <<__setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = desc;
+ *   - arch/x86/kernel/apic/vector.c|496| <<__setup_vector_irq>> desc = per_cpu(vector_irq, cpu)[vector];
+ *   - arch/x86/kernel/apic/vector.c|502| <<__setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|522| <<setup_vector_irq>> per_cpu(vector_irq, cpu)[ISA_IRQ_VECTOR(irq)] = irq_to_desc(irq);
+ *   - arch/x86/kernel/apic/vector.c|607| <<smp_irq_move_cleanup_interrupt>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/apic/vector.c|658| <<smp_irq_move_cleanup_interrupt>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/apic/vector.c|792| <<irq_force_complete_move>> per_cpu(vector_irq, cpu)[cfg->old_vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/irq.c|228| <<do_IRQ>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|238| <<do_IRQ>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/irq.c|351| <<check_irq_vectors_for_cpu_disable>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|409| <<check_irq_vectors_for_cpu_disable>> IS_ERR_OR_NULL(per_cpu(vector_irq, cpu)[vector])) {
+ *   - arch/x86/kernel/irq.c|451| <<fixup_irqs>> if (IS_ERR_OR_NULL(__this_cpu_read(vector_irq[vector])))
+ *   - arch/x86/kernel/irq.c|456| <<fixup_irqs>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|463| <<fixup_irqs>> __this_cpu_write(vector_irq[vector], VECTOR_RETRIGGERED);
+ *   - arch/x86/kernel/irq.c|467| <<fixup_irqs>> if (__this_cpu_read(vector_irq[vector]) != VECTOR_RETRIGGERED)
+ *   - arch/x86/kernel/irq.c|468| <<fixup_irqs>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/irqinit.c|87| <<init_IRQ>> per_cpu(vector_irq, 0)[ISA_IRQ_VECTOR(i)] = irq_to_desc(i);
+ */
 
 /*
  * do_IRQ handles all normal device IRQ's (the special
diff --git a/arch/x86/kernel/irqinit.c b/arch/x86/kernel/irqinit.c
index 40f83d0..1f99984 100644
--- a/arch/x86/kernel/irqinit.c
+++ b/arch/x86/kernel/irqinit.c
@@ -53,6 +53,31 @@ static struct irqaction irq2 = {
 	.flags = IRQF_NO_THREAD,
 };
 
+/*
+ * 在以下使用:
+ *   - arch/x86/kernel/apic/vector.c|183| <<__assign_irq_vector>> if (!IS_ERR_OR_NULL(per_cpu(vector_irq, new_cpu)[vector]))
+ *   - arch/x86/kernel/apic/vector.c|193| <<__assign_irq_vector>> per_cpu(vector_irq, new_cpu)[vector] = irq_to_desc(irq);
+ *   - arch/x86/kernel/apic/vector.c|272| <<clear_irq_vector>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|289| <<clear_irq_vector>> if (per_cpu(vector_irq, cpu)[vector] != desc)
+ *   - arch/x86/kernel/apic/vector.c|291| <<clear_irq_vector>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|492| <<__setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = desc;
+ *   - arch/x86/kernel/apic/vector.c|496| <<__setup_vector_irq>> desc = per_cpu(vector_irq, cpu)[vector];
+ *   - arch/x86/kernel/apic/vector.c|502| <<__setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|522| <<setup_vector_irq>> per_cpu(vector_irq, cpu)[ISA_IRQ_VECTOR(irq)] = irq_to_desc(irq);
+ *   - arch/x86/kernel/apic/vector.c|607| <<smp_irq_move_cleanup_interrupt>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/apic/vector.c|658| <<smp_irq_move_cleanup_interrupt>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/apic/vector.c|792| <<irq_force_complete_move>> per_cpu(vector_irq, cpu)[cfg->old_vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/irq.c|228| <<do_IRQ>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|238| <<do_IRQ>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/irq.c|351| <<check_irq_vectors_for_cpu_disable>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|409| <<check_irq_vectors_for_cpu_disable>> IS_ERR_OR_NULL(per_cpu(vector_irq, cpu)[vector])) {
+ *   - arch/x86/kernel/irq.c|451| <<fixup_irqs>> if (IS_ERR_OR_NULL(__this_cpu_read(vector_irq[vector])))
+ *   - arch/x86/kernel/irq.c|456| <<fixup_irqs>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|463| <<fixup_irqs>> __this_cpu_write(vector_irq[vector], VECTOR_RETRIGGERED);
+ *   - arch/x86/kernel/irq.c|467| <<fixup_irqs>> if (__this_cpu_read(vector_irq[vector]) != VECTOR_RETRIGGERED)
+ *   - arch/x86/kernel/irq.c|468| <<fixup_irqs>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/irqinit.c|87| <<init_IRQ>> per_cpu(vector_irq, 0)[ISA_IRQ_VECTOR(i)] = irq_to_desc(i);
+ */
 DEFINE_PER_CPU(vector_irq_t, vector_irq) = {
 	[0 ... NR_VECTORS - 1] = VECTOR_UNUSED,
 };
diff --git a/arch/x86/kernel/time.c b/arch/x86/kernel/time.c
index ab0176a..73658b8 100644
--- a/arch/x86/kernel/time.c
+++ b/arch/x86/kernel/time.c
@@ -56,8 +56,29 @@ EXPORT_SYMBOL(profile_pc);
 /*
  * Default timer interrupt handler for PIT/HPET
  */
+/*
+ * struct irqaction irq0.handler = timer_interrupt()
+ *
+ * tick_do_timer_cpu更新timer
+ */
 static irqreturn_t timer_interrupt(int irq, void *dev_id)
 {
+	/*
+	 * event_handler在以下设置:
+	 *   - arch/x86/kernel/apic/apic.c|845| <<calibrate_APIC_clock>> global_clock_event->event_handler = lapic_cal_handler;
+	 *   - arch/x86/kernel/apic/apic.c|862| <<calibrate_APIC_clock>> global_clock_event->event_handler = real_handler;
+	 *   - arch/x86/kernel/apic/apic.c|924| <<calibrate_APIC_clock>> levt->event_handler = lapic_cal_handler;
+	 *   - kernel/time/tick-broadcast.c|104| <<tick_install_broadcast_device>> cur->event_handler = clockevents_handle_noop;
+	 *   - kernel/time/tick-broadcast.c|176| <<tick_device_uses_broadcast>> dev->event_handler = tick_handle_periodic;
+	 *   - kernel/time/tick-broadcast.c|435| <<tick_set_periodic_handler>> dev->event_handler = tick_handle_periodic;
+	 *   - kernel/time/tick-broadcast.c|437| <<tick_set_periodic_handler>> dev->event_handler = tick_handle_periodic_broadcast;
+	 *   - kernel/time/tick-broadcast.c|891| <<tick_broadcast_setup_oneshot>> bc->event_handler = tick_handle_oneshot_broadcast;
+	 *   - kernel/time/tick-common.c|208| <<tick_setup_device>> td->evtdev->event_handler = clockevents_handle_noop;
+	 *   - kernel/time/tick-common.c|402| <<tick_shutdown>> dev->event_handler = clockevents_handle_noop;
+	 *   - kernel/time/tick-internal.h|91| <<tick_set_periodic_handler>> dev->event_handler = tick_handle_periodic;
+	 *   - kernel/time/tick-oneshot.c|68| <<tick_setup_oneshot>> newdev->event_handler = handler;
+	 *   - kernel/time/tick-oneshot.c|99| <<tick_switch_to_oneshot>> dev->event_handler = handler;
+	 */
 	global_clock_event->event_handler(global_clock_event);
 	return IRQ_HANDLED;
 }
@@ -78,6 +99,13 @@ static void __init setup_default_timer_irq(void)
 /* Default timer init function */
 void __init hpet_time_init(void)
 {
+	/*
+	 * hpet_enable - Try to setup the HPET timer. Returns 1 on success.
+	 *
+	 * 这里如果激活hpet失败, 再使用pit
+	 *
+	 * 在ovm xen上是失败的, 要用PIT
+	 */
 	if (!hpet_enable())
 		setup_pit_timer();
 	setup_default_timer_irq();
diff --git a/arch/x86/kernel/x86_init.c b/arch/x86/kernel/x86_init.c
index 5b2d10c..fdab936 100644
--- a/arch/x86/kernel/x86_init.c
+++ b/arch/x86/kernel/x86_init.c
@@ -144,6 +144,13 @@ void arch_restore_msi_irqs(struct pci_dev *dev)
 }
 #endif
 
+/*
+ * used by:
+ *   - arch/x86/include/asm/io_apic.h|190| <<io_apic_read>> return x86_io_apic_ops.read(apic, reg);
+ *   - arch/x86/kernel/apic/io_apic.c|1454| <<disable_IO_APIC>> x86_io_apic_ops.disable();
+ *   - arch/x86/xen/apic.c|220| <<xen_init_apic>> x86_io_apic_ops.read = xen_io_apic_read;
+ *   - drivers/iommu/irq_remapping.c|45| <<irq_remapping_modify_x86_ops>> x86_io_apic_ops.disable = irq_remapping_disable_io_apic;
+ */
 struct x86_io_apic_ops x86_io_apic_ops __ro_after_init = {
 	.read			= native_io_apic_read,
 	.disable		= native_disable_io_apic,
diff --git a/drivers/clocksource/i8253.c b/drivers/clocksource/i8253.c
index d4350bb..6609f45 100644
--- a/drivers/clocksource/i8253.c
+++ b/drivers/clocksource/i8253.c
@@ -178,6 +178,10 @@ struct clock_event_device i8253_clockevent = {
  * Initialize the conversion factor and the min/max deltas of the clock event
  * structure and register the clock event source with the framework.
  */
+/*
+ * x86下只有一处调用:
+ *   - arch/x86/kernel/i8253.c|23| <<setup_pit_timer>> clockevent_i8253_init(true);
+ */
 void __init clockevent_i8253_init(bool oneshot)
 {
 	if (oneshot) {
diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c
index 536e9a5..01cdf78 100644
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -34,6 +34,7 @@ int pci_msi_ignore_mask;
 #ifdef CONFIG_PCI_MSI_IRQ_DOMAIN
 static int pci_msi_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
 {
+	/* include/linux/irqdomain.h */
 	struct irq_domain *domain;
 
 	domain = dev_get_msi_domain(&dev->dev);
@@ -531,6 +532,10 @@ static int populate_msi_sysfs(struct pci_dev *pdev)
 	return ret;
 }
 
+/*
+ * called by only:
+ *   - drivers/pci/msi.c|614| <<msi_capability_init>> entry = msi_setup_entry(dev, nvec, affd);
+ */
 static struct msi_desc *
 msi_setup_entry(struct pci_dev *dev, int nvec, const struct irq_affinity *affd)
 {
@@ -597,6 +602,10 @@ static int msi_verify_entries(struct pci_dev *dev)
  * an error, and a positive return value indicates the number of interrupts
  * which could have been allocated.
  */
+/*
+ * called by:
+ *   - drivers/pci/msi.c|1060| <<__pci_enable_msi_range>> rc = msi_capability_init(dev, nvec, affd);
+ */
 static int msi_capability_init(struct pci_dev *dev, int nvec,
 			       const struct irq_affinity *affd)
 {
@@ -614,6 +623,14 @@ static int msi_capability_init(struct pci_dev *dev, int nvec,
 	mask = msi_mask(entry->msi_attrib.multi_cap);
 	msi_mask_irq(entry, mask, mask);
 
+	/*
+	 * msi_list在以使用:
+	 *   - drivers/base/core.c|1424| <<device_initialize>> INIT_LIST_HEAD(&dev->msi_list);
+	 *   - drivers/pci/msi.c|344| <<free_msi_irqs>> struct list_head *msi_list = dev_to_msi_list(&dev->dev);
+	 *   - drivers/pci/msi.c|357| <<free_msi_irqs>> list_for_each_entry_safe(entry, tmp, msi_list, list) {
+	 *   - drivers/pci/msi.c|359| <<free_msi_irqs>> if (list_is_last(&entry->list, msi_list))
+	 *   - include/linux/msi.h|125| <<dev_to_msi_list>> #define dev_to_msi_list(dev) (&(dev)->msi_list)
+	 */
 	list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
 
 	/* Configure MSI capability structure */
@@ -648,6 +665,10 @@ static int msi_capability_init(struct pci_dev *dev, int nvec,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/pci/msi.c|793| <<msix_capability_init>> base = msix_map_region(dev, msix_table_size(control));
+ */
 static void __iomem *msix_map_region(struct pci_dev *dev, unsigned nr_entries)
 {
 	resource_size_t phys_addr;
@@ -668,6 +689,20 @@ static void __iomem *msix_map_region(struct pci_dev *dev, unsigned nr_entries)
 	return ioremap_nocache(phys_addr, nr_entries * PCI_MSIX_ENTRY_SIZE);
 }
 
+/*
+ * qemu nvme 4个cpu的例子: 两次进入以下, nvec=1和nvec=4
+ * [0] msix_setup_entries
+ * [0] __pci_enable_msix_range
+ * [0] pci_alloc_irq_vectors_affinity
+ * [0] nvme_reset_work
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/pci/msi.c|768| <<msix_capability_init>> ret = msix_setup_entries(dev, base, entries, nvec, affd);
+ */
 static int msix_setup_entries(struct pci_dev *dev, void __iomem *base,
 			      struct msix_entry *entries, int nvec,
 			      const struct irq_affinity *affd)
@@ -700,6 +735,17 @@ static int msix_setup_entries(struct pci_dev *dev, void __iomem *base,
 		entry->msi_attrib.default_irq	= dev->irq;
 		entry->mask_base		= base;
 
+		/*
+		 * dev_to_msi_list()的一些调用的地方:
+		 *   - drivers/pci/msi.c|344| <<free_msi_irqs>> struct list_head *msi_list = dev_to_msi_list(&dev->dev);
+		 *   - drivers/pci/msi.c|418| <<__pci_restore_msix_state>> BUG_ON(list_empty(dev_to_msi_list(&dev->dev)));
+		 *   - drivers/pci/msi.c|618| <<msi_capability_init>> list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
+		 *   - drivers/pci/msi.c|704| <<msix_setup_entries>> list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
+		 *   - drivers/pci/msi.c|889| <<pci_msi_shutdown>> BUG_ON(list_empty(dev_to_msi_list(&dev->dev)));
+		 *   - include/linux/msi.h|116| <<first_msi_entry>> list_first_entry(dev_to_msi_list((dev)), struct msi_desc, list)
+		 *   - include/linux/msi.h|118| <<for_each_msi_entry>> list_for_each_entry((desc), dev_to_msi_list((dev)), list)
+		 *   - include/linux/msi.h|120| <<for_each_msi_entry_safe>> list_for_each_entry_safe((desc), (tmp), dev_to_msi_list((dev)), list)
+		 */
 		list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
 		if (masks)
 			curmsk++;
@@ -736,6 +782,10 @@ static void msix_program_entries(struct pci_dev *dev,
  * single MSI-X irq. A return of zero indicates the successful setup of
  * requested MSI-X entries with allocated irqs or non-zero for otherwise.
  **/
+/*
+ * called by:
+ *   - drivers/pci/msi.c|980| <<__pci_enable_msix>> return msix_capability_init(dev, entries, nvec, affd);
+ */
 static int msix_capability_init(struct pci_dev *dev, struct msix_entry *entries,
 				int nvec, const struct irq_affinity *affd)
 {
@@ -932,6 +982,10 @@ int pci_msix_vec_count(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_msix_vec_count);
 
+/*
+ * called by:
+ *   - drivers/pci/msi.c|1137| <<__pci_enable_msix_range>> rc = __pci_enable_msix(dev, entries, nvec, affd);
+ */
 static int __pci_enable_msix(struct pci_dev *dev, struct msix_entry *entries,
 			     int nvec, const struct irq_affinity *affd)
 {
@@ -1018,6 +1072,11 @@ int pci_msi_enabled(void)
 }
 EXPORT_SYMBOL(pci_msi_enabled);
 
+/*
+ * called by:
+ *   - drivers/pci/msi.c|1076| <<pci_enable_msi>> int rc = __pci_enable_msi_range(dev, 1, 1, NULL);
+ *   - drivers/pci/msi.c|1178| <<pci_alloc_irq_vectors_affinity>> vecs = __pci_enable_msi_range(dev, min_vecs, max_vecs, affd);
+ */
 static int __pci_enable_msi_range(struct pci_dev *dev, int minvec, int maxvec,
 				  const struct irq_affinity *affd)
 {
@@ -1079,6 +1138,11 @@ int pci_enable_msi(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_enable_msi);
 
+/*
+ * called by:
+ *   - drivers/pci/msi.c|1183| <<pci_enable_msix_range>> return __pci_enable_msix_range(dev, entries, minvec, maxvec, NULL);
+ *   - drivers/pci/msi.c|1221| <<pci_alloc_irq_vectors_affinity>> vecs = __pci_enable_msix_range(dev, NULL, min_vecs, max_vecs,
+ */
 static int __pci_enable_msix_range(struct pci_dev *dev,
 				   struct msix_entry *entries, int minvec,
 				   int maxvec, const struct irq_affinity *affd)
@@ -1126,6 +1190,10 @@ static int __pci_enable_msix_range(struct pci_dev *dev,
  * indicates the successful configuration of MSI-X capability structure
  * with new allocated MSI-X interrupts.
  **/
+/*
+ * 一些调用的例子:
+ *   - drivers/net/ethernet/intel/e1000e/netdev.c|2079| <<e1000e_set_interrupt_capability>> err = pci_enable_msix_range(a->pdev,
+ */
 int pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries,
 		int minvec, int maxvec)
 {
@@ -1386,12 +1454,20 @@ static void pci_msi_domain_set_desc(msi_alloc_info_t *arg,
 #define pci_msi_domain_set_desc		NULL
 #endif
 
+/*
+ * used by:
+ *   - drivers/pci/msi.c|1468| <<pci_msi_domain_update_dom_ops>> info->ops = &pci_msi_domain_ops_default;
+ */
 static struct msi_domain_ops pci_msi_domain_ops_default = {
 	.set_desc	= pci_msi_domain_set_desc,
 	.msi_check	= pci_msi_domain_check_cap,
 	.handle_error	= pci_msi_domain_handle_error,
 };
 
+/*
+ * called by only:
+ *   - drivers/pci/msi.c|1510| <<pci_msi_create_irq_domain>> pci_msi_domain_update_dom_ops(info);
+ */
 static void pci_msi_domain_update_dom_ops(struct msi_domain_info *info)
 {
 	struct msi_domain_ops *ops = info->ops;
diff --git a/include/linux/device.h b/include/linux/device.h
index 66fe271..a117a25 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -916,6 +916,14 @@ struct device {
 	struct dev_pin_info	*pins;
 #endif
 #ifdef CONFIG_GENERIC_MSI_IRQ
+	/*
+	 * 在以下使用:
+	 *   - drivers/base/core.c|1424| <<device_initialize>> INIT_LIST_HEAD(&dev->msi_list);
+	 *   - drivers/pci/msi.c|344| <<free_msi_irqs>> struct list_head *msi_list = dev_to_msi_list(&dev->dev);
+	 *   - drivers/pci/msi.c|357| <<free_msi_irqs>> list_for_each_entry_safe(entry, tmp, msi_list, list) {
+	 *   - drivers/pci/msi.c|359| <<free_msi_irqs>> if (list_is_last(&entry->list, msi_list))
+	 *   - include/linux/msi.h|125| <<dev_to_msi_list>> #define dev_to_msi_list(dev) (&(dev)->msi_list)
+	 */
 	struct list_head	msi_list;
 #endif
 
@@ -1014,6 +1022,12 @@ static inline struct irq_domain *dev_get_msi_domain(const struct device *dev)
 #endif
 }
 
+/*
+ * called by:
+ *   - drivers/pci/host/vmd.c|658| <<vmd_enable_domain>> dev_set_msi_domain(&vmd->bus->dev, vmd->irq_domain);
+ *   - drivers/pci/probe.c|748| <<pci_set_bus_msi_domain>> dev_set_msi_domain(&bus->dev, d);
+ *   - drivers/pci/probe.c|2081| <<pci_set_msi_domain>> dev_set_msi_domain(&dev->dev, d);
+ */
 static inline void dev_set_msi_domain(struct device *dev, struct irq_domain *d)
 {
 #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index b1037df..89a9d32 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -108,11 +108,27 @@ struct irq_domain_ops {
 
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 	/* extended V2 interfaces to support hierarchy irq_domains */
+	/*
+	 * called by:
+	 *   - kernel/irq/irqdomain.c|1780| <<__irq_domain_activate_irq>> domain->ops->activate(domain, irq_data);
+	 */
 	int (*alloc)(struct irq_domain *d, unsigned int virq,
 		     unsigned int nr_irqs, void *arg);
+	/*
+	 * called by:
+	 *   - kernel/irq/irqdomain.c|1790| <<__irq_domain_deactivate_irq>> domain->ops->deactivate(domain, irq_data);
+	 */
 	void (*free)(struct irq_domain *d, unsigned int virq,
 		     unsigned int nr_irqs);
+	/*
+	 * called by:
+	 *   - kernel/irq/irqdomain.c|1780| <<__irq_domain_activate_irq>> domain->ops->activate(domain, irq_data);
+	 */
 	void (*activate)(struct irq_domain *d, struct irq_data *irq_data);
+	/*
+	 * called by:             
+	 *   - kernel/irq/irqdomain.c|1790| <<__irq_domain_deactivate_irq>> domain->ops->deactivate(domain, irq_data);
+	 */
 	void (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);
 	int (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec,
 			 unsigned long *out_hwirq, unsigned int *out_type);
@@ -339,6 +355,12 @@ static inline struct irq_domain *irq_domain_create_linear(struct fwnode_handle *
 					 const struct irq_domain_ops *ops,
 					 void *host_data)
 {
+	/*
+	 * 如果是从ioapic进来的:
+	 *   ops可以是struct irq_domain_ops mp_ioapic_irqdomain_ops
+	 *   size是ioapic的pin的数量
+	 *   host_data是ioapic的id
+	 */
 	return __irq_domain_add(fwnode, size, size, 0, ops, host_data);
 }
 
@@ -441,6 +463,14 @@ extern void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs);
 extern void irq_domain_activate_irq(struct irq_data *irq_data);
 extern void irq_domain_deactivate_irq(struct irq_data *irq_data);
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/htirq.c|192| <<arch_setup_ht_irq>> return irq_domain_alloc_irqs(htirq_domain, 1, dev_to_node(&dev->dev),
+ *   - arch/x86/kernel/apic/msi.c|280| <<dmar_alloc_hwirq>> return irq_domain_alloc_irqs(domain, 1, node, &info);
+ *   - arch/x86/kernel/apic/msi.c|400| <<hpet_assign_irq>> return irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, &info);
+ *   - arch/x86/platform/uv/uv_irq.c|204| <<uv_setup_irq>> return irq_domain_alloc_irqs(domain, 1,
+ *   - kernel/irq/irqdomain.c|907| <<irq_create_fwspec_mapping>> virq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec);
+ */
 static inline int irq_domain_alloc_irqs(struct irq_domain *domain,
 			unsigned int nr_irqs, int node, void *arg)
 {
diff --git a/include/linux/msi.h b/include/linux/msi.h
index a89cdea..87152f6 100644
--- a/include/linux/msi.h
+++ b/include/linux/msi.h
@@ -111,6 +111,17 @@ struct msi_desc {
 
 /* Helpers to hide struct msi_desc implementation details */
 #define msi_desc_to_dev(desc)		((desc)->dev)
+/*
+ * 一些调用的地方:
+ *   - drivers/pci/msi.c|344| <<free_msi_irqs>> struct list_head *msi_list = dev_to_msi_list(&dev->dev);
+ *   - drivers/pci/msi.c|418| <<__pci_restore_msix_state>> BUG_ON(list_empty(dev_to_msi_list(&dev->dev)));
+ *   - drivers/pci/msi.c|618| <<msi_capability_init>> list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
+ *   - drivers/pci/msi.c|704| <<msix_setup_entries>> list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
+ *   - drivers/pci/msi.c|889| <<pci_msi_shutdown>> BUG_ON(list_empty(dev_to_msi_list(&dev->dev)));
+ *   - include/linux/msi.h|116| <<first_msi_entry>> list_first_entry(dev_to_msi_list((dev)), struct msi_desc, list)
+ *   - include/linux/msi.h|118| <<for_each_msi_entry>> list_for_each_entry((desc), dev_to_msi_list((dev)), list)
+ *   - include/linux/msi.h|120| <<for_each_msi_entry_safe>> list_for_each_entry_safe((desc), (tmp), dev_to_msi_list((dev)), list)
+ */
 #define dev_to_msi_list(dev)		(&(dev)->msi_list)
 #define first_msi_entry(dev)		\
 	list_first_entry(dev_to_msi_list((dev)), struct msi_desc, list)
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index 317fc75..343e0be 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -157,6 +157,9 @@ int irq_set_chip_data(unsigned int irq, void *data)
 }
 EXPORT_SYMBOL(irq_set_chip_data);
 
+/*
+ * 获得irq的struct irq_desc *desc, 返回desc->irq_data
+ */
 struct irq_data *irq_get_irq_data(unsigned int irq)
 {
 	struct irq_desc *desc = irq_to_desc(irq);
@@ -1246,6 +1249,10 @@ EXPORT_SYMBOL_GPL(irq_chip_disable_parent);
  * irq_chip_ack_parent - Acknowledge the parent interrupt
  * @data:	Pointer to interrupt specific data
  */
+/*
+ * struct irq_chip ioapic_chip.irq_ack = irq_chip_ack_parent()
+ * struct irq_chip ioapic_ir_chip.irq_ack = irq_chip_ack_parent()
+ */
 void irq_chip_ack_parent(struct irq_data *data)
 {
 	data = data->parent_data;
@@ -1330,6 +1337,10 @@ EXPORT_SYMBOL_GPL(irq_chip_set_type_parent);
  * Iterate through the domain hierarchy of the interrupt and check
  * whether a hw retrigger function exists. If yes, invoke it.
  */
+/*
+ * struct irq_chip ioapic_chip.irq_retrigger = irq_chip_retrigger_hierarchy()
+ * struct irq_chip ioapic_ir_chip.irq_retrigger = irq_chip_retrigger_hierarchy()
+ */
 int irq_chip_retrigger_hierarchy(struct irq_data *data)
 {
 	for (data = data->parent_data; data; data = data->parent_data)
diff --git a/kernel/irq/irqdomain.c b/kernel/irq/irqdomain.c
index ac4644e..40a170b 100644
--- a/kernel/irq/irqdomain.c
+++ b/kernel/irq/irqdomain.c
@@ -18,6 +18,14 @@
 #include <linux/smp.h>
 #include <linux/fs.h>
 
+/*
+ * used by:
+ *   - kernel/irq/irqdomain.c|298| <<__irq_domain_add>> list_add(&domain->link, &irq_domain_list);
+ *   - kernel/irq/irqdomain.c|472| <<irq_find_matching_fwspec>> list_for_each_entry(h, &irq_domain_list, link) {
+ *   - kernel/irq/irqdomain.c|505| <<irq_domain_check_msi_remap>> list_for_each_entry(h, &irq_domain_list, link) {
+ *   - kernel/irq/irqdomain.c|1029| <<virq_debug_show>> list_for_each_entry(domain, &irq_domain_list, link) {
+ *   - kernel/irq/irqdomain.c|1961| <<irq_domain_debugfs_init>> list_for_each_entry(d, &irq_domain_list, link)
+ */
 static LIST_HEAD(irq_domain_list);
 static DEFINE_MUTEX(irq_domain_mutex);
 
@@ -125,6 +133,90 @@ EXPORT_SYMBOL_GPL(irq_domain_free_fwnode);
  * Allocates and initialize and irq_domain structure.
  * Returns pointer to IRQ domain, or NULL on failure.
  */
+/*
+ * irq: Added domain VECTOR
+ * [0] __irq_domain_add
+ * [0] arch_early_irq_init
+ * [0] start_kernel
+ * [0] secondary_startup_64
+ *
+ * irq: Added domain PCI-MSI
+ * [0] __irq_domain_add
+ * [0] irq_domain_create_hierarchy
+ * [0] msi_create_irq_domain
+ * [0] pci_msi_create_irq_domain
+ * [0] arch_init_msi_domain
+ * [0] arch_early_irq_init
+ * [0] start_kernel
+ * [0] secondary_startup_64
+ *
+ * irq: Added domain PCI-HT
+ * [0] __irq_domain_add
+ * [0] arch_init_htirq_domain
+ * [0] arch_early_irq_init
+ * [0] start_kernel
+ * [0] secondary_startup_64
+ *
+ * irq: Added domain IO-APIC-0
+ * [0] __irq_domain_add
+ * [0] mp_irqdomain_create
+ * [0] setup_IO_APIC
+ * [0] apic_bsp_setup
+ * [0] native_smp_prepare_cpus
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * irq: Added domain HPET-MSI-0
+ * [0] __irq_domain_add
+ * [0] irq_domain_create_hierarchy
+ * [0] msi_create_irq_domain
+ * [0] hpet_create_irq_domain
+ * [0] hpet_msi_capability_lookup
+ * [0] hpet_late_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * q35有个额外的
+ * irq: Added domain unknown-1
+ * [0] __irq_domain_add
+ * [0] i2c_register_adapter
+ * [0] i2c_add_adapter
+ * [0] i801_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] i2c_i801_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - include/linux/irqdomain.h|313| <<irq_domain_add_linear>> return __irq_domain_add(of_node_to_fwnode(of_node), size, size, 0, ops, host_data);
+ *   - include/linux/irqdomain.h|320| <<irq_domain_add_nomap>> return __irq_domain_add(of_node_to_fwnode(of_node), 0, max_irq, max_irq, ops, host_data);
+ *   - include/linux/irqdomain.h|334| <<irq_domain_add_tree>> return __irq_domain_add(of_node_to_fwnode(of_node), 0, ~0, 0, ops, host_data);
+ *   - include/linux/irqdomain.h|342| <<irq_domain_create_linear>> return __irq_domain_add(fwnode, size, size, 0, ops, host_data);
+ *   - include/linux/irqdomain.h|349| <<irq_domain_create_tree>> return __irq_domain_add(fwnode, 0, ~0, 0, ops, host_data);
+ *   - kernel/irq/irqdomain.c|322| <<irq_domain_add_simple>> domain = __irq_domain_add(of_node_to_fwnode(of_node), size, size, 0, ops, host_data);
+ *   - kernel/irq/irqdomain.c|366| <<irq_domain_add_legacy>> domain = __irq_domain_add(of_node_to_fwnode(of_node), first_hwirq + size,
+ *
+ * 如果是从ioapic进来的:
+ *   ops可以是struct irq_domain_ops mp_ioapic_irqdomain_ops
+ *   size是ioapic的pin的数量
+ *   hwirq_max是ioapic的pin的数量
+ *   direct_max是0
+ *   host_data是ioapic的id
+ *
+ * 核心思想就是初始化一个struct irq_domain, 加入irq_domain_list
+ */
 struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,
 				    irq_hw_number_t hwirq_max, int direct_max,
 				    const struct irq_domain_ops *ops,
@@ -220,6 +312,14 @@ struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,
 
 	mutex_lock(&irq_domain_mutex);
 	debugfs_add_domain_dir(domain);
+	/*
+	 * used by:
+	 *   - kernel/irq/irqdomain.c|298| <<__irq_domain_add>> list_add(&domain->link, &irq_domain_list);
+	 *   - kernel/irq/irqdomain.c|472| <<irq_find_matching_fwspec>> list_for_each_entry(h, &irq_domain_list, link) {
+	 *   - kernel/irq/irqdomain.c|505| <<irq_domain_check_msi_remap>> list_for_each_entry(h, &irq_domain_list, link) {
+	 *   - kernel/irq/irqdomain.c|1029| <<virq_debug_show>> list_for_each_entry(domain, &irq_domain_list, link) {
+	 *   - kernel/irq/irqdomain.c|1961| <<irq_domain_debugfs_init>> list_for_each_entry(d, &irq_domain_list, link)
+	 */
 	list_add(&domain->link, &irq_domain_list);
 	mutex_unlock(&irq_domain_mutex);
 
@@ -1146,6 +1246,10 @@ struct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,
 }
 EXPORT_SYMBOL_GPL(irq_domain_create_hierarchy);
 
+/*
+ * called by:
+ *   - kernel/irq/irqdomain.c|1523| <<__irq_domain_alloc_irqs>> irq_domain_insert_irq(virq + i);
+ */
 static void irq_domain_insert_irq(int virq)
 {
 	struct irq_data *data;
@@ -1252,6 +1356,10 @@ struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,
 {
 	struct irq_data *irq_data;
 
+	/*
+	 * irq_get_irq_data()
+	 * 获得irq的struct irq_desc *desc, 返回desc->irq_data
+	 */
 	for (irq_data = irq_get_irq_data(virq); irq_data;
 	     irq_data = irq_data->parent_data)
 		if (irq_data->domain == domain)
@@ -1367,6 +1475,13 @@ static void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,
 		domain->ops->free(domain, irq_base, nr_irqs);
 }
 
+/*
+ * called by:
+ *   - kernel/irq/irqdomain.c|1445| <<__irq_domain_alloc_irqs>> ret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);
+ *   - kernel/irq/irqdomain.c|1546| <<irq_domain_push_irq>> rv = irq_domain_alloc_irqs_hierarchy(domain, virq, 1, arg);
+ *   - kernel/irq/irqdomain.c|1672| <<irq_domain_alloc_irqs_parent>> return irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,
+ *   - kernel/irq/msi.c|318| <<msi_domain_populate_irqs>> ret = irq_domain_alloc_irqs_hierarchy(domain, desc->irq, 1,
+ */
 int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,
 				    unsigned int irq_base,
 				    unsigned int nr_irqs, void *arg)
@@ -1396,6 +1511,14 @@ int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,
  * resources. In this way, it's easier to rollback when failing to
  * allocate resources.
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|1079| <<alloc_irq_from_domain>> return __irq_domain_alloc_irqs(domain, irq, 1,
+ *   - arch/x86/kernel/apic/io_apic.c|1114| <<alloc_isa_irq_from_domain>> irq = __irq_domain_alloc_irqs(domain, irq, 1, node, info, true,
+ *   - include/linux/irqdomain.h|469| <<irq_domain_alloc_irqs>> return __irq_domain_alloc_irqs(domain, -1, nr_irqs, node, arg, false,
+ *   - kernel/irq/ipi.c|85| <<irq_reserve_ipi>> virq = __irq_domain_alloc_irqs(domain, virq, nr_irqs, NUMA_NO_NODE,
+ *   - kernel/irq/msi.c|376| <<msi_domain_alloc_irqs>> virq = __irq_domain_alloc_irqs(domain, -1, desc->nvec_used,
+ */
 int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
 			    unsigned int nr_irqs, int node, void *arg,
 			    bool realloc, const struct cpumask *affinity)
@@ -1689,6 +1812,11 @@ static void __irq_domain_activate_irq(struct irq_data *irq_data)
 
 		if (irq_data->parent_data)
 			__irq_domain_activate_irq(irq_data->parent_data);
+		/*
+		 * 设置的部分地方:
+		 *   - arch/x86/kernel/apic/io_apic.c|3227| <<global>> .activate = mp_irqdomain_activate,
+		 *   - drivers/iommu/intel_irq_remapping.c|1414| <<global>> .activate = intel_irq_remapping_activate,
+		 */
 		if (domain->ops->activate)
 			domain->ops->activate(domain, irq_data);
 	}
@@ -1767,6 +1895,10 @@ bool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)
 struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,
 					 unsigned int virq)
 {
+	/*
+	 * irq_get_irq_data()
+	 * 获得irq的struct irq_desc *desc, 返回desc->irq_data
+	 */
 	struct irq_data *irq_data = irq_get_irq_data(virq);
 
 	return (irq_data && irq_data->domain == domain) ? irq_data : NULL;
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 6c877d2..84fdca7 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -1142,6 +1142,13 @@ setup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary)
  * interrupt related functions. desc->request_mutex solely serializes
  * request/free_irq().
  */
+/*
+ * called by:
+ *   - kernel/irq/manage.c|1508| <<setup_irq>> retval = __setup_irq(irq, desc, act);
+ *   - kernel/irq/manage.c|1795| <<request_threaded_irq>> retval = __setup_irq(irq, desc, action);
+ *   - kernel/irq/manage.c|2043| <<setup_percpu_irq>> retval = __setup_irq(irq, desc, act);
+ *   - kernel/irq/manage.c|2102| <<__request_percpu_irq>> retval = __setup_irq(irq, desc, action);
+ */
 static int
 __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 {
diff --git a/kernel/irq/msi.c b/kernel/irq/msi.c
index 3fa4bd5..693acd3 100644
--- a/kernel/irq/msi.c
+++ b/kernel/irq/msi.c
@@ -100,6 +100,9 @@ int msi_domain_set_affinity(struct irq_data *irq_data,
 	return ret;
 }
 
+/*
+ * struct irq_domain_ops msi_domain_ops.activate = msi_domain_activate()
+ */
 static void msi_domain_activate(struct irq_domain *domain,
 				struct irq_data *irq_data)
 {
@@ -109,6 +112,9 @@ static void msi_domain_activate(struct irq_domain *domain,
 	irq_chip_write_msi_msg(irq_data, &msg);
 }
 
+/*
+ * struct irq_domain_ops msi_domain_ops.deactivate = msi_domain_deactivate()
+ */
 static void msi_domain_deactivate(struct irq_domain *domain,
 				  struct irq_data *irq_data)
 {
@@ -118,6 +124,9 @@ static void msi_domain_deactivate(struct irq_domain *domain,
 	irq_chip_write_msi_msg(irq_data, &msg);
 }
 
+/*
+ * struct irq_domain_ops msi_domain_ops.alloc = msi_domain_alloc()
+ */
 static int msi_domain_alloc(struct irq_domain *domain, unsigned int virq,
 			    unsigned int nr_irqs, void *arg)
 {
@@ -136,6 +145,14 @@ static int msi_domain_alloc(struct irq_domain *domain, unsigned int virq,
 	}
 
 	for (i = 0; i < nr_irqs; i++) {
+		/*
+		 * info的例子是pci_msi_domain_info
+		 *
+		 * 这里的ops是struct msi_domain_ops
+		 *
+		 * 一个例子就是msi_domain_ops_default?
+		 * msi_domain_ops_init()
+		 */
 		ret = ops->msi_init(domain, info, virq + i, hwirq + i, arg);
 		if (ret < 0) {
 			if (ops->msi_free) {
@@ -150,6 +167,9 @@ static int msi_domain_alloc(struct irq_domain *domain, unsigned int virq,
 	return 0;
 }
 
+/*
+ * struct irq_domain_ops msi_domain_ops.free = msi_domain_free()
+ */
 static void msi_domain_free(struct irq_domain *domain, unsigned int virq,
 			    unsigned int nr_irqs)
 {
@@ -200,6 +220,9 @@ static int msi_domain_ops_init(struct irq_domain *domain,
 			       unsigned int virq, irq_hw_number_t hwirq,
 			       msi_alloc_info_t *arg)
 {
+	/*
+	 * info的例子是pci_msi_domain_info
+	 */
 	irq_domain_set_hwirq_and_chip(domain, virq, hwirq, info->chip,
 				      info->chip_data);
 	if (info->handler && info->handler_name) {
@@ -217,6 +240,15 @@ static int msi_domain_ops_check(struct irq_domain *domain,
 	return 0;
 }
 
+/*
+ * used by:
+ *   - kernel/irq/msi.c|250| <<msi_domain_update_dom_ops>> info->ops = &msi_domain_ops_default;
+ *   - kernel/irq/msi.c|255| <<msi_domain_update_dom_ops>> ops->get_hwirq = msi_domain_ops_default.get_hwirq;
+ *   - kernel/irq/msi.c|257| <<msi_domain_update_dom_ops>> ops->msi_init = msi_domain_ops_default.msi_init;
+ *   - kernel/irq/msi.c|259| <<msi_domain_update_dom_ops>> ops->msi_check = msi_domain_ops_default.msi_check;
+ *   - kernel/irq/msi.c|261| <<msi_domain_update_dom_ops>> ops->msi_prepare = msi_domain_ops_default.msi_prepare;
+ *   - kernel/irq/msi.c|263| <<msi_domain_update_dom_ops>> ops->set_desc = msi_domain_ops_default.set_desc;
+ */
 static struct msi_domain_ops msi_domain_ops_default = {
 	.get_hwirq	= msi_domain_ops_get_hwirq,
 	.msi_init	= msi_domain_ops_init,
@@ -225,6 +257,10 @@ static struct msi_domain_ops msi_domain_ops_default = {
 	.set_desc	= msi_domain_ops_set_desc,
 };
 
+/*
+ * called by:
+ *   - kernel/irq/msi.c|288| <<msi_create_irq_domain>> msi_domain_update_dom_ops(info);
+ */
 static void msi_domain_update_dom_ops(struct msi_domain_info *info)
 {
 	struct msi_domain_ops *ops = info->ops;
@@ -345,9 +381,55 @@ int msi_domain_populate_irqs(struct irq_domain *domain, struct device *dev,
  *
  * Returns 0 on success or an error code.
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/msi.c|95| <<native_setup_msi_irqs>> return msi_domain_alloc_irqs(domain, &dev->dev, nvec);
+ *   - drivers/base/platform-msi.c|273| <<platform_msi_domain_alloc_irqs>> err = msi_domain_alloc_irqs(dev->msi_domain, dev, nvec);
+ *   - drivers/pci/msi.c|41| <<pci_msi_setup_msi_irqs>> return msi_domain_alloc_irqs(domain, &dev->dev, nvec);
+ */
 int msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,
 			  int nvec)
 {
+	/*
+	 * msi的struct irq_domain_ops的例子
+	 *
+	 * kernel/irq/msi.c
+	 *
+	 * 166 static const struct irq_domain_ops msi_domain_ops = {
+	 * 167         .alloc          = msi_domain_alloc,
+	 * 168         .free           = msi_domain_free,
+	 * 169         .activate       = msi_domain_activate,
+	 * 170         .deactivate     = msi_domain_deactivate,
+	 * 171 };
+	 *
+	 *
+	 * info的例子:
+	 * struct msi_domain_info pci_msi_domain_info
+	 *
+	 * 148 static struct msi_domain_info pci_msi_domain_info = {
+	 * 149         .flags          = MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
+	 * 150                           MSI_FLAG_PCI_MSIX,
+	 * 151         .ops            = &pci_msi_domain_ops,
+	 * 152         .chip           = &pci_msi_controller,
+	 * 153         .handler        = handle_edge_irq,
+	 * 154         .handler_name   = "edge",
+	 * 155 };
+	 *
+	 *
+	 * struct msi_domain_ops的例子:
+	 *
+	 * 138 static struct msi_domain_ops pci_msi_domain_ops = {
+	 * 139         .get_hwirq      = pci_msi_get_hwirq,
+	 * 140         .msi_prepare    = pci_msi_prepare,
+	 * 141         .set_desc       = pci_msi_set_desc,
+	 * 142 };
+	 *
+	 * 1390 static struct msi_domain_ops pci_msi_domain_ops_default = {
+	 * 1391         .set_desc       = pci_msi_domain_set_desc,
+	 * 1392         .msi_check      = pci_msi_domain_check_cap,
+	 * 1393         .handle_error   = pci_msi_domain_handle_error,
+	 * 1394 };
+	 */
 	struct msi_domain_info *info = domain->host_data;
 	struct msi_domain_ops *ops = info->ops;
 	msi_alloc_info_t arg;
diff --git a/kernel/irq_work.c b/kernel/irq_work.c
index bcf107c..627f328 100644
--- a/kernel/irq_work.c
+++ b/kernel/irq_work.c
@@ -166,6 +166,12 @@ static void irq_work_run_list(struct llist_head *list)
  * hotplug calls this through:
  *  hotplug_cfd() -> flush_smp_call_function_queue()
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/irq_work.c|21| <<smp_irq_work_interrupt>> irq_work_run();
+ *   - arch/x86/xen/smp_pv.c|476| <<xen_irq_work_interrupt>> irq_work_run();
+ *   - kernel/smp.c|257| <<flush_smp_call_function_queue>> irq_work_run();
+ */
 void irq_work_run(void)
 {
 	irq_work_run_list(this_cpu_ptr(&raised_list));
diff --git a/kernel/kexec_core.c b/kernel/kexec_core.c
index 20fef1a..82bf1f1 100644
--- a/kernel/kexec_core.c
+++ b/kernel/kexec_core.c
@@ -924,6 +924,12 @@ int kexec_load_disabled;
  * only when panic_cpu holds the current CPU number; this is the only CPU
  * which processes crash_kexec routines.
  */
+/*
+ * called by:
+ *   - kernel/kexec_core.c|965| <<crash_kexec>> __crash_kexec(regs);
+ *   - kernel/panic.c|195| <<panic>> __crash_kexec(NULL);
+ *   - kernel/panic.c|232| <<panic>> __crash_kexec(NULL);
+ */
 void __noclone __crash_kexec(struct pt_regs *regs)
 {
 	/* Take the kexec_mutex here to prevent sys_kexec_load
@@ -948,6 +954,11 @@ void __noclone __crash_kexec(struct pt_regs *regs)
 }
 STACK_FRAME_NON_STANDARD(__crash_kexec);
 
+/*
+ * x86下的调用:
+ *   - arch/x86/kernel/dumpstack.c|279| <<oops_end>> crash_kexec(regs);
+ *   - arch/x86/platform/uv/uv_nmi.c|816| <<uv_nmi_kdump>> crash_kexec(regs);
+ */
 void crash_kexec(struct pt_regs *regs)
 {
 	int old_cpu, this_cpu;
@@ -958,6 +969,16 @@ void crash_kexec(struct pt_regs *regs)
 	 * may stop each other.  To exclude them, we use panic_cpu here too.
 	 */
 	this_cpu = raw_smp_processor_id();
+	/*
+	 * panic_cpu在以下被使用:
+	 *   - kernel/kexec_core.c|972| <<crash_kexec>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+	 *   - kernel/kexec_core.c|982| <<crash_kexec>> atomic_set(&panic_cpu, PANIC_CPU_INVALID);
+	 *   - kernel/panic.c|116| <<nmi_panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, cpu);
+	 *   - kernel/panic.c|166| <<panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+	 *
+	 * cmpxchg(ptr, old, new)
+	 * 将old和ptr指向的内容比较,如果相等,则将new写入到ptr中,返回old,如果不相等,则返回ptr指向的内容.
+	 */
 	old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
 	if (old_cpu == PANIC_CPU_INVALID) {
 		/* This is the 1st CPU which comes here, so go ahead. */
diff --git a/kernel/panic.c b/kernel/panic.c
index 32ff6fd..63b042d 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -100,6 +100,13 @@ void __weak crash_smp_send_stop(void)
 	cpus_stopped = 1;
 }
 
+/*
+ * used by:
+ *   - kernel/kexec_core.c|972| <<crash_kexec>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+ *   - kernel/kexec_core.c|982| <<crash_kexec>> atomic_set(&panic_cpu, PANIC_CPU_INVALID);
+ *   - kernel/panic.c|116| <<nmi_panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, cpu);
+ *   - kernel/panic.c|166| <<panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+ */
 atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);
 
 /*
diff --git a/kernel/time/tick-common.c b/kernel/time/tick-common.c
index 49edc1c..3ac3df4 100644
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@ -174,6 +174,11 @@ void tick_setup_periodic(struct clock_event_device *dev, int broadcast)
 /*
  * Setup the tick device
  */
+/*
+ * called by:
+ *   - kernel/time/tick-common.c|242| <<tick_install_replacement>> tick_setup_device(td, newdev, cpu, cpumask_of(cpu));
+ *   - kernel/time/tick-common.c|331| <<tick_check_new_device>> tick_setup_device(td, newdev, cpu, cpumask_of(cpu));
+ */
 static void tick_setup_device(struct tick_device *td,
 			      struct clock_event_device *newdev, int cpu,
 			      const struct cpumask *cpumask)
diff --git a/kernel/time/tick-oneshot.c b/kernel/time/tick-oneshot.c
index 6b009c2..252dca2 100644
--- a/kernel/time/tick-oneshot.c
+++ b/kernel/time/tick-oneshot.c
@@ -61,6 +61,10 @@ void tick_resume_oneshot(void)
 /**
  * tick_setup_oneshot - setup the event device for oneshot mode (hres or nohz)
  */
+/*
+ * called by only:
+ *   - kernel/time/tick-common.c|233| <<tick_setup_device>> tick_setup_oneshot(newdev, handler, next_event);
+ */
 void tick_setup_oneshot(struct clock_event_device *newdev,
 			void (*handler)(struct clock_event_device *),
 			ktime_t next_event)
@@ -73,6 +77,11 @@ void tick_setup_oneshot(struct clock_event_device *newdev,
 /**
  * tick_switch_to_oneshot - switch to oneshot mode
  */
+/*
+ * called by:
+ *   - kernel/time/tick-oneshot.c|130| <<tick_init_highres>> return tick_switch_to_oneshot(hrtimer_interrupt);
+ *   - kernel/time/tick-sched.c|1149| <<tick_nohz_switch_to_nohz>> if (tick_switch_to_oneshot(tick_nohz_handler))
+ */
 int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))
 {
 	struct tick_device *td = this_cpu_ptr(&tick_cpu_device);
-- 
2.7.4

