From 900079c17e2793cf5d93b685b4fd02e3677d3fdc Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Thu, 9 May 2019 01:39:32 +0800
Subject: [PATCH 1/1] linux-apic-for-4.14.113

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/kernel/apic/io_apic.c  | 32 ++++++++++++++++++++++++++++++++
 arch/x86/kernel/apic/probe_64.c | 13 +++++++++++++
 arch/x86/kernel/dumpstack.c     |  6 ++++++
 arch/x86/kernel/i8259.c         |  7 +++++++
 arch/x86/kernel/time.c          | 19 +++++++++++++++++++
 kernel/irq/chip.c               |  3 +++
 kernel/kexec_core.c             | 21 +++++++++++++++++++++
 kernel/panic.c                  |  7 +++++++
 kernel/time/tick-common.c       |  5 +++++
 kernel/time/tick-oneshot.c      |  9 +++++++++
 10 files changed, 122 insertions(+)

diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c
index 96a8a68..67e3937 100644
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@ -1597,6 +1597,10 @@ __setup("no_timer_check", notimercheck);
  */
 static int __init timer_irq_works(void)
 {
+	/*
+	 * jiffies和jiffies_64是一样的, 定义在
+	 * arch/x86/kernel/vmlinux.lds.S
+	 */
 	unsigned long t1 = jiffies;
 	unsigned long flags;
 
@@ -2029,6 +2033,9 @@ static int mp_alloc_timer_irq(int ioapic, int pin)
  */
 static inline void __init check_timer(void)
 {
+	/*
+	 * 获得irq 0的struct irq_desc *desc, 返回desc->irq_data
+	 */
 	struct irq_data *irq_data = irq_get_irq_data(0);
 	struct mp_chip_data *data = irq_data->chip_data;
 	struct irq_cfg *cfg = irqd_cfg(irq_data);
@@ -2042,6 +2049,13 @@ static inline void __init check_timer(void)
 	/*
 	 * get/set the timer IRQ vector:
 	 */
+	/*
+	 * legacy_pic可以是:
+	 *   - default_legacy_pic
+	 *   - null_legacy_pic
+	 *
+	 * 这里的参数0是irq
+	 */
 	legacy_pic->mask(0);
 
 	/*
@@ -2061,6 +2075,13 @@ static inline void __init check_timer(void)
 	pin2  = ioapic_i8259.pin;
 	apic2 = ioapic_i8259.apic;
 
+	/*
+	 * 在测试xen domU中boot和kdump的例子都是:
+	 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=0 pin2=0
+	 *
+	 * 在8-thread的dell测试机kvm的VM里:
+	 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=-1 pin2=-1
+	 */
 	apic_printk(APIC_QUIET, KERN_INFO "..TIMER: vector=0x%02X "
 		    "apic1=%d pin1=%d apic2=%d pin2=%d\n",
 		    cfg->vector, apic1, pin1, apic2, pin2);
@@ -2072,6 +2093,14 @@ static inline void __init check_timer(void)
 	 * was found above, try it both directly and through the
 	 * 8259A.
 	 */
+	/*
+	 * 在测试xen domU中boot和kdump的例子都是:
+	 *
+	 * pin1 = 2
+	 * pin2 = 0
+	 *
+	 * 所以下面的no_pin1应该是0
+	 */
 	if (pin1 == -1) {
 		panic_if_irq_remap("BIOS bug: timer not connected to IO-APIC");
 		pin1 = pin2;
@@ -2088,6 +2117,9 @@ static inline void __init check_timer(void)
 			mp_alloc_timer_irq(apic1, pin1);
 		} else {
 			/*
+			 * 目前测试的kvm和xen都是执行这里
+			 */
+			/*
 			 * for edge trigger, it's already unmasked,
 			 * so only need to unmask if it is level-trigger
 			 * do we really have level trigger timer?
diff --git a/arch/x86/kernel/apic/probe_64.c b/arch/x86/kernel/apic/probe_64.c
index c303054..e714f47 100644
--- a/arch/x86/kernel/apic/probe_64.c
+++ b/arch/x86/kernel/apic/probe_64.c
@@ -25,6 +25,14 @@
 /*
  * Check the APIC IDs in bios_cpu_apicid and choose the APIC mode.
  */
+/*
+ * [0] default_setup_apic_routing
+ * [0] native_smp_prepare_cpus
+ * [0] xen_hvm_smp_prepare_cpus
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ */
 void __init default_setup_apic_routing(void)
 {
 	struct apic **drv;
@@ -32,6 +40,11 @@ void __init default_setup_apic_routing(void)
 	enable_IR_x2apic();
 
 	for (drv = __apicdrivers; drv < __apicdrivers_end; drv++) {
+		/*
+		 * apic=flat, drv=Xen PV
+		 * apic=flat, drv=physical flat
+		 * apic=flat, drv=flat
+		 */
 		if ((*drv)->probe && (*drv)->probe()) {
 			if (apic != *drv) {
 				apic = *drv;
diff --git a/arch/x86/kernel/dumpstack.c b/arch/x86/kernel/dumpstack.c
index 224de37..aa6fef2 100644
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@ -273,6 +273,12 @@ NOKPROBE_SYMBOL(oops_begin);
 
 void __noreturn rewind_stack_do_exit(int signr);
 
+/*
+ * called by:
+ *   - arch/x86/kernel/dumpstack.c|360| <<die>> oops_end(flags, regs, sig);
+ *   - arch/x86/mm/fault.c|733| <<pgtable_bad>> oops_end(flags, regs, sig);
+ *   - arch/x86/mm/fault.c|846| <<no_context>> oops_end(flags, regs, sig);
+ */
 void oops_end(unsigned long flags, struct pt_regs *regs, int signr)
 {
 	if (regs && kexec_should_crash(current))
diff --git a/arch/x86/kernel/i8259.c b/arch/x86/kernel/i8259.c
index 02abc13..03589ff 100644
--- a/arch/x86/kernel/i8259.c
+++ b/arch/x86/kernel/i8259.c
@@ -419,6 +419,13 @@ struct legacy_pic default_legacy_pic = {
 	.make_irq = make_8259A_irq,
 };
 
+/*
+ * used by:
+ *   - arch/x86/kernel/i8259.c|422| <<global>> struct legacy_pic *legacy_pic = &default_legacy_pic;
+ *   - arch/x86/kernel/acpi/boot.c|1387| <<acpi_reduced_hw_init>> legacy_pic = &null_legacy_pic;
+ *   - arch/x86/kernel/i8259.c|319| <<probe_8259A>> legacy_pic = &null_legacy_pic;
+ *   - arch/x86/platform/intel-mid/intel-mid.c|200| <<x86_intel_mid_early_setup>> legacy_pic = &null_legacy_pic;
+ */
 struct legacy_pic *legacy_pic = &default_legacy_pic;
 EXPORT_SYMBOL(legacy_pic);
 
diff --git a/arch/x86/kernel/time.c b/arch/x86/kernel/time.c
index ab0176a..84f3660 100644
--- a/arch/x86/kernel/time.c
+++ b/arch/x86/kernel/time.c
@@ -56,8 +56,27 @@ EXPORT_SYMBOL(profile_pc);
 /*
  * Default timer interrupt handler for PIT/HPET
  */
+/*
+ * tick_do_timer_cpu更新timer
+ */
 static irqreturn_t timer_interrupt(int irq, void *dev_id)
 {
+	/*
+	 * event_handler在以下设置:
+	 *   - arch/x86/kernel/apic/apic.c|845| <<calibrate_APIC_clock>> global_clock_event->event_handler = lapic_cal_handler;
+	 *   - arch/x86/kernel/apic/apic.c|862| <<calibrate_APIC_clock>> global_clock_event->event_handler = real_handler;
+	 *   - arch/x86/kernel/apic/apic.c|924| <<calibrate_APIC_clock>> levt->event_handler = lapic_cal_handler;
+	 *   - kernel/time/tick-broadcast.c|104| <<tick_install_broadcast_device>> cur->event_handler = clockevents_handle_noop;
+	 *   - kernel/time/tick-broadcast.c|176| <<tick_device_uses_broadcast>> dev->event_handler = tick_handle_periodic;
+	 *   - kernel/time/tick-broadcast.c|435| <<tick_set_periodic_handler>> dev->event_handler = tick_handle_periodic;
+	 *   - kernel/time/tick-broadcast.c|437| <<tick_set_periodic_handler>> dev->event_handler = tick_handle_periodic_broadcast;
+	 *   - kernel/time/tick-broadcast.c|891| <<tick_broadcast_setup_oneshot>> bc->event_handler = tick_handle_oneshot_broadcast;
+	 *   - kernel/time/tick-common.c|208| <<tick_setup_device>> td->evtdev->event_handler = clockevents_handle_noop;
+	 *   - kernel/time/tick-common.c|402| <<tick_shutdown>> dev->event_handler = clockevents_handle_noop;
+	 *   - kernel/time/tick-internal.h|91| <<tick_set_periodic_handler>> dev->event_handler = tick_handle_periodic;
+	 *   - kernel/time/tick-oneshot.c|68| <<tick_setup_oneshot>> newdev->event_handler = handler;
+	 *   - kernel/time/tick-oneshot.c|99| <<tick_switch_to_oneshot>> dev->event_handler = handler;
+	 */
 	global_clock_event->event_handler(global_clock_event);
 	return IRQ_HANDLED;
 }
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index 317fc75..76f1650 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -157,6 +157,9 @@ int irq_set_chip_data(unsigned int irq, void *data)
 }
 EXPORT_SYMBOL(irq_set_chip_data);
 
+/*
+ * 获得irq的struct irq_desc *desc, 返回desc->irq_data
+ */
 struct irq_data *irq_get_irq_data(unsigned int irq)
 {
 	struct irq_desc *desc = irq_to_desc(irq);
diff --git a/kernel/kexec_core.c b/kernel/kexec_core.c
index 20fef1a..82bf1f1 100644
--- a/kernel/kexec_core.c
+++ b/kernel/kexec_core.c
@@ -924,6 +924,12 @@ int kexec_load_disabled;
  * only when panic_cpu holds the current CPU number; this is the only CPU
  * which processes crash_kexec routines.
  */
+/*
+ * called by:
+ *   - kernel/kexec_core.c|965| <<crash_kexec>> __crash_kexec(regs);
+ *   - kernel/panic.c|195| <<panic>> __crash_kexec(NULL);
+ *   - kernel/panic.c|232| <<panic>> __crash_kexec(NULL);
+ */
 void __noclone __crash_kexec(struct pt_regs *regs)
 {
 	/* Take the kexec_mutex here to prevent sys_kexec_load
@@ -948,6 +954,11 @@ void __noclone __crash_kexec(struct pt_regs *regs)
 }
 STACK_FRAME_NON_STANDARD(__crash_kexec);
 
+/*
+ * x86下的调用:
+ *   - arch/x86/kernel/dumpstack.c|279| <<oops_end>> crash_kexec(regs);
+ *   - arch/x86/platform/uv/uv_nmi.c|816| <<uv_nmi_kdump>> crash_kexec(regs);
+ */
 void crash_kexec(struct pt_regs *regs)
 {
 	int old_cpu, this_cpu;
@@ -958,6 +969,16 @@ void crash_kexec(struct pt_regs *regs)
 	 * may stop each other.  To exclude them, we use panic_cpu here too.
 	 */
 	this_cpu = raw_smp_processor_id();
+	/*
+	 * panic_cpu在以下被使用:
+	 *   - kernel/kexec_core.c|972| <<crash_kexec>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+	 *   - kernel/kexec_core.c|982| <<crash_kexec>> atomic_set(&panic_cpu, PANIC_CPU_INVALID);
+	 *   - kernel/panic.c|116| <<nmi_panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, cpu);
+	 *   - kernel/panic.c|166| <<panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+	 *
+	 * cmpxchg(ptr, old, new)
+	 * 将old和ptr指向的内容比较,如果相等,则将new写入到ptr中,返回old,如果不相等,则返回ptr指向的内容.
+	 */
 	old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
 	if (old_cpu == PANIC_CPU_INVALID) {
 		/* This is the 1st CPU which comes here, so go ahead. */
diff --git a/kernel/panic.c b/kernel/panic.c
index 32ff6fd..63b042d 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -100,6 +100,13 @@ void __weak crash_smp_send_stop(void)
 	cpus_stopped = 1;
 }
 
+/*
+ * used by:
+ *   - kernel/kexec_core.c|972| <<crash_kexec>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+ *   - kernel/kexec_core.c|982| <<crash_kexec>> atomic_set(&panic_cpu, PANIC_CPU_INVALID);
+ *   - kernel/panic.c|116| <<nmi_panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, cpu);
+ *   - kernel/panic.c|166| <<panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+ */
 atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);
 
 /*
diff --git a/kernel/time/tick-common.c b/kernel/time/tick-common.c
index 49edc1c..3ac3df4 100644
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@ -174,6 +174,11 @@ void tick_setup_periodic(struct clock_event_device *dev, int broadcast)
 /*
  * Setup the tick device
  */
+/*
+ * called by:
+ *   - kernel/time/tick-common.c|242| <<tick_install_replacement>> tick_setup_device(td, newdev, cpu, cpumask_of(cpu));
+ *   - kernel/time/tick-common.c|331| <<tick_check_new_device>> tick_setup_device(td, newdev, cpu, cpumask_of(cpu));
+ */
 static void tick_setup_device(struct tick_device *td,
 			      struct clock_event_device *newdev, int cpu,
 			      const struct cpumask *cpumask)
diff --git a/kernel/time/tick-oneshot.c b/kernel/time/tick-oneshot.c
index 6b009c2..252dca2 100644
--- a/kernel/time/tick-oneshot.c
+++ b/kernel/time/tick-oneshot.c
@@ -61,6 +61,10 @@ void tick_resume_oneshot(void)
 /**
  * tick_setup_oneshot - setup the event device for oneshot mode (hres or nohz)
  */
+/*
+ * called by only:
+ *   - kernel/time/tick-common.c|233| <<tick_setup_device>> tick_setup_oneshot(newdev, handler, next_event);
+ */
 void tick_setup_oneshot(struct clock_event_device *newdev,
 			void (*handler)(struct clock_event_device *),
 			ktime_t next_event)
@@ -73,6 +77,11 @@ void tick_setup_oneshot(struct clock_event_device *newdev,
 /**
  * tick_switch_to_oneshot - switch to oneshot mode
  */
+/*
+ * called by:
+ *   - kernel/time/tick-oneshot.c|130| <<tick_init_highres>> return tick_switch_to_oneshot(hrtimer_interrupt);
+ *   - kernel/time/tick-sched.c|1149| <<tick_nohz_switch_to_nohz>> if (tick_switch_to_oneshot(tick_nohz_handler))
+ */
 int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))
 {
 	struct tick_device *td = this_cpu_ptr(&tick_cpu_device);
-- 
2.7.4

