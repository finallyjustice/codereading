From 18ab05e735c97e60ae029e011b825eb135cf2a26 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Fri, 23 Aug 2019 02:10:54 +0800
Subject: [PATCH 1/1] linux-apic-for-4.14.113

Signed-off-by: Dongli Zhang <dongli.zhangi0129@gmail.com>
---
 arch/x86/include/asm/apic.h           |   6 +
 arch/x86/include/asm/hw_irq.h         |   4 +
 arch/x86/include/asm/i8259.h          |  31 +++
 arch/x86/include/asm/io_apic.h        |  10 +
 arch/x86/include/asm/irq_vectors.h    |   7 +
 arch/x86/kernel/apic/apic.c           |  41 +++
 arch/x86/kernel/apic/apic_flat_64.c   |   8 +
 arch/x86/kernel/apic/apic_noop.c      |   6 +
 arch/x86/kernel/apic/apic_numachip.c  |   8 +
 arch/x86/kernel/apic/bigsmp_32.c      |   6 +
 arch/x86/kernel/apic/htirq.c          |  33 +++
 arch/x86/kernel/apic/io_apic.c        | 498 ++++++++++++++++++++++++++++++++++
 arch/x86/kernel/apic/msi.c            | 198 ++++++++++++++
 arch/x86/kernel/apic/probe_32.c       |   6 +
 arch/x86/kernel/apic/probe_64.c       |  26 ++
 arch/x86/kernel/apic/vector.c         | 464 +++++++++++++++++++++++++++++++
 arch/x86/kernel/apic/x2apic_cluster.c |  82 ++++++
 arch/x86/kernel/apic/x2apic_phys.c    |   6 +
 arch/x86/kernel/apic/x2apic_uv_x.c    |   6 +
 arch/x86/kernel/dumpstack.c           |   6 +
 arch/x86/kernel/hpet.c                |   9 +
 arch/x86/kernel/i8259.c               | 221 +++++++++++++++
 arch/x86/kernel/irq.c                 |  67 +++++
 arch/x86/kernel/irqinit.c             |  27 ++
 arch/x86/kernel/time.c                |  28 ++
 arch/x86/kernel/traps.c               |  13 +
 arch/x86/kernel/x86_init.c            |  15 +
 drivers/clocksource/i8253.c           |   4 +
 drivers/nvme/host/pci.c               |  37 +++
 drivers/pci/msi.c                     | 142 ++++++++++
 include/linux/device.h                |  18 ++
 include/linux/irq.h                   |  30 ++
 include/linux/irqdomain.h             |  40 +++
 include/linux/msi.h                   |  14 +
 include/linux/pci.h                   |   6 +
 kernel/cpu.c                          |   4 +
 kernel/irq/chip.c                     |  24 ++
 kernel/irq/cpuhotplug.c               |  31 +++
 kernel/irq/irqdesc.c                  |  30 ++
 kernel/irq/irqdomain.c                | 183 +++++++++++++
 kernel/irq/manage.c                   |  11 +
 kernel/irq/msi.c                      | 106 ++++++++
 kernel/irq/proc.c                     |  24 ++
 kernel/irq_work.c                     |   6 +
 kernel/kexec_core.c                   |  21 ++
 kernel/panic.c                        |   7 +
 kernel/smpboot.c                      |   1 +
 kernel/time/tick-common.c             |   5 +
 kernel/time/tick-oneshot.c            |   9 +
 49 files changed, 2585 insertions(+)

diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h
index a1ed92a..19be1b8 100644
--- a/arch/x86/include/asm/apic.h
+++ b/arch/x86/include/asm/apic.h
@@ -243,6 +243,12 @@ static inline int x2apic_enabled(void)
 	return boot_cpu_has(X86_FEATURE_X2APIC) && apic_is_x2apic_enabled();
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/apic.c|1740| <<enable_IR_x2apic>> if (ir_stat < 0 && !x2apic_supported())
+ *   - drivers/iommu/intel_irq_remapping.c|675| <<intel_cleanup_irq_remapping>> if (x2apic_supported())
+ *   - drivers/iommu/intel_irq_remapping.c|712| <<intel_prepare_irq_remapping>> if (x2apic_supported()) {
+ */
 #define x2apic_supported()	(boot_cpu_has(X86_FEATURE_X2APIC))
 #else /* !CONFIG_X86_X2APIC */
 static inline void check_x2apic(void) { }
diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h
index bf253ad..ef9c894 100644
--- a/arch/x86/include/asm/hw_irq.h
+++ b/arch/x86/include/asm/hw_irq.h
@@ -123,6 +123,10 @@ struct irq_alloc_info {
 };
 
 struct irq_cfg {
+	/*
+	 * 在这里修改dest_apicid:
+	 *   - arch/x86/kernel/apic/vector.c|542| <<__assign_irq_vector>> &d->cfg.dest_apicid));
+	 */
 	unsigned int		dest_apicid;
 	u8			vector;
 	u8			old_vector;
diff --git a/arch/x86/include/asm/i8259.h b/arch/x86/include/asm/i8259.h
index 89789e8..909be79 100644
--- a/arch/x86/include/asm/i8259.h
+++ b/arch/x86/include/asm/i8259.h
@@ -8,7 +8,23 @@
 extern unsigned int cached_irq_mask;
 
 #define __byte(x, y)		(((unsigned char *)&(y))[x])
+/*
+ * 只使用, 不修改:
+ *   - arch/x86/kernel/i8259.c|113| <<mask_8259A_irq>> outb(cached_master_mask, PIC_MASTER_IMR);
+ *   - arch/x86/kernel/i8259.c|147| <<unmask_8259A_irq>> outb(cached_master_mask, PIC_MASTER_IMR);
+ *   - arch/x86/kernel/i8259.c|288| <<mask_and_ack_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+ *   - arch/x86/kernel/i8259.c|413| <<unmask_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+ *   - arch/x86/kernel/i8259.c|528| <<init_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+ */
 #define cached_master_mask	(__byte(0, cached_irq_mask))
+/*
+ * 只使用, 不修改:
+ *   - arch/x86/kernel/i8259.c|111| <<mask_8259A_irq>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+ *   - arch/x86/kernel/i8259.c|145| <<unmask_8259A_irq>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+ *   - arch/x86/kernel/i8259.c|281| <<mask_and_ack_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+ *   - arch/x86/kernel/i8259.c|414| <<unmask_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+ *   - arch/x86/kernel/i8259.c|529| <<init_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+ */
 #define cached_slave_mask	(__byte(1, cached_irq_mask))
 
 /* i8259A PIC registers */
@@ -61,9 +77,20 @@ struct legacy_pic {
 	void (*unmask)(unsigned int irq);
 	void (*mask_all)(void);
 	void (*restore_mask)(void);
+	/*
+	 * called by:
+	 *   - arch/x86/kernel/apic/io_apic.c|2166| <<check_timer>> legacy_pic->init(1);
+	 *   - arch/x86/kernel/apic/io_apic.c|2315| <<check_timer>> legacy_pic->init(0);
+	 *   - arch/x86/kernel/irqinit.c|68| <<init_ISA_irqs>> legacy_pic->init(0);
+	 */
 	void (*init)(int auto_eoi);
 	int (*probe)(void);
 	int (*irq_pending)(unsigned int irq);
+	/*
+	 * calld by:
+	 *   - arch/x86/kernel/apic/io_apic.c|1977| <<init_IO_APIC_traps>> legacy_pic->make_irq(irq);
+	 *   - arch/x86/kernel/apic/io_apic.c|2316| <<check_timer>> legacy_pic->make_irq(0);
+	 */
 	void (*make_irq)(unsigned int irq);
 };
 
@@ -75,6 +102,10 @@ static inline bool has_legacy_pic(void)
 	return legacy_pic != &null_legacy_pic;
 }
 
+/*
+ * 在default_legacy_pic返回NR_IRQS_LEGACY(16)
+ * 在null_legacy_pic返回0
+ */
 static inline int nr_legacy_irqs(void)
 {
 	return legacy_pic->nr_legacy_irqs;
diff --git a/arch/x86/include/asm/io_apic.h b/arch/x86/include/asm/io_apic.h
index 5c27e14..ad0a20d 100644
--- a/arch/x86/include/asm/io_apic.h
+++ b/arch/x86/include/asm/io_apic.h
@@ -150,6 +150,16 @@ extern unsigned long io_apic_irqs;
  * If we use the IO-APIC for IRQ routing, disable automatic
  * assignment of PCI IRQ's.
  */
+/*
+ * used by:
+ *   - arch/x86/pci/irq.c|898| <<pcibios_lookup_irq>> if (io_apic_assign_pci_irqs)
+ *   - arch/x86/pci/irq.c|1051| <<pcibios_fixup_irqs>> if (io_apic_assign_pci_irqs)
+ *   - arch/x86/pci/irq.c|1147| <<pcibios_irq_init>> if (io_apic_assign_pci_irqs)
+ *   - arch/x86/pci/irq.c|1153| <<pcibios_irq_init>> if (io_apic_assign_pci_irqs && pci_routeirq) {
+ *   - arch/x86/pci/irq.c|1198| <<pirq_enable_irq>> if (!io_apic_assign_pci_irqs && dev->irq)
+ *   - arch/x86/pci/irq.c|1201| <<pirq_enable_irq>> if (io_apic_assign_pci_irqs) {
+ *   - arch/x86/pci/irq.c|1275| <<pirq_disable_irq>> if (io_apic_assign_pci_irqs && !mp_should_keep_irq(&dev->dev) &&
+ */
 #define io_apic_assign_pci_irqs \
 	(mp_irq_entries && !skip_ioapic_setup && io_apic_irqs)
 
diff --git a/arch/x86/include/asm/irq_vectors.h b/arch/x86/include/asm/irq_vectors.h
index c20ffca..df116f4 100644
--- a/arch/x86/include/asm/irq_vectors.h
+++ b/arch/x86/include/asm/irq_vectors.h
@@ -53,6 +53,13 @@
  * Vectors 0x30-0x3f are used for ISA interrupts.
  *   round up to the next 16-vector boundary
  */
+/*
+ * FIRST_EXTERNAL_VECTOR = 0x20
+ * FIRST_EXTERNAL_VECTOR + 16 = 0x30 = 110000
+ * ~15 = ~1111 = 11110000
+ * ((FIRST_EXTERNAL_VECTOR + 16) & ~15) = 110000 & 11110000 = 110000 = 0x30
+ * 于是这里是输入一个irq, 返回0x30+irq, 也就是48+irq
+ */
 #define ISA_IRQ_VECTOR(irq)		(((FIRST_EXTERNAL_VECTOR + 16) & ~15) + irq)
 
 /*
diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c
index 2e64178..47294ea 100644
--- a/arch/x86/kernel/apic/apic.c
+++ b/arch/x86/kernel/apic/apic.c
@@ -59,6 +59,26 @@
 #include <asm/intel-family.h>
 #include <asm/irq_regs.h>
 
+/*
+ * 主要的数据结构:
+ *
+ * 533 static struct clock_event_device lapic_clockevent = {
+ * 534         .name                           = "lapic",
+ * 535         .features                       = CLOCK_EVT_FEAT_PERIODIC |
+ * 536                                           CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_C3STOP
+ * 537                                           | CLOCK_EVT_FEAT_DUMMY,
+ * 538         .shift                          = 32,
+ * 539         .set_state_shutdown             = lapic_timer_shutdown,
+ * 540         .set_state_periodic             = lapic_timer_set_periodic,
+ * 541         .set_state_oneshot              = lapic_timer_set_oneshot,
+ * 542         .set_state_oneshot_stopped      = lapic_timer_shutdown,
+ * 543         .set_next_event                 = lapic_next_event,
+ * 544         .broadcast                      = lapic_timer_broadcast,
+ * 545         .rating                         = 100,
+ * 546         .irq                            = -1,
+ * 547 };
+ */
+
 unsigned int num_processors;
 
 unsigned disabled_cpus;
@@ -1542,6 +1562,13 @@ void apic_ap_setup(void)
 }
 
 #ifdef CONFIG_X86_X2APIC
+/*
+ * 在以下修改:
+ *   - arch/x86/kernel/apic/apic.c|1616| <<setup_nox2apic>> x2apic_mode = 0;
+ *   - arch/x86/kernel/apic/apic.c|1639| <<x2apic_disable>> x2apic_mode = 0;
+ *   - arch/x86/kernel/apic/apic.c|1658| <<x2apic_enable>> x2apic_mode = 1;
+ *   - arch/x86/kernel/apic/apic.c|1692| <<check_x2apic>> x2apic_mode = 1;
+ */
 int x2apic_mode;
 
 enum {
@@ -1630,6 +1657,10 @@ static __init void x2apic_disable(void)
 	register_lapic_address(mp_lapic_addr);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/apic.c|1685| <<try_to_enable_x2apic>> x2apic_enable();
+ */
 static __init void x2apic_enable(void)
 {
 	if (x2apic_state != X2APIC_OFF)
@@ -1640,6 +1671,10 @@ static __init void x2apic_enable(void)
 	__x2apic_enable();
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/apic.c|1753| <<enable_IR_x2apic>> try_to_enable_x2apic(ir_stat);
+ */
 static __init void try_to_enable_x2apic(int remap_mode)
 {
 	if (x2apic_state == X2APIC_DISABLED)
@@ -2287,6 +2322,12 @@ int default_cpu_mask_to_apicid(const struct cpumask *mask,
 	return 0;
 }
 
+/*
+ * struct apic apic_flat.cpu_mask_to_apicid = flat_cpu_mask_to_apicid()
+ * struct apic apic_noop.cpu_mask_to_apicid = flat_cpu_mask_to_apicid()
+ * struct apic apic_default.cpu_mask_to_apicid = flat_cpu_mask_to_apicid()
+ * struct apic xen_pv_apic.cpu_mask_to_apicid = flat_cpu_mask_to_apicid()
+ */
 int flat_cpu_mask_to_apicid(const struct cpumask *mask,
 			    struct irq_data *irqdata,
 			    unsigned int *apicid)
diff --git a/arch/x86/kernel/apic/apic_flat_64.c b/arch/x86/kernel/apic/apic_flat_64.c
index dedd5a4..6469a1f 100644
--- a/arch/x86/kernel/apic/apic_flat_64.c
+++ b/arch/x86/kernel/apic/apic_flat_64.c
@@ -22,6 +22,14 @@
 
 #include <linux/acpi.h>
 
+/*
+ * 主要的数据结构:
+ *
+ * struct apic apic_physflat
+ *
+ * struct apic apic_flat
+ */
+
 static struct apic apic_physflat;
 static struct apic apic_flat;
 
diff --git a/arch/x86/kernel/apic/apic_noop.c b/arch/x86/kernel/apic/apic_noop.c
index c8d2112..1fbf102 100644
--- a/arch/x86/kernel/apic/apic_noop.c
+++ b/arch/x86/kernel/apic/apic_noop.c
@@ -29,6 +29,12 @@
 #include <asm/acpi.h>
 #include <asm/e820/api.h>
 
+/*
+ * 主要的数据结构:
+ * 
+ * struct apic apic_noop
+ */
+
 static void noop_init_apic_ldr(void) { }
 static void noop_send_IPI(int cpu, int vector) { }
 static void noop_send_IPI_mask(const struct cpumask *cpumask, int vector) { }
diff --git a/arch/x86/kernel/apic/apic_numachip.c b/arch/x86/kernel/apic/apic_numachip.c
index 2fda912..74bbb2f 100644
--- a/arch/x86/kernel/apic/apic_numachip.c
+++ b/arch/x86/kernel/apic/apic_numachip.c
@@ -20,6 +20,14 @@
 #include <asm/pgtable.h>
 #include <asm/pci_x86.h>
 
+/*
+ * 主要的数据结构:
+ *
+ * struct apic apic_numachip1;
+ *
+ * struct apic apic_numachip2;
+ */
+
 u8 numachip_system __read_mostly;
 static const struct apic apic_numachip1;
 static const struct apic apic_numachip2;
diff --git a/arch/x86/kernel/apic/bigsmp_32.c b/arch/x86/kernel/apic/bigsmp_32.c
index e12fbcf..4a3e431 100644
--- a/arch/x86/kernel/apic/bigsmp_32.c
+++ b/arch/x86/kernel/apic/bigsmp_32.c
@@ -17,6 +17,12 @@
 #include <asm/apic.h>
 #include <asm/ipi.h>
 
+/*
+ * 主要数据结构:
+ *
+ * struct apic apic_bigsmp
+ */
+
 static unsigned bigsmp_get_apic_id(unsigned long x)
 {
 	return (x >> 24) & 0xFF;
diff --git a/arch/x86/kernel/apic/htirq.c b/arch/x86/kernel/apic/htirq.c
index 741de28..a3c3581 100644
--- a/arch/x86/kernel/apic/htirq.c
+++ b/arch/x86/kernel/apic/htirq.c
@@ -23,6 +23,27 @@
 #include <asm/apic.h>
 #include <asm/hypertransport.h>
 
+/*
+ * 主要的数据结构:
+ *
+ * 156 static const struct irq_domain_ops htirq_domain_ops = {
+ * 157         .alloc          = htirq_domain_alloc,
+ * 158         .free           = htirq_domain_free,
+ * 159         .activate       = htirq_domain_activate,
+ * 160         .deactivate     = htirq_domain_deactivate,
+ * 161 };
+ *
+ * 72 static struct irq_chip ht_irq_chip = {
+ * 73         .name                   = "PCI-HT",
+ * 74         .irq_mask               = mask_ht_irq,
+ * 75         .irq_unmask             = unmask_ht_irq,
+ * 76         .irq_ack                = irq_chip_ack_parent,
+ * 77         .irq_set_affinity       = ht_set_affinity,
+ * 78         .irq_retrigger          = irq_chip_retrigger_hierarchy,
+ * 79         .flags                  = IRQCHIP_SKIP_SET_WAKE,
+ * 80 };
+ */
+
 static struct irq_domain *htirq_domain;
 
 /*
@@ -52,6 +73,10 @@ ht_set_affinity(struct irq_data *data, const struct cpumask *mask, bool force)
 	return ret;
 }
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/htirq.c|101| <<htirq_domain_alloc>> irq_domain_set_info(domain, virq, hwirq, &ht_irq_chip, ht_cfg,
+ */
 static struct irq_chip ht_irq_chip = {
 	.name			= "PCI-HT",
 	.irq_mask		= mask_ht_irq,
@@ -145,6 +170,10 @@ static void htirq_domain_deactivate(struct irq_domain *domain,
 	write_ht_irq_msg(irq_data->irq, &msg);
 }
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/htirq.c|166| <<arch_init_htirq_domain>> htirq_domain = irq_domain_create_tree(fn, &htirq_domain_ops, NULL);
+ */
 static const struct irq_domain_ops htirq_domain_ops = {
 	.alloc		= htirq_domain_alloc,
 	.free		= htirq_domain_free,
@@ -152,6 +181,10 @@ static const struct irq_domain_ops htirq_domain_ops = {
 	.deactivate	= htirq_domain_deactivate,
 };
 
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/vector.c|673| <<arch_early_irq_init>> arch_init_htirq_domain(x86_vector_domain);
+ */
 void __init arch_init_htirq_domain(struct irq_domain *parent)
 {
 	struct fwnode_handle *fn;
diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c
index 96a8a68..77a24e5 100644
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@ -65,6 +65,49 @@
 
 #include <asm/apic.h>
 
+/*
+ * 主要数据结构:
+ *
+ * 2025 static struct irq_chip ioapic_chip __read_mostly = {
+ * 2026         .name                   = "IO-APIC",
+ * 2027         .irq_startup            = startup_ioapic_irq,
+ * 2028         .irq_mask               = mask_ioapic_irq,
+ * 2029         .irq_unmask             = unmask_ioapic_irq,
+ * 2030         .irq_ack                = irq_chip_ack_parent,
+ * 2031         .irq_eoi                = ioapic_ack_level,
+ * 2032         .irq_set_affinity       = ioapic_set_affinity,
+ * 2033         .irq_retrigger          = irq_chip_retrigger_hierarchy,
+ * 2034         .flags                  = IRQCHIP_SKIP_SET_WAKE,
+ * 2035 };
+ *
+ * 2058 static struct irq_chip ioapic_ir_chip __read_mostly = {
+ * 2059         .name                   = "IR-IO-APIC",
+ * 2060         .irq_startup            = startup_ioapic_irq,
+ * 2061         .irq_mask               = mask_ioapic_irq,
+ * 2062         .irq_unmask             = unmask_ioapic_irq,
+ * 2063         .irq_ack                = irq_chip_ack_parent,
+ * 2064         .irq_eoi                = ioapic_ir_ack_level,
+ * 2065         .irq_set_affinity       = ioapic_set_affinity,
+ * 2066         .irq_retrigger          = irq_chip_retrigger_hierarchy,
+ * 2067         .flags                  = IRQCHIP_SKIP_SET_WAKE,
+ * 2068 };
+ *
+ * 2142 static struct irq_chip lapic_chip __read_mostly = {
+ * 2143         .name           = "local-APIC",
+ * 2144         .irq_mask       = mask_lapic_irq,
+ * 2145         .irq_unmask     = unmask_lapic_irq,
+ * 2146         .irq_ack        = ack_lapic_irq,
+ * 2147 };
+ *
+ *
+ * 3484 const struct irq_domain_ops mp_ioapic_irqdomain_ops = {
+ * 3485         .alloc          = mp_irqdomain_alloc,
+ * 3486         .free           = mp_irqdomain_free,
+ * 3487         .activate       = mp_irqdomain_activate,
+ * 3488         .deactivate     = mp_irqdomain_deactivate,
+ * 3489 };
+ */
+
 #define	for_each_ioapic(idx)		\
 	for ((idx) = 0; (idx) < nr_ioapics; (idx)++)
 #define	for_each_ioapic_reverse(idx)	\
@@ -79,6 +122,11 @@
 
 static DEFINE_RAW_SPINLOCK(ioapic_lock);
 static DEFINE_MUTEX(ioapic_mutex);
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/io_apic.c|2554| <<mp_irqdomain_create>> ioapic_dynirq_base = max(ioapic_dynirq_base,
+ *   - arch/x86/kernel/apic/io_apic.c|2659| <<arch_dynirq_lower_bound>> return ioapic_initialized ? ioapic_dynirq_base : gsi_top;
+ */
 static unsigned int ioapic_dynirq_base;
 static int ioapic_initialized;
 
@@ -88,6 +136,22 @@ struct irq_pin_list {
 };
 
 struct mp_chip_data {
+	/*
+	 * 使用的地方:
+	 *   - arch/x86/kernel/apic/io_apic.c|414| <<__add_pin_to_irq_node>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|426| <<__add_pin_to_irq_node>> list_add_tail(&entry->list, &data->irq_2_pin);
+	 *   - arch/x86/kernel/apic/io_apic.c|435| <<__remove_pin_from_irq>> list_for_each_entry_safe(entry, tmp, &data->irq_2_pin, list)
+	 *   - arch/x86/kernel/apic/io_apic.c|463| <<replace_pin_at_irq_node>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|488| <<io_apic_modify_irq>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|578| <<eoi_ioapic_pin>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|1410| <<print_IO_APICs>> if (list_empty(&data->irq_2_pin))
+	 *   - arch/x86/kernel/apic/io_apic.c|1414| <<print_IO_APICs>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|1763| <<io_apic_level_ack_pending>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|1930| <<ioapic_set_affinity>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|3113| <<mp_irqdomain_alloc>> INIT_LIST_HEAD(&data->irq_2_pin);
+	 *   - arch/x86/kernel/apic/io_apic.c|3151| <<mp_irqdomain_free>> WARN_ON(!list_empty(&data->irq_2_pin));
+	 *   - arch/x86/kernel/apic/io_apic.c|3165| <<mp_irqdomain_activate>> for_each_irq_pin(entry, data->irq_2_pin)
+	 */
 	struct list_head irq_2_pin;
 	struct IO_APIC_route_entry entry;
 	int trigger;
@@ -105,6 +169,15 @@ static struct ioapic {
 	/*
 	 * # of IRQ routing registers
 	 */
+	/*
+	 * used by:
+	 *   - arch/x86/kernel/apic/io_apic.c|73| <<for_each_pin>> for ((pin) = 0; (pin) < ioapics[(idx)].nr_registers; (pin)++)
+	 *   - arch/x86/kernel/apic/io_apic.c|240| <<alloc_ioapic_saved_registers>> size = sizeof(struct IO_APIC_route_entry) * ioapics[idx].nr_registers;
+	 *   - arch/x86/kernel/apic/io_apic.c|1324| <<print_IO_APICs>> ioapics[ioapic_idx].nr_registers);
+	 *   - arch/x86/kernel/apic/io_apic.c|2752| <<find_free_ioapic_entry>> if (ioapics[idx].nr_registers == 0)
+	 *   - arch/x86/kernel/apic/io_apic.c|2849| <<mp_register_ioapic>> ioapics[idx].nr_registers = entries;
+	 *   - arch/x86/kernel/apic/io_apic.c|2890| <<mp_unregister_ioapic>> ioapics[ioapic].nr_registers = 0;
+	 */
 	int nr_registers;
 	/*
 	 * Saved state during suspend/resume, or while enabling intr-remap.
@@ -176,6 +249,24 @@ int nr_ioapics;
 /* The one past the highest gsi number used */
 u32 gsi_top;
 
+/*
+ * 在以下被使用:
+ *   - mp_config_acpi_legacy_irqs()
+ *   - mp_save_irq()
+ *   - find_irq_entry()
+ *   - find_isa_irq_pin()
+ *   - find_isa_irq_apic()
+ *   - default_EISA_trigger()
+ *   - irq_polarity()
+ *   - irq_trigger()
+ *   - mp_map_pin_to_irq()
+ *   - pin_2_irq()
+ *   - IO_APIC_get_PCI_irq_vector()
+ *   - setup_ioapic_ids_from_mpc_nocheck()
+ *   - get_MP_intsrc_index()
+ *   - check_irq_src()
+ *   - replace_intsrc_all()
+ */
 /* MP IRQ source entries */
 struct mpc_intsrc mp_irqs[MAX_IRQ_SOURCES];
 
@@ -303,10 +394,18 @@ union entry_union {
 	struct IO_APIC_route_entry entry;
 };
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|322| <<ioapic_read_entry>> eu.entry = __ioapic_read_entry(apic, pin);
+ *   - arch/x86/kernel/apic/io_apic.c|516| <<__eoi_ioapic_pin>> entry = entry1 = __ioapic_read_entry(apic, pin);
+ */
 static struct IO_APIC_route_entry __ioapic_read_entry(int apic, int pin)
 {
 	union entry_union eu;
 
+	/*
+	 * 乘以2是因为一个entry是64 bits
+	 */
 	eu.w1 = io_apic_read(apic, 0x10 + 2 * pin);
 	eu.w2 = io_apic_read(apic, 0x11 + 2 * pin);
 
@@ -415,12 +514,32 @@ static void add_pin_to_irq_node(struct mp_chip_data *data,
 /*
  * Reroute an IRQ to a different pin.
  */
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/io_apic.c|2226| <<check_timer>> replace_pin_at_irq_node(data, node, apic1, pin1, apic2, pin2);
+ */
 static void __init replace_pin_at_irq_node(struct mp_chip_data *data, int node,
 					   int oldapic, int oldpin,
 					   int newapic, int newpin)
 {
 	struct irq_pin_list *entry;
 
+	/*
+	 * 使用的地方:
+	 *   - arch/x86/kernel/apic/io_apic.c|414| <<__add_pin_to_irq_node>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|426| <<__add_pin_to_irq_node>> list_add_tail(&entry->list, &data->irq_2_pin);
+	 *   - arch/x86/kernel/apic/io_apic.c|435| <<__remove_pin_from_irq>> list_for_each_entry_safe(entry, tmp, &data->irq_2_pin, list)
+	 *   - arch/x86/kernel/apic/io_apic.c|463| <<replace_pin_at_irq_node>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|488| <<io_apic_modify_irq>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|578| <<eoi_ioapic_pin>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|1410| <<print_IO_APICs>> if (list_empty(&data->irq_2_pin))
+	 *   - arch/x86/kernel/apic/io_apic.c|1414| <<print_IO_APICs>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|1763| <<io_apic_level_ack_pending>> for_each_irq_pin(entry, data->irq_2_pin) {
+	 *   - arch/x86/kernel/apic/io_apic.c|1930| <<ioapic_set_affinity>> for_each_irq_pin(entry, data->irq_2_pin)
+	 *   - arch/x86/kernel/apic/io_apic.c|3113| <<mp_irqdomain_alloc>> INIT_LIST_HEAD(&data->irq_2_pin);
+	 *   - arch/x86/kernel/apic/io_apic.c|3151| <<mp_irqdomain_free>> WARN_ON(!list_empty(&data->irq_2_pin));
+	 *   - arch/x86/kernel/apic/io_apic.c|3165| <<mp_irqdomain_activate>> for_each_irq_pin(entry, data->irq_2_pin)
+	 */
 	for_each_irq_pin(entry, data->irq_2_pin) {
 		if (entry->apic == oldapic && entry->pin == oldpin) {
 			entry->apic = newapic;
@@ -465,6 +584,10 @@ static void io_apic_sync(struct irq_pin_list *entry)
 	readl(&io_apic->data);
 }
 
+/*
+ * struct irq_chip ioapic_chip.irq_mask = mask_ioapic_irq()
+ * struct irq_chip ioapic_ir_chip.irq_mask = mask_ioapic_irq()
+ */
 static void mask_ioapic_irq(struct irq_data *irq_data)
 {
 	struct mp_chip_data *data = irq_data->chip_data;
@@ -480,6 +603,10 @@ static void __unmask_ioapic(struct mp_chip_data *data)
 	io_apic_modify_irq(data, ~IO_APIC_REDIR_MASKED, 0, NULL);
 }
 
+/*
+ * struct irq_chip ioapic_chip.irq_unmask = unmask_ioapic_irq()
+ * struct irq_chip ioapic_ir_chip.irq_unmask = unmask_ioapic_irq()
+ */
 static void unmask_ioapic_irq(struct irq_data *irq_data)
 {
 	struct mp_chip_data *data = irq_data->chip_data;
@@ -541,6 +668,15 @@ static void eoi_ioapic_pin(int vector, struct mp_chip_data *data)
 	raw_spin_unlock_irqrestore(&ioapic_lock, flags);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|636| <<clear_IO_APIC>> clear_IO_APIC_pin(apic, pin);
+ *   - arch/x86/kernel/apic/io_apic.c|2033| <<unlock_ExtINT_logic>> clear_IO_APIC_pin(apic, pin);
+ *   - arch/x86/kernel/apic/io_apic.c|2062| <<unlock_ExtINT_logic>> clear_IO_APIC_pin(apic, pin);
+ *   - arch/x86/kernel/apic/io_apic.c|2209| <<check_timer>> clear_IO_APIC_pin(0, pin1);
+ *   - arch/x86/kernel/apic/io_apic.c|2214| <<check_timer>> clear_IO_APIC_pin(apic1, pin1);
+ *   - arch/x86/kernel/apic/io_apic.c|2239| <<check_timer>> clear_IO_APIC_pin(apic2, pin2);
+ */
 static void clear_IO_APIC_pin(unsigned int apic, unsigned int pin)
 {
 	struct IO_APIC_route_entry entry;
@@ -588,6 +724,11 @@ static void clear_IO_APIC_pin(unsigned int apic, unsigned int pin)
 		       mpc_ioapic_id(apic), pin);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|1410| <<enable_IO_APIC>> clear_IO_APIC();
+ *   - arch/x86/kernel/apic/io_apic.c|1449| <<disable_IO_APIC>> clear_IO_APIC();
+ */
 static void clear_IO_APIC (void)
 {
 	int apic, pin;
@@ -717,6 +858,9 @@ static int find_irq_entry(int ioapic_idx, int pin, int type)
 /*
  * Find the pin to which IRQ[irq] (ISA) is connected
  */
+/*
+ * 通过mptable读取
+ */
 static int __init find_isa_irq_pin(int irq, int type)
 {
 	int i;
@@ -733,6 +877,9 @@ static int __init find_isa_irq_pin(int irq, int type)
 	return -1;
 }
 
+/*
+ * 通过mptable读取
+ */
 static int __init find_isa_irq_apic(int irq, int type)
 {
 	int i;
@@ -1226,6 +1373,10 @@ void ioapic_zap_locks(void)
 	raw_spin_lock_init(&ioapic_lock);
 }
 
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/io_apic.c|1408| <<print_IO_APIC>> io_apic_print_entries(ioapic_idx, reg_01.bits.entries);
+ */
 static void io_apic_print_entries(unsigned int apic, unsigned int nr_entries)
 {
 	int i;
@@ -1312,6 +1463,10 @@ static void __init print_IO_APIC(int ioapic_idx)
 	io_apic_print_entries(ioapic_idx, reg_01.bits.entries);
 }
 
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/vector.c|993| <<print_ICs>> print_IO_APICs();
+ */
 void __init print_IO_APICs(void)
 {
 	int ioapic_idx;
@@ -1356,9 +1511,28 @@ void __init print_IO_APICs(void)
 	printk(KERN_INFO ".................................... done.\n");
 }
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/io_apic.c|1381| <<enable_IO_APIC>> ioapic_i8259.apic = apic;
+ *   - arch/x86/kernel/apic/io_apic.c|1382| <<enable_IO_APIC>> ioapic_i8259.pin = pin;
+ *   - arch/x86/kernel/apic/io_apic.c|1395| <<enable_IO_APIC>> if ((ioapic_i8259.pin == -1) && (i8259_pin >= 0)) {
+ *   - arch/x86/kernel/apic/io_apic.c|1397| <<enable_IO_APIC>> ioapic_i8259.pin = i8259_pin;
+ *   - arch/x86/kernel/apic/io_apic.c|1398| <<enable_IO_APIC>> ioapic_i8259.apic = i8259_apic;
+ *   - arch/x86/kernel/apic/io_apic.c|1401| <<enable_IO_APIC>> if (((ioapic_i8259.apic != i8259_apic) || (ioapic_i8259.pin != i8259_pin)) &&
+ *   - arch/x86/kernel/apic/io_apic.c|1402| <<enable_IO_APIC>> (i8259_pin >= 0) && (ioapic_i8259.pin >= 0))
+ *   - arch/x86/kernel/apic/io_apic.c|1420| <<native_disable_io_apic>> if (ioapic_i8259.pin != -1) {
+ *   - arch/x86/kernel/apic/io_apic.c|1434| <<native_disable_io_apic>> ioapic_write_entry(ioapic_i8259.apic, ioapic_i8259.pin, entry);
+ *   - arch/x86/kernel/apic/io_apic.c|1438| <<native_disable_io_apic>> disconnect_bsp_APIC(ioapic_i8259.pin != -1);
+ *   - arch/x86/kernel/apic/io_apic.c|2079| <<check_timer>> pin2 = ioapic_i8259.pin;
+ *   - arch/x86/kernel/apic/io_apic.c|2080| <<check_timer>> apic2 = ioapic_i8259.apic;
+ */
 /* Where if anywhere is the i8259 connect in external int mode */
 static struct { int pin, apic; } ioapic_i8259 = { -1, -1 };
 
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/apic.c|2361| <<apic_bsp_setup>> enable_IO_APIC();
+ */
 void __init enable_IO_APIC(void)
 {
 	int i8259_apic, i8259_pin;
@@ -1578,6 +1752,15 @@ void __init setup_ioapic_ids_from_mpc(void)
 }
 #endif
 
+/*
+ * 在以下设置:
+ *   - arch/x86/kernel/apic/io_apic.c|1699| <<notimercheck>> no_timer_check = 1; ---> "no_timer_check"参数!
+ *   - arch/x86/kernel/cpu/mshyperv.c|231| <<ms_hyperv_init_platform>> no_timer_check = 1;
+ *   - arch/x86/kernel/cpu/vmware.c|171| <<vmware_platform_setup>> no_timer_check = 1;
+ *   - arch/x86/kernel/kvm.c|298| <<paravirt_ops_setup>> no_timer_check = 1;
+ * 只在timer_irq_works()使用:
+ *   - arch/x86/kernel/apic/io_apic.c|1724| <<timer_irq_works>> if (no_timer_check)
+ */
 int no_timer_check __initdata;
 
 static int __init notimercheck(char *s)
@@ -1595,11 +1778,27 @@ __setup("no_timer_check", notimercheck);
  *	- if this function detects that timer IRQs are defunct, then we fall
  *	  back to ISA timer IRQs
  */
+/*
+ * 在timer_irq_works()中测试的时候会激活中断
+ */
 static int __init timer_irq_works(void)
 {
+	/*
+	 * jiffies和jiffies_64是一样的, 定义在
+	 * arch/x86/kernel/vmlinux.lds.S
+	 */
 	unsigned long t1 = jiffies;
 	unsigned long flags;
 
+	/*
+	 * 在以下设置:
+	 *   - arch/x86/kernel/apic/io_apic.c|1699| <<notimercheck>> no_timer_check = 1; ---> "no_timer_check"参数!
+	 *   - arch/x86/kernel/cpu/mshyperv.c|231| <<ms_hyperv_init_platform>> no_timer_check = 1;
+	 *   - arch/x86/kernel/cpu/vmware.c|171| <<vmware_platform_setup>> no_timer_check = 1;
+	 *   - arch/x86/kernel/kvm.c|298| <<paravirt_ops_setup>> no_timer_check = 1;
+	 * 只在timer_irq_works()使用:
+	 *   - arch/x86/kernel/apic/io_apic.c|1724| <<timer_irq_works>> if (no_timer_check)
+	 */
 	if (no_timer_check)
 		return 1;
 
@@ -1645,6 +1844,10 @@ static int __init timer_irq_works(void)
  * This is not complete - we should be able to fake
  * an edge even if it isn't on the 8259A...
  */
+/*
+ * struct irq_chip ioapic_chip.irq_startup = startup_ioapic_irq()
+ * struct irq_chip ioapic_ir_chip.irq_startup = startup_ioapic_irq()
+ */
 static unsigned int startup_ioapic_irq(struct irq_data *data)
 {
 	int was_pending = 0, irq = data->irq;
@@ -1742,6 +1945,9 @@ static inline void ioapic_irqd_unmask(struct irq_data *data, bool masked)
 }
 #endif
 
+/*
+ * struct irq_chip ioapic_chip.irq_eoi = ioapic_ack_level()
+ */
 static void ioapic_ack_level(struct irq_data *irq_data)
 {
 	struct irq_cfg *cfg = irqd_cfg(irq_data);
@@ -1808,6 +2014,9 @@ static void ioapic_ack_level(struct irq_data *irq_data)
 	ioapic_irqd_unmask(irq_data, masked);
 }
 
+/*
+ * struct irq_chip ioapic_ir_chip.irq_eoi = ioapic_ir_ack_level()
+ */
 static void ioapic_ir_ack_level(struct irq_data *irq_data)
 {
 	struct mp_chip_data *data = irq_data->chip_data;
@@ -1822,6 +2031,10 @@ static void ioapic_ir_ack_level(struct irq_data *irq_data)
 	eoi_ioapic_pin(data->entry.vector, data);
 }
 
+/*
+ * struct irq_chip ioapic_chip.irq_set_affinity = ioapic_set_affinity()
+ * struct irq_chip ioapic_ir_chip.irq_set_affinity = ioapic_set_affinity()
+ */
 static int ioapic_set_affinity(struct irq_data *irq_data,
 			       const struct cpumask *mask, bool force)
 {
@@ -1847,6 +2060,11 @@ static int ioapic_set_affinity(struct irq_data *irq_data,
 	return ret;
 }
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/io_apic.c|1446| <<print_IO_APICs>> if (chip != &ioapic_chip && chip != &ioapic_ir_chip)
+ *   - arch/x86/kernel/apic/io_apic.c|3296| <<mp_irqdomain_alloc>> &ioapic_chip : &ioapic_ir_chip;
+ */
 static struct irq_chip ioapic_chip __read_mostly = {
 	.name			= "IO-APIC",
 	.irq_startup		= startup_ioapic_irq,
@@ -1859,6 +2077,11 @@ static struct irq_chip ioapic_chip __read_mostly = {
 	.flags			= IRQCHIP_SKIP_SET_WAKE,
 };
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/io_apic.c|1446| <<print_IO_APICs>> if (chip != &ioapic_chip && chip != &ioapic_ir_chip)
+ *   - arch/x86/kernel/apic/io_apic.c|3296| <<mp_irqdomain_alloc>> &ioapic_chip : &ioapic_ir_chip;
+ */
 static struct irq_chip ioapic_ir_chip __read_mostly = {
 	.name			= "IR-IO-APIC",
 	.irq_startup		= startup_ioapic_irq,
@@ -1897,6 +2120,9 @@ static inline void init_IO_APIC_traps(void)
  * The local APIC irq-chip implementation:
  */
 
+/*
+ * struct irq_chip lapic_chip.irq_mask = mask_lapic_irq()
+ */
 static void mask_lapic_irq(struct irq_data *data)
 {
 	unsigned long v;
@@ -1905,6 +2131,9 @@ static void mask_lapic_irq(struct irq_data *data)
 	apic_write(APIC_LVT0, v | APIC_LVT_MASKED);
 }
 
+/*
+ * struct irq_chip lapic_chip.irq_unmask = unmask_lapic_irq()
+ */
 static void unmask_lapic_irq(struct irq_data *data)
 {
 	unsigned long v;
@@ -1913,11 +2142,18 @@ static void unmask_lapic_irq(struct irq_data *data)
 	apic_write(APIC_LVT0, v & ~APIC_LVT_MASKED);
 }
 
+/*
+ * struct irq_chip lapic_chip.irq_ack = ack_lapic_irq()
+ */
 static void ack_lapic_irq(struct irq_data *data)
 {
 	ack_APIC_irq();
 }
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/io_apic.c|2121| <<lapic_register_intr>> irq_set_chip_and_handler_name(irq, &lapic_chip, handle_edge_irq,
+ */
 static struct irq_chip lapic_chip __read_mostly = {
 	.name		= "local-APIC",
 	.irq_mask	= mask_lapic_irq,
@@ -1925,9 +2161,26 @@ static struct irq_chip lapic_chip __read_mostly = {
 	.irq_ack	= ack_lapic_irq,
 };
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|2278| <<check_timer>> lapic_register_intr(0);
+ */
 static void lapic_register_intr(int irq)
 {
 	irq_clear_status_flags(irq, IRQ_LEVEL);
+	/*
+	 * 在部分以下调用:
+	 *   - arch/x86/kernel/apic/io_apic.c|2056| <<lapic_register_intr>> irq_set_chip_and_handler_name(irq, &lapic_chip, handle_edge_irq,
+	 *   - kernel/irq/irqdomain.c|1797| <<irq_domain_set_info>> irq_set_chip_and_handler_name(virq, chip, handler, handler_name);
+	 *   - include/linux/irq.h|620| <<irq_set_chip_and_handler>> irq_set_chip_and_handler_name(irq, chip, handle, NULL);
+	 *   - drivers/xen/events/events_base.c|702| <<xen_bind_pirq_gsi_to_irq>> irq_set_chip_and_handler_name(irq, &xen_pirq_chip,
+	 *   - drivers/xen/events/events_base.c|705| <<xen_bind_pirq_gsi_to_irq>> irq_set_chip_and_handler_name(irq, &xen_pirq_chip,
+	 *   - drivers/xen/events/events_base.c|741| <<xen_bind_pirq_msi_to_irq>> irq_set_chip_and_handler_name(irq + i, &xen_pirq_chip, handle_edge_irq, name);
+	 *   - drivers/xen/events/events_base.c|846| <<bind_evtchn_to_irq>> irq_set_chip_and_handler_name(irq, &xen_dynamic_chip,
+	 *   - drivers/xen/events/events_base.c|884| <<bind_ipi_to_irq>> irq_set_chip_and_handler_name(irq, &xen_percpu_chip,
+	 *   - drivers/xen/events/events_base.c|976| <<bind_virq_to_irq>> irq_set_chip_and_handler_name(irq, &xen_percpu_chip,
+	 *   - drivers/xen/events/events_base.c|979| <<bind_virq_to_irq>> irq_set_chip_and_handler_name(irq, &xen_dynamic_chip,
+	 */
 	irq_set_chip_and_handler_name(irq, &lapic_chip, handle_edge_irq,
 				      "edge");
 }
@@ -1945,11 +2198,13 @@ static inline void __init unlock_ExtINT_logic(void)
 	struct IO_APIC_route_entry entry0, entry1;
 	unsigned char save_control, save_freq_select;
 
+	/* 通过mptable读取 */
 	pin  = find_isa_irq_pin(8, mp_INT);
 	if (pin == -1) {
 		WARN_ON_ONCE(1);
 		return;
 	}
+	/* 通过mptable读取 */
 	apic = find_isa_irq_apic(8, mp_INT);
 	if (apic == -1) {
 		WARN_ON_ONCE(1);
@@ -2027,10 +2282,47 @@ static int mp_alloc_timer_irq(int ioapic, int pin)
  *
  * FIXME: really need to revamp this for all platforms.
  */
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/io_apic.c|2312| <<setup_IO_APIC>> check_timer();
+ *
+ * 在之前给KVM的commit的中禁用了
+ * commit a90ede7b17d122acd58e6e1ff911be9dcf5263cc
+ * Author: Marcelo Tosatti <mtosatti@redhat.com>
+ * Date:   Wed Feb 11 22:45:42 2009 -0200
+ *
+ * KVM: x86: paravirt skip pit-through-ioapic boot check
+ *
+ * Skip the test which checks if the PIT is properly routed when
+ * using the IOAPIC, aimed at buggy hardware.
+ *
+ * Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
+ * Signed-off-by: Avi Kivity <avi@redhat.com>
+ */
 static inline void __init check_timer(void)
 {
+	/*
+	 * 获得irq 0的struct irq_desc *desc, 返回desc->irq_data
+	 *
+	 * irq_data是: struct irq_data irq_data
+	 */
 	struct irq_data *irq_data = irq_get_irq_data(0);
+	/*
+	 * chip_data是: void *chip_data
+	 *
+	 * chip_data在以下设置:
+	 *   - arch/x86/kernel/apic/io_apic.c|3385| <<mp_irqdomain_alloc>> irq_data->chip_data = data;
+	 *   - arch/x86/kernel/apic/vector.c|563| <<x86_vector_alloc_irqs>> irq_data->chip_data = data;
+	 *   - drivers/iommu/amd_iommu.c|4161| <<irq_remapping_alloc>> irq_data->chip_data = data;
+	 *   - drivers/iommu/intel_irq_remapping.c|1372| <<intel_irq_remapping_alloc>> irq_data->chip_data = ird;
+	 *   - drivers/pci/host/pci-hyperv.c|1224| <<hv_compose_msi_msg>> data->chip_data = int_desc;
+	 *   - kernel/irq/chip.c|167| <<irq_set_chip_data>> desc->irq_data.chip_data = data;
+	 *   - kernel/irq/irqdomain.c|1403| <<irq_domain_set_hwirq_and_chip>> irq_data->chip_data = chip_data;
+	 */
 	struct mp_chip_data *data = irq_data->chip_data;
+	/*
+	 * irq_data是struct irq_desc的struct irq_data irq_data
+	 */
 	struct irq_cfg *cfg = irqd_cfg(irq_data);
 	int node = cpu_to_node(0);
 	int apic1, pin1, apic2, pin2;
@@ -2042,6 +2334,18 @@ static inline void __init check_timer(void)
 	/*
 	 * get/set the timer IRQ vector:
 	 */
+	/*
+	 * legacy_pic可以是:
+	 *   - default_legacy_pic
+	 *   - null_legacy_pic
+	 *
+	 * 这里的参数0是irq
+	 *
+	 * 对于mask_8259A_irq(): 通过IMR寄存器在8259禁用某个irq line
+	 *
+	 * 对于8259, 由于从片串接到主片的IRQ2 pin上,
+	 * 从片的IRQ1 pin同时接到IRQ2和IRQ9 line
+	 */
 	legacy_pic->mask(0);
 
 	/*
@@ -2054,13 +2358,31 @@ static inline void __init check_timer(void)
 	 * automatically.
 	 */
 	apic_write(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
+	/*
+	 * init_8259A(): 1说明支持AEOI
+	 * 按照ICW要求的顺序初始化8259
+	 *   vector 0x30对应irq line 0
+	 *   vector 0x38对应irq line 8
+	 * 最后会根据cached_irq_mask屏蔽中断
+	 */
 	legacy_pic->init(1);
 
+	/* 通过mptable读取 */
 	pin1  = find_isa_irq_pin(0, mp_INT);
+	/* 通过mptable读取 */
 	apic1 = find_isa_irq_apic(0, mp_INT);
+	/* 从ioapic获取的 */
 	pin2  = ioapic_i8259.pin;
+	/* 从ioapic获取的 */
 	apic2 = ioapic_i8259.apic;
 
+	/*
+	 * 在测试xen domU中boot和kdump的例子都是:
+	 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=0 pin2=0
+	 *
+	 * 在8-thread的dell测试机kvm的VM里:
+	 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=-1 pin2=-1
+	 */
 	apic_printk(APIC_QUIET, KERN_INFO "..TIMER: vector=0x%02X "
 		    "apic1=%d pin1=%d apic2=%d pin2=%d\n",
 		    cfg->vector, apic1, pin1, apic2, pin2);
@@ -2072,6 +2394,14 @@ static inline void __init check_timer(void)
 	 * was found above, try it both directly and through the
 	 * 8259A.
 	 */
+	/*
+	 * 在测试xen domU中boot和kdump的例子都是:
+	 *
+	 * pin1 = 2
+	 * pin2 = 0
+	 *
+	 * 所以下面的no_pin1应该是0
+	 */
 	if (pin1 == -1) {
 		panic_if_irq_remap("BIOS bug: timer not connected to IO-APIC");
 		pin1 = pin2;
@@ -2088,17 +2418,43 @@ static inline void __init check_timer(void)
 			mp_alloc_timer_irq(apic1, pin1);
 		} else {
 			/*
+			 * 目前测试的kvm和xen都是执行这里
+			 *
+			 * 在测试xen domU中boot和kdump的例子都是:
+			 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=0 pin2=0
+			 */
+			/*
 			 * for edge trigger, it's already unmasked,
 			 * so only need to unmask if it is level-trigger
 			 * do we really have level trigger timer?
 			 */
 			int idx;
+			/*
+			 * 在测试xen domU中boot和kdump的例子都是:
+			 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=0 pin2=0
+			 *
+			 * 这里先尝试8254???
+			 * 就是8254!!!
+			 * 只有8254这一个pit
+			 */
 			idx = find_irq_entry(apic1, pin1, mp_INT);
 			if (idx != -1 && irq_trigger(idx))
 				unmask_ioapic_irq(irq_get_irq_data(0));
 		}
+		/*
+		 * irq_data来自一开始的:
+		 * struct irq_data *irq_data = irq_get_irq_data(0);
+		 */
 		irq_domain_deactivate_irq(irq_data);
 		irq_domain_activate_irq(irq_data);
+		/*
+		 * 先测试用ioapic处理的8254?? (pin 2接口)
+		 *
+		 * 在这里测试中:
+		 *   - 在8259上mask了irq 0
+		 *   - 在lapic上的lvt0禁用了8259
+		 *   - 在ioapic的pin 2 (irq line 2)上接收中断到irq 0 --> 当然是用 ioapic发的!!
+		 */
 		if (timer_irq_works()) {
 			if (disable_timer_pin_1 > 0)
 				clear_IO_APIC_pin(0, pin1);
@@ -2116,12 +2472,30 @@ static inline void __init check_timer(void)
 		apic_printk(APIC_QUIET, KERN_INFO
 			    "..... (found apic %d pin %d) ...\n", apic2, pin2);
 		/*
+		 * 在测试xen domU中boot和kdump的例子都是:
+		 * ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=0 pin2=0
+		 *
+		 * 下面用8259, 也就是pin 0接口, 定向到irq0
+		 */
+		/*
 		 * legacy devices should be connected to IO APIC #0
 		 */
 		replace_pin_at_irq_node(data, node, apic1, pin1, apic2, pin2);
 		irq_domain_deactivate_irq(irq_data);
 		irq_domain_activate_irq(irq_data);
+		/*
+		 * 对于unmask_8259A_irq(): 通过IMR寄存器在8259开通某个irq line
+		 */
 		legacy_pic->unmask(0);
+		/*
+		 * 这里测试的8259? pin 0接口
+		 *
+		 * 在这里的测试中:
+		 *   - 在8259上开通了irq 0
+		 *   - 在lapic上的lvt0依然禁用了8259???
+		 *   - 这里用io_apic发的???
+		 * 那中断是怎么发到cpu的????????
+		 */
 		if (timer_irq_works()) {
 			apic_printk(APIC_QUIET, KERN_INFO "....... works.\n");
 			goto out;
@@ -2138,10 +2512,23 @@ static inline void __init check_timer(void)
 	apic_printk(APIC_QUIET, KERN_INFO
 		    "...trying to set up timer as Virtual Wire IRQ...\n");
 
+	/*
+	 * 下面又要开启lapic的LVT0
+	 */
 	lapic_register_intr(0);
+	/*
+	 * 用APIC_DM_FIXED需要制定vector
+	 *
+	 * cfg来自函数一开始的
+	 * struct irq_data *irq_data = irq_get_irq_data(0);
+	 * struct irq_cfg *cfg = irqd_cfg(irq_data);
+	 */
 	apic_write(APIC_LVT0, APIC_DM_FIXED | cfg->vector);	/* Fixed mode */
 	legacy_pic->unmask(0);
 
+	/*
+	 *
+	 */
 	if (timer_irq_works()) {
 		apic_printk(APIC_QUIET, KERN_INFO "..... works.\n");
 		goto out;
@@ -2154,12 +2541,43 @@ static inline void __init check_timer(void)
 	apic_printk(APIC_QUIET, KERN_INFO
 		    "...trying to set up timer as ExtINT IRQ...\n");
 
+	/*
+	 * 下面用另外一种方式开启lapic的LVT0
+	 *
+	 * default_legacy_pic:
+	 *   init_8259A()
+	 *   make_8259A_irq()
+	 *
+	 * init_8259A(): 0说明不支持AEOI
+	 * 按照ICW要求的顺序初始化8259
+	 *   vector 0x30对应irq line 0
+	 *   vector 0x38对应irq line 8
+	 * 最后会根据cached_irq_mask屏蔽中断
+	 */
 	legacy_pic->init(0);
+	/*
+	 * make_8259A_irq()
+	 * 配置8259使某个irq line通过8259, 而不通过ioapic了
+	 * 这里在io_apic_irqs把某个irq line的bit清0, 说明不通过ioapic了
+	 * 通过下面设置中断的chip:
+	 *   - irq_set_chip_and_handler(irq, &i8259A_chip, handle_level_irq);
+	 *
+	 * io_apic_irqs是一个bitmap, 说明那个irq line是用的io_apic
+	 * used by:
+	 *   - arch/x86/include/asm/io_apic.h|147| <<IO_APIC_IRQ>> #define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1 << (x)) & io_apic_irqs))
+	 *   - arch/x86/include/asm/io_apic.h|154| <<io_apic_assign_pci_irqs>> (mp_irq_entries && !skip_ioapic_setup && io_apic_irqs)
+	 *   - arch/x86/kernel/apic/io_apic.c|284| <<arch_early_ioapic_init>> io_apic_irqs = ~0UL;
+	 *   - arch/x86/kernel/apic/io_apic.c|2427| <<setup_IO_APIC>> io_apic_irqs = nr_legacy_irqs() ? ~PIC_IRQS : ~0UL;
+	 *   - arch/x86/kernel/i8259.c|115| <<make_8259A_irq>> io_apic_irqs &= ~(1<<irq);
+	 */
 	legacy_pic->make_irq(0);
 	apic_write(APIC_LVT0, APIC_DM_EXTINT);
 
 	unlock_ExtINT_logic();
 
+	/*
+	 *
+	 */
 	if (timer_irq_works()) {
 		apic_printk(APIC_QUIET, KERN_INFO "..... works.\n");
 		goto out;
@@ -2195,6 +2613,11 @@ static inline void __init check_timer(void)
  */
 #define PIC_IRQS	(1UL << PIC_CASCADE_IR)
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|2583| <<setup_IO_APIC>> BUG_ON(mp_irqdomain_create(ioapic));
+ *   - arch/x86/kernel/apic/io_apic.c|3110| <<mp_register_ioapic>> if (mp_irqdomain_create(idx)) {
+ */
 static int mp_irqdomain_create(int ioapic)
 {
 	struct irq_alloc_info info;
@@ -2209,6 +2632,7 @@ static int mp_irqdomain_create(int ioapic)
 	if (cfg->type == IOAPIC_DOMAIN_INVALID)
 		return 0;
 
+	/* 就是清0 */
 	init_irq_alloc_info(&info, NULL);
 	info.type = X86_IRQ_ALLOC_TYPE_IOAPIC;
 	info.ioapic_id = mpc_ioapic_id(ioapic);
@@ -2222,11 +2646,23 @@ static int mp_irqdomain_create(int ioapic)
 	if (cfg->dev) {
 		fn = of_node_to_fwnode(cfg->dev);
 	} else {
+		/*
+		 * 在kvm上执行到这里
+		 *
+		 * 分配和初始化一个 struct fwnode_handle
+		 */
 		fn = irq_domain_alloc_named_id_fwnode(name, ioapic);
 		if (!fn)
 			return -ENOMEM;
 	}
 
+	/*
+	 * 这里cfg->ops可以是struct irq_domain_ops mp_ioapic_irqdomain_ops
+	 * hwirqs是ioapic的pin的数量
+	 * ioapic是ioapic的id
+	 *
+	 * 核心思想就是初始化一个struct irq_domain, 加入irq_domain_list
+	 */
 	ip->irqdomain = irq_domain_create_linear(fn, hwirqs, cfg->ops,
 						 (void *)(long)ioapic);
 
@@ -2255,6 +2691,10 @@ static void ioapic_destroy_irqdomain(int idx)
 	}
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/apic.c|2364| <<apic_bsp_setup>> setup_IO_APIC();
+ */
 void __init setup_IO_APIC(void)
 {
 	int ioapic;
@@ -2903,6 +3343,23 @@ static void mp_setup_entry(struct irq_cfg *cfg, struct mp_chip_data *data,
 		entry->mask = IOAPIC_UNMASKED;
 }
 
+/*
+ * [0] mp_irqdomain_alloc
+ * [0] __irq_domain_alloc_irqs
+ * [0] alloc_isa_irq_from_domain.isra.11
+ * [0] mp_map_pin_to_irq
+ * [0] setup_IO_APIC
+ * [0] apic_bsp_setup
+ * [0] native_smp_prepare_cpus
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - kernel/irq/irqdomain.c|1456| <<irq_domain_alloc_irqs_hierarchy>> return domain->ops->alloc(domain, irq_base, nr_irqs, arg);
+ *
+ * struct irq_domain_ops mp_ioapic_irqdomain_ops.alloc = mp_irqdomain_alloc()
+ */
 int mp_irqdomain_alloc(struct irq_domain *domain, unsigned int virq,
 		       unsigned int nr_irqs, void *arg)
 {
@@ -2928,6 +3385,9 @@ int mp_irqdomain_alloc(struct irq_domain *domain, unsigned int virq,
 	if (!data)
 		return -ENOMEM;
 
+	/*
+	 * info->ioapic_entry是struct IO_APIC_route_entry *ioapic_entry;
+	 */
 	info->ioapic_entry = &data->entry;
 	ret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, info);
 	if (ret < 0) {
@@ -2961,6 +3421,12 @@ int mp_irqdomain_alloc(struct irq_domain *domain, unsigned int virq,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - kernel/irq/irqdomain.c|1442| <<irq_domain_free_irqs_hierarchy>> domain->ops->free(domain, irq_base, nr_irqs);
+ *
+ * struct irq_domain_ops mp_ioapic_irqdomain_ops.free = mp_irqdomain_free()
+ */
 void mp_irqdomain_free(struct irq_domain *domain, unsigned int virq,
 		       unsigned int nr_irqs)
 {
@@ -2979,6 +3445,12 @@ void mp_irqdomain_free(struct irq_domain *domain, unsigned int virq,
 	irq_domain_free_irqs_top(domain, virq, nr_irqs);
 }
 
+/*
+ * called by:
+ *   - kernel/irq/irqdomain.c|1780| <<__irq_domain_activate_irq>> domain->ops->activate(domain, irq_data);
+ *
+ * struct irq_domain_ops mp_ioapic_irqdomain_ops.activate = mp_irqdomain_activate()
+ */
 void mp_irqdomain_activate(struct irq_domain *domain,
 			   struct irq_data *irq_data)
 {
@@ -2987,11 +3459,23 @@ void mp_irqdomain_activate(struct irq_domain *domain,
 	struct mp_chip_data *data = irq_data->chip_data;
 
 	raw_spin_lock_irqsave(&ioapic_lock, flags);
+	/*
+	 * struct irq_pin_list {
+	 *         struct list_head list;
+	 *         int apic, pin;
+	 * };
+	 */
 	for_each_irq_pin(entry, data->irq_2_pin)
 		__ioapic_write_entry(entry->apic, entry->pin, data->entry);
 	raw_spin_unlock_irqrestore(&ioapic_lock, flags);
 }
 
+/*
+ * called by:
+ *   - kernel/irq/irqdomain.c|1790| <<__irq_domain_deactivate_irq>> domain->ops->deactivate(domain, irq_data);
+ *
+ * struct irq_domain_ops mp_ioapic_irqdomain_ops.deactivate = mp_irqdomain_deactivate()
+ */
 void mp_irqdomain_deactivate(struct irq_domain *domain,
 			     struct irq_data *irq_data)
 {
@@ -3000,11 +3484,25 @@ void mp_irqdomain_deactivate(struct irq_domain *domain,
 			  (int)irq_data->hwirq);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|3230| <<mp_irqdomain_alloc>> ioapic = mp_irqdomain_ioapic_idx(domain);
+ *   - arch/x86/kernel/apic/io_apic.c|3282| <<mp_irqdomain_free>> __remove_pin_from_irq(data, mp_irqdomain_ioapic_idx(domain),
+ *   - arch/x86/kernel/apic/io_apic.c|3307| <<mp_irqdomain_deactivate>> ioapic_mask_entry(mp_irqdomain_ioapic_idx(domain),
+ *   - arch/x86/kernel/devicetree.c|218| <<dt_irqdomain_alloc>> tmp.ioapic_id = mpc_ioapic_id(mp_irqdomain_ioapic_idx(domain));
+ */
 int mp_irqdomain_ioapic_idx(struct irq_domain *domain)
 {
 	return (int)(long)domain->host_data;
 }
 
+/*
+ * used by:
+ *   - arch/x86/kernel/acpi/boot.c|453| <<acpi_parse_ioapic>> .ops = &mp_ioapic_irqdomain_ops,
+ *   - arch/x86/kernel/acpi/boot.c|805| <<acpi_register_ioapic>> .ops = &mp_ioapic_irqdomain_ops,
+ *   - arch/x86/kernel/mpparse.c|120| <<MP_ioapic_info>> .ops = &mp_ioapic_irqdomain_ops,
+ *   - arch/x86/platform/sfi/sfi.c|82| <<sfi_parse_ioapic>> .ops = &mp_ioapic_irqdomain_ops,
+ */
 const struct irq_domain_ops mp_ioapic_irqdomain_ops = {
 	.alloc		= mp_irqdomain_alloc,
 	.free		= mp_irqdomain_free,
diff --git a/arch/x86/kernel/apic/msi.c b/arch/x86/kernel/apic/msi.c
index f10e7f9..9369d3b 100644
--- a/arch/x86/kernel/apic/msi.c
+++ b/arch/x86/kernel/apic/msi.c
@@ -24,8 +24,139 @@
 #include <asm/apic.h>
 #include <asm/irq_remapping.h>
 
+/*
+ * 主要的数据结构:
+ *
+ * 122 static struct irq_chip pci_msi_controller = {
+ * 123         .name                   = "PCI-MSI",
+ * 124         .irq_unmask             = pci_msi_unmask_irq,
+ * 125         .irq_mask               = pci_msi_mask_irq,
+ * 126         .irq_ack                = irq_chip_ack_parent,
+ * 127         .irq_retrigger          = irq_chip_retrigger_hierarchy,
+ * 128         .irq_compose_msi_msg    = irq_msi_compose_msg,
+ * 129         .flags                  = IRQCHIP_SKIP_SET_WAKE,
+ * 130 };
+ *
+ *
+ * 在msi_domain_update_chip_ops()中设置chip->irq_set_affinity = msi_domain_set_affinity
+ * 247 static struct irq_chip pci_msi_ir_controller = {
+ * 248         .name                   = "IR-PCI-MSI",
+ * 249         .irq_unmask             = pci_msi_unmask_irq,
+ * 250         .irq_mask               = pci_msi_mask_irq,
+ * 251         .irq_ack                = irq_chip_ack_parent,
+ * 252         .irq_retrigger          = irq_chip_retrigger_hierarchy,
+ * 253         .irq_set_vcpu_affinity  = irq_chip_set_vcpu_affinity_parent,
+ * 254         .flags                  = IRQCHIP_SKIP_SET_WAKE,
+ * 255 };
+ *
+ * 297 static struct irq_chip dmar_msi_controller = {
+ * 298         .name                   = "DMAR-MSI",
+ * 299         .irq_unmask             = dmar_msi_unmask,
+ * 300         .irq_mask               = dmar_msi_mask,
+ * 301         .irq_ack                = irq_chip_ack_parent,
+ * 302         .irq_set_affinity       = msi_domain_set_affinity,
+ * 303         .irq_retrigger          = irq_chip_retrigger_hierarchy,
+ * 304         .irq_compose_msi_msg    = irq_msi_compose_msg,
+ * 305         .irq_write_msi_msg      = dmar_msi_write_msg,
+ * 306         .flags                  = IRQCHIP_SKIP_SET_WAKE,
+ * 307 };
+ *
+ * 406 static struct irq_chip hpet_msi_controller __ro_after_init = {
+ * 407         .name = "HPET-MSI",
+ * 408         .irq_unmask = hpet_msi_unmask,
+ * 409         .irq_mask = hpet_msi_mask,
+ * 410         .irq_ack = irq_chip_ack_parent,
+ * 411         .irq_set_affinity = msi_domain_set_affinity,
+ * 412         .irq_retrigger = irq_chip_retrigger_hierarchy,
+ * 413         .irq_compose_msi_msg = irq_msi_compose_msg,
+ * 414         .irq_write_msi_msg = hpet_msi_write_msg,
+ * 415         .flags = IRQCHIP_SKIP_SET_WAKE,
+ * 416 };
+ */
+
+/*
+ * 相关的数据结构:
+ *
+ * 118 struct x86_msi_ops x86_msi __ro_after_init = {
+ * 119         .setup_msi_irqs         = native_setup_msi_irqs,
+ * 120         .teardown_msi_irq       = native_teardown_msi_irq,
+ * 121         .teardown_msi_irqs      = default_teardown_msi_irqs,
+ * 122         .restore_msi_irqs       = default_restore_msi_irqs,
+ * 123 };
+ */
+
+/*
+ * nvme申请vector的过程
+ * nvme_reset_work()
+ * nvme_setup_io_queues()
+ * pci_alloc_irq_vectors()
+ * pci_alloc_irq_vectors_affinity()
+ * __pci_enable_msix_range()
+ * __pci_enable_msix()
+ * msix_capability_init()
+ * pci_msi_setup_msi_irqs() (domain=NULL)
+ * arch_setup_msi_irqs()
+ * x86_msi.setup_msi_irqs = native_setup_msi_irqs()
+ * msi_domain_alloc_irqs()
+ * __irq_domain_alloc_irqs()
+ * irq_domain_alloc_irqs_hierarchy()
+ * domain->ops->alloc = msi_domain_alloc()
+ * irq_domain_alloc_irqs_parent()
+ * irq_domain_alloc_irqs_hierarchy()
+ * domain->ops->alloc = x86_vector_alloc_irqs()
+ * assign_irq_vector_policy()
+ * assign_irq_vector()
+ * __assign_irq_vector()
+ *
+ * nvme hotplug申请vector的过程
+ * [0] __assign_irq_vector
+ * [0] assign_irq_vector
+ * [0] msi_domain_set_affinity
+ * [0] irq_do_set_affinity
+ * [0] irq_startup
+ * [0] irq_affinity_online_cpu
+ * [0] cpuhp_invoke_callback
+ * [0] cpuhp_thread_fun
+ * [0] smpboot_thread_fn
+ * [0] kthread
+ * [0] ret_from_fork
+ */
+
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/msi.c|85| <<native_setup_msi_irqs>> domain = msi_default_domain;
+ *   - arch/x86/kernel/apic/msi.c|152| <<arch_init_msi_domain>> msi_default_domain =
+ *   - arch/x86/kernel/apic/msi.c|157| <<arch_init_msi_domain>> if (!msi_default_domain)
+ *
+ * msi_default_domain在arch_init_msi_domain()创建
+ *
+ * name是"PCI-MSI"
+ * msi_domain_info是pci_msi_domain_info
+ * parent是x86_vector_domain
+ */
 static struct irq_domain *msi_default_domain;
 
+/*
+ * [  234.140616] orabug: irq_msi_compose_msg() vector=65, apicid=13
+ * [  234.140617] CPU: 1 PID: 13 Comm: migration/1 Not tainted 4.14.113 #2
+ * [  234.140618] Call Trace:
+ * [  234.140623]  dump_stack+0x46/0x62
+ * [  234.140625]  irq_chip_compose_msi_msg+0x42/0x50
+ * [  234.140626]  msi_domain_set_affinity+0x35/0x60
+ * [  234.140628]  irq_do_set_affinity+0x28/0xa0
+ * [  234.140630]  irq_migrate_all_off_this_cpu+0x19c/0x2a0
+ * [  234.140631]  fixup_irqs+0x1e/0xe0
+ * [  234.140633]  native_cpu_disable+0x1b/0x30
+ * [  234.140635]  take_cpu_down+0x34/0x90
+ * [  234.140636]  multi_cpu_stop+0x86/0xb0
+ * [  234.140637]  ? cpu_stop_queue_work+0xa0/0xa0
+ * [  234.140638]  cpu_stopper_thread+0x76/0xe0
+ * [  234.140640]  smpboot_thread_fn+0x109/0x160
+ * [  234.140641]  kthread+0xfa/0x130
+ * [  234.140642]  ? sort_range+0x20/0x20
+ * [  234.140643]  ? kthread_create_on_node+0x40/0x40
+ * [  234.140645]  ret_from_fork+0x35/0x40
+ */
 static void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
 {
 	struct irq_cfg *cfg = irqd_cfg(data);
@@ -35,6 +166,11 @@ static void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
 	if (x2apic_enabled())
 		msg->address_hi |= MSI_ADDR_EXT_DEST_ID(cfg->dest_apicid);
 
+	/*
+	 * 在以下修改dest_apicid:
+	 *   - arch/x86/kernel/apic/vector.c|542| <<__assign_irq_vector>> &d->cfg.dest_apicid));
+	 */
+
 	msg->address_lo =
 		MSI_ADDR_BASE_LO |
 		((apic->irq_dest_mode == 0) ?
@@ -58,6 +194,9 @@ static void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
  * IRQ Chip for MSI PCI/PCI-X/PCI-Express Devices,
  * which implement the MSI or MSI-X Capability Structure.
  */
+/*
+ * struct msi_domain_info pci_msi_domain_info.chip = pci_msi_controller
+ */
 static struct irq_chip pci_msi_controller = {
 	.name			= "PCI-MSI",
 	.irq_unmask		= pci_msi_unmask_irq,
@@ -68,6 +207,15 @@ static struct irq_chip pci_msi_controller = {
 	.flags			= IRQCHIP_SKIP_SET_WAKE,
 };
 
+/*
+ * arch/x86/kernel/x86_init.c|119| <<global>> .setup_msi_irqs = native_setup_msi_irqs,
+ * 118 struct x86_msi_ops x86_msi __ro_after_init = {
+ * 119         .setup_msi_irqs         = native_setup_msi_irqs,
+ * 120         .teardown_msi_irq       = native_teardown_msi_irq,
+ * 121         .teardown_msi_irqs      = default_teardown_msi_irqs,
+ * 122         .restore_msi_irqs       = default_restore_msi_irqs,
+ * 123 };
+ */
 int native_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
 {
 	struct irq_domain *domain;
@@ -77,7 +225,17 @@ int native_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
 	info.type = X86_IRQ_ALLOC_TYPE_MSI;
 	info.msi_dev = dev;
 
+	/*
+	 * 对于有iommu的情况下, name是"INTEL-IR-MSI-0-2"
+	 */
 	domain = irq_remapping_get_irq_domain(&info);
+	/*
+	 * msi_default_domain在arch_init_msi_domain()创建
+	 *
+	 * name是"PCI-MSI"
+	 * msi_domain_info是pci_msi_domain_info
+	 * parent是x86_vector_domain
+	 */
 	if (domain == NULL)
 		domain = msi_default_domain;
 	if (domain == NULL)
@@ -122,12 +280,20 @@ void pci_msi_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc)
 }
 EXPORT_SYMBOL_GPL(pci_msi_set_desc);
 
+/*
+ * struct msi_domain_info pci_msi_domain_info.ops = pci_msi_domain_ops
+ * struct msi_domain_info pci_msi_ir_domain_info.ops = pci_msi_domain_ops
+ */
 static struct msi_domain_ops pci_msi_domain_ops = {
 	.get_hwirq	= pci_msi_get_hwirq,
 	.msi_prepare	= pci_msi_prepare,
 	.set_desc	= pci_msi_set_desc,
 };
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/msi.c|159| <<arch_init_msi_domain>> pci_msi_create_irq_domain(fn, &pci_msi_domain_info,
+ */
 static struct msi_domain_info pci_msi_domain_info = {
 	.flags		= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
 			  MSI_FLAG_PCI_MSIX,
@@ -137,6 +303,9 @@ static struct msi_domain_info pci_msi_domain_info = {
 	.handler_name	= "edge",
 };
 
+/*
+ * arch/x86/kernel/apic/vector.c|672| <<arch_early_irq_init>> arch_init_msi_domain(x86_vector_domain);
+ */
 void __init arch_init_msi_domain(struct irq_domain *parent)
 {
 	struct fwnode_handle *fn;
@@ -164,6 +333,9 @@ static struct irq_chip pci_msi_ir_controller = {
 	.irq_retrigger		= irq_chip_retrigger_hierarchy,
 	.irq_set_vcpu_affinity	= irq_chip_set_vcpu_affinity_parent,
 	.flags			= IRQCHIP_SKIP_SET_WAKE,
+	/*
+	 * 在msi_domain_update_chip_ops()中设置chip->irq_set_affinity = msi_domain_set_affinity
+	 */
 };
 
 static struct msi_domain_info pci_msi_ir_domain_info = {
@@ -391,3 +563,29 @@ int hpet_assign_irq(struct irq_domain *domain, struct hpet_dev *dev,
 	return irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, &info);
 }
 #endif
+
+/*
+ * msi的struct irq_domain_ops的例子
+ *
+ * kernel/irq/msi.c
+ *
+ * 166 static const struct irq_domain_ops msi_domain_ops = {
+ * 167         .alloc          = msi_domain_alloc,
+ * 168         .free           = msi_domain_free,
+ * 169         .activate       = msi_domain_activate,
+ * 170         .deactivate     = msi_domain_deactivate,
+ * 171 };
+ *
+ *
+ * info的例子:
+ * struct msi_domain_info pci_msi_domain_info
+ *
+ * 148 static struct msi_domain_info pci_msi_domain_info = {
+ * 149         .flags          = MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
+ * 150                           MSI_FLAG_PCI_MSIX,
+ * 151         .ops            = &pci_msi_domain_ops,
+ * 152         .chip           = &pci_msi_controller,
+ * 153         .handler        = handle_edge_irq,
+ * 154         .handler_name   = "edge",
+ * 155 };
+ */
diff --git a/arch/x86/kernel/apic/probe_32.c b/arch/x86/kernel/apic/probe_32.c
index 6328765..6e18a9f 100644
--- a/arch/x86/kernel/apic/probe_32.c
+++ b/arch/x86/kernel/apic/probe_32.c
@@ -27,6 +27,12 @@
 #include <asm/acpi.h>
 #include <asm/e820/api.h>
 
+/*
+ * 主要的数据结构:
+ *
+ * struct apic apic_default
+ */
+
 #ifdef CONFIG_HOTPLUG_CPU
 #define DEFAULT_SEND_IPI	(1)
 #else
diff --git a/arch/x86/kernel/apic/probe_64.c b/arch/x86/kernel/apic/probe_64.c
index c303054..df560b0 100644
--- a/arch/x86/kernel/apic/probe_64.c
+++ b/arch/x86/kernel/apic/probe_64.c
@@ -25,6 +25,14 @@
 /*
  * Check the APIC IDs in bios_cpu_apicid and choose the APIC mode.
  */
+/*
+ * [0] default_setup_apic_routing
+ * [0] native_smp_prepare_cpus
+ * [0] xen_hvm_smp_prepare_cpus
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ */
 void __init default_setup_apic_routing(void)
 {
 	struct apic **drv;
@@ -32,9 +40,20 @@ void __init default_setup_apic_routing(void)
 	enable_IR_x2apic();
 
 	for (drv = __apicdrivers; drv < __apicdrivers_end; drv++) {
+		/*
+		 * kvm上就检测出3个:
+		 * apic=flat, drv=Xen PV          --> arch/x86/xen/apic.c
+		 * apic=flat, drv=physical x2apic --> arch/x86/kernel/apic/x2apic_phys.c
+		 * apic=flat, drv=cluster x2apic  --> arch/x86/kernel/apic/x2apic_cluster.c
+		 * apic=flat, drv=physical flat   --> arch/x86/kernel/apic/apic_flat_64.c
+		 * apic=flat, drv=flat            --> arch/x86/kernel/apic/apic_flat_64.c
+		 */
 		if ((*drv)->probe && (*drv)->probe()) {
 			if (apic != *drv) {
 				apic = *drv;
+				/*
+				 * Switched APIC routing to cluster x2apic.
+				 */
 				pr_info("Switched APIC routing to %s.\n",
 					apic->name);
 			}
@@ -42,6 +61,13 @@ void __init default_setup_apic_routing(void)
 		}
 	}
 
+	/*
+	 * 在以下设置:
+	 *   - arch/x86/kernel/cpu/mshyperv.c|261| <<ms_hyperv_init_platform>> x86_platform.apic_post_init = hyperv_init;
+	 *   - arch/x86/kernel/vsmp_64.c|239| <<vsmp_init>> x86_platform.apic_post_init = vsmp_apic_post_init;
+	 *   - arch/x86/pci/xen.c|467| <<pci_xen_hvm_init>> x86_platform.apic_post_init = xen_msi_init;
+	 *   - arch/x86/xen/apic.c|226| <<xen_init_apic>> x86_platform.apic_post_init = xen_apic_check;
+	 */
 	if (x86_platform.apic_post_init)
 		x86_platform.apic_post_init();
 }
diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c
index b958082..76c24e6 100644
--- a/arch/x86/kernel/apic/vector.c
+++ b/arch/x86/kernel/apic/vector.c
@@ -22,6 +22,22 @@
 #include <asm/desc.h>
 #include <asm/irq_remapping.h>
 
+/*
+ * 主要的数据结构:
+ *
+ * 504 static const struct irq_domain_ops x86_vector_domain_ops = {
+ * 505         .alloc  = x86_vector_alloc_irqs,
+ * 506         .free   = x86_vector_free_irqs,
+ * 507 };
+ *
+ * 669 static struct irq_chip lapic_controller = {
+ * 670         .name                   = "APIC",
+ * 671         .irq_ack                = apic_ack_edge,
+ * 672         .irq_set_affinity       = apic_set_affinity,
+ * 673         .irq_retrigger          = apic_retrigger_irq,
+ * 674 };
+ */
+
 struct apic_chip_data {
 	struct irq_cfg		cfg;
 	cpumask_var_t		domain;
@@ -29,15 +45,78 @@ struct apic_chip_data {
 	u8			move_in_progress : 1;
 };
 
+/*
+ * 在以下被使用:
+ *   - arch/x86/include/asm/irq_remapping.h|64| <<arch_get_ir_parent_domain>> return x86_vector_domain;
+ *   - arch/x86/kernel/apic/io_apic.c|2581| <<mp_irqdomain_create>> parent = x86_vector_domain;
+ *   - arch/x86/kernel/apic/io_apic.c|3340| <<mp_irqdomain_alloc>> irq_data->chip = (domain->parent == x86_vector_domain) ?
+ *   - arch/x86/kernel/apic/msi.c|267| <<dmar_get_irq_domain>> x86_vector_domain);
+ *   - arch/x86/kernel/apic/msi.c|366| <<hpet_create_irq_domain>> if (x86_vector_domain == NULL)
+ *   - arch/x86/kernel/apic/msi.c|381| <<hpet_create_irq_domain>> parent = x86_vector_domain;
+ *   - arch/x86/kernel/apic/vector.c|389| <<x86_vector_free_irqs>> irq_data = irq_domain_get_irq_data(x86_vector_domain, virq + i);
+ *   - arch/x86/kernel/apic/vector.c|528| <<arch_early_irq_init>> x86_vector_domain = irq_domain_create_tree(fn, &x86_vector_domain_ops,
+ *   - arch/x86/kernel/apic/vector.c|530| <<arch_early_irq_init>> BUG_ON(x86_vector_domain == NULL);
+ *   - arch/x86/kernel/apic/vector.c|532| <<arch_early_irq_init>> irq_set_default_host(x86_vector_domain);
+ *   - arch/x86/kernel/apic/vector.c|534| <<arch_early_irq_init>> arch_init_msi_domain(x86_vector_domain);
+ *   - arch/x86/kernel/apic/vector.c|535| <<arch_early_irq_init>> arch_init_htirq_domain(x86_vector_domain);
+ *   - arch/x86/kernel/apic/vector.c|802| <<irq_force_complete_move>> irqdata = irq_domain_get_irq_data(x86_vector_domain,
+ *   - arch/x86/platform/uv/uv_irq.c|176| <<uv_get_irq_domain>> uv_domain->parent = x86_vector_domain;
+ *   - drivers/pci/host/pci-hyperv.c|1292| <<hv_pcie_init_irq_domain>> x86_vector_domain);
+ *   - drivers/pci/host/vmd.c|640| <<vmd_enable_domain>> x86_vector_domain);
+ *
+ * ops在arch_early_irq_init()被设置为x86_vector_domain_ops
+ */
 struct irq_domain *x86_vector_domain;
 EXPORT_SYMBOL_GPL(x86_vector_domain);
 static DEFINE_RAW_SPINLOCK(vector_lock);
+/*
+ * vector_searchmask在以下声明和使用:
+ *   - arch/x86/kernel/apic/vector.c|80| <<global>> static cpumask_var_t vector_cpumask, vector_searchmask, searched_cpumask;
+ *   - arch/x86/kernel/apic/vector.c|419| <<__assign_irq_vector>> cpumask_and(vector_searchmask, vector_cpumask, cpu_online_mask);
+ *   - arch/x86/kernel/apic/vector.c|420| <<__assign_irq_vector>> if (!cpumask_intersects(vector_searchmask, mask))
+ *   - arch/x86/kernel/apic/vector.c|451| <<__assign_irq_vector>> for_each_cpu(new_cpu, vector_searchmask) {
+ *   - arch/x86/kernel/apic/vector.c|464| <<__assign_irq_vector>> for_each_cpu(new_cpu, vector_searchmask)
+ *   - arch/x86/kernel/apic/vector.c|502| <<__assign_irq_vector>> cpumask_and(vector_searchmask, vector_searchmask, mask);
+ *   - arch/x86/kernel/apic/vector.c|503| <<__assign_irq_vector>> BUG_ON(apic->cpu_mask_to_apicid(vector_searchmask, irqdata,
+ *   - arch/x86/kernel/apic/vector.c|796| <<arch_early_irq_init>> BUG_ON(!alloc_cpumask_var(&vector_searchmask, GFP_KERNEL));
+ *
+ * searched_cpumask在以下声明和使用:
+ *   - arch/x86/kernel/apic/vector.c|72| <<global>> static cpumask_var_t vector_cpumask, vector_searchmask, searched_cpumask;
+ *   - arch/x86/kernel/apic/vector.c|312| <<__assign_irq_vector>> cpumask_clear(searched_cpumask);
+ *   - arch/x86/kernel/apic/vector.c|384| <<__assign_irq_vector>> cpumask_or(searched_cpumask, searched_cpumask, vector_cpumask);
+ *   - arch/x86/kernel/apic/vector.c|385| <<__assign_irq_vector>> cpumask_andnot(vector_cpumask, mask, searched_cpumask);
+ *   - arch/x86/kernel/apic/vector.c|705| <<arch_early_irq_init>> BUG_ON(!alloc_cpumask_var(&searched_cpumask, GFP_KERNEL));
+ */
 static cpumask_var_t vector_cpumask, vector_searchmask, searched_cpumask;
+/*
+ * used by:
+ *
+ *   - arch/x86/kernel/apic/vector.c|435| <<x86_vector_alloc_irqs>> irq_data->chip = &lapic_controller;
+ *
+ * 669 static struct irq_chip lapic_controller = {
+ * 670         .name                   = "APIC",
+ * 671         .irq_ack                = apic_ack_edge,
+ * 672         .irq_set_affinity       = apic_set_affinity,
+ * 673         .irq_retrigger          = apic_retrigger_irq,
+ * 674 };
+ */
 static struct irq_chip lapic_controller;
 #ifdef	CONFIG_X86_IO_APIC
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/vector.c|399| <<x86_vector_free_irqs>> legacy_irq_data[virq + i] = NULL;
+ *   - arch/x86/kernel/apic/vector.c|425| <<x86_vector_alloc_irqs>> if (virq + i < nr_legacy_irqs() && legacy_irq_data[virq + i])
+ *   - arch/x86/kernel/apic/vector.c|426| <<x86_vector_alloc_irqs>> data = legacy_irq_data[virq + i];
+ *   - arch/x86/kernel/apic/vector.c|508| <<init_legacy_irqs>> data = legacy_irq_data[i] = alloc_apic_chip_data(node);
+ */
 static struct apic_chip_data *legacy_irq_data[NR_IRQS_LEGACY];
 #endif
 
+/*
+ * called by:
+ *   - arch/x86/kernel/smpboot.c|256| <<start_secondary>> lock_vector_lock();
+ *   - arch/x86/kernel/smpboot.c|1562| <<cpu_disable_common>> lock_vector_lock();
+ */
 void lock_vector_lock(void)
 {
 	/* Used to the online set of cpus does not change
@@ -51,6 +130,12 @@ void unlock_vector_lock(void)
 	raw_spin_unlock(&vector_lock);
 }
 
+/*
+ * 返回irq_data->parent_data->chip_data或者irq_data->chip_data
+ *
+ * parent_data是: struct irq_data *parent_data;
+ * chip_data是: void *chip_data;
+ */
 static struct apic_chip_data *apic_chip_data(struct irq_data *irq_data)
 {
 	if (!irq_data)
@@ -59,11 +144,34 @@ static struct apic_chip_data *apic_chip_data(struct irq_data *irq_data)
 	while (irq_data->parent_data)
 		irq_data = irq_data->parent_data;
 
+	/*
+	 * chip_data在以下设置:
+	 *   - arch/x86/kernel/apic/io_apic.c|3385| <<mp_irqdomain_alloc>> irq_data->chip_data = data;
+	 *   - arch/x86/kernel/apic/vector.c|563| <<x86_vector_alloc_irqs>> irq_data->chip_data = data;
+	 *   - drivers/iommu/amd_iommu.c|4161| <<irq_remapping_alloc>> irq_data->chip_data = data;
+	 *   - drivers/iommu/intel_irq_remapping.c|1372| <<intel_irq_remapping_alloc>> irq_data->chip_data = ird;
+	 *   - drivers/pci/host/pci-hyperv.c|1224| <<hv_compose_msi_msg>> data->chip_data = int_desc;
+	 *   - kernel/irq/chip.c|167| <<irq_set_chip_data>> desc->irq_data.chip_data = data;
+	 *   - kernel/irq/irqdomain.c|1403| <<irq_domain_set_hwirq_and_chip>> irq_data->chip_data = chip_data;
+	 *
+	 * void *chip_data
+	 */
 	return irq_data->chip_data;
 }
 
+/*
+ * irq_data是struct irq_desc的struct irq_data irq_data
+ */
 struct irq_cfg *irqd_cfg(struct irq_data *irq_data)
 {
+	/*
+	 * irq_data是struct irq_desc的struct irq_data irq_data
+	 *
+	 * 返回irq_data->parent_data->chip_data或者irq_data->chip_data
+	 *
+	 * parent_data是: struct irq_data *parent_data;
+	 * chip_data是: void *chip_data;
+	 */
 	struct apic_chip_data *data = apic_chip_data(irq_data);
 
 	return data ? &data->cfg : NULL;
@@ -103,6 +211,146 @@ static void free_apic_chip_data(struct apic_chip_data *data)
 	}
 }
 
+/*
+ * [0] assign_irq_vector
+ * [0] x86_vector_alloc_irqs
+ * [0] msi_domain_alloc
+ * [0] __irq_domain_alloc_irqs
+ * [0] msi_domain_alloc_irqs
+ * [0] native_setup_msi_irqs
+ * [0] __pci_enable_msix_range
+ * [0] pci_alloc_irq_vectors_affinity
+ * [0] vp_find_vqs_msix
+ * [0] vp_find_vqs
+ * [0] vp_modern_find_vqs
+ * [0] virtscsi_init
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * [0] assign_irq_vector
+ * [0] msi_domain_set_affinity
+ * [0] irq_do_set_affinity
+ * [0] irq_startup
+ * [0] __setup_irq
+ * [0] request_threaded_irq
+ * [0] vp_find_vqs_msix
+ * [0] vp_find_vqs
+ * [0] vp_modern_find_vqs
+ * [0] virtscsi_init
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * nvme申请vector的过程
+ * nvme_reset_work()
+ * nvme_setup_io_queues()
+ * pci_alloc_irq_vectors()
+ * pci_alloc_irq_vectors_affinity()
+ * __pci_enable_msix_range()
+ * __pci_enable_msix()
+ * msix_capability_init()
+ * pci_msi_setup_msi_irqs() (domain=NULL)
+ * arch_setup_msi_irqs()
+ * x86_msi.setup_msi_irqs = native_setup_msi_irqs()
+ * msi_domain_alloc_irqs()
+ * __irq_domain_alloc_irqs()
+ * irq_domain_alloc_irqs_hierarchy()
+ * domain->ops->alloc = msi_domain_alloc()
+ * irq_domain_alloc_irqs_parent()
+ * irq_domain_alloc_irqs_hierarchy()
+ * domain->ops->alloc = x86_vector_alloc_irqs()
+ * assign_irq_vector_policy()
+ * assign_irq_vector()
+ * __assign_irq_vector()
+ *
+ * [0] __assign_irq_vector
+ * [0] assign_irq_vector
+ * [0] msi_domain_set_affinity
+ * [0] irq_do_set_affinity
+ * [0] irq_startup
+ * [0] __setup_irq
+ * [0] request_threaded_irq
+ * [0] pci_request_irq
+ * [0] queue_request_irq
+ * [0] nvme_reset_work
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * nvme hotplug申请vector的过程
+ * [0] __assign_irq_vector
+ * [0] assign_irq_vector
+ * [0] msi_domain_set_affinity
+ * [0] irq_do_set_affinity
+ * [0] irq_startup
+ * [0] irq_affinity_online_cpu
+ * [0] cpuhp_invoke_callback
+ * [0] cpuhp_thread_fun
+ * [0] smpboot_thread_fn
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ *
+ * 用了iommu irq remap的例子:
+ *
+ * [0] __assign_irq_vector
+ * [0] assign_irq_vector
+ * [0] x86_vector_alloc_irqs
+ * [0] intel_irq_remapping_alloc
+ * [0] msi_domain_alloc
+ * [0] __irq_domain_alloc_irqs
+ * [0] msi_domain_alloc_irqs
+ * [0] native_setup_msi_irqs
+ * [0] __pci_enable_msix_range
+ * [0] pci_alloc_irq_vectors_affinity
+ * [0] nvme_reset_work
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] __assign_irq_vector
+ * [0] assign_irq_vector
+ * [0] intel_ir_set_affinity
+ * [0] msi_domain_set_affinity
+ * [0] irq_do_set_affinity
+ * [0] irq_startup
+ * [0] __setup_irq
+ * [0] request_threaded_irq
+ * [0] pci_request_irq
+ * [0] queue_request_irq
+ * [0] nvme_reset_work
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|244| <<assign_irq_vector>> err = __assign_irq_vector(irq, data, mask, irqdata);
+ *
+ * 开iommu的irq remap是cluster x2apic
+ * 不开是physical x2apic
+ */
 static int __assign_irq_vector(int irq, struct apic_chip_data *d,
 			       const struct cpumask *mask,
 			       struct irq_data *irqdata)
@@ -123,6 +371,12 @@ static int __assign_irq_vector(int irq, struct apic_chip_data *d,
 	int cpu, vector;
 
 	/*
+	 * 以qemu上nvme为例子, 这个函数会进来2次
+	 * 第一次mask = 0-3
+	 * 第二次mask = 1
+	 */
+
+	/*
 	 * If there is still a move in progress or the previous move has not
 	 * been cleaned up completely, tell the caller to come back later.
 	 */
@@ -132,12 +386,37 @@ static int __assign_irq_vector(int irq, struct apic_chip_data *d,
 
 	/* Only try and allocate irqs on cpus that are present */
 	cpumask_clear(d->old_domain);
+	/*
+	 * searched_cpumask在以下声明和使用: 
+	 *   - arch/x86/kernel/apic/vector.c|72| <<global>> static cpumask_var_t vector_cpumask, vector_searchmask, searched_cpumask;
+	 *   - arch/x86/kernel/apic/vector.c|312| <<__assign_irq_vector>> cpumask_clear(searched_cpumask);
+	 *   - arch/x86/kernel/apic/vector.c|384| <<__assign_irq_vector>> cpumask_or(searched_cpumask, searched_cpumask, vector_cpumask);
+	 *   - arch/x86/kernel/apic/vector.c|385| <<__assign_irq_vector>> cpumask_andnot(vector_cpumask, mask, searched_cpumask);
+	 *   - arch/x86/kernel/apic/vector.c|705| <<arch_early_irq_init>> BUG_ON(!alloc_cpumask_var(&searched_cpumask, GFP_KERNEL));
+	 */
 	cpumask_clear(searched_cpumask);
 	cpu = cpumask_first_and(mask, cpu_online_mask);
+	/*
+	 * mask可以用cpumask_pr_args()打印
+	 *
+	 * cpu初始化是0
+	 */
 	while (cpu < nr_cpu_ids) {
 		int new_cpu, offset;
 
 		/* Get the possible target cpus for @mask/@cpu from the apic */
+		/*
+		 * x2apic_cluster就是cluster_vector_allocation_domain()
+		 *
+		 * 结果返回到vector_cpumask
+		 *
+		 * 以qemu上nvme为例子, 这个函数会进来2次
+		 * 第一次mask = 0-3
+		 * 第二次mask = 1
+		 *
+		 * 用x2apic physical的时候vector_cpumask分别是1和1
+		 * 用iommu remap的x2apic cluser的时候分别是0-3和1
+		 */
 		apic->vector_allocation_domain(cpu, vector_cpumask, mask);
 
 		/*
@@ -147,10 +426,16 @@ static int __assign_irq_vector(int irq, struct apic_chip_data *d,
 		 * succeed as well. If not, no point in trying to find a
 		 * vector in this mask.
 		 */
+		/*
+		 * vector_searchmask = vector_cpumask & cpu_online_mask
+		 */
 		cpumask_and(vector_searchmask, vector_cpumask, cpu_online_mask);
 		if (!cpumask_intersects(vector_searchmask, mask))
 			goto next_cpu;
 
+		/*
+		 * return 1 if vector_cpumask is subset of d->domain
+		 */
 		if (cpumask_subset(vector_cpumask, d->domain)) {
 			if (cpumask_equal(vector_cpumask, d->domain))
 				goto success;
@@ -158,6 +443,9 @@ static int __assign_irq_vector(int irq, struct apic_chip_data *d,
 			 * Mark the cpus which are not longer in the mask for
 			 * cleanup.
 			 */
+			/*
+			 * d->old_domain = d->domain & ~vector_cpumask
+			 */
 			cpumask_andnot(d->old_domain, d->domain, vector_cpumask);
 			vector = d->cfg.vector;
 			goto update;
@@ -176,10 +464,29 @@ static int __assign_irq_vector(int irq, struct apic_chip_data *d,
 		if (unlikely(current_vector == vector))
 			goto next_cpu;
 
+		/*
+		 * 在以下声明和使用:
+		 *   - arch/x86/kernel/traps.c|74| <<global>> DECLARE_BITMAP(used_vectors, NR_VECTORS);
+		 *   - arch/x86/kernel/apic/vector.c|461| <<__assign_irq_vector>> if (test_bit(vector, used_vectors))
+		 *   - arch/x86/kernel/idt.c|228| <<idt_setup_from_table>> set_bit(t->vector, used_vectors);
+		 *   - arch/x86/kernel/idt.c|316| <<idt_setup_apic_and_irq_gates>> for_each_clear_bit_from(i, used_vectors, FIRST_SYSTEM_VECTOR) {
+		 *   - arch/x86/kernel/idt.c|321| <<idt_setup_apic_and_irq_gates>> for_each_clear_bit_from(i, used_vectors, NR_VECTORS) {
+		 *   - arch/x86/kernel/idt.c|323| <<idt_setup_apic_and_irq_gates>> set_bit(i, used_vectors);
+		 *   - arch/x86/kernel/idt.c|361| <<update_intr_gate>> if (WARN_ON_ONCE(!test_bit(n, used_vectors)))
+		 *   - arch/x86/kernel/idt.c|369| <<alloc_intr_gate>> if (!test_and_set_bit(n, used_vectors))
+		 *   - arch/x86/kernel/irq.c|138| <<arch_show_interrupts>> if (test_bit(HYPERVISOR_CALLBACK_VECTOR, used_vectors)) {
+		 *   - arch/x86/kernel/irq.c|433| <<check_irq_vectors_for_cpu_disable>> if (!test_bit(vector, used_vectors) &&
+		 */
 		if (test_bit(vector, used_vectors))
 			goto next;
 
+		/*
+		 * vector_searchmask是这里申请vector要用的mask!!!!!
+		 */
 		for_each_cpu(new_cpu, vector_searchmask) {
+			/*
+			 * 如果这个vector在此cpu上已经被占用了, 则要进入下一个vector试一下
+			 */
 			if (!IS_ERR_OR_NULL(per_cpu(vector_irq, new_cpu)[vector]))
 				goto next;
 		}
@@ -189,6 +496,9 @@ static int __assign_irq_vector(int irq, struct apic_chip_data *d,
 		/* Schedule the old vector for cleanup on all cpus */
 		if (d->cfg.vector)
 			cpumask_copy(d->old_domain, d->domain);
+		/*
+		 * 这里很重要, 为cpu设置vector-irq
+		 */
 		for_each_cpu(new_cpu, vector_searchmask)
 			per_cpu(vector_irq, new_cpu)[vector] = irq_to_desc(irq);
 		goto update;
@@ -233,6 +543,13 @@ static int __assign_irq_vector(int irq, struct apic_chip_data *d,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|255| <<assign_irq_vector_policy>> return assign_irq_vector(irq, data, info->mask, irqdata);
+ *   - arch/x86/kernel/apic/vector.c|257| <<assign_irq_vector_policy>> assign_irq_vector(irq, data, cpumask_of_node(node), irqdata) == 0)
+ *   - arch/x86/kernel/apic/vector.c|259| <<assign_irq_vector_policy>> return assign_irq_vector(irq, data, apic->target_cpus(), irqdata);
+ *   - arch/x86/kernel/apic/vector.c|560| <<apic_set_affinity>> err = assign_irq_vector(irq, data, dest, irq_data);
+ */
 static int assign_irq_vector(int irq, struct apic_chip_data *data,
 			     const struct cpumask *mask,
 			     struct irq_data *irqdata)
@@ -246,6 +563,10 @@ static int assign_irq_vector(int irq, struct apic_chip_data *data,
 	return err;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|434| <<x86_vector_alloc_irqs>> err = assign_irq_vector_policy(virq + i, node, data, info,
+ */
 static int assign_irq_vector_policy(int irq, int node,
 				    struct apic_chip_data *data,
 				    struct irq_alloc_info *info,
@@ -259,6 +580,12 @@ static int assign_irq_vector_policy(int irq, int node,
 	return assign_irq_vector(irq, data, apic->target_cpus(), irqdata);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|649| <<x86_vector_free_irqs>> clear_irq_vector(virq + i, irq_data->chip_data);
+ *
+ * "echo 0 > /sys/devices/system/cpu/cpu1/online"的时候没调用这里
+ */
 static void clear_irq_vector(int irq, struct apic_chip_data *data)
 {
 	struct irq_desc *desc;
@@ -310,6 +637,9 @@ void copy_irq_alloc_info(struct irq_alloc_info *dst, struct irq_alloc_info *src)
 		memset(dst, 0, sizeof(*dst));
 }
 
+/*
+ * struct irq_domain_ops x86_vector_domain_ops.free = x86_vector_free_irqs()
+ */
 static void x86_vector_free_irqs(struct irq_domain *domain,
 				 unsigned int virq, unsigned int nr_irqs)
 {
@@ -335,6 +665,34 @@ static void x86_vector_free_irqs(struct irq_domain *domain,
 	}
 }
 
+/*
+ * [0] x86_vector_alloc_irqs
+ * [0] mp_irqdomain_alloc
+ * [0] __irq_domain_alloc_irqs
+ * [0] alloc_isa_irq_from_domain.isra.11
+ * [0] mp_map_pin_to_irq
+ * [0] setup_IO_APIC
+ * [0] apic_bsp_setup
+ * [0] native_smp_prepare_cpus
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * [0] x86_vector_alloc_irqs
+ * [0] msi_domain_alloc
+ * [0] __irq_domain_alloc_irqs
+ * [0] msi_domain_alloc_irqs
+ * [0] native_setup_msi_irqs
+ * [0] __pci_enable_msix_range
+ * [0] pci_alloc_irq_vectors_affinity
+ * [0] nvme_reset_work
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct irq_domain_ops x86_vector_domain_ops.alloc = x86_vector_alloc_irqs()
+ */
 static int x86_vector_alloc_irqs(struct irq_domain *domain, unsigned int virq,
 				 unsigned int nr_irqs, void *arg)
 {
@@ -391,11 +749,19 @@ static int x86_vector_alloc_irqs(struct irq_domain *domain, unsigned int virq,
 	return err;
 }
 
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/vector.c|653| <<arch_early_irq_init>> x86_vector_domain = irq_domain_create_tree(fn, &x86_vector_domain_ops,
+ */
 static const struct irq_domain_ops x86_vector_domain_ops = {
 	.alloc	= x86_vector_alloc_irqs,
 	.free	= x86_vector_free_irqs,
 };
 
+/*
+ * called by only:
+ *   - kernel/irq/irqdesc.c|490| <<early_irq_init>> initcnt = arch_probe_nr_irqs();
+ */
 int __init arch_probe_nr_irqs(void)
 {
 	int nr;
@@ -420,6 +786,13 @@ int __init arch_probe_nr_irqs(void)
 	 * We don't know if PIC is present at this point so we need to do
 	 * probe() to get the right number of legacy IRQs.
 	 */
+	/*
+	 * used by: 
+	 *   - arch/x86/kernel/i8259.c|422| <<global>> struct legacy_pic *legacy_pic = &default_legacy_pic;
+	 *   - arch/x86/kernel/acpi/boot.c|1387| <<acpi_reduced_hw_init>> legacy_pic = &null_legacy_pic;
+	 *   - arch/x86/kernel/i8259.c|319| <<probe_8259A>> legacy_pic = &null_legacy_pic;
+	 *   - arch/x86/platform/intel-mid/intel-mid.c|200| <<x86_intel_mid_early_setup>> legacy_pic = &null_legacy_pic;
+	 */
 	return legacy_pic->probe();
 }
 
@@ -471,6 +844,14 @@ int __init arch_early_irq_init(void)
 }
 
 /* Initialize vector_irq on a new cpu */
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|538| <<setup_vector_irq>> __setup_vector_irq(cpu);
+ *
+ * start_secondary()
+ *   -> setup_vector_irq()
+ *        -> __setup_vector_irq()
+ */
 static void __setup_vector_irq(int cpu)
 {
 	struct apic_chip_data *data;
@@ -479,11 +860,23 @@ static void __setup_vector_irq(int cpu)
 
 	/* Mark the inuse vectors */
 	for_each_irq_desc(irq, desc) {
+		/*
+		 * struct irq_data来自irq_desc->irq_data
+		 * 是嵌入进去的, 不是指针
+		 */
 		struct irq_data *idata = irq_desc_get_irq_data(desc);
 
+		/* struct irq_data的void *chip_data */
 		data = apic_chip_data(idata);
 		if (!data || !cpumask_test_cpu(cpu, data->domain))
 			continue;
+		/*
+		 * struct irq_cfg {
+		 *         unsigned int dest_apicid;
+		 *         u8           vector;
+		 *         u8           old_vector;
+		 * };
+		 */
 		vector = data->cfg.vector;
 		per_cpu(vector_irq, cpu)[vector] = desc;
 	}
@@ -493,6 +886,7 @@ static void __setup_vector_irq(int cpu)
 		if (IS_ERR_OR_NULL(desc))
 			continue;
 
+		/* struct irq_data的void *chip_data */
 		data = apic_chip_data(irq_desc_get_irq_data(desc));
 		if (!cpumask_test_cpu(cpu, data->domain))
 			per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
@@ -502,6 +896,10 @@ static void __setup_vector_irq(int cpu)
 /*
  * Setup the vector to irq mappings. Must be called with vector_lock held.
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/smpboot.c|257| <<start_secondary>> setup_vector_irq(smp_processor_id());
+ */
 void setup_vector_irq(int cpu)
 {
 	int irq;
@@ -520,6 +918,9 @@ void setup_vector_irq(int cpu)
 	__setup_vector_irq(cpu);
 }
 
+/*
+ * struct irq_chip lapic_controller.irq_retrigger = apic_retrigger_irq()
+ */
 static int apic_retrigger_irq(struct irq_data *irq_data)
 {
 	struct apic_chip_data *data = apic_chip_data(irq_data);
@@ -534,6 +935,9 @@ static int apic_retrigger_irq(struct irq_data *irq_data)
 	return 1;
 }
 
+/*
+ * struct irq_chip lapic_controller.irq_ack = apic_ack_edge()
+ */
 void apic_ack_edge(struct irq_data *data)
 {
 	irq_complete_move(irqd_cfg(data));
@@ -541,6 +945,9 @@ void apic_ack_edge(struct irq_data *data)
 	ack_APIC_irq();
 }
 
+/*
+ * struct irq_chip lapic_controller.irq_set_affinity = apic_set_affinity()
+ */
 static int apic_set_affinity(struct irq_data *irq_data,
 			     const struct cpumask *dest, bool force)
 {
@@ -557,6 +964,10 @@ static int apic_set_affinity(struct irq_data *irq_data,
 	return err ? err : IRQ_SET_MASK_OK;
 }
 
+/*
+ * used only by:
+ *   - arch/x86/kernel/apic/vector.c|560| <<x86_vector_alloc_irqs>> irq_data->chip = &lapic_controller;
+ */
 static struct irq_chip lapic_controller = {
 	.name			= "APIC",
 	.irq_ack		= apic_ack_edge,
@@ -584,6 +995,9 @@ void send_cleanup_vector(struct irq_cfg *cfg)
 		__send_cleanup_vector(data);
 }
 
+/*
+ * x86下没使用, ia64使用
+ */
 asmlinkage __visible void __irq_entry smp_irq_move_cleanup_interrupt(void)
 {
 	unsigned vector, me;
@@ -676,6 +1090,11 @@ static void __irq_complete_move(struct irq_cfg *cfg, unsigned vector)
 		__send_cleanup_vector(data);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|1915| <<ioapic_ack_level>> irq_complete_move(cfg);
+ *   - arch/x86/kernel/apic/vector.c|779| <<apic_ack_edge>> irq_complete_move(irqd_cfg(data));
+ */
 void irq_complete_move(struct irq_cfg *cfg)
 {
 	__irq_complete_move(cfg, ~get_irq_regs()->orig_ax);
@@ -684,6 +1103,31 @@ void irq_complete_move(struct irq_cfg *cfg)
 /*
  * Called from fixup_irqs() with @desc->lock held and interrupts disabled.
  */
+/*
+ * offline cpu 1的时候调用了好几次:
+ *
+ * [   35.122970] orabug: irq_force_complete_move()
+ * [   35.122972] CPU: 1 PID: 13 Comm: migration/1 Not tainted 4.14.113 #4
+ * [   35.122973] Call Trace:
+ * [   35.122975]  dump_stack+0x46/0x62
+ * [   35.122977]  irq_force_complete_move+0x18/0xe0
+ * [   35.122979]  irq_migrate_all_off_this_cpu+0x124/0x2a0
+ * [   35.122981]  fixup_irqs+0x1e/0x100
+ * [   35.122984]  native_cpu_disable+0x1b/0x30
+ * [   35.122985]  take_cpu_down+0x34/0x90
+ * [   35.122987]  multi_cpu_stop+0x86/0xb0
+ * [   35.122988]  ? cpu_stop_queue_work+0xa0/0xa0
+ * [   35.122989]  cpu_stopper_thread+0x76/0xe0
+ * [   35.122991]  smpboot_thread_fn+0x109/0x160
+ * [   35.122994]  kthread+0xfa/0x130
+ * [   35.122995]  ? sort_range+0x20/0x20
+ * [   35.122997]  ? kthread_create_on_node+0x40/0x40
+ * [   35.122999]  ret_from_fork+0x35/0x40
+ * [   35.123070] IRQ 29: no longer affine to CPU1 ----->>>> !!!!!
+ *
+ * called by:
+ *   - kernel/irq/cpuhotplug.c|94| <<migrate_one_irq>> irq_force_complete_move(desc);
+ */
 void irq_force_complete_move(struct irq_desc *desc)
 {
 	struct irq_data *irqdata;
@@ -794,6 +1238,12 @@ void irq_force_complete_move(struct irq_desc *desc)
 }
 #endif
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|948| <<print_local_APIC>> print_APIC_field(APIC_ISR);
+ *   - arch/x86/kernel/apic/vector.c|950| <<print_local_APIC>> print_APIC_field(APIC_TMR);
+ *   - arch/x86/kernel/apic/vector.c|952| <<print_local_APIC>> print_APIC_field(APIC_IRR);
+ */
 static void __init print_APIC_field(int base)
 {
 	int i;
@@ -806,6 +1256,10 @@ static void __init print_APIC_field(int base)
 	pr_cont("\n");
 }
 
+/*
+ * called by only:
+ *   - arch/x86/kernel/apic/vector.c|931| <<print_local_APICs>> smp_call_function_single(cpu, print_local_APIC, NULL, 1);
+ */
 static void __init print_local_APIC(void *dummy)
 {
 	unsigned int i, v, ver, maxlvt;
@@ -913,6 +1367,10 @@ static void __init print_local_APIC(void *dummy)
 	pr_cont("\n");
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|996| <<print_ICs>> print_local_APICs(show_lapic);
+ */
 static void __init print_local_APICs(int maxcpu)
 {
 	int cpu;
@@ -961,6 +1419,12 @@ static void __init print_PIC(void)
 	pr_debug("... PIC ELCR: %04x\n", v);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|1066| <<setup_show_lapic>> show_lapic = CONFIG_NR_CPUS;
+ *   - arch/x86/kernel/apic/vector.c|1070| <<setup_show_lapic>> show_lapic = num;
+ *   - arch/x86/kernel/apic/vector.c|1088| <<print_ICs>> print_local_APICs(show_lapic);
+ */
 static int show_lapic __initdata = 1;
 static __init int setup_show_lapic(char *arg)
 {
diff --git a/arch/x86/kernel/apic/x2apic_cluster.c b/arch/x86/kernel/apic/x2apic_cluster.c
index e216cf3..da264c9 100644
--- a/arch/x86/kernel/apic/x2apic_cluster.c
+++ b/arch/x86/kernel/apic/x2apic_cluster.c
@@ -11,20 +11,53 @@
 #include <asm/smp.h>
 #include <asm/x2apic.h>
 
+/*
+ * 主要的数据结构:
+ *
+ * struct apic apic_x2apic_cluster
+ */
+
 static DEFINE_PER_CPU(u32, x86_cpu_to_logical_apicid);
+/*
+ * 使用的例子:
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|90| <<__x2apic_send_IPI_mask>> cpus_in_cluster_ptr = per_cpu(cpus_in_cluster, cpu);
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|187| <<init_x2apic_ldr>> cpumask_set_cpu(this_cpu, per_cpu(cpus_in_cluster, this_cpu));
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|191| <<init_x2apic_ldr>> cpumask_set_cpu(this_cpu, per_cpu(cpus_in_cluster, cpu));
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|192| <<init_x2apic_ldr>> cpumask_set_cpu(cpu, per_cpu(cpus_in_cluster, this_cpu));
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|201| <<x2apic_prepare_cpu>> if (!zalloc_cpumask_var(&per_cpu(cpus_in_cluster, cpu), GFP_KERNEL))
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|205| <<x2apic_prepare_cpu>> free_cpumask_var(per_cpu(cpus_in_cluster, cpu));
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|219| <<x2apic_dead_cpu>> cpumask_clear_cpu(this_cpu, per_cpu(cpus_in_cluster, cpu));
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|220| <<x2apic_dead_cpu>> cpumask_clear_cpu(cpu, per_cpu(cpus_in_cluster, this_cpu));
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|222| <<x2apic_dead_cpu>> free_cpumask_var(per_cpu(cpus_in_cluster, this_cpu));
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|251| <<x2apic_cluster_probe>> cpumask_set_cpu(cpu, per_cpu(cpus_in_cluster, cpu));
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|292| <<cluster_vector_allocation_domain>> cpumask_and(retmask, mask, per_cpu(cpus_in_cluster, cpu));
+ */
 static DEFINE_PER_CPU(cpumask_var_t, cpus_in_cluster);
 static DEFINE_PER_CPU(cpumask_var_t, ipi_mask);
 
+/*
+ * struct apic apic_x2apic_cluster.acpi_madt_oem_check = x2apic_acpi_madt_oem_check()
+ */
 static int x2apic_acpi_madt_oem_check(char *oem_id, char *oem_table_id)
 {
 	return x2apic_enabled();
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|137| <<x2apic_cpu_mask_to_apicid>> cluster = x2apic_cluster(cpu);
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|141| <<x2apic_cpu_mask_to_apicid>> if (cluster != x2apic_cluster(cpu))
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|163| <<init_x2apic_ldr>> if (x2apic_cluster(this_cpu) != x2apic_cluster(cpu))
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|191| <<x2apic_dead_cpu>> if (x2apic_cluster(this_cpu) != x2apic_cluster(cpu))
+ */
 static inline u32 x2apic_cluster(int cpu)
 {
 	return per_cpu(x86_cpu_to_logical_apicid, cpu) >> 16;
 }
 
+/*
+ * struct apic apic_x2apic_cluster.send_IPI = x2apic_send_IPI()
+ */
 static void x2apic_send_IPI(int cpu, int vector)
 {
 	u32 dest = per_cpu(x86_cpu_to_logical_apicid, cpu);
@@ -33,6 +66,13 @@ static void x2apic_send_IPI(int cpu, int vector)
 	__x2apic_send_IPI_dest(dest, vector, APIC_DEST_LOGICAL);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|101| <<x2apic_send_IPI_mask>> __x2apic_send_IPI_mask(mask, vector, APIC_DEST_ALLINC);
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|107| <<x2apic_send_IPI_mask_allbutself>> __x2apic_send_IPI_mask(mask, vector, APIC_DEST_ALLBUT);
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|112| <<x2apic_send_IPI_allbutself>> __x2apic_send_IPI_mask(cpu_online_mask, vector, APIC_DEST_ALLBUT);
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|117| <<x2apic_send_IPI_all>> __x2apic_send_IPI_mask(cpu_online_mask, vector, APIC_DEST_ALLINC);
+ */
 static void
 __x2apic_send_IPI_mask(const struct cpumask *mask, int vector, int apic_dest)
 {
@@ -84,27 +124,42 @@ __x2apic_send_IPI_mask(const struct cpumask *mask, int vector, int apic_dest)
 	local_irq_restore(flags);
 }
 
+/*
+ * struct apic apic_x2apic_cluster.send_IPI_mask = x2apic_send_IPI_mask()
+ */
 static void x2apic_send_IPI_mask(const struct cpumask *mask, int vector)
 {
 	__x2apic_send_IPI_mask(mask, vector, APIC_DEST_ALLINC);
 }
 
+/*
+ * struct apic apic_x2apic_cluster.send_IPI_mask_allbutself = x2apic_send_IPI_mask_allbutself()
+ */
 static void
 x2apic_send_IPI_mask_allbutself(const struct cpumask *mask, int vector)
 {
 	__x2apic_send_IPI_mask(mask, vector, APIC_DEST_ALLBUT);
 }
 
+/*
+ * struct apic apic_x2apic_cluster.send_IPI_allbutself = x2apic_send_IPI_allbutself()
+ */
 static void x2apic_send_IPI_allbutself(int vector)
 {
 	__x2apic_send_IPI_mask(cpu_online_mask, vector, APIC_DEST_ALLBUT);
 }
 
+/*
+ * struct apic apic_x2apic_cluster.send_IPI_all = x2apic_send_IPI_all()
+ */
 static void x2apic_send_IPI_all(int vector)
 {
 	__x2apic_send_IPI_mask(cpu_online_mask, vector, APIC_DEST_ALLINC);
 }
 
+/*
+ * struct apic apic_x2apic_cluster.cpu_mask_to_apicid = x2apic_cpu_mask_to_apicid()
+ */
 static int
 x2apic_cpu_mask_to_apicid(const struct cpumask *mask, struct irq_data *irqdata,
 			  unsigned int *apicid)
@@ -133,6 +188,9 @@ x2apic_cpu_mask_to_apicid(const struct cpumask *mask, struct irq_data *irqdata,
 	return 0;
 }
 
+/*
+ * struct apic apic_x2apic_cluster.init_apic_ldr = init_x2apic_ldr()
+ */
 static void init_x2apic_ldr(void)
 {
 	unsigned int this_cpu = smp_processor_id();
@@ -180,11 +238,21 @@ static int x2apic_dead_cpu(unsigned int this_cpu)
 	return 0;
 }
 
+/*
+ * struct apic apic_x2apic_cluster.probe = x2apic_cluster_probe()
+ */
 static int x2apic_cluster_probe(void)
 {
 	int cpu = smp_processor_id();
 	int ret;
 
+	/*
+	 * x2apic_mode在以下修改:
+	 *   - arch/x86/kernel/apic/apic.c|1616| <<setup_nox2apic>> x2apic_mode = 0;
+	 *   - arch/x86/kernel/apic/apic.c|1639| <<x2apic_disable>> x2apic_mode = 0;
+	 *   - arch/x86/kernel/apic/apic.c|1658| <<x2apic_enable>> x2apic_mode = 1;
+	 *   - arch/x86/kernel/apic/apic.c|1692| <<check_x2apic>> x2apic_mode = 1;
+	 */
 	if (!x2apic_mode)
 		return 0;
 
@@ -198,6 +266,14 @@ static int x2apic_cluster_probe(void)
 	return 1;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|281| <<cluster_vector_allocation_domain>> if (mask == x2apic_cluster_target_cpus())
+ *   - arch/x86/kernel/apic/io_apic.c|2992| <<setup_ioapic_dest>> mask = apic->target_cpus();
+ *   - arch/x86/kernel/apic/vector.c|450| <<assign_irq_vector_policy>> return assign_irq_vector(irq, data, apic->target_cpus(), irqdata);
+ *
+ * struct apic apic_x2apic_cluster.target_cpus = x2apic_cluster_target_cpus()
+ */
 static const struct cpumask *x2apic_cluster_target_cpus(void)
 {
 	return cpu_all_mask;
@@ -206,6 +282,12 @@ static const struct cpumask *x2apic_cluster_target_cpus(void)
 /*
  * Each x2apic cluster is an allocation domain.
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|318| <<__assign_irq_vector>> apic->vector_allocation_domain(cpu, vector_cpumask, mask);
+ *
+ * struct apic apic_x2apic_cluster.vector_allocation_domain = cluster_vector_allocation_domain()
+ */
 static void cluster_vector_allocation_domain(int cpu, struct cpumask *retmask,
 					     const struct cpumask *mask)
 {
diff --git a/arch/x86/kernel/apic/x2apic_phys.c b/arch/x86/kernel/apic/x2apic_phys.c
index b94d353..603872b 100644
--- a/arch/x86/kernel/apic/x2apic_phys.c
+++ b/arch/x86/kernel/apic/x2apic_phys.c
@@ -9,6 +9,12 @@
 #include <asm/smp.h>
 #include <asm/x2apic.h>
 
+/*
+ * 主要的数据结构
+ *
+ * struct apic apic_x2apic_phys
+ */
+
 int x2apic_phys;
 
 static struct apic apic_x2apic_phys;
diff --git a/arch/x86/kernel/apic/x2apic_uv_x.c b/arch/x86/kernel/apic/x2apic_uv_x.c
index 02cfc61..ec7bfe1 100644
--- a/arch/x86/kernel/apic/x2apic_uv_x.c
+++ b/arch/x86/kernel/apic/x2apic_uv_x.c
@@ -40,6 +40,12 @@
 #include <asm/x86_init.h>
 #include <asm/nmi.h>
 
+/*
+ * 主要的数据结构
+ *
+ * struct apic apic_x2apic_uv_x
+ */
+
 DEFINE_PER_CPU(int, x2apic_extra_bits);
 
 static enum uv_system_type	uv_system_type;
diff --git a/arch/x86/kernel/dumpstack.c b/arch/x86/kernel/dumpstack.c
index 224de37..aa6fef2 100644
--- a/arch/x86/kernel/dumpstack.c
+++ b/arch/x86/kernel/dumpstack.c
@@ -273,6 +273,12 @@ NOKPROBE_SYMBOL(oops_begin);
 
 void __noreturn rewind_stack_do_exit(int signr);
 
+/*
+ * called by:
+ *   - arch/x86/kernel/dumpstack.c|360| <<die>> oops_end(flags, regs, sig);
+ *   - arch/x86/mm/fault.c|733| <<pgtable_bad>> oops_end(flags, regs, sig);
+ *   - arch/x86/mm/fault.c|846| <<no_context>> oops_end(flags, regs, sig);
+ */
 void oops_end(unsigned long flags, struct pt_regs *regs, int signr)
 {
 	if (regs && kexec_should_crash(current))
diff --git a/arch/x86/kernel/hpet.c b/arch/x86/kernel/hpet.c
index df767e6..364d9d7 100644
--- a/arch/x86/kernel/hpet.c
+++ b/arch/x86/kernel/hpet.c
@@ -899,6 +899,11 @@ static u32 *hpet_boot_cfg;
 /**
  * hpet_enable - Try to setup the HPET timer. Returns 1 on success.
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/hpet.c|1032| <<hpet_late_init>> hpet_enable();
+ *   - arch/x86/kernel/time.c|102| <<hpet_time_init>> if (!hpet_enable())
+ */
 int __init hpet_enable(void)
 {
 	u32 hpet_period, cfg, id;
@@ -1294,6 +1299,10 @@ int hpet_rtc_dropped_irq(void)
 }
 EXPORT_SYMBOL_GPL(hpet_rtc_dropped_irq);
 
+/*
+ * called only by:
+ *   - arch/x86/kernel/hpet.c|1334| <<hpet_rtc_interrupt>> hpet_rtc_timer_reinit();
+ */
 static void hpet_rtc_timer_reinit(void)
 {
 	unsigned int delta;
diff --git a/arch/x86/kernel/i8259.c b/arch/x86/kernel/i8259.c
index 02abc13..9b124eb 100644
--- a/arch/x86/kernel/i8259.c
+++ b/arch/x86/kernel/i8259.c
@@ -32,6 +32,11 @@
  */
 static void init_8259A(int auto_eoi);
 
+/*
+ * used by:
+ *   - arch/x86/kernel/i8259.c|346| <<i8259A_resume>> init_8259A(i8259A_auto_eoi);
+ *   - arch/x86/kernel/i8259.c|452| <<init_8259A>> i8259A_auto_eoi = auto_eoi;
+ */
 static int i8259A_auto_eoi;
 DEFINE_RAW_SPINLOCK(i8259A_lock);
 
@@ -42,6 +47,15 @@ DEFINE_RAW_SPINLOCK(i8259A_lock);
 /*
  * This contains the irq mask for both 8259A irq controllers,
  */
+/*
+ * used by:
+ *   - arch/x86/include/asm/i8259.h|11| <<cached_master_mask>> #define cached_master_mask (__byte(0, cached_irq_mask))
+ *   - arch/x86/include/asm/i8259.h|12| <<cached_slave_mask>> #define cached_slave_mask (__byte(1, cached_irq_mask))
+ *   - arch/x86/kernel/i8259.c|64| <<mask_8259A_irq>> cached_irq_mask |= mask;
+ *   - arch/x86/kernel/i8259.c|83| <<unmask_8259A_irq>> cached_irq_mask &= mask;
+ *   - arch/x86/kernel/i8259.c|171| <<mask_and_ack_8259A>> if (cached_irq_mask & irqmask)
+ *   - arch/x86/kernel/i8259.c|173| <<mask_and_ack_8259A>> cached_irq_mask |= irqmask;
+ */
 unsigned int cached_irq_mask = 0xffff;
 
 /*
@@ -53,13 +67,44 @@ unsigned int cached_irq_mask = 0xffff;
  * this 'mixed mode' IRQ handling costs nothing because it's only used
  * at IRQ setup time.
  */
+/*
+ * used by:
+ *   - arch/x86/include/asm/io_apic.h|147| <<IO_APIC_IRQ>> #define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1 << (x)) & io_apic_irqs))
+ *   - arch/x86/include/asm/io_apic.h|154| <<io_apic_assign_pci_irqs>> (mp_irq_entries && !skip_ioapic_setup && io_apic_irqs)
+ *   - arch/x86/kernel/apic/io_apic.c|284| <<arch_early_ioapic_init>> io_apic_irqs = ~0UL;
+ *   - arch/x86/kernel/apic/io_apic.c|2427| <<setup_IO_APIC>> io_apic_irqs = nr_legacy_irqs() ? ~PIC_IRQS : ~0UL;
+ *   - arch/x86/kernel/i8259.c|115| <<make_8259A_irq>> io_apic_irqs &= ~(1<<irq);
+ *
+ * 在I/O APIC的IRQ0线上链接着8259中断
+ *
+ * 下面是一个bitmap, 说明那个irq line是用的io_apic
+ */
 unsigned long io_apic_irqs;
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|1744| <<startup_ioapic_irq>> legacy_pic->mask(irq);
+ *   - arch/x86/kernel/apic/io_apic.c|2154| <<check_timer>> legacy_pic->mask(0);
+ *   - arch/x86/kernel/apic/io_apic.c|2285| <<check_timer>> legacy_pic->mask(0);
+ *   - arch/x86/kernel/apic/io_apic.c|2305| <<check_timer>> legacy_pic->mask(0);
+ *   - arch/x86/kernel/apic/io_apic.c|3115| <<mp_irqdomain_alloc>> legacy_pic->mask(virq);
+ *
+ * struct legacy_pic default_legacy_pic.mask = mask_8259A_irq()
+ *
+ * 通过IMR寄存器在8259禁用某个irq line
+ */
 static void mask_8259A_irq(unsigned int irq)
 {
 	unsigned int mask = 1 << irq;
 	unsigned long flags;
 
+	/*
+	 * unsigned int cached_irq_mask;
+	 * #define __byte(x, y)            (((unsigned char *)&(y))[x])
+	 * #define cached_master_mask      (__byte(0, cached_irq_mask))
+	 * #define cached_slave_mask       (__byte(1, cached_irq_mask))
+	 */
+
 	raw_spin_lock_irqsave(&i8259A_lock, flags);
 	cached_irq_mask |= mask;
 	if (irq & 8)
@@ -69,11 +114,26 @@ static void mask_8259A_irq(unsigned int irq)
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
 }
 
+/*
+ * struct irq_chip i8259A_chip.irq_mask = disable_8259A_irq()
+ * struct irq_chip i8259A_chip.irq_disable = disable_8259A_irq()
+ *
+ * 通过IMR寄存器在8259禁用某个通过irq_data定义的irq line
+ */
 static void disable_8259A_irq(struct irq_data *data)
 {
 	mask_8259A_irq(data->irq);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|2273| <<check_timer>> legacy_pic->unmask(0);
+ *   - arch/x86/kernel/apic/io_apic.c|2298| <<check_timer>> legacy_pic->unmask(0);
+ *
+ * struct legacy_pic default_legacy_pic.unmask = unmask_8259A_irq()
+ *
+ * 通过IMR寄存器在8259开通某个irq line
+ */
 static void unmask_8259A_irq(unsigned int irq)
 {
 	unsigned int mask = ~(1 << irq);
@@ -88,11 +148,24 @@ static void unmask_8259A_irq(unsigned int irq)
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
 }
 
+/*
+ * struct irq_chip i8259A_chip.irq_unmask = enable_8259A_irq()
+ *
+ * 通过IMR寄存器在8259开通某个irq line
+ */
 static void enable_8259A_irq(struct irq_data *data)
 {
 	unmask_8259A_irq(data->irq);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|1745| <<startup_ioapic_irq>> if (legacy_pic->irq_pending(irq))
+ *
+ * struct legacy_pic default_legacy_pic.irq_pending = i8259A_irq_pending()
+ *
+ * 通过cmd port获取某个irq line是否在pending
+ */
 static int i8259A_irq_pending(unsigned int irq)
 {
 	unsigned int mask = 1<<irq;
@@ -109,9 +182,32 @@ static int i8259A_irq_pending(unsigned int irq)
 	return ret;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|1977| <<init_IO_APIC_traps>> legacy_pic->make_irq(irq);
+ *   - arch/x86/kernel/apic/io_apic.c|2316| <<check_timer>> legacy_pic->make_irq(0);
+ *
+ * struct legacy_pic default_legacy_pic.make_irq = make_8259A_irq()
+ *
+ * 配置8259使某个irq line通过8259, 而不通过ioapic了
+ * 这里在io_apic_irqs把某个irq line的bit清0, 说明不通过ioapic了
+ * 通过下面设置中断的chip:
+ *   - irq_set_chip_and_handler(irq, &i8259A_chip, handle_level_irq);
+ */
 static void make_8259A_irq(unsigned int irq)
 {
 	disable_irq_nosync(irq);
+	/*
+	 * io_apic_irqs是一个bitmap, 说明那个irq line是用的io_apic
+	 * used by:
+	 *   - arch/x86/include/asm/io_apic.h|147| <<IO_APIC_IRQ>> #define IO_APIC_IRQ(x) (((x) >= NR_IRQS_LEGACY) || ((1 << (x)) & io_apic_irqs))
+	 *   - arch/x86/include/asm/io_apic.h|154| <<io_apic_assign_pci_irqs>> (mp_irq_entries && !skip_ioapic_setup && io_apic_irqs)
+	 *   - arch/x86/kernel/apic/io_apic.c|284| <<arch_early_ioapic_init>> io_apic_irqs = ~0UL;
+	 *   - arch/x86/kernel/apic/io_apic.c|2427| <<setup_IO_APIC>> io_apic_irqs = nr_legacy_irqs() ? ~PIC_IRQS : ~0UL;
+	 *   - arch/x86/kernel/i8259.c|115| <<make_8259A_irq>> io_apic_irqs &= ~(1<<irq);
+	 *
+	 * 这里把某个irq line的bit清0, 说明不通过ioapic了
+	 */
 	io_apic_irqs &= ~(1<<irq);
 	irq_set_chip_and_handler(irq, &i8259A_chip, handle_level_irq);
 	enable_irq(irq);
@@ -123,6 +219,10 @@ static void make_8259A_irq(unsigned int irq)
  * This has to be protected by the irq controller spinlock
  * before being called.
  */
+/*
+ * called by only:
+ *   - arch/x86/kernel/i8259.c|273| <<mask_and_ack_8259A>> if (i8259A_irq_real(irq))
+ */
 static inline int i8259A_irq_real(unsigned int irq)
 {
 	int value;
@@ -146,6 +246,9 @@ static inline int i8259A_irq_real(unsigned int irq)
  * first, _then_ send the EOI, and the order of EOI
  * to the two 8259s is important!
  */
+/*
+ * struct irq_chip i8259A_chip.irq_mask_ack = mask_and_ack_8259A()
+ */
 static void mask_and_ack_8259A(struct irq_data *data)
 {
 	unsigned int irq = data->irq;
@@ -220,6 +323,7 @@ static void mask_and_ack_8259A(struct irq_data *data)
 	}
 }
 
+/* struct legacy_pic default_legacy_pic.chip = i8259A_chip */
 struct irq_chip i8259A_chip = {
 	.name		= "XT-PIC",
 	.irq_mask	= disable_8259A_irq,
@@ -245,18 +349,27 @@ static void save_ELCR(char *trigger)
 	trigger[1] = inb(0x4d1) & 0xDE;
 }
 
+/*
+ * struct syscore_ops i8259_syscore_ops.resume = i8259A_resume()
+ */
 static void i8259A_resume(void)
 {
 	init_8259A(i8259A_auto_eoi);
 	restore_ELCR(irq_trigger);
 }
 
+/*
+ * struct syscore_ops i8259_syscore_ops.suspend = i8259A_suspend()
+ */
 static int i8259A_suspend(void)
 {
 	save_ELCR(irq_trigger);
 	return 0;
 }
 
+/*
+ * struct syscore_ops i8259_syscore_ops.shutdown = i8259A_shutdown()
+ */
 static void i8259A_shutdown(void)
 {
 	/* Put the i8259A into a quiescent state that
@@ -273,6 +386,9 @@ static struct syscore_ops i8259_syscore_ops = {
 	.shutdown = i8259A_shutdown,
 };
 
+/*
+ * struct legacy_pic default_legacy_pic.mask_all = mask_8259A()
+ */
 static void mask_8259A(void)
 {
 	unsigned long flags;
@@ -285,6 +401,9 @@ static void mask_8259A(void)
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
 }
 
+/*
+ * struct legacy_pic default_legacy_pic.restore_mask = unmask_8259A()
+ */
 static void unmask_8259A(void)
 {
 	unsigned long flags;
@@ -297,9 +416,20 @@ static void unmask_8259A(void)
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|423| <<arch_probe_nr_irqs>> return legacy_pic->probe();
+ *
+ * struct legacy_pic default_legacy_pic.probe = probe_8259A()
+ *
+ * 把slave的imr设置为全是1 (全部master)
+ * 把master除了irq 2全部mask (irq 2连接slave)
+ * 对于default_legacy_pic返回NR_IRQS_LEGACY(16)
+ */
 static int probe_8259A(void)
 {
 	unsigned long flags;
+	/* 除了第2个bit是0, 剩下全是1: 11111011*/
 	unsigned char probe_val = ~(1 << PIC_CASCADE_IR);
 	unsigned char new_val;
 	/*
@@ -320,44 +450,106 @@ static int probe_8259A(void)
 	}
 
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
+	/*
+	 * 在default_legacy_pic返回NR_IRQS_LEGACY(16)
+	 * 在null_legacy_pic返回0
+	 */
 	return nr_legacy_irqs();
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|2166| <<check_timer>> legacy_pic->init(1);
+ *   - arch/x86/kernel/apic/io_apic.c|2315| <<check_timer>> legacy_pic->init(0);
+ *   - arch/x86/kernel/irqinit.c|68| <<init_ISA_irqs>> legacy_pic->init(0);
+ *
+ * struct legacy_pic default_legacy_pic.init = init_8259A()
+ *
+ * 按照ICW要求的顺序初始化8259
+ *   vector 0x30对应irq line 0
+ *   vector 0x38对应irq line 8
+ * 最后会根据cached_irq_mask屏蔽中断
+ */
 static void init_8259A(int auto_eoi)
 {
 	unsigned long flags;
 
+	/* 主要在i8259A_resume()的时候使用 */
 	i8259A_auto_eoi = auto_eoi;
 
 	raw_spin_lock_irqsave(&i8259A_lock, flags);
 
+	/* 在8259 master上屏蔽所有中断 */
 	outb(0xff, PIC_MASTER_IMR);	/* mask all of 8259A-1 */
 
 	/*
+	 * 初始化按照如下顺序:
+	 * 1. master ICW1 (实际上ICW1的字是固定的 00010001 = 0x11)
+	 * 2. master ICW2
+	 * 3. master ICW3
+	 * 4. master ICW4
+	 * 5. slave  ICW1
+	 * 6. slave  ICW2
+	 * 7. slave  ICW3
+	 * 8. slave  ICW4
+	 */
+
+	/*
 	 * outb_pic - this has to work on a wide range of PC hardware.
 	 */
+	/*
+	 * 最后一位是1, 说明要求设置ICW4
+	 */
 	outb_pic(0x11, PIC_MASTER_CMD);	/* ICW1: select 8259A-1 init */
 
 	/* ICW2: 8259A-1 IR0-7 mapped to ISA_IRQ_VECTOR(0) */
+	/*
+	 * ISA_IRQ_VECTOR(0)
+	 * 输入一个irq, 返回0x30+irq, 也就是48+irq
+	 * 00110000
+	 *
+	 * 00110 000: 也就是说, vector 0x30对应irq line 0
+	 */
 	outb_pic(ISA_IRQ_VECTOR(0), PIC_MASTER_IMR);
 
 	/* 8259A-1 (the master) has a slave on IR2 */
+	/*
+	 * ICW3的master, 表示slave接入master的IRQ line 8
+	 */
 	outb_pic(1U << PIC_CASCADE_IR, PIC_MASTER_IMR);
 
+	/*
+	 * 对于支持aeoi, ICW4的master是00000011
+	 * 对于不支持aeoi, ICW4的master是00000001
+	 *
+	 * 这里总是不支持Special Full Nested Mode
+	 */
 	if (auto_eoi)	/* master does Auto EOI */
 		outb_pic(MASTER_ICW4_DEFAULT | PIC_ICW4_AEOI, PIC_MASTER_IMR);
 	else		/* master expects normal EOI */
 		outb_pic(MASTER_ICW4_DEFAULT, PIC_MASTER_IMR);
 
+	/*
+	 * 开始slave的ICW1
+	 */
 	outb_pic(0x11, PIC_SLAVE_CMD);	/* ICW1: select 8259A-2 init */
 
 	/* ICW2: 8259A-2 IR0-7 mapped to ISA_IRQ_VECTOR(8) */
+	/*
+	 * 111000
+	 *
+	 * 00111 000: 也就是说, vector 0x38对应irq line 0
+	 */
 	outb_pic(ISA_IRQ_VECTOR(8), PIC_SLAVE_IMR);
 	/* 8259A-2 is a slave on master's IR2 */
 	outb_pic(PIC_CASCADE_IR, PIC_SLAVE_IMR);
 	/* (slave's support for AEOI in flat mode is to be investigated) */
 	outb_pic(SLAVE_ICW4_DEFAULT, PIC_SLAVE_IMR);
 
+	/*
+	 * 在AEOI (Automatic End of Interrupt) 模式里, 8259在第2个INTA#结束后自动清ISR相应的bit,
+	 * 否则必须发送一个EOI命令给8259
+	 */
 	if (auto_eoi)
 		/*
 		 * In AEOI mode we just have to mask the interrupt
@@ -369,7 +561,29 @@ static void init_8259A(int auto_eoi)
 
 	udelay(100);		/* wait for 8259A to initialize */
 
+	/*
+	 * #define __byte(x, y)            (((unsigned char *)&(y))[x])
+	 * #define cached_master_mask      (__byte(0, cached_irq_mask))
+	 *
+	 * cached_master_mask只使用, 不修改:
+	 *   - arch/x86/kernel/i8259.c|113| <<mask_8259A_irq>> outb(cached_master_mask, PIC_MASTER_IMR);
+	 *   - arch/x86/kernel/i8259.c|147| <<unmask_8259A_irq>> outb(cached_master_mask, PIC_MASTER_IMR);
+	 *   - arch/x86/kernel/i8259.c|288| <<mask_and_ack_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+	 *   - arch/x86/kernel/i8259.c|413| <<unmask_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+	 *   - arch/x86/kernel/i8259.c|528| <<init_8259A>> outb(cached_master_mask, PIC_MASTER_IMR);
+	 */
 	outb(cached_master_mask, PIC_MASTER_IMR); /* restore master IRQ mask */
+	/*
+	 * #define __byte(x, y)            (((unsigned char *)&(y))[x])
+	 * #define cached_slave_mask       (__byte(1, cached_irq_mask))
+	 *
+	 * cached_slave_mask只使用, 不修改:
+	 *   - arch/x86/kernel/i8259.c|111| <<mask_8259A_irq>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+	 *   - arch/x86/kernel/i8259.c|145| <<unmask_8259A_irq>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+	 *   - arch/x86/kernel/i8259.c|281| <<mask_and_ack_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+	 *   - arch/x86/kernel/i8259.c|414| <<unmask_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+	 *   - arch/x86/kernel/i8259.c|529| <<init_8259A>> outb(cached_slave_mask, PIC_SLAVE_IMR);
+	 */
 	outb(cached_slave_mask, PIC_SLAVE_IMR);	  /* restore slave IRQ mask */
 
 	raw_spin_unlock_irqrestore(&i8259A_lock, flags);
@@ -419,6 +633,13 @@ struct legacy_pic default_legacy_pic = {
 	.make_irq = make_8259A_irq,
 };
 
+/*
+ * used by:
+ *   - arch/x86/kernel/i8259.c|422| <<global>> struct legacy_pic *legacy_pic = &default_legacy_pic;
+ *   - arch/x86/kernel/acpi/boot.c|1387| <<acpi_reduced_hw_init>> legacy_pic = &null_legacy_pic;
+ *   - arch/x86/kernel/i8259.c|319| <<probe_8259A>> legacy_pic = &null_legacy_pic;
+ *   - arch/x86/platform/intel-mid/intel-mid.c|200| <<x86_intel_mid_early_setup>> legacy_pic = &null_legacy_pic;
+ */
 struct legacy_pic *legacy_pic = &default_legacy_pic;
 EXPORT_SYMBOL(legacy_pic);
 
diff --git a/arch/x86/kernel/irq.c b/arch/x86/kernel/irq.c
index 3c2326b..2c059bf 100644
--- a/arch/x86/kernel/irq.c
+++ b/arch/x86/kernel/irq.c
@@ -207,6 +207,31 @@ u64 arch_irq_stat(void)
 	return sum;
 }
 
+/*
+ * vector_irq在以下使用:
+ *   - arch/x86/kernel/apic/vector.c|183| <<__assign_irq_vector>> if (!IS_ERR_OR_NULL(per_cpu(vector_irq, new_cpu)[vector]))
+ *   - arch/x86/kernel/apic/vector.c|193| <<__assign_irq_vector>> per_cpu(vector_irq, new_cpu)[vector] = irq_to_desc(irq);
+ *   - arch/x86/kernel/apic/vector.c|272| <<clear_irq_vector>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|289| <<clear_irq_vector>> if (per_cpu(vector_irq, cpu)[vector] != desc)
+ *   - arch/x86/kernel/apic/vector.c|291| <<clear_irq_vector>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|492| <<__setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = desc;
+ *   - arch/x86/kernel/apic/vector.c|496| <<__setup_vector_irq>> desc = per_cpu(vector_irq, cpu)[vector];
+ *   - arch/x86/kernel/apic/vector.c|502| <<__setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|522| <<setup_vector_irq>> per_cpu(vector_irq, cpu)[ISA_IRQ_VECTOR(irq)] = irq_to_desc(irq);
+ *   - arch/x86/kernel/apic/vector.c|607| <<smp_irq_move_cleanup_interrupt>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/apic/vector.c|658| <<smp_irq_move_cleanup_interrupt>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/apic/vector.c|792| <<irq_force_complete_move>> per_cpu(vector_irq, cpu)[cfg->old_vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/irq.c|228| <<do_IRQ>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|238| <<do_IRQ>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/irq.c|351| <<check_irq_vectors_for_cpu_disable>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|409| <<check_irq_vectors_for_cpu_disable>> IS_ERR_OR_NULL(per_cpu(vector_irq, cpu)[vector])) {
+ *   - arch/x86/kernel/irq.c|451| <<fixup_irqs>> if (IS_ERR_OR_NULL(__this_cpu_read(vector_irq[vector])))
+ *   - arch/x86/kernel/irq.c|456| <<fixup_irqs>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|463| <<fixup_irqs>> __this_cpu_write(vector_irq[vector], VECTOR_RETRIGGERED);
+ *   - arch/x86/kernel/irq.c|467| <<fixup_irqs>> if (__this_cpu_read(vector_irq[vector]) != VECTOR_RETRIGGERED)
+ *   - arch/x86/kernel/irq.c|468| <<fixup_irqs>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/irqinit.c|87| <<init_IRQ>> per_cpu(vector_irq, 0)[ISA_IRQ_VECTOR(i)] = irq_to_desc(i);
+ */
 
 /*
  * do_IRQ handles all normal device IRQ's (the special
@@ -422,6 +447,48 @@ int check_irq_vectors_for_cpu_disable(void)
 }
 
 /* A cpu has been removed from cpu_online_mask.  Reset irq affinities. */
+/*
+ * nvme往某个entry的destination写0的例子
+ * [   55.963222] orabug: __pci_write_msi_msg() irq=25, lo=0x00000000
+ * [   55.963226] CPU: 3 PID: 23 Comm: migration/3 Not tainted 4.14.113 #8
+ * [   55.963228] Call Trace:
+ * [   55.963237]  dump_stack+0x46/0x62
+ * [   55.963242]  __pci_write_msi_msg+0x129/0x130
+ * [   55.963247]  ? printk+0x3e/0x46
+ * [   55.963252]  msi_domain_deactivate+0x2d/0x40
+ * [   55.963256]  irq_domain_deactivate_irq+0x43/0x60
+ * [   55.963260]  irq_migrate_all_off_this_cpu+0x296/0x2c0
+ * [   55.963263]  fixup_irqs+0x1e/0xe0
+ * [   55.963269]  native_cpu_disable+0x1b/0x30
+ * [   55.963273]  take_cpu_down+0x34/0x90
+ * [   55.963276]  multi_cpu_stop+0x86/0xb0
+ * [   55.963279]  ? cpu_stop_queue_work+0xa0/0xa0
+ * [   55.963282]  cpu_stopper_thread+0x76/0xe0
+ * [   55.963286]  smpboot_thread_fn+0x109/0x160
+ * [   55.963290]  kthread+0xfa/0x130
+ * [   55.963293]  ? sort_range+0x20/0x20
+ * [   55.963297]  ? kthread_create_on_node+0x40/0x40
+ * [   55.963300]  ret_from_fork+0x35/0x40
+ *
+ * 在这个函数dump_stack()的输出:
+ * [   50.420855] IRQ 29: no longer affine to CPU1
+ * [   50.421858] orabug: fixup_irqs()
+ * [   50.421862] CPU: 1 PID: 13 Comm: migration/1 Not tainted 4.14.113 #2
+ * [   50.421864] Call Trace:
+ * [   50.421885]  dump_stack+0x46/0x62
+ * [   50.421888]  fixup_irqs+0x39/0x100
+ * [   50.421893]  native_cpu_disable+0x1b/0x30
+ * [   50.421896]  take_cpu_down+0x34/0x90
+ * [   50.421899]  multi_cpu_stop+0x86/0xb0
+ * [   50.421901]  ? cpu_stop_queue_work+0xa0/0xa0
+ * [   50.421903]  cpu_stopper_thread+0x76/0xe0
+ * [   50.421907]  smpboot_thread_fn+0x109/0x160
+ * [   50.421910]  kthread+0xfa/0x130
+ * [   50.421913]  ? sort_range+0x20/0x20
+ * [   50.421915]  ? kthread_create_on_node+0x40/0x40
+ * [   50.421918]  ret_from_fork+0x35/0x40
+ * [   50.422124] smpboot: CPU 1 is now offline
+ */
 void fixup_irqs(void)
 {
 	unsigned int irr, vector;
diff --git a/arch/x86/kernel/irqinit.c b/arch/x86/kernel/irqinit.c
index 40f83d0..0694a24 100644
--- a/arch/x86/kernel/irqinit.c
+++ b/arch/x86/kernel/irqinit.c
@@ -53,6 +53,33 @@ static struct irqaction irq2 = {
 	.flags = IRQF_NO_THREAD,
 };
 
+/*
+ * 在以下设置:
+ *
+ * 在以下使用:
+ *   - arch/x86/kernel/apic/vector.c|183| <<__assign_irq_vector>> if (!IS_ERR_OR_NULL(per_cpu(vector_irq, new_cpu)[vector]))
+ *   - arch/x86/kernel/apic/vector.c|193| <<__assign_irq_vector>> per_cpu(vector_irq, new_cpu)[vector] = irq_to_desc(irq);
+ *   - arch/x86/kernel/apic/vector.c|272| <<clear_irq_vector>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|289| <<clear_irq_vector>> if (per_cpu(vector_irq, cpu)[vector] != desc)
+ *   - arch/x86/kernel/apic/vector.c|291| <<clear_irq_vector>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|492| <<__setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = desc;
+ *   - arch/x86/kernel/apic/vector.c|496| <<__setup_vector_irq>> desc = per_cpu(vector_irq, cpu)[vector];
+ *   - arch/x86/kernel/apic/vector.c|502| <<__setup_vector_irq>> per_cpu(vector_irq, cpu)[vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/apic/vector.c|522| <<setup_vector_irq>> per_cpu(vector_irq, cpu)[ISA_IRQ_VECTOR(irq)] = irq_to_desc(irq);
+ *   - arch/x86/kernel/apic/vector.c|607| <<smp_irq_move_cleanup_interrupt>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/apic/vector.c|658| <<smp_irq_move_cleanup_interrupt>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/apic/vector.c|792| <<irq_force_complete_move>> per_cpu(vector_irq, cpu)[cfg->old_vector] = VECTOR_UNUSED;
+ *   - arch/x86/kernel/irq.c|228| <<do_IRQ>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|238| <<do_IRQ>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/irq.c|351| <<check_irq_vectors_for_cpu_disable>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|409| <<check_irq_vectors_for_cpu_disable>> IS_ERR_OR_NULL(per_cpu(vector_irq, cpu)[vector])) {
+ *   - arch/x86/kernel/irq.c|451| <<fixup_irqs>> if (IS_ERR_OR_NULL(__this_cpu_read(vector_irq[vector])))
+ *   - arch/x86/kernel/irq.c|456| <<fixup_irqs>> desc = __this_cpu_read(vector_irq[vector]);
+ *   - arch/x86/kernel/irq.c|463| <<fixup_irqs>> __this_cpu_write(vector_irq[vector], VECTOR_RETRIGGERED);
+ *   - arch/x86/kernel/irq.c|467| <<fixup_irqs>> if (__this_cpu_read(vector_irq[vector]) != VECTOR_RETRIGGERED)
+ *   - arch/x86/kernel/irq.c|468| <<fixup_irqs>> __this_cpu_write(vector_irq[vector], VECTOR_UNUSED);
+ *   - arch/x86/kernel/irqinit.c|87| <<init_IRQ>> per_cpu(vector_irq, 0)[ISA_IRQ_VECTOR(i)] = irq_to_desc(i);
+ */
 DEFINE_PER_CPU(vector_irq_t, vector_irq) = {
 	[0 ... NR_VECTORS - 1] = VECTOR_UNUSED,
 };
diff --git a/arch/x86/kernel/time.c b/arch/x86/kernel/time.c
index ab0176a..73658b8 100644
--- a/arch/x86/kernel/time.c
+++ b/arch/x86/kernel/time.c
@@ -56,8 +56,29 @@ EXPORT_SYMBOL(profile_pc);
 /*
  * Default timer interrupt handler for PIT/HPET
  */
+/*
+ * struct irqaction irq0.handler = timer_interrupt()
+ *
+ * tick_do_timer_cpu更新timer
+ */
 static irqreturn_t timer_interrupt(int irq, void *dev_id)
 {
+	/*
+	 * event_handler在以下设置:
+	 *   - arch/x86/kernel/apic/apic.c|845| <<calibrate_APIC_clock>> global_clock_event->event_handler = lapic_cal_handler;
+	 *   - arch/x86/kernel/apic/apic.c|862| <<calibrate_APIC_clock>> global_clock_event->event_handler = real_handler;
+	 *   - arch/x86/kernel/apic/apic.c|924| <<calibrate_APIC_clock>> levt->event_handler = lapic_cal_handler;
+	 *   - kernel/time/tick-broadcast.c|104| <<tick_install_broadcast_device>> cur->event_handler = clockevents_handle_noop;
+	 *   - kernel/time/tick-broadcast.c|176| <<tick_device_uses_broadcast>> dev->event_handler = tick_handle_periodic;
+	 *   - kernel/time/tick-broadcast.c|435| <<tick_set_periodic_handler>> dev->event_handler = tick_handle_periodic;
+	 *   - kernel/time/tick-broadcast.c|437| <<tick_set_periodic_handler>> dev->event_handler = tick_handle_periodic_broadcast;
+	 *   - kernel/time/tick-broadcast.c|891| <<tick_broadcast_setup_oneshot>> bc->event_handler = tick_handle_oneshot_broadcast;
+	 *   - kernel/time/tick-common.c|208| <<tick_setup_device>> td->evtdev->event_handler = clockevents_handle_noop;
+	 *   - kernel/time/tick-common.c|402| <<tick_shutdown>> dev->event_handler = clockevents_handle_noop;
+	 *   - kernel/time/tick-internal.h|91| <<tick_set_periodic_handler>> dev->event_handler = tick_handle_periodic;
+	 *   - kernel/time/tick-oneshot.c|68| <<tick_setup_oneshot>> newdev->event_handler = handler;
+	 *   - kernel/time/tick-oneshot.c|99| <<tick_switch_to_oneshot>> dev->event_handler = handler;
+	 */
 	global_clock_event->event_handler(global_clock_event);
 	return IRQ_HANDLED;
 }
@@ -78,6 +99,13 @@ static void __init setup_default_timer_irq(void)
 /* Default timer init function */
 void __init hpet_time_init(void)
 {
+	/*
+	 * hpet_enable - Try to setup the HPET timer. Returns 1 on success.
+	 *
+	 * 这里如果激活hpet失败, 再使用pit
+	 *
+	 * 在ovm xen上是失败的, 要用PIT
+	 */
 	if (!hpet_enable())
 		setup_pit_timer();
 	setup_default_timer_irq();
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index ed8d78f..b9f35c2 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -71,6 +71,19 @@
 #include <asm/proto.h>
 #endif
 
+/*
+ * 在以下声明和使用:
+ *   - arch/x86/kernel/traps.c|74| <<global>> DECLARE_BITMAP(used_vectors, NR_VECTORS);
+ *   - arch/x86/kernel/apic/vector.c|461| <<__assign_irq_vector>> if (test_bit(vector, used_vectors))
+ *   - arch/x86/kernel/idt.c|228| <<idt_setup_from_table>> set_bit(t->vector, used_vectors);
+ *   - arch/x86/kernel/idt.c|316| <<idt_setup_apic_and_irq_gates>> for_each_clear_bit_from(i, used_vectors, FIRST_SYSTEM_VECTOR) {
+ *   - arch/x86/kernel/idt.c|321| <<idt_setup_apic_and_irq_gates>> for_each_clear_bit_from(i, used_vectors, NR_VECTORS) {
+ *   - arch/x86/kernel/idt.c|323| <<idt_setup_apic_and_irq_gates>> set_bit(i, used_vectors);
+ *   - arch/x86/kernel/idt.c|361| <<update_intr_gate>> if (WARN_ON_ONCE(!test_bit(n, used_vectors)))
+ *   - arch/x86/kernel/idt.c|369| <<alloc_intr_gate>> if (!test_and_set_bit(n, used_vectors))
+ *   - arch/x86/kernel/irq.c|138| <<arch_show_interrupts>> if (test_bit(HYPERVISOR_CALLBACK_VECTOR, used_vectors)) {
+ *   - arch/x86/kernel/irq.c|433| <<check_irq_vectors_for_cpu_disable>> if (!test_bit(vector, used_vectors) &&
+ */
 DECLARE_BITMAP(used_vectors, NR_VECTORS);
 
 static inline void cond_local_irq_enable(struct pt_regs *regs)
diff --git a/arch/x86/kernel/x86_init.c b/arch/x86/kernel/x86_init.c
index 5b2d10c..6635ae7 100644
--- a/arch/x86/kernel/x86_init.c
+++ b/arch/x86/kernel/x86_init.c
@@ -125,6 +125,14 @@ struct x86_msi_ops x86_msi __ro_after_init = {
 /* MSI arch specific hooks */
 int arch_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
 {
+	/*
+	 * 一个例子是native_setup_msi_irqs()
+	 *
+	 * xen上的例子:
+	 *   - arch/x86/pci/xen.c|418| <<pci_xen_init>> x86_msi.setup_msi_irqs = xen_setup_msi_irqs;
+	 *   - arch/x86/pci/xen.c|443| <<xen_msi_init>> x86_msi.setup_msi_irqs = xen_hvm_setup_msi_irqs;
+	 *   - arch/x86/pci/xen.c|478| <<pci_xen_initial_domain>> x86_msi.setup_msi_irqs = xen_initdom_setup_msi_irqs;
+	 */
 	return x86_msi.setup_msi_irqs(dev, nvec, type);
 }
 
@@ -144,6 +152,13 @@ void arch_restore_msi_irqs(struct pci_dev *dev)
 }
 #endif
 
+/*
+ * used by:
+ *   - arch/x86/include/asm/io_apic.h|190| <<io_apic_read>> return x86_io_apic_ops.read(apic, reg);
+ *   - arch/x86/kernel/apic/io_apic.c|1454| <<disable_IO_APIC>> x86_io_apic_ops.disable();
+ *   - arch/x86/xen/apic.c|220| <<xen_init_apic>> x86_io_apic_ops.read = xen_io_apic_read;
+ *   - drivers/iommu/irq_remapping.c|45| <<irq_remapping_modify_x86_ops>> x86_io_apic_ops.disable = irq_remapping_disable_io_apic;
+ */
 struct x86_io_apic_ops x86_io_apic_ops __ro_after_init = {
 	.read			= native_io_apic_read,
 	.disable		= native_disable_io_apic,
diff --git a/drivers/clocksource/i8253.c b/drivers/clocksource/i8253.c
index d4350bb..6609f45 100644
--- a/drivers/clocksource/i8253.c
+++ b/drivers/clocksource/i8253.c
@@ -178,6 +178,10 @@ struct clock_event_device i8253_clockevent = {
  * Initialize the conversion factor and the min/max deltas of the clock event
  * structure and register the clock event source with the framework.
  */
+/*
+ * x86下只有一处调用:
+ *   - arch/x86/kernel/i8253.c|23| <<setup_pit_timer>> clockevent_i8253_init(true);
+ */
 void __init clockevent_i8253_init(bool oneshot)
 {
 	if (oneshot) {
diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c
index 06355ca..257de02 100644
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@ -36,6 +36,43 @@
 
 #include "nvme.h"
 
+/*
+ * nvme申请vector的过程
+ * nvme_reset_work()
+ * nvme_setup_io_queues()
+ * pci_alloc_irq_vectors()
+ * pci_alloc_irq_vectors_affinity()
+ * __pci_enable_msix_range()
+ * __pci_enable_msix()
+ * msix_capability_init()
+ * pci_msi_setup_msi_irqs() (domain=NULL)
+ * arch_setup_msi_irqs()
+ * x86_msi.setup_msi_irqs = native_setup_msi_irqs()
+ * msi_domain_alloc_irqs()
+ * __irq_domain_alloc_irqs()
+ * irq_domain_alloc_irqs_hierarchy()
+ * domain->ops->alloc = msi_domain_alloc()
+ * irq_domain_alloc_irqs_parent()
+ * irq_domain_alloc_irqs_hierarchy()
+ * domain->ops->alloc = x86_vector_alloc_irqs()
+ * assign_irq_vector_policy()
+ * assign_irq_vector()
+ * __assign_irq_vector()
+ *
+ * nvme hotplug申请vector的过程
+ * [0] __assign_irq_vector
+ * [0] assign_irq_vector
+ * [0] msi_domain_set_affinity
+ * [0] irq_do_set_affinity
+ * [0] irq_startup
+ * [0] irq_affinity_online_cpu
+ * [0] cpuhp_invoke_callback
+ * [0] cpuhp_thread_fun
+ * [0] smpboot_thread_fn
+ * [0] kthread
+ * [0] ret_from_fork
+ */
+
 #define SQ_SIZE(depth)		(depth * sizeof(struct nvme_command))
 #define CQ_SIZE(depth)		(depth * sizeof(struct nvme_completion))
 
diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c
index 536e9a5..d767cab 100644
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -32,11 +32,22 @@ int pci_msi_ignore_mask;
 #define msix_table_size(flags)	((flags & PCI_MSIX_FLAGS_QSIZE) + 1)
 
 #ifdef CONFIG_PCI_MSI_IRQ_DOMAIN
+/*
+ * called by:
+ *   - drivers/pci/msi.c|637| <<msi_capability_init>> ret = pci_msi_setup_msi_irqs(dev, nvec, PCI_CAP_ID_MSI);
+ *   - drivers/pci/msi.c|809| <<msix_capability_init>> ret = pci_msi_setup_msi_irqs(dev, nvec, PCI_CAP_ID_MSIX);
+ *
+ * 是所有相关的irq一起调用一次, 不是一个irq一次
+ */
 static int pci_msi_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)
 {
+	/* include/linux/irqdomain.h */
 	struct irq_domain *domain;
 
 	domain = dev_get_msi_domain(&dev->dev);
+	/*
+	 * 在简单的nvme测试上, 此处domain为NULL
+	 */
 	if (domain && irq_domain_is_hierarchy(domain))
 		return msi_domain_alloc_irqs(domain, &dev->dev, nvec);
 
@@ -531,6 +542,10 @@ static int populate_msi_sysfs(struct pci_dev *pdev)
 	return ret;
 }
 
+/*
+ * called by only:
+ *   - drivers/pci/msi.c|614| <<msi_capability_init>> entry = msi_setup_entry(dev, nvec, affd);
+ */
 static struct msi_desc *
 msi_setup_entry(struct pci_dev *dev, int nvec, const struct irq_affinity *affd)
 {
@@ -597,6 +612,10 @@ static int msi_verify_entries(struct pci_dev *dev)
  * an error, and a positive return value indicates the number of interrupts
  * which could have been allocated.
  */
+/*
+ * called by:
+ *   - drivers/pci/msi.c|1060| <<__pci_enable_msi_range>> rc = msi_capability_init(dev, nvec, affd);
+ */
 static int msi_capability_init(struct pci_dev *dev, int nvec,
 			       const struct irq_affinity *affd)
 {
@@ -614,6 +633,14 @@ static int msi_capability_init(struct pci_dev *dev, int nvec,
 	mask = msi_mask(entry->msi_attrib.multi_cap);
 	msi_mask_irq(entry, mask, mask);
 
+	/*
+	 * msi_list在以使用:
+	 *   - drivers/base/core.c|1424| <<device_initialize>> INIT_LIST_HEAD(&dev->msi_list);
+	 *   - drivers/pci/msi.c|344| <<free_msi_irqs>> struct list_head *msi_list = dev_to_msi_list(&dev->dev);
+	 *   - drivers/pci/msi.c|357| <<free_msi_irqs>> list_for_each_entry_safe(entry, tmp, msi_list, list) {
+	 *   - drivers/pci/msi.c|359| <<free_msi_irqs>> if (list_is_last(&entry->list, msi_list))
+	 *   - include/linux/msi.h|125| <<dev_to_msi_list>> #define dev_to_msi_list(dev) (&(dev)->msi_list)
+	 */
 	list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
 
 	/* Configure MSI capability structure */
@@ -648,6 +675,10 @@ static int msi_capability_init(struct pci_dev *dev, int nvec,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/pci/msi.c|793| <<msix_capability_init>> base = msix_map_region(dev, msix_table_size(control));
+ */
 static void __iomem *msix_map_region(struct pci_dev *dev, unsigned nr_entries)
 {
 	resource_size_t phys_addr;
@@ -668,6 +699,22 @@ static void __iomem *msix_map_region(struct pci_dev *dev, unsigned nr_entries)
 	return ioremap_nocache(phys_addr, nr_entries * PCI_MSIX_ENTRY_SIZE);
 }
 
+/*
+ * qemu nvme 4个cpu的例子: 两次进入以下, nvec=1和nvec=4
+ * [0] msix_setup_entries
+ * [0] __pci_enable_msix_range
+ * [0] pci_alloc_irq_vectors_affinity
+ * [0] nvme_reset_work
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/pci/msi.c|768| <<msix_capability_init>> ret = msix_setup_entries(dev, base, entries, nvec, affd);
+ *
+ * 分配nvec个struct msi_desc简单初始化并链接到dev_to_msi_list(&dev->dev)
+ */
 static int msix_setup_entries(struct pci_dev *dev, void __iomem *base,
 			      struct msix_entry *entries, int nvec,
 			      const struct irq_affinity *affd)
@@ -700,6 +747,17 @@ static int msix_setup_entries(struct pci_dev *dev, void __iomem *base,
 		entry->msi_attrib.default_irq	= dev->irq;
 		entry->mask_base		= base;
 
+		/*
+		 * dev_to_msi_list()的一些调用的地方:
+		 *   - drivers/pci/msi.c|344| <<free_msi_irqs>> struct list_head *msi_list = dev_to_msi_list(&dev->dev);
+		 *   - drivers/pci/msi.c|418| <<__pci_restore_msix_state>> BUG_ON(list_empty(dev_to_msi_list(&dev->dev)));
+		 *   - drivers/pci/msi.c|618| <<msi_capability_init>> list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
+		 *   - drivers/pci/msi.c|704| <<msix_setup_entries>> list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
+		 *   - drivers/pci/msi.c|889| <<pci_msi_shutdown>> BUG_ON(list_empty(dev_to_msi_list(&dev->dev)));
+		 *   - include/linux/msi.h|116| <<first_msi_entry>> list_first_entry(dev_to_msi_list((dev)), struct msi_desc, list)
+		 *   - include/linux/msi.h|118| <<for_each_msi_entry>> list_for_each_entry((desc), dev_to_msi_list((dev)), list)
+		 *   - include/linux/msi.h|120| <<for_each_msi_entry_safe>> list_for_each_entry_safe((desc), (tmp), dev_to_msi_list((dev)), list)
+		 */
 		list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
 		if (masks)
 			curmsk++;
@@ -710,6 +768,10 @@ static int msix_setup_entries(struct pci_dev *dev, void __iomem *base,
 	return ret;
 }
 
+/*
+ * called by only:
+ *   - drivers/pci/msi.c|836| <<msix_capability_init>> msix_program_entries(dev, entries);
+ */
 static void msix_program_entries(struct pci_dev *dev,
 				 struct msix_entry *entries)
 {
@@ -736,6 +798,12 @@ static void msix_program_entries(struct pci_dev *dev,
  * single MSI-X irq. A return of zero indicates the successful setup of
  * requested MSI-X entries with allocated irqs or non-zero for otherwise.
  **/
+/*
+ * called by:
+ *   - drivers/pci/msi.c|980| <<__pci_enable_msix>> return msix_capability_init(dev, entries, nvec, affd);
+ *
+ * 从nvme进来的时候affd应该是&msi_default_affd
+ */
 static int msix_capability_init(struct pci_dev *dev, struct msix_entry *entries,
 				int nvec, const struct irq_affinity *affd)
 {
@@ -752,10 +820,18 @@ static int msix_capability_init(struct pci_dev *dev, struct msix_entry *entries,
 	if (!base)
 		return -ENOMEM;
 
+	/*
+	 * 分配nvec个struct msi_desc简单初始化并链接到dev_to_msi_list(&dev->dev)
+	 */
 	ret = msix_setup_entries(dev, base, entries, nvec, affd);
 	if (ret)
 		return ret;
 
+	/*
+	 * 核心函数!!
+	 *
+	 * 是所有相关的irq一起调用一次, 不是一个irq一次
+	 */
 	ret = pci_msi_setup_msi_irqs(dev, nvec, PCI_CAP_ID_MSIX);
 	if (ret)
 		goto out_avail;
@@ -932,6 +1008,10 @@ int pci_msix_vec_count(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_msix_vec_count);
 
+/*
+ * called by:
+ *   - drivers/pci/msi.c|1137| <<__pci_enable_msix_range>> rc = __pci_enable_msix(dev, entries, nvec, affd);
+ */
 static int __pci_enable_msix(struct pci_dev *dev, struct msix_entry *entries,
 			     int nvec, const struct irq_affinity *affd)
 {
@@ -941,12 +1021,16 @@ static int __pci_enable_msix(struct pci_dev *dev, struct msix_entry *entries,
 	if (!pci_msi_supported(dev, nvec))
 		return -EINVAL;
 
+	/*
+	 * return the number of device's MSI-X table entries
+	 */
 	nr_entries = pci_msix_vec_count(dev);
 	if (nr_entries < 0)
 		return nr_entries;
 	if (nvec > nr_entries)
 		return nr_entries;
 
+	/* nvme的io queue进来entries是NULL */
 	if (entries) {
 		/* Check for any invalid entries */
 		for (i = 0; i < nvec; i++) {
@@ -964,6 +1048,9 @@ static int __pci_enable_msix(struct pci_dev *dev, struct msix_entry *entries,
 		dev_info(&dev->dev, "can't enable MSI-X (MSI IRQ already assigned)\n");
 		return -EINVAL;
 	}
+	/*
+	 * 从nvme进来的时候affd应该是&msi_default_affd
+	 */
 	return msix_capability_init(dev, entries, nvec, affd);
 }
 
@@ -1018,6 +1105,11 @@ int pci_msi_enabled(void)
 }
 EXPORT_SYMBOL(pci_msi_enabled);
 
+/*
+ * called by:
+ *   - drivers/pci/msi.c|1076| <<pci_enable_msi>> int rc = __pci_enable_msi_range(dev, 1, 1, NULL);
+ *   - drivers/pci/msi.c|1178| <<pci_alloc_irq_vectors_affinity>> vecs = __pci_enable_msi_range(dev, min_vecs, max_vecs, affd);
+ */
 static int __pci_enable_msi_range(struct pci_dev *dev, int minvec, int maxvec,
 				  const struct irq_affinity *affd)
 {
@@ -1079,6 +1171,11 @@ int pci_enable_msi(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(pci_enable_msi);
 
+/*
+ * called by:
+ *   - drivers/pci/msi.c|1183| <<pci_enable_msix_range>> return __pci_enable_msix_range(dev, entries, minvec, maxvec, NULL);
+ *   - drivers/pci/msi.c|1221| <<pci_alloc_irq_vectors_affinity>> vecs = __pci_enable_msix_range(dev, NULL, min_vecs, max_vecs,
+ */
 static int __pci_enable_msix_range(struct pci_dev *dev,
 				   struct msix_entry *entries, int minvec,
 				   int maxvec, const struct irq_affinity *affd)
@@ -1088,16 +1185,39 @@ static int __pci_enable_msix_range(struct pci_dev *dev,
 	if (maxvec < minvec)
 		return -ERANGE;
 
+	/*
+	 * dev->msix_enabled在以下设置:
+	 *   - drivers/pci/msi.c|844| <<msix_capability_init>> dev->msix_enabled = 1;
+	 *   - drivers/pci/msi.c|1042| <<pci_msix_shutdown>> dev->msix_enabled = 0;
+	 *   - drivers/pci/msi.c|1054| <<pci_msix_shutdown>> dev->msix_enabled = 0;
+	 */
 	if (WARN_ON_ONCE(dev->msix_enabled))
 		return -EINVAL;
 
 	for (;;) {
+		/*
+		 * 从nvme进来的时候affd应该是&msi_default_affd
+		 */
 		if (affd) {
+			/*
+			 * Calculate the optimal number of vectors
+			 */
 			nvec = irq_calc_affinity_vectors(minvec, nvec, affd);
 			if (nvec < minvec)
 				return -ENOSPC;
 		}
 
+		/*
+		 * nvme_reset_work()
+		 *  -> nvme_setup_io_queues()
+		 *      -> pci_alloc_irq_vectors()
+		 *          -> pci_alloc_irq_vectors_affinity()
+		 *              -> __pci_enable_msix_range()
+		 *                  -> __pci_enable_msix()
+		 * nvme的io queue进来的时候entries是NULL
+		 *
+		 * 从nvme进来的时候affd应该是&msi_default_affd
+		 */
 		rc = __pci_enable_msix(dev, entries, nvec, affd);
 		if (rc == 0)
 			return nvec;
@@ -1126,6 +1246,10 @@ static int __pci_enable_msix_range(struct pci_dev *dev,
  * indicates the successful configuration of MSI-X capability structure
  * with new allocated MSI-X interrupts.
  **/
+/*
+ * 一些调用的例子:
+ *   - drivers/net/ethernet/intel/e1000e/netdev.c|2079| <<e1000e_set_interrupt_capability>> err = pci_enable_msix_range(a->pdev,
+ */
 int pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries,
 		int minvec, int maxvec)
 {
@@ -1151,6 +1275,9 @@ EXPORT_SYMBOL(pci_enable_msix_range);
  * To get the Linux IRQ number used for a vector that can be passed to
  * request_irq() use the pci_irq_vector() helper.
  */
+/*
+ * nvme的io queue进来的话affd是NULL
+ */
 int pci_alloc_irq_vectors_affinity(struct pci_dev *dev, unsigned int min_vecs,
 				   unsigned int max_vecs, unsigned int flags,
 				   const struct irq_affinity *affd)
@@ -1159,6 +1286,9 @@ int pci_alloc_irq_vectors_affinity(struct pci_dev *dev, unsigned int min_vecs,
 	int vecs = -ENOSPC;
 
 	if (flags & PCI_IRQ_AFFINITY) {
+		/*
+		 * 从nvme进入到这里的时候应该是到这里吧
+		 */
 		if (!affd)
 			affd = &msi_default_affd;
 	} else {
@@ -1166,6 +1296,9 @@ int pci_alloc_irq_vectors_affinity(struct pci_dev *dev, unsigned int min_vecs,
 			affd = NULL;
 	}
 
+	/*
+	 * 从nvme的io queue进来的时候msix, msi和legacy都会设置
+	 */
 	if (flags & PCI_IRQ_MSIX) {
 		vecs = __pci_enable_msix_range(dev, NULL, min_vecs, max_vecs,
 				affd);
@@ -1379,6 +1512,7 @@ static void pci_msi_domain_set_desc(msi_alloc_info_t *arg,
 				    struct msi_desc *desc)
 {
 	arg->desc = desc;
+	/* Generate a unique ID for an MSI source */
 	arg->hwirq = pci_msi_domain_calc_hwirq(msi_desc_to_pci_dev(desc),
 					       desc);
 }
@@ -1386,12 +1520,20 @@ static void pci_msi_domain_set_desc(msi_alloc_info_t *arg,
 #define pci_msi_domain_set_desc		NULL
 #endif
 
+/*
+ * used by:
+ *   - drivers/pci/msi.c|1468| <<pci_msi_domain_update_dom_ops>> info->ops = &pci_msi_domain_ops_default;
+ */
 static struct msi_domain_ops pci_msi_domain_ops_default = {
 	.set_desc	= pci_msi_domain_set_desc,
 	.msi_check	= pci_msi_domain_check_cap,
 	.handle_error	= pci_msi_domain_handle_error,
 };
 
+/*
+ * called by only:
+ *   - drivers/pci/msi.c|1510| <<pci_msi_create_irq_domain>> pci_msi_domain_update_dom_ops(info);
+ */
 static void pci_msi_domain_update_dom_ops(struct msi_domain_info *info)
 {
 	struct msi_domain_ops *ops = info->ops;
diff --git a/include/linux/device.h b/include/linux/device.h
index 66fe271..612e07e 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -916,6 +916,14 @@ struct device {
 	struct dev_pin_info	*pins;
 #endif
 #ifdef CONFIG_GENERIC_MSI_IRQ
+	/*
+	 * 在以下使用:
+	 *   - drivers/base/core.c|1424| <<device_initialize>> INIT_LIST_HEAD(&dev->msi_list);
+	 *   - drivers/pci/msi.c|344| <<free_msi_irqs>> struct list_head *msi_list = dev_to_msi_list(&dev->dev);
+	 *   - drivers/pci/msi.c|357| <<free_msi_irqs>> list_for_each_entry_safe(entry, tmp, msi_list, list) {
+	 *   - drivers/pci/msi.c|359| <<free_msi_irqs>> if (list_is_last(&entry->list, msi_list))
+	 *   - include/linux/msi.h|125| <<dev_to_msi_list>> #define dev_to_msi_list(dev) (&(dev)->msi_list)
+	 */
 	struct list_head	msi_list;
 #endif
 
@@ -1008,12 +1016,22 @@ static inline void set_dev_node(struct device *dev, int node)
 static inline struct irq_domain *dev_get_msi_domain(const struct device *dev)
 {
 #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
+	/*
+	 * 在以下设置:
+	 *   - include/linux/device.h|1034| <<dev_set_msi_domain>> dev->msi_domain = d;
+	 */
 	return dev->msi_domain;
 #else
 	return NULL;
 #endif
 }
 
+/*
+ * called by:
+ *   - drivers/pci/host/vmd.c|658| <<vmd_enable_domain>> dev_set_msi_domain(&vmd->bus->dev, vmd->irq_domain);
+ *   - drivers/pci/probe.c|748| <<pci_set_bus_msi_domain>> dev_set_msi_domain(&bus->dev, d);
+ *   - drivers/pci/probe.c|2081| <<pci_set_msi_domain>> dev_set_msi_domain(&dev->dev, d);
+ */
 static inline void dev_set_msi_domain(struct device *dev, struct irq_domain *d)
 {
 #ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
diff --git a/include/linux/irq.h b/include/linux/irq.h
index 0d53626..f4a36f4 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -153,6 +153,14 @@ struct irq_common_data {
 	struct msi_desc		*msi_desc;
 	cpumask_var_t		affinity;
 #ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK
+	/*
+	 * used by:
+	 *   - include/linux/irq.h|796| <<irq_data_get_effective_affinity_mask>> return d->common->effective_affinity;
+	 *   - include/linux/irq.h|801| <<irq_data_update_effective_affinity>> cpumask_copy(d->common->effective_affinity, m);
+	 *   - kernel/irq/irqdesc.c|62| <<alloc_masks>> if (!zalloc_cpumask_var_node(&desc->irq_common_data.effective_affinity,
+	 *   - kernel/irq/irqdesc.c|72| <<alloc_masks>> free_cpumask_var(desc->irq_common_data.effective_affinity);
+	 *   - kernel/irq/irqdesc.c|349| <<free_masks>> free_cpumask_var(desc->irq_common_data.effective_affinity);
+	 */
 	cpumask_var_t		effective_affinity;
 #endif
 #ifdef CONFIG_GENERIC_IRQ_IPI
@@ -790,11 +798,33 @@ static inline struct cpumask *irq_data_get_affinity_mask(struct irq_data *d)
 }
 
 #ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/apic.c|2330| <<flat_cpu_mask_to_apicid>> struct cpumask *effmsk = irq_data_get_effective_affinity_mask(irqdata);
+ *   - arch/x86/kernel/apic/x2apic_cluster.c|167| <<x2apic_cpu_mask_to_apicid>> struct cpumask *effmsk = irq_data_get_effective_affinity_mask(irqdata);
+ *   - kernel/irq/cpuhotplug.c|20| <<irq_needs_fixup>> const struct cpumask *m = irq_data_get_effective_affinity_mask(d);
+ *   - kernel/irq/debugfs.c|40| <<irq_debug_show_masks>> msk = irq_data_get_effective_affinity_mask(data);
+ *   - kernel/irq/manage.c|174| <<irq_validate_effective_affinity>> const struct cpumask *m = irq_data_get_effective_affinity_mask(data);
+ *   - kernel/irq/proc.c|89| <<show_irq_affinity>> mask = irq_data_get_effective_affinity_mask(&desc->irq_data);
+ */
 static inline
 struct cpumask *irq_data_get_effective_affinity_mask(struct irq_data *d)
 {
+	/*
+	 * used by:
+	 *   - include/linux/irq.h|796| <<irq_data_get_effective_affinity_mask>> return d->common->effective_affinity;
+	 *   - include/linux/irq.h|801| <<irq_data_update_effective_affinity>> cpumask_copy(d->common->effective_affinity, m);
+	 *   - kernel/irq/irqdesc.c|62| <<alloc_masks>> if (!zalloc_cpumask_var_node(&desc->irq_common_data.effective_affinity,
+	 *   - kernel/irq/irqdesc.c|72| <<alloc_masks>> free_cpumask_var(desc->irq_common_data.effective_affinity);
+	 *   - kernel/irq/irqdesc.c|349| <<free_masks>> free_cpumask_var(desc->irq_common_data.effective_affinity);
+	 */
 	return d->common->effective_affinity;
 }
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/apic.c|2321| <<default_cpu_mask_to_apicid>> irq_data_update_effective_affinity(irqdata, cpumask_of(cpu));
+ *   - drivers/xen/events/events_base.c|1339| <<set_affinity_irq>> irq_data_update_effective_affinity(data, cpumask_of(tcpu));
+ */
 static inline void irq_data_update_effective_affinity(struct irq_data *d,
 						      const struct cpumask *m)
 {
diff --git a/include/linux/irqdomain.h b/include/linux/irqdomain.h
index b1037df..ef0a477 100644
--- a/include/linux/irqdomain.h
+++ b/include/linux/irqdomain.h
@@ -108,11 +108,27 @@ struct irq_domain_ops {
 
 #ifdef	CONFIG_IRQ_DOMAIN_HIERARCHY
 	/* extended V2 interfaces to support hierarchy irq_domains */
+	/*
+	 * called by:
+	 *   - kernel/irq/irqdomain.c|1780| <<__irq_domain_activate_irq>> domain->ops->activate(domain, irq_data);
+	 */
 	int (*alloc)(struct irq_domain *d, unsigned int virq,
 		     unsigned int nr_irqs, void *arg);
+	/*
+	 * called by:
+	 *   - kernel/irq/irqdomain.c|1790| <<__irq_domain_deactivate_irq>> domain->ops->deactivate(domain, irq_data);
+	 */
 	void (*free)(struct irq_domain *d, unsigned int virq,
 		     unsigned int nr_irqs);
+	/*
+	 * called by:
+	 *   - kernel/irq/irqdomain.c|1780| <<__irq_domain_activate_irq>> domain->ops->activate(domain, irq_data);
+	 */
 	void (*activate)(struct irq_domain *d, struct irq_data *irq_data);
+	/*
+	 * called by:             
+	 *   - kernel/irq/irqdomain.c|1790| <<__irq_domain_deactivate_irq>> domain->ops->deactivate(domain, irq_data);
+	 */
 	void (*deactivate)(struct irq_domain *d, struct irq_data *irq_data);
 	int (*translate)(struct irq_domain *d, struct irq_fwspec *fwspec,
 			 unsigned long *out_hwirq, unsigned int *out_type);
@@ -179,6 +195,11 @@ struct irq_domain {
 /* Irq domain flags */
 enum {
 	/* Irq domain is hierarchical */
+	/*
+	 * used by:
+	 *   - include/linux/irqdomain.h|509| <<irq_domain_is_hierarchy>> return domain->flags & IRQ_DOMAIN_FLAG_HIERARCHY;
+	 *   - kernel/irq/irqdomain.c|1893| <<irq_domain_check_hierarchy>> domain->flags |= IRQ_DOMAIN_FLAG_HIERARCHY;
+	 */
 	IRQ_DOMAIN_FLAG_HIERARCHY	= (1 << 0),
 
 	/* Irq domain name was allocated in __irq_domain_add() */
@@ -339,6 +360,12 @@ static inline struct irq_domain *irq_domain_create_linear(struct fwnode_handle *
 					 const struct irq_domain_ops *ops,
 					 void *host_data)
 {
+	/*
+	 * 如果是从ioapic进来的:
+	 *   ops可以是struct irq_domain_ops mp_ioapic_irqdomain_ops
+	 *   size是ioapic的pin的数量
+	 *   host_data是ioapic的id
+	 */
 	return __irq_domain_add(fwnode, size, size, 0, ops, host_data);
 }
 
@@ -441,6 +468,14 @@ extern void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs);
 extern void irq_domain_activate_irq(struct irq_data *irq_data);
 extern void irq_domain_deactivate_irq(struct irq_data *irq_data);
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/htirq.c|192| <<arch_setup_ht_irq>> return irq_domain_alloc_irqs(htirq_domain, 1, dev_to_node(&dev->dev),
+ *   - arch/x86/kernel/apic/msi.c|280| <<dmar_alloc_hwirq>> return irq_domain_alloc_irqs(domain, 1, node, &info);
+ *   - arch/x86/kernel/apic/msi.c|400| <<hpet_assign_irq>> return irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, &info);
+ *   - arch/x86/platform/uv/uv_irq.c|204| <<uv_setup_irq>> return irq_domain_alloc_irqs(domain, 1,
+ *   - kernel/irq/irqdomain.c|907| <<irq_create_fwspec_mapping>> virq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec);
+ */
 static inline int irq_domain_alloc_irqs(struct irq_domain *domain,
 			unsigned int nr_irqs, int node, void *arg)
 {
@@ -476,6 +511,11 @@ extern void irq_domain_free_irqs_parent(struct irq_domain *domain,
 
 static inline bool irq_domain_is_hierarchy(struct irq_domain *domain)
 {
+	/*
+	 * used by:
+	 *   - include/linux/irqdomain.h|509| <<irq_domain_is_hierarchy>> return domain->flags & IRQ_DOMAIN_FLAG_HIERARCHY;
+	 *   - kernel/irq/irqdomain.c|1893| <<irq_domain_check_hierarchy>> domain->flags |= IRQ_DOMAIN_FLAG_HIERARCHY;
+	 */
 	return domain->flags & IRQ_DOMAIN_FLAG_HIERARCHY;
 }
 
diff --git a/include/linux/msi.h b/include/linux/msi.h
index a89cdea..5c25e10 100644
--- a/include/linux/msi.h
+++ b/include/linux/msi.h
@@ -72,6 +72,9 @@ struct fsl_mc_msi_desc {
 struct msi_desc {
 	/* Shared device/bus type independent data */
 	struct list_head		list;
+	/*
+	 * 会使用irq_set_msi_desc_off()修改struct msi_desc的irq!!!
+	 */
 	unsigned int			irq;
 	unsigned int			nvec_used;
 	struct device			*dev;
@@ -111,6 +114,17 @@ struct msi_desc {
 
 /* Helpers to hide struct msi_desc implementation details */
 #define msi_desc_to_dev(desc)		((desc)->dev)
+/*
+ * 一些调用的地方:
+ *   - drivers/pci/msi.c|344| <<free_msi_irqs>> struct list_head *msi_list = dev_to_msi_list(&dev->dev);
+ *   - drivers/pci/msi.c|418| <<__pci_restore_msix_state>> BUG_ON(list_empty(dev_to_msi_list(&dev->dev)));
+ *   - drivers/pci/msi.c|618| <<msi_capability_init>> list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
+ *   - drivers/pci/msi.c|704| <<msix_setup_entries>> list_add_tail(&entry->list, dev_to_msi_list(&dev->dev));
+ *   - drivers/pci/msi.c|889| <<pci_msi_shutdown>> BUG_ON(list_empty(dev_to_msi_list(&dev->dev)));
+ *   - include/linux/msi.h|116| <<first_msi_entry>> list_first_entry(dev_to_msi_list((dev)), struct msi_desc, list)
+ *   - include/linux/msi.h|118| <<for_each_msi_entry>> list_for_each_entry((desc), dev_to_msi_list((dev)), list)
+ *   - include/linux/msi.h|120| <<for_each_msi_entry_safe>> list_for_each_entry_safe((desc), (tmp), dev_to_msi_list((dev)), list)
+ */
 #define dev_to_msi_list(dev)		(&(dev)->msi_list)
 #define first_msi_entry(dev)		\
 	list_first_entry(dev_to_msi_list((dev)), struct msi_desc, list)
diff --git a/include/linux/pci.h b/include/linux/pci.h
index b1abbcc..1cfac35 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -1414,6 +1414,12 @@ static inline int pci_irq_get_node(struct pci_dev *pdev, int vec)
 }
 #endif
 
+/*
+ * 从nvme的io queue调用的例子:
+ *
+ * 1851         nr_io_queues = pci_alloc_irq_vectors(pdev, 1, nr_io_queues,
+ * 1852                         PCI_IRQ_ALL_TYPES | PCI_IRQ_AFFINITY);
+ */
 static inline int
 pci_alloc_irq_vectors(struct pci_dev *dev, unsigned int min_vecs,
 		      unsigned int max_vecs, unsigned int flags)
diff --git a/kernel/cpu.c b/kernel/cpu.c
index 8c350dd..ca6a84a 100644
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -814,6 +814,10 @@ void clear_tasks_mm_cpumask(int cpu)
 }
 
 /* Take this CPU down. */
+/*
+ * called by only:
+ *   - kernel/cpu.c|868| <<takedown_cpu>> err = stop_machine_cpuslocked(take_cpu_down, NULL, cpumask_of(cpu));
+ */
 static int take_cpu_down(void *_param)
 {
 	struct cpuhp_cpu_state *st = this_cpu_ptr(&cpuhp_state);
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index 317fc75..865dd8a 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -110,6 +110,16 @@ EXPORT_SYMBOL(irq_set_handler_data);
  *
  *	Set the MSI descriptor entry for an irq at offset
  */
+/*
+ * called by:
+ *   - kernel/irq/chip.c|137| <<irq_set_msi_desc>> return irq_set_msi_desc_off(irq, 0, entry);
+ *   - kernel/irq/msi.c|359| <<msi_domain_populate_irqs>> irq_set_msi_desc_off(desc->irq, 0, desc);
+ *   - kernel/irq/msi.c|470| <<msi_domain_alloc_irqs>> irq_set_msi_desc_off(virq, i, desc);
+ *
+ * 这个函数会修改desc->irq_common_data.msi_desc = entry
+ *
+ * 主要是会修改entry->irq = irq_base!!!!
+ */
 int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,
 			 struct msi_desc *entry)
 {
@@ -119,6 +129,9 @@ int irq_set_msi_desc_off(unsigned int irq_base, unsigned int irq_offset,
 	if (!desc)
 		return -EINVAL;
 	desc->irq_common_data.msi_desc = entry;
+	/*
+	 * 这里的entry是struct msi_desc
+	 */
 	if (entry && !irq_offset)
 		entry->irq = irq_base;
 	irq_put_desc_unlock(desc, flags);
@@ -157,6 +170,9 @@ int irq_set_chip_data(unsigned int irq, void *data)
 }
 EXPORT_SYMBOL(irq_set_chip_data);
 
+/*
+ * 获得irq的struct irq_desc *desc, 返回desc->irq_data
+ */
 struct irq_data *irq_get_irq_data(unsigned int irq)
 {
 	struct irq_desc *desc = irq_to_desc(irq);
@@ -1246,6 +1262,10 @@ EXPORT_SYMBOL_GPL(irq_chip_disable_parent);
  * irq_chip_ack_parent - Acknowledge the parent interrupt
  * @data:	Pointer to interrupt specific data
  */
+/*
+ * struct irq_chip ioapic_chip.irq_ack = irq_chip_ack_parent()
+ * struct irq_chip ioapic_ir_chip.irq_ack = irq_chip_ack_parent()
+ */
 void irq_chip_ack_parent(struct irq_data *data)
 {
 	data = data->parent_data;
@@ -1330,6 +1350,10 @@ EXPORT_SYMBOL_GPL(irq_chip_set_type_parent);
  * Iterate through the domain hierarchy of the interrupt and check
  * whether a hw retrigger function exists. If yes, invoke it.
  */
+/*
+ * struct irq_chip ioapic_chip.irq_retrigger = irq_chip_retrigger_hierarchy()
+ * struct irq_chip ioapic_ir_chip.irq_retrigger = irq_chip_retrigger_hierarchy()
+ */
 int irq_chip_retrigger_hierarchy(struct irq_data *data)
 {
 	for (data = data->parent_data; data; data = data->parent_data)
diff --git a/kernel/irq/cpuhotplug.c b/kernel/irq/cpuhotplug.c
index 9eb09ae..ec768c6 100644
--- a/kernel/irq/cpuhotplug.c
+++ b/kernel/irq/cpuhotplug.c
@@ -48,6 +48,10 @@ static inline bool irq_needs_fixup(struct irq_data *d)
 	return cpumask_test_cpu(cpu, m);
 }
 
+/*
+ * called by:
+ *   - kernel/irq/cpuhotplug.c|163| <<irq_migrate_all_off_this_cpu>> affinity_broken = migrate_one_irq(desc);
+ */
 static bool migrate_one_irq(struct irq_desc *desc)
 {
 	struct irq_data *d = irq_desc_get_irq_data(desc);
@@ -150,11 +154,38 @@ static bool migrate_one_irq(struct irq_desc *desc)
  * Note: we must iterate over all IRQs, whether they have an attached
  * action structure or not, as we need to get chained interrupts too.
  */
+/*
+ * [  234.140616] orabug: irq_msi_compose_msg() vector=65, apicid=13
+ * [  234.140617] CPU: 1 PID: 13 Comm: migration/1 Not tainted 4.14.113 #2
+ * [  234.140618] Call Trace:
+ * [  234.140623]  dump_stack+0x46/0x62
+ * [  234.140625]  irq_chip_compose_msi_msg+0x42/0x50
+ * [  234.140626]  msi_domain_set_affinity+0x35/0x60
+ * [  234.140628]  irq_do_set_affinity+0x28/0xa0
+ * [  234.140630]  irq_migrate_all_off_this_cpu+0x19c/0x2a0
+ * [  234.140631]  fixup_irqs+0x1e/0xe0
+ * [  234.140633]  native_cpu_disable+0x1b/0x30
+ * [  234.140635]  take_cpu_down+0x34/0x90
+ * [  234.140636]  multi_cpu_stop+0x86/0xb0
+ * [  234.140637]  ? cpu_stop_queue_work+0xa0/0xa0
+ * [  234.140638]  cpu_stopper_thread+0x76/0xe0
+ * [  234.140640]  smpboot_thread_fn+0x109/0x160
+ * [  234.140641]  kthread+0xfa/0x130
+ * [  234.140642]  ? sort_range+0x20/0x20
+ * [  234.140643]  ? kthread_create_on_node+0x40/0x40
+ * [  234.140645]  ret_from_fork+0x35/0x40
+ *
+ * called by:
+ *   - arch/x86/kernel/irq.c|477| <<fixup_irqs>> irq_migrate_all_off_this_cpu();
+ */
 void irq_migrate_all_off_this_cpu(void)
 {
 	struct irq_desc *desc;
 	unsigned int irq;
 
+	/*
+	 * 这里是遍历所有的irq, 和cpu无关
+	 */
 	for_each_active_irq(irq) {
 		bool affinity_broken;
 
diff --git a/kernel/irq/irqdesc.c b/kernel/irq/irqdesc.c
index aa08d41..10572a8 100644
--- a/kernel/irq/irqdesc.c
+++ b/kernel/irq/irqdesc.c
@@ -131,6 +131,16 @@ int nr_irqs = NR_IRQS;
 EXPORT_SYMBOL_GPL(nr_irqs);
 
 static DEFINE_MUTEX(sparse_irq_lock);
+/*
+ * used by:
+ *   - kernel/irq/irqdesc.c|465| <<alloc_descs>> bitmap_set(allocated_irqs, start, cnt);
+ *   - kernel/irq/irqdesc.c|505| <<early_irq_init>> set_bit(i, allocated_irqs);
+ *   - kernel/irq/irqdesc.c|571| <<alloc_descs>> bitmap_set(allocated_irqs, start, cnt);
+ *   - kernel/irq/irqdesc.c|583| <<irq_mark_irq>> bitmap_set(allocated_irqs, irq, 1);
+ *   - kernel/irq/irqdesc.c|671| <<irq_free_descs>> bitmap_clear(allocated_irqs, from, cnt);
+ *   - kernel/irq/irqdesc.c|713| <<__irq_alloc_descs>> start = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,
+ *   - kernel/irq/irqdesc.c|790| <<irq_get_next_irq>> return find_next_bit(allocated_irqs, nr_irqs, offset);
+ */
 static DECLARE_BITMAP(allocated_irqs, IRQ_BITMAP_BITS);
 
 #ifdef CONFIG_SPARSE_IRQ
@@ -686,6 +696,15 @@ EXPORT_SYMBOL_GPL(irq_free_descs);
  *
  * Returns the first irq number or error code
  */
+/*
+ * called by:
+ *   - include/linux/irq.h|826| <<irq_alloc_descs>> __irq_alloc_descs(irq, from, cnt, node, THIS_MODULE, NULL)
+ *   - kernel/irq/devres.c|190| <<__devm_irq_alloc_descs>> base = __irq_alloc_descs(irq, from, cnt, node, owner, affinity);
+ *   - kernel/irq/irqdesc.c|751| <<irq_alloc_hwirqs>> int i, irq = __irq_alloc_descs(-1, 0, cnt, node, NULL, NULL);
+ *   - kernel/irq/irqdomain.c|1200| <<irq_domain_alloc_descs>> virq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,
+ *   - kernel/irq/irqdomain.c|1206| <<irq_domain_alloc_descs>> virq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,
+ *   - kernel/irq/irqdomain.c|1209| <<irq_domain_alloc_descs>> virq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,
+ */
 int __ref
 __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
 		  struct module *owner, const struct cpumask *affinity)
@@ -710,6 +729,17 @@ __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,
 
 	mutex_lock(&sparse_irq_lock);
 
+	/*
+	 * allocated_irqs被以下使用:
+	 *   - kernel/irq/irqdesc.c|144| <<global>> static DECLARE_BITMAP(allocated_irqs, IRQ_BITMAP_BITS);
+	 *   - kernel/irq/irqdesc.c|465| <<alloc_descs>> bitmap_set(allocated_irqs, start, cnt);
+	 *   - kernel/irq/irqdesc.c|505| <<early_irq_init>> set_bit(i, allocated_irqs);
+	 *   - kernel/irq/irqdesc.c|571| <<alloc_descs>> bitmap_set(allocated_irqs, start, cnt);
+	 *   - kernel/irq/irqdesc.c|583| <<irq_mark_irq>> bitmap_set(allocated_irqs, irq, 1);
+	 *   - kernel/irq/irqdesc.c|671| <<irq_free_descs>> bitmap_clear(allocated_irqs, from, cnt);
+	 *   - kernel/irq/irqdesc.c|713| <<__irq_alloc_descs>> start = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,
+	 *   - kernel/irq/irqdesc.c|790| <<irq_get_next_irq>> return find_next_bit(allocated_irqs, nr_irqs, offset);
+	 */
 	start = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,
 					   from, cnt, 0);
 	ret = -EEXIST;
diff --git a/kernel/irq/irqdomain.c b/kernel/irq/irqdomain.c
index ac4644e..4a2c234 100644
--- a/kernel/irq/irqdomain.c
+++ b/kernel/irq/irqdomain.c
@@ -18,6 +18,14 @@
 #include <linux/smp.h>
 #include <linux/fs.h>
 
+/*
+ * used by:
+ *   - kernel/irq/irqdomain.c|298| <<__irq_domain_add>> list_add(&domain->link, &irq_domain_list);
+ *   - kernel/irq/irqdomain.c|472| <<irq_find_matching_fwspec>> list_for_each_entry(h, &irq_domain_list, link) {
+ *   - kernel/irq/irqdomain.c|505| <<irq_domain_check_msi_remap>> list_for_each_entry(h, &irq_domain_list, link) {
+ *   - kernel/irq/irqdomain.c|1029| <<virq_debug_show>> list_for_each_entry(domain, &irq_domain_list, link) {
+ *   - kernel/irq/irqdomain.c|1961| <<irq_domain_debugfs_init>> list_for_each_entry(d, &irq_domain_list, link)
+ */
 static LIST_HEAD(irq_domain_list);
 static DEFINE_MUTEX(irq_domain_mutex);
 
@@ -125,6 +133,90 @@ EXPORT_SYMBOL_GPL(irq_domain_free_fwnode);
  * Allocates and initialize and irq_domain structure.
  * Returns pointer to IRQ domain, or NULL on failure.
  */
+/*
+ * irq: Added domain VECTOR
+ * [0] __irq_domain_add
+ * [0] arch_early_irq_init
+ * [0] start_kernel
+ * [0] secondary_startup_64
+ *
+ * irq: Added domain PCI-MSI
+ * [0] __irq_domain_add
+ * [0] irq_domain_create_hierarchy
+ * [0] msi_create_irq_domain
+ * [0] pci_msi_create_irq_domain
+ * [0] arch_init_msi_domain
+ * [0] arch_early_irq_init
+ * [0] start_kernel
+ * [0] secondary_startup_64
+ *
+ * irq: Added domain PCI-HT
+ * [0] __irq_domain_add
+ * [0] arch_init_htirq_domain
+ * [0] arch_early_irq_init
+ * [0] start_kernel
+ * [0] secondary_startup_64
+ *
+ * irq: Added domain IO-APIC-0
+ * [0] __irq_domain_add
+ * [0] mp_irqdomain_create
+ * [0] setup_IO_APIC
+ * [0] apic_bsp_setup
+ * [0] native_smp_prepare_cpus
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * irq: Added domain HPET-MSI-0
+ * [0] __irq_domain_add
+ * [0] irq_domain_create_hierarchy
+ * [0] msi_create_irq_domain
+ * [0] hpet_create_irq_domain
+ * [0] hpet_msi_capability_lookup
+ * [0] hpet_late_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * q35有个额外的
+ * irq: Added domain unknown-1
+ * [0] __irq_domain_add
+ * [0] i2c_register_adapter
+ * [0] i2c_add_adapter
+ * [0] i801_probe
+ * [0] local_pci_probe
+ * [0] pci_device_probe
+ * [0] driver_probe_device
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] i2c_i801_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - include/linux/irqdomain.h|313| <<irq_domain_add_linear>> return __irq_domain_add(of_node_to_fwnode(of_node), size, size, 0, ops, host_data);
+ *   - include/linux/irqdomain.h|320| <<irq_domain_add_nomap>> return __irq_domain_add(of_node_to_fwnode(of_node), 0, max_irq, max_irq, ops, host_data);
+ *   - include/linux/irqdomain.h|334| <<irq_domain_add_tree>> return __irq_domain_add(of_node_to_fwnode(of_node), 0, ~0, 0, ops, host_data);
+ *   - include/linux/irqdomain.h|342| <<irq_domain_create_linear>> return __irq_domain_add(fwnode, size, size, 0, ops, host_data);
+ *   - include/linux/irqdomain.h|349| <<irq_domain_create_tree>> return __irq_domain_add(fwnode, 0, ~0, 0, ops, host_data);
+ *   - kernel/irq/irqdomain.c|322| <<irq_domain_add_simple>> domain = __irq_domain_add(of_node_to_fwnode(of_node), size, size, 0, ops, host_data);
+ *   - kernel/irq/irqdomain.c|366| <<irq_domain_add_legacy>> domain = __irq_domain_add(of_node_to_fwnode(of_node), first_hwirq + size,
+ *
+ * 如果是从ioapic进来的:
+ *   ops可以是struct irq_domain_ops mp_ioapic_irqdomain_ops
+ *   size是ioapic的pin的数量
+ *   hwirq_max是ioapic的pin的数量
+ *   direct_max是0
+ *   host_data是ioapic的id
+ *
+ * 核心思想就是初始化一个struct irq_domain, 加入irq_domain_list
+ */
 struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,
 				    irq_hw_number_t hwirq_max, int direct_max,
 				    const struct irq_domain_ops *ops,
@@ -220,6 +312,14 @@ struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,
 
 	mutex_lock(&irq_domain_mutex);
 	debugfs_add_domain_dir(domain);
+	/*
+	 * used by:
+	 *   - kernel/irq/irqdomain.c|298| <<__irq_domain_add>> list_add(&domain->link, &irq_domain_list);
+	 *   - kernel/irq/irqdomain.c|472| <<irq_find_matching_fwspec>> list_for_each_entry(h, &irq_domain_list, link) {
+	 *   - kernel/irq/irqdomain.c|505| <<irq_domain_check_msi_remap>> list_for_each_entry(h, &irq_domain_list, link) {
+	 *   - kernel/irq/irqdomain.c|1029| <<virq_debug_show>> list_for_each_entry(domain, &irq_domain_list, link) {
+	 *   - kernel/irq/irqdomain.c|1961| <<irq_domain_debugfs_init>> list_for_each_entry(d, &irq_domain_list, link)
+	 */
 	list_add(&domain->link, &irq_domain_list);
 	mutex_unlock(&irq_domain_mutex);
 
@@ -468,6 +568,12 @@ static void irq_domain_clear_mapping(struct irq_domain *domain,
 	}
 }
 
+/*
+ * called by:
+ *   - kernel/irq/irqdomain.c|656| <<irq_domain_associate>> irq_domain_set_mapping(domain, hwirq, irq_data);
+ *   - kernel/irq/irqdomain.c|1261| <<irq_domain_insert_irq>> irq_domain_set_mapping(domain, data->hwirq, data);
+ *   - kernel/irq/irqdomain.c|1682| <<irq_domain_push_irq>> irq_domain_set_mapping(domain, root_irq_data->hwirq, root_irq_data);
+ */
 static void irq_domain_set_mapping(struct irq_domain *domain,
 				   irq_hw_number_t hwirq,
 				   struct irq_data *irq_data)
@@ -1085,6 +1191,12 @@ const struct irq_domain_ops irq_domain_simple_ops = {
 };
 EXPORT_SYMBOL_GPL(irq_domain_simple_ops);
 
+/*
+ * called by:
+ *   - kernel/irq/ipi.c|79| <<irq_reserve_ipi>> virq = irq_domain_alloc_descs(-1, nr_irqs, 0, NUMA_NO_NODE, NULL);
+ *   - kernel/irq/irqdomain.c|765| <<irq_create_mapping>> virq = irq_domain_alloc_descs(-1, 1, hwirq, of_node_to_nid(of_node), NULL);
+ *   - kernel/irq/irqdomain.c|1567| <<__irq_domain_alloc_irqs>> virq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,
+ */
 int irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,
 			   int node, const struct cpumask *affinity)
 {
@@ -1146,6 +1258,10 @@ struct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,
 }
 EXPORT_SYMBOL_GPL(irq_domain_create_hierarchy);
 
+/*
+ * called by:
+ *   - kernel/irq/irqdomain.c|1523| <<__irq_domain_alloc_irqs>> irq_domain_insert_irq(virq + i);
+ */
 static void irq_domain_insert_irq(int virq)
 {
 	struct irq_data *data;
@@ -1252,6 +1368,10 @@ struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,
 {
 	struct irq_data *irq_data;
 
+	/*
+	 * irq_get_irq_data()
+	 * 获得irq的struct irq_desc *desc, 返回desc->irq_data
+	 */
 	for (irq_data = irq_get_irq_data(virq); irq_data;
 	     irq_data = irq_data->parent_data)
 		if (irq_data->domain == domain)
@@ -1367,10 +1487,32 @@ static void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,
 		domain->ops->free(domain, irq_base, nr_irqs);
 }
 
+/*
+ * called by:
+ *   - kernel/irq/irqdomain.c|1445| <<__irq_domain_alloc_irqs>> ret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);
+ *   - kernel/irq/irqdomain.c|1546| <<irq_domain_push_irq>> rv = irq_domain_alloc_irqs_hierarchy(domain, virq, 1, arg);
+ *   - kernel/irq/irqdomain.c|1672| <<irq_domain_alloc_irqs_parent>> return irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,
+ *   - kernel/irq/msi.c|318| <<msi_domain_populate_irqs>> ret = irq_domain_alloc_irqs_hierarchy(domain, desc->irq, 1,
+ */
 int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,
 				    unsigned int irq_base,
 				    unsigned int nr_irqs, void *arg)
 {
+	/*
+	 * kernel/irq/msi.c
+	 * 166 static const struct irq_domain_ops msi_domain_ops = {
+	 * 167         .alloc          = msi_domain_alloc,
+	 * 168         .free           = msi_domain_free,
+	 * 169         .activate       = msi_domain_activate,
+	 * 170         .deactivate     = msi_domain_deactivate,
+	 * 171 };
+	 *
+	 * arch/x86/kernel/apic/vector.c
+	 * 504 static const struct irq_domain_ops x86_vector_domain_ops = {
+	 * 505         .alloc  = x86_vector_alloc_irqs,
+	 * 506         .free   = x86_vector_free_irqs,
+	 * 507 };
+	 */
 	return domain->ops->alloc(domain, irq_base, nr_irqs, arg);
 }
 
@@ -1396,6 +1538,14 @@ int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,
  * resources. In this way, it's easier to rollback when failing to
  * allocate resources.
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/io_apic.c|1079| <<alloc_irq_from_domain>> return __irq_domain_alloc_irqs(domain, irq, 1,
+ *   - arch/x86/kernel/apic/io_apic.c|1114| <<alloc_isa_irq_from_domain>> irq = __irq_domain_alloc_irqs(domain, irq, 1, node, info, true,
+ *   - include/linux/irqdomain.h|469| <<irq_domain_alloc_irqs>> return __irq_domain_alloc_irqs(domain, -1, nr_irqs, node, arg, false,
+ *   - kernel/irq/ipi.c|85| <<irq_reserve_ipi>> virq = __irq_domain_alloc_irqs(domain, virq, nr_irqs, NUMA_NO_NODE,
+ *   - kernel/irq/msi.c|376| <<msi_domain_alloc_irqs>> virq = __irq_domain_alloc_irqs(domain, -1, desc->nvec_used,
+ */
 int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
 			    unsigned int nr_irqs, int node, void *arg,
 			    bool realloc, const struct cpumask *affinity)
@@ -1416,6 +1566,10 @@ int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,
 	if (realloc && irq_base >= 0) {
 		virq = irq_base;
 	} else {
+		/*
+		 * 从kernel/irq/msi.c的msi_domain_alloc_irqs()进来的时候irq_base=-1,
+		 * 所以这里要分配irq
+		 */
 		virq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,
 					      affinity);
 		if (virq < 0) {
@@ -1652,6 +1806,20 @@ void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)
  * Check whether the domain has been setup recursive. If not allocate
  * through the parent domain.
  */
+/*
+ * [0] irq_domain_alloc_irqs_parent
+ * [0] msi_domain_alloc
+ * [0] __irq_domain_alloc_irqs
+ * [0] msi_domain_alloc_irqs
+ * [0] native_setup_msi_irqs
+ * [0] __pci_enable_msix_range
+ * [0] pci_alloc_irq_vectors_affinity
+ * [0] nvme_reset_work
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ */
 int irq_domain_alloc_irqs_parent(struct irq_domain *domain,
 				 unsigned int irq_base, unsigned int nr_irqs,
 				 void *arg)
@@ -1659,6 +1827,12 @@ int irq_domain_alloc_irqs_parent(struct irq_domain *domain,
 	if (!domain->parent)
 		return -ENOSYS;
 
+	/*
+	 * 对于nvme, 这里name=PCI-MSI-2, irq_base=25, nr_irqs=1
+	 *
+	 * 然后parent, name=VECTOR, virq=25, nr_irq=1
+	 */
+
 	return irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,
 					       nr_irqs, arg);
 }
@@ -1689,6 +1863,11 @@ static void __irq_domain_activate_irq(struct irq_data *irq_data)
 
 		if (irq_data->parent_data)
 			__irq_domain_activate_irq(irq_data->parent_data);
+		/*
+		 * 设置的部分地方:
+		 *   - arch/x86/kernel/apic/io_apic.c|3227| <<global>> .activate = mp_irqdomain_activate,
+		 *   - drivers/iommu/intel_irq_remapping.c|1414| <<global>> .activate = intel_irq_remapping_activate,
+		 */
 		if (domain->ops->activate)
 			domain->ops->activate(domain, irq_data);
 	}
@@ -1767,6 +1946,10 @@ bool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)
 struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,
 					 unsigned int virq)
 {
+	/*
+	 * irq_get_irq_data()
+	 * 获得irq的struct irq_desc *desc, 返回desc->irq_data
+	 */
 	struct irq_data *irq_data = irq_get_irq_data(virq);
 
 	return (irq_data && irq_data->domain == domain) ? irq_data : NULL;
diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c
index 6c877d2..f5f41d7 100644
--- a/kernel/irq/manage.c
+++ b/kernel/irq/manage.c
@@ -191,6 +191,10 @@ int irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,
 	if (!chip || !chip->irq_set_affinity)
 		return -EINVAL;
 
+	/*
+	 * 在开了iommu和irq remap的时候chip是IR-PCI-MSI (pci_msi_ir_controller)
+	 * 在msi_domain_update_chip_ops()中设置chip->irq_set_affinity = msi_domain_set_affinity
+	 */
 	ret = chip->irq_set_affinity(data, mask, force);
 	switch (ret) {
 	case IRQ_SET_MASK_OK:
@@ -1142,6 +1146,13 @@ setup_irq_thread(struct irqaction *new, unsigned int irq, bool secondary)
  * interrupt related functions. desc->request_mutex solely serializes
  * request/free_irq().
  */
+/*
+ * called by:
+ *   - kernel/irq/manage.c|1508| <<setup_irq>> retval = __setup_irq(irq, desc, act);
+ *   - kernel/irq/manage.c|1795| <<request_threaded_irq>> retval = __setup_irq(irq, desc, action);
+ *   - kernel/irq/manage.c|2043| <<setup_percpu_irq>> retval = __setup_irq(irq, desc, act);
+ *   - kernel/irq/manage.c|2102| <<__request_percpu_irq>> retval = __setup_irq(irq, desc, action);
+ */
 static int
 __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)
 {
diff --git a/kernel/irq/msi.c b/kernel/irq/msi.c
index 3fa4bd5..e258261 100644
--- a/kernel/irq/msi.c
+++ b/kernel/irq/msi.c
@@ -84,6 +84,12 @@ static inline void irq_chip_write_msi_msg(struct irq_data *data,
  * Intended to be used by MSI interrupt controllers which are
  * implemented with hierarchical domains.
  */
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/msi.c|350| <<global>> .irq_set_affinity = msi_domain_set_affinity,
+ *   - arch/x86/kernel/apic/msi.c|447| <<global>> .irq_set_affinity = msi_domain_set_affinity,
+ *   - kernel/irq/msi.c|291| <<msi_domain_update_chip_ops>> chip->irq_set_affinity = msi_domain_set_affinity;
+ */
 int msi_domain_set_affinity(struct irq_data *irq_data,
 			    const struct cpumask *mask, bool force)
 {
@@ -100,6 +106,9 @@ int msi_domain_set_affinity(struct irq_data *irq_data,
 	return ret;
 }
 
+/*
+ * struct irq_domain_ops msi_domain_ops.activate = msi_domain_activate()
+ */
 static void msi_domain_activate(struct irq_domain *domain,
 				struct irq_data *irq_data)
 {
@@ -109,6 +118,9 @@ static void msi_domain_activate(struct irq_domain *domain,
 	irq_chip_write_msi_msg(irq_data, &msg);
 }
 
+/*
+ * struct irq_domain_ops msi_domain_ops.deactivate = msi_domain_deactivate()
+ */
 static void msi_domain_deactivate(struct irq_domain *domain,
 				  struct irq_data *irq_data)
 {
@@ -118,6 +130,9 @@ static void msi_domain_deactivate(struct irq_domain *domain,
 	irq_chip_write_msi_msg(irq_data, &msg);
 }
 
+/*
+ * struct irq_domain_ops msi_domain_ops.alloc = msi_domain_alloc()
+ */
 static int msi_domain_alloc(struct irq_domain *domain, unsigned int virq,
 			    unsigned int nr_irqs, void *arg)
 {
@@ -136,6 +151,14 @@ static int msi_domain_alloc(struct irq_domain *domain, unsigned int virq,
 	}
 
 	for (i = 0; i < nr_irqs; i++) {
+		/*
+		 * info的例子是pci_msi_domain_info
+		 *
+		 * 这里的ops是struct msi_domain_ops
+		 *
+		 * 一个例子就是msi_domain_ops_default?
+		 * msi_domain_ops_init()
+		 */
 		ret = ops->msi_init(domain, info, virq + i, hwirq + i, arg);
 		if (ret < 0) {
 			if (ops->msi_free) {
@@ -150,6 +173,9 @@ static int msi_domain_alloc(struct irq_domain *domain, unsigned int virq,
 	return 0;
 }
 
+/*
+ * struct irq_domain_ops msi_domain_ops.free = msi_domain_free()
+ */
 static void msi_domain_free(struct irq_domain *domain, unsigned int virq,
 			    unsigned int nr_irqs)
 {
@@ -200,6 +226,9 @@ static int msi_domain_ops_init(struct irq_domain *domain,
 			       unsigned int virq, irq_hw_number_t hwirq,
 			       msi_alloc_info_t *arg)
 {
+	/*
+	 * info的例子是pci_msi_domain_info
+	 */
 	irq_domain_set_hwirq_and_chip(domain, virq, hwirq, info->chip,
 				      info->chip_data);
 	if (info->handler && info->handler_name) {
@@ -217,6 +246,15 @@ static int msi_domain_ops_check(struct irq_domain *domain,
 	return 0;
 }
 
+/*
+ * used by:
+ *   - kernel/irq/msi.c|250| <<msi_domain_update_dom_ops>> info->ops = &msi_domain_ops_default;
+ *   - kernel/irq/msi.c|255| <<msi_domain_update_dom_ops>> ops->get_hwirq = msi_domain_ops_default.get_hwirq;
+ *   - kernel/irq/msi.c|257| <<msi_domain_update_dom_ops>> ops->msi_init = msi_domain_ops_default.msi_init;
+ *   - kernel/irq/msi.c|259| <<msi_domain_update_dom_ops>> ops->msi_check = msi_domain_ops_default.msi_check;
+ *   - kernel/irq/msi.c|261| <<msi_domain_update_dom_ops>> ops->msi_prepare = msi_domain_ops_default.msi_prepare;
+ *   - kernel/irq/msi.c|263| <<msi_domain_update_dom_ops>> ops->set_desc = msi_domain_ops_default.set_desc;
+ */
 static struct msi_domain_ops msi_domain_ops_default = {
 	.get_hwirq	= msi_domain_ops_get_hwirq,
 	.msi_init	= msi_domain_ops_init,
@@ -225,6 +263,10 @@ static struct msi_domain_ops msi_domain_ops_default = {
 	.set_desc	= msi_domain_ops_set_desc,
 };
 
+/*
+ * called by:
+ *   - kernel/irq/msi.c|288| <<msi_create_irq_domain>> msi_domain_update_dom_ops(info);
+ */
 static void msi_domain_update_dom_ops(struct msi_domain_info *info)
 {
 	struct msi_domain_ops *ops = info->ops;
@@ -345,9 +387,57 @@ int msi_domain_populate_irqs(struct irq_domain *domain, struct device *dev,
  *
  * Returns 0 on success or an error code.
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/msi.c|95| <<native_setup_msi_irqs>> return msi_domain_alloc_irqs(domain, &dev->dev, nvec);
+ *   - drivers/base/platform-msi.c|273| <<platform_msi_domain_alloc_irqs>> err = msi_domain_alloc_irqs(dev->msi_domain, dev, nvec);
+ *   - drivers/pci/msi.c|41| <<pci_msi_setup_msi_irqs>> return msi_domain_alloc_irqs(domain, &dev->dev, nvec);
+ *
+ * 会使用irq_set_msi_desc_off()修改struct msi_desc的irq!!!
+ */
 int msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,
 			  int nvec)
 {
+	/*
+	 * msi的struct irq_domain_ops的例子
+	 *
+	 * kernel/irq/msi.c
+	 *
+	 * 166 static const struct irq_domain_ops msi_domain_ops = {
+	 * 167         .alloc          = msi_domain_alloc,
+	 * 168         .free           = msi_domain_free,
+	 * 169         .activate       = msi_domain_activate,
+	 * 170         .deactivate     = msi_domain_deactivate,
+	 * 171 };
+	 *
+	 *
+	 * info的例子:
+	 * struct msi_domain_info pci_msi_domain_info
+	 *
+	 * 148 static struct msi_domain_info pci_msi_domain_info = {
+	 * 149         .flags          = MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
+	 * 150                           MSI_FLAG_PCI_MSIX,
+	 * 151         .ops            = &pci_msi_domain_ops,
+	 * 152         .chip           = &pci_msi_controller,
+	 * 153         .handler        = handle_edge_irq,
+	 * 154         .handler_name   = "edge",
+	 * 155 };
+	 *
+	 *
+	 * struct msi_domain_ops的例子:
+	 *
+	 * 138 static struct msi_domain_ops pci_msi_domain_ops = {
+	 * 139         .get_hwirq      = pci_msi_get_hwirq,
+	 * 140         .msi_prepare    = pci_msi_prepare,
+	 * 141         .set_desc       = pci_msi_set_desc,
+	 * 142 };
+	 *
+	 * 1390 static struct msi_domain_ops pci_msi_domain_ops_default = {
+	 * 1391         .set_desc       = pci_msi_domain_set_desc,
+	 * 1392         .msi_check      = pci_msi_domain_check_cap,
+	 * 1393         .handle_error   = pci_msi_domain_handle_error,
+	 * 1394 };
+	 */
 	struct msi_domain_info *info = domain->host_data;
 	struct msi_domain_ops *ops = info->ops;
 	msi_alloc_info_t arg;
@@ -358,9 +448,20 @@ int msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,
 	if (ret)
 		return ret;
 
+	/*
+	 * 对于nvme的io queues, desc们之前在msix_setup_entries()插入的
+	 */
 	for_each_msi_entry(desc, dev) {
+		/*
+		 * ops是struct msi_domain_ops
+		 *
+		 * 参数arg是上面堆栈申请的msi_alloc_info_t arg
+		 */
 		ops->set_desc(&arg, desc);
 
+		/*
+		 * 对于nvme的io queues, 这里的virq是'cat /proc/interrupts'的irq
+		 */
 		virq = __irq_domain_alloc_irqs(domain, -1, desc->nvec_used,
 					       dev_to_node(dev), &arg, false,
 					       desc->affinity);
@@ -373,6 +474,11 @@ int msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,
 			return ret;
 		}
 
+		/*
+		 * 这个函数会修改desc->irq_common_data.msi_desc = entry
+		 *
+		 * 主要是会修改entry->irq = irq_base!!!!
+		 */
 		for (i = 0; i < desc->nvec_used; i++)
 			irq_set_msi_desc_off(virq, i, desc);
 	}
diff --git a/kernel/irq/proc.c b/kernel/irq/proc.c
index c010cc0..5e4fe85 100644
--- a/kernel/irq/proc.c
+++ b/kernel/irq/proc.c
@@ -18,6 +18,18 @@
 #include "internals.h"
 
 /*
+ * # ls /proc/irq/28/
+ * affinity_hint
+ * effective_affinity
+ * effective_affinity_list
+ * node
+ * nvme0q3
+ * smp_affinity
+ * smp_affinity_list
+ * spurious
+ */
+
+/*
  * Access rules:
  *
  * procfs protects read/write of /proc/irq/N/ files against a
@@ -45,8 +57,20 @@ enum {
 	EFFECTIVE_LIST,
 };
 
+/*
+ * called by:
+ *   - kernel/irq/proc.c|112| <<irq_affinity_proc_show>> return show_irq_affinity(AFFINITY, m);
+ *   - kernel/irq/proc.c|117| <<irq_affinity_list_proc_show>> return show_irq_affinity(AFFINITY_LIST, m);
+ *   - kernel/irq/proc.c|220| <<irq_effective_aff_proc_show>> return show_irq_affinity(EFFECTIVE, m);
+ *   - kernel/irq/proc.c|225| <<irq_effective_aff_list_proc_show>> return show_irq_affinity(EFFECTIVE_LIST, m);
+ */
 static int show_irq_affinity(int type, struct seq_file *m)
 {
+	/*
+	 * struct irq_desc
+	 *     struct irq_common_data  irq_common_data;
+	 *     struct irq_data         irq_data;
+	 */
 	struct irq_desc *desc = irq_to_desc((long)m->private);
 	const struct cpumask *mask;
 
diff --git a/kernel/irq_work.c b/kernel/irq_work.c
index bcf107c..627f328 100644
--- a/kernel/irq_work.c
+++ b/kernel/irq_work.c
@@ -166,6 +166,12 @@ static void irq_work_run_list(struct llist_head *list)
  * hotplug calls this through:
  *  hotplug_cfd() -> flush_smp_call_function_queue()
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/irq_work.c|21| <<smp_irq_work_interrupt>> irq_work_run();
+ *   - arch/x86/xen/smp_pv.c|476| <<xen_irq_work_interrupt>> irq_work_run();
+ *   - kernel/smp.c|257| <<flush_smp_call_function_queue>> irq_work_run();
+ */
 void irq_work_run(void)
 {
 	irq_work_run_list(this_cpu_ptr(&raised_list));
diff --git a/kernel/kexec_core.c b/kernel/kexec_core.c
index 20fef1a..82bf1f1 100644
--- a/kernel/kexec_core.c
+++ b/kernel/kexec_core.c
@@ -924,6 +924,12 @@ int kexec_load_disabled;
  * only when panic_cpu holds the current CPU number; this is the only CPU
  * which processes crash_kexec routines.
  */
+/*
+ * called by:
+ *   - kernel/kexec_core.c|965| <<crash_kexec>> __crash_kexec(regs);
+ *   - kernel/panic.c|195| <<panic>> __crash_kexec(NULL);
+ *   - kernel/panic.c|232| <<panic>> __crash_kexec(NULL);
+ */
 void __noclone __crash_kexec(struct pt_regs *regs)
 {
 	/* Take the kexec_mutex here to prevent sys_kexec_load
@@ -948,6 +954,11 @@ void __noclone __crash_kexec(struct pt_regs *regs)
 }
 STACK_FRAME_NON_STANDARD(__crash_kexec);
 
+/*
+ * x86下的调用:
+ *   - arch/x86/kernel/dumpstack.c|279| <<oops_end>> crash_kexec(regs);
+ *   - arch/x86/platform/uv/uv_nmi.c|816| <<uv_nmi_kdump>> crash_kexec(regs);
+ */
 void crash_kexec(struct pt_regs *regs)
 {
 	int old_cpu, this_cpu;
@@ -958,6 +969,16 @@ void crash_kexec(struct pt_regs *regs)
 	 * may stop each other.  To exclude them, we use panic_cpu here too.
 	 */
 	this_cpu = raw_smp_processor_id();
+	/*
+	 * panic_cpu在以下被使用:
+	 *   - kernel/kexec_core.c|972| <<crash_kexec>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+	 *   - kernel/kexec_core.c|982| <<crash_kexec>> atomic_set(&panic_cpu, PANIC_CPU_INVALID);
+	 *   - kernel/panic.c|116| <<nmi_panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, cpu);
+	 *   - kernel/panic.c|166| <<panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+	 *
+	 * cmpxchg(ptr, old, new)
+	 * 将old和ptr指向的内容比较,如果相等,则将new写入到ptr中,返回old,如果不相等,则返回ptr指向的内容.
+	 */
 	old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
 	if (old_cpu == PANIC_CPU_INVALID) {
 		/* This is the 1st CPU which comes here, so go ahead. */
diff --git a/kernel/panic.c b/kernel/panic.c
index 32ff6fd..63b042d 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -100,6 +100,13 @@ void __weak crash_smp_send_stop(void)
 	cpus_stopped = 1;
 }
 
+/*
+ * used by:
+ *   - kernel/kexec_core.c|972| <<crash_kexec>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+ *   - kernel/kexec_core.c|982| <<crash_kexec>> atomic_set(&panic_cpu, PANIC_CPU_INVALID);
+ *   - kernel/panic.c|116| <<nmi_panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, cpu);
+ *   - kernel/panic.c|166| <<panic>> old_cpu = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);
+ */
 atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);
 
 /*
diff --git a/kernel/smpboot.c b/kernel/smpboot.c
index 5043e74..db70bf9 100644
--- a/kernel/smpboot.c
+++ b/kernel/smpboot.c
@@ -157,6 +157,7 @@ static int smpboot_thread_fn(void *data)
 
 		if (!ht->thread_should_run(td->cpu)) {
 			preempt_enable_no_resched();
+			/* 平时应该hang在这里吧 */
 			schedule();
 		} else {
 			__set_current_state(TASK_RUNNING);
diff --git a/kernel/time/tick-common.c b/kernel/time/tick-common.c
index 49edc1c..3ac3df4 100644
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@ -174,6 +174,11 @@ void tick_setup_periodic(struct clock_event_device *dev, int broadcast)
 /*
  * Setup the tick device
  */
+/*
+ * called by:
+ *   - kernel/time/tick-common.c|242| <<tick_install_replacement>> tick_setup_device(td, newdev, cpu, cpumask_of(cpu));
+ *   - kernel/time/tick-common.c|331| <<tick_check_new_device>> tick_setup_device(td, newdev, cpu, cpumask_of(cpu));
+ */
 static void tick_setup_device(struct tick_device *td,
 			      struct clock_event_device *newdev, int cpu,
 			      const struct cpumask *cpumask)
diff --git a/kernel/time/tick-oneshot.c b/kernel/time/tick-oneshot.c
index 6b009c2..252dca2 100644
--- a/kernel/time/tick-oneshot.c
+++ b/kernel/time/tick-oneshot.c
@@ -61,6 +61,10 @@ void tick_resume_oneshot(void)
 /**
  * tick_setup_oneshot - setup the event device for oneshot mode (hres or nohz)
  */
+/*
+ * called by only:
+ *   - kernel/time/tick-common.c|233| <<tick_setup_device>> tick_setup_oneshot(newdev, handler, next_event);
+ */
 void tick_setup_oneshot(struct clock_event_device *newdev,
 			void (*handler)(struct clock_event_device *),
 			ktime_t next_event)
@@ -73,6 +77,11 @@ void tick_setup_oneshot(struct clock_event_device *newdev,
 /**
  * tick_switch_to_oneshot - switch to oneshot mode
  */
+/*
+ * called by:
+ *   - kernel/time/tick-oneshot.c|130| <<tick_init_highres>> return tick_switch_to_oneshot(hrtimer_interrupt);
+ *   - kernel/time/tick-sched.c|1149| <<tick_nohz_switch_to_nohz>> if (tick_switch_to_oneshot(tick_nohz_handler))
+ */
 int tick_switch_to_oneshot(void (*handler)(struct clock_event_device *))
 {
 	struct tick_device *td = this_cpu_ptr(&tick_cpu_device);
-- 
2.7.4

