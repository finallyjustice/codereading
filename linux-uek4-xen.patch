From 898f75beba56ecd95398905596656c72cdec765d Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Fri, 4 Dec 2020 09:38:17 -0800
Subject: [PATCH 1/1] linux uek4 xen

v4.1.12-124.26.12

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/xen/spinlock.c           |  25 +++
 drivers/xen/xenbus/xenbus.h       |  24 +++
 drivers/xen/xenbus/xenbus_comms.c | 185 +++++++++++++++++++++
 drivers/xen/xenbus/xenbus_xs.c    | 261 ++++++++++++++++++++++++++++++
 4 files changed, 495 insertions(+)

diff --git a/arch/x86/xen/spinlock.c b/arch/x86/xen/spinlock.c
index 956374c1edbc..c36ec8b9fee8 100644
--- a/arch/x86/xen/spinlock.c
+++ b/arch/x86/xen/spinlock.c
@@ -100,8 +100,22 @@ struct xen_lock_waiting {
 	__ticket_t want;
 };
 
+/*
+ * 在以下使用lock_kicker_irq:
+ *   - arch/x86/xen/spinlock.c|111| <<xen_lock_spinning>> int irq = __this_cpu_read(lock_kicker_irq);
+ *   - arch/x86/xen/spinlock.c|235| <<xen_init_lock_cpu>> WARN(per_cpu(lock_kicker_irq, cpu) >= 0, "spinlock on CPU%d exists on IRQ%d!\n",
+ *   - arch/x86/xen/spinlock.c|236| <<xen_init_lock_cpu>> cpu, per_cpu(lock_kicker_irq, cpu));
+ *   - arch/x86/xen/spinlock.c|248| <<xen_init_lock_cpu>> per_cpu(lock_kicker_irq, cpu) = irq;
+ *   - arch/x86/xen/spinlock.c|260| <<xen_uninit_lock_cpu>> unbind_from_irqhandler(per_cpu(lock_kicker_irq, cpu), NULL);
+ *   - arch/x86/xen/spinlock.c|261| <<xen_uninit_lock_cpu>> per_cpu(lock_kicker_irq, cpu) = -1;
+ */
 static DEFINE_PER_CPU(int, lock_kicker_irq) = -1;
 static DEFINE_PER_CPU(char *, irq_name);
+/*
+ * 在以下使用xen_lock_waiting:
+ *   - arch/x86/xen/spinlock.c|125| <<xen_lock_spinning>> struct xen_lock_waiting *w = this_cpu_ptr(&lock_waiting);
+ *   - arch/x86/xen/spinlock.c|222| <<xen_unlock_kick>> const struct xen_lock_waiting *w = &per_cpu(lock_waiting, cpu);
+ */
 static DEFINE_PER_CPU(struct xen_lock_waiting, lock_waiting);
 static cpumask_t waiting_cpus;
 
@@ -224,6 +238,13 @@ static irqreturn_t dummy_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+/*
+ * called by:
+ *   - arch/x86/xen/smp.c|349| <<xen_smp_prepare_cpus>> xen_init_lock_cpu(0);
+ *   - arch/x86/xen/smp.c|459| <<xen_cpu_up>> xen_init_lock_cpu(cpu); 
+ *   - arch/x86/xen/smp.c|749| <<xen_hvm_smp_prepare_cpus>> xen_init_lock_cpu(0);
+ *   - arch/x86/xen/smp.c|784| <<xen_hvm_cpu_up>> xen_init_lock_cpu(cpu);
+ */
 void xen_init_lock_cpu(int cpu)
 {
 	int irq;
@@ -272,6 +293,10 @@ void xen_uninit_lock_cpu(int cpu)
  * The paravirt patching needs to be done _before_ the alternative asm code
  * is started, otherwise we would not patch the core kernel code.
  */
+/*
+ * called by:
+ *   - arch/x86/xen/smp.c|332| <<xen_smp_prepare_boot_cpu>> xen_init_spinlocks();
+ */
 void __init xen_init_spinlocks(void)
 {
 
diff --git a/drivers/xen/xenbus/xenbus.h b/drivers/xen/xenbus/xenbus.h
index 092981171df1..292029c54225 100644
--- a/drivers/xen/xenbus/xenbus.h
+++ b/drivers/xen/xenbus/xenbus.h
@@ -66,9 +66,33 @@ struct xs_watch_event {
 };
 
 enum xb_req_state {
+	/*
+	 * 在以下使用xb_req_state_queued:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|290| <<xs_send>> req->state = xb_req_state_queued;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|332| <<xs_wait_for_reply>> if (req->state == xb_req_state_queued ||
+	 */
 	xb_req_state_queued,
+	/*
+	 * 在以下使用xb_req_state_wait_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|458| <<process_writes>> state.req->state = xb_req_state_wait_reply;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|357| <<process_msg>> if (req->state == xb_req_state_wait_reply) {
+	 *   - drivers/xen/xenbus/xenbus_xs.c|333| <<xs_wait_for_reply>> req->state == xb_req_state_wait_reply)
+	 */
 	xb_req_state_wait_reply,
+	/*
+	 * 在以下使用xb_req_state_got_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|362| <<process_msg>> req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|480| <<process_writes>> state.req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|220| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok())
+	 *   - drivers/xen/xenbus/xenbus_xs.c|231| <<read_reply>> while (req->state != xb_req_state_got_reply) {
+	 */
 	xb_req_state_got_reply,
+	/*
+	 * 在以下使用xb_req_state_aborted:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|334| <<xs_wait_for_reply>> req->state = xb_req_state_aborted;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|432| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 *   - drivers/xen/xenbus/xenbus_comms.c|477| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 */
 	xb_req_state_aborted
 };
 
diff --git a/drivers/xen/xenbus/xenbus_comms.c b/drivers/xen/xenbus/xenbus_comms.c
index babc9592b78a..b4cac354acc8 100644
--- a/drivers/xen/xenbus/xenbus_comms.c
+++ b/drivers/xen/xenbus/xenbus_comms.c
@@ -44,11 +44,39 @@
 #include "xenbus.h"
 
 /* A list of replies. Currently only one will ever be outstanding. */
+/*
+ * 使用xs_reply_list的地方:
+ *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+ *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+ */
 LIST_HEAD(xs_reply_list);
 
 /* A list of write requests. */
+/*
+ * 使用xb_write_list的地方:
+ *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+ *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+ */
 LIST_HEAD(xb_write_list);
 DECLARE_WAIT_QUEUE_HEAD(xb_waitq);
+/*
+ * 使用xb_write_mutex的地方:
+ *   - drivers/xen/xenbus/xenbus_comms.c|374| <<process_msg>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|413| <<process_msg>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|450| <<process_writes>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|506| <<process_writes>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|521| <<process_writes>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|297| <<xs_send>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|308| <<xs_send>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|331| <<xs_wait_for_reply>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|337| <<xs_wait_for_reply>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|1093| <<xs_reboot_notify>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|1112| <<xs_reboot_notify>> mutex_unlock(&xb_write_mutex);
+ */
 DEFINE_MUTEX(xb_write_mutex);
 
 /* Protect xenbus reader thread against save/restore. */
@@ -93,6 +121,7 @@ static const void *get_input_chunk(XENSTORE_RING_IDX cons,
 	*len = XENSTORE_RING_SIZE - MASK_XENSTORE_IDX(cons);
 	if ((prod - cons) < *len)
 		*len = prod - cons;
+	/* #define MASK_XENSTORE_IDX(idx) ((idx) & (XENSTORE_RING_SIZE-1)) */
 	return buf + MASK_XENSTORE_IDX(cons);
 }
 
@@ -111,6 +140,10 @@ static int xb_data_to_write(void)
  *
  * Returns number of bytes written or -err.
  */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|413| <<process_writes>> err = xb_write(base + state.written, len - state.written);
+ */
 static int xb_write(const void *data, unsigned int len)
 {
 	struct xenstore_domain_interface *intf = xen_store_interface;
@@ -163,8 +196,25 @@ static int xb_data_to_read(void)
 	return (intf->rsp_cons != intf->rsp_prod);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|285| <<process_msg>> err = xb_read((void *)&state.msg + state.read,
+ *   - drivers/xen/xenbus/xenbus_comms.c|314| <<process_msg>> err = xb_read(state.body + state.read, state.msg.len - state.read);
+ */
 static int xb_read(void *data, unsigned int len)
 {
+	/*
+	 * // Inter-domain shared memory communications.
+	 * #define XENSTORE_RING_SIZE 1024
+	 * typedef uint32_t XENSTORE_RING_IDX;
+	 * #define MASK_XENSTORE_IDX(idx) ((idx) & (XENSTORE_RING_SIZE-1))
+	 * struct xenstore_domain_interface {
+	 *	char req[XENSTORE_RING_SIZE]; // Requests to xenstore daemon.
+	 *	char rsp[XENSTORE_RING_SIZE]; // Replies and async watch events.
+	 *	XENSTORE_RING_IDX req_cons, req_prod;
+	 *	XENSTORE_RING_IDX rsp_cons, rsp_prod;
+	 * };
+	 */
 	struct xenstore_domain_interface *intf = xen_store_interface;
 	XENSTORE_RING_IDX cons, prod;
 	unsigned int bytes = 0;
@@ -193,6 +243,9 @@ static int xb_read(void *data, unsigned int len)
 		/* Must read data /after/ reading the producer index. */
 		rmb();
 
+		/*
+		 * data是要返回的read的地址
+		 */
 		memcpy(data, src, avail);
 		data += avail;
 		len -= avail;
@@ -210,13 +263,38 @@ static int xb_read(void *data, unsigned int len)
 	return bytes;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|494| <<xenbus_thread>> err = process_msg();
+ */
 static int process_msg(void)
 {
 	static struct {
+		/*
+		 * struct xsd_sockmsg
+		 * {
+		 *	uint32_t type;  // XS_???
+		 *	uint32_t req_id;// Request identifier, echoed in daemon's response.
+		 *	uint32_t tx_id; // Transaction id (0 if not related to a transaction).
+		 *	uint32_t len;   // Length of data following this.
+		 *
+		 *	// Generally followed by nul-terminated string(s).
+		 * };
+		 */
 		struct xsd_sockmsg msg;
 		char *body;
 		union {
 			void *alloc;
+			/*
+			 * struct xs_watch_event {
+			 *	struct list_head list;
+			 *	unsigned int len;
+			 *	struct xenbus_watch *handle;
+			 *	const char *path;
+			 *	const char *token;
+			 *	char body[];
+			 * };
+			 */
 			struct xs_watch_event *watch;
 		};
 		bool in_msg;
@@ -242,6 +320,9 @@ static int process_msg(void)
 		 */
 		mutex_lock(&xs_response_mutex);
 
+		/*
+		 * 判断xenstore_domain_interface->rsp_cons是不是和xenstore_domain_interface->rsp_prod不一样
+		 */
 		if (!xb_data_to_read()) {
 			/* We raced with save/restore: pending data 'gone'. */
 			mutex_unlock(&xs_response_mutex);
@@ -269,10 +350,18 @@ static int process_msg(void)
 		if (state.msg.type == XS_WATCH_EVENT)
 			len += sizeof(*state.watch);
 
+		/*
+		 * 这里是唯一分配alloc的地方!!!
+		 */
 		state.alloc = kmalloc(len, GFP_NOIO | __GFP_HIGH);
 		if (!state.alloc)
 			return -ENOMEM;
 
+		/*
+		 * 以下的两个是一个union中的:
+		 *   * void *alloc;
+		 *   - struct xs_watch_event *watch;
+		 */
 		if (state.msg.type == XS_WATCH_EVENT)
 			state.body = state.watch->body;
 		else
@@ -297,15 +386,45 @@ static int process_msg(void)
 	} else {
 		err = -ENOENT;
 		mutex_lock(&xb_write_mutex);
+		/*
+		 * 使用xs_reply_list的地方:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+		 *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+		 *
+		 * req是struct xb_req_data *req;
+		 */
 		list_for_each_entry(req, &xs_reply_list, list) {
+			/*
+			 * 只要找到一个匹配的就立刻break
+			 */
 			if (req->msg.req_id == state.msg.req_id) {
+				/*
+				 * 在以下使用xb_req_state_wait_reply:
+				 *   - drivers/xen/xenbus/xenbus_comms.c|458| <<process_writes>> state.req->state = xb_req_state_wait_reply;
+				 *   - drivers/xen/xenbus/xenbus_comms.c|357| <<process_msg>> if (req->state == xb_req_state_wait_reply) {
+				 *   - drivers/xen/xenbus/xenbus_xs.c|333| <<xs_wait_for_reply>> req->state == xb_req_state_wait_reply)
+				 */
 				if (req->state == xb_req_state_wait_reply) {
 					req->msg.req_id = req->caller_req_id;
 					req->msg.type = state.msg.type;
 					req->msg.len = state.msg.len;
 					req->body = state.body;
+					/*
+					 * 在以下使用xb_req_state_got_reply:
+					 *   - drivers/xen/xenbus/xenbus_comms.c|362| <<process_msg>> req->state = xb_req_state_got_reply;
+					 *   - drivers/xen/xenbus/xenbus_comms.c|480| <<process_writes>> state.req->state = xb_req_state_got_reply;
+					 *   - drivers/xen/xenbus/xenbus_xs.c|220| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok())
+					 *   - drivers/xen/xenbus/xenbus_xs.c|231| <<read_reply>> while (req->state != xb_req_state_got_reply) {
+					 */
 					req->state = xb_req_state_got_reply;
 					list_del(&req->list);
+					/*
+					 * 仅仅是一个例子xs_wake_up()
+					 *
+					 * 这是唯一调用cb的地方:
+					 *   - drivers/xen/xenbus/xenbus_comms.c|418| <<process_msg>> req->cb(req);
+					 */
 					req->cb(req);
 				} else {
 					list_del(&req->list);
@@ -334,9 +453,29 @@ static int process_msg(void)
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|430| <<xenbus_thread>> err = process_writes();
+ */
 static int process_writes(void)
 {
 	static struct {
+		/*
+		 * struct xb_req_data {
+		 *	struct list_head list;
+		 *	wait_queue_head_t wq;
+		 *	struct xsd_sockmsg msg;
+		 *	uint32_t caller_req_id;
+		 *	enum xsd_sockmsg_type type;
+		 *	char *body;
+		 *	const struct kvec *vec;
+		 *	int num_vecs;
+		 *	int err;
+		 *	enum xb_req_state state;
+		 *	void (*cb)(struct xb_req_data *);
+		 *	void *par;
+		 * };
+		 */
 		struct xb_req_data *req;
 		int idx;
 		unsigned int written;
@@ -348,9 +487,33 @@ static int process_writes(void)
 	if (!xb_data_to_write())
 		return 0;
 
+	/*
+	 * 使用xb_write_mutex的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|374| <<process_msg>> mutex_lock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|413| <<process_msg>> mutex_unlock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|450| <<process_writes>> mutex_lock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|506| <<process_writes>> mutex_unlock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|521| <<process_writes>> mutex_unlock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|297| <<xs_send>> mutex_lock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|308| <<xs_send>> mutex_unlock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|331| <<xs_wait_for_reply>> mutex_lock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|337| <<xs_wait_for_reply>> mutex_unlock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|1093| <<xs_reboot_notify>> mutex_lock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|1112| <<xs_reboot_notify>> mutex_unlock(&xb_write_mutex);
+	 */
 	mutex_lock(&xb_write_mutex);
 
 	if (!state.req) {
+		/*
+		 * 使用xb_write_list的地方:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+		 *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+		 *
+		 * req的类型struct xb_req_data *req;
+		 */
 		state.req = list_first_entry(&xb_write_list,
 					     struct xb_req_data, list);
 		state.idx = -1;
@@ -368,6 +531,9 @@ static int process_writes(void)
 			base = state.req->vec[state.idx].iov_base;
 			len = state.req->vec[state.idx].iov_len;
 		}
+		/*
+		 * 参数base来自紧接上面的if语句
+		 */
 		err = xb_write(base + state.written, len - state.written);
 		if (err < 0)
 			goto out_err;
@@ -381,6 +547,12 @@ static int process_writes(void)
 
 	list_del(&state.req->list);
 	state.req->state = xb_req_state_wait_reply;
+	/*
+	 * 使用xs_reply_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+	 *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+	 */
 	list_add_tail(&state.req->list, &xs_reply_list);
 	state.req = NULL;
 
@@ -393,9 +565,22 @@ static int process_writes(void)
 	state.req->msg.type = XS_ERROR;
 	state.req->err = err;
 	list_del(&state.req->list);
+	/*
+	 * 在以下使用xb_req_state_aborted:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|334| <<xs_wait_for_reply>> req->state = xb_req_state_aborted;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|432| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 *   - drivers/xen/xenbus/xenbus_comms.c|477| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 */
 	if (state.req->state == xb_req_state_aborted)
 		kfree(state.req);
 	else {
+		/*
+		 * 在以下使用xb_req_state_got_reply:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|362| <<process_msg>> req->state = xb_req_state_got_reply;
+		 *   - drivers/xen/xenbus/xenbus_comms.c|480| <<process_writes>> state.req->state = xb_req_state_got_reply;
+		 *   - drivers/xen/xenbus/xenbus_xs.c|220| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok())
+		 *   - drivers/xen/xenbus/xenbus_xs.c|231| <<read_reply>> while (req->state != xb_req_state_got_reply) {
+		 */
 		state.req->state = xb_req_state_got_reply;
 		wake_up(&state.req->wq);
 	}
diff --git a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c
index b8657ef0a3c3..6f0a15d36c51 100644
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -64,6 +64,16 @@
 /* Lock protecting enter/exit critical region. */
 static DEFINE_SPINLOCK(xs_state_lock);
 /* Number of users in critical region (protected by xs_state_lock). */
+/*
+ * 在以下使用xs_state_users:
+ *   - drivers/xen/xenbus/xenbus_xs.c|108| <<xs_suspend_enter>> wait_event(xs_state_exit_wq, xs_state_users == 0);
+ *   - drivers/xen/xenbus/xenbus_xs.c|136| <<xs_request_enter>> while (!xs_state_users && xs_suspend_active) {
+ *   - drivers/xen/xenbus/xenbus_xs.c|143| <<xs_request_enter>> xs_state_users++;
+ *   - drivers/xen/xenbus/xenbus_xs.c|144| <<xs_request_enter>> xs_state_users++;
+ *   - drivers/xen/xenbus/xenbus_xs.c|160| <<xs_request_exit>> xs_state_users--;
+ *   - drivers/xen/xenbus/xenbus_xs.c|163| <<xs_request_exit>> xs_state_users--;
+ *   - drivers/xen/xenbus/xenbus_xs.c|166| <<xs_request_exit>> if (xs_suspend_active && !xs_state_users)
+ */
 static unsigned int xs_state_users;
 /* Suspend handler waiting or already active (protected by xs_state_lock)? */
 static int xs_suspend_active;
@@ -96,6 +106,10 @@ static pid_t xenwatch_pid;
 static DEFINE_MUTEX(xenwatch_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(watch_events_waitq);
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|862| <<xs_suspend>> xs_suspend_enter();
+ */
 static void xs_suspend_enter(void)
 {
 	spin_lock(&xs_state_lock);
@@ -104,6 +118,11 @@ static void xs_suspend_enter(void)
 	wait_event(xs_state_exit_wq, xs_state_users == 0);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|877| <<xs_resume>> xs_suspend_exit();
+ *   - drivers/xen/xenbus/xenbus_xs.c|893| <<xs_suspend_cancel>> xs_suspend_exit();
+ */
 static void xs_suspend_exit(void)
 {
 	spin_lock(&xs_state_lock);
@@ -112,6 +131,10 @@ static void xs_suspend_exit(void)
 	wake_up_all(&xs_state_enter_wq);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|233| <<xs_send>> req->msg.req_id = xs_request_enter(req);
+ */
 static uint32_t xs_request_enter(struct xb_req_data *req)
 {
 	uint32_t rq_id;
@@ -136,6 +159,11 @@ static uint32_t xs_request_enter(struct xb_req_data *req)
 	return rq_id;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_dev_frontend.c|355| <<xenbus_dev_queue_reply>> xs_request_exit(req);
+ *   - drivers/xen/xenbus/xenbus_xs.c|258| <<xs_wait_for_reply>> xs_request_exit(req);
+ */
 void xs_request_exit(struct xb_req_data *req)
 {
 	spin_lock(&xs_state_lock);
@@ -153,6 +181,24 @@ static int get_error(const char *errorstring)
 {
 	unsigned int i;
 
+	/*
+	 * static struct xsd_errors xsd_errors[] __attribute__((unused)) = {
+	 *	XSD_ERROR(EINVAL),
+	 *	XSD_ERROR(EACCES),
+	 *	XSD_ERROR(EEXIST),
+	 *	XSD_ERROR(EISDIR),
+	 *	XSD_ERROR(ENOENT),
+	 *	XSD_ERROR(ENOMEM),
+	 *	XSD_ERROR(ENOSPC),
+	 *	XSD_ERROR(EIO),
+	 *	XSD_ERROR(ENOTEMPTY),
+	 *	XSD_ERROR(ENOSYS),
+	 *	XSD_ERROR(EROFS),
+	 *	XSD_ERROR(EBUSY),
+	 *	XSD_ERROR(EAGAIN),
+	 *	XSD_ERROR(EISCONN)
+	 * };
+	 */
 	for (i = 0; strcmp(errorstring, xsd_errors[i].errstring) != 0; i++) {
 		if (i == ARRAY_SIZE(xsd_errors) - 1) {
 			pr_warn("xen store gave: unknown error %s\n",
@@ -198,9 +244,45 @@ static bool test_reply(struct xb_req_data *req)
 	return false;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|336| <<xs_wait_for_reply>> ret = read_reply(req);
+ */
 static void *read_reply(struct xb_req_data *req)
 {
+	/*
+	 * xenbus_thread的race:
+	 * 557  out_err:
+	 * 558         state.req->msg.type = XS_ERROR;
+	 * 559         state.req->err = err;
+	 * 560         list_del(&state.req->list);
+	 * 567         if (state.req->state == xb_req_state_aborted)
+	 * 568                 kfree(state.req);
+	 * 569         else {
+	 * 570                 state.req->state = xb_req_state_got_reply;
+	 * 571                 wake_up(&state.req->wq);
+	 * 572         }
+	 * 573
+	 * 574         mutex_unlock(&xb_write_mutex);
+	 * 575
+	 * 576         state.req = NULL;
+	 */
+	/*
+	 * 在以下使用xb_req_state_got_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|362| <<process_msg>> req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|480| <<process_writes>> state.req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|220| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok())
+	 *   - drivers/xen/xenbus/xenbus_xs.c|231| <<read_reply>> while (req->state != xb_req_state_got_reply) {
+	 */
 	while (req->state != xb_req_state_got_reply) {
+		/*
+		 * 可能唤醒的地方:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|418| <<process_msg>> req->cb(req);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|538| <<process_writes>> wake_up(&state.req->wq);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|344| <<xs_wake_up>> wake_up(&req->wq);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|1101| <<xs_reboot_notify>> wake_up(&req->wq);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|1111| <<xs_reboot_notify>> wake_up(&req->wq);
+		 */
 		wait_event(req->wq, test_reply(req));
 
 		if (!xenbus_ok())
@@ -211,11 +293,30 @@ static void *read_reply(struct xb_req_data *req)
 			 * has been killed or is unreachable.
 			 */
 			return ERR_PTR(-EIO);
+		/*
+		 * struct xb_req_data {
+		 *	struct list_head list;
+		 *	wait_queue_head_t wq;
+		 *	struct xsd_sockmsg msg;
+		 *	uint32_t caller_req_id;
+		 *	enum xsd_sockmsg_type type;
+		 *	char *body;
+		 *	const struct kvec *vec;
+		 *	int num_vecs;
+		 *	int err;
+		 *	enum xb_req_state state;
+		 *	void (*cb)(struct xb_req_data *);
+		 *	void *par;
+		 * };
+		 */
 		if (req->err)
 			return ERR_PTR(req->err);
 
 	}
 
+	/*
+	 * xb_req_data->body是唯一可能发表
+	 */
 	return req->body;
 }
 
@@ -223,6 +324,14 @@ static void xs_send(struct xb_req_data *req, struct xsd_sockmsg *msg)
 {
 	bool notify;
 
+	/*
+	 * 如果是xenbus_transaction_start()来的:
+	 * struct xsd_sockmsg
+	 *  -> type = XS_TRANSACTION_START
+	 *  -> req_id = 0
+	 *  -> tx_id = XBT_NIL.id
+	 *  -> len = 1
+	 */
 	req->msg = *msg;
 	req->err = 0;
 	req->state = xb_req_state_queued;
@@ -233,18 +342,38 @@ static void xs_send(struct xb_req_data *req, struct xsd_sockmsg *msg)
 	req->msg.req_id = xs_request_enter(req);
 
 	mutex_lock(&xb_write_mutex);
+	/*
+	 * 使用xb_write_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+	 *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+	 */
 	list_add_tail(&req->list, &xb_write_list);
 	notify = list_is_singular(&xb_write_list);
 	mutex_unlock(&xb_write_mutex);
 
+	/*
+	 * 唤醒xenbus_thread()
+	 */
 	if (notify)
 		wake_up(&xb_waitq);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|465| <<xs_talkv>> ret = xs_wait_for_reply(req, &msg);
+ */
 static void *xs_wait_for_reply(struct xb_req_data *req, struct xsd_sockmsg *msg)
 {
 	void *ret;
 
+	/*
+	 * 似乎下面的ret都依赖于这里!!!!!
+	 *
+	 * 关键是这里到底是不是NULL!!!!
+	 */
 	ret = read_reply(req);
 
 	xs_request_exit(req);
@@ -263,6 +392,10 @@ static void *xs_wait_for_reply(struct xb_req_data *req, struct xsd_sockmsg *msg)
 	return ret;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|418| <<process_msg>> req->cb(req);
+ */
 static void xs_wake_up(struct xb_req_data *req)
 {
 	wake_up(&req->wq);
@@ -293,13 +426,54 @@ int xenbus_dev_request_and_reply(struct xsd_sockmsg *msg, void *par)
 EXPORT_SYMBOL(xenbus_dev_request_and_reply);
 
 /* Send message to xs, get kmalloc'ed reply.  ERR_PTR() on error. */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|412| <<xs_single>> return xs_talkv(t, type, &iovec, 1, len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|543| <<xenbus_write>> ret = xs_error(xs_talkv(t, XS_WRITE, iovec, ARRAY_SIZE(iovec), NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|715| <<xs_watch>> return xs_error(xs_talkv(XBT_NIL, XS_WATCH, iov,
+ *   - drivers/xen/xenbus/xenbus_xs.c|728| <<xs_unwatch>> return xs_error(xs_talkv(XBT_NIL, XS_UNWATCH, iov,
+ *
+ * 如果是xenbus_transaction_start()来的:
+ * t     -> XBT_NIL
+ * type  -> XS_TRANSACTION_START
+ * iovec -> {"", strlen("")+1}
+ * 1     -> 1
+ * len   -> NULL
+ */
 static void *xs_talkv(struct xenbus_transaction t,
 		      enum xsd_sockmsg_type type,
 		      const struct kvec *iovec,
 		      unsigned int num_vecs,
 		      unsigned int *len)
 {
+	/*
+	 * 很复杂, 不是ring buffer的格式
+	 * struct xb_req_data {
+	 *	struct list_head list;
+	 *	wait_queue_head_t wq;
+	 *	struct xsd_sockmsg msg;
+	 *	uint32_t caller_req_id;
+	 *	enum xsd_sockmsg_type type;
+	 *	char *body;
+	 *	const struct kvec *vec;
+	 *	int num_vecs;
+	 *	int err;
+	 *	enum xb_req_state state;
+	 *	void (*cb)(struct xb_req_data *);
+	 *	void *par;
+	 * };
+	 */
 	struct xb_req_data *req;
+	/*
+	 * struct xsd_sockmsg
+	 * {
+	 *	uint32_t type;  // XS_???
+	 *	uint32_t req_id;// Request identifier, echoed in daemon's response.
+	 *	uint32_t tx_id; // Transaction id (0 if not related to a transaction).
+	 *	uint32_t len;   // Length of data following this.
+	 *	// Generally followed by nul-terminated string(s).
+	 * };
+	 */
 	struct xsd_sockmsg msg;
 	void *ret = NULL;
 	unsigned int i;
@@ -311,6 +485,10 @@ static void *xs_talkv(struct xenbus_transaction t,
 
 	req->vec = iovec;
 	req->num_vecs = num_vecs;
+	/*
+	 * called by:
+	 *    drivers/xen/xenbus/xenbus_comms.c|418| <<process_msg>> req->cb(req);
+	 */
 	req->cb = xs_wake_up;
 
 	msg.req_id = 0;
@@ -319,9 +497,20 @@ static void *xs_talkv(struct xenbus_transaction t,
 	msg.len = 0;
 	for (i = 0; i < num_vecs; i++)
 		msg.len += iovec[i].iov_len;
+	/*
+	 * 如果是xenbus_transaction_start()来的:
+	 * struct xsd_sockmsg
+	 *  -> type = XS_TRANSACTION_START
+	 *  -> req_id = 0
+	 *  -> tx_id = XBT_NIL.id
+	 *  -> len = 1
+	 */
 
 	xs_send(req, &msg);
 
+	/*
+	 * 似乎下面的ret都依赖于这里!!!!!
+	 */
 	ret = xs_wait_for_reply(req, &msg);
 	if (len)
 		*len = msg.len;
@@ -345,15 +534,50 @@ static void *xs_talkv(struct xenbus_transaction t,
 }
 
 /* Simplified version of xs_talkv: single message. */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|480| <<xenbus_directory>> strings = xs_single(t, XS_DIRECTORY, path, &len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|518| <<xenbus_read>> ret = xs_single(t, XS_READ, path, len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|560| <<xenbus_mkdir>> ret = xs_error(xs_single(t, XS_MKDIR, path, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|576| <<xenbus_rm>> ret = xs_error(xs_single(t, XS_RM, path, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|589| <<xenbus_transaction_start>> id_str = xs_single(XBT_NIL, XS_TRANSACTION_START, "", NULL);
+ *   - drivers/xen/xenbus/xenbus_xs.c|611| <<xenbus_transaction_end>> return xs_error(xs_single(t, XS_TRANSACTION_END, abortstr, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|802| <<xs_reset_watches>> err = xs_error(xs_single(XBT_NIL, XS_RESET_WATCHES, "", NULL));
+ *
+ * xs_single()直接返回xs_talkv()的结果()
+ */
 static void *xs_single(struct xenbus_transaction t,
 		       enum xsd_sockmsg_type type,
 		       const char *string,
 		       unsigned int *len)
 {
+	/*
+	 * struct kvec {
+	 *	void *iov_base; // and that should *never* hold a userland pointer
+	 *	size_t iov_len;
+	 * };
+	 */
 	struct kvec iovec;
 
+	/*
+	 * 如果是xenbus_transaction_start()进来的:
+	 * t      -> XBT_NIL
+	 * type   -> XS_TRANSACTION_START
+	 * string -> ""
+	 * len    -> NULL
+	 */
 	iovec.iov_base = (void *)string;
 	iovec.iov_len = strlen(string) + 1;
+	/*
+	 * 如果是xenbus_transaction_start()来的:
+	 * t     -> XBT_NIL
+	 * type  -> XS_TRANSACTION_START
+	 * iovec -> {"", strlen("")+1}
+	 * 1     -> 1
+	 * len   -> NULL
+	 *
+	 * 如果xs_single()返回NULL, 肯定是这里返回NULL!!!
+	 */
 	return xs_talkv(t, type, &iovec, 1, len);
 }
 
@@ -527,10 +751,33 @@ EXPORT_SYMBOL_GPL(xenbus_rm);
 /* Start a transaction: changes by others will not be seen during this
  * transaction, and changes will not be visible to others until end.
  */
+/*
+ * 在以下调用xenbus_transaction_start():
+ *   - drivers/block/xen-blkback/blkback.c|568| <<xen_vbd_resize>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/block/xen-blkback/xenbus.c|603| <<xen_emit_oracle_phys_device>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/block/xen-blkback/xenbus.c|993| <<connect>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/block/xen-blkfront.c|1830| <<talk_to_blkback>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/char/tpm/xen-tpmfront.c|223| <<setup_ring>> rv = xenbus_transaction_start(&xbt);
+ *   - drivers/input/misc/xen-kbdfront.c|269| <<xenkbd_connect_backend>> ret = xenbus_transaction_start(&xbt);
+ *   - drivers/net/xen-netback/xenbus.c|283| <<netback_probe>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/net/xen-netfront.c|2405| <<talk_to_netback>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/pci/xen-pcifront.c|805| <<pcifront_publish_info>> err = xenbus_transaction_start(&trans);
+ *   - drivers/scsi/xen-scsifront.c|772| <<scsifront_init_ring>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/tty/hvc/hvc_xen.c|403| <<xencons_connect_backend>> ret = xenbus_transaction_start(&xbt);
+ *   - drivers/video/fbdev/xen-fbfront.c|593| <<xenfb_connect_backend>> ret = xenbus_transaction_start(&xbt);
+ *   - drivers/xen/manage.c|229| <<shutdown_handler>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/xen/manage.c|274| <<sysrq_handler>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/xen/xen-pciback/pci_stub.c|672| <<kill_domain_by_device>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/xen/xen-pciback/pci_stub.c|695| <<kill_domain_by_device>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/xen/xenbus/xenbus_client.c|210| <<__xenbus_switch_state>> err = xenbus_transaction_start(&xbt);
+ */
 int xenbus_transaction_start(struct xenbus_transaction *t)
 {
 	char *id_str;
 
+	/*
+	 * 关于id_str是否为NULL, 核心在read_reply()的返回值!!
+	 */
 	id_str = xs_single(XBT_NIL, XS_TRANSACTION_START, "", NULL);
 	if (IS_ERR(id_str))
 		return PTR_ERR(id_str);
@@ -910,8 +1157,22 @@ static int xs_reboot_notify(struct notifier_block *nb,
 	struct xb_req_data *req;
 
 	mutex_lock(&xb_write_mutex);
+	/*
+	 * 使用xs_reply_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+	 *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+	 */
 	list_for_each_entry(req, &xs_reply_list, list)
 		wake_up(&req->wq);
+	/*
+	 * 使用xb_write_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+	 *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+	 */
 	list_for_each_entry(req, &xb_write_list, list)
 		wake_up(&req->wq);
 	mutex_unlock(&xb_write_mutex);
-- 
2.17.1

