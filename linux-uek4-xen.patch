From d62b597d573f2bd10ca3c3c3120b3c16e40b54cb Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 3 Feb 2020 13:53:44 -0800
Subject: [PATCH 1/1] linux uek4 xen

v4.1.12-124.26.12

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 drivers/xen/xenbus/xenbus_comms.c | 20 +++++++++++++++++
 drivers/xen/xenbus/xenbus_xs.c    | 37 +++++++++++++++++++++++++++++++
 2 files changed, 57 insertions(+)

diff --git a/drivers/xen/xenbus/xenbus_comms.c b/drivers/xen/xenbus/xenbus_comms.c
index babc9592b78a..fc2ee2f3f72e 100644
--- a/drivers/xen/xenbus/xenbus_comms.c
+++ b/drivers/xen/xenbus/xenbus_comms.c
@@ -47,6 +47,14 @@
 LIST_HEAD(xs_reply_list);
 
 /* A list of write requests. */
+/*
+ * 使用xb_write_list的地方:
+ *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+ *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+ */
 LIST_HEAD(xb_write_list);
 DECLARE_WAIT_QUEUE_HEAD(xb_waitq);
 DEFINE_MUTEX(xb_write_mutex);
@@ -334,6 +342,10 @@ static int process_msg(void)
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|430| <<xenbus_thread>> err = process_writes();
+ */
 static int process_writes(void)
 {
 	static struct {
@@ -351,6 +363,14 @@ static int process_writes(void)
 	mutex_lock(&xb_write_mutex);
 
 	if (!state.req) {
+		/*
+		 * 使用xb_write_list的地方:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+		 *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+		 */
 		state.req = list_first_entry(&xb_write_list,
 					     struct xb_req_data, list);
 		state.idx = -1;
diff --git a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c
index b8657ef0a3c3..a05e04c75abe 100644
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -233,6 +233,14 @@ static void xs_send(struct xb_req_data *req, struct xsd_sockmsg *msg)
 	req->msg.req_id = xs_request_enter(req);
 
 	mutex_lock(&xb_write_mutex);
+	/*
+	 * 使用xb_write_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+	 *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+	 */
 	list_add_tail(&req->list, &xb_write_list);
 	notify = list_is_singular(&xb_write_list);
 	mutex_unlock(&xb_write_mutex);
@@ -293,6 +301,14 @@ int xenbus_dev_request_and_reply(struct xsd_sockmsg *msg, void *par)
 EXPORT_SYMBOL(xenbus_dev_request_and_reply);
 
 /* Send message to xs, get kmalloc'ed reply.  ERR_PTR() on error. */
+/*
+ * 如果是xenbus_transaction_start()来的:
+ * t     -> XBT_NIL
+ * type  -> XS_TRANSACTION_START
+ * iovec -> {"", strlen("")+1}
+ * 1     -> 1
+ * len   -> NULL
+ */
 static void *xs_talkv(struct xenbus_transaction t,
 		      enum xsd_sockmsg_type type,
 		      const struct kvec *iovec,
@@ -350,10 +366,31 @@ static void *xs_single(struct xenbus_transaction t,
 		       const char *string,
 		       unsigned int *len)
 {
+	/*
+	 * struct kvec {
+	 *	void *iov_base; // and that should *never* hold a userland pointer
+	 *	size_t iov_len;
+	 * };
+	 */
 	struct kvec iovec;
 
+	/*
+	 * 如果是xenbus_transaction_start()进来的:
+	 * t      -> XBT_NIL
+	 * type   -> XS_TRANSACTION_START
+	 * string -> ""
+	 * len    -> NULL
+	 */
 	iovec.iov_base = (void *)string;
 	iovec.iov_len = strlen(string) + 1;
+	/*
+	 * 如果是xenbus_transaction_start()来的:
+	 * t     -> XBT_NIL
+	 * type  -> XS_TRANSACTION_START
+	 * iovec -> {"", strlen("")+1}
+	 * 1     -> 1
+	 * len   -> NULL
+	 */
 	return xs_talkv(t, type, &iovec, 1, len);
 }
 
-- 
2.17.1

