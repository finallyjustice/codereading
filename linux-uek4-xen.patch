From 2480a3dbea2f39b19167197688cb40fafcc3e96a Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Tue, 11 Feb 2020 08:42:02 -0800
Subject: [PATCH 1/1] linux uek4 xen

v4.1.12-124.26.12

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 drivers/xen/xenbus/xenbus_comms.c |  81 +++++++++++++++++
 drivers/xen/xenbus/xenbus_xs.c    | 143 ++++++++++++++++++++++++++++++
 2 files changed, 224 insertions(+)

diff --git a/drivers/xen/xenbus/xenbus_comms.c b/drivers/xen/xenbus/xenbus_comms.c
index babc9592b78a..75793fea94bc 100644
--- a/drivers/xen/xenbus/xenbus_comms.c
+++ b/drivers/xen/xenbus/xenbus_comms.c
@@ -44,9 +44,23 @@
 #include "xenbus.h"
 
 /* A list of replies. Currently only one will ever be outstanding. */
+/*
+ * 使用xs_reply_list的地方:
+ *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+ *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+ */
 LIST_HEAD(xs_reply_list);
 
 /* A list of write requests. */
+/*
+ * 使用xb_write_list的地方:
+ *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+ *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+ */
 LIST_HEAD(xb_write_list);
 DECLARE_WAIT_QUEUE_HEAD(xb_waitq);
 DEFINE_MUTEX(xb_write_mutex);
@@ -93,6 +107,7 @@ static const void *get_input_chunk(XENSTORE_RING_IDX cons,
 	*len = XENSTORE_RING_SIZE - MASK_XENSTORE_IDX(cons);
 	if ((prod - cons) < *len)
 		*len = prod - cons;
+	/* #define MASK_XENSTORE_IDX(idx) ((idx) & (XENSTORE_RING_SIZE-1)) */
 	return buf + MASK_XENSTORE_IDX(cons);
 }
 
@@ -111,6 +126,10 @@ static int xb_data_to_write(void)
  *
  * Returns number of bytes written or -err.
  */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|413| <<process_writes>> err = xb_write(base + state.written, len - state.written);
+ */
 static int xb_write(const void *data, unsigned int len)
 {
 	struct xenstore_domain_interface *intf = xen_store_interface;
@@ -163,8 +182,25 @@ static int xb_data_to_read(void)
 	return (intf->rsp_cons != intf->rsp_prod);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|285| <<process_msg>> err = xb_read((void *)&state.msg + state.read,
+ *   - drivers/xen/xenbus/xenbus_comms.c|314| <<process_msg>> err = xb_read(state.body + state.read, state.msg.len - state.read);
+ */
 static int xb_read(void *data, unsigned int len)
 {
+	/*
+	 * // Inter-domain shared memory communications.
+	 * #define XENSTORE_RING_SIZE 1024
+	 * typedef uint32_t XENSTORE_RING_IDX;
+	 * #define MASK_XENSTORE_IDX(idx) ((idx) & (XENSTORE_RING_SIZE-1))
+	 * struct xenstore_domain_interface {
+	 *	char req[XENSTORE_RING_SIZE]; // Requests to xenstore daemon.
+	 *	char rsp[XENSTORE_RING_SIZE]; // Replies and async watch events.
+	 *	XENSTORE_RING_IDX req_cons, req_prod;
+	 *	XENSTORE_RING_IDX rsp_cons, rsp_prod;
+	 * };
+	 */
 	struct xenstore_domain_interface *intf = xen_store_interface;
 	XENSTORE_RING_IDX cons, prod;
 	unsigned int bytes = 0;
@@ -193,6 +229,9 @@ static int xb_read(void *data, unsigned int len)
 		/* Must read data /after/ reading the producer index. */
 		rmb();
 
+		/*
+		 * data是要返回的read的地址
+		 */
 		memcpy(data, src, avail);
 		data += avail;
 		len -= avail;
@@ -210,6 +249,10 @@ static int xb_read(void *data, unsigned int len)
 	return bytes;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|494| <<xenbus_thread>> err = process_msg();
+ */
 static int process_msg(void)
 {
 	static struct {
@@ -242,6 +285,9 @@ static int process_msg(void)
 		 */
 		mutex_lock(&xs_response_mutex);
 
+		/*
+		 * 判断xenstore_domain_interface->rsp_cons是不是和xenstore_domain_interface->rsp_prod不一样
+		 */
 		if (!xb_data_to_read()) {
 			/* We raced with save/restore: pending data 'gone'. */
 			mutex_unlock(&xs_response_mutex);
@@ -297,7 +343,16 @@ static int process_msg(void)
 	} else {
 		err = -ENOENT;
 		mutex_lock(&xb_write_mutex);
+		/*
+		 * 使用xs_reply_list的地方:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+		 *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+		 */
 		list_for_each_entry(req, &xs_reply_list, list) {
+			/*
+			 * 只要找到一个匹配的就立刻break
+			 */
 			if (req->msg.req_id == state.msg.req_id) {
 				if (req->state == xb_req_state_wait_reply) {
 					req->msg.req_id = req->caller_req_id;
@@ -306,6 +361,9 @@ static int process_msg(void)
 					req->body = state.body;
 					req->state = xb_req_state_got_reply;
 					list_del(&req->list);
+					/*
+					 * 仅仅是一个例子xs_wake_up()
+					 */
 					req->cb(req);
 				} else {
 					list_del(&req->list);
@@ -334,6 +392,10 @@ static int process_msg(void)
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|430| <<xenbus_thread>> err = process_writes();
+ */
 static int process_writes(void)
 {
 	static struct {
@@ -351,6 +413,16 @@ static int process_writes(void)
 	mutex_lock(&xb_write_mutex);
 
 	if (!state.req) {
+		/*
+		 * 使用xb_write_list的地方:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+		 *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+		 *
+		 * req的类型struct xb_req_data *req;
+		 */
 		state.req = list_first_entry(&xb_write_list,
 					     struct xb_req_data, list);
 		state.idx = -1;
@@ -368,6 +440,9 @@ static int process_writes(void)
 			base = state.req->vec[state.idx].iov_base;
 			len = state.req->vec[state.idx].iov_len;
 		}
+		/*
+		 * 参数base来自紧接上面的if语句
+		 */
 		err = xb_write(base + state.written, len - state.written);
 		if (err < 0)
 			goto out_err;
@@ -381,6 +456,12 @@ static int process_writes(void)
 
 	list_del(&state.req->list);
 	state.req->state = xb_req_state_wait_reply;
+	/*
+	 * 使用xs_reply_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+	 *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+	 */
 	list_add_tail(&state.req->list, &xs_reply_list);
 	state.req = NULL;
 
diff --git a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c
index b8657ef0a3c3..5a0a92214906 100644
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -64,6 +64,16 @@
 /* Lock protecting enter/exit critical region. */
 static DEFINE_SPINLOCK(xs_state_lock);
 /* Number of users in critical region (protected by xs_state_lock). */
+/*
+ * 在以下使用xs_state_users:
+ *   - drivers/xen/xenbus/xenbus_xs.c|108| <<xs_suspend_enter>> wait_event(xs_state_exit_wq, xs_state_users == 0);
+ *   - drivers/xen/xenbus/xenbus_xs.c|136| <<xs_request_enter>> while (!xs_state_users && xs_suspend_active) {
+ *   - drivers/xen/xenbus/xenbus_xs.c|143| <<xs_request_enter>> xs_state_users++;
+ *   - drivers/xen/xenbus/xenbus_xs.c|144| <<xs_request_enter>> xs_state_users++;
+ *   - drivers/xen/xenbus/xenbus_xs.c|160| <<xs_request_exit>> xs_state_users--;
+ *   - drivers/xen/xenbus/xenbus_xs.c|163| <<xs_request_exit>> xs_state_users--;
+ *   - drivers/xen/xenbus/xenbus_xs.c|166| <<xs_request_exit>> if (xs_suspend_active && !xs_state_users)
+ */
 static unsigned int xs_state_users;
 /* Suspend handler waiting or already active (protected by xs_state_lock)? */
 static int xs_suspend_active;
@@ -96,6 +106,10 @@ static pid_t xenwatch_pid;
 static DEFINE_MUTEX(xenwatch_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(watch_events_waitq);
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|862| <<xs_suspend>> xs_suspend_enter();
+ */
 static void xs_suspend_enter(void)
 {
 	spin_lock(&xs_state_lock);
@@ -104,6 +118,11 @@ static void xs_suspend_enter(void)
 	wait_event(xs_state_exit_wq, xs_state_users == 0);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|877| <<xs_resume>> xs_suspend_exit();
+ *   - drivers/xen/xenbus/xenbus_xs.c|893| <<xs_suspend_cancel>> xs_suspend_exit();
+ */
 static void xs_suspend_exit(void)
 {
 	spin_lock(&xs_state_lock);
@@ -112,6 +131,10 @@ static void xs_suspend_exit(void)
 	wake_up_all(&xs_state_enter_wq);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|233| <<xs_send>> req->msg.req_id = xs_request_enter(req);
+ */
 static uint32_t xs_request_enter(struct xb_req_data *req)
 {
 	uint32_t rq_id;
@@ -136,6 +159,11 @@ static uint32_t xs_request_enter(struct xb_req_data *req)
 	return rq_id;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_dev_frontend.c|355| <<xenbus_dev_queue_reply>> xs_request_exit(req);
+ *   - drivers/xen/xenbus/xenbus_xs.c|258| <<xs_wait_for_reply>> xs_request_exit(req);
+ */
 void xs_request_exit(struct xb_req_data *req)
 {
 	spin_lock(&xs_state_lock);
@@ -223,6 +251,14 @@ static void xs_send(struct xb_req_data *req, struct xsd_sockmsg *msg)
 {
 	bool notify;
 
+	/*
+	 * 如果是xenbus_transaction_start()来的:
+	 * struct xsd_sockmsg
+	 *  -> type = XS_TRANSACTION_START
+	 *  -> req_id = 0
+	 *  -> tx_id = XBT_NIL.id
+	 *  -> len = 1
+	 */
 	req->msg = *msg;
 	req->err = 0;
 	req->state = xb_req_state_queued;
@@ -233,10 +269,21 @@ static void xs_send(struct xb_req_data *req, struct xsd_sockmsg *msg)
 	req->msg.req_id = xs_request_enter(req);
 
 	mutex_lock(&xb_write_mutex);
+	/*
+	 * 使用xb_write_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+	 *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+	 */
 	list_add_tail(&req->list, &xb_write_list);
 	notify = list_is_singular(&xb_write_list);
 	mutex_unlock(&xb_write_mutex);
 
+	/*
+	 * 唤醒xenbus_thread()
+	 */
 	if (notify)
 		wake_up(&xb_waitq);
 }
@@ -293,13 +340,54 @@ int xenbus_dev_request_and_reply(struct xsd_sockmsg *msg, void *par)
 EXPORT_SYMBOL(xenbus_dev_request_and_reply);
 
 /* Send message to xs, get kmalloc'ed reply.  ERR_PTR() on error. */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|412| <<xs_single>> return xs_talkv(t, type, &iovec, 1, len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|543| <<xenbus_write>> ret = xs_error(xs_talkv(t, XS_WRITE, iovec, ARRAY_SIZE(iovec), NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|715| <<xs_watch>> return xs_error(xs_talkv(XBT_NIL, XS_WATCH, iov,
+ *   - drivers/xen/xenbus/xenbus_xs.c|728| <<xs_unwatch>> return xs_error(xs_talkv(XBT_NIL, XS_UNWATCH, iov,
+ *
+ * 如果是xenbus_transaction_start()来的:
+ * t     -> XBT_NIL
+ * type  -> XS_TRANSACTION_START
+ * iovec -> {"", strlen("")+1}
+ * 1     -> 1
+ * len   -> NULL
+ */
 static void *xs_talkv(struct xenbus_transaction t,
 		      enum xsd_sockmsg_type type,
 		      const struct kvec *iovec,
 		      unsigned int num_vecs,
 		      unsigned int *len)
 {
+	/*
+	 * 很复杂, 不是ring buffer的格式
+	 * struct xb_req_data {
+	 *	struct list_head list;
+	 *	wait_queue_head_t wq;
+	 *	struct xsd_sockmsg msg;
+	 *	uint32_t caller_req_id;
+	 *	enum xsd_sockmsg_type type;
+	 *	char *body;
+	 *	const struct kvec *vec;
+	 *	int num_vecs;
+	 *	int err;
+	 *	enum xb_req_state state;
+	 *	void (*cb)(struct xb_req_data *);
+	 *	void *par;
+	 * };
+	 */
 	struct xb_req_data *req;
+	/*
+	 * struct xsd_sockmsg
+	 * {
+	 *	uint32_t type;  // XS_???
+	 *	uint32_t req_id;// Request identifier, echoed in daemon's response.
+	 *	uint32_t tx_id; // Transaction id (0 if not related to a transaction).
+	 *	uint32_t len;   // Length of data following this.
+	 *	// Generally followed by nul-terminated string(s).
+	 * };
+	 */
 	struct xsd_sockmsg msg;
 	void *ret = NULL;
 	unsigned int i;
@@ -319,6 +407,14 @@ static void *xs_talkv(struct xenbus_transaction t,
 	msg.len = 0;
 	for (i = 0; i < num_vecs; i++)
 		msg.len += iovec[i].iov_len;
+	/*
+	 * 如果是xenbus_transaction_start()来的:
+	 * struct xsd_sockmsg
+	 *  -> type = XS_TRANSACTION_START
+	 *  -> req_id = 0
+	 *  -> tx_id = XBT_NIL.id
+	 *  -> len = 1
+	 */
 
 	xs_send(req, &msg);
 
@@ -345,15 +441,48 @@ static void *xs_talkv(struct xenbus_transaction t,
 }
 
 /* Simplified version of xs_talkv: single message. */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|480| <<xenbus_directory>> strings = xs_single(t, XS_DIRECTORY, path, &len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|518| <<xenbus_read>> ret = xs_single(t, XS_READ, path, len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|560| <<xenbus_mkdir>> ret = xs_error(xs_single(t, XS_MKDIR, path, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|576| <<xenbus_rm>> ret = xs_error(xs_single(t, XS_RM, path, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|589| <<xenbus_transaction_start>> id_str = xs_single(XBT_NIL, XS_TRANSACTION_START, "", NULL);
+ *   - drivers/xen/xenbus/xenbus_xs.c|611| <<xenbus_transaction_end>> return xs_error(xs_single(t, XS_TRANSACTION_END, abortstr, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|802| <<xs_reset_watches>> err = xs_error(xs_single(XBT_NIL, XS_RESET_WATCHES, "", NULL));
+ *
+ * xs_single()直接返回xs_talkv()的结果()
+ */
 static void *xs_single(struct xenbus_transaction t,
 		       enum xsd_sockmsg_type type,
 		       const char *string,
 		       unsigned int *len)
 {
+	/*
+	 * struct kvec {
+	 *	void *iov_base; // and that should *never* hold a userland pointer
+	 *	size_t iov_len;
+	 * };
+	 */
 	struct kvec iovec;
 
+	/*
+	 * 如果是xenbus_transaction_start()进来的:
+	 * t      -> XBT_NIL
+	 * type   -> XS_TRANSACTION_START
+	 * string -> ""
+	 * len    -> NULL
+	 */
 	iovec.iov_base = (void *)string;
 	iovec.iov_len = strlen(string) + 1;
+	/*
+	 * 如果是xenbus_transaction_start()来的:
+	 * t     -> XBT_NIL
+	 * type  -> XS_TRANSACTION_START
+	 * iovec -> {"", strlen("")+1}
+	 * 1     -> 1
+	 * len   -> NULL
+	 */
 	return xs_talkv(t, type, &iovec, 1, len);
 }
 
@@ -910,8 +1039,22 @@ static int xs_reboot_notify(struct notifier_block *nb,
 	struct xb_req_data *req;
 
 	mutex_lock(&xb_write_mutex);
+	/*
+	 * 使用xs_reply_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+	 *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+	 */
 	list_for_each_entry(req, &xs_reply_list, list)
 		wake_up(&req->wq);
+	/*
+	 * 使用xb_write_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+	 *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+	 */
 	list_for_each_entry(req, &xb_write_list, list)
 		wake_up(&req->wq);
 	mutex_unlock(&xb_write_mutex);
-- 
2.17.1

