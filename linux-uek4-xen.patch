From 631dd0ae4be4a77339be3cc608358e0bf8f0173b Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 9 Dec 2020 14:26:15 -0800
Subject: [PATCH 1/1] linux uek4 xen

v4.1.12-124.26.12

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/xen/spinlock.c             |  25 +++
 drivers/net/xen-netback/common.h    |  47 +++++
 drivers/net/xen-netback/interface.c |  22 +++
 drivers/net/xen-netback/rx.c        | 101 +++++++++++
 drivers/net/xen-netback/xenbus.c    |  12 ++
 drivers/xen/xenbus/xenbus.h         |  24 +++
 drivers/xen/xenbus/xenbus_comms.c   | 185 ++++++++++++++++++++
 drivers/xen/xenbus/xenbus_xs.c      | 261 ++++++++++++++++++++++++++++
 net/bridge/br_forward.c             |   6 +
 net/bridge/br_stp.c                 |  69 ++++++++
 net/bridge/br_stp_if.c              |  11 ++
 11 files changed, 763 insertions(+)

diff --git a/arch/x86/xen/spinlock.c b/arch/x86/xen/spinlock.c
index 956374c1edbc..c36ec8b9fee8 100644
--- a/arch/x86/xen/spinlock.c
+++ b/arch/x86/xen/spinlock.c
@@ -100,8 +100,22 @@ struct xen_lock_waiting {
 	__ticket_t want;
 };
 
+/*
+ * 在以下使用lock_kicker_irq:
+ *   - arch/x86/xen/spinlock.c|111| <<xen_lock_spinning>> int irq = __this_cpu_read(lock_kicker_irq);
+ *   - arch/x86/xen/spinlock.c|235| <<xen_init_lock_cpu>> WARN(per_cpu(lock_kicker_irq, cpu) >= 0, "spinlock on CPU%d exists on IRQ%d!\n",
+ *   - arch/x86/xen/spinlock.c|236| <<xen_init_lock_cpu>> cpu, per_cpu(lock_kicker_irq, cpu));
+ *   - arch/x86/xen/spinlock.c|248| <<xen_init_lock_cpu>> per_cpu(lock_kicker_irq, cpu) = irq;
+ *   - arch/x86/xen/spinlock.c|260| <<xen_uninit_lock_cpu>> unbind_from_irqhandler(per_cpu(lock_kicker_irq, cpu), NULL);
+ *   - arch/x86/xen/spinlock.c|261| <<xen_uninit_lock_cpu>> per_cpu(lock_kicker_irq, cpu) = -1;
+ */
 static DEFINE_PER_CPU(int, lock_kicker_irq) = -1;
 static DEFINE_PER_CPU(char *, irq_name);
+/*
+ * 在以下使用xen_lock_waiting:
+ *   - arch/x86/xen/spinlock.c|125| <<xen_lock_spinning>> struct xen_lock_waiting *w = this_cpu_ptr(&lock_waiting);
+ *   - arch/x86/xen/spinlock.c|222| <<xen_unlock_kick>> const struct xen_lock_waiting *w = &per_cpu(lock_waiting, cpu);
+ */
 static DEFINE_PER_CPU(struct xen_lock_waiting, lock_waiting);
 static cpumask_t waiting_cpus;
 
@@ -224,6 +238,13 @@ static irqreturn_t dummy_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+/*
+ * called by:
+ *   - arch/x86/xen/smp.c|349| <<xen_smp_prepare_cpus>> xen_init_lock_cpu(0);
+ *   - arch/x86/xen/smp.c|459| <<xen_cpu_up>> xen_init_lock_cpu(cpu); 
+ *   - arch/x86/xen/smp.c|749| <<xen_hvm_smp_prepare_cpus>> xen_init_lock_cpu(0);
+ *   - arch/x86/xen/smp.c|784| <<xen_hvm_cpu_up>> xen_init_lock_cpu(cpu);
+ */
 void xen_init_lock_cpu(int cpu)
 {
 	int irq;
@@ -272,6 +293,10 @@ void xen_uninit_lock_cpu(int cpu)
  * The paravirt patching needs to be done _before_ the alternative asm code
  * is started, otherwise we would not patch the core kernel code.
  */
+/*
+ * called by:
+ *   - arch/x86/xen/smp.c|332| <<xen_smp_prepare_boot_cpu>> xen_init_spinlocks();
+ */
 void __init xen_init_spinlocks(void)
 {
 
diff --git a/drivers/net/xen-netback/common.h b/drivers/net/xen-netback/common.h
index 7c4d2e133411..6e051c89034a 100644
--- a/drivers/net/xen-netback/common.h
+++ b/drivers/net/xen-netback/common.h
@@ -204,6 +204,21 @@ struct xenvif_queue { /* Per-queue data for xenvif */
 	/* Only used when feature-split-event-channels = 1 */
 	char rx_irq_name[IRQ_NAME_SIZE]; /* DEVNAME-qN-rx */
 	struct xen_netif_rx_back_ring rx;
+	/*
+	 * 在以下使用xenvif->rx_queue:
+	 *   - drivers/net/xen-netback/interface.c|499| <<xenvif_init_queue>> skb_queue_head_init(&queue->rx_queue);
+	 *   - drivers/net/xen-netback/rx.c|70| <<xenvif_rx_queue_slots_available>> skb = skb_peek(&queue->rx_queue);
+	 *   - drivers/net/xen-netback/rx.c|81| <<xenvif_rx_queue_tail>> spin_lock_irqsave(&queue->rx_queue.lock, flags);
+	 *   - drivers/net/xen-netback/rx.c|83| <<xenvif_rx_queue_tail>> __skb_queue_tail(&queue->rx_queue, skb);
+	 *   - drivers/net/xen-netback/rx.c|92| <<xenvif_rx_queue_tail>> spin_unlock_irqrestore(&queue->rx_queue.lock, flags);
+	 *   - drivers/net/xen-netback/rx.c|99| <<xenvif_rx_dequeue>> spin_lock_irq(&queue->rx_queue.lock);
+	 *   - drivers/net/xen-netback/rx.c|101| <<xenvif_rx_dequeue>> skb = __skb_dequeue(&queue->rx_queue);
+	 *   - drivers/net/xen-netback/rx.c|112| <<xenvif_rx_dequeue>> spin_unlock_irq(&queue->rx_queue.lock);
+	 *   - drivers/net/xen-netback/rx.c|130| <<xenvif_rx_queue_drop_expired>> skb = skb_peek(&queue->rx_queue);
+	 *   - drivers/net/xen-netback/rx.c|515| <<xenvif_rx_queue_timeout>> skb = skb_peek(&queue->rx_queue);
+	 *   - drivers/net/xen-netback/rx.c|644| <<xenvif_kthread_guest_rx>> if (!skb_queue_empty(&queue->rx_queue))
+	 *   - drivers/net/xen-netback/xenbus.c|123| <<xenvif_read_io_ring>> skb_queue_len(&queue->rx_queue),
+	 */
 	struct sk_buff_head rx_queue;
 	/* This prevents from have guestrx thread and ndo_start_xmit to race
 	 * over response creation.
@@ -213,6 +228,14 @@ struct xenvif_queue { /* Per-queue data for xenvif */
 	unsigned int rx_queue_max;
 	unsigned int rx_queue_len;
 	unsigned long last_rx_time;
+	/*
+	 * 在以下使用xenvif_queue->stalled:
+	 *   - drivers/net/xen-netback/interface.c|602| <<xenvif_connect>> queue->stalled = true;
+	 *   - drivers/net/xen-netback/rx.c|484| <<xenvif_rx_queue_stalled>> return !queue->stalled &&
+	 *   - drivers/net/xen-netback/rx.c|497| <<xenvif_rx_queue_ready>> return queue->stalled && prod - cons >= 1;
+	 *   - drivers/net/xen-netback/rx.c|557| <<xenvif_queue_carrier_off>> queue->stalled = true;
+	 *   - drivers/net/xen-netback/rx.c|573| <<xenvif_queue_carrier_on>> queue->stalled = false;
+	 */
 	bool stalled;
 
 	struct xenvif_copy_state rx_copy;
@@ -265,14 +288,38 @@ struct xenvif {
 	/* Is this interface disabled? True when backend discovers
 	 * frontend is rogue.
 	 */
+	/*
+	 * 在以下使用xenvif->disabled:
+	 *   - drivers/net/xen-netback/interface.c|82| <<xenvif_schedulable>> !vif->disabled;
+	 *   - drivers/net/xen-netback/interface.c|105| <<xenvif_poll>> if (unlikely(queue->vif->disabled)) {
+	 *   - drivers/net/xen-netback/interface.c|442| <<xenvif_alloc>> vif->disabled = false;
+	 *   - drivers/net/xen-netback/netback.c|230| <<xenvif_fatal_tx_err>> vif->disabled = true;
+	 *   - drivers/net/xen-netback/rx.c|511| <<xenvif_have_rx_work>> queue->vif->disabled;
+	 *   - drivers/net/xen-netback/rx.c|643| <<xenvif_kthread_guest_rx>> if (unlikely(vif->disabled && queue->id == 0)) {
+	 */
 	bool disabled;
 	unsigned long status;
 	unsigned long drain_timeout;
+	/*
+	 * 在以下使用xenvif->stall_timeout:
+	 *   - drivers/net/xen-netback/interface.c|444| <<xenvif_alloc>> vif->stall_timeout = msecs_to_jiffies(rx_stall_timeout_msecs);
+	 *   - drivers/net/xen-netback/rx.c|487| <<xenvif_rx_queue_stalled>> queue->last_rx_time + queue->vif->stall_timeout);
+	 *   - drivers/net/xen-netback/rx.c|503| <<xenvif_have_rx_work>> (queue->vif->stall_timeout &&
+	 *   - drivers/net/xen-netback/rx.c|589| <<xenvif_kthread_guest_rx>> if (!vif->stall_timeout)
+	 *   - drivers/net/xen-netback/rx.c|617| <<xenvif_kthread_guest_rx>> if (vif->stall_timeout) {
+	 *   - drivers/net/xen-netback/xenbus.c|1098| <<read_xenbus_vif_flags>> be->vif->stall_timeout = 0;
+	 */
 	unsigned long stall_timeout;
 
 	/* Queues */
 	struct xenvif_queue *queues;
 	unsigned int num_queues; /* active queues, resource allocated */
+	/*
+	 * 在以下使用xenvif->stalled_queues:
+	 *   - drivers/net/xen-netback/rx.c|561| <<xenvif_queue_carrier_off>> if (vif->stalled_queues++ == 0) {
+	 *   - drivers/net/xen-netback/rx.c|577| <<xenvif_queue_carrier_on>> if (--vif->stalled_queues == 0) {
+	 *   - drivers/net/xen-netback/xenbus.c|892| <<connect>> be->vif->stalled_queues = requested_num_queues;
+	 */
 	unsigned int stalled_queues;
 
 	struct xenbus_watch credit_watch;
diff --git a/drivers/net/xen-netback/interface.c b/drivers/net/xen-netback/interface.c
index 432a965242da..8c523e6091d4 100644
--- a/drivers/net/xen-netback/interface.c
+++ b/drivers/net/xen-netback/interface.c
@@ -102,6 +102,15 @@ static int xenvif_poll(struct napi_struct *napi, int budget)
 	 * for this vif to deschedule it from NAPI. But this interface
 	 * will be turned off in thread context later.
 	 */
+	/*
+	 * 在以下使用xenvif->disabled:
+	 *   - drivers/net/xen-netback/interface.c|82| <<xenvif_schedulable>> !vif->disabled;
+	 *   - drivers/net/xen-netback/interface.c|105| <<xenvif_poll>> if (unlikely(queue->vif->disabled)) {
+	 *   - drivers/net/xen-netback/interface.c|442| <<xenvif_alloc>> vif->disabled = false;
+	 *   - drivers/net/xen-netback/netback.c|230| <<xenvif_fatal_tx_err>> vif->disabled = true;
+	 *   - drivers/net/xen-netback/rx.c|511| <<xenvif_have_rx_work>> queue->vif->disabled;
+	 *   - drivers/net/xen-netback/rx.c|643| <<xenvif_kthread_guest_rx>> if (unlikely(vif->disabled && queue->id == 0)) {
+	 */
 	if (unlikely(queue->vif->disabled)) {
 		napi_complete(napi);
 		return 0;
@@ -238,6 +247,11 @@ out:
 	return &vif->dev->stats;
 }
 
+/*
+ * called by:
+ *   - drivers/net/xen-netback/interface.c|277| <<xenvif_open>> xenvif_up(vif);
+ *   - drivers/net/xen-netback/interface.c|548| <<xenvif_carrier_on>> xenvif_up(vif);
+ */
 static void xenvif_up(struct xenvif *vif)
 {
 	struct xenvif_queue *queue = NULL;
@@ -533,6 +547,10 @@ int xenvif_init_queue(struct xenvif_queue *queue)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/net/xen-netback/xenbus.c|949| <<connect>> xenvif_carrier_on(be->vif);
+ */
 void xenvif_carrier_on(struct xenvif *vif)
 {
 	rtnl_lock();
@@ -545,6 +563,10 @@ void xenvif_carrier_on(struct xenvif *vif)
 	rtnl_unlock();
 }
 
+/*
+ * called by:
+ *   - drivers/net/xen-netback/xenbus.c|1029| <<connect_rings>> err = xenvif_connect(queue, tx_ring_ref, rx_ring_ref,
+ */
 int xenvif_connect(struct xenvif_queue *queue, unsigned long tx_ring_ref,
 		   unsigned long rx_ring_ref, unsigned int tx_evtchn,
 		   unsigned int rx_evtchn)
diff --git a/drivers/net/xen-netback/rx.c b/drivers/net/xen-netback/rx.c
index 0841cc8d99e1..88ace6022e93 100644
--- a/drivers/net/xen-netback/rx.c
+++ b/drivers/net/xen-netback/rx.c
@@ -74,6 +74,10 @@ static bool xenvif_rx_queue_slots_available(struct xenvif_queue *queue)
 	return xenvif_rx_ring_slots_available(queue, skb);
 }
 
+/*
+ * called by:
+ *   - drivers/net/xen-netback/interface.c|195| <<xenvif_start_xmit>> xenvif_rx_queue_tail(queue, skb);
+ */
 void xenvif_rx_queue_tail(struct xenvif_queue *queue, struct sk_buff *skb)
 {
 	unsigned long flags;
@@ -487,6 +491,11 @@ static bool xenvif_rx_queue_stalled(struct xenvif_queue *queue)
 			   queue->last_rx_time + queue->vif->stall_timeout);
 }
 
+/*
+ * called by:
+ *   - drivers/net/xen-netback/rx.c|509| <<xenvif_have_rx_work>> xenvif_rx_queue_ready(queue))) ||
+ *   - drivers/net/xen-netback/rx.c|682| <<xenvif_kthread_guest_rx>> else if (xenvif_rx_queue_ready(queue))
+ */
 static bool xenvif_rx_queue_ready(struct xenvif_queue *queue)
 {
 	RING_IDX prod, cons;
@@ -494,11 +503,28 @@ static bool xenvif_rx_queue_ready(struct xenvif_queue *queue)
 	prod = queue->rx.sring->req_prod;
 	cons = queue->rx.req_cons;
 
+	/*
+	 * 在以下使用xenvif_queue->stalled:
+	 *   - drivers/net/xen-netback/interface.c|602| <<xenvif_connect>> queue->stalled = true;
+	 *   - drivers/net/xen-netback/rx.c|484| <<xenvif_rx_queue_stalled>> return !queue->stalled &&
+	 *   - drivers/net/xen-netback/rx.c|497| <<xenvif_rx_queue_ready>> return queue->stalled && prod - cons >= 1;
+	 *   - drivers/net/xen-netback/rx.c|557| <<xenvif_queue_carrier_off>> queue->stalled = true;
+	 *   - drivers/net/xen-netback/rx.c|573| <<xenvif_queue_carrier_on>> queue->stalled = false;
+	 */
 	return queue->stalled && prod - cons >= 1;
 }
 
 static bool xenvif_have_rx_work(struct xenvif_queue *queue)
 {
+	/*
+	 * 在以下使用xenvif->disabled:
+	 *   - drivers/net/xen-netback/interface.c|82| <<xenvif_schedulable>> !vif->disabled;
+	 *   - drivers/net/xen-netback/interface.c|105| <<xenvif_poll>> if (unlikely(queue->vif->disabled)) {
+	 *   - drivers/net/xen-netback/interface.c|442| <<xenvif_alloc>> vif->disabled = false;
+	 *   - drivers/net/xen-netback/netback.c|230| <<xenvif_fatal_tx_err>> vif->disabled = true;
+	 *   - drivers/net/xen-netback/rx.c|511| <<xenvif_have_rx_work>> queue->vif->disabled;
+	 *   - drivers/net/xen-netback/rx.c|643| <<xenvif_kthread_guest_rx>> if (unlikely(vif->disabled && queue->id == 0)) {
+	 */
 	return xenvif_rx_queue_slots_available(queue) ||
 		(queue->vif->stall_timeout &&
 		 (xenvif_rx_queue_stalled(queue) ||
@@ -550,6 +576,10 @@ static void xenvif_wait_for_rx_work(struct xenvif_queue *queue)
 	finish_wait(&queue->wq, &wait);
 }
 
+/*
+ * called by:
+ *   - drivers/net/xen-netback/rx.c|619| <<xenvif_kthread_guest_rx>> xenvif_queue_carrier_off(queue);
+ */
 static void xenvif_queue_carrier_off(struct xenvif_queue *queue)
 {
 	struct xenvif *vif = queue->vif;
@@ -558,6 +588,12 @@ static void xenvif_queue_carrier_off(struct xenvif_queue *queue)
 
 	/* At least one queue has stalled? Disable the carrier. */
 	spin_lock(&vif->lock);
+	/*
+	 * 在以下使用xenvif->stalled_queues:
+	 *   - drivers/net/xen-netback/rx.c|561| <<xenvif_queue_carrier_off>> if (vif->stalled_queues++ == 0) {
+	 *   - drivers/net/xen-netback/rx.c|577| <<xenvif_queue_carrier_on>> if (--vif->stalled_queues == 0) {
+	 *   - drivers/net/xen-netback/xenbus.c|892| <<connect>> be->vif->stalled_queues = requested_num_queues;
+	 */
 	if (vif->stalled_queues++ == 0) {
 		netdev_info(vif->dev, "Guest Rx stalled");
 		netif_carrier_off(vif->dev);
@@ -565,6 +601,28 @@ static void xenvif_queue_carrier_off(struct xenvif_queue *queue)
 	spin_unlock(&vif->lock);
 }
 
+/*
+ * 似乎最终会导致
+ * [0] br_make_forwarding
+ * [0] br_stp_enable_port
+ * [0] br_port_carrier_check
+ * [0] br_device_event
+ * [0] notifier_call_chain
+ * [0] raw_notifier_call_chain
+ * [0] call_netdevice_notifiers_info
+ * [0] netdev_state_change
+ * [0] linkwatch_do_dev
+ * [0] __linkwatch_run_queue
+ * [0] linkwatch_event
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/net/xen-netback/rx.c|590| <<xenvif_kthread_guest_rx>> xenvif_queue_carrier_on(queue);
+ *   - drivers/net/xen-netback/rx.c|621| <<xenvif_kthread_guest_rx>> xenvif_queue_carrier_on(queue);
+ */
 static void xenvif_queue_carrier_on(struct xenvif_queue *queue)
 {
 	struct xenvif *vif = queue->vif;
@@ -574,6 +632,12 @@ static void xenvif_queue_carrier_on(struct xenvif_queue *queue)
 
 	/* All queues are ready? Enable the carrier. */
 	spin_lock(&vif->lock);
+	/*
+	 * 在以下使用xenvif->stalled_queues:
+	 *   - drivers/net/xen-netback/rx.c|561| <<xenvif_queue_carrier_off>> if (vif->stalled_queues++ == 0) {
+	 *   - drivers/net/xen-netback/rx.c|577| <<xenvif_queue_carrier_on>> if (--vif->stalled_queues == 0) {
+	 *   - drivers/net/xen-netback/xenbus.c|892| <<connect>> be->vif->stalled_queues = requested_num_queues;
+	 */
 	if (--vif->stalled_queues == 0) {
 		netdev_info(vif->dev, "Guest Rx ready");
 		netif_carrier_on(vif->dev);
@@ -581,11 +645,24 @@ static void xenvif_queue_carrier_on(struct xenvif_queue *queue)
 	spin_unlock(&vif->lock);
 }
 
+/*
+ * 在以下使用xenvif_kthread_guest_rx():
+ *   - drivers/net/xen-netback/interface.c|604| <<xenvif_connect>> task = kthread_create(xenvif_kthread_guest_rx,
+ */
 int xenvif_kthread_guest_rx(void *data)
 {
 	struct xenvif_queue *queue = data;
 	struct xenvif *vif = queue->vif;
 
+	/*
+	 * 在以下使用xenvif->stall_timeout:
+	 *   - drivers/net/xen-netback/interface.c|444| <<xenvif_alloc>> vif->stall_timeout = msecs_to_jiffies(rx_stall_timeout_msecs);
+	 *   - drivers/net/xen-netback/rx.c|487| <<xenvif_rx_queue_stalled>> queue->last_rx_time + queue->vif->stall_timeout);
+	 *   - drivers/net/xen-netback/rx.c|503| <<xenvif_have_rx_work>> (queue->vif->stall_timeout &&
+	 *   - drivers/net/xen-netback/rx.c|589| <<xenvif_kthread_guest_rx>> if (!vif->stall_timeout)
+	 *   - drivers/net/xen-netback/rx.c|617| <<xenvif_kthread_guest_rx>> if (vif->stall_timeout) {
+	 *   - drivers/net/xen-netback/xenbus.c|1098| <<read_xenbus_vif_flags>> be->vif->stall_timeout = 0;
+	 */
 	if (!vif->stall_timeout)
 		xenvif_queue_carrier_on(queue);
 
@@ -607,6 +684,21 @@ int xenvif_kthread_guest_rx(void *data)
 			break;
 		}
 
+		/*
+		 * 在以下使用xenvif->rx_queue:
+		 *   - drivers/net/xen-netback/interface.c|499| <<xenvif_init_queue>> skb_queue_head_init(&queue->rx_queue);
+		 *   - drivers/net/xen-netback/rx.c|70| <<xenvif_rx_queue_slots_available>> skb = skb_peek(&queue->rx_queue);
+		 *   - drivers/net/xen-netback/rx.c|81| <<xenvif_rx_queue_tail>> spin_lock_irqsave(&queue->rx_queue.lock, flags);
+		 *   - drivers/net/xen-netback/rx.c|83| <<xenvif_rx_queue_tail>> __skb_queue_tail(&queue->rx_queue, skb);
+		 *   - drivers/net/xen-netback/rx.c|92| <<xenvif_rx_queue_tail>> spin_unlock_irqrestore(&queue->rx_queue.lock, flags);
+		 *   - drivers/net/xen-netback/rx.c|99| <<xenvif_rx_dequeue>> spin_lock_irq(&queue->rx_queue.lock);
+		 *   - drivers/net/xen-netback/rx.c|101| <<xenvif_rx_dequeue>> skb = __skb_dequeue(&queue->rx_queue);
+		 *   - drivers/net/xen-netback/rx.c|112| <<xenvif_rx_dequeue>> spin_unlock_irq(&queue->rx_queue.lock);
+		 *   - drivers/net/xen-netback/rx.c|130| <<xenvif_rx_queue_drop_expired>> skb = skb_peek(&queue->rx_queue);
+		 *   - drivers/net/xen-netback/rx.c|515| <<xenvif_rx_queue_timeout>> skb = skb_peek(&queue->rx_queue);
+		 *   - drivers/net/xen-netback/rx.c|644| <<xenvif_kthread_guest_rx>> if (!skb_queue_empty(&queue->rx_queue))
+		 *   - drivers/net/xen-netback/xenbus.c|123| <<xenvif_read_io_ring>> skb_queue_len(&queue->rx_queue),
+		 */
 		if (!skb_queue_empty(&queue->rx_queue))
 			xenvif_rx_action(queue);
 
@@ -614,6 +706,15 @@ int xenvif_kthread_guest_rx(void *data)
 		 * while it's probably not responsive, drop the
 		 * carrier so packets are dropped earlier.
 		 */
+		/*
+		 * 在以下使用xenvif->stall_timeout:
+		 *   - drivers/net/xen-netback/interface.c|444| <<xenvif_alloc>> vif->stall_timeout = msecs_to_jiffies(rx_stall_timeout_msecs);
+		 *   - drivers/net/xen-netback/rx.c|487| <<xenvif_rx_queue_stalled>> queue->last_rx_time + queue->vif->stall_timeout);
+		 *   - drivers/net/xen-netback/rx.c|503| <<xenvif_have_rx_work>> (queue->vif->stall_timeout &&
+		 *   - drivers/net/xen-netback/rx.c|589| <<xenvif_kthread_guest_rx>> if (!vif->stall_timeout)
+		 *   - drivers/net/xen-netback/rx.c|617| <<xenvif_kthread_guest_rx>> if (vif->stall_timeout) {
+		 *   - drivers/net/xen-netback/xenbus.c|1098| <<read_xenbus_vif_flags>> be->vif->stall_timeout = 0;
+		 */
 		if (vif->stall_timeout) {
 			if (xenvif_rx_queue_stalled(queue))
 				xenvif_queue_carrier_off(queue);
diff --git a/drivers/net/xen-netback/xenbus.c b/drivers/net/xen-netback/xenbus.c
index fd098d362b03..4a1b392d23d0 100644
--- a/drivers/net/xen-netback/xenbus.c
+++ b/drivers/net/xen-netback/xenbus.c
@@ -469,6 +469,10 @@ static void backend_disconnect(struct backend_info *be)
 	}
 }
 
+/*
+ * called by:
+ *   - drivers/net/xen-netback/xenbus.c|548| <<set_backend_state>> backend_connect(be);
+ */
 static void backend_connect(struct backend_info *be)
 {
 	if (be->vif)
@@ -846,6 +850,10 @@ static void hotplug_status_changed(struct xenbus_watch *watch,
 	kfree(str);
 }
 
+/*
+ * called by:
+ *   - drivers/net/xen-netback/xenbus.c|475| <<backend_connect>> connect(be);
+ */
 static void connect(struct backend_info *be)
 {
 	int err;
@@ -961,6 +969,10 @@ err:
 }
 
 
+/*
+ * called by:
+ *   - drivers/net/xen-netback/xenbus.c|917| <<connect>> err = connect_rings(be, queue);
+ */
 static int connect_rings(struct backend_info *be, struct xenvif_queue *queue)
 {
 	struct xenbus_device *dev = be->dev;
diff --git a/drivers/xen/xenbus/xenbus.h b/drivers/xen/xenbus/xenbus.h
index 092981171df1..292029c54225 100644
--- a/drivers/xen/xenbus/xenbus.h
+++ b/drivers/xen/xenbus/xenbus.h
@@ -66,9 +66,33 @@ struct xs_watch_event {
 };
 
 enum xb_req_state {
+	/*
+	 * 在以下使用xb_req_state_queued:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|290| <<xs_send>> req->state = xb_req_state_queued;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|332| <<xs_wait_for_reply>> if (req->state == xb_req_state_queued ||
+	 */
 	xb_req_state_queued,
+	/*
+	 * 在以下使用xb_req_state_wait_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|458| <<process_writes>> state.req->state = xb_req_state_wait_reply;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|357| <<process_msg>> if (req->state == xb_req_state_wait_reply) {
+	 *   - drivers/xen/xenbus/xenbus_xs.c|333| <<xs_wait_for_reply>> req->state == xb_req_state_wait_reply)
+	 */
 	xb_req_state_wait_reply,
+	/*
+	 * 在以下使用xb_req_state_got_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|362| <<process_msg>> req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|480| <<process_writes>> state.req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|220| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok())
+	 *   - drivers/xen/xenbus/xenbus_xs.c|231| <<read_reply>> while (req->state != xb_req_state_got_reply) {
+	 */
 	xb_req_state_got_reply,
+	/*
+	 * 在以下使用xb_req_state_aborted:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|334| <<xs_wait_for_reply>> req->state = xb_req_state_aborted;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|432| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 *   - drivers/xen/xenbus/xenbus_comms.c|477| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 */
 	xb_req_state_aborted
 };
 
diff --git a/drivers/xen/xenbus/xenbus_comms.c b/drivers/xen/xenbus/xenbus_comms.c
index babc9592b78a..b4cac354acc8 100644
--- a/drivers/xen/xenbus/xenbus_comms.c
+++ b/drivers/xen/xenbus/xenbus_comms.c
@@ -44,11 +44,39 @@
 #include "xenbus.h"
 
 /* A list of replies. Currently only one will ever be outstanding. */
+/*
+ * 使用xs_reply_list的地方:
+ *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+ *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+ */
 LIST_HEAD(xs_reply_list);
 
 /* A list of write requests. */
+/*
+ * 使用xb_write_list的地方:
+ *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+ *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+ */
 LIST_HEAD(xb_write_list);
 DECLARE_WAIT_QUEUE_HEAD(xb_waitq);
+/*
+ * 使用xb_write_mutex的地方:
+ *   - drivers/xen/xenbus/xenbus_comms.c|374| <<process_msg>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|413| <<process_msg>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|450| <<process_writes>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|506| <<process_writes>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|521| <<process_writes>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|297| <<xs_send>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|308| <<xs_send>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|331| <<xs_wait_for_reply>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|337| <<xs_wait_for_reply>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|1093| <<xs_reboot_notify>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|1112| <<xs_reboot_notify>> mutex_unlock(&xb_write_mutex);
+ */
 DEFINE_MUTEX(xb_write_mutex);
 
 /* Protect xenbus reader thread against save/restore. */
@@ -93,6 +121,7 @@ static const void *get_input_chunk(XENSTORE_RING_IDX cons,
 	*len = XENSTORE_RING_SIZE - MASK_XENSTORE_IDX(cons);
 	if ((prod - cons) < *len)
 		*len = prod - cons;
+	/* #define MASK_XENSTORE_IDX(idx) ((idx) & (XENSTORE_RING_SIZE-1)) */
 	return buf + MASK_XENSTORE_IDX(cons);
 }
 
@@ -111,6 +140,10 @@ static int xb_data_to_write(void)
  *
  * Returns number of bytes written or -err.
  */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|413| <<process_writes>> err = xb_write(base + state.written, len - state.written);
+ */
 static int xb_write(const void *data, unsigned int len)
 {
 	struct xenstore_domain_interface *intf = xen_store_interface;
@@ -163,8 +196,25 @@ static int xb_data_to_read(void)
 	return (intf->rsp_cons != intf->rsp_prod);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|285| <<process_msg>> err = xb_read((void *)&state.msg + state.read,
+ *   - drivers/xen/xenbus/xenbus_comms.c|314| <<process_msg>> err = xb_read(state.body + state.read, state.msg.len - state.read);
+ */
 static int xb_read(void *data, unsigned int len)
 {
+	/*
+	 * // Inter-domain shared memory communications.
+	 * #define XENSTORE_RING_SIZE 1024
+	 * typedef uint32_t XENSTORE_RING_IDX;
+	 * #define MASK_XENSTORE_IDX(idx) ((idx) & (XENSTORE_RING_SIZE-1))
+	 * struct xenstore_domain_interface {
+	 *	char req[XENSTORE_RING_SIZE]; // Requests to xenstore daemon.
+	 *	char rsp[XENSTORE_RING_SIZE]; // Replies and async watch events.
+	 *	XENSTORE_RING_IDX req_cons, req_prod;
+	 *	XENSTORE_RING_IDX rsp_cons, rsp_prod;
+	 * };
+	 */
 	struct xenstore_domain_interface *intf = xen_store_interface;
 	XENSTORE_RING_IDX cons, prod;
 	unsigned int bytes = 0;
@@ -193,6 +243,9 @@ static int xb_read(void *data, unsigned int len)
 		/* Must read data /after/ reading the producer index. */
 		rmb();
 
+		/*
+		 * data是要返回的read的地址
+		 */
 		memcpy(data, src, avail);
 		data += avail;
 		len -= avail;
@@ -210,13 +263,38 @@ static int xb_read(void *data, unsigned int len)
 	return bytes;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|494| <<xenbus_thread>> err = process_msg();
+ */
 static int process_msg(void)
 {
 	static struct {
+		/*
+		 * struct xsd_sockmsg
+		 * {
+		 *	uint32_t type;  // XS_???
+		 *	uint32_t req_id;// Request identifier, echoed in daemon's response.
+		 *	uint32_t tx_id; // Transaction id (0 if not related to a transaction).
+		 *	uint32_t len;   // Length of data following this.
+		 *
+		 *	// Generally followed by nul-terminated string(s).
+		 * };
+		 */
 		struct xsd_sockmsg msg;
 		char *body;
 		union {
 			void *alloc;
+			/*
+			 * struct xs_watch_event {
+			 *	struct list_head list;
+			 *	unsigned int len;
+			 *	struct xenbus_watch *handle;
+			 *	const char *path;
+			 *	const char *token;
+			 *	char body[];
+			 * };
+			 */
 			struct xs_watch_event *watch;
 		};
 		bool in_msg;
@@ -242,6 +320,9 @@ static int process_msg(void)
 		 */
 		mutex_lock(&xs_response_mutex);
 
+		/*
+		 * 判断xenstore_domain_interface->rsp_cons是不是和xenstore_domain_interface->rsp_prod不一样
+		 */
 		if (!xb_data_to_read()) {
 			/* We raced with save/restore: pending data 'gone'. */
 			mutex_unlock(&xs_response_mutex);
@@ -269,10 +350,18 @@ static int process_msg(void)
 		if (state.msg.type == XS_WATCH_EVENT)
 			len += sizeof(*state.watch);
 
+		/*
+		 * 这里是唯一分配alloc的地方!!!
+		 */
 		state.alloc = kmalloc(len, GFP_NOIO | __GFP_HIGH);
 		if (!state.alloc)
 			return -ENOMEM;
 
+		/*
+		 * 以下的两个是一个union中的:
+		 *   * void *alloc;
+		 *   - struct xs_watch_event *watch;
+		 */
 		if (state.msg.type == XS_WATCH_EVENT)
 			state.body = state.watch->body;
 		else
@@ -297,15 +386,45 @@ static int process_msg(void)
 	} else {
 		err = -ENOENT;
 		mutex_lock(&xb_write_mutex);
+		/*
+		 * 使用xs_reply_list的地方:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+		 *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+		 *
+		 * req是struct xb_req_data *req;
+		 */
 		list_for_each_entry(req, &xs_reply_list, list) {
+			/*
+			 * 只要找到一个匹配的就立刻break
+			 */
 			if (req->msg.req_id == state.msg.req_id) {
+				/*
+				 * 在以下使用xb_req_state_wait_reply:
+				 *   - drivers/xen/xenbus/xenbus_comms.c|458| <<process_writes>> state.req->state = xb_req_state_wait_reply;
+				 *   - drivers/xen/xenbus/xenbus_comms.c|357| <<process_msg>> if (req->state == xb_req_state_wait_reply) {
+				 *   - drivers/xen/xenbus/xenbus_xs.c|333| <<xs_wait_for_reply>> req->state == xb_req_state_wait_reply)
+				 */
 				if (req->state == xb_req_state_wait_reply) {
 					req->msg.req_id = req->caller_req_id;
 					req->msg.type = state.msg.type;
 					req->msg.len = state.msg.len;
 					req->body = state.body;
+					/*
+					 * 在以下使用xb_req_state_got_reply:
+					 *   - drivers/xen/xenbus/xenbus_comms.c|362| <<process_msg>> req->state = xb_req_state_got_reply;
+					 *   - drivers/xen/xenbus/xenbus_comms.c|480| <<process_writes>> state.req->state = xb_req_state_got_reply;
+					 *   - drivers/xen/xenbus/xenbus_xs.c|220| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok())
+					 *   - drivers/xen/xenbus/xenbus_xs.c|231| <<read_reply>> while (req->state != xb_req_state_got_reply) {
+					 */
 					req->state = xb_req_state_got_reply;
 					list_del(&req->list);
+					/*
+					 * 仅仅是一个例子xs_wake_up()
+					 *
+					 * 这是唯一调用cb的地方:
+					 *   - drivers/xen/xenbus/xenbus_comms.c|418| <<process_msg>> req->cb(req);
+					 */
 					req->cb(req);
 				} else {
 					list_del(&req->list);
@@ -334,9 +453,29 @@ static int process_msg(void)
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|430| <<xenbus_thread>> err = process_writes();
+ */
 static int process_writes(void)
 {
 	static struct {
+		/*
+		 * struct xb_req_data {
+		 *	struct list_head list;
+		 *	wait_queue_head_t wq;
+		 *	struct xsd_sockmsg msg;
+		 *	uint32_t caller_req_id;
+		 *	enum xsd_sockmsg_type type;
+		 *	char *body;
+		 *	const struct kvec *vec;
+		 *	int num_vecs;
+		 *	int err;
+		 *	enum xb_req_state state;
+		 *	void (*cb)(struct xb_req_data *);
+		 *	void *par;
+		 * };
+		 */
 		struct xb_req_data *req;
 		int idx;
 		unsigned int written;
@@ -348,9 +487,33 @@ static int process_writes(void)
 	if (!xb_data_to_write())
 		return 0;
 
+	/*
+	 * 使用xb_write_mutex的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|374| <<process_msg>> mutex_lock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|413| <<process_msg>> mutex_unlock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|450| <<process_writes>> mutex_lock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|506| <<process_writes>> mutex_unlock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|521| <<process_writes>> mutex_unlock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|297| <<xs_send>> mutex_lock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|308| <<xs_send>> mutex_unlock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|331| <<xs_wait_for_reply>> mutex_lock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|337| <<xs_wait_for_reply>> mutex_unlock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|1093| <<xs_reboot_notify>> mutex_lock(&xb_write_mutex);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|1112| <<xs_reboot_notify>> mutex_unlock(&xb_write_mutex);
+	 */
 	mutex_lock(&xb_write_mutex);
 
 	if (!state.req) {
+		/*
+		 * 使用xb_write_list的地方:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+		 *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+		 *
+		 * req的类型struct xb_req_data *req;
+		 */
 		state.req = list_first_entry(&xb_write_list,
 					     struct xb_req_data, list);
 		state.idx = -1;
@@ -368,6 +531,9 @@ static int process_writes(void)
 			base = state.req->vec[state.idx].iov_base;
 			len = state.req->vec[state.idx].iov_len;
 		}
+		/*
+		 * 参数base来自紧接上面的if语句
+		 */
 		err = xb_write(base + state.written, len - state.written);
 		if (err < 0)
 			goto out_err;
@@ -381,6 +547,12 @@ static int process_writes(void)
 
 	list_del(&state.req->list);
 	state.req->state = xb_req_state_wait_reply;
+	/*
+	 * 使用xs_reply_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+	 *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+	 */
 	list_add_tail(&state.req->list, &xs_reply_list);
 	state.req = NULL;
 
@@ -393,9 +565,22 @@ static int process_writes(void)
 	state.req->msg.type = XS_ERROR;
 	state.req->err = err;
 	list_del(&state.req->list);
+	/*
+	 * 在以下使用xb_req_state_aborted:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|334| <<xs_wait_for_reply>> req->state = xb_req_state_aborted;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|432| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 *   - drivers/xen/xenbus/xenbus_comms.c|477| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 */
 	if (state.req->state == xb_req_state_aborted)
 		kfree(state.req);
 	else {
+		/*
+		 * 在以下使用xb_req_state_got_reply:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|362| <<process_msg>> req->state = xb_req_state_got_reply;
+		 *   - drivers/xen/xenbus/xenbus_comms.c|480| <<process_writes>> state.req->state = xb_req_state_got_reply;
+		 *   - drivers/xen/xenbus/xenbus_xs.c|220| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok())
+		 *   - drivers/xen/xenbus/xenbus_xs.c|231| <<read_reply>> while (req->state != xb_req_state_got_reply) {
+		 */
 		state.req->state = xb_req_state_got_reply;
 		wake_up(&state.req->wq);
 	}
diff --git a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c
index b8657ef0a3c3..6f0a15d36c51 100644
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -64,6 +64,16 @@
 /* Lock protecting enter/exit critical region. */
 static DEFINE_SPINLOCK(xs_state_lock);
 /* Number of users in critical region (protected by xs_state_lock). */
+/*
+ * 在以下使用xs_state_users:
+ *   - drivers/xen/xenbus/xenbus_xs.c|108| <<xs_suspend_enter>> wait_event(xs_state_exit_wq, xs_state_users == 0);
+ *   - drivers/xen/xenbus/xenbus_xs.c|136| <<xs_request_enter>> while (!xs_state_users && xs_suspend_active) {
+ *   - drivers/xen/xenbus/xenbus_xs.c|143| <<xs_request_enter>> xs_state_users++;
+ *   - drivers/xen/xenbus/xenbus_xs.c|144| <<xs_request_enter>> xs_state_users++;
+ *   - drivers/xen/xenbus/xenbus_xs.c|160| <<xs_request_exit>> xs_state_users--;
+ *   - drivers/xen/xenbus/xenbus_xs.c|163| <<xs_request_exit>> xs_state_users--;
+ *   - drivers/xen/xenbus/xenbus_xs.c|166| <<xs_request_exit>> if (xs_suspend_active && !xs_state_users)
+ */
 static unsigned int xs_state_users;
 /* Suspend handler waiting or already active (protected by xs_state_lock)? */
 static int xs_suspend_active;
@@ -96,6 +106,10 @@ static pid_t xenwatch_pid;
 static DEFINE_MUTEX(xenwatch_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(watch_events_waitq);
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|862| <<xs_suspend>> xs_suspend_enter();
+ */
 static void xs_suspend_enter(void)
 {
 	spin_lock(&xs_state_lock);
@@ -104,6 +118,11 @@ static void xs_suspend_enter(void)
 	wait_event(xs_state_exit_wq, xs_state_users == 0);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|877| <<xs_resume>> xs_suspend_exit();
+ *   - drivers/xen/xenbus/xenbus_xs.c|893| <<xs_suspend_cancel>> xs_suspend_exit();
+ */
 static void xs_suspend_exit(void)
 {
 	spin_lock(&xs_state_lock);
@@ -112,6 +131,10 @@ static void xs_suspend_exit(void)
 	wake_up_all(&xs_state_enter_wq);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|233| <<xs_send>> req->msg.req_id = xs_request_enter(req);
+ */
 static uint32_t xs_request_enter(struct xb_req_data *req)
 {
 	uint32_t rq_id;
@@ -136,6 +159,11 @@ static uint32_t xs_request_enter(struct xb_req_data *req)
 	return rq_id;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_dev_frontend.c|355| <<xenbus_dev_queue_reply>> xs_request_exit(req);
+ *   - drivers/xen/xenbus/xenbus_xs.c|258| <<xs_wait_for_reply>> xs_request_exit(req);
+ */
 void xs_request_exit(struct xb_req_data *req)
 {
 	spin_lock(&xs_state_lock);
@@ -153,6 +181,24 @@ static int get_error(const char *errorstring)
 {
 	unsigned int i;
 
+	/*
+	 * static struct xsd_errors xsd_errors[] __attribute__((unused)) = {
+	 *	XSD_ERROR(EINVAL),
+	 *	XSD_ERROR(EACCES),
+	 *	XSD_ERROR(EEXIST),
+	 *	XSD_ERROR(EISDIR),
+	 *	XSD_ERROR(ENOENT),
+	 *	XSD_ERROR(ENOMEM),
+	 *	XSD_ERROR(ENOSPC),
+	 *	XSD_ERROR(EIO),
+	 *	XSD_ERROR(ENOTEMPTY),
+	 *	XSD_ERROR(ENOSYS),
+	 *	XSD_ERROR(EROFS),
+	 *	XSD_ERROR(EBUSY),
+	 *	XSD_ERROR(EAGAIN),
+	 *	XSD_ERROR(EISCONN)
+	 * };
+	 */
 	for (i = 0; strcmp(errorstring, xsd_errors[i].errstring) != 0; i++) {
 		if (i == ARRAY_SIZE(xsd_errors) - 1) {
 			pr_warn("xen store gave: unknown error %s\n",
@@ -198,9 +244,45 @@ static bool test_reply(struct xb_req_data *req)
 	return false;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|336| <<xs_wait_for_reply>> ret = read_reply(req);
+ */
 static void *read_reply(struct xb_req_data *req)
 {
+	/*
+	 * xenbus_thread的race:
+	 * 557  out_err:
+	 * 558         state.req->msg.type = XS_ERROR;
+	 * 559         state.req->err = err;
+	 * 560         list_del(&state.req->list);
+	 * 567         if (state.req->state == xb_req_state_aborted)
+	 * 568                 kfree(state.req);
+	 * 569         else {
+	 * 570                 state.req->state = xb_req_state_got_reply;
+	 * 571                 wake_up(&state.req->wq);
+	 * 572         }
+	 * 573
+	 * 574         mutex_unlock(&xb_write_mutex);
+	 * 575
+	 * 576         state.req = NULL;
+	 */
+	/*
+	 * 在以下使用xb_req_state_got_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|362| <<process_msg>> req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|480| <<process_writes>> state.req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|220| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok())
+	 *   - drivers/xen/xenbus/xenbus_xs.c|231| <<read_reply>> while (req->state != xb_req_state_got_reply) {
+	 */
 	while (req->state != xb_req_state_got_reply) {
+		/*
+		 * 可能唤醒的地方:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|418| <<process_msg>> req->cb(req);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|538| <<process_writes>> wake_up(&state.req->wq);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|344| <<xs_wake_up>> wake_up(&req->wq);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|1101| <<xs_reboot_notify>> wake_up(&req->wq);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|1111| <<xs_reboot_notify>> wake_up(&req->wq);
+		 */
 		wait_event(req->wq, test_reply(req));
 
 		if (!xenbus_ok())
@@ -211,11 +293,30 @@ static void *read_reply(struct xb_req_data *req)
 			 * has been killed or is unreachable.
 			 */
 			return ERR_PTR(-EIO);
+		/*
+		 * struct xb_req_data {
+		 *	struct list_head list;
+		 *	wait_queue_head_t wq;
+		 *	struct xsd_sockmsg msg;
+		 *	uint32_t caller_req_id;
+		 *	enum xsd_sockmsg_type type;
+		 *	char *body;
+		 *	const struct kvec *vec;
+		 *	int num_vecs;
+		 *	int err;
+		 *	enum xb_req_state state;
+		 *	void (*cb)(struct xb_req_data *);
+		 *	void *par;
+		 * };
+		 */
 		if (req->err)
 			return ERR_PTR(req->err);
 
 	}
 
+	/*
+	 * xb_req_data->body是唯一可能发表
+	 */
 	return req->body;
 }
 
@@ -223,6 +324,14 @@ static void xs_send(struct xb_req_data *req, struct xsd_sockmsg *msg)
 {
 	bool notify;
 
+	/*
+	 * 如果是xenbus_transaction_start()来的:
+	 * struct xsd_sockmsg
+	 *  -> type = XS_TRANSACTION_START
+	 *  -> req_id = 0
+	 *  -> tx_id = XBT_NIL.id
+	 *  -> len = 1
+	 */
 	req->msg = *msg;
 	req->err = 0;
 	req->state = xb_req_state_queued;
@@ -233,18 +342,38 @@ static void xs_send(struct xb_req_data *req, struct xsd_sockmsg *msg)
 	req->msg.req_id = xs_request_enter(req);
 
 	mutex_lock(&xb_write_mutex);
+	/*
+	 * 使用xb_write_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+	 *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+	 */
 	list_add_tail(&req->list, &xb_write_list);
 	notify = list_is_singular(&xb_write_list);
 	mutex_unlock(&xb_write_mutex);
 
+	/*
+	 * 唤醒xenbus_thread()
+	 */
 	if (notify)
 		wake_up(&xb_waitq);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|465| <<xs_talkv>> ret = xs_wait_for_reply(req, &msg);
+ */
 static void *xs_wait_for_reply(struct xb_req_data *req, struct xsd_sockmsg *msg)
 {
 	void *ret;
 
+	/*
+	 * 似乎下面的ret都依赖于这里!!!!!
+	 *
+	 * 关键是这里到底是不是NULL!!!!
+	 */
 	ret = read_reply(req);
 
 	xs_request_exit(req);
@@ -263,6 +392,10 @@ static void *xs_wait_for_reply(struct xb_req_data *req, struct xsd_sockmsg *msg)
 	return ret;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|418| <<process_msg>> req->cb(req);
+ */
 static void xs_wake_up(struct xb_req_data *req)
 {
 	wake_up(&req->wq);
@@ -293,13 +426,54 @@ int xenbus_dev_request_and_reply(struct xsd_sockmsg *msg, void *par)
 EXPORT_SYMBOL(xenbus_dev_request_and_reply);
 
 /* Send message to xs, get kmalloc'ed reply.  ERR_PTR() on error. */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|412| <<xs_single>> return xs_talkv(t, type, &iovec, 1, len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|543| <<xenbus_write>> ret = xs_error(xs_talkv(t, XS_WRITE, iovec, ARRAY_SIZE(iovec), NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|715| <<xs_watch>> return xs_error(xs_talkv(XBT_NIL, XS_WATCH, iov,
+ *   - drivers/xen/xenbus/xenbus_xs.c|728| <<xs_unwatch>> return xs_error(xs_talkv(XBT_NIL, XS_UNWATCH, iov,
+ *
+ * 如果是xenbus_transaction_start()来的:
+ * t     -> XBT_NIL
+ * type  -> XS_TRANSACTION_START
+ * iovec -> {"", strlen("")+1}
+ * 1     -> 1
+ * len   -> NULL
+ */
 static void *xs_talkv(struct xenbus_transaction t,
 		      enum xsd_sockmsg_type type,
 		      const struct kvec *iovec,
 		      unsigned int num_vecs,
 		      unsigned int *len)
 {
+	/*
+	 * 很复杂, 不是ring buffer的格式
+	 * struct xb_req_data {
+	 *	struct list_head list;
+	 *	wait_queue_head_t wq;
+	 *	struct xsd_sockmsg msg;
+	 *	uint32_t caller_req_id;
+	 *	enum xsd_sockmsg_type type;
+	 *	char *body;
+	 *	const struct kvec *vec;
+	 *	int num_vecs;
+	 *	int err;
+	 *	enum xb_req_state state;
+	 *	void (*cb)(struct xb_req_data *);
+	 *	void *par;
+	 * };
+	 */
 	struct xb_req_data *req;
+	/*
+	 * struct xsd_sockmsg
+	 * {
+	 *	uint32_t type;  // XS_???
+	 *	uint32_t req_id;// Request identifier, echoed in daemon's response.
+	 *	uint32_t tx_id; // Transaction id (0 if not related to a transaction).
+	 *	uint32_t len;   // Length of data following this.
+	 *	// Generally followed by nul-terminated string(s).
+	 * };
+	 */
 	struct xsd_sockmsg msg;
 	void *ret = NULL;
 	unsigned int i;
@@ -311,6 +485,10 @@ static void *xs_talkv(struct xenbus_transaction t,
 
 	req->vec = iovec;
 	req->num_vecs = num_vecs;
+	/*
+	 * called by:
+	 *    drivers/xen/xenbus/xenbus_comms.c|418| <<process_msg>> req->cb(req);
+	 */
 	req->cb = xs_wake_up;
 
 	msg.req_id = 0;
@@ -319,9 +497,20 @@ static void *xs_talkv(struct xenbus_transaction t,
 	msg.len = 0;
 	for (i = 0; i < num_vecs; i++)
 		msg.len += iovec[i].iov_len;
+	/*
+	 * 如果是xenbus_transaction_start()来的:
+	 * struct xsd_sockmsg
+	 *  -> type = XS_TRANSACTION_START
+	 *  -> req_id = 0
+	 *  -> tx_id = XBT_NIL.id
+	 *  -> len = 1
+	 */
 
 	xs_send(req, &msg);
 
+	/*
+	 * 似乎下面的ret都依赖于这里!!!!!
+	 */
 	ret = xs_wait_for_reply(req, &msg);
 	if (len)
 		*len = msg.len;
@@ -345,15 +534,50 @@ static void *xs_talkv(struct xenbus_transaction t,
 }
 
 /* Simplified version of xs_talkv: single message. */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|480| <<xenbus_directory>> strings = xs_single(t, XS_DIRECTORY, path, &len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|518| <<xenbus_read>> ret = xs_single(t, XS_READ, path, len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|560| <<xenbus_mkdir>> ret = xs_error(xs_single(t, XS_MKDIR, path, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|576| <<xenbus_rm>> ret = xs_error(xs_single(t, XS_RM, path, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|589| <<xenbus_transaction_start>> id_str = xs_single(XBT_NIL, XS_TRANSACTION_START, "", NULL);
+ *   - drivers/xen/xenbus/xenbus_xs.c|611| <<xenbus_transaction_end>> return xs_error(xs_single(t, XS_TRANSACTION_END, abortstr, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|802| <<xs_reset_watches>> err = xs_error(xs_single(XBT_NIL, XS_RESET_WATCHES, "", NULL));
+ *
+ * xs_single()直接返回xs_talkv()的结果()
+ */
 static void *xs_single(struct xenbus_transaction t,
 		       enum xsd_sockmsg_type type,
 		       const char *string,
 		       unsigned int *len)
 {
+	/*
+	 * struct kvec {
+	 *	void *iov_base; // and that should *never* hold a userland pointer
+	 *	size_t iov_len;
+	 * };
+	 */
 	struct kvec iovec;
 
+	/*
+	 * 如果是xenbus_transaction_start()进来的:
+	 * t      -> XBT_NIL
+	 * type   -> XS_TRANSACTION_START
+	 * string -> ""
+	 * len    -> NULL
+	 */
 	iovec.iov_base = (void *)string;
 	iovec.iov_len = strlen(string) + 1;
+	/*
+	 * 如果是xenbus_transaction_start()来的:
+	 * t     -> XBT_NIL
+	 * type  -> XS_TRANSACTION_START
+	 * iovec -> {"", strlen("")+1}
+	 * 1     -> 1
+	 * len   -> NULL
+	 *
+	 * 如果xs_single()返回NULL, 肯定是这里返回NULL!!!
+	 */
 	return xs_talkv(t, type, &iovec, 1, len);
 }
 
@@ -527,10 +751,33 @@ EXPORT_SYMBOL_GPL(xenbus_rm);
 /* Start a transaction: changes by others will not be seen during this
  * transaction, and changes will not be visible to others until end.
  */
+/*
+ * 在以下调用xenbus_transaction_start():
+ *   - drivers/block/xen-blkback/blkback.c|568| <<xen_vbd_resize>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/block/xen-blkback/xenbus.c|603| <<xen_emit_oracle_phys_device>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/block/xen-blkback/xenbus.c|993| <<connect>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/block/xen-blkfront.c|1830| <<talk_to_blkback>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/char/tpm/xen-tpmfront.c|223| <<setup_ring>> rv = xenbus_transaction_start(&xbt);
+ *   - drivers/input/misc/xen-kbdfront.c|269| <<xenkbd_connect_backend>> ret = xenbus_transaction_start(&xbt);
+ *   - drivers/net/xen-netback/xenbus.c|283| <<netback_probe>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/net/xen-netfront.c|2405| <<talk_to_netback>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/pci/xen-pcifront.c|805| <<pcifront_publish_info>> err = xenbus_transaction_start(&trans);
+ *   - drivers/scsi/xen-scsifront.c|772| <<scsifront_init_ring>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/tty/hvc/hvc_xen.c|403| <<xencons_connect_backend>> ret = xenbus_transaction_start(&xbt);
+ *   - drivers/video/fbdev/xen-fbfront.c|593| <<xenfb_connect_backend>> ret = xenbus_transaction_start(&xbt);
+ *   - drivers/xen/manage.c|229| <<shutdown_handler>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/xen/manage.c|274| <<sysrq_handler>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/xen/xen-pciback/pci_stub.c|672| <<kill_domain_by_device>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/xen/xen-pciback/pci_stub.c|695| <<kill_domain_by_device>> err = xenbus_transaction_start(&xbt);
+ *   - drivers/xen/xenbus/xenbus_client.c|210| <<__xenbus_switch_state>> err = xenbus_transaction_start(&xbt);
+ */
 int xenbus_transaction_start(struct xenbus_transaction *t)
 {
 	char *id_str;
 
+	/*
+	 * 关于id_str是否为NULL, 核心在read_reply()的返回值!!
+	 */
 	id_str = xs_single(XBT_NIL, XS_TRANSACTION_START, "", NULL);
 	if (IS_ERR(id_str))
 		return PTR_ERR(id_str);
@@ -910,8 +1157,22 @@ static int xs_reboot_notify(struct notifier_block *nb,
 	struct xb_req_data *req;
 
 	mutex_lock(&xb_write_mutex);
+	/*
+	 * 使用xs_reply_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|308| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+	 *   - drivers/xen/xenbus/xenbus_comms.c|404| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|950| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+	 */
 	list_for_each_entry(req, &xs_reply_list, list)
 		wake_up(&req->wq);
+	/*
+	 * 使用xb_write_list的地方:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|104| <<xb_data_to_write>> !list_empty(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|354| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+	 *   - drivers/xen/xenbus/xenbus_xs.c|236| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|237| <<xs_send>> notify = list_is_singular(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|915| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+	 */
 	list_for_each_entry(req, &xb_write_list, list)
 		wake_up(&req->wq);
 	mutex_unlock(&xb_write_mutex);
diff --git a/net/bridge/br_forward.c b/net/bridge/br_forward.c
index 0ff6e1bbca91..5328c0097dda 100644
--- a/net/bridge/br_forward.c
+++ b/net/bridge/br_forward.c
@@ -27,6 +27,12 @@ static int deliver_clone(const struct net_bridge_port *prev,
 					       struct sk_buff *skb));
 
 /* Don't forward packets to originating port or forwarding disabled */
+/*
+ * called by:
+ *   - net/bridge/br_forward.c|110| <<br_deliver>> if (to && should_deliver(to, skb)) {
+ *   - net/bridge/br_forward.c|122| <<br_forward>> if (should_deliver(to, skb)) {
+ *   - net/bridge/br_forward.c|159| <<maybe_deliver>> if (!should_deliver(p, skb))
+ */
 static inline int should_deliver(const struct net_bridge_port *p,
 				 const struct sk_buff *skb)
 {
diff --git a/net/bridge/br_stp.c b/net/bridge/br_stp.c
index fb3ebe615513..4c0021057d6b 100644
--- a/net/bridge/br_stp.c
+++ b/net/bridge/br_stp.c
@@ -408,6 +408,62 @@ static void br_make_blocking(struct net_bridge_port *p)
 }
 
 /* called under bridge lock */
+/*
+ * [0] br_make_forwarding
+ * [0] br_stp_enable_port
+ * [0] br_device_event
+ * [0] notifier_call_chain
+ * [0] raw_notifier_call_chain
+ * [0] call_netdevice_notifiers_info
+ * [0] __dev_notify_flags
+ * [0] dev_change_flags
+ * [0] do_setlink
+ * [0] rtnl_newlink
+ * [0] rtnetlink_rcv_msg
+ * [0] netlink_rcv_skb
+ * [0] rtnetlink_rcv
+ * [0] netlink_unicast
+ * [0] netlink_sendmsg
+ * [0] sock_sendmsg
+ * [0] ___sys_sendmsg
+ * [0] __sys_sendmsg
+ * [0] SyS_sendmsg
+ * [0] system_call_fastpath
+ *
+ * [0] br_make_forwarding
+ * [0] br_stp_disable_port
+ * [0] br_device_event
+ * [0] notifier_call_chain
+ * [0] raw_notifier_call_chain
+ * [0] call_netdevice_notifiers_info
+ * [0] dev_close_many
+ * [0] rollback_registered_many
+ * [0] rollback_registered
+ * [0] unregister_netdevice_queue
+ * [0] __tun_detach
+ * [0] tun_chr_close
+ * [0] __fput
+ * [0] ____fput
+ * [0] task_work_run
+ * [0] do_notify_resume
+ * [0] int_signal
+ *
+ * [0] br_make_forwarding
+ * [0] br_stp_enable_port
+ * [0] br_port_carrier_check
+ * [0] br_device_event
+ * [0] notifier_call_chain
+ * [0] raw_notifier_call_chain
+ * [0] call_netdevice_notifiers_info
+ * [0] netdev_state_change
+ * [0] linkwatch_do_dev
+ * [0] __linkwatch_run_queue
+ * [0] linkwatch_event
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ */
 static void br_make_forwarding(struct net_bridge_port *p)
 {
 	struct net_bridge *br = p->br;
@@ -433,6 +489,19 @@ static void br_make_forwarding(struct net_bridge_port *p)
 }
 
 /* called under bridge lock */
+/*
+ * called by:
+ *   - net/bridge/br_netlink.c|532| <<br_set_port_state>> br_port_state_selection(p->br);
+ *   - net/bridge/br_stp.c|491| <<br_received_config_bpdu>> br_port_state_selection(br);
+ *   - net/bridge/br_stp_if.c|90| <<br_stp_enable_port>> br_port_state_selection(p->br);
+ *   - net/bridge/br_stp_if.c|119| <<br_stp_disable_port>> br_port_state_selection(br);
+ *   - net/bridge/br_stp_if.c|151| <<br_stp_start>> br_port_state_selection(br);
+ *   - net/bridge/br_stp_if.c|169| <<br_stp_stop>> br_port_state_selection(br);
+ *   - net/bridge/br_stp_if.c|215| <<br_stp_change_bridge_id>> br_port_state_selection(br);
+ *   - net/bridge/br_stp_if.c|270| <<br_stp_set_bridge_priority>> br_port_state_selection(br);
+ *   - net/bridge/br_stp_if.c|293| <<br_stp_set_port_priority>> br_port_state_selection(p->br);
+ *   - net/bridge/br_stp_if.c|309| <<br_stp_set_path_cost>> br_port_state_selection(p->br);
+ */
 void br_port_state_selection(struct net_bridge *br)
 {
 	struct net_bridge_port *p;
diff --git a/net/bridge/br_stp_if.c b/net/bridge/br_stp_if.c
index ce658abdc2c8..eb9988336244 100644
--- a/net/bridge/br_stp_if.c
+++ b/net/bridge/br_stp_if.c
@@ -84,6 +84,13 @@ void br_stp_disable_bridge(struct net_bridge *br)
 }
 
 /* called under bridge lock */
+/*
+ * called by:
+ *   - net/bridge/br.c|87| <<br_device_event>> br_stp_enable_port(p);
+ *   - net/bridge/br_if.c|80| <<br_port_carrier_check>> br_stp_enable_port(p);
+ *   - net/bridge/br_if.c|518| <<br_add_if>> br_stp_enable_port(p);
+ *   - net/bridge/br_stp_if.c|58| <<br_stp_enable_bridge>> br_stp_enable_port(p);
+ */
 void br_stp_enable_port(struct net_bridge_port *p)
 {
 	br_init_port(p);
@@ -173,6 +180,10 @@ static void br_stp_stop(struct net_bridge *br)
 	br->stp_enabled = BR_NO_STP;
 }
 
+/*
+ * called by:
+ *   - net/bridge/br_stp_if.c|125| <<br_stp_start>> static void br_stp_start(struct net_bridge *br)
+ */
 void br_stp_set_enabled(struct net_bridge *br, unsigned long val)
 {
 	ASSERT_RTNL();
-- 
2.17.1

