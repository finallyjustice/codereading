From 63d3ab2cdcf14bd7ba7fd60f9b9450cd3106d3db Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 11 Jun 2025 12:31:09 -0700
Subject: [PATCH 1/1] linux v5.15.0-300.163.18.7

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/include/asm/kvm_host.h    |  84 +++
 arch/x86/include/asm/smp.h         |  10 +
 arch/x86/kernel/kvm.c              |  31 ++
 arch/x86/kvm/i8254.c               |   7 +
 arch/x86/kvm/ioapic.c              | 468 ++++++++++++++++
 arch/x86/kvm/ioapic.h              |  37 ++
 arch/x86/kvm/irq.c                 |  74 +++
 arch/x86/kvm/irq.h                 |  13 +
 arch/x86/kvm/irq_comm.c            | 180 ++++++
 arch/x86/kvm/lapic.c               | 853 +++++++++++++++++++++++++++++
 arch/x86/kvm/lapic.h               |  89 +++
 arch/x86/kvm/svm/avic.c            |  20 +
 arch/x86/kvm/vmx/posted_intr.c     |  21 +
 arch/x86/kvm/vmx/vmx.c             | 126 +++++
 arch/x86/kvm/vmx/vmx.h             |  15 +
 arch/x86/kvm/x86.c                 | 415 ++++++++++++++
 arch/x86/kvm/x86.h                 |   5 +
 drivers/acpi/bus.c                 |   5 +
 drivers/acpi/device_pm.c           |  45 ++
 drivers/acpi/dock.c                |  11 +
 drivers/acpi/osl.c                 |  16 +
 drivers/acpi/scan.c                | 130 +++++
 drivers/acpi/utils.c               |  16 +
 drivers/pci/hotplug/acpiphp_glue.c |  69 +++
 drivers/pci/iov.c                  |   5 +
 drivers/pci/probe.c                |  94 ++++
 drivers/pci/search.c               |   4 +
 include/acpi/acpi_bus.h            |  15 +
 include/linux/kvm_host.h           |  54 ++
 virt/kvm/eventfd.c                 |  91 +++
 virt/kvm/irqchip.c                 | 274 +++++++++
 virt/kvm/kvm_main.c                |  37 ++
 virt/lib/irqbypass.c               |  27 +
 33 files changed, 3341 insertions(+)

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 91560b1abc54..269e6857cb94 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -635,7 +635,24 @@ struct kvm_vcpu_arch {
 	u64 apic_base;
 	struct kvm_lapic *apic;    /* kernel irqchip context */
 	bool apicv_active;
+	/*
+	 * 在以下使用kvm_vcpu_arch->load_eoi_exitmap_pending:
+	 *   - arch/x86/kvm/kvm_cache_regs.h|184| <<leave_guest_mode>> if (vcpu->arch.load_eoi_exitmap_pending) {
+	 *   - arch/x86/kvm/kvm_cache_regs.h|185| <<leave_guest_mode>> vcpu->arch.load_eoi_exitmap_pending = false;
+	 *   - arch/x86/kvm/x86.c|10048| <<vcpu_scan_ioapic>> vcpu->arch.load_eoi_exitmap_pending = true;
+	 */
 	bool load_eoi_exitmap_pending;
+	/*
+	 * 在以下使用ioapic_handled_vectors:
+	 *   - arch/x86/kvm/lapic.c|1614| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10020| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+	 *   - arch/x86/kvm/x86.c|10025| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10027| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10044| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap,
+	 *              vcpu->arch.ioapic_handled_vectors, to_hv_synic(vcpu)->vec_bitmap, 256);
+	 *   - arch/x86/kvm/x86.c|10051| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10193| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+	 */
 	DECLARE_BITMAP(ioapic_handled_vectors, 256);
 	unsigned long apic_attention;
 	int32_t apic_arb_prio;
@@ -762,7 +779,24 @@ struct kvm_vcpu_arch {
 
 	u64 l1_tsc_offset;
 	u64 tsc_offset; /* current tsc offset */
+	/*
+	 * 在以下使用kvm_vcpu_arch->last_guest_tsc:
+	 *   - arch/x86/kvm/x86.c|2625| <<kvm_synchronize_tsc>> vcpu->arch.last_guest_tsc = data;
+	 *   - arch/x86/kvm/x86.c|3053| <<kvm_guest_time_update>> vcpu->last_guest_tsc = tsc_timestamp;
+	 *   - arch/x86/kvm/x86.c|4535| <<kvm_arch_vcpu_load>> u64 offset = kvm_compute_l1_tsc_offset(vcpu, vcpu->arch.last_guest_tsc);
+	 *   - arch/x86/kvm/x86.c|10223| <<vcpu_enter_guest>> vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());
+	 */
 	u64 last_guest_tsc;
+	/*
+	 * 在以下使用kvm_vcpu_arch->last_host_tsc:
+	 *   - arch/x86/kvm/x86.c|4528| <<kvm_arch_vcpu_load>> s64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :
+	 *   - arch/x86/kvm/x86.c|4529| <<kvm_arch_vcpu_load>> rdtsc() - vcpu->arch.last_host_tsc;
+	 *   - arch/x86/kvm/x86.c|4625| <<kvm_arch_vcpu_put>> vcpu->arch.last_host_tsc = rdtsc();
+	 *   - arch/x86/kvm/x86.c|11541| <<kvm_arch_hardware_enable>> if (stable && vcpu->arch.last_host_tsc > local_tsc) {
+	 *   - arch/x86/kvm/x86.c|11543| <<kvm_arch_hardware_enable>> if (vcpu->arch.last_host_tsc > max_tsc)
+	 *   - arch/x86/kvm/x86.c|11544| <<kvm_arch_hardware_enable>> max_tsc = vcpu->arch.last_host_tsc;
+	 *   - arch/x86/kvm/x86.c|11593| <<kvm_arch_hardware_enable>> vcpu->arch.last_host_tsc = local_tsc;
+	 */
 	u64 last_host_tsc;
 	u64 tsc_offset_adjustment;
 	u64 this_tsc_nsec;
@@ -875,7 +909,23 @@ struct kvm_vcpu_arch {
 		bool pv_unhalted;
 	} pv;
 
+	/*
+	 * 在以下使用kvm_vcpu_arch->pending_ioapic_eoi:
+	 *   - arch/x86/kvm/lapic.c|1653| <<kvm_ioapic_send_eoi>> apic->vcpu->arch.pending_ioapic_eoi = vector;
+	 *   - arch/x86/kvm/x86.c|10224| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> BUG_ON(vcpu->arch.pending_ioapic_eoi > 255);
+	 *   - arch/x86/kvm/x86.c|10236| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> if (test_bit(vcpu->arch.pending_ioapic_eoi,
+	 *   - arch/x86/kvm/x86.c|10240| <<vcpu_enter_guest(KVM_REQ_IOAPIC_EOI_EXIT)>> vcpu->arch.pending_ioapic_eoi;
+	 */
 	int pending_ioapic_eoi;
+	/*
+	 * 在以下使用kvm_vcpu_arch->pending_external_vector:
+	 *   - arch/x86/kvm/irq.c|42| <<pending_userspace_extint>> return v->arch.pending_external_vector != -1;
+	 *   - arch/x86/kvm/irq.c|135| <<kvm_cpu_get_extint>> int vector = v->arch.pending_external_vector;
+	 *   - arch/x86/kvm/irq.c|137| <<kvm_cpu_get_extint>> v->arch.pending_external_vector = -1;
+	 *   - arch/x86/kvm/x86.c|4750| <<kvm_vcpu_ioctl_interrupt>> if (vcpu->arch.pending_external_vector != -1)
+	 *   - arch/x86/kvm/x86.c|4753| <<kvm_vcpu_ioctl_interrupt>> vcpu->arch.pending_external_vector = irq->irq;
+	 *   - arch/x86/kvm/x86.c|11459| <<kvm_arch_vcpu_create>> vcpu->arch.pending_external_vector = -1;
+	 */
 	int pending_external_vector;
 
 	/* be preempted when it's in kernel-mode(cpl=0) */
@@ -1152,10 +1202,22 @@ struct kvm_arch {
 	gpa_t wall_clock;
 
 	bool mwait_in_guest;
+	/*
+	 * 在以下使用kvm_arch->hlt_in_guest:
+	 *   - arch/x86/kvm/x86.c|5835| <<kvm_vm_ioctl_enable_cap>> kvm->arch.hlt_in_guest = true;
+	 *   - arch/x86/kvm/x86.h|379| <<kvm_hlt_in_guest>> return kvm->arch.hlt_in_guest;
+	 */
 	bool hlt_in_guest;
 	bool pause_in_guest;
 	bool cstate_in_guest;
 
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|209| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|241| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|12081| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|12084| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	unsigned long irq_sources_bitmap;
 	s64 kvmclock_offset;
 	raw_spinlock_t tsc_write_lock;
@@ -1177,6 +1239,12 @@ struct kvm_arch {
 
 	struct kvm_xen_hvm_config xen_hvm_config;
 
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|278| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|12073| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	/* reads protected by irq_srcu, writes by irq_lock */
 	struct hlist_head mask_notifier_list;
 
@@ -1195,6 +1263,13 @@ struct kvm_arch {
 	int cpu_dirty_logging_count;
 
 	enum kvm_irqchip_mode irqchip_mode;
+	/*
+	 * 在以下使用kvm_arch->nr_reserved_ioapic_pins:
+	 *   - arch/x86/kvm/irq_comm.c|446| <<kvm_scan_ioapic_routes>> nr_ioapic_pins =
+	 *               min_t(u32, table->nr_rt_entries, kvm->arch.nr_reserved_ioapic_pins);
+	 *   - arch/x86/kvm/x86.c|5874| <<kvm_vm_ioctl_enable_cap(KVM_CAP_SPLIT_IRQCHIP)>>
+	 *               kvm->arch.nr_reserved_ioapic_pins = cap->args[0];
+	 */
 	u8 nr_reserved_ioapic_pins;
 
 	bool disabled_lapic_found;
@@ -1363,6 +1438,15 @@ struct kvm_lapic_irq {
 	bool msi_redir_hint;
 };
 
+/*
+ * 在以下使用kvm_lapic_irq_dest_mode():
+ *   - arch/x86/kvm/ioapic.c|130| <<__rtc_irq_eoi_tracking_restore_one>> kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+ *   - arch/x86/kvm/ioapic.c|367| <<kvm_ioapic_scan_entry>> u16 dm = kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);
+ *   - arch/x86/kvm/ioapic.c|465| <<ioapic_write_indirect>> kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);
+ *   - arch/x86/kvm/ioapic.c|483| <<ioapic_write_indirect>> kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);
+ *   - arch/x86/kvm/ioapic.c|540| <<ioapic_service>> irqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);
+ *   - arch/x86/kvm/irq_comm.c|138| <<kvm_set_msi_irq>> irq->dest_mode = kvm_lapic_irq_dest_mode(msg.arch_addr_lo.dest_mode_logical);
+ */
 static inline u16 kvm_lapic_irq_dest_mode(bool dest_mode_logical)
 {
 	return dest_mode_logical ? APIC_DEST_LOGICAL : APIC_DEST_PHYSICAL;
diff --git a/arch/x86/include/asm/smp.h b/arch/x86/include/asm/smp.h
index 630ff08532be..0050421ff8ff 100644
--- a/arch/x86/include/asm/smp.h
+++ b/arch/x86/include/asm/smp.h
@@ -102,6 +102,16 @@ static inline void play_dead(void)
 	smp_ops.play_dead();
 }
 
+/*
+ * 在以下调用x86的smp_send_reschedule():
+ *   - arch/x86/kvm/svm/svm.c|4112| <<svm_vcpu_run>> smp_send_reschedule(vcpu->cpu);
+ *   - arch/x86/kvm/x86.c|9972| <<__kvm_request_immediate_exit>> smp_send_reschedule(vcpu->cpu);
+ *   - kernel/sched/core.c|981| <<resched_curr>> smp_send_reschedule(cpu);
+ *   - kernel/sched/core.c|1060| <<wake_up_idle_cpu>> smp_send_reschedule(cpu);
+ *   - kernel/sched/core.c|3326| <<kick_process>> smp_send_reschedule(cpu);
+ *   - kernel/sched/core.c|3736| <<wake_up_if_idle>> smp_send_reschedule(cpu);
+ *   - virt/kvm/kvm_main.c|3458| <<kvm_vcpu_kick>> smp_send_reschedule(cpu);
+ */
 static inline void smp_send_reschedule(int cpu)
 {
 	smp_ops.smp_send_reschedule(cpu);
diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c
index de0a76157a4c..93cbec3296c3 100644
--- a/arch/x86/kernel/kvm.c
+++ b/arch/x86/kernel/kvm.c
@@ -492,6 +492,11 @@ static bool pv_sched_yield_supported(void)
 
 #define KVM_IPI_CLUSTER_SIZE	(2 * BITS_PER_LONG)
 
+/*
+ * 在以下调用__send_ipi_mask():
+ *   - arch/x86/kernel/kvm.c|553| <<kvm_send_ipi_mask>> __send_ipi_mask(mask, vector);
+ *   - arch/x86/kernel/kvm.c|565| <<kvm_send_ipi_mask_allbutself>> __send_ipi_mask(local_mask, vector);
+ */
 static void __send_ipi_mask(const struct cpumask *mask, int vector)
 {
 	unsigned long flags;
@@ -548,11 +553,32 @@ static void __send_ipi_mask(const struct cpumask *mask, int vector)
 	local_irq_restore(flags);
 }
 
+/*
+ * 576 static void kvm_setup_pv_ipi(void)
+ * 577 {
+ * 578         apic->send_IPI_mask = kvm_send_ipi_mask;
+ * 579         apic->send_IPI_mask_allbutself = kvm_send_ipi_mask_allbutself;
+ * 580         pr_info("setup PV IPIs\n");
+ * 581 }
+ */
 static void kvm_send_ipi_mask(const struct cpumask *mask, int vector)
 {
+	/*
+	 * 在以下调用__send_ipi_mask():
+	 *   - arch/x86/kernel/kvm.c|553| <<kvm_send_ipi_mask>> __send_ipi_mask(mask, vector);
+	 *   - arch/x86/kernel/kvm.c|565| <<kvm_send_ipi_mask_allbutself>> __send_ipi_mask(local_mask, vector);
+	 */
 	__send_ipi_mask(mask, vector);
 }
 
+/*
+ * 576 static void kvm_setup_pv_ipi(void)
+ * 577 {
+ * 578         apic->send_IPI_mask = kvm_send_ipi_mask;
+ * 579         apic->send_IPI_mask_allbutself = kvm_send_ipi_mask_allbutself;
+ * 580         pr_info("setup PV IPIs\n");
+ * 581 }
+ */
 static void kvm_send_ipi_mask_allbutself(const struct cpumask *mask, int vector)
 {
 	unsigned int this_cpu = smp_processor_id();
@@ -562,6 +588,11 @@ static void kvm_send_ipi_mask_allbutself(const struct cpumask *mask, int vector)
 	cpumask_copy(new_mask, mask);
 	cpumask_clear_cpu(this_cpu, new_mask);
 	local_mask = new_mask;
+	/*
+	 * 在以下调用__send_ipi_mask():
+	 *   - arch/x86/kernel/kvm.c|553| <<kvm_send_ipi_mask>> __send_ipi_mask(mask, vector);
+	 *   - arch/x86/kernel/kvm.c|565| <<kvm_send_ipi_mask_allbutself>> __send_ipi_mask(local_mask, vector);
+	 */
 	__send_ipi_mask(local_mask, vector);
 }
 
diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c
index 043dd4af1848..647fbf89e470 100644
--- a/arch/x86/kvm/i8254.c
+++ b/arch/x86/kvm/i8254.c
@@ -288,6 +288,13 @@ static inline void kvm_pit_reset_reinject(struct kvm_pit *pit)
 	atomic_set(&pit->pit_state.irq_ack, 1);
 }
 
+/*
+ * 在以下使用kvm_pit_set_reinject():
+ *   - arch/x86/kvm/i8254.c|701| <<kvm_create_pit>> kvm_pit_set_reinject(pit, true);
+ *   - arch/x86/kvm/i8254.c|726| <<kvm_create_pit>> kvm_pit_set_reinject(pit, false);
+ *   - arch/x86/kvm/i8254.c|744| <<kvm_free_pit>> kvm_pit_set_reinject(pit, false);
+ *   - arch/x86/kvm/x86.c|5807| <<kvm_vm_ioctl_reinject>> kvm_pit_set_reinject(pit, control->pit_reinject);
+ */
 void kvm_pit_set_reinject(struct kvm_pit *pit, bool reinject)
 {
 	struct kvm_kpit_state *ps = &pit->pit_state;
diff --git a/arch/x86/kvm/ioapic.c b/arch/x86/kvm/ioapic.c
index 4e0f52660842..f6b30eee0174 100644
--- a/arch/x86/kvm/ioapic.c
+++ b/arch/x86/kvm/ioapic.c
@@ -54,6 +54,10 @@ static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,
 				      int trigger_mode,
 				      int pin);
 
+/*
+ * 在以下使用ioapic_read_indirect():
+ *   - arch/x86/kvm/ioapic.c|664| <<ioapic_mmio_read>> result = ioapic_read_indirect(ioapic, addr, len);
+ */
 static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,
 					  unsigned long addr,
 					  unsigned long length)
@@ -76,13 +80,33 @@ static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,
 			u32 redir_index = (ioapic->ioregsel - 0x10) >> 1;
 			u64 redir_content = ~0ULL;
 
+			/*
+			 * 最多24个
+			 */
 			if (redir_index < IOAPIC_NUM_PINS) {
 				u32 index = array_index_nospec(
 					redir_index, IOAPIC_NUM_PINS);
 
+				/*
+				 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+				 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+				 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+				 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+				 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+				 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+				 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+				 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+				 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+				 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+				 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+				 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+				 */
 				redir_content = ioapic->redirtbl[index].bits;
 			}
 
+			/*
+			 * 是读高位还是低位?
+			 */
 			result = (ioapic->ioregsel & 0x1) ?
 			    (redir_content >> 32) & 0xffffffff :
 			    redir_content & 0xffffffff;
@@ -114,6 +138,20 @@ static void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)
 	struct dest_map *dest_map = &ioapic->rtc_status.dest_map;
 	union kvm_ioapic_redirect_entry *e;
 
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	e = &ioapic->redirtbl[RTC_GSI];
 	if (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,
 				 e->fields.dest_id,
@@ -146,6 +184,11 @@ void kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)
 	spin_unlock(&ioapic->lock);
 }
 
+/*
+ * 在以下使用kvm_rtc_eoi_tracking_restore_all():
+ *   - arch/x86/kvm/ioapic.c|131| <<rtc_status_pending_eoi_check_valid>> kvm_rtc_eoi_tracking_restore_all(ioapic);
+ *   - arch/x86/kvm/ioapic.c|358| <<kvm_ioapic_inject_all>> kvm_rtc_eoi_tracking_restore_all(ioapic);
+ */
 static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)
 {
 	struct kvm_vcpu *vcpu;
@@ -159,6 +202,11 @@ static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)
 	    __rtc_irq_eoi_tracking_restore_one(vcpu);
 }
 
+/*
+ * 在以下使用rtc_irq_eoi:
+ *   - arch/x86/kvm/ioapic.c|202| <<ioapic_lazy_update_eoi>> rtc_irq_eoi(ioapic, vcpu, entry->fields.vector);
+ *   - arch/x86/kvm/ioapic.c|606| <<kvm_ioapic_update_eoi>> rtc_irq_eoi(ioapic, vcpu, vector);
+ */
 static void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu,
 			int vector)
 {
@@ -182,10 +230,28 @@ static bool rtc_irq_check_coalesced(struct kvm_ioapic *ioapic)
 	return false;
 }
 
+/*
+ * 在以下使用ioapic_lazy_update_eoi():
+ *   - arch/x86/kvm/ioapic.c|231| <<ioapic_set_irq>> ioapic_lazy_update_eoi(ioapic, irq);
+ */
 static void ioapic_lazy_update_eoi(struct kvm_ioapic *ioapic, int irq)
 {
 	int i;
 	struct kvm_vcpu *vcpu;
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
 
 	kvm_for_each_vcpu(i, vcpu, ioapic->kvm) {
@@ -212,6 +278,20 @@ static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,
 	u32 old_irr;
 	int edge, ret;
 
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	entry = ioapic->redirtbl[irq];
 	edge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);
 
@@ -250,6 +330,14 @@ static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,
 	old_irr = ioapic->irr;
 	ioapic->irr |= mask;
 	if (edge) {
+		/*
+		 * 在以下使用kvm_ioapic->irr_delivered:
+		 *   - arch/x86/kvm/ioapic.c|253| <<ioapic_set_irq>> ioapic->irr_delivered &= ~mask;
+		 *   - arch/x86/kvm/ioapic.c|455| <<ioapic_service>> ioapic->irr_delivered |= 1 << irq;
+		 *   - arch/x86/kvm/ioapic.c|742| <<kvm_ioapic_reset>> ioapic->irr_delivered = 0;
+		 *   - arch/x86/kvm/ioapic.c|800| <<kvm_get_ioapic>> state->irr &= ~ioapic->irr_delivered;
+		 *   - arch/x86/kvm/ioapic.c|811| <<kvm_set_ioapic>> ioapic->irr_delivered = 0;
+		 */
 		ioapic->irr_delivered &= ~mask;
 		if (old_irr == ioapic->irr) {
 			ret = 0;
@@ -276,6 +364,21 @@ static void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)
 }
 
 
+/*
+ * 在以下使用ioapic_handled_vectors:
+ *   - arch/x86/kvm/lapic.c|1614| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+ *   - arch/x86/kvm/x86.c|10020| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+ *   - arch/x86/kvm/x86.c|10025| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+ *   - arch/x86/kvm/x86.c|10027| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+ *   - arch/x86/kvm/x86.c|10044| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap,
+ *              vcpu->arch.ioapic_handled_vectors, to_hv_synic(vcpu)->vec_bitmap, 256);
+ *   - arch/x86/kvm/x86.c|10051| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+ *   - arch/x86/kvm/x86.c|10193| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+ *
+ *
+ * called by:
+ *   - arch/x86/kvm/x86.c|9981| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+ */
 void kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)
 {
 	struct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;
@@ -285,18 +388,88 @@ void kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)
 
 	spin_lock(&ioapic->lock);
 
+	/*
+	 * struct dest_map {
+	 * map = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 * 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 * 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+	 *
+	 * 第一次设置的地方
+	 * 看着似乎rtc_statu的bit都是空
+	 */
 	/* Make sure we see any missing RTC EOI */
 	if (test_bit(vcpu->vcpu_id, dest_map->map))
 		__set_bit(dest_map->vectors[vcpu->vcpu_id],
 			  ioapic_handled_vectors);
 
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	for (index = 0; index < IOAPIC_NUM_PINS; index++) {
+		/*
+		 *  union kvm_ioapic_redirect_entry {
+                 *     bits = 144115188075888682,
+                 *     fields = {
+                 *       vector = 42 '*',
+		 *       delivery_mode = 0 '\000',
+		 *       dest_mode = 0 '\000',
+		 *       delivery_status = 0 '\000',
+		 *       polarity = 0 '\000',
+		 *       remote_irr = 0 '\000',
+		 *       trig_mode = 1 '\001',
+		 *       mask = 0 '\000',
+		 *       reserve = 0 '\000',
+		 *       reserved = "\000\000\000",
+		 *       dest_id = 2 '\002'
+		 *     }
+		 *  }
+		 *
+		 * 57 union kvm_ioapic_redirect_entry {
+		 * 58         u64 bits;
+		 * 59         struct {
+		 * 60                 u8 vector;
+		 * 61                 u8 delivery_mode:3;
+		 * 62                 u8 dest_mode:1;
+		 * 63                 u8 delivery_status:1;
+		 * 64                 u8 polarity:1;
+		 * 65                 u8 remote_irr:1;
+		 * 66                 u8 trig_mode:1;
+		 * 67                 u8 mask:1;
+		 * 68                 u8 reserve:7;
+		 * 69                 u8 reserved[4];
+		 * 70                 u8 dest_id;
+		 * 71         } fields;
+		 * 72 };
+		 */
 		e = &ioapic->redirtbl[index];
+		/*
+		 * 是或者:
+		 * - e->fields.trig_mode == IOAPIC_LEVEL_TRIG
+		 * - kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index)
+		 * - index == RTC_GSI
+		 */
 		if (e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||
 		    kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||
 		    index == RTC_GSI) {
+			/*
+			 * APIC_DEST_LOGICAL还是APIC_DEST_PHYSICAL
+			 */
 			u16 dm = kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);
 
+			/*
+			 * 第二次设置的地方
+			 */
 			if (kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,
 						e->fields.dest_id, dm) ||
 			    kvm_apic_pending_eoi(vcpu, e->fields.vector))
@@ -311,9 +484,21 @@ void kvm_arch_post_irq_ack_notifier_list_update(struct kvm *kvm)
 {
 	if (!ioapic_in_kernel(kvm))
 		return;
+	/*
+	 * 在以下使用kvm_make_scan_ioapic_request():
+	 *   - arch/x86/kvm/ioapic.c|345| <<kvm_arch_post_irq_ack_notifier_list_update>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/ioapic.c|442| <<ioapic_write_indirect>> kvm_make_scan_ioapic_request(ioapic->kvm);
+	 *   - arch/x86/kvm/ioapic.c|879| <<kvm_set_ioapic>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/irq_comm.c|408| <<kvm_arch_post_irq_routing_update>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/lapic.c|436| <<kvm_recalculate_apic_map>> kvm_make_scan_ioapic_request(kvm);
+	 */
 	kvm_make_scan_ioapic_request(kvm);
 }
 
+/*
+ * 在以下调用ioapic_write_indirect(), 处理IOAPIC_REG_WINDOW:
+ *   - arch/x86/kvm/ioapic.c|654| <<ioapic_mmio_write>> ioapic_write_indirect(ioapic, data);
+ */
 static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)
 {
 	unsigned index;
@@ -340,6 +525,20 @@ static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)
 		if (index >= IOAPIC_NUM_PINS)
 			return;
 		index = array_index_nospec(index, IOAPIC_NUM_PINS);
+		/*
+		 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+		 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+		 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+		 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+		 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+		 */
 		e = &ioapic->redirtbl[index];
 		mask_before = e->fields.mask;
 		/* Preserve read-only fields */
@@ -401,17 +600,61 @@ static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)
 				kvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,
 							 vcpu_bitmap);
 			}
+			/*
+			 * 只在此处调用kvm_make_scan_ioapic_request_mask()
+			 */
 			kvm_make_scan_ioapic_request_mask(ioapic->kvm,
 							  vcpu_bitmap);
 		} else {
+			/*
+			 * 在以下使用kvm_make_scan_ioapic_request():
+			 *   - arch/x86/kvm/ioapic.c|345| <<kvm_arch_post_irq_ack_notifier_list_update>> kvm_make_scan_ioapic_request(kvm);
+			 *   - arch/x86/kvm/ioapic.c|442| <<ioapic_write_indirect>> kvm_make_scan_ioapic_request(ioapic->kvm);
+			 *   - arch/x86/kvm/ioapic.c|879| <<kvm_set_ioapic>> kvm_make_scan_ioapic_request(kvm);
+			 *   - arch/x86/kvm/irq_comm.c|408| <<kvm_arch_post_irq_routing_update>> kvm_make_scan_ioapic_request(kvm);
+			 *   - arch/x86/kvm/lapic.c|436| <<kvm_recalculate_apic_map>> kvm_make_scan_ioapic_request(kvm);
+			 */
 			kvm_make_scan_ioapic_request(ioapic->kvm);
 		}
 		break;
 	}
 }
 
+/*
+ * hot-add和hot-del都调用
+ *
+ * ioapic_service
+ * ioapic_set_irq
+ * kvm_ioapic_set_irq
+ * kvm_set_irq
+ * kvm_vm_ioctl_irq_line
+ * kvm_vm_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * 在以下使用ioapic_service():
+ *   - arch/x86/kvm/ioapic.c|287| <<ioapic_set_irq>> ret = ioapic_service(ioapic, irq, line_status);
+ *   - arch/x86/kvm/ioapic.c|435| <<ioapic_write_indirect>> ioapic_service(ioapic, index, false)
+ *   - arch/x86/kvm/ioapic.c|606| <<kvm_ioapic_eoi_inject_work>> ioapic_service(ioapic, i, false);
+ *   - arch/x86/kvm/ioapic.c|657| <<kvm_ioapic_update_eoi_one>> ioapic_service(ioapic, pin, false);
+ */
 static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)
 {
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
 	struct kvm_lapic_irq irqe;
 	int ret;
@@ -430,6 +673,14 @@ static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)
 	irqe.shorthand = APIC_DEST_NOSHORT;
 	irqe.msi_redir_hint = false;
 
+	/*
+	 * 在以下使用kvm_ioapic->irr_delivered:
+	 *   - arch/x86/kvm/ioapic.c|253| <<ioapic_set_irq>> ioapic->irr_delivered &= ~mask;
+	 *   - arch/x86/kvm/ioapic.c|455| <<ioapic_service>> ioapic->irr_delivered |= 1 << irq;
+	 *   - arch/x86/kvm/ioapic.c|742| <<kvm_ioapic_reset>> ioapic->irr_delivered = 0;
+	 *   - arch/x86/kvm/ioapic.c|800| <<kvm_get_ioapic>> state->irr &= ~ioapic->irr_delivered;
+	 *   - arch/x86/kvm/ioapic.c|811| <<kvm_set_ioapic>> ioapic->irr_delivered = 0;
+	 */
 	if (irqe.trig_mode == IOAPIC_EDGE_TRIG)
 		ioapic->irr_delivered |= 1 << irq;
 
@@ -441,6 +692,15 @@ static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)
 		 * if rtc_irq_check_coalesced returns false).
 		 */
 		BUG_ON(ioapic->rtc_status.pending_eoi != 0);
+		/*
+		 * 在以下调用kvm_irq_delivery_to_apic():
+		 *   - arch/x86/kvm/hyperv.c|482| <<synic_set_irq>> ret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);
+		 *   - arch/x86/kvm/ioapic.c|444| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, &ioapic->rtc_status.dest_map);
+		 *   - arch/x86/kvm/ioapic.c|448| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);
+		 *   - arch/x86/kvm/irq_comm.c|142| <<kvm_set_msi>> return kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);
+		 *   - arch/x86/kvm/lapic.c|1723| <<kvm_apic_send_ipi>> kvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);
+		 *   - arch/x86/kvm/x86.c|9079| <<kvm_pv_kick_cpu_op>> kvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);
+		 */
 		ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,
 					       &ioapic->rtc_status.dest_map);
 		ioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);
@@ -453,6 +713,10 @@ static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)
 	return ret;
 }
 
+/*
+ * 在以下使用kvm_ioapic_set_irq():
+ *   - arch/x86/kvm/irq_comm.c|41| <<kvm_set_ioapic_irq>> return kvm_ioapic_set_irq(ioapic, e->irqchip.pin, irq_source_id, level,
+ */
 int kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,
 		       int level, bool line_status)
 {
@@ -480,6 +744,18 @@ void kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)
 	spin_unlock(&ioapic->lock);
 }
 
+/*
+ * 在以下使用kvm_ioapic->eoi_inject:
+ *   - arch/x86/kvm/ioapic.c|653| <<kvm_ioapic_update_eoi_one>> schedule_delayed_work(&ioapic->eoi_inject, HZ / 100);
+ *   - arch/x86/kvm/ioapic.c|816| <<kvm_ioapic_reset>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+ *   - arch/x86/kvm/ioapic.c|850| <<kvm_ioapic_init>> INIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);
+ *   - arch/x86/kvm/ioapic.c|874| <<kvm_ioapic_destroy>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+ *
+ * 在以下使用kvm_ioapic_eoi_inject_work():
+ *   - arch/x86/kvm/ioapic.c|762| <<kvm_ioapic_init>> INIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);
+ *
+ * 是不是写了ioapic的eoi, 就要插入下一个了
+ */
 static void kvm_ioapic_eoi_inject_work(struct work_struct *work)
 {
 	int i;
@@ -487,6 +763,20 @@ static void kvm_ioapic_eoi_inject_work(struct work_struct *work)
 						 eoi_inject.work);
 	spin_lock(&ioapic->lock);
 	for (i = 0; i < IOAPIC_NUM_PINS; i++) {
+		/*
+		 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+		 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+		 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+		 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+		 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+		 */
 		union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
 
 		if (ent->fields.trig_mode != IOAPIC_LEVEL_TRIG)
@@ -499,12 +789,30 @@ static void kvm_ioapic_eoi_inject_work(struct work_struct *work)
 }
 
 #define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000
+/*
+ * 在以下使用kvm_ioapic_update_eoi_one():
+ *   - arch/x86/kvm/ioapic.c|575| <<kvm_ioapic_update_eoi>> kvm_ioapic_update_eoi_one(vcpu, ioapic, trigger_mode, i);
+ */
 static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,
 				      struct kvm_ioapic *ioapic,
 				      int trigger_mode,
 				      int pin)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
 
 	/*
@@ -516,6 +824,16 @@ static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,
 	 * after ack notifier returns.
 	 */
 	spin_unlock(&ioapic->lock);
+	/*
+	 * 在以下使用kvm_notify_acked_irq():
+	 *   - arch/arm64/kvm/vgic/vgic-v2.c|72| <<vgic_v2_fold_lr_state>> kvm_notify_acked_irq(vcpu->kvm, 0,
+	 *   - arch/arm64/kvm/vgic/vgic-v3.c|63| <<vgic_v3_fold_lr_state>> kvm_notify_acked_irq(vcpu->kvm, 0,
+	 *   - arch/powerpc/kvm/book3s_xics.c|812| <<ics_eoi>> kvm_notify_acked_irq(vcpu->kvm, 0, irq);
+	 *   - arch/powerpc/kvm/book3s_xics.c|866| <<kvmppc_xics_rm_complete>> kvm_notify_acked_irq(vcpu->kvm, 0, icp->rm_eoied_irq);
+	 *   - arch/powerpc/kvm/mpic.c|1106| <<openpic_cpu_write_internal>> kvm_notify_acked_irq(opp->kvm, 0, notify_eoi);
+	 *   - arch/x86/kvm/i8259.c|82| <<pic_clear_isr>> kvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);
+	 *   - arch/x86/kvm/ioapic.c|633| <<kvm_ioapic_update_eoi_one>> kvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, pin);
+	 */
 	kvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, pin);
 	spin_lock(&ioapic->lock);
 
@@ -526,6 +844,14 @@ static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,
 	ASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);
 	ent->fields.remote_irr = 0;
 	if (!ent->fields.mask && (ioapic->irr & (1 << pin))) {
+		/*
+		 * 在以下使用kvm_ioapic->irq_eoi[]:
+		 *   - arch/x86/kvm/ioapic.c|643| <<kvm_ioapic_update_eoi_one>> ++ioapic->irq_eoi[pin];
+		 *   - arch/x86/kvm/ioapic.c|644| <<kvm_ioapic_update_eoi_one>> if (ioapic->irq_eoi[pin] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {
+		 *   - arch/x86/kvm/ioapic.c|654| <<kvm_ioapic_update_eoi_one>> ioapic->irq_eoi[pin] = 0;
+		 *   - arch/x86/kvm/ioapic.c|660| <<kvm_ioapic_update_eoi_one>> ioapic->irq_eoi[pin] = 0;
+		 *   - arch/x86/kvm/ioapic.c|832| <<kvm_ioapic_reset>> memset(ioapic->irq_eoi, 0x00, sizeof(ioapic->irq_eoi));
+		 */
 		++ioapic->irq_eoi[pin];
 		if (ioapic->irq_eoi[pin] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {
 			/*
@@ -536,6 +862,13 @@ static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,
 			 * level-triggered interrupt.  Emulate this
 			 * behavior if we detect an interrupt storm.
 			 */
+			/*
+			 * 在以下使用kvm_ioapic->eoi_inject:
+			 *   - arch/x86/kvm/ioapic.c|653| <<kvm_ioapic_update_eoi_one>> schedule_delayed_work(&ioapic->eoi_inject, HZ / 100);
+			 *   - arch/x86/kvm/ioapic.c|816| <<kvm_ioapic_reset>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+			 *   - arch/x86/kvm/ioapic.c|850| <<kvm_ioapic_init>> INIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);
+			 *   - arch/x86/kvm/ioapic.c|874| <<kvm_ioapic_destroy>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+			 */
 			schedule_delayed_work(&ioapic->eoi_inject, HZ / 100);
 			ioapic->irq_eoi[pin] = 0;
 			trace_kvm_ioapic_delayed_eoi_inj(ent->bits);
@@ -547,6 +880,22 @@ static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,
 	}
 }
 
+/*
+ * kvm_ioapic_update_eoi
+ * kvm_apic_set_eoi_accelerated
+ * handle_apic_eoi_induced
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * 在以下调用kvm_ioapic_update_eoi():
+ *   - arch/x86/kvm/lapic.c|1629| <<kvm_ioapic_send_eoi>> kvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);
+ */
 void kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)
 {
 	int i;
@@ -555,10 +904,45 @@ void kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)
 	spin_lock(&ioapic->lock);
 	rtc_irq_eoi(ioapic, vcpu, vector);
 	for (i = 0; i < IOAPIC_NUM_PINS; i++) {
+		/*
+		 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+		 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+		 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+		 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+		 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+		 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+		 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+		 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+		 */
 		union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
 
+		/*
+		 * 57 union kvm_ioapic_redirect_entry {
+		 * 58         u64 bits;
+		 * 59         struct {
+		 * 60                 u8 vector;
+		 * 61                 u8 delivery_mode:3;
+		 * 62                 u8 dest_mode:1;
+		 * 63                 u8 delivery_status:1;
+		 * 64                 u8 polarity:1;
+		 * 65                 u8 remote_irr:1;
+		 * 66                 u8 trig_mode:1;
+		 * 67                 u8 mask:1;
+		 * 68                 u8 reserve:7;
+		 * 69                 u8 reserved[4];
+		 * 70                 u8 dest_id;
+		 * 71         } fields;
+		 * 72 };
+		 */
 		if (ent->fields.vector != vector)
 			continue;
+		/*
+		 * 只在此处调用
+		 */
 		kvm_ioapic_update_eoi_one(vcpu, ioapic, trigger_mode, i);
 	}
 	spin_unlock(&ioapic->lock);
@@ -569,6 +953,11 @@ static inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)
 	return container_of(dev, struct kvm_ioapic, dev);
 }
 
+/*
+ * 在以下使用ioapic_in_range():
+ *   - arch/x86/kvm/ioapic.c|731| <<ioapic_mmio_read>> if (!ioapic_in_range(ioapic, addr))
+ *   - arch/x86/kvm/ioapic.c|773| <<ioapic_mmio_write>> if (!ioapic_in_range(ioapic, addr))
+ */
 static inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)
 {
 	return ((addr >= ioapic->base_address &&
@@ -665,14 +1054,51 @@ static void kvm_ioapic_reset(struct kvm_ioapic *ioapic)
 {
 	int i;
 
+	/*
+	 * 在以下使用kvm_ioapic->eoi_inject:
+	 *   - arch/x86/kvm/ioapic.c|653| <<kvm_ioapic_update_eoi_one>> schedule_delayed_work(&ioapic->eoi_inject, HZ / 100);
+	 *   *   - arch/x86/kvm/ioapic.c|816| <<kvm_ioapic_reset>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+	 *   - arch/x86/kvm/ioapic.c|850| <<kvm_ioapic_init>> INIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);
+	 *   - arch/x86/kvm/ioapic.c|874| <<kvm_ioapic_destroy>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+	 */
 	cancel_delayed_work_sync(&ioapic->eoi_inject);
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	for (i = 0; i < IOAPIC_NUM_PINS; i++)
 		ioapic->redirtbl[i].fields.mask = 1;
 	ioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;
 	ioapic->ioregsel = 0;
 	ioapic->irr = 0;
+	/*
+	 * 在以下使用kvm_ioapic->irr_delivered:
+	 *   - arch/x86/kvm/ioapic.c|253| <<ioapic_set_irq>> ioapic->irr_delivered &= ~mask;
+	 *   - arch/x86/kvm/ioapic.c|455| <<ioapic_service>> ioapic->irr_delivered |= 1 << irq;
+	 *   - arch/x86/kvm/ioapic.c|742| <<kvm_ioapic_reset>> ioapic->irr_delivered = 0;
+	 *   - arch/x86/kvm/ioapic.c|800| <<kvm_get_ioapic>> state->irr &= ~ioapic->irr_delivered;
+	 *   - arch/x86/kvm/ioapic.c|811| <<kvm_set_ioapic>> ioapic->irr_delivered = 0;
+	 */
 	ioapic->irr_delivered = 0;
 	ioapic->id = 0;
+	/*
+	 * 在以下使用kvm_ioapic->irq_eoi[]:
+	 *   - arch/x86/kvm/ioapic.c|643| <<kvm_ioapic_update_eoi_one>> ++ioapic->irq_eoi[pin];
+	 *   - arch/x86/kvm/ioapic.c|644| <<kvm_ioapic_update_eoi_one>> if (ioapic->irq_eoi[pin] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {
+	 *   - arch/x86/kvm/ioapic.c|654| <<kvm_ioapic_update_eoi_one>> ioapic->irq_eoi[pin] = 0;
+	 *   - arch/x86/kvm/ioapic.c|660| <<kvm_ioapic_update_eoi_one>> ioapic->irq_eoi[pin] = 0;
+	 *   - arch/x86/kvm/ioapic.c|832| <<kvm_ioapic_reset>> memset(ioapic->irq_eoi, 0x00, sizeof(ioapic->irq_eoi));
+	 */
 	memset(ioapic->irq_eoi, 0x00, sizeof(ioapic->irq_eoi));
 	rtc_irq_eoi_tracking_reset(ioapic);
 }
@@ -682,6 +1108,10 @@ static const struct kvm_io_device_ops ioapic_mmio_ops = {
 	.write    = ioapic_mmio_write,
 };
 
+/*
+ * 处理KVM_CREATE_IRQCHIP:
+ *   - arch/x86/kvm/x86.c|6256| <<kvm_arch_vm_ioctl(KVM_CREATE_IRQCHIP)>> r = kvm_ioapic_init(kvm);
+ */
 int kvm_ioapic_init(struct kvm *kvm)
 {
 	struct kvm_ioapic *ioapic;
@@ -691,6 +1121,13 @@ int kvm_ioapic_init(struct kvm *kvm)
 	if (!ioapic)
 		return -ENOMEM;
 	spin_lock_init(&ioapic->lock);
+	/*
+	 * 在以下使用kvm_ioapic->eoi_inject:
+	 *   - arch/x86/kvm/ioapic.c|653| <<kvm_ioapic_update_eoi_one>> schedule_delayed_work(&ioapic->eoi_inject, HZ / 100);
+	 *   - arch/x86/kvm/ioapic.c|816| <<kvm_ioapic_reset>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+	 *   - arch/x86/kvm/ioapic.c|850| <<kvm_ioapic_init>> INIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);
+	 *   - arch/x86/kvm/ioapic.c|874| <<kvm_ioapic_destroy>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+	 */
 	INIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);
 	kvm->arch.vioapic = ioapic;
 	kvm_ioapic_reset(ioapic);
@@ -715,6 +1152,13 @@ void kvm_ioapic_destroy(struct kvm *kvm)
 	if (!ioapic)
 		return;
 
+	/*
+	 * 在以下使用kvm_ioapic->eoi_inject:
+	 *   - arch/x86/kvm/ioapic.c|653| <<kvm_ioapic_update_eoi_one>> schedule_delayed_work(&ioapic->eoi_inject, HZ / 100);
+	 *   - arch/x86/kvm/ioapic.c|816| <<kvm_ioapic_reset>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+	 *   - arch/x86/kvm/ioapic.c|850| <<kvm_ioapic_init>> INIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);
+	 *   - arch/x86/kvm/ioapic.c|874| <<kvm_ioapic_destroy>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+	 */
 	cancel_delayed_work_sync(&ioapic->eoi_inject);
 	mutex_lock(&kvm->slots_lock);
 	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
@@ -729,6 +1173,14 @@ void kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)
 
 	spin_lock(&ioapic->lock);
 	memcpy(state, ioapic, sizeof(struct kvm_ioapic_state));
+	/*
+	 * 在以下使用kvm_ioapic->irr_delivered:
+	 *   - arch/x86/kvm/ioapic.c|253| <<ioapic_set_irq>> ioapic->irr_delivered &= ~mask;
+	 *   - arch/x86/kvm/ioapic.c|455| <<ioapic_service>> ioapic->irr_delivered |= 1 << irq;
+	 *   - arch/x86/kvm/ioapic.c|742| <<kvm_ioapic_reset>> ioapic->irr_delivered = 0;
+	 *   - arch/x86/kvm/ioapic.c|800| <<kvm_get_ioapic>> state->irr &= ~ioapic->irr_delivered;
+	 *   - arch/x86/kvm/ioapic.c|811| <<kvm_set_ioapic>> ioapic->irr_delivered = 0;
+	 */
 	state->irr &= ~ioapic->irr_delivered;
 	spin_unlock(&ioapic->lock);
 }
@@ -740,7 +1192,23 @@ void kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)
 	spin_lock(&ioapic->lock);
 	memcpy(ioapic, state, sizeof(struct kvm_ioapic_state));
 	ioapic->irr = 0;
+	/*
+	 * 在以下使用kvm_ioapic->irr_delivered:
+	 *   - arch/x86/kvm/ioapic.c|253| <<ioapic_set_irq>> ioapic->irr_delivered &= ~mask;
+	 *   - arch/x86/kvm/ioapic.c|455| <<ioapic_service>> ioapic->irr_delivered |= 1 << irq;
+	 *   - arch/x86/kvm/ioapic.c|742| <<kvm_ioapic_reset>> ioapic->irr_delivered = 0;
+	 *   - arch/x86/kvm/ioapic.c|800| <<kvm_get_ioapic>> state->irr &= ~ioapic->irr_delivered;
+	 *   - arch/x86/kvm/ioapic.c|811| <<kvm_set_ioapic>> ioapic->irr_delivered = 0;
+	 */
 	ioapic->irr_delivered = 0;
+	/*
+	 * 在以下使用kvm_make_scan_ioapic_request():
+	 *   - arch/x86/kvm/ioapic.c|345| <<kvm_arch_post_irq_ack_notifier_list_update>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/ioapic.c|442| <<ioapic_write_indirect>> kvm_make_scan_ioapic_request(ioapic->kvm);
+	 *   - arch/x86/kvm/ioapic.c|879| <<kvm_set_ioapic>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/irq_comm.c|408| <<kvm_arch_post_irq_routing_update>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/lapic.c|436| <<kvm_recalculate_apic_map>> kvm_make_scan_ioapic_request(kvm);
+	 */
 	kvm_make_scan_ioapic_request(kvm);
 	kvm_ioapic_inject_all(ioapic, state->irr);
 	spin_unlock(&ioapic->lock);
diff --git a/arch/x86/kvm/ioapic.h b/arch/x86/kvm/ioapic.h
index f1b2b2a6ff4d..ab9355752788 100644
--- a/arch/x86/kvm/ioapic.h
+++ b/arch/x86/kvm/ioapic.h
@@ -77,14 +77,51 @@ struct kvm_ioapic {
 	u32 id;
 	u32 irr;
 	u32 pad;
+	/*
+	 * 在以下使用kvm_ioapic->redirtbl[IOAPIC_NUM_PINS]:
+	 *   - arch/x86/kvm/ioapic.c|90| <<ioapic_read_indirect>> redir_content = ioapic->redirtbl[index].bits;
+	 *   - arch/x86/kvm/ioapic.c|127| <<__rtc_irq_eoi_tracking_restore_one>> e = &ioapic->redirtbl[RTC_GSI];
+	 *   - arch/x86/kvm/ioapic.c|208| <<ioapic_lazy_update_eoi>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|234| <<ioapic_set_irq>> entry = ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|357| <<kvm_ioapic_scan_entry>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|427| <<ioapic_write_indirect>> e = &ioapic->redirtbl[index];
+	 *   - arch/x86/kvm/ioapic.c|529| <<ioapic_service>> union kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];
+	 *   - arch/x86/kvm/ioapic.c|637| <<kvm_ioapic_eoi_inject_work>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|659| <<kvm_ioapic_update_eoi_one>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];
+	 *   - arch/x86/kvm/ioapic.c|750| <<kvm_ioapic_update_eoi>> union kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];
+	 *   - arch/x86/kvm/ioapic.c|895| <<kvm_ioapic_reset>> ioapic->redirtbl[i].fields.mask = 1;
+	 */
 	union kvm_ioapic_redirect_entry redirtbl[IOAPIC_NUM_PINS];
 	unsigned long irq_states[IOAPIC_NUM_PINS];
 	struct kvm_io_device dev;
 	struct kvm *kvm;
 	spinlock_t lock;
 	struct rtc_status rtc_status;
+	/*
+	 * 在以下使用kvm_ioapic->eoi_inject:
+	 *   - arch/x86/kvm/ioapic.c|653| <<kvm_ioapic_update_eoi_one>> schedule_delayed_work(&ioapic->eoi_inject, HZ / 100);
+	 *   - arch/x86/kvm/ioapic.c|816| <<kvm_ioapic_reset>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+	 *   - arch/x86/kvm/ioapic.c|850| <<kvm_ioapic_init>> INIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);
+	 *   - arch/x86/kvm/ioapic.c|874| <<kvm_ioapic_destroy>> cancel_delayed_work_sync(&ioapic->eoi_inject);
+	 */
 	struct delayed_work eoi_inject;
+	/*
+	 * 在以下使用kvm_ioapic->irq_eoi[]:
+	 *   - arch/x86/kvm/ioapic.c|643| <<kvm_ioapic_update_eoi_one>> ++ioapic->irq_eoi[pin];
+	 *   - arch/x86/kvm/ioapic.c|644| <<kvm_ioapic_update_eoi_one>> if (ioapic->irq_eoi[pin] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {
+	 *   - arch/x86/kvm/ioapic.c|654| <<kvm_ioapic_update_eoi_one>> ioapic->irq_eoi[pin] = 0;
+	 *   - arch/x86/kvm/ioapic.c|660| <<kvm_ioapic_update_eoi_one>> ioapic->irq_eoi[pin] = 0;
+	 *   - arch/x86/kvm/ioapic.c|832| <<kvm_ioapic_reset>> memset(ioapic->irq_eoi, 0x00, sizeof(ioapic->irq_eoi));
+	 */
 	u32 irq_eoi[IOAPIC_NUM_PINS];
+	/*
+	 * 在以下使用kvm_ioapic->irr_delivered:
+	 *   - arch/x86/kvm/ioapic.c|253| <<ioapic_set_irq>> ioapic->irr_delivered &= ~mask;
+	 *   - arch/x86/kvm/ioapic.c|455| <<ioapic_service>> ioapic->irr_delivered |= 1 << irq;
+	 *   - arch/x86/kvm/ioapic.c|742| <<kvm_ioapic_reset>> ioapic->irr_delivered = 0;
+	 *   - arch/x86/kvm/ioapic.c|800| <<kvm_get_ioapic>> state->irr &= ~ioapic->irr_delivered;
+	 *   - arch/x86/kvm/ioapic.c|811| <<kvm_set_ioapic>> ioapic->irr_delivered = 0;
+	 */
 	u32 irr_delivered;
 };
 
diff --git a/arch/x86/kvm/irq.c b/arch/x86/kvm/irq.c
index 172b05343cfd..b77beafcd378 100644
--- a/arch/x86/kvm/irq.c
+++ b/arch/x86/kvm/irq.c
@@ -20,6 +20,11 @@
  * check if there are pending timer events
  * to be processed.
  */
+/*
+ * 在以下使用kvm_cpu_has_pending_timer():
+ *   - arch/x86/kvm/x86.c|10389| <<vcpu_run>> if (kvm_cpu_has_pending_timer(vcpu))
+ *   - virt/kvm/kvm_main.c|3282| <<kvm_vcpu_check_block>> if (kvm_cpu_has_pending_timer(vcpu))
+ */
 int kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)
 {
 	if (lapic_in_kernel(vcpu))
@@ -32,8 +37,21 @@ EXPORT_SYMBOL(kvm_cpu_has_pending_timer);
 /*
  * check if there is a pending userspace external interrupt
  */
+/*
+ * 在以下使用pending_userspace_extint():
+ *   - arch/x86/kvm/irq.c|81| <<kvm_cpu_has_extint>> return pending_userspace_extint(v);
+ */
 static int pending_userspace_extint(struct kvm_vcpu *v)
 {
+	/*
+	 * 在以下使用kvm_vcpu_arch->pending_external_vector:
+	 *   - arch/x86/kvm/irq.c|42| <<pending_userspace_extint>> return v->arch.pending_external_vector != -1;
+	 *   - arch/x86/kvm/irq.c|135| <<kvm_cpu_get_extint>> int vector = v->arch.pending_external_vector;
+	 *   - arch/x86/kvm/irq.c|137| <<kvm_cpu_get_extint>> v->arch.pending_external_vector = -1;
+	 *   - arch/x86/kvm/x86.c|4750| <<kvm_vcpu_ioctl_interrupt>> if (vcpu->arch.pending_external_vector != -1)
+	 *   - arch/x86/kvm/x86.c|4753| <<kvm_vcpu_ioctl_interrupt>> vcpu->arch.pending_external_vector = irq->irq;
+	 *   - arch/x86/kvm/x86.c|11459| <<kvm_arch_vcpu_create>> vcpu->arch.pending_external_vector = -1;
+	 */
 	return v->arch.pending_external_vector != -1;
 }
 
@@ -41,6 +59,13 @@ static int pending_userspace_extint(struct kvm_vcpu *v)
  * check if there is pending interrupt from
  * non-APIC source without intack.
  */
+/*
+ * 在以下调用kvm_cpu_has_extint():
+ *   - arch/x86/kvm/irq.c|100| <<kvm_cpu_has_injectable_intr>> if (kvm_cpu_has_extint(v))
+ *   - arch/x86/kvm/irq.c|119| <<kvm_cpu_has_interrupt>> if (kvm_cpu_has_extint(v))
+ *   - arch/x86/kvm/irq.c|136| <<kvm_cpu_get_extint>> if (!kvm_cpu_has_extint(v)) {
+ *   - arch/x86/kvm/x86.c|4708| <<kvm_cpu_accept_dm_intr>> if (kvm_cpu_has_extint(vcpu))
+ */
 int kvm_cpu_has_extint(struct kvm_vcpu *v)
 {
 	/*
@@ -75,11 +100,20 @@ int kvm_cpu_has_extint(struct kvm_vcpu *v)
  * interrupt from apic will handled by hardware,
  * we don't need to check it here.
  */
+/*
+ * 在以下调用kvm_cpu_has_injectable_intr():
+ *   - arch/x86/kvm/svm/svm.c|2450| <<svm_set_gif>> kvm_cpu_has_injectable_intr(&svm->vcpu))
+ *   - arch/x86/kvm/x86.c|9470| <<inject_pending_event>> if (kvm_cpu_has_injectable_intr(vcpu)) {
+ *   - arch/x86/kvm/x86.c|9486| <<inject_pending_event>> if (kvm_cpu_has_injectable_intr(vcpu))
+ */
 int kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)
 {
 	if (kvm_cpu_has_extint(v))
 		return 1;
 
+	/*
+	 * 这里很重要!!!!!
+	 */
 	if (!is_guest_mode(v) && kvm_vcpu_apicv_active(v))
 		return 0;
 
@@ -91,6 +125,12 @@ EXPORT_SYMBOL_GPL(kvm_cpu_has_injectable_intr);
  * check if there is pending interrupt without
  * intack.
  */
+/*
+ * 在以下使用kvm_cpu_has_interrupt():
+ *   - arch/x86/kvm/svm/nested.c|1330| <<svm_check_nested_events>> if (kvm_cpu_has_interrupt(vcpu) && !svm_interrupt_blocked(vcpu)) {
+ *   - arch/x86/kvm/vmx/nested.c|4007| <<vmx_check_nested_events>> if (kvm_cpu_has_interrupt(vcpu) && !vmx_interrupt_blocked(vcpu)) {
+ *   - arch/x86/kvm/x86.c|12591| <<kvm_vcpu_has_events>> (kvm_cpu_has_interrupt(vcpu) ||
+ */
 int kvm_cpu_has_interrupt(struct kvm_vcpu *v)
 {
 	if (kvm_cpu_has_extint(v))
@@ -104,6 +144,10 @@ EXPORT_SYMBOL_GPL(kvm_cpu_has_interrupt);
  * Read pending interrupt(from non-APIC source)
  * vector and intack.
  */
+/*
+ * 在以下使用kvm_cpu_get_extint():
+ *   - arch/x86/kvm/irq.c|153| <<kvm_cpu_get_interrupt>> int vector = kvm_cpu_get_extint(v);
+ */
 static int kvm_cpu_get_extint(struct kvm_vcpu *v)
 {
 	if (!kvm_cpu_has_extint(v)) {
@@ -118,6 +162,15 @@ static int kvm_cpu_get_extint(struct kvm_vcpu *v)
 		return v->kvm->arch.xen.upcall_vector;
 
 	if (irqchip_split(v->kvm)) {
+		/*
+		 * 在以下使用kvm_vcpu_arch->pending_external_vector:
+		 *   - arch/x86/kvm/irq.c|42| <<pending_userspace_extint>> return v->arch.pending_external_vector != -1;
+		 *   - arch/x86/kvm/irq.c|135| <<kvm_cpu_get_extint>> int vector = v->arch.pending_external_vector;
+		 *   - arch/x86/kvm/irq.c|137| <<kvm_cpu_get_extint>> v->arch.pending_external_vector = -1;
+		 *   - arch/x86/kvm/x86.c|4750| <<kvm_vcpu_ioctl_interrupt>> if (vcpu->arch.pending_external_vector != -1)
+		 *   - arch/x86/kvm/x86.c|4753| <<kvm_vcpu_ioctl_interrupt>> vcpu->arch.pending_external_vector = irq->irq;
+		 *   - arch/x86/kvm/x86.c|11459| <<kvm_arch_vcpu_create>> vcpu->arch.pending_external_vector = -1;
+		 */
 		int vector = v->arch.pending_external_vector;
 
 		v->arch.pending_external_vector = -1;
@@ -129,6 +182,20 @@ static int kvm_cpu_get_extint(struct kvm_vcpu *v)
 /*
  * Read pending interrupt vector and intack.
  */
+/*
+ * 在以下使用kvm_cpu_get_interrupt():
+ *   - arch/x86/kvm/vmx/nested.c|4695| <<nested_vmx_vmexit>> int irq = kvm_cpu_get_interrupt(vcpu);
+ *   - arch/x86/kvm/x86.c|9478| <<inject_pending_event>> int irq = kvm_cpu_get_interrupt(vcpu);
+ *
+ * vcpu_enter_guest()
+ * -> if (kvm_cpu_has_injectable_intr(vcpu)) {
+ *      inject_pending_event()
+ *      -> kvm_cpu_get_interrupt()
+ *         -> kvm_get_apic_interrupt()
+ *            -> apic_set_isr()
+ *
+ * 注意kvm_cpu_has_injectable_intr()
+ */
 int kvm_cpu_get_interrupt(struct kvm_vcpu *v)
 {
 	int vector = kvm_cpu_get_extint(v);
@@ -153,6 +220,13 @@ void __kvm_migrate_timers(struct kvm_vcpu *vcpu)
 	static_call_cond(kvm_x86_migrate_timers)(vcpu);
 }
 
+/*
+ * 在以下使用kvm_arch_irqfd_allowed():
+ *   - virt/kvm/eventfd.c|303| <<kvm_irqfd_assign>> if (!kvm_arch_irqfd_allowed(kvm, args))
+ *
+ * 一般是KVM_IRQCHIP_KERNEL
+ * 一般支持resample
+ */
 bool kvm_arch_irqfd_allowed(struct kvm *kvm, struct kvm_irqfd *args)
 {
 	bool resample = args->flags & KVM_IRQFD_FLAG_RESAMPLE;
diff --git a/arch/x86/kvm/irq.h b/arch/x86/kvm/irq.h
index c2d7cfe82d00..4781dab821ad 100644
--- a/arch/x86/kvm/irq.h
+++ b/arch/x86/kvm/irq.h
@@ -64,6 +64,9 @@ void kvm_pic_destroy(struct kvm *kvm);
 int kvm_pic_read_irq(struct kvm *kvm);
 void kvm_pic_update_irq(struct kvm_pic *s);
 
+/*
+ * 一般是KVM_IRQCHIP_KERNEL
+ */
 static inline int irqchip_split(struct kvm *kvm)
 {
 	int mode = kvm->arch.irqchip_mode;
@@ -73,6 +76,9 @@ static inline int irqchip_split(struct kvm *kvm)
 	return mode == KVM_IRQCHIP_SPLIT;
 }
 
+/*
+ * 一般是KVM_IRQCHIP_KERNEL
+ */
 static inline int irqchip_kernel(struct kvm *kvm)
 {
 	int mode = kvm->arch.irqchip_mode;
@@ -93,6 +99,13 @@ static inline int irqchip_in_kernel(struct kvm *kvm)
 
 	/* Matches smp_wmb() when setting irqchip_mode */
 	smp_rmb();
+	/*
+	 * enum kvm_irqchip_mode {
+	 *     KVM_IRQCHIP_NONE,
+	 *     KVM_IRQCHIP_KERNEL,       // created with KVM_CREATE_IRQCHIP
+	 *     KVM_IRQCHIP_SPLIT,        // created with KVM_CAP_SPLIT_IRQCHIP
+	 * };
+	 */
 	return mode != KVM_IRQCHIP_NONE;
 }
 
diff --git a/arch/x86/kvm/irq_comm.c b/arch/x86/kvm/irq_comm.c
index 025b65502fce..365874501fe2 100644
--- a/arch/x86/kvm/irq_comm.c
+++ b/arch/x86/kvm/irq_comm.c
@@ -33,6 +33,10 @@ static int kvm_set_pic_irq(struct kvm_kernel_irq_routing_entry *e,
 	return kvm_pic_set_irq(pic, e->irqchip.pin, irq_source_id, level);
 }
 
+/*
+ * 在以下使用kvm_set_ioapic_irq():
+ *   - arch/x86/kvm/irq_comm.c|317| <<kvm_set_routing_entry>> e->set = kvm_set_ioapic_irq;
+ */
 static int kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,
 			      struct kvm *kvm, int irq_source_id, int level,
 			      bool line_status)
@@ -42,6 +46,15 @@ static int kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,
 				line_status);
 }
 
+/*
+ * 在以下调用kvm_irq_delivery_to_apic():
+ *   - arch/x86/kvm/hyperv.c|482| <<synic_set_irq>> ret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);
+ *   - arch/x86/kvm/ioapic.c|444| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, &ioapic->rtc_status.dest_map);
+ *   - arch/x86/kvm/ioapic.c|448| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);
+ *   - arch/x86/kvm/irq_comm.c|142| <<kvm_set_msi>> return kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);
+ *   - arch/x86/kvm/lapic.c|1723| <<kvm_apic_send_ipi>> kvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);
+ *   - arch/x86/kvm/x86.c|9079| <<kvm_pv_kick_cpu_op>> kvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);
+ */
 int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,
 		struct kvm_lapic_irq *irq, struct dest_map *dest_map)
 {
@@ -72,6 +85,17 @@ int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,
 		if (!kvm_lowest_prio_delivery(irq)) {
 			if (r < 0)
 				r = 0;
+			/*
+			 * 在以下使用kvm_apic_set_irq():
+			 *   - arch/x86/kvm/hyperv.c|828| <<stimer_notify_direct>> return !kvm_apic_set_irq(vcpu, &irq, NULL);
+			 *   - arch/x86/kvm/hyperv.c|1899| <<kvm_send_ipi_to_many>> kvm_apic_set_irq(vcpu, &irq, NULL);
+			 *   - arch/x86/kvm/irq_comm.c|88| <<kvm_irq_delivery_to_apic>> r += kvm_apic_set_irq(vcpu, irq, dest_map);
+			 *   - arch/x86/kvm/irq_comm.c|110| <<kvm_irq_delivery_to_apic>> r = kvm_apic_set_irq(lowest, irq, dest_map);
+			 *   - arch/x86/kvm/lapic.c|914| <<__pv_send_ipi>> count += kvm_apic_set_irq(vcpu, irq, NULL);
+			 *   - arch/x86/kvm/lapic.c|1332| <<kvm_irq_delivery_to_apic_fast>> *r = kvm_apic_set_irq(src->vcpu, irq, dest_map);
+			 *   - arch/x86/kvm/lapic.c|1345| <<kvm_irq_delivery_to_apic_fast>> *r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);
+			 *   - arch/x86/kvm/x86.c|12888| <<kvm_arch_async_page_present>> kvm_apic_set_irq(vcpu, &irq, NULL);
+			 */
 			r += kvm_apic_set_irq(vcpu, irq, dest_map);
 		} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {
 			if (!kvm_vector_hashing_enabled()) {
@@ -120,12 +144,23 @@ void kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,
 }
 EXPORT_SYMBOL_GPL(kvm_set_msi_irq);
 
+/*
+ * 在以下使用kvm_msi_route_invalid():
+ *   - arch/x86/kvm/irq_comm.c|147| <<kvm_set_msi>> if (kvm_msi_route_invalid(kvm, e))
+ *   - arch/x86/kvm/irq_comm.c|191| <<kvm_arch_set_irq_inatomic>> if (kvm_msi_route_invalid(kvm, e))
+ *   - arch/x86/kvm/irq_comm.c|334| <<kvm_set_routing_entry>> if (kvm_msi_route_invalid(kvm, e))
+ */
 static inline bool kvm_msi_route_invalid(struct kvm *kvm,
 		struct kvm_kernel_irq_routing_entry *e)
 {
 	return kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);
 }
 
+/*
+ * 在以下使用kvm_set_msi():
+ *   - arch/x86/kvm/irq_comm.c|329| <<kvm_set_routing_entry>> e->set = kvm_set_msi;
+ *   - virt/kvm/irqchip.c|136| <<kvm_send_userspace_msi>> return kvm_set_msi(&route, kvm, KVM_USERSPACE_IRQ_SOURCE_ID, 1, false);
+ */
 int kvm_set_msi(struct kvm_kernel_irq_routing_entry *e,
 		struct kvm *kvm, int irq_source_id, int level, bool line_status)
 {
@@ -139,6 +174,15 @@ int kvm_set_msi(struct kvm_kernel_irq_routing_entry *e,
 
 	kvm_set_msi_irq(kvm, e, &irq);
 
+	/*
+	 * 在以下调用kvm_irq_delivery_to_apic():
+	 *   - arch/x86/kvm/hyperv.c|482| <<synic_set_irq>> ret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);
+	 *   - arch/x86/kvm/ioapic.c|444| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, &ioapic->rtc_status.dest_map);
+	 *   - arch/x86/kvm/ioapic.c|448| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);
+	 *   - arch/x86/kvm/irq_comm.c|142| <<kvm_set_msi>> return kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);
+	 *   - arch/x86/kvm/lapic.c|1723| <<kvm_apic_send_ipi>> kvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);
+	 *   - arch/x86/kvm/x86.c|9079| <<kvm_pv_kick_cpu_op>> kvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);
+	 */
 	return kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);
 }
 
@@ -153,6 +197,10 @@ static int kvm_hv_set_sint(struct kvm_kernel_irq_routing_entry *e,
 	return kvm_hv_synic_set_irq(kvm, e->hv_sint.vcpu, e->hv_sint.sint);
 }
 
+/*
+ * 在以下调用kvm_arch_set_irq_inatomic():
+ *   - virt/kvm/eventfd.c|210| <<irqfd_wakeup>> if (kvm_arch_set_irq_inatomic(&irq, kvm,
+ */
 int kvm_arch_set_irq_inatomic(struct kvm_kernel_irq_routing_entry *e,
 			      struct kvm *kvm, int irq_source_id, int level,
 			      bool line_status)
@@ -182,8 +230,19 @@ int kvm_arch_set_irq_inatomic(struct kvm_kernel_irq_routing_entry *e,
 	return -EWOULDBLOCK;
 }
 
+/*
+ * 在以下使用kvm_request_irq_source_id():
+ *   - arch/x86/kvm/i8254.c|670| <<kvm_create_pit>> pit->irq_source_id = kvm_request_irq_source_id(kvm);
+ */
 int kvm_request_irq_source_id(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|209| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|241| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|12081| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|12084| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
 	int irq_source_id;
 
@@ -216,6 +275,13 @@ void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)
 		printk(KERN_ERR "kvm: IRQ source ID out of range!\n");
 		goto unlock;
 	}
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|209| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|241| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|12081| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|12084| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
 	if (!irqchip_kernel(kvm))
 		goto unlock;
@@ -226,11 +292,21 @@ void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)
 	mutex_unlock(&kvm->irq_lock);
 }
 
+/*
+ * 在以下调用kvm_register_irq_mask_notifier():
+ *   - arch/x86/kvm/i8254.c|312| <<kvm_pit_set_reinject>> kvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);
+ */
 void kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,
 				    struct kvm_irq_mask_notifier *kimn)
 {
 	mutex_lock(&kvm->irq_lock);
 	kimn->irq = irq;
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|278| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|12073| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
 	mutex_unlock(&kvm->irq_lock);
 }
@@ -244,6 +320,13 @@ void kvm_unregister_irq_mask_notifier(struct kvm *kvm, int irq,
 	synchronize_srcu(&kvm->irq_srcu);
 }
 
+/*
+ * 在以下调用kvm_fire_mask_notifiers():
+ *   - arch/x86/kvm/i8259.c|372| <<pic_ioport_write>> kvm_fire_mask_notifiers(s->pics_state->kvm,
+ *                               SELECT_PIC(irq + off), irq + off, !!(s->imr & (1 << irq)));
+ *   - arch/x86/kvm/ioapic.c|432| <<ioapic_write_indirect>> kvm_fire_mask_notifiers(ioapic->kvm,
+ *                               KVM_IRQCHIP_IOAPIC, index, mask_after);
+ */
 void kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,
 			     bool mask)
 {
@@ -252,6 +335,12 @@ void kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,
 
 	idx = srcu_read_lock(&kvm->irq_srcu);
 	gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|278| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|12073| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	if (gsi != -1)
 		hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
 			if (kimn->irq == gsi)
@@ -264,6 +353,13 @@ bool kvm_arch_can_set_irq_routing(struct kvm *kvm)
 	return irqchip_in_kernel(kvm);
 }
 
+/*
+ * 在以下调用kvm_set_routing_entry():
+ *   - virt/kvm/irqchip.c|194| <<setup_routing_entry>> r = kvm_set_routing_entry(kvm, e, ue);
+ *
+ * 根据用户空间的kvm_irq_routing_entry
+ * 配置kvm_kernel_irq_routing_entry
+ */
 int kvm_set_routing_entry(struct kvm *kvm,
 			  struct kvm_kernel_irq_routing_entry *e,
 			  const struct kvm_irq_routing_entry *ue)
@@ -317,6 +413,11 @@ int kvm_set_routing_entry(struct kvm *kvm,
 	return 0;
 }
 
+/*
+ * 在以下使用kvm_intr_is_single_vcpu():
+ *    - arch/x86/kvm/svm/avic.c|889| <<get_pi_vcpu_info>> if (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu) ||
+ *    - arch/x86/kvm/vmx/posted_intr.c|331| <<vmx_pi_update_irte>> if (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu) ||
+ */
 bool kvm_intr_is_single_vcpu(struct kvm *kvm, struct kvm_lapic_irq *irq,
 			     struct kvm_vcpu **dest_vcpu)
 {
@@ -372,6 +473,15 @@ static const struct kvm_irq_routing_entry default_routing[] = {
 
 int kvm_setup_default_irq_routing(struct kvm *kvm)
 {
+	/*
+	 * 在以下调用kvm_set_irq_routing():
+	 *   - arch/arm64/kvm/vgic/vgic-irqfd.c|152| <<kvm_vgic_setup_default_irq_routing>> ret = kvm_set_irq_routing(kvm, entries, nr, 0);
+	 *   - arch/powerpc/kvm/mpic.c|1649| <<mpic_set_default_irq_routing>> kvm_set_irq_routing(opp->kvm, routing, 0, 0);
+	 *   - arch/s390/kvm/kvm-s390.c|2435| <<kvm_arch_vm_ioctl>> r = kvm_set_irq_routing(kvm, &routing, 0, 0);
+	 *   - arch/x86/kvm/irq_comm.c|393| <<kvm_setup_default_irq_routing>> return kvm_set_irq_routing(kvm, default_routing, ARRAY_SIZE(default_routing), 0);
+	 *   - arch/x86/kvm/irq_comm.c|401| <<kvm_setup_empty_irq_routing>> return kvm_set_irq_routing(kvm, empty_routing, 0, 0);
+	 *   - virt/kvm/kvm_main.c|4638| <<kvm_vm_ioctl(KVM_SET_GSI_ROUTING)>> r = kvm_set_irq_routing(kvm, entries, routing.nr, routing.flags);
+	 */
 	return kvm_set_irq_routing(kvm, default_routing,
 				   ARRAY_SIZE(default_routing), 0);
 }
@@ -380,6 +490,15 @@ static const struct kvm_irq_routing_entry empty_routing[] = {};
 
 int kvm_setup_empty_irq_routing(struct kvm *kvm)
 {
+	/*
+	 * 在以下调用kvm_set_irq_routing():
+	 *   - arch/arm64/kvm/vgic/vgic-irqfd.c|152| <<kvm_vgic_setup_default_irq_routing>> ret = kvm_set_irq_routing(kvm, entries, nr, 0);
+	 *   - arch/powerpc/kvm/mpic.c|1649| <<mpic_set_default_irq_routing>> kvm_set_irq_routing(opp->kvm, routing, 0, 0);
+	 *   - arch/s390/kvm/kvm-s390.c|2435| <<kvm_arch_vm_ioctl>> r = kvm_set_irq_routing(kvm, &routing, 0, 0);
+	 *   - arch/x86/kvm/irq_comm.c|393| <<kvm_setup_default_irq_routing>> return kvm_set_irq_routing(kvm, default_routing, ARRAY_SIZE(default_routing), 0);
+	 *   - arch/x86/kvm/irq_comm.c|401| <<kvm_setup_empty_irq_routing>> return kvm_set_irq_routing(kvm, empty_routing, 0, 0);
+	 *   - virt/kvm/kvm_main.c|4638| <<kvm_vm_ioctl(KVM_SET_GSI_ROUTING)>> r = kvm_set_irq_routing(kvm, entries, routing.nr, routing.flags);
+	 */
 	return kvm_set_irq_routing(kvm, empty_routing, 0, 0);
 }
 
@@ -387,9 +506,32 @@ void kvm_arch_post_irq_routing_update(struct kvm *kvm)
 {
 	if (!irqchip_split(kvm))
 		return;
+	/*
+	 * 在以下使用kvm_make_scan_ioapic_request():
+	 *   - arch/x86/kvm/ioapic.c|345| <<kvm_arch_post_irq_ack_notifier_list_update>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/ioapic.c|442| <<ioapic_write_indirect>> kvm_make_scan_ioapic_request(ioapic->kvm);
+	 *   - arch/x86/kvm/ioapic.c|879| <<kvm_set_ioapic>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/irq_comm.c|408| <<kvm_arch_post_irq_routing_update>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/lapic.c|436| <<kvm_recalculate_apic_map>> kvm_make_scan_ioapic_request(kvm);
+	 */
 	kvm_make_scan_ioapic_request(kvm);
 }
 
+/*
+ * 在以下使用ioapic_handled_vectors:
+ *   - arch/x86/kvm/lapic.c|1614| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+ *   - arch/x86/kvm/x86.c|10020| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+ *   - arch/x86/kvm/x86.c|10025| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+ *   - arch/x86/kvm/x86.c|10027| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+ *   - arch/x86/kvm/x86.c|10044| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap,
+ *              vcpu->arch.ioapic_handled_vectors, to_hv_synic(vcpu)->vec_bitmap, 256);
+ *   - arch/x86/kvm/x86.c|10051| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+ *   - arch/x86/kvm/x86.c|10193| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+ *
+ *
+ * 在以下使用kvm_scan_ioapic_routes():
+ *   - arch/x86/kvm/x86.c|10036| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+ */
 void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,
 			    ulong *ioapic_handled_vectors)
 {
@@ -400,7 +542,41 @@ void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,
 	int idx;
 
 	idx = srcu_read_lock(&kvm->irq_srcu);
+	/*
+	 * 在以下使用kvm->irq_routing:
+	 *   - arch/x86/kvm/hyperv.c|531| <<kvm_hv_irq_routing_update>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - arch/x86/kvm/irq_comm.c|469| <<kvm_scan_ioapic_routes>> table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/svm/avic.c|929| <<avic_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|291| <<vmx_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|60| <<kvm_irq_map_gsi>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - virt/kvm/irqchip.c|88| <<kvm_irq_map_chip_pin>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|222| <<kvm_free_irq_routing>> struct kvm_irq_routing_table *rt = rcu_access_pointer(kvm->irq_routing);
+	 *   - virt/kvm/irqchip.c|421| <<kvm_set_irq_routing>> old = rcu_dereference_protected(kvm->irq_routing, 1);
+	 *   - virt/kvm/irqchip.c|422| <<kvm_set_irq_routing>> rcu_assign_pointer(kvm->irq_routing, new);
+	 */
 	table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	/*
+	 * 在以下使用kvm_arch->nr_reserved_ioapic_pins:
+	 *   - arch/x86/kvm/irq_comm.c|446| <<kvm_scan_ioapic_routes>> nr_ioapic_pins =
+	 *               min_t(u32, table->nr_rt_entries, kvm->arch.nr_reserved_ioapic_pins);
+	 *   - arch/x86/kvm/x86.c|5874| <<kvm_vm_ioctl_enable_cap(KVM_CAP_SPLIT_IRQCHIP)>>
+	 *               kvm->arch.nr_reserved_ioapic_pins = cap->args[0];
+	 *
+	 * 在以下使用kvm_irq_routing_table->nr_rt_entries:
+	 *   - arch/x86/kvm/hyperv.c|534| <<kvm_hv_irq_routing_update>> for (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {
+	 *   - arch/x86/kvm/irq_comm.c|430| <<kvm_scan_ioapic_routes>> nr_ioapic_pins = min_t(u32, table->nr_rt_entries,
+	 *                  kvm->arch.nr_reserved_ioapic_pins);
+	 *   - arch/x86/kvm/svm/avic.c|931| <<avic_pi_update_irte>> if (guest_irq >= irq_rt->nr_rt_entries || hlist_empty(&irq_rt->map[guest_irq])) {
+	 *   - arch/x86/kvm/svm/avic.c|934| <<avic_pi_update_irte>> pr_warn_once("no route for guest_irq %u/%u (broken user space?)\n",
+	 *                  guest_irq, irq_rt->nr_rt_entries);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|292| <<vmx_pi_update_irte>> if (guest_irq >= irq_rt->nr_rt_entries || hlist_empty(&irq_rt->map[guest_irq])) {
+	 *   - arch/x86/kvm/vmx/posted_intr.c|295| <<vmx_pi_update_irte>> pr_warn_once("no route for guest_irq %u/%u (broken user space?)\n",
+	 *                  guest_irq, irq_rt->nr_rt_entries);
+	 *   - virt/kvm/irqchip.c|31| <<kvm_irq_map_gsi>> if (irq_rt && gsi < irq_rt->nr_rt_entries) {
+	 *   - virt/kvm/irqchip.c|34| <<kvm_irq_map_gsi>> index = array_index_nospec(gsi, irq_rt->nr_rt_entries);
+	 *   - virt/kvm/irqchip.c|111| <<free_irq_routing_table>> for (i = 0; i < rt->nr_rt_entries; ++i) {
+	 *   - virt/kvm/irqchip.c|195| <<kvm_set_irq_routing>> new->nr_rt_entries = nr_rt_entries;
+	 */
 	nr_ioapic_pins = min_t(u32, table->nr_rt_entries,
 			       kvm->arch.nr_reserved_ioapic_pins);
 	for (i = 0; i < nr_ioapic_pins; ++i) {
@@ -422,6 +598,10 @@ void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,
 	srcu_read_unlock(&kvm->irq_srcu, idx);
 }
 
+/*
+ * 在以下使用kvm_arch_irq_routing_update():
+ *   - virt/kvm/irqchip.c|227| <<kvm_set_irq_routing>> kvm_arch_irq_routing_update(kvm);
+ */
 void kvm_arch_irq_routing_update(struct kvm *kvm)
 {
 	kvm_hv_irq_routing_update(kvm);
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 43c2722ef25e..e3135bb5987d 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -43,6 +43,13 @@
 #include "cpuid.h"
 #include "hyperv.h"
 
+/*
+ * 下面两个函数很重要.
+ *
+ * vmx_inject_irq()
+ * vmx_hwapic_isr_update()
+ */
+
 #ifndef CONFIG_X86_64
 #define mod_64(x, y) ((x) - (y) * div64_u64(x, y))
 #else
@@ -76,6 +83,40 @@ static inline void __kvm_lapic_set_reg(char *regs, int reg_off, u32 val)
 	*((u32 *) (regs + reg_off)) = val;
 }
 
+/*
+ * 在以下使用kvm_lapic_set_reg():
+ *   - arch/x86/kvm/lapic.c|358| <<apic_set_spiv>> kvm_lapic_set_reg(apic, APIC_SPIV, val);
+ *   - arch/x86/kvm/lapic.c|388| <<kvm_apic_set_xapic_id>> kvm_lapic_set_reg(apic, APIC_ID, id << 24);
+ *   - arch/x86/kvm/lapic.c|394| <<kvm_apic_set_ldr>> kvm_lapic_set_reg(apic, APIC_LDR, id);
+ *   - arch/x86/kvm/lapic.c|400| <<kvm_apic_set_dfr>> kvm_lapic_set_reg(apic, APIC_DFR, val);
+ *   - arch/x86/kvm/lapic.c|415| <<kvm_apic_set_x2apic_id>> kvm_lapic_set_reg(apic, APIC_ID, id);
+ *   - arch/x86/kvm/lapic.c|416| <<kvm_apic_set_x2apic_id>> kvm_lapic_set_reg(apic, APIC_LDR, ldr);
+ *   - arch/x86/kvm/lapic.c|463| <<kvm_apic_set_version>> kvm_lapic_set_reg(apic, APIC_LVR, v);
+ *   - arch/x86/kvm/lapic.c|817| <<__apic_update_ppr>> kvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);
+ *   - arch/x86/kvm/lapic.c|839| <<apic_set_tpr>> kvm_lapic_set_reg(apic, APIC_TASKPRI, tpr);
+ *   - arch/x86/kvm/lapic.c|1614| <<apic_update_lvtt>> kvm_lapic_set_reg(apic, APIC_TMICT, 0);
+ *   - arch/x86/kvm/lapic.c|1876| <<set_target_expiration>> kvm_lapic_set_reg(apic, count_reg, 0);
+ *   - arch/x86/kvm/lapic.c|2145| <<kvm_lapic_reg_write>> kvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,
+ *   - arch/x86/kvm/lapic.c|2160| <<kvm_lapic_reg_write>> kvm_lapic_set_reg(apic, APIC_ICR, val);
+ *   - arch/x86/kvm/lapic.c|2166| <<kvm_lapic_reg_write>> kvm_lapic_set_reg(apic, APIC_ICR2, val & 0xff000000);
+ *   - arch/x86/kvm/lapic.c|2186| <<kvm_lapic_reg_write>> kvm_lapic_set_reg(apic, reg, val);
+ *   - arch/x86/kvm/lapic.c|2194| <<kvm_lapic_reg_write>> kvm_lapic_set_reg(apic, APIC_LVTT, val);
+ *   - arch/x86/kvm/lapic.c|2203| <<kvm_lapic_reg_write>> kvm_lapic_set_reg(apic, APIC_TMICT, val);
+ *   - arch/x86/kvm/lapic.c|2210| <<kvm_lapic_reg_write>> kvm_lapic_set_reg(apic, APIC_TDCR, val & 0xb);
+ *   - arch/x86/kvm/lapic.c|2476| <<kvm_lapic_reset>> kvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);
+ *   - arch/x86/kvm/lapic.c|2480| <<kvm_lapic_reset>> kvm_lapic_set_reg(apic, APIC_LVT0,
+ *   - arch/x86/kvm/lapic.c|2486| <<kvm_lapic_reset>> kvm_lapic_set_reg(apic, APIC_TASKPRI, 0);
+ *   - arch/x86/kvm/lapic.c|2489| <<kvm_lapic_reset>> kvm_lapic_set_reg(apic, APIC_ESR, 0);
+ *   - arch/x86/kvm/lapic.c|2491| <<kvm_lapic_reset>> kvm_lapic_set_reg(apic, APIC_ICR, 0);
+ *   - arch/x86/kvm/lapic.c|2492| <<kvm_lapic_reset>> kvm_lapic_set_reg(apic, APIC_ICR2, 0);
+ *   - arch/x86/kvm/lapic.c|2496| <<kvm_lapic_reset>> kvm_lapic_set_reg(apic, APIC_TDCR, 0);
+ *   - arch/x86/kvm/lapic.c|2497| <<kvm_lapic_reset>> kvm_lapic_set_reg(apic, APIC_TMICT, 0);
+ *   - arch/x86/kvm/lapic.c|2499| <<kvm_lapic_reset>> kvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);
+ *   - arch/x86/kvm/lapic.c|2500| <<kvm_lapic_reset>> kvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);
+ *   - arch/x86/kvm/lapic.c|2501| <<kvm_lapic_reset>> kvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);
+ *   - arch/x86/kvm/lapic.c|2556| <<kvm_apic_local_deliver>> kvm_lapic_set_reg(apic, APIC_LVTPC, reg | APIC_LVT_MASKED);
+ *   - arch/x86/kvm/lapic.c|2800| <<kvm_apic_set_state>> kvm_lapic_set_reg(apic, APIC_TMCCT, 0);
+ */
 static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)
 {
 	__kvm_lapic_set_reg(apic->regs, reg_off, val);
@@ -92,6 +133,11 @@ static __always_inline u64 kvm_lapic_get_reg64(struct kvm_lapic *apic, int reg)
 	return __kvm_lapic_get_reg64(apic->regs, reg);
 }
 
+/*
+ * 在以下调用kvm_lapic_set_reg64():
+ *   - arch/x86/kvm/lapic.c|2494| <<kvm_lapic_reset>> kvm_lapic_set_reg64(apic, APIC_ICR, 0);
+ *   - arch/x86/kvm/lapic.c|2956| <<kvm_x2apic_icr_write>> kvm_lapic_set_reg64(apic, APIC_ICR, data);
+ */
 static __always_inline void __kvm_lapic_set_reg64(char *regs, int reg, u64 val)
 {
 	BUILD_BUG_ON(reg != APIC_ICR);
@@ -109,6 +155,13 @@ static inline int apic_test_vector(int vec, void *bitmap)
 	return test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
 }
 
+/*
+ * 在以下调用kvm_apic_pending_eoi():
+ *   - arch/x86/kvm/ioapic.c|123| <<__rtc_irq_eoi_tracking_restore_one>> new_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);
+ *   - arch/x86/kvm/ioapic.c|195| <<ioapic_lazy_update_eoi>> kvm_apic_pending_eoi(vcpu, entry->fields.vector))
+ *   - arch/x86/kvm/ioapic.c|302| <<kvm_ioapic_scan_entry>> kvm_apic_pending_eoi(vcpu, e->fields.vector))
+ *   - arch/x86/kvm/irq_comm.c|418| <<kvm_scan_ioapic_routes>> kvm_apic_pending_eoi(vcpu, irq.vector)))
+ */
 bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
@@ -127,7 +180,28 @@ static inline int __apic_test_and_clear_vector(int vec, void *bitmap)
 	return __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
 }
 
+/*
+ * 在以下使用apic_hw_disabled:
+ *   - arch/x86/kvm/lapic.c|130| <<global>> __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_hw_disabled, HZ);
+ *   - arch/x86/kvm/lapic.c|2323| <<kvm_free_lapic>> static_branch_slow_dec_deferred(&apic_hw_disabled);
+ *   - arch/x86/kvm/lapic.c|2403| <<kvm_lapic_set_base>> static_branch_slow_dec_deferred(&apic_hw_disabled);
+ *   - arch/x86/kvm/lapic.c|2407| <<kvm_lapic_set_base>> static_branch_inc(&apic_hw_disabled.key);
+ *   - arch/x86/kvm/lapic.c|3130| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_hw_disabled);
+ *   - arch/x86/kvm/lapic.c|3131| <<kvm_lapic_exit>> WARN_ON(static_branch_unlikely(&apic_hw_disabled.key));
+ *   - arch/x86/kvm/lapic.h|180| <<kvm_apic_hw_enabled>> if (static_branch_unlikely(&apic_hw_disabled.key))
+ */
 __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_hw_disabled, HZ);
+/*
+ * 在以下使用apic_sw_disabled:
+ *   - arch/x86/kvm/lapic.c|131| <<global>> __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_sw_disabled, HZ);
+ *   - arch/x86/kvm/lapic.c|352| <<apic_set_spiv>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+ *   - arch/x86/kvm/lapic.c|354| <<apic_set_spiv>> static_branch_inc(&apic_sw_disabled.key);
+ *   - arch/x86/kvm/lapic.c|2304| <<kvm_free_lapic>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+ *   - arch/x86/kvm/lapic.c|2593| <<kvm_create_lapic>> static_branch_inc(&apic_sw_disabled.key);
+ *   - arch/x86/kvm/lapic.c|3084| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_sw_disabled);
+ *   - arch/x86/kvm/lapic.c|3085| <<kvm_lapic_exit>> WARN_ON(static_branch_unlikely(&apic_sw_disabled.key));
+ *   - arch/x86/kvm/lapic.h|189| <<kvm_apic_sw_enabled>> if (static_branch_unlikely(&apic_sw_disabled.key))
+ */
 __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_sw_disabled, HZ);
 
 static inline int apic_enabled(struct kvm_lapic *apic)
@@ -149,6 +223,14 @@ static inline u32 kvm_x2apic_id(struct kvm_lapic *apic)
 
 static bool kvm_can_post_timer_interrupt(struct kvm_vcpu *vcpu)
 {
+	/*
+	 * 在以下使用pi_inject_timer:
+	 *   - arch/x86/kvm/x86.c|188| <<global>> int __read_mostly pi_inject_timer = -1;
+	 *   - arch/x86/kvm/x86.c|189| <<global>> module_param(pi_inject_timer, bint, S_IRUGO | S_IWUSR);
+	 *   - arch/x86/kvm/lapic.c|163| <<kvm_can_post_timer_interrupt>> return pi_inject_timer && kvm_vcpu_apicv_active(vcpu) &&
+	 *   - arch/x86/kvm/x86.c|8848| <<kvm_arch_init>> if (pi_inject_timer == -1)
+	 *   - arch/x86/kvm/x86.c|8849| <<kvm_arch_init>> pi_inject_timer = housekeeping_enabled(HK_FLAG_TIMER);
+	 */
 	return pi_inject_timer && kvm_vcpu_apicv_active(vcpu) &&
 		(kvm_mwait_in_guest(vcpu->kvm) || kvm_hlt_in_guest(vcpu->kvm));
 }
@@ -161,11 +243,20 @@ bool kvm_can_use_hv_timer(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_can_use_hv_timer);
 
+/*
+ * 在以下使用kvm_use_posted_timer_interrupt():
+ *   - arch/x86/kvm/lapic.c|1760| <<apic_timer_expired>> if (kvm_use_posted_timer_interrupt(apic->vcpu)) {
+ */
 static bool kvm_use_posted_timer_interrupt(struct kvm_vcpu *vcpu)
 {
 	return kvm_can_post_timer_interrupt(vcpu) && vcpu->mode == IN_GUEST_MODE;
 }
 
+/*
+ * 在以下使用kvm_apic_map_get_logical_dest():
+ *   - arch/x86/kvm/lapic.c|325| <<kvm_recalculate_apic_map>> if (!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))
+ *   - arch/x86/kvm/lapic.c|1028| <<kvm_apic_map_get_dest_lapic>> if (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,
+ */
 static inline bool kvm_apic_map_get_logical_dest(struct kvm_apic_map *map,
 		u32 dest_id, struct kvm_lapic ***cluster, u16 *mask) {
 	switch (map->mode) {
@@ -311,6 +402,11 @@ void kvm_recalculate_apic_map(struct kvm *kvm)
 				new->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;
 		}
 
+		/*
+		 * 在以下使用kvm_apic_map_get_logical_dest():
+		 *   - arch/x86/kvm/lapic.c|325| <<kvm_recalculate_apic_map>> if (!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))
+		 *   - arch/x86/kvm/lapic.c|1028| <<kvm_apic_map_get_dest_lapic>> if (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,
+		 */
 		if (!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))
 			continue;
 
@@ -337,6 +433,14 @@ void kvm_recalculate_apic_map(struct kvm *kvm)
 	if (old)
 		call_rcu(&old->rcu, kvm_apic_map_free);
 
+	/*
+	 * 在以下使用kvm_make_scan_ioapic_request():
+	 *   - arch/x86/kvm/ioapic.c|345| <<kvm_arch_post_irq_ack_notifier_list_update>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/ioapic.c|442| <<ioapic_write_indirect>> kvm_make_scan_ioapic_request(ioapic->kvm);
+	 *   - arch/x86/kvm/ioapic.c|879| <<kvm_set_ioapic>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/irq_comm.c|408| <<kvm_arch_post_irq_routing_update>> kvm_make_scan_ioapic_request(kvm);
+	 *   - arch/x86/kvm/lapic.c|436| <<kvm_recalculate_apic_map>> kvm_make_scan_ioapic_request(kvm);
+	 */
 	kvm_make_scan_ioapic_request(kvm);
 }
 
@@ -348,6 +452,17 @@ static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)
 
 	if (enabled != apic->sw_enabled) {
 		apic->sw_enabled = enabled;
+		/*
+		 * 在以下使用apic_sw_disabled:
+		 *   - arch/x86/kvm/lapic.c|131| <<global>> __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_sw_disabled, HZ);
+		 *   - arch/x86/kvm/lapic.c|352| <<apic_set_spiv>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+		 *   - arch/x86/kvm/lapic.c|354| <<apic_set_spiv>> static_branch_inc(&apic_sw_disabled.key);
+		 *   - arch/x86/kvm/lapic.c|2304| <<kvm_free_lapic>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+		 *   - arch/x86/kvm/lapic.c|2593| <<kvm_create_lapic>> static_branch_inc(&apic_sw_disabled.key);
+		 *   - arch/x86/kvm/lapic.c|3084| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_sw_disabled);
+		 *   - arch/x86/kvm/lapic.c|3085| <<kvm_lapic_exit>> WARN_ON(static_branch_unlikely(&apic_sw_disabled.key));
+		 *   - arch/x86/kvm/lapic.h|189| <<kvm_apic_sw_enabled>> if (static_branch_unlikely(&apic_sw_disabled.key))
+		 */
 		if (enabled)
 			static_branch_slow_dec_deferred(&apic_sw_disabled);
 		else
@@ -379,11 +494,20 @@ static inline void kvm_apic_set_dfr(struct kvm_lapic *apic, u32 val)
 	atomic_set_release(&apic->vcpu->kvm->arch.apic_map_dirty, DIRTY);
 }
 
+/*
+ * 在以下使用kvm_apic_calc_x2apic_ldr():
+ *   - arch/x86/kvm/lapic.c|482| <<kvm_apic_set_x2apic_id>> u32 ldr = kvm_apic_calc_x2apic_ldr(id);
+ *   - arch/x86/kvm/lapic.c|2836| <<kvm_apic_state_fixup>> *ldr = kvm_apic_calc_x2apic_ldr(*id);
+ */
 static inline u32 kvm_apic_calc_x2apic_ldr(u32 id)
 {
 	return ((id >> 4) << 16) | (1 << (id & 0xf));
 }
 
+/*
+ * 在以下使用kvm_apic_set_x2apic_id():
+ *   - arch/x86/kvm/lapic.c|2504| <<kvm_lapic_set_base>> kvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);
+ */
 static inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u32 id)
 {
 	u32 ldr = kvm_apic_calc_x2apic_ldr(id);
@@ -415,6 +539,10 @@ static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)
 	return apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;
 }
 
+/*
+ * 在以下使用apic_lvt_nmi_mode():
+ *   - arch/x86/kvm/lapic.c|2155| <<apic_manage_nmi_watchdog>> bool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);
+ */
 static inline int apic_lvt_nmi_mode(u32 lvt_val)
 {
 	return (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;
@@ -449,6 +577,11 @@ static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {
 	LVT_MASK		/* LVTERR */
 };
 
+/*
+ * 在以下调用find_highest_vector():
+ *   - arch/x86/kvm/lapic.c|623| <<apic_search_irr>> return find_highest_vector(apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.c|709| <<apic_find_highest_isr>> result = find_highest_vector(apic->regs + APIC_ISR);
+ */
 static int find_highest_vector(void *bitmap)
 {
 	int vec;
@@ -478,6 +611,15 @@ static u8 count_vectors(void *bitmap)
 	return count;
 }
 
+/*
+ * 在以下使用__kvm_apic_update_irr():
+ *   - arch/x86/kvm/lapic.c|638| <<kvm_apic_update_irr>> bool irr_updated = __kvm_apic_update_irr(pir, apic->regs, max_irr);
+ *   - arch/x86/kvm/vmx/nested.c|3818| <<vmx_complete_nested_posted_interrupt>> __kvm_apic_update_irr(vmx->nested.pi_desc->pir,
+ *
+ * vmx_sync_pir_to_irr()
+ * -> kvm_apic_update_irr()
+ *    -> __kvm_apic_update_irr()
+ */
 bool __kvm_apic_update_irr(u32 *pir, void *regs, int *max_irr)
 {
 	u32 i, vec;
@@ -514,9 +656,22 @@ bool __kvm_apic_update_irr(u32 *pir, void *regs, int *max_irr)
 }
 EXPORT_SYMBOL_GPL(__kvm_apic_update_irr);
 
+/*
+ * 在以下调用kvm_apic_update_irr():
+ *   - arch/x86/kvm/vmx/vmx.c|6519| <<vmx_sync_pir_to_irr>> kvm_apic_update_irr(vcpu, vmx->pi_desc.pir, &max_irr);
+ *
+ * vmx_sync_pir_to_irr()
+ * -> kvm_apic_update_irr()
+ *    -> __kvm_apic_update_irr()
+ */
 bool kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir, int *max_irr)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
+	/*
+	 * 在以下使用__kvm_apic_update_irr():
+	 *   - arch/x86/kvm/lapic.c|638| <<kvm_apic_update_irr>> bool irr_updated = __kvm_apic_update_irr(pir, apic->regs, max_irr);
+	 *   - arch/x86/kvm/vmx/nested.c|3818| <<vmx_complete_nested_posted_interrupt>> __kvm_apic_update_irr(vmx->nested.pi_desc->pir,
+	 */
 	bool irr_updated = __kvm_apic_update_irr(pir, apic->regs, max_irr);
 
 	if (unlikely(!vcpu->arch.apicv_active && irr_updated))
@@ -527,9 +682,22 @@ EXPORT_SYMBOL_GPL(kvm_apic_update_irr);
 
 static inline int apic_search_irr(struct kvm_lapic *apic)
 {
+	/*
+	 * 在以下调用find_highest_vector():
+	 *   - arch/x86/kvm/lapic.c|623| <<apic_search_irr>> return find_highest_vector(apic->regs + APIC_IRR);
+	 *   - arch/x86/kvm/lapic.c|709| <<apic_find_highest_isr>> result = find_highest_vector(apic->regs + APIC_ISR);
+	 */
 	return find_highest_vector(apic->regs + APIC_IRR);
 }
 
+/*
+ * 在以下使用apic_find_highest_irr():
+ *   - arch/x86/kvm/lapic.c|710| <<apic_clear_irr>> apic_find_highest_irr(apic));
+ *   - arch/x86/kvm/lapic.c|844| <<kvm_lapic_find_highest_irr>> return apic_find_highest_irr(vcpu->arch.apic);
+ *   - arch/x86/kvm/lapic.c|962| <<apic_has_interrupt_for_ppr>> highest_irr = apic_find_highest_irr(apic);
+ *   - arch/x86/kvm/lapic.c|3310| <<kvm_apic_set_state>> apic_find_highest_irr(apic));
+ *   - arch/x86/kvm/lapic.c|3433| <<kvm_lapic_sync_to_vapic>> max_irr = apic_find_highest_irr(apic);
+ */
 static inline int apic_find_highest_irr(struct kvm_lapic *apic)
 {
 	int result;
@@ -547,6 +715,11 @@ static inline int apic_find_highest_irr(struct kvm_lapic *apic)
 	return result;
 }
 
+/*
+ * 在以下调用apic_clear_irr():
+ *   - arch/x86/kvm/lapic.c|694| <<kvm_apic_clear_irr>> apic_clear_irr(vec, vcpu->arch.apic);
+ *   - arch/x86/kvm/lapic.c|3120| <<kvm_get_apic_interrupt>> apic_clear_irr(vector, apic);
+ */
 static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)
 {
 	struct kvm_vcpu *vcpu;
@@ -566,12 +739,29 @@ static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)
 	}
 }
 
+/*
+ * 在以下调用kvm_apic_clear_irr():
+ *   - arch/x86/kvm/vmx/nested.c|3616| <<nested_vmx_run>> kvm_apic_clear_irr(vcpu, vmx->nested.posted_intr_nv);
+ */
 void kvm_apic_clear_irr(struct kvm_vcpu *vcpu, int vec)
 {
 	apic_clear_irr(vec, vcpu->arch.apic);
 }
 EXPORT_SYMBOL_GPL(kvm_apic_clear_irr);
 
+/*
+ * 在以下使用apic_set_isr():
+ *   - arch/x86/kvm/lapic.c|3116| <<kvm_get_apic_interrupt>> apic_set_isr(vector, apic);
+ *
+ * vcpu_enter_guest()
+ * -> if (kvm_cpu_has_injectable_intr(vcpu)) {
+ *      inject_pending_event()
+ *      -> kvm_cpu_get_interrupt()
+ *         -> kvm_get_apic_interrupt()
+ *            -> apic_set_isr()
+ *
+ * 注意kvm_cpu_has_injectable_intr()
+ */
 static inline void apic_set_isr(int vec, struct kvm_lapic *apic)
 {
 	struct kvm_vcpu *vcpu;
@@ -586,6 +776,9 @@ static inline void apic_set_isr(int vec, struct kvm_lapic *apic)
 	 * because the processor can modify ISR under the hood.  Instead
 	 * just set SVI.
 	 */
+	/*
+	 * vmx_hwapic_isr_update()
+	 */
 	if (unlikely(vcpu->arch.apicv_active))
 		static_call(kvm_x86_hwapic_isr_update)(vcpu, vec);
 	else {
@@ -600,6 +793,14 @@ static inline void apic_set_isr(int vec, struct kvm_lapic *apic)
 	}
 }
 
+/*
+ * 在以下使用apic_find_highest_isr():
+ *   - arch/x86/kvm/lapic.c|781| <<apic_clear_isr>> apic_find_highest_isr(apic));
+ *   - arch/x86/kvm/lapic.c|927| <<__apic_update_ppr>> isr = apic_find_highest_isr(apic);
+ *   - arch/x86/kvm/lapic.c|1494| <<apic_set_eoi>> int vector = apic_find_highest_isr(apic);
+ *   - arch/x86/kvm/lapic.c|3225| <<kvm_apic_set_state>> apic_find_highest_isr(apic));
+ *   - arch/x86/kvm/lapic.c|3344| <<kvm_lapic_sync_to_vapic>> max_isr = apic_find_highest_isr(apic);
+ */
 static inline int apic_find_highest_isr(struct kvm_lapic *apic)
 {
 	int result;
@@ -613,15 +814,28 @@ static inline int apic_find_highest_isr(struct kvm_lapic *apic)
 	if (likely(apic->highest_isr_cache != -1))
 		return apic->highest_isr_cache;
 
+	/*
+	 * 在以下调用find_highest_vector():
+	 *   - arch/x86/kvm/lapic.c|623| <<apic_search_irr>> return find_highest_vector(apic->regs + APIC_IRR);
+	 *   - arch/x86/kvm/lapic.c|709| <<apic_find_highest_isr>> result = find_highest_vector(apic->regs + APIC_ISR);
+	 */
 	result = find_highest_vector(apic->regs + APIC_ISR);
 	ASSERT(result == -1 || result >= 16);
 
 	return result;
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/lapic.c|1667| <<apic_set_eoi>> apic_clear_isr(vector, apic);
+ */
 static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)
 {
 	struct kvm_vcpu *vcpu;
+	/*
+	 * 注释
+	 * clear a bit and return old value
+	 */
 	if (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))
 		return;
 
@@ -634,6 +848,9 @@ static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)
 	 * on the other hand isr_count and highest_isr_cache are unused
 	 * and must be left alone.
 	 */
+	/*
+	 * vmx_hwapic_isr_update()
+	 */
 	if (unlikely(vcpu->arch.apicv_active))
 		static_call(kvm_x86_hwapic_isr_update)(vcpu,
 						apic_find_highest_isr(apic));
@@ -644,6 +861,11 @@ static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)
 	}
 }
 
+/*
+ * 在以下使用kvm_lapic_find_highest_irr():
+ *   - arch/x86/kvm/vmx/vmx.c|6562| <<vmx_sync_pir_to_irr>> max_irr = kvm_lapic_find_highest_irr(vcpu);
+ *   - arch/x86/kvm/x86.c|9322| <<update_cr8_intercept>> max_irr = kvm_lapic_find_highest_irr(vcpu);
+ */
 int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)
 {
 	/* This may race with setting of irr in __apic_accept_irq() and
@@ -651,6 +873,14 @@ int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)
 	 * will cause vmexit immediately and the value will be recalculated
 	 * on the next vmentry.
 	 */
+	/*
+	 * 在以下使用apic_find_highest_irr():
+	 *   - arch/x86/kvm/lapic.c|710| <<apic_clear_irr>> apic_find_highest_irr(apic));
+	 *   - arch/x86/kvm/lapic.c|844| <<kvm_lapic_find_highest_irr>> return apic_find_highest_irr(vcpu->arch.apic);
+	 *   - arch/x86/kvm/lapic.c|962| <<apic_has_interrupt_for_ppr>> highest_irr = apic_find_highest_irr(apic);
+	 *   - arch/x86/kvm/lapic.c|3310| <<kvm_apic_set_state>> apic_find_highest_irr(apic));
+	 *   - arch/x86/kvm/lapic.c|3433| <<kvm_lapic_sync_to_vapic>> max_irr = apic_find_highest_irr(apic);
+	 */
 	return apic_find_highest_irr(vcpu->arch.apic);
 }
 EXPORT_SYMBOL_GPL(kvm_lapic_find_highest_irr);
@@ -659,6 +889,17 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 			     int vector, int level, int trig_mode,
 			     struct dest_map *dest_map);
 
+/*
+ * 在以下使用kvm_apic_set_irq():
+ *   - arch/x86/kvm/hyperv.c|828| <<stimer_notify_direct>> return !kvm_apic_set_irq(vcpu, &irq, NULL);
+ *   - arch/x86/kvm/hyperv.c|1899| <<kvm_send_ipi_to_many>> kvm_apic_set_irq(vcpu, &irq, NULL);
+ *   - arch/x86/kvm/irq_comm.c|88| <<kvm_irq_delivery_to_apic>> r += kvm_apic_set_irq(vcpu, irq, dest_map);
+ *   - arch/x86/kvm/irq_comm.c|110| <<kvm_irq_delivery_to_apic>> r = kvm_apic_set_irq(lowest, irq, dest_map);
+ *   - arch/x86/kvm/lapic.c|914| <<__pv_send_ipi>> count += kvm_apic_set_irq(vcpu, irq, NULL);
+ *   - arch/x86/kvm/lapic.c|1332| <<kvm_irq_delivery_to_apic_fast>> *r = kvm_apic_set_irq(src->vcpu, irq, dest_map);
+ *   - arch/x86/kvm/lapic.c|1345| <<kvm_irq_delivery_to_apic_fast>> *r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);
+ *   - arch/x86/kvm/x86.c|12888| <<kvm_arch_async_page_present>> kvm_apic_set_irq(vcpu, &irq, NULL);
+ */
 int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,
 		     struct dest_map *dest_map)
 {
@@ -735,6 +976,18 @@ static int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)
 
 static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)
 {
+	/*
+	 *     pv_eoi = {
+         *       msr_val = 0,
+         *        data = {
+         *          generation = 0,
+         *          gpa = 0,
+         *          hva = 0,
+         *          len = 0,
+         *          memslot = 0x0
+         *        }
+         *     },
+	 */
 	return vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;
 }
 
@@ -763,9 +1016,22 @@ static void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)
 	__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);
 }
 
+/*
+ * 在以下使用apic_has_interrupt_for_ppr():
+ *   - arch/x86/kvm/lapic.c|1024| <<apic_update_ppr>> apic_has_interrupt_for_ppr(apic, ppr) != -1)
+ *   - arch/x86/kvm/lapic.c|3169| <<kvm_apic_has_interrupt>> return apic_has_interrupt_for_ppr(apic, ppr);
+ */
 static int apic_has_interrupt_for_ppr(struct kvm_lapic *apic, u32 ppr)
 {
 	int highest_irr;
+	/*
+	 * 在以下使用apic_find_highest_irr():
+	 *   - arch/x86/kvm/lapic.c|710| <<apic_clear_irr>> apic_find_highest_irr(apic));
+	 *   - arch/x86/kvm/lapic.c|844| <<kvm_lapic_find_highest_irr>> return apic_find_highest_irr(vcpu->arch.apic);
+	 *   - arch/x86/kvm/lapic.c|962| <<apic_has_interrupt_for_ppr>> highest_irr = apic_find_highest_irr(apic);
+	 *   - arch/x86/kvm/lapic.c|3310| <<kvm_apic_set_state>> apic_find_highest_irr(apic));
+	 *   - arch/x86/kvm/lapic.c|3433| <<kvm_lapic_sync_to_vapic>> max_irr = apic_find_highest_irr(apic);
+	 */
 	if (kvm_x86_ops.sync_pir_to_irr)
 		highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
 	else
@@ -797,10 +1063,30 @@ static bool __apic_update_ppr(struct kvm_lapic *apic, u32 *new_ppr)
 	return ppr < old_ppr;
 }
 
+/*
+ * 在以下调用apic_update_ppr():
+ *   - arch/x86/kvm/lapic.c|1030| <<kvm_apic_update_ppr>> apic_update_ppr(vcpu->arch.apic);
+ *   - arch/x86/kvm/lapic.c|1037| <<apic_set_tpr>> apic_update_ppr(apic);
+ *   - arch/x86/kvm/lapic.c|1602| <<apic_set_eoi>> apic_update_ppr(apic);
+ *   - arch/x86/kvm/lapic.c|1729| <<__apic_read>> apic_update_ppr(apic);
+ *   - arch/x86/kvm/lapic.c|3005| <<kvm_lapic_reset>> apic_update_ppr(apic);
+ *   - arch/x86/kvm/lapic.c|3231| <<kvm_get_apic_interrupt>> apic_update_ppr(apic);
+ *   - arch/x86/kvm/lapic.c|3327| <<kvm_apic_set_state>> apic_update_ppr(apic);
+ */
 static void apic_update_ppr(struct kvm_lapic *apic)
 {
 	u32 ppr;
 
+	/*
+	 * 在以下调用apic_update_ppr():
+	 *   - arch/x86/kvm/lapic.c|1030| <<kvm_apic_update_ppr>> apic_update_ppr(vcpu->arch.apic);
+	 *   - arch/x86/kvm/lapic.c|1037| <<apic_set_tpr>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|1602| <<apic_set_eoi>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|1729| <<__apic_read>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|3005| <<kvm_lapic_reset>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|3231| <<kvm_get_apic_interrupt>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|3327| <<kvm_apic_set_state>> apic_update_ppr(apic);
+	 */
 	if (__apic_update_ppr(apic, &ppr) &&
 	    apic_has_interrupt_for_ppr(apic, ppr) != -1)
 		kvm_make_request(KVM_REQ_EVENT, apic->vcpu);
@@ -815,6 +1101,16 @@ EXPORT_SYMBOL_GPL(kvm_apic_update_ppr);
 static void apic_set_tpr(struct kvm_lapic *apic, u32 tpr)
 {
 	kvm_lapic_set_reg(apic, APIC_TASKPRI, tpr);
+	/*
+	 * 在以下调用apic_update_ppr():
+	 *   - arch/x86/kvm/lapic.c|1030| <<kvm_apic_update_ppr>> apic_update_ppr(vcpu->arch.apic);
+	 *   - arch/x86/kvm/lapic.c|1037| <<apic_set_tpr>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|1602| <<apic_set_eoi>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|1729| <<__apic_read>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|3005| <<kvm_lapic_reset>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|3231| <<kvm_get_apic_interrupt>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|3327| <<kvm_apic_set_state>> apic_update_ppr(apic);
+	 */
 	apic_update_ppr(apic);
 }
 
@@ -898,6 +1194,20 @@ static u32 kvm_apic_mda(struct kvm_vcpu *vcpu, unsigned int dest_id,
 	return dest_id;
 }
 
+/*
+ * 在以下调用kvm_apic_match_dest():
+ *   - arch/x86/kvm/ioapic.c|156| <<__rtc_irq_eoi_tracking_restore_one>> if (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT, e->fields.dest_id,
+ 158                                  kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))
+  4 arch/x86/kvm/ioapic.c|258| <<ioapic_lazy_update_eoi>> if (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT, entry->fields.dest_id,
+ 260                                          entry->fields.dest_mode) ||
+ 261                     kvm_apic_pending_eoi(vcpu, entry->fields.vector))
+  5 arch/x86/kvm/ioapic.c|473| <<kvm_ioapic_scan_entry>> if (kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT, e->fields.dest_id, dm)
+  6 arch/x86/kvm/irq_comm.c|81| <<kvm_irq_delivery_to_apic>> if (!kvm_apic_match_dest(vcpu, src, irq->shorthand,
+  7 arch/x86/kvm/irq_comm.c|434| <<kvm_intr_is_single_vcpu>> if (!kvm_apic_match_dest(vcpu, NULL, irq->shorthand,
+  8 arch/x86/kvm/irq_comm.c|592| <<kvm_scan_ioapic_routes>> (kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,
+ *   - arch/x86/kvm/lapic.c|1634| <<kvm_bitmap_or_dest_vcpus>> if (!kvm_apic_match_dest(vcpu, NULL,
+ 11 arch/x86/kvm/svm/avic.c|461| <<avic_kick_target_vcpus>> if (kvm_apic_match_dest(vcpu, source, icrl & APIC_SHORT_MASK,
+ */
 bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,
 			   int shorthand, unsigned int dest, int dest_mode)
 {
@@ -906,6 +1216,9 @@ bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,
 
 	ASSERT(target);
 	switch (shorthand) {
+	/*
+	 * 注意很多NOSHORT模式
+	 */
 	case APIC_DEST_NOSHORT:
 		if (dest_mode == APIC_DEST_PHYSICAL)
 			return kvm_apic_match_physical_addr(target, mda);
@@ -974,6 +1287,12 @@ static bool kvm_apic_is_broadcast_dest(struct kvm *kvm, struct kvm_lapic **src,
  * means that the interrupt should be dropped.  In this case, *bitmap would be
  * zero and *dst undefined.
  */
+/*
+ * 在以下使用kvm_apic_map_get_dest_lapic():
+ *   - arch/x86/kvm/lapic.c|1350| <<kvm_irq_delivery_to_apic_fast>> ret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);
+ *   - arch/x86/kvm/lapic.c|1392| <<kvm_intr_is_single_vcpu_fast>> if (kvm_apic_map_get_dest_lapic(kvm, NULL, irq, map, &dst, &bitmap) &&
+ *   - arch/x86/kvm/lapic.c|1598| <<kvm_bitmap_or_dest_vcpus>> ret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dest_vcpu,
+ */
 static inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,
 		struct kvm_lapic **src, struct kvm_lapic_irq *irq,
 		struct kvm_apic_map *map, struct kvm_lapic ***dst,
@@ -1119,10 +1438,63 @@ bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,
 	return ret;
 }
 
+/*
+ * 其他的:
+ * __apic_accept_irq
+ * __pv_send_ipi
+ * kvm_pv_send_ipi
+ * kvm_emulate_hypercall
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * __apic_accept_irq
+ * kvm_irq_delivery_to_apic
+ * kvm_apic_send_ipi
+ * kvm_x2apic_icr_write
+ * vmx_set_msr
+ * __kvm_set_msr
+ * kvm_emulate_wrmsr
+ * vmx_handle_exit
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
+/*
+ * 关于RESCHEDULE_VECTOR (0xfd)
+ *
+ * __apic_accept_irq
+ * kvm_irq_delivery_to_apic_fast
+ * kvm_irq_delivery_to_apic
+ * kvm_apic_send_ipi
+ * kvm_x2apic_icr_write
+ * handle_fastpath_set_msr_irqoff
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ */
 /*
  * Add a pending IRQ into lapic.
  * Return 1 if successfully added and 0 if discarded.
  */
+/*
+ * 在以下调用__apic_accept_irq():
+ *   - arch/x86/kvm/lapic.c|878| <<kvm_apic_set_irq>> return __apic_accept_irq(apic, irq->delivery_mode, irq->vector, irq->level, irq->trig_mode, dest_map);
+ *   - arch/x86/kvm/lapic.c|3050| <<kvm_apic_local_deliver>> r = __apic_accept_irq(apic, mode, vector, 1, trig_mode, NULL);
+ */
 static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 			     int vector, int level, int trig_mode,
 			     struct dest_map *dest_map)
@@ -1151,6 +1523,22 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 			dest_map->vectors[vcpu->vcpu_id] = vector;
 		}
 
+		/*
+		 * 在APIC中,TMR是Trigger Mode Register(触发方式寄存器),它的作用
+		 * 是记录每个中断向量是边沿触发还是电平触发.
+		 *
+		 * TMR[x] = 0 -> 中断向量x是边沿触发
+		 * TMR[x] = 1 -> 中断向量x是电平触发
+		 *
+		 * 对于边沿触发,中断发生后就结束,不再重复处理
+		 * 对于电平触发,需要在处理完成后确认信号已解除,
+		 * 否则中断会再次被触发(因为信号电平还在)
+		 *
+		 * 假设中断向量45是电平触发,那么:
+		 * TMR[45] = 1
+		 * 当中断控制器检测到45的信号为低电平时,会记录它在IRR(中断请求寄存器)中
+		 * 处理中断后,系统必须通知设备"我处理完了",否则设备保持信号为低电平,45 会一直被重复触发
+		 */
 		if (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {
 			if (trig_mode)
 				kvm_lapic_set_vector(vector,
@@ -1160,6 +1548,9 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 						       apic->regs + APIC_TMR);
 		}
 
+		/*
+		 * vmx_deliver_interrupt()
+		 */
 		static_call(kvm_x86_deliver_interrupt)(apic, delivery_mode,
 						       trig_mode, vector);
 		break;
@@ -1225,6 +1616,11 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
  * out the destination vcpus array and set the bitmap or it traverses to
  * each available vcpu to identify the same.
  */
+/*
+ * 在以下调用kvm_bitmap_or_dest_vcpus():
+ *   - arch/x86/kvm/ioapic.c|472| <<ioapic_write_indirect>> kvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,
+ *   - arch/x86/kvm/ioapic.c|485| <<ioapic_write_indirect>> kvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,
+ */
 void kvm_bitmap_or_dest_vcpus(struct kvm *kvm, struct kvm_lapic_irq *irq,
 			      unsigned long *vcpu_bitmap)
 {
@@ -1268,11 +1664,32 @@ int kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)
 	return vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;
 }
 
+/*
+ * 在以下调用kvm_ioapic_handles_vector():
+ *   - arch/x86/kvm/lapic.c|1648| <<kvm_ioapic_send_eoi>> if (!kvm_ioapic_handles_vector(apic, vector))
+ *   - arch/x86/kvm/lapic.c|3604| <<apic_sync_pv_eoi_to_guest>> kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {
+ */
 static bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)
 {
+	/*
+	 * 在以下使用ioapic_handled_vectors:
+	 *   - arch/x86/kvm/lapic.c|1614| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10020| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+	 *   - arch/x86/kvm/x86.c|10025| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10027| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10044| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap,
+	 *              vcpu->arch.ioapic_handled_vectors, to_hv_synic(vcpu)->vec_bitmap, 256);
+	 *   - arch/x86/kvm/x86.c|10051| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10193| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+	 */
 	return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
 }
 
+/*
+ * 在以下使用kvm_ioapic_send_eoi():
+ *   - arch/x86/kvm/lapic.c|1693| <<apic_set_eoi>> kvm_ioapic_send_eoi(apic, vector);
+ *   - arch/x86/kvm/lapic.c|1712| <<kvm_apic_set_eoi_accelerated>> kvm_ioapic_send_eoi(apic, vector);
+ */
 static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)
 {
 	int trigger_mode;
@@ -1281,6 +1698,9 @@ static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)
 	if (!kvm_ioapic_handles_vector(apic, vector))
 		return;
 
+	/*
+	 * 一般是KVM_IRQCHIP_KERNEL
+	 */
 	/* Request a KVM exit to inform the userspace IOAPIC. */
 	if (irqchip_split(apic->vcpu->kvm)) {
 		apic->vcpu->arch.pending_ioapic_eoi = vector;
@@ -1296,6 +1716,13 @@ static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)
 	kvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);
 }
 
+/*
+ * 在以下调用apic_set_eoi():
+ *   - arch/x86/kvm/lapic.c|2677| <<kvm_lapic_reg_write(APIC_EOI)>> apic_set_eoi(apic);
+ *   - arch/x86/kvm/lapic.c|3540| <<apic_sync_pv_eoi_from_guest>> vector = apic_set_eoi(apic);
+ *
+ * 实际测试没见到调用
+ */
 static int apic_set_eoi(struct kvm_lapic *apic)
 {
 	int vector = apic_find_highest_isr(apic);
@@ -1325,6 +1752,10 @@ static int apic_set_eoi(struct kvm_lapic *apic)
  * this interface assumes a trap-like exit, which has already finished
  * desired side effect including vISR and vPPR update.
  */
+/*
+ * 在以下调用kvm_apic_set_eoi_accelerated():
+ *   - arch/x86/kvm/vmx/vmx.c|5361| <<handle_apic_eoi_induced>> kvm_apic_set_eoi_accelerated(vcpu, vector);
+ */
 void kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
@@ -1336,6 +1767,30 @@ void kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)
 }
 EXPORT_SYMBOL_GPL(kvm_apic_set_eoi_accelerated);
 
+/*
+ * 关于RESCHEDULE_VECTOR (0xfd)
+ * 
+ * __apic_accept_irq
+ * kvm_irq_delivery_to_apic_fast
+ * kvm_irq_delivery_to_apic
+ * kvm_apic_send_ipi
+ * kvm_x2apic_icr_write
+ * handle_fastpath_set_msr_irqoff
+ * vcpu_enter_guest
+ * vcpu_run
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * 在以下调用kvm_apic_send_ipi()
+ *   - arch/x86/kvm/lapic.c|2676| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));
+ *   - arch/x86/kvm/lapic.c|2750| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, APIC_DEST_SELF | val, 0);
+ *   - arch/x86/kvm/lapic.c|2820| <<kvm_apic_write_nodecode>> kvm_apic_send_ipi(apic, (u32)val, (u32)(val >> 32));
+ *   - arch/x86/kvm/lapic.c|3577| <<kvm_x2apic_icr_write>> kvm_apic_send_ipi(apic, (u32)data, (u32)(data >> 32));
+ *   - arch/x86/kvm/svm/avic.c|501| <<avic_incomplete_ipi_interception>> kvm_apic_send_ipi(apic, icrl, icrh);
+ */
 void kvm_apic_send_ipi(struct kvm_lapic *apic, u32 icr_low, u32 icr_high)
 {
 	struct kvm_lapic_irq irq;
@@ -1357,6 +1812,17 @@ void kvm_apic_send_ipi(struct kvm_lapic *apic, u32 icr_low, u32 icr_high)
 
 	trace_kvm_apic_ipi(icr_low, irq.dest_id);
 
+	/*
+	 * 在以下调用kvm_irq_delivery_to_apic(): 
+	 *   - arch/x86/kvm/hyperv.c|482| <<synic_set_irq>> ret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);
+	 *   - arch/x86/kvm/ioapic.c|444| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, &ioapic->rtc_status.dest_map);
+	 *   - arch/x86/kvm/ioapic.c|448| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);
+	 *   - arch/x86/kvm/irq_comm.c|142| <<kvm_set_msi>> return kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);
+	 *   - arch/x86/kvm/lapic.c|1723| <<kvm_apic_send_ipi>> kvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);
+	 *   - arch/x86/kvm/x86.c|9079| <<kvm_pv_kick_cpu_op>> kvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);
+	 *
+	 * 参数的apic是source的
+	 */
 	kvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);
 }
 EXPORT_SYMBOL_GPL(kvm_apic_send_ipi);
@@ -1574,6 +2040,20 @@ static void cancel_apic_timer(struct kvm_lapic *apic)
 {
 	hrtimer_cancel(&apic->lapic_timer.timer);
 	preempt_disable();
+	/*
+	 * 在以下使用kvm_timer->hv_timer_in_use:
+	 *   - arch/x86/kvm/lapic.c|1698| <<cancel_apic_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|1850| <<apic_timer_expired>> if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2034| <<kvm_lapic_hv_timer_in_use>> return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
+	 *   - arch/x86/kvm/lapic.c|2041| <<cancel_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2043| <<cancel_hv_timer>> apic->lapic_timer.hv_timer_in_use = false;
+	 *   - arch/x86/kvm/lapic.c|2062| <<start_hv_timer>> ktimer->hv_timer_in_use = true;
+	 *   - arch/x86/kvm/lapic.c|2083| <<start_hv_timer>> trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2093| <<start_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2124| <<kvm_lapic_expired_hv_timer>> if (!apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2159| <<kvm_lapic_switch_to_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2169| <<kvm_lapic_restart_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 */
 	if (apic->lapic_timer.hv_timer_in_use)
 		cancel_hv_timer(apic);
 	preempt_enable();
@@ -1718,6 +2198,14 @@ static void kvm_apic_inject_pending_timer_irqs(struct kvm_lapic *apic)
 	}
 }
 
+/*
+ * 在以下使用apic_timer_expired():
+ *   - arch/x86/kvm/lapic.c|1908| <<start_sw_tscdeadline>> apic_timer_expired(apic, false);
+ *   - arch/x86/kvm/lapic.c|2016| <<start_sw_period>> apic_timer_expired(apic, false);
+ *   - arch/x86/kvm/lapic.c|2078| <<start_hv_timer>> apic_timer_expired(apic, false);
+ *   - arch/x86/kvm/lapic.c|2127| <<kvm_lapic_expired_hv_timer>> apic_timer_expired(apic, false);
+ *   - arch/x86/kvm/lapic.c|2707| <<apic_timer_fn>> apic_timer_expired(apic, true);
+ */
 static void apic_timer_expired(struct kvm_lapic *apic, bool from_timer_fn)
 {
 	struct kvm_vcpu *vcpu = apic->vcpu;
@@ -1726,6 +2214,20 @@ static void apic_timer_expired(struct kvm_lapic *apic, bool from_timer_fn)
 	if (atomic_read(&apic->lapic_timer.pending))
 		return;
 
+	/*
+	 * 在以下使用kvm_timer->hv_timer_in_use:
+	 *   - arch/x86/kvm/lapic.c|1698| <<cancel_apic_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|1850| <<apic_timer_expired>> if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2034| <<kvm_lapic_hv_timer_in_use>> return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
+	 *   - arch/x86/kvm/lapic.c|2041| <<cancel_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2043| <<cancel_hv_timer>> apic->lapic_timer.hv_timer_in_use = false;
+	 *   - arch/x86/kvm/lapic.c|2062| <<start_hv_timer>> ktimer->hv_timer_in_use = true;
+	 *   - arch/x86/kvm/lapic.c|2083| <<start_hv_timer>> trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2093| <<start_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2124| <<kvm_lapic_expired_hv_timer>> if (!apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2159| <<kvm_lapic_switch_to_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2169| <<kvm_lapic_restart_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 */
 	if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
 		ktimer->expired_tscdeadline = ktimer->tscdeadline;
 
@@ -1778,6 +2280,14 @@ static void start_sw_tscdeadline(struct kvm_lapic *apic)
 	ns = (tscdeadline - guest_tsc) * 1000000ULL;
 	do_div(ns, this_tsc_khz);
 
+	/*
+	 * 在以下使用apic_timer_expired():
+	 *   - arch/x86/kvm/lapic.c|1908| <<start_sw_tscdeadline>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2016| <<start_sw_period>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2078| <<start_hv_timer>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2127| <<kvm_lapic_expired_hv_timer>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2707| <<apic_timer_fn>> apic_timer_expired(apic, true);
+	 */
 	if (likely(tscdeadline > guest_tsc) &&
 	    likely(ns > apic->lapic_timer.timer_advance_ns)) {
 		expire = ktime_add_ns(now, ns);
@@ -1892,6 +2402,14 @@ static void start_sw_period(struct kvm_lapic *apic)
 
 	if (ktime_after(ktime_get(),
 			apic->lapic_timer.target_expiration)) {
+		/*
+		 * 在以下使用apic_timer_expired():
+		 *   - arch/x86/kvm/lapic.c|1908| <<start_sw_tscdeadline>> apic_timer_expired(apic, false);
+		 *   - arch/x86/kvm/lapic.c|2016| <<start_sw_period>> apic_timer_expired(apic, false);
+		 *   - arch/x86/kvm/lapic.c|2078| <<start_hv_timer>> apic_timer_expired(apic, false);
+		 *   - arch/x86/kvm/lapic.c|2127| <<kvm_lapic_expired_hv_timer>> apic_timer_expired(apic, false);
+		 *   - arch/x86/kvm/lapic.c|2707| <<apic_timer_fn>> apic_timer_expired(apic, true);
+		 */
 		apic_timer_expired(apic, false);
 
 		if (apic_lvtt_oneshot(apic))
@@ -1910,6 +2428,20 @@ bool kvm_lapic_hv_timer_in_use(struct kvm_vcpu *vcpu)
 	if (!lapic_in_kernel(vcpu))
 		return false;
 
+	/*
+	 * 在以下使用kvm_timer->hv_timer_in_use:
+	 *   - arch/x86/kvm/lapic.c|1698| <<cancel_apic_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|1850| <<apic_timer_expired>> if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2034| <<kvm_lapic_hv_timer_in_use>> return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
+	 *   - arch/x86/kvm/lapic.c|2041| <<cancel_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2043| <<cancel_hv_timer>> apic->lapic_timer.hv_timer_in_use = false;
+	 *   - arch/x86/kvm/lapic.c|2062| <<start_hv_timer>> ktimer->hv_timer_in_use = true;
+	 *   - arch/x86/kvm/lapic.c|2083| <<start_hv_timer>> trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2093| <<start_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2124| <<kvm_lapic_expired_hv_timer>> if (!apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2159| <<kvm_lapic_switch_to_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2169| <<kvm_lapic_restart_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 */
 	return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
 }
 EXPORT_SYMBOL_GPL(kvm_lapic_hv_timer_in_use);
@@ -1919,6 +2451,20 @@ static void cancel_hv_timer(struct kvm_lapic *apic)
 	WARN_ON(preemptible());
 	WARN_ON(!apic->lapic_timer.hv_timer_in_use);
 	static_call(kvm_x86_cancel_hv_timer)(apic->vcpu);
+	/*
+	 * 在以下使用kvm_timer->hv_timer_in_use:
+	 *   - arch/x86/kvm/lapic.c|1698| <<cancel_apic_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|1850| <<apic_timer_expired>> if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2034| <<kvm_lapic_hv_timer_in_use>> return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
+	 *   - arch/x86/kvm/lapic.c|2041| <<cancel_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2043| <<cancel_hv_timer>> apic->lapic_timer.hv_timer_in_use = false;
+	 *   - arch/x86/kvm/lapic.c|2062| <<start_hv_timer>> ktimer->hv_timer_in_use = true;
+	 *   - arch/x86/kvm/lapic.c|2083| <<start_hv_timer>> trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2093| <<start_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2124| <<kvm_lapic_expired_hv_timer>> if (!apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2159| <<kvm_lapic_switch_to_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2169| <<kvm_lapic_restart_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 */
 	apic->lapic_timer.hv_timer_in_use = false;
 }
 
@@ -1938,6 +2484,20 @@ static bool start_hv_timer(struct kvm_lapic *apic)
 	if (static_call(kvm_x86_set_hv_timer)(vcpu, ktimer->tscdeadline, &expired))
 		return false;
 
+	/*
+	 * 在以下使用kvm_timer->hv_timer_in_use:
+	 *   - arch/x86/kvm/lapic.c|1698| <<cancel_apic_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|1850| <<apic_timer_expired>> if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2034| <<kvm_lapic_hv_timer_in_use>> return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
+	 *   - arch/x86/kvm/lapic.c|2041| <<cancel_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2043| <<cancel_hv_timer>> apic->lapic_timer.hv_timer_in_use = false;
+	 *   - arch/x86/kvm/lapic.c|2062| <<start_hv_timer>> ktimer->hv_timer_in_use = true;
+	 *   - arch/x86/kvm/lapic.c|2083| <<start_hv_timer>> trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2093| <<start_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2124| <<kvm_lapic_expired_hv_timer>> if (!apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2159| <<kvm_lapic_switch_to_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2169| <<kvm_lapic_restart_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 */
 	ktimer->hv_timer_in_use = true;
 	hrtimer_cancel(&ktimer->timer);
 
@@ -1954,21 +2514,62 @@ static bool start_hv_timer(struct kvm_lapic *apic)
 		if (atomic_read(&ktimer->pending)) {
 			cancel_hv_timer(apic);
 		} else if (expired) {
+			/*
+			 * 在以下使用apic_timer_expired():
+			 *   - arch/x86/kvm/lapic.c|1908| <<start_sw_tscdeadline>> apic_timer_expired(apic, false);
+			 *   - arch/x86/kvm/lapic.c|2016| <<start_sw_period>> apic_timer_expired(apic, false);
+			 *   - arch/x86/kvm/lapic.c|2078| <<start_hv_timer>> apic_timer_expired(apic, false);
+			 *   - arch/x86/kvm/lapic.c|2127| <<kvm_lapic_expired_hv_timer>> apic_timer_expired(apic, false);
+			 *   - arch/x86/kvm/lapic.c|2707| <<apic_timer_fn>> apic_timer_expired(apic, true);
+			 */
 			apic_timer_expired(apic, false);
 			cancel_hv_timer(apic);
 		}
 	}
 
+	/*
+	 * 在以下使用kvm_timer->hv_timer_in_use:
+	 *   - arch/x86/kvm/lapic.c|1698| <<cancel_apic_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|1850| <<apic_timer_expired>> if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2034| <<kvm_lapic_hv_timer_in_use>> return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
+	 *   - arch/x86/kvm/lapic.c|2041| <<cancel_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2043| <<cancel_hv_timer>> apic->lapic_timer.hv_timer_in_use = false;
+	 *   - arch/x86/kvm/lapic.c|2062| <<start_hv_timer>> ktimer->hv_timer_in_use = true;
+	 *   - arch/x86/kvm/lapic.c|2083| <<start_hv_timer>> trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2093| <<start_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2124| <<kvm_lapic_expired_hv_timer>> if (!apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2159| <<kvm_lapic_switch_to_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2169| <<kvm_lapic_restart_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 */
 	trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
 
 	return true;
 }
 
+/*
+ * 在以下调用start_sw_timer():
+ *   - arch/x86/kvm/lapic.c|2113| <<restart_apic_timer>> start_sw_timer(apic);
+ *   - arch/x86/kvm/lapic.c|2160| <<kvm_lapic_switch_to_sw_timer>> start_sw_timer(apic);
+ */
 static void start_sw_timer(struct kvm_lapic *apic)
 {
 	struct kvm_timer *ktimer = &apic->lapic_timer;
 
 	WARN_ON(preemptible());
+	/*
+	 * 在以下使用kvm_timer->hv_timer_in_use:
+	 *   - arch/x86/kvm/lapic.c|1698| <<cancel_apic_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|1850| <<apic_timer_expired>> if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2034| <<kvm_lapic_hv_timer_in_use>> return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
+	 *   - arch/x86/kvm/lapic.c|2041| <<cancel_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2043| <<cancel_hv_timer>> apic->lapic_timer.hv_timer_in_use = false;
+	 *   - arch/x86/kvm/lapic.c|2062| <<start_hv_timer>> ktimer->hv_timer_in_use = true;
+	 *   - arch/x86/kvm/lapic.c|2083| <<start_hv_timer>> trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2093| <<start_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2124| <<kvm_lapic_expired_hv_timer>> if (!apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2159| <<kvm_lapic_switch_to_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2169| <<kvm_lapic_restart_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 */
 	if (apic->lapic_timer.hv_timer_in_use)
 		cancel_hv_timer(apic);
 	if (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending))
@@ -1999,10 +2600,32 @@ void kvm_lapic_expired_hv_timer(struct kvm_vcpu *vcpu)
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
 	preempt_disable();
+	/*
+	 * 在以下使用kvm_timer->hv_timer_in_use:
+	 *   - arch/x86/kvm/lapic.c|1698| <<cancel_apic_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|1850| <<apic_timer_expired>> if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2034| <<kvm_lapic_hv_timer_in_use>> return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
+	 *   - arch/x86/kvm/lapic.c|2041| <<cancel_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2043| <<cancel_hv_timer>> apic->lapic_timer.hv_timer_in_use = false;
+	 *   - arch/x86/kvm/lapic.c|2062| <<start_hv_timer>> ktimer->hv_timer_in_use = true;
+	 *   - arch/x86/kvm/lapic.c|2083| <<start_hv_timer>> trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2093| <<start_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2124| <<kvm_lapic_expired_hv_timer>> if (!apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2159| <<kvm_lapic_switch_to_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2169| <<kvm_lapic_restart_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 */
 	/* If the preempt notifier has already run, it also called apic_timer_expired */
 	if (!apic->lapic_timer.hv_timer_in_use)
 		goto out;
 	WARN_ON(kvm_vcpu_is_blocking(vcpu));
+	/*
+	 * 在以下使用apic_timer_expired():
+	 *   - arch/x86/kvm/lapic.c|1908| <<start_sw_tscdeadline>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2016| <<start_sw_period>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2078| <<start_hv_timer>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2127| <<kvm_lapic_expired_hv_timer>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2707| <<apic_timer_fn>> apic_timer_expired(apic, true);
+	 */
 	apic_timer_expired(apic, false);
 	cancel_hv_timer(apic);
 
@@ -2015,17 +2638,39 @@ void kvm_lapic_expired_hv_timer(struct kvm_vcpu *vcpu)
 }
 EXPORT_SYMBOL_GPL(kvm_lapic_expired_hv_timer);
 
+/*
+ * 在以下使用kvm_lapic_switch_to_hv_timer():
+ *   - arch/x86/kvm/x86.c|10325| <<vcpu_block>> kvm_lapic_switch_to_hv_timer(vcpu);
+ */
 void kvm_lapic_switch_to_hv_timer(struct kvm_vcpu *vcpu)
 {
 	restart_apic_timer(vcpu->arch.apic);
 }
 EXPORT_SYMBOL_GPL(kvm_lapic_switch_to_hv_timer);
 
+/*
+ * 在以下使用kvm_lapic_switch_to_sw_timer():
+ *   - arch/x86/kvm/x86.c|10318| <<vcpu_block>> kvm_lapic_switch_to_sw_timer(vcpu);
+ */
 void kvm_lapic_switch_to_sw_timer(struct kvm_vcpu *vcpu)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
 	preempt_disable();
+	/*
+	 * 在以下使用kvm_timer->hv_timer_in_use:
+	 *   - arch/x86/kvm/lapic.c|1698| <<cancel_apic_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|1850| <<apic_timer_expired>> if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2034| <<kvm_lapic_hv_timer_in_use>> return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
+	 *   - arch/x86/kvm/lapic.c|2041| <<cancel_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2043| <<cancel_hv_timer>> apic->lapic_timer.hv_timer_in_use = false;
+	 *   - arch/x86/kvm/lapic.c|2062| <<start_hv_timer>> ktimer->hv_timer_in_use = true;
+	 *   - arch/x86/kvm/lapic.c|2083| <<start_hv_timer>> trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2093| <<start_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2124| <<kvm_lapic_expired_hv_timer>> if (!apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2159| <<kvm_lapic_switch_to_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2169| <<kvm_lapic_restart_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 */
 	/* Possibly the TSC deadline timer is not enabled yet */
 	if (apic->lapic_timer.hv_timer_in_use)
 		start_sw_timer(apic);
@@ -2037,6 +2682,20 @@ void kvm_lapic_restart_hv_timer(struct kvm_vcpu *vcpu)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
+	/*
+	 * 在以下使用kvm_timer->hv_timer_in_use:
+	 *   - arch/x86/kvm/lapic.c|1698| <<cancel_apic_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|1850| <<apic_timer_expired>> if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2034| <<kvm_lapic_hv_timer_in_use>> return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
+	 *   - arch/x86/kvm/lapic.c|2041| <<cancel_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2043| <<cancel_hv_timer>> apic->lapic_timer.hv_timer_in_use = false;
+	 *   - arch/x86/kvm/lapic.c|2062| <<start_hv_timer>> ktimer->hv_timer_in_use = true;
+	 *   - arch/x86/kvm/lapic.c|2083| <<start_hv_timer>> trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2093| <<start_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2124| <<kvm_lapic_expired_hv_timer>> if (!apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2159| <<kvm_lapic_switch_to_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2169| <<kvm_lapic_restart_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 */
 	WARN_ON(!apic->lapic_timer.hv_timer_in_use);
 	restart_apic_timer(apic);
 }
@@ -2134,6 +2793,14 @@ int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 
 		/* No delay here, so we always clear the pending bit */
 		val &= ~APIC_ICR_BUSY;
+		/*
+		 * 在以下调用kvm_apic_send_ipi()
+		 *   - arch/x86/kvm/lapic.c|2676| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));
+		 *   - arch/x86/kvm/lapic.c|2750| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, APIC_DEST_SELF | val, 0);
+		 *   - arch/x86/kvm/lapic.c|2820| <<kvm_apic_write_nodecode>> kvm_apic_send_ipi(apic, (u32)val, (u32)(val >> 32));
+		 *   - arch/x86/kvm/lapic.c|3577| <<kvm_x2apic_icr_write>> kvm_apic_send_ipi(apic, (u32)data, (u32)(data >> 32));
+		 *   - arch/x86/kvm/svm/avic.c|501| <<avic_incomplete_ipi_interception>> kvm_apic_send_ipi(apic, icrl, icrh);
+		 */
 		kvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));
 		kvm_lapic_set_reg(apic, APIC_ICR, val);
 		break;
@@ -2205,6 +2872,14 @@ int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
 		 * Self-IPI exists only when x2APIC is enabled.  Bits 7:0 hold
 		 * the vector, everything else is reserved.
 		 */
+		/*
+		 * 在以下调用kvm_apic_send_ipi()
+		 *   - arch/x86/kvm/lapic.c|2676| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));
+		 *   - arch/x86/kvm/lapic.c|2750| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, APIC_DEST_SELF | val, 0);
+		 *   - arch/x86/kvm/lapic.c|2820| <<kvm_apic_write_nodecode>> kvm_apic_send_ipi(apic, (u32)val, (u32)(val >> 32));
+		 *   - arch/x86/kvm/lapic.c|3577| <<kvm_x2apic_icr_write>> kvm_apic_send_ipi(apic, (u32)data, (u32)(data >> 32));
+		 *   - arch/x86/kvm/svm/avic.c|501| <<avic_incomplete_ipi_interception>> kvm_apic_send_ipi(apic, icrl, icrh);
+		 */
 		if (!apic_x2apic_mode(apic) || (val & ~APIC_VECTOR_MASK))
 			ret = 1;
 		else
@@ -2278,6 +2953,14 @@ void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)
 	 */
 	if (apic_x2apic_mode(apic) && offset == APIC_ICR) {
 		val = kvm_lapic_get_reg64(apic, APIC_ICR);
+		/*
+		 * 在以下调用kvm_apic_send_ipi()
+		 *   - arch/x86/kvm/lapic.c|2676| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));
+		 *   - arch/x86/kvm/lapic.c|2750| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, APIC_DEST_SELF | val, 0);
+		 *   - arch/x86/kvm/lapic.c|2820| <<kvm_apic_write_nodecode>> kvm_apic_send_ipi(apic, (u32)val, (u32)(val >> 32));
+		 *   - arch/x86/kvm/lapic.c|3577| <<kvm_x2apic_icr_write>> kvm_apic_send_ipi(apic, (u32)data, (u32)(data >> 32));
+		 *   - arch/x86/kvm/svm/avic.c|501| <<avic_incomplete_ipi_interception>> kvm_apic_send_ipi(apic, icrl, icrh);
+		 */
 		kvm_apic_send_ipi(apic, (u32)val, (u32)(val >> 32));
 		trace_kvm_apic_write(APIC_ICR, val);
 	} else {
@@ -2297,9 +2980,30 @@ void kvm_free_lapic(struct kvm_vcpu *vcpu)
 
 	hrtimer_cancel(&apic->lapic_timer.timer);
 
+	/*
+	 * 在以下使用apic_hw_disabled:
+	 *   - arch/x86/kvm/lapic.c|130| <<global>> __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_hw_disabled, HZ);
+	 *   - arch/x86/kvm/lapic.c|2323| <<kvm_free_lapic>> static_branch_slow_dec_deferred(&apic_hw_disabled);
+	 *   - arch/x86/kvm/lapic.c|2403| <<kvm_lapic_set_base>> static_branch_slow_dec_deferred(&apic_hw_disabled);
+	 *   - arch/x86/kvm/lapic.c|2407| <<kvm_lapic_set_base>> static_branch_inc(&apic_hw_disabled.key);
+	 *   - arch/x86/kvm/lapic.c|3130| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_hw_disabled);
+	 *   - arch/x86/kvm/lapic.c|3131| <<kvm_lapic_exit>> WARN_ON(static_branch_unlikely(&apic_hw_disabled.key));
+	 *   - arch/x86/kvm/lapic.h|180| <<kvm_apic_hw_enabled>> if (static_branch_unlikely(&apic_hw_disabled.key))
+	 */
 	if (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))
 		static_branch_slow_dec_deferred(&apic_hw_disabled);
 
+	/*
+	 * 在以下使用apic_sw_disabled:
+	 *   - arch/x86/kvm/lapic.c|131| <<global>> __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_sw_disabled, HZ);
+	 *   - arch/x86/kvm/lapic.c|352| <<apic_set_spiv>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|354| <<apic_set_spiv>> static_branch_inc(&apic_sw_disabled.key);
+	 *   - arch/x86/kvm/lapic.c|2304| <<kvm_free_lapic>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|2593| <<kvm_create_lapic>> static_branch_inc(&apic_sw_disabled.key);
+	 *   - arch/x86/kvm/lapic.c|3084| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|3085| <<kvm_lapic_exit>> WARN_ON(static_branch_unlikely(&apic_sw_disabled.key));
+	 *   - arch/x86/kvm/lapic.h|189| <<kvm_apic_sw_enabled>> if (static_branch_unlikely(&apic_sw_disabled.key))
+	 */
 	if (!apic->sw_enabled)
 		static_branch_slow_dec_deferred(&apic_sw_disabled);
 
@@ -2367,6 +3071,16 @@ void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)
 	if ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {
 		if (value & MSR_IA32_APICBASE_ENABLE) {
 			kvm_apic_set_xapic_id(apic, vcpu->vcpu_id);
+			/*
+			 * 在以下使用apic_hw_disabled:
+			 *   - arch/x86/kvm/lapic.c|130| <<global>> __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_hw_disabled, HZ);
+			 *   - arch/x86/kvm/lapic.c|2323| <<kvm_free_lapic>> static_branch_slow_dec_deferred(&apic_hw_disabled);
+			 *   - arch/x86/kvm/lapic.c|2403| <<kvm_lapic_set_base>> static_branch_slow_dec_deferred(&apic_hw_disabled);
+			 *   - arch/x86/kvm/lapic.c|2407| <<kvm_lapic_set_base>> static_branch_inc(&apic_hw_disabled.key);
+			 *   - arch/x86/kvm/lapic.c|3130| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_hw_disabled);
+			 *   - arch/x86/kvm/lapic.c|3131| <<kvm_lapic_exit>> WARN_ON(static_branch_unlikely(&apic_hw_disabled.key));
+			 *   - arch/x86/kvm/lapic.h|180| <<kvm_apic_hw_enabled>> if (static_branch_unlikely(&apic_hw_disabled.key))
+			 */
 			static_branch_slow_dec_deferred(&apic_hw_disabled);
 			/* Check if there are APF page ready requests pending */
 			kvm_make_request(KVM_REQ_APF_READY, vcpu);
@@ -2544,6 +3258,14 @@ static enum hrtimer_restart apic_timer_fn(struct hrtimer *data)
 	struct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);
 	struct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);
 
+	/*
+	 * 在以下使用apic_timer_expired():
+	 *   - arch/x86/kvm/lapic.c|1908| <<start_sw_tscdeadline>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2016| <<start_sw_period>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2078| <<start_hv_timer>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2127| <<kvm_lapic_expired_hv_timer>> apic_timer_expired(apic, false);
+	 *   - arch/x86/kvm/lapic.c|2707| <<apic_timer_fn>> apic_timer_expired(apic, true);
+	 */
 	apic_timer_expired(apic, true);
 
 	if (lapic_is_periodic(apic)) {
@@ -2590,6 +3312,17 @@ int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)
 	 * apic_hw_disabled; the full RESET value is set by kvm_lapic_reset().
 	 */
 	vcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;
+	/*
+	 * 在以下使用apic_sw_disabled:
+	 *   - arch/x86/kvm/lapic.c|131| <<global>> __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_sw_disabled, HZ);
+	 *   - arch/x86/kvm/lapic.c|352| <<apic_set_spiv>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|354| <<apic_set_spiv>> static_branch_inc(&apic_sw_disabled.key);
+	 *   - arch/x86/kvm/lapic.c|2304| <<kvm_free_lapic>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|2593| <<kvm_create_lapic>> static_branch_inc(&apic_sw_disabled.key);
+	 *   - arch/x86/kvm/lapic.c|3084| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|3085| <<kvm_lapic_exit>> WARN_ON(static_branch_unlikely(&apic_sw_disabled.key));
+	 *   - arch/x86/kvm/lapic.h|189| <<kvm_apic_sw_enabled>> if (static_branch_unlikely(&apic_sw_disabled.key))
+	 */
 	static_branch_inc(&apic_sw_disabled.key); /* sw disabled at reset */
 	kvm_iodevice_init(&apic->dev, &apic_mmio_ops);
 
@@ -2601,6 +3334,13 @@ int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)
 	return -ENOMEM;
 }
 
+/*
+ * 在以下使用kvm_apic_has_interrupt():
+ *   - arch/x86/kvm/irq.c|100| <<kvm_cpu_has_injectable_intr>> return kvm_apic_has_interrupt(v) != -1;
+ *   - arch/x86/kvm/irq.c|113| <<kvm_cpu_has_interrupt>> return kvm_apic_has_interrupt(v) != -1;
+ *   - arch/x86/kvm/lapic.c|3106| <<kvm_get_apic_interrupt>> int vector = kvm_apic_has_interrupt(vcpu);
+ *   - arch/x86/kvm/vmx/nested.c|3613| <<nested_vmx_run>> kvm_apic_has_interrupt(vcpu) == vmx->nested.posted_intr_nv) {
+ */
 int kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
@@ -2636,6 +3376,19 @@ void kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)
 	}
 }
 
+/*
+ * called by:
+ *   - arch/x86/kvm/irq.c|143| <<kvm_cpu_get_interrupt>> return kvm_get_apic_interrupt(v);
+ *
+ * vcpu_enter_guest()
+ * -> if (kvm_cpu_has_injectable_intr(vcpu)) {
+ *      inject_pending_event()
+ *      -> kvm_cpu_get_interrupt()
+ *         -> kvm_get_apic_interrupt()
+ *            -> apic_set_isr()
+ *
+ * 注意kvm_cpu_has_injectable_intr()
+ */
 int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)
 {
 	int vector = kvm_apic_has_interrupt(vcpu);
@@ -2659,6 +3412,16 @@ int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)
 		 * interrupt above PPR, so check whether to raise another
 		 * KVM_REQ_EVENT.
 		 */
+		/*
+		 * 在以下调用apic_update_ppr():
+		 *   - arch/x86/kvm/lapic.c|1030| <<kvm_apic_update_ppr>> apic_update_ppr(vcpu->arch.apic);
+		 *   - arch/x86/kvm/lapic.c|1037| <<apic_set_tpr>> apic_update_ppr(apic);
+		 *   - arch/x86/kvm/lapic.c|1602| <<apic_set_eoi>> apic_update_ppr(apic);
+		 *   - arch/x86/kvm/lapic.c|1729| <<__apic_read>> apic_update_ppr(apic);
+		 *   - arch/x86/kvm/lapic.c|3005| <<kvm_lapic_reset>> apic_update_ppr(apic);
+		 *   - arch/x86/kvm/lapic.c|3231| <<kvm_get_apic_interrupt>> apic_update_ppr(apic);
+		 *   - arch/x86/kvm/lapic.c|3327| <<kvm_apic_set_state>> apic_update_ppr(apic);
+		 */
 		apic_update_ppr(apic);
 	} else {
 		/*
@@ -2674,6 +3437,11 @@ int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)
 	return vector;
 }
 
+/*
+ * 在以下使用kvm_apic_state_fixup():
+ *   - arch/x86/kvm/lapic.c|2861| <<kvm_apic_get_state>> return kvm_apic_state_fixup(vcpu, s, false);
+ *   - arch/x86/kvm/lapic.c|2873| <<kvm_apic_set_state>> r = kvm_apic_state_fixup(vcpu, s, true);
+ */
 static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,
 		struct kvm_lapic_state *s, bool set)
 {
@@ -2712,6 +3480,12 @@ static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,
 	return 0;
 }
 
+/*
+ * 128 #define KVM_APIC_REG_SIZE 0x400
+ * 129 struct kvm_lapic_state {
+ * 130         char regs[KVM_APIC_REG_SIZE];
+ * 131 };
+ */
 int kvm_apic_get_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 {
 	memcpy(s->regs, vcpu->arch.apic->regs, sizeof(*s));
@@ -2726,6 +3500,10 @@ int kvm_apic_get_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 	return kvm_apic_state_fixup(vcpu, s, false);
 }
 
+/*
+ * 在以下调用kvm_apic_set_state():
+ *   - arch/x86/kvm/x86.c|4692| <<kvm_vcpu_ioctl_set_lapic>> r = kvm_apic_set_state(vcpu, s);
+ */
 int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 {
 	struct kvm_lapic *apic = vcpu->arch.apic;
@@ -2746,6 +3524,16 @@ int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 	kvm_recalculate_apic_map(vcpu->kvm);
 	kvm_apic_set_version(vcpu);
 
+	/*
+	 * 在以下调用apic_update_ppr():
+	 *   - arch/x86/kvm/lapic.c|1030| <<kvm_apic_update_ppr>> apic_update_ppr(vcpu->arch.apic);
+	 *   - arch/x86/kvm/lapic.c|1037| <<apic_set_tpr>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|1602| <<apic_set_eoi>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|1729| <<__apic_read>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|3005| <<kvm_lapic_reset>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|3231| <<kvm_get_apic_interrupt>> apic_update_ppr(apic);
+	 *   - arch/x86/kvm/lapic.c|3327| <<kvm_apic_set_state>> apic_update_ppr(apic);
+	 */
 	apic_update_ppr(apic);
 	cancel_apic_timer(apic);
 	apic->lapic_timer.expired_tscdeadline = 0;
@@ -2757,6 +3545,14 @@ int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)
 	kvm_apic_update_apicv(vcpu);
 	if (vcpu->arch.apicv_active) {
 		static_call(kvm_x86_apicv_post_state_restore)(vcpu);
+		/*
+		 * 在以下使用apic_find_highest_irr():
+		 *   - arch/x86/kvm/lapic.c|710| <<apic_clear_irr>> apic_find_highest_irr(apic));
+		 *   - arch/x86/kvm/lapic.c|844| <<kvm_lapic_find_highest_irr>> return apic_find_highest_irr(vcpu->arch.apic);
+		 *   - arch/x86/kvm/lapic.c|962| <<apic_has_interrupt_for_ppr>> highest_irr = apic_find_highest_irr(apic);
+		 *   - arch/x86/kvm/lapic.c|3310| <<kvm_apic_set_state>> apic_find_highest_irr(apic));
+		 *   - arch/x86/kvm/lapic.c|3433| <<kvm_lapic_sync_to_vapic>> max_irr = apic_find_highest_irr(apic);
+		 */
 		static_call(kvm_x86_hwapic_irr_update)(vcpu,
 				apic_find_highest_irr(apic));
 		static_call(kvm_x86_hwapic_isr_update)(vcpu,
@@ -2791,6 +3587,10 @@ void __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)
  * last entry. If yes, set EOI on guests's behalf.
  * Clear PV EOI in guest memory in any case.
  */
+/*
+ * 在以下调用apic_sync_pv_eoi_from_guest():
+ *   - arch/x86/kvm/lapic.c|3601| <<kvm_lapic_sync_from_vapic>> apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);
+ */
 static void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,
 					struct kvm_lapic *apic)
 {
@@ -2821,6 +3621,11 @@ static void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,
 	trace_kvm_pv_eoi(apic, vector);
 }
 
+/*
+ * 在以下使用kvm_lapic_sync_from_vapic():
+ *   - arch/x86/kvm/x86.c|10409| <<vcpu_enter_guest>> kvm_lapic_sync_from_vapic(vcpu);
+ *   - arch/x86/kvm/x86.c|10419| <<vcpu_enter_guest>> kvm_lapic_sync_from_vapic(vcpu);
+ */
 void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
 {
 	u32 data;
@@ -2876,18 +3681,33 @@ void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)
 		return;
 
 	tpr = kvm_lapic_get_reg(apic, APIC_TASKPRI) & 0xff;
+	/*
+	 * 在以下使用apic_find_highest_irr():
+	 *   - arch/x86/kvm/lapic.c|710| <<apic_clear_irr>> apic_find_highest_irr(apic));
+	 *   - arch/x86/kvm/lapic.c|844| <<kvm_lapic_find_highest_irr>> return apic_find_highest_irr(vcpu->arch.apic);
+	 *   - arch/x86/kvm/lapic.c|962| <<apic_has_interrupt_for_ppr>> highest_irr = apic_find_highest_irr(apic);
+	 *   - arch/x86/kvm/lapic.c|3310| <<kvm_apic_set_state>> apic_find_highest_irr(apic));
+	 *   - arch/x86/kvm/lapic.c|3433| <<kvm_lapic_sync_to_vapic>> max_irr = apic_find_highest_irr(apic);
+	 */
 	max_irr = apic_find_highest_irr(apic);
 	if (max_irr < 0)
 		max_irr = 0;
 	max_isr = apic_find_highest_isr(apic);
 	if (max_isr < 0)
 		max_isr = 0;
+	/*
+	 * data是32位
+	 */
 	data = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);
 
 	kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,
 				sizeof(u32));
 }
 
+/*
+ * 处理KVM_SET_VAPIC_ADDR:
+ *   - arch/x86/kvm/x86.c|5334| <<kvm_arch_vcpu_ioctl(KVM_SET_VAPIC_ADDR)>> r = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);
+ */
 int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)
 {
 	if (vapic_addr) {
@@ -2908,6 +3728,14 @@ int kvm_x2apic_icr_write(struct kvm_lapic *apic, u64 data)
 {
 	data &= ~APIC_ICR_BUSY;
 
+	/*
+	 * 在以下调用kvm_apic_send_ipi()
+	 *   - arch/x86/kvm/lapic.c|2676| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));
+	 *   - arch/x86/kvm/lapic.c|2750| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, APIC_DEST_SELF | val, 0);
+	 *   - arch/x86/kvm/lapic.c|2820| <<kvm_apic_write_nodecode>> kvm_apic_send_ipi(apic, (u32)val, (u32)(val >> 32));
+	 *   - arch/x86/kvm/lapic.c|3577| <<kvm_x2apic_icr_write>> kvm_apic_send_ipi(apic, (u32)data, (u32)(data >> 32));
+	 *   - arch/x86/kvm/svm/avic.c|501| <<avic_incomplete_ipi_interception>> kvm_apic_send_ipi(apic, icrl, icrh);
+	 */
 	kvm_apic_send_ipi(apic, (u32)data, (u32)(data >> 32));
 	kvm_lapic_set_reg64(apic, APIC_ICR, data);
 	trace_kvm_apic_write(APIC_ICR, data);
@@ -3077,10 +3905,35 @@ int kvm_apic_accept_events(struct kvm_vcpu *vcpu)
 	return 0;
 }
 
+/*
+ * 在以下调用kvm_lapic_exit():
+ *   - arch/x86/kvm/x86.c|8873| <<kvm_arch_exit>> kvm_lapic_exit();
+ */
 void kvm_lapic_exit(void)
 {
+	/*
+	 * 在以下使用apic_hw_disabled:
+	 *   - arch/x86/kvm/lapic.c|130| <<global>> __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_hw_disabled, HZ);
+	 *   - arch/x86/kvm/lapic.c|2323| <<kvm_free_lapic>> static_branch_slow_dec_deferred(&apic_hw_disabled);
+	 *   - arch/x86/kvm/lapic.c|2403| <<kvm_lapic_set_base>> static_branch_slow_dec_deferred(&apic_hw_disabled);
+	 *   - arch/x86/kvm/lapic.c|2407| <<kvm_lapic_set_base>> static_branch_inc(&apic_hw_disabled.key);
+	 *   - arch/x86/kvm/lapic.c|3130| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_hw_disabled);
+	 *   - arch/x86/kvm/lapic.c|3131| <<kvm_lapic_exit>> WARN_ON(static_branch_unlikely(&apic_hw_disabled.key));
+	 *   - arch/x86/kvm/lapic.h|180| <<kvm_apic_hw_enabled>> if (static_branch_unlikely(&apic_hw_disabled.key))
+	 */
 	static_key_deferred_flush(&apic_hw_disabled);
 	WARN_ON(static_branch_unlikely(&apic_hw_disabled.key));
+	/*
+	 * 在以下使用apic_sw_disabled:
+	 *   - arch/x86/kvm/lapic.c|131| <<global>> __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_sw_disabled, HZ);
+	 *   - arch/x86/kvm/lapic.c|352| <<apic_set_spiv>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|354| <<apic_set_spiv>> static_branch_inc(&apic_sw_disabled.key);
+	 *   - arch/x86/kvm/lapic.c|2304| <<kvm_free_lapic>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|2593| <<kvm_create_lapic>> static_branch_inc(&apic_sw_disabled.key);
+	 *   - arch/x86/kvm/lapic.c|3084| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|3085| <<kvm_lapic_exit>> WARN_ON(static_branch_unlikely(&apic_sw_disabled.key));
+	 *   - arch/x86/kvm/lapic.h|189| <<kvm_apic_sw_enabled>> if (static_branch_unlikely(&apic_sw_disabled.key))
+	 */
 	static_key_deferred_flush(&apic_sw_disabled);
 	WARN_ON(static_branch_unlikely(&apic_sw_disabled.key));
 }
diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h
index ee42eef92f32..0b07f852d1aa 100644
--- a/arch/x86/kvm/lapic.h
+++ b/arch/x86/kvm/lapic.h
@@ -40,6 +40,20 @@ struct kvm_timer {
 	u32 timer_advance_ns;
 	s64 advance_expire_delta;
 	atomic_t pending;			/* accumulated triggered timers */
+	/*
+	 * 在以下使用kvm_timer->hv_timer_in_use:
+	 *   - arch/x86/kvm/lapic.c|1698| <<cancel_apic_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|1850| <<apic_timer_expired>> if (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2034| <<kvm_lapic_hv_timer_in_use>> return vcpu->arch.apic->lapic_timer.hv_timer_in_use;
+	 *   - arch/x86/kvm/lapic.c|2041| <<cancel_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2043| <<cancel_hv_timer>> apic->lapic_timer.hv_timer_in_use = false;
+	 *   - arch/x86/kvm/lapic.c|2062| <<start_hv_timer>> ktimer->hv_timer_in_use = true;
+	 *   - arch/x86/kvm/lapic.c|2083| <<start_hv_timer>> trace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);
+	 *   - arch/x86/kvm/lapic.c|2093| <<start_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2124| <<kvm_lapic_expired_hv_timer>> if (!apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2159| <<kvm_lapic_switch_to_sw_timer>> if (apic->lapic_timer.hv_timer_in_use)
+	 *   - arch/x86/kvm/lapic.c|2169| <<kvm_lapic_restart_hv_timer>> WARN_ON(!apic->lapic_timer.hv_timer_in_use);
+	 */
 	bool hv_timer_in_use;
 };
 
@@ -64,6 +78,25 @@ struct kvm_lapic {
 	void *regs;
 	gpa_t vapic_addr;
 	struct gfn_to_hva_cache vapic_cache;
+	/*
+	 * 在以下使用kvm_lapic->pending_events:
+	 *   - arch/x86/kvm/lapic.c|1476| <<__apic_accept_irq>> apic->pending_events = (1UL << KVM_APIC_INIT);
+	 *   - arch/x86/kvm/lapic.c|1487| <<__apic_accept_irq>> set_bit(KVM_APIC_SIPI, &apic->pending_events);
+	 *   - arch/x86/kvm/lapic.c|3633| <<kvm_apic_accept_events>> pe = smp_load_acquire(&apic->pending_events);
+	 *   - arch/x86/kvm/lapic.c|3661| <<kvm_apic_accept_events>> clear_bit(KVM_APIC_SIPI, &apic->pending_events);
+	 *   - arch/x86/kvm/lapic.c|3666| <<kvm_apic_accept_events>> clear_bit(KVM_APIC_INIT, &apic->pending_events);
+	 *   - arch/x86/kvm/lapic.c|3674| <<kvm_apic_accept_events>> clear_bit(KVM_APIC_SIPI, &apic->pending_events);
+	 *   - arch/x86/kvm/lapic.h|251| <<kvm_apic_has_events>> return lapic_in_kernel(vcpu) && vcpu->arch.apic->pending_events;
+	 *   - arch/x86/kvm/lapic.h|262| <<kvm_lapic_latched_init>> return lapic_in_kernel(vcpu) && test_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
+	 *   - arch/x86/kvm/svm/nested.c|1288| <<svm_check_nested_events>> test_bit(KVM_APIC_INIT, &apic->pending_events)) {
+	 *   - arch/x86/kvm/vmx/nested.c|3919| <<vmx_check_nested_events>> test_bit(KVM_APIC_INIT, &apic->pending_events)) {
+	 *   - arch/x86/kvm/vmx/nested.c|3923| <<vmx_check_nested_events>> clear_bit(KVM_APIC_INIT, &apic->pending_events);
+	 *   - arch/x86/kvm/vmx/nested.c|3930| <<vmx_check_nested_events>> test_bit(KVM_APIC_SIPI, &apic->pending_events)) {
+	 *   - arch/x86/kvm/vmx/nested.c|3934| <<vmx_check_nested_events>> clear_bit(KVM_APIC_SIPI, &apic->pending_events);
+	 *   - arch/x86/kvm/x86.c|5020| <<kvm_vcpu_ioctl_x86_set_vcpu_events>> set_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
+	 *   - arch/x86/kvm/x86.c|5022| <<kvm_vcpu_ioctl_x86_set_vcpu_events>> clear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
+	 *   - arch/x86/kvm/x86.c|11011| <<kvm_arch_vcpu_ioctl_set_mpstate>> set_bit(KVM_APIC_SIPI, &vcpu->arch.apic->pending_events);
+	 */
 	unsigned long pending_events;
 	unsigned int sipi_vector;
 };
@@ -134,16 +167,32 @@ void kvm_lapic_exit(void);
 #define VEC_POS(v) ((v) & (32 - 1))
 #define REG_POS(v) (((v) >> 5) << 4)
 
+/*
+ * 在以下调用kvm_lapic_clear_vector():
+ *   - arch/x86/kvm/lapic.c|716| <<apic_clear_irr>> kvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.c|721| <<apic_clear_irr>> kvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);
+ *   - arch/x86/kvm/lapic.c|1442| <<__apic_accept_irq>> kvm_lapic_clear_vector(vector, apic->regs + APIC_TMR);
+ */
 static inline void kvm_lapic_clear_vector(int vec, void *bitmap)
 {
 	clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
 }
 
+/*
+ * 在以下使用kvm_lapic_set_vector():
+ *   - arch/x86/kvm/lapic.c|1439| <<__apic_accept_irq>> kvm_lapic_set_vector(vector, apic->regs + APIC_TMR);
+ *   - arch/x86/kvm/lapic.h|163| <<kvm_lapic_set_irr>> kvm_lapic_set_vector(vec, apic->regs + APIC_IRR);
+ */
 static inline void kvm_lapic_set_vector(int vec, void *bitmap)
 {
 	set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));
 }
 
+/*
+ * 在以下调用kvm_lapic_set_irr():
+ *   - arch/x86/kvm/svm/svm.c|3678| <<svm_deliver_interrupt>> kvm_lapic_set_irr(vector, apic);
+ *   - arch/x86/kvm/vmx/vmx.c|4134| <<vmx_deliver_interrupt>> kvm_lapic_set_irr(vector, apic);
+ */
 static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)
 {
 	kvm_lapic_set_vector(vec, apic->regs + APIC_IRR);
@@ -177,6 +226,16 @@ extern struct static_key_false_deferred apic_hw_disabled;
 
 static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)
 {
+	/*
+	 * 在以下使用apic_hw_disabled:
+	 *   - arch/x86/kvm/lapic.c|130| <<global>> __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_hw_disabled, HZ);
+	 *   - arch/x86/kvm/lapic.c|2323| <<kvm_free_lapic>> static_branch_slow_dec_deferred(&apic_hw_disabled);
+	 *   - arch/x86/kvm/lapic.c|2403| <<kvm_lapic_set_base>> static_branch_slow_dec_deferred(&apic_hw_disabled);
+	 *   - arch/x86/kvm/lapic.c|2407| <<kvm_lapic_set_base>> static_branch_inc(&apic_hw_disabled.key);
+	 *   - arch/x86/kvm/lapic.c|3130| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_hw_disabled);
+	 *   - arch/x86/kvm/lapic.c|3131| <<kvm_lapic_exit>> WARN_ON(static_branch_unlikely(&apic_hw_disabled.key));
+	 *   - arch/x86/kvm/lapic.h|180| <<kvm_apic_hw_enabled>> if (static_branch_unlikely(&apic_hw_disabled.key))
+	 */
 	if (static_branch_unlikely(&apic_hw_disabled.key))
 		return apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;
 	return MSR_IA32_APICBASE_ENABLE;
@@ -186,6 +245,17 @@ extern struct static_key_false_deferred apic_sw_disabled;
 
 static inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)
 {
+	/*
+	 * 在以下使用apic_sw_disabled:
+	 *   - arch/x86/kvm/lapic.c|131| <<global>> __read_mostly DEFINE_STATIC_KEY_DEFERRED_FALSE(apic_sw_disabled, HZ);
+	 *   - arch/x86/kvm/lapic.c|352| <<apic_set_spiv>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|354| <<apic_set_spiv>> static_branch_inc(&apic_sw_disabled.key);
+	 *   - arch/x86/kvm/lapic.c|2304| <<kvm_free_lapic>> static_branch_slow_dec_deferred(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|2593| <<kvm_create_lapic>> static_branch_inc(&apic_sw_disabled.key);
+	 *   - arch/x86/kvm/lapic.c|3084| <<kvm_lapic_exit>> static_key_deferred_flush(&apic_sw_disabled);
+	 *   - arch/x86/kvm/lapic.c|3085| <<kvm_lapic_exit>> WARN_ON(static_branch_unlikely(&apic_sw_disabled.key));
+	 *   - arch/x86/kvm/lapic.h|189| <<kvm_apic_sw_enabled>> if (static_branch_unlikely(&apic_sw_disabled.key))
+	 */
 	if (static_branch_unlikely(&apic_sw_disabled.key))
 		return apic->sw_enabled;
 	return true;
@@ -213,6 +283,25 @@ static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)
 
 static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)
 {
+	/*
+	 * 在以下使用kvm_lapic->pending_events:
+	 *   - arch/x86/kvm/lapic.c|1476| <<__apic_accept_irq>> apic->pending_events = (1UL << KVM_APIC_INIT);
+	 *   - arch/x86/kvm/lapic.c|1487| <<__apic_accept_irq>> set_bit(KVM_APIC_SIPI, &apic->pending_events);
+	 *   - arch/x86/kvm/lapic.c|3633| <<kvm_apic_accept_events>> pe = smp_load_acquire(&apic->pending_events);
+	 *   - arch/x86/kvm/lapic.c|3661| <<kvm_apic_accept_events>> clear_bit(KVM_APIC_SIPI, &apic->pending_events);
+	 *   - arch/x86/kvm/lapic.c|3666| <<kvm_apic_accept_events>> clear_bit(KVM_APIC_INIT, &apic->pending_events);
+	 *   - arch/x86/kvm/lapic.c|3674| <<kvm_apic_accept_events>> clear_bit(KVM_APIC_SIPI, &apic->pending_events);
+	 *   - arch/x86/kvm/lapic.h|251| <<kvm_apic_has_events>> return lapic_in_kernel(vcpu) && vcpu->arch.apic->pending_events;
+	 *   - arch/x86/kvm/lapic.h|262| <<kvm_lapic_latched_init>> return lapic_in_kernel(vcpu) && test_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
+	 *   - arch/x86/kvm/svm/nested.c|1288| <<svm_check_nested_events>> test_bit(KVM_APIC_INIT, &apic->pending_events)) {
+	 *   - arch/x86/kvm/vmx/nested.c|3919| <<vmx_check_nested_events>> test_bit(KVM_APIC_INIT, &apic->pending_events)) {
+	 *   - arch/x86/kvm/vmx/nested.c|3923| <<vmx_check_nested_events>> clear_bit(KVM_APIC_INIT, &apic->pending_events);
+	 *   - arch/x86/kvm/vmx/nested.c|3930| <<vmx_check_nested_events>> test_bit(KVM_APIC_SIPI, &apic->pending_events)) {
+	 *   - arch/x86/kvm/vmx/nested.c|3934| <<vmx_check_nested_events>> clear_bit(KVM_APIC_SIPI, &apic->pending_events);
+	 *   - arch/x86/kvm/x86.c|5020| <<kvm_vcpu_ioctl_x86_set_vcpu_events>> set_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
+	 *   - arch/x86/kvm/x86.c|5022| <<kvm_vcpu_ioctl_x86_set_vcpu_events>> clear_bit(KVM_APIC_INIT, &vcpu->arch.apic->pending_events);
+	 *   - arch/x86/kvm/x86.c|11011| <<kvm_arch_vcpu_ioctl_set_mpstate>> set_bit(KVM_APIC_SIPI, &vcpu->arch.apic->pending_events);
+	 */
 	return lapic_in_kernel(vcpu) && vcpu->arch.apic->pending_events;
 }
 
diff --git a/arch/x86/kvm/svm/avic.c b/arch/x86/kvm/svm/avic.c
index df2d33395a48..4beca330eaeb 100644
--- a/arch/x86/kvm/svm/avic.c
+++ b/arch/x86/kvm/svm/avic.c
@@ -495,6 +495,14 @@ int avic_incomplete_ipi_interception(struct kvm_vcpu *vcpu)
 		 * in which case KVM needs to emulate the ICR write as well in
 		 * order to clear the BUSY flag.
 		 */
+		/*
+		 * 在以下调用kvm_apic_send_ipi()
+		 *   - arch/x86/kvm/lapic.c|2676| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));
+		 *   - arch/x86/kvm/lapic.c|2750| <<kvm_lapic_reg_write>> kvm_apic_send_ipi(apic, APIC_DEST_SELF | val, 0);
+		 *   - arch/x86/kvm/lapic.c|2820| <<kvm_apic_write_nodecode>> kvm_apic_send_ipi(apic, (u32)val, (u32)(val >> 32));
+		 *   - arch/x86/kvm/lapic.c|3577| <<kvm_x2apic_icr_write>> kvm_apic_send_ipi(apic, (u32)data, (u32)(data >> 32));
+		 *   - arch/x86/kvm/svm/avic.c|501| <<avic_incomplete_ipi_interception>> kvm_apic_send_ipi(apic, icrl, icrh);
+		 */
 		if (icrl & APIC_ICR_BUSY)
 			kvm_apic_write_nodecode(vcpu, APIC_ICR);
 		else
@@ -918,6 +926,18 @@ int avic_pi_update_irte(struct kvm *kvm, unsigned int host_irq,
 		 __func__, host_irq, guest_irq, set);
 
 	idx = srcu_read_lock(&kvm->irq_srcu);
+	/*
+	 * 在以下使用kvm->irq_routing:
+	 *   - arch/x86/kvm/hyperv.c|531| <<kvm_hv_irq_routing_update>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - arch/x86/kvm/irq_comm.c|469| <<kvm_scan_ioapic_routes>> table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/svm/avic.c|929| <<avic_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|291| <<vmx_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|60| <<kvm_irq_map_gsi>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - virt/kvm/irqchip.c|88| <<kvm_irq_map_chip_pin>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|222| <<kvm_free_irq_routing>> struct kvm_irq_routing_table *rt = rcu_access_pointer(kvm->irq_routing);
+	 *   - virt/kvm/irqchip.c|421| <<kvm_set_irq_routing>> old = rcu_dereference_protected(kvm->irq_routing, 1);
+	 *   - virt/kvm/irqchip.c|422| <<kvm_set_irq_routing>> rcu_assign_pointer(kvm->irq_routing, new);
+	 */
 	irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
 
 	if (guest_irq >= irq_rt->nr_rt_entries ||
diff --git a/arch/x86/kvm/vmx/posted_intr.c b/arch/x86/kvm/vmx/posted_intr.c
index cb93a31a77c3..23a90c88256c 100644
--- a/arch/x86/kvm/vmx/posted_intr.c
+++ b/arch/x86/kvm/vmx/posted_intr.c
@@ -17,6 +17,15 @@
 static DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);
 static DEFINE_PER_CPU(raw_spinlock_t, blocked_vcpu_on_cpu_lock);
 
+/*
+ * 在以下使用vcpu_to_pi_desc():
+ *   - arch/x86/kvm/vmx/posted_intr.c|27| <<vmx_vcpu_pi_load>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ *   - arch/x86/kvm/vmx/posted_intr.c|90| <<vmx_vcpu_pi_put>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ *   - arch/x86/kvm/vmx/posted_intr.c|102| <<__pi_post_block>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ *   - arch/x86/kvm/vmx/posted_intr.c|148| <<pi_pre_block>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ *   - arch/x86/kvm/vmx/posted_intr.c|222| <<pi_wakeup_handler>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ *   - arch/x86/kvm/vmx/posted_intr.c|238| <<pi_has_pending_interrupt>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+ */
 static inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)
 {
 	return &(to_vmx(vcpu)->pi_desc);
@@ -279,6 +288,18 @@ int vmx_pi_update_irte(struct kvm *kvm, unsigned int host_irq,
 		return 0;
 
 	idx = srcu_read_lock(&kvm->irq_srcu);
+	/*
+	 * 在以下使用kvm->irq_routing:
+	 *   - arch/x86/kvm/hyperv.c|531| <<kvm_hv_irq_routing_update>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - arch/x86/kvm/irq_comm.c|469| <<kvm_scan_ioapic_routes>> table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/svm/avic.c|929| <<avic_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|291| <<vmx_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|60| <<kvm_irq_map_gsi>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - virt/kvm/irqchip.c|88| <<kvm_irq_map_chip_pin>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|222| <<kvm_free_irq_routing>> struct kvm_irq_routing_table *rt = rcu_access_pointer(kvm->irq_routing);
+	 *   - virt/kvm/irqchip.c|421| <<kvm_set_irq_routing>> old = rcu_dereference_protected(kvm->irq_routing, 1);
+	 *   - virt/kvm/irqchip.c|422| <<kvm_set_irq_routing>> rcu_assign_pointer(kvm->irq_routing, new);
+	 */
 	irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
 	if (guest_irq >= irq_rt->nr_rt_entries ||
 	    hlist_empty(&irq_rt->map[guest_irq])) {
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index 8b5abf2c76bd..315b576e34e5 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -5349,6 +5349,9 @@ static int handle_apic_access(struct kvm_vcpu *vcpu)
 	return kvm_emulate_instruction(vcpu, 0);
 }
 
+/*
+ * arch/x86/kvm/vmx/vmx.c|5769| <<global>> [EXIT_REASON_EOI_INDUCED] = handle_apic_eoi_induced,
+ */
 static int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)
 {
 	unsigned long exit_qualification = vmx_get_exit_qual(vcpu);
@@ -6415,6 +6418,43 @@ static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu)
 	put_page(page);
 }
 
+/*
+ * vmx_hwapic_isr_update
+ * kvm_lapic_reset
+ * kvm_vcpu_reset
+ * kvm_apic_accept_events
+ * kvm_arch_vcpu_ioctl_run
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * vmx_hwapic_isr_update
+ * kvm_lapic_reset
+ * kvm_vcpu_reset
+ * kvm_arch_vcpu_create
+ * kvm_vm_ioctl_create_vcpu
+ * kvm_vm_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * vmx_hwapic_isr_update
+ * kvm_apic_set_state
+ * kvm_arch_vcpu_ioctl
+ * kvm_vcpu_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * 在以下调用kvm_x86_hwapic_isr_update:
+ *   - arch/x86/kvm/lapic.c|720| <<apic_set_isr>> static_call(kvm_x86_hwapic_isr_update)(vcpu, vec);
+ *   - arch/x86/kvm/lapic.c|780| <<apic_clear_isr>> static_call(kvm_x86_hwapic_isr_update)(vcpu,
+ *   - arch/x86/kvm/lapic.c|2913| <<kvm_lapic_reset>> static_call(kvm_x86_hwapic_isr_update)(vcpu, -1);
+ *   - arch/x86/kvm/lapic.c|3224| <<kvm_apic_set_state>> static_call(kvm_x86_hwapic_isr_update)(vcpu,
+ *
+ * struct kvm_x86_ops vmx_x86_ops.hwapic_isr_update = vmx_hwapic_isr_update()
+ */
 static void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)
 {
 	u16 status;
@@ -6432,6 +6472,11 @@ static void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)
 	}
 }
 
+/*
+ * 在以下使用vmx_set_rvi():
+ *   - arch/x86/kvm/vmx/vmx.c|6491| <<vmx_hwapic_irr_update>> vmx_set_rvi(max_irr);
+ *   - arch/x86/kvm/vmx/vmx.c|6541| <<vmx_sync_pir_to_irr>> vmx_set_rvi(max_irr);
+ */
 static void vmx_set_rvi(int vector)
 {
 	u16 status;
@@ -6440,6 +6485,25 @@ static void vmx_set_rvi(int vector)
 	if (vector == -1)
 		vector = 0;
 
+	/*
+	 * 注释
+	 *
+	 * Guest interrupt status (16 bits). This field is supported only on
+	 * processors that support the 1-setting of the "virtual-interrupt
+	 * delivery" VM-execution control. It characterizes part of the guest’s
+	 * virtual-APIC state and does not correspond to any processor or APIC
+	 * registers. It comprises two 8-bit subfields:
+	 *
+	 * - Requesting virtual interrupt (RVI). This is the low byte of the
+	 * guest interrupt status. The processor treats this value as the
+	 * vector of the highest priority virtual interrupt that is requesting
+	 * service. (The value 0 implies that there is no such interrupt.)
+	 *
+	 * - Servicing virtual interrupt (SVI). This is the high byte of the
+	 * guest interrupt status. The processor treats this value as the
+	 * vector of the highest priority virtual interrupt that is in service.
+	 * (The value 0 implies that there is no such interrupt.)
+	 */
 	status = vmcs_read16(GUEST_INTR_STATUS);
 	old = (u8)status & 0xff;
 	if ((u8)vector != old) {
@@ -6449,6 +6513,14 @@ static void vmx_set_rvi(int vector)
 	}
 }
 
+/*
+ * 在以下调用vmx_hwapic_irr_update():
+ *   - arch/x86/kvm/lapic.c|682| <<apic_clear_irr>> static_call(kvm_x86_hwapic_irr_update)(vcpu,
+ *   - arch/x86/kvm/lapic.c|2920| <<kvm_lapic_reset>> static_call(kvm_x86_hwapic_irr_update)(vcpu, -1);
+ *   - arch/x86/kvm/lapic.c|3230| <<kvm_apic_set_state>> static_call(kvm_x86_hwapic_irr_update)(vcpu,
+ *
+ * struct kvm_x86_ops vmx_x86_ops.hwapic_irr_update = vmx_hwapic_irr_update()
+ */
 static void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)
 {
 	/*
@@ -6463,6 +6535,14 @@ static void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)
 		vmx_set_rvi(max_irr);
 }
 
+/*
+ * 在以下调用vmx_sync_pir_to_irr():
+ *   - arch/x86/kvm/lapic.c|912| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+ *   - arch/x86/kvm/x86.c|4672| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ *   - arch/x86/kvm/x86.c|9911| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ *   - arch/x86/kvm/x86.c|10204| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ *   - arch/x86/kvm/x86.c|10253| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+ */
 static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
@@ -6472,6 +6552,29 @@ static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)
 	if (KVM_BUG_ON(!enable_apicv, vcpu->kvm))
 		return -EIO;
 
+	/*
+	 * 在以下使用vcpu_to_pi_desc():
+	 *   - arch/x86/kvm/vmx/posted_intr.c|27| <<vmx_vcpu_pi_load>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|90| <<vmx_vcpu_pi_put>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|102| <<__pi_post_block>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|148| <<pi_pre_block>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|222| <<pi_wakeup_handler>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|238| <<pi_has_pending_interrupt>> struct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);
+	 *
+	 * 在以下使用vcpu_vmx->pi_desc:
+	 *   - arch/x86/kvm/vmx/posted_intr.c|22| <<vcpu_to_pi_desc>> return &(to_vmx(vcpu)->pi_desc);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|327| <<vmx_pi_update_irte>> vcpu_info.pi_desc_addr = __pa(&to_vmx(vcpu)->pi_desc);
+	 *   - arch/x86/kvm/vmx/vmx.c|4115| <<vmx_deliver_posted_interrupt>> if (pi_test_and_set_pir(vector, &vmx->pi_desc))
+	 *   - arch/x86/kvm/vmx/vmx.c|4119| <<vmx_deliver_posted_interrupt>> if (pi_test_and_set_on(&vmx->pi_desc))
+	 *   - arch/x86/kvm/vmx/vmx.c|4488| <<init_vmcs>> vmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));
+	 *   - arch/x86/kvm/vmx/vmx.c|6511| <<vmx_sync_pir_to_irr>> if (pi_test_on(&vmx->pi_desc)) {
+	 *   - arch/x86/kvm/vmx/vmx.c|6512| <<vmx_sync_pir_to_irr>> pi_clear_on(&vmx->pi_desc);
+	 *   - arch/x86/kvm/vmx/vmx.c|6519| <<vmx_sync_pir_to_irr>> kvm_apic_update_irr(vcpu, vmx->pi_desc.pir, &max_irr);
+	 *   - arch/x86/kvm/vmx/vmx.c|6563| <<vmx_apicv_post_state_restore>> pi_clear_on(&vmx->pi_desc);
+	 *   - arch/x86/kvm/vmx/vmx.c|6564| <<vmx_apicv_post_state_restore>> memset(vmx->pi_desc.pir, 0, sizeof(vmx->pi_desc.pir));
+	 *   - arch/x86/kvm/vmx/vmx.c|7182| <<vmx_vcpu_create>> vmx->pi_desc.nv = POSTED_INTR_VECTOR;
+	 *   - arch/x86/kvm/vmx/vmx.c|7183| <<vmx_vcpu_create>> vmx->pi_desc.sn = 1;
+	 */
 	if (pi_test_on(&vmx->pi_desc)) {
 		pi_clear_on(&vmx->pi_desc);
 		/*
@@ -6479,9 +6582,19 @@ static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)
 		 * But on x86 this is just a compiler barrier anyway.
 		 */
 		smp_mb__after_atomic();
+		/*
+		 * vmx_sync_pir_to_irr()
+		 * -> kvm_apic_update_irr()
+		 *    -> __kvm_apic_update_irr()
+		 */
 		got_posted_interrupt =
 			kvm_apic_update_irr(vcpu, vmx->pi_desc.pir, &max_irr);
 	} else {
+		/*
+		 * 在以下使用kvm_lapic_find_highest_irr():
+		 *   - arch/x86/kvm/vmx/vmx.c|6562| <<vmx_sync_pir_to_irr>> max_irr = kvm_lapic_find_highest_irr(vcpu);
+		 *   - arch/x86/kvm/x86.c|9322| <<update_cr8_intercept>> max_irr = kvm_lapic_find_highest_irr(vcpu);
+		 */
 		max_irr = kvm_lapic_find_highest_irr(vcpu);
 		got_posted_interrupt = false;
 	}
@@ -6501,6 +6614,13 @@ static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)
 	 * attempt to post interrupts.  The posted interrupt vector will cause
 	 * a VM-Exit and the subsequent entry will call sync_pir_to_irr.
 	 */
+	/*
+	 * 在以下使用vmx_set_rvi():
+	 *   - arch/x86/kvm/vmx/vmx.c|6491| <<vmx_hwapic_irr_update>> vmx_set_rvi(max_irr);
+	 *   - arch/x86/kvm/vmx/vmx.c|6541| <<vmx_sync_pir_to_irr>> vmx_set_rvi(max_irr);
+	 *
+	 * 基本就是第一个if语句了
+	 */
 	if (!is_guest_mode(vcpu) && kvm_vcpu_apicv_active(vcpu))
 		vmx_set_rvi(max_irr);
 	else if (got_posted_interrupt)
@@ -6509,6 +6629,9 @@ static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)
 	return max_irr;
 }
 
+/*
+ * struct kvm_x86_ops vmx_x86_ops.load_eoi_exitmap = vmx_load_eoi_exitmap()
+ */
 static void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
 {
 	if (!kvm_vcpu_apicv_active(vcpu))
@@ -6942,6 +7065,9 @@ static fastpath_t vmx_vcpu_run(struct kvm_vcpu *vcpu)
 
 	kvm_wait_lapic_expire(vcpu);
 
+	/*
+	 * 就是这里进入!!!!
+	 */
 	/* The actual VMENTER/EXIT is in the .noinstr.text section. */
 	vmx_vcpu_enter_exit(vcpu, vmx, __vmx_vcpu_run_flags(vmx));
 
diff --git a/arch/x86/kvm/vmx/vmx.h b/arch/x86/kvm/vmx/vmx.h
index 538e0a2e4cff..355a248e4782 100644
--- a/arch/x86/kvm/vmx/vmx.h
+++ b/arch/x86/kvm/vmx/vmx.h
@@ -309,6 +309,21 @@ struct vcpu_vmx {
 
 	union vmx_exit_reason exit_reason;
 
+	/*
+	 * 在以下使用vcpu_vmx->pi_desc:
+	 *   - arch/x86/kvm/vmx/posted_intr.c|22| <<vcpu_to_pi_desc>> return &(to_vmx(vcpu)->pi_desc);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|327| <<vmx_pi_update_irte>> vcpu_info.pi_desc_addr = __pa(&to_vmx(vcpu)->pi_desc);
+	 *   - arch/x86/kvm/vmx/vmx.c|4115| <<vmx_deliver_posted_interrupt>> if (pi_test_and_set_pir(vector, &vmx->pi_desc))
+	 *   - arch/x86/kvm/vmx/vmx.c|4119| <<vmx_deliver_posted_interrupt>> if (pi_test_and_set_on(&vmx->pi_desc))
+	 *   - arch/x86/kvm/vmx/vmx.c|4488| <<init_vmcs>> vmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));
+	 *   - arch/x86/kvm/vmx/vmx.c|6511| <<vmx_sync_pir_to_irr>> if (pi_test_on(&vmx->pi_desc)) {
+	 *   - arch/x86/kvm/vmx/vmx.c|6512| <<vmx_sync_pir_to_irr>> pi_clear_on(&vmx->pi_desc);
+	 *   - arch/x86/kvm/vmx/vmx.c|6519| <<vmx_sync_pir_to_irr>> kvm_apic_update_irr(vcpu, vmx->pi_desc.pir, &max_irr);
+	 *   - arch/x86/kvm/vmx/vmx.c|6563| <<vmx_apicv_post_state_restore>> pi_clear_on(&vmx->pi_desc);
+	 *   - arch/x86/kvm/vmx/vmx.c|6564| <<vmx_apicv_post_state_restore>> memset(vmx->pi_desc.pir, 0, sizeof(vmx->pi_desc.pir));
+	 *   - arch/x86/kvm/vmx/vmx.c|7182| <<vmx_vcpu_create>> vmx->pi_desc.nv = POSTED_INTR_VECTOR;
+	 *   - arch/x86/kvm/vmx/vmx.c|7183| <<vmx_vcpu_create>> vmx->pi_desc.sn = 1;
+	 */
 	/* Posted interrupt descriptor */
 	struct pi_desc pi_desc;
 
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 4e98e0459e70..81e674c87673 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -185,6 +185,14 @@ EXPORT_SYMBOL_GPL(enable_vmware_backdoor);
 static bool __read_mostly force_emulation_prefix = false;
 module_param(force_emulation_prefix, bool, S_IRUGO);
 
+/*
+ * 在以下使用pi_inject_timer:
+ *   - arch/x86/kvm/x86.c|188| <<global>> int __read_mostly pi_inject_timer = -1;
+ *   - arch/x86/kvm/x86.c|189| <<global>> module_param(pi_inject_timer, bint, S_IRUGO | S_IWUSR);
+ *   - arch/x86/kvm/lapic.c|163| <<kvm_can_post_timer_interrupt>> return pi_inject_timer && kvm_vcpu_apicv_active(vcpu) &&
+ *   - arch/x86/kvm/x86.c|8848| <<kvm_arch_init>> if (pi_inject_timer == -1)
+ *   - arch/x86/kvm/x86.c|8849| <<kvm_arch_init>> pi_inject_timer = housekeeping_enabled(HK_FLAG_TIMER);
+ */
 int __read_mostly pi_inject_timer = -1;
 module_param(pi_inject_timer, bint, S_IRUGO | S_IWUSR);
 
@@ -2614,6 +2622,13 @@ static void kvm_synchronize_tsc(struct kvm_vcpu *vcpu, u64 data)
 	kvm->arch.last_tsc_write = data;
 	kvm->arch.last_tsc_khz = vcpu->arch.virtual_tsc_khz;
 
+	/*
+	 * 在以下使用kvm_vcpu_arch->last_guest_tsc:
+	 *   - arch/x86/kvm/x86.c|2625| <<kvm_synchronize_tsc>> vcpu->arch.last_guest_tsc = data;
+	 *   - arch/x86/kvm/x86.c|3053| <<kvm_guest_time_update>> vcpu->last_guest_tsc = tsc_timestamp;
+	 *   - arch/x86/kvm/x86.c|4535| <<kvm_arch_vcpu_load>> u64 offset = kvm_compute_l1_tsc_offset(vcpu, vcpu->arch.last_guest_tsc);
+	 *   - arch/x86/kvm/x86.c|10223| <<vcpu_enter_guest>> vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());
+	 */
 	vcpu->arch.last_guest_tsc = data;
 
 	/* Keep track of which generation this VCPU has synchronized to */
@@ -3042,6 +3057,13 @@ static int kvm_guest_time_update(struct kvm_vcpu *v)
 
 	vcpu->hv_clock.tsc_timestamp = tsc_timestamp;
 	vcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;
+	/*
+	 * 在以下使用kvm_vcpu_arch->last_guest_tsc:
+	 *   - arch/x86/kvm/x86.c|2625| <<kvm_synchronize_tsc>> vcpu->arch.last_guest_tsc = data;
+	 *   - arch/x86/kvm/x86.c|3053| <<kvm_guest_time_update>> vcpu->last_guest_tsc = tsc_timestamp;
+	 *   - arch/x86/kvm/x86.c|4535| <<kvm_arch_vcpu_load>> u64 offset = kvm_compute_l1_tsc_offset(vcpu, vcpu->arch.last_guest_tsc);
+	 *   - arch/x86/kvm/x86.c|10223| <<vcpu_enter_guest>> vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());
+	 */
 	vcpu->last_guest_tsc = tsc_timestamp;
 
 	/* If the host uses TSC clocksource, then it is stable */
@@ -4517,12 +4539,29 @@ void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
 	}
 
 	if (unlikely(vcpu->cpu != cpu) || kvm_check_tsc_unstable()) {
+		/*
+		 * 在以下使用kvm_vcpu_arch->last_host_tsc:
+		 *   - arch/x86/kvm/x86.c|4528| <<kvm_arch_vcpu_load>> s64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :
+		 *   - arch/x86/kvm/x86.c|4529| <<kvm_arch_vcpu_load>> rdtsc() - vcpu->arch.last_host_tsc;
+		 *   - arch/x86/kvm/x86.c|4625| <<kvm_arch_vcpu_put>> vcpu->arch.last_host_tsc = rdtsc();
+		 *   - arch/x86/kvm/x86.c|11541| <<kvm_arch_hardware_enable>> if (stable && vcpu->arch.last_host_tsc > local_tsc) {
+		 *   - arch/x86/kvm/x86.c|11543| <<kvm_arch_hardware_enable>> if (vcpu->arch.last_host_tsc > max_tsc)
+		 *   - arch/x86/kvm/x86.c|11544| <<kvm_arch_hardware_enable>> max_tsc = vcpu->arch.last_host_tsc;
+		 *   - arch/x86/kvm/x86.c|11593| <<kvm_arch_hardware_enable>> vcpu->arch.last_host_tsc = local_tsc;
+		 */
 		s64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :
 				rdtsc() - vcpu->arch.last_host_tsc;
 		if (tsc_delta < 0)
 			mark_tsc_unstable("KVM discovered backwards TSC");
 
 		if (kvm_check_tsc_unstable()) {
+			/*
+			 * 在以下使用kvm_vcpu_arch->last_guest_tsc:
+			 *   - arch/x86/kvm/x86.c|2625| <<kvm_synchronize_tsc>> vcpu->arch.last_guest_tsc = data;
+			 *   - arch/x86/kvm/x86.c|3053| <<kvm_guest_time_update>> vcpu->last_guest_tsc = tsc_timestamp;
+			 *   - arch/x86/kvm/x86.c|4535| <<kvm_arch_vcpu_load>> u64 offset = kvm_compute_l1_tsc_offset(vcpu, vcpu->arch.last_guest_tsc);
+			 *   - arch/x86/kvm/x86.c|10223| <<vcpu_enter_guest>> vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());
+			 */
 			u64 offset = kvm_compute_l1_tsc_offset(vcpu,
 						vcpu->arch.last_guest_tsc);
 			kvm_vcpu_write_tsc_offset(vcpu, offset);
@@ -4614,12 +4653,32 @@ void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
 	}
 
 	static_call(kvm_x86_vcpu_put)(vcpu);
+	/*
+	 * 在以下使用kvm_vcpu_arch->last_host_tsc:
+	 *   - arch/x86/kvm/x86.c|4528| <<kvm_arch_vcpu_load>> s64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :
+	 *   - arch/x86/kvm/x86.c|4529| <<kvm_arch_vcpu_load>> rdtsc() - vcpu->arch.last_host_tsc;
+	 *   - arch/x86/kvm/x86.c|4625| <<kvm_arch_vcpu_put>> vcpu->arch.last_host_tsc = rdtsc();
+	 *   - arch/x86/kvm/x86.c|11541| <<kvm_arch_hardware_enable>> if (stable && vcpu->arch.last_host_tsc > local_tsc) {
+	 *   - arch/x86/kvm/x86.c|11543| <<kvm_arch_hardware_enable>> if (vcpu->arch.last_host_tsc > max_tsc)
+	 *   - arch/x86/kvm/x86.c|11544| <<kvm_arch_hardware_enable>> max_tsc = vcpu->arch.last_host_tsc;
+	 *   - arch/x86/kvm/x86.c|11593| <<kvm_arch_hardware_enable>> vcpu->arch.last_host_tsc = local_tsc;
+	 */
 	vcpu->arch.last_host_tsc = rdtsc();
 }
 
 static int kvm_vcpu_ioctl_get_lapic(struct kvm_vcpu *vcpu,
 				    struct kvm_lapic_state *s)
 {
+	/*
+	 * 在以下调用vmx_sync_pir_to_irr():
+	 *   - arch/x86/kvm/lapic.c|912| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+	 *   - arch/x86/kvm/x86.c|4672| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|9911| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10204| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10253| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *
+	 * vmx_sync_pir_to_irr()
+	 */
 	static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
 	return kvm_apic_get_state(vcpu, s);
@@ -4691,6 +4750,15 @@ static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,
 	if (vcpu->arch.pending_external_vector != -1)
 		return -EEXIST;
 
+	/*
+	 * 在以下使用kvm_vcpu_arch->pending_external_vector:
+	 *   - arch/x86/kvm/irq.c|42| <<pending_userspace_extint>> return v->arch.pending_external_vector != -1;
+	 *   - arch/x86/kvm/irq.c|135| <<kvm_cpu_get_extint>> int vector = v->arch.pending_external_vector;
+	 *   - arch/x86/kvm/irq.c|137| <<kvm_cpu_get_extint>> v->arch.pending_external_vector = -1;
+	 *   - arch/x86/kvm/x86.c|4750| <<kvm_vcpu_ioctl_interrupt>> if (vcpu->arch.pending_external_vector != -1)
+	 *   - arch/x86/kvm/x86.c|4753| <<kvm_vcpu_ioctl_interrupt>> vcpu->arch.pending_external_vector = irq->irq;
+	 *   - arch/x86/kvm/x86.c|11459| <<kvm_arch_vcpu_create>> vcpu->arch.pending_external_vector = -1;
+	 */
 	vcpu->arch.pending_external_vector = irq->irq;
 	kvm_make_request(KVM_REQ_EVENT, vcpu);
 	return 0;
@@ -5151,6 +5219,12 @@ long kvm_arch_vcpu_ioctl(struct file *filp,
 		r = -EINVAL;
 		if (!lapic_in_kernel(vcpu))
 			goto out;
+		/*
+		 * 128 #define KVM_APIC_REG_SIZE 0x400
+		 * 129 struct kvm_lapic_state {
+		 * 130         char regs[KVM_APIC_REG_SIZE];
+		 * 131 };
+		 */
 		u.lapic = kzalloc(sizeof(struct kvm_lapic_state),
 				GFP_KERNEL_ACCOUNT);
 
@@ -5720,6 +5794,10 @@ static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 	return 0;
 }
 
+/*
+ * 在以下使用KVM_REINJECT_CONTROL:
+ *   - arch/x86/kvm/x86.c|6401| <<kvm_arch_vm_ioctl>> r = kvm_vm_ioctl_reinject(kvm, &control);
+ */
 static int kvm_vm_ioctl_reinject(struct kvm *kvm,
 				 struct kvm_reinject_control *control)
 {
@@ -5752,6 +5830,10 @@ void kvm_arch_sync_dirty_log(struct kvm *kvm, struct kvm_memory_slot *memslot)
 		kvm_vcpu_kick(vcpu);
 }
 
+/*
+ * 处理KVM_IRQ_LINE_STATUS和KVM_IRQ_LINE:
+ *   - virt/kvm/kvm_main.c|4597| <<kvm_vm_ioctl>> r = kvm_vm_ioctl_irq_line(kvm, &irq_event,
+ */
 int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_event,
 			bool line_status)
 {
@@ -5793,6 +5875,13 @@ int kvm_vm_ioctl_enable_cap(struct kvm *kvm,
 		/* Pairs with irqchip_in_kernel. */
 		smp_wmb();
 		kvm->arch.irqchip_mode = KVM_IRQCHIP_SPLIT;
+		/*
+		 * 在以下使用kvm_arch->nr_reserved_ioapic_pins:
+		 *   - arch/x86/kvm/irq_comm.c|446| <<kvm_scan_ioapic_routes>> nr_ioapic_pins =
+		 *               min_t(u32, table->nr_rt_entries, kvm->arch.nr_reserved_ioapic_pins);
+		 *   - arch/x86/kvm/x86.c|5874| <<kvm_vm_ioctl_enable_cap(KVM_CAP_SPLIT_IRQCHIP)>>
+		 *               kvm->arch.nr_reserved_ioapic_pins = cap->args[0];
+		 */
 		kvm->arch.nr_reserved_ioapic_pins = cap->args[0];
 		kvm_clear_apicv_inhibit(kvm, APICV_INHIBIT_REASON_ABSENT);
 		r = 0;
@@ -8845,6 +8934,14 @@ int kvm_arch_init(void *opaque)
 		supported_xcr0 = host_xcr0 & KVM_SUPPORTED_XCR0;
 	}
 
+	/*
+	 * 在以下使用pi_inject_timer:
+	 *   - arch/x86/kvm/x86.c|188| <<global>> int __read_mostly pi_inject_timer = -1;
+	 *   - arch/x86/kvm/x86.c|189| <<global>> module_param(pi_inject_timer, bint, S_IRUGO | S_IWUSR);
+	 *   - arch/x86/kvm/lapic.c|163| <<kvm_can_post_timer_interrupt>> return pi_inject_timer && kvm_vcpu_apicv_active(vcpu) &&
+	 *   - arch/x86/kvm/x86.c|8848| <<kvm_arch_init>> if (pi_inject_timer == -1)
+	 *   - arch/x86/kvm/x86.c|8849| <<kvm_arch_init>> pi_inject_timer = housekeeping_enabled(HK_FLAG_TIMER);
+	 */
 	if (pi_inject_timer == -1)
 		pi_inject_timer = housekeeping_enabled(HK_FLAG_TIMER);
 #ifdef CONFIG_X86_64
@@ -8864,6 +8961,11 @@ int kvm_arch_init(void *opaque)
 	return r;
 }
 
+/*
+ * 在以下调用kvm_arch_exit():
+ *   - virt/kvm/kvm_main.c|5737| <<kvm_init>> kvm_arch_exit();
+ *   - virt/kvm/kvm_main.c|5764| <<kvm_exit>> kvm_arch_exit();
+ */
 void kvm_arch_exit(void)
 {
 #ifdef CONFIG_X86_64
@@ -8891,6 +8993,11 @@ void kvm_arch_exit(void)
 #endif
 }
 
+/*
+ * 在以下使用__kvm_vcpu_halt():
+ *   - arch/x86/kvm/x86.c|8970| <<kvm_vcpu_halt>> return __kvm_vcpu_halt(vcpu, KVM_MP_STATE_HALTED, KVM_EXIT_HLT);
+ *   - arch/x86/kvm/x86.c|8989| <<kvm_emulate_ap_reset_hold>> return __kvm_vcpu_halt(vcpu, KVM_MP_STATE_AP_RESET_HOLD, KVM_EXIT_AP_RESET_HOLD) && ret;
+ */
 static int __kvm_vcpu_halt(struct kvm_vcpu *vcpu, int state, int reason)
 {
 	++vcpu->stat.halt_exits;
@@ -8903,6 +9010,13 @@ static int __kvm_vcpu_halt(struct kvm_vcpu *vcpu, int state, int reason)
 	}
 }
 
+/*
+ * 在以下使用kvm_vcpu_halt():
+ *   - arch/x86/kvm/vmx/nested.c|3646| <<nested_vmx_run>> return kvm_vcpu_halt(vcpu);
+ *   - arch/x86/kvm/vmx/vmx.c|4845| <<handle_rmode_exception>> return kvm_vcpu_halt(vcpu);
+ *   - arch/x86/kvm/vmx/vmx.c|5552| <<handle_invalid_guest_state>> return kvm_vcpu_halt(vcpu);
+ *   - arch/x86/kvm/x86.c|8981| <<kvm_emulate_halt>> return kvm_vcpu_halt(vcpu) && ret;
+ */
 int kvm_vcpu_halt(struct kvm_vcpu *vcpu)
 {
 	return __kvm_vcpu_halt(vcpu, KVM_MP_STATE_HALTED, KVM_EXIT_HLT);
@@ -8983,6 +9097,15 @@ static void kvm_pv_kick_cpu_op(struct kvm *kvm, unsigned long flags, int apicid)
 		.dest_id = apicid,
 	};
 
+	/*
+	 * 在以下调用kvm_irq_delivery_to_apic():
+	 *   - arch/x86/kvm/hyperv.c|482| <<synic_set_irq>> ret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);
+	 *   - arch/x86/kvm/ioapic.c|444| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, &ioapic->rtc_status.dest_map);
+	 *   - arch/x86/kvm/ioapic.c|448| <<ioapic_service>> ret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);
+	 *   - arch/x86/kvm/irq_comm.c|142| <<kvm_set_msi>> return kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);
+	 *   - arch/x86/kvm/lapic.c|1723| <<kvm_apic_send_ipi>> kvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);
+	 *   - arch/x86/kvm/x86.c|9079| <<kvm_pv_kick_cpu_op>> kvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);
+	 */
 	kvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);
 }
 
@@ -9268,6 +9391,19 @@ static void kvm_inject_exception(struct kvm_vcpu *vcpu)
 	static_call(kvm_x86_inject_exception)(vcpu);
 }
 
+/*
+ * 在以下调用inject_pending_event():
+ *   - arch/x86/kvm/x86.c|10148| <<vcpu_enter_guest>> r = inject_pending_event(vcpu, &req_immediate_exit);
+ *
+ * vcpu_enter_guest()
+ * -> if (kvm_cpu_has_injectable_intr(vcpu)) {
+ *      inject_pending_event()
+ *      -> kvm_cpu_get_interrupt()
+ *         -> kvm_get_apic_interrupt()
+ *            -> apic_set_isr()
+ *
+ * 注意kvm_cpu_has_injectable_intr()
+ */
 static int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)
 {
 	int r;
@@ -9393,7 +9529,18 @@ static int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)
 			static_call(kvm_x86_enable_nmi_window)(vcpu);
 	}
 
+	/*
+	 * 这里很重要
+	 * check if there is injectable interrupt:
+	 * when virtual interrupt delivery enabled,
+	 * interrupt from apic will handled by hardware,
+	 * we don't need to check it here.
+	 * 也就是说, 一般括号里不会执行
+	 */
 	if (kvm_cpu_has_injectable_intr(vcpu)) {
+		/*
+		 * vmx_interrupt_allowed()
+		 */
 		r = can_inject ? static_call(kvm_x86_interrupt_allowed)(vcpu, true) : -EBUSY;
 		if (r < 0)
 			goto out;
@@ -9401,7 +9548,17 @@ static int inject_pending_event(struct kvm_vcpu *vcpu, bool *req_immediate_exit)
 			int irq = kvm_cpu_get_interrupt(vcpu);
 
 			if (!WARN_ON_ONCE(irq == -1)) {
+				/*
+				 * 做了下面的:
+				 * vcpu->arch.interrupt.injected = true;
+				 * vcpu->arch.interrupt.soft = soft;
+				 * vcpu->arch.interrupt.nr = vector;
+				 */
 				kvm_queue_interrupt(vcpu, irq, false);
+				/*
+				 * vmx_inject_irq()
+				 * 也没见写ISR
+				 */
 				static_call(kvm_x86_inject_irq)(vcpu, false);
 				WARN_ON(static_call(kvm_x86_interrupt_allowed)(vcpu, true) < 0);
 			}
@@ -9716,6 +9873,10 @@ static void process_smi(struct kvm_vcpu *vcpu)
 	kvm_make_request(KVM_REQ_EVENT, vcpu);
 }
 
+/*
+ * 在以下调用kvm_make_scan_ioapic_request_mask():
+ *   - arch/x86/kvm/ioapic.c|439| <<ioapic_write_indirect>> kvm_make_scan_ioapic_request_mask(ioapic->kvm, vcpu_bitmap);
+ */
 void kvm_make_scan_ioapic_request_mask(struct kvm *kvm,
 				       unsigned long *vcpu_bitmap)
 {
@@ -9723,14 +9884,40 @@ void kvm_make_scan_ioapic_request_mask(struct kvm *kvm,
 
 	zalloc_cpumask_var(&cpus, GFP_ATOMIC);
 
+	/*
+	 * 在以下使用KVM_REQ_SCAN_IOAPIC:
+	 *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+	 *   - arch/x86/kvm/x86.c|9868| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+	 *   - arch/x86/kvm/x86.c|9876| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+	 *   - arch/x86/kvm/x86.c|10159| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
+	 *
+	 * 处理的函数: vcpu_scan_ioapic(vcpu);
+	 */
 	kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
 				    NULL, vcpu_bitmap, cpus);
 
 	free_cpumask_var(cpus);
 }
 
+/*
+ * 在以下使用kvm_make_scan_ioapic_request():
+ *   - arch/x86/kvm/ioapic.c|345| <<kvm_arch_post_irq_ack_notifier_list_update>> kvm_make_scan_ioapic_request(kvm);
+ *   - arch/x86/kvm/ioapic.c|442| <<ioapic_write_indirect>> kvm_make_scan_ioapic_request(ioapic->kvm);
+ *   - arch/x86/kvm/ioapic.c|879| <<kvm_set_ioapic>> kvm_make_scan_ioapic_request(kvm);
+ *   - arch/x86/kvm/irq_comm.c|408| <<kvm_arch_post_irq_routing_update>> kvm_make_scan_ioapic_request(kvm);
+ *   - arch/x86/kvm/lapic.c|436| <<kvm_recalculate_apic_map>> kvm_make_scan_ioapic_request(kvm);
+ */
 void kvm_make_scan_ioapic_request(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用KVM_REQ_SCAN_IOAPIC:
+	 *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+	 *   - arch/x86/kvm/x86.c|9868| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+	 *   - arch/x86/kvm/x86.c|9876| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+	 *   - arch/x86/kvm/x86.c|10159| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
+	 *
+	 * 处理的函数: vcpu_scan_ioapic(vcpu);
+	 */
 	kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
 }
 
@@ -9824,13 +10011,39 @@ void kvm_set_or_clear_apicv_inhibit(struct kvm *kvm,
 }
 EXPORT_SYMBOL_GPL(kvm_set_or_clear_apicv_inhibit);
 
+/*
+ * 在以下使用KVM_REQ_SCAN_IOAPIC:
+ *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+ *   - arch/x86/kvm/x86.c|9868| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+ *   - arch/x86/kvm/x86.c|9876| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+ *   - arch/x86/kvm/x86.c|10159| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
+ *
+ * 处理的函数: vcpu_scan_ioapic(vcpu);
+ *
+ * 处理KVM_REQ_SCAN_IOAPIC:
+ *   - arch/x86/kvm/x86.c|10156| <<vcpu_enter_guest>> vcpu_scan_ioapic(vcpu);
+ */
 static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)
 {
 	if (!kvm_apic_present(vcpu))
 		return;
 
+	/*
+	 * 在以下使用ioapic_handled_vectors:
+	 *   - arch/x86/kvm/lapic.c|1614| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10020| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+	 *   - arch/x86/kvm/x86.c|10025| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10027| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10044| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap,
+	 *              vcpu->arch.ioapic_handled_vectors, to_hv_synic(vcpu)->vec_bitmap, 256);
+	 *   - arch/x86/kvm/x86.c|10051| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10193| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+	 */
 	bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
 
+	/*
+	 * vmx_sync_pir_to_irr()
+	 */
 	static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
 	if (irqchip_split(vcpu->kvm))
@@ -9838,12 +10051,36 @@ static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)
 	else if (ioapic_in_kernel(vcpu->kvm))
 		kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
 
+	/*
+	 * 在以下使用kvm_vcpu_arch->load_eoi_exitmap_pending:
+	 *   - arch/x86/kvm/kvm_cache_regs.h|184| <<leave_guest_mode>> if (vcpu->arch.load_eoi_exitmap_pending) {
+	 *   - arch/x86/kvm/kvm_cache_regs.h|185| <<leave_guest_mode>> vcpu->arch.load_eoi_exitmap_pending = false;
+	 *   - arch/x86/kvm/x86.c|10048| <<vcpu_scan_ioapic>> vcpu->arch.load_eoi_exitmap_pending = true;
+	 *
+	 * 在以下使用KVM_REQ_LOAD_EOI_EXITMAP:
+	 *   - arch/x86/kvm/kvm_cache_regs.h|186| <<leave_guest_mode>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+	 *   - arch/x86/kvm/x86.c|10050| <<vcpu_scan_ioapic>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+	 *   - arch/x86/kvm/x86.c|10256| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))
+	 *
+	 * 处理的函数vcpu_load_eoi_exitmap()
+	 */
 	if (is_guest_mode(vcpu))
 		vcpu->arch.load_eoi_exitmap_pending = true;
 	else
 		kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
 }
 
+/*
+ * 在以下使用KVM_REQ_LOAD_EOI_EXITMAP:
+ *   - arch/x86/kvm/kvm_cache_regs.h|186| <<leave_guest_mode>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+ *   - arch/x86/kvm/x86.c|10050| <<vcpu_scan_ioapic>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+ *   - arch/x86/kvm/x86.c|10256| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))
+ *
+ * 处理的函数vcpu_load_eoi_exitmap()
+ *
+ * 在以下调用vcpu_load_eoi_exitmap():
+ *   - arch/x86/kvm/x86.c|10213| <<vcpu_enter_guest(KVM_REQ_LOAD_EOI_EXITMAP)>> vcpu_load_eoi_exitmap(vcpu);
+ */
 static void vcpu_load_eoi_exitmap(struct kvm_vcpu *vcpu)
 {
 	u64 eoi_exit_bitmap[4];
@@ -9859,6 +10096,19 @@ static void vcpu_load_eoi_exitmap(struct kvm_vcpu *vcpu)
 		return;
 	}
 
+	/*
+	 * 在以下使用ioapic_handled_vectors:
+	 *   - arch/x86/kvm/lapic.c|1614| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10020| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+	 *   - arch/x86/kvm/x86.c|10025| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10027| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10044| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap,
+	 *              vcpu->arch.ioapic_handled_vectors, to_hv_synic(vcpu)->vec_bitmap, 256);
+	 *   - arch/x86/kvm/x86.c|10051| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+	 *   - arch/x86/kvm/x86.c|10193| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+	 *
+	 * vmx_load_eoi_exitmap()
+	 */
 	static_call(kvm_x86_load_eoi_exitmap)(
 		vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
 }
@@ -9904,6 +10154,15 @@ EXPORT_SYMBOL_GPL(__kvm_request_immediate_exit);
  * exiting to the userspace.  Otherwise, the value will be returned to the
  * userspace.
  */
+/*
+ * 只在以下使用vcpu_enter_guest():
+ *   - arch/x86/kvm/x86.c|10380| <<vcpu_run>> r = vcpu_enter_guest(vcpu);
+ *
+ * 注释:
+ * Returns 1 to let vcpu_run() continue the guest execution loop without
+ * exiting to the userspace.  Otherwise, the value will be returned to the
+ * userspace.
+ */
 static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 {
 	int r;
@@ -9992,6 +10251,17 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 			kvm_pmu_deliver_pmi(vcpu);
 		if (kvm_check_request(KVM_REQ_IOAPIC_EOI_EXIT, vcpu)) {
 			BUG_ON(vcpu->arch.pending_ioapic_eoi > 255);
+			/*
+			 * 在以下使用ioapic_handled_vectors:
+			 *   - arch/x86/kvm/lapic.c|1614| <<kvm_ioapic_handles_vector>> return test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|10020| <<vcpu_scan_ioapic>> bitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);
+			 *   - arch/x86/kvm/x86.c|10025| <<vcpu_scan_ioapic>> kvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|10027| <<vcpu_scan_ioapic>> kvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|10044| <<vcpu_load_eoi_exitmap>> bitmap_or((ulong *)eoi_exit_bitmap,
+			 *              vcpu->arch.ioapic_handled_vectors, to_hv_synic(vcpu)->vec_bitmap, 256);
+			 *   - arch/x86/kvm/x86.c|10051| <<vcpu_load_eoi_exitmap>> static_call(kvm_x86_load_eoi_exitmap)(vcpu, (u64 *)vcpu->arch.ioapic_handled_vectors);
+			 *   - arch/x86/kvm/x86.c|10193| <<vcpu_enter_guest>> if (test_bit(vcpu->arch.pending_ioapic_eoi, vcpu->arch.ioapic_handled_vectors)) {
+			 */
 			if (test_bit(vcpu->arch.pending_ioapic_eoi,
 				     vcpu->arch.ioapic_handled_vectors)) {
 				vcpu->run->exit_reason = KVM_EXIT_IOAPIC_EOI;
@@ -10001,8 +10271,25 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 				goto out;
 			}
 		}
+		/*
+		 * 在以下使用KVM_REQ_SCAN_IOAPIC:
+		 *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+		 *   - arch/x86/kvm/x86.c|9868| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+		 *   - arch/x86/kvm/x86.c|9876| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+		 *   - arch/x86/kvm/x86.c|10159| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
+		 *
+		 * 处理的函数: vcpu_scan_ioapic(vcpu);
+		 */
 		if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
 			vcpu_scan_ioapic(vcpu);
+		/*
+		 * 在以下使用KVM_REQ_LOAD_EOI_EXITMAP:
+		 *   - arch/x86/kvm/kvm_cache_regs.h|186| <<leave_guest_mode>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+		 *   - arch/x86/kvm/x86.c|10050| <<vcpu_scan_ioapic>> kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);
+		 *   - arch/x86/kvm/x86.c|10256| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))
+		 *
+		 * 处理的函数vcpu_load_eoi_exitmap()
+		 */
 		if (kvm_check_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu))
 			vcpu_load_eoi_exitmap(vcpu);
 		if (kvm_check_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu))
@@ -10114,6 +10401,16 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 	 * use the POSTED_INTR_VECTOR even if APICv is disabled,
 	 * so do it even if APICv is disabled on this vCPU.
 	 */
+	/*
+	 * 在以下调用vmx_sync_pir_to_irr():
+	 *   - arch/x86/kvm/lapic.c|912| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+	 *   - arch/x86/kvm/x86.c|4672| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|9911| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10204| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *   - arch/x86/kvm/x86.c|10253| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+	 *
+	 * vmx_sync_pir_to_irr()
+	 */
 	if (kvm_lapic_enabled(vcpu))
 		static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
@@ -10159,10 +10456,28 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 		WARN_ON_ONCE((kvm_vcpu_apicv_activated(vcpu) != kvm_vcpu_apicv_active(vcpu)) &&
 			     (kvm_get_apic_mode(vcpu) != LAPIC_MODE_DISABLED));
 
+		/*
+		 * vmx_vcpu_run()
+		 */
 		exit_fastpath = static_call(kvm_x86_vcpu_run)(vcpu);
+		/*
+		 * enum exit_fastpath_completion {
+		 *     EXIT_FASTPATH_NONE,
+		 *     EXIT_FASTPATH_REENTER_GUEST,
+		 *     EXIT_FASTPATH_EXIT_HANDLED,
+		 * };
+		 */
 		if (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST))
 			break;
 
+		/*
+		 * 在以下调用vmx_sync_pir_to_irr():
+		 *   - arch/x86/kvm/lapic.c|912| <<apic_has_interrupt_for_ppr>> highest_irr = static_call(kvm_x86_sync_pir_to_irr)(apic->vcpu);
+		 *   - arch/x86/kvm/x86.c|4672| <<kvm_vcpu_ioctl_get_lapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 *   - arch/x86/kvm/x86.c|9911| <<vcpu_scan_ioapic>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 *   - arch/x86/kvm/x86.c|10204| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 *   - arch/x86/kvm/x86.c|10253| <<vcpu_enter_guest>> static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
+		 */
 		if (kvm_lapic_enabled(vcpu))
 			static_call_cond(kvm_x86_sync_pir_to_irr)(vcpu);
 
@@ -10199,6 +10514,22 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 		hw_breakpoint_restore();
 
 	vcpu->arch.last_vmentry_cpu = vcpu->cpu;
+	/*
+	 * 在以下使用kvm_vcpu_arch->last_host_tsc:
+	 *   - arch/x86/kvm/x86.c|4528| <<kvm_arch_vcpu_load>> s64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :
+	 *   - arch/x86/kvm/x86.c|4529| <<kvm_arch_vcpu_load>> rdtsc() - vcpu->arch.last_host_tsc;
+	 *   - arch/x86/kvm/x86.c|4625| <<kvm_arch_vcpu_put>> vcpu->arch.last_host_tsc = rdtsc();
+	 *   - arch/x86/kvm/x86.c|11541| <<kvm_arch_hardware_enable>> if (stable && vcpu->arch.last_host_tsc > local_tsc) {
+	 *   - arch/x86/kvm/x86.c|11543| <<kvm_arch_hardware_enable>> if (vcpu->arch.last_host_tsc > max_tsc)
+	 *   - arch/x86/kvm/x86.c|11544| <<kvm_arch_hardware_enable>> max_tsc = vcpu->arch.last_host_tsc;
+	 *   - arch/x86/kvm/x86.c|11593| <<kvm_arch_hardware_enable>> vcpu->arch.last_host_tsc = local_tsc;
+	 *
+	 * 在以下使用kvm_vcpu_arch->last_guest_tsc:
+	 *   - arch/x86/kvm/x86.c|2625| <<kvm_synchronize_tsc>> vcpu->arch.last_guest_tsc = data;
+	 *   - arch/x86/kvm/x86.c|3053| <<kvm_guest_time_update>> vcpu->last_guest_tsc = tsc_timestamp;
+	 *   - arch/x86/kvm/x86.c|4535| <<kvm_arch_vcpu_load>> u64 offset = kvm_compute_l1_tsc_offset(vcpu, vcpu->arch.last_guest_tsc);
+	 *   - arch/x86/kvm/x86.c|10223| <<vcpu_enter_guest>> vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());
+	 */
 	vcpu->arch.last_guest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());
 
 	vcpu->mode = OUTSIDE_GUEST_MODE;
@@ -10279,10 +10610,17 @@ static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
 	return r;
 }
 
+/*
+ * 只在以下调用vcpu_block():
+ *   - arch/x86/kvm/x86.c|10382| <<vcpu_run>> r = vcpu_block(kvm, vcpu);
+ */
 static inline int vcpu_block(struct kvm *kvm, struct kvm_vcpu *vcpu)
 {
 	bool hv_timer;
 
+	/*
+	 * vmx_pre_block()
+	 */
 	if (!kvm_arch_vcpu_runnable(vcpu) &&
 	    (!kvm_x86_ops.pre_block || static_call(kvm_x86_pre_block)(vcpu) == 0)) {
 		/*
@@ -10293,16 +10631,33 @@ static inline int vcpu_block(struct kvm *kvm, struct kvm_vcpu *vcpu)
 		 * timer before blocking.
 		 */
 		hv_timer = kvm_lapic_hv_timer_in_use(vcpu);
+		/*
+		 * 只在此处调用kvm_lapic_switch_to_sw_timer()
+		 */
 		if (hv_timer)
 			kvm_lapic_switch_to_sw_timer(vcpu);
 
 		srcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);
+		/*
+		 * 在以下使用kvm_vcpu_block():
+		 *   - arch/x86/kvm/x86.c|10321| <<vcpu_block>> kvm_vcpu_block(vcpu);
+		 *   - arch/x86/kvm/x86.c|10533| <<kvm_arch_vcpu_ioctl_run>> kvm_vcpu_block(vcpu);
+		 *
+		 * 注释是:
+		 * The vCPU has executed a HLT instruction with in-kernel mode enabled.
+		 */
 		kvm_vcpu_block(vcpu);
 		vcpu->srcu_idx = srcu_read_lock(&kvm->srcu);
 
+		/*
+		 * 只在此处调用kvm_lapic_switch_to_hv_timer()
+		 */
 		if (hv_timer)
 			kvm_lapic_switch_to_hv_timer(vcpu);
 
+		/*
+		 * vmx_post_block()
+		 */
 		if (kvm_x86_ops.post_block)
 			static_call(kvm_x86_post_block)(vcpu);
 
@@ -10312,6 +10667,12 @@ static inline int vcpu_block(struct kvm *kvm, struct kvm_vcpu *vcpu)
 
 	if (kvm_apic_accept_events(vcpu) < 0)
 		return 0;
+	/*
+	 * 在以下使用KVM_MP_STATE_HALTED:
+	 *   - arch/x86/kvm/vmx/nested.c|4180| <<sync_vmcs02_to_vmcs12>> if (vcpu->arch.mp_state == KVM_MP_STATE_HALTED)
+	 *   - arch/x86/kvm/x86.c|8970| <<kvm_vcpu_halt>> return __kvm_vcpu_halt(vcpu, KVM_MP_STATE_HALTED, KVM_EXIT_HLT);
+	 *   - arch/x86/kvm/x86.c|10873| <<kvm_arch_vcpu_ioctl_get_mpstate>> if ((vcpu->arch.mp_state == KVM_MP_STATE_HALTED ||
+	 */
 	switch(vcpu->arch.mp_state) {
 	case KVM_MP_STATE_HALTED:
 	case KVM_MP_STATE_AP_RESET_HOLD:
@@ -10356,6 +10717,15 @@ static int vcpu_run(struct kvm_vcpu *vcpu)
 		 */
 		vcpu->arch.at_instruction_boundary = false;
 		if (kvm_vcpu_running(vcpu)) {
+			/*
+			 * 只在以下使用vcpu_enter_guest():
+			 *   - arch/x86/kvm/x86.c|10380| <<vcpu_run>> r = vcpu_enter_guest(vcpu);
+			 *
+			 * 注释:
+			 * Returns 1 to let vcpu_run() continue the guest execution loop without
+			 * exiting to the userspace.  Otherwise, the value will be returned to the
+			 * userspace.
+			 */
 			r = vcpu_enter_guest(vcpu);
 		} else {
 			r = vcpu_block(kvm, vcpu);
@@ -10365,6 +10735,11 @@ static int vcpu_run(struct kvm_vcpu *vcpu)
 			break;
 
 		kvm_clear_request(KVM_REQ_UNBLOCK, vcpu);
+		/*
+		 * 在以下使用kvm_cpu_has_pending_timer():
+		 *   - arch/x86/kvm/x86.c|10389| <<vcpu_run>> if (kvm_cpu_has_pending_timer(vcpu))
+		 *   - virt/kvm/kvm_main.c|3282| <<kvm_vcpu_check_block>> if (kvm_cpu_has_pending_timer(vcpu))
+		 */
 		if (kvm_cpu_has_pending_timer(vcpu))
 			kvm_inject_pending_timer_irqs(vcpu);
 
@@ -10509,6 +10884,14 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
 		 * use before KVM has ever run the vCPU.
 		 */
 		WARN_ON_ONCE(kvm_lapic_hv_timer_in_use(vcpu));
+		/*
+		 * 在以下使用kvm_vcpu_block():
+		 *   - arch/x86/kvm/x86.c|10321| <<vcpu_block>> kvm_vcpu_block(vcpu);
+		 *   - arch/x86/kvm/x86.c|10533| <<kvm_arch_vcpu_ioctl_run>> kvm_vcpu_block(vcpu);
+		 *
+		 * 注释是:
+		 * The vCPU has executed a HLT instruction with in-kernel mode enabled.
+		 */
 		kvm_vcpu_block(vcpu);
 		if (kvm_apic_accept_events(vcpu) < 0) {
 			r = 0;
@@ -11262,6 +11645,15 @@ int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
 	kvm_async_pf_hash_reset(vcpu);
 	kvm_pmu_init(vcpu);
 
+	/*
+	 * 在以下使用kvm_vcpu_arch->pending_external_vector:
+	 *   - arch/x86/kvm/irq.c|42| <<pending_userspace_extint>> return v->arch.pending_external_vector != -1;
+	 *   - arch/x86/kvm/irq.c|135| <<kvm_cpu_get_extint>> int vector = v->arch.pending_external_vector;
+	 *   - arch/x86/kvm/irq.c|137| <<kvm_cpu_get_extint>> v->arch.pending_external_vector = -1;
+	 *   - arch/x86/kvm/x86.c|4750| <<kvm_vcpu_ioctl_interrupt>> if (vcpu->arch.pending_external_vector != -1)
+	 *   - arch/x86/kvm/x86.c|4753| <<kvm_vcpu_ioctl_interrupt>> vcpu->arch.pending_external_vector = irq->irq;
+	 *   - arch/x86/kvm/x86.c|11459| <<kvm_arch_vcpu_create>> vcpu->arch.pending_external_vector = -1;
+	 */
 	vcpu->arch.pending_external_vector = -1;
 	vcpu->arch.preempted_in_kernel = false;
 
@@ -11517,6 +11909,16 @@ int kvm_arch_hardware_enable(void)
 		kvm_for_each_vcpu(i, vcpu, kvm) {
 			if (!stable && vcpu->cpu == smp_processor_id())
 				kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);
+			/*
+			 * 在以下使用kvm_vcpu_arch->last_host_tsc:
+			 *   - arch/x86/kvm/x86.c|4528| <<kvm_arch_vcpu_load>> s64 tsc_delta = !vcpu->arch.last_host_tsc ? 0 :
+			 *   - arch/x86/kvm/x86.c|4529| <<kvm_arch_vcpu_load>> rdtsc() - vcpu->arch.last_host_tsc;
+			 *   - arch/x86/kvm/x86.c|4625| <<kvm_arch_vcpu_put>> vcpu->arch.last_host_tsc = rdtsc();
+			 *   - arch/x86/kvm/x86.c|11541| <<kvm_arch_hardware_enable>> if (stable && vcpu->arch.last_host_tsc > local_tsc) {
+			 *   - arch/x86/kvm/x86.c|11543| <<kvm_arch_hardware_enable>> if (vcpu->arch.last_host_tsc > max_tsc)
+			 *   - arch/x86/kvm/x86.c|11544| <<kvm_arch_hardware_enable>> max_tsc = vcpu->arch.last_host_tsc;
+			 *   - arch/x86/kvm/x86.c|11593| <<kvm_arch_hardware_enable>> vcpu->arch.last_host_tsc = local_tsc;
+			 */
 			if (stable && vcpu->arch.last_host_tsc > local_tsc) {
 				backwards_tsc = true;
 				if (vcpu->arch.last_host_tsc > max_tsc)
@@ -11705,6 +12107,12 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 	if (ret)
 		return ret;
 
+	/*
+	 * 在以下使用kvm_arch->mask_notifier_list:
+	 *   - arch/x86/kvm/irq_comm.c|256| <<kvm_register_irq_mask_notifier>> hlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);
+	 *   - arch/x86/kvm/irq_comm.c|278| <<kvm_fire_mask_notifiers>> hlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)
+	 *   - arch/x86/kvm/x86.c|12073| <<kvm_arch_init_vm>> INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
+	 */
 	INIT_HLIST_HEAD(&kvm->arch.mask_notifier_list);
 	INIT_LIST_HEAD(&kvm->arch.active_mmu_pages);
 	INIT_LIST_HEAD(&kvm->arch.zapped_obsolete_pages);
@@ -11712,6 +12120,13 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 	INIT_LIST_HEAD(&kvm->arch.assigned_dev_head);
 	atomic_set(&kvm->arch.noncoherent_dma_count, 0);
 
+	/*
+	 * 在以下使用kvm_arch->irq_sources_bitmap:
+	 *   - arch/x86/kvm/irq_comm.c|209| <<kvm_request_irq_source_id>> unsigned long *bitmap = &kvm->arch.irq_sources_bitmap;
+	 *   - arch/x86/kvm/irq_comm.c|241| <<kvm_free_irq_source_id>> clear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|12081| <<kvm_arch_init_vm>> set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 *   - arch/x86/kvm/x86.c|12084| <<kvm_arch_init_vm>> set_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
+	 */
 	/* Reserve bit 0 of irq_sources_bitmap for userspace irq source */
 	set_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);
 	/* Reserve bit 1 of irq_sources_bitmap for irqfd-resampler */
diff --git a/arch/x86/kvm/x86.h b/arch/x86/kvm/x86.h
index f7854e742e8c..dae7c9f2e9d7 100644
--- a/arch/x86/kvm/x86.h
+++ b/arch/x86/kvm/x86.h
@@ -376,6 +376,11 @@ static inline bool kvm_mwait_in_guest(struct kvm *kvm)
 
 static inline bool kvm_hlt_in_guest(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用kvm_arch->hlt_in_guest:
+	 *   - arch/x86/kvm/x86.c|5835| <<kvm_vm_ioctl_enable_cap>> kvm->arch.hlt_in_guest = true;
+	 *   - arch/x86/kvm/x86.h|379| <<kvm_hlt_in_guest>> return kvm->arch.hlt_in_guest;
+	 */
 	return kvm->arch.hlt_in_guest;
 }
 
diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index a9e3a7cd4068..ef05e9f6d049 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -437,6 +437,11 @@ static void acpi_bus_osc_negotiate_usb_control(void)
  * ---------------
  * Callback for all 'system-level' device notifications (values 0x00-0x7F).
  */
+/*
+ * 在以下使用acpi_bus_notify():
+ *   - drivers/acpi/bus.c|1298| <<acpi_bus_init>>
+ *     status = acpi_install_notify_handler(ACPI_ROOT_OBJECT, ACPI_SYSTEM_NOTIFY, &acpi_bus_notify, NULL);
+ */
 static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 {
 	struct acpi_device *adev;
diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c
index 60a8d7a5ff03..f4029ad6a3aa 100644
--- a/drivers/acpi/device_pm.c
+++ b/drivers/acpi/device_pm.c
@@ -72,6 +72,26 @@ static int acpi_dev_pm_explicit_get(struct acpi_device *device, int *state)
  * state shallower than previously set by acpi_device_set_power() for @device
  * (if that power state depends on any power resources).
  */
+/*
+ * acpi_device_get_power
+ * acpi_bus_init_power
+ * acpi_bus_attach
+ * acpi_bus_scan
+ * acpiphp_rescan_slot
+ * hotplug_event
+ * acpiphp_hotplug_notify
+ * acpi_device_hotplug
+ * acpi_hotplug_work_fn
+ * process_one_work
+ * worker_thread
+ * kthread
+ * ret_from_fork
+ *
+ * 在以下调用acpi_device_get_power():
+ *   - drivers/acpi/device_pm.c|311| <<acpi_bus_init_power>> result = acpi_device_get_power(device, &state);
+ *   - drivers/acpi/device_pm.c|381| <<acpi_device_update_power>> result = acpi_device_get_power(device, &state);
+ *   - drivers/acpi/device_sysfs.c|349| <<real_power_state_show>> ret = acpi_device_get_power(adev, &state);
+ */
 int acpi_device_get_power(struct acpi_device *device, int *state)
 {
 	int result = ACPI_STATE_UNKNOWN;
@@ -157,6 +177,25 @@ static int acpi_dev_pm_explicit_set(struct acpi_device *adev, int state)
  * Callers must ensure that the device is power manageable before using this
  * function.
  */
+/*
+ * 在以下使用acpi_device_set_power():
+ *   - drivers/acpi/device_pm.c|297| <<acpi_bus_set_power>> return acpi_device_set_power(device, state);
+ *   - drivers/acpi/device_pm.c|399| <<acpi_device_update_power>> result = acpi_device_set_power(device, state);
+ *   - drivers/acpi/device_pm.c|898| <<acpi_dev_pm_low_power>> return ret ? ret : acpi_device_set_power(adev, state);
+ *   - drivers/acpi/device_pm.c|908| <<acpi_dev_pm_full_power>> return acpi_device_power_manageable(adev) ? acpi_device_set_power(adev, ACPI_STATE_D0) : 0;
+ *   - drivers/acpi/fan.c|182| <<fan_set_state>> return acpi_device_set_power(device, state ? ACPI_STATE_D0 : ACPI_STATE_D3_COLD);
+ *   - drivers/acpi/fan.c|475| <<acpi_fan_suspend>> acpi_device_set_power(ACPI_COMPANION(dev), ACPI_STATE_D0);
+ *   - drivers/acpi/scan.c|2540| <<acpi_bus_trim>> acpi_device_set_power(adev, ACPI_STATE_D3_COLD);
+ *   - drivers/hid/i2c-hid/i2c-hid-acpi.c|77| <<i2c_hid_acpi_shutdown_tail>> acpi_device_set_power(ihid_acpi->adev, ACPI_STATE_D3_COLD);
+ *   - drivers/pci/hotplug/acpiphp_glue.c|446| <<acpiphp_rescan_slot>> acpi_device_set_power(adev, ACPI_STATE_D0);
+ *   - drivers/pci/pci-acpi.c|1058| <<acpi_pci_set_power_state>> error = acpi_device_set_power(adev, state_conv[state]);
+ *   - drivers/pnp/pnpacpi/core.c|85| <<pnpacpi_set_resources>> ret = acpi_device_set_power(acpi_dev, ACPI_STATE_D0);
+ *   - drivers/pnp/pnpacpi/core.c|105| <<pnpacpi_disable_resources>> acpi_device_set_power(acpi_dev, ACPI_STATE_D3_COLD);
+ *   - drivers/pnp/pnpacpi/core.c|158| <<pnpacpi_suspend>> error = acpi_device_set_power(acpi_dev, power_state);
+ *   - drivers/pnp/pnpacpi/core.c|178| <<pnpacpi_resume>> error = acpi_device_set_power(acpi_dev, ACPI_STATE_D0);
+ *   - drivers/staging/media/atomisp/pci/atomisp_gmin_platform.c|959| <<gmin_acpi_pm_ctrl>> ret = acpi_device_set_power(adev, ACPI_STATE_D0);
+ *   - drivers/staging/media/atomisp/pci/atomisp_gmin_platform.c|962| <<gmin_acpi_pm_ctrl>> ret = acpi_device_set_power(adev, ACPI_STATE_D3_COLD);
+ */
 int acpi_device_set_power(struct acpi_device *device, int state)
 {
 	int target_state = state;
@@ -378,6 +417,12 @@ int acpi_device_update_power(struct acpi_device *device, int *state_p)
 		return result;
 	}
 
+	/*
+	 * 在以下调用acpi_device_get_power():
+	 *   - drivers/acpi/device_pm.c|311| <<acpi_bus_init_power>> result = acpi_device_get_power(device, &state);
+	 *   - drivers/acpi/device_pm.c|381| <<acpi_device_update_power>> result = acpi_device_get_power(device, &state);
+	 *   - drivers/acpi/device_sysfs.c|349| <<real_power_state_show>> ret = acpi_device_get_power(adev, &state);
+	 */
 	result = acpi_device_get_power(device, &state);
 	if (result)
 		return result;
diff --git a/drivers/acpi/dock.c b/drivers/acpi/dock.c
index a89bdbe00184..70e686057de0 100644
--- a/drivers/acpi/dock.c
+++ b/drivers/acpi/dock.c
@@ -270,6 +270,17 @@ static void hotplug_dock_devices(struct dock_station *ds, u32 event)
 		struct acpi_device *adev = dd->adev;
 
 		if (!acpi_device_enumerated(adev)) {
+			/*
+			 * 在以下调用acpi_bus_scan():
+			 *   - drivers/acpi/dock.c|273| <<hotplug_dock_devices>> int ret = acpi_bus_scan(adev->handle);
+			 *   - drivers/acpi/scan.c|321| <<acpi_scan_device_check>> error = acpi_bus_scan(adev->handle);
+			 *   - drivers/acpi/scan.c|346| <<acpi_scan_bus_check>> error = acpi_bus_scan(adev->handle);
+			 *   - drivers/acpi/scan.c|2631| <<acpi_scan_init>> result = acpi_bus_scan(ACPI_ROOT_OBJECT);
+			 *   - drivers/acpi/scan.c|2702| <<acpi_table_events_fn>> acpi_bus_scan(ACPI_ROOT_OBJECT);
+			 *   - drivers/pci/hotplug/acpiphp_glue.c|428| <<acpiphp_rescan_slot>> acpi_bus_scan(adev->handle);
+			 *   - drivers/platform/surface/surface3-wmi.c|233| <<s3_wmi_probe>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+			 *   - drivers/platform/surface/surface3-wmi.c|243| <<s3_wmi_remove>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+			 */
 			int ret = acpi_bus_scan(adev->handle);
 
 			if (ret)
diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c
index 45c5c0e45e33..c7c96ea56b84 100644
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@ -841,6 +841,11 @@ acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,
 }
 #endif
 
+/*
+ * 在以下使用acpi_os_execute_deferred():
+ *   - drivers/acpi/osl.c|1104| <<acpi_os_execute>> INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+ *   - drivers/acpi/osl.c|1107| <<acpi_os_execute>> INIT_WORK(&dpc->work, acpi_os_execute_deferred);
+ */
 static void acpi_os_execute_deferred(struct work_struct *work)
 {
 	struct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);
@@ -1152,6 +1157,12 @@ struct acpi_hp_work {
 	u32 src;
 };
 
+/*
+ * 在以下使用acpi_hotplug_work_fn():
+ *   - drivers/acpi/osl.c|1176| <<acpi_hotplug_schedule>> INIT_WORK(&hpw->work, acpi_hotplug_work_fn);
+ *
+ * 似乎在acpi_hotplug_schedule()调用
+ */
 static void acpi_hotplug_work_fn(struct work_struct *work)
 {
 	struct acpi_hp_work *hpw = container_of(work, struct acpi_hp_work, work);
@@ -1161,6 +1172,11 @@ static void acpi_hotplug_work_fn(struct work_struct *work)
 	kfree(hpw);
 }
 
+/*
+ * 在以下使用acpi_hotplug_schedule():
+ *   - drivers/acpi/bus.c|505| <<acpi_bus_notify>> if (ACPI_SUCCESS(acpi_hotplug_schedule(adev, type)))
+ *   - drivers/acpi/device_sysfs.c|388| <<eject_store>> status = acpi_hotplug_schedule(acpi_device, ACPI_OST_EC_OSPM_EJECT);
+ */
 acpi_status acpi_hotplug_schedule(struct acpi_device *adev, u32 src)
 {
 	struct acpi_hp_work *hpw;
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index e7d4a39e539f..b092431cf928 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -318,6 +318,17 @@ static int acpi_scan_device_check(struct acpi_device *adev)
 			dev_dbg(&adev->dev, "Already enumerated\n");
 			return 0;
 		}
+		/*
+		 * 在以下调用acpi_bus_scan():
+		 *   - drivers/acpi/dock.c|273| <<hotplug_dock_devices>> int ret = acpi_bus_scan(adev->handle);
+		 *   - drivers/acpi/scan.c|321| <<acpi_scan_device_check>> error = acpi_bus_scan(adev->handle);
+		 *   - drivers/acpi/scan.c|346| <<acpi_scan_bus_check>> error = acpi_bus_scan(adev->handle);
+		 *   - drivers/acpi/scan.c|2631| <<acpi_scan_init>> result = acpi_bus_scan(ACPI_ROOT_OBJECT);
+		 *   - drivers/acpi/scan.c|2702| <<acpi_table_events_fn>> acpi_bus_scan(ACPI_ROOT_OBJECT);
+		 *   - drivers/pci/hotplug/acpiphp_glue.c|428| <<acpiphp_rescan_slot>> acpi_bus_scan(adev->handle);
+		 *   - drivers/platform/surface/surface3-wmi.c|233| <<s3_wmi_probe>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+		 *   - drivers/platform/surface/surface3-wmi.c|243| <<s3_wmi_remove>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+		 */
 		error = acpi_bus_scan(adev->handle);
 		if (error) {
 			dev_warn(&adev->dev, "Namespace scan failure\n");
@@ -343,6 +354,17 @@ static int acpi_scan_bus_check(struct acpi_device *adev)
 	if (handler && handler->hotplug.scan_dependent)
 		return handler->hotplug.scan_dependent(adev);
 
+	/*
+	 * 在以下调用acpi_bus_scan():
+	 *   - drivers/acpi/dock.c|273| <<hotplug_dock_devices>> int ret = acpi_bus_scan(adev->handle);
+	 *   - drivers/acpi/scan.c|321| <<acpi_scan_device_check>> error = acpi_bus_scan(adev->handle);
+	 *   - drivers/acpi/scan.c|346| <<acpi_scan_bus_check>> error = acpi_bus_scan(adev->handle);
+	 *   - drivers/acpi/scan.c|2631| <<acpi_scan_init>> result = acpi_bus_scan(ACPI_ROOT_OBJECT);
+	 *   - drivers/acpi/scan.c|2702| <<acpi_table_events_fn>> acpi_bus_scan(ACPI_ROOT_OBJECT);
+	 *   - drivers/pci/hotplug/acpiphp_glue.c|428| <<acpiphp_rescan_slot>> acpi_bus_scan(adev->handle);
+	 *   - drivers/platform/surface/surface3-wmi.c|233| <<s3_wmi_probe>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+	 *   - drivers/platform/surface/surface3-wmi.c|243| <<s3_wmi_remove>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+	 */
 	error = acpi_bus_scan(adev->handle);
 	if (error) {
 		dev_warn(&adev->dev, "Namespace scan failure\n");
@@ -376,6 +398,77 @@ static int acpi_generic_hotplug_event(struct acpi_device *adev, u32 type)
 	return -EINVAL;
 }
 
+/*
+ * [  433.553792] <intr> acpi:624: ACPI: GPE event 0x01
+ * [  433.554104] [426] acpi:462: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: ACPI_NOTIFY_DEVICE_CHECK event
+ * [  433.554110] [426] acpi:1168: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: OSL: Scheduling hotplug event 1 for deferred handling
+ * [  433.554178] [97] acpiphp:803: ACPI: \_SB_.PCI0.S29_.S00_: acpiphp_glue: Device check in hotplug_event()
+ * [  433.554184] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._ADR: ACPI: No context!
+ * [  433.554186] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_.ASUN: ACPI: No context!
+ * [  433.554188] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._DSM: ACPI: No context!
+ * [  433.554190] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._SUN: ACPI: No context!
+ * [  433.554191] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._EJ0: ACPI: No context!
+ * [  433.554197] [97] acpi:28: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Evaluate [_STA]: AE_NOT_FOUND
+ * [  433.554199] [97] acpi:125: ACPI: Device [S00] status [0000000f]
+ * [  433.554356] [97] acpi:273: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Return value [0]
+ * [  433.554359] [97] acpi:273: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Return value [0]
+ * [  433.554419] pci 0000:02:00.0: [1af4:1048] type 00 class 0x010000
+ * [  433.555885] pci 0000:02:00.0: reg 0x14: [mem 0x00000000-0x00000fff]
+ * [  433.557122] pci 0000:02:00.0: reg 0x20: [mem 0x00000000-0x00003fff 64bit pref]
+ * [  433.559748] [97] edr:233: pci 0000:02:00.0: EDR: Notify handler installed
+ * [  433.559766] [97] acpi:324: wakeup wakeup15: No ACPI support
+ * [  433.559838] [97] acpi:318: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: Bound to device 0000:02:00.0
+ * [  433.560376] [97] acpi:28: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Evaluate [_STA]: AE_NOT_FOUND
+ * [  433.560402] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._ADR: ACPI: No context!
+ * [  433.560404] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_.ASUN: ACPI: No context!
+ * [  433.560405] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._DSM: ACPI: No context!
+ * [  433.560407] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._SUN: ACPI: No context!
+ * [  433.560409] [97] acpi:579: ACPI: \_SB_.PCI0.S29_.S00_._EJ0: ACPI: No context!
+ * [  433.560411] [97] acpi:28: ACPI: \_SB_.PCI0.S29_.S00_: ACPI: utils: Evaluate [_STA]: AE_NOT_FOUND
+ * [  433.560412] [97] acpi:125: ACPI: Device [S00] status [0000000f]
+ * [  433.560430] pci 0000:02:00.0: BAR 4: assigned [mem 0x802000000-0x802003fff 64bit pref]
+ * [  433.561843] pci 0000:02:00.0: BAR 1: assigned [mem 0x81200000-0x81200fff]
+ * [  433.563130] [97] acpi:1591: pciback 0000:02:00.0: Adding to IOMMU failed: -19
+ * [  433.563136] [97] setup_irq:27: pciback 0000:02:00.0: runtime IRQ mapping not provided by arch
+ * [  433.563161] [97] acpi:1591: virtio-pci 0000:02:00.0: Adding to IOMMU failed: -19
+ * [  433.563164] [97] setup_irq:27: virtio-pci 0000:02:00.0: runtime IRQ mapping not provided by arch
+ * [  433.563197] virtio-pci 0000:02:00.0: enabling device (0000 -> 0002)
+ * [  433.565778] [97] acpi:190: ACPI: PCI: 0000:00:05[A] -> \_SB_.GSIF[0]
+ * [  433.565782] [97] acpi:327: virtio-pci 0000:02:00.0: Derived GSI INT A from 0000:00:05.1
+ * [  433.565786] [97] acpi:649: ACPI: \_SB_.GSIF: ACPI: PCI: Link is referenced
+ * [  433.565791] [97] acpi:466: virtio-pci 0000:02:00.0: PCI INT A -> Link[GSIF] -> GSI 21 (level, high) -> IRQ 21
+ * [  433.566517] [97] pci:4371: virtio-pci 0000:02:00.0: enabling bus mastering
+ * [  433.567195] [97] acpi:324: virtio virtio1: No ACPI support
+ * [  433.567502] [97] acpi:324: workqueue scsi_tmf_7: No ACPI support
+ * [  433.568580] scsi host7: Virtio SCSI HBA
+ * [  433.569371] [97] acpi:324: scsi host7: No ACPI support
+ * [  433.569420] [97] acpi:324: scsi_host host7: No ACPI support
+ * [  433.574553] scsi 7:0:1:0: Direct-Access     LIO-ORG  storage02        4.0  PQ: 0 ANSI: 6
+ * [  433.589101] [1935] acpi:324: scsi target7:0:1: No ACPI support
+ * [  433.589137] scsi 7:0:1:0: alua: supports implicit and explicit TPGS
+ * [  433.590341] scsi 7:0:1:0: alua: device naa.6001405428c34d0d8a342cdbb4597c72 port group 0 rel port 1
+ * [  433.591927] [1935] acpi:324: scsi 7:0:1:0: No ACPI support
+ * [  433.591985] [1935] acpi:324: scsi_device 7:0:1:0: No ACPI support
+ * [  433.592021] [1935] acpi:324: scsi_generic sg3: No ACPI support
+ * [  433.592093] [105] acpi:324: scsi_disk 7:0:1:0: No ACPI support
+ * [  433.592302] sd 7:0:1:0: Attached scsi generic sg3 type 0
+ * [  433.592332] sd 7:0:1:0: [sdc] 262144 512-byte logical blocks: (134 MB/128 MiB)
+ * [  433.593213] [1935] acpi:324: bsg 7:0:1:0: No ACPI support
+ * [  433.594767] sd 7:0:1:0: [sdc] Write Protect is off
+ * [  433.595651] sd 7:0:1:0: [sdc] Mode Sense: 43 00 10 08
+ * [  433.595722] sd 7:0:1:0: [sdc] Write cache: enabled, read cache: enabled, supports DPO and FUA
+ * [  433.597263] sd 7:0:1:0: alua: transition timeout set to 60 seconds
+ * [  433.597270] sd 7:0:1:0: alua: port group 00 state A non-preferred supports TOlUSNA
+ * [  433.703687] sd 7:0:1:0: [sdc] Optimal transfer size 8388608 bytes
+ * [  433.705139] [105] acpi:324: block sdc: No ACPI support
+ * [  433.705660] [105] acpi:324: bdi 8:32: No ACPI support
+ * [  433.706272] sd 7:0:1:0: [sdc] Attached SCSI disk
+ */
+
+/*
+ * 在以下使用acpi_device_hotplug():
+ *   - drivers/acpi/osl.c|1160| <<acpi_hotplug_work_fn>> acpi_device_hotplug(hpw->adev, hpw->src);
+ */
 void acpi_device_hotplug(struct acpi_device *adev, u32 src)
 {
 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
@@ -406,6 +499,10 @@ void acpi_device_hotplug(struct acpi_device *adev, u32 src)
 		 * There may be additional notify handlers for device objects
 		 * without the .event() callback, so ignore them here.
 		 */
+		/*
+		 * 注释: acpiphp_hotplug_notify()
+		 * 错误的时候有的时候没有notify
+		 */
 		if (notify)
 			error = notify(adev, src);
 		else
@@ -2366,6 +2463,17 @@ EXPORT_SYMBOL_GPL(acpi_dev_get_first_consumer_dev);
  *
  * Must be called under acpi_scan_lock.
  */
+/*
+ * 在以下调用acpi_bus_scan():
+ *   - drivers/acpi/dock.c|273| <<hotplug_dock_devices>> int ret = acpi_bus_scan(adev->handle);
+ *   - drivers/acpi/scan.c|321| <<acpi_scan_device_check>> error = acpi_bus_scan(adev->handle);
+ *   - drivers/acpi/scan.c|346| <<acpi_scan_bus_check>> error = acpi_bus_scan(adev->handle);
+ *   - drivers/acpi/scan.c|2631| <<acpi_scan_init>> result = acpi_bus_scan(ACPI_ROOT_OBJECT);
+ *   - drivers/acpi/scan.c|2702| <<acpi_table_events_fn>> acpi_bus_scan(ACPI_ROOT_OBJECT);
+ *   - drivers/pci/hotplug/acpiphp_glue.c|428| <<acpiphp_rescan_slot>> acpi_bus_scan(adev->handle);
+ *   - drivers/platform/surface/surface3-wmi.c|233| <<s3_wmi_probe>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+ *   - drivers/platform/surface/surface3-wmi.c|243| <<s3_wmi_remove>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+ */
 int acpi_bus_scan(acpi_handle handle)
 {
 	struct acpi_device *device = NULL;
@@ -2557,6 +2665,17 @@ int __init acpi_scan_init(void)
 	/*
 	 * Enumerate devices in the ACPI namespace.
 	 */
+	/*
+	 * 在以下调用acpi_bus_scan():
+	 *   - drivers/acpi/dock.c|273| <<hotplug_dock_devices>> int ret = acpi_bus_scan(adev->handle);
+	 *   - drivers/acpi/scan.c|321| <<acpi_scan_device_check>> error = acpi_bus_scan(adev->handle);
+	 *   - drivers/acpi/scan.c|346| <<acpi_scan_bus_check>> error = acpi_bus_scan(adev->handle);
+	 *   - drivers/acpi/scan.c|2631| <<acpi_scan_init>> result = acpi_bus_scan(ACPI_ROOT_OBJECT);
+	 *   - drivers/acpi/scan.c|2702| <<acpi_table_events_fn>> acpi_bus_scan(ACPI_ROOT_OBJECT);
+	 *   - drivers/pci/hotplug/acpiphp_glue.c|428| <<acpiphp_rescan_slot>> acpi_bus_scan(adev->handle);
+	 *   - drivers/platform/surface/surface3-wmi.c|233| <<s3_wmi_probe>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+	 *   - drivers/platform/surface/surface3-wmi.c|243| <<s3_wmi_remove>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+	 */
 	result = acpi_bus_scan(ACPI_ROOT_OBJECT);
 	if (result)
 		goto out;
@@ -2628,6 +2747,17 @@ int __init __acpi_probe_device_table(struct acpi_probe_entry *ap_head, int nr)
 static void acpi_table_events_fn(struct work_struct *work)
 {
 	acpi_scan_lock_acquire();
+	/*
+	 * 在以下调用acpi_bus_scan():
+	 *   - drivers/acpi/dock.c|273| <<hotplug_dock_devices>> int ret = acpi_bus_scan(adev->handle);
+	 *   - drivers/acpi/scan.c|321| <<acpi_scan_device_check>> error = acpi_bus_scan(adev->handle);
+	 *   - drivers/acpi/scan.c|346| <<acpi_scan_bus_check>> error = acpi_bus_scan(adev->handle);
+	 *   - drivers/acpi/scan.c|2631| <<acpi_scan_init>> result = acpi_bus_scan(ACPI_ROOT_OBJECT);
+	 *   - drivers/acpi/scan.c|2702| <<acpi_table_events_fn>> acpi_bus_scan(ACPI_ROOT_OBJECT);
+	 *   - drivers/pci/hotplug/acpiphp_glue.c|428| <<acpiphp_rescan_slot>> acpi_bus_scan(adev->handle);
+	 *   - drivers/platform/surface/surface3-wmi.c|233| <<s3_wmi_probe>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+	 *   - drivers/platform/surface/surface3-wmi.c|243| <<s3_wmi_remove>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+	 */
 	acpi_bus_scan(ACPI_ROOT_OBJECT);
 	acpi_scan_lock_release();
 
diff --git a/drivers/acpi/utils.c b/drivers/acpi/utils.c
index 0b19b0e4c100..441e3318e69b 100644
--- a/drivers/acpi/utils.c
+++ b/drivers/acpi/utils.c
@@ -243,6 +243,22 @@ acpi_extract_package(union acpi_object *package,
 
 EXPORT_SYMBOL(acpi_extract_package);
 
+/*
+ * [0] acpi_evaluate_integer
+ * [0] acpi_find_child_device
+ * [0] acpi_pci_find_companion
+ * [0] pci_set_acpi_fwnode
+ * [0] pci_setup_device
+ * [0] pci_scan_single_device
+ * [0] pci_scan_slot
+ * [0] acpiphp_hotplug_notify
+ * [0] acpi_device_hotplug
+ * [0] acpi_hotplug_work_fn
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ */
 acpi_status
 acpi_evaluate_integer(acpi_handle handle,
 		      acpi_string pathname,
diff --git a/drivers/pci/hotplug/acpiphp_glue.c b/drivers/pci/hotplug/acpiphp_glue.c
index f031302ad401..41fe0e40dccb 100644
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@ -418,20 +418,58 @@ static void check_hotplug_bridge(struct acpiphp_slot *slot, struct pci_dev *dev)
 	}
 }
 
+/*
+ * 在以下调用acpiphp_rescan_slot():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|495| <<enable_slot>> acpiphp_rescan_slot(slot);
+ *   - drivers/pci/hotplug/acpiphp_glue.c|821| <<hotplug_event>> if (acpiphp_rescan_slot(slot))
+ */
 static int acpiphp_rescan_slot(struct acpiphp_slot *slot)
 {
 	struct acpiphp_func *func;
 
+	/*
+	 * 从hotplut_event()来的时候
+	 * slot->bus->name: "PCI Bus 0000:02"
+	 * 这是从pcie出来的bus
+	 */
+
 	list_for_each_entry(func, &slot->funcs, sibling) {
 		struct acpi_device *adev = func_to_acpi_device(func);
 
+		/*
+		 * 在以下调用acpi_bus_scan():
+		 *   - drivers/acpi/dock.c|273| <<hotplug_dock_devices>> int ret = acpi_bus_scan(adev->handle);
+		 *   - drivers/acpi/scan.c|321| <<acpi_scan_device_check>> error = acpi_bus_scan(adev->handle);
+		 *   - drivers/acpi/scan.c|346| <<acpi_scan_bus_check>> error = acpi_bus_scan(adev->handle);
+		 *   - drivers/acpi/scan.c|2631| <<acpi_scan_init>> result = acpi_bus_scan(ACPI_ROOT_OBJECT);
+		 *   - drivers/acpi/scan.c|2702| <<acpi_table_events_fn>> acpi_bus_scan(ACPI_ROOT_OBJECT);
+		 *   - drivers/pci/hotplug/acpiphp_glue.c|428| <<acpiphp_rescan_slot>> acpi_bus_scan(adev->handle);
+		 *   - drivers/platform/surface/surface3-wmi.c|233| <<s3_wmi_probe>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+		 *   - drivers/platform/surface/surface3-wmi.c|243| <<s3_wmi_remove>> acpi_bus_scan(s3_wmi.pnp0c0d_adev->handle);
+		 */
 		acpi_bus_scan(adev->handle);
 		if (acpi_device_enumerated(adev))
 			acpi_device_set_power(adev, ACPI_STATE_D0);
 	}
+	/*
+	 * 在以下使用pci_scan_slot():
+	 *   - arch/powerpc/kernel/pci-hotplug.c|132| <<pci_hp_add_devices>> pci_scan_slot(bus, PCI_DEVFN(slotno, 0));
+	 *   - drivers/pci/hotplug/acpiphp_glue.c|448| <<acpiphp_rescan_slot>> return pci_scan_slot(slot->bus, PCI_DEVFN(slot->device, 0));
+	 *   - drivers/pci/hotplug/cpci_hotplug_pci.c|260| <<cpci_configure_slot>> n = pci_scan_slot(slot->bus, slot->devfn);
+	 *   - drivers/pci/hotplug/cpqphp_pci.c|86| <<cpqhp_configure_device>> num = pci_scan_slot(ctrl->pci_dev->bus, PCI_DEVFN(func->device, func->function));
+	 *   - drivers/pci/hotplug/ibmphp_core.c|751| <<ibm_configure_device>> num = pci_scan_slot(bus,
+	 *   - drivers/pci/hotplug/pciehp_pci.c|54| <<pciehp_configure_device>> num = pci_scan_slot(parent, PCI_DEVFN(0, 0));
+	 *   - drivers/pci/hotplug/shpchp_pci.c|43| <<shpchp_configure_device>> num = pci_scan_slot(parent, PCI_DEVFN(p_slot->device, 0));
+	 *   - drivers/pci/probe.c|2859| <<pci_scan_child_bus_extend>> nr_devs = pci_scan_slot(bus, devfn);
+	 *   - drivers/pcmcia/cardbus.c|74| <<cb_alloc>> s->functions = pci_scan_slot(bus, PCI_DEVFN(0, 0));
+	 */
 	return pci_scan_slot(slot->bus, PCI_DEVFN(slot->device, 0));
 }
 
+/*
+ * 只在此处调用acpiphp_native_scan_bridge():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|505| <<enable_slot>> acpiphp_native_scan_bridge(dev);
+ */
 static void acpiphp_native_scan_bridge(struct pci_dev *bridge)
 {
 	struct pci_bus *bus = bridge->subordinate;
@@ -485,6 +523,10 @@ static void enable_slot(struct acpiphp_slot *slot, bool bridge)
 		 * as a Thunderbolt host controller.
 		 */
 		for_each_pci_bridge(dev, bus) {
+			/*
+			 * 只在此处调用acpiphp_native_scan_bridge():
+			 *   - drivers/pci/hotplug/acpiphp_glue.c|505| <<enable_slot>> acpiphp_native_scan_bridge(de
+			 */
 			if (PCI_SLOT(dev->devfn) == slot->device)
 				acpiphp_native_scan_bridge(dev);
 		}
@@ -492,6 +534,11 @@ static void enable_slot(struct acpiphp_slot *slot, bool bridge)
 		LIST_HEAD(add_list);
 		int max, pass;
 
+		/*
+		 * 在以下调用acpiphp_rescan_slot():
+		 *   - drivers/pci/hotplug/acpiphp_glue.c|495| <<enable_slot>> acpiphp_rescan_slot(slot);
+		 *   - drivers/pci/hotplug/acpiphp_glue.c|821| <<hotplug_event>> if (acpiphp_rescan_slot(slot))
+		 */
 		acpiphp_rescan_slot(slot);
 		max = acpiphp_max_busnr(bus);
 		for (pass = 0; pass < 2; pass++) {
@@ -685,6 +732,13 @@ static void trim_stale_devices(struct pci_dev *dev)
  * Iterate over all slots under this bridge and make sure that if a
  * card is present they are enabled, and if not they are disabled.
  */
+/*
+ * 在以下调用acpiphp_check_bridge():
+ *   - drivers/pci/hotplug/acpiphp_glue.c|765| <<acpiphp_check_host_bridge>> acpiphp_check_bridge(bridge);
+ *   - drivers/pci/hotplug/acpiphp_glue.c|805| <<hotplug_event>> acpiphp_check_bridge(bridge);
+ *   - drivers/pci/hotplug/acpiphp_glue.c|815| <<hotplug_event>> acpiphp_check_bridge(bridge);
+ *   - drivers/pci/hotplug/acpiphp_glue.c|822| <<hotplug_event>> acpiphp_check_bridge(func->parent);
+ */
 static void acpiphp_check_bridge(struct acpiphp_bridge *bridge)
 {
 	struct acpiphp_slot *slot;
@@ -771,6 +825,16 @@ void acpiphp_check_host_bridge(struct acpi_device *adev)
 
 static int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot);
 
+/*
+ * hotplug_event
+ * acpiphp_hotplug_notify
+ * acpi_device_hotplug
+ * acpi_hotplug_work_fn
+ * process_one_work
+ * worker_thread
+ * kthread
+ * ret_from_fork
+ */
 static void hotplug_event(u32 type, struct acpiphp_context *context)
 {
 	acpi_handle handle = context->hp.self->handle;
@@ -808,6 +872,11 @@ static void hotplug_event(u32 type, struct acpiphp_context *context)
 			 * Check if anything has changed in the slot and rescan
 			 * from the parent if that's the case.
 			 */
+			/*
+			 * 在以下调用acpiphp_rescan_slot():
+			 *   - drivers/pci/hotplug/acpiphp_glue.c|495| <<enable_slot>> acpiphp_rescan_slot(slot);
+			 *   - drivers/pci/hotplug/acpiphp_glue.c|821| <<hotplug_event>> if (acpiphp_rescan_slot(slot))
+			 */
 			if (acpiphp_rescan_slot(slot))
 				acpiphp_check_bridge(func->parent);
 		}
diff --git a/drivers/pci/iov.c b/drivers/pci/iov.c
index e1b8234ea066..2ad79ecb7845 100644
--- a/drivers/pci/iov.c
+++ b/drivers/pci/iov.c
@@ -287,6 +287,11 @@ const struct attribute_group sriov_vf_dev_attr_group = {
 	.is_visible = sriov_vf_attrs_are_visible,
 };
 
+/*
+ * 在以下使用pci_iov_add_virtfn():
+ *   - arch/powerpc/kernel/eeh_driver.c|480| <<eeh_add_virt_device>> pci_iov_add_virtfn(edev->physfn, edev->vf_index);
+ *   - drivers/pci/iov.c|588| <<sriov_add_vfs>> rc = pci_iov_add_virtfn(dev, i);
+ */
 int pci_iov_add_virtfn(struct pci_dev *dev, int id)
 {
 	int i;
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 55b14452226b..066b3409940d 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1463,6 +1463,16 @@ static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
  *
  * Return: New subordinate number covering all buses behind this bridge.
  */
+/*
+ * 在以下调用pci_scan_bridge():
+ *   - arch/powerpc/kernel/pci-hotplug.c|140| <<pci_hp_add_devices>> max = pci_scan_bridge(bus, dev, max, 0);
+ *   - arch/powerpc/kernel/pci-hotplug.c|144| <<pci_hp_add_devices>> max = pci_scan_bridge(bus, dev, max, 1);
+ *   - drivers/pci/hotplug/acpiphp_glue.c|464| <<acpiphp_native_scan_bridge>> max = pci_scan_bridge(bus, dev, max, 0);
+ *   - drivers/pci/hotplug/acpiphp_glue.c|472| <<acpiphp_native_scan_bridge>> max = pci_scan_bridge(bus, dev, max, 1);
+ *   - drivers/pci/hotplug/acpiphp_glue.c|523| <<enable_slot>> max = pci_scan_bridge(bus, dev, max, pass);
+ *   - drivers/pci/probe.c|3314| <<pci_hp_add_bridge>> busnr = pci_scan_bridge(parent, dev, busnr, 0);
+ *   - drivers/pcmcia/cardbus.c|80| <<cb_alloc>> max = pci_scan_bridge(bus, dev, max, pass);
+ */
 int pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 {
 	return pci_scan_bridge_extend(bus, dev, max, 0, pass);
@@ -1797,6 +1807,11 @@ static void early_dump_pci_device(struct pci_dev *pdev)
  * Returns 0 on success and negative if unknown type of device (not normal,
  * bridge or CardBus).
  */
+/*
+ * 在以下调用pci_setup_device():
+ *   - drivers/pci/iov.c|318| <<pci_iov_add_virtfn>> rc = pci_setup_device(virtfn);
+ *   - drivers/pci/probe.c|2399| <<pci_scan_device>> if (pci_setup_device(dev)) {
+ */
 int pci_setup_device(struct pci_dev *dev)
 {
 	u32 class;
@@ -2370,6 +2385,10 @@ EXPORT_SYMBOL(pci_bus_read_dev_vendor_id);
  * Read the config data for a PCI device, sanity-check it,
  * and fill in the dev structure.
  */
+/*
+ * 在以下调用pci_scan_device():
+ *   - drivers/pci/probe.c|2553| <<pci_scan_single_device>> dev = pci_scan_device(bus, devfn);
+ */
 static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
@@ -2378,6 +2397,11 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 	if (!pci_bus_read_dev_vendor_id(bus, devfn, &l, 60*1000))
 		return NULL;
 
+	/*
+	 * crash> pci_dev -x -o
+	 * ... ...
+	 * SIZE: 0xce8
+	 */
 	dev = pci_alloc_dev(bus);
 	if (!dev)
 		return NULL;
@@ -2484,6 +2508,13 @@ static void pci_set_msi_domain(struct pci_dev *dev)
 	dev_set_msi_domain(&dev->dev, d);
 }
 
+/*
+ * 在以下调用pci_device_add():
+ *   - arch/powerpc/kernel/pci_of_scan.c|236| <<of_create_pci_dev>> pci_device_add(dev, bus);
+ *   - arch/sparc/kernel/pci.c|357| <<of_create_pci_dev>> pci_device_add(dev, bus);
+ *   - drivers/pci/iov.c|338| <<pci_iov_add_virtfn>> pci_device_add(virtfn, virtfn->bus);
+ *   - drivers/pci/probe.c|2578| <<pci_scan_single_device>> pci_device_add(dev, bus);
+ */
 void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 {
 	int ret;
@@ -2530,6 +2561,18 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 	WARN_ON(ret < 0);
 }
 
+/*
+ * 在以下使用pci_scan_single_device():
+ *   - arch/s390/pci/pci_bus.c|84| <<zpci_bus_scan_device>> pdev = pci_scan_single_device(zdev->zbus->bus, zdev->devfn);
+ *   - drivers/edac/e752x_edac.c|1181| <<e752x_get_devs>> pvt->dev_d0f1 = pci_scan_single_device(pdev->bus,
+ *   - drivers/edac/i82875p_edac.c|288| <<i82875p_setup_overfl_dev>> dev = pci_scan_single_device(pdev->bus, PCI_DEVFN(6, 0));
+ *   - drivers/pci/probe.c|2642| <<pci_scan_slot>> dev = pci_scan_single_device(bus, devfn);
+ *   - drivers/pci/probe.c|2649| <<pci_scan_slot>> dev = pci_scan_single_device(bus, devfn + fn);
+ *   - drivers/pci/probe.c|2868| <<pci_scan_child_bus_extend>> dev = pci_scan_single_device(bus, devfn + fn);
+ *   - drivers/pci/xen-pcifront.c|434| <<pcifront_scan_bus>> d = pci_scan_single_device(b, devfn);
+ *   - drivers/platform/x86/asus-wmi.c|1078| <<asus_rfkill_hotplug>> dev = pci_scan_single_device(bus, 0);
+ *   - drivers/platform/x86/eeepc-laptop.c|612| <<eeepc_rfkill_hotplug>> dev = pci_scan_single_device(bus, 0);
+ */
 struct pci_dev *pci_scan_single_device(struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
@@ -2540,10 +2583,20 @@ struct pci_dev *pci_scan_single_device(struct pci_bus *bus, int devfn)
 		return dev;
 	}
 
+	/*
+	 * 只在此处调用
+	 */
 	dev = pci_scan_device(bus, devfn);
 	if (!dev)
 		return NULL;
 
+	/*
+	 * 在以下调用pci_device_add():
+	 *   - arch/powerpc/kernel/pci_of_scan.c|236| <<of_create_pci_dev>> pci_device_add(dev, bus);
+	 *   - arch/sparc/kernel/pci.c|357| <<of_create_pci_dev>> pci_device_add(dev, bus);
+	 *   - drivers/pci/iov.c|338| <<pci_iov_add_virtfn>> pci_device_add(virtfn, virtfn->bus);
+	 *   - drivers/pci/probe.c|2578| <<pci_scan_single_device>> pci_device_add(dev, bus);
+	 */
 	pci_device_add(dev, bus);
 
 	return dev;
@@ -2612,6 +2665,18 @@ static int only_one_child(struct pci_bus *bus)
  *
  * Returns the number of new devices found.
  */
+/*
+ * 在以下使用pci_scan_slot():
+ *   - arch/powerpc/kernel/pci-hotplug.c|132| <<pci_hp_add_devices>> pci_scan_slot(bus, PCI_DEVFN(slotno, 0));
+ *   - drivers/pci/hotplug/acpiphp_glue.c|448| <<acpiphp_rescan_slot>> return pci_scan_slot(slot->bus, PCI_DEVFN(slot->device, 0));
+ *   - drivers/pci/hotplug/cpci_hotplug_pci.c|260| <<cpci_configure_slot>> n = pci_scan_slot(slot->bus, slot->devfn);
+ *   - drivers/pci/hotplug/cpqphp_pci.c|86| <<cpqhp_configure_device>> num = pci_scan_slot(ctrl->pci_dev->bus, PCI_DEVFN(func->device, func->function));
+ *   - drivers/pci/hotplug/ibmphp_core.c|751| <<ibm_configure_device>> num = pci_scan_slot(bus,
+ *   - drivers/pci/hotplug/pciehp_pci.c|54| <<pciehp_configure_device>> num = pci_scan_slot(parent, PCI_DEVFN(0, 0));
+ *   - drivers/pci/hotplug/shpchp_pci.c|43| <<shpchp_configure_device>> num = pci_scan_slot(parent, PCI_DEVFN(p_slot->device, 0));
+ *   - drivers/pci/probe.c|2859| <<pci_scan_child_bus_extend>> nr_devs = pci_scan_slot(bus, devfn);
+ *   - drivers/pcmcia/cardbus.c|74| <<cb_alloc>> s->functions = pci_scan_slot(bus, PCI_DEVFN(0, 0));
+ */
 int pci_scan_slot(struct pci_bus *bus, int devfn)
 {
 	unsigned int fn, nr = 0;
@@ -2620,6 +2685,18 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 	if (only_one_child(bus) && (devfn > 0))
 		return 0; /* Already scanned the entire slot */
 
+	/*
+	 * 在以下使用pci_scan_single_device():
+	 *   - arch/s390/pci/pci_bus.c|84| <<zpci_bus_scan_device>> pdev = pci_scan_single_device(zdev->zbus->bus, zdev->devfn);
+	 *   - drivers/edac/e752x_edac.c|1181| <<e752x_get_devs>> pvt->dev_d0f1 = pci_scan_single_device(pdev->bus,
+	 *   - drivers/edac/i82875p_edac.c|288| <<i82875p_setup_overfl_dev>> dev = pci_scan_single_device(pdev->bus, PCI_DEVFN(6, 0));
+	 *   - drivers/pci/probe.c|2642| <<pci_scan_slot>> dev = pci_scan_single_device(bus, devfn);
+	 *   - drivers/pci/probe.c|2649| <<pci_scan_slot>> dev = pci_scan_single_device(bus, devfn + fn);
+	 *   - drivers/pci/probe.c|2868| <<pci_scan_child_bus_extend>> dev = pci_scan_single_device(bus, devfn + fn);
+	 *   - drivers/pci/xen-pcifront.c|434| <<pcifront_scan_bus>> d = pci_scan_single_device(b, devfn);
+	 *   - drivers/platform/x86/asus-wmi.c|1078| <<asus_rfkill_hotplug>> dev = pci_scan_single_device(bus, 0);
+	 *   - drivers/platform/x86/eeepc-laptop.c|612| <<eeepc_rfkill_hotplug>> dev = pci_scan_single_device(bus, 0);
+	 */
 	dev = pci_scan_single_device(bus, devfn);
 	if (!dev)
 		return 0;
@@ -2824,6 +2901,11 @@ void __weak pcibios_fixup_bus(struct pci_bus *bus)
  * equally between hotplug-capable bridges to allow future extension of the
  * hierarchy.
  */
+/*
+ * 在以下使用pci_scan_child_bus_extend():
+ *   - drivers/pci/probe.c|1376| <<pci_scan_bridge_extend>> max = pci_scan_child_bus_extend(child, available_buses);
+ *   - drivers/pci/probe.c|3037| <<pci_scan_child_bus>> return pci_scan_child_bus_extend(bus, 0);
+ */
 static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
 					      unsigned int available_buses)
 {
@@ -2846,6 +2928,18 @@ static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
 		 */
 		if (jailhouse_paravirt() && nr_devs == 0) {
 			for (fn = 1; fn < 8; fn++) {
+				/*
+				 * 在以下使用pci_scan_single_device():
+				 *   - arch/s390/pci/pci_bus.c|84| <<zpci_bus_scan_device>> pdev = pci_scan_single_device(zdev->zbus->bus, zdev->devfn);
+				 *   - drivers/edac/e752x_edac.c|1181| <<e752x_get_devs>> pvt->dev_d0f1 = pci_scan_single_device(pdev->bus,
+				 *   - drivers/edac/i82875p_edac.c|288| <<i82875p_setup_overfl_dev>> dev = pci_scan_single_device(pdev->bus, PCI_DEVFN(6, 0));
+				 *   - drivers/pci/probe.c|2642| <<pci_scan_slot>> dev = pci_scan_single_device(bus, devfn);
+				 *   - drivers/pci/probe.c|2649| <<pci_scan_slot>> dev = pci_scan_single_device(bus, devfn + fn);
+				 *   - drivers/pci/probe.c|2868| <<pci_scan_child_bus_extend>> dev = pci_scan_single_device(bus, devfn + fn);
+				 *   - drivers/pci/xen-pcifront.c|434| <<pcifront_scan_bus>> d = pci_scan_single_device(b, devfn);
+				 *   - drivers/platform/x86/asus-wmi.c|1078| <<asus_rfkill_hotplug>> dev = pci_scan_single_device(bus, 0);
+				 *   - drivers/platform/x86/eeepc-laptop.c|612| <<eeepc_rfkill_hotplug>> dev = pci_scan_single_device(bus, 0);
+				 */
 				dev = pci_scan_single_device(bus, devfn + fn);
 				if (dev)
 					dev->multifunction = 1;
diff --git a/drivers/pci/search.c b/drivers/pci/search.c
index b4c138a6ec02..c2868b7fbe2a 100644
--- a/drivers/pci/search.c
+++ b/drivers/pci/search.c
@@ -197,6 +197,10 @@ struct pci_dev *pci_get_slot(struct pci_bus *bus, unsigned int devfn)
 
 	down_read(&pci_bus_sem);
 
+	/*
+	 * struct pci_bus *bus:
+	 * -> struct list_head devices;
+	 */
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		if (dev->devfn == devfn)
 			goto out;
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index 0d0816f3bea6..c34af54520b7 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -546,6 +546,21 @@ void acpi_set_modalias(struct acpi_device *adev, const char *default_id,
 int acpi_create_dir(struct acpi_device *);
 void acpi_remove_dir(struct acpi_device *);
 
+/*
+ * 在以下使用acpi_device_enumerated():
+ *   - drivers/acpi/acpi_platform.c|51| <<acpi_platform_device_remove_notify>> if (!acpi_device_enumerated(adev))
+ *   - drivers/acpi/dock.c|272| <<hotplug_dock_devices>> if (!acpi_device_enumerated(adev)) {
+ *   - drivers/acpi/dock.c|462| <<dock_notify>> if (!dock_in_progress(ds) && !acpi_device_enumerated(adev)) {
+ *   - drivers/acpi/dock.c|505| <<docked_show>> return sysfs_emit(buf, "%u\n", acpi_device_enumerated(adev));
+ *   - drivers/acpi/scan.c|295| <<acpi_scan_device_not_present>> if (!acpi_device_enumerated(adev)) {
+ *   - drivers/bus/hisi_lpc.c|416| <<hisi_lpc_acpi_set_io_res>> if (acpi_device_enumerated(adev)) {
+ *   - drivers/i2c/i2c-core-acpi.c|221| <<i2c_acpi_get_info>> if (acpi_device_enumerated(adev))
+ *   - drivers/i2c/i2c-core-acpi.c|454| <<i2c_acpi_notify>> if (!acpi_device_enumerated(adev))
+ *   - drivers/pci/hotplug/acpiphp_glue.c|445| <<acpiphp_rescan_slot>> if (acpi_device_enumerated(adev))
+ *   - drivers/spi/spi.c|2366| <<acpi_register_spi_device>> acpi_device_enumerated(adev))
+ *   - drivers/spi/spi.c|4309| <<acpi_spi_notify>> if (!acpi_device_enumerated(adev))
+ *   - drivers/tty/serdev/core.c|713| <<acpi_serdev_add_device>> if (acpi_device_enumerated(adev))
+ */
 static inline bool acpi_device_enumerated(struct acpi_device *adev)
 {
 	return adev && adev->flags.initialized && adev->flags.visited;
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index e7d3925f23b7..f5c185b3b263 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -602,7 +602,29 @@ struct kvm_kernel_irq_routing_entry {
 
 #ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
 struct kvm_irq_routing_table {
+	/*
+	 * #define KVM_IRQCHIP_PIC_MASTER   0
+	 * #define KVM_IRQCHIP_PIC_SLAVE    1
+	 * #define KVM_IRQCHIP_IOAPIC       2
+	 * #define KVM_NR_IRQCHIPS          3
+	 */
 	int chip[KVM_NR_IRQCHIPS][KVM_IRQCHIP_NUM_PINS];
+	/*
+	 * 在以下使用kvm_irq_routing_table->nr_rt_entries:
+	 *   - arch/x86/kvm/hyperv.c|534| <<kvm_hv_irq_routing_update>> for (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {
+	 *   - arch/x86/kvm/irq_comm.c|430| <<kvm_scan_ioapic_routes>> nr_ioapic_pins = min_t(u32, table->nr_rt_entries,
+	 *                  kvm->arch.nr_reserved_ioapic_pins);
+	 *   - arch/x86/kvm/svm/avic.c|931| <<avic_pi_update_irte>> if (guest_irq >= irq_rt->nr_rt_entries || hlist_empty(&irq_rt->map[guest_irq])) {
+	 *   - arch/x86/kvm/svm/avic.c|934| <<avic_pi_update_irte>> pr_warn_once("no route for guest_irq %u/%u (broken user space?)\n",
+	 *                  guest_irq, irq_rt->nr_rt_entries);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|292| <<vmx_pi_update_irte>> if (guest_irq >= irq_rt->nr_rt_entries || hlist_empty(&irq_rt->map[guest_irq])) {
+	 *   - arch/x86/kvm/vmx/posted_intr.c|295| <<vmx_pi_update_irte>> pr_warn_once("no route for guest_irq %u/%u (broken user space?)\n",
+	 *                  guest_irq, irq_rt->nr_rt_entries);
+	 *   - virt/kvm/irqchip.c|31| <<kvm_irq_map_gsi>> if (irq_rt && gsi < irq_rt->nr_rt_entries) {
+	 *   - virt/kvm/irqchip.c|34| <<kvm_irq_map_gsi>> index = array_index_nospec(gsi, irq_rt->nr_rt_entries);
+	 *   - virt/kvm/irqchip.c|111| <<free_irq_routing_table>> for (i = 0; i < rt->nr_rt_entries; ++i) {
+	 *   - virt/kvm/irqchip.c|195| <<kvm_set_irq_routing>> new->nr_rt_entries = nr_rt_entries;
+	 */
 	u32 nr_rt_entries;
 	/*
 	 * Array indexed by gsi. Each entry contains list of irq chips
@@ -682,6 +704,12 @@ struct kvm {
 	struct {
 		spinlock_t        lock;
 		struct list_head  items;
+		/*
+		 * 在以下使用kvm.irqfds.resampler_list:
+		 *   - virt/kvm/eventfd.c|350| <<kvm_irqfd_assign>> list_for_each_entry(resampler, &kvm->irqfds.resampler_list, link) {
+		 *   - virt/kvm/eventfd.c|372| <<kvm_irqfd_assign>> list_add(&resampler->link, &kvm->irqfds.resampler_list);
+		 *   - virt/kvm/eventfd.c|567| <<kvm_eventfd_init>> INIT_LIST_HEAD(&kvm->irqfds.resampler_list);
+		 */
 		struct list_head  resampler_list;
 		struct mutex      resampler_lock;
 	} irqfds;
@@ -701,9 +729,29 @@ struct kvm {
 	/*
 	 * Update side is protected by irq_lock.
 	 */
+	/*
+	 * 在以下使用kvm->irq_routing:
+	 *   - arch/x86/kvm/hyperv.c|531| <<kvm_hv_irq_routing_update>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - arch/x86/kvm/irq_comm.c|469| <<kvm_scan_ioapic_routes>> table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/svm/avic.c|929| <<avic_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|291| <<vmx_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|60| <<kvm_irq_map_gsi>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - virt/kvm/irqchip.c|88| <<kvm_irq_map_chip_pin>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|222| <<kvm_free_irq_routing>> struct kvm_irq_routing_table *rt = rcu_access_pointer(kvm->irq_routing);
+	 *   - virt/kvm/irqchip.c|421| <<kvm_set_irq_routing>> old = rcu_dereference_protected(kvm->irq_routing, 1);
+	 *   - virt/kvm/irqchip.c|422| <<kvm_set_irq_routing>> rcu_assign_pointer(kvm->irq_routing, new);
+	 */
 	struct kvm_irq_routing_table __rcu *irq_routing;
 #endif
 #ifdef CONFIG_HAVE_KVM_IRQFD
+	/*
+	 * 在以下使用kvm->irq_ack_notifier_list:
+	 *   - arch/powerpc/kvm/book3s_hv_rm_xics.c|704| <<ics_rm_eoi>> if (!hlist_empty(&vcpu->kvm->irq_ack_notifier_list)) {
+	 *   - virt/kvm/eventfd.c|471| <<kvm_irq_has_notifier>> hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,
+	 *   - virt/kvm/eventfd.c|493| <<kvm_notify_acked_gsi>> hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,
+	 *   - virt/kvm/eventfd.c|545| <<kvm_register_irq_ack_notifier>> hlist_add_head_rcu(&kian->link, &kvm->irq_ack_notifier_list);
+	 *   - virt/kvm/kvm_main.c|1153| <<kvm_create_vm>> INIT_HLIST_HEAD(&kvm->irq_ack_notifier_list);
+	 */
 	struct hlist_head irq_ack_notifier_list;
 #endif
 
@@ -1295,6 +1343,12 @@ bool kvm_is_transparent_hugepage(kvm_pfn_t pfn);
 struct kvm_irq_ack_notifier {
 	struct hlist_node link;
 	unsigned gsi;
+	/*
+	 * 在以下使用kvm_irq_ack_notifier->irq_acked:
+	 *   - arch/x86/kvm/i8254.c|696| <<kvm_create_pit>> pit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;
+	 *   - virt/kvm/eventfd.c|369| <<kvm_irqfd_assign>> resampler->notifier.irq_acked = irqfd_resampler_ack;
+	 *   - virt/kvm/eventfd.c|487| <<kvm_notify_acked_gsi>> kian->irq_acked(kian);
+	 */
 	void (*irq_acked)(struct kvm_irq_ack_notifier *kian);
 };
 
diff --git a/virt/kvm/eventfd.c b/virt/kvm/eventfd.c
index 37e3a49f4e76..d549ff634b99 100644
--- a/virt/kvm/eventfd.c
+++ b/virt/kvm/eventfd.c
@@ -38,6 +38,10 @@ kvm_arch_irqfd_allowed(struct kvm *kvm, struct kvm_irqfd *args)
 	return true;
 }
 
+/*
+ * 在以下调用irqfd_inject():
+ *   - virt/kvm/eventfd.c|309| <<kvm_irqfd_assign>> INIT_WORK(&irqfd->inject, irqfd_inject);
+ */
 static void
 irqfd_inject(struct work_struct *work)
 {
@@ -296,6 +300,10 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
 	if (!kvm_arch_intc_initialized(kvm))
 		return -EAGAIN;
 
+	/*
+	 * 在以下使用kvm_arch_irqfd_allowed():
+	 *   - virt/kvm/eventfd.c|303| <<kvm_irqfd_assign>> if (!kvm_arch_irqfd_allowed(kvm, args))
+	 */
 	if (!kvm_arch_irqfd_allowed(kvm, args))
 		return -EINVAL;
 
@@ -338,6 +346,12 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
 
 		mutex_lock(&kvm->irqfds.resampler_lock);
 
+		/*
+		 * 在以下使用kvm.irqfds.resampler_list:
+		 *   - virt/kvm/eventfd.c|350| <<kvm_irqfd_assign>> list_for_each_entry(resampler, &kvm->irqfds.resampler_list, link) {
+		 *   - virt/kvm/eventfd.c|372| <<kvm_irqfd_assign>> list_add(&resampler->link, &kvm->irqfds.resampler_list);
+		 *   - virt/kvm/eventfd.c|567| <<kvm_eventfd_init>> INIT_LIST_HEAD(&kvm->irqfds.resampler_list);
+		 */
 		list_for_each_entry(resampler,
 				    &kvm->irqfds.resampler_list, link) {
 			if (resampler->notifier.gsi == irqfd->gsi) {
@@ -448,13 +462,33 @@ kvm_irqfd_assign(struct kvm *kvm, struct kvm_irqfd *args)
 	return ret;
 }
 
+/*
+ * 在以下调用kvm_irq_has_notifier():
+ *   - arch/x86/kvm/ioapic.c|345| <<kvm_ioapic_scan_entry>> kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||
+ */
 bool kvm_irq_has_notifier(struct kvm *kvm, unsigned irqchip, unsigned pin)
 {
 	struct kvm_irq_ack_notifier *kian;
 	int gsi, idx;
 
 	idx = srcu_read_lock(&kvm->irq_srcu);
+	/*
+	 * 在以下调用kvm_irq_map_chip_pin():
+	 *   - rch/x86/kvm/irq_comm.c|272| <<kvm_fire_mask_notifiers>> gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	 *   - virt/kvm/eventfd.c|457| <<kvm_irq_has_notifier>> gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	 *   - virt/kvm/eventfd.c|489| <<kvm_notify_acked_irq>> gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	 *
+	 * 返回irq_rt->chip[irqchip][pin]
+	 */
 	gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	/*
+	 * 在以下使用kvm->irq_ack_notifier_list:
+	 *   - arch/powerpc/kvm/book3s_hv_rm_xics.c|704| <<ics_rm_eoi>> if (!hlist_empty(&vcpu->kvm->irq_ack_notifier_list)) {
+	 *   - virt/kvm/eventfd.c|471| <<kvm_irq_has_notifier>> hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,
+	 *   - virt/kvm/eventfd.c|493| <<kvm_notify_acked_gsi>> hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,
+	 *   - virt/kvm/eventfd.c|545| <<kvm_register_irq_ack_notifier>> hlist_add_head_rcu(&kian->link, &kvm->irq_ack_notifier_list);
+	 *   - virt/kvm/kvm_main.c|1153| <<kvm_create_vm>> INIT_HLIST_HEAD(&kvm->irq_ack_notifier_list);
+	 */
 	if (gsi != -1)
 		hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,
 					  link, srcu_read_lock_held(&kvm->irq_srcu))
@@ -469,16 +503,37 @@ bool kvm_irq_has_notifier(struct kvm *kvm, unsigned irqchip, unsigned pin)
 }
 EXPORT_SYMBOL_GPL(kvm_irq_has_notifier);
 
+/*
+ * 在以下调用kvm_notify_acked_gsi():
+ *   - arch/x86/kvm/hyperv.c|226| <<kvm_hv_notify_acked_sint>> kvm_notify_acked_gsi(kvm, gsi);
+ *   - virt/kvm/eventfd.c|499| <<kvm_notify_acked_irq>> kvm_notify_acked_gsi(kvm, gsi);
+ */
 void kvm_notify_acked_gsi(struct kvm *kvm, int gsi)
 {
 	struct kvm_irq_ack_notifier *kian;
 
 	hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,
 				  link, srcu_read_lock_held(&kvm->irq_srcu))
+		/*
+		 * 在以下使用kvm_irq_ack_notifier->irq_acked:
+		 *   - arch/x86/kvm/i8254.c|696| <<kvm_create_pit>> pit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;
+		 *   - virt/kvm/eventfd.c|369| <<kvm_irqfd_assign>> resampler->notifier.irq_acked = irqfd_resampler_ack;
+		 *   - virt/kvm/eventfd.c|487| <<kvm_notify_acked_gsi>> kian->irq_acked(kian);
+		 */
 		if (kian->gsi == gsi)
 			kian->irq_acked(kian);
 }
 
+/*
+ * 在以下使用kvm_notify_acked_irq():
+ *   - arch/arm64/kvm/vgic/vgic-v2.c|72| <<vgic_v2_fold_lr_state>> kvm_notify_acked_irq(vcpu->kvm, 0,
+ *   - arch/arm64/kvm/vgic/vgic-v3.c|63| <<vgic_v3_fold_lr_state>> kvm_notify_acked_irq(vcpu->kvm, 0,
+ *   - arch/powerpc/kvm/book3s_xics.c|812| <<ics_eoi>> kvm_notify_acked_irq(vcpu->kvm, 0, irq);
+ *   - arch/powerpc/kvm/book3s_xics.c|866| <<kvmppc_xics_rm_complete>> kvm_notify_acked_irq(vcpu->kvm, 0, icp->rm_eoied_irq);
+ *   - arch/powerpc/kvm/mpic.c|1106| <<openpic_cpu_write_internal>> kvm_notify_acked_irq(opp->kvm, 0, notify_eoi);
+ *   - arch/x86/kvm/i8259.c|82| <<pic_clear_isr>> kvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);
+ *   - arch/x86/kvm/ioapic.c|633| <<kvm_ioapic_update_eoi_one>> kvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, pin);
+ */
 void kvm_notify_acked_irq(struct kvm *kvm, unsigned irqchip, unsigned pin)
 {
 	int gsi, idx;
@@ -486,16 +541,42 @@ void kvm_notify_acked_irq(struct kvm *kvm, unsigned irqchip, unsigned pin)
 	trace_kvm_ack_irq(irqchip, pin);
 
 	idx = srcu_read_lock(&kvm->irq_srcu);
+	/*
+	 * 在以下调用kvm_irq_map_chip_pin():
+	 *   - rch/x86/kvm/irq_comm.c|272| <<kvm_fire_mask_notifiers>> gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	 *   - virt/kvm/eventfd.c|457| <<kvm_irq_has_notifier>> gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	 *   - virt/kvm/eventfd.c|489| <<kvm_notify_acked_irq>> gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	 *
+	 * 返回irq_rt->chip[irqchip][pin]
+	 */
 	gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	/*
+	 * 在以下调用kvm_notify_acked_gsi():
+	 *   - arch/x86/kvm/hyperv.c|226| <<kvm_hv_notify_acked_sint>> kvm_notify_acked_gsi(kvm, gsi);
+	 *   - virt/kvm/eventfd.c|499| <<kvm_notify_acked_irq>> kvm_notify_acked_gsi(kvm, gsi);
+	 */
 	if (gsi != -1)
 		kvm_notify_acked_gsi(kvm, gsi);
 	srcu_read_unlock(&kvm->irq_srcu, idx);
 }
 
+/*
+ * 在以下使用kvm_register_irq_ack_notifier():
+ *   - arch/x86/kvm/i8254.c|311| <<kvm_pit_set_reinject>> kvm_register_irq_ack_notifier(kvm, &ps->irq_ack_notifier);
+ *   - virt/kvm/eventfd.c|373| <<kvm_irqfd_assign>> kvm_register_irq_ack_notifier(kvm, &resampler->notifier);
+ */
 void kvm_register_irq_ack_notifier(struct kvm *kvm,
 				   struct kvm_irq_ack_notifier *kian)
 {
 	mutex_lock(&kvm->irq_lock);
+	/*
+	 * 在以下使用kvm->irq_ack_notifier_list:
+	 *   - arch/powerpc/kvm/book3s_hv_rm_xics.c|704| <<ics_rm_eoi>> if (!hlist_empty(&vcpu->kvm->irq_ack_notifier_list)) {
+	 *   - virt/kvm/eventfd.c|471| <<kvm_irq_has_notifier>> hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,
+	 *   - virt/kvm/eventfd.c|493| <<kvm_notify_acked_gsi>> hlist_for_each_entry_srcu(kian, &kvm->irq_ack_notifier_list,
+	 *   - virt/kvm/eventfd.c|545| <<kvm_register_irq_ack_notifier>> hlist_add_head_rcu(&kian->link, &kvm->irq_ack_notifier_list);
+	 *   - virt/kvm/kvm_main.c|1153| <<kvm_create_vm>> INIT_HLIST_HEAD(&kvm->irq_ack_notifier_list);
+	 */
 	hlist_add_head_rcu(&kian->link, &kvm->irq_ack_notifier_list);
 	mutex_unlock(&kvm->irq_lock);
 	kvm_arch_post_irq_ack_notifier_list_update(kvm);
@@ -518,6 +599,12 @@ kvm_eventfd_init(struct kvm *kvm)
 #ifdef CONFIG_HAVE_KVM_IRQFD
 	spin_lock_init(&kvm->irqfds.lock);
 	INIT_LIST_HEAD(&kvm->irqfds.items);
+	/*
+	 * 在以下使用kvm.irqfds.resampler_list:
+	 *   - virt/kvm/eventfd.c|350| <<kvm_irqfd_assign>> list_for_each_entry(resampler, &kvm->irqfds.resampler_list, link) {
+	 *   - virt/kvm/eventfd.c|372| <<kvm_irqfd_assign>> list_add(&resampler->link, &kvm->irqfds.resampler_list);
+	 *   - virt/kvm/eventfd.c|567| <<kvm_eventfd_init>> INIT_LIST_HEAD(&kvm->irqfds.resampler_list);
+	 */
 	INIT_LIST_HEAD(&kvm->irqfds.resampler_list);
 	mutex_init(&kvm->irqfds.resampler_lock);
 #endif
@@ -608,6 +695,10 @@ kvm_irqfd_release(struct kvm *kvm)
  * Take note of a change in irq routing.
  * Caller must invoke synchronize_srcu(&kvm->irq_srcu) afterwards.
  */
+/*
+ * 只在一个地方调用kvm_irq_routing_update():
+ *   - virt/kvm/irqchip.c|423| <<kvm_set_irq_routing>> kvm_irq_routing_update(kvm);
+ */
 void kvm_irq_routing_update(struct kvm *kvm)
 {
 	struct kvm_kernel_irqfd *irqfd;
diff --git a/virt/kvm/irqchip.c b/virt/kvm/irqchip.c
index 79dcd4cd5c60..200d0dc662d4 100644
--- a/virt/kvm/irqchip.c
+++ b/virt/kvm/irqchip.c
@@ -19,6 +19,37 @@
 #include <trace/events/kvm.h>
 #include "irq.h"
 
+/*
+ * 579 struct kvm_kernel_irq_routing_entry {
+ * 580         u32 gsi;
+ * 581         u32 type;
+ * 582         int (*set)(struct kvm_kernel_irq_routing_entry *e,
+ * 583                    struct kvm *kvm, int irq_source_id, int level,
+ * 584                    bool line_status);
+ * 585         union {
+ * 586                 struct {
+ * 587                         unsigned irqchip;
+ * 588                         unsigned pin;
+ * 589                 } irqchip;
+ * 590                 struct {
+ * 591                         u32 address_lo;
+ * 592                         u32 address_hi;
+ * 593                         u32 data;
+ * 594                         u32 flags;
+ * 595                         u32 devid;
+ * 596                 } msi;
+ * 597                 struct kvm_s390_adapter_int adapter;
+ * 598                 struct kvm_hv_sint hv_sint;
+ * 599         };
+ * 600         struct hlist_node link;
+ * 601 };
+ *
+ * 在以下调用kvm_irq_map_gsi():
+ *   - virt/kvm/eventfd.c|254| <<irqfd_update>> n_entries = kvm_irq_map_gsi(kvm, entries, irqfd->gsi);
+ *   - virt/kvm/irqchip.c|113| <<kvm_set_irq>> i = kvm_irq_map_gsi(kvm, irq_set, irq);
+ *
+ * 不知道为什么, 传进来的entires[]数组的长度都是3
+ */
 int kvm_irq_map_gsi(struct kvm *kvm,
 		    struct kvm_kernel_irq_routing_entry *entries, int gsi)
 {
@@ -26,6 +57,18 @@ int kvm_irq_map_gsi(struct kvm *kvm,
 	struct kvm_kernel_irq_routing_entry *e;
 	int n = 0, index;
 
+	/*
+	 * 在以下使用kvm->irq_routing:
+	 *   - arch/x86/kvm/hyperv.c|531| <<kvm_hv_irq_routing_update>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - arch/x86/kvm/irq_comm.c|469| <<kvm_scan_ioapic_routes>> table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/svm/avic.c|929| <<avic_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|291| <<vmx_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|60| <<kvm_irq_map_gsi>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - virt/kvm/irqchip.c|88| <<kvm_irq_map_chip_pin>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|222| <<kvm_free_irq_routing>> struct kvm_irq_routing_table *rt = rcu_access_pointer(kvm->irq_routing);
+	 *   - virt/kvm/irqchip.c|421| <<kvm_set_irq_routing>> old = rcu_dereference_protected(kvm->irq_routing, 1);
+	 *   - virt/kvm/irqchip.c|422| <<kvm_set_irq_routing>> rcu_assign_pointer(kvm->irq_routing, new);
+	 */
 	irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
 					lockdep_is_held(&kvm->irq_lock));
 	if (irq_rt && gsi < irq_rt->nr_rt_entries) {
@@ -42,14 +85,38 @@ int kvm_irq_map_gsi(struct kvm *kvm,
 	return n;
 }
 
+/*
+ * 在以下调用kvm_irq_map_chip_pin():
+ *   - rch/x86/kvm/irq_comm.c|272| <<kvm_fire_mask_notifiers>> gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+ *   - virt/kvm/eventfd.c|457| <<kvm_irq_has_notifier>> gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+ *   - virt/kvm/eventfd.c|489| <<kvm_notify_acked_irq>> gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+ *
+ * 返回irq_rt->chip[irqchip][pin]
+ */
 int kvm_irq_map_chip_pin(struct kvm *kvm, unsigned irqchip, unsigned pin)
 {
 	struct kvm_irq_routing_table *irq_rt;
 
+	/*
+	 * 在以下使用kvm->irq_routing:
+	 *   - arch/x86/kvm/hyperv.c|531| <<kvm_hv_irq_routing_update>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - arch/x86/kvm/irq_comm.c|469| <<kvm_scan_ioapic_routes>> table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/svm/avic.c|929| <<avic_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|291| <<vmx_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|60| <<kvm_irq_map_gsi>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - virt/kvm/irqchip.c|88| <<kvm_irq_map_chip_pin>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|222| <<kvm_free_irq_routing>> struct kvm_irq_routing_table *rt = rcu_access_pointer(kvm->irq_routing);
+	 *   - virt/kvm/irqchip.c|421| <<kvm_set_irq_routing>> old = rcu_dereference_protected(kvm->irq_routing, 1);
+	 *   - virt/kvm/irqchip.c|422| <<kvm_set_irq_routing>> rcu_assign_pointer(kvm->irq_routing, new);
+	 */
 	irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
 	return irq_rt->chip[irqchip][pin];
 }
 
+/*
+ * 处理KVM_SIGNAL_MSI:
+ *   - virt/kvm/kvm_main.c|4584| <<kvm_vm_ioctl(KVM_SIGNAL_MSI)>> r = kvm_send_userspace_msi(kvm, &msi);
+ */
 int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi)
 {
 	struct kvm_kernel_irq_routing_entry route;
@@ -63,9 +130,30 @@ int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi)
 	route.msi.flags = msi->flags;
 	route.msi.devid = msi->devid;
 
+	/*
+	 * 在以下使用kvm_set_msi():
+	 *   - arch/x86/kvm/irq_comm.c|329| <<kvm_set_routing_entry>> e->set = kvm_set_msi;
+	 *   - virt/kvm/irqchip.c|136| <<kvm_send_userspace_msi>> return kvm_set_msi(&route, kvm, KVM_USERSPACE_IRQ_SOURCE_ID, 1, false);
+	 *
+	 * userspace_msi好像不走irq_routing
+	 */
 	return kvm_set_msi(&route, kvm, KVM_USERSPACE_IRQ_SOURCE_ID, 1, false);
 }
 
+/*
+ * 在以下调用kvm_set_irq():
+ *   - arch/powerpc/kvm/book3s.c|1035| <<kvm_arch_set_irq_inatomic>> return kvm_set_irq(kvm, irq_source_id, irq_entry->gsi,
+ *   - arch/powerpc/kvm/book3s.c|1042| <<kvmppc_book3s_set_irq>> return kvm_set_irq(kvm, irq_source_id, e->gsi, level, line_status);
+ *   - arch/powerpc/kvm/powerpc.c|2139| <<kvm_vm_ioctl_irq_line>> irq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,
+ *   - arch/x86/kvm/i8254.c|251| <<pit_do_work>> kvm_set_irq(kvm, pit->irq_source_id, 0, 1, false);
+ *   - arch/x86/kvm/i8254.c|252| <<pit_do_work>> kvm_set_irq(kvm, pit->irq_source_id, 0, 0, false);
+ *   - arch/x86/kvm/x86.c|5839| <<kvm_vm_ioctl_irq_line>> irq_event->status = kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID,
+ *   - virt/kvm/eventfd.c|49| <<irqfd_inject>> kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID, irqfd->gsi, 1,
+ *   - virt/kvm/eventfd.c|51| <<irqfd_inject>> kvm_set_irq(kvm, KVM_USERSPACE_IRQ_SOURCE_ID, irqfd->gsi, 0,
+ *   - virt/kvm/eventfd.c|54| <<irqfd_inject>> kvm_set_irq(kvm, KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
+ *   - virt/kvm/eventfd.c|75| <<irqfd_resampler_ack>> kvm_set_irq(kvm, KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
+ *   - virt/kvm/eventfd.c|100| <<irqfd_resampler_shutdown>> kvm_set_irq(kvm, KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,
+ */
 /*
  * Return value:
  *  < 0   Interrupt was ignored (masked or not delivered for other reasons)
@@ -75,6 +163,12 @@ int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi)
 int kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,
 		bool line_status)
 {
+	/*
+	 * #define KVM_IRQCHIP_PIC_MASTER   0
+	 * #define KVM_IRQCHIP_PIC_SLAVE    1
+	 * #define KVM_IRQCHIP_IOAPIC       2
+	 * #define KVM_NR_IRQCHIPS          3
+	 */
 	struct kvm_kernel_irq_routing_entry irq_set[KVM_NR_IRQCHIPS];
 	int ret = -1, i, idx;
 
@@ -85,6 +179,9 @@ int kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,
 	 * writes to the unused one.
 	 */
 	idx = srcu_read_lock(&kvm->irq_srcu);
+	/*
+	 * 填充irq_set十足
+	 */
 	i = kvm_irq_map_gsi(kvm, irq_set, irq);
 	srcu_read_unlock(&kvm->irq_srcu, idx);
 
@@ -101,6 +198,11 @@ int kvm_set_irq(struct kvm *kvm, int irq_source_id, u32 irq, int level,
 	return ret;
 }
 
+/*
+ * 在以下使用free_irq_routing_table():
+ *   - virt/kvm/irqchip.c|170| <<kvm_free_irq_routing>> free_irq_routing_table(rt);
+ *   - virt/kvm/irqchip.c|333| <<kvm_set_irq_routing>> free_irq_routing_table(new);
+ */
 static void free_irq_routing_table(struct kvm_irq_routing_table *rt)
 {
 	int i;
@@ -108,6 +210,22 @@ static void free_irq_routing_table(struct kvm_irq_routing_table *rt)
 	if (!rt)
 		return;
 
+	/*
+	 * 在以下使用kvm_irq_routing_table->nr_rt_entries:
+	 *   - arch/x86/kvm/hyperv.c|534| <<kvm_hv_irq_routing_update>> for (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {
+	 *   - arch/x86/kvm/irq_comm.c|430| <<kvm_scan_ioapic_routes>> nr_ioapic_pins = min_t(u32, table->nr_rt_entries,
+	 *                  kvm->arch.nr_reserved_ioapic_pins);
+	 *   - arch/x86/kvm/svm/avic.c|931| <<avic_pi_update_irte>> if (guest_irq >= irq_rt->nr_rt_entries || hlist_empty(&irq_rt->map[guest_irq])) {
+	 *   - arch/x86/kvm/svm/avic.c|934| <<avic_pi_update_irte>> pr_warn_once("no route for guest_irq %u/%u (broken user space?)\n",
+	 *                  guest_irq, irq_rt->nr_rt_entries);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|292| <<vmx_pi_update_irte>> if (guest_irq >= irq_rt->nr_rt_entries || hlist_empty(&irq_rt->map[guest_irq])) {
+	 *   - arch/x86/kvm/vmx/posted_intr.c|295| <<vmx_pi_update_irte>> pr_warn_once("no route for guest_irq %u/%u (broken user space?)\n",
+	 *                  guest_irq, irq_rt->nr_rt_entries);
+	 *   - virt/kvm/irqchip.c|31| <<kvm_irq_map_gsi>> if (irq_rt && gsi < irq_rt->nr_rt_entries) {
+	 *   - virt/kvm/irqchip.c|34| <<kvm_irq_map_gsi>> index = array_index_nospec(gsi, irq_rt->nr_rt_entries);
+	 *   - virt/kvm/irqchip.c|111| <<free_irq_routing_table>> for (i = 0; i < rt->nr_rt_entries; ++i) {
+	 *   - virt/kvm/irqchip.c|195| <<kvm_set_irq_routing>> new->nr_rt_entries = nr_rt_entries;
+	 */
 	for (i = 0; i < rt->nr_rt_entries; ++i) {
 		struct kvm_kernel_irq_routing_entry *e;
 		struct hlist_node *n;
@@ -121,14 +239,58 @@ static void free_irq_routing_table(struct kvm_irq_routing_table *rt)
 	kfree(rt);
 }
 
+/*
+ * 在以下调用kvm_free_irq_routing():
+ *   - virt/kvm/kvm_main.c|1227| <<kvm_destroy_vm>> kvm_free_irq_routing(kvm);
+ */
 void kvm_free_irq_routing(struct kvm *kvm)
 {
+	/*
+	 * 在以下使用kvm->irq_routing:
+	 *   - arch/x86/kvm/hyperv.c|531| <<kvm_hv_irq_routing_update>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - arch/x86/kvm/irq_comm.c|469| <<kvm_scan_ioapic_routes>> table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/svm/avic.c|929| <<avic_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|291| <<vmx_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|60| <<kvm_irq_map_gsi>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - virt/kvm/irqchip.c|88| <<kvm_irq_map_chip_pin>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|222| <<kvm_free_irq_routing>> struct kvm_irq_routing_table *rt = rcu_access_pointer(kvm->irq_routing);
+	 *   - virt/kvm/irqchip.c|421| <<kvm_set_irq_routing>> old = rcu_dereference_protected(kvm->irq_routing, 1);
+	 *   - virt/kvm/irqchip.c|422| <<kvm_set_irq_routing>> rcu_assign_pointer(kvm->irq_routing, new);
+	 */
 	/* Called only during vm destruction. Nobody can use the pointer
 	   at this stage */
 	struct kvm_irq_routing_table *rt = rcu_access_pointer(kvm->irq_routing);
+	/*
+	 * 在以下使用free_irq_routing_table():
+	 *   - virt/kvm/irqchip.c|170| <<kvm_free_irq_routing>> free_irq_routing_table(rt);
+	 *   - virt/kvm/irqchip.c|333| <<kvm_set_irq_routing>> free_irq_routing_table(new);
+	 */
 	free_irq_routing_table(rt);
 }
 
+/*
+ * 1159 #define KVM_IRQ_ROUTING_IRQCHIP 1
+ * 1160 #define KVM_IRQ_ROUTING_MSI 2
+ * 1161 #define KVM_IRQ_ROUTING_S390_ADAPTER 3
+ * 1162 #define KVM_IRQ_ROUTING_HV_SINT 4
+ * 1163
+ * 1164 struct kvm_irq_routing_entry {
+ * 1165         __u32 gsi;
+ * 1166         __u32 type;
+ * 1167         __u32 flags;
+ * 1168         __u32 pad;
+ * 1169         union {
+ * 1170                 struct kvm_irq_routing_irqchip irqchip;
+ * 1171                 struct kvm_irq_routing_msi msi;
+ * 1172                 struct kvm_irq_routing_s390_adapter adapter;
+ * 1173                 struct kvm_irq_routing_hv_sint hv_sint;
+ * 1174                 __u32 pad[8];
+ * 1175         } u;
+ * 1176 };
+ *
+ * 在以下调用setup_routing_entry():
+ *   - virt/kvm/irqchip.c|309| <<kvm_set_irq_routing>> r = setup_routing_entry(kvm, new, e, ue);
+ */
 static int setup_routing_entry(struct kvm *kvm,
 			       struct kvm_irq_routing_table *rt,
 			       struct kvm_kernel_irq_routing_entry *e,
@@ -150,12 +312,28 @@ static int setup_routing_entry(struct kvm *kvm,
 
 	e->gsi = gsi;
 	e->type = ue->type;
+	/*
+	 * 在以下调用kvm_set_routing_entry():
+	 *   - virt/kvm/irqchip.c|194| <<setup_routing_entry>> r = kvm_set_routing_entry(kvm, e, ue);
+	 *
+	 * 根据用户空间的kvm_irq_routing_entry
+	 * 配置kvm_kernel_irq_routing_entry
+	 */
 	r = kvm_set_routing_entry(kvm, e, ue);
 	if (r)
 		return r;
+	/*
+	 * #define KVM_IRQ_ROUTING_IRQCHIP 1
+	 * #define KVM_IRQ_ROUTING_MSI 2
+	 * #define KVM_IRQ_ROUTING_S390_ADAPTER 3
+	 * #define KVM_IRQ_ROUTING_HV_SINT 4
+	 */
 	if (e->type == KVM_IRQ_ROUTING_IRQCHIP)
 		rt->chip[e->irqchip.irqchip][e->irqchip.pin] = e->gsi;
 
+	/*
+	 * 有没有可能上面有4个entry?????
+	 */
 	hlist_add_head(&e->link, &rt->map[e->gsi]);
 
 	return 0;
@@ -170,6 +348,49 @@ bool __weak kvm_arch_can_set_irq_routing(struct kvm *kvm)
 	return true;
 }
 
+/*
+ * 265 把irq从CPU=5换到CPU=6上.
+ * 266 
+ * 267        CPU 5/KVM-51857   [011] ..... 435912.873065: vfio_pci_set_msi_trigger <-vfio_pci_core_ioctl
+ * 268        CPU 5/KVM-51857   [011] ..... 435912.873068: vfio_msi_set_vector_signal <-vfio_msi_set_block
+ * 269        CPU 5/KVM-51857   [011] ..... 435912.873069: irq_bypass_unregister_producer <-vfio_msi_set_vector_signal
+ * 270        CPU 5/KVM-51857   [011] ..... 435912.873070: kvm_arch_irq_bypass_del_producer <-__disconnect
+ * 271        CPU 5/KVM-51857   [011] ..... 435912.873070: vmx_pi_update_irte <-kvm_arch_irq_bypass_del_producer
+ * 272        CPU 5/KVM-51857   [011] ..... 435912.873102: irq_bypass_register_producer <-vfio_msi_set_vector_signal
+ * 273 
+ * 274        CPU 5/KVM-51857   [011] ..... 435912.873255: kvm_set_irq_routing <-kvm_vm_ioctl
+ * 275        CPU 5/KVM-51857   [011] ..... 435912.873263: kvm_irq_routing_update <-kvm_set_irq_routing
+ * 276        CPU 5/KVM-51857   [011] d.... 435912.873263: irqfd_update <-kvm_irq_routing_update
+ * 277        CPU 5/KVM-51857   [011] d.... 435912.873264: kvm_arch_update_irqfd_routing <-kvm_irq_routing_update
+ * 278        CPU 5/KVM-51857   [011] d.... 435912.873264: vmx_pi_update_irte <-kvm_irq_routing_update
+ * 279        CPU 5/KVM-51857   [011] d.... 435912.873266: irqfd_update <-kvm_irq_routing_update
+ * 280        CPU 5/KVM-51857   [011] d.... 435912.873266: irqfd_update <-kvm_irq_routing_update
+ * 281        CPU 5/KVM-51857   [011] d.... 435912.873266: kvm_arch_update_irqfd_routing <-kvm_irq_routing_update
+ * 282        CPU 5/KVM-51857   [011] d.... 435912.873266: vmx_pi_update_irte <-kvm_irq_routing_update
+ * 283 
+ * 284        CPU 5/KVM-51857   [011] ..... 435912.873290: vfio_pci_set_msi_trigger <-vfio_pci_core_ioctl
+ * 285        CPU 5/KVM-51857   [011] ..... 435912.873291: vfio_msi_set_vector_signal <-vfio_msi_set_block
+ * 286        CPU 5/KVM-51857   [011] ..... 435912.873291: irq_bypass_unregister_producer <-vfio_msi_set_vector_signal
+ * 287        CPU 5/KVM-51857   [011] ..... 435912.873311: irq_bypass_register_producer <-vfio_msi_set_vector_signal
+ * 288        CPU 5/KVM-51857   [011] ..... 435912.873312: kvm_arch_irq_bypass_add_producer <-__connect
+ * 289        CPU 5/KVM-51857   [011] ..... 435912.873312: vmx_pi_update_irte <-kvm_arch_irq_bypass_add_producer
+ *
+ * Add或者Del vCPU会调用:
+ *
+ * kvm_set_irq_routing
+ * kvm_vm_ioctl
+ * __x64_sys_ioctl
+ * do_syscall_64
+ * entry_SYSCALL_64_after_hwframe
+ *
+ * 在以下调用kvm_set_irq_routing():
+ *   - arch/arm64/kvm/vgic/vgic-irqfd.c|152| <<kvm_vgic_setup_default_irq_routing>> ret = kvm_set_irq_routing(kvm, entries, nr, 0);
+ *   - arch/powerpc/kvm/mpic.c|1649| <<mpic_set_default_irq_routing>> kvm_set_irq_routing(opp->kvm, routing, 0, 0);
+ *   - arch/s390/kvm/kvm-s390.c|2435| <<kvm_arch_vm_ioctl>> r = kvm_set_irq_routing(kvm, &routing, 0, 0);
+ *   - arch/x86/kvm/irq_comm.c|393| <<kvm_setup_default_irq_routing>> return kvm_set_irq_routing(kvm, default_routing, ARRAY_SIZE(default_routing), 0);
+ *   - arch/x86/kvm/irq_comm.c|401| <<kvm_setup_empty_irq_routing>> return kvm_set_irq_routing(kvm, empty_routing, 0, 0);
+ *   - virt/kvm/kvm_main.c|4638| <<kvm_vm_ioctl(KVM_SET_GSI_ROUTING)>> r = kvm_set_irq_routing(kvm, entries, routing.nr, routing.flags);
+ */
 int kvm_set_irq_routing(struct kvm *kvm,
 			const struct kvm_irq_routing_entry *ue,
 			unsigned nr,
@@ -192,6 +413,22 @@ int kvm_set_irq_routing(struct kvm *kvm,
 	if (!new)
 		return -ENOMEM;
 
+	/*
+	 * 在以下使用kvm_irq_routing_table->nr_rt_entries:
+	 *   - arch/x86/kvm/hyperv.c|534| <<kvm_hv_irq_routing_update>> for (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {
+	 *   - arch/x86/kvm/irq_comm.c|430| <<kvm_scan_ioapic_routes>> nr_ioapic_pins = min_t(u32, table->nr_rt_entries,
+	 *                  kvm->arch.nr_reserved_ioapic_pins);
+	 *   - arch/x86/kvm/svm/avic.c|931| <<avic_pi_update_irte>> if (guest_irq >= irq_rt->nr_rt_entries || hlist_empty(&irq_rt->map[guest_irq])) {
+	 *   - arch/x86/kvm/svm/avic.c|934| <<avic_pi_update_irte>> pr_warn_once("no route for guest_irq %u/%u (broken user space?)\n",
+	 *                  guest_irq, irq_rt->nr_rt_entries);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|292| <<vmx_pi_update_irte>> if (guest_irq >= irq_rt->nr_rt_entries || hlist_empty(&irq_rt->map[guest_irq])) {
+	 *   - arch/x86/kvm/vmx/posted_intr.c|295| <<vmx_pi_update_irte>> pr_warn_once("no route for guest_irq %u/%u (broken user space?)\n",
+	 *                  guest_irq, irq_rt->nr_rt_entries);
+	 *   - virt/kvm/irqchip.c|31| <<kvm_irq_map_gsi>> if (irq_rt && gsi < irq_rt->nr_rt_entries) {
+	 *   - virt/kvm/irqchip.c|34| <<kvm_irq_map_gsi>> index = array_index_nospec(gsi, irq_rt->nr_rt_entries);
+	 *   - virt/kvm/irqchip.c|111| <<free_irq_routing_table>> for (i = 0; i < rt->nr_rt_entries; ++i) {
+	 *   - virt/kvm/irqchip.c|195| <<kvm_set_irq_routing>> new->nr_rt_entries = nr_rt_entries;
+	 */
 	new->nr_rt_entries = nr_rt_entries;
 	for (i = 0; i < KVM_NR_IRQCHIPS; i++)
 		for (j = 0; j < KVM_IRQCHIP_NUM_PINS; j++)
@@ -221,12 +458,44 @@ int kvm_set_irq_routing(struct kvm *kvm,
 	}
 
 	mutex_lock(&kvm->irq_lock);
+	/*
+	 * 在以下使用kvm->irq_routing:
+	 *   - arch/x86/kvm/hyperv.c|531| <<kvm_hv_irq_routing_update>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - arch/x86/kvm/irq_comm.c|469| <<kvm_scan_ioapic_routes>> table = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/svm/avic.c|929| <<avic_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - arch/x86/kvm/vmx/posted_intr.c|291| <<vmx_pi_update_irte>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|60| <<kvm_irq_map_gsi>> irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+	 *   - virt/kvm/irqchip.c|88| <<kvm_irq_map_chip_pin>> irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+	 *   - virt/kvm/irqchip.c|222| <<kvm_free_irq_routing>> struct kvm_irq_routing_table *rt = rcu_access_pointer(kvm->irq_routing);
+	 *   - virt/kvm/irqchip.c|421| <<kvm_set_irq_routing>> old = rcu_dereference_protected(kvm->irq_routing, 1);
+	 *   - virt/kvm/irqchip.c|422| <<kvm_set_irq_routing>> rcu_assign_pointer(kvm->irq_routing, new);
+	 */
 	old = rcu_dereference_protected(kvm->irq_routing, 1);
 	rcu_assign_pointer(kvm->irq_routing, new);
+	/*
+	 * 只在此处调用
+	 */
 	kvm_irq_routing_update(kvm);
+	/*
+	 * 只调用kvm_hv_irq_routing_update()
+	 * 基本等于没用
+	 */
 	kvm_arch_irq_routing_update(kvm);
 	mutex_unlock(&kvm->irq_lock);
 
+	/*
+	 * 在以下使用KVM_REQ_SCAN_IOAPIC:
+	 *   - arch/x86/kvm/hyperv.c|171| <<synic_set_sint>> kvm_make_request(KVM_REQ_SCAN_IOAPIC, hv_synic_to_vcpu(synic));
+	 *   - arch/x86/kvm/x86.c|9868| <<kvm_make_scan_ioapic_request_mask>> kvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,
+	 *   - arch/x86/kvm/x86.c|9876| <<kvm_make_scan_ioapic_request>> kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
+	 *   - arch/x86/kvm/x86.c|10159| <<vcpu_enter_guest>> if (kvm_check_request(KVM_REQ_SCAN_IOAPIC, vcpu))
+	 *
+	 * 处理的函数: vcpu_scan_ioapic(vcpu);
+	 *
+	 * 如果是split:
+	 * kvm_make_scan_ioapic_request()
+	 * 可能还会kick各个vcpu
+	 */
 	kvm_arch_post_irq_routing_update(kvm);
 
 	synchronize_srcu_expedited(&kvm->irq_srcu);
@@ -238,6 +507,11 @@ int kvm_set_irq_routing(struct kvm *kvm,
 free_entry:
 	kfree(e);
 out:
+	/*
+	 * 在以下使用free_irq_routing_table():
+	 *   - virt/kvm/irqchip.c|170| <<kvm_free_irq_routing>> free_irq_routing_table(rt);
+	 *   - virt/kvm/irqchip.c|333| <<kvm_set_irq_routing>> free_irq_routing_table(new);
+	 */
 	free_irq_routing_table(new);
 
 	return r;
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 801ab0635bc3..f3d7ef288dbb 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -3270,6 +3270,11 @@ static void shrink_halt_poll_ns(struct kvm_vcpu *vcpu)
 	trace_kvm_halt_poll_ns_shrink(vcpu->vcpu_id, val, old);
 }
 
+/*
+ * 在以下调用kvm_vcpu_check_block():
+ *   - virt/kvm/kvm_main.c|3326| <<kvm_vcpu_block>> if (kvm_vcpu_check_block(vcpu) < 0) {
+ *   - virt/kvm/kvm_main.c|3351| <<kvm_vcpu_block>> if (kvm_vcpu_check_block(vcpu) < 0)
+ */
 static int kvm_vcpu_check_block(struct kvm_vcpu *vcpu)
 {
 	int ret = -EINTR;
@@ -3279,6 +3284,11 @@ static int kvm_vcpu_check_block(struct kvm_vcpu *vcpu)
 		kvm_make_request(KVM_REQ_UNHALT, vcpu);
 		goto out;
 	}
+	/*
+	 * 在以下使用kvm_cpu_has_pending_timer():
+	 *   - arch/x86/kvm/x86.c|10389| <<vcpu_run>> if (kvm_cpu_has_pending_timer(vcpu))
+	 *   - virt/kvm/kvm_main.c|3282| <<kvm_vcpu_check_block>> if (kvm_cpu_has_pending_timer(vcpu))
+	 */
 	if (kvm_cpu_has_pending_timer(vcpu))
 		goto out;
 	if (signal_pending(current))
@@ -3304,6 +3314,14 @@ update_halt_poll_stats(struct kvm_vcpu *vcpu, u64 poll_ns, bool waited)
 /*
  * The vCPU has executed a HLT instruction with in-kernel mode enabled.
  */
+/*
+ * 在以下使用kvm_vcpu_block():
+ *   - arch/x86/kvm/x86.c|10321| <<vcpu_block>> kvm_vcpu_block(vcpu);
+ *   - arch/x86/kvm/x86.c|10533| <<kvm_arch_vcpu_ioctl_run>> kvm_vcpu_block(vcpu);
+ *
+ * 注释是:
+ * The vCPU has executed a HLT instruction with in-kernel mode enabled.
+ */
 void kvm_vcpu_block(struct kvm_vcpu *vcpu)
 {
 	bool halt_poll_allowed = !kvm_arch_no_poll(vcpu);
@@ -3323,6 +3341,11 @@ void kvm_vcpu_block(struct kvm_vcpu *vcpu)
 			 * This sets KVM_REQ_UNHALT if an interrupt
 			 * arrives.
 			 */
+			/*
+			 * 在以下调用kvm_vcpu_check_block():
+			 *   - virt/kvm/kvm_main.c|3326| <<kvm_vcpu_block>> if (kvm_vcpu_check_block(vcpu) < 0) {
+			 *   - virt/kvm/kvm_main.c|3351| <<kvm_vcpu_block>> if (kvm_vcpu_check_block(vcpu) < 0)
+			 */
 			if (kvm_vcpu_check_block(vcpu) < 0) {
 				++vcpu->stat.generic.halt_successful_poll;
 				if (!vcpu_valid_wakeup(vcpu))
@@ -3348,6 +3371,11 @@ void kvm_vcpu_block(struct kvm_vcpu *vcpu)
 	for (;;) {
 		set_current_state(TASK_INTERRUPTIBLE);
 
+		/*
+		 * 在以下调用kvm_vcpu_check_block():
+		 *   - virt/kvm/kvm_main.c|3326| <<kvm_vcpu_block>> if (kvm_vcpu_check_block(vcpu) < 0) {
+		 *   - virt/kvm/kvm_main.c|3351| <<kvm_vcpu_block>> if (kvm_vcpu_check_block(vcpu) < 0)
+		 */
 		if (kvm_vcpu_check_block(vcpu) < 0)
 			break;
 
@@ -4607,6 +4635,15 @@ static long kvm_vm_ioctl(struct file *filp,
 				goto out;
 			}
 		}
+		/*
+		 * 在以下调用kvm_set_irq_routing():
+		 *   - arch/arm64/kvm/vgic/vgic-irqfd.c|152| <<kvm_vgic_setup_default_irq_routing>> ret = kvm_set_irq_routing(kvm, entries, nr, 0);
+		 *   - arch/powerpc/kvm/mpic.c|1649| <<mpic_set_default_irq_routing>> kvm_set_irq_routing(opp->kvm, routing, 0, 0);
+		 *   - arch/s390/kvm/kvm-s390.c|2435| <<kvm_arch_vm_ioctl>> r = kvm_set_irq_routing(kvm, &routing, 0, 0);
+		 *   - arch/x86/kvm/irq_comm.c|393| <<kvm_setup_default_irq_routing>> return kvm_set_irq_routing(kvm, default_routing, ARRAY_SIZE(default_routing), 0);
+		 *   - arch/x86/kvm/irq_comm.c|401| <<kvm_setup_empty_irq_routing>> return kvm_set_irq_routing(kvm, empty_routing, 0, 0);
+		 *   - virt/kvm/kvm_main.c|4638| <<kvm_vm_ioctl(KVM_SET_GSI_ROUTING)>> r = kvm_set_irq_routing(kvm, entries, routing.nr, routing.flags);
+		 */
 		r = kvm_set_irq_routing(kvm, entries, routing.nr,
 					routing.flags);
 		kvfree(entries);
diff --git a/virt/lib/irqbypass.c b/virt/lib/irqbypass.c
index 28fda42e471b..37261be61732 100644
--- a/virt/lib/irqbypass.c
+++ b/virt/lib/irqbypass.c
@@ -22,7 +22,25 @@
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("IRQ bypass manager utility module");
 
+/*
+ * 在以下使用producers:
+ *   - virt/lib/irqbypass.c|25| <<global>> static LIST_HEAD(producers);
+ *   - virt/lib/irqbypass.c|100| <<irq_bypass_register_producer>> list_for_each_entry(tmp, &producers, node) {
+ *   - virt/lib/irqbypass.c|116| <<irq_bypass_register_producer>> list_add(&producer->node, &producers);
+ *   - virt/lib/irqbypass.c|150| <<irq_bypass_unregister_producer>> list_for_each_entry(tmp, &producers, node) {
+ *   - virt/lib/irqbypass.c|203| <<irq_bypass_register_consumer>> list_for_each_entry(producer, &producers, node) {
+ *   - virt/lib/irqbypass.c|250| <<irq_bypass_unregister_consumer>> list_for_each_entry(producer, &producers, node) {
+ */
 static LIST_HEAD(producers);
+/*
+ * 在以下使用consumers:
+ *   - virt/lib/irqbypass.c|26| <<global>> static LIST_HEAD(consumers);
+ *   - virt/lib/irqbypass.c|107| <<irq_bypass_register_producer>> list_for_each_entry(consumer, &consumers, node) {
+ *   - virt/lib/irqbypass.c|154| <<irq_bypass_unregister_producer>> list_for_each_entry(consumer, &consumers, node) {
+ *   - virt/lib/irqbypass.c|196| <<irq_bypass_register_consumer>> list_for_each_entry(tmp, &consumers, node) {
+ *   - virt/lib/irqbypass.c|212| <<irq_bypass_register_consumer>> list_add(&consumer->node, &consumers);
+ *   - virt/lib/irqbypass.c|246| <<irq_bypass_unregister_consumer>> list_for_each_entry(tmp, &consumers, node) {
+ */
 static LIST_HEAD(consumers);
 static DEFINE_MUTEX(lock);
 
@@ -81,6 +99,11 @@ static void __disconnect(struct irq_bypass_producer *prod,
  * Add the provided IRQ producer to the list of producers and connect
  * with any matching token found on the IRQ consumers list.
  */
+/*
+ * 在以下调用irq_bypass_register_producer():
+ *   - drivers/vfio/pci/vfio_pci_intrs.c|386| <<vfio_msi_set_vector_signal>> ret = irq_bypass_register_producer(&vdev->ctx[vector].producer);
+ *   - drivers/vhost/vdpa.c|217| <<vhost_vdpa_setup_vq_irq>> ret = irq_bypass_register_producer(&vq->call_ctx.producer);
+ */
 int irq_bypass_register_producer(struct irq_bypass_producer *producer)
 {
 	struct irq_bypass_producer *tmp;
@@ -176,6 +199,10 @@ EXPORT_SYMBOL_GPL(irq_bypass_unregister_producer);
  * Add the provided IRQ consumer to the list of consumers and connect
  * with any matching token found on the IRQ producer list.
  */
+/*
+ * 在以下调用irq_bypass_register_consumer():
+ *   - virt/kvm/eventfd.c|418| <<kvm_irqfd_assign>> ret = irq_bypass_register_consumer(&irqfd->consumer);
+ */
 int irq_bypass_register_consumer(struct irq_bypass_consumer *consumer)
 {
 	struct irq_bypass_consumer *tmp;
-- 
2.39.5 (Apple Git-154)

