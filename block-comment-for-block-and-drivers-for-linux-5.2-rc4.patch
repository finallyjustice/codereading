From 106d517c7fc02873c36f6de04c44f1d911af89c2 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Thu, 13 Jun 2019 15:59:15 +0800
Subject: [PATCH 1/1] block comment for block and drivers for linux-5.2-rc4

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/kernel/apic/vector.c       |  35 +++++++++++
 block/blk-core.c                    |  36 +++++++++++
 block/blk-mq-tag.h                  |   7 +++
 block/blk-mq.c                      |  87 +++++++++++++++++++++++++++
 block/blk-mq.h                      |   9 +++
 block/blk-timeout.c                 |  18 ++++++
 drivers/nvme/host/pci.c             |   4 ++
 drivers/scsi/hosts.c                |  29 +++++++++
 drivers/scsi/iscsi_tcp.c            |  10 +++
 drivers/scsi/scsi_lib.c             |  49 +++++++++++++++
 drivers/scsi/scsi_scan.c            | 117 ++++++++++++++++++++++++++++++++++++
 drivers/scsi/scsi_sysfs.c           |  26 ++++++++
 drivers/scsi/scsi_transport_iscsi.c |   9 +++
 drivers/scsi/sd.c                   |  52 ++++++++++++++++
 drivers/scsi/virtio_scsi.c          | 110 +++++++++++++++++++++++++++++++++
 include/linux/blk-mq.h              |  30 +++++++++
 include/linux/blkdev.h              |  20 ++++++
 include/linux/dma-mapping.h         |  13 ++++
 include/linux/irq.h                 |   7 +++
 kernel/irq/matrix.c                 |   4 ++
 20 files changed, 672 insertions(+)

diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c
index 3173e07..ab8ce93 100644
--- a/arch/x86/kernel/apic/vector.c
+++ b/arch/x86/kernel/apic/vector.c
@@ -26,6 +26,37 @@
 
 #include <asm/trace/irq_vectors.h>
 
+/*
+ * struct irq_affinity_desc
+ *   unsigned int is_managed:1; 默认是1
+ *
+ *   - kernel/irq/affinity.c|318| <<irq_create_affinity_masks>> masks[i].is_managed = 1;
+ *   - kernel/irq/irqdesc.c|473| <<alloc_descs>> if (affinity->is_managed) {
+ *
+ *
+ * struct pci_dev
+ *   unsigned int is_managed:1; 默认是1
+ *
+ *   - drivers/pci/pci.c|1808| <<pcim_enable_device>> pdev->is_managed = 1;
+ *   - include/linux/pci.h|1107| <<pci_is_managed>> return pdev->is_managed;
+ *
+ *
+ * struct apic_chip_data
+ *   unsigned int is_managed:1; 默认是1
+ *
+ *   - arch/x86/kernel/apic/vector.c|194| <<reserve_managed_vector>> apicd->is_managed = true;
+ *   - arch/x86/kernel/apic/vector.c|367| <<x86_vector_deactivate>> trace_vector_deactivate(irqd->irq, apicd->is_managed,
+ *   - arch/x86/kernel/apic/vector.c|371| <<x86_vector_deactivate>> if (!apicd->is_managed && !apicd->can_reserve)
+ *   - arch/x86/kernel/apic/vector.c|438| <<x86_vector_activate>> trace_vector_activate(irqd->irq, apicd->is_managed,
+ *   - arch/x86/kernel/apic/vector.c|442| <<x86_vector_activate>> if (!apicd->can_reserve && !apicd->is_managed)
+ *   - arch/x86/kernel/apic/vector.c|448| <<x86_vector_activate>> else if (apicd->is_managed)
+ *   - arch/x86/kernel/apic/vector.c|461| <<vector_free_reserved_and_managed>> trace_vector_teardown(irqd->irq, apicd->is_managed,
+ *   - arch/x86/kernel/apic/vector.c|466| <<vector_free_reserved_and_managed>> if (apicd->is_managed)
+ *   - arch/x86/kernel/apic/vector.c|615| <<x86_vector_debug_show>> seq_printf(m, "%*sis_managed: %u\n", ind, "", apicd.is_managed ? 1 : 0);
+ *   - arch/x86/kernel/apic/vector.c|776| <<apic_set_affinity>> (apicd->is_managed || apicd->can_reserve))
+ *   - arch/x86/kernel/apic/vector.c|830| <<free_moved_vector>> bool managed = apicd->is_managed;
+ */
+
 struct apic_chip_data {
 	struct irq_cfg		hw_irq_cfg;
 	unsigned int		vector;
@@ -296,6 +327,10 @@ static int assign_irq_vector_any_locked(struct irq_data *irqd)
 static int
 assign_irq_vector_policy(struct irq_data *irqd, struct irq_alloc_info *info)
 {
+	/*
+	 * IRQD_AFFINITY_MANAGED在以下设置:
+	 *   - kernel/irq/irqdesc.c|474| <<alloc_descs>> flags = IRQD_AFFINITY_MANAGED |
+	 */
 	if (irqd_affinity_is_managed(irqd))
 		return reserve_managed_vector(irqd);
 	if (info->mask)
diff --git a/block/blk-core.c b/block/blk-core.c
index 8340f69..fae2d4d 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -411,10 +411,23 @@ static void blk_queue_usage_counter_release(struct percpu_ref *ref)
 	wake_up_all(&q->mq_freeze_wq);
 }
 
+/*
+ * used by:
+ *   - block/blk-core.c|466| <<blk_alloc_queue_node>> timer_setup(&q->timeout, blk_rq_timed_out_timer, 0);
+ */
 static void blk_rq_timed_out_timer(struct timer_list *t)
 {
 	struct request_queue *q = from_timer(q, t, timeout);
 
+	/*
+	 * timeout_work在以下使用:
+	 *   - block/blk-core.c|235| <<blk_sync_queue>> cancel_work_sync(&q->timeout_work);
+	 *   - block/blk-core.c|418| <<blk_rq_timed_out_timer>> kblockd_schedule_work(&q->timeout_work);
+	 *   - block/blk-core.c|467| <<blk_alloc_queue_node>> INIT_WORK(&q->timeout_work, blk_timeout_work);
+	 *   - block/blk-mq.c|923| <<blk_mq_timeout_work>> container_of(work, struct request_queue, timeout_work);
+	 *   - block/blk-mq.c|2942| <<blk_mq_init_allocated_queue>> INIT_WORK(&q->timeout_work, blk_mq_timeout_work);
+	 *   - block/blk-timeout.c|89| <<blk_abort_request>> kblockd_schedule_work(&req->q->timeout_work);
+	 */
 	kblockd_schedule_work(&q->timeout_work);
 }
 
@@ -427,6 +440,18 @@ static void blk_timeout_work(struct work_struct *work)
  * @gfp_mask: memory allocation flags
  * @node_id: NUMA node to allocate memory from
  */
+/*
+ * called by:
+ *   - block/blk-mq.c|2777| <<blk_mq_init_queue>> uninit_q = blk_alloc_queue_node(GFP_KERNEL, set->numa_node);
+ *   - block/blk-core.c|345| <<blk_alloc_queue>> return blk_alloc_queue_node(gfp_mask, NUMA_NO_NODE);
+ *   - drivers/block/drbd/drbd_main.c|2803| <<drbd_create_device>> q = blk_alloc_queue_node(GFP_KERNEL, NUMA_NO_NODE);
+ *   - drivers/block/null_blk_main.c|1663| <<null_add_dev>> nullb->q = blk_alloc_queue_node(GFP_KERNEL, dev->home_node);
+ *   - drivers/block/umem.c|888| <<mm_pci_probe>> card->queue = blk_alloc_queue_node(GFP_KERNEL, NUMA_NO_NODE);
+ *   - drivers/lightnvm/core.c|381| <<nvm_create_tgt>> tqueue = blk_alloc_queue_node(GFP_KERNEL, dev->q->node);
+ *   - drivers/md/dm.c|1971| <<alloc_dev>> md->queue = blk_alloc_queue_node(GFP_KERNEL, numa_node_id);
+ *   - drivers/nvdimm/pmem.c|398| <<pmem_attach_disk>> q = blk_alloc_queue_node(GFP_KERNEL, dev_to_node(dev));
+ *   - drivers/nvme/host/multipath.c|310| <<nvme_mpath_alloc_disk>> q = blk_alloc_queue_node(GFP_KERNEL, ctrl->numa_node);
+ */
 struct request_queue *blk_alloc_queue_node(gfp_t gfp_mask, int node_id)
 {
 	struct request_queue *q;
@@ -463,6 +488,17 @@ struct request_queue *blk_alloc_queue_node(gfp_t gfp_mask, int node_id)
 
 	timer_setup(&q->backing_dev_info->laptop_mode_wb_timer,
 		    laptop_mode_timer_fn, 0);
+	/*
+	 * q->timeout在以下使用:
+	 *   - block/blk-core.c|234| <<blk_sync_queue>> del_timer_sync(&q->timeout);
+	 *   - block/blk-core.c|491| <<blk_alloc_queue_node>> timer_setup(&q->timeout, blk_rq_timed_out_timer, 0);
+	 *   - block/blk-mq.c|967| <<blk_mq_timeout_work>> mod_timer(&q->timeout, next);
+	 *   - block/blk-timeout.c|154| <<blk_add_timer>> if (!timer_pending(&q->timeout) ||
+	 *   - block/blk-timeout.c|155| <<blk_add_timer>> time_before(expiry, q->timeout.expires)) {
+	 *   - block/blk-timeout.c|156| <<blk_add_timer>> unsigned long diff = q->timeout.expires - expiry; 
+	 *   - block/blk-timeout.c|165| <<blk_add_timer>> if (!timer_pending(&q->timeout) || (diff >= HZ / 2))
+	 *   - block/blk-timeout.c|166| <<blk_add_timer>> mod_timer(&q->timeout, expiry);
+	 */
 	timer_setup(&q->timeout, blk_rq_timed_out_timer, 0);
 	INIT_WORK(&q->timeout_work, blk_timeout_work);
 	INIT_LIST_HEAD(&q->icq_list);
diff --git a/block/blk-mq-tag.h b/block/blk-mq-tag.h
index 61deab0..a9f4d7f 100644
--- a/block/blk-mq-tag.h
+++ b/block/blk-mq-tag.h
@@ -18,6 +18,13 @@ struct blk_mq_tags {
 
 	struct request **rqs;
 	struct request **static_rqs;
+	/*
+	 * 在以下使用:
+	 *   - block/blk-mq.c|2072| <<blk_mq_free_rqs>> while (!list_empty(&tags->page_list)) {
+	 *   - block/blk-mq.c|2073| <<blk_mq_free_rqs>> page = list_first_entry(&tags->page_list, struct page, lru);
+	 *   - block/blk-mq.c|2162| <<blk_mq_alloc_rqs>> INIT_LIST_HEAD(&tags->page_list);
+	 *   - block/blk-mq.c|2197| <<blk_mq_alloc_rqs>> list_add_tail(&page->lru, &tags->page_list);
+	 */
 	struct list_head page_list;
 };
 
diff --git a/block/blk-mq.c b/block/blk-mq.c
index ce0f5f4..f26eaca 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -844,6 +844,10 @@ bool blk_mq_queue_inflight(struct request_queue *q)
 }
 EXPORT_SYMBOL_GPL(blk_mq_queue_inflight);
 
+/*
+ * called by:
+ *   - block/blk-mq.c|913| <<blk_mq_check_expired>> blk_mq_rq_timed_out(rq, reserved);
+ */
 static void blk_mq_rq_timed_out(struct request *req, bool reserved)
 {
 	req->rq_flags |= RQF_TIMED_OUT;
@@ -879,6 +883,10 @@ static bool blk_mq_req_expired(struct request *rq, unsigned long *next)
 	return false;
 }
 
+/*
+ * used by:
+ *   - block/blk-mq.c|944| <<blk_mq_timeout_work>> blk_mq_queue_tag_busy_iter(q, blk_mq_check_expired, &next);
+ */
 static bool blk_mq_check_expired(struct blk_mq_hw_ctx *hctx,
 		struct request *rq, void *priv, bool reserved)
 {
@@ -917,6 +925,18 @@ static bool blk_mq_check_expired(struct blk_mq_hw_ctx *hctx,
 	return true;
 }
 
+/*
+ * q->timeout_work在以下使用:
+ *   - lock/blk-core.c|235| <<blk_sync_queue>> cancel_work_sync(&q->timeout_work);
+ *   - block/blk-core.c|418| <<blk_rq_timed_out_timer>> kblockd_schedule_work(&q->timeout_work);
+ *   - block/blk-core.c|467| <<blk_alloc_queue_node>> INIT_WORK(&q->timeout_work, blk_timeout_work);
+ *   - block/blk-mq.c|923| <<blk_mq_timeout_work>> container_of(work, struct request_queue, timeout_work);
+ *   - block/blk-mq.c|2942| <<blk_mq_init_allocated_queue>> INIT_WORK(&q->timeout_work, blk_mq_timeout_work);
+ *   - block/blk-timeout.c|89| <<blk_abort_request>> kblockd_schedule_work(&req->q->timeout_work);
+ *
+ * used by:
+ *   - block/blk-mq.c|2942| <<blk_mq_init_allocated_queue>> INIT_WORK(&q->timeout_work, blk_mq_timeout_work);
+ */
 static void blk_mq_timeout_work(struct work_struct *work)
 {
 	struct request_queue *q =
@@ -1611,6 +1631,16 @@ void blk_mq_start_stopped_hw_queues(struct request_queue *q, bool async)
 }
 EXPORT_SYMBOL(blk_mq_start_stopped_hw_queues);
 
+/*
+ * 在以下使用:
+ *   - block/blk-mq.c|2353| <<blk_mq_alloc_hctx>> INIT_DELAYED_WORK(&hctx->run_work, blk_mq_run_work_fn);
+ *
+ * 在以下调用:
+ *   - block/blk-mq-sysfs.c|39| <<blk_mq_hw_sysfs_release>> cancel_delayed_work_sync(&hctx->run_work);
+ *   - block/blk-mq.c|1469| <<__blk_mq_delay_run_hw_queue>> kblockd_mod_delayed_work_on(blk_mq_hctx_next_cpu(hctx), &hctx->run_work,
+ *   - block/blk-mq.c|1551| <<blk_mq_stop_hw_queue>> cancel_delayed_work(&hctx->run_work);
+ *   - block/blk-mq.c|1618| <<blk_mq_run_work_fn>> hctx = container_of(work, struct blk_mq_hw_ctx, run_work.work);
+ */
 static void blk_mq_run_work_fn(struct work_struct *work)
 {
 	struct blk_mq_hw_ctx *hctx;
@@ -2041,6 +2071,14 @@ static blk_qc_t blk_mq_make_request(struct request_queue *q, struct bio *bio)
 	return cookie;
 }
 
+/*
+ * called by:
+ *   - block/blk-mq-sched.c|453| <<blk_mq_sched_free_tags>> blk_mq_free_rqs(set, hctx->sched_tags, hctx_idx);
+ *   - block/blk-mq-sched.c|562| <<blk_mq_sched_free_requests>> blk_mq_free_rqs(q->tag_set, hctx->sched_tags, i);
+ *   - block/blk-mq-tag.c|505| <<blk_mq_tag_update_depth>> blk_mq_free_rqs(set, *tagsptr, hctx->queue_num);
+ *   - block/blk-mq.c|2224| <<blk_mq_alloc_rqs>> blk_mq_free_rqs(set, tags, hctx_idx);
+ *   - block/blk-mq.c|2473| <<blk_mq_free_map_and_requests>> blk_mq_free_rqs(set, set->tags[hctx_idx], hctx_idx);
+ */
 void blk_mq_free_rqs(struct blk_mq_tag_set *set, struct blk_mq_tags *tags,
 		     unsigned int hctx_idx)
 {
@@ -2429,10 +2467,18 @@ static void blk_mq_init_cpu_queues(struct request_queue *q,
 	}
 }
 
+/*
+ * called by:
+ *   - block/blk-mq.c|2488| <<blk_mq_map_swqueue>> !__blk_mq_alloc_rq_map(set, hctx_idx)) {
+ *   - block/blk-mq.c|2955| <<__blk_mq_alloc_rq_maps>> if (!__blk_mq_alloc_rq_map(set, i))
+ */
 static bool __blk_mq_alloc_rq_map(struct blk_mq_tag_set *set, int hctx_idx)
 {
 	int ret = 0;
 
+	/*
+	 * struct blk_mq_tags **tags;
+	 */
 	set->tags[hctx_idx] = blk_mq_alloc_rq_map(set, hctx_idx,
 					set->queue_depth, set->reserved_tags);
 	if (!set->tags[hctx_idx])
@@ -2614,6 +2660,36 @@ static void blk_mq_del_queue_tag_set(struct request_queue *q)
 	INIT_LIST_HEAD(&q->tag_set_list);
 }
 
+/*
+ * virtio_scsi的例子, 调用了好多好多遍, 似乎为每一个target都调用了
+ * [0] blk_mq_add_queue_tag_set
+ * [0] blk_mq_init_allocated_queue
+ * [0] blk_mq_init_queue
+ * [0] scsi_mq_alloc_queue
+ * [0] scsi_alloc_sdev
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - block/blk-mq.c|2941| <<blk_mq_init_allocated_queue>> blk_mq_add_queue_tag_set(set, q);
+ */
 static void blk_mq_add_queue_tag_set(struct blk_mq_tag_set *set,
 				     struct request_queue *q)
 {
@@ -2694,6 +2770,17 @@ void blk_mq_release(struct request_queue *q)
 	blk_mq_sysfs_deinit(q);
 }
 
+/*
+ * 调用的几个例子:
+ *   - drivers/scsi/scsi_lib.c|1832| <<scsi_mq_alloc_queue>> sdev->request_queue = blk_mq_init_queue(&sdev->host->tag_set);
+ *   - drivers/nvme/host/core.c|3253| <<nvme_alloc_ns>> ns->queue = blk_mq_init_queue(ctrl->tagset);
+ *   - drivers/nvme/host/pci.c|1636| <<nvme_alloc_admin_tags>> dev->ctrl.admin_q = blk_mq_init_queue(&dev->admin_tagset);
+ *   - drivers/block/virtio_blk.c|802| <<virtblk_probe>> q = blk_mq_init_queue(&vblk->tag_set);
+ *   - drivers/block/xen-blkfront.c|986| <<xlvbd_init_blk_queue>> rq = blk_mq_init_queue(&info->tag_set);
+ *   - block/blk-mq.c|2813| <<blk_mq_init_sq_queue>> q = blk_mq_init_queue(set);
+ *   - drivers/block/loop.c|2004| <<loop_add>> lo->lo_queue = blk_mq_init_queue(&lo->tag_set);
+ *   - drivers/block/null_blk_main.c|1656| <<null_add_dev>> nullb->q = blk_mq_init_queue(nullb->tag_set);
+ */
 struct request_queue *blk_mq_init_queue(struct blk_mq_tag_set *set)
 {
 	struct request_queue *uninit_q, *q;
diff --git a/block/blk-mq.h b/block/blk-mq.h
index 633a5a7..850fd7d 100644
--- a/block/blk-mq.h
+++ b/block/blk-mq.h
@@ -149,6 +149,15 @@ static inline struct blk_mq_ctx *__blk_mq_get_ctx(struct request_queue *q,
  * care about preemption, since we know the ctx's are persistent. This does
  * mean that we can't rely on ctx always matching the currently running CPU.
  */
+/*
+ * called by:
+ *   - block/blk-mq-sched.c|324| <<__blk_mq_sched_bio_merge>> struct blk_mq_ctx *ctx = blk_mq_get_ctx(q);
+ *   - block/blk-mq-tag.c|172| <<blk_mq_get_tag>> data->ctx = blk_mq_get_ctx(data->q);
+ *   - block/blk-mq.c|363| <<blk_mq_get_request>> data->ctx = blk_mq_get_ctx(q);
+ *   - block/kyber-iosched.c|568| <<kyber_bio_merge>> struct blk_mq_ctx *ctx = blk_mq_get_ctx(hctx->queue);
+ *
+ * 这个函数会通过get_cpu()来disable preemption
+ */
 static inline struct blk_mq_ctx *blk_mq_get_ctx(struct request_queue *q)
 {
 	return __blk_mq_get_ctx(q, get_cpu());
diff --git a/block/blk-timeout.c b/block/blk-timeout.c
index 8aa68fa..f13f6f5 100644
--- a/block/blk-timeout.c
+++ b/block/blk-timeout.c
@@ -78,6 +78,15 @@ ssize_t part_timeout_store(struct device *dev, struct device_attribute *attr,
  * LLDDs who implement their own error recovery MAY ignore the timeout
  * event if they generated blk_abort_request.
  */
+/*
+ * called by:
+ *   - drivers/ata/libata-eh.c|916| <<ata_qc_schedule_eh>> blk_abort_request(qc->scsicmd->request);
+ *   - drivers/block/mtip32xx/mtip32xx.c|2618| <<mtip_queue_cmd>> blk_abort_request(req);
+ *   - drivers/s390/block/dasd_ioctl.c|168| <<dasd_ioctl_abortio>> blk_abort_request(cqr->callback_data);
+ *   - drivers/scsi/libsas/sas_ata.c|588| <<sas_ata_task_abort>> blk_abort_request(qc->scsicmd->request);
+ *   - drivers/scsi/libsas/sas_scsi_host.c|912| <<sas_task_abort>> blk_abort_request(sc->request);
+ *   - drivers/scsi/scsi_debug.c|4390| <<schedule_resp>> blk_abort_request(cmnd->request);
+ */
 void blk_abort_request(struct request *req)
 {
 	/*
@@ -90,6 +99,10 @@ void blk_abort_request(struct request *req)
 }
 EXPORT_SYMBOL_GPL(blk_abort_request);
 
+/*
+ * called by:
+ *   - block/blk-timeout.c|134| <<blk_add_timer>> expiry = blk_rq_timeout(round_jiffies_up(expiry));
+ */
 unsigned long blk_rq_timeout(unsigned long timeout)
 {
 	unsigned long maxt;
@@ -109,6 +122,11 @@ unsigned long blk_rq_timeout(unsigned long timeout)
  *    Each request has its own timer, and as it is added to the queue, we
  *    set up the timer. When the request completes, we cancel the timer.
  */
+/*
+ * called by:
+ *   - block/blk-mq.c|691| <<blk_mq_start_request>> blk_add_timer(rq);
+ *   - block/blk-mq.c|863| <<blk_mq_rq_timed_out>> blk_add_timer(req);
+ */
 void blk_add_timer(struct request *req)
 {
 	struct request_queue *q = req->q;
diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c
index 524d6bd..db63737 100644
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@ -2464,6 +2464,10 @@ static void nvme_pci_free_ctrl(struct nvme_ctrl *ctrl)
 	kfree(dev);
 }
 
+/*
+ * called by only:
+ *   - drivers/nvme/host/pci.c|2600| <<nvme_reset_work>> nvme_remove_dead_ctrl(dev, result);
+ */
 static void nvme_remove_dead_ctrl(struct nvme_dev *dev, int status)
 {
 	dev_warn(dev->ctrl.device, "Removing after probe failure status: %d\n", status);
diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index ff0d8c6..41c1483 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -204,6 +204,32 @@ EXPORT_SYMBOL(scsi_remove_host);
  * Return value: 
  * 	0 on success / != 0 for error
  **/
+/*
+ * [0] scsi_add_host_with_dma
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/ata/libata-scsi.c|4535| <<ata_scsi_add_hosts>> rc = scsi_add_host_with_dma(ap->scsi_host,
+ *   - drivers/firewire/sbp2.c|1150| <<sbp2_probe>> if (scsi_add_host_with_dma(shost, &unit->device,
+ *   - drivers/scsi/bfa/bfad_im.c|571| <<bfad_im_scsi_host_alloc>> error = scsi_add_host_with_dma(im_port->shost, dev, &bfad->pcidev->dev);
+ *   - drivers/scsi/csiostor/csio_init.c|647| <<csio_shost_init>> if (scsi_add_host_with_dma(shost, dev, &hw->pdev->dev))
+ *   - drivers/scsi/lpfc/lpfc_init.c|4350| <<lpfc_create_port>> error = scsi_add_host_with_dma(shost, dev, &phba->pcidev->dev);
+ *   - drivers/scsi/qla2xxx/qla_attr.c|2855| <<qla24xx_vport_create>> if (scsi_add_host_with_dma(vha->host, &fc_vport->dev,
+ *   - include/scsi/scsi_host.h|738| <<scsi_add_host>> return scsi_add_host_with_dma(host, dev, dev);
+ */
 int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 			   struct device *dma_dev)
 {
@@ -365,6 +391,9 @@ static struct device_type scsi_host_type = {
  * Return value:
  * 	Pointer to a new Scsi_Host
  **/
+/*
+ * 会把分配的Scsi_Host->hostt设置为参数的struct scsi_host_template
+ */
 struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 {
 	struct Scsi_Host *shost;
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 7bedbe8..83a1c05 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -823,6 +823,12 @@ iscsi_sw_tcp_conn_get_stats(struct iscsi_cls_conn *cls_conn,
 	iscsi_tcp_conn_get_stats(cls_conn, stats);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_transport_iscsi.c|2699| <<iscsi_if_create_session>> session = transport->create_session(ep, cmds_max, queue_depth,
+ *
+ * struct iscsi_transport iscsi_sw_tcp_transport.create_session = iscsi_sw_tcp_session_create()
+ */
 static struct iscsi_cls_session *
 iscsi_sw_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,
 			    uint16_t qdepth, uint32_t initial_cmdsn)
@@ -956,6 +962,10 @@ static int iscsi_sw_tcp_slave_configure(struct scsi_device *sdev)
 	return 0;
 }
 
+/*
+ * used only by:
+ *   - drivers/scsi/iscsi_tcp.c|840| <<iscsi_sw_tcp_session_create>> shost = iscsi_host_alloc(&iscsi_sw_tcp_sht,
+ */
 static struct scsi_host_template iscsi_sw_tcp_sht = {
 	.module			= THIS_MODULE,
 	.name			= "iSCSI Initiator over TCP/IP",
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 65d0a10..5934f02 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -1166,6 +1166,10 @@ static blk_status_t scsi_setup_scsi_cmnd(struct scsi_device *sdev,
  * Setup a normal block command.  These are simple request from filesystems
  * that still need to be translated to SCSI CDBs from the ULD.
  */
+/*
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1200| <<scsi_setup_cmnd>> return scsi_setup_fs_cmnd(sdev, req);
+ */
 static blk_status_t scsi_setup_fs_cmnd(struct scsi_device *sdev,
 		struct request *req)
 {
@@ -1699,6 +1703,13 @@ static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
 	return ret;
 }
 
+/*
+ * called by:
+ *   - block/blk-mq.c|853| <<blk_mq_rq_timed_out>> ret = req->q->mq_ops->timeout(req, reserved);
+ *
+ * 只在以下使用:
+ *   - struct blk_mq_ops scsi_mq_ops.timeout = scsi_timeout
+ */
 static enum blk_eh_timer_return scsi_timeout(struct request *req,
 		bool reserved)
 {
@@ -1788,6 +1799,11 @@ void __scsi_init_queue(struct Scsi_Host *shost, struct request_queue *q)
 }
 EXPORT_SYMBOL_GPL(__scsi_init_queue);
 
+/*
+ * used by:
+ *   - drivers/scsi/scsi_lib.c|1836| <<scsi_mq_setup_tags>> shost->tag_set.ops = &scsi_mq_ops;
+ *   - drivers/scsi/scsi_lib.c|1865| <<scsi_device_from_queue>> if (q->mq_ops == &scsi_mq_ops)
+ */
 static const struct blk_mq_ops scsi_mq_ops = {
 	.get_budget	= scsi_mq_get_budget,
 	.put_budget	= scsi_mq_put_budget,
@@ -1804,8 +1820,37 @@ static const struct blk_mq_ops scsi_mq_ops = {
 	.map_queues	= scsi_map_queues,
 };
 
+/*
+ * [0] scsi_mq_alloc_queue
+ * [0] scsi_alloc_sdev
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver   
+ * [0] driver_register  
+ * [0] init
+ * [0] do_one_initcall  
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|269| <<scsi_alloc_sdev>> sdev->request_queue = scsi_mq_alloc_queue(sdev);
+ */
 struct request_queue *scsi_mq_alloc_queue(struct scsi_device *sdev)
 {
+	/*
+	 * 每个struct scsi_devic一个request_queue
+	 */
 	sdev->request_queue = blk_mq_init_queue(&sdev->host->tag_set);
 	if (IS_ERR(sdev->request_queue))
 		return NULL;
@@ -1816,6 +1861,10 @@ struct request_queue *scsi_mq_alloc_queue(struct scsi_device *sdev)
 	return sdev->request_queue;
 }
 
+/*
+ * called by:
+ *   - rivers/scsi/hosts.c|226| <<scsi_add_host_with_dma>> error = scsi_mq_setup_tags(shost);
+ */
 int scsi_mq_setup_tags(struct Scsi_Host *shost)
 {
 	unsigned int cmd_size, sgl_size;
diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 058079f..fe14ad0 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -212,6 +212,37 @@ static void scsi_unlock_floptical(struct scsi_device *sdev,
  * Return value:
  *     scsi_Device pointer, or NULL on failure.
  **/
+/*
+ * [0] scsi_alloc_sdev
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1078| <<scsi_probe_and_add_lun>> sdev = scsi_alloc_sdev(starget, lun, hostdata);
+ *   - drivers/scsi/scsi_scan.c|1324| <<scsi_report_lun_scan>> sdev = scsi_alloc_sdev(starget, 0, NULL);
+ *   - drivers/scsi/scsi_scan.c|1911| <<scsi_get_host_dev>> sdev = scsi_alloc_sdev(starget, 0, NULL);
+ *
+ * 在测试的时候用了一个virtio_scsi的host上的两个lun (相同channel和target)
+ * 发现这个函数被host=0, channel=0为0-255个target都在调用
+ * 其中channel=0调用2次, 因为有2个lun
+ */
 static struct scsi_device *scsi_alloc_sdev(struct scsi_target *starget,
 					   u64 lun, void *hostdata)
 {
@@ -280,6 +311,9 @@ static struct scsi_device *scsi_alloc_sdev(struct scsi_target *starget,
 	scsi_change_queue_depth(sdev, sdev->host->cmd_per_lun ?
 					sdev->host->cmd_per_lun : 1);
 
+	/*
+	 * 为scsi_device->sdev_gendev.bus设置为&scsi_bus_type
+	 */
 	scsi_sysfs_device_initialize(sdev);
 
 	if (shost->hostt->slave_alloc) {
@@ -407,6 +441,34 @@ static void scsi_target_reap_ref_put(struct scsi_target *starget)
  * The target is returned with an incremented reference, so the caller
  * is responsible for both reaping and doing a last put
  */
+/*
+ * 测试的时候用了2个lun, 在同一个host,channel,target上
+ * 结果在channel=0上为256个target各调用一次
+ * [0] scsi_alloc_target
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1512| <<__scsi_add_device>> starget = scsi_alloc_target(parent, channel, id);
+ *   - drivers/scsi/scsi_scan.c|1593| <<__scsi_scan_target>> starget = scsi_alloc_target(parent, channel, id);
+ *   - drivers/scsi/scsi_scan.c|1960| <<scsi_get_host_dev>> starget = scsi_alloc_target(&shost->shost_gendev, 0, shost->this_id);
+ */
 static struct scsi_target *scsi_alloc_target(struct device *parent,
 					     int channel, uint id)
 {
@@ -1040,6 +1102,34 @@ static unsigned char *scsi_inq_str(unsigned char *buf, unsigned char *inq,
  *         attached at the LUN
  *   - SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized
  **/
+/*
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1269| <<scsi_sequential_lun_scan>> if ((scsi_probe_and_add_lun(starget, lun, NULL, NULL, rescan,
+ *   - drivers/scsi/scsi_scan.c|1439| <<scsi_report_lun_scan>> res = scsi_probe_and_add_lun(starget,
+ *   - drivers/scsi/scsi_scan.c|1486| <<__scsi_add_device>> scsi_probe_and_add_lun(starget, lun, NULL, &sdev, 1, hostdata);
+ *   - drivers/scsi/scsi_scan.c|1566| <<__scsi_scan_target>> scsi_probe_and_add_lun(starget, lun, NULL, NULL, rescan, NULL);
+ *   - drivers/scsi/scsi_scan.c|1574| <<__scsi_scan_target>> res = scsi_probe_and_add_lun(starget, 0, &bflags, NULL, rescan, NULL);
+ */
 static int scsi_probe_and_add_lun(struct scsi_target *starget,
 				  u64 lun, blist_flags_t *bflagsp,
 				  struct scsi_device **sdevp,
@@ -1194,6 +1284,12 @@ static int scsi_probe_and_add_lun(struct scsi_target *starget,
  *
  *     Modifies sdevscan->lun.
  **/
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1617| <<__scsi_scan_target>> scsi_sequential_lun_scan(starget, bflags,
+ *
+ * 在virtio_scsi上2个lun的情况下没调用
+ */
 static void scsi_sequential_lun_scan(struct scsi_target *starget,
 				     blist_flags_t bflags, int scsi_level,
 				     enum scsi_scan_mode rescan)
@@ -1528,6 +1624,12 @@ void scsi_rescan_device(struct device *dev)
 }
 EXPORT_SYMBOL(scsi_rescan_device);
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1619| <<scsi_scan_target>> __scsi_scan_target(parent, channel, id, lun, rescan);
+ *   - drivers/scsi/scsi_scan.c|1650| <<scsi_scan_channel>> __scsi_scan_target(&shost->shost_gendev, channel,
+ *   - drivers/scsi/scsi_scan.c|1654| <<scsi_scan_channel>> __scsi_scan_target(&shost->shost_gendev, channel,
+ */
 static void __scsi_scan_target(struct device *parent, unsigned int channel,
 		unsigned int id, u64 lun, enum scsi_scan_mode rescan)
 {
@@ -1623,6 +1725,11 @@ void scsi_scan_target(struct device *parent, unsigned int channel,
 }
 EXPORT_SYMBOL(scsi_scan_target);
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1679| <<scsi_scan_host_selected>> scsi_scan_channel(shost, channel, id, lun,
+ *   - drivers/scsi/scsi_scan.c|1682| <<scsi_scan_host_selected>> scsi_scan_channel(shost, channel, id, lun, rescan);
+ */
 static void scsi_scan_channel(struct Scsi_Host *shost, unsigned int channel,
 			      unsigned int id, u64 lun,
 			      enum scsi_scan_mode rescan)
@@ -1655,6 +1762,12 @@ static void scsi_scan_channel(struct Scsi_Host *shost, unsigned int channel,
 				id, lun, rescan);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_proc.c|255| <<scsi_add_single_device>> error = scsi_scan_host_selected(shost, channel, id, lun,
+ *   - drivers/scsi/scsi_scan.c|1924| <<do_scsi_scan_host>> scsi_scan_host_selected(shost, SCAN_WILD_CARD, SCAN_WILD_CARD,
+ *   - drivers/scsi/scsi_sysfs.c|150| <<scsi_scan>> res = scsi_scan_host_selected(shost, channel, id, lun,
+ */
 int scsi_scan_host_selected(struct Scsi_Host *shost, unsigned int channel,
 			    unsigned int id, u64 lun,
 			    enum scsi_scan_mode rescan)
@@ -1819,6 +1932,10 @@ static void do_scsi_scan_host(struct Scsi_Host *shost)
 	}
 }
 
+/*
+ * used only by:
+ *   - drivers/scsi/scsi_scan.c|1855| <<scsi_scan_host>> async_schedule(do_scan_async, data);
+ */
 static void do_scan_async(void *_data, async_cookie_t c)
 {
 	struct async_scan_data *data = _data;
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index dbb206c..c308dd1 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -522,6 +522,17 @@ static int scsi_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
+/*
+ * used by:
+ *   - drivers/scsi/hosts.c|496| <<scsi_host_alloc>> shost->shost_gendev.bus = &scsi_bus_type;
+ *   - drivers/scsi/scsi_proc.c|382| <<next_scsi_device>> struct device *next = bus_find_device(&scsi_bus_type, start, NULL,
+ *   - drivers/scsi/scsi_scan.c|463| <<scsi_alloc_target>> dev->bus = &scsi_bus_type;
+ *   - drivers/scsi/scsi_sysfs.c|539| <<scsi_sysfs_register>> error = bus_register(&scsi_bus_type);
+ *   - drivers/scsi/scsi_sysfs.c|543| <<scsi_sysfs_register>> bus_unregister(&scsi_bus_type);
+ *   - drivers/scsi/scsi_sysfs.c|552| <<scsi_sysfs_unregister>> bus_unregister(&scsi_bus_type);
+ *   - drivers/scsi/scsi_sysfs.c|1508| <<scsi_register_driver>> drv->bus = &scsi_bus_type;
+ *   - drivers/scsi/scsi_sysfs.c|1558| <<scsi_sysfs_device_initialize>> sdev->sdev_gendev.bus = &scsi_bus_type;
+ */
 struct bus_type scsi_bus_type = {
         .name		= "scsi",
         .match		= scsi_bus_match,
@@ -1503,6 +1514,15 @@ void scsi_remove_target(struct device *dev)
 }
 EXPORT_SYMBOL(scsi_remove_target);
 
+/*
+ * called by:
+ *   - drivers/scsi/ch.c|1021| <<init_ch_module>> rc = scsi_register_driver(&ch_template.gendrv);
+ *   - drivers/scsi/osst.c|6061| <<init_osst>> err = scsi_register_driver(&osst_template.gendrv);
+ *   - drivers/scsi/sd.c|3729| <<init_sd>> err = scsi_register_driver(&sd_template.gendrv);
+ *   - drivers/scsi/ses.c|860| <<ses_init>> err = scsi_register_driver(&ses_template.gendrv);
+ *   - drivers/scsi/sr.c|1039| <<init_sr>> rc = scsi_register_driver(&sr_template.gendrv);
+ *   - drivers/scsi/st.c|4509| <<init_st>> err = scsi_register_driver(&st_template.gendrv);
+ */
 int scsi_register_driver(struct device_driver *drv)
 {
 	drv->bus = &scsi_bus_type;
@@ -1548,6 +1568,12 @@ static struct device_type scsi_dev_type = {
 	.groups =	scsi_sdev_attr_groups,
 };
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|314| <<scsi_alloc_sdev>> scsi_sysfs_device_initialize(sdev);
+ *
+ * 为scsi_device->sdev_gendev.bus设置为&scsi_bus_type
+ */
 void scsi_sysfs_device_initialize(struct scsi_device *sdev)
 {
 	unsigned long flags;
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 417b868..cdd3a42 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -2686,6 +2686,11 @@ int iscsi_session_event(struct iscsi_cls_session *session,
 }
 EXPORT_SYMBOL_GPL(iscsi_session_event);
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_transport_iscsi.c|3504| <<iscsi_if_recv_msg>> err = iscsi_if_create_session(priv, ep, ev,
+ *   - drivers/scsi/scsi_transport_iscsi.c|3517| <<iscsi_if_recv_msg>> err = iscsi_if_create_session(priv, ep, ev,
+ */
 static int
 iscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_endpoint *ep,
 			struct iscsi_uevent *ev, pid_t pid,
@@ -3472,6 +3477,10 @@ iscsi_get_host_stats(struct iscsi_transport *transport, struct nlmsghdr *nlh)
 }
 
 
+/*
+ * called by only:
+ *   - drivers/scsi/scsi_transport_iscsi.c|3697| <<iscsi_if_rx>> err = iscsi_if_recv_msg(skb, nlh, &group);
+ */
 static int
 iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, uint32_t *group)
 {
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index a3406bd..178bd9e 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -563,7 +563,20 @@ static const struct dev_pm_ops sd_pm_ops = {
 	.runtime_resume		= sd_resume,
 };
 
+/*
+ * used by:
+ *   - drivers/scsi/sd.c|3381| <<sd_probe>> sdkp->driver = &sd_template;
+ *   - drivers/scsi/sd.c|3677| <<init_sd>> err = scsi_register_driver(&sd_template.gendrv);
+ *   - drivers/scsi/sd.c|3711| <<exit_sd>> scsi_unregister_driver(&sd_template.gendrv);
+ */
 static struct scsi_driver sd_template = {
+	/*
+	 * used by:
+	 *   - drivers/scsi/sd.c|3677| <<init_sd>> err = scsi_register_driver(&sd_template.gendrv);
+	 *   - drivers/scsi/sd.c|3711| <<exit_sd>> scsi_unregister_driver(&sd_template.gendrv);
+	 *
+	 * 这个struct device_driver被挂在struct bus_type scsi_bus_type
+	 */
 	.gendrv = {
 		.name		= "sd",
 		.owner		= THIS_MODULE,
@@ -572,6 +585,10 @@ static struct scsi_driver sd_template = {
 		.shutdown	= sd_shutdown,
 		.pm		= &sd_pm_ops,
 	},
+	/*
+	 * called by:
+	 *   - drivers/scsi/scsi_scan.c|1524| <<scsi_rescan_device>> drv->rescan(dev);
+	 */
 	.rescan			= sd_rescan,
 	.init_command		= sd_init_command,
 	.uninit_command		= sd_uninit_command,
@@ -1802,6 +1819,10 @@ static const struct pr_ops sd_pr_ops = {
 	.pr_clear	= sd_pr_clear,
 };
 
+/*
+ * used by only:
+ *   - drivers/scsi/sd.c|3295| <<sd_probe_async>> gd->fops = &sd_fops;
+ */
 static const struct block_device_operations sd_fops = {
 	.owner			= THIS_MODULE,
 	.open			= sd_open,
@@ -3255,6 +3276,10 @@ static int sd_format_disk_name(char *prefix, int index, char *buf, int buflen)
 /*
  * The asynchronous part of sd_probe
  */
+/*
+ * called by only:
+ *   - drivers/scsi/sd.c|3408| <<sd_probe>> async_schedule_domain(sd_probe_async, sdkp, &scsi_sd_probe_domain);
+ */
 static void sd_probe_async(void *data, async_cookie_t cookie)
 {
 	struct scsi_disk *sdkp = data;
@@ -3264,6 +3289,7 @@ static void sd_probe_async(void *data, async_cookie_t cookie)
 	struct device *dev;
 
 	sdp = sdkp->device;
+	/* struct gendisk  *disk */
 	gd = sdkp->disk;
 	index = sdkp->index;
 	dev = &sdp->sdev_gendev;
@@ -3273,6 +3299,9 @@ static void sd_probe_async(void *data, async_cookie_t cookie)
 
 	gd->fops = &sd_fops;
 	gd->private_data = &sdkp->driver;
+	/*
+	 * sdkp->device是struct scsi_device
+	 */
 	gd->queue = sdkp->device->request_queue;
 
 	/* defaults, until the device tells us otherwise */
@@ -3309,6 +3338,10 @@ static void sd_probe_async(void *data, async_cookie_t cookie)
 			sd_printk(KERN_NOTICE, sdkp, "supports TCG Opal\n");
 	}
 
+	/*
+	 * [    0.341475] sd 0:0:0:0: [sda] Attached SCSI disk
+	 * [    0.346937] sd 0:0:0:1: [sdb] Attached SCSI disk
+	 */
 	sd_printk(KERN_NOTICE, sdkp, "Attached SCSI %sdisk\n",
 		  sdp->removable ? "removable " : "");
 	scsi_autopm_put_device(sdp);
@@ -3333,6 +3366,21 @@ static void sd_probe_async(void *data, async_cookie_t cookie)
  *	Assume sd_probe is not re-entrant (for time being)
  *	Also think about sd_probe() and sd_remove() running coincidentally.
  **/
+/*
+ * [0] sd_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init_sd
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ */
 static int sd_probe(struct device *dev)
 {
 	struct scsi_device *sdp = to_scsi_device(dev);
@@ -3361,6 +3409,7 @@ static int sd_probe(struct device *dev)
 	if (!sdkp)
 		goto out;
 
+	/* 分配gendisk? */
 	gd = alloc_disk(SD_MINORS);
 	if (!gd)
 		goto out_free;
@@ -3395,6 +3444,9 @@ static int sd_probe(struct device *dev)
 	device_initialize(&sdkp->dev);
 	sdkp->dev.parent = dev;
 	sdkp->dev.class = &sd_disk_class;
+	/*
+	 * 在virtio_scsi上的dev_name(dev)例子是"0:0:0:0", "0:0:0:1"
+	 */
 	dev_set_name(&sdkp->dev, "%s", dev_name(dev));
 
 	error = device_add(&sdkp->dev);
diff --git a/drivers/scsi/virtio_scsi.c b/drivers/scsi/virtio_scsi.c
index 13f1b3b..e8a5660 100644
--- a/drivers/scsi/virtio_scsi.c
+++ b/drivers/scsi/virtio_scsi.c
@@ -30,6 +30,62 @@
 #include <linux/seqlock.h>
 #include <linux/blk-mq-virtio.h>
 
+/*
+ * virtio_scsi初始化
+ *
+ * virtscsi_probe()
+ *   -> scsi_add_host()
+ *   -> scsi_scan_host()
+ *
+ * scan host的时候会为每一个lun分配一个struct scsi_device
+ * 还有request_queue, 链接入tagset的tag_set_list
+ * 然后add device
+ *
+ * scsi定义了一条scsi busi_type: scsi_bus_type in drivers/scsi/scsi_sysfs.c
+ *
+ * 上面add的device会被sd的sd_probe()初始化
+ * 在sd_probe()分配gendisk和scsi_disk
+ */
+
+/*
+ * virtio_scsi的timeout的例子
+ *
+ * blk_mq_init_queue()
+ *  -> blk_alloc_queue_node
+ *      -> timer_setup(&q->timeout, blk_rq_timed_out_timer, 0);
+ *      -> INIT_WORK(&q->timeout_work, blk_timeout_work);
+ *  -> blk_mq_init_allocated_queue()
+ *      -> INIT_WORK(&q->timeout_work, blk_mq_timeout_work);
+ *
+ * 最终, q->timeout的timer是blk_rq_timed_out_timer()
+ * q->timeout_work是blk_mq_timeout_work()
+ *
+ * timer的blk_rq_timed_out_timer()会调用q->timeout_work=blk_mq_timeout_work()
+ *
+ * 每开始一个request, 都要调用blk_mq_start_request()
+ *
+ * scsi_queue_rq()
+ *  -> blk_mq_start_request(request)
+ *
+ * blk_mq_start_request()
+ *  -> blk_add_timer()
+ *      -> 根据情况mod_timer
+ *
+ * 是一个request_queue一个timer, 不是一个request一个timer
+ *
+ * 如果timer被触发了:
+ *
+ * blk_rq_timed_out_timer()
+ *  -> 调用q->timeout_work = blk_mq_timeout_work()
+ *      -> 为每一个inflight request调用blk_mq_check_expired()
+ *          -> expire了就调用blk_mq_rq_timed_out()
+ *              -> req->q->mq_ops->timeout = scsi_timeout()
+ *                  -> scsi_times_out()
+ *                      -> host->hostt->eh_timed_out = virtscsi_eh_timed_out()
+ *
+ * virtscsi_eh_timed_out()直接返回BLK_EH_RESET_TIMER
+ */
+
 #define VIRTIO_SCSI_MEMPOOL_SZ 64
 #define VIRTIO_SCSI_EVENT_LEN 8
 #define VIRTIO_SCSI_VQ_BASE 2
@@ -379,6 +435,10 @@ static void virtscsi_event_done(struct virtqueue *vq)
  * @req_size	: size of the request buffer
  * @resp_size	: size of the response buffer
  */
+/*
+ * called by only:
+ *   - drivers/scsi/virtio_scsi.c|436| <<virtscsi_kick_cmd>> err = virtscsi_add_cmd(vq->vq, cmd, req_size, resp_size);
+ */
 static int virtscsi_add_cmd(struct virtqueue *vq,
 			    struct virtio_scsi_cmd *cmd,
 			    size_t req_size, size_t resp_size)
@@ -424,6 +484,11 @@ static int virtscsi_add_cmd(struct virtqueue *vq,
 	return virtqueue_add_sgs(vq, sgs, out_num, in_num, cmd, GFP_ATOMIC);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|531| <<virtscsi_queuecommand>> ret = virtscsi_kick_cmd(req_vq, cmd, req_size, sizeof(cmd->resp.cmd));
+ *   - drivers/scsi/virtio_scsi.c|549| <<virtscsi_tmf>> if (virtscsi_kick_cmd(&vscsi->ctrl_vq, cmd,
+ */
 static int virtscsi_kick_cmd(struct virtio_scsi_vq *vq,
 			     struct virtio_scsi_cmd *cmd,
 			     size_t req_size, size_t resp_size)
@@ -671,6 +736,10 @@ static enum blk_eh_timer_return virtscsi_eh_timed_out(struct scsi_cmnd *scmnd)
 	return BLK_EH_RESET_TIMER;
 }
 
+/*
+ * used by only:
+ *   - drivers/scsi/virtio_scsi.c|806| <<virtscsi_probe>> shost = scsi_host_alloc(&virtscsi_host_template,
+ */
 static struct scsi_host_template virtscsi_host_template = {
 	.module = THIS_MODULE,
 	.name = "Virtio SCSI HBA",
@@ -773,6 +842,12 @@ static int virtscsi_init(struct virtio_device *vdev,
 	return err;
 }
 
+/*
+ * 初始化一个scsi的大概流程:
+ * 1. scsi_host_alloc()
+ * 2. scsi_add_host()
+ * 3. scsi_scan_host()
+ */
 static int virtscsi_probe(struct virtio_device *vdev)
 {
 	struct Scsi_Host *shost;
@@ -794,6 +869,9 @@ static int virtscsi_probe(struct virtio_device *vdev)
 
 	num_targets = virtscsi_config_get(vdev, max_target) + 1;
 
+	/*
+	 * 会把分配的Scsi_Host->hostt设置为参数的struct scsi_host_template
+	 */
 	shost = scsi_host_alloc(&virtscsi_host_template,
 		sizeof(*vscsi) + sizeof(vscsi->req_vqs[0]) * num_queues);
 	if (!shost)
@@ -847,6 +925,38 @@ static int virtscsi_probe(struct virtio_device *vdev)
 	if (virtio_has_feature(vdev, VIRTIO_SCSI_F_HOTPLUG))
 		virtscsi_kick_event_all(vscsi);
 
+	/*
+	 * 在测试的时候用了一个virtio_scsi的host上的两个lun (相同channel和target)
+	 * 发现这个函数被host=0, channel=0为0-255个target都在调用
+	 * 其中channel=0调用2次, 因为有2个lun
+	 *
+	 * [0] blk_mq_add_queue_tag_set
+	 * [0] blk_mq_init_allocated_queue
+	 * [0] blk_mq_init_queue
+	 * [0] scsi_mq_alloc_queue
+	 * [0] scsi_alloc_sdev
+	 * [0] scsi_probe_and_add_lun
+	 * [0] __scsi_scan_target
+	 * [0] scsi_scan_channel
+	 * [0] scsi_scan_host_selected
+	 * [0] scsi_scan_host
+	 * [0] virtscsi_probe
+	 * [0] virtio_dev_probe
+	 * [0] really_probe
+	 * [0] driver_probe_device
+	 * [0] device_driver_attach
+	 * [0] __driver_attach
+	 * [0] bus_for_each_dev
+	 * [0] bus_add_driver
+	 * [0] driver_register
+	 * [0] init
+	 * [0] do_one_initcall
+	 * [0] kernel_init_freeable 
+	 * [0] kernel_init
+	 * [0] ret_from_fork
+	 *
+	 * gendisk在sd_probe()分配
+	 */
 	scsi_scan_host(shost);
 	return 0;
 
diff --git a/include/linux/blk-mq.h b/include/linux/blk-mq.h
index 15d1aa5..144d148 100644
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@ -112,6 +112,10 @@ struct blk_mq_tag_set {
 	struct blk_mq_tags	**tags;
 
 	struct mutex		tag_list_lock;
+	/*
+	 * 在以下添加:
+	 *   - block/blk-mq.c|2659| <<blk_mq_add_queue_tag_set>> list_add_tail_rcu(&q->tag_set_list, &set->tag_list);
+	 */
 	struct list_head	tag_list;
 };
 
@@ -218,12 +222,38 @@ struct blk_mq_ops {
 
 enum {
 	BLK_MQ_F_SHOULD_MERGE	= 1 << 0,
+	/*
+	 * 在以下设置或者清除BLK_MQ_F_TAG_SHARED:
+	 *   - block/blk-mq.c|2581| <<queue_set_hctx_shared>> hctx->flags |= BLK_MQ_F_TAG_SHARED;
+	 *   - block/blk-mq.c|2627| <<blk_mq_add_queue_tag_set>> set->flags |= BLK_MQ_F_TAG_SHARED;
+	 *   - block/blk-mq.c|2357| <<blk_mq_alloc_hctx>> hctx->flags = set->flags & ~BLK_MQ_F_TAG_SHARED;
+	 *   - block/blk-mq.c|2583| <<queue_set_hctx_shared>> hctx->flags &= ~BLK_MQ_F_TAG_SHARED;
+	 *   - block/blk-mq.c|2609| <<blk_mq_del_queue_tag_set>> set->flags &= ~BLK_MQ_F_TAG_SHARED;
+	 *
+	 * 在以下使用BLK_MQ_F_TAG_SHARED:
+	 *   - block/blk-mq-tag.c|75| <<hctx_may_queue>> if (!hctx || !(hctx->flags & BLK_MQ_F_TAG_SHARED))
+	 *   - block/blk-mq-tag.h|58| <<blk_mq_tag_busy>> if (!(hctx->flags & BLK_MQ_F_TAG_SHARED))
+	 *   - block/blk-mq-tag.h|66| <<blk_mq_tag_idle>> if (!(hctx->flags & BLK_MQ_F_TAG_SHARED))
+	 *   - block/blk-mq.c|304| <<blk_mq_rq_ctx_init>> if (data->hctx->flags & BLK_MQ_F_TAG_SHARED) {
+	 *   - block/blk-mq.c|1111| <<blk_mq_mark_tag_wait>> if (!(hctx->flags & BLK_MQ_F_TAG_SHARED)) {
+	 *   - block/blk-mq.c|1242| <<blk_mq_dispatch_rq_list>> if (hctx->flags & BLK_MQ_F_TAG_SHARED)
+	 *   - block/blk-mq.c|2626| <<blk_mq_add_queue_tag_set>> !(set->flags & BLK_MQ_F_TAG_SHARED)) {
+	 *   - block/blk-mq.c|2631| <<blk_mq_add_queue_tag_set>> if (set->flags & BLK_MQ_F_TAG_SHARED)
+	 */
 	BLK_MQ_F_TAG_SHARED	= 1 << 1,
 	BLK_MQ_F_BLOCKING	= 1 << 5,
 	BLK_MQ_F_NO_SCHED	= 1 << 6,
 	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
 	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
 
+	/*
+	 * 在以下使用:
+	 *   - block/blk-mq.c|1553| <<blk_mq_stop_hw_queue>> set_bit(BLK_MQ_S_STOPPED, &hctx->state);
+	 *   - block/blk-mq.c|1578| <<blk_mq_start_hw_queue>> clear_bit(BLK_MQ_S_STOPPED, &hctx->state);
+	 *   - block/blk-mq.c|1599| <<blk_mq_start_stopped_hw_queue>> clear_bit(BLK_MQ_S_STOPPED, &hctx->state);
+	 *   - block/blk-mq.c|1623| <<blk_mq_run_work_fn>> if (test_bit(BLK_MQ_S_STOPPED, &hctx->state))
+	 *   - block/blk-mq.h|184| <<blk_mq_hctx_stopped>> return test_bit(BLK_MQ_S_STOPPED, &hctx->state);
+	 */
 	BLK_MQ_S_STOPPED	= 0,
 	BLK_MQ_S_TAG_ACTIVE	= 1,
 	BLK_MQ_S_SCHED_RESTART	= 2,
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 592669b..496c82e 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -479,7 +479,27 @@ struct request_queue {
 	struct blk_stat_callback	*poll_cb;
 	struct blk_rq_stat	poll_stat[BLK_MQ_POLL_STATS_BKTS];
 
+	/*
+	 * q->timeout在以下使用:
+	 *   - block/blk-core.c|234| <<blk_sync_queue>> del_timer_sync(&q->timeout);
+	 *   - block/blk-core.c|491| <<blk_alloc_queue_node>> timer_setup(&q->timeout, blk_rq_timed_out_timer, 0);
+	 *   - block/blk-mq.c|967| <<blk_mq_timeout_work>> mod_timer(&q->timeout, next);
+	 *   - block/blk-timeout.c|154| <<blk_add_timer>> if (!timer_pending(&q->timeout) ||
+	 *   - block/blk-timeout.c|155| <<blk_add_timer>> time_before(expiry, q->timeout.expires)) {
+	 *   - block/blk-timeout.c|156| <<blk_add_timer>> unsigned long diff = q->timeout.expires - expiry; 
+	 *   - block/blk-timeout.c|165| <<blk_add_timer>> if (!timer_pending(&q->timeout) || (diff >= HZ / 2))
+	 *   - block/blk-timeout.c|166| <<blk_add_timer>> mod_timer(&q->timeout, expiry);
+	 */
 	struct timer_list	timeout;
+	/*
+	 * timeout_work在以下使用:
+	 *   - block/blk-core.c|235| <<blk_sync_queue>> cancel_work_sync(&q->timeout_work);
+	 *   - block/blk-core.c|418| <<blk_rq_timed_out_timer>> kblockd_schedule_work(&q->timeout_work);
+	 *   - block/blk-core.c|467| <<blk_alloc_queue_node>> INIT_WORK(&q->timeout_work, blk_timeout_work);
+	 *   - block/blk-mq.c|923| <<blk_mq_timeout_work>> container_of(work, struct request_queue, timeout_work);
+	 *   - block/blk-mq.c|2942| <<blk_mq_init_allocated_queue>> INIT_WORK(&q->timeout_work, blk_mq_timeout_work);
+	 *   - block/blk-timeout.c|89| <<blk_abort_request>> kblockd_schedule_work(&req->q->timeout_work);
+	 */
 	struct work_struct	timeout_work;
 
 	struct list_head	icq_list;
diff --git a/include/linux/dma-mapping.h b/include/linux/dma-mapping.h
index 6309a72..a5c3d48 100644
--- a/include/linux/dma-mapping.h
+++ b/include/linux/dma-mapping.h
@@ -697,6 +697,13 @@ static inline void arch_teardown_dma_ops(struct device *dev)
 }
 #endif /* CONFIG_ARCH_HAS_TEARDOWN_DMA_OPS */
 
+/*
+ * x86下调用的几个例子:
+ *   - arch/x86/kernel/amd_gart_64.c|397| <<gart_map_sg>> max_seg_size = dma_get_max_seg_size(dev);
+ *   - drivers/iommu/dma-iommu.c|702| <<__finalise_sg>> unsigned int cur_len = 0, max_len = dma_get_max_seg_size(dev);
+ *   - kernel/dma/debug.c|349| <<bucket_find_contain>> unsigned int max_range = dma_get_max_seg_size(ref->dev);
+ *   - kernel/dma/debug.c|1212| <<check_sg_segment>> unsigned int max_seg = dma_get_max_seg_size(dev);
+ */
 static inline unsigned int dma_get_max_seg_size(struct device *dev)
 {
 	if (dev->dma_parms && dev->dma_parms->max_segment_size)
@@ -707,6 +714,12 @@ static inline unsigned int dma_get_max_seg_size(struct device *dev)
 static inline int dma_set_max_seg_size(struct device *dev, unsigned int size)
 {
 	if (dev->dma_parms) {
+		/*
+		 * 只在下面使用:
+		 *   - include/linux/dma-mapping.h|702| <<dma_get_max_seg_size>> if (dev->dma_parms && dev->dma_parms->max_segment_size)
+		 *   - include/linux/dma-mapping.h|703| <<dma_get_max_seg_size>> return dev->dma_parms->max_segment_size;
+		 *   - include/linux/dma-mapping.h|710| <<dma_set_max_seg_size>> dev->dma_parms->max_segment_size = size;
+		 */
 		dev->dma_parms->max_segment_size = size;
 		return 0;
 	}
diff --git a/include/linux/irq.h b/include/linux/irq.h
index fb301cf..cf4414e 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -225,6 +225,13 @@ enum {
 	IRQD_IRQ_INPROGRESS		= (1 << 18),
 	IRQD_WAKEUP_ARMED		= (1 << 19),
 	IRQD_FORWARDED_TO_VCPU		= (1 << 20),
+	/*
+	 * 在以下设置:
+	 *   - kernel/irq/irqdesc.c|474| <<alloc_descs>> flags = IRQD_AFFINITY_MANAGED |
+	 *
+	 * 在以下使用:
+	 *   - include/linux/irq.h|350| <<irqd_affinity_is_managed>> return __irqd_to_state(d) & IRQD_AFFINITY_MANAGED;
+	 */
 	IRQD_AFFINITY_MANAGED		= (1 << 21),
 	IRQD_IRQ_STARTED		= (1 << 22),
 	IRQD_MANAGED_SHUTDOWN		= (1 << 23),
diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index 30cc217..ea7e885 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -374,6 +374,10 @@ void irq_matrix_remove_reserved(struct irq_matrix *m)
  * @reserved:	Allocate previously reserved interrupts
  * @mapped_cpu: Pointer to store the CPU for which the irq was allocated
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|250| <<assign_vector_locked>> vector = irq_matrix_alloc(vector_matrix, dest, resvd, &cpu);
+ */
 int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,
 		     bool reserved, unsigned int *mapped_cpu)
 {
-- 
2.7.4

