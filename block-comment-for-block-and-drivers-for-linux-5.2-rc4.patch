From 5b62a4b189dddce5c00b392d33593f7dd0754d6b Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 8 Jul 2019 13:55:45 +0800
Subject: [PATCH 1/1] block comment for block and drivers for linux-5.2-rc4

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 arch/x86/kernel/apic/vector.c       |  69 ++++++++++
 arch/x86/pci/common.c               |  25 ++++
 arch/x86/pci/legacy.c               |   9 ++
 block/blk-core.c                    |  42 ++++++
 block/blk-mq-sysfs.c                |   3 +
 block/blk-mq-tag.c                  |   9 ++
 block/blk-mq-tag.h                  |   7 +
 block/blk-mq.c                      | 161 ++++++++++++++++++++++
 block/blk-mq.h                      |   9 ++
 block/blk-timeout.c                 |  18 +++
 drivers/acpi/pci_root.c             |   4 +
 drivers/acpi/scan.c                 |   6 +
 drivers/nvme/host/pci.c             |   4 +
 drivers/pci/msi.c                   |   7 +
 drivers/pci/probe.c                 | 254 +++++++++++++++++++++++++++++++++++
 drivers/pci/search.c                |  20 +++
 drivers/scsi/hosts.c                |  47 +++++++
 drivers/scsi/iscsi_tcp.c            |  10 ++
 drivers/scsi/scsi_lib.c             | 211 +++++++++++++++++++++++++++++
 drivers/scsi/scsi_scan.c            | 254 +++++++++++++++++++++++++++++++++++
 drivers/scsi/scsi_sysfs.c           |  68 ++++++++++
 drivers/scsi/scsi_transport_iscsi.c |   9 ++
 drivers/scsi/sd.c                   |  56 ++++++++
 drivers/scsi/virtio_scsi.c          | 259 ++++++++++++++++++++++++++++++++++++
 drivers/virtio/virtio_pci_common.c  |  15 +++
 include/linux/blk-mq.h              |  63 +++++++++
 include/linux/blkdev.h              |  20 +++
 include/linux/dma-mapping.h         |  13 ++
 include/linux/interrupt.h           |  33 +++++
 include/linux/irq.h                 |   7 +
 include/linux/virtio_config.h       |   3 +
 include/scsi/scsi_cmnd.h            |  24 ++++
 include/scsi/scsi_device.h          |  46 +++++++
 include/scsi/scsi_host.h            |  22 +++
 kernel/irq/affinity.c               |  75 +++++++++++
 kernel/irq/matrix.c                 |   4 +
 36 files changed, 1886 insertions(+)

diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c
index 3173e07..04aa2bd 100644
--- a/arch/x86/kernel/apic/vector.c
+++ b/arch/x86/kernel/apic/vector.c
@@ -26,6 +26,37 @@
 
 #include <asm/trace/irq_vectors.h>
 
+/*
+ * struct irq_affinity_desc
+ *   unsigned int is_managed:1; 默认是1
+ *
+ *   - kernel/irq/affinity.c|318| <<irq_create_affinity_masks>> masks[i].is_managed = 1;
+ *   - kernel/irq/irqdesc.c|473| <<alloc_descs>> if (affinity->is_managed) {
+ *
+ *
+ * struct pci_dev
+ *   unsigned int is_managed:1; 默认是1
+ *
+ *   - drivers/pci/pci.c|1808| <<pcim_enable_device>> pdev->is_managed = 1;
+ *   - include/linux/pci.h|1107| <<pci_is_managed>> return pdev->is_managed;
+ *
+ *
+ * struct apic_chip_data
+ *   unsigned int is_managed:1; 默认是1
+ *
+ *   - arch/x86/kernel/apic/vector.c|194| <<reserve_managed_vector>> apicd->is_managed = true;
+ *   - arch/x86/kernel/apic/vector.c|367| <<x86_vector_deactivate>> trace_vector_deactivate(irqd->irq, apicd->is_managed,
+ *   - arch/x86/kernel/apic/vector.c|371| <<x86_vector_deactivate>> if (!apicd->is_managed && !apicd->can_reserve)
+ *   - arch/x86/kernel/apic/vector.c|438| <<x86_vector_activate>> trace_vector_activate(irqd->irq, apicd->is_managed,
+ *   - arch/x86/kernel/apic/vector.c|442| <<x86_vector_activate>> if (!apicd->can_reserve && !apicd->is_managed)
+ *   - arch/x86/kernel/apic/vector.c|448| <<x86_vector_activate>> else if (apicd->is_managed)
+ *   - arch/x86/kernel/apic/vector.c|461| <<vector_free_reserved_and_managed>> trace_vector_teardown(irqd->irq, apicd->is_managed,
+ *   - arch/x86/kernel/apic/vector.c|466| <<vector_free_reserved_and_managed>> if (apicd->is_managed)
+ *   - arch/x86/kernel/apic/vector.c|615| <<x86_vector_debug_show>> seq_printf(m, "%*sis_managed: %u\n", ind, "", apicd.is_managed ? 1 : 0);
+ *   - arch/x86/kernel/apic/vector.c|776| <<apic_set_affinity>> (apicd->is_managed || apicd->can_reserve))
+ *   - arch/x86/kernel/apic/vector.c|830| <<free_moved_vector>> bool managed = apicd->is_managed;
+ */
+
 struct apic_chip_data {
 	struct irq_cfg		hw_irq_cfg;
 	unsigned int		vector;
@@ -43,6 +74,25 @@ struct apic_chip_data {
 struct irq_domain *x86_vector_domain;
 EXPORT_SYMBOL_GPL(x86_vector_domain);
 static DEFINE_RAW_SPINLOCK(vector_lock);
+/*
+ * used by:
+ *   - arch/x86/kernel/apic/vector.c|297| <<assign_irq_vector>> cpumask_and(vector_searchmask, dest, cpu_online_mask);
+ *   - arch/x86/kernel/apic/vector.c|298| <<assign_irq_vector>> ret = assign_vector_locked(irqd, vector_searchmask);
+ *   - arch/x86/kernel/apic/vector.c|312| <<assign_irq_vector_any_locked>> cpumask_and(vector_searchmask, cpumask_of_node(node), affmsk);
+ *   - arch/x86/kernel/apic/vector.c|313| <<assign_irq_vector_any_locked>> if (!assign_vector_locked(irqd, vector_searchmask))
+ *   - arch/x86/kernel/apic/vector.c|320| <<assign_irq_vector_any_locked>> cpumask_and(vector_searchmask, affmsk, cpu_online_mask);
+ *   - arch/x86/kernel/apic/vector.c|321| <<assign_irq_vector_any_locked>> if (!assign_vector_locked(irqd, vector_searchmask))
+ *   - arch/x86/kernel/apic/vector.c|352| <<assign_managed_vector>> cpumask_and(vector_searchmask, dest, affmsk);
+ *   - arch/x86/kernel/apic/vector.c|355| <<assign_managed_vector>> if (apicd->vector && cpumask_test_cpu(apicd->cpu, vector_searchmask))
+ *   - arch/x86/kernel/apic/vector.c|357| <<assign_managed_vector>> vector = irq_matrix_alloc_managed(vector_matrix, vector_searchmask,
+ *   - arch/x86/kernel/apic/vector.c|447| <<activate_managed>> cpumask_and(vector_searchmask, dest, cpu_online_mask);
+ *   - arch/x86/kernel/apic/vector.c|448| <<activate_managed>> if (WARN_ON_ONCE(cpumask_empty(vector_searchmask))) {
+ *   - arch/x86/kernel/apic/vector.c|454| <<activate_managed>> ret = assign_managed_vector(irqd, vector_searchmask);
+ *   - arch/x86/kernel/apic/vector.c|738| <<arch_early_irq_init>> BUG_ON(!alloc_cpumask_var(&vector_searchmask, GFP_KERNEL));
+ *   - arch/x86/kernel/apic/vector.c|815| <<apic_set_affinity>> cpumask_and(vector_searchmask, dest, cpu_online_mask);
+ *   - arch/x86/kernel/apic/vector.c|817| <<apic_set_affinity>> err = assign_managed_vector(irqd, vector_searchmask);
+ *   - arch/x86/kernel/apic/vector.c|819| <<apic_set_affinity>> err = assign_vector_locked(irqd, vector_searchmask);
+ */
 static cpumask_var_t vector_searchmask;
 static struct irq_chip lapic_controller;
 static struct irq_matrix *vector_matrix;
@@ -183,6 +233,10 @@ static void vector_assign_managed_shutdown(struct irq_data *irqd)
 	apic_update_irq_cfg(irqd, MANAGED_IRQ_SHUTDOWN_VECTOR, cpu);
 }
 
+/*
+ * called only by:
+ *   - arch/x86/kernel/apic/vector.c|358| <<assign_irq_vector_policy>> return reserve_managed_vector(irqd);
+ */
 static int reserve_managed_vector(struct irq_data *irqd)
 {
 	const struct cpumask *affmsk = irq_data_get_affinity_mask(irqd);
@@ -257,6 +311,10 @@ assign_vector_locked(struct irq_data *irqd, const struct cpumask *dest)
 	return 0;
 }
 
+/*
+ * called only by:
+ *   - arch/x86/kernel/apic/vector.c|337| <<assign_irq_vector_policy>> return assign_irq_vector(irqd, info->mask);
+ */
 static int assign_irq_vector(struct irq_data *irqd, const struct cpumask *dest)
 {
 	unsigned long flags;
@@ -293,9 +351,17 @@ static int assign_irq_vector_any_locked(struct irq_data *irqd)
 	return assign_vector_locked(irqd, cpu_online_mask);
 }
 
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|621| <<x86_vector_alloc_irqs>> err = assign_irq_vector_policy(irqd, info);
+ */
 static int
 assign_irq_vector_policy(struct irq_data *irqd, struct irq_alloc_info *info)
 {
+	/*
+	 * IRQD_AFFINITY_MANAGED在以下设置:
+	 *   - kernel/irq/irqdesc.c|474| <<alloc_descs>> flags = IRQD_AFFINITY_MANAGED |
+	 */
 	if (irqd_affinity_is_managed(irqd))
 		return reserve_managed_vector(irqd);
 	if (info->mask)
@@ -517,6 +583,9 @@ static bool vector_configure_legacy(unsigned int virq, struct irq_data *irqd,
 	return realloc;
 }
 
+/*
+ * struct irq_domain_ops x86_vector_domain_ops.alloc = x86_vector_alloc_irqs()
+ */
 static int x86_vector_alloc_irqs(struct irq_domain *domain, unsigned int virq,
 				 unsigned int nr_irqs, void *arg)
 {
diff --git a/arch/x86/pci/common.c b/arch/x86/pci/common.c
index 9acab6a..7a0b806 100644
--- a/arch/x86/pci/common.c
+++ b/arch/x86/pci/common.c
@@ -31,6 +31,17 @@ int noioapicreroute = 0;
 #else
 int noioapicreroute = 1;
 #endif
+/*
+ * 在以下修改pcibios_last_bus:
+ *   - arch/x86/pci/common.c|34| <<global>> int pcibios_last_bus = -1;
+ *   - arch/x86/kernel/jailhouse.c|126| <<jailhouse_pci_arch_init>> pcibios_last_bus = 0xff;
+ *   - arch/x86/pci/common.c|591| <<pcibios_setup>> pcibios_last_bus = simple_strtol(str+8, NULL, 0);
+ *   - arch/x86/pci/fixup.c|34| <<pci_fixup_i450nx>> pcibios_last_bus = -1;
+ *   - arch/x86/pci/fixup.c|48| <<pci_fixup_i450gx>> pcibios_last_bus = -1;
+ *   - arch/x86/pci/irq.c|145| <<pirq_peer_trick>> pcibios_last_bus = -1;
+ *   - arch/x86/pci/mmconfig-shared.c|647| <<__pci_mmcfg_init>> pcibios_last_bus = cfg->end_bus;
+ *   - arch/x86/pci/pcbios.c|162| <<check_pcibios>> pcibios_last_bus = ecx & 0xff;
+ */
 int pcibios_last_bus = -1;
 unsigned long pirq_table_addr;
 const struct pci_raw_ops *__read_mostly raw_pci_ops;
@@ -169,6 +180,11 @@ void pcibios_fixup_bus(struct pci_bus *b)
 		pcibios_fixup_device_resources(dev);
 }
 
+/*
+ * called by:
+ *   - drivers/pci/probe.c|900| <<pci_register_host_bridge>> pcibios_add_bus(bus);
+ *   - drivers/pci/probe.c|1053| <<pci_alloc_child_bus>> pcibios_add_bus(child);
+ */
 void pcibios_add_bus(struct pci_bus *bus)
 {
 	acpi_pci_add_bus(bus);
@@ -454,6 +470,15 @@ void __init dmi_check_pciprobe(void)
 	dmi_check_system(pciprobe_dmi_table);
 }
 
+/*
+ * called by:
+ *   - arch/x86/pci/fixup.c|30| <<pci_fixup_i450nx>> pcibios_scan_root(busno);
+ *   - arch/x86/pci/fixup.c|32| <<pci_fixup_i450nx>> pcibios_scan_root(suba+1);
+ *   - arch/x86/pci/fixup.c|47| <<pci_fixup_i450gx>> pcibios_scan_root(busno);
+ *   - arch/x86/pci/irq.c|143| <<pirq_peer_trick>> pcibios_scan_root(i);
+ *   - arch/x86/pci/legacy.c|33| <<pci_legacy_init>> pcibios_scan_root(0);
+ *   - arch/x86/pci/legacy.c|51| <<pcibios_scan_specific_bus>> pcibios_scan_root(busn);
+ */
 void pcibios_scan_root(int busnum)
 {
 	struct pci_bus *bus;
diff --git a/arch/x86/pci/legacy.c b/arch/x86/pci/legacy.c
index 467311b..67b2b62 100644
--- a/arch/x86/pci/legacy.c
+++ b/arch/x86/pci/legacy.c
@@ -12,6 +12,10 @@
  * Discover remaining PCI buses in case there are peer host bridges.
  * We use the number of last PCI bus provided by the PCI BIOS.
  */
+/*
+ * called by only:
+ *   - arch/x86/pci/legacy.c|71| <<pci_subsys_init>> pcibios_fixup_peer_bridges();
+ */
 static void pcibios_fixup_peer_bridges(void)
 {
 	int n;
@@ -34,6 +38,11 @@ int __init pci_legacy_init(void)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - arch/x86/pci/legacy.c|24| <<pcibios_fixup_peer_bridges>> pcibios_scan_specific_bus(n);
+ *   - drivers/edac/i7core_edac.c|1275| <<i7core_xeon_pci_fixup>> pcibios_scan_specific_bus(255-i);
+ */
 void pcibios_scan_specific_bus(int busn)
 {
 	int stride = jailhouse_paravirt() ? 1 : 8;
diff --git a/block/blk-core.c b/block/blk-core.c
index 8340f69..9ffd259 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -411,10 +411,23 @@ static void blk_queue_usage_counter_release(struct percpu_ref *ref)
 	wake_up_all(&q->mq_freeze_wq);
 }
 
+/*
+ * used by:
+ *   - block/blk-core.c|466| <<blk_alloc_queue_node>> timer_setup(&q->timeout, blk_rq_timed_out_timer, 0);
+ */
 static void blk_rq_timed_out_timer(struct timer_list *t)
 {
 	struct request_queue *q = from_timer(q, t, timeout);
 
+	/*
+	 * timeout_work在以下使用:
+	 *   - block/blk-core.c|235| <<blk_sync_queue>> cancel_work_sync(&q->timeout_work);
+	 *   - block/blk-core.c|418| <<blk_rq_timed_out_timer>> kblockd_schedule_work(&q->timeout_work);
+	 *   - block/blk-core.c|467| <<blk_alloc_queue_node>> INIT_WORK(&q->timeout_work, blk_timeout_work);
+	 *   - block/blk-mq.c|923| <<blk_mq_timeout_work>> container_of(work, struct request_queue, timeout_work);
+	 *   - block/blk-mq.c|2942| <<blk_mq_init_allocated_queue>> INIT_WORK(&q->timeout_work, blk_mq_timeout_work);
+	 *   - block/blk-timeout.c|89| <<blk_abort_request>> kblockd_schedule_work(&req->q->timeout_work);
+	 */
 	kblockd_schedule_work(&q->timeout_work);
 }
 
@@ -427,6 +440,18 @@ static void blk_timeout_work(struct work_struct *work)
  * @gfp_mask: memory allocation flags
  * @node_id: NUMA node to allocate memory from
  */
+/*
+ * called by:
+ *   - block/blk-mq.c|2777| <<blk_mq_init_queue>> uninit_q = blk_alloc_queue_node(GFP_KERNEL, set->numa_node);
+ *   - block/blk-core.c|345| <<blk_alloc_queue>> return blk_alloc_queue_node(gfp_mask, NUMA_NO_NODE);
+ *   - drivers/block/drbd/drbd_main.c|2803| <<drbd_create_device>> q = blk_alloc_queue_node(GFP_KERNEL, NUMA_NO_NODE);
+ *   - drivers/block/null_blk_main.c|1663| <<null_add_dev>> nullb->q = blk_alloc_queue_node(GFP_KERNEL, dev->home_node);
+ *   - drivers/block/umem.c|888| <<mm_pci_probe>> card->queue = blk_alloc_queue_node(GFP_KERNEL, NUMA_NO_NODE);
+ *   - drivers/lightnvm/core.c|381| <<nvm_create_tgt>> tqueue = blk_alloc_queue_node(GFP_KERNEL, dev->q->node);
+ *   - drivers/md/dm.c|1971| <<alloc_dev>> md->queue = blk_alloc_queue_node(GFP_KERNEL, numa_node_id);
+ *   - drivers/nvdimm/pmem.c|398| <<pmem_attach_disk>> q = blk_alloc_queue_node(GFP_KERNEL, dev_to_node(dev));
+ *   - drivers/nvme/host/multipath.c|310| <<nvme_mpath_alloc_disk>> q = blk_alloc_queue_node(GFP_KERNEL, ctrl->numa_node);
+ */
 struct request_queue *blk_alloc_queue_node(gfp_t gfp_mask, int node_id)
 {
 	struct request_queue *q;
@@ -463,6 +488,17 @@ struct request_queue *blk_alloc_queue_node(gfp_t gfp_mask, int node_id)
 
 	timer_setup(&q->backing_dev_info->laptop_mode_wb_timer,
 		    laptop_mode_timer_fn, 0);
+	/*
+	 * q->timeout在以下使用:
+	 *   - block/blk-core.c|234| <<blk_sync_queue>> del_timer_sync(&q->timeout);
+	 *   - block/blk-core.c|491| <<blk_alloc_queue_node>> timer_setup(&q->timeout, blk_rq_timed_out_timer, 0);
+	 *   - block/blk-mq.c|967| <<blk_mq_timeout_work>> mod_timer(&q->timeout, next);
+	 *   - block/blk-timeout.c|154| <<blk_add_timer>> if (!timer_pending(&q->timeout) ||
+	 *   - block/blk-timeout.c|155| <<blk_add_timer>> time_before(expiry, q->timeout.expires)) {
+	 *   - block/blk-timeout.c|156| <<blk_add_timer>> unsigned long diff = q->timeout.expires - expiry; 
+	 *   - block/blk-timeout.c|165| <<blk_add_timer>> if (!timer_pending(&q->timeout) || (diff >= HZ / 2))
+	 *   - block/blk-timeout.c|166| <<blk_add_timer>> mod_timer(&q->timeout, expiry);
+	 */
 	timer_setup(&q->timeout, blk_rq_timed_out_timer, 0);
 	INIT_WORK(&q->timeout_work, blk_timeout_work);
 	INIT_LIST_HEAD(&q->icq_list);
@@ -1606,6 +1642,12 @@ int kblockd_schedule_work_on(int cpu, struct work_struct *work)
 }
 EXPORT_SYMBOL(kblockd_schedule_work_on);
 
+/*
+ * called by:
+ *   - block/blk-mq.c|798| <<blk_mq_kick_requeue_list>> kblockd_mod_delayed_work_on(WORK_CPU_UNBOUND, &q->requeue_work, 0);
+ *   - block/blk-mq.c|805| <<blk_mq_delay_kick_requeue_list>> kblockd_mod_delayed_work_on(WORK_CPU_UNBOUND, &q->requeue_work,
+ *   - block/blk-mq.c|1494| <<__blk_mq_delay_run_hw_queue>> kblockd_mod_delayed_work_on(blk_mq_hctx_next_cpu(hctx), &hctx->run_work,
+ */
 int kblockd_mod_delayed_work_on(int cpu, struct delayed_work *dwork,
 				unsigned long delay)
 {
diff --git a/block/blk-mq-sysfs.c b/block/blk-mq-sysfs.c
index d6e1a9b..801e593 100644
--- a/block/blk-mq-sysfs.c
+++ b/block/blk-mq-sysfs.c
@@ -164,6 +164,9 @@ static ssize_t blk_mq_hw_sysfs_nr_reserved_tags_show(struct blk_mq_hw_ctx *hctx,
 	return sprintf(page, "%u\n", hctx->tags->nr_reserved_tags);
 }
 
+/*
+ * 打印cpu_list
+ */
 static ssize_t blk_mq_hw_sysfs_cpus_show(struct blk_mq_hw_ctx *hctx, char *page)
 {
 	unsigned int i, first = 1;
diff --git a/block/blk-mq-tag.c b/block/blk-mq-tag.c
index 7513c8e..63f1900 100644
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@ -529,6 +529,15 @@ int blk_mq_tag_update_depth(struct blk_mq_hw_ctx *hctx,
  * Note: When called for a request that is queued on a non-multiqueue request
  * queue, the hardware context index is set to zero.
  */
+/*
+ * 调用的例子:
+ *   - drivers/nvme/host/nvme.h|129| <<nvme_req_qid>> return blk_mq_unique_tag_to_hwq(blk_mq_unique_tag(req)) + 1;
+ *   - drivers/scsi/lpfc/lpfc_scsi.c|693| <<lpfc_get_scsi_buf_s4>> tag = blk_mq_unique_tag(cmnd->request);
+ *   - drivers/scsi/qla2xxx/qla_os.c|859| <<qla2xxx_queuecommand>> tag = blk_mq_unique_tag(cmd->request);
+ *   - drivers/scsi/scsi_debug.c|3698| <<get_queue>> u32 tag = blk_mq_unique_tag(cmnd->request);
+ *   - drivers/scsi/scsi_debug.c|5620| <<scsi_debug_queuecommand>> blk_mq_unique_tag(scp->request), b);
+ *   - drivers/scsi/virtio_scsi.c|649| <<virtscsi_pick_vq_mq>> u32 tag = blk_mq_unique_tag(sc->request);
+ */
 u32 blk_mq_unique_tag(struct request *rq)
 {
 	return (rq->mq_hctx->queue_num << BLK_MQ_UNIQUE_TAG_BITS) |
diff --git a/block/blk-mq-tag.h b/block/blk-mq-tag.h
index 61deab0..a9f4d7f 100644
--- a/block/blk-mq-tag.h
+++ b/block/blk-mq-tag.h
@@ -18,6 +18,13 @@ struct blk_mq_tags {
 
 	struct request **rqs;
 	struct request **static_rqs;
+	/*
+	 * 在以下使用:
+	 *   - block/blk-mq.c|2072| <<blk_mq_free_rqs>> while (!list_empty(&tags->page_list)) {
+	 *   - block/blk-mq.c|2073| <<blk_mq_free_rqs>> page = list_first_entry(&tags->page_list, struct page, lru);
+	 *   - block/blk-mq.c|2162| <<blk_mq_alloc_rqs>> INIT_LIST_HEAD(&tags->page_list);
+	 *   - block/blk-mq.c|2197| <<blk_mq_alloc_rqs>> list_add_tail(&page->lru, &tags->page_list);
+	 */
 	struct list_head page_list;
 };
 
diff --git a/block/blk-mq.c b/block/blk-mq.c
index ce0f5f4..4ae7444 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -844,6 +844,10 @@ bool blk_mq_queue_inflight(struct request_queue *q)
 }
 EXPORT_SYMBOL_GPL(blk_mq_queue_inflight);
 
+/*
+ * called by:
+ *   - block/blk-mq.c|913| <<blk_mq_check_expired>> blk_mq_rq_timed_out(rq, reserved);
+ */
 static void blk_mq_rq_timed_out(struct request *req, bool reserved)
 {
 	req->rq_flags |= RQF_TIMED_OUT;
@@ -879,6 +883,10 @@ static bool blk_mq_req_expired(struct request *rq, unsigned long *next)
 	return false;
 }
 
+/*
+ * used by:
+ *   - block/blk-mq.c|944| <<blk_mq_timeout_work>> blk_mq_queue_tag_busy_iter(q, blk_mq_check_expired, &next);
+ */
 static bool blk_mq_check_expired(struct blk_mq_hw_ctx *hctx,
 		struct request *rq, void *priv, bool reserved)
 {
@@ -917,6 +925,18 @@ static bool blk_mq_check_expired(struct blk_mq_hw_ctx *hctx,
 	return true;
 }
 
+/*
+ * q->timeout_work在以下使用:
+ *   - lock/blk-core.c|235| <<blk_sync_queue>> cancel_work_sync(&q->timeout_work);
+ *   - block/blk-core.c|418| <<blk_rq_timed_out_timer>> kblockd_schedule_work(&q->timeout_work);
+ *   - block/blk-core.c|467| <<blk_alloc_queue_node>> INIT_WORK(&q->timeout_work, blk_timeout_work);
+ *   - block/blk-mq.c|923| <<blk_mq_timeout_work>> container_of(work, struct request_queue, timeout_work);
+ *   - block/blk-mq.c|2942| <<blk_mq_init_allocated_queue>> INIT_WORK(&q->timeout_work, blk_mq_timeout_work);
+ *   - block/blk-timeout.c|89| <<blk_abort_request>> kblockd_schedule_work(&req->q->timeout_work);
+ *
+ * used by:
+ *   - block/blk-mq.c|2942| <<blk_mq_init_allocated_queue>> INIT_WORK(&q->timeout_work, blk_mq_timeout_work);
+ */
 static void blk_mq_timeout_work(struct work_struct *work)
 {
 	struct request_queue *q =
@@ -1352,6 +1372,11 @@ bool blk_mq_dispatch_rq_list(struct request_queue *q, struct list_head *list,
 	return (queued + errors) != 0;
 }
 
+/*
+ * called by:
+ *   - block/blk-mq.c|1486| <<__blk_mq_delay_run_hw_queue>> __blk_mq_run_hw_queue(hctx);
+ *   - block/blk-mq.c|1661| <<blk_mq_run_work_fn>> __blk_mq_run_hw_queue(hctx);
+ */
 static void __blk_mq_run_hw_queue(struct blk_mq_hw_ctx *hctx)
 {
 	int srcu_idx;
@@ -1373,6 +1398,11 @@ static void __blk_mq_run_hw_queue(struct blk_mq_hw_ctx *hctx)
 	 *   triggered, and we depend on blk-mq timeout handler to
 	 *   handle dispatched requests to this hctx
 	 */
+	/*
+	 * 在以下修改hctx的cpumask:
+	 *   - block/blk-mq.c|2562| <<blk_mq_map_swqueue>> cpumask_set_cpu(i, hctx->cpumask);
+	 *   - block/blk-mq.c|2520| <<blk_mq_map_swqueue>> cpumask_clear(hctx->cpumask);
+	 */
 	if (!cpumask_test_cpu(raw_smp_processor_id(), hctx->cpumask) &&
 		cpu_online(hctx->next_cpu)) {
 		printk(KERN_WARNING "run queue from wrong CPU %d, hctx %s\n",
@@ -1457,6 +1487,11 @@ static void __blk_mq_delay_run_hw_queue(struct blk_mq_hw_ctx *hctx, bool async,
 
 	if (!async && !(hctx->flags & BLK_MQ_F_BLOCKING)) {
 		int cpu = get_cpu();
+		/*
+		 * 在以下修改hctx的cpumask:
+		 *   - block/blk-mq.c|2562| <<blk_mq_map_swqueue>> cpumask_set_cpu(i, hctx->cpumask);
+		 *   - block/blk-mq.c|2520| <<blk_mq_map_swqueue>> cpumask_clear(hctx->cpumask);
+		 */
 		if (cpumask_test_cpu(cpu, hctx->cpumask)) {
 			__blk_mq_run_hw_queue(hctx);
 			put_cpu();
@@ -1611,6 +1646,16 @@ void blk_mq_start_stopped_hw_queues(struct request_queue *q, bool async)
 }
 EXPORT_SYMBOL(blk_mq_start_stopped_hw_queues);
 
+/*
+ * 在以下使用:
+ *   - block/blk-mq.c|2353| <<blk_mq_alloc_hctx>> INIT_DELAYED_WORK(&hctx->run_work, blk_mq_run_work_fn);
+ *
+ * 在以下调用:
+ *   - block/blk-mq-sysfs.c|39| <<blk_mq_hw_sysfs_release>> cancel_delayed_work_sync(&hctx->run_work);
+ *   - block/blk-mq.c|1469| <<__blk_mq_delay_run_hw_queue>> kblockd_mod_delayed_work_on(blk_mq_hctx_next_cpu(hctx), &hctx->run_work,
+ *   - block/blk-mq.c|1551| <<blk_mq_stop_hw_queue>> cancel_delayed_work(&hctx->run_work);
+ *   - block/blk-mq.c|1618| <<blk_mq_run_work_fn>> hctx = container_of(work, struct blk_mq_hw_ctx, run_work.work);
+ */
 static void blk_mq_run_work_fn(struct work_struct *work)
 {
 	struct blk_mq_hw_ctx *hctx;
@@ -2041,6 +2086,14 @@ static blk_qc_t blk_mq_make_request(struct request_queue *q, struct bio *bio)
 	return cookie;
 }
 
+/*
+ * called by:
+ *   - block/blk-mq-sched.c|453| <<blk_mq_sched_free_tags>> blk_mq_free_rqs(set, hctx->sched_tags, hctx_idx);
+ *   - block/blk-mq-sched.c|562| <<blk_mq_sched_free_requests>> blk_mq_free_rqs(q->tag_set, hctx->sched_tags, i);
+ *   - block/blk-mq-tag.c|505| <<blk_mq_tag_update_depth>> blk_mq_free_rqs(set, *tagsptr, hctx->queue_num);
+ *   - block/blk-mq.c|2224| <<blk_mq_alloc_rqs>> blk_mq_free_rqs(set, tags, hctx_idx);
+ *   - block/blk-mq.c|2473| <<blk_mq_free_map_and_requests>> blk_mq_free_rqs(set, set->tags[hctx_idx], hctx_idx);
+ */
 void blk_mq_free_rqs(struct blk_mq_tag_set *set, struct blk_mq_tags *tags,
 		     unsigned int hctx_idx)
 {
@@ -2249,6 +2302,11 @@ static int blk_mq_hctx_notify_dead(unsigned int cpu, struct hlist_node *node)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - block/blk-mq.c|2315| <<blk_mq_exit_hctx>> blk_mq_remove_cpuhp(hctx);
+ *   - block/blk-mq.c|2373| <<blk_mq_init_hctx>> blk_mq_remove_cpuhp(hctx);
+ */
 static void blk_mq_remove_cpuhp(struct blk_mq_hw_ctx *hctx)
 {
 	cpuhp_state_remove_instance_nocalls(CPUHP_BLK_MQ_DEAD,
@@ -2304,6 +2362,10 @@ static int blk_mq_hw_ctx_size(struct blk_mq_tag_set *tag_set)
 	return hw_ctx_size;
 }
 
+/*
+ * called by:
+ *   - block/blk-mq.c|2895| <<blk_mq_alloc_and_init_hctx>> if (blk_mq_init_hctx(q, set, hctx, hctx_idx))
+ */
 static int blk_mq_init_hctx(struct request_queue *q,
 		struct blk_mq_tag_set *set,
 		struct blk_mq_hw_ctx *hctx, unsigned hctx_idx)
@@ -2429,10 +2491,18 @@ static void blk_mq_init_cpu_queues(struct request_queue *q,
 	}
 }
 
+/*
+ * called by:
+ *   - block/blk-mq.c|2488| <<blk_mq_map_swqueue>> !__blk_mq_alloc_rq_map(set, hctx_idx)) {
+ *   - block/blk-mq.c|2955| <<__blk_mq_alloc_rq_maps>> if (!__blk_mq_alloc_rq_map(set, i))
+ */
 static bool __blk_mq_alloc_rq_map(struct blk_mq_tag_set *set, int hctx_idx)
 {
 	int ret = 0;
 
+	/*
+	 * struct blk_mq_tags **tags;
+	 */
 	set->tags[hctx_idx] = blk_mq_alloc_rq_map(set, hctx_idx,
 					set->queue_depth, set->reserved_tags);
 	if (!set->tags[hctx_idx])
@@ -2584,6 +2654,11 @@ static void queue_set_hctx_shared(struct request_queue *q, bool shared)
 	}
 }
 
+/*
+ * called by:
+ *   - block/blk-mq.c|2657| <<blk_mq_del_queue_tag_set>> blk_mq_update_tag_set_depth(set, false);
+ *   - block/blk-mq.c|2705| <<blk_mq_add_queue_tag_set>> blk_mq_update_tag_set_depth(set, true);
+ */
 static void blk_mq_update_tag_set_depth(struct blk_mq_tag_set *set,
 					bool shared)
 {
@@ -2598,6 +2673,34 @@ static void blk_mq_update_tag_set_depth(struct blk_mq_tag_set *set,
 	}
 }
 
+/*
+ * [0] blk_mq_del_queue_tag_set
+ * [0] blk_mq_exit_queue
+ * [0] blk_cleanup_queue
+ * [0] __scsi_remove_device
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called only by:
+ *   - block/blk-mq.c|3041| <<blk_mq_exit_queue>> blk_mq_del_queue_tag_set(q);
+ */
 static void blk_mq_del_queue_tag_set(struct request_queue *q)
 {
 	struct blk_mq_tag_set *set = q->tag_set;
@@ -2614,6 +2717,36 @@ static void blk_mq_del_queue_tag_set(struct request_queue *q)
 	INIT_LIST_HEAD(&q->tag_set_list);
 }
 
+/*
+ * virtio_scsi的例子, 调用了好多好多遍, 似乎为每一个target都调用了
+ * [0] blk_mq_add_queue_tag_set
+ * [0] blk_mq_init_allocated_queue
+ * [0] blk_mq_init_queue
+ * [0] scsi_mq_alloc_queue
+ * [0] scsi_alloc_sdev
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - block/blk-mq.c|2941| <<blk_mq_init_allocated_queue>> blk_mq_add_queue_tag_set(set, q);
+ */
 static void blk_mq_add_queue_tag_set(struct blk_mq_tag_set *set,
 				     struct request_queue *q)
 {
@@ -2694,6 +2827,17 @@ void blk_mq_release(struct request_queue *q)
 	blk_mq_sysfs_deinit(q);
 }
 
+/*
+ * 调用的几个例子:
+ *   - drivers/scsi/scsi_lib.c|1832| <<scsi_mq_alloc_queue>> sdev->request_queue = blk_mq_init_queue(&sdev->host->tag_set);
+ *   - drivers/nvme/host/core.c|3253| <<nvme_alloc_ns>> ns->queue = blk_mq_init_queue(ctrl->tagset);
+ *   - drivers/nvme/host/pci.c|1636| <<nvme_alloc_admin_tags>> dev->ctrl.admin_q = blk_mq_init_queue(&dev->admin_tagset);
+ *   - drivers/block/virtio_blk.c|802| <<virtblk_probe>> q = blk_mq_init_queue(&vblk->tag_set);
+ *   - drivers/block/xen-blkfront.c|986| <<xlvbd_init_blk_queue>> rq = blk_mq_init_queue(&info->tag_set);
+ *   - block/blk-mq.c|2813| <<blk_mq_init_sq_queue>> q = blk_mq_init_queue(set);
+ *   - drivers/block/loop.c|2004| <<loop_add>> lo->lo_queue = blk_mq_init_queue(&lo->tag_set);
+ *   - drivers/block/null_blk_main.c|1656| <<null_add_dev>> nullb->q = blk_mq_init_queue(nullb->tag_set);
+ */
 struct request_queue *blk_mq_init_queue(struct blk_mq_tag_set *set)
 {
 	struct request_queue *uninit_q, *q;
@@ -3034,6 +3178,19 @@ static int blk_mq_update_queue_map(struct blk_mq_tag_set *set)
  * requested depth down, if it's too large. In that case, the set
  * value will be stored in set->queue_depth.
  */
+/*
+ * 被很多调用, 这里是部分调用的例子:
+ *   - block/blk-mq.c|2820| <<blk_mq_init_sq_queue>> ret = blk_mq_alloc_tag_set(set);
+ *   - block/bsg-lib.c|382| <<bsg_setup_queue>> if (blk_mq_alloc_tag_set(set))
+ *   - drivers/block/loop.c|2000| <<loop_add>> err = blk_mq_alloc_tag_set(&lo->tag_set);
+ *   - drivers/block/null_blk_main.c|1562| <<null_init_tag_set>> return blk_mq_alloc_tag_set(set);
+ *   - drivers/block/virtio_blk.c|798| <<virtblk_probe>> err = blk_mq_alloc_tag_set(&vblk->tag_set);
+ *   - drivers/block/xen-blkfront.c|984| <<xlvbd_init_blk_queue>> if (blk_mq_alloc_tag_set(&info->tag_set))
+ *   - drivers/md/dm-rq.c|561| <<dm_mq_init_request_queue>> err = blk_mq_alloc_tag_set(md->tag_set);
+ *   - drivers/nvme/host/pci.c|1632| <<nvme_alloc_admin_tags>> if (blk_mq_alloc_tag_set(&dev->admin_tagset))
+ *   - drivers/nvme/host/pci.c|2277| <<nvme_dev_add>> ret = blk_mq_alloc_tag_set(&dev->tagset);
+ *   - drivers/scsi/scsi_lib.c|2050| <<scsi_mq_setup_tags>> return blk_mq_alloc_tag_set(&shost->tag_set);
+ */
 int blk_mq_alloc_tag_set(struct blk_mq_tag_set *set)
 {
 	int i, ret;
@@ -3252,6 +3409,10 @@ static void blk_mq_elv_switch_back(struct list_head *head,
 	mutex_unlock(&q->sysfs_lock);
 }
 
+/*
+ * called by only:
+ *   - block/blk-mq.c|3408| <<blk_mq_update_nr_hw_queues>> __blk_mq_update_nr_hw_queues(set, nr_hw_queues);
+ */
 static void __blk_mq_update_nr_hw_queues(struct blk_mq_tag_set *set,
 							int nr_hw_queues)
 {
diff --git a/block/blk-mq.h b/block/blk-mq.h
index 633a5a7..850fd7d 100644
--- a/block/blk-mq.h
+++ b/block/blk-mq.h
@@ -149,6 +149,15 @@ static inline struct blk_mq_ctx *__blk_mq_get_ctx(struct request_queue *q,
  * care about preemption, since we know the ctx's are persistent. This does
  * mean that we can't rely on ctx always matching the currently running CPU.
  */
+/*
+ * called by:
+ *   - block/blk-mq-sched.c|324| <<__blk_mq_sched_bio_merge>> struct blk_mq_ctx *ctx = blk_mq_get_ctx(q);
+ *   - block/blk-mq-tag.c|172| <<blk_mq_get_tag>> data->ctx = blk_mq_get_ctx(data->q);
+ *   - block/blk-mq.c|363| <<blk_mq_get_request>> data->ctx = blk_mq_get_ctx(q);
+ *   - block/kyber-iosched.c|568| <<kyber_bio_merge>> struct blk_mq_ctx *ctx = blk_mq_get_ctx(hctx->queue);
+ *
+ * 这个函数会通过get_cpu()来disable preemption
+ */
 static inline struct blk_mq_ctx *blk_mq_get_ctx(struct request_queue *q)
 {
 	return __blk_mq_get_ctx(q, get_cpu());
diff --git a/block/blk-timeout.c b/block/blk-timeout.c
index 8aa68fa..f13f6f5 100644
--- a/block/blk-timeout.c
+++ b/block/blk-timeout.c
@@ -78,6 +78,15 @@ ssize_t part_timeout_store(struct device *dev, struct device_attribute *attr,
  * LLDDs who implement their own error recovery MAY ignore the timeout
  * event if they generated blk_abort_request.
  */
+/*
+ * called by:
+ *   - drivers/ata/libata-eh.c|916| <<ata_qc_schedule_eh>> blk_abort_request(qc->scsicmd->request);
+ *   - drivers/block/mtip32xx/mtip32xx.c|2618| <<mtip_queue_cmd>> blk_abort_request(req);
+ *   - drivers/s390/block/dasd_ioctl.c|168| <<dasd_ioctl_abortio>> blk_abort_request(cqr->callback_data);
+ *   - drivers/scsi/libsas/sas_ata.c|588| <<sas_ata_task_abort>> blk_abort_request(qc->scsicmd->request);
+ *   - drivers/scsi/libsas/sas_scsi_host.c|912| <<sas_task_abort>> blk_abort_request(sc->request);
+ *   - drivers/scsi/scsi_debug.c|4390| <<schedule_resp>> blk_abort_request(cmnd->request);
+ */
 void blk_abort_request(struct request *req)
 {
 	/*
@@ -90,6 +99,10 @@ void blk_abort_request(struct request *req)
 }
 EXPORT_SYMBOL_GPL(blk_abort_request);
 
+/*
+ * called by:
+ *   - block/blk-timeout.c|134| <<blk_add_timer>> expiry = blk_rq_timeout(round_jiffies_up(expiry));
+ */
 unsigned long blk_rq_timeout(unsigned long timeout)
 {
 	unsigned long maxt;
@@ -109,6 +122,11 @@ unsigned long blk_rq_timeout(unsigned long timeout)
  *    Each request has its own timer, and as it is added to the queue, we
  *    set up the timer. When the request completes, we cancel the timer.
  */
+/*
+ * called by:
+ *   - block/blk-mq.c|691| <<blk_mq_start_request>> blk_add_timer(rq);
+ *   - block/blk-mq.c|863| <<blk_mq_rq_timed_out>> blk_add_timer(req);
+ */
 void blk_add_timer(struct request *req)
 {
 	struct request_queue *q = req->q;
diff --git a/drivers/acpi/pci_root.c b/drivers/acpi/pci_root.c
index 39f5d17..a8f75cd 100644
--- a/drivers/acpi/pci_root.c
+++ b/drivers/acpi/pci_root.c
@@ -871,6 +871,10 @@ static void acpi_pci_root_release_info(struct pci_host_bridge *bridge)
 	__acpi_pci_root_release_info(bridge->release_data);
 }
 
+/*
+ * called by:
+ *   - arch/x86/pci/acpi.c|368| <<pci_acpi_scan_root>> bus = acpi_pci_root_create(root, &acpi_pci_root_ops,
+ */
 struct pci_bus *acpi_pci_root_create(struct acpi_pci_root *root,
 				     struct acpi_pci_root_ops *ops,
 				     struct acpi_pci_root_info *info,
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index 0e28270..965b12f 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -1951,6 +1951,12 @@ static int acpi_scan_attach_handler(struct acpi_device *device)
 	return ret;
 }
 
+/*
+ * called by:
+ *   - drivers/acpi/scan.c|2006| <<acpi_bus_attach>> acpi_bus_attach(child);
+ *   - drivers/acpi/scan.c|2026| <<acpi_walk_dep_device_list>> acpi_bus_attach(adev);
+ *   - drivers/acpi/scan.c|2058| <<acpi_bus_scan>> acpi_bus_attach(device);
+ */
 static void acpi_bus_attach(struct acpi_device *device)
 {
 	struct acpi_device *child;
diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c
index 524d6bd..db63737 100644
--- a/drivers/nvme/host/pci.c
+++ b/drivers/nvme/host/pci.c
@@ -2464,6 +2464,10 @@ static void nvme_pci_free_ctrl(struct nvme_ctrl *ctrl)
 	kfree(dev);
 }
 
+/*
+ * called by only:
+ *   - drivers/nvme/host/pci.c|2600| <<nvme_reset_work>> nvme_remove_dead_ctrl(dev, result);
+ */
 static void nvme_remove_dead_ctrl(struct nvme_dev *dev, int status)
 {
 	dev_warn(dev->ctrl.device, "Removing after probe failure status: %d\n", status);
diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c
index e039b74..034610f 100644
--- a/drivers/pci/msi.c
+++ b/drivers/pci/msi.c
@@ -1149,6 +1149,13 @@ EXPORT_SYMBOL(pci_enable_msix_range);
  * To get the Linux IRQ number used for a vector that can be passed to
  * request_irq() use the pci_irq_vector() helper.
  */
+/*
+ * called by:
+ *   - drivers/nvme/host/pci.c|2089| <<nvme_setup_irqs>> return pci_alloc_irq_vectors_affinity(pdev, 1, irq_queues,
+ *   - drivers/scsi/qla2xxx/qla_isr.c|3463| <<qla24xx_enable_msix>> ret = pci_alloc_irq_vectors_affinity(ha->pdev, min_vecs,
+ *   - drivers/virtio/virtio_pci_common.c|133| <<vp_request_msix_vectors>> err = pci_alloc_irq_vectors_affinity(vp_dev->pci_dev, nvectors,
+ *   - include/linux/pci.h|1466| <<pci_alloc_irq_vectors>> return pci_alloc_irq_vectors_affinity(dev, min_vecs, max_vecs, flags,
+ */
 int pci_alloc_irq_vectors_affinity(struct pci_dev *dev, unsigned int min_vecs,
 				   unsigned int max_vecs, unsigned int flags,
 				   struct irq_affinity *affd)
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index 0e8e2c1..36a943c 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -31,6 +31,17 @@ static struct resource busn_resource = {
 };
 
 /* Ugh.  Need to stop exporting this to modules. */
+/*
+ * used by:
+ *   - arch/x86/pci/i386.c|360| <<pcibios_assign_resources>> list_for_each_entry(bus, &pci_root_buses, node)
+ *   - arch/x86/pci/i386.c|394| <<pcibios_resource_survey>> list_for_each_entry(bus, &pci_root_buses, node)
+ *   - arch/x86/pci/i386.c|397| <<pcibios_resource_survey>> list_for_each_entry(bus, &pci_root_buses, node)
+ *   - arch/x86/pci/i386.c|399| <<pcibios_resource_survey>> list_for_each_entry(bus, &pci_root_buses, node)
+ *   - drivers/pci/probe.c|937| <<pci_register_host_bridge>> list_add_tail(&bus->node, &pci_root_buses);
+ *   - drivers/pci/search.c|168| <<pci_find_next_bus>> n = from ? from->node.next : pci_root_buses.next;
+ *   - drivers/pci/search.c|169| <<pci_find_next_bus>> if (n != &pci_root_buses)
+ *   - drivers/pci/setup-bus.c|1803| <<pci_assign_unassigned_resources>> list_for_each_entry(root_bus, &pci_root_buses, node) {
+ */
 LIST_HEAD(pci_root_buses);
 EXPORT_SYMBOL(pci_root_buses);
 
@@ -603,6 +614,12 @@ static void pci_init_host_bridge(struct pci_host_bridge *bridge)
 	bridge->native_ltr = 1;
 }
 
+/*
+ * called by:
+ *   - drivers/pci/controller/pci-v3-semi.c|746| <<v3_pci_probe>> host = pci_alloc_host_bridge(sizeof(*v3));
+ *   - drivers/pci/controller/pcie-rcar.c|1132| <<rcar_pcie_probe>> bridge = pci_alloc_host_bridge(sizeof(*pcie));
+ *   - drivers/pci/probe.c|3278| <<pci_create_root_bus>> bridge = pci_alloc_host_bridge(0);
+ */
 struct pci_host_bridge *pci_alloc_host_bridge(size_t priv)
 {
 	struct pci_host_bridge *bridge;
@@ -827,6 +844,11 @@ static void pci_set_bus_msi_domain(struct pci_bus *bus)
 	dev_set_msi_domain(&bus->dev, d);
 }
 
+/*
+ * called by:
+ *   - drivers/pci/probe.c|3187| <<pci_create_root_bus>> error = pci_register_host_bridge(bridge);
+ *   - drivers/pci/probe.c|3309| <<pci_scan_root_bus_bridge>> ret = pci_register_host_bridge(bridge);
+ */
 static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 {
 	struct device *parent = bridge->dev.parent;
@@ -863,6 +885,11 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 		goto free;
 	}
 
+	/*
+	 * i440fx上pci的name例子:
+	 * pci0000:00
+	 * pci0000:03
+	 */
 	dev_set_name(&bridge->dev, "pci%04x:%02x", pci_domain_nr(bus),
 		     bridge->busnr);
 
@@ -897,6 +924,13 @@ static int pci_register_host_bridge(struct pci_host_bridge *bridge)
 	/* Create legacy_io and legacy_mem files for this bus */
 	pci_create_legacy_files(bus);
 
+	/*
+	 * 例子:
+	 * [    0.324037] ACPI: PCI Root Bridge [PCI0] (domain 0000 [bus 00-02])
+	 * [    0.325050] PCI host bridge to bus 0000:00
+	 * [    0.371036] ACPI: PCI Root Bridge [PC03] (domain 0000 [bus 03-04])
+	 * [    0.372048] PCI host bridge to bus 0000:03
+	 */
 	if (parent)
 		dev_info(parent, "PCI host bridge to bus %s\n", name);
 	else
@@ -1141,6 +1175,13 @@ static bool pci_ea_fixed_busnrs(struct pci_dev *dev, u8 *sec, u8 *sub)
  *
  * Return: New subordinate number covering all buses behind this bridge.
  */
+/*
+ * called by:
+ *   - drivers/pci/probe.c|1396| <<pci_scan_bridge>> return pci_scan_bridge_extend(bus, dev, max, 0, pass);
+ *   - drivers/pci/probe.c|3070| <<pci_scan_child_bus_extend>> max = pci_scan_bridge_extend(bus, dev, max, 0, 0);
+ *   - drivers/pci/probe.c|3105| <<pci_scan_child_bus_extend>> max = pci_scan_bridge_extend(bus, dev, cmax, buses, 1);
+ *   - drivers/pci/probe.c|3530| <<pci_hp_add_bridge>> pci_scan_bridge_extend(parent, dev, busnr, available_buses, 1);
+ */
 static int pci_scan_bridge_extend(struct pci_bus *bus, struct pci_dev *dev,
 				  int max, unsigned int available_buses,
 				  int pass)
@@ -1706,6 +1747,72 @@ static void early_dump_pci_device(struct pci_dev *pdev)
  * Returns 0 on success and negative if unknown type of device (not normal,
  * bridge or CardBus).
  */
+/*
+ * [0] pci_setup_device
+ * [0] pci_scan_single_device
+ * [0] pci_scan_slot
+ * [0] pci_scan_child_bus_extend
+ * [0] acpi_pci_root_create
+ * [0] pci_acpi_scan_root
+ * [0] acpi_pci_root_add
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_scan
+ * [0] acpi_scan_init
+ * [0] acpi_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * [0] pci_setup_device
+ * [0] pci_scan_single_device
+ * [0] pci_scan_slot
+ * [0] pci_scan_child_bus_extend
+ * [0] pci_scan_bridge_extend
+ * [0] pci_scan_child_bus_extend
+ * [0] acpi_pci_root_create
+ * [0] pci_acpi_scan_root
+ * [0] acpi_pci_root_add
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_scan
+ * [0] acpi_scan_init
+ * [0] acpi_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * 设置了pci=noacpi
+ * [0] pci_setup_device
+ * [0] pci_scan_single_device
+ * [0] pci_scan_slot
+ * [0] pci_scan_child_bus_extend
+ * [0] pci_scan_root_bus
+ * [0] pcibios_scan_root
+ * [0] pci_legacy_init
+ * [0] pci_subsys_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * [0] pci_setup_device
+ * [0] pci_scan_single_device
+ * [0] pci_scan_slot
+ * [0] pci_scan_child_bus_extend
+ * [0] pci_scan_root_bus
+ * [0] pcibios_scan_root
+ * [0] pcibios_scan_specific_bus
+ * [0] pci_subsys_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ */
 int pci_setup_device(struct pci_dev *dev)
 {
 	u32 class;
@@ -2788,6 +2895,19 @@ static int only_one_child(struct pci_bus *bus)
  *
  * Returns the number of new devices found.
  */
+/*
+ * called by:
+ *   - drivers/pci/hotplug/acpiphp_glue.c|431| <<acpiphp_rescan_slot>> return pci_scan_slot(slot->bus, PCI_DEVFN(slot->device, 0));
+ *   - drivers/pci/hotplug/cpci_hotplug_pci.c|262| <<cpci_configure_slot>> n = pci_scan_slot(slot->bus, slot->devfn);
+ *   - drivers/pci/hotplug/cpqphp_pci.c|86| <<cpqhp_configure_device>> num = pci_scan_slot(ctrl->pci_dev->bus, PCI_DEVFN(func->device, func->function));
+ *   - drivers/pci/hotplug/ibmphp_core.c|751| <<ibm_configure_device>> num = pci_scan_slot(bus,
+ *   - drivers/pci/hotplug/pciehp_pci.c|54| <<pciehp_configure_device>> num = pci_scan_slot(parent, PCI_DEVFN(0, 0));
+ *   - drivers/pci/hotplug/s390_pci_hpc.c|82| <<enable_slot>> pci_scan_slot(slot->zdev->bus, ZPCI_DEVFN);
+ *   - drivers/pci/hotplug/sgi_hotplug.c|366| <<enable_slot>> num_funcs = pci_scan_slot(slot->pci_bus,
+ *   - drivers/pci/hotplug/shpchp_pci.c|43| <<shpchp_configure_device>> num = pci_scan_slot(parent, PCI_DEVFN(p_slot->device, 0));
+ *   - drivers/pci/probe.c|3074| <<pci_scan_child_bus_extend>> nr_devs = pci_scan_slot(bus, devfn);
+ *   - drivers/pcmcia/cardbus.c|75| <<cb_alloc>> s->functions = pci_scan_slot(bus, PCI_DEVFN(0, 0));
+ */
 int pci_scan_slot(struct pci_bus *bus, int devfn)
 {
 	unsigned fn, nr = 0;
@@ -3000,6 +3120,69 @@ void __weak pcibios_fixup_bus(struct pci_bus *bus)
  * equally between hotplug-capable bridges to allow future extension of the
  * hierarchy.
  */
+/*
+ * qemu在i440fx上加了一个pxb, 一个bus是0, 一个bus是0x3
+ * [0] pci_scan_child_bus_extend
+ * [0] acpi_pci_root_create
+ * [0] pci_acpi_scan_root
+ * [0] acpi_pci_root_add
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_scan
+ * [0] acpi_scan_init
+ * [0] acpi_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * 0x3的bus上挂了nvme, 是bus=0x4
+ * [0] pci_scan_child_bus_extend
+ * [0] pci_scan_bridge_extend
+ * [0] pci_scan_child_bus_extend
+ * [0] acpi_pci_root_create
+ * [0] pci_acpi_scan_root
+ * [0] acpi_pci_root_add
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_scan
+ * [0] acpi_scan_init
+ * [0] acpi_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * acpi_pci_disabled是1的例子:
+ * [0] pci_scan_child_bus_extend
+ * [0] pci_scan_root_bus
+ * [0] pcibios_scan_root
+ * [0] pcibios_scan_specific_bus
+ * [0] pci_subsys_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * [0] pci_scan_child_bus_extend
+ * [0] pci_scan_bridge_extend
+ * [0] pci_scan_child_bus_extend
+ * [0] pci_scan_root_bus
+ * [0] pcibios_scan_root
+ * [0] pcibios_scan_specific_bus
+ * [0] pci_subsys_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/pci/probe.c|1322| <<pci_scan_bridge_extend>> max = pci_scan_child_bus_extend(child, available_buses);
+ *   - drivers/pci/probe.c|3204| <<pci_scan_child_bus>> return pci_scan_child_bus_extend(bus, 0);
+ */
 static unsigned int pci_scan_child_bus_extend(struct pci_bus *bus,
 					      unsigned int available_buses)
 {
@@ -3167,6 +3350,54 @@ void __weak pcibios_remove_bus(struct pci_bus *bus)
 {
 }
 
+/*
+ * 用qemu的i440fx的-device pxb,id=bridge1,bus=pci.0,bus_nr=3
+ * 调用两次, 第一次bus=0x0, 第二次bus=0x3
+ * [0] pci_create_root_bus
+ * [0] acpi_pci_root_create
+ * [0] pci_acpi_scan_root
+ * [0] acpi_pci_root_add
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_attach
+ * [0] acpi_bus_scan
+ * [0] acpi_scan_init
+ * [0] acpi_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * 用了pci=noacpi:
+ * [0] pci_create_root_bus
+ * [0] pci_scan_root_bus
+ * [0] pcibios_scan_root
+ * [0] pci_legacy_init
+ * [0] pci_subsys_init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * [0] pci_create_root_bus
+ * [0] pci_scan_root_bus+0x46/0xa0
+ * [0] pcibios_scan_root+0x77/0xd0
+ * [0] pcibios_scan_specific_bus+0x8c/0xa0
+ * [0] pci_subsys_init+0x5e/0x62
+ * [0] do_one_initcall+0x48/0x1df
+ * [0] kernel_init+0x5/0x100
+ * [0] ret_from_fork+0x35/0x40
+ *
+ * called by:
+ *   - drivers/acpi/pci_root.c|903| <<acpi_pci_root_create>> bus = pci_create_root_bus(NULL, busnum, ops->pci_ops,
+ *   - drivers/parisc/dino.c|988| <<dino_probe>> dino_dev->hba.hba_bus = bus = pci_create_root_bus(&dev->dev,
+ *   - drivers/parisc/lba_pci.c|1624| <<lba_driver_probe>> pci_create_root_bus(&dev->dev, lba_dev->hba.bus_num.start,
+ *   - drivers/pci/controller/pci-hyperv.c|1513| <<create_root_hv_pci_bus>> hbus->pci_bus = pci_create_root_bus(&hbus->hdev->device,
+ *   - drivers/pci/controller/vmd.c|684| <<vmd_enable_domain>> vmd->bus = pci_create_root_bus(&vmd->dev->dev, busn_start, &vmd_ops,
+ *   - drivers/pci/probe.c|3346| <<pci_scan_root_bus>> b = pci_create_root_bus(parent, bus, ops, sysdata, resources);
+ *   - drivers/pci/probe.c|3375| <<pci_scan_bus>> b = pci_create_root_bus(NULL, bus, ops, sysdata, &resources);
+ */
 struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
@@ -3196,6 +3427,13 @@ struct pci_bus *pci_create_root_bus(struct device *parent, int bus,
 }
 EXPORT_SYMBOL_GPL(pci_create_root_bus);
 
+/*
+ * called by:
+ *   - drivers/pci/controller/pci-aardvark.c|1025| <<advk_pcie_probe>> ret = pci_host_probe(bridge);
+ *   - drivers/pci/controller/pci-host-common.c|90| <<pci_host_common_probe>> ret = pci_host_probe(bridge);
+ *   - drivers/pci/controller/pcie-cadence-host.c|317| <<cdns_pcie_host_probe>> ret = pci_host_probe(bridge);
+ *   - drivers/pci/controller/pcie-mediatek.c|1114| <<mtk_pcie_probe>> err = pci_host_probe(host);
+ */
 int pci_host_probe(struct pci_host_bridge *bridge)
 {
 	struct pci_bus *bus, *child;
@@ -3329,6 +3567,11 @@ int pci_scan_root_bus_bridge(struct pci_host_bridge *bridge)
 }
 EXPORT_SYMBOL(pci_scan_root_bus_bridge);
 
+/*
+ * called by:
+ *   - arch/x86/pci/common.c|476| <<pcibios_scan_root>> bus = pci_scan_root_bus(NULL, busnum, &pci_root_ops, sd, &resources);
+ *   - drivers/pci/xen-pcifront.c|486| <<pcifront_scan_root>> b = pci_scan_root_bus(&pdev->xdev->dev, bus,
+ */
 struct pci_bus *pci_scan_root_bus(struct device *parent, int bus,
 		struct pci_ops *ops, void *sysdata, struct list_head *resources)
 {
@@ -3469,6 +3712,17 @@ void __init pci_sort_breadthfirst(void)
 	bus_sort_breadthfirst(&pci_bus_type, &pci_sort_bf_cmp);
 }
 
+/*
+ * called by:
+ *   - drivers/pci/hotplug/cpci_hotplug_pci.c|275| <<cpci_configure_slot>> pci_hp_add_bridge(dev);
+ *   - drivers/pci/hotplug/cpqphp_pci.c|100| <<cpqhp_configure_device>> pci_hp_add_bridge(func->pci_dev);
+ *   - drivers/pci/hotplug/ibmphp_core.c|764| <<ibm_configure_device>> pci_hp_add_bridge(func->dev);
+ *   - drivers/pci/hotplug/pciehp_pci.c|62| <<pciehp_configure_device>> pci_hp_add_bridge(dev);
+ *   - drivers/pci/hotplug/sgi_hotplug.c|394| <<enable_slot>> pci_hp_add_bridge(dev);
+ *   - drivers/pci/hotplug/shpchp_pci.c|52| <<shpchp_configure_device>> pci_hp_add_bridge(dev);
+ *
+ * 似乎只在hotplug使用
+ */
 int pci_hp_add_bridge(struct pci_dev *dev)
 {
 	struct pci_bus *parent = dev->bus;
diff --git a/drivers/pci/search.c b/drivers/pci/search.c
index 5c79226..02232c3 100644
--- a/drivers/pci/search.c
+++ b/drivers/pci/search.c
@@ -133,6 +133,21 @@ static struct pci_bus *pci_do_find_bus(struct pci_bus *bus, unsigned char busnr)
  * in the global list of PCI buses.  If the bus is found, a pointer to its
  * data structure is returned.  If no bus is found, %NULL is returned.
  */
+/*
+ * called by:
+ *   - arch/x86/pci/acpi.c|343| <<pci_acpi_scan_root>> bus = pci_find_bus(domain, busnum);
+ *   - arch/x86/pci/irq.c|141| <<pirq_peer_trick>> if (!busmap[i] || pci_find_bus(0, i))
+ *   - arch/x86/pci/legacy.c|43| <<pcibios_scan_specific_bus>> if (pci_find_bus(0, busn))
+ *   - drivers/acpi/reboot.c|14| <<acpi_pci_reboot>> bus0 = pci_find_bus(0, 0);
+ *   - drivers/pci/iov.c|87| <<virtfn_add_bus>> child = pci_find_bus(pci_domain_nr(bus), busnr);
+ *   - drivers/pci/pcie/pme.c|161| <<pcie_pme_handle_request>> bus = pci_find_bus(pci_domain_nr(port->bus), busnr);
+ *   - drivers/pci/probe.c|863| <<pci_register_host_bridge>> b = pci_find_bus(pci_domain_nr(bus), bridge->busnr);
+ *   - drivers/pci/probe.c|1218| <<pci_scan_bridge_extend>> child = pci_find_bus(pci_domain_nr(bus), secondary);
+ *   - drivers/pci/probe.c|1273| <<pci_scan_bridge_extend>> child = pci_find_bus(pci_domain_nr(bus), next_busnr);
+ *   - drivers/pci/probe.c|1314| <<pci_scan_bridge_extend>> if (pci_find_bus(pci_domain_nr(bus),
+ *   - drivers/pci/probe.c|3512| <<pci_hp_add_bridge>> if (!pci_find_bus(pci_domain_nr(parent), busnr))
+ *   - drivers/pci/xen-pcifront.c|540| <<pcifront_rescan_root>> b = pci_find_bus(domain, bus);
+ */
 struct pci_bus *pci_find_bus(int domain, int busnr)
 {
 	struct pci_bus *bus = NULL;
@@ -158,6 +173,11 @@ EXPORT_SYMBOL(pci_find_bus);
  * @from is not %NULL, searches continue from next device on the
  * global list.
  */
+/*
+ * called by:
+ *   - drivers/pci/pci-sysfs.c|425| <<rescan_store>> while ((b = pci_find_next_bus(b)) != NULL)
+ *   - drivers/pci/search.c|141| <<pci_find_bus>> while ((bus = pci_find_next_bus(bus)) != NULL) {
+ */
 struct pci_bus *pci_find_next_bus(const struct pci_bus *from)
 {
 	struct list_head *n;
diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index ff0d8c6..2b131f6 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -70,6 +70,24 @@ static struct class shost_class = {
  *	Returns zero if unsuccessful or an error if the requested
  *	transition is illegal.
  **/
+/*
+ * called by:
+ *   - drivers/scsi/hosts.c|169| <<scsi_remove_host>> if (scsi_host_set_state(shost, SHOST_CANCEL))
+ *   - drivers/scsi/hosts.c|170| <<scsi_remove_host>> if (scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY)) {
+ *   - drivers/scsi/hosts.c|184| <<scsi_remove_host>> if (scsi_host_set_state(shost, SHOST_DEL))
+ *   - drivers/scsi/hosts.c|185| <<scsi_remove_host>> BUG_ON(scsi_host_set_state(shost, SHOST_DEL_RECOVERY));
+ *   - drivers/scsi/hosts.c|277| <<scsi_add_host_with_dma>> scsi_host_set_state(shost, SHOST_RUNNING);
+ *   - drivers/scsi/scsi_error.c|90| <<scsi_schedule_eh>> if (scsi_host_set_state(shost, SHOST_RECOVERY) == 0 ||
+ *   - drivers/scsi/scsi_error.c|91| <<scsi_schedule_eh>> scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY) == 0) {
+ *   - drivers/scsi/scsi_error.c|257| <<scsi_eh_scmd_add>> if (scsi_host_set_state(shost, SHOST_RECOVERY)) {
+ *   - drivers/scsi/scsi_error.c|258| <<scsi_eh_scmd_add>> ret = scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY);
+ *   - drivers/scsi/scsi_error.c|2006| <<scsi_restart_operations>> if (scsi_host_set_state(shost, SHOST_RUNNING))
+ *   - drivers/scsi/scsi_error.c|2007| <<scsi_restart_operations>> if (scsi_host_set_state(shost, SHOST_CANCEL))
+ *   - drivers/scsi/scsi_error.c|2008| <<scsi_restart_operations>> BUG_ON(scsi_host_set_state(shost, SHOST_DEL));
+ *   - drivers/scsi/scsi_error.c|2031| <<scsi_restart_operations>> if (scsi_host_set_state(shost, SHOST_RECOVERY))
+ *   - drivers/scsi/scsi_error.c|2032| <<scsi_restart_operations>> WARN_ON(scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY));
+ *   - drivers/scsi/scsi_sysfs.c|216| <<store_shost_state>> if (scsi_host_set_state(shost, state))
+ */
 int scsi_host_set_state(struct Scsi_Host *shost, enum scsi_host_state state)
 {
 	enum scsi_host_state oldstate = shost->shost_state;
@@ -204,6 +222,32 @@ EXPORT_SYMBOL(scsi_remove_host);
  * Return value: 
  * 	0 on success / != 0 for error
  **/
+/*
+ * [0] scsi_add_host_with_dma
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/ata/libata-scsi.c|4535| <<ata_scsi_add_hosts>> rc = scsi_add_host_with_dma(ap->scsi_host,
+ *   - drivers/firewire/sbp2.c|1150| <<sbp2_probe>> if (scsi_add_host_with_dma(shost, &unit->device,
+ *   - drivers/scsi/bfa/bfad_im.c|571| <<bfad_im_scsi_host_alloc>> error = scsi_add_host_with_dma(im_port->shost, dev, &bfad->pcidev->dev);
+ *   - drivers/scsi/csiostor/csio_init.c|647| <<csio_shost_init>> if (scsi_add_host_with_dma(shost, dev, &hw->pdev->dev))
+ *   - drivers/scsi/lpfc/lpfc_init.c|4350| <<lpfc_create_port>> error = scsi_add_host_with_dma(shost, dev, &phba->pcidev->dev);
+ *   - drivers/scsi/qla2xxx/qla_attr.c|2855| <<qla24xx_vport_create>> if (scsi_add_host_with_dma(vha->host, &fc_vport->dev,
+ *   - include/scsi/scsi_host.h|738| <<scsi_add_host>> return scsi_add_host_with_dma(host, dev, dev);
+ */
 int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 			   struct device *dma_dev)
 {
@@ -365,6 +409,9 @@ static struct device_type scsi_host_type = {
  * Return value:
  * 	Pointer to a new Scsi_Host
  **/
+/*
+ * 会把分配的Scsi_Host->hostt设置为参数的struct scsi_host_template
+ */
 struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 {
 	struct Scsi_Host *shost;
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 7bedbe8..83a1c05 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -823,6 +823,12 @@ iscsi_sw_tcp_conn_get_stats(struct iscsi_cls_conn *cls_conn,
 	iscsi_tcp_conn_get_stats(cls_conn, stats);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_transport_iscsi.c|2699| <<iscsi_if_create_session>> session = transport->create_session(ep, cmds_max, queue_depth,
+ *
+ * struct iscsi_transport iscsi_sw_tcp_transport.create_session = iscsi_sw_tcp_session_create()
+ */
 static struct iscsi_cls_session *
 iscsi_sw_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,
 			    uint16_t qdepth, uint32_t initial_cmdsn)
@@ -956,6 +962,10 @@ static int iscsi_sw_tcp_slave_configure(struct scsi_device *sdev)
 	return 0;
 }
 
+/*
+ * used only by:
+ *   - drivers/scsi/iscsi_tcp.c|840| <<iscsi_sw_tcp_session_create>> shost = iscsi_host_alloc(&iscsi_sw_tcp_sht,
+ */
 static struct scsi_host_template iscsi_sw_tcp_sht = {
 	.module			= THIS_MODULE,
 	.name			= "iSCSI Initiator over TCP/IP",
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 65d0a10..7b3e422 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -233,6 +233,10 @@ void scsi_queue_insert(struct scsi_cmnd *cmd, int reason)
  * Returns the scsi_cmnd result field if a command was executed, or a negative
  * Linux error code if we didn't get that far.
  */
+/*
+ * called by only:
+ *   - include/scsi/scsi_device.h|442| <<scsi_execute>> __scsi_execute(sdev, cmd, data_direction, buffer, bufflen, \
+ */
 int __scsi_execute(struct scsi_device *sdev, const unsigned char *cmd,
 		 int data_direction, void *buffer, unsigned bufflen,
 		 unsigned char *sense, struct scsi_sense_hdr *sshdr,
@@ -1134,6 +1138,40 @@ void scsi_init_command(struct scsi_device *dev, struct scsi_cmnd *cmd)
 	scsi_add_cmd_to_list(cmd);
 }
 
+/*
+ * [0] scsi_setup_scsi_cmnd
+ * [0] scsi_queue_rq
+ * [0] blk_mq_dispatch_rq_list
+ * [0] blk_mq_sched_dispatch_requests
+ * [0] __blk_mq_run_hw_queue
+ * [0] __blk_mq_delay_run_hw_queue
+ * [0] blk_mq_run_hw_queue
+ * [0] blk_mq_sched_insert_request
+ * [0] blk_execute_rq
+ * [0] __scsi_execute
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1208| <<scsi_setup_cmnd>> return scsi_setup_scsi_cmnd(sdev, req);
+ */
 static blk_status_t scsi_setup_scsi_cmnd(struct scsi_device *sdev,
 		struct request *req)
 {
@@ -1166,11 +1204,22 @@ static blk_status_t scsi_setup_scsi_cmnd(struct scsi_device *sdev,
  * Setup a normal block command.  These are simple request from filesystems
  * that still need to be translated to SCSI CDBs from the ULD.
  */
+/*
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1200| <<scsi_setup_cmnd>> return scsi_setup_fs_cmnd(sdev, req);
+ */
 static blk_status_t scsi_setup_fs_cmnd(struct scsi_device *sdev,
 		struct request *req)
 {
 	struct scsi_cmnd *cmd = blk_mq_rq_to_pdu(req);
 
+	/*
+	 * prep_fn设置的地方:
+	 *   - drivers/scsi/device_handler/scsi_dh_alua.c|1151| <<global>> .prep_fn = alua_prep_fn,
+	 *   - drivers/scsi/device_handler/scsi_dh_emc.c|520| <<global>> .prep_fn = clariion_prep_fn,
+	 *   - drivers/scsi/device_handler/scsi_dh_hp_sw.c|243| <<global>> .prep_fn = hp_sw_prep_fn,
+	 *   - drivers/scsi/device_handler/scsi_dh_rdac.c|790| <<global>> .prep_fn = rdac_prep_fn,
+	 */
 	if (unlikely(sdev->handler && sdev->handler->prep_fn)) {
 		blk_status_t ret = sdev->handler->prep_fn(sdev, req);
 		if (ret != BLK_STS_OK)
@@ -1179,9 +1228,18 @@ static blk_status_t scsi_setup_fs_cmnd(struct scsi_device *sdev,
 
 	cmd->cmnd = scsi_req(req)->cmd = scsi_req(req)->__cmd;
 	memset(cmd->cmnd, 0, BLK_MAX_CDB);
+	/*
+	 * sd_init_command()
+	 */
 	return scsi_cmd_to_driver(cmd)->init_command(cmd);
 }
 
+/*
+ * called by only:
+ *   - drivers/scsi/scsi_lib.c|1628| <<scsi_mq_prep_fn>> return scsi_setup_cmnd(sdev, req);
+ *
+ * scsi_queue_rq() --> scsi_mq_prep_fn() --> scsi_setup_cmnd()
+ */
 static blk_status_t scsi_setup_cmnd(struct scsi_device *sdev,
 		struct request *req)
 {
@@ -1282,6 +1340,10 @@ static inline int scsi_dev_queue_ready(struct request_queue *q,
  * scsi_target_queue_ready: checks if there we can send commands to target
  * @sdev: scsi device on starget to check.
  */
+/*
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1642| <<scsi_queue_rq>> if (!scsi_target_queue_ready(shost, sdev))
+ */
 static inline int scsi_target_queue_ready(struct Scsi_Host *shost,
 					   struct scsi_device *sdev)
 {
@@ -1337,6 +1399,10 @@ static inline int scsi_target_queue_ready(struct Scsi_Host *shost,
  * return 0. We must end up running the queue again whenever 0 is
  * returned, else IO can hang.
  */
+/*
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1644| <<scsi_queue_rq>> if (!scsi_host_queue_ready(q, shost, sdev))
+ */
 static inline int scsi_host_queue_ready(struct request_queue *q,
 				   struct Scsi_Host *shost,
 				   struct scsi_device *sdev)
@@ -1467,6 +1533,18 @@ static void scsi_softirq_done(struct request *rq)
  * Return: nonzero return request was rejected and device's queue needs to be
  * plugged.
  */
+/*
+ * called only by:
+ *   - drivers/scsi/scsi_lib.c|1665| <<scsi_queue_rq>> reason = scsi_dispatch_cmd(cmd);
+ *
+ * 对于virtio_scsi, 在没有CONFIG_BLK_DEV_INTEGRITY的情况下,
+ * 分配的request成了
+ *
+ * struct request
+ * struct scsi_cmnd
+ * struct virtio_scsi_cmd
+ * 若干个sizeof(struct scatterlist)总的size
+ */
 static int scsi_dispatch_cmd(struct scsi_cmnd *cmd)
 {
 	struct Scsi_Host *host = cmd->device->host;
@@ -1542,12 +1620,44 @@ static int scsi_dispatch_cmd(struct scsi_cmnd *cmd)
 }
 
 /* Size in bytes of the sg-list stored in the scsi-mq command-private data. */
+/*
+ * 返回的应该是若干个sizeof(struct scatterlist)总的size
+ */
 static unsigned int scsi_mq_sgl_size(struct Scsi_Host *shost)
 {
+	/*
+	 * struct scatterlist {
+	 *         unsigned long   page_link;
+	 *         unsigned int    offset;
+	 *         unsigned int    length;
+	 *         dma_addr_t      dma_address;
+	 * #ifdef CONFIG_NEED_SG_DMA_LENGTH
+	 *         unsigned int    dma_length;
+	 * #endif
+	 * };
+	 */
+
+	/*
+	 * shost->sg_tablesize在virtscsi_probe()设置的例子:
+	 * sg_elems = virtscsi_config_get(vdev, seg_max) ?: 1;
+	 * shost->sg_tablesize = sg_elems;
+	 *
+	 * The maximum number of SG segments that we will put inside a
+	 * scatterlist (unless chaining is used). Should ideally fit inside a
+	 * single page, to avoid a higher order allocation.  We could define this
+	 * to SG_MAX_SINGLE_ALLOC to pack correctly at the highest order.  The
+	 * minimum value is 32
+	 *
+	 * 这里'*'的前面应该是scatterlist的数目
+	 */
 	return min_t(unsigned int, shost->sg_tablesize, SG_CHUNK_SIZE) *
 		sizeof(struct scatterlist);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_lib.c|1717| <<scsi_queue_rq>> ret = scsi_mq_prep_fn(req);
+ */
 static blk_status_t scsi_mq_prep_fn(struct request *req)
 {
 	struct scsi_cmnd *cmd = blk_mq_rq_to_pdu(req);
@@ -1613,9 +1723,30 @@ static bool scsi_mq_get_budget(struct blk_mq_hw_ctx *hctx)
 	return false;
 }
 
+/*
+ * called by:
+ *   - lock/blk-mq.c|1283| <<blk_mq_dispatch_rq_list>> ret = q->mq_ops->queue_rq(hctx, &bd);
+ *   - block/blk-mq.c|1823| <<__blk_mq_issue_directly>> ret = q->mq_ops->queue_rq(hctx, &bd);
+ */
 static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
 			 const struct blk_mq_queue_data *bd)
 {
+	/*
+	 * scsi的tag_set.cmd_size初始化
+	 *
+	 * sgl_size = scsi_mq_sgl_size(shost);
+	 * cmd_size = sizeof(struct scsi_cmnd) + shost->hostt->cmd_size + sgl_size;
+	 * if (scsi_host_get_prot(shost))
+	 *       cmd_size += sizeof(struct scsi_data_buffer) + sgl_size;
+	 *
+	 * 对于virtio_scsi, 在没有CONFIG_BLK_DEV_INTEGRITY的情况下,
+	 * 分配的request成了
+	 *
+	 * struct request
+	 * struct scsi_cmnd
+	 * struct virtio_scsi_cmd
+	 * 若干个sizeof(struct scatterlist)总的size
+	 */
 	struct request *req = bd->rq;
 	struct request_queue *q = req->q;
 	struct scsi_device *sdev = q->queuedata;
@@ -1650,6 +1781,9 @@ static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
 		blk_mq_start_request(req);
 	}
 
+	/*
+	 * 猜测默认是1
+	 */
 	if (sdev->simple_tags)
 		cmd->flags |= SCMD_TAGGED;
 	else
@@ -1699,6 +1833,13 @@ static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,
 	return ret;
 }
 
+/*
+ * called by:
+ *   - block/blk-mq.c|853| <<blk_mq_rq_timed_out>> ret = req->q->mq_ops->timeout(req, reserved);
+ *
+ * 只在以下使用:
+ *   - struct blk_mq_ops scsi_mq_ops.timeout = scsi_timeout
+ */
 static enum blk_eh_timer_return scsi_timeout(struct request *req,
 		bool reserved)
 {
@@ -1788,6 +1929,11 @@ void __scsi_init_queue(struct Scsi_Host *shost, struct request_queue *q)
 }
 EXPORT_SYMBOL_GPL(__scsi_init_queue);
 
+/*
+ * used by:
+ *   - drivers/scsi/scsi_lib.c|1836| <<scsi_mq_setup_tags>> shost->tag_set.ops = &scsi_mq_ops;
+ *   - drivers/scsi/scsi_lib.c|1865| <<scsi_device_from_queue>> if (q->mq_ops == &scsi_mq_ops)
+ */
 static const struct blk_mq_ops scsi_mq_ops = {
 	.get_budget	= scsi_mq_get_budget,
 	.put_budget	= scsi_mq_put_budget,
@@ -1804,8 +1950,37 @@ static const struct blk_mq_ops scsi_mq_ops = {
 	.map_queues	= scsi_map_queues,
 };
 
+/*
+ * [0] scsi_mq_alloc_queue
+ * [0] scsi_alloc_sdev
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver   
+ * [0] driver_register  
+ * [0] init
+ * [0] do_one_initcall  
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|269| <<scsi_alloc_sdev>> sdev->request_queue = scsi_mq_alloc_queue(sdev);
+ */
 struct request_queue *scsi_mq_alloc_queue(struct scsi_device *sdev)
 {
+	/*
+	 * 每个struct scsi_devic一个request_queue
+	 */
 	sdev->request_queue = blk_mq_init_queue(&sdev->host->tag_set);
 	if (IS_ERR(sdev->request_queue))
 		return NULL;
@@ -1816,19 +1991,55 @@ struct request_queue *scsi_mq_alloc_queue(struct scsi_device *sdev)
 	return sdev->request_queue;
 }
 
+/*
+ * called by:
+ *   - rivers/scsi/hosts.c|226| <<scsi_add_host_with_dma>> error = scsi_mq_setup_tags(shost);
+ */
 int scsi_mq_setup_tags(struct Scsi_Host *shost)
 {
 	unsigned int cmd_size, sgl_size;
 
+	/*
+	 * 返回的应该是若干个sizeof(struct scatterlist)总的size
+	 *
+	 * 用到了shost->sg_tablesize
+	 */
 	sgl_size = scsi_mq_sgl_size(shost);
+	/*
+	 * struct scsi_host_template virtscsi_host_template.cmd_size = sizeof(virtio_scsi_cmd)
+	 */
 	cmd_size = sizeof(struct scsi_cmnd) + shost->hostt->cmd_size + sgl_size;
+	/*
+	 * 如果CONFIG_BLK_DEV_INTEGRITY设置了, scsi_host_get_prot(shost)才返回true
+	 */
 	if (scsi_host_get_prot(shost))
 		cmd_size += sizeof(struct scsi_data_buffer) + sgl_size;
 
+	/*
+	 * 对于virtio_scsi, 上面结束后cmd_size大概是 (假设没有CONFIG_BLK_DEV_INTEGRITY)
+	 *
+	 * struct scsi_cmnd
+	 * struct virtio_scsi_cmd
+	 * 若干个sizeof(struct scatterlist)总的size
+	 */
+
 	memset(&shost->tag_set, 0, sizeof(shost->tag_set));
 	shost->tag_set.ops = &scsi_mq_ops;
 	shost->tag_set.nr_hw_queues = shost->nr_hw_queues ? : 1;
 	shost->tag_set.queue_depth = shost->can_queue;
+	/*
+	 * tag_set.cmd_size用的地方:
+	 *   - block/blk-mq.c|2196| <<blk_mq_alloc_rqs>> rq_size = round_up(sizeof(struct request) + set->cmd_size,
+	 *   - block/blk-mq.c|2417| <<blk_mq_alloc_hctx>> hctx->fq = blk_alloc_flush_queue(q, hctx->numa_node, set->cmd_size,
+	 *
+	 * 对于virtio_scsi, 在没有CONFIG_BLK_DEV_INTEGRITY的情况下,
+	 * 分配的request成了
+	 *
+	 * struct request
+	 * struct scsi_cmnd
+	 * struct virtio_scsi_cmd
+	 * 若干个sizeof(struct scatterlist)总的size
+	 */
 	shost->tag_set.cmd_size = cmd_size;
 	shost->tag_set.numa_node = NUMA_NO_NODE;
 	shost->tag_set.flags = BLK_MQ_F_SHOULD_MERGE;
diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 058079f..d82eaad3 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -85,6 +85,10 @@ static const char *scsi_null_device_strs = "nullnullnullnull";
 
 #define MAX_SCSI_LUNS	512
 
+/*
+ * called by only:
+ *   - drivers/scsi/scsi_scan.c|1304| <<scsi_sequential_lun_scan>> max_dev_lun = min(max_scsi_luns, shost->max_lun);
+ */
 static u64 max_scsi_luns = MAX_SCSI_LUNS;
 
 module_param_named(max_luns, max_scsi_luns, ullong, S_IRUGO|S_IWUSR);
@@ -114,11 +118,33 @@ MODULE_PARM_DESC(inq_timeout,
 
 /* This lock protects only this list */
 static DEFINE_SPINLOCK(async_scan_lock);
+/*
+ * used by:
+ *   - drivers/scsi/scsi_scan.c|138| <<scsi_complete_async_scans>> if (list_empty(&scanning_hosts))
+ *   - drivers/scsi/scsi_scan.c|154| <<scsi_complete_async_scans>> if (list_empty(&scanning_hosts))
+ *   - drivers/scsi/scsi_scan.c|156| <<scsi_complete_async_scans>> list_add_tail(&data->list, &scanning_hosts);
+ *   - drivers/scsi/scsi_scan.c|164| <<scsi_complete_async_scans>> if (!list_empty(&scanning_hosts)) {
+ *   - drivers/scsi/scsi_scan.c|165| <<scsi_complete_async_scans>> struct async_scan_data *next = list_entry(scanning_hosts.next,
+ *   - drivers/scsi/scsi_scan.c|1857| <<scsi_prep_async_scan>> if (list_empty(&scanning_hosts))
+ *   - drivers/scsi/scsi_scan.c|1859| <<scsi_prep_async_scan>> list_add_tail(&data->list, &scanning_hosts);
+ *   - drivers/scsi/scsi_scan.c|1908| <<scsi_finish_async_scan>> if (!list_empty(&scanning_hosts)) {
+ *   - drivers/scsi/scsi_scan.c|1909| <<scsi_finish_async_scan>> struct async_scan_data *next = list_entry(scanning_hosts.next,
+ */
 static LIST_HEAD(scanning_hosts);
 
 struct async_scan_data {
 	struct list_head list;
 	struct Scsi_Host *shost;
+	/*
+	 * used by:
+	 *   - drivers/scsi/scsi_scan.c|173| <<scsi_complete_async_scans>> init_completion(&data->prev_finished);
+	 *   - drivers/scsi/scsi_scan.c|183| <<scsi_complete_async_scans>> wait_for_completion(&data->prev_finished);
+	 *   - drivers/scsi/scsi_scan.c|190| <<scsi_complete_async_scans>> complete(&next->prev_finished);
+	 *   - drivers/scsi/scsi_scan.c|1871| <<scsi_prep_async_scan>> init_completion(&data->prev_finished);
+	 *   - drivers/scsi/scsi_scan.c|1881| <<scsi_prep_async_scan>> complete(&data->prev_finished);
+	 *   - drivers/scsi/scsi_scan.c|1919| <<scsi_finish_async_scan>> wait_for_completion(&data->prev_finished);
+	 *   - drivers/scsi/scsi_scan.c|1934| <<scsi_finish_async_scan>> complete(&next->prev_finished);
+	 */
 	struct completion prev_finished;
 };
 
@@ -130,6 +156,13 @@ struct async_scan_data {
  * started scanning after this function was called may or may not have
  * finished.
  */
+/*
+ * called by:
+ *   - drivers/scsi/scsi_pm.c|185| <<scsi_bus_prepare>> scsi_complete_async_scans();
+ *   - drivers/scsi/scsi_scan.c|1573| <<__scsi_add_device>> scsi_complete_async_scans();
+ *   - drivers/scsi/scsi_scan.c|1718| <<scsi_scan_target>> scsi_complete_async_scans();
+ *   - drivers/scsi/scsi_scan.c|1786| <<scsi_scan_host_selected>> scsi_complete_async_scans();
+ */
 int scsi_complete_async_scans(void)
 {
 	struct async_scan_data *data;
@@ -212,6 +245,39 @@ static void scsi_unlock_floptical(struct scsi_device *sdev,
  * Return value:
  *     scsi_Device pointer, or NULL on failure.
  **/
+/*
+ * [0] scsi_alloc_sdev
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1078| <<scsi_probe_and_add_lun>> sdev = scsi_alloc_sdev(starget, lun, hostdata);
+ *   - drivers/scsi/scsi_scan.c|1324| <<scsi_report_lun_scan>> sdev = scsi_alloc_sdev(starget, 0, NULL);
+ *   - drivers/scsi/scsi_scan.c|1911| <<scsi_get_host_dev>> sdev = scsi_alloc_sdev(starget, 0, NULL);
+ *
+ * 在测试的时候用了一个virtio_scsi的host上的两个lun (相同channel和target)
+ * 发现这个函数被host=0, channel=0为0-255个target都在调用
+ * 其中channel=0调用2次, 因为有2个lun
+ *
+ * 会把scsi_target->lun设置为参数的lun
+ */
 static struct scsi_device *scsi_alloc_sdev(struct scsi_target *starget,
 					   u64 lun, void *hostdata)
 {
@@ -280,6 +346,9 @@ static struct scsi_device *scsi_alloc_sdev(struct scsi_target *starget,
 	scsi_change_queue_depth(sdev, sdev->host->cmd_per_lun ?
 					sdev->host->cmd_per_lun : 1);
 
+	/*
+	 * 为scsi_device->sdev_gendev.bus设置为&scsi_bus_type
+	 */
 	scsi_sysfs_device_initialize(sdev);
 
 	if (shost->hostt->slave_alloc) {
@@ -407,6 +476,34 @@ static void scsi_target_reap_ref_put(struct scsi_target *starget)
  * The target is returned with an incremented reference, so the caller
  * is responsible for both reaping and doing a last put
  */
+/*
+ * 测试的时候用了2个lun, 在同一个host,channel,target上
+ * 结果在channel=0上为256个target各调用一次
+ * [0] scsi_alloc_target
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1512| <<__scsi_add_device>> starget = scsi_alloc_target(parent, channel, id);
+ *   - drivers/scsi/scsi_scan.c|1593| <<__scsi_scan_target>> starget = scsi_alloc_target(parent, channel, id);
+ *   - drivers/scsi/scsi_scan.c|1960| <<scsi_get_host_dev>> starget = scsi_alloc_target(&shost->shost_gendev, 0, shost->this_id);
+ */
 static struct scsi_target *scsi_alloc_target(struct device *parent,
 					     int channel, uint id)
 {
@@ -557,6 +654,22 @@ EXPORT_SYMBOL(scsi_sanitize_inquiry_string);
  *     INQUIRY data is in @inq_result; the scsi_level and INQUIRY length
  *     are copied to the scsi_device any flags value is stored in *@bflags.
  **/
+/*
+ * virtio_scsi初始化
+ *
+ * virtscsi_probe()
+ *   -> scsi_add_host()
+ *   -> scsi_scan_host()
+ *
+ * scan host的时候会为每一个lun分配一个struct scsi_device
+ * 还有request_queue, 链接入tagset的tag_set_list
+ * 然后add device
+ *
+ * scsi定义了一条scsi busi_type: scsi_bus_type in drivers/scsi/scsi_sysfs.c
+ *
+ * 上面add的device会被sd的sd_probe()初始化
+ * 在sd_probe()分配gendisk和scsi_disk
+ */
 static int scsi_probe_lun(struct scsi_device *sdev, unsigned char *inq_result,
 			  int result_len, blist_flags_t *bflags)
 {
@@ -761,6 +874,10 @@ static int scsi_probe_lun(struct scsi_device *sdev, unsigned char *inq_result,
  *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a scsi_device
  *     SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized
  **/
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1280| <<scsi_probe_and_add_lun>> res = scsi_add_lun(sdev, result, &bflags, shost->async_scan);
+ */
 static int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,
 		blist_flags_t *bflags, int async)
 {
@@ -1040,6 +1157,40 @@ static unsigned char *scsi_inq_str(unsigned char *buf, unsigned char *inq,
  *         attached at the LUN
  *   - SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized
  **/
+/*
+ * virtio_scsi的例子, 调用了好多好多遍, 似乎为每一个target都调用了
+ * [0] blk_mq_add_queue_tag_set
+ * [0] blk_mq_init_allocated_queue
+ * [0] blk_mq_init_queue
+ * [0] scsi_mq_alloc_queue
+ * [0] scsi_alloc_sdev
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1269| <<scsi_sequential_lun_scan>> if ((scsi_probe_and_add_lun(starget, lun, NULL, NULL, rescan,
+ *   - drivers/scsi/scsi_scan.c|1439| <<scsi_report_lun_scan>> res = scsi_probe_and_add_lun(starget,
+ *   - drivers/scsi/scsi_scan.c|1486| <<__scsi_add_device>> scsi_probe_and_add_lun(starget, lun, NULL, &sdev, 1, hostdata);
+ *   - drivers/scsi/scsi_scan.c|1566| <<__scsi_scan_target>> scsi_probe_and_add_lun(starget, lun, NULL, NULL, rescan, NULL);
+ *   - drivers/scsi/scsi_scan.c|1574| <<__scsi_scan_target>> res = scsi_probe_and_add_lun(starget, 0, &bflags, NULL, rescan, NULL);
+ */
 static int scsi_probe_and_add_lun(struct scsi_target *starget,
 				  u64 lun, blist_flags_t *bflagsp,
 				  struct scsi_device **sdevp,
@@ -1056,6 +1207,7 @@ static int scsi_probe_and_add_lun(struct scsi_target *starget,
 	 * The rescan flag is used as an optimization, the first scan of a
 	 * host adapter calls into here with rescan == 0.
 	 */
+	/* sdev是scsi_device, 每个lun一个 */
 	sdev = scsi_device_lookup_by_target(starget, lun);
 	if (sdev) {
 		if (rescan != SCSI_SCAN_INITIAL || !scsi_device_created(sdev)) {
@@ -1076,6 +1228,11 @@ static int scsi_probe_and_add_lun(struct scsi_target *starget,
 		scsi_device_put(sdev);
 	} else
 		sdev = scsi_alloc_sdev(starget, lun, hostdata);
+	/*
+	 * 上面调用的scsi_alloc_sdev()会把request_queue加入到tag的tag_set_list
+	 *
+	 * 会把scsi_target->lun设置为参数的lun
+	 */
 	if (!sdev)
 		goto out;
 
@@ -1084,6 +1241,9 @@ static int scsi_probe_and_add_lun(struct scsi_target *starget,
 	if (!result)
 		goto out_free_sdev;
 
+	/*
+	 * 如果lun不存在, 跳到out_free_result, 会把request_queue在tag_list删除!
+	 */
 	if (scsi_probe_lun(sdev, result, result_len, &bflags))
 		goto out_free_result;
 
@@ -1194,6 +1354,12 @@ static int scsi_probe_and_add_lun(struct scsi_target *starget,
  *
  *     Modifies sdevscan->lun.
  **/
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1617| <<__scsi_scan_target>> scsi_sequential_lun_scan(starget, bflags,
+ *
+ * 在virtio_scsi上2个lun的情况下没调用
+ */
 static void scsi_sequential_lun_scan(struct scsi_target *starget,
 				     blist_flags_t bflags, int scsi_level,
 				     enum scsi_scan_mode rescan)
@@ -1286,6 +1452,30 @@ static void scsi_sequential_lun_scan(struct scsi_target *starget,
  *     0: scan completed (or no memory, so further scanning is futile)
  *     1: could not scan with REPORT LUN
  **/
+/*
+ * [0] scsi_report_lun_scan
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1699| <<__scsi_scan_target>> if (scsi_report_lun_scan(starget, bflags, rescan) != 0)
+ */
 static int scsi_report_lun_scan(struct scsi_target *starget, blist_flags_t bflags,
 				enum scsi_scan_mode rescan)
 {
@@ -1411,6 +1601,9 @@ static int scsi_report_lun_scan(struct scsi_target *starget, blist_flags_t bflag
 	}
 	length = get_unaligned_be32(lun_data->scsi_lun);
 
+	/*
+	 * virtio_scsi配置两个lun时返回2
+	 */
 	num_luns = (length / sizeof(struct scsi_lun));
 
 	SCSI_LOG_SCAN_BUS(3, sdev_printk (KERN_INFO, sdev,
@@ -1528,6 +1721,12 @@ void scsi_rescan_device(struct device *dev)
 }
 EXPORT_SYMBOL(scsi_rescan_device);
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1619| <<scsi_scan_target>> __scsi_scan_target(parent, channel, id, lun, rescan);
+ *   - drivers/scsi/scsi_scan.c|1650| <<scsi_scan_channel>> __scsi_scan_target(&shost->shost_gendev, channel,
+ *   - drivers/scsi/scsi_scan.c|1654| <<scsi_scan_channel>> __scsi_scan_target(&shost->shost_gendev, channel,
+ */
 static void __scsi_scan_target(struct device *parent, unsigned int channel,
 		unsigned int id, u64 lun, enum scsi_scan_mode rescan)
 {
@@ -1559,13 +1758,23 @@ static void __scsi_scan_target(struct device *parent, unsigned int channel,
 	 * Scan LUN 0, if there is some response, scan further. Ideally, we
 	 * would not configure LUN 0 until all LUNs are scanned.
 	 */
+	/*
+	 * 对于virtio_scsi这里为每个可能的target都调用了
+	 * 针对lun = 0
+	 */
 	res = scsi_probe_and_add_lun(starget, 0, &bflags, NULL, rescan, NULL);
 	if (res == SCSI_SCAN_LUN_PRESENT || res == SCSI_SCAN_TARGET_PRESENT) {
+		/*
+		 * 对于virtio_scsi来说, 这里针对剩下的lun
+		 */
 		if (scsi_report_lun_scan(starget, bflags, rescan) != 0)
 			/*
 			 * The REPORT LUN did not scan the target,
 			 * do a sequential scan.
 			 */
+			/*
+			 * virtio_scsi并没有到这里
+			 */
 			scsi_sequential_lun_scan(starget, bflags,
 						 starget->scsi_level, rescan);
 	}
@@ -1623,12 +1832,21 @@ void scsi_scan_target(struct device *parent, unsigned int channel,
 }
 EXPORT_SYMBOL(scsi_scan_target);
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1679| <<scsi_scan_host_selected>> scsi_scan_channel(shost, channel, id, lun,
+ *   - drivers/scsi/scsi_scan.c|1682| <<scsi_scan_host_selected>> scsi_scan_channel(shost, channel, id, lun, rescan);
+ */
 static void scsi_scan_channel(struct Scsi_Host *shost, unsigned int channel,
 			      unsigned int id, u64 lun,
 			      enum scsi_scan_mode rescan)
 {
 	uint order_id;
 
+	/*
+	 * virtio_scsi的target的数量:
+	 *   - drivers/scsi/virtio_scsi.c|923| <<virtscsi_probe>> shost->max_id = num_targets;
+	 */
 	if (id == SCAN_WILD_CARD)
 		for (id = 0; id < shost->max_id; ++id) {
 			/*
@@ -1655,6 +1873,12 @@ static void scsi_scan_channel(struct Scsi_Host *shost, unsigned int channel,
 				id, lun, rescan);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_proc.c|255| <<scsi_add_single_device>> error = scsi_scan_host_selected(shost, channel, id, lun,
+ *   - drivers/scsi/scsi_scan.c|1924| <<do_scsi_scan_host>> scsi_scan_host_selected(shost, SCAN_WILD_CARD, SCAN_WILD_CARD,
+ *   - drivers/scsi/scsi_sysfs.c|150| <<scsi_scan>> res = scsi_scan_host_selected(shost, channel, id, lun,
+ */
 int scsi_scan_host_selected(struct Scsi_Host *shost, unsigned int channel,
 			    unsigned int id, u64 lun,
 			    enum scsi_scan_mode rescan)
@@ -1673,6 +1897,12 @@ int scsi_scan_host_selected(struct Scsi_Host *shost, unsigned int channel,
 		scsi_complete_async_scans();
 
 	if (scsi_host_scan_allowed(shost) && scsi_autopm_get_host(shost) == 0) {
+		/*
+		 * 在virtio_scsi上channel == SCAN_WILD_CARD
+		 * 
+		 * virtio_scsi的shost->max_channel是0
+		 *   - drivers/scsi/virtio_scsi.c|924| <<virtscsi_probe>> shost->max_channel = 0;
+		 */
 		if (channel == SCAN_WILD_CARD)
 			for (channel = 0; channel <= shost->max_channel;
 			     channel++)
@@ -1713,6 +1943,10 @@ static void scsi_sysfs_add_devices(struct Scsi_Host *shost)
  * that other asynchronous scans started after this one won't affect the
  * ordering of the discovered devices.
  */
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1990| <<scsi_scan_host>> data = scsi_prep_async_scan(shost);
+ */
 static struct async_scan_data *scsi_prep_async_scan(struct Scsi_Host *shost)
 {
 	struct async_scan_data *data;
@@ -1761,6 +1995,10 @@ static struct async_scan_data *scsi_prep_async_scan(struct Scsi_Host *shost)
  * This function announces all the devices it has found to the rest
  * of the system.
  */
+/*
+ * called only by:
+ *   - drivers/scsi/scsi_scan.c|1968| <<do_scan_async>> scsi_finish_async_scan(data);
+ */
 static void scsi_finish_async_scan(struct async_scan_data *data)
 {
 	struct Scsi_Host *shost;
@@ -1804,8 +2042,14 @@ static void scsi_finish_async_scan(struct async_scan_data *data)
 	kfree(data);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1985| <<do_scan_async>> do_scsi_scan_host(shost);
+ *   - drivers/scsi/scsi_scan.c|2011| <<scsi_scan_host>> do_scsi_scan_host(shost);
+ */
 static void do_scsi_scan_host(struct Scsi_Host *shost)
 {
+	/* drivers/scsi/qla2xxx/qla_os.c|7138| <<global>> .scan_finished = qla2xxx_scan_finished, */
 	if (shost->hostt->scan_finished) {
 		unsigned long start = jiffies;
 		if (shost->hostt->scan_start)
@@ -1819,6 +2063,10 @@ static void do_scsi_scan_host(struct Scsi_Host *shost)
 	}
 }
 
+/*
+ * used only by:
+ *   - drivers/scsi/scsi_scan.c|1855| <<scsi_scan_host>> async_schedule(do_scan_async, data);
+ */
 static void do_scan_async(void *_data, async_cookie_t c)
 {
 	struct async_scan_data *data = _data;
@@ -1832,10 +2080,16 @@ static void do_scan_async(void *_data, async_cookie_t c)
  * scsi_scan_host - scan the given adapter
  * @shost:	adapter to scan
  **/
+/*
+ * 被很多调用, virtio_scsi的例子:
+ *   - drivers/scsi/virtio_scsi.c|397| <<virtscsi_handle_event>> scsi_scan_host(virtio_scsi_host(vscsi->vdev));
+ *   - drivers/scsi/virtio_scsi.c|982| <<virtscsi_probe>> scsi_scan_host(shost);
+ */
 void scsi_scan_host(struct Scsi_Host *shost)
 {
 	struct async_scan_data *data;
 
+	/* 假设是"async"吧 */
 	if (strncmp(scsi_scan_type, "none", 4) == 0 ||
 	    strncmp(scsi_scan_type, "manual", 6) == 0)
 		return;
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index dbb206c..e6ca4be 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -522,6 +522,17 @@ static int scsi_bus_uevent(struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
+/*
+ * used by:
+ *   - drivers/scsi/hosts.c|496| <<scsi_host_alloc>> shost->shost_gendev.bus = &scsi_bus_type;
+ *   - drivers/scsi/scsi_proc.c|382| <<next_scsi_device>> struct device *next = bus_find_device(&scsi_bus_type, start, NULL,
+ *   - drivers/scsi/scsi_scan.c|463| <<scsi_alloc_target>> dev->bus = &scsi_bus_type;
+ *   - drivers/scsi/scsi_sysfs.c|539| <<scsi_sysfs_register>> error = bus_register(&scsi_bus_type);
+ *   - drivers/scsi/scsi_sysfs.c|543| <<scsi_sysfs_register>> bus_unregister(&scsi_bus_type);
+ *   - drivers/scsi/scsi_sysfs.c|552| <<scsi_sysfs_unregister>> bus_unregister(&scsi_bus_type);
+ *   - drivers/scsi/scsi_sysfs.c|1508| <<scsi_register_driver>> drv->bus = &scsi_bus_type;
+ *   - drivers/scsi/scsi_sysfs.c|1558| <<scsi_sysfs_device_initialize>> sdev->sdev_gendev.bus = &scsi_bus_type;
+ */
 struct bus_type scsi_bus_type = {
         .name		= "scsi",
         .match		= scsi_bus_match,
@@ -1280,6 +1291,11 @@ static int scsi_target_add(struct scsi_target *starget)
  * Return value:
  * 	0 on Success / non-zero on Failure
  **/
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|1107| <<scsi_add_lun>> if (!async && scsi_sysfs_add_sdev(sdev) != 0)
+ *   - drivers/scsi/scsi_scan.c|1931| <<scsi_sysfs_add_devices>> scsi_sysfs_add_sdev(sdev) != 0)
+ */
 int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 {
 	int error, i;
@@ -1349,6 +1365,43 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 	return error;
 }
 
+/*
+ * 某一个例子:
+ * [0] blk_mq_del_queue_tag_set
+ * [0] blk_mq_exit_queue
+ * [0] blk_cleanup_queue
+ * [0] __scsi_remove_device
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|370| <<scsi_alloc_sdev>> __scsi_remove_device(sdev);
+ *   - drivers/scsi/scsi_scan.c|1329| <<scsi_probe_and_add_lun>> __scsi_remove_device(sdev);
+ *   - drivers/scsi/scsi_scan.c|1334| <<scsi_probe_and_add_lun>> __scsi_remove_device(sdev);
+ *   - drivers/scsi/scsi_scan.c|1514| <<scsi_report_lun_scan>> __scsi_remove_device(sdev);
+ *   - drivers/scsi/scsi_scan.c|1644| <<scsi_report_lun_scan>> __scsi_remove_device(sdev);
+ *   - drivers/scsi/scsi_scan.c|1928| <<scsi_sysfs_add_devices>> __scsi_remove_device(sdev);
+ *   - drivers/scsi/scsi_scan.c|2122| <<scsi_forget_host>> __scsi_remove_device(sdev);
+ *   - drivers/scsi/scsi_scan.c|2181| <<scsi_free_host_dev>> __scsi_remove_device(sdev);
+ *   - drivers/scsi/scsi_sysfs.c|1444| <<scsi_remove_device>> __scsi_remove_device(sdev);
+ */
 void __scsi_remove_device(struct scsi_device *sdev)
 {
 	struct device *dev = &sdev->sdev_gendev;
@@ -1503,6 +1556,15 @@ void scsi_remove_target(struct device *dev)
 }
 EXPORT_SYMBOL(scsi_remove_target);
 
+/*
+ * called by:
+ *   - drivers/scsi/ch.c|1021| <<init_ch_module>> rc = scsi_register_driver(&ch_template.gendrv);
+ *   - drivers/scsi/osst.c|6061| <<init_osst>> err = scsi_register_driver(&osst_template.gendrv);
+ *   - drivers/scsi/sd.c|3729| <<init_sd>> err = scsi_register_driver(&sd_template.gendrv);
+ *   - drivers/scsi/ses.c|860| <<ses_init>> err = scsi_register_driver(&ses_template.gendrv);
+ *   - drivers/scsi/sr.c|1039| <<init_sr>> rc = scsi_register_driver(&sr_template.gendrv);
+ *   - drivers/scsi/st.c|4509| <<init_st>> err = scsi_register_driver(&st_template.gendrv);
+ */
 int scsi_register_driver(struct device_driver *drv)
 {
 	drv->bus = &scsi_bus_type;
@@ -1548,6 +1610,12 @@ static struct device_type scsi_dev_type = {
 	.groups =	scsi_sdev_attr_groups,
 };
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_scan.c|314| <<scsi_alloc_sdev>> scsi_sysfs_device_initialize(sdev);
+ *
+ * 为scsi_device->sdev_gendev.bus设置为&scsi_bus_type
+ */
 void scsi_sysfs_device_initialize(struct scsi_device *sdev)
 {
 	unsigned long flags;
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 417b868..cdd3a42 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -2686,6 +2686,11 @@ int iscsi_session_event(struct iscsi_cls_session *session,
 }
 EXPORT_SYMBOL_GPL(iscsi_session_event);
 
+/*
+ * called by:
+ *   - drivers/scsi/scsi_transport_iscsi.c|3504| <<iscsi_if_recv_msg>> err = iscsi_if_create_session(priv, ep, ev,
+ *   - drivers/scsi/scsi_transport_iscsi.c|3517| <<iscsi_if_recv_msg>> err = iscsi_if_create_session(priv, ep, ev,
+ */
 static int
 iscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_endpoint *ep,
 			struct iscsi_uevent *ev, pid_t pid,
@@ -3472,6 +3477,10 @@ iscsi_get_host_stats(struct iscsi_transport *transport, struct nlmsghdr *nlh)
 }
 
 
+/*
+ * called by only:
+ *   - drivers/scsi/scsi_transport_iscsi.c|3697| <<iscsi_if_rx>> err = iscsi_if_recv_msg(skb, nlh, &group);
+ */
 static int
 iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, uint32_t *group)
 {
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index a3406bd..6ab6201 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -563,7 +563,20 @@ static const struct dev_pm_ops sd_pm_ops = {
 	.runtime_resume		= sd_resume,
 };
 
+/*
+ * used by:
+ *   - drivers/scsi/sd.c|3381| <<sd_probe>> sdkp->driver = &sd_template;
+ *   - drivers/scsi/sd.c|3677| <<init_sd>> err = scsi_register_driver(&sd_template.gendrv);
+ *   - drivers/scsi/sd.c|3711| <<exit_sd>> scsi_unregister_driver(&sd_template.gendrv);
+ */
 static struct scsi_driver sd_template = {
+	/*
+	 * used by:
+	 *   - drivers/scsi/sd.c|3677| <<init_sd>> err = scsi_register_driver(&sd_template.gendrv);
+	 *   - drivers/scsi/sd.c|3711| <<exit_sd>> scsi_unregister_driver(&sd_template.gendrv);
+	 *
+	 * 这个struct device_driver被挂在struct bus_type scsi_bus_type
+	 */
 	.gendrv = {
 		.name		= "sd",
 		.owner		= THIS_MODULE,
@@ -572,6 +585,10 @@ static struct scsi_driver sd_template = {
 		.shutdown	= sd_shutdown,
 		.pm		= &sd_pm_ops,
 	},
+	/*
+	 * called by:
+	 *   - drivers/scsi/scsi_scan.c|1524| <<scsi_rescan_device>> drv->rescan(dev);
+	 */
 	.rescan			= sd_rescan,
 	.init_command		= sd_init_command,
 	.uninit_command		= sd_uninit_command,
@@ -1157,6 +1174,10 @@ static blk_status_t sd_setup_rw6_cmnd(struct scsi_cmnd *cmd, bool write,
 	return BLK_STS_OK;
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/sd.c|1310| <<sd_init_command>> return sd_setup_read_write_cmnd(cmd);
+ */
 static blk_status_t sd_setup_read_write_cmnd(struct scsi_cmnd *cmd)
 {
 	struct request *rq = cmd->request;
@@ -1802,6 +1823,10 @@ static const struct pr_ops sd_pr_ops = {
 	.pr_clear	= sd_pr_clear,
 };
 
+/*
+ * used by only:
+ *   - drivers/scsi/sd.c|3295| <<sd_probe_async>> gd->fops = &sd_fops;
+ */
 static const struct block_device_operations sd_fops = {
 	.owner			= THIS_MODULE,
 	.open			= sd_open,
@@ -3255,6 +3280,10 @@ static int sd_format_disk_name(char *prefix, int index, char *buf, int buflen)
 /*
  * The asynchronous part of sd_probe
  */
+/*
+ * called by only:
+ *   - drivers/scsi/sd.c|3408| <<sd_probe>> async_schedule_domain(sd_probe_async, sdkp, &scsi_sd_probe_domain);
+ */
 static void sd_probe_async(void *data, async_cookie_t cookie)
 {
 	struct scsi_disk *sdkp = data;
@@ -3264,6 +3293,7 @@ static void sd_probe_async(void *data, async_cookie_t cookie)
 	struct device *dev;
 
 	sdp = sdkp->device;
+	/* struct gendisk  *disk */
 	gd = sdkp->disk;
 	index = sdkp->index;
 	dev = &sdp->sdev_gendev;
@@ -3273,6 +3303,9 @@ static void sd_probe_async(void *data, async_cookie_t cookie)
 
 	gd->fops = &sd_fops;
 	gd->private_data = &sdkp->driver;
+	/*
+	 * sdkp->device是struct scsi_device
+	 */
 	gd->queue = sdkp->device->request_queue;
 
 	/* defaults, until the device tells us otherwise */
@@ -3309,6 +3342,10 @@ static void sd_probe_async(void *data, async_cookie_t cookie)
 			sd_printk(KERN_NOTICE, sdkp, "supports TCG Opal\n");
 	}
 
+	/*
+	 * [    0.341475] sd 0:0:0:0: [sda] Attached SCSI disk
+	 * [    0.346937] sd 0:0:0:1: [sdb] Attached SCSI disk
+	 */
 	sd_printk(KERN_NOTICE, sdkp, "Attached SCSI %sdisk\n",
 		  sdp->removable ? "removable " : "");
 	scsi_autopm_put_device(sdp);
@@ -3333,6 +3370,21 @@ static void sd_probe_async(void *data, async_cookie_t cookie)
  *	Assume sd_probe is not re-entrant (for time being)
  *	Also think about sd_probe() and sd_remove() running coincidentally.
  **/
+/*
+ * [0] sd_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init_sd
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ */
 static int sd_probe(struct device *dev)
 {
 	struct scsi_device *sdp = to_scsi_device(dev);
@@ -3361,6 +3413,7 @@ static int sd_probe(struct device *dev)
 	if (!sdkp)
 		goto out;
 
+	/* 分配gendisk? */
 	gd = alloc_disk(SD_MINORS);
 	if (!gd)
 		goto out_free;
@@ -3395,6 +3448,9 @@ static int sd_probe(struct device *dev)
 	device_initialize(&sdkp->dev);
 	sdkp->dev.parent = dev;
 	sdkp->dev.class = &sd_disk_class;
+	/*
+	 * 在virtio_scsi上的dev_name(dev)例子是"0:0:0:0", "0:0:0:1"
+	 */
 	dev_set_name(&sdkp->dev, "%s", dev_name(dev));
 
 	error = device_add(&sdkp->dev);
diff --git a/drivers/scsi/virtio_scsi.c b/drivers/scsi/virtio_scsi.c
index 13f1b3b..e5f70df 100644
--- a/drivers/scsi/virtio_scsi.c
+++ b/drivers/scsi/virtio_scsi.c
@@ -30,10 +30,161 @@
 #include <linux/seqlock.h>
 #include <linux/blk-mq-virtio.h>
 
+/*
+ * virtio_scsi初始化的例子
+ *
+ * -device virtio-scsi-pci,id=scsi0,num_queues=4 \
+ * -device scsi-hd,drive=drive0,bus=scsi0.0,channel=0,scsi-id=0,lun=0 \
+ * -drive file=boot.img,if=none,id=drive0 \
+ * -device scsi-hd,drive=drive1,bus=scsi0.0,channel=0,scsi-id=0,lun=1  \
+ * -drive file=test.img,if=none,id=drive1
+ *
+ * 一个target上2个lun
+ *
+ * virtscsi_probe()
+ *  -> scsi_add_host()
+ *  -> scsi_scan_host()
+ *      -> async_schedule(do_scan_async, data)
+ *
+ * do_scan_async()
+ *  -> do_scsi_scan_host()
+ *      -> scsi_scan_host_selected() ==> 扫描所有的channel, target和lun
+ *          -> scsi_scan_channel() ==> 调用1次, 因为shost->max_channel=0
+ *              -> __scsi_scan_target() ==> 调用256次
+ *                  -> scsi_alloc_target()
+ *                  -> scsi_probe_and_add_lun() ==> 检测lun=0
+ *                      -> scsi_alloc_sdev()
+ *                         会分配并把request_queue放入tagset的tag_list
+ *                         如果最终lun不存在会再被scsi_probe_and_add_lun()->__scsi_remove_device()移除
+ *                      -> scsi_probe_lun()
+ *                          -> scsi_sysfs_add_sdev()
+ *                              -> device_add()
+ *                  -> scsi_report_lun_scan() ==> 检测剩下的lun, 上面scsi_probe_and_add_lun()失败就不执行这里了*
+ *
+ * 
+ * 总结上面, scan host的时候会为每一个lun分配一个struct scsi_device
+ * 还有request_queue, 链接入tagset的tag_set_list
+ * 然后add device
+ *
+ * scsi定义了一条scsi busi_type: scsi_bus_type in drivers/scsi/scsi_sysfs.c
+ *
+ * 上面add的device会被sd的sd_probe()初始化
+ * 在sd_probe()分配gendisk和scsi_disk
+ *
+ * 下面是probe的stack
+ *
+ * [0] blk_mq_add_queue_tag_set
+ * [0] blk_mq_init_allocated_queue
+ * [0] blk_mq_init_queue
+ * [0] scsi_mq_alloc_queue
+ * [0] scsi_alloc_sdev
+ * [0] scsi_probe_and_add_lun
+ * [0] __scsi_scan_target
+ * [0] scsi_scan_channel
+ * [0] scsi_scan_host_selected
+ * [0] scsi_scan_host
+ * [0] virtscsi_probe
+ * [0] virtio_dev_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ *
+ * 下面是sd_probe()的stack
+ *
+ * [0] sd_probe
+ * [0] really_probe
+ * [0] driver_probe_device
+ * [0] device_driver_attach
+ * [0] __driver_attach
+ * [0] bus_for_each_dev
+ * [0] bus_add_driver
+ * [0] driver_register
+ * [0] init_sd
+ * [0] do_one_initcall
+ * [0] kernel_init_freeable
+ * [0] kernel_init
+ * [0] ret_from_fork
+ *
+ * sd_probe()
+ *  -> alloc_disk() 分配gendisk
+ *  -> async_schedule_domain(sd_probe_async, sdkp, &scsi_sd_probe_domain);
+ *      -> sd_probe_async()
+ *          -> gd->queue = sdkp->device->request_queue;
+ *          -> device_add_disk() 添加gendisk
+ *
+ * [    0.676944] scsi host0: Virtio SCSI HBA
+ * [    0.679662] scsi 0:0:0:0: Direct-Access     QEMU     QEMU HARDDISK    2.5+ PQ: 0 ANSI: 5
+ * [    0.680782] scsi 0:0:0:1: Direct-Access     QEMU     QEMU HARDDISK    2.5+ PQ: 0 ANSI: 5
+ * [    0.693429] sd 0:0:0:0: Attached scsi generic sg0 type 0
+ * [    0.694888] sd 0:0:0:1: Attached scsi generic sg1 type 0
+ * [    0.700609] sd 0:0:0:0: [sda] Attached SCSI disk
+ * [    0.702835] sd 0:0:0:1: [sdb] Attached SCSI disk
+ */
+
+/*
+ * virtio_scsi的timeout的例子
+ *
+ * blk_mq_init_queue()
+ *  -> blk_alloc_queue_node
+ *      -> timer_setup(&q->timeout, blk_rq_timed_out_timer, 0);
+ *      -> INIT_WORK(&q->timeout_work, blk_timeout_work);
+ *  -> blk_mq_init_allocated_queue()
+ *      -> INIT_WORK(&q->timeout_work, blk_mq_timeout_work);
+ *
+ * 最终, q->timeout的timer是blk_rq_timed_out_timer()
+ * q->timeout_work是blk_mq_timeout_work()
+ *
+ * timer的blk_rq_timed_out_timer()会调用q->timeout_work=blk_mq_timeout_work()
+ *
+ * 每开始一个request, 都要调用blk_mq_start_request()
+ *
+ * scsi_queue_rq()
+ *  -> blk_mq_start_request(request)
+ *
+ * blk_mq_start_request()
+ *  -> blk_add_timer()
+ *      -> 根据情况mod_timer
+ *
+ * 是一个request_queue一个timer, 不是一个request一个timer
+ *
+ * 如果timer被触发了:
+ *
+ * blk_rq_timed_out_timer()
+ *  -> 调用q->timeout_work = blk_mq_timeout_work()
+ *      -> 为每一个inflight request调用blk_mq_check_expired()
+ *          -> expire了就调用blk_mq_rq_timed_out()
+ *              -> req->q->mq_ops->timeout = scsi_timeout()
+ *                  -> scsi_times_out()
+ *                      -> host->hostt->eh_timed_out = virtscsi_eh_timed_out()
+ *
+ * virtscsi_eh_timed_out()直接返回BLK_EH_RESET_TIMER
+ */
+
 #define VIRTIO_SCSI_MEMPOOL_SZ 64
 #define VIRTIO_SCSI_EVENT_LEN 8
 #define VIRTIO_SCSI_VQ_BASE 2
 
+/*
+ * 对于virtio_scsi, 在没有CONFIG_BLK_DEV_INTEGRITY的情况下,
+ * 分配的request成了
+ *
+ * struct request
+ * struct scsi_cmnd
+ * struct virtio_scsi_cmd
+ * 若干个sizeof(struct scatterlist)总的size
+ *
+ * tmf是task management
+ */
 /* Command queue element */
 struct virtio_scsi_cmd {
 	struct scsi_cmnd *sc;
@@ -70,20 +221,47 @@ struct virtio_scsi {
 	struct virtio_device *vdev;
 
 	/* Get some buffers ready for event vq */
+	/*
+	 * used by:
+	 *   - drivers/scsi/virtio_scsi.c|418| <<virtscsi_kick_event_all>> vscsi->event_list[i].vscsi = vscsi;
+	 *   - drivers/scsi/virtio_scsi.c|419| <<virtscsi_kick_event_all>> virtscsi_kick_event(vscsi, &vscsi->event_list[i]);
+	 *   - drivers/scsi/virtio_scsi.c|435| <<virtscsi_cancel_event_work>> cancel_work_sync(&vscsi->event_list[i].work);
+	 */
 	struct virtio_scsi_event_node event_list[VIRTIO_SCSI_EVENT_LEN];
 
+	/*
+	 * used by:
+	 *   - drivers/scsi/virtio_scsi.c|367| <<virtscsi_poll_requests>> num_vqs = vscsi->num_queues;
+	 *   - drivers/scsi/virtio_scsi.c|927| <<virtscsi_init>> num_vqs = vscsi->num_queues + VIRTIO_SCSI_VQ_BASE;
+	 *   - drivers/scsi/virtio_scsi.c|1011| <<virtscsi_probe>> vscsi->num_queues = num_queues;
+	 */
 	u32 num_queues;
 
 	/* If the affinity hint is set for virtqueues */
+	/* 已经不用了 */
 	bool affinity_hint_set;
 
 	struct hlist_node node;
 
 	/* Protected by event_vq lock */
+	/*
+	 * used by:
+	 *   - drivers/scsi/virtio_scsi.c|431| <<virtscsi_cancel_event_work>> vscsi->stop_events = true;
+	 *   - drivers/scsi/virtio_scsi.c|523| <<virtscsi_complete_event>> if (!vscsi->stop_events)
+	 */
 	bool stop_events;
 
 	struct virtio_scsi_vq ctrl_vq;
 	struct virtio_scsi_vq event_vq;
+	/*
+	 * used by:
+	 *   - drivers/scsi/virtio_scsi.c|338| <<virtscsi_req_done>> struct virtio_scsi_vq *req_vq = &vscsi->req_vqs[index];
+	 *   - drivers/scsi/virtio_scsi.c|349| <<virtscsi_poll_requests>> virtscsi_vq_done(vscsi, &vscsi->req_vqs[i],
+	 *   - drivers/scsi/virtio_scsi.c|652| <<virtscsi_pick_vq_mq>> return &vscsi->req_vqs[hwq];
+	 *   - drivers/scsi/virtio_scsi.c|934| <<virtscsi_init>> virtscsi_init_vq(&vscsi->req_vqs[i - VIRTIO_SCSI_VQ_BASE],
+	 *   - drivers/scsi/virtio_scsi.c|982| <<virtscsi_probe>> sizeof(*vscsi) + sizeof(vscsi->req_vqs[0]) * num_queues);
+	 *   - drivers/scsi/virtio_scsi.c|997| <<virtscsi_probe>> shost->can_queue = virtqueue_get_vring_size(vscsi->req_vqs[0].vq);
+	 */
 	struct virtio_scsi_vq req_vqs[];
 };
 
@@ -95,6 +273,10 @@ static inline struct Scsi_Host *virtio_scsi_host(struct virtio_device *vdev)
 	return vdev->priv;
 }
 
+/*
+ * called by only:
+ *   - drivers/scsi/virtio_scsi.c|298| <<virtscsi_complete_cmd>> virtscsi_compute_resid(sc, virtio32_to_cpu(vscsi->vdev, resp->resid));
+ */
 static void virtscsi_compute_resid(struct scsi_cmnd *sc, u32 resid)
 {
 	if (resid)
@@ -379,6 +561,10 @@ static void virtscsi_event_done(struct virtqueue *vq)
  * @req_size	: size of the request buffer
  * @resp_size	: size of the response buffer
  */
+/*
+ * called by only:
+ *   - drivers/scsi/virtio_scsi.c|436| <<virtscsi_kick_cmd>> err = virtscsi_add_cmd(vq->vq, cmd, req_size, resp_size);
+ */
 static int virtscsi_add_cmd(struct virtqueue *vq,
 			    struct virtio_scsi_cmd *cmd,
 			    size_t req_size, size_t resp_size)
@@ -390,6 +576,16 @@ static int virtscsi_add_cmd(struct virtqueue *vq,
 
 	out = in = NULL;
 
+	/*
+	 * 部分设置sc_data_direction的地方:
+	 *   - drivers/scsi/scsi_error.c|987| <<scsi_eh_prep_cmnd>> scmd->sc_data_direction = DMA_FROM_DEVICE;
+	 *   - drivers/scsi/scsi_error.c|993| <<scsi_eh_prep_cmnd>> scmd->sc_data_direction = DMA_NONE; 
+	 *   - drivers/scsi/scsi_error.c|1029| <<scsi_eh_restore_cmnd>> scmd->sc_data_direction = ses->data_direction;
+	 *   - drivers/scsi/scsi_error.c|2338| <<scsi_ioctl_reset>> scmd->sc_data_direction = DMA_BIDIRECTIONAL;
+	 *   - drivers/scsi/scsi_lib.c|1195| <<scsi_setup_cmnd>> cmd->sc_data_direction = DMA_NONE;
+	 *   - drivers/scsi/scsi_lib.c|1197| <<scsi_setup_cmnd>> cmd->sc_data_direction = DMA_TO_DEVICE;
+	 *   - drivers/scsi/scsi_lib.c|1199| <<scsi_setup_cmnd>> cmd->sc_data_direction = DMA_FROM_DEVICE;
+	 */
 	if (sc && sc->sc_data_direction != DMA_NONE) {
 		if (sc->sc_data_direction != DMA_FROM_DEVICE)
 			out = &sc->sdb.table;
@@ -424,6 +620,11 @@ static int virtscsi_add_cmd(struct virtqueue *vq,
 	return virtqueue_add_sgs(vq, sgs, out_num, in_num, cmd, GFP_ATOMIC);
 }
 
+/*
+ * called by:
+ *   - drivers/scsi/virtio_scsi.c|531| <<virtscsi_queuecommand>> ret = virtscsi_kick_cmd(req_vq, cmd, req_size, sizeof(cmd->resp.cmd));
+ *   - drivers/scsi/virtio_scsi.c|549| <<virtscsi_tmf>> if (virtscsi_kick_cmd(&vscsi->ctrl_vq, cmd,
+ */
 static int virtscsi_kick_cmd(struct virtio_scsi_vq *vq,
 			     struct virtio_scsi_cmd *cmd,
 			     size_t req_size, size_t resp_size)
@@ -493,9 +694,19 @@ static struct virtio_scsi_vq *virtscsi_pick_vq_mq(struct virtio_scsi *vscsi,
 	return &vscsi->req_vqs[hwq];
 }
 
+/*
+ * 对于virtio_scsi, 在没有CONFIG_BLK_DEV_INTEGRITY的情况下,
+ * 分配的request成了
+ *
+ * struct request
+ * struct scsi_cmnd
+ * struct virtio_scsi_cmd
+ * 若干个sizeof(struct scatterlist)总的size
+ */
 static int virtscsi_queuecommand(struct Scsi_Host *shost,
 				 struct scsi_cmnd *sc)
 {
+	/* Scsi_Host->hostdata是struct virtio_scsi */
 	struct virtio_scsi *vscsi = shost_priv(shost);
 	struct virtio_scsi_vq *req_vq = virtscsi_pick_vq_mq(vscsi, sc);
 	struct virtio_scsi_cmd *cmd = scsi_cmd_priv(sc);
@@ -523,6 +734,9 @@ static int virtscsi_queuecommand(struct Scsi_Host *shost,
 	} else
 #endif
 	{
+		/*
+		 * cmd->req.cmd是struct virtio_scsi_cmd_req cmd
+		 */
 		virtio_scsi_init_hdr(vscsi->vdev, &cmd->req.cmd, sc);
 		memcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);
 		req_size = sizeof(cmd->req.cmd);
@@ -671,6 +885,10 @@ static enum blk_eh_timer_return virtscsi_eh_timed_out(struct scsi_cmnd *scmnd)
 	return BLK_EH_RESET_TIMER;
 }
 
+/*
+ * used by only:
+ *   - drivers/scsi/virtio_scsi.c|806| <<virtscsi_probe>> shost = scsi_host_alloc(&virtscsi_host_template,
+ */
 static struct scsi_host_template virtscsi_host_template = {
 	.module = THIS_MODULE,
 	.name = "Virtio SCSI HBA",
@@ -773,6 +991,12 @@ static int virtscsi_init(struct virtio_device *vdev,
 	return err;
 }
 
+/*
+ * 初始化一个scsi的大概流程:
+ * 1. scsi_host_alloc()
+ * 2. scsi_add_host()
+ * 3. scsi_scan_host()
+ */
 static int virtscsi_probe(struct virtio_device *vdev)
 {
 	struct Scsi_Host *shost;
@@ -794,6 +1018,9 @@ static int virtscsi_probe(struct virtio_device *vdev)
 
 	num_targets = virtscsi_config_get(vdev, max_target) + 1;
 
+	/*
+	 * 会把分配的Scsi_Host->hostt设置为参数的struct scsi_host_template
+	 */
 	shost = scsi_host_alloc(&virtscsi_host_template,
 		sizeof(*vscsi) + sizeof(vscsi->req_vqs[0]) * num_queues);
 	if (!shost)
@@ -847,6 +1074,38 @@ static int virtscsi_probe(struct virtio_device *vdev)
 	if (virtio_has_feature(vdev, VIRTIO_SCSI_F_HOTPLUG))
 		virtscsi_kick_event_all(vscsi);
 
+	/*
+	 * 在测试的时候用了一个virtio_scsi的host上的两个lun (相同channel和target)
+	 * 发现这个函数被host=0, channel=0为0-255个target都在调用
+	 * 其中channel=0调用2次, 因为有2个lun
+	 *
+	 * [0] blk_mq_add_queue_tag_set
+	 * [0] blk_mq_init_allocated_queue
+	 * [0] blk_mq_init_queue
+	 * [0] scsi_mq_alloc_queue
+	 * [0] scsi_alloc_sdev
+	 * [0] scsi_probe_and_add_lun
+	 * [0] __scsi_scan_target
+	 * [0] scsi_scan_channel
+	 * [0] scsi_scan_host_selected
+	 * [0] scsi_scan_host
+	 * [0] virtscsi_probe
+	 * [0] virtio_dev_probe
+	 * [0] really_probe
+	 * [0] driver_probe_device
+	 * [0] device_driver_attach
+	 * [0] __driver_attach
+	 * [0] bus_for_each_dev
+	 * [0] bus_add_driver
+	 * [0] driver_register
+	 * [0] init
+	 * [0] do_one_initcall
+	 * [0] kernel_init_freeable 
+	 * [0] kernel_init
+	 * [0] ret_from_fork
+	 *
+	 * gendisk在sd_probe()分配
+	 */
 	scsi_scan_host(shost);
 	return 0;
 
diff --git a/drivers/virtio/virtio_pci_common.c b/drivers/virtio/virtio_pci_common.c
index f2862f6..c94efdc 100644
--- a/drivers/virtio/virtio_pci_common.c
+++ b/drivers/virtio/virtio_pci_common.c
@@ -127,6 +127,18 @@ static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,
 
 	if (desc) {
 		flags |= PCI_IRQ_AFFINITY;
+		/*
+		 * 对于virtio_scsi, 此时pre_vectors是3
+		 * 下面前3个irq的affinity可以改变
+		 *
+		 * 24:          0          0          0          0   PCI-MSI 65536-edge      virtio0-config
+		 * 25:          0          0          0          0   PCI-MSI 65537-edge      virtio0-control
+		 * 26:          0          0          0          0   PCI-MSI 65538-edge      virtio0-event
+		 * 27:       1202          0          0          0   PCI-MSI 65539-edge      virtio0-request
+		 * 28:          0       1632          0          0   PCI-MSI 65540-edge      virtio0-request
+		 * 29:          0          0       1498          0   PCI-MSI 65541-edge      virtio0-request
+		 * 30:          0          0          0       1005   PCI-MSI 65542-edge      virtio0-request
+		 */
 		desc->pre_vectors++; /* virtio config vector */
 	}
 
@@ -292,6 +304,9 @@ static int vp_find_vqs_msix(struct virtio_device *vdev, unsigned nvqs,
 
 	if (per_vq_vectors) {
 		/* Best option: one for change interrupt, one per vq. */
+		/*
+		 * 这个是给config的irq用的
+		 */
 		nvectors = 1;
 		for (i = 0; i < nvqs; ++i)
 			if (callbacks[i])
diff --git a/include/linux/blk-mq.h b/include/linux/blk-mq.h
index 15d1aa5..98071f2 100644
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@ -20,6 +20,25 @@ struct blk_mq_hw_ctx {
 	} ____cacheline_aligned_in_smp;
 
 	struct delayed_work	run_work;
+	/*
+	 * 在以下修改hctx的cpumask:
+	 *   - block/blk-mq.c|2562| <<blk_mq_map_swqueue>> cpumask_set_cpu(i, hctx->cpumask);
+	 *   - block/blk-mq.c|2520| <<blk_mq_map_swqueue>> cpumask_clear(hctx->cpumask);
+	 *
+	 * 在以下使用hctx的cpumask:
+	 *   - block/blk-mq-sysfs.c|45| <<blk_mq_hw_sysfs_release>> free_cpumask_var(hctx->cpumask);
+	 *   - block/blk-mq-sysfs.c|172| <<blk_mq_hw_sysfs_cpus_show>> for_each_cpu(i, hctx->cpumask) {
+	 *   - block/blk-mq.c|472| <<blk_mq_alloc_request_hctx>> cpu = cpumask_first_and(alloc_data.hctx->cpumask, cpu_online_mask);
+	 *   - block/blk-mq.c|1396| <<__blk_mq_run_hw_queue>> if (!cpumask_test_cpu(raw_smp_processor_id(), hctx->cpumask) &&
+	 *   - block/blk-mq.c|1400| <<__blk_mq_run_hw_queue>> cpumask_empty(hctx->cpumask) ? "inactive": "active");
+	 *   - block/blk-mq.c|1419| <<blk_mq_first_mapped_cpu>> int cpu = cpumask_first_and(hctx->cpumask, cpu_online_mask);
+	 *   - block/blk-mq.c|1422| <<blk_mq_first_mapped_cpu>> cpu = cpumask_first(hctx->cpumask);
+	 *   - block/blk-mq.c|1442| <<blk_mq_hctx_next_cpu>> next_cpu = cpumask_next_and(next_cpu, hctx->cpumask,
+	 *   - block/blk-mq.c|1480| <<__blk_mq_delay_run_hw_queue>> if (cpumask_test_cpu(cpu, hctx->cpumask)) {
+	 *   - block/blk-mq.c|2383| <<blk_mq_alloc_hctx>> if (!zalloc_cpumask_var_node(&hctx->cpumask, gfp, node))
+	 *   - block/blk-mq.c|2433| <<blk_mq_alloc_hctx>> free_cpumask_var(hctx->cpumask);
+	 *   - block/blk-mq.c|2559| <<blk_mq_map_swqueue>> if (cpumask_test_cpu(i, hctx->cpumask))
+	 */
 	cpumask_var_t		cpumask;
 	int			next_cpu;
 	int			next_cpu_batch;
@@ -112,6 +131,24 @@ struct blk_mq_tag_set {
 	struct blk_mq_tags	**tags;
 
 	struct mutex		tag_list_lock;
+	/*
+	 * 在以下添加:
+	 *   - block/blk-mq.c|2659| <<blk_mq_add_queue_tag_set>> list_add_tail_rcu(&q->tag_set_list, &set->tag_list);
+	 *
+	 * 在以下使用:
+	 *   - block/blk-mq.c|2640| <<blk_mq_update_tag_set_depth>> list_for_each_entry(q, &set->tag_list, tag_set_list) {
+	 *   - block/blk-mq.c|2653| <<blk_mq_del_queue_tag_set>> if (list_is_singular(&set->tag_list)) {
+	 *   - block/blk-mq.c|2701| <<blk_mq_add_queue_tag_set>> if (!list_empty(&set->tag_list) &&
+	 *   - block/blk-mq.c|2709| <<blk_mq_add_queue_tag_set>> list_add_tail_rcu(&q->tag_set_list, &set->tag_list);
+	 *   - block/blk-mq.c|3195| <<blk_mq_alloc_tag_set>> INIT_LIST_HEAD(&set->tag_list);
+	 *   - block/blk-mq.c|3356| <<__blk_mq_update_nr_hw_queues>> list_for_each_entry(q, &set->tag_list, tag_set_list)
+	 *   - block/blk-mq.c|3367| <<__blk_mq_update_nr_hw_queues>> list_for_each_entry(q, &set->tag_list, tag_set_list)
+	 *   - block/blk-mq.c|3371| <<__blk_mq_update_nr_hw_queues>> list_for_each_entry(q, &set->tag_list, tag_set_list) {
+	 *   - block/blk-mq.c|3380| <<__blk_mq_update_nr_hw_queues>> list_for_each_entry(q, &set->tag_list, tag_set_list) {
+	 *   - block/blk-mq.c|3392| <<__blk_mq_update_nr_hw_queues>> list_for_each_entry(q, &set->tag_list, tag_set_list) {
+	 *   - block/blk-mq.c|3398| <<__blk_mq_update_nr_hw_queues>> list_for_each_entry(q, &set->tag_list, tag_set_list)
+	 *   - block/blk-mq.c|3401| <<__blk_mq_update_nr_hw_queues>> list_for_each_entry(q, &set->tag_list, tag_set_list)
+	 */
 	struct list_head	tag_list;
 };
 
@@ -218,12 +255,38 @@ struct blk_mq_ops {
 
 enum {
 	BLK_MQ_F_SHOULD_MERGE	= 1 << 0,
+	/*
+	 * 在以下设置或者清除BLK_MQ_F_TAG_SHARED:
+	 *   - block/blk-mq.c|2581| <<queue_set_hctx_shared>> hctx->flags |= BLK_MQ_F_TAG_SHARED;
+	 *   - block/blk-mq.c|2627| <<blk_mq_add_queue_tag_set>> set->flags |= BLK_MQ_F_TAG_SHARED;
+	 *   - block/blk-mq.c|2357| <<blk_mq_alloc_hctx>> hctx->flags = set->flags & ~BLK_MQ_F_TAG_SHARED;
+	 *   - block/blk-mq.c|2583| <<queue_set_hctx_shared>> hctx->flags &= ~BLK_MQ_F_TAG_SHARED;
+	 *   - block/blk-mq.c|2609| <<blk_mq_del_queue_tag_set>> set->flags &= ~BLK_MQ_F_TAG_SHARED;
+	 *
+	 * 在以下使用BLK_MQ_F_TAG_SHARED:
+	 *   - block/blk-mq-tag.c|75| <<hctx_may_queue>> if (!hctx || !(hctx->flags & BLK_MQ_F_TAG_SHARED))
+	 *   - block/blk-mq-tag.h|58| <<blk_mq_tag_busy>> if (!(hctx->flags & BLK_MQ_F_TAG_SHARED))
+	 *   - block/blk-mq-tag.h|66| <<blk_mq_tag_idle>> if (!(hctx->flags & BLK_MQ_F_TAG_SHARED))
+	 *   - block/blk-mq.c|304| <<blk_mq_rq_ctx_init>> if (data->hctx->flags & BLK_MQ_F_TAG_SHARED) {
+	 *   - block/blk-mq.c|1111| <<blk_mq_mark_tag_wait>> if (!(hctx->flags & BLK_MQ_F_TAG_SHARED)) {
+	 *   - block/blk-mq.c|1242| <<blk_mq_dispatch_rq_list>> if (hctx->flags & BLK_MQ_F_TAG_SHARED)
+	 *   - block/blk-mq.c|2626| <<blk_mq_add_queue_tag_set>> !(set->flags & BLK_MQ_F_TAG_SHARED)) {
+	 *   - block/blk-mq.c|2631| <<blk_mq_add_queue_tag_set>> if (set->flags & BLK_MQ_F_TAG_SHARED)
+	 */
 	BLK_MQ_F_TAG_SHARED	= 1 << 1,
 	BLK_MQ_F_BLOCKING	= 1 << 5,
 	BLK_MQ_F_NO_SCHED	= 1 << 6,
 	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
 	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
 
+	/*
+	 * 在以下使用:
+	 *   - block/blk-mq.c|1553| <<blk_mq_stop_hw_queue>> set_bit(BLK_MQ_S_STOPPED, &hctx->state);
+	 *   - block/blk-mq.c|1578| <<blk_mq_start_hw_queue>> clear_bit(BLK_MQ_S_STOPPED, &hctx->state);
+	 *   - block/blk-mq.c|1599| <<blk_mq_start_stopped_hw_queue>> clear_bit(BLK_MQ_S_STOPPED, &hctx->state);
+	 *   - block/blk-mq.c|1623| <<blk_mq_run_work_fn>> if (test_bit(BLK_MQ_S_STOPPED, &hctx->state))
+	 *   - block/blk-mq.h|184| <<blk_mq_hctx_stopped>> return test_bit(BLK_MQ_S_STOPPED, &hctx->state);
+	 */
 	BLK_MQ_S_STOPPED	= 0,
 	BLK_MQ_S_TAG_ACTIVE	= 1,
 	BLK_MQ_S_SCHED_RESTART	= 2,
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 592669b..496c82e 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -479,7 +479,27 @@ struct request_queue {
 	struct blk_stat_callback	*poll_cb;
 	struct blk_rq_stat	poll_stat[BLK_MQ_POLL_STATS_BKTS];
 
+	/*
+	 * q->timeout在以下使用:
+	 *   - block/blk-core.c|234| <<blk_sync_queue>> del_timer_sync(&q->timeout);
+	 *   - block/blk-core.c|491| <<blk_alloc_queue_node>> timer_setup(&q->timeout, blk_rq_timed_out_timer, 0);
+	 *   - block/blk-mq.c|967| <<blk_mq_timeout_work>> mod_timer(&q->timeout, next);
+	 *   - block/blk-timeout.c|154| <<blk_add_timer>> if (!timer_pending(&q->timeout) ||
+	 *   - block/blk-timeout.c|155| <<blk_add_timer>> time_before(expiry, q->timeout.expires)) {
+	 *   - block/blk-timeout.c|156| <<blk_add_timer>> unsigned long diff = q->timeout.expires - expiry; 
+	 *   - block/blk-timeout.c|165| <<blk_add_timer>> if (!timer_pending(&q->timeout) || (diff >= HZ / 2))
+	 *   - block/blk-timeout.c|166| <<blk_add_timer>> mod_timer(&q->timeout, expiry);
+	 */
 	struct timer_list	timeout;
+	/*
+	 * timeout_work在以下使用:
+	 *   - block/blk-core.c|235| <<blk_sync_queue>> cancel_work_sync(&q->timeout_work);
+	 *   - block/blk-core.c|418| <<blk_rq_timed_out_timer>> kblockd_schedule_work(&q->timeout_work);
+	 *   - block/blk-core.c|467| <<blk_alloc_queue_node>> INIT_WORK(&q->timeout_work, blk_timeout_work);
+	 *   - block/blk-mq.c|923| <<blk_mq_timeout_work>> container_of(work, struct request_queue, timeout_work);
+	 *   - block/blk-mq.c|2942| <<blk_mq_init_allocated_queue>> INIT_WORK(&q->timeout_work, blk_mq_timeout_work);
+	 *   - block/blk-timeout.c|89| <<blk_abort_request>> kblockd_schedule_work(&req->q->timeout_work);
+	 */
 	struct work_struct	timeout_work;
 
 	struct list_head	icq_list;
diff --git a/include/linux/dma-mapping.h b/include/linux/dma-mapping.h
index 6309a72..a5c3d48 100644
--- a/include/linux/dma-mapping.h
+++ b/include/linux/dma-mapping.h
@@ -697,6 +697,13 @@ static inline void arch_teardown_dma_ops(struct device *dev)
 }
 #endif /* CONFIG_ARCH_HAS_TEARDOWN_DMA_OPS */
 
+/*
+ * x86下调用的几个例子:
+ *   - arch/x86/kernel/amd_gart_64.c|397| <<gart_map_sg>> max_seg_size = dma_get_max_seg_size(dev);
+ *   - drivers/iommu/dma-iommu.c|702| <<__finalise_sg>> unsigned int cur_len = 0, max_len = dma_get_max_seg_size(dev);
+ *   - kernel/dma/debug.c|349| <<bucket_find_contain>> unsigned int max_range = dma_get_max_seg_size(ref->dev);
+ *   - kernel/dma/debug.c|1212| <<check_sg_segment>> unsigned int max_seg = dma_get_max_seg_size(dev);
+ */
 static inline unsigned int dma_get_max_seg_size(struct device *dev)
 {
 	if (dev->dma_parms && dev->dma_parms->max_segment_size)
@@ -707,6 +714,12 @@ static inline unsigned int dma_get_max_seg_size(struct device *dev)
 static inline int dma_set_max_seg_size(struct device *dev, unsigned int size)
 {
 	if (dev->dma_parms) {
+		/*
+		 * 只在下面使用:
+		 *   - include/linux/dma-mapping.h|702| <<dma_get_max_seg_size>> if (dev->dma_parms && dev->dma_parms->max_segment_size)
+		 *   - include/linux/dma-mapping.h|703| <<dma_get_max_seg_size>> return dev->dma_parms->max_segment_size;
+		 *   - include/linux/dma-mapping.h|710| <<dma_set_max_seg_size>> dev->dma_parms->max_segment_size = size;
+		 */
 		dev->dma_parms->max_segment_size = size;
 		return 0;
 	}
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index c7eef32..1eeb0ac 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -276,10 +276,43 @@ struct irq_affinity_notify {
  *			pointer to driver/device specific data.
  */
 struct irq_affinity {
+	/*
+	 * used by:
+	 *   - drivers/nvme/host/pci.c|2066| <<nvme_setup_irqs>> .pre_vectors = 1,
+	 *   - drivers/scsi/qla2xxx/qla_isr.c|3449| <<qla24xx_enable_msix>> .pre_vectors = QLA_BASE_VECTORS,
+	 *   - drivers/scsi/qla2xxx/qla_isr.c|3454| <<qla24xx_enable_msix>> desc.pre_vectors++;
+	 *   - drivers/scsi/qla2xxx/qla_isr.c|3494| <<qla24xx_enable_msix>> vha->irq_offset = desc.pre_vectors;
+	 *   - drivers/scsi/virtio_scsi.c|820| <<virtscsi_init>> struct irq_affinity desc = { .pre_vectors = 2 };
+	 *   - drivers/virtio/virtio_pci_common.c|130| <<vp_request_msix_vectors>> desc->pre_vectors++;
+	 *   - kernel/irq/affinity.c|260| <<irq_create_affinity_masks>> if (nvecs > 1 && nvecs > affd->pre_vectors + affd->post_vectors)
+	 *   - kernel/irq/affinity.c|261| <<irq_create_affinity_masks>> affvecs = nvecs - affd->pre_vectors - affd->post_vectors;
+	 *   - kernel/irq/affinity.c|287| <<irq_create_affinity_masks>> for (curvec = 0; curvec < affd->pre_vectors; curvec++)
+	 *   - kernel/irq/affinity.c|310| <<irq_create_affinity_masks>> curvec = affd->pre_vectors + affvecs;
+	 *   - kernel/irq/affinity.c|312| <<irq_create_affinity_masks>> curvec = affd->pre_vectors + usedvecs;
+	 *   - kernel/irq/affinity.c|317| <<irq_create_affinity_masks>> for (i = affd->pre_vectors; i < nvecs - affd->post_vectors; i++)
+	 *   - kernel/irq/affinity.c|332| <<irq_calc_affinity_vectors>> unsigned int resv = affd->pre_vectors + affd->post_vectors;
+	 */
 	unsigned int	pre_vectors;
+	/*
+	 * used by:
+	 *   - drivers/scsi/be2iscsi/be_main.c|3570| <<be2iscsi_enable_msix>> struct irq_affinity desc = { .post_vectors = 1 };
+	 *   - kernel/irq/affinity.c|260| <<irq_create_affinity_masks>> if (nvecs > 1 && nvecs > affd->pre_vectors + affd->post_vectors)
+	 *   - kernel/irq/affinity.c|261| <<irq_create_affinity_masks>> affvecs = nvecs - affd->pre_vectors - affd->post_vectors;
+	 *   - kernel/irq/affinity.c|317| <<irq_create_affinity_masks>> for (i = affd->pre_vectors; i < nvecs - affd->post_vectors; i++)
+	 *   - kernel/irq/affinity.c|332| <<irq_calc_affinity_vectors>> unsigned int resv = affd->pre_vectors + affd->post_vectors;
+	 */
 	unsigned int	post_vectors;
 	unsigned int	nr_sets;
 	unsigned int	set_size[IRQ_AFFINITY_MAX_SETS];
+	/*
+	 * used by:
+	 *   - drivers/nvme/host/pci.c|2067| <<nvme_setup_irqs>> .calc_sets = nvme_calc_irq_sets,
+	 *   - drivers/scsi/csiostor/csio_isr.c|504| <<csio_enable_msix>> .calc_sets = csio_calc_sets,
+	 *   - kernel/irq/affinity.c|275| <<irq_create_affinity_masks>> if (!affd->calc_sets)
+	 *   - kernel/irq/affinity.c|276| <<irq_create_affinity_masks>> affd->calc_sets = default_calc_sets;
+	 *   - kernel/irq/affinity.c|279| <<irq_create_affinity_masks>> affd->calc_sets(affd, affvecs);
+	 *   - kernel/irq/affinity.c|344| <<irq_calc_affinity_vectors>> if (affd->calc_sets) {
+	 */
 	void		(*calc_sets)(struct irq_affinity *, unsigned int nvecs);
 	void		*priv;
 };
diff --git a/include/linux/irq.h b/include/linux/irq.h
index fb301cf..cf4414e 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -225,6 +225,13 @@ enum {
 	IRQD_IRQ_INPROGRESS		= (1 << 18),
 	IRQD_WAKEUP_ARMED		= (1 << 19),
 	IRQD_FORWARDED_TO_VCPU		= (1 << 20),
+	/*
+	 * 在以下设置:
+	 *   - kernel/irq/irqdesc.c|474| <<alloc_descs>> flags = IRQD_AFFINITY_MANAGED |
+	 *
+	 * 在以下使用:
+	 *   - include/linux/irq.h|350| <<irqd_affinity_is_managed>> return __irqd_to_state(d) & IRQD_AFFINITY_MANAGED;
+	 */
 	IRQD_AFFINITY_MANAGED		= (1 << 21),
 	IRQD_IRQ_STARTED		= (1 << 22),
 	IRQD_MANAGED_SHUTDOWN		= (1 << 23),
diff --git a/include/linux/virtio_config.h b/include/linux/virtio_config.h
index bb4cc49..61b1960 100644
--- a/include/linux/virtio_config.h
+++ b/include/linux/virtio_config.h
@@ -194,6 +194,9 @@ int virtio_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 			const char * const names[],
 			struct irq_affinity *desc)
 {
+	/*
+	 * vp_modern_find_vqs()
+	 */
 	return vdev->config->find_vqs(vdev, nvqs, vqs, callbacks, names, NULL, desc);
 }
 
diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
index 76ed5e4..09495f6 100644
--- a/include/scsi/scsi_cmnd.h
+++ b/include/scsi/scsi_cmnd.h
@@ -89,6 +89,16 @@ struct scsi_cmnd {
 	unsigned char prot_flags;
 
 	unsigned short cmd_len;
+	/*
+	 * 部分设置sc_data_direction的地方:
+	 *   - drivers/scsi/scsi_error.c|987| <<scsi_eh_prep_cmnd>> scmd->sc_data_direction = DMA_FROM_DEVICE;
+	 *   - drivers/scsi/scsi_error.c|993| <<scsi_eh_prep_cmnd>> scmd->sc_data_direction = DMA_NONE; 
+	 *   - drivers/scsi/scsi_error.c|1029| <<scsi_eh_restore_cmnd>> scmd->sc_data_direction = ses->data_direction;
+	 *   - drivers/scsi/scsi_error.c|2338| <<scsi_ioctl_reset>> scmd->sc_data_direction = DMA_BIDIRECTIONAL;
+	 *   - drivers/scsi/scsi_lib.c|1195| <<scsi_setup_cmnd>> cmd->sc_data_direction = DMA_NONE;
+	 *   - drivers/scsi/scsi_lib.c|1197| <<scsi_setup_cmnd>> cmd->sc_data_direction = DMA_TO_DEVICE;
+	 *   - drivers/scsi/scsi_lib.c|1199| <<scsi_setup_cmnd>> cmd->sc_data_direction = DMA_FROM_DEVICE;
+	 */
 	enum dma_data_direction sc_data_direction;
 
 	/* These elements define the operation we are about to perform */
@@ -146,6 +156,15 @@ struct scsi_cmnd {
  * Return the driver private allocation behind the command.
  * Only works if cmd_size is set in the host template.
  */
+/*
+ * 对于virtio_scsi, 在没有CONFIG_BLK_DEV_INTEGRITY的情况下,
+ * 分配的request成了
+ *
+ * struct request
+ * struct scsi_cmnd
+ * struct virtio_scsi_cmd
+ * 若干个sizeof(struct scatterlist)总的size
+ */
 static inline void *scsi_cmd_priv(struct scsi_cmnd *cmd)
 {
 	return cmd + 1;
@@ -176,6 +195,11 @@ static inline void scsi_dma_unmap(struct scsi_cmnd *cmd) { }
 
 static inline unsigned scsi_sg_count(struct scsi_cmnd *cmd)
 {
+	/*
+	 * struct scsi_data_buffer sdb
+	 *   struct sg_table table
+	 *     unsigned int nents
+	 */
 	return cmd->sdb.table.nents;
 }
 
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index 202f4d6..f1b838f 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -434,6 +434,25 @@ extern int __scsi_execute(struct scsi_device *sdev, const unsigned char *cmd,
 			int timeout, int retries, u64 flags,
 			req_flags_t rq_flags, int *resid);
 /* Make sure any sense buffer is the correct size. */
+/*
+ * called by:
+ *   - drivers/ata/libata-scsi.c|635| <<ata_cmd_ioctl>> cmd_result = scsi_execute(scsidev, scsi_cmd, data_dir, argbuf, argsize,
+ *   - drivers/ata/libata-scsi.c|716| <<ata_task_ioctl>> cmd_result = scsi_execute(scsidev, scsi_cmd, DMA_NONE, NULL, 0,
+ *   - drivers/scsi/cxlflash/superpipe.c|360| <<read_cap16>> result = scsi_execute(sdev, scsi_cmd, DMA_FROM_DEVICE, cmd_buf,
+ *   - drivers/scsi/cxlflash/vlun.c|453| <<write_same16>> result = scsi_execute(sdev, scsi_cmd, DMA_TO_DEVICE, cmd_buf,
+ *   - drivers/scsi/device_handler/scsi_dh_alua.c|140| <<submit_rtpg>> return scsi_execute(sdev, cdb, DMA_FROM_DEVICE, buff, bufflen, NULL,
+ *   - drivers/scsi/device_handler/scsi_dh_alua.c|172| <<submit_stpg>> return scsi_execute(sdev, cdb, DMA_TO_DEVICE, stpg_data, stpg_len, NULL,
+ *   - drivers/scsi/device_handler/scsi_dh_emc.c|266| <<send_trespass_cmd>> err = scsi_execute(sdev, cdb, DMA_TO_DEVICE, csdev->buffer, len, NULL,
+ *   - drivers/scsi/device_handler/scsi_dh_hp_sw.c|90| <<hp_sw_tur>> res = scsi_execute(sdev, cmd, DMA_NONE, NULL, 0, NULL, &sshdr,
+ *   - drivers/scsi/device_handler/scsi_dh_hp_sw.c|128| <<hp_sw_start_stop>> res = scsi_execute(sdev, cmd, DMA_NONE, NULL, 0, NULL, &sshdr,
+ *   - drivers/scsi/scsi_transport_spi.c|120| <<spi_execute>> result = scsi_execute(sdev, cmd, dir, buffer, bufflen, sense,
+ *   - drivers/scsi/sd.c|1659| <<sd_sync_cache>> res = scsi_execute(sdp, cmd, DMA_NONE, NULL, 0, NULL, sshdr,
+ *   - drivers/scsi/sd.c|3565| <<sd_start_stop_device>> res = scsi_execute(sdp, cmd, DMA_NONE, NULL, 0, NULL, &sshdr,
+ *   - drivers/scsi/sr_ioctl.c|203| <<sr_do_ioctl>> result = scsi_execute(SDev, cgc->cmd, cgc->data_direction,
+ *   - drivers/scsi/ufs/ufshcd.c|7444| <<ufshcd_send_request_sense>> ret = scsi_execute(sdp, cmd, DMA_FROM_DEVICE, buffer,
+ *   - drivers/scsi/ufs/ufshcd.c|7511| <<ufshcd_set_dev_pwr_mode>> ret = scsi_execute(sdp, cmd, DMA_NONE, NULL, 0, NULL, &sshdr,
+ *   - include/scsi/scsi_device.h|451| <<scsi_execute_req>> return scsi_execute(sdev, cmd, data_direction, buffer,
+ */
 #define scsi_execute(sdev, cmd, data_direction, buffer, bufflen, sense,	\
 		     sshdr, timeout, retries, flags, rq_flags, resid)	\
 ({									\
@@ -443,6 +462,33 @@ extern int __scsi_execute(struct scsi_device *sdev, const unsigned char *cmd,
 		       sense, sshdr, timeout, retries, flags, rq_flags,	\
 		       resid);						\
 })
+/*
+ * called by:
+ *   - drivers/scsi/ch.c|199| <<ch_do_scsi>> result = scsi_execute_req(ch->device, cmd, direction, buffer,
+ *   - drivers/scsi/scsi.c|334| <<scsi_vpd_inquiry>> result = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buffer,
+ *   - drivers/scsi/scsi.c|510| <<scsi_report_opcode>> result = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buffer, len,
+ *   - drivers/scsi/scsi_ioctl.c|98| <<ioctl_internal_command>> result = scsi_execute_req(sdev, cmd, DMA_NONE, NULL, 0,
+ *   - drivers/scsi/scsi_lib.c|2169| <<scsi_mode_select>> ret = scsi_execute_req(sdev, cmd, DMA_TO_DEVICE, real_buffer, len,
+ *   - drivers/scsi/scsi_lib.c|2234| <<scsi_mode_sense>> result = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buffer, len,
+ *   - drivers/scsi/scsi_lib.c|2312| <<scsi_test_unit_ready>> result = scsi_execute_req(sdev, cmd, DMA_NONE, NULL, 0, sshdr,
+ *   - drivers/scsi/scsi_scan.c|197| <<scsi_unlock_floptical>> scsi_execute_req(sdev, scsi_cmd, DMA_FROM_DEVICE, result, 0x2a, NULL,
+ *   - drivers/scsi/scsi_scan.c|655| <<scsi_probe_lun>> result = scsi_execute_req(sdev, scsi_cmd, DMA_FROM_DEVICE,
+ *   - drivers/scsi/scsi_scan.c|1473| <<scsi_report_lun_scan>> result = scsi_execute_req(sdev, scsi_cmd, DMA_FROM_DEVICE,
+ *   - drivers/scsi/sd.c|679| <<sd_sec_submit>> ret = scsi_execute_req(sdev, cdb,
+ *   - drivers/scsi/sd.c|1767| <<sd_pr_command>> result = scsi_execute_req(sdev, cmd, DMA_TO_DEVICE, &data, sizeof(data),
+ *   - drivers/scsi/sd.c|2106| <<sd_spinup_disk>> the_result = scsi_execute_req(sdkp->device, cmd,
+ *   - drivers/scsi/sd.c|2163| <<sd_spinup_disk>> scsi_execute_req(sdkp->device, cmd, DMA_NONE,
+ *   - drivers/scsi/sd.c|2303| <<read_capacity_16>> the_result = scsi_execute_req(sdp, cmd, DMA_FROM_DEVICE,
+ *   - drivers/scsi/sd.c|2388| <<read_capacity_10>> the_result = scsi_execute_req(sdp, cmd, DMA_FROM_DEVICE,
+ *   - drivers/scsi/sd_zbc.c|84| <<sd_zbc_do_report_zones>> result = scsi_execute_req(sdp, cmd, DMA_FROM_DEVICE,
+ *   - drivers/scsi/ses.c|96| <<ses_recv_diag>> ret = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,
+ *   - drivers/scsi/ses.c|130| <<ses_send_diag>> result = scsi_execute_req(sdev, cmd, DMA_TO_DEVICE, buf, bufflen,
+ *   - drivers/scsi/sr.c|206| <<sr_get_events>> result = scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, sizeof(buf),
+ *   - drivers/scsi/sr.c|795| <<get_sectorsize>> the_result = scsi_execute_req(cd->device, cmd, DMA_FROM_DEVICE,
+ *   - drivers/target/target_core_pscsi.c|150| <<pscsi_tape_read_blocksize>> ret = scsi_execute_req(sdev, cdb, DMA_FROM_DEVICE, buf, 12, NULL,
+ *   - drivers/target/target_core_pscsi.c|201| <<pscsi_get_inquiry_vpd_serial>> ret = scsi_execute_req(sdev, cdb, DMA_FROM_DEVICE, buf,
+ *   - drivers/target/target_core_pscsi.c|236| <<pscsi_get_inquiry_vpd_device_ident>> ret = scsi_execute_req(sdev, cdb, DMA_FROM_DEVICE, buf,
+ */
 static inline int scsi_execute_req(struct scsi_device *sdev,
 	const unsigned char *cmd, int data_direction, void *buffer,
 	unsigned bufflen, struct scsi_sense_hdr *sshdr, int timeout,
diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index a5fcdad..f0c9939 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -659,6 +659,11 @@ struct Scsi_Host {
 	unsigned int  irq;
 	
 
+	/*
+	 * 修改的地方:
+	 *   - drivers/scsi/hosts.c|146| <<scsi_host_set_state>> shost->shost_state = state;
+	 *   - drivers/scsi/hosts.c|412| <<scsi_host_alloc>> shost->shost_state = SHOST_CREATED;
+	 */
 	enum scsi_host_state shost_state;
 
 	/* ldm bits */
@@ -791,13 +796,30 @@ enum scsi_host_prot_capabilities {
  * indicate their capabilities by setting the prot_capabilities using
  * this call.
  */
+/*
+ * virtscsi_probe()的例子
+ *
+ * host_prot = SHOST_DIF_TYPE1_PROTECTION | SHOST_DIF_TYPE2_PROTECTION |
+ *             SHOST_DIF_TYPE3_PROTECTION | SHOST_DIX_TYPE1_PROTECTION |
+ *             SHOST_DIX_TYPE2_PROTECTION | SHOST_DIX_TYPE3_PROTECTION;
+ *
+ * scsi_host_set_prot(shost, host_prot);
+ */
 static inline void scsi_host_set_prot(struct Scsi_Host *shost, unsigned int mask)
 {
+	/*
+	 * 只在如下设置:
+	 *   - include/scsi/scsi_host.h|796| <<scsi_host_set_prot>> shost->prot_capabilities = mask;
+	 */
 	shost->prot_capabilities = mask;
 }
 
 static inline unsigned int scsi_host_get_prot(struct Scsi_Host *shost)
 {
+	/*
+	 * 只在如下设置:
+	 *   - include/scsi/scsi_host.h|796| <<scsi_host_set_prot>> shost->prot_capabilities = mask;
+	 */
 	return shost->prot_capabilities;
 }
 
diff --git a/kernel/irq/affinity.c b/kernel/irq/affinity.c
index f18cd5a..bdd8901 100644
--- a/kernel/irq/affinity.c
+++ b/kernel/irq/affinity.c
@@ -8,6 +8,10 @@
 #include <linux/slab.h>
 #include <linux/cpu.h>
 
+/*
+ * called by:
+ *   - kernel/irq/affinity.c|155| <<__irq_build_affinity_masks>> irq_spread_init_one(&masks[curvec].mask, nmsk,
+ */
 static void irq_spread_init_one(struct cpumask *irqmsk, struct cpumask *nmsk,
 				unsigned int cpus_per_vec)
 {
@@ -28,6 +32,9 @@ static void irq_spread_init_one(struct cpumask *irqmsk, struct cpumask *nmsk,
 		/* If the cpu has siblings, use them first */
 		siblmsk = topology_sibling_cpumask(cpu);
 		for (sibl = -1; cpus_per_vec > 0; ) {
+			/*
+			 * siblmsk是上面cpu的sibling
+			 */
 			sibl = cpumask_next(sibl, siblmsk);
 			if (sibl >= nr_cpu_ids)
 				break;
@@ -39,6 +46,12 @@ static void irq_spread_init_one(struct cpumask *irqmsk, struct cpumask *nmsk,
 	}
 }
 
+/*
+ * called by:
+ *   - kernel/irq/affinity.c|190| <<irq_build_affinity_masks>> node_to_cpumask = alloc_node_to_cpumask();
+ *
+ * 似乎就是分配一个cpumask_var_t数组, 有nr_node_ids个元素
+ */
 static cpumask_var_t *alloc_node_to_cpumask(void)
 {
 	cpumask_var_t *masks;
@@ -62,6 +75,12 @@ static cpumask_var_t *alloc_node_to_cpumask(void)
 	return NULL;
 }
 
+/*
+ * called by:
+ *   - kernel/irq/affinity.c|240| <<irq_build_affinity_masks>> free_node_to_cpumask(node_to_cpumask);
+ *
+ * 把cpumask_var_t数组的nr_node_ids个元素释放
+ */
 static void free_node_to_cpumask(cpumask_var_t *masks)
 {
 	int node;
@@ -71,6 +90,12 @@ static void free_node_to_cpumask(cpumask_var_t *masks)
 	kfree(masks);
 }
 
+/*
+ * called by:
+ *   - kernel/irq/affinity.c|214| <<irq_build_affinity_masks>> build_node_to_cpumask(node_to_cpumask);
+ *
+ * 参数
+ */
 static void build_node_to_cpumask(cpumask_var_t *masks)
 {
 	int cpu;
@@ -79,6 +104,10 @@ static void build_node_to_cpumask(cpumask_var_t *masks)
 		cpumask_set_cpu(cpu, masks[cpu_to_node(cpu)]);
 }
 
+/*
+ * called by:
+ *   - kernel/irq/affinity.c|127| <<__irq_build_affinity_masks>> nodes = get_nodes_in_cpumask(node_to_cpumask, cpu_mask, &nodemsk);
+ */
 static int get_nodes_in_cpumask(cpumask_var_t *node_to_cpumask,
 				const struct cpumask *mask, nodemask_t *nodemsk)
 {
@@ -94,6 +123,11 @@ static int get_nodes_in_cpumask(cpumask_var_t *node_to_cpumask,
 	return nodes;
 }
 
+/*
+ * called by:
+ *   - kernel/irq/affinity.c|200| <<irq_build_affinity_masks>> nr_present = __irq_build_affinity_masks(affd, curvec, numvecs,
+ *   - kernel/irq/affinity.c|215| <<irq_build_affinity_masks>> nr_others = __irq_build_affinity_masks(affd, curvec, numvecs,
+ */
 static int __irq_build_affinity_masks(const struct irq_affinity *affd,
 				      unsigned int startvec,
 				      unsigned int numvecs,
@@ -171,6 +205,10 @@ static int __irq_build_affinity_masks(const struct irq_affinity *affd,
  *	1) spread present CPU on these vectors
  *	2) spread other possible CPUs on these vectors
  */
+/*
+ * called by:
+ *   - kernel/irq/affinity.c|313| <<irq_create_affinity_masks>> ret = irq_build_affinity_masks(affd, curvec, this_vecs,
+ */
 static int irq_build_affinity_masks(const struct irq_affinity *affd,
 				    unsigned int startvec, unsigned int numvecs,
 				    unsigned int firstvec,
@@ -230,6 +268,13 @@ static int irq_build_affinity_masks(const struct irq_affinity *affd,
 	return ret;
 }
 
+/*
+ * used by:
+ *   - kernel/irq/affinity.c|285| <<irq_create_affinity_masks>> affd->calc_sets = default_calc_sets;
+ *
+ * called by:
+ *   - kernel/irq/affinity.c|288| <<irq_create_affinity_masks>> affd->calc_sets(affd, affvecs);
+ */
 static void default_calc_sets(struct irq_affinity *affd, unsigned int affvecs)
 {
 	affd->nr_sets = 1;
@@ -243,6 +288,12 @@ static void default_calc_sets(struct irq_affinity *affd, unsigned int affvecs)
  *
  * Returns the irq_affinity_desc pointer or NULL if allocation failed.
  */
+/*
+ * called by:
+ *   - drivers/pci/msi.c|542| <<msi_setup_entry>> masks = irq_create_affinity_masks(nvec, affd);
+ *   - drivers/pci/msi.c|679| <<msix_setup_entries>> masks = irq_create_affinity_masks(nvec, affd);
+ *   - drivers/pci/msi.c|1191| <<pci_alloc_irq_vectors_affinity>> irq_create_affinity_masks(1, affd);
+ */
 struct irq_affinity_desc *
 irq_create_affinity_masks(unsigned int nvecs, struct irq_affinity *affd)
 {
@@ -266,6 +317,15 @@ irq_create_affinity_masks(unsigned int nvecs, struct irq_affinity *affd)
 	 * Simple invocations do not provide a calc_sets() callback. Install
 	 * the generic one.
 	 */
+	/*
+	 * used by:
+	 *   - drivers/nvme/host/pci.c|2067| <<nvme_setup_irqs>> .calc_sets = nvme_calc_irq_sets,
+	 *   - drivers/scsi/csiostor/csio_isr.c|504| <<csio_enable_msix>> .calc_sets = csio_calc_sets,
+	 *   - kernel/irq/affinity.c|275| <<irq_create_affinity_masks>> if (!affd->calc_sets)
+	 *   - kernel/irq/affinity.c|276| <<irq_create_affinity_masks>> affd->calc_sets = default_calc_sets;
+	 *   - kernel/irq/affinity.c|279| <<irq_create_affinity_masks>> affd->calc_sets(affd, affvecs);
+	 *   - kernel/irq/affinity.c|344| <<irq_calc_affinity_vectors>> if (affd->calc_sets) {
+	 */
 	if (!affd->calc_sets)
 		affd->calc_sets = default_calc_sets;
 
@@ -326,6 +386,11 @@ irq_create_affinity_masks(unsigned int nvecs, struct irq_affinity *affd)
  * @maxvec:	The maximum number of vectors available
  * @affd:	Description of the affinity requirements
  */
+/*
+ * called by:
+ *   - drivers/pci/msi.c|1052| <<__pci_enable_msi_range>> nvec = irq_calc_affinity_vectors(minvec, nvec, affd);
+ *   - drivers/pci/msi.c|1094| <<__pci_enable_msix_range>> nvec = irq_calc_affinity_vectors(minvec, nvec, affd);
+ */
 unsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,
 				       const struct irq_affinity *affd)
 {
@@ -335,10 +400,20 @@ unsigned int irq_calc_affinity_vectors(unsigned int minvec, unsigned int maxvec,
 	if (resv > minvec)
 		return 0;
 
+	/*
+	 * used by:
+	 *   - drivers/nvme/host/pci.c|2067| <<nvme_setup_irqs>> .calc_sets = nvme_calc_irq_sets,
+	 *   - drivers/scsi/csiostor/csio_isr.c|504| <<csio_enable_msix>> .calc_sets = csio_calc_sets,
+	 *   - kernel/irq/affinity.c|275| <<irq_create_affinity_masks>> if (!affd->calc_sets)
+	 *   - kernel/irq/affinity.c|276| <<irq_create_affinity_masks>> affd->calc_sets = default_calc_sets;
+	 *   - kernel/irq/affinity.c|279| <<irq_create_affinity_masks>> affd->calc_sets(affd, affvecs);
+	 *   - kernel/irq/affinity.c|344| <<irq_calc_affinity_vectors>> if (affd->calc_sets) {
+	 */
 	if (affd->calc_sets) {
 		set_vecs = maxvec - resv;
 	} else {
 		get_online_cpus();
+		/* Count of bits in *srcp */
 		set_vecs = cpumask_weight(cpu_possible_mask);
 		put_online_cpus();
 	}
diff --git a/kernel/irq/matrix.c b/kernel/irq/matrix.c
index 30cc217..ea7e885 100644
--- a/kernel/irq/matrix.c
+++ b/kernel/irq/matrix.c
@@ -374,6 +374,10 @@ void irq_matrix_remove_reserved(struct irq_matrix *m)
  * @reserved:	Allocate previously reserved interrupts
  * @mapped_cpu: Pointer to store the CPU for which the irq was allocated
  */
+/*
+ * called by:
+ *   - arch/x86/kernel/apic/vector.c|250| <<assign_vector_locked>> vector = irq_matrix_alloc(vector_matrix, dest, resvd, &cpu);
+ */
 int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,
 		     bool reserved, unsigned int *mapped_cpu)
 {
-- 
2.7.4

