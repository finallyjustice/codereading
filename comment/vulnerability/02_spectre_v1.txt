Spectre_v1.

根据内核代码, 只要不是用whilelist明确说明没bug的, 都被X86_BUG_SPECTRE_V1影响.

1320 static void __init cpu_set_bug_bits(struct cpuinfo_x86 *c)
1321 {
1322         u64 x86_arch_cap_msr = x86_read_arch_cap_msr();
1323
1324         /* Set ITLB_MULTIHIT bug if cpu is not in the whitelist and not mitigated */
1325         if (!cpu_matches(cpu_vuln_whitelist, NO_ITLB_MULTIHIT) &&
1326             !(x86_arch_cap_msr & ARCH_CAP_PSCHANGE_MC_NO))
1327                 setup_force_cpu_bug(X86_BUG_ITLB_MULTIHIT);
1328
1329         if (cpu_matches(cpu_vuln_whitelist, NO_SPECULATION))
1330                 return;
1331
1332         setup_force_cpu_bug(X86_BUG_SPECTRE_V1);

---------------------------

SpectreV1 一般就是指论文中那个很有名的pattern.

1. 这个pattern在内核中用带_nospec的accessor解决, 比如array_index_nospec().
这些没法enable或者disable, 只能靠手写代码一行一行改.

都是具体的例子具体分析, 下面的patch就是一个例子.

kernel/sys.c: fix potential Spectre v1 issue
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=23d6aef74da86a33fa6bb75f79565e0a16ee97c2

2. SpectreV1的第二部分设计与swapgs和fsgsbase相关.

(1) fsgsbase是一个CPU的feature, 用户进程或线程想要读写FS/GS base寄存器, 需要执行arch_prctl系统调用. 因为这是privileged operation.

根据Linux kernel的注释, "If FSGSBASE is enabled, the user can put a kernel address in GS, in which case SMAP provides no protection."

这里写fs/gs base的目的不是给kernel用, 也是给user用.
以前想改user的fs/gs还要arch_prctl系统调用帮忙, 现在不用了.

(2) swapgs是一个指令, 比如使用系统调用的时候可以切换gs寄存器(和某个MSR的指切换).

这里不是为了给user或者kernel用, 主要是为了切换.

Linux在进入syscall时可能会这样:

swapgs                  ; 切换到内核GS.base
mov %gs:0, %rax         ; 读取当前CPU的per-cpu数据

然后返回用户态前:

swapgs                  ; 恢复用户态GS.base
sysretq                 ; 返回用户态


在用户和内核切换的地方, 有时候可能是:

if (coming from user space)
	    swapgs
// 基于gs访问percpu数据

如果swapgs上面的if语句被speculative绕过了, 并且用户通过fsgsbase写入了一个用户的gs,
用户空间就可以利用这个speculative访问内核空间的数据.

The kernel entry code interrupt, exception, and NMI handlers all have
conditional swapgs checks.


所以核心的修复主要是靠 line=913到line=940的注释.

x86/speculation: Prepare entry code for Spectre v1 swapgs mitigations
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=18ec54fdd6d18d92025af097cd042a75cf0ea24c

x86/speculation: Enable Spectre v1 swapgs mitigations
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a2059825986a1c8143fd6698774fa9d83733bb11


(1) 如果有FSGSBASE, 用户空间可以修改gs, 所以怎么都不安全.

(2) 就算没有FSGSBASE, 也要考虑smap (在内核能不能访问用户空间).

904 static void __init spectre_v1_select_mitigation(void)
905 {
906         if (!boot_cpu_has_bug(X86_BUG_SPECTRE_V1) || cpu_mitigations_off()) {
907                 spectre_v1_mitigation = SPECTRE_V1_MITIGATION_NONE;
908                 return;
909         }
910
911         if (spectre_v1_mitigation == SPECTRE_V1_MITIGATION_AUTO) {
912                 /*
913                  * With Spectre v1, a user can speculatively control either
914                  * path of a conditional swapgs with a user-controlled GS
915                  * value.  The mitigation is to add lfences to both code paths.
916                  *
917                  * If FSGSBASE is enabled, the user can put a kernel address in
918                  * GS, in which case SMAP provides no protection.
919                  *
920                  * If FSGSBASE is disabled, the user can only put a user space
921                  * address in GS.  That makes an attack harder, but still
922                  * possible if there's no SMAP protection.
923                  */
924                 if (boot_cpu_has(X86_FEATURE_FSGSBASE) ||
925                     !smap_works_speculatively()) {
926                         /*
927                          * Mitigation can be provided from SWAPGS itself or
928                          * PTI as the CR3 write in the Meltdown mitigation
929                          * is serializing.
930                          *
931                          * If neither is there, mitigate with an LFENCE to
932                          * stop speculation through swapgs.
933                          */
934                         if (boot_cpu_has_bug(X86_BUG_SWAPGS) &&
935                             !boot_cpu_has(X86_FEATURE_PTI))
936                                 setup_force_cpu_cap(X86_FEATURE_FENCE_SWAPGS_USER);
937
938                         /*
939                          * Enable lfences in the kernel entry (non-swapgs)
940                          * paths, to prevent user entry from speculatively
941                          * skipping swapgs.
942                          */
943                         setup_force_cpu_cap(X86_FEATURE_FENCE_SWAPGS_KERNEL);
944                 }
945         }
946
947         pr_info("%s\n", spectre_v1_strings[spectre_v1_mitigation]);
948 }

在内核和用户之间切换的地方的swapgs后面, 添加lfence.

--- a/arch/x86/entry/entry_64.S
+++ b/arch/x86/entry/entry_64.S
@@ -519,7 +519,7 @@ ENTRY(interrupt_entry)
        testb   $3, CS-ORIG_RAX+8(%rsp)
        jz      1f
        SWAPGS
-
+       FENCE_SWAPGS_USER_ENTRY
        /*
         * Switch to the thread stack. The IRET frame and orig_ax are
         * on the stack, as well as the return address. RDI..R12 are
@@ -549,8 +549,10 @@ ENTRY(interrupt_entry)
        UNWIND_HINT_FUNC

        movq    (%rdi), %rdi
+       jmpq    2f
 1:
-
+       FENCE_SWAPGS_KERNEL_ENTRY
+2:
        PUSH_AND_CLEAR_REGS save_ret=1
        ENCODE_FRAME_POINTER 8

-------------------

第二部分可以在cmdline disable: "nospectre_v1".

# cat /sys/devices/system/cpu/vulnerabilities/spectre_v1
Mitigation: usercopy/swapgs barriers and __user pointer sanitization

# cat /sys/devices/system/cpu/vulnerabilities/spectre_v1 
Vulnerable: __user pointer sanitization and usercopy barriers only; no swapgs barriers


这是spectre_v1初始化的callstack.

[0] spectre_v1_select_mitigation
[0] cpu_select_mitigations
[0] arch_cpu_finalize_init
[0] start_kernel
[0] x86_64_start_reservations
[0] x86_64_start_kernel
[0] common_startup_64

[    0.246019] Spectre V1 : Mitigation: usercopy/swapgs barriers and __user pointer sanitization
[    0.254980] Spectre V2 : Mitigation: Retpolines
[    0.255979] Spectre V2 : Spectre v2 / SpectreRSB mitigation: Filling RSB on context switch
[    0.256978] Spectre V2 : Spectre v2 / SpectreRSB : Filling RSB on VMEXIT
[    0.257979] Spectre V2 : Enabling Restricted Speculation for firmware calls
[    0.258980] Spectre V2 : mitigation: Enabling conditional Indirect Branch Prediction Barrier
[    0.259979] Speculative Store Bypass: Mitigation: Speculative Store Bypass disabled via prctl
[    0.260982] MDS: Mitigation: Clear CPU buffers
[    0.261978] TAA: Mitigation: Clear CPU buffers
[    0.262978] MMIO Stale Data: Vulnerable: Clear CPU buffers attempted, no microcode
