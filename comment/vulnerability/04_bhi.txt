# SpectreV2原理:

利用CPU的分支目标预测器(BTB, Branch Target Buffer).
攻击者训练BTB,使得受害者进程中间接跳转(如 jmp *%rax)在投机执行阶段跳到攻击者准备的gadget.
虽然真正跳转时CPU会发现错了,但投机执行期间的数据访问可泄露敏感信息(通过cache timing等方式).

# Retpoline的防御原理:

通过ret, 彻底避开了间接跳转预测的参与,使BTB被"绕过".
BTB不再参与间接跳转的预测过程.
CPU对ret指令的预测只能依赖于RSB(Return Stack Buffer),而RSB是按调用-返回对维护的,攻击者很难污染.
投机跳转只能去trampoline,而非攻击者gadget.
所以:SpectreV2成立的关键是BTB被污染,Retpoline正好绕开了BTB.

# 纯Retpoline为什么能防BHI?

RRSBA是某些CPU的硬件行为特性,在RSB underflow时,不是停下来等待真正返回地址,而是fallback到BTB/BHB来猜测返回地址.

BHI利用的是BHB(Branch History Buffer),记录之前是否taken的分支路径.

在CPU 执行分支预测时,不仅仅依赖BTB,还会使用BHB中的历史信息做路径选择.

如果CPU的ret执行过程中发生fallback to BTB/BHB(RRSBA),那么BHB被攻击者污染就可能影响投机路径.
在没有RRSBA行为的CPU上, ret 始终使用RSB预测跳转,而不是fallback到BTB/BHB.
此时, Retpoline构造的ret安全有效,不会受到BHB的污染影响.
因此在这些 CPU 上,Retpoline间接"顺带"也防住了BHI,即便不是设计目标.
Again, Retpoline是一种"软件绕过硬件预测器"的技巧,不是阻止预测,而是从根本不走那条路.

# 假设CPU没有RRSBA, 为什么retpoline可以防BHI, 同时retpoline + lfence就不可以?

因为Retpoline+LFENCE在某些实现中,破坏了RSB的正常工作,使得CPU fallback到其他预测路径(如BTB/BHB),从而导致BHI重新成为可能.
在没有RRSBA的CPU上,Retpoline单独使用时能保证RSB是有效的,所以防住了BHI.
加了LFENCE后,打乱了CPU对ret指令的正常处理方式(例如pipeline flush),使得RSB不再被正确使用,可能导致fallback,反而引入了攻击面.
