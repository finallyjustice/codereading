

/proc/cpuinfo可能会有一个"arch_capabilities" feature.
并不是所有的Intel CPU都有.
比如在Icelake上我看到了, 但是没有在Broadwell看到.
在AMD上也看不到, 算是Intel的feature.

/* Intel-defined CPU features, CPUID level 0x00000007:0 (EDX), word 18 */
... ...
#define X86_FEATURE_ARCH_CAPABILITIES   (18*32+29) /* "arch_capabilities" IA32_ARCH_CAPABILITIES MSR (Intel) */

icelake$ cpuid -1 -l 0x7 | grep ARCH
      IA32_ARCH_CAPABILITIES MSR               = true

broadwell$ cpuid -1 -l 0x7  | grep ARCH
      IA32_ARCH_CAPABILITIES MSR               = false

amd$ cpuid -1 -l 0x7 | grep ARCH
      IA32_ARCH_CAPABILITIES MSR               = false


如果支持X86_FEATURE_ARCH_CAPABILITIES, 就可以读取MSR_IA32_ARCH_CAPABILITIES.

1285 u64 x86_read_arch_cap_msr(void)
1286 {
1287         u64 x86_arch_cap_msr = 0;
1288 
1289         if (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES))
1290                 rdmsrl(MSR_IA32_ARCH_CAPABILITIES, x86_arch_cap_msr);
1291 
1292         return x86_arch_cap_msr;
1293 }

下面是一些对相关feature bit的信息.
比如ARCH_CAP_RDCL_NO表示当前CPU是否有Meltdown的问题.

125 #define MSR_IA32_ARCH_CAPABILITIES      0x0000010a
126 #define ARCH_CAP_RDCL_NO                BIT(0)  /* Not susceptible to Meltdown */
127 #define ARCH_CAP_IBRS_ALL               BIT(1)  /* Enhanced IBRS support */
128 #define ARCH_CAP_RSBA                   BIT(2)  /* RET may use alternative branch predictors */
129 #define ARCH_CAP_SKIP_VMENTRY_L1DFLUSH  BIT(3)  /* Skip L1D flush on vmentry */
130 #define ARCH_CAP_SSB_NO                 BIT(4)  /*
131                                                  * Not susceptible to Speculative Store Bypass
132                                                  * attack, so no Speculative Store Bypass
133                                                  * control required.

-----------------

[0] cpu_set_bug_bits
[0] early_identify_cpu
[0] early_cpu_init
[0] setup_arch
[0] start_kernel
[0] x86_64_start_reservations
[0] x86_64_start_kernel
[0] common_startup_64

有两个重要的数组.

cpu_vuln_whitelist[] --> 会告诉不需要哪些bug.
cpu_vuln_blacklist[] --> 会告诉哪些bug是需要的.

cpu_set_bug_bits()会用setup_force_cpu_bug()来set各种bugs.

# cat /proc/cpuinfo | grep bug
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa mmio_stale_data bhi ibpb_no_ret
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa mmio_stale_data bhi ibpb_no_ret
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa mmio_stale_data bhi ibpb_no_ret
bugs		: cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf mds swapgs taa mmio_stale_data bhi ibpb_no_ret

比如, 根据cpu_vuln_whitelist[], Zhaoxin不支持SpectreV2.

1153 static const __initconst struct x86_cpu_id cpu_vuln_whitelist[] = {
... ...
1212         VULNWL(CENTAUR, 7, X86_MODEL_ANY,       NO_SPECTRE_V2 | NO_SWAPGS | NO_MMIO | NO_BHI),
1213         VULNWL(ZHAOXIN, 7, X86_MODEL_ANY,       NO_SPECTRE_V2 | NO_SWAPGS | NO_MMIO | NO_BHI),

-----------------

通过sysfs可以看到每一个bug的细节.

# cat /sys/devices/system/cpu/vulnerabilities/spectre_v1
Mitigation: usercopy/swapgs barriers and __user pointer sanitization


[0] cpu_show_common
[0] cpu_show_spectre_v1
[0] dev_attr_show
[0] sysfs_kf_seq_show
[0] seq_read_iter
[0] vfs_read
[0] ksys_read
[0] do_syscall_64
[0] entry_SYSCALL_64_after_hwframe

-----------------

启动后会根据bugs选择mitigations.

[0] spectre_v1_select_mitigation
[0] cpu_select_mitigations
[0] arch_cpu_finalize_init
[0] start_kernel
[0] x86_64_start_reservations
[0] x86_64_start_kernel
[0] common_startup_64

[    0.246019] Spectre V1 : Mitigation: usercopy/swapgs barriers and __user pointer sanitization
[    0.254980] Spectre V2 : Mitigation: Retpolines
[    0.255979] Spectre V2 : Spectre v2 / SpectreRSB mitigation: Filling RSB on context switch
[    0.256978] Spectre V2 : Spectre v2 / SpectreRSB : Filling RSB on VMEXIT
[    0.257979] Spectre V2 : Enabling Restricted Speculation for firmware calls
[    0.258980] Spectre V2 : mitigation: Enabling conditional Indirect Branch Prediction Barrier
[    0.259979] Speculative Store Bypass: Mitigation: Speculative Store Bypass disabled via prctl
[    0.260982] MDS: Mitigation: Clear CPU buffers
[    0.261978] TAA: Mitigation: Clear CPU buffers
[    0.262978] MMIO Stale Data: Vulnerable: Clear CPU buffers attempted, no microcode

131 void __init cpu_select_mitigations(void)
132 {
133         /*
134          * Read the SPEC_CTRL MSR to account for reserved bits which may
135          * have unknown values. AMD64_LS_CFG MSR is cached in the early AMD
136          * init code as it is not enumerated and depends on the family.
137          */
138         if (cpu_feature_enabled(X86_FEATURE_MSR_SPEC_CTRL)) {
139                 rdmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base);
140 
141                 /*
142                  * Previously running kernel (kexec), may have some controls
143                  * turned ON. Clear them and let the mitigations setup below
144                  * rediscover them based on configuration.
145                  */
146                 x86_spec_ctrl_base &= ~SPEC_CTRL_MITIGATIONS_MASK;
147         }
148 
149         x86_arch_cap_msr = x86_read_arch_cap_msr();
150 
151         /* Select the proper CPU mitigations before patching alternatives: */
152         spectre_v1_select_mitigation();
153         spectre_v2_select_mitigation();
154         /*
155          * retbleed_select_mitigation() relies on the state set by
156          * spectre_v2_select_mitigation(); specifically it wants to know about
157          * spectre_v2=ibrs.
158          */
159         retbleed_select_mitigation();
160         /*
161          * spectre_v2_user_select_mitigation() relies on the state set by
162          * retbleed_select_mitigation(); specifically the STIBP selection is
163          * forced for UNRET or IBPB.
164          */
165         spectre_v2_user_select_mitigation();
166         ssb_select_mitigation();
167         l1tf_select_mitigation();
168         md_clear_select_mitigation();
169         srbds_select_mitigation();
170         l1d_flush_select_mitigation();
171 
172         /*
173          * srso_select_mitigation() depends and must run after
174          * retbleed_select_mitigation().
175          */
176         srso_select_mitigation();
177         gds_select_mitigation();
178 }

"mitigations=off" stops any mitigation.

一些例子:

# cat /sys/devices/system/cpu/vulnerabilities/spectre_v1
Vulnerable: __user pointer sanitization and usercopy barriers only; no swapgs barriers

# cat /sys/devices/system/cpu/vulnerabilities/spectre_v2
Vulnerable; IBPB: disabled; STIBP: disabled; PBRSB-eIBRS: Not affected; BHI: Vulnerable

# cat /sys/devices/system/cpu/vulnerabilities/meltdown
Vulnerable

# cat /sys/devices/system/cpu/vulnerabilities/retbleed
Not affected

# cat /sys/devices/system/cpu/vulnerabilities/ghostwrite
Not affected

# cat /sys/devices/system/cpu/vulnerabilities/itlb_multihit
Not affected

# cat /sys/devices/system/cpu/vulnerabilities/l1tf
Mitigation: PTE Inversion

