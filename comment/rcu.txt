

rcu_read_lock()
 -> __rcu_read_lock()

如果设置了CONFIG_PREEMPT_RCU

195 /*
196  * Preemptible RCU implementation for rcu_read_lock().
197  * Just increment ->rcu_read_lock_nesting, shared state will be updated
198  * if we block.
199  */
200 void __rcu_read_lock(void)
201 {
202         current->rcu_read_lock_nesting++;
203         barrier();  /* critical section after entry code. */
204 }

如果没有设置CONFIG_PREEMPT_RCU

307 static inline void __rcu_read_lock(void)
308 {
309         if (IS_ENABLED(CONFIG_PREEMPT_COUNT))
310                 preempt_disable();
311 }


Desktop/Server Linux基本都是没有设置CONFIG_PREEMPT_COUNT的.

所以在Desktop/Server上rcu_read_lock()等价于什么都不做.

只是增加了额外的编程限制: 不可以在rcu的read-size critical section主动睡眠/调度
