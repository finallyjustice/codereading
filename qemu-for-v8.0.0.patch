From abcdcfb9540ba748dde8b9c2a025bc390143db90 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Sat, 22 Jul 2023 22:12:30 -0700
Subject: [PATCH 1/1] qemu for v8.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 dump/dump.c              | 85 ++++++++++++++++++++++++++++++++++++++++
 softmmu/memory_mapping.c |  7 ++++
 2 files changed, 92 insertions(+)

diff --git a/dump/dump.c b/dump/dump.c
index 1f1a6edca..fac289a08 100644
--- a/dump/dump.c
+++ b/dump/dump.c
@@ -1180,6 +1180,11 @@ static size_t dump_bitmap_get_bufsize(DumpState *s)
  * (last bit + sizeof(buf) * 8) to 0 will do flushing the content in buf into
  * vmcore, ie. synchronizing un-sync bit into vmcore.
  */
+/*
+ * called by:
+ *   - dump/dump.c|1354| <<write_dump_bitmap>> ret = set_dump_bitmap(last_pfn, pfn, true, dump_bitmap_buf, s);
+ *   - dump/dump.c|1370| <<write_dump_bitmap>> ret = set_dump_bitmap(last_pfn, last_pfn + bits_per_buf, false,
+ */
 static int set_dump_bitmap(uint64_t last_pfn, uint64_t pfn, bool value,
                            uint8_t *buf, DumpState *s)
 {
@@ -1233,6 +1238,13 @@ static int set_dump_bitmap(uint64_t last_pfn, uint64_t pfn, bool value,
     return 0;
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|1273| <<get_next_page>> *pfnptr = dump_paddr_to_pfn(s, addr);
+ *   - dump/dump.c|1314| <<get_next_page>> if (dump_paddr_to_pfn(s, addr) != *pfnptr) {
+ *   - dump/dump.c|1320| <<get_next_page>> *pfnptr = dump_paddr_to_pfn(s, addr);
+ *   - dump/dump.c|1713| <<get_max_mapnr>> s->max_mapnr = dump_paddr_to_pfn(s, last_block->target_end);
+ */
 static uint64_t dump_paddr_to_pfn(DumpState *s, uint64_t addr)
 {
     int target_page_shift = ctz32(s->dump_info.page_size);
@@ -1240,6 +1252,10 @@ static uint64_t dump_paddr_to_pfn(DumpState *s, uint64_t addr)
     return (addr >> target_page_shift) - ARCH_PFN_OFFSET;
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|1276| <<get_next_page>> addr = dump_pfn_to_paddr(s, *pfnptr);
+ */
 static uint64_t dump_pfn_to_paddr(DumpState *s, uint64_t pfn)
 {
     int target_page_shift = ctz32(s->dump_info.page_size);
@@ -1252,10 +1268,20 @@ static uint64_t dump_pfn_to_paddr(DumpState *s, uint64_t pfn)
  * NULL. If not NULL, *bufptr must contains a target page size of pre-allocated
  * memory. This is not necessarily the memory returned.
  */
+/*
+ * called by:
+ *   - dump/dump.c|1348| <<write_dump_bitmap>> while (get_next_page(&block_iter, &pfn, NULL, s)) {
+ *   - dump/dump.c|1505| <<write_dump_pages>> for (buf = page; get_next_page(&block_iter, &pfn_iter, &buf, s); buf = page) {
+ *
+ * pfn_iter根本不会在caller用到 (pfnptr)
+ */
 static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,
                           uint8_t **bufptr, DumpState *s)
 {
     GuestPhysBlock *block = *blockptr;
+    /*
+     * arm是0x10000
+     */
     uint32_t page_size = s->dump_info.page_size;
     uint8_t *buf = NULL, *hbuf;
     hwaddr addr;
@@ -1274,7 +1300,13 @@ static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,
 
     while (1) {
         if (addr >= block->target_start && addr < block->target_end) {
+            /*
+	     * n是要拷贝的内存大小
+	     */
             size_t n = MIN(block->target_end - addr, page_size - addr % page_size);
+            /*
+	     * uint8_t *buf = NULL, *hbuf;
+	     */
             hbuf = block->host_addr + (addr - block->target_start);
             if (!buf) {
                 if (n == page_size) {
@@ -1325,6 +1357,10 @@ static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,
     return buf != NULL;
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|1719| <<create_kdump_vmcore>> write_dump_bitmap(s, errp);
+ */
 static void write_dump_bitmap(DumpState *s, Error **errp)
 {
     int ret = 0;
@@ -1446,6 +1482,10 @@ static size_t get_len_buf_out(size_t page_size, uint32_t flag_compress)
     return 0;
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|1663| <<create_kdump_vmcore>> write_dump_pages(s, errp);
+ */
 static void write_dump_pages(DumpState *s, Error **errp)
 {
     int ret = 0;
@@ -1462,6 +1502,14 @@ static void write_dump_pages(DumpState *s, Error **errp)
     uint64_t pfn_iter;
     g_autofree uint8_t *page = NULL;
 
+    /*
+     * off_t offset_dump_bitmap;   // offset of dump_bitmap part in vmcore
+     * off_t offset_page;          // offset of page part in vmcore
+     * size_t num_dumpable;        // number of page that can be dumped
+     * uint32_t flag_compress;     // indicate the compression format
+     * DumpStatus status;          // current dump status
+     */
+
     /* get offset of page_desc and page_data in dump file */
     offset_desc = s->offset_page;
     offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable;
@@ -1477,6 +1525,9 @@ static void write_dump_pages(DumpState *s, Error **errp)
     wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS);
 #endif
 
+    /*
+     * uint8_t *buf_out = NULL;
+     */
     buf_out = g_malloc(len_buf_out);
 
     /*
@@ -1502,6 +1553,13 @@ static void write_dump_pages(DumpState *s, Error **errp)
      * dump memory to vmcore page by page. zero page will all be resided in the
      * first page of page section
      */
+    /*
+     * uint8_t *buf;
+     * GuestPhysBlock *block_iter = NULL;
+     * uint64_t pfn_iter;
+     *
+     * pfn_iter根本不会在caller用到
+     */
     for (buf = page; get_next_page(&block_iter, &pfn_iter, &buf, s); buf = page) {
         /* check zero page */
         if (buffer_is_zero(buf, s->dump_info.page_size)) {
@@ -1523,6 +1581,9 @@ static void write_dump_pages(DumpState *s, Error **errp)
              * s->flag_compress is set. But when compression fails to work,
              * we fall back to save in plaintext.
              */
+             /*
+	      * uint8_t *buf_out = NULL;
+	      */
              size_out = len_buf_out;
              if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) &&
                     (compress2(buf_out, (uLongf *)&size_out, buf,
@@ -1617,6 +1678,10 @@ out:
     g_free(buf_out);
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|2033| <<dump_process>> create_kdump_vmcore(s, errp);
+ */
 static void create_kdump_vmcore(DumpState *s, Error **errp)
 {
     ERRP_GUARD();
@@ -1773,6 +1838,10 @@ static void vmcoreinfo_update_phys_base(DumpState *s)
     g_strfreev(lines);
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|2183| <<qmp_dump_guest_memory>> dump_init(s, fd, has_format, format, paging, has_begin,
+ */
 static void dump_init(DumpState *s, int fd, bool has_format,
                       DumpGuestMemoryFormat format, bool paging, bool has_filter,
                       int64_t begin, int64_t length, Error **errp)
@@ -1827,6 +1896,13 @@ static void dump_init(DumpState *s, int fd, bool has_format,
     memory_mapping_list_init(&s->list);
 
     guest_phys_blocks_init(&s->guest_phys_blocks);
+    /*
+     * called by:
+     *   - dump/dump.c|1847| <<dump_init>> guest_phys_blocks_append(&s->guest_phys_blocks);
+     *   - hw/s390x/s390-skeys.c|157| <<qmp_dump_skeys>> guest_phys_blocks_append(&guest_phys_blocks);
+     *   - hw/s390x/s390-skeys.c|320| <<s390_storage_keys_save>> guest_phys_blocks_append(&guest_phys_blocks);
+     *   - hw/tpm/tpm_ppi.c|31| <<tpm_ppi_reset>> guest_phys_blocks_append(&guest_phys_blocks);
+     */
     guest_phys_blocks_append(&s->guest_phys_blocks);
     s->total_size = dump_calculate_size(s);
 #ifdef DEBUG_DUMP_GUEST_MEMORY
@@ -2013,6 +2089,11 @@ cleanup:
 }
 
 /* this operation might be time consuming. */
+/*
+ * called by:
+ *   - dump/dump.c|2061| <<dump_thread>> dump_process(s, NULL);
+ *   - dump/dump.c|2197| <<qmp_dump_guest_memory>> dump_process(s, errp);
+ */
 static void dump_process(DumpState *s, Error **errp)
 {
     ERRP_GUARD();
@@ -2042,6 +2123,10 @@ static void dump_process(DumpState *s, Error **errp)
     dump_cleanup(s);
 }
 
+/*
+ * 在以下使用dump_thread():
+ *   - dump/dump.c|2193| <<qmp_dump_guest_memory>> qemu_thread_create(&s->dump_thread, "dump_thread", dump_thread,
+ */
 static void *dump_thread(void *data)
 {
     DumpState *s = (DumpState *)data;
diff --git a/softmmu/memory_mapping.c b/softmmu/memory_mapping.c
index d7f1d096e..a137bcf19 100644
--- a/softmmu/memory_mapping.c
+++ b/softmmu/memory_mapping.c
@@ -281,6 +281,13 @@ static void guest_phys_blocks_region_add(MemoryListener *listener,
     guest_phys_block_add_section(g, section);
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|1847| <<dump_init>> guest_phys_blocks_append(&s->guest_phys_blocks);
+ *   - hw/s390x/s390-skeys.c|157| <<qmp_dump_skeys>> guest_phys_blocks_append(&guest_phys_blocks);
+ *   - hw/s390x/s390-skeys.c|320| <<s390_storage_keys_save>> guest_phys_blocks_append(&guest_phys_blocks);
+ *   - hw/tpm/tpm_ppi.c|31| <<tpm_ppi_reset>> guest_phys_blocks_append(&guest_phys_blocks);
+ */
 void guest_phys_blocks_append(GuestPhysBlockList *list)
 {
     GuestPhysListener g = { 0 };
-- 
2.34.1

