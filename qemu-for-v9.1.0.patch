From 40bf6e8cd542a9923dbe2837d67589dad5d8bbb3 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 16 Sep 2024 00:54:17 -0700
Subject: [PATCH 1/1] qemu for v9.1.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-accel-ops.c     |   7 +
 accel/kvm/kvm-all.c           |  35 ++
 block.c                       | 130 +++++
 block/file-posix.c            |  50 ++
 block/io.c                    |   9 +
 block/mirror.c                |  77 +++
 blockdev.c                    |  55 ++
 hw/block/virtio-blk.c         |  41 ++
 hw/core/nmi.c                 |  12 +
 hw/pci/pcie.c                 |  11 +
 hw/pci/pcie_aer.c             |   7 +
 hw/pci/pcie_port.c            |   7 +
 hw/scsi/megasas.c             |   6 +
 hw/scsi/scsi-bus.c            |   6 +
 hw/scsi/scsi-disk.c           |  26 +
 hw/scsi/scsi-generic.c        |   6 +
 hw/scsi/virtio-scsi.c         |   6 +
 hw/vfio/pci.c                 |  13 +
 include/hw/block/block.h      |  32 ++
 include/hw/virtio/virtio.h    |  33 ++
 include/sysemu/accel-ops.h    |  27 +
 qom/object.c                  |  26 +
 target/i386/cpu.c             | 869 ++++++++++++++++++++++++++++++
 target/i386/cpu.h             | 142 +++++
 target/i386/host-cpu.c        |  25 +
 target/i386/kvm/kvm-cpu.c     |  50 ++
 target/i386/kvm/kvm.c         | 965 ++++++++++++++++++++++++++++++++++
 target/i386/kvm/vmsr_energy.c |  51 ++
 target/i386/machine.c         |  45 ++
 util/oslib-posix.c            |   7 +
 30 files changed, 2776 insertions(+)

diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index c239dfc87..ea6884b3e 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -26,6 +26,10 @@
 #include <linux/kvm.h>
 #include "kvm-cpus.h"
 
+/*
+ * 在以下使用kvm_vcpu_thread_fn():
+ *   - accel/kvm/kvm-accel-ops.c|71| <<kvm_start_vcpu_thread>> qemu_thread_create(cpu->thread, thread_name, kvm_vcpu_thread_fn, cpu, QEMU_THREAD_JOINABLE);
+ */
 static void *kvm_vcpu_thread_fn(void *arg)
 {
     CPUState *cpu = arg;
@@ -38,6 +42,9 @@ static void *kvm_vcpu_thread_fn(void *arg)
     cpu->thread_id = qemu_get_thread_id();
     current_cpu = cpu;
 
+    /*
+     * 只在此处调用
+     */
     r = kvm_init_vcpu(cpu, &error_fatal);
     kvm_init_cpu_signals(cpu);
 
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 75d11a07b..2e1a71a57 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -105,6 +105,13 @@ static const KVMCapabilityInfo kvm_required_capabilites[] = {
     KVM_CAP_LAST_INFO
 };
 
+/*
+ * 在以下使用kvm_irqchip_change_notifiers:
+ *   - accel/kvm/kvm-all.c|108| <<global>> static NotifierList kvm_irqchip_change_notifiers =
+ *   - accel/kvm/kvm-all.c|109| <<global>> NOTIFIER_LIST_INITIALIZER(kvm_irqchip_change_notifiers);
+ *   - accel/kvm/kvm-all.c|2041| <<kvm_irqchip_add_change_notifier>> notifier_list_add(&kvm_irqchip_change_notifiers, n);
+ *   - accel/kvm/kvm-all.c|2051| <<kvm_irqchip_change_notify>> notifier_list_notify(&kvm_irqchip_change_notifiers, NULL);
+ */
 static NotifierList kvm_irqchip_change_notifiers =
     NOTIFIER_LIST_INITIALIZER(kvm_irqchip_change_notifiers);
 
@@ -456,6 +463,10 @@ void kvm_destroy_vcpu(CPUState *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|45| <<kvm_vcpu_thread_fn>> r = kvm_init_vcpu(cpu, &error_fatal);
+ */
 int kvm_init_vcpu(CPUState *cpu, Error **errp)
 {
     KVMState *s = kvm_state;
@@ -507,6 +518,16 @@ int kvm_init_vcpu(CPUState *cpu, Error **errp)
         }
     }
 
+    /*
+     * 支持的架构:
+     *   - target/arm/kvm.c|1863| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/i386/kvm/kvm.c|2255| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/loongarch/kvm/kvm.c|666| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/mips/kvm.c|64| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/ppc/kvm.c|480| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/riscv/kvm/kvm-cpu.c|1358| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/s390x/kvm/kvm.c|410| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     */
     ret = kvm_arch_init_vcpu(cpu);
     if (ret < 0) {
         error_setg_errno(errp, -ret,
@@ -2763,6 +2784,10 @@ void kvm_flush_coalesced_mmio_buffer(void)
     s->coalesced_flush_in_progress = false;
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-all.c|2804| <<kvm_cpu_synchronize_state>> run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
@@ -2777,6 +2802,16 @@ static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|108| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - accel/kvm/kvm-all.c|3156| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+ *   - target/i386/kvm/kvm.c|6348| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6367| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6385| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6390| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6916| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+ */
 void kvm_cpu_synchronize_state(CPUState *cpu)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
diff --git a/block.c b/block.c
index c317de9ea..cb54242b8 100644
--- a/block.c
+++ b/block.c
@@ -68,6 +68,11 @@
 
 #define NOT_DONE 0x7fffffff /* used while emulated sync operation in progress */
 
+/*
+ * Managing the New Block Layer
+ * https://events.static.linuxfound.org/sites/events/files/slides/talk_11.pdf
+ */
+
 /* Protected by BQL */
 static QTAILQ_HEAD(, BlockDriverState) graph_bdrv_states =
     QTAILQ_HEAD_INITIALIZER(graph_bdrv_states);
@@ -2378,6 +2383,31 @@ TransactionActionDrv bdrv_drv_set_perm_drv = {
     .commit = bdrv_drv_set_perm_commit,
 };
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 /*
  * After calling this function, the transaction @tran may only be completed
  * while holding a reader lock for the graph.
@@ -2488,6 +2518,31 @@ bdrv_replace_child_tran(BdrvChild *child, BlockDriverState *new_bs,
     /* old_bs reference is transparently moved from @child to @s */
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 /*
  * Refresh permissions in @bs subtree. The function is intended to be called
  * after some graph modification that was done without permission update.
@@ -2567,6 +2622,31 @@ bdrv_node_refresh_perm(BlockDriverState *bs, BlockReopenQueue *q,
     return 0;
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 /*
  * @list is a product of bdrv_topological_dfs() (may be called several times) -
  * a topologically sorted subgraph.
@@ -5306,6 +5386,31 @@ static void GRAPH_WRLOCK bdrv_remove_child(BdrvChild *child, Transaction *tran)
     tran_add(tran, &bdrv_remove_child_drv, child);
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 /*
  * Both @from and @to (if non-NULL) must be drained. @to must be kept drained
  * until the transaction is completed.
@@ -5347,6 +5452,31 @@ bdrv_replace_node_noperm(BlockDriverState *from,
     return 0;
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 /*
  * Switch all parents of @from to point to @to instead. @from and @to must be in
  * the same AioContext and both must be drained.
diff --git a/block/file-posix.c b/block/file-posix.c
index ff928b5e8..ec168f9ab 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -959,6 +959,31 @@ static int raw_check_lock_bytes(int fd, uint64_t perm, uint64_t shared_perm,
     return 0;
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 static int raw_handle_perm_lock(BlockDriverState *bs,
                                 RawPermLockOp op,
                                 uint64_t new_perm, uint64_t new_shared,
@@ -3747,6 +3772,31 @@ static QemuOptsList raw_create_opts = {
     }
 };
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 static int raw_check_perm(BlockDriverState *bs, uint64_t perm, uint64_t shared,
                           Error **errp)
 {
diff --git a/block/io.c b/block/io.c
index 301514c88..6e7505ee1 100644
--- a/block/io.c
+++ b/block/io.c
@@ -570,6 +570,15 @@ void bdrv_drain_all_end(void)
     bdrv_drain_all_count--;
 }
 
+/*
+ * called by:
+ *   - block.c|5265| <<bdrv_close_all>> bdrv_drain_all();
+ *   - blockdev.c|2188| <<qmp_transaction>> bdrv_drain_all();
+ *   - hw/xen/xen-mapcache.c|700| <<xen_invalidate_map_cache>> bdrv_drain_all();
+ *   - qemu-io.c|679| <<main>> bdrv_drain_all();
+ *   - system/cpus.c|307| <<do_vm_stop>> bdrv_drain_all();
+ *   - system/cpus.c|786| <<vm_stop_force_state>> bdrv_drain_all();
+ */
 void bdrv_drain_all(void)
 {
     GLOBAL_STATE_CODE();
diff --git a/block/mirror.c b/block/mirror.c
index 61f0a717b..8dcd1a39d 100644
--- a/block/mirror.c
+++ b/block/mirror.c
@@ -480,6 +480,10 @@ static unsigned mirror_perform(MirrorBlockJob *s, int64_t offset,
     return bytes_handled;
 }
 
+/*
+ * called by:
+ *   - block/mirror.c|1078| <<mirror_run>> mirror_iteration(s);
+ */
 static void coroutine_fn GRAPH_UNLOCKED mirror_iteration(MirrorBlockJob *s)
 {
     BlockDriverState *source;
@@ -1706,6 +1710,42 @@ static BlockDriver bdrv_mirror_top = {
     .filtered_child_is_backing  = true,
 };
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ *
+ * bs     :
+ *   - filename = "/tmp/overlay01.qcow2"i,
+ *   - exact_filename = "/tmp/overlay01.qcow2"
+ *   - backing_file = "test01.qcow2"
+ *   - auto_backing_file = "test01.qcow2"
+ * target :
+ *   - filename = "test01.qcow2"
+ *   - exact_filename = "test01.qcow2"
+ *   - backing_file = 0
+ *   - auto_backing_file = 0
+ */
 static BlockJob *mirror_start_job(
                              const char *job_id, BlockDriverState *bs,
                              int creation_flags, BlockDriverState *target,
@@ -2039,6 +2079,43 @@ void mirror_start(const char *job_id, BlockDriverState *bs,
                      filter_node_name, true, copy_mode, false, errp);
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ *
+ * 两个重要的参数:
+ * bs   :
+ *   - filename = "/tmp/overlay01.qcow2",
+ *   - exact_filename = "/tmp/overlay01.qcow2"
+ *   - backing_file = "test01.qcow2"
+ *   - auto_backing_file = "test01.qcow2"
+ * base :
+ *   - filename = "test01.qcow2"
+ *   - exact_filename = "test01.qcow2"
+ *   - backing_file = 0
+ *   - auto_backing_file = 0
+ */
 BlockJob *commit_active_start(const char *job_id, BlockDriverState *bs,
                               BlockDriverState *base, int creation_flags,
                               int64_t speed, BlockdevOnError on_error,
diff --git a/blockdev.c b/blockdev.c
index 835064ed0..59bbb8e56 100644
--- a/blockdev.c
+++ b/blockdev.c
@@ -2423,6 +2423,35 @@ out_rdlock:
     bdrv_graph_rdunlock_main_loop();
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ *
+ * (QEMU) blockdev-snapshot-sync node-name=drive01 snapshot-file=/tmp/overlay01.qcow2 snapshot-node-name=over01
+ * (QEMU) block-commit device=over01 job-id=jobA
+ * (QEMU) block-job-complete device=jobA
+ */
 void qmp_block_commit(const char *job_id, const char *device,
                       const char *base_node,
                       const char *base,
@@ -2559,6 +2588,19 @@ void qmp_block_commit(const char *job_id, const char *device,
         }
     }
 
+    /*
+     * 这里有两个很重要的:
+     * top_bs  :
+     *   - filename = "/tmp/overlay01.qcow2"i,
+     *   - exact_filename = "/tmp/overlay01.qcow2"
+     *   - backing_file = "test01.qcow2"
+     *   - auto_backing_file = "test01.qcow2"
+     * base_bs :
+     *   - filename = "test01.qcow2"
+     *   - exact_filename = "test01.qcow2"
+     *   - backing_file = 0
+     *   - auto_backing_file = 0
+     */
     /* Do not allow attempts to commit an image into itself */
     if (top_bs == base_bs) {
         error_setg(errp, "cannot commit an image into itself");
@@ -2596,6 +2638,19 @@ void qmp_block_commit(const char *job_id, const char *device,
              */
             job_id = bdrv_get_device_name(bs);
         }
+        /*
+	 * 两个重要的参数:
+	 * top_bs  :
+	 *   - filename = "/tmp/overlay01.qcow2"i,
+	 *   - exact_filename = "/tmp/overlay01.qcow2"
+	 *   - backing_file = "test01.qcow2"
+	 *   - auto_backing_file = "test01.qcow2"
+	 * base_bs :
+	 *   - filename = "test01.qcow2"
+	 *   - exact_filename = "test01.qcow2"
+	 *   - backing_file = 0
+	 *   - auto_backing_file = 0
+	 */
         commit_active_start(job_id, top_bs, base_bs, job_flags, speed, on_error,
                             filter_node_name, NULL, NULL, false, &local_err);
     } else {
diff --git a/hw/block/virtio-blk.c b/hw/block/virtio-blk.c
index 73bdfd612..19fd25ddb 100644
--- a/hw/block/virtio-blk.c
+++ b/hw/block/virtio-blk.c
@@ -37,6 +37,47 @@
 #include "hw/virtio/virtio-blk-common.h"
 #include "qemu/coroutine.h"
 
+/*
+ * QEMU-9.0的例子.
+ *
+ * (gdb) bt
+ * #0  blk_new (ctx=0x55555716e240, perm=0, shared_perm=15) at ../block/block-backend.c:357
+ * #1  0x000055555593f279 in set_drive_helper (obj=0x5555580dc630, v=
+ *     0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, iothread=false, errp=0x7fffffffd710) at ../hw/core/qdev-properties-system.c:146
+ * #2  0x000055555593f453 in set_drive (obj=0x5555580dc630, v=0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, errp=0x7fffffffd710)
+ *     at ../hw/core/qdev-properties-system.c:190
+ * #3  0x0000555555e8b43c in field_prop_set (obj=0x5555580dc630, v=0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, errp=0x7fffffffd710)
+ *     at ../hw/core/qdev-properties.c:88
+ * #4  0x0000555555e98e36 in object_property_set (obj=0x5555580dc630, name=0x5555580de030 "drive", v=0x5555580e0fc0, errp=0x7fffffffd710) at ../qom/object.c:1472
+ * #5  0x0000555555e9c464 in property_set_alias (obj=0x5555580d4260, v=0x5555580e0e00, name=0x5555580e0d90 "drive", opaque=0x5555580de010, errp=0x7fffffffd710) at ../qom/object.c:2799
+ * #6  0x0000555555e98e36 in object_property_set (obj=0x5555580d4260, name=0x5555580e0d90 "drive", v=0x5555580e0e00, errp=0x7fffffffd710) at ../qom/object.c:1472
+ * #7  0x0000555555e9cbc1 in object_set_properties_from_qdict (obj=0x5555580d4260, qdict=0x5555580dfc70, v=0x5555580e0e00, errp=0x7fffffffd710) at ../qom/object_interfaces.c:55
+ * #8  0x0000555555e9ccbc in object_set_properties_from_keyval (obj=0x5555580d4260, qdict=0x5555580dfc70, from_json=false, errp=0x7fffffffd710) at ../qom/object_interfaces.c:73
+ * #9  0x0000555555bbc53a in qdev_device_add_from_qdict (opts=0x5555580d3220, from_json=false, errp=0x7fffffffd710) at ../system/qdev-monitor.c:712
+ * #10 0x0000555555bbc611 in qdev_device_add (opts=0x55555716d840, errp=0x5555570af7c0 <error_fatal>) at ../system/qdev-monitor.c:737
+ * #11 0x0000555555bc6d64 in device_init_func (opaque=0x0, opts=0x55555716d840, errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:1200
+ * #12 0x00005555560c439e in qemu_opts_foreach (list=0x555556f98e80 <qemu_device_opts>, func=0x555555bc6d35 <device_init_func>, opaque=0x0, errp=0x5555570af7c0 <error_fatal>)
+ *     at ../util/qemu-option.c:1135
+ * #13 0x0000555555bcac00 in qemu_create_cli_devices () at ../system/vl.c:2637
+ * #14 0x0000555555bcae46 in qmp_x_exit_preconfig (errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:2706
+ * #15 0x0000555555bcd92e in qemu_init (argc=30, argv=0x7fffffffdb18) at ../system/vl.c:3739
+ * #16 0x0000555555e8a1ef in main (argc=30, argv=0x7fffffffdb18) at ../system/main.c:47
+ *
+ * VirtIOBlock:
+ * -> BlockBackend *blk;
+ * -> VirtIOBlkConf conf;
+ *    -> BlockConf conf;
+ *       -> BlockBackend *blk;
+ *
+ * -device virtio-blk-pci,id=vblk01,num-queues=8,drive=drive01,iothread=iothread01 \
+ * -blockdev node-name=file01,driver=file,aio=threads,filename=test01.qcow2,cache.direct=on,cache.no-flush=off \
+ * -blockdev node-name=drive01,driver=qcow2,cache.direct=on,cache.no-flush=off,file=file01 \
+ *
+ *
+ * Managing the New Block Layer
+ * https://events.static.linuxfound.org/sites/events/files/slides/talk_11.pdf
+ */
+
 static void virtio_blk_ioeventfd_attach(VirtIOBlock *s);
 
 static void virtio_blk_init_request(VirtIOBlock *s, VirtQueue *vq,
diff --git a/hw/core/nmi.c b/hw/core/nmi.c
index a7bce8a04..306ebf601 100644
--- a/hw/core/nmi.c
+++ b/hw/core/nmi.c
@@ -42,6 +42,18 @@ static int do_nmi(Object *o, void *opaque)
         NMIClass *nc = NMI_GET_CLASS(n);
 
         ns->handled = true;
+        /*
+	 * 在以下设置nc->nmi_monitor_handler:
+	 *   - hw/hppa/machine.c|712| <<HP_B160L_machine_init_class_init>> nc->nmi_monitor_handler = hppa_nmi;
+	 *   - hw/hppa/machine.c|748| <<HP_C3700_machine_init_class_init>> nc->nmi_monitor_handler = hppa_nmi;
+	 *   - hw/i386/x86.c|387| <<x86_machine_class_init>> nc->nmi_monitor_handler = x86_nmi;
+	 *   - hw/intc/m68k_irqc.c|101| <<m68k_irqc_class_init>> nc->nmi_monitor_handler = m68k_nmi;
+	 *   - hw/m68k/q800-glue.c|241| <<glue_class_init>> nc->nmi_monitor_handler = glue_nmi;
+	 *   - hw/misc/macio/gpio.c|199| <<macio_gpio_class_init>> nc->nmi_monitor_handler = macio_gpio_nmi;
+	 *   - hw/ppc/pnv.c|2861| <<pnv_machine_class_init>> nc->nmi_monitor_handler = pnv_nmi;
+	 *   - hw/ppc/spapr.c|4723| <<spapr_machine_class_init>> nc->nmi_monitor_handler = spapr_nmi;
+	 *   - hw/s390x/s390-virtio-ccw.c|785| <<ccw_machine_class_init>> nc->nmi_monitor_handler = s390_nmi;
+	 */
         nc->nmi_monitor_handler(n, ns->cpu_index, &ns->err);
         if (ns->err) {
             return -1;
diff --git a/hw/pci/pcie.c b/hw/pci/pcie.c
index 4b2f0805c..5c691f0d4 100644
--- a/hw/pci/pcie.c
+++ b/hw/pci/pcie.c
@@ -182,6 +182,17 @@ static void pcie_cap_fill_slot_lnk(PCIDevice *dev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci-bridge/cxl_downstream.c|156| <<cxl_dsp_realize>> rc = pcie_cap_init(d, CXL_DOWNSTREAM_PORT_EXP_OFFSET, PCI_EXP_TYPE_DOWNSTREAM, p->port, errp);
+ *   - hw/pci-bridge/cxl_upstream.c|310| <<cxl_usp_realize>> rc = pcie_cap_init(d, CXL_UPSTREAM_PORT_PCIE_CAP_OFFSET, PCI_EXP_TYPE_UPSTREAM, p->port, errp);
+ *   - hw/pci-bridge/pcie_pci_bridge.c|50| <<pcie_pci_bridge_realize>> rc = pcie_cap_init(d, 0, PCI_EXP_TYPE_PCI_BRIDGE, 0, errp);
+ *   - hw/pci-bridge/pcie_root_port.c|92| <<rp_realize>> rc = pcie_cap_init(d, rpc->exp_offset, PCI_EXP_TYPE_ROOT_PORT, p->port, errp);
+ *   - hw/pci-bridge/xio3130_downstream.c|91| <<xio3130_downstream_realize>> rc = pcie_cap_init(d, XIO3130_EXP_OFFSET, PCI_EXP_TYPE_DOWNSTREAM, p->port, errp);
+ *   - hw/pci-bridge/xio3130_upstream.c|81| <<xio3130_upstream_realize>> rc = pcie_cap_init(d, XIO3130_EXP_OFFSET, PCI_EXP_TYPE_UPSTREAM, p->port, errp);
+ *   - hw/pci-host/designware.c|419| <<designware_pcie_root_realize>> pcie_cap_init(dev, 0x70, PCI_EXP_TYPE_ROOT_PORT, 0, &error_fatal);
+ *   -  hw/pci/pcie.c|265| <<pcie_endpoint_cap_common_init>> ret = pcie_cap_init(dev, offset, type, 0, &local_err);
+ */
 int pcie_cap_init(PCIDevice *dev, uint8_t offset,
                   uint8_t type, uint8_t port,
                   Error **errp)
diff --git a/hw/pci/pcie_aer.c b/hw/pci/pcie_aer.c
index 2c85a78fc..d8225274c 100644
--- a/hw/pci/pcie_aer.c
+++ b/hw/pci/pcie_aer.c
@@ -636,6 +636,13 @@ static bool pcie_aer_inject_uncor_error(PCIEAERInject *inj, bool is_fatal)
  * Figure 6-2: Flowchart Showing Sequence of Device Error Signaling and Logging
  *             Operations
  */
+/*
+ * called by:
+ *   - hw/mem/cxl_type3.c|1494| <<qmp_cxl_inject_uncorrectable_errors>> pcie_aer_inject_error(PCI_DEVICE(obj), &err);
+ *   - hw/mem/cxl_type3.c|1540| <<qmp_cxl_inject_correctable_error>> pcie_aer_inject_error(PCI_DEVICE(obj), &err);
+ *   - hw/pci/pci-hmp-cmds.c|226| <<hmp_pcie_aer_inject_error>> ret = pcie_aer_inject_error(dev, &aer_err);
+ *   - hw/pci/pcie_aer.c|712| <<pcie_aer_inject_error>> int ret = pcie_aer_inject_error(dev, &header_log_overflow);
+ */
 int pcie_aer_inject_error(PCIDevice *dev, const PCIEAERErr *err)
 {
     uint8_t *aer_cap = NULL;
diff --git a/hw/pci/pcie_port.c b/hw/pci/pcie_port.c
index 20ff2b39e..b343e2757 100644
--- a/hw/pci/pcie_port.c
+++ b/hw/pci/pcie_port.c
@@ -136,6 +136,13 @@ static void pcie_port_class_init(ObjectClass *oc, void *data)
     device_class_set_props(dc, pcie_port_props);
 }
 
+/*
+ * called by:
+ *   - hw/cxl/cxl-host.c|193| <<cxl_cfmws_find_device>> rp = pcie_find_port_by_pn(hb->bus, target);
+ *   - hw/cxl/cxl-host.c|229| <<cxl_cfmws_find_device>> d = pcie_find_port_by_pn(&PCI_BRIDGE(d)->sec_bus, target);
+ *   - hw/cxl/cxl-mailbox-utils.c|189| <<cmd_tunnel_management_cmd>> tunnel_target = pcie_find_port_by_pn(&PCI_BRIDGE(usp)->sec_bus, in->port_or_ld_id);
+ *   - hw/cxl/cxl-mailbox-utils.c|540| <<cmd_get_physical_port_state>> port_dev = pcie_find_port_by_pn(bus, in->ports[i]);
+ */
 PCIDevice *pcie_find_port_by_pn(PCIBus *bus, uint8_t pn)
 {
     int devfn;
diff --git a/hw/scsi/megasas.c b/hw/scsi/megasas.c
index 2d0c60717..ac2869125 100644
--- a/hw/scsi/megasas.c
+++ b/hw/scsi/megasas.c
@@ -37,6 +37,12 @@
 #include "migration/vmstate.h"
 #include "qom/object.h"
 
+/*
+ * 这个文档:
+ * A Practical Look at QEMU's Block Layer Primitives
+ * https://kashyapc.fedorapeople.org/virt/LinuxCon-NA-2016/A-Practical-Look-at-QEMU-Block-Layer-Primitives-LC-NA-2016.pdf
+ */
+
 #define MEGASAS_VERSION_GEN1 "1.70"
 #define MEGASAS_VERSION_GEN2 "1.80"
 #define MEGASAS_MAX_FRAMES 2048         /* Firmware limit at 65535 */
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 53eff5dd3..74e459688 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -17,6 +17,12 @@
 #include "sysemu/dma.h"
 #include "qemu/cutils.h"
 
+/*
+ * 这个文档:
+ * A Practical Look at QEMU's Block Layer Primitives
+ * https://kashyapc.fedorapeople.org/virt/LinuxCon-NA-2016/A-Practical-Look-at-QEMU-Block-Layer-Primitives-LC-NA-2016.pdf
+ */
+
 static char *scsibus_get_dev_path(DeviceState *dev);
 static char *scsibus_get_fw_dev_path(DeviceState *dev);
 static void scsi_req_dequeue(SCSIRequest *req);
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index 4d94b2b81..4d8833768 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -47,6 +47,12 @@
 #include <scsi/sg.h>
 #endif
 
+/*
+ * 这个文档:
+ * A Practical Look at QEMU's Block Layer Primitives
+ * https://kashyapc.fedorapeople.org/virt/LinuxCon-NA-2016/A-Practical-Look-at-QEMU-Block-Layer-Primitives-LC-NA-2016.pdf
+ */
+
 #define SCSI_WRITE_SAME_MAX         (512 * KiB)
 #define SCSI_DMA_BUF_SIZE           (128 * KiB)
 #define SCSI_MAX_INQUIRY_LEN        256
@@ -96,6 +102,16 @@ typedef struct SCSIDiskReq {
 #define SCSI_DISK_F_NO_REMOVABLE_DEVOPS   2
 
 struct SCSIDiskState {
+    /*
+     * 3228 static Property scsi_block_properties[] = {
+     * 3229     DEFINE_BLOCK_ERROR_PROPERTIES(SCSIDiskState, qdev.conf),
+     * 3230     DEFINE_PROP_DRIVE("drive", SCSIDiskState, qdev.conf.blk),
+     *
+     * struct SCSIDiskState:
+     * -> SCSIDevice qdev;
+     *    -> BlockConf conf;
+     *       -> BlockBackend *blk;
+     */
     SCSIDevice qdev;
     uint32_t features;
     bool media_changed;
@@ -3266,6 +3282,16 @@ static const TypeInfo scsi_cd_info = {
     .class_init    = scsi_cd_class_initfn,
 };
 
+/*
+ * 3228 static Property scsi_block_properties[] = {
+ * 3229     DEFINE_BLOCK_ERROR_PROPERTIES(SCSIDiskState, qdev.conf),
+ * 3230     DEFINE_PROP_DRIVE("drive", SCSIDiskState, qdev.conf.blk),
+ *
+ * struct SCSIDiskState:
+ * -> SCSIDevice qdev;
+ *    -> BlockConf conf;
+ *       -> BlockBackend *blk;
+ */
 #ifdef __linux__
 static Property scsi_block_properties[] = {
     DEFINE_BLOCK_ERROR_PROPERTIES(SCSIDiskState, qdev.conf),
diff --git a/hw/scsi/scsi-generic.c b/hw/scsi/scsi-generic.c
index ee945f87e..4fd08858a 100644
--- a/hw/scsi/scsi-generic.c
+++ b/hw/scsi/scsi-generic.c
@@ -33,6 +33,12 @@
 #define MAX_UINT ((unsigned int)-1)
 #endif
 
+/*
+ * 这个文档:
+ * A Practical Look at QEMU's Block Layer Primitives
+ * https://kashyapc.fedorapeople.org/virt/LinuxCon-NA-2016/A-Practical-Look-at-QEMU-Block-Layer-Primitives-LC-NA-2016.pdf
+ */
+
 typedef struct SCSIGenericReq {
     SCSIRequest req;
     uint8_t *buf;
diff --git a/hw/scsi/virtio-scsi.c b/hw/scsi/virtio-scsi.c
index 9f02ceea0..e4dbd4c72 100644
--- a/hw/scsi/virtio-scsi.c
+++ b/hw/scsi/virtio-scsi.c
@@ -31,6 +31,12 @@
 #include "hw/virtio/virtio-access.h"
 #include "trace.h"
 
+/*
+ * 这个文档:
+ * A Practical Look at QEMU's Block Layer Primitives
+ * https://kashyapc.fedorapeople.org/virt/LinuxCon-NA-2016/A-Practical-Look-at-QEMU-Block-Layer-Primitives-LC-NA-2016.pdf
+ */
+
 typedef struct VirtIOSCSIReq {
     /*
      * Note:
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 2407720c3..bfe3c088f 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -585,6 +585,16 @@ static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
             Error *err = NULL;
             int32_t fd;
 
+            /*
+	     * 注释
+	     * Two interrupt paths are configured per vector.  The first, is only used
+	     * for interrupts injected via QEMU.  This is typically the non-accel path,
+	     * but may also be used when we want QEMU to handle masking and pending
+	     * bits.  The KVM path bypasses QEMU and is therefore higher performance,
+	     * but requires masking at the device.  virq is used to track the MSI route
+	     * through KVM, thus kvm_interrupt is only available when virq is set to a
+	     * valid (>= 0) value.
+	     */
             if (vector->virq >= 0) {
                 fd = event_notifier_get_fd(&vector->kvm_interrupt);
             } else {
@@ -600,6 +610,9 @@ static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
         }
     }
 
+    /*
+     * 这里会改变memslots!!!
+     */
     /* Disable PBA emulation when nothing more is pending. */
     clear_bit(nr, vdev->msix->pending);
     if (find_first_bit(vdev->msix->pending,
diff --git a/include/hw/block/block.h b/include/hw/block/block.h
index de3946a5f..2a50a8c16 100644
--- a/include/hw/block/block.h
+++ b/include/hw/block/block.h
@@ -68,6 +68,38 @@ static inline unsigned int get_physical_block_exp(BlockConf *conf)
     DEFINE_PROP_ON_OFF_AUTO("account-failed", _state,                   \
                             _conf.account_failed, ON_OFF_AUTO_AUTO)
 
+/*
+ * QEMU-9.0的例子.
+ *
+ * (gdb) bt
+ * #0  blk_new (ctx=0x55555716e240, perm=0, shared_perm=15) at ../block/block-backend.c:357
+ * #1  0x000055555593f279 in set_drive_helper (obj=0x5555580dc630, v=
+ *     0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, iothread=false, errp=0x7fffffffd710) at ../hw/core/qdev-properties-system.c:146
+ * #2  0x000055555593f453 in set_drive (obj=0x5555580dc630, v=0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, errp=0x7fffffffd710)
+ *     at ../hw/core/qdev-properties-system.c:190
+ * #3  0x0000555555e8b43c in field_prop_set (obj=0x5555580dc630, v=0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, errp=0x7fffffffd710)
+ *     at ../hw/core/qdev-properties.c:88
+ * #4  0x0000555555e98e36 in object_property_set (obj=0x5555580dc630, name=0x5555580de030 "drive", v=0x5555580e0fc0, errp=0x7fffffffd710) at ../qom/object.c:1472
+ * #5  0x0000555555e9c464 in property_set_alias (obj=0x5555580d4260, v=0x5555580e0e00, name=0x5555580e0d90 "drive", opaque=0x5555580de010, errp=0x7fffffffd710) at ../qom/object.c:2799
+ * #6  0x0000555555e98e36 in object_property_set (obj=0x5555580d4260, name=0x5555580e0d90 "drive", v=0x5555580e0e00, errp=0x7fffffffd710) at ../qom/object.c:1472
+ * #7  0x0000555555e9cbc1 in object_set_properties_from_qdict (obj=0x5555580d4260, qdict=0x5555580dfc70, v=0x5555580e0e00, errp=0x7fffffffd710) at ../qom/object_interfaces.c:55
+ * #8  0x0000555555e9ccbc in object_set_properties_from_keyval (obj=0x5555580d4260, qdict=0x5555580dfc70, from_json=false, errp=0x7fffffffd710) at ../qom/object_interfaces.c:73
+ * #9  0x0000555555bbc53a in qdev_device_add_from_qdict (opts=0x5555580d3220, from_json=false, errp=0x7fffffffd710) at ../system/qdev-monitor.c:712
+ * #10 0x0000555555bbc611 in qdev_device_add (opts=0x55555716d840, errp=0x5555570af7c0 <error_fatal>) at ../system/qdev-monitor.c:737
+ * #11 0x0000555555bc6d64 in device_init_func (opaque=0x0, opts=0x55555716d840, errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:1200
+ * #12 0x00005555560c439e in qemu_opts_foreach (list=0x555556f98e80 <qemu_device_opts>, func=0x555555bc6d35 <device_init_func>, opaque=0x0, errp=0x5555570af7c0 <error_fatal>)
+ *     at ../util/qemu-option.c:1135
+ * #13 0x0000555555bcac00 in qemu_create_cli_devices () at ../system/vl.c:2637
+ * #14 0x0000555555bcae46 in qmp_x_exit_preconfig (errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:2706
+ * #15 0x0000555555bcd92e in qemu_init (argc=30, argv=0x7fffffffdb18) at ../system/vl.c:3739
+ * #16 0x0000555555e8a1ef in main (argc=30, argv=0x7fffffffdb18) at ../system/main.c:47
+ *
+ * VirtIOBlock:
+ * -> BlockBackend *blk;
+ * -> VirtIOBlkConf conf;
+ *    -> BlockConf conf;
+ *       -> BlockBackend *blk;
+ */
 #define DEFINE_BLOCK_PROPERTIES(_state, _conf)                          \
     DEFINE_PROP_DRIVE("drive", _state, _conf.blk),                      \
     DEFINE_BLOCK_PROPERTIES_BASE(_state, _conf)
diff --git a/include/hw/virtio/virtio.h b/include/hw/virtio/virtio.h
index 0fcbc5c0c..491cfeeb5 100644
--- a/include/hw/virtio/virtio.h
+++ b/include/hw/virtio/virtio.h
@@ -121,8 +121,41 @@ struct VirtIODevice
      * backend (e.g. vhost) and could potentially be a subset of the
      * total feature set offered by QEMU.
      */
+    /*
+     * 注释:
+     * These fields represent a set of VirtIO features at various
+     * levels of the stack. @host_features indicates the complete
+     * feature set the VirtIO device can offer to the driver.
+     * @guest_features indicates which features the VirtIO driver has
+     * selected by writing to the feature register. Finally
+     * @backend_features represents everything supported by the
+     * backend (e.g. vhost) and could potentially be a subset of the
+     * total feature set offered by QEMU.
+     */
     uint64_t host_features;
+    /*
+     * 注释:
+     * These fields represent a set of VirtIO features at various
+     * levels of the stack. @host_features indicates the complete
+     * feature set the VirtIO device can offer to the driver.
+     * @guest_features indicates which features the VirtIO driver has
+     * selected by writing to the feature register. Finally
+     * @backend_features represents everything supported by the
+     * backend (e.g. vhost) and could potentially be a subset of the
+     * total feature set offered by QEMU.
+     */
     uint64_t guest_features;
+    /*
+     * 注释:
+     * These fields represent a set of VirtIO features at various
+     * levels of the stack. @host_features indicates the complete
+     * feature set the VirtIO device can offer to the driver.
+     * @guest_features indicates which features the VirtIO driver has
+     * selected by writing to the feature register. Finally
+     * @backend_features represents everything supported by the
+     * backend (e.g. vhost) and could potentially be a subset of the
+     * total feature set offered by QEMU.
+     */
     uint64_t backend_features;
 
     size_t config_len;
diff --git a/include/sysemu/accel-ops.h b/include/sysemu/accel-ops.h
index a08867223..1ddde9436 100644
--- a/include/sysemu/accel-ops.h
+++ b/include/sysemu/accel-ops.h
@@ -41,8 +41,35 @@ struct AccelOpsClass {
     void (*kick_vcpu_thread)(CPUState *cpu);
     bool (*cpu_thread_is_idle)(CPUState *cpu);
 
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_reset:
+     *   - accel/hvf/hvf-accel-ops.c|581| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|106| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - system/cpus.c|178| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - system/cpus.c|179| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|90| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|93| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     void (*synchronize_post_reset)(CPUState *cpu);
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init:
+     *   - accel/hvf/hvf-accel-ops.c|582| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|107| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|185| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|186| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|91| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|94| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     void (*synchronize_post_init)(CPUState *cpu);
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state:
+     *   - accel/hvf/hvf-accel-ops.c|583| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|108| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - system/cpus.c|171| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|172| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     void (*synchronize_state)(CPUState *cpu);
     void (*synchronize_pre_loadvm)(CPUState *cpu);
     void (*synchronize_pre_resume)(bool step_pending);
diff --git a/qom/object.c b/qom/object.c
index 157a45c5f..41622d3d8 100644
--- a/qom/object.c
+++ b/qom/object.c
@@ -1704,6 +1704,32 @@ int object_property_get_enum(Object *obj, const char *name,
     return ret;
 }
 
+/*
+ * 旧的version的实现
+ *
+ * (gdb) bt
+ * #0  object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1646
+ * #1  0x0000555555d28d33 in object_apply_global_props (obj=0x555556a5f460, props=0x5555569b8f00, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:412
+ * #2  0x0000555555d20e5c in qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:790
+ * #3  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #4  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #5  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #7  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #9  0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #10 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #11 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #12 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #13 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #14 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.    c:157
+ * #15 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #16 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #17 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #18 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #19 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #20 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 bool object_property_parse(Object *obj, const char *name,
                            const char *string, Error **errp)
 {
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 85ef7452c..1fd6e2a06 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -46,6 +46,12 @@
 #include "disas/capstone.h"
 #include "cpu-internal.h"
 
+/*
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
+
 static void x86_cpu_realizefn(DeviceState *dev, Error **errp);
 
 /* Helpers for building CPUID[2] descriptors: */
@@ -912,6 +918,469 @@ void x86_cpu_vendor_words2str(char *dst, uint32_t vendor1,
 #define TCG_8000_0008_EBX  (CPUID_8000_0008_EBX_XSAVEERPTR | \
           CPUID_8000_0008_EBX_WBNOINVD | CPUID_8000_0008_EBX_KERNEL_FEATURES)
 
+/*
+ *
+ * KVM cpuid init/process.
+ *
+ * KVM在定义cpuid的时候分为下面核心的步骤.
+ *
+ * 1. KVM会通过KVM_GET_SUPPORTED_CPUID这个ioctl让QEMU知道那些cpuid的feature是支持的 (会有不支持的).
+ *
+ * 2. QEMU会把KVM_GET_SUPPORTED_CPUID的结果和"-cpu xxx,+feature0,-feature1,feature=on"的结果and一下.
+ *
+ * 3. 最终的结果会通过KVM_SET_CPUID2配置到KVM.
+ *
+ * ----------------------------------
+ *
+ * 在KVM side, 最初的时候, 通过vmx_set_cpu_caps()或者svm_set_cpu_caps()设置一些caps,
+ * 比方是否支持X86_FEATURE_SVM.
+ *
+ * 这样在__do_cpuid_func()中, 如果X86_FEATURE_SVM不被支持(没有nested),对应的KVM_GET_SUPPORTED_CPUID cpuid就返回0.
+ *
+ *  789 static inline int __do_cpuid_func(struct kvm_cpuid_array *array, u32 function)
+ *  790 {
+ * 1134         case 0x8000000A:
+ * 1135                 if (!kvm_cpu_cap_has(X86_FEATURE_SVM)) {
+ * 1136                         entry->eax = entry->ebx = entry->ecx = entry->edx = 0;
+ * 1137                         break;
+ * 1138                 }
+ * 1139                 entry->eax = 1; // SVM revision 1
+ * 1140                 entry->ebx = 8; // Lets support 8 ASIDs in case we add proper
+ * 1141                                    ASID emulation to nested SVM
+ * 1142                 entry->ecx = 0; // Reserved
+ * 1143                 cpuid_entry_override(entry, CPUID_8000_000A_EDX);
+ * 1144                 break;
+ *
+ *
+ * 这样为了返回KVM_GET_SUPPORTED_CPUID而调用__do_cpuid_func()的时候,KVM先调用host硬件的cpuid, 然后根据caps过滤.
+ *
+ * 814 static inline int __do_cpuid_func(struct kvm_cpuid_array *array, u32 function)
+ * 815 {
+ * 816         struct kvm_cpuid_entry2 *entry;
+ * 817         int r, i, max_idx;
+ * 818
+ * 819         // all calls to cpuid_count() should be made on the same cpu
+ * 820         get_cpu();
+ * 821
+ * 822         r = -E2BIG;
+ * 823
+ * 824         entry = do_host_cpuid(array, function, 0);
+ * 825         if (!entry)
+ * 826                 goto out;
+ * 827
+ * 828         switch (function) {
+ * 829         case 0:
+ * 830                 // Limited to the highest leaf implemented in KVM.
+ * 831                 entry->eax = min(entry->eax, 0x1fU);
+ * 832                 break;
+ * 833         case 1:
+ * 834                 cpuid_entry_override(entry, CPUID_1_EDX);
+ * 835                 cpuid_entry_override(entry, CPUID_1_ECX);
+ * 836                 break;
+ * 837         case 2:
+ *
+ * ----------------------------------
+ *
+ * cap配置好了, KVM_GET_SUPPORTED_CPUID就能返回KVM支持哪些cpuid的feature了.
+ *
+ * 通过get_supported_cpuid()-->try_get_cpuid()-->KVM_GET_SUPPORTED_CPUID来获取KVM支持的feature/cpuid.
+ *
+ * 为了减少和KVM的沟通, 结果可以缓存在cpuid_cache.
+ *
+ * 321 static struct kvm_cpuid2 *get_supported_cpuid(KVMState *s)
+ * 322 {
+ * 323     struct kvm_cpuid2 *cpuid;
+ * 324     int max = 1;
+ * 325
+ * 326     if (cpuid_cache != NULL) {
+ * 327         return cpuid_cache;
+ * 328     }
+ * 329     while ((cpuid = try_get_cpuid(s, max)) == NULL) {
+ * 330         max *= 2;
+ * 331     }
+ * 332     cpuid_cache = cpuid;
+ * 333     return cpuid;
+ * 334 }
+ *
+ * (gdb) bt
+ * #0  try_get_cpuid (s=0x55555680c600, max=64) at ../target/i386/kvm/kvm.c:257
+ * #1  0x0000555555b144dc in get_supported_cpuid (s=0x55555680c600) at ../target/i386/kvm/kvm.c:288
+ * #2  0x0000555555b146d2 in kvm_arch_get_supported_cpuid (s=0x55555680c600, function=0, index=0, reg=0) at ../target/i386/kvm/kvm.c:356
+ * #3  0x0000555555b219d1 in kvm_cpu_max_instance_init (cpu=0x555556a5f390) at ../target/i386/kvm/kvm-cpu.c:77
+ * #4  0x0000555555b21cb6 in kvm_cpu_instance_init (cs=0x555556a5f390) at ../target/i386/kvm/kvm-cpu.c:183
+ * #5  0x0000555555ce9da1 in accel_cpu_instance_init (cpu=0x555556a5f390) at ../accel/accel-common.c:110
+ * #6  0x0000555555b6dd3b in x86_cpu_post_initfn (obj=0x555556a5f390) at ../target/i386/cpu.c:6686
+ * #7  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567e1470) at ../qom/object.c:384
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567f4600) at ../qom/object.c:388
+ * #9  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567f4960) at ../qom/object.c:388
+ * #10 0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f390, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #11 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #12 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #13 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #14 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #15 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #16 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #17 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #18 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #19 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #20 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #21 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * ----------------------------------
+ * 
+ * QEMU初始化的时候, x86_cpu_common_class_init()-->x86_cpu_register_feature_bit_props()会为每一个cpu的feature (e.g., -x2apic,+x2apic,x2apic=on)注册.
+ *
+ * 7018 static void x86_cpu_common_class_init(ObjectClass *oc, void *data)
+ * 7019 {
+ * ... ...
+ * 7092     for (w = 0; w < FEATURE_WORDS; w++) {
+ * 7093         int bitnr;
+ * 7094         for (bitnr = 0; bitnr < 64; bitnr++) {
+ * 7095             x86_cpu_register_feature_bit_props(xcc, w, bitnr);
+ * 7096         }
+ * 7097     }
+ * 7098 }
+ *
+ * FEATURE_WORDS包括比如FEAT_1_ECX.
+ *
+ * 676 FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
+ * 677     [FEAT_1_EDX] = {
+ * 678         .type = CPUID_FEATURE_WORD,
+ * 679         .feat_names = {
+ * 680             "fpu", "vme", "de", "pse",
+ * 681             "tsc", "msr", "pae", "mce",
+ * 682             "cx8", "apic", NULL, "sep",
+ * 683             "mtrr", "pge", "mca", "cmov",
+ * 684             "pat", "pse36", "pn" / Intel psn /, "clflush" / Intel clfsh /,
+ * 685             NULL, "ds" / Intel dts /, "acpi", "mmx",
+ * 686             "fxsr", "sse", "sse2", "ss",
+ * 687             "ht" / Intel htt /, "tm", "ia64", "pbe",
+ * 688         },
+ * 689         .cpuid = {.eax = 1, .reg = R_EDX, },
+ * 690         .tcg_features = TCG_FEATURES,
+ * 691     },
+ * 692     [FEAT_1_ECX] = {
+ * 693         .type = CPUID_FEATURE_WORD,
+ * 694         .feat_names = {
+ * 695             "pni" / Intel,AMD sse3 /, "pclmulqdq", "dtes64", "monitor",
+ * 696             "ds-cpl", "vmx", "smx", "est",
+ * 697             "tm2", "ssse3", "cid", NULL,
+ * 698             "fma", "cx16", "xtpr", "pdcm",
+ * 699             NULL, "pcid", "dca", "sse4.1",
+ * 700             "sse4.2", "x2apic", "movbe", "popcnt",
+ * 701             "tsc-deadline", "aes", "xsave", NULL / osxsave /,
+ * 702             "avx", "f16c", "rdrand", "hypervisor",
+ * 703         },
+ * 704         .cpuid = { .eax = 1, .reg = R_ECX, },
+ * 705         .tcg_features = TCG_EXT_FEATURES,
+ * 706     },
+ *
+ * 最终这些property(e.g., x2apic, vmx)的setter是x86_cpu_set_bit_prop(),
+ * 就是修改cpu->env.features[fp->w].
+ *
+ * 6605 static void x86_cpu_set_bit_prop(Object *obj, Visitor *v, const char *name,
+ * 6606                                  void *opaque, Error **errp)
+ * 6607 {
+ * 6608     DeviceState *dev = DEVICE(obj);
+ * 6609     X86CPU *cpu = X86_CPU(obj);
+ * 6610     BitProperty *fp = opaque;
+ * 6611     bool value;
+ * 6612
+ * 6613     if (dev->realized) {
+ * 6614         qdev_prop_set_after_realize(dev, name, errp);
+ * 6615         return;
+ * 6616     }
+ * 6617
+ * 6618     if (!visit_type_bool(v, name, &value, errp)) {
+ * 6619         return;
+ * 6620     }
+ * 6621
+ * 6622     if (value) {
+ * 6623         cpu->env.features[fp->w] |= fp->mask;
+ * 6624     } else {
+ * 6625         cpu->env.features[fp->w] &= ~fp->mask;
+ * 6626     }
+ * 6627     cpu->env.user_features[fp->w] |= fp->mask;
+ * 6628 }
+ *
+ * (gdb) bt
+ * #0  x86_cpu_register_bit_prop (xcc=0x555556812140, prop_name=0x55555607a689 "x2apic", w=FEAT_1_ECX, bitnr=21) at ../target/i386/cpu.c:6641
+ * #1  0x0000555555b6dd1e in x86_cpu_register_feature_bit_props (xcc=0x555556812140, w=FEAT_1_ECX, bitnr=21) at ../target/i386/cpu.c:6681
+ * #2  0x0000555555b6e9ec in x86_cpu_common_class_init (oc=0x555556812140, data=0x0) at ../target/i386/cpu.c:7095
+ * #3  0x0000555555d28b97 in type_initialize (ti=0x5555567e1470) at ../qom/object.c:366
+ * #4  0x0000555555d28902 in type_initialize (ti=0x5555567ea7e0) at ../qom/object.c:314
+ * #5  0x0000555555d2a0fa in object_class_foreach_tramp (key=0x5555567ea960, value=0x5555567ea7e0, opaque=0x7fffffffdb90) at ../qom/object.c:1071
+ * #6  0x00007ffff6e46710 in g_hash_table_foreach () at /lib64/libglib-2.0.so.0
+ * #7  0x0000555555d2a1d9 in object_class_foreach (fn=0x555555d2a336 <object_class_get_list_tramp>, implements_type=0x555555faee84 "machine", include_abstract=false, opaque=0x7fffffffdbe0) at ../qom/object.c:1093
+ * #8  0x0000555555d2a3b1 in object_class_get_list (implements_type=0x555555faee84 "machine", include_abstract=false) at ../qom/object.c:1150
+ * #9  0x0000555555894512 in select_machine (qdict=0x55555680c600, errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:1661
+ * #10 0x00005555558956a4 in qemu_create_machine (qdict=0x55555680c600) at ../softmmu/vl.c:2146
+ * #11 0x00005555558991e5 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3708
+ * #12 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * 下面是其中一个property的例子.
+ *
+ * (gdb) p *prop
+ * $8 = {name = 0x555556817690 "x2apic", type = 0x5555568176b0 "bool", description = 0x0, get = 0x555555b6d930 <x86_cpu_get_bit_prop>, set = 0x555555b6d9de <x86_cpu_set_bit_prop>, resolve = 0x0, release = 0x0,
+ *   init = 0x0, opaque = 0x555556817610, defval = 0x0}
+ *
+ * ----------------------------------
+ *
+ * 启动以后, QEMU有两处初始化property的地方, 一个是"+x2apic,-x2apic", 一个是"x2apic=on".
+ *
+ * 对于"+"或者"-", 用x86_cpu_parse_featurestr()添加到plus_features或者minus_features, 比如line 4694和line 4698.
+ *
+ * (gdb) bt
+ * #0  x86_cpu_parse_featurestr (typename=0x5555567f4ae0 "host-x86_64-cpu", features=0x55555680e620 "-x2apic", errp=0x55555679a800 <error_fatal>) at ../target/i386/cpu.c:4669
+ * #1  0x0000555555bf2f64 in parse_cpu_option (cpu_option=0x7fffffffe290 "host,-x2apic") at ../cpu.c:265
+ * #2  0x0000555555899305 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3761
+ * #3  0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * 4667 static void x86_cpu_parse_featurestr(const char *typename, char *features,
+ * 4668                                      Error **errp)
+ * 4669 {
+ * 4670     char *featurestr; // Single 'key=value" string being parsed
+ * 4671     static bool cpu_globals_initialized;
+ * 4672     bool ambiguous = false;
+ * 4673
+ * 4674     if (cpu_globals_initialized) {
+ * 4675         return;
+ * 4676     }
+ * 4677     cpu_globals_initialized = true;
+ * 4678
+ * 4679     if (!features) {
+ * 4680         return;
+ * 4681     }
+ * 4682
+ * 4683     for (featurestr = strtok(features, ",");
+ * 4684          featurestr;
+ * 4685          featurestr = strtok(NULL, ",")) {
+ * 4686         const char *name;
+ * 4687         const char *val = NULL;
+ * 4688         char *eq = NULL;
+ * 4689         char num[32];
+ * 4690         GlobalProperty *prop;
+ * 4691
+ * 4692         // Compatibility syntax:
+ * 4693         if (featurestr[0] == '+') {
+ * 4694             plus_features = g_list_append(plus_features,
+ * 4695                                           g_strdup(featurestr + 1));
+ * 4696             continue;
+ * 4697         } else if (featurestr[0] == '-') {
+ * 4698             minus_features = g_list_append(minus_features,
+ * 4699                                            g_strdup(featurestr + 1));
+ * 4700             continue;
+ * 4701         }
+ *
+ * 稍后在x86_cpu_expand_features()设置true或者false.
+ *
+ * 6145 void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
+ * 6146 {
+ * 6147     CPUX86State *env = &cpu->env;
+ * 6148     FeatureWord w;
+ * 6149     int i;
+ * 6150     GList *l;
+ * 6151
+ * 6152     for (l = plus_features; l; l = l->next) {
+ * 6153         const char *prop = l->data;
+ * 6154         if (!object_property_set_bool(OBJECT(cpu), prop, true, errp)) {
+ * 6155             return;
+ * 6156         }
+ * 6157     }
+ * 6158
+ * 6159     for (l = minus_features; l; l = l->next) {
+ * 6160         const char *prop = l->data;
+ * 6161         if (!object_property_set_bool(OBJECT(cpu), prop, false, errp)) {
+ * 6162             return;
+ * 6163         }
+ * 6164     }
+ *
+ * (gdb) bt
+ * #0  x86_cpu_expand_features (cpu=0x555556a5f460, errp=0x7fffffffd790) at ../target/i386/cpu.c:6147
+ * #1  0x0000555555b6d14e in x86_cpu_realizefn (dev=0x555556a5f460, errp=0x7fffffffd810) at ../target/i386/cpu.c:6381
+ * #2  0x0000555555d2325a in device_set_realized (obj=0x555556a5f460, value=true, errp=0x7fffffffd920) at ../hw/core/qdev.c:531
+ * #3  0x0000555555d2cd6c in property_set_bool (obj=0x555556a5f460, v=0x555556a6e980, name=0x5555560c1221 "realized", opaque=0x555556812500, errp=0x7fffffffd920) at ../qom/object.c:2273
+ * #4  0x0000555555d2adb3 in object_property_set (obj=0x555556a5f460, name=0x5555560c1221 "realized", v=0x555556a6e980, errp=0x7fffffffd920) at ../qom/object.c:1408
+ * #5  0x0000555555d2f15e in object_property_set_qobject (obj=0x555556a5f460, name=0x5555560c1221 "realized", value=0x555556a6be10, errp=0x55555679a800 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #6  0x0000555555d2b118 in object_property_set_bool (obj=0x555556a5f460, name=0x5555560c1221 "realized", value=true, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:1477
+ * #7  0x0000555555d22b22 in qdev_realize (dev=0x555556a5f460, bus=0x0, errp=0x55555679a800 <error_fatal>) at ../hw/core/qdev.c:333
+ * #8  0x0000555555b2e017 in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:101
+ * #9  0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #10 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #11 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #12 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #13 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #14 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #15 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #16 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ *
+ * 对于第二种情况"x2apic=on"或"x2apic=off", 在x86_cpu_parse_featurestr()的最后一种情况处理, line 4742.
+ *
+ * 4667 static void x86_cpu_parse_featurestr(const char *typename, char *features,
+ * 4668                                      Error **errp)
+ * 4669 {
+ * ... ...
+ * 4742         prop = g_new0(typeof(*prop), 1);
+ * 4743         prop->driver = typename;
+ * 4744         prop->property = g_strdup(name);
+ * 4745         prop->value = g_strdup(val);
+ * 4746         qdev_prop_register_global(prop);
+ * 4747     }
+ *
+ * ... 然后稍后在x86_cpu_new()-->qdev_prop_set_globals()设置true or false.
+ *
+ * (gdb) bt
+ * #0  object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1646
+ * #1  0x0000555555d28d33 in object_apply_global_props (obj=0x555556a5f460, props=0x5555569b8f00, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:412
+ * #2  0x0000555555d20e5c in qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:790
+ * #3  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #4  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #5  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #7  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #9  0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #10 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #11 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #12 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #13 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #14 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #15 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #16 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #17 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #18 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #19 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #20 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ *
+ * Again, 最终这些property(e.g., x2apic, vmx)的setter是x86_cpu_set_bit_prop(), 就是修改cpu->env.features[fp->w].
+ *
+ * ----------------------------------
+ *
+ * 这里是关于在QEMU的cpuid features的计算.
+ *
+ * x86_cpu_realizefn()
+ * -> x86_cpu_expand_features()
+ * -> x86_cpu_filter_features()
+ *
+ * x86_cpu_filter_features()会通过从KVM_GET_SUPPORTED_CPUID和已经有的env->features[w]比较, 然后and过滤掉不支持的.
+ * 比如line 6295-6300.
+ *
+ * 6283 static void x86_cpu_filter_features(X86CPU *cpu, bool verbose)
+ * 6284 {
+ * 6285     CPUX86State *env = &cpu->env;
+ * 6286     FeatureWord w;
+ * 6287     const char *prefix = NULL;
+ * 6288
+ * 6289     if (verbose) {
+ * 6290         prefix = accel_uses_host_cpuid()
+ * 6291                  ? "host doesn't support requested feature"
+ * 6292                  : "TCG doesn't support requested feature";
+ * 6293     }
+ * 6294
+ * 6295     for (w = 0; w < FEATURE_WORDS; w++) {
+ * 6296         uint64_t host_feat =
+ * 6297             x86_cpu_get_supported_feature_word(w, false);
+ * 6298         uint64_t requested_features = env->features[w];
+ * 6299         uint64_t unavailable_features = requested_features & ~host_feat;
+ * 6300         mark_unavailable_features(cpu, w, unavailable_features, prefix);
+ * 6301     }
+ *
+ *
+ * 最终会通过KVM_SET_CPUID2更新到KVM. 首先在kvm_arch_init_vcpu()把env->features[w]转换成以下的结构.
+ * 然后通过KVM_SET_CPUID2更新到KVM.
+ *
+ * struct {
+ *     struct kvm_cpuid2 cpuid;
+ *     struct kvm_cpuid_entry2 entries[KVM_MAX_CPUID_ENTRIES];
+ * }
+ *
+ * (gdb) bt
+ * #0  kvm_arch_init_vcpu (cs=0x555556a5f460) at ../target/i386/kvm/kvm.c:1621
+ * #1  0x0000555555d0c631 in kvm_init_vcpu (cpu=0x555556a5f460, errp=0x55555679a800 <error_fatal>) at ../accel/kvm/kvm-all.c:516
+ * #2  0x0000555555d13504 in kvm_vcpu_thread_fn (arg=0x555556a5f460) at ../accel/kvm/kvm-accel-ops.c:40
+ * #3  0x0000555555efbfb0 in qemu_thread_start (args=0x555556a6f3a0) at ../util/qemu-thread-posix.c:556
+ * #4  0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #5  0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ *
+ * ----------------------------------
+ *
+ * KVM side处理KVM_SET_CPUID2, 把cpuid的结构更新到下面.
+ *
+ * struct kvm_vcpu_arch {
+ * ... ...
+ *     int cpuid_nent;
+ *     struct kvm_cpuid_entry2 *cpuid_entries;
+ *
+ * 这样在kvm_cpuid()的时候就可以用kvm_find_cpuid_entry()获得了.
+ *
+ *
+ * ======================================
+ *
+ * 下面是QEMU comment中的流程.
+ *
+ *  ***** Steps involved on loading and filtering CPUID data
+ *  *
+ *  * When initializing and realizing a CPU object, the steps
+ *  * involved in setting up CPUID data are:
+ *  *
+ *  * 1) Loading CPU model definition (X86CPUDefinition). This is
+ *  *    implemented by x86_cpu_load_model() and should be completely
+ *  *    transparent, as it is done automatically by instance_init.
+ *  *    No code should need to look at X86CPUDefinition structs
+ *  *    outside instance_init.
+ *  *
+ *  * 2) CPU expansion. This is done by realize before CPUID
+ *  *    filtering, and will make sure host/accelerator data is
+ *  *    loaded for CPU models that depend on host capabilities
+ *  *    (e.g. "host"). Done by x86_cpu_expand_features().
+ *  *
+ *  * 3) CPUID filtering. This initializes extra data related to
+ *  *    CPUID, and checks if the host supports all capabilities
+ *  *    required by the CPU. Runnability of a CPU model is
+ *  *    determined at this step. Done by x86_cpu_filter_features().
+ *  *
+ *  * Some operations don't require all steps to be performed.
+ *  * More precisely:
+ *  *
+ *  * - CPU instance creation (instance_init) will run only CPU
+ *  *   model loading. CPU expansion can't run at instance_init-time
+ *  *   because host/accelerator data may be not available yet.
+ *  * - CPU realization will perform both CPU model expansion and CPUID
+ *  *   filtering, and return an error in case one of them fails.
+ *  * - query-cpu-definitions needs to run all 3 steps. It needs
+ *  *   to run CPUID filtering, as the 'unavailable-features'
+ *  *   field is set based on the filtering results.
+ *  * - The query-cpu-model-expansion QMP command only needs to run
+ *  *   CPU model loading and CPU expansion. It should not filter
+ *  *   any CPUID data based on host capabilities.
+ *  *
+ *
+ * ==============================================
+ *
+ * 几种VM不支持x2apic的原因.
+ *
+ * 1. "-cpu"中有-x2apic
+ *
+ * 2. 没有kvm_irqchip_in_kernel().
+ *
+ *  389 uint32_t kvm_arch_get_supported_cpuid(KVMState *s, uint32_t function,
+ *  390                                       uint32_t index, int reg)
+ * ... ...
+ *  423         // x2apic is reported by GET_SUPPORTED_CPUID, but it can't be enabled
+ *  424          * without the in-kernel irqchip
+ *  425          //
+ *  426         if (!kvm_irqchip_in_kernel()) {
+ *  427             ret &= ~CPUID_EXT_X2APIC;
+ *  428         }
+ *
+ *
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
 FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
     [FEAT_1_EDX] = {
         .type = CPUID_FEATURE_WORD,
@@ -1884,6 +2353,32 @@ static uint64_t x86_cpu_get_migratable_flags(FeatureWord w)
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/i386/sgx.c|96| <<sgx_calc_host_epc_sections>> host_cpuid(0x12, i + 2, &eax, &ebx, &ecx, &edx);
+ *   - hw/i386/sgx.c|170| <<qmp_query_sgx_capabilities>> host_cpuid(0x7, 0, &eax, &ebx, &ecx, &edx);
+ *   - hw/i386/sgx.c|175| <<qmp_query_sgx_capabilities>> host_cpuid(0x12, 0, &eax, &ebx, &ecx, &edx);
+ *   - target/i386/cpu.c|6289| <<x86_cpu_get_cache_cpuid>> host_cpuid(0, 0, &level, &unused, &unused, &unused);
+ *   - target/i386/cpu.c|6294| <<x86_cpu_get_cache_cpuid>> host_cpuid(0x80000000, 0, &level, &unused, &unused, &unused);
+ *   - target/i386/cpu.c|6306| <<x86_cpu_get_cache_cpuid>> host_cpuid(func, index, eax, ebx, ecx, edx);
+  9 target/i386/cpu.c|6916| <<cpu_x86_cpuid>> host_cpuid(index, 2, eax, ebx, ecx, edx);
+ 10 target/i386/host-cpu.c|23| <<host_cpu_phys_bits>> host_cpuid(0x80000000, 0, &eax, NULL, NULL, NULL);
+ 11 target/i386/host-cpu.c|25| <<host_cpu_phys_bits>> host_cpuid(0x80000008, 0, &eax, NULL, NULL, NULL);
+ 12 target/i386/host-cpu.c|109| <<host_cpu_fill_model_id>> host_cpuid(0x80000002 + i, 0, &eax, &ebx, &ecx, &edx);
+ 13 target/i386/host-cpu.c|122| <<host_cpu_vendor_fms>> host_cpuid(0x0, 0, &eax, &ebx, &ecx, &edx);
+ *   - target/i386/host-cpu.c|125| <<host_cpu_vendor_fms>> host_cpuid(0x1, 0, &eax, &ebx, &ecx, &edx);
+ 15 target/i386/host-cpu.c|145| <<host_cpu_instance_init>> host_cpuid(0, 0, NULL, &ebx, &ecx, &edx);
+ 16 target/i386/hvf/x86_cpuid.c|54| <<hvf_get_supported_cpuid>> host_cpuid(func, idx, &eax, &ebx, &ecx, &edx);
+ 17 target/i386/kvm/kvm-cpu.c|96| <<kvm_cpu_realizefn>> host_cpuid(5, 0, &cpu->mwait.eax, &cpu->mwait.ebx,
+ 18 target/i386/kvm/kvm-cpu.c|173| <<kvm_cpu_xsave_init>> host_cpuid(0xd, i, &eax, &ebx, &ecx, &edx);
+ 19 target/i386/kvm/kvm.c|653| <<kvm_arch_get_supported_cpuid>> host_cpuid(7, 0, &unused, &ebx, &unused, &unused);
+ 20 target/i386/kvm/kvm.c|662| <<kvm_arch_get_supported_cpuid>> host_cpuid(7, 0, &unused, &unused, &unused, &edx);
+ 21 target/i386/kvm/kvm.c|676| <<kvm_arch_get_supported_cpuid>> host_cpuid(7, 1, &eax, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|680| <<kvm_arch_get_supported_cpuid>> host_cpuid(7, 2, &unused, &unused, &unused, &edx);
+ 23 target/i386/kvm/kvm.c|6711| <<host_supports_vmx>> host_cpuid(1, 0, &unused, &unused, &ecx, &unused);
+ 24 target/i386/sev.c|620| <<sev_get_capabilities>> host_cpuid(0x8000001F, 0, NULL, &ebx, NULL, NULL);
+ 25 target/i386/sev.c|1449| <<sev_common_kvm_init>> host_cpuid(0x8000001F, 0, NULL, &ebx, NULL, NULL);
+ */
 void host_cpuid(uint32_t function, uint32_t count,
                 uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx)
 {
@@ -5352,6 +5847,9 @@ static void max_x86_cpu_initfn(Object *obj)
      * these defaults are used for TCG and all other accelerators
      * besides KVM and HVF, which overwrite these values
      */
+    /*
+     * TCG默认是AuthenticAMD
+     */
     object_property_set_str(OBJECT(cpu), "vendor", CPUID_VENDOR_AMD,
                             &error_abort);
     object_property_set_str(OBJECT(cpu), "model-id",
@@ -5552,6 +6050,105 @@ static char *x86_cpuid_get_vendor(Object *obj, Error **errp)
     return value;
 }
 
+/*
+ * 初始化默认是AMD
+ *
+ * (gdb) bt
+ * #0  x86_cpuid_set_vendor (obj=0x5555574631f0, value=0x55555746c020 "AuthenticAMD", errp=0x5555570af7b8 <error_abort>)
+ *            at ../target/i386/cpu.c:5190
+ * #1  0x0000555555e9b051 in property_set_str (obj=0x5555574631f0, v=0x55555746bf20, name=0x5555562f38b7 "vendor",
+ *            opaque=0x555557184d80, errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:2281
+ * #2  0x0000555555e98e36 in object_property_set (obj=0x5555574631f0, name=0x5555562f38b7 "vendor", v=0x55555746bf20,
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1472
+ * #3  0x0000555555e9dba3 in object_property_set_qobject (obj=0x5555574631f0, name=0x5555562f38b7 "vendor",
+ *            value=0x555557463080, errp=0x5555570af7b8 <error_abort>) at ../qom/qom-qobject.c:28
+ * #4  0x0000555555e98eda in object_property_set_str (obj=0x5555574631f0, name=0x5555562f38b7 "vendor", value=0x5555562f38aa "AuthenticAMD",
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1480
+ * #5  0x0000555555ce8d85 in max_x86_cpu_initfn (obj=0x5555574631f0) at ../target/i386/cpu.c:4987
+ * #6  0x0000555555e9650e in object_init_with_type (obj=0x5555574631f0, ti=0x555557154310) at ../qom/object.c:429
+ * #7  0x0000555555e964f0 in object_init_with_type (obj=0x5555574631f0, ti=0x555557154670) at ../qom/object.c:425
+ * #8  0x0000555555e96b05 in object_initialize_with_type (obj=0x5555574631f0, size=25888, type=0x555557154670) at ../qom/object.c:571
+ * #9  0x0000555555e97385 in object_new_with_type (type=0x555557154670) at ../qom/object.c:791
+ * #10 0x0000555555e973e9 in object_new (typename=0x5555571547f0 "host-x86_64-cpu") at ../qom/object.c:806
+ * #11 0x0000555555c9413a in x86_cpu_new (x86ms=0x5555573e9000, apic_id=0, errp=0x5555570af7c0 <error_fatal>) at ../hw/i386/x86.c:100
+ * #12 0x0000555555c942f7 in x86_cpus_init (x86ms=0x5555573e9000, default_cpu_version=1) at ../hw/i386/x86.c:156
+ * #13 0x0000555555ca1242 in pc_init1 (machine=0x5555573e9000, pci_type=0x5555562e5df3 "i440FX") at ../hw/i386/pc_piix.c:185
+ * #14 0x0000555555ca20fa in pc_init_v9_0 (machine=0x5555573e9000) at ../hw/i386/pc_piix.c:523
+ * #15 0x000055555593b0b8 in machine_run_board_init (machine=0x5555573e9000, mem_path=0x0, errp=0x7fffffffd970)
+ *            at ../hw/core/machine.c:1547
+ * #16 0x0000555555bcab2e in qemu_init_board () at ../system/vl.c:2613
+ * #17 0x0000555555bcae41 in qmp_x_exit_preconfig (errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:2705
+ * #18 0x0000555555bcd92e in qemu_init (argc=24, argv=0x7fffffffdc68) at ../system/vl.c:3739
+ * #19 0x0000555555e8a1ef in main (argc=24, argv=0x7fffffffdc68) at ../system/main.c:47
+ *
+ * 有"-cpu host"
+ *
+ * (gdb) bt
+ * #0  x86_cpuid_set_vendor (obj=0x5555574631f0, value=0x55555746c020 "GenuineIntel", errp=0x5555570af7b8 <error_abort>)
+ *            at ../target/i386/cpu.c:5190
+ * #1  0x0000555555e9b051 in property_set_str (obj=0x5555574631f0, v=0x55555746bf20, name=0x5555562f5a45 "vendor",
+ *            opaque=0x555557184d80, errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:2281
+ * #2  0x0000555555e98e36 in object_property_set (obj=0x5555574631f0, name=0x5555562f5a45 "vendor", v=0x55555746bf20,
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1472
+ * #3  0x0000555555e9dba3 in object_property_set_qobject (obj=0x5555574631f0, name=0x5555562f5a45 "vendor", value=0x555557463080,
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/qom-qobject.c:28
+ * #4  0x0000555555e98eda in object_property_set_str (obj=0x5555574631f0, name=0x5555562f5a45 "vendor", value=0x7fffffffd583 "GenuineIntel",
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1480
+ * #5  0x0000555555cf7dc0 in host_cpu_max_instance_init (cpu=0x5555574631f0) at ../target/i386/host-cpu.c:178
+ * #6  0x0000555555c81a89 in kvm_cpu_max_instance_init (cpu=0x5555574631f0) at ../target/i386/kvm/kvm-cpu.c:71
+ * #7  0x0000555555c81e1f in kvm_cpu_instance_init (cs=0x5555574631f0) at ../target/i386/kvm/kvm-cpu.c:184
+ * #8  0x0000555555e46ba0 in accel_cpu_instance_init (cpu=0x5555574631f0) at ../accel/accel-target.c:118
+ * #9  0x0000555555cf01d8 in x86_cpu_post_initfn (obj=0x5555574631f0) at ../target/i386/cpu.c:7596
+ * #10 0x0000555555e96547 in object_post_init_with_type (obj=0x5555574631f0, ti=0x555557140640) at ../qom/object.c:436
+ * #11 0x0000555555e96575 in object_post_init_with_type (obj=0x5555574631f0, ti=0x555557154310) at ../qom/object.c:440
+ * #12 0x0000555555e96575 in object_post_init_with_type (obj=0x5555574631f0, ti=0x555557154670) at ../qom/object.c:440
+ * #13 0x0000555555e96b18 in object_initialize_with_type (obj=0x5555574631f0, size=25888, type=0x555557154670) at ../qom/object.c:572
+ * #14 0x0000555555e97385 in object_new_with_type (type=0x555557154670) at ../qom/object.c:791
+ * #15 0x0000555555e973e9 in object_new (typename=0x5555571547f0 "host-x86_64-cpu") at ../qom/object.c:806
+ * #16 0x0000555555c9413a in x86_cpu_new (x86ms=0x5555573e9000, apic_id=0, errp=0x5555570af7c0 <error_fatal>) at ../hw/i386/x86.c:100
+ * #17 0x0000555555c942f7 in x86_cpus_init (x86ms=0x5555573e9000, default_cpu_version=1) at ../hw/i386/x86.c:156
+ * #18 0x0000555555ca1242 in pc_init1 (machine=0x5555573e9000, pci_type=0x5555562e5df3 "i440FX") at ../hw/i386/pc_piix.c:185
+ * #19 0x0000555555ca20fa in pc_init_v9_0 (machine=0x5555573e9000) at ../hw/i386/pc_piix.c:523
+ * #20 0x000055555593b0b8 in machine_run_board_init (machine=0x5555573e9000, mem_path=0x0, errp=0x7fffffffd970)
+ *            at ../hw/core/machine.c:1547
+ * #21 0x0000555555bcab2e in qemu_init_board () at ../system/vl.c:2613
+ * #22 0x0000555555bcae41 in qmp_x_exit_preconfig (errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:2705
+ * #23 0x0000555555bcd92e in qemu_init (argc=24, argv=0x7fffffffdc68) at ../system/vl.c:3739
+ * #24 0x0000555555e8a1ef in main (argc=24, argv=0x7fffffffdc68) at ../system/main.c:47
+ *
+ * 没有"-cpu host"
+ *
+ * (gdb) bt
+ * #0  x86_cpuid_set_vendor (obj=0x5555574631f0, value=0x55555746c020 "GenuineIntel", errp=0x5555570af7b8 <error_abort>)
+ *            at ../target/i386/cpu.c:5190
+ * #1  0x0000555555e9b051 in property_set_str (obj=0x5555574631f0, v=0x55555746bf20, name=0x5555562f5a45 "vendor",
+ *            opaque=0x555557184d80, errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:2281
+ * #2  0x0000555555e98e36 in object_property_set (obj=0x5555574631f0, name=0x5555562f5a45 "vendor", v=0x55555746bf20,
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1472
+ * #3  0x0000555555e9dba3 in object_property_set_qobject (obj=0x5555574631f0, name=0x5555562f5a45 "vendor",
+ *            value=0x555557463080, errp=0x5555570af7b8 <error_abort>) at ../qom/qom-qobject.c:28
+ * #4  0x0000555555e98eda in object_property_set_str (obj=0x5555574631f0, name=0x5555562f5a45 "vendor", value=0x7fffffffd62b "GenuineIntel",
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1480
+ * #5  0x0000555555cf7cbb in host_cpu_instance_init (cpu=0x5555574631f0) at ../target/i386/host-cpu.c:162
+ * #6  0x0000555555c81d91 in kvm_cpu_instance_init (cs=0x5555574631f0) at ../target/i386/kvm/kvm-cpu.c:169
+ * #7  0x0000555555e46ba0 in accel_cpu_instance_init (cpu=0x5555574631f0) at ../accel/accel-target.c:118
+ * #8  0x0000555555cf01d8 in x86_cpu_post_initfn (obj=0x5555574631f0) at ../target/i386/cpu.c:7596
+ * #9  0x0000555555e96547 in object_post_init_with_type (obj=0x5555574631f0, ti=0x555557140640) at ../qom/object.c:436
+ * #10 0x0000555555e96575 in object_post_init_with_type (obj=0x5555574631f0, ti=0x5555571241b0) at ../qom/object.c:440
+ * #11 0x0000555555e96b18 in object_initialize_with_type (obj=0x5555574631f0, size=25888, type=0x5555571241b0) at ../qom/object.c:572
+ * #12 0x0000555555e97385 in object_new_with_type (type=0x5555571241b0) at ../qom/object.c:791
+ * #13 0x0000555555e973e9 in object_new (typename=0x5555562ec770 "qemu64-x86_64-cpu") at ../qom/object.c:806
+ * #14 0x0000555555c9413a in x86_cpu_new (x86ms=0x5555573e9000, apic_id=0, errp=0x5555570af7c0 <error_fatal>) at ../hw/i386/x86.c:100
+ * #15 0x0000555555c942f7 in x86_cpus_init (x86ms=0x5555573e9000, default_cpu_version=1) at ../hw/i386/x86.c:156
+ * #16 0x0000555555ca1242 in pc_init1 (machine=0x5555573e9000, pci_type=0x5555562e5df3 "i440FX") at ../hw/i386/pc_piix.c:185
+ * #17 0x0000555555ca20fa in pc_init_v9_0 (machine=0x5555573e9000) at ../hw/i386/pc_piix.c:523
+ * #18 0x000055555593b0b8 in machine_run_board_init (machine=0x5555573e9000, mem_path=0x0, errp=0x7fffffffd990)
+ *            at ../hw/core/machine.c:1547
+ * #19 0x0000555555bcab2e in qemu_init_board () at ../system/vl.c:2613
+ * #20 0x0000555555bcae41 in qmp_x_exit_preconfig (errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:2705
+ * #21 0x0000555555bcd92e in qemu_init (argc=22, argv=0x7fffffffdc88) at ../system/vl.c:3739
+ * #22 0x0000555555e8a1ef in main (argc=22, argv=0x7fffffffdc88) at ../system/main.c:47
+ */
 static void x86_cpuid_set_vendor(Object *obj, const char *value,
                                  Error **errp)
 {
@@ -5565,6 +6162,18 @@ static void x86_cpuid_set_vendor(Object *obj, const char *value,
         return;
     }
 
+    /*
+     * 在以下使用CPUArchState->cpuid_vendor1:
+     *   - target/i386/cpu.c|5550| <<x86_cpuid_get_vendor>> x86_cpu_vendor_words2str(value, env->cpuid_vendor1, env->cpuid_vendor2,
+     *   - target/i386/cpu.c|5568| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 = 0;
+     *   - target/i386/cpu.c|5572| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 |= ((uint8_t)value[i ]) << (8 * i);
+     *   - target/i386/cpu.c|6451| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+     *   - target/i386/cpu.c|6862| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+     *   - target/i386/cpu.c|6877| <<cpu_x86_cpuid>> if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||
+     *   - target/i386/cpu.c|6883| <<cpu_x86_cpuid>> if (tcg_enabled() && env->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 &&
+     *   - target/i386/cpu.h|1051| <<IS_INTEL_CPU>> #define IS_INTEL_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 && \
+     *   - target/i386/cpu.h|1054| <<IS_AMD_CPU>> #define IS_AMD_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_AMD_1 && \
+     */
     env->cpuid_vendor1 = 0;
     env->cpuid_vendor2 = 0;
     env->cpuid_vendor3 = 0;
@@ -6185,6 +6794,11 @@ static void x86_cpu_get_cache_cpuid(uint32_t func, uint32_t index,
 /*
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm-cpu.c|247| <<kvm_cpu_instance_init>> x86_cpu_apply_props(cpu, kvm_default_props);
+ *   - target/i386/tcg/tcg-cpu.c|176| <<x86_tcg_cpu_instance_init>> x86_cpu_apply_props(cpu, x86_tcg_default_props);
+ */
 void x86_cpu_apply_props(X86CPU *cpu, PropValue *props)
 {
     PropValue *pv;
@@ -6202,6 +6816,32 @@ void x86_cpu_apply_props(X86CPU *cpu, PropValue *props)
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_set_bit_prop (obj=0x555557557f10, v=0x555557560a60, name=0x55555622de8d "ibpb", opaque=0x5555572829e0, errp=0x5555571efef8 <error_abort>) at ../target/i386/cpu.c:7933
+ * #1  0x0000555555e42517 in object_property_set (obj=0x555557557f10, name=0x55555622de8d "ibpb", v=0x555557560a60, errp=0x5555571efef8 <error_abort>) at ../qom/object.c:1463
+ * #2  0x0000555555e43083 in object_property_parse (obj=0x555557557f10, name=0x55555622de8d "ibpb", string=0x55555622e985 "on", errp=0x5555571efef8 <error_abort>) at ../qom/object.c:1711
+ * #3  0x0000555555cbd2f3 in x86_cpu_apply_version_props (cpu=0x555557557f10, model=0x555557259890) at ../target/i386/cpu.c:6234
+ * #4  0x0000555555cbd5b8 in x86_cpu_load_model (cpu=0x555557557f10, model=0x555557259890) at ../target/i386/cpu.c:6324
+ * #5  0x0000555555cc2218 in x86_cpu_initfn (obj=0x555557557f10) at ../target/i386/cpu.c:8084
+ * #6  0x0000555555e4010d in object_init_with_type (obj=0x555557557f10, ti=0x55555722adb0) at ../qom/object.c:420
+ * #7  0x0000555555e400ef in object_init_with_type (obj=0x555557557f10, ti=0x5555572598c0) at ../qom/object.c:416
+ * #8  0x0000555555e4063f in object_initialize_with_type (obj=0x555557557f10, size=26048, type=0x5555572598c0) at ../qom/object.c:562
+ * #9  0x0000555555e40d49 in object_new_with_type (type=0x5555572598c0) at ../qom/object.c:782
+ * #10 0x0000555555e40da0 in object_new (typename=0x555557259a40 "EPYC-v2-x86_64-cpu") at ../qom/object.c:797
+ * #11 0x0000555555c79aa9 in x86_cpu_new (x86ms=0x5555574e0270, apic_id=0, errp=0x5555571eff00 <error_fatal>) at ../hw/i386/x86-common.c:58
+ * #12 0x0000555555c79c50 in x86_cpus_init (x86ms=0x5555574e0270, default_cpu_version=1) at ../hw/i386/x86-common.c:114
+ * #13 0x0000555555c80dbc in pc_q35_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:190
+ * #14 0x0000555555c816b5 in pc_q35_machine_9_1_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:365
+ * #15 0x000055555592bb08 in machine_run_board_init (machine=0x5555574e0270, mem_path=0x0, errp=0x7fffffffd850) at ../hw/core/machine.c:1593
+ * #16 0x0000555555b851c9 in qemu_init_board () at ../system/vl.c:2628
+ * #17 0x0000555555b85489 in qmp_x_exit_preconfig (errp=0x5555571eff00 <error_fatal>) at ../system/vl.c:2720
+ * #18 0x0000555555b87ccf in qemu_init (argc=22, argv=0x7fffffffdb48) at ../system/vl.c:3766
+ * #19 0x0000555555fb2744 in main (argc=22, argv=0x7fffffffdb48) at ../system/main.c:47
+ *
+ * called by:
+ *   - target/i386/cpu.c|6921| <<x86_cpu_load_model>> x86_cpu_apply_version_props(cpu, model);
+ */
 static void x86_cpu_apply_version_props(X86CPU *cpu, X86CPUModel *model)
 {
     const X86CPUVersionDefinition *vdef;
@@ -6259,6 +6899,32 @@ static const CPUCaches *x86_cpu_get_versioned_cache_info(X86CPU *cpu,
  * Load data from X86CPUDefinition into a X86CPU object.
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
+/*
+ * (gdb) bt
+ * #0  x86_cpu_set_bit_prop (obj=0x555557557f10, v=0x555557560a60, name=0x55555622de8d "ibpb", opaque=0x5555572829e0, errp=0x5555571efef8 <error_abort>) at ../target/i386/cpu.c:7933
+ * #1  0x0000555555e42517 in object_property_set (obj=0x555557557f10, name=0x55555622de8d "ibpb", v=0x555557560a60, errp=0x5555571efef8 <error_abort>) at ../qom/object.c:1463
+ * #2  0x0000555555e43083 in object_property_parse (obj=0x555557557f10, name=0x55555622de8d "ibpb", string=0x55555622e985 "on", errp=0x5555571efef8 <error_abort>) at ../qom/object.c:1711
+ * #3  0x0000555555cbd2f3 in x86_cpu_apply_version_props (cpu=0x555557557f10, model=0x555557259890) at ../target/i386/cpu.c:6234
+ * #4  0x0000555555cbd5b8 in x86_cpu_load_model (cpu=0x555557557f10, model=0x555557259890) at ../target/i386/cpu.c:6324
+ * #5  0x0000555555cc2218 in x86_cpu_initfn (obj=0x555557557f10) at ../target/i386/cpu.c:8084
+ * #6  0x0000555555e4010d in object_init_with_type (obj=0x555557557f10, ti=0x55555722adb0) at ../qom/object.c:420
+ * #7  0x0000555555e400ef in object_init_with_type (obj=0x555557557f10, ti=0x5555572598c0) at ../qom/object.c:416
+ * #8  0x0000555555e4063f in object_initialize_with_type (obj=0x555557557f10, size=26048, type=0x5555572598c0) at ../qom/object.c:562
+ * #9  0x0000555555e40d49 in object_new_with_type (type=0x5555572598c0) at ../qom/object.c:782
+ * #10 0x0000555555e40da0 in object_new (typename=0x555557259a40 "EPYC-v2-x86_64-cpu") at ../qom/object.c:797
+ * #11 0x0000555555c79aa9 in x86_cpu_new (x86ms=0x5555574e0270, apic_id=0, errp=0x5555571eff00 <error_fatal>) at ../hw/i386/x86-common.c:58
+ * #12 0x0000555555c79c50 in x86_cpus_init (x86ms=0x5555574e0270, default_cpu_version=1) at ../hw/i386/x86-common.c:114
+ * #13 0x0000555555c80dbc in pc_q35_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:190
+ * #14 0x0000555555c816b5 in pc_q35_machine_9_1_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:365
+ * #15 0x000055555592bb08 in machine_run_board_init (machine=0x5555574e0270, mem_path=0x0, errp=0x7fffffffd850) at ../hw/core/machine.c:1593
+ * #16 0x0000555555b851c9 in qemu_init_board () at ../system/vl.c:2628
+ * #17 0x0000555555b85489 in qmp_x_exit_preconfig (errp=0x5555571eff00 <error_fatal>) at ../system/vl.c:2720
+ * #18 0x0000555555b87ccf in qemu_init (argc=22, argv=0x7fffffffdb48) at ../system/vl.c:3766
+ * #19 0x0000555555fb2744 in main (argc=22, argv=0x7fffffffdb48) at ../system/main.c:47
+ *
+ * called by:
+ *   - target/i386/cpu.c|8839| <<x86_cpu_initfn>> x86_cpu_load_model(cpu, xcc->model);
+ */
 static void x86_cpu_load_model(X86CPU *cpu, X86CPUModel *model)
 {
     const X86CPUDefinition *def = model->cpudef;
@@ -6405,6 +7071,33 @@ uint32_t cpu_x86_virtual_addr_width(CPUX86State *env)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/fw_cfg.c|183| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 1, 0, &unused, &unused, &ecx, &edx);
+ *   - hw/i386/fw_cfg.c|195| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 0x7, 0, &unused, &ebx, &ecx, &unused);
+ *   - target/i386/hvf/hvf.c|404| <<hvf_cpu_x86_cpuid>> cpu_x86_cpuid(env, index, count, eax, ebx, ecx, edx);
+ *   - target/i386/kvm/kvm.c|2061| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|2077| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2087| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2108| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2133| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2154| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2165| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2172| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2187| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0x0a, 0, &eax, &unused, &unused, &edx);
+ *   - target/i386/kvm/kvm.c|2211| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0x80000000, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|2227| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2241| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2255| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0xC0000000, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|2266| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/tcg/fpu_helper.c|3151| <<helper_xsetbv>> cpu_x86_cpuid(env, 0x0d, 0, &ena_lo, &dummy, &dummy, &ena_hi);
+ *   - target/i386/tcg/misc_helper.c|56| <<helper_cpuid>> cpu_x86_cpuid(env, (uint32_t)env->regs[R_EAX], (uint32_t)env->regs[R_ECX],
+ *   - target/i386/whpx/whpx-all.c|1946| <<whpx_vcpu_run>> cpu_x86_cpuid(env, cpuid_fn, 0, (UINT32 *)&rax, (UINT32 *)&rbx,
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
 void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,
                    uint32_t *eax, uint32_t *ebx,
                    uint32_t *ecx, uint32_t *edx)
@@ -6447,6 +7140,30 @@ void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,
 
     switch(index) {
     case 0:
+        /*
+	 * 查看:
+	 *
+	 * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+	 *
+	 * 在以下使用CPUArchState->cpuid_vendor1:
+	 *   - target/i386/cpu.c|5550| <<x86_cpuid_get_vendor>> x86_cpu_vendor_words2str(value, env->cpuid_vendor1, env->cpuid_vendor2,
+	 *   - target/i386/cpu.c|5568| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 = 0;
+	 *   - target/i386/cpu.c|5572| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 |= ((uint8_t)value[i ]) << (8 * i);
+	 *   - target/i386/cpu.c|6451| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+	 *   - target/i386/cpu.c|6862| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+	 *   - target/i386/cpu.c|6877| <<cpu_x86_cpuid>> if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||
+	 *   - target/i386/cpu.c|6883| <<cpu_x86_cpuid>> if (tcg_enabled() && env->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 &&
+	 *   - target/i386/cpu.h|1051| <<IS_INTEL_CPU>> #define IS_INTEL_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 && \
+	 *   - target/i386/cpu.h|1054| <<IS_AMD_CPU>> #define IS_AMD_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_AMD_1 && \
+	 *
+	 * # cpuid -1 -l 0x0
+         * CPU:
+         *    vendor_id = "GenuineIntel"
+         *
+	 * # cpuid -1 -l 0x0 -r
+         * CPU:
+         *    0x00000000 0x00: eax=0x00000014 ebx=0x756e6547 ecx=0x6c65746e edx=0x49656e69
+	 */
         *eax = env->cpuid_level;
         *ebx = env->cpuid_vendor1;
         *edx = env->cpuid_vendor2;
@@ -6460,6 +7177,11 @@ void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,
         if ((*ecx & CPUID_EXT_XSAVE) && (env->cr[4] & CR4_OSXSAVE_MASK)) {
             *ecx |= CPUID_EXT_OSXSAVE;
         }
+        /*
+	 * 查看:
+	 *
+	 * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+	 */
         *edx = env->features[FEAT_1_EDX];
         if (threads_per_pkg > 1) {
             *ebx |= threads_per_pkg << 16;
@@ -7065,6 +7787,32 @@ static void x86_cpu_set_sgxlepubkeyhash(CPUX86State *env)
 #endif
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_reset_hold (obj=0x5555577182a0, type=RESET_TYPE_COLD) at ../target/i386/cpu.c:7070
+ * #1  0x0000555555eefb43 in resettable_phase_hold (obj=0x5555577182a0, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:180
+ * #2  0x0000555555eef69f in resettable_assert_reset (obj=0x5555577182a0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #3  0x0000555555eef5f7 in resettable_reset (obj=0x5555577182a0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #4  0x0000555555eec4c4 in device_cold_reset (dev=0x5555577182a0) at ../hw/core/qdev.c:254
+ * #5  0x000055555587d07f in cpu_reset (cpu=0x5555577182a0) at ../hw/core/cpu-common.c:113
+ * #6  0x0000555555cbd795 in x86_cpu_machine_reset_cb (opaque=0x5555577182a0) at ../target/i386/cpu-sysemu.c:266
+ * #7  0x0000555555951bdb in legacy_reset_hold (obj=0x55555771eeb0, type=RESET_TYPE_COLD) at ../hw/core/reset.c:76
+ * #8  0x0000555555eefb43 in resettable_phase_hold (obj=0x55555771eeb0, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:180
+ * #9  0x0000555555eedf2f in resettable_container_child_foreach (obj=0x55555768e600, cb=0x555555eef9e7 <resettable_phase_hold>, opaque=0x0,
+ *     type=RESET_TYPE_COLD) at ../hw/core/resetcontainer.c:54
+ * #10 0x0000555555eef7ea in resettable_child_foreach (rc=0x555557641ce0, obj=0x55555768e600, cb=0x555555eef9e7 <resettable_phase_hold>, opaque=0x0,
+ *     type=RESET_TYPE_COLD) at ../hw/core/resettable.c:92
+ * #11 0x0000555555eefaa4 in resettable_phase_hold (obj=0x55555768e600, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:169
+ * #12 0x0000555555eef69f in resettable_assert_reset (obj=0x55555768e600, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #13 0x0000555555eef5f7 in resettable_reset (obj=0x55555768e600, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #14 0x0000555555951f35 in qemu_devices_reset (reason=SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET) at ../hw/core/reset.c:179
+ * #15 0x0000555555d1dd96 in pc_machine_reset (machine=0x55555766ac00, reason=SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET) at ../hw/i386/pc.c:1714
+ * #16 0x0000555555be061c in qemu_system_reset (reason=SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET) at ../system/runstate.c:516
+ * #17 0x0000555555be0e22 in main_loop_should_exit (status=0x7fffffffdb14) at ../system/runstate.c:792
+ * #18 0x0000555555be0f23 in qemu_main_loop () at ../system/runstate.c:825
+ * #19 0x0000555556093994 in qemu_default_main () at ../system/main.c:37
+ * #20 0x00005555560939d1 in main (argc=24, argv=0x7fffffffdc38) at ../system/main.c:48
+ */
 static void x86_cpu_reset_hold(Object *obj, ResetType type)
 {
     CPUState *cs = CPU(obj);
@@ -7512,6 +8260,53 @@ void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
  *
  * Returns: 0 if all flags are supported by the host, non-zero otherwise.
  */
+/*
+ * 这里是关于在QEMU的cpuid features的计算.
+ *
+ * x86_cpu_realizefn()
+ * -> x86_cpu_expand_features()
+ * -> x86_cpu_filter_features()
+ *
+ * x86_cpu_filter_features()会通过从KVM_GET_SUPPORTED_CPUID和已经有的env->features[w]比较, 然后and过滤掉不支持的.
+ * 比如line 6295-6300.
+ *
+ * 6283 static void x86_cpu_filter_features(X86CPU *cpu, bool verbose)
+ * 6284 {
+ * 6285     CPUX86State *env = &cpu->env;
+ * 6286     FeatureWord w;
+ * 6287     const char *prefix = NULL;
+ * 6288
+ * 6289     if (verbose) {
+ * 6290         prefix = accel_uses_host_cpuid()
+ * 6291                  ? "host doesn't support requested feature"
+ * 6292                  : "TCG doesn't support requested feature";
+ * 6293     }
+ * 6294
+ * 6295     for (w = 0; w < FEATURE_WORDS; w++) {
+ * 6296         uint64_t host_feat =
+ * 6297             x86_cpu_get_supported_feature_word(w, false);
+ * 6298         uint64_t requested_features = env->features[w];
+ * 6299         uint64_t unavailable_features = requested_features & ~host_feat;
+ * 6300         mark_unavailable_features(cpu, w, unavailable_features, prefix);
+ * 6301     }
+ *
+ *
+ * 最终会通过KVM_SET_CPUID2更新到KVM. 首先在kvm_arch_init_vcpu()把env->features[w]转换成以下的结构.
+ * 然后通过KVM_SET_CPUID2更新到KVM.
+ *
+ * struct {
+ *     struct kvm_cpuid2 cpuid;
+ *     struct kvm_cpuid_entry2 entries[KVM_MAX_CPUID_ENTRIES];
+ * }
+ *
+ * (gdb) bt
+ * #0  kvm_arch_init_vcpu (cs=0x555556a5f460) at ../target/i386/kvm/kvm.c:1621
+ * #1  0x0000555555d0c631 in kvm_init_vcpu (cpu=0x555556a5f460, errp=0x55555679a800 <error_fatal>) at ../accel/kvm/kvm-all.c:516
+ * #2  0x0000555555d13504 in kvm_vcpu_thread_fn (arg=0x555556a5f460) at ../accel/kvm/kvm-accel-ops.c:40
+ * #3  0x0000555555efbfb0 in qemu_thread_start (args=0x555556a6f3a0) at ../util/qemu-thread-posix.c:556
+ * #4  0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #5  0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ */
 static void x86_cpu_filter_features(X86CPU *cpu, bool verbose)
 {
     CPUX86State *env = &cpu->env;
@@ -7595,6 +8390,26 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
     cpu->hyperv_limits[2] = 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_realizefn (dev=0x555557557f50, errp=0x7fffffffd460) at ../target/i386/cpu.c:7626
+ * #1  0x0000555555cbae19 in max_x86_cpu_realize (dev=0x555557557f50, errp=0x7fffffffd460) at ../target/i386/cpu.c:5340
+ * #2  0x0000555555e3a9ec in device_set_realized (obj=0x555557557f50, value=true, errp=0x7fffffffd570) at ../hw/core/qdev.c:510
+ * #3  0x0000555555e445a6 in property_set_bool (obj=0x555557557f50, v=0x555557562140, name=0x5555562709a9 "realized", opaque=0x555557278a70, errp=0x7fffffffd570) at ../qom/object.c:2354
+ * #4  0x0000555555e42517 in object_property_set (obj=0x555557557f50, name=0x5555562709a9 "realized", v=0x555557562140, errp=0x7fffffffd570) at ../qom/object.c:1463
+ * #5  0x0000555555e46998 in object_property_set_qobject (obj=0x555557557f50, name=0x5555562709a9 "realized", value=0x555557557f30, errp=0x5555571eff00 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #6  0x0000555555e4286c in object_property_set_bool (obj=0x555557557f50, name=0x5555562709a9 "realized", value=true, errp=0x5555571eff00 <error_fatal>) at ../qom/object.c:1533
+ * #7  0x0000555555e3a1ec in qdev_realize (dev=0x555557557f50, bus=0x0, errp=0x5555571eff00 <error_fatal>) at ../hw/core/qdev.c:291
+ * #8  0x0000555555c79af2 in x86_cpu_new (x86ms=0x5555574e0270, apic_id=0, errp=0x5555571eff00 <error_fatal>) at ../hw/i386/x86-common.c:63
+ * #9  0x0000555555c79c50 in x86_cpus_init (x86ms=0x5555574e0270, default_cpu_version=1) at ../hw/i386/x86-common.c:114
+ * #10 0x0000555555c80dbc in pc_q35_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:190
+ * #11 0x0000555555c816b5 in pc_q35_machine_9_1_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:365
+ * #12 0x000055555592bb08 in machine_run_board_init (machine=0x5555574e0270, mem_path=0x0, errp=0x7fffffffd840) at ../hw/core/machine.c:1593
+ * #13 0x0000555555b851c9 in qemu_init_board () at ../system/vl.c:2628
+ * #14 0x0000555555b85489 in qmp_x_exit_preconfig (errp=0x5555571eff00 <error_fatal>) at ../system/vl.c:2720
+ * #15 0x0000555555b87ccf in qemu_init (argc=22, argv=0x7fffffffdb38) at ../system/vl.c:3766
+ * #16 0x0000555555fb2744 in main (argc=22, argv=0x7fffffffdb38) at ../system/main.c:47
+ */
 static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
@@ -7958,11 +8773,65 @@ static void x86_cpu_register_bit_prop(X86CPUClass *xcc,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_register_bit_prop (xcc=0x555557277d00, prop_name=0x55555622d9c6 "fpu", w=FEAT_1_EDX, bitnr=0) at ../target/i386/cpu.c:7968
+ * #1  0x0000555555cc1d75 in x86_cpu_register_feature_bit_props (xcc=0x555557277d00, w=FEAT_1_EDX, bitnr=0) at ../target/i386/cpu.c:8010
+ * #2  0x0000555555cc2c51 in x86_cpu_common_class_init (oc=0x555557277d00, data=0x0) at ../target/i386/cpu.c:8496
+ * #3  0x0000555555e40164 in type_initialize (ti=0x55555722adb0) at ../qom/object.c:409
+ * #4  0x0000555555e3fecf in type_initialize (ti=0x55555725a460) at ../qom/object.c:357
+ * #5  0x0000555555e418dd in object_class_foreach_tramp (key=0x55555725a5e0, value=0x55555725a460, opaque=0x7fffffffd7a0) at ../qom/object.c:1124
+ * #6  0x00007ffff7eaf3c0 in g_hash_table_foreach (hash_table=0x5555571f2a40, func=0x555555e418ad <object_class_foreach_tramp>, user_data=0x7fffffffd7a0) at ../glib/ghash.c:2067
+ * #7  0x0000555555e419bc in object_class_foreach (fn=0x555555e41b19 <object_class_get_list_tramp>, implements_type=0x5555561e9522 "machine", include_abstract=false, 
+ *     opaque=0x7fffffffd7f0) at ../qom/object.c:1146
+ * #8  0x0000555555e41b94 in object_class_get_list (implements_type=0x5555561e9522 "machine", include_abstract=false) at ../qom/object.c:1203
+ * #9  0x0000555555b82d98 in select_machine (qdict=0x555557272190, errp=0x7fffffffd840) at ../system/vl.c:1677
+ * #10 0x0000555555b83d92 in qemu_create_machine (qdict=0x555557272190) at ../system/vl.c:2116
+ * #11 0x0000555555b87b42 in qemu_init (argc=22, argv=0x7fffffffdb38) at ../system/vl.c:3691
+ * #12 0x0000555555fb2800 in main (argc=22, argv=0x7fffffffdb38) at ../system/main.c:47
+ *
+ * called by:
+ *   - target/i386/cpu.c|9165| <<x86_cpu_common_class_init>> x86_cpu_register_feature_bit_props(xcc, w, bitnr);
+ */
 static void x86_cpu_register_feature_bit_props(X86CPUClass *xcc,
                                                FeatureWord w,
                                                int bitnr)
 {
     FeatureWordInfo *fi = &feature_word_info[w];
+    /*
+     * 915 FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
+     * 916     [FEAT_1_EDX] = {
+     * 917         .type = CPUID_FEATURE_WORD,
+     * 918         .feat_names = {
+     * 919             "fpu", "vme", "de", "pse",
+     * 920             "tsc", "msr", "pae", "mce",
+     * 921             "cx8", "apic", NULL, "sep",
+     * 922             "mtrr", "pge", "mca", "cmov",
+     * 923             "pat", "pse36", "pn", "clflush",
+     * 924             NULL, "ds", "acpi", "mmx",
+     * 925             "fxsr", "sse", "sse2", "ss",
+     * 926             "ht", "tm", "ia64", "pbe",
+     * 927         },
+     * 928         .cpuid = {.eax = 1, .reg = R_EDX, },
+     * 929         .tcg_features = TCG_FEATURES,
+     * 930         .no_autoenable_flags = CPUID_HT,
+     * 931     },
+     * 932     [FEAT_1_ECX] = {
+     * 933         .type = CPUID_FEATURE_WORD,
+     * 934         .feat_names = {
+     * 935             "pni", "pclmulqdq", "dtes64", "monitor",
+     * 936             "ds-cpl", "vmx", "smx", "est",
+     * 937             "tm2", "ssse3", "cid", NULL,
+     * 938             "fma", "cx16", "xtpr", "pdcm",
+     * 939             NULL, "pcid", "dca", "sse4.1",
+     * 940             "sse4.2", "x2apic", "movbe", "popcnt",
+     * 941             "tsc-deadline", "aes", "xsave", NULL,
+     * 942             "avx", "f16c", "rdrand", "hypervisor",
+     * 943         },
+     * 944         .cpuid = { .eax = 1, .reg = R_ECX, },
+     * 945         .tcg_features = TCG_EXT_FEATURES,
+     * 946     },
+     */
     const char *name = fi->feat_names[bitnr];
 
     if (!name) {
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index 14edd57a3..a6cc159f4 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -488,7 +488,35 @@ typedef enum X86Seg {
 #define MSR_CORE_PERF_FIXED_CTR0        0x309
 #define MSR_CORE_PERF_FIXED_CTR1        0x30a
 #define MSR_CORE_PERF_FIXED_CTR2        0x30b
+/*
+ * 在以下使用MSR_CORE_PERF_FIXED_CTR_CTRL:
+ *   - target/i386/cpu.h|491| <<global>> #define MSR_CORE_PERF_FIXED_CTR_CTRL 0x38d
+ *   - target/i386/kvm/kvm.c|4552| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);
+ *   - target/i386/kvm/kvm.c|4632| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, env->msr_fixed_ctr_ctrl);
+ *   - target/i386/kvm/kvm.c|5153| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);
+ *   - target/i386/kvm/kvm.c|5473| <<kvm_get_msrs>> case MSR_CORE_PERF_FIXED_CTR_CTRL:
+ */
 #define MSR_CORE_PERF_FIXED_CTR_CTRL    0x38d
+/*
+ * 在以下使用MSR_CORE_PERF_GLOBAL_STATUS:
+ *   - target/i386/cpu.h|492| <<global>> #define MSR_CORE_PERF_GLOBAL_STATUS 0x38e                                                                               
+ *   - target/i386/kvm/kvm.c|4612| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, env->msr_global_status);
+ *   - target/i386/kvm/kvm.c|5155| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);
+ *   - target/i386/kvm/kvm.c|5493| <<kvm_get_msrs>> case MSR_CORE_PERF_GLOBAL_STATUS:
+ *
+ * 在以下使用MSR_CORE_PERF_GLOBAL_CTRL:
+ *   - target/i386/cpu.h|493| <<global>> #define MSR_CORE_PERF_GLOBAL_CTRL 0x38f
+ *   - target/i386/kvm/kvm.c|4553| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);
+ *   - target/i386/kvm/kvm.c|4641| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, env->msr_global_ctrl);
+ *   - target/i386/kvm/kvm.c|5154| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);
+ *   - target/i386/kvm/kvm.c|5483| <<kvm_get_msrs>> case MSR_CORE_PERF_GLOBAL_CTRL:
+ *
+ * 在以下使用MSR_CORE_PERF_GLOBAL_OVF_CTRL:
+ *   - target/i386/cpu.h|494| <<global>> #define MSR_CORE_PERF_GLOBAL_OVF_CTRL 0x390
+ *   - target/i386/kvm/kvm.c|4621| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, env->msr_global_ovf_ctrl);
+ *   - target/i386/kvm/kvm.c|5156| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);
+ *   - target/i386/kvm/kvm.c|5503| <<kvm_get_msrs>> case MSR_CORE_PERF_GLOBAL_OVF_CTRL:
+ */
 #define MSR_CORE_PERF_GLOBAL_STATUS     0x38e
 #define MSR_CORE_PERF_GLOBAL_CTRL       0x38f
 #define MSR_CORE_PERF_GLOBAL_OVF_CTRL   0x390
@@ -1787,12 +1815,61 @@ typedef struct CPUArchState {
     uint64_t msr_ia32_feature_control;
     uint64_t msr_ia32_sgxlepubkeyhash[4];
 
+    /*
+     * 在以下使用CPUX86State->msr_fixed_ctr_ctrl:
+     *   - target/i386/machine.c|674| <<global>> VMSTATE_UINT64(env.msr_fixed_ctr_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4430| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, env->msr_fixed_ctr_ctrl);
+     *   - target/i386/kvm/kvm.c|5234| <<kvm_get_msrs>> env->msr_fixed_ctr_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+     */
     uint64_t msr_fixed_ctr_ctrl;
+    /*
+     * 在以下使用CPUX86State->msr_global_ctrl:
+     *   - target/i386/machine.c|675| <<global>> VMSTATE_UINT64(env.msr_global_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4432| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, env->msr_global_ctrl);
+     *   - target/i386/kvm/kvm.c|5237| <<kvm_get_msrs>> env->msr_global_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+     */
     uint64_t msr_global_ctrl;
+    /*
+     * 在以下使用CPUX86State->msr_global_status:
+     *   - target/i386/machine.c|676| <<global>> VMSTATE_UINT64(env.msr_global_status, X86CPU),
+     *   - target/i386/kvm/kvm.c|4424| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, env->msr_global_status);
+     *   - target/i386/kvm/kvm.c|5240| <<kvm_get_msrs>> env->msr_global_status = msrs[i].data;
+     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+     */
     uint64_t msr_global_status;
+    /*
+     * 在以下使用CPUX86State->msr_global_ovf_ctrl:
+     *   - target/i386/machine.c|677| <<global>> VMSTATE_UINT64(env.msr_global_ovf_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4426| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, env->msr_global_ovf_ctrl);
+     *   - target/i386/kvm/kvm.c|5243| <<kvm_get_msrs>> env->msr_global_ovf_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+     */
     uint64_t msr_global_ovf_ctrl;
+    /*
+     * 在以下使用CPUX86State->msr_fixed_counters[MAX_FIXED_COUNTERS]:
+     *   - target/i386/machine.c|678| <<global>> VMSTATE_UINT64_ARRAY(env.msr_fixed_counters, X86CPU, MAX_FIXED_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4422| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, env->msr_fixed_counters[i]);
+     *   - target/i386/kvm/kvm.c|5270| <<kvm_get_msrs>> env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;
+     *   - target/i386/machine.c|655| <<pmu_enable_needed>> if (env->msr_fixed_counters[i]) {
+     */
     uint64_t msr_fixed_counters[MAX_FIXED_COUNTERS];
+    /*
+     * 在以下使用CPUX86State->msr_gp_counters[MAX_GP_COUNTERS]:
+     *   - target/i386/machine.c|679| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_counters, X86CPU, MAX_GP_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4418| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, env->msr_gp_counters[i]);
+     *   - target/i386/kvm/kvm.c|5249| <<kvm_get_msrs>> env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;
+     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+     */
     uint64_t msr_gp_counters[MAX_GP_COUNTERS];
+    /*
+     * 在以下使用CPUX86State->msr_gp_evtsel[MAX_GP_COUNTERS]:
+     *   - target/i386/machine.c|680| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_evtsel, X86CPU, MAX_GP_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4420| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, env->msr_gp_evtsel[i]);
+     *   - target/i386/kvm/kvm.c|5252| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+     */
     uint64_t msr_gp_evtsel[MAX_GP_COUNTERS];
 
     uint64_t pat;
@@ -1909,6 +1986,18 @@ typedef struct CPUArchState {
     uint32_t cpuid_max_level, cpuid_max_xlevel, cpuid_max_xlevel2;
     /* Actual level/xlevel/xlevel2 value: */
     uint32_t cpuid_level, cpuid_xlevel, cpuid_xlevel2;
+    /*
+     * 在以下使用CPUX86State->cpuid_vendor1:
+     *   - target/i386/cpu.c|5550| <<x86_cpuid_get_vendor>> x86_cpu_vendor_words2str(value, env->cpuid_vendor1, env->cpuid_vendor2,
+     *   - target/i386/cpu.c|5568| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 = 0;
+     *   - target/i386/cpu.c|5572| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 |= ((uint8_t)value[i ]) << (8 * i);
+     *   - target/i386/cpu.c|6451| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+     *   - target/i386/cpu.c|6862| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+     *   - target/i386/cpu.c|6877| <<cpu_x86_cpuid>> if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||
+     *   - target/i386/cpu.c|6883| <<cpu_x86_cpuid>> if (tcg_enabled() && env->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 &&
+     *   - target/i386/cpu.h|1051| <<IS_INTEL_CPU>> #define IS_INTEL_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 && \
+     *   - target/i386/cpu.h|1054| <<IS_AMD_CPU>> #define IS_AMD_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_AMD_1 && \
+     */
     uint32_t cpuid_vendor1;
     uint32_t cpuid_vendor2;
     uint32_t cpuid_vendor3;
@@ -2046,6 +2135,14 @@ struct ArchCPU {
     bool expose_tcg;
     bool migratable;
     bool migrate_smi_count;
+    /*
+     * 在以下使用ArchCPU->max_features:
+     *   - target/i386/cpu.c|5843| <<max_x86_cpu_initfn>> cpu->max_features = true;
+     *   - target/i386/cpu.c|8114| <<x86_cpu_expand_features>> if (cpu->max_features) {
+     *   - target/i386/hvf/hvf-cpu.c|70| <<hvf_cpu_instance_init>> if (cpu->max_features) {
+     *   - target/i386/kvm/kvm-cpu.c|89| <<kvm_cpu_realizefn>> if (cpu->max_features) {
+     *   - target/i386/kvm/kvm-cpu.c|250| <<kvm_cpu_instance_init>> if (cpu->max_features) {
+     */
     bool max_features; /* Enable all supported features automatically */
     uint32_t apic_id;
 
@@ -2148,6 +2245,25 @@ struct ArchCPU {
      * paging, guest physical address space might be restricted to 48 bits
      * even if the host cpu supports more physical address bits.
      */
+    /*
+     * 在以下设置ArchCPU->guest_phys_bits:
+     *   - target/i386/cpu.c|8315| <<global>> DEFINE_PROP_UINT32("guest-phys-bits", X86CPU, guest_phys_bits, -1),
+     *   - target/i386/cpu.c|7708| <<x86_cpu_realizefn>> cpu->guest_phys_bits = 0;
+     *   - target/i386/kvm/kvm-cpu.c|30| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = guest_phys_bits;
+     *   - target/i386/kvm/kvm-cpu.c|32| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = cpu->phys_bits;
+     *   - target/i386/kvm/kvm-cpu.c|37| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = cpu->host_phys_bits_limit;
+     * 在以下使用ArchCPU->guest_phys_bits:
+     *   - target/i386/cpu.c|6940| <<cpu_x86_cpuid>> *eax |= (cpu->guest_phys_bits << 16);
+     *   - target/i386/cpu.c|7703| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits == -1) {
+     *   - target/i386/cpu.c|7761| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits &&
+     *   - target/i386/cpu.c|7762| <<x86_cpu_realizefn>> (cpu->guest_phys_bits > cpu->phys_bits ||
+     *   - target/i386/cpu.c|7763| <<x86_cpu_realizefn>> cpu->guest_phys_bits < 32)) {
+     *   - target/i386/cpu.c|7766| <<x86_cpu_realizefn>> cpu->phys_bits, cpu->guest_phys_bits);
+     *   - target/i386/cpu.c|7777| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits != 0) {
+     *   - target/i386/kvm/kvm-cpu.c|31| <<kvm_set_guest_phys_bits>> if (cpu->guest_phys_bits > cpu->phys_bits) {
+     *   - target/i386/kvm/kvm-cpu.c|36| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits > cpu->host_phys_bits_limit) {
+     *   - target/i386/kvm/kvm-cpu.c|89| <<kvm_cpu_realizefn>> if ((env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) && cpu->guest_phys_bits == -1) {
+     */
     uint32_t guest_phys_bits;
 
     /* in order to simplify APIC support, we leave this pointer to the
@@ -2156,6 +2272,32 @@ struct ArchCPU {
     struct MemoryRegion *cpu_as_root, *cpu_as_mem, *smram;
     Notifier machine_done;
 
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     struct kvm_msrs *kvm_msr_buf;
 
     int32_t node_id; /* NUMA node this CPU belongs to */
diff --git a/target/i386/host-cpu.c b/target/i386/host-cpu.c
index 8b8bf5afe..614eff00e 100644
--- a/target/i386/host-cpu.c
+++ b/target/i386/host-cpu.c
@@ -69,6 +69,11 @@ static uint32_t host_cpu_adjust_phys_bits(X86CPU *cpu)
     return phys_bits;
 }
 
+/*
+ * called by:
+ *   - target/i386/hvf/hvf-cpu.c|81| <<hvf_cpu_accel_class_init>> acc->cpu_target_realize = host_cpu_realizefn;
+ *   - target/i386/kvm/kvm-cpu.c|106| <<kvm_cpu_realizefn>> ret = host_cpu_realizefn(cs, errp);
+ */
 bool host_cpu_realizefn(CPUState *cs, Error **errp)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -100,6 +105,10 @@ bool host_cpu_realizefn(CPUState *cs, Error **errp)
  * The function does NOT add a null terminator to the string
  * automatically.
  */
+/*
+ * called by:
+ *   - target/i386/host-cpu.c|167| <<host_cpu_max_instance_init>> host_cpu_fill_model_id(model_id);
+ */
 static int host_cpu_fill_model_id(char *str)
 {
     uint32_t eax = 0, ebx = 0, ecx = 0, edx = 0;
@@ -115,6 +124,12 @@ static int host_cpu_fill_model_id(char *str)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/host-cpu.c|160| <<host_cpu_max_instance_init>> host_cpu_vendor_fms(vendor, &family, &model, &stepping);
+ *   - target/i386/kvm/kvm.c|513| <<host_tsx_broken>> host_cpu_vendor_fms(vendor, &family, &model, &stepping);
+ *   - target/i386/kvm/vmsr_energy.c|86| <<is_host_cpu_intel>> host_cpu_vendor_fms(vendor, &family, &model, &stepping);
+ */
 void host_cpu_vendor_fms(char *vendor, int *family, int *model, int *stepping)
 {
     uint32_t eax, ebx, ecx, edx;
@@ -134,6 +149,11 @@ void host_cpu_vendor_fms(char *vendor, int *family, int *model, int *stepping)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/hvf/hvf-cpu.c|65| <<hvf_cpu_instance_init>> host_cpu_instance_init(cpu);
+ *   - target/i386/kvm/kvm-cpu.c|236| <<kvm_cpu_instance_init>> host_cpu_instance_init(cpu);
+ */
 void host_cpu_instance_init(X86CPU *cpu)
 {
     X86CPUClass *xcc = X86_CPU_GET_CLASS(cpu);
@@ -148,6 +168,11 @@ void host_cpu_instance_init(X86CPU *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/hvf/hvf-cpu.c|24| <<hvf_cpu_max_instance_init>> host_cpu_max_instance_init(cpu);
+ *   - target/i386/kvm/kvm-cpu.c|138| <<kvm_cpu_max_instance_init>> host_cpu_max_instance_init(cpu);
+ */
 void host_cpu_max_instance_init(X86CPU *cpu)
 {
     char vendor[CPUID_VENDOR_SZ + 1] = { 0 };
diff --git a/target/i386/kvm/kvm-cpu.c b/target/i386/kvm/kvm-cpu.c
index 6bf8dcfc6..33f16497c 100644
--- a/target/i386/kvm/kvm-cpu.c
+++ b/target/i386/kvm/kvm-cpu.c
@@ -17,6 +17,10 @@
 #include "kvm_i386.h"
 #include "hw/core/accel-cpu.h"
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm-cpu.c|90| <<kvm_cpu_realizefn>> kvm_set_guest_phys_bits(cs);
+ */
 static void kvm_set_guest_phys_bits(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -27,6 +31,25 @@ static void kvm_set_guest_phys_bits(CPUState *cs)
     if (!guest_phys_bits) {
         return;
     }
+    /*
+     * 在以下设置ArchCPU->guest_phys_bits:
+     *   - target/i386/cpu.c|8315| <<global>> DEFINE_PROP_UINT32("guest-phys-bits", X86CPU, guest_phys_bits, -1),
+     *   - target/i386/cpu.c|7708| <<x86_cpu_realizefn>> cpu->guest_phys_bits = 0;
+     *   - target/i386/kvm/kvm-cpu.c|30| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = guest_phys_bits;
+     *   - target/i386/kvm/kvm-cpu.c|32| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = cpu->phys_bits;
+     *   - target/i386/kvm/kvm-cpu.c|37| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = cpu->host_phys_bits_limit;
+     * 在以下使用ArchCPU->guest_phys_bits:
+     *   - target/i386/cpu.c|6940| <<cpu_x86_cpuid>> *eax |= (cpu->guest_phys_bits << 16);
+     *   - target/i386/cpu.c|7703| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits == -1) {
+     *   - target/i386/cpu.c|7761| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits &&
+     *   - target/i386/cpu.c|7762| <<x86_cpu_realizefn>> (cpu->guest_phys_bits > cpu->phys_bits ||
+     *   - target/i386/cpu.c|7763| <<x86_cpu_realizefn>> cpu->guest_phys_bits < 32)) {
+     *   - target/i386/cpu.c|7766| <<x86_cpu_realizefn>> cpu->phys_bits, cpu->guest_phys_bits);
+     *   - target/i386/cpu.c|7777| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits != 0) {
+     *   - target/i386/kvm/kvm-cpu.c|31| <<kvm_set_guest_phys_bits>> if (cpu->guest_phys_bits > cpu->phys_bits) {
+     *   - target/i386/kvm/kvm-cpu.c|36| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits > cpu->host_phys_bits_limit) {
+     *   - target/i386/kvm/kvm-cpu.c|89| <<kvm_cpu_realizefn>> if ((env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) && cpu->guest_phys_bits == -1) {
+     */
     cpu->guest_phys_bits = guest_phys_bits;
     if (cpu->guest_phys_bits > cpu->phys_bits) {
         cpu->guest_phys_bits = cpu->phys_bits;
@@ -63,6 +86,14 @@ static bool kvm_cpu_realizefn(CPUState *cs, Error **errp)
      *   check/update ucode_rev, phys_bits, guest_phys_bits, mwait
      *   cpu_common_realizefn() (via xcc->parent_realize)
      */
+    /*
+     * 在以下使用ArchCPU->max_features:
+     *   - target/i386/cpu.c|5843| <<max_x86_cpu_initfn>> cpu->max_features = true;
+     *   - target/i386/cpu.c|8114| <<x86_cpu_expand_features>> if (cpu->max_features) {
+     *   - target/i386/hvf/hvf-cpu.c|70| <<hvf_cpu_instance_init>> if (cpu->max_features) {
+     *   - target/i386/kvm/kvm-cpu.c|89| <<kvm_cpu_realizefn>> if (cpu->max_features) {
+     *   - target/i386/kvm/kvm-cpu.c|250| <<kvm_cpu_instance_init>> if (cpu->max_features) {
+     */
     if (cpu->max_features) {
         if (enable_cpu_pm) {
             if (kvm_has_waitpkg()) {
@@ -103,6 +134,10 @@ static bool lmce_supported(void)
     return !!(mce_cap & MCG_LMCE_P);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm-cpu.c|247| <<kvm_cpu_instance_init>> kvm_cpu_max_instance_init(cpu);
+ */
 static void kvm_cpu_max_instance_init(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -166,6 +201,11 @@ static void kvm_cpu_xsave_init(void)
  *       by the KVM accelerator (see "OS requirements" section at
  *       docs/system/target-i386.rst)
  */
+/*
+ * 在以下使用kvm_default_props[]:
+ *   - target/i386/kvm/kvm-cpu.c|217| <<x86_cpu_change_kvm_default>> for (pv = kvm_default_props; pv->prop; pv++) {
+ *   - target/i386/kvm/kvm-cpu.c|247| <<kvm_cpu_instance_init>> x86_cpu_apply_props(cpu, kvm_default_props);
+ */
 static PropValue kvm_default_props[] = {
     { "kvmclock", "on" },
     { "kvm-nopiodelay", "on" },
@@ -184,6 +224,11 @@ static PropValue kvm_default_props[] = {
 /*
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm-cpu.c|241| <<kvm_cpu_instance_init>> x86_cpu_change_kvm_default("x2apic", "off");
+ *   - target/i386/kvm/kvm-cpu.c|243| <<kvm_cpu_instance_init>> x86_cpu_change_kvm_default("kvm-msi-ext-dest-id", "on");
+ */
 static void x86_cpu_change_kvm_default(const char *prop, const char *value)
 {
     PropValue *pv;
@@ -206,6 +251,11 @@ static void kvm_cpu_instance_init(CPUState *cs)
     X86CPU *cpu = X86_CPU(cs);
     X86CPUClass *xcc = X86_CPU_GET_CLASS(cpu);
 
+    /*
+     * called by:
+     *   - target/i386/hvf/hvf-cpu.c|65| <<hvf_cpu_instance_init>> host_cpu_instance_init(cpu);
+     *   - target/i386/kvm/kvm-cpu.c|236| <<kvm_cpu_instance_init>> host_cpu_instance_init(cpu);
+     */
     host_cpu_instance_init(cpu);
 
     if (xcc->model) {
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 2fa88ef1e..fa3008985 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -85,6 +85,12 @@
 #define KVM_APIC_BUS_CYCLE_NS       1
 #define KVM_APIC_BUS_FREQUENCY      (1000000000ULL / KVM_APIC_BUS_CYCLE_NS)
 
+/*
+ * 在以下使用MSR_KVM_SYSTEM_TIME:
+ *   - target/i386/kvm/kvm.c|4154| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
+ *   - target/i386/kvm/kvm.c|4634| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);
+ *   - target/i386/kvm/kvm.c|4896| <<kvm_get_msrs>> case MSR_KVM_SYSTEM_TIME:
+ */
 #define MSR_KVM_WALL_CLOCK  0x11
 #define MSR_KVM_SYSTEM_TIME 0x12
 
@@ -94,6 +100,10 @@
 
 static void kvm_init_msrs(X86CPU *cpu);
 
+/*
+ * 在以下使用kvm_arch_required_capabilities[]:
+ *   - accel/kvm/kvm-all.c|2541| <<kvm_init>> kvm_check_extension_list(s, kvm_arch_required_capabilities);
+ */
 const KVMCapabilityInfo kvm_arch_required_capabilities[] = {
     KVM_CAP_INFO(SET_TSS_ADDR),
     KVM_CAP_INFO(EXT_CPUID),
@@ -146,8 +156,73 @@ static bool has_msr_vmx_procbased_ctls2;
 static bool has_msr_perf_capabs;
 static bool has_msr_pkrs;
 
+/*
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ *
+ * 在以下使用has_architectural_pmu_version:
+ *   - target/i386/kvm/kvm.c|2162| <<kvm_x86_build_cpuid>> has_architectural_pmu_version = eax & 0xff;
+ *   - target/i386/kvm/kvm.c|2163| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 0) {
+ *   - target/i386/kvm/kvm.c|2174| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 1) {
+ *   - target/i386/kvm/kvm.c|4316| <<kvm_put_msrs>> if (has_architectural_pmu_version > 0) {
+ *   - target/i386/kvm/kvm.c|4317| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+ *   - target/i386/kvm/kvm.c|4334| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+ *   - target/i386/kvm/kvm.c|4820| <<kvm_get_msrs>> if (has_architectural_pmu_version > 0) {
+ *   - target/i386/kvm/kvm.c|4821| <<kvm_get_msrs>> if (has_architectural_pmu_version > 1) {
+ *
+ * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+ * has_architectural_pmu_version = 0.
+ * num_architectural_pmu_gp_counters = 0.
+ * num_architectural_pmu_fixed_counters = 0.
+ *
+ * 2. 如果guest_vendor是Intel
+ * 完全按照cpuid来算
+ *
+ * 3. 如果guest_vendor是AMD
+ * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+ *      如果支持, 根据0x80000022获取寄存器的数目.
+ *      此外, 3个global的也支持!
+ *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+ * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+ *      就是6个寄存器
+ * 3.3. 默认只支持4个
+ *
+ *
+ * KVM中限制了version.
+ *
+ * 220         kvm_pmu_cap.version = min(kvm_pmu_cap.version, 2);
+ * 221         kvm_pmu_cap.num_counters_gp = min(kvm_pmu_cap.num_counters_gp,
+ * 222                                           pmu_ops->MAX_NR_GP_COUNTERS);
+ * 223         kvm_pmu_cap.num_counters_fixed = min(kvm_pmu_cap.num_counters_fixed,
+ * 224                                              KVM_PMC_MAX_FIXED);
+ */
 static uint32_t has_architectural_pmu_version;
+/*
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ *
+ * 在以下使用num_architectural_pmu_gp_counters:
+ *   - target/i386/kvm/kvm.c|2164| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
+ *   - target/i386/kvm/kvm.c|2170| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+ *   - target/i386/kvm/kvm.c|2171| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+ *   - target/i386/kvm/kvm.c|4328| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+ *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+ */
 static uint32_t num_architectural_pmu_gp_counters;
+/*
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ *
+ * 在以下使用num_architectural_pmu_fixed_counters:
+ *   - target/i386/kvm/kvm.c|2175| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = edx & 0x1f;
+ *   - target/i386/kvm/kvm.c|2177| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
+ *   - target/i386/kvm/kvm.c|2178| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = MAX_FIXED_COUNTERS;
+ *   - target/i386/kvm/kvm.c|4324| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+ *   - target/i386/kvm/kvm.c|4827| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+ */
 static uint32_t num_architectural_pmu_fixed_counters;
 
 static int has_xsave2;
@@ -162,6 +237,18 @@ static struct kvm_cpuid2 *cpuid_cache;
 static struct kvm_cpuid2 *hv_cpuid_cache;
 static struct kvm_msr_list *kvm_feature_msrs;
 
+/*
+ * 在以下使用msr_handlers[KVM_MSR_FILTER_MAX_RANGES]:
+ *   - target/i386/kvm/kvm.c|6026| <<kvm_install_msr_filters>> KVMMSRHandlers *handler = &msr_handlers[i];
+ *   - target/i386/kvm/kvm.c|6060| <<kvm_filter_msr>> for (i = 0; i < ARRAY_SIZE(msr_handlers); i++) {
+ *   - target/i386/kvm/kvm.c|6061| <<kvm_filter_msr>> if (!msr_handlers[i].msr) {
+ *   - target/i386/kvm/kvm.c|6062| <<kvm_filter_msr>> msr_handlers[i] = (KVMMSRHandlers) {
+ *   - target/i386/kvm/kvm.c|6069| <<kvm_filter_msr>> msr_handlers[i] = (KVMMSRHandlers) { };
+ *   - target/i386/kvm/kvm.c|6085| <<kvm_handle_rdmsr>> for (i = 0; i < ARRAY_SIZE(msr_handlers); i++) {
+ *   - target/i386/kvm/kvm.c|6086| <<kvm_handle_rdmsr>> KVMMSRHandlers *handler = &msr_handlers[i];
+ *   - target/i386/kvm/kvm.c|6105| <<kvm_handle_wrmsr>> for (i = 0; i < ARRAY_SIZE(msr_handlers); i++) {
+ *   - target/i386/kvm/kvm.c|6106| <<kvm_handle_wrmsr>> KVMMSRHandlers *handler = &msr_handlers[i];
+ */
 static KVMMSRHandlers msr_handlers[KVM_MSR_FILTER_MAX_RANGES];
 
 #define BUS_LOCK_SLICE_TIME 1000000000ULL /* ns */
@@ -175,6 +262,17 @@ static const char *vm_type_name[] = {
     [KVM_X86_SNP_VM] = "SEV-SNP",
 };
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|213| <<kvm_get_vm_type>> if (!kvm_is_vm_type_supported(kvm_type)) {
+ *   - target/i386/sev.c|1408| <<sev_kvm_type>> if (!kvm_is_vm_type_supported(kvm_type)) {
+ *
+ * #define KVM_X86_DEFAULT_VM      0
+ * #define KVM_X86_SW_PROTECTED_VM 1
+ * #define KVM_X86_SEV_VM          2
+ * #define KVM_X86_SEV_ES_VM       3        
+ * #define KVM_X86_SNP_VM          4
+ */
 bool kvm_is_vm_type_supported(int type)
 {
     uint32_t machine_types;
@@ -192,6 +290,10 @@ bool kvm_is_vm_type_supported(int type)
     return !!(machine_types & BIT(type));
 }
 
+/*
+ * called by:
+ *   - hw/i386/x86.c|357| <<x86_kvm_type>> return kvm_enabled() ? kvm_get_vm_type(ms) : 0;
+ */
 int kvm_get_vm_type(MachineState *ms)
 {
     int kvm_type = KVM_X86_DEFAULT_VM;
@@ -214,6 +316,10 @@ int kvm_get_vm_type(MachineState *ms)
     return kvm_type;
 }
 
+/*
+ * called by:
+ *   - target/i386/sev.c|772| <<sev_snp_launch_start>> if (!kvm_enable_hypercall(BIT_ULL(KVM_HC_MAP_GPA_RANGE))) {
+ */
 bool kvm_enable_hypercall(uint64_t enable_mask)
 {
     KVMState *s = KVM_STATE(current_accel());
@@ -221,11 +327,19 @@ bool kvm_enable_hypercall(uint64_t enable_mask)
     return !kvm_vm_enable_cap(s, KVM_CAP_EXIT_HYPERCALL, 0, enable_mask);
 }
 
+/*
+ * called by:
+ *   - hw/i386/x86.c|177| <<x86_machine_is_smm_enabled>> smm_available = kvm_has_smm();
+ */
 bool kvm_has_smm(void)
 {
     return kvm_vm_check_extension(kvm_state, KVM_CAP_X86_SMM);
 }
 
+/*
+ * called by:
+ *   - hw/i386/kvm/clock.c|152| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+ */
 bool kvm_has_adjust_clock_stable(void)
 {
     int ret = kvm_check_extension(kvm_state, KVM_CAP_ADJUST_CLOCK);
@@ -233,11 +347,19 @@ bool kvm_has_adjust_clock_stable(void)
     return (ret & KVM_CLOCK_TSC_STABLE);
 }
 
+/*
+ * called by:
+ *   - target/i386/machine.c|266| <<cpu_pre_save>> (!kvm_has_exception_payload() && (env->hflags & HF_GUEST_MASK) &&
+ */
 bool kvm_has_exception_payload(void)
 {
     return has_exception_payload;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|269| <<kvm_enable_x2apic>> kvm_x2apic_api_set_flags(KVM_X2APIC_API_USE_32BIT_IDS |
+ */
 static bool kvm_x2apic_api_set_flags(uint64_t flags)
 {
     KVMState *s = KVM_STATE(current_accel());
@@ -245,6 +367,11 @@ static bool kvm_x2apic_api_set_flags(uint64_t flags)
     return !kvm_vm_enable_cap(s, KVM_CAP_X2APIC_API, 0, flags);
 }
 
+/*
+ * 在以下使用MEMORIZE():
+ *   - target/i386/kvm/kvm.c|268| <<kvm_enable_x2apic>> return MEMORIZE(
+ *   - target/i386/kvm/kvm.c|6098| <<kvm_enable_sgx_provisioning>> return MEMORIZE(__kvm_enable_sgx_provisioning(s), has_sgx_provisioning);
+ */
 #define MEMORIZE(fn, _result) \
     ({ \
         static bool _memorized; \
@@ -258,11 +385,21 @@ static bool kvm_x2apic_api_set_flags(uint64_t flags)
 
 static bool has_x2apic_api;
 
+/*
+ * called by:
+ *   - hw/i386/kvm/apic.c|38| <<kvm_put_apic_state>> if (kvm_has_x2apic_api() && s->apicbase & MSR_IA32_APICBASE_EXTD) {
+ *   - hw/i386/kvm/apic.c|67| <<kvm_get_apic_state>> if (kvm_has_x2apic_api() && s->apicbase & MSR_IA32_APICBASE_EXTD) {
+ */
 bool kvm_has_x2apic_api(void)
 {
     return has_x2apic_api;
 }
 
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|4255| <<vtd_decide_config>> if (kvm_irqchip_is_split() && !kvm_enable_x2apic()) {
+ *   - hw/i386/x86-common.c|98| <<x86_cpus_init>> kvm_irqchip_in_kernel() && !kvm_enable_x2apic()) {
+ */
 bool kvm_enable_x2apic(void)
 {
     return MEMORIZE(
@@ -276,6 +413,10 @@ bool kvm_hv_vpindex_settable(void)
     return hv_vpindex_settable;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|303| <<do_kvm_synchronize_tsc>> kvm_get_tsc(cpu);
+ */
 static int kvm_get_tsc(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -298,11 +439,19 @@ static int kvm_get_tsc(CPUState *cs)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|316| <<kvm_synchronize_all_tsc>> run_on_cpu(cpu, do_kvm_synchronize_tsc, RUN_ON_CPU_NULL);
+ */
 static inline void do_kvm_synchronize_tsc(CPUState *cpu, run_on_cpu_data arg)
 {
     kvm_get_tsc(cpu);
 }
 
+/*
+ * called by:
+ *   - hw/i386/kvm/clock.c|210| <<kvmclock_vm_state_change>> kvm_synchronize_all_tsc();
+ */
 void kvm_synchronize_all_tsc(void)
 {
     CPUState *cpu;
@@ -314,6 +463,10 @@ void kvm_synchronize_all_tsc(void)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|353| <<get_supported_cpuid>> while ((cpuid = try_get_cpuid(s, max)) == NULL) {
+ */
 static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 {
     struct kvm_cpuid2 *cpuid;
@@ -342,6 +495,10 @@ static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 /* Run KVM_GET_SUPPORTED_CPUID ioctl(), allocating a buffer large enough
  * for all entries.
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|421| <<kvm_arch_get_supported_cpuid>> cpuid = get_supported_cpuid(s);
+ */
 static struct kvm_cpuid2 *get_supported_cpuid(KVMState *s)
 {
     struct kvm_cpuid2 *cpuid;
@@ -373,6 +530,11 @@ static bool host_tsx_broken(void)
 
 /* Returns the value for a specific register on the cpuid entry
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|425| <<kvm_arch_get_supported_cpuid>> ret = cpuid_entry_get_reg(entry, reg);
+ *   - target/i386/kvm/kvm.c|1291| <<hv_cpuid_get_host>> return cpuid_entry_get_reg(entry, reg);
+ */
 static uint32_t cpuid_entry_get_reg(struct kvm_cpuid_entry2 *entry, int reg)
 {
     uint32_t ret = 0;
@@ -395,6 +557,14 @@ static uint32_t cpuid_entry_get_reg(struct kvm_cpuid_entry2 *entry, int reg)
 
 /* Find matching entry for function/index on kvm_cpuid2 struct
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|423| <<kvm_arch_get_supported_cpuid>> struct kvm_cpuid_entry2 *entry = cpuid_find_entry(cpuid, function, index);
+ *   - target/i386/kvm/kvm.c|1286| <<hv_cpuid_get_host>> entry = cpuid_find_entry(cpuid, func, 0);
+ *   - target/i386/kvm/kvm.c|2245| <<kvm_arch_init_vcpu>> c = cpuid_find_entry(&cpuid_data.cpuid, 1, 0);
+ *   - target/i386/kvm/kvm.c|2251| <<kvm_arch_init_vcpu>> c = cpuid_find_entry(&cpuid_data.cpuid, 7, 0);
+ *   - target/i386/kvm/kvm.c|2288| <<kvm_arch_init_vcpu>> c = cpuid_find_entry(&cpuid_data.cpuid, kvm_base, 0);
+ */
 static struct kvm_cpuid_entry2 *cpuid_find_entry(struct kvm_cpuid2 *cpuid,
                                                  uint32_t function,
                                                  uint32_t index)
@@ -410,6 +580,29 @@ static struct kvm_cpuid_entry2 *cpuid_find_entry(struct kvm_cpuid2 *cpuid,
     return NULL;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|6063| <<x86_cpu_get_supported_feature_word>> r = kvm_arch_get_supported_cpuid(kvm_state, wi->cpuid.eax,
+ *   - target/i386/cpu.c|6137| <<x86_cpu_get_supported_cpuid>> *eax = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_EAX);
+ *   - target/i386/cpu.c|6138| <<x86_cpu_get_supported_cpuid>> *ebx = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_EBX);
+ *   - target/i386/cpu.c|6139| <<x86_cpu_get_supported_cpuid>> *ecx = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_ECX);
+ *   - target/i386/cpu.c|6140| <<x86_cpu_get_supported_cpuid>> *edx = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_EDX);
+ *   - target/i386/kvm/kvm-cpu.c|25| <<kvm_set_guest_phys_bits>> eax = kvm_arch_get_supported_cpuid(cs->kvm_state, 0x80000008, 0, R_EAX);
+ *   - target/i386/kvm/kvm-cpu.c|118| <<kvm_cpu_max_instance_init>> kvm_arch_get_supported_cpuid(s, 0x0, 0, R_EAX);
+ *   - target/i386/kvm/kvm-cpu.c|120| <<kvm_cpu_max_instance_init>> kvm_arch_get_supported_cpuid(s, 0x80000000, 0, R_EAX);
+ *   - target/i386/kvm/kvm-cpu.c|122| <<kvm_cpu_max_instance_init>> kvm_arch_get_supported_cpuid(s, 0xC0000000, 0, R_EAX);
+ *   - target/i386/kvm/kvm.c|537| <<kvm_arch_get_supported_cpuid>> cpuid_1_edx = kvm_arch_get_supported_cpuid(s, 1, 0, R_EDX);
+ *   - target/i386/kvm/kvm.c|601| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 0xD, 1, R_ECX) &
+ *   - target/i386/kvm/kvm.c|605| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 1, 0, R_ECX) &
+ *   - target/i386/kvm/kvm.c|609| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 7, 0, R_EBX) &
+ *   - target/i386/kvm/kvm.c|613| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 7, 0, R_EBX) &
+ *   - target/i386/kvm/kvm.c|617| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 0x80000001, 0, R_EDX) &
+ *   - target/i386/kvm/kvm.c|1771| <<kvm_init_xsave>> assert(kvm_arch_get_supported_cpuid(kvm_state, 0xd, 0, R_ECX) <=
+ *   - target/i386/kvm/kvm.c|4014| <<kvm_put_msrs>> int addr_num = kvm_arch_get_supported_cpuid(kvm_state,
+ *   - target/i386/kvm/kvm.c|4441| <<kvm_get_msrs>> kvm_arch_get_supported_cpuid(kvm_state, 0x14, 1, R_EAX) & 0x7;
+ *   - target/i386/kvm/kvm.c|6239| <<kvm_request_xsave_components>> supported = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);
+ *   - target/i386/kvm/kvm.c|6240| <<kvm_request_xsave_components>> supported |= (uint64_t)kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX) << 32;
+ */
 uint32_t kvm_arch_get_supported_cpuid(KVMState *s, uint32_t function,
                                       uint32_t index, int reg)
 {
@@ -560,6 +753,15 @@ uint32_t kvm_arch_get_supported_cpuid(KVMState *s, uint32_t function,
     return ret;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|6068| <<x86_cpu_get_supported_feature_word>> r = kvm_arch_get_supported_msr_feature(kvm_state,
+ *   - target/i386/kvm/kvm-cpu.c|79| <<kvm_cpu_realizefn>> kvm_arch_get_supported_msr_feature(kvm_state,
+ *   - target/i386/kvm/kvm.c|3610| <<kvm_msr_entry_add_vmx>> kvm_arch_get_supported_msr_feature(kvm_state,
+ *   - target/i386/kvm/kvm.c|3621| <<kvm_msr_entry_add_vmx>> kvm_arch_get_supported_msr_feature(kvm_state,
+ *   - target/i386/kvm/kvm.c|3624| <<kvm_msr_entry_add_vmx>> kvm_arch_get_supported_msr_feature(kvm_state,
+ *   - target/i386/kvm/kvm.c|3709| <<kvm_msr_entry_add_perf>> kvm_arch_get_supported_msr_feature(kvm_state,
+ */
 uint64_t kvm_arch_get_supported_msr_feature(KVMState *s, uint32_t index)
 {
     struct {
@@ -645,6 +847,10 @@ static int kvm_get_mce_cap_supported(KVMState *s, uint64_t *mce_cap,
     return kvm_ioctl(s, KVM_X86_GET_MCE_CAP_SUPPORTED, mce_cap);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|736| <<kvm_arch_on_sigbus_vcpu>> kvm_mce_inject(cpu, paddr, code);
+ */
 static void kvm_mce_inject(X86CPU *cpu, hwaddr paddr, int code)
 {
     CPUState *cs = CPU(cpu);
@@ -714,6 +920,11 @@ static void hardware_memory_error(void *host_addr)
     exit(1);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|3032| <<kvm_cpu_exec>> kvm_arch_on_sigbus_vcpu(cpu, pending_sigbus_code,
+ *   - accel/kvm/kvm-all.c|3570| <<kvm_on_sigbus>> kvm_arch_on_sigbus_vcpu(first_cpu, code, addr);
+ */
 void kvm_arch_on_sigbus_vcpu(CPUState *c, int code, void *addr)
 {
     X86CPU *cpu = X86_CPU(c);
@@ -768,6 +979,11 @@ void kvm_arch_on_sigbus_vcpu(CPUState *c, int code, void *addr)
     emit_hypervisor_memory_failure(MEMORY_FAILURE_ACTION_IGNORE, false);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|5436| <<kvm_arch_process_async_events>> kvm_queue_exception(env, EXCP12_MCHK, 0, 0);
+ *   - target/i386/kvm/kvm.c|5657| <<kvm_handle_debug>> kvm_queue_exception(env, arch_info->exception,
+ */
 static void kvm_queue_exception(CPUX86State *env,
                                 int32_t exception_nr,
                                 uint8_t exception_has_payload,
@@ -809,6 +1025,29 @@ static void cpu_update_state(void *opaque, bool running, RunState state)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|347| <<kvm_park_vcpu>> trace_kvm_park_vcpu(cpu->cpu_index, kvm_arch_vcpu_id(cpu));
+ *   - accel/kvm/kvm-all.c|350| <<kvm_park_vcpu>> vcpu->vcpu_id = kvm_arch_vcpu_id(cpu);
+ *   - accel/kvm/kvm-all.c|376| <<kvm_create_vcpu>> unsigned long vcpu_id = kvm_arch_vcpu_id(cpu);
+ *   - accel/kvm/kvm-all.c|420| <<do_kvm_destroy_vcpu>> trace_kvm_destroy_vcpu(cpu->cpu_index, kvm_arch_vcpu_id(cpu));
+ *   - accel/kvm/kvm-all.c|465| <<kvm_init_vcpu>> trace_kvm_init_vcpu(cpu->cpu_index, kvm_arch_vcpu_id(cpu));
+ *   - accel/kvm/kvm-all.c|471| <<kvm_init_vcpu>> kvm_arch_vcpu_id(cpu));
+ *   - accel/kvm/kvm-all.c|489| <<kvm_init_vcpu>> kvm_arch_vcpu_id(cpu));
+ *   - accel/kvm/kvm-all.c|514| <<kvm_init_vcpu>> kvm_arch_vcpu_id(cpu));
+ *   - hw/i386/kvm/xen_evtchn.c|563| <<assign_kernel_port>> ha.u.evtchn.deliver.port.vcpu = kvm_arch_vcpu_id(cpu);
+ *   - hw/i386/kvm/xen_evtchn.c|925| <<set_port_pending>> evt.vcpu = kvm_arch_vcpu_id(cpu);
+ *   - hw/i386/kvm/xen_evtchn.c|1784| <<xen_evtchn_translate_pirq_msi>> route->u.xen_evtchn.vcpu = kvm_arch_vcpu_id(cpu);
+ *   - hw/intc/openpic_kvm.c|262| <<kvm_openpic_connect_vcpu>> kvm_arch_vcpu_id(cs));
+ *   - hw/intc/spapr_xive_kvm.c|43| <<kvm_cpu_is_enabled>> unsigned long vcpu_id = kvm_arch_vcpu_id(cs);
+ *   - hw/intc/spapr_xive_kvm.c|56| <<kvm_cpu_enable>> unsigned long vcpu_id = kvm_arch_vcpu_id(cs);
+ *   - hw/intc/spapr_xive_kvm.c|92| <<kvmppc_xive_cpu_set_state>> kvm_arch_vcpu_id(tctx->cs));
+ *   - hw/intc/spapr_xive_kvm.c|111| <<kvmppc_xive_cpu_get_state>> kvm_arch_vcpu_id(tctx->cs));
+ *   - hw/intc/spapr_xive_kvm.c|165| <<kvmppc_xive_cpu_connect>> vcpu_id = kvm_arch_vcpu_id(tctx->cs);
+ *   - hw/intc/xics_kvm.c|83| <<icp_get_kvm_state>> " for CPU %ld: %s", kvm_arch_vcpu_id(icp->cs), strerror(errno));
+ *   - hw/intc/xics_kvm.c|130| <<icp_set_kvm_state>> kvm_arch_vcpu_id(icp->cs));
+ *   - hw/intc/xics_kvm.c|151| <<icp_kvm_realize>> vcpu_id = kvm_arch_vcpu_id(cs);
+ */
 unsigned long kvm_arch_vcpu_id(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -842,6 +1081,11 @@ static inline bool freq_within_bounds(int freq, int target_freq)
         return false;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2054| <<kvm_arch_init_vcpu>> r = kvm_arch_set_tsc_khz(cs);
+ *   - target/i386/kvm/kvm.c|5158| <<kvm_arch_put_registers>> kvm_arch_set_tsc_khz(cpu);
+ */
 static int kvm_arch_set_tsc_khz(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -894,6 +1138,11 @@ static int kvm_arch_set_tsc_khz(CPUState *cs)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2135| <<kvm_arch_init_vcpu>> c->eax = ((!!tsc_is_stable_and_known(env) << 1) |
+ *   - target/i386/kvm/kvm.c|2280| <<kvm_arch_init_vcpu>> && tsc_is_stable_and_known(env)) {
+ */
 static bool tsc_is_stable_and_known(CPUX86State *env)
 {
     if (!env->tsc_khz) {
@@ -905,6 +1154,28 @@ static bool tsc_is_stable_and_known(CPUX86State *env)
 
 #define DEFAULT_EVMCS_VERSION ((1 << 8) | 1)
 
+/*
+ * 在以下使用kvm_hyperv_properties[]:
+ *   - target/i386/kvm/kvm.c|916| <<global>> } kvm_hyperv_properties[] = {
+ *   - target/i386/kvm/kvm.c|1299| <<hyperv_feature_supported>> for (i = 0; i < ARRAY_SIZE(kvm_hyperv_properties[feature].flags); i++) {
+ *   - target/i386/kvm/kvm.c|1301| <<hyperv_feature_supported>> func = kvm_hyperv_properties[feature].flags[i].func;
+ *   - target/i386/kvm/kvm.c|1302| <<hyperv_feature_supported>> reg = kvm_hyperv_properties[feature].flags[i].reg;
+ *   - target/i386/kvm/kvm.c|1303| <<hyperv_feature_supported>> bits = kvm_hyperv_properties[feature].flags[i].bits;
+ *   - target/i386/kvm/kvm.c|1323| <<hv_feature_check_deps>> deps = kvm_hyperv_properties[feature].dependencies;
+ *   - target/i386/kvm/kvm.c|1328| <<hv_feature_check_deps>> kvm_hyperv_properties[feature].desc,
+ *   - target/i386/kvm/kvm.c|1329| <<hv_feature_check_deps>> kvm_hyperv_properties[dep_feat].desc);
+ *   - target/i386/kvm/kvm.c|1344| <<hv_build_cpuid_leaf>> for (i = 0; i < ARRAY_SIZE(kvm_hyperv_properties); i++) {
+ *   - target/i386/kvm/kvm.c|1349| <<hv_build_cpuid_leaf>> for (j = 0; j < ARRAY_SIZE(kvm_hyperv_properties[i].flags); j++) {
+ *   -  target/i386/kvm/kvm.c|1350| <<hv_build_cpuid_leaf>> if (kvm_hyperv_properties[i].flags[j].func != func) {
+ *   - target/i386/kvm/kvm.c|1353| <<hv_build_cpuid_leaf>> if (kvm_hyperv_properties[i].flags[j].reg != reg) {
+ *   - target/i386/kvm/kvm.c|1357| <<hv_build_cpuid_leaf>> r |= kvm_hyperv_properties[i].flags[j].bits;
+ *   - target/i386/kvm/kvm.c|1447| <<kvm_hyperv_expand_features>> for (feat = 0; feat < ARRAY_SIZE(kvm_hyperv_properties); feat++) {
+ *   - target/i386/kvm/kvm.c|1454| <<kvm_hyperv_expand_features>> for (feat = 0; feat < ARRAY_SIZE(kvm_hyperv_properties); feat++) {
+ *   - target/i386/kvm/kvm.c|1463| <<kvm_hyperv_expand_features>> kvm_hyperv_properties[feat].desc);
+ *   - target/i386/kvm/kvm.c|1480| <<kvm_hyperv_expand_features>> kvm_hyperv_properties[HYPERV_FEAT_SYNIC].desc,
+ *   - target/i386/kvm/kvm.c|1481| <<kvm_hyperv_expand_features>> kvm_hyperv_properties[HYPERV_FEAT_VPINDEX].desc);
+ *   - target/i386/kvm/kvm.c|1721| <<hyperv_init_vcpu>> kvm_hyperv_properties[HYPERV_FEAT_EVMCS].desc);
+ */
 static struct {
     const char *desc;
     struct {
@@ -1160,6 +1431,10 @@ static struct kvm_cpuid2 *get_supported_hv_cpuid(CPUState *cs)
  * When KVM_GET_SUPPORTED_HV_CPUID is not supported we fill CPUID feature
  * leaves from KVM_CAP_HYPERV* and present MSRs data.
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|1277| <<hv_cpuid_get_host>> cpuid = get_supported_hv_cpuid_legacy(cs);
+ */
 static struct kvm_cpuid2 *get_supported_hv_cpuid_legacy(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -1633,6 +1908,10 @@ static bool evmcs_version_supported(uint16_t evmcs_version,
         (max_version <= max_supported_version);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2089| <<kvm_arch_init_vcpu>> r = hyperv_init_vcpu(cpu);
+ */
 static int hyperv_init_vcpu(X86CPU *cpu)
 {
     CPUState *cs = CPU(cpu);
@@ -1754,6 +2033,10 @@ static Error *invtsc_mig_blocker;
 
 #define KVM_MAX_CPUID_ENTRIES  100
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2299| <<kvm_arch_init_vcpu>> kvm_init_xsave(env);
+ */
 static void kvm_init_xsave(CPUX86State *env)
 {
     if (has_xsave2) {
@@ -1772,6 +2055,11 @@ static void kvm_init_xsave(CPUX86State *env)
            env->xsave_buf_len);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2309| <<kvm_arch_init_vcpu>> kvm_init_nested_state(env);
+ *   - target/i386/kvm/kvm.c|2362| <<kvm_arch_reset_vcpu>> kvm_init_nested_state(env);
+ */
 static void kvm_init_nested_state(CPUX86State *env)
 {
     struct kvm_vmx_nested_state_hdr *vmx_hdr;
@@ -1796,6 +2084,14 @@ static void kvm_init_nested_state(CPUX86State *env)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2203| <<kvm_arch_init_vcpu>> cpuid_i = kvm_x86_build_cpuid(env, cpuid_data.entries, cpuid_i);
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
 static uint32_t kvm_x86_build_cpuid(CPUX86State *env,
                                     struct kvm_cpuid_entry2 *entries,
                                     uint32_t cpuid_i)
@@ -1804,6 +2100,29 @@ static uint32_t kvm_x86_build_cpuid(CPUX86State *env,
     uint32_t unused;
     struct kvm_cpuid_entry2 *c;
 
+    /*
+     * called by:
+     *   - hw/i386/fw_cfg.c|183| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 1, 0, &unused, &unused, &ecx, &edx);
+     *   - hw/i386/fw_cfg.c|195| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 0x7, 0, &unused, &ebx, &ecx, &unused);
+     *   - target/i386/hvf/hvf.c|404| <<hvf_cpu_x86_cpuid>> cpu_x86_cpuid(env, index, count, eax, ebx, ecx, edx);
+     *   - target/i386/kvm/kvm.c|2061| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0, 0, &limit, &unused, &unused, &unused);
+     *   - target/i386/kvm/kvm.c|2077| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2087| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2108| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2133| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2154| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2165| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2172| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2187| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0x0a, 0, &eax, &unused, &unused, &edx);
+     *   - target/i386/kvm/kvm.c|2211| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0x80000000, 0, &limit, &unused, &unused, &unused);
+     *   - target/i386/kvm/kvm.c|2227| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2241| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2255| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0xC0000000, 0, &limit, &unused, &unused, &unused);
+     *   - target/i386/kvm/kvm.c|2266| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/tcg/fpu_helper.c|3151| <<helper_xsetbv>> cpu_x86_cpuid(env, 0x0d, 0, &ena_lo, &dummy, &dummy, &ena_hi);
+     *   - target/i386/tcg/misc_helper.c|56| <<helper_cpuid>> cpu_x86_cpuid(env, (uint32_t)env->regs[R_EAX], (uint32_t)env->regs[R_ECX],
+     *   - target/i386/whpx/whpx-all.c|1946| <<whpx_vcpu_run>> cpu_x86_cpuid(env, cpuid_fn, 0, (UINT32 *)&rax, (UINT32 *)&rbx,
+     */
     cpu_x86_cpuid(env, 0, 0, &limit, &unused, &unused, &unused);
 
     for (i = 0; i <= limit; i++) {
@@ -1930,12 +2249,49 @@ static uint32_t kvm_x86_build_cpuid(CPUX86State *env,
     if (limit >= 0x0a) {
         uint32_t eax, edx;
 
+        /*
+         * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+	 * has_architectural_pmu_version = 0.
+	 * num_architectural_pmu_gp_counters = 0.
+	 * num_architectural_pmu_fixed_counters = 0.
+	 *
+	 * 2. 如果guest_vendor是Intel
+	 * 完全按照cpuid来算
+	 *
+	 * 3. 如果guest_vendor是AMD
+	 * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+	 *      如果支持, 根据0x80000022获取寄存器的数目.
+	 *      此外, 3个global的也支持!
+	 *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+	 * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+	 *      就是6个寄存器
+	 * 3.3. 默认只支持4个
+	 */
         cpu_x86_cpuid(env, 0x0a, 0, &eax, &unused, &unused, &edx);
 
+        /*
+	 * 在以下使用has_architectural_pmu_version:
+	 *   - target/i386/kvm/kvm.c|2162| <<kvm_x86_build_cpuid>> has_architectural_pmu_version = eax & 0xff;
+	 *   - target/i386/kvm/kvm.c|2163| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|2174| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4316| <<kvm_put_msrs>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|4317| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4334| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4820| <<kvm_get_msrs>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|4821| <<kvm_get_msrs>> if (has_architectural_pmu_version > 1) {
+	 */
         has_architectural_pmu_version = eax & 0xff;
         if (has_architectural_pmu_version > 0) {
             num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
 
+            /*
+	     * 在以下使用num_architectural_pmu_gp_counters:
+	     *   - target/i386/kvm/kvm.c|2164| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
+	     *   - target/i386/kvm/kvm.c|2170| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+	     *   - target/i386/kvm/kvm.c|2171| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+	     *   - target/i386/kvm/kvm.c|4328| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	     */
             /* Shouldn't be more than 32, since that's the number of bits
              * available in EBX to tell us _which_ counters are available.
              * Play it safe.
@@ -1945,6 +2301,14 @@ static uint32_t kvm_x86_build_cpuid(CPUX86State *env,
             }
 
             if (has_architectural_pmu_version > 1) {
+                /*
+		 * 在以下使用num_architectural_pmu_fixed_counters:
+		 *   - target/i386/kvm/kvm.c|2175| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = edx & 0x1f;
+		 *   - target/i386/kvm/kvm.c|2177| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
+		 *   - target/i386/kvm/kvm.c|2178| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = MAX_FIXED_COUNTERS;
+		 *   - target/i386/kvm/kvm.c|4324| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+		 *   - target/i386/kvm/kvm.c|4827| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+		 */
                 num_architectural_pmu_fixed_counters = edx & 0x1f;
 
                 if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
@@ -2021,6 +2385,32 @@ full:
     abort();
 }
 
+/*
+ * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+ * has_architectural_pmu_version = 0.
+ * num_architectural_pmu_gp_counters = 0.
+ * num_architectural_pmu_fixed_counters = 0.
+ *
+ * 2. 如果guest_vendor是Intel
+ * 完全按照cpuid来算
+ *
+ * 3. 如果guest_vendor是AMD
+ * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+ *      如果支持, 根据0x80000022获取寄存器的数目.
+ *      此外, 3个global的也支持!
+ *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+ * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+ *      就是6个寄存器
+ * 3.3. 默认只支持4个
+ *
+ *
+ * called by:
+ *   - accel/kvm/kvm-all.c|510| <<kvm_init_vcpu>> ret = kvm_arch_init_vcpu(cpu);
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
 int kvm_arch_init_vcpu(CPUState *cs)
 {
     struct {
@@ -2200,6 +2590,30 @@ int kvm_arch_init_vcpu(CPUState *cs)
         }
     }
 
+    /*
+     * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+     * has_architectural_pmu_version = 0.
+     * num_architectural_pmu_gp_counters = 0.
+     * num_architectural_pmu_fixed_counters = 0.
+     *
+     * 2. 如果guest_vendor是Intel
+     * 完全按照cpuid来算
+     *
+     * 3. 如果guest_vendor是AMD
+     * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+     *      如果支持, 根据0x80000022获取寄存器的数目.
+     *      此外, 3个global的也支持!
+     *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+     * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+     *      就是6个寄存器
+     * 3.3. 默认只支持4个
+     *
+     * 查看:
+     *
+     * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+     *
+     * 只在此处调用
+     */
     cpuid_i = kvm_x86_build_cpuid(env, cpuid_data.entries, cpuid_i);
     cpuid_data.cpuid.nent = cpuid_i;
 
@@ -2292,6 +2706,12 @@ int kvm_arch_init_vcpu(CPUState *cs)
     cpuid_data.cpuid.nent = cpuid_i;
 
     cpuid_data.cpuid.padding = 0;
+    /*
+     * struct {
+     *     struct kvm_cpuid2 cpuid;
+     *     struct kvm_cpuid_entry2 entries[KVM_MAX_CPUID_ENTRIES];
+     * } cpuid_data;
+     */
     r = kvm_vcpu_ioctl(cs, KVM_SET_CPUID2, &cpuid_data);
     if (r) {
         goto fail;
@@ -2310,12 +2730,41 @@ int kvm_arch_init_vcpu(CPUState *cs)
         }
     }
 
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
 
     if (!(env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_RDTSCP)) {
         has_msr_tsc_aux = false;
     }
 
+    /*
+     * 只在此处调用
+     */
     kvm_init_msrs(cpu);
 
     return 0;
@@ -2326,6 +2775,10 @@ int kvm_arch_init_vcpu(CPUState *cs)
     return r;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|422| <<do_kvm_destroy_vcpu>> ret = kvm_arch_destroy_vcpu(cpu);
+ */
 int kvm_arch_destroy_vcpu(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -2344,6 +2797,10 @@ int kvm_arch_destroy_vcpu(CPUState *cs)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|7217| <<x86_cpu_reset_hold>> kvm_arch_reset_vcpu(cpu);
+ */
 void kvm_arch_reset_vcpu(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -2364,6 +2821,10 @@ void kvm_arch_reset_vcpu(X86CPU *cpu)
     sev_es_set_reset_vector(CPU(cpu));
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|7231| <<x86_cpu_after_reset>> kvm_arch_after_reset_vcpu(cpu);
+ */
 void kvm_arch_after_reset_vcpu(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -2382,6 +2843,10 @@ void kvm_arch_after_reset_vcpu(X86CPU *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/helper.c|609| <<do_cpu_init>> kvm_arch_do_init_vcpu(cpu);
+ */
 void kvm_arch_do_init_vcpu(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -2392,6 +2857,10 @@ void kvm_arch_do_init_vcpu(X86CPU *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3074| <<kvm_arch_init>> kvm_get_supported_feature_msrs(s);
+ */
 static int kvm_get_supported_feature_msrs(KVMState *s)
 {
     int ret = 0;
@@ -2432,6 +2901,10 @@ static int kvm_get_supported_feature_msrs(KVMState *s)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3069| <<kvm_arch_init>> ret = kvm_get_supported_msrs(s);
+ */
 static int kvm_get_supported_msrs(KVMState *s)
 {
     int ret = 0;
@@ -2563,6 +3036,10 @@ static int kvm_get_supported_msrs(KVMState *s)
     return ret;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3187| <<kvm_arch_init>> r = kvm_filter_msr(s, MSR_CORE_THREAD_COUNT, kvm_rdmsr_core_thread_count, NULL);
+ */
 static bool kvm_rdmsr_core_thread_count(X86CPU *cpu,
                                         uint32_t msr,
                                         uint64_t *val)
@@ -2656,6 +3133,11 @@ static void register_smram_listener(Notifier *n, void *unused)
                                  &smram_address_space, 1, "kvm-smram");
 }
 
+/*
+ * 在以下使用kvm_msr_energy_thread():
+ *   - target/i386/kvm/kvm.c|2987| <<kvm_msr_energy_thread_init>> qemu_thread_create(&r->msr_thr, "kvm-msr",
+ *                  kvm_msr_energy_thread, s, QEMU_THREAD_JOINABLE);
+ */
 static void *kvm_msr_energy_thread(void *data)
 {
     KVMState *s = data;
@@ -2885,6 +3367,10 @@ clean:
     return NULL;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3229| <<kvm_arch_init>> r = kvm_msr_energy_thread_init(s, ms);
+ */
 static int kvm_msr_energy_thread_init(KVMState *s, MachineState *ms)
 {
     MachineClass *mc = MACHINE_GET_CLASS(ms);
@@ -2990,11 +3476,19 @@ out:
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2478| <<kvm_init>> type = kvm_arch_get_default_type(ms);
+ */
 int kvm_arch_get_default_type(MachineState *ms)
 {
     return 0;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2635| <<kvm_init>> ret = kvm_arch_init(ms, s);
+ */
 int kvm_arch_init(MachineState *ms, KVMState *s)
 {
     uint64_t identity_base = 0xfffbc000;
@@ -3469,13 +3963,95 @@ static int kvm_put_sregs2(X86CPU *cpu)
 }
 
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3493| <<kvm_put_one_msr>> kvm_msr_buf_reset(cpu);
+ *   - target/i386/kvm/kvm.c|3739| <<kvm_init_msrs>> kvm_msr_buf_reset(cpu);
+ *   - target/i386/kvm/kvm.c|3774| <<kvm_put_msrs>> kvm_msr_buf_reset(cpu);
+ *   - target/i386/kvm/kvm.c|4248| <<kvm_get_msrs>> kvm_msr_buf_reset(cpu);
+ */
 static void kvm_msr_buf_reset(X86CPU *cpu)
 {
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
 }
 
+/*
+ * 特别多的调用:
+ *   - target/i386/kvm/kvm.c|3494| <<kvm_put_one_msr>> kvm_msr_entry_add(cpu, index, value);
+ *   - target/i386/kvm/kvm.c|3663| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_TRUE_PROCBASED_CTLS,
+ *   - target/i386/kvm/kvm.c|3666| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_TRUE_PINBASED_CTLS,
+ *   - target/i386/kvm/kvm.c|3669| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_TRUE_EXIT_CTLS,
+ *   - target/i386/kvm/kvm.c|3672| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_TRUE_ENTRY_CTLS,
+ *   - target/i386/kvm/kvm.c|3675| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_PROCBASED_CTLS2,
+ *   - target/i386/kvm/kvm.c|3678| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_EPT_VPID_CAP,
+ *   - target/i386/kvm/kvm.c|3680| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_BASIC,
+ *   - target/i386/kvm/kvm.c|3682| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_MISC,
+ *   - target/i386/kvm/kvm.c|3685| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_VMFUNC, f[FEAT_VMX_VMFUNC]);
+ *   - target/i386/kvm/kvm.c|3692| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_CR0_FIXED0,
+ *   - target/i386/kvm/kvm.c|3694| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_CR4_FIXED0,
+ *   - target/i386/kvm/kvm.c|3699| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_VMCS_ENUM, 0x32);
+ *   - target/i386/kvm/kvm.c|3702| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_VMCS_ENUM, 0x2E);
+ *   - target/i386/kvm/kvm.c|3713| <<kvm_msr_entry_add_perf>> kvm_msr_entry_add(cpu, MSR_IA32_PERF_CAPABILITIES,
+ *   - target/i386/kvm/kvm.c|3741| <<kvm_init_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_ARCH_CAPABILITIES,
+ *   - target/i386/kvm/kvm.c|3746| <<kvm_init_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_CORE_CAPABILITY,
+ *   - target/i386/kvm/kvm.c|3755| <<kvm_init_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_UCODE_REV, cpu->ucode_rev);
+ *   - 特别特别多的kvm_put_msrs()
+ *   - 特别特别多的kvm_get_msrs()
+ */
 static void kvm_msr_entry_add(X86CPU *cpu, uint32_t index, uint64_t value)
 {
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     struct kvm_msrs *msrs = cpu->kvm_msr_buf;
     void *limit = ((void *)msrs) + MSR_BUF_SIZE;
     struct kvm_msr_entry *entry = &msrs->entries[msrs->nmsrs];
@@ -3488,6 +4064,12 @@ static void kvm_msr_entry_add(X86CPU *cpu, uint32_t index, uint64_t value)
     msrs->nmsrs++;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3522| <<kvm_put_apicbase>> ret = kvm_put_one_msr(cpu, MSR_IA32_APICBASE, value);
+ *   - target/i386/kvm/kvm.c|3535| <<kvm_put_tscdeadline_msr>> ret = kvm_put_one_msr(cpu, MSR_IA32_TSCDEADLINE, env->tsc_deadline);
+ *   - target/i386/kvm/kvm.c|3558| <<kvm_put_msr_feature_control>> ret = kvm_put_one_msr(cpu, MSR_IA32_FEATURE_CONTROL,
+ */
 static int kvm_put_one_msr(X86CPU *cpu, int index, uint64_t value)
 {
     kvm_msr_buf_reset(cpu);
@@ -3604,6 +4186,10 @@ static uint64_t make_vmx_msr_value(uint32_t index, uint32_t features)
     return must_be_one | (((uint64_t)can_be_one) << 32);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3763| <<kvm_init_msrs>> kvm_msr_entry_add_vmx(cpu, env->features);
+ */
 static void kvm_msr_entry_add_vmx(X86CPU *cpu, FeatureWordArray f)
 {
     uint64_t kvm_vmx_basic =
@@ -3703,6 +4289,10 @@ static void kvm_msr_entry_add_vmx(X86CPU *cpu, FeatureWordArray f)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3751| <<kvm_init_msrs>> kvm_msr_entry_add_perf(cpu, env->features);
+ */
 static void kvm_msr_entry_add_perf(X86CPU *cpu, FeatureWordArray f)
 {
     uint64_t kvm_perf_cap =
@@ -3715,8 +4305,39 @@ static void kvm_msr_entry_add_perf(X86CPU *cpu, FeatureWordArray f)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3766| <<kvm_init_msrs>> assert(kvm_buf_set_msrs(cpu) == 0);
+ *   - target/i386/kvm/kvm.c|4097| <<kvm_put_msrs>> return kvm_buf_set_msrs(cpu);
+ */
 static int kvm_buf_set_msrs(X86CPU *cpu)
 {
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
     if (ret < 0) {
         return ret;
@@ -3732,6 +4353,10 @@ static int kvm_buf_set_msrs(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2319| <<kvm_arch_init_vcpu>> kvm_init_msrs(cpu);
+ */
 static void kvm_init_msrs(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -3766,6 +4391,37 @@ static void kvm_init_msrs(X86CPU *cpu)
     assert(kvm_buf_set_msrs(cpu) == 0);
 }
 
+/*
+ * QEMU-7.1的例子:
+ *
+ * (gdb) bt
+ * #0  kvm_put_msrs (cpu=0x555556ae2360, level=2) at ../target/i386/kvm/kvm.c:3135
+ * #1  0x0000555555b1497a in kvm_arch_put_registers (cpu=0x555556ae2360, level=2) at ../target/i386/kvm/kvm.c:4559
+ * #2  0x0000555555d0de56 in do_kvm_cpu_synchronize_post_reset (cpu=0x555556ae2360, arg=...) at ../accel/kvm/kvm-all.c:2780
+ * #3  0x0000555555821f77 in process_queued_cpu_work (cpu=0x555556ae2360) at ../cpus-common.c:351
+ * #4  0x0000555555a717d4 in qemu_wait_io_event_common (cpu=0x555556ae2360) at ../softmmu/cpus.c:411
+ * #5  0x0000555555a71865 in qemu_wait_io_event (cpu=0x555556ae2360) at ../softmmu/cpus.c:435
+ * #6  0x0000555555d10fce in kvm_vcpu_thread_fn (arg=0x555556ae2360) at ../accel/kvm/kvm-accel-ops.c:54
+ * #7  0x0000555555eec4de in qemu_thread_start (args=0x555556af1620) at ../util/qemu-thread-posix.c:504
+ * #8  0x00007ffff55eeea5 in start_thread () at /lib64/libpthread.so.0
+ * #9  0x00007ffff53179fd in clone () at /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_put_msrs (cpu=0x555556ae2360, level=1) at ../target/i386/kvm/kvm.c:3135
+ * #1  0x0000555555b1497a in kvm_arch_put_registers (cpu=0x555556ae2360, level=1) at ../target/i386/kvm/kvm.c:4559
+ * #2  0x0000555555d0e12c in kvm_cpu_exec (cpu=0x555556ae2360) at ../accel/kvm/kvm-all.c:2884
+ * #3  0x0000555555d10faa in kvm_vcpu_thread_fn (arg=0x555556ae2360) at ../accel/kvm/kvm-accel-ops.c:49
+ * #4  0x0000555555eec4de in qemu_thread_start (args=0x555556af1620) at ../util/qemu-thread-posix.c:504
+ * #5  0x00007ffff55eeea5 in start_thread () at /lib64/libpthread.so.0
+ * #6  0x00007ffff53179fd in clone () at /lib64/libc.so.6
+ *
+ * called by:
+ *   - target/i386/kvm/kvm.c|5182| <<kvm_arch_put_registers>> ret = kvm_put_msrs(x86_cpu, level);
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
 static int kvm_put_msrs(X86CPU *cpu, int level)
 {
     CPUX86State *env = &cpu->env;
@@ -3870,33 +4526,145 @@ static int kvm_put_msrs(X86CPU *cpu, int level)
             kvm_msr_entry_add(cpu, MSR_KVM_POLL_CONTROL, env->poll_control_msr);
         }
 
+        /*
+         * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+	 * has_architectural_pmu_version = 0.
+	 * num_architectural_pmu_gp_counters = 0.
+	 * num_architectural_pmu_fixed_counters = 0.
+	 *
+	 * 2. 如果guest_vendor是Intel
+	 * 完全按照cpuid来算
+	 *
+	 * 3. 如果guest_vendor是AMD
+	 * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+	 *      如果支持, 根据0x80000022获取寄存器的数目.
+	 *      此外, 3个global的也支持!
+	 *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+	 * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+	 *      就是6个寄存器
+	 * 3.3. 默认只支持4个
+         */
+        /*
+	 * 在以下使用has_architectural_pmu_version:
+	 *   - target/i386/kvm/kvm.c|2162| <<kvm_x86_build_cpuid>> has_architectural_pmu_version = eax & 0xff;
+	 *   - target/i386/kvm/kvm.c|2163| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|2174| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4316| <<kvm_put_msrs>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|4317| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4334| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4820| <<kvm_get_msrs>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|4821| <<kvm_get_msrs>> if (has_architectural_pmu_version > 1) {
+	 */
         if (has_architectural_pmu_version > 0) {
             if (has_architectural_pmu_version > 1) {
+                /*
+		 * Intel SDM里面有这样一句话:
+		 * The event logic unit for a UMASK must be disabled by
+		 * setting IA32_PERFEVTSELx[bit 22] = 0, before writing to
+		 * IA32_PMCx.
+		 */
                 /* Stop the counter.  */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);
             }
 
             /* Set the counter values.  */
+	    /*
+	     * Intel SDM里面有这样一句话:
+	     * The event logic unit for a UMASK must be disabled by
+	     * setting IA32_PERFEVTSELx[bit 22] = 0, before writing to
+	     * IA32_PMCx.
+	     */
+            /*
+	     * 在以下使用num_architectural_pmu_fixed_counters:
+	     *   - target/i386/kvm/kvm.c|2175| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = edx & 0x1f;
+	     *   - target/i386/kvm/kvm.c|2177| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
+	     *   - target/i386/kvm/kvm.c|2178| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = MAX_FIXED_COUNTERS;
+	     *   - target/i386/kvm/kvm.c|4324| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+	     *   - target/i386/kvm/kvm.c|4827| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+	     */
             for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+                /*
+		 * 在以下使用CPUX86State->msr_fixed_counters[MAX_FIXED_COUNTERS]:
+		 *   - target/i386/machine.c|678| <<global>> VMSTATE_UINT64_ARRAY(env.msr_fixed_counters, X86CPU, MAX_FIXED_COUNTERS),
+		 *   - target/i386/kvm/kvm.c|4422| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, env->msr_fixed_counters[i]);
+		 *   - target/i386/kvm/kvm.c|5270| <<kvm_get_msrs>> env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;
+		 *   - target/i386/machine.c|655| <<pmu_enable_needed>> if (env->msr_fixed_counters[i]) {
+		 */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i,
                                   env->msr_fixed_counters[i]);
             }
+            /*
+	     * 在以下使用num_architectural_pmu_gp_counters:
+	     *   - target/i386/kvm/kvm.c|2164| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
+	     *   - target/i386/kvm/kvm.c|2170| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+	     *   - target/i386/kvm/kvm.c|2171| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+	     *   - target/i386/kvm/kvm.c|4328| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	     */
             for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+                /*
+		 * 在以下使用CPUX86State->msr_gp_counters[MAX_GP_COUNTERS]:
+		 *   - target/i386/machine.c|679| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_counters, X86CPU, MAX_GP_COUNTERS),
+		 *   - target/i386/kvm/kvm.c|4418| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, env->msr_gp_counters[i]);
+		 *   - target/i386/kvm/kvm.c|5249| <<kvm_get_msrs>> env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;
+		 *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+		 */
                 kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i,
                                   env->msr_gp_counters[i]);
+                /*
+		 * 在以下使用CPUX86State->msr_gp_evtsel[MAX_GP_COUNTERS]:
+		 *   - target/i386/machine.c|680| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_evtsel, X86CPU, MAX_GP_COUNTERS),
+		 *   - target/i386/kvm/kvm.c|4420| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, env->msr_gp_evtsel[i]);
+		 *   - target/i386/kvm/kvm.c|5252| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+		 *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+		 */
                 kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i,
                                   env->msr_gp_evtsel[i]);
             }
             if (has_architectural_pmu_version > 1) {
+                /*
+		 * 在以下使用CPUX86State->msr_global_status:
+		 *   - target/i386/machine.c|676| <<global>> VMSTATE_UINT64(env.msr_global_status, X86CPU),
+		 *   - target/i386/kvm/kvm.c|4424| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, env->msr_global_status);
+		 *   - target/i386/kvm/kvm.c|5240| <<kvm_get_msrs>> env->msr_global_status = msrs[i].data;
+		 *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+		 */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS,
                                   env->msr_global_status);
+                /*
+		 * 在以下使用CPUX86State->msr_global_ovf_ctrl:
+		 *   - target/i386/machine.c|677| <<global>> VMSTATE_UINT64(env.msr_global_ovf_ctrl, X86CPU),
+		 *   - target/i386/kvm/kvm.c|4426| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, env->msr_global_ovf_ctrl);
+		 *   - target/i386/kvm/kvm.c|5243| <<kvm_get_msrs>> env->msr_global_ovf_ctrl = msrs[i].data;
+		 *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+		 */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL,
                                   env->msr_global_ovf_ctrl);
 
+		/*
+		 * 在以下使用CPUX86State->msr_fixed_ctr_ctrl:
+		 *   - target/i386/machine.c|674| <<global>> VMSTATE_UINT64(env.msr_fixed_ctr_ctrl, X86CPU),
+		 *   - target/i386/kvm/kvm.c|4430| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, env->msr_fixed_ctr_ctrl);
+		 *   - target/i386/kvm/kvm.c|5234| <<kvm_get_msrs>> env->msr_fixed_ctr_ctrl = msrs[i].data;
+		 *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+		 */
+		/*
+		 * Intel SDM里面有这样一句话:
+		 * The event logic unit for a UMASK must be disabled by
+		 * setting IA32_PERFEVTSELx[bit 22] = 0, before writing to
+		 * IA32_PMCx.
+		 */
                 /* Now start the PMU.  */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL,
                                   env->msr_fixed_ctr_ctrl);
+                /*
+		 * 在以下使用CPUX86State->msr_global_ctrl:
+		 *   - target/i386/machine.c|675| <<global>> VMSTATE_UINT64(env.msr_global_ctrl, X86CPU),
+		 *   - target/i386/kvm/kvm.c|4432| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, env->msr_global_ctrl);
+		 *   - target/i386/kvm/kvm.c|5237| <<kvm_get_msrs>> env->msr_global_ctrl = msrs[i].data;
+		 *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+		 */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL,
                                   env->msr_global_ctrl);
             }
@@ -4094,6 +4862,11 @@ static int kvm_put_msrs(X86CPU *cpu, int level)
         }
     }
 
+    /*
+     * called by:
+     *   - target/i386/kvm/kvm.c|3766| <<kvm_init_msrs>> assert(kvm_buf_set_msrs(cpu) == 0);
+     *   - target/i386/kvm/kvm.c|4097| <<kvm_put_msrs>> return kvm_buf_set_msrs(cpu);
+     */
     return kvm_buf_set_msrs(cpu);
 }
 
@@ -4238,9 +5011,43 @@ static int kvm_get_sregs2(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|5243| <<kvm_arch_get_registers>> ret = kvm_get_msrs(cpu);
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
 static int kvm_get_msrs(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
     int ret, i;
     uint64_t mtrr_top_bits;
@@ -4344,6 +5151,35 @@ static int kvm_get_msrs(X86CPU *cpu)
     if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_POLL_CONTROL)) {
         kvm_msr_entry_add(cpu, MSR_KVM_POLL_CONTROL, 1);
     }
+    /*
+     * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+     * has_architectural_pmu_version = 0.
+     * num_architectural_pmu_gp_counters = 0.
+     * num_architectural_pmu_fixed_counters = 0.
+     *
+     * 2. 如果guest_vendor是Intel
+     * 完全按照cpuid来算
+     *
+     * 3. 如果guest_vendor是AMD
+     * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+     *      如果支持, 根据0x80000022获取寄存器的数目.
+     *      此外, 3个global的也支持!
+     *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+     * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+     *      就是6个寄存器
+     * 3.3. 默认只支持4个
+     */
+    /*
+     * 在以下使用has_architectural_pmu_version:
+     *   - target/i386/kvm/kvm.c|2162| <<kvm_x86_build_cpuid>> has_architectural_pmu_version = eax & 0xff;
+     *   - target/i386/kvm/kvm.c|2163| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 0) {
+     *   - target/i386/kvm/kvm.c|2174| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 1) {
+     *   - target/i386/kvm/kvm.c|4316| <<kvm_put_msrs>> if (has_architectural_pmu_version > 0) {
+     *   - target/i386/kvm/kvm.c|4317| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+     *   - target/i386/kvm/kvm.c|4334| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+     *   - target/i386/kvm/kvm.c|4820| <<kvm_get_msrs>> if (has_architectural_pmu_version > 0) {
+     *   - target/i386/kvm/kvm.c|4821| <<kvm_get_msrs>> if (has_architectural_pmu_version > 1) {
+     */
     if (has_architectural_pmu_version > 0) {
         if (has_architectural_pmu_version > 1) {
             kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);
@@ -4351,9 +5187,25 @@ static int kvm_get_msrs(X86CPU *cpu)
             kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);
             kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);
         }
+        /*
+	 * 在以下使用num_architectural_pmu_fixed_counters:
+	 *   - target/i386/kvm/kvm.c|2175| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = edx & 0x1f;
+	 *   - target/i386/kvm/kvm.c|2177| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
+	 *   - target/i386/kvm/kvm.c|2178| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = MAX_FIXED_COUNTERS;
+	 *   - target/i386/kvm/kvm.c|4324| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+	 *   - target/i386/kvm/kvm.c|4827| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+	 */
         for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
             kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);
         }
+        /*
+	 * 在以下使用num_architectural_pmu_gp_counters:
+	 *   - target/i386/kvm/kvm.c|2164| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
+	 *   - target/i386/kvm/kvm.c|2170| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+	 *   - target/i386/kvm/kvm.c|2171| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+	 *   - target/i386/kvm/kvm.c|4328| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	 *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	 */
         for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
             kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);
             kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);
@@ -4479,6 +5331,35 @@ static int kvm_get_msrs(X86CPU *cpu)
         }
     }
 
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *          
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     *
+     * X86CPU *cpu (ArchCPU):
+     * -> struct kvm_msrs *kvm_msr_buf;
+     */
     ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
     if (ret < 0) {
         return ret;
@@ -4651,24 +5532,73 @@ static int kvm_get_msrs(X86CPU *cpu)
             break;
         }
         case MSR_CORE_PERF_FIXED_CTR_CTRL:
+            /*
+	     * 在以下使用CPUX86State->msr_fixed_ctr_ctrl:
+	     *   - target/i386/machine.c|674| <<global>> VMSTATE_UINT64(env.msr_fixed_ctr_ctrl, X86CPU),
+	     *   - target/i386/kvm/kvm.c|4430| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, env->msr_fixed_ctr_ctrl);
+	     *   - target/i386/kvm/kvm.c|5234| <<kvm_get_msrs>> env->msr_fixed_ctr_ctrl = msrs[i].data;
+	     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+	     */
             env->msr_fixed_ctr_ctrl = msrs[i].data;
             break;
         case MSR_CORE_PERF_GLOBAL_CTRL:
+            /*
+	     * 在以下使用CPUX86State->msr_global_ctrl:
+	     *   - target/i386/machine.c|675| <<global>> VMSTATE_UINT64(env.msr_global_ctrl, X86CPU),
+	     *   - target/i386/kvm/kvm.c|4432| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, env->msr_global_ctrl);
+	     *   - target/i386/kvm/kvm.c|5237| <<kvm_get_msrs>> env->msr_global_ctrl = msrs[i].data;
+	     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+	     */
             env->msr_global_ctrl = msrs[i].data;
             break;
         case MSR_CORE_PERF_GLOBAL_STATUS:
+            /*
+	     * 在以下使用CPUX86State->msr_global_status:
+	     *   - target/i386/machine.c|676| <<global>> VMSTATE_UINT64(env.msr_global_status, X86CPU),
+	     *   - target/i386/kvm/kvm.c|4424| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, env->msr_global_status);
+	     *   - target/i386/kvm/kvm.c|5240| <<kvm_get_msrs>> env->msr_global_status = msrs[i].data;
+	     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+	     */
             env->msr_global_status = msrs[i].data;
             break;
         case MSR_CORE_PERF_GLOBAL_OVF_CTRL:
+            /*
+	     * 在以下使用CPUX86State->msr_global_ovf_ctrl:
+	     *   - target/i386/machine.c|677| <<global>> VMSTATE_UINT64(env.msr_global_ovf_ctrl, X86CPU),
+	     *   - target/i386/kvm/kvm.c|4426| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, env->msr_global_ovf_ctrl);
+	     *   - target/i386/kvm/kvm.c|5243| <<kvm_get_msrs>> env->msr_global_ovf_ctrl = msrs[i].data;
+	     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+	     */
             env->msr_global_ovf_ctrl = msrs[i].data;
             break;
         case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:
+            /*
+	     * 在以下使用CPUX86State->msr_fixed_counters[MAX_FIXED_COUNTERS]:
+	     *   - target/i386/machine.c|678| <<global>> VMSTATE_UINT64_ARRAY(env.msr_fixed_counters, X86CPU, MAX_FIXED_COUNTERS),
+	     *   - target/i386/kvm/kvm.c|4422| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, env->msr_fixed_counters[i]);
+	     *   - target/i386/kvm/kvm.c|5270| <<kvm_get_msrs>> env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;
+	     *   - target/i386/machine.c|655| <<pmu_enable_needed>> if (env->msr_fixed_counters[i]) {
+	     */
             env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;
             break;
         case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:
+            /*
+	     * 在以下使用CPUX86State->msr_gp_counters[MAX_GP_COUNTERS]:
+	     *   - target/i386/machine.c|679| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_counters, X86CPU, MAX_GP_COUNTERS),
+	     *   - target/i386/kvm/kvm.c|4418| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, env->msr_gp_counters[i]);
+	     *   - target/i386/kvm/kvm.c|5249| <<kvm_get_msrs>> env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;
+	     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+	     */
             env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;
             break;
         case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:
+            /*
+	     * 在以下使用CPUX86State->msr_gp_evtsel[MAX_GP_COUNTERS]:
+	     *   - target/i386/machine.c|680| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_evtsel, X86CPU, MAX_GP_COUNTERS),
+	     *   - target/i386/kvm/kvm.c|4420| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, env->msr_gp_evtsel[i]);
+	     *   - target/i386/kvm/kvm.c|5252| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+	     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+	     */
             env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
             break;
         case HV_X64_MSR_HYPERCALL:
@@ -5117,6 +6047,12 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2814| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE);
+ *   - accel/kvm/kvm-all.c|2831| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);
+ *   - accel/kvm/kvm-all.c|3023| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);
+ */
 int kvm_arch_put_registers(CPUState *cpu, int level)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -5205,6 +6141,10 @@ int kvm_arch_put_registers(CPUState *cpu, int level)
     return 0;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2769| <<do_kvm_cpu_synchronize_state>> int ret = kvm_arch_get_registers(cpu);
+ */
 int kvm_arch_get_registers(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -5360,6 +6300,10 @@ void kvm_arch_pre_run(CPUState *cpu, struct kvm_run *run)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|5388| <<kvm_arch_post_run>> kvm_rate_limit_on_bus_lock();
+ */
 static void kvm_rate_limit_on_bus_lock(void)
 {
     uint64_t delay_ns = ratelimit_calculate_delay(&bus_lock_ratelimit_ctrl, 1);
@@ -5369,6 +6313,10 @@ static void kvm_rate_limit_on_bus_lock(void)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|3027| <<kvm_cpu_exec>> attrs = kvm_arch_post_run(cpu, run);
+ */
 MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -5414,6 +6362,10 @@ MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
     return cpu_get_mem_attrs(env);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2986| <<kvm_cpu_exec>> if (kvm_arch_process_async_events(cpu)) {
+ */
 int kvm_arch_process_async_events(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -5475,6 +6427,10 @@ int kvm_arch_process_async_events(CPUState *cs)
     return cs->halted;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|5890| <<kvm_arch_handle_exit(KVM_EXIT_HLT)>> ret = kvm_handle_halt(cpu);
+ */
 static int kvm_handle_halt(X86CPU *cpu)
 {
     CPUState *cs = CPU(cpu);
@@ -5875,6 +6831,11 @@ static int kvm_handle_hypercall(struct kvm_run *run)
 
 #define VMX_INVALID_GUEST_STATE 0x80000021
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|3138| <<kvm_cpu_exec>> ret = kvm_arch_handle_exit(cpu, run);
+ *   - accel/kvm/kvm-all.c|3156| <<kvm_cpu_exec>> ret = kvm_arch_handle_exit(cpu, run);
+ */
 int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -6387,6 +7348,10 @@ static void kvm_arch_set_xen_evtchn_max_pirq(Object *obj, Visitor *v,
     s->xen_evtchn_max_pirq = value;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|3882| <<kvm_accel_class_init>> kvm_arch_accel_class_init(oc);
+ */
 void kvm_arch_accel_class_init(ObjectClass *oc)
 {
     object_class_property_add_enum(oc, "notify-vmexit", "NotifyVMexitOption",
diff --git a/target/i386/kvm/vmsr_energy.c b/target/i386/kvm/vmsr_energy.c
index 7e064c5ae..7bace5304 100644
--- a/target/i386/kvm/vmsr_energy.c
+++ b/target/i386/kvm/vmsr_energy.c
@@ -20,6 +20,57 @@
 #include "cpu.h"
 #include "host-cpu.h"
 
+/*
+ * commit 0418f90809aea5b375c859e744c8e8610e9be446
+ * Author: Anthony Harivel <aharivel@redhat.com>
+ * Date:   Wed May 22 17:34:52 2024 +0200
+ *
+ * Add support for RAPL MSRs in KVM/Qemu
+ *
+ * Starting with the "Sandy Bridge" generation, Intel CPUs provide a RAPL
+ * interface (Running Average Power Limit) for advertising the accumulated
+ * energy consumption of various power domains (e.g. CPU packages, DRAM,
+ * etc.).
+ *
+ * The consumption is reported via MSRs (model specific registers) like
+ * MSR_PKG_ENERGY_STATUS for the CPU package power domain. These MSRs are
+ * 64 bits registers that represent the accumulated energy consumption in
+ * micro Joules. They are updated by microcode every ~1ms.
+ *
+ * For now, KVM always returns 0 when the guest requests the value of
+ * these MSRs. Use the KVM MSR filtering mechanism to allow QEMU handle
+ * these MSRs dynamically in userspace.
+ *
+ * To limit the amount of system calls for every MSR call, create a new
+ * thread in QEMU that updates the "virtual" MSR values asynchronously.
+ *
+ * Each vCPU has its own vMSR to reflect the independence of vCPUs. The
+ * thread updates the vMSR values with the ratio of energy consumed of
+ * the whole physical CPU package the vCPU thread runs on and the
+ * thread's utime and stime values.
+ *
+ * All other non-vCPU threads are also taken into account. Their energy
+ * consumption is evenly distributed among all vCPUs threads running on
+ * the same physical CPU package.
+ *
+ * To overcome the problem that reading the RAPL MSR requires priviliged
+ * access, a socket communication between QEMU and the qemu-vmsr-helper is
+ * mandatory. You can specified the socket path in the parameter.
+ *
+ * This feature is activated with -accel kvm,rapl=true,path=/path/sock.sock
+ *
+ * Actual limitation:
+ * - Works only on Intel host CPU because AMD CPUs are using different MSR
+ *   adresses.
+ *
+ * - Only the Package Power-Plane (MSR_PKG_ENERGY_STATUS) is reported at
+ *   the moment.
+ *
+ * Signed-off-by: Anthony Harivel <aharivel@redhat.com>
+ * Link: https://lore.kernel.org/r/20240522153453.1230389-4-aharivel@redhat.com
+ * Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
+ */
+
 char *vmsr_compute_default_paths(void)
 {
     g_autofree char *state = qemu_get_local_state_dir();
diff --git a/target/i386/machine.c b/target/i386/machine.c
index 39f8294f2..46256f7a5 100644
--- a/target/i386/machine.c
+++ b/target/i386/machine.c
@@ -647,15 +647,60 @@ static bool pmu_enable_needed(void *opaque)
     CPUX86State *env = &cpu->env;
     int i;
 
+    /*
+     * 在以下使用CPUX86State->msr_fixed_ctr_ctrl:
+     *   - target/i386/machine.c|674| <<global>> VMSTATE_UINT64(env.msr_fixed_ctr_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4430| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, env->msr_fixed_ctr_ctrl);
+     *   - target/i386/kvm/kvm.c|5234| <<kvm_get_msrs>> env->msr_fixed_ctr_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+     *
+     * 在以下使用CPUX86State->msr_global_ctrl:
+     *   - target/i386/machine.c|675| <<global>> VMSTATE_UINT64(env.msr_global_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4432| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, env->msr_global_ctrl);
+     *   - target/i386/kvm/kvm.c|5237| <<kvm_get_msrs>> env->msr_global_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+     *
+     * 在以下使用CPUX86State->msr_global_status:
+     *   - target/i386/machine.c|676| <<global>> VMSTATE_UINT64(env.msr_global_status, X86CPU),
+     *   - target/i386/kvm/kvm.c|4424| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, env->msr_global_status);
+     *   - target/i386/kvm/kvm.c|5240| <<kvm_get_msrs>> env->msr_global_status = msrs[i].data;
+     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+     *
+     * 在以下使用CPUX86State->msr_global_ovf_ctrl:
+     *   - target/i386/machine.c|677| <<global>> VMSTATE_UINT64(env.msr_global_ovf_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4426| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, env->msr_global_ovf_ctrl);
+     *   - target/i386/kvm/kvm.c|5243| <<kvm_get_msrs>> env->msr_global_ovf_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+     */
     if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
         env->msr_global_status || env->msr_global_ovf_ctrl) {
         return true;
     }
+    /*
+     * 在以下使用CPUX86State->msr_fixed_counters[MAX_FIXED_COUNTERS]:
+     *   - target/i386/machine.c|678| <<global>> VMSTATE_UINT64_ARRAY(env.msr_fixed_counters, X86CPU, MAX_FIXED_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4422| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, env->msr_fixed_counters[i]);
+     *   - target/i386/kvm/kvm.c|5270| <<kvm_get_msrs>> env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;
+     *   - target/i386/machine.c|655| <<pmu_enable_needed>> if (env->msr_fixed_counters[i]) {
+     */
     for (i = 0; i < MAX_FIXED_COUNTERS; i++) {
         if (env->msr_fixed_counters[i]) {
             return true;
         }
     }
+    /*
+     * 在以下使用CPUX86State->msr_gp_counters[MAX_GP_COUNTERS]:
+     *   - target/i386/machine.c|679| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_counters, X86CPU, MAX_GP_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4418| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, env->msr_gp_counters[i]);
+     *   - target/i386/kvm/kvm.c|5249| <<kvm_get_msrs>> env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;
+     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+     *
+     * 在以下使用CPUX86State->msr_gp_evtsel[MAX_GP_COUNTERS]:
+     *   - target/i386/machine.c|680| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_evtsel, X86CPU, MAX_GP_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4420| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, env->msr_gp_evtsel[i]);
+     *   - target/i386/kvm/kvm.c|5252| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+     */
     for (i = 0; i < MAX_GP_COUNTERS; i++) {
         if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
             return true;
diff --git a/util/oslib-posix.c b/util/oslib-posix.c
index 11b35e48f..6c9a96d2e 100644
--- a/util/oslib-posix.c
+++ b/util/oslib-posix.c
@@ -657,6 +657,13 @@ char *qemu_get_pid_name(pid_t pid)
 }
 
 
+/*
+ * called by:
+ *   - system/async-teardown.c|88| <<new_stack_for_clone>> stack_ptr = qemu_alloc_stack(&stack_size);
+ *   - util/coroutine-sigaltstack.c|172| <<qemu_coroutine_new>> co->stack = qemu_alloc_stack(&co->stack_size);
+ *   - util/coroutine-ucontext.c|202| <<qemu_coroutine_new>> co->stack = qemu_alloc_stack(&co->stack_size);
+ *   - util/coroutine-ucontext.c|205| <<qemu_coroutine_new>> co->unsafe_stack = qemu_alloc_stack(&co->unsafe_stack_size);
+ */
 void *qemu_alloc_stack(size_t *sz)
 {
     void *ptr;
-- 
2.39.3 (Apple Git-146)

