From ce11f68ac0d7a83b68d30c5a4673a8fafd832544 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 9 Dec 2024 09:36:47 -0800
Subject: [PATCH 1/1] qemu for v9.1.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-accel-ops.c                    |   7 +
 accel/kvm/kvm-all.c                          | 118 +++
 block.c                                      | 130 +++
 block/file-posix.c                           |  50 +
 block/io.c                                   |  26 +
 block/mirror.c                               |  77 ++
 blockdev.c                                   |  55 ++
 dump/dump.c                                  |   8 +
 hw/acpi/aml-build.c                          |   5 +
 hw/acpi/cpu.c                                | 178 ++++
 hw/acpi/memory_hotplug.c                     |   5 +
 hw/acpi/pcihp.c                              |  18 +
 hw/acpi/piix4.c                              |  92 ++
 hw/arm/virt-acpi-build.c                     |   5 +
 hw/block/virtio-blk.c                        |  41 +
 hw/core/machine-smp.c                        |   7 +
 hw/core/machine.c                            |   9 +
 hw/core/nmi.c                                |  12 +
 hw/core/qdev.c                               |   3 +
 hw/display/virtio-dmabuf.c                   |  13 +
 hw/i386/pc.c                                 |   5 +
 hw/i386/pc_piix.c                            |  10 +
 hw/i386/x86-common.c                         |   6 +
 hw/net/virtio-net.c                          |  36 +
 hw/nvram/fw_cfg.c                            |  59 ++
 hw/pci/pci_bridge.c                          |   6 +
 hw/pci/pcie.c                                |  11 +
 hw/pci/pcie_aer.c                            |   7 +
 hw/pci/pcie_port.c                           |   7 +
 hw/scsi/megasas.c                            |   6 +
 hw/scsi/scsi-bus.c                           |   6 +
 hw/scsi/scsi-disk.c                          |  26 +
 hw/scsi/scsi-generic.c                       |   6 +
 hw/scsi/vhost-scsi.c                         |  13 +
 hw/scsi/virtio-scsi.c                        |   6 +
 hw/vfio/container.c                          |   4 +
 hw/vfio/pci.c                                |  13 +
 hw/virtio/vhost-backend.c                    | 158 +++
 hw/virtio/vhost.c                            | 668 +++++++++++++
 hw/virtio/virtio-pci.c                       |   9 +
 hw/virtio/virtio.c                           |  21 +
 include/exec/ram_addr.h                      |  10 +
 include/hw/acpi/pcihp.h                      |  21 +
 include/hw/block/block.h                     |  32 +
 include/hw/core/cpu.h                        |  44 +
 include/hw/virtio/vhost.h                    |  16 +
 include/hw/virtio/virtio.h                   |  33 +
 include/net/net.h                            |   8 +
 include/standard-headers/linux/vhost_types.h |  24 +
 include/sysemu/accel-ops.h                   |  27 +
 include/sysemu/kvm.h                         |  28 +
 include/sysemu/kvm_int.h                     |  16 +
 migration/migration.c                        |  94 ++
 migration/migration.h                        |  14 +
 migration/options.c                          |  29 +
 migration/ram.c                              | 104 ++
 net/tap-linux.c                              |   4 +
 net/tap.c                                    |  10 +
 qom/object.c                                 |  26 +
 system/cpus.c                                | 183 ++++
 system/globals.c                             |   7 +
 system/memory.c                              |  46 +
 system/runstate.c                            |  35 +
 target/arm/cpu.c                             |   9 +
 target/arm/cpu.h                             |  21 +
 target/i386/cpu.c                            | 925 +++++++++++++++++
 target/i386/cpu.h                            | 142 +++
 target/i386/host-cpu.c                       |  25 +
 target/i386/kvm/kvm-cpu.c                    |  50 +
 target/i386/kvm/kvm.c                        | 980 +++++++++++++++++++
 target/i386/kvm/vmsr_energy.c                |  51 +
 target/i386/machine.c                        |  45 +
 target/i386/tcg/sysemu/excp_helper.c         |   5 +
 util/oslib-posix.c                           |   7 +
 util/qemu-coroutine.c                        | 337 +++++++
 75 files changed, 5350 insertions(+)

diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index c239dfc87..ea6884b3e 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -26,6 +26,10 @@
 #include <linux/kvm.h>
 #include "kvm-cpus.h"
 
+/*
+ * 在以下使用kvm_vcpu_thread_fn():
+ *   - accel/kvm/kvm-accel-ops.c|71| <<kvm_start_vcpu_thread>> qemu_thread_create(cpu->thread, thread_name, kvm_vcpu_thread_fn, cpu, QEMU_THREAD_JOINABLE);
+ */
 static void *kvm_vcpu_thread_fn(void *arg)
 {
     CPUState *cpu = arg;
@@ -38,6 +42,9 @@ static void *kvm_vcpu_thread_fn(void *arg)
     cpu->thread_id = qemu_get_thread_id();
     current_cpu = cpu;
 
+    /*
+     * 只在此处调用
+     */
     r = kvm_init_vcpu(cpu, &error_fatal);
     kvm_init_cpu_signals(cpu);
 
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 75d11a07b..d58da43b0 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -105,6 +105,13 @@ static const KVMCapabilityInfo kvm_required_capabilites[] = {
     KVM_CAP_LAST_INFO
 };
 
+/*
+ * 在以下使用kvm_irqchip_change_notifiers:
+ *   - accel/kvm/kvm-all.c|108| <<global>> static NotifierList kvm_irqchip_change_notifiers =
+ *   - accel/kvm/kvm-all.c|109| <<global>> NOTIFIER_LIST_INITIALIZER(kvm_irqchip_change_notifiers);
+ *   - accel/kvm/kvm-all.c|2041| <<kvm_irqchip_add_change_notifier>> notifier_list_add(&kvm_irqchip_change_notifiers, n);
+ *   - accel/kvm/kvm-all.c|2051| <<kvm_irqchip_change_notify>> notifier_list_notify(&kvm_irqchip_change_notifiers, NULL);
+ */
 static NotifierList kvm_irqchip_change_notifiers =
     NOTIFIER_LIST_INITIALIZER(kvm_irqchip_change_notifiers);
 
@@ -190,6 +197,10 @@ unsigned int kvm_get_free_memslots(void)
     return s->nr_slots - used_slots;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|218| <<kvm_alloc_slot>> KVMSlot *slot = kvm_get_free_slot(kml);
+ */
 /* Called with KVMMemoryListener.slots_lock held */
 static KVMSlot *kvm_get_free_slot(KVMMemoryListener *kml)
 {
@@ -198,6 +209,16 @@ static KVMSlot *kvm_get_free_slot(KVMMemoryListener *kml)
 
     for (i = 0; i < s->nr_slots; i++) {
         if (kml->slots[i].memory_size == 0) {
+            /*
+	     * typedef struct KVMMemoryListener {
+	     *     MemoryListener listener;
+	     *     KVMSlot *slots;
+	     *     unsigned int nr_used_slots;
+	     *     int as_id;
+	     *     QSIMPLEQ_HEAD(, KVMMemoryUpdate) transaction_add;
+	     *     QSIMPLEQ_HEAD(, KVMMemoryUpdate) transaction_del;
+	     * } KVMMemoryListener;
+	     */
             return &kml->slots[i];
         }
     }
@@ -205,6 +226,10 @@ static KVMSlot *kvm_get_free_slot(KVMMemoryListener *kml)
     return NULL;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1511| <<kvm_set_phys_mem>> mem = kvm_alloc_slot(kml);
+ */
 /* Called with KVMMemoryListener.slots_lock held */
 static KVMSlot *kvm_alloc_slot(KVMMemoryListener *kml)
 {
@@ -218,6 +243,13 @@ static KVMSlot *kvm_alloc_slot(KVMMemoryListener *kml)
     abort();
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|604| <<kvm_section_update_flags>> mem = kvm_lookup_matching_slot(kml, start_addr, slot_size);
+ *   - accel/kvm/kvm-all.c|944| <<kvm_physical_sync_dirty_bitmap>> mem = kvm_lookup_matching_slot(kml, start_addr, slot_size);
+ *   - accel/kvm/kvm-all.c|1473| <<kvm_set_phys_mem>> mem = kvm_lookup_matching_slot(kml, start_addr, slot_size);
+ *   - accel/kvm/kvm-all.c|3727| <<kvm_accel_has_memory>> return NULL != kvm_lookup_matching_slot(kvm->as[i].ml, start_addr, size);
+ */
 static KVMSlot *kvm_lookup_matching_slot(KVMMemoryListener *kml,
                                          hwaddr start_addr,
                                          hwaddr size)
@@ -456,6 +488,10 @@ void kvm_destroy_vcpu(CPUState *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|45| <<kvm_vcpu_thread_fn>> r = kvm_init_vcpu(cpu, &error_fatal);
+ */
 int kvm_init_vcpu(CPUState *cpu, Error **errp)
 {
     KVMState *s = kvm_state;
@@ -507,6 +543,16 @@ int kvm_init_vcpu(CPUState *cpu, Error **errp)
         }
     }
 
+    /*
+     * 支持的架构:
+     *   - target/arm/kvm.c|1863| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/i386/kvm/kvm.c|2255| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/loongarch/kvm/kvm.c|666| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/mips/kvm.c|64| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/ppc/kvm.c|480| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/riscv/kvm/kvm-cpu.c|1358| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     *   - target/s390x/kvm/kvm.c|410| <<kvm_arch_init_vcpu>> int kvm_arch_init_vcpu(CPUState *cs)
+     */
     ret = kvm_arch_init_vcpu(cpu);
     if (ret < 0) {
         error_setg_errno(errp, -ret,
@@ -1180,6 +1226,35 @@ int kvm_check_extension(KVMState *s, unsigned int extension)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1584| <<kvm_dirty_ring_init>> ret = kvm_vm_check_extension(s, capability);
+ *   - accel/kvm/kvm-all.c|1587| <<kvm_dirty_ring_init>> ret = kvm_vm_check_extension(s, capability);
+ *   - accel/kvm/kvm-all.c|1610| <<kvm_dirty_ring_init>> ret = kvm_vm_check_extension(s, KVM_CAP_DIRTY_LOG_RING_WITH_BITMAP);
+ *   - accel/kvm/kvm-all.c|2373| <<kvm_recommended_vcpus>> int ret = kvm_vm_check_extension(s, KVM_CAP_NR_VCPUS);
+ *   - accel/kvm/kvm-all.c|2681| <<kvm_init>> s->sync_mmu = !!kvm_vm_check_extension(kvm_state, KVM_CAP_SYNC_MMU);
+ *   - target/arm/kvm.c|587| <<kvm_arch_init>> sizes = kvm_vm_check_extension(s, KVM_CAP_ARM_SUPPORTED_BLOCK_SIZES);
+ *   - target/i386/kvm/kvm.c|336| <<kvm_has_smm>> return kvm_vm_check_extension(kvm_state, KVM_CAP_X86_SMM);
+ *   - target/i386/kvm/kvm.c|3669| <<kvm_arch_init>> if (kvm_vm_check_extension(s, KVM_CAP_X86_USER_SPACE_MSR)) {
+ *   - target/i386/kvm/kvm.c|6757| <<__kvm_enable_sgx_provisioning>> if (!kvm_vm_check_extension(s, KVM_CAP_SGX_ATTRIBUTE)) {
+ *   - target/ppc/kvm.c|113| <<kvmppc_is_pr>> return kvm_vm_check_extension(ks, KVM_CAP_PPC_GET_PVINFO) != 0;
+ *   - target/ppc/kvm.c|130| <<kvm_arch_init>> cap_ppc_smt_possible = kvm_vm_check_extension(s, KVM_CAP_PPC_SMT_POSSIBLE);
+ *   - target/ppc/kvm.c|134| <<kvm_arch_init>> cap_spapr_vfio = kvm_vm_check_extension(s, KVM_CAP_SPAPR_TCE_VFIO);
+ *   - target/ppc/kvm.c|143| <<kvm_arch_init>> cap_htab_fd = kvm_vm_check_extension(s, KVM_CAP_PPC_HTAB_FD);
+ *   - target/ppc/kvm.c|145| <<kvm_arch_init>> cap_ppc_smt = kvm_vm_check_extension(s, KVM_CAP_PPC_SMT);
+ *   - target/ppc/kvm.c|146| <<kvm_arch_init>> cap_htm = kvm_vm_check_extension(s, KVM_CAP_PPC_HTM);
+ *   - target/ppc/kvm.c|147| <<kvm_arch_init>> cap_mmu_radix = kvm_vm_check_extension(s, KVM_CAP_PPC_MMU_RADIX);
+ *   - target/ppc/kvm.c|148| <<kvm_arch_init>> cap_mmu_hash_v3 = kvm_vm_check_extension(s, KVM_CAP_PPC_MMU_HASH_V3);
+ *   - target/ppc/kvm.c|149| <<kvm_arch_init>> cap_xive = kvm_vm_check_extension(s, KVM_CAP_PPC_IRQ_XIVE);
+ *   - target/ppc/kvm.c|150| <<kvm_arch_init>> cap_resize_hpt = kvm_vm_check_extension(s, KVM_CAP_SPAPR_RESIZE_HPT);
+ *   - target/ppc/kvm.c|152| <<kvm_arch_init>> cap_ppc_nested_kvm_hv = kvm_vm_check_extension(s, KVM_CAP_PPC_NESTED_HV);
+ *   - target/ppc/kvm.c|154| <<kvm_arch_init>> cap_fwnmi = kvm_vm_check_extension(s, KVM_CAP_PPC_FWNMI);
+ *   - target/ppc/kvm.c|169| <<kvm_arch_init>> cap_rpt_invalidate = kvm_vm_check_extension(s, KVM_CAP_PPC_RPT_INVALIDATE);
+ *   - target/ppc/kvm.c|170| <<kvm_arch_init>> cap_ail_mode_3 = kvm_vm_check_extension(s, KVM_CAP_PPC_AIL_MODE_3);
+ *   - target/ppc/kvm.c|1979| <<kvmppc_get_pvinfo>> if (kvm_vm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
+ *   - target/ppc/kvm.c|2301| <<kvmppc_reset_htab>> if (kvm_vm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {
+ *   - target/ppc/kvm.c|2510| <<kvmppc_get_cpu_characteristics>> ret = kvm_vm_check_extension(s, KVM_CAP_PPC_GET_CPU_CHAR);
+ */
 int kvm_vm_check_extension(KVMState *s, unsigned int extension)
 {
     int ret;
@@ -1369,6 +1444,11 @@ int kvm_set_memory_attributes_shared(hwaddr start, uint64_t size)
     return kvm_set_memory_attributes(start, size, 0);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1731| <<kvm_region_commit(处理QSIMPLEQ_EMPTY(&kml->transaction_del))>> kvm_set_phys_mem(kml, &u1->section, false);
+ *   - accel/kvm/kvm-all.c|1741| <<kvm_region_commit(处理QSIMPLEQ_EMPTY(&kml->transaction_del))>> kvm_set_phys_mem(kml, &u1->section, true);
+ */
 /* Called with KVMMemoryListener.slots_lock held */
 static void kvm_set_phys_mem(KVMMemoryListener *kml,
                              MemoryRegionSection *section, bool add)
@@ -2763,6 +2843,10 @@ void kvm_flush_coalesced_mmio_buffer(void)
     s->coalesced_flush_in_progress = false;
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-all.c|2804| <<kvm_cpu_synchronize_state>> run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
@@ -2777,6 +2861,24 @@ static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_state:
+ *   - accel/hvf/hvf-accel-ops.c|583| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+ *   - accel/kvm/kvm-accel-ops.c|108| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - system/cpus.c|171| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+ *   - system/cpus.c|172| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+ *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+ *
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|108| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - accel/kvm/kvm-all.c|3156| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+ *   - target/i386/kvm/kvm.c|6348| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6367| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6385| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6390| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6916| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+ */
 void kvm_cpu_synchronize_state(CPUState *cpu)
 {
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
@@ -2801,6 +2903,10 @@ void kvm_cpu_synchronize_post_reset(CPUState *cpu)
     run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-all.c|2924| <<kvm_cpu_synchronize_post_init>> run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
 {
     int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);
@@ -2812,6 +2918,18 @@ static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
     cpu->vcpu_dirty = false;
 }
 
+/*
+ * 在以下使用AccelOpsClass->synchronize_post_init:
+ *   - accel/hvf/hvf-accel-ops.c|582| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+ *   - accel/kvm/kvm-accel-ops.c|107| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ *   - system/cpus.c|185| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+ *   - system/cpus.c|186| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|91| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+ *   - target/i386/whpx/whpx-accel-ops.c|94| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+ *
+ * 在以下使用kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-accel-ops.c|107| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ */
 void kvm_cpu_synchronize_post_init(CPUState *cpu)
 {
     if (!kvm_state->guest_state_protected) {
diff --git a/block.c b/block.c
index c317de9ea..cb54242b8 100644
--- a/block.c
+++ b/block.c
@@ -68,6 +68,11 @@
 
 #define NOT_DONE 0x7fffffff /* used while emulated sync operation in progress */
 
+/*
+ * Managing the New Block Layer
+ * https://events.static.linuxfound.org/sites/events/files/slides/talk_11.pdf
+ */
+
 /* Protected by BQL */
 static QTAILQ_HEAD(, BlockDriverState) graph_bdrv_states =
     QTAILQ_HEAD_INITIALIZER(graph_bdrv_states);
@@ -2378,6 +2383,31 @@ TransactionActionDrv bdrv_drv_set_perm_drv = {
     .commit = bdrv_drv_set_perm_commit,
 };
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 /*
  * After calling this function, the transaction @tran may only be completed
  * while holding a reader lock for the graph.
@@ -2488,6 +2518,31 @@ bdrv_replace_child_tran(BdrvChild *child, BlockDriverState *new_bs,
     /* old_bs reference is transparently moved from @child to @s */
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 /*
  * Refresh permissions in @bs subtree. The function is intended to be called
  * after some graph modification that was done without permission update.
@@ -2567,6 +2622,31 @@ bdrv_node_refresh_perm(BlockDriverState *bs, BlockReopenQueue *q,
     return 0;
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 /*
  * @list is a product of bdrv_topological_dfs() (may be called several times) -
  * a topologically sorted subgraph.
@@ -5306,6 +5386,31 @@ static void GRAPH_WRLOCK bdrv_remove_child(BdrvChild *child, Transaction *tran)
     tran_add(tran, &bdrv_remove_child_drv, child);
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 /*
  * Both @from and @to (if non-NULL) must be drained. @to must be kept drained
  * until the transaction is completed.
@@ -5347,6 +5452,31 @@ bdrv_replace_node_noperm(BlockDriverState *from,
     return 0;
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 /*
  * Switch all parents of @from to point to @to instead. @from and @to must be in
  * the same AioContext and both must be drained.
diff --git a/block/file-posix.c b/block/file-posix.c
index ff928b5e8..ec168f9ab 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -959,6 +959,31 @@ static int raw_check_lock_bytes(int fd, uint64_t perm, uint64_t shared_perm,
     return 0;
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 static int raw_handle_perm_lock(BlockDriverState *bs,
                                 RawPermLockOp op,
                                 uint64_t new_perm, uint64_t new_shared,
@@ -3747,6 +3772,31 @@ static QemuOptsList raw_create_opts = {
     }
 };
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ */
 static int raw_check_perm(BlockDriverState *bs, uint64_t perm, uint64_t shared,
                           Error **errp)
 {
diff --git a/block/io.c b/block/io.c
index 301514c88..42c6eb464 100644
--- a/block/io.c
+++ b/block/io.c
@@ -507,6 +507,19 @@ void bdrv_drain_all_begin_nopoll(void)
     }
 }
 
+/*
+ * 在以下使用bdrv_drain_all_begin():
+ *   - block/block-backend.c|2088| <<blk_drain_all>> bdrv_drain_all_begin();
+ *   - block/io.c|306| <<bdrv_co_drain_bh_cb>> bdrv_drain_all_begin();
+ *   - block/io.c|585| <<bdrv_drain_all>> bdrv_drain_all_begin();
+ *   - migration/savevm.c|3125| <<save_snapshot>> bdrv_drain_all_begin();
+ *   - migration/savevm.c|3306| <<load_snapshot>> bdrv_drain_all_begin();
+ *   - storage-daemon/qemu-storage-daemon.c|438| <<main>> bdrv_drain_all_begin();
+ *   - system/runstate.c|948| <<qemu_cleanup>> bdrv_drain_all_begin();
+ *   - tests/unit/test-bdrv-drain.c|165| <<do_drain_begin>> case BDRV_DRAIN_ALL: bdrv_drain_all_begin(); break;
+ *   - tests/unit/test-bdrv-drain.c|441| <<test_graph_change_drain_all>> bdrv_drain_all_begin();
+ *   - tests/unit/test-bdrv-drain.c|1106| <<do_test_delete_by_drain>> bdrv_drain_all_begin();
+ */
 void coroutine_mixed_fn bdrv_drain_all_begin(void)
 {
     BlockDriverState *bs = NULL;
@@ -570,6 +583,15 @@ void bdrv_drain_all_end(void)
     bdrv_drain_all_count--;
 }
 
+/*
+ * called by:
+ *   - block.c|5265| <<bdrv_close_all>> bdrv_drain_all();
+ *   - blockdev.c|2188| <<qmp_transaction>> bdrv_drain_all();
+ *   - hw/xen/xen-mapcache.c|700| <<xen_invalidate_map_cache>> bdrv_drain_all();
+ *   - qemu-io.c|679| <<main>> bdrv_drain_all();
+ *   - system/cpus.c|307| <<do_vm_stop>> bdrv_drain_all();
+ *   - system/cpus.c|786| <<vm_stop_force_state>> bdrv_drain_all();
+ */
 void bdrv_drain_all(void)
 {
     GLOBAL_STATE_CODE();
@@ -762,6 +784,10 @@ static int coroutine_fn GRAPH_RDLOCK bdrv_get_cluster_size(BlockDriverState *bs)
     }
 }
 
+/*
+ * called by:
+ *   - 
+ */
 void bdrv_inc_in_flight(BlockDriverState *bs)
 {
     IO_CODE();
diff --git a/block/mirror.c b/block/mirror.c
index 61f0a717b..8dcd1a39d 100644
--- a/block/mirror.c
+++ b/block/mirror.c
@@ -480,6 +480,10 @@ static unsigned mirror_perform(MirrorBlockJob *s, int64_t offset,
     return bytes_handled;
 }
 
+/*
+ * called by:
+ *   - block/mirror.c|1078| <<mirror_run>> mirror_iteration(s);
+ */
 static void coroutine_fn GRAPH_UNLOCKED mirror_iteration(MirrorBlockJob *s)
 {
     BlockDriverState *source;
@@ -1706,6 +1710,42 @@ static BlockDriver bdrv_mirror_top = {
     .filtered_child_is_backing  = true,
 };
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ *
+ * bs     :
+ *   - filename = "/tmp/overlay01.qcow2"i,
+ *   - exact_filename = "/tmp/overlay01.qcow2"
+ *   - backing_file = "test01.qcow2"
+ *   - auto_backing_file = "test01.qcow2"
+ * target :
+ *   - filename = "test01.qcow2"
+ *   - exact_filename = "test01.qcow2"
+ *   - backing_file = 0
+ *   - auto_backing_file = 0
+ */
 static BlockJob *mirror_start_job(
                              const char *job_id, BlockDriverState *bs,
                              int creation_flags, BlockDriverState *target,
@@ -2039,6 +2079,43 @@ void mirror_start(const char *job_id, BlockDriverState *bs,
                      filter_node_name, true, copy_mode, false, errp);
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ *
+ * 两个重要的参数:
+ * bs   :
+ *   - filename = "/tmp/overlay01.qcow2",
+ *   - exact_filename = "/tmp/overlay01.qcow2"
+ *   - backing_file = "test01.qcow2"
+ *   - auto_backing_file = "test01.qcow2"
+ * base :
+ *   - filename = "test01.qcow2"
+ *   - exact_filename = "test01.qcow2"
+ *   - backing_file = 0
+ *   - auto_backing_file = 0
+ */
 BlockJob *commit_active_start(const char *job_id, BlockDriverState *bs,
                               BlockDriverState *base, int creation_flags,
                               int64_t speed, BlockdevOnError on_error,
diff --git a/blockdev.c b/blockdev.c
index 835064ed0..59bbb8e56 100644
--- a/blockdev.c
+++ b/blockdev.c
@@ -2423,6 +2423,35 @@ out_rdlock:
     bdrv_graph_rdunlock_main_loop();
 }
 
+/*
+ * [0] qemu_lock_fd
+ * [0] raw_handle_perm_lock
+ * [0] raw_check_perm
+ * [0] bdrv_drv_set_perm
+ * [0] bdrv_node_refresh_perm
+ * [0] bdrv_list_refresh_perms
+ * [0] bdrv_replace_node_common
+ * [0] mirror_start_job
+ * [0] commit_active_start
+ * [0] qmp_block_commit
+ * [0] qmp_marshal_block_commit
+ * [0] do_qmp_dispatch_bh
+ * [0] aio_bh_poll
+ * [0] aio_dispatch
+ * [0] aio_ctx_dispatch
+ * [0] g_main_context_dispatch
+ * [0] glib_pollfds_poll
+ * [0] os_host_main_loop_wait
+ * [0] main_loop_wait
+ * [0] qemu_main_loop
+ * [0] qemu_default_main
+ * [0] __libc_start_main
+ * [0] _start
+ *
+ * (QEMU) blockdev-snapshot-sync node-name=drive01 snapshot-file=/tmp/overlay01.qcow2 snapshot-node-name=over01
+ * (QEMU) block-commit device=over01 job-id=jobA
+ * (QEMU) block-job-complete device=jobA
+ */
 void qmp_block_commit(const char *job_id, const char *device,
                       const char *base_node,
                       const char *base,
@@ -2559,6 +2588,19 @@ void qmp_block_commit(const char *job_id, const char *device,
         }
     }
 
+    /*
+     * 这里有两个很重要的:
+     * top_bs  :
+     *   - filename = "/tmp/overlay01.qcow2"i,
+     *   - exact_filename = "/tmp/overlay01.qcow2"
+     *   - backing_file = "test01.qcow2"
+     *   - auto_backing_file = "test01.qcow2"
+     * base_bs :
+     *   - filename = "test01.qcow2"
+     *   - exact_filename = "test01.qcow2"
+     *   - backing_file = 0
+     *   - auto_backing_file = 0
+     */
     /* Do not allow attempts to commit an image into itself */
     if (top_bs == base_bs) {
         error_setg(errp, "cannot commit an image into itself");
@@ -2596,6 +2638,19 @@ void qmp_block_commit(const char *job_id, const char *device,
              */
             job_id = bdrv_get_device_name(bs);
         }
+        /*
+	 * 两个重要的参数:
+	 * top_bs  :
+	 *   - filename = "/tmp/overlay01.qcow2"i,
+	 *   - exact_filename = "/tmp/overlay01.qcow2"
+	 *   - backing_file = "test01.qcow2"
+	 *   - auto_backing_file = "test01.qcow2"
+	 * base_bs :
+	 *   - filename = "test01.qcow2"
+	 *   - exact_filename = "test01.qcow2"
+	 *   - backing_file = 0
+	 *   - auto_backing_file = 0
+	 */
         commit_active_start(job_id, top_bs, base_bs, job_flags, speed, on_error,
                             filter_node_name, NULL, NULL, false, &local_err);
     } else {
diff --git a/dump/dump.c b/dump/dump.c
index 45e84428a..cd32522ff 100644
--- a/dump/dump.c
+++ b/dump/dump.c
@@ -527,6 +527,10 @@ static void write_data(DumpState *s, void *buf, int length, Error **errp)
     }
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|770| <<dump_iterate>> write_memory(s, block, memblock_start, memblock_size, errp);
+ */
 /* write the memory to vmcore. 1 page per I/O. */
 static void write_memory(DumpState *s, GuestPhysBlock *block, ram_addr_t start,
                          int64_t size, Error **errp)
@@ -654,6 +658,10 @@ static void write_elf_notes(DumpState *s, Error **errp)
     }
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|805| <<create_vmcore>> dump_begin(s, errp);
+ */
 /* write elf header, PT_NOTE and elf note to vmcore. */
 static void dump_begin(DumpState *s, Error **errp)
 {
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index 6d4517cfb..c8a69238a 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -2051,6 +2051,11 @@ void build_spcr(GArray *table_data, BIOSLinker *linker,
  * ACPI spec, Revision 6.3
  * 5.2.29 Processor Properties Topology Table (PPTT)
  */
+/*
+ * called by:
+ *   - hw/arm/virt-acpi-build.c|922| <<virt_acpi_build>> build_pptt(tables_blob, tables->linker, ms, vms->oem_id, vms->oem_table_id);
+ *   - hw/loongarch/acpi-build.c|475| <<acpi_build>> build_pptt(tables_blob, tables->linker, machine, lvms->oem_id, lvms->oem_table_id);
+ */
 void build_pptt(GArray *table_data, BIOSLinker *linker, MachineState *ms,
                 const char *oem_id, const char *oem_table_id)
 {
diff --git a/hw/acpi/cpu.c b/hw/acpi/cpu.c
index 5cb60ca8b..7da88c9fc 100644
--- a/hw/acpi/cpu.c
+++ b/hw/acpi/cpu.c
@@ -7,6 +7,165 @@
 #include "trace.h"
 #include "sysemu/numa.h"
 
+/*
+ * {"timestamp": {"seconds": 1727334425, "microseconds": 314956}, "event": "ACPI_DEVICE_OST", "data": {"info": {"device": "cpu4", "source": 3,
+ * "status": 132, "slot": "4", "slot-type": "CPU"}}}
+ * {"timestamp": {"seconds": 1727334425, "microseconds": 338022}, "event": "DEVICE_DELETED", "data": {"path": "/machine/peripheral/cpu4/lapic"}}
+ * {"timestamp": {"seconds": 1727334425, "microseconds": 338273}, "event": "DEVICE_DELETED", "data": {"device": "cpu4", "path": "/machine/peripheral/cpu4"}}
+ * {"timestamp": {"seconds": 1727334425, "microseconds": 338408}, "event": "ACPI_DEVICE_OST", "data": {"info": {"source": 3, "status": 0, "slot": "4", "slot-type": "CPU"}}}
+ *
+ * =====================
+ *
+ * {"timestamp": {"seconds": 1727334425, "microseconds": 314956}, "event": "ACPI_DEVICE_OST", "data": {"info": {"device": "cpu4", "source": 3,
+ * "status": 132, "slot": "4", "slot-type": "CPU"}}}
+ *
+ * (gdb) bt
+ * #0  qapi_event_send_acpi_device_ost (info=0x7ffdd0006610) at qapi/qapi-events-acpi.c:23
+ * #1  0x00005555558e93c0 in cpu_hotplug_wr (opaque=0x555557c05c60, addr=8, data=132, size=4) at ../hw/acpi/cpu.c:190
+ * #2  0x0000555555e63c32 in memory_region_write_accessor (mr=0x555557c05c60, addr=8, value=0x7fffe8f123b8, size=4, shift=0, mask=4294967295,
+ *     attrs=...) at ../system/memory.c:497
+ * #3  0x0000555555e63f79 in access_with_adjusted_size (addr=8, value=0x7fffe8f123b8, size=4, access_size_min=1, access_size_max=4,
+ *     access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x555557c05c60, attrs=...) at ../system/memory.c:573
+ * #4  0x0000555555e674ae in memory_region_dispatch_write (mr=0x555557c05c60, addr=8, data=132, op=MO_32, attrs=...) at ../system/memory.c:1521
+ * #5  0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff0034000 "\204", len=4, mr_addr=8, l=0x7fffe8f124a0,
+ *     mr=0x555557c05c60) at ../system/physmem.c:2803
+ * #6  0x0000555555e76cae in flatview_write_continue (fv=0x7ffdd4502b60, addr=44808, attrs=..., ptr=0x7ffff0034000, len=4, mr_addr=8, l=4,
+ *     mr=0x555557c05c60) at ../system/physmem.c:2833
+ * #7  0x0000555555e76dd6 in flatview_write (fv=0x7ffdd4502b60, addr=44808, attrs=..., buf=0x7ffff0034000, len=4) at ../system/physmem.c:2864
+ * #8  0x0000555555e77250 in address_space_write (as=0x555557328140 <address_space_io>, addr=44808, attrs=..., buf=0x7ffff0034000, len=4)
+ *     at ../system/physmem.c:2984
+ * #9  0x0000555555e772c8 in address_space_rw (as=0x555557328140 <address_space_io>, addr=44808, attrs=..., buf=0x7ffff0034000, len=4,
+ *     is_write=true) at ../system/physmem.c:2994
+ * #10 0x0000555555ed3f0a in kvm_handle_io (port=44808, attrs=..., data=0x7ffff0034000, direction=1, size=4, count=1)
+ *     at ../accel/kvm/kvm-all.c:2703
+ * #11 0x0000555555ed4d13 in kvm_cpu_exec (cpu=0x555557746980) at ../accel/kvm/kvm-all.c:3066
+ * #12 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x555557746980) at ../accel/kvm/kvm-accel-ops.c:50
+ * #13 0x000055555616b040 in qemu_thread_start (args=0x55555774fab0) at ../util/qemu-thread-posix.c:541
+ * #14 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #15 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ *
+ * {"timestamp": {"seconds": 1727334425, "microseconds": 338022}, "event": "DEVICE_DELETED", "data": {"path": "/machine/peripheral/cpu4/lapic"}}
+ *
+ * (gdb) bt
+ * #0  qapi_event_send_device_deleted (device=0x0, path=0x555557684a40 "/machine/peripheral/core4/lapic") at qapi/qapi-events-qdev.c:23
+ * #1  0x0000555555eed740 in device_finalize (obj=0x7ffdcc020cd0) at ../hw/core/qdev.c:704
+ * #2  0x0000555555ef3ec3 in object_deinit (obj=0x7ffdcc020cd0, type=0x5555573f21c0) at ../qom/object.c:723
+ * #3  0x0000555555ef3ef1 in object_deinit (obj=0x7ffdcc020cd0, type=0x5555573e4e50) at ../qom/object.c:727
+ * #4  0x0000555555ef3ef1 in object_deinit (obj=0x7ffdcc020cd0, type=0x5555573cd890) at ../qom/object.c:727
+ * #5  0x0000555555ef3f3d in object_finalize (data=0x7ffdcc020cd0) at ../qom/object.c:737
+ * #6  0x0000555555ef51a0 in object_unref (objptr=0x7ffdcc020cd0) at ../qom/object.c:1245
+ * #7  0x0000555555ef6ad6 in object_finalize_child_property (obj=0x5555581fab60, name=0x5555584f4730 "lapic", opaque=0x7ffdcc020cd0)
+ *     at ../qom/object.c:1799
+ * #8  0x0000555555ef3da2 in object_property_del_child (obj=0x5555581fab60, child=0x7ffdcc020cd0) at ../qom/object.c:697
+ * #9  0x0000555555ef3e8a in object_unparent (obj=0x7ffdcc020cd0) at ../qom/object.c:716
+ * #10 0x0000555555d49c4e in x86_cpu_unrealizefn (dev=0x5555581fab60) at ../target/i386/cpu.c:7882
+ * #11 0x0000555555eed28f in device_set_realized (obj=0x5555581fab60, value=false, errp=0x5555573440b8 <error_abort>) at ../hw/core/qdev.c:599
+ * #12 0x0000555555ef8021 in property_set_bool (obj=0x5555581fab60, v=0x7ffdcc00e6d0, name=0x55555639c861 "realized", opaque=0x555557400780,
+ *     errp=0x5555573440b8 <error_abort>) at ../qom/object.c:2354
+ * #13 0x0000555555ef5b6f in object_property_set (obj=0x5555581fab60, name=0x55555639c861 "realized", v=0x7ffdcc00e6d0,
+ *     errp=0x5555573440b8 <error_abort>) at ../qom/object.c:1463
+ * #14 0x0000555555efa89c in object_property_set_qobject (obj=0x5555581fab60, name=0x55555639c861 "realized", value=0x7ffdcc000fb0,
+ *     errp=0x5555573440b8 <error_abort>) at ../qom/qom-qobject.c:28
+ * #15 0x0000555555ef5f14 in object_property_set_bool (obj=0x5555581fab60, name=0x55555639c861 "realized", value=false,
+ *     errp=0x5555573440b8 <error_abort>) at ../qom/object.c:1533
+ * #16 0x0000555555eec6f3 in qdev_unrealize (dev=0x5555581fab60) at ../hw/core/qdev.c:305
+ * #17 0x0000555555cfaa40 in x86_cpu_unplug_cb (hotplug_dev=0x555557668800, dev=0x5555581fab60, errp=0x0) at ../hw/i386/x86-common.c:229
+ * #18 0x0000555555d1d2e9 in pc_machine_device_unplug_cb (hotplug_dev=0x555557668800, dev=0x5555581fab60, errp=0x0) at ../hw/i386/pc.c:1451
+ * #19 0x000055555593c170 in hotplug_handler_unplug (plug_handler=0x555557668800, plugged_dev=0x5555581fab60, errp=0x0) at ../hw/core/hotplug.c:56
+ * #20 0x00005555558e9165 in cpu_hotplug_wr (opaque=0x555557c05c60, addr=4, data=8, size=1) at ../hw/acpi/cpu.c:145
+ * #21 0x0000555555e63c32 in memory_region_write_accessor (mr=0x555557c05c60, addr=4, value=0x7fffe97133b8, size=1, shift=0, mask=255, attrs=...)
+ *     at ../system/memory.c:497
+ * #22 0x0000555555e63f79 in access_with_adjusted_size (addr=4, value=0x7fffe97133b8, size=1, access_size_min=1, access_size_max=4,
+ *     access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x555557c05c60, attrs=...) at ../system/memory.c:573
+ * #23 0x0000555555e674ae in memory_region_dispatch_write (mr=0x555557c05c60, addr=4, data=8, op=MO_8, attrs=...) at ../system/memory.c:1521
+ * #24 0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff0037000 "\b", len=1, mr_addr=4, l=0x7fffe97134a0,
+ *     mr=0x555557c05c60) at ../system/physmem.c:2803
+ * #25 0x0000555555e76cae in flatview_write_continue (fv=0x7ffdd4502b60, addr=44804, attrs=..., ptr=0x7ffff0037000, len=1, mr_addr=4, l=1,
+ *     mr=0x555557c05c60) at ../system/physmem.c:2833
+ * #26 0x0000555555e76dd6 in flatview_write (fv=0x7ffdd4502b60, addr=44804, attrs=..., buf=0x7ffff0037000, len=1) at ../system/physmem.c:2864
+ * #27 0x0000555555e77250 in address_space_write (as=0x555557328140 <address_space_io>, addr=44804, attrs=..., buf=0x7ffff0037000, len=1)
+ *     at ../system/physmem.c:2984
+ * #28 0x0000555555e772c8 in address_space_rw (as=0x555557328140 <address_space_io>, addr=44804, attrs=..., buf=0x7ffff0037000, len=1,
+ *     is_write=true) at ../system/physmem.c:2994
+ * #29 0x0000555555ed3f0a in kvm_handle_io (port=44804, attrs=..., data=0x7ffff0037000, direction=1, size=1, count=1)
+ *     at ../accel/kvm/kvm-all.c:2703
+ * #30 0x0000555555ed4d13 in kvm_cpu_exec (cpu=0x55555773cfb0) at ../accel/kvm/kvm-all.c:3066
+ * #31 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x55555773cfb0) at ../accel/kvm/kvm-accel-ops.c:50
+ * #32 0x000055555616b040 in qemu_thread_start (args=0x555557746090) at ../util/qemu-thread-posix.c:541
+ * #33 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #34 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ *
+ * {"timestamp": {"seconds": 1727334425, "microseconds": 338273}, "event": "DEVICE_DELETED", "data": {"device": "cpu4", "path": "/machine/peripheral/cpu4"}}
+ *
+ * (gdb) bt
+ * #0  qapi_event_send_device_deleted (device=0x55555837cc40 "core4", path=0x555557777c00 "/machine/peripheral/core4")
+ *     at qapi/qapi-events-qdev.c:23
+ * #1  0x0000555555eed740 in device_finalize (obj=0x5555581fab60) at ../hw/core/qdev.c:704
+ * #2  0x0000555555ef3ec3 in object_deinit (obj=0x5555581fab60, type=0x5555573f21c0) at ../qom/object.c:723
+ * #3  0x0000555555ef3ef1 in object_deinit (obj=0x5555581fab60, type=0x5555573929d0) at ../qom/object.c:727
+ * #4  0x0000555555ef3ef1 in object_deinit (obj=0x5555581fab60, type=0x5555573b2380) at ../qom/object.c:727
+ * #5  0x0000555555ef3ef1 in object_deinit (obj=0x5555581fab60, type=0x5555573e2ef0) at ../qom/object.c:727
+ * #6  0x0000555555ef3ef1 in object_deinit (obj=0x5555581fab60, type=0x5555573e3250) at ../qom/object.c:727
+ * #7  0x0000555555ef3f3d in object_finalize (data=0x5555581fab60) at ../qom/object.c:737
+ * #8  0x0000555555ef51a0 in object_unref (objptr=0x5555581fab60) at ../qom/object.c:1245
+ * #9  0x0000555555ef6ad6 in object_finalize_child_property (obj=0x555557667da0, name=0x5555577e10c0 "core4", opaque=0x5555581fab60)
+ *     at ../qom/object.c:1799
+ * #10 0x0000555555ef3da2 in object_property_del_child (obj=0x555557667da0, child=0x5555581fab60) at ../qom/object.c:697
+ * #11 0x0000555555ef3e8a in object_unparent (obj=0x5555581fab60) at ../qom/object.c:716
+ * #12 0x00005555558e9171 in cpu_hotplug_wr (opaque=0x555557c05c60, addr=4, data=8, size=1) at ../hw/acpi/cpu.c:146
+ * #13 0x0000555555e63c32 in memory_region_write_accessor (mr=0x555557c05c60, addr=4, value=0x7fffe97133b8, size=1, shift=0, mask=255, attrs=...)
+ *     at ../system/memory.c:497
+ * #14 0x0000555555e63f79 in access_with_adjusted_size (addr=4, value=0x7fffe97133b8, size=1, access_size_min=1, access_size_max=4,
+ *     access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x555557c05c60, attrs=...) at ../system/memory.c:573
+ * #15 0x0000555555e674ae in memory_region_dispatch_write (mr=0x555557c05c60, addr=4, data=8, op=MO_8, attrs=...) at ../system/memory.c:1521
+ * #16 0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff0037000 "\b", len=1, mr_addr=4, l=0x7fffe97134a0,
+ *     mr=0x555557c05c60) at ../system/physmem.c:2803
+ * #17 0x0000555555e76cae in flatview_write_continue (fv=0x7ffdd4502b60, addr=44804, attrs=..., ptr=0x7ffff0037000, len=1, mr_addr=4, l=1,
+ *     mr=0x555557c05c60) at ../system/physmem.c:2833
+ * #18 0x0000555555e76dd6 in flatview_write (fv=0x7ffdd4502b60, addr=44804, attrs=..., buf=0x7ffff0037000, len=1) at ../system/physmem.c:2864
+ * #19 0x0000555555e77250 in address_space_write (as=0x555557328140 <address_space_io>, addr=44804, attrs=..., buf=0x7ffff0037000, len=1)
+ *     at ../system/physmem.c:2984
+ * #20 0x0000555555e772c8 in address_space_rw (as=0x555557328140 <address_space_io>, addr=44804, attrs=..., buf=0x7ffff0037000, len=1,
+ *     is_write=true) at ../system/physmem.c:2994
+ * #21 0x0000555555ed3f0a in kvm_handle_io (port=44804, attrs=..., data=0x7ffff0037000, direction=1, size=1, count=1)
+ *     at ../accel/kvm/kvm-all.c:2703
+ * #22 0x0000555555ed4d13 in kvm_cpu_exec (cpu=0x55555773cfb0) at ../accel/kvm/kvm-all.c:3066
+ * #23 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x55555773cfb0) at ../accel/kvm/kvm-accel-ops.c:50
+ * #24 0x000055555616b040 in qemu_thread_start (args=0x555557746090) at ../util/qemu-thread-posix.c:541
+ * #25 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #26 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ *
+ * {"timestamp": {"seconds": 1727334425, "microseconds": 338408}, "event": "ACPI_DEVICE_OST", "data": {"info": {"source": 3, "status": 0, "slot": "4", "slot-type": "CPU"}}}
+ *
+ * (gdb) bt
+ * #0  qapi_event_send_acpi_device_ost (info=0x7ffdcc006110) at qapi/qapi-events-acpi.c:23
+ * #1  0x00005555558e93c0 in cpu_hotplug_wr (opaque=0x555557c05c60, addr=8, data=0, size=4) at ../hw/acpi/cpu.c:190
+ * #2  0x0000555555e63c32 in memory_region_write_accessor (mr=0x555557c05c60, addr=8, value=0x7fffe97133b8, size=4, shift=0, mask=4294967295,
+ *     attrs=...) at ../system/memory.c:497
+ * #3  0x0000555555e63f79 in access_with_adjusted_size (addr=8, value=0x7fffe97133b8, size=4, access_size_min=1, access_size_max=4,
+ *     access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x555557c05c60, attrs=...) at ../system/memory.c:573
+ * #4  0x0000555555e674ae in memory_region_dispatch_write (mr=0x555557c05c60, addr=8, data=0, op=MO_32, attrs=...) at ../system/memory.c:1521
+ * #5  0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff0037000 "", len=4, mr_addr=8, l=0x7fffe97134a0,
+ *     mr=0x555557c05c60) at ../system/physmem.c:2803
+ * #6  0x0000555555e76cae in flatview_write_continue (fv=0x7ffdd4502b60, addr=44808, attrs=..., ptr=0x7ffff0037000, len=4, mr_addr=8, l=4,
+ *     mr=0x555557c05c60) at ../system/physmem.c:2833
+ * #7  0x0000555555e76dd6 in flatview_write (fv=0x7ffdd4502b60, addr=44808, attrs=..., buf=0x7ffff0037000, len=4) at ../system/physmem.c:2864
+ * #8  0x0000555555e77250 in address_space_write (as=0x555557328140 <address_space_io>, addr=44808, attrs=..., buf=0x7ffff0037000, len=4)
+ *     at ../system/physmem.c:2984
+ * #9  0x0000555555e772c8 in address_space_rw (as=0x555557328140 <address_space_io>, addr=44808, attrs=..., buf=0x7ffff0037000, len=4,
+ *     is_write=true) at ../system/physmem.c:2994
+ * #10 0x0000555555ed3f0a in kvm_handle_io (port=44808, attrs=..., data=0x7ffff0037000, direction=1, size=4, count=1)
+ *     at ../accel/kvm/kvm-all.c:2703
+ * #11 0x0000555555ed4d13 in kvm_cpu_exec (cpu=0x55555773cfb0) at ../accel/kvm/kvm-all.c:3066
+ * #12 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x55555773cfb0) at ../accel/kvm/kvm-accel-ops.c:50
+ * #13 0x000055555616b040 in qemu_thread_start (args=0x555557746090) at ../util/qemu-thread-posix.c:541
+ * #14 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #15 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ */
+
 #define ACPI_CPU_SELECTOR_OFFSET_WR 0
 #define ACPI_CPU_FLAGS_OFFSET_RW 4
 #define ACPI_CPU_CMD_OFFSET_WR 5
@@ -187,6 +346,20 @@ static void cpu_hotplug_wr(void *opaque, hwaddr addr, uint64_t data,
            cdev = &cpu_st->devs[cpu_st->selector];
            cdev->ost_status = data;
            info = acpi_cpu_device_status(cpu_st->selector, cdev);
+	   /*
+	    * {"execute": "device_del", "arguments": {"id": "cpu4"}}
+	    * {"return": {}}
+	    *
+	    * {"timestamp": {"seconds": 1727334425, "microseconds": 314956}, "event": "ACPI_DEVICE_OST", "data": {"info": {"device": "cpu4", "source": 3,
+	    * "status": 132, "slot": "4", "slot-type": "CPU"}}}
+	    * {"timestamp": {"seconds": 1727334425, "microseconds": 338022}, "event": "DEVICE_DELETED", "data": {"path": "/machine/peripheral/cpu4/lapic"}}
+	    * {"timestamp": {"seconds": 1727334425, "microseconds": 338273}, "event": "DEVICE_DELETED", "data": {"device": "cpu4", "path": "/machine/peripheral/cpu4"}}
+	    * {"timestamp": {"seconds": 1727334425, "microseconds": 338408}, "event": "ACPI_DEVICE_OST", "data": {"info": {"source": 3, "status": 0, "slot": "4", "slot-type": "CPU"}}}
+	    *
+	    * 在以下调用qapi_event_send_acpi_device_ost():
+	    *   - hw/acpi/cpu.c|190| <<cpu_hotplug_wr>> qapi_event_send_acpi_device_ost(info);
+	    *   - hw/acpi/memory_hotplug.c|158| <<acpi_memory_hotplug_write>> qapi_event_send_acpi_device_ost(info);
+	    */
            qapi_event_send_acpi_device_ost(info);
            qapi_free_ACPIOSTInfo(info);
            trace_cpuhp_acpi_write_ost_status(cpu_st->selector,
@@ -337,6 +510,11 @@ const VMStateDescription vmstate_cpu_hotplug = {
 #define CPU_EJECT_EVENT   "CEJ0"
 #define CPU_FW_EJECT_EVENT "CEJF"
 
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|1538| <<build_dsdt>> build_cpus_aml(dsdt, machine, opts,
+ *         pc_madt_cpu_entry, pm->cpu_hp_io_base, "\\_SB.PCI0", "\\_GPE._E02", AML_SYSTEM_IO);
+ */
 void build_cpus_aml(Aml *table, MachineState *machine, CPUHotplugFeatures opts,
                     build_madt_cpu_fn build_madt_cpu, hwaddr base_addr,
                     const char *res_root,
diff --git a/hw/acpi/memory_hotplug.c b/hw/acpi/memory_hotplug.c
index 9b974b727..d917031f5 100644
--- a/hw/acpi/memory_hotplug.c
+++ b/hw/acpi/memory_hotplug.c
@@ -155,6 +155,11 @@ static void acpi_memory_hotplug_write(void *opaque, hwaddr addr, uint64_t data,
         /* TODO: implement memory removal on guest signal */
 
         info = acpi_memory_device_status(mem_st->selector, mdev);
+	/*
+	 * 在以下调用qapi_event_send_acpi_device_ost():
+	 *   - hw/acpi/cpu.c|190| <<cpu_hotplug_wr>> qapi_event_send_acpi_device_ost(info);
+	 *   - hw/acpi/memory_hotplug.c|158| <<acpi_memory_hotplug_write>> qapi_event_send_acpi_device_ost(info);
+	 */
         qapi_event_send_acpi_device_ost(info);
         qapi_free_ACPIOSTInfo(info);
         break;
diff --git a/hw/acpi/pcihp.c b/hw/acpi/pcihp.c
index 5f79c9016..11cee3126 100644
--- a/hw/acpi/pcihp.c
+++ b/hw/acpi/pcihp.c
@@ -442,6 +442,15 @@ static void pci_write(void *opaque, hwaddr addr, uint64_t data,
     BusChild *kid, *next;
     AcpiPciHpState *s = opaque;
 
+    /*
+     * 在以下使用AcpiPciHpState->acpi_index:
+     *   - hw/acpi/pcihp.c|426| <<pci_read>> val = s->acpi_index;
+     *   - hw/acpi/pcihp.c|427| <<pci_read>> s->acpi_index = 0;
+     *   - hw/acpi/pcihp.c|445| <<pci_write>> s->acpi_index = 0;
+     *   - hw/acpi/pcihp.c|466| <<pci_write>> s->acpi_index = object_property_get_uint(o, "acpi-index", NULL);
+     *   - hw/acpi/pcihp.c|470| <<pci_write>> trace_acpi_pci_acpi_index_write(s->hotplug_select, slot, s->acpi_index);
+     *   - include/hw/acpi/pcihp.h|99| <<VMSTATE_PCI_HOTPLUG>> VMSTATE_UINT32_TEST(pcihp.acpi_index, state, \
+     */
     s->acpi_index = 0;
     switch (addr) {
     case PCI_AIDX_BASE:
@@ -463,6 +472,15 @@ static void pci_write(void *opaque, hwaddr addr, uint64_t data,
             Object *o = OBJECT(kid->child);
             PCIDevice *dev = PCI_DEVICE(o);
             if (PCI_SLOT(dev->devfn) == slot) {
+                /*
+		 * 在以下使用AcpiPciHpState->acpi_index:
+		 *   - hw/acpi/pcihp.c|426| <<pci_read>> val = s->acpi_index;
+		 *   - hw/acpi/pcihp.c|427| <<pci_read>> s->acpi_index = 0;
+		 *   - hw/acpi/pcihp.c|445| <<pci_write>> s->acpi_index = 0;
+		 *   - hw/acpi/pcihp.c|466| <<pci_write>> s->acpi_index = object_property_get_uint(o, "acpi-index", NULL);
+		 *   - hw/acpi/pcihp.c|470| <<pci_write>> trace_acpi_pci_acpi_index_write(s->hotplug_select, slot, s->acpi_index);
+		 *   - include/hw/acpi/pcihp.h|99| <<VMSTATE_PCI_HOTPLUG>> VMSTATE_UINT32_TEST(pcihp.acpi_index, state, \
+		 */
                 s->acpi_index = object_property_get_uint(o, "acpi-index", NULL);
                 break;
             }
diff --git a/hw/acpi/piix4.c b/hw/acpi/piix4.c
index debe1adb8..3877847cc 100644
--- a/hw/acpi/piix4.c
+++ b/hw/acpi/piix4.c
@@ -225,10 +225,48 @@ static bool piix4_vmstate_need_smbus(void *opaque, int version_id)
     return pm_smbus_vmstate_needed();
 }
 
+/*
+ * struct VMStateDescription:
+ * -> const VMStateField *fields;
+ *        struct VMStateField {
+ *            const char *name;
+ *    	      const char *err_hint;
+ * 	      size_t offset;
+ * 	      size_t size;
+ * 	      size_t start;
+ * 	      int num;
+ * 	      size_t num_offset;
+ * 	      size_t size_offset;
+ * 	      const VMStateInfo *info;
+ * 	      enum VMStateFlags flags;
+ * 	      const VMStateDescription *vmsd;
+ * 	      int version_id;
+ * 	      int struct_version_id;
+ * 	      bool (*field_exists)(void *opaque, int version_id);
+ *        };
+ * -> const VMStateDescription * const *subsections;
+ *
+ * 266 static const VMStateDescription vmstate_acpi = {
+ * 267     .name = "piix4_pm",
+ * 268     .version_id = 3,
+ * 269     .minimum_version_id = 3,
+ * 270     .post_load = vmstate_acpi_post_load,
+ * 271     .fields = (const VMStateField[]) {
+ * 272         VMSTATE_PCI_DEVICE(parent_obj, PIIX4PMState),
+ * ... ...
+ * 288         VMSTATE_PCI_HOTPLUG(acpi_pci_hotplug, PIIX4PMState,
+ * 289                             vmstate_test_use_acpi_hotplug_bridge,
+ * 290                             vmstate_test_migrate_acpi_index),
+ */
 /*
  * This is a fudge to turn off the acpi_index field,
  * whose test was always broken on piix4 with 6.2 and older machine types.
  */
+/*
+ * struct PIIX4PMState:
+ * -> AcpiPciHpState acpi_pci_hotplug;
+ *    -> uint32_t acpi_index;
+ */
 static bool vmstate_test_migrate_acpi_index(void *opaque, int version_id)
 {
     PIIX4PMState *s = PIIX4_PM(opaque);
@@ -236,12 +274,66 @@ static bool vmstate_test_migrate_acpi_index(void *opaque, int version_id)
            !s->not_migrate_acpi_index;
 }
 
+/*
+ * struct VMStateDescription:
+ * -> const VMStateField *fields;
+ *        struct VMStateField {
+ *            const char *name;
+ *            const char *err_hint;
+ *            size_t offset;
+ *            size_t size;
+ *            size_t start;
+ *            int num;
+ *            size_t num_offset;
+ *            size_t size_offset;
+ *            const VMStateInfo *info;
+ *            enum VMStateFlags flags;
+ *            const VMStateDescription *vmsd;
+ *            int version_id;
+ *            int struct_version_id;
+ *            bool (*field_exists)(void *opaque, int version_id);
+ *        };
+ * -> const VMStateDescription * const *subsections;
+ *
+ * 266 static const VMStateDescription vmstate_acpi = {
+ * 267     .name = "piix4_pm",
+ * 268     .version_id = 3,
+ * 269     .minimum_version_id = 3,
+ * 270     .post_load = vmstate_acpi_post_load,
+ * 271     .fields = (const VMStateField[]) {
+ * 272         VMSTATE_PCI_DEVICE(parent_obj, PIIX4PMState),
+ * ... ...
+ * 288         VMSTATE_PCI_HOTPLUG(acpi_pci_hotplug, PIIX4PMState,
+ * 289                             vmstate_test_use_acpi_hotplug_bridge,
+ * 290                             vmstate_test_migrate_acpi_index),
+ */
 /* qemu-kvm 1.2 uses version 3 but advertised as 2
  * To support incoming qemu-kvm 1.2 migration, change version_id
  * and minimum_version_id to 2 below (which breaks migration from
  * qemu 1.2).
  *
  */
+/*
+ * 167 struct VMStateField {
+ * 168     const char *name;
+ * 169     const char *err_hint;  
+ * 170     size_t offset;
+ * 171     size_t size;
+ * 172     size_t start;
+ * 173     int num;
+ * 174     size_t num_offset;
+ * 175     size_t size_offset;
+ * 176     const VMStateInfo *info;
+ * 177     enum VMStateFlags flags;
+ * 178     const VMStateDescription *vmsd;
+ * 179     int version_id;
+ * 180     int struct_version_id; 
+ * 181     bool (*field_exists)(void *opaque, int version_id);
+ * 182 };
+ *
+ * 在以下使用vmstate_acpi:
+ *   - hw/acpi/piix4.c|638| <<piix4_pm_class_init>> dc->vmsd = &vmstate_acpi;
+ */
 static const VMStateDescription vmstate_acpi = {
     .name = "piix4_pm",
     .version_id = 3,
diff --git a/hw/arm/virt-acpi-build.c b/hw/arm/virt-acpi-build.c
index f76fb117a..65e958ce6 100644
--- a/hw/arm/virt-acpi-build.c
+++ b/hw/arm/virt-acpi-build.c
@@ -890,6 +890,11 @@ static void acpi_align_size(GArray *blob, unsigned align)
     g_array_set_size(blob, ROUND_UP(acpi_data_len(blob), align));
 }
 
+/*
+ * called by:
+ *   - hw/arm/virt-acpi-build.c|1052| <<virt_acpi_build_update>> virt_acpi_build(VIRT_MACHINE(qdev_get_machine()), &tables);
+ *   - hw/arm/virt-acpi-build.c|1096| <<virt_acpi_setup>> virt_acpi_build(vms, &tables);
+ */
 static
 void virt_acpi_build(VirtMachineState *vms, AcpiBuildTables *tables)
 {
diff --git a/hw/block/virtio-blk.c b/hw/block/virtio-blk.c
index 73bdfd612..19fd25ddb 100644
--- a/hw/block/virtio-blk.c
+++ b/hw/block/virtio-blk.c
@@ -37,6 +37,47 @@
 #include "hw/virtio/virtio-blk-common.h"
 #include "qemu/coroutine.h"
 
+/*
+ * QEMU-9.0的例子.
+ *
+ * (gdb) bt
+ * #0  blk_new (ctx=0x55555716e240, perm=0, shared_perm=15) at ../block/block-backend.c:357
+ * #1  0x000055555593f279 in set_drive_helper (obj=0x5555580dc630, v=
+ *     0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, iothread=false, errp=0x7fffffffd710) at ../hw/core/qdev-properties-system.c:146
+ * #2  0x000055555593f453 in set_drive (obj=0x5555580dc630, v=0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, errp=0x7fffffffd710)
+ *     at ../hw/core/qdev-properties-system.c:190
+ * #3  0x0000555555e8b43c in field_prop_set (obj=0x5555580dc630, v=0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, errp=0x7fffffffd710)
+ *     at ../hw/core/qdev-properties.c:88
+ * #4  0x0000555555e98e36 in object_property_set (obj=0x5555580dc630, name=0x5555580de030 "drive", v=0x5555580e0fc0, errp=0x7fffffffd710) at ../qom/object.c:1472
+ * #5  0x0000555555e9c464 in property_set_alias (obj=0x5555580d4260, v=0x5555580e0e00, name=0x5555580e0d90 "drive", opaque=0x5555580de010, errp=0x7fffffffd710) at ../qom/object.c:2799
+ * #6  0x0000555555e98e36 in object_property_set (obj=0x5555580d4260, name=0x5555580e0d90 "drive", v=0x5555580e0e00, errp=0x7fffffffd710) at ../qom/object.c:1472
+ * #7  0x0000555555e9cbc1 in object_set_properties_from_qdict (obj=0x5555580d4260, qdict=0x5555580dfc70, v=0x5555580e0e00, errp=0x7fffffffd710) at ../qom/object_interfaces.c:55
+ * #8  0x0000555555e9ccbc in object_set_properties_from_keyval (obj=0x5555580d4260, qdict=0x5555580dfc70, from_json=false, errp=0x7fffffffd710) at ../qom/object_interfaces.c:73
+ * #9  0x0000555555bbc53a in qdev_device_add_from_qdict (opts=0x5555580d3220, from_json=false, errp=0x7fffffffd710) at ../system/qdev-monitor.c:712
+ * #10 0x0000555555bbc611 in qdev_device_add (opts=0x55555716d840, errp=0x5555570af7c0 <error_fatal>) at ../system/qdev-monitor.c:737
+ * #11 0x0000555555bc6d64 in device_init_func (opaque=0x0, opts=0x55555716d840, errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:1200
+ * #12 0x00005555560c439e in qemu_opts_foreach (list=0x555556f98e80 <qemu_device_opts>, func=0x555555bc6d35 <device_init_func>, opaque=0x0, errp=0x5555570af7c0 <error_fatal>)
+ *     at ../util/qemu-option.c:1135
+ * #13 0x0000555555bcac00 in qemu_create_cli_devices () at ../system/vl.c:2637
+ * #14 0x0000555555bcae46 in qmp_x_exit_preconfig (errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:2706
+ * #15 0x0000555555bcd92e in qemu_init (argc=30, argv=0x7fffffffdb18) at ../system/vl.c:3739
+ * #16 0x0000555555e8a1ef in main (argc=30, argv=0x7fffffffdb18) at ../system/main.c:47
+ *
+ * VirtIOBlock:
+ * -> BlockBackend *blk;
+ * -> VirtIOBlkConf conf;
+ *    -> BlockConf conf;
+ *       -> BlockBackend *blk;
+ *
+ * -device virtio-blk-pci,id=vblk01,num-queues=8,drive=drive01,iothread=iothread01 \
+ * -blockdev node-name=file01,driver=file,aio=threads,filename=test01.qcow2,cache.direct=on,cache.no-flush=off \
+ * -blockdev node-name=drive01,driver=qcow2,cache.direct=on,cache.no-flush=off,file=file01 \
+ *
+ *
+ * Managing the New Block Layer
+ * https://events.static.linuxfound.org/sites/events/files/slides/talk_11.pdf
+ */
+
 static void virtio_blk_ioeventfd_attach(VirtIOBlock *s);
 
 static void virtio_blk_init_request(VirtIOBlock *s, VirtQueue *vq,
diff --git a/hw/core/machine-smp.c b/hw/core/machine-smp.c
index 5d8d7edcb..414c8d56e 100644
--- a/hw/core/machine-smp.c
+++ b/hw/core/machine-smp.c
@@ -261,6 +261,13 @@ void machine_parse_smp_config(MachineState *ms,
     }
 }
 
+/*
+ * called by:
+ *   - hw/core/machine-smp.c|271| <<machine_topo_get_threads_per_socket>> return ms->smp.threads * machine_topo_get_cores_per_socket(ms);
+ *   - hw/smbios/smbios.c|711| <<smbios_build_type_4_table>> cores_per_socket = machine_topo_get_cores_per_socket(ms);
+ *   - system/cpus.c|847| <<qemu_init_vcpu>> cpu->nr_cores = machine_topo_get_cores_per_socket(ms);
+ *   - tests/unit/test-smp-parse.c|805| <<check_parse>> ms_cores_per_socket = machine_topo_get_cores_per_socket(ms);
+ */
 unsigned int machine_topo_get_cores_per_socket(const MachineState *ms)
 {
     return ms->smp.cores * ms->smp.modules * ms->smp.clusters * ms->smp.dies;
diff --git a/hw/core/machine.c b/hw/core/machine.c
index 27dcda024..e9ac54646 100644
--- a/hw/core/machine.c
+++ b/hw/core/machine.c
@@ -91,6 +91,15 @@ GlobalProperty hw_compat_7_0[] = {
 };
 const size_t hw_compat_7_0_len = G_N_ELEMENTS(hw_compat_7_0);
 
+/*
+ * 在以下使用hw_compat_6_2[]:
+ *   - hw/arm/virt.c|3376| <<virt_machine_6_2_options>> compat_props_add(mc->compat_props, hw_compat_6_2, hw_compat_6_2_len);
+ *   - hw/i386/pc_piix.c|575| <<pc_i440fx_machine_6_2_options>> compat_props_add(m->compat_props, hw_compat_6_2, hw_compat_6_2_len);
+ *   - hw/i386/pc_q35.c|451| <<pc_q35_machine_6_2_options>> compat_props_add(m->compat_props, hw_compat_6_2, hw_compat_6_2_len);
+ *   - hw/m68k/virt.c|426| <<virt_machine_6_2_options>> compat_props_add(mc->compat_props, hw_compat_6_2, hw_compat_6_2_len);
+ *   - hw/ppc/spapr.c|4933| <<spapr_machine_6_2_class_options>> compat_props_add(mc->compat_props, hw_compat_6_2, hw_compat_6_2_len);
+ *   - hw/s390x/s390-virtio-ccw.c|1000| <<ccw_machine_6_2_class_options>> compat_props_add(mc->compat_props, hw_compat_6_2, hw_compat_6_2_len);
+ */
 GlobalProperty hw_compat_6_2[] = {
     { "PIIX4_PM", "x-not-migrate-acpi-index", "on"},
 };
diff --git a/hw/core/nmi.c b/hw/core/nmi.c
index a7bce8a04..306ebf601 100644
--- a/hw/core/nmi.c
+++ b/hw/core/nmi.c
@@ -42,6 +42,18 @@ static int do_nmi(Object *o, void *opaque)
         NMIClass *nc = NMI_GET_CLASS(n);
 
         ns->handled = true;
+        /*
+	 * 在以下设置nc->nmi_monitor_handler:
+	 *   - hw/hppa/machine.c|712| <<HP_B160L_machine_init_class_init>> nc->nmi_monitor_handler = hppa_nmi;
+	 *   - hw/hppa/machine.c|748| <<HP_C3700_machine_init_class_init>> nc->nmi_monitor_handler = hppa_nmi;
+	 *   - hw/i386/x86.c|387| <<x86_machine_class_init>> nc->nmi_monitor_handler = x86_nmi;
+	 *   - hw/intc/m68k_irqc.c|101| <<m68k_irqc_class_init>> nc->nmi_monitor_handler = m68k_nmi;
+	 *   - hw/m68k/q800-glue.c|241| <<glue_class_init>> nc->nmi_monitor_handler = glue_nmi;
+	 *   - hw/misc/macio/gpio.c|199| <<macio_gpio_class_init>> nc->nmi_monitor_handler = macio_gpio_nmi;
+	 *   - hw/ppc/pnv.c|2861| <<pnv_machine_class_init>> nc->nmi_monitor_handler = pnv_nmi;
+	 *   - hw/ppc/spapr.c|4723| <<spapr_machine_class_init>> nc->nmi_monitor_handler = spapr_nmi;
+	 *   - hw/s390x/s390-virtio-ccw.c|785| <<ccw_machine_class_init>> nc->nmi_monitor_handler = s390_nmi;
+	 */
         nc->nmi_monitor_handler(n, ns->cpu_index, &ns->err);
         if (ns->err) {
             return -1;
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index f3a996f57..26c4b08e2 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -701,6 +701,9 @@ static void device_finalize(Object *obj)
     if (dev->pending_deleted_event) {
         g_assert(dev->canonical_path);
 
+	/*
+	 * 只在此处调用qapi_event_send_device_deleted()
+	 */
         qapi_event_send_device_deleted(dev->id, dev->canonical_path);
         g_free(dev->canonical_path);
         dev->canonical_path = NULL;
diff --git a/hw/display/virtio-dmabuf.c b/hw/display/virtio-dmabuf.c
index 3dba4577c..61c4e5886 100644
--- a/hw/display/virtio-dmabuf.c
+++ b/hw/display/virtio-dmabuf.c
@@ -27,6 +27,11 @@ static int uuid_equal_func(const void *lhv, const void *rhv)
     return qemu_uuid_is_equal(lhv, rhv);
 }
 
+/*
+ * called by:
+ *   - hw/display/virtio-dmabuf.c|61| <<virtio_add_dmabuf>> result = virtio_add_resource(uuid, vso);
+ *   - hw/display/virtio-dmabuf.c|79| <<virtio_add_vhost_device>> result = virtio_add_resource(uuid, vso);
+ */
 static bool virtio_add_resource(QemuUUID *uuid, VirtioSharedObject *value)
 {
     bool result = true;
@@ -48,6 +53,14 @@ static bool virtio_add_resource(QemuUUID *uuid, VirtioSharedObject *value)
     return result;
 }
 
+/*
+ * called by:
+ *   - tests/unit/test-virtio-dmabuf.c|34| <<test_add_remove_resources>> g_assert(virtio_add_dmabuf(&uuid, dmabuf_fd));
+ *   - tests/unit/test-virtio-dmabuf.c|84| <<test_add_invalid_resource>> g_assert_false(virtio_add_dmabuf(&uuid, dmabuf_fd));
+ *   - tests/unit/test-virtio-dmabuf.c|97| <<test_add_invalid_resource>> g_assert(virtio_add_dmabuf(&uuid, dmabuf_fd));
+ *   - tests/unit/test-virtio-dmabuf.c|100| <<test_add_invalid_resource>> g_assert_false(virtio_add_dmabuf(&uuid, alt_dmabuf));
+ *   - tests/unit/test-virtio-dmabuf.c|114| <<test_free_resources>> g_assert(virtio_add_dmabuf(&uuids[i], dmabuf_fd));
+ */
 bool virtio_add_dmabuf(QemuUUID *uuid, int udmabuf_fd)
 {
     bool result;
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 7779c88a9..abb10303b 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -812,6 +812,11 @@ static hwaddr pc_max_used_gpa(PCMachineState *pcms, uint64_t pci_hole64_size)
 #define AMD_ABOVE_1TB_START  (AMD_HT_END + 1)
 #define AMD_HT_SIZE          (AMD_ABOVE_1TB_START - AMD_HT_START)
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|225| <<pc_init1>> pc_memory_init(pcms, system_memory, rom_memory, hole64_size);
+ *   - hw/i386/pc_q35.c|205| <<pc_q35_init>> pc_memory_init(pcms, system_memory, pci_memory, pci_hole64_size);
+ */
 void pc_memory_init(PCMachineState *pcms,
                     MemoryRegion *system_memory,
                     MemoryRegion *rom_memory,
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index 347afa4c3..f16093165 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -99,6 +99,12 @@ static void piix_intx_routing_notifier_xen(PCIDevice *dev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|415| <<pc_init_isa>> pc_init1(machine, NULL);
+ *   - hw/i386/pc_piix.c|425| <<pc_xen_hvm_init_pci>> pc_init1(machine, pci_type);
+ *   - hw/i386/pc_piix.c|445| <<pc_i440fx_init>> pc_init1(machine, TYPE_I440FX_PCI_DEVICE);
+ */
 /* PC hardware initialisation */
 static void pc_init1(MachineState *machine, const char *pci_type)
 {
@@ -569,6 +575,10 @@ static void pc_i440fx_machine_7_0_options(MachineClass *m)
 
 DEFINE_I440FX_MACHINE(7, 0);
 
+/*
+ * 在以下使用pc_i440fx_machine_6_2_options():
+ *   - hw/i386/pc_piix.c|583| <<pc_i440fx_machine_6_1_options>> pc_i440fx_machine_6_2_options(m);
+ */
 static void pc_i440fx_machine_6_2_options(MachineClass *m)
 {
     pc_i440fx_machine_7_0_options(m);
diff --git a/hw/i386/x86-common.c b/hw/i386/x86-common.c
index 992ea1f25..2958863d2 100644
--- a/hw/i386/x86-common.c
+++ b/hw/i386/x86-common.c
@@ -623,6 +623,12 @@ static bool load_elfboot(const char *kernel_filename,
     return true;
 }
 
+/*
+ * 在以下使用x86_load_linux():
+ *   - hw/i386/microvm.c|331| <<microvm_memory_init>> x86_load_linux(x86ms, fw_cfg, 0, true);
+ *   - hw/i386/pc.c|661| <<xen_load_linux>> x86_load_linux(x86ms, fw_cfg, PC_FW_DATA, pcmc->pvh_enabled);
+ *   - hw/i386/pc.c|1000| <<pc_memory_init>> x86_load_linux(x86ms, fw_cfg, PC_FW_DATA, pcmc->pvh_enabled);
+ */
 void x86_load_linux(X86MachineState *x86ms,
                     FWCfgState *fw_cfg,
                     int acpi_data_size,
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index ed33a3287..a27de45a8 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -1234,6 +1234,13 @@ static int virtio_net_handle_announce(VirtIONet *n, uint8_t cmd,
     }
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|1272| <<virtio_net_attach_epbf_rss>> if (!virtio_net_attach_ebpf_to_backend(n->nic, n->ebpf_rss.program_fd)) {
+ *   - hw/net/virtio-net.c|1281| <<virtio_net_detach_epbf_rss>> virtio_net_attach_ebpf_to_backend(n->nic, -1);
+ *   - hw/net/virtio-net.c|1355| <<virtio_net_load_ebpf>> if (virtio_net_attach_ebpf_to_backend(n->nic, -1)) {
+ *   - hw/net/virtio-net.c|1366| <<virtio_net_unload_ebpf>> virtio_net_attach_ebpf_to_backend(n->nic, -1);
+ */
 static bool virtio_net_attach_ebpf_to_backend(NICState *nic, int prog_fd)
 {
     NetClientState *nc = qemu_get_peer(qemu_get_queue(nic), 0);
@@ -1254,6 +1261,10 @@ static void rss_data_to_rss_config(struct VirtioNetRssData *data,
     config->default_queue = data->default_queue;
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|1290| <<virtio_net_commit_rss_config>> } else if (!virtio_net_attach_epbf_rss(n)) {
+ */
 static bool virtio_net_attach_epbf_rss(VirtIONet *n)
 {
     struct EBPFRSSConfig config = {};
@@ -1281,6 +1292,12 @@ static void virtio_net_detach_epbf_rss(VirtIONet *n)
     virtio_net_attach_ebpf_to_backend(n->nic, -1);
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|1315| <<virtio_net_disable_rss>> virtio_net_commit_rss_config(n);
+ *   - hw/net/virtio-net.c|1482| <<virtio_net_handle_rss>> virtio_net_commit_rss_config(n);
+ *   - hw/net/virtio-net.c|3095| <<virtio_net_post_load_device>> virtio_net_commit_rss_config(n);
+ */
 static void virtio_net_commit_rss_config(VirtIONet *n)
 {
     if (n->rss_data.enabled) {
@@ -1367,6 +1384,11 @@ static void virtio_net_unload_ebpf(VirtIONet *n)
     ebpf_rss_unload(&n->ebpf_rss);
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|1499| <<virtio_net_handle_mq>> queue_pairs = virtio_net_handle_rss(n, iov, iov_cnt, false);
+ *   - hw/net/virtio-net.c|1503| <<virtio_net_handle_mq>> queue_pairs = virtio_net_handle_rss(n, iov, iov_cnt, true);
+ */
 static uint16_t virtio_net_handle_rss(VirtIONet *n,
                                       struct iovec *iov,
                                       unsigned int iov_cnt,
@@ -1487,6 +1509,10 @@ error:
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|1574| <<virtio_net_handle_ctrl_iov>> status = virtio_net_handle_mq(n, ctrl.cmd, iov, out_num);
+ */
 static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,
                                 struct iovec *iov, unsigned int iov_cnt)
 {
@@ -1540,6 +1566,11 @@ static int virtio_net_handle_mq(VirtIONet *n, uint8_t cmd,
     return VIRTIO_NET_OK;
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|1597| <<virtio_net_handle_ctrl>> written = virtio_net_handle_ctrl_iov(vdev, elem->in_sg, elem->in_num,
+ *   - net/vhost-vdpa.c|1556| <<vhost_vdpa_net_handle_ctrl_avail>> virtio_net_handle_ctrl_iov(svq->vdev, &model_in, 1, &out, 1);
+ */
 size_t virtio_net_handle_ctrl_iov(VirtIODevice *vdev,
                                   const struct iovec *in_sg, unsigned in_num,
                                   const struct iovec *out_sg,
@@ -1583,6 +1614,11 @@ size_t virtio_net_handle_ctrl_iov(VirtIODevice *vdev,
     return sizeof(status);
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|3022| <<virtio_net_change_num_queue_pairs>> n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
+ *   - hw/net/virtio-net.c|3704| <<virtio_net_device_realize>> n->ctrl_vq = virtio_add_queue(vdev, 64, virtio_net_handle_ctrl);
+ */
 static void virtio_net_handle_ctrl(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtQueueElement *elem;
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index fc0263f34..a221c155c 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -915,6 +915,18 @@ static int get_fw_cfg_order(FWCfgState *s, const char *name)
     return FW_CFG_ORDER_OVERRIDE_LAST;
 }
 
+/*
+ * called by:
+ *   - hw/acpi/ghes.c|385| <<acpi_ghes_add_fw_cfg>> fw_cfg_add_file_callback(s, ACPI_GHES_DATA_ADDR_FW_CFG_FILE, NULL, NULL, NULL, &(ags->ghes_addr_le), sizeof(ags->ghes_addr_le), false);
+ *   - hw/acpi/vmgenid.c|129| <<vmgenid_add_fw_cfg>> fw_cfg_add_file_callback(s, VMGENID_ADDR_FW_CFG_FILE, NULL, NULL, NULL, vms->vmgenid_addr_le, ARRAY_SIZE(vms->vmgenid_addr_le), false);
+ *   - hw/core/loader.c|1175| <<rom_add_blob>> fw_cfg_add_file_callback(fw_cfg, fw_file_name, fw_callback, NULL, callback_opaque, data, rom->datasize, read_only);
+ *   - hw/display/ramfb.c|151| <<ramfb_setup>> fw_cfg_add_file_callback(fw_cfg, "etc/ramfb", NULL, ramfb_fw_cfg_write, s, &s->cfg, sizeof(s->cfg), false);
+ *   - hw/isa/lpc_ich9.c|443| <<ich9_lpc_pm_init>> fw_cfg_add_file_callback(fw_cfg, "etc/smi/requested-features", NULL, NULL, NULL, lpc->smi_guest_features_le, sizeof lpc->smi_guest_features_le, false);
+ *   - hw/isa/lpc_ich9.c|448| <<ich9_lpc_pm_init>> fw_cfg_add_file_callback(fw_cfg, "etc/smi/features-ok", smi_features_ok_callback, NULL, lpc, &lpc->smi_features_ok, sizeof lpc->smi_features_ok, true);
+ *   - hw/misc/vmcoreinfo.c|60| <<vmcoreinfo_realize>> fw_cfg_add_file_callback(fw_cfg, FW_CFG_VMCOREINFO_FILENAME, NULL, fw_cfg_vmci_write, s, &s->vmcoreinfo, sizeof(s->vmcoreinfo), false);
+ *   - hw/nvram/fw_cfg.c|1047| <<fw_cfg_add_file>> fw_cfg_add_file_callback(s, filename, NULL, NULL, NULL, data, len, true);
+ *   - hw/nvram/fw_cfg.c|1073| <<fw_cfg_modify_file>> fw_cfg_add_file_callback(s, filename, NULL, NULL, NULL, data, len, true);
+ */
 void fw_cfg_add_file_callback(FWCfgState *s,  const char *filename,
                               FWCfgCallback select_cb,
                               FWCfgWriteCallback write_cb,
@@ -994,6 +1006,53 @@ void fw_cfg_add_file_callback(FWCfgState *s,  const char *filename,
     fw_cfg_acpi_mr_save(s, filename, len);
 }
 
+/*
+ * called by:
+ *   - hw/acpi/core.c|641| <<acpi_pm1_cnt_init>> fw_cfg_add_file(fw_cfg, "etc/system-states", g_memdup(suspend, 6), 6);
+ *   - hw/acpi/ghes.c|381| <<acpi_ghes_add_fw_cfg>> fw_cfg_add_file(s, ACPI_GHES_ERRORS_FW_CFG_FILE, hardware_error->data, hardware_error->len);
+ *   - hw/acpi/nvdimm.c|906| <<nvdimm_init_acpi_state>> fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data, state->dsm_mem->len);
+ *   - hw/acpi/vmgenid.c|126| <<vmgenid_add_fw_cfg>> fw_cfg_add_file(s, VMGENID_GUID_FW_CFG_FILE, guid->data, VMGENID_FW_CFG_SIZE);
+ *   - hw/arm/virt-acpi-build.c|1109| <<virt_acpi_setup>> fw_cfg_add_file(vms->fw_cfg, ACPI_BUILD_TPMLOG_FILE, tables.tcpalog->data, acpi_data_len(tables.tcpalog));
+ *   - hw/arm/virt.c|1714| <<virt_build_smbios>> fw_cfg_add_file(vms->fw_cfg, "etc/smbios/smbios-tables", smbios_tables, smbios_tables_len);
+ *   - hw/arm/virt.c|1716| <<virt_build_smbios>> fw_cfg_add_file(vms->fw_cfg, "etc/smbios/smbios-anchor", smbios_anchor, smbios_anchor_len);
+ *   - hw/core/loader.c|1121| <<rom_add_file>> fw_cfg_add_file(fw_cfg, fw_file_name, data, rom->romsize);
+ *   - hw/hppa/machine.c|209| <<create_fw_cfg>> fw_cfg_add_file(fw_cfg, "/etc/firmware-min-version", g_memdup2(&val, sizeof(val)), sizeof(val));
+ *   - hw/hppa/machine.c|213| <<create_fw_cfg>> fw_cfg_add_file(fw_cfg, "/etc/cpu/tlb_entries", g_memdup2(&val, sizeof(val)), sizeof(val));
+ *   - hw/hppa/machine.c|217| <<create_fw_cfg>> fw_cfg_add_file(fw_cfg, "/etc/cpu/btlb_entries", g_memdup2(&val, sizeof(val)), sizeof(val));
+ *   - hw/hppa/machine.c|221| <<create_fw_cfg>> fw_cfg_add_file(fw_cfg, "/etc/hppa/machine", g_memdup2(mc->name, len), len);
+ *   - hw/hppa/machine.c|225| <<create_fw_cfg>> fw_cfg_add_file(fw_cfg, "/etc/hppa/power-button-addr", g_memdup2(&val, sizeof(val)), sizeof(val));
+ *   - hw/hppa/machine.c|229| <<create_fw_cfg>> fw_cfg_add_file(fw_cfg, "/etc/hppa/rtc-addr", g_memdup2(&val, sizeof(val)), sizeof(val));
+ *   - hw/hppa/machine.c|233| <<create_fw_cfg>> fw_cfg_add_file(fw_cfg, "/etc/hppa/DebugOutputPort", g_memdup2(&val, sizeof(val)), sizeof(val));
+ *   - hw/hppa/machine.c|239| <<create_fw_cfg>> fw_cfg_add_file(fw_cfg, "/etc/qemu-version", g_memdup2(qemu_version, sizeof(qemu_version)), sizeof(qemu_version));
+ *   - hw/i386/acpi-build.c|2782| <<acpi_setup>> fw_cfg_add_file(x86ms->fw_cfg, ACPI_BUILD_TPMLOG_FILE, tables.tcpalog->data, acpi_data_len(tables.tcpalog));
+ *   - hw/i386/acpi-build.c|2792| <<acpi_setup>> fw_cfg_add_file(x86ms->fw_cfg, "etc/tpm/config", &tpm_config, sizeof tpm_config);
+ *   - hw/i386/fw_cfg.c|57| <<fw_cfg_add_e820>> fw_cfg_add_file(fw_cfg, "etc/e820", table, nr_e820 * sizeof(*table));
+ *   - hw/i386/fw_cfg.c|109| <<fw_cfg_build_smbios>> fw_cfg_add_file(fw_cfg, "etc/smbios/smbios-tables", smbios_tables, smbios_tables_len);
+ *   - hw/i386/fw_cfg.c|111| <<fw_cfg_build_smbios>> fw_cfg_add_file(fw_cfg, "etc/smbios/smbios-anchor", smbios_anchor, smbios_anchor_len);
+ *   - hw/i386/fw_cfg.c|210| <<fw_cfg_build_feature_control>> fw_cfg_add_file(fw_cfg, "etc/msr_feature_control", val, sizeof(*val));
+ *   - hw/i386/microvm-dt.c|336| <<dt_setup_microvm>> fw_cfg_add_file(x86ms->fw_cfg, "etc/fdt", mms->fdt, size);
+ *   - hw/i386/pc.c|996| <<pc_memory_init>> fw_cfg_add_file(fw_cfg, "etc/reserved-memory-end", val, sizeof(*val));
+ *   - hw/isa/lpc_ich9.c|436| <<ich9_lpc_pm_init>> fw_cfg_add_file(fw_cfg, "etc/smi/supported-features", lpc->smi_host_features_le, sizeof lpc->smi_host_features_le);
+ *   - hw/loongarch/acpi-build.c|649| <<loongarch_acpi_setup>> fw_cfg_add_file(lvms->fw_cfg, ACPI_BUILD_TPMLOG_FILE, tables.tcpalog->data, acpi_data_len(tables.tcpalog));
+ *   - hw/loongarch/virt.c|567| <<virt_build_smbios>> fw_cfg_add_file(lvms->fw_cfg, "etc/smbios/smbios-tables", smbios_tables, smbios_tables_len);
+ *   - hw/loongarch/virt.c|569| <<virt_build_smbios>> fw_cfg_add_file(lvms->fw_cfg, "etc/smbios/smbios-anchor", smbios_anchor, smbios_anchor_len);
+ *   - hw/loongarch/virt.c|1171| <<virt_init>> fw_cfg_add_file(lvms->fw_cfg, "etc/memmap", memmap_table, sizeof(struct memmap_entry) * (memmap_entries));
+ *   - hw/mips/loongson3_virt.c|296| <<fw_conf_init>> fw_cfg_add_file(fw_cfg, "etc/system-states", g_memdup2(suspend, sizeof(suspend)), sizeof(suspend));
+ *   - hw/misc/pvpanic-isa.c|60| <<pvpanic_isa_realizefn>> fw_cfg_add_file(fw_cfg, "etc/pvpanic-port", pvpanic_port, sizeof(*pvpanic_port));
+ *   - hw/nvram/fw_cfg.c|200| <<fw_cfg_bootsplash>> fw_cfg_add_file(s, "etc/boot-menu-wait", g_memdup(&bst_le16, sizeof bst_le16), sizeof bst_le16);
+ *   - hw/nvram/fw_cfg.c|224| <<fw_cfg_bootsplash>> fw_cfg_add_file(s, "bootsplash.jpg", boot_splash_filedata, file_size);
+ *   - hw/nvram/fw_cfg.c|227| <<fw_cfg_bootsplash>> fw_cfg_add_file(s, "bootsplash.bmp", boot_splash_filedata, file_size);
+ *   - hw/nvram/fw_cfg.c|251| <<fw_cfg_reboot>> fw_cfg_add_file(s, "etc/boot-fail-wait", g_memdup(&rt_le32, 4), 4);
+ *   - hw/nvram/fw_cfg.c|1054| <<fw_cfg_add_from_generator>> fw_cfg_add_file(s, filename, g_byte_array_free(array, FALSE), size);
+ *   - hw/nvram/fw_cfg.c|1077| <<fw_cfg_add_extra_pci_roots>> fw_cfg_add_file(s, "etc/extra-pci-roots", val, sizeof(*val));
+ *   - hw/ppc/mac_newworld.c|521| <<ppc_core99_init>> fw_cfg_add_file(fw_cfg, "ndrv/qemu_vga.ndrv", ndrv_file, ndrv_size);
+ *   - hw/ppc/mac_oldworld.c|360| <<ppc_heathrow_init>> fw_cfg_add_file(fw_cfg, "ndrv/qemu_vga.ndrv", ndrv_file, ndrv_size);
+ *   - hw/riscv/virt.c|1325| <<virt_build_smbios>> fw_cfg_add_file(s->fw_cfg, "etc/smbios/smbios-tables", smbios_tables, smbios_tables_len);
+ *   - hw/riscv/virt.c|1327| <<virt_build_smbios>> fw_cfg_add_file(s->fw_cfg, "etc/smbios/smbios-anchor", smbios_anchor, smbios_anchor_len);
+ *   - hw/vfio/igd.c|567| <<vfio_probe_igd_bar4_quirk>> fw_cfg_add_file(fw_cfg_find(), "etc/igd-bdsm-size", bdsm_size, sizeof(*bdsm_size));
+ *   - hw/vfio/pci-quirks.c|1200| <<vfio_pci_igd_opregion_init>> fw_cfg_add_file(fw_cfg_find(), "etc/igd-opregion", vdev->igd_opregion, info->size);
+ *   - system/vl.c|1201| <<parse_fw_cfg>> fw_cfg_add_file(fw_cfg, name, buf, size);
+ */
 void fw_cfg_add_file(FWCfgState *s,  const char *filename,
                      void *data, size_t len)
 {
diff --git a/hw/pci/pci_bridge.c b/hw/pci/pci_bridge.c
index 6a4e38856..8a8d3bdc8 100644
--- a/hw/pci/pci_bridge.c
+++ b/hw/pci/pci_bridge.c
@@ -417,6 +417,12 @@ void pci_bridge_map_irq(PCIBridge *br, const char* bus_name,
 }
 
 
+/*
+ * called by:
+ *   - hw/pci-bridge/cxl_root_port.c|163| <<cxl_rp_realize>> pci_bridge_qemu_reserve_cap_init(pci_dev, 0, crp->res_reserve, errp);
+ *   - hw/pci-bridge/gen_pcie_root_port.c|98| <<gen_rp_realize>> int rc = pci_bridge_qemu_reserve_cap_init(d, 0, grp->res_reserve, errp);
+ *   - hw/pci-bridge/pci_bridge_dev.c|102| <<pci_bridge_dev_realize>> err = pci_bridge_qemu_reserve_cap_init(dev, 0, bridge_dev->res_reserve, errp);
+ */
 int pci_bridge_qemu_reserve_cap_init(PCIDevice *dev, int cap_offset,
                                      PCIResReserve res_reserve, Error **errp)
 {
diff --git a/hw/pci/pcie.c b/hw/pci/pcie.c
index 4b2f0805c..5c691f0d4 100644
--- a/hw/pci/pcie.c
+++ b/hw/pci/pcie.c
@@ -182,6 +182,17 @@ static void pcie_cap_fill_slot_lnk(PCIDevice *dev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci-bridge/cxl_downstream.c|156| <<cxl_dsp_realize>> rc = pcie_cap_init(d, CXL_DOWNSTREAM_PORT_EXP_OFFSET, PCI_EXP_TYPE_DOWNSTREAM, p->port, errp);
+ *   - hw/pci-bridge/cxl_upstream.c|310| <<cxl_usp_realize>> rc = pcie_cap_init(d, CXL_UPSTREAM_PORT_PCIE_CAP_OFFSET, PCI_EXP_TYPE_UPSTREAM, p->port, errp);
+ *   - hw/pci-bridge/pcie_pci_bridge.c|50| <<pcie_pci_bridge_realize>> rc = pcie_cap_init(d, 0, PCI_EXP_TYPE_PCI_BRIDGE, 0, errp);
+ *   - hw/pci-bridge/pcie_root_port.c|92| <<rp_realize>> rc = pcie_cap_init(d, rpc->exp_offset, PCI_EXP_TYPE_ROOT_PORT, p->port, errp);
+ *   - hw/pci-bridge/xio3130_downstream.c|91| <<xio3130_downstream_realize>> rc = pcie_cap_init(d, XIO3130_EXP_OFFSET, PCI_EXP_TYPE_DOWNSTREAM, p->port, errp);
+ *   - hw/pci-bridge/xio3130_upstream.c|81| <<xio3130_upstream_realize>> rc = pcie_cap_init(d, XIO3130_EXP_OFFSET, PCI_EXP_TYPE_UPSTREAM, p->port, errp);
+ *   - hw/pci-host/designware.c|419| <<designware_pcie_root_realize>> pcie_cap_init(dev, 0x70, PCI_EXP_TYPE_ROOT_PORT, 0, &error_fatal);
+ *   -  hw/pci/pcie.c|265| <<pcie_endpoint_cap_common_init>> ret = pcie_cap_init(dev, offset, type, 0, &local_err);
+ */
 int pcie_cap_init(PCIDevice *dev, uint8_t offset,
                   uint8_t type, uint8_t port,
                   Error **errp)
diff --git a/hw/pci/pcie_aer.c b/hw/pci/pcie_aer.c
index 2c85a78fc..d8225274c 100644
--- a/hw/pci/pcie_aer.c
+++ b/hw/pci/pcie_aer.c
@@ -636,6 +636,13 @@ static bool pcie_aer_inject_uncor_error(PCIEAERInject *inj, bool is_fatal)
  * Figure 6-2: Flowchart Showing Sequence of Device Error Signaling and Logging
  *             Operations
  */
+/*
+ * called by:
+ *   - hw/mem/cxl_type3.c|1494| <<qmp_cxl_inject_uncorrectable_errors>> pcie_aer_inject_error(PCI_DEVICE(obj), &err);
+ *   - hw/mem/cxl_type3.c|1540| <<qmp_cxl_inject_correctable_error>> pcie_aer_inject_error(PCI_DEVICE(obj), &err);
+ *   - hw/pci/pci-hmp-cmds.c|226| <<hmp_pcie_aer_inject_error>> ret = pcie_aer_inject_error(dev, &aer_err);
+ *   - hw/pci/pcie_aer.c|712| <<pcie_aer_inject_error>> int ret = pcie_aer_inject_error(dev, &header_log_overflow);
+ */
 int pcie_aer_inject_error(PCIDevice *dev, const PCIEAERErr *err)
 {
     uint8_t *aer_cap = NULL;
diff --git a/hw/pci/pcie_port.c b/hw/pci/pcie_port.c
index 20ff2b39e..b343e2757 100644
--- a/hw/pci/pcie_port.c
+++ b/hw/pci/pcie_port.c
@@ -136,6 +136,13 @@ static void pcie_port_class_init(ObjectClass *oc, void *data)
     device_class_set_props(dc, pcie_port_props);
 }
 
+/*
+ * called by:
+ *   - hw/cxl/cxl-host.c|193| <<cxl_cfmws_find_device>> rp = pcie_find_port_by_pn(hb->bus, target);
+ *   - hw/cxl/cxl-host.c|229| <<cxl_cfmws_find_device>> d = pcie_find_port_by_pn(&PCI_BRIDGE(d)->sec_bus, target);
+ *   - hw/cxl/cxl-mailbox-utils.c|189| <<cmd_tunnel_management_cmd>> tunnel_target = pcie_find_port_by_pn(&PCI_BRIDGE(usp)->sec_bus, in->port_or_ld_id);
+ *   - hw/cxl/cxl-mailbox-utils.c|540| <<cmd_get_physical_port_state>> port_dev = pcie_find_port_by_pn(bus, in->ports[i]);
+ */
 PCIDevice *pcie_find_port_by_pn(PCIBus *bus, uint8_t pn)
 {
     int devfn;
diff --git a/hw/scsi/megasas.c b/hw/scsi/megasas.c
index 2d0c60717..ac2869125 100644
--- a/hw/scsi/megasas.c
+++ b/hw/scsi/megasas.c
@@ -37,6 +37,12 @@
 #include "migration/vmstate.h"
 #include "qom/object.h"
 
+/*
+ * 这个文档:
+ * A Practical Look at QEMU's Block Layer Primitives
+ * https://kashyapc.fedorapeople.org/virt/LinuxCon-NA-2016/A-Practical-Look-at-QEMU-Block-Layer-Primitives-LC-NA-2016.pdf
+ */
+
 #define MEGASAS_VERSION_GEN1 "1.70"
 #define MEGASAS_VERSION_GEN2 "1.80"
 #define MEGASAS_MAX_FRAMES 2048         /* Firmware limit at 65535 */
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index 53eff5dd3..74e459688 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -17,6 +17,12 @@
 #include "sysemu/dma.h"
 #include "qemu/cutils.h"
 
+/*
+ * 这个文档:
+ * A Practical Look at QEMU's Block Layer Primitives
+ * https://kashyapc.fedorapeople.org/virt/LinuxCon-NA-2016/A-Practical-Look-at-QEMU-Block-Layer-Primitives-LC-NA-2016.pdf
+ */
+
 static char *scsibus_get_dev_path(DeviceState *dev);
 static char *scsibus_get_fw_dev_path(DeviceState *dev);
 static void scsi_req_dequeue(SCSIRequest *req);
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index 4d94b2b81..4d8833768 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -47,6 +47,12 @@
 #include <scsi/sg.h>
 #endif
 
+/*
+ * 这个文档:
+ * A Practical Look at QEMU's Block Layer Primitives
+ * https://kashyapc.fedorapeople.org/virt/LinuxCon-NA-2016/A-Practical-Look-at-QEMU-Block-Layer-Primitives-LC-NA-2016.pdf
+ */
+
 #define SCSI_WRITE_SAME_MAX         (512 * KiB)
 #define SCSI_DMA_BUF_SIZE           (128 * KiB)
 #define SCSI_MAX_INQUIRY_LEN        256
@@ -96,6 +102,16 @@ typedef struct SCSIDiskReq {
 #define SCSI_DISK_F_NO_REMOVABLE_DEVOPS   2
 
 struct SCSIDiskState {
+    /*
+     * 3228 static Property scsi_block_properties[] = {
+     * 3229     DEFINE_BLOCK_ERROR_PROPERTIES(SCSIDiskState, qdev.conf),
+     * 3230     DEFINE_PROP_DRIVE("drive", SCSIDiskState, qdev.conf.blk),
+     *
+     * struct SCSIDiskState:
+     * -> SCSIDevice qdev;
+     *    -> BlockConf conf;
+     *       -> BlockBackend *blk;
+     */
     SCSIDevice qdev;
     uint32_t features;
     bool media_changed;
@@ -3266,6 +3282,16 @@ static const TypeInfo scsi_cd_info = {
     .class_init    = scsi_cd_class_initfn,
 };
 
+/*
+ * 3228 static Property scsi_block_properties[] = {
+ * 3229     DEFINE_BLOCK_ERROR_PROPERTIES(SCSIDiskState, qdev.conf),
+ * 3230     DEFINE_PROP_DRIVE("drive", SCSIDiskState, qdev.conf.blk),
+ *
+ * struct SCSIDiskState:
+ * -> SCSIDevice qdev;
+ *    -> BlockConf conf;
+ *       -> BlockBackend *blk;
+ */
 #ifdef __linux__
 static Property scsi_block_properties[] = {
     DEFINE_BLOCK_ERROR_PROPERTIES(SCSIDiskState, qdev.conf),
diff --git a/hw/scsi/scsi-generic.c b/hw/scsi/scsi-generic.c
index ee945f87e..4fd08858a 100644
--- a/hw/scsi/scsi-generic.c
+++ b/hw/scsi/scsi-generic.c
@@ -33,6 +33,12 @@
 #define MAX_UINT ((unsigned int)-1)
 #endif
 
+/*
+ * 这个文档:
+ * A Practical Look at QEMU's Block Layer Primitives
+ * https://kashyapc.fedorapeople.org/virt/LinuxCon-NA-2016/A-Practical-Look-at-QEMU-Block-Layer-Primitives-LC-NA-2016.pdf
+ */
+
 typedef struct SCSIGenericReq {
     SCSIRequest req;
     uint8_t *buf;
diff --git a/hw/scsi/vhost-scsi.c b/hw/scsi/vhost-scsi.c
index 49cff2a0c..67ee72f40 100644
--- a/hw/scsi/vhost-scsi.c
+++ b/hw/scsi/vhost-scsi.c
@@ -60,6 +60,10 @@ static int vhost_scsi_set_endpoint(VHostSCSI *s)
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/vhost-scsi.c|113| <<vhost_scsi_stop>> vhost_scsi_clear_endpoint(s);
+ */
 static void vhost_scsi_clear_endpoint(VHostSCSI *s)
 {
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);
@@ -106,6 +110,10 @@ static int vhost_scsi_start(VHostSCSI *s)
     return ret;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/vhost-scsi.c|140| <<vhost_scsi_set_status>> vhost_scsi_stop(s);
+ */
 static void vhost_scsi_stop(VHostSCSI *s)
 {
     VHostSCSICommon *vsc = VHOST_SCSI_COMMON(s);
@@ -114,6 +122,11 @@ static void vhost_scsi_stop(VHostSCSI *s)
     vhost_scsi_common_stop(vsc);
 }
 
+/*
+ * 在以下使用vhost_scsi_set_status():
+ *   - hw/scsi/vhost-scsi.c|331| <<vhost_scsi_unrealize>> vhost_scsi_set_status(vdev, 0);
+ *   - hw/scsi/vhost-scsi.c|381| <<vhost_scsi_class_init>> vdc->set_status = vhost_scsi_set_status;
+ */
 static void vhost_scsi_set_status(VirtIODevice *vdev, uint8_t val)
 {
     VHostSCSI *s = VHOST_SCSI(vdev);
diff --git a/hw/scsi/virtio-scsi.c b/hw/scsi/virtio-scsi.c
index 9f02ceea0..e4dbd4c72 100644
--- a/hw/scsi/virtio-scsi.c
+++ b/hw/scsi/virtio-scsi.c
@@ -31,6 +31,12 @@
 #include "hw/virtio/virtio-access.h"
 #include "trace.h"
 
+/*
+ * 这个文档:
+ * A Practical Look at QEMU's Block Layer Primitives
+ * https://kashyapc.fedorapeople.org/virt/LinuxCon-NA-2016/A-Practical-Look-at-QEMU-Block-Layer-Primitives-LC-NA-2016.pdf
+ */
+
 typedef struct VirtIOSCSIReq {
     /*
      * Note:
diff --git a/hw/vfio/container.c b/hw/vfio/container.c
index 9ccdb639a..2ec666679 100644
--- a/hw/vfio/container.c
+++ b/hw/vfio/container.c
@@ -175,6 +175,10 @@ static int vfio_legacy_dma_unmap(const VFIOContainerBase *bcontainer,
     return 0;
 }
 
+/*
+ * 在以下使用vfio_legacy_dma_map():
+ *   - hw/vfio/container.c|1133| <<vfio_iommu_legacy_class_init>> vioc->dma_map = vfio_legacy_dma_map;
+ */
 static int vfio_legacy_dma_map(const VFIOContainerBase *bcontainer, hwaddr iova,
                                ram_addr_t size, void *vaddr, bool readonly)
 {
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 2407720c3..bfe3c088f 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -585,6 +585,16 @@ static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
             Error *err = NULL;
             int32_t fd;
 
+            /*
+	     * 注释
+	     * Two interrupt paths are configured per vector.  The first, is only used
+	     * for interrupts injected via QEMU.  This is typically the non-accel path,
+	     * but may also be used when we want QEMU to handle masking and pending
+	     * bits.  The KVM path bypasses QEMU and is therefore higher performance,
+	     * but requires masking at the device.  virq is used to track the MSI route
+	     * through KVM, thus kvm_interrupt is only available when virq is set to a
+	     * valid (>= 0) value.
+	     */
             if (vector->virq >= 0) {
                 fd = event_notifier_get_fd(&vector->kvm_interrupt);
             } else {
@@ -600,6 +610,9 @@ static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
         }
     }
 
+    /*
+     * 这里会改变memslots!!!
+     */
     /* Disable PBA emulation when nothing more is pending. */
     clear_bit(nr, vdev->msix->pending);
     if (find_first_bit(vdev->msix->pending,
diff --git a/hw/virtio/vhost-backend.c b/hw/virtio/vhost-backend.c
index 833804dd4..29fd089ea 100644
--- a/hw/virtio/vhost-backend.c
+++ b/hw/virtio/vhost-backend.c
@@ -75,6 +75,147 @@ static int vhost_kernel_net_set_backend(struct vhost_dev *dev,
     return vhost_kernel_call(dev, VHOST_NET_SET_BACKEND, file);
 }
 
+/*
+ * Bootup on source:
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_scsi_set_endpoint (dev=0x5555585519b0, target=0x7fffeae130f0) at ../hw/virtio/vhost-backend.c:81
+ * #1  0x0000555555afe88a in vhost_scsi_set_endpoint (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:56
+ * #2  0x0000555555afeacd in vhost_scsi_start (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:100
+ * #3  0x0000555555afebd8 in vhost_scsi_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/scsi/vhost-scsi.c:134
+ * #4  0x0000555555e33c08 in virtio_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #5  0x0000555555b7b531 in virtio_pci_common_write (opaque=0x555558549290, addr=20, val=15, size=1) at ../hw/virtio/virtio-pci.c:1608
+ * #6  0x0000555555e63c32 in memory_region_write_accessor (mr=0x555558549e80, addr=20, value=0x7fffeae133f8, size=1, shift=0,
+ *     mask=255, attrs=...) at ../system/memory.c:497
+ * #7  0x0000555555e63f79 in access_with_adjusted_size (addr=20, value=0x7fffeae133f8, size=1, access_size_min=1, access_size_max=4,
+ *     access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x555558549e80, attrs=...) at ../system/memory.c:573
+ * #8  0x0000555555e674ae in memory_region_dispatch_write (mr=0x555558549e80, addr=20, data=15, op=MO_8, attrs=...) at ../system/memory.c:1521
+ * #9  0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff7e0c028 "\017", len=1, mr_addr=20, l=0x7fffeae134e0,
+ *     mr=0x555558549e80) at ../system/physmem.c:2803
+ * #10 0x0000555555e76cae in flatview_write_continue (fv=0x7ffbdc32a800, addr=4261429268, attrs=..., ptr=0x7ffff7e0c028,
+ *     len=1, mr_addr=20, l=1, mr=0x555558549e80) at ../system/physmem.c:2833
+ * #11 0x0000555555e76dd6 in flatview_write (fv=0x7ffbdc32a800, addr=4261429268, attrs=..., buf=0x7ffff7e0c028, len=1) at ../system/physmem.c:2864
+ * #12 0x0000555555e77250 in address_space_write (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1) at ../system/physmem.c:2984
+ * #13 0x0000555555e772c8 in address_space_rw (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1, is_write=true) at ../system/physmem.c:2994
+ * #14 0x0000555555ed4d63 in kvm_cpu_exec (cpu=0x5555576e1b00) at ../accel/kvm/kvm-all.c:3075
+ * #15 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x5555576e1b00) at ../accel/kvm/kvm-accel-ops.c:50
+ * #16 0x000055555616b040 in qemu_thread_start (args=0x5555576ec4a0) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #18 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_scsi_clear_endpoint (dev=0x5555585519b0, target=0x7fffeae13110) at ../hw/virtio/vhost-backend.c:87
+ * #1  0x0000555555afe9b0 in vhost_scsi_clear_endpoint (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:72
+ * #2  0x0000555555afeb3f in vhost_scsi_stop (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:113
+ * #3  0x0000555555afec1a in vhost_scsi_set_status (vdev=0x555558551710, val=0 '\000') at ../hw/scsi/vhost-scsi.c:140
+ * #4  0x0000555555e33c08 in virtio_set_status (vdev=0x555558551710, val=0 '\000') at ../hw/virtio/virtio.c:2242
+ * #5  0x0000555555b7b531 in virtio_pci_common_write (opaque=0x555558549290, addr=20, val=0, size=1) at ../hw/virtio/virtio-pci.c:1608
+ * #6  0x0000555555e63c32 in memory_region_write_accessor (mr=0x555558549e80, addr=20, value=0x7fffeae133f8, size=1, shift=0,
+ *     mask=255, attrs=...) at ../system/memory.c:497
+ * #7  0x0000555555e63f79 in access_with_adjusted_size (addr=20, value=0x7fffeae133f8, size=1, access_size_min=1, access_size_max=4,
+ *     access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x555558549e80, attrs=...) at ../system/memory.c:573
+ * #8  0x0000555555e674ae in memory_region_dispatch_write (mr=0x555558549e80, addr=20, data=0, op=MO_8, attrs=...) at ../system/memory.c:1521
+ * #9  0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff7e0c028 "", len=1, mr_addr=20,
+ *     l=0x7fffeae134e0, mr=0x555558549e80) at ../system/physmem.c:2803
+ * #10 0x0000555555e76cae in flatview_write_continue (fv=0x7ffbd8003990, addr=4261429268, attrs=..., ptr=0x7ffff7e0c028, len=1,
+ *     mr_addr=20, l=1, mr=0x555558549e80) at ../system/physmem.c:2833
+ * #11 0x0000555555e76dd6 in flatview_write (fv=0x7ffbd8003990, addr=4261429268, attrs=..., buf=0x7ffff7e0c028, len=1)
+ *     at ../system/physmem.c:2864
+ * #12 0x0000555555e77250 in address_space_write (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1) at ../system/physmem.c:2984
+ * #13 0x0000555555e772c8 in address_space_rw (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1, is_write=true) at ../system/physmem.c:2994
+ * #14 0x0000555555ed4d63 in kvm_cpu_exec (cpu=0x5555576e1b00) at ../accel/kvm/kvm-all.c:3075
+ * #15 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x5555576e1b00) at ../accel/kvm/kvm-accel-ops.c:50
+ * #16 0x000055555616b040 in qemu_thread_start (args=0x5555576ec4a0) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #18 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_scsi_set_endpoint (dev=0x5555585519b0, target=0x7fffeae130f0) at ../hw/virtio/vhost-backend.c:81
+ * #1  0x0000555555afe88a in vhost_scsi_set_endpoint (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:56
+ * #2  0x0000555555afeacd in vhost_scsi_start (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:100
+ * #3  0x0000555555afebd8 in vhost_scsi_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/scsi/vhost-scsi.c:134
+ * #4  0x0000555555e33c08 in virtio_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #5  0x0000555555b7b531 in virtio_pci_common_write (opaque=0x555558549290, addr=20, val=15, size=1) at ../hw/virtio/virtio-pci.c:1608
+ * #6  0x0000555555e63c32 in memory_region_write_accessor (mr=0x555558549e80, addr=20, value=0x7fffeae133f8, size=1, shift=0, mask=255,
+ *     attrs=...) at ../system/memory.c:497
+ * #7  0x0000555555e63f79 in access_with_adjusted_size (addr=20, value=0x7fffeae133f8, size=1, access_size_min=1,
+ *     access_size_max=4, access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x555558549e80, attrs=...) at ../system/memory.c:573
+ * #8  0x0000555555e674ae in memory_region_dispatch_write (mr=0x555558549e80, addr=20, data=15, op=MO_8, attrs=...) at ../system/memory.c:1521
+ * #9  0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff7e0c028 "\017\020", len=1, mr_addr=20,
+ *     l=0x7fffeae134e0, mr=0x555558549e80) at ../system/physmem.c:2803
+ * #10 0x0000555555e76cae in flatview_write_continue (fv=0x7ffbd8003990, addr=4261429268, attrs=..., ptr=0x7ffff7e0c028,
+ *     len=1, mr_addr=20, l=1, mr=0x555558549e80) at ../system/physmem.c:2833
+ * #11 0x0000555555e76dd6 in flatview_write (fv=0x7ffbd8003990, addr=4261429268, attrs=..., buf=0x7ffff7e0c028, len=1)
+ *     at ../system/physmem.c:2864
+ * #12 0x0000555555e77250 in address_space_write (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1) at ../system/physmem.c:2984
+ * #13 0x0000555555e772c8 in address_space_rw (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1, is_write=true) at ../system/physmem.c:2994
+ * #14 0x0000555555ed4d63 in kvm_cpu_exec (cpu=0x5555576e1b00) at ../accel/kvm/kvm-all.c:3075
+ * #15 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x5555576e1b00) at ../accel/kvm/kvm-accel-ops.c:50
+ * #16 0x000055555616b040 in qemu_thread_start (args=0x5555576ec4a0) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #18 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * -----------------
+ *
+ * Migration from source:
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_scsi_clear_endpoint (dev=0x5555585519b0, target=0x7ffbb95d5280) at ../hw/virtio/vhost-backend.c:87
+ * #1  0x0000555555afe9b0 in vhost_scsi_clear_endpoint (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:72
+ * #2  0x0000555555afeb3f in vhost_scsi_stop (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:113
+ * #3  0x0000555555afec1a in vhost_scsi_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/scsi/vhost-scsi.c:140
+ * #4  0x0000555555e33c08 in virtio_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #5  0x0000555555e36d84 in virtio_vmstate_change (opaque=0x555558551710, running=false, state=RUN_STATE_FINISH_MIGRATE)
+ *     at ../hw/virtio/virtio.c:3428
+ * #6  0x0000555555be03d7 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:405
+ * #7  0x0000555555bd0b84 in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:301
+ * #8  0x0000555555bd1b08 in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:712
+ * #9  0x0000555555bd1c83 in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:781
+ * #10 0x0000555555c11e3b in migration_stop_vm (s=0x555557400150, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:225
+ * #11 0x0000555555c17bde in migration_completion_precopy (s=0x555557400150, current_active_state=0x7ffbb95d5588)
+ *     at ../migration/migration.c:2757
+ * #12 0x0000555555c17e13 in migration_completion (s=0x555557400150) at ../migration/migration.c:2839
+ * #13 0x0000555555c18c5a in migration_iteration_run (s=0x555557400150) at ../migration/migration.c:3265
+ * #14 0x0000555555c193b8 in migration_thread (opaque=0x555557400150) at ../migration/migration.c:3531
+ * #15 0x000055555616b040 in qemu_thread_start (args=0x555557e01e50) at ../util/qemu-thread-posix.c:541
+ * #16 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #17 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * Migration to target:
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_scsi_set_endpoint (dev=0x555558552430, target=0x7fffffffd5c0) at ../hw/virtio/vhost-backend.c:81
+ * #1  0x0000555555afe88a in vhost_scsi_set_endpoint (s=0x555558552190) at ../hw/scsi/vhost-scsi.c:56
+ * #2  0x0000555555afeacd in vhost_scsi_start (s=0x555558552190) at ../hw/scsi/vhost-scsi.c:100
+ * #3  0x0000555555afebd8 in vhost_scsi_set_status (vdev=0x555558552190, val=15 '\017') at ../hw/scsi/vhost-scsi.c:134
+ * #4  0x0000555555e33c08 in virtio_set_status (vdev=0x555558552190, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #5  0x0000555555e36d2f in virtio_vmstate_change (opaque=0x555558552190, running=true, state=RUN_STATE_RUNNING)
+ *     at ../hw/virtio/virtio.c:3420
+ * #6  0x0000555555be0320 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:395
+ * #7  0x0000555555bd1be6 in vm_prepare_start (step_pending=false) at ../system/cpus.c:755
+ * #8  0x0000555555bd1c1d in vm_start () at ../system/cpus.c:762
+ * #9  0x0000555555c13324 in process_incoming_migration_bh (opaque=0x5555573fd9d0) at ../migration/migration.c:757
+ * #10 0x0000555555c120bb in migration_bh_dispatch_bh (opaque=0x555557cc41e0) at ../migration/migration.c:284
+ * #11 0x0000555556186520 in aio_bh_call (bh=0x5555573fedc0) at ../util/async.c:171
+ * #12 0x000055555618666e in aio_bh_poll (ctx=0x5555573ff890) at ../util/async.c:218
+ * #13 0x0000555556165595 in aio_dispatch (ctx=0x5555573ff890) at ../util/aio-posix.c:423
+ * #14 0x0000555556186b3d in aio_ctx_dispatch (source=0x5555573ff890, callback=0x0, user_data=0x0) at ../util/async.c:360
+ * #15 0x00007ffff6fd494b in g_main_dispatch (context=0x5555573ffd80) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x5555573ffd80) at ../glib/gmain.c:4043
+ * #17 0x0000555556188215 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561882a3 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #19 0x00005555561883d2 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555be0f17 in qemu_main_loop () at ../system/runstate.c:826
+ * #21 0x0000555556093994 in qemu_default_main () at ../system/main.c:37
+ * #22 0x00005555560939d1 in main (argc=22, argv=0x7fffffffdbd8) at ../system/main.c:48
+ */
+
 static int vhost_kernel_scsi_set_endpoint(struct vhost_dev *dev,
                                           struct vhost_scsi_target *target)
 {
@@ -92,6 +233,23 @@ static int vhost_kernel_scsi_get_abi_version(struct vhost_dev *dev, int *version
     return vhost_kernel_call(dev, VHOST_SCSI_GET_ABI_VERSION, version);
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_kernel_set_log_base (dev=0x5555573f9c50, base=140729502631248, log=0x7ffe24004fd0) at ../hw/virtio/vhost-backend.c:98
+ * #1  0x0000555555b900ac in vhost_dev_log_resize (dev=0x5555573f9c50, size=28672) at ../hw/virtio/vhost.c:450
+ * #2  0x0000555555b91c49 in vhost_migration_log (listener=0x5555573f9c58, enable=true) at ../hw/virtio/vhost.c:1092
+ * #3  0x0000555555b91ccf in vhost_log_global_start (listener=0x5555573f9c58, errp=0x7ffe23dff628) at ../hw/virtio/vhost.c:1125
+ * #4  0x0000555555e6b859 in memory_global_dirty_log_do_start (errp=0x7ffe23dff628) at ../system/memory.c:2902
+ * #5  0x0000555555e6b98d in memory_global_dirty_log_start (flags=1, errp=0x7ffe23dff628) at ../system/memory.c:2941
+ * #6  0x0000555555e84d5d in ram_init_bitmaps (rs=0x7ffe240081b0, errp=0x7ffe23dff628) at ../migration/ram.c:2782
+ * #7  0x0000555555e84e6e in ram_init_all (rsp=0x555557328500 <ram_state>, errp=0x7ffe23dff628) at ../migration/ram.c:2816
+ * #8  0x0000555555e854fc in ram_save_setup (f=0x555557671f70, opaque=0x555557328500 <ram_state>, errp=0x7ffe23dff628) at ../migration/ram.c:3010
+ * #9  0x0000555555c2fe16 in qemu_savevm_state_setup (f=0x555557671f70, errp=0x7ffe23dff628) at ../migration/savevm.c:1346
+ * #10 0x0000555555c19305 in migration_thread (opaque=0x5555573fe6a0) at ../migration/migration.c:3507
+ * #11 0x000055555616b040 in qemu_thread_start (args=0x55555777a310) at ../util/qemu-thread-posix.c:541
+ * #12 0x00007ffff5c081da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #13 0x00007ffff3839e73 in clone () from /lib/../lib64/libc.so.6
+ */
 static int vhost_kernel_set_log_base(struct vhost_dev *dev, uint64_t base,
                                      struct vhost_log *log)
 {
diff --git a/hw/virtio/vhost.c b/hw/virtio/vhost.c
index 06fc71746..bd79e3c8d 100644
--- a/hw/virtio/vhost.c
+++ b/hw/virtio/vhost.c
@@ -32,6 +32,31 @@
 /* enabled until disconnected backend stabilizes */
 #define _VHOST_DEBUG 1
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|452| <<vhost_dev_log_resize>> VHOST_OPS_DEBUG(r, "vhost_set_log_base failed");
+ *   - hw/virtio/vhost.c|705| <<vhost_commit>> VHOST_OPS_DEBUG(r, "vhost_set_mem_table failed");
+ *   - hw/virtio/vhost.c|719| <<vhost_commit>> VHOST_OPS_DEBUG(r, "vhost_set_mem_table failed");
+ *   - hw/virtio/vhost.c|968| <<vhost_virtqueue_set_addr>> VHOST_OPS_DEBUG(r, "vhost_vq_get_addr failed");
+ *   - hw/virtio/vhost.c|981| <<vhost_virtqueue_set_addr>> VHOST_OPS_DEBUG(r, "vhost_set_vring_addr failed");
+ *   - hw/virtio/vhost.c|1004| <<vhost_dev_set_features>> VHOST_OPS_DEBUG(r, "vhost_set_features failed");
+ *   - hw/virtio/vhost.c|1010| <<vhost_dev_set_features>> VHOST_OPS_DEBUG(r, "vhost_set_backend_cap failed");
+ *   - hw/virtio/vhost.c|1185| <<vhost_virtqueue_set_vring_endian_legacy>> VHOST_OPS_DEBUG(r, "vhost_set_vring_endian failed");
+ *   - hw/virtio/vhost.c|1279| <<vhost_virtqueue_start>> VHOST_OPS_DEBUG(r, "vhost_set_vring_num failed");
+ *   - hw/virtio/vhost.c|1286| <<vhost_virtqueue_start>> VHOST_OPS_DEBUG(r, "vhost_set_vring_base failed");
+ *   - hw/virtio/vhost.c|1329| <<vhost_virtqueue_start>> VHOST_OPS_DEBUG(r, "vhost_set_vring_kick failed");
+ *   - hw/virtio/vhost.c|1389| <<vhost_virtqueue_stop>> VHOST_OPS_DEBUG(r, "vhost VQ %u ring restore failed: %d", idx, r);
+ *   - hw/virtio/vhost.c|1433| <<vhost_virtqueue_set_busyloop_timeout>> VHOST_OPS_DEBUG(r, "vhost_set_vring_busyloop_timeout failed");
+ *   - hw/virtio/vhost.c|1448| <<vhost_virtqueue_error_notifier>> VHOST_OPS_DEBUG(-EINVAL, "vhost vring error in virtqueue %d",
+ *   - hw/virtio/vhost.c|1468| <<vhost_virtqueue_init>> VHOST_OPS_DEBUG(r, "vhost_set_vring_call failed");
+ *   - hw/virtio/vhost.c|1483| <<vhost_virtqueue_init>> VHOST_OPS_DEBUG(r, "vhost_set_vring_err failed");
+ *   - hw/virtio/vhost.c|2002| <<vhost_dev_prepare_inflight>> VHOST_OPS_DEBUG(r, "vhost_dev_prepare_inflight failed");
+ *   - hw/virtio/vhost.c|2017| <<vhost_dev_set_inflight>> VHOST_OPS_DEBUG(r, "vhost_set_inflight_fd failed");
+ *   - hw/virtio/vhost.c|2033| <<vhost_dev_get_inflight>> VHOST_OPS_DEBUG(r, "vhost_get_inflight_fd failed");
+ *   - hw/virtio/vhost.c|2093| <<vhost_dev_start>> VHOST_OPS_DEBUG(r, "vhost_set_mem_table failed");
+ *   - hw/virtio/vhost.c|2109| <<vhost_dev_start>> VHOST_OPS_DEBUG(r, "event_notifier_init failed");
+ *   - hw/virtio/vhost.c|2129| <<vhost_dev_start>> VHOST_OPS_DEBUG(r, "vhost_set_log_base failed");
+ */
 #ifdef _VHOST_DEBUG
 #define VHOST_OPS_DEBUG(retval, fmt, ...) \
     do { \
@@ -43,39 +68,145 @@
     do { } while (0)
 #endif
 
+/*
+ * 42 typedef unsigned long vhost_log_chunk_t;
+ * 43 #define VHOST_LOG_PAGE 0x1000
+ * 44 #define VHOST_LOG_BITS (8 * sizeof(vhost_log_chunk_t))
+ * 45 #define VHOST_LOG_CHUNK (VHOST_LOG_PAGE * VHOST_LOG_BITS)
+ * 46 #define VHOST_INVALID_FEATURE_BIT   (0xff)
+ * 47 #define VHOST_QUEUE_NUM_CONFIG_INR 0
+ * 48
+ * 49 struct vhost_log {
+ * 50     unsigned long long size;
+ * 51     int refcnt;
+ * 52     int fd;
+ * 53     vhost_log_chunk_t *log;
+ * 54 };
+ */
+/*
+ * 在以下使用指针数组vhost_log[VHOST_BACKEND_TYPE_MAX]:
+ *   - hw/virtio/vhost.c|414| <<vhost_log_get>> log = share ? vhost_log_shm[backend_type] : vhost_log[backend_type];
+ *   - hw/virtio/vhost.c|421| <<vhost_log_get>> vhost_log[backend_type] = log;
+ *   - hw/virtio/vhost.c|454| <<vhost_log_put>> if (vhost_log[backend_type] == log) {
+ *   - hw/virtio/vhost.c|456| <<vhost_log_put>> vhost_log[backend_type] = NULL;
+ */
 static struct vhost_log *vhost_log[VHOST_BACKEND_TYPE_MAX];
+/*
+ * 49 struct vhost_log {
+ * 50     unsigned long long size;
+ * 51     int refcnt;
+ * 52     int fd;
+ * 53     vhost_log_chunk_t *log;
+ * 54 };
+ *
+ * 16 typedef enum VhostBackendType {
+ * 17     VHOST_BACKEND_TYPE_NONE = 0,
+ * 18     VHOST_BACKEND_TYPE_KERNEL = 1,
+ * 19     VHOST_BACKEND_TYPE_USER = 2,
+ * 20     VHOST_BACKEND_TYPE_VDPA = 3,
+ * 21     VHOST_BACKEND_TYPE_MAX = 4,
+ * 22 } VhostBackendType;
+ *
+ * 在以下使用指针数组vhost_log_shm[VHOST_BACKEND_TYPE_MAX]:
+ *   - hw/virtio/vhost.c|414| <<vhost_log_get>> log = share ? vhost_log_shm[backend_type] : vhost_log[backend_type];
+ *   - hw/virtio/vhost.c|419| <<vhost_log_get>> vhost_log_shm[backend_type] = log;
+ *   - hw/virtio/vhost.c|457| <<vhost_log_put>> } else if (vhost_log_shm[backend_type] == log) {
+ *   - hw/virtio/vhost.c|460| <<vhost_log_put>> vhost_log_shm[backend_type] = NULL;
+ */
 static struct vhost_log *vhost_log_shm[VHOST_BACKEND_TYPE_MAX];
+/*
+ * 在以下使用链表vhost_log_devs[VHOST_BACKEND_TYPE_MAX]:
+ *   - hw/virtio/vhost.c|124| <<QLIST_HEAD>> static QLIST_HEAD(, vhost_dev) vhost_log_devs[VHOST_BACKEND_TYPE_MAX];
+ *   - hw/virtio/vhost.c|190| <<vhost_dev_should_log>> return dev == QLIST_FIRST(&vhost_log_devs[dev->vhost_ops->backend_type]);
+ *   - hw/virtio/vhost.c|204| <<vhost_dev_elect_mem_logger>> if (QLIST_EMPTY(&vhost_log_devs[backend_type])) {
+ *   - hw/virtio/vhost.c|205| <<vhost_dev_elect_mem_logger>> QLIST_INSERT_HEAD(&vhost_log_devs[backend_type], hdev, logdev_entry);
+ *   - hw/virtio/vhost.c|217| <<vhost_dev_elect_mem_logger>> QLIST_INSERT_AFTER(QLIST_FIRST(&vhost_log_devs[backend_type]), hdev, logdev_entry);
+ */
 static QLIST_HEAD(, vhost_dev) vhost_log_devs[VHOST_BACKEND_TYPE_MAX];
 
+/*
+ * 在以下使用used_memslots:
+ *   - hw/virtio/vhost.c|76| <<QLIST_HEAD>> static unsigned int used_memslots;
+ *   - hw/virtio/vhost.c|108| <<vhost_get_free_memslots>> cur_free = r - used_memslots;
+ *   - hw/virtio/vhost.c|709| <<vhost_commit>> used_memslots = dev->mem->nregions;
+ *   - hw/virtio/vhost.c|1665| <<vhost_dev_init>> used = used_memslots;
+ */
 /* Memslots used by backends that support private memslots (without an fd). */
 static unsigned int used_memslots;
 
+/*
+ * 在以下使用used_shared_memslots:
+ *   - hw/virtio/vhost.c|79| <<QLIST_HEAD>> static unsigned int used_shared_memslots;
+ *   - hw/virtio/vhost.c|106| <<vhost_get_free_memslots>> cur_free = r - used_shared_memslots;
+ *   - hw/virtio/vhost.c|707| <<vhost_commit>> used_shared_memslots = dev->mem->nregions;
+ *   - hw/virtio/vhost.c|1663| <<vhost_dev_init>> used = used_shared_memslots;
+ */
 /* Memslots used by backends that only support shared memslots (with an fd). */
 static unsigned int used_shared_memslots;
 
+/*
+ * 在以下使用vhost_devices:
+ *   - hw/virtio/vhost.c|81| <<QLIST_HEAD>> static QLIST_HEAD(, vhost_dev) vhost_devices =
+ *   - hw/virtio/vhost.c|82| <<QLIST_HEAD>> QLIST_HEAD_INITIALIZER(vhost_devices);
+ *   - hw/virtio/vhost.c|89| <<vhost_get_max_memslots>> QLIST_FOREACH(hdev, &vhost_devices, entry) {
+ *   - hw/virtio/vhost.c|100| <<vhost_get_free_memslots>> QLIST_FOREACH(hdev, &vhost_devices, entry) {
+ *   - hw/virtio/vhost.c|1655| <<vhost_dev_init>> QLIST_INSERT_HEAD(&vhost_devices, hdev, entry);
+ */
 static QLIST_HEAD(, vhost_dev) vhost_devices =
     QLIST_HEAD_INITIALIZER(vhost_devices);
 
+/*
+ * called by:
+ *   - hw/mem/memory-device.c|118| <<memory_device_memslot_decision_limit>> unsigned int max = vhost_get_max_memslots();
+ */
 unsigned int vhost_get_max_memslots(void)
 {
     unsigned int max = UINT_MAX;
     struct vhost_dev *hdev;
 
+    /*
+     * kernel的例子:
+     * /sys/module/vhost/parameters/max_mem_regions
+     */
     QLIST_FOREACH(hdev, &vhost_devices, entry) {
         max = MIN(max, hdev->vhost_ops->vhost_backend_memslots_limit(hdev));
     }
     return max;
 }
 
+/*
+ * called by:
+ *   - hw/mem/memory-device.c|119| <<memory_device_memslot_decision_limit>> unsigned int free = vhost_get_free_memslots();
+ *   - hw/mem/memory-device.c|198| <<memory_device_check_addable>> if (vhost_get_free_memslots() < required_memslots + reserved_memslots) {
+ */
 unsigned int vhost_get_free_memslots(void)
 {
     unsigned int free = UINT_MAX;
     struct vhost_dev *hdev;
 
     QLIST_FOREACH(hdev, &vhost_devices, entry) {
+        /*
+	 * kernel的例子:
+	 * /sys/module/vhost/parameters/max_mem_regions
+	 */
         unsigned int r = hdev->vhost_ops->vhost_backend_memslots_limit(hdev);
         unsigned int cur_free;
 
+        /*
+	 * 在以下使用used_memslots:
+	 *   - hw/virtio/vhost.c|76| <<QLIST_HEAD>> static unsigned int used_memslots;
+         *   - hw/virtio/vhost.c|108| <<vhost_get_free_memslots>> cur_free = r - used_memslots;
+         *   - hw/virtio/vhost.c|709| <<vhost_commit>> used_memslots = dev->mem->nregions;
+         *   - hw/virtio/vhost.c|1665| <<vhost_dev_init>> used = used_memslots;
+	 *
+         * 在以下使用used_shared_memslots:
+         *   - hw/virtio/vhost.c|79| <<QLIST_HEAD>> static unsigned int used_shared_memslots;
+         *   - hw/virtio/vhost.c|106| <<vhost_get_free_memslots>> cur_free = r - used_shared_memslots;
+         *   - hw/virtio/vhost.c|707| <<vhost_commit>> used_shared_memslots = dev->mem->nregions;
+         *   - hw/virtio/vhost.c|1663| <<vhost_dev_init>> used = used_shared_memslots;
+	 *
+	 * 应该是只有vhost-user有: vhost_backend_no_private_memslots
+	 */
         if (hdev->vhost_ops->vhost_backend_no_private_memslots &&
             hdev->vhost_ops->vhost_backend_no_private_memslots(hdev)) {
             cur_free = r - used_shared_memslots;
@@ -87,11 +218,50 @@ unsigned int vhost_get_free_memslots(void)
     return free;
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_log_alloc (size=28672, share=false) at ../hw/virtio/vhost.c:342
+ * #1  0x0000555555b8fda2 in vhost_log_get (backend_type=VHOST_BACKEND_TYPE_KERNEL, size=28672, share=false) at ../hw/virtio/vhost.c:381
+ * #2  0x0000555555b90071 in vhost_dev_log_resize (dev=0x55555767da60, size=28672) at ../hw/virtio/vhost.c:443
+ * #3  0x0000555555b91c49 in vhost_migration_log (listener=0x55555767da68, enable=true) at ../hw/virtio/vhost.c:1092
+ * #4  0x0000555555b91ccf in vhost_log_global_start (listener=0x55555767da68, errp=0x7ffe247ff628) at ../hw/virtio/vhost.c:1125
+ * #5  0x0000555555e6b859 in memory_global_dirty_log_do_start (errp=0x7ffe247ff628) at ../system/memory.c:2902
+ * #6  0x0000555555e6b98d in memory_global_dirty_log_start (flags=1, errp=0x7ffe247ff628) at ../system/memory.c:2941
+ * #7  0x0000555555e84d5d in ram_init_bitmaps (rs=0x7fffdc008410, errp=0x7ffe247ff628) at ../migration/ram.c:2782
+ * #8  0x0000555555e84e6e in ram_init_all (rsp=0x555557328500 <ram_state>, errp=0x7ffe247ff628) at ../migration/ram.c:2816
+ * #9  0x0000555555e854fc in ram_save_setup (f=0x555557671f70, opaque=0x555557328500 <ram_state>, errp=0x7ffe247ff628) at ../migration/ram.c:3010
+ * #10 0x0000555555c2fe16 in qemu_savevm_state_setup (f=0x555557671f70, errp=0x7ffe247ff628) at ../migration/savevm.c:1346
+ * #11 0x0000555555c19305 in migration_thread (opaque=0x5555573fe6a0) at ../migration/migration.c:3507
+ * #12 0x000055555616b040 in qemu_thread_start (args=0x555557c465e0) at ../util/qemu-thread-posix.c:541
+ * #13 0x00007ffff5c081da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #14 0x00007ffff3839e73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/virtio/vhost.c|214| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr,
+ *   - hw/virtio/vhost.c|262| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr, phys,
+ *   - hw/virtio/vhost.c|268| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr,
+ */
 static void vhost_dev_sync_region(struct vhost_dev *dev,
                                   MemoryRegionSection *section,
                                   uint64_t mfirst, uint64_t mlast,
                                   uint64_t rfirst, uint64_t rlast)
 {
+    /*
+     * 49 struct vhost_log {
+     * 50     unsigned long long size;
+     * 51     int refcnt;
+     * 52     int fd;
+     * 53     vhost_log_chunk_t *log;
+     * 54 };
+     *
+     * struct vhost_dev *dev:
+     * -> struct vhost_log *log;
+     *    -> vhost_log_chunk_t *log;
+     *
+     * 在vhost_log_alloc()分配的:
+     * log = g_new0(struct vhost_log, 1);
+     * log->log = g_malloc0(logsize);
+     */
     vhost_log_chunk_t *dev_log = dev->log->log;
 
     uint64_t start = MAX(mfirst, rfirst);
@@ -107,9 +277,20 @@ static void vhost_dev_sync_region(struct vhost_dev *dev,
     assert(start / VHOST_LOG_CHUNK < dev->log_size);
 
     for (;from < to; ++from) {
+        /*
+	 * typedef unsigned long vhost_log_chunk_t;
+	 * #define VHOST_LOG_PAGE 0x1000
+	 * #define VHOST_LOG_BITS (8 * sizeof(vhost_log_chunk_t))
+	 * #define VHOST_LOG_CHUNK (VHOST_LOG_PAGE * VHOST_LOG_BITS)
+	 * #define VHOST_INVALID_FEATURE_BIT   (0xff)
+	 * #define VHOST_QUEUE_NUM_CONFIG_INR 0
+	 */
         vhost_log_chunk_t log;
         /* We first check with non-atomic: much cheaper,
          * and we expect non-dirty to be the common case. */
+	/*
+	 * 如果这个chunk的bit都是0??
+	 */
         if (!*from) {
             addr += VHOST_LOG_CHUNK;
             continue;
@@ -150,15 +331,33 @@ bool vhost_dev_has_iommu(struct vhost_dev *dev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|446| <<vhost_sync_dirty_bitmap>> if (vhost_dev_should_log(dev)) {
+ */
 static inline bool vhost_dev_should_log(struct vhost_dev *dev)
 {
     assert(dev->vhost_ops);
     assert(dev->vhost_ops->backend_type > VHOST_BACKEND_TYPE_NONE);
     assert(dev->vhost_ops->backend_type < VHOST_BACKEND_TYPE_MAX);
 
+    /*
+     * 在以下使用链表vhost_log_devs[VHOST_BACKEND_TYPE_MAX]:
+     *   - hw/virtio/vhost.c|124| <<QLIST_HEAD>> static QLIST_HEAD(, vhost_dev) vhost_log_devs[VHOST_BACKEND_TYPE_MAX];
+     *   - hw/virtio/vhost.c|190| <<vhost_dev_should_log>> return dev == QLIST_FIRST(&vhost_log_devs[dev->vhost_ops->backend_type]);
+     *   - hw/virtio/vhost.c|204| <<vhost_dev_elect_mem_logger>> if (QLIST_EMPTY(&vhost_log_devs[backend_type])) {
+     *   - hw/virtio/vhost.c|205| <<vhost_dev_elect_mem_logger>> QLIST_INSERT_HEAD(&vhost_log_devs[backend_type], hdev, logdev_entry);
+     *   - hw/virtio/vhost.c|217| <<vhost_dev_elect_mem_logger>> QLIST_INSERT_AFTER(QLIST_FIRST(&vhost_log_devs[backend_type]), hdev, logdev_entry);
+     */
     return dev == QLIST_FIRST(&vhost_log_devs[dev->vhost_ops->backend_type]);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|562| <<vhost_log_put>> vhost_dev_elect_mem_logger(dev, false);
+ *   - hw/virtio/vhost.c|1217| <<vhost_dev_set_log>> vhost_dev_elect_mem_logger(dev, enable_log);
+ *   - hw/virtio/vhost.c|2381| <<vhost_dev_start>> vhost_dev_elect_mem_logger(hdev, true);
+ */
 static inline void vhost_dev_elect_mem_logger(struct vhost_dev *hdev, bool add)
 {
     VhostBackendType backend_type;
@@ -170,6 +369,14 @@ static inline void vhost_dev_elect_mem_logger(struct vhost_dev *hdev, bool add)
     assert(backend_type < VHOST_BACKEND_TYPE_MAX);
 
     if (add && !QLIST_IS_INSERTED(hdev, logdev_entry)) {
+        /*
+	 * 在以下使用链表vhost_log_devs[VHOST_BACKEND_TYPE_MAX]:
+	 *   - hw/virtio/vhost.c|124| <<QLIST_HEAD>> static QLIST_HEAD(, vhost_dev) vhost_log_devs[VHOST_BACKEND_TYPE_MAX];
+	 *   - hw/virtio/vhost.c|190| <<vhost_dev_should_log>> return dev == QLIST_FIRST(&vhost_log_devs[dev->vhost_ops->backend_type]);
+	 *   - hw/virtio/vhost.c|204| <<vhost_dev_elect_mem_logger>> if (QLIST_EMPTY(&vhost_log_devs[backend_type])) {
+	 *   - hw/virtio/vhost.c|205| <<vhost_dev_elect_mem_logger>> QLIST_INSERT_HEAD(&vhost_log_devs[backend_type], hdev, logdev_entry);
+	 *   - hw/virtio/vhost.c|217| <<vhost_dev_elect_mem_logger>> QLIST_INSERT_AFTER(QLIST_FIRST(&vhost_log_devs[backend_type]), hdev, logdev_entry);
+	 */
         if (QLIST_EMPTY(&vhost_log_devs[backend_type])) {
             QLIST_INSERT_HEAD(&vhost_log_devs[backend_type],
                               hdev, logdev_entry);
@@ -183,6 +390,14 @@ static inline void vhost_dev_elect_mem_logger(struct vhost_dev *hdev, bool add)
              * new devices come and go quickly, it wouldn't end up changing
              * the active leading logger device at all.
              */
+            /*
+	     * 在以下使用链表vhost_log_devs[VHOST_BACKEND_TYPE_MAX]:
+	     *   - hw/virtio/vhost.c|124| <<QLIST_HEAD>> static QLIST_HEAD(, vhost_dev) vhost_log_devs[VHOST_BACKEND_TYPE_MAX];
+	     *   - hw/virtio/vhost.c|190| <<vhost_dev_should_log>> return dev == QLIST_FIRST(&vhost_log_devs[dev->vhost_ops->backend_type]);
+	     *   - hw/virtio/vhost.c|204| <<vhost_dev_elect_mem_logger>> if (QLIST_EMPTY(&vhost_log_devs[backend_type])) {
+	     *   - hw/virtio/vhost.c|205| <<vhost_dev_elect_mem_logger>> QLIST_INSERT_HEAD(&vhost_log_devs[backend_type], hdev, logdev_entry);
+	     *   - hw/virtio/vhost.c|217| <<vhost_dev_elect_mem_logger>> QLIST_INSERT_AFTER(QLIST_FIRST(&vhost_log_devs[backend_type]), hdev, logdev_entry);
+	     */
             QLIST_INSERT_AFTER(QLIST_FIRST(&vhost_log_devs[backend_type]),
                                hdev, logdev_entry);
         }
@@ -191,6 +406,42 @@ static inline void vhost_dev_elect_mem_logger(struct vhost_dev *hdev, bool add)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_sync_dirty_bitmap (dev=0x5555573f9c50, section=0x7ffe2d1ff390, first=0, last=18446744073709551615) at ../hw/virtio/vhost.c:198
+ * #1  0x0000555555b8f997 in vhost_log_sync (listener=0x5555573f9c58, section=0x7ffe2d1ff390) at ../hw/virtio/vhost.c:281
+ * #2  0x0000555555e6956c in memory_region_sync_dirty_bitmap (mr=0x0, last_stage=false) at ../system/memory.c:2274
+ * #3  0x0000555555e6b7af in memory_global_dirty_log_sync (last_stage=false) at ../system/memory.c:2880
+ * #4  0x0000555555e8168b in migration_bitmap_sync (rs=0x7ffe1c0081c0, last_stage=false) at ../migration/ram.c:1056
+ * #5  0x0000555555e818f7 in migration_bitmap_sync_precopy (rs=0x7ffe1c0081c0, last_stage=false) at ../migration/ram.c:1104
+ * #6  0x0000555555e84d83 in ram_init_bitmaps (rs=0x7ffe1c0081c0, errp=0x7ffe2d1ff628) at ../migration/ram.c:2786
+ * #7  0x0000555555e84e6e in ram_init_all (rsp=0x555557328500 <ram_state>, errp=0x7ffe2d1ff628) at ../migration/ram.c:2816
+ * #8  0x0000555555e854fc in ram_save_setup (f=0x555557671f70, opaque=0x555557328500 <ram_state>, errp=0x7ffe2d1ff628) at ../migration/ram.c:3010
+ * #9  0x0000555555c2fe16 in qemu_savevm_state_setup (f=0x555557671f70, errp=0x7ffe2d1ff628) at ../migration/savevm.c:1346
+ * #10 0x0000555555c19305 in migration_thread (opaque=0x5555573fe6a0) at ../migration/migration.c:3507
+ * #11 0x000055555616b040 in qemu_thread_start (args=0x555557b1b070) at ../util/qemu-thread-posix.c:541
+ * #12 0x00007ffff5c081da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #13 0x00007ffff3839e73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  vhost_sync_dirty_bitmap (dev=0x55555767da60, section=0x7ffe2d1ff400, first=0, last=18446744073709551615) at ../hw/virtio/vhost.c:198
+ * #1  0x0000555555b8f997 in vhost_log_sync (listener=0x55555767da68, section=0x7ffe2d1ff400) at ../hw/virtio/vhost.c:281
+ * #2  0x0000555555e6956c in memory_region_sync_dirty_bitmap (mr=0x0, last_stage=false) at ../system/memory.c:2274
+ * #3  0x0000555555e6b7af in memory_global_dirty_log_sync (last_stage=false) at ../system/memory.c:2880
+ * #4  0x0000555555e8168b in migration_bitmap_sync (rs=0x7ffe1c0081c0, last_stage=false) at ../migration/ram.c:1056
+ * #5  0x0000555555e818f7 in migration_bitmap_sync_precopy (rs=0x7ffe1c0081c0, last_stage=false) at ../migration/ram.c:1104
+ * #6  0x0000555555e8615f in ram_state_pending_exact (opaque=0x555557328500 <ram_state>, must_precopy=0x7ffe2d1ff5c8, can_postcopy=0x7ffe2d1ff5d0) at ../migration/ram.c:3333
+ * #7  0x0000555555c30b9c in qemu_savevm_state_pending_exact (must_precopy=0x7ffe2d1ff5c8, can_postcopy=0x7ffe2d1ff5d0) at ../migration/savevm.c:1683
+ * #8  0x0000555555c18bfe in migration_iteration_run (s=0x5555573fe6a0) at ../migration/migration.c:3258
+ * #9  0x0000555555c193b8 in migration_thread (opaque=0x5555573fe6a0) at ../migration/migration.c:3531
+ * #10 0x000055555616b040 in qemu_thread_start (args=0x555557b1b070) at ../util/qemu-thread-posix.c:541
+ * #11 0x00007ffff5c081da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #12 0x00007ffff3839e73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/virtio/vhost.c|281| <<vhost_log_sync>> vhost_sync_dirty_bitmap(dev, section, 0x0, ~0x0ULL);
+ *   - hw/virtio/vhost.c|291| <<vhost_log_sync_range>> vhost_sync_dirty_bitmap(dev, section, first, last);
+ */
 static int vhost_sync_dirty_bitmap(struct vhost_dev *dev,
                                    MemoryRegionSection *section,
                                    hwaddr first,
@@ -203,6 +454,18 @@ static int vhost_sync_dirty_bitmap(struct vhost_dev *dev,
     if (!dev->log_enabled || !dev->started) {
         return 0;
     }
+    /*
+     * struct MemoryRegionSection {
+     *     Int128 size;
+     *     MemoryRegion *mr;
+     *     FlatView *fv;
+     *     hwaddr offset_within_region;
+     *     hwaddr offset_within_address_space;
+     *     bool readonly;
+     *     bool nonvolatile;
+     *     bool unmergeable;
+     * };
+     */
     start_addr = section->offset_within_address_space;
     end_addr = range_get_last(start_addr, int128_get64(section->size));
     start_addr = MAX(first, start_addr);
@@ -211,6 +474,12 @@ static int vhost_sync_dirty_bitmap(struct vhost_dev *dev,
     if (vhost_dev_should_log(dev)) {
         for (i = 0; i < dev->mem->nregions; ++i) {
             struct vhost_memory_region *reg = dev->mem->regions + i;
+            /*
+	     * called by:
+	     *   - hw/virtio/vhost.c|214| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr,
+	     *   - hw/virtio/vhost.c|262| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr, phys,
+	     *   - hw/virtio/vhost.c|268| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr,
+	     */
             vhost_dev_sync_region(dev, section, start_addr, end_addr,
                                   reg->guest_phys_addr,
                                   range_get_last(reg->guest_phys_addr,
@@ -259,12 +528,24 @@ static int vhost_sync_dirty_bitmap(struct vhost_dev *dev,
                  */
                 s = MIN(s, used_size - 1) + 1;
 
+                /*
+		 * called by:
+		 *   - hw/virtio/vhost.c|214| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr,
+		 *   - hw/virtio/vhost.c|262| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr, phys,
+		 *   - hw/virtio/vhost.c|268| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr,
+		 */
                 vhost_dev_sync_region(dev, section, start_addr, end_addr, phys,
                                       range_get_last(phys, s));
                 used_size -= s;
                 used_phys += s;
             }
         } else {
+            /*
+	     * called by:
+	     *   - hw/virtio/vhost.c|214| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr,
+	     *   - hw/virtio/vhost.c|262| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr, phys,
+	     *   - hw/virtio/vhost.c|268| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr,
+	     */
             vhost_dev_sync_region(dev, section, start_addr,
                                   end_addr, vq->used_phys,
                                   range_get_last(vq->used_phys, vq->used_size));
@@ -273,6 +554,24 @@ static int vhost_sync_dirty_bitmap(struct vhost_dev *dev,
     return 0;
 }
 
+/*
+ * 在以下设置:
+ *   - hw/virtio/vhost.c|1774| <<vhost_dev_init>> .log_sync = vhost_log_sync,
+ *
+ * 1697     hdev->memory_listener = (MemoryListener) {
+ * 1698         .name = "vhost",
+ * 1699         .begin = vhost_begin,
+ * 1700         .commit = vhost_commit,
+ * 1701         .region_add = vhost_region_addnop,
+ * 1702         .region_nop = vhost_region_addnop,
+ * 1703         .log_start = vhost_log_start,
+ * 1704         .log_stop = vhost_log_stop,
+ * 1705         .log_sync = vhost_log_sync,
+ * 1706         .log_global_start = vhost_log_global_start,
+ * 1707         .log_global_stop = vhost_log_global_stop,
+ * 1708         .priority = MEMORY_LISTENER_PRIORITY_DEV_BACKEND
+ * 1709     };
+ */
 static void vhost_log_sync(MemoryListener *listener,
                           MemoryRegionSection *section)
 {
@@ -281,6 +580,34 @@ static void vhost_log_sync(MemoryListener *listener,
     vhost_sync_dirty_bitmap(dev, section, 0x0, ~0x0ULL);
 }
 
+/*
+ * 最普通的测试,只在迁移完后使用了.
+ * (gdb) bt
+ * #0  vhost_log_sync_range (dev=0x5555573f9c50, first=0, last=7516192767) at ../hw/virtio/vhost.c:287
+ * #1  0x0000555555b8feeb in vhost_log_put (dev=0x5555573f9c50, sync=true) at ../hw/virtio/vhost.c:415
+ * #2  0x0000555555b94f94 in vhost_dev_stop (hdev=0x5555573f9c50, vdev=0x555558419170, vrings=false) at ../hw/virtio/vhost.c:2221
+ * #3  0x0000555555a47fa1 in vhost_net_stop_one (net=0x5555573f9c50, dev=0x555558419170) at ../hw/net/vhost_net.c:350
+ * #4  0x0000555555a48460 in vhost_net_stop (dev=0x555558419170, ncs=0x555558424898, data_queue_pairs=2, cvq=0) at ../hw/net/vhost_net.c:462
+ * #5  0x0000555555df0a6c in virtio_net_vhost_status (n=0x555558419170, status=15 '\017') at ../hw/net/virtio-net.c:318
+ * #6  0x0000555555df0d2b in virtio_net_set_status (vdev=0x555558419170, status=15 '\017') at ../hw/net/virtio-net.c:393
+ * #7  0x0000555555e33c08 in virtio_set_status (vdev=0x555558419170, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #8  0x0000555555e36d84 in virtio_vmstate_change (opaque=0x555558419170, running=false, state=RUN_STATE_FINISH_MIGRATE) at ../hw/virtio/virtio.c:3428
+ * #9  0x0000555555be03d7 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:405
+ * #10 0x0000555555bd0b84 in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:301
+ * #11 0x0000555555bd1b08 in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:712
+ * #12 0x0000555555bd1c83 in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:781
+ * #13 0x0000555555c11e3b in migration_stop_vm (s=0x5555573fe6a0, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:225
+ * #14 0x0000555555c17bde in migration_completion_precopy (s=0x5555573fe6a0, current_active_state=0x7ffe375ff588) at ../migration/migration.c:2757
+ * #15 0x0000555555c17e13 in migration_completion (s=0x5555573fe6a0) at ../migration/migration.c:2839
+ * #16 0x0000555555c18c5a in migration_iteration_run (s=0x5555573fe6a0) at ../migration/migration.c:3265
+ * #17 0x0000555555c193b8 in migration_thread (opaque=0x5555573fe6a0) at ../migration/migration.c:3531
+ * #18 0x000055555616b040 in qemu_thread_start (args=0x555557c65b60) at ../util/qemu-thread-posix.c:541
+ * #19 0x00007ffff5c081da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #20 0x00007ffff3839e73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/virtio/vhost.c|631| <<vhost_log_put>> vhost_log_sync_range(dev, 0, dev->log_size * VHOST_LOG_CHUNK - 1);
+ */
 static void vhost_log_sync_range(struct vhost_dev *dev,
                                  hwaddr first, hwaddr last)
 {
@@ -292,6 +619,12 @@ static void vhost_log_sync_range(struct vhost_dev *dev,
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|835| <<vhost_commit>> log_size = vhost_get_log_size(dev);
+ *   - hw/virtio/vhost.c|1228| <<vhost_migration_log>> vhost_dev_log_resize(dev, vhost_get_log_size(dev));
+ *   - hw/virtio/vhost.c|2336| <<vhost_dev_start>> hdev->log_size = vhost_get_log_size(hdev);
+ */
 static uint64_t vhost_get_log_size(struct vhost_dev *dev)
 {
     uint64_t log_size = 0;
@@ -338,6 +671,27 @@ static int vhost_set_backend_type(struct vhost_dev *dev,
     return r;
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_log_alloc (size=28672, share=false) at ../hw/virtio/vhost.c:342
+ * #1  0x0000555555b8fda2 in vhost_log_get (backend_type=VHOST_BACKEND_TYPE_KERNEL, size=28672, share=false) at ../hw/virtio/vhost.c:381
+ * #2  0x0000555555b90071 in vhost_dev_log_resize (dev=0x55555767da60, size=28672) at ../hw/virtio/vhost.c:443
+ * #3  0x0000555555b91c49 in vhost_migration_log (listener=0x55555767da68, enable=true) at ../hw/virtio/vhost.c:1092
+ * #4  0x0000555555b91ccf in vhost_log_global_start (listener=0x55555767da68, errp=0x7ffe247ff628) at ../hw/virtio/vhost.c:1125
+ * #5  0x0000555555e6b859 in memory_global_dirty_log_do_start (errp=0x7ffe247ff628) at ../system/memory.c:2902
+ * #6  0x0000555555e6b98d in memory_global_dirty_log_start (flags=1, errp=0x7ffe247ff628) at ../system/memory.c:2941
+ * #7  0x0000555555e84d5d in ram_init_bitmaps (rs=0x7fffdc008410, errp=0x7ffe247ff628) at ../migration/ram.c:2782
+ * #8  0x0000555555e84e6e in ram_init_all (rsp=0x555557328500 <ram_state>, errp=0x7ffe247ff628) at ../migration/ram.c:2816
+ * #9  0x0000555555e854fc in ram_save_setup (f=0x555557671f70, opaque=0x555557328500 <ram_state>, errp=0x7ffe247ff628) at ../migration/ram.c:3010
+ * #10 0x0000555555c2fe16 in qemu_savevm_state_setup (f=0x555557671f70, errp=0x7ffe247ff628) at ../migration/savevm.c:1346
+ * #11 0x0000555555c19305 in migration_thread (opaque=0x5555573fe6a0) at ../migration/migration.c:3507
+ * #12 0x000055555616b040 in qemu_thread_start (args=0x555557c465e0) at ../util/qemu-thread-posix.c:541
+ * #13 0x00007ffff5c081da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #14 0x00007ffff3839e73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/virtio/vhost.c|513| <<vhost_log_get>> log = vhost_log_alloc(size, share);
+ */
 static struct vhost_log *vhost_log_alloc(uint64_t size, bool share)
 {
     Error *err = NULL;
@@ -367,6 +721,11 @@ static struct vhost_log *vhost_log_alloc(uint64_t size, bool share)
     return log;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|546| <<vhost_dev_log_resize>> struct vhost_log *log = vhost_log_get(dev->vhost_ops->backend_type,
+ *   - hw/virtio/vhost.c|2224| <<vhost_dev_start>> hdev->log = vhost_log_get(hdev->vhost_ops->backend_type,
+ */
 static struct vhost_log *vhost_log_get(VhostBackendType backend_type,
                                        uint64_t size, bool share)
 {
@@ -391,6 +750,13 @@ static struct vhost_log *vhost_log_get(VhostBackendType backend_type,
     return log;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|599| <<vhost_dev_log_resize>> vhost_log_put(dev, true);
+ *   - hw/virtio/vhost.c|1259| <<vhost_migration_log>> vhost_log_put(dev, false);
+ *   - hw/virtio/vhost.c|2413| <<vhost_dev_start>> vhost_log_put(hdev, false);
+ *   - hw/virtio/vhost.c|2485| <<vhost_dev_stop>> vhost_log_put(hdev, true);
+ */
 static void vhost_log_put(struct vhost_dev *dev, bool sync)
 {
     struct vhost_log *log = dev->log;
@@ -432,14 +798,58 @@ static void vhost_log_put(struct vhost_dev *dev, bool sync)
     dev->log_size = 0;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|570| <<vhost_dev_log_resize>> struct vhost_log *log = vhost_log_get(dev->vhost_ops->backend_type, size, vhost_dev_log_is_shared(dev));
+ *   - hw/virtio/vhost.c|1790| <<vhost_dev_init>> } else if (vhost_dev_log_is_shared(hdev) && !qemu_memfd_alloc_check()) {
+ *   - hw/virtio/vhost.c|2339| <<vhost_dev_start>> hdev->log = vhost_log_get(hdev->vhost_ops->backend_type, hdev->log_size, vhost_dev_log_is_shared(hdev));
+ */
 static bool vhost_dev_log_is_shared(struct vhost_dev *dev)
 {
+    /*
+     * 在以下使用vhost_requires_shm_log:
+     *   - hw/virtio/vhost-user.c|3026| <<global>> .vhost_requires_shm_log = vhost_user_requires_shm_log,
+     *   - hw/virtio/vhost-vdpa.c|1569| <<global>> .vhost_requires_shm_log = NULL,
+     *   - hw/virtio/vhost.c|642| <<vhost_dev_log_is_shared>> return dev->vhost_ops->vhost_requires_shm_log &&
+     *   - hw/virtio/vhost.c|643| <<vhost_dev_log_is_shared>> dev->vhost_ops->vhost_requires_shm_log(dev);
+     */
     return dev->vhost_ops->vhost_requires_shm_log &&
            dev->vhost_ops->vhost_requires_shm_log(dev);
 }
 
+/*
+ * (gdb) bt
+ * #0  vhost_kernel_set_log_base (dev=0x5555573f9c50, base=140729502631248, log=0x7ffe24004fd0) at ../hw/virtio/vhost-backend.c:98
+ * #1  0x0000555555b900ac in vhost_dev_log_resize (dev=0x5555573f9c50, size=28672) at ../hw/virtio/vhost.c:450
+ * #2  0x0000555555b91c49 in vhost_migration_log (listener=0x5555573f9c58, enable=true) at ../hw/virtio/vhost.c:1092
+ * #3  0x0000555555b91ccf in vhost_log_global_start (listener=0x5555573f9c58, errp=0x7ffe23dff628) at ../hw/virtio/vhost.c:1125
+ * #4  0x0000555555e6b859 in memory_global_dirty_log_do_start (errp=0x7ffe23dff628) at ../system/memory.c:2902
+ * #5  0x0000555555e6b98d in memory_global_dirty_log_start (flags=1, errp=0x7ffe23dff628) at ../system/memory.c:2941
+ * #6  0x0000555555e84d5d in ram_init_bitmaps (rs=0x7ffe240081b0, errp=0x7ffe23dff628) at ../migration/ram.c:2782
+ * #7  0x0000555555e84e6e in ram_init_all (rsp=0x555557328500 <ram_state>, errp=0x7ffe23dff628) at ../migration/ram.c:2816
+ * #8  0x0000555555e854fc in ram_save_setup (f=0x555557671f70, opaque=0x555557328500 <ram_state>, errp=0x7ffe23dff628) at ../migration/ram.c:3010
+ * #9  0x0000555555c2fe16 in qemu_savevm_state_setup (f=0x555557671f70, errp=0x7ffe23dff628) at ../migration/savevm.c:1346
+ * #10 0x0000555555c19305 in migration_thread (opaque=0x5555573fe6a0) at ../migration/migration.c:3507
+ * #11 0x000055555616b040 in qemu_thread_start (args=0x55555777a310) at ../util/qemu-thread-posix.c:541
+ * #12 0x00007ffff5c081da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #13 0x00007ffff3839e73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * called by:
+ *   - hw/virtio/vhost.c|841| <<vhost_commit>> vhost_dev_log_resize(dev, log_size + VHOST_LOG_BUFFER);
+ *   - hw/virtio/vhost.c|849| <<vhost_commit>> vhost_dev_log_resize(dev, log_size);
+ *   - hw/virtio/vhost.c|1228| <<vhost_migration_log>> vhost_dev_log_resize(dev, vhost_get_log_size(dev));
+ */
 static inline void vhost_dev_log_resize(struct vhost_dev *dev, uint64_t size)
 {
+    /*
+     * 16 typedef enum VhostBackendType {
+     * 17     VHOST_BACKEND_TYPE_NONE = 0,
+     * 18     VHOST_BACKEND_TYPE_KERNEL = 1,
+     * 19     VHOST_BACKEND_TYPE_USER = 2,
+     * 20     VHOST_BACKEND_TYPE_VDPA = 3,
+     * 21     VHOST_BACKEND_TYPE_MAX = 4,
+     * 22 } VhostBackendType;
+     */
     struct vhost_log *log = vhost_log_get(dev->vhost_ops->backend_type,
                                           size, vhost_dev_log_is_shared(dev));
     uint64_t log_base = (uintptr_t)log->log;
@@ -457,6 +867,12 @@ static inline void vhost_dev_log_resize(struct vhost_dev *dev, uint64_t size)
     dev->log_size = size;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|1478| <<vhost_virtqueue_start>> vq->desc = vhost_memory_map(dev, a, &l, false);
+ *   - hw/virtio/vhost.c|1485| <<vhost_virtqueue_start>> vq->avail = vhost_memory_map(dev, a, &l, false);
+ *   - hw/virtio/vhost.c|1492| <<vhost_virtqueue_start>> vq->used = vhost_memory_map(dev, a, &l, true);
+ */
 static void *vhost_memory_map(struct vhost_dev *dev, hwaddr addr,
                               hwaddr *plen, bool is_write)
 {
@@ -467,6 +883,15 @@ static void *vhost_memory_map(struct vhost_dev *dev, hwaddr addr,
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|1536| <<vhost_virtqueue_start>> vhost_memory_unmap(dev, vq->used, virtio_queue_get_used_size(vdev, idx),
+ *   - hw/virtio/vhost.c|1539| <<vhost_virtqueue_start>> vhost_memory_unmap(dev, vq->avail, virtio_queue_get_avail_size(vdev, idx),
+ *   - hw/virtio/vhost.c|1542| <<vhost_virtqueue_start>> vhost_memory_unmap(dev, vq->desc, virtio_queue_get_desc_size(vdev, idx),
+ *   - hw/virtio/vhost.c|1586| <<vhost_virtqueue_stop>> vhost_memory_unmap(dev, vq->used, virtio_queue_get_used_size(vdev, idx),
+ *   - hw/virtio/vhost.c|1588| <<vhost_virtqueue_stop>> vhost_memory_unmap(dev, vq->avail, virtio_queue_get_avail_size(vdev, idx),
+ *   - hw/virtio/vhost.c|1590| <<vhost_virtqueue_stop>> vhost_memory_unmap(dev, vq->desc, virtio_queue_get_desc_size(vdev, idx),
+ */
 static void vhost_memory_unmap(struct vhost_dev *dev, void *buffer,
                                hwaddr len, int is_write,
                                hwaddr access_len)
@@ -666,6 +1091,9 @@ static void vhost_commit(MemoryListener *listener)
     dev->mem = g_realloc(dev->mem, regions_size);
     dev->mem->nregions = dev->n_mem_sections;
 
+    /*
+     * 应该是只有vhost-user有vhost_backend_no_private_memslots
+     */
     if (dev->vhost_ops->vhost_backend_no_private_memslots &&
         dev->vhost_ops->vhost_backend_no_private_memslots(dev)) {
         used_shared_memslots = dev->mem->nregions;
@@ -846,6 +1274,34 @@ static void vhost_region_add_section(struct vhost_dev *dev,
     }
 }
 
+/*
+ * 所有修改内存的地方都会用到.
+ *
+ * (gdb) bt
+ * #0  vhost_region_addnop (listener=0x5555573f9c58, section=0x7fffffffd310) at ../hw/virtio/vhost.c:853
+ * #1  0x0000555555e65d32 in address_space_update_topology_pass (as=0x555557328200 <address_space_memory>, old_view=0x55555781a740, new_view=0x555557836260, adding=true) at ../system/memory.c:985
+ * #2  0x0000555555e66292 in address_space_set_flatview (as=0x555557328200 <address_space_memory>) at ../system/memory.c:1080
+ * #3  0x0000555555e6646f in memory_region_transaction_commit () at ../system/memory.c:1132
+ * #4  0x0000555555aafe56 in init_pam (mem=0x55555778b3b0, owner=0x55555778a480, ram_memory=0x555557526ee0, system_memory=0x5555576486e0, pci_address_space=0x5555573fa000, start=786432, size=16384)
+ *     at ../hw/pci-host/pam.c:59
+ * #5  0x0000555555ab54cc in i440fx_pcihost_realize (dev=0x555557753090, errp=0x7fffffffd550) at ../hw/pci-host/i440fx.c:303
+ * #6  0x0000555555eecf82 in device_set_realized (obj=0x555557753090, value=true, errp=0x7fffffffd660) at ../hw/core/qdev.c:510
+ * #7  0x0000555555ef8021 in property_set_bool (obj=0x555557753090, v=0x555557754570, name=0x55555639c861 "realized", opaque=0x555557400680, errp=0x7fffffffd660) at ../qom/object.c:2354
+ * #8  0x0000555555ef5b6f in object_property_set (obj=0x555557753090, name=0x55555639c861 "realized", v=0x555557754570, errp=0x7fffffffd660) at ../qom/object.c:1463
+ * #9  0x0000555555efa89c in object_property_set_qobject (obj=0x555557753090, name=0x55555639c861 "realized", value=0x5555577543d0, errp=0x5555573440c0 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #10 0x0000555555ef5f14 in object_property_set_bool (obj=0x555557753090, name=0x55555639c861 "realized", value=true, errp=0x5555573440c0 <error_fatal>) at ../qom/object.c:1533
+ * #11 0x0000555555eec66f in qdev_realize (dev=0x555557753090, bus=0x555557670c70, errp=0x5555573440c0 <error_fatal>) at ../hw/core/qdev.c:291
+ * #12 0x0000555555eec6a8 in qdev_realize_and_unref (dev=0x555557753090, bus=0x555557670c70, errp=0x5555573440c0 <error_fatal>) at ../hw/core/qdev.c:298
+ * #13 0x0000555555952b57 in sysbus_realize_and_unref (dev=0x555557753090, errp=0x5555573440c0 <error_fatal>) at ../hw/core/sysbus.c:261
+ * #14 0x0000555555cf6ac7 in pc_init1 (machine=0x555557668000, pci_type=0x55555634cc4a "i440FX") at ../hw/i386/pc_piix.c:211
+ * #15 0x0000555555cf7512 in pc_i440fx_init (machine=0x555557668000) at ../hw/i386/pc_piix.c:445
+ * #16 0x0000555555cf770a in pc_i440fx_machine_9_1_init (machine=0x555557668000) at ../hw/i386/pc_piix.c:484
+ * #17 0x000055555594ae1d in machine_run_board_init (machine=0x555557668000, mem_path=0x0, errp=0x7fffffffd950) at ../hw/core/machine.c:1593
+ * #18 0x0000555555be812e in qemu_init_board () at ../system/vl.c:2628
+ * #19 0x0000555555be8441 in qmp_x_exit_preconfig (errp=0x5555573440c0 <error_fatal>) at ../system/vl.c:2720
+ * #20 0x0000555555beb015 in qemu_init (argc=16, argv=0x7fffffffdc48) at ../system/vl.c:3766
+ * #21 0x00005555560939c8 in main (argc=16, argv=0x7fffffffdc48) at ../system/main.c:47
+ */
 /* Used for both add and nop callbacks */
 static void vhost_region_addnop(MemoryListener *listener,
                                 MemoryRegionSection *section)
@@ -954,6 +1410,52 @@ void vhost_toggle_device_iotlb(VirtIODevice *vdev)
     }
 }
 
+/*
+ * VHOST_SET_VRING_ADDR
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_set_vring_addr (dev=0x5555573f9c50, addr=0x7fffe3dfefd0) at ../hw/virtio/vhost-backend.c:110
+ * #1  0x0000555555b917d9 in vhost_virtqueue_set_addr (dev=0x5555573f9c50, vq=0x5555573f9f60, idx=1, enable_log=false) at ../hw/virtio/vhost.c:979
+ * #2  0x0000555555b92541 in vhost_virtqueue_start (dev=0x5555573f9c50, vdev=0x555558419170, vq=0x5555573f9f60, idx=3) at ../hw/virtio/vhost.c:1321
+ * #3  0x0000555555b949e8 in vhost_dev_start (hdev=0x5555573f9c50, vdev=0x555558419170, vrings=false) at ../hw/virtio/vhost.c:2097
+ * #4  0x0000555555a47c24 in vhost_net_start_one (net=0x5555573f9c50, dev=0x555558419170) at ../hw/net/vhost_net.c:280
+ * #5  0x0000555555a48278 in vhost_net_start (dev=0x555558419170, ncs=0x555558424898, data_queue_pairs=2, cvq=0) at ../hw/net/vhost_net.c:421
+ * #6  0x0000555555df0a1b in virtio_net_vhost_status (n=0x555558419170, status=15 '\017') at ../hw/net/virtio-net.c:311
+ * #7  0x0000555555df0d2b in virtio_net_set_status (vdev=0x555558419170, status=15 '\017') at ../hw/net/virtio-net.c:393
+ * #8  0x0000555555e33c08 in virtio_set_status (vdev=0x555558419170, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #9  0x0000555555b7b531 in virtio_pci_common_write (opaque=0x555558410cf0, addr=20, val=15, size=1) at ../hw/virtio/virtio-pci.c:1608
+ * #10 0x0000555555e63c32 in memory_region_write_accessor (mr=0x5555584118e0, addr=20, value=0x7fffe3dff3f8, size=1, shift=0, mask=255, attrs=...) at ../system/memory.c:497
+ * #11 0x0000555555e63f79 in access_with_adjusted_size (addr=20, value=0x7fffe3dff3f8, size=1, access_size_min=1, access_size_max=4,
+ *           access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x5555584118e0, attrs=...) at ../system/memory.c:573
+ * #12 0x0000555555e674ae in memory_region_dispatch_write (mr=0x5555584118e0, addr=20, data=15, op=MO_8, attrs=...) at ../system/memory.c:1521
+ * #13 0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff7e39028 "\017", len=1, mr_addr=20, l=0x7fffe3dff4e0, mr=0x5555584118e0) at ../system/physmem.c:2803
+ * #14 0x0000555555e76cae in flatview_write_continue (fv=0x7ffe542b6060, addr=4261412884, attrs=..., ptr=0x7ffff7e39028, len=1, mr_addr=20, l=1, mr=0x5555584118e0) at ../system/physmem.c:2833
+ * #15 0x0000555555e76dd6 in flatview_write (fv=0x7ffe542b6060, addr=4261412884, attrs=..., buf=0x7ffff7e39028, len=1) at ../system/physmem.c:2864
+ * #16 0x0000555555e77250 in address_space_write (as=0x555557328200 <address_space_memory>, addr=4261412884, attrs=..., buf=0x7ffff7e39028, len=1) at ../system/physmem.c:2984
+ * #17 0x0000555555e772c8 in address_space_rw (as=0x555557328200 <address_space_memory>, addr=4261412884, attrs=..., buf=0x7ffff7e39028, len=1, is_write=true) at ../system/physmem.c:2994
+ * #18 0x0000555555ed4d63 in kvm_cpu_exec (cpu=0x555557748910) at ../accel/kvm/kvm-all.c:3075
+ * #19 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x555557748910) at ../accel/kvm/kvm-accel-ops.c:50
+ * #20 0x000055555616b040 in qemu_thread_start (args=0x555557752230) at ../util/qemu-thread-posix.c:541
+ * #21 0x00007ffff5c081da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #22 0x00007ffff3839e73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_set_vring_addr (dev=0x5555573f9c50, addr=0x7ffe253ff350) at ../hw/virtio/vhost-backend.c:110
+ * #1  0x0000555555b917d9 in vhost_virtqueue_set_addr (dev=0x5555573f9c50, vq=0x5555573f9f60, idx=1, enable_log=true) at ../hw/virtio/vhost.c:979
+ * #2  0x0000555555b91a76 in vhost_dev_set_log (dev=0x5555573f9c50, enable_log=true) at ../hw/virtio/vhost.c:1040
+ * #3  0x0000555555b91c5a in vhost_migration_log (listener=0x5555573f9c58, enable=true) at ../hw/virtio/vhost.c:1093
+ * #4  0x0000555555b91ccf in vhost_log_global_start (listener=0x5555573f9c58, errp=0x7ffe253ff628) at ../hw/virtio/vhost.c:1125
+ * #5  0x0000555555e6b859 in memory_global_dirty_log_do_start (errp=0x7ffe253ff628) at ../system/memory.c:2902
+ * #6  0x0000555555e6b98d in memory_global_dirty_log_start (flags=1, errp=0x7ffe253ff628) at ../system/memory.c:2941
+ * #7  0x0000555555e84d5d in ram_init_bitmaps (rs=0x7fffdc008420, errp=0x7ffe253ff628) at ../migration/ram.c:2782
+ * #8  0x0000555555e84e6e in ram_init_all (rsp=0x555557328500 <ram_state>, errp=0x7ffe253ff628) at ../migration/ram.c:2816
+ * #9  0x0000555555e854fc in ram_save_setup (f=0x555557671f70, opaque=0x555557328500 <ram_state>, errp=0x7ffe253ff628) at ../migration/ram.c:3010
+ * #10 0x0000555555c2fe16 in qemu_savevm_state_setup (f=0x555557671f70, errp=0x7ffe253ff628) at ../migration/savevm.c:1346
+ * #11 0x0000555555c19305 in migration_thread (opaque=0x5555573fe6a0) at ../migration/migration.c:3507
+ * #12 0x000055555616b040 in qemu_thread_start (args=0x555558115c40) at ../util/qemu-thread-posix.c:541
+ * #13 0x00007ffff5c081da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #14 0x00007ffff3839e73 in clone () from /lib/../lib64/libc.so.6
+ */
 static int vhost_virtqueue_set_addr(struct vhost_dev *dev,
                                     struct vhost_virtqueue *vq,
                                     unsigned idx, bool enable_log)
@@ -974,7 +1476,18 @@ static int vhost_virtqueue_set_addr(struct vhost_dev *dev,
         addr.used_user_addr = (uint64_t)(unsigned long)vq->used;
     }
     addr.index = idx;
+    /*
+     * struct vhost_vring_addr
+     */
     addr.log_guest_addr = vq->used_phys;
+    /*
+     * QEMU在以下使用VHOST_VRING_F_LOG:
+     *   -  hw/virtio/vhost-user.c|1366| <<vhost_user_set_vring_addr>> bool wait_for_reply = addr->flags & (1 << VHOST_VRING_F_LOG);
+     *   - hw/virtio/vhost.c|1454| <<vhost_virtqueue_set_addr>> addr.flags = enable_log ? (1 << VHOST_VRING_F_LOG) : 0; 
+     *
+     * 注释:
+     * Whether log address is valid. If set enables logging. 
+     */
     addr.flags = enable_log ? (1 << VHOST_VRING_F_LOG) : 0;
     r = dev->vhost_ops->vhost_set_vring_addr(dev, &addr);
     if (r < 0) {
@@ -983,6 +1496,13 @@ static int vhost_virtqueue_set_addr(struct vhost_dev *dev,
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|1258| <<vhost_dev_set_log>> r = vhost_dev_set_features(dev, enable_log);
+ *   - hw/virtio/vhost.c|1300| <<vhost_dev_set_log>> vhost_dev_set_features(dev, dev->log_enabled);
+ *   - hw/virtio/vhost.c|2295| <<vhost_dev_prepare_inflight>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+ *   - hw/virtio/vhost.c|2401| <<vhost_dev_start>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+ */
 static int vhost_dev_set_features(struct vhost_dev *dev,
                                   bool enable_log)
 {
@@ -1016,11 +1536,25 @@ out:
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|1199| <<vhost_migration_log>> r = vhost_dev_set_log(dev, false);
+ *   - hw/virtio/vhost.c|1206| <<vhost_migration_log>> r = vhost_dev_set_log(dev, true);
+ */
 static int vhost_dev_set_log(struct vhost_dev *dev, bool enable_log)
 {
     int r, i, idx;
     hwaddr addr;
 
+    /*
+     * called by:
+     *   - hw/virtio/vhost.c|1258| <<vhost_dev_set_log>> r = vhost_dev_set_features(dev, enable_log);
+     *   - hw/virtio/vhost.c|1300| <<vhost_dev_set_log>> vhost_dev_set_features(dev, dev->log_enabled);
+     *   - hw/virtio/vhost.c|2295| <<vhost_dev_prepare_inflight>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     *   - hw/virtio/vhost.c|2401| <<vhost_dev_start>> r = vhost_dev_set_features(hdev, hdev->log_enabled);
+     *
+     * 这里设置VHOST_F_LOG_ALL
+     */
     r = vhost_dev_set_features(dev, enable_log);
     if (r < 0) {
         goto err_features;
@@ -1037,6 +1571,9 @@ static int vhost_dev_set_log(struct vhost_dev *dev, bool enable_log)
              */
             continue;
         }
+        /*
+	 * 这里设置VHOST_VRING_F_LOG
+	 */
         r = vhost_virtqueue_set_addr(dev, dev->vqs + i, idx,
                                      enable_log);
         if (r < 0) {
@@ -1068,6 +1605,11 @@ err_features:
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|1228| <<vhost_log_global_start>> r = vhost_migration_log(listener, true);
+ *   - hw/virtio/vhost.c|1239| <<vhost_log_global_stop>> r = vhost_migration_log(listener, false);
+ */
 static int vhost_migration_log(MemoryListener *listener, bool enable)
 {
     struct vhost_dev *dev = container_of(listener, struct vhost_dev,
@@ -1118,6 +1660,24 @@ check_dev_state:
     return r;
 }
 
+/*
+ * 在以下设置:
+ *   - hw/virtio/vhost.c|1734| <<vhost_dev_init>> .log_global_start = vhost_log_global_start,
+ *
+ * 1697     hdev->memory_listener = (MemoryListener) {
+ * 1698         .name = "vhost",
+ * 1699         .begin = vhost_begin,
+ * 1700         .commit = vhost_commit,
+ * 1701         .region_add = vhost_region_addnop,
+ * 1702         .region_nop = vhost_region_addnop,
+ * 1703         .log_start = vhost_log_start,
+ * 1704         .log_stop = vhost_log_stop,
+ * 1705         .log_sync = vhost_log_sync,
+ * 1706         .log_global_start = vhost_log_global_start,
+ * 1707         .log_global_stop = vhost_log_global_stop,
+ * 1708         .priority = MEMORY_LISTENER_PRIORITY_DEV_BACKEND
+ * 1709     };
+ */
 static bool vhost_log_global_start(MemoryListener *listener, Error **errp)
 {
     int r;
@@ -1146,6 +1706,24 @@ static void vhost_log_start(MemoryListener *listener,
     /* FIXME: implement */
 }
 
+/*
+ * 在以下设置:
+ *   - hw/virtio/vhost.c|1684| <<vhost_dev_init>> .log_stop = vhost_log_stop
+ *
+ * 1697     hdev->memory_listener = (MemoryListener) {
+ * 1698         .name = "vhost",
+ * 1699         .begin = vhost_begin,
+ * 1700         .commit = vhost_commit,
+ * 1701         .region_add = vhost_region_addnop,
+ * 1702         .region_nop = vhost_region_addnop,
+ * 1703         .log_start = vhost_log_start,
+ * 1704         .log_stop = vhost_log_stop,
+ * 1705         .log_sync = vhost_log_sync,
+ * 1706         .log_global_start = vhost_log_global_start,
+ * 1707         .log_global_stop = vhost_log_global_stop,
+ * 1708         .priority = MEMORY_LISTENER_PRIORITY_DEV_BACKEND
+ * 1709     };
+ */
 static void vhost_log_stop(MemoryListener *listener,
                            MemoryRegionSection *section,
                            int old, int new)
@@ -1248,6 +1826,11 @@ out:
     return ret;
 }
 
+/*
+ * called by:
+ *   - hw/net/vhost_net.c|622| <<vhost_net_virtqueue_restart>> r = vhost_virtqueue_start(&net->dev,
+ *   - hw/virtio/vhost.c|2200| <<vhost_dev_start>> r = vhost_virtqueue_start(hdev,
+ */
 int vhost_virtqueue_start(struct vhost_dev *dev,
                           struct VirtIODevice *vdev,
                           struct vhost_virtqueue *vq,
@@ -1506,6 +2089,21 @@ static void vhost_virtqueue_cleanup(struct vhost_virtqueue *vq)
     }
 }
 
+/*
+ * called by:
+ *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev, options->opaque, options->backend_type, 0,
+ *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev, &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0,
+ *   - hw/block/vhost-user-blk.c|336| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev, &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0,
+ *   - hw/net/vhost_net.c|212| <<vhost_net_init>> r = vhost_dev_init(&net->dev, options->opaque,
+ *   - hw/scsi/vhost-scsi.c|293| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev, (void *)(uintptr_t)vhostfd,
+ *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev, &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0,
+ *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev, &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+ *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev, &vub->vhost_user,
+ *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev, &fs->vhost_user,
+ *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev, &scmi->vhost_user,
+ *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev, &vsock->vhost_user,
+ *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev, (void *)(uintptr_t)vhostfd,
+ */
 int vhost_dev_init(struct vhost_dev *hdev, void *opaque,
                    VhostBackendType backend_type, uint32_t busyloop_timeout,
                    Error **errp)
@@ -2022,6 +2620,11 @@ int vhost_dev_set_inflight(struct vhost_dev *dev,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/block/vhost-user-blk.c|154| <<vhost_user_blk_start>> ret = vhost_dev_get_inflight(&s->dev, s->queue_size, s->inflight);
+ *   - hw/scsi/vhost-scsi-common.c|65| <<vhost_scsi_common_start>> ret = vhost_dev_get_inflight(&vsc->dev,
+ */
 int vhost_dev_get_inflight(struct vhost_dev *dev, uint16_t queue_size,
                            struct vhost_inflight *inflight)
 {
@@ -2038,6 +2641,12 @@ int vhost_dev_get_inflight(struct vhost_dev *dev, uint16_t queue_size,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|2238| <<vhost_dev_start>> r = vhost_dev_set_vring_enable(hdev, true);
+ *   - hw/virtio/vhost.c|2264| <<vhost_dev_start>> vhost_dev_set_vring_enable(hdev, false);
+ *   - hw/virtio/vhost.c|2305| <<vhost_dev_stop>> vhost_dev_set_vring_enable(hdev, false);
+ */
 static int vhost_dev_set_vring_enable(struct vhost_dev *hdev, int enable)
 {
     if (!hdev->vhost_ops->vhost_set_vring_enable) {
@@ -2066,6 +2675,19 @@ static int vhost_dev_set_vring_enable(struct vhost_dev *hdev, int enable)
  * device. If it is false, the vring initialization is left to be done by the
  * caller.
  */
+/*
+ * called by:
+ *   - backends/cryptodev-vhost.c|96| <<cryptodev_vhost_start_one>> r = vhost_dev_start(&crypto->dev, dev, false);
+ *   - backends/vhost-user.c|76| <<vhost_user_backend_start>> ret = vhost_dev_start(&b->dev, b->vdev, true);
+ *   - hw/block/vhost-user-blk.c|176| <<vhost_user_blk_start>> ret = vhost_dev_start(&s->dev, vdev, true);
+ *   - hw/net/vhost_net.c|280| <<vhost_net_start_one>> r = vhost_dev_start(&net->dev, dev, false);
+ *   - hw/scsi/vhost-scsi-common.c|81| <<vhost_scsi_common_start>> ret = vhost_dev_start(&vsc->dev, vdev, true);
+ *   - hw/virtio/vdpa-dev.c|263| <<vhost_vdpa_device_start>> ret = vhost_dev_start(&s->dev, vdev, true);
+ *   - hw/virtio/vhost-user-base.c|46| <<vub_start>> ret = vhost_dev_start(&vub->vhost_dev, vdev, true);
+ *   - hw/virtio/vhost-user-fs.c|80| <<vuf_start>> ret = vhost_dev_start(&fs->vhost_dev, vdev, true);
+ *   - hw/virtio/vhost-user-scmi.c|61| <<vu_scmi_start>> ret = vhost_dev_start(vhost_dev, vdev, true);
+ *   - hw/virtio/vhost-vsock-common.c|74| <<vhost_vsock_common_start>> ret = vhost_dev_start(&vvc->vhost_dev, vdev, true);
+ */
 int vhost_dev_start(struct vhost_dev *hdev, VirtIODevice *vdev, bool vrings)
 {
     int i, r;
@@ -2180,6 +2802,21 @@ fail_features:
     return r;
 }
 
+/*
+ * called by:
+ *   - backends/cryptodev-vhost.c|113| <<cryptodev_vhost_stop_one>> vhost_dev_stop(&crypto->dev, dev, false);
+ *   - backends/vhost-user.c|111| <<vhost_user_backend_stop>> vhost_dev_stop(&b->dev, b->vdev, true);
+ *   - hw/block/vhost-user-blk.c|211| <<vhost_user_blk_stop>> vhost_dev_stop(&s->dev, vdev, true);
+ *   - hw/net/vhost_net.c|329| <<vhost_net_start_one>> vhost_dev_stop(&net->dev, dev, false);
+ *   - hw/net/vhost_net.c|350| <<vhost_net_stop_one>> vhost_dev_stop(&net->dev, dev, false);
+ *   - hw/net/vhost_net.c|652| <<vhost_net_virtqueue_restart>> vhost_dev_stop(&net->dev, vdev, false);
+ *   - hw/scsi/vhost-scsi-common.c|111| <<vhost_scsi_common_stop>> vhost_dev_stop(&vsc->dev, vdev, true);
+ *   - hw/virtio/vdpa-dev.c|304| <<vhost_vdpa_device_stop>> vhost_dev_stop(&s->dev, vdev, false);
+ *   - hw/virtio/vhost-user-base.c|80| <<vub_stop>> vhost_dev_stop(&vub->vhost_dev, vdev, true);
+ *   - hw/virtio/vhost-user-fs.c|114| <<vuf_stop>> vhost_dev_stop(&fs->vhost_dev, vdev, true);
+ *   - hw/virtio/vhost-user-scmi.c|104| <<vu_scmi_stop>> vhost_dev_stop(vhost_dev, vdev, true);
+ *   - hw/virtio/vhost-vsock-common.c|109| <<vhost_vsock_common_stop>> vhost_dev_stop(&vvc->vhost_dev, vdev, true);
+ */
 /* Host notifiers must be enabled at this point. */
 void vhost_dev_stop(struct vhost_dev *hdev, VirtIODevice *vdev, bool vrings)
 {
@@ -2224,6 +2861,15 @@ void vhost_dev_stop(struct vhost_dev *hdev, VirtIODevice *vdev, bool vrings)
     hdev->vdev = NULL;
 }
 
+/*
+ * called by:
+ *   - hw/net/vhost_net.c|298| <<vhost_net_start_one>> r = vhost_net_set_backend(&net->dev, &file);
+ *   - hw/net/vhost_net.c|322| <<vhost_net_start_one>> int ret = vhost_net_set_backend(&net->dev, &file);
+ *   - hw/net/vhost_net.c|343| <<vhost_net_stop_one>> int r = vhost_net_set_backend(&net->dev, &file);
+ *   - hw/net/vhost_net.c|595| <<vhost_net_virtqueue_reset>> int r = vhost_net_set_backend(&net->dev, &file);
+ *   - hw/net/vhost_net.c|633| <<vhost_net_virtqueue_restart>> r = vhost_net_set_backend(&net->dev, &file);
+ *   - hw/net/vhost_net.c|648| <<vhost_net_virtqueue_restart>> int ret = vhost_net_set_backend(&net->dev, &file);
+ */
 int vhost_net_set_backend(struct vhost_dev *hdev,
                           struct vhost_vring_file *file)
 {
@@ -2234,6 +2880,10 @@ int vhost_net_set_backend(struct vhost_dev *hdev,
     return -ENOSYS;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|2348| <<virtio_reset>> vhost_reset_device(k->get_vhost(vdev));
+ */
 int vhost_reset_device(struct vhost_dev *hdev)
 {
     if (hdev->vhost_ops->vhost_reset_device) {
@@ -2252,6 +2902,11 @@ bool vhost_supports_device_state(struct vhost_dev *dev)
     return false;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|2415| <<vhost_save_backend_state>> ret = vhost_set_device_state_fd(dev,
+ *   - hw/virtio/vhost.c|2507| <<vhost_load_backend_state>> ret = vhost_set_device_state_fd(dev,
+ */
 int vhost_set_device_state_fd(struct vhost_dev *dev,
                               VhostDeviceStateDirection direction,
                               VhostDeviceStatePhase phase,
@@ -2269,6 +2924,11 @@ int vhost_set_device_state_fd(struct vhost_dev *dev,
     return -ENOSYS;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost.c|2465| <<vhost_save_backend_state>> ret = vhost_check_device_state(dev, errp);
+ *   - hw/virtio/vhost.c|2578| <<vhost_load_backend_state>> ret = vhost_check_device_state(dev, errp);
+ */
 int vhost_check_device_state(struct vhost_dev *dev, Error **errp)
 {
     if (dev->vhost_ops->vhost_check_device_state) {
@@ -2280,6 +2940,10 @@ int vhost_check_device_state(struct vhost_dev *dev, Error **errp)
     return -ENOSYS;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost-user-fs.c|313| <<vuf_save_state>> ret = vhost_save_backend_state(&fs->vhost_dev, f, &local_error);
+ */
 int vhost_save_backend_state(struct vhost_dev *dev, QEMUFile *f, Error **errp)
 {
     ERRP_GUARD();
@@ -2373,6 +3037,10 @@ fail:
     return ret;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost-user-fs.c|337| <<vuf_load_state>> ret = vhost_load_backend_state(&fs->vhost_dev, f, &local_error);
+ */
 int vhost_load_backend_state(struct vhost_dev *dev, QEMUFile *f, Error **errp)
 {
     ERRP_GUARD();
diff --git a/hw/virtio/virtio-pci.c b/hw/virtio/virtio-pci.c
index 524b63e5c..751a17fa3 100644
--- a/hw/virtio/virtio-pci.c
+++ b/hw/virtio/virtio-pci.c
@@ -131,6 +131,11 @@ static const VMStateDescription vmstate_virtio_pci_modern_state_sub = {
     }
 };
 
+/*
+ * 在以下使用vmstate_virtio_pci:
+ *   - hw/virtio/virtio-pci.c|158| <<virtio_pci_save_extra_state>> vmstate_save_state(f, &vmstate_virtio_pci, proxy, NULL);
+ *   - hw/virtio/virtio-pci.c|165| <<virtio_pci_load_extra_state>> return vmstate_load_state(f, &vmstate_virtio_pci, proxy, 1);
+ */
 static const VMStateDescription vmstate_virtio_pci = {
     .name = "virtio_pci",
     .version_id = 1,
@@ -151,6 +156,10 @@ static bool virtio_pci_has_extra_state(DeviceState *d)
     return proxy->flags & VIRTIO_PCI_FLAG_MIGRATE_EXTRA;
 }
 
+/*
+ * 在以下使用virtio_pci_save_extra_state():
+ *   - hw/virtio/virtio-pci.c|2581| <<virtio_pci_bus_class_init>> k->save_extra_state = virtio_pci_save_extra_state;
+ */
 static void virtio_pci_save_extra_state(DeviceState *d, QEMUFile *f)
 {
     VirtIOPCIProxy *proxy = to_virtio_pci_proxy(d);
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index 9e10cbc05..a36fcb774 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -2217,6 +2217,19 @@ static int virtio_validate_features(VirtIODevice *vdev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/vhost-user-blk.c|519| <<vhost_user_blk_device_unrealize>> virtio_set_status(vdev, 0);
+ *   - hw/s390x/virtio-ccw.c|536| <<virtio_ccw_cb>> if (virtio_set_status(vdev, status) == 0) {
+ *   - hw/virtio/vdpa-dev.c|178| <<vhost_vdpa_device_unrealize>> virtio_set_status(vdev, 0);
+ *   - hw/virtio/virtio-mmio.c|436| <<virtio_mmio_write>> virtio_set_status(vdev, value & 0xff);
+ *   - hw/virtio/virtio-pci.c|435| <<virtio_ioport_write>> virtio_set_status(vdev, val & 0xFF);
+ *   - hw/virtio/virtio-pci.c|776| <<virtio_write_config>> virtio_set_status(vdev, vdev->status & ~VIRTIO_CONFIG_S_DRIVER_OK);
+ *   - hw/virtio/virtio-pci.c|1617| <<virtio_pci_common_write>> virtio_set_status(vdev, val & 0xFF);
+ *   - hw/virtio/virtio.c|2325| <<virtio_reset>> virtio_set_status(vdev, 0);
+ *   - hw/virtio/virtio.c|3424| <<virtio_vmstate_change>> virtio_set_status(vdev, vdev->status);
+ *   - hw/virtio/virtio.c|3432| <<virtio_vmstate_change>> virtio_set_status(vdev, vdev->status);
+ */
 int virtio_set_status(VirtIODevice *vdev, uint8_t val)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -2999,6 +3012,10 @@ static const VMStateDescription vmstate_virtio = {
     }
 };
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|3066| <<virtio_device_put>> return virtio_save(VIRTIO_DEVICE(opaque), f);
+ */
 int virtio_save(VirtIODevice *vdev, QEMUFile *f)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
@@ -3408,6 +3425,10 @@ void virtio_cleanup(VirtIODevice *vdev)
     qemu_del_vm_change_state_handler(vdev->vmstate);
 }
 
+/*
+ * 在以下使用virtio_vmstate_change():
+ *   - hw/virtio/virtio.c|3485| <<virtio_init>> vdev->vmstate = qdev_add_vm_change_state_handler(DEVICE(vdev), virtio_vmstate_change, vdev);
+ */
 static void virtio_vmstate_change(void *opaque, bool running, RunState state)
 {
     VirtIODevice *vdev = opaque;
diff --git a/include/exec/ram_addr.h b/include/exec/ram_addr.h
index 891c44cf2..bddd66688 100644
--- a/include/exec/ram_addr.h
+++ b/include/exec/ram_addr.h
@@ -285,6 +285,16 @@ static inline void cpu_physical_memory_set_dirty_flag(ram_addr_t addr,
     set_bit_atomic(offset, blocks->blocks[idx]);
 }
 
+/*
+ * called by:
+ *   - accel/tcg/cputlb.c|1329| <<notdirty_write>> cpu_physical_memory_set_dirty_range(ram_addr, size, DIRTY_CLIENTS_NOCODE);
+ *   - hw/vfio/common.c|1166| <<vfio_get_dirty_bitmap>> cpu_physical_memory_set_dirty_range(ram_addr, size, tcg_enabled() ? DIRTY_CLIENTS_ALL : DIRTY_CLIENTS_NOCODE);
+ *   - include/exec/ram_addr.h|437| <<cpu_physical_memory_set_dirty_lebitmap>> cpu_physical_memory_set_dirty_range(ram_addr, TARGET_PAGE_SIZE * hpratio, clients);
+ *   - system/memory.c|2282| <<memory_region_set_dirty>> cpu_physical_memory_set_dirty_range(memory_region_get_ram_addr(mr) + addr, size, memory_region_get_dirty_log_mask(mr));
+ *   - system/physmem.c|1758| <<qemu_ram_resize>> cpu_physical_memory_set_dirty_range(block->offset, block->used_length, DIRTY_CLIENTS_ALL);
+ *   - system/physmem.c|1933| <<ram_block_add>> cpu_physical_memory_set_dirty_range(new_block->offset, new_block->used_length, DIRTY_CLIENTS_ALL);
+ *   - system/physmem.c|2687| <<invalidate_and_set_dirty>> cpu_physical_memory_set_dirty_range(addr, length, dirty_log_mask);
+ */
 static inline void cpu_physical_memory_set_dirty_range(ram_addr_t start,
                                                        ram_addr_t length,
                                                        uint8_t mask)
diff --git a/include/hw/acpi/pcihp.h b/include/hw/acpi/pcihp.h
index ac21a9591..12add5eda 100644
--- a/include/hw/acpi/pcihp.h
+++ b/include/hw/acpi/pcihp.h
@@ -46,6 +46,15 @@ typedef struct AcpiPciHpPciStatus {
 typedef struct AcpiPciHpState {
     AcpiPciHpPciStatus acpi_pcihp_pci_status[ACPI_PCIHP_MAX_HOTPLUG_BUS];
     uint32_t hotplug_select;
+    /*
+     * 在以下使用AcpiPciHpState->acpi_index:
+     *   - hw/acpi/pcihp.c|426| <<pci_read>> val = s->acpi_index;
+     *   - hw/acpi/pcihp.c|427| <<pci_read>> s->acpi_index = 0;
+     *   - hw/acpi/pcihp.c|445| <<pci_write>> s->acpi_index = 0;
+     *   - hw/acpi/pcihp.c|466| <<pci_write>> s->acpi_index = object_property_get_uint(o, "acpi-index", NULL);
+     *   - hw/acpi/pcihp.c|470| <<pci_write>> trace_acpi_pci_acpi_index_write(s->hotplug_select, slot, s->acpi_index);
+     *   - include/hw/acpi/pcihp.h|99| <<VMSTATE_PCI_HOTPLUG>> VMSTATE_UINT32_TEST(pcihp.acpi_index, state, \
+     */
     uint32_t acpi_index;
     PCIBus *root;
     MemoryRegion io;
@@ -76,6 +85,18 @@ void build_append_pcihp_slots(Aml *parent_scope, PCIBus *bus);
 
 extern const VMStateDescription vmstate_acpi_pcihp_pci_status;
 
+/*
+ * 266 static const VMStateDescription vmstate_acpi = {
+ * 267     .name = "piix4_pm",
+ * 268     .version_id = 3,
+ * 269     .minimum_version_id = 3,
+ * 270     .post_load = vmstate_acpi_post_load,
+ * ... ...
+ * 288         VMSTATE_PCI_HOTPLUG(acpi_pci_hotplug, PIIX4PMState,
+ * 289                             vmstate_test_use_acpi_hotplug_bridge,
+ * 290                             vmstate_test_migrate_acpi_index),
+ * ... ...
+ */
 #define VMSTATE_PCI_HOTPLUG(pcihp, state, test_pcihp, test_acpi_index) \
         VMSTATE_UINT32_TEST(pcihp.hotplug_select, state, \
                             test_pcihp), \
diff --git a/include/hw/block/block.h b/include/hw/block/block.h
index de3946a5f..2a50a8c16 100644
--- a/include/hw/block/block.h
+++ b/include/hw/block/block.h
@@ -68,6 +68,38 @@ static inline unsigned int get_physical_block_exp(BlockConf *conf)
     DEFINE_PROP_ON_OFF_AUTO("account-failed", _state,                   \
                             _conf.account_failed, ON_OFF_AUTO_AUTO)
 
+/*
+ * QEMU-9.0的例子.
+ *
+ * (gdb) bt
+ * #0  blk_new (ctx=0x55555716e240, perm=0, shared_perm=15) at ../block/block-backend.c:357
+ * #1  0x000055555593f279 in set_drive_helper (obj=0x5555580dc630, v=
+ *     0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, iothread=false, errp=0x7fffffffd710) at ../hw/core/qdev-properties-system.c:146
+ * #2  0x000055555593f453 in set_drive (obj=0x5555580dc630, v=0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, errp=0x7fffffffd710)
+ *     at ../hw/core/qdev-properties-system.c:190
+ * #3  0x0000555555e8b43c in field_prop_set (obj=0x5555580dc630, v=0x5555580e0fc0, name=0x5555580de030 "drive", opaque=0x555556fbbf80 <virtio_blk_properties>, errp=0x7fffffffd710)
+ *     at ../hw/core/qdev-properties.c:88
+ * #4  0x0000555555e98e36 in object_property_set (obj=0x5555580dc630, name=0x5555580de030 "drive", v=0x5555580e0fc0, errp=0x7fffffffd710) at ../qom/object.c:1472
+ * #5  0x0000555555e9c464 in property_set_alias (obj=0x5555580d4260, v=0x5555580e0e00, name=0x5555580e0d90 "drive", opaque=0x5555580de010, errp=0x7fffffffd710) at ../qom/object.c:2799
+ * #6  0x0000555555e98e36 in object_property_set (obj=0x5555580d4260, name=0x5555580e0d90 "drive", v=0x5555580e0e00, errp=0x7fffffffd710) at ../qom/object.c:1472
+ * #7  0x0000555555e9cbc1 in object_set_properties_from_qdict (obj=0x5555580d4260, qdict=0x5555580dfc70, v=0x5555580e0e00, errp=0x7fffffffd710) at ../qom/object_interfaces.c:55
+ * #8  0x0000555555e9ccbc in object_set_properties_from_keyval (obj=0x5555580d4260, qdict=0x5555580dfc70, from_json=false, errp=0x7fffffffd710) at ../qom/object_interfaces.c:73
+ * #9  0x0000555555bbc53a in qdev_device_add_from_qdict (opts=0x5555580d3220, from_json=false, errp=0x7fffffffd710) at ../system/qdev-monitor.c:712
+ * #10 0x0000555555bbc611 in qdev_device_add (opts=0x55555716d840, errp=0x5555570af7c0 <error_fatal>) at ../system/qdev-monitor.c:737
+ * #11 0x0000555555bc6d64 in device_init_func (opaque=0x0, opts=0x55555716d840, errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:1200
+ * #12 0x00005555560c439e in qemu_opts_foreach (list=0x555556f98e80 <qemu_device_opts>, func=0x555555bc6d35 <device_init_func>, opaque=0x0, errp=0x5555570af7c0 <error_fatal>)
+ *     at ../util/qemu-option.c:1135
+ * #13 0x0000555555bcac00 in qemu_create_cli_devices () at ../system/vl.c:2637
+ * #14 0x0000555555bcae46 in qmp_x_exit_preconfig (errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:2706
+ * #15 0x0000555555bcd92e in qemu_init (argc=30, argv=0x7fffffffdb18) at ../system/vl.c:3739
+ * #16 0x0000555555e8a1ef in main (argc=30, argv=0x7fffffffdb18) at ../system/main.c:47
+ *
+ * VirtIOBlock:
+ * -> BlockBackend *blk;
+ * -> VirtIOBlkConf conf;
+ *    -> BlockConf conf;
+ *       -> BlockBackend *blk;
+ */
 #define DEFINE_BLOCK_PROPERTIES(_state, _conf)                          \
     DEFINE_PROP_DRIVE("drive", _state, _conf.blk),                      \
     DEFINE_BLOCK_PROPERTIES_BASE(_state, _conf)
diff --git a/include/hw/core/cpu.h b/include/hw/core/cpu.h
index 1c9c775df..ac1686ec5 100644
--- a/include/hw/core/cpu.h
+++ b/include/hw/core/cpu.h
@@ -461,6 +461,17 @@ struct CPUState {
     CPUClass *cc;
     /*< public >*/
 
+    /*
+     * 在以下使用CPUState->nr_cores:
+     *   - hw/core/cpu-common.c|245| <<cpu_common_initfn>> cpu->nr_cores = 1;
+     *   - system/cpus.c|847| <<qemu_init_vcpu>> cpu->nr_cores = machine_topo_get_cores_per_socket(ms);
+     *   - target/i386/cpu.c|7143| <<cpu_x86_cpuid>> topo_info.cores_per_module = cs->nr_cores / env->nr_dies / env->nr_modules;
+     *   - target/i386/hvf/x86_emu.c|748| <<simulate_rdmsr>> val = cs->nr_threads * cs->nr_cores;
+     *   - target/i386/hvf/x86_emu.c|749| <<simulate_rdmsr>> val |= ((uint32_t)cs->nr_cores << 16);
+     *   - target/i386/kvm/kvm.c|3049| <<kvm_rdmsr_core_thread_count>> *val = cs->nr_threads * cs->nr_cores;
+     *   - target/i386/kvm/kvm.c|3050| <<kvm_rdmsr_core_thread_count>> *val |= ((uint32_t)cs->nr_cores << 16);
+     *   - target/i386/tcg/sysemu/misc_helper.c|472| <<helper_rdmsr>> val = (cs->nr_threads * cs->nr_cores) | (cs->nr_cores << 16);
+     */
     int nr_cores;
     int nr_threads;
 
@@ -470,6 +481,25 @@ struct CPUState {
 #endif
     int thread_id;
     bool running, has_waiter;
+    /*
+     * 在以下使用CPUState:
+     *   - accel/tcg/tcg-accel-ops-rr.c|114| <<rr_wait_io_event>> qemu_cond_wait_bql(first_cpu->halt_cond);
+     *   - accel/tcg/tcg-accel-ops-rr.c|201| <<rr_cpu_thread_fn>> qemu_cond_wait_bql(first_cpu->halt_cond);
+     *   - accel/tcg/tcg-accel-ops-rr.c|320| <<rr_start_vcpu_thread>> single_tcg_halt_cond = cpu->halt_cond;
+     *   - accel/tcg/tcg-accel-ops-rr.c|331| <<rr_start_vcpu_thread>> qemu_cond_destroy(cpu->halt_cond);
+     *   - accel/tcg/tcg-accel-ops-rr.c|332| <<rr_start_vcpu_thread>> g_free(cpu->halt_cond);
+     *   - accel/tcg/tcg-accel-ops-rr.c|334| <<rr_start_vcpu_thread>> cpu->halt_cond = single_tcg_halt_cond;
+     *   - hw/core/cpu-common.c|251| <<cpu_common_initfn>> cpu->halt_cond = g_new0(QemuCond, 1);
+     *   - hw/core/cpu-common.c|252| <<cpu_common_initfn>> qemu_cond_init(cpu->halt_cond);
+     *   - hw/core/cpu-common.c|291| <<cpu_common_finalize>> qemu_cond_destroy(cpu->halt_cond);
+     *   - hw/core/cpu-common.c|292| <<cpu_common_finalize>> g_free(cpu->halt_cond);
+     *   - system/cpu-throttle.c|57| <<cpu_throttle_thread>> qemu_cond_timedwait_bql(cpu->halt_cond,
+     *   - system/cpus.c|573| <<qemu_wait_io_event>> qemu_cond_wait(cpu->halt_cond, &bql);
+     *   - system/cpus.c|631| <<qemu_cpu_kick>> qemu_cond_broadcast(cpu->halt_cond);
+     *   - system/physmem.c|2634| <<tcg_commit>> if (cpu->halt_cond) {
+     *   - target/i386/nvmm/nvmm-accel-ops.c|51| <<qemu_nvmm_cpu_thread_fn>> qemu_cond_wait_bql(cpu->halt_cond);
+     *   - target/i386/whpx/whpx-accel-ops.c|51| <<whpx_cpu_thread_fn>> qemu_cond_wait_bql(cpu->halt_cond);
+     */
     struct QemuCond *halt_cond;
     bool thread_kicked;
     bool created;
@@ -529,6 +559,20 @@ struct CPUState {
     uint32_t kvm_fetch_index;
     uint64_t dirty_pages;
     int kvm_vcpu_stats_fd;
+    /*
+     * 在以下使用CPUState->vcpu_dirty:
+     *   - accel/kvm/kvm-all.c|425| <<kvm_create_vcpu>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|2852| <<do_kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|2860| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|2876| <<kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|2890| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|2906| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|2922| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3091| <<kvm_cpu_exec>> if (cpu->vcpu_dirty) {
+     *   - accel/kvm/kvm-all.c|3100| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/mips/kvm.c|563| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *   - target/mips/kvm.c|579| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     */
     bool vcpu_dirty;
 
     /* Use by accel-block: CPU is executing an ioctl() */
diff --git a/include/hw/virtio/vhost.h b/include/hw/virtio/vhost.h
index d75faf46e..bbf33ce14 100644
--- a/include/hw/virtio/vhost.h
+++ b/include/hw/virtio/vhost.h
@@ -31,6 +31,22 @@ struct vhost_virtqueue {
     unsigned desc_size;
     unsigned long long avail_phys;
     unsigned avail_size;
+    /*
+     * 在以下设置vhost_virtqueue->used_phys:
+     *   - hw/virtio/vhost.c|1594| <<vhost_virtqueue_start>> vq->used_phys = a = virtio_queue_get_used_addr(vdev, idx);
+     * 在以下使用vhost_virtqueue->used_phys:
+     *   - hw/virtio/vhost-vdpa.c|1535| <<vhost_vdpa_vq_get_addr>> addr->used_user_addr = (uint64_t)(unsigned long )vq->used_phys;
+     *   - hw/virtio/vhost.c|382| <<vhost_sync_dirty_bitmap>> if (!vq->used_phys && !vq->used_size) {
+     *   - hw/virtio/vhost.c|388| <<vhost_sync_dirty_bitmap>> hwaddr used_phys = vq->used_phys, used_size = vq->used_size;
+     *   - hw/virtio/vhost.c|428| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr,
+     *          vq->used_phys, range_get_last(vq->used_phys, vq->used_size));
+     *   - hw/virtio/vhost.c|429| <<vhost_sync_dirty_bitmap>> vhost_dev_sync_region(dev, section, start_addr, end_addr,
+     *          vq->used_phys, range_get_last(vq->used_phys, vq->used_size));
+     *   - hw/virtio/vhost.c|774| <<vhost_verify_ring_mappings>> r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys, vq->used_size,
+     *   - hw/virtio/vhost.c|1206| <<vhost_virtqueue_set_addr>> addr.log_guest_addr = vq->used_phys;
+     *   - hw/virtio/vhost.c|2473| <<vhost_dev_start>> vhost_device_iotlb_miss(hdev, vq->used_phys, true);
+     *   - hw/virtio/virtio-qmp.c|833| <<qmp_x_query_virtio_vhost_queue_status>> status->used_phys = hdev->vqs[queue].used_phys;
+     */
     unsigned long long used_phys;
     unsigned used_size;
     EventNotifier masked_notifier;
diff --git a/include/hw/virtio/virtio.h b/include/hw/virtio/virtio.h
index 0fcbc5c0c..491cfeeb5 100644
--- a/include/hw/virtio/virtio.h
+++ b/include/hw/virtio/virtio.h
@@ -121,8 +121,41 @@ struct VirtIODevice
      * backend (e.g. vhost) and could potentially be a subset of the
      * total feature set offered by QEMU.
      */
+    /*
+     * 注释:
+     * These fields represent a set of VirtIO features at various
+     * levels of the stack. @host_features indicates the complete
+     * feature set the VirtIO device can offer to the driver.
+     * @guest_features indicates which features the VirtIO driver has
+     * selected by writing to the feature register. Finally
+     * @backend_features represents everything supported by the
+     * backend (e.g. vhost) and could potentially be a subset of the
+     * total feature set offered by QEMU.
+     */
     uint64_t host_features;
+    /*
+     * 注释:
+     * These fields represent a set of VirtIO features at various
+     * levels of the stack. @host_features indicates the complete
+     * feature set the VirtIO device can offer to the driver.
+     * @guest_features indicates which features the VirtIO driver has
+     * selected by writing to the feature register. Finally
+     * @backend_features represents everything supported by the
+     * backend (e.g. vhost) and could potentially be a subset of the
+     * total feature set offered by QEMU.
+     */
     uint64_t guest_features;
+    /*
+     * 注释:
+     * These fields represent a set of VirtIO features at various
+     * levels of the stack. @host_features indicates the complete
+     * feature set the VirtIO device can offer to the driver.
+     * @guest_features indicates which features the VirtIO driver has
+     * selected by writing to the feature register. Finally
+     * @backend_features represents everything supported by the
+     * backend (e.g. vhost) and could potentially be a subset of the
+     * total feature set offered by QEMU.
+     */
     uint64_t backend_features;
 
     size_t config_len;
diff --git a/include/net/net.h b/include/net/net.h
index c8f679761..7dce8bf83 100644
--- a/include/net/net.h
+++ b/include/net/net.h
@@ -90,6 +90,14 @@ typedef struct NetClientInfo {
     SetVnetLE *set_vnet_le;
     SetVnetBE *set_vnet_be;
     NetAnnounce *announce;
+    /*
+     * 在以下使用NetClientInfo->set_steering_ebpf:
+     *   - net/tap.c|349| <<global>> .set_steering_ebpf = tap_set_steering_ebpf,
+     *   - net/vhost-vdpa.c|442| <<global>> .set_steering_ebpf = vhost_vdpa_set_steering_ebpf,
+     *   - net/vhost-vdpa.c|1309| <<global>> .set_steering_ebpf = vhost_vdpa_set_steering_ebpf,
+     *   - hw/net/virtio-net.c|1240| <<virtio_net_attach_ebpf_to_backend>> if (nc == NULL || nc->info->set_steering_ebpf == NULL) {
+     *   - hw/net/virtio-net.c|1244| <<virtio_net_attach_ebpf_to_backend>> return nc->info->set_steering_ebpf(nc, prog_fd);
+     */
     SetSteeringEBPF *set_steering_ebpf;
     NetCheckPeerType *check_peer_type;
 } NetClientInfo;
diff --git a/include/standard-headers/linux/vhost_types.h b/include/standard-headers/linux/vhost_types.h
index fd5404493..40f9a6275 100644
--- a/include/standard-headers/linux/vhost_types.h
+++ b/include/standard-headers/linux/vhost_types.h
@@ -27,6 +27,14 @@ struct vhost_vring_file {
 
 };
 
+/*
+ * QEMU在以下使用VHOST_VRING_F_LOG:
+ *   -  hw/virtio/vhost-user.c|1366| <<vhost_user_set_vring_addr>> bool wait_for_reply = addr->flags & (1 << VHOST_VRING_F_LOG);
+ *   - hw/virtio/vhost.c|1454| <<vhost_virtqueue_set_addr>> addr.flags = enable_log ? (1 << VHOST_VRING_F_LOG) : 0;
+ *
+ * 注释:
+ * Whether log address is valid. If set enables logging.
+ */
 struct vhost_vring_addr {
 	unsigned int index;
 	/* Option flags. */
@@ -164,6 +172,22 @@ struct vhost_vdpa_iova_range {
 };
 
 /* Feature bits */
+/*
+ * QEMU在以下使用VHOST_F_LOG_ALL:
+ *   - net/vhost-vdpa.c|126| <<global>> BIT_ULL(VHOST_F_LOG_ALL) |
+ *   - hw/virtio/vhost-user.c|1428| <<vhost_user_set_features>> bool log_enabled = features & (0x1ULL << VHOST_F_LOG_ALL);
+ *   - hw/virtio/vhost-vdpa.c|819| <<vhost_vdpa_set_features>> if ((v->acked_features ^ features) == BIT_ULL(VHOST_F_LOG_ALL)) {
+ *   - hw/virtio/vhost-vdpa.c|831| <<vhost_vdpa_set_features>> features &= ~BIT_ULL(VHOST_F_LOG_ALL);
+ *   - hw/virtio/vhost-vdpa.c|1513| <<vhost_vdpa_get_features>> *features |= BIT_ULL(VHOST_F_LOG_ALL);
+ *   - hw/virtio/vhost.c|1475| <<vhost_dev_set_features>> features |= 0x1ULL << VHOST_F_LOG_ALL;
+ *   - hw/virtio/vhost.c|2144| <<vhost_dev_init>> if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {
+ *   - subprojects/libvhost-user/libvhost-user.c|733| <<vu_log_write>> if (!(dev->features & (1ULL << VHOST_F_LOG_ALL)) ||
+ *   - subprojects/libvhost-user/libvhost-user.c|785| <<vu_get_features_exec>> 1ULL << VHOST_F_LOG_ALL |
+ *   - tests/qtest/vhost-user-test.c|1046| <<vu_net_get_features>> uint64_t features = 0x1ULL << VHOST_F_LOG_ALL |
+ *
+ * 用来Log all write descriptors. Can be changed while device is active.
+ * 是给dev->feature用的
+ */
 /* Log all write descriptors. Can be changed while device is active. */
 #define VHOST_F_LOG_ALL 26
 /* vhost-net should add virtio_net_hdr for RX, and strip for TX packets. */
diff --git a/include/sysemu/accel-ops.h b/include/sysemu/accel-ops.h
index a08867223..1ddde9436 100644
--- a/include/sysemu/accel-ops.h
+++ b/include/sysemu/accel-ops.h
@@ -41,8 +41,35 @@ struct AccelOpsClass {
     void (*kick_vcpu_thread)(CPUState *cpu);
     bool (*cpu_thread_is_idle)(CPUState *cpu);
 
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_reset:
+     *   - accel/hvf/hvf-accel-ops.c|581| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|106| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - system/cpus.c|178| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - system/cpus.c|179| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|90| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|93| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     void (*synchronize_post_reset)(CPUState *cpu);
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init:
+     *   - accel/hvf/hvf-accel-ops.c|582| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|107| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|185| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|186| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|91| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|94| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     void (*synchronize_post_init)(CPUState *cpu);
+    /*
+     * 在以下使用AccelOpsClass->synchronize_state:
+     *   - accel/hvf/hvf-accel-ops.c|583| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|108| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - system/cpus.c|171| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - system/cpus.c|172| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     void (*synchronize_state)(CPUState *cpu);
     void (*synchronize_pre_loadvm)(CPUState *cpu);
     void (*synchronize_pre_resume)(bool step_pending);
diff --git a/include/sysemu/kvm.h b/include/sysemu/kvm.h
index 9cf14ca3d..f8f7cb74a 100644
--- a/include/sysemu/kvm.h
+++ b/include/sysemu/kvm.h
@@ -361,6 +361,34 @@ int kvm_arch_process_async_events(CPUState *cpu);
 
 int kvm_arch_get_registers(CPUState *cpu);
 
+/*
+ * 在以下使用KVM_PUT_RESET_STATE:
+ *   - accel/kvm/kvm-all.c|2883| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE);
+ *   - target/i386/kvm/kvm.c|4508| <<kvm_put_msrs>> if (level >= KVM_PUT_RESET_STATE) {
+ *   - target/i386/kvm/kvm.c|5854| <<kvm_put_vcpu_events>> if (level >= KVM_PUT_RESET_STATE) {
+ *   - target/i386/kvm/kvm.c|6068| <<kvm_arch_put_registers>> if (level >= KVM_PUT_RESET_STATE) {
+ *   - target/i386/kvm/kvm.c|6081| <<kvm_arch_put_registers>> if (level >= KVM_PUT_RESET_STATE) {
+ *   - target/i386/kvm/kvm.c|6126| <<kvm_arch_put_registers>> if (level >= KVM_PUT_RESET_STATE) {
+ *   - target/ppc/kvm.c|954| <<kvm_arch_put_registers>> if (cap_segstate && (level >= KVM_PUT_RESET_STATE)) {
+ *   - target/ppc/kvm.c|961| <<kvm_arch_put_registers>> if (cap_hior && (level >= KVM_PUT_RESET_STATE)) {
+ *   - target/riscv/kvm/kvm-cpu.c|1264| <<kvm_arch_put_registers>> if (KVM_PUT_RESET_STATE == level) {
+ *
+ * 在以下使用KVM_PUT_RUNTIME_STATE:
+ *   - accel/kvm/kvm-all.c|3092| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);
+ *   - target/arm/kvm.c|892| <<kvm_arm_cpreg_level>> return KVM_PUT_RUNTIME_STATE;
+ *   - target/ppc/kvm.c|1008| <<kvm_arch_put_registers>> if (level > KVM_PUT_RUNTIME_STATE) {
+ *   - target/s390x/kvm/kvm.c|518| <<kvm_arch_put_registers>> if (level == KVM_PUT_RUNTIME_STATE) {
+ *
+ * 在以下使用KVM_PUT_FULL_STATE:
+ *   - accel/kvm/kvm-all.c|2900| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);
+ *   - target/arm/kvm.c|890| <<kvm_arm_cpreg_level>> return KVM_PUT_FULL_STATE;
+ *   - target/arm/machine.c|980| <<cpu_post_load>> if (!write_list_to_kvmstate(cpu, KVM_PUT_FULL_STATE)) {
+ *   - target/i386/kvm/kvm.c|6088| <<kvm_arch_put_registers>> if (level == KVM_PUT_FULL_STATE) {
+ *   - target/i386/kvm/kvm.c|6098| <<kvm_arch_put_registers>> if (xen_mode == XEN_EMULATE && level == KVM_PUT_FULL_STATE) {
+ *   - target/loongarch/kvm/kvm.c|322| <<kvm_loongarch_put_csr>> if (level >= KVM_PUT_FULL_STATE) {
+ *   - target/mips/kvm.c|597| <<kvm_mips_put_fpu_registers>> if (level == KVM_PUT_FULL_STATE) {
+ *   - target/mips/kvm.c|637| <<kvm_mips_put_fpu_registers>> if (level == KVM_PUT_FULL_STATE) {
+ */
 /* state subset only touched by the VCPU itself during runtime */
 #define KVM_PUT_RUNTIME_STATE   1
 /* state subset modified during VCPU reset */
diff --git a/include/sysemu/kvm_int.h b/include/sysemu/kvm_int.h
index 1d8fb1473..c0ac8996a 100644
--- a/include/sysemu/kvm_int.h
+++ b/include/sysemu/kvm_int.h
@@ -103,6 +103,22 @@ struct KVMState
 {
     AccelState parent_obj;
 
+    /*
+     * 在以下设置KVMState->nr_slots:
+     *   - accel/kvm/kvm-all.c|2520| <<kvm_init>> s->nr_slots = kvm_check_extension(s, KVM_CAP_NR_MEMSLOTS);
+     *   - accel/kvm/kvm-all.c|2524| <<kvm_init>> s->nr_slots = 32;
+     * 在以下使用KVMState->nr_slots:
+     *   - accel/kvm/kvm-all.c|179| <<kvm_get_max_memslots>> return s->nr_slots;
+     *   - accel/kvm/kvm-all.c|197| <<kvm_get_free_memslots>> return s->nr_slots - used_slots;
+     *   - accel/kvm/kvm-all.c|210| <<kvm_get_free_slot>> for (i = 0; i < s->nr_slots; i++) {
+     *   - accel/kvm/kvm-all.c|243| <<kvm_lookup_matching_slot>> for (i = 0; i < s->nr_slots; i++) {
+     *   - accel/kvm/kvm-all.c|285| <<kvm_physical_memory_addr_from_host>> for (i = 0; i < s->nr_slots; i++) {
+     *   - accel/kvm/kvm-all.c|1103| <<kvm_physical_log_clear>> for (i = 0; i < s->nr_slots; i++) {
+     *   - accel/kvm/kvm-all.c|1790| <<kvm_log_sync_global>> for (i = 0; i < s->nr_slots; i++) {
+     *   - accel/kvm/kvm-all.c|1905| <<kvm_memory_listener_register>> kml->slots = g_new0(KVMSlot, s->nr_slots);
+     *   - accel/kvm/kvm-all.c|1908| <<kvm_memory_listener_register>> for (i = 0; i < s->nr_slots; i++) {
+     *   - accel/kvm/kvm-all.c|2523| <<kvm_init>> if (!s->nr_slots) {
+     */
     int nr_slots;
     int fd;
     int vmfd;
diff --git a/migration/migration.c b/migration/migration.c
index 3dea06d57..c7f98360a 100644
--- a/migration/migration.c
+++ b/migration/migration.c
@@ -1132,6 +1132,16 @@ bool migration_is_setup_or_active(void)
     }
 }
 
+/*
+ * called by:
+ *   - migration/migration.c|1530| <<migrate_fd_cancel>> if (!migration_is_running()) {
+ *   - migration/migration.c|2021| <<migrate_prepare>> if (migration_is_running()) {
+ *   - migration/options.c|603| <<migrate_cap_set>> if (migration_is_running()) {
+ *   - migration/options.c|642| <<qmp_migrate_set_capabilities>> if (migration_is_running() || migration_in_colo_state()) {
+ *   - migration/savevm.c|1710| <<qemu_savevm_state>> if (migration_is_running()) {
+ *   - system/dirtylimit.c|450| <<dirtylimit_is_allowed>> if (migration_is_running() &&
+ *   - target/riscv/kvm/kvm-cpu.c|744| <<kvm_riscv_put_regs_timer>> if (migration_is_running()) {
+ */
 bool migration_is_running(void)
 {
     MigrationState *s = current_migration;
@@ -1728,6 +1738,20 @@ int migrate_init(MigrationState *s, Error **errp)
     s->total_time = 0;
     s->vm_old_state = -1;
     s->iteration_initial_bytes = 0;
+    /*
+     * 在以下使用MigrationState->threshold_size:
+     *   - migration/migration.c|1731| <<migrate_init>> s->threshold_size = 0;
+     *   - migration/migration.c|3191| <<migration_update_counters>> s->threshold_size = expected_bw_per_ms * migrate_downtime_limit();
+     *   - migration/migration.c|3218| <<migration_update_counters>> trace_migrate_transferred(transferred, time_spent, bandwidth, switchover_bw / 1000, s->threshold_size);
+     *   - migration/migration.c|3257| <<migration_iteration_run>> if (pending_size < s->threshold_size) {
+     *   - migration/migration.c|3263| <<migration_iteration_run>> if ((!pending_size || pending_size < s->threshold_size) && can_switchover) {
+     *   - migration/migration.c|3270| <<migration_iteration_run>> if (!in_postcopy && must_precopy <= s->threshold_size && can_switchover &&
+     *
+     * 注释:
+     * The final stage happens when the remaining data is smaller than
+     * this threshold; it's calculated from the requested downtime and
+     * measured bandwidth, or avail-switchover-bandwidth if specified.
+     */
     s->threshold_size = 0;
     s->switchover_acked = false;
     s->rdma_migration = false;
@@ -3157,6 +3181,11 @@ static void update_iteration_initial_status(MigrationState *s)
     s->iteration_initial_pages = ram_get_total_transferred_pages();
 }
 
+/*
+ * called by:
+ *   - migration/migration.c|3455| <<migration_rate_limit>> migration_update_counters(s, now);
+ *   - migration/migration.c|3777| <<bg_migration_thread>> migration_update_counters(s, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));
+ */
 static void migration_update_counters(MigrationState *s,
                                       int64_t current_time)
 {
@@ -3188,6 +3217,20 @@ static void migration_update_counters(MigrationState *s,
         expected_bw_per_ms = bandwidth;
     }
 
+    /*
+     * 在以下使用MigrationState->threshold_size:
+     *   - migration/migration.c|1731| <<migrate_init>> s->threshold_size = 0;
+     *   - migration/migration.c|3191| <<migration_update_counters>> s->threshold_size = expected_bw_per_ms * migrate_downtime_limit();
+     *   - migration/migration.c|3218| <<migration_update_counters>> trace_migrate_transferred(transferred, time_spent, bandwidth, switchover_bw / 1000, s->threshold_size);
+     *   - migration/migration.c|3257| <<migration_iteration_run>> if (pending_size < s->threshold_size) {
+     *   - migration/migration.c|3263| <<migration_iteration_run>> if ((!pending_size || pending_size < s->threshold_size) && can_switchover) {
+     *   - migration/migration.c|3270| <<migration_iteration_run>> if (!in_postcopy && must_precopy <= s->threshold_size && can_switchover &&
+     *
+     * 注释:
+     * The final stage happens when the remaining data is smaller than
+     * this threshold; it's calculated from the requested downtime and
+     * measured bandwidth, or avail-switchover-bandwidth if specified.
+     */
     s->threshold_size = expected_bw_per_ms * migrate_downtime_limit();
 
     s->mbps = (((double) transferred * 8.0) /
@@ -3254,18 +3297,60 @@ static MigIterateState migration_iteration_run(MigrationState *s)
     pending_size = must_precopy + can_postcopy;
     trace_migrate_pending_estimate(pending_size, must_precopy, can_postcopy);
 
+    /*
+     * 在以下使用MigrationState->threshold_size:
+     *   - migration/migration.c|1731| <<migrate_init>> s->threshold_size = 0;
+     *   - migration/migration.c|3191| <<migration_update_counters>> s->threshold_size = expected_bw_per_ms * migrate_downtime_limit();
+     *   - migration/migration.c|3218| <<migration_update_counters>> trace_migrate_transferred(transferred, time_spent, bandwidth, switchover_bw / 1000, s->threshold_size);
+     *   - migration/migration.c|3257| <<migration_iteration_run>> if (pending_size < s->threshold_size) {
+     *   - migration/migration.c|3263| <<migration_iteration_run>> if ((!pending_size || pending_size < s->threshold_size) && can_switchover) {
+     *   - migration/migration.c|3270| <<migration_iteration_run>> if (!in_postcopy && must_precopy <= s->threshold_size && can_switchover &&
+     *
+     * 注释:
+     * The final stage happens when the remaining data is smaller than
+     * this threshold; it's calculated from the requested downtime and
+     * measured bandwidth, or avail-switchover-bandwidth if specified.
+     */
     if (pending_size < s->threshold_size) {
         qemu_savevm_state_pending_exact(&must_precopy, &can_postcopy);
         pending_size = must_precopy + can_postcopy;
         trace_migrate_pending_exact(pending_size, must_precopy, can_postcopy);
     }
 
+    /*
+     * 在以下使用MigrationState->threshold_size:
+     *   - migration/migration.c|1731| <<migrate_init>> s->threshold_size = 0;
+     *   - migration/migration.c|3191| <<migration_update_counters>> s->threshold_size = expected_bw_per_ms * migrate_downtime_limit();
+     *   - migration/migration.c|3218| <<migration_update_counters>> trace_migrate_transferred(transferred, time_spent, bandwidth, switchover_bw / 1000, s->threshold_size);
+     *   - migration/migration.c|3257| <<migration_iteration_run>> if (pending_size < s->threshold_size) {
+     *   - migration/migration.c|3263| <<migration_iteration_run>> if ((!pending_size || pending_size < s->threshold_size) && can_switchover) {
+     *   - migration/migration.c|3270| <<migration_iteration_run>> if (!in_postcopy && must_precopy <= s->threshold_size && can_switchover &&
+     *
+     * 注释:
+     * The final stage happens when the remaining data is smaller than
+     * this threshold; it's calculated from the requested downtime and
+     * measured bandwidth, or avail-switchover-bandwidth if specified.
+     */
     if ((!pending_size || pending_size < s->threshold_size) && can_switchover) {
         trace_migration_thread_low_pending(pending_size);
         migration_completion(s);
         return MIG_ITERATE_BREAK;
     }
 
+    /*
+     * 在以下使用MigrationState->threshold_size:
+     *   - migration/migration.c|1731| <<migrate_init>> s->threshold_size = 0;
+     *   - migration/migration.c|3191| <<migration_update_counters>> s->threshold_size = expected_bw_per_ms * migrate_downtime_limit();
+     *   - migration/migration.c|3218| <<migration_update_counters>> trace_migrate_transferred(transferred, time_spent, bandwidth, switchover_bw / 1000, s->threshold_size);
+     *   - migration/migration.c|3257| <<migration_iteration_run>> if (pending_size < s->threshold_size) {
+     *   - migration/migration.c|3263| <<migration_iteration_run>> if ((!pending_size || pending_size < s->threshold_size) && can_switchover) {
+     *   - migration/migration.c|3270| <<migration_iteration_run>> if (!in_postcopy && must_precopy <= s->threshold_size && can_switchover &&
+     *
+     * 注释:
+     * The final stage happens when the remaining data is smaller than
+     * this threshold; it's calculated from the requested downtime and
+     * measured bandwidth, or avail-switchover-bandwidth if specified.
+     */
     /* Still a significant amount to transfer */
     if (!in_postcopy && must_precopy <= s->threshold_size && can_switchover &&
         qatomic_read(&s->start_postcopy)) {
@@ -3375,6 +3460,11 @@ void migration_consume_urgent_request(void)
     qemu_sem_wait(&migrate_get_current()->rate_limit_sem);
 }
 
+/*
+ * called by:
+ *   - migration/migration.c|3626| <<migration_thread>> urgent = migration_rate_limit();
+ *   - migration/ram.c|2206| <<ram_save_host_page>> migration_rate_limit();
+ */
 /* Returns true if the rate limiting was broken by an urgent request */
 bool migration_rate_limit(void)
 {
@@ -3452,6 +3542,10 @@ static void qemu_savevm_wait_unplug(MigrationState *s, int old_state,
  * Master migration thread on the source VM.
  * It drives the migration and pumps the data down the outgoing channel.
  */
+/*
+ * 在以下使用migration_thread():
+ *   - migration/migration.c|3889| <<migrate_fd_connect>> qemu_thread_create(&s->thread, "mig/src/main", migration_thread, s, QEMU_THREAD_JOINABLE);
+ */
 static void *migration_thread(void *opaque)
 {
     MigrationState *s = opaque;
diff --git a/migration/migration.h b/migration/migration.h
index 38aa1402d..7286c8e78 100644
--- a/migration/migration.h
+++ b/migration/migration.h
@@ -296,6 +296,20 @@ struct MigrationState {
      * this threshold; it's calculated from the requested downtime and
      * measured bandwidth, or avail-switchover-bandwidth if specified.
      */
+    /*
+     * 在以下使用MigrationState->threshold_size:
+     *   - migration/migration.c|1731| <<migrate_init>> s->threshold_size = 0;
+     *   - migration/migration.c|3191| <<migration_update_counters>> s->threshold_size = expected_bw_per_ms * migrate_downtime_limit();
+     *   - migration/migration.c|3218| <<migration_update_counters>> trace_migrate_transferred(transferred, time_spent, bandwidth, switchover_bw / 1000, s->threshold_size);
+     *   - migration/migration.c|3257| <<migration_iteration_run>> if (pending_size < s->threshold_size) {
+     *   - migration/migration.c|3263| <<migration_iteration_run>> if ((!pending_size || pending_size < s->threshold_size) && can_switchover) {
+     *   - migration/migration.c|3270| <<migration_iteration_run>> if (!in_postcopy && must_precopy <= s->threshold_size && can_switchover &&
+     *
+     * 注释:
+     * The final stage happens when the remaining data is smaller than
+     * this threshold; it's calculated from the requested downtime and
+     * measured bandwidth, or avail-switchover-bandwidth if specified.
+     */
     uint64_t threshold_size;
 
     /* params from 'migrate-set-parameters' */
diff --git a/migration/options.c b/migration/options.c
index 645f55003..5bab39ca4 100644
--- a/migration/options.c
+++ b/migration/options.c
@@ -721,10 +721,39 @@ bool migrate_direct_io(void)
         s->capabilities[MIGRATION_CAPABILITY_MULTIFD];
 }
 
+/*
+ * called by:
+ *   - migration/migration.c|3191| <<migration_update_counters>> s->threshold_size = expected_bw_per_ms * migrate_downtime_limit();
+ *   - migration/migration.c|3743| <<migrate_fd_connect>> s->expected_downtime = migrate_downtime_limit();
+ */
 uint64_t migrate_downtime_limit(void)
 {
     MigrationState *s = migrate_get_current();
 
+    /*
+     * 在以下使用MigrationState->threshold_size:
+     *   - migration/migration.c|1731| <<migrate_init>> s->threshold_size = 0;
+     *   - migration/migration.c|3191| <<migration_update_counters>> s->threshold_size = expected_bw_per_ms * migrate_downtime_limit();
+     *   - migration/migration.c|3218| <<migration_update_counters>> trace_migrate_transferred(transferred, time_spent, bandwidth, switchover_bw / 1000, s->threshold_size);
+     *   - migration/migration.c|3257| <<migration_iteration_run>> if (pending_size < s->threshold_size) {
+     *   - migration/migration.c|3263| <<migration_iteration_run>> if ((!pending_size || pending_size < s->threshold_size) && can_switchover) {
+     *   - migration/migration.c|3270| <<migration_iteration_run>> if (!in_postcopy && must_precopy <= s->threshold_size && can_switchover &&
+     *
+     * 注释:
+     * The final stage happens when the remaining data is smaller than
+     * this threshold; it's calculated from the requested downtime and
+     * measured bandwidth, or avail-switchover-bandwidth if specified.
+     *
+     *
+     * 在以下使用downtime_limit:
+     *   - migration/options.c|112| <<global>> DEFINE_PROP_UINT64("x-downtime-limit", MigrationState, parameters.downtime_limit, DEFAULT_MIGRATE_SET_DOWNTIME),
+     *   - migration/migration-hmp-cmds.c|290| <<hmp_info_migrate_parameters>> monitor_printf(mon ... params->downtime_limit);
+     *   - migration/migration-hmp-cmds.c|560| <<hmp_migrate_set_parameter>> visit_type_size(v, param, &p->downtime_limit, &err);
+     *   - migration/options.c|886| <<qmp_query_migrate_parameters>> params->downtime_limit = s->parameters.downtime_limit;
+     *   - migration/options.c|1017| <<migrate_params_check>> if (params->has_downtime_limit && (params->downtime_limit > MAX_MIGRATE_DOWNTIME)) {
+     *   - migration/options.c|1185| <<migrate_params_test_apply>> dest->downtime_limit = params->downtime_limit;
+     *   - migration/options.c|1304| <<migrate_params_apply>> s->parameters.downtime_limit = params->downtime_limit;
+     */
     return s->parameters.downtime_limit;
 }
 
diff --git a/migration/ram.c b/migration/ram.c
index edec1a2d0..e35d3dbf8 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -68,6 +68,98 @@
 #include "qemu/userfaultfd.h"
 #endif /* defined(__linux__) */
 
+/*
+ * 下面是发送端的流程.
+ * 
+ * qmp_migrate()
+ * -> migrate_prepare()
+ * -> socket_start_outgoing_migration()
+ *    -> qio_channel_socket_connect_async(socket_outgoing_migration)
+ *       -> socket_outgoing_migration()
+ *          -> migration_channel_connect()
+ *             -> multifd_save_setup()
+ *                -> multifd_new_send_channel_create() --> N次
+ *                   -> socket_send_channel_create(multifd_new_send_channel_async)
+ *                      -> multifd_new_send_channel_async()
+ *                         -> multifd_channel_connect() --> 创建multifd_send_thread()
+ *             -> qemu_thread_create(migration_thread)
+ *
+ * migration_thread()
+ * -> qemu_savevm_state_header() --> 发送头部header, 比如QEMU_VM_FILE_MAGIC和QEMU_VM_FILE_VERSION
+ * -> qemu_savevm_state_setup()
+ *    -> se->ops->save_setup = ram_save_setup() --> 第一阶段
+ *       -> ram_init_all()
+ *          -> ram_init_bitmaps()
+ *             -> ram_list_init_bitmaps()
+ *                -> 遍历&ram_list.blocks: RAMBLOCK_FOREACH_NOT_IGNORED(block)
+ *                   -> block->bmap = bitmap_new(pages);
+ *                   -> bitmap_set(block->bmap, 0, pages); --> 第一阶段, 把所有block的bitmap都设置成全是1, 所以page都是dirty!
+ *                   -> block->clear_bmap_shift = shift;
+ *                   -> block->clear_bmap = bitmap_new(clear_bmap_size(pages, shift));
+ *             -> memory_global_dirty_log_start()
+ *                -> memory_region_transaction_commit()
+ *                   -> kvm_log_start()
+ *                      -> kvm_section_update_flags()
+ *                         -> kvm_slot_update_flags() --> 设置KVM_MEM_LOG_DIRTY_PAGES
+ *          -> migration_bitmap_sync_precopy()
+ *             -> migration_bitmap_sync() --> 脏页同步
+ *                -> memory_global_dirty_log_sync()
+ *                   -> memory_region_sync_dirty_bitmap()
+ *                      -> kvm_log_sync()
+ *                         -> kvm_physical_sync_dirty_bitmap()
+ *                            -> kvm_slot_get_dirty_log()
+ * -> while: migration_iteration_run()  --> 第二阶段
+ *    -> qemu_savevm_state_pending_exact()
+ *       -> ram_state_pending_exact()
+ *          -> migration_bitmap_sync_precopy()
+ *             -> migration_bitmap_sync() --> 脏页同步
+ *                -> memory_global_dirty_log_sync()
+ *                   -> memory_region_sync_dirty_bitmap()
+ *                      -> kvm_log_sync()
+ *                         -> kvm_physical_sync_dirty_bitmap()
+ *                            -> kvm_slot_get_dirty_log()
+ *    -> migration_completion() --> 如果完成 --> 第三阶段(ram+dev)
+ *       -> migration_completion_precopy()
+ *          -> qemu_savevm_state_complete_precopy()
+ *             -> qemu_savevm_state_complete_precopy_iterable() --> 剩余可以一次性迁移的最后一部分数据
+ *                -> se->ops->save_live_complete_precopy = ram_save_complete()
+ *                   -> ram_find_and_save_block()
+ *                      -> ram_save_host_page()
+ *                         -> migration_ops->ram_save_target_page = ram_save_target_page_legacy()
+ *                            -> 如果multifd: ram_save_multifd_page()
+ *                               -> multifd_queue_page()
+ *                                  -> multifd_send_pages()
+ *                                     -> p->pages = pages;
+ *                                     -> qemu_sem_post(&p->sem); --> 唤醒multifd_send_thread()
+ *                            -> 如果不multifd: ram_save_page()
+ *                               -> save_normal_page()
+ *                                  -> qemu_put_buffer()
+ *                   -> multifd_send_sync_main()
+ *             -> qemu_savevm_state_complete_precopy_non_iterable() --> 迁移设备(non-iterable)
+ *                -> 针对每一个&savevm_state.handlers调用vmstate_save()
+ *                   -> vmstate_save()
+ *                      -> vmstate_save_state_with_err()
+ *                         -> vmstate_save_state_v()
+ *                            -> virtio_device_put()
+ *                               -> virtio_save()
+ *    -> qemu_savevm_state_iterate() --> 第二阶段真正迭代的地方
+ *       -> save_section_header(f, se, QEMU_VM_SECTION_PART); --> 设置数据段头标标识
+ *       -> se->ops->save_live_iterate = ram_save_iterate()
+ *          -> ram_find_and_save_block()
+ *             -> ram_save_host_page()
+ *                -> migration_ops->ram_save_target_page = ram_save_target_page_legacy()
+ *                   -> 如果multifd: ram_save_multifd_page()
+ *                      -> multifd_queue_page()
+ *                         -> multifd_send_pages()
+ *                            -> p->pages = pages;
+ *                            -> qemu_sem_post(&p->sem); --> 唤醒multifd_send_thread()
+ *                   -> 如果不multifd: ram_save_page()
+ *                      -> save_normal_page()
+ *                         -> qemu_put_buffer()
+ *          -> multifd_send_sync_main()
+ *       -> save_section_footer(f, se);
+ */
+
 /***********************************************************/
 /* ram save/restore */
 
@@ -1013,6 +1105,10 @@ static void migration_dirty_limit_guest(void)
     trace_migration_dirty_limit_guest(quota_dirtyrate);
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|1074| <<migration_bitmap_sync>> migration_trigger_throttle(rs);
+ */
 static void migration_trigger_throttle(RAMState *rs)
 {
     uint64_t threshold = migrate_throttle_trigger_threshold();
@@ -2769,6 +2865,10 @@ static void migration_bitmap_clear_discarded_pages(RAMState *rs)
     }
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|2820| <<ram_init_all>> if (!ram_init_bitmaps(*rsp, errp)) {
+ */
 static bool ram_init_bitmaps(RAMState *rs, Error **errp)
 {
     bool ret = true;
@@ -2802,6 +2902,10 @@ out_unlock:
     return true;
 }
 
+/*
+ * called by:
+ *   - migration/ram.c|3014| <<ram_save_setup>> if (ram_init_all(rsp, errp) != 0) {
+ */
 static int ram_init_all(RAMState **rsp, Error **errp)
 {
     if (!ram_state_init(rsp, errp)) {
diff --git a/net/tap-linux.c b/net/tap-linux.c
index 1226d5fda..b8b74f425 100644
--- a/net/tap-linux.c
+++ b/net/tap-linux.c
@@ -318,6 +318,10 @@ int tap_fd_get_ifname(int fd, char *ifname)
     return 0;
 }
 
+/*
+ * called by:
+ *   - net/tap.c|322| <<tap_set_steering_ebpf>> return tap_fd_set_steering_ebpf(s->fd, prog_fd) == 0;
+ */
 int tap_fd_set_steering_ebpf(int fd, int prog_fd)
 {
     if (ioctl(fd, TUNSETSTEERINGEBPF, (void *) &prog_fd) != 0) {
diff --git a/net/tap.c b/net/tap.c
index 3f90022c0..c15972969 100644
--- a/net/tap.c
+++ b/net/tap.c
@@ -314,6 +314,16 @@ static void tap_poll(NetClientState *nc, bool enable)
     tap_write_poll(s, enable);
 }
 
+/*
+ * 在以下使用NetClientInfo->set_steering_ebpf:
+ *   - net/tap.c|349| <<global>> .set_steering_ebpf = tap_set_steering_ebpf,
+ *   - net/vhost-vdpa.c|442| <<global>> .set_steering_ebpf = vhost_vdpa_set_steering_ebpf,
+ *   - net/vhost-vdpa.c|1309| <<global>> .set_steering_ebpf = vhost_vdpa_set_steering_ebpf,
+ *   - hw/net/virtio-net.c|1240| <<virtio_net_attach_ebpf_to_backend>> if (nc == NULL || nc->info->set_steering_ebpf == NULL) {
+ *   - hw/net/virtio-net.c|1244| <<virtio_net_attach_ebpf_to_backend>> return nc->info->set_steering_ebpf(nc, prog_fd);
+ *
+ * struct NetClientInfo net_tap_info.set_steering_ebpf = tap_set_steering_ebpf()
+ */
 static bool tap_set_steering_ebpf(NetClientState *nc, int prog_fd)
 {
     TAPState *s = DO_UPCAST(TAPState, nc, nc);
diff --git a/qom/object.c b/qom/object.c
index 157a45c5f..41622d3d8 100644
--- a/qom/object.c
+++ b/qom/object.c
@@ -1704,6 +1704,32 @@ int object_property_get_enum(Object *obj, const char *name,
     return ret;
 }
 
+/*
+ * 旧的version的实现
+ *
+ * (gdb) bt
+ * #0  object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1646
+ * #1  0x0000555555d28d33 in object_apply_global_props (obj=0x555556a5f460, props=0x5555569b8f00, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:412
+ * #2  0x0000555555d20e5c in qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:790
+ * #3  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #4  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #5  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #7  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #9  0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #10 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #11 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #12 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #13 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #14 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.    c:157
+ * #15 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #16 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #17 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #18 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #19 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #20 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ */
 bool object_property_parse(Object *obj, const char *name,
                            const char *string, Error **errp)
 {
diff --git a/system/cpus.c b/system/cpus.c
index 1c818ff68..3ab6afe0a 100644
--- a/system/cpus.c
+++ b/system/cpus.c
@@ -130,6 +130,17 @@ void hw_error(const char *fmt, ...)
     abort();
 }
 
+/*
+ * called by:
+ *   - dump/dump.c|1819| <<dump_init>> cpu_synchronize_all_states();
+ *   - hw/i386/pc.c|1728| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+ *   - migration/colo.c|685| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+ *   - migration/migration.c|3664| <<bg_migration_thread>> cpu_synchronize_all_states();
+ *   - migration/savevm.c|1618| <<qemu_savevm_state_complete_precopy>> cpu_synchronize_all_states();
+ *   - migration/savevm.c|1775| <<qemu_save_device_state>> cpu_synchronize_all_states();
+ *   - system/runstate.c|548| <<qemu_system_reset>> cpu_synchronize_all_states();
+ *   - target/arm/hvf/hvf.c|2039| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+ */
 void cpu_synchronize_all_states(void)
 {
     CPUState *cpu;
@@ -139,6 +150,11 @@ void cpu_synchronize_all_states(void)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc.c|1730| <<pc_machine_wakeup>> cpu_synchronize_all_post_reset();
+ *   - system/runstate.c|572| <<qemu_system_reset>> cpu_synchronize_all_post_reset();
+ */
 void cpu_synchronize_all_post_reset(void)
 {
     CPUState *cpu;
@@ -148,6 +164,13 @@ void cpu_synchronize_all_post_reset(void)
     }
 }
 
+/*
+ * called by:
+ *   - hw/core/machine.c|1624| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|2151| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3030| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3047| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+ */
 void cpu_synchronize_all_post_init(void)
 {
     CPUState *cpu;
@@ -166,6 +189,62 @@ void cpu_synchronize_all_pre_loadvm(void)
     }
 }
 
+/*
+ * called by:
+ *   - gdbstub/gdbstub.c|649| <<gdb_set_cpu_pc>> cpu_synchronize_state(cpu);
+ *   - gdbstub/gdbstub.c|1308| <<handle_write_all_regs>> cpu_synchronize_state(gdbserver_state.g_cpu);
+ *   - gdbstub/gdbstub.c|1327| <<handle_read_all_regs>> cpu_synchronize_state(gdbserver_state.g_cpu);
+ *   - gdbstub/gdbstub.c|1611| <<handle_query_thread_extra>> cpu_synchronize_state(cpu);
+ *   - hw/core/cpu-common.c|106| <<cpu_dump_state>> cpu_synchronize_state(cpu);
+ *   - hw/i386/kvm/apic.c|165| <<do_inject_external_nmi>> cpu_synchronize_state(cpu);
+ *   - hw/i386/kvm/clock.c|78| <<kvmclock_current_nsec>> cpu_synchronize_state(cpu);
+ *   - hw/i386/vapic.c|474| <<vapic_report_tpr_access>> cpu_synchronize_state(cs);
+ *   - hw/i386/vapic.c|650| <<vapic_write>> cpu_synchronize_state(current_cpu);
+ *   - hw/i386/vmport.c|107| <<vmport_ioport_read>> cpu_synchronize_state(cs);
+ *   - hw/ppc/pnv.c|2789| <<pnv_cpu_do_nmi_on_cpu>> cpu_synchronize_state(cs);
+ *   - hw/ppc/pnv_xscom.c|51| <<xscom_complete>> cpu_synchronize_state(cs);
+ *   - hw/ppc/ppce500_spin.c|98| <<spin_kick>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr.c|1403| <<do_lpcr_sync>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr.c|3547| <<spapr_do_system_reset_on_cpu>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr_hcall.c|137| <<do_push_sregs_to_kvm_pr>> cpu_synchronize_state(cs);
+ *   - hw/ppc/spapr_hcall.c|208| <<h_set_sprg0>> cpu_synchronize_state(CPU(cpu));
+ *   - hw/ppc/spapr_hcall.c|220| <<h_set_dabr>> cpu_synchronize_state(CPU(cpu));
+ *   - hw/ppc/spapr_hcall.c|246| <<h_set_xdabr>> cpu_synchronize_state(CPU(cpu));
+ *   - hw/ppc/spapr_rtas.c|161| <<rtas_start_cpu>> cpu_synchronize_state(CPU(newcpu));
+ *   - monitor/hmp-cmds-target.c|71| <<mon_get_cpu_sync>> cpu_synchronize_state(cpu);
+ *   - system/cpus.c|138| <<cpu_synchronize_all_states>> cpu_synchronize_state(cpu);
+ *   - system/physmem.c|3545| <<cpu_memory_rw_debug>> cpu_synchronize_state(cpu);
+ *   - target/arm/cpu.c|1131| <<arm_cpu_virtio_is_big_endian>> cpu_synchronize_state(cs);
+ *   - target/arm/hvf/hvf.c|1367| <<hvf_sysreg_read>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1670| <<hvf_sysreg_write>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1866| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1878| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1888| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1969| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1982| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|1997| <<hvf_vcpu_exec>> cpu_synchronize_state(cpu);
+ *   - target/arm/hvf/hvf.c|2233| <<hvf_arch_update_guest_debug>> cpu_synchronize_state(cpu);
+ *   - target/i386/cpu-apic.c|100| <<hmp_info_local_apic>> cpu_synchronize_state(cs);
+ *   - target/i386/helper.c|392| <<do_inject_x86_mce>> cpu_synchronize_state(cs);
+ *   - target/i386/hvf/x86hvf.c|436| <<hvf_process_events>> cpu_synchronize_state(cs);
+ *   - target/i386/hvf/x86hvf.c|450| <<hvf_process_events>> cpu_synchronize_state(cs);
+ *   - target/i386/hvf/x86hvf.c|455| <<hvf_process_events>> cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|898| <<kvm_mce_inject>> cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6609| <<kvm_handle_debug>> cpu_synchronize_state(cs);
+ *   - target/ppc/compat.c|181| <<ppc_set_compat>> cpu_synchronize_state(CPU(cpu));
+ *   - target/ppc/cpu_init.c|7348| <<ppc_cpu_is_big_endian>> cpu_synchronize_state(cs);
+ *   - target/ppc/kvm.c|1643| <<kvm_handle_debug>> cpu_synchronize_state(cs);
+ *   - target/ppc/kvm.c|2878| <<kvm_handle_nmi>> cpu_synchronize_state(CPU(cpu));
+ *   - target/ppc/mmu-hash64.c|91| <<dump_slb>> cpu_synchronize_state(CPU(cpu));
+ *   - target/s390x/cpu-sysemu.c|79| <<s390_cpu_get_crash_info>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|147| <<sigp_stop_and_store_status>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|166| <<sigp_store_status_at_address>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|219| <<sigp_store_adtl_status>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|236| <<sigp_restart>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|258| <<sigp_initial_cpu_reset>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|270| <<sigp_cpu_reset>> cpu_synchronize_state(cs);
+ *   - target/s390x/sigp.c|282| <<sigp_set_prefix>> cpu_synchronize_state(cs);
+ */
 void cpu_synchronize_state(CPUState *cpu)
 {
     if (cpus_accel->synchronize_state) {
@@ -173,6 +252,12 @@ void cpu_synchronize_state(CPUState *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - system/cpus.c|158| <<cpu_synchronize_all_post_reset>> cpu_synchronize_post_reset(cpu);
+ *   - target/s390x/sigp.c|260| <<sigp_initial_cpu_reset>> cpu_synchronize_post_reset(cs);
+ *   - target/s390x/sigp.c|272| <<sigp_cpu_reset>> cpu_synchronize_post_reset(cs);
+ */
 void cpu_synchronize_post_reset(CPUState *cpu)
 {
     if (cpus_accel->synchronize_post_reset) {
@@ -180,8 +265,34 @@ void cpu_synchronize_post_reset(CPUState *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - hw/core/cpu-common.c|214| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+ *   - system/cpus.c|167| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+ *   - target/s390x/gdbstub.c|92| <<cpu_write_ac_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|210| <<cpu_write_c_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|250| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|254| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|258| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|262| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|302| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|306| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|310| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|314| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|342| <<cpu_write_gs_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/sigp.c|299| <<sigp_set_prefix>> cpu_synchronize_post_init(cs);
+ */
 void cpu_synchronize_post_init(CPUState *cpu)
 {
+    /*
+     * 在以下使用AccelOpsClass->synchronize_post_init:
+     *   - accel/hvf/hvf-accel-ops.c|582| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|107| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|185| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|186| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|91| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|94| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     if (cpus_accel->synchronize_post_init) {
         cpus_accel->synchronize_post_init(cpu);
     }
@@ -286,6 +397,11 @@ bool vm_get_suspended(void)
     return vm_was_suspended;
 }
 
+/*
+ * called by:
+ *   - system/cpus.c|430| <<vm_shutdown>> return do_vm_stop(RUN_STATE_SHUTDOWN, false);
+ *   - system/cpus.c|890| <<vm_stop>> return do_vm_stop(state, true);
+ */
 static int do_vm_stop(RunState state, bool send_stop)
 {
     int ret = 0;
@@ -459,6 +575,25 @@ void qemu_wait_io_event(CPUState *cpu)
             slept = true;
             qemu_plugin_vcpu_idle_cb(cpu);
         }
+        /*
+	 * 在以下使用CPUState:
+	 *   - accel/tcg/tcg-accel-ops-rr.c|114| <<rr_wait_io_event>> qemu_cond_wait_bql(first_cpu->halt_cond);
+	 *   - accel/tcg/tcg-accel-ops-rr.c|201| <<rr_cpu_thread_fn>> qemu_cond_wait_bql(first_cpu->halt_cond);
+	 *   - accel/tcg/tcg-accel-ops-rr.c|320| <<rr_start_vcpu_thread>> single_tcg_halt_cond = cpu->halt_cond;
+	 *   - accel/tcg/tcg-accel-ops-rr.c|331| <<rr_start_vcpu_thread>> qemu_cond_destroy(cpu->halt_cond);
+	 *   - accel/tcg/tcg-accel-ops-rr.c|332| <<rr_start_vcpu_thread>> g_free(cpu->halt_cond);
+	 *   - accel/tcg/tcg-accel-ops-rr.c|334| <<rr_start_vcpu_thread>> cpu->halt_cond = single_tcg_halt_cond;
+	 *   - hw/core/cpu-common.c|251| <<cpu_common_initfn>> cpu->halt_cond = g_new0(QemuCond, 1);
+	 *   - hw/core/cpu-common.c|252| <<cpu_common_initfn>> qemu_cond_init(cpu->halt_cond);
+	 *   - hw/core/cpu-common.c|291| <<cpu_common_finalize>> qemu_cond_destroy(cpu->halt_cond);
+	 *   - hw/core/cpu-common.c|292| <<cpu_common_finalize>> g_free(cpu->halt_cond);
+	 *   - system/cpu-throttle.c|57| <<cpu_throttle_thread>> qemu_cond_timedwait_bql(cpu->halt_cond,
+	 *   - system/cpus.c|573| <<qemu_wait_io_event>> qemu_cond_wait(cpu->halt_cond, &bql);
+	 *   - system/cpus.c|631| <<qemu_cpu_kick>> qemu_cond_broadcast(cpu->halt_cond);
+	 *   - system/physmem.c|2634| <<tcg_commit>> if (cpu->halt_cond) {
+	 *   - target/i386/nvmm/nvmm-accel-ops.c|51| <<qemu_nvmm_cpu_thread_fn>> qemu_cond_wait_bql(cpu->halt_cond);
+	 *   - target/i386/whpx/whpx-accel-ops.c|51| <<whpx_cpu_thread_fn>> qemu_cond_wait_bql(cpu->halt_cond);
+	 */
         qemu_cond_wait(cpu->halt_cond, &bql);
     }
     if (slept) {
@@ -486,8 +621,56 @@ void cpus_kick_thread(CPUState *cpu)
 #endif
 }
 
+/*
+ * called by:
+ *   - accel/accel-blocker.c|92| <<accel_has_to_wait>> qemu_cpu_kick(cpu);
+ *   - accel/tcg/icount-common.c|499| <<icount_notify_exit>> qemu_cpu_kick(current_cpu);
+ *   - accel/tcg/tcg-accel-ops.c|102| <<tcg_handle_interrupt>> qemu_cpu_kick(cpu);
+ *   - cpu-common.c|141| <<queue_work_on_cpu>> qemu_cpu_kick(cpu);
+ *   - cpu-common.c|215| <<start_exclusive>> qemu_cpu_kick(other_cpu);
+ *   - gdbstub/system.c|118| <<gdb_syscall_handling>> qemu_cpu_kick(gdbserver_state.c_cpu);
+ *   - hw/openrisc/cputimer.c|123| <<openrisc_timer_cb>> qemu_cpu_kick(CPU(cpu));
+ *   - hw/ppc/ppc.c|195| <<ppc970_set_irq>> qemu_cpu_kick(cs);
+ *   - hw/ppc/ppc.c|392| <<ppc40x_set_irq>> qemu_cpu_kick(cs);
+ *   - hw/ppc/ppce500_spin.c|115| <<spin_kick>> qemu_cpu_kick(cs);
+ *   - hw/ppc/spapr_hcall.c|646| <<h_prod>> qemu_cpu_kick(cs);
+ *   - hw/ppc/spapr_rtas.c|198| <<rtas_start_cpu>> qemu_cpu_kick(CPU(newcpu));
+ *   - hw/ppc/spapr_rtas.c|221| <<rtas_stop_self>> qemu_cpu_kick(cs);
+ *   - hw/sparc/sun4m.c|179| <<cpu_kick_irq>> qemu_cpu_kick(cs);
+ *   - hw/sparc64/sparc64.c|45| <<cpu_kick_irq>> qemu_cpu_kick(cs);
+ *   - replay/replay-events.c|130| <<replay_add_event>> qemu_cpu_kick(first_cpu);
+ *   - semihosting/console.c|55| <<console_wake_up>> qemu_cpu_kick(cs);
+ *   - system/cpu-timers.c|253| <<qemu_timer_notify_cb>> qemu_cpu_kick(current_cpu);
+ *   - system/cpus.c|261| <<generic_handle_interrupt>> qemu_cpu_kick(cpu);
+ *   - system/cpus.c|577| <<cpu_pause>> qemu_cpu_kick(cpu);
+ *   - system/cpus.c|585| <<cpu_resume>> qemu_cpu_kick(cpu);
+ *   - system/cpus.c|618| <<pause_all_vcpus>> qemu_cpu_kick(cpu);
+ *   - system/cpus.c|645| <<cpu_remove_sync>> qemu_cpu_kick(cpu);
+ *   - target/arm/tcg/mte_helper.c|588| <<mte_async_check_fail>> qemu_cpu_kick(env_cpu(env));
+ *   - target/i386/kvm/xen-emu.c|462| <<kvm_xen_inject_vcpu_callback_vector>> qemu_cpu_kick(cs);
+ *   - target/xtensa/helper.c|317| <<xtensa_runstall>> qemu_cpu_kick(cpu);
+ */
 void qemu_cpu_kick(CPUState *cpu)
 {
+    /*
+     * 在以下使用CPUState->halt_cond:
+     *   - accel/tcg/tcg-accel-ops-rr.c|114| <<rr_wait_io_event>> qemu_cond_wait_bql(first_cpu->halt_cond);
+     *   - accel/tcg/tcg-accel-ops-rr.c|201| <<rr_cpu_thread_fn>> qemu_cond_wait_bql(first_cpu->halt_cond);
+     *   - accel/tcg/tcg-accel-ops-rr.c|320| <<rr_start_vcpu_thread>> single_tcg_halt_cond = cpu->halt_cond;
+     *   - accel/tcg/tcg-accel-ops-rr.c|331| <<rr_start_vcpu_thread>> qemu_cond_destroy(cpu->halt_cond);
+     *   - accel/tcg/tcg-accel-ops-rr.c|332| <<rr_start_vcpu_thread>> g_free(cpu->halt_cond);
+     *   - accel/tcg/tcg-accel-ops-rr.c|334| <<rr_start_vcpu_thread>> cpu->halt_cond = single_tcg_halt_cond;
+     *   - hw/core/cpu-common.c|251| <<cpu_common_initfn>> cpu->halt_cond = g_new0(QemuCond, 1);
+     *   - hw/core/cpu-common.c|252| <<cpu_common_initfn>> qemu_cond_init(cpu->halt_cond);
+     *   - hw/core/cpu-common.c|291| <<cpu_common_finalize>> qemu_cond_destroy(cpu->halt_cond);
+     *   - hw/core/cpu-common.c|292| <<cpu_common_finalize>> g_free(cpu->halt_cond);
+     *   - system/cpu-throttle.c|57| <<cpu_throttle_thread>> qemu_cond_timedwait_bql(cpu->halt_cond,
+     *   - system/cpus.c|573| <<qemu_wait_io_event>> qemu_cond_wait(cpu->halt_cond, &bql);
+     *   - system/cpus.c|631| <<qemu_cpu_kick>> qemu_cond_broadcast(cpu->halt_cond);
+     *   - system/physmem.c|2634| <<tcg_commit>> if (cpu->halt_cond) {
+     *   - target/i386/nvmm/nvmm-accel-ops.c|51| <<qemu_nvmm_cpu_thread_fn>> qemu_cond_wait_bql(cpu->halt_cond);
+     *   - target/i386/whpx/whpx-accel-ops.c|51| <<whpx_cpu_thread_fn>> qemu_cond_wait_bql(cpu->halt_cond);
+     */
     qemu_cond_broadcast(cpu->halt_cond);
     if (cpus_accel->kick_vcpu_thread) {
         cpus_accel->kick_vcpu_thread(cpu);
diff --git a/system/globals.c b/system/globals.c
index d602a04fa..9a052a307 100644
--- a/system/globals.c
+++ b/system/globals.c
@@ -34,6 +34,13 @@
 enum vga_retrace_method vga_retrace_method = VGA_RETRACE_DUMB;
 int display_opengl;
 const char* keyboard_layout;
+/*
+ * 在以下使用enable_mlock:
+ *   - hw/virtio/virtio-mem.c|993| <<virtio_mem_device_realize>> if (enable_mlock) {
+ *   - migration/postcopy-ram.c|654| <<postcopy_ram_incoming_cleanup>> if (enable_mlock) {
+ *   - system/vl.c|795| <<realtime_init>> if (enable_mlock) {
+ *   - system/vl.c|3556| <<qemu_init>> enable_mlock = qemu_opt_get_bool(opts, "mem-lock", enable_mlock);
+ */
 bool enable_mlock;
 bool enable_cpu_pm;
 int autostart = 1;
diff --git a/system/memory.c b/system/memory.c
index 5e6eb459d..3eebc8572 100644
--- a/system/memory.c
+++ b/system/memory.c
@@ -2239,10 +2239,56 @@ void memory_region_set_log(MemoryRegion *mr, bool log, unsigned client)
     memory_region_transaction_commit();
 }
 
+/*
+ * 很多调用, 一些例子:
+ *   - hw/arm/virt-acpi-build.c|1041| <<acpi_ram_update>> memory_region_set_dirty(mr, 0, size);
+ *   - hw/display/artist.c|234| <<artist_invalidate_lines>> memory_region_set_dirty(&buf->mr, start, size);
+ *   - hw/display/cirrus_vga.c|2086| <<cirrus_vga_mem_write>> memory_region_set_dirty(&s->vga.vram, bank_offset,
+ *   - hw/display/cirrus_vga.c|2379| <<cirrus_linear_write>> memory_region_set_dirty(&s->vga.vram, addr, 1);
+ *   - hw/display/vga.c|951| <<vga_mem_writeb>> memory_region_set_dirty(&s->vram, addr, 1);
+ *   - hw/display/vga.c|1027| <<vga_mem_writeb>> memory_region_set_dirty(&s->vram, addr << 2, sizeof(uint32_t));
+ *   - hw/hyperv/hyperv.c|290| <<cpu_post_msg>> memory_region_set_dirty(&synic->msg_page_mr, 0, sizeof(*synic->msg_page));
+ *   - hw/hyperv/hyperv.c|367| <<hyperv_set_event_flag>> memory_region_set_dirty(&synic->event_page_mr, 0,
+ *   - hw/i386/acpi-build.c|2697| <<acpi_ram_update>> memory_region_set_dirty(mr, 0, size);
+ *   - hw/i386/kvm/xen_gnttab.c|257| <<gnt_unref>> memory_region_set_dirty(mrs->mr, mrs->offset_within_region,
+ *   - hw/i386/xen/xen-hvm.c|409| <<xen_sync_dirty_bitmap>> memory_region_set_dirty(framebuffer, 0, size);
+ *   - hw/i386/xen/xen-hvm.c|422| <<xen_sync_dirty_bitmap>> memory_region_set_dirty(framebuffer,
+ *   - hw/loongarch/acpi-build.c|566| <<acpi_ram_update>> memory_region_set_dirty(mr, 0, size);
+ *   - hw/mem/cxl_type3.c|1288| <<set_lsa>> memory_region_set_dirty(mr, offset, size);
+ *   - hw/mem/nvdimm.c|246| <<nvdimm_write_label_data>> memory_region_set_dirty(mr, backend_offset, size);
+ *   - hw/riscv/virt-acpi-build.c|743| <<acpi_ram_update>> memory_region_set_dirty(mr, 0, size);
+ *   - hw/tpm/tpm_crb.c|201| <<tpm_crb_request_completed>> memory_region_set_dirty(&s->cmdmem, 0, CRB_CTRL_CMD_SIZE);
+ *   - hw/tpm/tpm_ppi.c|40| <<tpm_ppi_reset>> memory_region_set_dirty(block->mr, mr_offs,
+ *   - hw/virtio/vhost.c|276| <<vhost_dev_sync_region>> memory_region_set_dirty(section->mr, mr_offset, VHOST_LOG_PAGE);
+ *   - target/i386/hvf/hvf.c|139| <<ept_emulation_fault>> memory_region_set_dirty(slot->region, gpa - slot->start, 1);
+ *   - target/i386/kvm/xen-emu.c|1906| <<kvm_get_xen_state>> memory_region_set_dirty(mrs.mr, mrs.offset_within_region,
+ *   - target/i386/nvmm/nvmm-all.c|1119| <<nvmm_log_sync>> memory_region_set_dirty(mr, 0, int128_get64(section->size));
+ *   - target/i386/whpx/whpx-all.c|2399| <<whpx_log_sync>> memory_region_set_dirty(mr, 0, int128_get64(section->size));
+ *
+ * 注释:
+ * memory_region_set_dirty: Mark a range of bytes as dirty in a memory region.
+ *
+ * Marks a range of bytes as dirty, after it has been dirtied outside
+ * guest code.
+ *
+ * @mr: the memory region being dirtied.
+ * @addr: the address (relative to the start of the region) being dirtied.
+ * @size: size of the range being dirtied.
+ */
 void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
                              hwaddr size)
 {
     assert(mr->ram_block);
+    /*
+     * called by:
+     *   - accel/tcg/cputlb.c|1329| <<notdirty_write>> cpu_physical_memory_set_dirty_range(ram_addr, size, DIRTY_CLIENTS_NOCODE);
+     *   - hw/vfio/common.c|1166| <<vfio_get_dirty_bitmap>> cpu_physical_memory_set_dirty_range(ram_addr, size, tcg_enabled() ? DIRTY_CLIENTS_ALL : DIRTY_CLIENTS_NOCODE);
+     *   - include/exec/ram_addr.h|437| <<cpu_physical_memory_set_dirty_lebitmap>> cpu_physical_memory_set_dirty_range(ram_addr, TARGET_PAGE_SIZE * hpratio, clients);
+     *   - system/memory.c|2282| <<memory_region_set_dirty>> cpu_physical_memory_set_dirty_range(memory_region_get_ram_addr(mr) + addr, size, memory_region_get_dirty_log_mask(mr));
+     *   - system/physmem.c|1758| <<qemu_ram_resize>> cpu_physical_memory_set_dirty_range(block->offset, block->used_length, DIRTY_CLIENTS_ALL);
+     *   - system/physmem.c|1933| <<ram_block_add>> cpu_physical_memory_set_dirty_range(new_block->offset, new_block->used_length, DIRTY_CLIENTS_ALL);
+     *   - system/physmem.c|2687| <<invalidate_and_set_dirty>> cpu_physical_memory_set_dirty_range(addr, length, dirty_log_mask);
+     */
     cpu_physical_memory_set_dirty_range(memory_region_get_ram_addr(mr) + addr,
                                         size,
                                         memory_region_get_dirty_log_mask(mr));
diff --git a/system/runstate.c b/system/runstate.c
index a0e2a5fd2..62a4751d9 100644
--- a/system/runstate.c
+++ b/system/runstate.c
@@ -225,6 +225,41 @@ static void runstate_init(void)
     qemu_mutex_init(&vmstop_lock);
 }
 
+/*
+ * (gdb) bt
+ * #0  runstate_set (new_state=RUN_STATE_RUNNING) at ../system/runstate.c:231
+ * #1  0x0000555555bd1bd7 in vm_prepare_start (step_pending=false) at ../system/cpus.c:754
+ * #2  0x0000555555bd1c1d in vm_start () at ../system/cpus.c:762
+ * #3  0x0000555555c13324 in process_incoming_migration_bh (opaque=0x555557691cc0) at ../migration/migration.c:757
+ * #4  0x0000555555c120bb in migration_bh_dispatch_bh (opaque=0x5555576736c0) at ../migration/migration.c:284
+ * #5  0x0000555556186520 in aio_bh_call (bh=0x5555583ab510) at ../util/async.c:171
+ * #6  0x000055555618666e in aio_bh_poll (ctx=0x5555573fd590) at ../util/async.c:218
+ * #7  0x0000555556165595 in aio_dispatch (ctx=0x5555573fd590) at ../util/aio-posix.c:423
+ * #8  0x0000555556186b3d in aio_ctx_dispatch (source=0x5555573fd590, callback=0x0, user_data=0x0) at ../util/async.c:360
+ * #9  0x00007ffff6fd494b in g_main_dispatch (context=0x5555573fdab0) at ../glib/gmain.c:3325
+ * #10 g_main_context_dispatch (context=0x5555573fdab0) at ../glib/gmain.c:4043
+ * #11 0x0000555556188215 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #12 0x00005555561882a3 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #13 0x00005555561883d2 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #14 0x0000555555be0f17 in qemu_main_loop () at ../system/runstate.c:826
+ * #15 0x0000555556093994 in qemu_default_main () at ../system/main.c:37
+ * #16 0x00005555560939d1 in main (argc=18, argv=0x7fffffffdc68) at ../system/main.c:48
+ *
+ * called by:
+ *   - migration/migration.c|759| <<process_incoming_migration_bh>> runstate_set(RUN_STATE_PAUSED);
+ *   - migration/migration.c|765| <<process_incoming_migration_bh>> runstate_set(global_state_get_runstate());
+ *   - migration/migration.c|3292| <<migration_iteration_finish>> runstate_set(RUN_STATE_POSTMIGRATE);
+ *   - migration/migration.c|3308| <<migration_iteration_finish>> runstate_set(s->vm_old_state);
+ *   - migration/savevm.c|2177| <<loadvm_postcopy_handle_run_bh>> runstate_set(RUN_STATE_PAUSED);
+ *   - system/cpus.c|296| <<do_vm_stop>> runstate_set(state);
+ *   - system/cpus.c|754| <<vm_prepare_start>> runstate_set(state);
+ *   - system/cpus.c|772| <<vm_resume>> runstate_set(state);
+ *   - system/cpus.c|784| <<vm_stop_force_state>> runstate_set(state);
+ *   - system/runstate.c|637| <<qemu_system_suspend>> runstate_set(RUN_STATE_SUSPENDED);
+ *   - system/runstate.c|668| <<qemu_system_wakeup_request>> runstate_set(RUN_STATE_RUNNING);
+ *   - system/runstate.c|801| <<main_loop_should_exit>> runstate_set(RUN_STATE_PRELAUNCH);
+ *   - system/vl.c|3464| <<qemu_init>> runstate_set(RUN_STATE_INMIGRATE);
+ */
 /* This function will abort() on invalid state transitions */
 void runstate_set(RunState new_state)
 {
diff --git a/target/arm/cpu.c b/target/arm/cpu.c
index 19191c239..1709ffdf4 100644
--- a/target/arm/cpu.c
+++ b/target/arm/cpu.c
@@ -1467,6 +1467,12 @@ static void arm_cpu_dump_state(CPUState *cs, FILE *f, int flags)
     }
 }
 
+/*
+ * called by:
+ *   -  hw/arm/sbsa-ref.c|162| <<sbsa_ref_cpu_mp_affinity>> return arm_build_mp_affinity(idx, clustersz);
+ *   - hw/arm/virt.c|1774| <<virt_cpu_mp_affinity>> return arm_build_mp_affinity(idx, clustersz);
+ *   - target/arm/cpu.c|2311| <<arm_cpu_realizefn>> cpu->mp_affinity = arm_build_mp_affinity(cs->cpu_index, ARM_DEFAULT_CPUS_PER_CLUSTER);
+ */
 uint64_t arm_build_mp_affinity(int idx, uint8_t clustersz)
 {
     uint32_t Aff1 = idx / clustersz;
@@ -1770,6 +1776,9 @@ void arm_cpu_post_init(Object *obj)
 
     if (arm_feature(&cpu->env, ARM_FEATURE_PMU)) {
         cpu->has_pmu = true;
+        /*
+	 * 设置"-cpu host,pmu=false"可以成功disable pmu
+	 */
         object_property_add_bool(obj, "pmu", arm_get_pmu, arm_set_pmu);
     }
 
diff --git a/target/arm/cpu.h b/target/arm/cpu.h
index 9a3fd5956..8de764d39 100644
--- a/target/arm/cpu.h
+++ b/target/arm/cpu.h
@@ -945,6 +945,17 @@ struct ArchCPU {
     uint32_t kvm_target;
 
 #ifdef CONFIG_KVM
+    /*
+     * 在以下使用ARMCPU(ArchCPU)->kvm_init_features[7]:
+     *   - target/arm/kvm.c|79| <<kvm_arm_vcpu_init>> memcpy(init.features, cpu->kvm_init_features, sizeof(init.features));
+     *   - target/arm/kvm.c|1880| <<kvm_arch_init_vcpu>> memset(cpu->kvm_init_features, 0, sizeof(cpu->kvm_init_features));
+     *   - target/arm/kvm.c|1882| <<kvm_arch_init_vcpu>> cpu->kvm_init_features[0] |= 1 << KVM_ARM_VCPU_POWER_OFF;
+     *   - target/arm/kvm.c|1886| <<kvm_arch_init_vcpu>> cpu->kvm_init_features[0] |= 1 << KVM_ARM_VCPU_PSCI_0_2;
+     *   - target/arm/kvm.c|1889| <<kvm_arch_init_vcpu>> cpu->kvm_init_features[0] |= 1 << KVM_ARM_VCPU_EL1_32BIT;
+     *   - target/arm/kvm.c|1892| <<kvm_arch_init_vcpu>> cpu->kvm_init_features[0] |= 1 << KVM_ARM_VCPU_PMU_V3;
+     *   - target/arm/kvm.c|1896| <<kvm_arch_init_vcpu>> cpu->kvm_init_features[0] |= 1 << KVM_ARM_VCPU_SVE;
+     *   - target/arm/kvm.c|1899| <<kvm_arch_init_vcpu>> cpu->kvm_init_features[0] |= (1 << KVM_ARM_VCPU_PTRAUTH_ADDRESS |
+     */
     /* KVM init features for this CPU */
     uint32_t kvm_init_features[7];
 
@@ -1043,6 +1054,16 @@ struct ArchCPU {
     uint64_t id_aa64afr0;
     uint64_t id_aa64afr1;
     uint64_t clidr;
+    /*
+     * 在以下使用ARMCPU->mp_affinity:
+     *   - target/arm/cpu.c|2626| <<global>> DEFINE_PROP_UINT64("mp-affinity", ARMCPU, mp_affinity, ARM64_AFFINITY_INVALID),
+     *   - target/arm/cpu.c|1479| <<arm_cpu_mp_affinity>> return cpu->mp_affinity;
+     *   - target/arm/cpu.c|2310| <<arm_cpu_realizefn>> if (cpu->mp_affinity == ARM64_AFFINITY_INVALID) {
+     *   - target/arm/cpu.c|2311| <<arm_cpu_realizefn>> cpu->mp_affinity = arm_build_mp_affinity(cs->cpu_index, ARM_DEFAULT_CPUS_PER_CLUSTER);
+     *   - target/arm/helper.c|4677| <<mpidr_read_val>> uint64_t mpidr = cpu->mp_affinity;
+     *   - target/arm/hvf/hvf.c|984| <<hvf_arch_init_vcpu>> ret = hv_vcpu_set_sys_reg(cpu->accel->fd, HV_SYS_REG_MPIDR_EL1, arm_cpu->mp_affinity);
+     *   - target/arm/kvm.c|1940| <<kvm_arch_init_vcpu>> cpu->mp_affinity = mpidr & ARM64_AFFINITY_MASK;
+     */
     uint64_t mp_affinity; /* MP ID without feature bits */
     /* The elements of this array are the CCSIDR values for each cache,
      * in the order L1DCache, L1ICache, L2DCache, L2ICache, etc.
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 85ef7452c..96e552fc6 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -46,6 +46,12 @@
 #include "disas/capstone.h"
 #include "cpu-internal.h"
 
+/*
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
+
 static void x86_cpu_realizefn(DeviceState *dev, Error **errp);
 
 /* Helpers for building CPUID[2] descriptors: */
@@ -912,6 +918,485 @@ void x86_cpu_vendor_words2str(char *dst, uint32_t vendor1,
 #define TCG_8000_0008_EBX  (CPUID_8000_0008_EBX_XSAVEERPTR | \
           CPUID_8000_0008_EBX_WBNOINVD | CPUID_8000_0008_EBX_KERNEL_FEATURES)
 
+/*
+ *
+ * KVM cpuid init/process.
+ *
+ * KVM在定义cpuid的时候分为下面核心的步骤.
+ *
+ * 1. KVM会通过KVM_GET_SUPPORTED_CPUID这个ioctl让QEMU知道那些cpuid的feature是支持的 (会有不支持的).
+ *
+ * 2. QEMU会把KVM_GET_SUPPORTED_CPUID的结果和"-cpu xxx,+feature0,-feature1,feature=on"的结果and一下.
+ *
+ * 3. 最终的结果会通过KVM_SET_CPUID2配置到KVM.
+ *
+ * ----------------------------------
+ *
+ * 在KVM side, 最初的时候, 通过vmx_set_cpu_caps()或者svm_set_cpu_caps()设置一些caps,
+ * 比方是否支持X86_FEATURE_SVM.
+ *
+ * 这样在__do_cpuid_func()中, 如果X86_FEATURE_SVM不被支持(没有nested),对应的KVM_GET_SUPPORTED_CPUID cpuid就返回0.
+ *
+ *  789 static inline int __do_cpuid_func(struct kvm_cpuid_array *array, u32 function)
+ *  790 {
+ * 1134         case 0x8000000A:
+ * 1135                 if (!kvm_cpu_cap_has(X86_FEATURE_SVM)) {
+ * 1136                         entry->eax = entry->ebx = entry->ecx = entry->edx = 0;
+ * 1137                         break;
+ * 1138                 }
+ * 1139                 entry->eax = 1; // SVM revision 1
+ * 1140                 entry->ebx = 8; // Lets support 8 ASIDs in case we add proper
+ * 1141                                    ASID emulation to nested SVM
+ * 1142                 entry->ecx = 0; // Reserved
+ * 1143                 cpuid_entry_override(entry, CPUID_8000_000A_EDX);
+ * 1144                 break;
+ *
+ *
+ * 这样为了返回KVM_GET_SUPPORTED_CPUID而调用__do_cpuid_func()的时候,KVM先调用host硬件的cpuid, 然后根据caps过滤.
+ *
+ * 814 static inline int __do_cpuid_func(struct kvm_cpuid_array *array, u32 function)
+ * 815 {
+ * 816         struct kvm_cpuid_entry2 *entry;
+ * 817         int r, i, max_idx;
+ * 818
+ * 819         // all calls to cpuid_count() should be made on the same cpu
+ * 820         get_cpu();
+ * 821
+ * 822         r = -E2BIG;
+ * 823
+ * 824         entry = do_host_cpuid(array, function, 0);
+ * 825         if (!entry)
+ * 826                 goto out;
+ * 827
+ * 828         switch (function) {
+ * 829         case 0:
+ * 830                 // Limited to the highest leaf implemented in KVM.
+ * 831                 entry->eax = min(entry->eax, 0x1fU);
+ * 832                 break;
+ * 833         case 1:
+ * 834                 cpuid_entry_override(entry, CPUID_1_EDX);
+ * 835                 cpuid_entry_override(entry, CPUID_1_ECX);
+ * 836                 break;
+ * 837         case 2:
+ *
+ * ----------------------------------
+ *
+ * cap配置好了, KVM_GET_SUPPORTED_CPUID就能返回KVM支持哪些cpuid的feature了.
+ *
+ * 通过get_supported_cpuid()-->try_get_cpuid()-->KVM_GET_SUPPORTED_CPUID来获取KVM支持的feature/cpuid.
+ *
+ * 为了减少和KVM的沟通, 结果可以缓存在cpuid_cache.
+ *
+ * 321 static struct kvm_cpuid2 *get_supported_cpuid(KVMState *s)
+ * 322 {
+ * 323     struct kvm_cpuid2 *cpuid;
+ * 324     int max = 1;
+ * 325
+ * 326     if (cpuid_cache != NULL) {
+ * 327         return cpuid_cache;
+ * 328     }
+ * 329     while ((cpuid = try_get_cpuid(s, max)) == NULL) {
+ * 330         max *= 2;
+ * 331     }
+ * 332     cpuid_cache = cpuid;
+ * 333     return cpuid;
+ * 334 }
+ *
+ * (gdb) bt
+ * #0  try_get_cpuid (s=0x55555680c600, max=64) at ../target/i386/kvm/kvm.c:257
+ * #1  0x0000555555b144dc in get_supported_cpuid (s=0x55555680c600) at ../target/i386/kvm/kvm.c:288
+ * #2  0x0000555555b146d2 in kvm_arch_get_supported_cpuid (s=0x55555680c600, function=0, index=0, reg=0) at ../target/i386/kvm/kvm.c:356
+ * #3  0x0000555555b219d1 in kvm_cpu_max_instance_init (cpu=0x555556a5f390) at ../target/i386/kvm/kvm-cpu.c:77
+ * #4  0x0000555555b21cb6 in kvm_cpu_instance_init (cs=0x555556a5f390) at ../target/i386/kvm/kvm-cpu.c:183
+ * #5  0x0000555555ce9da1 in accel_cpu_instance_init (cpu=0x555556a5f390) at ../accel/accel-common.c:110
+ * #6  0x0000555555b6dd3b in x86_cpu_post_initfn (obj=0x555556a5f390) at ../target/i386/cpu.c:6686
+ * #7  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567e1470) at ../qom/object.c:384
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567f4600) at ../qom/object.c:388
+ * #9  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f390, ti=0x5555567f4960) at ../qom/object.c:388
+ * #10 0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f390, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #11 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #12 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #13 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #14 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #15 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #16 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #17 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #18 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #19 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #20 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #21 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * ----------------------------------
+ * 
+ * QEMU初始化的时候, x86_cpu_common_class_init()-->x86_cpu_register_feature_bit_props()会为每一个cpu的feature (e.g., -x2apic,+x2apic,x2apic=on)注册.
+ *
+ * 7018 static void x86_cpu_common_class_init(ObjectClass *oc, void *data)
+ * 7019 {
+ * ... ...
+ * 7092     for (w = 0; w < FEATURE_WORDS; w++) {
+ * 7093         int bitnr;
+ * 7094         for (bitnr = 0; bitnr < 64; bitnr++) {
+ * 7095             x86_cpu_register_feature_bit_props(xcc, w, bitnr);
+ * 7096         }
+ * 7097     }
+ * 7098 }
+ *
+ * FEATURE_WORDS包括比如FEAT_1_ECX.
+ *
+ * 676 FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
+ * 677     [FEAT_1_EDX] = {
+ * 678         .type = CPUID_FEATURE_WORD,
+ * 679         .feat_names = {
+ * 680             "fpu", "vme", "de", "pse",
+ * 681             "tsc", "msr", "pae", "mce",
+ * 682             "cx8", "apic", NULL, "sep",
+ * 683             "mtrr", "pge", "mca", "cmov",
+ * 684             "pat", "pse36", "pn" / Intel psn /, "clflush" / Intel clfsh /,
+ * 685             NULL, "ds" / Intel dts /, "acpi", "mmx",
+ * 686             "fxsr", "sse", "sse2", "ss",
+ * 687             "ht" / Intel htt /, "tm", "ia64", "pbe",
+ * 688         },
+ * 689         .cpuid = {.eax = 1, .reg = R_EDX, },
+ * 690         .tcg_features = TCG_FEATURES,
+ * 691     },
+ * 692     [FEAT_1_ECX] = {
+ * 693         .type = CPUID_FEATURE_WORD,
+ * 694         .feat_names = {
+ * 695             "pni" / Intel,AMD sse3 /, "pclmulqdq", "dtes64", "monitor",
+ * 696             "ds-cpl", "vmx", "smx", "est",
+ * 697             "tm2", "ssse3", "cid", NULL,
+ * 698             "fma", "cx16", "xtpr", "pdcm",
+ * 699             NULL, "pcid", "dca", "sse4.1",
+ * 700             "sse4.2", "x2apic", "movbe", "popcnt",
+ * 701             "tsc-deadline", "aes", "xsave", NULL / osxsave /,
+ * 702             "avx", "f16c", "rdrand", "hypervisor",
+ * 703         },
+ * 704         .cpuid = { .eax = 1, .reg = R_ECX, },
+ * 705         .tcg_features = TCG_EXT_FEATURES,
+ * 706     },
+ *
+ * 最终这些property(e.g., x2apic, vmx)的setter是x86_cpu_set_bit_prop(),
+ * 就是修改cpu->env.features[fp->w].
+ *
+ * 6605 static void x86_cpu_set_bit_prop(Object *obj, Visitor *v, const char *name,
+ * 6606                                  void *opaque, Error **errp)
+ * 6607 {
+ * 6608     DeviceState *dev = DEVICE(obj);
+ * 6609     X86CPU *cpu = X86_CPU(obj);
+ * 6610     BitProperty *fp = opaque;
+ * 6611     bool value;
+ * 6612
+ * 6613     if (dev->realized) {
+ * 6614         qdev_prop_set_after_realize(dev, name, errp);
+ * 6615         return;
+ * 6616     }
+ * 6617
+ * 6618     if (!visit_type_bool(v, name, &value, errp)) {
+ * 6619         return;
+ * 6620     }
+ * 6621
+ * 6622     if (value) {
+ * 6623         cpu->env.features[fp->w] |= fp->mask;
+ * 6624     } else {
+ * 6625         cpu->env.features[fp->w] &= ~fp->mask;
+ * 6626     }
+ * 6627     cpu->env.user_features[fp->w] |= fp->mask;
+ * 6628 }
+ *
+ * (gdb) bt
+ * #0  x86_cpu_register_bit_prop (xcc=0x555556812140, prop_name=0x55555607a689 "x2apic", w=FEAT_1_ECX, bitnr=21) at ../target/i386/cpu.c:6641
+ * #1  0x0000555555b6dd1e in x86_cpu_register_feature_bit_props (xcc=0x555556812140, w=FEAT_1_ECX, bitnr=21) at ../target/i386/cpu.c:6681
+ * #2  0x0000555555b6e9ec in x86_cpu_common_class_init (oc=0x555556812140, data=0x0) at ../target/i386/cpu.c:7095
+ * #3  0x0000555555d28b97 in type_initialize (ti=0x5555567e1470) at ../qom/object.c:366
+ * #4  0x0000555555d28902 in type_initialize (ti=0x5555567ea7e0) at ../qom/object.c:314
+ * #5  0x0000555555d2a0fa in object_class_foreach_tramp (key=0x5555567ea960, value=0x5555567ea7e0, opaque=0x7fffffffdb90) at ../qom/object.c:1071
+ * #6  0x00007ffff6e46710 in g_hash_table_foreach () at /lib64/libglib-2.0.so.0
+ * #7  0x0000555555d2a1d9 in object_class_foreach (fn=0x555555d2a336 <object_class_get_list_tramp>, implements_type=0x555555faee84 "machine", include_abstract=false, opaque=0x7fffffffdbe0) at ../qom/object.c:1093
+ * #8  0x0000555555d2a3b1 in object_class_get_list (implements_type=0x555555faee84 "machine", include_abstract=false) at ../qom/object.c:1150
+ * #9  0x0000555555894512 in select_machine (qdict=0x55555680c600, errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:1661
+ * #10 0x00005555558956a4 in qemu_create_machine (qdict=0x55555680c600) at ../softmmu/vl.c:2146
+ * #11 0x00005555558991e5 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3708
+ * #12 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * 下面是其中一个property的例子.
+ *
+ * (gdb) p *prop
+ * $8 = {name = 0x555556817690 "x2apic", type = 0x5555568176b0 "bool", description = 0x0, get = 0x555555b6d930 <x86_cpu_get_bit_prop>, set = 0x555555b6d9de <x86_cpu_set_bit_prop>, resolve = 0x0, release = 0x0,
+ *   init = 0x0, opaque = 0x555556817610, defval = 0x0}
+ *
+ * ----------------------------------
+ *
+ * 启动以后, QEMU有两处初始化property的地方, 一个是"+x2apic,-x2apic", 一个是"x2apic=on".
+ *
+ * 对于"+"或者"-", 用x86_cpu_parse_featurestr()添加到plus_features或者minus_features, 比如line 4694和line 4698.
+ *
+ * (gdb) bt
+ * #0  x86_cpu_parse_featurestr (typename=0x5555567f4ae0 "host-x86_64-cpu", features=0x55555680e620 "-x2apic", errp=0x55555679a800 <error_fatal>) at ../target/i386/cpu.c:4669
+ * #1  0x0000555555bf2f64 in parse_cpu_option (cpu_option=0x7fffffffe290 "host,-x2apic") at ../cpu.c:265
+ * #2  0x0000555555899305 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3761
+ * #3  0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ * 4667 static void x86_cpu_parse_featurestr(const char *typename, char *features,
+ * 4668                                      Error **errp)
+ * 4669 {
+ * 4670     char *featurestr; // Single 'key=value" string being parsed
+ * 4671     static bool cpu_globals_initialized;
+ * 4672     bool ambiguous = false;
+ * 4673
+ * 4674     if (cpu_globals_initialized) {
+ * 4675         return;
+ * 4676     }
+ * 4677     cpu_globals_initialized = true;
+ * 4678
+ * 4679     if (!features) {
+ * 4680         return;
+ * 4681     }
+ * 4682
+ * 4683     for (featurestr = strtok(features, ",");
+ * 4684          featurestr;
+ * 4685          featurestr = strtok(NULL, ",")) {
+ * 4686         const char *name;
+ * 4687         const char *val = NULL;
+ * 4688         char *eq = NULL;
+ * 4689         char num[32];
+ * 4690         GlobalProperty *prop;
+ * 4691
+ * 4692         // Compatibility syntax:
+ * 4693         if (featurestr[0] == '+') {
+ * 4694             plus_features = g_list_append(plus_features,
+ * 4695                                           g_strdup(featurestr + 1));
+ * 4696             continue;
+ * 4697         } else if (featurestr[0] == '-') {
+ * 4698             minus_features = g_list_append(minus_features,
+ * 4699                                            g_strdup(featurestr + 1));
+ * 4700             continue;
+ * 4701         }
+ *
+ * 稍后在x86_cpu_expand_features()设置true或者false.
+ *
+ * 6145 void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
+ * 6146 {
+ * 6147     CPUX86State *env = &cpu->env;
+ * 6148     FeatureWord w;
+ * 6149     int i;
+ * 6150     GList *l;
+ * 6151
+ * 6152     for (l = plus_features; l; l = l->next) {
+ * 6153         const char *prop = l->data;
+ * 6154         if (!object_property_set_bool(OBJECT(cpu), prop, true, errp)) {
+ * 6155             return;
+ * 6156         }
+ * 6157     }
+ * 6158
+ * 6159     for (l = minus_features; l; l = l->next) {
+ * 6160         const char *prop = l->data;
+ * 6161         if (!object_property_set_bool(OBJECT(cpu), prop, false, errp)) {
+ * 6162             return;
+ * 6163         }
+ * 6164     }
+ *
+ * (gdb) bt
+ * #0  x86_cpu_expand_features (cpu=0x555556a5f460, errp=0x7fffffffd790) at ../target/i386/cpu.c:6147
+ * #1  0x0000555555b6d14e in x86_cpu_realizefn (dev=0x555556a5f460, errp=0x7fffffffd810) at ../target/i386/cpu.c:6381
+ * #2  0x0000555555d2325a in device_set_realized (obj=0x555556a5f460, value=true, errp=0x7fffffffd920) at ../hw/core/qdev.c:531
+ * #3  0x0000555555d2cd6c in property_set_bool (obj=0x555556a5f460, v=0x555556a6e980, name=0x5555560c1221 "realized", opaque=0x555556812500, errp=0x7fffffffd920) at ../qom/object.c:2273
+ * #4  0x0000555555d2adb3 in object_property_set (obj=0x555556a5f460, name=0x5555560c1221 "realized", v=0x555556a6e980, errp=0x7fffffffd920) at ../qom/object.c:1408
+ * #5  0x0000555555d2f15e in object_property_set_qobject (obj=0x555556a5f460, name=0x5555560c1221 "realized", value=0x555556a6be10, errp=0x55555679a800 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #6  0x0000555555d2b118 in object_property_set_bool (obj=0x555556a5f460, name=0x5555560c1221 "realized", value=true, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:1477
+ * #7  0x0000555555d22b22 in qdev_realize (dev=0x555556a5f460, bus=0x0, errp=0x55555679a800 <error_fatal>) at ../hw/core/qdev.c:333
+ * #8  0x0000555555b2e017 in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:101
+ * #9  0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #10 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #11 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #12 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #13 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #14 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #15 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #16 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ *
+ * 对于第二种情况"x2apic=on"或"x2apic=off", 在x86_cpu_parse_featurestr()的最后一种情况处理, line 4742.
+ *
+ * 4667 static void x86_cpu_parse_featurestr(const char *typename, char *features,
+ * 4668                                      Error **errp)
+ * 4669 {
+ * ... ...
+ * 4742         prop = g_new0(typeof(*prop), 1);
+ * 4743         prop->driver = typename;
+ * 4744         prop->property = g_strdup(name);
+ * 4745         prop->value = g_strdup(val);
+ * 4746         qdev_prop_register_global(prop);
+ * 4747     }
+ *
+ * ... 然后稍后在x86_cpu_new()-->qdev_prop_set_globals()设置true or false.
+ *
+ * (gdb) bt
+ * #0  object_property_parse (obj=0x555556a5f460, name=0x55555680db00 "x2apic", string=0x55555680db20 "off", errp=0x7fffffffd878) at ../qom/object.c:1646
+ * #1  0x0000555555d28d33 in object_apply_global_props (obj=0x555556a5f460, props=0x5555569b8f00, errp=0x55555679a800 <error_fatal>) at ../qom/object.c:412
+ * #2  0x0000555555d20e5c in qdev_prop_set_globals (dev=0x555556a5f460) at ../hw/core/qdev-properties.c:790
+ * #3  0x0000555555d2385d in device_post_init (obj=0x555556a5f460) at ../hw/core/qdev.c:697
+ * #4  0x0000555555d28c2d in object_post_init_with_type (obj=0x555556a5f460, ti=0x555556802d20) at ../qom/object.c:384
+ * #5  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567b2220) at ../qom/object.c:388
+ * #6  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567e1470) at ../qom/object.c:388
+ * #7  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4600) at ../qom/object.c:388
+ * #8  0x0000555555d28c5b in object_post_init_with_type (obj=0x555556a5f460, ti=0x5555567f4960) at ../qom/object.c:388
+ * #9  0x0000555555d29141 in object_initialize_with_type (obj=0x555556a5f460, size=51344, type=0x5555567f4960) at ../qom/object.c:520
+ * #10 0x0000555555d29838 in object_new_with_type (type=0x5555567f4960) at ../qom/object.c:734
+ * #11 0x0000555555d2988f in object_new (typename=0x5555567f4ae0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #12 0x0000555555b2dfce in x86_cpu_new (x86ms=0x555556a0b990, apic_id=0, errp=0x55555679a800 <error_fatal>) at ../hw/i386/x86.c:96
+ * #13 0x0000555555b2e0e6 in x86_cpus_init (x86ms=0x555556a0b990, default_cpu_version=1) at ../hw/i386/x86.c:128
+ * #14 0x0000555555b398df in pc_init1 (machine=0x555556a0b990, host_type=0x55555606fef4 "i440FX-pcihost", pci_type=0x55555606feed "i440FX") at ../hw/i386/pc_piix.c:157
+ * #15 0x0000555555b3a322 in pc_init_v7_0 (machine=0x555556a0b990) at ../hw/i386/pc_piix.c:427
+ * #16 0x0000555555954dff in machine_run_board_init (machine=0x555556a0b990) at ../hw/core/machine.c:1189
+ * #17 0x0000555555896b1d in qemu_init_board () at ../softmmu/vl.c:2656
+ * #18 0x0000555555896d5b in qmp_x_exit_preconfig (errp=0x55555679a800 <error_fatal>) at ../softmmu/vl.c:2746
+ * #19 0x0000555555899362 in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/vl.c:3776
+ * #20 0x0000555555836e7d in main (argc=18, argv=0x7fffffffdf08, envp=0x7fffffffdfa0) at ../softmmu/main.c:49
+ *
+ *
+ * Again, 最终这些property(e.g., x2apic, vmx)的setter是x86_cpu_set_bit_prop(), 就是修改cpu->env.features[fp->w].
+ *
+ * ----------------------------------
+ *
+ * 这里是关于在QEMU的cpuid features的计算.
+ *
+ * x86_cpu_realizefn()
+ * -> x86_cpu_expand_features()
+ * -> x86_cpu_filter_features()
+ *
+ * x86_cpu_filter_features()会通过从KVM_GET_SUPPORTED_CPUID和已经有的env->features[w]比较, 然后and过滤掉不支持的.
+ * 比如line 6295-6300.
+ *
+ * 6283 static void x86_cpu_filter_features(X86CPU *cpu, bool verbose)
+ * 6284 {
+ * 6285     CPUX86State *env = &cpu->env;
+ * 6286     FeatureWord w;
+ * 6287     const char *prefix = NULL;
+ * 6288
+ * 6289     if (verbose) {
+ * 6290         prefix = accel_uses_host_cpuid()
+ * 6291                  ? "host doesn't support requested feature"
+ * 6292                  : "TCG doesn't support requested feature";
+ * 6293     }
+ * 6294
+ * 6295     for (w = 0; w < FEATURE_WORDS; w++) {
+ * 6296         uint64_t host_feat =
+ * 6297             x86_cpu_get_supported_feature_word(w, false);
+ * 6298         uint64_t requested_features = env->features[w];
+ * 6299         uint64_t unavailable_features = requested_features & ~host_feat;
+ * 6300         mark_unavailable_features(cpu, w, unavailable_features, prefix);
+ * 6301     }
+ *
+ *
+ * 最终会通过KVM_SET_CPUID2更新到KVM. 首先在kvm_arch_init_vcpu()把env->features[w]转换成以下的结构.
+ * 然后通过KVM_SET_CPUID2更新到KVM.
+ *
+ * struct {
+ *     struct kvm_cpuid2 cpuid;
+ *     struct kvm_cpuid_entry2 entries[KVM_MAX_CPUID_ENTRIES];
+ * }
+ *
+ * (gdb) bt
+ * #0  kvm_arch_init_vcpu (cs=0x555556a5f460) at ../target/i386/kvm/kvm.c:1621
+ * #1  0x0000555555d0c631 in kvm_init_vcpu (cpu=0x555556a5f460, errp=0x55555679a800 <error_fatal>) at ../accel/kvm/kvm-all.c:516
+ * #2  0x0000555555d13504 in kvm_vcpu_thread_fn (arg=0x555556a5f460) at ../accel/kvm/kvm-accel-ops.c:40
+ * #3  0x0000555555efbfb0 in qemu_thread_start (args=0x555556a6f3a0) at ../util/qemu-thread-posix.c:556
+ * #4  0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #5  0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ *
+ * ----------------------------------
+ *
+ * KVM side处理KVM_SET_CPUID2, 把cpuid的结构更新到下面.
+ *
+ * struct kvm_vcpu_arch {
+ * ... ...
+ *     int cpuid_nent;
+ *     struct kvm_cpuid_entry2 *cpuid_entries;
+ *
+ * 这样在kvm_cpuid()的时候就可以用kvm_find_cpuid_entry()获得了.
+ *
+ *
+ * ======================================
+ *
+ * 下面是QEMU comment中的流程.
+ *
+ *  ***** Steps involved on loading and filtering CPUID data
+ *  *
+ *  * When initializing and realizing a CPU object, the steps
+ *  * involved in setting up CPUID data are:
+ *  *
+ *  * 1) Loading CPU model definition (X86CPUDefinition). This is
+ *  *    implemented by x86_cpu_load_model() and should be completely
+ *  *    transparent, as it is done automatically by instance_init.
+ *  *    No code should need to look at X86CPUDefinition structs
+ *  *    outside instance_init.
+ *  *
+ *  * 2) CPU expansion. This is done by realize before CPUID
+ *  *    filtering, and will make sure host/accelerator data is
+ *  *    loaded for CPU models that depend on host capabilities
+ *  *    (e.g. "host"). Done by x86_cpu_expand_features().
+ *  *
+ *  * 3) CPUID filtering. This initializes extra data related to
+ *  *    CPUID, and checks if the host supports all capabilities
+ *  *    required by the CPU. Runnability of a CPU model is
+ *  *    determined at this step. Done by x86_cpu_filter_features().
+ *  *
+ *  * Some operations don't require all steps to be performed.
+ *  * More precisely:
+ *  *
+ *  * - CPU instance creation (instance_init) will run only CPU
+ *  *   model loading. CPU expansion can't run at instance_init-time
+ *  *   because host/accelerator data may be not available yet.
+ *  * - CPU realization will perform both CPU model expansion and CPUID
+ *  *   filtering, and return an error in case one of them fails.
+ *  * - query-cpu-definitions needs to run all 3 steps. It needs
+ *  *   to run CPUID filtering, as the 'unavailable-features'
+ *  *   field is set based on the filtering results.
+ *  * - The query-cpu-model-expansion QMP command only needs to run
+ *  *   CPU model loading and CPU expansion. It should not filter
+ *  *   any CPUID data based on host capabilities.
+ *  *
+ *
+ * ==============================================
+ *
+ * 几种VM不支持x2apic的原因.
+ *
+ * 1. "-cpu"中有-x2apic
+ *
+ * 2. 没有kvm_irqchip_in_kernel().
+ *
+ *  389 uint32_t kvm_arch_get_supported_cpuid(KVMState *s, uint32_t function,
+ *  390                                       uint32_t index, int reg)
+ * ... ...
+ *  423         // x2apic is reported by GET_SUPPORTED_CPUID, but it can't be enabled
+ *  424          * without the in-kernel irqchip
+ *  425          //
+ *  426         if (!kvm_irqchip_in_kernel()) {
+ *  427             ret &= ~CPUID_EXT_X2APIC;
+ *  428         }
+ *
+ *
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ *
+ * 在以下使用feature_word_info[FEATURE_WORDS]:
+ *   - target/i386/cpu.c|1384| <<global>> FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
+ *   - target/i386/cpu-sysemu.c|62| <<x86_cpu_static_props>> FeatureWordInfo *fi = &feature_word_info[w];
+ *   - target/i386/cpu.c|2339| <<x86_cpu_get_migratable_flags>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|5904| <<mark_unavailable_features>> FeatureWordInfo *f = &feature_word_info[w];
+ *   - target/i386/cpu.c|6266| <<x86_cpu_get_feature_words>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|6319| <<x86_cpu_feature_name>> name = feature_word_info[w].feat_names[bitnr];
+ *   - target/i386/cpu.c|6320| <<x86_cpu_feature_name>> assert(bitnr < 32 || !(name && feature_word_info[w].type == CPUID_FEATURE_WORD));
+ *   - target/i386/cpu.c|6568| <<x86_cpu_list>> for (i = 0; i < ARRAY_SIZE(feature_word_info); i++) {
+ *   - target/i386/cpu.c|6569| <<x86_cpu_list>> FeatureWordInfo *fw = &feature_word_info[i];
+ *   - target/i386/cpu.c|6665| <<x86_cpu_get_supported_feature_word>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|8016| <<x86_cpu_adjust_feat_level>> FeatureWordInfo *fi = &feature_word_info[w];
+ *   - target/i386/cpu.c|8020| <<x86_cpu_adjust_feat_level>> assert(feature_word_info[w].type == CPUID_FEATURE_WORD);
+ *   - target/i386/cpu.c|8153| <<x86_cpu_expand_features>> ~feature_word_info[w].no_autoenable_flags;
+ *   - target/i386/cpu.c|8800| <<x86_cpu_register_feature_bit_props>> FeatureWordInfo *fi = &feature_word_info[w];
+ */
 FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
     [FEAT_1_EDX] = {
         .type = CPUID_FEATURE_WORD,
@@ -1617,6 +2102,11 @@ typedef struct FeatureDep {
     FeatureMask from, to;
 } FeatureDep;
 
+/*
+ * 在以下使用feature_dependencies[]:
+ *   - target/i386/cpu.c|8203| <<x86_cpu_expand_features>> for (i = 0; i < ARRAY_SIZE(feature_dependencies); i++) {
+ *   - target/i386/cpu.c|8204| <<x86_cpu_expand_features>> FeatureDep *d = &feature_dependencies[i];
+ */
 static FeatureDep feature_dependencies[] = {
     {
         .from = { FEAT_7_0_EDX,             CPUID_7_0_EDX_ARCH_CAPABILITIES },
@@ -1884,6 +2374,32 @@ static uint64_t x86_cpu_get_migratable_flags(FeatureWord w)
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/i386/sgx.c|96| <<sgx_calc_host_epc_sections>> host_cpuid(0x12, i + 2, &eax, &ebx, &ecx, &edx);
+ *   - hw/i386/sgx.c|170| <<qmp_query_sgx_capabilities>> host_cpuid(0x7, 0, &eax, &ebx, &ecx, &edx);
+ *   - hw/i386/sgx.c|175| <<qmp_query_sgx_capabilities>> host_cpuid(0x12, 0, &eax, &ebx, &ecx, &edx);
+ *   - target/i386/cpu.c|6289| <<x86_cpu_get_cache_cpuid>> host_cpuid(0, 0, &level, &unused, &unused, &unused);
+ *   - target/i386/cpu.c|6294| <<x86_cpu_get_cache_cpuid>> host_cpuid(0x80000000, 0, &level, &unused, &unused, &unused);
+ *   - target/i386/cpu.c|6306| <<x86_cpu_get_cache_cpuid>> host_cpuid(func, index, eax, ebx, ecx, edx);
+  9 target/i386/cpu.c|6916| <<cpu_x86_cpuid>> host_cpuid(index, 2, eax, ebx, ecx, edx);
+ 10 target/i386/host-cpu.c|23| <<host_cpu_phys_bits>> host_cpuid(0x80000000, 0, &eax, NULL, NULL, NULL);
+ 11 target/i386/host-cpu.c|25| <<host_cpu_phys_bits>> host_cpuid(0x80000008, 0, &eax, NULL, NULL, NULL);
+ 12 target/i386/host-cpu.c|109| <<host_cpu_fill_model_id>> host_cpuid(0x80000002 + i, 0, &eax, &ebx, &ecx, &edx);
+ 13 target/i386/host-cpu.c|122| <<host_cpu_vendor_fms>> host_cpuid(0x0, 0, &eax, &ebx, &ecx, &edx);
+ *   - target/i386/host-cpu.c|125| <<host_cpu_vendor_fms>> host_cpuid(0x1, 0, &eax, &ebx, &ecx, &edx);
+ 15 target/i386/host-cpu.c|145| <<host_cpu_instance_init>> host_cpuid(0, 0, NULL, &ebx, &ecx, &edx);
+ 16 target/i386/hvf/x86_cpuid.c|54| <<hvf_get_supported_cpuid>> host_cpuid(func, idx, &eax, &ebx, &ecx, &edx);
+ 17 target/i386/kvm/kvm-cpu.c|96| <<kvm_cpu_realizefn>> host_cpuid(5, 0, &cpu->mwait.eax, &cpu->mwait.ebx,
+ 18 target/i386/kvm/kvm-cpu.c|173| <<kvm_cpu_xsave_init>> host_cpuid(0xd, i, &eax, &ebx, &ecx, &edx);
+ 19 target/i386/kvm/kvm.c|653| <<kvm_arch_get_supported_cpuid>> host_cpuid(7, 0, &unused, &ebx, &unused, &unused);
+ 20 target/i386/kvm/kvm.c|662| <<kvm_arch_get_supported_cpuid>> host_cpuid(7, 0, &unused, &unused, &unused, &edx);
+ 21 target/i386/kvm/kvm.c|676| <<kvm_arch_get_supported_cpuid>> host_cpuid(7, 1, &eax, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|680| <<kvm_arch_get_supported_cpuid>> host_cpuid(7, 2, &unused, &unused, &unused, &edx);
+ 23 target/i386/kvm/kvm.c|6711| <<host_supports_vmx>> host_cpuid(1, 0, &unused, &unused, &ecx, &unused);
+ 24 target/i386/sev.c|620| <<sev_get_capabilities>> host_cpuid(0x8000001F, 0, NULL, &ebx, NULL, NULL);
+ 25 target/i386/sev.c|1449| <<sev_common_kvm_init>> host_cpuid(0x8000001F, 0, NULL, &ebx, NULL, NULL);
+ */
 void host_cpuid(uint32_t function, uint32_t count,
                 uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx)
 {
@@ -5352,6 +5868,9 @@ static void max_x86_cpu_initfn(Object *obj)
      * these defaults are used for TCG and all other accelerators
      * besides KVM and HVF, which overwrite these values
      */
+    /*
+     * TCG默认是AuthenticAMD
+     */
     object_property_set_str(OBJECT(cpu), "vendor", CPUID_VENDOR_AMD,
                             &error_abort);
     object_property_set_str(OBJECT(cpu), "model-id",
@@ -5399,6 +5918,13 @@ static bool x86_cpu_have_filtered_features(X86CPU *cpu)
     return false;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|8202| <<x86_cpu_expand_features>> mark_unavailable_features(cpu, d->to.index,
+ *   - target/i386/cpu.c|8239| <<x86_cpu_expand_features>> mark_unavailable_features(cpu, FEAT_7_0_EBX,
+ *   - target/i386/cpu.c|8366| <<x86_cpu_filter_features>> mark_unavailable_features(cpu, w, unavailable_features, prefix);
+ *   - target/i386/cpu.c|8398| <<x86_cpu_filter_features>> mark_unavailable_features(cpu, FEAT_7_0_EBX, CPUID_7_0_EBX_INTEL_PT, prefix); 
+ */
 static void mark_unavailable_features(X86CPU *cpu, FeatureWord w, uint64_t mask,
                                       const char *verbose_prefix)
 {
@@ -5552,6 +6078,105 @@ static char *x86_cpuid_get_vendor(Object *obj, Error **errp)
     return value;
 }
 
+/*
+ * 初始化默认是AMD
+ *
+ * (gdb) bt
+ * #0  x86_cpuid_set_vendor (obj=0x5555574631f0, value=0x55555746c020 "AuthenticAMD", errp=0x5555570af7b8 <error_abort>)
+ *            at ../target/i386/cpu.c:5190
+ * #1  0x0000555555e9b051 in property_set_str (obj=0x5555574631f0, v=0x55555746bf20, name=0x5555562f38b7 "vendor",
+ *            opaque=0x555557184d80, errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:2281
+ * #2  0x0000555555e98e36 in object_property_set (obj=0x5555574631f0, name=0x5555562f38b7 "vendor", v=0x55555746bf20,
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1472
+ * #3  0x0000555555e9dba3 in object_property_set_qobject (obj=0x5555574631f0, name=0x5555562f38b7 "vendor",
+ *            value=0x555557463080, errp=0x5555570af7b8 <error_abort>) at ../qom/qom-qobject.c:28
+ * #4  0x0000555555e98eda in object_property_set_str (obj=0x5555574631f0, name=0x5555562f38b7 "vendor", value=0x5555562f38aa "AuthenticAMD",
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1480
+ * #5  0x0000555555ce8d85 in max_x86_cpu_initfn (obj=0x5555574631f0) at ../target/i386/cpu.c:4987
+ * #6  0x0000555555e9650e in object_init_with_type (obj=0x5555574631f0, ti=0x555557154310) at ../qom/object.c:429
+ * #7  0x0000555555e964f0 in object_init_with_type (obj=0x5555574631f0, ti=0x555557154670) at ../qom/object.c:425
+ * #8  0x0000555555e96b05 in object_initialize_with_type (obj=0x5555574631f0, size=25888, type=0x555557154670) at ../qom/object.c:571
+ * #9  0x0000555555e97385 in object_new_with_type (type=0x555557154670) at ../qom/object.c:791
+ * #10 0x0000555555e973e9 in object_new (typename=0x5555571547f0 "host-x86_64-cpu") at ../qom/object.c:806
+ * #11 0x0000555555c9413a in x86_cpu_new (x86ms=0x5555573e9000, apic_id=0, errp=0x5555570af7c0 <error_fatal>) at ../hw/i386/x86.c:100
+ * #12 0x0000555555c942f7 in x86_cpus_init (x86ms=0x5555573e9000, default_cpu_version=1) at ../hw/i386/x86.c:156
+ * #13 0x0000555555ca1242 in pc_init1 (machine=0x5555573e9000, pci_type=0x5555562e5df3 "i440FX") at ../hw/i386/pc_piix.c:185
+ * #14 0x0000555555ca20fa in pc_init_v9_0 (machine=0x5555573e9000) at ../hw/i386/pc_piix.c:523
+ * #15 0x000055555593b0b8 in machine_run_board_init (machine=0x5555573e9000, mem_path=0x0, errp=0x7fffffffd970)
+ *            at ../hw/core/machine.c:1547
+ * #16 0x0000555555bcab2e in qemu_init_board () at ../system/vl.c:2613
+ * #17 0x0000555555bcae41 in qmp_x_exit_preconfig (errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:2705
+ * #18 0x0000555555bcd92e in qemu_init (argc=24, argv=0x7fffffffdc68) at ../system/vl.c:3739
+ * #19 0x0000555555e8a1ef in main (argc=24, argv=0x7fffffffdc68) at ../system/main.c:47
+ *
+ * 有"-cpu host"
+ *
+ * (gdb) bt
+ * #0  x86_cpuid_set_vendor (obj=0x5555574631f0, value=0x55555746c020 "GenuineIntel", errp=0x5555570af7b8 <error_abort>)
+ *            at ../target/i386/cpu.c:5190
+ * #1  0x0000555555e9b051 in property_set_str (obj=0x5555574631f0, v=0x55555746bf20, name=0x5555562f5a45 "vendor",
+ *            opaque=0x555557184d80, errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:2281
+ * #2  0x0000555555e98e36 in object_property_set (obj=0x5555574631f0, name=0x5555562f5a45 "vendor", v=0x55555746bf20,
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1472
+ * #3  0x0000555555e9dba3 in object_property_set_qobject (obj=0x5555574631f0, name=0x5555562f5a45 "vendor", value=0x555557463080,
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/qom-qobject.c:28
+ * #4  0x0000555555e98eda in object_property_set_str (obj=0x5555574631f0, name=0x5555562f5a45 "vendor", value=0x7fffffffd583 "GenuineIntel",
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1480
+ * #5  0x0000555555cf7dc0 in host_cpu_max_instance_init (cpu=0x5555574631f0) at ../target/i386/host-cpu.c:178
+ * #6  0x0000555555c81a89 in kvm_cpu_max_instance_init (cpu=0x5555574631f0) at ../target/i386/kvm/kvm-cpu.c:71
+ * #7  0x0000555555c81e1f in kvm_cpu_instance_init (cs=0x5555574631f0) at ../target/i386/kvm/kvm-cpu.c:184
+ * #8  0x0000555555e46ba0 in accel_cpu_instance_init (cpu=0x5555574631f0) at ../accel/accel-target.c:118
+ * #9  0x0000555555cf01d8 in x86_cpu_post_initfn (obj=0x5555574631f0) at ../target/i386/cpu.c:7596
+ * #10 0x0000555555e96547 in object_post_init_with_type (obj=0x5555574631f0, ti=0x555557140640) at ../qom/object.c:436
+ * #11 0x0000555555e96575 in object_post_init_with_type (obj=0x5555574631f0, ti=0x555557154310) at ../qom/object.c:440
+ * #12 0x0000555555e96575 in object_post_init_with_type (obj=0x5555574631f0, ti=0x555557154670) at ../qom/object.c:440
+ * #13 0x0000555555e96b18 in object_initialize_with_type (obj=0x5555574631f0, size=25888, type=0x555557154670) at ../qom/object.c:572
+ * #14 0x0000555555e97385 in object_new_with_type (type=0x555557154670) at ../qom/object.c:791
+ * #15 0x0000555555e973e9 in object_new (typename=0x5555571547f0 "host-x86_64-cpu") at ../qom/object.c:806
+ * #16 0x0000555555c9413a in x86_cpu_new (x86ms=0x5555573e9000, apic_id=0, errp=0x5555570af7c0 <error_fatal>) at ../hw/i386/x86.c:100
+ * #17 0x0000555555c942f7 in x86_cpus_init (x86ms=0x5555573e9000, default_cpu_version=1) at ../hw/i386/x86.c:156
+ * #18 0x0000555555ca1242 in pc_init1 (machine=0x5555573e9000, pci_type=0x5555562e5df3 "i440FX") at ../hw/i386/pc_piix.c:185
+ * #19 0x0000555555ca20fa in pc_init_v9_0 (machine=0x5555573e9000) at ../hw/i386/pc_piix.c:523
+ * #20 0x000055555593b0b8 in machine_run_board_init (machine=0x5555573e9000, mem_path=0x0, errp=0x7fffffffd970)
+ *            at ../hw/core/machine.c:1547
+ * #21 0x0000555555bcab2e in qemu_init_board () at ../system/vl.c:2613
+ * #22 0x0000555555bcae41 in qmp_x_exit_preconfig (errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:2705
+ * #23 0x0000555555bcd92e in qemu_init (argc=24, argv=0x7fffffffdc68) at ../system/vl.c:3739
+ * #24 0x0000555555e8a1ef in main (argc=24, argv=0x7fffffffdc68) at ../system/main.c:47
+ *
+ * 没有"-cpu host"
+ *
+ * (gdb) bt
+ * #0  x86_cpuid_set_vendor (obj=0x5555574631f0, value=0x55555746c020 "GenuineIntel", errp=0x5555570af7b8 <error_abort>)
+ *            at ../target/i386/cpu.c:5190
+ * #1  0x0000555555e9b051 in property_set_str (obj=0x5555574631f0, v=0x55555746bf20, name=0x5555562f5a45 "vendor",
+ *            opaque=0x555557184d80, errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:2281
+ * #2  0x0000555555e98e36 in object_property_set (obj=0x5555574631f0, name=0x5555562f5a45 "vendor", v=0x55555746bf20,
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1472
+ * #3  0x0000555555e9dba3 in object_property_set_qobject (obj=0x5555574631f0, name=0x5555562f5a45 "vendor",
+ *            value=0x555557463080, errp=0x5555570af7b8 <error_abort>) at ../qom/qom-qobject.c:28
+ * #4  0x0000555555e98eda in object_property_set_str (obj=0x5555574631f0, name=0x5555562f5a45 "vendor", value=0x7fffffffd62b "GenuineIntel",
+ *            errp=0x5555570af7b8 <error_abort>) at ../qom/object.c:1480
+ * #5  0x0000555555cf7cbb in host_cpu_instance_init (cpu=0x5555574631f0) at ../target/i386/host-cpu.c:162
+ * #6  0x0000555555c81d91 in kvm_cpu_instance_init (cs=0x5555574631f0) at ../target/i386/kvm/kvm-cpu.c:169
+ * #7  0x0000555555e46ba0 in accel_cpu_instance_init (cpu=0x5555574631f0) at ../accel/accel-target.c:118
+ * #8  0x0000555555cf01d8 in x86_cpu_post_initfn (obj=0x5555574631f0) at ../target/i386/cpu.c:7596
+ * #9  0x0000555555e96547 in object_post_init_with_type (obj=0x5555574631f0, ti=0x555557140640) at ../qom/object.c:436
+ * #10 0x0000555555e96575 in object_post_init_with_type (obj=0x5555574631f0, ti=0x5555571241b0) at ../qom/object.c:440
+ * #11 0x0000555555e96b18 in object_initialize_with_type (obj=0x5555574631f0, size=25888, type=0x5555571241b0) at ../qom/object.c:572
+ * #12 0x0000555555e97385 in object_new_with_type (type=0x5555571241b0) at ../qom/object.c:791
+ * #13 0x0000555555e973e9 in object_new (typename=0x5555562ec770 "qemu64-x86_64-cpu") at ../qom/object.c:806
+ * #14 0x0000555555c9413a in x86_cpu_new (x86ms=0x5555573e9000, apic_id=0, errp=0x5555570af7c0 <error_fatal>) at ../hw/i386/x86.c:100
+ * #15 0x0000555555c942f7 in x86_cpus_init (x86ms=0x5555573e9000, default_cpu_version=1) at ../hw/i386/x86.c:156
+ * #16 0x0000555555ca1242 in pc_init1 (machine=0x5555573e9000, pci_type=0x5555562e5df3 "i440FX") at ../hw/i386/pc_piix.c:185
+ * #17 0x0000555555ca20fa in pc_init_v9_0 (machine=0x5555573e9000) at ../hw/i386/pc_piix.c:523
+ * #18 0x000055555593b0b8 in machine_run_board_init (machine=0x5555573e9000, mem_path=0x0, errp=0x7fffffffd990)
+ *            at ../hw/core/machine.c:1547
+ * #19 0x0000555555bcab2e in qemu_init_board () at ../system/vl.c:2613
+ * #20 0x0000555555bcae41 in qmp_x_exit_preconfig (errp=0x5555570af7c0 <error_fatal>) at ../system/vl.c:2705
+ * #21 0x0000555555bcd92e in qemu_init (argc=22, argv=0x7fffffffdc88) at ../system/vl.c:3739
+ * #22 0x0000555555e8a1ef in main (argc=22, argv=0x7fffffffdc88) at ../system/main.c:47
+ */
 static void x86_cpuid_set_vendor(Object *obj, const char *value,
                                  Error **errp)
 {
@@ -5565,6 +6190,18 @@ static void x86_cpuid_set_vendor(Object *obj, const char *value,
         return;
     }
 
+    /*
+     * 在以下使用CPUArchState->cpuid_vendor1:
+     *   - target/i386/cpu.c|5550| <<x86_cpuid_get_vendor>> x86_cpu_vendor_words2str(value, env->cpuid_vendor1, env->cpuid_vendor2,
+     *   - target/i386/cpu.c|5568| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 = 0;
+     *   - target/i386/cpu.c|5572| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 |= ((uint8_t)value[i ]) << (8 * i);
+     *   - target/i386/cpu.c|6451| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+     *   - target/i386/cpu.c|6862| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+     *   - target/i386/cpu.c|6877| <<cpu_x86_cpuid>> if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||
+     *   - target/i386/cpu.c|6883| <<cpu_x86_cpuid>> if (tcg_enabled() && env->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 &&
+     *   - target/i386/cpu.h|1051| <<IS_INTEL_CPU>> #define IS_INTEL_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 && \
+     *   - target/i386/cpu.h|1054| <<IS_AMD_CPU>> #define IS_AMD_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_AMD_1 && \
+     */
     env->cpuid_vendor1 = 0;
     env->cpuid_vendor2 = 0;
     env->cpuid_vendor3 = 0;
@@ -6185,6 +6822,11 @@ static void x86_cpu_get_cache_cpuid(uint32_t func, uint32_t index,
 /*
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm-cpu.c|247| <<kvm_cpu_instance_init>> x86_cpu_apply_props(cpu, kvm_default_props);
+ *   - target/i386/tcg/tcg-cpu.c|176| <<x86_tcg_cpu_instance_init>> x86_cpu_apply_props(cpu, x86_tcg_default_props);
+ */
 void x86_cpu_apply_props(X86CPU *cpu, PropValue *props)
 {
     PropValue *pv;
@@ -6202,6 +6844,32 @@ void x86_cpu_apply_props(X86CPU *cpu, PropValue *props)
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_set_bit_prop (obj=0x555557557f10, v=0x555557560a60, name=0x55555622de8d "ibpb", opaque=0x5555572829e0, errp=0x5555571efef8 <error_abort>) at ../target/i386/cpu.c:7933
+ * #1  0x0000555555e42517 in object_property_set (obj=0x555557557f10, name=0x55555622de8d "ibpb", v=0x555557560a60, errp=0x5555571efef8 <error_abort>) at ../qom/object.c:1463
+ * #2  0x0000555555e43083 in object_property_parse (obj=0x555557557f10, name=0x55555622de8d "ibpb", string=0x55555622e985 "on", errp=0x5555571efef8 <error_abort>) at ../qom/object.c:1711
+ * #3  0x0000555555cbd2f3 in x86_cpu_apply_version_props (cpu=0x555557557f10, model=0x555557259890) at ../target/i386/cpu.c:6234
+ * #4  0x0000555555cbd5b8 in x86_cpu_load_model (cpu=0x555557557f10, model=0x555557259890) at ../target/i386/cpu.c:6324
+ * #5  0x0000555555cc2218 in x86_cpu_initfn (obj=0x555557557f10) at ../target/i386/cpu.c:8084
+ * #6  0x0000555555e4010d in object_init_with_type (obj=0x555557557f10, ti=0x55555722adb0) at ../qom/object.c:420
+ * #7  0x0000555555e400ef in object_init_with_type (obj=0x555557557f10, ti=0x5555572598c0) at ../qom/object.c:416
+ * #8  0x0000555555e4063f in object_initialize_with_type (obj=0x555557557f10, size=26048, type=0x5555572598c0) at ../qom/object.c:562
+ * #9  0x0000555555e40d49 in object_new_with_type (type=0x5555572598c0) at ../qom/object.c:782
+ * #10 0x0000555555e40da0 in object_new (typename=0x555557259a40 "EPYC-v2-x86_64-cpu") at ../qom/object.c:797
+ * #11 0x0000555555c79aa9 in x86_cpu_new (x86ms=0x5555574e0270, apic_id=0, errp=0x5555571eff00 <error_fatal>) at ../hw/i386/x86-common.c:58
+ * #12 0x0000555555c79c50 in x86_cpus_init (x86ms=0x5555574e0270, default_cpu_version=1) at ../hw/i386/x86-common.c:114
+ * #13 0x0000555555c80dbc in pc_q35_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:190
+ * #14 0x0000555555c816b5 in pc_q35_machine_9_1_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:365
+ * #15 0x000055555592bb08 in machine_run_board_init (machine=0x5555574e0270, mem_path=0x0, errp=0x7fffffffd850) at ../hw/core/machine.c:1593
+ * #16 0x0000555555b851c9 in qemu_init_board () at ../system/vl.c:2628
+ * #17 0x0000555555b85489 in qmp_x_exit_preconfig (errp=0x5555571eff00 <error_fatal>) at ../system/vl.c:2720
+ * #18 0x0000555555b87ccf in qemu_init (argc=22, argv=0x7fffffffdb48) at ../system/vl.c:3766
+ * #19 0x0000555555fb2744 in main (argc=22, argv=0x7fffffffdb48) at ../system/main.c:47
+ *
+ * called by:
+ *   - target/i386/cpu.c|6921| <<x86_cpu_load_model>> x86_cpu_apply_version_props(cpu, model);
+ */
 static void x86_cpu_apply_version_props(X86CPU *cpu, X86CPUModel *model)
 {
     const X86CPUVersionDefinition *vdef;
@@ -6259,6 +6927,32 @@ static const CPUCaches *x86_cpu_get_versioned_cache_info(X86CPU *cpu,
  * Load data from X86CPUDefinition into a X86CPU object.
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
+/*
+ * (gdb) bt
+ * #0  x86_cpu_set_bit_prop (obj=0x555557557f10, v=0x555557560a60, name=0x55555622de8d "ibpb", opaque=0x5555572829e0, errp=0x5555571efef8 <error_abort>) at ../target/i386/cpu.c:7933
+ * #1  0x0000555555e42517 in object_property_set (obj=0x555557557f10, name=0x55555622de8d "ibpb", v=0x555557560a60, errp=0x5555571efef8 <error_abort>) at ../qom/object.c:1463
+ * #2  0x0000555555e43083 in object_property_parse (obj=0x555557557f10, name=0x55555622de8d "ibpb", string=0x55555622e985 "on", errp=0x5555571efef8 <error_abort>) at ../qom/object.c:1711
+ * #3  0x0000555555cbd2f3 in x86_cpu_apply_version_props (cpu=0x555557557f10, model=0x555557259890) at ../target/i386/cpu.c:6234
+ * #4  0x0000555555cbd5b8 in x86_cpu_load_model (cpu=0x555557557f10, model=0x555557259890) at ../target/i386/cpu.c:6324
+ * #5  0x0000555555cc2218 in x86_cpu_initfn (obj=0x555557557f10) at ../target/i386/cpu.c:8084
+ * #6  0x0000555555e4010d in object_init_with_type (obj=0x555557557f10, ti=0x55555722adb0) at ../qom/object.c:420
+ * #7  0x0000555555e400ef in object_init_with_type (obj=0x555557557f10, ti=0x5555572598c0) at ../qom/object.c:416
+ * #8  0x0000555555e4063f in object_initialize_with_type (obj=0x555557557f10, size=26048, type=0x5555572598c0) at ../qom/object.c:562
+ * #9  0x0000555555e40d49 in object_new_with_type (type=0x5555572598c0) at ../qom/object.c:782
+ * #10 0x0000555555e40da0 in object_new (typename=0x555557259a40 "EPYC-v2-x86_64-cpu") at ../qom/object.c:797
+ * #11 0x0000555555c79aa9 in x86_cpu_new (x86ms=0x5555574e0270, apic_id=0, errp=0x5555571eff00 <error_fatal>) at ../hw/i386/x86-common.c:58
+ * #12 0x0000555555c79c50 in x86_cpus_init (x86ms=0x5555574e0270, default_cpu_version=1) at ../hw/i386/x86-common.c:114
+ * #13 0x0000555555c80dbc in pc_q35_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:190
+ * #14 0x0000555555c816b5 in pc_q35_machine_9_1_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:365
+ * #15 0x000055555592bb08 in machine_run_board_init (machine=0x5555574e0270, mem_path=0x0, errp=0x7fffffffd850) at ../hw/core/machine.c:1593
+ * #16 0x0000555555b851c9 in qemu_init_board () at ../system/vl.c:2628
+ * #17 0x0000555555b85489 in qmp_x_exit_preconfig (errp=0x5555571eff00 <error_fatal>) at ../system/vl.c:2720
+ * #18 0x0000555555b87ccf in qemu_init (argc=22, argv=0x7fffffffdb48) at ../system/vl.c:3766
+ * #19 0x0000555555fb2744 in main (argc=22, argv=0x7fffffffdb48) at ../system/main.c:47
+ *
+ * called by:
+ *   - target/i386/cpu.c|8839| <<x86_cpu_initfn>> x86_cpu_load_model(cpu, xcc->model);
+ */
 static void x86_cpu_load_model(X86CPU *cpu, X86CPUModel *model)
 {
     const X86CPUDefinition *def = model->cpudef;
@@ -6405,6 +7099,33 @@ uint32_t cpu_x86_virtual_addr_width(CPUX86State *env)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/fw_cfg.c|183| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 1, 0, &unused, &unused, &ecx, &edx);
+ *   - hw/i386/fw_cfg.c|195| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 0x7, 0, &unused, &ebx, &ecx, &unused);
+ *   - target/i386/hvf/hvf.c|404| <<hvf_cpu_x86_cpuid>> cpu_x86_cpuid(env, index, count, eax, ebx, ecx, edx);
+ *   - target/i386/kvm/kvm.c|2061| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|2077| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2087| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2108| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2133| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2154| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2165| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2172| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2187| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0x0a, 0, &eax, &unused, &unused, &edx);
+ *   - target/i386/kvm/kvm.c|2211| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0x80000000, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|2227| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2241| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/kvm/kvm.c|2255| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0xC0000000, 0, &limit, &unused, &unused, &unused);
+ *   - target/i386/kvm/kvm.c|2266| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+ *   - target/i386/tcg/fpu_helper.c|3151| <<helper_xsetbv>> cpu_x86_cpuid(env, 0x0d, 0, &ena_lo, &dummy, &dummy, &ena_hi);
+ *   - target/i386/tcg/misc_helper.c|56| <<helper_cpuid>> cpu_x86_cpuid(env, (uint32_t)env->regs[R_EAX], (uint32_t)env->regs[R_ECX],
+ *   - target/i386/whpx/whpx-all.c|1946| <<whpx_vcpu_run>> cpu_x86_cpuid(env, cpuid_fn, 0, (UINT32 *)&rax, (UINT32 *)&rbx,
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
 void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,
                    uint32_t *eax, uint32_t *ebx,
                    uint32_t *ecx, uint32_t *edx)
@@ -6447,6 +7168,30 @@ void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,
 
     switch(index) {
     case 0:
+        /*
+	 * 查看:
+	 *
+	 * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+	 *
+	 * 在以下使用CPUArchState->cpuid_vendor1:
+	 *   - target/i386/cpu.c|5550| <<x86_cpuid_get_vendor>> x86_cpu_vendor_words2str(value, env->cpuid_vendor1, env->cpuid_vendor2,
+	 *   - target/i386/cpu.c|5568| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 = 0;
+	 *   - target/i386/cpu.c|5572| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 |= ((uint8_t)value[i ]) << (8 * i);
+	 *   - target/i386/cpu.c|6451| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+	 *   - target/i386/cpu.c|6862| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+	 *   - target/i386/cpu.c|6877| <<cpu_x86_cpuid>> if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||
+	 *   - target/i386/cpu.c|6883| <<cpu_x86_cpuid>> if (tcg_enabled() && env->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 &&
+	 *   - target/i386/cpu.h|1051| <<IS_INTEL_CPU>> #define IS_INTEL_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 && \
+	 *   - target/i386/cpu.h|1054| <<IS_AMD_CPU>> #define IS_AMD_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_AMD_1 && \
+	 *
+	 * # cpuid -1 -l 0x0
+         * CPU:
+         *    vendor_id = "GenuineIntel"
+         *
+	 * # cpuid -1 -l 0x0 -r
+         * CPU:
+         *    0x00000000 0x00: eax=0x00000014 ebx=0x756e6547 ecx=0x6c65746e edx=0x49656e69
+	 */
         *eax = env->cpuid_level;
         *ebx = env->cpuid_vendor1;
         *edx = env->cpuid_vendor2;
@@ -6460,6 +7205,11 @@ void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,
         if ((*ecx & CPUID_EXT_XSAVE) && (env->cr[4] & CR4_OSXSAVE_MASK)) {
             *ecx |= CPUID_EXT_OSXSAVE;
         }
+        /*
+	 * 查看:
+	 *
+	 * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+	 */
         *edx = env->features[FEAT_1_EDX];
         if (threads_per_pkg > 1) {
             *ebx |= threads_per_pkg << 16;
@@ -7065,6 +7815,32 @@ static void x86_cpu_set_sgxlepubkeyhash(CPUX86State *env)
 #endif
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_reset_hold (obj=0x5555577182a0, type=RESET_TYPE_COLD) at ../target/i386/cpu.c:7070
+ * #1  0x0000555555eefb43 in resettable_phase_hold (obj=0x5555577182a0, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:180
+ * #2  0x0000555555eef69f in resettable_assert_reset (obj=0x5555577182a0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #3  0x0000555555eef5f7 in resettable_reset (obj=0x5555577182a0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #4  0x0000555555eec4c4 in device_cold_reset (dev=0x5555577182a0) at ../hw/core/qdev.c:254
+ * #5  0x000055555587d07f in cpu_reset (cpu=0x5555577182a0) at ../hw/core/cpu-common.c:113
+ * #6  0x0000555555cbd795 in x86_cpu_machine_reset_cb (opaque=0x5555577182a0) at ../target/i386/cpu-sysemu.c:266
+ * #7  0x0000555555951bdb in legacy_reset_hold (obj=0x55555771eeb0, type=RESET_TYPE_COLD) at ../hw/core/reset.c:76
+ * #8  0x0000555555eefb43 in resettable_phase_hold (obj=0x55555771eeb0, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:180
+ * #9  0x0000555555eedf2f in resettable_container_child_foreach (obj=0x55555768e600, cb=0x555555eef9e7 <resettable_phase_hold>, opaque=0x0,
+ *     type=RESET_TYPE_COLD) at ../hw/core/resetcontainer.c:54
+ * #10 0x0000555555eef7ea in resettable_child_foreach (rc=0x555557641ce0, obj=0x55555768e600, cb=0x555555eef9e7 <resettable_phase_hold>, opaque=0x0,
+ *     type=RESET_TYPE_COLD) at ../hw/core/resettable.c:92
+ * #11 0x0000555555eefaa4 in resettable_phase_hold (obj=0x55555768e600, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:169
+ * #12 0x0000555555eef69f in resettable_assert_reset (obj=0x55555768e600, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #13 0x0000555555eef5f7 in resettable_reset (obj=0x55555768e600, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #14 0x0000555555951f35 in qemu_devices_reset (reason=SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET) at ../hw/core/reset.c:179
+ * #15 0x0000555555d1dd96 in pc_machine_reset (machine=0x55555766ac00, reason=SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET) at ../hw/i386/pc.c:1714
+ * #16 0x0000555555be061c in qemu_system_reset (reason=SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET) at ../system/runstate.c:516
+ * #17 0x0000555555be0e22 in main_loop_should_exit (status=0x7fffffffdb14) at ../system/runstate.c:792
+ * #18 0x0000555555be0f23 in qemu_main_loop () at ../system/runstate.c:825
+ * #19 0x0000555556093994 in qemu_default_main () at ../system/main.c:37
+ * #20 0x00005555560939d1 in main (argc=24, argv=0x7fffffffdc38) at ../system/main.c:48
+ */
 static void x86_cpu_reset_hold(Object *obj, ResetType type)
 {
     CPUState *cs = CPU(obj);
@@ -7368,6 +8144,12 @@ static void x86_cpu_enable_xsave_components(X86CPU *cpu)
 /* Expand CPU configuration data, based on configured features
  * and host/accelerator capabilities when appropriate.
  */
+/*
+ * called by:
+ *   - target/i386/cpu-sysemu.c|175| <<x86_cpu_from_model>> x86_cpu_expand_features(xc, &err);
+ *   - target/i386/cpu.c|6604| <<x86_cpu_class_check_missing_features>> x86_cpu_expand_features(xc, &err);
+ *   - target/i386/cpu.c|8438| <<x86_cpu_realizefn>> x86_cpu_expand_features(cpu, &local_err);
+ */
 void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
 {
     CPUX86State *env = &cpu->env;
@@ -7389,6 +8171,23 @@ void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
         }
     }
 
+    /*
+     * 在以下使用feature_word_info[FEATURE_WORDS]:
+     *   - target/i386/cpu.c|1384| <<global>> FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
+     *   - target/i386/cpu-sysemu.c|62| <<x86_cpu_static_props>> FeatureWordInfo *fi = &feature_word_info[w];
+     *   - target/i386/cpu.c|2339| <<x86_cpu_get_migratable_flags>> FeatureWordInfo *wi = &feature_word_info[w];
+     *   - target/i386/cpu.c|5904| <<mark_unavailable_features>> FeatureWordInfo *f = &feature_word_info[w];
+     *   - target/i386/cpu.c|6266| <<x86_cpu_get_feature_words>> FeatureWordInfo *wi = &feature_word_info[w];
+     *   - target/i386/cpu.c|6319| <<x86_cpu_feature_name>> name = feature_word_info[w].feat_names[bitnr];
+     *   - target/i386/cpu.c|6320| <<x86_cpu_feature_name>> assert(bitnr < 32 || !(name && feature_word_info[w].type == CPUID_FEATURE_WORD));
+     *   - target/i386/cpu.c|6568| <<x86_cpu_list>> for (i = 0; i < ARRAY_SIZE(feature_word_info); i++) {
+     *   - target/i386/cpu.c|6569| <<x86_cpu_list>> FeatureWordInfo *fw = &feature_word_info[i];
+     *   - target/i386/cpu.c|6665| <<x86_cpu_get_supported_feature_word>> FeatureWordInfo *wi = &feature_word_info[w];
+     *   - target/i386/cpu.c|8016| <<x86_cpu_adjust_feat_level>> FeatureWordInfo *fi = &feature_word_info[w];
+     *   - target/i386/cpu.c|8020| <<x86_cpu_adjust_feat_level>> assert(feature_word_info[w].type == CPUID_FEATURE_WORD);
+     *   - target/i386/cpu.c|8153| <<x86_cpu_expand_features>> ~feature_word_info[w].no_autoenable_flags;
+     *   - target/i386/cpu.c|8800| <<x86_cpu_register_feature_bit_props>> FeatureWordInfo *fi = &feature_word_info[w];
+     */
     /*TODO: Now cpu->max_features doesn't overwrite features
      * set using QOM properties, and we can convert
      * plus_features & minus_features to global properties
@@ -7512,6 +8311,58 @@ void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
  *
  * Returns: 0 if all flags are supported by the host, non-zero otherwise.
  */
+/*
+ * 这里是关于在QEMU的cpuid features的计算.
+ *
+ * x86_cpu_realizefn()
+ * -> x86_cpu_expand_features()
+ * -> x86_cpu_filter_features()
+ *
+ * x86_cpu_filter_features()会通过从KVM_GET_SUPPORTED_CPUID和已经有的env->features[w]比较, 然后and过滤掉不支持的.
+ * 比如line 6295-6300.
+ *
+ * 6283 static void x86_cpu_filter_features(X86CPU *cpu, bool verbose)
+ * 6284 {
+ * 6285     CPUX86State *env = &cpu->env;
+ * 6286     FeatureWord w;
+ * 6287     const char *prefix = NULL;
+ * 6288
+ * 6289     if (verbose) {
+ * 6290         prefix = accel_uses_host_cpuid()
+ * 6291                  ? "host doesn't support requested feature"
+ * 6292                  : "TCG doesn't support requested feature";
+ * 6293     }
+ * 6294
+ * 6295     for (w = 0; w < FEATURE_WORDS; w++) {
+ * 6296         uint64_t host_feat =
+ * 6297             x86_cpu_get_supported_feature_word(w, false);
+ * 6298         uint64_t requested_features = env->features[w];
+ * 6299         uint64_t unavailable_features = requested_features & ~host_feat;
+ * 6300         mark_unavailable_features(cpu, w, unavailable_features, prefix);
+ * 6301     }
+ *
+ *
+ * 最终会通过KVM_SET_CPUID2更新到KVM. 首先在kvm_arch_init_vcpu()把env->features[w]转换成以下的结构.
+ * 然后通过KVM_SET_CPUID2更新到KVM.
+ *
+ * struct {
+ *     struct kvm_cpuid2 cpuid;
+ *     struct kvm_cpuid_entry2 entries[KVM_MAX_CPUID_ENTRIES];
+ * }
+ *
+ * (gdb) bt
+ * #0  kvm_arch_init_vcpu (cs=0x555556a5f460) at ../target/i386/kvm/kvm.c:1621
+ * #1  0x0000555555d0c631 in kvm_init_vcpu (cpu=0x555556a5f460, errp=0x55555679a800 <error_fatal>) at ../accel/kvm/kvm-all.c:516
+ * #2  0x0000555555d13504 in kvm_vcpu_thread_fn (arg=0x555556a5f460) at ../accel/kvm/kvm-accel-ops.c:40
+ * #3  0x0000555555efbfb0 in qemu_thread_start (args=0x555556a6f3a0) at ../util/qemu-thread-posix.c:556
+ * #4  0x00007ffff55efea5 in start_thread () at /lib64/libpthread.so.0
+ * #5  0x00007ffff53189fd in clone () at /lib64/libc.so.6
+ *
+ * 
+ * called by:
+ *   - target/i386/cpu.c|6630| <<x86_cpu_class_check_missing_features>> x86_cpu_filter_features(xc, false);
+ *   - target/i386/cpu.c|8518| <<x86_cpu_realizefn>> x86_cpu_filter_features(cpu, cpu->check_cpuid || cpu->enforce_cpuid);
+ */
 static void x86_cpu_filter_features(X86CPU *cpu, bool verbose)
 {
     CPUX86State *env = &cpu->env;
@@ -7595,6 +8446,26 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
     cpu->hyperv_limits[2] = 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_realizefn (dev=0x555557557f50, errp=0x7fffffffd460) at ../target/i386/cpu.c:7626
+ * #1  0x0000555555cbae19 in max_x86_cpu_realize (dev=0x555557557f50, errp=0x7fffffffd460) at ../target/i386/cpu.c:5340
+ * #2  0x0000555555e3a9ec in device_set_realized (obj=0x555557557f50, value=true, errp=0x7fffffffd570) at ../hw/core/qdev.c:510
+ * #3  0x0000555555e445a6 in property_set_bool (obj=0x555557557f50, v=0x555557562140, name=0x5555562709a9 "realized", opaque=0x555557278a70, errp=0x7fffffffd570) at ../qom/object.c:2354
+ * #4  0x0000555555e42517 in object_property_set (obj=0x555557557f50, name=0x5555562709a9 "realized", v=0x555557562140, errp=0x7fffffffd570) at ../qom/object.c:1463
+ * #5  0x0000555555e46998 in object_property_set_qobject (obj=0x555557557f50, name=0x5555562709a9 "realized", value=0x555557557f30, errp=0x5555571eff00 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #6  0x0000555555e4286c in object_property_set_bool (obj=0x555557557f50, name=0x5555562709a9 "realized", value=true, errp=0x5555571eff00 <error_fatal>) at ../qom/object.c:1533
+ * #7  0x0000555555e3a1ec in qdev_realize (dev=0x555557557f50, bus=0x0, errp=0x5555571eff00 <error_fatal>) at ../hw/core/qdev.c:291
+ * #8  0x0000555555c79af2 in x86_cpu_new (x86ms=0x5555574e0270, apic_id=0, errp=0x5555571eff00 <error_fatal>) at ../hw/i386/x86-common.c:63
+ * #9  0x0000555555c79c50 in x86_cpus_init (x86ms=0x5555574e0270, default_cpu_version=1) at ../hw/i386/x86-common.c:114
+ * #10 0x0000555555c80dbc in pc_q35_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:190
+ * #11 0x0000555555c816b5 in pc_q35_machine_9_1_init (machine=0x5555574e0270) at ../hw/i386/pc_q35.c:365
+ * #12 0x000055555592bb08 in machine_run_board_init (machine=0x5555574e0270, mem_path=0x0, errp=0x7fffffffd840) at ../hw/core/machine.c:1593
+ * #13 0x0000555555b851c9 in qemu_init_board () at ../system/vl.c:2628
+ * #14 0x0000555555b85489 in qmp_x_exit_preconfig (errp=0x5555571eff00 <error_fatal>) at ../system/vl.c:2720
+ * #15 0x0000555555b87ccf in qemu_init (argc=22, argv=0x7fffffffdb38) at ../system/vl.c:3766
+ * #16 0x0000555555fb2744 in main (argc=22, argv=0x7fffffffdb38) at ../system/main.c:47
+ */
 static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
@@ -7958,11 +8829,65 @@ static void x86_cpu_register_bit_prop(X86CPUClass *xcc,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_register_bit_prop (xcc=0x555557277d00, prop_name=0x55555622d9c6 "fpu", w=FEAT_1_EDX, bitnr=0) at ../target/i386/cpu.c:7968
+ * #1  0x0000555555cc1d75 in x86_cpu_register_feature_bit_props (xcc=0x555557277d00, w=FEAT_1_EDX, bitnr=0) at ../target/i386/cpu.c:8010
+ * #2  0x0000555555cc2c51 in x86_cpu_common_class_init (oc=0x555557277d00, data=0x0) at ../target/i386/cpu.c:8496
+ * #3  0x0000555555e40164 in type_initialize (ti=0x55555722adb0) at ../qom/object.c:409
+ * #4  0x0000555555e3fecf in type_initialize (ti=0x55555725a460) at ../qom/object.c:357
+ * #5  0x0000555555e418dd in object_class_foreach_tramp (key=0x55555725a5e0, value=0x55555725a460, opaque=0x7fffffffd7a0) at ../qom/object.c:1124
+ * #6  0x00007ffff7eaf3c0 in g_hash_table_foreach (hash_table=0x5555571f2a40, func=0x555555e418ad <object_class_foreach_tramp>, user_data=0x7fffffffd7a0) at ../glib/ghash.c:2067
+ * #7  0x0000555555e419bc in object_class_foreach (fn=0x555555e41b19 <object_class_get_list_tramp>, implements_type=0x5555561e9522 "machine", include_abstract=false, 
+ *     opaque=0x7fffffffd7f0) at ../qom/object.c:1146
+ * #8  0x0000555555e41b94 in object_class_get_list (implements_type=0x5555561e9522 "machine", include_abstract=false) at ../qom/object.c:1203
+ * #9  0x0000555555b82d98 in select_machine (qdict=0x555557272190, errp=0x7fffffffd840) at ../system/vl.c:1677
+ * #10 0x0000555555b83d92 in qemu_create_machine (qdict=0x555557272190) at ../system/vl.c:2116
+ * #11 0x0000555555b87b42 in qemu_init (argc=22, argv=0x7fffffffdb38) at ../system/vl.c:3691
+ * #12 0x0000555555fb2800 in main (argc=22, argv=0x7fffffffdb38) at ../system/main.c:47
+ *
+ * called by:
+ *   - target/i386/cpu.c|9165| <<x86_cpu_common_class_init>> x86_cpu_register_feature_bit_props(xcc, w, bitnr);
+ */
 static void x86_cpu_register_feature_bit_props(X86CPUClass *xcc,
                                                FeatureWord w,
                                                int bitnr)
 {
     FeatureWordInfo *fi = &feature_word_info[w];
+    /*
+     * 915 FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
+     * 916     [FEAT_1_EDX] = {
+     * 917         .type = CPUID_FEATURE_WORD,
+     * 918         .feat_names = {
+     * 919             "fpu", "vme", "de", "pse",
+     * 920             "tsc", "msr", "pae", "mce",
+     * 921             "cx8", "apic", NULL, "sep",
+     * 922             "mtrr", "pge", "mca", "cmov",
+     * 923             "pat", "pse36", "pn", "clflush",
+     * 924             NULL, "ds", "acpi", "mmx",
+     * 925             "fxsr", "sse", "sse2", "ss",
+     * 926             "ht", "tm", "ia64", "pbe",
+     * 927         },
+     * 928         .cpuid = {.eax = 1, .reg = R_EDX, },
+     * 929         .tcg_features = TCG_FEATURES,
+     * 930         .no_autoenable_flags = CPUID_HT,
+     * 931     },
+     * 932     [FEAT_1_ECX] = {
+     * 933         .type = CPUID_FEATURE_WORD,
+     * 934         .feat_names = {
+     * 935             "pni", "pclmulqdq", "dtes64", "monitor",
+     * 936             "ds-cpl", "vmx", "smx", "est",
+     * 937             "tm2", "ssse3", "cid", NULL,
+     * 938             "fma", "cx16", "xtpr", "pdcm",
+     * 939             NULL, "pcid", "dca", "sse4.1",
+     * 940             "sse4.2", "x2apic", "movbe", "popcnt",
+     * 941             "tsc-deadline", "aes", "xsave", NULL,
+     * 942             "avx", "f16c", "rdrand", "hypervisor",
+     * 943         },
+     * 944         .cpuid = { .eax = 1, .reg = R_ECX, },
+     * 945         .tcg_features = TCG_EXT_FEATURES,
+     * 946     },
+     */
     const char *name = fi->feat_names[bitnr];
 
     if (!name) {
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index 14edd57a3..a6cc159f4 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -488,7 +488,35 @@ typedef enum X86Seg {
 #define MSR_CORE_PERF_FIXED_CTR0        0x309
 #define MSR_CORE_PERF_FIXED_CTR1        0x30a
 #define MSR_CORE_PERF_FIXED_CTR2        0x30b
+/*
+ * 在以下使用MSR_CORE_PERF_FIXED_CTR_CTRL:
+ *   - target/i386/cpu.h|491| <<global>> #define MSR_CORE_PERF_FIXED_CTR_CTRL 0x38d
+ *   - target/i386/kvm/kvm.c|4552| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);
+ *   - target/i386/kvm/kvm.c|4632| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, env->msr_fixed_ctr_ctrl);
+ *   - target/i386/kvm/kvm.c|5153| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);
+ *   - target/i386/kvm/kvm.c|5473| <<kvm_get_msrs>> case MSR_CORE_PERF_FIXED_CTR_CTRL:
+ */
 #define MSR_CORE_PERF_FIXED_CTR_CTRL    0x38d
+/*
+ * 在以下使用MSR_CORE_PERF_GLOBAL_STATUS:
+ *   - target/i386/cpu.h|492| <<global>> #define MSR_CORE_PERF_GLOBAL_STATUS 0x38e                                                                               
+ *   - target/i386/kvm/kvm.c|4612| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, env->msr_global_status);
+ *   - target/i386/kvm/kvm.c|5155| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);
+ *   - target/i386/kvm/kvm.c|5493| <<kvm_get_msrs>> case MSR_CORE_PERF_GLOBAL_STATUS:
+ *
+ * 在以下使用MSR_CORE_PERF_GLOBAL_CTRL:
+ *   - target/i386/cpu.h|493| <<global>> #define MSR_CORE_PERF_GLOBAL_CTRL 0x38f
+ *   - target/i386/kvm/kvm.c|4553| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);
+ *   - target/i386/kvm/kvm.c|4641| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, env->msr_global_ctrl);
+ *   - target/i386/kvm/kvm.c|5154| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);
+ *   - target/i386/kvm/kvm.c|5483| <<kvm_get_msrs>> case MSR_CORE_PERF_GLOBAL_CTRL:
+ *
+ * 在以下使用MSR_CORE_PERF_GLOBAL_OVF_CTRL:
+ *   - target/i386/cpu.h|494| <<global>> #define MSR_CORE_PERF_GLOBAL_OVF_CTRL 0x390
+ *   - target/i386/kvm/kvm.c|4621| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, env->msr_global_ovf_ctrl);
+ *   - target/i386/kvm/kvm.c|5156| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);
+ *   - target/i386/kvm/kvm.c|5503| <<kvm_get_msrs>> case MSR_CORE_PERF_GLOBAL_OVF_CTRL:
+ */
 #define MSR_CORE_PERF_GLOBAL_STATUS     0x38e
 #define MSR_CORE_PERF_GLOBAL_CTRL       0x38f
 #define MSR_CORE_PERF_GLOBAL_OVF_CTRL   0x390
@@ -1787,12 +1815,61 @@ typedef struct CPUArchState {
     uint64_t msr_ia32_feature_control;
     uint64_t msr_ia32_sgxlepubkeyhash[4];
 
+    /*
+     * 在以下使用CPUX86State->msr_fixed_ctr_ctrl:
+     *   - target/i386/machine.c|674| <<global>> VMSTATE_UINT64(env.msr_fixed_ctr_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4430| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, env->msr_fixed_ctr_ctrl);
+     *   - target/i386/kvm/kvm.c|5234| <<kvm_get_msrs>> env->msr_fixed_ctr_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+     */
     uint64_t msr_fixed_ctr_ctrl;
+    /*
+     * 在以下使用CPUX86State->msr_global_ctrl:
+     *   - target/i386/machine.c|675| <<global>> VMSTATE_UINT64(env.msr_global_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4432| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, env->msr_global_ctrl);
+     *   - target/i386/kvm/kvm.c|5237| <<kvm_get_msrs>> env->msr_global_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+     */
     uint64_t msr_global_ctrl;
+    /*
+     * 在以下使用CPUX86State->msr_global_status:
+     *   - target/i386/machine.c|676| <<global>> VMSTATE_UINT64(env.msr_global_status, X86CPU),
+     *   - target/i386/kvm/kvm.c|4424| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, env->msr_global_status);
+     *   - target/i386/kvm/kvm.c|5240| <<kvm_get_msrs>> env->msr_global_status = msrs[i].data;
+     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+     */
     uint64_t msr_global_status;
+    /*
+     * 在以下使用CPUX86State->msr_global_ovf_ctrl:
+     *   - target/i386/machine.c|677| <<global>> VMSTATE_UINT64(env.msr_global_ovf_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4426| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, env->msr_global_ovf_ctrl);
+     *   - target/i386/kvm/kvm.c|5243| <<kvm_get_msrs>> env->msr_global_ovf_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+     */
     uint64_t msr_global_ovf_ctrl;
+    /*
+     * 在以下使用CPUX86State->msr_fixed_counters[MAX_FIXED_COUNTERS]:
+     *   - target/i386/machine.c|678| <<global>> VMSTATE_UINT64_ARRAY(env.msr_fixed_counters, X86CPU, MAX_FIXED_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4422| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, env->msr_fixed_counters[i]);
+     *   - target/i386/kvm/kvm.c|5270| <<kvm_get_msrs>> env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;
+     *   - target/i386/machine.c|655| <<pmu_enable_needed>> if (env->msr_fixed_counters[i]) {
+     */
     uint64_t msr_fixed_counters[MAX_FIXED_COUNTERS];
+    /*
+     * 在以下使用CPUX86State->msr_gp_counters[MAX_GP_COUNTERS]:
+     *   - target/i386/machine.c|679| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_counters, X86CPU, MAX_GP_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4418| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, env->msr_gp_counters[i]);
+     *   - target/i386/kvm/kvm.c|5249| <<kvm_get_msrs>> env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;
+     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+     */
     uint64_t msr_gp_counters[MAX_GP_COUNTERS];
+    /*
+     * 在以下使用CPUX86State->msr_gp_evtsel[MAX_GP_COUNTERS]:
+     *   - target/i386/machine.c|680| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_evtsel, X86CPU, MAX_GP_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4420| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, env->msr_gp_evtsel[i]);
+     *   - target/i386/kvm/kvm.c|5252| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+     */
     uint64_t msr_gp_evtsel[MAX_GP_COUNTERS];
 
     uint64_t pat;
@@ -1909,6 +1986,18 @@ typedef struct CPUArchState {
     uint32_t cpuid_max_level, cpuid_max_xlevel, cpuid_max_xlevel2;
     /* Actual level/xlevel/xlevel2 value: */
     uint32_t cpuid_level, cpuid_xlevel, cpuid_xlevel2;
+    /*
+     * 在以下使用CPUX86State->cpuid_vendor1:
+     *   - target/i386/cpu.c|5550| <<x86_cpuid_get_vendor>> x86_cpu_vendor_words2str(value, env->cpuid_vendor1, env->cpuid_vendor2,
+     *   - target/i386/cpu.c|5568| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 = 0;
+     *   - target/i386/cpu.c|5572| <<x86_cpuid_set_vendor>> env->cpuid_vendor1 |= ((uint8_t)value[i ]) << (8 * i);
+     *   - target/i386/cpu.c|6451| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+     *   - target/i386/cpu.c|6862| <<cpu_x86_cpuid>> *ebx = env->cpuid_vendor1;
+     *   - target/i386/cpu.c|6877| <<cpu_x86_cpuid>> if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||
+     *   - target/i386/cpu.c|6883| <<cpu_x86_cpuid>> if (tcg_enabled() && env->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 &&
+     *   - target/i386/cpu.h|1051| <<IS_INTEL_CPU>> #define IS_INTEL_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 && \
+     *   - target/i386/cpu.h|1054| <<IS_AMD_CPU>> #define IS_AMD_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_AMD_1 && \
+     */
     uint32_t cpuid_vendor1;
     uint32_t cpuid_vendor2;
     uint32_t cpuid_vendor3;
@@ -2046,6 +2135,14 @@ struct ArchCPU {
     bool expose_tcg;
     bool migratable;
     bool migrate_smi_count;
+    /*
+     * 在以下使用ArchCPU->max_features:
+     *   - target/i386/cpu.c|5843| <<max_x86_cpu_initfn>> cpu->max_features = true;
+     *   - target/i386/cpu.c|8114| <<x86_cpu_expand_features>> if (cpu->max_features) {
+     *   - target/i386/hvf/hvf-cpu.c|70| <<hvf_cpu_instance_init>> if (cpu->max_features) {
+     *   - target/i386/kvm/kvm-cpu.c|89| <<kvm_cpu_realizefn>> if (cpu->max_features) {
+     *   - target/i386/kvm/kvm-cpu.c|250| <<kvm_cpu_instance_init>> if (cpu->max_features) {
+     */
     bool max_features; /* Enable all supported features automatically */
     uint32_t apic_id;
 
@@ -2148,6 +2245,25 @@ struct ArchCPU {
      * paging, guest physical address space might be restricted to 48 bits
      * even if the host cpu supports more physical address bits.
      */
+    /*
+     * 在以下设置ArchCPU->guest_phys_bits:
+     *   - target/i386/cpu.c|8315| <<global>> DEFINE_PROP_UINT32("guest-phys-bits", X86CPU, guest_phys_bits, -1),
+     *   - target/i386/cpu.c|7708| <<x86_cpu_realizefn>> cpu->guest_phys_bits = 0;
+     *   - target/i386/kvm/kvm-cpu.c|30| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = guest_phys_bits;
+     *   - target/i386/kvm/kvm-cpu.c|32| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = cpu->phys_bits;
+     *   - target/i386/kvm/kvm-cpu.c|37| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = cpu->host_phys_bits_limit;
+     * 在以下使用ArchCPU->guest_phys_bits:
+     *   - target/i386/cpu.c|6940| <<cpu_x86_cpuid>> *eax |= (cpu->guest_phys_bits << 16);
+     *   - target/i386/cpu.c|7703| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits == -1) {
+     *   - target/i386/cpu.c|7761| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits &&
+     *   - target/i386/cpu.c|7762| <<x86_cpu_realizefn>> (cpu->guest_phys_bits > cpu->phys_bits ||
+     *   - target/i386/cpu.c|7763| <<x86_cpu_realizefn>> cpu->guest_phys_bits < 32)) {
+     *   - target/i386/cpu.c|7766| <<x86_cpu_realizefn>> cpu->phys_bits, cpu->guest_phys_bits);
+     *   - target/i386/cpu.c|7777| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits != 0) {
+     *   - target/i386/kvm/kvm-cpu.c|31| <<kvm_set_guest_phys_bits>> if (cpu->guest_phys_bits > cpu->phys_bits) {
+     *   - target/i386/kvm/kvm-cpu.c|36| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits > cpu->host_phys_bits_limit) {
+     *   - target/i386/kvm/kvm-cpu.c|89| <<kvm_cpu_realizefn>> if ((env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) && cpu->guest_phys_bits == -1) {
+     */
     uint32_t guest_phys_bits;
 
     /* in order to simplify APIC support, we leave this pointer to the
@@ -2156,6 +2272,32 @@ struct ArchCPU {
     struct MemoryRegion *cpu_as_root, *cpu_as_mem, *smram;
     Notifier machine_done;
 
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     struct kvm_msrs *kvm_msr_buf;
 
     int32_t node_id; /* NUMA node this CPU belongs to */
diff --git a/target/i386/host-cpu.c b/target/i386/host-cpu.c
index 8b8bf5afe..614eff00e 100644
--- a/target/i386/host-cpu.c
+++ b/target/i386/host-cpu.c
@@ -69,6 +69,11 @@ static uint32_t host_cpu_adjust_phys_bits(X86CPU *cpu)
     return phys_bits;
 }
 
+/*
+ * called by:
+ *   - target/i386/hvf/hvf-cpu.c|81| <<hvf_cpu_accel_class_init>> acc->cpu_target_realize = host_cpu_realizefn;
+ *   - target/i386/kvm/kvm-cpu.c|106| <<kvm_cpu_realizefn>> ret = host_cpu_realizefn(cs, errp);
+ */
 bool host_cpu_realizefn(CPUState *cs, Error **errp)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -100,6 +105,10 @@ bool host_cpu_realizefn(CPUState *cs, Error **errp)
  * The function does NOT add a null terminator to the string
  * automatically.
  */
+/*
+ * called by:
+ *   - target/i386/host-cpu.c|167| <<host_cpu_max_instance_init>> host_cpu_fill_model_id(model_id);
+ */
 static int host_cpu_fill_model_id(char *str)
 {
     uint32_t eax = 0, ebx = 0, ecx = 0, edx = 0;
@@ -115,6 +124,12 @@ static int host_cpu_fill_model_id(char *str)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/host-cpu.c|160| <<host_cpu_max_instance_init>> host_cpu_vendor_fms(vendor, &family, &model, &stepping);
+ *   - target/i386/kvm/kvm.c|513| <<host_tsx_broken>> host_cpu_vendor_fms(vendor, &family, &model, &stepping);
+ *   - target/i386/kvm/vmsr_energy.c|86| <<is_host_cpu_intel>> host_cpu_vendor_fms(vendor, &family, &model, &stepping);
+ */
 void host_cpu_vendor_fms(char *vendor, int *family, int *model, int *stepping)
 {
     uint32_t eax, ebx, ecx, edx;
@@ -134,6 +149,11 @@ void host_cpu_vendor_fms(char *vendor, int *family, int *model, int *stepping)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/hvf/hvf-cpu.c|65| <<hvf_cpu_instance_init>> host_cpu_instance_init(cpu);
+ *   - target/i386/kvm/kvm-cpu.c|236| <<kvm_cpu_instance_init>> host_cpu_instance_init(cpu);
+ */
 void host_cpu_instance_init(X86CPU *cpu)
 {
     X86CPUClass *xcc = X86_CPU_GET_CLASS(cpu);
@@ -148,6 +168,11 @@ void host_cpu_instance_init(X86CPU *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/hvf/hvf-cpu.c|24| <<hvf_cpu_max_instance_init>> host_cpu_max_instance_init(cpu);
+ *   - target/i386/kvm/kvm-cpu.c|138| <<kvm_cpu_max_instance_init>> host_cpu_max_instance_init(cpu);
+ */
 void host_cpu_max_instance_init(X86CPU *cpu)
 {
     char vendor[CPUID_VENDOR_SZ + 1] = { 0 };
diff --git a/target/i386/kvm/kvm-cpu.c b/target/i386/kvm/kvm-cpu.c
index 6bf8dcfc6..33f16497c 100644
--- a/target/i386/kvm/kvm-cpu.c
+++ b/target/i386/kvm/kvm-cpu.c
@@ -17,6 +17,10 @@
 #include "kvm_i386.h"
 #include "hw/core/accel-cpu.h"
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm-cpu.c|90| <<kvm_cpu_realizefn>> kvm_set_guest_phys_bits(cs);
+ */
 static void kvm_set_guest_phys_bits(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -27,6 +31,25 @@ static void kvm_set_guest_phys_bits(CPUState *cs)
     if (!guest_phys_bits) {
         return;
     }
+    /*
+     * 在以下设置ArchCPU->guest_phys_bits:
+     *   - target/i386/cpu.c|8315| <<global>> DEFINE_PROP_UINT32("guest-phys-bits", X86CPU, guest_phys_bits, -1),
+     *   - target/i386/cpu.c|7708| <<x86_cpu_realizefn>> cpu->guest_phys_bits = 0;
+     *   - target/i386/kvm/kvm-cpu.c|30| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = guest_phys_bits;
+     *   - target/i386/kvm/kvm-cpu.c|32| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = cpu->phys_bits;
+     *   - target/i386/kvm/kvm-cpu.c|37| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits = cpu->host_phys_bits_limit;
+     * 在以下使用ArchCPU->guest_phys_bits:
+     *   - target/i386/cpu.c|6940| <<cpu_x86_cpuid>> *eax |= (cpu->guest_phys_bits << 16);
+     *   - target/i386/cpu.c|7703| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits == -1) {
+     *   - target/i386/cpu.c|7761| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits &&
+     *   - target/i386/cpu.c|7762| <<x86_cpu_realizefn>> (cpu->guest_phys_bits > cpu->phys_bits ||
+     *   - target/i386/cpu.c|7763| <<x86_cpu_realizefn>> cpu->guest_phys_bits < 32)) {
+     *   - target/i386/cpu.c|7766| <<x86_cpu_realizefn>> cpu->phys_bits, cpu->guest_phys_bits);
+     *   - target/i386/cpu.c|7777| <<x86_cpu_realizefn>> if (cpu->guest_phys_bits != 0) {
+     *   - target/i386/kvm/kvm-cpu.c|31| <<kvm_set_guest_phys_bits>> if (cpu->guest_phys_bits > cpu->phys_bits) {
+     *   - target/i386/kvm/kvm-cpu.c|36| <<kvm_set_guest_phys_bits>> cpu->guest_phys_bits > cpu->host_phys_bits_limit) {
+     *   - target/i386/kvm/kvm-cpu.c|89| <<kvm_cpu_realizefn>> if ((env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) && cpu->guest_phys_bits == -1) {
+     */
     cpu->guest_phys_bits = guest_phys_bits;
     if (cpu->guest_phys_bits > cpu->phys_bits) {
         cpu->guest_phys_bits = cpu->phys_bits;
@@ -63,6 +86,14 @@ static bool kvm_cpu_realizefn(CPUState *cs, Error **errp)
      *   check/update ucode_rev, phys_bits, guest_phys_bits, mwait
      *   cpu_common_realizefn() (via xcc->parent_realize)
      */
+    /*
+     * 在以下使用ArchCPU->max_features:
+     *   - target/i386/cpu.c|5843| <<max_x86_cpu_initfn>> cpu->max_features = true;
+     *   - target/i386/cpu.c|8114| <<x86_cpu_expand_features>> if (cpu->max_features) {
+     *   - target/i386/hvf/hvf-cpu.c|70| <<hvf_cpu_instance_init>> if (cpu->max_features) {
+     *   - target/i386/kvm/kvm-cpu.c|89| <<kvm_cpu_realizefn>> if (cpu->max_features) {
+     *   - target/i386/kvm/kvm-cpu.c|250| <<kvm_cpu_instance_init>> if (cpu->max_features) {
+     */
     if (cpu->max_features) {
         if (enable_cpu_pm) {
             if (kvm_has_waitpkg()) {
@@ -103,6 +134,10 @@ static bool lmce_supported(void)
     return !!(mce_cap & MCG_LMCE_P);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm-cpu.c|247| <<kvm_cpu_instance_init>> kvm_cpu_max_instance_init(cpu);
+ */
 static void kvm_cpu_max_instance_init(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -166,6 +201,11 @@ static void kvm_cpu_xsave_init(void)
  *       by the KVM accelerator (see "OS requirements" section at
  *       docs/system/target-i386.rst)
  */
+/*
+ * 在以下使用kvm_default_props[]:
+ *   - target/i386/kvm/kvm-cpu.c|217| <<x86_cpu_change_kvm_default>> for (pv = kvm_default_props; pv->prop; pv++) {
+ *   - target/i386/kvm/kvm-cpu.c|247| <<kvm_cpu_instance_init>> x86_cpu_apply_props(cpu, kvm_default_props);
+ */
 static PropValue kvm_default_props[] = {
     { "kvmclock", "on" },
     { "kvm-nopiodelay", "on" },
@@ -184,6 +224,11 @@ static PropValue kvm_default_props[] = {
 /*
  * Only for builtin_x86_defs models initialized with x86_register_cpudef_types.
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm-cpu.c|241| <<kvm_cpu_instance_init>> x86_cpu_change_kvm_default("x2apic", "off");
+ *   - target/i386/kvm/kvm-cpu.c|243| <<kvm_cpu_instance_init>> x86_cpu_change_kvm_default("kvm-msi-ext-dest-id", "on");
+ */
 static void x86_cpu_change_kvm_default(const char *prop, const char *value)
 {
     PropValue *pv;
@@ -206,6 +251,11 @@ static void kvm_cpu_instance_init(CPUState *cs)
     X86CPU *cpu = X86_CPU(cs);
     X86CPUClass *xcc = X86_CPU_GET_CLASS(cpu);
 
+    /*
+     * called by:
+     *   - target/i386/hvf/hvf-cpu.c|65| <<hvf_cpu_instance_init>> host_cpu_instance_init(cpu);
+     *   - target/i386/kvm/kvm-cpu.c|236| <<kvm_cpu_instance_init>> host_cpu_instance_init(cpu);
+     */
     host_cpu_instance_init(cpu);
 
     if (xcc->model) {
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 2fa88ef1e..d62e558bc 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -85,6 +85,12 @@
 #define KVM_APIC_BUS_CYCLE_NS       1
 #define KVM_APIC_BUS_FREQUENCY      (1000000000ULL / KVM_APIC_BUS_CYCLE_NS)
 
+/*
+ * 在以下使用MSR_KVM_SYSTEM_TIME:
+ *   - target/i386/kvm/kvm.c|4154| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
+ *   - target/i386/kvm/kvm.c|4634| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);
+ *   - target/i386/kvm/kvm.c|4896| <<kvm_get_msrs>> case MSR_KVM_SYSTEM_TIME:
+ */
 #define MSR_KVM_WALL_CLOCK  0x11
 #define MSR_KVM_SYSTEM_TIME 0x12
 
@@ -94,6 +100,10 @@
 
 static void kvm_init_msrs(X86CPU *cpu);
 
+/*
+ * 在以下使用kvm_arch_required_capabilities[]:
+ *   - accel/kvm/kvm-all.c|2541| <<kvm_init>> kvm_check_extension_list(s, kvm_arch_required_capabilities);
+ */
 const KVMCapabilityInfo kvm_arch_required_capabilities[] = {
     KVM_CAP_INFO(SET_TSS_ADDR),
     KVM_CAP_INFO(EXT_CPUID),
@@ -146,8 +156,73 @@ static bool has_msr_vmx_procbased_ctls2;
 static bool has_msr_perf_capabs;
 static bool has_msr_pkrs;
 
+/*
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ *
+ * 在以下使用has_architectural_pmu_version:
+ *   - target/i386/kvm/kvm.c|2162| <<kvm_x86_build_cpuid>> has_architectural_pmu_version = eax & 0xff;
+ *   - target/i386/kvm/kvm.c|2163| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 0) {
+ *   - target/i386/kvm/kvm.c|2174| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 1) {
+ *   - target/i386/kvm/kvm.c|4316| <<kvm_put_msrs>> if (has_architectural_pmu_version > 0) {
+ *   - target/i386/kvm/kvm.c|4317| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+ *   - target/i386/kvm/kvm.c|4334| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+ *   - target/i386/kvm/kvm.c|4820| <<kvm_get_msrs>> if (has_architectural_pmu_version > 0) {
+ *   - target/i386/kvm/kvm.c|4821| <<kvm_get_msrs>> if (has_architectural_pmu_version > 1) {
+ *
+ * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+ * has_architectural_pmu_version = 0.
+ * num_architectural_pmu_gp_counters = 0.
+ * num_architectural_pmu_fixed_counters = 0.
+ *
+ * 2. 如果guest_vendor是Intel
+ * 完全按照cpuid来算
+ *
+ * 3. 如果guest_vendor是AMD
+ * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+ *      如果支持, 根据0x80000022获取寄存器的数目.
+ *      此外, 3个global的也支持!
+ *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+ * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+ *      就是6个寄存器
+ * 3.3. 默认只支持4个
+ *
+ *
+ * KVM中限制了version.
+ *
+ * 220         kvm_pmu_cap.version = min(kvm_pmu_cap.version, 2);
+ * 221         kvm_pmu_cap.num_counters_gp = min(kvm_pmu_cap.num_counters_gp,
+ * 222                                           pmu_ops->MAX_NR_GP_COUNTERS);
+ * 223         kvm_pmu_cap.num_counters_fixed = min(kvm_pmu_cap.num_counters_fixed,
+ * 224                                              KVM_PMC_MAX_FIXED);
+ */
 static uint32_t has_architectural_pmu_version;
+/*
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ *
+ * 在以下使用num_architectural_pmu_gp_counters:
+ *   - target/i386/kvm/kvm.c|2164| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
+ *   - target/i386/kvm/kvm.c|2170| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+ *   - target/i386/kvm/kvm.c|2171| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+ *   - target/i386/kvm/kvm.c|4328| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+ *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+ */
 static uint32_t num_architectural_pmu_gp_counters;
+/*
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ *
+ * 在以下使用num_architectural_pmu_fixed_counters:
+ *   - target/i386/kvm/kvm.c|2175| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = edx & 0x1f;
+ *   - target/i386/kvm/kvm.c|2177| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
+ *   - target/i386/kvm/kvm.c|2178| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = MAX_FIXED_COUNTERS;
+ *   - target/i386/kvm/kvm.c|4324| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+ *   - target/i386/kvm/kvm.c|4827| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+ */
 static uint32_t num_architectural_pmu_fixed_counters;
 
 static int has_xsave2;
@@ -162,6 +237,18 @@ static struct kvm_cpuid2 *cpuid_cache;
 static struct kvm_cpuid2 *hv_cpuid_cache;
 static struct kvm_msr_list *kvm_feature_msrs;
 
+/*
+ * 在以下使用msr_handlers[KVM_MSR_FILTER_MAX_RANGES]:
+ *   - target/i386/kvm/kvm.c|6026| <<kvm_install_msr_filters>> KVMMSRHandlers *handler = &msr_handlers[i];
+ *   - target/i386/kvm/kvm.c|6060| <<kvm_filter_msr>> for (i = 0; i < ARRAY_SIZE(msr_handlers); i++) {
+ *   - target/i386/kvm/kvm.c|6061| <<kvm_filter_msr>> if (!msr_handlers[i].msr) {
+ *   - target/i386/kvm/kvm.c|6062| <<kvm_filter_msr>> msr_handlers[i] = (KVMMSRHandlers) {
+ *   - target/i386/kvm/kvm.c|6069| <<kvm_filter_msr>> msr_handlers[i] = (KVMMSRHandlers) { };
+ *   - target/i386/kvm/kvm.c|6085| <<kvm_handle_rdmsr>> for (i = 0; i < ARRAY_SIZE(msr_handlers); i++) {
+ *   - target/i386/kvm/kvm.c|6086| <<kvm_handle_rdmsr>> KVMMSRHandlers *handler = &msr_handlers[i];
+ *   - target/i386/kvm/kvm.c|6105| <<kvm_handle_wrmsr>> for (i = 0; i < ARRAY_SIZE(msr_handlers); i++) {
+ *   - target/i386/kvm/kvm.c|6106| <<kvm_handle_wrmsr>> KVMMSRHandlers *handler = &msr_handlers[i];
+ */
 static KVMMSRHandlers msr_handlers[KVM_MSR_FILTER_MAX_RANGES];
 
 #define BUS_LOCK_SLICE_TIME 1000000000ULL /* ns */
@@ -175,6 +262,17 @@ static const char *vm_type_name[] = {
     [KVM_X86_SNP_VM] = "SEV-SNP",
 };
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|213| <<kvm_get_vm_type>> if (!kvm_is_vm_type_supported(kvm_type)) {
+ *   - target/i386/sev.c|1408| <<sev_kvm_type>> if (!kvm_is_vm_type_supported(kvm_type)) {
+ *
+ * #define KVM_X86_DEFAULT_VM      0
+ * #define KVM_X86_SW_PROTECTED_VM 1
+ * #define KVM_X86_SEV_VM          2
+ * #define KVM_X86_SEV_ES_VM       3        
+ * #define KVM_X86_SNP_VM          4
+ */
 bool kvm_is_vm_type_supported(int type)
 {
     uint32_t machine_types;
@@ -192,6 +290,10 @@ bool kvm_is_vm_type_supported(int type)
     return !!(machine_types & BIT(type));
 }
 
+/*
+ * called by:
+ *   - hw/i386/x86.c|357| <<x86_kvm_type>> return kvm_enabled() ? kvm_get_vm_type(ms) : 0;
+ */
 int kvm_get_vm_type(MachineState *ms)
 {
     int kvm_type = KVM_X86_DEFAULT_VM;
@@ -214,6 +316,10 @@ int kvm_get_vm_type(MachineState *ms)
     return kvm_type;
 }
 
+/*
+ * called by:
+ *   - target/i386/sev.c|772| <<sev_snp_launch_start>> if (!kvm_enable_hypercall(BIT_ULL(KVM_HC_MAP_GPA_RANGE))) {
+ */
 bool kvm_enable_hypercall(uint64_t enable_mask)
 {
     KVMState *s = KVM_STATE(current_accel());
@@ -221,11 +327,19 @@ bool kvm_enable_hypercall(uint64_t enable_mask)
     return !kvm_vm_enable_cap(s, KVM_CAP_EXIT_HYPERCALL, 0, enable_mask);
 }
 
+/*
+ * called by:
+ *   - hw/i386/x86.c|177| <<x86_machine_is_smm_enabled>> smm_available = kvm_has_smm();
+ */
 bool kvm_has_smm(void)
 {
     return kvm_vm_check_extension(kvm_state, KVM_CAP_X86_SMM);
 }
 
+/*
+ * called by:
+ *   - hw/i386/kvm/clock.c|152| <<kvm_update_clock>> s->clock_is_reliable = kvm_has_adjust_clock_stable();
+ */
 bool kvm_has_adjust_clock_stable(void)
 {
     int ret = kvm_check_extension(kvm_state, KVM_CAP_ADJUST_CLOCK);
@@ -233,11 +347,19 @@ bool kvm_has_adjust_clock_stable(void)
     return (ret & KVM_CLOCK_TSC_STABLE);
 }
 
+/*
+ * called by:
+ *   - target/i386/machine.c|266| <<cpu_pre_save>> (!kvm_has_exception_payload() && (env->hflags & HF_GUEST_MASK) &&
+ */
 bool kvm_has_exception_payload(void)
 {
     return has_exception_payload;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|269| <<kvm_enable_x2apic>> kvm_x2apic_api_set_flags(KVM_X2APIC_API_USE_32BIT_IDS |
+ */
 static bool kvm_x2apic_api_set_flags(uint64_t flags)
 {
     KVMState *s = KVM_STATE(current_accel());
@@ -245,6 +367,11 @@ static bool kvm_x2apic_api_set_flags(uint64_t flags)
     return !kvm_vm_enable_cap(s, KVM_CAP_X2APIC_API, 0, flags);
 }
 
+/*
+ * 在以下使用MEMORIZE():
+ *   - target/i386/kvm/kvm.c|268| <<kvm_enable_x2apic>> return MEMORIZE(
+ *   - target/i386/kvm/kvm.c|6098| <<kvm_enable_sgx_provisioning>> return MEMORIZE(__kvm_enable_sgx_provisioning(s), has_sgx_provisioning);
+ */
 #define MEMORIZE(fn, _result) \
     ({ \
         static bool _memorized; \
@@ -258,11 +385,21 @@ static bool kvm_x2apic_api_set_flags(uint64_t flags)
 
 static bool has_x2apic_api;
 
+/*
+ * called by:
+ *   - hw/i386/kvm/apic.c|38| <<kvm_put_apic_state>> if (kvm_has_x2apic_api() && s->apicbase & MSR_IA32_APICBASE_EXTD) {
+ *   - hw/i386/kvm/apic.c|67| <<kvm_get_apic_state>> if (kvm_has_x2apic_api() && s->apicbase & MSR_IA32_APICBASE_EXTD) {
+ */
 bool kvm_has_x2apic_api(void)
 {
     return has_x2apic_api;
 }
 
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|4255| <<vtd_decide_config>> if (kvm_irqchip_is_split() && !kvm_enable_x2apic()) {
+ *   - hw/i386/x86-common.c|98| <<x86_cpus_init>> kvm_irqchip_in_kernel() && !kvm_enable_x2apic()) {
+ */
 bool kvm_enable_x2apic(void)
 {
     return MEMORIZE(
@@ -276,6 +413,10 @@ bool kvm_hv_vpindex_settable(void)
     return hv_vpindex_settable;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|303| <<do_kvm_synchronize_tsc>> kvm_get_tsc(cpu);
+ */
 static int kvm_get_tsc(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -298,11 +439,19 @@ static int kvm_get_tsc(CPUState *cs)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|316| <<kvm_synchronize_all_tsc>> run_on_cpu(cpu, do_kvm_synchronize_tsc, RUN_ON_CPU_NULL);
+ */
 static inline void do_kvm_synchronize_tsc(CPUState *cpu, run_on_cpu_data arg)
 {
     kvm_get_tsc(cpu);
 }
 
+/*
+ * called by:
+ *   - hw/i386/kvm/clock.c|210| <<kvmclock_vm_state_change>> kvm_synchronize_all_tsc();
+ */
 void kvm_synchronize_all_tsc(void)
 {
     CPUState *cpu;
@@ -314,6 +463,10 @@ void kvm_synchronize_all_tsc(void)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|353| <<get_supported_cpuid>> while ((cpuid = try_get_cpuid(s, max)) == NULL) {
+ */
 static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 {
     struct kvm_cpuid2 *cpuid;
@@ -342,6 +495,10 @@ static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 /* Run KVM_GET_SUPPORTED_CPUID ioctl(), allocating a buffer large enough
  * for all entries.
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|421| <<kvm_arch_get_supported_cpuid>> cpuid = get_supported_cpuid(s);
+ */
 static struct kvm_cpuid2 *get_supported_cpuid(KVMState *s)
 {
     struct kvm_cpuid2 *cpuid;
@@ -373,6 +530,11 @@ static bool host_tsx_broken(void)
 
 /* Returns the value for a specific register on the cpuid entry
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|425| <<kvm_arch_get_supported_cpuid>> ret = cpuid_entry_get_reg(entry, reg);
+ *   - target/i386/kvm/kvm.c|1291| <<hv_cpuid_get_host>> return cpuid_entry_get_reg(entry, reg);
+ */
 static uint32_t cpuid_entry_get_reg(struct kvm_cpuid_entry2 *entry, int reg)
 {
     uint32_t ret = 0;
@@ -395,6 +557,14 @@ static uint32_t cpuid_entry_get_reg(struct kvm_cpuid_entry2 *entry, int reg)
 
 /* Find matching entry for function/index on kvm_cpuid2 struct
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|423| <<kvm_arch_get_supported_cpuid>> struct kvm_cpuid_entry2 *entry = cpuid_find_entry(cpuid, function, index);
+ *   - target/i386/kvm/kvm.c|1286| <<hv_cpuid_get_host>> entry = cpuid_find_entry(cpuid, func, 0);
+ *   - target/i386/kvm/kvm.c|2245| <<kvm_arch_init_vcpu>> c = cpuid_find_entry(&cpuid_data.cpuid, 1, 0);
+ *   - target/i386/kvm/kvm.c|2251| <<kvm_arch_init_vcpu>> c = cpuid_find_entry(&cpuid_data.cpuid, 7, 0);
+ *   - target/i386/kvm/kvm.c|2288| <<kvm_arch_init_vcpu>> c = cpuid_find_entry(&cpuid_data.cpuid, kvm_base, 0);
+ */
 static struct kvm_cpuid_entry2 *cpuid_find_entry(struct kvm_cpuid2 *cpuid,
                                                  uint32_t function,
                                                  uint32_t index)
@@ -410,6 +580,29 @@ static struct kvm_cpuid_entry2 *cpuid_find_entry(struct kvm_cpuid2 *cpuid,
     return NULL;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|6063| <<x86_cpu_get_supported_feature_word>> r = kvm_arch_get_supported_cpuid(kvm_state, wi->cpuid.eax,
+ *   - target/i386/cpu.c|6137| <<x86_cpu_get_supported_cpuid>> *eax = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_EAX);
+ *   - target/i386/cpu.c|6138| <<x86_cpu_get_supported_cpuid>> *ebx = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_EBX);
+ *   - target/i386/cpu.c|6139| <<x86_cpu_get_supported_cpuid>> *ecx = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_ECX);
+ *   - target/i386/cpu.c|6140| <<x86_cpu_get_supported_cpuid>> *edx = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_EDX);
+ *   - target/i386/kvm/kvm-cpu.c|25| <<kvm_set_guest_phys_bits>> eax = kvm_arch_get_supported_cpuid(cs->kvm_state, 0x80000008, 0, R_EAX);
+ *   - target/i386/kvm/kvm-cpu.c|118| <<kvm_cpu_max_instance_init>> kvm_arch_get_supported_cpuid(s, 0x0, 0, R_EAX);
+ *   - target/i386/kvm/kvm-cpu.c|120| <<kvm_cpu_max_instance_init>> kvm_arch_get_supported_cpuid(s, 0x80000000, 0, R_EAX);
+ *   - target/i386/kvm/kvm-cpu.c|122| <<kvm_cpu_max_instance_init>> kvm_arch_get_supported_cpuid(s, 0xC0000000, 0, R_EAX);
+ *   - target/i386/kvm/kvm.c|537| <<kvm_arch_get_supported_cpuid>> cpuid_1_edx = kvm_arch_get_supported_cpuid(s, 1, 0, R_EDX);
+ *   - target/i386/kvm/kvm.c|601| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 0xD, 1, R_ECX) &
+ *   - target/i386/kvm/kvm.c|605| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 1, 0, R_ECX) &
+ *   - target/i386/kvm/kvm.c|609| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 7, 0, R_EBX) &
+ *   - target/i386/kvm/kvm.c|613| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 7, 0, R_EBX) &
+ *   - target/i386/kvm/kvm.c|617| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 0x80000001, 0, R_EDX) &
+ *   - target/i386/kvm/kvm.c|1771| <<kvm_init_xsave>> assert(kvm_arch_get_supported_cpuid(kvm_state, 0xd, 0, R_ECX) <=
+ *   - target/i386/kvm/kvm.c|4014| <<kvm_put_msrs>> int addr_num = kvm_arch_get_supported_cpuid(kvm_state,
+ *   - target/i386/kvm/kvm.c|4441| <<kvm_get_msrs>> kvm_arch_get_supported_cpuid(kvm_state, 0x14, 1, R_EAX) & 0x7;
+ *   - target/i386/kvm/kvm.c|6239| <<kvm_request_xsave_components>> supported = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);
+ *   - target/i386/kvm/kvm.c|6240| <<kvm_request_xsave_components>> supported |= (uint64_t)kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX) << 32;
+ */
 uint32_t kvm_arch_get_supported_cpuid(KVMState *s, uint32_t function,
                                       uint32_t index, int reg)
 {
@@ -560,6 +753,15 @@ uint32_t kvm_arch_get_supported_cpuid(KVMState *s, uint32_t function,
     return ret;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|6068| <<x86_cpu_get_supported_feature_word>> r = kvm_arch_get_supported_msr_feature(kvm_state,
+ *   - target/i386/kvm/kvm-cpu.c|79| <<kvm_cpu_realizefn>> kvm_arch_get_supported_msr_feature(kvm_state,
+ *   - target/i386/kvm/kvm.c|3610| <<kvm_msr_entry_add_vmx>> kvm_arch_get_supported_msr_feature(kvm_state,
+ *   - target/i386/kvm/kvm.c|3621| <<kvm_msr_entry_add_vmx>> kvm_arch_get_supported_msr_feature(kvm_state,
+ *   - target/i386/kvm/kvm.c|3624| <<kvm_msr_entry_add_vmx>> kvm_arch_get_supported_msr_feature(kvm_state,
+ *   - target/i386/kvm/kvm.c|3709| <<kvm_msr_entry_add_perf>> kvm_arch_get_supported_msr_feature(kvm_state,
+ */
 uint64_t kvm_arch_get_supported_msr_feature(KVMState *s, uint32_t index)
 {
     struct {
@@ -645,6 +847,10 @@ static int kvm_get_mce_cap_supported(KVMState *s, uint64_t *mce_cap,
     return kvm_ioctl(s, KVM_X86_GET_MCE_CAP_SUPPORTED, mce_cap);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|736| <<kvm_arch_on_sigbus_vcpu>> kvm_mce_inject(cpu, paddr, code);
+ */
 static void kvm_mce_inject(X86CPU *cpu, hwaddr paddr, int code)
 {
     CPUState *cs = CPU(cpu);
@@ -714,6 +920,11 @@ static void hardware_memory_error(void *host_addr)
     exit(1);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|3032| <<kvm_cpu_exec>> kvm_arch_on_sigbus_vcpu(cpu, pending_sigbus_code,
+ *   - accel/kvm/kvm-all.c|3570| <<kvm_on_sigbus>> kvm_arch_on_sigbus_vcpu(first_cpu, code, addr);
+ */
 void kvm_arch_on_sigbus_vcpu(CPUState *c, int code, void *addr)
 {
     X86CPU *cpu = X86_CPU(c);
@@ -768,6 +979,11 @@ void kvm_arch_on_sigbus_vcpu(CPUState *c, int code, void *addr)
     emit_hypervisor_memory_failure(MEMORY_FAILURE_ACTION_IGNORE, false);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|5436| <<kvm_arch_process_async_events>> kvm_queue_exception(env, EXCP12_MCHK, 0, 0);
+ *   - target/i386/kvm/kvm.c|5657| <<kvm_handle_debug>> kvm_queue_exception(env, arch_info->exception,
+ */
 static void kvm_queue_exception(CPUX86State *env,
                                 int32_t exception_nr,
                                 uint8_t exception_has_payload,
@@ -809,6 +1025,29 @@ static void cpu_update_state(void *opaque, bool running, RunState state)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|347| <<kvm_park_vcpu>> trace_kvm_park_vcpu(cpu->cpu_index, kvm_arch_vcpu_id(cpu));
+ *   - accel/kvm/kvm-all.c|350| <<kvm_park_vcpu>> vcpu->vcpu_id = kvm_arch_vcpu_id(cpu);
+ *   - accel/kvm/kvm-all.c|376| <<kvm_create_vcpu>> unsigned long vcpu_id = kvm_arch_vcpu_id(cpu);
+ *   - accel/kvm/kvm-all.c|420| <<do_kvm_destroy_vcpu>> trace_kvm_destroy_vcpu(cpu->cpu_index, kvm_arch_vcpu_id(cpu));
+ *   - accel/kvm/kvm-all.c|465| <<kvm_init_vcpu>> trace_kvm_init_vcpu(cpu->cpu_index, kvm_arch_vcpu_id(cpu));
+ *   - accel/kvm/kvm-all.c|471| <<kvm_init_vcpu>> kvm_arch_vcpu_id(cpu));
+ *   - accel/kvm/kvm-all.c|489| <<kvm_init_vcpu>> kvm_arch_vcpu_id(cpu));
+ *   - accel/kvm/kvm-all.c|514| <<kvm_init_vcpu>> kvm_arch_vcpu_id(cpu));
+ *   - hw/i386/kvm/xen_evtchn.c|563| <<assign_kernel_port>> ha.u.evtchn.deliver.port.vcpu = kvm_arch_vcpu_id(cpu);
+ *   - hw/i386/kvm/xen_evtchn.c|925| <<set_port_pending>> evt.vcpu = kvm_arch_vcpu_id(cpu);
+ *   - hw/i386/kvm/xen_evtchn.c|1784| <<xen_evtchn_translate_pirq_msi>> route->u.xen_evtchn.vcpu = kvm_arch_vcpu_id(cpu);
+ *   - hw/intc/openpic_kvm.c|262| <<kvm_openpic_connect_vcpu>> kvm_arch_vcpu_id(cs));
+ *   - hw/intc/spapr_xive_kvm.c|43| <<kvm_cpu_is_enabled>> unsigned long vcpu_id = kvm_arch_vcpu_id(cs);
+ *   - hw/intc/spapr_xive_kvm.c|56| <<kvm_cpu_enable>> unsigned long vcpu_id = kvm_arch_vcpu_id(cs);
+ *   - hw/intc/spapr_xive_kvm.c|92| <<kvmppc_xive_cpu_set_state>> kvm_arch_vcpu_id(tctx->cs));
+ *   - hw/intc/spapr_xive_kvm.c|111| <<kvmppc_xive_cpu_get_state>> kvm_arch_vcpu_id(tctx->cs));
+ *   - hw/intc/spapr_xive_kvm.c|165| <<kvmppc_xive_cpu_connect>> vcpu_id = kvm_arch_vcpu_id(tctx->cs);
+ *   - hw/intc/xics_kvm.c|83| <<icp_get_kvm_state>> " for CPU %ld: %s", kvm_arch_vcpu_id(icp->cs), strerror(errno));
+ *   - hw/intc/xics_kvm.c|130| <<icp_set_kvm_state>> kvm_arch_vcpu_id(icp->cs));
+ *   - hw/intc/xics_kvm.c|151| <<icp_kvm_realize>> vcpu_id = kvm_arch_vcpu_id(cs);
+ */
 unsigned long kvm_arch_vcpu_id(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -842,6 +1081,11 @@ static inline bool freq_within_bounds(int freq, int target_freq)
         return false;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2054| <<kvm_arch_init_vcpu>> r = kvm_arch_set_tsc_khz(cs);
+ *   - target/i386/kvm/kvm.c|5158| <<kvm_arch_put_registers>> kvm_arch_set_tsc_khz(cpu);
+ */
 static int kvm_arch_set_tsc_khz(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -894,6 +1138,11 @@ static int kvm_arch_set_tsc_khz(CPUState *cs)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2135| <<kvm_arch_init_vcpu>> c->eax = ((!!tsc_is_stable_and_known(env) << 1) |
+ *   - target/i386/kvm/kvm.c|2280| <<kvm_arch_init_vcpu>> && tsc_is_stable_and_known(env)) {
+ */
 static bool tsc_is_stable_and_known(CPUX86State *env)
 {
     if (!env->tsc_khz) {
@@ -905,6 +1154,28 @@ static bool tsc_is_stable_and_known(CPUX86State *env)
 
 #define DEFAULT_EVMCS_VERSION ((1 << 8) | 1)
 
+/*
+ * 在以下使用kvm_hyperv_properties[]:
+ *   - target/i386/kvm/kvm.c|916| <<global>> } kvm_hyperv_properties[] = {
+ *   - target/i386/kvm/kvm.c|1299| <<hyperv_feature_supported>> for (i = 0; i < ARRAY_SIZE(kvm_hyperv_properties[feature].flags); i++) {
+ *   - target/i386/kvm/kvm.c|1301| <<hyperv_feature_supported>> func = kvm_hyperv_properties[feature].flags[i].func;
+ *   - target/i386/kvm/kvm.c|1302| <<hyperv_feature_supported>> reg = kvm_hyperv_properties[feature].flags[i].reg;
+ *   - target/i386/kvm/kvm.c|1303| <<hyperv_feature_supported>> bits = kvm_hyperv_properties[feature].flags[i].bits;
+ *   - target/i386/kvm/kvm.c|1323| <<hv_feature_check_deps>> deps = kvm_hyperv_properties[feature].dependencies;
+ *   - target/i386/kvm/kvm.c|1328| <<hv_feature_check_deps>> kvm_hyperv_properties[feature].desc,
+ *   - target/i386/kvm/kvm.c|1329| <<hv_feature_check_deps>> kvm_hyperv_properties[dep_feat].desc);
+ *   - target/i386/kvm/kvm.c|1344| <<hv_build_cpuid_leaf>> for (i = 0; i < ARRAY_SIZE(kvm_hyperv_properties); i++) {
+ *   - target/i386/kvm/kvm.c|1349| <<hv_build_cpuid_leaf>> for (j = 0; j < ARRAY_SIZE(kvm_hyperv_properties[i].flags); j++) {
+ *   -  target/i386/kvm/kvm.c|1350| <<hv_build_cpuid_leaf>> if (kvm_hyperv_properties[i].flags[j].func != func) {
+ *   - target/i386/kvm/kvm.c|1353| <<hv_build_cpuid_leaf>> if (kvm_hyperv_properties[i].flags[j].reg != reg) {
+ *   - target/i386/kvm/kvm.c|1357| <<hv_build_cpuid_leaf>> r |= kvm_hyperv_properties[i].flags[j].bits;
+ *   - target/i386/kvm/kvm.c|1447| <<kvm_hyperv_expand_features>> for (feat = 0; feat < ARRAY_SIZE(kvm_hyperv_properties); feat++) {
+ *   - target/i386/kvm/kvm.c|1454| <<kvm_hyperv_expand_features>> for (feat = 0; feat < ARRAY_SIZE(kvm_hyperv_properties); feat++) {
+ *   - target/i386/kvm/kvm.c|1463| <<kvm_hyperv_expand_features>> kvm_hyperv_properties[feat].desc);
+ *   - target/i386/kvm/kvm.c|1480| <<kvm_hyperv_expand_features>> kvm_hyperv_properties[HYPERV_FEAT_SYNIC].desc,
+ *   - target/i386/kvm/kvm.c|1481| <<kvm_hyperv_expand_features>> kvm_hyperv_properties[HYPERV_FEAT_VPINDEX].desc);
+ *   - target/i386/kvm/kvm.c|1721| <<hyperv_init_vcpu>> kvm_hyperv_properties[HYPERV_FEAT_EVMCS].desc);
+ */
 static struct {
     const char *desc;
     struct {
@@ -1160,6 +1431,10 @@ static struct kvm_cpuid2 *get_supported_hv_cpuid(CPUState *cs)
  * When KVM_GET_SUPPORTED_HV_CPUID is not supported we fill CPUID feature
  * leaves from KVM_CAP_HYPERV* and present MSRs data.
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|1277| <<hv_cpuid_get_host>> cpuid = get_supported_hv_cpuid_legacy(cs);
+ */
 static struct kvm_cpuid2 *get_supported_hv_cpuid_legacy(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -1633,6 +1908,10 @@ static bool evmcs_version_supported(uint16_t evmcs_version,
         (max_version <= max_supported_version);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2089| <<kvm_arch_init_vcpu>> r = hyperv_init_vcpu(cpu);
+ */
 static int hyperv_init_vcpu(X86CPU *cpu)
 {
     CPUState *cs = CPU(cpu);
@@ -1754,6 +2033,10 @@ static Error *invtsc_mig_blocker;
 
 #define KVM_MAX_CPUID_ENTRIES  100
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2299| <<kvm_arch_init_vcpu>> kvm_init_xsave(env);
+ */
 static void kvm_init_xsave(CPUX86State *env)
 {
     if (has_xsave2) {
@@ -1772,6 +2055,11 @@ static void kvm_init_xsave(CPUX86State *env)
            env->xsave_buf_len);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2309| <<kvm_arch_init_vcpu>> kvm_init_nested_state(env);
+ *   - target/i386/kvm/kvm.c|2362| <<kvm_arch_reset_vcpu>> kvm_init_nested_state(env);
+ */
 static void kvm_init_nested_state(CPUX86State *env)
 {
     struct kvm_vmx_nested_state_hdr *vmx_hdr;
@@ -1796,6 +2084,14 @@ static void kvm_init_nested_state(CPUX86State *env)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2203| <<kvm_arch_init_vcpu>> cpuid_i = kvm_x86_build_cpuid(env, cpuid_data.entries, cpuid_i);
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
 static uint32_t kvm_x86_build_cpuid(CPUX86State *env,
                                     struct kvm_cpuid_entry2 *entries,
                                     uint32_t cpuid_i)
@@ -1804,6 +2100,29 @@ static uint32_t kvm_x86_build_cpuid(CPUX86State *env,
     uint32_t unused;
     struct kvm_cpuid_entry2 *c;
 
+    /*
+     * called by:
+     *   - hw/i386/fw_cfg.c|183| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 1, 0, &unused, &unused, &ecx, &edx);
+     *   - hw/i386/fw_cfg.c|195| <<fw_cfg_build_feature_control>> cpu_x86_cpuid(env, 0x7, 0, &unused, &ebx, &ecx, &unused);
+     *   - target/i386/hvf/hvf.c|404| <<hvf_cpu_x86_cpuid>> cpu_x86_cpuid(env, index, count, eax, ebx, ecx, edx);
+     *   - target/i386/kvm/kvm.c|2061| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0, 0, &limit, &unused, &unused, &unused);
+     *   - target/i386/kvm/kvm.c|2077| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2087| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2108| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2133| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2154| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2165| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2172| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2187| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0x0a, 0, &eax, &unused, &unused, &edx);
+     *   - target/i386/kvm/kvm.c|2211| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0x80000000, 0, &limit, &unused, &unused, &unused);
+     *   - target/i386/kvm/kvm.c|2227| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, j, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2241| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/kvm/kvm.c|2255| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, 0xC0000000, 0, &limit, &unused, &unused, &unused);
+     *   - target/i386/kvm/kvm.c|2266| <<kvm_x86_build_cpuid>> cpu_x86_cpuid(env, i, 0, &c->eax, &c->ebx, &c->ecx, &c->edx);
+     *   - target/i386/tcg/fpu_helper.c|3151| <<helper_xsetbv>> cpu_x86_cpuid(env, 0x0d, 0, &ena_lo, &dummy, &dummy, &ena_hi);
+     *   - target/i386/tcg/misc_helper.c|56| <<helper_cpuid>> cpu_x86_cpuid(env, (uint32_t)env->regs[R_EAX], (uint32_t)env->regs[R_ECX],
+     *   - target/i386/whpx/whpx-all.c|1946| <<whpx_vcpu_run>> cpu_x86_cpuid(env, cpuid_fn, 0, (UINT32 *)&rax, (UINT32 *)&rbx,
+     */
     cpu_x86_cpuid(env, 0, 0, &limit, &unused, &unused, &unused);
 
     for (i = 0; i <= limit; i++) {
@@ -1930,12 +2249,49 @@ static uint32_t kvm_x86_build_cpuid(CPUX86State *env,
     if (limit >= 0x0a) {
         uint32_t eax, edx;
 
+        /*
+         * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+	 * has_architectural_pmu_version = 0.
+	 * num_architectural_pmu_gp_counters = 0.
+	 * num_architectural_pmu_fixed_counters = 0.
+	 *
+	 * 2. 如果guest_vendor是Intel
+	 * 完全按照cpuid来算
+	 *
+	 * 3. 如果guest_vendor是AMD
+	 * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+	 *      如果支持, 根据0x80000022获取寄存器的数目.
+	 *      此外, 3个global的也支持!
+	 *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+	 * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+	 *      就是6个寄存器
+	 * 3.3. 默认只支持4个
+	 */
         cpu_x86_cpuid(env, 0x0a, 0, &eax, &unused, &unused, &edx);
 
+        /*
+	 * 在以下使用has_architectural_pmu_version:
+	 *   - target/i386/kvm/kvm.c|2162| <<kvm_x86_build_cpuid>> has_architectural_pmu_version = eax & 0xff;
+	 *   - target/i386/kvm/kvm.c|2163| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|2174| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4316| <<kvm_put_msrs>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|4317| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4334| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4820| <<kvm_get_msrs>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|4821| <<kvm_get_msrs>> if (has_architectural_pmu_version > 1) {
+	 */
         has_architectural_pmu_version = eax & 0xff;
         if (has_architectural_pmu_version > 0) {
             num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
 
+            /*
+	     * 在以下使用num_architectural_pmu_gp_counters:
+	     *   - target/i386/kvm/kvm.c|2164| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
+	     *   - target/i386/kvm/kvm.c|2170| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+	     *   - target/i386/kvm/kvm.c|2171| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+	     *   - target/i386/kvm/kvm.c|4328| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	     */
             /* Shouldn't be more than 32, since that's the number of bits
              * available in EBX to tell us _which_ counters are available.
              * Play it safe.
@@ -1945,6 +2301,14 @@ static uint32_t kvm_x86_build_cpuid(CPUX86State *env,
             }
 
             if (has_architectural_pmu_version > 1) {
+                /*
+		 * 在以下使用num_architectural_pmu_fixed_counters:
+		 *   - target/i386/kvm/kvm.c|2175| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = edx & 0x1f;
+		 *   - target/i386/kvm/kvm.c|2177| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
+		 *   - target/i386/kvm/kvm.c|2178| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = MAX_FIXED_COUNTERS;
+		 *   - target/i386/kvm/kvm.c|4324| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+		 *   - target/i386/kvm/kvm.c|4827| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+		 */
                 num_architectural_pmu_fixed_counters = edx & 0x1f;
 
                 if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
@@ -2021,6 +2385,32 @@ full:
     abort();
 }
 
+/*
+ * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+ * has_architectural_pmu_version = 0.
+ * num_architectural_pmu_gp_counters = 0.
+ * num_architectural_pmu_fixed_counters = 0.
+ *
+ * 2. 如果guest_vendor是Intel
+ * 完全按照cpuid来算
+ *
+ * 3. 如果guest_vendor是AMD
+ * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+ *      如果支持, 根据0x80000022获取寄存器的数目.
+ *      此外, 3个global的也支持!
+ *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+ * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+ *      就是6个寄存器
+ * 3.3. 默认只支持4个
+ *
+ *
+ * called by:
+ *   - accel/kvm/kvm-all.c|510| <<kvm_init_vcpu>> ret = kvm_arch_init_vcpu(cpu);
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
 int kvm_arch_init_vcpu(CPUState *cs)
 {
     struct {
@@ -2200,6 +2590,30 @@ int kvm_arch_init_vcpu(CPUState *cs)
         }
     }
 
+    /*
+     * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+     * has_architectural_pmu_version = 0.
+     * num_architectural_pmu_gp_counters = 0.
+     * num_architectural_pmu_fixed_counters = 0.
+     *
+     * 2. 如果guest_vendor是Intel
+     * 完全按照cpuid来算
+     *
+     * 3. 如果guest_vendor是AMD
+     * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+     *      如果支持, 根据0x80000022获取寄存器的数目.
+     *      此外, 3个global的也支持!
+     *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+     * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+     *      就是6个寄存器
+     * 3.3. 默认只支持4个
+     *
+     * 查看:
+     *
+     * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+     *
+     * 只在此处调用
+     */
     cpuid_i = kvm_x86_build_cpuid(env, cpuid_data.entries, cpuid_i);
     cpuid_data.cpuid.nent = cpuid_i;
 
@@ -2292,6 +2706,12 @@ int kvm_arch_init_vcpu(CPUState *cs)
     cpuid_data.cpuid.nent = cpuid_i;
 
     cpuid_data.cpuid.padding = 0;
+    /*
+     * struct {
+     *     struct kvm_cpuid2 cpuid;
+     *     struct kvm_cpuid_entry2 entries[KVM_MAX_CPUID_ENTRIES];
+     * } cpuid_data;
+     */
     r = kvm_vcpu_ioctl(cs, KVM_SET_CPUID2, &cpuid_data);
     if (r) {
         goto fail;
@@ -2310,12 +2730,41 @@ int kvm_arch_init_vcpu(CPUState *cs)
         }
     }
 
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
 
     if (!(env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_RDTSCP)) {
         has_msr_tsc_aux = false;
     }
 
+    /*
+     * 只在此处调用
+     */
     kvm_init_msrs(cpu);
 
     return 0;
@@ -2326,6 +2775,10 @@ int kvm_arch_init_vcpu(CPUState *cs)
     return r;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|422| <<do_kvm_destroy_vcpu>> ret = kvm_arch_destroy_vcpu(cpu);
+ */
 int kvm_arch_destroy_vcpu(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -2344,6 +2797,10 @@ int kvm_arch_destroy_vcpu(CPUState *cs)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|7217| <<x86_cpu_reset_hold>> kvm_arch_reset_vcpu(cpu);
+ */
 void kvm_arch_reset_vcpu(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -2364,6 +2821,10 @@ void kvm_arch_reset_vcpu(X86CPU *cpu)
     sev_es_set_reset_vector(CPU(cpu));
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|7231| <<x86_cpu_after_reset>> kvm_arch_after_reset_vcpu(cpu);
+ */
 void kvm_arch_after_reset_vcpu(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -2382,6 +2843,10 @@ void kvm_arch_after_reset_vcpu(X86CPU *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/helper.c|609| <<do_cpu_init>> kvm_arch_do_init_vcpu(cpu);
+ */
 void kvm_arch_do_init_vcpu(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -2392,6 +2857,10 @@ void kvm_arch_do_init_vcpu(X86CPU *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3074| <<kvm_arch_init>> kvm_get_supported_feature_msrs(s);
+ */
 static int kvm_get_supported_feature_msrs(KVMState *s)
 {
     int ret = 0;
@@ -2432,6 +2901,10 @@ static int kvm_get_supported_feature_msrs(KVMState *s)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3069| <<kvm_arch_init>> ret = kvm_get_supported_msrs(s);
+ */
 static int kvm_get_supported_msrs(KVMState *s)
 {
     int ret = 0;
@@ -2563,6 +3036,10 @@ static int kvm_get_supported_msrs(KVMState *s)
     return ret;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3187| <<kvm_arch_init>> r = kvm_filter_msr(s, MSR_CORE_THREAD_COUNT, kvm_rdmsr_core_thread_count, NULL);
+ */
 static bool kvm_rdmsr_core_thread_count(X86CPU *cpu,
                                         uint32_t msr,
                                         uint64_t *val)
@@ -2656,6 +3133,11 @@ static void register_smram_listener(Notifier *n, void *unused)
                                  &smram_address_space, 1, "kvm-smram");
 }
 
+/*
+ * 在以下使用kvm_msr_energy_thread():
+ *   - target/i386/kvm/kvm.c|2987| <<kvm_msr_energy_thread_init>> qemu_thread_create(&r->msr_thr, "kvm-msr",
+ *                  kvm_msr_energy_thread, s, QEMU_THREAD_JOINABLE);
+ */
 static void *kvm_msr_energy_thread(void *data)
 {
     KVMState *s = data;
@@ -2885,6 +3367,10 @@ clean:
     return NULL;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3229| <<kvm_arch_init>> r = kvm_msr_energy_thread_init(s, ms);
+ */
 static int kvm_msr_energy_thread_init(KVMState *s, MachineState *ms)
 {
     MachineClass *mc = MACHINE_GET_CLASS(ms);
@@ -2990,11 +3476,19 @@ out:
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2478| <<kvm_init>> type = kvm_arch_get_default_type(ms);
+ */
 int kvm_arch_get_default_type(MachineState *ms)
 {
     return 0;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2635| <<kvm_init>> ret = kvm_arch_init(ms, s);
+ */
 int kvm_arch_init(MachineState *ms, KVMState *s)
 {
     uint64_t identity_base = 0xfffbc000;
@@ -3469,13 +3963,95 @@ static int kvm_put_sregs2(X86CPU *cpu)
 }
 
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3493| <<kvm_put_one_msr>> kvm_msr_buf_reset(cpu);
+ *   - target/i386/kvm/kvm.c|3739| <<kvm_init_msrs>> kvm_msr_buf_reset(cpu);
+ *   - target/i386/kvm/kvm.c|3774| <<kvm_put_msrs>> kvm_msr_buf_reset(cpu);
+ *   - target/i386/kvm/kvm.c|4248| <<kvm_get_msrs>> kvm_msr_buf_reset(cpu);
+ */
 static void kvm_msr_buf_reset(X86CPU *cpu)
 {
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
 }
 
+/*
+ * 特别多的调用:
+ *   - target/i386/kvm/kvm.c|3494| <<kvm_put_one_msr>> kvm_msr_entry_add(cpu, index, value);
+ *   - target/i386/kvm/kvm.c|3663| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_TRUE_PROCBASED_CTLS,
+ *   - target/i386/kvm/kvm.c|3666| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_TRUE_PINBASED_CTLS,
+ *   - target/i386/kvm/kvm.c|3669| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_TRUE_EXIT_CTLS,
+ *   - target/i386/kvm/kvm.c|3672| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_TRUE_ENTRY_CTLS,
+ *   - target/i386/kvm/kvm.c|3675| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_PROCBASED_CTLS2,
+ *   - target/i386/kvm/kvm.c|3678| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_EPT_VPID_CAP,
+ *   - target/i386/kvm/kvm.c|3680| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_BASIC,
+ *   - target/i386/kvm/kvm.c|3682| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_MISC,
+ *   - target/i386/kvm/kvm.c|3685| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_VMFUNC, f[FEAT_VMX_VMFUNC]);
+ *   - target/i386/kvm/kvm.c|3692| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_CR0_FIXED0,
+ *   - target/i386/kvm/kvm.c|3694| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_CR4_FIXED0,
+ *   - target/i386/kvm/kvm.c|3699| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_VMCS_ENUM, 0x32);
+ *   - target/i386/kvm/kvm.c|3702| <<kvm_msr_entry_add_vmx>> kvm_msr_entry_add(cpu, MSR_IA32_VMX_VMCS_ENUM, 0x2E);
+ *   - target/i386/kvm/kvm.c|3713| <<kvm_msr_entry_add_perf>> kvm_msr_entry_add(cpu, MSR_IA32_PERF_CAPABILITIES,
+ *   - target/i386/kvm/kvm.c|3741| <<kvm_init_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_ARCH_CAPABILITIES,
+ *   - target/i386/kvm/kvm.c|3746| <<kvm_init_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_CORE_CAPABILITY,
+ *   - target/i386/kvm/kvm.c|3755| <<kvm_init_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_UCODE_REV, cpu->ucode_rev);
+ *   - 特别特别多的kvm_put_msrs()
+ *   - 特别特别多的kvm_get_msrs()
+ */
 static void kvm_msr_entry_add(X86CPU *cpu, uint32_t index, uint64_t value)
 {
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     struct kvm_msrs *msrs = cpu->kvm_msr_buf;
     void *limit = ((void *)msrs) + MSR_BUF_SIZE;
     struct kvm_msr_entry *entry = &msrs->entries[msrs->nmsrs];
@@ -3488,6 +4064,12 @@ static void kvm_msr_entry_add(X86CPU *cpu, uint32_t index, uint64_t value)
     msrs->nmsrs++;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3522| <<kvm_put_apicbase>> ret = kvm_put_one_msr(cpu, MSR_IA32_APICBASE, value);
+ *   - target/i386/kvm/kvm.c|3535| <<kvm_put_tscdeadline_msr>> ret = kvm_put_one_msr(cpu, MSR_IA32_TSCDEADLINE, env->tsc_deadline);
+ *   - target/i386/kvm/kvm.c|3558| <<kvm_put_msr_feature_control>> ret = kvm_put_one_msr(cpu, MSR_IA32_FEATURE_CONTROL,
+ */
 static int kvm_put_one_msr(X86CPU *cpu, int index, uint64_t value)
 {
     kvm_msr_buf_reset(cpu);
@@ -3604,6 +4186,10 @@ static uint64_t make_vmx_msr_value(uint32_t index, uint32_t features)
     return must_be_one | (((uint64_t)can_be_one) << 32);
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3763| <<kvm_init_msrs>> kvm_msr_entry_add_vmx(cpu, env->features);
+ */
 static void kvm_msr_entry_add_vmx(X86CPU *cpu, FeatureWordArray f)
 {
     uint64_t kvm_vmx_basic =
@@ -3703,6 +4289,10 @@ static void kvm_msr_entry_add_vmx(X86CPU *cpu, FeatureWordArray f)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3751| <<kvm_init_msrs>> kvm_msr_entry_add_perf(cpu, env->features);
+ */
 static void kvm_msr_entry_add_perf(X86CPU *cpu, FeatureWordArray f)
 {
     uint64_t kvm_perf_cap =
@@ -3715,8 +4305,39 @@ static void kvm_msr_entry_add_perf(X86CPU *cpu, FeatureWordArray f)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|3766| <<kvm_init_msrs>> assert(kvm_buf_set_msrs(cpu) == 0);
+ *   - target/i386/kvm/kvm.c|4097| <<kvm_put_msrs>> return kvm_buf_set_msrs(cpu);
+ */
 static int kvm_buf_set_msrs(X86CPU *cpu)
 {
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
     if (ret < 0) {
         return ret;
@@ -3732,6 +4353,10 @@ static int kvm_buf_set_msrs(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2319| <<kvm_arch_init_vcpu>> kvm_init_msrs(cpu);
+ */
 static void kvm_init_msrs(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -3766,6 +4391,52 @@ static void kvm_init_msrs(X86CPU *cpu)
     assert(kvm_buf_set_msrs(cpu) == 0);
 }
 
+/*
+ * system_reset的时候, 假设4个vCPU, 先为每个vCPU各调用一次
+ * 再为每个vCPU调用一次, 一共8次
+ *
+ * #1  0x0000555555cd05e3 in kvm_put_msrs (cpu=0x5555576fe3d0, level=2) at ../target/i386/kvm/kvm.c:3859
+ * #2  0x0000555555cd4e9f in kvm_arch_put_registers (cpu=0x5555576fe3d0, level=2) at ../target/i386/kvm/kvm.c:5189
+ * #3  0x0000555555ed4306 in do_kvm_cpu_synchronize_post_reset (cpu=0x5555576fe3d0, arg=...) at ../accel/kvm/kvm-all.c:2789
+ * #4  0x000055555587f74c in process_queued_cpu_work (cpu=0x5555576fe3d0) at ../cpu-common.c:372
+ * #5  0x0000555555bd1036 in qemu_wait_io_event_common (cpu=0x5555576fe3d0) at ../system/cpus.c:450
+ * #6  0x0000555555bd10cf in qemu_wait_io_event (cpu=0x5555576fe3d0) at ../system/cpus.c:468
+ * #7  0x0000555555ed84bb in kvm_vcpu_thread_fn (arg=0x5555576fe3d0) at ../accel/kvm/kvm-accel-ops.c:55
+ * #8  0x000055555616b06e in qemu_thread_start (args=0x5555577089d0) at ../util/qemu-thread-posix.c:541
+ * #9  0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #10 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ *
+ * QEMU-7.1的例子:
+ *
+ * (gdb) bt
+ * #0  kvm_put_msrs (cpu=0x555556ae2360, level=2) at ../target/i386/kvm/kvm.c:3135
+ * #1  0x0000555555b1497a in kvm_arch_put_registers (cpu=0x555556ae2360, level=2) at ../target/i386/kvm/kvm.c:4559
+ * #2  0x0000555555d0de56 in do_kvm_cpu_synchronize_post_reset (cpu=0x555556ae2360, arg=...) at ../accel/kvm/kvm-all.c:2780
+ * #3  0x0000555555821f77 in process_queued_cpu_work (cpu=0x555556ae2360) at ../cpus-common.c:351
+ * #4  0x0000555555a717d4 in qemu_wait_io_event_common (cpu=0x555556ae2360) at ../softmmu/cpus.c:411
+ * #5  0x0000555555a71865 in qemu_wait_io_event (cpu=0x555556ae2360) at ../softmmu/cpus.c:435
+ * #6  0x0000555555d10fce in kvm_vcpu_thread_fn (arg=0x555556ae2360) at ../accel/kvm/kvm-accel-ops.c:54
+ * #7  0x0000555555eec4de in qemu_thread_start (args=0x555556af1620) at ../util/qemu-thread-posix.c:504
+ * #8  0x00007ffff55eeea5 in start_thread () at /lib64/libpthread.so.0
+ * #9  0x00007ffff53179fd in clone () at /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_put_msrs (cpu=0x555556ae2360, level=1) at ../target/i386/kvm/kvm.c:3135
+ * #1  0x0000555555b1497a in kvm_arch_put_registers (cpu=0x555556ae2360, level=1) at ../target/i386/kvm/kvm.c:4559
+ * #2  0x0000555555d0e12c in kvm_cpu_exec (cpu=0x555556ae2360) at ../accel/kvm/kvm-all.c:2884
+ * #3  0x0000555555d10faa in kvm_vcpu_thread_fn (arg=0x555556ae2360) at ../accel/kvm/kvm-accel-ops.c:49
+ * #4  0x0000555555eec4de in qemu_thread_start (args=0x555556af1620) at ../util/qemu-thread-posix.c:504
+ * #5  0x00007ffff55eeea5 in start_thread () at /lib64/libpthread.so.0
+ * #6  0x00007ffff53179fd in clone () at /lib64/libc.so.6
+ *
+ * called by:
+ *   - target/i386/kvm/kvm.c|5182| <<kvm_arch_put_registers>> ret = kvm_put_msrs(x86_cpu, level);
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
 static int kvm_put_msrs(X86CPU *cpu, int level)
 {
     CPUX86State *env = &cpu->env;
@@ -3870,33 +4541,145 @@ static int kvm_put_msrs(X86CPU *cpu, int level)
             kvm_msr_entry_add(cpu, MSR_KVM_POLL_CONTROL, env->poll_control_msr);
         }
 
+        /*
+         * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+	 * has_architectural_pmu_version = 0.
+	 * num_architectural_pmu_gp_counters = 0.
+	 * num_architectural_pmu_fixed_counters = 0.
+	 *
+	 * 2. 如果guest_vendor是Intel
+	 * 完全按照cpuid来算
+	 *
+	 * 3. 如果guest_vendor是AMD
+	 * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+	 *      如果支持, 根据0x80000022获取寄存器的数目.
+	 *      此外, 3个global的也支持!
+	 *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+	 * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+	 *      就是6个寄存器
+	 * 3.3. 默认只支持4个
+         */
+        /*
+	 * 在以下使用has_architectural_pmu_version:
+	 *   - target/i386/kvm/kvm.c|2162| <<kvm_x86_build_cpuid>> has_architectural_pmu_version = eax & 0xff;
+	 *   - target/i386/kvm/kvm.c|2163| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|2174| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4316| <<kvm_put_msrs>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|4317| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4334| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|4820| <<kvm_get_msrs>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|4821| <<kvm_get_msrs>> if (has_architectural_pmu_version > 1) {
+	 */
         if (has_architectural_pmu_version > 0) {
             if (has_architectural_pmu_version > 1) {
+                /*
+		 * Intel SDM里面有这样一句话:
+		 * The event logic unit for a UMASK must be disabled by
+		 * setting IA32_PERFEVTSELx[bit 22] = 0, before writing to
+		 * IA32_PMCx.
+		 */
                 /* Stop the counter.  */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);
             }
 
             /* Set the counter values.  */
+	    /*
+	     * Intel SDM里面有这样一句话:
+	     * The event logic unit for a UMASK must be disabled by
+	     * setting IA32_PERFEVTSELx[bit 22] = 0, before writing to
+	     * IA32_PMCx.
+	     */
+            /*
+	     * 在以下使用num_architectural_pmu_fixed_counters:
+	     *   - target/i386/kvm/kvm.c|2175| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = edx & 0x1f;
+	     *   - target/i386/kvm/kvm.c|2177| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
+	     *   - target/i386/kvm/kvm.c|2178| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = MAX_FIXED_COUNTERS;
+	     *   - target/i386/kvm/kvm.c|4324| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+	     *   - target/i386/kvm/kvm.c|4827| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+	     */
             for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+                /*
+		 * 在以下使用CPUX86State->msr_fixed_counters[MAX_FIXED_COUNTERS]:
+		 *   - target/i386/machine.c|678| <<global>> VMSTATE_UINT64_ARRAY(env.msr_fixed_counters, X86CPU, MAX_FIXED_COUNTERS),
+		 *   - target/i386/kvm/kvm.c|4422| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, env->msr_fixed_counters[i]);
+		 *   - target/i386/kvm/kvm.c|5270| <<kvm_get_msrs>> env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;
+		 *   - target/i386/machine.c|655| <<pmu_enable_needed>> if (env->msr_fixed_counters[i]) {
+		 */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i,
                                   env->msr_fixed_counters[i]);
             }
+            /*
+	     * 在以下使用num_architectural_pmu_gp_counters:
+	     *   - target/i386/kvm/kvm.c|2164| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
+	     *   - target/i386/kvm/kvm.c|2170| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+	     *   - target/i386/kvm/kvm.c|2171| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+	     *   - target/i386/kvm/kvm.c|4328| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	     */
             for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+                /*
+		 * 在以下使用CPUX86State->msr_gp_counters[MAX_GP_COUNTERS]:
+		 *   - target/i386/machine.c|679| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_counters, X86CPU, MAX_GP_COUNTERS),
+		 *   - target/i386/kvm/kvm.c|4418| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, env->msr_gp_counters[i]);
+		 *   - target/i386/kvm/kvm.c|5249| <<kvm_get_msrs>> env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;
+		 *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+		 */
                 kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i,
                                   env->msr_gp_counters[i]);
+                /*
+		 * 在以下使用CPUX86State->msr_gp_evtsel[MAX_GP_COUNTERS]:
+		 *   - target/i386/machine.c|680| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_evtsel, X86CPU, MAX_GP_COUNTERS),
+		 *   - target/i386/kvm/kvm.c|4420| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, env->msr_gp_evtsel[i]);
+		 *   - target/i386/kvm/kvm.c|5252| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+		 *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+		 */
                 kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i,
                                   env->msr_gp_evtsel[i]);
             }
             if (has_architectural_pmu_version > 1) {
+                /*
+		 * 在以下使用CPUX86State->msr_global_status:
+		 *   - target/i386/machine.c|676| <<global>> VMSTATE_UINT64(env.msr_global_status, X86CPU),
+		 *   - target/i386/kvm/kvm.c|4424| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, env->msr_global_status);
+		 *   - target/i386/kvm/kvm.c|5240| <<kvm_get_msrs>> env->msr_global_status = msrs[i].data;
+		 *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+		 */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS,
                                   env->msr_global_status);
+                /*
+		 * 在以下使用CPUX86State->msr_global_ovf_ctrl:
+		 *   - target/i386/machine.c|677| <<global>> VMSTATE_UINT64(env.msr_global_ovf_ctrl, X86CPU),
+		 *   - target/i386/kvm/kvm.c|4426| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, env->msr_global_ovf_ctrl);
+		 *   - target/i386/kvm/kvm.c|5243| <<kvm_get_msrs>> env->msr_global_ovf_ctrl = msrs[i].data;
+		 *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+		 */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL,
                                   env->msr_global_ovf_ctrl);
 
+		/*
+		 * 在以下使用CPUX86State->msr_fixed_ctr_ctrl:
+		 *   - target/i386/machine.c|674| <<global>> VMSTATE_UINT64(env.msr_fixed_ctr_ctrl, X86CPU),
+		 *   - target/i386/kvm/kvm.c|4430| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, env->msr_fixed_ctr_ctrl);
+		 *   - target/i386/kvm/kvm.c|5234| <<kvm_get_msrs>> env->msr_fixed_ctr_ctrl = msrs[i].data;
+		 *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+		 */
+		/*
+		 * Intel SDM里面有这样一句话:
+		 * The event logic unit for a UMASK must be disabled by
+		 * setting IA32_PERFEVTSELx[bit 22] = 0, before writing to
+		 * IA32_PMCx.
+		 */
                 /* Now start the PMU.  */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL,
                                   env->msr_fixed_ctr_ctrl);
+                /*
+		 * 在以下使用CPUX86State->msr_global_ctrl:
+		 *   - target/i386/machine.c|675| <<global>> VMSTATE_UINT64(env.msr_global_ctrl, X86CPU),
+		 *   - target/i386/kvm/kvm.c|4432| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, env->msr_global_ctrl);
+		 *   - target/i386/kvm/kvm.c|5237| <<kvm_get_msrs>> env->msr_global_ctrl = msrs[i].data;
+		 *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+		 */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL,
                                   env->msr_global_ctrl);
             }
@@ -4094,6 +4877,11 @@ static int kvm_put_msrs(X86CPU *cpu, int level)
         }
     }
 
+    /*
+     * called by:
+     *   - target/i386/kvm/kvm.c|3766| <<kvm_init_msrs>> assert(kvm_buf_set_msrs(cpu) == 0);
+     *   - target/i386/kvm/kvm.c|4097| <<kvm_put_msrs>> return kvm_buf_set_msrs(cpu);
+     */
     return kvm_buf_set_msrs(cpu);
 }
 
@@ -4238,9 +5026,43 @@ static int kvm_get_sregs2(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|5243| <<kvm_arch_get_registers>> ret = kvm_get_msrs(cpu);
+ *
+ * 查看:
+ *
+ * https://github.com/finallyjustice/codereading/blob/master/comment/kvm/qemu_kvm_cpuid_features.txt
+ */
 static int kvm_get_msrs(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     */
     struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
     int ret, i;
     uint64_t mtrr_top_bits;
@@ -4344,6 +5166,35 @@ static int kvm_get_msrs(X86CPU *cpu)
     if (env->features[FEAT_KVM] & (1 << KVM_FEATURE_POLL_CONTROL)) {
         kvm_msr_entry_add(cpu, MSR_KVM_POLL_CONTROL, 1);
     }
+    /*
+     * 1. 如果guest_vendor和host_vendor不一样, 不支持PMU.
+     * has_architectural_pmu_version = 0.
+     * num_architectural_pmu_gp_counters = 0.
+     * num_architectural_pmu_fixed_counters = 0.
+     *
+     * 2. 如果guest_vendor是Intel
+     * 完全按照cpuid来算
+     *
+     * 3. 如果guest_vendor是AMD
+     * 3.1. 查看cpuid是否支持X86_FEATURE_PERFMON_V2.
+     *      如果支持, 根据0x80000022获取寄存器的数目.
+     *      此外, 3个global的也支持!
+     *      寄存器的base address和MSR_F15H_PERF_CTR5的一样(KVM svm其实限制了最多6个)
+     * 3.2. 如果不是ver=2, 如果支持X86_FEATURE_PERFCTR_CORE,
+     *      就是6个寄存器
+     * 3.3. 默认只支持4个
+     */
+    /*
+     * 在以下使用has_architectural_pmu_version:
+     *   - target/i386/kvm/kvm.c|2162| <<kvm_x86_build_cpuid>> has_architectural_pmu_version = eax & 0xff;
+     *   - target/i386/kvm/kvm.c|2163| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 0) {
+     *   - target/i386/kvm/kvm.c|2174| <<kvm_x86_build_cpuid>> if (has_architectural_pmu_version > 1) {
+     *   - target/i386/kvm/kvm.c|4316| <<kvm_put_msrs>> if (has_architectural_pmu_version > 0) {
+     *   - target/i386/kvm/kvm.c|4317| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+     *   - target/i386/kvm/kvm.c|4334| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+     *   - target/i386/kvm/kvm.c|4820| <<kvm_get_msrs>> if (has_architectural_pmu_version > 0) {
+     *   - target/i386/kvm/kvm.c|4821| <<kvm_get_msrs>> if (has_architectural_pmu_version > 1) {
+     */
     if (has_architectural_pmu_version > 0) {
         if (has_architectural_pmu_version > 1) {
             kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);
@@ -4351,9 +5202,25 @@ static int kvm_get_msrs(X86CPU *cpu)
             kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);
             kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);
         }
+        /*
+	 * 在以下使用num_architectural_pmu_fixed_counters:
+	 *   - target/i386/kvm/kvm.c|2175| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = edx & 0x1f;
+	 *   - target/i386/kvm/kvm.c|2177| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
+	 *   - target/i386/kvm/kvm.c|2178| <<kvm_x86_build_cpuid>> num_architectural_pmu_fixed_counters = MAX_FIXED_COUNTERS;
+	 *   - target/i386/kvm/kvm.c|4324| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+	 *   - target/i386/kvm/kvm.c|4827| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+	 */
         for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
             kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);
         }
+        /*
+	 * 在以下使用num_architectural_pmu_gp_counters:
+	 *   - target/i386/kvm/kvm.c|2164| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
+	 *   - target/i386/kvm/kvm.c|2170| <<kvm_x86_build_cpuid>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+	 *   - target/i386/kvm/kvm.c|2171| <<kvm_x86_build_cpuid>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+	 *   - target/i386/kvm/kvm.c|4328| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	 *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	 */
         for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
             kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);
             kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);
@@ -4479,6 +5346,35 @@ static int kvm_get_msrs(X86CPU *cpu)
         }
     }
 
+    /*
+     * 在以下使用ArchCPU->kvm_msr_buf (struct kvm_msrs *):
+     *   - target/i386/kvm/kvm.c|2544| <<kvm_arch_init_vcpu>> cpu->kvm_msr_buf = g_malloc0(MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|2571| <<kvm_arch_destroy_vcpu>> g_free(cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|2572| <<kvm_arch_destroy_vcpu>> cpu->kvm_msr_buf = NULL;
+     *   - target/i386/kvm/kvm.c|3757| <<kvm_msr_buf_reset>> memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
+     *   - target/i386/kvm/kvm.c|3785| <<kvm_msr_entry_add>> struct kvm_msrs *msrs = cpu->kvm_msr_buf;
+     *   - target/i386/kvm/kvm.c|3808| <<kvm_put_one_msr>> return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4045| <<kvm_buf_set_msrs>> int ret = kvm_vcpu_ioctl(CPU(cpu), KVM_SET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4050| <<kvm_buf_set_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4051| <<kvm_buf_set_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4056| <<kvm_buf_set_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *   - target/i386/kvm/kvm.c|4581| <<kvm_get_msrs>> struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;
+     *   - target/i386/kvm/kvm.c|4819| <<kvm_get_msrs>> ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
+     *   - target/i386/kvm/kvm.c|4824| <<kvm_get_msrs>> if (ret < cpu->kvm_msr_buf->nmsrs) {
+     *   - target/i386/kvm/kvm.c|4825| <<kvm_get_msrs>> struct kvm_msr_entry *e = &cpu->kvm_msr_buf->entries[ret];
+     *   - target/i386/kvm/kvm.c|4830| <<kvm_get_msrs>> assert(ret == cpu->kvm_msr_buf->nmsrs);
+     *          
+     * // for KVM_GET_MSRS and KVM_SET_MSRS
+     * struct kvm_msrs {
+     *     __u32 nmsrs; // number of msrs in entries
+     *     __u32 pad;
+     *
+     *     struct kvm_msr_entry entries[];
+     * };
+     *
+     * X86CPU *cpu (ArchCPU):
+     * -> struct kvm_msrs *kvm_msr_buf;
+     */
     ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);
     if (ret < 0) {
         return ret;
@@ -4651,24 +5547,73 @@ static int kvm_get_msrs(X86CPU *cpu)
             break;
         }
         case MSR_CORE_PERF_FIXED_CTR_CTRL:
+            /*
+	     * 在以下使用CPUX86State->msr_fixed_ctr_ctrl:
+	     *   - target/i386/machine.c|674| <<global>> VMSTATE_UINT64(env.msr_fixed_ctr_ctrl, X86CPU),
+	     *   - target/i386/kvm/kvm.c|4430| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, env->msr_fixed_ctr_ctrl);
+	     *   - target/i386/kvm/kvm.c|5234| <<kvm_get_msrs>> env->msr_fixed_ctr_ctrl = msrs[i].data;
+	     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+	     */
             env->msr_fixed_ctr_ctrl = msrs[i].data;
             break;
         case MSR_CORE_PERF_GLOBAL_CTRL:
+            /*
+	     * 在以下使用CPUX86State->msr_global_ctrl:
+	     *   - target/i386/machine.c|675| <<global>> VMSTATE_UINT64(env.msr_global_ctrl, X86CPU),
+	     *   - target/i386/kvm/kvm.c|4432| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, env->msr_global_ctrl);
+	     *   - target/i386/kvm/kvm.c|5237| <<kvm_get_msrs>> env->msr_global_ctrl = msrs[i].data;
+	     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+	     */
             env->msr_global_ctrl = msrs[i].data;
             break;
         case MSR_CORE_PERF_GLOBAL_STATUS:
+            /*
+	     * 在以下使用CPUX86State->msr_global_status:
+	     *   - target/i386/machine.c|676| <<global>> VMSTATE_UINT64(env.msr_global_status, X86CPU),
+	     *   - target/i386/kvm/kvm.c|4424| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, env->msr_global_status);
+	     *   - target/i386/kvm/kvm.c|5240| <<kvm_get_msrs>> env->msr_global_status = msrs[i].data;
+	     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+	     */
             env->msr_global_status = msrs[i].data;
             break;
         case MSR_CORE_PERF_GLOBAL_OVF_CTRL:
+            /*
+	     * 在以下使用CPUX86State->msr_global_ovf_ctrl:
+	     *   - target/i386/machine.c|677| <<global>> VMSTATE_UINT64(env.msr_global_ovf_ctrl, X86CPU),
+	     *   - target/i386/kvm/kvm.c|4426| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, env->msr_global_ovf_ctrl);
+	     *   - target/i386/kvm/kvm.c|5243| <<kvm_get_msrs>> env->msr_global_ovf_ctrl = msrs[i].data;
+	     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+	     */
             env->msr_global_ovf_ctrl = msrs[i].data;
             break;
         case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:
+            /*
+	     * 在以下使用CPUX86State->msr_fixed_counters[MAX_FIXED_COUNTERS]:
+	     *   - target/i386/machine.c|678| <<global>> VMSTATE_UINT64_ARRAY(env.msr_fixed_counters, X86CPU, MAX_FIXED_COUNTERS),
+	     *   - target/i386/kvm/kvm.c|4422| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, env->msr_fixed_counters[i]);
+	     *   - target/i386/kvm/kvm.c|5270| <<kvm_get_msrs>> env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;
+	     *   - target/i386/machine.c|655| <<pmu_enable_needed>> if (env->msr_fixed_counters[i]) {
+	     */
             env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;
             break;
         case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:
+            /*
+	     * 在以下使用CPUX86State->msr_gp_counters[MAX_GP_COUNTERS]:
+	     *   - target/i386/machine.c|679| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_counters, X86CPU, MAX_GP_COUNTERS),
+	     *   - target/i386/kvm/kvm.c|4418| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, env->msr_gp_counters[i]);
+	     *   - target/i386/kvm/kvm.c|5249| <<kvm_get_msrs>> env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;
+	     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+	     */
             env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;
             break;
         case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:
+            /*
+	     * 在以下使用CPUX86State->msr_gp_evtsel[MAX_GP_COUNTERS]:
+	     *   - target/i386/machine.c|680| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_evtsel, X86CPU, MAX_GP_COUNTERS),
+	     *   - target/i386/kvm/kvm.c|4420| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, env->msr_gp_evtsel[i]);
+	     *   - target/i386/kvm/kvm.c|5252| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+	     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+	     */
             env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
             break;
         case HV_X64_MSR_HYPERCALL:
@@ -5117,6 +6062,12 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2814| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE);
+ *   - accel/kvm/kvm-all.c|2831| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);
+ *   - accel/kvm/kvm-all.c|3023| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);
+ */
 int kvm_arch_put_registers(CPUState *cpu, int level)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -5205,6 +6156,10 @@ int kvm_arch_put_registers(CPUState *cpu, int level)
     return 0;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2769| <<do_kvm_cpu_synchronize_state>> int ret = kvm_arch_get_registers(cpu);
+ */
 int kvm_arch_get_registers(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -5360,6 +6315,10 @@ void kvm_arch_pre_run(CPUState *cpu, struct kvm_run *run)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|5388| <<kvm_arch_post_run>> kvm_rate_limit_on_bus_lock();
+ */
 static void kvm_rate_limit_on_bus_lock(void)
 {
     uint64_t delay_ns = ratelimit_calculate_delay(&bus_lock_ratelimit_ctrl, 1);
@@ -5369,6 +6328,10 @@ static void kvm_rate_limit_on_bus_lock(void)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|3027| <<kvm_cpu_exec>> attrs = kvm_arch_post_run(cpu, run);
+ */
 MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -5414,6 +6377,10 @@ MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
     return cpu_get_mem_attrs(env);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2986| <<kvm_cpu_exec>> if (kvm_arch_process_async_events(cpu)) {
+ */
 int kvm_arch_process_async_events(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -5475,6 +6442,10 @@ int kvm_arch_process_async_events(CPUState *cs)
     return cs->halted;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|5890| <<kvm_arch_handle_exit(KVM_EXIT_HLT)>> ret = kvm_handle_halt(cpu);
+ */
 static int kvm_handle_halt(X86CPU *cpu)
 {
     CPUState *cs = CPU(cpu);
@@ -5875,6 +6846,11 @@ static int kvm_handle_hypercall(struct kvm_run *run)
 
 #define VMX_INVALID_GUEST_STATE 0x80000021
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|3138| <<kvm_cpu_exec>> ret = kvm_arch_handle_exit(cpu, run);
+ *   - accel/kvm/kvm-all.c|3156| <<kvm_cpu_exec>> ret = kvm_arch_handle_exit(cpu, run);
+ */
 int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -6387,6 +7363,10 @@ static void kvm_arch_set_xen_evtchn_max_pirq(Object *obj, Visitor *v,
     s->xen_evtchn_max_pirq = value;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|3882| <<kvm_accel_class_init>> kvm_arch_accel_class_init(oc);
+ */
 void kvm_arch_accel_class_init(ObjectClass *oc)
 {
     object_class_property_add_enum(oc, "notify-vmexit", "NotifyVMexitOption",
diff --git a/target/i386/kvm/vmsr_energy.c b/target/i386/kvm/vmsr_energy.c
index 7e064c5ae..7bace5304 100644
--- a/target/i386/kvm/vmsr_energy.c
+++ b/target/i386/kvm/vmsr_energy.c
@@ -20,6 +20,57 @@
 #include "cpu.h"
 #include "host-cpu.h"
 
+/*
+ * commit 0418f90809aea5b375c859e744c8e8610e9be446
+ * Author: Anthony Harivel <aharivel@redhat.com>
+ * Date:   Wed May 22 17:34:52 2024 +0200
+ *
+ * Add support for RAPL MSRs in KVM/Qemu
+ *
+ * Starting with the "Sandy Bridge" generation, Intel CPUs provide a RAPL
+ * interface (Running Average Power Limit) for advertising the accumulated
+ * energy consumption of various power domains (e.g. CPU packages, DRAM,
+ * etc.).
+ *
+ * The consumption is reported via MSRs (model specific registers) like
+ * MSR_PKG_ENERGY_STATUS for the CPU package power domain. These MSRs are
+ * 64 bits registers that represent the accumulated energy consumption in
+ * micro Joules. They are updated by microcode every ~1ms.
+ *
+ * For now, KVM always returns 0 when the guest requests the value of
+ * these MSRs. Use the KVM MSR filtering mechanism to allow QEMU handle
+ * these MSRs dynamically in userspace.
+ *
+ * To limit the amount of system calls for every MSR call, create a new
+ * thread in QEMU that updates the "virtual" MSR values asynchronously.
+ *
+ * Each vCPU has its own vMSR to reflect the independence of vCPUs. The
+ * thread updates the vMSR values with the ratio of energy consumed of
+ * the whole physical CPU package the vCPU thread runs on and the
+ * thread's utime and stime values.
+ *
+ * All other non-vCPU threads are also taken into account. Their energy
+ * consumption is evenly distributed among all vCPUs threads running on
+ * the same physical CPU package.
+ *
+ * To overcome the problem that reading the RAPL MSR requires priviliged
+ * access, a socket communication between QEMU and the qemu-vmsr-helper is
+ * mandatory. You can specified the socket path in the parameter.
+ *
+ * This feature is activated with -accel kvm,rapl=true,path=/path/sock.sock
+ *
+ * Actual limitation:
+ * - Works only on Intel host CPU because AMD CPUs are using different MSR
+ *   adresses.
+ *
+ * - Only the Package Power-Plane (MSR_PKG_ENERGY_STATUS) is reported at
+ *   the moment.
+ *
+ * Signed-off-by: Anthony Harivel <aharivel@redhat.com>
+ * Link: https://lore.kernel.org/r/20240522153453.1230389-4-aharivel@redhat.com
+ * Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
+ */
+
 char *vmsr_compute_default_paths(void)
 {
     g_autofree char *state = qemu_get_local_state_dir();
diff --git a/target/i386/machine.c b/target/i386/machine.c
index 39f8294f2..46256f7a5 100644
--- a/target/i386/machine.c
+++ b/target/i386/machine.c
@@ -647,15 +647,60 @@ static bool pmu_enable_needed(void *opaque)
     CPUX86State *env = &cpu->env;
     int i;
 
+    /*
+     * 在以下使用CPUX86State->msr_fixed_ctr_ctrl:
+     *   - target/i386/machine.c|674| <<global>> VMSTATE_UINT64(env.msr_fixed_ctr_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4430| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, env->msr_fixed_ctr_ctrl);
+     *   - target/i386/kvm/kvm.c|5234| <<kvm_get_msrs>> env->msr_fixed_ctr_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+     *
+     * 在以下使用CPUX86State->msr_global_ctrl:
+     *   - target/i386/machine.c|675| <<global>> VMSTATE_UINT64(env.msr_global_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4432| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, env->msr_global_ctrl);
+     *   - target/i386/kvm/kvm.c|5237| <<kvm_get_msrs>> env->msr_global_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|650| <<pmu_enable_needed>> if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
+     *
+     * 在以下使用CPUX86State->msr_global_status:
+     *   - target/i386/machine.c|676| <<global>> VMSTATE_UINT64(env.msr_global_status, X86CPU),
+     *   - target/i386/kvm/kvm.c|4424| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, env->msr_global_status);
+     *   - target/i386/kvm/kvm.c|5240| <<kvm_get_msrs>> env->msr_global_status = msrs[i].data;
+     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+     *
+     * 在以下使用CPUX86State->msr_global_ovf_ctrl:
+     *   - target/i386/machine.c|677| <<global>> VMSTATE_UINT64(env.msr_global_ovf_ctrl, X86CPU),
+     *   - target/i386/kvm/kvm.c|4426| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, env->msr_global_ovf_ctrl);
+     *   - target/i386/kvm/kvm.c|5243| <<kvm_get_msrs>> env->msr_global_ovf_ctrl = msrs[i].data;
+     *   - target/i386/machine.c|651| <<pmu_enable_needed>> env->msr_global_status || env->msr_global_ovf_ctrl) {
+     */
     if (env->msr_fixed_ctr_ctrl || env->msr_global_ctrl ||
         env->msr_global_status || env->msr_global_ovf_ctrl) {
         return true;
     }
+    /*
+     * 在以下使用CPUX86State->msr_fixed_counters[MAX_FIXED_COUNTERS]:
+     *   - target/i386/machine.c|678| <<global>> VMSTATE_UINT64_ARRAY(env.msr_fixed_counters, X86CPU, MAX_FIXED_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4422| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, env->msr_fixed_counters[i]);
+     *   - target/i386/kvm/kvm.c|5270| <<kvm_get_msrs>> env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;
+     *   - target/i386/machine.c|655| <<pmu_enable_needed>> if (env->msr_fixed_counters[i]) {
+     */
     for (i = 0; i < MAX_FIXED_COUNTERS; i++) {
         if (env->msr_fixed_counters[i]) {
             return true;
         }
     }
+    /*
+     * 在以下使用CPUX86State->msr_gp_counters[MAX_GP_COUNTERS]:
+     *   - target/i386/machine.c|679| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_counters, X86CPU, MAX_GP_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4418| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, env->msr_gp_counters[i]);
+     *   - target/i386/kvm/kvm.c|5249| <<kvm_get_msrs>> env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;
+     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+     *
+     * 在以下使用CPUX86State->msr_gp_evtsel[MAX_GP_COUNTERS]:
+     *   - target/i386/machine.c|680| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_evtsel, X86CPU, MAX_GP_COUNTERS),
+     *   - target/i386/kvm/kvm.c|4420| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, env->msr_gp_evtsel[i]);
+     *   - target/i386/kvm/kvm.c|5252| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+     *   - target/i386/machine.c|660| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+     */
     for (i = 0; i < MAX_GP_COUNTERS; i++) {
         if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
             return true;
diff --git a/target/i386/tcg/sysemu/excp_helper.c b/target/i386/tcg/sysemu/excp_helper.c
index 8fb05b1f5..84342195b 100644
--- a/target/i386/tcg/sysemu/excp_helper.c
+++ b/target/i386/tcg/sysemu/excp_helper.c
@@ -132,6 +132,11 @@ static inline bool ptw_setl(const PTETranslate *in, uint32_t old, uint32_t set)
     return true;
 }
 
+/*
+ * called by:
+ *   - target/i386/tcg/sysemu/excp_helper.c|552| <<get_physical_address>> if (!mmu_translate(env, &in, out, err, ra)) {
+ *   - target/i386/tcg/sysemu/excp_helper.c|583| <<get_physical_address>> return mmu_translate(env, &in, out, err, ra);
+ */
 static bool mmu_translate(CPUX86State *env, const TranslateParams *in,
                           TranslateResult *out, TranslateFault *err,
                           uint64_t ra)
diff --git a/util/oslib-posix.c b/util/oslib-posix.c
index 11b35e48f..6c9a96d2e 100644
--- a/util/oslib-posix.c
+++ b/util/oslib-posix.c
@@ -657,6 +657,13 @@ char *qemu_get_pid_name(pid_t pid)
 }
 
 
+/*
+ * called by:
+ *   - system/async-teardown.c|88| <<new_stack_for_clone>> stack_ptr = qemu_alloc_stack(&stack_size);
+ *   - util/coroutine-sigaltstack.c|172| <<qemu_coroutine_new>> co->stack = qemu_alloc_stack(&co->stack_size);
+ *   - util/coroutine-ucontext.c|202| <<qemu_coroutine_new>> co->stack = qemu_alloc_stack(&co->stack_size);
+ *   - util/coroutine-ucontext.c|205| <<qemu_coroutine_new>> co->unsafe_stack = qemu_alloc_stack(&co->unsafe_stack_size);
+ */
 void *qemu_alloc_stack(size_t *sz)
 {
     void *ptr;
diff --git a/util/qemu-coroutine.c b/util/qemu-coroutine.c
index eb4eebefd..7feee25e6 100644
--- a/util/qemu-coroutine.c
+++ b/util/qemu-coroutine.c
@@ -21,6 +21,11 @@
 #include "qemu/cutils.h"
 #include "block/aio.h"
 
+/*
+ * 在以下使用COROUTINE_POOL_BATCH_MAX_SIZE:
+ *   - util/qemu-coroutine.c|65| <<QSLIST_HEAD>> static unsigned int global_pool_max_size = COROUTINE_POOL_BATCH_MAX_SIZE;
+ *   - util/qemu-coroutine.c|200| <<coroutine_pool_put>> if (unlikely(batch->size >= COROUTINE_POOL_BATCH_MAX_SIZE)) {
+ */
 enum {
     COROUTINE_POOL_BATCH_MAX_SIZE = 128,
 };
@@ -54,21 +59,82 @@ typedef struct CoroutinePoolBatch {
     unsigned int size;
 } CoroutinePoolBatch;
 
+/*
+ * 一个链接着CoroutinePoolBatch的链表
+ */
 typedef QSLIST_HEAD(, CoroutinePoolBatch) CoroutinePool;
 
+/*
+ * 在以下使用global_pool_hard_max_size:
+ *   - util/qemu-coroutine.c|200| <<coroutine_pool_put_global>> unsigned int max = MIN(global_pool_max_size, global_pool_hard_max_size);
+ *   - util/qemu-coroutine.c|546| <<qemu_coroutine_init>> global_pool_hard_max_size = get_global_pool_hard_max_size();
+ */
 /* Host operating system limit on number of pooled coroutines */
 static unsigned int global_pool_hard_max_size;
 
+/*
+ * 在以下使用global_pool_lock:
+ *   - util/qemu-coroutine.c|72| <<QSLIST_HEAD>> static QemuMutex global_pool_lock;
+ *   - util/qemu-coroutine.c|233| <<coroutine_pool_refill_local>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+ *   - util/qemu-coroutine.c|255| <<coroutine_pool_put_global>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+ *   - util/qemu-coroutine.c|546| <<qemu_coroutine_inc_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+ *   - util/qemu-coroutine.c|556| <<qemu_coroutine_dec_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+ *   - util/qemu-coroutine.c|602| <<qemu_coroutine_init>> qemu_mutex_init(&global_pool_lock);
+ */
 static QemuMutex global_pool_lock; /* protects the following variables */
+/*
+ * 在以下使用global_pool:
+ *   - util/qemu-coroutine.c|68| <<QSLIST_HEAD>> static CoroutinePool global_pool = QSLIST_HEAD_INITIALIZER(global_pool);
+ *   - util/qemu-coroutine.c|147| <<coroutine_pool_refill_local>> batch = QSLIST_FIRST(&global_pool);
+ *   - util/qemu-coroutine.c|150| <<coroutine_pool_refill_local>> QSLIST_REMOVE_HEAD(&global_pool, next);
+ *   - util/qemu-coroutine.c|169| <<coroutine_pool_put_global>> QSLIST_INSERT_HEAD(&global_pool, batch, next);
+ *
+ * 一个链接着CoroutinePoolBatch的链表
+ */
 static CoroutinePool global_pool = QSLIST_HEAD_INITIALIZER(global_pool);
+/*
+ * 在以下使用global_pool_size:
+ *   - util/qemu-coroutine.c|69| <<QSLIST_HEAD>> static unsigned int global_pool_size;
+ *   - util/qemu-coroutine.c|151| <<coroutine_pool_refill_local>> global_pool_size -= batch->size;
+ *   - util/qemu-coroutine.c|168| <<coroutine_pool_put_global>> if (global_pool_size < max) {
+ *   - util/qemu-coroutine.c|172| <<coroutine_pool_put_global>> global_pool_size += batch->size;
+ */
 static unsigned int global_pool_size;
+/*
+ * 在以下使用global_pool_max_size:
+ *   - util/qemu-coroutine.c|70| <<QSLIST_HEAD>> static unsigned int global_pool_max_size = COROUTINE_POOL_BATCH_MAX_SIZE;
+ *   - util/qemu-coroutine.c|165| <<coroutine_pool_put_global>> unsigned int max = MIN(global_pool_max_size, global_pool_hard_max_size);
+ *   - util/qemu-coroutine.c|360| <<qemu_coroutine_inc_pool_size>> global_pool_max_size += additional_pool_size;
+ *   - util/qemu-coroutine.c|366| <<qemu_coroutine_dec_pool_size>> global_pool_max_size -= removing_pool_size;
+ */
 static unsigned int global_pool_max_size = COROUTINE_POOL_BATCH_MAX_SIZE;
 
+/*
+ * 一个链接着CoroutinePoolBatch的链表
+ */
 QEMU_DEFINE_STATIC_CO_TLS(CoroutinePool, local_pool);
+/*
+ * 查看local_pool_cleanup_init_once()
+ */
 QEMU_DEFINE_STATIC_CO_TLS(Notifier, local_pool_cleanup_notifier);
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|229| <<coroutine_pool_put>> batch = coroutine_pool_batch_new();
+ *   - util/qemu-coroutine.c|243| <<coroutine_pool_put>> batch = coroutine_pool_batch_new();
+ */
 static CoroutinePoolBatch *coroutine_pool_batch_new(void)
 {
+    /*
+     * 53 typedef struct CoroutinePoolBatch {
+     * 54     // Batches are kept in a list
+     * 55     QSLIST_ENTRY(CoroutinePoolBatch) next;
+     * 56
+     * 57     // This batch holds up to @COROUTINE_POOL_BATCH_MAX_SIZE coroutines
+     * 58     QSLIST_HEAD(, Coroutine) list;
+     * 59     unsigned int size;
+     * 60 } CoroutinePoolBatch;
+     */
     CoroutinePoolBatch *batch = g_new(CoroutinePoolBatch, 1);
 
     QSLIST_INIT(&batch->list);
@@ -76,11 +142,29 @@ static CoroutinePoolBatch *coroutine_pool_batch_new(void)
     return batch;
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|133| <<local_pool_cleanup>> coroutine_pool_batch_delete(batch);
+ *   - util/qemu-coroutine.c|169| <<coroutine_pool_get_local>> coroutine_pool_batch_delete(batch);
+ *   - util/qemu-coroutine.c|212| <<coroutine_pool_put_global>> coroutine_pool_batch_delete(batch);
+ *
+ * 把一个CoroutinePoolBatch上所有的Coroutine清空
+ */
 static void coroutine_pool_batch_delete(CoroutinePoolBatch *batch)
 {
     Coroutine *co;
     Coroutine *tmp;
 
+    /*
+     * 53 typedef struct CoroutinePoolBatch {
+     * 54     // Batches are kept in a list
+     * 55     QSLIST_ENTRY(CoroutinePoolBatch) next;
+     * 56
+     * 57     // This batch holds up to @COROUTINE_POOL_BATCH_MAX_SIZE coroutines
+     * 58     QSLIST_HEAD(, Coroutine) list;
+     * 59     unsigned int size;
+     * 60 } CoroutinePoolBatch;
+     */
     QSLIST_FOREACH_SAFE(co, &batch->list, pool_next, tmp) {
         QSLIST_REMOVE_HEAD(&batch->list, pool_next);
         qemu_coroutine_delete(co);
@@ -88,21 +172,51 @@ static void coroutine_pool_batch_delete(CoroutinePoolBatch *batch)
     g_free(batch);
 }
 
+/*
+ * 在以下使用local_pool_cleanup():
+ *   - util/qemu-coroutine.c|147| <<local_pool_cleanup_init_once>> notifier->notify = local_pool_cleanup;
+ */
 static void local_pool_cleanup(Notifier *n, void *value)
 {
     CoroutinePool *local_pool = get_ptr_local_pool();
     CoroutinePoolBatch *batch;
     CoroutinePoolBatch *tmp;
 
+    /*
+     * 53 typedef struct CoroutinePoolBatch {
+     * 54     // Batches are kept in a list
+     * 55     QSLIST_ENTRY(CoroutinePoolBatch) next;
+     * 56
+     * 57     // This batch holds up to @COROUTINE_POOL_BATCH_MAX_SIZE coroutines
+     * 58     QSLIST_HEAD(, Coroutine) list;
+     * 59     unsigned int size;
+     * 60 } CoroutinePoolBatch;
+     */
     QSLIST_FOREACH_SAFE(batch, local_pool, next, tmp) {
         QSLIST_REMOVE_HEAD(local_pool, next);
+        /*
+	 * called by:
+	 *   - util/qemu-coroutine.c|133| <<local_pool_cleanup>> coroutine_pool_batch_delete(batch);
+	 *   - util/qemu-coroutine.c|169| <<coroutine_pool_get_local>> coroutine_pool_batch_delete(batch);
+	 *   - util/qemu-coroutine.c|212| <<coroutine_pool_put_global>> coroutine_pool_batch_delete(batch);
+	 *
+	 * 把一个CoroutinePoolBatch上所有的Coroutine清空
+	 */
         coroutine_pool_batch_delete(batch);
     }
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|178| <<coroutine_pool_refill_local>> local_pool_cleanup_init_once();
+ *   - util/qemu-coroutine.c|223| <<coroutine_pool_put>> local_pool_cleanup_init_once();
+ */
 /* Ensure the atexit notifier is registered */
 static void local_pool_cleanup_init_once(void)
 {
+    /*
+     * 声明: QEMU_DEFINE_STATIC_CO_TLS(CoroutinePool, local_pool);
+     */
     Notifier *notifier = get_ptr_local_pool_cleanup_notifier();
     if (!notifier->notify) {
         notifier->notify = local_pool_cleanup;
@@ -110,6 +224,11 @@ static void local_pool_cleanup_init_once(void)
     }
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|224| <<coroutine_pool_get>> co = coroutine_pool_get_local();
+ *   - util/qemu-coroutine.c|227| <<coroutine_pool_get>> co = coroutine_pool_get_local();
+ */
 /* Helper to get the next unused coroutine from the local pool */
 static Coroutine *coroutine_pool_get_local(void)
 {
@@ -132,17 +251,44 @@ static Coroutine *coroutine_pool_get_local(void)
     return co;
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|226| <<coroutine_pool_get>> coroutine_pool_refill_local();
+ */
 /* Get the next batch from the global pool */
 static void coroutine_pool_refill_local(void)
 {
     CoroutinePool *local_pool = get_ptr_local_pool();
     CoroutinePoolBatch *batch;
 
+    /*
+     * 在以下使用global_pool_lock:
+     *   - util/qemu-coroutine.c|72| <<QSLIST_HEAD>> static QemuMutex global_pool_lock;
+     *   - util/qemu-coroutine.c|233| <<coroutine_pool_refill_local>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|255| <<coroutine_pool_put_global>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|546| <<qemu_coroutine_inc_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|556| <<qemu_coroutine_dec_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|602| <<qemu_coroutine_init>> qemu_mutex_init(&global_pool_lock);
+     */
     WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+        /*
+	 * 在以下使用global_pool:
+	 *   - util/qemu-coroutine.c|68| <<QSLIST_HEAD>> static CoroutinePool global_pool = QSLIST_HEAD_INITIALIZER(global_pool);
+	 *   - util/qemu-coroutine.c|147| <<coroutine_pool_refill_local>> batch = QSLIST_FIRST(&global_pool);
+	 *   - util/qemu-coroutine.c|150| <<coroutine_pool_refill_local>> QSLIST_REMOVE_HEAD(&global_pool, next);
+	 *   - util/qemu-coroutine.c|169| <<coroutine_pool_put_global>> QSLIST_INSERT_HEAD(&global_pool, batch, next);
+	 */
         batch = QSLIST_FIRST(&global_pool);
 
         if (batch) {
             QSLIST_REMOVE_HEAD(&global_pool, next);
+            /*
+	     * 在以下使用global_pool_size:
+	     *   - util/qemu-coroutine.c|69| <<QSLIST_HEAD>> static unsigned int global_pool_size;
+	     *   - util/qemu-coroutine.c|151| <<coroutine_pool_refill_local>> global_pool_size -= batch->size;
+	     *   - util/qemu-coroutine.c|168| <<coroutine_pool_put_global>> if (global_pool_size < max) {
+	     *   - util/qemu-coroutine.c|172| <<coroutine_pool_put_global>> global_pool_size += batch->size;
+	     */
             global_pool_size -= batch->size;
         }
     }
@@ -153,16 +299,55 @@ static void coroutine_pool_refill_local(void)
     }
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|253| <<coroutine_pool_put>> coroutine_pool_put_global(batch);
+ */
 /* Add a batch of coroutines to the global pool */
 static void coroutine_pool_put_global(CoroutinePoolBatch *batch)
 {
+    /*
+     * 在以下使用global_pool_lock:
+     *   - util/qemu-coroutine.c|72| <<QSLIST_HEAD>> static QemuMutex global_pool_lock;
+     *   - util/qemu-coroutine.c|233| <<coroutine_pool_refill_local>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|255| <<coroutine_pool_put_global>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|546| <<qemu_coroutine_inc_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|556| <<qemu_coroutine_dec_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|602| <<qemu_coroutine_init>> qemu_mutex_init(&global_pool_lock);
+     */
     WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+        /*
+	 * 在以下使用global_pool_hard_max_size:
+	 *   - util/qemu-coroutine.c|200| <<coroutine_pool_put_global>> unsigned int max = MIN(global_pool_max_size, global_pool_hard_max_size);
+	 *   - util/qemu-coroutine.c|546| <<qemu_coroutine_init>> global_pool_hard_max_size = get_global_pool_hard_max_size();
+	 */
         unsigned int max = MIN(global_pool_max_size,
                                global_pool_hard_max_size);
 
+        /*
+	 * 在以下使用global_pool_size:
+	 *   - util/qemu-coroutine.c|69| <<QSLIST_HEAD>> static unsigned int global_pool_size;
+	 *   - util/qemu-coroutine.c|151| <<coroutine_pool_refill_local>> global_pool_size -= batch->size;
+	 *   - util/qemu-coroutine.c|168| <<coroutine_pool_put_global>> if (global_pool_size < max) {
+	 *   - util/qemu-coroutine.c|172| <<coroutine_pool_put_global>> global_pool_size += batch->size;
+	 */
         if (global_pool_size < max) {
+            /*
+	     * 在以下使用global_pool:
+	     *   - util/qemu-coroutine.c|68| <<QSLIST_HEAD>> static CoroutinePool global_pool = QSLIST_HEAD_INITIALIZER(global_pool);
+	     *   - util/qemu-coroutine.c|147| <<coroutine_pool_refill_local>> batch = QSLIST_FIRST(&global_pool);
+	     *   - util/qemu-coroutine.c|150| <<coroutine_pool_refill_local>> QSLIST_REMOVE_HEAD(&global_pool, next);
+	     *   - util/qemu-coroutine.c|169| <<coroutine_pool_put_global>> QSLIST_INSERT_HEAD(&global_pool, batch, next);
+	     */
             QSLIST_INSERT_HEAD(&global_pool, batch, next);
 
+            /*
+	     * 在以下使用global_pool_size:
+	     *   - util/qemu-coroutine.c|69| <<QSLIST_HEAD>> static unsigned int global_pool_size;
+	     *   - util/qemu-coroutine.c|151| <<coroutine_pool_refill_local>> global_pool_size -= batch->size;
+	     *   - util/qemu-coroutine.c|168| <<coroutine_pool_put_global>> if (global_pool_size < max) {
+	     *   - util/qemu-coroutine.c|172| <<coroutine_pool_put_global>> global_pool_size += batch->size;
+	     */
             /* Overshooting the max pool size is allowed */
             global_pool_size += batch->size;
             return;
@@ -173,6 +358,10 @@ static void coroutine_pool_put_global(CoroutinePoolBatch *batch)
     coroutine_pool_batch_delete(batch);
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|256| <<qemu_coroutine_create>> co = coroutine_pool_get();
+ */
 /* Get the next unused coroutine from the pool or return NULL */
 static Coroutine *coroutine_pool_get(void)
 {
@@ -186,6 +375,10 @@ static Coroutine *coroutine_pool_get(void)
     return co;
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|274| <<coroutine_delete>> coroutine_pool_put(co);
+ */
 static void coroutine_pool_put(Coroutine *co)
 {
     CoroutinePool *local_pool = get_ptr_local_pool();
@@ -203,6 +396,9 @@ static void coroutine_pool_put(Coroutine *co)
         /* Is the local pool full? */
         if (next) {
             QSLIST_REMOVE_HEAD(local_pool, next);
+            /*
+	     * 只在此处调用
+	     */
             coroutine_pool_put_global(batch);
         }
 
@@ -214,11 +410,17 @@ static void coroutine_pool_put(Coroutine *co)
     batch->size++;
 }
 
+/*
+ * 非常多的调用qemu_coroutine_create()
+ */
 Coroutine *qemu_coroutine_create(CoroutineEntry *entry, void *opaque)
 {
     Coroutine *co = NULL;
 
     if (IS_ENABLED(CONFIG_COROUTINE_POOL)) {
+        /*
+	 * 只在此处调用
+	 */
         co = coroutine_pool_get();
     }
 
@@ -232,6 +434,10 @@ Coroutine *qemu_coroutine_create(CoroutineEntry *entry, void *opaque)
     return co;
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|340| <<qemu_aio_coroutine_enter>> coroutine_delete(to);
+ */
 static void coroutine_delete(Coroutine *co)
 {
     co->caller = NULL;
@@ -243,6 +449,12 @@ static void coroutine_delete(Coroutine *co)
     }
 }
 
+/*
+ * called by:
+ *   - util/async.c|570| <<co_schedule_bh_cb>> qemu_aio_coroutine_enter(ctx, co);
+ *   - util/async.c|710| <<aio_co_enter>> qemu_aio_coroutine_enter(ctx, co);
+ *   - util/qemu-coroutine.c|350| <<qemu_coroutine_enter>> qemu_aio_coroutine_enter(qemu_get_current_aio_context(), co);
+ */
 void qemu_aio_coroutine_enter(AioContext *ctx, Coroutine *co)
 {
     QSIMPLEQ_HEAD(, Coroutine) pending = QSIMPLEQ_HEAD_INITIALIZER(pending);
@@ -311,11 +523,54 @@ void qemu_aio_coroutine_enter(AioContext *ctx, Coroutine *co)
     }
 }
 
+/*
+ * 除了unit tests, 在以下调用qemu_coroutine_enter():
+ *   - block/aio_task.c|94| <<aio_task_pool_start_task>> qemu_coroutine_enter(qemu_coroutine_create(aio_task_co, task));
+ *   - block/blkdebug.c|915| <<resume_req_by_tag>> qemu_coroutine_enter(co);
+ *   - block/blkverify.c|217| <<blkverify_co_prwv>> qemu_coroutine_enter(co_a);
+ *   - block/blkverify.c|218| <<blkverify_co_prwv>> qemu_coroutine_enter(co_b);
+ *   - block/block-copy.c|976| <<block_copy_async>> qemu_coroutine_enter(call_state->co);
+ *   - block/export/vduse-blk.c|112| <<vduse_blk_vq_handler>> qemu_coroutine_enter(co);
+ *   - block/export/vhost-user-blk-server.c|102| <<vu_blk_process_vq>> qemu_coroutine_enter(co);
+ *   - block/mirror.c|469| <<mirror_perform>> qemu_coroutine_enter(co);
+ *   - block/nvme.c|1169| <<nvme_rw_cb_bh>> qemu_coroutine_enter(data->co);
+ *   - block/qed.c|329| <<qed_need_check_timer_cb>> qemu_coroutine_enter(co);
+ *   - block/qed.c|593| <<bdrv_qed_open>> qemu_coroutine_enter(qemu_coroutine_create(bdrv_qed_open_entry, &qoc));
+ *   - block/quorum.c|332| <<quorum_rewrite_bad_versions>> qemu_coroutine_enter(co);
+ *   - block/quorum.c|630| <<read_quorum_children>> qemu_coroutine_enter(co);
+ *   - block/quorum.c|744| <<quorum_co_pwritev>> qemu_coroutine_enter(co);
+ *   - hw/9pfs/9p.c|4181| <<pdu_submit>> qemu_coroutine_enter(co);
+ *   - hw/9pfs/9p.c|4338| <<v9fs_reset>> qemu_coroutine_enter(co);
+ *   - hw/9pfs/coth.c|30| <<coroutine_enter_cb>> qemu_coroutine_enter(co);
+ *   - hw/9pfs/coth.c|37| <<coroutine_enter_func>> qemu_coroutine_enter(co);
+ *   - hw/remote/remote-obj.c|125| <<remote_object_machine_done>> qemu_coroutine_enter(co);
+ *   - migration/colo.c|153| <<secondary_vm_do_failover>> qemu_coroutine_enter(mis->colo_incoming_co);
+ *   - migration/migration.c|868| <<migration_incoming_process>> qemu_coroutine_enter(co);
+ *   - migration/rdma.c|3328| <<rdma_cm_poll_handler>> qemu_coroutine_enter(mis->loadvm_co);
+ *   - nbd/server.c|3270| <<rdma_cm_poll_handler>> qemu_coroutine_enter(co);
+ *   - net/colo-compare.c|825| <<compare_chr_send>> qemu_coroutine_enter(sendco->co);
+ *   - net/filter-mirror.c|128| <<filter_send>> qemu_coroutine_enter(co);
+ *   - qemu-img.c|2079| <<convert_co_do_copy>> qemu_coroutine_enter(s->co[i]);
+ *   - qemu-img.c|2140| <<convert_do_copy>> qemu_coroutine_enter(s->co[i]);
+ *   - scsi/qemu-pr-helper.c|817| <<accept_client>> qemu_coroutine_enter(prh->co);
+ *   - tools/i386/qemu-vmsr-helper.c|296| <<accept_client>> qemu_coroutine_enter(vmsrh->co);
+ *   - util/qemu-coroutine-io.c|78| <<fd_coroutine_enter>> qemu_coroutine_enter(data->co);
+ *   - util/qemu-coroutine.c|356| <<qemu_coroutine_enter_if_inactive>> qemu_coroutine_enter(co);
+ */
 void qemu_coroutine_enter(Coroutine *co)
 {
     qemu_aio_coroutine_enter(qemu_get_current_aio_context(), co);
 }
 
+/*
+ * called by:
+ *   - block/blkverify.c|179| <<blkverify_do_test_req>> qemu_coroutine_enter_if_inactive(r->co);
+ *   - block/blkverify.c|192| <<blkverify_do_raw_req>> qemu_coroutine_enter_if_inactive(r->co);
+ *   - block/quorum.c|293| <<quorum_rewrite_entry>> qemu_coroutine_enter_if_inactive(acb->co);
+ *   - block/quorum.c|606| <<read_quorum_children_entry>> qemu_coroutine_enter_if_inactive(acb->co);
+ *   - block/quorum.c|724| <<write_quorum_entry>> qemu_coroutine_enter_if_inactive(acb->co);
+ *   - hw/9pfs/xen-9p-backend.c|321| <<xen_9pfs_bh>> qemu_coroutine_enter_if_inactive(ring->co);
+ */
 void qemu_coroutine_enter_if_inactive(Coroutine *co)
 {
     if (!qemu_coroutine_entered(co)) {
@@ -323,6 +578,9 @@ void qemu_coroutine_enter_if_inactive(Coroutine *co)
     }
 }
 
+/*
+ * 特别多qemu_coroutine_yield()的调用
+ */
 void coroutine_fn qemu_coroutine_yield(void)
 {
     Coroutine *self = qemu_coroutine_self();
@@ -339,28 +597,90 @@ void coroutine_fn qemu_coroutine_yield(void)
     qemu_coroutine_switch(self, to, COROUTINE_YIELD);
 }
 
+/*
+ * called by:
+ *   - block/io_uring.c|219| <<luring_process_completions>> if (!qemu_coroutine_entered(luringcb->co)) {
+ *   - block/linux-aio.c|108| <<qemu_laio_process_completion>> if (!qemu_coroutine_entered(laiocb->co)) {
+ *   - hw/9pfs/xen-9p-backend.c|312| <<xen_9pfs_bh>> wait = ring->co != NULL && qemu_coroutine_entered(ring->co);
+ *   - nbd/server.c|776| <<nbd_server_tls_handshake>> if (!qemu_coroutine_entered(data->co)) {
+ *   - tests/unit/test-coroutine.c|62| <<verify_entered_step_2>> g_assert(qemu_coroutine_entered(caller));
+ *   - tests/unit/test-coroutine.c|63| <<verify_entered_step_2>> g_assert(qemu_coroutine_entered(qemu_coroutine_self()));
+ *   - tests/unit/test-coroutine.c|67| <<verify_entered_step_2>> g_assert(qemu_coroutine_entered(caller));
+ *   - tests/unit/test-coroutine.c|68| <<verify_entered_step_2>> g_assert(qemu_coroutine_entered(qemu_coroutine_self()));
+ *   - tests/unit/test-coroutine.c|76| <<verify_entered_step_1>> g_assert(qemu_coroutine_entered(self));
+ *   - tests/unit/test-coroutine.c|79| <<verify_entered_step_1>> g_assert(!qemu_coroutine_entered(coroutine));
+ *   - tests/unit/test-coroutine.c|81| <<verify_entered_step_1>> g_assert(!qemu_coroutine_entered(coroutine));
+ *   - tests/unit/test-coroutine.c|90| <<test_entered>> g_assert(!qemu_coroutine_entered(coroutine));
+ *   - util/qemu-coroutine.c|355| <<qemu_coroutine_enter_if_inactive>> if (!qemu_coroutine_entered(co)) {
+ */
 bool qemu_coroutine_entered(Coroutine *co)
 {
     return co->caller;
 }
 
+/*
+ * called by:
+ *   - block.c|7561| <<bdrv_co_enter>> AioContext *old_ctx = qemu_coroutine_get_aio_context(self);
+ *   - io/channel.c|605| <<qio_channel_restart_read>> qemu_coroutine_get_aio_context(co));
+ *   - io/channel.c|620| <<qio_channel_restart_write>> qemu_coroutine_get_aio_context(co));
+ *   - io/channel.c|628| <<qio_channel_set_fd_handlers>> qemu_coroutine_get_aio_context(qemu_coroutine_self()) :
+ *   - io/channel.c|709| <<qio_channel_yield>> ioc_ctx = qemu_coroutine_get_aio_context(qemu_coroutine_self());
+ *   - util/vhost-user-server.c|441| <<vhost_user_server_attach_aio_context>> AioContext *co_ctx = qemu_coroutine_get_aio_context(server->co_trip);
+ */
 AioContext *qemu_coroutine_get_aio_context(Coroutine *co)
 {
     return co->ctx;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|1954| <<virtio_blk_device_realize>> qemu_coroutine_inc_pool_size(conf->num_queues * conf->queue_size / 2);
+ */
 void qemu_coroutine_inc_pool_size(unsigned int additional_pool_size)
 {
+    /*
+     * 在以下使用global_pool_lock:
+     *   - util/qemu-coroutine.c|72| <<QSLIST_HEAD>> static QemuMutex global_pool_lock;
+     *   - util/qemu-coroutine.c|233| <<coroutine_pool_refill_local>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|255| <<coroutine_pool_put_global>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|546| <<qemu_coroutine_inc_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|556| <<qemu_coroutine_dec_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|602| <<qemu_coroutine_init>> qemu_mutex_init(&global_pool_lock);
+     */
     QEMU_LOCK_GUARD(&global_pool_lock);
+    /*
+     * 在以下使用global_pool_max_size:
+     *   - util/qemu-coroutine.c|70| <<QSLIST_HEAD>> static unsigned int global_pool_max_size = COROUTINE_POOL_BATCH_MAX_SIZE;
+     *   - util/qemu-coroutine.c|165| <<coroutine_pool_put_global>> unsigned int max = MIN(global_pool_max_size, global_pool_hard_max_size);
+     *   - util/qemu-coroutine.c|360| <<qemu_coroutine_inc_pool_size>> global_pool_max_size += additional_pool_size;
+     *   - util/qemu-coroutine.c|366| <<qemu_coroutine_dec_pool_size>> global_pool_max_size -= removing_pool_size;
+     */
     global_pool_max_size += additional_pool_size;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|2002| <<virtio_blk_device_unrealize>> qemu_coroutine_dec_pool_size(conf->num_queues * conf->queue_size / 2)
+ */
 void qemu_coroutine_dec_pool_size(unsigned int removing_pool_size)
 {
+    /*
+     * 在以下使用global_pool_lock:
+     *   - util/qemu-coroutine.c|72| <<QSLIST_HEAD>> static QemuMutex global_pool_lock;
+     *   - util/qemu-coroutine.c|233| <<coroutine_pool_refill_local>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|255| <<coroutine_pool_put_global>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|546| <<qemu_coroutine_inc_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|556| <<qemu_coroutine_dec_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|602| <<qemu_coroutine_init>> qemu_mutex_init(&global_pool_lock);
+     */
     QEMU_LOCK_GUARD(&global_pool_lock);
     global_pool_max_size -= removing_pool_size;
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|400| <<qemu_coroutine_init>> global_pool_hard_max_size = get_global_pool_hard_max_size();
+ */
 static unsigned int get_global_pool_hard_max_size(void)
 {
 #ifdef __linux__
@@ -394,8 +714,25 @@ static unsigned int get_global_pool_hard_max_size(void)
     return UINT_MAX;
 }
 
+/*
+ * 只在此处使用qemu_coroutine_init()
+ */
 static void __attribute__((constructor)) qemu_coroutine_init(void)
 {
+    /*
+     * 在以下使用global_pool_lock:
+     *   - util/qemu-coroutine.c|72| <<QSLIST_HEAD>> static QemuMutex global_pool_lock;
+     *   - util/qemu-coroutine.c|233| <<coroutine_pool_refill_local>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|255| <<coroutine_pool_put_global>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|546| <<qemu_coroutine_inc_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|556| <<qemu_coroutine_dec_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|602| <<qemu_coroutine_init>> qemu_mutex_init(&global_pool_lock);
+     */
     qemu_mutex_init(&global_pool_lock);
+    /*
+     * 在以下使用global_pool_hard_max_size:
+     *   - util/qemu-coroutine.c|200| <<coroutine_pool_put_global>> unsigned int max = MIN(global_pool_max_size, global_pool_hard_max_size);
+     *   - util/qemu-coroutine.c|546| <<qemu_coroutine_init>> global_pool_hard_max_size = get_global_pool_hard_max_size();
+     */
     global_pool_hard_max_size = get_global_pool_hard_max_size();
 }
-- 
2.39.5 (Apple Git-154)

