From e61bc3745044d3c9e14807dd34604e1ef33d8e0b Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang@oracle.com>
Date: Thu, 15 Nov 2018 16:08:58 +0800
Subject: [PATCH 1/1] qemu for 3.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-all.c                          |   85 +-
 block.c                                      |  108 ++
 block/block-backend.c                        |   56 +
 block/file-posix.c                           |  257 ++++
 block/io.c                                   |   12 +
 block/nvme.c                                 |  134 +++
 block/raw-format.c                           |  367 +++++-
 blockdev.c                                   |   78 ++
 bootdevice.c                                 |   27 +
 data/drive_config_groups.txt                 |    6 +
 data/index.txt                               |   15 +
 data/info_mtree.txt                          |  420 +++++++
 data/notes-irq.txt                           |   14 +
 data/qemu_options.txt                        |  722 +++++++++++
 data/qom-tree.txt                            |  262 ++++
 data/vm_config_groups.txt                    |   33 +
 exec.c                                       |  414 ++++++-
 hmp.c                                        |    7 +
 hw/block/dataplane/virtio-blk.c              |  221 ++++
 hw/block/nvme.c                              |  115 ++
 hw/block/virtio-blk.c                        | 1161 ++++++++++++++++++
 hw/core/bus.c                                |   88 ++
 hw/core/irq.c                                |   62 +
 hw/core/machine.c                            |  140 ++-
 hw/core/qdev-fw.c                            |   13 +
 hw/core/qdev-properties-system.c             |   66 +
 hw/core/qdev-properties.c                    |   71 ++
 hw/core/qdev.c                               |  293 +++++
 hw/core/reset.c                              |   41 +
 hw/core/sysbus.c                             |   25 +
 hw/i386/intel_iommu.c                        |   12 +
 hw/i386/kvm/apic.c                           |   61 +
 hw/i386/kvm/clock.c                          |   32 +
 hw/i386/pc.c                                 |   91 ++
 hw/i386/pc_piix.c                            |   55 +-
 hw/i386/pc_q35.c                             |   24 +
 hw/i386/x86-iommu.c                          |    6 +
 hw/net/e1000.c                               |   37 +
 hw/nvram/fw_cfg.c                            |   13 +
 hw/pci-host/piix.c                           |  152 +++
 hw/pci/msi.c                                 |   30 +
 hw/pci/msix.c                                |   45 +
 hw/pci/pci.c                                 |  410 +++++++
 hw/pci/pci_host.c                            |   11 +
 hw/vfio/common.c                             |   65 +
 hw/vfio/pci.c                                |  170 +++
 hw/virtio/virtio-balloon.c                   |    6 +
 hw/virtio/virtio-bus.c                       |  156 +++
 hw/virtio/virtio-pci.c                       |  281 +++++
 hw/virtio/virtio-pci.h                       |   12 +
 hw/virtio/virtio.c                           | 1084 +++++++++++++++++
 include/block/aio.h                          |    9 +
 include/block/block_int.h                    |  165 ++-
 include/exec/cpu-all.h                       |    2 +
 include/exec/memory.h                        |  153 +++
 include/exec/ram_addr.h                      |   11 +
 include/hw/boards.h                          |   16 +
 include/hw/i386/pc.h                         |   77 +-
 include/hw/pci/pci.h                         |    8 +
 include/hw/pci/pci_bus.h                     |    1 +
 include/hw/pci/pci_host.h                    |    1 +
 include/hw/qdev-core.h                       |   14 +
 include/hw/qdev-properties.h                 |   51 +
 include/hw/sysbus.h                          |    1 +
 include/hw/virtio/virtio-blk.h               |    1 +
 include/hw/virtio/virtio-bus.h               |   16 +
 include/hw/virtio/virtio.h                   |  160 +++
 include/qapi/qmp/qobject.h                   |    3 +
 include/qemu/module.h                        |   18 +
 include/qom/object.h                         |   48 +-
 include/standard-headers/linux/virtio_ring.h |    4 +
 include/sysemu/accel.h                       |    1 +
 include/sysemu/iothread.h                    |   14 +
 include/sysemu/kvm_int.h                     |    1 +
 iothread.c                                   |  171 +++
 linux-headers/linux/kvm.h                    |    4 +
 memory.c                                     | 1040 +++++++++++++++-
 migration/migration.c                        |   32 +
 numa.c                                       |    4 +
 qapi/qapi-visit-core.c                       |    1 +
 qapi/qobject-input-visitor.c                 |   10 +
 qdev-monitor.c                               |  228 ++++
 qom/container.c                              |   84 ++
 qom/object.c                                 | 1651 +++++++++++++++++++++++++-
 qom/object_interfaces.c                      |    3 +
 qom/qom-qobject.c                            |   47 +
 target/i386/cpu.c                            |   16 +
 target/i386/kvm.c                            |    4 +
 ui/console.c                                 |    6 +
 util/aio-posix.c                             |  117 ++
 util/async.c                                 |   46 +
 util/cutils.c                                |   17 +
 util/event_notifier-posix.c                  |   49 +
 util/iohandler.c                             |    9 +
 util/main-loop.c                             |    4 +
 util/module.c                                |   59 +-
 util/qemu-config.c                           |   95 ++
 util/qemu-option.c                           |   31 +
 util/qemu-thread-posix.c                     |   14 +
 util/thread-pool.c                           |    3 +
 util/vfio-helpers.c                          |   58 +
 vl.c                                         |   92 +-
 102 files changed, 12700 insertions(+), 36 deletions(-)
 create mode 100644 data/drive_config_groups.txt
 create mode 100644 data/index.txt
 create mode 100644 data/info_mtree.txt
 create mode 100644 data/notes-irq.txt
 create mode 100644 data/qemu_options.txt
 create mode 100644 data/qom-tree.txt
 create mode 100644 data/vm_config_groups.txt

diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index eb7db92..7943d3a 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -124,6 +124,15 @@ bool kvm_gsi_direct_mapping;
 bool kvm_allowed;
 bool kvm_readonly_mem_allowed;
 bool kvm_vm_attributes_allowed;
+/*
+ * 设置的地方:
+ *   - accel/kvm/kvm-all.c|1676| <<kvm_init>> kvm_direct_msi_allowed = (kvm_check_extension(s, KVM_CAP_SIGNAL_MSI) > 0);
+ *
+ * 使用的地方:
+ *   - accel/kvm/kvm-all.c|993| <<kvm_init_irq_routing>> if (!kvm_direct_msi_allowed) {
+ *   - accel/kvm/kvm-all.c|1134| <<kvm_irqchip_get_virq>> if (!kvm_direct_msi_allowed && s->irq_routes->nr == s->gsi_count) {
+ *   - accel/kvm/kvm-all.c|1171| <<kvm_irqchip_send_msi>> if (kvm_direct_msi_allowed) {
+ */
 bool kvm_direct_msi_allowed;
 bool kvm_ioeventfd_any_length_allowed;
 bool kvm_msi_use_devid;
@@ -271,9 +280,15 @@ static int kvm_set_user_memory_region(KVMMemoryListener *kml, KVMSlot *slot, boo
         /* Set the slot size to 0 before setting the slot to the desired
          * value. This is needed based on KVM commit 75d61fbc. */
         mem.memory_size = 0;
+	/*
+	 * 设置GPA到HVA的映射
+	 */
         kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);
     }
     mem.memory_size = slot->memory_size;
+    /*
+     * 设置GPA到HVA的映射
+     */
     ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);
     slot->old_flags = mem.flags;
     trace_kvm_set_user_memory(mem.slot, mem.flags, mem.guest_phys_addr,
@@ -713,6 +728,16 @@ kvm_check_extension_list(KVMState *s, const KVMCapabilityInfo *list)
     return NULL;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|793| <<kvm_region_add>> kvm_set_phys_mem(kml, section, true);
+ *   - accel/kvm/kvm-all.c|801| <<kvm_region_del>> kvm_set_phys_mem(kml, section, false);
+ *
+ * 这个函数主要就是得到MemoryRegionSection在address_space中的位置,这个就是虚
+ * 拟机的物理地址,函数中是start_addr,,然后通过memory_region_get_ram_ptr得到对
+ * 应其对应的qemu的HVA地址,函数中是ram,当然还有大小的size以及这块内存的flags,
+ * 这些参数组成了一个KVMSlot,之后传递给kvm_set_user_memory_region.
+ */
 static void kvm_set_phys_mem(KVMMemoryListener *kml,
                              MemoryRegionSection *section, bool add)
 {
@@ -723,8 +748,18 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
     hwaddr start_addr, size;
     void *ram;
 
+    /*
+     * 所有把ram设置成true的地方:
+     *   - memory.c|1986| <<memory_region_init_ram_shared_nomigrate>> mr->ram = true;
+     *   - memory.c|2004| <<memory_region_init_resizeable_ram>> mr->ram = true;
+     *   - memory.c|2023| <<memory_region_init_ram_from_file>> mr->ram = true;
+     *   - memory.c|2040| <<memory_region_init_ram_from_fd>> mr->ram = true;
+     *   - memory.c|2055| <<memory_region_init_ram_ptr>> mr->ram = true;
+     *   - memory.c|2118| <<memory_region_init_rom_nomigrate>> mr->ram = true;
+     */
     if (!memory_region_is_ram(mr)) {
         if (writeable || !kvm_readonly_mem_allowed) {
+            /* 设备MR不是RAM但可以写，那么这里直接return不注册到kvm里面 */
             return;
         } else if (!mr->romd_mode) {
             /* If the memory device is not in romd_mode, then we actually want
@@ -778,6 +813,10 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
     }
 }
 
+/*
+ * used by:
+ *   - accel/kvm/kvm-all.c|918| <<kvm_memory_listener_register>> kml->listener.region_add = kvm_region_add;
+ */
 static void kvm_region_add(MemoryListener *listener,
                            MemoryRegionSection *section)
 {
@@ -877,6 +916,13 @@ static void kvm_io_ioeventfd_del(MemoryListener *listener,
     }
 }
 
+/*
+ * 只被两处调用:
+ *   - accel/kvm/kvm-all.c|1727| <<kvm_init>> kvm_memory_listener_register(s, &s->memory_listener,
+ *                                                                         &address_space_memory, 0);
+ *   - target/i386/kvm.c|1373| <<register_smram_listener>> kvm_memory_listener_register(kvm_state, &smram_listener,
+ *                                                                                      &smram_address_space, 1);
+ */
 void kvm_memory_listener_register(KVMState *s, KVMMemoryListener *kml,
                                   AddressSpace *as, int as_id)
 {
@@ -1122,11 +1168,19 @@ static KVMMSIRoute *kvm_lookup_msi_route(KVMState *s, MSIMessage msg)
     return NULL;
 }
 
+/*
+ * called only by:
+ *   - hw/i386/kvm/apic.c|185| <<kvm_send_msi>> ret = kvm_irqchip_send_msi(kvm_state, *msg);
+ */
 int kvm_irqchip_send_msi(KVMState *s, MSIMessage msg)
 {
     struct kvm_msi msi;
     KVMMSIRoute *route;
 
+    /*
+     * 在kvm上依赖host是否支持KVM_CAP_SIGNAL_MSI(依赖CONFIG_HAVE_KVM_MSI)
+     * 测试机器支持
+     */
     if (kvm_direct_msi_allowed) {
         msi.address_lo = (uint32_t)msg.address;
         msi.address_hi = msg.address >> 32;
@@ -1134,6 +1188,9 @@ int kvm_irqchip_send_msi(KVMState *s, MSIMessage msg)
         msi.flags = 0;
         memset(msi.pad, 0, sizeof(msi.pad));
 
+	/*
+	 * 内核的处理函数是kvm_send_userspace_msi()
+	 */
         return kvm_vm_ioctl(s, KVM_SIGNAL_MSI, &msi);
     }
 
@@ -1479,6 +1536,10 @@ bool kvm_vcpu_id_is_valid(int vcpu_id)
     return vcpu_id >= 0 && vcpu_id < kvm_max_vcpu_id(s);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2544| <<kvm_accel_class_init>> ac->init_machine = kvm_init;
+ */
 static int kvm_init(MachineState *ms)
 {
     MachineClass *mc = MACHINE_GET_CLASS(ms);
@@ -1679,6 +1740,16 @@ static int kvm_init(MachineState *ms)
         goto err;
     }
 
+    /*
+     * QEMU和KVM 都实现了对中断芯片的模拟,这是由于历史原因造成的.早在KVM诞生之前,
+     * QEMU就提供了一整套对设备的模拟,包括中断芯片.而KVM诞生之后,为了进一步提高中
+     * 断性能,因此又在KVM中实现了一套中断芯片.我们可以通过QEMU的启动参数
+     * kernel-irqchip来决定使用谁的中断芯片(irq chip).
+     *
+     *   on: KVM 模拟全部
+     *   split: QEMU模拟IOAPIC和PIC,KVM模拟LAPIC
+     *   off: QEMU 模拟全部
+     */
     if (machine_kernel_irqchip_allowed(ms)) {
         kvm_irqchip_create(ms, s);
     }
@@ -2537,6 +2608,9 @@ int kvm_get_one_reg(CPUState *cs, uint64_t id, void *target)
     return r;
 }
 
+/*
+ * TypeInfo kvm_accel_type.class_init = kvm_accel_class_init()
+ */
 static void kvm_accel_class_init(ObjectClass *oc, void *data)
 {
     AccelClass *ac = ACCEL_CLASS(oc);
@@ -2547,11 +2621,20 @@ static void kvm_accel_class_init(ObjectClass *oc, void *data)
 
 static const TypeInfo kvm_accel_type = {
     .name = TYPE_KVM_ACCEL,
-    .parent = TYPE_ACCEL,
+    .parent = TYPE_ACCEL,  // accel_type: class_size是AccelClass, instance_size是AccelState
     .class_init = kvm_accel_class_init,
     .instance_size = sizeof(KVMState),
 };
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
 static void kvm_type_init(void)
 {
     type_register_static(&kvm_accel_type);
diff --git a/block.c b/block.c
index 39f373e..e747a6a 100644
--- a/block.c
+++ b/block.c
@@ -315,6 +315,9 @@ void bdrv_register(BlockDriver *bdrv)
     QLIST_INSERT_HEAD(&bdrv_drivers, bdrv, list);
 }
 
+/*
+ * 核心思想是分配一个BlockDriverState,简单初始化然后链接入all_bdrv_states
+ */
 BlockDriverState *bdrv_new(void)
 {
     BlockDriverState *bs;
@@ -355,6 +358,15 @@ static BlockDriver *bdrv_do_find_format(const char *format_name)
     return NULL;
 }
 
+/*
+ * called by:
+ *   - block.c|1350| <<bdrv_open_common>> drv = bdrv_find_format(driver_name);
+ *   - block.c|1550| <<bdrv_fill_options>> drv = bdrv_find_format(drvname);
+ *   - block.c|2672| <<bdrv_open_inherit>> drv = bdrv_find_format(drvname);
+ *   - block.c|4703| <<bdrv_img_create>> drv = bdrv_find_format(fmt);
+ *   - block/create.c|71| <<qmp_blockdev_create>> BlockDriver *drv = bdrv_find_format(fmt);
+ *   - block/vvfat.c|3162| <<enable_write_target>> bdrv_qcow = bdrv_find_format("qcow");
+ */
 BlockDriver *bdrv_find_format(const char *format_name)
 {
     BlockDriver *drv1;
@@ -1361,6 +1373,7 @@ static int bdrv_open_common(BlockDriverState *bs, BlockBackend *file,
     }
 
     if (file != NULL) {
+        /* BlockDriverState */
         filename = blk_bs(file)->filename;
     } else {
         /*
@@ -1529,6 +1542,10 @@ static void parse_json_protocol(QDict *options, const char **pfilename,
  * The BDRV_O_PROTOCOL flag in *flags will be set or cleared accordingly if a
  * block driver has been specified explicitly.
  */
+/*
+ * called only by:
+ *   - block.c|2663| <<bdrv_open_inherit>> ret = bdrv_fill_options(&options, filename, &flags, &local_err);
+ */
 static int bdrv_fill_options(QDict **options, const char *filename,
                              int *flags, Error **errp)
 {
@@ -1954,6 +1971,12 @@ int bdrv_child_try_set_perm(BdrvChild *c, uint64_t perm, uint64_t shared,
     return 0;
 }
 
+/*
+ * called by only:
+ *   - block.c|1686| <<bdrv_child_perm>> bs->drv->bdrv_child_perm(bs, c, role, reopen_queue
+ *
+ * BlockDriver bdrv_raw.bdrv_child_perm = bdrv_filter_default_perms()
+ */
 void bdrv_filter_default_perms(BlockDriverState *bs, BdrvChild *c,
                                const BdrvChildRole *role,
                                BlockReopenQueue *reopen_queue,
@@ -2112,6 +2135,17 @@ static void bdrv_replace_child(BdrvChild *child, BlockDriverState *new_bs)
     }
 }
 
+/*
+ * called by:
+ *   - block.c|2180| <<bdrv_attach_child>> child = bdrv_root_attach_child(child_bs, child_name, child_role,
+ *   - block/block-backend.c|399| <<blk_new_open>> blk->root = bdrv_root_attach_child(bs, "root", &child_root,
+ *   - block/block-backend.c|804| <<blk_insert_bs>> blk->root = bdrv_root_attach_child(bs, "root", &child_root,
+ *   - blockjob.c|211| <<block_job_add_bdrv>> c = bdrv_root_attach_child(bs, name, &child_job, perm, shared_perm,
+ *
+ * 如果是blockdev_init()-->blk_new_open()调用进来的
+ *    403     blk->root = bdrv_root_attach_child(bs, "root", &child_root,
+ *    404                                        perm, BLK_PERM_ALL, blk, errp);
+ */
 BdrvChild *bdrv_root_attach_child(BlockDriverState *child_bs,
                                   const char *child_name,
                                   const BdrvChildRole *child_role,
@@ -2143,12 +2177,39 @@ BdrvChild *bdrv_root_attach_child(BlockDriverState *child_bs,
     return child;
 }
 
+/*
+ * (gdb) bt
+ * #0  bdrv_attach_child (parent_bs=0x5555568a3160, child_bs=0x5555568a9780, child_name=0x555555fc1a52 "file", child_role=0x55555654fe80 <child_file>, errp=0x7fffffffda40) at block.c:2151
+ * #1  0x0000555555c88b17 in bdrv_open_child (filename=0x0, options=0x5555568a7570, bdref_key=0x555555fc1a52 "file", parent=0x5555568a3160, child_role=0x55555654fe80 <child_file>, allow_none=false, 
+ *     errp=0x7fffffffda40) at block.c:2437
+ * #2  0x0000555555c98c91 in raw_open (bs=0x5555568a3160, options=0x5555568a7570, flags=8194, errp=0x7fffffffda40) at block/raw-format.c:425
+ * #3  0x0000555555c85f54 in bdrv_open_driver (bs=0x5555568a3160, drv=0x555556730540 <bdrv_raw>, node_name=0x0, options=0x5555568a7570, open_flags=8194, errp=0x7fffffffdb60) at block.c:1193
+ * #4  0x0000555555c8695b in bdrv_open_common (bs=0x5555568a3160, file=0x5555568adcc0, options=0x5555568a7570, errp=0x7fffffffdb60) at block.c:1457
+ * #5  0x0000555555c897e6 in bdrv_open_inherit (filename=0x5555568a1bd0 "/home/zhang/img/ubuntu1604/ubuntu1604.img", reference=0x0, options=0x5555568a7570, flags=8194, parent=0x0, child_role=0x0, 
+ *     errp=0x7fffffffdf50) at block.c:2752
+ * #6  0x0000555555c89c28 in bdrv_open (filename=0x5555568a1bd0 "/home/zhang/img/ubuntu1604/ubuntu1604.img", reference=0x0, options=0x5555568a0a20, flags=0, errp=0x7fffffffdf50) at block.c:2834
+ * #7  0x0000555555ce7f8a in blk_new_open (filename=0x5555568a1bd0 "/home/zhang/img/ubuntu1604/ubuntu1604.img", reference=0x0, options=0x5555568a0a20, flags=0, errp=0x7fffffffdf50)
+ *     at block/block-backend.c:375
+ * #8  0x00005555559cc068 in blockdev_init (file=0x5555568a1bd0 "/home/zhang/img/ubuntu1604/ubuntu1604.img", bs_opts=0x5555568a0a20, errp=0x7fffffffdf50) at blockdev.c:599
+ * #9  0x00005555559cd2d7 in drive_new (all_opts=0x5555567f37c0, block_default_type=IF_IDE) at blockdev.c:1093
+ * #10 0x00005555559ddafe in drive_init_func (opaque=0x555556845208, opts=0x5555567f37c0, errp=0x0) at vl.c:1143
+ * #11 0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b7620 <qemu_drive_opts>, func=0x5555559ddace <drive_init_func>, opaque=0x555556845208, errp=0x0) at util/qemu-option.c:1106
+ * #12 0x00005555559e60ed in main (argc=18, argv=0x7fffffffe3a8, envp=0x7fffffffe440) at vl.c:4450
+ *
+ * called by:
+ *   - block.c|2283| <<bdrv_set_backing_hd>> bs->backing = bdrv_attach_child(bs, backing_hd, "backing", &child_backing,
+ *   - block.c|2471| <<bdrv_open_child>> c = bdrv_attach_child(parent, bs, bdref_key, child_role, errp);
+ *   - block/quorum.c|1029| <<quorum_add_child>> child = bdrv_attach_child(bs, child_bs, indexstr, &child_format, errp);
+ */
 BdrvChild *bdrv_attach_child(BlockDriverState *parent_bs,
                              BlockDriverState *child_bs,
                              const char *child_name,
                              const BdrvChildRole *child_role,
                              Error **errp)
 {
+    /*
+     * 在测试的时候virtblk+raw, parent_bs是raw的, child_bs是file的
+     */
     BdrvChild *child;
     uint64_t perm, shared_perm;
 
@@ -2434,6 +2495,9 @@ BdrvChild *bdrv_open_child(const char *filename,
         return NULL;
     }
 
+    /*
+     * 在测试的时候virtblk+raw, parent是raw的, bs是file的
+     */
     c = bdrv_attach_child(parent, bs, bdref_key, child_role, errp);
     if (!c) {
         bdrv_unref(bs);
@@ -2612,6 +2676,7 @@ static BlockDriverState *bdrv_open_inherit(const char *filename,
         return bs;
     }
 
+    /* 核心思想是分配一个BlockDriverState,简单初始化然后链接入all_bdrv_states */
     bs = bdrv_new();
 
     /* NULL means an empty set of options */
@@ -2669,6 +2734,9 @@ static BlockDriverState *bdrv_open_inherit(const char *filename,
     /* See cautionary note on accessing @options above */
     drvname = qdict_get_try_str(options, "driver");
     if (drvname) {
+        /*
+	 * 在这里获得的"raw", "qcow2"等的BlockDriver
+	 */
         drv = bdrv_find_format(drvname);
         if (!drv) {
             error_setg(errp, "Unknown driver: '%s'", drvname);
@@ -2828,6 +2896,26 @@ close_and_fail:
     return NULL;
 }
 
+/*
+ * called by:
+ *   - block.c|2549| <<bdrv_append_temp_snapshot>> bs_snapshot = bdrv_open(NULL, NULL, snapshot_options, flags, errp);
+ *   - block.c|4816| <<bdrv_img_create>> bs = bdrv_open(full_backing, NULL, backing_options, back_flags,
+ *   - block/block-backend.c|375| <<blk_new_open>> bs = bdrv_open(filename, reference, options, flags, errp);
+ *   - block/crypto.c|557| <<block_crypto_co_create_opts_luks>> bs = bdrv_open(filename, NULL, NULL,
+ *   - block/parallels.c|648| <<parallels_co_create_opts>> bs = bdrv_open(filename, NULL, NULL,
+ *   - block/qcow.c|990| <<qcow_co_create_opts>> bs = bdrv_open(filename, NULL, NULL,
+ *   - block/qcow2.c|3120| <<qcow2_co_create_opts>> bs = bdrv_open(filename, NULL, NULL,
+ *   - block/qed.c|754| <<bdrv_qed_co_create_opts>> bs = bdrv_open(filename, NULL, NULL,
+ *   - block/sheepdog.c|1883| <<sd_create_prealloc>> bs = bdrv_open(NULL, NULL, qdict, BDRV_O_PROTOCOL | BDRV_O_RDWR, errp);
+ *   - block/vdi.c|922| <<vdi_co_create_opts>> bs_file = bdrv_open(filename, NULL, NULL,
+ *   - block/vhdx.c|1996| <<vhdx_co_create_opts>> bs = bdrv_open(filename, NULL, NULL,
+ *   - block/vpc.c|1110| <<vpc_co_create_opts>> bs = bdrv_open(filename, NULL, NULL,
+ *   - blockdev.c|679| <<bds_tree_init>> return bdrv_open(NULL, NULL, bs_opts, bdrv_flags, errp);
+ *   - blockdev.c|1824| <<external_snapshot_prepare>> state->new_bs = bdrv_open(new_image_file, snapshot_ref, options, flags,
+ *   - blockdev.c|2811| <<qmp_blockdev_change_medium>> medium_bs = bdrv_open(filename, NULL, options, bdrv_flags, errp);
+ *   - blockdev.c|3599| <<do_drive_backup>> target_bs = bdrv_open(`backup->target, NULL, options, flags, errp);
+ *   - blockdev.c|3954| <<qmp_drive_mirror>> target_bs = bdrv_open(arg->target, NULL, options, flags, errp);
+ */
 BlockDriverState *bdrv_open(const char *filename, const char *reference,
                             QDict *options, int flags, Error **errp)
 {
@@ -3137,6 +3225,10 @@ static void bdrv_reopen_perm(BlockReopenQueue *q, BlockDriverState *bs,
  * commit() for any other BDS that have been left in a prepare() state
  *
  */
+/*
+ * 只被如下调用:
+ *   - block.c|3059| <<bdrv_reopen_multiple>> if (bdrv_reopen_prepare(&bs_entry->state, bs_queue, &local_err)) {
+ */
 int bdrv_reopen_prepare(BDRVReopenState *reopen_state, BlockReopenQueue *queue,
                         Error **errp)
 {
@@ -3891,6 +3983,10 @@ static int qsort_strcmp(const void *a, const void *b)
     return strcmp(*(char *const *)a, *(char *const *)b);
 }
 
+/*
+ * called by only:
+ *   - blockdev.c|548| <<blockdev_init>> bdrv_iterate_format(bdrv_format_print, NULL);
+ */
 void bdrv_iterate_format(void (*it)(void *opaque, const char *name),
                          void *opaque)
 {
@@ -4082,6 +4178,12 @@ int bdrv_get_flags(BlockDriverState *bs)
     return bs->open_flags;
 }
 
+/*
+ * called by:
+ *   - block.c|4141| <<bdrv_has_zero_init>> return bs->drv->bdrv_has_zero_init(bs);
+ *
+ * BlockDriver bdrv_file.bdrv_has_zero_init = bdrv_has_zero_init_1()
+ */
 int bdrv_has_zero_init_1(BlockDriverState *bs)
 {
     return 1;
@@ -4862,6 +4964,12 @@ out:
 
 AioContext *bdrv_get_aio_context(BlockDriverState *bs)
 {
+    /*
+     * 初始化bs->aio_context的地方:
+     *   - block.c|335| <<bdrv_new>> bs->aio_context = qemu_get_aio_context();
+     *   - block.c|4995| <<bdrv_attach_aio_context>> bs->aio_context = new_context;
+     *   - block.c|4982| <<bdrv_detach_aio_context>> bs->aio_context = NULL;
+     */
     return bs ? bs->aio_context : qemu_get_aio_context();
 }
 
diff --git a/block/block-backend.c b/block/block-backend.c
index f2f75a9..9016023 100644
--- a/block/block-backend.c
+++ b/block/block-backend.c
@@ -38,6 +38,9 @@ typedef struct BlockBackendAioNotifier {
     QLIST_ENTRY(BlockBackendAioNotifier) list;
 } BlockBackendAioNotifier;
 
+/*
+ * 核心被drive_new()-->blockdev_init()分配
+ */
 struct BlockBackend {
     char *name;
     int refcnt;
@@ -314,6 +317,9 @@ static const BdrvChildRole child_root = {
  *
  * Return the new BlockBackend on success, null on failure.
  */
+/*
+ * 核心思想是分配和简单初始化一个BlockBackend, 并链入全局block_backends
+ */
 BlockBackend *blk_new(uint64_t perm, uint64_t shared_perm)
 {
     BlockBackend *blk;
@@ -346,6 +352,15 @@ BlockBackend *blk_new(uint64_t perm, uint64_t shared_perm)
  * though, so callers of this function have to be able to specify @filename and
  * @flags.
  */
+/*
+ * (gdb) bt
+ * #0  blk_new_open (filename=0x5555568a1bd0 "/home/zhang/img/ubuntu1604/ubuntu1604.img", reference=0x0, options=0x5555568a0a20, flags=0, errp=0x7fffffffdf50) at block/block-backend.c:354
+ * #1  0x00005555559cc068 in blockdev_init (file=0x5555568a1bd0 "/home/zhang/img/ubuntu1604/ubuntu1604.img", bs_opts=0x5555568a0a20, errp=0x7fffffffdf50) at blockdev.c:599
+ * #2  0x00005555559cd2d7 in drive_new (all_opts=0x5555567f37c0, block_default_type=IF_IDE) at blockdev.c:1093
+ * #3  0x00005555559ddafe in drive_init_func (opaque=0x555556845208, opts=0x5555567f37c0, errp=0x0) at vl.c:1143
+ * #4  0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b7620 <qemu_drive_opts>, func=0x5555559ddace <drive_init_func>, opaque=0x555556845208, errp=0x0) at util/qemu-option.c:1106
+ * #5  0x00005555559e60ed in main (argc=18, argv=0x7fffffffe3a8, envp=0x7fffffffe440) at vl.c:4450
+ */
 BlockBackend *blk_new_open(const char *filename, const char *reference,
                            QDict *options, int flags, Error **errp)
 {
@@ -371,7 +386,14 @@ BlockBackend *blk_new_open(const char *filename, const char *reference,
         perm |= BLK_PERM_RESIZE;
     }
 
+    /*
+     * 核心思想是分配和简单初始化一个BlockBackend, 并链入全局block_backends
+     */
     blk = blk_new(perm, BLK_PERM_ALL);
+    /*
+     * bs是BlockDriverState
+     * 调用bdrv_open_inherit()
+     */
     bs = bdrv_open(filename, reference, options, flags, errp);
     if (!bs) {
         blk_unref(blk);
@@ -1377,6 +1399,11 @@ static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset, int bytes,
     return &acb->common;
 }
 
+/*
+ * 只被block/block-backend.c:blk_aio_preadv()调用
+ * 1466     return blk_aio_prwv(blk, offset, qiov->size, qiov,
+ * 1467                         blk_aio_read_entry, flags, cb, opaque);
+ */
 static void blk_aio_read_entry(void *opaque)
 {
     BlkAioEmAIOCB *acb = opaque;
@@ -1472,6 +1499,19 @@ BlockAIOCB *blk_aio_pwritev(BlockBackend *blk, int64_t offset,
                         blk_aio_write_entry, flags, cb, opaque);
 }
 
+/*
+ * (gdb) bt
+ * #0  blk_aio_flush_entry (opaque=0x7fffe0000a40) at block/block-backend.c:1477
+ * #1  0x0000555555dd04e6 in coroutine_trampoline (i0=-536860144, i1=32767) at util/coroutine-ucontext.c:116
+ * #2  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #3  0x00007fffe7ffdda0 in ?? ()
+ * #4  0x0000000000000000 in ?? ()
+ *
+ * used only by:
+ *   - block/block-backend.c|1487| <<blk_aio_flush>> return blk_aio_prwv(blk, 0, 0, NULL, blk_aio_flush_entry, 0, cb, opaque);
+ *
+ * 在virtio block测试时 和下面的blk_aio_flush()是一个iothread
+ */
 static void blk_aio_flush_entry(void *opaque)
 {
     BlkAioEmAIOCB *acb = opaque;
@@ -1481,6 +1521,22 @@ static void blk_aio_flush_entry(void *opaque)
     blk_aio_complete(acb);
 }
 
+/*
+ * (gdb) bt
+ * #0  blk_aio_flush (blk=0x5555568a2d80, cb=0x5555558b1ba8 <virtio_blk_flush_complete>, opaque=0x7fffe0000960) at block/block-backend.c:1487
+ * #1  0x00005555558b2785 in virtio_blk_handle_flush (req=0x7fffe0000960, mrb=0x7fffe7ffe6d0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:456
+ * #2  0x00005555558b2d4c in virtio_blk_handle_request (req=0x7fffe0000960, mrb=0x7fffe7ffe6d0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:565
+ * #3  0x00005555558b2f51 in virtio_blk_handle_vq (s=0x5555579da580, vq=0x5555579e5b80) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:608
+ * #4  0x00005555558b5a8e in virtio_blk_data_plane_handle_output (vdev=0x5555579da580, vq=0x5555579e5b80) at /home/zhang/kvm/qemu-3.0.0/hw/block/dataplane/virtio-blk.c:164
+ * #5  0x00005555558ffebd in virtio_queue_notify_aio_vq (vq=0x5555579e5b80) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1518
+ * #6  0x0000555555902015 in virtio_queue_host_notifier_aio_read (n=0x5555579e5be8) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2391
+ * #7  0x0000555555db21a3 in aio_dispatch_handlers (ctx=0x5555568950c0) at util/aio-posix.c:406
+ * #8  0x0000555555db2d34 in aio_poll (ctx=0x5555568950c0, blocking=true) at util/aio-posix.c:692
+ * #9  0x00005555559d5f1a in iothread_run (opaque=0x555556894bc0) at iothread.c:64
+ * #10 0x0000555555db5d87 in qemu_thread_start (args=0x555556895490) at util/qemu-thread-posix.c:504
+ * #11 0x00007ffff47596ba in start_thread (arg=0x7fffe7fff700) at pthread_create.c:333
+ * #12 0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 BlockAIOCB *blk_aio_flush(BlockBackend *blk,
                           BlockCompletionFunc *cb, void *opaque)
 {
diff --git a/block/file-posix.c b/block/file-posix.c
index fe83cbf..01a44f3 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -398,6 +398,12 @@ static void raw_parse_flags(int bdrv_flags, int *open_flags)
     }
 }
 
+/*
+ * called by:
+ *   - block.c|1613| <<bdrv_fill_options>> drv->bdrv_parse_filename(filename, *options, &local_err);
+ *
+ * BlockDriver bdrv_file.bdrv_parse_filename = raw_parse_filename()
+ */
 static void raw_parse_filename(const char *filename, QDict *options,
                                Error **errp)
 {
@@ -658,6 +664,12 @@ fail:
     return ret;
 }
 
+/*
+ * called by:
+ *   - block.c|1200| <<bdrv_open_driver>> ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);
+ *
+ * BlockDriver bdrv_file.bdrv_file_open = raw_open()
+ */
 static int raw_open(BlockDriverState *bs, QDict *options, int flags,
                     Error **errp)
 {
@@ -823,6 +835,12 @@ static int raw_handle_perm_lock(BlockDriverState *bs,
     return ret;
 }
 
+/*
+ * called by:
+ *   - block.c|3210| <<bdrv_reopen_prepare>> ret = drv->bdrv_reopen_prepare(reopen_state, queue, &local_err);
+ *
+ * BlockDriver bdrv_file.bdrv_reopen_prepare = raw_reopen_prepare()
+ */
 static int raw_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
 {
@@ -918,6 +936,12 @@ out:
     return ret;
 }
 
+/*
+ * called by:
+ *   - block.c|3298| <<bdrv_reopen_commit>> drv->bdrv_reopen_commit(reopen_state);
+ *
+ * BlockDriver bdrv_file.bdrv_reopen_commit = raw_reopen_commit()
+ */
 static void raw_reopen_commit(BDRVReopenState *state)
 {
     BDRVRawReopenState *rs = state->opaque;
@@ -934,6 +958,12 @@ static void raw_reopen_commit(BDRVReopenState *state)
 }
 
 
+/*
+ * called by:
+ *   - block.c|3342| <<bdrv_reopen_abort>> drv->bdrv_reopen_abort(reopen_state);
+ *
+ * BlockDriver bdrv_file.bdrv_reopen_abort = raw_reopen_abort()
+ */
 static void raw_reopen_abort(BDRVReopenState *state)
 {
     BDRVRawReopenState *rs = state->opaque;
@@ -1013,6 +1043,12 @@ out:
 #endif
 }
 
+/*
+ * called by:
+ *   - block/io.c|162| <<bdrv_refresh_limits>> drv->bdrv_refresh_limits(bs, errp);
+ *
+ * BlockDriver bdrv_file.bdrv_refresh_limits = raw_refresh_limits()
+ */
 static void raw_refresh_limits(BlockDriverState *bs, Error **errp)
 {
     BDRVRawState *s = bs->opaque;
@@ -1122,6 +1158,10 @@ static ssize_t handle_aiocb_ioctl(RawPosixAIOData *aiocb)
     return 0;
 }
 
+/*
+ * called only by:
+ *   - block/file-posix.c|1753| <<aio_worker>> ret = handle_aiocb_flush(aiocb);
+ */
 static ssize_t handle_aiocb_flush(RawPosixAIOData *aiocb)
 {
     BDRVRawState *s = aiocb->bs->opaque;
@@ -1721,6 +1761,16 @@ out:
     return result;
 }
 
+/*
+ * 在worker thread处理的
+ * (gdb) bt
+ * #0  handle_aiocb_flush (aiocb=0x7fffe0000c00) at block/file-posix.c:1127
+ * #1  0x0000555555cf2dca in aio_worker (arg=0x7fffe0000c00) at block/file-posix.c:1753
+ * #2  0x0000555555daeb10 in worker_thread (opaque=0x7fffe0000c50) at util/thread-pool.c:105
+ * #3  0x0000555555db5d87 in qemu_thread_start (args=0x7fffe0000aa0) at util/qemu-thread-posix.c:504
+ * #4  0x00007ffff47596ba in start_thread (arg=0x7fff437fe700) at pthread_create.c:333
+ * #5  0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 static int aio_worker(void *arg)
 {
     RawPosixAIOData *aiocb = arg;
@@ -1780,6 +1830,20 @@ static int aio_worker(void *arg)
     return ret;
 }
 
+/*
+ * virtio block flush的例子 (和下发的主线在一个iothread中):
+ * #0  paio_submit_co_full (bs=0x5555568a9660, fd=16, offset=0, fd2=-1, offset2=0, qiov=0x0, bytes=0, type=8) at block/file-posix.c:1788
+ * #1  0x0000555555cf2fea in paio_submit_co (bs=0x5555568a9660, fd=16, offset=0, qiov=0x0, bytes=0, type=8) at block/file-posix.c:1815
+ * #2  0x0000555555cf32b9 in raw_co_flush_to_disk (bs=0x5555568a9660) at block/file-posix.c:1894
+ * #3  0x0000555555d032e8 in bdrv_co_flush (bs=0x5555568a9660) at block/io.c:2617
+ * #4  0x0000555555d03397 in bdrv_co_flush (bs=0x5555568a3040) at block/io.c:2654
+ * #5  0x0000555555cea60d in blk_co_flush (blk=0x5555568a2d80) at block/block-backend.c:1572
+ * #6  0x0000555555cea2a9 in blk_aio_flush_entry (opaque=0x7fffe0000a40) at block/block-backend.c:1480
+ * #7  0x0000555555dd04e6 in coroutine_trampoline (i0=-536860144, i1=32767) at util/coroutine-ucontext.c:116
+ * #8  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #9  0x00007fffe7ffdda0 in ?? ()
+ * #10 0x0000000000000000 in ?? ()
+ */
 static int paio_submit_co_full(BlockDriverState *bs, int fd,
                                int64_t offset, int fd2, int64_t offset2,
                                QEMUIOVector *qiov,
@@ -1844,6 +1908,28 @@ static int coroutine_fn raw_co_prw(BlockDriverState *bs, uint64_t offset,
     return paio_submit_co(bs, s->fd, offset, qiov, bytes, type);
 }
 
+/*
+ * (gdb) bt
+ * #0  raw_co_preadv (bs=0x5555568a9780, offset=7207198720, bytes=16384, qiov=0x7fffe00074a0, flags=0) at block/file-posix.c:1851
+ * #1  0x0000555555cff46a in bdrv_driver_preadv (bs=0x5555568a9780, offset=7207198720, bytes=16384, qiov=0x7fffe00074a0, flags=0) at block/io.c:1042
+ * #2  0x0000555555d00040 in bdrv_aligned_preadv (child=0x5555568ae260, req=0x7fffe45fec40, offset=7207198720, bytes=16384, align=1, qiov=0x7fffe00074a0, flags=0) at block/io.c:1359
+ * #3  0x0000555555d0054c in bdrv_co_preadv (child=0x5555568ae260, offset=7207198720, bytes=16384, qiov=0x7fffe00074a0, flags=0) at block/io.c:1455
+ * #4  0x0000555555c984fd in raw_co_preadv (bs=0x5555568a3160, offset=7207198720, bytes=16384, qiov=0x7fffe00074a0, flags=0) at block/raw-format.c:203
+ * #5  0x0000555555cff46a in bdrv_driver_preadv (bs=0x5555568a3160, offset=7207198720, bytes=16384, qiov=0x7fffe00074a0, flags=0) at block/io.c:1042
+ * #6  0x0000555555d00040 in bdrv_aligned_preadv (child=0x5555568a8650, req=0x7fffe45feea0, offset=7207198720, bytes=16384, align=1, qiov=0x7fffe00074a0, flags=0) at block/io.c:1359
+ * #7  0x0000555555d0054c in bdrv_co_preadv (child=0x5555568a8650, offset=7207198720, bytes=16384, qiov=0x7fffe00074a0, flags=0) at block/io.c:1455
+ * #8  0x0000555555ce96f7 in blk_co_preadv (blk=0x5555568a2ea0, offset=7207198720, bytes=16384, qiov=0x7fffe00074a0, flags=0) at block/block-backend.c:1163
+ * #9  0x0000555555ce9f34 in blk_aio_read_entry (opaque=0x7fffe0007d70) at block/block-backend.c:1387
+ * #10 0x0000555555dd04e6 in coroutine_trampoline (i0=-536866544, i1=32767) at util/coroutine-ucontext.c:116
+ * #11 0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #12 0x00007fffe7ffdda0 in ?? ()
+ * #13 0x0000000000000000 in ?? ()
+ *
+ * called by:
+ *   - block/io.c|1042| <<bdrv_driver_preadv>> return drv->bdrv_co_preadv(bs, offset, bytes, qiov, flags);
+ *
+ * BlockDriver bdrv_file.bdrv_co_preadv = raw_co_preadv()
+ */
 static int coroutine_fn raw_co_preadv(BlockDriverState *bs, uint64_t offset,
                                       uint64_t bytes, QEMUIOVector *qiov,
                                       int flags)
@@ -1851,6 +1937,12 @@ static int coroutine_fn raw_co_preadv(BlockDriverState *bs, uint64_t offset,
     return raw_co_prw(bs, offset, bytes, qiov, QEMU_AIO_READ);
 }
 
+/*
+ * called by:
+ *   - block/io.c|1088| <<bdrv_driver_pwritev>> ret = drv->bdrv_co_pwritev(bs, offset, bytes, qiov,
+ *
+ * BlockDriver bdrv_file.bdrv_co_pwritev = raw_co_pwritev()
+ */
 static int coroutine_fn raw_co_pwritev(BlockDriverState *bs, uint64_t offset,
                                        uint64_t bytes, QEMUIOVector *qiov,
                                        int flags)
@@ -1859,6 +1951,12 @@ static int coroutine_fn raw_co_pwritev(BlockDriverState *bs, uint64_t offset,
     return raw_co_prw(bs, offset, bytes, qiov, QEMU_AIO_WRITE);
 }
 
+/*
+ * called by:
+ *   - block/io.c|2953| <<bdrv_io_plug>> drv->bdrv_io_plug(bs);
+ *
+ * BlockDriver bdrv_file.bdrv_io_plug = raw_aio_plug()
+ */
 static void raw_aio_plug(BlockDriverState *bs)
 {
 #ifdef CONFIG_LINUX_AIO
@@ -1870,6 +1968,12 @@ static void raw_aio_plug(BlockDriverState *bs)
 #endif
 }
 
+/*
+ * called by:
+ *   - block/io.c|2966| <<bdrv_io_unplug>> drv->bdrv_io_unplug(bs);
+ *
+ * BlockDriver bdrv_file.bdrv_io_unplug = raw_aio_unplug()
+ */
 static void raw_aio_unplug(BlockDriverState *bs)
 {
 #ifdef CONFIG_LINUX_AIO
@@ -1881,6 +1985,25 @@ static void raw_aio_unplug(BlockDriverState *bs)
 #endif
 }
 
+/*
+ * virtio block flush的例子 (和下发的主线在一个iothread中):
+ * #0  paio_submit_co_full (bs=0x5555568a9660, fd=16, offset=0, fd2=-1, offset2=0, qiov=0x0, bytes=0, type=8) at block/file-posix.c:1788
+ * #1  0x0000555555cf2fea in paio_submit_co (bs=0x5555568a9660, fd=16, offset=0, qiov=0x0, bytes=0, type=8) at block/file-posix.c:1815
+ * #2  0x0000555555cf32b9 in raw_co_flush_to_disk (bs=0x5555568a9660) at block/file-posix.c:1894
+ * #3  0x0000555555d032e8 in bdrv_co_flush (bs=0x5555568a9660) at block/io.c:2617
+ * #4  0x0000555555d03397 in bdrv_co_flush (bs=0x5555568a3040) at block/io.c:2654
+ * #5  0x0000555555cea60d in blk_co_flush (blk=0x5555568a2d80) at block/block-backend.c:1572
+ * #6  0x0000555555cea2a9 in blk_aio_flush_entry (opaque=0x7fffe0000a40) at block/block-backend.c:1480
+ * #7  0x0000555555dd04e6 in coroutine_trampoline (i0=-536860144, i1=32767) at util/coroutine-ucontext.c:116
+ * #8  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #9  0x00007fffe7ffdda0 in ?? ()
+ * #10 0x0000000000000000 in ?? ()
+ *
+ * called by:
+ *   - block/io.c|2629| <<bdrv_co_flush>> ret = bs->drv->bdrv_co_flush_to_disk(bs);
+ *
+ * BlockDriver bdrv_file.bdrv_co_flush_to_disk = raw_co_flush_to_disk()
+ */
 static int raw_co_flush_to_disk(BlockDriverState *bs)
 {
     BDRVRawState *s = bs->opaque;
@@ -1894,6 +2017,12 @@ static int raw_co_flush_to_disk(BlockDriverState *bs)
     return paio_submit_co(bs, s->fd, 0, NULL, 0, QEMU_AIO_FLUSH);
 }
 
+/*
+ * called by:
+ *   - block.c|4976| <<bdrv_attach_aio_context>> bs->drv->bdrv_attach_aio_context(bs, new_context);
+ *
+ * BlockDriver bdrv_file.bdrv_attach_aio_context = raw_aio_attach_aio_context()
+ */
 static void raw_aio_attach_aio_context(BlockDriverState *bs,
                                        AioContext *new_context)
 {
@@ -1910,6 +2039,13 @@ static void raw_aio_attach_aio_context(BlockDriverState *bs,
 #endif
 }
 
+/*
+ * called by:
+ *   - block.c|3384| <<bdrv_close>> bs->drv->bdrv_close(bs);
+ *   - block/snapshot.c|221| <<bdrv_snapshot_goto>> drv->bdrv_close(bs);
+ *
+ * BlockDriver bdrv_file.bdrv_close = raw_close()
+ */
 static void raw_close(BlockDriverState *bs)
 {
     BDRVRawState *s = bs->opaque;
@@ -1951,6 +2087,12 @@ raw_regular_truncate(BlockDriverState *bs, int fd, int64_t offset,
     return thread_pool_submit_co(pool, aio_worker, acb);
 }
 
+/*
+ * called by:
+ *   - block/io.c|3193| <<bdrv_co_truncate>> ret = drv->bdrv_co_truncate(bs, offset, prealloc, errp);
+ *
+ * BlockDriver bdrv_file.bdrv_co_truncate = raw_co_truncate()
+ */
 static int coroutine_fn raw_co_truncate(BlockDriverState *bs, int64_t offset,
                                         PreallocMode prealloc, Error **errp)
 {
@@ -2137,6 +2279,12 @@ again:
     return size;
 }
 #else
+/*
+ * called by:
+ *   - block.c|751| <<refresh_total_sectors>> int64_t length = drv->bdrv_getlength(bs);
+ *
+ * BlockDriver bdrv_file.bdrv_getlength = raw_getlength()
+ */
 static int64_t raw_getlength(BlockDriverState *bs)
 {
     BDRVRawState *s = bs->opaque;
@@ -2156,6 +2304,12 @@ static int64_t raw_getlength(BlockDriverState *bs)
 }
 #endif
 
+/*
+ * called by:
+ *   - block.c|3824| <<bdrv_get_allocated_file_size>> return drv->bdrv_get_allocated_file_size(bs);
+ *
+ * BlockDriver bdrv_file.bdrv_get_allocated_file_size = raw_get_allocated_file_size()
+ */
 static int64_t raw_get_allocated_file_size(BlockDriverState *bs)
 {
     struct stat st;
@@ -2167,6 +2321,12 @@ static int64_t raw_get_allocated_file_size(BlockDriverState *bs)
     return (int64_t)st.st_blocks * 512;
 }
 
+/*
+ * called by:
+ *   - block.c|438| <<bdrv_create_co_entry>> ret = cco->drv->bdrv_co_create_opts(cco->filename, cco->opts, &local_err);
+ *
+ * BlockDriver bdrv_file.bdrv_co_create = raw_co_create()
+ */
 static int coroutine_fn
 raw_co_create(BlockdevCreateOptions *options, Error **errp)
 {
@@ -2268,6 +2428,12 @@ out:
     return result;
 }
 
+/*
+ * called by only:
+ *   - block.c|438| <<bdrv_create_co_entry>> ret = cco->drv->bdrv_co_create_opts(cco->filename, cco->opts, &local_err);
+ *
+ * BlockDriver bdrv_file.bdrv_co_create_opts = raw_co_create_opts()
+ */
 static int coroutine_fn raw_co_create_opts(const char *filename, QemuOpts *opts,
                                            Error **errp)
 {
@@ -2414,6 +2580,12 @@ static int find_allocation(BlockDriverState *bs, off_t start,
  *
  * 'bytes' is the max value 'pnum' should be set to.
  */
+/*
+ * called by:
+ *   - block/io.c|2141| <<bdrv_co_block_status>> ret = bs->drv->bdrv_co_block_status(bs, want_zero, aligned_offset,
+ *
+ * BlockDriver bdrv_file.bdrv_co_block_status = raw_co_block_status()
+ */
 static int coroutine_fn raw_co_block_status(BlockDriverState *bs,
                                             bool want_zero,
                                             int64_t offset,
@@ -2528,6 +2700,12 @@ static void check_cache_dropped(BlockDriverState *bs, Error **errp)
 }
 #endif /* __linux__ */
 
+/*
+ * called by:
+ *   - block.c|4417| <<bdrv_co_invalidate_cache>> bs->drv->bdrv_co_invalidate_cache(bs, &local_err);
+ *
+ * BlockDriver bdrv_file.bdrv_co_invalidate_cache = raw_co_invalidate_cache()
+ */
 static void coroutine_fn raw_co_invalidate_cache(BlockDriverState *bs,
                                                  Error **errp)
 {
@@ -2575,6 +2753,12 @@ static void coroutine_fn raw_co_invalidate_cache(BlockDriverState *bs,
 #endif /* !__linux__ */
 }
 
+/*
+ * called by:
+ *   - block/io.c|2799| <<bdrv_co_pdiscard>> ret = bs->drv->bdrv_co_pdiscard(bs, offset, num);
+ *
+ * BlockDriver bdrv_file.bdrv_co_pdiscard = raw_co_pdiscard()
+ */
 static coroutine_fn int
 raw_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)
 {
@@ -2583,6 +2767,12 @@ raw_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)
     return paio_submit_co(bs, s->fd, offset, NULL, bytes, QEMU_AIO_DISCARD);
 }
 
+/*
+ * called by:
+ *   - block/io.c|1523| <<bdrv_co_do_pwrite_zeroes>> ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num,
+ *
+ * BlockDriver bdrv_file.bdrv_co_pwrite_zeroes = raw_co_pwrite_zeroes()
+ */
 static int coroutine_fn raw_co_pwrite_zeroes(
     BlockDriverState *bs, int64_t offset,
     int bytes, BdrvRequestFlags flags)
@@ -2597,6 +2787,12 @@ static int coroutine_fn raw_co_pwrite_zeroes(
     return paio_submit_co(bs, s->fd, offset, NULL, bytes, operation);
 }
 
+/*
+ * called by:
+ *   - block.c|4205| <<bdrv_get_info>> return drv->bdrv_get_info(bs, bdi);
+ *
+ * BlockDriver bdrv_file.bdrv_get_info = raw_get_info()
+ */
 static int raw_get_info(BlockDriverState *bs, BlockDriverInfo *bdi)
 {
     BDRVRawState *s = bs->opaque;
@@ -2605,6 +2801,17 @@ static int raw_get_info(BlockDriverState *bs, BlockDriverInfo *bdi)
     return 0;
 }
 
+/*
+ * 主要被以下使用:
+ *   - block.c|2536| <<bdrv_append_temp_snapshot>> opts = qemu_opts_create(bdrv_qcow2.create_opts, NULL, 0,
+ *   - block.c|4757| <<bdrv_img_create>> if (!drv->create_opts) {
+ *   - block.c|4763| <<bdrv_img_create>> if (!proto_drv->create_opts) {
+ *   - block.c|4769| <<bdrv_img_create>> create_opts = qemu_opts_append(create_opts, drv->create_opts);
+ *   - block.c|4770| <<bdrv_img_create>> create_opts = qemu_opts_append(create_opts, proto_drv->create_opts);
+ *   - 最后就是qemu-img命令
+ *
+ * BlockDriver bdrv_file.create_opts = &raw_create_opts
+ */
 static QemuOptsList raw_create_opts = {
     .name = "raw-create-opts",
     .head = QTAILQ_HEAD_INITIALIZER(raw_create_opts.head),
@@ -2628,12 +2835,24 @@ static QemuOptsList raw_create_opts = {
     }
 };
 
+/*
+ * called by:
+ *   - block.c|1728| <<bdrv_check_perm>> return drv->bdrv_check_perm(bs, cumulative_perms,
+ *
+ * BlockDriver bdrv_file.bdrv_check_perm = raw_check_perm()
+ */
 static int raw_check_perm(BlockDriverState *bs, uint64_t perm, uint64_t shared,
                           Error **errp)
 {
     return raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, errp);
 }
 
+/*
+ * called by:
+ *   - block.c|1791| <<bdrv_set_perm>> drv->bdrv_set_perm(bs, cumulative_perms, cumulative_shared_perms);
+ *
+ * BlockDriver bdrv_file.bdrv_set_perm = raw_set_perm()
+ */
 static void raw_set_perm(BlockDriverState *bs, uint64_t perm, uint64_t shared)
 {
     BDRVRawState *s = bs->opaque;
@@ -2642,11 +2861,23 @@ static void raw_set_perm(BlockDriverState *bs, uint64_t perm, uint64_t shared)
     s->shared_perm = shared;
 }
 
+/*
+ * called by:
+ *   - block.c|1771| <<bdrv_abort_perm_update>> drv->bdrv_abort_perm_update(bs);
+ *
+ * BlockDriver bdrv_file.bdrv_abort_perm_update = raw_abort_perm_update()
+ */
 static void raw_abort_perm_update(BlockDriverState *bs)
 {
     raw_handle_perm_lock(bs, RAW_PL_ABORT, 0, 0, NULL);
 }
 
+/*
+ * called by:
+ *   - block/io.c|3044| <<bdrv_co_copy_range_internal>> ret = src->bs->drv->bdrv_co_copy_range_from(src->bs,
+ *
+ * BlockDriver bdrv_file.bdrv_co_copy_range_from = raw_co_copy_range_from()
+ */
 static int coroutine_fn raw_co_copy_range_from(
         BlockDriverState *bs, BdrvChild *src, uint64_t src_offset,
         BdrvChild *dst, uint64_t dst_offset, uint64_t bytes,
@@ -2656,6 +2887,12 @@ static int coroutine_fn raw_co_copy_range_from(
                                  read_flags, write_flags);
 }
 
+/*
+ * called by:
+ *   - block/io.c|3059| <<bdrv_co_copy_range_internal>> ret = dst->bs->drv->bdrv_co_copy_range_to(dst->bs,
+ *
+ * BlockDriver bdrv_file.bdrv_co_copy_range_to = raw_co_copy_range_to()
+ */
 static int coroutine_fn raw_co_copy_range_to(BlockDriverState *bs,
                                              BdrvChild *src,
                                              uint64_t src_offset,
@@ -2681,6 +2918,12 @@ static int coroutine_fn raw_co_copy_range_to(BlockDriverState *bs,
                                NULL, bytes, QEMU_AIO_COPY_RANGE);
 }
 
+/*
+ * used by:
+ *   - block.c|638| <<bdrv_find_protocol>> return &bdrv_file;
+ *   - block/file-posix.c|3690| <<bdrv_file_init>> bdrv_register(&bdrv_file);
+ *   - qemu-img.c|4849| <<img_measure>> create_opts = qemu_opts_append(create_opts, bdrv_file.create_opts);
+ */
 BlockDriver bdrv_file = {
     .format_name = "file",
     .protocol_name = "file",
@@ -3465,6 +3708,9 @@ static void bdrv_file_init(void)
      * Register all the drivers.  Note that order is important, the driver
      * registered last will get probed first.
      */
+    /*
+     * 插入bdrv_drivers链表
+     */
     bdrv_register(&bdrv_file);
     bdrv_register(&bdrv_host_device);
 #ifdef __linux__
@@ -3475,4 +3721,15 @@ static void bdrv_file_init(void)
 #endif
 }
 
+/*
+ * BlockDriver bdrv_file
+ * static BlockDriver bdrv_host_device = {
+ * static BlockDriver bdrv_host_cdrom = {
+ * static BlockDriver bdrv_host_cdrom = {
+ */
+
+/*
+ * 该函数调用module_init(function, MODULE_INIT_BLOCK)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_BLOCK]
+ */
 block_init(bdrv_file_init);
diff --git a/block/io.c b/block/io.c
index 7100344..551fd0e 100644
--- a/block/io.c
+++ b/block/io.c
@@ -2557,6 +2557,18 @@ static void coroutine_fn bdrv_flush_co_entry(void *opaque)
     rwco->ret = bdrv_co_flush(rwco->bs);
 }
 
+/*
+ * virtio block在iothread下的例子(第一次bdrv_co_flush()是raw, 第二次是file):
+ * #0  raw_co_flush_to_disk (bs=0x5555568a9660) at block/file-posix.c:1886
+ * #1  0x0000555555d032e8 in bdrv_co_flush (bs=0x5555568a9660) at block/io.c:2617
+ * #2  0x0000555555d03397 in bdrv_co_flush (bs=0x5555568a3040) at block/io.c:2654
+ * #3  0x0000555555cea60d in blk_co_flush (blk=0x5555568a2d80) at block/block-backend.c:1572
+ * #4  0x0000555555cea2a9 in blk_aio_flush_entry (opaque=0x7fffe0000a40) at block/block-backend.c:1480
+ * #5  0x0000555555dd04e6 in coroutine_trampoline (i0=-536860144, i1=32767) at util/coroutine-ucontext.c:116
+ * #6  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #7  0x00007fffe7ffdda0 in ?? ()
+ * #8  0x0000000000000000 in ?? ()
+ */
 int coroutine_fn bdrv_co_flush(BlockDriverState *bs)
 {
     int current_gen;
diff --git a/block/nvme.c b/block/nvme.c
index 6f71122..fd73485 100644
--- a/block/nvme.c
+++ b/block/nvme.c
@@ -222,6 +222,11 @@ fail:
 }
 
 /* With q->lock */
+/*
+ * called by:
+ *   - block/nvme.c|384| <<nvme_submit_command>> nvme_kick(s, q);
+ *   - block/nvme.c|1129| <<nvme_aio_unplug>> nvme_kick(s, q);
+ */
 static void nvme_kick(BDRVNVMeState *s, NVMeQueuePair *q)
 {
     if (s->plugged || !q->need_kick) {
@@ -294,6 +299,12 @@ static inline int nvme_translate_error(const NvmeCqe *c)
 }
 
 /* With q->lock */
+/*
+ * called by:
+ *   - block/nvme.c|385| <<nvme_submit_command>> nvme_process_completion(s, q);
+ *   - block/nvme.c|478| <<nvme_poll_queues>> while (nvme_process_completion(s, q)) {
+ *   - block/nvme.c|1130| <<nvme_aio_unplug>> nvme_process_completion(s, q);
+ */
 static bool nvme_process_completion(BDRVNVMeState *s, NVMeQueuePair *q)
 {
     bool progress = false;
@@ -308,6 +319,9 @@ static bool nvme_process_completion(BDRVNVMeState *s, NVMeQueuePair *q)
     }
     q->busy = true;
     assert(q->inflight >= 0);
+    /*
+     * 很重要的部分!!!, q->inflight不为0就一直循环处理!!!
+     */
     while (q->inflight) {
         int16_t cid;
         c = (NvmeCqe *)&q->cq.queue[q->cq.head * NVME_CQ_ENTRY_BYTES];
@@ -467,6 +481,11 @@ out:
     qemu_vfree(resp);
 }
 
+/*
+ * called by:
+ *   - block/nvme.c|494| <<nvme_handle_event>> nvme_poll_queues(s);
+ *   - block/nvme.c|545| <<nvme_poll_cb>> progress = nvme_poll_queues(s);
+ */
 static bool nvme_poll_queues(BDRVNVMeState *s)
 {
     bool progress = false;
@@ -546,6 +565,10 @@ static bool nvme_poll_cb(void *opaque)
     return progress;
 }
 
+/*
+ * called only by:
+ *   - block/nvme.c|767| <<nvme_file_open>> ret = nvme_init(bs, device, namespace, errp);
+ */
 static int nvme_init(BlockDriverState *bs, const char *device, int namespace,
                      Error **errp)
 {
@@ -683,6 +706,28 @@ fail:
  * where the "nvme://" is a fixed form of the protocol prefix, the middle part
  * is the PCI address, and the last part is the namespace number starting from
  * 1 according to the NVMe spec. */
+/*
+ * (gdb) bt
+ * #0  nvme_parse_filename (filename=0x5555565ee7b0 "nvme://0000:01:00.0/1", options=0x5555565f7190, errp=0x7fffffffd870) at block/nvme.c:688
+ * #1  0x0000555555c26d58 in bdrv_fill_options (options=0x7fffffffd8c8, filename=0x5555565ee7b0 "nvme://0000:01:00.0/1", flags=0x7fffffffd8c4, errp=0x7fffffffd900) at block.c:1604
+ * #2  0x0000555555c2917a in bdrv_open_inherit (filename=0x5555565de3c0 "nvme://0000:01:00.0/1", reference=0x0, options=0x5555565f7190, flags=40962, parent=0x5555565f1ea0, 
+ *     child_role=0x5555562d3180 <child_file>, errp=0x7fffffffdaf0) at block.c:2636
+ * #3  0x0000555555c28907 in bdrv_open_child_bs (filename=0x5555565de3c0 "nvme://0000:01:00.0/1", options=0x5555565f6170, bdref_key=0x555555e9253a "file", parent=0x5555565f1ea0, 
+ *     child_role=0x5555562d3180 <child_file>, allow_none=true, errp=0x7fffffffdaf0) at block.c:2397
+ * #4  0x0000555555c2945a in bdrv_open_inherit (filename=0x5555565de3c0 "nvme://0000:01:00.0/1", reference=0x0, options=0x5555565f6170, flags=8194, parent=0x0, child_role=0x0, 
+ *     errp=0x7fffffffdee0) at block.c:2700
+ * #5  0x0000555555c29ad4 in bdrv_open (filename=0x5555565de3c0 "nvme://0000:01:00.0/1", reference=0x0, options=0x5555565e7900, flags=0, errp=0x7fffffffdee0) at block.c:2834
+ * #6  0x0000555555c87e39 in blk_new_open (filename=0x5555565de3c0 "nvme://0000:01:00.0/1", reference=0x0, options=0x5555565e7900, flags=0, errp=0x7fffffffdee0)
+ *     at block/block-backend.c:375
+ * #7  0x0000555555983980 in blockdev_init (file=0x5555565de3c0 "nvme://0000:01:00.0/1", bs_opts=0x5555565e7900, errp=0x7fffffffdee0) at blockdev.c:599
+ * #8  0x0000555555984bef in drive_new (all_opts=0x555556536ce0, block_default_type=IF_IDE) at blockdev.c:1093
+ * #9  0x0000555555995416 in drive_init_func (opaque=0x555556585d88, opts=0x555556536ce0, errp=0x0) at vl.c:1143
+ * #10 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd5c0 <qemu_drive_opts>, func=0x5555559953e6 <drive_init_func>, opaque=0x555556585d88, errp=0x0)
+ *     at util/qemu-option.c:1106
+ * #11 0x000055555599da05 in main (argc=22, argv=0x7fffffffe338, envp=0x7fffffffe3f0) at vl.c:4450
+ *
+ * BlockDriver bdrv_nvme.bdrv_parse_filename = nvme_parse_filename()
+ */
 static void nvme_parse_filename(const char *filename, QDict *options,
                                 Error **errp)
 {
@@ -731,6 +776,9 @@ static int nvme_enable_disable_write_cache(BlockDriverState *bs, bool enable,
     return ret;
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_close = nvme_close()
+ */
 static void nvme_close(BlockDriverState *bs)
 {
     int i;
@@ -745,6 +793,30 @@ static void nvme_close(BlockDriverState *bs)
     qemu_vfio_close(s->vfio);
 }
 
+/*
+ * (gdb) bt
+ * #0  nvme_file_open (bs=0x5555565f81b0, options=0x5555565fc480, flags=24578, errp=0x7fffffffd7e0) at block/nvme.c:755
+ * #1  0x0000555555c25dd5 in bdrv_open_driver (bs=0x5555565f81b0, drv=0x55555647b480 <bdrv_nvme>, node_name=0x0, options=0x5555565fc480, open_flags=24578, errp=0x7fffffffd900)
+ *     at block.c:1191
+ * #2  0x0000555555c26807 in bdrv_open_common (bs=0x5555565f81b0, file=0x0, options=0x5555565fc480, errp=0x7fffffffd900) at block.c:1457
+ * #3  0x0000555555c29692 in bdrv_open_inherit (filename=0x5555565de3c0 "nvme://0000:01:00.0/1", reference=0x0, options=0x5555565fc480, flags=40962, parent=0x5555565f1ea0, 
+ *     child_role=0x5555562d3180 <child_file>, errp=0x7fffffffdaf0) at block.c:2752
+ * #4  0x0000555555c28907 in bdrv_open_child_bs (filename=0x5555565de3c0 "nvme://0000:01:00.0/1", options=0x5555565f6170, bdref_key=0x555555e9253a "file", parent=0x5555565f1ea0, 
+ *     child_role=0x5555562d3180 <child_file>, allow_none=true, errp=0x7fffffffdaf0) at block.c:2397
+ * #5  0x0000555555c2945a in bdrv_open_inherit (filename=0x5555565de3c0 "nvme://0000:01:00.0/1", reference=0x0, options=0x5555565f6170, flags=8194, parent=0x0, child_role=0x0, 
+ *     errp=0x7fffffffdee0) at block.c:2700
+ * #6  0x0000555555c29ad4 in bdrv_open (filename=0x5555565de3c0 "nvme://0000:01:00.0/1", reference=0x0, options=0x5555565e7900, flags=0, errp=0x7fffffffdee0) at block.c:2834
+ * #7  0x0000555555c87e39 in blk_new_open (filename=0x5555565de3c0 "nvme://0000:01:00.0/1", reference=0x0, options=0x5555565e7900, flags=0, errp=0x7fffffffdee0)
+ *     at block/block-backend.c:375
+ * #8  0x0000555555983980 in blockdev_init (file=0x5555565de3c0 "nvme://0000:01:00.0/1", bs_opts=0x5555565e7900, errp=0x7fffffffdee0) at blockdev.c:599
+ * #9  0x0000555555984bef in drive_new (all_opts=0x555556536ce0, block_default_type=IF_IDE) at blockdev.c:1093
+ * #10 0x0000555555995416 in drive_init_func (opaque=0x555556585d88, opts=0x555556536ce0, errp=0x0) at vl.c:1143
+ * #11 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd5c0 <qemu_drive_opts>, func=0x5555559953e6 <drive_init_func>, opaque=0x555556585d88, errp=0x0)
+ *     at util/qemu-option.c:1106
+ * #12 0x000055555599da05 in main (argc=22, argv=0x7fffffffe338, envp=0x7fffffffe3f0) at vl.c:4450
+ *
+ * BlockDriver bdrv_nvme.bdrv_file_open = nvme_file_open()
+ */
 static int nvme_file_open(BlockDriverState *bs, QDict *options, int flags,
                           Error **errp)
 {
@@ -754,6 +826,9 @@ static int nvme_file_open(BlockDriverState *bs, QDict *options, int flags,
     int ret;
     BDRVNVMeState *s = bs->opaque;
 
+    /*
+     * 核心思想是分配简单初始化一个QemuOpts, 插入QemuOptsList runtime_opts的head
+     */
     opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
     qemu_opts_absorb_qdict(opts, options, &error_abort);
     device = qemu_opt_get(opts, NVME_BLOCK_OPT_DEVICE);
@@ -789,6 +864,9 @@ fail:
     return ret;
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_getlength = nvme_getlength()
+ */
 static int64_t nvme_getlength(BlockDriverState *bs)
 {
     BDRVNVMeState *s = bs->opaque;
@@ -918,6 +996,11 @@ static void nvme_rw_cb(void *opaque, int ret)
     aio_bh_schedule_oneshot(data->ctx, nvme_rw_cb_bh, data);
 }
 
+/*
+ * called by:
+ *   - block/nvme.c|1076| <<nvme_co_prw>> return nvme_co_prw_aligned(bs, offset, bytes, qiov, is_write, flags);
+ *   - block/nvme.c|1089| <<nvme_co_prw>> r = nvme_co_prw_aligned(bs, offset, bytes, &local_qiov, is_write, flags);
+ */
 static coroutine_fn int nvme_co_prw_aligned(BlockDriverState *bs,
                                             uint64_t offset, uint64_t bytes,
                                             QEMUIOVector *qiov,
@@ -1023,6 +1106,9 @@ static int nvme_co_prw(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
     return r;
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_co_preadv = nvme_co_preadv()
+ */
 static coroutine_fn int nvme_co_preadv(BlockDriverState *bs,
                                        uint64_t offset, uint64_t bytes,
                                        QEMUIOVector *qiov, int flags)
@@ -1030,6 +1116,9 @@ static coroutine_fn int nvme_co_preadv(BlockDriverState *bs,
     return nvme_co_prw(bs, offset, bytes, qiov, false, flags);
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_co_pwritev = nvme_co_pwritev()
+ */
 static coroutine_fn int nvme_co_pwritev(BlockDriverState *bs,
                                         uint64_t offset, uint64_t bytes,
                                         QEMUIOVector *qiov, int flags)
@@ -1037,6 +1126,9 @@ static coroutine_fn int nvme_co_pwritev(BlockDriverState *bs,
     return nvme_co_prw(bs, offset, bytes, qiov, true, flags);
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_co_flush_to_disk = nvme_co_flush()
+ */
 static coroutine_fn int nvme_co_flush(BlockDriverState *bs)
 {
     BDRVNVMeState *s = bs->opaque;
@@ -1065,12 +1157,18 @@ static coroutine_fn int nvme_co_flush(BlockDriverState *bs)
 }
 
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_reopen_prepare = nvme_reopen_prepare()
+ */
 static int nvme_reopen_prepare(BDRVReopenState *reopen_state,
                                BlockReopenQueue *queue, Error **errp)
 {
     return 0;
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_refresh_filename = nvme_refresh_filename()
+ */
 static void nvme_refresh_filename(BlockDriverState *bs, QDict *opts)
 {
     qdict_del(opts, "filename");
@@ -1084,6 +1182,9 @@ static void nvme_refresh_filename(BlockDriverState *bs, QDict *opts)
     bs->full_open_options = qobject_ref(opts);
 }
 
+/*
+ * BlockDriver bdrv_nvme..bdrv_refresh_limits = nvme_refresh_limits()
+ */
 static void nvme_refresh_limits(BlockDriverState *bs, Error **errp)
 {
     BDRVNVMeState *s = bs->opaque;
@@ -1093,6 +1194,9 @@ static void nvme_refresh_limits(BlockDriverState *bs, Error **errp)
     bs->bl.max_transfer = s->max_transfer;
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_detach_aio_context = nvme_detach_aio_context()
+ */
 static void nvme_detach_aio_context(BlockDriverState *bs)
 {
     BDRVNVMeState *s = bs->opaque;
@@ -1101,6 +1205,9 @@ static void nvme_detach_aio_context(BlockDriverState *bs)
                            false, NULL, NULL);
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_attach_aio_context = nvme_attach_aio_context()
+ */
 static void nvme_attach_aio_context(BlockDriverState *bs,
                                     AioContext *new_context)
 {
@@ -1111,12 +1218,18 @@ static void nvme_attach_aio_context(BlockDriverState *bs,
                            false, nvme_handle_event, nvme_poll_cb);
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_io_plug = nvme_aio_plug()
+ */
 static void nvme_aio_plug(BlockDriverState *bs)
 {
     BDRVNVMeState *s = bs->opaque;
     s->plugged++;
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_io_unplug = nvme_aio_unplug()
+ */
 static void nvme_aio_unplug(BlockDriverState *bs)
 {
     int i;
@@ -1133,6 +1246,9 @@ static void nvme_aio_unplug(BlockDriverState *bs)
     }
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_register_buf = nvme_register_buf()
+ */
 static void nvme_register_buf(BlockDriverState *bs, void *host, size_t size)
 {
     int ret;
@@ -1147,6 +1263,9 @@ static void nvme_register_buf(BlockDriverState *bs, void *host, size_t size)
     }
 }
 
+/*
+ * BlockDriver bdrv_nvme.bdrv_unregister_buf = nvme_unregister_buf()
+ */
 static void nvme_unregister_buf(BlockDriverState *bs, void *host)
 {
     BDRVNVMeState *s = bs->opaque;
@@ -1159,7 +1278,15 @@ static BlockDriver bdrv_nvme = {
     .protocol_name            = "nvme",
     .instance_size            = sizeof(BDRVNVMeState),
 
+    /*
+     * called by:
+     *   - block.c|1613| <<bdrv_fill_options>> drv->bdrv_parse_filename(filename, *options, &local_err);
+     */
     .bdrv_parse_filename      = nvme_parse_filename,
+    /*
+     * called by:
+     *   - block.c|1200| <<bdrv_open_driver>> ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);
+     */
     .bdrv_file_open           = nvme_file_open,
     .bdrv_close               = nvme_close,
     .bdrv_getlength           = nvme_getlength,
@@ -1184,7 +1311,14 @@ static BlockDriver bdrv_nvme = {
 
 static void bdrv_nvme_init(void)
 {
+    /*
+     * 插入bdrv_drivers链表
+     */
     bdrv_register(&bdrv_nvme);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_BLOCK)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_BLOCK]
+ */
 block_init(bdrv_nvme_init);
diff --git a/block/raw-format.c b/block/raw-format.c
index 2fd69cd..42bcb4d 100644
--- a/block/raw-format.c
+++ b/block/raw-format.c
@@ -37,6 +37,10 @@ typedef struct BDRVRawState {
     bool has_size;
 } BDRVRawState;
 
+/*
+ * used only by:
+ *   - block/raw-format.c|88| <<raw_read_options>> opts = qemu_opts_create(&raw_runtime_opts, NULL, 0, &error_abort);
+ */
 static QemuOptsList raw_runtime_opts = {
     .name = "raw",
     .head = QTAILQ_HEAD_INITIALIZER(raw_runtime_opts.head),
@@ -55,6 +59,17 @@ static QemuOptsList raw_runtime_opts = {
     },
 };
 
+/*
+ * 主要被以下使用:
+ *   - block.c|2536| <<bdrv_append_temp_snapshot>> opts = qemu_opts_create(bdrv_qcow2.create_opts, NULL, 0,
+ *   - block.c|4757| <<bdrv_img_create>> if (!drv->create_opts) {
+ *   - block.c|4763| <<bdrv_img_create>> if (!proto_drv->create_opts) {
+ *   - block.c|4769| <<bdrv_img_create>> create_opts = qemu_opts_append(create_opts, drv->create_opts);
+ *   - block.c|4770| <<bdrv_img_create>> create_opts = qemu_opts_append(create_opts, proto_drv->create_opts);
+ *   - 最后就是qemu-img命令
+ *
+ * BlockDriver bdrv_raw.create_opts = raw_create_opts
+ */
 static QemuOptsList raw_create_opts = {
     .name = "raw-create-opts",
     .head = QTAILQ_HEAD_INITIALIZER(raw_create_opts.head),
@@ -68,6 +83,11 @@ static QemuOptsList raw_create_opts = {
     }
 };
 
+/*
+ * called by:
+ *   - block/raw-format.c|152| <<raw_reopen_prepare>> return raw_read_options(
+ *   - block/raw-format.c|509| <<raw_open>> ret = raw_read_options(options, bs, s, errp);
+ */
 static int raw_read_options(QDict *options, BlockDriverState *bs,
     BDRVRawState *s, Error **errp)
 {
@@ -135,6 +155,12 @@ end:
     return ret;
 }
 
+/*
+ * called by:
+ *   - block.c|3233| <<bdrv_reopen_prepare>> ret = drv->bdrv_reopen_prepare(reopen_state, queue, &local_err);
+ *
+ * BlockDriver bdrv_raw.bdrv_reopen_prepare = raw_reopen_prepare()
+ */
 static int raw_reopen_prepare(BDRVReopenState *reopen_state,
                               BlockReopenQueue *queue, Error **errp)
 {
@@ -150,6 +176,13 @@ static int raw_reopen_prepare(BDRVReopenState *reopen_state,
         errp);
 }
 
+/*
+ * called by:
+ *   - block.c|3047| <<bdrv_reopen_multiple>> bdrv_reopen_commit(&bs_entry->state);
+ *   - block.c|3298| <<bdrv_reopen_commit>> drv->bdrv_reopen_commit(reopen_state);
+ *
+ * BlockDriver bdrv_raw.bdrv_reopen_commit = raw_reopen_commit()
+ */
 static void raw_reopen_commit(BDRVReopenState *state)
 {
     BDRVRawState *new_s = state->opaque;
@@ -161,6 +194,13 @@ static void raw_reopen_commit(BDRVReopenState *state)
     state->opaque = NULL;
 }
 
+/*
+ * called by:
+ *   - block.c|3055| <<bdrv_reopen_multiple>> bdrv_reopen_abort(&bs_entry->state);
+ *   - block.c|3342| <<bdrv_reopen_abort>> drv->bdrv_reopen_abort(reopen_state);
+ *
+ * BlockDriver bdrv_raw.bdrv_reopen_abort = raw_reopen_abort()
+ */
 static void raw_reopen_abort(BDRVReopenState *state)
 {
     g_free(state->opaque);
@@ -168,9 +208,27 @@ static void raw_reopen_abort(BDRVReopenState *state)
 }
 
 /* Check and adjust the offset, against 'offset' and 'size' options. */
+/*
+ * called by:
+ *   - block/raw-format.c|221| <<raw_co_preadv>> ret = raw_adjust_offset(bs, &offset, bytes, false);
+ *   - block/raw-format.c|276| <<raw_co_pwritev>> ret = raw_adjust_offset(bs, &offset, bytes, true);
+ *   - block/raw-format.c|317| <<raw_co_pwrite_zeroes>> ret = raw_adjust_offset(bs, (uint64_t *)&offset, bytes, true);
+ *   - block/raw-format.c|332| <<raw_co_pdiscard>> ret = raw_adjust_offset(bs, (uint64_t *)&offset, bytes, true);
+ *   - block/raw-format.c|598| <<raw_co_copy_range_from>> ret = raw_adjust_offset(bs, &src_offset, bytes, false);
+ *   - block/raw-format.c|620| <<raw_co_copy_range_to>> ret = raw_adjust_offset(bs, &dst_offset, bytes, true);
+ */
 static inline int raw_adjust_offset(BlockDriverState *bs, uint64_t *offset,
                                     uint64_t bytes, bool is_write)
 {
+    /*
+     * virtblk配raw的例子:
+     * (gdb) p *(BDRVRawState *)bs->opaque
+     * $7 = {
+     *   offset = 0, 
+     *   size = 21474836480, 
+     *   has_size = false
+     * }
+     */
     BDRVRawState *s = bs->opaque;
 
     if (s->has_size && (*offset > s->size || bytes > (s->size - *offset))) {
@@ -188,6 +246,24 @@ static inline int raw_adjust_offset(BlockDriverState *bs, uint64_t *offset,
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  raw_co_preadv (bs=0x5555568a3160, offset=9178509312, bytes=16384, qiov=0x7fffe0000e70, flags=0) at block/raw-format.c:197
+ * #1  0x0000555555cff46a in bdrv_driver_preadv (bs=0x5555568a3160, offset=9178509312, bytes=16384, qiov=0x7fffe0000e70, flags=0) at block/io.c:1042
+ * #2  0x0000555555d00040 in bdrv_aligned_preadv (child=0x5555568a8650, req=0x7fffe63ffea0, offset=9178509312, bytes=16384, align=1, qiov=0x7fffe0000e70, flags=0) at block/io.c:1359
+ * #3  0x0000555555d0054c in bdrv_co_preadv (child=0x5555568a8650, offset=9178509312, bytes=16384, qiov=0x7fffe0000e70, flags=0) at block/io.c:1455
+ * #4  0x0000555555ce96f7 in blk_co_preadv (blk=0x5555568a2ea0, offset=9178509312, bytes=16384, qiov=0x7fffe0000e70, flags=0) at block/block-backend.c:1163
+ * #5  0x0000555555ce9f34 in blk_aio_read_entry (opaque=0x7fffe0008b40) at block/block-backend.c:1387
+ * #6  0x0000555555dd04e6 in coroutine_trampoline (i0=1469103728, i1=21845) at util/coroutine-ucontext.c:116
+ * #7  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #8  0x00007fffffffce10 in ?? ()
+ * #9  0x0000000000000000 in ?? ()
+ *
+ * called by:
+ *   - block/io.c|1042| <<bdrv_driver_preadv>> return drv->bdrv_co_preadv(bs, offset, bytes, qiov, flags);
+ *
+ * BlockDriver bdrv_raw.bdrv_co_preadv = raw_co_preadv()
+ */
 static int coroutine_fn raw_co_preadv(BlockDriverState *bs, uint64_t offset,
                                       uint64_t bytes, QEMUIOVector *qiov,
                                       int flags)
@@ -200,9 +276,30 @@ static int coroutine_fn raw_co_preadv(BlockDriverState *bs, uint64_t offset,
     }
 
     BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);
+    /*
+     * bs->file是BdrvChild
+     */
     return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);
 }
 
+/*
+ * (gdb) bt
+ * #0  raw_co_pwritev (bs=0x5555568a3160, offset=39731200, bytes=4096, qiov=0x7fffe0008f40, flags=0) at block/raw-format.c:209
+ * #1  0x0000555555cff6a3 in bdrv_driver_pwritev (bs=0x5555568a3160, offset=39731200, bytes=4096, qiov=0x7fffe0008f40, flags=0) at block/io.c:1088
+ * #2  0x0000555555d01060 in bdrv_aligned_pwritev (child=0x5555568a8650, req=0x7fff53bfbea0, offset=39731200, bytes=4096, align=1, qiov=0x7fffe0008f40, flags=0) at block/io.c:1715
+ * #3  0x0000555555d01ccc in bdrv_co_pwritev (child=0x5555568a8650, offset=39731200, bytes=4096, qiov=0x7fffe0008f40, flags=0) at block/io.c:1957
+ * #4  0x0000555555ce97e4 in blk_co_pwritev (blk=0x5555568a2ea0, offset=39731200, bytes=4096, qiov=0x7fffe0008f40, flags=0) at block/block-backend.c:1193
+ * #5  0x0000555555ce9fe7 in blk_aio_write_entry (opaque=0x7fffe0007400) at block/block-backend.c:1399
+ * #6  0x0000555555dd04e6 in coroutine_trampoline (i0=-536855664, i1=32767) at util/coroutine-ucontext.c:116
+ * #7  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #8  0x00007fffe7ffdda0 in ?? ()
+ * #9  0x0000000000000000 in ?? ()
+ *
+ * called by:
+ *   - block/io.c|1088| <<bdrv_driver_pwritev>> ret = drv->bdrv_co_pwritev(bs, offset, bytes, qiov,
+ *
+ * BlockDriver bdrv_raw.bdrv_co_pwritev = raw_co_pwritev()
+ */
 static int coroutine_fn raw_co_pwritev(BlockDriverState *bs, uint64_t offset,
                                        uint64_t bytes, QEMUIOVector *qiov,
                                        int flags)
@@ -212,6 +309,9 @@ static int coroutine_fn raw_co_pwritev(BlockDriverState *bs, uint64_t offset,
     QEMUIOVector local_qiov;
     int ret;
 
+    /*
+     * 用virtblk和raw的例子, bs->probed=false
+     */
     if (bs->probed && offset < BLOCK_PROBE_BUF_SIZE && bytes) {
         /* Handling partial writes would be a pain - so we just
          * require that guests have 512-byte request alignment if
@@ -262,6 +362,12 @@ fail:
     return ret;
 }
 
+/*
+ * called by:
+ *   - block/io.c|2141| <<bdrv_co_block_status>> ret = bs->drv->bdrv_co_block_status(bs, want_zero, aligned_offset,
+ *
+ * BlockDriver bdrv_raw.bdrv_co_block_status = raw_co_block_status()
+ */
 static int coroutine_fn raw_co_block_status(BlockDriverState *bs,
                                             bool want_zero, int64_t offset,
                                             int64_t bytes, int64_t *pnum,
@@ -275,6 +381,12 @@ static int coroutine_fn raw_co_block_status(BlockDriverState *bs,
     return BDRV_BLOCK_RAW | BDRV_BLOCK_OFFSET_VALID;
 }
 
+/*
+ * called by:
+ *   - block/io.c|1523| <<bdrv_co_do_pwrite_zeroes>> ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num,
+ *
+ * BlockDriver bdrv_raw.bdrv_co_pwrite_zeroes = raw_co_pwrite_zeroes()
+ */
 static int coroutine_fn raw_co_pwrite_zeroes(BlockDriverState *bs,
                                              int64_t offset, int bytes,
                                              BdrvRequestFlags flags)
@@ -288,6 +400,12 @@ static int coroutine_fn raw_co_pwrite_zeroes(BlockDriverState *bs,
     return bdrv_co_pwrite_zeroes(bs->file, offset, bytes, flags);
 }
 
+/*
+ * called by:
+ *   - block/io.c|2799| <<bdrv_co_pdiscard>> ret = bs->drv->bdrv_co_pdiscard(bs, offset, num);
+ *
+ * BlockDriver bdrv_raw.bdrv_co_pdiscard = raw_co_pdiscard()
+ */
 static int coroutine_fn raw_co_pdiscard(BlockDriverState *bs,
                                         int64_t offset, int bytes)
 {
@@ -300,6 +418,12 @@ static int coroutine_fn raw_co_pdiscard(BlockDriverState *bs,
     return bdrv_co_pdiscard(bs->file, offset, bytes);
 }
 
+/*
+ * called by:
+ *   - block.c|751| <<refresh_total_sectors>> int64_t length = drv->bdrv_getlength(bs);
+ *
+ * BlockDriver bdrv_raw.bdrv_getlength = raw_getlength()
+ */
 static int64_t raw_getlength(BlockDriverState *bs)
 {
     int64_t len;
@@ -326,6 +450,12 @@ static int64_t raw_getlength(BlockDriverState *bs)
     return s->size;
 }
 
+/*
+ * called by:
+ *   - block.c|3864| <<bdrv_measure>> return drv->bdrv_measure(opts, in_bs, errp);
+ *
+ * BlockDriver bdrv_raw.bdrv_measure = raw_measure()
+ */
 static BlockMeasureInfo *raw_measure(QemuOpts *opts, BlockDriverState *in_bs,
                                      Error **errp)
 {
@@ -351,11 +481,39 @@ static BlockMeasureInfo *raw_measure(QemuOpts *opts, BlockDriverState *in_bs,
     return info;
 }
 
+/*
+ * called by:
+ *   - block.c|4205| <<bdrv_get_info>> return drv->bdrv_get_info(bs, bdi);
+ *
+ * BlockDriver bdrv_raw.bdrv_get_info = raw_get_info()
+ */
 static int raw_get_info(BlockDriverState *bs, BlockDriverInfo *bdi)
 {
     return bdrv_get_info(bs->file->bs, bdi);
 }
 
+/*
+ * (gdb) bt
+ * #0  raw_refresh_limits (bs=0x5555568a3160, errp=0x7fffffffda40) at block/raw-format.c:361
+ * #1  0x0000555555cfd461 in bdrv_refresh_limits (bs=0x5555568a3160, errp=0x7fffffffda40) at block/io.c:162
+ * #2  0x0000555555c8608f in bdrv_open_driver (bs=0x5555568a3160, drv=0x555556730540 <bdrv_raw>, node_name=0x0, options=0x5555568a7570, open_flags=8194, errp=0x7fffffffdb60) at block.c:1215
+ * #3  0x0000555555c8695b in bdrv_open_common (bs=0x5555568a3160, file=0x5555568adcc0, options=0x5555568a7570, errp=0x7fffffffdb60) at block.c:1457
+ * #4  0x0000555555c897e6 in bdrv_open_inherit (filename=0x5555568a1bd0 "/home/zhang/img/ubuntu1604/ubuntu1604.img", reference=0x0, options=0x5555568a7570, flags=8194, parent=0x0, child_role=0x0, 
+ *     errp=0x7fffffffdf50) at block.c:2752
+ * #5  0x0000555555c89c28 in bdrv_open (filename=0x5555568a1bd0 "/home/zhang/img/ubuntu1604/ubuntu1604.img", reference=0x0, options=0x5555568a0a20, flags=0, errp=0x7fffffffdf50) at block.c:2834
+ * #6  0x0000555555ce7f8a in blk_new_open (filename=0x5555568a1bd0 "/home/zhang/img/ubuntu1604/ubuntu1604.img", reference=0x0, options=0x5555568a0a20, flags=0, errp=0x7fffffffdf50)
+ *     at block/block-backend.c:375
+ * #7  0x00005555559cc068 in blockdev_init (file=0x5555568a1bd0 "/home/zhang/img/ubuntu1604/ubuntu1604.img", bs_opts=0x5555568a0a20, errp=0x7fffffffdf50) at blockdev.c:599
+ * #8  0x00005555559cd2d7 in drive_new (all_opts=0x5555567f37c0, block_default_type=IF_IDE) at blockdev.c:1093
+ * #9  0x00005555559ddafe in drive_init_func (opaque=0x555556845208, opts=0x5555567f37c0, errp=0x0) at vl.c:1143
+ * #10 0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b7620 <qemu_drive_opts>, func=0x5555559ddace <drive_init_func>, opaque=0x555556845208, errp=0x0) at util/qemu-option.c:1106
+ * #11 0x00005555559e60ed in main (argc=18, argv=0x7fffffffe3a8, envp=0x7fffffffe440) at vl.c:4450
+ *
+ * called by:
+ *   - block/io.c|162| <<bdrv_refresh_limits>> drv->bdrv_refresh_limits(bs, errp);
+ *
+ * BlockDriver bdrv_raw.bdrv_refresh_limits = raw_refresh_limits()
+ */
 static void raw_refresh_limits(BlockDriverState *bs, Error **errp)
 {
     if (bs->probed) {
@@ -366,6 +524,12 @@ static void raw_refresh_limits(BlockDriverState *bs, Error **errp)
     }
 }
 
+/*
+ * called by:
+ *   - block/io.c|3193| <<bdrv_co_truncate>> ret = drv->bdrv_co_truncate(bs, offset, prealloc, errp);
+ *
+ * BlockDriver bdrv_raw.bdrv_co_truncate = raw_co_truncate()
+ */
 static int coroutine_fn raw_co_truncate(BlockDriverState *bs, int64_t offset,
                                         PreallocMode prealloc, Error **errp)
 {
@@ -386,16 +550,34 @@ static int coroutine_fn raw_co_truncate(BlockDriverState *bs, int64_t offset,
     return bdrv_co_truncate(bs->file, offset, prealloc, errp);
 }
 
+/*
+ * called by:
+ *   - block.c|4620| <<bdrv_eject>> drv->bdrv_eject(bs, eject_flag);
+ *
+ * BlockDriver bdrv_raw.bdrv_eject = raw_eject()
+ */
 static void raw_eject(BlockDriverState *bs, bool eject_flag)
 {
     bdrv_eject(bs->file->bs, eject_flag);
 }
 
+/*
+ * called by:
+ *   - block.c|4635| <<bdrv_lock_medium>> drv->bdrv_lock_medium(bs, locked);
+ *
+ * BlockDriver bdrv_raw.bdrv_lock_medium = raw_lock_medium()
+ */
 static void raw_lock_medium(BlockDriverState *bs, bool locked)
 {
     bdrv_lock_medium(bs->file->bs, locked);
 }
 
+/*
+ * called by:
+ *   - block/io.c|2868| <<bdrv_co_ioctl>> co.ret = drv->bdrv_co_ioctl(bs, req, buf);
+ *
+ * BlockDriver bdrv_raw.bdrv_co_ioctl = raw_co_ioctl()
+ */
 static int raw_co_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
 {
     BDRVRawState *s = bs->opaque;
@@ -405,17 +587,60 @@ static int raw_co_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
     return bdrv_co_ioctl(bs->file->bs, req, buf);
 }
 
+/*
+ * called by:
+ *   - block.c|4141| <<bdrv_has_zero_init>> return bs->drv->bdrv_has_zero_init(bs);
+ *
+ * BlockDriver bdrv_raw.bdrv_has_zero_init = raw_has_zero_init()
+ */
 static int raw_has_zero_init(BlockDriverState *bs)
 {
     return bdrv_has_zero_init(bs->file->bs);
 }
 
+/*
+ * called by only:
+ *   - block.c|438| <<bdrv_create_co_entry>> ret = cco->drv->bdrv_co_create_opts(cco->filename, cco->opts, &local_err);
+ *
+ * BlockDriver bdrv_raw..bdrv_co_create_opts()
+ */
 static int coroutine_fn raw_co_create_opts(const char *filename, QemuOpts *opts,
                                            Error **errp)
 {
     return bdrv_create_file(filename, opts, errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  raw_open (bs=0x5555565e98a0, options=0x5555565eddd0, flags=24578, errp=0x7fffffffd870) at block/file-posix.c:664
+ * #1  0x0000555555c25dd5 in bdrv_open_driver (bs=0x5555565e98a0, drv=0x55555647a360 <bdrv_file>, node_name=0x0, options=0x5555565eddd0, 
+ *     open_flags=24578, errp=0x7fffffffd990) at block.c:1191
+ * #2  0x0000555555c26807 in bdrv_open_common (bs=0x5555565e98a0, file=0x0, options=0x5555565eddd0, errp=0x7fffffffd990) at block.c:1457
+ * #3  0x0000555555c29692 in bdrv_open_inherit (filename=0x5555565e1bc0 "/home/zhang/img/ubuntu/disk.img", reference=0x0, options=0x5555565eddd0, 
+ *     flags=40962, parent=0x5555565e3280, child_role=0x5555562d3180 <child_file>, errp=0x7fffffffdb80) at block.c:2752
+ * #4  0x0000555555c28907 in bdrv_open_child_bs (filename=0x5555565e1bc0 "/home/zhang/img/ubuntu/disk.img", options=0x5555565e7690, 
+ *     bdref_key=0x555555e9253a "file", parent=0x5555565e3280, child_role=0x5555562d3180 <child_file>, allow_none=true, errp=0x7fffffffdb80)
+ *     at block.c:2397
+ * #5  0x0000555555c2945a in bdrv_open_inherit (filename=0x5555565e1bc0 "/home/zhang/img/ubuntu/disk.img", reference=0x0, options=0x5555565e7690, 
+ *     flags=8194, parent=0x0, child_role=0x0, errp=0x7fffffffdf70) at block.c:2700
+ * #6  0x0000555555c29ad4 in bdrv_open (filename=0x5555565e1bc0 "/home/zhang/img/ubuntu/disk.img", reference=0x0, options=0x5555565e0b70, flags=0, 
+ *     errp=0x7fffffffdf70) at block.c:2834
+ * #7  0x0000555555c87e39 in blk_new_open (filename=0x5555565e1bc0 "/home/zhang/img/ubuntu/disk.img", reference=0x0, options=0x5555565e0b70, flags=0, 
+ *     errp=0x7fffffffdf70) at block/block-backend.c:375
+ * #8  0x0000555555983980 in blockdev_init (file=0x5555565e1bc0 "/home/zhang/img/ubuntu/disk.img", bs_opts=0x5555565e0b70, errp=0x7fffffffdf70)
+ *     at blockdev.c:599
+ * #9  0x0000555555984bef in drive_new (all_opts=0x555556536190, block_default_type=IF_IDE) at blockdev.c:1093
+ * #10 0x0000555555995416 in drive_init_func (opaque=0x555556585b08, opts=0x555556536190, errp=0x0) at vl.c:1143
+ * #11 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd5c0 <qemu_drive_opts>, func=0x5555559953e6 <drive_init_func>, opaque=0x555556585b08, 
+ *     errp=0x0) at util/qemu-option.c:1106
+ * #12 0x000055555599da05 in main (argc=18, argv=0x7fffffffe3c8, envp=0x7fffffffe460) at vl.c:4450
+ *
+ * called by:
+ *   - block.c|1202| <<bdrv_open_driver>> ret = drv->bdrv_open(bs, options, open_flags, &local_err);
+ *   - block/snapshot.c|226| <<bdrv_snapshot_goto>> open_ret = drv->bdrv_open(bs, options, bs->open_flags, &local_err);
+ *
+ * BlockDriver bdrv_raw..bdrv_open = raw_open()
+ */
 static int raw_open(BlockDriverState *bs, QDict *options, int flags,
                     Error **errp)
 {
@@ -459,10 +684,34 @@ static int raw_open(BlockDriverState *bs, QDict *options, int flags,
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  raw_close (bs=0x5555568a3160) at block/raw-format.c:464
+ * #1  0x0000555555c8ae9a in bdrv_close (bs=0x5555568a3160) at block.c:3352
+ * #2  0x0000555555c8b597 in bdrv_delete (bs=0x5555568a3160) at block.c:3560
+ * #3  0x0000555555c8d778 in bdrv_unref (bs=0x5555568a3160) at block.c:4616
+ * #4  0x0000555555c882b1 in bdrv_root_unref_child (child=0x5555568a8630) at block.c:2191
+ * #5  0x0000555555ce8b9e in blk_remove_bs (blk=0x5555568a2ea0) at block/block-backend.c:776
+ * #6  0x0000555555ce8374 in blk_remove_all_bs () at block/block-backend.c:474
+ * #7  0x0000555555c8b147 in bdrv_close_all () at block.c:3406
+ * #8  0x00005555559e66b9 in main (argc=18, argv=0x7fffffffe3a8, envp=0x7fffffffe440) at vl.c:4652
+ *
+ * called by:
+ *   - block.c|3384| <<bdrv_close>> bs->drv->bdrv_close(bs);
+ *   - block/snapshot.c|221| <<bdrv_snapshot_goto>> drv->bdrv_close(bs);
+ *
+ * BlockDriver bdrv_raw.bdrv_close = raw_close()
+ */
 static void raw_close(BlockDriverState *bs)
 {
 }
 
+/*
+ * BlockDriver bdrv_raw.bdrv_probe = raw_probe()
+ *
+ * called by only:
+ *   - block.c|691| <<bdrv_probe_all>> score = d->bdrv_probe(buf, buf_size, filename);
+ */
 static int raw_probe(const uint8_t *buf, int buf_size, const char *filename)
 {
     /* smallest possible positive score so that raw is used if and only if no
@@ -471,6 +720,38 @@ static int raw_probe(const uint8_t *buf, int buf_size, const char *filename)
     return 1;
 }
 
+/*
+ * (gdb) bt
+ * #0  raw_probe_blocksizes (bs=0x5555568a3160, bsz=0x7fffffffda10) at block/raw-format.c:476
+ * #1  0x0000555555c84966 in bdrv_probe_blocksizes (bs=0x5555568a3160, bsz=0x7fffffffda10) at block.c:506
+ * #2  0x0000555555ceb717 in blk_probe_blocksizes (blk=0x5555568a2ea0, bsz=0x7fffffffda10) at block/block-backend.c:2057
+ * #3  0x0000555555a5001c in blkconf_blocksizes (conf=0x555557901590) at hw/block/block.c:37
+ * #4  0x00005555558b3ecf in virtio_blk_device_realize (dev=0x5555579013e0, errp=0x7fffffffdaa0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:949
+ * #5  0x0000555555902567 in virtio_device_realize (dev=0x5555579013e0, errp=0x7fffffffdb00) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2518
+ * #6  0x0000555555a7cc8d in device_set_realized (obj=0x5555579013e0, value=true, errp=0x7fffffffdd38) at hw/core/qdev.c:826
+ * #7  0x0000555555c81d1b in property_set_bool (obj=0x5555579013e0, v=0x55555790bde0, name=0x555555f67386 "realized", opaque=0x555557902b10, errp=0x7fffffffdd38) at qom/object.c:1984
+ * #8  0x0000555555c7ffa0 in object_property_set (obj=0x5555579013e0, v=0x55555790bde0, name=0x555555f67386 "realized", errp=0x7fffffffdd38) at qom/object.c:1176
+ * #9  0x0000555555c83058 in object_property_set_qobject (obj=0x5555579013e0, value=0x55555790bd30, name=0x555555f67386 "realized", errp=0x7fffffffdd38) at qom/qom-qobject.c:27
+ * #10 0x0000555555c80285 in object_property_set_bool (obj=0x5555579013e0, value=true, name=0x555555f67386 "realized", errp=0x7fffffffdd38) at qom/object.c:1242
+ * #11 0x0000555555bef33d in virtio_blk_pci_realize (vpci_dev=0x5555578f9270, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1970
+ * #12 0x0000555555beed20 in virtio_pci_realize (pci_dev=0x5555578f9270, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1841
+ * #13 0x0000555555b4aa8b in pci_qdev_realize (qdev=0x5555578f9270, errp=0x7fffffffddf0) at hw/pci/pci.c:2028
+ * #14 0x0000555555bef12e in virtio_pci_dc_realize (qdev=0x5555578f9270, errp=0x7fffffffddf0) at hw/virtio/virtio-pci.c:1915
+ * #15 0x0000555555a7cc8d in device_set_realized (obj=0x5555578f9270, value=true, errp=0x7fffffffdfc0) at hw/core/qdev.c:826
+ * #16 0x0000555555c81d1b in property_set_bool (obj=0x5555578f9270, v=0x555557905ed0, name=0x555555edfa8a "realized", opaque=0x555557881150, errp=0x7fffffffdfc0) at qom/object.c:1984
+ * #17 0x0000555555c7ffa0 in object_property_set (obj=0x5555578f9270, v=0x555557905ed0, name=0x555555edfa8a "realized", errp=0x7fffffffdfc0) at qom/object.c:1176
+ * #18 0x0000555555c83058 in object_property_set_qobject (obj=0x5555578f9270, value=0x555557905d90, name=0x555555edfa8a "realized", errp=0x7fffffffdfc0) at qom/qom-qobject.c:27
+ * #19 0x0000555555c80285 in object_property_set_bool (obj=0x5555578f9270, value=true, name=0x555555edfa8a "realized", errp=0x7fffffffdfc0) at qom/object.c:1242
+ * #20 0x00005555559d8e31 in qdev_device_add (opts=0x5555567f39f0, errp=0x7fffffffe038) at qdev-monitor.c:627
+ * #21 0x00005555559e12b8 in device_init_func (opaque=0x0, opts=0x5555567f39f0, errp=0x0) at vl.c:2275
+ * #22 0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b76c0 <qemu_device_opts>, func=0x5555559e127a <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #23 0x00005555559e6449 in main (argc=18, argv=0x7fffffffe3a8, envp=0x7fffffffe440) at vl.c:4542
+ *
+ * called by:
+ *   - block.c|515| <<bdrv_probe_blocksizes>> return drv->bdrv_probe_blocksizes(bs, bsz);
+ *
+ * BlockDriver bdrv_raw.bdrv_probe_blocksizes = raw_probe_blocksizes()
+ */
 static int raw_probe_blocksizes(BlockDriverState *bs, BlockSizes *bsz)
 {
     BDRVRawState *s = bs->opaque;
@@ -488,6 +769,39 @@ static int raw_probe_blocksizes(BlockDriverState *bs, BlockSizes *bsz)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  raw_probe_geometry (bs=0x5555568a3160, geo=0x7fffffffd9c0) at block/raw-format.c:493
+ * #1  0x0000555555c849ff in bdrv_probe_geometry (bs=0x5555568a3160, geo=0x7fffffffd9c0) at block.c:525
+ * #2  0x0000555555ceb761 in blk_probe_geometry (blk=0x5555568a2ea0, geo=0x7fffffffd9c0) at block/block-backend.c:2066
+ * #3  0x0000555555a50f5e in hd_geometry_guess (blk=0x5555568a2ea0, pcyls=0x5555579015ac, pheads=0x5555579015b0, psecs=0x5555579015b4, ptrans=0x0) at hw/block/hd-geometry.c:131
+ * #4  0x0000555555a502b9 in blkconf_geometry (conf=0x555557901590, ptrans=0x0, cyls_max=65535, heads_max=255, secs_max=255, errp=0x7fffffffdaa0) at hw/block/block.c:126
+ * #5  0x00005555558b3eb8 in virtio_blk_device_realize (dev=0x5555579013e0, errp=0x7fffffffdaa0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:945
+ * #6  0x0000555555902567 in virtio_device_realize (dev=0x5555579013e0, errp=0x7fffffffdb00) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2518
+ * #7  0x0000555555a7cc8d in device_set_realized (obj=0x5555579013e0, value=true, errp=0x7fffffffdd38) at hw/core/qdev.c:826
+ * #8  0x0000555555c81d1b in property_set_bool (obj=0x5555579013e0, v=0x55555790bde0, name=0x555555f67386 "realized", opaque=0x555557902b10, errp=0x7fffffffdd38) at qom/object.c:1984
+ * #9  0x0000555555c7ffa0 in object_property_set (obj=0x5555579013e0, v=0x55555790bde0, name=0x555555f67386 "realized", errp=0x7fffffffdd38) at qom/object.c:1176
+ * #10 0x0000555555c83058 in object_property_set_qobject (obj=0x5555579013e0, value=0x55555790bd30, name=0x555555f67386 "realized", errp=0x7fffffffdd38) at qom/qom-qobject.c:27
+ * #11 0x0000555555c80285 in object_property_set_bool (obj=0x5555579013e0, value=true, name=0x555555f67386 "realized", errp=0x7fffffffdd38) at qom/object.c:1242
+ * #12 0x0000555555bef33d in virtio_blk_pci_realize (vpci_dev=0x5555578f9270, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1970
+ * #13 0x0000555555beed20 in virtio_pci_realize (pci_dev=0x5555578f9270, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1841
+ * #14 0x0000555555b4aa8b in pci_qdev_realize (qdev=0x5555578f9270, errp=0x7fffffffddf0) at hw/pci/pci.c:2028
+ * #15 0x0000555555bef12e in virtio_pci_dc_realize (qdev=0x5555578f9270, errp=0x7fffffffddf0) at hw/virtio/virtio-pci.c:1915
+ * #16 0x0000555555a7cc8d in device_set_realized (obj=0x5555578f9270, value=true, errp=0x7fffffffdfc0) at hw/core/qdev.c:826
+ * #17 0x0000555555c81d1b in property_set_bool (obj=0x5555578f9270, v=0x555557905ed0, name=0x555555edfa8a "realized", opaque=0x555557881150, errp=0x7fffffffdfc0) at qom/object.c:1984
+ * #18 0x0000555555c7ffa0 in object_property_set (obj=0x5555578f9270, v=0x555557905ed0, name=0x555555edfa8a "realized", errp=0x7fffffffdfc0) at qom/object.c:1176
+ * #19 0x0000555555c83058 in object_property_set_qobject (obj=0x5555578f9270, value=0x555557905d90, name=0x555555edfa8a "realized", errp=0x7fffffffdfc0) at qom/qom-qobject.c:27
+ * #20 0x0000555555c80285 in object_property_set_bool (obj=0x5555578f9270, value=true, name=0x555555edfa8a "realized", errp=0x7fffffffdfc0) at qom/object.c:1242
+ * #21 0x00005555559d8e31 in qdev_device_add (opts=0x5555567f39f0, errp=0x7fffffffe038) at qdev-monitor.c:627
+ * #22 0x00005555559e12b8 in device_init_func (opaque=0x0, opts=0x5555567f39f0, errp=0x0) at vl.c:2275
+ * #23 0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b76c0 <qemu_device_opts>, func=0x5555559e127a <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #24 0x00005555559e6449 in main (argc=18, argv=0x7fffffffe3a8, envp=0x7fffffffe440) at vl.c:4542
+ *
+ * called by:
+ *   - block.c|534| <<bdrv_probe_geometry>> return drv->bdrv_probe_geometry(bs, geo);
+ *
+ * BlockDriver bdrv_raw.bdrv_probe_geometry = raw_probe_geometry()
+ */
 static int raw_probe_geometry(BlockDriverState *bs, HDGeometry *geo)
 {
     BDRVRawState *s = bs->opaque;
@@ -497,6 +811,12 @@ static int raw_probe_geometry(BlockDriverState *bs, HDGeometry *geo)
     return bdrv_probe_geometry(bs->file->bs, geo);
 }
 
+/*
+ * called by:
+ *   - block/io.c|3044| <<bdrv_co_copy_range_internal>> ret = src->bs->drv->bdrv_co_copy_range_from(src->bs,
+ *
+ * BlockDriver bdrv_raw.bdrv_co_copy_range_from = raw_co_copy_range_from()
+ */
 static int coroutine_fn raw_co_copy_range_from(BlockDriverState *bs,
                                                BdrvChild *src,
                                                uint64_t src_offset,
@@ -516,6 +836,12 @@ static int coroutine_fn raw_co_copy_range_from(BlockDriverState *bs,
                                    bytes, read_flags, write_flags);
 }
 
+/*
+ * called by:
+ *   - block/io.c|3059| <<bdrv_co_copy_range_internal>> ret = dst->bs->drv->bdrv_co_copy_range_to(dst->bs,
+ *
+ * BlockDriver bdrv_raw.bdrv_co_copy_range_to  = &raw_co_copy_range_to()
+ */
 static int coroutine_fn raw_co_copy_range_to(BlockDriverState *bs,
                                              BdrvChild *src,
                                              uint64_t src_offset,
@@ -538,39 +864,44 @@ static int coroutine_fn raw_co_copy_range_to(BlockDriverState *bs,
 BlockDriver bdrv_raw = {
     .format_name          = "raw",
     .instance_size        = sizeof(BDRVRawState),
-    .bdrv_probe           = &raw_probe,
-    .bdrv_reopen_prepare  = &raw_reopen_prepare,
-    .bdrv_reopen_commit   = &raw_reopen_commit,
-    .bdrv_reopen_abort    = &raw_reopen_abort,
+    .bdrv_probe           = &raw_probe,           /* virtblk q35简单测试没调用 */
+    .bdrv_reopen_prepare  = &raw_reopen_prepare,  /* virtblk q35简单测试没调用*/
+    .bdrv_reopen_commit   = &raw_reopen_commit,   /* virtblk q35简单测试没调用 */
+    .bdrv_reopen_abort    = &raw_reopen_abort,    /* virtblk q35简单测试没调用 */
     .bdrv_open            = &raw_open,
-    .bdrv_close           = &raw_close,
-    .bdrv_child_perm      = bdrv_filter_default_perms,
-    .bdrv_co_create_opts  = &raw_co_create_opts,
+    .bdrv_close           = &raw_close,    /* shutdown调用的 */
+    .bdrv_child_perm      = bdrv_filter_default_perms,  /* 调用非常多 */
+    .bdrv_co_create_opts  = &raw_co_create_opts,  /* virtblk q35简单测试没调用 */
     .bdrv_co_preadv       = &raw_co_preadv,
     .bdrv_co_pwritev      = &raw_co_pwritev,
     .bdrv_co_pwrite_zeroes = &raw_co_pwrite_zeroes,
     .bdrv_co_pdiscard     = &raw_co_pdiscard,
-    .bdrv_co_block_status = &raw_co_block_status,
-    .bdrv_co_copy_range_from = &raw_co_copy_range_from,
-    .bdrv_co_copy_range_to  = &raw_co_copy_range_to,
-    .bdrv_co_truncate     = &raw_co_truncate,
-    .bdrv_getlength       = &raw_getlength,
+    .bdrv_co_block_status = &raw_co_block_status, /* virtblk q35简单测试没调用 */
+    .bdrv_co_copy_range_from = &raw_co_copy_range_from, /* virtblk q35简单测试没调用 */
+    .bdrv_co_copy_range_to  = &raw_co_copy_range_to,    /* virtblk q35简单测试没调用 */
+    .bdrv_co_truncate     = &raw_co_truncate,     /* virtblk q35简单测试没调用 */
+    .bdrv_getlength       = &raw_getlength,       /* 调用非常多 */
     .has_variable_length  = true,
-    .bdrv_measure         = &raw_measure,
-    .bdrv_get_info        = &raw_get_info,
+    .bdrv_measure         = &raw_measure,        /* virtblk q35简单测试没调用 */
+    .bdrv_get_info        = &raw_get_info,       /* virtblk q35简单测试没调用 */
     .bdrv_refresh_limits  = &raw_refresh_limits,
     .bdrv_probe_blocksizes = &raw_probe_blocksizes,
     .bdrv_probe_geometry  = &raw_probe_geometry,
-    .bdrv_eject           = &raw_eject,
-    .bdrv_lock_medium     = &raw_lock_medium,
-    .bdrv_co_ioctl        = &raw_co_ioctl,
+    .bdrv_eject           = &raw_eject,          /* virtblk q35简单测试没调用 */
+    .bdrv_lock_medium     = &raw_lock_medium,    /* virtblk q35简单测试没调用 */
+    .bdrv_co_ioctl        = &raw_co_ioctl,       /* virtblk q35简单测试没调用 */
     .create_opts          = &raw_create_opts,
-    .bdrv_has_zero_init   = &raw_has_zero_init
+    .bdrv_has_zero_init   = &raw_has_zero_init   /* virtblk q35简单测试没调用 */
 };
 
 static void bdrv_raw_init(void)
 {
+    /* 插入bdrv_drivers链表 */
     bdrv_register(&bdrv_raw);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_BLOCK)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_BLOCK]
+ */
 block_init(bdrv_raw_init);
diff --git a/blockdev.c b/blockdev.c
index dcf8c8d..d3d6155 100644
--- a/blockdev.c
+++ b/blockdev.c
@@ -204,6 +204,16 @@ QemuOpts *drive_def(const char *optstr)
     return qemu_opts_parse_noisily(qemu_find_opts("drive"), optstr, false);
 }
 
+/*
+ * called by:
+ *   - vl.c|3104| <<main>> drive_add(IF_DEFAULT, 0, argv[optind++], HD_OPTS);
+ *   - vl.c|3128| <<main>> drive_add(IF_DEFAULT, popt->index - QEMU_OPTION_hda, optarg,
+ *   - vl.c|3164| <<main>> drive_add(IF_MTD, -1, optarg, MTD_OPTS);
+ *   - vl.c|3167| <<main>> drive_add(IF_SD, -1, optarg, SD_OPTS);
+ *   - vl.c|3170| <<main>> drive_add(IF_PFLASH, -1, optarg, PFLASH_OPTS);
+ *   - vl.c|3227| <<main>> drive_add(IF_DEFAULT, 2, optarg, CDROM_OPTS);
+ *   - vl.c|3238| <<main>> drive_add(IF_FLOPPY, popt->index - QEMU_OPTION_fda,
+ */
 QemuOpts *drive_add(BlockInterfaceType type, int index, const char *file,
                     const char *optstr)
 {
@@ -462,6 +472,10 @@ static void extract_common_blockdev_options(QemuOpts *opts, int *bdrv_flags,
 }
 
 /* Takes the ownership of bs_opts */
+/*
+ * called only by:
+ *   - blockdev.c|1103| <<drive_new>> blk = blockdev_init(filename, bs_opts, &local_err);
+ */
 static BlockBackend *blockdev_init(const char *file, QDict *bs_opts,
                                    Error **errp)
 {
@@ -540,6 +554,7 @@ static BlockBackend *blockdev_init(const char *file, QDict *bs_opts,
             error_setg(errp, "Cannot specify both 'driver' and 'format'");
             goto early_err;
         }
+        /* 猜测比如"driver"可以存"raw" */
         qdict_put_str(bs_opts, "driver", buf);
     }
 
@@ -567,6 +582,10 @@ static BlockBackend *blockdev_init(const char *file, QDict *bs_opts,
 
     read_only = qemu_opt_get_bool(opts, BDRV_OPT_READ_ONLY, false);
 
+    /*
+     * 测试中, file此时是/home/zhang/img/ubuntu1604/ubuntu1604.img
+     */
+
     /* init */
     if ((!file || !*file) && !qdict_size(bs_opts)) {
         BlockBackendRootState *blk_rs;
@@ -783,10 +802,63 @@ QemuOptsList qemu_legacy_drive_opts = {
     },
 };
 
+/*
+ * (qemu) info block
+ * drive-virtio-disk0 (#block138): /home/zhang/img/ubuntu1604/ubuntu1604.img (raw)
+ *     Attached to:      /machine/peripheral/virtio-disk0/virtio-backend
+ *     Cache mode:       writeback
+ *
+ * ide1-cd0: [not inserted]
+ *     Attached to:      /machine/unattached/device[25]
+ *     Removable device: not locked, tray closed
+ *
+ * floppy0: [not inserted]
+ *     Attached to:      /machine/unattached/device[18]
+ *     Removable device: not locked, tray closed
+ *
+ * sd0: [not inserted]
+ *     Removable device: not locked, tray closed*
+ */
+
+/*
+ * virtio的启动例子:
+ * (gdb) bt
+ * #0  drive_new (all_opts=0x5555567f3180, block_default_type=IF_IDE) at blockdev.c:787
+ * #1  0x00005555559ddafe in drive_init_func (opaque=0x55555686d1a8, opts=0x5555567f3180, errp=0x0) at vl.c:1143
+ * #2  0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b7620 <qemu_drive_opts>, func=0x5555559ddace <drive_init_func>, opaque=0x55555686d1a8, errp=0x0) at util/qemu-option.c:1106
+ * #3  0x00005555559e60ed in main (argc=16, argv=0x7fffffffe3b8, envp=0x7fffffffe440) at vl.c:4450
+ *
+ * virtio hotplug的例子:
+ * (gdb) bt
+ * #0  drive_new (all_opts=0x555556f5bfb0, block_default_type=IF_IDE) at blockdev.c:787
+ * #1  0x00005555559d9c69 in add_init_drive (optstr=0x555556889540 "file=/home/zhang/img/sparse/sparse.img,format=raw,id=myh1,if=none") at device-hotplug.c:48
+ * #2  0x00005555559d9d01 in hmp_drive_add (mon=0x5555568a7450, qdict=0x55555779d810) at device-hotplug.c:68
+ * #3  0x000055555585b273 in handle_hmp_command (mon=0x5555568a7450, cmdline=0x5555568b1a0a "0 file=/home/zhang/img/sparse/sparse.img,format=raw,id=myh1,if=none") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #4  0x000055555585d62e in monitor_command_cb (opaque=0x5555568a7450, cmdline=0x5555568b1a00 "drive_add 0 file=/home/zhang/img/sparse/sparse.img,format=raw,id=myh1,if=none", readline_opaque=0x0)
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #5  0x0000555555dcda60 in readline_handle_byte (rs=0x5555568b1a00, ch=13) at util/readline.c:393
+ * #6  0x000055555585d581 in monitor_read (opaque=0x5555568a7450, buf=0x7fffffffcf40 "\r\317\377\377\377\177", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #7  0x0000555555d2d217 in qemu_chr_be_write_impl (s=0x555556893ab0, buf=0x7fffffffcf40 "\r\317\377\377\377\177", len=1) at chardev/char.c:175
+ * #8  0x0000555555d2d27b in qemu_chr_be_write (s=0x555556893ab0, buf=0x7fffffffcf40 "\r\317\377\377\377\177", len=1) at chardev/char.c:187
+ * #9  0x0000555555d2f98f in fd_chr_read (chan=0x555556893cf0, cond=G_IO_IN, opaque=0x555556893ab0) at chardev/char-fd.c:66
+ * #10 0x0000555555d4f6b7 in qio_channel_fd_source_dispatch (source=0x55555749a920, callback=0x555555d2f831 <fd_chr_read>, user_data=0x555556893ab0) at io/channel-watch.c:84
+ * #11 0x00007ffff50e004a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #12 0x0000555555db0d34 in glib_pollfds_poll () at util/main-loop.c:215
+ * #13 0x0000555555db0da2 in os_host_main_loop_wait (timeout=499000000) at util/main-loop.c:238
+ * #14 0x0000555555db0e5b in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #15 0x00005555559dee92 in main_loop () at vl.c:1866
+ * #16 0x00005555559e66a5 in main (argc=16, argv=0x7fffffffe3b8, envp=0x7fffffffe440) at vl.c:4644
+ *
+ * called by:
+ *   - vl.c|1143| <<drive_init_func>> return drive_new(opts, *block_default_type) == NULL;
+ *   - device-hotplug.c|48| <<add_init_drive>> dinfo = drive_new(opts, mc->block_default_type);
+ *   - vl.c|1169| <<default_drive>> dinfo = drive_new(opts, type);
+ */
 DriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type)
 {
     const char *value;
     BlockBackend *blk;
+    /* 最终的返回值 */
     DriveInfo *dinfo = NULL;
     QDict *bs_opts;
     QemuOpts *legacy_opts;
@@ -1090,6 +1162,9 @@ DriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type)
     }
 
     /* Actual block device init: Functionality shared with blockdev-add */
+    /*
+     * 核心!!!! blk是BlockBackend
+     */
     blk = blockdev_init(filename, bs_opts, &local_err);
     bs_opts = NULL;
     if (!blk) {
@@ -1116,6 +1191,9 @@ DriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type)
     dinfo->devaddr = devaddr;
     dinfo->serial = g_strdup(serial);
 
+    /*
+     * 设置BlockBackend->legacy_dinfo = DriveInfo
+     */
     blk_set_legacy_dinfo(blk, dinfo);
 
     switch(type) {
diff --git a/bootdevice.c b/bootdevice.c
index 1141009..247eafc 100644
--- a/bootdevice.c
+++ b/bootdevice.c
@@ -208,6 +208,15 @@ DeviceState *get_boot_device(uint32_t position)
  * memory pointed by "size" is assigned total length of the array in bytes
  *
  */
+/*
+ * (gdb) bt
+ * #0  get_boot_devices_list (size=0x7fffffffe078, ignore_suffixes=false) at bootdevice.c:214
+ * #1  0x0000555555b28ae5 in fw_cfg_machine_reset (opaque=0x5555569bc5d0) at hw/nvram/fw_cfg.c:864
+ * #2  0x0000555555a78499 in qemu_devices_reset () at hw/core/reset.c:69
+ * #3  0x000055555591bfda in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #4  0x00005555559d8098 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #5  0x00005555559dfd6e in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4611
+ */
 char *get_boot_devices_list(size_t *size, bool ignore_suffixes)
 {
     FWBootEntry *i;
@@ -280,6 +289,24 @@ static void device_get_bootindex(Object *obj, Visitor *v, const char *name,
     visit_type_int32(v, name, prop->bootindex, errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  device_set_bootindex (obj=0x5555579a9f20, v=0x5555579ace70, name=0x555555ede8fe "bootindex", opaque=0x5555579acd00, errp=0x0) at bootdevice.c:285
+ * #1  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ace70, name=0x555555ede8fe "bootindex", errp=0x0) at qom/object.c:1176
+ * #2  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579ace40, name=0x555555ede8fe "bootindex", errp=0x0) at qom/qom-qobject.c:27
+ * #3  0x0000555555c5e8e6 in object_property_set_int (obj=0x5555579a9f20, value=-1, name=0x555555ede8fe "bootindex", errp=0x0) at qom/object.c:1273
+ * #4  0x00005555559cf629 in device_add_bootindex_property (obj=0x5555579a9f20, bootindex=0x5555579aaa34, name=0x555555ede8fe "bootindex", suffix=0x555555ede8ef "/namespace@1,0", dev=0x5555579a9f20, 
+ *     errp=0x555556751590 <error_abort>) at bootdevice.c:341
+ * #5  0x0000555555a5f923 in nvme_instance_init (obj=0x5555579a9f20) at hw/block/nvme.c:1377
+ * #6  0x0000555555c5c635 in object_init_with_type (obj=0x5555579a9f20, ti=0x555556794080) at qom/object.c:353
+ * #7  0x0000555555c5c7f8 in object_initialize_with_type (data=0x5555579a9f20, size=7248, type=0x555556794080) at qom/object.c:384
+ * #8  0x0000555555c5ce4c in object_new_with_type (type=0x555556794080) at qom/object.c:546
+ * #9  0x0000555555c5ce89 in object_new (typename=0x5555567bde50 "nvme") at qom/object.c:556
+ * #10 0x00005555559d251c in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:608
+ * #11 0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #12 0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #13 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 static void device_set_bootindex(Object *obj, Visitor *v, const char *name,
                                  void *opaque, Error **errp)
 {
diff --git a/data/drive_config_groups.txt b/data/drive_config_groups.txt
new file mode 100644
index 0000000..0940094
--- /dev/null
+++ b/data/drive_config_groups.txt
@@ -0,0 +1,6 @@
+(gdb) p drive_config_groups
+$30 =   {0x555556588f40 <qemu_legacy_drive_opts>,
+  0x5555565891a0 <qemu_common_drive_opts>,
+  0x5555565895e0 <qemu_drive_opts>,
+  0x5555566fd680 <bdrv_runtime_opts>,
+  0x0}
diff --git a/data/index.txt b/data/index.txt
new file mode 100644
index 0000000..2da8553
--- /dev/null
+++ b/data/index.txt
@@ -0,0 +1,15 @@
+qemu/kvm
+
+* cpu virtualization
+    - apic timer
+    - interrupt (apic, ioapic, msi)
+* memory virtualization
+* device virtualization
+    - virtnet
+    - virtblk
+    - vhost
+* vfio and passthrough
+
+
+
+qemu
diff --git a/data/info_mtree.txt b/data/info_mtree.txt
new file mode 100644
index 0000000..fcc73fd
--- /dev/null
+++ b/data/info_mtree.txt
@@ -0,0 +1,420 @@
+(qemu) info mtree
+address-space: memory
+  0000000000000000-ffffffffffffffff (prio 0, i/o): system
+    0000000000000000-00000000bb7fffff (prio 0, i/o): alias ram-below-4g @pc.ram 0000000000000000-00000000bb7fffff
+    0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+      00000000000a0000-00000000000bffff (prio 1, i/o): vga-lowmem
+      00000000000c0000-00000000000dffff (prio 1, rom): pc.rom
+      00000000000e0000-00000000000fffff (prio 1, i/o): alias isa-bios @pc.bios 0000000000020000-000000000003ffff
+      00000000fd000000-00000000fdffffff (prio 1, ram): vga.vram
+      00000000febc0000-00000000febdffff (prio 1, i/o): e1000-mmio
+      00000000febf0000-00000000febf1fff (prio 1, i/o): nvme
+      00000000febf2000-00000000febf2fff (prio 1, i/o): vga.mmio
+        00000000febf2400-00000000febf241f (prio 0, i/o): vga ioports remapped
+        00000000febf2500-00000000febf2515 (prio 0, i/o): bochs dispi interface
+        00000000febf2600-00000000febf2607 (prio 0, i/o): qemu extended regs
+      00000000febf3000-00000000febf3fff (prio 1, i/o): nvme-msix
+        00000000febf3000-00000000febf33ff (prio 0, i/o): msix-table
+        00000000febf3800-00000000febf3807 (prio 0, i/o): msix-pba
+      00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+    00000000000a0000-00000000000bffff (prio 1, i/o): alias smram-region @pci 00000000000a0000-00000000000bffff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c0000-00000000000c3fff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pci 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c4000-00000000000c7fff
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pci 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c8000-00000000000cbfff
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pci 00000000000c8000-00000000000cbfff [disabled]
+    00000000000ca000-00000000000ccfff (prio 1000, i/o): alias kvmvapic-rom @pc.ram 00000000000ca000-00000000000ccfff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000cc000-00000000000cffff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pci 00000000000cc000-00000000000cffff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d0000-00000000000d3fff
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pci 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d4000-00000000000d7fff
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pci 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d8000-00000000000dbfff
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pci 00000000000d8000-00000000000dbfff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000dc000-00000000000dffff
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pci 00000000000dc000-00000000000dffff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e0000-00000000000e3fff
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pci 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e4000-00000000000e7fff
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pci 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e8000-00000000000ebfff
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pci 00000000000e8000-00000000000ebfff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-ram @pc.ram 00000000000ec000-00000000000effff
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-rom @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pci 00000000000ec000-00000000000effff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000f0000-00000000000fffff
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pci 00000000000f0000-00000000000fffff [disabled]
+    00000000fec00000-00000000fec00fff (prio 0, i/o): kvm-ioapic
+    00000000fed00000-00000000fed003ff (prio 0, i/o): hpet
+    00000000fee00000-00000000feefffff (prio 4096, i/o): kvm-apic-msi
+
+address-space: I/O
+  0000000000000000-000000000000ffff (prio 0, i/o): io
+    0000000000000000-0000000000000007 (prio 0, i/o): dma-chan
+    0000000000000008-000000000000000f (prio 0, i/o): dma-cont
+    0000000000000020-0000000000000021 (prio 0, i/o): kvm-pic
+    0000000000000040-0000000000000043 (prio 0, i/o): kvm-pit
+    0000000000000060-0000000000000060 (prio 0, i/o): i8042-data
+    0000000000000061-0000000000000061 (prio 0, i/o): pcspk
+    0000000000000064-0000000000000064 (prio 0, i/o): i8042-cmd
+    0000000000000070-0000000000000071 (prio 0, i/o): rtc
+    000000000000007e-000000000000007f (prio 0, i/o): kvmvapic
+    0000000000000080-0000000000000080 (prio 0, i/o): ioport80
+    0000000000000081-0000000000000083 (prio 0, i/o): dma-page
+    0000000000000087-0000000000000087 (prio 0, i/o): dma-page
+    0000000000000089-000000000000008b (prio 0, i/o): dma-page
+    000000000000008f-000000000000008f (prio 0, i/o): dma-page
+    0000000000000092-0000000000000092 (prio 0, i/o): port92
+    00000000000000a0-00000000000000a1 (prio 0, i/o): kvm-pic
+    00000000000000b2-00000000000000b3 (prio 0, i/o): apm-io
+    00000000000000c0-00000000000000cf (prio 0, i/o): dma-chan
+    00000000000000d0-00000000000000df (prio 0, i/o): dma-cont
+    00000000000000f0-00000000000000f0 (prio 0, i/o): ioportF0
+    0000000000000170-0000000000000177 (prio 0, i/o): ide
+    00000000000001ce-00000000000001d1 (prio 0, i/o): vbe
+    00000000000001f0-00000000000001f7 (prio 0, i/o): ide
+    0000000000000376-0000000000000376 (prio 0, i/o): ide
+    0000000000000378-000000000000037f (prio 0, i/o): parallel
+    00000000000003b4-00000000000003b5 (prio 0, i/o): vga
+    00000000000003ba-00000000000003ba (prio 0, i/o): vga
+    00000000000003c0-00000000000003cf (prio 0, i/o): vga
+    00000000000003d4-00000000000003d5 (prio 0, i/o): vga
+    00000000000003da-00000000000003da (prio 0, i/o): vga
+    00000000000003f1-00000000000003f5 (prio 0, i/o): fdc
+    00000000000003f6-00000000000003f6 (prio 0, i/o): ide
+    00000000000003f7-00000000000003f7 (prio 0, i/o): fdc
+    00000000000003f8-00000000000003ff (prio 0, i/o): serial
+    00000000000004d0-00000000000004d0 (prio 0, i/o): kvm-elcr
+    00000000000004d1-00000000000004d1 (prio 0, i/o): kvm-elcr
+    0000000000000510-0000000000000511 (prio 0, i/o): fwcfg
+    0000000000000514-000000000000051b (prio 0, i/o): fwcfg.dma
+    0000000000000600-000000000000063f (prio 0, i/o): piix4-pm
+      0000000000000600-0000000000000603 (prio 0, i/o): acpi-evt
+      0000000000000604-0000000000000605 (prio 0, i/o): acpi-cnt
+      0000000000000608-000000000000060b (prio 0, i/o): acpi-tmr
+    0000000000000700-000000000000073f (prio 0, i/o): pm-smbus
+    0000000000000cf8-0000000000000cfb (prio 0, i/o): pci-conf-idx
+    0000000000000cf9-0000000000000cf9 (prio 1, i/o): piix3-reset-control
+    0000000000000cfc-0000000000000cff (prio 0, i/o): pci-conf-data
+    0000000000005658-0000000000005658 (prio 0, i/o): vmport
+    000000000000ae00-000000000000ae13 (prio 0, i/o): acpi-pci-hotplug
+    000000000000af00-000000000000af0b (prio 0, i/o): acpi-mem-hotplug
+    000000000000afe0-000000000000afe3 (prio 0, i/o): acpi-gpe0
+    000000000000c000-000000000000c03f (prio 1, i/o): e1000-io
+    000000000000c040-000000000000c04f (prio 1, i/o): piix-bmdma-container
+      000000000000c040-000000000000c043 (prio 0, i/o): piix-bmdma
+      000000000000c044-000000000000c047 (prio 0, i/o): bmdma
+      000000000000c048-000000000000c04b (prio 0, i/o): piix-bmdma
+      000000000000c04c-000000000000c04f (prio 0, i/o): bmdma
+
+address-space: cpu-memory-0
+  0000000000000000-ffffffffffffffff (prio 0, i/o): system
+    0000000000000000-00000000bb7fffff (prio 0, i/o): alias ram-below-4g @pc.ram 0000000000000000-00000000bb7fffff
+    0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+      00000000000a0000-00000000000bffff (prio 1, i/o): vga-lowmem
+      00000000000c0000-00000000000dffff (prio 1, rom): pc.rom
+      00000000000e0000-00000000000fffff (prio 1, i/o): alias isa-bios @pc.bios 0000000000020000-000000000003ffff
+      00000000fd000000-00000000fdffffff (prio 1, ram): vga.vram
+      00000000febc0000-00000000febdffff (prio 1, i/o): e1000-mmio
+      00000000febf0000-00000000febf1fff (prio 1, i/o): nvme
+      00000000febf2000-00000000febf2fff (prio 1, i/o): vga.mmio
+        00000000febf2400-00000000febf241f (prio 0, i/o): vga ioports remapped
+        00000000febf2500-00000000febf2515 (prio 0, i/o): bochs dispi interface
+        00000000febf2600-00000000febf2607 (prio 0, i/o): qemu extended regs
+      00000000febf3000-00000000febf3fff (prio 1, i/o): nvme-msix
+        00000000febf3000-00000000febf33ff (prio 0, i/o): msix-table
+        00000000febf3800-00000000febf3807 (prio 0, i/o): msix-pba
+      00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+    00000000000a0000-00000000000bffff (prio 1, i/o): alias smram-region @pci 00000000000a0000-00000000000bffff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c0000-00000000000c3fff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pci 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c4000-00000000000c7fff
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pci 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c8000-00000000000cbfff
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pci 00000000000c8000-00000000000cbfff [disabled]
+    00000000000ca000-00000000000ccfff (prio 1000, i/o): alias kvmvapic-rom @pc.ram 00000000000ca000-00000000000ccfff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000cc000-00000000000cffff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pci 00000000000cc000-00000000000cffff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d0000-00000000000d3fff
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pci 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d4000-00000000000d7fff
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pci 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d8000-00000000000dbfff
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pci 00000000000d8000-00000000000dbfff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000dc000-00000000000dffff
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pci 00000000000dc000-00000000000dffff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e0000-00000000000e3fff
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pci 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e4000-00000000000e7fff
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pci 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e8000-00000000000ebfff
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pci 00000000000e8000-00000000000ebfff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-ram @pc.ram 00000000000ec000-00000000000effff
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-rom @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pci 00000000000ec000-00000000000effff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000f0000-00000000000fffff
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pci 00000000000f0000-00000000000fffff [disabled]
+    00000000fec00000-00000000fec00fff (prio 0, i/o): kvm-ioapic
+    00000000fed00000-00000000fed003ff (prio 0, i/o): hpet
+    00000000fee00000-00000000feefffff (prio 4096, i/o): kvm-apic-msi
+
+address-space: cpu-memory-1
+  0000000000000000-ffffffffffffffff (prio 0, i/o): system
+    0000000000000000-00000000bb7fffff (prio 0, i/o): alias ram-below-4g @pc.ram 0000000000000000-00000000bb7fffff
+    0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+      00000000000a0000-00000000000bffff (prio 1, i/o): vga-lowmem
+      00000000000c0000-00000000000dffff (prio 1, rom): pc.rom
+      00000000000e0000-00000000000fffff (prio 1, i/o): alias isa-bios @pc.bios 0000000000020000-000000000003ffff
+      00000000fd000000-00000000fdffffff (prio 1, ram): vga.vram
+      00000000febc0000-00000000febdffff (prio 1, i/o): e1000-mmio
+      00000000febf0000-00000000febf1fff (prio 1, i/o): nvme
+      00000000febf2000-00000000febf2fff (prio 1, i/o): vga.mmio
+        00000000febf2400-00000000febf241f (prio 0, i/o): vga ioports remapped
+        00000000febf2500-00000000febf2515 (prio 0, i/o): bochs dispi interface
+        00000000febf2600-00000000febf2607 (prio 0, i/o): qemu extended regs
+      00000000febf3000-00000000febf3fff (prio 1, i/o): nvme-msix
+        00000000febf3000-00000000febf33ff (prio 0, i/o): msix-table
+        00000000febf3800-00000000febf3807 (prio 0, i/o): msix-pba
+      00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+    00000000000a0000-00000000000bffff (prio 1, i/o): alias smram-region @pci 00000000000a0000-00000000000bffff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c0000-00000000000c3fff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pci 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c4000-00000000000c7fff
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pci 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c8000-00000000000cbfff
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pci 00000000000c8000-00000000000cbfff [disabled]
+    00000000000ca000-00000000000ccfff (prio 1000, i/o): alias kvmvapic-rom @pc.ram 00000000000ca000-00000000000ccfff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000cc000-00000000000cffff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pci 00000000000cc000-00000000000cffff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d0000-00000000000d3fff
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pci 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d4000-00000000000d7fff
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pci 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d8000-00000000000dbfff
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pci 00000000000d8000-00000000000dbfff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000dc000-00000000000dffff
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pci 00000000000dc000-00000000000dffff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e0000-00000000000e3fff
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pci 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e4000-00000000000e7fff
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pci 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e8000-00000000000ebfff
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pci 00000000000e8000-00000000000ebfff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-ram @pc.ram 00000000000ec000-00000000000effff
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-rom @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pci 00000000000ec000-00000000000effff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000f0000-00000000000fffff
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pci 00000000000f0000-00000000000fffff [disabled]
+    00000000fec00000-00000000fec00fff (prio 0, i/o): kvm-ioapic
+    00000000fed00000-00000000fed003ff (prio 0, i/o): hpet
+    00000000fee00000-00000000feefffff (prio 4096, i/o): kvm-apic-msi
+
+address-space: i440FX
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff [disabled]
+
+address-space: PIIX3
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff [disabled]
+
+address-space: VGA
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff [disabled]
+
+address-space: e1000
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff
+
+address-space: piix3-ide
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff
+
+address-space: PIIX4_PM
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff [disabled]
+
+address-space: nvme
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff
+
+address-space: KVM-SMRAM
+  0000000000000000-ffffffffffffffff (prio 0, i/o): mem-container-smram
+    0000000000000000-00000000ffffffff (prio 10, i/o): smram
+      00000000000a0000-00000000000bffff (prio 0, i/o): alias smram-low @pc.ram 00000000000a0000-00000000000bffff
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias mem-smram @system 0000000000000000-ffffffffffffffff
+
+memory-region: pc.ram
+  0000000000000000-00000000bb7fffff (prio 0, ram): pc.ram
+
+memory-region: pc.bios
+  00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+
+memory-region: pci
+  0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+    00000000000a0000-00000000000bffff (prio 1, i/o): vga-lowmem
+    00000000000c0000-00000000000dffff (prio 1, rom): pc.rom
+    00000000000e0000-00000000000fffff (prio 1, i/o): alias isa-bios @pc.bios 0000000000020000-000000000003ffff
+    00000000fd000000-00000000fdffffff (prio 1, ram): vga.vram
+    00000000febc0000-00000000febdffff (prio 1, i/o): e1000-mmio
+    00000000febf0000-00000000febf1fff (prio 1, i/o): nvme
+    00000000febf2000-00000000febf2fff (prio 1, i/o): vga.mmio
+      00000000febf2400-00000000febf241f (prio 0, i/o): vga ioports remapped
+      00000000febf2500-00000000febf2515 (prio 0, i/o): bochs dispi interface
+      00000000febf2600-00000000febf2607 (prio 0, i/o): qemu extended regs
+    00000000febf3000-00000000febf3fff (prio 1, i/o): nvme-msix
+      00000000febf3000-00000000febf33ff (prio 0, i/o): msix-table
+      00000000febf3800-00000000febf3807 (prio 0, i/o): msix-pba
+    00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+
+memory-region: system
+  0000000000000000-ffffffffffffffff (prio 0, i/o): system
+    0000000000000000-00000000bb7fffff (prio 0, i/o): alias ram-below-4g @pc.ram 0000000000000000-00000000bb7fffff
+    0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+      00000000000a0000-00000000000bffff (prio 1, i/o): vga-lowmem
+      00000000000c0000-00000000000dffff (prio 1, rom): pc.rom
+      00000000000e0000-00000000000fffff (prio 1, i/o): alias isa-bios @pc.bios 0000000000020000-000000000003ffff
+      00000000fd000000-00000000fdffffff (prio 1, ram): vga.vram
+      00000000febc0000-00000000febdffff (prio 1, i/o): e1000-mmio
+      00000000febf0000-00000000febf1fff (prio 1, i/o): nvme
+      00000000febf2000-00000000febf2fff (prio 1, i/o): vga.mmio
+        00000000febf2400-00000000febf241f (prio 0, i/o): vga ioports remapped
+        00000000febf2500-00000000febf2515 (prio 0, i/o): bochs dispi interface
+        00000000febf2600-00000000febf2607 (prio 0, i/o): qemu extended regs
+      00000000febf3000-00000000febf3fff (prio 1, i/o): nvme-msix
+        00000000febf3000-00000000febf33ff (prio 0, i/o): msix-table
+        00000000febf3800-00000000febf3807 (prio 0, i/o): msix-pba
+      00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+    00000000000a0000-00000000000bffff (prio 1, i/o): alias smram-region @pci 00000000000a0000-00000000000bffff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c0000-00000000000c3fff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pci 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c4000-00000000000c7fff
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pci 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c8000-00000000000cbfff
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pci 00000000000c8000-00000000000cbfff [disabled]
+    00000000000ca000-00000000000ccfff (prio 1000, i/o): alias kvmvapic-rom @pc.ram 00000000000ca000-00000000000ccfff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000cc000-00000000000cffff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pci 00000000000cc000-00000000000cffff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d0000-00000000000d3fff
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pci 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d4000-00000000000d7fff
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pci 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d8000-00000000000dbfff
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pci 00000000000d8000-00000000000dbfff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000dc000-00000000000dffff
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pci 00000000000dc000-00000000000dffff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e0000-00000000000e3fff
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pci 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e4000-00000000000e7fff
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pci 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e8000-00000000000ebfff
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pci 00000000000e8000-00000000000ebfff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-ram @pc.ram 00000000000ec000-00000000000effff
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-rom @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pci 00000000000ec000-00000000000effff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000f0000-00000000000fffff
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pci 00000000000f0000-00000000000fffff [disabled]
+    00000000fec00000-00000000fec00fff (prio 0, i/o): kvm-ioapic
+    00000000fed00000-00000000fed003ff (prio 0, i/o): hpet
+    00000000fee00000-00000000feefffff (prio 4096, i/o): kvm-apic-msi
diff --git a/data/notes-irq.txt b/data/notes-irq.txt
new file mode 100644
index 0000000..dc8b835
--- /dev/null
+++ b/data/notes-irq.txt
@@ -0,0 +1,14 @@
+传统(物理机)中断从某个设备发出,送到IOAPIC.IOAPIC查PRT表找到对应的表项PTE,得知目
+标LAPIC.于是格式化出中断消息发送给LAPIC,通知置remote irr为1(level).
+
+LAPIC收到中断消息后,根据向量号设置IRR后,进行中断选取,取得取得优先级最高的中断后
+,清除IRR,设置ISR,提交CPU进行中断处理,CPU处理完中断后,写LAPIC的EOI,通知IOAPIC清
+除remote irr(level且deassert).
+
+QEMU和KVM都实现了对中断芯片的模拟,这是由于历史原因造成的.早在KVM诞生之前, QEMU
+就提供了一整套对设备的模拟,包括中断芯片.而KVM诞生之后,为了进一步提高中断性能,因
+此又在KVM中实现了一套中断芯片.我们可以通过QEMU的启动参数kernel-irqchip来决定使
+用谁的中断芯片(irq chip)
+* on: KVM模拟全部
+* split: QEMU模拟IOAPIC和PIC,KVM模拟LAPIC
+* off: QEMU模拟全部
diff --git a/data/qemu_options.txt b/data/qemu_options.txt
new file mode 100644
index 0000000..3956fb6
--- /dev/null
+++ b/data/qemu_options.txt
@@ -0,0 +1,722 @@
+(gdb) p qemu_options
+$5 = {{
+    name = 0x555555ec4a19 "h", 
+    flags = 0, 
+    index = 0, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd2e2 "help", 
+    flags = 0, 
+    index = 0, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a1b "version", 
+    flags = 0, 
+    index = 1, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd4f6 "machine", 
+    flags = 1, 
+    index = 2, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a23 "M", 
+    flags = 1, 
+    index = 3, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a25 "cpu", 
+    flags = 1, 
+    index = 4, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd503 "accel", 
+    flags = 1, 
+    index = 5, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebdf86 "smp", 
+    flags = 1, 
+    index = 6, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a29 "numa", 
+    flags = 1, 
+    index = 7, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd59d "add-fd", 
+    flags = 1, 
+    index = 8, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd5e0 "set", 
+    flags = 1, 
+    index = 9, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a2e "global", 
+    flags = 1, 
+    index = 10, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a35 "boot", 
+    flags = 1, 
+    index = 11, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a3a "m", 
+    flags = 1, 
+    index = 12, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a3c "mem-path", 
+    flags = 1, 
+    index = 13, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a45 "mem-prealloc", 
+    flags = 0, 
+    index = 14, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a52 "k", 
+    flags = 1, 
+    index = 15, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a54 "audio-help", 
+    flags = 0, 
+    index = 16, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a5f "soundhw", 
+    flags = 1, 
+    index = 17, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a67 "balloon", 
+    flags = 1, 
+    index = 18, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a6f "device", 
+    flags = 1, 
+    index = 19, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd684 "name", 
+    flags = 1, 
+    index = 20, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a76 "uuid", 
+    flags = 1, 
+    index = 21, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a7b "fda", 
+    flags = 1, 
+    index = 22, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a7f "fdb", 
+    flags = 1, 
+    index = 23, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a83 "hda", 
+    flags = 1, 
+    index = 24, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a87 "hdb", 
+    flags = 1, 
+    index = 25, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a8b "hdc", 
+    flags = 1, 
+    index = 26, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a8f "hdd", 
+    flags = 1, 
+    index = 27, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a93 "cdrom", 
+    flags = 1, 
+    index = 28, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a99 "blockdev", 
+    flags = 1, 
+    index = 29, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4aa2 "drive", 
+    flags = 1, 
+    index = 30, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4aa8 "mtdblock", 
+    flags = 1, 
+    index = 31, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ab1 "sd", 
+    flags = 1, 
+    index = 32, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ab4 "pflash", 
+    flags = 1, 
+    index = 33, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebde89 "snapshot", 
+    flags = 0, 
+    index = 34, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4abb "fsdev", 
+    flags = 1, 
+    index = 35, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ac1 "virtfs", 
+    flags = 1, 
+    index = 36, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ac8 "virtfs_synth", 
+    flags = 0, 
+    index = 37, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ad5 "iscsi", 
+    flags = 1, 
+    index = 38, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4adb "usb", 
+    flags = 0, 
+    index = 39, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4adf "usbdevice", 
+    flags = 1, 
+    index = 40, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ae9 "display", 
+    flags = 1, 
+    index = 41, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4af1 "nographic", 
+    flags = 0, 
+    index = 42, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4afb "curses", 
+    flags = 0, 
+    index = 43, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b02 "no-frame", 
+    flags = 0, 
+    index = 44, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b0b "alt-grab", 
+    flags = 0, 
+    index = 45, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b14 "ctrl-grab", 
+    flags = 0, 
+    index = 46, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b1e "no-quit", 
+    flags = 0, 
+    index = 47, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b26 "sdl", 
+    flags = 0, 
+    index = 48, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b2a "spice", 
+    flags = 1, 
+    index = 49, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b30 "portrait", 
+    flags = 0, 
+    index = 50, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b39 "rotate", 
+    flags = 1, 
+    index = 51, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b40 "vga", 
+    flags = 1, 
+    index = 52, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b44 "full-screen", 
+    flags = 0, 
+    index = 53, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b50 "g", 
+    flags = 1, 
+    index = 54, 
+    arch_mask = 2304
+  }, {
+    name = 0x555555ec4b52 "vnc", 
+    flags = 1, 
+    index = 55, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b56 "win2k-hack", 
+    flags = 0, 
+    index = 56, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4b61 "rtc-td-hack", 
+    flags = 0, 
+    index = 57, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4b6d "no-fd-bootchk", 
+    flags = 0, 
+    index = 58, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4b7b "no-acpi", 
+    flags = 0, 
+    index = 59, 
+    arch_mask = 10
+  }, {
+    name = 0x555555ec4b83 "no-hpet", 
+    flags = 0, 
+    index = 60, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4b8b "acpitable", 
+    flags = 1, 
+    index = 61, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4b95 "smbios", 
+    flags = 1, 
+    index = 62, 
+    arch_mask = 10
+  }, {
+    name = 0x555555ec4b9c "tftp", 
+    flags = 1, 
+    index = 63, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ba1 "bootp", 
+    flags = 1, 
+    index = 64, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ba7 "redir", 
+    flags = 1, 
+    index = 65, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bad "smb", 
+    flags = 1, 
+    index = 66, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bb1 "netdev", 
+    flags = 1, 
+    index = 67, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bb8 "nic", 
+    flags = 1, 
+    index = 68, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bbc "net", 
+    flags = 1, 
+    index = 69, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bc0 "chardev", 
+    flags = 1, 
+    index = 70, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bc8 "bt", 
+    flags = 1, 
+    index = 71, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd645 "tpmdev", 
+    flags = 1, 
+    index = 72, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bcb "kernel", 
+    flags = 1, 
+    index = 73, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bd2 "append", 
+    flags = 1, 
+    index = 74, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bd9 "initrd", 
+    flags = 1, 
+    index = 75, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4be0 "dtb", 
+    flags = 1, 
+    index = 76, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd84c "fw_cfg", 
+    flags = 1, 
+    index = 77, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4be4 "serial", 
+    flags = 1, 
+    index = 78, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4beb "parallel", 
+    flags = 1, 
+    index = 79, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bf4 "monitor", 
+    flags = 1, 
+    index = 80, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bfc "qmp", 
+    flags = 1, 
+    index = 81, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c00 "qmp-pretty", 
+    flags = 1, 
+    index = 82, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c0b "mon", 
+    flags = 1, 
+    index = 83, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c0f "debugcon", 
+    flags = 1, 
+    index = 84, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c18 "pidfile", 
+    flags = 1, 
+    index = 85, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c20 "singlestep", 
+    flags = 0, 
+    index = 86, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c2b "preconfig", 
+    flags = 0, 
+    index = 87, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c35 "S", 
+    flags = 0, 
+    index = 88, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd64c "realtime", 
+    flags = 1, 
+    index = 89, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd65b "overcommit", 
+    flags = 1, 
+    index = 90, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c37 "gdb", 
+    flags = 1, 
+    index = 91, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c3b "s", 
+    flags = 0, 
+    index = 92, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c3d "d", 
+    flags = 1, 
+    index = 93, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c3f "D", 
+    flags = 1, 
+    index = 94, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c41 "dfilter", 
+    flags = 1, 
+    index = 95, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c49 "L", 
+    flags = 1, 
+    index = 96, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c4b "bios", 
+    flags = 1, 
+    index = 97, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c50 "enable-kvm", 
+    flags = 0, 
+    index = 98, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c5b "enable-hax", 
+    flags = 0, 
+    index = 99, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4c66 "xen-domid", 
+    flags = 1, 
+    index = 100, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c70 "xen-create", 
+    flags = 0, 
+    index = 101, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c7b "xen-attach", 
+    flags = 0, 
+    index = 102, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c86 "xen-domid-restrict", 
+    flags = 0, 
+    index = 103, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c99 "no-reboot", 
+    flags = 0, 
+    index = 104, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ca3 "no-shutdown", 
+    flags = 0, 
+    index = 105, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4caf "loadvm", 
+    flags = 1, 
+    index = 106, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4cb6 "daemonize", 
+    flags = 0, 
+    index = 107, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd4d9 "option-rom", 
+    flags = 1, 
+    index = 108, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd4ca "clock", 
+    flags = 1, 
+    index = 109, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebdc12 "localtime", 
+    flags = 0, 
+    index = 110, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4cc0 "startdate", 
+    flags = 1, 
+    index = 111, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd4c1 "rtc", 
+    flags = 1, 
+    index = 112, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd7f9 "icount", 
+    flags = 1, 
+    index = 113, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4cca "watchdog", 
+    flags = 1, 
+    index = 114, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4cd3 "watchdog-action", 
+    flags = 1, 
+    index = 115, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ce3 "echr", 
+    flags = 1, 
+    index = 116, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ce8 "virtioconsole", 
+    flags = 1, 
+    index = 117, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4cf6 "show-cursor", 
+    flags = 0, 
+    index = 118, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d02 "tb-size", 
+    flags = 1, 
+    index = 119, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d0a "incoming", 
+    flags = 1, 
+    index = 120, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d13 "only-migratable", 
+    flags = 0, 
+    index = 121, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d23 "nodefaults", 
+    flags = 0, 
+    index = 122, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d2e "chroot", 
+    flags = 1, 
+    index = 123, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d35 "runas", 
+    flags = 1, 
+    index = 124, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d3b "prom-env", 
+    flags = 1, 
+    index = 125, 
+    arch_mask = 2304
+  }, {
+    name = 0x555555ec4d44 "semihosting", 
+    flags = 0, 
+    index = 126, 
+    arch_mask = 4274
+  }, {
+    name = 0x555555ebd827 "semihosting-config", 
+    flags = 1, 
+    index = 127, 
+    arch_mask = 4274
+  }, {
+    name = 0x555555ec4d50 "old-param", 
+    flags = 0, 
+    index = 128, 
+    arch_mask = 2
+  }, {
+    name = 0x555555ec4d5a "sandbox", 
+    flags = 1, 
+    index = 129, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d62 "readconfig", 
+    flags = 1, 
+    index = 130, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d6d "writeconfig", 
+    flags = 1, 
+    index = 131, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d79 "nodefconfig", 
+    flags = 0, 
+    index = 132, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d85 "no-user-config", 
+    flags = 0, 
+    index = 133, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d94 "trace", 
+    flags = 1, 
+    index = 134, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d9a "qtest", 
+    flags = 1, 
+    index = 135, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4da0 "qtest-log", 
+    flags = 1, 
+    index = 136, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4daa "enable-fips", 
+    flags = 0, 
+    index = 137, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4db6 "no-kvm", 
+    flags = 0, 
+    index = 138, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ebd676 "msg", 
+    flags = 1, 
+    index = 139, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4dbd "dump-vmstate", 
+    flags = 1, 
+    index = 140, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd635 "object", 
+    flags = 1, 
+    index = 141, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x0, 
+    flags = 0, 
+    index = 0, 
+    arch_mask = 0
+  }}
diff --git a/data/qom-tree.txt b/data/qom-tree.txt
new file mode 100644
index 0000000..b3aa5e7
--- /dev/null
+++ b/data/qom-tree.txt
@@ -0,0 +1,262 @@
+(qemu) info qom-tree
+/machine (pc-i440fx-3.0-machine)
+  /unattached (container)
+    /non-qdev-gpio[24] (irq)
+    /non-qdev-gpio[3] (irq)
+    /device[14] (i8257)
+      /dma-page[0] (qemu:memory-region)
+      /dma-page[1] (qemu:memory-region)
+      /dma-cont[0] (qemu:memory-region)
+    /device[9] (hpet)
+      /unnamed-gpio-in[0] (irq)
+      /unnamed-gpio-in[1] (irq)
+      /hpet[0] (qemu:memory-region)
+    /device[18] (floppy)
+    /non-qdev-gpio[7] (irq)
+    /device[22] (port92)
+      /port92[0] (qemu:memory-region)
+    /device[26] (ide-cd)
+    /device[30] (smbus-eeprom)
+    /system[0] (qemu:memory-region)
+    /non-qdev-gpio[13] (irq)
+    /device[34] (smbus-eeprom)
+    /ide[1] (qemu:memory-region)
+    /non-qdev-gpio[17] (irq)
+    /device[2] (qemu64-x86_64-cpu)
+      /lapic (kvm-apic)
+        /kvm-apic-msi[0] (qemu:memory-region)
+    /non-qdev-gpio[21] (irq)
+    /dma-chan[1] (qemu:memory-region)
+    /device[11] (kvm-pit)
+      /kvm-pit[0] (qemu:memory-region)
+      /unnamed-gpio-in[0] (irq)
+    /non-qdev-gpio[0] (irq)
+    /device[6] (kvm-i8259)
+      /kvm-pic[0] (qemu:memory-region)
+      /kvm-elcr[0] (qemu:memory-region)
+    /non-qdev-gpio[25] (irq)
+    /device[15] (isa-serial)
+      /serial[0] (qemu:memory-region)
+    /non-qdev-gpio[4] (irq)
+    /device[19] (i8042)
+      /i8042-cmd[0] (qemu:memory-region)
+      /i8042-data[0] (qemu:memory-region)
+    /non-qdev-gpio[8] (irq)
+    /ioport80[0] (qemu:memory-region)
+    /device[23] (e1000)
+      /e1000.rom[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /e1000-io[0] (qemu:memory-region)
+      /e1000-mmio[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+    /device[27] (PIIX4_PM)
+      /piix4-pm[0] (qemu:memory-region)
+      /acpi-evt[0] (qemu:memory-region)
+      /acpi-tmr[0] (qemu:memory-region)
+      /apm-io[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /acpi-pci-hotplug[0] (qemu:memory-region)
+      /pm-smbus[0] (qemu:memory-region)
+      /acpi-gpe0[0] (qemu:memory-region)
+      /i2c (i2c-bus)
+      /acpi-cnt[0] (qemu:memory-region)
+      /acpi-mem-hotplug[0] (qemu:memory-region)
+      /acpi-cpu-hotplug[0] (qemu:memory-region)
+    /non-qdev-gpio[10] (irq)
+    /device[31] (smbus-eeprom)
+    /isa-bios[0] (qemu:memory-region)
+    /non-qdev-gpio[14] (irq)
+    /pc.rom[0] (qemu:memory-region)
+    /ide[2] (qemu:memory-region)
+    /non-qdev-gpio[18] (irq)
+    /device[3] (kvmclock)
+    /non-qdev-gpio[22] (irq)
+    /device[12] (isa-pcspk)
+      /pcspk[0] (qemu:memory-region)
+    /non-qdev-gpio[1] (irq)
+    /device[7] (kvm-i8259)
+      /kvm-pic[0] (qemu:memory-region)
+      /kvm-elcr[0] (qemu:memory-region)
+    /non-qdev-gpio[5] (irq)
+    /device[16] (isa-parallel)
+      /parallel[0] (qemu:memory-region)
+    /device[20] (vmport)
+      /vmport[0] (qemu:memory-region)
+    /vga.mmio[0] (qemu:memory-region)
+    /non-qdev-gpio[9] (irq)
+    /device[24] (piix3-ide)
+      /piix-bmdma[0] (qemu:memory-region)
+      /piix-bmdma-container[0] (qemu:memory-region)
+      /bmdma[1] (qemu:memory-region)
+      /bmdma[0] (qemu:memory-region)
+      /piix-bmdma[1] (qemu:memory-region)
+      /ide.0 (IDE)
+      /ide.1 (IDE)
+      /bus master[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+    /device[28] (smbus-eeprom)
+    /non-qdev-gpio[11] (irq)
+    /io[0] (qemu:memory-region)
+    /device[32] (smbus-eeprom)
+    /non-qdev-gpio[15] (irq)
+    /device[0] (qemu64-x86_64-cpu)
+      /lapic (kvm-apic)
+        /kvm-apic-msi[0] (qemu:memory-region)
+    /ram-below-4g[0] (qemu:memory-region)
+    /ide[3] (qemu:memory-region)
+    /non-qdev-gpio[19] (irq)
+    /device[4] (i440FX)
+      /smram[0] (qemu:memory-region)
+      /smram-region[0] (qemu:memory-region)
+      /smram-low[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+    /non-qdev-gpio[23] (irq)
+    /pci[0] (qemu:memory-region)
+    /non-qdev-gpio[2] (irq)
+    /device[13] (i8257)
+      /dma-page[0] (qemu:memory-region)
+      /dma-page[1] (qemu:memory-region)
+      /dma-cont[0] (qemu:memory-region)
+    /device[8] (VGA)
+      /vga.rom[0] (qemu:memory-region)
+      /vga[0] (qemu:memory-region)
+      /bochs dispi interface[0] (qemu:memory-region)
+      /vga[2] (qemu:memory-region)
+      /vga[4] (qemu:memory-region)
+      /qemu extended regs[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /vga-lowmem[0] (qemu:memory-region)
+      /vga[1] (qemu:memory-region)
+      /vga[3] (qemu:memory-region)
+      /vga.vram[0] (qemu:memory-region)
+      /vga ioports remapped[0] (qemu:memory-region)
+      /vbe[0] (qemu:memory-region)
+    /pc.bios[0] (qemu:memory-region)
+    /ioportF0[0] (qemu:memory-region)
+    /device[17] (isa-fdc)
+      /floppy-bus.0 (floppy-bus)
+      /fdc[0] (qemu:memory-region)
+      /fdc[1] (qemu:memory-region)
+    /non-qdev-gpio[6] (irq)
+    /device[21] (vmmouse)
+    /sysbus (System)
+    /device[25] (ide-hd)
+    /device[35] (smbus-eeprom)
+    /device[29] (smbus-eeprom)
+    /non-qdev-gpio[12] (irq)
+    /device[33] (smbus-eeprom)
+    /ide[0] (qemu:memory-region)
+    /dma-chan[0] (qemu:memory-region)
+    /non-qdev-gpio[16] (irq)
+    /device[1] (kvmvapic)
+      /kvmvapic[0] (qemu:memory-region)
+      /kvmvapic-rom[0] (qemu:memory-region)
+    /non-qdev-gpio[20] (irq)
+    /device[10] (mc146818rtc)
+      /rtc[0] (qemu:memory-region)
+    /pc.ram[0] (qemu:memory-region)
+    /device[5] (PIIX3)
+      /isa.0 (ISA)
+      /piix3-reset-control[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+  /fw_cfg (fw_cfg_io)
+    /\x2from@etc\x2ftable-loader[0] (qemu:memory-region)
+    /fwcfg[0] (qemu:memory-region)
+    /\x2from@etc\x2facpi\x2frsdp[0] (qemu:memory-region)
+    /\x2from@etc\x2facpi\x2ftables[0] (qemu:memory-region)
+    /fwcfg.dma[0] (qemu:memory-region)
+  /peripheral-anon (container)
+    /device[0] (nvme)
+      /nvme-msix[0] (qemu:memory-region)
+      /msix-table[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /msix-pba[0] (qemu:memory-region)
+      /nvme[0] (qemu:memory-region)
+  /peripheral (container)
+  /i440fx (i440FX-pcihost)
+    /pam-pci[19] (qemu:memory-region)
+    /pam-rom[1] (qemu:memory-region)
+    /pam-pci[8] (qemu:memory-region)
+    /pam-rom[10] (qemu:memory-region)
+    /pam-rom[5] (qemu:memory-region)
+    /pam-pci[23] (qemu:memory-region)
+    /pam-ram[3] (qemu:memory-region)
+    /pam-rom[9] (qemu:memory-region)
+    /pci-conf-idx[0] (qemu:memory-region)
+    /pam-ram[7] (qemu:memory-region)
+    /pam-pci[12] (qemu:memory-region)
+    /pam-pci[1] (qemu:memory-region)
+    /pam-pci[16] (qemu:memory-region)
+    /pam-ram[10] (qemu:memory-region)
+    /pam-pci[20] (qemu:memory-region)
+    /pam-pci[5] (qemu:memory-region)
+    /pam-rom[2] (qemu:memory-region)
+    /pam-pci[24] (qemu:memory-region)
+    /pam-pci[9] (qemu:memory-region)
+    /pam-rom[11] (qemu:memory-region)
+    /pam-rom[6] (qemu:memory-region)
+    /pam-ram[0] (qemu:memory-region)
+    /pam-ram[4] (qemu:memory-region)
+    /pam-ram[8] (qemu:memory-region)
+    /pam-pci[13] (qemu:memory-region)
+    /pam-pci[2] (qemu:memory-region)
+    /pam-pci[17] (qemu:memory-region)
+    /pam-ram[11] (qemu:memory-region)
+    /pam-pci[21] (qemu:memory-region)
+    /pam-pci[6] (qemu:memory-region)
+    /pam-rom[3] (qemu:memory-region)
+    /pam-pci[25] (qemu:memory-region)
+    /ioapic (kvm-ioapic)
+      /unnamed-gpio-in[17] (irq)
+      /unnamed-gpio-in[9] (irq)
+      /unnamed-gpio-in[20] (irq)
+      /unnamed-gpio-in[19] (irq)
+      /unnamed-gpio-in[22] (irq)
+      /unnamed-gpio-in[0] (irq)
+      /unnamed-gpio-in[10] (irq)
+      /unnamed-gpio-in[2] (irq)
+      /unnamed-gpio-in[12] (irq)
+      /unnamed-gpio-in[4] (irq)
+      /unnamed-gpio-in[14] (irq)
+      /unnamed-gpio-in[6] (irq)
+      /unnamed-gpio-in[16] (irq)
+      /unnamed-gpio-in[8] (irq)
+      /unnamed-gpio-in[18] (irq)
+      /unnamed-gpio-in[21] (irq)
+      /unnamed-gpio-in[23] (irq)
+      /unnamed-gpio-in[1] (irq)
+      /kvm-ioapic[0] (qemu:memory-region)
+      /unnamed-gpio-in[11] (irq)
+      /unnamed-gpio-in[3] (irq)
+      /unnamed-gpio-in[13] (irq)
+      /unnamed-gpio-in[5] (irq)
+      /unnamed-gpio-in[15] (irq)
+      /unnamed-gpio-in[7] (irq)
+    /pam-ram[1] (qemu:memory-region)
+    /pam-rom[12] (qemu:memory-region)
+    /pam-rom[7] (qemu:memory-region)
+    /pam-ram[5] (qemu:memory-region)
+    /pci-conf-data[0] (qemu:memory-region)
+    /pam-ram[9] (qemu:memory-region)
+    /pam-pci[10] (qemu:memory-region)
+    /pam-pci[14] (qemu:memory-region)
+    /pam-pci[3] (qemu:memory-region)
+    /pam-pci[18] (qemu:memory-region)
+    /pam-rom[0] (qemu:memory-region)
+    /pam-pci[22] (qemu:memory-region)
+    /pam-pci[7] (qemu:memory-region)
+    /pam-ram[12] (qemu:memory-region)
+    /pam-rom[4] (qemu:memory-region)
+    /pam-ram[2] (qemu:memory-region)
+    /pam-rom[8] (qemu:memory-region)
+    /pam-ram[6] (qemu:memory-region)
+    /pam-pci[11] (qemu:memory-region)
+    /pci.0 (PCI)
+    /pam-pci[0] (qemu:memory-region)
+    /pam-pci[15] (qemu:memory-region)
+    /pam-pci[4] (qemu:memory-region)
diff --git a/data/vm_config_groups.txt b/data/vm_config_groups.txt
new file mode 100644
index 0000000..5f2770b
--- /dev/null
+++ b/data/vm_config_groups.txt
@@ -0,0 +1,33 @@
+(gdb) p vm_config_groups
+$22 =   {0x5555565895e0 <qemu_drive_opts>,
+  0x555556706b00 <qemu_chardev_opts>,
+  0x555556589680 <qemu_device_opts>,
+  0x5555566fa0c0 <qemu_netdev_opts>,
+  0x5555566fa120 <qemu_nic_opts>,
+  0x5555566fa180 <qemu_net_opts>,
+  0x555556589980 <qemu_rtc_opts>,
+  0x5555565896e0 <qemu_global_opts>,
+  0x55555656efa0 <qemu_mon_opts>,
+  0x5555567074e0 <qemu_trace_opts>,
+  0x555556589a40 <qemu_option_rom_opts>,
+  0x555556589ae0 <qemu_machine_opts>,
+  0x555556589b40 <qemu_accel_opts>,
+  0x55555658a100 <qemu_mem_opts>,
+  0x55555658a460 <qemu_smp_opts>,
+  0x555556589be0 <qemu_boot_opts>,
+  0x555556589d20 <qemu_add_fd_opts>,
+  0x555556589de0 <qemu_object_opts>,
+  0x555556589e40 <qemu_tpmdev_opts>,
+  0x555556589ea0 <qemu_realtime_opts>,
+  0x555556589fc0 <qemu_msg_opts>,
+  0x55555658a040 <qemu_name_opts>,
+  0x55555656f0a0 <qemu_numa_opts>,
+  0x55555658a1c0 <qemu_icount_opts>,
+  0x55555658a2e0 <qemu_semihosting_config_opts>,
+  0x55555658a3a0 <qemu_fw_cfg_opts>,
+  0x5555565d0460 <qemu_fsdev_opts>,
+  0x5555565d0840 <qemu_virtfs_opts>,
+  0x5555565d09e0 <qemu_acpi_opts>,
+  0x5555566eb300 <qemu_smbios_opts>,
+  0x5555566fcec0 <qemu_vnc_opts>,
+  0x0 <repeats 17 times>}
diff --git a/exec.c b/exec.c
index 4f5df07..0860f40 100644
--- a/exec.c
+++ b/exec.c
@@ -79,11 +79,24 @@
  */
 RAMList ram_list = { .blocks = QLIST_HEAD_INITIALIZER(ram_list.blocks) };
 
+/*
+ * system_memory作为address_space_memory的根MemoryRegion,
+ * 大小涵盖了整个64位空间的大小, 这是一个pure contaner,并
+ * 不会分配空间的
+ */
 static MemoryRegion *system_memory;
+/*
+ * system_io作为address_space_io的根MemoryRegion,大小为65536,
+ * 也就是平时的io port空间
+ */
 static MemoryRegion *system_io;
 
 AddressSpace address_space_io;
 AddressSpace address_space_memory;
+/*
+ * 在随后的cpu初始化之中,还会初始化多个AddressSpace,
+ * 这些很多都是disabled的,对虚拟机意义不大
+ */
 
 MemoryRegion io_mem_rom, io_mem_notdirty;
 static MemoryRegion io_mem_unassigned;
@@ -159,50 +172,130 @@ static void finalize_target_page_bits(void)
 
 typedef struct PhysPageEntry PhysPageEntry;
 
+/*
+ * skip表示需要移动多少步到下一级页表,如果skip为0,说明这是最末级页表了
+ * 最末尾的页表项表示的是MemoryRegionSection
+ *
+ * AddressSpaceDispatch中的phys_map域则相当于CR3寄存器,用来最开始的寻址
+ */
 struct PhysPageEntry {
     /* How many bits skip to next level (in units of L2_SIZE). 0 for a leaf. */
+    /*
+     * 被修改的地方:
+     *   - exec.c|366| <<phys_map_node_alloc>> e.skip = leaf ? 0 : 1;
+     *   - exec.c|410| <<phys_page_set_level>> lp->skip = 0;
+     *   - exec.c|490| <<phys_page_compact>> lp->skip = 0;
+     *   - exec.c|492| <<phys_page_compact>> lp->skip += p[valid_ptr].skip;
+     *   - exec.c|3380| <<address_space_dispatch_new>> d->phys_map = (PhysPageEntry) { .ptr = PHYS_MAP_NODE_NIL, .skip = 1 };
+     */
     uint32_t skip : 6;
      /* index into phys_sections (!skip) or phys_map_nodes (skip) */
+    /*
+     * 修改的地方:
+     *   - exec.c|378| <<phys_map_node_alloc>> e.ptr = leaf ? PHYS_SECTION_UNASSIGNED : PHYS_MAP_NODE_NIL;
+     *   - exec.c|411| <<phys_page_set_level>> lp->ptr = phys_map_node_alloc(map, level == 0);
+     *   - exec.c|419| <<phys_page_set_level>> lp->ptr = leaf;
+     *   - exec.c|490| <<phys_page_compact>> lp->ptr = p[valid_ptr].ptr;
+     *
+     * ptr是用来索引d->map.nodes[ptr][]的, 每一个nodes[ptr]是一个PhysPageEntry[P_L2_SIZE]
+     */
     uint32_t ptr : 26;
 };
 
+/* 0x3ffffff */
 #define PHYS_MAP_NODE_NIL (((uint32_t)~0) >> 6)
 
 /* Size of the L2 (and L3, etc) page tables.  */
 #define ADDR_SPACE_BITS 64
 
 #define P_L2_BITS 9
+/* 512 */
 #define P_L2_SIZE (1 << P_L2_BITS)
 
+/* 0x6 */
 #define P_L2_LEVELS (((ADDR_SPACE_BITS - TARGET_PAGE_BITS - 1) / P_L2_BITS) + 1)
 
+/* 定义Node是PhysPageEntry[P_L2_SIZE] */
 typedef PhysPageEntry Node[P_L2_SIZE];
 
 typedef struct PhysPageMap {
     struct rcu_head rcu;
 
+    /*
+     * 只在如下修改:
+     *   - exec.c|1731| <<phys_section_add>> return map->sections_nb++;
+     *   - exec.c|1750| <<phys_sections_free>> MemoryRegionSection *section = &map->sections[--map->sections_nb];
+     *
+     * 当前sections[]数组中元素的个数
+     */
     unsigned sections_nb;
+    /*
+     * 只在如下修改:
+     *   - exec.c|1725| <<phys_section_add>> map->sections_nb_alloc = MAX(map->sections_nb_alloc * 2, 16);
+     */
     unsigned sections_nb_alloc;
+    /*
+     * 只在如下修改:
+     *   - exec.c|336| <<phys_map_node_alloc>> ret = map->nodes_nb++;
+     *
+     * 当前nodes[]数组中元素的个数
+     */
     unsigned nodes_nb;
+    /*
+     * 只在如下修改:
+     *   - exec.c|327| <<phys_map_node_reserve>> map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, alloc_hint);
+     *   - exec.c|331| <<phys_map_node_reserve>> map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, map->nodes_nb + nodes);
+     */
     unsigned nodes_nb_alloc;
+    /*
+     * 分配nodes的地方:
+     *   - exec.c|313| <<phys_map_node_reserve>> map->nodes = g_renew(Node, map->nodes, map->nodes_nb_alloc);
+     */
     Node *nodes;
+    /*
+     * 分配sections的地方:
+     *   - exec.c|1741| <<phys_section_add>> map->sections = g_renew(MemoryRegionSection, map->sections,
+     *                                                               map->sections_nb_alloc);
+     */
     MemoryRegionSection *sections;
 } PhysPageMap;
 
+/*
+ * 为了在虚拟机退出时,能够顺利根据物理地址找到对应的HVA地址,qemu会有一个AddressSpaceDispatch结构,
+ * 用来在AddressSpace中进行位置的找寻,继而完成对IO/MMIO地址的访问.
+ */
 struct AddressSpaceDispatch {
     MemoryRegionSection *mru_section;
     /* This is a multi-level map on the physical address space.
      * The bottom level has pointers to MemoryRegionSections.
      */
+    /*
+     * skip表示需要移动多少步到下一级页表,如果skip为0,说明这是最末级页表了
+     * 最末尾的页表项表示的是MemoryRegionSection
+     *
+     * AddressSpaceDispatch中的phys_map域则相当于CR3寄存器,用来最开始的寻址
+     */
     PhysPageEntry phys_map;
+    /*
+     * 保存了一个GPA->HVA的一个映射,通过多层页表实现,当kvm exit退到qemu之后,通过这个
+     * AddressSpaceDispatch里面的map查找对应的MemoryRegionSection,继而找到对应的主机HVA
+     */
     PhysPageMap map;
 };
 
+/*
+ * TARGET_PAGE_MASK  = 0xfffff000
+ * ~TARGET_PAGE_MASK = 0xfff
+ */
 #define SUBPAGE_IDX(addr) ((addr) & ~TARGET_PAGE_MASK)
 typedef struct subpage_t {
     MemoryRegion iomem;
     FlatView *fv;
     hwaddr base;
+    /*
+     * 在subpage_init()初始化时分配TARGET_PAGE_SIZE * sizeof(uint16_t)
+     * 一共4K个元素 (i386)
+     */
     uint16_t sub_section[];
 } subpage_t;
 
@@ -241,17 +334,37 @@ struct DirtyBitmapSnapshot {
 
 #if !defined(CONFIG_USER_ONLY)
 
+/*
+ * called only by:
+ *   - exec.c|337| <<phys_page_set>> phys_map_node_reserve(&d->map, 3 * P_L2_LEVELS);
+ *
+ * 检查一下PhysPageMap是否还有nodes个Node (map->nodes_nb+nodes小于等于 map->nodes_nb_alloc)
+ * 否则就要提前分配一些
+ */
 static void phys_map_node_reserve(PhysPageMap *map, unsigned nodes)
 {
     static unsigned alloc_hint = 16;
     if (map->nodes_nb + nodes > map->nodes_nb_alloc) {
+        /*
+	 * nodes_nb_alloc只在当前函数修改
+	 */
         map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, alloc_hint);
+	/*
+	 * 如果参数nodes特别大(要求分配的特别多), nodes_nb_alloc会超过16
+	 */
         map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, map->nodes_nb + nodes);
+	/*
+	 * 唯一分配nodes的地方
+	 */
         map->nodes = g_renew(Node, map->nodes, map->nodes_nb_alloc);
         alloc_hint = map->nodes_nb_alloc;
     }
 }
 
+/*
+ * called only by:
+ *   - exec.c|363| <<phys_page_set_level>> lp->ptr = phys_map_node_alloc(map, level == 0);
+ */
 static uint32_t phys_map_node_alloc(PhysPageMap *map, bool leaf)
 {
     unsigned i;
@@ -265,20 +378,52 @@ static uint32_t phys_map_node_alloc(PhysPageMap *map, bool leaf)
     assert(ret != map->nodes_nb_alloc);
 
     e.skip = leaf ? 0 : 1;
+    /*
+     * 最末尾的页表项(level=0, 也就是leaf=true)表示的是MemoryRegionSection
+     */
     e.ptr = leaf ? PHYS_SECTION_UNASSIGNED : PHYS_MAP_NODE_NIL;
     for (i = 0; i < P_L2_SIZE; ++i) {
+        /* 把512个entry都初始化成上面e相同的样子 */
         memcpy(&p[i], &e, sizeof(e));
     }
     return ret;
 }
 
+/*
+ * called by:
+ *   - exec.c|343| <<phys_page_set_level>> phys_page_set_level(map, lp, index, nb, leaf, level - 1);
+ *   - exec.c|368| <<phys_page_set>> phys_page_set_level(&d->map, &d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);
+ *
+ * ---> register_subpage()   ---> phys_page_set() ---> phys_page_set_level()
+ * ---> register_multipage() ---> phys_page_set() ---> phys_page_set_level()
+ *
+ * 如果是从register_multipage()那条路径进来的:
+ *     map: AddressSpaceDispatch的PhysPageMap
+ *     lp: d->phys_map, 理解成cr3
+ *     index: 物理内存页的起始pfn
+ *     nb: 物理内存页的数目
+ *     leaf: section在map->sections[]数组中的index
+ *     level: P_L2_LEVELS - 1 = 5
+ *
+ * 填充页表?
+ */
 static void phys_page_set_level(PhysPageMap *map, PhysPageEntry *lp,
                                 hwaddr *index, hwaddr *nb, uint16_t leaf,
                                 int level)
 {
     PhysPageEntry *p;
+    /*
+     * 这个函数的总入口只能是phys_page_set()
+     * 所以一开始level = 5, step是1往左移动45位
+     */
     hwaddr step = (hwaddr)1 << (level * P_L2_BITS);
 
+    /*
+     * skip表示需要移动多少步到下一级页表,如果skip为0,说明这是最末级页表了
+     * 最末尾的页表项表示的是MemoryRegionSection
+     *
+     * AddressSpaceDispatch中的phys_map域则相当于CR3寄存器,用来最开始的寻址
+     */
     if (lp->skip && lp->ptr == PHYS_MAP_NODE_NIL) {
         lp->ptr = phys_map_node_alloc(map, level == 0);
     }
@@ -298,13 +443,39 @@ static void phys_page_set_level(PhysPageMap *map, PhysPageEntry *lp,
     }
 }
 
+/*
+ * called by:
+ *   - exec.c|1719| <<register_subpage>> phys_page_set(d, base >> TARGET_PAGE_BITS, 1,
+ *                                                     phys_section_add(&d->map, &subsection));
+ *   - exec.c|1747| <<register_multipage>> phys_page_set(d, start_addr >> TARGET_PAGE_BITS, num_pages, section_index);
+ *
+ * 如果是register_multipage()进来的:
+ *     d: FlatView的dispatch (AddressSpaceDispatch)
+ *     index: 物理内存页的起始pfn
+ *     nb: 物理内存页的数目
+ *     leaf: section在map->sections[]数组中的index
+ */
 static void phys_page_set(AddressSpaceDispatch *d,
                           hwaddr index, hwaddr nb,
                           uint16_t leaf)
 {
     /* Wildly overreserve - it doesn't matter much. */
+    /*
+     * 检查一下PhysPageMap是否还有nodes个Node (map->nodes_nb+nodes小于等于 map->nodes_nb_alloc)
+     * 否则就要提前分配一些
+     *
+     * 这里nodes = 3 * P_L2_LEVELS = 18
+     */
     phys_map_node_reserve(&d->map, 3 * P_L2_LEVELS);
 
+    /*
+     * d->map: PhysPageMap
+     * d->phys_map: 理解成cr3
+     * index: 物理内存页的起始pfn
+     * nb: 物理内存页的数目
+     * leaf: section在map->sections[]数组中的index
+     * P_L2_LEVELS - 1: 5
+     */
     phys_page_set_level(&d->map, &d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);
 }
 
@@ -361,6 +532,10 @@ static void phys_page_compact(PhysPageEntry *lp, Node *nodes)
     }
 }
 
+/*
+ * called only by:
+ *   - memory.c|1087| <<generate_memory_topology>> address_space_dispatch_compact(view->dispatch);
+ */
 void address_space_dispatch_compact(AddressSpaceDispatch *d)
 {
     if (d->phys_map.skip) {
@@ -368,6 +543,9 @@ void address_space_dispatch_compact(AddressSpaceDispatch *d)
     }
 }
 
+/*
+ * 检查一下基于AddressSpace的addr是否在section的地址范围中
+ */
 static inline bool section_covers_addr(const MemoryRegionSection *section,
                                        hwaddr addr)
 {
@@ -379,22 +557,61 @@ static inline bool section_covers_addr(const MemoryRegionSection *section,
                              int128_getlo(section->size), addr);
 }
 
+/*
+ * called by:
+ *   - exec.c|430| <<address_space_lookup_region>> section = phys_page_find(d, addr);
+ *   - exec.c|1622| <<register_subpage>> MemoryRegionSection *existing = phys_page_find(d, base);
+ *
+ * 根据物理地址, 在AddressSpaceDispatch中寻找返回MemoryRegionSection (比如d->map.sections[lp.ptr])
+ * 中间经历了一些看不懂的类似页表转换
+ * 最末尾的页表项表示的是MemoryRegionSection
+ */
 static MemoryRegionSection *phys_page_find(AddressSpaceDispatch *d, hwaddr addr)
 {
+    /*
+     * skip表示需要移动多少步到下一级页表,如果skip为0,说明这是最末级页表了
+     * 最末尾的页表项表示的是MemoryRegionSection
+     *
+     * AddressSpaceDispatch中的phys_map域则相当于CR3寄存器,用来最开始的寻址
+     */
     PhysPageEntry lp = d->phys_map, *p;
+    /* 一个Node相当于PhysPageEntry[P_L2_SIZE] */
     Node *nodes = d->map.nodes;
     MemoryRegionSection *sections = d->map.sections;
     hwaddr index = addr >> TARGET_PAGE_BITS;
     int i;
 
+    /*
+     * P_L2_LEVELS是0x6
+     *
+     * 一开始lp是d->phys_map, 相当于cr3
+     */
     for (i = P_L2_LEVELS; lp.skip && (i -= lp.skip) >= 0;) {
         if (lp.ptr == PHYS_MAP_NODE_NIL) {
+            /* sections来自d->map.sections */
             return &sections[PHYS_SECTION_UNASSIGNED];
         }
+	/*
+	 * p是一个PhysPageEntry指针
+	 *
+	 * nodes[lp.ptr]本身是一个数组 (这样nodes就是二维数组了)
+	 */
         p = nodes[lp.ptr];
+	/*
+	 * 这里用p[]索引, 说明上一行的p是一个数组, nodes是二维数组!
+	 *
+	 * index在这个函数没变过就是物理地址往右移12位
+	 * 根据level(i)决定应该往右移几个9bit, 最后就是一个9bit的数(最大512), 用来索引p[]
+	 */
         lp = p[(index >> (i * P_L2_BITS)) & (P_L2_SIZE - 1)];
     }
 
+    /*
+     * section_covers_addr()表示需要移动多少步到下一级页表,如果skip为0,说明这是最末级页表了
+     * 最末尾的页表项表示的是MemoryRegionSection
+     *
+     * 检查一下基于AddressSpace的addr是否在section的地址范围中
+     */
     if (section_covers_addr(&sections[lp.ptr], addr)) {
         return &sections[lp.ptr];
     } else {
@@ -418,6 +635,10 @@ static MemoryRegionSection *address_space_lookup_region(AddressSpaceDispatch *d,
 
     if (!section || section == &d->map.sections[PHYS_SECTION_UNASSIGNED] ||
         !section_covers_addr(section, addr)) {
+        /*
+	 * 根据物理地址, 在AddressSpaceDispatch中寻找返回MemoryRegionSection (比如d->map.sections[lp.ptr])
+	 * 中间经历了一些看不懂的类似页表转换
+	 */
         section = phys_page_find(d, addr);
         atomic_set(&d->mru_section, section);
     }
@@ -1305,15 +1526,31 @@ void cpu_abort(CPUState *cpu, const char *fmt, ...)
 
 #if !defined(CONFIG_USER_ONLY)
 /* Called from RCU critical section */
+/*
+ * called by:
+ *   - exec.c|1358| <<tlb_reset_dirty_range_all>> block = qemu_get_ram_block(start);
+ *   - exec.c|1359| <<tlb_reset_dirty_range_all>> assert(block == qemu_get_ram_block(end - 1));
+ *   - exec.c|2510| <<qemu_map_ram_ptr>> block = qemu_get_ram_block(addr);
+ *   - exec.c|2542| <<qemu_ram_ptr_length>> block = qemu_get_ram_block(addr);
+ *   - exec.c|2599| <<qemu_ram_block_from_host>> block = qemu_get_ram_block(ram_addr);
+ *
+ * 根据给定的模拟的物理地址 返回对应的RAMBlock
+ */
 static RAMBlock *qemu_get_ram_block(ram_addr_t addr)
 {
     RAMBlock *block;
 
+    /*
+     * mru: most recently used
+     */
     block = atomic_rcu_read(&ram_list.mru_block);
     if (block && addr - block->offset < block->max_length) {
         return block;
     }
     RAMBLOCK_FOREACH(block) {
+        /*
+	 * offset是RAMBlock在内存中代表的基地址
+	 */
         if (addr - block->offset < block->max_length) {
             goto found;
         }
@@ -1535,6 +1772,10 @@ void phys_mem_set_alloc(void *(*alloc)(size_t, uint64_t *align, bool shared))
     phys_mem_alloc = alloc;
 }
 
+/*
+ * 使map->sections[map->sections_nb] = *section;
+ * 然后增加map->sections_nb并返回增加前的map->sections_nb
+ */
 static uint16_t phys_section_add(PhysPageMap *map,
                                  MemoryRegionSection *section)
 {
@@ -1544,13 +1785,21 @@ static uint16_t phys_section_add(PhysPageMap *map,
      */
     assert(map->sections_nb < TARGET_PAGE_SIZE);
 
+    /* 如果空间不够了重新分配 */
     if (map->sections_nb == map->sections_nb_alloc) {
         map->sections_nb_alloc = MAX(map->sections_nb_alloc * 2, 16);
+	/*
+	 * g_renew(struct_type, mem, n_structs):
+	 * Reallocates the memory pointed to by mem, so that it now has
+	 * space for n_structs elements of type struct_type. It returns
+	 * the new address of the memory, which may have been moved.
+	 */
         map->sections = g_renew(MemoryRegionSection, map->sections,
                                 map->sections_nb_alloc);
     }
     map->sections[map->sections_nb] = *section;
     memory_region_ref(section->mr);
+    /* 先确定返回值是map->sections_nb然后在加加 */
     return map->sections_nb++;
 }
 
@@ -1577,22 +1826,37 @@ static void phys_sections_free(PhysPageMap *map)
     g_free(map->nodes);
 }
 
+/*
+ * 被generate_memory_topology()-->flatview_add_to_dispatch()在三处调用
+ */
 static void register_subpage(FlatView *fv, MemoryRegionSection *section)
 {
     AddressSpaceDispatch *d = flatview_to_dispatch(fv);
     subpage_t *subpage;
+    /* TARGET_PAGE_MASK = 0xfffff000 */
     hwaddr base = section->offset_within_address_space
         & TARGET_PAGE_MASK;
+    /*
+     * 根据物理地址, 在AddressSpaceDispatch中寻找返回MemoryRegionSection (比如d->map.sections[lp.ptr])
+     * 中间经历了一些看不懂的类似页表转换
+     */
     MemoryRegionSection *existing = phys_page_find(d, base);
+    /* 初始化subsection的size是4K */
     MemoryRegionSection subsection = {
         .offset_within_address_space = base,
-        .size = int128_make64(TARGET_PAGE_SIZE),
+        .size = int128_make64(TARGET_PAGE_SIZE), // TARGET_PAGE_SIZE在i386是4K
     };
     hwaddr start, end;
 
     assert(existing->mr->subpage || existing->mr == &io_mem_unassigned);
 
     if (!(existing->mr->subpage)) {
+        /*
+	 * 分配初始化一个subpage_t (后面跟着TARGET_PAGE_SIZE * sizeof(uint16_t)作为sub_section[]数组)
+	 * subpage_t的base设置成参数base
+	 * 用memory_region_init_io()初始化subpage_t的iomem (MemoryRegion)
+	 * 把sub_section的4096个uint16_t全部设置成PHYS_SECTION_UNASSIGNED
+	 */
         subpage = subpage_init(fv, base);
         subsection.fv = fv;
         subsection.mr = &subpage->iomem;
@@ -1608,24 +1872,53 @@ static void register_subpage(FlatView *fv, MemoryRegionSection *section)
 }
 
 
+/*
+ * called only by:
+ *   - generate_memory_topology()-->flatview_add_to_dispatch()
+ */
 static void register_multipage(FlatView *fv,
                                MemoryRegionSection *section)
 {
     AddressSpaceDispatch *d = flatview_to_dispatch(fv);
     hwaddr start_addr = section->offset_within_address_space;
+    /*
+     * 使map->sections[map->sections_nb] = *section;
+     * 然后增加map->sections_nb并返回增加前的map->sections_nb
+     */
     uint16_t section_index = phys_section_add(&d->map, section);
     uint64_t num_pages = int128_get64(int128_rshift(section->size,
                                                     TARGET_PAGE_BITS));
 
     assert(num_pages);
+    /*
+     * d: FlatView的dispatch (AddressSpaceDispatch)
+     * start_addr >> TARGET_PAGE_BITS : 物理内存页的起始pfn
+     * num_pages: 物理内存页的数目
+     * section_index: section在map->sections[]数组中的index 
+     */
     phys_page_set(d, start_addr >> TARGET_PAGE_BITS, num_pages, section_index);
 }
 
+/*
+ * called only by:
+ *   - memory.c|795| <<generate_memory_topology>> flatview_add_to_dispatch(view, &mrs);
+ *
+ * register_subpage()和register_multipage()都只被flatview_add_to_dispatch()调用!
+ *
+ * 被调用的时候是根据每个view->ranges[i]调用一下
+ *
+ * 把一个MemoryRegionSection在FlatView的页表中填充一下!
+ */
 void flatview_add_to_dispatch(FlatView *fv, MemoryRegionSection *section)
 {
+    /* now和remain都是做的拷贝 */
     MemoryRegionSection now = *section, remain = *section;
     Int128 page_size = int128_make64(TARGET_PAGE_SIZE);
 
+    /*
+     * TARGET_PAGE_MASK  = 0xfffff000
+     * ~TARGET_PAGE_MASK = 0xfff
+     */
     if (now.offset_within_address_space & ~TARGET_PAGE_MASK) {
         uint64_t left = TARGET_PAGE_ALIGN(now.offset_within_address_space)
                        - now.offset_within_address_space;
@@ -1640,6 +1933,9 @@ void flatview_add_to_dispatch(FlatView *fv, MemoryRegionSection *section)
         remain.offset_within_address_space += int128_get64(now.size);
         remain.offset_within_region += int128_get64(now.size);
         now = remain;
+	/*
+	 * page_size就是4096=TARGET_PAGE_SIZE
+	 */
         if (int128_lt(remain.size, page_size)) {
             register_subpage(fv, &now);
         } else if (remain.offset_within_address_space & ~TARGET_PAGE_MASK) {
@@ -1909,6 +2205,10 @@ static void *file_ram_alloc(RAMBlock *block,
  * dirty bitmaps.
  * Called with the ramlist lock held.
  */
+/*
+ * called only by:
+ *   - exec.c|2212| <<ram_block_add>> new_block->offset = find_ram_offset(new_block->max_length);
+ */
 static ram_addr_t find_ram_offset(ram_addr_t size)
 {
     RAMBlock *block, *next_block;
@@ -2179,6 +2479,29 @@ static void dirty_memory_extend(ram_addr_t old_ram_size,
     }
 }
 
+/*
+ * 一个例子:
+ * (gdb) bt
+ * #0  ram_block_add (new_block=0x5555568fb9d0, errp=0x7fffffffdd58, shared=false) at /home/zhang/kvm/qemu-3.0.0/exec.c:2183
+ * #1  0x0000555555801ea9 in qemu_ram_alloc_internal (size=2097152000, max_size=2097152000, resized=0x0, host=0x0, resizeable=false, share=false, mr=0x5555568fb440, errp=0x555556751598 <error_fatal>)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:2375
+ * #2  0x0000555555801f84 in qemu_ram_alloc (size=2097152000, share=false, mr=0x5555568fb440, errp=0x555556751598 <error_fatal>) at /home/zhang/kvm/qemu-3.0.0/exec.c:2394
+ * #3  0x0000555555867b1a in memory_region_init_ram_shared_nomigrate (mr=0x5555568fb440, owner=0x0, name=0x555555ea76a7 "pc.ram", size=2097152000, share=false, errp=0x555556751598 <error_fatal>)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:1525
+ * #4  0x0000555555867aa3 in memory_region_init_ram_nomigrate (mr=0x5555568fb440, owner=0x0, name=0x555555ea76a7 "pc.ram", size=2097152000, errp=0x555556751598 <error_fatal>)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:1511
+ * #5  0x000055555585f53a in allocate_system_memory_nonnuma (mr=0x5555568fb440, owner=0x0, name=0x555555ea76a7 "pc.ram", ram_size=2097152000) at /home/zhang/kvm/qemu-3.0.0/numa.c:502
+ * #6  0x000055555585f5a9 in memory_region_allocate_system_memory (mr=0x5555568fb440, owner=0x0, name=0x555555ea76a7 "pc.ram", ram_size=2097152000) at /home/zhang/kvm/qemu-3.0.0/numa.c:515
+ * #7  0x0000555555918fdb in pc_memory_init (pcms=0x55555684f780, system_memory=0x555556850d40, rom_memory=0x5555568faff0, ram_memory=0x7fffffffdfc8) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1346
+ * #8  0x000055555591ceb7 in pc_init1 (machine=0x55555684f780, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:181
+ * #9  0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f780) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #10 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f780) at hw/core/machine.c:830
+ * #11 0x00005555559dfb8f in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4516
+ *
+ * called by:
+ *   - exec.c|2353| <<qemu_ram_alloc_from_fd>> ram_block_add(new_block, &local_err, share);
+ *   - exec.c|2418| <<qemu_ram_alloc_internal>> ram_block_add(new_block, &local_err, share);
+ */
 static void ram_block_add(RAMBlock *new_block, Error **errp, bool shared)
 {
     RAMBlock *block;
@@ -2344,6 +2667,12 @@ RAMBlock *qemu_ram_alloc_from_file(ram_addr_t size, MemoryRegion *mr,
 }
 #endif
 
+/*
+ * called by:
+ *   - exec.c|2430| <<qemu_ram_alloc_from_ptr>> return qemu_ram_alloc_internal(size, size, NULL, host, false,
+ *   - exec.c|2437| <<qemu_ram_alloc>> return qemu_ram_alloc_internal(size, size, NULL, NULL, false,
+ *   - exec.c|2447| <<qemu_ram_alloc_resizeable>> return qemu_ram_alloc_internal(size, maxsz, resized, NULL, true,
+ */
 static
 RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                   void (*resized)(const char*,
@@ -2388,6 +2717,12 @@ RAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
                                    false, mr, errp);
 }
 
+/*
+ * called by:
+ *   - memory.c|1647| <<memory_region_init_ram_shared_nomigrate>> mr->ram_block = qemu_ram_alloc(size, share, mr, errp);
+ *   - memory.c|1758| <<memory_region_init_rom_nomigrate>> mr->ram_block = qemu_ram_alloc(size, false, mr, errp);
+ *   - memory.c|1777| <<memory_region_init_rom_device_nomigrate>> mr->ram_block = qemu_ram_alloc(size, false, mr, errp);
+ */
 RAMBlock *qemu_ram_alloc(ram_addr_t size, bool share,
                          MemoryRegion *mr, Error **errp)
 {
@@ -2935,6 +3270,13 @@ static const MemoryRegionOps subpage_ops = {
     .endianness = DEVICE_NATIVE_ENDIAN,
 };
 
+/*
+ * called by:
+ *   - exec.c|1668| <<register_subpage>> subpage_register(subpage, start, end,
+ *   - exec.c|3084| <<subpage_init>> subpage_register(mmio, 0, TARGET_PAGE_SIZE-1, PHYS_SECTION_UNASSIGNED);
+ *
+ * 如果是从subpage_register()进来的, 把参数mmio(subpage_t)的sub_section的4096个uint16_t全部设置成PHYS_SECTION_UNASSIGNED
+ */
 static int subpage_register (subpage_t *mmio, uint32_t start, uint32_t end,
                              uint16_t section)
 {
@@ -2942,26 +3284,57 @@ static int subpage_register (subpage_t *mmio, uint32_t start, uint32_t end,
 
     if (start >= TARGET_PAGE_SIZE || end >= TARGET_PAGE_SIZE)
         return -1;
+    /* 把start和0xfff相and */
     idx = SUBPAGE_IDX(start);
     eidx = SUBPAGE_IDX(end);
+
+    /*
+     * 如果是从subpage_register()进来的, 此时:
+     *   idx  = 0x0
+     *   eidx = 0xfff
+     */
+
 #if defined(DEBUG_SUBPAGE)
     printf("%s: %p start %08x end %08x idx %08x eidx %08x section %d\n",
            __func__, mmio, start, end, idx, eidx, section);
 #endif
     for (; idx <= eidx; idx++) {
+        /*
+	 * 如果是从subpage_register()进来的, 此时section是PHYS_SECTION_UNASSIGNED
+	 */
         mmio->sub_section[idx] = section;
     }
 
     return 0;
 }
 
+/*
+ * called only by register_subpage()
+ *
+ * 分配初始化一个subpage_t (后面跟着TARGET_PAGE_SIZE * sizeof(uint16_t)作为sub_section[]数组)
+ * subpage_t的base设置成参数base
+ * 用memory_region_init_io()初始化subpage_t的iomem (MemoryRegion)
+ * 把sub_section的4096个uint16_t全部设置成PHYS_SECTION_UNASSIGNED
+ */
 static subpage_t *subpage_init(FlatView *fv, hwaddr base)
 {
     subpage_t *mmio;
 
+    /*
+     * TARGET_PAGE_SIZE是4K
+     *
+     * 除了subpage_t, 还要额外分配4K个uint16_t
+     */
     mmio = g_malloc0(sizeof(subpage_t) + TARGET_PAGE_SIZE * sizeof(uint16_t));
     mmio->fv = fv;
     mmio->base = base;
+    /*
+     * 初始化MemoryRegion,比如:
+     *     根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     *     MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+     *     然后简单初始化MemoryRegion的各个field
+     * 设置mr的ops, opaqueue和terminates=true
+     */
     memory_region_init_io(&mmio->iomem, NULL, &subpage_ops, mmio,
                           NULL, TARGET_PAGE_SIZE);
     mmio->iomem.subpage = true;
@@ -2969,6 +3342,13 @@ static subpage_t *subpage_init(FlatView *fv, hwaddr base)
     printf("%s: %p base " TARGET_FMT_plx " len %08x\n", __func__,
            mmio, base, TARGET_PAGE_SIZE);
 #endif
+    /*
+     * mmio是subpage_t
+     * TARGET_PAGE_SIZE是4K
+     * PHYS_SECTION_UNASSIGNED是0
+     *
+     * 把参数mmio(subpage_t)的sub_section的4096个uint16_t全部设置成PHYS_SECTION_UNASSIGNED
+     */
     subpage_register(mmio, 0, TARGET_PAGE_SIZE-1, PHYS_SECTION_UNASSIGNED);
 
     return mmio;
@@ -2985,6 +3365,10 @@ static uint16_t dummy_section(PhysPageMap *map, FlatView *fv, MemoryRegion *mr)
         .size = int128_2_64(),
     };
 
+    /*
+     * 使map->sections[map->sections_nb] = *section;
+     * 然后增加map->sections_nb
+     */
     return phys_section_add(map, &section);
 }
 
@@ -3049,8 +3433,12 @@ static void io_mem_init(void)
                           NULL, UINT64_MAX);
 }
 
+/*
+ * 分配一个AddressSpaceDispatch并简单初始化一些dummy section
+ */
 AddressSpaceDispatch *address_space_dispatch_new(FlatView *fv)
 {
+    /* 分配一个AddressSpaceDispatch */
     AddressSpaceDispatch *d = g_new0(AddressSpaceDispatch, 1);
     uint16_t n;
 
@@ -3093,17 +3481,38 @@ static void tcg_commit(MemoryListener *listener)
     tlb_flush(cpuas->cpu);
 }
 
+/*
+ * called only by (只被vl.c的main()调用----->cpu_exec_init_all()):
+ *   - exec.c|3534| <<cpu_exec_init_all>> memory_map_init();
+ */
 static void memory_map_init(void)
 {
+    /*
+     * system_memory作为address_space_memory的根MemoryRegion,
+     * 大小涵盖了整个64位空间的大小, 这是一个pure contaner,并
+     * 不会分配空间的
+     */
     system_memory = g_malloc(sizeof(*system_memory));
 
     memory_region_init(system_memory, NULL, "system", UINT64_MAX);
     address_space_init(&address_space_memory, system_memory, "memory");
 
+    /*
+     * system_io作为address_space_io的根MemoryRegion,大小为65536,
+     * 也就是平时的io port空间
+     */
     system_io = g_malloc(sizeof(*system_io));
     memory_region_init_io(system_io, NULL, &unassigned_io_ops, NULL, "io",
                           65536);
     address_space_init(&address_space_io, system_io, "I/O");
+
+    /*
+     * 在随后的cpu初始化之中,还会初始化多个AddressSpace,
+     * 这些很多都是disabled的,对虚拟机意义不大
+     *
+     * 重点在随后的main->pc_init_v2_8->pc_init1->pc_memory_init中,这
+     * 里面是分配系统ram,也是第一次真正为虚拟机分配物理内存.
+     */
 }
 
 MemoryRegion *get_system_memory(void)
@@ -3519,6 +3928,9 @@ void cpu_register_map_client(QEMUBH *bh)
     qemu_mutex_unlock(&map_client_list_lock);
 }
 
+/*
+ * 只被vl.c的main()调用
+ */
 void cpu_exec_init_all(void)
 {
     qemu_mutex_init(&ram_list.mutex);
diff --git a/hmp.c b/hmp.c
index 2aafb50..2a2f4d0 100644
--- a/hmp.c
+++ b/hmp.c
@@ -2548,6 +2548,13 @@ void hmp_info_iothreads(Monitor *mon, const QDict *qdict)
     qapi_free_IOThreadInfoList(info_list);
 }
 
+/*
+ * (qemu) qom-list /
+ * machine (child<pc-i440fx-3.0-machine>)
+ * type (string)
+ * chardevs (child<container>)
+ * backend (child<container>)
+ */
 void hmp_qom_list(Monitor *mon, const QDict *qdict)
 {
     const char *path = qdict_get_try_str(qdict, "path");
diff --git a/hw/block/dataplane/virtio-blk.c b/hw/block/dataplane/virtio-blk.c
index 8c37bd3..3773cc0 100644
--- a/hw/block/dataplane/virtio-blk.c
+++ b/hw/block/dataplane/virtio-blk.c
@@ -29,10 +29,26 @@ struct VirtIOBlockDataPlane {
     bool starting;
     bool stopping;
 
+    /*
+     * 也包含一个"IOThread *iothread;"指针
+     * 这里conf->iothread被VirtIOBlockDataPlane->iothread指向
+     *
+     * 指向VirtIOBlock->conf
+     */
     VirtIOBlkConf *conf;
     VirtIODevice *vdev;
+    /* s->bh = aio_bh_new(s->ctx, notify_guest_bh, s); */
     QEMUBH *bh;                     /* bh for guest notification */
+    /* bitmap, 和num_queues相关 */
     unsigned long *batch_notify_vqs;
+    /*
+     * 在virtio_blk_data_plane_start()被设置:
+     * 235     if (!virtio_vdev_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX)) {
+     * 236         s->batch_notifications = true;
+     * 237     } else {
+     * 238         s->batch_notifications = false;
+     * 239     }
+     */
     bool batch_notifications;
 
     /* Note that these EventNotifiers are assigned by value.  This is
@@ -40,21 +56,68 @@ struct VirtIOBlockDataPlane {
      * (because you don't own the file descriptor or handle; you just
      * use it).
      */
+    /*
+     * 上面的VirtIOBlkConf也包含一个"IOThread *iothread;"指针
+     *
+     * 指向VirtIOBlock->conf->iothread
+     */
     IOThread *iothread;
+    /*
+     * 有iothread, 则指向iothread->ctx
+     * 否则用默认的qemu_aio_context
+     *
+     * AioContext的aio_handlers存着所有该context当前poll的handler和fd
+     */
     AioContext *ctx;
 };
 
 /* Raise an interrupt to signal guest, if necessary */
+/*
+ * called by only:
+ *   - hw/block/virtio-blk.c|74| <<virtio_blk_req_complete>> virtio_blk_data_plane_notify(s->dataplane, req->vq);
+ */
 void virtio_blk_data_plane_notify(VirtIOBlockDataPlane *s, VirtQueue *vq)
 {
+    /*
+     * 在virtio_blk_data_plane_start()被设置:
+     * 235     if (!virtio_vdev_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX)) {
+     * 236         s->batch_notifications = true;
+     * 237     } else {
+     * 238         s->batch_notifications = false;
+     * 239     }
+     *
+     * VIRTIO_RING_F_EVENT_IDX:
+     *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+     *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+     */
     if (s->batch_notifications) {
+        /*
+	 * s->batch_notify_vqs被用到的地方:
+	 *   - hw/block/dataplane/virtio-blk.c|81| <<virtio_blk_data_plane_notify>> set_bit(virtio_get_queue_index(vq), s->batch_notify_vqs);
+	 *   - hw/block/dataplane/virtio-blk.c|103| <<notify_guest_bh>> memcpy(bitmap, s->batch_notify_vqs, sizeof(bitmap));
+	 *   - hw/block/dataplane/virtio-blk.c|104| <<notify_guest_bh>> memset(s->batch_notify_vqs, 0, sizeof(bitmap));
+	 */
         set_bit(virtio_get_queue_index(vq), s->batch_notify_vqs);
+	/*
+	 * s->bh是notify_guest_bh()
+	 * 在virtio_blk_data_plane_create()初始化
+	 *
+	 * bh的notify_guest_bh()最终也会调用virtio_notify_irqfd(), 不过是批处理罢了
+	 */
         qemu_bh_schedule(s->bh);
     } else {
         virtio_notify_irqfd(s->vdev, vq);
     }
+
+    /*
+     * notify_guest_bh()和virtio_notify_irqfd()最终都会通过"event_notifier_set(&vq->guest_notifier)"通知guest
+     */
 }
 
+/*
+ * 被设置为以下的bh:
+ *   - hw/block/dataplane/virtio-blk.c|182| <<virtio_blk_data_plane_create>> s->bh = aio_bh_new(s->ctx, notify_guest_bh, s);
+ */
 static void notify_guest_bh(void *opaque)
 {
     VirtIOBlockDataPlane *s = opaque;
@@ -80,16 +143,73 @@ static void notify_guest_bh(void *opaque)
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * (gdb) bt
+ * #0  virtio_blk_data_plane_create (vdev=0x555557785cf0, conf=0x555557785ea0, dataplane=0x555557785f10, errp=0x7fffffffda58)
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/block/dataplane/virtio-blk.c:88
+ * #1  0x000055555587be0a in virtio_blk_device_realize (dev=0x555557785cf0, errp=0x7fffffffdaa0)
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:968
+ * #2  0x00005555558ca3a0 in virtio_device_realize (dev=0x555557785cf0, errp=0x7fffffffdb00)
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2518
+ * #3  0x0000555555a2d447 in device_set_realized (obj=0x555557785cf0, value=true, errp=0x7fffffffdd38) at hw/core/qdev.c:826
+ * #4  0x0000555555c21bc7 in property_set_bool (obj=0x555557785cf0, v=0x555557790940, name=0x555555e3cce6 "realized", opaque=0x555557787620, 
+ *     errp=0x7fffffffdd38) at qom/object.c:1984
+ * #5  0x0000555555c1fe4c in object_property_set (obj=0x555557785cf0, v=0x555557790940, name=0x555555e3cce6 "realized", errp=0x7fffffffdd38)
+ *     at qom/object.c:1176
+ * #6  0x0000555555c22f04 in object_property_set_qobject (obj=0x555557785cf0, value=0x555557790890, name=0x555555e3cce6 "realized", 
+ *     errp=0x7fffffffdd38) at qom/qom-qobject.c:27
+ * #7  0x0000555555c20131 in object_property_set_bool (obj=0x555557785cf0, value=true, name=0x555555e3cce6 "realized", errp=0x7fffffffdd38)
+ *     at qom/object.c:1242
+ * #8  0x0000555555b92c9f in virtio_blk_pci_realize (vpci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1970
+ * #9  0x0000555555b92682 in virtio_pci_realize (pci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1841
+ * #10 0x0000555555af770d in pci_qdev_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/pci/pci.c:2028
+ * #11 0x0000555555b92a90 in virtio_pci_dc_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/virtio/virtio-pci.c:1915
+ * #12 0x0000555555a2d447 in device_set_realized (obj=0x55555777db80, value=true, errp=0x7fffffffdfc0) at hw/core/qdev.c:826
+ * #13 0x0000555555c21bc7 in property_set_bool (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", opaque=0x555557785fa0, 
+ *     errp=0x7fffffffdfc0) at qom/object.c:1984
+ * #14 0x0000555555c1fe4c in object_property_set (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1176
+ * #15 0x0000555555c22f04 in object_property_set_qobject (obj=0x55555777db80, value=0x55555778a8a0, name=0x555555db778a "realized", 
+ *     errp=0x7fffffffdfc0) at qom/qom-qobject.c:27
+ * #16 0x0000555555c20131 in object_property_set_bool (obj=0x55555777db80, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1242
+ * #17 0x0000555555990749 in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe038) at qdev-monitor.c:627
+ * #18 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+ * #19 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, 
+ *     errp=0x0) at util/qemu-option.c:1106
+ * #20 0x000055555599dd61 in main (argc=15, argv=0x7fffffffe3a8, envp=0x7fffffffe428) at vl.c:4542
+ *
+ * called only by:
+ *   - hw/block/virtio-blk.c|1001| <<virtio_blk_device_realize>> virtio_blk_data_plane_create(vdev, conf, &s->dataplane, &err);
+ *
+ * 在这个函数中分配的VirtIOBlockDataPlane
+ */
 bool virtio_blk_data_plane_create(VirtIODevice *vdev, VirtIOBlkConf *conf,
                                   VirtIOBlockDataPlane **dataplane,
                                   Error **errp)
 {
+    /*
+     * 参数的conf来自VirtIOBlock->conf
+     * dataplane被VirtIOBlock的dataplane所指向
+     */
     VirtIOBlockDataPlane *s;
+    /*
+     * 对于virtio block,parent_bus初始化开始于virtio_pci_realize():
+     * 1. 使用virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);
+     *    其中proxy是VirtIOPCIProxy,其bus是自己的field,不是指针
+     * 2. 然后调用k->realize=virtio_blk_pci_realize()--> qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
+     *    让dev->parent_bus = bus, dev是VirtIOBlock, bus是VirtIOPCIProxy的bus
+     * 所以结论是,virtio block的parent_bus都是专属于自己对应的VirtIOPCIProxy
+     */
     BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
 
     *dataplane = NULL;
 
+    /*
+     * 参数的conf来自VirtIOBlock->conf
+     * dataplane被VirtIOBlock的dataplane所指向
+     */
     if (conf->iothread) {
         if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
             error_setg(errp,
@@ -97,6 +217,9 @@ bool virtio_blk_data_plane_create(VirtIODevice *vdev, VirtIOBlkConf *conf,
                        "(transport does not support notifiers)");
             return false;
         }
+	/*
+	 * vdev是VirtIODevice
+	 */
         if (!virtio_device_ioeventfd_enabled(vdev)) {
             error_setg(errp, "ioeventfd is required for iothread");
             return false;
@@ -111,19 +234,35 @@ bool virtio_blk_data_plane_create(VirtIODevice *vdev, VirtIOBlkConf *conf,
         }
     }
     /* Don't try if transport does not support notifiers. */
+    /*
+     * 看看props吧, 对于virtio block, 在virtio_blk_pci_properties, 开始默认就是true
+     *
+     * 就是检查VirtIOPCIProxy->flags是否设置了VIRTIO_PCI_FLAG_USE_IOEVENTFD
+     * 设置和使用VIRTIO_PCI_FLAG_USE_IOEVENTFD的地方:
+     *   - hw/virtio/virtio-pci.c|218| <<virtio_pci_ioeventfd_enabled>> return (proxy->flags & VIRTIO_PCI_FLAG_USE_IOEVENTFD) != 0;
+     *   - hw/virtio/virtio-pci.c|1834| <<virtio_pci_realize>> proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;
+     */
     if (!virtio_device_ioeventfd_enabled(vdev)) {
         return false;
     }
 
     s = g_new0(VirtIOBlockDataPlane, 1);
     s->vdev = vdev;
+    /*
+     * 参数的conf来自VirtIOBlock->conf
+     * dataplane被VirtIOBlock的dataplane所指向
+     */
     s->conf = conf;
 
     if (conf->iothread) {
         s->iothread = conf->iothread;
         object_ref(OBJECT(s->iothread));
+	/* 返回iothread->ctx */
         s->ctx = iothread_get_aio_context(s->iothread);
     } else {
+        /*
+	 * 返回qemu_aio_context
+	 */
         s->ctx = qemu_get_aio_context();
     }
     s->bh = aio_bh_new(s->ctx, notify_guest_bh, s);
@@ -153,6 +292,22 @@ void virtio_blk_data_plane_destroy(VirtIOBlockDataPlane *s)
     g_free(s);
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_blk_data_plane_handle_output (vdev=0x5555579013a0, vq=0x7fffe64b2010) at /home/zhang/kvm/qemu-3.0.0/hw/block/dataplane/virtio-blk.c:159
+ * #1  0x00005555558ffebd in virtio_queue_notify_aio_vq (vq=0x7fffe64b2010) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1518
+ * #2  0x0000555555902015 in virtio_queue_host_notifier_aio_read (n=0x7fffe64b2078) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2391
+ * #3  0x0000555555db21a3 in aio_dispatch_handlers (ctx=0x555556895200) at util/aio-posix.c:406
+ * #4  0x0000555555db2d34 in aio_poll (ctx=0x555556895200, blocking=true) at util/aio-posix.c:692
+ * #5  0x00005555559d5f1a in iothread_run (opaque=0x555556894d00) at iothread.c:64
+ * #6  0x0000555555db5d87 in qemu_thread_start (args=0x5555568955d0) at util/qemu-thread-posix.c:504
+ * #7  0x00007ffff47596ba in start_thread (arg=0x7fffe7fff700) at pthread_create.c:333
+ * #8  0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * used by virtio_blk_data_plane_start():
+ *   314         virtio_queue_aio_set_host_notifier_handler(vq, s->ctx,
+ *   315                 virtio_blk_data_plane_handle_output);
+ */
 static bool virtio_blk_data_plane_handle_output(VirtIODevice *vdev,
                                                 VirtQueue *vq)
 {
@@ -165,10 +320,34 @@ static bool virtio_blk_data_plane_handle_output(VirtIODevice *vdev,
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * used by only:
+ *   - hw/block/virtio-blk.c|1111| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start;
+ *
+ * 关于start_ioeventfd:
+ * called by:
+ *   - hw/virtio/virtio-bus.c|281| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+ * used by:
+ *   - hw/block/virtio-blk.c|1111| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start; --> block用
+ *   - hw/scsi/virtio-scsi.c|976| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ *   - hw/virtio/virtio.c|2799| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl; --> 网络用
+ *
+ * 对于block, 在guest write寄存器的改配置的时候调用
+ *
+ * 核心思想是设置host和guest的notifiers
+ */
 int virtio_blk_data_plane_start(VirtIODevice *vdev)
 {
     VirtIOBlock *vblk = VIRTIO_BLK(vdev);
     VirtIOBlockDataPlane *s = vblk->dataplane;
+    /*
+     * 对于virtio block,parent_bus初始化开始于virtio_pci_realize():
+     * 1. 使用virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);
+     *    其中proxy是VirtIOPCIProxy,其bus是自己的field,不是指针
+     * 2. 然后调用k->realize=virtio_blk_pci_realize()--> qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
+     *    让dev->parent_bus = bus, dev是VirtIOBlock, bus是VirtIOPCIProxy的bus
+     * 所以结论是,virtio block的parent_bus都是专属于自己对应的VirtIOPCIProxy
+     */
     BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vblk)));
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
     unsigned i;
@@ -188,6 +367,12 @@ int virtio_blk_data_plane_start(VirtIODevice *vdev)
     }
 
     /* Set up guest notifier (irq) */
+    /*
+     * 设置的地方:
+     *   - hw/virtio/virtio-pci.c|2922| <<virtio_pci_bus_class_init>> k->set_guest_notifiers = virtio_pci_set_guest_notifiers;
+     *   - hw/s390x/virtio-ccw.c|1762| <<virtio_ccw_bus_class_init>> k->set_guest_notifiers = virtio_ccw_set_guest_notifiers;
+     *   - hw/virtio/virtio-mmio.c|512| <<virtio_mmio_bus_class_init>> k->set_guest_notifiers = virtio_mmio_set_guest_notifiers;
+     */
     r = k->set_guest_notifiers(qbus->parent, nvqs, true);
     if (r != 0) {
         error_report("virtio-blk failed to set guest notifier (%d), "
@@ -218,6 +403,7 @@ int virtio_blk_data_plane_start(VirtIODevice *vdev)
     for (i = 0; i < nvqs; i++) {
         VirtQueue *vq = virtio_get_queue(s->vdev, i);
 
+	/* 存在VirtQueue->host_notifier */
         event_notifier_set(virtio_queue_get_host_notifier(vq));
     }
 
@@ -256,6 +442,41 @@ static void virtio_blk_data_plane_stop_bh(void *opaque)
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * (gdb) bt
+ * #0  virtio_blk_data_plane_stop (vdev=0x555556abf170) at /home/zhang/kvm/qemu-3.0.0/hw/block/dataplane/virtio-blk.c:261
+ * #1  0x0000555555b8c799 in virtio_bus_stop_ioeventfd (bus=0x555556abf0f8) at hw/virtio/virtio-bus.c:246
+ * #2  0x0000555555b8eab7 in virtio_pci_stop_ioeventfd (proxy=0x555556ab7000) at hw/virtio/virtio-pci.c:293
+ * #3  0x0000555555b90ee6 in virtio_pci_common_write (opaque=0x555556ab7000, addr=20, val=0, size=1) at hw/virtio/virtio-pci.c:1282
+ * #4  0x000055555583317e in memory_region_write_accessor (mr=0x555556ab79d0, addr=20, value=0x7fffecab07e8, size=1, shift=0, mask=255, attrs=...)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #5  0x0000555555833396 in access_with_adjusted_size (addr=20, value=0x7fffecab07e8, size=1, access_size_min=1, access_size_max=4, 
+ *     access_fn=0x555555833094 <memory_region_write_accessor>, mr=0x555556ab79d0, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #6  0x0000555555835fbe in memory_region_dispatch_write (mr=0x555556ab79d0, addr=20, data=0, size=1, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #7  0x00005555557d1ff8 in flatview_write_continue (fv=0x7fffe4152f70, addr=4294967316, attrs=..., buf=0x7ffff7fef028 "", len=1, addr1=20, l=1, mr=0x555556ab79d0)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #8  0x00005555557d2142 in flatview_write (fv=0x7fffe4152f70, addr=4294967316, attrs=..., buf=0x7ffff7fef028 "", len=1) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #9  0x00005555557d2448 in address_space_write (as=0x555556498b40 <address_space_memory>, addr=4294967316, attrs=..., buf=0x7ffff7fef028 "", len=1)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #10 0x00005555557d2499 in address_space_rw (as=0x555556498b40 <address_space_memory>, addr=4294967316, attrs=..., buf=0x7ffff7fef028 "", len=1, is_write=true)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #11 0x00005555558511ce in kvm_cpu_exec (cpu=0x5555565f4360) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1979
+ * #12 0x0000555555818505 in qemu_kvm_cpu_thread_fn (arg=0x5555565f4360) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #13 0x0000555555d54975 in qemu_thread_start (args=0x555556615fa0) at util/qemu-thread-posix.c:504
+ * #14 0x00007ffff55126ba in start_thread (arg=0x7fffecab1700) at pthread_create.c:333
+ * #15 0x00007ffff524841d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * used by:
+ *   - hw/block/virtio-blk.c|1112| <<virtio_blk_class_init>> vdc->stop_ioeventfd = virtio_blk_data_plane_stop;
+ *
+ * 关于stop_ioeventfd:
+ * called by:
+ *   - hw/virtio/virtio-bus.c|304| <<virtio_bus_stop_ioeventfd>> vdc->stop_ioeventfd(vdev);
+ * used by:
+ *   - hw/block/virtio-blk.c|1112| <<virtio_blk_class_init>> vdc->stop_ioeventfd = virtio_blk_data_plane_stop;
+ *   - hw/scsi/virtio-scsi.c|977| <<virtio_scsi_class_init>> vdc->stop_ioeventfd = virtio_scsi_dataplane_stop;
+ *   - hw/virtio/virtio.c|2800| <<virtio_device_class_init>> vdc->stop_ioeventfd = virtio_device_stop_ioeventfd_impl;
+ */
 void virtio_blk_data_plane_stop(VirtIODevice *vdev)
 {
     VirtIOBlock *vblk = VIRTIO_BLK(vdev);
diff --git a/hw/block/nvme.c b/hw/block/nvme.c
index 5e508ab..7b1711e 100644
--- a/hw/block/nvme.c
+++ b/hw/block/nvme.c
@@ -94,6 +94,13 @@ static uint8_t nvme_sq_empty(NvmeSQueue *sq)
     return sq->head == sq->tail;
 }
 
+/*
+ * called by:
+ *   - hw/block/nvme.c|119| <<nvme_irq_assert>> nvme_irq_check(n);
+ *   - hw/block/nvme.c|134| <<nvme_irq_deassert>> nvme_irq_check(n);
+ *   - hw/block/nvme.c|938| <<nvme_write_bar>> nvme_irq_check(n);
+ *   - hw/block/nvme.c|951| <<nvme_write_bar>> nvme_irq_check(n);
+ */
 static void nvme_irq_check(NvmeCtrl *n)
 {
     if (msix_enabled(&(n->parent_obj))) {
@@ -1041,6 +1048,24 @@ static void nvme_write_bar(NvmeCtrl *n, hwaddr offset, uint64_t data,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  nvme_mmio_read (opaque=0x5555579a9f90, addr=0, size=4) at hw/block/nvme.c:1045
+ * #1  0x0000555555864736 in memory_region_read_accessor (mr=0x5555579aa870, addr=0, value=0x7fffec8b0858, size=4, shift=0, mask=4294967295, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:436
+ * #2  0x0000555555864d45 in access_with_adjusted_size (addr=0, value=0x7fffec8b0858, size=4, access_size_min=2, access_size_max=8, access_fn=0x5555558646f8 <memory_region_read_accessor>, mr=0x5555579aa870, 
+ *     attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #3  0x00005555558675d1 in memory_region_dispatch_read1 (mr=0x5555579aa870, addr=0, pval=0x7fffec8b0858, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1392
+ * #4  0x00005555558676dc in memory_region_dispatch_read (mr=0x5555579aa870, addr=0, pval=0x7fffec8b0858, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1423
+ * #5  0x0000555555803bbc in flatview_read_continue (fv=0x7fffe024d810, addr=4273930240, attrs=..., buf=0x7ffff7fef028 "", len=4, addr1=0, l=4, mr=0x5555579aa870) at /home/zhang/kvm/qemu-3.0.0/exec.c:3316
+ * #6  0x0000555555803d14 in flatview_read (fv=0x7fffe024d810, addr=4273930240, attrs=..., buf=0x7ffff7fef028 "", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3354
+ * #7  0x0000555555803d88 in address_space_read_full (as=0x555556721a80 <address_space_memory>, addr=4273930240, attrs=..., buf=0x7ffff7fef028 "", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3367
+ * #8  0x0000555555803e5f in address_space_rw (as=0x555556721a80 <address_space_memory>, addr=4273930240, attrs=..., buf=0x7ffff7fef028 "", len=4, is_write=false) at /home/zhang/kvm/qemu-3.0.0/exec.c:3397
+ * #9  0x0000555555882b7d in kvm_cpu_exec (cpu=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1979
+ * #10 0x0000555555849eac in qemu_kvm_cpu_thread_fn (arg=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #11 0x0000555555d92dd7 in qemu_thread_start (args=0x5555568abcb0) at util/qemu-thread-posix.c:504
+ * #12 0x00007ffff4ca06ba in start_thread (arg=0x7fffec8b1700) at pthread_create.c:333
+ * #13 0x00007ffff49d641d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 static uint64_t nvme_mmio_read(void *opaque, hwaddr addr, unsigned size)
 {
     NvmeCtrl *n = (NvmeCtrl *)opaque;
@@ -1150,6 +1175,29 @@ static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  nvme_mmio_write (opaque=0x555557720c30, addr=40, data=3145584640, size=4) at hw/block/nvme.c:1156
+ * #1  0x000055555583317e in memory_region_write_accessor (mr=0x555557721510, addr=40, value=0x7fffec8be7e8, size=4, shift=0, mask=4294967295, attrs=...)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #2  0x0000555555833396 in access_with_adjusted_size (addr=40, value=0x7fffec8be7e8, size=4, access_size_min=2, access_size_max=8, 
+ *     access_fn=0x555555833094 <memory_region_write_accessor>, mr=0x555557721510, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #3  0x0000555555835fbe in memory_region_dispatch_write (mr=0x555557721510, addr=40, data=3145584640, size=4, attrs=...)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #4  0x00005555557d1ff8 in flatview_write_continue (fv=0x7fffe009f3a0, addr=4273930280, attrs=..., buf=0x7ffff7fef028 "", len=4, addr1=40, l=4, 
+ *     mr=0x555557721510) at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #5  0x00005555557d2142 in flatview_write (fv=0x7fffe009f3a0, addr=4273930280, attrs=..., buf=0x7ffff7fef028 "", len=4)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #6  0x00005555557d2448 in address_space_write (as=0x555556498b40 <address_space_memory>, addr=4273930280, attrs=..., buf=0x7ffff7fef028 "", len=4)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #7  0x00005555557d2499 in address_space_rw (as=0x555556498b40 <address_space_memory>, addr=4273930280, attrs=..., buf=0x7ffff7fef028 "", len=4, 
+ *     is_write=true) at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #8  0x00005555558511ce in kvm_cpu_exec (cpu=0x555556600e30) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1979
+ * #9  0x0000555555818505 in qemu_kvm_cpu_thread_fn (arg=0x555556600e30) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #10 0x0000555555d54975 in qemu_thread_start (args=0x5555566230b0) at util/qemu-thread-posix.c:504
+ * #11 0x00007ffff55126ba in start_thread (arg=0x7fffec8bf700) at pthread_create.c:333
+ * #12 0x00007ffff524841d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 static void nvme_mmio_write(void *opaque, hwaddr addr, uint64_t data,
     unsigned size)
 {
@@ -1197,6 +1245,24 @@ static const MemoryRegionOps nvme_cmb_ops = {
     },
 };
 
+/*
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ *
+ *
+ * called by:
+ *   - hw/pci/pci.c|2087| <<pci_qdev_realize>> pc->realize(pci_dev, &local_err);
+ */
 static void nvme_realize(PCIDevice *pci_dev, Error **errp)
 {
     NvmeCtrl *n = NVME(pci_dev);
@@ -1242,6 +1308,9 @@ static void nvme_realize(PCIDevice *pci_dev, Error **errp)
     n->sq = g_new0(NvmeSQueue *, n->num_queues);
     n->cq = g_new0(NvmeCQueue *, n->num_queues);
 
+    /*
+     * 里面n->iomem->ram是false!!!
+     */
     memory_region_init_io(&n->iomem, OBJECT(n), &nvme_mmio_ops, n,
                           "nvme", n->reg_size);
     pci_register_bar(&n->parent_obj, 0,
@@ -1339,6 +1408,9 @@ static void nvme_exit(PCIDevice *pci_dev)
     msix_uninit_exclusive_bar(pci_dev);
 }
 
+/*
+ * 猜测props是用device_initfn()
+ */
 static Property nvme_props[] = {
     DEFINE_BLOCK_PROPERTIES(NvmeCtrl, conf),
     DEFINE_PROP_STRING("serial", NvmeCtrl, serial),
@@ -1352,11 +1424,32 @@ static const VMStateDescription nvme_vmstate = {
     .unmigratable = 1,
 };
 
+/*
+ * TypeInfo nvme_info.class_init = nvme_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ *
+ * (gdb) bt
+ * #0  nvme_class_init (oc=0x5555567d1690, data=0x0) at hw/block/nvme.c:1357
+ * #1  0x0000555555c5c5cf in type_initialize (ti=0x555556794080) at qom/object.c:342
+ * #2  0x0000555555c5d93f in object_class_foreach_tramp (key=0x555556771ba0, value=0x555556794080, opaque=0x7fffffffe040) at qom/object.c:867
+ * #3  0x00007ffff5616340 in g_hash_table_foreach () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #4  0x0000555555c5da1e in object_class_foreach (fn=0x555555c5db6f <object_class_get_list_tramp>, implements_type=0x555555ebd4f6 "machine", include_abstract=false, opaque=0x7fffffffe090) at qom/object.c:889
+ * #5  0x0000555555c5dbed in object_class_get_list (implements_type=0x555555ebd4f6 "machine", include_abstract=false) at qom/object.c:943
+ * #6  0x00005555559d7a68 in find_default_machine () at vl.c:1417
+ * #7  0x00005555559db957 in select_machine () at vl.c:2669
+ * #8  0x00005555559de882 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:3988
+ */
 static void nvme_class_init(ObjectClass *oc, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(oc);
     PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);
 
+    /*
+     * called by:
+     *   - hw/pci/pci.c|2087| <<pci_qdev_realize>> pc->realize(pci_dev, &local_err);
+     */
     pc->realize = nvme_realize;
     pc->exit = nvme_exit;
     pc->class_id = PCI_CLASS_STORAGE_EXPRESS;
@@ -1370,6 +1463,23 @@ static void nvme_class_init(ObjectClass *oc, void *data)
     dc->vmsd = &nvme_vmstate;
 }
 
+/*
+ * TypeInfo nvme_info.instance_init = nvme_instance_init()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ *
+ * (gdb) bt
+ * #0  nvme_instance_init (obj=0x5555579a9f20) at hw/block/nvme.c:1375
+ * #1  0x0000555555c5c635 in object_init_with_type (obj=0x5555579a9f20, ti=0x555556794080) at qom/object.c:353
+ * #2  0x0000555555c5c7f8 in object_initialize_with_type (data=0x5555579a9f20, size=7248, type=0x555556794080) at qom/object.c:384
+ * #3  0x0000555555c5ce4c in object_new_with_type (type=0x555556794080) at qom/object.c:546
+ * #4  0x0000555555c5ce89 in object_new (typename=0x5555567bde50 "nvme") at qom/object.c:556
+ * #5  0x00005555559d251c in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:608
+ * #6  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #7  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #8  0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 static void nvme_instance_init(Object *obj)
 {
     NvmeCtrl *s = NVME(obj);
@@ -1393,7 +1503,12 @@ static const TypeInfo nvme_info = {
 
 static void nvme_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&nvme_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(nvme_register_types)
diff --git a/hw/block/virtio-blk.c b/hw/block/virtio-blk.c
index 50b5c86..940b439 100644
--- a/hw/block/virtio-blk.c
+++ b/hw/block/virtio-blk.c
@@ -28,6 +28,63 @@
 #include "hw/virtio/virtio-bus.h"
 #include "hw/virtio/virtio-access.h"
 
+/*
+ * 和qemu block层的接口是blk_aio_pwritev()和blk_aio_preadv()
+ *
+ * 从qemu block完成的回调函数是virtio_blk_rw_complete()是virtio_blk_flush_complete()
+ *
+ * 事件(中断)处理函数的入口是virtio_blk_data_plane_handle_output()
+ *
+ * 如果没有开启ioeventfd, 就会用默认的pci write拦截的方法, 由cpu线程退出处理virtio_blk_handle_output()
+ *
+ * 
+ * drive初始化的函数是drive_new(), 和drive建立链接是通过property的set方法; virtblk和文件的联系就是BlockBackend
+ *
+ *
+ * 添加新设备的地方, 被main()函数调用:
+ *   4630     if (qemu_opts_foreach(qemu_find_opts("device"),
+ *   4631                           device_init_func, NULL, NULL)) {
+ *   4632         exit(1);
+ *   4633     }
+ *
+ * 用find_device_state()可以找到想找的设备
+ */
+
+/*
+ * 开启了iothread的例子 (从kvm唤醒到qemu的iothread):
+ * (gdb) bt
+ * #0  virtio_blk_data_plane_handle_output (vdev=0x5555579da940, vq=0x7fffe6642090) at /home/zhang/kvm/qemu-3.0.0/hw/block/dataplane/virtio-blk.c:159
+ * #1  0x00005555558ffebd in virtio_queue_notify_aio_vq (vq=0x7fffe6642090) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1518
+ * #2  0x0000555555902015 in virtio_queue_host_notifier_aio_read (n=0x7fffe66420f8) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2391
+ * #3  0x0000555555db21a3 in aio_dispatch_handlers (ctx=0x5555568952a0) at util/aio-posix.c:406
+ * #4  0x0000555555db2d34 in aio_poll (ctx=0x5555568952a0, blocking=true) at util/aio-posix.c:692
+ * #5  0x00005555559d5f1a in iothread_run (opaque=0x555556894da0) at iothread.c:64
+ * #6  0x0000555555db5d87 in qemu_thread_start (args=0x555556895670) at util/qemu-thread-posix.c:504
+ * #7  0x00007ffff47596ba in start_thread (arg=0x7fffe7fff700) at pthread_create.c:333
+ * #8  0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ *
+ * 没有iothread的例子 (从kvm唤醒到qemu的mainloop):
+ * (gdb) bt
+ * #0  virtio_blk_data_plane_handle_output (vdev=0x5555579d9c30, vq=0x7fffe6e43010) at /home/zhang/kvm/qemu-3.0.0/hw/block/dataplane/virtio-blk.c:159
+ * #1  0x00005555558ffebd in virtio_queue_notify_aio_vq (vq=0x7fffe6e43010) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1518
+ * #2  0x0000555555902015 in virtio_queue_host_notifier_aio_read (n=0x7fffe6e43078) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2391
+ * #3  0x0000555555db21a3 in aio_dispatch_handlers (ctx=0x5555568865a0) at util/aio-posix.c:406
+ * #4  0x0000555555db2336 in aio_dispatch (ctx=0x5555568865a0) at util/aio-posix.c:437
+ * #5  0x0000555555dadb1a in aio_ctx_dispatch (source=0x5555568865a0, callback=0x0, user_data=0x0) at util/async.c:261
+ * #6  0x00007ffff50e0197 in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #7  0x0000555555db0d34 in glib_pollfds_poll () at util/main-loop.c:215
+ * #8  0x0000555555db0da2 in os_host_main_loop_wait (timeout=1000000000) at util/main-loop.c:238
+ * #9  0x0000555555db0e5b in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #10 0x00005555559dee92 in main_loop () at vl.c:1866
+ * #11 0x00005555559e66a5 in main (argc=12, argv=0x7fffffffe418, envp=0x7fffffffe480) at vl.c:4644
+ */
+
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|206| <<virtio_blk_get_request>> virtio_blk_init_request(s, vq, req);
+ *   - hw/block/virtio-blk.c|891| <<virtio_blk_load_device>> virtio_blk_init_request(s, virtio_get_queue(vdev, vq_idx), req);
+ */
 static void virtio_blk_init_request(VirtIOBlock *s, VirtQueue *vq,
                                     VirtIOBlockReq *req)
 {
@@ -36,6 +93,13 @@ static void virtio_blk_init_request(VirtIOBlock *s, VirtQueue *vq,
     req->qiov.size = 0;
     req->in_len = 0;
     req->next = NULL;
+    /*
+     * 用到或者修改了mr_next的地方:
+     *   - hw/block/virtio-blk.c|198| <<virtio_blk_rw_complete>> next = req->mr_next;
+     *   - hw/block/virtio-blk.c|543| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+     *   - hw/block/virtio-blk.c|82| <<virtio_blk_init_request>> req->mr_next = NULL;
+     *   - hw/block/virtio-blk.c|147| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+     */
     req->mr_next = NULL;
 }
 
@@ -44,6 +108,23 @@ static void virtio_blk_free_request(VirtIOBlockReq *req)
     g_free(req);
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|77| <<virtio_blk_handle_rw_error>> virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
+ *   - hw/block/virtio-blk.c|121| <<virtio_blk_rw_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|140| <<virtio_blk_flush_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|193| <<virtio_blk_ioctl_complete>> virtio_blk_req_complete(req, status);
+ *   - hw/block/virtio-blk.c|326| <<virtio_blk_handle_scsi>> virtio_blk_req_complete(req, status);
+ *   - hw/block/virtio-blk.c|540| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
+ *   - hw/block/virtio-blk.c|583| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|588| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
+ *
+ * 根据VirtIOBlockReq回复前端response (设置status)
+ * 核心思想是把VirtQueueElement给unmap (设置完status后)
+ * 根据VirtQueueElement制作VRingUsedElem, 然后写入VRingUsed->ring[0+vq->used_idx]
+ * 把VRingUsed->idx和vq->used_idx增加1
+ * 然后通知前端 (virtio_blk_data_plane_notify()或者virtio_notify())
+ */
 static void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
 {
     VirtIOBlock *s = req->dev;
@@ -51,7 +132,16 @@ static void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
 
     trace_virtio_blk_req_complete(vdev, req, status);
 
+    /*
+     * in是struct virtio_blk_inhdr类型
+     * stb_p()就是: *(uint8_t *)ptr = v
+     */
     stb_p(&req->in->status, status);
+    /*
+     * 核心思想是把VirtQueueElement给unmap
+     * 根据VirtQueueElement制作VRingUsedElem, 然后写入VRingUsed->ring[0+vq->used_idx]
+     * 把VRingUsed->idx和vq->used_idx增加1
+     */
     virtqueue_push(req->vq, &req->elem, req->in_len);
     if (s->dataplane_started && !s->dataplane_disabled) {
         virtio_blk_data_plane_notify(s->dataplane, req->vq);
@@ -60,6 +150,11 @@ static void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|133| <<virtio_blk_rw_complete>> if (virtio_blk_handle_rw_error(req, -ret, is_read)) {
+ *   - hw/block/virtio-blk.c|152| <<virtio_blk_flush_complete>> if (virtio_blk_handle_rw_error(req, -ret, 0)) {
+ */
 static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
     bool is_read)
 {
@@ -70,10 +165,24 @@ static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
     if (action == BLOCK_ERROR_ACTION_STOP) {
         /* Break the link as the next request is going to be parsed from the
          * ring again. Otherwise we may end up doing a double completion! */
+        /*
+	 * 用到或者修改了mr_next的地方:
+	 *   - hw/block/virtio-blk.c|198| <<virtio_blk_rw_complete>> next = req->mr_next;
+	 *   - hw/block/virtio-blk.c|543| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+	 *   - hw/block/virtio-blk.c|82| <<virtio_blk_init_request>> req->mr_next = NULL;
+	 *   - hw/block/virtio-blk.c|147| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+	 */
         req->mr_next = NULL;
         req->next = s->rq;
         s->rq = req;
     } else if (action == BLOCK_ERROR_ACTION_REPORT) {
+        /*
+	 * 根据VirtIOBlockReq回复前端response (设置VIRTIO_BLK_S_IOERR)
+	 * 核心思想是把VirtQueueElement给unmap (设置完VIRTIO_BLK_S_IOERR后)
+	 * 根据VirtQueueElement制作VRingUsedElem, 然后写入VRingUsed->ring[0+vq->used_idx]
+	 * 把VRingUsed->idx和vq->used_idx增加1
+	 * 然后通知前端 (virtio_blk_data_plane_notify()或者virtio_notify())
+	 */
         virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
         block_acct_failed(blk_get_stats(s->blk), &req->acct);
         virtio_blk_free_request(req);
@@ -83,6 +192,30 @@ static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
     return action != BLOCK_ERROR_ACTION_IGNORE;
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_blk_rw_complete (opaque=0x7fffe00082f0, ret=0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:88
+ * #1  0x0000555555ce9d35 in blk_aio_complete (acb=0x7fffe000aca0) at block/block-backend.c:1336
+ * #2  0x0000555555ce9f49 in blk_aio_read_entry (opaque=0x7fffe000aca0) at block/block-backend.c:1389
+ * #3  0x0000555555dd04e6 in coroutine_trampoline (i0=-536864304, i1=32767) at util/coroutine-ucontext.c:116
+ * #4  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #5  0x00007fffe7ffdda0 in ?? ()
+ * #6  0x0000000000000000 in ?? ()
+ *
+ * 被submit_requests()在两处使用
+ *   537     if (is_write) {
+ *   538         blk_aio_pwritev(blk, sector_num << BDRV_SECTOR_BITS, qiov, 0,
+ *   539                         virtio_blk_rw_complete, mrb->reqs[start]);
+ *   540     } else {
+ *   541         blk_aio_preadv(blk, sector_num << BDRV_SECTOR_BITS, qiov, 0,
+ *   542                        virtio_blk_rw_complete, mrb->reqs[start]);
+ *   543     }
+ *
+ * 因为根据gdb的bt, virtio_blk_rw_complete()和submit_requests()都是在一个thread调用的
+ * 所以判断virtio_blk_rw_complete()是在iothread (或者mainloop)的coroutine调用的
+ *
+ * 如果ioeventfd没开, 则在mainloop的coroutine调用
+ */
 static void virtio_blk_rw_complete(void *opaque, int ret)
 {
     VirtIOBlockReq *next = opaque;
@@ -92,6 +225,13 @@ static void virtio_blk_rw_complete(void *opaque, int ret)
     aio_context_acquire(blk_get_aio_context(s->conf.conf.blk));
     while (next) {
         VirtIOBlockReq *req = next;
+	/*
+	 * 用到或者修改了mr_next的地方:
+	 *   - hw/block/virtio-blk.c|198| <<virtio_blk_rw_complete>> next = req->mr_next;
+	 *   - hw/block/virtio-blk.c|543| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+	 *   - hw/block/virtio-blk.c|82| <<virtio_blk_init_request>> req->mr_next = NULL;
+	 *   - hw/block/virtio-blk.c|147| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+	 */
         next = req->mr_next;
         trace_virtio_blk_rw_complete(vdev, req, ret);
 
@@ -118,6 +258,13 @@ static void virtio_blk_rw_complete(void *opaque, int ret)
             }
         }
 
+	/*
+	 * 根据VirtIOBlockReq回复前端response (设置status)
+	 * 核心思想是把VirtQueueElement给unmap (设置完status后)
+	 * 根据VirtQueueElement制作VRingUsedElem, 然后写入VRingUsed->ring[0+vq->used_idx]
+	 * 把VRingUsed->idx和vq->used_idx增加1
+	 * 然后通知前端 (virtio_blk_data_plane_notify()或者virtio_notify())
+	 */
         virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
         block_acct_done(blk_get_stats(req->dev->blk), &req->acct);
         virtio_blk_free_request(req);
@@ -125,6 +272,20 @@ static void virtio_blk_rw_complete(void *opaque, int ret)
     aio_context_release(blk_get_aio_context(s->conf.conf.blk));
 }
 
+/*
+ * used by:
+ *   - hw/block/virtio-blk.c|484| <<virtio_blk_handle_flush>> blk_aio_flush(req->dev->blk, virtio_blk_flush_complete, req);
+ *
+ * #0  virtio_blk_flush_complete (opaque=0x7fffe000a340, ret=0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:130
+ * #1  0x0000555555ce9d35 in blk_aio_complete (acb=0x7fffe0008290) at block/block-backend.c:1336
+ * #2  0x0000555555cea2be in blk_aio_flush_entry (opaque=0x7fffe0008290) at block/block-backend.c:1481
+ * #3  0x0000555555dd04e6 in coroutine_trampoline (i0=-536847984, i1=32767) at util/coroutine-ucontext.c:116
+ * #4  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #5  0x00007fffe7ffdda0 in ?? ()
+ * #6  0x0000000000000000 in ?? ()
+ *
+ * flush完成的回调函数, 也是在iothread (mainloop)的coroutine调用的
+ */
 static void virtio_blk_flush_complete(void *opaque, int ret)
 {
     VirtIOBlockReq *req = opaque;
@@ -137,6 +298,13 @@ static void virtio_blk_flush_complete(void *opaque, int ret)
         }
     }
 
+    /*
+     * 根据VirtIOBlockReq回复前端response (设置status)
+     * 核心思想是把VirtQueueElement给unmap (设置完status后)
+     * 根据VirtQueueElement制作VRingUsedElem, 然后写入VRingUsed->ring[0+vq->used_idx]
+     * 把VRingUsed->idx和vq->used_idx增加1
+     * 然后通知前端 (virtio_blk_data_plane_notify()或者virtio_notify())
+     */
     virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
     block_acct_done(blk_get_stats(req->dev->blk), &req->acct);
     virtio_blk_free_request(req);
@@ -152,6 +320,11 @@ typedef struct {
     struct sg_io_hdr hdr;
 } VirtIOBlockIoctlReq;
 
+/*
+ * used only by virtio_blk_handle_scsi_req():
+ *   430     acb = blk_aio_ioctl(blk->blk, SG_IO, &ioctl_req->hdr,
+ *   431                         virtio_blk_ioctl_complete, ioctl_req);
+ */
 static void virtio_blk_ioctl_complete(void *opaque, int status)
 {
     VirtIOBlockIoctlReq *ioctl_req = opaque;
@@ -198,16 +371,43 @@ out:
 
 #endif
 
+/*
+ * called only by:
+ *   - hw/block/virtio-blk.c|804| <<virtio_blk_handle_vq>> while ((req = virtio_blk_get_request(s, vq))) {
+ *
+ * 从ring buffer把下一个avail的所有desc读出来
+ * 分配一个结构,这个结构就是或者包含VirtQueueElement (这里是sizeof(VirtIOBlockReq))
+ * 在这个结构后面附着in_addr, out_addr等指向的真是数据
+ * 然后做一些简单初始化,要注意的是req->mr_next=NULL
+ */
 static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s, VirtQueue *vq)
 {
+    /*
+     * 参数sc(这里是sizeof(VirtIOBlockReq))的结构必须包含VirtQueueElement,
+     * 所以virtqueue_pop()-->virtqueue_alloc_element()会
+     * 检查sc(这里sizeof(VirtIOBlockReq))是否大于等于sizeof(VirtQueueElement)
+     *  
+     * 从ring buffer把下一个avail的所有desc读出来
+     * 分配一个结构,这个结构就是或者包含VirtQueueElement
+     * 在这个结构后面附着in_addr, out_addr等指向的真是数据
+     * 结构的例子是VirtIOBlockReq或者virtio_gpu_ctrl_command
+     */
     VirtIOBlockReq *req = virtqueue_pop(vq, sizeof(VirtIOBlockReq));
 
     if (req) {
+        /*
+	 * 做一些简单初始化
+	 * 要注意的是req->mr_next=NULL
+	 */
         virtio_blk_init_request(s, vq, req);
     }
     return req;
 }
 
+/*
+ * called only by virtio_blk_handle_request()-->virtio_blk_handle_scsi():
+ *   - hw/block/virtio-blk.c|356| <<virtio_blk_handle_scsi>> status = virtio_blk_handle_scsi_req(req);
+ */
 static int virtio_blk_handle_scsi_req(VirtIOBlockReq *req)
 {
     int status = VIRTIO_BLK_S_OK;
@@ -317,6 +517,10 @@ fail:
     return status;
 }
 
+/*
+ * called only by:
+ *   - hw/block/virtio-blk.c|617| <<virtio_blk_handle_request>> virtio_blk_handle_scsi(req);
+ */
 static void virtio_blk_handle_scsi(VirtIOBlockReq *req)
 {
     int status;
@@ -328,6 +532,27 @@ static void virtio_blk_handle_scsi(VirtIOBlockReq *req)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|433| <<virtio_blk_submit_multireq>> submit_requests(blk, mrb, 0, 1, -1);
+ *   - hw/block/virtio-blk.c|457| <<virtio_blk_submit_multireq>> submit_requests(blk, mrb, start, num_reqs, niov);
+ *   - hw/block/virtio-blk.c|473| <<virtio_blk_submit_multireq>> submit_requests(blk, mrb, start, num_reqs, niov);
+ *
+ * (gdb) bt
+ * #0  submit_requests (blk=0x5555568a31f0, mrb=0x7fffe7ffe6a0, start=0, num_reqs=1, niov=2) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:334
+ * #1  0x00005555558b264b in virtio_blk_submit_multireq (blk=0x5555568a31f0, mrb=0x7fffe7ffe6a0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:425
+ * #2  0x00005555558b3008 in virtio_blk_handle_vq (s=0x5555579da940, vq=0x7fffe6642090) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:619
+ * #3  0x00005555558b5a8e in virtio_blk_data_plane_handle_output (vdev=0x5555579da940, vq=0x7fffe6642090) at /home/zhang/kvm/qemu-3.0.0/hw/block/dataplane/virtio-blk.c:164
+ * #4  0x00005555558ffebd in virtio_queue_notify_aio_vq (vq=0x7fffe6642090) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1518
+ * #5  0x00005555559020a4 in virtio_queue_host_notifier_aio_poll (opaque=0x7fffe66420f8) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2412
+ * #6  0x0000555555db25bd in run_poll_handlers_once (ctx=0x5555568952a0) at util/aio-posix.c:497
+ * #7  0x0000555555db27d5 in try_poll_mode (ctx=0x5555568952a0, blocking=true) at util/aio-posix.c:573
+ * #8  0x0000555555db2880 in aio_poll (ctx=0x5555568952a0, blocking=true) at util/aio-posix.c:602
+ * #9  0x00005555559d5f1a in iothread_run (opaque=0x555556894da0) at iothread.c:64
+ * #10 0x0000555555db5d87 in qemu_thread_start (args=0x555556895670) at util/qemu-thread-posix.c:504
+ * #11 0x00007ffff47596ba in start_thread (arg=0x7fffe7fff700) at pthread_create.c:333
+ * #12 0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 static inline void submit_requests(BlockBackend *blk, MultiReqBuffer *mrb,
                                    int start, int num_reqs, int niov)
 {
@@ -337,6 +562,7 @@ static inline void submit_requests(BlockBackend *blk, MultiReqBuffer *mrb,
 
     if (num_reqs > 1) {
         int i;
+	/* 一开始进来的时候qiov是&mrb->reqs[start]->qiov */
         struct iovec *tmp_iov = qiov->iov;
         int tmp_niov = qiov->niov;
 
@@ -350,8 +576,20 @@ static inline void submit_requests(BlockBackend *blk, MultiReqBuffer *mrb,
         }
 
         for (i = start + 1; i < start + num_reqs; i++) {
+            /*
+	     * 看看能不能把剩下的qiov拼接起来
+	     */
             qemu_iovec_concat(qiov, &mrb->reqs[i]->qiov, 0,
                               mrb->reqs[i]->qiov.size);
+            /*
+	     * 用到或者修改了mr_next的地方:
+	     *   - hw/block/virtio-blk.c|198| <<virtio_blk_rw_complete>> next = req->mr_next;
+	     *   - hw/block/virtio-blk.c|543| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+	     *   - hw/block/virtio-blk.c|82| <<virtio_blk_init_request>> req->mr_next = NULL;
+	     *   - hw/block/virtio-blk.c|147| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+	     *
+	     * 拼接完了就要把reqs[]链起来!!!
+	     */
             mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
         }
 
@@ -365,14 +603,26 @@ static inline void submit_requests(BlockBackend *blk, MultiReqBuffer *mrb,
     }
 
     if (is_write) {
+        /*
+	 * 0是BdrvRequestFlags
+	 */
         blk_aio_pwritev(blk, sector_num << BDRV_SECTOR_BITS, qiov, 0,
                         virtio_blk_rw_complete, mrb->reqs[start]);
     } else {
+        /*
+	 * 0是BdrvRequestFlags
+	 */
         blk_aio_preadv(blk, sector_num << BDRV_SECTOR_BITS, qiov, 0,
                        virtio_blk_rw_complete, mrb->reqs[start]);
     }
 }
 
+/*
+ * called only by:
+ *   - hw/block/virtio-blk.c|602| <<virtio_blk_submit_multireq>> &multireq_compare);
+ *
+ * 比较两个VirtIOBlockReq的sector_num
+ */
 static int multireq_compare(const void *a, const void *b)
 {
     const VirtIOBlockReq *req1 = *(VirtIOBlockReq **)a,
@@ -391,6 +641,15 @@ static int multireq_compare(const void *a, const void *b)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|490| <<virtio_blk_handle_flush>> virtio_blk_submit_multireq(req->dev->blk, mrb);
+ *   - hw/block/virtio-blk.c|592| <<virtio_blk_handle_request>> virtio_blk_submit_multireq(req->dev->blk, mrb);
+ *   - hw/block/virtio-blk.c|655| <<virtio_blk_handle_vq>> virtio_blk_submit_multireq(s->blk, &mrb);
+ *   - hw/block/virtio-blk.c|714| <<virtio_blk_dma_restart_bh>> virtio_blk_submit_multireq(s->blk, &mrb);
+ *
+ * 参数mrb(MultiReqBuffer)就是包含一个有上限的指针数组VirtIOBlockReq*
+ */
 static void virtio_blk_submit_multireq(BlockBackend *blk, MultiReqBuffer *mrb)
 {
     int i = 0, start = 0, num_reqs = 0, niov = 0, nb_sectors = 0;
@@ -405,9 +664,15 @@ static void virtio_blk_submit_multireq(BlockBackend *blk, MultiReqBuffer *mrb)
 
     max_transfer = blk_get_max_transfer(mrb->reqs[0]->dev->blk);
 
+    /*
+     * 这里也要来一个电梯排序???
+     */
     qsort(mrb->reqs, mrb->num_reqs, sizeof(*mrb->reqs),
           &multireq_compare);
 
+    /*
+     * 参数mrb(MultiReqBuffer)就是包含一个有上限的指针数组VirtIOBlockReq*
+     */
     for (i = 0; i < mrb->num_reqs; i++) {
         VirtIOBlockReq *req = mrb->reqs[i];
         if (num_reqs > 0) {
@@ -442,6 +707,63 @@ static void virtio_blk_submit_multireq(BlockBackend *blk, MultiReqBuffer *mrb)
     mrb->num_reqs = 0;
 }
 
+/*
+ * coroutine和主线都在同一个iothread中
+ *
+ * 下发的主线:
+ * (gdb) bt
+ * #0  blk_aio_flush (blk=0x5555568a2d80, cb=0x5555558b1ba8 <virtio_blk_flush_complete>, opaque=0x7fffe0000960) at block/block-backend.c:1487
+ * #1  0x00005555558b2785 in virtio_blk_handle_flush (req=0x7fffe0000960, mrb=0x7fffe7ffe6d0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:456
+ * #2  0x00005555558b2d4c in virtio_blk_handle_request (req=0x7fffe0000960, mrb=0x7fffe7ffe6d0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:565
+ * #3  0x00005555558b2f51 in virtio_blk_handle_vq (s=0x5555579da580, vq=0x5555579e5b80) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:608
+ * #4  0x00005555558b5a8e in virtio_blk_data_plane_handle_output (vdev=0x5555579da580, vq=0x5555579e5b80) at /home/zhang/kvm/qemu-3.0.0/hw/block/dataplane/virtio-blk.c:164
+ * #5  0x00005555558ffebd in virtio_queue_notify_aio_vq (vq=0x5555579e5b80) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1518
+ * #6  0x0000555555902015 in virtio_queue_host_notifier_aio_read (n=0x5555579e5be8) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2391
+ * #7  0x0000555555db21a3 in aio_dispatch_handlers (ctx=0x5555568950c0) at util/aio-posix.c:406
+ * #8  0x0000555555db2d34 in aio_poll (ctx=0x5555568950c0, blocking=true) at util/aio-posix.c:692
+ * #9  0x00005555559d5f1a in iothread_run (opaque=0x555556894bc0) at iothread.c:64
+ * #10 0x0000555555db5d87 in qemu_thread_start (args=0x555556895490) at util/qemu-thread-posix.c:504
+ * #11 0x00007ffff47596ba in start_thread (arg=0x7fffe7fff700) at pthread_create.c:333
+ * #12 0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * coroutine中:
+ * virtio block flush的例子 (和下发的主线在一个iothread中):
+ * #0  paio_submit_co_full (bs=0x5555568a9660, fd=16, offset=0, fd2=-1, offset2=0, qiov=0x0, bytes=0, type=8) at block/file-posix.c:1788
+ * #1  0x0000555555cf2fea in paio_submit_co (bs=0x5555568a9660, fd=16, offset=0, qiov=0x0, bytes=0, type=8) at block/file-posix.c:1815
+ * #2  0x0000555555cf32b9 in raw_co_flush_to_disk (bs=0x5555568a9660) at block/file-posix.c:1894
+ * #3  0x0000555555d032e8 in bdrv_co_flush (bs=0x5555568a9660) at block/io.c:2617
+ * #4  0x0000555555d03397 in bdrv_co_flush (bs=0x5555568a3040) at block/io.c:2654
+ * #5  0x0000555555cea60d in blk_co_flush (blk=0x5555568a2d80) at block/block-backend.c:1572
+ * #6  0x0000555555cea2a9 in blk_aio_flush_entry (opaque=0x7fffe0000a40) at block/block-backend.c:1480
+ * #7  0x0000555555dd04e6 in coroutine_trampoline (i0=-536860144, i1=32767) at util/coroutine-ucontext.c:116
+ * #8  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #9  0x00007fffe7ffdda0 in ?? ()
+ * #10 0x0000000000000000 in ?? ()
+ *
+ * coroutine中的paio_submit_co_full()会把flush的请求用thread_pool_submit_co()下发到worker thread
+ * 在worker thread中执行:
+ * (gdb) bt
+ * #0  qemu_fdatasync (fd=16) at util/cutils.c:159
+ * #1  0x0000555555cf1b1d in handle_aiocb_flush (aiocb=0x7fffe0000c00) at block/file-posix.c:1134
+ * #2  0x0000555555cf2dca in aio_worker (arg=0x7fffe0000c00) at block/file-posix.c:1753
+ * #3  0x0000555555daeb10 in worker_thread (opaque=0x7fffe0000c50) at util/thread-pool.c:105
+ * #4  0x0000555555db5d87 in qemu_thread_start (args=0x7fffe0000aa0) at util/qemu-thread-posix.c:504
+ * #5  0x00007ffff47596ba in start_thread (arg=0x7fff437fe700) at pthread_create.c:333
+ * #6  0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * 最后在coroutine中又执行了complete:
+ * (gdb) bt
+ * #0  virtio_blk_flush_complete (opaque=0x7fffe0000960, ret=0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:130
+ * #1  0x0000555555ce9d35 in blk_aio_complete (acb=0x7fffe0000a40) at block/block-backend.c:1336
+ * #2  0x0000555555cea2be in blk_aio_flush_entry (opaque=0x7fffe0000a40) at block/block-backend.c:1481
+ * #3  0x0000555555dd04e6 in coroutine_trampoline (i0=-536860144, i1=32767) at util/coroutine-ucontext.c:116
+ * #4  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #5  0x00007fffe7ffdda0 in ?? ()
+ * #6  0x0000000000000000 in ?? ()
+ *
+ * called only by:
+ *   - hw/block/virtio-blk.c|593| <<virtio_blk_handle_request>> virtio_blk_handle_flush(req, mrb);
+ */
 static void virtio_blk_handle_flush(VirtIOBlockReq *req, MultiReqBuffer *mrb)
 {
     block_acct_start(blk_get_stats(req->dev->blk), &req->acct, 0,
@@ -450,6 +772,10 @@ static void virtio_blk_handle_flush(VirtIOBlockReq *req, MultiReqBuffer *mrb)
     /*
      * Make sure all outstanding writes are posted to the backing device.
      */
+    /*
+     * virtio_blk_handle_vq()-->virtio_blk_handle_request()处理
+     * VIRTIO_BLK_T_IN和VIRTIO_BLK_T_OUT时可能在mrb已经积攒了一些
+     */
     if (mrb->is_write && mrb->num_reqs > 0) {
         virtio_blk_submit_multireq(req->dev->blk, mrb);
     }
@@ -462,6 +788,7 @@ static bool virtio_blk_sect_range_ok(VirtIOBlock *dev,
     uint64_t nb_sectors = size >> BDRV_SECTOR_BITS;
     uint64_t total_sectors;
 
+    /* 一次request的sector数量不可以太大 */
     if (nb_sectors > BDRV_REQUEST_MAX_SECTORS) {
         return false;
     }
@@ -478,9 +805,19 @@ static bool virtio_blk_sect_range_ok(VirtIOBlock *dev,
     return true;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|670| <<virtio_blk_handle_vq>> if (virtio_blk_handle_request(req, &mrb)) {
+ *   - hw/block/virtio-blk.c|724| <<virtio_blk_dma_restart_bh>> if (virtio_blk_handle_request(req, &mrb)) {
+ *
+ * 对于virtio_blk_handle_vq():
+ *   mrb是一个virtio_blk_handle_vq()的本地变量, 把处理的req信息转化然后存入mrb
+ *   此时VirtIOBlockReq只有elem有数据,VirtIOBlockReq的其他部门还没初始化
+ */
 static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
 {
     uint32_t type;
+    /* elem是VirtQueueElement */
     struct iovec *in_iov = req->elem.in_sg;
     struct iovec *iov = req->elem.out_sg;
     unsigned in_num = req->elem.in_num;
@@ -488,31 +825,66 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
     VirtIOBlock *s = req->dev;
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
 
+    /*
+     * 对于从virtio_blk_handle_vq()调用进来的:
+     *     VirtIOBlockReq, 除了elem(VirtQueueElement)基本没有初始化
+     */
+
+    /*
+     * 根据virtio blk前端的代码:
+     *    第一个out的元素一定是header!!!!!!!!!
+     *    最后一个in的元素一定是status (返回状态)
+     * 所以这里必然至少一个out一个in
+     */
     if (req->elem.out_num < 1 || req->elem.in_num < 1) {
         virtio_error(vdev, "virtio-blk missing headers");
         return -1;
     }
 
+    /*
+     * iov是out的
+     *
+     * 这里获取out header, 就是把iov[0]的内容拷贝到req->out
+     * 因为req->out的类型是virtio_blk_outhdr
+     */
     if (unlikely(iov_to_buf(iov, out_num, 0, &req->out,
                             sizeof(req->out)) != sizeof(req->out))) {
         virtio_error(vdev, "virtio-blk request outhdr too short");
         return -1;
     }
 
+    /*
+     * 因为上面的header已经拷贝了, 修改iov和out_num把数量(或者还有指针???)移动一下
+     */
     iov_discard_front(&iov, &out_num, sizeof(req->out));
 
+    /*
+     * in_iov是in的
+     */
     if (in_iov[in_num - 1].iov_len < sizeof(struct virtio_blk_inhdr)) {
         virtio_error(vdev, "virtio-blk request inhdr too short");
         return -1;
     }
 
     /* We always touch the last byte, so just see how big in_iov is.  */
+    /*
+     * 计算所有in的总共的size
+     */
     req->in_len = iov_size(in_iov, in_num);
+    /*
+     * 获得in的header
+     */
     req->in = (void *)in_iov[in_num - 1].iov_base
               + in_iov[in_num - 1].iov_len
               - sizeof(struct virtio_blk_inhdr);
+    /*
+     * 可以像是上面iov_discard_front()一样把in的header也计算掉了
+     */
     iov_discard_back(in_iov, &in_num, sizeof(struct virtio_blk_inhdr));
 
+    /*
+     * 从第一个的out的header获得type
+     */
     type = virtio_ldl_p(VIRTIO_DEVICE(req->dev), &req->out.type);
 
     /* VIRTIO_BLK_T_OUT defines the command direction. VIRTIO_BLK_T_BARRIER
@@ -521,22 +893,53 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
     switch (type & ~(VIRTIO_BLK_T_OUT | VIRTIO_BLK_T_BARRIER)) {
     case VIRTIO_BLK_T_IN:
     {
+        /*
+	 * 似乎如果设置了IN, 就一定设置了OUT
+	 */
         bool is_write = type & VIRTIO_BLK_T_OUT;
+	/*
+	 * req就是参数的VirtIOBlockReq
+	 *
+	 * 4.18内核中的实现是blk_rq_pos():
+	 * 252         vbr->out_hdr.type = cpu_to_virtio32(vblk->vdev, type);
+	 * 253         vbr->out_hdr.sector = type ?
+	 * 254                 0 : cpu_to_virtio64(vblk->vdev, blk_rq_pos(req));
+	 * 255         vbr->out_hdr.ioprio = cpu_to_virtio32(vblk->vdev, req_get_ioprio(req));
+	 */
         req->sector_num = virtio_ldq_p(VIRTIO_DEVICE(req->dev),
                                        &req->out.sector);
 
+	/*
+	 * 下面根据is_write只能二选一
+	 * 一个virtio blk的request有out head, 有in head,
+	 * 剩下的要么是一组in的desc要么是out的desc
+	 */
         if (is_write) {
+            /*
+	     * qiov(QEMUIOVector)是用blk_aio_pwritev()和blk_aio_preadv()下去io的接口数据结构
+	     *
+	     * 此时req->qiov->nalloc=-1
+	     */
             qemu_iovec_init_external(&req->qiov, iov, out_num);
             trace_virtio_blk_handle_write(vdev, req, req->sector_num,
                                           req->qiov.size / BDRV_SECTOR_SIZE);
         } else {
+            /*
+	     * 此时req->qiov->nalloc=-1
+	     */
             qemu_iovec_init_external(&req->qiov, in_iov, in_num);
             trace_virtio_blk_handle_read(vdev, req, req->sector_num,
                                          req->qiov.size / BDRV_SECTOR_SIZE);
         }
 
+        /*
+	 * req->qiov.size是所有的iov[i].iov_len的和
+	 */
         if (!virtio_blk_sect_range_ok(req->dev, req->sector_num,
                                       req->qiov.size)) {
+            /*
+	     * 不ok就要response错误
+	     */
             virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
             block_acct_invalid(blk_get_stats(req->dev->blk),
                                is_write ? BLOCK_ACCT_WRITE : BLOCK_ACCT_READ);
@@ -553,15 +956,26 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
         if (mrb->num_reqs > 0 && (mrb->num_reqs == VIRTIO_BLK_MAX_MERGE_REQS ||
                                   is_write != mrb->is_write ||
                                   !req->dev->conf.request_merging)) {
+            /*
+	     * 一个例子是如果num_reqs达到上限了就立即下发io
+	     */
             virtio_blk_submit_multireq(req->dev->blk, mrb);
         }
 
         assert(mrb->num_reqs < VIRTIO_BLK_MAX_MERGE_REQS);
+	/*
+	 * 这里是更新mrb(MultiReqBuffer)的核心位置
+	 * mrb就是包含一个有上限的指针数组VirtIOBlockReq*
+	 */
         mrb->reqs[mrb->num_reqs++] = req;
         mrb->is_write = is_write;
         break;
     }
     case VIRTIO_BLK_T_FLUSH:
+        /*
+	 * virtio_blk_handle_vq()-->virtio_blk_handle_request()处理
+	 * VIRTIO_BLK_T_IN和VIRTIO_BLK_T_OUT时可能在mrb已经积攒了一些
+	 */
         virtio_blk_handle_flush(req, mrb);
         break;
     case VIRTIO_BLK_T_SCSI_CMD:
@@ -585,12 +999,28 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
         break;
     }
     default:
+        /*
+	 * 到了default说明not supported
+	 * 直接返回response(VIRTIO_BLK_S_UNSUPP)然后free相关内存
+	 */
+        /*
+	 * 根据VirtIOBlockReq回复前端response (设置status)
+	 * 核心思想是把VirtQueueElement给unmap (设置完status后)
+	 * 根据VirtQueueElement制作VRingUsedElem, 然后写入VRingUsed->ring[0+vq->used_idx]
+	 * 把VRingUsed->idx和vq->used_idx增加1
+	 * 然后通知前端 (virtio_blk_data_plane_notify()或者virtio_notify())
+	 */
         virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
         virtio_blk_free_request(req);
     }
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|233| <<virtio_blk_data_plane_handle_output>> return virtio_blk_handle_vq(s, vq);
+ *   - hw/block/virtio-blk.c|678| <<virtio_blk_handle_output_do>> virtio_blk_handle_vq(s, vq);
+ */
 bool virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
 {
     VirtIOBlockReq *req;
@@ -601,18 +1031,48 @@ bool virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
     blk_io_plug(s->blk);
 
     do {
+        /*
+	 * 先不让前端通知后端了
+	 */
         virtio_queue_set_notification(vq, 0);
 
+	/*
+	 * 从ring buffer把下一个avail的所有desc读出来
+	 * 分配一个结构,这个结构就是或者包含VirtQueueElement (这里是sizeof(VirtIOBlockReq))
+	 * 在这个结构后面附着in_addr, out_addr等指向的真是数据
+	 * 然后做一些简单初始化,要注意的是req->mr_next=NUL
+	 *
+	 * req是VirtIOBlockReq, 除了elem(VirtQueueElement)基本没有初始化
+	 */
         while ((req = virtio_blk_get_request(s, vq))) {
             progress = true;
+	    /*
+	     * mrb是该函数的本地临时变量
+	     */
             if (virtio_blk_handle_request(req, &mrb)) {
+                /*
+		 * 到这里说明失败了!!!!
+		 */
+                /*
+		 * 把VirtQueueElement中in_sg[]和out_sg[]数组的entry全部dma unmap
+		 * 并减少vq->inuse
+		 */
                 virtqueue_detach_element(req->vq, &req->elem, 0);
                 virtio_blk_free_request(req);
                 break;
             }
         }
 
+	/*
+	 * 前端又可以通知了
+	 */
         virtio_queue_set_notification(vq, 1);
+    /*
+     * 下面的while
+     * shadow_avail_idx是最近在VRingAvail.idx读的值
+     * last_avail_idx最最近后端使用的值
+     * 如果两者相等, 说明没有pending的request
+     */
     } while (!virtio_queue_empty(vq));
 
     if (mrb.num_reqs) {
@@ -624,11 +1084,41 @@ bool virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
     return progress;
 }
 
+/*
+ * called by only virtio_blk_handle_output()
+ *
+ * 用dataplane的时候测试时从没调用过
+ */
 static void virtio_blk_handle_output_do(VirtIOBlock *s, VirtQueue *vq)
 {
     virtio_blk_handle_vq(s, vq);
 }
 
+/*
+ * 如果没有开启ioeventfd, 就会用默认的pci write拦截的方法, 由cpu线程退出处理
+ * (gdb) bt
+ * #0  virtio_blk_handle_output (vdev=0x5555579d9b20, vq=0x7fffe6c9c010) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:634
+ * #1  0x000055555590001e in virtio_queue_notify (vdev=0x5555579d9b20, n=0) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1550
+ * #2  0x0000555555bedb64 in virtio_pci_notify_write (opaque=0x5555579d9b20, addr=0, val=0, size=2) at hw/virtio/virtio-pci.c:1363
+ * #3  0x000055555586b345 in memory_region_write_accessor (mr=0x5555579d2680, addr=0, value=0x7fffe7ffe7e8, size=2, shift=0, mask=65535, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #4  0x000055555586b55d in access_with_adjusted_size (addr=0, value=0x7fffe7ffe7e8, size=2, access_size_min=1, access_size_max=4, access_fn=0x55555586b25b <memory_region_write_accessor>,
+ *     mr=0x5555579d2680,attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #5  0x000055555586e185 in memory_region_dispatch_write (mr=0x5555579d2680, addr=0, data=0, size=2, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #6  0x000055555580a1bf in flatview_write_continue (fv=0x7fffd8005350, addr=4261425152, attrs=..., buf=0x7ffff7fef028 "", len=2, addr1=0, l=2, mr=0x5555579d2680) at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #7  0x000055555580a309 in flatview_write (fv=0x7fffd8005350, addr=4261425152, attrs=..., buf=0x7ffff7fef028 "", len=2) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #8  0x000055555580a60f in address_space_write (as=0x555556754580 <address_space_memory>, addr=4261425152, attrs=..., buf=0x7ffff7fef028 "", len=2) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #9  0x000055555580a660 in address_space_rw (as=0x555556754580 <address_space_memory>, addr=4261425152, attrs=..., buf=0x7ffff7fef028 "", len=2, is_write=true) at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #10 0x0000555555889395 in kvm_cpu_exec (cpu=0x5555568b3640) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1979
+ * #11 0x00005555558506cc in qemu_kvm_cpu_thread_fn (arg=0x5555568b3640) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #12 0x0000555555db5d87 in qemu_thread_start (args=0x5555568d56c0) at util/qemu-thread-posix.c:504
+ * #13 0x00007ffff47596ba in start_thread (arg=0x7fffe7fff700) at pthread_create.c:333
+ * #14 0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * used only by:
+ *   - hw/block/virtio-blk.c|1145| <<virtio_blk_device_realize>> virtio_add_queue(vdev, conf->queue_size, virtio_blk_handle_output);
+ *
+ * 用dataplane的时候测试时从没调用过
+ */
 static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBlock *s = (VirtIOBlock *)vdev;
@@ -645,6 +1135,47 @@ static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
     virtio_blk_handle_output_do(s, vq);
 }
 
+/*
+ * 只在qemu monitor cont的时候调用了
+ * (gdb) bt
+ * #0  virtio_blk_dma_restart_bh (opaque=0x5555579da580) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:649
+ * #1  0x0000555555dad6e6 in aio_bh_call (bh=0x555557850bc0) at util/async.c:90
+ * #2  0x0000555555dad77e in aio_bh_poll (ctx=0x555556886980) at util/async.c:118
+ * #3  0x0000555555db2d06 in aio_poll (ctx=0x555556886980, blocking=false) at util/aio-posix.c:689
+ * #4  0x0000555555cfd8a3 in bdrv_drain_poll_top_level (bs=0x5555568a3040, recursive=false, ignore_parent=0x0) at block/io.c:273
+ * #5  0x0000555555cfdd0a in bdrv_do_drained_begin (bs=0x5555568a3040, recursive=false, parent=0x0, ignore_bds_parents=false, poll=true) at block/io.c:390
+ * #6  0x0000555555cfdde0 in bdrv_drained_begin (bs=0x5555568a3040) at block/io.c:396
+ * #7  0x0000555555cfe0d7 in bdrv_drain (bs=0x5555568a3040) at block/io.c:478
+ * #8  0x0000555555c8e565 in bdrv_set_aio_context (bs=0x5555568a3040, new_context=0x5555568950c0) at block.c:4954
+ * #9  0x0000555555ceb18b in blk_set_aio_context (blk=0x5555568a2d80, new_context=0x5555568950c0) at block/block-backend.c:1894
+ * #10 0x00005555558b5d41 in virtio_blk_data_plane_start (vdev=0x5555579da580) at /home/zhang/kvm/qemu-3.0.0/hw/block/dataplane/virtio-blk.c:215
+ * #11 0x0000555555be8d86 in virtio_bus_start_ioeventfd (bus=0x5555579da508) at hw/virtio/virtio-bus.c:223
+ * #12 0x0000555555beb134 in virtio_pci_start_ioeventfd (proxy=0x5555579d2410) at hw/virtio/virtio-pci.c:288
+ * #13 0x0000555555beced9 in virtio_pci_vmstate_change (d=0x5555579d2410, running=true) at hw/virtio/virtio-pci.c:1076
+ * #14 0x00005555559018fd in virtio_vmstate_change (opaque=0x5555579da580, running=1, state=RUN_STATE_RUNNING) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2222
+ * #15 0x00005555559de673 in vm_state_notify (running=1, state=RUN_STATE_RUNNING) at vl.c:1532
+ * #16 0x0000555555851e84 in vm_prepare_start () at /home/zhang/kvm/qemu-3.0.0/cpus.c:2073
+ * #17 0x0000555555851ea8 in vm_start () at /home/zhang/kvm/qemu-3.0.0/cpus.c:2079
+ * #18 0x00005555559ffaae in qmp_cont (errp=0x7fffffffcd80) at qmp.c:180
+ * #19 0x0000555555a0475e in hmp_cont (mon=0x5555568a7450, qdict=0x55555779d000) at hmp.c:1168
+ * #20 0x000055555585b273 in handle_hmp_command (mon=0x5555568a7450, cmdline=0x5555568b1a04 "") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #21 0x000055555585d62e in monitor_command_cb (opaque=0x5555568a7450, cmdline=0x5555568b1a00 "cont", readline_opaque=0x0) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #22 0x0000555555dcda60 in readline_handle_byte (rs=0x5555568b1a00, ch=13) at util/readline.c:393
+ * #23 0x000055555585d581 in monitor_read (opaque=0x5555568a7450, buf=0x7fffffffcf40 "\r\317\377\377\377\177", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #24 0x0000555555d2d217 in qemu_chr_be_write_impl (s=0x555556893ab0, buf=0x7fffffffcf40 "\r\317\377\377\377\177", len=1) at chardev/char.c:175
+ * #25 0x0000555555d2d27b in qemu_chr_be_write (s=0x555556893ab0, buf=0x7fffffffcf40 "\r\317\377\377\377\177", len=1) at chardev/char.c:187
+ * #26 0x0000555555d2f98f in fd_chr_read (chan=0x555556893cf0, cond=G_IO_IN, opaque=0x555556893ab0) at chardev/char-fd.c:66
+ * #27 0x0000555555d4f6b7 in qio_channel_fd_source_dispatch (source=0x555556a65250, callback=0x555555d2f831 <fd_chr_read>, user_data=0x555556893ab0) at io/channel-watch.c:84
+ * #28 0x00007ffff50e004a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #29 0x0000555555db0d34 in glib_pollfds_poll () at util/main-loop.c:215
+ * #30 0x0000555555db0da2 in os_host_main_loop_wait (timeout=499000000) at util/main-loop.c:238
+ * #31 0x0000555555db0e5b in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #32 0x00005555559dee92 in main_loop () at vl.c:1866
+ * #33 0x00005555559e66a5 in main (argc=16, argv=0x7fffffffe3b8, envp=0x7fffffffe440) at vl.c:4644
+ *
+ * used only by:
+ *   - hw/block/virtio-blk.c|1153| <<virtio_blk_dma_restart_cb>> virtio_blk_dma_restart_bh, s);
+ */
 static void virtio_blk_dma_restart_bh(void *opaque)
 {
     VirtIOBlock *s = opaque;
@@ -680,6 +1211,32 @@ static void virtio_blk_dma_restart_bh(void *opaque)
     aio_context_release(blk_get_aio_context(s->conf.conf.blk));
 }
 
+/*
+ * 在qemu monitor调用stop和cont会调用:
+ * #0  virtio_blk_dma_restart_cb (opaque=0x5555579da580, running=0, state=RUN_STATE_PAUSED) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:686
+ * #1  0x00005555559de673 in vm_state_notify (running=0, state=RUN_STATE_PAUSED) at vl.c:1532
+ * #2  0x0000555555850140 in do_vm_stop (state=RUN_STATE_PAUSED, send_stop=true) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1012
+ * #3  0x0000555555851df0 in vm_stop (state=RUN_STATE_PAUSED) at /home/zhang/kvm/qemu-3.0.0/cpus.c:2039
+ * #4  0x00005555559ff858 in qmp_stop (errp=0x0) at qmp.c:106
+ * #5  0x0000555555a04290 in hmp_stop (mon=0x5555568a7450, qdict=0x555557c9bc90) at hmp.c:1062
+ * #6  0x000055555585b273 in handle_hmp_command (mon=0x5555568a7450, cmdline=0x5555568b1a04 "") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #7  0x000055555585d62e in monitor_command_cb (opaque=0x5555568a7450, cmdline=0x5555568b1a00 "stop", readline_opaque=0x0) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #8  0x0000555555dcda60 in readline_handle_byte (rs=0x5555568b1a00, ch=13) at util/readline.c:393
+ * #9  0x000055555585d581 in monitor_read (opaque=0x5555568a7450, buf=0x7fffffffcf40 "\r\317\377\377\377\177", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #10 0x0000555555d2d217 in qemu_chr_be_write_impl (s=0x555556893ab0, buf=0x7fffffffcf40 "\r\317\377\377\377\177", len=1) at chardev/char.c:175
+ * #11 0x0000555555d2d27b in qemu_chr_be_write (s=0x555556893ab0, buf=0x7fffffffcf40 "\r\317\377\377\377\177", len=1) at chardev/char.c:187
+ * #12 0x0000555555d2f98f in fd_chr_read (chan=0x555556893cf0, cond=G_IO_IN, opaque=0x555556893ab0) at chardev/char-fd.c:66
+ * #13 0x0000555555d4f6b7 in qio_channel_fd_source_dispatch (source=0x555556a65250, callback=0x555555d2f831 <fd_chr_read>, user_data=0x555556893ab0) at io/channel-watch.c:84
+ * #14 0x00007ffff50e004a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #15 0x0000555555db0d34 in glib_pollfds_poll () at util/main-loop.c:215
+ * #16 0x0000555555db0da2 in os_host_main_loop_wait (timeout=499000000) at util/main-loop.c:238
+ * #17 0x0000555555db0e5b in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #18 0x00005555559dee92 in main_loop () at vl.c:1866
+ * #19 0x00005555559e66a5 in main (argc=16, argv=0x7fffffffe3b8, envp=0x7fffffffe440) at vl.c:4644
+ *
+ * used only by:
+ *   - hw/block/virtio-blk.c|1574| <<virtio_blk_device_realize>> s->change = qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);
+ */
 static void virtio_blk_dma_restart_cb(void *opaque, int running,
                                       RunState state)
 {
@@ -696,6 +1253,12 @@ static void virtio_blk_dma_restart_cb(void *opaque, int running,
     }
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio.c|1201| <<virtio_reset>> k->reset(vdev);
+ *
+ * 在virtio_blk_class_init()中设置VirtioDeviceClass->reset = virtio_blk_reset()
+ */
 static void virtio_blk_reset(VirtIODevice *vdev)
 {
     VirtIOBlock *s = VIRTIO_BLK(vdev);
@@ -711,6 +1274,10 @@ static void virtio_blk_reset(VirtIODevice *vdev)
     while (s->rq) {
         req = s->rq;
         s->rq = req->next;
+	/*
+	 * 把VirtQueueElement(&req->elem)中in_sg[]和out_sg[]数组的entry全部dma unmap
+	 * 并减少vq->inuse
+	 */
         virtqueue_detach_element(req->vq, &req->elem, 0);
         virtio_blk_free_request(req);
     }
@@ -723,6 +1290,19 @@ static void virtio_blk_reset(VirtIODevice *vdev)
 
 /* coalesce internal state, copy to pci i/o region 0
  */
+/*
+ * 在以下被用到 (vdc是VirtioDeviceClass):
+ *   - hw/block/virtio-blk.c|1144| <<virtio_blk_class_init>> vdc->get_config = virtio_blk_update_config;
+ *
+ * called by:
+ *   - hw/virtio/virtio-bus.c|195| <<virtio_bus_get_vdev_config>> k->get_config(vdev, config);
+ *   - hw/virtio/virtio.c|1238| <<virtio_config_readb>> k->get_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1253| <<virtio_config_readw>> k->get_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1268| <<virtio_config_readl>> k->get_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1331| <<virtio_config_modern_readb>> k->get_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1346| <<virtio_config_modern_readw>> k->get_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1361| <<virtio_config_modern_readl>> k->get_config(vdev, vdev->config);
+ */
 static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)
 {
     VirtIOBlock *s = VIRTIO_BLK(vdev);
@@ -766,6 +1346,18 @@ static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)
     memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-bus.c|208| <<virtio_bus_set_vdev_config>> k->set_config(vdev, config);
+ *   - hw/virtio/virtio.c|1286| <<virtio_config_writeb>> k->set_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1302| <<virtio_config_writew>> k->set_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1318| <<virtio_config_writel>> k->set_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1380| <<virtio_config_modern_writeb>> k->set_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1397| <<virtio_config_modern_writew>> k->set_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1414| <<virtio_config_modern_writel>> k->set_config(vdev, vdev->config);
+ *
+ * 在virtio_blk_class_init()中设置VirtioDeviceClass->set_config = virtio_blk_set_config()
+ */
 static void virtio_blk_set_config(VirtIODevice *vdev, const uint8_t *config)
 {
     VirtIOBlock *s = VIRTIO_BLK(vdev);
@@ -778,6 +1370,12 @@ static void virtio_blk_set_config(VirtIODevice *vdev, const uint8_t *config)
     aio_context_release(blk_get_aio_context(s->blk));
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio-bus.c|99| <<virtio_bus_device_plugged>> vdev->host_features = vdc->get_features(vdev, vdev->host_features,
+ *
+ * 在virtio_blk_class_init()中设置VirtioDeviceClass->get_features = virtio_blk_get_features()
+ */
 static uint64_t virtio_blk_get_features(VirtIODevice *vdev, uint64_t features,
                                         Error **errp)
 {
@@ -813,6 +1411,12 @@ static uint64_t virtio_blk_get_features(VirtIODevice *vdev, uint64_t features,
     return features;
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio.c|1158| <<virtio_set_status>> k->set_status(vdev, val);
+ *
+ * 在virtio_blk_class_init()中设置VirtioDeviceClass->set_status = virtio_blk_set_status()
+ */
 static void virtio_blk_set_status(VirtIODevice *vdev, uint8_t status)
 {
     VirtIOBlock *s = VIRTIO_BLK(vdev);
@@ -849,6 +1453,28 @@ static void virtio_blk_set_status(VirtIODevice *vdev, uint8_t status)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_blk_save_device (vdev=0x5555579da580, f=0x55555688a010) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:854
+ * #1  0x0000555555900cbe in virtio_save (vdev=0x5555579da580, f=0x55555688a010) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1957
+ * #2  0x0000555555900d82 in virtio_device_put (f=0x55555688a010, opaque=0x5555579da580, size=0, field=0x55555659d280 <__compound_literal.0>, vmdesc=0x7fff1c05cf90)
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1975
+ * #3  0x0000555555c0b1e5 in vmstate_save_state_v (f=0x55555688a010, vmsd=0x555556486ca0 <vmstate_virtio_blk>, opaque=0x5555579da580, vmdesc=0x7fff1c05cf90, version_id=2) at migration/vmstate.c:384
+ * #4  0x0000555555c0ae75 in vmstate_save_state (f=0x55555688a010, vmsd=0x555556486ca0 <vmstate_virtio_blk>, opaque=0x5555579da580, vmdesc_id=0x7fff1c05cf90) at migration/vmstate.c:319
+ * #5  0x0000555555c03e0e in vmstate_save (f=0x55555688a010, se=0x555557b15da0, vmdesc=0x7fff1c05cf90) at migration/savevm.c:786
+ *     #6  0x0000555555c04efd in qemu_savevm_state_complete_precopy (f=0x55555688a010, iterable_only=false, inactivate_disks=true) at migration/savevm.c:1231
+ *     #7  0x0000555555bfcd37 in migration_completion (s=0x555556894630) at migration/migration.c:2534
+ *     #8  0x0000555555bfd6c0 in migration_iteration_run (s=0x555556894630) at migration/migration.c:2862
+ *     #9  0x0000555555bfd94e in migration_thread (opaque=0x555556894630) at migration/migration.c:2979
+ *     #10 0x0000555555db5d87 in qemu_thread_start (args=0x5555572078f0) at util/qemu-thread-posix.c:504
+ *     #11 0x00007ffff47596ba in start_thread (arg=0x7fffe4dff700) at pthread_create.c:333
+ *     #12 0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * called only by:
+ *   - hw/virtio/virtio.c|1957| <<virtio_save>> vdc->save(vdev, f);
+ *
+ * 在virtio_blk_class_init()设置VirtioDeviceClass->save = virtio_blk_save_devcice()
+ */
 static void virtio_blk_save_device(VirtIODevice *vdev, QEMUFile *f)
 {
     VirtIOBlock *s = VIRTIO_BLK(vdev);
@@ -867,6 +1493,27 @@ static void virtio_blk_save_device(VirtIODevice *vdev, QEMUFile *f)
     qemu_put_sbyte(f, 0);
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_blk_load_device (vdev=0x5555579da580, f=0x55555688a010, version_id=2) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:873
+ * #1  0x000055555590136d in virtio_load (vdev=0x5555579da580, f=0x55555688a010, version_id=2) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2106
+ * #2  0x0000555555900e3b in virtio_device_get (f=0x55555688a010, opaque=0x5555579da580, size=0, field=0x55555659d280 <__compound_literal.0>) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1985
+ * #3  0x0000555555c0a91a in vmstate_load_state (f=0x55555688a010, vmsd=0x555556486ca0 <vmstate_virtio_blk>, opaque=0x5555579da580, version_id=2) at migration/vmstate.c:143
+ * #4  0x0000555555c03c61 in vmstate_load (f=0x55555688a010, se=0x555557b15da0) at migration/savevm.c:756
+ * #5  0x0000555555c06801 in qemu_loadvm_section_start_full (f=0x55555688a010, mis=0x55555689d3e0) at migration/savevm.c:2098
+ * #6  0x0000555555c06d34 in qemu_loadvm_state_main (f=0x55555688a010, mis=0x55555689d3e0) at migration/savevm.c:2245
+ * #7  0x0000555555c06f6f in qemu_loadvm_state (f=0x55555688a010) at migration/savevm.c:2341
+ * #8  0x0000555555bf8a19 in process_incoming_migration_co (opaque=0x0) at migration/migration.c:396
+ * #9  0x0000555555dd04e6 in coroutine_trampoline (i0=1458945488, i1=21845) at util/coroutine-ucontext.c:116
+ * #10 0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #11 0x00007fffffffd690 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ *
+ * called only by:
+ *   - hw/virtio/virtio.c|2106| <<virtio_load>> ret = vdc->load(vdev, f, version_id);
+ *
+ * 在virtio_blk_class_init()设置VirtioDeviceClass->load = virtio_blk_class_init()
+ */
 static int virtio_blk_load_device(VirtIODevice *vdev, QEMUFile *f,
                                   int version_id)
 {
@@ -896,6 +1543,9 @@ static int virtio_blk_load_device(VirtIODevice *vdev, QEMUFile *f,
     return 0;
 }
 
+/*
+ * BlockDevOps virtio_block_ops.resize_cb = virtio_blk_resize()
+ */
 static void virtio_blk_resize(void *opaque)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(opaque);
@@ -903,10 +1553,54 @@ static void virtio_blk_resize(void *opaque)
     virtio_notify_config(vdev);
 }
 
+/*
+ * used only by:
+ *   - hw/block/virtio-blk.c|1108| <<virtio_blk_device_realize>> blk_set_dev_ops(s->blk, &virtio_block_ops, s);
+ */
 static const BlockDevOps virtio_block_ops = {
     .resize_cb = virtio_blk_resize,
 };
 
+/*
+ * (gdb) bt
+ * #0  virtio_blk_device_realize (dev=0x555557785cf0, errp=0x7fffffffdaa0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:911
+ * #1  0x00005555558ca3a0 in virtio_device_realize (dev=0x555557785cf0, errp=0x7fffffffdb00)
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2518
+ * #2  0x0000555555a2d447 in device_set_realized (obj=0x555557785cf0, value=true, errp=0x7fffffffdd38) at hw/core/qdev.c:826
+ * #3  0x0000555555c21bc7 in property_set_bool (obj=0x555557785cf0, v=0x555557790940, name=0x555555e3cce6 "realized", opaque=0x555557787620, 
+ *     errp=0x7fffffffdd38) at qom/object.c:1984
+ * #4  0x0000555555c1fe4c in object_property_set (obj=0x555557785cf0, v=0x555557790940, name=0x555555e3cce6 "realized", errp=0x7fffffffdd38)
+ *     at qom/object.c:1176
+ * #5  0x0000555555c22f04 in object_property_set_qobject (obj=0x555557785cf0, value=0x555557790890, name=0x555555e3cce6 "realized", 
+ *     errp=0x7fffffffdd38) at qom/qom-qobject.c:27
+ * #6  0x0000555555c20131 in object_property_set_bool (obj=0x555557785cf0, value=true, name=0x555555e3cce6 "realized", errp=0x7fffffffdd38)
+ *     at qom/object.c:1242
+ * #7  0x0000555555b92c9f in virtio_blk_pci_realize (vpci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1970
+ * #8  0x0000555555b92682 in virtio_pci_realize (pci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1841
+ * #9  0x0000555555af770d in pci_qdev_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/pci/pci.c:2028
+ * #10 0x0000555555b92a90 in virtio_pci_dc_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/virtio/virtio-pci.c:1915
+ * #11 0x0000555555a2d447 in device_set_realized (obj=0x55555777db80, value=true, errp=0x7fffffffdfc0) at hw/core/qdev.c:826
+ * #12 0x0000555555c21bc7 in property_set_bool (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", opaque=0x555557785fa0, 
+ *     errp=0x7fffffffdfc0) at qom/object.c:1984
+ * #13 0x0000555555c1fe4c in object_property_set (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1176
+ * #14 0x0000555555c22f04 in object_property_set_qobject (obj=0x55555777db80, value=0x55555778a8a0, name=0x555555db778a "realized", 
+ *     errp=0x7fffffffdfc0) at qom/qom-qobject.c:27
+ * #15 0x0000555555c20131 in object_property_set_bool (obj=0x55555777db80, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1242
+ * #16 0x0000555555990749 in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe038) at qdev-monitor.c:627
+ * #17 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+ * #18 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, 
+ *     errp=0x0) at util/qemu-option.c:1106
+ * #19 0x000055555599dd61 in main (argc=15, argv=0x7fffffffe3a8, envp=0x7fffffffe428) at vl.c:4542
+ *
+ *
+ * 在以下被设置 (vdc是VirtioDeviceClass):
+ *   - hw/block/virtio-blk.c|1138| <<virtio_blk_class_init>> vdc->realize = virtio_blk_device_realize;
+ *
+ * called by:
+ *   - hw/virtio/virtio.c|2612| <<virtio_device_realize>> vdc->realize(dev, &err);
+ */
 static void virtio_blk_device_realize(DeviceState *dev, Error **errp)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
@@ -915,6 +1609,12 @@ static void virtio_blk_device_realize(DeviceState *dev, Error **errp)
     Error *err = NULL;
     unsigned i;
 
+    /*
+     * conf->conf.blk类型是BlockBackend
+     * conf->conf是BlockConf
+     *
+     * conf->conf.blk是用"drive"参数设计的
+     */
     if (!conf->conf.blk) {
         error_setg(errp, "drive property not set");
         return;
@@ -942,10 +1642,27 @@ static void virtio_blk_device_realize(DeviceState *dev, Error **errp)
         return;
     }
     s->original_wce = blk_enable_write_cache(conf->conf.blk);
+    /*
+     * (gdb) bt
+     * #0  raw_probe_geometry (bs=0x5555568a3160, geo=0x7fffffffd9c0) at block/raw-format.c:493
+     * #1  0x0000555555c849ff in bdrv_probe_geometry (bs=0x5555568a3160, geo=0x7fffffffd9c0) at block.c:525
+     * #2  0x0000555555ceb761 in blk_probe_geometry (blk=0x5555568a2ea0, geo=0x7fffffffd9c0) at block/block-backend.c:2066
+     * #3  0x0000555555a50f5e in hd_geometry_guess (blk=0x5555568a2ea0, pcyls=0x5555579015ac, pheads=0x5555579015b0, psecs=0x5555579015b4, ptrans=0x0) at hw/block/hd-geometry.c:131
+     * #4  0x0000555555a502b9 in blkconf_geometry (conf=0x555557901590, ptrans=0x0, cyls_max=65535, heads_max=255, secs_max=255, errp=0x7fffffffdaa0) at hw/block/block.c:126
+     * #5  0x00005555558b3eb8 in virtio_blk_device_realize (dev=0x5555579013e0, errp=0x7fffffffdaa0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:945
+     */
     if (!blkconf_geometry(&conf->conf, NULL, 65535, 255, 255, errp)) {
         return;
     }
 
+    /*
+     * (gdb) bt
+     * #0  raw_probe_blocksizes (bs=0x5555568a3160, bsz=0x7fffffffda10) at block/raw-format.c:476
+     * #1  0x0000555555c84966 in bdrv_probe_blocksizes (bs=0x5555568a3160, bsz=0x7fffffffda10) at block.c:506
+     * #2  0x0000555555ceb717 in blk_probe_blocksizes (blk=0x5555568a2ea0, bsz=0x7fffffffda10) at block/block-backend.c:2057
+     * #3  0x0000555555a5001c in blkconf_blocksizes (conf=0x555557901590) at hw/block/block.c:37
+     * #4  0x00005555558b3ecf in virtio_blk_device_realize (dev=0x5555579013e0, errp=0x7fffffffdaa0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:949
+     */
     blkconf_blocksizes(&conf->conf);
 
     if (conf->conf.logical_block_size >
@@ -963,6 +1680,9 @@ static void virtio_blk_device_realize(DeviceState *dev, Error **errp)
     s->sector_mask = (s->conf.conf.logical_block_size / BDRV_SECTOR_SIZE) - 1;
 
     for (i = 0; i < conf->num_queues; i++) {
+        /*
+	 * virtio_blk_handle_output()用dataplane的时候测试时从没调用过
+	 */
         virtio_add_queue(vdev, conf->queue_size, virtio_blk_handle_output);
     }
     virtio_blk_data_plane_create(vdev, conf, &s->dataplane, &err);
@@ -979,6 +1699,58 @@ static void virtio_blk_device_realize(DeviceState *dev, Error **errp)
     blk_iostatus_enable(s->blk);
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_blk_device_unrealize (dev=0x555556abf170, errp=0x7fffecaaffa0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:984
+ * #1  0x00005555558ca50b in virtio_device_unrealize (dev=0x555556abf170, errp=0x7fffecab0000) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2545
+ * #2  0x0000555555a2d6d3 in device_set_realized (obj=0x555556abf170, value=false, errp=0x7fffecab01d0) at hw/core/qdev.c:886
+ * #3  0x0000555555c21bc7 in property_set_bool (obj=0x555556abf170, v=0x7fffe404a020, name=0x555555ddc924 "realized", opaque=0x555557412410, errp=0x7fffecab01d0)
+ *     at qom/object.c:1984
+ * #4  0x0000555555c1fe4c in object_property_set (obj=0x555556abf170, v=0x7fffe404a020, name=0x555555ddc924 "realized", errp=0x7fffecab01d0) at qom/object.c:1176
+ * #5  0x0000555555c22f04 in object_property_set_qobject (obj=0x555556abf170, value=0x7fffe404a000, name=0x555555ddc924 "realized", errp=0x7fffecab01d0) at qom/qom-qobject.c:27
+ * #6  0x0000555555c20131 in object_property_set_bool (obj=0x555556abf170, value=false, name=0x555555ddc924 "realized", errp=0x7fffecab01d0) at qom/object.c:1242
+ * #7  0x0000555555a31690 in bus_set_realized (obj=0x555556abf0f8, value=false, errp=0x7fffecab0380) at hw/core/bus.c:172
+ * #8  0x0000555555c21bc7 in property_set_bool (obj=0x555556abf0f8, v=0x7fffe4049f30, name=0x555555ddb971 "realized", opaque=0x555556daeaa0, errp=0x7fffecab0380)
+ *     at qom/object.c:1984
+ * #9  0x0000555555c1fe4c in object_property_set (obj=0x555556abf0f8, v=0x7fffe4049f30, name=0x555555ddb971 "realized", errp=0x7fffecab0380) at qom/object.c:1176
+ * #10 0x0000555555c22f04 in object_property_set_qobject (obj=0x555556abf0f8, value=0x7fffe4044500, name=0x555555ddb971 "realized", errp=0x7fffecab0380) at qom/qom-qobject.c:27
+ * #11 0x0000555555c20131 in object_property_set_bool (obj=0x555556abf0f8, value=false, name=0x555555ddb971 "realized", errp=0x7fffecab0380) at qom/object.c:1242
+ * #12 0x0000555555a2d64a in device_set_realized (obj=0x555556ab7000, value=false, errp=0x0) at hw/core/qdev.c:878
+ * #13 0x0000555555c21bc7 in property_set_bool (obj=0x555556ab7000, v=0x7fffe4049e30, name=0x555555ddb971 "realized", opaque=0x55555669d890, errp=0x0) at qom/object.c:1984
+ * #14 0x0000555555c1fe4c in object_property_set (obj=0x555556ab7000, v=0x7fffe4049e30, name=0x555555ddb971 "realized", errp=0x0) at qom/object.c:1176
+ * #15 0x0000555555c22f04 in object_property_set_qobject (obj=0x555556ab7000, value=0x7fffe40444e0, name=0x555555ddb971 "realized", errp=0x0) at qom/qom-qobject.c:27
+ * #16 0x0000555555c20131 in object_property_set_bool (obj=0x555556ab7000, value=false, name=0x555555ddb971 "realized", errp=0x0) at qom/object.c:1242
+ * #17 0x0000555555a2dd81 in device_unparent (obj=0x555556ab7000) at hw/core/qdev.c:1028
+ * #18 0x0000555555c20ac4 in object_finalize_child_property (obj=0x5555565e1df0, name=0x555557683c90 "virtio-disk1", opaque=0x555556ab7000) at qom/object.c:1487
+ * #19 0x0000555555c1e5c0 in object_property_del_child (obj=0x5555565e1df0, child=0x555556ab7000, errp=0x0) at qom/object.c:490
+ * #20 0x0000555555c1e6a0 in object_unparent (obj=0x555556ab7000) at qom/object.c:509
+ * #21 0x00005555559e0e19 in acpi_pcihp_eject_slot (s=0x555557609ee0, bsel=0, slots=32) at hw/acpi/pcihp.c:173
+ * #22 0x00005555559e1449 in pci_write (opaque=0x555557609ee0, addr=8, data=32, size=4) at hw/acpi/pcihp.c:308
+ * #23 0x000055555583317e in memory_region_write_accessor (mr=0x55555760aaf0, addr=8, value=0x7fffecab07a8, size=4, shift=0, mask=4294967295, attrs=...)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #24 0x0000555555833396 in access_with_adjusted_size (addr=8, value=0x7fffecab07a8, size=4, access_size_min=1, access_size_max=4, 
+ *     access_fn=0x555555833094 <memory_region_write_accessor>, mr=0x55555760aaf0, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #25 0x0000555555835fbe in memory_region_dispatch_write (mr=0x55555760aaf0, addr=8, data=32, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #26 0x00005555557d1ff8 in flatview_write_continue (fv=0x7fffe47a2a10, addr=44552, attrs=..., buf=0x7ffff7ff0000 " ", len=4, addr1=8, l=4, mr=0x55555760aaf0)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #27 0x00005555557d2142 in flatview_write (fv=0x7fffe47a2a10, addr=44552, attrs=..., buf=0x7ffff7ff0000 " ", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #28 0x00005555557d2448 in address_space_write (as=0x555556498ae0 <address_space_io>, addr=44552, attrs=..., buf=0x7ffff7ff0000 " ", len=4)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #29 0x00005555557d2499 in address_space_rw (as=0x555556498ae0 <address_space_io>, addr=44552, attrs=..., buf=0x7ffff7ff0000 " ", len=4, is_write=true)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #30 0x0000555555850a3d in kvm_handle_io (port=44552, attrs=..., data=0x7ffff7ff0000, direction=1, size=4, count=1) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1729
+ * #31 0x0000555555851181 in kvm_cpu_exec (cpu=0x5555565f4360) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1969
+ * #32 0x0000555555818505 in qemu_kvm_cpu_thread_fn (arg=0x5555565f4360) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #33 0x0000555555d54975 in qemu_thread_start (args=0x555556615fa0) at util/qemu-thread-posix.c:504
+ * #34 0x00007ffff55126ba in start_thread (arg=0x7fffecab1700) at pthread_create.c:333
+ * #35 0x00007ffff524841d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * called by:
+ *   - hw/virtio/virtio.c|2622| <<virtio_device_realize>> vdc->unrealize(dev, NULL);
+ *   - hw/virtio/virtio.c|2639| <<virtio_device_unrealize>> vdc->unrealize(dev, &err);
+ *
+ * 在virtio_blk_class_init()中设置为VirtioDeviceClass->unrealize = virtio_blk_device_unrealize()
+ */
 static void virtio_blk_device_unrealize(DeviceState *dev, Error **errp)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
@@ -991,6 +1763,32 @@ static void virtio_blk_device_unrealize(DeviceState *dev, Error **errp)
     virtio_cleanup(vdev);
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_blk_instance_init (obj=0x555557785cf0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:996
+ * #1  0x0000555555c1dfee in object_init_with_type (obj=0x555557785cf0, ti=0x5555564f9e70) at qom/object.c:353
+ * #2  0x0000555555c1e1b1 in object_initialize_with_type (data=0x555557785cf0, size=552, type=0x5555564f9e70) at qom/object.c:384
+ * #3  0x0000555555c1e202 in object_initialize (data=0x555557785cf0, size=552, typename=0x555555e3ccef "virtio-blk-device") at qom/object.c:392
+ * #4  0x00005555558c9797 in virtio_instance_init_common (proxy_obj=0x55555777db80, data=0x555557785cf0, vdev_size=552, 
+ *     vdev_name=0x555555e3ccef "virtio-blk-device") at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2235
+ * #5  0x0000555555b92df4 in virtio_blk_pci_instance_init (obj=0x55555777db80) at hw/virtio/virtio-pci.c:1992
+ * #6  0x0000555555c1dfee in object_init_with_type (obj=0x55555777db80, ti=0x555556527f40) at qom/object.c:353
+ * #7  0x0000555555c1e1b1 in object_initialize_with_type (data=0x55555777db80, size=33696, type=0x555556527f40) at qom/object.c:384
+ * #8  0x0000555555c1e805 in object_new_with_type (type=0x555556527f40) at qom/object.c:546
+ * #9  0x0000555555c1e842 in object_new (typename=0x555556536340 "virtio-blk-pci") at qom/object.c:556
+ * #10 0x000055555599064c in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe038) at qdev-monitor.c:608
+ * #11 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+ * #12 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, 
+ *     errp=0x0) at util/qemu-option.c:1106
+ * #13 0x000055555599dd61 in main (argc=15, argv=0x7fffffffe3a8, envp=0x7fffffffe428) at vl.c:4542
+ *
+ * TypeInfo virtio_blk_info.instance_init = virtio_blk_instance_init()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ *
+ * 主要是从virtio_blk_pci_instance_init()调用来的
+ */
 static void virtio_blk_instance_init(Object *obj)
 {
     VirtIOBlock *s = VIRTIO_BLK(obj);
@@ -1000,6 +1798,21 @@ static void virtio_blk_instance_init(Object *obj)
                                   DEVICE(obj), NULL);
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_device_put (f=0x555556c5a800, opaque=0x5555579da580, size=0, field=0x55555659d280 <__compound_literal.0>, vmdesc=0x7fff4805d450) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1975
+ * #1  0x0000555555c0b1e5 in vmstate_save_state_v (f=0x555556c5a800, vmsd=0x555556486ca0 <vmstate_virtio_blk>, opaque=0x5555579da580, vmdesc=0x7fff4805d450, version_id=2) at migration/vmstate.c:384
+ * #2  0x0000555555c0ae75 in vmstate_save_state (f=0x555556c5a800, vmsd=0x555556486ca0 <vmstate_virtio_blk>, opaque=0x5555579da580, vmdesc_id=0x7fff4805d450) at migration/vmstate.c:319
+ * #3  0x0000555555c03e0e in vmstate_save (f=0x555556c5a800, se=0x555557b15da0, vmdesc=0x7fff4805d450) at migration/savevm.c:786
+ * #4  0x0000555555c04efd in qemu_savevm_state_complete_precopy (f=0x555556c5a800, iterable_only=false, inactivate_disks=true) at migration/savevm.c:1231
+ * #5  0x0000555555bfcd37 in migration_completion (s=0x555556894630) at migration/migration.c:2534
+ * #6  0x0000555555bfd6c0 in migration_iteration_run (s=0x555556894630) at migration/migration.c:2862
+ * #7  0x0000555555bfd94e in migration_thread (opaque=0x555556894630) at migration/migration.c:2979
+ * #8  0x0000555555db5d87 in qemu_thread_start (args=0x5555576e8240) at util/qemu-thread-posix.c:504
+ * #9  0x00007ffff47596ba in start_thread (arg=0x7fff4f3cf700) at pthread_create.c:333
+ * #10 0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
+
 static const VMStateDescription vmstate_virtio_blk = {
     .name = "virtio-blk",
     .minimum_version_id = 2,
@@ -1010,6 +1823,192 @@ static const VMStateDescription vmstate_virtio_blk = {
     },
 };
 
+/*
+ * virtio_blk_properties[]数组中有一个:
+ *
+ * struct Property {
+ *     const char *name = "num_queues";
+ *     const PropertyInfo *info = qdev_prop_uint16;
+ *     ptrdiff_t offset = offsetof(VirtIOBlock, conf.num_queues);
+ *     bool set_default = true;
+ *     defval.u = (uint16_t) 1 (queue的数量)
+ * }
+ *
+ * 下面是PropertyInfo的定义:
+ *
+ * const PropertyInfo qdev_prop_uint16 = {
+ *     .name  = "uint16",
+ *     .get   = get_uint16,
+ *     .set   = set_uint16,
+ *     .set_default_value = set_default_value_uint,
+ * };
+ *
+ * 所有的virtio_blk_properties[] (struct Property)会在TypeInfo
+ * device_type_info.instance_init=device_initfn()中初始化object时插入Object->properties
+ * (GHashTable).
+ *
+ * device_initfn()会调用qdev_property_add_static()-->object_property_add().
+ *
+ * object_property_add()首先分配一个ObjectProperty, 然后按照如下初始化:
+ *
+ * struct ObjectProperty {
+ *     name = "num_queues";
+ *     type = "uint16";
+ *     get = get_uint16; (来自PropertyInfo)
+ *     set = set_uint16; (来自PropertyInfo)
+ *     release = NULL;
+ *     opaque = (struct Property);
+ * }
+ *
+ * 然后插入ObjectProperty到Object->properties (GHashTable)
+ *
+ * 在qdev_property_add_static()中, 如果Property有set_default
+ * ("num_queues"是有的)就调用prop->info->set_default_value=set_default_value_uint()设置默认的queue的数目
+ *
+ *
+ *
+ * 修改的时候调用object_property_set()调用ObjectProperty *prop->set = set_uint16()
+ *
+ * 从ObjectProperty的opaque中获得Property
+ *
+ * 把新的值写入(DeviceState的基地址+Property.offset)
+ *
+ * 181 void visit_type_uint16(Visitor *v, const char *name, uint16_t *obj,
+ * 182                        Error **errp)
+ * 183 {    
+ * 184     uint64_t value; 
+ * 185 
+ * 186     trace_visit_type_uint16(v, name, obj);
+ * 187     value = *obj;
+ * 188     visit_type_uintN(v, &value, name, UINT16_MAX, "uint16_t", errp);
+ * 190     *obj = value;
+ * 191 }
+ */
+
+/*
+ * physical_block_size初始化例子 (初始化的例子):
+ * (gdb) bt
+ * #0  object_property_set (obj=0x5555579d9c30, v=0x5555579db980, name=0x555555eb780d "physical_block_size", errp=0x555556785fb0 <error_abort>) at qom/object.c:1168
+ * #1  0x0000555555c83058 in object_property_set_qobject (obj=0x5555579d9c30, value=0x5555579db950, name=0x555555eb780d "physical_block_size", errp=0x555556785fb0 <error_abort>) at qom/qom-qobject.c:27
+ * #2  0x0000555555c80593 in object_property_set_uint (obj=0x5555579d9c30, value=0, name=0x555555eb780d "physical_block_size", errp=0x555556785fb0 <error_abort>) at qom/object.c:1304
+ * #3  0x0000555555a7e2ff in set_default_value_uint (obj=0x5555579d9c30, prop=0x55555659d3f0 <virtio_blk_properties+144>) at hw/core/qdev-properties.c:272
+ * #4  0x0000555555a7c7e5 in qdev_property_add_static (dev=0x5555579d9c30, prop=0x55555659d3f0 <virtio_blk_properties+144>, errp=0x555556785fb0 <error_abort>) at hw/core/qdev.c:716
+ * #5  0x0000555555a7d2f0 in device_initfn (obj=0x5555579d9c30) at hw/core/qdev.c:966
+ * #6  0x0000555555c7e142 in object_init_with_type (obj=0x5555579d9c30, ti=0x5555567ca6e0) at qom/object.c:353
+ * #7  0x0000555555c7e124 in object_init_with_type (obj=0x5555579d9c30, ti=0x5555567b9580) at qom/object.c:349
+ * #8  0x0000555555c7e124 in object_init_with_type (obj=0x5555579d9c30, ti=0x5555567b60a0) at qom/object.c:349
+ * #9  0x0000555555c7e305 in object_initialize_with_type (data=0x5555579d9c30, size=552, type=0x5555567b60a0) at qom/object.c:384
+ * #10 0x0000555555c7e356 in object_initialize (data=0x5555579d9c30, size=552, typename=0x555555f6738f "virtio-blk-device") at qom/object.c:392
+ * #11 0x000055555590195e in virtio_instance_init_common (proxy_obj=0x5555579d1ac0, data=0x5555579d9c30, vdev_size=552, vdev_name=0x555555f6738f "virtio-blk-device")
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2235
+ * #12 0x0000555555bef492 in virtio_blk_pci_instance_init (obj=0x5555579d1ac0) at hw/virtio/virtio-pci.c:1992
+ * #13 0x0000555555c7e142 in object_init_with_type (obj=0x5555579d1ac0, ti=0x5555567e4de0) at qom/object.c:353
+ * #14 0x0000555555c7e305 in object_initialize_with_type (data=0x5555579d1ac0, size=33696, type=0x5555567e4de0) at qom/object.c:384
+ * #15 0x0000555555c7e959 in object_new_with_type (type=0x5555567e4de0) at qom/object.c:546
+ * #16 0x0000555555c7e996 in object_new (typename=0x5555567f3970 "virtio-blk-pci") at qom/object.c:556
+ * #17 0x00005555559d8d34 in qdev_device_add (opts=0x5555567f3920, errp=0x7fffffffe0a8) at qdev-monitor.c:608
+ * #18 0x00005555559e12b8 in device_init_func (opaque=0x0, opts=0x5555567f3920, errp=0x0) at vl.c:2275
+ * #19 0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b76c0 <qemu_device_opts>, func=0x5555559e127a <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #20 0x00005555559e6449 in main (argc=12, argv=0x7fffffffe418, envp=0x7fffffffe480) at vl.c:4542
+ *
+ *
+ * num-queues的例子 (初始化的例子):
+ * (gdb) bt
+ * #0  object_property_set (obj=0x5555579d9c30, v=0x5555579dc4d0, name=0x555555eb78a7 "num-queues", errp=0x555556785fb0 <error_abort>) at qom/object.c:1168
+ * #1  0x0000555555c83058 in object_property_set_qobject (obj=0x5555579d9c30, value=0x5555579dae90, name=0x555555eb78a7 "num-queues", errp=0x555556785fb0 <error_abort>) at qom/qom-qobject.c:27
+ * #2  0x0000555555c80593 in object_property_set_uint (obj=0x5555579d9c30, value=1, name=0x555555eb78a7 "num-queues", errp=0x555556785fb0 <error_abort>) at qom/object.c:1304
+ * #3  0x0000555555a7e2ff in set_default_value_uint (obj=0x5555579d9c30, prop=0x55555659d828 <virtio_blk_properties+1224>) at hw/core/qdev-properties.c:272
+ * #4  0x0000555555a7c7e5 in qdev_property_add_static (dev=0x5555579d9c30, prop=0x55555659d828 <virtio_blk_properties+1224>, errp=0x555556785fb0 <error_abort>) at hw/core/qdev.c:716
+ * #5  0x0000555555a7d2f0 in device_initfn (obj=0x5555579d9c30) at hw/core/qdev.c:966
+ * #6  0x0000555555c7e142 in object_init_with_type (obj=0x5555579d9c30, ti=0x5555567ca6e0) at qom/object.c:353
+ * #7  0x0000555555c7e124 in object_init_with_type (obj=0x5555579d9c30, ti=0x5555567b9580) at qom/object.c:349
+ * #8  0x0000555555c7e124 in object_init_with_type (obj=0x5555579d9c30, ti=0x5555567b60a0) at qom/object.c:349
+ * #9  0x0000555555c7e305 in object_initialize_with_type (data=0x5555579d9c30, size=552, type=0x5555567b60a0) at qom/object.c:384
+ * #10 0x0000555555c7e356 in object_initialize (data=0x5555579d9c30, size=552, typename=0x555555f6738f "virtio-blk-device") at qom/object.c:392
+ * #11 0x000055555590195e in virtio_instance_init_common (proxy_obj=0x5555579d1ac0, data=0x5555579d9c30, vdev_size=552, vdev_name=0x555555f6738f "virtio-blk-device")
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2235
+ * #12 0x0000555555bef492 in virtio_blk_pci_instance_init (obj=0x5555579d1ac0) at hw/virtio/virtio-pci.c:1992
+ * #13 0x0000555555c7e142 in object_init_with_type (obj=0x5555579d1ac0, ti=0x5555567e4de0) at qom/object.c:353
+ * #14 0x0000555555c7e305 in object_initialize_with_type (data=0x5555579d1ac0, size=33696, type=0x5555567e4de0) at qom/object.c:384
+ * #15 0x0000555555c7e959 in object_new_with_type (type=0x5555567e4de0) at qom/object.c:546
+ * #16 0x0000555555c7e996 in object_new (typename=0x5555567f3970 "virtio-blk-pci") at qom/object.c:556
+ * #17 0x00005555559d8d34 in qdev_device_add (opts=0x5555567f3920, errp=0x7fffffffe0a8) at qdev-monitor.c:608
+ * #18 0x00005555559e12b8 in device_init_func (opaque=0x0, opts=0x5555567f3920, errp=0x0) at vl.c:2275
+ * #19 0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b76c0 <qemu_device_opts>, func=0x5555559e127a <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #20 0x00005555559e6449 in main (argc=12, argv=0x7fffffffe418, envp=0x7fffffffe480) at vl.c:4542
+ *
+ *
+ * num-queues的例子 (初始化完设备设置成2的例子):
+ * (gdb) bt
+ * #0  object_property_set (obj=0x5555579d9c30, v=0x5555579de920, name=0x5555579ddfe0 "num-queues", errp=0x7fffffffdfa8) at qom/object.c:1168
+ * #1  0x0000555555c82b45 in property_set_alias (obj=0x5555579d1ac0, v=0x5555579de920, name=0x5555567f3ad0 "num-queues", opaque=0x5555579ddfc0, errp=0x7fffffffdfa8) at qom/object.c:2330
+ * #2  0x0000555555c7ffa0 in object_property_set (obj=0x5555579d1ac0, v=0x5555579de920, name=0x5555567f3ad0 "num-queues", errp=0x7fffffffdfa8) at qom/object.c:1176
+ * #3  0x0000555555c809bf in object_property_parse (obj=0x5555579d1ac0, string=0x5555567f3900 "2", name=0x5555567f3ad0 "num-queues", errp=0x7fffffffdfa8) at qom/object.c:1402
+ * #4  0x00005555559d798e in set_property (opaque=0x5555579d1ac0, name=0x5555567f3ad0 "num-queues", value=0x5555567f3900 "2", errp=0x7fffffffe030) at qdev-monitor.c:180
+ * #5  0x0000555555dc83e9 in qemu_opt_foreach (opts=0x5555567f3920, func=0x5555559d7903 <set_property>, opaque=0x5555579d1ac0, errp=0x7fffffffe030) at util/qemu-option.c:580
+ * #6  0x00005555559d8e02 in qdev_device_add (opts=0x5555567f3920, errp=0x7fffffffe0a8) at qdev-monitor.c:622
+ * #7  0x00005555559e12b8 in device_init_func (opaque=0x0, opts=0x5555567f3920, errp=0x0) at vl.c:2275
+ * #8  0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b76c0 <qemu_device_opts>, func=0x5555559e127a <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #9  0x00005555559e6449 in main (argc=12, argv=0x7fffffffe418, envp=0x7fffffffe480) at vl.c:4542
+ *
+ * 
+ * iothread的例子 (初始化设备时的例子):
+ * (gdb) bt
+ * #0  create_link_property (obj=0x55555771a410, prop=0x5555562e48b8 <virtio_blk_properties+1368>, errp=0x7fffffffdd68) at hw/core/qdev-properties.c:1306
+ * #1  0x0000555555a2cebd in qdev_property_add_static (dev=0x55555771a410, prop=0x5555562e48b8 <virtio_blk_properties+1368>, errp=0x5555564c9e70 <error_abort>) at hw/core/qdev.c:690
+ * #2  0x0000555555a2daaa in device_initfn (obj=0x55555771a410) at hw/core/qdev.c:966
+ * #3  0x0000555555c1dfee in object_init_with_type (obj=0x55555771a410, ti=0x55555650db70) at qom/object.c:353
+ * #4  0x0000555555c1dfd0 in object_init_with_type (obj=0x55555771a410, ti=0x5555564fd310) at qom/object.c:349
+ * #5  0x0000555555c1dfd0 in object_init_with_type (obj=0x55555771a410, ti=0x5555564f9e30) at qom/object.c:349
+ * #6  0x0000555555c1e1b1 in object_initialize_with_type (data=0x55555771a410, size=552, type=0x5555564f9e30) at qom/object.c:384
+ * #7  0x0000555555c1e202 in object_initialize (data=0x55555771a410, size=552, typename=0x555555e3ccef "virtio-blk-device") at qom/object.c:392
+ * #8  0x00005555558c9797 in virtio_instance_init_common (proxy_obj=0x5555577122a0, data=0x55555771a410, vdev_size=552, vdev_name=0x555555e3ccef "virtio-blk-device")
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2235
+ * #9  0x0000555555b92df4 in virtio_blk_pci_instance_init (obj=0x5555577122a0) at hw/virtio/virtio-pci.c:1992
+ * #10 0x0000555555c1dfee in object_init_with_type (obj=0x5555577122a0, ti=0x555556527f40) at qom/object.c:353
+ * #11 0x0000555555c1e1b1 in object_initialize_with_type (data=0x5555577122a0, size=33696, type=0x555556527f40) at qom/object.c:384
+ * #12 0x0000555555c1e805 in object_new_with_type (type=0x555556527f40) at qom/object.c:546
+ * #13 0x0000555555c1e842 in object_new (typename=0x555556536320 "virtio-blk-pci") at qom/object.c:556
+ * #14 0x000055555599064c in qdev_device_add (opts=0x5555565362d0, errp=0x7fffffffe078) at qdev-monitor.c:608
+ * #15 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362d0, errp=0x0) at vl.c:2275
+ * #16 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #17 0x000055555599dd61 in main (argc=16, argv=0x7fffffffe3e8, envp=0x7fffffffe470) at vl.c:4542
+ *
+ *
+ * iothread的例子 (初始化设备完成时的例子):
+ * (gdb) bt
+ * #0  object_set_link_property (obj=0x55555771a410, v=0x55555771f100, name=0x55555771e960 "iothread", opaque=0x55555771cd40, errp=0x7fffffffdf78) at qom/object.c:1595
+ * #1  0x0000555555c1fe4c in object_property_set (obj=0x55555771a410, v=0x55555771f100, name=0x55555771e960 "iothread", errp=0x7fffffffdf78) at qom/object.c:1176
+ * #2  0x0000555555c229f1 in property_set_alias (obj=0x5555577122a0, v=0x55555771f100, name=0x555556536500 "iothread", opaque=0x55555771e940, errp=0x7fffffffdf78)
+ *     at qom/object.c:2330
+ * #3  0x0000555555c1fe4c in object_property_set (obj=0x5555577122a0, v=0x55555771f100, name=0x555556536500 "iothread", errp=0x7fffffffdf78) at qom/object.c:1176
+ * #4  0x0000555555c2086b in object_property_parse (obj=0x5555577122a0, string=0x5555565364a0 "io1", name=0x555556536500 "iothread", errp=0x7fffffffdf78) at qom/object.c:1402
+ * #5  0x000055555598f2a6 in set_property (opaque=0x5555577122a0, name=0x555556536500 "iothread", value=0x5555565364a0 "io1", errp=0x7fffffffe000) at qdev-monitor.c:180
+ * #6  0x0000555555d66fd7 in qemu_opt_foreach (opts=0x5555565362d0, func=0x55555598f21b <set_property>, opaque=0x5555577122a0, errp=0x7fffffffe000) at util/qemu-option.c:580
+ * #7  0x000055555599071a in qdev_device_add (opts=0x5555565362d0, errp=0x7fffffffe078) at qdev-monitor.c:622
+ * #8  0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362d0, errp=0x0) at vl.c:2275
+ * #9  0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x000055555599dd61 in main (argc=16, argv=0x7fffffffe3e8, envp=0x7fffffffe470) at vl.c:4542
+ *
+ * 是在vl.c main()的如下初始化的设备们的property
+ * 4541     rom_set_order_override(FW_CFG_ORDER_OVERRIDE_DEVICE);
+ * 4542     if (qemu_opts_foreach(qemu_find_opts("device"),
+ * 4543                           device_init_func, NULL, NULL)) {
+ * 4544         exit(1);
+ * 4545     }
+ * 4546 
+ * 4547     cpu_synchronize_all_post_init();
+ */
+
+/*
+ * virtio_blk_properties在初始化时会在virtio_blk_class_init()用作DeviceClass的props
+ * 似乎props是DeviceClass这一级用的
+ *
+ * 所有的props (struct Property)会在device_initfn()中初始化object时插入
+ *
+ *
+ * TypeInfo device_type_info.instance_init = device_initfn()
+ */
 static Property virtio_blk_properties[] = {
     DEFINE_BLOCK_PROPERTIES(VirtIOBlock, conf.conf),
     DEFINE_BLOCK_ERROR_PROPERTIES(VirtIOBlock, conf.conf),
@@ -1028,6 +2027,24 @@ static Property virtio_blk_properties[] = {
     DEFINE_PROP_END_OF_LIST(),
 };
 
+/*
+ * (gdb) bt
+ * #0  virtio_blk_class_init (klass=0x555556598a30, data=0x0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:1033
+ * #1  0x0000555555c1df88 in type_initialize (ti=0x5555564f9e70) at qom/object.c:342
+ * #2  0x0000555555c1f2f8 in object_class_foreach_tramp (key=0x5555564d6230, value=0x5555564f9e70, opaque=0x7fffffffdfc0) at qom/object.c:867
+ * #3  0x00007ffff5e88340 in g_hash_table_foreach () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #4  0x0000555555c1f3d7 in object_class_foreach (fn=0x555555c1f528 <object_class_get_list_tramp>, implements_type=0x555555db81d6 "machine", 
+ *     include_abstract=false, opaque=0x7fffffffe010) at qom/object.c:889
+ * #5  0x0000555555c1f5a6 in object_class_get_list (implements_type=0x555555db81d6 "machine", include_abstract=false) at qom/object.c:943
+ * #6  0x0000555555995b91 in find_default_machine () at vl.c:1417
+ * #7  0x0000555555999a80 in select_machine () at vl.c:2669
+ * #8  0x000055555599c9ab in main (argc=20, argv=0x7fffffffe398, envp=0x7fffffffe440) at vl.c:3988
+ *
+ * TypeInfo virtio_blk_info.class_init = virtio_blk_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void virtio_blk_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(klass);
@@ -1036,16 +2053,155 @@ static void virtio_blk_class_init(ObjectClass *klass, void *data)
     dc->props = virtio_blk_properties;
     dc->vmsd = &vmstate_virtio_blk;
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
+    /*
+     * 设置的地方:
+     *   - hw/block/virtio-blk.c|1435| <<virtio_blk_class_init>> vdc->realize = virtio_blk_device_realize;
+     *   - hw/scsi/virtio-scsi.c|971| <<virtio_scsi_class_init>> vdc->realize = virtio_scsi_device_realize;
+     *   - hw/virtio/virtio-balloon.c|531| <<virtio_balloon_class_init>> vdc->realize = virtio_balloon_device_realize;
+     *   - hw/9pfs/virtio-9p-device.c|246| <<virtio_9p_class_init>> vdc->realize = virtio_9p_device_realize;
+     *   - hw/char/virtio-serial-bus.c|1173| <<virtio_serial_class_init>> vdc->realize = virtio_serial_device_realize;
+     *   - hw/display/virtio-gpu.c|1366| <<virtio_gpu_class_init>> vdc->realize = virtio_gpu_device_realize;
+     *   - hw/input/virtio-input.c|317| <<virtio_input_class_init>> vdc->realize = virtio_input_device_realize;
+     *   - hw/net/virtio-net.c|2212| <<virtio_net_class_init>> vdc->realize = virtio_net_device_realize;
+     *   - hw/virtio/vhost-vsock.c|397| <<vhost_vsock_class_init>> vdc->realize = vhost_vsock_device_realize;
+     *   - hw/virtio/virtio-crypto.c|958| <<virtio_crypto_class_init>> vdc->realize = virtio_crypto_device_realize;
+     *   - hw/block/vhost-user-blk.c|351| <<vhost_user_blk_class_init>> vdc->realize = vhost_user_blk_device_realize;
+     *   - hw/scsi/vhost-scsi.c|252| <<vhost_scsi_class_init>> vdc->realize = vhost_scsi_realize;
+     *   - hw/scsi/vhost-user-scsi.c|188| <<vhost_user_scsi_class_init>> vdc->realize = vhost_user_scsi_realize;
+     *   - hw/virtio/vhost-vsock.c|397| <<vhost_vsock_class_init>> vdc->realize = vhost_vsock_device_realize;
+     *   - hw/virtio/virtio-rng.c|274| <<virtio_rng_class_init>> vdc->realize = virtio_rng_device_realize;
+     *
+     * 调用的地方:
+     *   - hw/virtio/virtio.c|2612| <<virtio_device_realize>> vdc->realize(dev, &err);
+     */
     vdc->realize = virtio_blk_device_realize;
+    /*
+     * called by:
+     *   - hw/virtio/virtio.c|2622| <<virtio_device_realize>> vdc->unrealize(dev, NULL);
+     *   - hw/virtio/virtio.c|2639| <<virtio_device_unrealize>> vdc->unrealize(dev, &err);
+     */
     vdc->unrealize = virtio_blk_device_unrealize;
+    /*
+     * 设置get_config的地方:
+     *   - hw/block/virtio-blk.c|1452| <<virtio_blk_class_init>> vdc->get_config = virtio_blk_update_config;
+     *   - hw/net/virtio-net.c|2214| <<virtio_net_class_init>> vdc->get_config = virtio_net_get_config;
+     *   - hw/scsi/virtio-scsi.c|958| <<virtio_scsi_common_class_init>> vdc->get_config = virtio_scsi_get_config;
+     *   - hw/virtio/virtio-balloon.c|534| <<virtio_balloon_class_init>> vdc->get_config = virtio_balloon_get_config;
+     *   - hw/9pfs/virtio-9p-device.c|249| <<virtio_9p_class_init>> vdc->get_config = virtio_9p_get_config;
+     *   - hw/block/vhost-user-blk.c|353| <<vhost_user_blk_class_init>> vdc->get_config = vhost_user_blk_update_config;
+     *   - hw/char/virtio-serial-bus.c|1176| <<virtio_serial_class_init>> vdc->get_config = get_config;
+     *   - hw/display/virtio-gpu.c|1368| <<virtio_gpu_class_init>> vdc->get_config = virtio_gpu_get_config;
+     *   - hw/input/virtio-input.c|319| <<virtio_input_class_init>> vdc->get_config = virtio_input_get_config;
+     *   - hw/virtio/vhost-vsock.c|400| <<vhost_vsock_class_init>> vdc->get_config = vhost_vsock_get_config;
+     *   - hw/virtio/virtio-crypto.c|960| <<virtio_crypto_class_init>> vdc->get_config = virtio_crypto_get_config;
+     *
+     * 调用get_config的地方:
+     *   - hw/virtio/virtio-bus.c|195| <<virtio_bus_get_vdev_config>> k->get_config(vdev, config);
+     *   - hw/virtio/virtio.c|1238| <<virtio_config_readb>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1253| <<virtio_config_readw>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1268| <<virtio_config_readl>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1331| <<virtio_config_modern_readb>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1346| <<virtio_config_modern_readw>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1361| <<virtio_config_modern_readl>> k->get_config(vdev, vdev->config);
+     */
     vdc->get_config = virtio_blk_update_config;
+    /*
+     * 设置set_config的地方:
+     *   - hw/block/virtio-blk.c|1463| <<virtio_blk_class_init>> vdc->set_config = virtio_blk_set_config;
+     *   - hw/net/virtio-net.c|2215| <<virtio_net_class_init>> vdc->set_config = virtio_net_set_config;
+     *   - hw/scsi/virtio-scsi.c|973| <<virtio_scsi_class_init>> vdc->set_config = virtio_scsi_set_config;
+     *   - hw/virtio/virtio-balloon.c|535| <<virtio_balloon_class_init>> vdc->set_config = virtio_balloon_set_config;
+     *   - hw/char/virtio-serial-bus.c|1177| <<virtio_serial_class_init>> vdc->set_config = set_config;
+     *   - hw/block/vhost-user-blk.c|354| <<vhost_user_blk_class_init>> vdc->set_config = vhost_user_blk_set_config;
+     *   - hw/display/virtio-gpu.c|1369| <<virtio_gpu_class_init>> vdc->set_config = virtio_gpu_set_config;
+     *   - hw/input/virtio-input.c|320| <<virtio_input_class_init>> vdc->set_config = virtio_input_set_config;
+     *   - hw/scsi/vhost-scsi.c|255| <<vhost_scsi_class_init>> vdc->set_config = vhost_scsi_common_set_config;
+     *   - hw/scsi/vhost-user-scsi.c|191| <<vhost_user_scsi_class_init>> vdc->set_config = vhost_scsi_common_set_config;
+     *
+     * 调用set_config的地方:
+     *   - hw/virtio/virtio-bus.c|208| <<virtio_bus_set_vdev_config>> k->set_config(vdev, config);
+     *   - hw/virtio/virtio.c|1881| <<virtio_config_writeb>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1902| <<virtio_config_writew>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1923| <<virtio_config_writel>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|2001| <<virtio_config_modern_writeb>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|2022| <<virtio_config_modern_writew>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|2043| <<virtio_config_modern_writel>> k->set_config(vdev, vdev->config);
+     */
     vdc->set_config = virtio_blk_set_config;
+    /*
+     * called only by:
+     *   - hw/virtio/virtio-bus.c|99| <<virtio_bus_device_plugged>> vdev->host_features = vdc->get_features(vdev, vdev->host_features,
+     */
     vdc->get_features = virtio_blk_get_features;
+    /*
+     * called only by:
+     *   - hw/virtio/virtio.c|1158| <<virtio_set_status>> k->set_status(vdev, val);
+     *
+     * 设置的地方:
+     *   - hw/block/virtio-blk.c|1469| <<virtio_blk_class_init>> vdc->set_status = virtio_blk_set_status;
+     *   - hw/block/vhost-user-blk.c|356| <<vhost_user_blk_class_init>> vdc->set_status = vhost_user_blk_set_status;
+     *   - hw/char/virtio-serial-bus.c|1178| <<virtio_serial_class_init>> vdc->set_status = set_status;
+     *   - hw/input/virtio-input.c|322| <<virtio_input_class_init>> vdc->set_status = virtio_input_set_status;
+     *   - hw/net/virtio-net.c|2220| <<virtio_net_class_init>> vdc->set_status = virtio_net_set_status;
+     *   - hw/scsi/vhost-scsi.c|256| <<vhost_scsi_class_init>> vdc->set_status = vhost_scsi_set_status;
+     *   - hw/scsi/vhost-user-scsi.c|192| <<vhost_user_scsi_class_init>> vdc->set_status = vhost_user_scsi_set_status;
+     *   - hw/virtio/vhost-vsock.c|401| <<vhost_vsock_class_init>> vdc->set_status = vhost_vsock_set_status;
+     *   - hw/virtio/virtio-balloon.c|537| <<virtio_balloon_class_init>> vdc->set_status = virtio_balloon_set_status;
+     *   - hw/virtio/virtio-crypto.c|963| <<virtio_crypto_class_init>> vdc->set_status = virtio_crypto_set_status;
+     *   - hw/virtio/virtio-rng.c|277| <<virtio_rng_class_init>> vdc->set_status = virtio_rng_set_status;
+     *
+     * 唯一调用的地方:
+     *   - hw/virtio/virtio.c|1652| <<virtio_set_status>> k->set_status(vdev, val);
+     */
     vdc->set_status = virtio_blk_set_status;
+    /*
+     * called only by:
+     *   - hw/virtio/virtio.c|1201| <<virtio_reset>> k->reset(vdev);
+     *
+     * 在以下被设置:
+     *   - hw/block/virtio-blk.c|1490| <<virtio_blk_class_init>> vdc->reset = virtio_blk_reset;
+     *   - hw/net/virtio-net.c|2219| <<virtio_net_class_init>> vdc->reset = virtio_net_reset;
+     *   - hw/scsi/virtio-scsi.c|975| <<virtio_scsi_class_init>> vdc->reset = virtio_scsi_reset;
+     *   - hw/virtio/virtio-balloon.c|533| <<virtio_balloon_class_init>> vdc->reset = virtio_balloon_device_reset;
+     *   - hw/virtio/virtio-crypto.c|962| <<virtio_crypto_class_init>> vdc->reset = virtio_crypto_reset;
+     *   - hw/char/virtio-serial-bus.c|1179| <<virtio_serial_class_init>> vdc->reset = vser_reset;
+     *   - hw/display/virtio-gpu.c|1373| <<virtio_gpu_class_init>> vdc->reset = virtio_gpu_reset;
+     *   - hw/9pfs/virtio-9p-device.c|250| <<virtio_9p_class_init>> vdc->reset = virtio_9p_reset;
+     *   - hw/input/virtio-input.c|323| <<virtio_input_class_init>> vdc->reset = virtio_input_reset;
+     *
+     * 在以下被调用:
+     *   - hw/virtio/virtio.c|1761| <<virtio_reset>> k->reset(vdev);
+     */
     vdc->reset = virtio_blk_reset;
+    /*
+     * called only by:
+     *   - hw/virtio/virtio.c|1957| <<virtio_save>> vdc->save(vdev, f);
+     */
     vdc->save = virtio_blk_save_device;
+    /*
+     * called only by:
+     *   - hw/virtio/virtio.c|2106| <<virtio_load>> ret = vdc->load(vdev, f, version_id);
+     */
     vdc->load = virtio_blk_load_device;
+    /*
+     * called only by:
+     *   - hw/virtio/virtio-bus.c|296| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+     *
+     * used by:
+     *   - hw/block/virtio-blk.c|1111| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start; --> block用
+     *   - hw/scsi/virtio-scsi.c|976| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+     *   - hw/virtio/virtio.c|2799| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl; --> 网络用
+     */
     vdc->start_ioeventfd = virtio_blk_data_plane_start;
+    /*
+     * called only by:
+     *   - hw/virtio/virtio-bus.c|319| <<virtio_bus_stop_ioeventfd>> vdc->stop_ioeventfd(vdev);
+     *
+     * used by: 
+     *   - hw/block/virtio-blk.c|1112| <<virtio_blk_class_init>> vdc->stop_ioeventfd = virtio_blk_data_plane_stop;
+     *   - hw/scsi/virtio-scsi.c|977| <<virtio_scsi_class_init>> vdc->stop_ioeventfd = virtio_scsi_dataplane_stop;
+     *   - hw/virtio/virtio.c|2800| <<virtio_device_class_init>> vdc->stop_ioeventfd = virtio_device_stop_ioeventfd_impl;
+     */
     vdc->stop_ioeventfd = virtio_blk_data_plane_stop;
 }
 
@@ -1059,7 +2215,12 @@ static const TypeInfo virtio_blk_info = {
 
 static void virtio_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&virtio_blk_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(virtio_register_types)
diff --git a/hw/core/bus.c b/hw/core/bus.c
index 4651f24..f9fbbf3 100644
--- a/hw/core/bus.c
+++ b/hw/core/bus.c
@@ -40,6 +40,12 @@ void qbus_set_bus_hotplug_handler(BusState *bus, Error **errp)
     qbus_set_hotplug_handler_internal(bus, OBJECT(bus), errp);
 }
 
+/*
+ * x86会用到的:
+ *   - hw/core/qdev.c|202| <<device_listener_register>> qbus_walk_children(sysbus_get_default(), NULL, NULL, device_listener_add,
+ *   - hw/core/qdev.c|276| <<qbus_reset_all>> qbus_walk_children(bus, NULL, NULL, qdev_reset_one, qbus_reset_one, NULL);
+ *   - hw/core/qdev.c|559| <<qdev_walk_children>> err = qbus_walk_children(bus, pre_devfn, pre_busfn,
+ */
 int qbus_walk_children(BusState *bus,
                        qdev_walkerfn *pre_devfn, qbus_walkerfn *pre_busfn,
                        qdev_walkerfn *post_devfn, qbus_walkerfn *post_busfn,
@@ -74,6 +80,11 @@ int qbus_walk_children(BusState *bus,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/core/bus.c|136| <<qbus_create_inplace>> qbus_realize(bus, parent, name);
+ *   - hw/core/bus.c|144| <<qbus_create>> qbus_realize(bus, parent, name);
+ */
 static void qbus_realize(BusState *bus, DeviceState *parent, const char *name)
 {
     const char *typename = object_get_typename(OBJECT(bus));
@@ -132,20 +143,49 @@ static void bus_unparent(Object *obj)
 void qbus_create_inplace(void *bus, size_t size, const char *typename,
                          DeviceState *parent, const char *name)
 {
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 根据TypeImpl初始化data(void *bus)头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     object_initialize(bus, size, typename);
+    /*
+     * 其中会把bus->parent=parent
+     */
     qbus_realize(bus, parent, name);
 }
 
+/*
+ * called by:
+ *   - hw/i2c/core.c|59| <<i2c_init_bus>> bus = I2C_BUS(qbus_create(TYPE_I2C_BUS, parent, name));
+ *   - hw/isa/isa-bus.c|66| <<isa_bus_new>> isabus = ISA_BUS(qbus_create(TYPE_ISA_BUS, dev, NULL));
+ *   - hw/misc/auxbus.c|69| <<aux_init_bus>> bus = AUX_BUS(qbus_create(TYPE_AUX_BUS, parent, name));
+ *   - hw/pci/pci.c|410| <<pci_root_bus_new>> bus = PCI_BUS(qbus_create(typename, parent, name));
+ *   - hw/ppc/spapr_vio.c|558| <<spapr_vio_bus_init>> qbus = qbus_create(TYPE_SPAPR_VIO_BUS, dev, "spapr-vio");
+ *   - hw/s390x/css-bridge.c|107| <<virtual_css_bus_init>> bus = qbus_create(TYPE_VIRTUAL_CSS_BUS, dev, "virtual-css");
+ *   - hw/s390x/s390-pci-bus.c|714| <<s390_pcihost_init>> s->bus = S390_PCI_BUS(qbus_create(TYPE_S390_PCI_BUS, DEVICE(s), NULL));
+ *   - hw/ssi/ssi.c|106| <<ssi_create_bus>> bus = qbus_create(TYPE_SSI_BUS, parent, name);
+ *   - hw/xen/xen_backend.c|700| <<xen_be_init>> xen_sysbus = qbus_create(TYPE_XENSYSBUS, DEVICE(xen_sysdev), "xen-sysbus");
+ */
 BusState *qbus_create(const char *typename, DeviceState *parent, const char *name)
 {
     BusState *bus;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     bus = BUS(object_new(typename));
     qbus_realize(bus, parent, name);
 
     return bus;
 }
 
+/*
+ * 只在qbus_initfn():
+ * 242     object_property_add_bool(obj, "realized",
+ * 243                              bus_get_realized, bus_set_realized, NULL);
+ */
 static bool bus_get_realized(Object *obj, Error **errp)
 {
     BusState *bus = BUS(obj);
@@ -153,6 +193,11 @@ static bool bus_get_realized(Object *obj, Error **errp)
     return bus->realized;
 }
 
+/*
+ * 只在qbus_initfn():
+ * 242     object_property_add_bool(obj, "realized",
+ * 243                              bus_get_realized, bus_set_realized, NULL);
+ */
 static void bus_set_realized(Object *obj, bool value, Error **errp)
 {
     BusState *bus = BUS(obj);
@@ -188,6 +233,9 @@ static void bus_set_realized(Object *obj, bool value, Error **errp)
     bus->realized = value;
 }
 
+/*
+ * TypeInfo bus_info.instance_init = qbus_initfn()
+ */
 static void qbus_initfn(Object *obj)
 {
     BusState *bus = BUS(obj);
@@ -199,6 +247,15 @@ static void qbus_initfn(Object *obj)
                              object_property_allow_set_link,
                              0,
                              NULL);
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 3140  * 然后插入Object->properties (GHashTable)
+     * 3141  *     get     = property_get_bool()
+     * 3142  *     set     = property_set_bool()
+     * 3143  *     release = property_release_bool()
+     *
+     * bus_get_realized()和bus_set_realized()是BoolProperty的get和set方法
+     */
     object_property_add_bool(obj, "realized",
                              bus_get_realized, bus_set_realized, NULL);
 }
@@ -208,14 +265,24 @@ static char *default_bus_get_fw_dev_path(DeviceState *dev)
     return g_strdup(object_get_typename(OBJECT(dev)));
 }
 
+/*
+ * TypeInfo bus_info.class_init = bus_class_init()
+ */
 static void bus_class_init(ObjectClass *class, void *data)
 {
     BusClass *bc = BUS_CLASS(class);
 
+    /*
+     * Called when an object is being removed from the QOM composition tree.
+     * The function should remove any backlinks from children objects to @obj.
+     */
     class->unparent = bus_unparent;
     bc->get_fw_dev_path = default_bus_get_fw_dev_path;
 }
 
+/*
+ * TypeInfo bus_info.instance_finalize = qbus_finalize()
+ */
 static void qbus_finalize(Object *obj)
 {
     BusState *bus = BUS(obj);
@@ -229,14 +296,35 @@ static const TypeInfo bus_info = {
     .instance_size = sizeof(BusState),
     .abstract = true,
     .class_size = sizeof(BusClass),
+    /*
+     * called only by:
+     *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+     */
     .instance_init = qbus_initfn,
+    /*
+     * called only by:
+     *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+     */
     .instance_finalize = qbus_finalize,
+    /*
+     * called only by:
+     *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+     */
     .class_init = bus_class_init,
 };
 
 static void bus_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&bus_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(bus_register_types)
diff --git a/hw/core/irq.c b/hw/core/irq.c
index b98d1d6..16c5776 100644
--- a/hw/core/irq.c
+++ b/hw/core/irq.c
@@ -42,6 +42,68 @@ void qemu_set_irq(qemu_irq irq, int level)
     if (!irq)
         return;
 
+    /*
+     * 其中一个例子是: kvm_pc_gsi_handler()
+     * (gdb) bt
+     * #0  qemu_set_irq (irq=0x5555569fb240, level=1) at hw/core/irq.c:42
+     * #1  0x0000555555b2ec42 in piix3_set_irq_pic (piix3=0x5555571ccf50, pic_irq=11) at hw/pci-host/piix.c:455
+     * #2  0x0000555555b2ed3d in piix3_set_irq_level (piix3=0x5555571ccf50, pirq=2, level=1) at hw/pci-host/piix.c:487
+     * #3  0x0000555555b2ed70 in piix3_set_irq (opaque=0x5555571ccf50, pirq=2, level=1) at hw/pci-host/piix.c:493
+     * #4  0x0000555555b32997 in pci_change_irq_level (pci_dev=0x7fffe765e010, irq_num=2, change=1) at hw/pci/pci.c:234
+     * #5  0x0000555555b359b4 in pci_irq_handler (opaque=0x7fffe765e010, irq_num=0, level=1) at hw/pci/pci.c:1406
+     * #6  0x0000555555b35a49 in pci_set_irq (pci_dev=0x7fffe765e010, level=1) at hw/pci/pci.c:1424
+     * #7  0x0000555555af30cc in set_interrupt_cause (s=0x7fffe765e010, index=0, val=16) at hw/net/e1000.c:329
+     * #8  0x0000555555af3154 in set_ics (s=0x7fffe765e010, index=50, val=16) at hw/net/e1000.c:347
+     * #9  0x0000555555af5687 in e1000_mmio_write (opaque=0x7fffe765e010, addr=200, val=16, size=4) at hw/net/e1000.c:1277
+     * #10 0x0000555555864b2d in memory_region_write_accessor (mr=0x7fffe7660910, addr=200, value=0x7fffe7ffe7e8, size=4, shift=0, mask=4294967295, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+     * #11 0x0000555555864d45 in access_with_adjusted_size (addr=200, value=0x7fffe7ffe7e8, size=4, access_size_min=4, access_size_max=4, access_fn=0x555555864a43
+     *     <memory_region_write_accessor>, mr=0x7fffe7660910, 
+     *     attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+     * #12 0x000055555586796d in memory_region_dispatch_write (mr=0x7fffe7660910, addr=200, data=16, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+     * #13 0x000055555580399f in flatview_write_continue (fv=0x7fffe02bd1b0, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4, addr1=200, l=4, mr=0x7fffe7660910)
+     *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+     * #14 0x0000555555803ae9 in flatview_write (fv=0x7fffe02bd1b0, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+     * #15 0x0000555555803def in address_space_write (as=0x555556721a80 <address_space_memory>, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+     * #16 0x0000555555803e40 in address_space_rw (as=0x555556721a80 <address_space_memory>, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4, is_write=true)
+     *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+     * #17 0x0000555555882b7d in kvm_cpu_exec (cpu=0x5555568d7d60) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1979
+     * #18 0x0000555555849eac in qemu_kvm_cpu_thread_fn (arg=0x5555568d7d60) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+     * #19 0x0000555555d92dd7 in qemu_thread_start (args=0x5555568f99c0) at util/qemu-thread-posix.c:504
+     * #20 0x00007ffff4ca06ba in start_thread (arg=0x7fffe7fff700) at pthread_create.c:333
+     * #21 0x00007ffff49d641d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+     *
+     * 在一次调用第二次进来的例子成了: kvm_pic_set_irq()
+     * (gdb) bt
+     * #0  kvm_pic_set_irq (opaque=0x0, irq=11, level=1) at /home/zhang/kvm/qemu-3.0.0/hw/i386/kvm/i8259.c:114
+     * #1  0x0000555555a788de in qemu_set_irq (irq=0x55555728b750, level=1) at hw/core/irq.c:45
+     * #2  0x000055555594300b in kvm_pc_gsi_handler (opaque=0x5555569f88a0, n=11, level=1) at /home/zhang/kvm/qemu-3.0.0/hw/i386/kvm/ioapic.c:55
+     * #3  0x0000555555a788de in qemu_set_irq (irq=0x5555569fb240, level=1) at hw/core/irq.c:45
+     * #4  0x0000555555b2ec42 in piix3_set_irq_pic (piix3=0x5555571ccf50, pic_irq=11) at hw/pci-host/piix.c:455
+     * #5  0x0000555555b2ed3d in piix3_set_irq_level (piix3=0x5555571ccf50, pirq=2, level=1) at hw/pci-host/piix.c:487
+     * #6  0x0000555555b2ed70 in piix3_set_irq (opaque=0x5555571ccf50, pirq=2, level=1) at hw/pci-host/piix.c:493
+     * #7  0x0000555555b32997 in pci_change_irq_level (pci_dev=0x7fffe765e010, irq_num=2, change=1) at hw/pci/pci.c:234
+     * #8  0x0000555555b359b4 in pci_irq_handler (opaque=0x7fffe765e010, irq_num=0, level=1) at hw/pci/pci.c:1406
+     * #9  0x0000555555b35a49 in pci_set_irq (pci_dev=0x7fffe765e010, level=1) at hw/pci/pci.c:1424
+     * #10 0x0000555555af30cc in set_interrupt_cause (s=0x7fffe765e010, index=0, val=16) at hw/net/e1000.c:329
+     * #11 0x0000555555af3154 in set_ics (s=0x7fffe765e010, index=50, val=16) at hw/net/e1000.c:347
+     * #12 0x0000555555af5687 in e1000_mmio_write (opaque=0x7fffe765e010, addr=200, val=16, size=4) at hw/net/e1000.c:1277
+     * #13 0x0000555555864b2d in memory_region_write_accessor (mr=0x7fffe7660910, addr=200, value=0x7fffe7ffe7e8, size=4, shift=0, mask=4294967295, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+     * #14 0x0000555555864d45 in access_with_adjusted_size (addr=200, value=0x7fffe7ffe7e8, size=4, access_size_min=4, access_size_max=4, access_fn=0x555555864a43 <memory_region_write_accessor>,
+     *     mr=0x7fffe7660910, 
+     *     attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+     * #15 0x000055555586796d in memory_region_dispatch_write (mr=0x7fffe7660910, addr=200, data=16, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+     * #16 0x000055555580399f in flatview_write_continue (fv=0x7fffe02bd1b0, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4, addr1=200, l=4, mr=0x7fffe7660910)
+     *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+     * #17 0x0000555555803ae9 in flatview_write (fv=0x7fffe02bd1b0, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+     * #18 0x0000555555803def in address_space_write (as=0x555556721a80 <address_space_memory>, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+     * #19 0x0000555555803e40 in address_space_rw (as=0x555556721a80 <address_space_memory>, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4, is_write=true)
+     *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+     * #20 0x0000555555882b7d in kvm_cpu_exec (cpu=0x5555568d7d60) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1979
+     * #21 0x0000555555849eac in qemu_kvm_cpu_thread_fn (arg=0x5555568d7d60) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+     * #22 0x0000555555d92dd7 in qemu_thread_start (args=0x5555568f99c0) at util/qemu-thread-posix.c:504
+     * #23 0x00007ffff4ca06ba in start_thread (arg=0x7fffe7fff700) at pthread_create.c:333
+     * #24 0x00007ffff49d641d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+     */
     irq->handler(irq->opaque, irq->n, level);
 }
 
diff --git a/hw/core/machine.c b/hw/core/machine.c
index a9aeb22..0c1d666 100644
--- a/hw/core/machine.c
+++ b/hw/core/machine.c
@@ -22,6 +22,11 @@
 #include "qemu/error-report.h"
 #include "sysemu/qtest.h"
 
+/*
+ * used by machine_class_init():
+ *   548     object_class_property_add_str(oc, "accel",
+ *   549         machine_get_accel, machine_set_accel, &error_abort);
+ */
 static char *machine_get_accel(Object *obj, Error **errp)
 {
     MachineState *ms = MACHINE(obj);
@@ -29,6 +34,11 @@ static char *machine_get_accel(Object *obj, Error **errp)
     return g_strdup(ms->accel);
 }
 
+/*
+ * used by machine_class_init():
+ *   548     object_class_property_add_str(oc, "accel",
+ *   549         machine_get_accel, machine_set_accel, &error_abort);
+ */
 static void machine_set_accel(Object *obj, const char *value, Error **errp)
 {
     MachineState *ms = MACHINE(obj);
@@ -37,6 +47,16 @@ static void machine_set_accel(Object *obj, const char *value, Error **errp)
     ms->accel = g_strdup(value);
 }
 
+/*
+ * used by machine_class_init():
+ *   545     object_class_property_add(oc, "kernel-irqchip", "on|off|split",
+ *   546         NULL, machine_set_kernel_irqchip, 
+ *   547         NULL, NULL, &error_abort);
+ *
+ * on: KVM 模拟全部
+ * split: QEMU模拟IOAPIC和PIC,KVM模拟LAPIC
+ * off: QEMU 模拟全部            
+ */
 static void machine_set_kernel_irqchip(Object *obj, Visitor *v,
                                        const char *name, void *opaque,
                                        Error **errp)
@@ -517,6 +537,12 @@ void machine_set_cpu_numa_node(MachineState *machine,
     }
 }
 
+/*
+ * TypeInfo machine_info.class_init = machine_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
@@ -636,6 +662,12 @@ static void machine_class_init(ObjectClass *oc, void *data)
         "Set memory encyption object to use", &error_abort);
 }
 
+/*
+ * TypeInfo machine_info.class_base_init = machine_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void machine_class_base_init(ObjectClass *oc, void *data)
 {
     if (!object_class_is_abstract(oc)) {
@@ -647,6 +679,12 @@ static void machine_class_base_init(ObjectClass *oc, void *data)
     }
 }
 
+/*
+ * TypeInfo machine_info.instance_init = machine_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+ */
 static void machine_initfn(Object *obj)
 {
     MachineState *ms = MACHINE(obj);
@@ -662,6 +700,12 @@ static void machine_initfn(Object *obj)
     qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);
 }
 
+/*
+ * TypeInfo machine_info.instance_finalize = machine_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void machine_finalize(Object *obj)
 {
     MachineState *ms = MACHINE(obj);
@@ -788,6 +832,12 @@ static void machine_numa_finish_cpu_init(MachineState *machine)
     g_string_free(s, true);
 }
 
+/*
+ * called only by:
+ *   - vl.c|4516| <<main>> machine_run_board_init(current_machine);
+ *
+ * 最主要的是调用MachineClass的init()
+ */
 void machine_run_board_init(MachineState *machine)
 {
     MachineClass *machine_class = MACHINE_GET_CLASS(machine);
@@ -804,6 +854,12 @@ void machine_run_board_init(MachineState *machine)
         int i;
 
         for (i = 0; machine_class->valid_cpu_types[i]; i++) {
+            /*
+	     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+	     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+	     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+	     */
             if (object_class_dynamic_cast(class,
                                           machine_class->valid_cpu_types[i])) {
                 /* The user specificed CPU is in the valid field, we are
@@ -827,9 +883,79 @@ void machine_run_board_init(MachineState *machine)
         }
     }
 
+    /*
+     * (gdb) p *machine_class
+     * $3 = {
+     *   parent_class = {
+     *     type = 0x555556785020, 
+     *     interfaces = 0x555556827780, 
+     *     object_cast_cache = {0x555555ea72b8 "generic-pc-machine", 0x555555ebd4f6 "machine", 0x555555eb8280 "generic-pc-machine", 0x555555f427bd "machine"}, 
+     *     class_cast_cache = {0x555555ea870d "generic-pc-machine", 0x555555e9299a "machine", 0x555555ee2032 "machine", 0x555555e8e912 "machine"}, 
+     *     unparent = 0x0, 
+     *     properties = 0x555556834300
+     *   }, 
+     *   family = 0x555555ea889e "pc_piix", 
+     *   name = 0x555556836d90 "pc-i440fx-3.0", 
+     *   alias = 0x555555ea88c7 "pc", 
+     *   desc = 0x555555ea8788 "Standard PC (i440FX + PIIX, 1996)", 
+     *   deprecation_reason = 0x0, 
+     *   init = 0x55555591d9e4 <pc_init_v3_0>, 
+     *   reset = 0x55555591bfcd <pc_machine_reset>, 
+     *   hot_add_cpu = 0x55555591851d <pc_hot_add_cpu>, 
+     *   kvm_type = 0x0, 
+     *   block_default_type = IF_IDE, 
+     *   units_per_default_bus = 0, 
+     *   max_cpus = 255, 
+     *   min_cpus = 1, 
+     *   default_cpus = 1, 
+     *   no_serial = 0, 
+     *   no_parallel = 0, 
+     *   use_virtcon = 0, 
+     *   no_floppy = 0, 
+     *   no_cdrom = 0, 
+     *   no_sdcard = 0, 
+     *   pci_allow_0_address = 0, 
+     *   legacy_fw_cfg_order = 0, 
+     *   is_default = 1, 
+     *   default_machine_opts = 0x555555ea88a6 "firmware=bios-256k.bin", 
+     *   default_boot_order = 0x555555ea7de8 "cad", 
+     *   default_display = 0x555555ea88bd "std", 
+     *   compat_props = 0x0, 
+     *   hw_version = 0x0, 
+     *   default_ram_size = 134217728, 
+     *   default_cpu_type = 0x555555ea7dec "qemu64-x86_64-cpu", 
+     *   option_rom_has_mr = false, 
+     *   rom_file_has_mr = true, 
+     *   minimum_page_bits = 0, 
+     *   has_hotpluggable_cpus = true, 
+     *   ignore_memory_transaction_failures = false, 
+     *   numa_mem_align_shift = 23, 
+     *   valid_cpu_types = 0x0, 
+     *   allowed_dynamic_sysbus_devices = 0x555556836db0, 
+     *   auto_enable_numa_with_memhp = true, 
+     *   numa_auto_assign_ram = 0x55555585eed8 <numa_default_auto_assign_ram>, 
+     *   get_hotplug_handler = 0x55555591b5fe <pc_get_hotpug_handler>, 
+     *   cpu_index_to_instance_props = 0x55555591c04d <pc_cpu_index_to_props>, 
+     *   possible_cpu_arch_ids = 0x55555591c1fd <pc_possible_cpu_arch_ids>, 
+     *  get_default_cpu_node_id = 0x55555591c138 <pc_get_default_cpu_node_id>
+     * }
+     */
+
+    /*
+     * init是在DEFINE_PC_MACHINE()初始化的
+     */
+
     machine_class->init(machine);
 }
 
+/*
+ * TypeInfo machine_info.class_finalize = machine_class_finalize()
+ *
+ * 似乎目前不调用:
+ *   - hw/core/machine.c|868| <<global>> .class_finalize = machine_class_finalize,
+ *   - qom/object.c|69| <<global>> void (*class_finalize)(ObjectClass *klass, void *data);
+ *   - qom/object.c|179| <<type_new>> ti->class_finalize = info->class_finalize;
+ */
 static void machine_class_finalize(ObjectClass *klass, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(klass);
@@ -840,6 +966,9 @@ static void machine_class_finalize(ObjectClass *klass, void *data)
     g_free(mc->name);
 }
 
+/*
+ * called only by register_global_properties() in vl.c
+ */
 void machine_register_compat_props(MachineState *machine)
 {
     MachineClass *mc = MACHINE_GET_CLASS(machine);
@@ -859,7 +988,7 @@ void machine_register_compat_props(MachineState *machine)
 }
 
 static const TypeInfo machine_info = {
-    .name = TYPE_MACHINE,
+    .name = TYPE_MACHINE,  // 还有孩子TYPE_PC_MACHINE
     .parent = TYPE_OBJECT,
     .abstract = true,
     .class_size = sizeof(MachineClass),
@@ -873,7 +1002,16 @@ static const TypeInfo machine_info = {
 
 static void machine_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&machine_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(machine_register_types)
diff --git a/hw/core/qdev-fw.c b/hw/core/qdev-fw.c
index aa35e9d..ea88689 100644
--- a/hw/core/qdev-fw.c
+++ b/hw/core/qdev-fw.c
@@ -30,6 +30,10 @@ const char *qdev_fw_name(DeviceState *dev)
     return object_get_typename(OBJECT(dev));
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev-fw.c|72| <<qdev_get_fw_dev_path_helper>> d = bus_get_fw_dev_path(dev->parent_bus, dev);
+ */
 static char *bus_get_fw_dev_path(BusState *bus, DeviceState *dev)
 {
     BusClass *bc = BUS_GET_CLASS(bus);
@@ -60,6 +64,11 @@ char *qdev_get_own_fw_dev_path_from_handler(BusState *bus, DeviceState *dev)
     return fw_path_provider_try_get_dev_path(obj, bus, dev);
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev-fw.c|69| <<qdev_get_fw_dev_path_helper>> l = qdev_get_fw_dev_path_helper(dev->parent_bus->parent, p, size);
+ *   - hw/core/qdev-fw.c|91| <<qdev_get_fw_dev_path>> l = qdev_get_fw_dev_path_helper(dev, path, 128);
+ */
 static int qdev_get_fw_dev_path_helper(DeviceState *dev, char *p, int size)
 {
     int l = 0;
@@ -83,6 +92,10 @@ static int qdev_get_fw_dev_path_helper(DeviceState *dev, char *p, int size)
     return l;
 }
 
+/*
+ * called only by:
+ *   - bootdevice.c|224| <<get_boot_devices_list>> devpath = qdev_get_fw_dev_path(i->dev);
+ */
 char *qdev_get_fw_dev_path(DeviceState *dev)
 {
     char path[128];
diff --git a/hw/core/qdev-properties-system.c b/hw/core/qdev-properties-system.c
index 8b22fb5..f45a4c8 100644
--- a/hw/core/qdev-properties-system.c
+++ b/hw/core/qdev-properties-system.c
@@ -69,6 +69,29 @@ static void set_pointer(Object *obj, Visitor *v, Property *prop,
 
 /* --- drive --- */
 
+/*
+ * virtio block初始化的例子:
+ * (gdb) bt
+ * #0  parse_drive (dev=0x5555579da580, str=0x5555579df130 "drive-virtio-disk0", ptr=0x5555579da730, propname=0x555555eb77f4 "drive", errp=0x7fffffffdf48) at hw/core/qdev-properties-system.c:76
+ * #1  0x0000555555a8af50 in set_pointer (obj=0x5555579da580, v=0x5555579df270, prop=0x55555659d360 <virtio_blk_properties>, parse=0x555555a8af72 <parse_drive>,
+ *     name=0x5555579dc410 "drive", errp=0x7fffffffdf48)
+ *     at hw/core/qdev-properties-system.c:66
+ * #2  0x0000555555a8b2c5 in set_drive (obj=0x5555579da580, v=0x5555579df270, name=0x5555579dc410 "drive", opaque=0x55555659d360 <virtio_blk_properties>, errp=0x7fffffffdf48)
+ *     at hw/core/qdev-properties-system.c:160
+ * #3  0x0000555555c7ffa0 in object_property_set (obj=0x5555579da580, v=0x5555579df270, name=0x5555579dc410 "drive", errp=0x7fffffffdf48) at qom/object.c:1176
+ * #4  0x0000555555c82b45 in property_set_alias (obj=0x5555579d2410, v=0x5555579df270, name=0x5555567f3a50 "drive", opaque=0x5555579dc3f0, errp=0x7fffffffdf48) at qom/object.c:2330
+ * #5  0x0000555555c7ffa0 in object_property_set (obj=0x5555579d2410, v=0x5555579df270, name=0x5555567f3a50 "drive", errp=0x7fffffffdf48) at qom/object.c:1176
+ * #6  0x0000555555c809bf in object_property_parse (obj=0x5555579d2410, string=0x5555567f39f0 "drive-virtio-disk0", name=0x5555567f3a50 "drive", errp=0x7fffffffdf48) at qom/object.c:1402
+ * #7  0x00005555559d798e in set_property (opaque=0x5555579d2410, name=0x5555567f3a50 "drive", value=0x5555567f39f0 "drive-virtio-disk0", errp=0x7fffffffdfd0) at qdev-monitor.c:180
+ * #8  0x0000555555dc83e9 in qemu_opt_foreach (opts=0x5555567f3920, func=0x5555559d7903 <set_property>, opaque=0x5555579d2410, errp=0x7fffffffdfd0) at util/qemu-option.c:580
+ * #9  0x00005555559d8e02 in qdev_device_add (opts=0x5555567f3920, errp=0x7fffffffe048) at qdev-monitor.c:622
+ * #10 0x00005555559e12b8 in device_init_func (opaque=0x0, opts=0x5555567f3920, errp=0x0) at vl.c:2275
+ * #11 0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b76c0 <qemu_device_opts>, func=0x5555559e127a <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #12 0x00005555559e6449 in main (argc=16, argv=0x7fffffffe3b8, envp=0x7fffffffe440) at vl.c:4542
+ *
+ * called by only:
+ *   - hw/core/qdev-properties-system.c|160| <<set_drive>> set_pointer(obj, v, opaque, parse_drive, name, errp);
+ */
 static void parse_drive(DeviceState *dev, const char *str, void **ptr,
                         const char *propname, Error **errp)
 {
@@ -154,6 +177,49 @@ static void get_drive(Object *obj, Visitor *v, const char *name, void *opaque,
     get_pointer(obj, v, opaque, print_drive, name, errp);
 }
 
+/*
+ * virtio block初始化的时候:
+ * (gdb) bt
+ * #0  set_drive (obj=0x5555579da580, v=0x5555579df270, name=0x5555579dc410 "drive", opaque=0x55555659d360 <virtio_blk_properties>, errp=0x7fffffffdf48) at hw/core/qdev-properties-system.c:160
+ * #1  0x0000555555c7ffa0 in object_property_set (obj=0x5555579da580, v=0x5555579df270, name=0x5555579dc410 "drive", errp=0x7fffffffdf48) at qom/object.c:1176
+ * #2  0x0000555555c82b45 in property_set_alias (obj=0x5555579d2410, v=0x5555579df270, name=0x5555567f3a50 "drive", opaque=0x5555579dc3f0, errp=0x7fffffffdf48) at qom/object.c:2330
+ * #3  0x0000555555c7ffa0 in object_property_set (obj=0x5555579d2410, v=0x5555579df270, name=0x5555567f3a50 "drive", errp=0x7fffffffdf48) at qom/object.c:1176
+ * #4  0x0000555555c809bf in object_property_parse (obj=0x5555579d2410, string=0x5555567f39f0 "drive-virtio-disk0", name=0x5555567f3a50 "drive", errp=0x7fffffffdf48) at qom/object.c:1402
+ * #5  0x00005555559d798e in set_property (opaque=0x5555579d2410, name=0x5555567f3a50 "drive", value=0x5555567f39f0 "drive-virtio-disk0", errp=0x7fffffffdfd0) at qdev-monitor.c:180
+ * #6  0x0000555555dc83e9 in qemu_opt_foreach (opts=0x5555567f3920, func=0x5555559d7903 <set_property>, opaque=0x5555579d2410, errp=0x7fffffffdfd0) at util/qemu-option.c:580
+ * #7  0x00005555559d8e02 in qdev_device_add (opts=0x5555567f3920, errp=0x7fffffffe048) at qdev-monitor.c:622
+ * #8  0x00005555559e12b8 in device_init_func (opaque=0x0, opts=0x5555567f3920, errp=0x0) at vl.c:2275
+ * #9  0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b76c0 <qemu_device_opts>, func=0x5555559e127a <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559e6449 in main (argc=16, argv=0x7fffffffe3b8, envp=0x7fffffffe440) at vl.c:4542
+ *
+ *
+ * virtio block hotplug的时候:
+ * (gdb) bt
+ * #0  set_drive (obj=0x555556d81180, v=0x5555572a4650, name=0x5555577da4c0 "drive", opaque=0x55555659d360 <virtio_blk_properties>, errp=0x7fffffffcc48) at hw/core/qdev-properties-system.c:160
+ * #1  0x0000555555c7ffa0 in object_property_set (obj=0x555556d81180, v=0x5555572a4650, name=0x5555577da4c0 "drive", errp=0x7fffffffcc48) at qom/object.c:1176
+ * #2  0x0000555555c82b45 in property_set_alias (obj=0x555556d79010, v=0x5555572a4650, name=0x55555799efb0 "drive", opaque=0x5555577da4a0, errp=0x7fffffffcc48) at qom/object.c:2330
+ * #3  0x0000555555c7ffa0 in object_property_set (obj=0x555556d79010, v=0x5555572a4650, name=0x55555799efb0 "drive", errp=0x7fffffffcc48) at qom/object.c:1176
+ * #4  0x0000555555c809bf in object_property_parse (obj=0x555556d79010, string=0x55555799ef90 "myh1", name=0x55555799efb0 "drive", errp=0x7fffffffcc48) at qom/object.c:1402
+ * #5  0x00005555559d798e in set_property (opaque=0x555556d79010, name=0x55555799efb0 "drive", value=0x55555799ef90 "myh1", errp=0x7fffffffccd0) at qdev-monitor.c:180
+ * #6  0x0000555555dc83e9 in qemu_opt_foreach (opts=0x555556e2f640, func=0x5555559d7903 <set_property>, opaque=0x555556d79010, errp=0x7fffffffccd0) at util/qemu-option.c:580
+ * #7  0x00005555559d8e02 in qdev_device_add (opts=0x555556e2f640, errp=0x7fffffffcd40) at qdev-monitor.c:622
+ * #8  0x00005555559d961a in qmp_device_add (qdict=0x55555779d810, ret_data=0x0, errp=0x7fffffffcd80) at qdev-monitor.c:807
+ * #9  0x0000555555a072bf in hmp_device_add (mon=0x5555568a7450, qdict=0x55555779d810) at hmp.c:2008
+ * #10 0x000055555585b273 in handle_hmp_command (mon=0x5555568a7450, cmdline=0x5555568b1a0b "virtio-blk-pci,drive=myh1") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #11 0x000055555585d62e in monitor_command_cb (opaque=0x5555568a7450, cmdline=0x5555568b1a00 "device_add virtio-blk-pci,drive=myh1", readline_opaque=0x0) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #12 0x0000555555dcda60 in readline_handle_byte (rs=0x5555568b1a00, ch=13) at util/readline.c:393
+ * #13 0x000055555585d581 in monitor_read (opaque=0x5555568a7450, buf=0x7fffffffcf40 "\r\260\361UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #14 0x0000555555d2d217 in qemu_chr_be_write_impl (s=0x555556893ab0, buf=0x7fffffffcf40 "\r\260\361UUU", len=1) at chardev/char.c:175
+ * #15 0x0000555555d2d27b in qemu_chr_be_write (s=0x555556893ab0, buf=0x7fffffffcf40 "\r\260\361UUU", len=1) at chardev/char.c:187
+ * #16 0x0000555555d2f98f in fd_chr_read (chan=0x555556893cf0, cond=G_IO_IN, opaque=0x555556893ab0) at chardev/char-fd.c:66
+ * #17 0x0000555555d4f6b7 in qio_channel_fd_source_dispatch (source=0x55555749a920, callback=0x555555d2f831 <fd_chr_read>, user_data=0x555556893ab0) at io/channel-watch.c:84
+ * #18 0x00007ffff50e004a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #19 0x0000555555db0d34 in glib_pollfds_poll () at util/main-loop.c:215
+ * #20 0x0000555555db0da2 in os_host_main_loop_wait (timeout=499000000) at util/main-loop.c:238
+ * #21 0x0000555555db0e5b in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #22 0x00005555559dee92 in main_loop () at vl.c:1866
+ * #23 0x00005555559e66a5 in main (argc=16, argv=0x7fffffffe3b8, envp=0x7fffffffe440) at vl.c:4644
+ */
 static void set_drive(Object *obj, Visitor *v, const char *name, void *opaque,
                       Error **errp)
 {
diff --git a/hw/core/qdev-properties.c b/hw/core/qdev-properties.c
index 35072de..e29c9a8 100644
--- a/hw/core/qdev-properties.c
+++ b/hw/core/qdev-properties.c
@@ -1226,6 +1226,12 @@ int qdev_prop_check_globals(void)
             continue;
         }
         oc = object_class_by_name(prop->driver);
+	/*
+	 * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	 * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+	 * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+	 * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+	 */
         oc = object_class_dynamic_cast(oc, TYPE_DEVICE);
         if (!oc) {
             warn_report("global %s.%s has invalid class name",
@@ -1301,10 +1307,75 @@ const PropertyInfo qdev_prop_size = {
 
 /* --- object link property --- */
 
+/*
+ * (gdb) bt
+ * #0  create_link_property (obj=0x55555771a410, prop=0x5555562e48b8 <virtio_blk_properties+1368>, errp=0x7fffffffdd68) at hw/core/qdev-properties.c:1306
+ * #1  0x0000555555a2cebd in qdev_property_add_static (dev=0x55555771a410, prop=0x5555562e48b8 <virtio_blk_properties+1368>, errp=0x5555564c9e70 <error_abort>) at hw/core/qdev.c:690
+ * #2  0x0000555555a2daaa in device_initfn (obj=0x55555771a410) at hw/core/qdev.c:966
+ * #3  0x0000555555c1dfee in object_init_with_type (obj=0x55555771a410, ti=0x55555650db70) at qom/object.c:353
+ * #4  0x0000555555c1dfd0 in object_init_with_type (obj=0x55555771a410, ti=0x5555564fd310) at qom/object.c:349
+ * #5  0x0000555555c1dfd0 in object_init_with_type (obj=0x55555771a410, ti=0x5555564f9e30) at qom/object.c:349
+ * #6  0x0000555555c1e1b1 in object_initialize_with_type (data=0x55555771a410, size=552, type=0x5555564f9e30) at qom/object.c:384
+ * #7  0x0000555555c1e202 in object_initialize (data=0x55555771a410, size=552, typename=0x555555e3ccef "virtio-blk-device") at qom/object.c:392
+ * #8  0x00005555558c9797 in virtio_instance_init_common (proxy_obj=0x5555577122a0, data=0x55555771a410, vdev_size=552, vdev_name=0x555555e3ccef "virtio-blk-device")
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2235
+ * #9  0x0000555555b92df4 in virtio_blk_pci_instance_init (obj=0x5555577122a0) at hw/virtio/virtio-pci.c:1992
+ * #10 0x0000555555c1dfee in object_init_with_type (obj=0x5555577122a0, ti=0x555556527f40) at qom/object.c:353
+ * #11 0x0000555555c1e1b1 in object_initialize_with_type (data=0x5555577122a0, size=33696, type=0x555556527f40) at qom/object.c:384
+ * #12 0x0000555555c1e805 in object_new_with_type (type=0x555556527f40) at qom/object.c:546
+ * #13 0x0000555555c1e842 in object_new (typename=0x555556536320 "virtio-blk-pci") at qom/object.c:556
+ * #14 0x000055555599064c in qdev_device_add (opts=0x5555565362d0, errp=0x7fffffffe078) at qdev-monitor.c:608
+ * #15 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362d0, errp=0x0) at vl.c:2275
+ * #16 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #17 0x000055555599dd61 in main (argc=16, argv=0x7fffffffe3e8, envp=0x7fffffffe470) at vl.c:4542
+ *
+ * 当virtio block的iothread参数初始化到这里的时候, default的num_queues=1, queue_size=128都设置了
+ */
 static void create_link_property(Object *obj, Property *prop, Error **errp)
 {
+    /*
+     * virtio block iothread的例子:
+     * 1904     DEFINE_PROP_LINK("iothread", VirtIOBlock, conf.iothread, TYPE_IOTHREAD,
+     * 1905                      IOThread *),
+     *
+     *   .name = "iothread",
+     *   .info = &(qdev_prop_link),
+     *   .offset = offsetof(VirtIOBlock, conf.iothread)
+     *       + type_check(IOThread *, typeof_field(VirtIOBlock, conf.iothread)),
+     *   .link_type = TYPE_IOTHREAD,
+     *
+     * (gdb) p *prop
+     * $3 = {
+     *   name = 0x555555d929bd "iothread", 
+     *   info = 0x5555562b3b00 <qdev_prop_link>, 
+     *   offset = 488, 
+     *   bitnr = 0 '\000', 
+     *   set_default = false, 
+     *   defval = {
+     *     i = 0, 
+     *     u = 0
+     *   }, 
+     *   arrayoffset = 0, 
+     *   arrayinfo = 0x0, 
+     *   arrayfieldsize = 0, 
+     *   link_type = 0x555555d929bd "iothread"
+     */
+
+    /*
+     * 如果是virtio block的iothread来的,此时obj是VirtIOBlock, prop是"iothread"的property
+     *
+     * child就是指向VirtIOBlock->conf.iothread(IOThread)指针的指针
+     */
     Object **child = qdev_get_prop_ptr(DEVICE(obj), prop);
 
+    /*
+     * 如果是初始化virtio block的iothread prop的此时的参数:
+     *   obj             : VirtIOBlock的Object
+     *   prop->name      : "iothread"
+     *   prop->link_type : "iothread"
+     *   child           : 指向VirtIOBlock->conf.iothread(IOThread)指针的指针
+     *                     修改其值就相当于是给VirtIOBlock->conf.iothread(IOThread)赋值了
+     */
     object_property_add_link(obj, prop->name, prop->link_type,
                              child,
                              qdev_prop_allow_set_link_before_realize,
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index 529b82d..2dde5de 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -68,6 +68,38 @@ static void bus_remove_child(BusState *bus, DeviceState *child)
     }
 }
 
+/*
+ * called only by:
+ *   - hw/core/qdev.c|107| <<qdev_set_parent_bus>> bus_add_child(bus, dev);
+ *
+ * q35添加virtio-blk-pci的例子, 对于virtio-blk-pci的没有设置bus的例子(q35):
+ * (gdb) p *bus
+ * $4 = {
+ *   obj = {
+ *     class = 0x555556804550, 
+ *     free = 0x7ffff50e58b0 <g_free>, 
+ *     properties = 0x555556a258c0, 
+ *     ref = 7, 
+ *     parent = 0x555556a26f80
+ *   }, 
+ *   parent = 0x555556a26f80, 
+ *   name = 0x555556a65b40 "pcie.0", 
+ *   hotplug_handler = 0x0, 
+ *   max_index = 6, 
+ *   realized = true, 
+ *   children = {
+ *     tqh_first = 0x555557881fe0, 
+ *     tqh_last = 0x555556a65c20
+ *   }, 
+ *   sibling = {
+ *     le_next = 0x0, 
+ *     le_prev = 0x555556a26fe0
+ *   }
+ * }
+ *
+ * 核心思想是分配一个BusChild, BusChild->child设置为参数的DeviceState
+ * 然后把BusChild->siibling插入BusState->children
+ */
 static void bus_add_child(BusState *bus, DeviceState *child)
 {
     char name[32];
@@ -77,6 +109,14 @@ static void bus_add_child(BusState *bus, DeviceState *child)
     kid->child = child;
     object_ref(OBJECT(kid->child));
 
+    /*
+     * typedef struct BusChild {
+     *     DeviceState *child;   ---> 保存virtio-blk-pci的DeviceState
+     *     int index;            ---> 保存着当时的bus->max_index
+     *     QTAILQ_ENTRY(BusChild) sibling;  ---> 把sibling链接到bus->children
+     * } BusChild;
+     */
+
     QTAILQ_INSERT_HEAD(&bus->children, kid, sibling);
 
     /* This transfers ownership of kid->child to the property.  */
@@ -89,6 +129,13 @@ static void bus_add_child(BusState *bus, DeviceState *child)
                              NULL);
 }
 
+/*
+ * 被很多很多外部调用
+ *
+ * 核心思想是把DeviceState dev->parent_bus设置成参数的BusState bus
+ * 然后分配一个BusChild, BusChild->child设置为参数的DeviceState
+ * 把BusChild->siibling插入BusState->children
+ */
 void qdev_set_parent_bus(DeviceState *dev, BusState *bus)
 {
     bool replugging = dev->parent_bus != NULL;
@@ -104,6 +151,10 @@ void qdev_set_parent_bus(DeviceState *dev, BusState *bus)
     }
     dev->parent_bus = bus;
     object_ref(OBJECT(bus));
+    /*
+     * 核心思想是分配一个BusChild, BusChild->child设置为参数的DeviceState
+     * 然后把BusChild->siibling插入BusState->children
+     */
     bus_add_child(bus, dev);
     if (replugging) {
         object_unref(OBJECT(dev));
@@ -113,6 +164,9 @@ void qdev_set_parent_bus(DeviceState *dev, BusState *bus)
 /* Create a new device.  This only initializes the device state
    structure and allows properties to be set.  The device still needs
    to be realized.  See qdev-core.h.  */
+/*
+ * 被很多很多外部调用
+ */
 DeviceState *qdev_create(BusState *bus, const char *name)
 {
     DeviceState *dev;
@@ -131,13 +185,33 @@ DeviceState *qdev_create(BusState *bus, const char *name)
     return dev;
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev.c|130| <<qdev_create>> dev = qdev_try_create(bus, name);
+ *   - hw/core/sysbus.c|256| <<sysbus_try_create_varargs>> dev = qdev_try_create(NULL, name);
+ *   - hw/i386/pc.c|1591| <<pc_basic_device_init>> hpet = qdev_try_create(NULL, TYPE_HPET);
+ *   - hw/isa/isa-bus.c|170| <<isa_try_create>> dev = qdev_try_create(BUS(bus), name);
+ *   - hw/s390x/s390-pci-bus.c|778| <<s390_pci_device_new>> dev = qdev_try_create(BUS(s->bus), TYPE_S390_PCI_DEVICE);
+ *   - hw/usb/bus.c|336| <<usb_try_create_simple>> dev = USB_DEVICE(qdev_try_create(&bus->qbus, name));
+ */
 DeviceState *qdev_try_create(BusState *bus, const char *type)
 {
     DeviceState *dev;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     if (object_class_by_name(type) == NULL) {
         return NULL;
     }
+    /*
+     * object_new():
+     *       根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     *       确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     *       然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     dev = DEVICE(object_new(type));
     if (!dev) {
         return NULL;
@@ -149,6 +223,12 @@ DeviceState *qdev_try_create(BusState *bus, const char *type)
          * being put onto a bus should be created with object_new(TYPE_FOO),
          * not qdev_create(NULL, TYPE_FOO).
          */
+        /*
+	 * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	 * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+	 * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+	 * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+	 */
         g_assert(object_dynamic_cast(OBJECT(dev), TYPE_SYS_BUS_DEVICE));
         bus = sysbus_get_default();
     }
@@ -188,6 +268,10 @@ enum ListenerDirection { Forward, Reverse };
         }                                                         \
     } while (0)
 
+/*
+ * called only by:
+ *   - hw/core/qdev.c|238| <<device_listener_register>> qbus_walk_children(sysbus_get_default(), NULL, NULL, device_listener_add,
+ */
 static int device_listener_add(DeviceState *dev, void *opaque)
 {
     DEVICE_LISTENER_CALL(realize, Forward, dev);
@@ -333,6 +417,14 @@ bool qdev_machine_modified(void)
     return qdev_hot_added || qdev_hot_removed;
 }
 
+/*
+ * 对于virtio block,parent_bus初始化开始于virtio_pci_realize():
+ * 1. 使用virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);
+ *    其中proxy是VirtIOPCIProxy,其bus是自己的field,不是指针
+ * 2. 然后调用k->realize=virtio_blk_pci_realize()--> qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
+ *    让dev->parent_bus = bus, dev是VirtIOBlock, bus是VirtIOPCIProxy的bus
+ * 所以结论是,virtio block的parent_bus都是专属于自己对应的VirtIOPCIProxy
+ */
 BusState *qdev_get_parent_bus(DeviceState *dev)
 {
     return dev->parent_bus;
@@ -540,6 +632,10 @@ BusState *qdev_get_child_bus(DeviceState *dev, const char *name)
     return NULL;
 }
 
+/*
+ * hw/core/bus.c|65| <<qbus_walk_children>> err = qdev_walk_children(kid->child,
+ * hw/core/qdev.c|266| <<qdev_reset_all>> qdev_walk_children(dev, NULL, NULL, qdev_reset_one, qbus_reset_one, NULL);
+ */
 int qdev_walk_children(DeviceState *dev,
                        qdev_walkerfn *pre_devfn, qbus_walkerfn *pre_busfn,
                        qdev_walkerfn *post_devfn, qbus_walkerfn *post_busfn,
@@ -661,6 +757,10 @@ static void qdev_property_add_legacy(DeviceState *dev, Property *prop,
     }
 
     name = g_strdup_printf("legacy-%s", prop->name);
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(OBJECT(dev), name, "str",
                         prop->info->print ? qdev_get_legacy_property : prop->info->get,
                         NULL,
@@ -680,6 +780,10 @@ static void qdev_property_add_legacy(DeviceState *dev, Property *prop,
  * On error, store error in @errp.  Static properties access data in a struct.
  * The type of the QOM property is derived from prop->info.
  */
+/*
+ * 在x86上只被如下调用:
+ *   - hw/core/qdev.c|1075| <<device_initfn>> qdev_property_add_static(dev, prop, &error_abort);
+ */
 void qdev_property_add_static(DeviceState *dev, Property *prop,
                               Error **errp)
 {
@@ -697,6 +801,10 @@ void qdev_property_add_static(DeviceState *dev, Property *prop,
         if (!prop->info->get && !prop->info->set) {
             return;
         }
+	/*
+	 * 核心思想是分配并初始化一个ObjectProperty
+	 * 然后插入Object->properties (GHashTable)
+	 */
         object_property_add(obj, prop->name, prop->info->name,
                             prop->info->get, prop->info->set,
                             prop->info->release,
@@ -708,6 +816,12 @@ void qdev_property_add_static(DeviceState *dev, Property *prop,
         return;
     }
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     * 最后修改找到的ObjectProperty的description
+     */
     object_property_set_description(obj, prop->name,
                                     prop->info->description,
                                     &error_abort);
@@ -720,8 +834,17 @@ void qdev_property_add_static(DeviceState *dev, Property *prop,
 /* @qdev_alias_all_properties - Add alias properties to the source object for
  * all qdev properties on the target DeviceState.
  */
+/*
+ * called only by (也就virtio有这么怪异的设计):
+ *   - hw/virtio/virtio.c|3115| <<virtio_instance_init_common>> qdev_alias_all_properties(vdev, proxy_obj);
+ */
 void qdev_alias_all_properties(DeviceState *target, Object *source)
 {
+    /*
+     * 如果是virtio block pci通过virtio_instance_init_common()进来的:
+     *   target : VirtIOBlock
+     *   source : VirtIOBlkPCI
+     */
     ObjectClass *class;
     Property *prop;
 
@@ -730,6 +853,13 @@ void qdev_alias_all_properties(DeviceState *target, Object *source)
         DeviceClass *dc = DEVICE_CLASS(class);
 
         for (prop = dc->props; prop && prop->name; prop++) {
+            /*
+	     * 如果是virtio block pci进来的 (假设是num_queues的例子):
+	     *   source         : VirtIOBlkPCI的Object
+	     *   prop->name     : "num_queues"
+	     *   OBJECT(target) : VirtIOBlock的Object
+	     *   prop->name     : "num_queues"
+	     */
             object_property_add_alias(source, prop->name,
                                       OBJECT(target), prop->name,
                                       &error_abort);
@@ -764,6 +894,14 @@ GSList *qdev_build_hotpluggable_device_list(Object *peripheral)
     return list;
 }
 
+/*
+ * 用在device_initfn():
+ * 1025     object_property_add_bool(obj, "realized",
+ * 1026                              device_get_realized, device_set_realized, NULL);
+ *
+ * called by:
+ *   - qom/object.c|2954| <<property_set_bool>> prop->set(obj, value, errp);
+ */
 static bool device_get_realized(Object *obj, Error **errp)
 {
     DeviceState *dev = DEVICE(obj);
@@ -784,6 +922,25 @@ static bool check_only_migratable(Object *obj, Error **err)
     return true;
 }
 
+/*
+ * used by:
+ *   - hw/core/qdev.c|995| <<device_initfn>> device_get_realized, device_set_realized, NULL);
+ *     1030     object_property_add_bool(obj, "realized",
+ *     1031                              device_get_realized, device_set_realized, NULL);
+ *
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 static void device_set_realized(Object *obj, bool value, Error **errp)
 {
     DeviceState *dev = DEVICE(obj);
@@ -937,6 +1094,47 @@ static bool device_get_hotplugged(Object *obj, Error **err)
     return dev->hotplugged;
 }
 
+/*
+ * (gdb) bt
+ * #0  device_initfn (obj=0x5555577122a0) at hw/core/qdev.c:942
+ * #1  0x0000555555c1dfee in object_init_with_type (obj=0x5555577122a0, ti=0x55555650db70) at qom/object.c:353
+ * #2  0x0000555555c1dfd0 in object_init_with_type (obj=0x5555577122a0, ti=0x55555651d980) at qom/object.c:349
+ * #3  0x0000555555c1dfd0 in object_init_with_type (obj=0x5555577122a0, ti=0x555556527d40) at qom/object.c:349
+ * #4  0x0000555555c1dfd0 in object_init_with_type (obj=0x5555577122a0, ti=0x555556527f40) at qom/object.c:349
+ * #5  0x0000555555c1e1b1 in object_initialize_with_type (data=0x5555577122a0, size=33696, type=0x555556527f40) at qom/object.c:384
+ * #6  0x0000555555c1e805 in object_new_with_type (type=0x555556527f40) at qom/object.c:546
+ * #7  0x0000555555c1e842 in object_new (typename=0x555556536320 "virtio-blk-pci") at qom/object.c:556
+ * #8  0x000055555599064c in qdev_device_add (opts=0x5555565362d0, errp=0x7fffffffe078) at qdev-monitor.c:608
+ * #9  0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362d0, errp=0x0) at vl.c:2275
+ * #10 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #11 0x000055555599dd61 in main (argc=16, argv=0x7fffffffe3e8, envp=0x7fffffffe470) at vl.c:4542
+ *
+ * 第一次并没有调用iothread的create_link_property()
+ *
+ * (gdb) bt
+ * #0  device_initfn (obj=0x55555771a410) at hw/core/qdev.c:942
+ * #1  0x0000555555c1dfee in object_init_with_type (obj=0x55555771a410, ti=0x55555650db70) at qom/object.c:353
+ * #2  0x0000555555c1dfd0 in object_init_with_type (obj=0x55555771a410, ti=0x5555564fd310) at qom/object.c:349
+ * #3  0x0000555555c1dfd0 in object_init_with_type (obj=0x55555771a410, ti=0x5555564f9e30) at qom/object.c:349
+ * #4  0x0000555555c1e1b1 in object_initialize_with_type (data=0x55555771a410, size=552, type=0x5555564f9e30) at qom/object.c:384
+ * #5  0x0000555555c1e202 in object_initialize (data=0x55555771a410, size=552, typename=0x555555e3ccef "virtio-blk-device") at qom/object.c:392
+ * #6  0x00005555558c9797 in virtio_instance_init_common (proxy_obj=0x5555577122a0, data=0x55555771a410, vdev_size=552, vdev_name=0x555555e3ccef "virtio-blk-device")
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2235
+ * #7  0x0000555555b92df4 in virtio_blk_pci_instance_init (obj=0x5555577122a0) at hw/virtio/virtio-pci.c:1992
+ * #8  0x0000555555c1dfee in object_init_with_type (obj=0x5555577122a0, ti=0x555556527f40) at qom/object.c:353
+ * #9  0x0000555555c1e1b1 in object_initialize_with_type (data=0x5555577122a0, size=33696, type=0x555556527f40) at qom/object.c:384
+ * #10 0x0000555555c1e805 in object_new_with_type (type=0x555556527f40) at qom/object.c:546
+ * #11 0x0000555555c1e842 in object_new (typename=0x555556536320 "virtio-blk-pci") at qom/object.c:556
+ * #12 0x000055555599064c in qdev_device_add (opts=0x5555565362d0, errp=0x7fffffffe078) at qdev-monitor.c:608
+ * #13 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362d0, errp=0x0) at vl.c:2275
+ * #14 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #15 0x000055555599dd61 in main (argc=16, argv=0x7fffffffe3e8, envp=0x7fffffffe470) at vl.c:4542
+ *
+ * TypeInfo device_type_info.instance_init = device_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void device_initfn(Object *obj)
 {
     DeviceState *dev = DEVICE(obj);
@@ -951,6 +1149,13 @@ static void device_initfn(Object *obj)
     dev->instance_id_alias = -1;
     dev->realized = false;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     *     get     = property_get_bool()
+     *     set     = property_set_bool()
+     *     release = property_release_bool()
+     */
     object_property_add_bool(obj, "realized",
                              device_get_realized, device_set_realized, NULL);
     object_property_add_bool(obj, "hotpluggable",
@@ -959,12 +1164,20 @@ static void device_initfn(Object *obj)
                              device_get_hotplugged, NULL,
                              &error_abort);
 
+    /*
+     * 返回Object->class
+     */
     class = object_get_class(OBJECT(dev));
     do {
         for (prop = DEVICE_CLASS(class)->props; prop && prop->name; prop++) {
             qdev_property_add_legacy(dev, prop, &error_abort);
             qdev_property_add_static(dev, prop, &error_abort);
         }
+	/*
+	 * 得到TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 * 初始化parent_type(TypeImpl)的class_size, instance_size和class, 还有interface, 调用.class_init()
+	 * 最后返回parent_type(TypeImpl)的class (ObjectClass)
+	 */
         class = object_class_get_parent(class);
     } while (class != object_class_by_name(TYPE_DEVICE));
 
@@ -974,12 +1187,24 @@ static void device_initfn(Object *obj)
     QLIST_INIT(&dev->gpios);
 }
 
+/*
+ * TypeInfo device_type_info.instance_post_init = device_post_init()
+ *
+ * called only by:
+ *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+ */
 static void device_post_init(Object *obj)
 {
     qdev_prop_set_globals(DEVICE(obj));
 }
 
 /* Unlink device from bus and free the structure.  */
+/*
+ * TypeInfo device_type_info.instance_finalize = device_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void device_finalize(Object *obj)
 {
     NamedGPIOList *ngl, *next;
@@ -1009,6 +1234,12 @@ static void device_finalize(Object *obj)
     qemu_opts_del(dev->opts);
 }
 
+/*
+ * TypeInfo device_type_info.class_base_init = device_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void device_class_base_init(ObjectClass *class, void *data)
 {
     DeviceClass *klass = DEVICE_CLASS(class);
@@ -1038,6 +1269,12 @@ static void device_unparent(Object *obj)
     }
 }
 
+/*
+ * TypeInfo device_type_info.class_init = device_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void device_class_init(ObjectClass *class, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(class);
@@ -1078,20 +1315,67 @@ void device_class_set_parent_unrealize(DeviceClass *dc,
     dc->unrealize = dev_unrealize;
 }
 
+/*
+ * (gdb) bt
+ * #0  qdev_e1000_reset (dev=0x7fffe765e010) at hw/net/e1000.c:1697
+ * #1  0x0000555555a749ce in device_reset (dev=0x7fffe765e010) at hw/core/qdev.c:1086
+ * #2  0x0000555555a729c1 in qdev_reset_one (dev=0x7fffe765e010, opaque=0x0) at hw/core/qdev.c:250
+ * #3  0x0000555555a735c7 in qdev_walk_children (dev=0x7fffe765e010, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/qdev.c:567
+ * #4  0x0000555555a77b53 in qbus_walk_children (bus=0x5555569fed40, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/bus.c:59
+ * #5  0x0000555555a7358b in qdev_walk_children (dev=0x5555569fca60, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/qdev.c:559
+ * #6  0x0000555555a77b53 in qbus_walk_children (bus=0x5555568acc70, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/bus.c:59
+ * #7  0x0000555555a72adb in qbus_reset_all (bus=0x5555568acc70) at hw/core/qdev.c:276
+ * #8  0x0000555555a72afe in qbus_reset_all_fn (opaque=0x5555568acc70) at hw/core/qdev.c:282
+ * #9  0x0000555555a78499 in qemu_devices_reset () at hw/core/reset.c:69
+ * #10 0x000055555591bfda in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #11 0x00005555559d8098 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #12 0x00005555559dfd6e in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4611
+ *
+ * 几个主要调用的例子:
+ *   - hw/core/qdev.c|290| <<qdev_reset_one>> device_reset(dev);
+ *   - hw/core/qdev.c|952| <<device_set_realized>> device_reset(dev);
+ *   - hw/i386/pc.c|2305| <<pc_machine_reset>> device_reset(cpu->apic_state);
+ */
 void device_reset(DeviceState *dev)
 {
     DeviceClass *klass = DEVICE_GET_CLASS(dev);
 
+    /*
+     * 以e1000和e1000e为例子, reset的设置的地方:
+     *   - hw/net/e1000.c|1755| <<e1000_class_init>> dc->reset = qdev_e1000_reset;
+     *   - hw/net/e1000e.c|681| <<e1000e_class_init>> dc->reset = e1000e_qdev_reset;
+     */
+
     if (klass->reset) {
         klass->reset(dev);
     }
 }
 
+/*
+ * 在这个例子中, machine是name, child<pc-i440fx-3.0-machine>是type
+ *    (qemu) qom-list /
+ *    machine (child<pc-i440fx-3.0-machine>)
+ *    type (string)
+ *    chardevs (child<container>)
+ *    backend (child<container>)
+ *
+ * 测试的时候"/machine"不是在这里的container_get()初始化的
+ * 应该是在vl.c的main()初始化的:
+ *     4067     object_property_add_child(object_get_root(), "machine",
+ *     4068                               OBJECT(current_machine), &error_abort);
+ */
 Object *qdev_get_machine(void)
 {
     static Object *dev;
 
     if (dev == NULL) {
+        /*
+	 * object_get_root(): 返回"container"的Object (root), 如果为空先初始化
+	 */
         dev = container_get(object_get_root(), "/machine");
     }
 
@@ -1113,7 +1397,16 @@ static const TypeInfo device_type_info = {
 
 static void qdev_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&device_type_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(qdev_register_types)
diff --git a/hw/core/reset.c b/hw/core/reset.c
index 84c8869..563a36f 100644
--- a/hw/core/reset.c
+++ b/hw/core/reset.c
@@ -35,9 +35,25 @@ typedef struct QEMUResetEntry {
     void *opaque;
 } QEMUResetEntry;
 
+/*
+ * 添加:
+ *   - hw/core/reset.c|47| <<qemu_register_reset>> QTAILQ_INSERT_TAIL(&reset_handlers, re, entry);
+ *
+ * 删除:
+ *   - hw/core/reset.c|56| <<qemu_unregister_reset>> QTAILQ_REMOVE(&reset_handlers, re, entry);
+ *
+ * 使用:
+ *   - hw/core/reset.c|54| <<qemu_unregister_reset>> QTAILQ_FOREACH(re, &reset_handlers, entry) {
+ *   - hw/core/reset.c|68| <<qemu_devices_reset>> QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {
+ */
 static QTAILQ_HEAD(reset_handlers, QEMUResetEntry) reset_handlers =
     QTAILQ_HEAD_INITIALIZER(reset_handlers);
 
+/*
+ * 很多很多外部调用
+ *
+ * 把func(QEMUResetHandler)和opaque初始化成QEMUResetEntry, 插入reset_handlers链表
+ */
 void qemu_register_reset(QEMUResetHandler *func, void *opaque)
 {
     QEMUResetEntry *re = g_malloc0(sizeof(QEMUResetEntry));
@@ -47,6 +63,23 @@ void qemu_register_reset(QEMUResetHandler *func, void *opaque)
     QTAILQ_INSERT_TAIL(&reset_handlers, re, entry);
 }
 
+/*
+ * bootdevice.c|115| <<restore_boot_order>> qemu_unregister_reset(restore_boot_order, normal_boot_order);
+ * hw/char/serial.c|959| <<serial_exit_core>> qemu_unregister_reset(serial_reset, s);
+ * hw/core/bus.c|139| <<bus_unparent>> qemu_unregister_reset(qbus_reset_all_fn, bus);
+ * hw/core/generic-loader.c|175| <<generic_loader_unrealize>> qemu_unregister_reset(generic_loader_reset, dev);
+ * hw/i386/pc.c|438| <<pc_cmos_init_late>> qemu_unregister_reset(pc_cmos_init_late, opaque);
+ * hw/intc/xics.c|364| <<icp_unrealize>> qemu_unregister_reset(icp_reset_handler, dev);
+ * hw/ppc/pnv_core.c|192| <<pnv_unrealize_vcpu>> qemu_unregister_reset(pnv_cpu_reset, cpu);
+ * hw/ppc/spapr_cpu_core.c|118| <<spapr_unrealize_vcpu>> qemu_unregister_reset(spapr_cpu_reset, cpu);
+ * hw/ppc/spapr_cpu_core.c|239| <<spapr_realize_vcpu>> qemu_unregister_reset(spapr_cpu_reset, cpu);
+ * hw/ppc/spapr_drc.c|641| <<unrealize_physical>> qemu_unregister_reset(drc_physical_reset, drcp);
+ * hw/vfio/common.c|1363| <<vfio_put_group>> qemu_unregister_reset(vfio_reset_handler, NULL);
+ * target/i386/cpu.c|5040| <<x86_cpu_unrealizefn>> qemu_unregister_reset(x86_cpu_machine_reset_cb, dev);
+ * target/s390x/cpu.c|303| <<s390_cpu_finalize>> qemu_unregister_reset(s390_cpu_machine_reset_cb, cpu);
+ *
+ * 根据func(QEMUResetHandler)和opaque在链表reset_handlers中寻找QEMUResetEntry并删掉
+ */
 void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
 {
     QEMUResetEntry *re;
@@ -60,6 +93,14 @@ void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
     }
 }
 
+/*
+ * hw/hppa/machine.c|245| <<hppa_machine_reset>> qemu_devices_reset();
+ * hw/i386/pc.c|2282| <<pc_machine_reset>> qemu_devices_reset();
+ * hw/ppc/pnv.c|504| <<pnv_reset>> qemu_devices_reset();
+ * hw/ppc/spapr.c|1639| <<spapr_machine_reset>> qemu_devices_reset();
+ * hw/s390x/s390-virtio-ccw.c|355| <<s390_machine_reset>> qemu_devices_reset();
+ * vl.c|1647| <<qemu_system_reset>> qemu_devices_reset();
+ */
 void qemu_devices_reset(void)
 {
     QEMUResetEntry *re, *nre;
diff --git a/hw/core/sysbus.c b/hw/core/sysbus.c
index 3c8e53b..275b64b 100644
--- a/hw/core/sysbus.c
+++ b/hw/core/sysbus.c
@@ -368,6 +368,31 @@ static void main_system_bus_create(void)
                               "sysbus", OBJECT(main_system_bus), NULL);
 }
 
+/*
+ * (gdb) p *main_system_bus
+ * $24 = {
+ *   obj = {
+ *     class = 0x55555684c380, 
+ *     free = 0x7ffff50e58b0 <g_free>, 
+ *     properties = 0x55555689bea0, 
+ *     ref = 8, 
+ *     parent = 0x555556889330
+ *   }, 
+ *   parent = 0x0, 
+ *   name = 0x5555568d7250 "main-system-bus", 
+ *   hotplug_handler = 0x0, 
+ *   max_index = 6, 
+ *   realized = false, 
+ *   children = {
+ *     tqh_first = 0x5555573f27b0, 
+ *     tqh_last = 0x5555568d7330
+ *   }, 
+ *   sibling = {
+ *     le_next = 0x0, 
+ *     le_prev = 0x0
+ *   }
+ * }
+ */
 BusState *sysbus_get_default(void)
 {
     if (!main_system_bus) {
diff --git a/hw/i386/intel_iommu.c b/hw/i386/intel_iommu.c
index 0a8cd4e..16f6933 100644
--- a/hw/i386/intel_iommu.c
+++ b/hw/i386/intel_iommu.c
@@ -2231,6 +2231,12 @@ static uint64_t vtd_mem_read(void *opaque, hwaddr addr, unsigned size)
     return val;
 }
 
+/*
+ * used by:
+ *   2575 static const MemoryRegionOps vtd_mem_ops = {
+ *   2576     .read = vtd_mem_read,
+ *   2577     .write = vtd_mem_write,
+ */
 static void vtd_mem_write(void *opaque, hwaddr addr,
                           uint64_t val, unsigned size)
 {
@@ -2572,6 +2578,12 @@ static const VMStateDescription vtd_vmstate = {
     }
 };
 
+/*
+ * used by:
+ *   - hw/i386/intel_iommu.c|3277| <<vtd_realize>>
+ *     3277     memory_region_init_io(&s->csrmem, OBJECT(s), &vtd_mem_ops, s,
+ *     3278                           "intel_iommu", DMAR_REG_SIZE);
+ */
 static const MemoryRegionOps vtd_mem_ops = {
     .read = vtd_mem_read,
     .write = vtd_mem_write,
diff --git a/hw/i386/kvm/apic.c b/hw/i386/kvm/apic.c
index 1df6d26..8336a03 100644
--- a/hw/i386/kvm/apic.c
+++ b/hw/i386/kvm/apic.c
@@ -18,6 +18,16 @@
 #include "sysemu/kvm.h"
 #include "target/i386/kvm_i386.h"
 
+/*
+ * QEMU和KVM都实现了对中断芯片的模拟,这是由于历史原因造成的.早在KVM诞生之前,
+ * QEMU就提供了一整套对设备的模拟,包括中断芯片.而KVM诞生之后,为了进一步提高
+ * 中断性能,因此又在KVM中实现了一套中断芯片.我们可以通过QEMU的启动参数
+ * kernel-irqchip来决定使用谁的中断芯片(irq chip)/
+ *   on: KVM模拟全部
+ *   split: QEMU模拟IOAPIC和PIC,KVM模拟LAPIC
+ *   off: QEMU模拟全部
+ */
+
 static inline void kvm_apic_set_reg(struct kvm_lapic_state *kapic,
                                     int reg_id, uint32_t val)
 {
@@ -178,6 +188,11 @@ static void kvm_apic_external_nmi(APICCommonState *s)
     run_on_cpu(CPU(s->cpu), do_inject_external_nmi, RUN_ON_CPU_HOST_PTR(s));
 }
 
+/*
+ * called and used by:
+ *   - hw/i386/kvm/apic.c|223| <<kvm_apic_mem_write>> kvm_send_msi(&msg);
+ *   - hw/i386/kvm/apic.c|296| <<kvm_apic_class_init>> k->send_msi = kvm_send_msi;
+ */
 static void kvm_send_msi(MSIMessage *msg)
 {
     int ret;
@@ -195,6 +210,26 @@ static uint64_t kvm_apic_mem_read(void *opaque, hwaddr addr,
     return ~(uint64_t)0;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_apic_mem_write (opaque=0x5555568aaf70, addr=4096, data=16421, size=4) at /home/zhang/kvm/qemu-3.0.0/hw/i386/kvm/apic.c:200
+ * #1  0x0000555555864b2d in memory_region_write_accessor (mr=0x5555568aaff0, addr=4096, value=0x7fffffffde98, size=4, shift=0, mask=4294967295, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #2  0x0000555555864d45 in access_with_adjusted_size (addr=4096, value=0x7fffffffde98, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555864a43 <memory_region_write_accessor>,
+ *     mr=0x5555568aaff0, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #3  0x000055555586796d in memory_region_dispatch_write (mr=0x5555568aaff0, addr=4096, data=16421, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #4  0x0000555555805285 in address_space_stl_internal (as=0x5555579aa130, addr=4276097024, val=16421, attrs=..., result=0x0, endian=DEVICE_LITTLE_ENDIAN) at /home/zhang/kvm/qemu-3.0.0/memory_ldst.inc.c:349
+ * #5  0x00005555558053bd in address_space_stl_le (as=0x5555579aa130, addr=4276097024, val=16421, attrs=..., result=0x0) at /home/zhang/kvm/qemu-3.0.0/memory_ldst.inc.c:386
+ * #6  0x0000555555b3c744 in msi_send_message (dev=0x5555579a9f20, msg=...) at hw/pci/msi.c:340
+ * #7  0x0000555555b3b2d2 in msix_notify (dev=0x5555579a9f20, vector=1) at hw/pci/msix.c:494
+ * #8  0x0000555555a5b4dc in nvme_irq_assert (n=0x5555579a9f20, cq=0x5555578a3410) at hw/block/nvme.c:114
+ * #9  0x0000555555a5bf1b in nvme_post_cqes (opaque=0x5555578a3410) at hw/block/nvme.c:275
+ * #10 0x0000555555d8d3a1 in timerlist_run_timers (timer_list=0x55555684ef50) at util/qemu-timer.c:536
+ * #11 0x0000555555d8d3ed in qemu_clock_run_timers (type=QEMU_CLOCK_VIRTUAL) at util/qemu-timer.c:547
+ * #12 0x0000555555d8d7c2 in qemu_clock_run_all_timers () at util/qemu-timer.c:667
+ * #13 0x0000555555d8ded2 in main_loop_wait (nonblocking=0) at util/main-loop.c:503
+ * #14 0x00005555559d8681 in main_loop () at vl.c:1866
+ * #15 0x00005555559dfe85 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4644
+ */
 static void kvm_apic_mem_write(void *opaque, hwaddr addr,
                                uint64_t data, unsigned size)
 {
@@ -217,10 +252,36 @@ static void kvm_apic_reset(APICCommonState *s)
     run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
 }
 
+/*
+ * 测试的是几个cpu调用几次:
+ * (gdb) bt
+ * #0  kvm_apic_realize (dev=0x5555569096f0, errp=0x7fffffffda30) at /home/zhang/kvm/qemu-3.0.0/hw/i386/kvm/apic.c:222
+ * #1  0x00005555558c3b00 in apic_common_realize (dev=0x5555569096f0, errp=0x7fffffffda30) at /home/zhang/kvm/qemu-3.0.0/hw/intc/apic_common.c:318
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555569096f0, value=true, errp=0x7fffffffdc40) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555569096f0, v=0x55555690a570, name=0x555555eb3490 "realized", opaque=0x5555569024e0, errp=0x7fffffffdc40) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555569096f0, v=0x55555690a570, name=0x555555eb3490 "realized", errp=0x7fffffffdc40) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555569096f0, value=0x55555690a3c0, name=0x555555eb3490 "realized", errp=0x7fffffffdc40) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555569096f0, value=true, name=0x555555eb3490 "realized", errp=0x7fffffffdc40) at qom/object.c:1242
+ * #7  0x0000555555955e9a in x86_cpu_apic_realize (cpu=0x5555568e8760, errp=0x7fffffffdc40) at /home/zhang/kvm/qemu-3.0.0/target/i386/cpu.c:4491
+ * #8  0x00005555559571da in x86_cpu_realizefn (dev=0x5555568e8760, errp=0x7fffffffdcc0) at /home/zhang/kvm/qemu-3.0.0/target/i386/cpu.c:5017
+ * #9  0x0000555555a73ecc in device_set_realized (obj=0x5555568e8760, value=true, errp=0x7fffffffde98) at hw/core/qdev.c:826
+ * #10 0x0000555555c6020e in property_set_bool (obj=0x5555568e8760, v=0x555556901fe0, name=0x555555ea7440 "realized", opaque=0x5555568e86f0, errp=0x7fffffffde98) at qom/object.c:1984
+ * #11 0x0000555555c5e493 in object_property_set (obj=0x5555568e8760, v=0x555556901fe0, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/object.c:1176
+ * #12 0x0000555555c6154b in object_property_set_qobject (obj=0x5555568e8760, value=0x555556906680, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/qom-qobject.c:27
+ * #13 0x0000555555c5e778 in object_property_set_bool (obj=0x5555568e8760, value=true, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/object.c:1242
+ * #14 0x00005555559184e7 in pc_new_cpu (typename=0x555555ea7dec "qemu64-x86_64-cpu", apic_id=1, errp=0x555556751598 <error_fatal>) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1107
+ * #15 0x0000555555918752 in pc_cpus_init (pcms=0x55555684fa40) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1155
+ * #16 0x000055555591cd4d in pc_init1 (machine=0x55555684fa40, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:153
+ * #17 0x000055555591da26 in pc_init_v3_0 (machine=0x55555684fa40) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #18 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684fa40) at hw/core/machine.c:830
+ * #19 0x00005555559dfb8f in main (argc=16, argv=0x7fffffffe388, envp=0x7fffffffe410) at vl.c:4516
+ *
+ */
 static void kvm_apic_realize(DeviceState *dev, Error **errp)
 {
     APICCommonState *s = APIC_COMMON(dev);
 
+    /* 在x86_cpu_apic_realize()中设置的ops */
     memory_region_init_io(&s->io_memory, OBJECT(s), &kvm_apic_io_ops, s,
                           "kvm-apic-msi", APIC_SPACE_SIZE);
 
diff --git a/hw/i386/kvm/clock.c b/hw/i386/kvm/clock.c
index 0bf1c60..d28f8d8 100644
--- a/hw/i386/kvm/clock.c
+++ b/hw/i386/kvm/clock.c
@@ -93,6 +93,30 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     return nsec + time.system_time;
 }
 
+/*
+ * 一个例子:
+ * (gdb) bt
+ * #0  kvm_update_clock (s=0x5555568fa2c0) at /home/zhang/kvm/qemu-3.0.0/hw/i386/kvm/clock.c:97
+ * #1  0x00005555559419d5 in kvmclock_realize (dev=0x5555568fa2c0, errp=0x7fffffffdc50) at /home/zhang/kvm/qemu-3.0.0/hw/i386/kvm/clock.c:221
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555568fa2c0, value=true, errp=0x7fffffffde10) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555568fa2c0, v=0x5555568fa970, name=0x555555ee0a71 "realized", opaque=0x5555568f9fe0, errp=0x7fffffffde10) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555568fa2c0, v=0x5555568fa970, name=0x555555ee0a71 "realized", errp=0x7fffffffde10) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555568fa2c0, value=0x5555568fa8c0, name=0x555555ee0a71 "realized", errp=0x7fffffffde10) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555568fa2c0, value=true, name=0x555555ee0a71 "realized", errp=0x7fffffffde10) at qom/object.c:1242
+ * #7  0x0000555555a72ba0 in qdev_init_nofail (dev=0x5555568fa2c0) at hw/core/qdev.c:313
+ * #8  0x0000555555a79a24 in sysbus_create_varargs (name=0x555555eaf500 "kvmclock", addr=18446744073709551615) at hw/core/sysbus.c:229
+ * #9  0x0000555555941583 in sysbus_create_simple (name=0x555555eaf500 "kvmclock", addr=18446744073709551615, irq=0x0) at /home/zhang/kvm/qemu-3.0.0/include/hw/sysbus.h:128
+ * #10 0x0000555555941b2c in kvmclock_create () at /home/zhang/kvm/qemu-3.0.0/hw/i386/kvm/clock.c:326
+ * #11 0x000055555591cd6f in pc_init1 (machine=0x55555684f700, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:156
+ * #12 0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f700) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #13 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f700) at hw/core/machine.c:830
+ * #14 0x00005555559dfb8f in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4516
+ *
+ * called by:
+ *   - hw/i386/kvm/clock.c|229| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|248| <<kvmclock_realize>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|302| <<kvmclock_pre_save>> kvm_update_clock(s);
+ */
 static void kvm_update_clock(KVMClockState *s)
 {
     struct kvm_clock_data data;
@@ -147,6 +171,14 @@ static void kvm_update_clock(KVMClockState *s)
     s->clock_is_reliable = kvm_has_adjust_clock_stable();
 }
 
+/*
+ * (gdb) bt
+ * #0  kvmclock_vm_state_change (opaque=0x5555568fa2c0, running=1, state=RUN_STATE_RUNNING) at /home/zhang/kvm/qemu-3.0.0/hw/i386/kvm/clock.c:152
+ * #1  0x00005555559d7e62 in vm_state_notify (running=1, state=RUN_STATE_RUNNING) at vl.c:1532
+ * #2  0x000055555584b664 in vm_prepare_start () at /home/zhang/kvm/qemu-3.0.0/cpus.c:2073
+ * #3  0x000055555584b688 in vm_start () at /home/zhang/kvm/qemu-3.0.0/cpus.c:2079
+ * #4  0x00005555559dfe6c in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4638
+ */
 static void kvmclock_vm_state_change(void *opaque, int running,
                                      RunState state)
 {
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 83a4444..d630d4f 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1321,6 +1321,16 @@ void xen_load_linux(PCMachineState *pcms)
     pcms->fw_cfg = fw_cfg;
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|194| <<pc_init1>> pc_memory_init(pcms, system_memory,
+ *   - hw/i386/pc_q35.c|167| <<pc_q35_init>> pc_memory_init(pcms, get_system_memory(),
+ *
+ * 整个过程中,分配内存也不会像MemoryRegion那么频繁,mr很多时候是创建一个alias,
+ * 指向已经存在的mr的一部分,这也是alias的作用,就是把一个mr分割成多个不连续的mr.
+ * 真正分配空间的大概有这么几个,pc.ram,,pc.bios,,pc.rom,,以及设备的一些ram,rom等,
+ * vga.vram,,vga.rom,,e1000.rom等.
+ */
 void pc_memory_init(PCMachineState *pcms,
                     MemoryRegion *system_memory,
                     MemoryRegion *rom_memory,
@@ -1333,6 +1343,9 @@ void pc_memory_init(PCMachineState *pcms,
     MachineState *machine = MACHINE(pcms);
     PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);
 
+    /*
+     * 在pc_init1()中初始化了pcms->below_4g_mem_size和pcms->above_4g_mem_size
+     */
     assert(machine->ram_size == pcms->below_4g_mem_size +
                                 pcms->above_4g_mem_size);
 
@@ -1342,13 +1355,37 @@ void pc_memory_init(PCMachineState *pcms,
      * aliases to address portions of it, mostly for backwards compatibility
      * with older qemus that used qemu_ram_alloc().
      */
+    /* ram是MemoryRegion */
     ram = g_malloc(sizeof(*ram));
+    /*
+     * 这里的machine->ram_size就是qemu参数中的内存
+     *
+     * 这里分配了RAMBlock!
+     */
     memory_region_allocate_system_memory(ram, NULL, "pc.ram",
                                          machine->ram_size);
+
+    /*
+     * 在创建好了ram并且分配好了空间之后,创建了两个mr alias,ram_below_4g
+     * 以及ram_above_4g,这两个mr分别指向ram的低4g以及高4g空间,这两个alias
+     * 是挂在根system_memory mr下面的
+     * 以后的情形类似,创建根mr,创建AddressSpace,然后在根mr下面加subregion。
+     */
+
     *ram_memory = ram;
     ram_below_4g = g_malloc(sizeof(*ram_below_4g));
+    /*
+     * 把ram_below_4g设置为ram的一个alias, 也就是表示ram的一部分
+     */
     memory_region_init_alias(ram_below_4g, NULL, "ram-below-4g", ram,
                              0, pcms->below_4g_mem_size);
+    /*
+     * 设置subregion的container和addr (记录该region在物理内存的地址)
+     * 按照priority=0把subregion插入到上一层的MemoryRegion的subregions链表
+     * "上一层"的意思就是说这个region是上一层的subregion
+     * 没有好的位置就插入到最后
+     * 最后还要memory_region_transaction_commit()
+     */
     memory_region_add_subregion(system_memory, 0, ram_below_4g);
     e820_add_entry(0, pcms->below_4g_mem_size, E820_RAM);
     if (pcms->above_4g_mem_size > 0) {
@@ -1356,6 +1393,9 @@ void pc_memory_init(PCMachineState *pcms,
         memory_region_init_alias(ram_above_4g, NULL, "ram-above-4g", ram,
                                  pcms->below_4g_mem_size,
                                  pcms->above_4g_mem_size);
+	/*
+	 * 0x100000000ULL是4g
+	 */
         memory_region_add_subregion(system_memory, 0x100000000ULL,
                                     ram_above_4g);
         e820_add_entry(0x100000000ULL, pcms->above_4g_mem_size, E820_RAM);
@@ -1633,6 +1673,11 @@ void pc_basic_device_init(ISABus *isa_bus, qemu_irq *gsi,
     pc_superio_init(isa_bus, create_fdctrl, no_vmport);
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|244| <<pc_init1>> pc_nic_init(pcmc, isa_bus, pci_bus);
+ *   - hw/i386/pc_q35.c|277| <<pc_q35_init>> pc_nic_init(pcmc, isa_bus, host_bus);
+ */
 void pc_nic_init(PCMachineClass *pcmc, ISABus *isa_bus, PCIBus *pci_bus)
 {
     int i;
@@ -2258,6 +2303,12 @@ static void pc_machine_set_pit(Object *obj, bool value, Error **errp)
     pcms->pit = value;
 }
 
+/*
+ * TypeInfo pc_machine_info.instance_init = pc_machine_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void pc_machine_initfn(Object *obj)
 {
     PCMachineState *pcms = PC_MACHINE(obj);
@@ -2274,6 +2325,9 @@ static void pc_machine_initfn(Object *obj)
     pcms->pit = true;
 }
 
+/*
+ * 在pc_machine_class_init设置成了MachineClass mc的reset
+ */
 static void pc_machine_reset(void)
 {
     CPUState *cs;
@@ -2363,6 +2417,12 @@ static void x86_nmi(NMIState *n, int cpu_index, Error **errp)
     }
 }
 
+/*
+ * TypeInfo pc_machine_info.class_init = pc_machine_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void pc_machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
@@ -2443,6 +2503,28 @@ static void pc_machine_class_init(ObjectClass *oc, void *data)
         pc_machine_get_pit, pc_machine_set_pit, &error_abort);
 }
 
+/*
+ * TYPE_PC_MACHINE is used by:
+ *   - hw/i386/x86-iommu.c|88| <<x86_iommu_realize>> PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));
+ *   - include/hw/i386/pc.h|142| <<PC_MACHINE>> OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|144| <<PC_MACHINE_GET_CLASS>> OBJECT_GET_CLASS(PCMachineClass, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|146| <<PC_MACHINE_CLASS>> OBJECT_CLASS_CHECK(PCMachineClass, (klass), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|954| <<DEFINE_PC_MACHINE>> .parent = TYPE_PC_MACHINE, \
+ *   - target/i386/kvm.c|1455| <<kvm_arch_init>> object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE) &&
+ *
+ *
+ * DEFINE_PC_MACHINE() is called by (i440x, q35, xenfv, isapc):
+ *   - hw/i386/pc_piix.c|1136| <<global>> DEFINE_PC_MACHINE(isapc, "isapc", pc_init_isa,
+ *   - hw/i386/pc_piix.c|1148| <<global>> DEFINE_PC_MACHINE(xenfv, "xenfv", pc_xen_hvm_init,
+ *   - hw/i386/pc_piix.c|417| <<DEFINE_I440FX_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *   - hw/i386/pc_q35.c|294| <<DEFINE_Q35_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *
+ * i440x: pc_init1()
+ * q35  : pc_q35_init()
+ *
+ * QEMU的默认是i440x
+ */
+
 static const TypeInfo pc_machine_info = {
     .name = TYPE_PC_MACHINE,
     .parent = TYPE_MACHINE,
@@ -2460,7 +2542,16 @@ static const TypeInfo pc_machine_info = {
 
 static void pc_machine_register_types(void)
 {
+    /*  
+     * 被外部好多好多调用
+     *
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&pc_machine_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(pc_machine_register_types)
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index dc09466..b8976c7 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -66,13 +66,26 @@ static const int ide_iobase2[MAX_IDE_BUS] = { 0x3f6, 0x376 };
 static const int ide_irq[MAX_IDE_BUS] = { 14, 15 };
 
 /* PC hardware initialisation */
+/*
+ * called or used by:
+ *   - hw/i386/pc_piix.c|379| <<pc_init_isa>> pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, TYPE_I440FX_PCI_DEVICE);
+ *   - hw/i386/pc_piix.c|388| <<pc_xen_hvm_init_pci>> pc_init1(machine,
+ *   - hw/i386/pc_piix.c|445| <<DEFINE_I440FX_MACHINE>> pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, \
+ *
+ * 一个例子:
+ * (gdb) bt
+ * #0  pc_init1 (machine=0x55555684f480, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:71
+ * #1  0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f480) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #2  0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f480) at hw/core/machine.c:830
+ * #3  0x00005555559dfb8f in main (argc=10, argv=0x7fffffffe498, envp=0x7fffffffe4f0) at vl.c:4516
+ */
 static void pc_init1(MachineState *machine,
                      const char *host_type, const char *pci_type)
 {
     PCMachineState *pcms = PC_MACHINE(machine);
     PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);
-    MemoryRegion *system_memory = get_system_memory();
-    MemoryRegion *system_io = get_system_io();
+    MemoryRegion *system_memory = get_system_memory();  // 返回system_memory (MemoryRegion)
+    MemoryRegion *system_io = get_system_io();          // 返回system_io (MemoryRegion)
     int i;
     PCIBus *pci_bus;
     ISABus *isa_bus;
@@ -123,7 +136,7 @@ static void pc_init1(MachineState *machine,
     if (xen_enabled()) {
         xen_hvm_init(pcms, &ram_memory);
     } else {
-        if (!pcms->max_ram_below_4g) {
+        if (!pcms->max_ram_below_4g) { // gdb调试的时候pcms->max_ram_below_4g是0
             pcms->max_ram_below_4g = 0xe0000000; /* default: 3.5G */
         }
         lowmem = pcms->max_ram_below_4g;
@@ -156,7 +169,9 @@ static void pc_init1(MachineState *machine,
         kvmclock_create();
     }
 
+    /* pcmc->pci_enabled在debug的时候是true */
     if (pcmc->pci_enabled) {
+        /* 分配一个MemoryRegion */
         pci_memory = g_new(MemoryRegion, 1);
         memory_region_init(pci_memory, NULL, "pci", UINT64_MAX);
         rom_memory = pci_memory;
@@ -178,6 +193,9 @@ static void pc_init1(MachineState *machine,
 
     /* allocate ram and load rom/bios */
     if (!xen_enabled()) {
+        /*
+	 * 刚刚在上面初始化完了above_4g_mem_size和below_4g_mem_size
+	 */
         pc_memory_init(pcms, system_memory,
                        rom_memory, &ram_memory);
     } else if (machine->kernel_filename != NULL) {
@@ -404,6 +422,37 @@ static void pc_xen_hvm_init(MachineState *machine)
 }
 #endif
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|438| <<global>> DEFINE_I440FX_MACHINE(v3_0, "pc-i440fx-3.0", NULL,
+ *   - hw/i386/pc_piix.c|449| <<global>> DEFINE_I440FX_MACHINE(v2_12, "pc-i440fx-2.12", NULL,
+ *   - hw/i386/pc_piix.c|458| <<global>> DEFINE_I440FX_MACHINE(v2_11, "pc-i440fx-2.11", NULL,
+ *   - hw/i386/pc_piix.c|468| <<global>> DEFINE_I440FX_MACHINE(v2_10, "pc-i440fx-2.10", NULL,
+ *   - hw/i386/pc_piix.c|478| <<global>> DEFINE_I440FX_MACHINE(v2_9, "pc-i440fx-2.9", NULL,
+ *   - hw/i386/pc_piix.c|487| <<global>> DEFINE_I440FX_MACHINE(v2_8, "pc-i440fx-2.8", NULL,
+ *   - hw/i386/pc_piix.c|497| <<global>> DEFINE_I440FX_MACHINE(v2_7, "pc-i440fx-2.7", NULL,
+ *   - hw/i386/pc_piix.c|510| <<global>> DEFINE_I440FX_MACHINE(v2_6, "pc-i440fx-2.6", NULL,
+ *   - hw/i386/pc_piix.c|523| <<global>> DEFINE_I440FX_MACHINE(v2_5, "pc-i440fx-2.5", NULL,
+ *   - hw/i386/pc_piix.c|536| <<global>> DEFINE_I440FX_MACHINE(v2_4, "pc-i440fx-2.4", NULL,
+ *   - hw/i386/pc_piix.c|547| <<global>> DEFINE_I440FX_MACHINE(v2_3, "pc-i440fx-2.3", pc_compat_2_3,
+ *   - hw/i386/pc_piix.c|560| <<global>> DEFINE_I440FX_MACHINE(v2_2, "pc-i440fx-2.2", pc_compat_2_2,
+ *   - hw/i386/pc_piix.c|575| <<global>> DEFINE_I440FX_MACHINE(v2_1, "pc-i440fx-2.1", pc_compat_2_1,
+ *   - hw/i386/pc_piix.c|608| <<global>> DEFINE_I440FX_MACHINE(v2_0, "pc-i440fx-2.0", pc_compat_2_0,
+ *   - hw/i386/pc_piix.c|625| <<global>> DEFINE_I440FX_MACHINE(v1_7, "pc-i440fx-1.7", pc_compat_1_7,
+ *   - hw/i386/pc_piix.c|639| <<global>> DEFINE_I440FX_MACHINE(v1_6, "pc-i440fx-1.6", pc_compat_1_6,
+ *   - hw/i386/pc_piix.c|650| <<global>> DEFINE_I440FX_MACHINE(v1_5, "pc-i440fx-1.5", pc_compat_1_5,
+ *   - hw/i386/pc_piix.c|662| <<global>> DEFINE_I440FX_MACHINE(v1_4, "pc-i440fx-1.4", pc_compat_1_4,
+ *   - hw/i386/pc_piix.c|694| <<global>> DEFINE_I440FX_MACHINE(v1_3, "pc-1.3", pc_compat_1_3,
+ *   - hw/i386/pc_piix.c|733| <<global>> DEFINE_I440FX_MACHINE(v1_2, "pc-1.2", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|776| <<global>> DEFINE_I440FX_MACHINE(v1_1, "pc-1.1", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|807| <<global>> DEFINE_I440FX_MACHINE(v1_0, "pc-1.0", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|821| <<global>> DEFINE_I440FX_MACHINE(v0_15, "pc-0.15", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|860| <<global>> DEFINE_I440FX_MACHINE(v0_14, "pc-0.14", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|897| <<global>> DEFINE_I440FX_MACHINE(v0_13, "pc-0.13", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|932| <<global>> DEFINE_I440FX_MACHINE(v0_12, "pc-0.12", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|964| <<global>> DEFINE_I440FX_MACHINE(v0_11, "pc-0.11", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|999| <<global>> DEFINE_I440FX_MACHINE(v0_10, "pc-0.10", pc_compat_0_13,
+ */
 #define DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn) \
     static void pc_init_##suffix(MachineState *machine) \
     { \
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index 532241e..85bc2d2 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -59,6 +59,17 @@
 #define MAX_SATA_PORTS     6
 
 /* PC hardware initialisation */
+/*
+ * called only by:
+ *   - hw/i386/pc_q35.c|305| <<DEFINE_Q35_MACHINE>> pc_q35_init(machine); \
+ *
+ * 一个例子:
+ * (gdb) bt
+ * #0  pc_q35_init (machine=0x55555684f880) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_q35.c:63
+ * #1  0x0000555555921d5e in pc_init_v3_0 (machine=0x55555684f880) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_q35.c:320
+ * #2  0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f880) at hw/core/machine.c:830
+ * #3  0x00005555559dfb8f in main (argc=12, argv=0x7fffffffe478, envp=0x7fffffffe4e0) at vl.c:4516
+ */
 static void pc_q35_init(MachineState *machine)
 {
     PCMachineState *pcms = PC_MACHINE(machine);
@@ -282,6 +293,19 @@ static void pc_q35_init(MachineState *machine)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_q35.c|320| <<global>> DEFINE_Q35_MACHINE(v3_0, "pc-q35-3.0", NULL,
+ *   - hw/i386/pc_q35.c|330| <<global>> DEFINE_Q35_MACHINE(v2_12, "pc-q35-2.12", NULL,
+ *   - hw/i386/pc_q35.c|342| <<global>> DEFINE_Q35_MACHINE(v2_11, "pc-q35-2.11", NULL,
+ *   - hw/i386/pc_q35.c|353| <<global>> DEFINE_Q35_MACHINE(v2_10, "pc-q35-2.10", NULL,
+ *   - hw/i386/pc_q35.c|362| <<global>> DEFINE_Q35_MACHINE(v2_9, "pc-q35-2.9", NULL,
+ *   - hw/i386/pc_q35.c|371| <<global>> DEFINE_Q35_MACHINE(v2_8, "pc-q35-2.8", NULL,
+ *   - hw/i386/pc_q35.c|381| <<global>> DEFINE_Q35_MACHINE(v2_7, "pc-q35-2.7", NULL,
+ *   - hw/i386/pc_q35.c|393| <<global>> DEFINE_Q35_MACHINE(v2_6, "pc-q35-2.6", NULL,
+ *   - hw/i386/pc_q35.c|405| <<global>> DEFINE_Q35_MACHINE(v2_5, "pc-q35-2.5", NULL,
+ *   - hw/i386/pc_q35.c|417| <<global>> DEFINE_Q35_MACHINE(v2_4, "pc-q35-2.4", NULL,
+ */
 #define DEFINE_Q35_MACHINE(suffix, name, compatfn, optionfn) \
     static void pc_init_##suffix(MachineState *machine) \
     { \
diff --git a/hw/i386/x86-iommu.c b/hw/i386/x86-iommu.c
index 8a01a2d..f86fb51 100644
--- a/hw/i386/x86-iommu.c
+++ b/hw/i386/x86-iommu.c
@@ -84,6 +84,12 @@ static void x86_iommu_realize(DeviceState *dev, Error **errp)
     X86IOMMUClass *x86_class = X86_IOMMU_GET_CLASS(dev);
     MachineState *ms = MACHINE(qdev_get_machine());
     MachineClass *mc = MACHINE_GET_CLASS(ms);
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     PCMachineState *pcms =
         PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));
     QLIST_INIT(&x86_iommu->iec_notifiers);
diff --git a/hw/net/e1000.c b/hw/net/e1000.c
index 13a9494..3137b6d 100644
--- a/hw/net/e1000.c
+++ b/hw/net/e1000.c
@@ -1652,6 +1652,23 @@ static void e1000_write_config(PCIDevice *pci_dev, uint32_t address,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  pci_e1000_realize (pci_dev=0x7fffe765e010, errp=0x7fffffffdc58) at hw/net/e1000.c:1657
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x7fffe765e010, errp=0x7fffffffdcd0) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x7fffe765e010, value=true, errp=0x7fffffffde90) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x7fffe765e010, v=0x55555775ae10, name=0x555555ee0a71 "realized", opaque=0x555557759330, errp=0x7fffffffde90) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x7fffe765e010, v=0x55555775ae10, name=0x555555ee0a71 "realized", errp=0x7fffffffde90) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x7fffe765e010, value=0x55555775ad10, name=0x555555ee0a71 "realized", errp=0x7fffffffde90) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x7fffe765e010, value=true, name=0x555555ee0a71 "realized", errp=0x7fffffffde90) at qom/object.c:1242
+ * #7  0x0000555555a72ba0 in qdev_init_nofail (dev=0x7fffe765e010) at hw/core/qdev.c:313
+ * #8  0x0000555555b36848 in pci_nic_init_nofail (nd=0x5555567449a0 <nd_table>, rootbus=0x5555569fecb0, default_model=0x555555ea8898 "e1000", default_devaddr=0x0) at hw/pci/pci.c:1874
+ * #9  0x0000555555919da1 in pc_nic_init (pcmc=0x555556836510, isa_bus=0x5555571cf2f0, pci_bus=0x5555569fecb0) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1648
+ * #10 0x000055555591d2b7 in pc_init1 (machine=0x55555684f700, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:244
+ * #11 0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f700) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #12 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f700) at hw/core/machine.c:830
+ * #13 0x00005555559dfb8f in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4516
+ */
 static void pci_e1000_realize(PCIDevice *pci_dev, Error **errp)
 {
     DeviceState *dev = DEVICE(pci_dev);
@@ -1692,6 +1709,26 @@ static void pci_e1000_realize(PCIDevice *pci_dev, Error **errp)
     d->mit_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, e1000_mit_timer, d);
 }
 
+/*
+ * (gdb) bt
+ * #0  qdev_e1000_reset (dev=0x7fffe765e010) at hw/net/e1000.c:1697
+ * #1  0x0000555555a749ce in device_reset (dev=0x7fffe765e010) at hw/core/qdev.c:1086
+ * #2  0x0000555555a729c1 in qdev_reset_one (dev=0x7fffe765e010, opaque=0x0) at hw/core/qdev.c:250
+ * #3  0x0000555555a735c7 in qdev_walk_children (dev=0x7fffe765e010, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/qdev.c:567
+ * #4  0x0000555555a77b53 in qbus_walk_children (bus=0x5555569fed40, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/bus.c:59
+ * #5  0x0000555555a7358b in qdev_walk_children (dev=0x5555569fca60, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/qdev.c:559
+ * #6  0x0000555555a77b53 in qbus_walk_children (bus=0x5555568acc70, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/bus.c:59
+ * #7  0x0000555555a72adb in qbus_reset_all (bus=0x5555568acc70) at hw/core/qdev.c:276
+ * #8  0x0000555555a72afe in qbus_reset_all_fn (opaque=0x5555568acc70) at hw/core/qdev.c:282
+ * #9  0x0000555555a78499 in qemu_devices_reset () at hw/core/reset.c:69
+ * #10 0x000055555591bfda in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #11 0x00005555559d8098 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #12 0x00005555559dfd6e in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4611
+ */
 static void qdev_e1000_reset(DeviceState *dev)
 {
     E1000State *d = E1000(dev);
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index b23e7f6..241d5a0 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -856,6 +856,18 @@ void *fw_cfg_modify_file(FWCfgState *s, const char *filename,
     return NULL;
 }
 
+/*
+ * used only by:
+ *   - hw/nvram/fw_cfg.c|874| <<fw_cfg_machine_ready>> qemu_register_reset(fw_cfg_machine_reset, s);
+ *
+ * (gdb) bt
+ * #0  get_boot_devices_list (size=0x7fffffffe078, ignore_suffixes=false) at bootdevice.c:214
+ * #1  0x0000555555b28ae5 in fw_cfg_machine_reset (opaque=0x5555569bc5d0) at hw/nvram/fw_cfg.c:864
+ * #2  0x0000555555a78499 in qemu_devices_reset () at hw/core/reset.c:69
+ * #3  0x000055555591bfda in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #4  0x00005555559d8098 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #5  0x00005555559dfd6e in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4611
+ */
 static void fw_cfg_machine_reset(void *opaque)
 {
     void *ptr;
@@ -870,6 +882,7 @@ static void fw_cfg_machine_reset(void *opaque)
 static void fw_cfg_machine_ready(struct Notifier *n, void *data)
 {
     FWCfgState *s = container_of(n, FWCfgState, machine_ready);
+    /* 把func(QEMUResetHandler)和opaque初始化成QEMUResetEntry, 插入reset_handlers链表 */
     qemu_register_reset(fw_cfg_machine_reset, s);
 }
 
diff --git a/hw/pci-host/piix.c b/hw/pci-host/piix.c
index 0e60834..da10632 100644
--- a/hw/pci-host/piix.c
+++ b/hw/pci-host/piix.c
@@ -214,6 +214,12 @@ static const VMStateDescription vmstate_i440fx = {
     }
 };
 
+/*
+ * used by hw/pci-host/piix.c|318| <<i440fx_pcihost_initfn>>:
+ * 317     object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_START, "uint32",
+ * 318                         i440fx_pcihost_get_pci_hole_start, 
+ * 319                         NULL, NULL, NULL, NULL);
+ */
 static void i440fx_pcihost_get_pci_hole_start(Object *obj, Visitor *v,
                                               const char *name, void *opaque,
                                               Error **errp)
@@ -228,6 +234,12 @@ static void i440fx_pcihost_get_pci_hole_start(Object *obj, Visitor *v,
     visit_type_uint32(v, name, &value, errp);
 }
 
+/*
+ * use by hw/pci-host/piix.c|328| <<i440fx_pcihost_initfn>>:
+ * 327     object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_END, "uint32",
+ * 328                         i440fx_pcihost_get_pci_hole_end, 
+ * 329                         NULL, NULL, NULL, NULL);
+ */
 static void i440fx_pcihost_get_pci_hole_end(Object *obj, Visitor *v,
                                             const char *name, void *opaque,
                                             Error **errp)
@@ -249,6 +261,12 @@ static void i440fx_pcihost_get_pci_hole_end(Object *obj, Visitor *v,
  * the 64bit PCI hole will start after "over 4G RAM" and the
  * reserved space for memory hotplug if any.
  */
+/*
+ * used by hw/pci-host/piix.c|338| <<i440fx_pcihost_initfn>>:
+ * 337     object_property_add(obj, PCI_HOST_PROP_PCI_HOLE64_START, "uint64",
+ * 338                         i440fx_pcihost_get_pci_hole64_start,
+ * 339                         NULL, NULL, NULL, NULL);
+ */
 static void i440fx_pcihost_get_pci_hole64_start(Object *obj, Visitor *v,
                                                 const char *name,
                                                 void *opaque, Error **errp)
@@ -272,6 +290,12 @@ static void i440fx_pcihost_get_pci_hole64_start(Object *obj, Visitor *v,
  * Then it is expanded to the PCI_HOST_PROP_PCI_HOLE64_SIZE
  * that can be configured by the user.
  */
+/*
+ * used by hw/pci-host/piix.c|348| <<i440fx_pcihost_initfn>>:
+ * 352     object_property_add(obj, PCI_HOST_PROP_PCI_HOLE64_END, "uint64",
+ * 353                         i440fx_pcihost_get_pci_hole64_end,
+ * 354                         NULL, NULL, NULL, NULL);
+ */
 static void i440fx_pcihost_get_pci_hole64_end(Object *obj, Visitor *v,
                                               const char *name, void *opaque,
                                               Error **errp)
@@ -291,15 +315,29 @@ static void i440fx_pcihost_get_pci_hole64_end(Object *obj, Visitor *v,
     visit_type_uint64(v, name, &value, errp);
 }
 
+/*
+ * TypeInfo i440fx_pcihost_info.instance_init = i440fx_pcihost_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void i440fx_pcihost_initfn(Object *obj)
 {
     PCIHostState *s = PCI_HOST_BRIDGE(obj);
 
     memory_region_init_io(&s->conf_mem, obj, &pci_host_conf_le_ops, s,
                           "pci-conf-idx", 4);
+    /*
+     * i440fx_pcihost_realize()调用sysbus_add_io()
+     * 为pci config space的内存加入到io内存中
+     */
     memory_region_init_io(&s->data_mem, obj, &pci_host_data_le_ops, s,
                           "pci-conf-data", 4);
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_START, "uint32",
                         i440fx_pcihost_get_pci_hole_start,
                         NULL, NULL, NULL, NULL);
@@ -317,6 +355,25 @@ static void i440fx_pcihost_initfn(Object *obj)
                         NULL, NULL, NULL, NULL);
 }
 
+/*
+ * (gdb) bt
+ * #0  i440fx_pcihost_realize (dev=0x5555569fca60, errp=0x7fffffffdcc0) at hw/pci-host/piix.c:322
+ * #1  0x0000555555a73ecc in device_set_realized (obj=0x5555569fca60, value=true, errp=0x7fffffffde80) at hw/core/qdev.c:826
+ * #2  0x0000555555c6020e in property_set_bool (obj=0x5555569fca60, v=0x5555569ffa60, name=0x555555ee0a71 "realized", opaque=0x5555569fd210, errp=0x7fffffffde80) at qom/object.c:1984
+ * #3  0x0000555555c5e493 in object_property_set (obj=0x5555569fca60, v=0x5555569ffa60, name=0x555555ee0a71 "realized", errp=0x7fffffffde80) at qom/object.c:1176
+ * #4  0x0000555555c6154b in object_property_set_qobject (obj=0x5555569fca60, value=0x5555569ff920, name=0x555555ee0a71 "realized", errp=0x7fffffffde80) at qom/qom-qobject.c:27
+ * #5  0x0000555555c5e778 in object_property_set_bool (obj=0x5555569fca60, value=true, name=0x555555ee0a71 "realized", errp=0x7fffffffde80) at qom/object.c:1242
+ * #6  0x0000555555a72ba0 in qdev_init_nofail (dev=0x5555569fca60) at hw/core/qdev.c:313
+ * #7  0x0000555555b2e6ac in i440fx_init (host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX", pi440fx_state=0x7fffffffdfb8, piix3_devfn=0x7fffffffdfa8, isa_bus=0x7fffffffdfb0, 
+ *     pic=0x5555569f9690, address_space_mem=0x555556850d40, address_space_io=0x555556851ad0, ram_size=2097152000, below_4g_mem_size=2097152000, above_4g_mem_size=0, pci_address_space=0x5555568faff0, 
+ *     ram_memory=0x5555568fb440) at hw/pci-host/piix.c:368
+ * #8  0x000055555591d014 in pc_init1 (machine=0x55555684f780, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:198
+ * #9  0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f780) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #10 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f780) at hw/core/machine.c:830
+ * #11 0x00005555559dfb8f in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4516
+ *
+ * 应该是为pci config space的内存加入到io内存中
+ */
 static void i440fx_pcihost_realize(DeviceState *dev, Error **errp)
 {
     PCIHostState *s = PCI_HOST_BRIDGE(dev);
@@ -329,6 +386,26 @@ static void i440fx_pcihost_realize(DeviceState *dev, Error **errp)
     sysbus_init_ioports(sbd, 0xcfc, 4);
 }
 
+/*
+ * (gdb) bt
+ * #0  i440fx_realize (dev=0x555556a36480, errp=0x7fffffffdbd8) at hw/pci-host/piix.c:334
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x555556a36480, errp=0x7fffffffdc50) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x555556a36480, value=true, errp=0x7fffffffde10) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x555556a36480, v=0x555556a3ace0, name=0x555555ee0a71 "realized", opaque=0x5555569ffab0, errp=0x7fffffffde10) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x555556a36480, v=0x555556a3ace0, name=0x555555ee0a71 "realized", errp=0x7fffffffde10) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x555556a36480, value=0x555556a3ac00, name=0x555555ee0a71 "realized", errp=0x7fffffffde10) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x555556a36480, value=true, name=0x555555ee0a71 "realized", errp=0x7fffffffde10) at qom/object.c:1242
+ * #7  0x0000555555a72ba0 in qdev_init_nofail (dev=0x555556a36480) at hw/core/qdev.c:313
+ * #8  0x0000555555b36f2e in pci_create_simple_multifunction (bus=0x5555569fed40, devfn=0, multifunction=false, name=0x555555ea882d "i440FX") at hw/pci/pci.c:2067
+ * #9  0x0000555555b36f92 in pci_create_simple (bus=0x5555569fed40, devfn=0, name=0x555555ea882d "i440FX") at hw/pci/pci.c:2078
+ * #10 0x0000555555b2e6c1 in i440fx_init (host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX", pi440fx_state=0x7fffffffdfb8, piix3_devfn=0x7fffffffdfa8, isa_bus=0x7fffffffdfb0, 
+ *     pic=0x5555569f9690, address_space_mem=0x555556850d40, address_space_io=0x555556851ad0, ram_size=2097152000, below_4g_mem_size=2097152000, above_4g_mem_size=0, pci_address_space=0x5555568faff0, 
+ *     ram_memory=0x5555568fb440) at hw/pci-host/piix.c:370
+ * #11 0x000055555591d014 in pc_init1 (machine=0x55555684f780, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:198
+ * #12 0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f780) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #13 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f780) at hw/core/machine.c:830
+ * #14 0x00005555559dfb8f in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4516
+ */
 static void i440fx_realize(PCIDevice *dev, Error **errp)
 {
     dev->config[I440FX_SMRAM] = 0x02;
@@ -338,6 +415,19 @@ static void i440fx_realize(PCIDevice *dev, Error **errp)
     }
 }
 
+/*
+ * called by: hw/i386/pc_piix.c pc_init1()
+ * pci_bus = i440fx_init(host_type,  ---> i440FX-pcihost
+ *                       pci_type,   ---> i440FX
+ *                       &i440fx_state, &piix3_devfn, &isa_bus, pcms->gsi,
+ *                       system_memory, system_io, machine->ram_size,
+ *                       pcms->below_4g_mem_size,
+ *                       pcms->above_4g_mem_size,
+ *                       pci_memory, ram_memory);
+ *
+ * #define TYPE_I440FX_PCI_HOST_BRIDGE "i440FX-pcihost"
+ * #define TYPE_I440FX_PCI_DEVICE "i440FX"
+ */
 PCIBus *i440fx_init(const char *host_type, const char *pci_type,
                     PCII440FXState **pi440fx_state,
                     int *piix3_devfn,
@@ -359,14 +449,25 @@ PCIBus *i440fx_init(const char *host_type, const char *pci_type,
     unsigned i;
     I440FXState *i440fx;
 
+    /*
+     * 因为只被pc_init1()调用, host_type是TYPE_I440FX_PCI_HOST_BRIDGE("i440FX-pcihost")
+     *
+     * 会间接调用到TYPE_I440FX_PCI_HOST_BRIDGE的instance_init=i440fx_pcihost_initfn()
+     */
     dev = qdev_create(NULL, host_type);
     s = PCI_HOST_BRIDGE(dev);
     b = pci_root_bus_new(dev, NULL, pci_address_space,
                          address_space_io, 0, TYPE_PCI_BUS);
     s->bus = b;
     object_property_add_child(qdev_get_machine(), "i440fx", OBJECT(dev), NULL);
+    /*
+     * 这里会间接调用i440fx_pcihost_realize()
+     */
     qdev_init_nofail(dev);
 
+    /*
+     * 这里会间接调用i440fx_realize()
+     */
     d = pci_create_simple(b, 0, pci_type);
     *pi440fx_state = I440FX_PCI_DEVICE(d);
     f = *pi440fx_state;
@@ -379,6 +480,7 @@ PCIBus *i440fx_init(const char *host_type, const char *pci_type,
                      IO_APIC_DEFAULT_ADDRESS - 1);
 
     /* setup pci memory mapping */
+    /* 把pci的address_space设为系统内存的subregion */
     pc_pci_as_mapping_init(OBJECT(f), f->system_memory,
                            f->pci_address_space);
 
@@ -449,6 +551,34 @@ PCIBus *find_i440fx(void)
     return s ? s->bus : NULL;
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_set_irq (irq=0x5555569fb240, level=1) at hw/core/irq.c:42
+ * #1  0x0000555555b2ec42 in piix3_set_irq_pic (piix3=0x5555571ccf50, pic_irq=11) at hw/pci-host/piix.c:455
+ * #2  0x0000555555b2ed3d in piix3_set_irq_level (piix3=0x5555571ccf50, pirq=2, level=1) at hw/pci-host/piix.c:487
+ * #3  0x0000555555b2ed70 in piix3_set_irq (opaque=0x5555571ccf50, pirq=2, level=1) at hw/pci-host/piix.c:493
+ * #4  0x0000555555b32997 in pci_change_irq_level (pci_dev=0x7fffe765e010, irq_num=2, change=1) at hw/pci/pci.c:234
+ * #5  0x0000555555b359b4 in pci_irq_handler (opaque=0x7fffe765e010, irq_num=0, level=1) at hw/pci/pci.c:1406
+ * #6  0x0000555555b35a49 in pci_set_irq (pci_dev=0x7fffe765e010, level=1) at hw/pci/pci.c:1424
+ * #7  0x0000555555af30cc in set_interrupt_cause (s=0x7fffe765e010, index=0, val=16) at hw/net/e1000.c:329
+ * #8  0x0000555555af3154 in set_ics (s=0x7fffe765e010, index=50, val=16) at hw/net/e1000.c:347
+ * #9  0x0000555555af5687 in e1000_mmio_write (opaque=0x7fffe765e010, addr=200, val=16, size=4) at hw/net/e1000.c:1277
+ * #10 0x0000555555864b2d in memory_region_write_accessor (mr=0x7fffe7660910, addr=200, value=0x7fffe7ffe7e8, size=4, shift=0, mask=4294967295, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #11 0x0000555555864d45 in access_with_adjusted_size (addr=200, value=0x7fffe7ffe7e8, size=4, access_size_min=4, access_size_max=4, access_fn=0x555555864a43 <memory_region_write_accessor>,
+ *     mr=0x7fffe7660910, 
+ *     attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #12 0x000055555586796d in memory_region_dispatch_write (mr=0x7fffe7660910, addr=200, data=16, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #13 0x000055555580399f in flatview_write_continue (fv=0x7fffe02bd1b0, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4, addr1=200, l=4, mr=0x7fffe7660910)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #14 0x0000555555803ae9 in flatview_write (fv=0x7fffe02bd1b0, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #15 0x0000555555803def in address_space_write (as=0x555556721a80 <address_space_memory>, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #16 0x0000555555803e40 in address_space_rw (as=0x555556721a80 <address_space_memory>, addr=4273733832, attrs=..., buf=0x7ffff7fec028 "\020", len=4, is_write=true) at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #17 0x0000555555882b7d in kvm_cpu_exec (cpu=0x5555568d7d60) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1979
+ * #18 0x0000555555849eac in qemu_kvm_cpu_thread_fn (arg=0x5555568d7d60) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #19 0x0000555555d92dd7 in qemu_thread_start (args=0x5555568f99c0) at util/qemu-thread-posix.c:504
+ * #20 0x00007ffff4ca06ba in start_thread (arg=0x7fffe7fff700) at pthread_create.c:333
+ * #21 0x00007ffff49d641d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 /* PIIX3 PCI to ISA bridge */
 static void piix3_set_irq_pic(PIIX3State *piix3, int pic_irq)
 {
@@ -755,6 +885,9 @@ static const TypeInfo piix3_xen_info = {
     .class_init    = piix3_xen_class_init,
 };
 
+/*
+ * TypeInfo i440fx_info.class_init = i440fx_class_init()
+ */
 static void i440fx_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(klass);
@@ -804,6 +937,10 @@ static const IGDHostInfo igd_host_bridge_infos[] = {
     {0xa8, 4},  /* SNB: base of GTT stolen memory */
 };
 
+/*
+ * called only by:
+ *   - hw/pci-host/piix.c|879| <<igd_pt_i440fx_realize>> host_pci_config_read(pos, len, &val, &local_err);
+ */
 static void host_pci_config_read(int pos, int len, uint32_t *val, Error **errp)
 {
     int rc, config_fd;
@@ -883,6 +1020,10 @@ static const char *i440fx_pcihost_root_bus_path(PCIHostState *host_bridge,
     return "0000:00";
 }
 
+/*
+ * used only by:
+ *   - hw/pci-host/piix.c|938| <<i440fx_pcihost_class_init>> dc->props = i440fx_props;
+ */
 static Property i440fx_props[] = {
     DEFINE_PROP_SIZE(PCI_HOST_PROP_PCI_HOLE64_SIZE, I440FXState,
                      pci_hole64_size, I440FX_PCI_HOST_HOLE64_SIZE_DEFAULT),
@@ -891,6 +1032,12 @@ static Property i440fx_props[] = {
     DEFINE_PROP_END_OF_LIST(),
 };
 
+/*
+ * TypeInfo i440fx_pcihost_info.class_init = i440fx_pcihost_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void i440fx_pcihost_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(klass);
@@ -914,6 +1061,7 @@ static const TypeInfo i440fx_pcihost_info = {
 
 static void i440fx_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&i440fx_info);
     type_register_static(&igd_passthrough_i440fx_info);
     type_register_static(&piix3_pci_type_info);
@@ -922,4 +1070,8 @@ static void i440fx_register_types(void)
     type_register_static(&i440fx_pcihost_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(i440fx_register_types)
diff --git a/hw/pci/msi.c b/hw/pci/msi.c
index 5e05ce5..cd68417 100644
--- a/hw/pci/msi.c
+++ b/hw/pci/msi.c
@@ -332,11 +332,41 @@ void msi_notify(PCIDevice *dev, unsigned int vector)
     msi_send_message(dev, msg);
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_apic_mem_write (opaque=0x5555568aaf70, addr=4096, data=16421, size=4) at /home/zhang/kvm/qemu-3.0.0/hw/i386/kvm/apic.c:200
+ * #1  0x0000555555864b2d in memory_region_write_accessor (mr=0x5555568aaff0, addr=4096, value=0x7fffffffde98, size=4, shift=0, mask=4294967295, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #2  0x0000555555864d45 in access_with_adjusted_size (addr=4096, value=0x7fffffffde98, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555864a43 <memory_region_write_accessor>,
+ *     mr=0x5555568aaff0, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #3  0x000055555586796d in memory_region_dispatch_write (mr=0x5555568aaff0, addr=4096, data=16421, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #4  0x0000555555805285 in address_space_stl_internal (as=0x5555579aa130, addr=4276097024, val=16421, attrs=..., result=0x0, endian=DEVICE_LITTLE_ENDIAN) at /home/zhang/kvm/qemu-3.0.0/memory_ldst.inc.c:349
+ * #5  0x00005555558053bd in address_space_stl_le (as=0x5555579aa130, addr=4276097024, val=16421, attrs=..., result=0x0) at /home/zhang/kvm/qemu-3.0.0/memory_ldst.inc.c:386
+ * #6  0x0000555555b3c744 in msi_send_message (dev=0x5555579a9f20, msg=...) at hw/pci/msi.c:340
+ * #7  0x0000555555b3b2d2 in msix_notify (dev=0x5555579a9f20, vector=1) at hw/pci/msix.c:494
+ * #8  0x0000555555a5b4dc in nvme_irq_assert (n=0x5555579a9f20, cq=0x5555578a3410) at hw/block/nvme.c:114
+ * #9  0x0000555555a5bf1b in nvme_post_cqes (opaque=0x5555578a3410) at hw/block/nvme.c:275
+ * #10 0x0000555555d8d3a1 in timerlist_run_timers (timer_list=0x55555684ef50) at util/qemu-timer.c:536
+ * #11 0x0000555555d8d3ed in qemu_clock_run_timers (type=QEMU_CLOCK_VIRTUAL) at util/qemu-timer.c:547
+ * #12 0x0000555555d8d7c2 in qemu_clock_run_all_timers () at util/qemu-timer.c:667
+ * #13 0x0000555555d8ded2 in main_loop_wait (nonblocking=0) at util/main-loop.c:503
+ * #14 0x00005555559d8681 in main_loop () at vl.c:1866
+ * #15 0x00005555559dfe85 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4644
+ *
+ * called by:
+ *   - hw/pci/msi.c|332| <<msi_notify>> msi_send_message(dev, msg);
+ *   - hw/pci/msix.c|523| <<msix_notify>> msi_send_message(dev, msg);
+ */
 void msi_send_message(PCIDevice *dev, MSIMessage msg)
 {
     MemTxAttrs attrs = {};
 
     attrs.requester_id = pci_requester_id(dev);
+    /*
+     * 对于mmio, 会调用memory_region_dispatch_write()
+     *
+     * 在kvm上测试nvme的时候, ops是kvm_apic_io_ops
+     * 在x86_cpu_apic_realize()为apic重叠的部分设置的kvm_apic_io_ops
+     */
     address_space_stl_le(&dev->bus_master_as, msg.address, msg.data,
                          attrs, NULL);
 }
diff --git a/hw/pci/msix.c b/hw/pci/msix.c
index c944c02..72cf1d1 100644
--- a/hw/pci/msix.c
+++ b/hw/pci/msix.c
@@ -142,6 +142,10 @@ static void msix_update_function_masked(PCIDevice *dev)
 }
 
 /* Handle MSI-X capability config write. */
+/*
+ * called by:
+ *   - hw/pci/pci.c|1405| <<pci_default_write_config>> msix_write_config(d, addr, val_in, l);
+ */
 void msix_write_config(PCIDevice *dev, uint32_t addr,
                        uint32_t val, int len)
 {
@@ -266,6 +270,17 @@ static void msix_mask_all(struct PCIDevice *dev, unsigned nentries)
  * also means a programming error, except device assignment, which can check
  * if a real HW is broken.
  */
+/*
+ * called by:
+ *   - hw/net/e1000e.c|292| <<e1000e_init_msix>> int res = msix_init(PCI_DEVICE(s), E1000E_MSIX_VEC_NUM,
+ *   - hw/net/rocker/rocker.c|1245| <<rocker_msix_init>> err = msix_init(dev, ROCKER_MSIX_VEC_COUNT(r->fp_ports),
+ *   - hw/net/vmxnet3.c|2217| <<vmxnet3_init_msix>> int res = msix_init(d, VMXNET3_MAX_INTRS,
+ *   - hw/pci/msix.c|371| <<msix_init_exclusive_bar>> ret = msix_init(dev, nentries, &dev->msix_exclusive_bar, bar_nr,
+ *   - hw/rdma/vmw/pvrdma_main.c|490| <<init_msix>> rc = msix_init(pdev, RDMA_MAX_INTRS, &dev->msix, RDMA_MSIX_BAR_IDX,
+ *   - hw/scsi/megasas.c|2351| <<megasas_scsi_realize>> msix_init(dev, 15, &s->mmio_io, b->mmio_bar, 0x2000,
+ *   - hw/usb/hcd-xhci.c|3432| <<usb_xhci_realize>> msix_init(dev, xhci->numintrs,
+ *   - hw/vfio/pci.c|1550| <<vfio_msix_setup>> ret = msix_init(&vdev->pdev, vdev->msix->entries,
+ */
 int msix_init(struct PCIDevice *dev, unsigned short nentries,
               MemoryRegion *table_bar, uint8_t table_bar_nr,
               unsigned table_offset, MemoryRegion *pba_bar,
@@ -476,6 +491,36 @@ int msix_enabled(PCIDevice *dev)
 }
 
 /* Send an MSI-X message */
+/*
+ * nvme的一个例子:
+ * (gdb) bt
+ * #0  msi_send_message (dev=0x555557adc1b0, msg=...) at hw/pci/msi.c:337
+ * #1  0x0000555555b3b2d2 in msix_notify (dev=0x555557adc1b0, vector=2) at hw/pci/msix.c:494
+ * #2  0x0000555555a5b4dc in nvme_irq_assert (n=0x555557adc1b0, cq=0x555557a81660) at hw/block/nvme.c:114
+ * #3  0x0000555555a5bf1b in nvme_post_cqes (opaque=0x555557a81660) at hw/block/nvme.c:275
+ * #4  0x0000555555d8d3a1 in timerlist_run_timers (timer_list=0x55555684f290) at util/qemu-timer.c:536
+ * #5  0x0000555555d8d3ed in qemu_clock_run_timers (type=QEMU_CLOCK_VIRTUAL) at util/qemu-timer.c:547
+ * #6  0x0000555555d8d7c2 in qemu_clock_run_all_timers () at util/qemu-timer.c:667
+ * #7  0x0000555555d8ded2 in main_loop_wait (nonblocking=0) at util/main-loop.c:503
+ * #8  0x00005555559d8681 in main_loop () at vl.c:1866
+ * #9  0x00005555559dfe85 in main (argc=16, argv=0x7fffffffe388, envp=0x7fffffffe410) at vl.c:4644
+ *
+ * virtio block在eventfd关闭下的情况:
+ * (gdb) bt
+ * #0  msix_notify (dev=0x5555579d19b0, vector=1) at hw/pci/msix.c:487
+ * #1  0x0000555555beaa74 in virtio_pci_notify (d=0x5555579d19b0, vector=1) at hw/virtio/virtio-pci.c:72
+ * #2  0x00005555558fedaf in virtio_notify_vector (vdev=0x5555579d9b20, vector=1) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1117
+ * #3  0x0000555555900542 in virtio_irq (vq=0x7fffe6c9c010) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1680
+ * #4  0x000055555590059f in virtio_notify (vdev=0x5555579d9b20, vq=0x7fffe6c9c010) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1695
+ * #5  0x00005555558b1909 in virtio_blk_req_complete (req=0x7fffe02154f0, status=0 '\000') at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:59
+ * #6  0x00005555558b1b41 in virtio_blk_rw_complete (opaque=0x7fffe02154f0, ret=0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:121
+ * #7  0x0000555555ce9d35 in blk_aio_complete (acb=0x7fffe0215350) at block/block-backend.c:1336
+ * #8  0x0000555555ce9f49 in blk_aio_read_entry (opaque=0x7fffe0215350) at block/block-backend.c:1389
+ * #9  0x0000555555dd04e6 in coroutine_trampoline (i0=-534635840, i1=32767) at util/coroutine-ucontext.c:116
+ * #10 0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #11 0x00007fffe7ffdbf0 in ?? ()
+ * #12 0x0000000000000000 in ?? ()
+ */
 void msix_notify(PCIDevice *dev, unsigned vector)
 {
     MSIMessage msg;
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index 80bc459..529d100 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -86,10 +86,21 @@ static const VMStateDescription vmstate_pcibus = {
     }
 };
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|108| <<pcibus_machine_done>> pci_init_bus_master(bus->devices[i]); --> 初始化?
+ *   - hw/pci/pci.c|1149| <<do_pci_register_device>> pci_init_bus_master(pci_dev);     --> hotplug?
+ */
 static void pci_init_bus_master(PCIDevice *pci_dev)
 {
+    /*
+     * 如果没使用iommu就返回address_space_memory
+     */
     AddressSpace *dma_as = pci_device_iommu_address_space(pci_dev);
 
+    /*
+     * 把pci_dev->bus_master_enable_region设置为dma_as->root的一个alias, 也就是表示dma_as->root的一部分
+     */
     memory_region_init_alias(&pci_dev->bus_master_enable_region,
                              OBJECT(pci_dev), "bus master",
                              dma_as->root, 0, memory_region_size(dma_as->root));
@@ -147,6 +158,9 @@ static uint16_t pcibus_numa_node(PCIBus *bus)
     return NUMA_NODE_UNASSIGNED;
 }
 
+/*
+ * TypeInfo pci_bus_info.class_init = pci_bus_class_init()
+ */
 static void pci_bus_class_init(ObjectClass *klass, void *data)
 {
     BusClass *k = BUS_CLASS(klass);
@@ -231,6 +245,9 @@ static void pci_change_irq_level(PCIDevice *pci_dev, int irq_num, int change)
         pci_dev = bus->parent_dev;
     }
     bus->irq_count[irq_num] += change;
+    /*
+     * 在e1000测试的是piix3_set_irq()
+     */
     bus->set_irq(bus->irq_opaque, irq_num, bus->irq_count[irq_num] != 0);
 }
 
@@ -260,6 +277,11 @@ void pci_device_deassert_intx(PCIDevice *dev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|308| <<pci_device_reset>> pci_do_device_reset(dev);
+ *   - hw/pci/pci.c|323| <<pcibus_reset>> pci_do_device_reset(bus->devices[i]);
+ */
 static void pci_do_device_reset(PCIDevice *dev)
 {
     int r;
@@ -310,6 +332,10 @@ void pci_device_reset(PCIDevice *dev)
  * Called via qbus_reset_all on RST# assert, after the devices
  * have been reset qdev_reset_all-ed already.
  */
+/*
+ * used by:
+ *   - hw/pci/pci.c|163| <<pci_bus_class_init>> k->reset = pcibus_reset; k是BusClass, 在bus_set_realized()被调用
+ */
 static void pcibus_reset(BusState *qbus)
 {
     PCIBus *bus = DO_UPCAST(PCIBus, qbus, qbus);
@@ -362,6 +388,23 @@ const char *pci_root_bus_path(PCIDevice *dev)
     return rootbus->qbus.name;
 }
 
+/*
+ * nvme的例子, 就调用了一次
+ * (gdb) bt
+ * #0  pci_root_bus_init (bus=0x555556775ae0, parent=0x555556774010, address_space_mem=0x5555566721b0, 
+ *     address_space_io=0x5555565c8ff0, devfn_min=0 '\000') at hw/pci/pci.c:370
+ * #1  0x0000555555af3b4b in pci_root_bus_new (parent=0x555556774010, name=0x0, address_space_mem=0x5555566721b0, 
+ *     address_space_io=0x5555565c8ff0, devfn_min=0 '\000', typename=0x555555e21357 "PCI") at hw/pci/pci.c:411
+ * #2  0x0000555555aef008 in i440fx_init (host_type=0x555555da4eec "i440FX-pcihost", pci_type=0x555555da4ee5 "i440FX", 
+ *     pi440fx_state=0x7fffffffdfe8, piix3_devfn=0x7fffffffdfd8, isa_bus=0x7fffffffdfe0, pic=0x555556770450, 
+ *     address_space_mem=0x5555565c81f0, address_space_io=0x5555565c8ff0, ram_size=3145728000, below_4g_mem_size=3145728000, 
+ *     above_4g_mem_size=0, pci_address_space=0x5555566721b0, ram_memory=0x555556672600) at hw/pci-host/piix.c:364
+ * #3  0x00005555558e344f in pc_init1 (machine=0x5555565c6490, host_type=0x555555da4eec "i440FX-pcihost", 
+ *     pci_type=0x555555da4ee5 "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:198
+ * #4  0x00005555558e3d91 in pc_init_v3_0 (machine=0x5555565c6490) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #5  0x0000555555a359ed in machine_run_board_init (machine=0x5555565c6490) at hw/core/machine.c:830
+ * #6  0x000055555599dcb8 in main (argc=14, argv=0x7fffffffe438, envp=0x7fffffffe4b0) at vl.c:4516
+ */
 static void pci_root_bus_init(PCIBus *bus, DeviceState *parent,
                               MemoryRegion *address_space_mem,
                               MemoryRegion *address_space_io,
@@ -846,10 +889,15 @@ static void pci_init_multifunction(PCIBus *bus, PCIDevice *dev, Error **errp)
     }
 }
 
+/*
+ * called by only:
+ *   - hw/pci/pci.c|1037| <<do_pci_register_device>> pci_config_alloc(pci_dev);
+ */
 static void pci_config_alloc(PCIDevice *pci_dev)
 {
     int config_size = pci_config_size(pci_dev);
 
+    /* 下面全都是一个uint8_t的指针 */
     pci_dev->config = g_malloc0(config_size);
     pci_dev->cmask = g_malloc0(config_size);
     pci_dev->wmask = g_malloc0(config_size);
@@ -964,15 +1012,91 @@ static bool pci_bus_devfn_reserved(PCIBus *bus, int devfn)
 }
 
 /* -1 for devfn means auto assign */
+/*
+ * called only by:
+ *   - hw/pci/pci.c|2021| <<pci_qdev_realize>> pci_dev = do_pci_register_device(pci_dev,
+ *
+ * hotplut一个e1000网卡的例子:
+ * (gdb) bt
+ * #0  do_pci_register_device (pci_dev=0x5555566fcc20, name=0x5555565190c0 "e1000", devfn=-1, errp=0x7fffffffcb60) at hw/pci/pci.c:970
+ * #1  0x0000555555af76d3 in pci_qdev_realize (qdev=0x5555566fcc20, errp=0x7fffffffcb60) at hw/pci/pci.c:2021
+ * #2  0x0000555555a2d447 in device_set_realized (obj=0x5555566fcc20, value=true, errp=0x7fffffffcd30) at hw/core/qdev.c:826
+ * #3  0x0000555555c21bc7 in property_set_bool (obj=0x5555566fcc20, v=0x5555574bba20, name=0x555555db778a "realized", opaque=0x5555569259d0, errp=0x7fffffffcd30)
+ *     at qom/object.c:1984
+ * #4  0x0000555555c1fe4c in object_property_set (obj=0x5555566fcc20, v=0x5555574bba20, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1176
+ * #5  0x0000555555c22f04 in object_property_set_qobject (obj=0x5555566fcc20, value=0x555557193700, name=0x555555db778a "realized", errp=0x7fffffffcd30)
+ *     at qom/qom-qobject.c:27
+ * #6  0x0000555555c20131 in object_property_set_bool (obj=0x5555566fcc20, value=true, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1242
+ * #7  0x0000555555990749 in qdev_device_add (opts=0x5555568b4290, errp=0x7fffffffcda0) at qdev-monitor.c:627
+ * #8  0x0000555555990f32 in qmp_device_add (qdict=0x555556ff10c0, ret_data=0x0, errp=0x7fffffffcde0) at qdev-monitor.c:807
+ * #9  0x00005555559bebd7 in hmp_device_add (mon=0x5555565fb820, qdict=0x555556ff10c0) at hmp.c:2008
+ * #10 0x00005555558230ac in handle_hmp_command (mon=0x5555565fb820, cmdline=0x5555565fe2cb "e1000,netdev=nd1") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #11 0x0000555555825467 in monitor_command_cb (opaque=0x5555565fb820, cmdline=0x5555565fe2c0 "device_add e1000,netdev=nd1", readline_opaque=0x0)
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #12 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565fe2c0, ch=13) at util/readline.c:393
+ * #13 0x00005555558253ba in monitor_read (opaque=0x5555565fb820, buf=0x7fffffffcfa0 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #14 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #15 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #16 0x0000555555cce691 in fd_chr_read (chan=0x5555565d35f0, cond=G_IO_IN, opaque=0x5555565d33e0) at chardev/char-fd.c:66
+ * #17 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x5555574b9b40, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d33e0)
+ *     at io/channel-watch.c:84
+ * #18 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #19 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #20 0x0000555555d4f990 in os_host_main_loop_wait (timeout=198513349) at util/main-loop.c:238
+ * #21 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #22 0x00005555559967aa in main_loop () at vl.c:1866
+ * #23 0x000055555599dfbd in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4644
+ *
+ *
+ * hotplug一个nvme的例子:
+ * (gdb) bt
+ * #0  memory_region_add_subregion (mr=0x55555706cae0, offset=0, subregion=0x55555706cbd0) at /home/zhang/kvm/qemu-3.0.0/memory.c:2327
+ * #1  0x0000555555af2ecb in pci_init_bus_master (pci_dev=0x55555706c870) at hw/pci/pci.c:97
+ * #2  0x0000555555af5249 in do_pci_register_device (pci_dev=0x55555706c870, name=0x5555564e9f40 "nvme", devfn=32, errp=0x7fffffffcbf0) at hw/pci/pci.c:1030
+ * #3  0x0000555555af76d3 in pci_qdev_realize (qdev=0x55555706c870, errp=0x7fffffffcbf0) at hw/pci/pci.c:2021
+ * #4  0x0000555555a2d447 in device_set_realized (obj=0x55555706c870, value=true, errp=0x7fffffffcdc0) at hw/core/qdev.c:826
+ * #5  0x0000555555c21bc7 in property_set_bool (obj=0x55555706c870, v=0x555556cfc690, name=0x555555db778a "realized", opaque=0x5555575902f0, errp=0x7fffffffcdc0)
+ *     at qom/object.c:1984
+ * #6  0x0000555555c1fe4c in object_property_set (obj=0x55555706c870, v=0x555556cfc690, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1176
+ * #7  0x0000555555c22f04 in object_property_set_qobject (obj=0x55555706c870, value=0x555557184ef0, name=0x555555db778a "realized", errp=0x7fffffffcdc0)
+ *     at qom/qom-qobject.c:27
+ * #8  0x0000555555c20131 in object_property_set_bool (obj=0x55555706c870, value=true, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1242
+ * #9  0x0000555555990749 in qdev_device_add (opts=0x555557185290, errp=0x7fffffffce30) at qdev-monitor.c:627
+ * #10 0x0000555555990f32 in qmp_device_add (qdict=0x555557164a40, ret_data=0x0, errp=0x7fffffffce70) at qdev-monitor.c:807
+ * #11 0x00005555559bebd7 in hmp_device_add (mon=0x5555565e0bd0, qdict=0x555557164a40) at hmp.c:2008
+ * #12 0x00005555558230ac in handle_hmp_command (mon=0x5555565e0bd0, cmdline=0x5555565f005b "nvme,drive=lightnvme,serial=deadbeaf1")
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #13 0x0000555555825467 in monitor_command_cb (opaque=0x5555565e0bd0, cmdline=0x5555565f0050 "device_add nvme,drive=lightnvme,serial=deadbeaf1", 
+ *     readline_opaque=0x0) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #14 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565f0050, ch=13) at util/readline.c:393
+ * #15 0x00005555558253ba in monitor_read (opaque=0x5555565e0bd0, buf=0x7fffffffd030 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #16 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #17 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #18 0x0000555555cce691 in fd_chr_read (chan=0x5555565d3310, cond=G_IO_IN, opaque=0x5555565d3100) at chardev/char-fd.c:66
+ * #19 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x555556ff37e0, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d3100)
+ *     at io/channel-watch.c:84
+ * #20 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #21 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #22 0x0000555555d4f990 in os_host_main_loop_wait (timeout=38256335) at util/main-loop.c:238
+ * #23 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #24 0x00005555559967aa in main_loop () at vl.c:1866
+ * #25 0x000055555599dfbd in main (argc=12, argv=0x7fffffffe4a8, envp=0x7fffffffe510) at vl.c:4644
+ */
 static PCIDevice *do_pci_register_device(PCIDevice *pci_dev,
                                          const char *name, int devfn,
                                          Error **errp)
 {
     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pci_dev);
+    /*
+     * virtio blk pci来的时候config_read和config_write都是0
+     */
     PCIConfigReadFunc *config_read = pc->config_read;
     PCIConfigWriteFunc *config_write = pc->config_write;
     Error *local_err = NULL;
     DeviceState *dev = DEVICE(pci_dev);
+    /*
+     * DeviceState.parent_bus类型转换
+     */
     PCIBus *bus = pci_get_bus(pci_dev);
 
     /* Only pci bridges can be attached to extra PCI root buses */
@@ -1021,12 +1145,23 @@ static PCIDevice *do_pci_register_device(PCIDevice *pci_dev,
     pci_dev->requester_id_cache = pci_req_id_cache_get(pci_dev);
     pstrcpy(pci_dev->name, sizeof(pci_dev->name), name);
 
+    /*
+     * 初始化MemoryRegion,比如:
+     *     根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     *     MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+     *     然后简单初始化MemoryRegion的各个field
+     */
     memory_region_init(&pci_dev->bus_master_container_region, OBJECT(pci_dev),
                        "bus master container", UINT64_MAX);
     address_space_init(&pci_dev->bus_master_as,
                        &pci_dev->bus_master_container_region, pci_dev->name);
 
     if (qdev_hotplug) {
+        /*
+	 * pci_init_bus_master()被以下调用:
+	 *   - hw/pci/pci.c|108| <<pcibus_machine_done>> pci_init_bus_master(bus->devices[i]); --> 初始化?
+	 *   - hw/pci/pci.c|1149| <<do_pci_register_device>> pci_init_bus_master(pci_dev);     --> hotplug?
+	 */
         pci_init_bus_master(pci_dev);
     }
     pci_dev->irq_state = 0;
@@ -1127,10 +1262,17 @@ void pci_register_bar(PCIDevice *pci_dev, int region_num,
     r->size = size;
     r->type = type;
     r->memory = memory;
+    /*
+     * address_space_io是MemoryRegion
+     */
     r->address_space = type & PCI_BASE_ADDRESS_SPACE_IO
                         ? pci_get_bus(pci_dev)->address_space_io
                         : pci_get_bus(pci_dev)->address_space_mem;
 
+    /*
+     * nvme调用到这里时r->address_space (MemoryRegion)的name是"pci"
+     */
+
     wmask = ~(size - 1);
     if (region_num == PCI_ROM_SLOT) {
         /* ROM enable bit is writable */
@@ -1211,11 +1353,21 @@ void pci_unregister_vga(PCIDevice *pci_dev)
     pci_dev->has_vga = false;
 }
 
+/*
+ * called by:
+ *   - hw/display/vmware_vga.c|863| <<vmsvga_value_read>> ret = pci_get_bar_addr(PCI_DEVICE(pci_vmsvga), 1);
+ *   - hw/display/vmware_vga.c|899| <<vmsvga_value_read>> ret = pci_get_bar_addr(PCI_DEVICE(pci_vmsvga), 2);
+ */
 pcibus_t pci_get_bar_addr(PCIDevice *pci_dev, int region_num)
 {
     return pci_dev->io_regions[region_num].addr;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|1313| <<pci_update_mappings>> new_addr = pci_bar_address(d, i, r->type, r->size);
+ *   - hw/pci/pci.c|2624| <<pci_dev_get_w64>> lob = pci_bar_address(dev, i, r->type, r->size);
+ */
 static pcibus_t pci_bar_address(PCIDevice *d,
 				int reg, uint8_t type, pcibus_t size)
 {
@@ -1288,6 +1440,158 @@ static pcibus_t pci_bar_address(PCIDevice *d,
     return new_addr;
 }
 
+/*
+ * nvme第一次的例子:
+ * (gdb) bt
+ * #0  pci_update_mappings (d=0x555557720d80) at hw/pci/pci.c:1297
+ * #1  0x0000555555af363d in pci_do_device_reset (dev=0x555557720d80) at hw/pci/pci.c:292
+ * #2  0x0000555555af36eb in pcibus_reset (qbus=0x555556775ae0) at hw/pci/pci.c:320
+ * #3  0x0000555555a2bfa3 in qbus_reset_one (bus=0x555556775ae0, opaque=0x0) at hw/core/qdev.c:259
+ * #4  0x0000555555a3110a in qbus_walk_children (bus=0x555556775ae0, pre_devfn=0x0, pre_busfn=0x0, 
+ *     post_devfn=0x555555a2bf20 <qdev_reset_one>, post_busfn=0x555555a2bf43 <qbus_reset_one>, opaque=0x0) at hw/core/bus.c:68
+ * #5  0x0000555555a2cb06 in qdev_walk_children (dev=0x555556774010, pre_devfn=0x0, pre_busfn=0x0, 
+ *     post_devfn=0x555555a2bf20 <qdev_reset_one>, post_busfn=0x555555a2bf43 <qbus_reset_one>, opaque=0x0) at hw/core/qdev.c:559
+ * #6  0x0000555555a310ce in qbus_walk_children (bus=0x555556624220, pre_devfn=0x0, pre_busfn=0x0, 
+ *     post_devfn=0x555555a2bf20 <qdev_reset_one>, post_busfn=0x555555a2bf43 <qbus_reset_one>, opaque=0x0) at hw/core/bus.c:59
+ * #7  0x0000555555a2c056 in qbus_reset_all (bus=0x555556624220) at hw/core/qdev.c:276
+ * #8  0x0000555555a2c079 in qbus_reset_all_fn (opaque=0x555556624220) at hw/core/qdev.c:282
+ * #9  0x0000555555a31a14 in qemu_devices_reset () at hw/core/reset.c:69
+ * #10 0x00005555558e2415 in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #11 0x00005555559961c1 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #12 0x000055555599dea6 in main (argc=14, argv=0x7fffffffe438, envp=0x7fffffffe4b0) at vl.c:4611
+ * (gdb) p d->name
+ * $7 = "nvme", '\000' <repeats 59 times>
+ *
+ * nvme多次到这里的例子:
+ * (gdb) bt
+ * #0  pci_update_mappings (d=0x5555579a9f90) at hw/pci/pci.c:1297
+ * #1  0x0000555555b358a3 in pci_default_write_config (d=0x5555579a9f90, addr=16, val_in=4294967295, l=4) at hw/pci/pci.c:1376
+ * #2  0x0000555555b3ebdc in pci_host_config_write_common (pci_dev=0x5555579a9f90, addr=16, limit=256, val=4294967295, len=4) at hw/pci/pci_host.c:66
+ * #3  0x0000555555b3ed04 in pci_data_write (s=0x5555569fed40, addr=2147491856, val=4294967295, len=4) at hw/pci/pci_host.c:100
+ * #4  0x0000555555b3ee30 in pci_host_data_write (opaque=0x5555569fca60, addr=0, val=4294967295, len=4) at hw/pci/pci_host.c:153
+ * #5  0x0000555555864b2d in memory_region_write_accessor (mr=0x5555569fce60, addr=0, value=0x7fffec8b07a8, size=4, shift=0, mask=4294967295, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #6  0x0000555555864d45 in access_with_adjusted_size (addr=0, value=0x7fffec8b07a8, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555864a43 <memory_region_write_accessor>, mr=0x5555569fce60, *     attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #7  0x000055555586796d in memory_region_dispatch_write (mr=0x5555569fce60, addr=0, data=4294967295, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #8  0x000055555580399f in flatview_write_continue (fv=0x7fffe0040b70, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4, addr1=0, l=4, mr=0x5555569fce60)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #9  0x0000555555803ae9 in flatview_write (fv=0x7fffe0040b70, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #10 0x0000555555803def in address_space_write (as=0x555556721a20 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #11 0x0000555555803e40 in address_space_rw (as=0x555556721a20 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4, is_write=true) at
+ *     /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #12 0x00005555558823ec in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7ff0000, direction=1, size=4, count=1) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1729
+ * #13 0x0000555555882b30 in kvm_cpu_exec (cpu=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1969
+ * #14 0x0000555555849eac in qemu_kvm_cpu_thread_fn (arg=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #15 0x0000555555d92dd7 in qemu_thread_start (args=0x5555568abcb0) at util/qemu-thread-posix.c:504
+ * #16 0x00007ffff4ca06ba in start_thread (arg=0x7fffec8b1700) at pthread_create.c:333
+ * #17 0x00007ffff49d641d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * e1000后来到这里的例子:
+ * (gdb) bt
+ * #0  pci_update_mappings (d=0x7fffe765e010) at hw/pci/pci.c:1297
+ * #1  0x0000555555b358a3 in pci_default_write_config (d=0x7fffe765e010, addr=16, val_in=4294967295, l=4) at hw/pci/pci.c:1376
+ * #2  0x0000555555af5d03 in e1000_write_config (pci_dev=0x7fffe765e010, address=16, val=4294967295, len=4) at hw/net/e1000.c:1647
+ * #3  0x0000555555b3ebdc in pci_host_config_write_common (pci_dev=0x7fffe765e010, addr=16, limit=256, val=4294967295, len=4) at hw/pci/pci_host.c:66
+ * #4  0x0000555555b3ed04 in pci_data_write (s=0x5555569fed40, addr=2147489808, val=4294967295, len=4) at hw/pci/pci_host.c:100
+ * #5  0x0000555555b3ee30 in pci_host_data_write (opaque=0x5555569fca60, addr=0, val=4294967295, len=4) at hw/pci/pci_host.c:153
+ * #6  0x0000555555864b2d in memory_region_write_accessor (mr=0x5555569fce60, addr=0, value=0x7fffec8b07a8, size=4, shift=0, mask=4294967295, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #7  0x0000555555864d45 in access_with_adjusted_size (addr=0, value=0x7fffec8b07a8, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555864a43 <memory_region_write_accessor>, mr=0x5555569fce60,
+ *     attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #8  0x000055555586796d in memory_region_dispatch_write (mr=0x5555569fce60, addr=0, data=4294967295, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #9  0x000055555580399f in flatview_write_continue (fv=0x7fffe0040b70, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4, addr1=0, l=4, mr=0x5555569fce60)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #10 0x0000555555803ae9 in flatview_write (fv=0x7fffe0040b70, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #11 0x0000555555803def in address_space_write (as=0x555556721a20 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #12 0x0000555555803e40 in address_space_rw (as=0x555556721a20 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4, is_write=true) at 
+ *     /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #13 0x00005555558823ec in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7ff0000, direction=1, size=4, count=1) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1729
+ * #14 0x0000555555882b30 in kvm_cpu_exec (cpu=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1969
+ * #15 0x0000555555849eac in qemu_kvm_cpu_thread_fn (arg=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #16 0x0000555555d92dd7 in qemu_thread_start (args=0x5555568abcb0) at util/qemu-thread-posix.c:504
+ * #17 0x00007ffff4ca06ba in start_thread (arg=0x7fffec8b1700) at pthread_create.c:333
+ * #18 0x00007ffff49d641d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ *
+ * hotplug e1000网卡的例子:
+ * (gdb) bt
+ * #0  pci_update_mappings (d=0x5555566fcc20) at hw/pci/pci.c:1297
+ * #1  0x0000555555af623e in pci_default_write_config (d=0x5555566fcc20, addr=4, val_in=1024, l=2) at hw/pci/pci.c:1376
+ * #2  0x0000555555ab669e in e1000_write_config (pci_dev=0x5555566fcc20, address=4, val=1024, len=2) at hw/net/e1000.c:1647
+ * #3  0x0000555555aff577 in pci_host_config_write_common (pci_dev=0x5555566fcc20, addr=4, limit=256, val=1024, len=2) at hw/pci/pci_host.c:66
+ * #4  0x0000555555aff69f in pci_data_write (s=0x555556775930, addr=2147493892, val=1024, len=2) at hw/pci/pci_host.c:100
+ * #5  0x0000555555aff7cb in pci_host_data_write (opaque=0x555556773e60, addr=0, val=1024, len=2) at hw/pci/pci_host.c:153
+ * #6  0x000055555583317e in memory_region_write_accessor (mr=0x555556774260, addr=0, value=0x7fffec8be7a8, size=2, shift=0, mask=65535, attrs=...)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #7  0x0000555555833396 in access_with_adjusted_size (addr=0, value=0x7fffec8be7a8, size=2, access_size_min=1, access_size_max=4, 
+ *     access_fn=0x555555833094 <memory_region_write_accessor>, mr=0x555556774260, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #8  0x0000555555835fbe in memory_region_dispatch_write (mr=0x555556774260, addr=0, data=1024, size=2, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #9  0x00005555557d1ff8 in flatview_write_continue (fv=0x55555707ce00, addr=3324, attrs=..., buf=0x7ffff7ff0000 "", len=2, addr1=0, l=2, mr=0x555556774260)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #10 0x00005555557d2142 in flatview_write (fv=0x55555707ce00, addr=3324, attrs=..., buf=0x7ffff7ff0000 "", len=2) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #11 0x00005555557d2448 in address_space_write (as=0x555556498ae0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "", len=2)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #12 0x00005555557d2499 in address_space_rw (as=0x555556498ae0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "", len=2, is_write=true)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #13 0x0000555555850a3d in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7ff0000, direction=1, size=2, count=1)
+ *     at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1729
+ * #14 0x0000555555851181 in kvm_cpu_exec (cpu=0x555556600e30) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1969
+ * #15 0x0000555555818505 in qemu_kvm_cpu_thread_fn (arg=0x555556600e30) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #16 0x0000555555d54975 in qemu_thread_start (args=0x5555566230b0) at util/qemu-thread-posix.c:504
+ * #17 0x00007ffff55126ba in start_thread (arg=0x7fffec8bf700) at pthread_create.c:333
+ * #18 0x00007ffff524841d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * nvme第一次到这里的例子
+ *   io_regions = {{
+ *       addr = 18446744073709551615, 
+ *       size = 8192, 
+ *       type = 4 '\004', 
+ *       memory = 0x5555579aa870,   (name="nvme", ops=nvme_mmio_ops) 
+ *       address_space = 0x5555568faff0  (name="pci", ops=unassigned_mem_ops, terminates = false)
+ *     }, {
+ *       addr = 0, 
+ *       size = 0, 
+ *       type = 0 '\000', 
+ *       memory = 0x0, 
+ *       address_space = 0x0
+ *     }, {
+ *       addr = 0, 
+ *       size = 0, 
+ *       type = 0 '\000', 
+ *       memory = 0x0, 
+ *       address_space = 0x0
+ *     }, {
+ *       addr = 0, 
+ *       size = 0, 
+ *       type = 0 '\000', 
+ *       memory = 0x0, 
+ *       address_space = 0x0
+ *     }, {
+ *       addr = 18446744073709551615, 
+ *       size = 4096, 
+ *       type = 0 '\000', 
+ *       memory = 0x5555579aa430,  (name="nvme-msix", ops=unassigned_mem_ops, terminates=false)
+ *       address_space = 0x5555568faff0 (name="pci", ops=unassigned_mem_ops, terminates = false)
+ *     }, {
+ *       addr = 0, 
+ *       size = 0, 
+ *       type = 0 '\000', 
+ *       memory = 0x0, 
+ *       address_space = 0x0
+ *     }, {
+ *       addr = 0, 
+ *       size = 0, 
+ *       type = 0 '\000', 
+ *       memory = 0x0, 
+ *       address_space = 0x0
+ *     }},
+ *
+ *
+ * bar的地址应该是guest (比如BIOS)更新的
+ *
+ * called by:
+ *   - hw/pci/pci.c|300| <<pci_do_device_reset>> pci_update_mappings(dev);
+ *   - hw/pci/pci.c|489| <<get_pci_config_device>> pci_update_mappings(s);
+ *   - hw/pci/pci.c|1407| <<pci_default_write_config>> pci_update_mappings(d);
+ */
 static void pci_update_mappings(PCIDevice *d)
 {
     PCIIORegion *r;
@@ -1301,6 +1605,7 @@ static void pci_update_mappings(PCIDevice *d)
         if (!r->size)
             continue;
 
+	/* nvme调用到这里时new_addr返回-1 */
         new_addr = pci_bar_address(d, i, r->type, r->size);
 
         /* This bar isn't changed */
@@ -1924,6 +2229,16 @@ static bool pci_root_bus_in_range(PCIBus *bus, int bus_num)
     return false;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|688| <<pci_get_bus_devfn>> return pci_find_bus_nr(root, 0);
+ *   - hw/pci/pci.c|701| <<pci_get_bus_devfn>> return pci_find_bus_nr(root, bus);
+ *   - hw/pci/pci.c|1608| <<pci_for_each_device_reverse>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|1635| <<pci_for_each_device>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|1724| <<qmp_query_pci_bridge>> PCIBus *child_bus = pci_find_bus_nr(bus, dev->config[PCI_SECONDARY_BUS]);
+ *   - hw/pci/pci.c|1805| <<qmp_query_pci_bus>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|2016| <<pci_find_device>> bus = pci_find_bus_nr(bus, bus_num);
+ */
 static PCIBus *pci_find_bus_nr(PCIBus *bus, int bus_num)
 {
     PCIBus *sec;
@@ -1932,6 +2247,10 @@ static PCIBus *pci_find_bus_nr(PCIBus *bus, int bus_num)
         return NULL;
     }
 
+    /*
+     * 如果参数中的bus就是要找的bus number 直接返回
+     * 否则要从child bus中继续找
+     */
     if (pci_bus_num(bus) == bus_num) {
         return bus;
     }
@@ -1992,6 +2311,9 @@ void pci_for_each_bus_depth_first(PCIBus *bus,
 }
 
 
+/*
+ * 被一群外部调用
+ */
 PCIDevice *pci_find_device(PCIBus *bus, int bus_num, uint8_t devfn)
 {
     bus = pci_find_bus_nr(bus, bus_num);
@@ -2002,6 +2324,26 @@ PCIDevice *pci_find_device(PCIBus *bus, int bus_num, uint8_t devfn)
     return bus->devices[devfn];
 }
 
+/*
+ * used by (用作DeviceClass的realize):
+ *   - hw/pci/pci.c|2557| <<pci_device_class_init>> k->realize = pci_qdev_realize;
+ *
+ * called by:
+ *   - hw/core/qdev.c|889| <<device_set_realized>> dc->realize(dev, &local_err);
+ *
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 static void pci_qdev_realize(DeviceState *qdev, Error **errp)
 {
     PCIDevice *pci_dev = (PCIDevice *)qdev;
@@ -2013,6 +2355,13 @@ static void pci_qdev_realize(DeviceState *qdev, Error **errp)
     /* initialize cap_present for pci_is_express() and pci_config_size(),
      * Note that hybrid PCIs are not set automatically and need to manage
      * QEMU_PCI_CAP_EXPRESS manually */
+    /*
+     * object_classs_dynamic_cast():
+     *     如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     *     一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     *     否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     *     在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_class_dynamic_cast(klass, INTERFACE_PCIE_DEVICE) &&
        !object_class_dynamic_cast(klass, INTERFACE_CONVENTIONAL_PCI_DEVICE)) {
         pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;
@@ -2048,6 +2397,20 @@ static void pci_qdev_realize(DeviceState *qdev, Error **errp)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci-bridge/dec.c|93| <<pci_dec_21154_init>> dev = pci_create_multifunction(parent_bus, devfn, false,
+ *   - hw/pci-bridge/xio3130_downstream.c|139| <<xio3130_downstream_init>> d = pci_create_multifunction(bus, devfn, multifunction,
+ *   - hw/pci-bridge/xio3130_upstream.c|119| <<xio3130_upstream_init>> d = pci_create_multifunction(bus, devfn, multifunction, "x3130-upstream");
+ *   - hw/pci-host/sabre.c|405| <<sabre_realize>> pci_dev = pci_create_multifunction(phb->bus, PCI_DEVFN(1, 0), true,
+ *   - hw/pci-host/sabre.c|411| <<sabre_realize>> pci_dev = pci_create_multifunction(phb->bus, PCI_DEVFN(1, 1), true,
+ *   - hw/pci/pci.c|2106| <<pci_create_simple_multifunction>> PCIDevice *dev = pci_create_multifunction(bus, devfn, multifunction, name);
+ *   - hw/pci/pci.c|2113| <<pci_create>> return pci_create_multifunction(bus, devfn, false, name);
+ *   - hw/sparc64/sun4u.c|581| <<sun4uv_init>> ebus = pci_create_multifunction(pci_busA, PCI_DEVFN(1, 0), true, TYPE_EBUS);
+ *   - hw/sparc64/sun4u.c|607| <<sun4uv_init>> pci_dev = pci_create_multifunction(pci_busA, PCI_DEVFN(1, 1),
+ *   - hw/usb/hcd-ehci-pci.c|273| <<ehci_create_ich9_with_companions>> ehci = pci_create_multifunction(bus, PCI_DEVFN(slot, 7), true, name);
+ *   - hw/usb/hcd-ehci-pci.c|278| <<ehci_create_ich9_with_companions>> uhci = pci_create_multifunction(bus, PCI_DEVFN(slot, comp[i].func),
+ */
 PCIDevice *pci_create_multifunction(PCIBus *bus, int devfn, bool multifunction,
                                     const char *name)
 {
@@ -2059,6 +2422,18 @@ PCIDevice *pci_create_multifunction(PCIBus *bus, int devfn, bool multifunction,
     return PCI_DEVICE(dev);
 }
 
+/*
+ * called by:
+ *   - hw/i2c/smbus_ich9.c|111| <<ich9_smb_init>> pci_create_simple_multifunction(bus, devfn, true, TYPE_ICH9_SMB_DEVICE);
+ *   - hw/i386/pc_q35.c|191| <<pc_q35_init>> lpc = pci_create_simple_multifunction(host_bus, PCI_DEVFN(ICH9_LPC_DEV,
+ *   - hw/i386/pc_q35.c|247| <<pc_q35_init>> ahci = pci_create_simple_multifunction(host_bus,
+ *   - hw/isa/piix4.c|106| <<piix4_init>> d = pci_create_simple_multifunction(bus, devfn, true, "PIIX4");
+ *   - hw/isa/vt82c686.c|486| <<vt82c686b_isa_init>> d = pci_create_simple_multifunction(bus, devfn, true,
+ *   - hw/mips/boston.c|520| <<boston_mach_init>> ahci = pci_create_simple_multifunction(&PCI_BRIDGE(&pcie2->root)->sec_bus,
+ *   - hw/pci-host/piix.c|415| <<i440fx_init>> PCIDevice *pci_dev = pci_create_simple_multifunction(b,
+ *   - hw/pci-host/piix.c|421| <<i440fx_init>> PCIDevice *pci_dev = pci_create_simple_multifunction(b,
+ *   - hw/pci/pci.c|2135| <<pci_create_simple>> return pci_create_simple_multifunction(bus, devfn, false, name);
+ */
 PCIDevice *pci_create_simple_multifunction(PCIBus *bus, int devfn,
                                            bool multifunction,
                                            const char *name)
@@ -2073,11 +2448,18 @@ PCIDevice *pci_create(PCIBus *bus, int devfn, const char *name)
     return pci_create_multifunction(bus, devfn, false, name);
 }
 
+/*
+ * 被很多外部调用
+ */
 PCIDevice *pci_create_simple(PCIBus *bus, int devfn, const char *name)
 {
     return pci_create_simple_multifunction(bus, devfn, false, name);
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|2297| <<pci_add_capability>> offset = pci_find_space(pdev, size);
+ */
 static uint8_t pci_find_space(PCIDevice *pdev, uint8_t size)
 {
     int offset = PCI_CONFIG_HEADER_SIZE;
@@ -2517,16 +2899,32 @@ MemoryRegion *pci_address_space_io(PCIDevice *dev)
     return pci_get_bus(dev)->address_space_io;
 }
 
+/*
+ * TypeInfo pci_device_type_info.class_init = pci_device_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void pci_device_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *k = DEVICE_CLASS(klass);
 
+    /*
+     * realize is called by:
+     *   - hw/core/qdev.c|860| <<device_set_realized>> dc->realize(dev, &local_err);
+     */
     k->realize = pci_qdev_realize;
     k->unrealize = pci_qdev_unrealize;
     k->bus_type = TYPE_PCI_BUS;
     k->props = pci_props;
 }
 
+/*
+ * TypeInfo pci_device_type_info.class_base_init = pci_device_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void pci_device_class_base_init(ObjectClass *klass, void *data)
 {
     if (!object_class_is_abstract(klass)) {
@@ -2538,6 +2936,9 @@ static void pci_device_class_base_init(ObjectClass *klass, void *data)
     }
 }
 
+/*
+ * 如果没使用iommu就返回address_space_memory
+ */
 AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)
 {
     PCIBus *bus = pci_get_bus(dev);
@@ -2669,6 +3070,11 @@ static const TypeInfo pci_device_type_info = {
 
 static void pci_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&pci_bus_info);
     type_register_static(&pcie_bus_info);
     type_register_static(&conventional_pci_interface_info);
@@ -2676,4 +3082,8 @@ static void pci_register_types(void)
     type_register_static(&pci_device_type_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(pci_register_types)
diff --git a/hw/pci/pci_host.c b/hw/pci/pci_host.c
index 5eaa935..0a4af82 100644
--- a/hw/pci/pci_host.c
+++ b/hw/pci/pci_host.c
@@ -42,6 +42,11 @@ do { printf("pci_host_data: " fmt , ## __VA_ARGS__); } while (0)
  */
 
 /* the helper function to get a PCIDevice* for a given pci address */
+/*
+ * called by:
+ *   - hw/pci/pci_host.c|91| <<pci_data_write>> PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);
+ *   - hw/pci/pci_host.c|106| <<pci_data_read>> PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);
+ */
 static inline PCIDevice *pci_dev_find_by_addr(PCIBus *bus, uint32_t addr)
 {
     uint8_t bus_num = addr >> 16;
@@ -104,6 +109,12 @@ void pci_data_write(PCIBus *s, uint32_t addr, uint32_t val, int len)
 uint32_t pci_data_read(PCIBus *s, uint32_t addr, int len)
 {
     PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);
+    /*
+     * PCI address
+     * bit 16 - 24: bus number
+     * bit  8 - 15: devfun number
+     * bit  0 -  7: offset in configuration space of a given pci device
+     */
     uint32_t config_addr = addr & (PCI_CONFIG_SPACE_SIZE - 1);
     uint32_t val;
 
diff --git a/hw/vfio/common.c b/hw/vfio/common.c
index fb396cf..ec66b91 100644
--- a/hw/vfio/common.c
+++ b/hw/vfio/common.c
@@ -192,6 +192,11 @@ uint64_t vfio_region_read(void *opaque,
     return data;
 }
 
+/*
+ * 只被以下调用:
+ *   - hw/vfio/common.c|788| <<vfio_region_setup>> memory_region_init_io(region->mem, obj, &vfio_region_ops,
+ *                                                                       region, name, region->size);
+ */
 const MemoryRegionOps vfio_region_ops = {
     .read = vfio_region_read,
     .write = vfio_region_write,
@@ -766,6 +771,17 @@ static int vfio_setup_region_sparse_mmaps(VFIORegion *region,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2550| <<vfio_populate_device>> ret = vfio_region_setup(OBJECT(vdev), vbasedev,
+ *                                                                          &vdev->bars[i].region, i, name);
+ *   - hw/vfio/display.c|256| <<vfio_display_region_update>> ret = vfio_region_setup(OBJECT(vdev), &vdev->vbasedev,
+ *                                                                                   &dpy->region.buffer,
+ *                                                                                   plane.region_index,
+ *                                                                                   "display");
+ *   - hw/vfio/platform.c|484| <<vfio_populate_device>> ret = vfio_region_setup(OBJECT(vdev), vbasedev,
+ *                                                                              vdev->regions[i], i, name);
+ */
 int vfio_region_setup(Object *obj, VFIODevice *vbasedev, VFIORegion *region,
                       int index, const char *name)
 {
@@ -809,6 +825,12 @@ int vfio_region_setup(Object *obj, VFIODevice *vbasedev, VFIORegion *region,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|1699| <<vfio_bar_register>> if (vfio_region_mmap(&bar->region)) {
+ *   - hw/vfio/platform.c|659| <<vfio_platform_realize>> if (vfio_region_mmap(vdev->regions[i])) {
+ *   - hw/vfio/display.c|265| <<vfio_display_region_update>> ret = vfio_region_mmap(&dpy->region.buffer);
+ */
 int vfio_region_mmap(VFIORegion *region)
 {
     int i, prot = 0;
@@ -1035,6 +1057,32 @@ static void vfio_put_address_space(VFIOAddressSpace *space)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  vfio_connect_container (group=0x55555773ae30, as=0x555556498b40 <address_space_memory>, errp=0x7fffffffdd68)
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/vfio/common.c:1040
+ * #1  0x00005555558acdb5 in vfio_get_group (groupid=2, as=0x555556498b40 <address_space_memory>, errp=0x7fffffffdd68)
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/vfio/common.c:1326
+ * #2  0x00005555558b724c in vfio_realize (pdev=0x555557738170, errp=0x7fffffffdd68) at /home/zhang/kvm/qemu-3.0.0/hw/vfio/pci.c:2859
+ * #3  0x0000555555af770d in pci_qdev_realize (qdev=0x555557738170, errp=0x7fffffffdde0) at hw/pci/pci.c:2028
+ * #4  0x0000555555a2d447 in device_set_realized (obj=0x555557738170, value=true, errp=0x7fffffffdfb0) at hw/core/qdev.c:826
+ * #5  0x0000555555c21bc7 in property_set_bool (obj=0x555557738170, v=0x55555773a920, name=0x555555db778a "realized", opaque=0x555557737dd0, 
+ *     errp=0x7fffffffdfb0) at qom/object.c:1984
+ * #6  0x0000555555c1fe4c in object_property_set (obj=0x555557738170, v=0x55555773a920, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/object.c:1176
+ * #7  0x0000555555c22f04 in object_property_set_qobject (obj=0x555557738170, value=0x555557739390, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/qom-qobject.c:27
+ * #8  0x0000555555c20131 in object_property_set_bool (obj=0x555557738170, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/object.c:1242
+ * #9  0x0000555555990749 in qdev_device_add (opts=0x555556536cc0, errp=0x7fffffffe028) at qdev-monitor.c:627
+ * #10 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x555556536cc0, errp=0x0) at vl.c:2275
+ * #11 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0)
+ *     at util/qemu-option.c:1106
+ * #12 0x000055555599dd61 in main (argc=20, argv=0x7fffffffe398, envp=0x7fffffffe440) at vl.c:4542
+ *
+ * called only by:
+ *   - hw/vfio/common.c|1342| <<vfio_get_group>> if (vfio_connect_container(group, as, errp)) {
+ */
 static int vfio_connect_container(VFIOGroup *group, AddressSpace *as,
                                   Error **errp)
 {
@@ -1279,6 +1327,12 @@ static void vfio_disconnect_container(VFIOGroup *group)
     }
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2927| <<vfio_realize>> group = vfio_get_group(groupid, pci_device_iommu_address_space(pdev), errp);
+ *   - hw/vfio/platform.c|602| <<vfio_base_device_init>> group = vfio_get_group(groupid, &address_space_memory, errp);
+ *   - hw/vfio/ccw.c|391| <<vfio_ccw_get_group>> return vfio_get_group(groupid, &address_space_memory, errp);
+ */
 VFIOGroup *vfio_get_group(int groupid, AddressSpace *as, Error **errp)
 {
     VFIOGroup *group;
@@ -1346,6 +1400,17 @@ free_group_exit:
     return NULL;
 }
 
+/*
+ * called by only:
+ *   - hw/vfio/pci.c|2935| <<vfio_realize>> vfio_put_group(group);
+ *   - hw/vfio/pci.c|2942| <<vfio_realize>> vfio_put_group(group);
+ *   - hw/vfio/pci.c|3155| <<vfio_instance_finalize>> vfio_put_group(group);
+ *   - hw/vfio/platform.c|610| <<vfio_base_device_init>> vfio_put_group(group);
+ *   - hw/vfio/platform.c|616| <<vfio_base_device_init>> vfio_put_group(group);
+ *   - hw/vfio/platform.c|622| <<vfio_base_device_init>> vfio_put_group(group);
+ *   - hw/vfio/ccw.c|438| <<vfio_ccw_realize>> vfio_put_group(group);
+ *   - hw/vfio/ccw.c|458| <<vfio_ccw_unrealize>> vfio_put_group(group);
+ */
 void vfio_put_group(VFIOGroup *group)
 {
     if (!group || !QLIST_EMPTY(&group->device_list)) {
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 6cbb8fa..61df380 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -35,6 +35,23 @@
 #include "trace.h"
 #include "qapi/error.h"
 
+/*
+ * Group 是IOMMU能够进行DMA隔离的最小硬件单元, 一个group内可能只有一个device, 也可能有多
+ * 个device, 这取决于物理平台上硬件的IOMMU拓扑结构. 设备直通的时候一个group里面的设备必须
+ * 都直通给一个虚拟机. 不能够让一个group里的多个device分别从属于2个不同的VM, 也不允许部分
+ * device在host上而另一部分被分配到guest里, 因为就这样一个guest中的device可以利用DMA攻击获
+ * 取另外一个guest里的数据, 就无法做到物理上的DMA隔离. 另外, VFIO中的group和iommu group可
+ * 以认为是同一个概念.
+ *
+ * Device 指的是我们要操作的硬件设备, 不过这里的"设备"需要从IOMMU拓扑的角度去理解. 如果该设
+ * 备是一个硬件拓扑上独立的设备, 那么它自己就构成一个iommu group. 如果这里是一个
+ * multi-function设备, 那么它和其他的function一起组成一个iommu group, 因为多个function设备
+ * 在物理硬件上就是互联的, 他们可以互相访问对方的数据所以必须放到一个group里隔离起来. 值得
+ * 一提的是, 对于支持PCIe ACS特性的硬件设备, 我们可以认为他们在物理上是互相隔离的.
+ *
+ * Container 是一个和地址空间相关联的概念, 这里可以简单把它理解为一个VM Domain的物理内存空间.
+ */
+
 #define MSIX_CAP_LENGTH 12
 
 static void vfio_disable_interrupts(VFIOPCIDevice *vdev);
@@ -1366,6 +1383,10 @@ static void vfio_pci_fixup_msix_region(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * called by only:
+ *   - hw/vfio/pci.c|1540| <<vfio_msix_early_setup>> vfio_pci_relocate_msix(vdev, errp);
+ */
 static void vfio_pci_relocate_msix(VFIOPCIDevice *vdev, Error **errp)
 {
     int target_bar = -1;
@@ -1658,6 +1679,28 @@ static void vfio_bars_prepare(VFIOPCIDevice *vdev)
     }
 }
 
+/*
+ * 对于igb的测试网卡, 从nr=0到nr=5执行了5次
+ * (gdb) bt
+ * #0  vfio_bar_register (vdev=0x555557738170, nr=0) at /home/zhang/kvm/qemu-3.0.0/hw/vfio/pci.c:1663
+ * #1  0x00005555558b4735 in vfio_bars_register (vdev=0x555557738170) at /home/zhang/kvm/qemu-3.0.0/hw/vfio/pci.c:1692
+ * #2  0x00005555558b795c in vfio_realize (pdev=0x555557738170, errp=0x7fffffffdd68) at /home/zhang/kvm/qemu-3.0.0/hw/vfio/pci.c:2979
+ * #3  0x0000555555af770d in pci_qdev_realize (qdev=0x555557738170, errp=0x7fffffffdde0) at hw/pci/pci.c:2028
+ * #4  0x0000555555a2d447 in device_set_realized (obj=0x555557738170, value=true, errp=0x7fffffffdfb0) at hw/core/qdev.c:826
+ * #5  0x0000555555c21bc7 in property_set_bool (obj=0x555557738170, v=0x55555773a920, name=0x555555db778a "realized", opaque=0x555557737dd0, 
+ *     errp=0x7fffffffdfb0) at qom/object.c:1984
+ * #6  0x0000555555c1fe4c in object_property_set (obj=0x555557738170, v=0x55555773a920, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/object.c:1176
+ * #7  0x0000555555c22f04 in object_property_set_qobject (obj=0x555557738170, value=0x555557739390, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/qom-qobject.c:27
+ * #8  0x0000555555c20131 in object_property_set_bool (obj=0x555557738170, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/object.c:1242
+ * #9  0x0000555555990749 in qdev_device_add (opts=0x555556536cc0, errp=0x7fffffffe028) at qdev-monitor.c:627
+ * #10 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x555556536cc0, errp=0x0) at vl.c:2275
+ * #11 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0)
+ *     at util/qemu-option.c:1106
+ * #12 0x000055555599dd61 in main (argc=20, argv=0x7fffffffe398, envp=0x7fffffffe440) at vl.c:4542
+ */
 static void vfio_bar_register(VFIOPCIDevice *vdev, int nr)
 {
     VFIOBAR *bar = &vdev->bars[nr];
@@ -2221,6 +2264,11 @@ static bool vfio_pci_host_match(PCIHostDeviceAddress *addr, const char *name)
     return (strcmp(tmp, name) == 0);
 }
 
+/*
+ * called by:
+ *   - hw/vfio/pci.c|2427| <<vfio_pci_hot_reset_one>> return vfio_pci_hot_reset(vdev, true);
+ *   - hw/vfio/pci.c|2433| <<vfio_pci_hot_reset_multi>> return vfio_pci_hot_reset(vdev, false);
+ */
 static int vfio_pci_hot_reset(VFIOPCIDevice *vdev, bool single)
 {
     VFIOGroup *group;
@@ -2511,6 +2559,29 @@ int vfio_populate_vga(VFIOPCIDevice *vdev, Error **errp)
     return 0;
 }
 
+/*
+ * (gdb) bt
+ * #0  vfio_populate_device (vdev=0x555557738170, errp=0x7fffffffcc48) at /home/zhang/kvm/qemu-3.0.0/hw/vfio/pci.c:2515
+ * #1  0x00005555558b7372 in vfio_realize (pdev=0x555557738170, errp=0x7fffffffdd68) at /home/zhang/kvm/qemu-3.0.0/hw/vfio/pci.c:2878
+ * #2  0x0000555555af770d in pci_qdev_realize (qdev=0x555557738170, errp=0x7fffffffdde0) at hw/pci/pci.c:2028
+ * #3  0x0000555555a2d447 in device_set_realized (obj=0x555557738170, value=true, errp=0x7fffffffdfb0) at hw/core/qdev.c:826
+ * #4  0x0000555555c21bc7 in property_set_bool (obj=0x555557738170, v=0x55555773a920, name=0x555555db778a "realized", opaque=0x555557737dd0, 
+ *     errp=0x7fffffffdfb0) at qom/object.c:1984
+ * #5  0x0000555555c1fe4c in object_property_set (obj=0x555557738170, v=0x55555773a920, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/object.c:1176
+ * #6  0x0000555555c22f04 in object_property_set_qobject (obj=0x555557738170, value=0x555557739390, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/qom-qobject.c:27
+ * #7  0x0000555555c20131 in object_property_set_bool (obj=0x555557738170, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/object.c:1242
+ * #8  0x0000555555990749 in qdev_device_add (opts=0x555556536cc0, errp=0x7fffffffe028) at qdev-monitor.c:627
+ * #9  0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x555556536cc0, errp=0x0) at vl.c:2275
+ * #10 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0)
+ *     at util/qemu-option.c:1106
+ * #11 0x000055555599dd61 in main (argc=20, argv=0x7fffffffe398, envp=0x7fffffffe440) at vl.c:4542
+ *
+ * pci的vfio_populate_device()只被以下调用:
+ *   - hw/vfio/pci.c|2906| <<vfio_realize>> vfio_populate_device(vdev, &err);
+ */
 static void vfio_populate_device(VFIOPCIDevice *vdev, Error **errp)
 {
     VFIODevice *vbasedev = &vdev->vbasedev;
@@ -2799,6 +2870,25 @@ static void vfio_unregister_req_notifier(VFIOPCIDevice *vdev)
     vdev->req_enabled = false;
 }
 
+/*
+ * (gdb) bt
+ * #0  vfio_realize (pdev=0x555557738170, errp=0x7fffffffdd68) at /home/zhang/kvm/qemu-3.0.0/hw/vfio/pci.c:2803
+ * #1  0x0000555555af770d in pci_qdev_realize (qdev=0x555557738170, errp=0x7fffffffdde0) at hw/pci/pci.c:2028
+ * #2  0x0000555555a2d447 in device_set_realized (obj=0x555557738170, value=true, errp=0x7fffffffdfb0) at hw/core/qdev.c:826
+ * #3  0x0000555555c21bc7 in property_set_bool (obj=0x555557738170, v=0x55555773a920, name=0x555555db778a "realized", opaque=0x555557737dd0, 
+ *     errp=0x7fffffffdfb0) at qom/object.c:1984
+ * #4  0x0000555555c1fe4c in object_property_set (obj=0x555557738170, v=0x55555773a920, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/object.c:1176
+ * #5  0x0000555555c22f04 in object_property_set_qobject (obj=0x555557738170, value=0x555557739390, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/qom-qobject.c:27
+ * #6  0x0000555555c20131 in object_property_set_bool (obj=0x555557738170, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfb0)
+ *     at qom/object.c:1242
+ * #7  0x0000555555990749 in qdev_device_add (opts=0x555556536cc0, errp=0x7fffffffe028) at qdev-monitor.c:627
+ * #8  0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x555556536cc0, errp=0x0) at vl.c:2275
+ * #9  0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0)
+ *     at util/qemu-option.c:1106
+ * #10 0x000055555599dd61 in main (argc=20, argv=0x7fffffffe398, envp=0x7fffffffe440) at vl.c:4542
+ */
 static void vfio_realize(PCIDevice *pdev, Error **errp)
 {
     VFIOPCIDevice *vdev = DO_UPCAST(VFIOPCIDevice, pdev, pdev);
@@ -3060,6 +3150,12 @@ error:
     error_prepend(errp, ERR_PREFIX, vdev->vbasedev.name);
 }
 
+/*
+ * TypeInfo vfio_pci_dev_info.instance_finalize = vfio_instance_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void vfio_instance_finalize(Object *obj)
 {
     PCIDevice *pci_dev = PCI_DEVICE(obj);
@@ -3096,6 +3192,26 @@ static void vfio_exitfn(PCIDevice *pdev)
     vfio_bars_exit(vdev);
 }
 
+/*
+ * (gdb) bt
+ * #0  vfio_pci_reset (dev=0x555557738170) at /home/zhang/kvm/qemu-3.0.0/hw/vfio/pci.c:3100
+ * #1  0x0000555555a2df49 in device_reset (dev=0x555557738170) at hw/core/qdev.c:1086
+ * #2  0x0000555555a2bf3c in qdev_reset_one (dev=0x555557738170, opaque=0x0) at hw/core/qdev.c:250
+ * #3  0x0000555555a2cb42 in qdev_walk_children (dev=0x555557738170, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a2bf20 <qdev_reset_one>, 
+ *     post_busfn=0x555555a2bf43 <qbus_reset_one>, opaque=0x0) at hw/core/qdev.c:567
+ * #4  0x0000555555a310ce in qbus_walk_children (bus=0x5555567a49a0, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a2bf20 <qdev_reset_one>, 
+ *     post_busfn=0x555555a2bf43 <qbus_reset_one>, opaque=0x0) at hw/core/bus.c:59
+ * #5  0x0000555555a2cb06 in qdev_walk_children (dev=0x555556766e80, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a2bf20 <qdev_reset_one>, 
+ *     post_busfn=0x555555a2bf43 <qbus_reset_one>, opaque=0x0) at hw/core/qdev.c:559
+ * #6  0x0000555555a310ce in qbus_walk_children (bus=0x555556617080, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a2bf20 <qdev_reset_one>, 
+ *     post_busfn=0x555555a2bf43 <qbus_reset_one>, opaque=0x0) at hw/core/bus.c:59
+ * #7  0x0000555555a2c056 in qbus_reset_all (bus=0x555556617080) at hw/core/qdev.c:276
+ * #8  0x0000555555a2c079 in qbus_reset_all_fn (opaque=0x555556617080) at hw/core/qdev.c:282
+ * #9  0x0000555555a31a14 in qemu_devices_reset () at hw/core/reset.c:69
+ * #10 0x00005555558e2415 in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #11 0x00005555559961c1 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #12 0x000055555599dea6 in main (argc=20, argv=0x7fffffffe398, envp=0x7fffffffe440) at vl.c:4611
+ */
 static void vfio_pci_reset(DeviceState *dev)
 {
     PCIDevice *pdev = DO_UPCAST(PCIDevice, qdev, dev);
@@ -3136,6 +3252,24 @@ post_reset:
     vfio_pci_post_reset(vdev);
 }
 
+/*
+ * (gdb) bt
+ * #0  vfio_instance_init (obj=0x555557738170) at /home/zhang/kvm/qemu-3.0.0/hw/vfio/pci.c:3140
+ * #1  0x0000555555c1dfee in object_init_with_type (obj=0x555557738170, ti=0x5555564fced0) at qom/object.c:353
+ * #2  0x0000555555c1e1b1 in object_initialize_with_type (data=0x555557738170, size=3136, type=0x5555564fced0) at qom/object.c:384
+ * #3  0x0000555555c1e805 in object_new_with_type (type=0x5555564fced0) at qom/object.c:546
+ * #4  0x0000555555c1e842 in object_new (typename=0x555556536d30 "vfio-pci") at qom/object.c:556
+ * #5  0x000055555599064c in qdev_device_add (opts=0x555556536cc0, errp=0x7fffffffe028) at qdev-monitor.c:608
+ * #6  0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x555556536cc0, errp=0x0) at vl.c:2275
+ * #7  0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0)
+ *     at util/qemu-option.c:1106
+ * #8  0x000055555599dd61 in main (argc=20, argv=0x7fffffffe398, envp=0x7fffffffe440) at vl.c:4542
+ *
+ * TypeInfo vfio_pci_dev_info.instance_init = vfio_instance_init()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void vfio_instance_init(Object *obj)
 {
     PCIDevice *pci_dev = PCI_DEVICE(obj);
@@ -3204,18 +3338,49 @@ static const VMStateDescription vfio_pci_vmstate = {
     .unmigratable = 1,
 };
 
+/*
+ * (gdb) bt
+ * #0  vfio_pci_dev_class_init (klass=0x555556573bb0, data=0x0) at /home/zhang/kvm/qemu-3.0.0/hw/vfio/pci.c:3209
+ * #1  0x0000555555c1df88 in type_initialize (ti=0x5555564fced0) at qom/object.c:342
+ * #2  0x0000555555c1f2f8 in object_class_foreach_tramp (key=0x5555564d9830, value=0x5555564fced0, opaque=0x7fffffffdfc0) at qom/object.c:867
+ * #3  0x00007ffff5e88340 in g_hash_table_foreach () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #4  0x0000555555c1f3d7 in object_class_foreach (fn=0x555555c1f528 <object_class_get_list_tramp>, implements_type=0x555555db81d6 "machine", 
+ *     include_abstract=false, opaque=0x7fffffffe010) at qom/object.c:889
+ * #5  0x0000555555c1f5a6 in object_class_get_list (implements_type=0x555555db81d6 "machine", include_abstract=false) at qom/object.c:943
+ * #6  0x0000555555995b91 in find_default_machine () at vl.c:1417
+ * #7  0x0000555555999a80 in select_machine () at vl.c:2669
+ * #8  0x000055555599c9ab in main (argc=20, argv=0x7fffffffe398, envp=0x7fffffffe440) at vl.c:3988
+ *
+ * TypeInfo vfio_pci_dev_info.class_init = vfio_pci_dev_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void vfio_pci_dev_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(klass);
     PCIDeviceClass *pdc = PCI_DEVICE_CLASS(klass);
 
+    /*
+     * called only by:
+     *   - hw/core/qdev.c|1310| <<device_reset>> klass->reset(dev);
+     */
     dc->reset = vfio_pci_reset;
     dc->props = vfio_pci_dev_properties;
     dc->vmsd = &vfio_pci_vmstate;
     dc->desc = "VFIO-based PCI device assignment";
     set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+    /*
+     * called only by:
+     *   - hw/core/qdev.c|860| <<device_set_realized>> dc->realize(dev, &local_err);
+     */
     pdc->realize = vfio_realize;
     pdc->exit = vfio_exitfn;
+    /*
+     * called by:
+     *   - hw/pci/pci_host.c|87| <<pci_host_config_read_common>> ret = pci_dev->config_read(pci_dev, addr, MIN(len, limit - addr));
+     *   - hw/pci-host/bonito.c|338| <<bonito_pciconf_readl>> return d->config_read(d, addr, 4);
+     */
     pdc->config_read = vfio_pci_read_config;
     pdc->config_write = vfio_pci_write_config;
 }
@@ -3236,7 +3401,12 @@ static const TypeInfo vfio_pci_dev_info = {
 
 static void register_vfio_pci_dev_type(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&vfio_pci_dev_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(register_vfio_pci_dev_type)
diff --git a/hw/virtio/virtio-balloon.c b/hw/virtio/virtio-balloon.c
index 1f7a87f..e64942a 100644
--- a/hw/virtio/virtio-balloon.c
+++ b/hw/virtio/virtio-balloon.c
@@ -326,6 +326,12 @@ static int build_dimm_list(Object *obj, void *opaque)
 {
     GSList **list = opaque;
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_dynamic_cast(obj, TYPE_PC_DIMM)) {
         DeviceState *dev = DEVICE(obj);
         if (dev->realized) { /* only realized DIMMs matter */
diff --git a/hw/virtio/virtio-bus.c b/hw/virtio/virtio-bus.c
index f9bc9ea..bb719f9 100644
--- a/hw/virtio/virtio-bus.c
+++ b/hw/virtio/virtio-bus.c
@@ -41,6 +41,39 @@ do { printf("virtio_bus: " fmt , ## __VA_ARGS__); } while (0)
 #endif
 
 /* A VirtIODevice is being plugged */
+/*
+ * (gdb) bt
+ * #0  virtio_bus_device_plugged (vdev=0x555557785cf0, errp=0x7fffffffdaa0) at hw/virtio/virtio-bus.c:45
+ * #1  0x00005555558ca3d1 in virtio_device_realize (dev=0x555557785cf0, errp=0x7fffffffdb00)
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2525
+ * #2  0x0000555555a2d447 in device_set_realized (obj=0x555557785cf0, value=true, errp=0x7fffffffdd38) at hw/core/qdev.c:826
+ * #3  0x0000555555c21bc7 in property_set_bool (obj=0x555557785cf0, v=0x555557790940, name=0x555555e3cce6 "realized", opaque=0x555557787620, 
+ *     errp=0x7fffffffdd38) at qom/object.c:1984
+ * #4  0x0000555555c1fe4c in object_property_set (obj=0x555557785cf0, v=0x555557790940, name=0x555555e3cce6 "realized", errp=0x7fffffffdd38)
+ *     at qom/object.c:1176
+ * #5  0x0000555555c22f04 in object_property_set_qobject (obj=0x555557785cf0, value=0x555557790890, name=0x555555e3cce6 "realized", 
+ *     errp=0x7fffffffdd38) at qom/qom-qobject.c:27
+ * #6  0x0000555555c20131 in object_property_set_bool (obj=0x555557785cf0, value=true, name=0x555555e3cce6 "realized", errp=0x7fffffffdd38)
+ *     at qom/object.c:1242
+ * #7  0x0000555555b92c9f in virtio_blk_pci_realize (vpci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1970
+ * #8  0x0000555555b92682 in virtio_pci_realize (pci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1841
+ * #9  0x0000555555af770d in pci_qdev_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/pci/pci.c:2028
+ * #10 0x0000555555b92a90 in virtio_pci_dc_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/virtio/virtio-pci.c:1915
+ * #11 0x0000555555a2d447 in device_set_realized (obj=0x55555777db80, value=true, errp=0x7fffffffdfc0) at hw/core/qdev.c:826
+ * #12 0x0000555555c21bc7 in property_set_bool (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", opaque=0x555557785fa0, 
+ *     errp=0x7fffffffdfc0) at qom/object.c:1984
+ * #13 0x0000555555c1fe4c in object_property_set (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1176
+ * #14 0x0000555555c22f04 in object_property_set_qobject (obj=0x55555777db80, value=0x55555778a8a0, name=0x555555db778a "realized", 
+ *     errp=0x7fffffffdfc0) at qom/qom-qobject.c:27
+ * #15 0x0000555555c20131 in object_property_set_bool (obj=0x55555777db80, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1242
+ * #16 0x0000555555990749 in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe038) at qdev-monitor.c:627
+ * #17 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+ * #18 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, 
+ *     errp=0x0) at util/qemu-option.c:1106
+ * #19 0x000055555599dd61 in main (argc=15, argv=0x7fffffffe3a8, envp=0x7fffffffe428) at vl.c:4542
+ */
 void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
 {
     DeviceState *qdev = DEVICE(vdev);
@@ -71,6 +104,9 @@ void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
     }
 
     if (klass->device_plugged != NULL) {
+        /*
+	 * virtio blk应该是virtio_pci_device_plugged()
+	 */
         klass->device_plugged(qbus->parent, &local_err);
     }
     if (local_err) {
@@ -78,6 +114,9 @@ void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
         return;
     }
 
+    /*
+     * 分别是支持和不支持vIOMMU的情况
+     */
     if (klass->get_dma_as != NULL && has_iommu) {
         virtio_add_feature(&vdev->host_features, VIRTIO_F_IOMMU_PLATFORM);
         vdev->dma_as = klass->get_dma_as(qbus->parent);
@@ -152,6 +191,29 @@ void virtio_bus_get_vdev_config(VirtioBusState *bus, uint8_t *config)
 
     assert(vdev != NULL);
     k = VIRTIO_DEVICE_GET_CLASS(vdev);
+    /*
+     * 设置get_config的地方:
+     *   - hw/block/virtio-blk.c|1452| <<virtio_blk_class_init>> vdc->get_config = virtio_blk_update_config;
+     *   - hw/net/virtio-net.c|2214| <<virtio_net_class_init>> vdc->get_config = virtio_net_get_config;
+     *   - hw/scsi/virtio-scsi.c|958| <<virtio_scsi_common_class_init>> vdc->get_config = virtio_scsi_get_config;
+     *   - hw/virtio/virtio-balloon.c|534| <<virtio_balloon_class_init>> vdc->get_config = virtio_balloon_get_config;
+     *   - hw/9pfs/virtio-9p-device.c|249| <<virtio_9p_class_init>> vdc->get_config = virtio_9p_get_config;
+     *   - hw/block/vhost-user-blk.c|353| <<vhost_user_blk_class_init>> vdc->get_config = vhost_user_blk_update_config;
+     *   - hw/char/virtio-serial-bus.c|1176| <<virtio_serial_class_init>> vdc->get_config = get_config;
+     *   - hw/display/virtio-gpu.c|1368| <<virtio_gpu_class_init>> vdc->get_config = virtio_gpu_get_config;
+     *   - hw/input/virtio-input.c|319| <<virtio_input_class_init>> vdc->get_config = virtio_input_get_config;
+     *   - hw/virtio/vhost-vsock.c|400| <<vhost_vsock_class_init>> vdc->get_config = vhost_vsock_get_config;
+     *   - hw/virtio/virtio-crypto.c|960| <<virtio_crypto_class_init>> vdc->get_config = virtio_crypto_get_config;
+     *
+     * 调用get_config的地方:
+     *   - hw/virtio/virtio-bus.c|195| <<virtio_bus_get_vdev_config>> k->get_config(vdev, config);
+     *   - hw/virtio/virtio.c|1818| <<virtio_config_readb>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1838| <<virtio_config_readw>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1858| <<virtio_config_readl>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1963| <<virtio_config_modern_readb>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1982| <<virtio_config_modern_readw>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|2001| <<virtio_config_modern_readl>> k->get_config(vdev, vdev->config);
+     */
     if (k->get_config != NULL) {
         k->get_config(vdev, config);
     }
@@ -165,6 +227,28 @@ void virtio_bus_set_vdev_config(VirtioBusState *bus, uint8_t *config)
 
     assert(vdev != NULL);
     k = VIRTIO_DEVICE_GET_CLASS(vdev);
+    /*
+     * 设置set_config的地方:
+     *   - hw/block/virtio-blk.c|1463| <<virtio_blk_class_init>> vdc->set_config = virtio_blk_set_config;
+     *   - hw/net/virtio-net.c|2215| <<virtio_net_class_init>> vdc->set_config = virtio_net_set_config;
+     *   - hw/scsi/virtio-scsi.c|973| <<virtio_scsi_class_init>> vdc->set_config = virtio_scsi_set_config;
+     *   - hw/virtio/virtio-balloon.c|535| <<virtio_balloon_class_init>> vdc->set_config = virtio_balloon_set_config;
+     *   - hw/char/virtio-serial-bus.c|1177| <<virtio_serial_class_init>> vdc->set_config = set_config;
+     *   - hw/block/vhost-user-blk.c|354| <<vhost_user_blk_class_init>> vdc->set_config = vhost_user_blk_set_config;
+     *   - hw/display/virtio-gpu.c|1369| <<virtio_gpu_class_init>> vdc->set_config = virtio_gpu_set_config;
+     *   - hw/input/virtio-input.c|320| <<virtio_input_class_init>> vdc->set_config = virtio_input_set_config;
+     *   - hw/scsi/vhost-scsi.c|255| <<vhost_scsi_class_init>> vdc->set_config = vhost_scsi_common_set_config;
+     *   - hw/scsi/vhost-user-scsi.c|191| <<vhost_user_scsi_class_init>> vdc->set_config = vhost_scsi_common_set_config;
+     *
+     * 调用set_config的地方:
+     *   - hw/virtio/virtio-bus.c|208| <<virtio_bus_set_vdev_config>> k->set_config(vdev, config);
+     *   - hw/virtio/virtio.c|1881| <<virtio_config_writeb>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1902| <<virtio_config_writew>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1923| <<virtio_config_writel>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|2001| <<virtio_config_modern_writeb>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|2022| <<virtio_config_modern_writew>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|2043| <<virtio_config_modern_writel>> k->set_config(vdev, vdev->config);
+     */
     if (k->set_config != NULL) {
         k->set_config(vdev, config);
     }
@@ -203,6 +287,39 @@ void virtio_bus_release_ioeventfd(VirtioBusState *bus)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_bus_start_ioeventfd (bus=0x555557785c78) at hw/virtio/virtio-bus.c:208
+ * #1  0x0000555555b8ea96 in virtio_pci_start_ioeventfd (proxy=0x55555777db80) at hw/virtio/virtio-pci.c:288
+ * #2  0x0000555555b90f13 in virtio_pci_common_write (opaque=0x55555777db80, addr=20, val=15, size=1) at hw/virtio/virtio-pci.c:1288
+ * #3  0x000055555583317e in memory_region_write_accessor (mr=0x55555777e550, addr=20, value=0x7fffec9bf7e8, size=1, shift=0, mask=255, 
+ *     attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #4  0x0000555555833396 in access_with_adjusted_size (addr=20, value=0x7fffec9bf7e8, size=1, access_size_min=1, access_size_max=4, 
+ *     access_fn=0x555555833094 <memory_region_write_accessor>, mr=0x55555777e550, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #5  0x0000555555835fbe in memory_region_dispatch_write (mr=0x55555777e550, addr=20, data=15, size=1, attrs=...)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #6  0x00005555557d1ff8 in flatview_write_continue (fv=0x7fffe40ed7b0, addr=4261412884, attrs=..., buf=0x7ffff7fef028 "\017\020", len=1, 
+ *     addr1=20, l=1, mr=0x55555777e550) at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #7  0x00005555557d2142 in flatview_write (fv=0x7fffe40ed7b0, addr=4261412884, attrs=..., buf=0x7ffff7fef028 "\017\020", len=1)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #8  0x00005555557d2448 in address_space_write (as=0x555556498b40 <address_space_memory>, addr=4261412884, attrs=..., 
+ *     buf=0x7ffff7fef028 "\017\020", len=1) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #9  0x00005555557d2499 in address_space_rw (as=0x555556498b40 <address_space_memory>, addr=4261412884, attrs=..., 
+ *     buf=0x7ffff7fef028 "\017\020", len=1, is_write=true) at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #10 0x00005555558511ce in kvm_cpu_exec (cpu=0x5555565f4e20) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1979
+ * #11 0x0000555555818505 in qemu_kvm_cpu_thread_fn (arg=0x5555565f4e20) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #12 0x0000555555d54975 in qemu_thread_start (args=0x555556616910) at util/qemu-thread-posix.c:504
+ * #13 0x00007ffff55126ba in start_thread (arg=0x7fffec9c0700) at pthread_create.c:333
+ * #14 0x00007ffff524841d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ *
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|134| <<virtio_ccw_start_ioeventfd>> virtio_bus_start_ioeventfd(&dev->bus);
+ *   - hw/virtio/virtio-bus.c|241| <<virtio_bus_release_ioeventfd>> virtio_bus_start_ioeventfd(bus);
+ *   - hw/virtio/virtio-mmio.c|97| <<virtio_mmio_start_ioeventfd>> virtio_bus_start_ioeventfd(&proxy->bus);
+ *   - hw/virtio/virtio-pci.c|294| <<virtio_pci_start_ioeventfd>> virtio_bus_start_ioeventfd(&proxy->bus);
+ *   - hw/virtio/virtio.c|2756| <<virtio_device_start_ioeventfd>> return virtio_bus_start_ioeventfd(vbus);
+ */
 int virtio_bus_start_ioeventfd(VirtioBusState *bus)
 {
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(bus);
@@ -220,6 +337,15 @@ int virtio_bus_start_ioeventfd(VirtioBusState *bus)
 
     /* Only set our notifier if we have ownership.  */
     if (!bus->ioeventfd_grabbed) {
+        /*
+	 * 关于start_ioeventfd:
+	 * called by: 
+	 *   - hw/virtio/virtio-bus.c|281| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+	 * used by:
+	 *   - hw/block/virtio-blk.c|1111| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start; --> block用
+	 *   - hw/scsi/virtio-scsi.c|976| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+	 *   - hw/virtio/virtio.c|2799| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl; --> 网络用
+	 */
         r = vdc->start_ioeventfd(vdev);
         if (r < 0) {
             error_report("%s: failed. Fallback to userspace (slower).", __func__);
@@ -251,8 +377,21 @@ void virtio_bus_stop_ioeventfd(VirtioBusState *bus)
 bool virtio_bus_ioeventfd_enabled(VirtioBusState *bus)
 {
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(bus);
+    /*
+     * 初始化开始于virtio_pci_realize():
+     * 1. 使用virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);
+     *    其中proxy是VirtIOPCIProxy,其bus是自己的field,不是指针
+     * 2. 然后调用k->realize=virtio_blk_pci_realize()--> qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
+     *    让dev->parent_bus = bus, dev是VirtIOBlock, bus是VirtIOPCIProxy的bus
+     */
     DeviceState *proxy = DEVICE(BUS(bus)->parent);
 
+    /*
+     * 所有设置k->ioeventfd_enabled()的地方:
+     *   - hw/s390x/virtio-ccw.c|1770| <<virtio_ccw_bus_class_init>> k->ioeventfd_enabled = virtio_ccw_ioeventfd_enabled;
+     *   - hw/virtio/virtio-mmio.c|513| <<virtio_mmio_bus_class_init>> k->ioeventfd_enabled = virtio_mmio_ioeventfd_enabled;
+     *   - hw/virtio/virtio-pci.c|2929| <<virtio_pci_bus_class_init>> k->ioeventfd_enabled = virtio_pci_ioeventfd_enabled;
+     */
     return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
 }
 
@@ -280,6 +419,12 @@ int virtio_bus_set_host_notifier(VirtioBusState *bus, int n, bool assign)
                          __func__, strerror(-r), r);
             return r;
         }
+        /*
+	 * 设置的地方:
+	 *   - hw/virtio/virtio-pci.c|2930| <<virtio_pci_bus_class_init>> k->ioeventfd_assign = virtio_pci_ioeventfd_assign;
+	 *   - hw/virtio/virtio-mmio.c|514| <<virtio_mmio_bus_class_init>> k->ioeventfd_assign = virtio_mmio_ioeventfd_assign;
+	 *   - hw/s390x/virtio-ccw.c|1771| <<virtio_ccw_bus_class_init>> k->ioeventfd_assign = virtio_ccw_ioeventfd_assign;
+	 */
         r = k->ioeventfd_assign(proxy, notifier, n, true);
         if (r < 0) {
             error_report("%s: unable to assign ioeventfd: %d", __func__, r);
@@ -317,6 +462,12 @@ static char *virtio_bus_get_fw_dev_path(DeviceState *dev)
     return NULL;
 }
 
+/*
+ * TypeInfo virtio_bus_info.class_init = virtio_bus_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void virtio_bus_class_init(ObjectClass *klass, void *data)
 {
     BusClass *bus_class = BUS_CLASS(klass);
@@ -335,7 +486,12 @@ static const TypeInfo virtio_bus_info = {
 
 static void virtio_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&virtio_bus_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(virtio_register_types)
diff --git a/hw/virtio/virtio-pci.c b/hw/virtio/virtio-pci.c
index 3a01fe9..1babdf2 100644
--- a/hw/virtio/virtio-pci.c
+++ b/hw/virtio/virtio-pci.c
@@ -211,10 +211,24 @@ static int virtio_pci_load_queue(DeviceState *d, int n, QEMUFile *f)
     return 0;
 }
 
+/*
+ * 只被如下使用:
+ *   - hw/virtio/virtio-pci.c|2933| <<virtio_pci_bus_class_init>> k->ioeventfd_enabled = virtio_pci_ioeventfd_enabled;
+ *
+ * called by:
+ *   - hw/virtio/vhost-user.c|756| <<vhost_set_vring_file>> if (ioeventfd_enabled() && file->fd > 0) {
+ *   - hw/virtio/virtio-bus.c|331| <<virtio_bus_start_ioeventfd>> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
+ *   - hw/virtio/virtio-bus.c|395| <<virtio_bus_ioeventfd_enabled>> return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
+ */
 static bool virtio_pci_ioeventfd_enabled(DeviceState *d)
 {
     VirtIOPCIProxy *proxy = to_virtio_pci_proxy(d);
 
+    /*
+     * 设置或者使用的地方:
+     *   - hw/virtio/virtio-pci.c|218| <<virtio_pci_ioeventfd_enabled>> return (proxy->flags & VIRTIO_PCI_FLAG_USE_IOEVENTFD) != 0;
+     *   - hw/virtio/virtio-pci.c|1834| <<virtio_pci_realize>> proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;
+     */
     return (proxy->flags & VIRTIO_PCI_FLAG_USE_IOEVENTFD) != 0;
 }
 
@@ -283,6 +297,12 @@ static int virtio_pci_ioeventfd_assign(DeviceState *d, EventNotifier *notifier,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|335| <<virtio_ioport_write>> virtio_pci_start_ioeventfd(proxy);
+ *   - hw/virtio/virtio-pci.c|1076| <<virtio_pci_vmstate_change>> virtio_pci_start_ioeventfd(proxy);
+ *   - hw/virtio/virtio-pci.c|1288| <<virtio_pci_common_write>> virtio_pci_start_ioeventfd(proxy);
+ */
 static void virtio_pci_start_ioeventfd(VirtIOPCIProxy *proxy)
 {
     virtio_bus_start_ioeventfd(&proxy->bus);
@@ -480,6 +500,12 @@ static void virtio_pci_config_write(void *opaque, hwaddr addr,
     }
 }
 
+/*
+ * used only by virtio_pci_device_plugged():
+ *   1735         memory_region_init_io(&proxy->bar, OBJECT(proxy),
+ *   1736                               &virtio_pci_config_ops,
+ *   1737                               proxy, "virtio-pci", size);
+ */
 static const MemoryRegionOps virtio_pci_config_ops = {
     .read = virtio_pci_config_read,
     .write = virtio_pci_config_write,
@@ -960,6 +986,10 @@ static bool virtio_pci_query_guest_notifiers(DeviceState *d)
     return msix_enabled(&proxy->pci_dev);
 }
 
+/*
+ * used only by (k是VirtioBusClass):
+ *   - hw/virtio/virtio-pci.c|2791| <<virtio_pci_bus_class_init>> k->set_guest_notifiers = virtio_pci_set_guest_notifiers;
+ */
 static int virtio_pci_set_guest_notifiers(DeviceState *d, int nvqs, bool assign)
 {
     VirtIOPCIProxy *proxy = to_virtio_pci_proxy(d);
@@ -1139,6 +1169,10 @@ static int virtio_pci_query_nvectors(DeviceState *d)
     return proxy->nvectors;
 }
 
+/*
+ * used by:
+ *   - hw/virtio/virtio-pci.c|2862| <<virtio_pci_bus_class_init>> k->get_dma_as = virtio_pci_get_dma_as;
+ */
 static AddressSpace *virtio_pci_get_dma_as(DeviceState *d)
 {
     VirtIOPCIProxy *proxy = VIRTIO_PCI(d);
@@ -1278,12 +1312,28 @@ static void virtio_pci_common_write(void *opaque, hwaddr addr,
         vdev->config_vector = val;
         break;
     case VIRTIO_PCI_COMMON_STATUS:
+	/*
+	 * virtio驱动会写的地方:
+	 *   - drivers/virtio/virtio_pci_modern.c|281| <<vp_set_status>> vp_iowrite8(status, &vp_dev->common->device_status);
+	 *   - drivers/virtio/virtio_pci_modern.c|288| <<vp_reset>> vp_iowrite8(0, &vp_dev->common->device_status);
+	 */
         if (!(val & VIRTIO_CONFIG_S_DRIVER_OK)) {
             virtio_pci_stop_ioeventfd(proxy);
         }
 
         virtio_set_status(vdev, val & 0xFF);
 
+	/*
+	 * 在guest virtio驱动用以下激活:
+	 * 212 static inline
+	 * 213 void virtio_device_ready(struct virtio_device *dev)
+	 * 214 {
+	 * 215         unsigned status = dev->config->get_status(dev);
+	 * 216 
+	 * 217         BUG_ON(status & VIRTIO_CONFIG_S_DRIVER_OK);
+	 * 218         dev->config->set_status(dev, status | VIRTIO_CONFIG_S_DRIVER_OK);
+	 * 219 }
+	 */
         if (val & VIRTIO_CONFIG_S_DRIVER_OK) {
             virtio_pci_start_ioeventfd(proxy);
         }
@@ -1567,6 +1617,43 @@ static void virtio_pci_pre_plugged(DeviceState *d, Error **errp)
 }
 
 /* This is called by virtio-bus just after the device is plugged. */
+/*
+ * (gdb) bt
+ * #0  virtio_pci_device_plugged (d=0x55555777db80, errp=0x7fffffffda48) at hw/virtio/virtio-pci.c:1571
+ * #1  0x0000555555b8c083 in virtio_bus_device_plugged (vdev=0x555557785cf0, errp=0x7fffffffdaa0) at hw/virtio/virtio-bus.c:74
+ * #2  0x00005555558ca3d1 in virtio_device_realize (dev=0x555557785cf0, errp=0x7fffffffdb00)
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2525
+ * #3  0x0000555555a2d447 in device_set_realized (obj=0x555557785cf0, value=true, errp=0x7fffffffdd38) at hw/core/qdev.c:826
+ * #4  0x0000555555c21bc7 in property_set_bool (obj=0x555557785cf0, v=0x555557790940, name=0x555555e3cce6 "realized", opaque=0x555557787620, 
+ *     errp=0x7fffffffdd38) at qom/object.c:1984
+ * #5  0x0000555555c1fe4c in object_property_set (obj=0x555557785cf0, v=0x555557790940, name=0x555555e3cce6 "realized", errp=0x7fffffffdd38)
+ *     at qom/object.c:1176
+ * #6  0x0000555555c22f04 in object_property_set_qobject (obj=0x555557785cf0, value=0x555557790890, name=0x555555e3cce6 "realized", 
+ *     errp=0x7fffffffdd38) at qom/qom-qobject.c:27
+ * #7  0x0000555555c20131 in object_property_set_bool (obj=0x555557785cf0, value=true, name=0x555555e3cce6 "realized", errp=0x7fffffffdd38)
+ *     at qom/object.c:1242
+ * #8  0x0000555555b92c9f in virtio_blk_pci_realize (vpci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1970
+ * #9  0x0000555555b92682 in virtio_pci_realize (pci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1841
+ * #10 0x0000555555af770d in pci_qdev_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/pci/pci.c:2028
+ * #11 0x0000555555b92a90 in virtio_pci_dc_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/virtio/virtio-pci.c:1915
+ * #12 0x0000555555a2d447 in device_set_realized (obj=0x55555777db80, value=true, errp=0x7fffffffdfc0) at hw/core/qdev.c:826
+ * #13 0x0000555555c21bc7 in property_set_bool (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", opaque=0x555557785fa0, 
+ *     errp=0x7fffffffdfc0) at qom/object.c:1984
+ * #14 0x0000555555c1fe4c in object_property_set (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1176
+ * #15 0x0000555555c22f04 in object_property_set_qobject (obj=0x55555777db80, value=0x55555778a8a0, name=0x555555db778a "realized", 
+ *     errp=0x7fffffffdfc0) at qom/qom-qobject.c:27
+ * #16 0x0000555555c20131 in object_property_set_bool (obj=0x55555777db80, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1242
+ * #17 0x0000555555990749 in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe038) at qdev-monitor.c:627
+ * #18 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+ * #19 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, 
+ *     errp=0x0) at util/qemu-option.c:1106
+ * #20 0x000055555599dd61 in main (argc=15, argv=0x7fffffffe3a8, envp=0x7fffffffe428) at vl.c:4542
+ *
+ * only used by virtio_pci_device_plugged() k是VirtioBusClass:
+ *   - hw/virtio/virtio-pci.c|2867| <<virtio_pci_bus_class_init>> k->device_plugged = virtio_pci_device_plugged;
+ */
 static void virtio_pci_device_plugged(DeviceState *d, Error **errp)
 {
     VirtIOPCIProxy *proxy = VIRTIO_PCI(d);
@@ -1726,6 +1813,30 @@ static void virtio_pci_device_unplugged(DeviceState *d)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_pci_realize (pci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1731
+ * #1  0x0000555555af770d in pci_qdev_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/pci/pci.c:2028
+ * #2  0x0000555555b92a90 in virtio_pci_dc_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/virtio/virtio-pci.c:1915
+ * #3  0x0000555555a2d447 in device_set_realized (obj=0x55555777db80, value=true, errp=0x7fffffffdfc0) at hw/core/qdev.c:826
+ * #4  0x0000555555c21bc7 in property_set_bool (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", opaque=0x555557785fa0, 
+ *     errp=0x7fffffffdfc0) at qom/object.c:1984
+ * #5  0x0000555555c1fe4c in object_property_set (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1176
+ * #6  0x0000555555c22f04 in object_property_set_qobject (obj=0x55555777db80, value=0x55555778a8a0, name=0x555555db778a "realized", 
+ *     errp=0x7fffffffdfc0) at qom/qom-qobject.c:27
+ * #7  0x0000555555c20131 in object_property_set_bool (obj=0x55555777db80, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1242
+ * #8  0x0000555555990749 in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe038) at qdev-monitor.c:627
+ * #9  0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+ * #10 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, 
+ *     errp=0x0) at util/qemu-option.c:1106
+ * #11 0x000055555599dd61 in main (argc=15, argv=0x7fffffffe3a8, envp=0x7fffffffe428) at vl.c:4542
+ *
+ *
+ * used only by (k是PCIDeviceClass):
+ *   - hw/virtio/virtio-pci.c|1977| <<virtio_pci_class_init>> k->realize = virtio_pci_realize;
+ */
 static void virtio_pci_realize(PCIDevice *pci_dev, Error **errp)
 {
     VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);
@@ -1734,6 +1845,11 @@ static void virtio_pci_realize(PCIDevice *pci_dev, Error **errp)
                      !pci_bus_is_root(pci_get_bus(pci_dev));
 
     if (kvm_enabled() && !kvm_has_many_ioeventfds()) {
+        /*
+	 * 设置或者使用的地方:
+	 *   - hw/virtio/virtio-pci.c|218| <<virtio_pci_ioeventfd_enabled>> return (proxy->flags & VIRTIO_PCI_FLAG_USE_IOEVENTFD) != 0;
+	 *   - hw/virtio/virtio-pci.c|1834| <<virtio_pci_realize>> proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;
+	 */
         proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;
     }
 
@@ -1836,7 +1952,13 @@ static void virtio_pci_realize(PCIDevice *pci_dev, Error **errp)
         pci_dev->cap_present &= ~QEMU_PCI_CAP_EXPRESS;
     }
 
+    /*
+     * proxy->bus是自己的field, 不是内存指针
+     */
     virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);
+    /*
+     * 对于virtio blk pci, realize是virtio_blk_pci_realize()
+     */
     if (k->realize) {
         k->realize(proxy, errp);
     }
@@ -1901,6 +2023,11 @@ static Property virtio_pci_properties[] = {
     DEFINE_PROP_END_OF_LIST(),
 };
 
+/*
+ * used only by virtio_pci_class_init():
+ * 1993     device_class_set_parent_realize(dc, virtio_pci_dc_realize,
+ * 1994                                     &vpciklass->parent_dc_realize);
+ */
 static void virtio_pci_dc_realize(DeviceState *qdev, Error **errp)
 {
     VirtioPCIClass *vpciklass = VIRTIO_PCI_GET_CLASS(qdev);
@@ -1915,6 +2042,12 @@ static void virtio_pci_dc_realize(DeviceState *qdev, Error **errp)
     vpciklass->parent_dc_realize(qdev, errp);
 }
 
+/*
+ * TypeInfo virtio_pci_info.class_init = virtio_pci_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void virtio_pci_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(klass);
@@ -1927,6 +2060,31 @@ static void virtio_pci_class_init(ObjectClass *klass, void *data)
     k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;
     k->revision = VIRTIO_PCI_ABI_VERSION;
     k->class_id = PCI_CLASS_OTHERS;
+    /*
+     * 把dc(DeviceClass, 更上一即)的realize设置成virtio_pci_dc_realize()
+     * 把原realize(应该是pci_qdev_realize())保存在vpciklass->parent_dc_realize
+     *
+     * realize的时候是从virtio device过来的
+     * (gdb) bt
+     * #0  virtio_blk_pci_realize (vpci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1962
+     * #1  0x0000555555b92682 in virtio_pci_realize (pci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1841
+     * #2  0x0000555555af770d in pci_qdev_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/pci/pci.c:2028
+     * #3  0x0000555555b92a90 in virtio_pci_dc_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/virtio/virtio-pci.c:1915
+     * #4  0x0000555555a2d447 in device_set_realized (obj=0x55555777db80, value=true, errp=0x7fffffffdfc0) at hw/core/qdev.c:826
+     * #5  0x0000555555c21bc7 in property_set_bool (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", opaque=0x555557785fa0, 
+     *     errp=0x7fffffffdfc0) at qom/object.c:1984
+     * #6  0x0000555555c1fe4c in object_property_set (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+     *     at qom/object.c:1176
+     * #7  0x0000555555c22f04 in object_property_set_qobject (obj=0x55555777db80, value=0x55555778a8a0, name=0x555555db778a "realized", 
+     *     errp=0x7fffffffdfc0) at qom/qom-qobject.c:27
+     * #8  0x0000555555c20131 in object_property_set_bool (obj=0x55555777db80, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+     *     at qom/object.c:1242
+     * #9  0x0000555555990749 in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe038) at qdev-monitor.c:627
+     * #10 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+     * #11 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, 
+     *     errp=0x0) at util/qemu-option.c:1106
+     * #12 0x000055555599dd61 in main (argc=15, argv=0x7fffffffe3a8, envp=0x7fffffffe428) at vl.c:4542
+     */
     device_class_set_parent_realize(dc, virtio_pci_dc_realize,
                                     &vpciklass->parent_dc_realize);
     dc->reset = virtio_pci_reset;
@@ -1948,6 +2106,12 @@ static const TypeInfo virtio_pci_info = {
 
 /* virtio-blk-pci */
 
+/*
+ * used only by:
+ *   - hw/virtio/virtio-pci.c|1986| <<virtio_blk_pci_class_init>> dc->props = virtio_blk_pci_properties;
+ *
+ * 在virtio_instance_init_common()中用qdev_alias_all_properties()指向virtio-blk的prop
+ */
 static Property virtio_blk_pci_properties[] = {
     DEFINE_PROP_UINT32("class", VirtIOPCIProxy, class_code, 0),
     DEFINE_PROP_BIT("ioeventfd", VirtIOPCIProxy, flags,
@@ -1957,19 +2121,70 @@ static Property virtio_blk_pci_properties[] = {
     DEFINE_PROP_END_OF_LIST(),
 };
 
+/*
+ * realize的时候是从virtio device过来的
+ * (gdb) bt
+ * #0  virtio_blk_pci_realize (vpci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1962
+ * #1  0x0000555555b92682 in virtio_pci_realize (pci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1841
+ * #2  0x0000555555af770d in pci_qdev_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/pci/pci.c:2028
+ * #3  0x0000555555b92a90 in virtio_pci_dc_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/virtio/virtio-pci.c:1915
+ * #4  0x0000555555a2d447 in device_set_realized (obj=0x55555777db80, value=true, errp=0x7fffffffdfc0) at hw/core/qdev.c:826
+ * #5  0x0000555555c21bc7 in property_set_bool (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", opaque=0x555557785fa0, 
+ *     errp=0x7fffffffdfc0) at qom/object.c:1984
+ * #6  0x0000555555c1fe4c in object_property_set (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1176
+ * #7  0x0000555555c22f04 in object_property_set_qobject (obj=0x55555777db80, value=0x55555778a8a0, name=0x555555db778a "realized", 
+ *     errp=0x7fffffffdfc0) at qom/qom-qobject.c:27
+ * #8  0x0000555555c20131 in object_property_set_bool (obj=0x55555777db80, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1242
+ * #9  0x0000555555990749 in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe038) at qdev-monitor.c:627
+ * #10 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+ * #11 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, 
+ *     errp=0x0) at util/qemu-option.c:1106
+ * #12 0x000055555599dd61 in main (argc=15, argv=0x7fffffffe3a8, envp=0x7fffffffe428) at vl.c:4542
+ *
+ * used only by:
+ *   - hw/virtio/virtio-pci.c|1987| <<virtio_blk_pci_class_init>> k->realize = virtio_blk_pci_realize; k是VirtioPCIClass
+ */
 static void virtio_blk_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
 {
     VirtIOBlkPCI *dev = VIRTIO_BLK_PCI(vpci_dev);
+    /* 这里获得的是VirtIOBlock */
     DeviceState *vdev = DEVICE(&dev->vdev);
 
     if (vpci_dev->nvectors == DEV_NVECTORS_UNSPECIFIED) {
         vpci_dev->nvectors = dev->vdev.conf.num_queues + 1;
     }
 
+    /*
+     * vdev是VirtIOBlock
+     * vpci_dev是VirtIOPCIProxy
+     */
     qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
+    /*
+     * 间接调用VirtIOBlock的realize, 似乎是virtio_device_realize()
+     */
     object_property_set_bool(OBJECT(vdev), true, "realized", errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_blk_pci_class_init (klass=0x55555658ebe0, data=0x0) at hw/virtio/virtio-pci.c:1975
+ * #1  0x0000555555c1df88 in type_initialize (ti=0x555556527f40) at qom/object.c:342
+ * #2  0x0000555555c1f2f8 in object_class_foreach_tramp (key=0x5555565280c0, value=0x555556527f40, opaque=0x7fffffffdfd0) at qom/object.c:867
+ * #3  0x00007ffff5e88340 in g_hash_table_foreach () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #4  0x0000555555c1f3d7 in object_class_foreach (fn=0x555555c1f528 <object_class_get_list_tramp>, implements_type=0x555555db81d6 "machine", 
+ *     include_abstract=false, opaque=0x7fffffffe020) at qom/object.c:889
+ * #5  0x0000555555c1f5a6 in object_class_get_list (implements_type=0x555555db81d6 "machine", include_abstract=false) at qom/object.c:943
+ * #6  0x0000555555995b91 in find_default_machine () at vl.c:1417
+ * #7  0x0000555555999a80 in select_machine () at vl.c:2669
+ * #8  0x000055555599c9ab in main (argc=15, argv=0x7fffffffe3a8, envp=0x7fffffffe428) at vl.c:3988
+ *
+ * TypeInfo virtio_blk_pci_info.class_init = virtio_blk_pci_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void virtio_blk_pci_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(klass);
@@ -1978,6 +2193,10 @@ static void virtio_blk_pci_class_init(ObjectClass *klass, void *data)
 
     set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
     dc->props = virtio_blk_pci_properties;
+    /*
+     * called only by:
+     *   - hw/virtio/virtio-pci.c|1944| <<virtio_pci_realize>> k->realize(proxy, errp);
+     */
     k->realize = virtio_blk_pci_realize;
     pcidev_k->vendor_id = PCI_VENDOR_ID_REDHAT_QUMRANET;
     pcidev_k->device_id = PCI_DEVICE_ID_VIRTIO_BLOCK;
@@ -1985,10 +2204,39 @@ static void virtio_blk_pci_class_init(ObjectClass *klass, void *data)
     pcidev_k->class_id = PCI_CLASS_STORAGE_SCSI;
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_blk_pci_instance_init (obj=0x55555777db80) at hw/virtio/virtio-pci.c:1990
+ * #1  0x0000555555c1dfee in object_init_with_type (obj=0x55555777db80, ti=0x555556527f40) at qom/object.c:353
+ * #2  0x0000555555c1e1b1 in object_initialize_with_type (data=0x55555777db80, size=33696, type=0x555556527f40) at qom/object.c:384
+ * #3  0x0000555555c1e805 in object_new_with_type (type=0x555556527f40) at qom/object.c:546
+ * #4  0x0000555555c1e842 in object_new (typename=0x555556536340 "virtio-blk-pci") at qom/object.c:556
+ * #5  0x000055555599064c in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe038) at qdev-monitor.c:608
+ * #6  0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+ * #7  0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, 
+ *     errp=0x0) at util/qemu-option.c:1106
+ * #8  0x000055555599dd61 in main (argc=15, argv=0x7fffffffe3a8, envp=0x7fffffffe428) at vl.c:4542
+ *
+ * TypeInfo virtio_blk_pci_info.instance_init = virtio_blk_pci_instance_init()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void virtio_blk_pci_instance_init(Object *obj)
 {
     VirtIOBlkPCI *dev = VIRTIO_BLK_PCI(obj);
 
+    /*
+     * 最终间接调用virtio_blk_instance_init()
+     *
+     * obj是VirtIOBlkPCI (TYPE_VIRTIO_BLK_PCI)
+     * &dev->vdev是VirtIOBlock (TYPE_VIRTIO_BLK)
+     *
+     * 针对virtblk的例子:
+     *   用object_initialize()针对TYPE_VIRTIO_BLK初始化其object
+     *   间接调用其virtio_blk_instance_init()
+     *   然后把VirtIOBlock(TYPE_VIRTIO_BLK)设置为VirtIOBlkPCI(TYPE_VIRTIO_BLK_PCI)的child(child<virtio-backend>)
+     */
     virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
                                 TYPE_VIRTIO_BLK);
     object_property_add_alias(obj, "bootindex", OBJECT(&dev->vdev),
@@ -1998,6 +2246,9 @@ static void virtio_blk_pci_instance_init(Object *obj)
 static const TypeInfo virtio_blk_pci_info = {
     .name          = TYPE_VIRTIO_BLK_PCI,
     .parent        = TYPE_VIRTIO_PCI,
+    /*
+     * 包含VirtIOPCIProxy和VirtIOBlock
+     */
     .instance_size = sizeof(VirtIOBlkPCI),
     .instance_init = virtio_blk_pci_instance_init,
     .class_init    = virtio_blk_pci_class_init,
@@ -2647,21 +2898,43 @@ static const TypeInfo virtio_host_pci_info = {
 
 /* virtio-pci-bus */
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio-pci.c|1936| <<virtio_pci_realize>> virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);
+ */
 static void virtio_pci_bus_new(VirtioBusState *bus, size_t bus_size,
                                VirtIOPCIProxy *dev)
 {
+    /*
+     * VirtIOPCIProxy包含PCIDevice包含DeviceState
+     */
     DeviceState *qdev = DEVICE(dev);
+    /* TYPE_VIRTIO_BUS */
     char virtio_bus_name[] = "virtio-bus";
 
     qbus_create_inplace(bus, bus_size, TYPE_VIRTIO_PCI_BUS, qdev,
                         virtio_bus_name);
 }
 
+/*
+ * TypeInfo virtio_pci_bus_info.class_init = virtio_pci_bus_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void virtio_pci_bus_class_init(ObjectClass *klass, void *data)
 {
     BusClass *bus_class = BUS_CLASS(klass);
     VirtioBusClass *k = VIRTIO_BUS_CLASS(klass);
     bus_class->max_dev = 1;
+    /*  
+     * notify设置的地方:
+     *   - hw/virtio/virtio-pci.c|2891| <<virtio_pci_bus_class_init>> k->notify = virtio_pci_notify;
+     *   - hw/virtio/virtio-mmio.c|509| <<virtio_mmio_bus_class_init>> k->notify = virtio_mmio_update_irq;
+     *
+     * notify调用的地方:
+     *   - hw/virtio/virtio.c|1562| <<virtio_notify_vector>> k->notify(qbus->parent, vector);
+     */
     k->notify = virtio_pci_notify;
     k->save_config = virtio_pci_save_config;
     k->load_config = virtio_pci_load_config;
@@ -2692,6 +2965,7 @@ static const TypeInfo virtio_pci_bus_info = {
 
 static void virtio_pci_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&virtio_rng_pci_info);
     type_register_static(&virtio_input_pci_info);
     type_register_static(&virtio_input_hid_pci_info);
@@ -2701,11 +2975,14 @@ static void virtio_pci_register_types(void)
 #ifdef CONFIG_LINUX
     type_register_static(&virtio_host_pci_info);
 #endif
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&virtio_pci_bus_info);
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&virtio_pci_info);
 #ifdef CONFIG_VIRTFS
     type_register_static(&virtio_9p_pci_info);
 #endif
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&virtio_blk_pci_info);
 #if defined(CONFIG_VHOST_USER) && defined(CONFIG_LINUX)
     type_register_static(&vhost_user_blk_pci_info);
@@ -2725,4 +3002,8 @@ static void virtio_pci_register_types(void)
 #endif
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(virtio_pci_register_types)
diff --git a/hw/virtio/virtio-pci.h b/hw/virtio/virtio-pci.h
index 813082b..3b98330 100644
--- a/hw/virtio/virtio-pci.h
+++ b/hw/virtio/virtio-pci.h
@@ -63,6 +63,7 @@ typedef struct VirtIOCryptoPCI VirtIOCryptoPCI;
 typedef struct VirtioBusState VirtioPCIBusState;
 typedef struct VirtioBusClass VirtioPCIBusClass;
 
+/* TypeInfo virtio_pci_bus_info */
 #define TYPE_VIRTIO_PCI_BUS "virtio-pci-bus"
 #define VIRTIO_PCI_BUS(obj) \
         OBJECT_CHECK(VirtioPCIBusState, (obj), TYPE_VIRTIO_PCI_BUS)
@@ -90,6 +91,11 @@ enum {
 
 /* Performance improves when virtqueue kick processing is decoupled from the
  * vcpu thread using ioeventfd for some devices. */
+/*
+ * 设置和使用的地方:
+ *   - hw/virtio/virtio-pci.c|218| <<virtio_pci_ioeventfd_enabled>> return (proxy->flags & VIRTIO_PCI_FLAG_USE_IOEVENTFD) != 0;
+ *   - hw/virtio/virtio-pci.c|1834| <<virtio_pci_realize>> proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;
+ */
 #define VIRTIO_PCI_FLAG_USE_IOEVENTFD   (1 << VIRTIO_PCI_FLAG_USE_IOEVENTFD_BIT)
 
 /* virtio version flags */
@@ -127,6 +133,7 @@ typedef struct {
 /*
  * virtio-pci: This is the PCIDevice which has a virtio-pci-bus.
  */
+/* TypeInfo virtio_pci_info */
 #define TYPE_VIRTIO_PCI "virtio-pci"
 #define VIRTIO_PCI_GET_CLASS(obj) \
         OBJECT_GET_CLASS(VirtioPCIClass, obj, TYPE_VIRTIO_PCI)
@@ -138,6 +145,10 @@ typedef struct {
 typedef struct VirtioPCIClass {
     PCIDeviceClass parent_class;
     DeviceRealize parent_dc_realize;
+    /*
+     * called only by:
+     *   - hw/virtio/virtio-pci.c|1944| <<virtio_pci_realize>> k->realize(proxy, errp);
+     */
     void (*realize)(VirtIOPCIProxy *vpci_dev, Error **errp);
 } VirtioPCIClass;
 
@@ -265,6 +276,7 @@ struct VHostUserBlkPCI {
 /*
  * virtio-blk-pci: This extends VirtioPCIProxy.
  */
+/* TypeInfo virtio_blk_pci_info */
 #define TYPE_VIRTIO_BLK_PCI "virtio-blk-pci"
 #define VIRTIO_BLK_PCI(obj) \
         OBJECT_CHECK(VirtIOBlkPCI, (obj), TYPE_VIRTIO_BLK_PCI)
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index d4e4d98..2706f8b 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -111,20 +111,37 @@ struct VirtQueue
     QLIST_ENTRY(VirtQueue) node;
 };
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|133| <<virtio_virtqueue_reset_region_cache>> call_rcu(caches, virtio_free_region_cache, rcu);
+ *   - hw/virtio/virtio.c|179| <<virtio_init_region_cache>> call_rcu(old, virtio_free_region_cache, rcu);
+ */
 static void virtio_free_region_cache(VRingMemoryRegionCaches *caches)
 {
     if (!caches) {
         return;
     }
 
+    /*
+     * desc, avail和used都是MemoryRegionCache类型
+     */
     address_space_cache_destroy(&caches->desc);
     address_space_cache_destroy(&caches->avail);
     address_space_cache_destroy(&caches->used);
     g_free(caches);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|191| <<virtio_init_region_cache>> virtio_virtqueue_reset_region_cache(vq);
+ *   - hw/virtio/virtio.c|1256| <<virtio_reset>> virtio_virtqueue_reset_region_cache(&vdev->vq[i]);
+ *   - hw/virtio/virtio.c|2694| <<virtio_device_free_virtqueues>> virtio_virtqueue_reset_region_cache(&vdev->vq[i]);
+ */
 static void virtio_virtqueue_reset_region_cache(struct VirtQueue *vq)
 {
+    /*
+     * VRingMemoryRegionCaches包含MemoryRegionCache类型的desc, avail和used
+     */
     VRingMemoryRegionCaches *caches;
 
     caches = atomic_read(&vq->vring.caches);
@@ -134,6 +151,17 @@ static void virtio_virtqueue_reset_region_cache(struct VirtQueue *vq)
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|245| <<virtio_queue_update_rings>> virtio_init_region_cache(vdev, n);
+ *   - hw/virtio/virtio.c|1522| <<virtio_queue_set_rings>> virtio_init_region_cache(vdev, n);
+ *   - hw/virtio/virtio.c|2244| <<virtio_load>> virtio_init_region_cache(vdev, i);
+ *   - hw/virtio/virtio.c|2651| <<virtio_memory_listener_commit>> virtio_init_region_cache(vdev, i);
+ *
+ * n是queue的index
+ *
+ * map下queue n的desc, avail和used三个ring buffer
+ */
 static void virtio_init_region_cache(VirtIODevice *vdev, int n)
 {
     VirtQueue *vq = &vdev->vq[n];
@@ -143,6 +171,12 @@ static void virtio_init_region_cache(VirtIODevice *vdev, int n)
     int event_size;
     int64_t len;
 
+    /*
+     * 查看VirtIODevice->guest_features的对应bit是否设置了VIRTIO_RING_F_EVENT_IDX
+     *
+     * 后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+     * 同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+     */
     event_size = virtio_vdev_has_feature(vq->vdev, VIRTIO_RING_F_EVENT_IDX) ? 2 : 0;
 
     addr = vq->vring.desc;
@@ -150,6 +184,10 @@ static void virtio_init_region_cache(VirtIODevice *vdev, int n)
         goto out_no_cache;
     }
     new = g_new0(VRingMemoryRegionCaches, 1);
+    /*
+     * size是sizeof(VRingDesc) * vdev->vq[n].vring.num
+     * size是desc的buffer的总的size(以byte为单位)
+     */
     size = virtio_queue_get_desc_size(vdev, n);
     len = address_space_cache_init(&new->desc, vdev->dma_as,
                                    addr, size, false);
@@ -158,6 +196,10 @@ static void virtio_init_region_cache(VirtIODevice *vdev, int n)
         goto err_desc;
     }
 
+    /*
+     * virtio_queue_get_used_size()返回整个VRingUsed占用的内存size, 包括后面的VRingUsedElem们
+     * 上面的event_size如果有VIRTIO_RING_F_EVENT_IDX是2, 也就是uint16_t=2个byte!
+     */
     size = virtio_queue_get_used_size(vdev, n) + event_size;
     len = address_space_cache_init(&new->used, vdev->dma_as,
                                    vq->vring.used, size, true);
@@ -166,6 +208,10 @@ static void virtio_init_region_cache(VirtIODevice *vdev, int n)
         goto err_used;
     }
 
+    /*
+     * virtio_queue_get_used_size()返回整个VRingAvail占用的内存size, 包括后面的uint16_t们
+     * 上面的event_size如果有VIRTIO_RING_F_EVENT_IDX是2, 也就是uint16_t=2个byte!
+     */
     size = virtio_queue_get_avail_size(vdev, n) + event_size;
     len = address_space_cache_init(&new->avail, vdev->dma_as,
                                    vq->vring.avail, size, false);
@@ -192,6 +238,17 @@ out_no_cache:
 }
 
 /* virt queue functions */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1526| <<virtio_queue_set_addr>> virtio_queue_update_rings(vdev, n);
+ *   - hw/virtio/virtio.c|1610| <<virtio_queue_set_align>> virtio_queue_update_rings(vdev, n);
+ *   - hw/virtio/virtio.c|2267| <<virtio_load>> virtio_queue_update_rings(vdev, i);
+ *   - hw/virtio/virtio-mmio.c|261| <<virtio_mmio_write>> virtio_queue_update_rings(vdev, vdev->queue_sel);
+ *
+ * 根据desc的base地址, 设置avail和used的地址
+ * 在guest里分配的时候avail, used和desc是连续的
+ * 然后map下queue n的desc, avail和used三个ring buffer
+ */
 void virtio_queue_update_rings(VirtIODevice *vdev, int n)
 {
     VRing *vring = &vdev->vq[n].vring;
@@ -200,25 +257,50 @@ void virtio_queue_update_rings(VirtIODevice *vdev, int n)
         /* not yet setup -> nothing to do */
         return;
     }
+    /*
+     * 在guest里分配的时候avail, used和desc是连续的
+     *
+     * 这里根据desc的地址就可以设定另外两个
+     */
     vring->avail = vring->desc + vring->num * sizeof(VRingDesc);
     vring->used = vring_align(vring->avail +
                               offsetof(VRingAvail, ring[vring->num]),
                               vring->align);
+    /*
+     * map下queue n的desc, avail和used三个ring buffer
+     */
     virtio_init_region_cache(vdev, n);
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|692| <<virtqueue_read_next_desc>> vring_desc_read(vdev, desc, desc_cache, *next);
+ *   - hw/virtio/virtio.c|741| <<virtqueue_get_avail_bytes>> vring_desc_read(vdev, &desc, desc_cache, i);
+ *   - hw/virtio/virtio.c|767| <<virtqueue_get_avail_bytes>> vring_desc_read(vdev, &desc, desc_cache, i);
+ *   - hw/virtio/virtio.c|1003| <<virtqueue_pop>> vring_desc_read(vdev, &desc, desc_cache, i);
+ *   - hw/virtio/virtio.c|1021| <<virtqueue_pop>> vring_desc_read(vdev, &desc, desc_cache, i);
+ *
+ * 把第i个VRingDesc读入参数desc
+ */
 static void vring_desc_read(VirtIODevice *vdev, VRingDesc *desc,
                             MemoryRegionCache *cache, int i)
 {
+    /*
+     * 把第i个VRingDesc读入desc
+     */
     address_space_read_cached(cache, i * sizeof(VRingDesc),
                               desc, sizeof(VRingDesc));
+    /* 根据big/small endian的情况对desc的结果转换 */
     virtio_tswap64s(vdev, &desc->addr);
     virtio_tswap32s(vdev, &desc->len);
     virtio_tswap16s(vdev, &desc->flags);
     virtio_tswap16s(vdev, &desc->next);
 }
 
+/*
+ * 获得VRingMemoryRegionCaches类型的vq->vring.caches
+ */
 static VRingMemoryRegionCaches *vring_get_region_caches(struct VirtQueue *vq)
 {
     VRingMemoryRegionCaches *caches = atomic_rcu_read(&vq->vring.caches);
@@ -226,14 +308,21 @@ static VRingMemoryRegionCaches *vring_get_region_caches(struct VirtQueue *vq)
     return caches;
 }
 /* Called within rcu_read_lock().  */
+/*
+ * 返回VirtQueue的VRingAvail->flags
+ */
 static inline uint16_t vring_avail_flags(VirtQueue *vq)
 {
+    /* 获得VRingMemoryRegionCaches类型的vq->vring.caches */
     VRingMemoryRegionCaches *caches = vring_get_region_caches(vq);
     hwaddr pa = offsetof(VRingAvail, flags);
     return virtio_lduw_phys_cached(vq->vdev, &caches->avail, pa);
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * 把VRingAvail.idx读入vq->shadow_avail_idx并返回
+ */
 static inline uint16_t vring_avail_idx(VirtQueue *vq)
 {
     VRingMemoryRegionCaches *caches = vring_get_region_caches(vq);
@@ -243,6 +332,9 @@ static inline uint16_t vring_avail_idx(VirtQueue *vq)
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * 返回VRingAvail.ring[i]的内容
+ */
 static inline uint16_t vring_avail_ring(VirtQueue *vq, int i)
 {
     VRingMemoryRegionCaches *caches = vring_get_region_caches(vq);
@@ -251,12 +343,21 @@ static inline uint16_t vring_avail_ring(VirtQueue *vq, int i)
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * 返回VRingAvail.ring[vq->vring.num]的内容
+ * 这个和VIRTIO_RING_F_EVENT_IDX相关
+ * 后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+ * 同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+ */
 static inline uint16_t vring_get_used_event(VirtQueue *vq)
 {
     return vring_avail_ring(vq, vq->vring.num);
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * 把参数VRingUsedElem写入VRingUsed->ring[i]
+ */
 static inline void vring_used_write(VirtQueue *vq, VRingUsedElem *uelem,
                                     int i)
 {
@@ -269,6 +370,9 @@ static inline void vring_used_write(VirtQueue *vq, VRingUsedElem *uelem,
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * 返回VRingUsed->idx
+ */
 static uint16_t vring_used_idx(VirtQueue *vq)
 {
     VRingMemoryRegionCaches *caches = vring_get_region_caches(vq);
@@ -277,6 +381,10 @@ static uint16_t vring_used_idx(VirtQueue *vq)
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * 把val写入VRingUsed->idx
+ * 并且把val写入vq->used_idx
+ */
 static inline void vring_used_idx_set(VirtQueue *vq, uint16_t val)
 {
     VRingMemoryRegionCaches *caches = vring_get_region_caches(vq);
@@ -287,6 +395,9 @@ static inline void vring_used_idx_set(VirtQueue *vq, uint16_t val)
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * 把参数mask应用到VirtQueue的VRingUsed->flags
+ */
 static inline void vring_used_flags_set_bit(VirtQueue *vq, int mask)
 {
     VRingMemoryRegionCaches *caches = vring_get_region_caches(vq);
@@ -299,6 +410,9 @@ static inline void vring_used_flags_set_bit(VirtQueue *vq, int mask)
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * 把参数mask从VirtQueue的VRingUsed->flags中移除
+ */
 static inline void vring_used_flags_unset_bit(VirtQueue *vq, int mask)
 {
     VRingMemoryRegionCaches *caches = vring_get_region_caches(vq);
@@ -311,6 +425,12 @@ static inline void vring_used_flags_unset_bit(VirtQueue *vq, int mask)
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * 把val写入used的vring的最后一个元素的位置
+ * VIRTIO_RING_F_EVENT_IDX
+ *   后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+ *   同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+ */
 static inline void vring_set_avail_event(VirtQueue *vq, uint16_t val)
 {
     VRingMemoryRegionCaches *caches;
@@ -334,11 +454,31 @@ void virtio_queue_set_notification(VirtQueue *vq, int enable)
     }
 
     rcu_read_lock();
+    /*
+     * 查看VirtIODevice->guest_features的对应bit(VIRTIO_RING_F_EVENT_IDX)是否设置了
+     * 后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+     * 同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+     */
     if (virtio_vdev_has_feature(vq->vdev, VIRTIO_RING_F_EVENT_IDX)) {
+        /*
+	 * 把val写入used的vring的最后一个元素的位置
+	 * vring_avail_idx()是把VRingAvail.idx读入vq->shadow_avail_idx并返回
+	 */
         vring_set_avail_event(vq, vring_avail_idx(vq));
     } else if (enable) {
+        /*
+	 * VRING_USED_F_NO_NOTIFY:
+	 *   The Host uses this in used->flags to advise the Guest: don't kick me when
+	 *   you add a buffer.  It's unreliable, so it's simply an optimization.  Guest
+	 *   will still kick if it's out of buffers.
+	 *
+	 * 把VRING_USED_F_NO_NOTIFY位从VRingUsed->flags删除
+	 */
         vring_used_flags_unset_bit(vq, VRING_USED_F_NO_NOTIFY);
     } else {
+        /*
+	 * 把VRING_USED_F_NO_NOTIFY位从VRingUsed->flags设置
+	 */
         vring_used_flags_set_bit(vq, VRING_USED_F_NO_NOTIFY);
     }
     if (enable) {
@@ -348,14 +488,26 @@ void virtio_queue_set_notification(VirtQueue *vq, int enable)
     rcu_read_unlock();
 }
 
+/*
+ * 确认vring的avail(hwaddr)是否是0, 不是返回true
+ */
 int virtio_queue_ready(VirtQueue *vq)
 {
+    /*
+     * vring是VRing
+     * avail是hwaddr
+     */
     return vq->vring.avail != 0;
 }
 
 /* Fetch avail_idx from VQ memory only when we really need to know if
  * guest has added some buffers.
  * Called within rcu_read_lock().  */
+/*
+ * shadow_avail_idx是最近在VRingAvail.idx读的值
+ * last_avail_idx最最近后端使用的值
+ * 如果两者相等, 说明没有pending的request
+ */
 static int virtio_queue_empty_rcu(VirtQueue *vq)
 {
     if (unlikely(!vq->vring.avail)) {
@@ -366,9 +518,17 @@ static int virtio_queue_empty_rcu(VirtQueue *vq)
         return 0;
     }
 
+    /*
+     * vring_avail_idx: 把VRingAvail.idx读入vq->shadow_avail_idx并返回
+     */
     return vring_avail_idx(vq) == vq->last_avail_idx;
 }
 
+/*
+ * shadow_avail_idx是最近在VRingAvail.idx读的值
+ * last_avail_idx最最近后端使用的值
+ * 如果两者相等, 说明没有pending的request
+ */
 int virtio_queue_empty(VirtQueue *vq)
 {
     bool empty;
@@ -387,6 +547,9 @@ int virtio_queue_empty(VirtQueue *vq)
     return empty;
 }
 
+/*
+ * 把VirtQueueElement中in_sg[]和out_sg[]数组的entry全部dma unmap
+ */
 static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,
                                unsigned int len)
 {
@@ -421,10 +584,17 @@ static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,
  * reset or other situations where a #VirtQueueElement is simply freed and will
  * not be pushed or discarded.
  */
+/*
+ * 把VirtQueueElement中in_sg[]和out_sg[]数组的entry全部dma unmap
+ * 并减少vq->inuse
+ */
 void virtqueue_detach_element(VirtQueue *vq, const VirtQueueElement *elem,
                               unsigned int len)
 {
     vq->inuse--;
+    /*
+     * 把VirtQueueElement中in_sg[]和out_sg[]数组的entry全部dma unmap
+     */
     virtqueue_unmap_sg(vq, elem, len);
 }
 
@@ -436,10 +606,19 @@ void virtqueue_detach_element(VirtQueue *vq, const VirtQueueElement *elem,
  * Pretend the most recent element wasn't popped from the virtqueue.  The next
  * call to virtqueue_pop() will refetch the element.
  */
+/*
+ * 把VirtQueueElement中in_sg[]和out_sg[]数组的entry全部dma unmap
+ * 并减少vq->inuse和最近用到的avail (last_avail_idx)
+ */
 void virtqueue_unpop(VirtQueue *vq, const VirtQueueElement *elem,
                      unsigned int len)
 {
+    /* 最近用到的avail */
     vq->last_avail_idx--;
+    /*
+     * 把VirtQueueElement中in_sg[]和out_sg[]数组的entry全部dma unmap
+     * 并减少vq->inuse
+     */
     virtqueue_detach_element(vq, elem, len);
 }
 
@@ -455,6 +634,10 @@ void virtqueue_unpop(VirtQueue *vq, const VirtQueueElement *elem,
  * Returns: true on success, false if @num is greater than the number of in use
  * elements.
  */
+/*
+ * 只被如下使用:
+ *   - hw/virtio/virtio-balloon.c|487| <<virtio_balloon_set_status>> (status & VIRTIO_CONFIG_S_DRIVER_OK) && virtqueue_rewind(s->svq, 1)) {
+ */
 bool virtqueue_rewind(VirtQueue *vq, unsigned int num)
 {
     if (num > vq->inuse) {
@@ -466,6 +649,14 @@ bool virtqueue_rewind(VirtQueue *vq, unsigned int num)
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|713| <<virtqueue_push>> virtqueue_fill(vq, elem, len, 0);
+ *   - hw/net/virtio-net.c|1278| <<virtio_net_receive_rcu>> virtqueue_fill(q->rx_vq, elem, total, i++);
+ *
+ * 把VirtQueueElement给unmap
+ * 根据VirtQueueElement制作VRingUsedElem, 然后写入VRingUsed->ring[idx+vq->used_idx]
+ */
 void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,
                     unsigned int len, unsigned int idx)
 {
@@ -473,6 +664,9 @@ void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,
 
     trace_virtqueue_fill(vq, elem, len, idx);
 
+    /*
+     * 把VirtQueueElement中in_sg[]和out_sg[]数组的entry全部dma unmap
+     */
     virtqueue_unmap_sg(vq, elem, len);
 
     if (unlikely(vq->vdev->broken)) {
@@ -487,10 +681,14 @@ void virtqueue_fill(VirtQueue *vq, const VirtQueueElement *elem,
 
     uelem.id = elem->index;
     uelem.len = len;
+    /* 把VRingUsedElem写入VRingUsed->ring[idx=idx+vq->used_idx] */
     vring_used_write(vq, &uelem, idx);
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * 核心思想是把VRingUsed->idx和vq->used_idx增加count
+ */
 void virtqueue_flush(VirtQueue *vq, unsigned int count)
 {
     uint16_t old, new;
@@ -509,27 +707,53 @@ void virtqueue_flush(VirtQueue *vq, unsigned int count)
     trace_virtqueue_flush(vq, count);
     old = vq->used_idx;
     new = old + count;
+    /*
+     * 把new写入VRingUsed->idx
+     * 并且把new写入vq->used_idx
+     */
     vring_used_idx_set(vq, new);
     vq->inuse -= count;
     if (unlikely((int16_t)(new - vq->signalled_used) < (uint16_t)(new - old)))
         vq->signalled_used_valid = false;
 }
 
+/*
+ * 核心思想是把VirtQueueElement给unmap
+ * 根据VirtQueueElement制作VRingUsedElem, 然后写入VRingUsed->ring[0+vq->used_idx]
+ * 把VRingUsed->idx和vq->used_idx增加1
+ */
 void virtqueue_push(VirtQueue *vq, const VirtQueueElement *elem,
                     unsigned int len)
 {
     rcu_read_lock();
+    /*
+     * 把VirtQueueElement给unmap
+     * 根据VirtQueueElement制作VRingUsedElem, 然后写入VRingUsed->ring[0+vq->used_idx]
+     */
     virtqueue_fill(vq, elem, len, 0);
+    /*
+     * 核心思想是把VRingUsed->idx和vq->used_idx增加1
+     */
     virtqueue_flush(vq, 1);
     rcu_read_unlock();
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * 首先把VRingAvail.idx读入vq->shadow_avail_idx
+ * 然后计算idx到vq->shadow_avail_idx的距离并返回距离
+ * 这个距离应该就是待处理的吧
+ */
 static int virtqueue_num_heads(VirtQueue *vq, unsigned int idx)
 {
+    /*
+     * 把VRingAvail.idx读入vq->shadow_avail_idx并返回
+     * num_heads就是avail最新的指针和idx之间的距离
+     */
     uint16_t num_heads = vring_avail_idx(vq) - idx;
 
     /* Check it isn't doing very strange things with descriptor numbers. */
+    /* 如果这个距离大于ring buffer size就有问题了 */
     if (num_heads > vq->vring.num) {
         virtio_error(vq->vdev, "Guest moved used index from %u to %u",
                      idx, vq->shadow_avail_idx);
@@ -541,15 +765,28 @@ static int virtqueue_num_heads(VirtQueue *vq, unsigned int idx)
         smp_rmb();
     }
 
+    /*
+     * 返回上面的距离
+     */
     return num_heads;
 }
 
 /* Called within rcu_read_lock().  */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|660| <<virtqueue_get_avail_bytes>> if (!virtqueue_get_head(vq, idx++, &i)) {
+ *   - hw/virtio/virtio.c|904| <<virtqueue_pop>> if (!virtqueue_get_head(vq, vq->last_avail_idx++, &head)) {
+ *   - hw/virtio/virtio.c|1029| <<virtqueue_drop_all>> if (!virtqueue_get_head(vq, vq->last_avail_idx, &elem.index)) {
+ *
+ * 把VRingAvail.ring[idx]的内容存入*head
+ * 其实就是得到VRingAvail.ring[idx]的内容
+ */
 static bool virtqueue_get_head(VirtQueue *vq, unsigned int idx,
                                unsigned int *head)
 {
     /* Grab the next descriptor number they're advertising, and increment
      * the index we've seen. */
+    /* 返回VRingAvail.ring[idx]的内容 */
     *head = vring_avail_ring(vq, idx % vq->vring.num);
 
     /* If their number is silly, that's a fatal mistake. */
@@ -567,11 +804,17 @@ enum {
     VIRTQUEUE_READ_DESC_MORE = 1,   /* more buffers in chain */
 };
 
+/*
+ * 如果desc的VRING_DESC_F_NEXT没设置, 说明当前的sk_buff或者io request结束了
+ * 否则从desc->next获取下一个desc的index读入参数*next
+ * 把第*next个VRingDesc读入参数desc
+ */
 static int virtqueue_read_next_desc(VirtIODevice *vdev, VRingDesc *desc,
                                     MemoryRegionCache *desc_cache, unsigned int max,
                                     unsigned int *next)
 {
     /* If this descriptor says it doesn't chain, we're done. */
+    /* 如果VRING_DESC_F_NEXT没设置, 说明当前的sk_buff或者io request结束了 */
     if (!(desc->flags & VRING_DESC_F_NEXT)) {
         return VIRTQUEUE_READ_DESC_DONE;
     }
@@ -586,10 +829,21 @@ static int virtqueue_read_next_desc(VirtIODevice *vdev, VRingDesc *desc,
         return VIRTQUEUE_READ_DESC_ERROR;
     }
 
+    /*
+     * 把第*next个VRingDesc读入参数desc
+     */
     vring_desc_read(vdev, desc, desc_cache, *next);
     return VIRTQUEUE_READ_DESC_MORE;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|969| <<virtqueue_avail_bytes>> virtqueue_get_avail_bytes(vq, &in_total, &out_total, in_bytes, out_bytes);
+ *   - hw/char/virtio-serial-bus.c|318| <<virtio_serial_guest_ready>> virtqueue_get_avail_bytes(vq, &bytes, NULL, 4096, 0);
+ *   - hw/virtio/virtio-rng.c|37| <<get_request_size>> virtqueue_get_avail_bytes(vq, &in, &out, quota, 0);
+ *
+ * 这个函数要遍历待处理的每一个avail和其desc们, 不为了处理, 只为了计算有多少in和out的bytes
+ */
 void virtqueue_get_avail_bytes(VirtQueue *vq, unsigned int *in_bytes,
                                unsigned int *out_bytes,
                                unsigned max_in_bytes, unsigned max_out_bytes)
@@ -613,16 +867,29 @@ void virtqueue_get_avail_bytes(VirtQueue *vq, unsigned int *in_bytes,
     }
 
     rcu_read_lock();
+    /* 后端下一个要处理的avail的idx */
     idx = vq->last_avail_idx;
     total_bufs = in_total = out_total = 0;
 
     max = vq->vring.num;
+    /* 获得VRingMemoryRegionCaches类型的vq->vring.caches */
     caches = vring_get_region_caches(vq);
     if (caches->desc.len < max * sizeof(VRingDesc)) {
         virtio_error(vdev, "Cannot map descriptor ring");
         goto err;
     }
 
+    /*
+     * virtqueue_num_heads()首先把VRingAvail.idx读入vq->shadow_avail_idx
+     * 然后计算idx到vq->shadow_avail_idx的距离并返回距离
+     * 这个距离应该就是待处理的吧
+     *
+     * 这里的idx一开始来自上面的vq->last_avail_idx
+     * 所以while就是判断当前是否还有待处理的avail
+     *
+     * 这个while应该是每次处理一个avail的元素
+     * 里面还有小循环, 处理每一组相关的desc
+     */
     while ((rc = virtqueue_num_heads(vq, idx)) > 0) {
         MemoryRegionCache *desc_cache = &caches->desc;
         unsigned int num_bufs;
@@ -631,12 +898,22 @@ void virtqueue_get_avail_bytes(VirtQueue *vq, unsigned int *in_bytes,
 
         num_bufs = total_bufs;
 
+	/*
+	 * 把VRingAvail.ring[idx]的内容存入&i
+	 * 其实就是得到VRingAvail.ring[idx]的内容
+	 * 然后idx++!!!! (会影响上面while循环)!
+	 */
         if (!virtqueue_get_head(vq, idx++, &i)) {
             goto err;
         }
 
+	/* 把第i个VRingDesc读入参数desc */
         vring_desc_read(vdev, &desc, desc_cache, i);
 
+	/*
+	 * 如果是indirect的, 这一组(一个sk_buff或者request)desc存放在别的地方,
+	 * 需要map过来 然后或者其第一个desc
+	 */
         if (desc.flags & VRING_DESC_F_INDIRECT) {
             if (desc.len % sizeof(VRingDesc)) {
                 virtio_error(vdev, "Invalid size for indirect buffer table");
@@ -680,6 +957,11 @@ void virtqueue_get_avail_bytes(VirtQueue *vq, unsigned int *in_bytes,
                 goto done;
             }
 
+	    /*
+	     * 如果desc的VRING_DESC_F_NEXT没设置, 说明当前的sk_buff或者io request结束了
+	     * 否则从desc->next获取下一个desc的index读入参数&i
+	     * 把第*next个VRingDesc读入参数desc
+	     */
             rc = virtqueue_read_next_desc(vdev, &desc, desc_cache, max, &i);
         } while (rc == VIRTQUEUE_READ_DESC_MORE);
 
@@ -715,15 +997,31 @@ err:
     goto done;
 }
 
+/*
+ * 只被virtio_net_has_buffers()调用两次:
+ *   - hw/net/virtio-net.c|1065| <<virtio_net_has_buffers>> !virtqueue_avail_bytes(q->rx_vq, bufsize, 0))) {
+ *   - hw/net/virtio-net.c|1074| <<virtio_net_has_buffers>> !virtqueue_avail_bytes(q->rx_vq, bufsize, 0))) {
+ *
+ * 这个函数要遍历待处理的每一个avail和其desc们, 不为了处理, 只为了计算有多少in和out的bytes
+ * 然后判断获得的in和out的bytes分别不大于参数的in_bytes和out_bytes
+ */
 int virtqueue_avail_bytes(VirtQueue *vq, unsigned int in_bytes,
                           unsigned int out_bytes)
 {
     unsigned int in_total, out_total;
 
+    /*
+     * 这个函数要遍历待处理的每一个avail和其desc们, 不为了处理, 只为了计算有多少in和out的bytes
+     */
     virtqueue_get_avail_bytes(vq, &in_total, &out_total, in_bytes, out_bytes);
     return in_bytes <= in_total && out_bytes <= out_total;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1219| <<virtqueue_pop>> map_ok = virtqueue_map_desc(vdev, &in_num, addr + out_num,
+ *   - hw/virtio/virtio.c|1228| <<virtqueue_pop>> map_ok = virtqueue_map_desc(vdev, &out_num, addr, iov,
+ */
 static bool virtqueue_map_desc(VirtIODevice *vdev, unsigned int *p_num_sg,
                                hwaddr *addr, struct iovec *iov,
                                unsigned int max_num_sg, bool is_write,
@@ -747,6 +1045,9 @@ static bool virtqueue_map_desc(VirtIODevice *vdev, unsigned int *p_num_sg,
             goto out;
         }
 
+	/*
+	 * Map a physical memory region into a host virtual address.
+	 */
         iov[num_sg].iov_base = dma_memory_map(vdev->dma_as, pa, &len,
                                               is_write ?
                                               DMA_DIRECTION_FROM_DEVICE :
@@ -774,6 +1075,9 @@ out:
  * virtqueue_unmap_sg() can't be used).  Assumes buffers weren't written to
  * yet.
  */
+/*
+ * 把iovec数组中的out_num+in_num个元素全部cpu_physical_memory_unmap()
+ */
 static void virtqueue_undo_map_desc(unsigned int out_num, unsigned int in_num,
                                     struct iovec *iov)
 {
@@ -787,6 +1091,10 @@ static void virtqueue_undo_map_desc(unsigned int out_num, unsigned int in_num,
     }
 }
 
+/*
+ * 把存着物理地址数组的addr[](hwaddr)中的一共*num_sg个地址map到host虚拟地址
+ * 并存储在iovec[]数组
+ */
 static void virtqueue_map_iovec(VirtIODevice *vdev, struct iovec *sg,
                                 hwaddr *addr, unsigned int *num_sg,
                                 int is_write)
@@ -811,14 +1119,48 @@ static void virtqueue_map_iovec(VirtIODevice *vdev, struct iovec *sg,
     }
 }
 
+/*
+ * 先把存着物理地址数组的elem->in_addr(hwaddr)中的一共&elem->in_num个地址
+ * map到host虚拟地址并存储在elem->in_sg(iovec类型)数组
+ * 再把存着物理地址数组的elem->out_addr(hwaddr)中的一共&elem->out_num个地址
+ * map到host虚拟地址并存储在elem->out_sg(iovec类型)数组
+ */
 void virtqueue_map(VirtIODevice *vdev, VirtQueueElement *elem)
 {
+    /*
+     * 把存着物理地址数组的elem->in_addr(hwaddr)中的一共&elem->in_num个地址
+     * map到host虚拟地址并存储在elem->in_sg(iovec类型)数组
+     */
     virtqueue_map_iovec(vdev, elem->in_sg, elem->in_addr, &elem->in_num, 1);
+    /*
+     * 把存着物理地址数组的elem->out_addr(hwaddr)中的一共&elem->out_num个地址
+     * map到host虚拟地址并存储在elem->out_sg(iovec类型)数组
+     */
     virtqueue_map_iovec(vdev, elem->out_sg, elem->out_addr, &elem->out_num, 0);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1290| <<virtqueue_pop>> elem = virtqueue_alloc_element(sz, out_num, in_num);
+ *   - hw/virtio/virtio.c|1386| <<qemu_get_virtqueue_element>> elem = virtqueue_alloc_element(sz, data.out_num, data.in_num);
+ *
+ * 分配一个结构,这个结构就是或者包含VirtQueueElement,在这个结构后面附着in_addr, out_addr等数据
+ * 结构的例子是VirtIOBlockReq或者virtio_gpu_ctrl_command
+ */
 static void *virtqueue_alloc_element(size_t sz, unsigned out_num, unsigned in_num)
 {
+    /*
+     * 44 typedef struct VirtQueueElement 
+     * 45 {    
+     * 46     unsigned int index;
+     * 47     unsigned int out_num;
+     * 48     unsigned int in_num;
+     * 49     hwaddr *in_addr;
+     * 50     hwaddr *out_addr;
+     * 51     struct iovec *in_sg;
+     * 52     struct iovec *out_sg;
+     * 53 } VirtQueueElement;
+     */
     VirtQueueElement *elem;
     size_t in_addr_ofs = QEMU_ALIGN_UP(sz, __alignof__(elem->in_addr[0]));
     size_t out_addr_ofs = in_addr_ofs + in_num * sizeof(elem->in_addr[0]);
@@ -839,6 +1181,21 @@ static void *virtqueue_alloc_element(size_t sz, unsigned out_num, unsigned in_nu
     return elem;
 }
 
+/*
+ * 一些例子:
+ *   - hw/block/virtio-blk.c|271| <<virtio_blk_get_request>> VirtIOBlockReq *req = virtqueue_pop(vq, sizeof(VirtIOBlockReq));
+ *   - hw/scsi/virtio-scsi.c|178| <<virtio_scsi_pop_req>> req = virtqueue_pop(vq, sizeof(VirtIOSCSIReq) + vs->cdb_size);
+ *   - hw/net/virtio-net.c|1347| <<virtio_net_flush_tx>> elem = virtqueue_pop(q->tx_vq, sizeof(VirtQueueElement));
+ *   - hw/display/virtio-gpu.c|931| <<virtio_gpu_handle_ctrl>> cmd = virtqueue_pop(vq, sizeof(struct virtio_gpu_ctrl_command))
+ *
+ * 参数sc的结构必须包含VirtQueueElement, 所以virtqueue_alloc_element()会
+ * 检查sc是否大于等于sizeof(VirtQueueElement)
+ *
+ * 从ring buffer把下一个avail的所有desc读出来
+ * 分配一个结构,这个结构就是或者包含VirtQueueElement
+ * 在这个结构后面附着in_addr, out_addr等指向的真是数据
+ * 结构的例子是VirtIOBlockReq或者virtio_gpu_ctrl_command
+ */
 void *virtqueue_pop(VirtQueue *vq, size_t sz)
 {
     unsigned int i, head, max;
@@ -858,6 +1215,11 @@ void *virtqueue_pop(VirtQueue *vq, size_t sz)
         return NULL;
     }
     rcu_read_lock();
+    /*
+     * shadow_avail_idx是最近在VRingAvail.idx读的值
+     * last_avail_idx最最近后端使用的值
+     * 如果两者相等, 说明没有pending的request
+     */
     if (virtio_queue_empty_rcu(vq)) {
         goto done;
     }
@@ -875,16 +1237,29 @@ void *virtqueue_pop(VirtQueue *vq, size_t sz)
         goto done;
     }
 
+    /*
+     * 把VRingAvail.ring[idx]的内容存入*head
+     * 其实就是得到VRingAvail.ring[idx]的内容
+     *
+     * 获得下一个avail的第一个desc
+     */
     if (!virtqueue_get_head(vq, vq->last_avail_idx++, &head)) {
         goto done;
     }
 
+    /*
+     * 后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+     * 同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+     */
     if (virtio_vdev_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX)) {
+        /* 把vq->last_avail_idx(下一个要处理的avail)写入used的vring的最后一个元素的位置 */
         vring_set_avail_event(vq, vq->last_avail_idx);
     }
 
+    /* i就是要处理的avail的第一个desc */
     i = head;
 
+    /* 获得VRingMemoryRegionCaches类型的vq->vring.caches */
     caches = vring_get_region_caches(vq);
     if (caches->desc.len < max * sizeof(VRingDesc)) {
         virtio_error(vdev, "Cannot map descriptor ring");
@@ -892,6 +1267,10 @@ void *virtqueue_pop(VirtQueue *vq, size_t sz)
     }
 
     desc_cache = &caches->desc;
+    /*
+     * 把第i个VRingDesc读入参数desc
+     * 此时i就是要处理的avail的第一个desc
+     */
     vring_desc_read(vdev, &desc, desc_cache, i);
     if (desc.flags & VRING_DESC_F_INDIRECT) {
         if (desc.len % sizeof(VRingDesc)) {
@@ -917,6 +1296,10 @@ void *virtqueue_pop(VirtQueue *vq, size_t sz)
     do {
         bool map_ok;
 
+	/*
+	 * addr[]和iov[]都是本地的数组
+	 */
+
         if (desc.flags & VRING_DESC_F_WRITE) {
             map_ok = virtqueue_map_desc(vdev, &in_num, addr + out_num,
                                         iov + out_num,
@@ -941,6 +1324,11 @@ void *virtqueue_pop(VirtQueue *vq, size_t sz)
             goto err_undo_map;
         }
 
+	/*
+	 * 如果desc的VRING_DESC_F_NEXT没设置, 说明当前的sk_buff或者io request结束了
+	 * 否则从desc->next获取下一个desc的index读入参数&i
+	 * 把第i个VRingDesc读入参数desc
+	 */
         rc = virtqueue_read_next_desc(vdev, &desc, desc_cache, max, &i);
     } while (rc == VIRTQUEUE_READ_DESC_MORE);
 
@@ -949,7 +1337,12 @@ void *virtqueue_pop(VirtQueue *vq, size_t sz)
     }
 
     /* Now copy what we have collected and mapped */
+    /*
+     * 分配一个结构,这个结构就是或者包含VirtQueueElement,在这个结构后面附着in_addr, out_addr等数据
+     * 结构的例子是VirtIOBlockReq或者virtio_gpu_ctrl_command
+     */
     elem = virtqueue_alloc_element(sz, out_num, in_num);
+    /* head是当前处理的avail的第一个desc的index */
     elem->index = head;
     for (i = 0; i < out_num; i++) {
         elem->out_addr[i] = addr[i];
@@ -980,31 +1373,62 @@ err_undo_map:
  * as if they are done. Useful when buffers can not be
  * processed but must be returned to the guest.
  */
+/*
+ * called only by:
+ *   - hw/net/virtio-net.c|245| <<virtio_net_drop_tx_queue_data>> unsigned int dropped = virtqueue_drop_all(vq);
+ *
+ * 把当前ring buffer所有的avail不处理,直接response
+ * 相当于drop了所有没处理的avail
+ */
 unsigned int virtqueue_drop_all(VirtQueue *vq)
 {
     unsigned int dropped = 0;
     VirtQueueElement elem = {};
     VirtIODevice *vdev = vq->vdev;
+    /*
+     * 后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+     * 同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+     */
     bool fEventIdx = virtio_vdev_has_feature(vdev, VIRTIO_RING_F_EVENT_IDX);
 
     if (unlikely(vdev->broken)) {
         return 0;
     }
 
+    /*
+     * 关于virtio_queue_empty():
+     *     shadow_avail_idx是最近在VRingAvail.idx读的值
+     *     last_avail_idx最最近后端使用的值
+     *     如果两者相等, 说明没有pending的request
+     */
     while (!virtio_queue_empty(vq) && vq->inuse < vq->vring.num) {
         /* works similar to virtqueue_pop but does not map buffers
         * and does not allocate any memory */
         smp_rmb();
+	/*
+	 * 把VRingAvail.ring[vq->last_avail_idx]的内容存入&elem.index
+	 * 其实就是得到VRingAvail.ring[vq->last_avail_idx]的内容
+	 */
         if (!virtqueue_get_head(vq, vq->last_avail_idx, &elem.index)) {
             break;
         }
         vq->inuse++;
         vq->last_avail_idx++;
         if (fEventIdx) {
+            /*
+	     * 如果设置了VIRTIO_RING_F_EVENT_IDX
+	     * 把vq->last_avail_idx写入used的vring的最后一个元素的位置
+	     */
             vring_set_avail_event(vq, vq->last_avail_idx);
         }
         /* immediately push the element, nothing to unmap
          * as both in_num and out_num are set to 0 */
+	/*
+	 * 核心思想是把VirtQueueElement给unmap
+	 * 根据VirtQueueElement制作VRingUsedElem, 然后写入VRingUsed->ring[0+vq->used_idx]
+	 * 把VRingUsed->idx和vq->used_idx增加1
+	 * 还减少了vq->inuse!
+	 */
         virtqueue_push(vq, &elem, 0);
         dropped++;
     }
@@ -1029,6 +1453,12 @@ typedef struct VirtQueueElementOld {
     struct iovec out_sg[VIRTQUEUE_MAX_SIZE];
 } VirtQueueElementOld;
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|1052| <<virtio_blk_load_device>> req = qemu_get_virtqueue_element(vdev, f, sizeof(VirtIOBlockReq));
+ *   - hw/char/virtio-serial-bus.c|783| <<fetch_active_ports_list>> qemu_get_virtqueue_element(vdev, f, sizeof(VirtQueueElement));
+ *   - hw/scsi/virtio-scsi.c|208| <<virtio_scsi_load_request>> req = qemu_get_virtqueue_element(vdev, f,
+ */
 void *qemu_get_virtqueue_element(VirtIODevice *vdev, QEMUFile *f, size_t sz)
 {
     VirtQueueElement *elem;
@@ -1072,6 +1502,12 @@ void *qemu_get_virtqueue_element(VirtIODevice *vdev, QEMUFile *f, size_t sz)
     return elem;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|1020| <<virtio_blk_save_device>> qemu_put_virtqueue_element(f, &req->elem);
+ *   - hw/char/virtio-serial-bus.c|707| <<virtio_serial_save_device>> qemu_put_virtqueue_element(f, port->elem);
+ *   - hw/scsi/virtio-scsi.c|194| <<virtio_scsi_save_request>> qemu_put_virtqueue_element(f, &req->elem);
+ */
 void qemu_put_virtqueue_element(QEMUFile *f, VirtQueueElement *elem)
 {
     VirtQueueElementOld data;
@@ -1104,8 +1540,20 @@ void qemu_put_virtqueue_element(QEMUFile *f, VirtQueueElement *elem)
 }
 
 /* virtio device */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1559| <<virtio_update_irq>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ *   - hw/virtio/virtio.c|1646| <<virtio_reset>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|2116| <<virtio_irq>> virtio_notify_vector(vq->vdev, vq->vector);
+ *   - hw/virtio/virtio.c|2141| <<virtio_notify_config>> virtio_notify_vector(vdev, vdev->config_vector);
+ *   - hw/virtio/virtio.c|2539| <<virtio_load>> virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
+ *
+ * 在启动时(可能是bios相关?)有调用
+ * 启动guest 内核后就没了
+ */
 static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)
 {
+    /* 在测试中, block的qbus->name是"virtio-bus" */
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
 
@@ -1113,32 +1561,75 @@ static void virtio_notify_vector(VirtIODevice *vdev, uint16_t vector)
         return;
     }
 
+    /*
+     * 对于block, qbus->parent应该是block pci device吧
+     *
+     * 参数的vdev   : canonical_path = "/machine/peripheral/virtio-disk0/virtio-backend"
+     * qbus->parent : canonical_path = "/machine/peripheral/virtio-disk0"
+     */
     if (k->notify) {
+        /*
+	 * notify设置的地方:
+	 *   - hw/virtio/virtio-pci.c|2891| <<virtio_pci_bus_class_init>> k->notify = virtio_pci_notify;
+	 *   - hw/virtio/virtio-mmio.c|509| <<virtio_mmio_bus_class_init>> k->notify = virtio_mmio_update_irq;
+	 *
+	 * notify调用的地方:
+	 *   - hw/virtio/virtio.c|1562| <<virtio_notify_vector>> k->notify(qbus->parent, vector);
+	 */
         k->notify(qbus->parent, vector);
     }
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio-mmio.c|282| <<virtio_mmio_write>> virtio_update_irq(vdev);
+ */
 void virtio_update_irq(VirtIODevice *vdev)
 {
     virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio.c|1623| <<virtio_set_status>> int ret = virtio_validate_features(vdev);
+ */
 static int virtio_validate_features(VirtIODevice *vdev)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
 
+    /*
+     * virtio_host_has_feature(): 查看VirtIODevice->host_features的对应bit是否设置了
+     * virtio_vdev_has_feature(): 查看VirtIODevice->guest_features的对应bit是否设置了
+     *
+     * 必须host和guest都设置了VIRTIO_F_IOMMU_PLATFORM才行
+     * 要么就都不设置
+     */
     if (virtio_host_has_feature(vdev, VIRTIO_F_IOMMU_PLATFORM) &&
         !virtio_vdev_has_feature(vdev, VIRTIO_F_IOMMU_PLATFORM)) {
         return -EFAULT;
     }
 
     if (k->validate_features) {
+        /*
+	 * 目前没有设置的
+	 * 只被如下调用:
+	 *   - hw/virtio/virtio.c|1609| <<virtio_validate_features>> return k->validate_features(vdev);
+	 */
         return k->validate_features(vdev);
     } else {
         return 0;
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|338| <<virtio_ioport_write>> virtio_set_status(vdev, val & 0xFF);
+ *   - hw/virtio/virtio-pci.c|621| <<virtio_write_config>> virtio_set_status(vdev, vdev->status & ~VIRTIO_CONFIG_S_DRIVER_OK);
+ *   - hw/virtio/virtio-pci.c|1310| <<virtio_pci_common_write>> virtio_set_status(vdev, val & 0xFF);
+ *   - hw/virtio/virtio.c|1664| <<virtio_reset>> virtio_set_status(vdev, 0);
+ *   - hw/virtio/virtio.c|2691| <<virtio_vmstate_change>> virtio_set_status(vdev, vdev->status);
+ *   - hw/virtio/virtio.c|2699| <<virtio_vmstate_change>> virtio_set_status(vdev, vdev->status);
+ */
 int virtio_set_status(VirtIODevice *vdev, uint8_t val)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -1154,6 +1645,23 @@ int virtio_set_status(VirtIODevice *vdev, uint8_t val)
             }
         }
     }
+    /*
+     * 设置的地方:
+     *   - hw/block/virtio-blk.c|1469| <<virtio_blk_class_init>> vdc->set_status = virtio_blk_set_status;
+     *   - hw/block/vhost-user-blk.c|356| <<vhost_user_blk_class_init>> vdc->set_status = vhost_user_blk_set_status;
+     *   - hw/char/virtio-serial-bus.c|1178| <<virtio_serial_class_init>> vdc->set_status = set_status;
+     *   - hw/input/virtio-input.c|322| <<virtio_input_class_init>> vdc->set_status = virtio_input_set_status;
+     *   - hw/net/virtio-net.c|2220| <<virtio_net_class_init>> vdc->set_status = virtio_net_set_status;
+     *   - hw/scsi/vhost-scsi.c|256| <<vhost_scsi_class_init>> vdc->set_status = vhost_scsi_set_status;
+     *   - hw/scsi/vhost-user-scsi.c|192| <<vhost_user_scsi_class_init>> vdc->set_status = vhost_user_scsi_set_status;
+     *   - hw/virtio/vhost-vsock.c|401| <<vhost_vsock_class_init>> vdc->set_status = vhost_vsock_set_status;
+     *   - hw/virtio/virtio-balloon.c|537| <<virtio_balloon_class_init>> vdc->set_status = virtio_balloon_set_status;
+     *   - hw/virtio/virtio-crypto.c|963| <<virtio_crypto_class_init>> vdc->set_status = virtio_crypto_set_status;
+     *   - hw/virtio/virtio-rng.c|277| <<virtio_rng_class_init>> vdc->set_status = virtio_rng_set_status;
+     *
+     * 唯一调用的地方:
+     *   - hw/virtio/virtio.c|1652| <<virtio_set_status>> k->set_status(vdev, val);
+     */
     if (k->set_status) {
         k->set_status(vdev, val);
     }
@@ -1171,6 +1679,9 @@ static enum virtio_device_endian virtio_default_endian(void)
     }
 }
 
+/*
+ * called only by virtio_reset()
+ */
 static enum virtio_device_endian virtio_current_cpu_endian(void)
 {
     CPUClass *cc = CPU_GET_CLASS(current_cpu);
@@ -1182,6 +1693,55 @@ static enum virtio_device_endian virtio_current_cpu_endian(void)
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-bus.c|135| <<virtio_bus_reset>> virtio_reset(vdev);
+ *   - hw/s390x/virtio-ccw.c|254| <<virtio_ccw_reset_virtio>> virtio_reset(vdev);
+ *   - hw/virtio/virtio-mmio.c|269| <<virtio_mmio_write>> virtio_reset(vdev);
+ *   - hw/virtio/virtio-mmio.c|296| <<virtio_mmio_write>> virtio_reset(vdev);
+ *
+ * 测试的时候三次被调用:
+ * (gdb) bt
+ * #0  virtio_reset (opaque=0x5555579da940) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1187
+ * #1  0x0000555555be87eb in virtio_bus_reset (bus=0x5555579da8c8) at hw/virtio/virtio-bus.c:96
+ * #2  0x0000555555beede8 in virtio_pci_reset (qdev=0x5555579d27d0) at hw/virtio/virtio-pci.c:1858
+ * #3  0x0000555555a7d78f in device_reset (dev=0x5555579d27d0) at hw/core/qdev.c:1086
+ * #4  0x0000555555a7b782 in qdev_reset_one (dev=0x5555579d27d0, opaque=0x0) at hw/core/qdev.c:250
+ * #5  0x0000555555a7c388 in qdev_walk_children (dev=0x5555579d27d0, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a7b766 <qdev_reset_one>, post_busfn=0x555555a7b789 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/qdev.c:567
+ * #6  0x0000555555a80914 in qbus_walk_children (bus=0x555556a29020, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a7b766 <qdev_reset_one>, post_busfn=0x555555a7b789 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/bus.c:59
+ * #7  0x0000555555a7c34c in qdev_walk_children (dev=0x555556a27550, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a7b766 <qdev_reset_one>, post_busfn=0x555555a7b789 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/qdev.c:559
+ * #8  0x0000555555a80914 in qbus_walk_children (bus=0x5555568d7370, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a7b766 <qdev_reset_one>, post_busfn=0x555555a7b789 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/bus.c:59
+ * #9  0x0000555555a7b89c in qbus_reset_all (bus=0x5555568d7370) at hw/core/qdev.c:276
+ * #10 0x0000555555a7b8bf in qbus_reset_all_fn (opaque=0x5555568d7370) at hw/core/qdev.c:282
+ * #11 0x0000555555a8125a in qemu_devices_reset () at hw/core/reset.c:69
+ * #12 0x00005555559227f2 in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #13 0x00005555559de8a9 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #14 0x00005555559e658e in main (argc=14, argv=0x7fffffffe3d8, envp=0x7fffffffe450) at vl.c:4611
+ *
+ * (gdb) bt
+ * #0  virtio_reset (opaque=0x5555579da940) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1187
+ * #1  0x0000555555be87eb in virtio_bus_reset (bus=0x5555579da8c8) at hw/virtio/virtio-bus.c:96
+ * #2  0x0000555555beede8 in virtio_pci_reset (qdev=0x5555579d27d0) at hw/virtio/virtio-pci.c:1858
+ * #3  0x0000555555bed5f2 in virtio_pci_common_write (opaque=0x5555579d27d0, addr=20, val=0, size=1) at hw/virtio/virtio-pci.c:1292
+ * #4  0x000055555586b345 in memory_region_write_accessor (mr=0x5555579d31a0, addr=20, value=0x7fffe77fd7e8, size=1, shift=0, mask=255, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #5  0x000055555586b55d in access_with_adjusted_size (addr=20, value=0x7fffe77fd7e8, size=1, access_size_min=1, access_size_max=4, access_fn=0x55555586b25b
+ *     <memory_region_write_accessor>, mr=0x5555579d31a0, 
+ *     attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #6  0x000055555586e185 in memory_region_dispatch_write (mr=0x5555579d31a0, addr=20, data=0, size=1, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #7  0x000055555580a1bf in flatview_write_continue (fv=0x7fffd80063c0, addr=4261412884, attrs=..., buf=0x7ffff7fef028 "", len=1, addr1=20, l=1, mr=0x5555579d31a0) at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #8  0x000055555580a309 in flatview_write (fv=0x7fffd80063c0, addr=4261412884, attrs=..., buf=0x7ffff7fef028 "", len=1) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #9  0x000055555580a60f in address_space_write (as=0x555556754580 <address_space_memory>, addr=4261412884, attrs=..., buf=0x7ffff7fef028 "", len=1) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #10 0x000055555580a660 in address_space_rw (as=0x555556754580 <address_space_memory>, addr=4261412884, attrs=..., buf=0x7ffff7fef028 "", len=1, is_write=true) at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #11 0x0000555555889395 in kvm_cpu_exec (cpu=0x5555568b49e0) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1979
+ * #12 0x00005555558506cc in qemu_kvm_cpu_thread_fn (arg=0x5555568b49e0) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #13 0x0000555555db5d87 in qemu_thread_start (args=0x5555568d63a0) at util/qemu-thread-posix.c:504
+ * #14 0x00007ffff47596ba in start_thread (arg=0x7fffe77fe700) at pthread_create.c:333
+ * #15 0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 void virtio_reset(void *opaque)
 {
     VirtIODevice *vdev = opaque;
@@ -1197,6 +1757,21 @@ void virtio_reset(void *opaque)
         vdev->device_endian = virtio_default_endian();
     }
 
+    /*
+     * 在以下被设置:
+     *   - hw/block/virtio-blk.c|1490| <<virtio_blk_class_init>> vdc->reset = virtio_blk_reset;
+     *   - hw/net/virtio-net.c|2219| <<virtio_net_class_init>> vdc->reset = virtio_net_reset;
+     *   - hw/scsi/virtio-scsi.c|975| <<virtio_scsi_class_init>> vdc->reset = virtio_scsi_reset;
+     *   - hw/virtio/virtio-balloon.c|533| <<virtio_balloon_class_init>> vdc->reset = virtio_balloon_device_reset;
+     *   - hw/virtio/virtio-crypto.c|962| <<virtio_crypto_class_init>> vdc->reset = virtio_crypto_reset;
+     *   - hw/char/virtio-serial-bus.c|1179| <<virtio_serial_class_init>> vdc->reset = vser_reset;
+     *   - hw/display/virtio-gpu.c|1373| <<virtio_gpu_class_init>> vdc->reset = virtio_gpu_reset;
+     *   - hw/9pfs/virtio-9p-device.c|250| <<virtio_9p_class_init>> vdc->reset = virtio_9p_reset;
+     *   - hw/input/virtio-input.c|323| <<virtio_input_class_init>> vdc->reset = virtio_input_reset;
+     *
+     * 在以下被调用:
+     *   - hw/virtio/virtio.c|1761| <<virtio_reset>> k->reset(vdev);
+     */
     if (k->reset) {
         k->reset(vdev);
     }
@@ -1226,6 +1801,35 @@ void virtio_reset(void *opaque)
     }
 }
 
+/*
+ * 设置get_config的地方:
+ *   - hw/block/virtio-blk.c|1452| <<virtio_blk_class_init>> vdc->get_config = virtio_blk_update_config;
+ *   - hw/net/virtio-net.c|2214| <<virtio_net_class_init>> vdc->get_config = virtio_net_get_config;
+ *   - hw/scsi/virtio-scsi.c|958| <<virtio_scsi_common_class_init>> vdc->get_config = virtio_scsi_get_config;
+ *   - hw/virtio/virtio-balloon.c|534| <<virtio_balloon_class_init>> vdc->get_config = virtio_balloon_get_config;
+ *   - hw/9pfs/virtio-9p-device.c|249| <<virtio_9p_class_init>> vdc->get_config = virtio_9p_get_config;
+ *   - hw/block/vhost-user-blk.c|353| <<vhost_user_blk_class_init>> vdc->get_config = vhost_user_blk_update_config;
+ *   - hw/char/virtio-serial-bus.c|1176| <<virtio_serial_class_init>> vdc->get_config = get_config;
+ *   - hw/display/virtio-gpu.c|1368| <<virtio_gpu_class_init>> vdc->get_config = virtio_gpu_get_config;
+ *   - hw/input/virtio-input.c|319| <<virtio_input_class_init>> vdc->get_config = virtio_input_get_config;
+ *   - hw/virtio/vhost-vsock.c|400| <<vhost_vsock_class_init>> vdc->get_config = vhost_vsock_get_config;
+ *   - hw/virtio/virtio-crypto.c|960| <<virtio_crypto_class_init>> vdc->get_config = virtio_crypto_get_config;
+ *
+ * 调用get_config的地方:
+ *   - hw/virtio/virtio-bus.c|195| <<virtio_bus_get_vdev_config>> k->get_config(vdev, config);
+ *   - hw/virtio/virtio.c|1818| <<virtio_config_readb>> k->get_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1838| <<virtio_config_readw>> k->get_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1858| <<virtio_config_readl>> k->get_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1963| <<virtio_config_modern_readb>> k->get_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1982| <<virtio_config_modern_readw>> k->get_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|2001| <<virtio_config_modern_readl>> k->get_config(vdev, vdev->config);
+ */
+
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|437| <<virtio_pci_config_read>> val = virtio_config_readb(vdev, addr);
+ *   - hw/virtio/virtio-mmio.c|137| <<virtio_mmio_read>> return virtio_config_readb(vdev, offset);
+ */
 uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -1241,6 +1845,11 @@ uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)
     return val;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|440| <<virtio_pci_config_read>> val = virtio_config_readw(vdev, addr);
+ *   - hw/virtio/virtio-mmio.c|139| <<virtio_mmio_read>> return virtio_config_readw(vdev, offset);
+ */
 uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -1256,6 +1865,11 @@ uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)
     return val;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|446| <<virtio_pci_config_read>> val = virtio_config_readl(vdev, addr);
+ *   - hw/virtio/virtio-mmio.c|141| <<virtio_mmio_read>> return virtio_config_readl(vdev, offset);
+ */
 uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -1271,6 +1885,34 @@ uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)
     return val;
 }
 
+/*
+ * 设置set_config的地方:
+ *   - hw/block/virtio-blk.c|1463| <<virtio_blk_class_init>> vdc->set_config = virtio_blk_set_config;
+ *   - hw/net/virtio-net.c|2215| <<virtio_net_class_init>> vdc->set_config = virtio_net_set_config;
+ *   - hw/scsi/virtio-scsi.c|973| <<virtio_scsi_class_init>> vdc->set_config = virtio_scsi_set_config;
+ *   - hw/virtio/virtio-balloon.c|535| <<virtio_balloon_class_init>> vdc->set_config = virtio_balloon_set_config;
+ *   - hw/char/virtio-serial-bus.c|1177| <<virtio_serial_class_init>> vdc->set_config = set_config;
+ *   - hw/block/vhost-user-blk.c|354| <<vhost_user_blk_class_init>> vdc->set_config = vhost_user_blk_set_config;
+ *   - hw/display/virtio-gpu.c|1369| <<virtio_gpu_class_init>> vdc->set_config = virtio_gpu_set_config;
+ *   - hw/input/virtio-input.c|320| <<virtio_input_class_init>> vdc->set_config = virtio_input_set_config;
+ *   - hw/scsi/vhost-scsi.c|255| <<vhost_scsi_class_init>> vdc->set_config = vhost_scsi_common_set_config;
+ *   - hw/scsi/vhost-user-scsi.c|191| <<vhost_user_scsi_class_init>> vdc->set_config = vhost_scsi_common_set_config;
+ *
+ * 调用set_config的地方:
+ *   - hw/virtio/virtio-bus.c|208| <<virtio_bus_set_vdev_config>> k->set_config(vdev, config);
+ *   - hw/virtio/virtio.c|1881| <<virtio_config_writeb>> k->set_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1902| <<virtio_config_writew>> k->set_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|1923| <<virtio_config_writel>> k->set_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|2001| <<virtio_config_modern_writeb>> k->set_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|2022| <<virtio_config_modern_writew>> k->set_config(vdev, vdev->config);
+ *   - hw/virtio/virtio.c|2043| <<virtio_config_modern_writel>> k->set_config(vdev, vdev->config);
+ */
+
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|472| <<virtio_pci_config_write>> virtio_config_writeb(vdev, addr, val);
+ *   - hw/virtio/virtio-mmio.c|215| <<virtio_mmio_write>> virtio_config_writeb(vdev, offset, value);
+ */
 void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -1287,6 +1929,11 @@ void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|478| <<virtio_pci_config_write>> virtio_config_writew(vdev, addr, val);
+ *   - hw/virtio/virtio-mmio.c|218| <<virtio_mmio_write>> virtio_config_writew(vdev, offset, value);
+ */
 void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -1303,6 +1950,11 @@ void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|484| <<virtio_pci_config_write>> virtio_config_writel(vdev, addr, val);
+ *   - hw/virtio/virtio-mmio.c|221| <<virtio_mmio_write>> virtio_config_writel(vdev, offset, value);
+ */
 void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -1319,6 +1971,10 @@ void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)
     }
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio-pci.c|1438| <<virtio_pci_device_read>> val = virtio_config_modern_readb(vdev, addr);
+ */
 uint32_t virtio_config_modern_readb(VirtIODevice *vdev, uint32_t addr)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -1334,6 +1990,10 @@ uint32_t virtio_config_modern_readb(VirtIODevice *vdev, uint32_t addr)
     return val;
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio-pci.c|1441| <<virtio_pci_device_read>> val = virtio_config_modern_readw(vdev, addr);
+ */
 uint32_t virtio_config_modern_readw(VirtIODevice *vdev, uint32_t addr)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -1349,6 +2009,10 @@ uint32_t virtio_config_modern_readw(VirtIODevice *vdev, uint32_t addr)
     return val;
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio-pci.c|1444| <<virtio_pci_device_read>> val = virtio_config_modern_readl(vdev, addr);
+ */
 uint32_t virtio_config_modern_readl(VirtIODevice *vdev, uint32_t addr)
 {
     VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
@@ -1364,6 +2028,10 @@ uint32_t virtio_config_modern_readl(VirtIODevice *vdev, uint32_t addr)
     return val;
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio-pci.c|1456| <<virtio_pci_device_write>> virtio_config_modern_writeb(vdev, addr, val);
+ */
 void virtio_config_modern_writeb(VirtIODevice *vdev,
                                  uint32_t addr, uint32_t data)
 {
@@ -1381,6 +2049,10 @@ void virtio_config_modern_writeb(VirtIODevice *vdev,
     }
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio-pci.c|1459| <<virtio_pci_device_write>> virtio_config_modern_writew(vdev, addr, val);
+ */
 void virtio_config_modern_writew(VirtIODevice *vdev,
                                  uint32_t addr, uint32_t data)
 {
@@ -1398,6 +2070,10 @@ void virtio_config_modern_writew(VirtIODevice *vdev,
     }
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio-pci.c|1462| <<virtio_pci_device_write>> virtio_config_modern_writel(vdev, addr, val);
+ */
 void virtio_config_modern_writel(VirtIODevice *vdev,
                                  uint32_t addr, uint32_t data)
 {
@@ -1415,20 +2091,47 @@ void virtio_config_modern_writel(VirtIODevice *vdev,
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|322| <<virtio_ioport_write>> virtio_queue_set_addr(vdev, vdev->queue_sel, pa);
+ *   - hw/virtio/virtio-mmio.c|271| <<virtio_mmio_write>> virtio_queue_set_addr(vdev, vdev->queue_sel,
+ *   - hw/s390x/virtio-ccw.c|225| <<virtio_ccw_set_vqs>> virtio_queue_set_addr(vdev, index, desc);
+ *
+ * 参数addr是ring buffer基地址, 在guest里分配的时候avail, used和desc是连续的
+ * 根据desc的base地址, 设置avail和used的地址
+ * 然后map下queue n的desc, avail和used三个ring buffer
+ */
 void virtio_queue_set_addr(VirtIODevice *vdev, int n, hwaddr addr)
 {
     if (!vdev->vq[n].vring.num) {
         return;
     }
     vdev->vq[n].vring.desc = addr;
+    /*
+     * 根据desc的base地址, 设置avail和used的地址
+     * 在guest里分配的时候avail, used和desc是连续的
+     * 然后map下queue n的desc, avail和used三个ring buffer
+     */
     virtio_queue_update_rings(vdev, n);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost-vsock.c|273| <<vhost_vsock_post_load>> if (virtio_queue_get_addr(vdev, 2)) {
+ *   - hw/virtio/virtio-mmio.c|170| <<virtio_mmio_read>> return virtio_queue_get_addr(vdev, vdev->queue_sel)
+ *   - hw/virtio/virtio-pci.c|393| <<virtio_ioport_read>> ret = virtio_queue_get_addr(vdev, vdev->queue_sel)
+ *
+ * 返回desc的地址, 也就是ring buffer的基地址
+ * 在guest里分配的时候avail, used和desc是连续的
+ */
 hwaddr virtio_queue_get_addr(VirtIODevice *vdev, int n)
 {
     return vdev->vq[n].vring.desc;
 }
 
+/*
+ * 设置并map一下queue n的desc, avail和used三个ring buffer
+ */
 void virtio_queue_set_rings(VirtIODevice *vdev, int n, hwaddr desc,
                             hwaddr avail, hwaddr used)
 {
@@ -1438,9 +2141,15 @@ void virtio_queue_set_rings(VirtIODevice *vdev, int n, hwaddr desc,
     vdev->vq[n].vring.desc = desc;
     vdev->vq[n].vring.avail = avail;
     vdev->vq[n].vring.used = used;
+    /*
+     * map下queue n的desc, avail和used三个ring buffer
+     */
     virtio_init_region_cache(vdev, n);
 }
 
+/*
+ * 设置queue n的元素的数量
+ */
 void virtio_queue_set_num(VirtIODevice *vdev, int n, int num)
 {
     /* Don't allow guest to flip queue between existent and
@@ -1454,23 +2163,47 @@ void virtio_queue_set_num(VirtIODevice *vdev, int n, int num)
     vdev->vq[n].vring.num = num;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|855| <<virtio_pci_vector_unmask>> VirtQueue *vq = virtio_vector_first_queue(vdev, vector);
+ *   - hw/virtio/virtio-pci.c|876| <<virtio_pci_vector_unmask>> vq = virtio_vector_first_queue(vdev, vector);
+ *   - hw/virtio/virtio-pci.c|892| <<virtio_pci_vector_mask>> VirtQueue *vq = virtio_vector_first_queue(vdev, vector);
+ */
 VirtQueue *virtio_vector_first_queue(VirtIODevice *vdev, uint16_t vector)
 {
     return QLIST_FIRST(&vdev->vector_queues[vector]);
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|870| <<virtio_pci_vector_unmask>> vq = virtio_vector_next_queue(vq);
+ *   - hw/virtio/virtio-pci.c|883| <<virtio_pci_vector_unmask>> vq = virtio_vector_next_queue(vq);
+ *   - hw/virtio/virtio-pci.c|903| <<virtio_pci_vector_mask>> vq = virtio_vector_next_queue(vq);
+ */
 VirtQueue *virtio_vector_next_queue(VirtQueue *vq)
 {
     return QLIST_NEXT(vq, node);
 }
 
+/*
+ * 返回ring buffer元素的数量: vdev->vq[n].vring.num
+ */
 int virtio_queue_get_num(VirtIODevice *vdev, int n)
 {
     return vdev->vq[n].vring.num;
 }
 
+/*
+ * 返回vdev->vq[n].vring.num_default
+ */
 int virtio_queue_get_max_num(VirtIODevice *vdev, int n)
 {
+    /*
+     * 设置的地方:
+     *   - hw/virtio/virtio.c|2519| <<global>> VMSTATE_UINT32(vring.num_default, struct VirtQueue),
+     *   - hw/virtio/virtio.c|2318| <<virtio_add_queue>> vdev->vq[i].vring.num_default = queue_size;
+     *   - hw/virtio/virtio.c|2333| <<virtio_del_queue>> vdev->vq[n].vring.num_default = 0;
+     */
     return vdev->vq[n].vring.num_default;
 }
 
@@ -1479,6 +2212,9 @@ int virtio_get_num_queues(VirtIODevice *vdev)
     int i;
 
     for (i = 0; i < VIRTIO_QUEUE_MAX; i++) {
+        /*
+	 * 返回ring buffer元素的数量: vdev->vq[n].vring.num
+	 */
         if (!virtio_queue_get_num(vdev, i)) {
             break;
         }
@@ -1505,10 +2241,23 @@ void virtio_queue_set_align(VirtIODevice *vdev, int n, int align)
 
     if (align) {
         vdev->vq[n].vring.align = align;
+	/*
+	 * 根据desc的base地址, 设置avail和used的地址
+	 * 在guest里分配的时候avail, used和desc是连续的
+	 * 然后map下queue n的desc, avail和used三个ring buffer
+	 */
         virtio_queue_update_rings(vdev, n);
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|3205| <<virtio_queue_host_notifier_aio_read>> virtio_queue_notify_aio_vq(vq);
+ *   - hw/virtio/virtio.c|3226| <<virtio_queue_host_notifier_aio_poll>> progress = virtio_queue_notify_aio_vq(vq);
+ *
+ * 如果vq->handle_aio_output被设置了调用vq->handle_aio_output()
+ * 否则返回false
+ */
 static bool virtio_queue_notify_aio_vq(VirtQueue *vq)
 {
     if (vq->vring.desc && vq->handle_aio_output) {
@@ -1521,6 +2270,12 @@ static bool virtio_queue_notify_aio_vq(VirtQueue *vq)
     return false;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|3265| <<virtio_queue_host_notifier_read>> virtio_queue_notify_vq(vq);
+ *
+ * 如果vq->handle_output被设置了调用vq->handle_output()
+ */
 static void virtio_queue_notify_vq(VirtQueue *vq)
 {
     if (vq->vring.desc && vq->handle_output) {
@@ -1535,6 +2290,17 @@ static void virtio_queue_notify_vq(VirtQueue *vq)
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-mmio.c|277| <<virtio_mmio_write>> virtio_queue_notify(vdev, value);
+ *   - hw/virtio/virtio-pci.c|330| <<virtio_ioport_write>> virtio_queue_notify(vdev, val);
+ *   - hw/virtio/virtio-pci.c|1399| <<virtio_pci_notify_write>> virtio_queue_notify(vdev, queue);
+ *   - hw/virtio/virtio-pci.c|1410| <<virtio_pci_notify_write_pio>> virtio_queue_notify(vdev, queue);
+ *
+ * 如果vq->handle_aio_output存在调用eventfd: event_notifier_set(&vq->host_notifier);
+ * 如果vq->handle_output存在调用vq->handle_output()
+ * 否则什么也不做
+ */
 void virtio_queue_notify(VirtIODevice *vdev, int n)
 {
     VirtQueue *vq = &vdev->vq[n];
@@ -1557,6 +2323,13 @@ uint16_t virtio_queue_vector(VirtIODevice *vdev, int n)
         VIRTIO_NO_VECTOR;
 }
 
+/*
+ * 相关的调用:
+ *   - hw/virtio/virtio-pci.c|206| <<virtio_pci_load_queue>> virtio_queue_set_vector(vdev, n, vector);
+ *   - hw/virtio/virtio-pci.c|371| <<virtio_ioport_write>> virtio_queue_set_vector(vdev, vdev->queue_sel, val);
+ *   - hw/virtio/virtio-pci.c|1347| <<virtio_pci_common_write>> virtio_queue_set_vector(vdev, vdev->queue_sel, val);
+ *   - hw/virtio/virtio.c|1794| <<virtio_reset>> virtio_queue_set_vector(vdev, i, VIRTIO_NO_VECTOR);
+ */
 void virtio_queue_set_vector(VirtIODevice *vdev, int n, uint16_t vector)
 {
     VirtQueue *vq = &vdev->vq[n];
@@ -1680,6 +2453,19 @@ static void virtio_irq(VirtQueue *vq)
     virtio_notify_vector(vq->vdev, vq->vector);
 }
 
+/*
+ * 当virtio block没有开启ioeventfd的时候:
+ * (gdb) bt
+ * #0  virtio_notify (vdev=0x5555579d9b20, vq=0x7fffe6c9c010) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1686
+ * #1  0x00005555558b1909 in virtio_blk_req_complete (req=0x7fffe02154f0, status=0 '\000') at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:59
+ * #2  0x00005555558b1b41 in virtio_blk_rw_complete (opaque=0x7fffe02154f0, ret=0) at /home/zhang/kvm/qemu-3.0.0/hw/block/virtio-blk.c:121
+ * #3  0x0000555555ce9d35 in blk_aio_complete (acb=0x7fffe0215350) at block/block-backend.c:1336
+ * #4  0x0000555555ce9f49 in blk_aio_read_entry (opaque=0x7fffe0215350) at block/block-backend.c:1389
+ * #5  0x0000555555dd04e6 in coroutine_trampoline (i0=-534635840, i1=32767) at util/coroutine-ucontext.c:116
+ * #6  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #7  0x00007fffe7ffdbf0 in ?? ()
+ * #8  0x0000000000000000 in ?? ()
+ */
 void virtio_notify(VirtIODevice *vdev, VirtQueue *vq)
 {
     bool should_notify;
@@ -1969,6 +2755,20 @@ int virtio_save(VirtIODevice *vdev, QEMUFile *f)
 }
 
 /* A wrapper for use as a VMState .put function */
+/*
+ * (gdb) bt
+ * #0  virtio_device_put (f=0x555556c5a800, opaque=0x5555579da580, size=0, field=0x55555659d280 <__compound_literal.0>, vmdesc=0x7fff4805d450) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1975
+ * #1  0x0000555555c0b1e5 in vmstate_save_state_v (f=0x555556c5a800, vmsd=0x555556486ca0 <vmstate_virtio_blk>, opaque=0x5555579da580, vmdesc=0x7fff4805d450, version_id=2) at migration/vmstate.c:384
+ * #2  0x0000555555c0ae75 in vmstate_save_state (f=0x555556c5a800, vmsd=0x555556486ca0 <vmstate_virtio_blk>, opaque=0x5555579da580, vmdesc_id=0x7fff4805d450) at migration/vmstate.c:319
+ * #3  0x0000555555c03e0e in vmstate_save (f=0x555556c5a800, se=0x555557b15da0, vmdesc=0x7fff4805d450) at migration/savevm.c:786
+ * #4  0x0000555555c04efd in qemu_savevm_state_complete_precopy (f=0x555556c5a800, iterable_only=false, inactivate_disks=true) at migration/savevm.c:1231
+ * #5  0x0000555555bfcd37 in migration_completion (s=0x555556894630) at migration/migration.c:2534
+ * #6  0x0000555555bfd6c0 in migration_iteration_run (s=0x555556894630) at migration/migration.c:2862
+ * #7  0x0000555555bfd94e in migration_thread (opaque=0x555556894630) at migration/migration.c:2979
+ * #8  0x0000555555db5d87 in qemu_thread_start (args=0x5555576e8240) at util/qemu-thread-posix.c:504
+ * #9  0x00007ffff47596ba in start_thread (arg=0x7fff4f3cf700) at pthread_create.c:333
+ * #10 0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 static int virtio_device_put(QEMUFile *f, void *opaque, size_t size,
                               VMStateField *field, QJSON *vmdesc)
 {
@@ -1976,6 +2776,20 @@ static int virtio_device_put(QEMUFile *f, void *opaque, size_t size,
 }
 
 /* A wrapper for use as a VMState .get function */
+/*
+ * (gdb) bt
+ * #0  virtio_device_get (f=0x55555688a010, opaque=0x5555579da580, size=0, field=0x55555659d280 <__compound_literal.0>) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:1982
+ * #1  0x0000555555c0a91a in vmstate_load_state (f=0x55555688a010, vmsd=0x555556486ca0 <vmstate_virtio_blk>, opaque=0x5555579da580, version_id=2) at migration/vmstate.c:143
+ * #2  0x0000555555c03c61 in vmstate_load (f=0x55555688a010, se=0x555557b15da0) at migration/savevm.c:756
+ * #3  0x0000555555c06801 in qemu_loadvm_section_start_full (f=0x55555688a010, mis=0x55555689d3e0) at migration/savevm.c:2098
+ * #4  0x0000555555c06d34 in qemu_loadvm_state_main (f=0x55555688a010, mis=0x55555689d3e0) at migration/savevm.c:2245
+ * #5  0x0000555555c06f6f in qemu_loadvm_state (f=0x55555688a010) at migration/savevm.c:2341
+ * #6  0x0000555555bf8a19 in process_incoming_migration_co (opaque=0x0) at migration/migration.c:396
+ * #7  0x0000555555dd04e6 in coroutine_trampoline (i0=1458945488, i1=21845) at util/coroutine-ucontext.c:116
+ * #8  0x00007ffff43d25d0 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
+ * #9  0x00007fffffffd690 in ?? ()
+ * #10 0x0000000000000000 in ?? ()
+ */
 static int virtio_device_get(QEMUFile *f, void *opaque, size_t size,
                              VMStateField *field)
 {
@@ -2016,6 +2830,10 @@ int virtio_set_features(VirtIODevice *vdev, uint64_t val)
     return virtio_set_features_nocheck(vdev, val);
 }
 
+/*
+ * called only by:
+ *   - hw/virtio/virtio.c|2772| <<virtio_device_get>> return virtio_load(vdev, f, dc->vmsd->version_id);
+ */
 int virtio_load(VirtIODevice *vdev, QEMUFile *f, int version_id)
 {
     int i, ret;
@@ -2227,21 +3045,149 @@ static void virtio_vmstate_change(void *opaque, int running, RunState state)
     }
 }
 
+/*
+ * called by:
+ *   - hw/display/virtio-gpu-pci.c|68| <<virtio_gpu_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/display/virtio-vga.c|213| <<virtio_vga_inst_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-crypto-pci.c|63| <<virtio_crypto_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|1118| <<virtio_9p_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2016| <<virtio_blk_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2075| <<vhost_user_blk_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2145| <<virtio_scsi_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2198| <<vhost_scsi_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2253| <<vhost_user_scsi_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2303| <<vhost_vsock_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2355| <<virtio_balloon_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2433| <<virtio_serial_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2486| <<virtio_net_pci_instance_init>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2539| <<virtio_rng_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2600| <<virtio_keyboard_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2608| <<virtio_mouse_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2616| <<virtio_tablet_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *   - hw/virtio/virtio-pci.c|2663| <<virtio_host_initfn>> virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ *
+ * virtblk的例子:
+ * 2012 static void virtio_blk_pci_instance_init(Object *obj)
+ * 2013 {
+ * 2014     VirtIOBlkPCI *dev = VIRTIO_BLK_PCI(obj);
+ * 2015 
+ * 2016     virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+ * 2017                                 TYPE_VIRTIO_BLK);
+ *
+ * 针对virtblk的例子:
+ *   proxy_obj是VirtIOBlkPCI (TYPE_VIRTIO_BLK_PCI)
+ *   data是VirtIOBlock (TYPE_VIRTIO_BLK)
+ *
+ * 针对virtblk的例子:
+ *   用object_initialize()针对TYPE_VIRTIO_BLK初始化其object
+ *   间接调用其virtio_blk_instance_init()
+ *   然后把VirtIOBlock(TYPE_VIRTIO_BLK)设置为VirtIOBlkPCI(TYPE_VIRTIO_BLK_PCI)的child (child<virtio-backend>)
+ */
 void virtio_instance_init_common(Object *proxy_obj, void *data,
                                  size_t vdev_size, const char *vdev_name)
 {
     DeviceState *vdev = data;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     object_initialize(vdev, vdev_size, vdev_name);
+    /*
+     * 对于virtblk的例子:
+     *   proxy_obj真正的类型是VirtIOBlkPCI
+     *   OBJECT(vdev)真正的类型是VirtIOBlock
+     *
+     * 把child设置成一个obj的ObjectProperty
+     * 在Object->properties (GHashTable)的name就是参数的name, type是"child<child的type>"
+     * ObjectProperty的opaque是child
+     * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+     */
     object_property_add_child(proxy_obj, "virtio-backend", OBJECT(vdev), NULL);
     object_unref(OBJECT(vdev));
+    /*
+     * 对于virtblk的例子:
+     *   vdev算是VirtIOBlock
+     *   proxy_obj算是VirtIOBlkPCI
+     *   像是num-queues这些都是属于VirtIOBlock的,但是qemu-system_x86-64的参数都是在VirtIOBlkPCI设置的,
+     *   所以要设置alias
+     */
     qdev_alias_all_properties(vdev, proxy_obj);
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|1175| <<virtio_blk_device_realize>> virtio_init(vdev, "virtio-blk", VIRTIO_ID_BLOCK,
+ *   - hw/net/virtio-net.c|1980| <<virtio_net_device_realize>> virtio_init(vdev, "virtio-net", VIRTIO_ID_NET, n->config_size);
+ *   - hw/scsi/virtio-scsi.c|863| <<virtio_scsi_common_realize>> virtio_init(vdev, "virtio-scsi", VIRTIO_ID_SCSI,
+ *   - hw/virtio/virtio-balloon.c|442| <<virtio_balloon_device_realize>> virtio_init(vdev, "virtio-balloon", VIRTIO_ID_BALLOON,
+ *   - hw/9pfs/virtio-9p-device.c|206| <<virtio_9p_device_realize>> virtio_init(vdev, "virtio-9p", VIRTIO_ID_9P, v->config_size);
+ *   - hw/block/vhost-user-blk.c|254| <<vhost_user_blk_device_realize>> virtio_init(vdev, "virtio-blk", VIRTIO_ID_BLOCK,
+ *   - hw/char/virtio-serial-bus.c|1049| <<virtio_serial_device_realize>> virtio_init(vdev, "virtio-serial", VIRTIO_ID_CONSOLE,
+ *   - hw/display/virtio-gpu.c|1240| <<virtio_gpu_device_realize>> virtio_init(VIRTIO_DEVICE(g), "virtio-gpu", VIRTIO_ID_GPU,
+ *   - hw/input/virtio-input.c|259| <<virtio_input_device_realize>> virtio_init(vdev, "virtio-input", VIRTIO_ID_INPUT,
+ *   - hw/virtio/vhost-vsock.c|332| <<vhost_vsock_device_realize>> virtio_init(vdev, "vhost-vsock", VIRTIO_ID_VSOCK,
+ *   - hw/virtio/virtio-crypto.c|800| <<virtio_crypto_device_realize>> virtio_init(vdev, "virtio-crypto", VIRTIO_ID_CRYPTO, vcrypto->config_size);
+ *   - hw/virtio/virtio-rng.c|221| <<virtio_rng_device_realize>> virtio_init(vdev, "virtio-rng", VIRTIO_ID_RNG, 0);
+ *
+ * 下面k的例子:
+ *(gdb) 
+ * $16 = {
+ *   parent = {
+ *     parent_class = {
+ *       type = 0x5555567e4a20, 
+ *       interfaces = 0x0, 
+ *       object_cast_cache = {0x555555f6647e "bus", 0x555555f66482 "virtio-bus", 0x555555f051e4 "bus", 0x555555f67382 "bus"}, 
+ *       class_cast_cache = {0x555555f66482 "virtio-bus", 0x555555f0424d "bus", 0x555555f051e4 "bus", 0x555555ec4721 "virtio-bus"}, 
+ *       unparent = 0x555555a80bb5 <bus_unparent>, 
+ *       properties = 0x555556819aa0
+ *     }, 
+ *     print_dev = 0x0, 
+ *     get_dev_path = 0x555555be9123 <virtio_bus_get_dev_path>, 
+ *     get_fw_dev_path = 0x555555be917b <virtio_bus_get_fw_dev_path>, 
+ *     reset = 0x0, 
+ *     realize = 0x0, 
+ *     unrealize = 0x0, 
+ *     max_dev = 1, 
+ *     automatic_ids = 0
+ *   }, 
+ *   notify = 0x555555beaa30 <virtio_pci_notify>, 
+ *   save_config = 0x555555beaab2 <virtio_pci_save_config>, 
+ *   save_queue = 0x555555beac0c <virtio_pci_save_queue>, 
+ *   save_extra_state = 0x555555beab8f <virtio_pci_save_extra_state>, 
+ *   load_config = 0x555555beac7a <virtio_pci_load_config>, 
+ *   load_queue = 0x555555bead62 <virtio_pci_load_queue>, 
+ *   load_done = 0x0, 
+ *   load_extra_state = 0x555555beabce <virtio_pci_load_extra_state>, 
+ *   has_extra_state = 0x555555beab5f <virtio_pci_has_extra_state>, 
+ *   query_guest_notifiers = 0x555555beca32 <virtio_pci_query_guest_notifiers>, 
+ *   set_guest_notifiers = 0x555555beca61 <virtio_pci_set_guest_notifiers>, 
+ *   set_host_notifier_mr = 0x555555becd58 <virtio_pci_set_host_notifier_mr>, 
+ *   vmstate_change = 0x555555bece26 <virtio_pci_vmstate_change>, 
+ *   pre_plugged = 0x555555bee02d <virtio_pci_pre_plugged>, 
+ *   device_plugged = 0x555555bee0be <virtio_pci_device_plugged>, 
+ *   device_unplugged = 0x555555bee79c <virtio_pci_device_unplugged>, 
+ *   query_nvectors = 0x555555beceea <virtio_pci_query_nvectors>, 
+ *   ioeventfd_enabled = 0x555555beae29 <virtio_pci_ioeventfd_enabled>, 
+ *   ioeventfd_assign = 0x555555beae80 <virtio_pci_ioeventfd_assign>, 
+ *   has_variable_vring_alignment = false, 
+ *   get_dma_as = 0x555555becf2c <virtio_pci_get_dma_as>
+ * } 
+ *
+ * virtio blk的例子:
+ * 1175     virtio_init(vdev, "virtio-blk", VIRTIO_ID_BLOCK,
+ * 1176                 sizeof(struct virtio_blk_config));
+ */
 void virtio_init(VirtIODevice *vdev, const char *name,
                  uint16_t device_id, size_t config_size)
 {
+    /*
+     * 不同的两个virtio block调用进来的时候qbus的地址不同!!!
+     */
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
+    /*
+     * 不同的两个virtio block的k的地址是相同的
+     */
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
     int i;
     int nvectors = k->query_nvectors ? k->query_nvectors(qbus->parent) : 0;
@@ -2298,14 +3244,21 @@ hwaddr virtio_queue_get_desc_size(VirtIODevice *vdev, int n)
     return sizeof(VRingDesc) * vdev->vq[n].vring.num;
 }
 
+/*
+ * 返回整个VRingAvail占用的内存size, 包括后面的uint16_t们
+ */
 hwaddr virtio_queue_get_avail_size(VirtIODevice *vdev, int n)
 {
     return offsetof(VRingAvail, ring) +
         sizeof(uint16_t) * vdev->vq[n].vring.num;
 }
 
+/*
+ * 返回整个VRingUsed占用的内存size, 包括后面的VRingUsedElem们
+ */
 hwaddr virtio_queue_get_used_size(VirtIODevice *vdev, int n)
 {
+    /* offset会算上前面的uint16_t flags和uint16_t idx */
     return offsetof(VRingUsed, ring) +
         sizeof(VRingUsedElem) * vdev->vq[n].vring.num;
 }
@@ -2363,6 +3316,13 @@ static void virtio_queue_guest_notifier_read(EventNotifier *n)
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|956| <<virtio_pci_set_guest_notifier>> virtio_queue_set_guest_notifier_fd_handler(vq, false, with_irqfd);
+ *   - hw/virtio/virtio-pci.c|954| <<virtio_pci_set_guest_notifier>> virtio_queue_set_guest_notifier_fd_handler(vq, true, with_irqfd);
+ *   - hw/virtio/virtio-mmio.c|378| <<virtio_mmio_set_guest_notifier>> virtio_queue_set_guest_notifier_fd_handler(vq, true, with_irqfd);
+ *   - hw/virtio/virtio-mmio.c|380| <<virtio_mmio_set_guest_notifier>> virtio_queue_set_guest_notifier_fd_handler(vq, false, with_irqfd);
+ */
 void virtio_queue_set_guest_notifier_fd_handler(VirtQueue *vq, bool assign,
                                                 bool with_irqfd)
 {
@@ -2424,10 +3384,27 @@ static void virtio_queue_host_notifier_aio_poll_end(EventNotifier *n)
     virtio_queue_set_notification(vq, 1);
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|315| <<virtio_blk_data_plane_start>> virtio_queue_aio_set_host_notifier_handler(vq, s->ctx,
+ *   - hw/block/dataplane/virtio-blk.c|340| <<virtio_blk_data_plane_stop_bh>> virtio_queue_aio_set_host_notifier_handler(vq, s->ctx, NULL);
+ *   - hw/scsi/virtio-scsi-dataplane.c|106| <<virtio_scsi_vring_init>> virtio_queue_aio_set_host_notifier_handler(vq, s->ctx, fn);
+ *   - hw/scsi/virtio-scsi-dataplane.c|117| <<virtio_scsi_dataplane_stop_bh>> virtio_queue_aio_set_host_notifier_handler(vs->ctrl_vq, s->ctx, NULL);
+ *   - hw/scsi/virtio-scsi-dataplane.c|118| <<virtio_scsi_dataplane_stop_bh>> virtio_queue_aio_set_host_notifier_handler(vs->event_vq, s->ctx, NULL);
+ *   - hw/scsi/virtio-scsi-dataplane.c|120| <<virtio_scsi_dataplane_stop_bh>> virtio_queue_aio_set_host_notifier_handler(vs->cmd_vqs[i], s->ctx, NULL);
+ */
 void virtio_queue_aio_set_host_notifier_handler(VirtQueue *vq, AioContext *ctx,
                                                 VirtIOHandleAIOOutput handle_output)
 {
     if (handle_output) {
+        /*
+	 * 假设是hw/block/dataplane/virtio-blk.c的virtio_blk_data_plane_start()进来的
+	 * 404         virtio_queue_aio_set_host_notifier_handler(vq, s->ctx,
+	 * 405                 virtio_blk_data_plane_handle_output);
+	 *
+	 * 于是vq->handle_aio_output = virtio_blk_data_plane_handle_output;
+	 * ctx = VirtIOBlockDataPlane->ctx
+	 */
         vq->handle_aio_output = handle_output;
         aio_set_event_notifier(ctx, &vq->host_notifier, true,
                                virtio_queue_host_notifier_aio_read,
@@ -2457,6 +3434,13 @@ EventNotifier *virtio_queue_get_host_notifier(VirtQueue *vq)
     return &vq->host_notifier;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/vhost-user.c|661| <<vhost_user_host_notifier_restore>> virtio_queue_set_host_notifier_mr(vdev, queue_idx, &n->mr, true);
+ *   - hw/virtio/vhost-user.c|674| <<vhost_user_host_notifier_remove>> virtio_queue_set_host_notifier_mr(vdev, queue_idx, &n->mr, false);
+ *   - hw/virtio/vhost-user.c|914| <<vhost_user_slave_handle_vring_host_notifier>> virtio_queue_set_host_notifier_mr(vdev, queue_idx, &n->mr, false);
+ *   - hw/virtio/vhost-user.c|941| <<vhost_user_slave_handle_vring_host_notifier>> if (virtio_queue_set_host_notifier_mr(vdev, queue_idx, &n->mr, true)) {
+ */
 int virtio_queue_set_host_notifier_mr(VirtIODevice *vdev, int n,
                                       MemoryRegion *mr, bool assign)
 {
@@ -2505,6 +3489,40 @@ static void virtio_memory_listener_commit(MemoryListener *listener)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_device_realize (dev=0x555557785cf0, errp=0x7fffffffdb00) at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2509
+ * #1  0x0000555555a2d447 in device_set_realized (obj=0x555557785cf0, value=true, errp=0x7fffffffdd38) at hw/core/qdev.c:826
+ * #2  0x0000555555c21bc7 in property_set_bool (obj=0x555557785cf0, v=0x555557790940, name=0x555555e3cce6 "realized", opaque=0x555557787620, 
+ *     errp=0x7fffffffdd38) at qom/object.c:1984
+ * #3  0x0000555555c1fe4c in object_property_set (obj=0x555557785cf0, v=0x555557790940, name=0x555555e3cce6 "realized", errp=0x7fffffffdd38)
+ *     at qom/object.c:1176
+ * #4  0x0000555555c22f04 in object_property_set_qobject (obj=0x555557785cf0, value=0x555557790890, name=0x555555e3cce6 "realized", 
+ *     errp=0x7fffffffdd38) at qom/qom-qobject.c:27
+ * #5  0x0000555555c20131 in object_property_set_bool (obj=0x555557785cf0, value=true, name=0x555555e3cce6 "realized", errp=0x7fffffffdd38)
+ *     at qom/object.c:1242
+ * #6  0x0000555555b92c9f in virtio_blk_pci_realize (vpci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1970
+ * #7  0x0000555555b92682 in virtio_pci_realize (pci_dev=0x55555777db80, errp=0x7fffffffdd38) at hw/virtio/virtio-pci.c:1841
+ * #8  0x0000555555af770d in pci_qdev_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/pci/pci.c:2028
+ * #9  0x0000555555b92a90 in virtio_pci_dc_realize (qdev=0x55555777db80, errp=0x7fffffffddf0) at hw/virtio/virtio-pci.c:1915
+ * #10 0x0000555555a2d447 in device_set_realized (obj=0x55555777db80, value=true, errp=0x7fffffffdfc0) at hw/core/qdev.c:826
+ * #11 0x0000555555c21bc7 in property_set_bool (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", opaque=0x555557785fa0, 
+ *     errp=0x7fffffffdfc0) at qom/object.c:1984
+ * #12 0x0000555555c1fe4c in object_property_set (obj=0x55555777db80, v=0x55555778a9e0, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1176
+ * #13 0x0000555555c22f04 in object_property_set_qobject (obj=0x55555777db80, value=0x55555778a8a0, name=0x555555db778a "realized", 
+ *     errp=0x7fffffffdfc0) at qom/qom-qobject.c:27
+ * #14 0x0000555555c20131 in object_property_set_bool (obj=0x55555777db80, value=true, name=0x555555db778a "realized", errp=0x7fffffffdfc0)
+ *     at qom/object.c:1242
+ * #15 0x0000555555990749 in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe038) at qdev-monitor.c:627
+ * #16 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+ * #17 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, 
+ *     errp=0x0) at util/qemu-option.c:1106
+ * #18 0x000055555599dd61 in main (argc=15, argv=0x7fffffffe3a8, envp=0x7fffffffe428) at vl.c:4542
+ *
+ * used by only:
+ *   - hw/virtio/virtio.c|2761| <<virtio_device_class_init>> dc->realize = virtio_device_realize;
+ */
 static void virtio_device_realize(DeviceState *dev, Error **errp)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
@@ -2514,7 +3532,31 @@ static void virtio_device_realize(DeviceState *dev, Error **errp)
     /* Devices should either use vmsd or the load/save methods */
     assert(!vdc->vmsd || !vdc->load);
 
+    /*
+     * 设置的地方:
+     *   - hw/block/virtio-blk.c|1435| <<virtio_blk_class_init>> vdc->realize = virtio_blk_device_realize;
+     *   - hw/scsi/virtio-scsi.c|971| <<virtio_scsi_class_init>> vdc->realize = virtio_scsi_device_realize;
+     *   - hw/virtio/virtio-balloon.c|531| <<virtio_balloon_class_init>> vdc->realize = virtio_balloon_device_realize;
+     *   - hw/9pfs/virtio-9p-device.c|246| <<virtio_9p_class_init>> vdc->realize = virtio_9p_device_realize;
+     *   - hw/char/virtio-serial-bus.c|1173| <<virtio_serial_class_init>> vdc->realize = virtio_serial_device_realize;
+     *   - hw/display/virtio-gpu.c|1366| <<virtio_gpu_class_init>> vdc->realize = virtio_gpu_device_realize;
+     *   - hw/input/virtio-input.c|317| <<virtio_input_class_init>> vdc->realize = virtio_input_device_realize;
+     *   - hw/net/virtio-net.c|2212| <<virtio_net_class_init>> vdc->realize = virtio_net_device_realize;
+     *   - hw/virtio/vhost-vsock.c|397| <<vhost_vsock_class_init>> vdc->realize = vhost_vsock_device_realize;
+     *   - hw/virtio/virtio-crypto.c|958| <<virtio_crypto_class_init>> vdc->realize = virtio_crypto_device_realize;
+     *   - hw/block/vhost-user-blk.c|351| <<vhost_user_blk_class_init>> vdc->realize = vhost_user_blk_device_realize;
+     *   - hw/scsi/vhost-scsi.c|252| <<vhost_scsi_class_init>> vdc->realize = vhost_scsi_realize;
+     *   - hw/scsi/vhost-user-scsi.c|188| <<vhost_user_scsi_class_init>> vdc->realize = vhost_user_scsi_realize;
+     *   - hw/virtio/vhost-vsock.c|397| <<vhost_vsock_class_init>> vdc->realize = vhost_vsock_device_realize;
+     *   - hw/virtio/virtio-rng.c|274| <<virtio_rng_class_init>> vdc->realize = virtio_rng_device_realize;
+     *
+     * 调用的地方:
+     *   - hw/virtio/virtio.c|2612| <<virtio_device_realize>> vdc->realize(dev, &err);
+     */
     if (vdc->realize != NULL) {
+        /*
+	 * virtio_blk_device_realize()
+	 */
         vdc->realize(dev, &err);
         if (err != NULL) {
             error_propagate(errp, err);
@@ -2569,6 +3611,12 @@ static void virtio_device_free_virtqueues(VirtIODevice *vdev)
     g_free(vdev->vq);
 }
 
+/*
+ * TypeInfo virtio_device_info.instance_finalize = virtio_device_instance_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void virtio_device_instance_finalize(Object *obj)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(obj);
@@ -2585,6 +3633,15 @@ static Property virtio_properties[] = {
     DEFINE_PROP_END_OF_LIST(),
 };
 
+/*
+ * 关于start_ioeventfd:
+ * called by: 
+ *   - hw/virtio/virtio-bus.c|281| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+ * used by:
+ *   - hw/block/virtio-blk.c|1111| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start; --> block用
+ *   - hw/scsi/virtio-scsi.c|976| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ *   - hw/virtio/virtio.c|2799| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl; --> 网络用
+ */
 static int virtio_device_start_ioeventfd_impl(VirtIODevice *vdev)
 {
     VirtioBusState *qbus = VIRTIO_BUS(qdev_get_parent_bus(DEVICE(vdev)));
@@ -2639,6 +3696,13 @@ assign_error:
     return err;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|676| <<virtio_blk_handle_output>> virtio_device_start_ioeventfd(vdev);
+ *   - hw/scsi/virtio-scsi.c|443| <<virtio_scsi_handle_ctrl>> virtio_device_start_ioeventfd(vdev);
+ *   - hw/scsi/virtio-scsi.c|630| <<virtio_scsi_handle_cmd>> virtio_device_start_ioeventfd(vdev);
+ *   - hw/scsi/virtio-scsi.c|762| <<virtio_scsi_handle_event>> virtio_device_start_ioeventfd(vdev);
+ */
 int virtio_device_start_ioeventfd(VirtIODevice *vdev)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
@@ -2697,6 +3761,12 @@ void virtio_device_release_ioeventfd(VirtIODevice *vdev)
     virtio_bus_release_ioeventfd(vbus);
 }
 
+/*
+ * TypeInfo virtio_device_info.class_init = virtio_device_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void virtio_device_class_init(ObjectClass *klass, void *data)
 {
     /* Set the default value here. */
@@ -2707,6 +3777,15 @@ static void virtio_device_class_init(ObjectClass *klass, void *data)
     dc->unrealize = virtio_device_unrealize;
     dc->bus_type = TYPE_VIRTIO_BUS;
     dc->props = virtio_properties;
+    /*
+     * 关于start_ioeventfd:
+     * called by: 
+     *   - hw/virtio/virtio-bus.c|281| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+     * used by:
+     *   - hw/block/virtio-blk.c|1111| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start; --> block用
+     *   - hw/scsi/virtio-scsi.c|976| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+     *   - hw/virtio/virtio.c|2799| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl; --> 网络用
+     */
     vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
     vdc->stop_ioeventfd = virtio_device_stop_ioeventfd_impl;
 
@@ -2733,7 +3812,12 @@ static const TypeInfo virtio_device_info = {
 
 static void virtio_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&virtio_device_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(virtio_register_types)
diff --git a/include/block/aio.h b/include/block/aio.h
index f08630c..20a906f 100644
--- a/include/block/aio.h
+++ b/include/block/aio.h
@@ -83,6 +83,15 @@ struct AioContext {
      * Instead, the aio_poll calls include both the prepare and the
      * dispatch phase, hence a simple counter is enough for them.
      */
+    /*
+     * 用到notify_me的地方:
+     *   - util/aio-posix.c|525| <<run_poll_handlers>> assert(ctx->notify_me);
+     *   - util/aio-posix.c|593| <<aio_poll>> atomic_add(&ctx->notify_me, 2);
+     *   - util/aio-posix.c|634| <<aio_poll>> atomic_sub(&ctx->notify_me, 2);
+     *   - util/async.c|264| <<aio_ctx_prepare>> atomic_or(&ctx->notify_me, 1);
+     *   - util/async.c|282| <<aio_ctx_check>> atomic_and(&ctx->notify_me, ~1);
+     *   - util/async.c|390| <<aio_notify>> if (ctx->notify_me) {
+     */
     uint32_t notify_me;
 
     /* A lock to protect between QEMUBH and AioHandler adders and deleter,
diff --git a/include/block/block_int.h b/include/block/block_int.h
index 903b9c1..957f212 100644
--- a/include/block/block_int.h
+++ b/include/block/block_int.h
@@ -102,11 +102,19 @@ struct BlockDriver {
     bool (*bdrv_recurse_is_first_non_filter)(BlockDriverState *bs,
                                              BlockDriverState *candidate);
 
+    /*
+     * called by only:
+     *   - block.c|691| <<bdrv_probe_all>> score = d->bdrv_probe(buf, buf_size, filename);
+     */
     int (*bdrv_probe)(const uint8_t *buf, int buf_size, const char *filename);
     int (*bdrv_probe_device)(const char *filename);
 
     /* Any driver implementing this callback is expected to be able to handle
      * NULL file names in its .bdrv_open() implementation */
+    /*
+     * called by:
+     *   - block.c|1613| <<bdrv_fill_options>> drv->bdrv_parse_filename(filename, *options, &local_err);
+     */
     void (*bdrv_parse_filename)(const char *filename, QDict *options, Error **errp);
     /* Drivers not implementing bdrv_parse_filename nor bdrv_open should have
      * this field set to true, except ones that are defined only by their
@@ -119,21 +127,55 @@ struct BlockDriver {
     bool supports_backing;
 
     /* For handling image reopen for split or non-split files */
+    /*
+     * called by:
+     *   - block.c|3210| <<bdrv_reopen_prepare>> ret = drv->bdrv_reopen_prepare(reopen_state, queue, &local_err);
+     */
     int (*bdrv_reopen_prepare)(BDRVReopenState *reopen_state,
                                BlockReopenQueue *queue, Error **errp);
+    /*
+     * called by:
+     * - block.c|3298| <<bdrv_reopen_commit>> drv->bdrv_reopen_commit(reopen_state);
+     */
     void (*bdrv_reopen_commit)(BDRVReopenState *reopen_state);
+    /*
+     * called by:
+     *   - block.c|3342| <<bdrv_reopen_abort>> drv->bdrv_reopen_abort(reopen_state);
+     */
     void (*bdrv_reopen_abort)(BDRVReopenState *reopen_state);
     void (*bdrv_join_options)(QDict *options, QDict *old_options);
 
+    /*
+     * called by:
+     *   - block.c|1202| <<bdrv_open_driver>> ret = drv->bdrv_open(bs, options, open_flags, &local_err);
+     *   - block/snapshot.c|226| <<bdrv_snapshot_goto>> open_ret = drv->bdrv_open(bs, options, bs->open_flags, &local_err);
+     */
     int (*bdrv_open)(BlockDriverState *bs, QDict *options, int flags,
                      Error **errp);
 
     /* Protocol drivers should implement this instead of bdrv_open */
+    /*
+     * called by:
+     *   - block.c|1200| <<bdrv_open_driver>> ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);
+     */
     int (*bdrv_file_open)(BlockDriverState *bs, QDict *options, int flags,
                           Error **errp);
+    /*
+     * called by:
+     *   - block.c|3384| <<bdrv_close>> bs->drv->bdrv_close(bs);
+     *   - block/snapshot.c|221| <<bdrv_snapshot_goto>> drv->bdrv_close(bs);
+     */
     void (*bdrv_close)(BlockDriverState *bs);
+    /*
+     * called by:
+     *   - block.c|438| <<bdrv_create_co_entry>> ret = cco->drv->bdrv_co_create_opts(cco->filename, cco->opts, &local_err);
+     */
     int coroutine_fn (*bdrv_co_create)(BlockdevCreateOptions *opts,
                                        Error **errp);
+    /*
+     * called by only:
+     *   - block.c|438| <<bdrv_create_co_entry>> ret = cco->drv->bdrv_co_create_opts(cco->filename, cco->opts, &local_err);
+     */
     int coroutine_fn (*bdrv_co_create_opts)(const char *filename,
                                             QemuOpts *opts,
                                             Error **errp);
@@ -154,7 +196,7 @@ struct BlockDriver {
         int64_t offset, int bytes,
         BlockCompletionFunc *cb, void *opaque);
 
-    int coroutine_fn (*bdrv_co_readv)(BlockDriverState *bs,
+        int coroutine_fn (*bdrv_co_readv)(BlockDriverState *bs,
         int64_t sector_num, int nb_sectors, QEMUIOVector *qiov);
 
     /**
@@ -172,6 +214,10 @@ struct BlockDriver {
      *
      * The buffer in @qiov may point directly to guest memory.
      */
+    /*
+     * called by:
+     *   - block/io.c|1042| <<bdrv_driver_preadv>> return drv->bdrv_co_preadv(bs, offset, bytes, qiov, flags);
+     */
     int coroutine_fn (*bdrv_co_preadv)(BlockDriverState *bs,
         uint64_t offset, uint64_t bytes, QEMUIOVector *qiov, int flags);
     int coroutine_fn (*bdrv_co_writev)(BlockDriverState *bs,
@@ -191,6 +237,10 @@ struct BlockDriver {
      *
      * The buffer in @qiov may point directly to guest memory.
      */
+    /*
+     * called by:
+     *   - block/io.c|1088| <<bdrv_driver_pwritev>> ret = drv->bdrv_co_pwritev(bs, offset, bytes, qiov,
+     */
     int coroutine_fn (*bdrv_co_pwritev)(BlockDriverState *bs,
         uint64_t offset, uint64_t bytes, QEMUIOVector *qiov, int flags);
 
@@ -200,8 +250,16 @@ struct BlockDriver {
      * function pointer may be NULL or return -ENOSUP and .bdrv_co_writev()
      * will be called instead.
      */
+    /*
+     * called by:
+     *   - block/io.c|1523| <<bdrv_co_do_pwrite_zeroes>> ret = drv->bdrv_co_pwrite_zeroes(bs, offset, num,
+     */
     int coroutine_fn (*bdrv_co_pwrite_zeroes)(BlockDriverState *bs,
         int64_t offset, int bytes, BdrvRequestFlags flags);
+    /*
+     * called by:
+     *   - block/io.c|2799| <<bdrv_co_pdiscard>> ret = bs->drv->bdrv_co_pdiscard(bs, offset, num);
+     */
     int coroutine_fn (*bdrv_co_pdiscard)(BlockDriverState *bs,
         int64_t offset, int bytes);
 
@@ -212,6 +270,10 @@ struct BlockDriver {
      * See the comment of bdrv_co_copy_range for the parameter and return value
      * semantics.
      */
+    /*
+     * called by:
+     *   - block/io.c|3044| <<bdrv_co_copy_range_internal>> ret = src->bs->drv->bdrv_co_copy_range_from(src->bs,
+     */
     int coroutine_fn (*bdrv_co_copy_range_from)(BlockDriverState *bs,
                                                 BdrvChild *src,
                                                 uint64_t offset,
@@ -229,6 +291,10 @@ struct BlockDriver {
      * See the comment of bdrv_co_copy_range for the parameter and return value
      * semantics.
      */
+    /*
+     * called by:
+     *   - block/io.c|3059| <<bdrv_co_copy_range_internal>> ret = dst->bs->drv->bdrv_co_copy_range_to(dst->bs,
+     */
     int coroutine_fn (*bdrv_co_copy_range_to)(BlockDriverState *bs,
                                               BdrvChild *src,
                                               uint64_t src_offset,
@@ -254,6 +320,10 @@ struct BlockDriver {
      * as well as non-NULL pnum, map, and file; in turn, the driver
      * must return an error or set pnum to an aligned non-zero value.
      */
+    /*
+     * called by:
+     *   - block/io.c|2141| <<bdrv_co_block_status>> ret = bs->drv->bdrv_co_block_status(bs, want_zero, aligned_offset,
+     */
     int coroutine_fn (*bdrv_co_block_status)(BlockDriverState *bs,
         bool want_zero, int64_t offset, int64_t bytes, int64_t *pnum,
         int64_t *map, BlockDriverState **file);
@@ -261,6 +331,10 @@ struct BlockDriver {
     /*
      * Invalidate any cached meta-data.
      */
+    /*
+     * called by:
+     *   - block.c|4417| <<bdrv_co_invalidate_cache>> bs->drv->bdrv_co_invalidate_cache(bs, &local_err);
+     */
     void coroutine_fn (*bdrv_co_invalidate_cache)(BlockDriverState *bs,
                                                   Error **errp);
     int (*bdrv_inactivate)(BlockDriverState *bs);
@@ -276,6 +350,10 @@ struct BlockDriver {
      * Flushes all data that was already written to the OS all the way down to
      * the disk (for example file-posix.c calls fsync()).
      */
+    /*
+     * called by:
+     *   - block/io.c|2629| <<bdrv_co_flush>> ret = bs->drv->bdrv_co_flush_to_disk(bs);
+     */
     int coroutine_fn (*bdrv_co_flush_to_disk)(BlockDriverState *bs);
 
     /*
@@ -292,12 +370,28 @@ struct BlockDriver {
      * bdrv_parse_filename.
      */
     const char *protocol_name;
+    /*
+     * called by:
+     *   - block/io.c|3193| <<bdrv_co_truncate>> ret = drv->bdrv_co_truncate(bs, offset, prealloc, errp);
+     */
     int coroutine_fn (*bdrv_co_truncate)(BlockDriverState *bs, int64_t offset,
                                          PreallocMode prealloc, Error **errp);
 
+    /*
+     * called by:
+     *   - block.c|751| <<refresh_total_sectors>> int64_t length = drv->bdrv_getlength(bs);
+     */
     int64_t (*bdrv_getlength)(BlockDriverState *bs);
     bool has_variable_length;
+    /*
+     * called by:
+     *   - block.c|3824| <<bdrv_get_allocated_file_size>> return drv->bdrv_get_allocated_file_size(bs);
+     */
     int64_t (*bdrv_get_allocated_file_size)(BlockDriverState *bs);
+    /*
+     * called by:
+     *   - block.c|3864| <<bdrv_measure>> return drv->bdrv_measure(opts, in_bs, errp);
+     */
     BlockMeasureInfo *(*bdrv_measure)(QemuOpts *opts, BlockDriverState *in_bs,
                                       Error **errp);
 
@@ -318,6 +412,10 @@ struct BlockDriver {
                                   const char *snapshot_id,
                                   const char *name,
                                   Error **errp);
+    /*
+     * called by:
+     *   - block.c|4205| <<bdrv_get_info>> return drv->bdrv_get_info(bs, bdi);
+     */
     int (*bdrv_get_info)(BlockDriverState *bs, BlockDriverInfo *bdi);
     ImageInfoSpecific *(*bdrv_get_specific_info)(BlockDriverState *bs);
 
@@ -333,17 +431,38 @@ struct BlockDriver {
 
     /* removable device specific */
     bool (*bdrv_is_inserted)(BlockDriverState *bs);
+    /*
+     * called by:
+     *   - block.c|4620| <<bdrv_eject>> drv->bdrv_eject(bs, eject_flag);
+     */
     void (*bdrv_eject)(BlockDriverState *bs, bool eject_flag);
+    /*
+     * called by:
+     *   - block.c|4635| <<bdrv_lock_medium>> drv->bdrv_lock_medium(bs, locked);
+     */
     void (*bdrv_lock_medium)(BlockDriverState *bs, bool locked);
 
     /* to control generic scsi devices */
     BlockAIOCB *(*bdrv_aio_ioctl)(BlockDriverState *bs,
         unsigned long int req, void *buf,
         BlockCompletionFunc *cb, void *opaque);
+    /*
+     * called by:
+     *   - block/io.c|2868| <<bdrv_co_ioctl>> co.ret = drv->bdrv_co_ioctl(bs, req, buf);
+     */
     int coroutine_fn (*bdrv_co_ioctl)(BlockDriverState *bs,
                                       unsigned long int req, void *buf);
 
     /* List of options for creating images, terminated by name == NULL */
+    /*
+     * 主要被以下使用:
+     *   - block.c|2536| <<bdrv_append_temp_snapshot>> opts = qemu_opts_create(bdrv_qcow2.create_opts, NULL, 0,
+     *   - block.c|4757| <<bdrv_img_create>> if (!drv->create_opts) {
+     *   - block.c|4763| <<bdrv_img_create>> if (!proto_drv->create_opts) {
+     *   - block.c|4769| <<bdrv_img_create>> create_opts = qemu_opts_append(create_opts, drv->create_opts);
+     *   - block.c|4770| <<bdrv_img_create>> create_opts = qemu_opts_append(create_opts, proto_drv->create_opts);
+     *   - 最后就是qemu-img命令
+     */
     QemuOptsList *create_opts;
 
     /*
@@ -369,12 +488,20 @@ struct BlockDriver {
     int (*bdrv_debug_resume)(BlockDriverState *bs, const char *tag);
     bool (*bdrv_debug_is_suspended)(BlockDriverState *bs, const char *tag);
 
+    /*
+     * called by:
+     *   - block/io.c|162| <<bdrv_refresh_limits>> drv->bdrv_refresh_limits(bs, errp);
+     */
     void (*bdrv_refresh_limits)(BlockDriverState *bs, Error **errp);
 
     /*
      * Returns 1 if newly created images are guaranteed to contain only
      * zeros, 0 otherwise.
      */
+    /*
+     * called by:
+     *   - block.c|4141| <<bdrv_has_zero_init>> return bs->drv->bdrv_has_zero_init(bs);
+     */
     int (*bdrv_has_zero_init)(BlockDriverState *bs);
 
     /* Remove fd handlers, timers, and other event loop callbacks so the event
@@ -387,11 +514,23 @@ struct BlockDriver {
      * can be processed again.  Called with no in-flight requests and in
      * depth-first traversal order with child nodes before parent nodes.
      */
+    /*
+     * called by:
+     *   - block.c|4976| <<bdrv_attach_aio_context>> bs->drv->bdrv_attach_aio_context(bs, new_context);
+     */
     void (*bdrv_attach_aio_context)(BlockDriverState *bs,
                                     AioContext *new_context);
 
     /* io queue for linux-aio */
+    /*
+     * called by:
+     *   - block/io.c|2953| <<bdrv_io_plug>> drv->bdrv_io_plug(bs);
+     */
     void (*bdrv_io_plug)(BlockDriverState *bs);
+    /*
+     * called by:
+     *   - block/io.c|2966| <<bdrv_io_unplug>> drv->bdrv_io_unplug(bs);
+     */
     void (*bdrv_io_unplug)(BlockDriverState *bs);
 
     /**
@@ -399,6 +538,10 @@ struct BlockDriver {
      * On success, store them in @bsz and return zero.
      * On failure, return negative errno.
      */
+    /*
+     * called by:
+     *   - block.c|515| <<bdrv_probe_blocksizes>> return drv->bdrv_probe_blocksizes(bs, bsz);
+     */
     int (*bdrv_probe_blocksizes)(BlockDriverState *bs, BlockSizes *bsz);
     /**
      * Try to get @bs's geometry (cyls, heads, sectors)
@@ -407,6 +550,10 @@ struct BlockDriver {
      * Only drivers that want to override guest geometry implement this
      * callback; see hd_geometry_guess().
      */
+    /*
+     * called by:
+     *   - block.c|534| <<bdrv_probe_geometry>> return drv->bdrv_probe_geometry(bs, geo);
+     */
     int (*bdrv_probe_geometry)(BlockDriverState *bs, HDGeometry *geo);
 
     /**
@@ -442,6 +589,10 @@ struct BlockDriver {
      * If both conditions are met, 0 is returned. Otherwise, -errno is returned
      * and errp is set to an error describing the conflict.
      */
+    /*
+     * called by:
+     *   - block.c|1728| <<bdrv_check_perm>> return drv->bdrv_check_perm(bs, cumulative_perms,
+     */
     int (*bdrv_check_perm)(BlockDriverState *bs, uint64_t perm,
                            uint64_t shared, Error **errp);
 
@@ -455,6 +606,10 @@ struct BlockDriver {
      * This function is only invoked after bdrv_check_perm(), so block drivers
      * may rely on preparations made in their .bdrv_check_perm implementation.
      */
+    /*
+     * called by:
+     *   - block.c|1791| <<bdrv_set_perm>> drv->bdrv_set_perm(bs, cumulative_perms, cumulative_shared_perms);
+     */
     void (*bdrv_set_perm)(BlockDriverState *bs, uint64_t perm, uint64_t shared);
 
     /*
@@ -465,6 +620,10 @@ struct BlockDriver {
      * This function can be called even for nodes that never saw a
      * bdrv_check_perm() call. It is a no-op then.
      */
+    /*
+     * called by:
+     *   - block.c|1771| <<bdrv_abort_perm_update>> drv->bdrv_abort_perm_update(bs);
+     */
     void (*bdrv_abort_perm_update)(BlockDriverState *bs);
 
     /**
@@ -479,6 +638,10 @@ struct BlockDriver {
      * permissions, but those that will be needed after applying the
      * @reopen_queue.
      */
+    /*
+     * called by:
+     *   - block.c|1686| <<bdrv_child_perm>> bs->drv->bdrv_child_perm(bs, c, role, reopen_queue,
+     */
      void (*bdrv_child_perm)(BlockDriverState *bs, BdrvChild *c,
                              const BdrvChildRole *role,
                              BlockReopenQueue *reopen_queue,
diff --git a/include/exec/cpu-all.h b/include/exec/cpu-all.h
index 117d2fb..be3a9f7 100644
--- a/include/exec/cpu-all.h
+++ b/include/exec/cpu-all.h
@@ -219,7 +219,9 @@ extern int target_page_bits;
 #define TARGET_PAGE_BITS_MIN TARGET_PAGE_BITS
 #endif
 
+/* 0x1000 */
 #define TARGET_PAGE_SIZE (1 << TARGET_PAGE_BITS)
+/* 0xfffff000 */
 #define TARGET_PAGE_MASK ~(TARGET_PAGE_SIZE - 1)
 #define TARGET_PAGE_ALIGN(addr) (((addr) + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK)
 
diff --git a/include/exec/memory.h b/include/exec/memory.h
index 448d41a..121a6e2 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -32,6 +32,7 @@
 #define MAX_PHYS_ADDR_SPACE_BITS 62
 #define MAX_PHYS_ADDR            (((hwaddr)1 << MAX_PHYS_ADDR_SPACE_BITS) - 1)
 
+/* TypeInfo memory_region_info */
 #define TYPE_MEMORY_REGION "qemu:memory-region"
 #define MEMORY_REGION(obj) \
         OBJECT_CHECK(MemoryRegion, (obj), TYPE_MEMORY_REGION)
@@ -336,6 +337,18 @@ typedef struct IOMMUMemoryRegionClass {
 typedef struct CoalescedMemoryRange CoalescedMemoryRange;
 typedef struct MemoryRegionIoeventfd MemoryRegionIoeventfd;
 
+/*
+ * TYPE_MEMORY_REGION的instance
+ *
+ * MemoryRegion是树状父子结构的,每一个ramblock都有一个对应的MemoryRegion,
+ * 一般而言,这个MemoryRegion是最顶级的MemoryRegion,它还有很多子MemoryRegion,
+ * 比如在这个ramblock地址范围内的MMIO等.
+ *
+ * MemoryRegion有多种类型,可以表示一段ram,rom,MMIO,alias,alias表示一个
+ * MemoryRegion的一部分区域,MemoryRegion也可以表示一个container,这就表示它
+ * 只是其他若干个MemoryRegion的容器.在MemoryRegion中,'ram_block'表示的是分配
+ * 的实际内存.
+ */
 struct MemoryRegion {
     Object parent_obj;
 
@@ -343,6 +356,15 @@ struct MemoryRegion {
 
     /* The following fields should fit in a cache line */
     bool romd_mode;
+    /*
+     * 所有把ram设置成true的地方:
+     *   - memory.c|1986| <<memory_region_init_ram_shared_nomigrate>> mr->ram = true;
+     *   - memory.c|2004| <<memory_region_init_resizeable_ram>> mr->ram = true;
+     *   - memory.c|2023| <<memory_region_init_ram_from_file>> mr->ram = true;
+     *   - memory.c|2040| <<memory_region_init_ram_from_fd>> mr->ram = true;
+     *   - memory.c|2055| <<memory_region_init_ram_ptr>> mr->ram = true;
+     *   - memory.c|2118| <<memory_region_init_rom_nomigrate>> mr->ram = true;
+     */
     bool ram;
     bool subpage;
     bool readonly; /* For RAM regions */
@@ -351,21 +373,54 @@ struct MemoryRegion {
     bool global_locking;
     uint8_t dirty_log_mask;
     bool is_iommu;
+    /*
+     * 被以下初始化:
+     *   - memory.c|1647| <<memory_region_init_ram_shared_nomigrate>> mr->ram_block = qemu_ram_alloc(size, share, mr, errp);
+     *   - memory.c|1665| <<memory_region_init_resizeable_ram>> mr->ram_block = qemu_ram_alloc_resizeable(size, max_size, resized,
+     *   - memory.c|1685| <<memory_region_init_ram_from_file>> mr->ram_block = qemu_ram_alloc_from_file(size, mr, share, path, errp);
+     *   - memory.c|1701| <<memory_region_init_ram_from_fd>> mr->ram_block = qemu_ram_alloc_from_fd(size, mr, share, fd, errp);
+     *   - memory.c|1720| <<memory_region_init_ram_ptr>> mr->ram_block = qemu_ram_alloc_from_ptr(size, ptr, mr, &error_fatal);
+     *   - memory.c|1758| <<memory_region_init_rom_nomigrate>> mr->ram_block = qemu_ram_alloc(size, false, mr, errp);
+     *   - memory.c|1777| <<memory_region_init_rom_device_nomigrate>> mr->ram_block = qemu_ram_alloc(size, false, mr, errp);
+     */
     RAMBlock *ram_block;
     Object *owner;
 
     const MemoryRegionOps *ops;
     void *opaque;
+    /* 记录这个MemoryRegion是谁的subregion */
     MemoryRegion *container;
     Int128 size;
+    /* 在AddressSpace中的地址 */
     hwaddr addr;
     void (*destructor)(MemoryRegion *mr);
     uint64_t align;
+    /*
+     * 设置terminates的地方, 初始化默认是false吧:
+     *   - memory.c|1867| <<memory_region_init_io>> mr->terminates = true;
+     *   - memory.c|1900| <<memory_region_init_ram_shared_nomigrate>> mr->terminates = true;
+     *   - memory.c|1918| <<memory_region_init_resizeable_ram>> mr->terminates = true;
+     *   - memory.c|1937| <<memory_region_init_ram_from_file>> mr->terminates = true;
+     *   - memory.c|1954| <<memory_region_init_ram_from_fd>> mr->terminates = true;
+     *   - memory.c|1969| <<memory_region_init_ram_ptr>> mr->terminates = true;
+     *   - memory.c|2020| <<memory_region_init_rom_nomigrate>> mr->terminates = true;
+     *   - memory.c|2038| <<memory_region_init_rom_device_nomigrate>> mr->terminates = true;
+     *   - memory.c|2058| <<memory_region_init_iommu>> mr->terminates = true;
+     *
+     * 使用的地方:
+     *   - memory.c|923| <<render_memory_region>> if (!mr->terminates) {
+     *   - memory.c|995| <<memory_region_get_flatview_root>> } else if (!mr->terminates) {
+     *
+     * 好像没有subregion的会设置成true
+     */
     bool terminates;
     bool ram_device;
     bool enabled;
     bool warning_printed; /* For reservations */
     uint8_t vga_logging_count;
+    /*
+     * alias表明此MemoryRegion是另外一个MemoryRegion的一部分的alias
+     */
     MemoryRegion *alias;
     hwaddr alias_offset;
     int32_t priority;
@@ -374,6 +429,22 @@ struct MemoryRegion {
     QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced;
     const char *name;
     unsigned ioeventfd_nb;
+    /*
+     * 主要用到ioeventfds的地方:
+     *   - accel/kvm/kvm-all.c -- kvm_check_many_ioeventfds()
+     *   - hw/vfio/pci-quirks.c -- vfio_quirk_alloc()
+     *   - hw/vfio/pci-quirks.c -- vfio_drop_dynamic_eventfds()
+     *   - hw/vfio/pci-quirks.c -- vfio_nvidia_quirk_mirror_write()
+     *   - hw/vfio/pci-quirks.c -- vfio_bar_quirk_exit()
+     *   - hw/vfio/pci-quirks.c -- vfio_bar_quirk_exit()
+     *   - memory.c -- memory_region_add_eventfd()
+     *   - memory.c -- memory_region_del_eventfd()
+     *   - memory.c -- address_space_update_ioeventfds()
+     *   - memory.c -- memory_region_dispatch_write_eventfds()
+     *   - memory.c -- memory_region_finalize()
+     *   - memory.c -- address_space_init()
+     *   - memory.c -- do_address_space_destroy()
+     */
     MemoryRegionIoeventfd *ioeventfds;
 };
 
@@ -394,8 +465,23 @@ struct IOMMUMemoryRegion {
  * Use with memory_listener_register() and memory_listener_unregister().
  */
 struct MemoryListener {
+    /*
+     * 设置begin的地方:
+     *   - hw/virtio/vhost.c|1232| <<vhost_dev_init>> .begin = vhost_begin,
+     */
     void (*begin)(MemoryListener *listener);
+    /*
+     * 设置commit的地方:
+     *   - hw/virtio/vhost.c|1233| <<vhost_dev_init>> .commit = vhost_commit,
+     *   - hw/virtio/virtio.c|2532| <<virtio_device_realize>> vdev->listener.commit = virtio_memory_listener_commit;
+     *   - exec.c|1149| <<cpu_address_space_init>> newas->tcg_as_listener.commit = tcg_commit;
+     */
     void (*commit)(MemoryListener *listener);
+    /*
+     * called only by:
+     *   - address_space_update_topology_pass()
+     *   - listener_add_address_space()
+     */
     void (*region_add)(MemoryListener *listener, MemoryRegionSection *section);
     void (*region_del)(MemoryListener *listener, MemoryRegionSection *section);
     void (*region_nop)(MemoryListener *listener, MemoryRegionSection *section);
@@ -406,6 +492,12 @@ struct MemoryListener {
     void (*log_sync)(MemoryListener *listener, MemoryRegionSection *section);
     void (*log_global_start)(MemoryListener *listener);
     void (*log_global_stop)(MemoryListener *listener);
+    /*
+     * 设置eventfd_add的地方:
+     *   - accel/kvm/kvm-all.c|919| <<global>> .eventfd_add = kvm_io_ioeventfd_add,
+     *   - accel/kvm/kvm-all.c|1707| <<kvm_init>> s->memory_listener.listener.eventfd_add = kvm_mem_ioeventfd_add;
+     *   - hw/virtio/vhost.c|1241| <<vhost_dev_init>> .eventfd_add = vhost_eventfd_add,
+     */
     void (*eventfd_add)(MemoryListener *listener, MemoryRegionSection *section,
                         bool match_data, uint64_t data, EventNotifier *e);
     void (*eventfd_del)(MemoryListener *listener, MemoryRegionSection *section,
@@ -424,6 +516,10 @@ struct MemoryListener {
 /**
  * AddressSpace: describes a mapping of addresses to #MemoryRegion objects
  */
+/*
+ * qemu中用AddressSpace用来表示CPU/设备看到的内存,一个AddressSpace下面包含
+ * 多个MemoryRegion,这些MemoryRegion结构通过树连接起来,树的根是AddressSpace的root域
+ */
 struct AddressSpace {
     /* All fields are private. */
     struct rcu_head rcu;
@@ -431,11 +527,58 @@ struct AddressSpace {
     MemoryRegion *root;
 
     /* Accessed via RCU.  */
+    /*
+     * AddressSpace的一张平面视图,它是AddressSpace所有正在使用的MemoryRegion的集合,这是从CPU的视角来看到的
+     */
     struct FlatView *current_map;
 
     int ioeventfd_nb;
+    /*
+     * 主要用到ioeventfds的地方:
+     *   - accel/kvm/kvm-all.c -- kvm_check_many_ioeventfds()
+     *   - hw/vfio/pci-quirks.c -- vfio_quirk_alloc()
+     *   - hw/vfio/pci-quirks.c -- vfio_drop_dynamic_eventfds()
+     *   - hw/vfio/pci-quirks.c -- vfio_nvidia_quirk_mirror_write()
+     *   - hw/vfio/pci-quirks.c -- vfio_bar_quirk_exit()
+     *   - hw/vfio/pci-quirks.c -- vfio_bar_quirk_exit()
+     *   - memory.c -- memory_region_add_eventfd()
+     *   - memory.c -- memory_region_del_eventfd()
+     *   - memory.c -- address_space_update_ioeventfds()
+     *   - memory.c -- memory_region_dispatch_write_eventfds()
+     *   - memory.c -- memory_region_finalize()
+     *   - memory.c -- address_space_init()
+     *   - memory.c -- do_address_space_destroy()
+     */
     struct MemoryRegionIoeventfd *ioeventfds;
+    /*
+     * 使用listerner的地方:
+     *   - memory.c|162| <<MEMORY_LISTENER_CALL>> struct memory_listeners_as *list = &(_as)->listeners; \
+     *   - memory.c|1034| <<address_space_set_flatview>> if (!QTAILQ_EMPTY(&as->listeners)) {
+     *   - memory.c|2777| <<memory_listener_register>> if (QTAILQ_EMPTY(&as->listeners)
+     *   - memory.c|2778| <<memory_listener_register>> || listener->priority >= QTAILQ_LAST(&as->listeners,
+     *   - memory.c|2780| <<memory_listener_register>> QTAILQ_INSERT_TAIL(&as->listeners, listener, link_as);
+     *   - memory.c|2782| <<memory_listener_register>> QTAILQ_FOREACH(other, &as->listeners, link_as) {
+     *   - memory.c|2801| <<memory_listener_unregister>> QTAILQ_REMOVE(&listener->address_space->listeners, listener, link_as);
+     *   - memory.c|2931| <<address_space_init>> QTAILQ_INIT(&as->listeners);
+     *   - memory.c|2944| <<do_address_space_destroy>> assert(QTAILQ_EMPTY(&as->listeners));
+     */
     QTAILQ_HEAD(memory_listeners_as, MemoryListener) listeners;
+    /*
+     * 添加:
+     *   - memory.c|2933| <<address_space_init>> QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
+     *
+     * 删除:
+     *   - memory.c|2960| <<address_space_destroy>> QTAILQ_REMOVE(&address_spaces, as, address_spaces_link);
+     *
+     * 使用:
+     *   - memory.c|638| <<memory_region_to_address_space>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|1005| <<flatviews_reset>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|1096| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|1104| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|2260| <<memory_region_update_coalesced_range>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|3255| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|3279| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     */
     QTAILQ_ENTRY(AddressSpace) address_spaces_link;
 };
 
@@ -448,15 +591,25 @@ typedef struct FlatRange FlatRange;
 struct FlatView {
     struct rcu_head rcu;
     unsigned ref;
+    /* nr_allocated个 数组 */
     FlatRange *ranges;
+    /* 当前正在使用的ranges */
     unsigned nr;
+    /* ranges数组中元素的数目 */
     unsigned nr_allocated;
     struct AddressSpaceDispatch *dispatch;
     MemoryRegion *root;
 };
 
+/*
+ * 返回AddressSpace的current_map
+ */
 static inline FlatView *address_space_to_flatview(AddressSpace *as)
 {
+    /*
+     * current_map是AddressSpace的一张平面视图,它是AddressSpace
+     * 所有正在使用的MemoryRegion的集合,这是从CPU的视角来看到的
+     */
     return atomic_rcu_read(&as->current_map);
 }
 
diff --git a/include/exec/ram_addr.h b/include/exec/ram_addr.h
index cf4ce06..0f12b75 100644
--- a/include/exec/ram_addr.h
+++ b/include/exec/ram_addr.h
@@ -23,10 +23,21 @@
 #include "hw/xen/xen.h"
 #include "exec/ramlist.h"
 
+/*
+ * 是真正分配了host内存的地方
+ *
+ * 每一个ram_block还会被连接到全局的'ram_list'链表上
+ */
 struct RAMBlock {
     struct rcu_head rcu;
     struct MemoryRegion *mr;
+    /*
+     * 'host'指向了动态分配的内存,用于表示实际的虚拟机物理内存
+     */
     uint8_t *host;
+    /*
+     * offset表示了这块内存在虚拟机物理内存中的偏移
+     */
     ram_addr_t offset;
     ram_addr_t used_length;
     ram_addr_t max_length;
diff --git a/include/hw/boards.h b/include/hw/boards.h
index d139a43..42479d0 100644
--- a/include/hw/boards.h
+++ b/include/hw/boards.h
@@ -48,6 +48,7 @@ void memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner,
  */
 #define MACHINE_TYPE_NAME(machinename) (machinename TYPE_MACHINE_SUFFIX)
 
+/* TypeInfo machine_info */
 #define TYPE_MACHINE "machine"
 #undef MACHINE  /* BSD defines it and QEMU does not use it */
 #define MACHINE(obj) \
@@ -169,7 +170,18 @@ struct MachineClass {
     const char *desc;
     const char *deprecation_reason;
 
+    /*
+     * called by:
+     *   - hw/core/machine.c|870| <<machine_run_board_init>> machine_class->init(machine);
+     *
+     * 在以下初始化:
+     *   - init是在DEFINE_PC_MACHINE()初始化的
+     */
     void (*init)(MachineState *state);
+    /*
+     * called by:
+     *   - vl.c|1645| <<qemu_system_reset>> mc->reset();
+     */
     void (*reset)(void);
     void (*hot_add_cpu)(const int64_t id, Error **errp);
     int (*kvm_type)(const char *arg);
@@ -258,6 +270,10 @@ struct MachineState {
     char *memory_encryption;
     DeviceMemoryState *device_memory;
 
+    /*
+     * 设定的地方:
+     *   - vl.c|4581| <<main>> current_machine->ram_size = ram_size;
+     */
     ram_addr_t ram_size;
     ram_addr_t maxram_size;
     uint64_t   ram_slots;
diff --git a/include/hw/i386/pc.h b/include/hw/i386/pc.h
index 6894f37..f1fad21 100644
--- a/include/hw/i386/pc.h
+++ b/include/hw/i386/pc.h
@@ -37,7 +37,7 @@ struct PCMachineState {
     /* Pointers to devices and objects: */
     HotplugHandler *acpi_dev;
     ISADevice *rtc;
-    PCIBus *bus;
+    PCIBus *bus;  // 有pci bus!
     FWCfgState *fw_cfg;
     qemu_irq *gsi;
 
@@ -136,6 +136,16 @@ struct PCMachineClass {
     bool linuxboot_dma_enabled;
 };
 
+/* TypeInfo pc_machine_info */
+/*
+ * TYPE_PC_MACHINE is used by:
+ *   - hw/i386/x86-iommu.c|88| <<x86_iommu_realize>> PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));
+ *   - include/hw/i386/pc.h|142| <<PC_MACHINE>> OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|144| <<PC_MACHINE_GET_CLASS>> OBJECT_GET_CLASS(PCMachineClass, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|146| <<PC_MACHINE_CLASS>> OBJECT_CLASS_CHECK(PCMachineClass, (klass), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|954| <<DEFINE_PC_MACHINE>> .parent = TYPE_PC_MACHINE, \
+ *   - target/i386/kvm.c|1455| <<kvm_arch_init>> object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE) &&
+ */
 #define TYPE_PC_MACHINE "generic-pc-machine"
 #define PC_MACHINE(obj) \
     OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
@@ -248,7 +258,9 @@ extern int no_hpet;
 struct PCII440FXState;
 typedef struct PCII440FXState PCII440FXState;
 
+/* TypeInfo i440fx_pcihost_info */
 #define TYPE_I440FX_PCI_HOST_BRIDGE "i440FX-pcihost"
+/* TypeInfo i440fx_info */
 #define TYPE_I440FX_PCI_DEVICE "i440FX"
 
 #define TYPE_IGD_PASSTHROUGH_I440FX_PCI_DEVICE "igd-passthrough-i440FX"
@@ -941,6 +953,69 @@ bool e820_get_entry(int, uint32_t, uint64_t *, uint64_t *);
         .value = "off",\
     },
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|1136| <<global>> DEFINE_PC_MACHINE(isapc, "isapc", pc_init_isa,
+ *   - hw/i386/pc_piix.c|1148| <<global>> DEFINE_PC_MACHINE(xenfv, "xenfv", pc_xen_hvm_init,
+ *   - hw/i386/pc_piix.c|417| <<DEFINE_I440FX_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *   - hw/i386/pc_q35.c|294| <<DEFINE_Q35_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *
+ * (gdb) p *machine_class
+ * $3 = {
+ *   parent_class = {
+ *     type = 0x555556785020, 
+ *     interfaces = 0x555556827780, 
+ *     object_cast_cache = {0x555555ea72b8 "generic-pc-machine", 0x555555ebd4f6 "machine", 0x555555eb8280 "generic-pc-machine", 0x555555f427bd "machine"}, 
+ *     class_cast_cache = {0x555555ea870d "generic-pc-machine", 0x555555e9299a "machine", 0x555555ee2032 "machine", 0x555555e8e912 "machine"}, 
+ *     unparent = 0x0, 
+ *     properties = 0x555556834300
+ *   }, 
+ *   family = 0x555555ea889e "pc_piix", 
+ *   name = 0x555556836d90 "pc-i440fx-3.0", 
+ *   alias = 0x555555ea88c7 "pc", 
+ *   desc = 0x555555ea8788 "Standard PC (i440FX + PIIX, 1996)", 
+ *   deprecation_reason = 0x0, 
+ *   init = 0x55555591d9e4 <pc_init_v3_0>, 
+ *   reset = 0x55555591bfcd <pc_machine_reset>, 
+ *   hot_add_cpu = 0x55555591851d <pc_hot_add_cpu>, 
+ *   kvm_type = 0x0, 
+ *   block_default_type = IF_IDE, 
+ *   units_per_default_bus = 0, 
+ *   max_cpus = 255, 
+ *   min_cpus = 1, 
+ *   default_cpus = 1, 
+ *   no_serial = 0, 
+ *   no_parallel = 0, 
+ *   use_virtcon = 0, 
+ *   no_floppy = 0, 
+ *   no_cdrom = 0, 
+ *   no_sdcard = 0, 
+ *   pci_allow_0_address = 0, 
+ *   legacy_fw_cfg_order = 0, 
+ *   is_default = 1, 
+ *   default_machine_opts = 0x555555ea88a6 "firmware=bios-256k.bin", 
+ *   default_boot_order = 0x555555ea7de8 "cad", 
+ *   default_display = 0x555555ea88bd "std", 
+ *   compat_props = 0x0, 
+ *   hw_version = 0x0, 
+ *   default_ram_size = 134217728, 
+ *   default_cpu_type = 0x555555ea7dec "qemu64-x86_64-cpu", 
+ *   option_rom_has_mr = false, 
+ *   rom_file_has_mr = true, 
+ *   minimum_page_bits = 0, 
+ *   has_hotpluggable_cpus = true, 
+ *   ignore_memory_transaction_failures = false, 
+ *   numa_mem_align_shift = 23, 
+ *   valid_cpu_types = 0x0,
+ *   allowed_dynamic_sysbus_devices = 0x555556836db0, 
+ *   auto_enable_numa_with_memhp = true, 
+ *   numa_auto_assign_ram = 0x55555585eed8 <numa_default_auto_assign_ram>, 
+ *   get_hotplug_handler = 0x55555591b5fe <pc_get_hotpug_handler>, 
+ *   cpu_index_to_instance_props = 0x55555591c04d <pc_cpu_index_to_props>, 
+ *   possible_cpu_arch_ids = 0x55555591c1fd <pc_possible_cpu_arch_ids>, 
+ *   get_default_cpu_node_id = 0x55555591c138 <pc_get_default_cpu_node_id>
+ * }
+ */
 #define DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn) \
     static void pc_machine_##suffix##_class_init(ObjectClass *oc, void *data) \
     { \
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 990d6fc..e6362d8 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -191,6 +191,7 @@ enum {
     QEMU_PCIE_EXTCAP_INIT = (1 << QEMU_PCIE_EXTCAP_INIT_BITNR),
 };
 
+/* TypeInfo pci_device_type_info */
 #define TYPE_PCI_DEVICE "pci-device"
 #define PCI_DEVICE(obj) \
      OBJECT_CHECK(PCIDevice, (obj), TYPE_PCI_DEVICE)
@@ -200,6 +201,7 @@ enum {
      OBJECT_GET_CLASS(PCIDeviceClass, (obj), TYPE_PCI_DEVICE)
 
 /* Implemented by devices that can be plugged on PCI Express buses */
+/* TypeInfo pcie_interface_info */
 #define INTERFACE_PCIE_DEVICE "pci-express-device"
 
 /* Implemented by devices that can be plugged on Conventional PCI buses */
@@ -388,10 +390,16 @@ typedef void (*pci_set_irq_fn)(void *opaque, int irq_num, int level);
 typedef int (*pci_map_irq_fn)(PCIDevice *pci_dev, int irq_num);
 typedef PCIINTxRoute (*pci_route_irq_fn)(void *opaque, int pin);
 
+/* TypeInfo pci_bus_info */
 #define TYPE_PCI_BUS "PCI"
 #define PCI_BUS(obj) OBJECT_CHECK(PCIBus, (obj), TYPE_PCI_BUS)
 #define PCI_BUS_CLASS(klass) OBJECT_CLASS_CHECK(PCIBusClass, (klass), TYPE_PCI_BUS)
 #define PCI_BUS_GET_CLASS(obj) OBJECT_GET_CLASS(PCIBusClass, (obj), TYPE_PCI_BUS)
+/*
+ * TypeInfo pcie_bus_info
+ *
+ * TYPE_PCIE_BUS的parent是TYPE_PCI_BUS
+ */
 #define TYPE_PCIE_BUS "PCIE"
 
 bool pci_bus_is_express(PCIBus *bus);
diff --git a/include/hw/pci/pci_bus.h b/include/hw/pci/pci_bus.h
index b7da8f5..72ba5ac 100644
--- a/include/hw/pci/pci_bus.h
+++ b/include/hw/pci/pci_bus.h
@@ -28,6 +28,7 @@ struct PCIBus {
     pci_map_irq_fn map_irq;
     pci_route_irq_fn route_intx_to_irq;
     void *irq_opaque;
+    /* 挂载着这个pci bus的所有device */
     PCIDevice *devices[PCI_SLOT_MAX * PCI_FUNC_MAX];
     PCIDevice *parent_dev;
     MemoryRegion *address_space_mem;
diff --git a/include/hw/pci/pci_host.h b/include/hw/pci/pci_host.h
index ba31595..d48abbc 100644
--- a/include/hw/pci/pci_host.h
+++ b/include/hw/pci/pci_host.h
@@ -30,6 +30,7 @@
 
 #include "hw/sysbus.h"
 
+/* TypeInfo pci_host_type_info */
 #define TYPE_PCI_HOST_BRIDGE "pci-host-bridge"
 #define PCI_HOST_BRIDGE(obj) \
     OBJECT_CHECK(PCIHostState, (obj), TYPE_PCI_HOST_BRIDGE)
diff --git a/include/hw/qdev-core.h b/include/hw/qdev-core.h
index f1fd0f8..081ccb2 100644
--- a/include/hw/qdev-core.h
+++ b/include/hw/qdev-core.h
@@ -11,6 +11,7 @@ enum {
     DEV_NVECTORS_UNSPECIFIED = -1,
 };
 
+/* TypeInfo device_type_info: hw/core/qdev.c */
 #define TYPE_DEVICE "device"
 #define DEVICE(obj) OBJECT_CHECK(DeviceState, (obj), TYPE_DEVICE)
 #define DEVICE_CLASS(klass) OBJECT_CLASS_CHECK(DeviceClass, (klass), TYPE_DEVICE)
@@ -106,7 +107,15 @@ typedef struct DeviceClass {
     bool hotpluggable;
 
     /* callbacks */
+    /*
+     * called only by:
+     *   - hw/core/qdev.c|1310| <<device_reset>> klass->reset(dev);
+     */
     DeviceReset reset;
+    /*
+     * called by:
+     *   - hw/core/qdev.c|860| <<device_set_realized>> dc->realize(dev, &local_err);
+     */
     DeviceRealize realize;
     DeviceUnrealize unrealize;
 
@@ -159,6 +168,7 @@ struct DeviceListener {
     QTAILQ_ENTRY(DeviceListener) link;
 };
 
+/* TypeInfo bus_info */
 #define TYPE_BUS "bus"
 #define BUS(obj) OBJECT_CHECK(BusState, (obj), TYPE_BUS)
 #define BUS_CLASS(klass) OBJECT_CLASS_CHECK(BusClass, (klass), TYPE_BUS)
@@ -177,6 +187,10 @@ struct BusClass {
      */
     char *(*get_fw_dev_path)(DeviceState *dev);
     void (*reset)(BusState *bus);
+    /*
+     * called by:
+     *   - hw/core/bus.c|193| <<bus_set_realized>> bc->realize(bus, &local_err);
+     */
     BusRealize realize;
     BusUnrealize unrealize;
 
diff --git a/include/hw/qdev-properties.h b/include/hw/qdev-properties.h
index 4f60cc8..566ee57 100644
--- a/include/hw/qdev-properties.h
+++ b/include/hw/qdev-properties.h
@@ -70,6 +70,25 @@ extern const PropertyInfo qdev_prop_off_auto_pcibar;
         .defval.u  = (bool)_defval,                              \
         }
 
+/*
+ * 一个例子:
+ *   _name   = "num_queues"
+ *   _state  = NvmeCtrl
+ *   _field  = num_queues
+ *   _defval = 64
+ *   _prop   = qdev_prop_uint32
+ *   _type   = uint32_t
+ *
+ * 一个virtblk的例子: DEFINE_PROP_UINT16("num-queues", VirtIOBlock, conf.num_queues, 1),
+ *   _name   = "num_queues"
+ *   _state  = VirtIOBlock
+ *   _field  = conf.num_queues
+ *   _defval = 1
+ *   _prop   = qdev_prop_uint16
+ *   _type   = uint16_t
+ *
+ * 定义了一个struct Property
+ */
 #define DEFINE_PROP_UNSIGNED(_name, _state, _field, _defval, _prop, _type) { \
         .name      = (_name),                                           \
         .info      = &(_prop),                                          \
@@ -144,6 +163,34 @@ extern const PropertyInfo qdev_prop_off_auto_pcibar;
         .arrayoffset = offsetof(_state, _arrayfield),                   \
         }
 
+/*
+ * virtio block iothread的例子:
+ * 1904     DEFINE_PROP_LINK("iothread", VirtIOBlock, conf.iothread, TYPE_IOTHREAD,
+ * 1905                      IOThread *),
+ *
+ *   .name = "iothread",
+ *   .info = &(qdev_prop_link),
+ *   .offset = offsetof(VirtIOBlock, conf.iothread)
+ *       + type_check(IOThread *, typeof_field(VirtIOBlock, conf.iothread)),
+ *   .link_type = TYPE_IOTHREAD,
+ *
+ * (gdb) p *prop
+ * $3 = {
+ *   name = 0x555555d929bd "iothread", 
+ *   info = 0x5555562b3b00 <qdev_prop_link>, 
+ *   offset = 488, 
+ *   bitnr = 0 '\000', 
+ *   set_default = false, 
+ *   defval = {
+ *     i = 0, 
+ *     u = 0
+ *   }, 
+ *   arrayoffset = 0, 
+ *   arrayinfo = 0x0, 
+ *   arrayfieldsize = 0, 
+ *   link_type = 0x555555d929bd "iothread"
+ * }
+ */
 #define DEFINE_PROP_LINK(_name, _state, _field, _type, _ptr_type) {     \
         .name = (_name),                                                \
         .info = &(qdev_prop_link),                                      \
@@ -156,6 +203,10 @@ extern const PropertyInfo qdev_prop_off_auto_pcibar;
     DEFINE_PROP_UNSIGNED(_n, _s, _f, _d, qdev_prop_uint8, uint8_t)
 #define DEFINE_PROP_UINT16(_n, _s, _f, _d)                      \
     DEFINE_PROP_UNSIGNED(_n, _s, _f, _d, qdev_prop_uint16, uint16_t)
+/*
+ * 一个例子:
+ *   DEFINE_PROP_UINT32("num_queues", NvmeCtrl, num_queues, 64),
+ */
 #define DEFINE_PROP_UINT32(_n, _s, _f, _d)                      \
     DEFINE_PROP_UNSIGNED(_n, _s, _f, _d, qdev_prop_uint32, uint32_t)
 #define DEFINE_PROP_INT32(_n, _s, _f, _d)                      \
diff --git a/include/hw/sysbus.h b/include/hw/sysbus.h
index 0b59a3b..71e00ab 100644
--- a/include/hw/sysbus.h
+++ b/include/hw/sysbus.h
@@ -14,6 +14,7 @@
 
 typedef struct SysBusDevice SysBusDevice;
 
+/* TypeInfo sysbus_device_type_info */
 #define TYPE_SYS_BUS_DEVICE "sys-bus-device"
 #define SYS_BUS_DEVICE(obj) \
      OBJECT_CHECK(SysBusDevice, (obj), TYPE_SYS_BUS_DEVICE)
diff --git a/include/hw/virtio/virtio-blk.h b/include/hw/virtio/virtio-blk.h
index 5117431..0ce69ff 100644
--- a/include/hw/virtio/virtio-blk.h
+++ b/include/hw/virtio/virtio-blk.h
@@ -20,6 +20,7 @@
 #include "sysemu/iothread.h"
 #include "sysemu/block-backend.h"
 
+/* TypeInfo virtio_blk_info */
 #define TYPE_VIRTIO_BLK "virtio-blk-device"
 #define VIRTIO_BLK(obj) \
         OBJECT_CHECK(VirtIOBlock, (obj), TYPE_VIRTIO_BLK)
diff --git a/include/hw/virtio/virtio-bus.h b/include/hw/virtio/virtio-bus.h
index 7fec9dc..bbc85fe 100644
--- a/include/hw/virtio/virtio-bus.h
+++ b/include/hw/virtio/virtio-bus.h
@@ -29,6 +29,7 @@
 #include "sysemu/sysemu.h"
 #include "hw/virtio/virtio.h"
 
+/* TypeInfo virtio_bus_info */
 #define TYPE_VIRTIO_BUS "virtio-bus"
 #define VIRTIO_BUS_GET_CLASS(obj) \
         OBJECT_GET_CLASS(VirtioBusClass, obj, TYPE_VIRTIO_BUS)
@@ -41,6 +42,14 @@ typedef struct VirtioBusState VirtioBusState;
 typedef struct VirtioBusClass {
     /* This is what a VirtioBus must implement */
     BusClass parent;
+    /*  
+     * notify设置的地方:
+     *   - hw/virtio/virtio-pci.c|2891| <<virtio_pci_bus_class_init>> k->notify = virtio_pci_notify;
+     *   - hw/virtio/virtio-mmio.c|509| <<virtio_mmio_bus_class_init>> k->notify = virtio_mmio_update_irq;
+     *
+     * notify调用的地方:
+     *   - hw/virtio/virtio.c|1562| <<virtio_notify_vector>> k->notify(qbus->parent, vector);
+     */
     void (*notify)(DeviceState *d, uint16_t vector);
     void (*save_config)(DeviceState *d, QEMUFile *f);
     void (*save_queue)(DeviceState *d, int n, QEMUFile *f);
@@ -99,6 +108,13 @@ struct VirtioBusState {
     /*
      * Set if ioeventfd has been started.
      */
+    /*
+     * 设置的地方:
+     *   - hw/virtio/virtio-bus.c|223| <<virtio_bus_grab_ioeventfd>> bus->ioeventfd_started = true;
+     *   - hw/virtio/virtio-bus.c|234| <<virtio_bus_release_ioeventfd>> bus->ioeventfd_started = false;
+     *   - hw/virtio/virtio-bus.c|296| <<virtio_bus_start_ioeventfd>> bus->ioeventfd_started = true;
+     *   - hw/virtio/virtio-bus.c|315| <<virtio_bus_stop_ioeventfd>> bus->ioeventfd_started = false;
+     */
     bool ioeventfd_started;
 
     /*
diff --git a/include/hw/virtio/virtio.h b/include/hw/virtio/virtio.h
index 9c1fa07..c35aa5a 100644
--- a/include/hw/virtio/virtio.h
+++ b/include/hw/virtio/virtio.h
@@ -56,6 +56,7 @@ typedef struct VirtQueueElement
 
 #define VIRTIO_NO_VECTOR 0xffff
 
+/* TypeInfo virtio_device_info */
 #define TYPE_VIRTIO_DEVICE "virtio-device"
 #define VIRTIO_DEVICE_GET_CLASS(obj) \
         OBJECT_GET_CLASS(VirtioDeviceClass, obj, TYPE_VIRTIO_DEVICE)
@@ -80,7 +81,15 @@ struct VirtIODevice
     uint64_t guest_features;
     uint64_t host_features;
     uint64_t backend_features;
+    /*
+     * 参考virtio_init()
+     * 一个例子是sizeof(virtio_blk_config)
+     */
     size_t config_len;
+    /*
+     * 参考virtio_init()
+     * 一个例子是virtio_blk_config
+     */
     void *config;
     uint16_t config_vector;
     uint32_t generation;
@@ -104,17 +113,136 @@ typedef struct VirtioDeviceClass {
     /*< public >*/
 
     /* This is what a VirtioDevice must implement */
+    /*
+     * 设置的地方:
+     *   - hw/block/virtio-blk.c|1435| <<virtio_blk_class_init>> vdc->realize = virtio_blk_device_realize;
+     *   - hw/scsi/virtio-scsi.c|971| <<virtio_scsi_class_init>> vdc->realize = virtio_scsi_device_realize;
+     *   - hw/virtio/virtio-balloon.c|531| <<virtio_balloon_class_init>> vdc->realize = virtio_balloon_device_realize;
+     *   - hw/9pfs/virtio-9p-device.c|246| <<virtio_9p_class_init>> vdc->realize = virtio_9p_device_realize;
+     *   - hw/char/virtio-serial-bus.c|1173| <<virtio_serial_class_init>> vdc->realize = virtio_serial_device_realize;
+     *   - hw/display/virtio-gpu.c|1366| <<virtio_gpu_class_init>> vdc->realize = virtio_gpu_device_realize;
+     *   - hw/input/virtio-input.c|317| <<virtio_input_class_init>> vdc->realize = virtio_input_device_realize;
+     *   - hw/net/virtio-net.c|2212| <<virtio_net_class_init>> vdc->realize = virtio_net_device_realize;
+     *   - hw/virtio/vhost-vsock.c|397| <<vhost_vsock_class_init>> vdc->realize = vhost_vsock_device_realize;
+     *   - hw/virtio/virtio-crypto.c|958| <<virtio_crypto_class_init>> vdc->realize = virtio_crypto_device_realize;
+     *   - hw/block/vhost-user-blk.c|351| <<vhost_user_blk_class_init>> vdc->realize = vhost_user_blk_device_realize;
+     *   - hw/scsi/vhost-scsi.c|252| <<vhost_scsi_class_init>> vdc->realize = vhost_scsi_realize;
+     *   - hw/scsi/vhost-user-scsi.c|188| <<vhost_user_scsi_class_init>> vdc->realize = vhost_user_scsi_realize;
+     *   - hw/virtio/vhost-vsock.c|397| <<vhost_vsock_class_init>> vdc->realize = vhost_vsock_device_realize;
+     *   - hw/virtio/virtio-rng.c|274| <<virtio_rng_class_init>> vdc->realize = virtio_rng_device_realize;
+     *
+     * 调用的地方:
+     *   - hw/virtio/virtio.c|2612| <<virtio_device_realize>> vdc->realize(dev, &err);
+     */
     DeviceRealize realize;
+    /*
+     * called by:
+     *   - hw/virtio/virtio.c|2622| <<virtio_device_realize>> vdc->unrealize(dev, NULL);
+     *   - hw/virtio/virtio.c|2639| <<virtio_device_unrealize>> vdc->unrealize(dev, &err);
+     */
     DeviceUnrealize unrealize;
+    /*
+     * called only by:
+     *   - hw/virtio/virtio-bus.c|99| <<virtio_bus_device_plugged>> vdev->host_features = vdc->get_features(vdev, vdev->host_features,
+     */
     uint64_t (*get_features)(VirtIODevice *vdev,
                              uint64_t requested_features,
                              Error **errp);
     uint64_t (*bad_features)(VirtIODevice *vdev);
     void (*set_features)(VirtIODevice *vdev, uint64_t val);
+    /*
+     * 目前没有设置的
+     * 只被如下调用:
+     *   - hw/virtio/virtio.c|1609| <<virtio_validate_features>> return k->validate_features(vdev);
+     */
     int (*validate_features)(VirtIODevice *vdev);
+    /*
+     * 设置get_config的地方:
+     *   - hw/block/virtio-blk.c|1452| <<virtio_blk_class_init>> vdc->get_config = virtio_blk_update_config;
+     *   - hw/net/virtio-net.c|2214| <<virtio_net_class_init>> vdc->get_config = virtio_net_get_config;
+     *   - hw/scsi/virtio-scsi.c|958| <<virtio_scsi_common_class_init>> vdc->get_config = virtio_scsi_get_config;
+     *   - hw/virtio/virtio-balloon.c|534| <<virtio_balloon_class_init>> vdc->get_config = virtio_balloon_get_config;
+     *   - hw/9pfs/virtio-9p-device.c|249| <<virtio_9p_class_init>> vdc->get_config = virtio_9p_get_config;
+     *   - hw/block/vhost-user-blk.c|353| <<vhost_user_blk_class_init>> vdc->get_config = vhost_user_blk_update_config;
+     *   - hw/char/virtio-serial-bus.c|1176| <<virtio_serial_class_init>> vdc->get_config = get_config;
+     *   - hw/display/virtio-gpu.c|1368| <<virtio_gpu_class_init>> vdc->get_config = virtio_gpu_get_config;
+     *   - hw/input/virtio-input.c|319| <<virtio_input_class_init>> vdc->get_config = virtio_input_get_config;
+     *   - hw/virtio/vhost-vsock.c|400| <<vhost_vsock_class_init>> vdc->get_config = vhost_vsock_get_config;
+     *   - hw/virtio/virtio-crypto.c|960| <<virtio_crypto_class_init>> vdc->get_config = virtio_crypto_get_config;
+     *
+     * 调用get_config的地方:
+     *   - hw/virtio/virtio-bus.c|195| <<virtio_bus_get_vdev_config>> k->get_config(vdev, config);
+     *   - hw/virtio/virtio.c|1238| <<virtio_config_readb>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1253| <<virtio_config_readw>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1268| <<virtio_config_readl>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1331| <<virtio_config_modern_readb>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1346| <<virtio_config_modern_readw>> k->get_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1361| <<virtio_config_modern_readl>> k->get_config(vdev, vdev->config);
+     */
     void (*get_config)(VirtIODevice *vdev, uint8_t *config);
+    /*
+     * 设置set_config的地方:
+     *   - hw/block/virtio-blk.c|1463| <<virtio_blk_class_init>> vdc->set_config = virtio_blk_set_config;
+     *   - hw/net/virtio-net.c|2215| <<virtio_net_class_init>> vdc->set_config = virtio_net_set_config;
+     *   - hw/scsi/virtio-scsi.c|973| <<virtio_scsi_class_init>> vdc->set_config = virtio_scsi_set_config;
+     *   - hw/virtio/virtio-balloon.c|535| <<virtio_balloon_class_init>> vdc->set_config = virtio_balloon_set_config;
+     *   - hw/char/virtio-serial-bus.c|1177| <<virtio_serial_class_init>> vdc->set_config = set_config;
+     *   - hw/block/vhost-user-blk.c|354| <<vhost_user_blk_class_init>> vdc->set_config = vhost_user_blk_set_config;
+     *   - hw/display/virtio-gpu.c|1369| <<virtio_gpu_class_init>> vdc->set_config = virtio_gpu_set_config;
+     *   - hw/input/virtio-input.c|320| <<virtio_input_class_init>> vdc->set_config = virtio_input_set_config;
+     *   - hw/scsi/vhost-scsi.c|255| <<vhost_scsi_class_init>> vdc->set_config = vhost_scsi_common_set_config;
+     *   - hw/scsi/vhost-user-scsi.c|191| <<vhost_user_scsi_class_init>> vdc->set_config = vhost_scsi_common_set_config;
+     *
+     * 调用set_config的地方:
+     * called by:
+     *   - hw/virtio/virtio-bus.c|208| <<virtio_bus_set_vdev_config>> k->set_config(vdev, config);
+     *   - hw/virtio/virtio.c|1286| <<virtio_config_writeb>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1302| <<virtio_config_writew>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1318| <<virtio_config_writel>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1380| <<virtio_config_modern_writeb>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1397| <<virtio_config_modern_writew>> k->set_config(vdev, vdev->config);
+     *   - hw/virtio/virtio.c|1414| <<virtio_config_modern_writel>> k->set_config(vdev, vdev->config);
+     */
     void (*set_config)(VirtIODevice *vdev, const uint8_t *config);
+    /*
+     * called only by:
+     *   - hw/virtio/virtio.c|1201| <<virtio_reset>> k->reset(vdev);
+     *
+     * 在以下被设置:
+     *   - hw/block/virtio-blk.c|1490| <<virtio_blk_class_init>> vdc->reset = virtio_blk_reset;
+     *   - hw/net/virtio-net.c|2219| <<virtio_net_class_init>> vdc->reset = virtio_net_reset;
+     *   - hw/scsi/virtio-scsi.c|975| <<virtio_scsi_class_init>> vdc->reset = virtio_scsi_reset;
+     *   - hw/virtio/virtio-balloon.c|533| <<virtio_balloon_class_init>> vdc->reset = virtio_balloon_device_reset;
+     *   - hw/virtio/virtio-crypto.c|962| <<virtio_crypto_class_init>> vdc->reset = virtio_crypto_reset;
+     *   - hw/char/virtio-serial-bus.c|1179| <<virtio_serial_class_init>> vdc->reset = vser_reset;
+     *   - hw/display/virtio-gpu.c|1373| <<virtio_gpu_class_init>> vdc->reset = virtio_gpu_reset;
+     *   - hw/9pfs/virtio-9p-device.c|250| <<virtio_9p_class_init>> vdc->reset = virtio_9p_reset;
+     *   - hw/input/virtio-input.c|323| <<virtio_input_class_init>> vdc->reset = virtio_input_reset;
+     *
+     * 在以下被调用:
+     *   - hw/virtio/virtio.c|1761| <<virtio_reset>> k->reset(vdev);
+     */
     void (*reset)(VirtIODevice *vdev);
+    /*
+     * called only by:
+     *   - hw/virtio/virtio.c|1158| <<virtio_set_status>> k->set_status(vdev, val);
+     *
+     * 设置的地方:
+     *   - hw/block/virtio-blk.c|1469| <<virtio_blk_class_init>> vdc->set_status = virtio_blk_set_status;
+     *   - hw/block/vhost-user-blk.c|356| <<vhost_user_blk_class_init>> vdc->set_status = vhost_user_blk_set_status;
+     *   - hw/char/virtio-serial-bus.c|1178| <<virtio_serial_class_init>> vdc->set_status = set_status;
+     *   - hw/input/virtio-input.c|322| <<virtio_input_class_init>> vdc->set_status = virtio_input_set_status;
+     *   - hw/net/virtio-net.c|2220| <<virtio_net_class_init>> vdc->set_status = virtio_net_set_status;
+     *   - hw/scsi/vhost-scsi.c|256| <<vhost_scsi_class_init>> vdc->set_status = vhost_scsi_set_status;
+     *   - hw/scsi/vhost-user-scsi.c|192| <<vhost_user_scsi_class_init>> vdc->set_status = vhost_user_scsi_set_status;
+     *   - hw/virtio/vhost-vsock.c|401| <<vhost_vsock_class_init>> vdc->set_status = vhost_vsock_set_status;
+     *   - hw/virtio/virtio-balloon.c|537| <<virtio_balloon_class_init>> vdc->set_status = virtio_balloon_set_status;
+     *   - hw/virtio/virtio-crypto.c|963| <<virtio_crypto_class_init>> vdc->set_status = virtio_crypto_set_status;
+     *   - hw/virtio/virtio-rng.c|277| <<virtio_rng_class_init>> vdc->set_status = virtio_rng_set_status;
+     *
+     * 唯一调用的地方:
+     *   - hw/virtio/virtio.c|1652| <<virtio_set_status>> k->set_status(vdev, val);
+     */
     void (*set_status)(VirtIODevice *vdev, uint8_t val);
     /* For transitional devices, this is a bitmap of features
      * that are only exposed on the legacy interface but not
@@ -133,12 +261,38 @@ typedef struct VirtioDeviceClass {
      * must mask in frontend instead.
      */
     void (*guest_notifier_mask)(VirtIODevice *vdev, int n, bool mask);
+    /*
+     * called only by:
+     *   - hw/virtio/virtio-bus.c|281| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+     *
+     * used by:
+     *   - hw/block/virtio-blk.c|1111| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_data_plane_start; --> block用
+     *   - hw/scsi/virtio-scsi.c|976| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+     *   - hw/virtio/virtio.c|2799| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl; --> 网络用
+     */
     int (*start_ioeventfd)(VirtIODevice *vdev);
+    /*
+     * called only by:
+     *   - hw/virtio/virtio-bus.c|304| <<virtio_bus_stop_ioeventfd>> vdc->stop_ioeventfd(vdev);
+     *
+     * used by:
+     *   - hw/block/virtio-blk.c|1112| <<virtio_blk_class_init>> vdc->stop_ioeventfd = virtio_blk_data_plane_stop;
+     *   - hw/scsi/virtio-scsi.c|977| <<virtio_scsi_class_init>> vdc->stop_ioeventfd = virtio_scsi_dataplane_stop;
+     *   - hw/virtio/virtio.c|2800| <<virtio_device_class_init>> vdc->stop_ioeventfd = virtio_device_stop_ioeventfd_impl;
+     */
     void (*stop_ioeventfd)(VirtIODevice *vdev);
     /* Saving and loading of a device; trying to deprecate save/load
      * use vmsd for new devices.
      */
+    /*
+     * called only by:
+     *   - hw/virtio/virtio.c|1957| <<virtio_save>> vdc->save(vdev, f);
+     */
     void (*save)(VirtIODevice *vdev, QEMUFile *f);
+    /*
+     * called only by:
+     *   - hw/virtio/virtio.c|2106| <<virtio_load>> ret = vdc->load(vdev, f, version_id);
+     */
     int (*load)(VirtIODevice *vdev, QEMUFile *f, int version_id);
     const VMStateDescription *vmsd;
 } VirtioDeviceClass;
@@ -312,12 +466,18 @@ static inline bool virtio_has_feature(uint64_t features, unsigned int fbit)
     return !!(features & (1ULL << fbit));
 }
 
+/*
+ * 查看VirtIODevice->guest_features的对应bit是否设置了
+ */
 static inline bool virtio_vdev_has_feature(VirtIODevice *vdev,
                                            unsigned int fbit)
 {
     return virtio_has_feature(vdev->guest_features, fbit);
 }
 
+/*
+ * 查看VirtIODevice->host_features的对应bit是否设置了
+ */
 static inline bool virtio_host_has_feature(VirtIODevice *vdev,
                                            unsigned int fbit)
 {
diff --git a/include/qapi/qmp/qobject.h b/include/qapi/qmp/qobject.h
index fcfd549..5af95ff 100644
--- a/include/qapi/qmp/qobject.h
+++ b/include/qapi/qmp/qobject.h
@@ -41,6 +41,9 @@ struct QObjectBase_ {
 };
 
 /* this struct must have no other members than base */
+/*
+ * 作为root存储在QObjectInputVisitor
+ */
 struct QObject {
     struct QObjectBase_ base;
 };
diff --git a/include/qemu/module.h b/include/qemu/module.h
index 54300ab..dffb4af 100644
--- a/include/qemu/module.h
+++ b/include/qemu/module.h
@@ -39,6 +39,16 @@ static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \
 }
 #endif
 
+/*
+ * 所有注册的module_init_type在以下调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * module_call_init()遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
+
 typedef enum {
     MODULE_INIT_BLOCK,
     MODULE_INIT_OPTS,
@@ -47,8 +57,16 @@ typedef enum {
     MODULE_INIT_MAX
 } module_init_type;
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_BLOCK)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_BLOCK]
+ */
 #define block_init(function) module_init(function, MODULE_INIT_BLOCK)
 #define opts_init(function) module_init(function, MODULE_INIT_OPTS)
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 #define type_init(function) module_init(function, MODULE_INIT_QOM)
 #define trace_init(function) module_init(function, MODULE_INIT_TRACE)
 
diff --git a/include/qom/object.h b/include/qom/object.h
index f0b0bf3..cc11938 100644
--- a/include/qom/object.h
+++ b/include/qom/object.h
@@ -17,6 +17,12 @@
 #include "qapi/qapi-builtin-types.h"
 #include "qemu/queue.h"
 
+/*
+ * 核心函数:
+ *   - type_initialize()
+ *   - object_initialize_with_type()
+ */
+
 struct TypeImpl;
 typedef struct TypeImpl *Type;
 
@@ -28,6 +34,7 @@ typedef struct TypeInfo TypeInfo;
 typedef struct InterfaceClass InterfaceClass;
 typedef struct InterfaceInfo InterfaceInfo;
 
+/* TypeInfo object_info */
 #define TYPE_OBJECT "object"
 
 /**
@@ -388,10 +395,28 @@ typedef void (ObjectFree)(void *obj);
  * The base for all classes.  The only thing that #ObjectClass contains is an
  * integer type handle.
  */
+/*
+ * 所有class_size()里的祖先都是ObjectClass
+ *
+ * 关注: type_initialize()
+ */
 struct ObjectClass
 {
     /*< private >*/
-    Type type;
+    Type type;  // 定义typedef struct TypeImpl *Type;
+    /*
+     * 插入新元素的地方:
+     *   - qom/object.c|472| <<type_initialize_interface>> ti->class->interfaces = g_slist_append(ti->class->interfaces,
+     *
+     * 用到的地方:
+     *   - qom/object.c|486| <<type_initialize_interface>> ti->class->interfaces = g_slist_append(ti->class->interfaces,
+     *   - qom/object.c|615| <<type_initialize>> ti->class->interfaces = NULL;
+     *   - qom/object.c|623| <<type_initialize>> for (e = parent->class->interfaces; e; e = e->next) {
+     *   - qom/object.c|646| <<type_initialize>> for (e = ti->class->interfaces; e; e = e->next) {
+     *   - qom/object.c|1199| <<object_class_dynamic_cast>> if (type->class->interfaces &&
+     *   - qom/object.c|1204| <<object_class_dynamic_cast>> for (i = class->interfaces; i; i = i->next) {
+     *   - qom/object.c|1245| <<object_class_dynamic_cast_assert>> if (!class || !class->interfaces) {
+     */
     GSList *interfaces;
 
     const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE];
@@ -399,6 +424,11 @@ struct ObjectClass
 
     ObjectUnparent *unparent;
 
+    /*
+     * 在以下分配:
+     *   - qom/object.c|550| <<type_initialize>> ti->class->properties = g_hash_table_new_full(
+     *   - qom/object.c|586| <<type_initialize>> ti->class->properties = g_hash_table_new_full(
+     */
     GHashTable *properties;
 };
 
@@ -414,11 +444,22 @@ struct ObjectClass
  * first member.  This allows identification of the real type of the object at
  * run time.
  */
+/*
+ * 关注object_initialize_with_type()
+ */
 struct Object
 {
     /*< private >*/
+    /*
+     * 初始化:
+     *   - qom/object.c|665| <<object_initialize_with_type>> obj->class = type->class;
+     */
     ObjectClass *class;
     ObjectFree *free;
+    /*
+     * 在以下初始化:
+     *   - qom/object.c|680| <<object_initialize_with_type>> obj->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
+     */
     GHashTable *properties;
     uint32_t ref;
     Object *parent;
@@ -574,6 +615,7 @@ struct InterfaceClass
     Type interface_type;
 };
 
+/* TypeInfo interface_info */
 #define TYPE_INTERFACE "interface"
 
 /**
@@ -868,6 +910,10 @@ void type_register_static_array(const TypeInfo *infos, int nr_infos);
  * @type_array should be static constant that exists for the life time
  * that the type is registered.
  */
+/*
+ * type_register_static_array()
+ *     为nr_infos个: 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 #define DEFINE_TYPES(type_array)                                            \
 static void do_qemu_init_ ## type_array(void)                               \
 {                                                                           \
diff --git a/include/standard-headers/linux/virtio_ring.h b/include/standard-headers/linux/virtio_ring.h
index d26e72b..4839e32 100644
--- a/include/standard-headers/linux/virtio_ring.h
+++ b/include/standard-headers/linux/virtio_ring.h
@@ -58,6 +58,10 @@
  * at the end of the avail ring. Host should ignore the avail->flags field. */
 /* The Host publishes the avail index for which it expects a kick
  * at the end of the used ring. Guest should ignore the used->flags field. */
+/*
+ * 后端用了used ring的最后一个元素,告诉前端驱动后端处理到哪个avail ring上的元素了,
+ * 同时前端使用avail ring的最后一个元素告诉后端,处理到那个used ring了
+ */
 #define VIRTIO_RING_F_EVENT_IDX		29
 
 /* Virtio ring descriptors: 16 bytes.  These can chain together via "next". */
diff --git a/include/sysemu/accel.h b/include/sysemu/accel.h
index 637358f..560b596 100644
--- a/include/sysemu/accel.h
+++ b/include/sysemu/accel.h
@@ -52,6 +52,7 @@ typedef struct AccelClass {
     GlobalProperty *global_props;
 } AccelClass;
 
+/* TypeInfo accel_type */
 #define TYPE_ACCEL "accel"
 
 #define ACCEL_CLASS_SUFFIX  "-" TYPE_ACCEL
diff --git a/include/sysemu/iothread.h b/include/sysemu/iothread.h
index 8a7ac2c..f66b89e 100644
--- a/include/sysemu/iothread.h
+++ b/include/sysemu/iothread.h
@@ -17,6 +17,7 @@
 #include "block/aio.h"
 #include "qemu/thread.h"
 
+/* TypeInfo iothread_info */
 #define TYPE_IOTHREAD "iothread"
 
 typedef struct {
@@ -24,6 +25,19 @@ typedef struct {
 
     QemuThread thread;
     AioContext *ctx;
+    /*
+     * 使用到的地方:
+     *   - iothread.c|80| <<iothread_run>> if (atomic_read(&iothread->worker_context)) {
+     *   - iothread.c|83| <<iothread_run>> g_main_context_push_thread_default(iothread->worker_context);
+     *   - iothread.c|85| <<iothread_run>> g_main_loop_new(iothread->worker_context, TRUE);
+     *   - iothread.c|92| <<iothread_run>> g_main_context_pop_thread_default(iothread->worker_context);
+     *   - iothread.c|203| <<iothread_instance_finalize>> if (iothread->worker_context) {
+     *   - iothread.c|204| <<iothread_instance_finalize>> g_main_context_unref(iothread->worker_context);
+     *   - iothread.c|205| <<iothread_instance_finalize>> iothread->worker_context = NULL;
+     *   - iothread.c|461| <<iothread_g_main_context_init>> iothread->worker_context = g_main_context_new();
+     *   - iothread.c|465| <<iothread_g_main_context_init>> g_source_attach(source, iothread->worker_context);
+     *   - iothread.c|497| <<iothread_get_g_main_context>> return iothread->worker_context;
+     */
     GMainContext *worker_context;
     GMainLoop *main_loop;
     GOnce once;
diff --git a/include/sysemu/kvm_int.h b/include/sysemu/kvm_int.h
index f838412..7be68df 100644
--- a/include/sysemu/kvm_int.h
+++ b/include/sysemu/kvm_int.h
@@ -29,6 +29,7 @@ typedef struct KVMMemoryListener {
     int as_id;
 } KVMMemoryListener;
 
+/* TypeInfo kvm_accel_type */
 #define TYPE_KVM_ACCEL ACCEL_CLASS_NAME("kvm")
 
 #define KVM_STATE(obj) \
diff --git a/iothread.c b/iothread.c
index aff1281..6a297ea 100644
--- a/iothread.c
+++ b/iothread.c
@@ -48,6 +48,13 @@ AioContext *qemu_get_current_aio_context(void)
     return my_iothread ? my_iothread->ctx : qemu_get_aio_context();
 }
 
+/*
+ * iothread的主函数!!!!----> 其实更是aio_poll()
+ *
+ * 只被iothread_complete()一个地方调用:
+ * 184     qemu_thread_create(&iothread->thread, thread_name, iothread_run,
+ * 185                        iothread, QEMU_THREAD_JOINABLE);
+ */
 static void *iothread_run(void *opaque)
 {
     IOThread *iothread = opaque;
@@ -57,12 +64,22 @@ static void *iothread_run(void *opaque)
     my_iothread = iothread;
     qemu_mutex_lock(&iothread->init_done_lock);
     iothread->thread_id = qemu_get_thread_id();
+    /*
+     * 使用到的地方:
+     *   - iothread.c|67| <<iothread_run>> qemu_cond_signal(&iothread->init_done_cond);
+     *   - iothread.c|190| <<iothread_instance_finalize>> qemu_cond_destroy(&iothread->init_done_cond);
+     *   - iothread.c|237| <<iothread_complete>> qemu_cond_init(&iothread->init_done_cond);
+     *   - iothread.c|253| <<iothread_complete>> qemu_cond_wait(&iothread->init_done_cond,
+     */
     qemu_cond_signal(&iothread->init_done_cond);
     qemu_mutex_unlock(&iothread->init_done_lock);
 
     while (iothread->running) {
         aio_poll(iothread->ctx, true);
 
+	/*
+	 * 在virtio block iothread测试中, worker_context和main_loop都是NULL
+	 */
         if (atomic_read(&iothread->worker_context)) {
             GMainLoop *loop;
 
@@ -84,10 +101,17 @@ static void *iothread_run(void *opaque)
 }
 
 /* Runs in iothread_run() thread */
+/*
+ * used by only:
+ *   - iothread.c|131| <<iothread_stop>> aio_bh_schedule_oneshot(iothread->ctx, iothread_stop_bh, iothread);
+ */
 static void iothread_stop_bh(void *opaque)
 {
     IOThread *iothread = opaque;
 
+    /*
+     * 这样iothread_run()中的while循环就要退出了
+     */
     iothread->running = false; /* stop iothread_run() */
 
     if (iothread->main_loop) {
@@ -95,16 +119,43 @@ static void iothread_stop_bh(void *opaque)
     }
 }
 
+/*
+ * called by:
+ *   - iothread.c|171| <<iothread_instance_finalize>> iothread_stop(iothread);
+ *   - monitor.c|4712| <<monitor_cleanup>> iothread_stop(mon_iothread);
+ */
 void iothread_stop(IOThread *iothread)
 {
     if (!iothread->ctx || iothread->stopping) {
         return;
     }
     iothread->stopping = true;
+    /*
+     * 用参数的cb和opaque制作一个QEMUBH,链接到AioContext->first_bh
+     * QEMUBH->deleted设置成1 (执行一次就删除)
+     * 然后根据情况set一下AioContext->notifier
+     */
     aio_bh_schedule_oneshot(iothread->ctx, iothread_stop_bh, iothread);
     qemu_thread_join(&iothread->thread);
 }
 
+/*
+ * virtio block iothread的例子(id是"io1")
+ * (gdb) bt
+ * #0  iothread_instance_init (obj=0x555556894bc0) at iothread.c:110
+ * #1  0x0000555555c7e142 in object_init_with_type (obj=0x555556894bc0, ti=0x5555567c52e0) at qom/object.c:353
+ * #2  0x0000555555c7e305 in object_initialize_with_type (data=0x555556894bc0, size=232, type=0x5555567c52e0) at qom/object.c:384
+ * #3  0x0000555555c7e959 in object_new_with_type (type=0x5555567c52e0) at qom/object.c:546
+ * #4  0x0000555555c7e996 in object_new (typename=0x5555567f3be0 "iothread") at qom/object.c:556
+ * #5  0x0000555555c833d4 in user_creatable_add_type (type=0x5555567f3be0 "iothread", id=0x5555567f3bc0 "io1", qdict=0x555556893ab0, v=0x555556894ad0, errp=0x7fffffffe038) at qom/object_interfaces.c:67
+ * #6  0x0000555555c83681 in user_creatable_add_opts (opts=0x5555567f3b70, errp=0x7fffffffe038) at qom/object_interfaces.c:131
+ * #7  0x0000555555c8378c in user_creatable_add_opts_foreach (opaque=0x5555559e2303 <object_create_initial>, opts=0x5555567f3b70, errp=0x0) at qom/object_interfaces.c:155
+ * #8  0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b7e20 <qemu_object_opts>, func=0x555555c836fe <user_creatable_add_opts_foreach>, opaque=0x5555559e2303 <object_create_initial>, errp=0x0)
+ *     at util/qemu-option.c:1106
+ * #9  0x00005555559e5aaa in main (argc=16, argv=0x7fffffffe3b8, envp=0x7fffffffe440) at vl.c:4267
+ *
+ * TypeInfo iothread_info.instance_init = iothread_instance_init()
+ */
 static void iothread_instance_init(Object *obj)
 {
     IOThread *iothread = IOTHREAD(obj);
@@ -112,6 +163,34 @@ static void iothread_instance_init(Object *obj)
     iothread->poll_max_ns = IOTHREAD_POLL_MAX_NS_DEFAULT;
 }
 
+/*
+ * (gdb) bt
+ * #0  iothread_instance_finalize (obj=0x55555700ae70) at iothread.c:117
+ * #1  0x0000555555c1e6d1 in object_deinit (obj=0x55555700ae70, type=0x5555565087b0) at qom/object.c:516
+ * #2  0x0000555555c1e743 in object_finalize (data=0x55555700ae70) at qom/object.c:530
+ * #3  0x0000555555c1f6b8 in object_unref (obj=0x55555700ae70) at qom/object.c:978
+ * #4  0x0000555555c20adc in object_finalize_child_property (obj=0x5555565d4750, name=0x55555771db60 "io2", opaque=0x55555700ae70) at qom/object.c:1490
+ * #5  0x0000555555c1e5c0 in object_property_del_child (obj=0x5555565d4750, child=0x55555700ae70, errp=0x0) at qom/object.c:490
+ * #6  0x0000555555c1e6a0 in object_unparent (obj=0x55555700ae70) at qom/object.c:509
+ * #7  0x0000555555c2378d in user_creatable_del (id=0x55555735dfe0 "io2", errp=0x7fffffffcda8) at qom/object_interfaces.c:189
+ * #8  0x00005555559bfe6a in hmp_object_del (mon=0x5555565e7250, qdict=0x555556dafc00) at hmp.c:2447
+ * #9  0x00005555558230ac in handle_hmp_command (mon=0x5555565e7250, cmdline=0x5555565f17fb "io2") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #10 0x0000555555825467 in monitor_command_cb (opaque=0x5555565e7250, cmdline=0x5555565f17f0 "object_del io2", readline_opaque=0x0) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #11 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565f17f0, ch=13) at util/readline.c:393
+ * #12 0x00005555558253ba in monitor_read (opaque=0x5555565e7250, buf=0x7fffffffcf70 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #13 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d34e0, buf=0x7fffffffcf70 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #14 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d34e0, buf=0x7fffffffcf70 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #15 0x0000555555cce691 in fd_chr_read (chan=0x5555565d36f0, cond=G_IO_IN, opaque=0x5555565d34e0) at chardev/char-fd.c:66
+ * #16 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x5555571da3f0, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d34e0) at io/channel-watch.c:84
+ * #17 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #18 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #19 0x0000555555d4f990 in os_host_main_loop_wait (timeout=499000000) at util/main-loop.c:238
+ * #20 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #21 0x00005555559967aa in main_loop () at vl.c:1866
+ * #22 0x000055555599dfbd in main (argc=16, argv=0x7fffffffe3e8, envp=0x7fffffffe470) at vl.c:4644
+ *
+ * TypeInfo iothread_info.instance_finalize = iothread_instance_finalize()
+ */
 static void iothread_instance_finalize(Object *obj)
 {
     IOThread *iothread = IOTHREAD(obj);
@@ -139,6 +218,21 @@ static void iothread_instance_finalize(Object *obj)
     qemu_mutex_destroy(&iothread->init_done_lock);
 }
 
+/*
+ * virtio block iothread的例子(id是"io1")
+ * (gdb) bt
+ * #0  iothread_complete (obj=0x555556894bc0, errp=0x7fffffffdf78) at iothread.c:143
+ * #1  0x0000555555c83212 in user_creatable_complete (obj=0x555556894bc0, errp=0x7fffffffdf78) at qom/object_interfaces.c:24
+ * #2  0x0000555555c834cc in user_creatable_add_type (type=0x5555567f3be0 "iothread", id=0x5555567f3bc0 "io1", qdict=0x555556893ab0, v=0x555556894ad0, errp=0x7fffffffe038) at qom/object_interfaces.c:92
+ * #3  0x0000555555c83681 in user_creatable_add_opts (opts=0x5555567f3b70, errp=0x7fffffffe038) at qom/object_interfaces.c:131
+ * #4  0x0000555555c8378c in user_creatable_add_opts_foreach (opaque=0x5555559e2303 <object_create_initial>, opts=0x5555567f3b70, errp=0x0) at qom/object_interfaces.c:155
+ * #5  0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b7e20 <qemu_object_opts>, func=0x555555c836fe <user_creatable_add_opts_foreach>, opaque=0x5555559e2303 <object_create_initial>, errp=0x0)
+ *     at util/qemu-option.c:1106
+ * #6  0x00005555559e5aaa in main (argc=16, argv=0x7fffffffe3b8, envp=0x7fffffffe440) at vl.c:4267
+ *
+ * used only by:
+ *   - iothread.c|261| <<iothread_class_init>> ucc->complete = iothread_complete;
+ */
 static void iothread_complete(UserCreatable *obj, Error **errp)
 {
     Error *local_error = NULL;
@@ -173,6 +267,10 @@ static void iothread_complete(UserCreatable *obj, Error **errp)
     /* This assumes we are called from a thread with useful CPU affinity for us
      * to inherit.
      */
+    /*
+     * 从该Object的parent的HashTable中寻找指向该Object的type开头是"child<"的并返回
+     * 似乎就是返回parent指向这个Object的prop->name
+     */
     name = object_get_canonical_path_component(OBJECT(obj));
     thread_name = g_strdup_printf("IO %s", name);
     qemu_thread_create(&iothread->thread, thread_name, iothread_run,
@@ -248,9 +346,16 @@ out:
     error_propagate(errp, local_err);
 }
 
+/*
+ * TypeInfo iothread_info.class_init = iothread_class_init()
+ */
 static void iothread_class_init(ObjectClass *klass, void *class_data)
 {
     UserCreatableClass *ucc = USER_CREATABLE_CLASS(klass);
+    /*
+     * called by:
+     *   - qom/object_interfaces.c|24| <<user_creatable_complete>> ucc->complete(uc, errp);
+     */
     ucc->complete = iothread_complete;
 
     object_class_property_add(klass, "poll-max-ns", "int",
@@ -282,9 +387,14 @@ static const TypeInfo iothread_info = {
 
 static void iothread_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&iothread_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(iothread_register_types)
 
 char *iothread_get_id(IOThread *iothread)
@@ -297,6 +407,10 @@ AioContext *iothread_get_aio_context(IOThread *iothread)
     return iothread->ctx;
 }
 
+/*
+ * 只在一处被调用:
+ *   - iothread.c|384| <<qmp_query_iothreads>> object_child_foreach(container, query_one_iothread, &prev);
+ */
 static int query_one_iothread(Object *object, void *opaque)
 {
     IOThreadInfoList ***prev = opaque;
@@ -325,16 +439,35 @@ static int query_one_iothread(Object *object, void *opaque)
     return 0;
 }
 
+/*
+ * 只被以下调用 用来list所有iothread:
+ *   - hmp.c|2535| <<hmp_info_iothreads>> IOThreadInfoList *info_list = qmp_query_iothreads(NULL);
+ */
 IOThreadInfoList *qmp_query_iothreads(Error **errp)
 {
     IOThreadInfoList *head = NULL;
     IOThreadInfoList **prev = &head;
     Object *container = object_get_objects_root();
 
+    /*
+     * (qemu) qom-list /objects
+     * type (string)
+     * io1 (child<iothread>)
+     */
+
+    /*
+     * 遍历的时候object的开头必须是"child<"
+     */
     object_child_foreach(container, query_one_iothread, &prev);
     return head;
 }
 
+/*
+ * called only by:
+ *   - iothread.c|407| <<iothread_get_g_main_context>> g_once(&iothread->once, iothread_g_main_context_init, iothread);
+ *
+ * 在简单的测试中没有被调用
+ */
 static gpointer iothread_g_main_context_init(gpointer opaque)
 {
     AioContext *ctx;
@@ -352,17 +485,46 @@ static gpointer iothread_g_main_context_init(gpointer opaque)
     return NULL;
 }
 
+/*
+ * called by:
+ *   - monitor.c|4534| <<monitor_get_io_context>> return iothread_get_g_main_context(mon_iothread);
+ *   - net/colo-compare.c|762| <<colo_compare_iothread>> s->worker_context = iothread_get_g_main_context(s->iothread);
+ */
 GMainContext *iothread_get_g_main_context(IOThread *iothread)
 {
+    /*
+     * g_once(once, func, arg):
+     *
+     * The first call to this routine by a process with a given GOnce
+     * struct calls func with the given argument. Thereafter, subsequent
+     * calls to g_once() with the same GOnce struct do not call func again,
+     * but return the stored result of the first call. On return from
+     * g_once(), the status of once will be G_ONCE_STATUS_READY.
+     *
+     * For example, a mutex or a thread-specific data key must be created
+     * exactly once. In a threaded environment, calling g_once() ensures
+     * that the initialization is serialized across multiple threads.
+     *
+     * Calling g_once() recursively on the same GOnce struct in func will
+     * lead to a deadlock.
+     */
     g_once(&iothread->once, iothread_g_main_context_init, iothread);
 
     return iothread->worker_context;
 }
 
+/*
+ * called only by:
+ *   - hw/block/xen_disk.c|622| <<blk_alloc>> blkdev->iothread = iothread_create(xendev->name, &err);
+ *   - monitor.c|4544| <<monitor_iothread_init>> mon_iothread = iothread_create("mon_iothread", &error_abort);
+ */
 IOThread *iothread_create(const char *id, Error **errp)
 {
     Object *obj;
 
+    /*
+     * object_get_internal_root(): 返回"container"的Object (internal_root), 如果为空先初始化
+     */
     obj = object_new_with_props(TYPE_IOTHREAD,
                                 object_get_internal_root(),
                                 id, errp, NULL);
@@ -370,6 +532,11 @@ IOThread *iothread_create(const char *id, Error **errp)
     return IOTHREAD(obj);
 }
 
+/*
+ * called by:
+ *   - hw/block/xen_disk.c|991| <<blk_free>> iothread_destroy(blkdev->iothread);
+ *   - monitor.c|4736| <<monitor_cleanup>> iothread_destroy(mon_iothread);
+ */
 void iothread_destroy(IOThread *iothread)
 {
     object_unparent(OBJECT(iothread));
@@ -377,6 +544,10 @@ void iothread_destroy(IOThread *iothread)
 
 /* Lookup IOThread by its id.  Only finds user-created objects, not internal
  * iothread_create() objects. */
+/*
+ * 只被以下调用:
+ *   - blockdev.c|4459| <<qmp_x_blockdev_set_iothread>> IOThread *obj = iothread_by_id(iothread->u.s);
+ */
 IOThread *iothread_by_id(const char *id)
 {
     return IOTHREAD(object_resolve_path_type(id, TYPE_IOTHREAD, NULL));
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 98f389a..b8b9320 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -754,6 +754,10 @@ struct kvm_ppc_resize_hpt {
  * ioctls for /dev/kvm fds:
  */
 #define KVM_GET_API_VERSION       _IO(KVMIO,   0x00)
+/*
+ * x86就用在:
+ *   - accel/kvm/kvm-all.c|1560| <<kvm_init>> ret = kvm_ioctl(s, KVM_CREATE_VM, type);
+ */
 #define KVM_CREATE_VM             _IO(KVMIO,   0x01) /* returns a VM fd */
 #define KVM_GET_MSR_INDEX_LIST    _IOWR(KVMIO, 0x02, struct kvm_msr_list)
 
diff --git a/memory.c b/memory.c
index e9cd446..36f4198 100644
--- a/memory.c
+++ b/memory.c
@@ -35,17 +35,206 @@
 
 //#define DEBUG_UNASSIGNED
 
+/*
+ * QEMU通过MemoryRegion来管理虚拟机内存,通过内存属性,GUEST物理地址等特点对内存
+ * 分类,就形成了多个MemoryRegion,这些MemoryRegion通过树状组织起来,挂接到根
+ * MemoryRegion下.每个MemoryRegion树代表了一类作用的内存,如系统内存空间或IO内存
+ * 空间.
+ *
+ * MemoryRegion可以粗略分为三类：
+ * 1. 根MemoryRegion: 不分配真正的物理内存,通过subregions将所有的子MemoryRegion
+ * 管理起来,如system_memory.
+ * 2. 实体MemoryRegion: 这种MemoryRegion中真正的分配物理内存,最主要的就是pc.ram
+ * 和pci.分配的物理内存的作用分别是内存,PCI地址空间以及fireware空间.QEMU是用户空
+ * 间代码,分配的物理内存返回的是HVA,被保存到host域.同时这个结构还会为本段虚拟机
+ * 内存分配虚拟机物理地址空间起始地址,该起始地址(GPA)保存到ram_addr域,该段内存大
+ * 小为size.通过实体MemoryRegion就可以将HOST地址HVA和GUEST地址GPA对应起来,这种实
+ * 体MemoryRegion起到了转换的作用.
+ * 3. 别名MemoryRegion: 这种MemoryRegion中不分配物理内存,代表了实体MemoryRegion
+ * 的一个部分,通过alias域指向实体MemoryRegion,alias_offset代表了该别名MemoryRegion
+ * 所代表内存起始GPA相对于实体MemoryRegion所代表内存起始GPA的偏移量,通常用来计算
+ * 别名MemoryRegion对应的物理内存的HVA值:
+ * HVA = 起始HVA + alias_offset.
+ *
+ * 所有实体MemoryRegion都会被插在主板上,如pc.ram就被插在I440FX主板的ram_memory成员中.
+ *
+ * MemoryRegion是QEMU管理内存的树状结构,便于按照功能,属性分类;但这只是管理结构.但虚
+ * 拟机的内存需要通过KVM_SET_USER_MEMORY_REGION,将HVA和GPA的对应关系注册到KVM模块的
+ * memslot,才可以生效成为EPT.如果QEMU直接使用MemoryRegion进行注册,那么注册的过程将会
+ * 很麻烦,也容易不断的出现重叠判断等.所以在通过KVM_SET_USER_MEMORY_REGION注册前,加
+ * 了一层转换机制,先将树状的MemoryRegion展开物理内存样子的一维区间结构,然后再通过
+ * KVM_SET_USER_MEMORY_REGION将这个展开的物理内存注册到KVM内核模块中,就方便了许多.
+ * 这个转换机制就是FlatView模型.整个转换过程请参见函数address_space_update_topology.
+ *
+ * --> address_space_update_topology将指定的AddressSpace下的MemoryRegion树进行展平,形成
+ *     了对应一维内存逻辑表示的FlatView.
+ * --> 然后在address_space_update_topology_pass中将FlatView模型通过
+ *     KVM_SET_USER_MEMORY_REGION注册到KVM模块中.
+ *
+ *
+ * 1. QEMU declares a memory region(but not allocate ram or commit it to kvm)
+ * 2. Guest first access the MMIO address, cause a EPT violation VM-exit
+ * 3. KVM construct the EPT page table and marks the page table entry with special mark(110b)
+ * 4. Later the guest access these MMIO, it will be processed by EPT misconfig VM-exit handler
+ *
+ */
+
+/*
+ * qemu中用AddressSpace用来表示CPU设备看到的内存,一个AddressSpace下面包含多个MemoryRegion,
+ * 这些MemoryRegion结构通过树连接起来,树的根是AddressSpace的root域.
+ *
+ * MemoryRegion有多种类型,可以表示一段ram,rom,MMIO,alias,alias表示一个MemoryRegion的一部分
+ * 区域,MemoryRegion也可以表示一个container,这就表示它只是其他若干个MemoryRegion的容器.
+ * 在MemoryRegion中,'ram_block'表示的是分配的实际内存.
+ *
+ * AddressSpace下面root及其子树形成了一个虚拟机的物理地址,但是在往kvm进行设置的时候,需要将其
+ * 转换为一个平坦的地址模型,也就是从0开始的.这个就用FlatView表示,一个AddressSpace对应一个FlatView.
+ *
+ * 在FlatView中,FlatRange表示按照需要被切分为了几个范围.
+ *
+ * 在内存虚拟化中,还有一个重要的结构是MemoryRegionSection,这个结构通过函数section_from_flat_range
+ * 可由FlatRange转换过来.
+ *
+ *
+ * 为了监控虚拟机的物理地址访问,对于每一个AddressSpace,会有一个MemoryListener与之对应.每当物理
+ * 映射(GPA->HVA)发生改变时,会回调这些函数.所有的MemoryListener都会挂在全局变量memory_listeners
+ * 链表上.同时,AddressSpace也会有一个链表连接自己注册的MemoryListener.
+ *
+ * 为了在虚拟机退出时,能够顺利根据物理地址找到对应的HVA地址,qemu会有一个AddressSpaceDispatch结构,
+ * 用来在AddressSpace中进行位置的找寻,继而完成对IO/MMIO地址的访问. 这里面有一个PhysPageMap,这其实
+ * 也是保存了一个GPA->HVA的一个映射,通过多层页表实现,当kvm exit退到qemu之后,通过这个AddressSpaceDispatch
+ * 里面的map查找对应的MemoryRegionSection,继而找到对应的主机HVA.
+ */
+
+/*
+ * pc_init1()用到system_memory(MemoryRegion)和pci_memory(MemoryRegion).
+ *
+ * 215     if (pcmc->pci_enabled) {
+ * 216         pci_bus = i440fx_init(host_type,
+ * 217                               pci_type,
+ * 218                               &i440fx_state, &piix3_devfn, &isa_bus, pcms->gsi,
+ * 219                               system_memory, system_io, machine->ram_size,
+ * 220                               pcms->below_4g_mem_size,
+ * 221                               pcms->above_4g_mem_size,
+ * 222                               pci_memory, ram_memory);
+ *
+ *
+ * 初始化bus->address_space_mem (PCIBus的MemoryRegion)为名字为"pci"的MemoryRegion.
+ *
+ * 364     b = pci_root_bus_new(dev, NULL, pci_address_space,
+ * 365                          address_space_io, 0, TYPE_PCI_BUS);
+ *
+ *
+ * f->system_memory是system_memory(MemoryRegion), f->pci_address_space是pci_address_space
+ * (也就是名字为"pci"的MemoryRegion).
+ *
+ * pc_pci_as_mapping_init()把pci_address_space(名字为"pci"的MemoryRegion)设置container
+ * 为system_memory.
+ *
+ * 382     pc_pci_as_mapping_init(OBJECT(f), f->system_memory,
+ * 383                            f->pci_address_space);
+ *
+ *
+ * nvme的初始化在nvme_realize()中初始化:
+ *
+ * 1307     memory_region_init_io(&n->iomem, OBJECT(n), &nvme_mmio_ops, n,
+ * 1308                           "nvme", n->reg_size);
+ * 1309     pci_register_bar(&n->parent_obj, 0,
+ * 1310         PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_64,
+ * 1311         &n->iomem);
+ *
+ * 在pci_register_bar()中, 把nvme自己的MemoryRegion设置成pci_dev->io_regions[i](PCIIORegion)
+ * 的memory. 上面说过pci_get_bus(pci_dev)->address_space_mem是名字为"pci"的
+ * MemoryRegion(container是system_memory).
+ *
+ * 1171     r->address_space = type & PCI_BASE_ADDRESS_SPACE_IO
+ * 1172                         ? pci_get_bus(pci_dev)->address_space_io
+ * 1173                         : pci_get_bus(pci_dev)->address_space_mem;
+ *
+ *
+ * 在pci_update_mappings()的时候会把PCIDevice的每一个PCIIORegion添加到r->address_space
+ * (名字为"pci"的MemoryRegion).
+ *
+ * 1405                                           i, r->addr, r->size);
+ * 1406             memory_region_add_subregion_overlap(r->address_space,
+ * 1407                                                 r->addr, r->memory, 1);
+ */
+
 static unsigned memory_region_transaction_depth;
+/*
+ * 设置的地方:
+ *   - memory.c|1254| <<memory_region_transaction_commit>> memory_region_update_pending = false;
+ *   - memory.c|2245| <<memory_region_set_log>> memory_region_update_pending |= mr->enabled;
+ *   - memory.c|2318| <<memory_region_set_readonly>> memory_region_update_pending |= mr->enabled;
+ *   - memory.c|2328| <<memory_region_rom_device_set_romd>> memory_region_update_pending |= mr->enabled;
+ *   - memory.c|2601| <<memory_region_update_container_subregions>> memory_region_update_pending |= mr->enabled && subregion->enabled;
+ *   - memory.c|2666| <<memory_region_del_subregion>> memory_region_update_pending |= mr->enabled && subregion->enabled;
+ *   - memory.c|2677| <<memory_region_set_enabled>> memory_region_update_pending = true;
+ *   - memory.c|2693| <<memory_region_set_size>> memory_region_update_pending = true;
+ *   - memory.c|2747| <<memory_region_set_alias_offset>> memory_region_update_pending |= mr->enabled;
+ *   - memory.c|2870| <<memory_global_dirty_log_start>> memory_region_update_pending = true;
+ *   - memory.c|2880| <<memory_global_dirty_log_do_stop>> memory_region_update_pending = true;
+ */
 static bool memory_region_update_pending;
+/*
+ * 设置的地方:
+ *   - memory.c|1273| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - memory.c|1282| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - memory.c|2556| <<memory_region_add_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ *   - memory.c|2591| <<memory_region_del_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ */
 static bool ioeventfd_update_pending;
 static bool global_dirty_log = false;
 
+/*
+ * 所有使用的地方:
+ *   - memory.c|2696| <<memory_listener_register>> QTAILQ_INSERT_TAIL(&memory_listeners, listener, link);
+ *   - memory.c|126| <<MEMORY_LISTENER_CALL_GLOBAL>> QTAILQ_FOREACH(_listener, &memory_listeners, link) { \
+ *   - memory.c|133| <<MEMORY_LISTENER_CALL_GLOBAL>> QTAILQ_FOREACH_REVERSE(_listener, &memory_listeners, \
+ *   - memory.c|134| <<MEMORY_LISTENER_CALL_GLOBAL>> memory_listeners, link) { \
+ *   - memory.c|2046| <<memory_region_sync_dirty_bitmap>> QTAILQ_FOREACH(listener, &memory_listeners, link) {
+ *   - memory.c|2693| <<memory_listener_register>> if (QTAILQ_EMPTY(&memory_listeners)
+ *   - memory.c|2694| <<memory_listener_register>> || listener->priority >= QTAILQ_LAST(&memory_listeners,
+ *   - memory.c|2695| <<memory_listener_register>> memory_listeners)->priority) {
+ *   - memory.c|2698| <<memory_listener_register>> QTAILQ_FOREACH(other, &memory_listeners, link) {
+ *   - memory.c|2708| <<memory_listener_register>> memory_listeners)->priority) {
+ *   - memory.c|2729| <<memory_listener_unregister>> QTAILQ_REMOVE(&memory_listeners, listener, link);
+ */
 static QTAILQ_HEAD(memory_listeners, MemoryListener) memory_listeners
     = QTAILQ_HEAD_INITIALIZER(memory_listeners);
 
+/*
+ * 添加:
+ *   - memory.c|2835| <<address_space_init>> QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
+ *
+ * 删除:
+ *   - memory.c|2859| <<address_space_destroy>> QTAILQ_REMOVE(&address_spaces, as, address_spaces_link);
+ *
+ * 使用:
+ *   - memory.c|608| <<memory_region_to_address_space>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|969| <<flatviews_reset>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|1060| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|1068| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|2189| <<memory_region_update_coalesced_range>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|3150| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|3174| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ */
 static QTAILQ_HEAD(, AddressSpace) address_spaces
     = QTAILQ_HEAD_INITIALIZER(address_spaces);
 
+/*
+ * 用到flat_views的地方:
+ *   - memory.c|819| <<generate_memory_topology>> g_hash_table_replace(flat_views, mr, view);
+ *   - memory.c|999| <<flatviews_init>> if (flat_views) {
+ *   - memory.c|1003| <<flatviews_init>> flat_views = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
+ *   - memory.c|1010| <<flatviews_init>> g_hash_table_replace(flat_views, NULL, empty_view);
+ *   - memory.c|1019| <<flatviews_reset>> if (flat_views) {
+ *   - memory.c|1020| <<flatviews_reset>> g_hash_table_unref(flat_views);
+ *   - memory.c|1021| <<flatviews_reset>> flat_views = NULL;
+ *   - memory.c|1029| <<flatviews_reset>> if (g_hash_table_lookup(flat_views, physmr)) {
+ *   - memory.c|1041| <<address_space_set_flatview>> FlatView *new_view = g_hash_table_lookup(flat_views, physmr);
+ *   - memory.c|1091| <<address_space_update_topology>> if (!g_hash_table_lookup(flat_views, physmr)) {
+ */
 static GHashTable *flat_views;
 
 typedef struct AddrRange AddrRange;
@@ -59,39 +248,46 @@ struct AddrRange {
     Int128 size;
 };
 
+/* 用start和size制作成一个AddrRange */
 static AddrRange addrrange_make(Int128 start, Int128 size)
 {
     return (AddrRange) { start, size };
 }
 
+/* 比较两个AddrRange的start的size是否完全相同 */
 static bool addrrange_equal(AddrRange r1, AddrRange r2)
 {
     return int128_eq(r1.start, r2.start) && int128_eq(r1.size, r2.size);
 }
 
+/* 返回AddrRange的start+size (也就是end) */
 static Int128 addrrange_end(AddrRange r)
 {
     return int128_add(r.start, r.size);
 }
 
+/* AddrRange的start加上delta并更新start */
 static AddrRange addrrange_shift(AddrRange range, Int128 delta)
 {
     int128_addto(&range.start, delta);
     return range;
 }
 
+/* 判断一个addr是否在AddrRange的范围内 */
 static bool addrrange_contains(AddrRange range, Int128 addr)
 {
     return int128_ge(addr, range.start)
         && int128_lt(addr, addrrange_end(range));
 }
 
+/* 判断两个AddrRange是否intersect */
 static bool addrrange_intersects(AddrRange r1, AddrRange r2)
 {
     return addrrange_contains(r1, r2.start)
         || addrrange_contains(r2, r1.start);
 }
 
+/* 返回两个AddrRange相交的地方并返回新生成的AddrRange */
 static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
 {
     Int128 start = int128_max(r1.start, r2.start);
@@ -101,6 +297,16 @@ static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
 
 enum ListenerDirection { Forward, Reverse };
 
+/*
+ * called by:
+ *   - memory.c|1135| <<memory_region_transaction_commit>> MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);
+ *   - memory.c|1143| <<memory_region_transaction_commit>> MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);
+ *   - memory.c|2737| <<memory_global_dirty_log_start>> MEMORY_LISTENER_CALL_GLOBAL(log_global_start, Forward);
+ *   - memory.c|2754| <<memory_global_dirty_log_do_stop>> MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);
+ *
+ * 根据_direction的方向, 从前向后或者从后向前遍历调用memory_listeners中的每个MemoryListener
+ * 并调用指定的_callback (比如commit, begin等)
+ */
 #define MEMORY_LISTENER_CALL_GLOBAL(_callback, _direction, _args...)    \
     do {                                                                \
         MemoryListener *_listener;                                      \
@@ -126,6 +332,17 @@ enum ListenerDirection { Forward, Reverse };
         }                                                               \
     } while (0)
 
+/*
+ * called by:
+ *   - memory.c|217| <<MEMORY_LISTENER_UPDATE_REGION>> MEMORY_LISTENER_CALL(as, callback, dir, &mrs, ##_args); \
+ *   - memory.c|877| <<address_space_add_del_ioeventfds>> MEMORY_LISTENER_CALL(as, eventfd_del, Forward, &section,
+ *   - memory.c|890| <<address_space_add_del_ioeventfds>> MEMORY_LISTENER_CALL(as, eventfd_add, Reverse, &section,
+ *   - memory.c|2304| <<memory_region_update_coalesced_range_as>> MEMORY_LISTENER_CALL(as, coalesced_mmio_del, Reverse, &section,
+ *   - memory.c|2315| <<memory_region_update_coalesced_range_as>> MEMORY_LISTENER_CALL(as, coalesced_mmio_add, Forward, &section,
+ *
+ * 根据_direction的方向, 从前向后或者从后向前遍历调用某个AddressSpace自己的每个MemoryListener
+ * 并调用指定的_callback (比如eventfd_add, coalesced_mmio_add等)
+ */
 #define MEMORY_LISTENER_CALL(_as, _callback, _direction, _section, _args...) \
     do {                                                                \
         MemoryListener *_listener;                                      \
@@ -153,6 +370,19 @@ enum ListenerDirection { Forward, Reverse };
     } while (0)
 
 /* No need to ref/unref .mr, the FlatRange keeps it alive.  */
+/*
+ * called by:
+ *   - memory.c|995| <<address_space_update_topology_pass>> MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del);
+ *   - memory.c|1003| <<address_space_update_topology_pass>> MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop);
+ *   - memory.c|1005| <<address_space_update_topology_pass>> MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start,
+ *   - memory.c|1010| <<address_space_update_topology_pass>> MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop,
+ *   - memory.c|1022| <<address_space_update_topology_pass>> MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);
+ *
+ * 这个宏会将每一个FlatRange转换为一个MemoryRegionSection,之后调用
+ * 这个as对应的各个MemoryListener的回调函数.这里我们以kvm对象注册
+ * Listener为例,从kvm_memory_listener_register,我们看到其region_add
+ * 回调为kvm_region_add()
+ */
 #define MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...)  \
     do {                                                                \
         MemoryRegionSection mrs = section_from_flat_range(fr,           \
@@ -161,17 +391,20 @@ enum ListenerDirection { Forward, Reverse };
     } while(0)
 
 struct CoalescedMemoryRange {
+    /* 包括start和size */
     AddrRange addr;
     QTAILQ_ENTRY(CoalescedMemoryRange) link;
 };
 
 struct MemoryRegionIoeventfd {
+    /* 包括start和size */
     AddrRange addr;
     bool match_data;
     uint64_t data;
     EventNotifier *e;
 };
 
+/* 判断第一个MemoryRegionIoeventfd是否在第二个前面 */
 static bool memory_region_ioeventfd_before(MemoryRegionIoeventfd *a,
                                            MemoryRegionIoeventfd *b)
 {
@@ -202,6 +435,7 @@ static bool memory_region_ioeventfd_before(MemoryRegionIoeventfd *a,
     return false;
 }
 
+/* 判断两个MemoryRegionIoeventfd是否相等 */
 static bool memory_region_ioeventfd_equal(MemoryRegionIoeventfd *a,
                                           MemoryRegionIoeventfd *b)
 {
@@ -210,18 +444,33 @@ static bool memory_region_ioeventfd_equal(MemoryRegionIoeventfd *a,
 }
 
 /* Range of memory in the global map.  Addresses are absolute. */
+/*
+ * 似乎主要用在FlatView中
+ */
 struct FlatRange {
     MemoryRegion *mr;
     hwaddr offset_in_region;
+    /* 包含start和size */
     AddrRange addr;
     uint8_t dirty_log_mask;
     bool romd_mode;
     bool readonly;
 };
 
+/* 遍历FlatView中的每一个FlatRange */
 #define FOR_EACH_FLAT_RANGE(var, view)          \
     for (var = (view)->ranges; var < (view)->ranges + (view)->nr; ++var)
 
+/*
+ * called by:
+ *   - memory.c|237| <<MEMORY_LISTENER_UPDATE_REGION>> MemoryRegionSection mrs = section_from_flat_range(fr, \
+ *   - memory.c|867| <<generate_memory_topology>> section_from_flat_range(&view->ranges[i], view);
+ *   - memory.c|2202| <<memory_region_sync_dirty_bitmap>> MemoryRegionSection mrs = section_from_flat_range(fr, view);
+ *   - memory.c|2833| <<listener_add_address_space>> MemoryRegionSection section = section_from_flat_range(fr, view);
+ *   - memory.c|2859| <<listener_del_address_space>> MemoryRegionSection section = section_from_flat_range(fr, view);
+ *
+ * 根据参数的FlatRange和FlatView, 返回一个临时的MemoryRegionSection
+ */
 static inline MemoryRegionSection
 section_from_flat_range(FlatRange *fr, FlatView *fv)
 {
@@ -235,6 +484,9 @@ section_from_flat_range(FlatRange *fr, FlatView *fv)
     };
 }
 
+/*
+ * 比较两个FlatRange是否完全相同
+ */
 static bool flatrange_equal(FlatRange *a, FlatRange *b)
 {
     return a->mr == b->mr
@@ -244,6 +496,11 @@ static bool flatrange_equal(FlatRange *a, FlatRange *b)
         && a->readonly == b->readonly;
 }
 
+/*
+ * called only by generate_memory_topology()
+ *
+ * 分配一个FlatView, 让其root指向参数的MemoryRegion
+ */
 static FlatView *flatview_new(MemoryRegion *mr_root)
 {
     FlatView *view;
@@ -260,13 +517,33 @@ static FlatView *flatview_new(MemoryRegion *mr_root)
 /* Insert a range into a given position.  Caller is responsible for maintaining
  * sorting order.
  */
+/*
+ * called by:
+ *   - memory.c|789| <<render_memory_region>> flatview_insert(view, i, &fr);
+ *   - memory.c|805| <<render_memory_region>> flatview_insert(view, i, &fr);
+ *
+ * FlatView的ranges数组(FlatRange)中的后面pos个都往后移一个
+ * 把参数中的FlatRange放在pos的位置
+ * 如果FlatView->nr_allocated不够了要扩容一下
+ */
 static void flatview_insert(FlatView *view, unsigned pos, FlatRange *range)
 {
+    /*
+     * 如果view (FlatView)的nr_allocated不够了, 扩大一下
+     * 最大也就10个
+     */
     if (view->nr == view->nr_allocated) {
         view->nr_allocated = MAX(2 * view->nr, 10);
+	/* ranges[nr_allocated]是一个FlatRange的数组 */
         view->ranges = g_realloc(view->ranges,
                                     view->nr_allocated * sizeof(*view->ranges));
     }
+    /*
+     * ranges[nr_allocated]是一个FlatRange的数组
+     *
+     * FlatView的ranges数组(FlatRange)中的后面pos个都往后移一个
+     * 把参数中的FlatRange放在pos的位置
+     */
     memmove(view->ranges + pos + 1, view->ranges + pos,
             (view->nr - pos) * sizeof(FlatRange));
     view->ranges[pos] = *range;
@@ -274,6 +551,10 @@ static void flatview_insert(FlatView *view, unsigned pos, FlatRange *range)
     ++view->nr;
 }
 
+/*
+ * called only by:
+ *   - memory.c|405| <<flatview_unref>> call_rcu(view, flatview_destroy, rcu);
+ */
 static void flatview_destroy(FlatView *view)
 {
     int i;
@@ -304,6 +585,9 @@ void flatview_unref(FlatView *view)
     }
 }
 
+/*
+ * 判断两个FlatRange是否想连续可以merge
+ */
 static bool can_merge(FlatRange *r1, FlatRange *r2)
 {
     return int128_eq(addrrange_end(r1->addr), r2->addr.start)
@@ -317,6 +601,13 @@ static bool can_merge(FlatRange *r1, FlatRange *r2)
 }
 
 /* Attempt to simplify a view by merging adjacent ranges */
+/*
+ * called only by:
+ *   - memory.c|905| <<generate_memory_topology>> flatview_simplify(view);
+ *
+ * 把FlatView中的ranges(FlatRange)数组中的FlatRange们合并一下
+ * 合并后nr也许会减少
+ */
 static void flatview_simplify(FlatView *view)
 {
     unsigned i, j;
@@ -354,6 +645,13 @@ static bool memory_region_wrong_endianness(MemoryRegion *mr)
 #endif
 }
 
+/*
+ * called by:
+ *   - memory.c|1660| <<memory_region_dispatch_read>> adjust_endianness(mr, pval, size);
+ *   - memory.c|1701| <<memory_region_dispatch_write>> adjust_endianness(mr, &data, size);
+ *   - memory.c|2494| <<memory_region_add_eventfd>> adjust_endianness(mr, &mrfd.data, size);
+ *   - memory.c|2529| <<memory_region_del_eventfd>> adjust_endianness(mr, &mrfd.data, size);
+ */
 static void adjust_endianness(MemoryRegion *mr, uint64_t *data, unsigned size)
 {
     if (memory_region_wrong_endianness(mr)) {
@@ -375,6 +673,32 @@ static void adjust_endianness(MemoryRegion *mr, uint64_t *data, unsigned size)
     }
 }
 
+/*
+ * called by:
+ *   - memory.c|449| <<memory_region_oldmmio_read_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *   - memory.c|475| <<memory_region_read_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *   - memory.c|502| <<memory_region_read_with_attrs_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *   - memory.c|528| <<memory_region_oldmmio_write_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *   - memory.c|554| <<memory_region_write_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *   - memory.c|580| <<memory_region_write_with_attrs_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *
+ * (gdb) bt
+ * #0  memory_region_to_absolute_addr (mr=0x555557498b60, offset=0) at /home/zhang/kvm/qemu-3.0.0/memory.c:381
+ * #1  0x0000555555864ae7 in memory_region_write_accessor (mr=0x555557498b60, addr=0, value=0x7fffec8b07a8, size=1, shift=0, mask=255, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:524
+ * #2  0x0000555555864d45 in access_with_adjusted_size (addr=0, value=0x7fffec8b07a8, size=1, access_size_min=1, access_size_max=1, access_fn=0x555555864a43 <memory_region_write_accessor>,
+ *     mr=0x555557498b60,attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #3  0x000055555586796d in memory_region_dispatch_write (mr=0x555557498b60, addr=0, data=143, size=1, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #4  0x000055555580399f in flatview_write_continue (fv=0x555557bb3600, addr=112, attrs=..., buf=0x7ffff7ff0000 "\217", len=1, addr1=0, l=1, mr=0x555557498b60) at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #5  0x0000555555803ae9 in flatview_write (fv=0x555557bb3600, addr=112, attrs=..., buf=0x7ffff7ff0000 "\217", len=1) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #6  0x0000555555803def in address_space_write (as=0x555556721a20 <address_space_io>, addr=112, attrs=..., buf=0x7ffff7ff0000 "\217", len=1) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #7  0x0000555555803e40 in address_space_rw (as=0x555556721a20 <address_space_io>, addr=112, attrs=..., buf=0x7ffff7ff0000 "\217", len=1, is_write=true) at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #8  0x00005555558823ec in kvm_handle_io (port=112, attrs=..., data=0x7ffff7ff0000, direction=1, size=1, count=1) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1729
+ * #9  0x0000555555882b30 in kvm_cpu_exec (cpu=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1969
+ * #10 0x0000555555849eac in qemu_kvm_cpu_thread_fn (arg=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #11 0x0000555555d92dd7 in qemu_thread_start (args=0x5555568abcb0) at util/qemu-thread-posix.c:504
+ * #12 0x00007ffff4ca06ba in start_thread (arg=0x7fffec8b1700) at pthread_create.c:333
+ * #13 0x00007ffff49d641d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 static hwaddr memory_region_to_absolute_addr(MemoryRegion *mr, hwaddr offset)
 {
     MemoryRegion *root;
@@ -389,6 +713,7 @@ static hwaddr memory_region_to_absolute_addr(MemoryRegion *mr, hwaddr offset)
     return abs_addr;
 }
 
+/* 如果current_cpu存在 返回current_cpu->cpu_index */
 static int get_cpu_index(void)
 {
     if (current_cpu) {
@@ -553,6 +878,11 @@ static MemTxResult memory_region_write_with_attrs_accessor(MemoryRegion *mr,
     return mr->ops->write_with_attrs(mr->opaque, addr, tmp, size, attrs);
 }
 
+/*
+ * called by:
+ *   - memory_region_dispatch_read1()
+ *   - memory_region_dispatch_write()
+ */
 static MemTxResult access_with_adjusted_size(hwaddr addr,
                                       uint64_t *value,
                                       unsigned size,
@@ -598,13 +928,22 @@ static MemTxResult access_with_adjusted_size(hwaddr addr,
     return r;
 }
 
+/*
+ * 一直从mr->container递归遍历 找到不再有container的MemeoryRegion
+ * 遍历address_spaces链表中所有的AddressSpace, 找到root是上面MemoryRegion的那个
+ * 其实就是找到一个MemoryRegion所属的AddressSpace
+ */
 static AddressSpace *memory_region_to_address_space(MemoryRegion *mr)
 {
     AddressSpace *as;
 
+    /* 一直从mr->container递归遍历 找到不再有container的MemeoryRegion */
     while (mr->container) {
         mr = mr->container;
     }
+    /*
+     * 遍历address_spaces链表中所有的AddressSpace, 找到root是上面MemoryRegion的那个
+     */
     QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
         if (mr == as->root) {
             return as;
@@ -616,6 +955,14 @@ static AddressSpace *memory_region_to_address_space(MemoryRegion *mr)
 /* Render a memory region into the global view.  Ranges in @view obscure
  * ranges in @mr.
  */
+/*
+ * called by:
+ *   - memory.c|859| <<render_memory_region>> render_memory_region(view, mr->alias, base, clip, readonly);
+ *   - memory.c|865| <<render_memory_region>> render_memory_region(view, subregion, base, clip, readonly);
+ *   - memory.c|977| <<generate_memory_topology>> render_memory_region(view, mr, int128_zero(),
+ *
+ * 因为等价于只被generate_memory_topology()调用, 核心思想就是生成FlatView中的FlatRange数组
+ */
 static void render_memory_region(FlatView *view,
                                  MemoryRegion *mr,
                                  Int128 base,
@@ -634,26 +981,40 @@ static void render_memory_region(FlatView *view,
         return;
     }
 
+    /*
+     * 如果一开始是generate_memory_topology()调用进来的话, base是0
+     */
     int128_addto(&base, int128_make64(mr->addr));
     readonly |= mr->readonly;
 
+    /* 用start和size制作成一个AddrRange */
     tmp = addrrange_make(base, mr->size);
 
+    /* 判断两个AddrRange(tmp和clip)是否intersect */
     if (!addrrange_intersects(tmp, clip)) {
         return;
     }
 
+    /* 返回两个AddrRange相交的地方并返回新生成的AddrRange */
     clip = addrrange_intersection(tmp, clip);
 
     if (mr->alias) {
         int128_subfrom(&base, int128_make64(mr->alias->addr));
         int128_subfrom(&base, int128_make64(mr->alias_offset));
+	/*
+	 * view是参数中的view
+	 *
+	 * clip是传值 所以不会更新
+	 */
         render_memory_region(view, mr->alias, base, clip, readonly);
         return;
     }
 
     /* Render subregions in priority order. */
     QTAILQ_FOREACH(subregion, &mr->subregions, subregions_link) {
+        /*
+	 * clip是传值 所以不会更新
+	 */
         render_memory_region(view, subregion, base, clip, readonly);
     }
 
@@ -665,6 +1026,9 @@ static void render_memory_region(FlatView *view,
     base = clip.start;
     remain = clip.size;
 
+    /*
+     * fr是FlatRange
+     */
     fr.mr = mr;
     fr.dirty_log_mask = memory_region_get_dirty_log_mask(mr);
     fr.romd_mode = mr->romd_mode;
@@ -686,6 +1050,9 @@ static void render_memory_region(FlatView *view,
             offset_in_region += int128_get64(now);
             int128_subfrom(&remain, now);
         }
+	/*
+	 * addrrange_end(): 返回AddrRange的start+size (也就是end)
+	 */
         now = int128_sub(int128_min(int128_add(base, remain),
                                     addrrange_end(view->ranges[i].addr)),
                          base);
@@ -695,11 +1062,23 @@ static void render_memory_region(FlatView *view,
     }
     if (int128_nz(remain)) {
         fr.offset_in_region = offset_in_region;
+	/* 用start和size制作成一个AddrRange */
         fr.addr = addrrange_make(base, remain);
+	/*
+	 * FlatView的ranges数组(FlatRange)中的后面pos个都往后移一个
+	 * 把参数中的FlatRange放在pos的位置
+	 * 如果FlatView->nr_allocated不够了要扩容一下
+	 */
         flatview_insert(view, i, &fr);
     }
 }
 
+/*
+ * called by:
+ *   - memory.c|1006| <<flatviews_reset>> MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
+ *   - memory.c|1019| <<address_space_set_flatview>> MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
+ *   - memory.c|1067| <<address_space_update_topology>> MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
+ */
 static MemoryRegion *memory_region_get_flatview_root(MemoryRegion *mr)
 {
     while (mr->enabled) {
@@ -745,26 +1124,106 @@ static MemoryRegion *memory_region_get_flatview_root(MemoryRegion *mr)
 }
 
 /* Render a memory topology into a list of disjoint absolute ranges. */
+/*
+ * called by:
+ *   - memory.c|985| <<flatviews_init>> empty_view = generate_memory_topology(NULL);
+ *   - memory.c|1012| <<flatviews_reset>> generate_memory_topology(physmr);
+ *   - memory.c|1071| <<address_space_update_topology>> generate_memory_topology(physmr);
+ *
+ *
+ * hotplug nvme的例子:
+ * (gdb) bt
+ * #0  generate_memory_topology (mr=0x5555565c81f0) at /home/zhang/kvm/qemu-3.0.0/memory.c:749
+ * #1  0x0000555555834cb3 in flatviews_reset () at /home/zhang/kvm/qemu-3.0.0/memory.c:976
+ * #2  0x0000555555834f30 in memory_region_transaction_commit () at /home/zhang/kvm/qemu-3.0.0/memory.c:1052
+ * #3  0x00005555558386eb in memory_region_set_enabled (mr=0x55555706cbd0, enabled=false) at /home/zhang/kvm/qemu-3.0.0/memory.c:2360
+ * #4  0x0000555555af2ea9 in pci_init_bus_master (pci_dev=0x55555706c870) at hw/pci/pci.c:96
+ * #5  0x0000555555af5249 in do_pci_register_device (pci_dev=0x55555706c870, name=0x5555564e9f40 "nvme", devfn=32, errp=0x7fffffffcbf0) at hw/pci/pci.c:1030
+ * #6  0x0000555555af76d3 in pci_qdev_realize (qdev=0x55555706c870, errp=0x7fffffffcbf0) at hw/pci/pci.c:2021
+ * #7  0x0000555555a2d447 in device_set_realized (obj=0x55555706c870, value=true, errp=0x7fffffffcdc0) at hw/core/qdev.c:826
+ * #8  0x0000555555c21bc7 in property_set_bool (obj=0x55555706c870, v=0x55555709f010, name=0x555555db778a "realized", opaque=0x55555715d760, errp=0x7fffffffcdc0)
+ *     at qom/object.c:1984
+ * #9  0x0000555555c1fe4c in object_property_set (obj=0x55555706c870, v=0x55555709f010, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1176
+ * #10 0x0000555555c22f04 in object_property_set_qobject (obj=0x55555706c870, value=0x55555675fec0, name=0x555555db778a "realized", errp=0x7fffffffcdc0)
+ *     at qom/qom-qobject.c:27
+ * #11 0x0000555555c20131 in object_property_set_bool (obj=0x55555706c870, value=true, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1242
+ * #12 0x0000555555990749 in qdev_device_add (opts=0x5555565c63a0, errp=0x7fffffffce30) at qdev-monitor.c:627
+ * #13 0x0000555555990f32 in qmp_device_add (qdict=0x55555709df10, ret_data=0x0, errp=0x7fffffffce70) at qdev-monitor.c:807
+ * #14 0x00005555559bebd7 in hmp_device_add (mon=0x5555565e0bd0, qdict=0x55555709df10) at hmp.c:2008
+ * #15 0x00005555558230ac in handle_hmp_command (mon=0x5555565e0bd0, cmdline=0x5555565f005b "nvme,drive=lightnvme,serial=deadbeaf1")
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #16 0x0000555555825467 in monitor_command_cb (opaque=0x5555565e0bd0, cmdline=0x5555565f0050 "device_add nvme,drive=lightnvme,serial=deadbeaf1", 
+ *     readline_opaque=0x0) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #17 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565f0050, ch=13) at util/readline.c:393
+ * #18 0x00005555558253ba in monitor_read (opaque=0x5555565e0bd0, buf=0x7fffffffd030 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #19 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #20 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #21 0x0000555555cce691 in fd_chr_read (chan=0x5555565d3310, cond=G_IO_IN, opaque=0x5555565d3100) at chardev/char-fd.c:66
+ * #22 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x555556ff37e0, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d3100)
+ *     at io/channel-watch.c:84
+ * #23 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #24 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #25 0x0000555555d4f990 in os_host_main_loop_wait (timeout=198688541) at util/main-loop.c:238
+ * #26 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #27 0x00005555559967aa in main_loop () at vl.c:1866
+ * #28 0x000055555599dfbd in main (argc=12, argv=0x7fffffffe4a8, envp=0x7fffffffe510) at vl.c:4644
+ * (gdb) p mr->name
+ * $1 = 0x5555565c86c0 "system"
+ *
+ * physmr可以临时理解成AddressSpace的root (先忽略其他情况)
+ */
 static FlatView *generate_memory_topology(MemoryRegion *mr)
 {
     int i;
+    /*
+     * AddressSpace下面root及其子树形成了一个虚拟机的物理地址,但是在往kvm进行设置的时候,
+     * 需要将其转换为一个平坦的地址模型,也就是从0开始的.这个就用FlatView表示,一个
+     * AddressSpace对应一个FlatView.
+     */
     FlatView *view;
 
+    /*
+     * 分配一个FlatView, 让其root指向参数的mr(MemoryRegion)
+     *
+     * 刚分配的话nr和nr_allocated都是0吧
+     */
     view = flatview_new(mr);
 
     if (mr) {
+	/*
+	 * 因为等价于只被generate_memory_topology()调用, 核心思想就是生成FlatView中的FlatRange数组
+	 */
         render_memory_region(view, mr, int128_zero(),
                              addrrange_make(int128_zero(), int128_2_64()), false);
     }
+    /*
+     * 把FlatView中的ranges(FlatRange)数组中的FlatRange们合并一下
+     * 合并后nr也许会减少
+     *
+     * 如果参数mr是NULL (从flatviews_init()进来), 下面的flatview_simplify()似乎就不运行了
+     */
     flatview_simplify(view);
 
+    /*
+     * 为了在虚拟机退出时,能够顺利根据物理地址找到对应的HVA地址,qemu会有一个
+     * AddressSpaceDispatch结构,用来在AddressSpace中进行位置的找寻,继而完成
+     * 对IO/MMIO地址的访问.
+     *
+     *
+     * 分配一个AddressSpaceDispatch并简单初始化一些dummy section
+     */
     view->dispatch = address_space_dispatch_new(view);
+    /*
+     * 如果参数mr是NULL (从flatviews_init()进来), 下面的for循环似乎就不运行了
+     */
     for (i = 0; i < view->nr; i++) {
+        /* 根据参数的FlatRange和FlatView, 返回一个临时的MemoryRegionSection */
         MemoryRegionSection mrs =
             section_from_flat_range(&view->ranges[i], view);
         flatview_add_to_dispatch(view, &mrs);
     }
     address_space_dispatch_compact(view->dispatch);
+    /* 把新分配的FlatView换成全局的flat_views */
     g_hash_table_replace(flat_views, mr, view);
 
     return view;
@@ -819,6 +1278,20 @@ static void address_space_add_del_ioeventfds(AddressSpace *as,
     }
 }
 
+/*
+ * called by:
+ *   - exec.c|3821| <<address_space_cache_init>> cache->fv = address_space_get_flatview(as);
+ *   - memory.c|1158| <<address_space_update_ioeventfds>> view = address_space_get_flatview(as);
+ *   - memory.c|2423| <<memory_region_sync_dirty_bitmap>> view = address_space_get_flatview(as);
+ *   - memory.c|2544| <<memory_region_update_coalesced_range_as>> view = address_space_get_flatview(as);
+ *   - memory.c|3105| <<listener_add_address_space>> view = address_space_get_flatview(as);
+ *   - memory.c|3131| <<listener_del_address_space>> view = address_space_get_flatview(as);
+ *   - memory.c|3661| <<mtree_info>> view = address_space_get_flatview(as);
+ *
+ * 返回AddressSpace->current_map
+ * current_map是AddressSpace的一张平面视图,它是AddressSpace
+ * 所有正在使用的MemoryRegion的集合,这是从CPU的视角来看到的
+ */
 FlatView *address_space_get_flatview(AddressSpace *as)
 {
     FlatView *view;
@@ -834,6 +1307,12 @@ FlatView *address_space_get_flatview(AddressSpace *as)
     return view;
 }
 
+/*
+ * called by:
+ *   - memory.c|1092| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+ *   - memory.c|1099| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+ *   - memory.c|2933| <<address_space_init>> address_space_update_ioeventfds(as);
+ */
 static void address_space_update_ioeventfds(AddressSpace *as)
 {
     FlatView *view;
@@ -843,6 +1322,11 @@ static void address_space_update_ioeventfds(AddressSpace *as)
     AddrRange tmp;
     unsigned i;
 
+    /*
+     * 返回AddressSpace->current_map
+     * current_map是AddressSpace的一张平面视图,它是AddressSpace
+     * 所有正在使用的MemoryRegion的集合,这是从CPU的视角来看到的
+     */
     view = address_space_get_flatview(as);
     FOR_EACH_FLAT_RANGE(fr, view) {
         for (i = 0; i < fr->mr->ioeventfd_nb; ++i) {
@@ -868,6 +1352,92 @@ static void address_space_update_ioeventfds(AddressSpace *as)
     flatview_unref(view);
 }
 
+/*
+ * called by:
+ *   - memory.c|1359| <<address_space_set_flatview>> address_space_update_topology_pass(as, old_view2, new_view, false);
+ *   - memory.c|1360| <<address_space_set_flatview>> address_space_update_topology_pass(as, old_view2, new_view, true);
+ *
+ * hotplug e1000网卡的例子:
+ * (gdb) bt
+ * #0  address_space_update_topology_pass (as=0x555556498b40 <address_space_memory>, old_view=0x7fffdc000c00, new_view=0x55555772c200, adding=false)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:875
+ * #1  0x0000555555834dc9 in address_space_set_flatview (as=0x555556498b40 <address_space_memory>) at /home/zhang/kvm/qemu-3.0.0/memory.c:1004
+ * #2  0x0000555555834f89 in memory_region_transaction_commit () at /home/zhang/kvm/qemu-3.0.0/memory.c:1057
+ * #3  0x00005555558386eb in memory_region_set_enabled (mr=0x5555566fcf80, enabled=false) at /home/zhang/kvm/qemu-3.0.0/memory.c:2360
+ * #4  0x0000555555af2ea9 in pci_init_bus_master (pci_dev=0x5555566fcc20) at hw/pci/pci.c:96
+ * #5  0x0000555555af5249 in do_pci_register_device (pci_dev=0x5555566fcc20, name=0x5555565190c0 "e1000", devfn=40, errp=0x7fffffffcb60) at hw/pci/pci.c:1030
+ * #6  0x0000555555af76d3 in pci_qdev_realize (qdev=0x5555566fcc20, errp=0x7fffffffcb60) at hw/pci/pci.c:2021
+ * #7  0x0000555555a2d447 in device_set_realized (obj=0x5555566fcc20, value=true, errp=0x7fffffffcd30) at hw/core/qdev.c:826
+ * #8  0x0000555555c21bc7 in property_set_bool (obj=0x5555566fcc20, v=0x5555572103f0, name=0x555555db778a "realized", opaque=0x555556925990, errp=0x7fffffffcd30)
+ *     at qom/object.c:1984
+ * #9  0x0000555555c1fe4c in object_property_set (obj=0x5555566fcc20, v=0x5555572103f0, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1176
+ * #10 0x0000555555c22f04 in object_property_set_qobject (obj=0x5555566fcc20, value=0x5555575c4f80, name=0x555555db778a "realized", errp=0x7fffffffcd30)
+ *     at qom/qom-qobject.c:27
+ * #11 0x0000555555c20131 in object_property_set_bool (obj=0x5555566fcc20, value=true, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1242
+ * #12 0x0000555555990749 in qdev_device_add (opts=0x55555739f8d0, errp=0x7fffffffcda0) at qdev-monitor.c:627
+ * #13 0x0000555555990f32 in qmp_device_add (qdict=0x555556ffff10, ret_data=0x0, errp=0x7fffffffcde0) at qdev-monitor.c:807
+ * #14 0x00005555559bebd7 in hmp_device_add (mon=0x5555565fb820, qdict=0x555556ffff10) at hmp.c:2008
+ * #15 0x00005555558230ac in handle_hmp_command (mon=0x5555565fb820, cmdline=0x5555565fe2cb "e1000,netdev=nd1") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #16 0x0000555555825467 in monitor_command_cb (opaque=0x5555565fb820, cmdline=0x5555565fe2c0 "device_add e1000,netdev=nd1", readline_opaque=0x0)
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #17 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565fe2c0, ch=13) at util/readline.c:393
+ * #18 0x00005555558253ba in monitor_read (opaque=0x5555565fb820, buf=0x7fffffffcfa0 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #19 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #20 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #21 0x0000555555cce691 in fd_chr_read (chan=0x5555565d35f0, cond=G_IO_IN, opaque=0x5555565d33e0) at chardev/char-fd.c:66
+ * #22 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x5555574b9b40, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d33e0)
+ *     at io/channel-watch.c:84
+ * #23 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #24 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #25 0x0000555555d4f990 in os_host_main_loop_wait (timeout=198784721) at util/main-loop.c:238
+ * #26 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #27 0x00005555559967aa in main_loop () at vl.c:1866
+ * #28 0x000055555599dfbd in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4644
+ *
+ *
+ * hotplug nvme的例子:
+ * (gdb) bt
+ * #0  address_space_update_topology_pass (as=0x555556498b40 <address_space_memory>, old_view=0x7fffdc000c00, new_view=0x555556cfc690, adding=false)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:875
+ * #1  0x0000555555834dc9 in address_space_set_flatview (as=0x555556498b40 <address_space_memory>) at /home/zhang/kvm/qemu-3.0.0/memory.c:1004
+ * #2  0x0000555555834f89 in memory_region_transaction_commit () at /home/zhang/kvm/qemu-3.0.0/memory.c:1057
+ * #3  0x00005555558386eb in memory_region_set_enabled (mr=0x55555706cbd0, enabled=false) at /home/zhang/kvm/qemu-3.0.0/memory.c:2360
+ * #4  0x0000555555af2ea9 in pci_init_bus_master (pci_dev=0x55555706c870) at hw/pci/pci.c:96
+ * #5  0x0000555555af5249 in do_pci_register_device (pci_dev=0x55555706c870, name=0x5555564e9f40 "nvme", devfn=32, errp=0x7fffffffcbf0) at hw/pci/pci.c:1030
+ * #6  0x0000555555af76d3 in pci_qdev_realize (qdev=0x55555706c870, errp=0x7fffffffcbf0) at hw/pci/pci.c:2021
+ * #7  0x0000555555a2d447 in device_set_realized (obj=0x55555706c870, value=true, errp=0x7fffffffcdc0) at hw/core/qdev.c:826
+ * #8  0x0000555555c21bc7 in property_set_bool (obj=0x55555706c870, v=0x55555709f010, name=0x555555db778a "realized", opaque=0x55555715d760, errp=0x7fffffffcdc0)
+ *     at qom/object.c:1984
+ * #9  0x0000555555c1fe4c in object_property_set (obj=0x55555706c870, v=0x55555709f010, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1176
+ * #10 0x0000555555c22f04 in object_property_set_qobject (obj=0x55555706c870, value=0x55555675fec0, name=0x555555db778a "realized", errp=0x7fffffffcdc0)
+ *     at qom/qom-qobject.c:27
+ * #11 0x0000555555c20131 in object_property_set_bool (obj=0x55555706c870, value=true, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1242
+ * #12 0x0000555555990749 in qdev_device_add (opts=0x5555565c63a0, errp=0x7fffffffce30) at qdev-monitor.c:627
+ * #13 0x0000555555990f32 in qmp_device_add (qdict=0x55555709df10, ret_data=0x0, errp=0x7fffffffce70) at qdev-monitor.c:807
+ * #14 0x00005555559bebd7 in hmp_device_add (mon=0x5555565e0bd0, qdict=0x55555709df10) at hmp.c:2008
+ * #15 0x00005555558230ac in handle_hmp_command (mon=0x5555565e0bd0, cmdline=0x5555565f005b "nvme,drive=lightnvme,serial=deadbeaf1")
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #16 0x0000555555825467 in monitor_command_cb (opaque=0x5555565e0bd0, cmdline=0x5555565f0050 "device_add nvme,drive=lightnvme,serial=deadbeaf1", 
+ *     readline_opaque=0x0) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #17 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565f0050, ch=13) at util/readline.c:393
+ * #18 0x00005555558253ba in monitor_read (opaque=0x5555565e0bd0, buf=0x7fffffffd030 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #19 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #20 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #21 0x0000555555cce691 in fd_chr_read (chan=0x5555565d3310, cond=G_IO_IN, opaque=0x5555565d3100) at chardev/char-fd.c:66
+ * #22 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x555556ff37e0, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d3100)
+ *     at io/channel-watch.c:84
+ * #23 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #24 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #25 0x0000555555d4f990 in os_host_main_loop_wait (timeout=198688541) at util/main-loop.c:238
+ * #26 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #27 0x00005555559967aa in main_loop () at vl.c:1866
+ * #28 0x000055555599dfbd in main (argc=12, argv=0x7fffffffe4a8, envp=0x7fffffffe510) at vl.c:4644
+ * (gdb) p as->name
+ * $4 = 0x5555565c86e0 "memory"
+ *
+ * 逐一对比新旧FlatView的差别,然后进行更新, 比如将FlatView模型通过
+ * KVM_SET_USER_MEMORY_REGION注册到KVM模块中
+ */
 static void address_space_update_topology_pass(AddressSpace *as,
                                                const FlatView *old_view,
                                                const FlatView *new_view,
@@ -927,6 +1497,10 @@ static void address_space_update_topology_pass(AddressSpace *as,
             /* In new */
 
             if (adding) {
+                /*
+		 * 如果新增加了一个FlatRange,则会调用将该fr转换为一个
+		 * MemroyRegionSection,然后调用Listener的region_add
+		 */
                 MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);
             }
 
@@ -935,14 +1509,29 @@ static void address_space_update_topology_pass(AddressSpace *as,
     }
 }
 
+/*
+ * called by:
+ *   - memory.c|1294| <<flatviews_reset>> flatviews_init();
+ *   - memory.c|1361| <<address_space_update_topology>> flatviews_init();
+ *
+ * 就是"重新"初始化全局的GHashTable flat_views,
+ * 然后根据情况把root mr是NULL的FlatView放入
+ */
 static void flatviews_init(void)
 {
+    /*
+     * FlatView是内存最终的体现
+     *
+     * 这个后面mr是NULL的FlatView不知道放入flat_views做什么
+     */
     static FlatView *empty_view;
 
+    /* static GHashTable *flat_views; */
     if (flat_views) {
         return;
     }
 
+    /* flat_views是GHashTable的指针 */
     flat_views = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
                                        (GDestroyNotify) flatview_unref);
     if (!empty_view) {
@@ -955,14 +1544,26 @@ static void flatviews_init(void)
     }
 }
 
+/*
+ * called only by memory_region_transaction_commit()
+ *
+ * 核心思想是"重新"初始化全局的GHashTable flat_views,
+ * 为address_spaces链表的每一个AddressSpace生成一份FlatView
+ * 然后插入flat_views(GHashTable)
+ */
 static void flatviews_reset(void)
 {
     AddressSpace *as;
 
+    /* static GHashTable *flat_views; */
     if (flat_views) {
         g_hash_table_unref(flat_views);
         flat_views = NULL;
     }
+    /*
+     * 就是"重新"初始化全局的GHashTable flat_views,
+     * 然后根据情况把root mr是NULL的FlatView放入
+     */
     flatviews_init();
 
     /* Render unique FVs */
@@ -973,10 +1574,21 @@ static void flatviews_reset(void)
             continue;
         }
 
+	/*
+	 * 生成FlatView
+	 */
         generate_memory_topology(physmr);
     }
 }
 
+/*
+ * called by:
+ *   - memory.c|1411| <<address_space_update_topology>> address_space_set_flatview(as);
+ *   - memory.c|1442| <<memory_region_transaction_commit>> address_space_set_flatview(as);
+ *
+ * 核心思想是逐一对比AddressSpace的新旧FlatView的差别,然后进行更新,
+ * 比如将FlatView模型通过KVM_SET_USER_MEMORY_REGION注册到KVM模块中
+ */
 static void address_space_set_flatview(AddressSpace *as)
 {
     FlatView *old_view = address_space_to_flatview(as);
@@ -1001,6 +1613,10 @@ static void address_space_set_flatview(AddressSpace *as)
         if (!old_view2) {
             old_view2 = &tmpview;
         }
+	/*
+	 * 逐一对比新旧FlatView的差别,然后进行更新, 比如将FlatView模型通过
+	 * KVM_SET_USER_MEMORY_REGION注册到KVM模块中
+	 */
         address_space_update_topology_pass(as, old_view2, new_view, false);
         address_space_update_topology_pass(as, old_view2, new_view, true);
     }
@@ -1022,14 +1638,58 @@ static void address_space_set_flatview(AddressSpace *as)
     }
 }
 
+/*
+ * called only by:
+ *   - memory.c|2833| <<address_space_init>> address_space_update_topology(as);
+ *
+ * hotplug e1000网卡的例子:
+ * (gdb) bt
+ * #0  address_space_update_topology (as=0x5555566fce30) at /home/zhang/kvm/qemu-3.0.0/memory.c:1027
+ * #1  0x0000555555839bce in address_space_init (as=0x5555566fce30, root=0x5555566fce90, name=0x5555566fccd8 "e1000") at /home/zhang/kvm/qemu-3.0.0/memory.c:2801
+ * #2  0x0000555555af5232 in do_pci_register_device (pci_dev=0x5555566fcc20, name=0x5555565190c0 "e1000", devfn=40, errp=0x7fffffffcb60) at hw/pci/pci.c:1026
+ * #3  0x0000555555af76d3 in pci_qdev_realize (qdev=0x5555566fcc20, errp=0x7fffffffcb60) at hw/pci/pci.c:2021
+ * #4  0x0000555555a2d447 in device_set_realized (obj=0x5555566fcc20, value=true, errp=0x7fffffffcd30) at hw/core/qdev.c:826
+ * #5  0x0000555555c21bc7 in property_set_bool (obj=0x5555566fcc20, v=0x5555572103f0, name=0x555555db778a "realized", opaque=0x555556925990, errp=0x7fffffffcd30)
+ *     at qom/object.c:1984
+ * #6  0x0000555555c1fe4c in object_property_set (obj=0x5555566fcc20, v=0x5555572103f0, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1176
+ * #7  0x0000555555c22f04 in object_property_set_qobject (obj=0x5555566fcc20, value=0x5555575c4f80, name=0x555555db778a "realized", errp=0x7fffffffcd30)
+ *     at qom/qom-qobject.c:27
+ * #8  0x0000555555c20131 in object_property_set_bool (obj=0x5555566fcc20, value=true, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1242
+ * #9  0x0000555555990749 in qdev_device_add (opts=0x55555739f8d0, errp=0x7fffffffcda0) at qdev-monitor.c:627
+ * #10 0x0000555555990f32 in qmp_device_add (qdict=0x555556ffff10, ret_data=0x0, errp=0x7fffffffcde0) at qdev-monitor.c:807
+ * #11 0x00005555559bebd7 in hmp_device_add (mon=0x5555565fb820, qdict=0x555556ffff10) at hmp.c:2008
+ * #12 0x00005555558230ac in handle_hmp_command (mon=0x5555565fb820, cmdline=0x5555565fe2cb "e1000,netdev=nd1") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #13 0x0000555555825467 in monitor_command_cb (opaque=0x5555565fb820, cmdline=0x5555565fe2c0 "device_add e1000,netdev=nd1", readline_opaque=0x0)
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #14 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565fe2c0, ch=13) at util/readline.c:393
+ * #15 0x00005555558253ba in monitor_read (opaque=0x5555565fb820, buf=0x7fffffffcfa0 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #16 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #17 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #18 0x0000555555cce691 in fd_chr_read (chan=0x5555565d35f0, cond=G_IO_IN, opaque=0x5555565d33e0) at chardev/char-fd.c:66
+ * #19 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x5555574b9b40, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d33e0)
+ *     at io/channel-watch.c:84
+ * #20 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #21 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #22 0x0000555555d4f990 in os_host_main_loop_wait (timeout=198784721) at util/main-loop.c:238
+ * #23 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #24 0x00005555559967aa in main_loop () at vl.c:1866
+ * #25 0x000055555599dfbd in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4644
+ */
 static void address_space_update_topology(AddressSpace *as)
 {
     MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
 
     flatviews_init();
     if (!g_hash_table_lookup(flat_views, physmr)) {
+        /*
+	 * physmr可以临时理解成AddressSpace的root
+	 */
         generate_memory_topology(physmr);
     }
+    /*
+     * 核心思想是逐一对比AddressSpace的新旧FlatView的差别,然后进行更新,
+     * 比如将FlatView模型通过KVM_SET_USER_MEMORY_REGION注册到KVM模块中
+     */
     address_space_set_flatview(as);
 }
 
@@ -1049,18 +1709,46 @@ void memory_region_transaction_commit(void)
     --memory_region_transaction_depth;
     if (!memory_region_transaction_depth) {
         if (memory_region_update_pending) {
+            /*
+	     * 核心思想是"重新"初始化全局的GHashTable flat_views,
+	     * 为address_spaces链表的每一个AddressSpace生成一份FlatView
+	     * 然后插入flat_views(GHashTable)
+	     */
             flatviews_reset();
 
+	    /*
+	     * 从前向后遍历调用memory_listeners中的每个MemoryListener,
+	     * 并调用begin方法
+	     *
+	     * 设置beigin的地方:
+	     *   - hw/virtio/vhost.c|1232| <<vhost_dev_init>> .begin = vhost_begin,
+	     */
             MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);
 
+	    /*
+	     * address_spaces是一个链表 装着所有的AddressSpace
+	     */
             QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+                /*
+		 * 核心思想是逐一对比AddressSpace的新旧FlatView的差别,然后进行更新,
+		 * 比如将FlatView模型通过KVM_SET_USER_MEMORY_REGION注册到KVM模块中
+		 */
                 address_space_set_flatview(as);
                 address_space_update_ioeventfds(as);
             }
             memory_region_update_pending = false;
             ioeventfd_update_pending = false;
+	    /*
+	     * 设置commit的地方:
+	     *   - hw/virtio/vhost.c|1233| <<vhost_dev_init>> .commit = vhost_commit,
+	     *   - hw/virtio/virtio.c|2532| <<virtio_device_realize>> vdev->listener.commit = virtio_memory_listener_commit;
+	     *   - exec.c|1149| <<cpu_address_space_init>> newas->tcg_as_listener.commit = tcg_commit;
+	     */
             MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);
         } else if (ioeventfd_update_pending) {
+            /*
+	     * address_spaces是一个链表 装着所有的AddressSpace
+	     */
             QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
                 address_space_update_ioeventfds(as);
             }
@@ -1112,6 +1800,13 @@ static char *memory_region_escape_name(const char *name)
     return escaped;
 }
 
+/*
+ * called by:
+ *   - memory.c|1158| <<memory_region_init>> memory_region_do_init(mr, owner, name, size);
+ *   - memory.c|1691| <<memory_region_init_iommu>> memory_region_do_init(mr, owner, name, size);
+ *
+ * 比如system_memory的name是"system", size是UINT64_MAX, owner是NULL
+ */
 static void memory_region_do_init(MemoryRegion *mr,
                                   Object *owner,
                                   const char *name,
@@ -1127,6 +1822,19 @@ static void memory_region_do_init(MemoryRegion *mr,
 
     if (name) {
         char *escaped_name = memory_region_escape_name(name);
+	/*
+	 * 对于system的内存, 这里执行完了就是system[*], 在object_property_add()会把[*]改动了
+	 *
+	 * (gdb) bt
+	 * #0  object_property_add (obj=0x5555568512d0, name=0x555556851250 "system[*]", type=0x555556851530 "child<qemu:memory-region>", get=0x555555c5f037 <object_get_child_property>, set=0x0, 
+	 *     release=0x555555c5f0cb <object_finalize_child_property>, opaque=0x555556850cd0, errp=0x7fffffffe060) at qom/object.c:990
+	 * #1  0x0000555555c5f1e6 in object_property_add_child (obj=0x5555568512d0, name=0x555556851250 "system[*]", child=0x555556850cd0, errp=0x555556751590 <error_abort>) at qom/object.c:1507
+	 * #2  0x0000555555866c8c in memory_region_do_init (mr=0x555556850cd0, owner=0x5555568512d0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1136
+	 * #3  0x0000555555866cfb in memory_region_init (mr=0x555556850cd0, owner=0x0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1149
+	 * #4  0x0000555555803699 in memory_map_init () at /home/zhang/kvm/qemu-3.0.0/exec.c:3100
+	 * #5  0x0000555555804201 in cpu_exec_init_all () at /home/zhang/kvm/qemu-3.0.0/exec.c:3534
+	 * #6  0x00005555559dea90 in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4046
+	 */
         char *name_array = g_strdup_printf("%s[*]", escaped_name);
 
         if (!owner) {
@@ -1140,12 +1848,29 @@ static void memory_region_do_init(MemoryRegion *mr,
     }
 }
 
+/*
+ * 被非常多的外部调用
+ *
+ * 初始化MemoryRegion,比如:
+ *     根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ *     MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+ *     然后简单初始化MemoryRegion的各个field
+ */
 void memory_region_init(MemoryRegion *mr,
                         Object *owner,
                         const char *name,
                         uint64_t size)
 {
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     *
+     * MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+     */
     object_initialize(mr, sizeof(*mr), TYPE_MEMORY_REGION);
+    /*
+     * 简单初始化MemoryRegion的各个field
+     */
     memory_region_do_init(mr, owner, name, size);
 }
 
@@ -1166,6 +1891,10 @@ static void memory_region_get_container(Object *obj, Visitor *v,
     gchar *path = (gchar *)"";
 
     if (mr->container) {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         path = object_get_canonical_path(OBJECT(mr->container));
     }
     visit_type_str(v, name, &path, errp);
@@ -1201,6 +1930,12 @@ static void memory_region_get_size(Object *obj, Visitor *v, const char *name,
     visit_type_uint64(v, name, &value, errp);
 }
 
+/*
+ * TypeInfo memory_region_info.instance_init = memory_reagion_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void memory_region_initfn(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -1214,6 +1949,10 @@ static void memory_region_initfn(Object *obj)
     QTAILQ_INIT(&mr->subregions);
     QTAILQ_INIT(&mr->coalesced);
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     op = object_property_add(OBJECT(mr), "container",
                              "link<" TYPE_MEMORY_REGION ">",
                              memory_region_get_container,
@@ -1221,20 +1960,38 @@ static void memory_region_initfn(Object *obj)
                              NULL, NULL, &error_abort);
     op->resolve = memory_region_resolve_container;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(OBJECT(mr), "addr", "uint64",
                         memory_region_get_addr,
                         NULL, /* memory_region_set_addr */
                         NULL, NULL, &error_abort);
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(OBJECT(mr), "priority", "uint32",
                         memory_region_get_priority,
                         NULL, /* memory_region_set_priority */
                         NULL, NULL, &error_abort);
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(OBJECT(mr), "size", "uint64",
                         memory_region_get_size,
                         NULL, /* memory_region_set_size, */
                         NULL, NULL, &error_abort);
 }
 
+/*
+ * TypeInfo iommu_memory_region_info.instance_init = iommu_memory_region_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void iommu_memory_region_initfn(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -1326,6 +2083,10 @@ static void memory_region_ram_device_write(void *opaque, hwaddr addr,
     }
 }
 
+/*
+ * used by:
+ *   - memory.c|2043| <<memory_region_init_ram_device_ptr>> mr->ops = &ram_device_mem_ops;
+ */
 static const MemoryRegionOps ram_device_mem_ops = {
     .read = memory_region_ram_device_read,
     .write = memory_region_ram_device_write,
@@ -1489,6 +2250,109 @@ MemTxResult memory_region_dispatch_write(MemoryRegion *mr,
     }
 }
 
+/*
+ * [0]  mark_mmio_spte [kvm]
+ * [0]  set_spte [kvm]
+ * [0]  mmu_set_spte [kvm]
+ * [0]  __direct_map [kvm]
+ * [0]  tdp_page_fault [kvm]
+ * [0]  kvm_mmu_page_fault [kvm]
+ * [0]  kvm_arch_vcpu_ioctl_run [kvm]
+ * [0]  kvm_vcpu_ioctl [kvm]
+ * [0]  do_vfs_ioctl
+ * [0]  ksys_ioctl
+ * [0]  __x64_sys_ioctl
+ * [0]  do_syscall_64
+ * [0]  entry_SYSCALL_64_after_hwframe
+ *
+ * [0]  is_noslot_pfn()
+ * [0]  set_spte [kvm]
+ * [0]  mmu_set_spte [kvm]
+ * [0]  __direct_map [kvm]
+ * [0]  tdp_page_fault [kvm]
+ * [0]  kvm_mmu_page_fault [kvm]
+ * [0]  kvm_arch_vcpu_ioctl_run [kvm]
+ * [0]  kvm_vcpu_ioctl [kvm]
+ * [0]  do_vfs_ioctl
+ * [0]  ksys_ioctl
+ * [0]  __x64_sys_ioctl
+ * [0]  do_syscall_64
+ * [0]  entry_SYSCALL_64_after_hwframe
+ *
+ * [0]  __gfn_to_pfn_memslot [kvm]
+ * [0]  try_async_pf [kvm]
+ * [0]  tdp_page_fault [kvm]
+ * [0]  kvm_mmu_page_fault [kvm]
+ * [0]  kvm_arch_vcpu_ioctl_run [kvm]
+ * [0]  kvm_vcpu_ioctl [kvm]
+ * [0]  do_vfs_ioctl
+ * [0]  ksys_ioctl
+ * [0]  __x64_sys_ioctl
+ * [0]  do_syscall_64
+ * [0]  entry_SYSCALL_64_after_hwframe
+ *
+ * 应该是kvm misconfig中设置pte的代码:
+ *  362 static bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,
+ *  363                           kvm_pfn_t pfn, unsigned access)
+ *  364 {
+ *  365         if (unlikely(is_noslot_pfn(pfn))) {
+ *  366                 mark_mmio_spte(vcpu, sptep, gfn, access);
+ *  367                 return true;
+ *  368         }
+ *  369 
+ *  370         return false;
+ *  371 }
+ *
+ *
+ *  3856 static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,
+ *  3857                          gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable)
+ *  3858 {
+ *  3859         struct kvm_memory_slot *slot;
+ *  3860         bool async;
+ *  3861         
+ *  3863         // Don't expose private memslots to L2.
+ *  3865         if (is_guest_mode(vcpu) && !kvm_is_visible_gfn(vcpu->kvm, gfn)) {
+ *  3866                 *pfn = KVM_PFN_NOSLOT;
+ *  3867                 return false;
+ *  3868         }
+ *  3869         
+ *  3870         slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);
+ *  3871         async = false;
+ *  3872         *pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);
+ *  3873         if (!async)            
+ *  3874                 return false; // pfn has correct page already
+ *  3875 
+ *  3876         if (!prefault && kvm_can_do_async_pf(vcpu)) {
+ *  3877                 trace_kvm_try_async_get_page(gva, gfn);
+ *  3878                 if (kvm_find_async_pf_gfn(vcpu, gfn)) {
+ *  3879                         trace_kvm_async_pf_doublefault(gva, gfn);
+ *  3880                         kvm_make_request(KVM_REQ_APF_HALT, vcpu);
+ *  3881                         return true;
+ *  3882                 } else if (kvm_arch_setup_async_pf(vcpu, gva, gfn))
+ *  3883                         return true;
+ *  3884         }
+ *  3885 
+ *  3886         *pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);
+ *  3887         return false;
+ *  3888 }
+ *
+ *
+ * MMIO是通过设置spte的保留位来标志的.虚拟机内部第一次访问MMIO的gpa时,
+ * 发生了EPT_VIOLATION然后check gpa发现对应的pfn不存在(QEMU没有注册),那
+ * 么认为这是个MMIO,于是set_mmio_spte来标志它的spte是一个MMIO.后面再次访
+ * 问这个gpa时就发生EPT_MISCONFIG了,进而愉快地调用handle_ept_misconfig->
+ * handle_mmio_page_fault->x86_emulate_instruction来处理所有的MMIO操作了
+ */
+
+/*
+ * 初始化MemoryRegion,比如:
+ *     根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ *     MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+ *     然后简单初始化MemoryRegion的各个field
+ * 设置mr的ops, opaqueue和terminates=true
+ *
+ * 这里mr->ram是false!!!!!!!!!!!!!!1
+ */
 void memory_region_init_io(MemoryRegion *mr,
                            Object *owner,
                            const MemoryRegionOps *ops,
@@ -1502,6 +2366,13 @@ void memory_region_init_io(MemoryRegion *mr,
     mr->terminates = true;
 }
 
+/*
+ * called by:
+ *   - memory.c|3349| <<memory_region_init_ram>> memory_region_init_ram_nomigrate(mr, owner, name, size, &err);
+ *   - numa.c|499| <<allocate_system_memory_nonnuma>> memory_region_init_ram_nomigrate(mr, owner, name, ram_size, &error_fatal);
+ *   - numa.c|506| <<allocate_system_memory_nonnuma>> memory_region_init_ram_nomigrate(mr, owner, name, ram_size, &error_fatal);
+ *   - hw/pci-host/prep.c|308| <<raven_realize>> memory_region_init_ram_nomigrate(&s->bios, OBJECT(s), "bios", BIOS_SIZE,
+ */
 void memory_region_init_ram_nomigrate(MemoryRegion *mr,
                                       Object *owner,
                                       const char *name,
@@ -1511,6 +2382,11 @@ void memory_region_init_ram_nomigrate(MemoryRegion *mr,
     memory_region_init_ram_shared_nomigrate(mr, owner, name, size, false, errp);
 }
 
+/*
+ * called by:
+ *   - memory.c|1633| <<memory_region_init_ram_nomigrate>> memory_region_init_ram_shared_nomigrate(mr, owner, name, size, false, errp);
+ *   - backends/hostmem-ram.c|31| <<ram_backend_memory_alloc>> memory_region_init_ram_shared_nomigrate(&backend->mr, OBJECT(backend), path,
+ */
 void memory_region_init_ram_shared_nomigrate(MemoryRegion *mr,
                                              Object *owner,
                                              const char *name,
@@ -1610,6 +2486,22 @@ void memory_region_init_ram_device_ptr(MemoryRegion *mr,
     mr->opaque = mr;
 }
 
+/*
+ * 调用的一个例子:
+ * 1362     memory_region_init_alias(ram_below_4g, NULL, "ram-below-4g", ram,
+ * 1363                              0, pcms->below_4g_mem_size);
+ * 1364     memory_region_add_subregion(system_memory, 0, ram_below_4g);
+ *
+ * alias: a subsection of another region.  Aliases allow a region to be
+ * split apart into discontiguous regions.  Examples of uses are memory banks
+ * used when the guest address space is smaller than the amount of RAM
+ * addressed, or a memory controller that splits main memory to expose a "PCI
+ * hole".  Aliases may point to any type of region, including other aliases,
+ * but an alias may not point back to itself, directly or indirectly.
+ * You initialize these with memory_region_init_alias().
+ *
+ * 把mr设置为orig的一个alias, 也就是表示orig的一部分
+ */
 void memory_region_init_alias(MemoryRegion *mr,
                               Object *owner,
                               const char *name,
@@ -1617,6 +2509,12 @@ void memory_region_init_alias(MemoryRegion *mr,
                               hwaddr offset,
                               uint64_t size)
 {
+    /*
+     * 初始化MemoryRegion,比如:
+     *     根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     *     MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+     *     然后简单初始化MemoryRegion的各个field
+     */
     memory_region_init(mr, owner, name, size);
     mr->alias = orig;
     mr->alias_offset = offset;
@@ -1674,6 +2572,12 @@ void memory_region_init_iommu(void *_iommu_mr,
     iommu_mr->iommu_notify_flags = IOMMU_NOTIFIER_NONE;
 }
 
+/*
+ * TypeInfo memory_region_info.instance_finalize = memory_region_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void memory_region_finalize(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -2290,41 +3194,112 @@ void memory_region_del_eventfd(MemoryRegion *mr,
     memory_region_transaction_commit();
 }
 
+/*
+ * 按照priority把subregion插入到上一层的MemoryRegion的subregions链表
+ * "上一层"的意思就是说这个region是上一层的subregion
+ * 没有好的位置就插入到最后
+ * 最后还要memory_region_transaction_commit()
+ */
 static void memory_region_update_container_subregions(MemoryRegion *subregion)
 {
+    /* container里存着subregion上一层的MemoryRegion */
     MemoryRegion *mr = subregion->container;
     MemoryRegion *other;
 
     memory_region_transaction_begin();
 
     memory_region_ref(subregion);
+    /*
+     * mr是参数subregion的上一层的MemoryRegion
+     *
+     * 按照priority把subregion插入到上一层的MemoryRegion的subregions链表
+     * "上一层"的意思就是说这个region是上一层的subregion
+     */
     QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {
         if (subregion->priority >= other->priority) {
             QTAILQ_INSERT_BEFORE(other, subregion, subregions_link);
             goto done;
         }
     }
+    /* 没有好的位置就插入到最后 */
     QTAILQ_INSERT_TAIL(&mr->subregions, subregion, subregions_link);
 done:
+    /* 如果memory_region_update_pending了memory_region_transaction_commit()就会做很多工作 */
     memory_region_update_pending |= mr->enabled && subregion->enabled;
     memory_region_transaction_commit();
 }
 
+/*
+ * called by:
+ *   - memory.c|2627| <<memory_region_add_subregion>> memory_region_add_subregion_common(mr, offset, subregion);
+ *   - memory.c|2636| <<memory_region_add_subregion_overlap>> memory_region_add_subregion_common(mr, offset, subregion);
+ *
+ * offset应该是物理内存中的offset, 把subregion挂到这个地址?
+ *
+ * 设置subregion的container和addr (记录该region在物理内存的地址)
+ * 按照priority把subregion插入到上一层的MemoryRegion的subregions链表
+ * "上一层"的意思就是说这个region是上一层的subregion
+ * 没有好的位置就插入到最后
+ * 最后还要memory_region_transaction_commit()
+ */
 static void memory_region_add_subregion_common(MemoryRegion *mr,
                                                hwaddr offset,
                                                MemoryRegion *subregion)
 {
     assert(!subregion->container);
     subregion->container = mr;
+    /* 记录该region在物理内存的地址 */
     subregion->addr = offset;
+    /*
+     * 按照priority把subregion插入到上一层的MemoryRegion的subregions链表
+     * "上一层"的意思就是说这个region是上一层的subregion
+     * 没有好的位置就插入到最后
+     * 最后还要memory_region_transaction_commit()
+     */
     memory_region_update_container_subregions(subregion);
 }
 
+/*
+ * 设置内存地址的地方
+ *
+ * 一些使用的例子:
+ *   - hw/i386/pc.c|1352| <<pc_memory_init>> memory_region_add_subregion(system_memory, 0, ram_below_4g);
+ *   - hw/i386/pc.c|1359| <<pc_memory_init>> memory_region_add_subregion(system_memory, 0x100000000ULL,
+ *   - hw/i386/pc.c|1412| <<pc_memory_init>> memory_region_add_subregion(system_memory, machine->device_memory->base,
+ *   - hw/i386/pc.c|1578| <<pc_basic_device_init>> memory_region_add_subregion(isa_bus->address_space_io, 0x80, ioport80_io);
+ *   - hw/i386/pc.c|1581| <<pc_basic_device_init>> memory_region_add_subregion(isa_bus->address_space_io, 0xf0, ioportF0_io);
+ *   - hw/vfio/common.c|858| <<vfio_region_mmap>> memory_region_add_subregion(region->mem, region->mmaps[i].offset,
+ *   - hw/vfio/pci-quirks.c|429| <<vfio_vga_probe_ati_3c3_quirk>> memory_region_add_subregion(&vdev->vga->region[QEMU_PCI_VGA_IO_HI].mem,
+ *   - hw/vfio/pci-quirks.c|686| <<vfio_vga_probe_nvidia_3d0_quirk>> memory_region_add_subregion(&vdev->vga->region[QEMU_PCI_VGA_IO_HI].mem,
+ *   - hw/vfio/pci-quirks.c|691| <<vfio_vga_probe_nvidia_3d0_quirk>> memory_region_add_subregion(&vdev->vga->region[QEMU_PCI_VGA_IO_HI].mem,
+ *   - hw/vfio/pci.c|1676| <<vfio_bar_register>> memory_region_add_subregion(bar->mr, 0, bar->region.mem);
+ *   - hw/virtio/virtio-pci.c|1517| <<virtio_pci_modern_region_map>> memory_region_add_subregion(mr, region->offset, &region->mr);
+ *   - hw/pci/msix.c|348| <<msix_init>> memory_region_add_subregion(table_bar, table_offset, &dev->msix_table_mmio);
+ *   - hw/pci/msix.c|351| <<msix_init>> memory_region_add_subregion(pba_bar, pba_offset, &dev->msix_pba_mmio);
+ *   - hw/pci/pci.c|97| <<pci_init_bus_master>> memory_region_add_subregion(&pci_dev->bus_master_container_region, 0,
+ *   - hw/pci/pcie_host.c|118| <<pcie_host_mmcfg_map>> memory_region_add_subregion(get_system_memory(), e->base_addr, &e->mmio);
+ *   - hw/i386/xen/xen-hvm.c|241| <<xen_ram_init>> memory_region_add_subregion(sysmem, 0xc0000, &ram_lo);
+ *
+ * offset应该是物理内存中的offset, 把subregion挂到这个地址?
+ *
+ * 设置subregion的container和addr (记录该region在物理内存的地址)
+ * 按照priority=0把subregion插入到上一层的MemoryRegion的subregions链表
+ * "上一层"的意思就是说这个region是上一层的subregion
+ * 没有好的位置就插入到最后
+ * 最后还要memory_region_transaction_commit()
+ */
 void memory_region_add_subregion(MemoryRegion *mr,
                                  hwaddr offset,
                                  MemoryRegion *subregion)
 {
     subregion->priority = 0;
+    /*
+     * 设置subregion的container和addr (记录该region在物理内存的地址)
+     * 按照priority把subregion插入到上一层的MemoryRegion的subregions链表
+     * "上一层"的意思就是说这个region是上一层的subregion
+     * 没有好的位置就插入到最后
+     * 最后还要memory_region_transaction_commit()
+     */
     memory_region_add_subregion_common(mr, offset, subregion);
 }
 
@@ -2391,6 +3366,23 @@ static void memory_region_readd_subregion(MemoryRegion *mr)
     }
 }
 
+/*
+ * 被很多看似无关的调用:
+ *   - hw/acpi/ich9.c|130| <<ich9_pm_iospace_update>> memory_region_set_address(&pm->io, pm->pm_io_base);
+ *   - hw/acpi/piix4.c|140| <<pm_io_space_update>> memory_region_set_address(&s->io, s->io_base);
+ *   - hw/acpi/piix4.c|153| <<smbus_io_space_update>> memory_region_set_address(&s->smb.io, s->smb_io_base);
+ *   - hw/isa/vt82c686.c|223| <<pm_io_space_update>> memory_region_set_address(&s->io, pm_io_base);
+ *   - hw/misc/mips_cmgcr.c|37| <<update_gcr_base>> memory_region_set_address(&gcr->iomem, gcr->gcr_base);
+ *   - hw/misc/mips_cmgcr.c|50| <<update_cpc_base>> memory_region_set_address(gcr->cpc_mr,
+ *   - hw/misc/mips_cmgcr.c|63| <<update_gic_base>> memory_region_set_address(gcr->gic_mr,
+ *   - hw/misc/mips_itu.c|91| <<itc_reconfigure>> memory_region_set_address(mr, address);
+ *   - hw/pci-host/designware.c|89| <<designware_pcie_root_update_msi_mapping>> memory_region_set_address(mem, base);
+ *   - hw/pci-host/designware.c|269| <<designware_pcie_update_viewport>> memory_region_set_address(current, base);
+ *   - hw/pci-host/q35.c|423| <<mch_update_smram>> memory_region_set_address(&mch->tseg_window,
+ *   - hw/ppc/rs6000_mc.c|112| <<rs6000mc_port0820_write>> memory_region_set_address(&s->simm[socket - 1],
+ *   - hw/ppc/rs6000_mc.c|186| <<rs6000mc_realize>> memory_region_set_address(&s->simm[socket], start_address);
+ *   - hw/ssi/aspeed_smc.c|373| <<aspeed_smc_flash_set_segment>> memory_region_set_address(&fl->mmio, seg.addr - s->ctrl->flash_window_base);
+ */
 void memory_region_set_address(MemoryRegion *mr, hwaddr addr)
 {
     if (addr != mr->addr) {
@@ -2633,6 +3625,29 @@ static void listener_del_address_space(MemoryListener *listener,
     flatview_unref(view);
 }
 
+/*
+ * 注意kvm的是重点
+ * accel/kvm/kvm-all.c|899| <<kvm_memory_listener_register>> memory_listener_register(&kml->listener, as);
+ * accel/kvm/kvm-all.c|1699| <<kvm_init>> memory_listener_register(&kvm_io_listener,
+ *								   &address_space_io);
+ * exec.c|929| <<cpu_address_space_init>> memory_listener_register(&newas->tcg_as_listener, as);
+ * hw/i386/xen/xen-hvm.c|1472| <<xen_hvm_init>> memory_listener_register(&state->memory_listener, &address_space_memory);
+ * hw/i386/xen/xen-hvm.c|1476| <<xen_hvm_init>> memory_listener_register(&state->io_listener, &address_space_io);
+ * hw/vfio/common.c|1151| <<vfio_connect_container>> memory_listener_register(&container->prereg_listener,
+ * hw/vfio/common.c|1210| <<vfio_connect_container>> memory_listener_register(&container->listener, container->space->as);
+ * hw/virtio/vhost.c|1277| <<vhost_dev_init>> memory_listener_register(&hdev->memory_listener, &address_space_memory);
+ * hw/virtio/vhost.c|1503| <<vhost_dev_start>> memory_listener_register(&hdev->iommu_listener, vdev->dma_as);
+ * hw/virtio/virtio.c|2533| <<virtio_device_realize>> memory_listener_register(&vdev->listener, vdev->dma_as);
+ * hw/xen/xen_pt.c|910| <<xen_pt_realize>> memory_listener_register(&s->memory_listener, &address_space_memory);
+ * hw/xen/xen_pt.c|911| <<xen_pt_realize>> memory_listener_register(&s->io_listener, &address_space_io);
+ * memory_mapping.c|270| <<guest_phys_blocks_append>> memory_listener_register(&g.listener, &address_space_memory);
+ *
+ * 进行内存更新有很多个点,比如我们新创建了一个AddressSpace address_space_init,再比如我们将
+ * 一个mr添加到另一个mr的subregions中memory_region_add_subregion,再比如我们更改了一端内存
+ * 的属性memory_region_set_readonly,将一个mr设置使能或者非使能memory_region_set_enabled,
+ * 总之一句话,我们修改了虚拟机的内存布局/属性时,就需要通知到各个Listener,这包括各个AddressSpace
+ * 对应的,以及kvm注册的,这个过程叫做commit,通过函数memory_region_transaction_commit实现.
+ */
 void memory_listener_register(MemoryListener *listener, AddressSpace *as)
 {
     MemoryListener *other = NULL;
@@ -2788,6 +3803,16 @@ void memory_region_invalidate_mmio_ptr(MemoryRegion *mr, hwaddr offset,
                           RUN_ON_CPU_HOST_PTR(invalidate_data));
 }
 
+/*
+ * 被很多外部调用, 一些调用的例子:
+ *   - exec.c|3109| <<memory_map_init>> address_space_init(&address_space_memory, system_memory, "memory");
+ *   - exec.c|3114| <<memory_map_init>> address_space_init(&address_space_io, system_io, "I/O");
+ *   - exec.c|906| <<cpu_address_space_init>> address_space_init(as, mr, as_name);
+ *   - hw/i386/amd_iommu.c|1055| <<amdvi_host_dma_iommu>> address_space_init(&iommu_as[devfn]->as,
+ *   - hw/i386/intel_iommu.c|2934| <<vtd_find_add_as>> address_space_init(&vtd_dev_as->as, &vtd_dev_as->root, name);
+ *   - hw/pci/pci.c|1047| <<do_pci_register_device>> address_space_init(&pci_dev->bus_master_as,
+ *   - target/i386/kvm.c|1372| <<register_smram_listener>> address_space_init(&smram_address_space, &smram_as_root, "KVM-SMRAM");
+ */
 void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
 {
     memory_region_ref(root);
@@ -2796,7 +3821,11 @@ void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
     as->ioeventfd_nb = 0;
     as->ioeventfds = NULL;
     QTAILQ_INIT(&as->listeners);
+    /* 把AddressSpace插入全局链表address_spaces */
     QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
+    /*
+     * 从memory_map_init()调用来的时候, name的例子是"memory"或者"I/O"
+     */
     as->name = g_strdup(name ? name : "anonymous");
     address_space_update_topology(as);
     address_space_update_ioeventfds(as);
@@ -2867,6 +3896,10 @@ static void mtree_expand_owner(fprintf_function mon_printf, void *f,
     if (dev && dev->id) {
         mon_printf(f, " id=%s", dev->id);
     } else {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         gchar *canonical_path = object_get_canonical_path(obj);
         if (canonical_path) {
             mon_printf(f, " path=%s", canonical_path);
@@ -3232,7 +4265,7 @@ static const TypeInfo memory_region_info = {
     .parent             = TYPE_OBJECT,
     .name               = TYPE_MEMORY_REGION,
     .instance_size      = sizeof(MemoryRegion),
-    .instance_init      = memory_region_initfn,
+    .instance_init      = memory_region_initfn, // 一个MemoryRegion有addr和size等属性
     .instance_finalize  = memory_region_finalize,
 };
 
@@ -3247,8 +4280,13 @@ static const TypeInfo iommu_memory_region_info = {
 
 static void memory_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&memory_region_info);
     type_register_static(&iommu_memory_region_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(memory_register_types)
diff --git a/migration/migration.c b/migration/migration.c
index b7d9854..454c6d3 100644
--- a/migration/migration.c
+++ b/migration/migration.c
@@ -382,6 +382,10 @@ static void process_incoming_migration_bh(void *opaque)
     migration_incoming_state_destroy();
 }
 
+/*
+ * used by:
+ *   - migration/migration.c|465| <<migration_incoming_process>> Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
+ */
 static void process_incoming_migration_co(void *opaque)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -460,6 +464,26 @@ static void migration_incoming_setup(QEMUFile *f)
     qemu_file_set_blocking(f, false);
 }
 
+/*
+ * tcp迁移的例子:
+ * (gdb) bt
+ * #0  migration_incoming_process () at migration/migration.c:465
+ * #1  0x0000555555bf8d8a in migration_ioc_process_incoming (ioc=0x555557207730) at migration/migration.c:539
+ * #2  0x0000555555bffd38 in migration_channel_process_incoming (ioc=0x555557207730) at migration/channel.c:47
+ * #3  0x0000555555bfe8b7 in socket_accept_incoming_migration (listener=0x5555572dbbc0, cioc=0x555557207730, opaque=0x0) at migration/socket.c:166
+ * #4  0x0000555555d53b34 in qio_net_listener_channel_func (ioc=0x5555572dbd70, condition=G_IO_IN, opaque=0x5555572dbbc0) at io/net-listener.c:53
+ * #5  0x0000555555d4f6b7 in qio_channel_fd_source_dispatch (source=0x55555732f500, callback=0x555555d53a88 <qio_net_listener_channel_func>, user_data=0x5555572dbbc0) at io/channel-watch.c:84
+ * #6  0x00007ffff50e004a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #7  0x0000555555db0d34 in glib_pollfds_poll () at util/main-loop.c:215
+ * #8  0x0000555555db0da2 in os_host_main_loop_wait (timeout=1000000000) at util/main-loop.c:238
+ * #9  0x0000555555db0e5b in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #10 0x00005555559dee92 in main_loop () at vl.c:1866
+ * #11 0x00005555559e66a5 in main (argc=18, argv=0x7fffffffe398, envp=0x7fffffffe430) at vl.c:4644
+ *
+ * called by:
+ *   - migration/migration.c|508| <<migration_fd_process_incoming>> migration_incoming_process();
+ *   - migration/migration.c|539| <<migration_ioc_process_incoming>> migration_incoming_process();
+ */
 void migration_incoming_process(void)
 {
     Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
@@ -498,6 +522,10 @@ static bool postcopy_try_recover(QEMUFile *f)
     return false;
 }
 
+/*
+ * called only by:
+ *   - migration/rdma.c|3690| <<rdma_accept_incoming_migration>> migration_fd_process_incoming(f);
+ */
 void migration_fd_process_incoming(QEMUFile *f)
 {
     if (postcopy_try_recover(f)) {
@@ -508,6 +536,10 @@ void migration_fd_process_incoming(QEMUFile *f)
     migration_incoming_process();
 }
 
+/*
+ * called only by:
+ *   - migration/channel.c|47| <<migration_channel_process_incoming>> migration_ioc_process_incoming(ioc);
+ */
 void migration_ioc_process_incoming(QIOChannel *ioc)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
diff --git a/numa.c b/numa.c
index 5f6367b..abc8bcc 100644
--- a/numa.c
+++ b/numa.c
@@ -346,6 +346,10 @@ void numa_default_auto_assign_ram(MachineClass *mc, NodeInfo *nodes,
     nodes[i].node_mem = size - usedmem;
 }
 
+/*
+ * called only by:
+ *   - hw/core/machine.c|839| <<machine_run_board_init>> numa_complete_configuration(machine);
+ */
 void numa_complete_configuration(MachineState *ms)
 {
     int i;
diff --git a/qapi/qapi-visit-core.c b/qapi/qapi-visit-core.c
index d9a1137..44d7291 100644
--- a/qapi/qapi-visit-core.c
+++ b/qapi/qapi-visit-core.c
@@ -186,6 +186,7 @@ void visit_type_uint16(Visitor *v, const char *name, uint16_t *obj,
     trace_visit_type_uint16(v, name, obj);
     value = *obj;
     visit_type_uintN(v, &value, name, UINT16_MAX, "uint16_t", errp);
+    /* 这一句才是核心的 */
     *obj = value;
 }
 
diff --git a/qapi/qobject-input-visitor.c b/qapi/qobject-input-visitor.c
index da57f4c..27269ff 100644
--- a/qapi/qobject-input-visitor.c
+++ b/qapi/qobject-input-visitor.c
@@ -658,6 +658,11 @@ static void qobject_input_free(Visitor *v)
     g_free(qiv);
 }
 
+/*
+ * QObjectInputVisitor的root里存着QObject
+ *
+ * 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是QObject
+ */
 static QObjectInputVisitor *qobject_input_visitor_base_new(QObject *obj)
 {
     QObjectInputVisitor *v = g_malloc0(sizeof(*v));
@@ -681,8 +686,13 @@ static QObjectInputVisitor *qobject_input_visitor_base_new(QObject *obj)
     return v;
 }
 
+/*
+ * 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是QObject
+ * 返回包含的Visitor
+ */
 Visitor *qobject_input_visitor_new(QObject *obj)
 {
+    /* 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是QObject */
     QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);
 
     v->visitor.type_int64 = qobject_input_type_int64;
diff --git a/qdev-monitor.c b/qdev-monitor.c
index 61e0300..68c2618 100644
--- a/qdev-monitor.c
+++ b/qdev-monitor.c
@@ -166,9 +166,30 @@ static void qdev_print_devinfos(bool show_no_user)
     g_slist_free(list);
 }
 
+/*
+ * 从qdev_device_add()为了virtio block iothread参数:
+ * (gdb) bt
+ * #0  object_set_link_property (obj=0x55555771a460, v=0x55555771f150, name=0x55555771e9b0 "iothread", opaque=0x55555771cd90, errp=0x7fffffffdf78) at qom/object.c:1595
+ * #1  0x0000555555c1fe4c in object_property_set (obj=0x55555771a460, v=0x55555771f150, name=0x55555771e9b0 "iothread", errp=0x7fffffffdf78) at qom/object.c:1176
+ * #2  0x0000555555c229f1 in property_set_alias (obj=0x5555577122f0, v=0x55555771f150, name=0x555556536520 "iothread", opaque=0x55555771e990, errp=0x7fffffffdf78)
+ *     at qom/object.c:2330
+ * #3  0x0000555555c1fe4c in object_property_set (obj=0x5555577122f0, v=0x55555771f150, name=0x555556536520 "iothread", errp=0x7fffffffdf78) at qom/object.c:1176
+ * #4  0x0000555555c2086b in object_property_parse (obj=0x5555577122f0, string=0x5555565364c0 "io1", name=0x555556536520 "iothread", errp=0x7fffffffdf78) at qom/object.c:1402
+ * #5  0x000055555598f2a6 in set_property (opaque=0x5555577122f0, name=0x555556536520 "iothread", value=0x5555565364c0 "io1", errp=0x7fffffffe000) at qdev-monitor.c:180
+ * #6  0x0000555555d66fd7 in qemu_opt_foreach (opts=0x5555565362f0, func=0x55555598f21b <set_property>, opaque=0x5555577122f0, errp=0x7fffffffe000) at util/qemu-option.c:580
+ * #7  0x000055555599071a in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe078) at qdev-monitor.c:622
+ * #8  0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+ * #9  0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x000055555599dd61 in main (argc=16, argv=0x7fffffffe3e8, envp=0x7fffffffe470) at vl.c:4542
+ */
 static int set_property(void *opaque, const char *name, const char *value,
                         Error **errp)
 {
+    /*
+     * 如果从qdev_device_add()为了virtio block iothread参数:
+     *     name  = "iothread";
+     *     value = "io1"; (qemu-system-x86_64中给virtio block的iothread的id)
+     */
     Object *obj = opaque;
     Error *err = NULL;
 
@@ -177,6 +198,11 @@ static int set_property(void *opaque, const char *name, const char *value,
     if (strcmp(name, "bus") == 0)
         return 0;
 
+    /* 如果从qdev_device_add()为了virtio block iothread参数:
+     *   obj   : VirtIOBlock
+     *   value : "io1"; (qemu-system-x86_64中给virtio block的iothread的id)
+     *   name  : "iothread"
+     */
     object_property_parse(obj, value, name, &err);
     if (err != NULL) {
         error_propagate(errp, err);
@@ -219,6 +245,12 @@ static DeviceClass *qdev_get_device_class(const char **driver, Error **errp)
         }
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {
         if (*driver != original_name) {
             error_setg(errp, "'%s' (alias '%s') is not a valid device model"
@@ -421,6 +453,12 @@ static BusState *qbus_find_recursive(BusState *bus, const char *name,
     if (name) {
         match = !strcmp(bus->name, name);
     } else {
+        /*
+	 * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	 * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+	 * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+	 * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+	 */
         match = !!object_dynamic_cast(OBJECT(bus), bus_typename);
     }
 
@@ -536,6 +574,15 @@ static BusState *qbus_find(const char *path, Error **errp)
     return bus;
 }
 
+/*
+ * called by:
+ *   - qdev-monitor.c|764| <<qdev_device_add>> qdev_set_id(dev, qemu_opts_id(opts));
+ *   - hw/xen/xen_backend.c|277| <<xen_be_get_xendev>> qdev_set_id(DEVICE(xendev), g_strdup_printf("xen-%s-%d", type, dev));
+ *
+ * 如果参数id不为NULL, 把DeviceState->id设置为参数的id
+ * 如果DeviceState->id不为NULL, 在/machine/peripheral下添加一个dev->id的child, 指向DeviceState
+ * 否则在/machine/peripheral-anon下添加一个device[%d]的child, 指向DeviceState
+ */
 void qdev_set_id(DeviceState *dev, const char *id)
 {
     if (id) {
@@ -543,9 +590,16 @@ void qdev_set_id(DeviceState *dev, const char *id)
     }
 
     if (dev->id) {
+        /*
+	 * 在/machine/peripheral下添加一个dev->id的child, 指向DeviceState
+	 * 比如带id的virtio-block-pci
+	 */
         object_property_add_child(qdev_get_peripheral(), dev->id,
                                   OBJECT(dev), NULL);
     } else {
+        /*
+	 * 在/machine/peripheral-anon下添加一个device[%d]的child, 指向DeviceState
+	 */
         static int anon_count;
         gchar *name = g_strdup_printf("device[%d]", anon_count++);
         object_property_add_child(qdev_get_peripheral_anon(), name,
@@ -554,6 +608,49 @@ void qdev_set_id(DeviceState *dev, const char *id)
     }
 }
 
+/*
+ * 初始化添加设备:
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ *
+ *
+ * hotplug添加设备:
+ * (gdb) bt
+ * #0  qdev_device_add (opts=0x5555574b0490, errp=0x7fffffffcd40) at qdev-monitor.c:558
+ * #1  0x00005555559d961a in qmp_device_add (qdict=0x555557c9bc90, ret_data=0x0, errp=0x7fffffffcd80) at qdev-monitor.c:807
+ * #2  0x0000555555a072bf in hmp_device_add (mon=0x5555568a7450, qdict=0x555557c9bc90) at hmp.c:2008
+ * #3  0x000055555585b273 in handle_hmp_command (mon=0x5555568a7450, cmdline=0x5555568b1a0b "virtio-blk-pci,drive=myh1,id=virtio-disk1,num-queues=2,iothread=io2") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #4  0x000055555585d62e in monitor_command_cb (opaque=0x5555568a7450, cmdline=0x5555568b1a00 "device_add virtio-blk-pci,drive=myh1,id=virtio-disk1,num-queues=2,iothread=io2", readline_opaque=0x0)
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #5  0x0000555555dcda60 in readline_handle_byte (rs=0x5555568b1a00, ch=13) at util/readline.c:393
+ * #6  0x000055555585d581 in monitor_read (opaque=0x5555568a7450, buf=0x7fffffffcf40 "\r\260\361UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #7  0x0000555555d2d217 in qemu_chr_be_write_impl (s=0x555556893ab0, buf=0x7fffffffcf40 "\r\260\361UUU", len=1) at chardev/char.c:175
+ * #8  0x0000555555d2d27b in qemu_chr_be_write (s=0x555556893ab0, buf=0x7fffffffcf40 "\r\260\361UUU", len=1) at chardev/char.c:187
+ * #9  0x0000555555d2f98f in fd_chr_read (chan=0x555556893cf0, cond=G_IO_IN, opaque=0x555556893ab0) at chardev/char-fd.c:66
+ * #10 0x0000555555d4f6b7 in qio_channel_fd_source_dispatch (source=0x555556a65250, callback=0x555555d2f831 <fd_chr_read>, user_data=0x555556893ab0) at io/channel-watch.c:84
+ * #11 0x00007ffff50e004a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #12 0x0000555555db0d34 in glib_pollfds_poll () at util/main-loop.c:215
+ * #13 0x0000555555db0da2 in os_host_main_loop_wait (timeout=499000000) at util/main-loop.c:238
+ * #14 0x0000555555db0e5b in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #15 0x00005555559dee92 in main_loop () at vl.c:1866
+ * #16 0x00005555559e66a5 in main (argc=16, argv=0x7fffffffe3b8, envp=0x7fffffffe440) at vl.c:4644
+ *
+ *
+ * called by:
+ *   - vl.c|2314| <<device_init_func>> dev = qdev_device_add(opts, &err);
+ *   - qdev-monitor.c|858| <<qmp_device_add>> dev = qdev_device_add(opts, &local_err);
+ *   - hw/usb/xen-usb.c|764| <<usbback_portid_add>> usbif->ports[port - 1].dev = USB_DEVICE(qdev_device_add(opts, &local_err));
+ */
 DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
 {
     DeviceClass *dc;
@@ -562,6 +659,9 @@ DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
     BusState *bus = NULL;
     Error *err = NULL;
 
+    /*
+     * 比如, driver的例子是"virtio-blk-pci"
+     */
     driver = qemu_opt_get(opts, "driver");
     if (!driver) {
         error_setg(errp, QERR_MISSING_PARAMETER, "driver");
@@ -569,12 +669,40 @@ DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
     }
 
     /* find driver */
+    /*
+     * virtio-blk-pci的例子:
+     * (gdb) p *dc
+     * $2 = {
+     *   parent_class = {
+     *     type = 0x5555567e4de0, 
+     *     interfaces = 0x5555568486b0, 
+     *     object_cast_cache = {0x0, 0x0, 0x0, 0x0}, 
+     *     class_cast_cache = {0x555555f66eb4 "virtio-pci", 0x555555f0418f "device", 0x555555f4b070 "device", 0x555555edf795 "device"}, 
+     *     unparent = 0x555555a7d568 <device_unparent>, 
+     *     properties = 0x55555684be40
+     *   }, 
+     *   categories = {4}, 
+     *   fw_name = 0x0, 
+     *   desc = 0x0, 
+     *   props = 0x55555672a300 <virtio_blk_pci_properties>, 
+     *   user_creatable = true, 
+     *   hotpluggable = true, 
+     *   reset = 0x555555beed40 <virtio_pci_reset>, 
+     *   realize = 0x555555bef065 <virtio_pci_dc_realize>, 
+     *   unrealize = 0x555555b488da <pci_qdev_unrealize>, 
+     *   vmsd = 0x0, 
+     *   bus_type = 0x555555f4b077 "PCI"
+     * }
+     */
     dc = qdev_get_device_class(&driver, errp);
     if (!dc) {
         return NULL;
     }
 
     /* find bus */
+    /*
+     * 对于virtio-blk-pci来说,如果参数没有设置bus, path就是NULL
+     */
     path = qemu_opt_get(opts, "bus");
     if (path != NULL) {
         bus = qbus_find(path, errp);
@@ -587,6 +715,58 @@ DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
             return NULL;
         }
     } else if (dc->bus_type != NULL) {
+        /*
+	 * 对于virtio-blk-pci的没有设置bus的例子(q35):
+	 * (gdb) p *bus
+	 * $4 = {
+	 *   obj = {
+	 *     class = 0x555556804550, 
+	 *     free = 0x7ffff50e58b0 <g_free>, 
+	 *     properties = 0x555556a258c0, 
+	 *     ref = 7, 
+	 *     parent = 0x555556a26f80
+	 *   }, 
+	 *   parent = 0x555556a26f80, 
+	 *   name = 0x555556a65b40 "pcie.0", 
+	 *   hotplug_handler = 0x0, 
+	 *   max_index = 6, 
+	 *   realized = true, 
+	 *   children = {
+	 *     tqh_first = 0x555557881fe0, 
+	 *     tqh_last = 0x555556a65c20
+	 *   }, 
+	 *   sibling = {
+	 *     le_next = 0x0, 
+	 *     le_prev = 0x555556a26fe0
+	 *   }
+	 * }
+	 *
+	 *
+	 * 对于virtio-blk-pci的没有设置bus的例子(i440x):
+	 * (gdb) p *bus
+	 * $6 = {
+	 *   obj = {
+	 *     class = 0x555556804590, 
+	 *     free = 0x7ffff50e58b0 <g_free>, 
+	 *     properties = 0x555556a25b00, 
+	 *     ref = 7, 
+	 *     parent = 0x555556a27300
+	 *   }, 
+	 *   parent = 0x555556a27300, 
+	 *   name = 0x555556a29990 "pci.0", 
+	 *   hotplug_handler = 0x0, 
+	 *   max_index = 6, 
+	 *   realized = true, 
+	 *   children = {
+	 *     tqh_first = 0x5555578cba50, 
+	 *     tqh_last = 0x555556a649a0
+	 *   }, 
+	 *   sibling = {
+	 *     le_next = 0x0, 
+	 *     le_prev = 0x555556a27360
+	 *   }
+	 * }
+	 */
         bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);
         if (!bus || qbus_is_full(bus)) {
             error_setg(errp, "No '%s' bus found for device '%s'",
@@ -605,9 +785,20 @@ DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
     }
 
     /* create device */
+    /*
+     * object_new():
+     *     根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     *     确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     *     然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     dev = DEVICE(object_new(driver));
 
     if (bus) {
+        /*
+	 * 核心思想是把DeviceState dev->parent_bus设置成参数的BusState bus
+	 * 然后分配一个BusChild, BusChild->child设置为参数的DeviceState
+	 * 把BusChild->siibling插入BusState->children
+	 */
         qdev_set_parent_bus(dev, bus);
     } else if (qdev_hotplug && !qdev_get_machine_hotplug_handler(dev)) {
         /* No bus, no machine hotplug handler --> device is not hotpluggable */
@@ -616,14 +807,32 @@ DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
         goto err_del_dev;
     }
 
+    /*
+     * 如果参数id不为NULL, 把DeviceState->id设置为参数的id
+     * 如果DeviceState->id不为NULL, 在/machine/peripheral下添加一个dev->id的child, 指向DeviceState
+     * 否则在/machine/peripheral-anon下添加一个device[%d]的child, 指向DeviceState
+     *
+     * 比如virtio-blk-pci如果有id就在/machine/peripheral
+     * (qemu) qom-list /machine/peripheral
+     * type (string)
+     * virtio-disk0 (child<virtio-blk-pci>)
+     */
     qdev_set_id(dev, qemu_opts_id(opts));
 
     /* set properties */
+    /*
+     * dev是DeviceState
+     *
+     * 对于该设备的每一个参数,调用set_property()
+     */
     if (qemu_opt_foreach(opts, set_property, dev, &err)) {
         goto err_del_dev;
     }
 
     dev->opts = opts;
+    /*
+     * 非常重要!!!!!!!!!!!!!!!!1
+     */
     object_property_set_bool(OBJECT(dev), true, "realized", &err);
     if (err != NULL) {
         dev->opts = NULL;
@@ -813,6 +1022,11 @@ void qmp_device_add(QDict *qdict, QObject **ret_data, Error **errp)
     object_unref(OBJECT(dev));
 }
 
+/*
+ * called by:
+ *   - qdev-monitor.c|1095| <<qmp_device_del>> DeviceState *dev = find_device_state(id, errp);
+ *   - qdev-monitor.c|1106| <<blk_by_qdev_id>> dev = find_device_state(id, errp);
+ */
 static DeviceState *find_device_state(const char *id, Error **errp)
 {
     Object *obj;
@@ -820,6 +1034,10 @@ static DeviceState *find_device_state(const char *id, Error **errp)
     if (id[0] == '/') {
         obj = object_resolve_path(id, NULL);
     } else {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         char *root_path = object_get_canonical_path(qdev_get_peripheral());
         char *path = g_strdup_printf("%s/%s", root_path, id);
 
@@ -834,6 +1052,12 @@ static DeviceState *find_device_state(const char *id, Error **errp)
         return NULL;
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (!object_dynamic_cast(obj, TYPE_DEVICE)) {
         error_setg(errp, "%s is not a hotpluggable device", id);
         return NULL;
@@ -881,6 +1105,10 @@ void qdev_unplug(DeviceState *dev, Error **errp)
     }
 }
 
+/*
+ * called only by:
+ *   - blockdev.c|1238| <<qmp_get_blk>> blk = blk_by_qdev_id(qdev_id, errp);
+ */
 void qmp_device_del(const char *id, Error **errp)
 {
     DeviceState *dev = find_device_state(id, errp);
diff --git a/qom/container.c b/qom/container.c
index f6ccaf7..2b95881 100644
--- a/qom/container.c
+++ b/qom/container.c
@@ -22,23 +22,103 @@ static const TypeInfo container_info = {
 
 static void container_register_types(void)
 {
+    /*
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&container_info);
 }
 
+/*
+ * 很多调用,其中一个例子:
+ *   - qom/object.c|2350| <<object_get_objects_root>> return container_get(object_get_root(), "/objects");
+ *
+ * (gdb) bt
+ * #0  container_get (root=0x55555684fb30, path=0x555555ee0c1e "/machine") at qom/container.c:34
+ * #1  0x0000555555a749f5 in qdev_get_machine () at hw/core/qdev.c:1095
+ * #2  0x0000555555866c5e in memory_region_do_init (mr=0x555556850cc0, owner=0x0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1133
+ * #3  0x0000555555866cfb in memory_region_init (mr=0x555556850cc0, owner=0x0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1149
+ * #4  0x0000555555803699 in memory_map_init () at /home/zhang/kvm/qemu-3.0.0/exec.c:3100
+ * #5  0x0000555555804201 in cpu_exec_init_all () at /home/zhang/kvm/qemu-3.0.0/exec.c:3534
+ * #6  0x00005555559dea90 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4046
+ *
+ * (gdb) bt
+ * #0  container_get (root=0x55555684f700, path=0x555555ee0b3f "/unattached") at qom/container.c:34
+ * #1  0x0000555555a73e3c in device_set_realized (obj=0x55555688a0f0, value=true, errp=0x7fffffffdf28) at hw/core/qdev.c:810
+ * #2  0x0000555555c6020e in property_set_bool (obj=0x55555688a0f0, v=0x5555568a2e50, name=0x555555ea7440 "realized", opaque=0x555556869e80, errp=0x7fffffffdf28) at qom/object.c:1984
+ * #3  0x0000555555c5e493 in object_property_set (obj=0x55555688a0f0, v=0x5555568a2e50, name=0x555555ea7440 "realized", errp=0x7fffffffdf28) at qom/object.c:1176
+ * #4  0x0000555555c6154b in object_property_set_qobject (obj=0x55555688a0f0, value=0x5555568a74f0, name=0x555555ea7440 "realized", errp=0x7fffffffdf28) at qom/qom-qobject.c:27
+ * #5  0x0000555555c5e778 in object_property_set_bool (obj=0x55555688a0f0, value=true, name=0x555555ea7440 "realized", errp=0x7fffffffdf28) at qom/object.c:1242
+ * #6  0x00005555559184e7 in pc_new_cpu (typename=0x555555ea7dec "qemu64-x86_64-cpu", apic_id=0, errp=0x555556751598 <error_fatal>) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1107
+ * #7  0x0000555555918752 in pc_cpus_init (pcms=0x55555684f700) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1155
+ * #8  0x000055555591cd4d in pc_init1 (machine=0x55555684f700, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:153
+ * #9  0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f700) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #10 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f700) at hw/core/machine.c:830
+ * #11 0x00005555559dfb8f in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4516
+ *
+ * 在这个例子中, machine是name, child<pc-i440fx-3.0-machine>是type
+ *    (qemu) qom-list /
+ *    machine (child<pc-i440fx-3.0-machine>)
+ *    type (string)
+ *    chardevs (child<container>)
+ *    backend (child<container>)
+ *
+ * 以下的调用可以在"qom-list /"中看到:
+ *   - hw/core/qdev.c|1236| <<qdev_get_machine>> dev = container_get(object_get_root(), "/machine"); ---> 测试的时候"/machine"不是在这里的container_get()初始化的
+ *   - chardev/char.c|46| <<get_chardevs_root>> return container_get(object_get_root(), "/chardevs");
+ *   - ui/console.c|1896| <<init_displaystate>> object_property_add_child(container_get(object_get_root(), "/backend"),
+ *   - qom/object.c|2350| <<object_get_objects_root>> return container_get(object_get_root(), "/objects");
+ *   - drc_container = container_get(object_get_root(), "/dr-connector");
+ *   - hw/ppc/spapr_drc.c|504| <<realize>> root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);
+ *   - hw/ppc/spapr_drc.c|529| <<unrealize>> root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);
+ *   - hw/ppc/spapr_drc.c|806| <<spapr_drc_populate_dt>> root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);
+ *   - scsi/pr-manager.c|148| <<qmp_query_pr_managers>> Object *container = container_get(object_get_root(), PR_MANAGER_PATH);
+ *
+ *
+ * "/machine"应该是在vl.c的main()初始化的:
+ *     4067     object_property_add_child(object_get_root(), "machine",
+ *     4068                               OBJECT(current_machine), &error_abort);
+ */
 Object *container_get(Object *root, const char *path)
 {
     Object *obj, *child;
     gchar **parts;
     int i;
 
+    /*
+     * 把path用'/'分开
+     *
+     * 对于/aaa/bbb/ccc/ddd
+     *     0: (不是NULL) 
+     *     1: aaa
+     *     2: bbb
+     *     3: ccc
+     *     4: ddd
+     *
+     * 对于aaa/bbb/ccc/ddd
+     *     0: aaa
+     *     1: bbb
+     *     2: ccc
+     *     3: ddd
+     */
     parts = g_strsplit(path, "/", 0);
+    /*
+     * 如果是以"/"开头的, parts[0][0]==0
+     */
     assert(parts != NULL && parts[0] != NULL && !parts[0][0]);
     obj = root;
 
+    /* obj=child让下一个iteration的parent换人! */
     for (i = 1; parts[i] != NULL; i++, obj = child) {
+        /* 从obj(Object)的properties(HashTable)中寻找parts[i]代表的prop, 返回其Object */
         child = object_resolve_path_component(obj, parts[i]);
         if (!child) {
             child = object_new("container");
+	    /*
+	     * 把child设置成一个obj的ObjectProperty
+	     * 在Object->properties (GHashTable)的name就是参数的name (patrs[i]), type是"child<child的type>"
+	     * ObjectProperty的opaque是child
+	     * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+	     */
             object_property_add_child(obj, parts[i], child, NULL);
             object_unref(child);
         }
@@ -50,4 +130,8 @@ Object *container_get(Object *root, const char *path)
 }
 
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(container_register_types)
diff --git a/qom/object.c b/qom/object.c
index 75d1d48..94cc9cc 100644
--- a/qom/object.c
+++ b/qom/object.c
@@ -31,6 +31,21 @@
 
 #define MAX_INTERFACES 32
 
+/*
+ * 核心函数:
+ *   - type_initialize()
+ *   - object_initialize_with_type() (依赖type_initialize())
+ *
+ * 所有instance的祖先是Object
+ * 所有class的祖先是ObjectClass
+ */
+
+/*
+ * 将一个父类的指针转换为子类的指针是不安全的,为了实现这种转换,各类需要提供强制类型转换的宏
+ * 如果类对象指针的name和目标子类的name一致,或类对象指针是目标子类的祖先,则执行转换,否则 abort
+ * 反过来,从子类指针转换为父类指针是安全的,因为类的第一项就指向父类,访问时不会存在越界等问题.
+ */
+
 typedef struct InterfaceImpl InterfaceImpl;
 typedef struct TypeImpl TypeImpl;
 
@@ -39,6 +54,15 @@ struct InterfaceImpl
     const char *typename;
 };
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
 struct TypeImpl
 {
     const char *name;
@@ -47,29 +71,85 @@ struct TypeImpl
 
     size_t instance_size;
 
+    /*
+     * called only by:
+     *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+     */
     void (*class_init)(ObjectClass *klass, void *data);
+    /*
+     * called only by:
+     *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+     */
     void (*class_base_init)(ObjectClass *klass, void *data);
+    /*
+     * 似乎目前不调用:
+     *   - hw/core/machine.c|868| <<global>> .class_finalize = machine_class_finalize,
+     *   - qom/object.c|69| <<global>> void (*class_finalize)(ObjectClass *klass, void *data);
+     *   - qom/object.c|179| <<type_new>> ti->class_finalize = info->class_finalize;
+     */
     void (*class_finalize)(ObjectClass *klass, void *data);
 
+    /*
+     * 来自TypeInfo (各个外部自己定义):
+     *   - qom/object.c|198| <<type_new>> ti->class_data = info->class_data;
+     */
     void *class_data;
 
+    /*
+     * called only by:
+     *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+     */
     void (*instance_init)(Object *obj);
+    /*
+     * called only by:
+     *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+     */
     void (*instance_post_init)(Object *obj);
+    /*
+     * called only by:
+     *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+     */
     void (*instance_finalize)(Object *obj);
 
     bool abstract;
 
+    /*
+     * 在type_new()中由TypeInfo->parent获得
+     */
     const char *parent;
+    /*
+     * 设置parent_type的地方:
+     *   - qom/object.c|256| <<type_get_parent>> type->parent_type = type_get_by_name(type->parent);
+     *   - qom/object.c|334| <<type_initialize_interface>> iface_impl->parent_type = parent_type;
+     */
     TypeImpl *parent_type;
 
+    /*
+     * 在type_initialize()中分配
+     */
     ObjectClass *class;
 
     int num_interfaces;
     InterfaceImpl interfaces[MAX_INTERFACES];
 };
 
+/*
+ * TYPE_INTERFACE获得的TypeImpl
+ *
+ * 用到的地方:
+ *   - qom/object.c|1217| <<object_class_dynamic_cast>> type_is_ancestor(target_type, type_interface)) {
+ *   - qom/object.c|3412| <<register_types>> type_interface = type_register_internal(&interface_info);
+ */
 static Type type_interface;
 
+/*
+ * called by:
+ *   - qom/object.c|89| <<type_table_add>> g_hash_table_insert(type_table_get(), (void *)ti->name, ti);
+ *   - qom/object.c|94| <<type_table_lookup>> return g_hash_table_lookup(type_table_get(), name);
+ *   - qom/object.c|889| <<object_class_foreach>> g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
+ *
+ *   如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+ */
 static GHashTable *type_table_get(void)
 {
     static GHashTable *type_table;
@@ -83,17 +163,42 @@ static GHashTable *type_table_get(void)
 
 static bool enumerating_types;
 
+/*
+ * called by only type_register_internal()
+ *
+ * 把一个根据TypeInfo转化成的TypeImpl插入到hashtable
+ */
 static void type_table_add(TypeImpl *ti)
 {
     assert(!enumerating_types);
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     g_hash_table_insert(type_table_get(), (void *)ti->name, ti);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|135| <<type_new>> if (type_table_lookup(info->name) != NULL) {
+ *   - qom/object.c|200| <<type_get_by_name>> return type_table_lookup(name);
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ */
 static TypeImpl *type_table_lookup(const char *name)
 {
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     return g_hash_table_lookup(type_table_get(), name);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|137| <<type_register_internal>> ti = type_new(info);
+ *   - qom/object.c|250| <<type_initialize_interface>> iface_impl = type_new(&info);
+ *
+ * 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 (通过name搜素)
+ */
 static TypeImpl *type_new(const TypeInfo *info)
 {
     TypeImpl *ti = g_malloc0(sizeof(*ti));
@@ -101,6 +206,7 @@ static TypeImpl *type_new(const TypeInfo *info)
 
     g_assert(info->name != NULL);
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     if (type_table_lookup(info->name) != NULL) {
         fprintf(stderr, "Registering `%s' which already exists\n", info->name);
         abort();
@@ -123,6 +229,11 @@ static TypeImpl *type_new(const TypeInfo *info)
 
     ti->abstract = info->abstract;
 
+    /*
+     * TypeImpl包含:
+     *       int num_interfaces;
+     *       InterfaceImpl interfaces[MAX_INTERFACES]; --> 包含const char *typename;
+     */
     for (i = 0; info->interfaces && info->interfaces[i].type; i++) {
         ti->interfaces[i].typename = g_strdup(info->interfaces[i].type);
     }
@@ -131,47 +242,100 @@ static TypeImpl *type_new(const TypeInfo *info)
     return ti;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|191| <<type_register>> return type_register_internal(info);
+ *   - qom/object.c|2503| <<register_types>> type_interface = type_register_internal(&interface_info);
+ *   - qom/object.c|2504| <<register_types>> type_register_internal(&object_info);
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 static TypeImpl *type_register_internal(const TypeInfo *info)
 {
     TypeImpl *ti;
+    /* 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 */
     ti = type_new(info);
 
+    /* 把一个根据TypeInfo转化成的TypeImpl插入到hashtable */
     type_table_add(ti);
     return ti;
 }
 
+/*
+ * 被外部好多好多调用
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 TypeImpl *type_register(const TypeInfo *info)
 {
     assert(info->parent);
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     return type_register_internal(info);
 }
 
+/*
+ * 被外部好多好多调用
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 TypeImpl *type_register_static(const TypeInfo *info)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     return type_register(info);
 }
 
+/*
+ * 为nr_infos个: 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 void type_register_static_array(const TypeInfo *infos, int nr_infos)
 {
     int i;
 
     for (i = 0; i < nr_infos; i++) {
+        /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
         type_register_static(&infos[i]);
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|245| <<type_get_parent>> type->parent_type = type_get_by_name(type->parent);
+ *   - qom/object.c|285| <<object_type_get_instance_size>> TypeImpl *type = type_get_by_name(typename);
+ *   - qom/object.c|383| <<type_initialize>> TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);
+ *   - qom/object.c|461| <<object_initialize>> TypeImpl *type = type_get_by_name(typename);
+ *   - qom/object.c|625| <<object_new>> TypeImpl *ti = type_get_by_name(typename);
+ *   - qom/object.c|801| <<object_class_dynamic_cast>> target_type = type_get_by_name(typename);
+ *   - qom/object.c|899| <<object_class_by_name>> TypeImpl *type = type_get_by_name(typename);
+ */
 static TypeImpl *type_get_by_name(const char *name)
 {
     if (name == NULL) {
         return NULL;
     }
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     return type_table_lookup(name);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|283| <<type_class_get_size>> return type_class_get_size(type_get_parent(ti));
+ *   - qom/object.c|296| <<type_object_get_size>> return type_object_get_size(type_get_parent(ti));
+ *   - qom/object.c|321| <<type_is_ancestor>> type = type_get_parent(type);
+ *   - qom/object.c|383| <<type_initialize>> parent = type_get_parent(ti);
+ *   - qom/object.c|430| <<type_initialize>> parent = type_get_parent(parent);
+ *   - qom/object.c|441| <<object_init_with_type>> object_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|456| <<object_post_init_with_type>> object_post_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|613| <<object_deinit>> object_deinit(obj, type_get_parent(type));
+ *   - qom/object.c|937| <<object_class_get_parent>> TypeImpl *type = type_get_parent(class->type);
+ *
+ * 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+ */
 static TypeImpl *type_get_parent(TypeImpl *type)
 {
+    /* parent是const char *parent类型 */
     if (!type->parent_type && type->parent) {
+        /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
         type->parent_type = type_get_by_name(type->parent);
         g_assert(type->parent_type != NULL);
     }
@@ -179,45 +343,95 @@ static TypeImpl *type_get_parent(TypeImpl *type)
     return type->parent_type;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|296| <<type_class_get_size>> if (type_has_parent(ti)) {
+ *   - qom/object.c|309| <<type_object_get_size>> if (type_has_parent(ti)) {
+ *   - qom/object.c|457| <<object_init_with_type>> if (type_has_parent(ti)) {
+ *   - qom/object.c|475| <<object_post_init_with_type>> if (type_has_parent(ti)) {
+ *   - qom/object.c|635| <<object_deinit>> if (type_has_parent(type)) {
+ *
+ * 检查TypeImpl是否有parent
+ */
 static bool type_has_parent(TypeImpl *type)
 {
     return (type->parent != NULL);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|308| <<type_class_get_size>> return type_class_get_size(type_get_parent(ti));
+ *   - qom/object.c|399| <<type_initialize>> ti->class_size = type_class_get_size(ti);
+ *
+ * 如果TypeImpl有class_size返回class_size
+ * 其次递归调用自己返回parent的size
+ * 最后没办法了返回sizeof(ObjectClass)
+ */
 static size_t type_class_get_size(TypeImpl *ti)
 {
     if (ti->class_size) {
         return ti->class_size;
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
-        return type_class_get_size(type_get_parent(ti));
+        /* 这里递归调用 继续返回parent的TypeImpl的class_size */
+        return type_class_get_size(type_get_parent(ti)); // 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
     }
 
     return sizeof(ObjectClass);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|338| <<type_object_get_size>> return type_object_get_size(type_get_parent(ti));
+ *   - qom/object.c|350| <<object_type_get_instance_size>> return type_object_get_size(type);
+ *   - qom/object.c|421| <<type_initialize>> ti->instance_size = type_object_get_size(ti);
+ *
+ * 如果TypeImpl有instance_size返回instance_size
+ * 其次递归调用自己返回parent的object size
+ * 最后没办法了返回0
+ */
 static size_t type_object_get_size(TypeImpl *ti)
 {
     if (ti->instance_size) {
         return ti->instance_size;
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
-        return type_object_get_size(type_get_parent(ti));
+	    /* 这里递归调用 继续返回parent的TypeImpl的instance_size */
+        return type_object_get_size(type_get_parent(ti)); // 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
     }
 
     return 0;
 }
 
+/*
+ * hw/ppc/pnv.c中调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 如果TypeImpl有instance_size返回instance_size
+ * 其次递归调用自己返回parent的object size
+ * 最后没办法了返回0
+ */
 size_t object_type_get_instance_size(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
     g_assert(type != NULL);
+    /*
+     * 如果TypeImpl有instance_size返回instance_size
+     * 其次递归调用自己返回parent的object size
+     * 最后没办法了返回0
+     */
     return type_object_get_size(type);
 }
 
+/*
+ * 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+ */
 static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
 {
     assert(target_type);
@@ -228,6 +442,7 @@ static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
             return true;
         }
 
+	/* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
         type = type_get_parent(type);
     }
 
@@ -236,9 +451,23 @@ static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
 
 static void type_initialize(TypeImpl *ti);
 
+/*
+ * called by:
+ *   - qom/object.c|474| <<type_initialize>> type_initialize_interface(ti, iface->interface_type, klass->type);
+ *   - qom/object.c|493| <<type_initialize>> type_initialize_interface(ti, t, t);
+ *
+ * 用ti和interface_type的name组成新的name("%s::%s"), 作为新的TypeInfo的name
+ * 根据TypeInfo转换成TypeImpl, 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 把转换成的TypeInfo的class插入ti->class->interfaces (Glist *)
+ */
 static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
                                       TypeImpl *parent_type)
 {
+    /*
+     * 一个例子: ti来自"nvme", interface_type和parent_type来自INTERFACE_PCIE_DEVICE
+     *
+     * 所有的interface的祖先(TYPE_INTERFACE)的class就是InterfaceClass
+     */
     InterfaceClass *new_iface;
     TypeInfo info = { };
     TypeImpl *iface_impl;
@@ -247,19 +476,36 @@ static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
     info.name = g_strdup_printf("%s::%s", ti->name, interface_type->name);
     info.abstract = true;
 
+    /* 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 (通过name搜索) */
     iface_impl = type_new(&info);
     iface_impl->parent_type = parent_type;
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(iface_impl);
     g_free((char *)info.name);
 
+    /*
+     * 最右边的class是ObjectClass
+     *
+     * 所有interface的祖先的class是InterfaceClass
+     */
     new_iface = (InterfaceClass *)iface_impl->class;
     new_iface->concrete_class = ti->class;
     new_iface->interface_type = interface_type;
 
+    /* 把TypeImpl挂载到ti->class->interfaces */
     ti->class->interfaces = g_slist_append(ti->class->interfaces,
                                            iface_impl->class);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|468| <<type_initialize>> g_str_hash, g_str_equal, g_free, object_property_free);
+ *   - qom/object.c|497| <<type_initialize>> g_str_hash, g_str_equal, g_free, object_property_free);
+ *   - qom/object.c|560| <<object_initialize_with_type>> NULL, object_property_free);
+ */
 static void object_property_free(gpointer data)
 {
     ObjectProperty *prop = data;
@@ -270,49 +516,150 @@ static void object_property_free(gpointer data)
     g_free(prop);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|407| <<type_initialize_interface>> type_initialize(iface_impl);
+ *   - qom/object.c|460| <<type_initialize>> type_initialize(parent);
+ *   - qom/object.c|550| <<object_initialize_with_type>> type_initialize(type);
+ *   - qom/object.c|725| <<object_new_with_type>> type_initialize(type);
+ *   - qom/object.c|1023| <<object_class_by_name>> type_initialize(type);
+ *   - qom/object.c|1037| <<object_class_get_parent>> type_initialize(type);
+ *   - qom/object.c|1057| <<object_class_foreach_tramp>> type_initialize(type);
+ *
+ * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+ * 调用.class_init()
+ */
 static void type_initialize(TypeImpl *ti)
 {
     TypeImpl *parent;
 
+    /* ti->class是ObjectClass, 如果已经初始化了就退出 */
     if (ti->class) {
         return;
     }
 
+    /*
+     * 如果TypeImpl有class_size返回class_size
+     * 其次递归调用自己返回parent的size
+     * 最后没办法了返回sizeof(ObjectClass)
+     */
     ti->class_size = type_class_get_size(ti);
+    /*
+     * 如果TypeImpl有instance_size返回instance_size
+     * 其次递归调用自己返回parent的size
+     * 最后没办法了返回0
+     */
     ti->instance_size = type_object_get_size(ti);
     /* Any type with zero instance_size is implicitly abstract.
      * This means interface types are all abstract.
      */
+    /* 没有instance_size的就是abstract */
     if (ti->instance_size == 0) {
         ti->abstract = true;
     }
 
+    /* class的类型: ObjectClass *class; */
     ti->class = g_malloc0(ti->class_size);
 
+    /* 返回TypeImpl的parent_type (TypeImpl), 如果没有现设置 (可以为NULL) */
     parent = type_get_parent(ti);
     if (parent) {
+        /* 递归调用自己保证祖先们都完成了初始化, 比如祖先们的class_init都调用过了! */
         type_initialize(parent);
         GSList *e;
         int i;
 
+	/*
+	 * 孩子们的class_size必须比祖先小 因为包含祖先
+	 */
         g_assert(parent->class_size <= ti->class_size);
+	/*
+	 * 包含祖先的时候都在头上 所以先拷贝过来
+	 *
+	 * TypeImpl包含ObjectClass *class, 后者包含GSList *interfaces
+	 */
         memcpy(ti->class, parent->class, parent->class_size);
+	/*
+	 * nvme的例子帮助理解interface:
+	 *
+	 * 1397 static const TypeInfo nvme_info = {
+	 * 1398     .name          = "nvme",
+	 * 1399     .parent        = TYPE_PCI_DEVICE,
+	 * 1400     .instance_size = sizeof(NvmeCtrl),
+	 * 1401     .class_init    = nvme_class_init,
+	 * 1402     .instance_init = nvme_instance_init,
+	 * 1403     .interfaces = (InterfaceInfo[]) {
+	 * 1404         { INTERFACE_PCIE_DEVICE },
+	 * 1405         { }
+	 * 1406     },
+	 * 1407 };
+	 *
+	 *  178 static const TypeInfo pcie_interface_info = {
+	 *  179     .name          = INTERFACE_PCIE_DEVICE,
+	 *  180     .parent        = TYPE_INTERFACE,
+	 *  181 };
+	 *
+	 *  3335     static TypeInfo interface_info = {
+	 *  3336         .name = TYPE_INTERFACE,
+	 *  3337         .class_size = sizeof(InterfaceClass),
+	 *  3338         .abstract = true,
+	 *  3339     };
+	 *
+	 *   597 struct InterfaceClass
+	 *   598 {
+	 *   599     ObjectClass parent_class;
+	 *   600     //< private >
+	 *   601     ObjectClass *concrete_class;
+	 *   602     Type interface_type;
+	 *   603 };
+	 *
+	 *
+	 *
+	 *
+	 * 从TypeInfo转换为TypeImpl时对interface的处理:
+	 *      TypeInfo的interfaces是InterfaceInfo的数组, 就是const char *type
+	 *      TypeImpl的interfaces是InterfaceImpl的数组, 就是const char *typename
+	 *  
+	 *  224     for (i = 0; info->interfaces && info->interfaces[i].type; i++) {
+	 *  225         ti->interfaces[i].typename = g_strdup(info->interfaces[i].type);
+	 *  226     }
+	 *  227     ti->num_interfaces = i;
+	 */
         ti->class->interfaces = NULL;
+	/*
+	 * ObjectClass的properties是GHashTable
+	 */
         ti->class->properties = g_hash_table_new_full(
             g_str_hash, g_str_equal, g_free, object_property_free);
 
+	/* 祖先没有先略过 */
         for (e = parent->class->interfaces; e; e = e->next) {
             InterfaceClass *iface = e->data;
+	    /*
+	     * ObjectClass包含Type (定义typedef struct TypeImpl *Type)
+	     */
             ObjectClass *klass = OBJECT_CLASS(iface);
 
+	    /*
+	     * 用ti和interface_type的name组成新的name("%s::%s"), 作为新的TypeInfo的name
+	     * 根据TypeInfo转换成TypeImpl, 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+	     * 把转换成的TypeInfo的class插入ti->class->interfaces (Glist *)
+	     */
             type_initialize_interface(ti, iface->interface_type, klass->type);
         }
 
         for (i = 0; i < ti->num_interfaces; i++) {
+            /*
+	     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+	     *
+	     * nvme的typename的例子是INTERFACE_PCIE_DEVICE
+	     */
             TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);
+	    /* ObjectClass中的interfaces是GSList *interfaces */
             for (e = ti->class->interfaces; e; e = e->next) {
                 TypeImpl *target_type = OBJECT_CLASS(e->data)->type;
 
+		/* 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor */
                 if (type_is_ancestor(target_type, t)) {
                     break;
                 }
@@ -322,6 +669,13 @@ static void type_initialize(TypeImpl *ti)
                 continue;
             }
 
+	    /*
+	     * 一个例子: ti来自"nvme", t来自INTERFACE_PCIE_DEVICE
+	     *
+	     * 用ti和interface_type的name组成新的name("%s::%s"), 作为新的TypeInfo的name
+	     * 根据TypeInfo转换成TypeImpl, 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+	     * 把转换成的TypeInfo的class插入ti->class->interfaces (Glist *)
+	     */
             type_initialize_interface(ti, t, t);
         }
     } else {
@@ -333,8 +687,15 @@ static void type_initialize(TypeImpl *ti)
 
     while (parent) {
         if (parent->class_base_init) {
+            /*
+	     * 实现了class_base_init的
+	     *   - hw/core/machine.c|867| <<global>> .class_base_init = machine_class_base_init,
+	     *   - hw/core/qdev.c|1108| <<global>> .class_base_init = device_class_base_init,
+	     *   - hw/pci/pci.c|2667| <<global>> .class_base_init = pci_device_class_base_init
+	     */
             parent->class_base_init(ti->class, ti->class_data);
         }
+	/* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
         parent = type_get_parent(parent);
     }
 
@@ -343,9 +704,20 @@ static void type_initialize(TypeImpl *ti)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|602| <<object_init_with_type>> object_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|641| <<object_initialize_with_type>> object_init_with_type(obj, type);
+ *
+ * 调用TypeImpl的instance_init(), 如果有parent递归"先"调用parent的instance_init()
+ */
 static void object_init_with_type(Object *obj, TypeImpl *ti)
 {
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
+        /*
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_init_with_type(obj, type_get_parent(ti));
     }
 
@@ -354,22 +726,95 @@ static void object_init_with_type(Object *obj, TypeImpl *ti)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|621| <<object_post_init_with_type>> object_post_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|642| <<object_initialize_with_type>> object_post_init_with_type(obj, type);
+ *
+ * 调用TypeImpl的instance_post_init(obj), 如果有parent"再"递归调用parent的instance_post_init(obj)
+ */
 static void object_post_init_with_type(Object *obj, TypeImpl *ti)
 {
     if (ti->instance_post_init) {
         ti->instance_post_init(obj);
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
+        /* 
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_post_init_with_type(obj, type_get_parent(ti));
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|650| <<object_initialize>> object_initialize_with_type(data, size, type);
+ *   - qom/object.c|816| <<object_new_with_type>> object_initialize_with_type(obj, type->instance_size, type);
+ *
+ * 一个例子 (TYPE_KVM_ACCEL):
+ * (gdb) bt
+ * #0  object_initialize_with_type (data=0x5555565d3d40, size=4456, type=0x5555564f9b30) at qom/object.c:370
+ * #1  0x0000555555c1e805 in object_new_with_type (type=0x5555564f9b30) at qom/object.c:546
+ * #2  0x0000555555c1e842 in object_new (typename=0x5555564d6090 "kvm-accel") at qom/object.c:556
+ * #3  0x000055555584bdb2 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ *
+ * (gdb) set print pretty on
+ * (gdb) p *type
+ * $9 = {
+ *   name = 0x5555564d6090 "kvm-accel", 
+ *   class_size = 152, 
+ *   instance_size = 4456, 
+ *   class_init = 0x555555852628 <kvm_accel_class_init>, 
+ *   class_base_init = 0x0, 
+ *   class_finalize = 0x0, 
+ *   class_data = 0x0, 
+ *   instance_init = 0x0, 
+ *   instance_post_init = 0x0, 
+ *   instance_finalize = 0x0, 
+ *   abstract = false, 
+ *   parent = 0x5555564d6160 "accel", 
+ *   parent_type = 0x5555564f99b0, 
+ *   class = 0x555556547110, 
+ *   num_interfaces = 0, 
+ *   interfaces =     {{
+ *       typename = 0x0
+ *     } <repeats 32 times>}
+ * }
+ *
+ * (gdb) p *type.class
+ * $10 = {
+ *   type = 0x5555564f9b30,   ----->  又指向"kvm-accel"的TypeImpl 
+ *   interfaces = 0x0, 
+ *   object_cast_cache =     {0x0,
+ *     0x0,
+ *     0x0,
+ *     0x0}, 
+ *   class_cast_cache =     {0x0,
+ *     0x0,
+ *     0x555555d90dcc "accel",
+ *     0x555555d903a0 "accel"}, 
+ *   unparent = 0x0, 
+ *   properties = 0x555556545e40
+ * }
+ *
+ * 在上面的例子中, type是TYPE_KVM_ACCEL, 在该函数中obj->class就被设置成了TYPE_KVM_ACCEL的ObjectClass
+ *
+ *
+ * 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 static void object_initialize_with_type(void *data, size_t size, TypeImpl *type)
 {
     Object *obj = data;
 
     g_assert(type != NULL);
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     g_assert(type->instance_size >= sizeof(Object));
@@ -381,14 +826,24 @@ static void object_initialize_with_type(void *data, size_t size, TypeImpl *type)
     object_ref(obj);
     obj->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
                                             NULL, object_property_free);
+    /* 调用TypeImpl的instance_init(), 如果有parent递归"先"调用parent的instance_init() */
     object_init_with_type(obj, type);
+    /* 调用TypeImpl的instance_post_init(obj), 如果有parent"再"递归调用parent的instance_post_init(obj) */
     object_post_init_with_type(obj, type);
 }
 
+/*
+ * 被一群外部的调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 void object_initialize(void *data, size_t size, const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
+    /* 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init() */
     object_initialize_with_type(data, size, type);
 }
 
@@ -411,6 +866,10 @@ void object_initialize_childv(Object *parentobj, const char *propname,
     Error *local_err = NULL;
     Object *obj;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     object_initialize(childobj, size, type);
     obj = OBJECT(childobj);
 
@@ -419,11 +878,23 @@ void object_initialize_childv(Object *parentobj, const char *propname,
         goto out;
     }
 
+    /*
+     * 把child设置成一个obj的ObjectProperty
+     * 在Object->properties (GHashTable)的name就是参数的name, type是"child<child的type>"
+     * ObjectProperty的opaque是child
+     * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+     */
     object_property_add_child(parentobj, propname, obj, &local_err);
     if (local_err) {
         goto out;
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_dynamic_cast(obj, TYPE_USER_CREATABLE)) {
         user_creatable_complete(obj, &local_err);
         if (local_err) {
@@ -446,6 +917,9 @@ out:
     }
 }
 
+/*
+ * 判断ObjectProperty的type是否开头是"child<"
+ */
 static inline bool object_property_is_child(ObjectProperty *prop)
 {
     return strstart(prop->type, "child<", NULL);
@@ -516,11 +990,18 @@ static void object_deinit(Object *obj, TypeImpl *type)
         type->instance_finalize(obj);
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(type)) {
+        /*
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_deinit(obj, type_get_parent(type));
     }
 }
 
+/*
+ * called only by object_unref()
+ */
 static void object_finalize(void *data)
 {
     Object *obj = data;
@@ -535,28 +1016,56 @@ static void object_finalize(void *data)
     }
 }
 
+/*
+ * called only by object_new()
+ *
+ * Type的定义: typedef struct TypeImpl *Type
+ *
+ * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 static Object *object_new_with_type(Type type)
 {
     Object *obj;
 
     g_assert(type != NULL);
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     obj = g_malloc(type->instance_size);
+    /* 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init() */
     object_initialize_with_type(obj, type->instance_size, type);
     obj->free = g_free;
 
     return obj;
 }
 
+/*
+ * 被一群外部调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 Object *object_new(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *ti = type_get_by_name(typename);
 
     return object_new_with_type(ti);
 }
 
 
+/*
+ * called by:
+ *   - hw/misc/auxbus.c|70| <<aux_init_bus>> auxtoi2c = object_new_with_props(TYPE_AUXTOI2C, OBJECT(bus), "i2c",
+ *   - iothread.c|366| <<iothread_create>> obj = object_new_with_props(TYPE_IOTHREAD,
+ *   - ui/vnc.c|3539| <<vnc_display_create_creds>> creds = object_new_with_props(TYPE_QCRYPTO_TLS_CREDS_X509,
+ *   - ui/vnc.c|3548| <<vnc_display_create_creds>> creds = object_new_with_props(TYPE_QCRYPTO_TLS_CREDS_ANON,
+ */
 Object *object_new_with_props(const char *typename,
                               Object *parent,
                               const char *id,
@@ -584,6 +1093,11 @@ Object *object_new_with_propv(const char *typename,
     ObjectClass *klass;
     Error *local_err = NULL;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     klass = object_class_by_name(typename);
     if (!klass) {
         error_setg(errp, "invalid object type: %s", typename);
@@ -594,17 +1108,34 @@ Object *object_new_with_propv(const char *typename,
         error_setg(errp, "object type '%s' is abstract", typename);
         return NULL;
     }
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     obj = object_new(typename);
 
     if (object_set_propv(obj, &local_err, vargs) < 0) {
         goto error;
     }
 
+    /*
+     * 把child设置成一个obj的ObjectProperty
+     * 在Object->properties (GHashTable)的name (id)就是参数的name, type是"child<child的type>"
+     * ObjectProperty的opaque是child
+     * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+     */
     object_property_add_child(parent, id, obj, &local_err);
     if (local_err) {
         goto error;
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_dynamic_cast(obj, TYPE_USER_CREATABLE)) {
         user_creatable_complete(obj, &local_err);
         if (local_err) {
@@ -623,6 +1154,31 @@ Object *object_new_with_propv(const char *typename,
 }
 
 
+/*
+ * <example>
+ *   <title>Update an object's properties</title>
+ *   <programlisting>
+ *   Error *err = NULL;
+ *   Object *obj = ...get / create object...;
+ *
+ *   obj = object_set_props(obj,
+ *                          &err,
+ *                          "share", "yes",
+ *                          "mem-path", "/dev/shm/somefile",
+ *                          "prealloc", "yes",
+ *                          "size", "1048576",
+ *                          NULL);
+ *  
+ *   if (!obj) {
+ *     g_printerr("Cannot set properties: %s\n",
+ *                error_get_pretty(err));
+ *   }
+ *   </programlisting>
+ * </example>
+ */
+/*
+ * 对于参数的没一个vargs中的pair, 根据name找到ObjectProperty, 然后调用其set方法 (还有一点Visitor的操作)
+ */
 int object_set_props(Object *obj,
                      Error **errp,
                      ...)
@@ -631,6 +1187,7 @@ int object_set_props(Object *obj,
     int ret;
 
     va_start(vargs, errp);
+    /* 对于参数的没一个vargs中的pair, 根据name找到ObjectProperty, 然后调用其set方法 (还有一点Visitor的操作) */
     ret = object_set_propv(obj, errp, vargs);
     va_end(vargs);
 
@@ -638,6 +1195,15 @@ int object_set_props(Object *obj,
 }
 
 
+/*
+ * called by:
+ *   - qom/object.c|720| <<object_initialize_childv>> object_set_propv(obj, &local_err, vargs);
+ *   - qom/object.c|937| <<object_new_with_propv>> if (object_set_propv(obj, &local_err, vargs) < 0) {
+ *   - qom/object.c|994| <<object_set_props>> ret = object_set_propv(obj, errp, vargs);
+ *   - qom/object.c|1001| <<object_set_propv>> int object_set_propv(Object *obj,
+ *
+ * 对于参数的没一个vargs中的pair, 根据name找到ObjectProperty, 然后调用其set方法 (还有一点Visitor的操作)
+ */
 int object_set_propv(Object *obj,
                      Error **errp,
                      va_list vargs)
@@ -650,6 +1216,9 @@ int object_set_propv(Object *obj,
         const char *value = va_arg(vargs, char *);
 
         g_assert(value != NULL);
+	/*
+	 * 根据name找到ObjectProperty, 然后调用其set方法 (还有一点Visitor的操作)
+	 */
         object_property_parse(obj, value, propname, &local_err);
         if (local_err) {
             error_propagate(errp, local_err);
@@ -662,8 +1231,37 @@ int object_set_propv(Object *obj,
 }
 
 
+/*
+ * 一个使用的例子: DeviceState *dev = (DeviceState *) object_dynamic_cast(obj, TYPE_DEVICE);
+ *   - memory.c|2938| <<mtree_expand_owner>> DeviceState *dev = (DeviceState *) object_dynamic_cast(obj, TYPE_DEVICE);
+ *
+ * 一个例子(#1):
+ *
+ * (gdb) bt
+ * #0  object_class_dynamic_cast (class=0x555556547110, typename=0x555555d903a0 "accel") at qom/object.c:716
+ * #1  0x0000555555c1ed8d in object_dynamic_cast (obj=0x5555565d3d40, typename=0x555555d903a0 "accel") at qom/object.c:667
+ * #2  0x0000555555c1ee43 in object_dynamic_cast_assert (obj=0x5555565d3d40, typename=0x555555d903a0 "accel", 
+ *     file=0x555555d903b8 "/home/zhang/kvm/qemu-3.0.0/accel/accel.c", line=58, func=0x555555d90480 <__func__.27147> "accel_init_machine")
+ *     at qom/object.c:690
+ * #3  0x000055555584bdd4 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ *
+ * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+ * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+ * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+ * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+ */
 Object *object_dynamic_cast(Object *obj, const char *typename)
 {
+    /*
+     * object_get_class(): 参考object_initialize_with_type()的注释, 比如class可能是TYPE_KVM_ACCEL的ObjectClass
+     *
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (obj && object_class_dynamic_cast(object_get_class(obj), typename)) {
         return obj;
     }
@@ -671,6 +1269,19 @@ Object *object_dynamic_cast(Object *obj, const char *typename)
     return NULL;
 }
 
+/*
+ * 一个例子(#2):
+ *
+ * (gdb) bt
+ * #0  object_class_dynamic_cast (class=0x555556547110, typename=0x555555d903a0 "accel") at qom/object.c:716
+ * #1  0x0000555555c1ed8d in object_dynamic_cast (obj=0x5555565d3d40, typename=0x555555d903a0 "accel") at qom/object.c:667
+ * #2  0x0000555555c1ee43 in object_dynamic_cast_assert (obj=0x5555565d3d40, typename=0x555555d903a0 "accel", 
+ *     file=0x555555d903b8 "/home/zhang/kvm/qemu-3.0.0/accel/accel.c", line=58, func=0x555555d90480 <__func__.27147> "accel_init_machine")
+ *     at qom/object.c:690
+ * #3  0x000055555584bdd4 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ */
 Object *object_dynamic_cast_assert(Object *obj, const char *typename,
                                    const char *file, int line, const char *func)
 {
@@ -687,6 +1298,12 @@ Object *object_dynamic_cast_assert(Object *obj, const char *typename,
         }
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     inst = object_dynamic_cast(obj, typename);
 
     if (!inst && obj) {
@@ -710,6 +1327,48 @@ out:
     return obj;
 }
 
+/*
+ * 一个gdb的例子 (#0):
+ *
+ * (gdb) bt
+ * #0  object_class_dynamic_cast (class=0x555556547110, typename=0x555555d903a0 "accel") at qom/object.c:716
+ * #1  0x0000555555c1ed8d in object_dynamic_cast (obj=0x5555565d3d40, typename=0x555555d903a0 "accel") at qom/object.c:667
+ * #2  0x0000555555c1ee43 in object_dynamic_cast_assert (obj=0x5555565d3d40, typename=0x555555d903a0 "accel", 
+ *     file=0x555555d903b8 "/home/zhang/kvm/qemu-3.0.0/accel/accel.c", line=58, func=0x555555d90480 <__func__.27147> "accel_init_machine")
+ *     at qom/object.c:690
+ * #3  0x000055555584bdd4 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ *
+ * (gdb) p *class.type
+ * $11 = {
+ *   name = 0x5555564d6090 "kvm-accel", 
+ *   class_size = 152, 
+ *   instance_size = 4456, 
+ *   class_init = 0x555555852628 <kvm_accel_class_init>, 
+ *   class_base_init = 0x0, 
+ *   class_finalize = 0x0, 
+ *   class_data = 0x0, 
+ *   instance_init = 0x0, 
+ *   instance_post_init = 0x0, 
+ *   instance_finalize = 0x0, 
+ *   abstract = false, 
+ *   parent = 0x5555564d6160 "accel", 
+ *   parent_type = 0x5555564f99b0, 
+ *   class = 0x555556547110, 
+ *   num_interfaces = 0, 
+ *   interfaces =     {{
+ *       typename = 0x0
+ *     } <repeats 32 times>}
+ * }
+ *
+ * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+ *
+ * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+ * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+ * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+ * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回 
+ */
 ObjectClass *object_class_dynamic_cast(ObjectClass *class,
                                        const char *typename)
 {
@@ -723,24 +1382,54 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
 
     /* A simple fast path that can trigger a lot for leaf classes.  */
     type = class->type;
+    /* 如果这个ObjectClass的type就是我们要找的 直接返回ObjectClass */
     if (type->name == typename) {
         return class;
     }
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     target_type = type_get_by_name(typename);
     if (!target_type) {
         /* target class type unknown, so fail the cast */
         return NULL;
     }
 
+    /*
+     * type_is_ancestor(): 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+     *
+     *
+     * 一个nvme的例子:
+     *
+     * 1397 static const TypeInfo nvme_info = {
+     * 1398     .name          = "nvme",
+     * 1399     .parent        = TYPE_PCI_DEVICE,
+     * 1400     .instance_size = sizeof(NvmeCtrl),
+     * 1401     .class_init    = nvme_class_init,
+     * 1402     .instance_init = nvme_instance_init,
+     * 1403     .interfaces = (InterfaceInfo[]) {
+     * 1404         { INTERFACE_PCIE_DEVICE },
+     * 1405         { }
+     * 1406     },
+     * 1407 };
+     *
+     *
+     * type_interface是TYPE_INTERFACE获得的TypeImpl
+     *
+     * 这个if语句是ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (type->class->interfaces &&
             type_is_ancestor(target_type, type_interface)) {
         int found = 0;
         GSList *i;
 
+	/*
+	 * 从ObjectClass的interfaces (GList *)中找到一个祖先是target_type的
+	 */
         for (i = class->interfaces; i; i = i->next) {
             ObjectClass *target_class = i->data;
 
+	    /* 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor */
             if (type_is_ancestor(target_class->type, target_type)) {
                 ret = target_class;
                 found++;
@@ -748,16 +1437,27 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
          }
 
         /* The match was ambiguous, don't allow a cast */
+	/* 找到多于一个是不正确的 */
         if (found > 1) {
             ret = NULL;
         }
-    } else if (type_is_ancestor(type, target_type)) {
+    } else if (type_is_ancestor(type, target_type)) {  // 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+        /*
+	 * else if中如果typename获得的target_type是class->type的最先则返回class
+	 *
+	 * 一个例子是type是TYPE_KVM_ACCEL, target_type是TYPE_ACCEL, 返回的class (ret)是TYPE_KVM_ACCEL的ObjectClass (没关系 因为包含了后者)
+	 *
+	 * 如果不是interface的部分, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	 */
         ret = class;
     }
 
     return ret;
 }
 
+/*
+ * 调用object_class_dynamic_cast() 剩下就是做了些检查
+ */
 ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,
                                               const char *typename,
                                               const char *file, int line,
@@ -783,6 +1483,12 @@ ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,
     }
 #endif
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     ret = object_class_dynamic_cast(class, typename);
     if (!ret && class) {
         fprintf(stderr, "%s:%d:%s: Object %p is not an instance of type %s\n",
@@ -805,47 +1511,78 @@ out:
 
 const char *object_get_typename(const Object *obj)
 {
+    /* 最后的type (Type) 是一个TypeImpl */
     return obj->class->type->name;
 }
 
 ObjectClass *object_get_class(Object *obj)
 {
+    /*
+     * class是ObjectClass
+     *
+     * 参考object_initialize_with_type()的注释, 比如class可能是TYPE_KVM_ACCEL的ObjectClass
+     */
     return obj->class;
 }
 
 bool object_class_is_abstract(ObjectClass *klass)
 {
+    /* type是Type (TypeImpl) */
     return klass->type->abstract;
 }
 
 const char *object_class_get_name(ObjectClass *klass)
 {
+    /* type是Type (TypeImpl) */
     return klass->type->name;
 }
 
+/*
+ * 很多外部调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+ * 调用.class_init()
+ */
 ObjectClass *object_class_by_name(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
     if (!type) {
         return NULL;
     }
 
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     return type->class;
 }
 
+/*
+ * 得到TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+ * 初始化parent_type(TypeImpl)的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 最后返回parent_type(TypeImpl)的class (ObjectClass)
+ */
 ObjectClass *object_class_get_parent(ObjectClass *class)
 {
+    /* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
     TypeImpl *type = type_get_parent(class->type);
 
     if (!type) {
         return NULL;
     }
 
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
+    /* class是ObjectClass */
     return type->class;
 }
 
@@ -857,6 +1594,10 @@ typedef struct OCFData
     void *opaque;
 } OCFData;
 
+/*
+ * called by:
+ *   - qom/object.c|1630| <<object_class_foreach>> g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
+ */
 static void object_class_foreach_tramp(gpointer key, gpointer value,
                                        gpointer opaque)
 {
@@ -871,6 +1612,13 @@ static void object_class_foreach_tramp(gpointer key, gpointer value,
         return;
     }
 
+    /*
+     * object_class_dymanic_cast():
+     *     如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     *     一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     *     否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     *     在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (data->implements_type && 
         !object_class_dynamic_cast(k, data->implements_type)) {
         return;
@@ -886,10 +1634,22 @@ void object_class_foreach(void (*fn)(ObjectClass *klass, void *opaque),
     OCFData data = { fn, implements_type, include_abstract, opaque };
 
     enumerating_types = true;
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
     enumerating_types = false;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|1662| <<do_object_child_foreach>> do_object_child_foreach(child, fn, opaque, true);
+ *   - qom/object.c|1678| <<object_child_foreach>> return do_object_child_foreach(obj, fn, opaque, false);
+ *   - qom/object.c|1685| <<object_child_foreach_recursive>> return do_object_child_foreach(obj, fn, opaque, true);
+ *
+ * 遍历Object的properties(HashTable), 针对每一个type开头是"child<"的ObjectProperty, 调用fn
+ * 如果recurse是true, 继续递归调用自己(针对prop->opaque)
+ */
 static int do_object_child_foreach(Object *obj,
                                    int (*fn)(Object *child, void *opaque),
                                    void *opaque, bool recurse)
@@ -900,6 +1660,7 @@ static int do_object_child_foreach(Object *obj,
 
     g_hash_table_iter_init(&iter, obj->properties);
     while (g_hash_table_iter_next(&iter, NULL, (gpointer *)&prop)) {
+        /* 判断ObjectProperty的type是否开头是"child<" */
         if (object_property_is_child(prop)) {
             Object *child = prop->opaque;
 
@@ -908,6 +1669,7 @@ static int do_object_child_foreach(Object *obj,
                 break;
             }
             if (recurse) {
+		/* 如果recurse为true, 递归调用孩子Object */
                 do_object_child_foreach(child, fn, opaque, true);
             }
         }
@@ -915,16 +1677,34 @@ static int do_object_child_foreach(Object *obj,
     return ret;
 }
 
+/*
+ * 调用的几个例子:
+ *   - hw/virtio/virtio-balloon.c|342| <<build_dimm_list>> object_child_foreach(obj, build_dimm_list, opaque);
+ *   - iothread.c|334| <<qmp_query_iothreads>> object_child_foreach(container, query_one_iothread, &prev);
+ *   - qdev-monitor.c|787| <<print_qom_composition>> object_child_foreach(obj, print_qom_composition_child, &s);
+ */
 int object_child_foreach(Object *obj, int (*fn)(Object *child, void *opaque),
                          void *opaque)
 {
+    /*
+     * 遍历Object的properties(HashTable), 针对每一个type开头是"child<"的ObjectProperty, 调用fn
+     * 如果recurse是true, 继续递归调用自己(针对prop->opaque)
+     */
     return do_object_child_foreach(obj, fn, opaque, false);
 }
 
+/*
+ * 遍历Object的properties(HashTable), 针对每一个type开头是"child<"的ObjectProperty, 调用fn
+ * 如果recurse是true, 继续递归调用自己(针对prop->opaque)
+ */
 int object_child_foreach_recursive(Object *obj,
                                    int (*fn)(Object *child, void *opaque),
                                    void *opaque)
 {
+    /*
+     * 遍历Object的properties(HashTable), 针对每一个type开头是"child<"的ObjectProperty, 调用fn
+     * 如果recurse是true, 继续递归调用自己(针对prop->opaque)
+     */
     return do_object_child_foreach(obj, fn, opaque, true);
 }
 
@@ -958,6 +1738,7 @@ GSList *object_class_get_list_sorted(const char *implements_type,
                         object_class_cmp);
 }
 
+/* 增加Object的uint32_t ref */
 void object_ref(Object *obj)
 {
     if (!obj) {
@@ -966,6 +1747,10 @@ void object_ref(Object *obj)
     atomic_inc(&obj->ref);
 }
 
+/*
+ * 减少Object的uint32_t ref
+ * 如果是0了还要调用object_finalize()
+ */
 void object_unref(Object *obj)
 {
     if (!obj) {
@@ -979,6 +1764,25 @@ void object_unref(Object *obj)
     }
 }
 
+/*
+ * 如果是初始化virtio block的iothread prop的此时的参数:
+ *   obj     : VirtIOBlock的Object
+ *   name    : "iothread"
+ *   type    : "link<iothread>"
+ *   get     : object_get_link_property()
+ *   set     : object_set_link_property()
+ *   release : object_release_link_property()
+ *   opaque      : 一个分配的LinkProperty
+ *               prop->child = 指向VirtIOBlock->conf.iothread(IOThread)指针的指针
+ *                             修改其值就相当于是给VirtIOBlock->conf.iothread(IOThread)赋值了
+ *               prop->check = qdev_prop_allow_set_link_before_realize()
+ *               prop->flags = OBJ_PROP_LINK_STRONG;
+ *
+ * 好多外部调用
+ *
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 ObjectProperty *
 object_property_add(Object *obj, const char *name, const char *type,
                     ObjectPropertyAccessor *get,
@@ -989,6 +1793,20 @@ object_property_add(Object *obj, const char *name, const char *type,
     ObjectProperty *prop;
     size_t name_len = strlen(name);
 
+    /*
+     * 感觉一般的都不满足这个什么[*]吧
+     *
+     * system_memory进来的时候
+     * (gdb) bt
+     * #0  object_property_add (obj=0x5555568512d0, name=0x555556851250 "system[*]", type=0x555556851530 "child<qemu:memory-region>", get=0x555555c5f037 <object_get_child_property>, set=0x0, 
+     *     release=0x555555c5f0cb <object_finalize_child_property>, opaque=0x555556850cd0, errp=0x7fffffffe060) at qom/object.c:990
+     * #1  0x0000555555c5f1e6 in object_property_add_child (obj=0x5555568512d0, name=0x555556851250 "system[*]", child=0x555556850cd0, errp=0x555556751590 <error_abort>) at qom/object.c:1507
+     * #2  0x0000555555866c8c in memory_region_do_init (mr=0x555556850cd0, owner=0x5555568512d0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1136
+     * #3  0x0000555555866cfb in memory_region_init (mr=0x555556850cd0, owner=0x0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1149
+     * #4  0x0000555555803699 in memory_map_init () at /home/zhang/kvm/qemu-3.0.0/exec.c:3100
+     * #5  0x0000555555804201 in cpu_exec_init_all () at /home/zhang/kvm/qemu-3.0.0/exec.c:3534
+     * #6  0x00005555559dea90 in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4046
+     */
     if (name_len >= 3 && !memcmp(name + name_len - 3, "[*]", 4)) {
         int i;
         ObjectProperty *ret;
@@ -1009,6 +1827,11 @@ object_property_add(Object *obj, const char *name, const char *type,
         return ret;
     }
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     if (object_property_find(obj, name, NULL) != NULL) {
         error_setg(errp, "attempt to add duplicate property '%s'"
                    " to object (type '%s')", name,
@@ -1016,6 +1839,7 @@ object_property_add(Object *obj, const char *name, const char *type,
         return NULL;
     }
 
+    /* prop是ObjectProperty */
     prop = g_malloc0(sizeof(*prop));
 
     prop->name = g_strdup(name);
@@ -1024,12 +1848,34 @@ object_property_add(Object *obj, const char *name, const char *type,
     prop->get = get;
     prop->set = set;
     prop->release = release;
+    /*
+     * opaque用在get和set中
+     * 一些例子是opaque就是Property
+     */
     prop->opaque = opaque;
 
+    /*
+     * 如果是初始化virtio block的iothread prop的此时的参数:
+     *   ObjectProperty->name    = "iothread";
+     *   ObjectProperty->type    = "link<iothread>";
+     *   ObjectProperty->get     = object_get_link_property();
+     *   ObjectProperty->set     = object_set_link_property();
+     *   ObjectProperty->release = object_get_release_property();
+     *   ObjectProperty->opaque  = 一个分配的LinkProperty
+     *                             LinkProperty->child = 指向VirtIOBlock->conf.iothread(IOThread)指针的指针
+     *                                           修改其值就相当于是给VirtIOBlock->conf.iothread(IOThread)赋值了
+     *                             LinkProperty->check = qdev_prop_allow_set_link_before_realize()
+     *                             LinkProperty->flags = OBJ_PROP_LINK_STRONG;;
+     */
+
     g_hash_table_insert(obj->properties, prop->name, prop);
     return prop;
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 ObjectProperty *
 object_class_property_add(ObjectClass *klass,
                           const char *name,
@@ -1064,17 +1910,29 @@ object_class_property_add(ObjectClass *klass,
     return prop;
 }
 
+/*
+ * 递归调用自己的parent (ObjectClass) 寻找prop
+ * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+ * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+ */
 ObjectProperty *object_property_find(Object *obj, const char *name,
                                      Error **errp)
 {
     ObjectProperty *prop;
     ObjectClass *klass = object_get_class(obj);
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     */
     prop = object_class_property_find(klass, name, NULL);
     if (prop) {
         return prop;
     }
 
+    /*
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     prop = g_hash_table_lookup(obj->properties, name);
     if (prop) {
         return prop;
@@ -1111,20 +1969,33 @@ void object_class_property_iter_init(ObjectPropertyIterator *iter,
     iter->nextclass = klass;
 }
 
+/*
+ * 递归调用自己的parent (ObjectClass) 寻找prop
+ * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+ */
 ObjectProperty *object_class_property_find(ObjectClass *klass, const char *name,
                                            Error **errp)
 {
     ObjectProperty *prop;
     ObjectClass *parent_klass;
 
+    /*
+     * 得到TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+     * 初始化parent_type(TypeImpl)的class_size, instance_size和class, 还有interface, 调用.class_init()
+     * 最后返回parent_type(TypeImpl)的class (ObjectClass)
+     */
     parent_klass = object_class_get_parent(klass);
     if (parent_klass) {
+        /*
+	 * 递归调用自己的parent (ObjectClass) 寻找prop
+	 */
         prop = object_class_property_find(parent_klass, name, NULL);
         if (prop) {
             return prop;
         }
     }
 
+    /* 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找 */
     prop = g_hash_table_lookup(klass->properties, name);
     if (!prop) {
         error_setg(errp, "Property '.%s' not found", name);
@@ -1147,9 +2018,17 @@ void object_property_del(Object *obj, const char *name, Error **errp)
     g_hash_table_remove(obj->properties, name);
 }
 
+/*
+ * 根据name找到ObjectProperty, 然后调用其get方法
+ */
 void object_property_get(Object *obj, Visitor *v, const char *name,
                          Error **errp)
 {
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     ObjectProperty *prop = object_property_find(obj, name, errp);
     if (prop == NULL) {
         return;
@@ -1162,24 +2041,100 @@ void object_property_get(Object *obj, Visitor *v, const char *name,
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|1791| <<object_property_parse>> object_property_set(obj, v, name, errp);
+ *   - qom/object.c|2719| <<property_set_alias>> object_property_set(prop->target_obj, v, prop->target_name, errp);
+ *   - qom/object_interfaces.c|73| <<user_creatable_add_type>> object_property_set(obj, v, e->key, &local_err);
+ *   - qom/qom-qobject.c|27| <<object_property_set_qobject>> object_property_set(obj, v, name, errp);
+ *   - target/s390x/cpu_models.c|491| <<cpu_model_from_info>> object_property_set(obj, visitor, e->key, errp);
+ *
+ * 根据name找到ObjectProperty, 然后调用其set方法
+ *
+ * 比如name可以是"realized" (#4):
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ *
+ *
+ * virtio block设置iothread参数的例子:
+ * (gdb) bt
+ * #0  object_set_link_property (obj=0x55555771a460, v=0x55555771f150, name=0x55555771e9b0 "iothread", opaque=0x55555771cd90, errp=0x7fffffffdf78) at qom/object.c:1595
+ * #1  0x0000555555c1fe4c in object_property_set (obj=0x55555771a460, v=0x55555771f150, name=0x55555771e9b0 "iothread", errp=0x7fffffffdf78) at qom/object.c:1176
+ * #2  0x0000555555c229f1 in property_set_alias (obj=0x5555577122f0, v=0x55555771f150, name=0x555556536520 "iothread", opaque=0x55555771e990, errp=0x7fffffffdf78)
+ *     at qom/object.c:2330
+ * #3  0x0000555555c1fe4c in object_property_set (obj=0x5555577122f0, v=0x55555771f150, name=0x555556536520 "iothread", errp=0x7fffffffdf78) at qom/object.c:1176
+ * #4  0x0000555555c2086b in object_property_parse (obj=0x5555577122f0, string=0x5555565364c0 "io1", name=0x555556536520 "iothread", errp=0x7fffffffdf78) at qom/object.c:1402
+ * #5  0x000055555598f2a6 in set_property (opaque=0x5555577122f0, name=0x555556536520 "iothread", value=0x5555565364c0 "io1", errp=0x7fffffffe000) at qdev-monitor.c:180
+ * #6  0x0000555555d66fd7 in qemu_opt_foreach (opts=0x5555565362f0, func=0x55555598f21b <set_property>, opaque=0x5555577122f0, errp=0x7fffffffe000) at util/qemu-option.c:580
+ * #7  0x000055555599071a in qdev_device_add (opts=0x5555565362f0, errp=0x7fffffffe078) at qdev-monitor.c:622
+ * #8  0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362f0, errp=0x0) at vl.c:2275
+ * #9  0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x000055555599dd61 in main (argc=16, argv=0x7fffffffe3e8, envp=0x7fffffffe470) at vl.c:4542
+ */
 void object_property_set(Object *obj, Visitor *v, const char *name,
                          Error **errp)
 {
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     ObjectProperty *prop = object_property_find(obj, name, errp);
     if (prop == NULL) {
         return;
     }
 
+    /*
+     * 如果是初始化virtio block的iothread prop的此时的参数:
+     *   ObjectProperty->name    = "iothread";
+     *   ObjectProperty->type    = "link<iothread>";
+     *   ObjectProperty->get     = object_get_link_property();
+     *   ObjectProperty->set     = object_set_link_property();
+     *   ObjectProperty->release = object_get_release_property();
+     *   ObjectProperty->opaque  = 一个分配的LinkProperty
+     *                             LinkProperty->child = 指向VirtIOBlock->conf.iothread(IOThread)指针的指针
+     *                                           修改其值就相当于是给VirtIOBlock->conf.iothread(IOThread)赋值了
+     *                             LinkProperty->check = qdev_prop_allow_set_link_before_realize()
+     *                             LinkProperty->flags = OBJ_PROP_LINK_STRONG;
+     */
+
     if (!prop->set) {
         error_setg(errp, QERR_PERMISSION_DENIED);
     } else {
-        prop->set(obj, v, name, prop->opaque, errp);
+        /*
+	 * 如果是初始化virtio block的iothread prop, set=object_set_link_property()
+	 *   obj          : VirtIOBlock
+	 *   v            : 用iothread id(比如"io1")制作的Visitor
+	 *   name         : "iothread"
+	 *   prop->opaque : 一个分配的LinkProperty
+	 *                  LinkProperty->child = 指向VirtIOBlock->conf.iothread(IOThread)指针的指针
+	 *                                修改其值就相当于是给VirtIOBlock->conf.iothread(IOThread)赋值了
+	 *                  LinkProperty->check = qdev_prop_allow_set_link_before_realize()
+	 *                  LinkProperty->flags = OBJ_PROP_LINK_STRONG;
+	 */
+        prop->set(obj, v, name, prop->opaque, errp); // 对于nvme的realized, 例子是property_set_bool()
     }
 }
 
+/*
+ * 很多调用, 几个调用的例子:
+ *   - qom/object.c|2076| <<object_property_set_link>> object_property_set_str(obj, path, name, errp);
+ *   - qom/object.c|2079| <<object_property_set_link>> object_property_set_str(obj, "", name, errp);
+ */
 void object_property_set_str(Object *obj, const char *value,
                              const char *name, Error **errp)
 {
+    /* Create a new QString from a regular C string */
     QString *qstr = qstring_from_str(value);
     object_property_set_qobject(obj, QOBJECT(qstr), name, errp);
 
@@ -1209,6 +2164,10 @@ void object_property_set_link(Object *obj, Object *value,
                               const char *name, Error **errp)
 {
     if (value) {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         gchar *path = object_get_canonical_path(value);
         object_property_set_str(obj, path, name, errp);
         g_free(path);
@@ -1235,6 +2194,20 @@ Object *object_property_get_link(Object *obj, const char *name,
     return target;
 }
 
+/*
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 void object_property_set_bool(Object *obj, bool value,
                               const char *name, Error **errp)
 {
@@ -1395,10 +2368,25 @@ out:
     visit_free(v);
 }
 
+/*
+ * called by:
+ *   - hmp.c|2594| <<hmp_qom_set>> object_property_parse(obj, value, property, &err);
+ *   - hw/core/qdev-properties.c|1259| <<qdev_prop_set_globals>> object_property_parse(OBJECT(dev), prop->value, prop->property, &err);
+ *   - qdev-monitor.c|180| <<set_property>> object_property_parse(obj, value, name, &err);
+ *   - qom/object.c|1020| <<object_set_propv>> object_property_parse(obj, value, propname, &local_err);
+ *   - target/i386/cpu.c|3528| <<x86_cpu_apply_props>> object_property_parse(OBJECT(cpu), pv->value, pv->prop,
+ *   - vl.c|2728| <<machine_set_property>> object_property_parse(obj, value, qom_name, &local_err);
+ *
+ * 如果是virtio block设置iothread进来的(qdev_device_add()-->set_property()):
+ *     obj    : VirtIOBlock
+ *     string : "io1"; (qemu-system-x86_64中给virtio block的iothread的id)
+ *     name   : "iothread"
+ */
 void object_property_parse(Object *obj, const char *string,
                            const char *name, Error **errp)
 {
     Visitor *v = string_input_visitor_new(string);
+    /* 根据name找到ObjectProperty, 然后调用其set方法 */
     object_property_set(obj, v, name, errp);
     visit_free(v);
 }
@@ -1434,11 +2422,58 @@ const char *object_property_get_type(Object *obj, const char *name, Error **errp
     return prop->type;
 }
 
+/*
+ * (gdb) p *object_get_root::root
+ * $5 = {
+ *   class = 0x5555567f1700, 
+ *   free = 0x7ffff50e58b0 <g_free>, 
+ *   properties = 0x555556883640, 
+ *   ref = 1, 
+ *   parent = 0x0
+ * }
+ * (gdb) p *object_get_root::root->class
+ * $6 = {
+ *   type = 0x5555567e8680, 
+ *   interfaces = 0x0, 
+ *   object_cast_cache = {0x0, 0x0, 0x0, 0x0}, 
+ *   class_cast_cache = {0x0, 0x0, 0x0, 0x0}, 
+ *   unparent = 0x0, 
+ *   properties = 0x55555678a180
+ * }
+ * (gdb) p *object_get_root::root->class->type
+ * $7 = {
+ *   name = 0x5555567e8800 "container", 
+ *   class_size = 96, 
+ *   instance_size = 40, 
+ *   class_init = 0x0, 
+ *   class_base_init = 0x0, 
+ *   class_finalize = 0x0, 
+ *   class_data = 0x0, 
+ *   instance_init = 0x0, 
+ *   instance_post_init = 0x0, 
+ *   instance_finalize = 0x0, 
+ *   abstract = false, 
+ *   parent = 0x5555567e8820 "object", 
+ *   parent_type = 0x5555567e84e0, 
+ *   class = 0x5555567f1700, 
+ *   num_interfaces = 0, 
+ *   interfaces = {{
+ *       typename = 0x0
+ *   } <repeats 32 times>}
+ * }
+ *
+ * 返回"container"的Object (root), 如果为空先初始化
+ */
 Object *object_get_root(void)
 {
     static Object *root;
 
     if (!root) {
+        /*
+	 * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+	 * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+	 * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+	 */
         root = object_new("container");
     }
 
@@ -1450,6 +2485,21 @@ Object *object_get_objects_root(void)
     return container_get(object_get_root(), "/objects");
 }
 
+/*
+ * 返回"container"的Object (internal_root), 如果为空先初始化
+ *
+ * (gdb) bt
+ * #0  object_get_internal_root () at qom/object.c:1457
+ * #1  0x00005555559d0132 in iothread_create (id=0x555555e8d6b4 "mon_iothread", errp=0x555556751590 <error_abort>) at iothread.c:366
+ * #2  0x0000555555857432 in monitor_iothread_init () at /home/zhang/kvm/qemu-3.0.0/monitor.c:4544
+ * #3  0x00005555558574ac in monitor_init_globals () at /home/zhang/kvm/qemu-3.0.0/monitor.c:4572
+ * #4  0x00005555559dc36d in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:3000
+ *
+ * called only by iothread_create():
+ *    366     obj = object_new_with_props(TYPE_IOTHREAD,
+ *    367                                 object_get_internal_root(),
+ *    368                                 id, errp, NULL);
+ */
 Object *object_get_internal_root(void)
 {
     static Object *internal_root;
@@ -1461,6 +2511,11 @@ Object *object_get_internal_root(void)
     return internal_root;
 }
 
+/*
+ * 用作get方法:
+ *   - qom/object.c|2008| <<object_property_add_child>> op = object_property_add(obj, name, type, object_get_child_property, NULL,
+ *   - qom/object.c|2191| <<object_property_add_const_link>> object_get_child_property, NULL,
+ */
 static void object_get_child_property(Object *obj, Visitor *v,
                                       const char *name, void *opaque,
                                       Error **errp)
@@ -1468,16 +2523,31 @@ static void object_get_child_property(Object *obj, Visitor *v,
     Object *child = opaque;
     gchar *path;
 
+    /*
+     * 如果obj是root ("container")就返回"/"
+     * 否则返回到达该obj的路径
+     */
     path = object_get_canonical_path(child);
     visit_type_str(v, name, &path, errp);
     g_free(path);
 }
 
+/*
+ * 用作ObjectProperty的resolve方法:
+ *   - qom/object.c|2020| <<object_property_add_child>> op->resolve = object_resolve_child_property;
+ *   - qom/object.c|2199| <<object_property_add_const_link>> op->resolve = object_resolve_child_property;
+ *
+ * 返回opaque
+ */
 static Object *object_resolve_child_property(Object *parent, void *opaque, const gchar *part)
 {
     return opaque;
 }
 
+/*
+ * 用作release方法:
+ *   - qom/object.c|2014| <<object_property_add_child>> object_finalize_child_property, child, &local_err);
+ */
 static void object_finalize_child_property(Object *obj, const char *name,
                                            void *opaque)
 {
@@ -1490,6 +2560,12 @@ static void object_finalize_child_property(Object *obj, const char *name,
     object_unref(child);
 }
 
+/*
+ * 把child设置成一个obj的ObjectProperty
+ * 在Object->properties (GHashTable)的name就是参数的name, type是"child<child的type>"
+ * ObjectProperty的opaque是child
+ * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+ */
 void object_property_add_child(Object *obj, const char *name,
                                Object *child, Error **errp)
 {
@@ -1504,6 +2580,10 @@ void object_property_add_child(Object *obj, const char *name,
 
     type = g_strdup_printf("child<%s>", object_get_typename(OBJECT(child)));
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     op = object_property_add(obj, name, type, object_get_child_property, NULL,
                              object_finalize_child_property, child, &local_err);
     if (local_err) {
@@ -1540,6 +2620,10 @@ static void object_get_link_property(Object *obj, Visitor *v,
     gchar *path;
 
     if (*child) {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         path = object_get_canonical_path(*child);
         visit_type_str(v, name, &path, errp);
         g_free(path);
@@ -1589,6 +2673,42 @@ static Object *object_resolve_link(Object *obj, const char *name,
     return target;
 }
 
+/*
+ * virtio block iothread的例子:
+ * (gdb) bt
+ * #0  object_set_link_property (obj=0x5555579da580, v=0x5555579df270, name=0x5555579dead0 "iothread", opaque=0x5555579dceb0, errp=0x7fffffffdf48) at qom/object.c:1595
+ * #1  0x0000555555c7ffa0 in object_property_set (obj=0x5555579da580, v=0x5555579df270, name=0x5555579dead0 "iothread", errp=0x7fffffffdf48) at qom/object.c:1176
+ * #2  0x0000555555c82b45 in property_set_alias (obj=0x5555579d2410, v=0x5555579df270, name=0x5555567f3b50 "iothread", opaque=0x5555579deab0, errp=0x7fffffffdf48) at qom/object.c:2330
+ * #3  0x0000555555c7ffa0 in object_property_set (obj=0x5555579d2410, v=0x5555579df270, name=0x5555567f3b50 "iothread", errp=0x7fffffffdf48) at qom/object.c:1176
+ * #4  0x0000555555c809bf in object_property_parse (obj=0x5555579d2410, string=0x5555567f3af0 "io1", name=0x5555567f3b50 "iothread", errp=0x7fffffffdf48) at qom/object.c:1402
+ * #5  0x00005555559d798e in set_property (opaque=0x5555579d2410, name=0x5555567f3b50 "iothread", value=0x5555567f3af0 "io1", errp=0x7fffffffdfd0) at qdev-monitor.c:180
+ * #6  0x0000555555dc83e9 in qemu_opt_foreach (opts=0x5555567f3920, func=0x5555559d7903 <set_property>, opaque=0x5555579d2410, errp=0x7fffffffdfd0) at util/qemu-option.c:580
+ * #7  0x00005555559d8e02 in qdev_device_add (opts=0x5555567f3920, errp=0x7fffffffe048) at qdev-monitor.c:622
+ * #8  0x00005555559e12b8 in device_init_func (opaque=0x0, opts=0x5555567f3920, errp=0x0) at vl.c:2275
+ * #9  0x0000555555dc96db in qemu_opts_foreach (list=0x5555565b76c0 <qemu_device_opts>, func=0x5555559e127a <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559e6449 in main (argc=16, argv=0x7fffffffe3b8, envp=0x7fffffffe440) at vl.c:4542
+ *
+ * 如果是初始化virtio block的iothread prop调用来的:
+ *   obj    : VirtIOBlock
+ *   v      : 用iothread id(比如"io1")制作的Visitor
+ *   name   : "iothread"
+ *   opaque : 一个分配的LinkProperty
+ *                  LinkProperty->child = 指向VirtIOBlock->conf.iothread(IOThread)指针的指针
+ *                                修改其值就相当于是给VirtIOBlock->conf.iothread(IOThread)赋值了
+ *                  LinkProperty->check = qdev_prop_allow_set_link_before_realize()
+ *                  LinkProperty->flags = OBJ_PROP_LINK_STRONG;
+ *
+ *   ObjectProperty->name    = "iothread";
+ *   ObjectProperty->type    = "link<iothread>";
+ *   ObjectProperty->get     = object_get_link_property();
+ *   ObjectProperty->set     = object_set_link_property();
+ *   ObjectProperty->release = object_get_release_property();
+ *   ObjectProperty->opaque  = 一个分配的LinkProperty
+ *                             LinkProperty->child = 指向VirtIOBlock->conf.iothread(IOThread)指针的指针
+ *                                           修改其值就相当于是给VirtIOBlock->conf.iothread(IOThread)赋值了
+ *                             LinkProperty->check = qdev_prop_allow_set_link_before_realize()
+ *                             LinkProperty->flags = OBJ_PROP_LINK_STRONG;
+ */
 static void object_set_link_property(Object *obj, Visitor *v,
                                      const char *name, void *opaque,
                                      Error **errp)
@@ -1600,6 +2720,7 @@ static void object_set_link_property(Object *obj, Visitor *v,
     Object *new_target = NULL;
     char *path = NULL;
 
+    /* 这里执行结束后一个path的例子是"io1", 也就是iothread的id */
     visit_type_str(v, name, &path, &local_err);
 
     if (!local_err && strcmp(path, "") != 0) {
@@ -1612,12 +2733,21 @@ static void object_set_link_property(Object *obj, Visitor *v,
         return;
     }
 
+    /*
+     * 在virtio block iothread的测试中: prop->check = qdev_prop_allow_set_link_before_realize()
+     */
     prop->check(obj, name, new_target, &local_err);
     if (local_err) {
         error_propagate(errp, local_err);
         return;
     }
 
+    /*
+     * 核心的地方!!!!!!
+     * 把找到的结果存入child
+     *
+     * 如果是virtio block "iothread", child是LinkProperty->child = 指向VirtIOBlock->conf.iothread(IOThread)指针的指针
+     */
     *child = new_target;
     if (prop->flags == OBJ_PROP_LINK_STRONG) {
         object_ref(new_target);
@@ -1643,6 +2773,40 @@ static void object_release_link_property(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * virtio block初始化"iothread"参数的例子:
+ * (gdb) bt
+ * #0  object_property_add_link (obj=0x55555771a410, name=0x555555d929bd "iothread", type=0x555555d929bd "iothread", child=0x55555771a5f8, 
+ *     check=0x555555a2e06a <qdev_prop_allow_set_link_before_realize>, flags=OBJ_PROP_LINK_STRONG, errp=0x7fffffffdd68) at qom/object.c:1652
+ * #1  0x0000555555a30fb7 in create_link_property (obj=0x55555771a410, prop=0x5555562e48b8 <virtio_blk_properties+1368>, errp=0x7fffffffdd68) at hw/core/qdev-properties.c:1308
+ * #2  0x0000555555a2cebd in qdev_property_add_static (dev=0x55555771a410, prop=0x5555562e48b8 <virtio_blk_properties+1368>, errp=0x5555564c9e70 <error_abort>) at hw/core/qdev.c:690
+ * #3  0x0000555555a2daaa in device_initfn (obj=0x55555771a410) at hw/core/qdev.c:966
+ * #4  0x0000555555c1dfee in object_init_with_type (obj=0x55555771a410, ti=0x55555650db70) at qom/object.c:353
+ * #5  0x0000555555c1dfd0 in object_init_with_type (obj=0x55555771a410, ti=0x5555564fd310) at qom/object.c:349
+ * #6  0x0000555555c1dfd0 in object_init_with_type (obj=0x55555771a410, ti=0x5555564f9e30) at qom/object.c:349
+ * #7  0x0000555555c1e1b1 in object_initialize_with_type (data=0x55555771a410, size=552, type=0x5555564f9e30) at qom/object.c:384
+ * #8  0x0000555555c1e202 in object_initialize (data=0x55555771a410, size=552, typename=0x555555e3ccef "virtio-blk-device") at qom/object.c:392
+ * #9  0x00005555558c9797 in virtio_instance_init_common (proxy_obj=0x5555577122a0, data=0x55555771a410, vdev_size=552, vdev_name=0x555555e3ccef "virtio-blk-device")
+ *     at /home/zhang/kvm/qemu-3.0.0/hw/virtio/virtio.c:2235
+ * #10 0x0000555555b92df4 in virtio_blk_pci_instance_init (obj=0x5555577122a0) at hw/virtio/virtio-pci.c:1992
+ * #11 0x0000555555c1dfee in object_init_with_type (obj=0x5555577122a0, ti=0x555556527f40) at qom/object.c:353
+ * #12 0x0000555555c1e1b1 in object_initialize_with_type (data=0x5555577122a0, size=33696, type=0x555556527f40) at qom/object.c:384
+ * #13 0x0000555555c1e805 in object_new_with_type (type=0x555556527f40) at qom/object.c:546
+ * #14 0x0000555555c1e842 in object_new (typename=0x555556536320 "virtio-blk-pci") at qom/object.c:556
+ * #15 0x000055555599064c in qdev_device_add (opts=0x5555565362d0, errp=0x7fffffffe078) at qdev-monitor.c:608
+ * #16 0x0000555555998bd0 in device_init_func (opaque=0x0, opts=0x5555565362d0, errp=0x0) at vl.c:2275
+ * #17 0x0000555555d682c9 in qemu_opts_foreach (list=0x5555562fd660 <qemu_device_opts>, func=0x555555998b92 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #18 0x000055555599dd61 in main (argc=16, argv=0x7fffffffe3e8, envp=0x7fffffffe470) at vl.c:4542
+ *
+ * 如果是初始化virtio block的iothread prop的此时的参数:
+ *   obj   : VirtIOBlock的Object
+ *   name  : "iothread"
+ *   type  : "iothread"
+ *   child : 指向VirtIOBlock->conf.iothread(IOThread)指针的指针
+ *           修改其值就相当于是给VirtIOBlock->conf.iothread(IOThread)赋值了
+ *   check : qdev_prop_allow_set_link_before_realize()
+ *   flags : OBJ_PROP_LINK_STRONG
+ */
 void object_property_add_link(Object *obj, const char *name,
                               const char *type, Object **child,
                               void (*check)(const Object *, const char *,
@@ -1661,6 +2825,18 @@ void object_property_add_link(Object *obj, const char *name,
 
     full_type = g_strdup_printf("link<%s>", type);
 
+    /*
+     * 如果是初始化virtio block的iothread prop的此时的参数:
+     *   obj       : VirtIOBlock的Object
+     *   name      : "iothread"
+     *   full_type : "link<iothread>"
+     *   check     : qdev_prop_allow_set_link_before_realize()
+     *   prop      : 一个分配的LinkProperty
+     *               prop->child = 指向VirtIOBlock->conf.iothread(IOThread)指针的指针
+     *                             修改其值就相当于是给VirtIOBlock->conf.iothread(IOThread)赋值了
+     *               prop->check = qdev_prop_allow_set_link_before_realize()
+     *               prop->flags = OBJ_PROP_LINK_STRONG;
+     */
     op = object_property_add(obj, name, full_type,
                              object_get_link_property,
                              check ? object_set_link_property : NULL,
@@ -1679,6 +2855,12 @@ out:
     g_free(full_type);
 }
 
+/*
+ * 把child设置成一个obj的ObjectProperty
+ * 在Object->properties (GHashTable)的name就是参数的name, type是"link<target的type>"
+ * 2003  * ObjectProperty的opaque是child
+ * 2004  * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+ */
 void object_property_add_const_link(Object *obj, const char *name,
                                     Object *target, Error **errp)
 {
@@ -1686,15 +2868,24 @@ void object_property_add_const_link(Object *obj, const char *name,
     ObjectProperty *op;
 
     link_type = g_strdup_printf("link<%s>", object_get_typename(target));
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     op = object_property_add(obj, name, link_type,
                              object_get_child_property, NULL,
                              NULL, target, errp);
     if (op != NULL) {
+        /* object_resolve_child_property就是返回opaque */
         op->resolve = object_resolve_child_property;
     }
     g_free(link_type);
 }
 
+/*
+ * 从该Object的parent的HashTable中寻找指向该Object的type开头是"child<"的并返回
+ * 似乎就是返回parent指向这个Object的prop->name
+ */
 gchar *object_get_canonical_path_component(Object *obj)
 {
     ObjectProperty *prop = NULL;
@@ -1705,7 +2896,9 @@ gchar *object_get_canonical_path_component(Object *obj)
     }
 
     g_hash_table_iter_init(&iter, obj->parent->properties);
+    /* 遍历parent (Object)的properties (HashTable) */
     while (g_hash_table_iter_next(&iter, NULL, (gpointer *)&prop)) {
+        /* 判断ObjectProperty的type是否开头是"child<" */
         if (!object_property_is_child(prop)) {
             continue;
         }
@@ -1720,16 +2913,26 @@ gchar *object_get_canonical_path_component(Object *obj)
     return NULL;
 }
 
+/*
+ * 如果obj是root ("container")就返回"/"
+ * 否则返回到达该obj的路径
+ */
 gchar *object_get_canonical_path(Object *obj)
 {
+    /* 返回"container"的Object (root), 如果为空先初始化 */
     Object *root = object_get_root();
     char *newpath, *path = NULL;
 
+    /* 如果参数的obj就是"container", 直接返回"/" */
     if (obj == root) {
         return g_strdup("/");
     }
 
     do {
+        /*
+	 * 从该Object的parent的HashTable中寻找指向该Object的type开头是"child<"的并返回
+	 * 似乎就是返回parent指向这个Object的prop->name
+	 */
         char *component = object_get_canonical_path_component(obj);
 
         if (!component) {
@@ -1740,6 +2943,7 @@ gchar *object_get_canonical_path(Object *obj)
             return NULL;
         }
 
+	/* 更新newpath */
         newpath = g_strdup_printf("/%s%s", component, path ? path : "");
         g_free(path);
         g_free(component);
@@ -1750,8 +2954,16 @@ gchar *object_get_canonical_path(Object *obj)
     return path;
 }
 
+/*
+ * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+ */
 Object *object_resolve_path_component(Object *parent, const gchar *part)
 {
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     ObjectProperty *prop = object_property_find(parent, part, NULL);
     if (prop == NULL) {
         return NULL;
@@ -1764,6 +2976,13 @@ Object *object_resolve_path_component(Object *parent, const gchar *part)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|2266| <<object_resolve_abs_path>> return object_resolve_abs_path(parent, parts, typename, index + 1);
+ *   - qom/object.c|2274| <<object_resolve_abs_path>> return object_resolve_abs_path(child, parts, typename, index + 1);
+ *   - qom/object.c|2286| <<object_resolve_partial_path>> obj = object_resolve_abs_path(parent, parts, typename, 0);
+ *   - qom/object.c|2331| <<object_resolve_path_type>> obj = object_resolve_abs_path(object_get_root(), parts, typename, 1);
+ */
 static Object *object_resolve_abs_path(Object *parent,
                                           gchar **parts,
                                           const char *typename,
@@ -1779,14 +2998,25 @@ static Object *object_resolve_abs_path(Object *parent,
         return object_resolve_abs_path(parent, parts, typename, index + 1);
     }
 
+    /*
+     * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+     */
     child = object_resolve_path_component(parent, parts[index]);
     if (!child) {
         return NULL;
     }
 
+    /*
+     * 递归调用自己, 处理parts[index+1]
+     */
     return object_resolve_abs_path(child, parts, typename, index + 1);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|2296| <<object_resolve_partial_path>> found = object_resolve_partial_path(prop->opaque, parts,
+ *   - qom/object.c|2325| <<object_resolve_path_type>> obj = object_resolve_partial_path(object_get_root(), parts,
+ */
 static Object *object_resolve_partial_path(Object *parent,
                                               gchar **parts,
                                               const char *typename,
@@ -1830,17 +3060,41 @@ Object *object_resolve_path_type(const char *path, const char *typename,
     Object *obj;
     gchar **parts;
 
+    /*
+     * 把path用'/'分开
+     *
+     * 对于/aaa/bbb/ccc/ddd
+     *     0: (不是NULL) 
+     *     1: aaa
+     *     2: bbb
+     *     3: ccc
+     *     4: ddd
+     *
+     * 对于aaa/bbb/ccc/ddd
+     *     0: aaa
+     *     1: bbb
+     *     2: ccc
+     *     3: ddd
+     */
     parts = g_strsplit(path, "/", 0);
     assert(parts);
 
     if (parts[0] == NULL || strcmp(parts[0], "") != 0) {
         bool ambiguous = false;
+	/*
+	 * object_get_root(): 返回"container"的Object (root), 如果为空先初始化
+	 */
         obj = object_resolve_partial_path(object_get_root(), parts,
                                           typename, &ambiguous);
         if (ambiguousp) {
             *ambiguousp = ambiguous;
         }
     } else {
+        /*
+	 * object_get_root(): 返回"container"的Object (root), 如果为空先初始化
+	 *
+	 * 最后的参数是1, 从第一个开始, 因为第0个是root
+	 */
         obj = object_resolve_abs_path(object_get_root(), parts, typename, 1);
     }
 
@@ -1854,12 +3108,20 @@ Object *object_resolve_path(const char *path, bool *ambiguous)
     return object_resolve_path_type(path, TYPE_OBJECT, ambiguous);
 }
 
+/*
+ * get和set的opaque
+ */
 typedef struct StringProperty
 {
     char *(*get)(Object *, Error **);
     void (*set)(Object *, const char *, Error **);
 } StringProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2384| <<object_property_add_str>> get ? property_get_str : NULL,
+ *   - qom/object.c|2419| <<object_class_property_add_str>> get ? property_get_str : NULL,
+ */
 static void property_get_str(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
 {
@@ -1877,6 +3139,11 @@ static void property_get_str(Object *obj, Visitor *v, const char *name,
     g_free(value);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|2385| <<object_property_add_str>> set ? property_set_str : NULL,
+ *   - qom/object.c|2420| <<object_class_property_add_str>> set ? property_set_str : NULL,
+ */
 static void property_set_str(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
 {
@@ -1894,6 +3161,11 @@ static void property_set_str(Object *obj, Visitor *v, const char *name,
     g_free(value);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2386| <<object_property_add_str>> property_release_str,
+ *   - qom/object.c|2421| <<object_class_property_add_str>> property_release_str,
+ */
 static void property_release_str(Object *obj, const char *name,
                                  void *opaque)
 {
@@ -1901,6 +3173,13 @@ static void property_release_str(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_str()
+ *     set     = property_set_str()
+ *     release = property_release_str()
+ */
 void object_property_add_str(Object *obj, const char *name,
                            char *(*get)(Object *, Error **),
                            void (*set)(Object *, const char *, Error **),
@@ -1909,9 +3188,14 @@ void object_property_add_str(Object *obj, const char *name,
     Error *local_err = NULL;
     StringProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_str(), property_set_str()和property_release_str用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "string",
                         get ? property_get_str : NULL,
                         set ? property_set_str : NULL,
@@ -1923,6 +3207,13 @@ void object_property_add_str(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_str()
+ *     set     = property_set_str()
+ *     release = property_release_str()
+ */
 void object_class_property_add_str(ObjectClass *klass, const char *name,
                                    char *(*get)(Object *, Error **),
                                    void (*set)(Object *, const char *,
@@ -1932,9 +3223,14 @@ void object_class_property_add_str(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     StringProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_str(), property_set_str()和property_release_str用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "string",
                               get ? property_get_str : NULL,
                               set ? property_set_str : NULL,
@@ -1946,12 +3242,20 @@ void object_class_property_add_str(ObjectClass *klass, const char *name,
     }
 }
 
+/*
+ * get和set的opaque
+ */
 typedef struct BoolProperty
 {
     bool (*get)(Object *, Error **);
     void (*set)(Object *, bool, Error **);
 } BoolProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2504| <<object_property_add_bool()>> get ? property_get_bool : NULL,
+ *   - qom/object.c|2526| <<object_class_property_add_bool()>> get ? property_get_bool : NULL,
+ */
 static void property_get_bool(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -1968,6 +3272,34 @@ static void property_get_bool(Object *obj, Visitor *v, const char *name,
     visit_type_bool(v, name, &value, errp);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|2505| <<object_property_add_bool()>> set ? property_set_bool : NULL,
+ *   - qom/object.c|2527| <<object_class_property_add_bool()>> set ? property_set_bool : NULL,
+ *
+ * 如下的会被object_property_set()调用:
+ *   - qom/object.c|2821| <<property_set_str>> prop->set(obj, value, errp);
+ *   - qom/object.c|2954| <<property_set_bool>> prop->set(obj, value, errp);
+ *   - qom/object.c|3090| <<property_set_enum>> prop->set(obj, value, errp);
+ *
+ *
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ *
+ *
+ * called by:
+ *   - qom/object.c|1957| <<object_property_set>> prop->set(obj, v, name, prop->opaque, errp);
+ */
 static void property_set_bool(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -1984,6 +3316,11 @@ static void property_set_bool(Object *obj, Visitor *v, const char *name,
     prop->set(obj, value, errp);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2531| <<object_property_add_bool()>> property_release_bool,
+ *   - qom/object.c|2565| <<object_class_property_add_bool()>> property_release_bool,
+ */
 static void property_release_bool(Object *obj, const char *name,
                                   void *opaque)
 {
@@ -1991,6 +3328,28 @@ static void property_release_bool(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 几个调用的例子:
+ *   - hw/core/bus.c|233| <<qbus_initfn>> object_property_add_bool(obj, "realized",
+ *   - hw/core/qdev.c|1004| <<device_initfn>> object_property_add_bool(obj, "realized",
+ *   - hw/core/qdev.c|1006| <<device_initfn>> object_property_add_bool(obj, "hotpluggable",
+ *   - hw/core/qdev.c|1008| <<device_initfn>> object_property_add_bool(obj, "hotplugged",
+ *
+ * 重要的一组例子:
+ * 1025     object_property_add_bool(obj, "realized",
+ * 1026                              device_get_realized, device_set_realized, NULL);
+ * 1027     object_property_add_bool(obj, "hotpluggable",
+ * 1028                              device_get_hotpluggable, NULL, NULL);
+ * 1029     object_property_add_bool(obj, "hotplugged",
+ * 1030                              device_get_hotplugged, NULL,
+ * 1031                              &error_abort);
+ *
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_bool()
+ *     set     = property_set_bool()
+ *     release = property_release_bool()
+ */
 void object_property_add_bool(Object *obj, const char *name,
                               bool (*get)(Object *, Error **),
                               void (*set)(Object *, bool, Error **),
@@ -1999,9 +3358,14 @@ void object_property_add_bool(Object *obj, const char *name,
     Error *local_err = NULL;
     BoolProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_bool(), property_set_bool()和property_release_bool用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "bool",
                         get ? property_get_bool : NULL,
                         set ? property_set_bool : NULL,
@@ -2013,6 +3377,13 @@ void object_property_add_bool(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_bool()
+ *     set     = property_set_bool()
+ *     release = property_release_bool()
+ */
 void object_class_property_add_bool(ObjectClass *klass, const char *name,
                                     bool (*get)(Object *, Error **),
                                     void (*set)(Object *, bool, Error **),
@@ -2021,9 +3392,14 @@ void object_class_property_add_bool(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     BoolProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_bool(), property_set_bool()和property_release_bool用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "bool",
                               get ? property_get_bool : NULL,
                               set ? property_set_bool : NULL,
@@ -2035,6 +3411,11 @@ void object_class_property_add_bool(ObjectClass *klass, const char *name,
     }
 }
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2631| <<object_property_add_enum>> get ? property_get_enum : NULL,
+ *   - qom/object.c|2656| <<object_class_property_add_enum>> get ? property_get_enum : NULL,
+ */
 static void property_get_enum(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -2051,6 +3432,11 @@ static void property_get_enum(Object *obj, Visitor *v, const char *name,
     visit_type_enum(v, name, &value, prop->lookup, errp);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|2632| <<object_property_add_enum>> set ? property_set_enum : NULL,
+ *   - qom/object.c|2657| <<object_class_property_add_enum>> set ? property_set_enum : NULL,
+ */
 static void property_set_enum(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -2066,6 +3452,11 @@ static void property_set_enum(Object *obj, Visitor *v, const char *name,
     prop->set(obj, value, errp);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2633| <<object_property_add_enum>> property_release_enum,
+ *   - qom/object.c|2658| <<object_class_property_add_enum>> property_release_enum,
+ */
 static void property_release_enum(Object *obj, const char *name,
                                   void *opaque)
 {
@@ -2073,6 +3464,13 @@ static void property_release_enum(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_enum()
+ *     set     = property_set_enum()
+ *     release = property_release_enum()
+ */
 void object_property_add_enum(Object *obj, const char *name,
                               const char *typename,
                               const QEnumLookup *lookup,
@@ -2083,10 +3481,15 @@ void object_property_add_enum(Object *obj, const char *name,
     Error *local_err = NULL;
     EnumProperty *prop = g_malloc(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_enum(), property_set_enum()和property_release_enum用到 */
     prop->lookup = lookup;
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, typename,
                         get ? property_get_enum : NULL,
                         set ? property_set_enum : NULL,
@@ -2098,6 +3501,13 @@ void object_property_add_enum(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_enum()
+ *     set     = property_set_enum()
+ *     release = property_release_enum()
+ */
 void object_class_property_add_enum(ObjectClass *klass, const char *name,
                                     const char *typename,
                                     const QEnumLookup *lookup,
@@ -2108,10 +3518,15 @@ void object_class_property_add_enum(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     EnumProperty *prop = g_malloc(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_enum(), property_set_enum()和property_release_enum用到 */
     prop->lookup = lookup;
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, typename,
                               get ? property_get_enum : NULL,
                               set ? property_set_enum : NULL,
@@ -2127,6 +3542,11 @@ typedef struct TMProperty {
     void (*get)(Object *, struct tm *, Error **);
 } TMProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2774| <<object_property_add_tm>> get ? property_get_tm : NULL, NULL,
+ *   - qom/object.c|2793| <<object_class_property_add_tm>> get ? property_get_tm : NULL, NULL,
+ */
 static void property_get_tm(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
 {
@@ -2175,6 +3595,11 @@ out:
 
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2775| <<object_property_add_tm>> property_release_tm,
+ *   - qom/object.c|2794| <<object_class_property_add_tm>> property_release_tm,
+ */
 static void property_release_tm(Object *obj, const char *name,
                                 void *opaque)
 {
@@ -2182,6 +3607,12 @@ static void property_release_tm(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_tm()
+ *     release = property_release_tm()
+ */
 void object_property_add_tm(Object *obj, const char *name,
                             void (*get)(Object *, struct tm *, Error **),
                             Error **errp)
@@ -2189,8 +3620,13 @@ void object_property_add_tm(Object *obj, const char *name,
     Error *local_err = NULL;
     TMProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_tm()和property_release_tm()用到 */
     prop->get = get;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "struct tm",
                         get ? property_get_tm : NULL, NULL,
                         property_release_tm,
@@ -2201,6 +3637,12 @@ void object_property_add_tm(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_tm()
+ *     release = property_release_tm()
+ */
 void object_class_property_add_tm(ObjectClass *klass, const char *name,
                                   void (*get)(Object *, struct tm *, Error **),
                                   Error **errp)
@@ -2208,8 +3650,13 @@ void object_class_property_add_tm(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     TMProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_tm()和property_release_tm()用到 */
     prop->get = get;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "struct tm",
                               get ? property_get_tm : NULL, NULL,
                               property_release_tm,
@@ -2220,11 +3667,19 @@ void object_class_property_add_tm(ObjectClass *klass, const char *name,
     }
 }
 
+/*
+ * 用作prop (opaque)的get
+ */
 static char *qdev_get_type(Object *obj, Error **errp)
 {
     return g_strdup(object_get_typename(obj));
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2873| <<object_property_add_uint8_ptr>> object_property_add(obj, name, "uint8", property_get_uint8_ptr,
+ *   - qom/object.c|2880| <<object_class_property_add_uint8_ptr>> object_class_property_add(klass, name, "uint8", property_get_uint8_ptr,
+ */
 static void property_get_uint8_ptr(Object *obj, Visitor *v, const char *name,
                                    void *opaque, Error **errp)
 {
@@ -2232,6 +3687,11 @@ static void property_get_uint8_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint8(v, name, &value, errp);
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2892| <<object_property_add_uint16_ptr>> object_property_add(obj, name, "uint16", property_get_uint16_ptr,
+ *   - qom/object.c|2899| <<object_class_property_add_uint16_ptr>> object_class_property_add(klass, name, "uint16", property_get_uint16_ptr,
+ */
 static void property_get_uint16_ptr(Object *obj, Visitor *v, const char *name,
                                     void *opaque, Error **errp)
 {
@@ -2239,6 +3699,11 @@ static void property_get_uint16_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint16(v, name, &value, errp);
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2911| <<object_property_add_uint32_ptr>> object_property_add(obj, name, "uint32", property_get_uint32_ptr,
+ *   - qom/object.c|2918| <<object_class_property_add_uint32_ptr>> object_class_property_add(klass, name, "uint32", property_get_uint32_ptr,
+ */
 static void property_get_uint32_ptr(Object *obj, Visitor *v, const char *name,
                                     void *opaque, Error **errp)
 {
@@ -2246,6 +3711,11 @@ static void property_get_uint32_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint32(v, name, &value, errp);
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2930| <<object_property_add_uint64_ptr>> object_property_add(obj, name, "uint64", property_get_uint64_ptr,
+ *   - qom/object.c|2937| <<object_class_property_add_uint64_ptr>> object_class_property_add(klass, name, "uint64", property_get_uint64_ptr,
+ */
 static void property_get_uint64_ptr(Object *obj, Visitor *v, const char *name,
                                     void *opaque, Error **errp)
 {
@@ -2253,58 +3723,122 @@ static void property_get_uint64_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint64(v, name, &value, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint8_ptr(Object *obj, const char *name,
                                    const uint8_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint8", property_get_uint8_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint8_ptr(ObjectClass *klass, const char *name,
                                          const uint8_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint8", property_get_uint8_ptr,
                               NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint16_ptr(Object *obj, const char *name,
                                     const uint16_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint16", property_get_uint16_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint16_ptr(ObjectClass *klass, const char *name,
                                           const uint16_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint16", property_get_uint16_ptr,
                               NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint32_ptr(Object *obj, const char *name,
                                     const uint32_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint32", property_get_uint32_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint32_ptr(ObjectClass *klass, const char *name,
                                           const uint32_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint32", property_get_uint32_ptr,
                               NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint64_ptr(Object *obj, const char *name,
                                     const uint64_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint64", property_get_uint64_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint64_ptr(ObjectClass *klass, const char *name,
                                           const uint64_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint64", property_get_uint64_ptr,
                               NULL, NULL, (void *)v, errp);
 }
@@ -2314,30 +3848,51 @@ typedef struct {
     char *target_name;
 } AliasProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|3536| <<object_property_add_alias>> property_get_alias,
+ */
 static void property_get_alias(Object *obj, Visitor *v, const char *name,
                                void *opaque, Error **errp)
 {
     AliasProperty *prop = opaque;
 
+    /* 根据name找到ObjectProperty, 然后调用其get方法 */
     object_property_get(prop->target_obj, v, prop->target_name, errp);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|3537| <<object_property_add_alias>> property_set_alias,
+ */
 static void property_set_alias(Object *obj, Visitor *v, const char *name,
                                void *opaque, Error **errp)
 {
     AliasProperty *prop = opaque;
 
+    /* 根据name找到ObjectProperty, 然后调用其set方法 */
     object_property_set(prop->target_obj, v, prop->target_name, errp);
 }
 
+/*
+ * 作为ObjectProperty的resolve方法:
+ *   - qom/object.c|3545| <<object_property_add_alias>> op->resolve = property_resolve_alias;
+ */
 static Object *property_resolve_alias(Object *obj, void *opaque,
                                       const gchar *part)
 {
     AliasProperty *prop = opaque;
 
+    /*
+     * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+     */
     return object_resolve_path_component(prop->target_obj, prop->target_name);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|3538| <<object_property_add_alias>> property_release_alias,
+ */
 static void property_release_alias(Object *obj, const char *name, void *opaque)
 {
     AliasProperty *prop = opaque;
@@ -2346,6 +3901,10 @@ static void property_release_alias(Object *obj, const char *name, void *opaque)
     g_free(prop);
 }
 
+/*
+ * 一个调用的例子:
+ *   - hw/virtio/virtio-pci.c|1994| <<virtio_blk_pci_instance_init>> object_property_add_alias(obj, "bootindex", OBJECT(&dev->vdev),
+ */
 void object_property_add_alias(Object *obj, const char *name,
                                Object *target_obj, const char *target_name,
                                Error **errp)
@@ -2356,11 +3915,28 @@ void object_property_add_alias(Object *obj, const char *name,
     gchar *prop_type;
     Error *local_err = NULL;
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     target_prop = object_property_find(target_obj, target_name, errp);
     if (!target_prop) {
         return;
     }
 
+    /*
+     * 如果是virtio block pci进来的 (假设是num_queues的例子):
+     * 通过virtio_instance_init_common()-->qdev_alias_all_properties()
+     *   obj         : VirtIOBlkPCI的Object
+     *   name        : "num_queues"
+     *   target_obj  : VirtIOBlock的Object
+     *   target_name : "num_queues"
+     *
+     *   target_prop : 是上面用object_property_find()在VirtIOBlock找到的"num_queues"的ObjectProperty
+     */
+
+    /* 判断ObjectProperty的type是否开头是"child<" */
     if (object_property_is_child(target_prop)) {
         prop_type = g_strdup_printf("link%s",
                                     target_prop->type + strlen("child"));
@@ -2372,6 +3948,10 @@ void object_property_add_alias(Object *obj, const char *name,
     prop->target_obj = target_obj;
     prop->target_name = g_strdup(target_name);
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     op = object_property_add(obj, name, prop_type,
                              property_get_alias,
                              property_set_alias,
@@ -2384,6 +3964,12 @@ void object_property_add_alias(Object *obj, const char *name,
     }
     op->resolve = property_resolve_alias;
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     * 最后修改找到的ObjectProperty的description
+     */
     object_property_set_description(obj, op->name,
                                     target_prop->description,
                                     &error_abort);
@@ -2392,11 +3978,22 @@ out:
     g_free(prop_type);
 }
 
+/*
+ * 递归调用自己的parent (ObjectClass) 寻找prop
+ * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+ * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+ * 最后修改找到的ObjectProperty的description
+ */
 void object_property_set_description(Object *obj, const char *name,
                                      const char *description, Error **errp)
 {
     ObjectProperty *op;
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     op = object_property_find(obj, name, errp);
     if (!op) {
         return;
@@ -2406,6 +4003,10 @@ void object_property_set_description(Object *obj, const char *name,
     op->description = g_strdup(description);
 }
 
+/*
+ * 从ObjectClass(不是Object)的properties中寻找name的ObjectProperty
+ * 找到后重新设置ObjectProperty的description
+ */
 void object_class_property_set_description(ObjectClass *klass,
                                            const char *name,
                                            const char *description,
@@ -2423,11 +4024,30 @@ void object_class_property_set_description(ObjectClass *klass,
     op->description = g_strdup(description);
 }
 
+/*
+ * TypeInfo object_info.instance_init = object_instance_init()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void object_instance_init(Object *obj)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     *     get     = property_get_str()
+     *     set     = property_set_str()
+     *     release = property_release_str()
+     *
+     *  qdev_get_type()就是返回obj->class->type->name
+     */
     object_property_add_str(obj, "type", qdev_get_type, NULL, NULL);
 }
 
+/*
+ * 在以下被间接调用:
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ */
 static void register_types(void)
 {
     static TypeInfo interface_info = {
@@ -2443,8 +4063,31 @@ static void register_types(void)
         .abstract = true,
     };
 
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_interface = type_register_internal(&interface_info);
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_internal(&object_info);
 }
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ *
+ * 所有注册的module_init_type在以下调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * module_call_init()遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
 type_init(register_types)
diff --git a/qom/object_interfaces.c b/qom/object_interfaces.c
index 72b97a8..c1ccd33 100644
--- a/qom/object_interfaces.c
+++ b/qom/object_interfaces.c
@@ -168,6 +168,9 @@ void user_creatable_del(const char *id, Error **errp)
     Object *obj;
 
     container = object_get_objects_root();
+    /*
+     * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+     */
     obj = object_resolve_path_component(container, id);
     if (!obj) {
         error_setg(errp, "object '%s' not found", id);
diff --git a/qom/qom-qobject.c b/qom/qom-qobject.c
index 4aec20d..b7fedf5 100644
--- a/qom/qom-qobject.c
+++ b/qom/qom-qobject.c
@@ -18,16 +18,60 @@
 #include "qapi/qobject-input-visitor.h"
 #include "qapi/qobject-output-visitor.h"
 
+/*
+ * called by:
+ *   - qmp.c|235| <<qmp_qom_set>> object_property_set_qobject(obj, value, property, errp);
+ *   - qom/object.c|1650| <<object_property_set_str>> object_property_set_qobject(obj, QOBJECT(qstr), name, errp);
+ *   - qom/object.c|1708| <<object_property_set_bool>> object_property_set_qobject(obj, QOBJECT(qbool), name, errp);
+ *   - qom/object.c|1739| <<object_property_set_int>> object_property_set_qobject(obj, QOBJECT(qnum), name, errp);
+ *   - qom/object.c|1770| <<object_property_set_uint>> object_property_set_qobject(obj, QOBJECT(qnum), name, errp);
+ *   - target/i386/cpu.c|3696| <<object_apply_props>> object_property_set_qobject(obj, qdict_entry_value(prop),
+ *
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 void object_property_set_qobject(Object *obj, QObject *value,
                                  const char *name, Error **errp)
 {
     Visitor *v;
 
+    /*
+     * 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是value(QObject)
+     * 返回包含的Visitor
+     */
     v = qobject_input_visitor_new(value);
+    /*
+     * 据name找到ObjectProperty, 然后调用其set方法
+     */
     object_property_set(obj, v, name, errp);
     visit_free(v);
 }
 
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|196| <<acpi_get_pm_info>> o = object_property_get_qobject(obj, ACPI_PM_PROP_S3_DISABLED, NULL);
+ *   - hw/i386/acpi-build.c|203| <<acpi_get_pm_info>> o = object_property_get_qobject(obj, ACPI_PM_PROP_S4_DISABLED, NULL);
+ *   - hw/i386/acpi-build.c|210| <<acpi_get_pm_info>> o = object_property_get_qobject(obj, ACPI_PM_PROP_S4_VAL, NULL);
+ *   - hw/i386/acpi-build.c|438| <<build_append_pci_bus_devices>> bsel = object_property_get_qobject(OBJECT(bus), ACPI_PCIHP_PROP_BSEL, NULL);
+ *   - hw/i386/acpi-build.c|2617| <<acpi_get_mcfg>> o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_BASE, NULL);
+ *   - hw/i386/acpi-build.c|2624| <<acpi_get_mcfg>> o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_SIZE, NULL);
+ *   - qmp.c|249| <<qmp_qom_get>> return object_property_get_qobject(obj, property, errp);
+ *   - qom/object.c|1658| <<object_property_get_str>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - qom/object.c|1716| <<object_property_get_bool>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - qom/object.c|1747| <<object_property_get_int>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - qom/object.c|1777| <<object_property_get_uint>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - target/i386/cpu.c|3642| <<x86_cpu_expand_prop>> QObject *value = object_property_get_qobject(OBJECT(cpu), prop,
+ */
 QObject *object_property_get_qobject(Object *obj, const char *name,
                                      Error **errp)
 {
@@ -36,6 +80,9 @@ QObject *object_property_get_qobject(Object *obj, const char *name,
     Visitor *v;
 
     v = qobject_output_visitor_new(&ret);
+    /*
+     * 根据name找到ObjectProperty, 然后调用其get方法
+     */
     object_property_get(obj, v, name, &local_err);
     if (!local_err) {
         visit_complete(v, &ret);
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 723e022..268a12f 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -4480,6 +4480,22 @@ static void x86_cpu_apic_create(X86CPU *cpu, Error **errp)
     apic->apicbase = APIC_DEFAULT_ADDRESS | MSR_IA32_APICBASE_ENABLE;
 }
 
+/*
+ * 测试的几个cpu调用几次:
+ * #0  x86_cpu_apic_realize (cpu=0x5555568e8780, errp=0x7fffffffdc40) at /home/zhang/kvm/qemu-3.0.0/target/i386/cpu.c:4488
+ * #1  0x00005555559571da in x86_cpu_realizefn (dev=0x5555568e8780, errp=0x7fffffffdcc0) at /home/zhang/kvm/qemu-3.0.0/target/i386/cpu.c:5017
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555568e8780, value=true, errp=0x7fffffffde98) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555568e8780, v=0x555556902000, name=0x555555ea7440 "realized", opaque=0x5555568e8710, errp=0x7fffffffde98) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555568e8780, v=0x555556902000, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555568e8780, value=0x5555569066a0, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555568e8780, value=true, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/object.c:1242
+ * #7  0x00005555559184e7 in pc_new_cpu (typename=0x555555ea7dec "qemu64-x86_64-cpu", apic_id=1, errp=0x555556751598 <error_fatal>) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1107
+ * #8  0x0000555555918752 in pc_cpus_init (pcms=0x55555684fa40) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1155
+ * #9  0x000055555591cd4d in pc_init1 (machine=0x55555684fa40, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:153
+ * #10 0x000055555591da26 in pc_init_v3_0 (machine=0x55555684fa40) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #11 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684fa40) at hw/core/machine.c:830
+ * #12 0x00005555559dfb8f in main (argc=16, argv=0x7fffffffe388, envp=0x7fffffffe410) at vl.c:4516
+ */
 static void x86_cpu_apic_realize(X86CPU *cpu, Error **errp)
 {
     APICCommonState *apic;
diff --git a/target/i386/kvm.c b/target/i386/kvm.c
index 9313602..a260ff1 100644
--- a/target/i386/kvm.c
+++ b/target/i386/kvm.c
@@ -1374,6 +1374,10 @@ static void register_smram_listener(Notifier *n, void *unused)
                                  &smram_address_space, 1);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1677| <<kvm_init>> ret = kvm_arch_init(ms, s);
+ */
 int kvm_arch_init(MachineState *ms, KVMState *s)
 {
     uint64_t identity_base = 0xfffbc000;
diff --git a/ui/console.c b/ui/console.c
index bc58458..b4144cb 100644
--- a/ui/console.c
+++ b/ui/console.c
@@ -1877,6 +1877,12 @@ static DisplayState *get_alloc_displaystate(void)
  * Called by main(), after creating QemuConsoles
  * and before initializing ui (sdl/vnc/...).
  */
+/*
+ * gdb调试确认被调用了
+ * (gdb) bt
+ * #0  init_displaystate () at ui/console.c:1885
+ * #1  0x00005555559dfcaa in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4573
+ */
 DisplayState *init_displaystate(void)
 {
     gchar *name;
diff --git a/util/aio-posix.c b/util/aio-posix.c
index 118bf57..434c218 100644
--- a/util/aio-posix.c
+++ b/util/aio-posix.c
@@ -24,12 +24,59 @@
 #include <sys/epoll.h>
 #endif
 
+/*
+ * GMainLoop --> GMainContext --> {GSource1, GSource2, GSource3 ...}
+ *
+ * 每个GMainLoop都包含一个GMainContext成员,而这个GMainContext成员可以装各
+ * 种各样的GSource.GSource则是具体的各种Event处理逻辑了.可以把GMainContext
+ * 理解为GSource的容器(不过它的用处不只是装GSource).
+ *
+ *
+ * GSource的接口:
+ *
+ * - prepare(): 进入睡眠前,在g_main_context_prepare()里,mainloop调用所有的
+ *   GSource的prepare函数,计算最小的timeout时间,该时间决定下一次睡眠的时间.
+ *
+ * - check(): poll()被唤醒后,在g_main_context_check()里,mainloop调用所有的
+ *   GSource的check函数,检查是否有GSOurce预警准备好了.如果poll是由于错误或
+ *   超时等原因唤醒的,就不必dispatch了.
+ *
+ * - dispatch(): 当前有GSource准备好了,在g_main_context_dispatch()里,
+ *   mainloop调用所有的GSource的dispatch去分发消息.
+ *
+ * - finalize()在GSource被移出时,mainloop调用该函数去销毁GSource.
+ */
+
 struct AioHandler
 {
     GPollFD pfd;
+    /*
+     * called by:
+     *   - util/aio-posix.c|406| <<aio_dispatch_handlers>> node->io_read(node->opaque);
+     */
     IOHandler *io_read;
+    /*
+     * called by:
+     *   - util/aio-posix.c|421| <<aio_dispatch_handlers>> node->io_write(node->opaque);
+     */
     IOHandler *io_write;
+    /*
+     * called by:
+     *   - util/aio-posix.c|501| <<run_poll_handlers_once>> node->io_poll(node->opaque)) {
+     */
     AioPollFn *io_poll;
+    /*
+     * called by poll_set_started():
+     * 350         if (started) {
+     * 351             fn = node->io_poll_begin;
+     * 352         } else {     
+     * 353             fn = node->io_poll_end;
+     * 354         }
+     * 355 
+     * 356         if (fn) {
+     * 357             fn(node->opaque);
+     * 358         }
+     */
     IOHandler *io_poll_begin;
     IOHandler *io_poll_end;
     int deleted;
@@ -43,6 +90,12 @@ struct AioHandler
 /* The fd number threashold to switch to epoll */
 #define EPOLL_ENABLE_THRESHOLD 64
 
+/*
+ * called by:
+ *   - util/aio-posix.c|128| <<aio_epoll_update>> aio_epoll_disable(ctx);
+ *   - util/aio-posix.c|183| <<aio_epoll_check_poll>> aio_epoll_disable(ctx);
+ *   - util/aio-posix.c|746| <<aio_context_destroy>> aio_epoll_disable(ctx);
+ */
 static void aio_epoll_disable(AioContext *ctx)
 {
     ctx->epoll_enabled = false;
@@ -61,6 +114,10 @@ static inline int epoll_events_from_pfd(int pfd_events)
            (pfd_events & G_IO_ERR ? EPOLLERR : 0);
 }
 
+/*
+ * 核心思想是遍历ctx->aio_handlers上每一个AioHandler
+ * 用EPOLL_CTL_ADD将其挂到ctx->epollfd
+ */
 static bool aio_epoll_try_enable(AioContext *ctx)
 {
     AioHandler *node;
@@ -82,6 +139,9 @@ static bool aio_epoll_try_enable(AioContext *ctx)
     return true;
 }
 
+/*
+ * 核心思想是把参数的AioHandler根据情况使用EPOLL_CTL_ADD,EPOLL_CTL_MOD,EPOLL_CTL_DEL
+ */
 static void aio_epoll_update(AioContext *ctx, AioHandler *node, bool is_new)
 {
     struct epoll_event event;
@@ -105,6 +165,10 @@ static void aio_epoll_update(AioContext *ctx, AioHandler *node, bool is_new)
     }
 }
 
+/*
+ * 只被以下调用:
+ *   - util/aio-posix.c|667| <<aio_poll>> ret = aio_epoll(ctx, pollfds, npfd, timeout);
+ */
 static int aio_epoll(AioContext *ctx, GPollFD *pfds,
                      unsigned npfd, int64_t timeout)
 {
@@ -187,6 +251,13 @@ static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,
 
 #endif
 
+/*
+ * called by:
+ *   - util/aio-posix.c|281| <<aio_set_fd_handler>> node = find_aio_handler(ctx, fd);
+ *   - util/aio-posix.c|354| <<aio_set_fd_poll>> AioHandler *node = find_aio_handler(ctx, fd);
+ *
+ * 遍历AioContext->aio_handlers中所有的AioHandler,返回fd对应的AioHandler(前提是deleted是false)
+ */
 static AioHandler *find_aio_handler(AioContext *ctx, int fd)
 {
     AioHandler *node;
@@ -200,6 +271,19 @@ static AioHandler *find_aio_handler(AioContext *ctx, int fd)
     return NULL;
 }
 
+/*
+ * 假设是virtio_blk_data_plane_start()-->
+ * virtio_queue_aio_set_host_notifier_handler()-->
+ * aio_set_event_notifier()调用进来的
+ *
+ * ctx = VirtIOBlockDataPlane->ctx
+ * fd = VirtQueue->host_notifier->rfd
+ * is_external = true
+ * io_read = virtio_queue_host_notifier_aio_read
+ * io_write = NULL
+ * io_poll = virtio_queue_host_notifier_aio_poll
+ * opaque = VirtQueue->host_notifier
+ */
 void aio_set_fd_handler(AioContext *ctx,
                         int fd,
                         bool is_external,
@@ -214,9 +298,13 @@ void aio_set_fd_handler(AioContext *ctx,
 
     qemu_lockcnt_lock(&ctx->list_lock);
 
+    /* 遍历AioContext->aio_handlers中所有的AioHandler,返回fd对应的AioHandler(前提是deleted是false) */
     node = find_aio_handler(ctx, fd);
 
     /* Are we deleting the fd handler? */
+    /*
+     * 如果io_read, io_write和io_poll都是NULL, 说明想删除这个AioHandler
+     */
     if (!io_read && !io_write && !io_poll) {
         if (node == NULL) {
             qemu_lockcnt_unlock(&ctx->list_lock);
@@ -255,11 +343,13 @@ void aio_set_fd_handler(AioContext *ctx,
             node->pfd.fd = fd;
             QLIST_INSERT_HEAD_RCU(&ctx->aio_handlers, node, node);
 
+	    /* 重要!!! 把fd挂到ctx->source */
             g_source_add_poll(&ctx->source, &node->pfd);
             is_new = true;
 
             ctx->poll_disable_cnt += !io_poll;
         } else {
+            /* 如果已经有AioHandler了,不用分配了,下面直接修改 */
             ctx->poll_disable_cnt += !io_poll - !node->io_poll;
         }
 
@@ -274,6 +364,7 @@ void aio_set_fd_handler(AioContext *ctx,
         node->pfd.events |= (io_write ? G_IO_OUT | G_IO_ERR : 0);
     }
 
+    /* 核心思想是把参数的AioHandler根据情况使用EPOLL_CTL_ADD,EPOLL_CTL_MOD,EPOLL_CTL_DEL */
     aio_epoll_update(ctx, node, is_new);
     qemu_lockcnt_unlock(&ctx->list_lock);
     aio_notify(ctx);
@@ -303,6 +394,18 @@ void aio_set_event_notifier(AioContext *ctx,
                             EventNotifierHandler *io_read,
                             AioPollFn *io_poll)
 {
+    /*
+     * 假设是virtio_blk_data_plane_start()-->virtio_queue_aio_set_host_notifier_handler()调用进来的
+     * 3408         aio_set_event_notifier(ctx, &vq->host_notifier, true,
+     * 3409                                virtio_queue_host_notifier_aio_read,
+     * 3410                                virtio_queue_host_notifier_aio_poll);
+     *
+     * ctx = VirtIOBlockDataPlane->ctx
+     * notifier = VirtQueue->host_notifier
+     * is_external = true
+     * io_read = virtio_queue_host_notifier_aio_read
+     * io_poll = virtio_queue_host_notifier_aio_poll
+     */
     aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,
                        (IOHandler *)io_read, NULL, io_poll, notifier);
 }
@@ -573,6 +676,17 @@ static bool try_poll_mode(AioContext *ctx, bool blocking)
     return run_poll_handlers_once(ctx);
 }
 
+/*
+ * iothread idle时的状态:
+ * (gdb) bt
+ * #0  0x00007ffff4483811 in __GI_ppoll (fds=0x7fffe00008c0, nfds=3, timeout=<optimized out>, sigmask=0x0) at ../sysdeps/unix/sysv/linux/ppoll.c:50
+ * #1  0x0000555555dafcda in qemu_poll_ns (fds=0x7fffe00008c0, nfds=3, timeout=-1) at util/qemu-timer.c:322
+ * #2  0x0000555555db2a39 in aio_poll (ctx=0x555556895200, blocking=true) at util/aio-posix.c:629
+ * #3  0x00005555559d5f1a in iothread_run (opaque=0x555556894d00) at iothread.c:64
+ * #4  0x0000555555db5d87 in qemu_thread_start (args=0x5555568955d0) at util/qemu-thread-posix.c:504
+ * #5  0x00007ffff47596ba in start_thread (arg=0x7fffe7fff700) at pthread_create.c:333
+ * #6  0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 bool aio_poll(AioContext *ctx, bool blocking)
 {
     AioHandler *node;
@@ -590,6 +704,9 @@ bool aio_poll(AioContext *ctx, bool blocking)
      * so disable the optimization now.
      */
     if (blocking) {
+        /*
+	 * 为什么加2??????
+	 */
         atomic_add(&ctx->notify_me, 2);
     }
 
diff --git a/util/async.c b/util/async.c
index 05979f8..30e2fdc 100644
--- a/util/async.c
+++ b/util/async.c
@@ -34,6 +34,15 @@
 #include "qemu/coroutine_int.h"
 #include "trace.h"
 
+/*
+ * 在qemu里主要有3种AioContext (AioContext的aio_handlers存着所有该context当前poll的handler和fd):
+ *
+ * * qemu_aio_context : 似乎不太用,比如vnc或者qmp命令
+ * * iohhandler_ctx   : main loop用这个
+ * * iothread->ctx    : iothread用的. qemu的block device决定是用mainloop的还是
+ *                      iothread的context, 比如virtio_blk_dataplane_create()
+ */
+
 /***********************************************************/
 /* bottom halves (can be seen as timers which expire ASAP) */
 
@@ -47,6 +56,11 @@ struct QEMUBH {
     bool deleted;
 };
 
+/*
+ * 用参数的cb和opaque制作一个QEMUBH,链接到AioContext->first_bh
+ * QEMUBH->deleted设置成1 (执行一次就删除)
+ * 然后根据情况set一下AioContext->notifier
+ */
 void aio_bh_schedule_oneshot(AioContext *ctx, QEMUBHFunc *cb, void *opaque)
 {
     QEMUBH *bh;
@@ -59,6 +73,9 @@ void aio_bh_schedule_oneshot(AioContext *ctx, QEMUBHFunc *cb, void *opaque)
     qemu_lockcnt_lock(&ctx->list_lock);
     bh->next = ctx->first_bh;
     bh->scheduled = 1;
+    /*
+     * 设置bh->deleted就是执行一次就删除吧
+     */
     bh->deleted = 1;
     /* Make sure that the members are ready before putting bh into list */
     smp_wmb();
@@ -67,6 +84,24 @@ void aio_bh_schedule_oneshot(AioContext *ctx, QEMUBHFunc *cb, void *opaque)
     aio_notify(ctx);
 }
 
+/*
+ * called by:
+ *   - util/main-loop.c|510| <<qemu_bh_new>> return aio_bh_new(qemu_aio_context, cb, opaque);
+ *   - hw/block/dataplane/virtio-blk.c|202| <<virtio_blk_data_plane_create>> s->bh = aio_bh_new(s->ctx, notify_guest_bh, s);
+ *   - hw/block/virtio-blk.c|1215| <<virtio_blk_dma_restart_cb>> s->bh = aio_bh_new(blk_get_aio_context(s->conf.conf.blk),
+ *   - hw/block/xen_disk.c|626| <<blk_alloc>> blkdev->bh = aio_bh_new(blkdev->ctx, blk_bh, blkdev);
+ *   - hw/scsi/scsi-bus.c|146| <<scsi_dma_restart_cb>> s->bh = aio_bh_new(ctx, scsi_dma_restart_bh, s);
+ *   - monitor.c|4551| <<monitor_iothread_init>> qmp_dispatcher_bh = aio_bh_new(iohandler_get_aio_context(),
+ *   - monitor.c|4560| <<monitor_iothread_init>> qmp_respond_bh = aio_bh_new(monitor_get_aio_context(),
+ *   - util/async.c|424| <<aio_context_new>> ctx->co_schedule_bh = aio_bh_new(ctx, co_schedule_bh_cb, ctx);
+ *   - util/thread-pool.c|310| <<thread_pool_init_one>> pool->completion_bh = aio_bh_new(ctx, thread_pool_completion_bh, pool);
+ *   - util/thread-pool.c|315| <<thread_pool_init_one>> pool->new_thread_bh = aio_bh_new(ctx, spawn_thread_bh_fn, pool);
+ *   - block/blkreplay.c|74| <<block_request_create>> .bh = aio_bh_new(bdrv_get_aio_context(bs), blkreplay_bh_cb, req),
+ *   - block/iscsi.c|172| <<iscsi_schedule_bh>> acb->bh = aio_bh_new(acb->iscsilun->aio_context, iscsi_bh_cb, acb);
+ *   - block/iscsi.c|993| <<iscsi_ioctl_handle_emulated>> acb->bh = aio_bh_new(bdrv_get_aio_context(bs),
+ *   - block/linux-aio.c|468| <<laio_attach_aio_context>> s->completion_bh = aio_bh_new(new_context, qemu_laio_completion_bh, s);
+ *   - dma-helpers.c|159| <<dma_blk_cb>> dbs->bh = aio_bh_new(dbs->ctx, reschedule_dma, dbs);
+ */
 QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)
 {
     QEMUBH *bh;
@@ -94,6 +129,11 @@ void aio_bh_call(QEMUBH *bh)
  * The count in ctx->list_lock is incremented before the call, and is
  * not affected by the call.
  */
+/*
+ * called by:
+ *   - util/aio-posix.c|436| <<aio_dispatch>> aio_bh_poll(ctx);
+ *   - util/aio-posix.c|689| <<aio_poll>> progress |= aio_bh_poll(ctx);
+ */
 int aio_bh_poll(AioContext *ctx)
 {
     QEMUBH *bh, **bhp, *next;
@@ -405,6 +445,12 @@ static void co_schedule_bh_cb(void *opaque)
     }
 }
 
+/*
+ * called by:
+ *   - iothread.c|151| <<iothread_complete>> iothread->ctx = aio_context_new(&local_error);
+ *   - util/iohandler.c|52| <<iohandler_init>> iohandler_ctx = aio_context_new(&error_abort);
+ *   - util/main-loop.c|156| <<qemu_init_main_loop>> qemu_aio_context = aio_context_new(&local_error);
+ */
 AioContext *aio_context_new(Error **errp)
 {
     int ret;
diff --git a/util/cutils.c b/util/cutils.c
index 9205e09..e9d9035 100644
--- a/util/cutils.c
+++ b/util/cutils.c
@@ -153,6 +153,23 @@ time_t mktimegm(struct tm *tm)
  * Unfortunately even in 2009 many operating systems do not support
  * fdatasync and have to fall back to fsync.
  */
+/*
+ * virtio block的一个flush的例子(在worker thread中执行的):
+ * (gdb) bt
+ * #0  qemu_fdatasync (fd=16) at util/cutils.c:159
+ * #1  0x0000555555cf1b1d in handle_aiocb_flush (aiocb=0x7fffe0000c00) at block/file-posix.c:1134
+ * #2  0x0000555555cf2dca in aio_worker (arg=0x7fffe0000c00) at block/file-posix.c:1753
+ * #3  0x0000555555daeb10 in worker_thread (opaque=0x7fffe0000c50) at util/thread-pool.c:105
+ * #4  0x0000555555db5d87 in qemu_thread_start (args=0x7fffe0000aa0) at util/qemu-thread-posix.c:504
+ * #5  0x00007ffff47596ba in start_thread (arg=0x7fff437fe700) at pthread_create.c:333
+ * #6  0x00007ffff448f41d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * called by:
+ *   - block/file-posix.c|1134| <<handle_aiocb_flush>> ret = qemu_fdatasync(aiocb->aio_fildes);
+ *   - hw/9pfs/9p-handle.c|412| <<handle_fsync>> return qemu_fdatasync(fd);
+ *   - hw/9pfs/9p-local.c|1165| <<local_fsync>> return qemu_fdatasync(fd);
+ *   - hw/9pfs/9p-proxy.c|940| <<proxy_fsync>> return qemu_fdatasync(fd);
+ */
 int qemu_fdatasync(int fd)
 {
 #ifdef CONFIG_FDATASYNC
diff --git a/util/event_notifier-posix.c b/util/event_notifier-posix.c
index 73c4046..1b47249 100644
--- a/util/event_notifier-posix.c
+++ b/util/event_notifier-posix.c
@@ -25,6 +25,10 @@
  * Initialize @e with existing file descriptor @fd.
  * @fd must be a genuine eventfd object, emulation with pipe won't do.
  */
+/*
+ * called only by:
+ *   - hw/misc/ivshmem.c|584| <<process_msg_connect>> event_notifier_init_fd(&peer->eventfds[vector], fd);
+ */
 void event_notifier_init_fd(EventNotifier *e, int fd)
 {
     e->rfd = fd;
@@ -32,12 +36,40 @@ void event_notifier_init_fd(EventNotifier *e, int fd)
 }
 #endif
 
+/*
+ * 主要被以下调用:
+ *   - util/async.c|454| <<aio_context_new>> ret = event_notifier_init(&ctx->notifier, false);
+ *   - hw/virtio/virtio-pci.c|964| <<virtio_pci_set_guest_notifier>> int r = event_notifier_init(notifier, 0);
+ *   - hw/virtio/vhost.c|1156| <<vhost_virtqueue_init>> int r = event_notifier_init(&vq->masked_notifier, 0);
+ *   - hw/virtio/virtio-bus.c|416| <<virtio_bus_set_host_notifier>> r = event_notifier_init(notifier, 1);
+ *   - block/linux-aio.c|480| <<laio_init>> rc = event_notifier_init(&s->e, false);
+ *   - block/nvme.c|586| <<nvme_init>> ret = event_notifier_init(&s->irq_notifier, 0);
+ *   - hw/vfio/pci.c|147| <<vfio_intx_enable_kvm>> if (event_notifier_init(&vdev->intx.unmask, 0)) {
+ *   - hw/vfio/pci.c|304| <<vfio_intx_enable>> ret = event_notifier_init(&vdev->intx.interrupt, 0);
+ *   - hw/vfio/pci.c|458| <<vfio_add_kvm_msi_virq>> if (event_notifier_init(&vector->kvm_interrupt, 0)) {
+ *   - hw/vfio/pci.c|508| <<vfio_msix_vector_do_use>> if (event_notifier_init(&vector->interrupt, 0)) { 
+ *   - hw/vfio/pci.c|680| <<vfio_msi_enable>> if (event_notifier_init(&vector->interrupt, 0)) {
+ *   - hw/vfio/pci.c|2715| <<vfio_register_err_notifier>> if (event_notifier_init(&vdev->err_notifier, 0)) {
+ *   - hw/vfio/pci.c|2810| <<vfio_register_req_notifier>> if (event_notifier_init(&vdev->req_notifier, 0)) {
+ *   - hw/vfio/platform.c|70| <<vfio_init_intp>> ret = event_notifier_init(intp->interrupt, 0);
+ *   - hw/vfio/platform.c|81| <<vfio_init_intp>> ret = event_notifier_init(intp->unmask, 0);
+ *   - hw/virtio/virtio-mmio.c|374| <<virtio_mmio_set_guest_notifier>> int r = event_notifier_init(notifier, 0);
+ *   - contrib/ivshmem-server/ivshmem-server.c|177| <<ivshmem_server_handle_new_conn>> if (event_notifier_init(&peer->vectors[i], FALSE) < 0) {
+ *   - hw/misc/pci-testdev.c|280| <<pci_testdev_realize>> r = event_notifier_init(&test->notifier, 0);
+ *   - hw/s390x/virtio-ccw.c|1173| <<virtio_ccw_set_guest_notifier>> int r = event_notifier_init(notifier, 0);
+ *   - hw/usb/ccid-card-emulated.c|404| <<init_event_notifier>> if (event_notifier_init(&card->notifier, false) < 0) {
+ *   - hw/vfio/ccw.c|230| <<vfio_ccw_register_io_notifier>> if (event_notifier_init(&vcdev->io_notifier, 0)) {
+ *   - hw/vfio/pci-quirks.c|364| <<vfio_ioeventfd_init>> if (event_notifier_init(&ioeventfd->e, 0)) {
+ */
 int event_notifier_init(EventNotifier *e, int active)
 {
     int fds[2];
     int ret;
 
 #ifdef CONFIG_EVENTFD
+    /*
+     * 如果不加这个, read就会hang!
+     */
     ret = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
 #else
     ret = -1;
@@ -91,6 +123,17 @@ int event_notifier_get_fd(const EventNotifier *e)
     return e->rfd;
 }
 
+/*
+ * 大部分主要的例子:
+ *   - util/async.c|351| <<aio_notify>> event_notifier_set(&ctx->notifier);
+ *   - util/event_notifier-posix.c|69| <<event_notifier_init>> event_notifier_set(e);
+ *   - hw/block/dataplane/virtio-blk.c|311| <<virtio_blk_data_plane_start>> event_notifier_set(virtio_queue_get_host_notifier(vq));
+ *   - hw/virtio/virtio-pci.c|825| <<virtio_pci_vq_vector_unmask>> event_notifier_set(n);
+ *   - hw/virtio/virtio.c|2314| <<virtio_queue_notify>> event_notifier_set(&vq->host_notifier);
+ *   - hw/virtio/virtio.c|2447| <<virtio_notify_irqfd>> event_notifier_set(&vq->guest_notifier);
+ *   - hw/virtio/virtio.c|3650| <<virtio_device_start_ioeventfd_impl>> event_notifier_set(&vq->host_notifier);
+ *   - memory.c|2207| <<memory_region_dispatch_write_eventfds>> event_notifier_set(ioeventfd.e);
+ */
 int event_notifier_set(EventNotifier *e)
 {
     static const uint64_t value = 1;
@@ -107,6 +150,9 @@ int event_notifier_set(EventNotifier *e)
     return 0;
 }
 
+/*
+ * 读取的时候只确认长度, 只要长度大于0就行
+ */
 int event_notifier_test_and_clear(EventNotifier *e)
 {
     int value;
@@ -116,6 +162,9 @@ int event_notifier_test_and_clear(EventNotifier *e)
     /* Drain the notify pipe.  For eventfd, only 8 bytes will be read.  */
     value = 0;
     do {
+        /*
+	 * 这里的read是之前积累的总和!!!
+	 */
         len = read(e->rfd, buffer, sizeof(buffer));
         value |= (len > 0);
     } while ((len == -1 && errno == EINTR) || len == sizeof(buffer));
diff --git a/util/iohandler.c b/util/iohandler.c
index 623b55b..5e1a814 100644
--- a/util/iohandler.c
+++ b/util/iohandler.c
@@ -35,6 +35,15 @@
 
 /* This context runs on top of main loop. We can't reuse qemu_aio_context
  * because iohandlers mustn't be polled by aio_poll(qemu_aio_context). */
+/*
+ * used by:
+ *   - util/iohandler.c|42| <<iohandler_init>> if (!iohandler_ctx) {
+ *   - util/iohandler.c|43| <<iohandler_init>> iohandler_ctx = aio_context_new(&error_abort);
+ *   - util/iohandler.c|50| <<iohandler_get_aio_context>> return iohandler_ctx;
+ *   - util/iohandler.c|56| <<iohandler_get_g_source>> return aio_get_g_source(iohandler_ctx);
+ *   - util/iohandler.c|65| <<qemu_set_fd_handler>> aio_set_fd_handler(iohandler_ctx, fd, false,
+ *   - util/iohandler.c|73| <<event_notifier_set_handler>> aio_set_event_notifier(iohandler_ctx, e, false,
+ */
 static AioContext *iohandler_ctx;
 
 static void iohandler_init(void)
diff --git a/util/main-loop.c b/util/main-loop.c
index affe040..7074557 100644
--- a/util/main-loop.c
+++ b/util/main-loop.c
@@ -140,6 +140,10 @@ void qemu_notify_event(void)
 
 static GArray *gpollfds;
 
+/*
+ * called only by:
+ *   - vl.c|4062| <<main>> if (qemu_init_main_loop(&main_loop_err)) {
+ */
 int qemu_init_main_loop(Error **errp)
 {
     int ret;
diff --git a/util/module.c b/util/module.c
index c909737..4a9b8ec 100644
--- a/util/module.c
+++ b/util/module.c
@@ -32,34 +32,64 @@ typedef QTAILQ_HEAD(, ModuleEntry) ModuleTypeList;
 
 static ModuleTypeList init_type_list[MODULE_INIT_MAX];
 
+/*
+ * used by:
+ *   - util/module.c|58| <<init_lists>> QTAILQ_INIT(&dso_init_list);
+ *   - util/module.c|115| <<register_dso_module_init>> QTAILQ_INSERT_TAIL(&dso_init_list, e, node);
+ *   - util/module.c|163| <<module_load_file>> assert(QTAILQ_EMPTY(&dso_init_list));
+ *   - util/module.c|184| <<module_load_file>> QTAILQ_FOREACH(e, &dso_init_list, node) {
+ *   - util/module.c|191| <<module_load_file>> QTAILQ_FOREACH_SAFE(e, &dso_init_list, node, next) {
+ *   - util/module.c|192| <<module_load_file>> QTAILQ_REMOVE(&dso_init_list, e, node);
+ */
 static ModuleTypeList dso_init_list;
 
+/*
+ * called by:
+ *   - util/module.c|58| <<find_type>> init_lists();
+ *   - util/module.c|81| <<register_dso_module_init>> init_lists();
+ *
+ * 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化)
+ */
 static void init_lists(void)
 {
     static int inited;
     int i;
 
+    /* 静态变量只在这个函数修改 如果是1说明初始化过了 */
     if (inited) {
         return;
     }
 
     for (i = 0; i < MODULE_INIT_MAX; i++) {
-        QTAILQ_INIT(&init_type_list[i]);
+        QTAILQ_INIT(&init_type_list[i]);  // 在该函数上面声明的
     }
 
-    QTAILQ_INIT(&dso_init_list);
+    QTAILQ_INIT(&dso_init_list);  // 在该函数上面声明的
 
     inited = 1;
 }
 
 
+/*
+ * called by:
+ *   - register_module_init()
+ *   - module_call_init()
+ *
+ * 返回init_type_list[type] (type最多MODULE_INIT_MAX个)
+ */
 static ModuleTypeList *find_type(module_init_type type)
 {
+    /* 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化) */
     init_lists();
 
     return &init_type_list[type];
 }
 
+/*
+ * type最多MODULE_INIT_MAX个
+ *
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[type] (type最多MODULE_INIT_MAX个)
+ */
 void register_module_init(void (*fn)(void), module_init_type type)
 {
     ModuleEntry *e;
@@ -69,15 +99,22 @@ void register_module_init(void (*fn)(void), module_init_type type)
     e->init = fn;
     e->type = type;
 
+    /* 返回init_type_list[type] (type最多MODULE_INIT_MAX个) */
     l = find_type(type);
 
     QTAILQ_INSERT_TAIL(l, e, node);
 }
 
+/*
+ * type最多MODULE_INIT_MAX个
+ *
+ * 根据fn初始化一个ModuleEntry插入到dso_init_list
+ */
 void register_dso_module_init(void (*fn)(void), module_init_type type)
 {
     ModuleEntry *e;
 
+    /* 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化) */
     init_lists();
 
     e = g_malloc0(sizeof(*e));
@@ -87,6 +124,15 @@ void register_dso_module_init(void (*fn)(void), module_init_type type)
     QTAILQ_INSERT_TAIL(&dso_init_list, e, node);
 }
 
+/*
+ * 主要的调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * 遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
 void module_call_init(module_init_type type)
 {
     ModuleTypeList *l;
@@ -100,6 +146,9 @@ void module_call_init(module_init_type type)
 }
 
 #ifdef CONFIG_MODULES
+/*
+ * called only by module_load_one()
+ */
 static int module_load_file(const char *fname)
 {
     GModule *g_module;
@@ -157,6 +206,12 @@ out:
 }
 #endif
 
+/*
+ * called by:
+ *   - include/qemu/module.h|55| <<block_module_load_one>> #define block_module_load_one(lib) module_load_one("block-", lib)
+ *   - include/qemu/module.h|56| <<ui_module_load_one>> #define ui_module_load_one(lib) module_load_one("ui-", lib)
+ *   - include/qemu/module.h|57| <<audio_module_load_one>> #define audio_module_load_one(lib) module_load_one("audio-", lib)
+ */
 void module_load_one(const char *prefix, const char *lib_name)
 {
 #ifdef CONFIG_MODULES
diff --git a/util/qemu-config.c b/util/qemu-config.c
index 9d2e278..68da2f3 100644
--- a/util/qemu-config.c
+++ b/util/qemu-config.c
@@ -9,9 +9,24 @@
 #include "qemu/option.h"
 #include "qemu/config-file.h"
 
+/*
+ * 应该是只通过qemu_add_opts()添加新元素
+ */
 static QemuOptsList *vm_config_groups[48];
+/*
+ * 应该只通过qemu_add_drive_opts()添加新元素
+ */
 static QemuOptsList *drive_config_groups[5];
 
+/*
+ * called by:
+ *   - util/qemu-config.c|41| <<qemu_find_opts>> ret = find_list(vm_config_groups, group, &local_err);
+ *   - util/qemu-config.c|288| <<qemu_find_opts_err>> return find_list(vm_config_groups, group, errp);
+ *   - util/qemu-config.c|484| <<qemu_config_parse>> list = find_list(lists, group, &local_err);
+ *   - util/qemu-config.c|495| <<qemu_config_parse>> list = find_list(lists, group, &local_err);
+ *
+ * 从参数给的QemuOptsList列表中寻找lists[i]的name是参数group的, 并返回list[i]
+ */
 static QemuOptsList *find_list(QemuOptsList **lists, const char *group,
                                Error **errp)
 {
@@ -27,11 +42,17 @@ static QemuOptsList *find_list(QemuOptsList **lists, const char *group,
     return lists[i];
 }
 
+/*
+ * 从vm_config_groups(QemuOptsList)列表中寻找name是参数group的, 并返回(QemuOptsList)
+ */
 QemuOptsList *qemu_find_opts(const char *group)
 {
     QemuOptsList *ret;
     Error *local_err = NULL;
 
+    /*
+     * 从vm_config_groups(QemuOptsList)列表中寻找name是参数group的, 并返回在ret(QemuOptsList)
+     */
     ret = find_list(vm_config_groups, group, &local_err);
     if (local_err) {
         error_report_err(local_err);
@@ -282,6 +303,13 @@ QemuOptsList *qemu_find_opts_err(const char *group, Error **errp)
     return find_list(vm_config_groups, group, errp);
 }
 
+/*
+ * called by:
+ *   - vl.c|3014| <<main>> qemu_add_drive_opts(&qemu_legacy_drive_opts);
+ *   - vl.c|3015| <<main>> qemu_add_drive_opts(&qemu_common_drive_opts);
+ *   - vl.c|3016| <<main>> qemu_add_drive_opts(&qemu_drive_opts);
+ *   - vl.c|3017| <<main>> qemu_add_drive_opts(&bdrv_runtime_opts);
+ */
 void qemu_add_drive_opts(QemuOptsList *list)
 {
     int entries, i;
@@ -298,6 +326,48 @@ void qemu_add_drive_opts(QemuOptsList *list)
     abort();
 }
 
+/*
+ * 被很多调用, 比如:
+ *   - vl.c|3005| <<main>> qemu_add_opts(&qemu_device_opts);
+ *
+ * 正常的调用:
+ *   - vl.c|3013| <<main>> qemu_add_opts(&qemu_drive_opts);
+ *   - vl.c|3018| <<main>> qemu_add_opts(&qemu_chardev_opts);
+ *   - vl.c|3019| <<main>> qemu_add_opts(&qemu_device_opts);
+ *   - vl.c|3020| <<main>> qemu_add_opts(&qemu_netdev_opts);
+ *   - vl.c|3021| <<main>> qemu_add_opts(&qemu_nic_opts);
+ *   - vl.c|3022| <<main>> qemu_add_opts(&qemu_net_opts);
+ *   - vl.c|3023| <<main>> qemu_add_opts(&qemu_rtc_opts);
+ *   - vl.c|3024| <<main>> qemu_add_opts(&qemu_global_opts);
+ *   - vl.c|3025| <<main>> qemu_add_opts(&qemu_mon_opts);
+ *   - vl.c|3026| <<main>> qemu_add_opts(&qemu_trace_opts);
+ *   - vl.c|3027| <<main>> qemu_add_opts(&qemu_option_rom_opts);
+ *   - vl.c|3028| <<main>> qemu_add_opts(&qemu_machine_opts);
+ *   - vl.c|3029| <<main>> qemu_add_opts(&qemu_accel_opts);
+ *   - vl.c|3030| <<main>> qemu_add_opts(&qemu_mem_opts);
+ *   - vl.c|3031| <<main>> qemu_add_opts(&qemu_smp_opts);
+ *   - vl.c|3032| <<main>> qemu_add_opts(&qemu_boot_opts);
+ *   - vl.c|3033| <<main>> qemu_add_opts(&qemu_add_fd_opts);
+ *   - vl.c|3034| <<main>> qemu_add_opts(&qemu_object_opts);
+ *   - vl.c|3035| <<main>> qemu_add_opts(&qemu_tpmdev_opts);
+ *   - vl.c|3036| <<main>> qemu_add_opts(&qemu_realtime_opts);
+ *   - vl.c|3037| <<main>> qemu_add_opts(&qemu_msg_opts);
+ *   - vl.c|3038| <<main>> qemu_add_opts(&qemu_name_opts);
+ *   - vl.c|3039| <<main>> qemu_add_opts(&qemu_numa_opts);
+ *   - vl.c|3040| <<main>> qemu_add_opts(&qemu_icount_opts);
+ *   - vl.c|3041| <<main>> qemu_add_opts(&qemu_semihosting_config_opts);
+ *   - vl.c|3042| <<main>> qemu_add_opts(&qemu_fw_cfg_opts);
+ *
+ * 不确定的:
+ *   - block/iscsi-opts.c|67| <<iscsi_block_opts_init>> qemu_add_opts(&qemu_iscsi_opts);
+ *   - fsdev/qemu-fsdev-opts.c|98| <<fsdev_register_config>> qemu_add_opts(&qemu_fsdev_opts);
+ *   - fsdev/qemu-fsdev-opts.c|99| <<fsdev_register_config>> qemu_add_opts(&qemu_virtfs_opts);
+ *   - hw/acpi/core.c|70| <<acpi_register_config>> qemu_add_opts(&qemu_acpi_opts);
+ *   - hw/smbios/smbios.c|339| <<smbios_register_config>> qemu_add_opts(&qemu_smbios_opts);
+ *   - qemu-seccomp.c|251| <<seccomp_register>> qemu_add_opts(&qemu_sandbox_opts);
+ *   - ui/spice-core.c|951| <<spice_register_config>> qemu_add_opts(&qemu_spice_opts);
+ *   - ui/vnc.c|4183| <<vnc_register_config>> qemu_add_opts(&qemu_vnc_opts);
+ */
 void qemu_add_opts(QemuOptsList *list)
 {
     int entries, i;
@@ -305,6 +375,9 @@ void qemu_add_opts(QemuOptsList *list)
     entries = ARRAY_SIZE(vm_config_groups);
     entries--; /* keep list NULL terminated */
     for (i = 0; i < entries; i++) {
+        /*
+	 * 从头开始找到一个非空的设置QemuOptsList
+	 */
         if (vm_config_groups[i] == NULL) {
             vm_config_groups[i] = list;
             return;
@@ -314,6 +387,10 @@ void qemu_add_opts(QemuOptsList *list)
     abort();
 }
 
+/*
+ * called only by:
+ *   - vl.c|3130| <<main>> if (qemu_set_option(optarg) != 0)
+ */
 int qemu_set_option(const char *str)
 {
     Error *local_err = NULL;
@@ -391,6 +468,11 @@ void qemu_config_write(FILE *fp)
 }
 
 /* Returns number of config groups on success, -errno on error */
+/*
+ * called by:
+ *    - block/blkdebug.c|244| <<read_config>> ret = qemu_config_parse(f, config_groups, filename);
+ *    - util/qemu-config.c|481| <<qemu_read_config_file>> ret = qemu_config_parse(f, vm_config_groups, filename);
+ */
 int qemu_config_parse(FILE *fp, QemuOptsList **lists, const char *fname)
 {
     char line[1024], group[64], id[64], arg[64], value[1024];
@@ -462,6 +544,11 @@ out:
     return res;
 }
 
+/*
+ * called by:
+ *   - vl.c|2916| <<qemu_read_default_config_file>> ret = qemu_read_config_file(CONFIG_QEMU_CONFDIR "/qemu.conf");
+ *   - vl.c|3876| <<main>> int ret = qemu_read_config_file(optarg); --->  QEMU_OPTION_readconfig
+ */
 int qemu_read_config_file(const char *filename)
 {
     FILE *f = fopen(filename, "r");
@@ -476,6 +563,10 @@ int qemu_read_config_file(const char *filename)
     return ret;
 }
 
+/*
+ * called only by read_config()-->qemu_config_parse_qdict()
+ *   - util/qemu-config.c|598| <<qemu_config_parse_qdict>> config_parse_qdict_section(options, lists[i], &local_err);
+ */
 static void config_parse_qdict_section(QDict *options, QemuOptsList *opts,
                                        Error **errp)
 {
@@ -567,6 +658,10 @@ out:
     qobject_unref(list);
 }
 
+/*
+ * called only by:
+ *   - block/blkdebug.c|251| <<read_config>> qemu_config_parse_qdict(options, config_groups, &local_err);
+ */
 void qemu_config_parse_qdict(QDict *options, QemuOptsList **lists,
                              Error **errp)
 {
diff --git a/util/qemu-option.c b/util/qemu-option.c
index 01886ef..451ddd3 100644
--- a/util/qemu-option.c
+++ b/util/qemu-option.c
@@ -570,6 +570,15 @@ void qemu_opt_set_number(QemuOpts *opts, const char *name, int64_t val,
  * When @func() returns non-zero, break the loop and return that value.
  * Return zero when the loop completes.
  */
+/*
+ * called by:
+ *   - qdev-monitor.c|642| <<qdev_device_add>> if (qemu_opt_foreach(opts, set_property, dev, &err)) {
+ *   - hw/smbios/smbios.c|948| <<save_opt_list>> qemu_opt_foreach(opts, save_opt_one, &opt, NULL);
+ *   - ui/spice-core.c|792| <<qemu_spice_init>> qemu_opt_foreach(opts, add_channel, &tls_port, NULL);
+ *   - util/qemu-config.c|452| <<config_write_opts>> qemu_opt_foreach(opts, config_write_opt, data, NULL);
+ *   - vl.c|3793| <<main>> qemu_opt_foreach(opts, add_semihosting_arg,
+ *   - vl.c|4371| <<main>> if (qemu_opt_foreach(machine_opts, machine_set_property, current_machine,
+ */
 int qemu_opt_foreach(QemuOpts *opts, qemu_opt_loopfunc func, void *opaque,
                      Error **errp)
 {
@@ -601,6 +610,9 @@ QemuOpts *qemu_opts_find(QemuOptsList *list, const char *id)
     return NULL;
 }
 
+/*
+ * 核心思想是分配简单初始化一个QemuOpts, 插入QemuOptsList的head
+ */
 QemuOpts *qemu_opts_create(QemuOptsList *list, const char *id,
                            int fail_if_exists, Error **errp)
 {
@@ -749,6 +761,11 @@ void qemu_opts_print(QemuOpts *opts, const char *separator)
     }
 }
 
+/*
+ * called by:
+ *   - util/qemu-option.c|817| <<qemu_opts_do_parse>> opts_do_parse(opts, params, firstname, false, errp);
+ *   - util/qemu-option.c|861| <<opts_parse>> opts_do_parse(opts, params, firstname, defaults, &local_err);
+ */
 static void opts_do_parse(QemuOpts *opts, const char *params,
                           const char *firstname, bool prepend, Error **errp)
 {
@@ -817,6 +834,14 @@ void qemu_opts_do_parse(QemuOpts *opts, const char *params,
     opts_do_parse(opts, params, firstname, false, errp);
 }
 
+/*
+ * called by:
+ *   - util/qemu-option.c|876| <<qemu_opts_parse>> return opts_parse(list, params, permit_abbrev, false, errp);
+ *   - util/qemu-option.c|896| <<qemu_opts_parse_noisily>> opts = opts_parse(list, params, permit_abbrev, false, &err);
+ *   - util/qemu-option.c|908| <<qemu_opts_set_defaults>> opts = opts_parse(list, params, permit_abbrev, true, NULL);
+ *
+ * 从qemu_opts_parse_noisily()调用过来的一个例子: list=qemu_mem_opts, params="3000M", permit_abbrev=true, defaults=false
+ */
 static QemuOpts *opts_parse(QemuOptsList *list, const char *params,
                             bool permit_abbrev, bool defaults, Error **errp)
 {
@@ -843,6 +868,9 @@ static QemuOpts *opts_parse(QemuOptsList *list, const char *params,
      * (if unlikely) future misuse:
      */
     assert(!defaults || list->merge_lists);
+    /*
+     * 核心思想是分配简单初始化一个QemuOpts, 插入QemuOptsList的head
+     */
     opts = qemu_opts_create(list, id, !defaults, &local_err);
     g_free(id);
     if (opts == NULL) {
@@ -881,6 +909,9 @@ QemuOpts *qemu_opts_parse(QemuOptsList *list, const char *params,
  * QMP context.  Do not use this function there!
  * Return the new QemuOpts on success, null pointer on error.
  */
+/*
+ * 调用的一个例子是: list=qemu_mem_opts, params="3000M", permit_abbrev=true
+ */
 QemuOpts *qemu_opts_parse_noisily(QemuOptsList *list, const char *params,
                                   bool permit_abbrev)
 {
diff --git a/util/qemu-thread-posix.c b/util/qemu-thread-posix.c
index dfa66ff..409e22d 100644
--- a/util/qemu-thread-posix.c
+++ b/util/qemu-thread-posix.c
@@ -504,6 +504,20 @@ static void *qemu_thread_start(void *args)
     return start_routine(arg);
 }
 
+/*
+ * called by:
+ *   - cpus.c|1935| <<qemu_kvm_start_vcpu>> qemu_thread_create(cpu->thread, thread_name, qemu_kvm_cpu_thread_fn,
+ *   - iothread.c|178| <<iothread_complete>> qemu_thread_create(&iothread->thread, thread_name, iothread_run,
+ *   - dump.c|2024| <<qmp_dump_guest_memory>> qemu_thread_create(&s->dump_thread, "dump_thread", dump_thread,
+ *   - migration/migration.c|426| <<process_incoming_migration_co>> qemu_thread_create(&mis->colo_incoming_thread, "COLO incoming",
+ *   - migration/migration.c|2297| <<open_return_path_on_source>> qemu_thread_create(&ms->rp_state.rp_thread, "return path",
+ *   - migration/migration.c|3123| <<migrate_fd_connect>> qemu_thread_create(&s->thread, "live_migration", migration_thread, s,
+ *   - migration/postcopy-ram.c|1095| <<postcopy_ram_enable_notify>> qemu_thread_create(&mis->fault_thread, "postcopy/fault",
+ *   - ui/vnc-jobs.c|341| <<vnc_start_worker_thread>> qemu_thread_create(&q->thread, "vnc_worker", vnc_worker_thread, q,
+ *   - util/oslib-posix.c|378| <<touch_all_pages>> qemu_thread_create(&memset_thread[i].pgthread, "touch_pages",
+ *   - util/rcu.c|327| <<rcu_init_complete>> qemu_thread_create(&thread, "call_rcu", call_rcu_thread,
+ *   - util/thread-pool.c|138| <<do_spawn_thread>> qemu_thread_create(&t, "worker", worker_thread, pool, QEMU_THREAD_DETACHED);
+ */
 void qemu_thread_create(QemuThread *thread, const char *name,
                        void *(*start_routine)(void*),
                        void *arg, int mode)
diff --git a/util/thread-pool.c b/util/thread-pool.c
index 610646d..62f6e3d 100644
--- a/util/thread-pool.c
+++ b/util/thread-pool.c
@@ -132,6 +132,9 @@ static void do_spawn_thread(ThreadPool *pool)
     pool->new_threads--;
     pool->pending_threads++;
 
+    /*
+     * 最终创建worker线程的地方
+     */
     qemu_thread_create(&t, "worker", worker_thread, pool, QEMU_THREAD_DETACHED);
 }
 
diff --git a/util/vfio-helpers.c b/util/vfio-helpers.c
index 1d9272e..170423a 100644
--- a/util/vfio-helpers.c
+++ b/util/vfio-helpers.c
@@ -127,6 +127,10 @@ static inline void assert_bar_index_valid(QEMUVFIOState *s, int index)
     assert(index >= 0 && index < ARRAY_SIZE(s->bar_region_info));
 }
 
+/*
+ * called only by:
+ *   - util/vfio-helpers.c|352| <<qemu_vfio_init_pci>> ret = qemu_vfio_pci_init_bar(s, i, errp);
+ */
 static int qemu_vfio_pci_init_bar(QEMUVFIOState *s, int index, Error **errp)
 {
     assert_bar_index_valid(s, index);
@@ -145,6 +149,10 @@ static int qemu_vfio_pci_init_bar(QEMUVFIOState *s, int index, Error **errp)
 /**
  * Map a PCI bar area.
  */
+/*
+ * called by:
+ *   - block/nvme.c|575| <<nvme_init>> s->regs = qemu_vfio_pci_map_bar(s->vfio, 0, 0, NVME_BAR_SIZE, errp);
+ */
 void *qemu_vfio_pci_map_bar(QEMUVFIOState *s, int index,
                             uint64_t offset, uint64_t size,
                             Error **errp)
@@ -175,6 +183,10 @@ void qemu_vfio_pci_unmap_bar(QEMUVFIOState *s, int index, void *bar,
 /**
  * Initialize device IRQ with @irq_type and and register an event notifier.
  */
+/*
+ * called only by:
+ *   - block/nvme.c|640| <<nvme_init>> ret = qemu_vfio_pci_init_irq(s->vfio, &s->irq_notifier,
+ */
 int qemu_vfio_pci_init_irq(QEMUVFIOState *s, EventNotifier *e,
                            int irq_type, Error **errp)
 {
@@ -236,6 +248,10 @@ static int qemu_vfio_pci_write_config(QEMUVFIOState *s, void *buf, int size, int
     return ret == size ? 0 : -errno;
 }
 
+/*
+ * called only by:
+ *   - util/vfio-helpers.c|431| <<qemu_vfio_open_pci>> r = qemu_vfio_init_pci(s, device, errp);
+ */
 static int qemu_vfio_init_pci(QEMUVFIOState *s, const char *device,
                               Error **errp)
 {
@@ -437,6 +453,9 @@ QEMUVFIOState *qemu_vfio_open_pci(const char *device, Error **errp)
     return s;
 }
 
+/*
+ * 只被qemu_vfio_dump_mappings()调用
+ */
 static void qemu_vfio_dump_mapping(IOVAMapping *m)
 {
     if (QEMU_VFIO_DEBUG) {
@@ -445,6 +464,12 @@ static void qemu_vfio_dump_mapping(IOVAMapping *m)
     }
 }
 
+/*
+ * called by:
+ *   - util/vfio-helpers.c|590| <<qemu_vfio_verify_mappings>> qemu_vfio_dump_mappings(s);
+ *   - util/vfio-helpers.c|596| <<qemu_vfio_verify_mappings>> qemu_vfio_dump_mappings(s);
+ *   - util/vfio-helpers.c|643| <<qemu_vfio_dma_map>> qemu_vfio_dump_mappings(s);
+ */
 static void qemu_vfio_dump_mappings(QEMUVFIOState *s)
 {
     int i;
@@ -463,6 +488,11 @@ static void qemu_vfio_dump_mappings(QEMUVFIOState *s)
  * to insert the new mapping. IOW, it is the index of the largest element that
  * is smaller than @host, or -1 if no entry is.
  */
+/*
+ * called by:
+ *   - util/vfio-helpers.c|621| <<qemu_vfio_dma_map>> mapping = qemu_vfio_find_mapping(s, host, &index);
+ *   - util/vfio-helpers.c|695| <<qemu_vfio_dma_unmap>> m = qemu_vfio_find_mapping(s, host, &index);
+ */
 static IOVAMapping *qemu_vfio_find_mapping(QEMUVFIOState *s, void *host,
                                            int *index)
 {
@@ -507,6 +537,10 @@ static IOVAMapping *qemu_vfio_find_mapping(QEMUVFIOState *s, void *host,
 /**
  * Allocate IOVA and and create a new mapping record and insert it in @s.
  */
+/*
+ * called only by:
+ *   - util/vfio-helpers.c|631| <<qemu_vfio_dma_map>> mapping = qemu_vfio_add_mapping(s, host, size, index + 1, iova0);
+ */
 static IOVAMapping *qemu_vfio_add_mapping(QEMUVFIOState *s,
                                           void *host, size_t size,
                                           int index, uint64_t iova)
@@ -606,6 +640,16 @@ static bool qemu_vfio_verify_mappings(QEMUVFIOState *s)
  * aligned to page size, and mustn't overlap with existing mapping areas (split
  * mapping status within this area is not allowed).
  */
+/*
+ * called by:
+ *   - block/nvme.c|152| <<nvme_init_queue>> r = qemu_vfio_dma_map(s->vfio, q->queue, bytes, false, &q->iova);
+ *   - block/nvme.c|192| <<nvme_create_queue_pair>> r = qemu_vfio_dma_map(s->vfio, q->prp_list_pages,
+ *   - block/nvme.c|431| <<nvme_identify>> r = qemu_vfio_dma_map(s->vfio, resp, sizeof(NvmeIdCtrl), true, &iova);
+ *   - block/nvme.c|832| <<nvme_cmd_map_qiov>> r = qemu_vfio_dma_map(s->vfio,
+ *   - block/nvme.c|1141| <<nvme_register_buf>> ret = qemu_vfio_dma_map(s->vfio, host, size, false, NULL);
+ *   - util/vfio-helpers.c|381| <<qemu_vfio_ram_block_added>> qemu_vfio_dma_map(s, host, size, false, NULL);
+ *   - util/vfio-helpers.c|404| <<qemu_vfio_init_ramblock>> ret = qemu_vfio_dma_map(s, host_addr, length, false, NULL);
+ */
 int qemu_vfio_dma_map(QEMUVFIOState *s, void *host, size_t size,
                       bool temporary, uint64_t *iova)
 {
@@ -681,6 +725,12 @@ int qemu_vfio_dma_reset_temporary(QEMUVFIOState *s)
 
 /* Unmapping the whole area that was previously mapped with
  * qemu_vfio_dma_map(). */
+/*
+ * called by:
+ *   - block/nvme.c|466| <<nvme_identify>> qemu_vfio_dma_unmap(s->vfio, resp);
+ *   - block/nvme.c|1154| <<nvme_unregister_buf>> qemu_vfio_dma_unmap(s->vfio, host);
+ *   - util/vfio-helpers.c|390| <<qemu_vfio_ram_block_removed>> qemu_vfio_dma_unmap(s, host);
+ */
 void qemu_vfio_dma_unmap(QEMUVFIOState *s, void *host)
 {
     int index = 0;
@@ -701,12 +751,20 @@ out:
     qemu_mutex_unlock(&s->lock);
 }
 
+/*
+ * called only by qemu_vfio_close()
+ */
 static void qemu_vfio_reset(QEMUVFIOState *s)
 {
     ioctl(s->device, VFIO_DEVICE_RESET);
 }
 
 /* Close and free the VFIO resources. */
+/*
+ * called by:
+ *   - block/nvme.c|673| <<nvme_init>> qemu_vfio_close(s->vfio);
+ *   - block/nvme.c|745| <<nvme_close>> qemu_vfio_close(s->vfio);
+ */
 void qemu_vfio_close(QEMUVFIOState *s)
 {
     int i;
diff --git a/vl.c b/vl.c
index 16b913f..9f96c2f 100644
--- a/vl.c
+++ b/vl.c
@@ -1136,6 +1136,13 @@ static int cleanup_add_fd(void *opaque, QemuOpts *opts, Error **errp)
 #define MTD_OPTS ""
 #define SD_OPTS ""
 
+/*
+ * 被以下调用使用vl.c main():
+ * 4534     if (qemu_opts_foreach(qemu_find_opts("drive"), drive_init_func,
+ * 4535                           &machine_class->block_default_type, NULL)) {
+ * 4536         exit(1);
+ * 4537     }
+ */
 static int drive_init_func(void *opaque, QemuOpts *opts, Error **errp)
 {
     BlockInterfaceType *block_default_type = opaque;
@@ -1389,6 +1396,10 @@ static int usb_parse(const char *cmdline)
 
 MachineState *current_machine;
 
+/*
+ * called only by:
+ *   - vl.c|2564| <<machine_parse>> mc = find_machine(name);
+ */
 static MachineClass *find_machine(const char *name)
 {
     GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);
@@ -1412,6 +1423,10 @@ static MachineClass *find_machine(const char *name)
     return mc;
 }
 
+/*
+ * called only by:
+ *   - vl.c|2677| <<select_machine>> MachineClass *machine_class = find_default_machine();
+ */
 MachineClass *find_default_machine(void)
 {
     GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);
@@ -1907,6 +1922,12 @@ typedef struct QEMUOption {
     uint32_t arch_mask;
 } QEMUOption;
 
+/*
+ * used only by:
+ *   - vl.c|2670| <<lookup_opt>> popt = qemu_options;
+ *
+ * 全局数组 (从"qemu-options-wrapper.h"插入的)
+ */
 static const QEMUOption qemu_options[] = {
     { "h", 0, QEMU_OPTION_h, QEMU_ARCH_ALL },
 #define QEMU_OPTIONS_GENERATE_OPTIONS
@@ -2267,8 +2288,27 @@ static int device_help_func(void *opaque, QemuOpts *opts, Error **errp)
     return qdev_device_help(opts);
 }
 
+/*
+ * 被main()函数调用:
+ * 4557     if (qemu_opts_foreach(qemu_find_opts("device"),
+ * 4558                           device_init_func, NULL, NULL)) {
+ *
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 static int device_init_func(void *opaque, QemuOpts *opts, Error **errp)
 {
+    /* opaque是NULL */
     Error *err = NULL;
     DeviceState *dev;
 
@@ -2555,6 +2595,10 @@ static gint machine_class_cmp(gconstpointer a, gconstpointer b)
                   object_class_get_name(OBJECT_CLASS(mc1)));
 }
 
+/*
+ * called by:
+ *   - vl.c|2685| <<select_machine>> machine_class = machine_parse(optarg);
+ */
  static MachineClass *machine_parse(const char *name)
 {
     MachineClass *mc = NULL;
@@ -2624,15 +2668,22 @@ static void qemu_run_machine_init_done_notifiers(void)
     notifier_list_notify(&machine_init_done_notifiers, NULL);
 }
 
+/*
+ * 两次被main()调用
+ */
 static const QEMUOption *lookup_opt(int argc, char **argv,
                                     const char **poptarg, int *poptind)
 {
+    /*
+     * 此时argv[optind][0]是"-"
+     */
     const QEMUOption *popt;
     int optind = *poptind;
     char *r = argv[optind];
     const char *optarg;
 
     loc_set_cmdline(argv, optind, 1);
+    /* 如果没参数, 加完了就指向下一个了 */
     optind++;
     /* Treat --foo the same as -foo.  */
     if (r[1] == '-')
@@ -2643,6 +2694,7 @@ static const QEMUOption *lookup_opt(int argc, char **argv,
             error_report("invalid option");
             exit(1);
         }
+	/* 比较'-'后面的部分是否和参数的名字相同 */
         if (!strcmp(popt->name, r + 1))
             break;
         popt++;
@@ -2664,6 +2716,9 @@ static const QEMUOption *lookup_opt(int argc, char **argv,
     return popt;
 }
 
+/*
+ * 被vl.c的main()调用
+ */
 static MachineClass *select_machine(void)
 {
     MachineClass *machine_class = find_default_machine();
@@ -2788,6 +2843,7 @@ static void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size,
 {
     uint64_t sz;
     const char *mem_str;
+    /* hw/core/machine.c|547| <<machine_class_init>> mc->default_ram_size = 128 * MiB; */
     const ram_addr_t default_ram_size = mc->default_ram_size;
     QemuOpts *opts = qemu_find_opts_singleton("memory");
     Location loc;
@@ -3021,12 +3077,13 @@ int main(int argc, char **argv, char **envp)
     optind = 1;
     while (optind < argc) {
         if (argv[optind][0] != '-') {
+            /* 如果开头不是'-'直接跳过 */
             /* disk image */
             optind++;
         } else {
             const QEMUOption *popt;
 
-            popt = lookup_opt(argc, argv, &optarg, &optind);
+            popt = lookup_opt(argc, argv, &optarg, &optind);      // ----> 第一轮
             switch (popt->index) {
             case QEMU_OPTION_nodefconfig:
             case QEMU_OPTION_nouserconfig:
@@ -3043,16 +3100,26 @@ int main(int argc, char **argv, char **envp)
     }
 
     /* second pass of option parsing */
+    /*
+     * 这一遍才是正式的!!!
+     */
     optind = 1;
     for(;;) {
         if (optind >= argc)
             break;
         if (argv[optind][0] != '-') {
+            /* 如果开头不是'-' */
             drive_add(IF_DEFAULT, 0, argv[optind++], HD_OPTS);
         } else {
             const QEMUOption *popt;
 
-            popt = lookup_opt(argc, argv, &optarg, &optind);
+	    /*
+	     * popt是返回的QEMUOption, 里面有index表明这代表的'-'后面的意义
+	     * optarg是返回的字符串参数内容
+	     *
+	     * 此时optind指向下一个
+	     */
+            popt = lookup_opt(argc, argv, &optarg, &optind);      // ----> 第二轮
             if (!(popt->arch_mask & arch_type)) {
                 error_report("Option not supported for this target");
                 exit(1);
@@ -3245,6 +3312,9 @@ int main(int argc, char **argv, char **envp)
                 exit(0);
                 break;
             case QEMU_OPTION_m:
+		/*
+		 * qemu_find_opts(): 从vm_config_groups(QemuOptsList)列表中寻找name是参数"memory"的, 并返回qemu_mem_opts
+		 */
                 opts = qemu_opts_parse_noisily(qemu_find_opts("memory"),
                                                optarg, true);
                 if (!opts) {
@@ -4026,11 +4096,29 @@ int main(int argc, char **argv, char **envp)
     }
 #endif
 
+    /*
+     * object_class_get_name()返回的一个例子是: pc-i440fx-3.0-machine
+     */
     current_machine = MACHINE(object_new(object_class_get_name(
                           OBJECT_CLASS(machine_class))));
     if (machine_help_func(qemu_get_machine_opts(), current_machine)) {
         exit(0);
     }
+    /*
+     * 把child设置成一个obj的ObjectProperty
+     * 在Object->properties (GHashTable)的name就是参数的name, type是"child<child的type>"
+     * ObjectProperty的opaque是child
+     * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+     *
+     *
+     * 应该是在这里初始化的"/machine"
+     * 在这个例子中, machine是name, child<pc-i440fx-3.0-machine>是type
+     *    (qemu) qom-list /
+     *    machine (child<pc-i440fx-3.0-machine>)
+     *    type (string)
+     *    chardevs (child<container>)
+     *    backend (child<container>)
+     */
     object_property_add_child(object_get_root(), "machine",
                               OBJECT(current_machine), &error_abort);
 
-- 
2.7.4

