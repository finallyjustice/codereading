From 9b5123c46b437f0aad9b38c7100055c16ec2a019 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang@oracle.com>
Date: Thu, 25 Oct 2018 05:55:31 +0800
Subject: [PATCH 1/1] qemu for 3.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-all.c          |   55 +-
 bootdevice.c                 |   27 +
 data/drive_config_groups.txt |    6 +
 data/info_mtree.txt          |  420 +++++++++++++
 data/qemu_options.txt        |  722 +++++++++++++++++++++
 data/qom-tree.txt            |  262 ++++++++
 data/vm_config_groups.txt    |   33 +
 exec.c                       |  414 +++++++++++-
 hmp.c                        |    7 +
 hw/block/nvme.c              |  108 ++++
 hw/core/bus.c                |   62 ++
 hw/core/machine.c            |  136 +++-
 hw/core/qdev-fw.c            |   13 +
 hw/core/qdev-properties.c    |    6 +
 hw/core/qdev.c               |  186 ++++++
 hw/core/reset.c              |   41 ++
 hw/i386/kvm/apic.c           |   26 +
 hw/i386/pc.c                 |   91 +++
 hw/i386/pc_piix.c            |   55 +-
 hw/i386/pc_q35.c             |   24 +
 hw/i386/x86-iommu.c          |    6 +
 hw/net/e1000.c               |   37 ++
 hw/nvram/fw_cfg.c            |   13 +
 hw/pci-host/piix.c           |  124 ++++
 hw/pci/msi.c                 |    6 +
 hw/pci/msix.c                |   29 +
 hw/pci/pci.c                 |  376 +++++++++++
 hw/pci/pci_host.c            |   11 +
 hw/virtio/virtio-balloon.c   |    6 +
 include/exec/cpu-all.h       |    2 +
 include/exec/memory.h        |  153 +++++
 include/exec/ram_addr.h      |   11 +
 include/hw/boards.h          |   16 +
 include/hw/i386/pc.h         |   77 ++-
 include/hw/pci/pci.h         |    8 +
 include/hw/pci/pci_bus.h     |    1 +
 include/hw/pci/pci_host.h    |    1 +
 include/hw/qdev-core.h       |   10 +
 include/hw/qdev-properties.h |   15 +
 include/hw/sysbus.h          |    1 +
 include/qapi/qmp/qobject.h   |    3 +
 include/qemu/module.h        |   14 +
 include/qom/object.h         |   48 +-
 include/sysemu/accel.h       |    1 +
 include/sysemu/iothread.h    |    1 +
 include/sysemu/kvm_int.h     |    1 +
 linux-headers/linux/kvm.h    |    4 +
 memory.c                     | 1040 +++++++++++++++++++++++++++++-
 numa.c                       |    4 +
 qapi/qobject-input-visitor.c |   10 +
 qdev-monitor.c               |   20 +
 qom/container.c              |   84 +++
 qom/object.c                 | 1426 +++++++++++++++++++++++++++++++++++++++++-
 qom/object_interfaces.c      |    3 +
 qom/qom-qobject.c            |   47 ++
 target/i386/cpu.c            |   16 +
 target/i386/kvm.c            |    4 +
 ui/console.c                 |    6 +
 util/module.c                |   59 +-
 util/qemu-config.c           |   95 +++
 util/qemu-option.c           |   22 +
 vl.c                         |   84 ++-
 62 files changed, 6572 insertions(+), 17 deletions(-)
 create mode 100644 data/drive_config_groups.txt
 create mode 100644 data/info_mtree.txt
 create mode 100644 data/qemu_options.txt
 create mode 100644 data/qom-tree.txt
 create mode 100644 data/vm_config_groups.txt

diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index eb7db92..b0d2d81 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -271,9 +271,15 @@ static int kvm_set_user_memory_region(KVMMemoryListener *kml, KVMSlot *slot, boo
         /* Set the slot size to 0 before setting the slot to the desired
          * value. This is needed based on KVM commit 75d61fbc. */
         mem.memory_size = 0;
+	/*
+	 * 设置GPA到HVA的映射
+	 */
         kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);
     }
     mem.memory_size = slot->memory_size;
+    /*
+     * 设置GPA到HVA的映射
+     */
     ret = kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);
     slot->old_flags = mem.flags;
     trace_kvm_set_user_memory(mem.slot, mem.flags, mem.guest_phys_addr,
@@ -713,6 +719,16 @@ kvm_check_extension_list(KVMState *s, const KVMCapabilityInfo *list)
     return NULL;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|793| <<kvm_region_add>> kvm_set_phys_mem(kml, section, true);
+ *   - accel/kvm/kvm-all.c|801| <<kvm_region_del>> kvm_set_phys_mem(kml, section, false);
+ *
+ * 这个函数主要就是得到MemoryRegionSection在address_space中的位置,这个就是虚
+ * 拟机的物理地址,函数中是start_addr,,然后通过memory_region_get_ram_ptr得到对
+ * 应其对应的qemu的HVA地址,函数中是ram,当然还有大小的size以及这块内存的flags,
+ * 这些参数组成了一个KVMSlot,之后传递给kvm_set_user_memory_region.
+ */
 static void kvm_set_phys_mem(KVMMemoryListener *kml,
                              MemoryRegionSection *section, bool add)
 {
@@ -723,8 +739,18 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
     hwaddr start_addr, size;
     void *ram;
 
+    /*
+     * 所有把ram设置成true的地方:
+     *   - memory.c|1986| <<memory_region_init_ram_shared_nomigrate>> mr->ram = true;
+     *   - memory.c|2004| <<memory_region_init_resizeable_ram>> mr->ram = true;
+     *   - memory.c|2023| <<memory_region_init_ram_from_file>> mr->ram = true;
+     *   - memory.c|2040| <<memory_region_init_ram_from_fd>> mr->ram = true;
+     *   - memory.c|2055| <<memory_region_init_ram_ptr>> mr->ram = true;
+     *   - memory.c|2118| <<memory_region_init_rom_nomigrate>> mr->ram = true;
+     */
     if (!memory_region_is_ram(mr)) {
         if (writeable || !kvm_readonly_mem_allowed) {
+            /* 设备MR不是RAM但可以写，那么这里直接return不注册到kvm里面 */
             return;
         } else if (!mr->romd_mode) {
             /* If the memory device is not in romd_mode, then we actually want
@@ -778,6 +804,10 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
     }
 }
 
+/*
+ * used by:
+ *   - accel/kvm/kvm-all.c|918| <<kvm_memory_listener_register>> kml->listener.region_add = kvm_region_add;
+ */
 static void kvm_region_add(MemoryListener *listener,
                            MemoryRegionSection *section)
 {
@@ -877,6 +907,13 @@ static void kvm_io_ioeventfd_del(MemoryListener *listener,
     }
 }
 
+/*
+ * 只被两处调用:
+ *   - accel/kvm/kvm-all.c|1727| <<kvm_init>> kvm_memory_listener_register(s, &s->memory_listener,
+ *                                                                         &address_space_memory, 0);
+ *   - target/i386/kvm.c|1373| <<register_smram_listener>> kvm_memory_listener_register(kvm_state, &smram_listener,
+ *                                                                                      &smram_address_space, 1);
+ */
 void kvm_memory_listener_register(KVMState *s, KVMMemoryListener *kml,
                                   AddressSpace *as, int as_id)
 {
@@ -1479,6 +1516,10 @@ bool kvm_vcpu_id_is_valid(int vcpu_id)
     return vcpu_id >= 0 && vcpu_id < kvm_max_vcpu_id(s);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2544| <<kvm_accel_class_init>> ac->init_machine = kvm_init;
+ */
 static int kvm_init(MachineState *ms)
 {
     MachineClass *mc = MACHINE_GET_CLASS(ms);
@@ -2537,6 +2578,9 @@ int kvm_get_one_reg(CPUState *cs, uint64_t id, void *target)
     return r;
 }
 
+/*
+ * TypeInfo kvm_accel_type.class_init = kvm_accel_class_init()
+ */
 static void kvm_accel_class_init(ObjectClass *oc, void *data)
 {
     AccelClass *ac = ACCEL_CLASS(oc);
@@ -2547,11 +2591,20 @@ static void kvm_accel_class_init(ObjectClass *oc, void *data)
 
 static const TypeInfo kvm_accel_type = {
     .name = TYPE_KVM_ACCEL,
-    .parent = TYPE_ACCEL,
+    .parent = TYPE_ACCEL,  // accel_type: class_size是AccelClass, instance_size是AccelState
     .class_init = kvm_accel_class_init,
     .instance_size = sizeof(KVMState),
 };
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
 static void kvm_type_init(void)
 {
     type_register_static(&kvm_accel_type);
diff --git a/bootdevice.c b/bootdevice.c
index 1141009..247eafc 100644
--- a/bootdevice.c
+++ b/bootdevice.c
@@ -208,6 +208,15 @@ DeviceState *get_boot_device(uint32_t position)
  * memory pointed by "size" is assigned total length of the array in bytes
  *
  */
+/*
+ * (gdb) bt
+ * #0  get_boot_devices_list (size=0x7fffffffe078, ignore_suffixes=false) at bootdevice.c:214
+ * #1  0x0000555555b28ae5 in fw_cfg_machine_reset (opaque=0x5555569bc5d0) at hw/nvram/fw_cfg.c:864
+ * #2  0x0000555555a78499 in qemu_devices_reset () at hw/core/reset.c:69
+ * #3  0x000055555591bfda in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #4  0x00005555559d8098 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #5  0x00005555559dfd6e in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4611
+ */
 char *get_boot_devices_list(size_t *size, bool ignore_suffixes)
 {
     FWBootEntry *i;
@@ -280,6 +289,24 @@ static void device_get_bootindex(Object *obj, Visitor *v, const char *name,
     visit_type_int32(v, name, prop->bootindex, errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  device_set_bootindex (obj=0x5555579a9f20, v=0x5555579ace70, name=0x555555ede8fe "bootindex", opaque=0x5555579acd00, errp=0x0) at bootdevice.c:285
+ * #1  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ace70, name=0x555555ede8fe "bootindex", errp=0x0) at qom/object.c:1176
+ * #2  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579ace40, name=0x555555ede8fe "bootindex", errp=0x0) at qom/qom-qobject.c:27
+ * #3  0x0000555555c5e8e6 in object_property_set_int (obj=0x5555579a9f20, value=-1, name=0x555555ede8fe "bootindex", errp=0x0) at qom/object.c:1273
+ * #4  0x00005555559cf629 in device_add_bootindex_property (obj=0x5555579a9f20, bootindex=0x5555579aaa34, name=0x555555ede8fe "bootindex", suffix=0x555555ede8ef "/namespace@1,0", dev=0x5555579a9f20, 
+ *     errp=0x555556751590 <error_abort>) at bootdevice.c:341
+ * #5  0x0000555555a5f923 in nvme_instance_init (obj=0x5555579a9f20) at hw/block/nvme.c:1377
+ * #6  0x0000555555c5c635 in object_init_with_type (obj=0x5555579a9f20, ti=0x555556794080) at qom/object.c:353
+ * #7  0x0000555555c5c7f8 in object_initialize_with_type (data=0x5555579a9f20, size=7248, type=0x555556794080) at qom/object.c:384
+ * #8  0x0000555555c5ce4c in object_new_with_type (type=0x555556794080) at qom/object.c:546
+ * #9  0x0000555555c5ce89 in object_new (typename=0x5555567bde50 "nvme") at qom/object.c:556
+ * #10 0x00005555559d251c in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:608
+ * #11 0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #12 0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #13 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 static void device_set_bootindex(Object *obj, Visitor *v, const char *name,
                                  void *opaque, Error **errp)
 {
diff --git a/data/drive_config_groups.txt b/data/drive_config_groups.txt
new file mode 100644
index 0000000..0940094
--- /dev/null
+++ b/data/drive_config_groups.txt
@@ -0,0 +1,6 @@
+(gdb) p drive_config_groups
+$30 =   {0x555556588f40 <qemu_legacy_drive_opts>,
+  0x5555565891a0 <qemu_common_drive_opts>,
+  0x5555565895e0 <qemu_drive_opts>,
+  0x5555566fd680 <bdrv_runtime_opts>,
+  0x0}
diff --git a/data/info_mtree.txt b/data/info_mtree.txt
new file mode 100644
index 0000000..fcc73fd
--- /dev/null
+++ b/data/info_mtree.txt
@@ -0,0 +1,420 @@
+(qemu) info mtree
+address-space: memory
+  0000000000000000-ffffffffffffffff (prio 0, i/o): system
+    0000000000000000-00000000bb7fffff (prio 0, i/o): alias ram-below-4g @pc.ram 0000000000000000-00000000bb7fffff
+    0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+      00000000000a0000-00000000000bffff (prio 1, i/o): vga-lowmem
+      00000000000c0000-00000000000dffff (prio 1, rom): pc.rom
+      00000000000e0000-00000000000fffff (prio 1, i/o): alias isa-bios @pc.bios 0000000000020000-000000000003ffff
+      00000000fd000000-00000000fdffffff (prio 1, ram): vga.vram
+      00000000febc0000-00000000febdffff (prio 1, i/o): e1000-mmio
+      00000000febf0000-00000000febf1fff (prio 1, i/o): nvme
+      00000000febf2000-00000000febf2fff (prio 1, i/o): vga.mmio
+        00000000febf2400-00000000febf241f (prio 0, i/o): vga ioports remapped
+        00000000febf2500-00000000febf2515 (prio 0, i/o): bochs dispi interface
+        00000000febf2600-00000000febf2607 (prio 0, i/o): qemu extended regs
+      00000000febf3000-00000000febf3fff (prio 1, i/o): nvme-msix
+        00000000febf3000-00000000febf33ff (prio 0, i/o): msix-table
+        00000000febf3800-00000000febf3807 (prio 0, i/o): msix-pba
+      00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+    00000000000a0000-00000000000bffff (prio 1, i/o): alias smram-region @pci 00000000000a0000-00000000000bffff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c0000-00000000000c3fff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pci 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c4000-00000000000c7fff
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pci 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c8000-00000000000cbfff
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pci 00000000000c8000-00000000000cbfff [disabled]
+    00000000000ca000-00000000000ccfff (prio 1000, i/o): alias kvmvapic-rom @pc.ram 00000000000ca000-00000000000ccfff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000cc000-00000000000cffff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pci 00000000000cc000-00000000000cffff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d0000-00000000000d3fff
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pci 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d4000-00000000000d7fff
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pci 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d8000-00000000000dbfff
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pci 00000000000d8000-00000000000dbfff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000dc000-00000000000dffff
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pci 00000000000dc000-00000000000dffff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e0000-00000000000e3fff
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pci 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e4000-00000000000e7fff
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pci 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e8000-00000000000ebfff
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pci 00000000000e8000-00000000000ebfff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-ram @pc.ram 00000000000ec000-00000000000effff
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-rom @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pci 00000000000ec000-00000000000effff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000f0000-00000000000fffff
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pci 00000000000f0000-00000000000fffff [disabled]
+    00000000fec00000-00000000fec00fff (prio 0, i/o): kvm-ioapic
+    00000000fed00000-00000000fed003ff (prio 0, i/o): hpet
+    00000000fee00000-00000000feefffff (prio 4096, i/o): kvm-apic-msi
+
+address-space: I/O
+  0000000000000000-000000000000ffff (prio 0, i/o): io
+    0000000000000000-0000000000000007 (prio 0, i/o): dma-chan
+    0000000000000008-000000000000000f (prio 0, i/o): dma-cont
+    0000000000000020-0000000000000021 (prio 0, i/o): kvm-pic
+    0000000000000040-0000000000000043 (prio 0, i/o): kvm-pit
+    0000000000000060-0000000000000060 (prio 0, i/o): i8042-data
+    0000000000000061-0000000000000061 (prio 0, i/o): pcspk
+    0000000000000064-0000000000000064 (prio 0, i/o): i8042-cmd
+    0000000000000070-0000000000000071 (prio 0, i/o): rtc
+    000000000000007e-000000000000007f (prio 0, i/o): kvmvapic
+    0000000000000080-0000000000000080 (prio 0, i/o): ioport80
+    0000000000000081-0000000000000083 (prio 0, i/o): dma-page
+    0000000000000087-0000000000000087 (prio 0, i/o): dma-page
+    0000000000000089-000000000000008b (prio 0, i/o): dma-page
+    000000000000008f-000000000000008f (prio 0, i/o): dma-page
+    0000000000000092-0000000000000092 (prio 0, i/o): port92
+    00000000000000a0-00000000000000a1 (prio 0, i/o): kvm-pic
+    00000000000000b2-00000000000000b3 (prio 0, i/o): apm-io
+    00000000000000c0-00000000000000cf (prio 0, i/o): dma-chan
+    00000000000000d0-00000000000000df (prio 0, i/o): dma-cont
+    00000000000000f0-00000000000000f0 (prio 0, i/o): ioportF0
+    0000000000000170-0000000000000177 (prio 0, i/o): ide
+    00000000000001ce-00000000000001d1 (prio 0, i/o): vbe
+    00000000000001f0-00000000000001f7 (prio 0, i/o): ide
+    0000000000000376-0000000000000376 (prio 0, i/o): ide
+    0000000000000378-000000000000037f (prio 0, i/o): parallel
+    00000000000003b4-00000000000003b5 (prio 0, i/o): vga
+    00000000000003ba-00000000000003ba (prio 0, i/o): vga
+    00000000000003c0-00000000000003cf (prio 0, i/o): vga
+    00000000000003d4-00000000000003d5 (prio 0, i/o): vga
+    00000000000003da-00000000000003da (prio 0, i/o): vga
+    00000000000003f1-00000000000003f5 (prio 0, i/o): fdc
+    00000000000003f6-00000000000003f6 (prio 0, i/o): ide
+    00000000000003f7-00000000000003f7 (prio 0, i/o): fdc
+    00000000000003f8-00000000000003ff (prio 0, i/o): serial
+    00000000000004d0-00000000000004d0 (prio 0, i/o): kvm-elcr
+    00000000000004d1-00000000000004d1 (prio 0, i/o): kvm-elcr
+    0000000000000510-0000000000000511 (prio 0, i/o): fwcfg
+    0000000000000514-000000000000051b (prio 0, i/o): fwcfg.dma
+    0000000000000600-000000000000063f (prio 0, i/o): piix4-pm
+      0000000000000600-0000000000000603 (prio 0, i/o): acpi-evt
+      0000000000000604-0000000000000605 (prio 0, i/o): acpi-cnt
+      0000000000000608-000000000000060b (prio 0, i/o): acpi-tmr
+    0000000000000700-000000000000073f (prio 0, i/o): pm-smbus
+    0000000000000cf8-0000000000000cfb (prio 0, i/o): pci-conf-idx
+    0000000000000cf9-0000000000000cf9 (prio 1, i/o): piix3-reset-control
+    0000000000000cfc-0000000000000cff (prio 0, i/o): pci-conf-data
+    0000000000005658-0000000000005658 (prio 0, i/o): vmport
+    000000000000ae00-000000000000ae13 (prio 0, i/o): acpi-pci-hotplug
+    000000000000af00-000000000000af0b (prio 0, i/o): acpi-mem-hotplug
+    000000000000afe0-000000000000afe3 (prio 0, i/o): acpi-gpe0
+    000000000000c000-000000000000c03f (prio 1, i/o): e1000-io
+    000000000000c040-000000000000c04f (prio 1, i/o): piix-bmdma-container
+      000000000000c040-000000000000c043 (prio 0, i/o): piix-bmdma
+      000000000000c044-000000000000c047 (prio 0, i/o): bmdma
+      000000000000c048-000000000000c04b (prio 0, i/o): piix-bmdma
+      000000000000c04c-000000000000c04f (prio 0, i/o): bmdma
+
+address-space: cpu-memory-0
+  0000000000000000-ffffffffffffffff (prio 0, i/o): system
+    0000000000000000-00000000bb7fffff (prio 0, i/o): alias ram-below-4g @pc.ram 0000000000000000-00000000bb7fffff
+    0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+      00000000000a0000-00000000000bffff (prio 1, i/o): vga-lowmem
+      00000000000c0000-00000000000dffff (prio 1, rom): pc.rom
+      00000000000e0000-00000000000fffff (prio 1, i/o): alias isa-bios @pc.bios 0000000000020000-000000000003ffff
+      00000000fd000000-00000000fdffffff (prio 1, ram): vga.vram
+      00000000febc0000-00000000febdffff (prio 1, i/o): e1000-mmio
+      00000000febf0000-00000000febf1fff (prio 1, i/o): nvme
+      00000000febf2000-00000000febf2fff (prio 1, i/o): vga.mmio
+        00000000febf2400-00000000febf241f (prio 0, i/o): vga ioports remapped
+        00000000febf2500-00000000febf2515 (prio 0, i/o): bochs dispi interface
+        00000000febf2600-00000000febf2607 (prio 0, i/o): qemu extended regs
+      00000000febf3000-00000000febf3fff (prio 1, i/o): nvme-msix
+        00000000febf3000-00000000febf33ff (prio 0, i/o): msix-table
+        00000000febf3800-00000000febf3807 (prio 0, i/o): msix-pba
+      00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+    00000000000a0000-00000000000bffff (prio 1, i/o): alias smram-region @pci 00000000000a0000-00000000000bffff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c0000-00000000000c3fff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pci 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c4000-00000000000c7fff
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pci 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c8000-00000000000cbfff
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pci 00000000000c8000-00000000000cbfff [disabled]
+    00000000000ca000-00000000000ccfff (prio 1000, i/o): alias kvmvapic-rom @pc.ram 00000000000ca000-00000000000ccfff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000cc000-00000000000cffff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pci 00000000000cc000-00000000000cffff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d0000-00000000000d3fff
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pci 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d4000-00000000000d7fff
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pci 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d8000-00000000000dbfff
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pci 00000000000d8000-00000000000dbfff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000dc000-00000000000dffff
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pci 00000000000dc000-00000000000dffff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e0000-00000000000e3fff
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pci 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e4000-00000000000e7fff
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pci 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e8000-00000000000ebfff
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pci 00000000000e8000-00000000000ebfff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-ram @pc.ram 00000000000ec000-00000000000effff
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-rom @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pci 00000000000ec000-00000000000effff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000f0000-00000000000fffff
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pci 00000000000f0000-00000000000fffff [disabled]
+    00000000fec00000-00000000fec00fff (prio 0, i/o): kvm-ioapic
+    00000000fed00000-00000000fed003ff (prio 0, i/o): hpet
+    00000000fee00000-00000000feefffff (prio 4096, i/o): kvm-apic-msi
+
+address-space: cpu-memory-1
+  0000000000000000-ffffffffffffffff (prio 0, i/o): system
+    0000000000000000-00000000bb7fffff (prio 0, i/o): alias ram-below-4g @pc.ram 0000000000000000-00000000bb7fffff
+    0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+      00000000000a0000-00000000000bffff (prio 1, i/o): vga-lowmem
+      00000000000c0000-00000000000dffff (prio 1, rom): pc.rom
+      00000000000e0000-00000000000fffff (prio 1, i/o): alias isa-bios @pc.bios 0000000000020000-000000000003ffff
+      00000000fd000000-00000000fdffffff (prio 1, ram): vga.vram
+      00000000febc0000-00000000febdffff (prio 1, i/o): e1000-mmio
+      00000000febf0000-00000000febf1fff (prio 1, i/o): nvme
+      00000000febf2000-00000000febf2fff (prio 1, i/o): vga.mmio
+        00000000febf2400-00000000febf241f (prio 0, i/o): vga ioports remapped
+        00000000febf2500-00000000febf2515 (prio 0, i/o): bochs dispi interface
+        00000000febf2600-00000000febf2607 (prio 0, i/o): qemu extended regs
+      00000000febf3000-00000000febf3fff (prio 1, i/o): nvme-msix
+        00000000febf3000-00000000febf33ff (prio 0, i/o): msix-table
+        00000000febf3800-00000000febf3807 (prio 0, i/o): msix-pba
+      00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+    00000000000a0000-00000000000bffff (prio 1, i/o): alias smram-region @pci 00000000000a0000-00000000000bffff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c0000-00000000000c3fff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pci 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c4000-00000000000c7fff
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pci 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c8000-00000000000cbfff
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pci 00000000000c8000-00000000000cbfff [disabled]
+    00000000000ca000-00000000000ccfff (prio 1000, i/o): alias kvmvapic-rom @pc.ram 00000000000ca000-00000000000ccfff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000cc000-00000000000cffff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pci 00000000000cc000-00000000000cffff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d0000-00000000000d3fff
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pci 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d4000-00000000000d7fff
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pci 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d8000-00000000000dbfff
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pci 00000000000d8000-00000000000dbfff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000dc000-00000000000dffff
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pci 00000000000dc000-00000000000dffff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e0000-00000000000e3fff
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pci 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e4000-00000000000e7fff
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pci 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e8000-00000000000ebfff
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pci 00000000000e8000-00000000000ebfff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-ram @pc.ram 00000000000ec000-00000000000effff
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-rom @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pci 00000000000ec000-00000000000effff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000f0000-00000000000fffff
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pci 00000000000f0000-00000000000fffff [disabled]
+    00000000fec00000-00000000fec00fff (prio 0, i/o): kvm-ioapic
+    00000000fed00000-00000000fed003ff (prio 0, i/o): hpet
+    00000000fee00000-00000000feefffff (prio 4096, i/o): kvm-apic-msi
+
+address-space: i440FX
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff [disabled]
+
+address-space: PIIX3
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff [disabled]
+
+address-space: VGA
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff [disabled]
+
+address-space: e1000
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff
+
+address-space: piix3-ide
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff
+
+address-space: PIIX4_PM
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff [disabled]
+
+address-space: nvme
+  0000000000000000-ffffffffffffffff (prio 0, i/o): bus master container
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias bus master @system 0000000000000000-ffffffffffffffff
+
+address-space: KVM-SMRAM
+  0000000000000000-ffffffffffffffff (prio 0, i/o): mem-container-smram
+    0000000000000000-00000000ffffffff (prio 10, i/o): smram
+      00000000000a0000-00000000000bffff (prio 0, i/o): alias smram-low @pc.ram 00000000000a0000-00000000000bffff
+    0000000000000000-ffffffffffffffff (prio 0, i/o): alias mem-smram @system 0000000000000000-ffffffffffffffff
+
+memory-region: pc.ram
+  0000000000000000-00000000bb7fffff (prio 0, ram): pc.ram
+
+memory-region: pc.bios
+  00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+
+memory-region: pci
+  0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+    00000000000a0000-00000000000bffff (prio 1, i/o): vga-lowmem
+    00000000000c0000-00000000000dffff (prio 1, rom): pc.rom
+    00000000000e0000-00000000000fffff (prio 1, i/o): alias isa-bios @pc.bios 0000000000020000-000000000003ffff
+    00000000fd000000-00000000fdffffff (prio 1, ram): vga.vram
+    00000000febc0000-00000000febdffff (prio 1, i/o): e1000-mmio
+    00000000febf0000-00000000febf1fff (prio 1, i/o): nvme
+    00000000febf2000-00000000febf2fff (prio 1, i/o): vga.mmio
+      00000000febf2400-00000000febf241f (prio 0, i/o): vga ioports remapped
+      00000000febf2500-00000000febf2515 (prio 0, i/o): bochs dispi interface
+      00000000febf2600-00000000febf2607 (prio 0, i/o): qemu extended regs
+    00000000febf3000-00000000febf3fff (prio 1, i/o): nvme-msix
+      00000000febf3000-00000000febf33ff (prio 0, i/o): msix-table
+      00000000febf3800-00000000febf3807 (prio 0, i/o): msix-pba
+    00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+
+memory-region: system
+  0000000000000000-ffffffffffffffff (prio 0, i/o): system
+    0000000000000000-00000000bb7fffff (prio 0, i/o): alias ram-below-4g @pc.ram 0000000000000000-00000000bb7fffff
+    0000000000000000-ffffffffffffffff (prio -1, i/o): pci
+      00000000000a0000-00000000000bffff (prio 1, i/o): vga-lowmem
+      00000000000c0000-00000000000dffff (prio 1, rom): pc.rom
+      00000000000e0000-00000000000fffff (prio 1, i/o): alias isa-bios @pc.bios 0000000000020000-000000000003ffff
+      00000000fd000000-00000000fdffffff (prio 1, ram): vga.vram
+      00000000febc0000-00000000febdffff (prio 1, i/o): e1000-mmio
+      00000000febf0000-00000000febf1fff (prio 1, i/o): nvme
+      00000000febf2000-00000000febf2fff (prio 1, i/o): vga.mmio
+        00000000febf2400-00000000febf241f (prio 0, i/o): vga ioports remapped
+        00000000febf2500-00000000febf2515 (prio 0, i/o): bochs dispi interface
+        00000000febf2600-00000000febf2607 (prio 0, i/o): qemu extended regs
+      00000000febf3000-00000000febf3fff (prio 1, i/o): nvme-msix
+        00000000febf3000-00000000febf33ff (prio 0, i/o): msix-table
+        00000000febf3800-00000000febf3807 (prio 0, i/o): msix-pba
+      00000000fffc0000-00000000ffffffff (prio 0, rom): pc.bios
+    00000000000a0000-00000000000bffff (prio 1, i/o): alias smram-region @pci 00000000000a0000-00000000000bffff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c0000-00000000000c3fff
+    00000000000c0000-00000000000c3fff (prio 1, i/o): alias pam-pci @pci 00000000000c0000-00000000000c3fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c4000-00000000000c7fff
+    00000000000c4000-00000000000c7fff (prio 1, i/o): alias pam-pci @pci 00000000000c4000-00000000000c7fff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000c8000-00000000000cbfff [disabled]
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000c8000-00000000000cbfff
+    00000000000c8000-00000000000cbfff (prio 1, i/o): alias pam-pci @pci 00000000000c8000-00000000000cbfff [disabled]
+    00000000000ca000-00000000000ccfff (prio 1000, i/o): alias kvmvapic-rom @pc.ram 00000000000ca000-00000000000ccfff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000cc000-00000000000cffff [disabled]
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000cc000-00000000000cffff
+    00000000000cc000-00000000000cffff (prio 1, i/o): alias pam-pci @pci 00000000000cc000-00000000000cffff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d0000-00000000000d3fff
+    00000000000d0000-00000000000d3fff (prio 1, i/o): alias pam-pci @pci 00000000000d0000-00000000000d3fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d4000-00000000000d7fff
+    00000000000d4000-00000000000d7fff (prio 1, i/o): alias pam-pci @pci 00000000000d4000-00000000000d7fff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000d8000-00000000000dbfff [disabled]
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000d8000-00000000000dbfff
+    00000000000d8000-00000000000dbfff (prio 1, i/o): alias pam-pci @pci 00000000000d8000-00000000000dbfff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000dc000-00000000000dffff [disabled]
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000dc000-00000000000dffff
+    00000000000dc000-00000000000dffff (prio 1, i/o): alias pam-pci @pci 00000000000dc000-00000000000dffff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e0000-00000000000e3fff
+    00000000000e0000-00000000000e3fff (prio 1, i/o): alias pam-pci @pci 00000000000e0000-00000000000e3fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e4000-00000000000e7fff
+    00000000000e4000-00000000000e7fff (prio 1, i/o): alias pam-pci @pci 00000000000e4000-00000000000e7fff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-ram @pc.ram 00000000000e8000-00000000000ebfff
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-rom @pc.ram 00000000000e8000-00000000000ebfff [disabled]
+    00000000000e8000-00000000000ebfff (prio 1, i/o): alias pam-pci @pci 00000000000e8000-00000000000ebfff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-ram @pc.ram 00000000000ec000-00000000000effff
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-rom @pc.ram 00000000000ec000-00000000000effff [disabled]
+    00000000000ec000-00000000000effff (prio 1, i/o): alias pam-pci @pci 00000000000ec000-00000000000effff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-ram @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pc.ram 00000000000f0000-00000000000fffff [disabled]
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-rom @pc.ram 00000000000f0000-00000000000fffff
+    00000000000f0000-00000000000fffff (prio 1, i/o): alias pam-pci @pci 00000000000f0000-00000000000fffff [disabled]
+    00000000fec00000-00000000fec00fff (prio 0, i/o): kvm-ioapic
+    00000000fed00000-00000000fed003ff (prio 0, i/o): hpet
+    00000000fee00000-00000000feefffff (prio 4096, i/o): kvm-apic-msi
diff --git a/data/qemu_options.txt b/data/qemu_options.txt
new file mode 100644
index 0000000..3956fb6
--- /dev/null
+++ b/data/qemu_options.txt
@@ -0,0 +1,722 @@
+(gdb) p qemu_options
+$5 = {{
+    name = 0x555555ec4a19 "h", 
+    flags = 0, 
+    index = 0, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd2e2 "help", 
+    flags = 0, 
+    index = 0, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a1b "version", 
+    flags = 0, 
+    index = 1, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd4f6 "machine", 
+    flags = 1, 
+    index = 2, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a23 "M", 
+    flags = 1, 
+    index = 3, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a25 "cpu", 
+    flags = 1, 
+    index = 4, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd503 "accel", 
+    flags = 1, 
+    index = 5, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebdf86 "smp", 
+    flags = 1, 
+    index = 6, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a29 "numa", 
+    flags = 1, 
+    index = 7, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd59d "add-fd", 
+    flags = 1, 
+    index = 8, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd5e0 "set", 
+    flags = 1, 
+    index = 9, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a2e "global", 
+    flags = 1, 
+    index = 10, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a35 "boot", 
+    flags = 1, 
+    index = 11, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a3a "m", 
+    flags = 1, 
+    index = 12, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a3c "mem-path", 
+    flags = 1, 
+    index = 13, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a45 "mem-prealloc", 
+    flags = 0, 
+    index = 14, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a52 "k", 
+    flags = 1, 
+    index = 15, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a54 "audio-help", 
+    flags = 0, 
+    index = 16, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a5f "soundhw", 
+    flags = 1, 
+    index = 17, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a67 "balloon", 
+    flags = 1, 
+    index = 18, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a6f "device", 
+    flags = 1, 
+    index = 19, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd684 "name", 
+    flags = 1, 
+    index = 20, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a76 "uuid", 
+    flags = 1, 
+    index = 21, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a7b "fda", 
+    flags = 1, 
+    index = 22, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a7f "fdb", 
+    flags = 1, 
+    index = 23, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a83 "hda", 
+    flags = 1, 
+    index = 24, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a87 "hdb", 
+    flags = 1, 
+    index = 25, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a8b "hdc", 
+    flags = 1, 
+    index = 26, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a8f "hdd", 
+    flags = 1, 
+    index = 27, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a93 "cdrom", 
+    flags = 1, 
+    index = 28, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4a99 "blockdev", 
+    flags = 1, 
+    index = 29, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4aa2 "drive", 
+    flags = 1, 
+    index = 30, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4aa8 "mtdblock", 
+    flags = 1, 
+    index = 31, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ab1 "sd", 
+    flags = 1, 
+    index = 32, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ab4 "pflash", 
+    flags = 1, 
+    index = 33, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebde89 "snapshot", 
+    flags = 0, 
+    index = 34, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4abb "fsdev", 
+    flags = 1, 
+    index = 35, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ac1 "virtfs", 
+    flags = 1, 
+    index = 36, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ac8 "virtfs_synth", 
+    flags = 0, 
+    index = 37, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ad5 "iscsi", 
+    flags = 1, 
+    index = 38, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4adb "usb", 
+    flags = 0, 
+    index = 39, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4adf "usbdevice", 
+    flags = 1, 
+    index = 40, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ae9 "display", 
+    flags = 1, 
+    index = 41, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4af1 "nographic", 
+    flags = 0, 
+    index = 42, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4afb "curses", 
+    flags = 0, 
+    index = 43, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b02 "no-frame", 
+    flags = 0, 
+    index = 44, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b0b "alt-grab", 
+    flags = 0, 
+    index = 45, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b14 "ctrl-grab", 
+    flags = 0, 
+    index = 46, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b1e "no-quit", 
+    flags = 0, 
+    index = 47, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b26 "sdl", 
+    flags = 0, 
+    index = 48, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b2a "spice", 
+    flags = 1, 
+    index = 49, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b30 "portrait", 
+    flags = 0, 
+    index = 50, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b39 "rotate", 
+    flags = 1, 
+    index = 51, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b40 "vga", 
+    flags = 1, 
+    index = 52, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b44 "full-screen", 
+    flags = 0, 
+    index = 53, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b50 "g", 
+    flags = 1, 
+    index = 54, 
+    arch_mask = 2304
+  }, {
+    name = 0x555555ec4b52 "vnc", 
+    flags = 1, 
+    index = 55, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4b56 "win2k-hack", 
+    flags = 0, 
+    index = 56, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4b61 "rtc-td-hack", 
+    flags = 0, 
+    index = 57, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4b6d "no-fd-bootchk", 
+    flags = 0, 
+    index = 58, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4b7b "no-acpi", 
+    flags = 0, 
+    index = 59, 
+    arch_mask = 10
+  }, {
+    name = 0x555555ec4b83 "no-hpet", 
+    flags = 0, 
+    index = 60, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4b8b "acpitable", 
+    flags = 1, 
+    index = 61, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4b95 "smbios", 
+    flags = 1, 
+    index = 62, 
+    arch_mask = 10
+  }, {
+    name = 0x555555ec4b9c "tftp", 
+    flags = 1, 
+    index = 63, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ba1 "bootp", 
+    flags = 1, 
+    index = 64, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ba7 "redir", 
+    flags = 1, 
+    index = 65, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bad "smb", 
+    flags = 1, 
+    index = 66, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bb1 "netdev", 
+    flags = 1, 
+    index = 67, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bb8 "nic", 
+    flags = 1, 
+    index = 68, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bbc "net", 
+    flags = 1, 
+    index = 69, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bc0 "chardev", 
+    flags = 1, 
+    index = 70, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bc8 "bt", 
+    flags = 1, 
+    index = 71, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd645 "tpmdev", 
+    flags = 1, 
+    index = 72, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bcb "kernel", 
+    flags = 1, 
+    index = 73, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bd2 "append", 
+    flags = 1, 
+    index = 74, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bd9 "initrd", 
+    flags = 1, 
+    index = 75, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4be0 "dtb", 
+    flags = 1, 
+    index = 76, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd84c "fw_cfg", 
+    flags = 1, 
+    index = 77, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4be4 "serial", 
+    flags = 1, 
+    index = 78, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4beb "parallel", 
+    flags = 1, 
+    index = 79, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bf4 "monitor", 
+    flags = 1, 
+    index = 80, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4bfc "qmp", 
+    flags = 1, 
+    index = 81, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c00 "qmp-pretty", 
+    flags = 1, 
+    index = 82, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c0b "mon", 
+    flags = 1, 
+    index = 83, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c0f "debugcon", 
+    flags = 1, 
+    index = 84, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c18 "pidfile", 
+    flags = 1, 
+    index = 85, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c20 "singlestep", 
+    flags = 0, 
+    index = 86, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c2b "preconfig", 
+    flags = 0, 
+    index = 87, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c35 "S", 
+    flags = 0, 
+    index = 88, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd64c "realtime", 
+    flags = 1, 
+    index = 89, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd65b "overcommit", 
+    flags = 1, 
+    index = 90, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c37 "gdb", 
+    flags = 1, 
+    index = 91, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c3b "s", 
+    flags = 0, 
+    index = 92, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c3d "d", 
+    flags = 1, 
+    index = 93, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c3f "D", 
+    flags = 1, 
+    index = 94, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c41 "dfilter", 
+    flags = 1, 
+    index = 95, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c49 "L", 
+    flags = 1, 
+    index = 96, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c4b "bios", 
+    flags = 1, 
+    index = 97, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c50 "enable-kvm", 
+    flags = 0, 
+    index = 98, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c5b "enable-hax", 
+    flags = 0, 
+    index = 99, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ec4c66 "xen-domid", 
+    flags = 1, 
+    index = 100, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c70 "xen-create", 
+    flags = 0, 
+    index = 101, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c7b "xen-attach", 
+    flags = 0, 
+    index = 102, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c86 "xen-domid-restrict", 
+    flags = 0, 
+    index = 103, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4c99 "no-reboot", 
+    flags = 0, 
+    index = 104, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ca3 "no-shutdown", 
+    flags = 0, 
+    index = 105, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4caf "loadvm", 
+    flags = 1, 
+    index = 106, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4cb6 "daemonize", 
+    flags = 0, 
+    index = 107, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd4d9 "option-rom", 
+    flags = 1, 
+    index = 108, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd4ca "clock", 
+    flags = 1, 
+    index = 109, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebdc12 "localtime", 
+    flags = 0, 
+    index = 110, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4cc0 "startdate", 
+    flags = 1, 
+    index = 111, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd4c1 "rtc", 
+    flags = 1, 
+    index = 112, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd7f9 "icount", 
+    flags = 1, 
+    index = 113, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4cca "watchdog", 
+    flags = 1, 
+    index = 114, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4cd3 "watchdog-action", 
+    flags = 1, 
+    index = 115, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ce3 "echr", 
+    flags = 1, 
+    index = 116, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4ce8 "virtioconsole", 
+    flags = 1, 
+    index = 117, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4cf6 "show-cursor", 
+    flags = 0, 
+    index = 118, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d02 "tb-size", 
+    flags = 1, 
+    index = 119, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d0a "incoming", 
+    flags = 1, 
+    index = 120, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d13 "only-migratable", 
+    flags = 0, 
+    index = 121, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d23 "nodefaults", 
+    flags = 0, 
+    index = 122, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d2e "chroot", 
+    flags = 1, 
+    index = 123, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d35 "runas", 
+    flags = 1, 
+    index = 124, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d3b "prom-env", 
+    flags = 1, 
+    index = 125, 
+    arch_mask = 2304
+  }, {
+    name = 0x555555ec4d44 "semihosting", 
+    flags = 0, 
+    index = 126, 
+    arch_mask = 4274
+  }, {
+    name = 0x555555ebd827 "semihosting-config", 
+    flags = 1, 
+    index = 127, 
+    arch_mask = 4274
+  }, {
+    name = 0x555555ec4d50 "old-param", 
+    flags = 0, 
+    index = 128, 
+    arch_mask = 2
+  }, {
+    name = 0x555555ec4d5a "sandbox", 
+    flags = 1, 
+    index = 129, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d62 "readconfig", 
+    flags = 1, 
+    index = 130, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d6d "writeconfig", 
+    flags = 1, 
+    index = 131, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d79 "nodefconfig", 
+    flags = 0, 
+    index = 132, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d85 "no-user-config", 
+    flags = 0, 
+    index = 133, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d94 "trace", 
+    flags = 1, 
+    index = 134, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4d9a "qtest", 
+    flags = 1, 
+    index = 135, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4da0 "qtest-log", 
+    flags = 1, 
+    index = 136, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4daa "enable-fips", 
+    flags = 0, 
+    index = 137, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4db6 "no-kvm", 
+    flags = 0, 
+    index = 138, 
+    arch_mask = 8
+  }, {
+    name = 0x555555ebd676 "msg", 
+    flags = 1, 
+    index = 139, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ec4dbd "dump-vmstate", 
+    flags = 1, 
+    index = 140, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x555555ebd635 "object", 
+    flags = 1, 
+    index = 141, 
+    arch_mask = 4294967295
+  }, {
+    name = 0x0, 
+    flags = 0, 
+    index = 0, 
+    arch_mask = 0
+  }}
diff --git a/data/qom-tree.txt b/data/qom-tree.txt
new file mode 100644
index 0000000..b3aa5e7
--- /dev/null
+++ b/data/qom-tree.txt
@@ -0,0 +1,262 @@
+(qemu) info qom-tree
+/machine (pc-i440fx-3.0-machine)
+  /unattached (container)
+    /non-qdev-gpio[24] (irq)
+    /non-qdev-gpio[3] (irq)
+    /device[14] (i8257)
+      /dma-page[0] (qemu:memory-region)
+      /dma-page[1] (qemu:memory-region)
+      /dma-cont[0] (qemu:memory-region)
+    /device[9] (hpet)
+      /unnamed-gpio-in[0] (irq)
+      /unnamed-gpio-in[1] (irq)
+      /hpet[0] (qemu:memory-region)
+    /device[18] (floppy)
+    /non-qdev-gpio[7] (irq)
+    /device[22] (port92)
+      /port92[0] (qemu:memory-region)
+    /device[26] (ide-cd)
+    /device[30] (smbus-eeprom)
+    /system[0] (qemu:memory-region)
+    /non-qdev-gpio[13] (irq)
+    /device[34] (smbus-eeprom)
+    /ide[1] (qemu:memory-region)
+    /non-qdev-gpio[17] (irq)
+    /device[2] (qemu64-x86_64-cpu)
+      /lapic (kvm-apic)
+        /kvm-apic-msi[0] (qemu:memory-region)
+    /non-qdev-gpio[21] (irq)
+    /dma-chan[1] (qemu:memory-region)
+    /device[11] (kvm-pit)
+      /kvm-pit[0] (qemu:memory-region)
+      /unnamed-gpio-in[0] (irq)
+    /non-qdev-gpio[0] (irq)
+    /device[6] (kvm-i8259)
+      /kvm-pic[0] (qemu:memory-region)
+      /kvm-elcr[0] (qemu:memory-region)
+    /non-qdev-gpio[25] (irq)
+    /device[15] (isa-serial)
+      /serial[0] (qemu:memory-region)
+    /non-qdev-gpio[4] (irq)
+    /device[19] (i8042)
+      /i8042-cmd[0] (qemu:memory-region)
+      /i8042-data[0] (qemu:memory-region)
+    /non-qdev-gpio[8] (irq)
+    /ioport80[0] (qemu:memory-region)
+    /device[23] (e1000)
+      /e1000.rom[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /e1000-io[0] (qemu:memory-region)
+      /e1000-mmio[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+    /device[27] (PIIX4_PM)
+      /piix4-pm[0] (qemu:memory-region)
+      /acpi-evt[0] (qemu:memory-region)
+      /acpi-tmr[0] (qemu:memory-region)
+      /apm-io[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /acpi-pci-hotplug[0] (qemu:memory-region)
+      /pm-smbus[0] (qemu:memory-region)
+      /acpi-gpe0[0] (qemu:memory-region)
+      /i2c (i2c-bus)
+      /acpi-cnt[0] (qemu:memory-region)
+      /acpi-mem-hotplug[0] (qemu:memory-region)
+      /acpi-cpu-hotplug[0] (qemu:memory-region)
+    /non-qdev-gpio[10] (irq)
+    /device[31] (smbus-eeprom)
+    /isa-bios[0] (qemu:memory-region)
+    /non-qdev-gpio[14] (irq)
+    /pc.rom[0] (qemu:memory-region)
+    /ide[2] (qemu:memory-region)
+    /non-qdev-gpio[18] (irq)
+    /device[3] (kvmclock)
+    /non-qdev-gpio[22] (irq)
+    /device[12] (isa-pcspk)
+      /pcspk[0] (qemu:memory-region)
+    /non-qdev-gpio[1] (irq)
+    /device[7] (kvm-i8259)
+      /kvm-pic[0] (qemu:memory-region)
+      /kvm-elcr[0] (qemu:memory-region)
+    /non-qdev-gpio[5] (irq)
+    /device[16] (isa-parallel)
+      /parallel[0] (qemu:memory-region)
+    /device[20] (vmport)
+      /vmport[0] (qemu:memory-region)
+    /vga.mmio[0] (qemu:memory-region)
+    /non-qdev-gpio[9] (irq)
+    /device[24] (piix3-ide)
+      /piix-bmdma[0] (qemu:memory-region)
+      /piix-bmdma-container[0] (qemu:memory-region)
+      /bmdma[1] (qemu:memory-region)
+      /bmdma[0] (qemu:memory-region)
+      /piix-bmdma[1] (qemu:memory-region)
+      /ide.0 (IDE)
+      /ide.1 (IDE)
+      /bus master[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+    /device[28] (smbus-eeprom)
+    /non-qdev-gpio[11] (irq)
+    /io[0] (qemu:memory-region)
+    /device[32] (smbus-eeprom)
+    /non-qdev-gpio[15] (irq)
+    /device[0] (qemu64-x86_64-cpu)
+      /lapic (kvm-apic)
+        /kvm-apic-msi[0] (qemu:memory-region)
+    /ram-below-4g[0] (qemu:memory-region)
+    /ide[3] (qemu:memory-region)
+    /non-qdev-gpio[19] (irq)
+    /device[4] (i440FX)
+      /smram[0] (qemu:memory-region)
+      /smram-region[0] (qemu:memory-region)
+      /smram-low[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+    /non-qdev-gpio[23] (irq)
+    /pci[0] (qemu:memory-region)
+    /non-qdev-gpio[2] (irq)
+    /device[13] (i8257)
+      /dma-page[0] (qemu:memory-region)
+      /dma-page[1] (qemu:memory-region)
+      /dma-cont[0] (qemu:memory-region)
+    /device[8] (VGA)
+      /vga.rom[0] (qemu:memory-region)
+      /vga[0] (qemu:memory-region)
+      /bochs dispi interface[0] (qemu:memory-region)
+      /vga[2] (qemu:memory-region)
+      /vga[4] (qemu:memory-region)
+      /qemu extended regs[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /vga-lowmem[0] (qemu:memory-region)
+      /vga[1] (qemu:memory-region)
+      /vga[3] (qemu:memory-region)
+      /vga.vram[0] (qemu:memory-region)
+      /vga ioports remapped[0] (qemu:memory-region)
+      /vbe[0] (qemu:memory-region)
+    /pc.bios[0] (qemu:memory-region)
+    /ioportF0[0] (qemu:memory-region)
+    /device[17] (isa-fdc)
+      /floppy-bus.0 (floppy-bus)
+      /fdc[0] (qemu:memory-region)
+      /fdc[1] (qemu:memory-region)
+    /non-qdev-gpio[6] (irq)
+    /device[21] (vmmouse)
+    /sysbus (System)
+    /device[25] (ide-hd)
+    /device[35] (smbus-eeprom)
+    /device[29] (smbus-eeprom)
+    /non-qdev-gpio[12] (irq)
+    /device[33] (smbus-eeprom)
+    /ide[0] (qemu:memory-region)
+    /dma-chan[0] (qemu:memory-region)
+    /non-qdev-gpio[16] (irq)
+    /device[1] (kvmvapic)
+      /kvmvapic[0] (qemu:memory-region)
+      /kvmvapic-rom[0] (qemu:memory-region)
+    /non-qdev-gpio[20] (irq)
+    /device[10] (mc146818rtc)
+      /rtc[0] (qemu:memory-region)
+    /pc.ram[0] (qemu:memory-region)
+    /device[5] (PIIX3)
+      /isa.0 (ISA)
+      /piix3-reset-control[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+  /fw_cfg (fw_cfg_io)
+    /\x2from@etc\x2ftable-loader[0] (qemu:memory-region)
+    /fwcfg[0] (qemu:memory-region)
+    /\x2from@etc\x2facpi\x2frsdp[0] (qemu:memory-region)
+    /\x2from@etc\x2facpi\x2ftables[0] (qemu:memory-region)
+    /fwcfg.dma[0] (qemu:memory-region)
+  /peripheral-anon (container)
+    /device[0] (nvme)
+      /nvme-msix[0] (qemu:memory-region)
+      /msix-table[0] (qemu:memory-region)
+      /bus master container[0] (qemu:memory-region)
+      /bus master[0] (qemu:memory-region)
+      /msix-pba[0] (qemu:memory-region)
+      /nvme[0] (qemu:memory-region)
+  /peripheral (container)
+  /i440fx (i440FX-pcihost)
+    /pam-pci[19] (qemu:memory-region)
+    /pam-rom[1] (qemu:memory-region)
+    /pam-pci[8] (qemu:memory-region)
+    /pam-rom[10] (qemu:memory-region)
+    /pam-rom[5] (qemu:memory-region)
+    /pam-pci[23] (qemu:memory-region)
+    /pam-ram[3] (qemu:memory-region)
+    /pam-rom[9] (qemu:memory-region)
+    /pci-conf-idx[0] (qemu:memory-region)
+    /pam-ram[7] (qemu:memory-region)
+    /pam-pci[12] (qemu:memory-region)
+    /pam-pci[1] (qemu:memory-region)
+    /pam-pci[16] (qemu:memory-region)
+    /pam-ram[10] (qemu:memory-region)
+    /pam-pci[20] (qemu:memory-region)
+    /pam-pci[5] (qemu:memory-region)
+    /pam-rom[2] (qemu:memory-region)
+    /pam-pci[24] (qemu:memory-region)
+    /pam-pci[9] (qemu:memory-region)
+    /pam-rom[11] (qemu:memory-region)
+    /pam-rom[6] (qemu:memory-region)
+    /pam-ram[0] (qemu:memory-region)
+    /pam-ram[4] (qemu:memory-region)
+    /pam-ram[8] (qemu:memory-region)
+    /pam-pci[13] (qemu:memory-region)
+    /pam-pci[2] (qemu:memory-region)
+    /pam-pci[17] (qemu:memory-region)
+    /pam-ram[11] (qemu:memory-region)
+    /pam-pci[21] (qemu:memory-region)
+    /pam-pci[6] (qemu:memory-region)
+    /pam-rom[3] (qemu:memory-region)
+    /pam-pci[25] (qemu:memory-region)
+    /ioapic (kvm-ioapic)
+      /unnamed-gpio-in[17] (irq)
+      /unnamed-gpio-in[9] (irq)
+      /unnamed-gpio-in[20] (irq)
+      /unnamed-gpio-in[19] (irq)
+      /unnamed-gpio-in[22] (irq)
+      /unnamed-gpio-in[0] (irq)
+      /unnamed-gpio-in[10] (irq)
+      /unnamed-gpio-in[2] (irq)
+      /unnamed-gpio-in[12] (irq)
+      /unnamed-gpio-in[4] (irq)
+      /unnamed-gpio-in[14] (irq)
+      /unnamed-gpio-in[6] (irq)
+      /unnamed-gpio-in[16] (irq)
+      /unnamed-gpio-in[8] (irq)
+      /unnamed-gpio-in[18] (irq)
+      /unnamed-gpio-in[21] (irq)
+      /unnamed-gpio-in[23] (irq)
+      /unnamed-gpio-in[1] (irq)
+      /kvm-ioapic[0] (qemu:memory-region)
+      /unnamed-gpio-in[11] (irq)
+      /unnamed-gpio-in[3] (irq)
+      /unnamed-gpio-in[13] (irq)
+      /unnamed-gpio-in[5] (irq)
+      /unnamed-gpio-in[15] (irq)
+      /unnamed-gpio-in[7] (irq)
+    /pam-ram[1] (qemu:memory-region)
+    /pam-rom[12] (qemu:memory-region)
+    /pam-rom[7] (qemu:memory-region)
+    /pam-ram[5] (qemu:memory-region)
+    /pci-conf-data[0] (qemu:memory-region)
+    /pam-ram[9] (qemu:memory-region)
+    /pam-pci[10] (qemu:memory-region)
+    /pam-pci[14] (qemu:memory-region)
+    /pam-pci[3] (qemu:memory-region)
+    /pam-pci[18] (qemu:memory-region)
+    /pam-rom[0] (qemu:memory-region)
+    /pam-pci[22] (qemu:memory-region)
+    /pam-pci[7] (qemu:memory-region)
+    /pam-ram[12] (qemu:memory-region)
+    /pam-rom[4] (qemu:memory-region)
+    /pam-ram[2] (qemu:memory-region)
+    /pam-rom[8] (qemu:memory-region)
+    /pam-ram[6] (qemu:memory-region)
+    /pam-pci[11] (qemu:memory-region)
+    /pci.0 (PCI)
+    /pam-pci[0] (qemu:memory-region)
+    /pam-pci[15] (qemu:memory-region)
+    /pam-pci[4] (qemu:memory-region)
diff --git a/data/vm_config_groups.txt b/data/vm_config_groups.txt
new file mode 100644
index 0000000..5f2770b
--- /dev/null
+++ b/data/vm_config_groups.txt
@@ -0,0 +1,33 @@
+(gdb) p vm_config_groups
+$22 =   {0x5555565895e0 <qemu_drive_opts>,
+  0x555556706b00 <qemu_chardev_opts>,
+  0x555556589680 <qemu_device_opts>,
+  0x5555566fa0c0 <qemu_netdev_opts>,
+  0x5555566fa120 <qemu_nic_opts>,
+  0x5555566fa180 <qemu_net_opts>,
+  0x555556589980 <qemu_rtc_opts>,
+  0x5555565896e0 <qemu_global_opts>,
+  0x55555656efa0 <qemu_mon_opts>,
+  0x5555567074e0 <qemu_trace_opts>,
+  0x555556589a40 <qemu_option_rom_opts>,
+  0x555556589ae0 <qemu_machine_opts>,
+  0x555556589b40 <qemu_accel_opts>,
+  0x55555658a100 <qemu_mem_opts>,
+  0x55555658a460 <qemu_smp_opts>,
+  0x555556589be0 <qemu_boot_opts>,
+  0x555556589d20 <qemu_add_fd_opts>,
+  0x555556589de0 <qemu_object_opts>,
+  0x555556589e40 <qemu_tpmdev_opts>,
+  0x555556589ea0 <qemu_realtime_opts>,
+  0x555556589fc0 <qemu_msg_opts>,
+  0x55555658a040 <qemu_name_opts>,
+  0x55555656f0a0 <qemu_numa_opts>,
+  0x55555658a1c0 <qemu_icount_opts>,
+  0x55555658a2e0 <qemu_semihosting_config_opts>,
+  0x55555658a3a0 <qemu_fw_cfg_opts>,
+  0x5555565d0460 <qemu_fsdev_opts>,
+  0x5555565d0840 <qemu_virtfs_opts>,
+  0x5555565d09e0 <qemu_acpi_opts>,
+  0x5555566eb300 <qemu_smbios_opts>,
+  0x5555566fcec0 <qemu_vnc_opts>,
+  0x0 <repeats 17 times>}
diff --git a/exec.c b/exec.c
index 4f5df07..0860f40 100644
--- a/exec.c
+++ b/exec.c
@@ -79,11 +79,24 @@
  */
 RAMList ram_list = { .blocks = QLIST_HEAD_INITIALIZER(ram_list.blocks) };
 
+/*
+ * system_memory作为address_space_memory的根MemoryRegion,
+ * 大小涵盖了整个64位空间的大小, 这是一个pure contaner,并
+ * 不会分配空间的
+ */
 static MemoryRegion *system_memory;
+/*
+ * system_io作为address_space_io的根MemoryRegion,大小为65536,
+ * 也就是平时的io port空间
+ */
 static MemoryRegion *system_io;
 
 AddressSpace address_space_io;
 AddressSpace address_space_memory;
+/*
+ * 在随后的cpu初始化之中,还会初始化多个AddressSpace,
+ * 这些很多都是disabled的,对虚拟机意义不大
+ */
 
 MemoryRegion io_mem_rom, io_mem_notdirty;
 static MemoryRegion io_mem_unassigned;
@@ -159,50 +172,130 @@ static void finalize_target_page_bits(void)
 
 typedef struct PhysPageEntry PhysPageEntry;
 
+/*
+ * skip表示需要移动多少步到下一级页表,如果skip为0,说明这是最末级页表了
+ * 最末尾的页表项表示的是MemoryRegionSection
+ *
+ * AddressSpaceDispatch中的phys_map域则相当于CR3寄存器,用来最开始的寻址
+ */
 struct PhysPageEntry {
     /* How many bits skip to next level (in units of L2_SIZE). 0 for a leaf. */
+    /*
+     * 被修改的地方:
+     *   - exec.c|366| <<phys_map_node_alloc>> e.skip = leaf ? 0 : 1;
+     *   - exec.c|410| <<phys_page_set_level>> lp->skip = 0;
+     *   - exec.c|490| <<phys_page_compact>> lp->skip = 0;
+     *   - exec.c|492| <<phys_page_compact>> lp->skip += p[valid_ptr].skip;
+     *   - exec.c|3380| <<address_space_dispatch_new>> d->phys_map = (PhysPageEntry) { .ptr = PHYS_MAP_NODE_NIL, .skip = 1 };
+     */
     uint32_t skip : 6;
      /* index into phys_sections (!skip) or phys_map_nodes (skip) */
+    /*
+     * 修改的地方:
+     *   - exec.c|378| <<phys_map_node_alloc>> e.ptr = leaf ? PHYS_SECTION_UNASSIGNED : PHYS_MAP_NODE_NIL;
+     *   - exec.c|411| <<phys_page_set_level>> lp->ptr = phys_map_node_alloc(map, level == 0);
+     *   - exec.c|419| <<phys_page_set_level>> lp->ptr = leaf;
+     *   - exec.c|490| <<phys_page_compact>> lp->ptr = p[valid_ptr].ptr;
+     *
+     * ptr是用来索引d->map.nodes[ptr][]的, 每一个nodes[ptr]是一个PhysPageEntry[P_L2_SIZE]
+     */
     uint32_t ptr : 26;
 };
 
+/* 0x3ffffff */
 #define PHYS_MAP_NODE_NIL (((uint32_t)~0) >> 6)
 
 /* Size of the L2 (and L3, etc) page tables.  */
 #define ADDR_SPACE_BITS 64
 
 #define P_L2_BITS 9
+/* 512 */
 #define P_L2_SIZE (1 << P_L2_BITS)
 
+/* 0x6 */
 #define P_L2_LEVELS (((ADDR_SPACE_BITS - TARGET_PAGE_BITS - 1) / P_L2_BITS) + 1)
 
+/* 定义Node是PhysPageEntry[P_L2_SIZE] */
 typedef PhysPageEntry Node[P_L2_SIZE];
 
 typedef struct PhysPageMap {
     struct rcu_head rcu;
 
+    /*
+     * 只在如下修改:
+     *   - exec.c|1731| <<phys_section_add>> return map->sections_nb++;
+     *   - exec.c|1750| <<phys_sections_free>> MemoryRegionSection *section = &map->sections[--map->sections_nb];
+     *
+     * 当前sections[]数组中元素的个数
+     */
     unsigned sections_nb;
+    /*
+     * 只在如下修改:
+     *   - exec.c|1725| <<phys_section_add>> map->sections_nb_alloc = MAX(map->sections_nb_alloc * 2, 16);
+     */
     unsigned sections_nb_alloc;
+    /*
+     * 只在如下修改:
+     *   - exec.c|336| <<phys_map_node_alloc>> ret = map->nodes_nb++;
+     *
+     * 当前nodes[]数组中元素的个数
+     */
     unsigned nodes_nb;
+    /*
+     * 只在如下修改:
+     *   - exec.c|327| <<phys_map_node_reserve>> map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, alloc_hint);
+     *   - exec.c|331| <<phys_map_node_reserve>> map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, map->nodes_nb + nodes);
+     */
     unsigned nodes_nb_alloc;
+    /*
+     * 分配nodes的地方:
+     *   - exec.c|313| <<phys_map_node_reserve>> map->nodes = g_renew(Node, map->nodes, map->nodes_nb_alloc);
+     */
     Node *nodes;
+    /*
+     * 分配sections的地方:
+     *   - exec.c|1741| <<phys_section_add>> map->sections = g_renew(MemoryRegionSection, map->sections,
+     *                                                               map->sections_nb_alloc);
+     */
     MemoryRegionSection *sections;
 } PhysPageMap;
 
+/*
+ * 为了在虚拟机退出时,能够顺利根据物理地址找到对应的HVA地址,qemu会有一个AddressSpaceDispatch结构,
+ * 用来在AddressSpace中进行位置的找寻,继而完成对IO/MMIO地址的访问.
+ */
 struct AddressSpaceDispatch {
     MemoryRegionSection *mru_section;
     /* This is a multi-level map on the physical address space.
      * The bottom level has pointers to MemoryRegionSections.
      */
+    /*
+     * skip表示需要移动多少步到下一级页表,如果skip为0,说明这是最末级页表了
+     * 最末尾的页表项表示的是MemoryRegionSection
+     *
+     * AddressSpaceDispatch中的phys_map域则相当于CR3寄存器,用来最开始的寻址
+     */
     PhysPageEntry phys_map;
+    /*
+     * 保存了一个GPA->HVA的一个映射,通过多层页表实现,当kvm exit退到qemu之后,通过这个
+     * AddressSpaceDispatch里面的map查找对应的MemoryRegionSection,继而找到对应的主机HVA
+     */
     PhysPageMap map;
 };
 
+/*
+ * TARGET_PAGE_MASK  = 0xfffff000
+ * ~TARGET_PAGE_MASK = 0xfff
+ */
 #define SUBPAGE_IDX(addr) ((addr) & ~TARGET_PAGE_MASK)
 typedef struct subpage_t {
     MemoryRegion iomem;
     FlatView *fv;
     hwaddr base;
+    /*
+     * 在subpage_init()初始化时分配TARGET_PAGE_SIZE * sizeof(uint16_t)
+     * 一共4K个元素 (i386)
+     */
     uint16_t sub_section[];
 } subpage_t;
 
@@ -241,17 +334,37 @@ struct DirtyBitmapSnapshot {
 
 #if !defined(CONFIG_USER_ONLY)
 
+/*
+ * called only by:
+ *   - exec.c|337| <<phys_page_set>> phys_map_node_reserve(&d->map, 3 * P_L2_LEVELS);
+ *
+ * 检查一下PhysPageMap是否还有nodes个Node (map->nodes_nb+nodes小于等于 map->nodes_nb_alloc)
+ * 否则就要提前分配一些
+ */
 static void phys_map_node_reserve(PhysPageMap *map, unsigned nodes)
 {
     static unsigned alloc_hint = 16;
     if (map->nodes_nb + nodes > map->nodes_nb_alloc) {
+        /*
+	 * nodes_nb_alloc只在当前函数修改
+	 */
         map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, alloc_hint);
+	/*
+	 * 如果参数nodes特别大(要求分配的特别多), nodes_nb_alloc会超过16
+	 */
         map->nodes_nb_alloc = MAX(map->nodes_nb_alloc, map->nodes_nb + nodes);
+	/*
+	 * 唯一分配nodes的地方
+	 */
         map->nodes = g_renew(Node, map->nodes, map->nodes_nb_alloc);
         alloc_hint = map->nodes_nb_alloc;
     }
 }
 
+/*
+ * called only by:
+ *   - exec.c|363| <<phys_page_set_level>> lp->ptr = phys_map_node_alloc(map, level == 0);
+ */
 static uint32_t phys_map_node_alloc(PhysPageMap *map, bool leaf)
 {
     unsigned i;
@@ -265,20 +378,52 @@ static uint32_t phys_map_node_alloc(PhysPageMap *map, bool leaf)
     assert(ret != map->nodes_nb_alloc);
 
     e.skip = leaf ? 0 : 1;
+    /*
+     * 最末尾的页表项(level=0, 也就是leaf=true)表示的是MemoryRegionSection
+     */
     e.ptr = leaf ? PHYS_SECTION_UNASSIGNED : PHYS_MAP_NODE_NIL;
     for (i = 0; i < P_L2_SIZE; ++i) {
+        /* 把512个entry都初始化成上面e相同的样子 */
         memcpy(&p[i], &e, sizeof(e));
     }
     return ret;
 }
 
+/*
+ * called by:
+ *   - exec.c|343| <<phys_page_set_level>> phys_page_set_level(map, lp, index, nb, leaf, level - 1);
+ *   - exec.c|368| <<phys_page_set>> phys_page_set_level(&d->map, &d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);
+ *
+ * ---> register_subpage()   ---> phys_page_set() ---> phys_page_set_level()
+ * ---> register_multipage() ---> phys_page_set() ---> phys_page_set_level()
+ *
+ * 如果是从register_multipage()那条路径进来的:
+ *     map: AddressSpaceDispatch的PhysPageMap
+ *     lp: d->phys_map, 理解成cr3
+ *     index: 物理内存页的起始pfn
+ *     nb: 物理内存页的数目
+ *     leaf: section在map->sections[]数组中的index
+ *     level: P_L2_LEVELS - 1 = 5
+ *
+ * 填充页表?
+ */
 static void phys_page_set_level(PhysPageMap *map, PhysPageEntry *lp,
                                 hwaddr *index, hwaddr *nb, uint16_t leaf,
                                 int level)
 {
     PhysPageEntry *p;
+    /*
+     * 这个函数的总入口只能是phys_page_set()
+     * 所以一开始level = 5, step是1往左移动45位
+     */
     hwaddr step = (hwaddr)1 << (level * P_L2_BITS);
 
+    /*
+     * skip表示需要移动多少步到下一级页表,如果skip为0,说明这是最末级页表了
+     * 最末尾的页表项表示的是MemoryRegionSection
+     *
+     * AddressSpaceDispatch中的phys_map域则相当于CR3寄存器,用来最开始的寻址
+     */
     if (lp->skip && lp->ptr == PHYS_MAP_NODE_NIL) {
         lp->ptr = phys_map_node_alloc(map, level == 0);
     }
@@ -298,13 +443,39 @@ static void phys_page_set_level(PhysPageMap *map, PhysPageEntry *lp,
     }
 }
 
+/*
+ * called by:
+ *   - exec.c|1719| <<register_subpage>> phys_page_set(d, base >> TARGET_PAGE_BITS, 1,
+ *                                                     phys_section_add(&d->map, &subsection));
+ *   - exec.c|1747| <<register_multipage>> phys_page_set(d, start_addr >> TARGET_PAGE_BITS, num_pages, section_index);
+ *
+ * 如果是register_multipage()进来的:
+ *     d: FlatView的dispatch (AddressSpaceDispatch)
+ *     index: 物理内存页的起始pfn
+ *     nb: 物理内存页的数目
+ *     leaf: section在map->sections[]数组中的index
+ */
 static void phys_page_set(AddressSpaceDispatch *d,
                           hwaddr index, hwaddr nb,
                           uint16_t leaf)
 {
     /* Wildly overreserve - it doesn't matter much. */
+    /*
+     * 检查一下PhysPageMap是否还有nodes个Node (map->nodes_nb+nodes小于等于 map->nodes_nb_alloc)
+     * 否则就要提前分配一些
+     *
+     * 这里nodes = 3 * P_L2_LEVELS = 18
+     */
     phys_map_node_reserve(&d->map, 3 * P_L2_LEVELS);
 
+    /*
+     * d->map: PhysPageMap
+     * d->phys_map: 理解成cr3
+     * index: 物理内存页的起始pfn
+     * nb: 物理内存页的数目
+     * leaf: section在map->sections[]数组中的index
+     * P_L2_LEVELS - 1: 5
+     */
     phys_page_set_level(&d->map, &d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);
 }
 
@@ -361,6 +532,10 @@ static void phys_page_compact(PhysPageEntry *lp, Node *nodes)
     }
 }
 
+/*
+ * called only by:
+ *   - memory.c|1087| <<generate_memory_topology>> address_space_dispatch_compact(view->dispatch);
+ */
 void address_space_dispatch_compact(AddressSpaceDispatch *d)
 {
     if (d->phys_map.skip) {
@@ -368,6 +543,9 @@ void address_space_dispatch_compact(AddressSpaceDispatch *d)
     }
 }
 
+/*
+ * 检查一下基于AddressSpace的addr是否在section的地址范围中
+ */
 static inline bool section_covers_addr(const MemoryRegionSection *section,
                                        hwaddr addr)
 {
@@ -379,22 +557,61 @@ static inline bool section_covers_addr(const MemoryRegionSection *section,
                              int128_getlo(section->size), addr);
 }
 
+/*
+ * called by:
+ *   - exec.c|430| <<address_space_lookup_region>> section = phys_page_find(d, addr);
+ *   - exec.c|1622| <<register_subpage>> MemoryRegionSection *existing = phys_page_find(d, base);
+ *
+ * 根据物理地址, 在AddressSpaceDispatch中寻找返回MemoryRegionSection (比如d->map.sections[lp.ptr])
+ * 中间经历了一些看不懂的类似页表转换
+ * 最末尾的页表项表示的是MemoryRegionSection
+ */
 static MemoryRegionSection *phys_page_find(AddressSpaceDispatch *d, hwaddr addr)
 {
+    /*
+     * skip表示需要移动多少步到下一级页表,如果skip为0,说明这是最末级页表了
+     * 最末尾的页表项表示的是MemoryRegionSection
+     *
+     * AddressSpaceDispatch中的phys_map域则相当于CR3寄存器,用来最开始的寻址
+     */
     PhysPageEntry lp = d->phys_map, *p;
+    /* 一个Node相当于PhysPageEntry[P_L2_SIZE] */
     Node *nodes = d->map.nodes;
     MemoryRegionSection *sections = d->map.sections;
     hwaddr index = addr >> TARGET_PAGE_BITS;
     int i;
 
+    /*
+     * P_L2_LEVELS是0x6
+     *
+     * 一开始lp是d->phys_map, 相当于cr3
+     */
     for (i = P_L2_LEVELS; lp.skip && (i -= lp.skip) >= 0;) {
         if (lp.ptr == PHYS_MAP_NODE_NIL) {
+            /* sections来自d->map.sections */
             return &sections[PHYS_SECTION_UNASSIGNED];
         }
+	/*
+	 * p是一个PhysPageEntry指针
+	 *
+	 * nodes[lp.ptr]本身是一个数组 (这样nodes就是二维数组了)
+	 */
         p = nodes[lp.ptr];
+	/*
+	 * 这里用p[]索引, 说明上一行的p是一个数组, nodes是二维数组!
+	 *
+	 * index在这个函数没变过就是物理地址往右移12位
+	 * 根据level(i)决定应该往右移几个9bit, 最后就是一个9bit的数(最大512), 用来索引p[]
+	 */
         lp = p[(index >> (i * P_L2_BITS)) & (P_L2_SIZE - 1)];
     }
 
+    /*
+     * section_covers_addr()表示需要移动多少步到下一级页表,如果skip为0,说明这是最末级页表了
+     * 最末尾的页表项表示的是MemoryRegionSection
+     *
+     * 检查一下基于AddressSpace的addr是否在section的地址范围中
+     */
     if (section_covers_addr(&sections[lp.ptr], addr)) {
         return &sections[lp.ptr];
     } else {
@@ -418,6 +635,10 @@ static MemoryRegionSection *address_space_lookup_region(AddressSpaceDispatch *d,
 
     if (!section || section == &d->map.sections[PHYS_SECTION_UNASSIGNED] ||
         !section_covers_addr(section, addr)) {
+        /*
+	 * 根据物理地址, 在AddressSpaceDispatch中寻找返回MemoryRegionSection (比如d->map.sections[lp.ptr])
+	 * 中间经历了一些看不懂的类似页表转换
+	 */
         section = phys_page_find(d, addr);
         atomic_set(&d->mru_section, section);
     }
@@ -1305,15 +1526,31 @@ void cpu_abort(CPUState *cpu, const char *fmt, ...)
 
 #if !defined(CONFIG_USER_ONLY)
 /* Called from RCU critical section */
+/*
+ * called by:
+ *   - exec.c|1358| <<tlb_reset_dirty_range_all>> block = qemu_get_ram_block(start);
+ *   - exec.c|1359| <<tlb_reset_dirty_range_all>> assert(block == qemu_get_ram_block(end - 1));
+ *   - exec.c|2510| <<qemu_map_ram_ptr>> block = qemu_get_ram_block(addr);
+ *   - exec.c|2542| <<qemu_ram_ptr_length>> block = qemu_get_ram_block(addr);
+ *   - exec.c|2599| <<qemu_ram_block_from_host>> block = qemu_get_ram_block(ram_addr);
+ *
+ * 根据给定的模拟的物理地址 返回对应的RAMBlock
+ */
 static RAMBlock *qemu_get_ram_block(ram_addr_t addr)
 {
     RAMBlock *block;
 
+    /*
+     * mru: most recently used
+     */
     block = atomic_rcu_read(&ram_list.mru_block);
     if (block && addr - block->offset < block->max_length) {
         return block;
     }
     RAMBLOCK_FOREACH(block) {
+        /*
+	 * offset是RAMBlock在内存中代表的基地址
+	 */
         if (addr - block->offset < block->max_length) {
             goto found;
         }
@@ -1535,6 +1772,10 @@ void phys_mem_set_alloc(void *(*alloc)(size_t, uint64_t *align, bool shared))
     phys_mem_alloc = alloc;
 }
 
+/*
+ * 使map->sections[map->sections_nb] = *section;
+ * 然后增加map->sections_nb并返回增加前的map->sections_nb
+ */
 static uint16_t phys_section_add(PhysPageMap *map,
                                  MemoryRegionSection *section)
 {
@@ -1544,13 +1785,21 @@ static uint16_t phys_section_add(PhysPageMap *map,
      */
     assert(map->sections_nb < TARGET_PAGE_SIZE);
 
+    /* 如果空间不够了重新分配 */
     if (map->sections_nb == map->sections_nb_alloc) {
         map->sections_nb_alloc = MAX(map->sections_nb_alloc * 2, 16);
+	/*
+	 * g_renew(struct_type, mem, n_structs):
+	 * Reallocates the memory pointed to by mem, so that it now has
+	 * space for n_structs elements of type struct_type. It returns
+	 * the new address of the memory, which may have been moved.
+	 */
         map->sections = g_renew(MemoryRegionSection, map->sections,
                                 map->sections_nb_alloc);
     }
     map->sections[map->sections_nb] = *section;
     memory_region_ref(section->mr);
+    /* 先确定返回值是map->sections_nb然后在加加 */
     return map->sections_nb++;
 }
 
@@ -1577,22 +1826,37 @@ static void phys_sections_free(PhysPageMap *map)
     g_free(map->nodes);
 }
 
+/*
+ * 被generate_memory_topology()-->flatview_add_to_dispatch()在三处调用
+ */
 static void register_subpage(FlatView *fv, MemoryRegionSection *section)
 {
     AddressSpaceDispatch *d = flatview_to_dispatch(fv);
     subpage_t *subpage;
+    /* TARGET_PAGE_MASK = 0xfffff000 */
     hwaddr base = section->offset_within_address_space
         & TARGET_PAGE_MASK;
+    /*
+     * 根据物理地址, 在AddressSpaceDispatch中寻找返回MemoryRegionSection (比如d->map.sections[lp.ptr])
+     * 中间经历了一些看不懂的类似页表转换
+     */
     MemoryRegionSection *existing = phys_page_find(d, base);
+    /* 初始化subsection的size是4K */
     MemoryRegionSection subsection = {
         .offset_within_address_space = base,
-        .size = int128_make64(TARGET_PAGE_SIZE),
+        .size = int128_make64(TARGET_PAGE_SIZE), // TARGET_PAGE_SIZE在i386是4K
     };
     hwaddr start, end;
 
     assert(existing->mr->subpage || existing->mr == &io_mem_unassigned);
 
     if (!(existing->mr->subpage)) {
+        /*
+	 * 分配初始化一个subpage_t (后面跟着TARGET_PAGE_SIZE * sizeof(uint16_t)作为sub_section[]数组)
+	 * subpage_t的base设置成参数base
+	 * 用memory_region_init_io()初始化subpage_t的iomem (MemoryRegion)
+	 * 把sub_section的4096个uint16_t全部设置成PHYS_SECTION_UNASSIGNED
+	 */
         subpage = subpage_init(fv, base);
         subsection.fv = fv;
         subsection.mr = &subpage->iomem;
@@ -1608,24 +1872,53 @@ static void register_subpage(FlatView *fv, MemoryRegionSection *section)
 }
 
 
+/*
+ * called only by:
+ *   - generate_memory_topology()-->flatview_add_to_dispatch()
+ */
 static void register_multipage(FlatView *fv,
                                MemoryRegionSection *section)
 {
     AddressSpaceDispatch *d = flatview_to_dispatch(fv);
     hwaddr start_addr = section->offset_within_address_space;
+    /*
+     * 使map->sections[map->sections_nb] = *section;
+     * 然后增加map->sections_nb并返回增加前的map->sections_nb
+     */
     uint16_t section_index = phys_section_add(&d->map, section);
     uint64_t num_pages = int128_get64(int128_rshift(section->size,
                                                     TARGET_PAGE_BITS));
 
     assert(num_pages);
+    /*
+     * d: FlatView的dispatch (AddressSpaceDispatch)
+     * start_addr >> TARGET_PAGE_BITS : 物理内存页的起始pfn
+     * num_pages: 物理内存页的数目
+     * section_index: section在map->sections[]数组中的index 
+     */
     phys_page_set(d, start_addr >> TARGET_PAGE_BITS, num_pages, section_index);
 }
 
+/*
+ * called only by:
+ *   - memory.c|795| <<generate_memory_topology>> flatview_add_to_dispatch(view, &mrs);
+ *
+ * register_subpage()和register_multipage()都只被flatview_add_to_dispatch()调用!
+ *
+ * 被调用的时候是根据每个view->ranges[i]调用一下
+ *
+ * 把一个MemoryRegionSection在FlatView的页表中填充一下!
+ */
 void flatview_add_to_dispatch(FlatView *fv, MemoryRegionSection *section)
 {
+    /* now和remain都是做的拷贝 */
     MemoryRegionSection now = *section, remain = *section;
     Int128 page_size = int128_make64(TARGET_PAGE_SIZE);
 
+    /*
+     * TARGET_PAGE_MASK  = 0xfffff000
+     * ~TARGET_PAGE_MASK = 0xfff
+     */
     if (now.offset_within_address_space & ~TARGET_PAGE_MASK) {
         uint64_t left = TARGET_PAGE_ALIGN(now.offset_within_address_space)
                        - now.offset_within_address_space;
@@ -1640,6 +1933,9 @@ void flatview_add_to_dispatch(FlatView *fv, MemoryRegionSection *section)
         remain.offset_within_address_space += int128_get64(now.size);
         remain.offset_within_region += int128_get64(now.size);
         now = remain;
+	/*
+	 * page_size就是4096=TARGET_PAGE_SIZE
+	 */
         if (int128_lt(remain.size, page_size)) {
             register_subpage(fv, &now);
         } else if (remain.offset_within_address_space & ~TARGET_PAGE_MASK) {
@@ -1909,6 +2205,10 @@ static void *file_ram_alloc(RAMBlock *block,
  * dirty bitmaps.
  * Called with the ramlist lock held.
  */
+/*
+ * called only by:
+ *   - exec.c|2212| <<ram_block_add>> new_block->offset = find_ram_offset(new_block->max_length);
+ */
 static ram_addr_t find_ram_offset(ram_addr_t size)
 {
     RAMBlock *block, *next_block;
@@ -2179,6 +2479,29 @@ static void dirty_memory_extend(ram_addr_t old_ram_size,
     }
 }
 
+/*
+ * 一个例子:
+ * (gdb) bt
+ * #0  ram_block_add (new_block=0x5555568fb9d0, errp=0x7fffffffdd58, shared=false) at /home/zhang/kvm/qemu-3.0.0/exec.c:2183
+ * #1  0x0000555555801ea9 in qemu_ram_alloc_internal (size=2097152000, max_size=2097152000, resized=0x0, host=0x0, resizeable=false, share=false, mr=0x5555568fb440, errp=0x555556751598 <error_fatal>)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:2375
+ * #2  0x0000555555801f84 in qemu_ram_alloc (size=2097152000, share=false, mr=0x5555568fb440, errp=0x555556751598 <error_fatal>) at /home/zhang/kvm/qemu-3.0.0/exec.c:2394
+ * #3  0x0000555555867b1a in memory_region_init_ram_shared_nomigrate (mr=0x5555568fb440, owner=0x0, name=0x555555ea76a7 "pc.ram", size=2097152000, share=false, errp=0x555556751598 <error_fatal>)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:1525
+ * #4  0x0000555555867aa3 in memory_region_init_ram_nomigrate (mr=0x5555568fb440, owner=0x0, name=0x555555ea76a7 "pc.ram", size=2097152000, errp=0x555556751598 <error_fatal>)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:1511
+ * #5  0x000055555585f53a in allocate_system_memory_nonnuma (mr=0x5555568fb440, owner=0x0, name=0x555555ea76a7 "pc.ram", ram_size=2097152000) at /home/zhang/kvm/qemu-3.0.0/numa.c:502
+ * #6  0x000055555585f5a9 in memory_region_allocate_system_memory (mr=0x5555568fb440, owner=0x0, name=0x555555ea76a7 "pc.ram", ram_size=2097152000) at /home/zhang/kvm/qemu-3.0.0/numa.c:515
+ * #7  0x0000555555918fdb in pc_memory_init (pcms=0x55555684f780, system_memory=0x555556850d40, rom_memory=0x5555568faff0, ram_memory=0x7fffffffdfc8) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1346
+ * #8  0x000055555591ceb7 in pc_init1 (machine=0x55555684f780, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:181
+ * #9  0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f780) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #10 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f780) at hw/core/machine.c:830
+ * #11 0x00005555559dfb8f in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4516
+ *
+ * called by:
+ *   - exec.c|2353| <<qemu_ram_alloc_from_fd>> ram_block_add(new_block, &local_err, share);
+ *   - exec.c|2418| <<qemu_ram_alloc_internal>> ram_block_add(new_block, &local_err, share);
+ */
 static void ram_block_add(RAMBlock *new_block, Error **errp, bool shared)
 {
     RAMBlock *block;
@@ -2344,6 +2667,12 @@ RAMBlock *qemu_ram_alloc_from_file(ram_addr_t size, MemoryRegion *mr,
 }
 #endif
 
+/*
+ * called by:
+ *   - exec.c|2430| <<qemu_ram_alloc_from_ptr>> return qemu_ram_alloc_internal(size, size, NULL, host, false,
+ *   - exec.c|2437| <<qemu_ram_alloc>> return qemu_ram_alloc_internal(size, size, NULL, NULL, false,
+ *   - exec.c|2447| <<qemu_ram_alloc_resizeable>> return qemu_ram_alloc_internal(size, maxsz, resized, NULL, true,
+ */
 static
 RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                   void (*resized)(const char*,
@@ -2388,6 +2717,12 @@ RAMBlock *qemu_ram_alloc_from_ptr(ram_addr_t size, void *host,
                                    false, mr, errp);
 }
 
+/*
+ * called by:
+ *   - memory.c|1647| <<memory_region_init_ram_shared_nomigrate>> mr->ram_block = qemu_ram_alloc(size, share, mr, errp);
+ *   - memory.c|1758| <<memory_region_init_rom_nomigrate>> mr->ram_block = qemu_ram_alloc(size, false, mr, errp);
+ *   - memory.c|1777| <<memory_region_init_rom_device_nomigrate>> mr->ram_block = qemu_ram_alloc(size, false, mr, errp);
+ */
 RAMBlock *qemu_ram_alloc(ram_addr_t size, bool share,
                          MemoryRegion *mr, Error **errp)
 {
@@ -2935,6 +3270,13 @@ static const MemoryRegionOps subpage_ops = {
     .endianness = DEVICE_NATIVE_ENDIAN,
 };
 
+/*
+ * called by:
+ *   - exec.c|1668| <<register_subpage>> subpage_register(subpage, start, end,
+ *   - exec.c|3084| <<subpage_init>> subpage_register(mmio, 0, TARGET_PAGE_SIZE-1, PHYS_SECTION_UNASSIGNED);
+ *
+ * 如果是从subpage_register()进来的, 把参数mmio(subpage_t)的sub_section的4096个uint16_t全部设置成PHYS_SECTION_UNASSIGNED
+ */
 static int subpage_register (subpage_t *mmio, uint32_t start, uint32_t end,
                              uint16_t section)
 {
@@ -2942,26 +3284,57 @@ static int subpage_register (subpage_t *mmio, uint32_t start, uint32_t end,
 
     if (start >= TARGET_PAGE_SIZE || end >= TARGET_PAGE_SIZE)
         return -1;
+    /* 把start和0xfff相and */
     idx = SUBPAGE_IDX(start);
     eidx = SUBPAGE_IDX(end);
+
+    /*
+     * 如果是从subpage_register()进来的, 此时:
+     *   idx  = 0x0
+     *   eidx = 0xfff
+     */
+
 #if defined(DEBUG_SUBPAGE)
     printf("%s: %p start %08x end %08x idx %08x eidx %08x section %d\n",
            __func__, mmio, start, end, idx, eidx, section);
 #endif
     for (; idx <= eidx; idx++) {
+        /*
+	 * 如果是从subpage_register()进来的, 此时section是PHYS_SECTION_UNASSIGNED
+	 */
         mmio->sub_section[idx] = section;
     }
 
     return 0;
 }
 
+/*
+ * called only by register_subpage()
+ *
+ * 分配初始化一个subpage_t (后面跟着TARGET_PAGE_SIZE * sizeof(uint16_t)作为sub_section[]数组)
+ * subpage_t的base设置成参数base
+ * 用memory_region_init_io()初始化subpage_t的iomem (MemoryRegion)
+ * 把sub_section的4096个uint16_t全部设置成PHYS_SECTION_UNASSIGNED
+ */
 static subpage_t *subpage_init(FlatView *fv, hwaddr base)
 {
     subpage_t *mmio;
 
+    /*
+     * TARGET_PAGE_SIZE是4K
+     *
+     * 除了subpage_t, 还要额外分配4K个uint16_t
+     */
     mmio = g_malloc0(sizeof(subpage_t) + TARGET_PAGE_SIZE * sizeof(uint16_t));
     mmio->fv = fv;
     mmio->base = base;
+    /*
+     * 初始化MemoryRegion,比如:
+     *     根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     *     MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+     *     然后简单初始化MemoryRegion的各个field
+     * 设置mr的ops, opaqueue和terminates=true
+     */
     memory_region_init_io(&mmio->iomem, NULL, &subpage_ops, mmio,
                           NULL, TARGET_PAGE_SIZE);
     mmio->iomem.subpage = true;
@@ -2969,6 +3342,13 @@ static subpage_t *subpage_init(FlatView *fv, hwaddr base)
     printf("%s: %p base " TARGET_FMT_plx " len %08x\n", __func__,
            mmio, base, TARGET_PAGE_SIZE);
 #endif
+    /*
+     * mmio是subpage_t
+     * TARGET_PAGE_SIZE是4K
+     * PHYS_SECTION_UNASSIGNED是0
+     *
+     * 把参数mmio(subpage_t)的sub_section的4096个uint16_t全部设置成PHYS_SECTION_UNASSIGNED
+     */
     subpage_register(mmio, 0, TARGET_PAGE_SIZE-1, PHYS_SECTION_UNASSIGNED);
 
     return mmio;
@@ -2985,6 +3365,10 @@ static uint16_t dummy_section(PhysPageMap *map, FlatView *fv, MemoryRegion *mr)
         .size = int128_2_64(),
     };
 
+    /*
+     * 使map->sections[map->sections_nb] = *section;
+     * 然后增加map->sections_nb
+     */
     return phys_section_add(map, &section);
 }
 
@@ -3049,8 +3433,12 @@ static void io_mem_init(void)
                           NULL, UINT64_MAX);
 }
 
+/*
+ * 分配一个AddressSpaceDispatch并简单初始化一些dummy section
+ */
 AddressSpaceDispatch *address_space_dispatch_new(FlatView *fv)
 {
+    /* 分配一个AddressSpaceDispatch */
     AddressSpaceDispatch *d = g_new0(AddressSpaceDispatch, 1);
     uint16_t n;
 
@@ -3093,17 +3481,38 @@ static void tcg_commit(MemoryListener *listener)
     tlb_flush(cpuas->cpu);
 }
 
+/*
+ * called only by (只被vl.c的main()调用----->cpu_exec_init_all()):
+ *   - exec.c|3534| <<cpu_exec_init_all>> memory_map_init();
+ */
 static void memory_map_init(void)
 {
+    /*
+     * system_memory作为address_space_memory的根MemoryRegion,
+     * 大小涵盖了整个64位空间的大小, 这是一个pure contaner,并
+     * 不会分配空间的
+     */
     system_memory = g_malloc(sizeof(*system_memory));
 
     memory_region_init(system_memory, NULL, "system", UINT64_MAX);
     address_space_init(&address_space_memory, system_memory, "memory");
 
+    /*
+     * system_io作为address_space_io的根MemoryRegion,大小为65536,
+     * 也就是平时的io port空间
+     */
     system_io = g_malloc(sizeof(*system_io));
     memory_region_init_io(system_io, NULL, &unassigned_io_ops, NULL, "io",
                           65536);
     address_space_init(&address_space_io, system_io, "I/O");
+
+    /*
+     * 在随后的cpu初始化之中,还会初始化多个AddressSpace,
+     * 这些很多都是disabled的,对虚拟机意义不大
+     *
+     * 重点在随后的main->pc_init_v2_8->pc_init1->pc_memory_init中,这
+     * 里面是分配系统ram,也是第一次真正为虚拟机分配物理内存.
+     */
 }
 
 MemoryRegion *get_system_memory(void)
@@ -3519,6 +3928,9 @@ void cpu_register_map_client(QEMUBH *bh)
     qemu_mutex_unlock(&map_client_list_lock);
 }
 
+/*
+ * 只被vl.c的main()调用
+ */
 void cpu_exec_init_all(void)
 {
     qemu_mutex_init(&ram_list.mutex);
diff --git a/hmp.c b/hmp.c
index 2aafb50..2a2f4d0 100644
--- a/hmp.c
+++ b/hmp.c
@@ -2548,6 +2548,13 @@ void hmp_info_iothreads(Monitor *mon, const QDict *qdict)
     qapi_free_IOThreadInfoList(info_list);
 }
 
+/*
+ * (qemu) qom-list /
+ * machine (child<pc-i440fx-3.0-machine>)
+ * type (string)
+ * chardevs (child<container>)
+ * backend (child<container>)
+ */
 void hmp_qom_list(Monitor *mon, const QDict *qdict)
 {
     const char *path = qdict_get_try_str(qdict, "path");
diff --git a/hw/block/nvme.c b/hw/block/nvme.c
index 5e508ab..2845394 100644
--- a/hw/block/nvme.c
+++ b/hw/block/nvme.c
@@ -1041,6 +1041,24 @@ static void nvme_write_bar(NvmeCtrl *n, hwaddr offset, uint64_t data,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  nvme_mmio_read (opaque=0x5555579a9f90, addr=0, size=4) at hw/block/nvme.c:1045
+ * #1  0x0000555555864736 in memory_region_read_accessor (mr=0x5555579aa870, addr=0, value=0x7fffec8b0858, size=4, shift=0, mask=4294967295, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:436
+ * #2  0x0000555555864d45 in access_with_adjusted_size (addr=0, value=0x7fffec8b0858, size=4, access_size_min=2, access_size_max=8, access_fn=0x5555558646f8 <memory_region_read_accessor>, mr=0x5555579aa870, 
+ *     attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #3  0x00005555558675d1 in memory_region_dispatch_read1 (mr=0x5555579aa870, addr=0, pval=0x7fffec8b0858, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1392
+ * #4  0x00005555558676dc in memory_region_dispatch_read (mr=0x5555579aa870, addr=0, pval=0x7fffec8b0858, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1423
+ * #5  0x0000555555803bbc in flatview_read_continue (fv=0x7fffe024d810, addr=4273930240, attrs=..., buf=0x7ffff7fef028 "", len=4, addr1=0, l=4, mr=0x5555579aa870) at /home/zhang/kvm/qemu-3.0.0/exec.c:3316
+ * #6  0x0000555555803d14 in flatview_read (fv=0x7fffe024d810, addr=4273930240, attrs=..., buf=0x7ffff7fef028 "", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3354
+ * #7  0x0000555555803d88 in address_space_read_full (as=0x555556721a80 <address_space_memory>, addr=4273930240, attrs=..., buf=0x7ffff7fef028 "", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3367
+ * #8  0x0000555555803e5f in address_space_rw (as=0x555556721a80 <address_space_memory>, addr=4273930240, attrs=..., buf=0x7ffff7fef028 "", len=4, is_write=false) at /home/zhang/kvm/qemu-3.0.0/exec.c:3397
+ * #9  0x0000555555882b7d in kvm_cpu_exec (cpu=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1979
+ * #10 0x0000555555849eac in qemu_kvm_cpu_thread_fn (arg=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #11 0x0000555555d92dd7 in qemu_thread_start (args=0x5555568abcb0) at util/qemu-thread-posix.c:504
+ * #12 0x00007ffff4ca06ba in start_thread (arg=0x7fffec8b1700) at pthread_create.c:333
+ * #13 0x00007ffff49d641d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 static uint64_t nvme_mmio_read(void *opaque, hwaddr addr, unsigned size)
 {
     NvmeCtrl *n = (NvmeCtrl *)opaque;
@@ -1150,6 +1168,29 @@ static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  nvme_mmio_write (opaque=0x555557720c30, addr=40, data=3145584640, size=4) at hw/block/nvme.c:1156
+ * #1  0x000055555583317e in memory_region_write_accessor (mr=0x555557721510, addr=40, value=0x7fffec8be7e8, size=4, shift=0, mask=4294967295, attrs=...)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #2  0x0000555555833396 in access_with_adjusted_size (addr=40, value=0x7fffec8be7e8, size=4, access_size_min=2, access_size_max=8, 
+ *     access_fn=0x555555833094 <memory_region_write_accessor>, mr=0x555557721510, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #3  0x0000555555835fbe in memory_region_dispatch_write (mr=0x555557721510, addr=40, data=3145584640, size=4, attrs=...)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #4  0x00005555557d1ff8 in flatview_write_continue (fv=0x7fffe009f3a0, addr=4273930280, attrs=..., buf=0x7ffff7fef028 "", len=4, addr1=40, l=4, 
+ *     mr=0x555557721510) at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #5  0x00005555557d2142 in flatview_write (fv=0x7fffe009f3a0, addr=4273930280, attrs=..., buf=0x7ffff7fef028 "", len=4)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #6  0x00005555557d2448 in address_space_write (as=0x555556498b40 <address_space_memory>, addr=4273930280, attrs=..., buf=0x7ffff7fef028 "", len=4)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #7  0x00005555557d2499 in address_space_rw (as=0x555556498b40 <address_space_memory>, addr=4273930280, attrs=..., buf=0x7ffff7fef028 "", len=4, 
+ *     is_write=true) at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #8  0x00005555558511ce in kvm_cpu_exec (cpu=0x555556600e30) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1979
+ * #9  0x0000555555818505 in qemu_kvm_cpu_thread_fn (arg=0x555556600e30) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #10 0x0000555555d54975 in qemu_thread_start (args=0x5555566230b0) at util/qemu-thread-posix.c:504
+ * #11 0x00007ffff55126ba in start_thread (arg=0x7fffec8bf700) at pthread_create.c:333
+ * #12 0x00007ffff524841d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 static void nvme_mmio_write(void *opaque, hwaddr addr, uint64_t data,
     unsigned size)
 {
@@ -1197,6 +1238,24 @@ static const MemoryRegionOps nvme_cmb_ops = {
     },
 };
 
+/*
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ *
+ *
+ * called by:
+ *   - hw/pci/pci.c|2087| <<pci_qdev_realize>> pc->realize(pci_dev, &local_err);
+ */
 static void nvme_realize(PCIDevice *pci_dev, Error **errp)
 {
     NvmeCtrl *n = NVME(pci_dev);
@@ -1242,6 +1301,9 @@ static void nvme_realize(PCIDevice *pci_dev, Error **errp)
     n->sq = g_new0(NvmeSQueue *, n->num_queues);
     n->cq = g_new0(NvmeCQueue *, n->num_queues);
 
+    /*
+     * 里面n->iomem->ram是false!!!
+     */
     memory_region_init_io(&n->iomem, OBJECT(n), &nvme_mmio_ops, n,
                           "nvme", n->reg_size);
     pci_register_bar(&n->parent_obj, 0,
@@ -1339,6 +1401,9 @@ static void nvme_exit(PCIDevice *pci_dev)
     msix_uninit_exclusive_bar(pci_dev);
 }
 
+/*
+ * 猜测props是用device_initfn()
+ */
 static Property nvme_props[] = {
     DEFINE_BLOCK_PROPERTIES(NvmeCtrl, conf),
     DEFINE_PROP_STRING("serial", NvmeCtrl, serial),
@@ -1352,11 +1417,32 @@ static const VMStateDescription nvme_vmstate = {
     .unmigratable = 1,
 };
 
+/*
+ * TypeInfo nvme_info.class_init = nvme_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ *
+ * (gdb) bt
+ * #0  nvme_class_init (oc=0x5555567d1690, data=0x0) at hw/block/nvme.c:1357
+ * #1  0x0000555555c5c5cf in type_initialize (ti=0x555556794080) at qom/object.c:342
+ * #2  0x0000555555c5d93f in object_class_foreach_tramp (key=0x555556771ba0, value=0x555556794080, opaque=0x7fffffffe040) at qom/object.c:867
+ * #3  0x00007ffff5616340 in g_hash_table_foreach () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #4  0x0000555555c5da1e in object_class_foreach (fn=0x555555c5db6f <object_class_get_list_tramp>, implements_type=0x555555ebd4f6 "machine", include_abstract=false, opaque=0x7fffffffe090) at qom/object.c:889
+ * #5  0x0000555555c5dbed in object_class_get_list (implements_type=0x555555ebd4f6 "machine", include_abstract=false) at qom/object.c:943
+ * #6  0x00005555559d7a68 in find_default_machine () at vl.c:1417
+ * #7  0x00005555559db957 in select_machine () at vl.c:2669
+ * #8  0x00005555559de882 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:3988
+ */
 static void nvme_class_init(ObjectClass *oc, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(oc);
     PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);
 
+    /*
+     * called by:
+     *   - hw/pci/pci.c|2087| <<pci_qdev_realize>> pc->realize(pci_dev, &local_err);
+     */
     pc->realize = nvme_realize;
     pc->exit = nvme_exit;
     pc->class_id = PCI_CLASS_STORAGE_EXPRESS;
@@ -1370,6 +1456,23 @@ static void nvme_class_init(ObjectClass *oc, void *data)
     dc->vmsd = &nvme_vmstate;
 }
 
+/*
+ * TypeInfo nvme_info.instance_init = nvme_instance_init()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ *
+ * (gdb) bt
+ * #0  nvme_instance_init (obj=0x5555579a9f20) at hw/block/nvme.c:1375
+ * #1  0x0000555555c5c635 in object_init_with_type (obj=0x5555579a9f20, ti=0x555556794080) at qom/object.c:353
+ * #2  0x0000555555c5c7f8 in object_initialize_with_type (data=0x5555579a9f20, size=7248, type=0x555556794080) at qom/object.c:384
+ * #3  0x0000555555c5ce4c in object_new_with_type (type=0x555556794080) at qom/object.c:546
+ * #4  0x0000555555c5ce89 in object_new (typename=0x5555567bde50 "nvme") at qom/object.c:556
+ * #5  0x00005555559d251c in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:608
+ * #6  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #7  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #8  0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 static void nvme_instance_init(Object *obj)
 {
     NvmeCtrl *s = NVME(obj);
@@ -1393,7 +1496,12 @@ static const TypeInfo nvme_info = {
 
 static void nvme_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&nvme_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(nvme_register_types)
diff --git a/hw/core/bus.c b/hw/core/bus.c
index 4651f24..8f3d457 100644
--- a/hw/core/bus.c
+++ b/hw/core/bus.c
@@ -40,6 +40,12 @@ void qbus_set_bus_hotplug_handler(BusState *bus, Error **errp)
     qbus_set_hotplug_handler_internal(bus, OBJECT(bus), errp);
 }
 
+/*
+ * x86会用到的:
+ *   - hw/core/qdev.c|202| <<device_listener_register>> qbus_walk_children(sysbus_get_default(), NULL, NULL, device_listener_add,
+ *   - hw/core/qdev.c|276| <<qbus_reset_all>> qbus_walk_children(bus, NULL, NULL, qdev_reset_one, qbus_reset_one, NULL);
+ *   - hw/core/qdev.c|559| <<qdev_walk_children>> err = qbus_walk_children(bus, pre_devfn, pre_busfn,
+ */
 int qbus_walk_children(BusState *bus,
                        qdev_walkerfn *pre_devfn, qbus_walkerfn *pre_busfn,
                        qdev_walkerfn *post_devfn, qbus_walkerfn *post_busfn,
@@ -74,6 +80,11 @@ int qbus_walk_children(BusState *bus,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/core/bus.c|136| <<qbus_create_inplace>> qbus_realize(bus, parent, name);
+ *   - hw/core/bus.c|144| <<qbus_create>> qbus_realize(bus, parent, name);
+ */
 static void qbus_realize(BusState *bus, DeviceState *parent, const char *name)
 {
     const char *typename = object_get_typename(OBJECT(bus));
@@ -136,10 +147,27 @@ void qbus_create_inplace(void *bus, size_t size, const char *typename,
     qbus_realize(bus, parent, name);
 }
 
+/*
+ * called by:
+ *   - hw/i2c/core.c|59| <<i2c_init_bus>> bus = I2C_BUS(qbus_create(TYPE_I2C_BUS, parent, name));
+ *   - hw/isa/isa-bus.c|66| <<isa_bus_new>> isabus = ISA_BUS(qbus_create(TYPE_ISA_BUS, dev, NULL));
+ *   - hw/misc/auxbus.c|69| <<aux_init_bus>> bus = AUX_BUS(qbus_create(TYPE_AUX_BUS, parent, name));
+ *   - hw/pci/pci.c|410| <<pci_root_bus_new>> bus = PCI_BUS(qbus_create(typename, parent, name));
+ *   - hw/ppc/spapr_vio.c|558| <<spapr_vio_bus_init>> qbus = qbus_create(TYPE_SPAPR_VIO_BUS, dev, "spapr-vio");
+ *   - hw/s390x/css-bridge.c|107| <<virtual_css_bus_init>> bus = qbus_create(TYPE_VIRTUAL_CSS_BUS, dev, "virtual-css");
+ *   - hw/s390x/s390-pci-bus.c|714| <<s390_pcihost_init>> s->bus = S390_PCI_BUS(qbus_create(TYPE_S390_PCI_BUS, DEVICE(s), NULL));
+ *   - hw/ssi/ssi.c|106| <<ssi_create_bus>> bus = qbus_create(TYPE_SSI_BUS, parent, name);
+ *   - hw/xen/xen_backend.c|700| <<xen_be_init>> xen_sysbus = qbus_create(TYPE_XENSYSBUS, DEVICE(xen_sysdev), "xen-sysbus");
+ */
 BusState *qbus_create(const char *typename, DeviceState *parent, const char *name)
 {
     BusState *bus;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     bus = BUS(object_new(typename));
     qbus_realize(bus, parent, name);
 
@@ -188,6 +216,9 @@ static void bus_set_realized(Object *obj, bool value, Error **errp)
     bus->realized = value;
 }
 
+/*
+ * TypeInfo bus_info.instance_init = qbus_initfn()
+ */
 static void qbus_initfn(Object *obj)
 {
     BusState *bus = BUS(obj);
@@ -208,14 +239,24 @@ static char *default_bus_get_fw_dev_path(DeviceState *dev)
     return g_strdup(object_get_typename(OBJECT(dev)));
 }
 
+/*
+ * TypeInfo bus_info.class_init = bus_class_init()
+ */
 static void bus_class_init(ObjectClass *class, void *data)
 {
     BusClass *bc = BUS_CLASS(class);
 
+    /*
+     * Called when an object is being removed from the QOM composition tree.
+     * The function should remove any backlinks from children objects to @obj.
+     */
     class->unparent = bus_unparent;
     bc->get_fw_dev_path = default_bus_get_fw_dev_path;
 }
 
+/*
+ * TypeInfo bus_info.instance_finalize = qbus_finalize()
+ */
 static void qbus_finalize(Object *obj)
 {
     BusState *bus = BUS(obj);
@@ -229,14 +270,35 @@ static const TypeInfo bus_info = {
     .instance_size = sizeof(BusState),
     .abstract = true,
     .class_size = sizeof(BusClass),
+    /*
+     * called only by:
+     *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+     */
     .instance_init = qbus_initfn,
+    /*
+     * called only by:
+     *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+     */
     .instance_finalize = qbus_finalize,
+    /*
+     * called only by:
+     *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+     */
     .class_init = bus_class_init,
 };
 
 static void bus_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&bus_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(bus_register_types)
diff --git a/hw/core/machine.c b/hw/core/machine.c
index a9aeb22..6129d45 100644
--- a/hw/core/machine.c
+++ b/hw/core/machine.c
@@ -22,6 +22,11 @@
 #include "qemu/error-report.h"
 #include "sysemu/qtest.h"
 
+/*
+ * used by machine_class_init():
+ *   548     object_class_property_add_str(oc, "accel",
+ *   549         machine_get_accel, machine_set_accel, &error_abort);
+ */
 static char *machine_get_accel(Object *obj, Error **errp)
 {
     MachineState *ms = MACHINE(obj);
@@ -29,6 +34,11 @@ static char *machine_get_accel(Object *obj, Error **errp)
     return g_strdup(ms->accel);
 }
 
+/*
+ * used by machine_class_init():
+ *   548     object_class_property_add_str(oc, "accel",
+ *   549         machine_get_accel, machine_set_accel, &error_abort);
+ */
 static void machine_set_accel(Object *obj, const char *value, Error **errp)
 {
     MachineState *ms = MACHINE(obj);
@@ -37,6 +47,12 @@ static void machine_set_accel(Object *obj, const char *value, Error **errp)
     ms->accel = g_strdup(value);
 }
 
+/*
+ * used by machine_class_init():
+ *   545     object_class_property_add(oc, "kernel-irqchip", "on|off|split",
+ *   546         NULL, machine_set_kernel_irqchip, 
+ *   547         NULL, NULL, &error_abort);
+ */
 static void machine_set_kernel_irqchip(Object *obj, Visitor *v,
                                        const char *name, void *opaque,
                                        Error **errp)
@@ -517,6 +533,12 @@ void machine_set_cpu_numa_node(MachineState *machine,
     }
 }
 
+/*
+ * TypeInfo machine_info.class_init = machine_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
@@ -636,6 +658,12 @@ static void machine_class_init(ObjectClass *oc, void *data)
         "Set memory encyption object to use", &error_abort);
 }
 
+/*
+ * TypeInfo machine_info.class_base_init = machine_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void machine_class_base_init(ObjectClass *oc, void *data)
 {
     if (!object_class_is_abstract(oc)) {
@@ -647,6 +675,12 @@ static void machine_class_base_init(ObjectClass *oc, void *data)
     }
 }
 
+/*
+ * TypeInfo machine_info.instance_init = machine_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+ */
 static void machine_initfn(Object *obj)
 {
     MachineState *ms = MACHINE(obj);
@@ -662,6 +696,12 @@ static void machine_initfn(Object *obj)
     qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);
 }
 
+/*
+ * TypeInfo machine_info.instance_finalize = machine_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void machine_finalize(Object *obj)
 {
     MachineState *ms = MACHINE(obj);
@@ -788,6 +828,12 @@ static void machine_numa_finish_cpu_init(MachineState *machine)
     g_string_free(s, true);
 }
 
+/*
+ * called only by:
+ *   - vl.c|4516| <<main>> machine_run_board_init(current_machine);
+ *
+ * 最主要的是调用MachineClass的init()
+ */
 void machine_run_board_init(MachineState *machine)
 {
     MachineClass *machine_class = MACHINE_GET_CLASS(machine);
@@ -804,6 +850,12 @@ void machine_run_board_init(MachineState *machine)
         int i;
 
         for (i = 0; machine_class->valid_cpu_types[i]; i++) {
+            /*
+	     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+	     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+	     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+	     */
             if (object_class_dynamic_cast(class,
                                           machine_class->valid_cpu_types[i])) {
                 /* The user specificed CPU is in the valid field, we are
@@ -827,9 +879,79 @@ void machine_run_board_init(MachineState *machine)
         }
     }
 
+    /*
+     * (gdb) p *machine_class
+     * $3 = {
+     *   parent_class = {
+     *     type = 0x555556785020, 
+     *     interfaces = 0x555556827780, 
+     *     object_cast_cache = {0x555555ea72b8 "generic-pc-machine", 0x555555ebd4f6 "machine", 0x555555eb8280 "generic-pc-machine", 0x555555f427bd "machine"}, 
+     *     class_cast_cache = {0x555555ea870d "generic-pc-machine", 0x555555e9299a "machine", 0x555555ee2032 "machine", 0x555555e8e912 "machine"}, 
+     *     unparent = 0x0, 
+     *     properties = 0x555556834300
+     *   }, 
+     *   family = 0x555555ea889e "pc_piix", 
+     *   name = 0x555556836d90 "pc-i440fx-3.0", 
+     *   alias = 0x555555ea88c7 "pc", 
+     *   desc = 0x555555ea8788 "Standard PC (i440FX + PIIX, 1996)", 
+     *   deprecation_reason = 0x0, 
+     *   init = 0x55555591d9e4 <pc_init_v3_0>, 
+     *   reset = 0x55555591bfcd <pc_machine_reset>, 
+     *   hot_add_cpu = 0x55555591851d <pc_hot_add_cpu>, 
+     *   kvm_type = 0x0, 
+     *   block_default_type = IF_IDE, 
+     *   units_per_default_bus = 0, 
+     *   max_cpus = 255, 
+     *   min_cpus = 1, 
+     *   default_cpus = 1, 
+     *   no_serial = 0, 
+     *   no_parallel = 0, 
+     *   use_virtcon = 0, 
+     *   no_floppy = 0, 
+     *   no_cdrom = 0, 
+     *   no_sdcard = 0, 
+     *   pci_allow_0_address = 0, 
+     *   legacy_fw_cfg_order = 0, 
+     *   is_default = 1, 
+     *   default_machine_opts = 0x555555ea88a6 "firmware=bios-256k.bin", 
+     *   default_boot_order = 0x555555ea7de8 "cad", 
+     *   default_display = 0x555555ea88bd "std", 
+     *   compat_props = 0x0, 
+     *   hw_version = 0x0, 
+     *   default_ram_size = 134217728, 
+     *   default_cpu_type = 0x555555ea7dec "qemu64-x86_64-cpu", 
+     *   option_rom_has_mr = false, 
+     *   rom_file_has_mr = true, 
+     *   minimum_page_bits = 0, 
+     *   has_hotpluggable_cpus = true, 
+     *   ignore_memory_transaction_failures = false, 
+     *   numa_mem_align_shift = 23, 
+     *   valid_cpu_types = 0x0, 
+     *   allowed_dynamic_sysbus_devices = 0x555556836db0, 
+     *   auto_enable_numa_with_memhp = true, 
+     *   numa_auto_assign_ram = 0x55555585eed8 <numa_default_auto_assign_ram>, 
+     *   get_hotplug_handler = 0x55555591b5fe <pc_get_hotpug_handler>, 
+     *   cpu_index_to_instance_props = 0x55555591c04d <pc_cpu_index_to_props>, 
+     *   possible_cpu_arch_ids = 0x55555591c1fd <pc_possible_cpu_arch_ids>, 
+     *  get_default_cpu_node_id = 0x55555591c138 <pc_get_default_cpu_node_id>
+     * }
+     */
+
+    /*
+     * init是在DEFINE_PC_MACHINE()初始化的
+     */
+
     machine_class->init(machine);
 }
 
+/*
+ * TypeInfo machine_info.class_finalize = machine_class_finalize()
+ *
+ * 似乎目前不调用:
+ *   - hw/core/machine.c|868| <<global>> .class_finalize = machine_class_finalize,
+ *   - qom/object.c|69| <<global>> void (*class_finalize)(ObjectClass *klass, void *data);
+ *   - qom/object.c|179| <<type_new>> ti->class_finalize = info->class_finalize;
+ */
 static void machine_class_finalize(ObjectClass *klass, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(klass);
@@ -840,6 +962,9 @@ static void machine_class_finalize(ObjectClass *klass, void *data)
     g_free(mc->name);
 }
 
+/*
+ * called only by register_global_properties() in vl.c
+ */
 void machine_register_compat_props(MachineState *machine)
 {
     MachineClass *mc = MACHINE_GET_CLASS(machine);
@@ -859,7 +984,7 @@ void machine_register_compat_props(MachineState *machine)
 }
 
 static const TypeInfo machine_info = {
-    .name = TYPE_MACHINE,
+    .name = TYPE_MACHINE,  // 还有孩子TYPE_PC_MACHINE
     .parent = TYPE_OBJECT,
     .abstract = true,
     .class_size = sizeof(MachineClass),
@@ -873,7 +998,16 @@ static const TypeInfo machine_info = {
 
 static void machine_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&machine_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(machine_register_types)
diff --git a/hw/core/qdev-fw.c b/hw/core/qdev-fw.c
index aa35e9d..ea88689 100644
--- a/hw/core/qdev-fw.c
+++ b/hw/core/qdev-fw.c
@@ -30,6 +30,10 @@ const char *qdev_fw_name(DeviceState *dev)
     return object_get_typename(OBJECT(dev));
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev-fw.c|72| <<qdev_get_fw_dev_path_helper>> d = bus_get_fw_dev_path(dev->parent_bus, dev);
+ */
 static char *bus_get_fw_dev_path(BusState *bus, DeviceState *dev)
 {
     BusClass *bc = BUS_GET_CLASS(bus);
@@ -60,6 +64,11 @@ char *qdev_get_own_fw_dev_path_from_handler(BusState *bus, DeviceState *dev)
     return fw_path_provider_try_get_dev_path(obj, bus, dev);
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev-fw.c|69| <<qdev_get_fw_dev_path_helper>> l = qdev_get_fw_dev_path_helper(dev->parent_bus->parent, p, size);
+ *   - hw/core/qdev-fw.c|91| <<qdev_get_fw_dev_path>> l = qdev_get_fw_dev_path_helper(dev, path, 128);
+ */
 static int qdev_get_fw_dev_path_helper(DeviceState *dev, char *p, int size)
 {
     int l = 0;
@@ -83,6 +92,10 @@ static int qdev_get_fw_dev_path_helper(DeviceState *dev, char *p, int size)
     return l;
 }
 
+/*
+ * called only by:
+ *   - bootdevice.c|224| <<get_boot_devices_list>> devpath = qdev_get_fw_dev_path(i->dev);
+ */
 char *qdev_get_fw_dev_path(DeviceState *dev)
 {
     char path[128];
diff --git a/hw/core/qdev-properties.c b/hw/core/qdev-properties.c
index 35072de..2aa9744 100644
--- a/hw/core/qdev-properties.c
+++ b/hw/core/qdev-properties.c
@@ -1226,6 +1226,12 @@ int qdev_prop_check_globals(void)
             continue;
         }
         oc = object_class_by_name(prop->driver);
+	/*
+	 * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	 * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+	 * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+	 * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+	 */
         oc = object_class_dynamic_cast(oc, TYPE_DEVICE);
         if (!oc) {
             warn_report("global %s.%s has invalid class name",
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index 529b82d..a9df9f4 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -68,6 +68,10 @@ static void bus_remove_child(BusState *bus, DeviceState *child)
     }
 }
 
+/*
+ * called only by:
+ *   - hw/core/qdev.c|107| <<qdev_set_parent_bus>> bus_add_child(bus, dev);
+ */
 static void bus_add_child(BusState *bus, DeviceState *child)
 {
     char name[32];
@@ -89,6 +93,9 @@ static void bus_add_child(BusState *bus, DeviceState *child)
                              NULL);
 }
 
+/*
+ * 被很多很多外部调用
+ */
 void qdev_set_parent_bus(DeviceState *dev, BusState *bus)
 {
     bool replugging = dev->parent_bus != NULL;
@@ -113,6 +120,9 @@ void qdev_set_parent_bus(DeviceState *dev, BusState *bus)
 /* Create a new device.  This only initializes the device state
    structure and allows properties to be set.  The device still needs
    to be realized.  See qdev-core.h.  */
+/*
+ * 被很多很多外部调用
+ */
 DeviceState *qdev_create(BusState *bus, const char *name)
 {
     DeviceState *dev;
@@ -131,13 +141,33 @@ DeviceState *qdev_create(BusState *bus, const char *name)
     return dev;
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev.c|130| <<qdev_create>> dev = qdev_try_create(bus, name);
+ *   - hw/core/sysbus.c|256| <<sysbus_try_create_varargs>> dev = qdev_try_create(NULL, name);
+ *   - hw/i386/pc.c|1591| <<pc_basic_device_init>> hpet = qdev_try_create(NULL, TYPE_HPET);
+ *   - hw/isa/isa-bus.c|170| <<isa_try_create>> dev = qdev_try_create(BUS(bus), name);
+ *   - hw/s390x/s390-pci-bus.c|778| <<s390_pci_device_new>> dev = qdev_try_create(BUS(s->bus), TYPE_S390_PCI_DEVICE);
+ *   - hw/usb/bus.c|336| <<usb_try_create_simple>> dev = USB_DEVICE(qdev_try_create(&bus->qbus, name));
+ */
 DeviceState *qdev_try_create(BusState *bus, const char *type)
 {
     DeviceState *dev;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     if (object_class_by_name(type) == NULL) {
         return NULL;
     }
+    /*
+     * object_new():
+     *       根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     *       确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     *       然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     dev = DEVICE(object_new(type));
     if (!dev) {
         return NULL;
@@ -149,6 +179,12 @@ DeviceState *qdev_try_create(BusState *bus, const char *type)
          * being put onto a bus should be created with object_new(TYPE_FOO),
          * not qdev_create(NULL, TYPE_FOO).
          */
+        /*
+	 * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	 * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+	 * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+	 * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+	 */
         g_assert(object_dynamic_cast(OBJECT(dev), TYPE_SYS_BUS_DEVICE));
         bus = sysbus_get_default();
     }
@@ -188,6 +224,10 @@ enum ListenerDirection { Forward, Reverse };
         }                                                         \
     } while (0)
 
+/*
+ * called only by:
+ *   - hw/core/qdev.c|238| <<device_listener_register>> qbus_walk_children(sysbus_get_default(), NULL, NULL, device_listener_add,
+ */
 static int device_listener_add(DeviceState *dev, void *opaque)
 {
     DEVICE_LISTENER_CALL(realize, Forward, dev);
@@ -540,6 +580,10 @@ BusState *qdev_get_child_bus(DeviceState *dev, const char *name)
     return NULL;
 }
 
+/*
+ * hw/core/bus.c|65| <<qbus_walk_children>> err = qdev_walk_children(kid->child,
+ * hw/core/qdev.c|266| <<qdev_reset_all>> qdev_walk_children(dev, NULL, NULL, qdev_reset_one, qbus_reset_one, NULL);
+ */
 int qdev_walk_children(DeviceState *dev,
                        qdev_walkerfn *pre_devfn, qbus_walkerfn *pre_busfn,
                        qdev_walkerfn *post_devfn, qbus_walkerfn *post_busfn,
@@ -661,6 +705,10 @@ static void qdev_property_add_legacy(DeviceState *dev, Property *prop,
     }
 
     name = g_strdup_printf("legacy-%s", prop->name);
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(OBJECT(dev), name, "str",
                         prop->info->print ? qdev_get_legacy_property : prop->info->get,
                         NULL,
@@ -697,6 +745,10 @@ void qdev_property_add_static(DeviceState *dev, Property *prop,
         if (!prop->info->get && !prop->info->set) {
             return;
         }
+	/*
+	 * 核心思想是分配并初始化一个ObjectProperty
+	 * 然后插入Object->properties (GHashTable)
+	 */
         object_property_add(obj, prop->name, prop->info->name,
                             prop->info->get, prop->info->set,
                             prop->info->release,
@@ -708,6 +760,12 @@ void qdev_property_add_static(DeviceState *dev, Property *prop,
         return;
     }
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     * 最后修改找到的ObjectProperty的description
+     */
     object_property_set_description(obj, prop->name,
                                     prop->info->description,
                                     &error_abort);
@@ -764,6 +822,14 @@ GSList *qdev_build_hotpluggable_device_list(Object *peripheral)
     return list;
 }
 
+/*
+ * 用在device_initfn():
+ * 1025     object_property_add_bool(obj, "realized",
+ * 1026                              device_get_realized, device_set_realized, NULL);
+ *
+ * called by:
+ *   - qom/object.c|2954| <<property_set_bool>> prop->set(obj, value, errp);
+ */
 static bool device_get_realized(Object *obj, Error **errp)
 {
     DeviceState *dev = DEVICE(obj);
@@ -784,6 +850,25 @@ static bool check_only_migratable(Object *obj, Error **err)
     return true;
 }
 
+/*
+ * used by:
+ *   - hw/core/qdev.c|995| <<device_initfn>> device_get_realized, device_set_realized, NULL);
+ *     1030     object_property_add_bool(obj, "realized",
+ *     1031                              device_get_realized, device_set_realized, NULL);
+ *
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 static void device_set_realized(Object *obj, bool value, Error **errp)
 {
     DeviceState *dev = DEVICE(obj);
@@ -937,6 +1022,12 @@ static bool device_get_hotplugged(Object *obj, Error **err)
     return dev->hotplugged;
 }
 
+/*
+ * TypeInfo device_type_info.instance_init = device_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void device_initfn(Object *obj)
 {
     DeviceState *dev = DEVICE(obj);
@@ -951,6 +1042,13 @@ static void device_initfn(Object *obj)
     dev->instance_id_alias = -1;
     dev->realized = false;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     *     get     = property_get_bool()
+     *     set     = property_set_bool()
+     *     release = property_release_bool()
+     */
     object_property_add_bool(obj, "realized",
                              device_get_realized, device_set_realized, NULL);
     object_property_add_bool(obj, "hotpluggable",
@@ -959,12 +1057,20 @@ static void device_initfn(Object *obj)
                              device_get_hotplugged, NULL,
                              &error_abort);
 
+    /*
+     * 返回Object->class
+     */
     class = object_get_class(OBJECT(dev));
     do {
         for (prop = DEVICE_CLASS(class)->props; prop && prop->name; prop++) {
             qdev_property_add_legacy(dev, prop, &error_abort);
             qdev_property_add_static(dev, prop, &error_abort);
         }
+	/*
+	 * 得到TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 * 初始化parent_type(TypeImpl)的class_size, instance_size和class, 还有interface, 调用.class_init()
+	 * 最后返回parent_type(TypeImpl)的class (ObjectClass)
+	 */
         class = object_class_get_parent(class);
     } while (class != object_class_by_name(TYPE_DEVICE));
 
@@ -974,12 +1080,24 @@ static void device_initfn(Object *obj)
     QLIST_INIT(&dev->gpios);
 }
 
+/*
+ * TypeInfo device_type_info.instance_post_init = device_post_init()
+ *
+ * called only by:
+ *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+ */
 static void device_post_init(Object *obj)
 {
     qdev_prop_set_globals(DEVICE(obj));
 }
 
 /* Unlink device from bus and free the structure.  */
+/*
+ * TypeInfo device_type_info.instance_finalize = device_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void device_finalize(Object *obj)
 {
     NamedGPIOList *ngl, *next;
@@ -1009,6 +1127,12 @@ static void device_finalize(Object *obj)
     qemu_opts_del(dev->opts);
 }
 
+/*
+ * TypeInfo device_type_info.class_base_init = device_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void device_class_base_init(ObjectClass *class, void *data)
 {
     DeviceClass *klass = DEVICE_CLASS(class);
@@ -1038,6 +1162,12 @@ static void device_unparent(Object *obj)
     }
 }
 
+/*
+ * TypeInfo device_type_info.class_init = device_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void device_class_init(ObjectClass *class, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(class);
@@ -1078,20 +1208,67 @@ void device_class_set_parent_unrealize(DeviceClass *dc,
     dc->unrealize = dev_unrealize;
 }
 
+/*
+ * (gdb) bt
+ * #0  qdev_e1000_reset (dev=0x7fffe765e010) at hw/net/e1000.c:1697
+ * #1  0x0000555555a749ce in device_reset (dev=0x7fffe765e010) at hw/core/qdev.c:1086
+ * #2  0x0000555555a729c1 in qdev_reset_one (dev=0x7fffe765e010, opaque=0x0) at hw/core/qdev.c:250
+ * #3  0x0000555555a735c7 in qdev_walk_children (dev=0x7fffe765e010, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/qdev.c:567
+ * #4  0x0000555555a77b53 in qbus_walk_children (bus=0x5555569fed40, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/bus.c:59
+ * #5  0x0000555555a7358b in qdev_walk_children (dev=0x5555569fca60, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/qdev.c:559
+ * #6  0x0000555555a77b53 in qbus_walk_children (bus=0x5555568acc70, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/bus.c:59
+ * #7  0x0000555555a72adb in qbus_reset_all (bus=0x5555568acc70) at hw/core/qdev.c:276
+ * #8  0x0000555555a72afe in qbus_reset_all_fn (opaque=0x5555568acc70) at hw/core/qdev.c:282
+ * #9  0x0000555555a78499 in qemu_devices_reset () at hw/core/reset.c:69
+ * #10 0x000055555591bfda in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #11 0x00005555559d8098 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #12 0x00005555559dfd6e in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4611
+ *
+ * 几个主要调用的例子:
+ *   - hw/core/qdev.c|290| <<qdev_reset_one>> device_reset(dev);
+ *   - hw/core/qdev.c|952| <<device_set_realized>> device_reset(dev);
+ *   - hw/i386/pc.c|2305| <<pc_machine_reset>> device_reset(cpu->apic_state);
+ */
 void device_reset(DeviceState *dev)
 {
     DeviceClass *klass = DEVICE_GET_CLASS(dev);
 
+    /*
+     * 以e1000和e1000e为例子, reset的设置的地方:
+     *   - hw/net/e1000.c|1755| <<e1000_class_init>> dc->reset = qdev_e1000_reset;
+     *   - hw/net/e1000e.c|681| <<e1000e_class_init>> dc->reset = e1000e_qdev_reset;
+     */
+
     if (klass->reset) {
         klass->reset(dev);
     }
 }
 
+/*
+ * 在这个例子中, machine是name, child<pc-i440fx-3.0-machine>是type
+ *    (qemu) qom-list /
+ *    machine (child<pc-i440fx-3.0-machine>)
+ *    type (string)
+ *    chardevs (child<container>)
+ *    backend (child<container>)
+ *
+ * 测试的时候"/machine"不是在这里的container_get()初始化的
+ * 应该是在vl.c的main()初始化的:
+ *     4067     object_property_add_child(object_get_root(), "machine",
+ *     4068                               OBJECT(current_machine), &error_abort);
+ */
 Object *qdev_get_machine(void)
 {
     static Object *dev;
 
     if (dev == NULL) {
+        /*
+	 * object_get_root(): 返回"container"的Object (root), 如果为空先初始化
+	 */
         dev = container_get(object_get_root(), "/machine");
     }
 
@@ -1113,7 +1290,16 @@ static const TypeInfo device_type_info = {
 
 static void qdev_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&device_type_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(qdev_register_types)
diff --git a/hw/core/reset.c b/hw/core/reset.c
index 84c8869..563a36f 100644
--- a/hw/core/reset.c
+++ b/hw/core/reset.c
@@ -35,9 +35,25 @@ typedef struct QEMUResetEntry {
     void *opaque;
 } QEMUResetEntry;
 
+/*
+ * 添加:
+ *   - hw/core/reset.c|47| <<qemu_register_reset>> QTAILQ_INSERT_TAIL(&reset_handlers, re, entry);
+ *
+ * 删除:
+ *   - hw/core/reset.c|56| <<qemu_unregister_reset>> QTAILQ_REMOVE(&reset_handlers, re, entry);
+ *
+ * 使用:
+ *   - hw/core/reset.c|54| <<qemu_unregister_reset>> QTAILQ_FOREACH(re, &reset_handlers, entry) {
+ *   - hw/core/reset.c|68| <<qemu_devices_reset>> QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {
+ */
 static QTAILQ_HEAD(reset_handlers, QEMUResetEntry) reset_handlers =
     QTAILQ_HEAD_INITIALIZER(reset_handlers);
 
+/*
+ * 很多很多外部调用
+ *
+ * 把func(QEMUResetHandler)和opaque初始化成QEMUResetEntry, 插入reset_handlers链表
+ */
 void qemu_register_reset(QEMUResetHandler *func, void *opaque)
 {
     QEMUResetEntry *re = g_malloc0(sizeof(QEMUResetEntry));
@@ -47,6 +63,23 @@ void qemu_register_reset(QEMUResetHandler *func, void *opaque)
     QTAILQ_INSERT_TAIL(&reset_handlers, re, entry);
 }
 
+/*
+ * bootdevice.c|115| <<restore_boot_order>> qemu_unregister_reset(restore_boot_order, normal_boot_order);
+ * hw/char/serial.c|959| <<serial_exit_core>> qemu_unregister_reset(serial_reset, s);
+ * hw/core/bus.c|139| <<bus_unparent>> qemu_unregister_reset(qbus_reset_all_fn, bus);
+ * hw/core/generic-loader.c|175| <<generic_loader_unrealize>> qemu_unregister_reset(generic_loader_reset, dev);
+ * hw/i386/pc.c|438| <<pc_cmos_init_late>> qemu_unregister_reset(pc_cmos_init_late, opaque);
+ * hw/intc/xics.c|364| <<icp_unrealize>> qemu_unregister_reset(icp_reset_handler, dev);
+ * hw/ppc/pnv_core.c|192| <<pnv_unrealize_vcpu>> qemu_unregister_reset(pnv_cpu_reset, cpu);
+ * hw/ppc/spapr_cpu_core.c|118| <<spapr_unrealize_vcpu>> qemu_unregister_reset(spapr_cpu_reset, cpu);
+ * hw/ppc/spapr_cpu_core.c|239| <<spapr_realize_vcpu>> qemu_unregister_reset(spapr_cpu_reset, cpu);
+ * hw/ppc/spapr_drc.c|641| <<unrealize_physical>> qemu_unregister_reset(drc_physical_reset, drcp);
+ * hw/vfio/common.c|1363| <<vfio_put_group>> qemu_unregister_reset(vfio_reset_handler, NULL);
+ * target/i386/cpu.c|5040| <<x86_cpu_unrealizefn>> qemu_unregister_reset(x86_cpu_machine_reset_cb, dev);
+ * target/s390x/cpu.c|303| <<s390_cpu_finalize>> qemu_unregister_reset(s390_cpu_machine_reset_cb, cpu);
+ *
+ * 根据func(QEMUResetHandler)和opaque在链表reset_handlers中寻找QEMUResetEntry并删掉
+ */
 void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
 {
     QEMUResetEntry *re;
@@ -60,6 +93,14 @@ void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
     }
 }
 
+/*
+ * hw/hppa/machine.c|245| <<hppa_machine_reset>> qemu_devices_reset();
+ * hw/i386/pc.c|2282| <<pc_machine_reset>> qemu_devices_reset();
+ * hw/ppc/pnv.c|504| <<pnv_reset>> qemu_devices_reset();
+ * hw/ppc/spapr.c|1639| <<spapr_machine_reset>> qemu_devices_reset();
+ * hw/s390x/s390-virtio-ccw.c|355| <<s390_machine_reset>> qemu_devices_reset();
+ * vl.c|1647| <<qemu_system_reset>> qemu_devices_reset();
+ */
 void qemu_devices_reset(void)
 {
     QEMUResetEntry *re, *nre;
diff --git a/hw/i386/kvm/apic.c b/hw/i386/kvm/apic.c
index 1df6d26..063944c 100644
--- a/hw/i386/kvm/apic.c
+++ b/hw/i386/kvm/apic.c
@@ -217,10 +217,36 @@ static void kvm_apic_reset(APICCommonState *s)
     run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
 }
 
+/*
+ * 测试的是几个cpu调用几次:
+ * (gdb) bt
+ * #0  kvm_apic_realize (dev=0x5555569096f0, errp=0x7fffffffda30) at /home/zhang/kvm/qemu-3.0.0/hw/i386/kvm/apic.c:222
+ * #1  0x00005555558c3b00 in apic_common_realize (dev=0x5555569096f0, errp=0x7fffffffda30) at /home/zhang/kvm/qemu-3.0.0/hw/intc/apic_common.c:318
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555569096f0, value=true, errp=0x7fffffffdc40) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555569096f0, v=0x55555690a570, name=0x555555eb3490 "realized", opaque=0x5555569024e0, errp=0x7fffffffdc40) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555569096f0, v=0x55555690a570, name=0x555555eb3490 "realized", errp=0x7fffffffdc40) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555569096f0, value=0x55555690a3c0, name=0x555555eb3490 "realized", errp=0x7fffffffdc40) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555569096f0, value=true, name=0x555555eb3490 "realized", errp=0x7fffffffdc40) at qom/object.c:1242
+ * #7  0x0000555555955e9a in x86_cpu_apic_realize (cpu=0x5555568e8760, errp=0x7fffffffdc40) at /home/zhang/kvm/qemu-3.0.0/target/i386/cpu.c:4491
+ * #8  0x00005555559571da in x86_cpu_realizefn (dev=0x5555568e8760, errp=0x7fffffffdcc0) at /home/zhang/kvm/qemu-3.0.0/target/i386/cpu.c:5017
+ * #9  0x0000555555a73ecc in device_set_realized (obj=0x5555568e8760, value=true, errp=0x7fffffffde98) at hw/core/qdev.c:826
+ * #10 0x0000555555c6020e in property_set_bool (obj=0x5555568e8760, v=0x555556901fe0, name=0x555555ea7440 "realized", opaque=0x5555568e86f0, errp=0x7fffffffde98) at qom/object.c:1984
+ * #11 0x0000555555c5e493 in object_property_set (obj=0x5555568e8760, v=0x555556901fe0, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/object.c:1176
+ * #12 0x0000555555c6154b in object_property_set_qobject (obj=0x5555568e8760, value=0x555556906680, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/qom-qobject.c:27
+ * #13 0x0000555555c5e778 in object_property_set_bool (obj=0x5555568e8760, value=true, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/object.c:1242
+ * #14 0x00005555559184e7 in pc_new_cpu (typename=0x555555ea7dec "qemu64-x86_64-cpu", apic_id=1, errp=0x555556751598 <error_fatal>) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1107
+ * #15 0x0000555555918752 in pc_cpus_init (pcms=0x55555684fa40) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1155
+ * #16 0x000055555591cd4d in pc_init1 (machine=0x55555684fa40, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:153
+ * #17 0x000055555591da26 in pc_init_v3_0 (machine=0x55555684fa40) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #18 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684fa40) at hw/core/machine.c:830
+ * #19 0x00005555559dfb8f in main (argc=16, argv=0x7fffffffe388, envp=0x7fffffffe410) at vl.c:4516
+ *
+ */
 static void kvm_apic_realize(DeviceState *dev, Error **errp)
 {
     APICCommonState *s = APIC_COMMON(dev);
 
+    /* 在x86_cpu_apic_realize()中设置的ops */
     memory_region_init_io(&s->io_memory, OBJECT(s), &kvm_apic_io_ops, s,
                           "kvm-apic-msi", APIC_SPACE_SIZE);
 
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 83a4444..d630d4f 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1321,6 +1321,16 @@ void xen_load_linux(PCMachineState *pcms)
     pcms->fw_cfg = fw_cfg;
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|194| <<pc_init1>> pc_memory_init(pcms, system_memory,
+ *   - hw/i386/pc_q35.c|167| <<pc_q35_init>> pc_memory_init(pcms, get_system_memory(),
+ *
+ * 整个过程中,分配内存也不会像MemoryRegion那么频繁,mr很多时候是创建一个alias,
+ * 指向已经存在的mr的一部分,这也是alias的作用,就是把一个mr分割成多个不连续的mr.
+ * 真正分配空间的大概有这么几个,pc.ram,,pc.bios,,pc.rom,,以及设备的一些ram,rom等,
+ * vga.vram,,vga.rom,,e1000.rom等.
+ */
 void pc_memory_init(PCMachineState *pcms,
                     MemoryRegion *system_memory,
                     MemoryRegion *rom_memory,
@@ -1333,6 +1343,9 @@ void pc_memory_init(PCMachineState *pcms,
     MachineState *machine = MACHINE(pcms);
     PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);
 
+    /*
+     * 在pc_init1()中初始化了pcms->below_4g_mem_size和pcms->above_4g_mem_size
+     */
     assert(machine->ram_size == pcms->below_4g_mem_size +
                                 pcms->above_4g_mem_size);
 
@@ -1342,13 +1355,37 @@ void pc_memory_init(PCMachineState *pcms,
      * aliases to address portions of it, mostly for backwards compatibility
      * with older qemus that used qemu_ram_alloc().
      */
+    /* ram是MemoryRegion */
     ram = g_malloc(sizeof(*ram));
+    /*
+     * 这里的machine->ram_size就是qemu参数中的内存
+     *
+     * 这里分配了RAMBlock!
+     */
     memory_region_allocate_system_memory(ram, NULL, "pc.ram",
                                          machine->ram_size);
+
+    /*
+     * 在创建好了ram并且分配好了空间之后,创建了两个mr alias,ram_below_4g
+     * 以及ram_above_4g,这两个mr分别指向ram的低4g以及高4g空间,这两个alias
+     * 是挂在根system_memory mr下面的
+     * 以后的情形类似,创建根mr,创建AddressSpace,然后在根mr下面加subregion。
+     */
+
     *ram_memory = ram;
     ram_below_4g = g_malloc(sizeof(*ram_below_4g));
+    /*
+     * 把ram_below_4g设置为ram的一个alias, 也就是表示ram的一部分
+     */
     memory_region_init_alias(ram_below_4g, NULL, "ram-below-4g", ram,
                              0, pcms->below_4g_mem_size);
+    /*
+     * 设置subregion的container和addr (记录该region在物理内存的地址)
+     * 按照priority=0把subregion插入到上一层的MemoryRegion的subregions链表
+     * "上一层"的意思就是说这个region是上一层的subregion
+     * 没有好的位置就插入到最后
+     * 最后还要memory_region_transaction_commit()
+     */
     memory_region_add_subregion(system_memory, 0, ram_below_4g);
     e820_add_entry(0, pcms->below_4g_mem_size, E820_RAM);
     if (pcms->above_4g_mem_size > 0) {
@@ -1356,6 +1393,9 @@ void pc_memory_init(PCMachineState *pcms,
         memory_region_init_alias(ram_above_4g, NULL, "ram-above-4g", ram,
                                  pcms->below_4g_mem_size,
                                  pcms->above_4g_mem_size);
+	/*
+	 * 0x100000000ULL是4g
+	 */
         memory_region_add_subregion(system_memory, 0x100000000ULL,
                                     ram_above_4g);
         e820_add_entry(0x100000000ULL, pcms->above_4g_mem_size, E820_RAM);
@@ -1633,6 +1673,11 @@ void pc_basic_device_init(ISABus *isa_bus, qemu_irq *gsi,
     pc_superio_init(isa_bus, create_fdctrl, no_vmport);
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|244| <<pc_init1>> pc_nic_init(pcmc, isa_bus, pci_bus);
+ *   - hw/i386/pc_q35.c|277| <<pc_q35_init>> pc_nic_init(pcmc, isa_bus, host_bus);
+ */
 void pc_nic_init(PCMachineClass *pcmc, ISABus *isa_bus, PCIBus *pci_bus)
 {
     int i;
@@ -2258,6 +2303,12 @@ static void pc_machine_set_pit(Object *obj, bool value, Error **errp)
     pcms->pit = value;
 }
 
+/*
+ * TypeInfo pc_machine_info.instance_init = pc_machine_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void pc_machine_initfn(Object *obj)
 {
     PCMachineState *pcms = PC_MACHINE(obj);
@@ -2274,6 +2325,9 @@ static void pc_machine_initfn(Object *obj)
     pcms->pit = true;
 }
 
+/*
+ * 在pc_machine_class_init设置成了MachineClass mc的reset
+ */
 static void pc_machine_reset(void)
 {
     CPUState *cs;
@@ -2363,6 +2417,12 @@ static void x86_nmi(NMIState *n, int cpu_index, Error **errp)
     }
 }
 
+/*
+ * TypeInfo pc_machine_info.class_init = pc_machine_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void pc_machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
@@ -2443,6 +2503,28 @@ static void pc_machine_class_init(ObjectClass *oc, void *data)
         pc_machine_get_pit, pc_machine_set_pit, &error_abort);
 }
 
+/*
+ * TYPE_PC_MACHINE is used by:
+ *   - hw/i386/x86-iommu.c|88| <<x86_iommu_realize>> PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));
+ *   - include/hw/i386/pc.h|142| <<PC_MACHINE>> OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|144| <<PC_MACHINE_GET_CLASS>> OBJECT_GET_CLASS(PCMachineClass, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|146| <<PC_MACHINE_CLASS>> OBJECT_CLASS_CHECK(PCMachineClass, (klass), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|954| <<DEFINE_PC_MACHINE>> .parent = TYPE_PC_MACHINE, \
+ *   - target/i386/kvm.c|1455| <<kvm_arch_init>> object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE) &&
+ *
+ *
+ * DEFINE_PC_MACHINE() is called by (i440x, q35, xenfv, isapc):
+ *   - hw/i386/pc_piix.c|1136| <<global>> DEFINE_PC_MACHINE(isapc, "isapc", pc_init_isa,
+ *   - hw/i386/pc_piix.c|1148| <<global>> DEFINE_PC_MACHINE(xenfv, "xenfv", pc_xen_hvm_init,
+ *   - hw/i386/pc_piix.c|417| <<DEFINE_I440FX_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *   - hw/i386/pc_q35.c|294| <<DEFINE_Q35_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *
+ * i440x: pc_init1()
+ * q35  : pc_q35_init()
+ *
+ * QEMU的默认是i440x
+ */
+
 static const TypeInfo pc_machine_info = {
     .name = TYPE_PC_MACHINE,
     .parent = TYPE_MACHINE,
@@ -2460,7 +2542,16 @@ static const TypeInfo pc_machine_info = {
 
 static void pc_machine_register_types(void)
 {
+    /*  
+     * 被外部好多好多调用
+     *
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&pc_machine_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(pc_machine_register_types)
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index dc09466..b8976c7 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -66,13 +66,26 @@ static const int ide_iobase2[MAX_IDE_BUS] = { 0x3f6, 0x376 };
 static const int ide_irq[MAX_IDE_BUS] = { 14, 15 };
 
 /* PC hardware initialisation */
+/*
+ * called or used by:
+ *   - hw/i386/pc_piix.c|379| <<pc_init_isa>> pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, TYPE_I440FX_PCI_DEVICE);
+ *   - hw/i386/pc_piix.c|388| <<pc_xen_hvm_init_pci>> pc_init1(machine,
+ *   - hw/i386/pc_piix.c|445| <<DEFINE_I440FX_MACHINE>> pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, \
+ *
+ * 一个例子:
+ * (gdb) bt
+ * #0  pc_init1 (machine=0x55555684f480, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:71
+ * #1  0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f480) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #2  0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f480) at hw/core/machine.c:830
+ * #3  0x00005555559dfb8f in main (argc=10, argv=0x7fffffffe498, envp=0x7fffffffe4f0) at vl.c:4516
+ */
 static void pc_init1(MachineState *machine,
                      const char *host_type, const char *pci_type)
 {
     PCMachineState *pcms = PC_MACHINE(machine);
     PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);
-    MemoryRegion *system_memory = get_system_memory();
-    MemoryRegion *system_io = get_system_io();
+    MemoryRegion *system_memory = get_system_memory();  // 返回system_memory (MemoryRegion)
+    MemoryRegion *system_io = get_system_io();          // 返回system_io (MemoryRegion)
     int i;
     PCIBus *pci_bus;
     ISABus *isa_bus;
@@ -123,7 +136,7 @@ static void pc_init1(MachineState *machine,
     if (xen_enabled()) {
         xen_hvm_init(pcms, &ram_memory);
     } else {
-        if (!pcms->max_ram_below_4g) {
+        if (!pcms->max_ram_below_4g) { // gdb调试的时候pcms->max_ram_below_4g是0
             pcms->max_ram_below_4g = 0xe0000000; /* default: 3.5G */
         }
         lowmem = pcms->max_ram_below_4g;
@@ -156,7 +169,9 @@ static void pc_init1(MachineState *machine,
         kvmclock_create();
     }
 
+    /* pcmc->pci_enabled在debug的时候是true */
     if (pcmc->pci_enabled) {
+        /* 分配一个MemoryRegion */
         pci_memory = g_new(MemoryRegion, 1);
         memory_region_init(pci_memory, NULL, "pci", UINT64_MAX);
         rom_memory = pci_memory;
@@ -178,6 +193,9 @@ static void pc_init1(MachineState *machine,
 
     /* allocate ram and load rom/bios */
     if (!xen_enabled()) {
+        /*
+	 * 刚刚在上面初始化完了above_4g_mem_size和below_4g_mem_size
+	 */
         pc_memory_init(pcms, system_memory,
                        rom_memory, &ram_memory);
     } else if (machine->kernel_filename != NULL) {
@@ -404,6 +422,37 @@ static void pc_xen_hvm_init(MachineState *machine)
 }
 #endif
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|438| <<global>> DEFINE_I440FX_MACHINE(v3_0, "pc-i440fx-3.0", NULL,
+ *   - hw/i386/pc_piix.c|449| <<global>> DEFINE_I440FX_MACHINE(v2_12, "pc-i440fx-2.12", NULL,
+ *   - hw/i386/pc_piix.c|458| <<global>> DEFINE_I440FX_MACHINE(v2_11, "pc-i440fx-2.11", NULL,
+ *   - hw/i386/pc_piix.c|468| <<global>> DEFINE_I440FX_MACHINE(v2_10, "pc-i440fx-2.10", NULL,
+ *   - hw/i386/pc_piix.c|478| <<global>> DEFINE_I440FX_MACHINE(v2_9, "pc-i440fx-2.9", NULL,
+ *   - hw/i386/pc_piix.c|487| <<global>> DEFINE_I440FX_MACHINE(v2_8, "pc-i440fx-2.8", NULL,
+ *   - hw/i386/pc_piix.c|497| <<global>> DEFINE_I440FX_MACHINE(v2_7, "pc-i440fx-2.7", NULL,
+ *   - hw/i386/pc_piix.c|510| <<global>> DEFINE_I440FX_MACHINE(v2_6, "pc-i440fx-2.6", NULL,
+ *   - hw/i386/pc_piix.c|523| <<global>> DEFINE_I440FX_MACHINE(v2_5, "pc-i440fx-2.5", NULL,
+ *   - hw/i386/pc_piix.c|536| <<global>> DEFINE_I440FX_MACHINE(v2_4, "pc-i440fx-2.4", NULL,
+ *   - hw/i386/pc_piix.c|547| <<global>> DEFINE_I440FX_MACHINE(v2_3, "pc-i440fx-2.3", pc_compat_2_3,
+ *   - hw/i386/pc_piix.c|560| <<global>> DEFINE_I440FX_MACHINE(v2_2, "pc-i440fx-2.2", pc_compat_2_2,
+ *   - hw/i386/pc_piix.c|575| <<global>> DEFINE_I440FX_MACHINE(v2_1, "pc-i440fx-2.1", pc_compat_2_1,
+ *   - hw/i386/pc_piix.c|608| <<global>> DEFINE_I440FX_MACHINE(v2_0, "pc-i440fx-2.0", pc_compat_2_0,
+ *   - hw/i386/pc_piix.c|625| <<global>> DEFINE_I440FX_MACHINE(v1_7, "pc-i440fx-1.7", pc_compat_1_7,
+ *   - hw/i386/pc_piix.c|639| <<global>> DEFINE_I440FX_MACHINE(v1_6, "pc-i440fx-1.6", pc_compat_1_6,
+ *   - hw/i386/pc_piix.c|650| <<global>> DEFINE_I440FX_MACHINE(v1_5, "pc-i440fx-1.5", pc_compat_1_5,
+ *   - hw/i386/pc_piix.c|662| <<global>> DEFINE_I440FX_MACHINE(v1_4, "pc-i440fx-1.4", pc_compat_1_4,
+ *   - hw/i386/pc_piix.c|694| <<global>> DEFINE_I440FX_MACHINE(v1_3, "pc-1.3", pc_compat_1_3,
+ *   - hw/i386/pc_piix.c|733| <<global>> DEFINE_I440FX_MACHINE(v1_2, "pc-1.2", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|776| <<global>> DEFINE_I440FX_MACHINE(v1_1, "pc-1.1", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|807| <<global>> DEFINE_I440FX_MACHINE(v1_0, "pc-1.0", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|821| <<global>> DEFINE_I440FX_MACHINE(v0_15, "pc-0.15", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|860| <<global>> DEFINE_I440FX_MACHINE(v0_14, "pc-0.14", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|897| <<global>> DEFINE_I440FX_MACHINE(v0_13, "pc-0.13", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|932| <<global>> DEFINE_I440FX_MACHINE(v0_12, "pc-0.12", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|964| <<global>> DEFINE_I440FX_MACHINE(v0_11, "pc-0.11", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|999| <<global>> DEFINE_I440FX_MACHINE(v0_10, "pc-0.10", pc_compat_0_13,
+ */
 #define DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn) \
     static void pc_init_##suffix(MachineState *machine) \
     { \
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index 532241e..85bc2d2 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -59,6 +59,17 @@
 #define MAX_SATA_PORTS     6
 
 /* PC hardware initialisation */
+/*
+ * called only by:
+ *   - hw/i386/pc_q35.c|305| <<DEFINE_Q35_MACHINE>> pc_q35_init(machine); \
+ *
+ * 一个例子:
+ * (gdb) bt
+ * #0  pc_q35_init (machine=0x55555684f880) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_q35.c:63
+ * #1  0x0000555555921d5e in pc_init_v3_0 (machine=0x55555684f880) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_q35.c:320
+ * #2  0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f880) at hw/core/machine.c:830
+ * #3  0x00005555559dfb8f in main (argc=12, argv=0x7fffffffe478, envp=0x7fffffffe4e0) at vl.c:4516
+ */
 static void pc_q35_init(MachineState *machine)
 {
     PCMachineState *pcms = PC_MACHINE(machine);
@@ -282,6 +293,19 @@ static void pc_q35_init(MachineState *machine)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_q35.c|320| <<global>> DEFINE_Q35_MACHINE(v3_0, "pc-q35-3.0", NULL,
+ *   - hw/i386/pc_q35.c|330| <<global>> DEFINE_Q35_MACHINE(v2_12, "pc-q35-2.12", NULL,
+ *   - hw/i386/pc_q35.c|342| <<global>> DEFINE_Q35_MACHINE(v2_11, "pc-q35-2.11", NULL,
+ *   - hw/i386/pc_q35.c|353| <<global>> DEFINE_Q35_MACHINE(v2_10, "pc-q35-2.10", NULL,
+ *   - hw/i386/pc_q35.c|362| <<global>> DEFINE_Q35_MACHINE(v2_9, "pc-q35-2.9", NULL,
+ *   - hw/i386/pc_q35.c|371| <<global>> DEFINE_Q35_MACHINE(v2_8, "pc-q35-2.8", NULL,
+ *   - hw/i386/pc_q35.c|381| <<global>> DEFINE_Q35_MACHINE(v2_7, "pc-q35-2.7", NULL,
+ *   - hw/i386/pc_q35.c|393| <<global>> DEFINE_Q35_MACHINE(v2_6, "pc-q35-2.6", NULL,
+ *   - hw/i386/pc_q35.c|405| <<global>> DEFINE_Q35_MACHINE(v2_5, "pc-q35-2.5", NULL,
+ *   - hw/i386/pc_q35.c|417| <<global>> DEFINE_Q35_MACHINE(v2_4, "pc-q35-2.4", NULL,
+ */
 #define DEFINE_Q35_MACHINE(suffix, name, compatfn, optionfn) \
     static void pc_init_##suffix(MachineState *machine) \
     { \
diff --git a/hw/i386/x86-iommu.c b/hw/i386/x86-iommu.c
index 8a01a2d..f86fb51 100644
--- a/hw/i386/x86-iommu.c
+++ b/hw/i386/x86-iommu.c
@@ -84,6 +84,12 @@ static void x86_iommu_realize(DeviceState *dev, Error **errp)
     X86IOMMUClass *x86_class = X86_IOMMU_GET_CLASS(dev);
     MachineState *ms = MACHINE(qdev_get_machine());
     MachineClass *mc = MACHINE_GET_CLASS(ms);
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     PCMachineState *pcms =
         PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));
     QLIST_INIT(&x86_iommu->iec_notifiers);
diff --git a/hw/net/e1000.c b/hw/net/e1000.c
index 13a9494..3137b6d 100644
--- a/hw/net/e1000.c
+++ b/hw/net/e1000.c
@@ -1652,6 +1652,23 @@ static void e1000_write_config(PCIDevice *pci_dev, uint32_t address,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  pci_e1000_realize (pci_dev=0x7fffe765e010, errp=0x7fffffffdc58) at hw/net/e1000.c:1657
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x7fffe765e010, errp=0x7fffffffdcd0) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x7fffe765e010, value=true, errp=0x7fffffffde90) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x7fffe765e010, v=0x55555775ae10, name=0x555555ee0a71 "realized", opaque=0x555557759330, errp=0x7fffffffde90) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x7fffe765e010, v=0x55555775ae10, name=0x555555ee0a71 "realized", errp=0x7fffffffde90) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x7fffe765e010, value=0x55555775ad10, name=0x555555ee0a71 "realized", errp=0x7fffffffde90) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x7fffe765e010, value=true, name=0x555555ee0a71 "realized", errp=0x7fffffffde90) at qom/object.c:1242
+ * #7  0x0000555555a72ba0 in qdev_init_nofail (dev=0x7fffe765e010) at hw/core/qdev.c:313
+ * #8  0x0000555555b36848 in pci_nic_init_nofail (nd=0x5555567449a0 <nd_table>, rootbus=0x5555569fecb0, default_model=0x555555ea8898 "e1000", default_devaddr=0x0) at hw/pci/pci.c:1874
+ * #9  0x0000555555919da1 in pc_nic_init (pcmc=0x555556836510, isa_bus=0x5555571cf2f0, pci_bus=0x5555569fecb0) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1648
+ * #10 0x000055555591d2b7 in pc_init1 (machine=0x55555684f700, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:244
+ * #11 0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f700) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #12 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f700) at hw/core/machine.c:830
+ * #13 0x00005555559dfb8f in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4516
+ */
 static void pci_e1000_realize(PCIDevice *pci_dev, Error **errp)
 {
     DeviceState *dev = DEVICE(pci_dev);
@@ -1692,6 +1709,26 @@ static void pci_e1000_realize(PCIDevice *pci_dev, Error **errp)
     d->mit_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, e1000_mit_timer, d);
 }
 
+/*
+ * (gdb) bt
+ * #0  qdev_e1000_reset (dev=0x7fffe765e010) at hw/net/e1000.c:1697
+ * #1  0x0000555555a749ce in device_reset (dev=0x7fffe765e010) at hw/core/qdev.c:1086
+ * #2  0x0000555555a729c1 in qdev_reset_one (dev=0x7fffe765e010, opaque=0x0) at hw/core/qdev.c:250
+ * #3  0x0000555555a735c7 in qdev_walk_children (dev=0x7fffe765e010, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/qdev.c:567
+ * #4  0x0000555555a77b53 in qbus_walk_children (bus=0x5555569fed40, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/bus.c:59
+ * #5  0x0000555555a7358b in qdev_walk_children (dev=0x5555569fca60, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/qdev.c:559
+ * #6  0x0000555555a77b53 in qbus_walk_children (bus=0x5555568acc70, pre_devfn=0x0, pre_busfn=0x0, post_devfn=0x555555a729a5 <qdev_reset_one>, post_busfn=0x555555a729c8 <qbus_reset_one>, opaque=0x0)
+ *     at hw/core/bus.c:59
+ * #7  0x0000555555a72adb in qbus_reset_all (bus=0x5555568acc70) at hw/core/qdev.c:276
+ * #8  0x0000555555a72afe in qbus_reset_all_fn (opaque=0x5555568acc70) at hw/core/qdev.c:282
+ * #9  0x0000555555a78499 in qemu_devices_reset () at hw/core/reset.c:69
+ * #10 0x000055555591bfda in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #11 0x00005555559d8098 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #12 0x00005555559dfd6e in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4611
+ */
 static void qdev_e1000_reset(DeviceState *dev)
 {
     E1000State *d = E1000(dev);
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index b23e7f6..241d5a0 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -856,6 +856,18 @@ void *fw_cfg_modify_file(FWCfgState *s, const char *filename,
     return NULL;
 }
 
+/*
+ * used only by:
+ *   - hw/nvram/fw_cfg.c|874| <<fw_cfg_machine_ready>> qemu_register_reset(fw_cfg_machine_reset, s);
+ *
+ * (gdb) bt
+ * #0  get_boot_devices_list (size=0x7fffffffe078, ignore_suffixes=false) at bootdevice.c:214
+ * #1  0x0000555555b28ae5 in fw_cfg_machine_reset (opaque=0x5555569bc5d0) at hw/nvram/fw_cfg.c:864
+ * #2  0x0000555555a78499 in qemu_devices_reset () at hw/core/reset.c:69
+ * #3  0x000055555591bfda in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #4  0x00005555559d8098 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #5  0x00005555559dfd6e in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4611
+ */
 static void fw_cfg_machine_reset(void *opaque)
 {
     void *ptr;
@@ -870,6 +882,7 @@ static void fw_cfg_machine_reset(void *opaque)
 static void fw_cfg_machine_ready(struct Notifier *n, void *data)
 {
     FWCfgState *s = container_of(n, FWCfgState, machine_ready);
+    /* 把func(QEMUResetHandler)和opaque初始化成QEMUResetEntry, 插入reset_handlers链表 */
     qemu_register_reset(fw_cfg_machine_reset, s);
 }
 
diff --git a/hw/pci-host/piix.c b/hw/pci-host/piix.c
index 0e60834..c83e2db 100644
--- a/hw/pci-host/piix.c
+++ b/hw/pci-host/piix.c
@@ -214,6 +214,12 @@ static const VMStateDescription vmstate_i440fx = {
     }
 };
 
+/*
+ * used by hw/pci-host/piix.c|318| <<i440fx_pcihost_initfn>>:
+ * 317     object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_START, "uint32",
+ * 318                         i440fx_pcihost_get_pci_hole_start, 
+ * 319                         NULL, NULL, NULL, NULL);
+ */
 static void i440fx_pcihost_get_pci_hole_start(Object *obj, Visitor *v,
                                               const char *name, void *opaque,
                                               Error **errp)
@@ -228,6 +234,12 @@ static void i440fx_pcihost_get_pci_hole_start(Object *obj, Visitor *v,
     visit_type_uint32(v, name, &value, errp);
 }
 
+/*
+ * use by hw/pci-host/piix.c|328| <<i440fx_pcihost_initfn>>:
+ * 327     object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_END, "uint32",
+ * 328                         i440fx_pcihost_get_pci_hole_end, 
+ * 329                         NULL, NULL, NULL, NULL);
+ */
 static void i440fx_pcihost_get_pci_hole_end(Object *obj, Visitor *v,
                                             const char *name, void *opaque,
                                             Error **errp)
@@ -249,6 +261,12 @@ static void i440fx_pcihost_get_pci_hole_end(Object *obj, Visitor *v,
  * the 64bit PCI hole will start after "over 4G RAM" and the
  * reserved space for memory hotplug if any.
  */
+/*
+ * used by hw/pci-host/piix.c|338| <<i440fx_pcihost_initfn>>:
+ * 337     object_property_add(obj, PCI_HOST_PROP_PCI_HOLE64_START, "uint64",
+ * 338                         i440fx_pcihost_get_pci_hole64_start,
+ * 339                         NULL, NULL, NULL, NULL);
+ */
 static void i440fx_pcihost_get_pci_hole64_start(Object *obj, Visitor *v,
                                                 const char *name,
                                                 void *opaque, Error **errp)
@@ -272,6 +290,12 @@ static void i440fx_pcihost_get_pci_hole64_start(Object *obj, Visitor *v,
  * Then it is expanded to the PCI_HOST_PROP_PCI_HOLE64_SIZE
  * that can be configured by the user.
  */
+/*
+ * used by hw/pci-host/piix.c|348| <<i440fx_pcihost_initfn>>:
+ * 352     object_property_add(obj, PCI_HOST_PROP_PCI_HOLE64_END, "uint64",
+ * 353                         i440fx_pcihost_get_pci_hole64_end,
+ * 354                         NULL, NULL, NULL, NULL);
+ */
 static void i440fx_pcihost_get_pci_hole64_end(Object *obj, Visitor *v,
                                               const char *name, void *opaque,
                                               Error **errp)
@@ -291,15 +315,29 @@ static void i440fx_pcihost_get_pci_hole64_end(Object *obj, Visitor *v,
     visit_type_uint64(v, name, &value, errp);
 }
 
+/*
+ * TypeInfo i440fx_pcihost_info.instance_init = i440fx_pcihost_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void i440fx_pcihost_initfn(Object *obj)
 {
     PCIHostState *s = PCI_HOST_BRIDGE(obj);
 
     memory_region_init_io(&s->conf_mem, obj, &pci_host_conf_le_ops, s,
                           "pci-conf-idx", 4);
+    /*
+     * i440fx_pcihost_realize()调用sysbus_add_io()
+     * 为pci config space的内存加入到io内存中
+     */
     memory_region_init_io(&s->data_mem, obj, &pci_host_data_le_ops, s,
                           "pci-conf-data", 4);
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, PCI_HOST_PROP_PCI_HOLE_START, "uint32",
                         i440fx_pcihost_get_pci_hole_start,
                         NULL, NULL, NULL, NULL);
@@ -317,6 +355,25 @@ static void i440fx_pcihost_initfn(Object *obj)
                         NULL, NULL, NULL, NULL);
 }
 
+/*
+ * (gdb) bt
+ * #0  i440fx_pcihost_realize (dev=0x5555569fca60, errp=0x7fffffffdcc0) at hw/pci-host/piix.c:322
+ * #1  0x0000555555a73ecc in device_set_realized (obj=0x5555569fca60, value=true, errp=0x7fffffffde80) at hw/core/qdev.c:826
+ * #2  0x0000555555c6020e in property_set_bool (obj=0x5555569fca60, v=0x5555569ffa60, name=0x555555ee0a71 "realized", opaque=0x5555569fd210, errp=0x7fffffffde80) at qom/object.c:1984
+ * #3  0x0000555555c5e493 in object_property_set (obj=0x5555569fca60, v=0x5555569ffa60, name=0x555555ee0a71 "realized", errp=0x7fffffffde80) at qom/object.c:1176
+ * #4  0x0000555555c6154b in object_property_set_qobject (obj=0x5555569fca60, value=0x5555569ff920, name=0x555555ee0a71 "realized", errp=0x7fffffffde80) at qom/qom-qobject.c:27
+ * #5  0x0000555555c5e778 in object_property_set_bool (obj=0x5555569fca60, value=true, name=0x555555ee0a71 "realized", errp=0x7fffffffde80) at qom/object.c:1242
+ * #6  0x0000555555a72ba0 in qdev_init_nofail (dev=0x5555569fca60) at hw/core/qdev.c:313
+ * #7  0x0000555555b2e6ac in i440fx_init (host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX", pi440fx_state=0x7fffffffdfb8, piix3_devfn=0x7fffffffdfa8, isa_bus=0x7fffffffdfb0, 
+ *     pic=0x5555569f9690, address_space_mem=0x555556850d40, address_space_io=0x555556851ad0, ram_size=2097152000, below_4g_mem_size=2097152000, above_4g_mem_size=0, pci_address_space=0x5555568faff0, 
+ *     ram_memory=0x5555568fb440) at hw/pci-host/piix.c:368
+ * #8  0x000055555591d014 in pc_init1 (machine=0x55555684f780, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:198
+ * #9  0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f780) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #10 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f780) at hw/core/machine.c:830
+ * #11 0x00005555559dfb8f in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4516
+ *
+ * 应该是为pci config space的内存加入到io内存中
+ */
 static void i440fx_pcihost_realize(DeviceState *dev, Error **errp)
 {
     PCIHostState *s = PCI_HOST_BRIDGE(dev);
@@ -329,6 +386,26 @@ static void i440fx_pcihost_realize(DeviceState *dev, Error **errp)
     sysbus_init_ioports(sbd, 0xcfc, 4);
 }
 
+/*
+ * (gdb) bt
+ * #0  i440fx_realize (dev=0x555556a36480, errp=0x7fffffffdbd8) at hw/pci-host/piix.c:334
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x555556a36480, errp=0x7fffffffdc50) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x555556a36480, value=true, errp=0x7fffffffde10) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x555556a36480, v=0x555556a3ace0, name=0x555555ee0a71 "realized", opaque=0x5555569ffab0, errp=0x7fffffffde10) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x555556a36480, v=0x555556a3ace0, name=0x555555ee0a71 "realized", errp=0x7fffffffde10) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x555556a36480, value=0x555556a3ac00, name=0x555555ee0a71 "realized", errp=0x7fffffffde10) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x555556a36480, value=true, name=0x555555ee0a71 "realized", errp=0x7fffffffde10) at qom/object.c:1242
+ * #7  0x0000555555a72ba0 in qdev_init_nofail (dev=0x555556a36480) at hw/core/qdev.c:313
+ * #8  0x0000555555b36f2e in pci_create_simple_multifunction (bus=0x5555569fed40, devfn=0, multifunction=false, name=0x555555ea882d "i440FX") at hw/pci/pci.c:2067
+ * #9  0x0000555555b36f92 in pci_create_simple (bus=0x5555569fed40, devfn=0, name=0x555555ea882d "i440FX") at hw/pci/pci.c:2078
+ * #10 0x0000555555b2e6c1 in i440fx_init (host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX", pi440fx_state=0x7fffffffdfb8, piix3_devfn=0x7fffffffdfa8, isa_bus=0x7fffffffdfb0, 
+ *     pic=0x5555569f9690, address_space_mem=0x555556850d40, address_space_io=0x555556851ad0, ram_size=2097152000, below_4g_mem_size=2097152000, above_4g_mem_size=0, pci_address_space=0x5555568faff0, 
+ *     ram_memory=0x5555568fb440) at hw/pci-host/piix.c:370
+ * #11 0x000055555591d014 in pc_init1 (machine=0x55555684f780, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:198
+ * #12 0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f780) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #13 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f780) at hw/core/machine.c:830
+ * #14 0x00005555559dfb8f in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4516
+ */
 static void i440fx_realize(PCIDevice *dev, Error **errp)
 {
     dev->config[I440FX_SMRAM] = 0x02;
@@ -338,6 +415,19 @@ static void i440fx_realize(PCIDevice *dev, Error **errp)
     }
 }
 
+/*
+ * called by: hw/i386/pc_piix.c pc_init1()
+ * pci_bus = i440fx_init(host_type,  ---> i440FX-pcihost
+ *                       pci_type,   ---> i440FX
+ *                       &i440fx_state, &piix3_devfn, &isa_bus, pcms->gsi,
+ *                       system_memory, system_io, machine->ram_size,
+ *                       pcms->below_4g_mem_size,
+ *                       pcms->above_4g_mem_size,
+ *                       pci_memory, ram_memory);
+ *
+ * #define TYPE_I440FX_PCI_HOST_BRIDGE "i440FX-pcihost"
+ * #define TYPE_I440FX_PCI_DEVICE "i440FX"
+ */
 PCIBus *i440fx_init(const char *host_type, const char *pci_type,
                     PCII440FXState **pi440fx_state,
                     int *piix3_devfn,
@@ -359,14 +449,25 @@ PCIBus *i440fx_init(const char *host_type, const char *pci_type,
     unsigned i;
     I440FXState *i440fx;
 
+    /*
+     * 因为只被pc_init1()调用, host_type是TYPE_I440FX_PCI_HOST_BRIDGE("i440FX-pcihost")
+     *
+     * 会间接调用到TYPE_I440FX_PCI_HOST_BRIDGE的instance_init=i440fx_pcihost_initfn()
+     */
     dev = qdev_create(NULL, host_type);
     s = PCI_HOST_BRIDGE(dev);
     b = pci_root_bus_new(dev, NULL, pci_address_space,
                          address_space_io, 0, TYPE_PCI_BUS);
     s->bus = b;
     object_property_add_child(qdev_get_machine(), "i440fx", OBJECT(dev), NULL);
+    /*
+     * 这里会间接调用i440fx_pcihost_realize()
+     */
     qdev_init_nofail(dev);
 
+    /*
+     * 这里会间接调用i440fx_realize()
+     */
     d = pci_create_simple(b, 0, pci_type);
     *pi440fx_state = I440FX_PCI_DEVICE(d);
     f = *pi440fx_state;
@@ -379,6 +480,7 @@ PCIBus *i440fx_init(const char *host_type, const char *pci_type,
                      IO_APIC_DEFAULT_ADDRESS - 1);
 
     /* setup pci memory mapping */
+    /* 把pci的address_space设为系统内存的subregion */
     pc_pci_as_mapping_init(OBJECT(f), f->system_memory,
                            f->pci_address_space);
 
@@ -755,6 +857,9 @@ static const TypeInfo piix3_xen_info = {
     .class_init    = piix3_xen_class_init,
 };
 
+/*
+ * TypeInfo i440fx_info.class_init = i440fx_class_init()
+ */
 static void i440fx_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(klass);
@@ -804,6 +909,10 @@ static const IGDHostInfo igd_host_bridge_infos[] = {
     {0xa8, 4},  /* SNB: base of GTT stolen memory */
 };
 
+/*
+ * called only by:
+ *   - hw/pci-host/piix.c|879| <<igd_pt_i440fx_realize>> host_pci_config_read(pos, len, &val, &local_err);
+ */
 static void host_pci_config_read(int pos, int len, uint32_t *val, Error **errp)
 {
     int rc, config_fd;
@@ -883,6 +992,10 @@ static const char *i440fx_pcihost_root_bus_path(PCIHostState *host_bridge,
     return "0000:00";
 }
 
+/*
+ * used only by:
+ *   - hw/pci-host/piix.c|938| <<i440fx_pcihost_class_init>> dc->props = i440fx_props;
+ */
 static Property i440fx_props[] = {
     DEFINE_PROP_SIZE(PCI_HOST_PROP_PCI_HOLE64_SIZE, I440FXState,
                      pci_hole64_size, I440FX_PCI_HOST_HOLE64_SIZE_DEFAULT),
@@ -891,6 +1004,12 @@ static Property i440fx_props[] = {
     DEFINE_PROP_END_OF_LIST(),
 };
 
+/*
+ * TypeInfo i440fx_pcihost_info.class_init = i440fx_pcihost_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void i440fx_pcihost_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(klass);
@@ -914,6 +1033,7 @@ static const TypeInfo i440fx_pcihost_info = {
 
 static void i440fx_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&i440fx_info);
     type_register_static(&igd_passthrough_i440fx_info);
     type_register_static(&piix3_pci_type_info);
@@ -922,4 +1042,8 @@ static void i440fx_register_types(void)
     type_register_static(&i440fx_pcihost_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(i440fx_register_types)
diff --git a/hw/pci/msi.c b/hw/pci/msi.c
index 5e05ce5..3229e38 100644
--- a/hw/pci/msi.c
+++ b/hw/pci/msi.c
@@ -337,6 +337,12 @@ void msi_send_message(PCIDevice *dev, MSIMessage msg)
     MemTxAttrs attrs = {};
 
     attrs.requester_id = pci_requester_id(dev);
+    /*
+     * 对于mmio, 会调用memory_region_dispatch_write()
+     *
+     * 在kvm上测试nvme的时候, ops是kvm_apic_io_ops
+     * 在x86_cpu_apic_realize()为apic重叠的部分设置的kvm_apic_io_ops
+     */
     address_space_stl_le(&dev->bus_master_as, msg.address, msg.data,
                          attrs, NULL);
 }
diff --git a/hw/pci/msix.c b/hw/pci/msix.c
index c944c02..7df54e0 100644
--- a/hw/pci/msix.c
+++ b/hw/pci/msix.c
@@ -142,6 +142,10 @@ static void msix_update_function_masked(PCIDevice *dev)
 }
 
 /* Handle MSI-X capability config write. */
+/*
+ * called by:
+ *   - hw/pci/pci.c|1405| <<pci_default_write_config>> msix_write_config(d, addr, val_in, l);
+ */
 void msix_write_config(PCIDevice *dev, uint32_t addr,
                        uint32_t val, int len)
 {
@@ -266,6 +270,17 @@ static void msix_mask_all(struct PCIDevice *dev, unsigned nentries)
  * also means a programming error, except device assignment, which can check
  * if a real HW is broken.
  */
+/*
+ * called by:
+ *   - hw/net/e1000e.c|292| <<e1000e_init_msix>> int res = msix_init(PCI_DEVICE(s), E1000E_MSIX_VEC_NUM,
+ *   - hw/net/rocker/rocker.c|1245| <<rocker_msix_init>> err = msix_init(dev, ROCKER_MSIX_VEC_COUNT(r->fp_ports),
+ *   - hw/net/vmxnet3.c|2217| <<vmxnet3_init_msix>> int res = msix_init(d, VMXNET3_MAX_INTRS,
+ *   - hw/pci/msix.c|371| <<msix_init_exclusive_bar>> ret = msix_init(dev, nentries, &dev->msix_exclusive_bar, bar_nr,
+ *   - hw/rdma/vmw/pvrdma_main.c|490| <<init_msix>> rc = msix_init(pdev, RDMA_MAX_INTRS, &dev->msix, RDMA_MSIX_BAR_IDX,
+ *   - hw/scsi/megasas.c|2351| <<megasas_scsi_realize>> msix_init(dev, 15, &s->mmio_io, b->mmio_bar, 0x2000,
+ *   - hw/usb/hcd-xhci.c|3432| <<usb_xhci_realize>> msix_init(dev, xhci->numintrs,
+ *   - hw/vfio/pci.c|1550| <<vfio_msix_setup>> ret = msix_init(&vdev->pdev, vdev->msix->entries,
+ */
 int msix_init(struct PCIDevice *dev, unsigned short nentries,
               MemoryRegion *table_bar, uint8_t table_bar_nr,
               unsigned table_offset, MemoryRegion *pba_bar,
@@ -476,6 +491,20 @@ int msix_enabled(PCIDevice *dev)
 }
 
 /* Send an MSI-X message */
+/*
+ * nvme的一个例子:
+ * (gdb) bt
+ * #0  msi_send_message (dev=0x555557adc1b0, msg=...) at hw/pci/msi.c:337
+ * #1  0x0000555555b3b2d2 in msix_notify (dev=0x555557adc1b0, vector=2) at hw/pci/msix.c:494
+ * #2  0x0000555555a5b4dc in nvme_irq_assert (n=0x555557adc1b0, cq=0x555557a81660) at hw/block/nvme.c:114
+ * #3  0x0000555555a5bf1b in nvme_post_cqes (opaque=0x555557a81660) at hw/block/nvme.c:275
+ * #4  0x0000555555d8d3a1 in timerlist_run_timers (timer_list=0x55555684f290) at util/qemu-timer.c:536
+ * #5  0x0000555555d8d3ed in qemu_clock_run_timers (type=QEMU_CLOCK_VIRTUAL) at util/qemu-timer.c:547
+ * #6  0x0000555555d8d7c2 in qemu_clock_run_all_timers () at util/qemu-timer.c:667
+ * #7  0x0000555555d8ded2 in main_loop_wait (nonblocking=0) at util/main-loop.c:503
+ * #8  0x00005555559d8681 in main_loop () at vl.c:1866
+ * #9  0x00005555559dfe85 in main (argc=16, argv=0x7fffffffe388, envp=0x7fffffffe410) at vl.c:4644
+ */
 void msix_notify(PCIDevice *dev, unsigned vector)
 {
     MSIMessage msg;
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index 80bc459..a2e429c 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -147,6 +147,9 @@ static uint16_t pcibus_numa_node(PCIBus *bus)
     return NUMA_NODE_UNASSIGNED;
 }
 
+/*
+ * TypeInfo pci_bus_info.class_init = pci_bus_class_init()
+ */
 static void pci_bus_class_init(ObjectClass *klass, void *data)
 {
     BusClass *k = BUS_CLASS(klass);
@@ -260,6 +263,11 @@ void pci_device_deassert_intx(PCIDevice *dev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|308| <<pci_device_reset>> pci_do_device_reset(dev);
+ *   - hw/pci/pci.c|323| <<pcibus_reset>> pci_do_device_reset(bus->devices[i]);
+ */
 static void pci_do_device_reset(PCIDevice *dev)
 {
     int r;
@@ -310,6 +318,10 @@ void pci_device_reset(PCIDevice *dev)
  * Called via qbus_reset_all on RST# assert, after the devices
  * have been reset qdev_reset_all-ed already.
  */
+/*
+ * used by:
+ *   - hw/pci/pci.c|163| <<pci_bus_class_init>> k->reset = pcibus_reset; k是BusClass, 在bus_set_realized()被调用
+ */
 static void pcibus_reset(BusState *qbus)
 {
     PCIBus *bus = DO_UPCAST(PCIBus, qbus, qbus);
@@ -362,6 +374,23 @@ const char *pci_root_bus_path(PCIDevice *dev)
     return rootbus->qbus.name;
 }
 
+/*
+ * nvme的例子, 就调用了一次
+ * (gdb) bt
+ * #0  pci_root_bus_init (bus=0x555556775ae0, parent=0x555556774010, address_space_mem=0x5555566721b0, 
+ *     address_space_io=0x5555565c8ff0, devfn_min=0 '\000') at hw/pci/pci.c:370
+ * #1  0x0000555555af3b4b in pci_root_bus_new (parent=0x555556774010, name=0x0, address_space_mem=0x5555566721b0, 
+ *     address_space_io=0x5555565c8ff0, devfn_min=0 '\000', typename=0x555555e21357 "PCI") at hw/pci/pci.c:411
+ * #2  0x0000555555aef008 in i440fx_init (host_type=0x555555da4eec "i440FX-pcihost", pci_type=0x555555da4ee5 "i440FX", 
+ *     pi440fx_state=0x7fffffffdfe8, piix3_devfn=0x7fffffffdfd8, isa_bus=0x7fffffffdfe0, pic=0x555556770450, 
+ *     address_space_mem=0x5555565c81f0, address_space_io=0x5555565c8ff0, ram_size=3145728000, below_4g_mem_size=3145728000, 
+ *     above_4g_mem_size=0, pci_address_space=0x5555566721b0, ram_memory=0x555556672600) at hw/pci-host/piix.c:364
+ * #3  0x00005555558e344f in pc_init1 (machine=0x5555565c6490, host_type=0x555555da4eec "i440FX-pcihost", 
+ *     pci_type=0x555555da4ee5 "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:198
+ * #4  0x00005555558e3d91 in pc_init_v3_0 (machine=0x5555565c6490) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #5  0x0000555555a359ed in machine_run_board_init (machine=0x5555565c6490) at hw/core/machine.c:830
+ * #6  0x000055555599dcb8 in main (argc=14, argv=0x7fffffffe438, envp=0x7fffffffe4b0) at vl.c:4516
+ */
 static void pci_root_bus_init(PCIBus *bus, DeviceState *parent,
                               MemoryRegion *address_space_mem,
                               MemoryRegion *address_space_io,
@@ -846,10 +875,15 @@ static void pci_init_multifunction(PCIBus *bus, PCIDevice *dev, Error **errp)
     }
 }
 
+/*
+ * called by only:
+ *   - hw/pci/pci.c|1037| <<do_pci_register_device>> pci_config_alloc(pci_dev);
+ */
 static void pci_config_alloc(PCIDevice *pci_dev)
 {
     int config_size = pci_config_size(pci_dev);
 
+    /* 下面全都是一个uint8_t的指针 */
     pci_dev->config = g_malloc0(config_size);
     pci_dev->cmask = g_malloc0(config_size);
     pci_dev->wmask = g_malloc0(config_size);
@@ -964,6 +998,76 @@ static bool pci_bus_devfn_reserved(PCIBus *bus, int devfn)
 }
 
 /* -1 for devfn means auto assign */
+/*
+ * called only by:
+ *   - hw/pci/pci.c|2021| <<pci_qdev_realize>> pci_dev = do_pci_register_device(pci_dev,
+ *
+ * hotplut一个e1000网卡的例子:
+ * (gdb) bt
+ * #0  do_pci_register_device (pci_dev=0x5555566fcc20, name=0x5555565190c0 "e1000", devfn=-1, errp=0x7fffffffcb60) at hw/pci/pci.c:970
+ * #1  0x0000555555af76d3 in pci_qdev_realize (qdev=0x5555566fcc20, errp=0x7fffffffcb60) at hw/pci/pci.c:2021
+ * #2  0x0000555555a2d447 in device_set_realized (obj=0x5555566fcc20, value=true, errp=0x7fffffffcd30) at hw/core/qdev.c:826
+ * #3  0x0000555555c21bc7 in property_set_bool (obj=0x5555566fcc20, v=0x5555574bba20, name=0x555555db778a "realized", opaque=0x5555569259d0, errp=0x7fffffffcd30)
+ *     at qom/object.c:1984
+ * #4  0x0000555555c1fe4c in object_property_set (obj=0x5555566fcc20, v=0x5555574bba20, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1176
+ * #5  0x0000555555c22f04 in object_property_set_qobject (obj=0x5555566fcc20, value=0x555557193700, name=0x555555db778a "realized", errp=0x7fffffffcd30)
+ *     at qom/qom-qobject.c:27
+ * #6  0x0000555555c20131 in object_property_set_bool (obj=0x5555566fcc20, value=true, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1242
+ * #7  0x0000555555990749 in qdev_device_add (opts=0x5555568b4290, errp=0x7fffffffcda0) at qdev-monitor.c:627
+ * #8  0x0000555555990f32 in qmp_device_add (qdict=0x555556ff10c0, ret_data=0x0, errp=0x7fffffffcde0) at qdev-monitor.c:807
+ * #9  0x00005555559bebd7 in hmp_device_add (mon=0x5555565fb820, qdict=0x555556ff10c0) at hmp.c:2008
+ * #10 0x00005555558230ac in handle_hmp_command (mon=0x5555565fb820, cmdline=0x5555565fe2cb "e1000,netdev=nd1") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #11 0x0000555555825467 in monitor_command_cb (opaque=0x5555565fb820, cmdline=0x5555565fe2c0 "device_add e1000,netdev=nd1", readline_opaque=0x0)
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #12 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565fe2c0, ch=13) at util/readline.c:393
+ * #13 0x00005555558253ba in monitor_read (opaque=0x5555565fb820, buf=0x7fffffffcfa0 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #14 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #15 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #16 0x0000555555cce691 in fd_chr_read (chan=0x5555565d35f0, cond=G_IO_IN, opaque=0x5555565d33e0) at chardev/char-fd.c:66
+ * #17 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x5555574b9b40, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d33e0)
+ *     at io/channel-watch.c:84
+ * #18 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #19 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #20 0x0000555555d4f990 in os_host_main_loop_wait (timeout=198513349) at util/main-loop.c:238
+ * #21 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #22 0x00005555559967aa in main_loop () at vl.c:1866
+ * #23 0x000055555599dfbd in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4644
+ *
+ *
+ * hotplug一个nvme的例子:
+ * (gdb) bt
+ * #0  memory_region_add_subregion (mr=0x55555706cae0, offset=0, subregion=0x55555706cbd0) at /home/zhang/kvm/qemu-3.0.0/memory.c:2327
+ * #1  0x0000555555af2ecb in pci_init_bus_master (pci_dev=0x55555706c870) at hw/pci/pci.c:97
+ * #2  0x0000555555af5249 in do_pci_register_device (pci_dev=0x55555706c870, name=0x5555564e9f40 "nvme", devfn=32, errp=0x7fffffffcbf0) at hw/pci/pci.c:1030
+ * #3  0x0000555555af76d3 in pci_qdev_realize (qdev=0x55555706c870, errp=0x7fffffffcbf0) at hw/pci/pci.c:2021
+ * #4  0x0000555555a2d447 in device_set_realized (obj=0x55555706c870, value=true, errp=0x7fffffffcdc0) at hw/core/qdev.c:826
+ * #5  0x0000555555c21bc7 in property_set_bool (obj=0x55555706c870, v=0x555556cfc690, name=0x555555db778a "realized", opaque=0x5555575902f0, errp=0x7fffffffcdc0)
+ *     at qom/object.c:1984
+ * #6  0x0000555555c1fe4c in object_property_set (obj=0x55555706c870, v=0x555556cfc690, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1176
+ * #7  0x0000555555c22f04 in object_property_set_qobject (obj=0x55555706c870, value=0x555557184ef0, name=0x555555db778a "realized", errp=0x7fffffffcdc0)
+ *     at qom/qom-qobject.c:27
+ * #8  0x0000555555c20131 in object_property_set_bool (obj=0x55555706c870, value=true, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1242
+ * #9  0x0000555555990749 in qdev_device_add (opts=0x555557185290, errp=0x7fffffffce30) at qdev-monitor.c:627
+ * #10 0x0000555555990f32 in qmp_device_add (qdict=0x555557164a40, ret_data=0x0, errp=0x7fffffffce70) at qdev-monitor.c:807
+ * #11 0x00005555559bebd7 in hmp_device_add (mon=0x5555565e0bd0, qdict=0x555557164a40) at hmp.c:2008
+ * #12 0x00005555558230ac in handle_hmp_command (mon=0x5555565e0bd0, cmdline=0x5555565f005b "nvme,drive=lightnvme,serial=deadbeaf1")
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #13 0x0000555555825467 in monitor_command_cb (opaque=0x5555565e0bd0, cmdline=0x5555565f0050 "device_add nvme,drive=lightnvme,serial=deadbeaf1", 
+ *     readline_opaque=0x0) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #14 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565f0050, ch=13) at util/readline.c:393
+ * #15 0x00005555558253ba in monitor_read (opaque=0x5555565e0bd0, buf=0x7fffffffd030 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #16 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #17 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #18 0x0000555555cce691 in fd_chr_read (chan=0x5555565d3310, cond=G_IO_IN, opaque=0x5555565d3100) at chardev/char-fd.c:66
+ * #19 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x555556ff37e0, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d3100)
+ *     at io/channel-watch.c:84
+ * #20 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #21 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #22 0x0000555555d4f990 in os_host_main_loop_wait (timeout=38256335) at util/main-loop.c:238
+ * #23 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #24 0x00005555559967aa in main_loop () at vl.c:1866
+ * #25 0x000055555599dfbd in main (argc=12, argv=0x7fffffffe4a8, envp=0x7fffffffe510) at vl.c:4644
+ */
 static PCIDevice *do_pci_register_device(PCIDevice *pci_dev,
                                          const char *name, int devfn,
                                          Error **errp)
@@ -1127,10 +1231,17 @@ void pci_register_bar(PCIDevice *pci_dev, int region_num,
     r->size = size;
     r->type = type;
     r->memory = memory;
+    /*
+     * address_space_io是MemoryRegion
+     */
     r->address_space = type & PCI_BASE_ADDRESS_SPACE_IO
                         ? pci_get_bus(pci_dev)->address_space_io
                         : pci_get_bus(pci_dev)->address_space_mem;
 
+    /*
+     * nvme调用到这里时r->address_space (MemoryRegion)的name是"pci"
+     */
+
     wmask = ~(size - 1);
     if (region_num == PCI_ROM_SLOT) {
         /* ROM enable bit is writable */
@@ -1211,11 +1322,21 @@ void pci_unregister_vga(PCIDevice *pci_dev)
     pci_dev->has_vga = false;
 }
 
+/*
+ * called by:
+ *   - hw/display/vmware_vga.c|863| <<vmsvga_value_read>> ret = pci_get_bar_addr(PCI_DEVICE(pci_vmsvga), 1);
+ *   - hw/display/vmware_vga.c|899| <<vmsvga_value_read>> ret = pci_get_bar_addr(PCI_DEVICE(pci_vmsvga), 2);
+ */
 pcibus_t pci_get_bar_addr(PCIDevice *pci_dev, int region_num)
 {
     return pci_dev->io_regions[region_num].addr;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|1313| <<pci_update_mappings>> new_addr = pci_bar_address(d, i, r->type, r->size);
+ *   - hw/pci/pci.c|2624| <<pci_dev_get_w64>> lob = pci_bar_address(dev, i, r->type, r->size);
+ */
 static pcibus_t pci_bar_address(PCIDevice *d,
 				int reg, uint8_t type, pcibus_t size)
 {
@@ -1288,6 +1409,158 @@ static pcibus_t pci_bar_address(PCIDevice *d,
     return new_addr;
 }
 
+/*
+ * nvme第一次的例子:
+ * (gdb) bt
+ * #0  pci_update_mappings (d=0x555557720d80) at hw/pci/pci.c:1297
+ * #1  0x0000555555af363d in pci_do_device_reset (dev=0x555557720d80) at hw/pci/pci.c:292
+ * #2  0x0000555555af36eb in pcibus_reset (qbus=0x555556775ae0) at hw/pci/pci.c:320
+ * #3  0x0000555555a2bfa3 in qbus_reset_one (bus=0x555556775ae0, opaque=0x0) at hw/core/qdev.c:259
+ * #4  0x0000555555a3110a in qbus_walk_children (bus=0x555556775ae0, pre_devfn=0x0, pre_busfn=0x0, 
+ *     post_devfn=0x555555a2bf20 <qdev_reset_one>, post_busfn=0x555555a2bf43 <qbus_reset_one>, opaque=0x0) at hw/core/bus.c:68
+ * #5  0x0000555555a2cb06 in qdev_walk_children (dev=0x555556774010, pre_devfn=0x0, pre_busfn=0x0, 
+ *     post_devfn=0x555555a2bf20 <qdev_reset_one>, post_busfn=0x555555a2bf43 <qbus_reset_one>, opaque=0x0) at hw/core/qdev.c:559
+ * #6  0x0000555555a310ce in qbus_walk_children (bus=0x555556624220, pre_devfn=0x0, pre_busfn=0x0, 
+ *     post_devfn=0x555555a2bf20 <qdev_reset_one>, post_busfn=0x555555a2bf43 <qbus_reset_one>, opaque=0x0) at hw/core/bus.c:59
+ * #7  0x0000555555a2c056 in qbus_reset_all (bus=0x555556624220) at hw/core/qdev.c:276
+ * #8  0x0000555555a2c079 in qbus_reset_all_fn (opaque=0x555556624220) at hw/core/qdev.c:282
+ * #9  0x0000555555a31a14 in qemu_devices_reset () at hw/core/reset.c:69
+ * #10 0x00005555558e2415 in pc_machine_reset () at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:2282
+ * #11 0x00005555559961c1 in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at vl.c:1645
+ * #12 0x000055555599dea6 in main (argc=14, argv=0x7fffffffe438, envp=0x7fffffffe4b0) at vl.c:4611
+ * (gdb) p d->name
+ * $7 = "nvme", '\000' <repeats 59 times>
+ *
+ * nvme多次到这里的例子:
+ * (gdb) bt
+ * #0  pci_update_mappings (d=0x5555579a9f90) at hw/pci/pci.c:1297
+ * #1  0x0000555555b358a3 in pci_default_write_config (d=0x5555579a9f90, addr=16, val_in=4294967295, l=4) at hw/pci/pci.c:1376
+ * #2  0x0000555555b3ebdc in pci_host_config_write_common (pci_dev=0x5555579a9f90, addr=16, limit=256, val=4294967295, len=4) at hw/pci/pci_host.c:66
+ * #3  0x0000555555b3ed04 in pci_data_write (s=0x5555569fed40, addr=2147491856, val=4294967295, len=4) at hw/pci/pci_host.c:100
+ * #4  0x0000555555b3ee30 in pci_host_data_write (opaque=0x5555569fca60, addr=0, val=4294967295, len=4) at hw/pci/pci_host.c:153
+ * #5  0x0000555555864b2d in memory_region_write_accessor (mr=0x5555569fce60, addr=0, value=0x7fffec8b07a8, size=4, shift=0, mask=4294967295, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #6  0x0000555555864d45 in access_with_adjusted_size (addr=0, value=0x7fffec8b07a8, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555864a43 <memory_region_write_accessor>, mr=0x5555569fce60, *     attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #7  0x000055555586796d in memory_region_dispatch_write (mr=0x5555569fce60, addr=0, data=4294967295, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #8  0x000055555580399f in flatview_write_continue (fv=0x7fffe0040b70, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4, addr1=0, l=4, mr=0x5555569fce60)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #9  0x0000555555803ae9 in flatview_write (fv=0x7fffe0040b70, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #10 0x0000555555803def in address_space_write (as=0x555556721a20 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #11 0x0000555555803e40 in address_space_rw (as=0x555556721a20 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4, is_write=true) at
+ *     /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #12 0x00005555558823ec in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7ff0000, direction=1, size=4, count=1) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1729
+ * #13 0x0000555555882b30 in kvm_cpu_exec (cpu=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1969
+ * #14 0x0000555555849eac in qemu_kvm_cpu_thread_fn (arg=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #15 0x0000555555d92dd7 in qemu_thread_start (args=0x5555568abcb0) at util/qemu-thread-posix.c:504
+ * #16 0x00007ffff4ca06ba in start_thread (arg=0x7fffec8b1700) at pthread_create.c:333
+ * #17 0x00007ffff49d641d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * e1000后来到这里的例子:
+ * (gdb) bt
+ * #0  pci_update_mappings (d=0x7fffe765e010) at hw/pci/pci.c:1297
+ * #1  0x0000555555b358a3 in pci_default_write_config (d=0x7fffe765e010, addr=16, val_in=4294967295, l=4) at hw/pci/pci.c:1376
+ * #2  0x0000555555af5d03 in e1000_write_config (pci_dev=0x7fffe765e010, address=16, val=4294967295, len=4) at hw/net/e1000.c:1647
+ * #3  0x0000555555b3ebdc in pci_host_config_write_common (pci_dev=0x7fffe765e010, addr=16, limit=256, val=4294967295, len=4) at hw/pci/pci_host.c:66
+ * #4  0x0000555555b3ed04 in pci_data_write (s=0x5555569fed40, addr=2147489808, val=4294967295, len=4) at hw/pci/pci_host.c:100
+ * #5  0x0000555555b3ee30 in pci_host_data_write (opaque=0x5555569fca60, addr=0, val=4294967295, len=4) at hw/pci/pci_host.c:153
+ * #6  0x0000555555864b2d in memory_region_write_accessor (mr=0x5555569fce60, addr=0, value=0x7fffec8b07a8, size=4, shift=0, mask=4294967295, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #7  0x0000555555864d45 in access_with_adjusted_size (addr=0, value=0x7fffec8b07a8, size=4, access_size_min=1, access_size_max=4, access_fn=0x555555864a43 <memory_region_write_accessor>, mr=0x5555569fce60,
+ *     attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #8  0x000055555586796d in memory_region_dispatch_write (mr=0x5555569fce60, addr=0, data=4294967295, size=4, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #9  0x000055555580399f in flatview_write_continue (fv=0x7fffe0040b70, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4, addr1=0, l=4, mr=0x5555569fce60)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #10 0x0000555555803ae9 in flatview_write (fv=0x7fffe0040b70, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #11 0x0000555555803def in address_space_write (as=0x555556721a20 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #12 0x0000555555803e40 in address_space_rw (as=0x555556721a20 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "\377\377\377\377", len=4, is_write=true) at 
+ *     /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #13 0x00005555558823ec in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7ff0000, direction=1, size=4, count=1) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1729
+ * #14 0x0000555555882b30 in kvm_cpu_exec (cpu=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1969
+ * #15 0x0000555555849eac in qemu_kvm_cpu_thread_fn (arg=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #16 0x0000555555d92dd7 in qemu_thread_start (args=0x5555568abcb0) at util/qemu-thread-posix.c:504
+ * #17 0x00007ffff4ca06ba in start_thread (arg=0x7fffec8b1700) at pthread_create.c:333
+ * #18 0x00007ffff49d641d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ *
+ * hotplug e1000网卡的例子:
+ * (gdb) bt
+ * #0  pci_update_mappings (d=0x5555566fcc20) at hw/pci/pci.c:1297
+ * #1  0x0000555555af623e in pci_default_write_config (d=0x5555566fcc20, addr=4, val_in=1024, l=2) at hw/pci/pci.c:1376
+ * #2  0x0000555555ab669e in e1000_write_config (pci_dev=0x5555566fcc20, address=4, val=1024, len=2) at hw/net/e1000.c:1647
+ * #3  0x0000555555aff577 in pci_host_config_write_common (pci_dev=0x5555566fcc20, addr=4, limit=256, val=1024, len=2) at hw/pci/pci_host.c:66
+ * #4  0x0000555555aff69f in pci_data_write (s=0x555556775930, addr=2147493892, val=1024, len=2) at hw/pci/pci_host.c:100
+ * #5  0x0000555555aff7cb in pci_host_data_write (opaque=0x555556773e60, addr=0, val=1024, len=2) at hw/pci/pci_host.c:153
+ * #6  0x000055555583317e in memory_region_write_accessor (mr=0x555556774260, addr=0, value=0x7fffec8be7a8, size=2, shift=0, mask=65535, attrs=...)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:527
+ * #7  0x0000555555833396 in access_with_adjusted_size (addr=0, value=0x7fffec8be7a8, size=2, access_size_min=1, access_size_max=4, 
+ *     access_fn=0x555555833094 <memory_region_write_accessor>, mr=0x555556774260, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #8  0x0000555555835fbe in memory_region_dispatch_write (mr=0x555556774260, addr=0, data=1024, size=2, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #9  0x00005555557d1ff8 in flatview_write_continue (fv=0x55555707ce00, addr=3324, attrs=..., buf=0x7ffff7ff0000 "", len=2, addr1=0, l=2, mr=0x555556774260)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #10 0x00005555557d2142 in flatview_write (fv=0x55555707ce00, addr=3324, attrs=..., buf=0x7ffff7ff0000 "", len=2) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #11 0x00005555557d2448 in address_space_write (as=0x555556498ae0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "", len=2)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #12 0x00005555557d2499 in address_space_rw (as=0x555556498ae0 <address_space_io>, addr=3324, attrs=..., buf=0x7ffff7ff0000 "", len=2, is_write=true)
+ *     at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #13 0x0000555555850a3d in kvm_handle_io (port=3324, attrs=..., data=0x7ffff7ff0000, direction=1, size=2, count=1)
+ *     at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1729
+ * #14 0x0000555555851181 in kvm_cpu_exec (cpu=0x555556600e30) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1969
+ * #15 0x0000555555818505 in qemu_kvm_cpu_thread_fn (arg=0x555556600e30) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #16 0x0000555555d54975 in qemu_thread_start (args=0x5555566230b0) at util/qemu-thread-posix.c:504
+ * #17 0x00007ffff55126ba in start_thread (arg=0x7fffec8bf700) at pthread_create.c:333
+ * #18 0x00007ffff524841d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ *
+ * nvme第一次到这里的例子
+ *   io_regions = {{
+ *       addr = 18446744073709551615, 
+ *       size = 8192, 
+ *       type = 4 '\004', 
+ *       memory = 0x5555579aa870,   (name="nvme", ops=nvme_mmio_ops) 
+ *       address_space = 0x5555568faff0  (name="pci", ops=unassigned_mem_ops, terminates = false)
+ *     }, {
+ *       addr = 0, 
+ *       size = 0, 
+ *       type = 0 '\000', 
+ *       memory = 0x0, 
+ *       address_space = 0x0
+ *     }, {
+ *       addr = 0, 
+ *       size = 0, 
+ *       type = 0 '\000', 
+ *       memory = 0x0, 
+ *       address_space = 0x0
+ *     }, {
+ *       addr = 0, 
+ *       size = 0, 
+ *       type = 0 '\000', 
+ *       memory = 0x0, 
+ *       address_space = 0x0
+ *     }, {
+ *       addr = 18446744073709551615, 
+ *       size = 4096, 
+ *       type = 0 '\000', 
+ *       memory = 0x5555579aa430,  (name="nvme-msix", ops=unassigned_mem_ops, terminates=false)
+ *       address_space = 0x5555568faff0 (name="pci", ops=unassigned_mem_ops, terminates = false)
+ *     }, {
+ *       addr = 0, 
+ *       size = 0, 
+ *       type = 0 '\000', 
+ *       memory = 0x0, 
+ *       address_space = 0x0
+ *     }, {
+ *       addr = 0, 
+ *       size = 0, 
+ *       type = 0 '\000', 
+ *       memory = 0x0, 
+ *       address_space = 0x0
+ *     }},
+ *
+ *
+ * bar的地址应该是guest (比如BIOS)更新的
+ *
+ * called by:
+ *   - hw/pci/pci.c|300| <<pci_do_device_reset>> pci_update_mappings(dev);
+ *   - hw/pci/pci.c|489| <<get_pci_config_device>> pci_update_mappings(s);
+ *   - hw/pci/pci.c|1407| <<pci_default_write_config>> pci_update_mappings(d);
+ */
 static void pci_update_mappings(PCIDevice *d)
 {
     PCIIORegion *r;
@@ -1301,6 +1574,7 @@ static void pci_update_mappings(PCIDevice *d)
         if (!r->size)
             continue;
 
+	/* nvme调用到这里时new_addr返回-1 */
         new_addr = pci_bar_address(d, i, r->type, r->size);
 
         /* This bar isn't changed */
@@ -1924,6 +2198,16 @@ static bool pci_root_bus_in_range(PCIBus *bus, int bus_num)
     return false;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|688| <<pci_get_bus_devfn>> return pci_find_bus_nr(root, 0);
+ *   - hw/pci/pci.c|701| <<pci_get_bus_devfn>> return pci_find_bus_nr(root, bus);
+ *   - hw/pci/pci.c|1608| <<pci_for_each_device_reverse>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|1635| <<pci_for_each_device>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|1724| <<qmp_query_pci_bridge>> PCIBus *child_bus = pci_find_bus_nr(bus, dev->config[PCI_SECONDARY_BUS]);
+ *   - hw/pci/pci.c|1805| <<qmp_query_pci_bus>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|2016| <<pci_find_device>> bus = pci_find_bus_nr(bus, bus_num);
+ */
 static PCIBus *pci_find_bus_nr(PCIBus *bus, int bus_num)
 {
     PCIBus *sec;
@@ -1932,6 +2216,10 @@ static PCIBus *pci_find_bus_nr(PCIBus *bus, int bus_num)
         return NULL;
     }
 
+    /*
+     * 如果参数中的bus就是要找的bus number 直接返回
+     * 否则要从child bus中继续找
+     */
     if (pci_bus_num(bus) == bus_num) {
         return bus;
     }
@@ -1992,6 +2280,9 @@ void pci_for_each_bus_depth_first(PCIBus *bus,
 }
 
 
+/*
+ * 被一群外部调用
+ */
 PCIDevice *pci_find_device(PCIBus *bus, int bus_num, uint8_t devfn)
 {
     bus = pci_find_bus_nr(bus, bus_num);
@@ -2002,6 +2293,26 @@ PCIDevice *pci_find_device(PCIBus *bus, int bus_num, uint8_t devfn)
     return bus->devices[devfn];
 }
 
+/*
+ * used by:
+ *   - hw/pci/pci.c|2557| <<pci_device_class_init>> k->realize = pci_qdev_realize;
+ *
+ * called by:
+ *   - hw/core/qdev.c|889| <<device_set_realized>> dc->realize(dev, &local_err);
+ *
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 static void pci_qdev_realize(DeviceState *qdev, Error **errp)
 {
     PCIDevice *pci_dev = (PCIDevice *)qdev;
@@ -2013,6 +2324,13 @@ static void pci_qdev_realize(DeviceState *qdev, Error **errp)
     /* initialize cap_present for pci_is_express() and pci_config_size(),
      * Note that hybrid PCIs are not set automatically and need to manage
      * QEMU_PCI_CAP_EXPRESS manually */
+    /*
+     * object_classs_dynamic_cast():
+     *     如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     *     一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     *     否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     *     在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_class_dynamic_cast(klass, INTERFACE_PCIE_DEVICE) &&
        !object_class_dynamic_cast(klass, INTERFACE_CONVENTIONAL_PCI_DEVICE)) {
         pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;
@@ -2048,6 +2366,20 @@ static void pci_qdev_realize(DeviceState *qdev, Error **errp)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci-bridge/dec.c|93| <<pci_dec_21154_init>> dev = pci_create_multifunction(parent_bus, devfn, false,
+ *   - hw/pci-bridge/xio3130_downstream.c|139| <<xio3130_downstream_init>> d = pci_create_multifunction(bus, devfn, multifunction,
+ *   - hw/pci-bridge/xio3130_upstream.c|119| <<xio3130_upstream_init>> d = pci_create_multifunction(bus, devfn, multifunction, "x3130-upstream");
+ *   - hw/pci-host/sabre.c|405| <<sabre_realize>> pci_dev = pci_create_multifunction(phb->bus, PCI_DEVFN(1, 0), true,
+ *   - hw/pci-host/sabre.c|411| <<sabre_realize>> pci_dev = pci_create_multifunction(phb->bus, PCI_DEVFN(1, 1), true,
+ *   - hw/pci/pci.c|2106| <<pci_create_simple_multifunction>> PCIDevice *dev = pci_create_multifunction(bus, devfn, multifunction, name);
+ *   - hw/pci/pci.c|2113| <<pci_create>> return pci_create_multifunction(bus, devfn, false, name);
+ *   - hw/sparc64/sun4u.c|581| <<sun4uv_init>> ebus = pci_create_multifunction(pci_busA, PCI_DEVFN(1, 0), true, TYPE_EBUS);
+ *   - hw/sparc64/sun4u.c|607| <<sun4uv_init>> pci_dev = pci_create_multifunction(pci_busA, PCI_DEVFN(1, 1),
+ *   - hw/usb/hcd-ehci-pci.c|273| <<ehci_create_ich9_with_companions>> ehci = pci_create_multifunction(bus, PCI_DEVFN(slot, 7), true, name);
+ *   - hw/usb/hcd-ehci-pci.c|278| <<ehci_create_ich9_with_companions>> uhci = pci_create_multifunction(bus, PCI_DEVFN(slot, comp[i].func),
+ */
 PCIDevice *pci_create_multifunction(PCIBus *bus, int devfn, bool multifunction,
                                     const char *name)
 {
@@ -2059,6 +2391,18 @@ PCIDevice *pci_create_multifunction(PCIBus *bus, int devfn, bool multifunction,
     return PCI_DEVICE(dev);
 }
 
+/*
+ * called by:
+ *   - hw/i2c/smbus_ich9.c|111| <<ich9_smb_init>> pci_create_simple_multifunction(bus, devfn, true, TYPE_ICH9_SMB_DEVICE);
+ *   - hw/i386/pc_q35.c|191| <<pc_q35_init>> lpc = pci_create_simple_multifunction(host_bus, PCI_DEVFN(ICH9_LPC_DEV,
+ *   - hw/i386/pc_q35.c|247| <<pc_q35_init>> ahci = pci_create_simple_multifunction(host_bus,
+ *   - hw/isa/piix4.c|106| <<piix4_init>> d = pci_create_simple_multifunction(bus, devfn, true, "PIIX4");
+ *   - hw/isa/vt82c686.c|486| <<vt82c686b_isa_init>> d = pci_create_simple_multifunction(bus, devfn, true,
+ *   - hw/mips/boston.c|520| <<boston_mach_init>> ahci = pci_create_simple_multifunction(&PCI_BRIDGE(&pcie2->root)->sec_bus,
+ *   - hw/pci-host/piix.c|415| <<i440fx_init>> PCIDevice *pci_dev = pci_create_simple_multifunction(b,
+ *   - hw/pci-host/piix.c|421| <<i440fx_init>> PCIDevice *pci_dev = pci_create_simple_multifunction(b,
+ *   - hw/pci/pci.c|2135| <<pci_create_simple>> return pci_create_simple_multifunction(bus, devfn, false, name);
+ */
 PCIDevice *pci_create_simple_multifunction(PCIBus *bus, int devfn,
                                            bool multifunction,
                                            const char *name)
@@ -2073,11 +2417,18 @@ PCIDevice *pci_create(PCIBus *bus, int devfn, const char *name)
     return pci_create_multifunction(bus, devfn, false, name);
 }
 
+/*
+ * 被很多外部调用
+ */
 PCIDevice *pci_create_simple(PCIBus *bus, int devfn, const char *name)
 {
     return pci_create_simple_multifunction(bus, devfn, false, name);
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|2297| <<pci_add_capability>> offset = pci_find_space(pdev, size);
+ */
 static uint8_t pci_find_space(PCIDevice *pdev, uint8_t size)
 {
     int offset = PCI_CONFIG_HEADER_SIZE;
@@ -2517,16 +2868,32 @@ MemoryRegion *pci_address_space_io(PCIDevice *dev)
     return pci_get_bus(dev)->address_space_io;
 }
 
+/*
+ * TypeInfo pci_device_type_info.class_init = pci_device_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void pci_device_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *k = DEVICE_CLASS(klass);
 
+    /*
+     * realize is called by:
+     *   - hw/core/qdev.c|860| <<device_set_realized>> dc->realize(dev, &local_err);
+     */
     k->realize = pci_qdev_realize;
     k->unrealize = pci_qdev_unrealize;
     k->bus_type = TYPE_PCI_BUS;
     k->props = pci_props;
 }
 
+/*
+ * TypeInfo pci_device_type_info.class_base_init = pci_device_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void pci_device_class_base_init(ObjectClass *klass, void *data)
 {
     if (!object_class_is_abstract(klass)) {
@@ -2669,6 +3036,11 @@ static const TypeInfo pci_device_type_info = {
 
 static void pci_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&pci_bus_info);
     type_register_static(&pcie_bus_info);
     type_register_static(&conventional_pci_interface_info);
@@ -2676,4 +3048,8 @@ static void pci_register_types(void)
     type_register_static(&pci_device_type_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(pci_register_types)
diff --git a/hw/pci/pci_host.c b/hw/pci/pci_host.c
index 5eaa935..0a4af82 100644
--- a/hw/pci/pci_host.c
+++ b/hw/pci/pci_host.c
@@ -42,6 +42,11 @@ do { printf("pci_host_data: " fmt , ## __VA_ARGS__); } while (0)
  */
 
 /* the helper function to get a PCIDevice* for a given pci address */
+/*
+ * called by:
+ *   - hw/pci/pci_host.c|91| <<pci_data_write>> PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);
+ *   - hw/pci/pci_host.c|106| <<pci_data_read>> PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);
+ */
 static inline PCIDevice *pci_dev_find_by_addr(PCIBus *bus, uint32_t addr)
 {
     uint8_t bus_num = addr >> 16;
@@ -104,6 +109,12 @@ void pci_data_write(PCIBus *s, uint32_t addr, uint32_t val, int len)
 uint32_t pci_data_read(PCIBus *s, uint32_t addr, int len)
 {
     PCIDevice *pci_dev = pci_dev_find_by_addr(s, addr);
+    /*
+     * PCI address
+     * bit 16 - 24: bus number
+     * bit  8 - 15: devfun number
+     * bit  0 -  7: offset in configuration space of a given pci device
+     */
     uint32_t config_addr = addr & (PCI_CONFIG_SPACE_SIZE - 1);
     uint32_t val;
 
diff --git a/hw/virtio/virtio-balloon.c b/hw/virtio/virtio-balloon.c
index 1f7a87f..e64942a 100644
--- a/hw/virtio/virtio-balloon.c
+++ b/hw/virtio/virtio-balloon.c
@@ -326,6 +326,12 @@ static int build_dimm_list(Object *obj, void *opaque)
 {
     GSList **list = opaque;
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_dynamic_cast(obj, TYPE_PC_DIMM)) {
         DeviceState *dev = DEVICE(obj);
         if (dev->realized) { /* only realized DIMMs matter */
diff --git a/include/exec/cpu-all.h b/include/exec/cpu-all.h
index 117d2fb..be3a9f7 100644
--- a/include/exec/cpu-all.h
+++ b/include/exec/cpu-all.h
@@ -219,7 +219,9 @@ extern int target_page_bits;
 #define TARGET_PAGE_BITS_MIN TARGET_PAGE_BITS
 #endif
 
+/* 0x1000 */
 #define TARGET_PAGE_SIZE (1 << TARGET_PAGE_BITS)
+/* 0xfffff000 */
 #define TARGET_PAGE_MASK ~(TARGET_PAGE_SIZE - 1)
 #define TARGET_PAGE_ALIGN(addr) (((addr) + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK)
 
diff --git a/include/exec/memory.h b/include/exec/memory.h
index 448d41a..121a6e2 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -32,6 +32,7 @@
 #define MAX_PHYS_ADDR_SPACE_BITS 62
 #define MAX_PHYS_ADDR            (((hwaddr)1 << MAX_PHYS_ADDR_SPACE_BITS) - 1)
 
+/* TypeInfo memory_region_info */
 #define TYPE_MEMORY_REGION "qemu:memory-region"
 #define MEMORY_REGION(obj) \
         OBJECT_CHECK(MemoryRegion, (obj), TYPE_MEMORY_REGION)
@@ -336,6 +337,18 @@ typedef struct IOMMUMemoryRegionClass {
 typedef struct CoalescedMemoryRange CoalescedMemoryRange;
 typedef struct MemoryRegionIoeventfd MemoryRegionIoeventfd;
 
+/*
+ * TYPE_MEMORY_REGION的instance
+ *
+ * MemoryRegion是树状父子结构的,每一个ramblock都有一个对应的MemoryRegion,
+ * 一般而言,这个MemoryRegion是最顶级的MemoryRegion,它还有很多子MemoryRegion,
+ * 比如在这个ramblock地址范围内的MMIO等.
+ *
+ * MemoryRegion有多种类型,可以表示一段ram,rom,MMIO,alias,alias表示一个
+ * MemoryRegion的一部分区域,MemoryRegion也可以表示一个container,这就表示它
+ * 只是其他若干个MemoryRegion的容器.在MemoryRegion中,'ram_block'表示的是分配
+ * 的实际内存.
+ */
 struct MemoryRegion {
     Object parent_obj;
 
@@ -343,6 +356,15 @@ struct MemoryRegion {
 
     /* The following fields should fit in a cache line */
     bool romd_mode;
+    /*
+     * 所有把ram设置成true的地方:
+     *   - memory.c|1986| <<memory_region_init_ram_shared_nomigrate>> mr->ram = true;
+     *   - memory.c|2004| <<memory_region_init_resizeable_ram>> mr->ram = true;
+     *   - memory.c|2023| <<memory_region_init_ram_from_file>> mr->ram = true;
+     *   - memory.c|2040| <<memory_region_init_ram_from_fd>> mr->ram = true;
+     *   - memory.c|2055| <<memory_region_init_ram_ptr>> mr->ram = true;
+     *   - memory.c|2118| <<memory_region_init_rom_nomigrate>> mr->ram = true;
+     */
     bool ram;
     bool subpage;
     bool readonly; /* For RAM regions */
@@ -351,21 +373,54 @@ struct MemoryRegion {
     bool global_locking;
     uint8_t dirty_log_mask;
     bool is_iommu;
+    /*
+     * 被以下初始化:
+     *   - memory.c|1647| <<memory_region_init_ram_shared_nomigrate>> mr->ram_block = qemu_ram_alloc(size, share, mr, errp);
+     *   - memory.c|1665| <<memory_region_init_resizeable_ram>> mr->ram_block = qemu_ram_alloc_resizeable(size, max_size, resized,
+     *   - memory.c|1685| <<memory_region_init_ram_from_file>> mr->ram_block = qemu_ram_alloc_from_file(size, mr, share, path, errp);
+     *   - memory.c|1701| <<memory_region_init_ram_from_fd>> mr->ram_block = qemu_ram_alloc_from_fd(size, mr, share, fd, errp);
+     *   - memory.c|1720| <<memory_region_init_ram_ptr>> mr->ram_block = qemu_ram_alloc_from_ptr(size, ptr, mr, &error_fatal);
+     *   - memory.c|1758| <<memory_region_init_rom_nomigrate>> mr->ram_block = qemu_ram_alloc(size, false, mr, errp);
+     *   - memory.c|1777| <<memory_region_init_rom_device_nomigrate>> mr->ram_block = qemu_ram_alloc(size, false, mr, errp);
+     */
     RAMBlock *ram_block;
     Object *owner;
 
     const MemoryRegionOps *ops;
     void *opaque;
+    /* 记录这个MemoryRegion是谁的subregion */
     MemoryRegion *container;
     Int128 size;
+    /* 在AddressSpace中的地址 */
     hwaddr addr;
     void (*destructor)(MemoryRegion *mr);
     uint64_t align;
+    /*
+     * 设置terminates的地方, 初始化默认是false吧:
+     *   - memory.c|1867| <<memory_region_init_io>> mr->terminates = true;
+     *   - memory.c|1900| <<memory_region_init_ram_shared_nomigrate>> mr->terminates = true;
+     *   - memory.c|1918| <<memory_region_init_resizeable_ram>> mr->terminates = true;
+     *   - memory.c|1937| <<memory_region_init_ram_from_file>> mr->terminates = true;
+     *   - memory.c|1954| <<memory_region_init_ram_from_fd>> mr->terminates = true;
+     *   - memory.c|1969| <<memory_region_init_ram_ptr>> mr->terminates = true;
+     *   - memory.c|2020| <<memory_region_init_rom_nomigrate>> mr->terminates = true;
+     *   - memory.c|2038| <<memory_region_init_rom_device_nomigrate>> mr->terminates = true;
+     *   - memory.c|2058| <<memory_region_init_iommu>> mr->terminates = true;
+     *
+     * 使用的地方:
+     *   - memory.c|923| <<render_memory_region>> if (!mr->terminates) {
+     *   - memory.c|995| <<memory_region_get_flatview_root>> } else if (!mr->terminates) {
+     *
+     * 好像没有subregion的会设置成true
+     */
     bool terminates;
     bool ram_device;
     bool enabled;
     bool warning_printed; /* For reservations */
     uint8_t vga_logging_count;
+    /*
+     * alias表明此MemoryRegion是另外一个MemoryRegion的一部分的alias
+     */
     MemoryRegion *alias;
     hwaddr alias_offset;
     int32_t priority;
@@ -374,6 +429,22 @@ struct MemoryRegion {
     QTAILQ_HEAD(coalesced_ranges, CoalescedMemoryRange) coalesced;
     const char *name;
     unsigned ioeventfd_nb;
+    /*
+     * 主要用到ioeventfds的地方:
+     *   - accel/kvm/kvm-all.c -- kvm_check_many_ioeventfds()
+     *   - hw/vfio/pci-quirks.c -- vfio_quirk_alloc()
+     *   - hw/vfio/pci-quirks.c -- vfio_drop_dynamic_eventfds()
+     *   - hw/vfio/pci-quirks.c -- vfio_nvidia_quirk_mirror_write()
+     *   - hw/vfio/pci-quirks.c -- vfio_bar_quirk_exit()
+     *   - hw/vfio/pci-quirks.c -- vfio_bar_quirk_exit()
+     *   - memory.c -- memory_region_add_eventfd()
+     *   - memory.c -- memory_region_del_eventfd()
+     *   - memory.c -- address_space_update_ioeventfds()
+     *   - memory.c -- memory_region_dispatch_write_eventfds()
+     *   - memory.c -- memory_region_finalize()
+     *   - memory.c -- address_space_init()
+     *   - memory.c -- do_address_space_destroy()
+     */
     MemoryRegionIoeventfd *ioeventfds;
 };
 
@@ -394,8 +465,23 @@ struct IOMMUMemoryRegion {
  * Use with memory_listener_register() and memory_listener_unregister().
  */
 struct MemoryListener {
+    /*
+     * 设置begin的地方:
+     *   - hw/virtio/vhost.c|1232| <<vhost_dev_init>> .begin = vhost_begin,
+     */
     void (*begin)(MemoryListener *listener);
+    /*
+     * 设置commit的地方:
+     *   - hw/virtio/vhost.c|1233| <<vhost_dev_init>> .commit = vhost_commit,
+     *   - hw/virtio/virtio.c|2532| <<virtio_device_realize>> vdev->listener.commit = virtio_memory_listener_commit;
+     *   - exec.c|1149| <<cpu_address_space_init>> newas->tcg_as_listener.commit = tcg_commit;
+     */
     void (*commit)(MemoryListener *listener);
+    /*
+     * called only by:
+     *   - address_space_update_topology_pass()
+     *   - listener_add_address_space()
+     */
     void (*region_add)(MemoryListener *listener, MemoryRegionSection *section);
     void (*region_del)(MemoryListener *listener, MemoryRegionSection *section);
     void (*region_nop)(MemoryListener *listener, MemoryRegionSection *section);
@@ -406,6 +492,12 @@ struct MemoryListener {
     void (*log_sync)(MemoryListener *listener, MemoryRegionSection *section);
     void (*log_global_start)(MemoryListener *listener);
     void (*log_global_stop)(MemoryListener *listener);
+    /*
+     * 设置eventfd_add的地方:
+     *   - accel/kvm/kvm-all.c|919| <<global>> .eventfd_add = kvm_io_ioeventfd_add,
+     *   - accel/kvm/kvm-all.c|1707| <<kvm_init>> s->memory_listener.listener.eventfd_add = kvm_mem_ioeventfd_add;
+     *   - hw/virtio/vhost.c|1241| <<vhost_dev_init>> .eventfd_add = vhost_eventfd_add,
+     */
     void (*eventfd_add)(MemoryListener *listener, MemoryRegionSection *section,
                         bool match_data, uint64_t data, EventNotifier *e);
     void (*eventfd_del)(MemoryListener *listener, MemoryRegionSection *section,
@@ -424,6 +516,10 @@ struct MemoryListener {
 /**
  * AddressSpace: describes a mapping of addresses to #MemoryRegion objects
  */
+/*
+ * qemu中用AddressSpace用来表示CPU/设备看到的内存,一个AddressSpace下面包含
+ * 多个MemoryRegion,这些MemoryRegion结构通过树连接起来,树的根是AddressSpace的root域
+ */
 struct AddressSpace {
     /* All fields are private. */
     struct rcu_head rcu;
@@ -431,11 +527,58 @@ struct AddressSpace {
     MemoryRegion *root;
 
     /* Accessed via RCU.  */
+    /*
+     * AddressSpace的一张平面视图,它是AddressSpace所有正在使用的MemoryRegion的集合,这是从CPU的视角来看到的
+     */
     struct FlatView *current_map;
 
     int ioeventfd_nb;
+    /*
+     * 主要用到ioeventfds的地方:
+     *   - accel/kvm/kvm-all.c -- kvm_check_many_ioeventfds()
+     *   - hw/vfio/pci-quirks.c -- vfio_quirk_alloc()
+     *   - hw/vfio/pci-quirks.c -- vfio_drop_dynamic_eventfds()
+     *   - hw/vfio/pci-quirks.c -- vfio_nvidia_quirk_mirror_write()
+     *   - hw/vfio/pci-quirks.c -- vfio_bar_quirk_exit()
+     *   - hw/vfio/pci-quirks.c -- vfio_bar_quirk_exit()
+     *   - memory.c -- memory_region_add_eventfd()
+     *   - memory.c -- memory_region_del_eventfd()
+     *   - memory.c -- address_space_update_ioeventfds()
+     *   - memory.c -- memory_region_dispatch_write_eventfds()
+     *   - memory.c -- memory_region_finalize()
+     *   - memory.c -- address_space_init()
+     *   - memory.c -- do_address_space_destroy()
+     */
     struct MemoryRegionIoeventfd *ioeventfds;
+    /*
+     * 使用listerner的地方:
+     *   - memory.c|162| <<MEMORY_LISTENER_CALL>> struct memory_listeners_as *list = &(_as)->listeners; \
+     *   - memory.c|1034| <<address_space_set_flatview>> if (!QTAILQ_EMPTY(&as->listeners)) {
+     *   - memory.c|2777| <<memory_listener_register>> if (QTAILQ_EMPTY(&as->listeners)
+     *   - memory.c|2778| <<memory_listener_register>> || listener->priority >= QTAILQ_LAST(&as->listeners,
+     *   - memory.c|2780| <<memory_listener_register>> QTAILQ_INSERT_TAIL(&as->listeners, listener, link_as);
+     *   - memory.c|2782| <<memory_listener_register>> QTAILQ_FOREACH(other, &as->listeners, link_as) {
+     *   - memory.c|2801| <<memory_listener_unregister>> QTAILQ_REMOVE(&listener->address_space->listeners, listener, link_as);
+     *   - memory.c|2931| <<address_space_init>> QTAILQ_INIT(&as->listeners);
+     *   - memory.c|2944| <<do_address_space_destroy>> assert(QTAILQ_EMPTY(&as->listeners));
+     */
     QTAILQ_HEAD(memory_listeners_as, MemoryListener) listeners;
+    /*
+     * 添加:
+     *   - memory.c|2933| <<address_space_init>> QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
+     *
+     * 删除:
+     *   - memory.c|2960| <<address_space_destroy>> QTAILQ_REMOVE(&address_spaces, as, address_spaces_link);
+     *
+     * 使用:
+     *   - memory.c|638| <<memory_region_to_address_space>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|1005| <<flatviews_reset>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|1096| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|1104| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|2260| <<memory_region_update_coalesced_range>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|3255| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     *   - memory.c|3279| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+     */
     QTAILQ_ENTRY(AddressSpace) address_spaces_link;
 };
 
@@ -448,15 +591,25 @@ typedef struct FlatRange FlatRange;
 struct FlatView {
     struct rcu_head rcu;
     unsigned ref;
+    /* nr_allocated个 数组 */
     FlatRange *ranges;
+    /* 当前正在使用的ranges */
     unsigned nr;
+    /* ranges数组中元素的数目 */
     unsigned nr_allocated;
     struct AddressSpaceDispatch *dispatch;
     MemoryRegion *root;
 };
 
+/*
+ * 返回AddressSpace的current_map
+ */
 static inline FlatView *address_space_to_flatview(AddressSpace *as)
 {
+    /*
+     * current_map是AddressSpace的一张平面视图,它是AddressSpace
+     * 所有正在使用的MemoryRegion的集合,这是从CPU的视角来看到的
+     */
     return atomic_rcu_read(&as->current_map);
 }
 
diff --git a/include/exec/ram_addr.h b/include/exec/ram_addr.h
index cf4ce06..0f12b75 100644
--- a/include/exec/ram_addr.h
+++ b/include/exec/ram_addr.h
@@ -23,10 +23,21 @@
 #include "hw/xen/xen.h"
 #include "exec/ramlist.h"
 
+/*
+ * 是真正分配了host内存的地方
+ *
+ * 每一个ram_block还会被连接到全局的'ram_list'链表上
+ */
 struct RAMBlock {
     struct rcu_head rcu;
     struct MemoryRegion *mr;
+    /*
+     * 'host'指向了动态分配的内存,用于表示实际的虚拟机物理内存
+     */
     uint8_t *host;
+    /*
+     * offset表示了这块内存在虚拟机物理内存中的偏移
+     */
     ram_addr_t offset;
     ram_addr_t used_length;
     ram_addr_t max_length;
diff --git a/include/hw/boards.h b/include/hw/boards.h
index d139a43..42479d0 100644
--- a/include/hw/boards.h
+++ b/include/hw/boards.h
@@ -48,6 +48,7 @@ void memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner,
  */
 #define MACHINE_TYPE_NAME(machinename) (machinename TYPE_MACHINE_SUFFIX)
 
+/* TypeInfo machine_info */
 #define TYPE_MACHINE "machine"
 #undef MACHINE  /* BSD defines it and QEMU does not use it */
 #define MACHINE(obj) \
@@ -169,7 +170,18 @@ struct MachineClass {
     const char *desc;
     const char *deprecation_reason;
 
+    /*
+     * called by:
+     *   - hw/core/machine.c|870| <<machine_run_board_init>> machine_class->init(machine);
+     *
+     * 在以下初始化:
+     *   - init是在DEFINE_PC_MACHINE()初始化的
+     */
     void (*init)(MachineState *state);
+    /*
+     * called by:
+     *   - vl.c|1645| <<qemu_system_reset>> mc->reset();
+     */
     void (*reset)(void);
     void (*hot_add_cpu)(const int64_t id, Error **errp);
     int (*kvm_type)(const char *arg);
@@ -258,6 +270,10 @@ struct MachineState {
     char *memory_encryption;
     DeviceMemoryState *device_memory;
 
+    /*
+     * 设定的地方:
+     *   - vl.c|4581| <<main>> current_machine->ram_size = ram_size;
+     */
     ram_addr_t ram_size;
     ram_addr_t maxram_size;
     uint64_t   ram_slots;
diff --git a/include/hw/i386/pc.h b/include/hw/i386/pc.h
index 6894f37..f1fad21 100644
--- a/include/hw/i386/pc.h
+++ b/include/hw/i386/pc.h
@@ -37,7 +37,7 @@ struct PCMachineState {
     /* Pointers to devices and objects: */
     HotplugHandler *acpi_dev;
     ISADevice *rtc;
-    PCIBus *bus;
+    PCIBus *bus;  // 有pci bus!
     FWCfgState *fw_cfg;
     qemu_irq *gsi;
 
@@ -136,6 +136,16 @@ struct PCMachineClass {
     bool linuxboot_dma_enabled;
 };
 
+/* TypeInfo pc_machine_info */
+/*
+ * TYPE_PC_MACHINE is used by:
+ *   - hw/i386/x86-iommu.c|88| <<x86_iommu_realize>> PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));
+ *   - include/hw/i386/pc.h|142| <<PC_MACHINE>> OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|144| <<PC_MACHINE_GET_CLASS>> OBJECT_GET_CLASS(PCMachineClass, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|146| <<PC_MACHINE_CLASS>> OBJECT_CLASS_CHECK(PCMachineClass, (klass), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|954| <<DEFINE_PC_MACHINE>> .parent = TYPE_PC_MACHINE, \
+ *   - target/i386/kvm.c|1455| <<kvm_arch_init>> object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE) &&
+ */
 #define TYPE_PC_MACHINE "generic-pc-machine"
 #define PC_MACHINE(obj) \
     OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
@@ -248,7 +258,9 @@ extern int no_hpet;
 struct PCII440FXState;
 typedef struct PCII440FXState PCII440FXState;
 
+/* TypeInfo i440fx_pcihost_info */
 #define TYPE_I440FX_PCI_HOST_BRIDGE "i440FX-pcihost"
+/* TypeInfo i440fx_info */
 #define TYPE_I440FX_PCI_DEVICE "i440FX"
 
 #define TYPE_IGD_PASSTHROUGH_I440FX_PCI_DEVICE "igd-passthrough-i440FX"
@@ -941,6 +953,69 @@ bool e820_get_entry(int, uint32_t, uint64_t *, uint64_t *);
         .value = "off",\
     },
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|1136| <<global>> DEFINE_PC_MACHINE(isapc, "isapc", pc_init_isa,
+ *   - hw/i386/pc_piix.c|1148| <<global>> DEFINE_PC_MACHINE(xenfv, "xenfv", pc_xen_hvm_init,
+ *   - hw/i386/pc_piix.c|417| <<DEFINE_I440FX_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *   - hw/i386/pc_q35.c|294| <<DEFINE_Q35_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *
+ * (gdb) p *machine_class
+ * $3 = {
+ *   parent_class = {
+ *     type = 0x555556785020, 
+ *     interfaces = 0x555556827780, 
+ *     object_cast_cache = {0x555555ea72b8 "generic-pc-machine", 0x555555ebd4f6 "machine", 0x555555eb8280 "generic-pc-machine", 0x555555f427bd "machine"}, 
+ *     class_cast_cache = {0x555555ea870d "generic-pc-machine", 0x555555e9299a "machine", 0x555555ee2032 "machine", 0x555555e8e912 "machine"}, 
+ *     unparent = 0x0, 
+ *     properties = 0x555556834300
+ *   }, 
+ *   family = 0x555555ea889e "pc_piix", 
+ *   name = 0x555556836d90 "pc-i440fx-3.0", 
+ *   alias = 0x555555ea88c7 "pc", 
+ *   desc = 0x555555ea8788 "Standard PC (i440FX + PIIX, 1996)", 
+ *   deprecation_reason = 0x0, 
+ *   init = 0x55555591d9e4 <pc_init_v3_0>, 
+ *   reset = 0x55555591bfcd <pc_machine_reset>, 
+ *   hot_add_cpu = 0x55555591851d <pc_hot_add_cpu>, 
+ *   kvm_type = 0x0, 
+ *   block_default_type = IF_IDE, 
+ *   units_per_default_bus = 0, 
+ *   max_cpus = 255, 
+ *   min_cpus = 1, 
+ *   default_cpus = 1, 
+ *   no_serial = 0, 
+ *   no_parallel = 0, 
+ *   use_virtcon = 0, 
+ *   no_floppy = 0, 
+ *   no_cdrom = 0, 
+ *   no_sdcard = 0, 
+ *   pci_allow_0_address = 0, 
+ *   legacy_fw_cfg_order = 0, 
+ *   is_default = 1, 
+ *   default_machine_opts = 0x555555ea88a6 "firmware=bios-256k.bin", 
+ *   default_boot_order = 0x555555ea7de8 "cad", 
+ *   default_display = 0x555555ea88bd "std", 
+ *   compat_props = 0x0, 
+ *   hw_version = 0x0, 
+ *   default_ram_size = 134217728, 
+ *   default_cpu_type = 0x555555ea7dec "qemu64-x86_64-cpu", 
+ *   option_rom_has_mr = false, 
+ *   rom_file_has_mr = true, 
+ *   minimum_page_bits = 0, 
+ *   has_hotpluggable_cpus = true, 
+ *   ignore_memory_transaction_failures = false, 
+ *   numa_mem_align_shift = 23, 
+ *   valid_cpu_types = 0x0,
+ *   allowed_dynamic_sysbus_devices = 0x555556836db0, 
+ *   auto_enable_numa_with_memhp = true, 
+ *   numa_auto_assign_ram = 0x55555585eed8 <numa_default_auto_assign_ram>, 
+ *   get_hotplug_handler = 0x55555591b5fe <pc_get_hotpug_handler>, 
+ *   cpu_index_to_instance_props = 0x55555591c04d <pc_cpu_index_to_props>, 
+ *   possible_cpu_arch_ids = 0x55555591c1fd <pc_possible_cpu_arch_ids>, 
+ *   get_default_cpu_node_id = 0x55555591c138 <pc_get_default_cpu_node_id>
+ * }
+ */
 #define DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn) \
     static void pc_machine_##suffix##_class_init(ObjectClass *oc, void *data) \
     { \
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 990d6fc..e6362d8 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -191,6 +191,7 @@ enum {
     QEMU_PCIE_EXTCAP_INIT = (1 << QEMU_PCIE_EXTCAP_INIT_BITNR),
 };
 
+/* TypeInfo pci_device_type_info */
 #define TYPE_PCI_DEVICE "pci-device"
 #define PCI_DEVICE(obj) \
      OBJECT_CHECK(PCIDevice, (obj), TYPE_PCI_DEVICE)
@@ -200,6 +201,7 @@ enum {
      OBJECT_GET_CLASS(PCIDeviceClass, (obj), TYPE_PCI_DEVICE)
 
 /* Implemented by devices that can be plugged on PCI Express buses */
+/* TypeInfo pcie_interface_info */
 #define INTERFACE_PCIE_DEVICE "pci-express-device"
 
 /* Implemented by devices that can be plugged on Conventional PCI buses */
@@ -388,10 +390,16 @@ typedef void (*pci_set_irq_fn)(void *opaque, int irq_num, int level);
 typedef int (*pci_map_irq_fn)(PCIDevice *pci_dev, int irq_num);
 typedef PCIINTxRoute (*pci_route_irq_fn)(void *opaque, int pin);
 
+/* TypeInfo pci_bus_info */
 #define TYPE_PCI_BUS "PCI"
 #define PCI_BUS(obj) OBJECT_CHECK(PCIBus, (obj), TYPE_PCI_BUS)
 #define PCI_BUS_CLASS(klass) OBJECT_CLASS_CHECK(PCIBusClass, (klass), TYPE_PCI_BUS)
 #define PCI_BUS_GET_CLASS(obj) OBJECT_GET_CLASS(PCIBusClass, (obj), TYPE_PCI_BUS)
+/*
+ * TypeInfo pcie_bus_info
+ *
+ * TYPE_PCIE_BUS的parent是TYPE_PCI_BUS
+ */
 #define TYPE_PCIE_BUS "PCIE"
 
 bool pci_bus_is_express(PCIBus *bus);
diff --git a/include/hw/pci/pci_bus.h b/include/hw/pci/pci_bus.h
index b7da8f5..72ba5ac 100644
--- a/include/hw/pci/pci_bus.h
+++ b/include/hw/pci/pci_bus.h
@@ -28,6 +28,7 @@ struct PCIBus {
     pci_map_irq_fn map_irq;
     pci_route_irq_fn route_intx_to_irq;
     void *irq_opaque;
+    /* 挂载着这个pci bus的所有device */
     PCIDevice *devices[PCI_SLOT_MAX * PCI_FUNC_MAX];
     PCIDevice *parent_dev;
     MemoryRegion *address_space_mem;
diff --git a/include/hw/pci/pci_host.h b/include/hw/pci/pci_host.h
index ba31595..d48abbc 100644
--- a/include/hw/pci/pci_host.h
+++ b/include/hw/pci/pci_host.h
@@ -30,6 +30,7 @@
 
 #include "hw/sysbus.h"
 
+/* TypeInfo pci_host_type_info */
 #define TYPE_PCI_HOST_BRIDGE "pci-host-bridge"
 #define PCI_HOST_BRIDGE(obj) \
     OBJECT_CHECK(PCIHostState, (obj), TYPE_PCI_HOST_BRIDGE)
diff --git a/include/hw/qdev-core.h b/include/hw/qdev-core.h
index f1fd0f8..5e69ab8 100644
--- a/include/hw/qdev-core.h
+++ b/include/hw/qdev-core.h
@@ -11,6 +11,7 @@ enum {
     DEV_NVECTORS_UNSPECIFIED = -1,
 };
 
+/* TypeInfo device_type_info: hw/core/qdev.c */
 #define TYPE_DEVICE "device"
 #define DEVICE(obj) OBJECT_CHECK(DeviceState, (obj), TYPE_DEVICE)
 #define DEVICE_CLASS(klass) OBJECT_CLASS_CHECK(DeviceClass, (klass), TYPE_DEVICE)
@@ -107,6 +108,10 @@ typedef struct DeviceClass {
 
     /* callbacks */
     DeviceReset reset;
+    /*
+     * called by:
+     *   - hw/core/qdev.c|860| <<device_set_realized>> dc->realize(dev, &local_err);
+     */
     DeviceRealize realize;
     DeviceUnrealize unrealize;
 
@@ -159,6 +164,7 @@ struct DeviceListener {
     QTAILQ_ENTRY(DeviceListener) link;
 };
 
+/* TypeInfo bus_info */
 #define TYPE_BUS "bus"
 #define BUS(obj) OBJECT_CHECK(BusState, (obj), TYPE_BUS)
 #define BUS_CLASS(klass) OBJECT_CLASS_CHECK(BusClass, (klass), TYPE_BUS)
@@ -177,6 +183,10 @@ struct BusClass {
      */
     char *(*get_fw_dev_path)(DeviceState *dev);
     void (*reset)(BusState *bus);
+    /*
+     * called by:
+     *   - hw/core/bus.c|193| <<bus_set_realized>> bc->realize(bus, &local_err);
+     */
     BusRealize realize;
     BusUnrealize unrealize;
 
diff --git a/include/hw/qdev-properties.h b/include/hw/qdev-properties.h
index 4f60cc8..6d678d2 100644
--- a/include/hw/qdev-properties.h
+++ b/include/hw/qdev-properties.h
@@ -70,6 +70,17 @@ extern const PropertyInfo qdev_prop_off_auto_pcibar;
         .defval.u  = (bool)_defval,                              \
         }
 
+/*
+ * 一个例子:
+ *   _name   = "num_queues"
+ *   _state  = NvmeCtrl
+ *   _field  = num_queues
+ *   _defval = 64
+ *   _prop   = qdev_prop_uint32
+ *   _type   = uint32_t
+ *
+ * 定义了一个struct Property
+ */
 #define DEFINE_PROP_UNSIGNED(_name, _state, _field, _defval, _prop, _type) { \
         .name      = (_name),                                           \
         .info      = &(_prop),                                          \
@@ -156,6 +167,10 @@ extern const PropertyInfo qdev_prop_off_auto_pcibar;
     DEFINE_PROP_UNSIGNED(_n, _s, _f, _d, qdev_prop_uint8, uint8_t)
 #define DEFINE_PROP_UINT16(_n, _s, _f, _d)                      \
     DEFINE_PROP_UNSIGNED(_n, _s, _f, _d, qdev_prop_uint16, uint16_t)
+/*
+ * 一个例子:
+ *   DEFINE_PROP_UINT32("num_queues", NvmeCtrl, num_queues, 64),
+ */
 #define DEFINE_PROP_UINT32(_n, _s, _f, _d)                      \
     DEFINE_PROP_UNSIGNED(_n, _s, _f, _d, qdev_prop_uint32, uint32_t)
 #define DEFINE_PROP_INT32(_n, _s, _f, _d)                      \
diff --git a/include/hw/sysbus.h b/include/hw/sysbus.h
index 0b59a3b..71e00ab 100644
--- a/include/hw/sysbus.h
+++ b/include/hw/sysbus.h
@@ -14,6 +14,7 @@
 
 typedef struct SysBusDevice SysBusDevice;
 
+/* TypeInfo sysbus_device_type_info */
 #define TYPE_SYS_BUS_DEVICE "sys-bus-device"
 #define SYS_BUS_DEVICE(obj) \
      OBJECT_CHECK(SysBusDevice, (obj), TYPE_SYS_BUS_DEVICE)
diff --git a/include/qapi/qmp/qobject.h b/include/qapi/qmp/qobject.h
index fcfd549..5af95ff 100644
--- a/include/qapi/qmp/qobject.h
+++ b/include/qapi/qmp/qobject.h
@@ -41,6 +41,9 @@ struct QObjectBase_ {
 };
 
 /* this struct must have no other members than base */
+/*
+ * 作为root存储在QObjectInputVisitor
+ */
 struct QObject {
     struct QObjectBase_ base;
 };
diff --git a/include/qemu/module.h b/include/qemu/module.h
index 54300ab..54f79db 100644
--- a/include/qemu/module.h
+++ b/include/qemu/module.h
@@ -39,6 +39,16 @@ static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \
 }
 #endif
 
+/*
+ * 所有注册的module_init_type在以下调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * module_call_init()遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
+
 typedef enum {
     MODULE_INIT_BLOCK,
     MODULE_INIT_OPTS,
@@ -49,6 +59,10 @@ typedef enum {
 
 #define block_init(function) module_init(function, MODULE_INIT_BLOCK)
 #define opts_init(function) module_init(function, MODULE_INIT_OPTS)
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 #define type_init(function) module_init(function, MODULE_INIT_QOM)
 #define trace_init(function) module_init(function, MODULE_INIT_TRACE)
 
diff --git a/include/qom/object.h b/include/qom/object.h
index f0b0bf3..cc11938 100644
--- a/include/qom/object.h
+++ b/include/qom/object.h
@@ -17,6 +17,12 @@
 #include "qapi/qapi-builtin-types.h"
 #include "qemu/queue.h"
 
+/*
+ * 核心函数:
+ *   - type_initialize()
+ *   - object_initialize_with_type()
+ */
+
 struct TypeImpl;
 typedef struct TypeImpl *Type;
 
@@ -28,6 +34,7 @@ typedef struct TypeInfo TypeInfo;
 typedef struct InterfaceClass InterfaceClass;
 typedef struct InterfaceInfo InterfaceInfo;
 
+/* TypeInfo object_info */
 #define TYPE_OBJECT "object"
 
 /**
@@ -388,10 +395,28 @@ typedef void (ObjectFree)(void *obj);
  * The base for all classes.  The only thing that #ObjectClass contains is an
  * integer type handle.
  */
+/*
+ * 所有class_size()里的祖先都是ObjectClass
+ *
+ * 关注: type_initialize()
+ */
 struct ObjectClass
 {
     /*< private >*/
-    Type type;
+    Type type;  // 定义typedef struct TypeImpl *Type;
+    /*
+     * 插入新元素的地方:
+     *   - qom/object.c|472| <<type_initialize_interface>> ti->class->interfaces = g_slist_append(ti->class->interfaces,
+     *
+     * 用到的地方:
+     *   - qom/object.c|486| <<type_initialize_interface>> ti->class->interfaces = g_slist_append(ti->class->interfaces,
+     *   - qom/object.c|615| <<type_initialize>> ti->class->interfaces = NULL;
+     *   - qom/object.c|623| <<type_initialize>> for (e = parent->class->interfaces; e; e = e->next) {
+     *   - qom/object.c|646| <<type_initialize>> for (e = ti->class->interfaces; e; e = e->next) {
+     *   - qom/object.c|1199| <<object_class_dynamic_cast>> if (type->class->interfaces &&
+     *   - qom/object.c|1204| <<object_class_dynamic_cast>> for (i = class->interfaces; i; i = i->next) {
+     *   - qom/object.c|1245| <<object_class_dynamic_cast_assert>> if (!class || !class->interfaces) {
+     */
     GSList *interfaces;
 
     const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE];
@@ -399,6 +424,11 @@ struct ObjectClass
 
     ObjectUnparent *unparent;
 
+    /*
+     * 在以下分配:
+     *   - qom/object.c|550| <<type_initialize>> ti->class->properties = g_hash_table_new_full(
+     *   - qom/object.c|586| <<type_initialize>> ti->class->properties = g_hash_table_new_full(
+     */
     GHashTable *properties;
 };
 
@@ -414,11 +444,22 @@ struct ObjectClass
  * first member.  This allows identification of the real type of the object at
  * run time.
  */
+/*
+ * 关注object_initialize_with_type()
+ */
 struct Object
 {
     /*< private >*/
+    /*
+     * 初始化:
+     *   - qom/object.c|665| <<object_initialize_with_type>> obj->class = type->class;
+     */
     ObjectClass *class;
     ObjectFree *free;
+    /*
+     * 在以下初始化:
+     *   - qom/object.c|680| <<object_initialize_with_type>> obj->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
+     */
     GHashTable *properties;
     uint32_t ref;
     Object *parent;
@@ -574,6 +615,7 @@ struct InterfaceClass
     Type interface_type;
 };
 
+/* TypeInfo interface_info */
 #define TYPE_INTERFACE "interface"
 
 /**
@@ -868,6 +910,10 @@ void type_register_static_array(const TypeInfo *infos, int nr_infos);
  * @type_array should be static constant that exists for the life time
  * that the type is registered.
  */
+/*
+ * type_register_static_array()
+ *     为nr_infos个: 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 #define DEFINE_TYPES(type_array)                                            \
 static void do_qemu_init_ ## type_array(void)                               \
 {                                                                           \
diff --git a/include/sysemu/accel.h b/include/sysemu/accel.h
index 637358f..560b596 100644
--- a/include/sysemu/accel.h
+++ b/include/sysemu/accel.h
@@ -52,6 +52,7 @@ typedef struct AccelClass {
     GlobalProperty *global_props;
 } AccelClass;
 
+/* TypeInfo accel_type */
 #define TYPE_ACCEL "accel"
 
 #define ACCEL_CLASS_SUFFIX  "-" TYPE_ACCEL
diff --git a/include/sysemu/iothread.h b/include/sysemu/iothread.h
index 8a7ac2c..137877b 100644
--- a/include/sysemu/iothread.h
+++ b/include/sysemu/iothread.h
@@ -17,6 +17,7 @@
 #include "block/aio.h"
 #include "qemu/thread.h"
 
+/* TypeInfo iothread_info */
 #define TYPE_IOTHREAD "iothread"
 
 typedef struct {
diff --git a/include/sysemu/kvm_int.h b/include/sysemu/kvm_int.h
index f838412..7be68df 100644
--- a/include/sysemu/kvm_int.h
+++ b/include/sysemu/kvm_int.h
@@ -29,6 +29,7 @@ typedef struct KVMMemoryListener {
     int as_id;
 } KVMMemoryListener;
 
+/* TypeInfo kvm_accel_type */
 #define TYPE_KVM_ACCEL ACCEL_CLASS_NAME("kvm")
 
 #define KVM_STATE(obj) \
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 98f389a..b8b9320 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -754,6 +754,10 @@ struct kvm_ppc_resize_hpt {
  * ioctls for /dev/kvm fds:
  */
 #define KVM_GET_API_VERSION       _IO(KVMIO,   0x00)
+/*
+ * x86就用在:
+ *   - accel/kvm/kvm-all.c|1560| <<kvm_init>> ret = kvm_ioctl(s, KVM_CREATE_VM, type);
+ */
 #define KVM_CREATE_VM             _IO(KVMIO,   0x01) /* returns a VM fd */
 #define KVM_GET_MSR_INDEX_LIST    _IOWR(KVMIO, 0x02, struct kvm_msr_list)
 
diff --git a/memory.c b/memory.c
index e9cd446..36f4198 100644
--- a/memory.c
+++ b/memory.c
@@ -35,17 +35,206 @@
 
 //#define DEBUG_UNASSIGNED
 
+/*
+ * QEMU通过MemoryRegion来管理虚拟机内存,通过内存属性,GUEST物理地址等特点对内存
+ * 分类,就形成了多个MemoryRegion,这些MemoryRegion通过树状组织起来,挂接到根
+ * MemoryRegion下.每个MemoryRegion树代表了一类作用的内存,如系统内存空间或IO内存
+ * 空间.
+ *
+ * MemoryRegion可以粗略分为三类：
+ * 1. 根MemoryRegion: 不分配真正的物理内存,通过subregions将所有的子MemoryRegion
+ * 管理起来,如system_memory.
+ * 2. 实体MemoryRegion: 这种MemoryRegion中真正的分配物理内存,最主要的就是pc.ram
+ * 和pci.分配的物理内存的作用分别是内存,PCI地址空间以及fireware空间.QEMU是用户空
+ * 间代码,分配的物理内存返回的是HVA,被保存到host域.同时这个结构还会为本段虚拟机
+ * 内存分配虚拟机物理地址空间起始地址,该起始地址(GPA)保存到ram_addr域,该段内存大
+ * 小为size.通过实体MemoryRegion就可以将HOST地址HVA和GUEST地址GPA对应起来,这种实
+ * 体MemoryRegion起到了转换的作用.
+ * 3. 别名MemoryRegion: 这种MemoryRegion中不分配物理内存,代表了实体MemoryRegion
+ * 的一个部分,通过alias域指向实体MemoryRegion,alias_offset代表了该别名MemoryRegion
+ * 所代表内存起始GPA相对于实体MemoryRegion所代表内存起始GPA的偏移量,通常用来计算
+ * 别名MemoryRegion对应的物理内存的HVA值:
+ * HVA = 起始HVA + alias_offset.
+ *
+ * 所有实体MemoryRegion都会被插在主板上,如pc.ram就被插在I440FX主板的ram_memory成员中.
+ *
+ * MemoryRegion是QEMU管理内存的树状结构,便于按照功能,属性分类;但这只是管理结构.但虚
+ * 拟机的内存需要通过KVM_SET_USER_MEMORY_REGION,将HVA和GPA的对应关系注册到KVM模块的
+ * memslot,才可以生效成为EPT.如果QEMU直接使用MemoryRegion进行注册,那么注册的过程将会
+ * 很麻烦,也容易不断的出现重叠判断等.所以在通过KVM_SET_USER_MEMORY_REGION注册前,加
+ * 了一层转换机制,先将树状的MemoryRegion展开物理内存样子的一维区间结构,然后再通过
+ * KVM_SET_USER_MEMORY_REGION将这个展开的物理内存注册到KVM内核模块中,就方便了许多.
+ * 这个转换机制就是FlatView模型.整个转换过程请参见函数address_space_update_topology.
+ *
+ * --> address_space_update_topology将指定的AddressSpace下的MemoryRegion树进行展平,形成
+ *     了对应一维内存逻辑表示的FlatView.
+ * --> 然后在address_space_update_topology_pass中将FlatView模型通过
+ *     KVM_SET_USER_MEMORY_REGION注册到KVM模块中.
+ *
+ *
+ * 1. QEMU declares a memory region(but not allocate ram or commit it to kvm)
+ * 2. Guest first access the MMIO address, cause a EPT violation VM-exit
+ * 3. KVM construct the EPT page table and marks the page table entry with special mark(110b)
+ * 4. Later the guest access these MMIO, it will be processed by EPT misconfig VM-exit handler
+ *
+ */
+
+/*
+ * qemu中用AddressSpace用来表示CPU设备看到的内存,一个AddressSpace下面包含多个MemoryRegion,
+ * 这些MemoryRegion结构通过树连接起来,树的根是AddressSpace的root域.
+ *
+ * MemoryRegion有多种类型,可以表示一段ram,rom,MMIO,alias,alias表示一个MemoryRegion的一部分
+ * 区域,MemoryRegion也可以表示一个container,这就表示它只是其他若干个MemoryRegion的容器.
+ * 在MemoryRegion中,'ram_block'表示的是分配的实际内存.
+ *
+ * AddressSpace下面root及其子树形成了一个虚拟机的物理地址,但是在往kvm进行设置的时候,需要将其
+ * 转换为一个平坦的地址模型,也就是从0开始的.这个就用FlatView表示,一个AddressSpace对应一个FlatView.
+ *
+ * 在FlatView中,FlatRange表示按照需要被切分为了几个范围.
+ *
+ * 在内存虚拟化中,还有一个重要的结构是MemoryRegionSection,这个结构通过函数section_from_flat_range
+ * 可由FlatRange转换过来.
+ *
+ *
+ * 为了监控虚拟机的物理地址访问,对于每一个AddressSpace,会有一个MemoryListener与之对应.每当物理
+ * 映射(GPA->HVA)发生改变时,会回调这些函数.所有的MemoryListener都会挂在全局变量memory_listeners
+ * 链表上.同时,AddressSpace也会有一个链表连接自己注册的MemoryListener.
+ *
+ * 为了在虚拟机退出时,能够顺利根据物理地址找到对应的HVA地址,qemu会有一个AddressSpaceDispatch结构,
+ * 用来在AddressSpace中进行位置的找寻,继而完成对IO/MMIO地址的访问. 这里面有一个PhysPageMap,这其实
+ * 也是保存了一个GPA->HVA的一个映射,通过多层页表实现,当kvm exit退到qemu之后,通过这个AddressSpaceDispatch
+ * 里面的map查找对应的MemoryRegionSection,继而找到对应的主机HVA.
+ */
+
+/*
+ * pc_init1()用到system_memory(MemoryRegion)和pci_memory(MemoryRegion).
+ *
+ * 215     if (pcmc->pci_enabled) {
+ * 216         pci_bus = i440fx_init(host_type,
+ * 217                               pci_type,
+ * 218                               &i440fx_state, &piix3_devfn, &isa_bus, pcms->gsi,
+ * 219                               system_memory, system_io, machine->ram_size,
+ * 220                               pcms->below_4g_mem_size,
+ * 221                               pcms->above_4g_mem_size,
+ * 222                               pci_memory, ram_memory);
+ *
+ *
+ * 初始化bus->address_space_mem (PCIBus的MemoryRegion)为名字为"pci"的MemoryRegion.
+ *
+ * 364     b = pci_root_bus_new(dev, NULL, pci_address_space,
+ * 365                          address_space_io, 0, TYPE_PCI_BUS);
+ *
+ *
+ * f->system_memory是system_memory(MemoryRegion), f->pci_address_space是pci_address_space
+ * (也就是名字为"pci"的MemoryRegion).
+ *
+ * pc_pci_as_mapping_init()把pci_address_space(名字为"pci"的MemoryRegion)设置container
+ * 为system_memory.
+ *
+ * 382     pc_pci_as_mapping_init(OBJECT(f), f->system_memory,
+ * 383                            f->pci_address_space);
+ *
+ *
+ * nvme的初始化在nvme_realize()中初始化:
+ *
+ * 1307     memory_region_init_io(&n->iomem, OBJECT(n), &nvme_mmio_ops, n,
+ * 1308                           "nvme", n->reg_size);
+ * 1309     pci_register_bar(&n->parent_obj, 0,
+ * 1310         PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_64,
+ * 1311         &n->iomem);
+ *
+ * 在pci_register_bar()中, 把nvme自己的MemoryRegion设置成pci_dev->io_regions[i](PCIIORegion)
+ * 的memory. 上面说过pci_get_bus(pci_dev)->address_space_mem是名字为"pci"的
+ * MemoryRegion(container是system_memory).
+ *
+ * 1171     r->address_space = type & PCI_BASE_ADDRESS_SPACE_IO
+ * 1172                         ? pci_get_bus(pci_dev)->address_space_io
+ * 1173                         : pci_get_bus(pci_dev)->address_space_mem;
+ *
+ *
+ * 在pci_update_mappings()的时候会把PCIDevice的每一个PCIIORegion添加到r->address_space
+ * (名字为"pci"的MemoryRegion).
+ *
+ * 1405                                           i, r->addr, r->size);
+ * 1406             memory_region_add_subregion_overlap(r->address_space,
+ * 1407                                                 r->addr, r->memory, 1);
+ */
+
 static unsigned memory_region_transaction_depth;
+/*
+ * 设置的地方:
+ *   - memory.c|1254| <<memory_region_transaction_commit>> memory_region_update_pending = false;
+ *   - memory.c|2245| <<memory_region_set_log>> memory_region_update_pending |= mr->enabled;
+ *   - memory.c|2318| <<memory_region_set_readonly>> memory_region_update_pending |= mr->enabled;
+ *   - memory.c|2328| <<memory_region_rom_device_set_romd>> memory_region_update_pending |= mr->enabled;
+ *   - memory.c|2601| <<memory_region_update_container_subregions>> memory_region_update_pending |= mr->enabled && subregion->enabled;
+ *   - memory.c|2666| <<memory_region_del_subregion>> memory_region_update_pending |= mr->enabled && subregion->enabled;
+ *   - memory.c|2677| <<memory_region_set_enabled>> memory_region_update_pending = true;
+ *   - memory.c|2693| <<memory_region_set_size>> memory_region_update_pending = true;
+ *   - memory.c|2747| <<memory_region_set_alias_offset>> memory_region_update_pending |= mr->enabled;
+ *   - memory.c|2870| <<memory_global_dirty_log_start>> memory_region_update_pending = true;
+ *   - memory.c|2880| <<memory_global_dirty_log_do_stop>> memory_region_update_pending = true;
+ */
 static bool memory_region_update_pending;
+/*
+ * 设置的地方:
+ *   - memory.c|1273| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - memory.c|1282| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - memory.c|2556| <<memory_region_add_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ *   - memory.c|2591| <<memory_region_del_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ */
 static bool ioeventfd_update_pending;
 static bool global_dirty_log = false;
 
+/*
+ * 所有使用的地方:
+ *   - memory.c|2696| <<memory_listener_register>> QTAILQ_INSERT_TAIL(&memory_listeners, listener, link);
+ *   - memory.c|126| <<MEMORY_LISTENER_CALL_GLOBAL>> QTAILQ_FOREACH(_listener, &memory_listeners, link) { \
+ *   - memory.c|133| <<MEMORY_LISTENER_CALL_GLOBAL>> QTAILQ_FOREACH_REVERSE(_listener, &memory_listeners, \
+ *   - memory.c|134| <<MEMORY_LISTENER_CALL_GLOBAL>> memory_listeners, link) { \
+ *   - memory.c|2046| <<memory_region_sync_dirty_bitmap>> QTAILQ_FOREACH(listener, &memory_listeners, link) {
+ *   - memory.c|2693| <<memory_listener_register>> if (QTAILQ_EMPTY(&memory_listeners)
+ *   - memory.c|2694| <<memory_listener_register>> || listener->priority >= QTAILQ_LAST(&memory_listeners,
+ *   - memory.c|2695| <<memory_listener_register>> memory_listeners)->priority) {
+ *   - memory.c|2698| <<memory_listener_register>> QTAILQ_FOREACH(other, &memory_listeners, link) {
+ *   - memory.c|2708| <<memory_listener_register>> memory_listeners)->priority) {
+ *   - memory.c|2729| <<memory_listener_unregister>> QTAILQ_REMOVE(&memory_listeners, listener, link);
+ */
 static QTAILQ_HEAD(memory_listeners, MemoryListener) memory_listeners
     = QTAILQ_HEAD_INITIALIZER(memory_listeners);
 
+/*
+ * 添加:
+ *   - memory.c|2835| <<address_space_init>> QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
+ *
+ * 删除:
+ *   - memory.c|2859| <<address_space_destroy>> QTAILQ_REMOVE(&address_spaces, as, address_spaces_link);
+ *
+ * 使用:
+ *   - memory.c|608| <<memory_region_to_address_space>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|969| <<flatviews_reset>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|1060| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|1068| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|2189| <<memory_region_update_coalesced_range>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|3150| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|3174| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ */
 static QTAILQ_HEAD(, AddressSpace) address_spaces
     = QTAILQ_HEAD_INITIALIZER(address_spaces);
 
+/*
+ * 用到flat_views的地方:
+ *   - memory.c|819| <<generate_memory_topology>> g_hash_table_replace(flat_views, mr, view);
+ *   - memory.c|999| <<flatviews_init>> if (flat_views) {
+ *   - memory.c|1003| <<flatviews_init>> flat_views = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
+ *   - memory.c|1010| <<flatviews_init>> g_hash_table_replace(flat_views, NULL, empty_view);
+ *   - memory.c|1019| <<flatviews_reset>> if (flat_views) {
+ *   - memory.c|1020| <<flatviews_reset>> g_hash_table_unref(flat_views);
+ *   - memory.c|1021| <<flatviews_reset>> flat_views = NULL;
+ *   - memory.c|1029| <<flatviews_reset>> if (g_hash_table_lookup(flat_views, physmr)) {
+ *   - memory.c|1041| <<address_space_set_flatview>> FlatView *new_view = g_hash_table_lookup(flat_views, physmr);
+ *   - memory.c|1091| <<address_space_update_topology>> if (!g_hash_table_lookup(flat_views, physmr)) {
+ */
 static GHashTable *flat_views;
 
 typedef struct AddrRange AddrRange;
@@ -59,39 +248,46 @@ struct AddrRange {
     Int128 size;
 };
 
+/* 用start和size制作成一个AddrRange */
 static AddrRange addrrange_make(Int128 start, Int128 size)
 {
     return (AddrRange) { start, size };
 }
 
+/* 比较两个AddrRange的start的size是否完全相同 */
 static bool addrrange_equal(AddrRange r1, AddrRange r2)
 {
     return int128_eq(r1.start, r2.start) && int128_eq(r1.size, r2.size);
 }
 
+/* 返回AddrRange的start+size (也就是end) */
 static Int128 addrrange_end(AddrRange r)
 {
     return int128_add(r.start, r.size);
 }
 
+/* AddrRange的start加上delta并更新start */
 static AddrRange addrrange_shift(AddrRange range, Int128 delta)
 {
     int128_addto(&range.start, delta);
     return range;
 }
 
+/* 判断一个addr是否在AddrRange的范围内 */
 static bool addrrange_contains(AddrRange range, Int128 addr)
 {
     return int128_ge(addr, range.start)
         && int128_lt(addr, addrrange_end(range));
 }
 
+/* 判断两个AddrRange是否intersect */
 static bool addrrange_intersects(AddrRange r1, AddrRange r2)
 {
     return addrrange_contains(r1, r2.start)
         || addrrange_contains(r2, r1.start);
 }
 
+/* 返回两个AddrRange相交的地方并返回新生成的AddrRange */
 static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
 {
     Int128 start = int128_max(r1.start, r2.start);
@@ -101,6 +297,16 @@ static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
 
 enum ListenerDirection { Forward, Reverse };
 
+/*
+ * called by:
+ *   - memory.c|1135| <<memory_region_transaction_commit>> MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);
+ *   - memory.c|1143| <<memory_region_transaction_commit>> MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);
+ *   - memory.c|2737| <<memory_global_dirty_log_start>> MEMORY_LISTENER_CALL_GLOBAL(log_global_start, Forward);
+ *   - memory.c|2754| <<memory_global_dirty_log_do_stop>> MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);
+ *
+ * 根据_direction的方向, 从前向后或者从后向前遍历调用memory_listeners中的每个MemoryListener
+ * 并调用指定的_callback (比如commit, begin等)
+ */
 #define MEMORY_LISTENER_CALL_GLOBAL(_callback, _direction, _args...)    \
     do {                                                                \
         MemoryListener *_listener;                                      \
@@ -126,6 +332,17 @@ enum ListenerDirection { Forward, Reverse };
         }                                                               \
     } while (0)
 
+/*
+ * called by:
+ *   - memory.c|217| <<MEMORY_LISTENER_UPDATE_REGION>> MEMORY_LISTENER_CALL(as, callback, dir, &mrs, ##_args); \
+ *   - memory.c|877| <<address_space_add_del_ioeventfds>> MEMORY_LISTENER_CALL(as, eventfd_del, Forward, &section,
+ *   - memory.c|890| <<address_space_add_del_ioeventfds>> MEMORY_LISTENER_CALL(as, eventfd_add, Reverse, &section,
+ *   - memory.c|2304| <<memory_region_update_coalesced_range_as>> MEMORY_LISTENER_CALL(as, coalesced_mmio_del, Reverse, &section,
+ *   - memory.c|2315| <<memory_region_update_coalesced_range_as>> MEMORY_LISTENER_CALL(as, coalesced_mmio_add, Forward, &section,
+ *
+ * 根据_direction的方向, 从前向后或者从后向前遍历调用某个AddressSpace自己的每个MemoryListener
+ * 并调用指定的_callback (比如eventfd_add, coalesced_mmio_add等)
+ */
 #define MEMORY_LISTENER_CALL(_as, _callback, _direction, _section, _args...) \
     do {                                                                \
         MemoryListener *_listener;                                      \
@@ -153,6 +370,19 @@ enum ListenerDirection { Forward, Reverse };
     } while (0)
 
 /* No need to ref/unref .mr, the FlatRange keeps it alive.  */
+/*
+ * called by:
+ *   - memory.c|995| <<address_space_update_topology_pass>> MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del);
+ *   - memory.c|1003| <<address_space_update_topology_pass>> MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop);
+ *   - memory.c|1005| <<address_space_update_topology_pass>> MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start,
+ *   - memory.c|1010| <<address_space_update_topology_pass>> MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop,
+ *   - memory.c|1022| <<address_space_update_topology_pass>> MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);
+ *
+ * 这个宏会将每一个FlatRange转换为一个MemoryRegionSection,之后调用
+ * 这个as对应的各个MemoryListener的回调函数.这里我们以kvm对象注册
+ * Listener为例,从kvm_memory_listener_register,我们看到其region_add
+ * 回调为kvm_region_add()
+ */
 #define MEMORY_LISTENER_UPDATE_REGION(fr, as, dir, callback, _args...)  \
     do {                                                                \
         MemoryRegionSection mrs = section_from_flat_range(fr,           \
@@ -161,17 +391,20 @@ enum ListenerDirection { Forward, Reverse };
     } while(0)
 
 struct CoalescedMemoryRange {
+    /* 包括start和size */
     AddrRange addr;
     QTAILQ_ENTRY(CoalescedMemoryRange) link;
 };
 
 struct MemoryRegionIoeventfd {
+    /* 包括start和size */
     AddrRange addr;
     bool match_data;
     uint64_t data;
     EventNotifier *e;
 };
 
+/* 判断第一个MemoryRegionIoeventfd是否在第二个前面 */
 static bool memory_region_ioeventfd_before(MemoryRegionIoeventfd *a,
                                            MemoryRegionIoeventfd *b)
 {
@@ -202,6 +435,7 @@ static bool memory_region_ioeventfd_before(MemoryRegionIoeventfd *a,
     return false;
 }
 
+/* 判断两个MemoryRegionIoeventfd是否相等 */
 static bool memory_region_ioeventfd_equal(MemoryRegionIoeventfd *a,
                                           MemoryRegionIoeventfd *b)
 {
@@ -210,18 +444,33 @@ static bool memory_region_ioeventfd_equal(MemoryRegionIoeventfd *a,
 }
 
 /* Range of memory in the global map.  Addresses are absolute. */
+/*
+ * 似乎主要用在FlatView中
+ */
 struct FlatRange {
     MemoryRegion *mr;
     hwaddr offset_in_region;
+    /* 包含start和size */
     AddrRange addr;
     uint8_t dirty_log_mask;
     bool romd_mode;
     bool readonly;
 };
 
+/* 遍历FlatView中的每一个FlatRange */
 #define FOR_EACH_FLAT_RANGE(var, view)          \
     for (var = (view)->ranges; var < (view)->ranges + (view)->nr; ++var)
 
+/*
+ * called by:
+ *   - memory.c|237| <<MEMORY_LISTENER_UPDATE_REGION>> MemoryRegionSection mrs = section_from_flat_range(fr, \
+ *   - memory.c|867| <<generate_memory_topology>> section_from_flat_range(&view->ranges[i], view);
+ *   - memory.c|2202| <<memory_region_sync_dirty_bitmap>> MemoryRegionSection mrs = section_from_flat_range(fr, view);
+ *   - memory.c|2833| <<listener_add_address_space>> MemoryRegionSection section = section_from_flat_range(fr, view);
+ *   - memory.c|2859| <<listener_del_address_space>> MemoryRegionSection section = section_from_flat_range(fr, view);
+ *
+ * 根据参数的FlatRange和FlatView, 返回一个临时的MemoryRegionSection
+ */
 static inline MemoryRegionSection
 section_from_flat_range(FlatRange *fr, FlatView *fv)
 {
@@ -235,6 +484,9 @@ section_from_flat_range(FlatRange *fr, FlatView *fv)
     };
 }
 
+/*
+ * 比较两个FlatRange是否完全相同
+ */
 static bool flatrange_equal(FlatRange *a, FlatRange *b)
 {
     return a->mr == b->mr
@@ -244,6 +496,11 @@ static bool flatrange_equal(FlatRange *a, FlatRange *b)
         && a->readonly == b->readonly;
 }
 
+/*
+ * called only by generate_memory_topology()
+ *
+ * 分配一个FlatView, 让其root指向参数的MemoryRegion
+ */
 static FlatView *flatview_new(MemoryRegion *mr_root)
 {
     FlatView *view;
@@ -260,13 +517,33 @@ static FlatView *flatview_new(MemoryRegion *mr_root)
 /* Insert a range into a given position.  Caller is responsible for maintaining
  * sorting order.
  */
+/*
+ * called by:
+ *   - memory.c|789| <<render_memory_region>> flatview_insert(view, i, &fr);
+ *   - memory.c|805| <<render_memory_region>> flatview_insert(view, i, &fr);
+ *
+ * FlatView的ranges数组(FlatRange)中的后面pos个都往后移一个
+ * 把参数中的FlatRange放在pos的位置
+ * 如果FlatView->nr_allocated不够了要扩容一下
+ */
 static void flatview_insert(FlatView *view, unsigned pos, FlatRange *range)
 {
+    /*
+     * 如果view (FlatView)的nr_allocated不够了, 扩大一下
+     * 最大也就10个
+     */
     if (view->nr == view->nr_allocated) {
         view->nr_allocated = MAX(2 * view->nr, 10);
+	/* ranges[nr_allocated]是一个FlatRange的数组 */
         view->ranges = g_realloc(view->ranges,
                                     view->nr_allocated * sizeof(*view->ranges));
     }
+    /*
+     * ranges[nr_allocated]是一个FlatRange的数组
+     *
+     * FlatView的ranges数组(FlatRange)中的后面pos个都往后移一个
+     * 把参数中的FlatRange放在pos的位置
+     */
     memmove(view->ranges + pos + 1, view->ranges + pos,
             (view->nr - pos) * sizeof(FlatRange));
     view->ranges[pos] = *range;
@@ -274,6 +551,10 @@ static void flatview_insert(FlatView *view, unsigned pos, FlatRange *range)
     ++view->nr;
 }
 
+/*
+ * called only by:
+ *   - memory.c|405| <<flatview_unref>> call_rcu(view, flatview_destroy, rcu);
+ */
 static void flatview_destroy(FlatView *view)
 {
     int i;
@@ -304,6 +585,9 @@ void flatview_unref(FlatView *view)
     }
 }
 
+/*
+ * 判断两个FlatRange是否想连续可以merge
+ */
 static bool can_merge(FlatRange *r1, FlatRange *r2)
 {
     return int128_eq(addrrange_end(r1->addr), r2->addr.start)
@@ -317,6 +601,13 @@ static bool can_merge(FlatRange *r1, FlatRange *r2)
 }
 
 /* Attempt to simplify a view by merging adjacent ranges */
+/*
+ * called only by:
+ *   - memory.c|905| <<generate_memory_topology>> flatview_simplify(view);
+ *
+ * 把FlatView中的ranges(FlatRange)数组中的FlatRange们合并一下
+ * 合并后nr也许会减少
+ */
 static void flatview_simplify(FlatView *view)
 {
     unsigned i, j;
@@ -354,6 +645,13 @@ static bool memory_region_wrong_endianness(MemoryRegion *mr)
 #endif
 }
 
+/*
+ * called by:
+ *   - memory.c|1660| <<memory_region_dispatch_read>> adjust_endianness(mr, pval, size);
+ *   - memory.c|1701| <<memory_region_dispatch_write>> adjust_endianness(mr, &data, size);
+ *   - memory.c|2494| <<memory_region_add_eventfd>> adjust_endianness(mr, &mrfd.data, size);
+ *   - memory.c|2529| <<memory_region_del_eventfd>> adjust_endianness(mr, &mrfd.data, size);
+ */
 static void adjust_endianness(MemoryRegion *mr, uint64_t *data, unsigned size)
 {
     if (memory_region_wrong_endianness(mr)) {
@@ -375,6 +673,32 @@ static void adjust_endianness(MemoryRegion *mr, uint64_t *data, unsigned size)
     }
 }
 
+/*
+ * called by:
+ *   - memory.c|449| <<memory_region_oldmmio_read_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *   - memory.c|475| <<memory_region_read_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *   - memory.c|502| <<memory_region_read_with_attrs_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *   - memory.c|528| <<memory_region_oldmmio_write_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *   - memory.c|554| <<memory_region_write_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *   - memory.c|580| <<memory_region_write_with_attrs_accessor>> hwaddr abs_addr = memory_region_to_absolute_addr(mr, addr);
+ *
+ * (gdb) bt
+ * #0  memory_region_to_absolute_addr (mr=0x555557498b60, offset=0) at /home/zhang/kvm/qemu-3.0.0/memory.c:381
+ * #1  0x0000555555864ae7 in memory_region_write_accessor (mr=0x555557498b60, addr=0, value=0x7fffec8b07a8, size=1, shift=0, mask=255, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:524
+ * #2  0x0000555555864d45 in access_with_adjusted_size (addr=0, value=0x7fffec8b07a8, size=1, access_size_min=1, access_size_max=1, access_fn=0x555555864a43 <memory_region_write_accessor>,
+ *     mr=0x555557498b60,attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:594
+ * #3  0x000055555586796d in memory_region_dispatch_write (mr=0x555557498b60, addr=0, data=143, size=1, attrs=...) at /home/zhang/kvm/qemu-3.0.0/memory.c:1473
+ * #4  0x000055555580399f in flatview_write_continue (fv=0x555557bb3600, addr=112, attrs=..., buf=0x7ffff7ff0000 "\217", len=1, addr1=0, l=1, mr=0x555557498b60) at /home/zhang/kvm/qemu-3.0.0/exec.c:3255
+ * #5  0x0000555555803ae9 in flatview_write (fv=0x555557bb3600, addr=112, attrs=..., buf=0x7ffff7ff0000 "\217", len=1) at /home/zhang/kvm/qemu-3.0.0/exec.c:3294
+ * #6  0x0000555555803def in address_space_write (as=0x555556721a20 <address_space_io>, addr=112, attrs=..., buf=0x7ffff7ff0000 "\217", len=1) at /home/zhang/kvm/qemu-3.0.0/exec.c:3384
+ * #7  0x0000555555803e40 in address_space_rw (as=0x555556721a20 <address_space_io>, addr=112, attrs=..., buf=0x7ffff7ff0000 "\217", len=1, is_write=true) at /home/zhang/kvm/qemu-3.0.0/exec.c:3395
+ * #8  0x00005555558823ec in kvm_handle_io (port=112, attrs=..., data=0x7ffff7ff0000, direction=1, size=1, count=1) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1729
+ * #9  0x0000555555882b30 in kvm_cpu_exec (cpu=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/accel/kvm/kvm-all.c:1969
+ * #10 0x0000555555849eac in qemu_kvm_cpu_thread_fn (arg=0x55555688a170) at /home/zhang/kvm/qemu-3.0.0/cpus.c:1215
+ * #11 0x0000555555d92dd7 in qemu_thread_start (args=0x5555568abcb0) at util/qemu-thread-posix.c:504
+ * #12 0x00007ffff4ca06ba in start_thread (arg=0x7fffec8b1700) at pthread_create.c:333
+ * #13 0x00007ffff49d641d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109
+ */
 static hwaddr memory_region_to_absolute_addr(MemoryRegion *mr, hwaddr offset)
 {
     MemoryRegion *root;
@@ -389,6 +713,7 @@ static hwaddr memory_region_to_absolute_addr(MemoryRegion *mr, hwaddr offset)
     return abs_addr;
 }
 
+/* 如果current_cpu存在 返回current_cpu->cpu_index */
 static int get_cpu_index(void)
 {
     if (current_cpu) {
@@ -553,6 +878,11 @@ static MemTxResult memory_region_write_with_attrs_accessor(MemoryRegion *mr,
     return mr->ops->write_with_attrs(mr->opaque, addr, tmp, size, attrs);
 }
 
+/*
+ * called by:
+ *   - memory_region_dispatch_read1()
+ *   - memory_region_dispatch_write()
+ */
 static MemTxResult access_with_adjusted_size(hwaddr addr,
                                       uint64_t *value,
                                       unsigned size,
@@ -598,13 +928,22 @@ static MemTxResult access_with_adjusted_size(hwaddr addr,
     return r;
 }
 
+/*
+ * 一直从mr->container递归遍历 找到不再有container的MemeoryRegion
+ * 遍历address_spaces链表中所有的AddressSpace, 找到root是上面MemoryRegion的那个
+ * 其实就是找到一个MemoryRegion所属的AddressSpace
+ */
 static AddressSpace *memory_region_to_address_space(MemoryRegion *mr)
 {
     AddressSpace *as;
 
+    /* 一直从mr->container递归遍历 找到不再有container的MemeoryRegion */
     while (mr->container) {
         mr = mr->container;
     }
+    /*
+     * 遍历address_spaces链表中所有的AddressSpace, 找到root是上面MemoryRegion的那个
+     */
     QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
         if (mr == as->root) {
             return as;
@@ -616,6 +955,14 @@ static AddressSpace *memory_region_to_address_space(MemoryRegion *mr)
 /* Render a memory region into the global view.  Ranges in @view obscure
  * ranges in @mr.
  */
+/*
+ * called by:
+ *   - memory.c|859| <<render_memory_region>> render_memory_region(view, mr->alias, base, clip, readonly);
+ *   - memory.c|865| <<render_memory_region>> render_memory_region(view, subregion, base, clip, readonly);
+ *   - memory.c|977| <<generate_memory_topology>> render_memory_region(view, mr, int128_zero(),
+ *
+ * 因为等价于只被generate_memory_topology()调用, 核心思想就是生成FlatView中的FlatRange数组
+ */
 static void render_memory_region(FlatView *view,
                                  MemoryRegion *mr,
                                  Int128 base,
@@ -634,26 +981,40 @@ static void render_memory_region(FlatView *view,
         return;
     }
 
+    /*
+     * 如果一开始是generate_memory_topology()调用进来的话, base是0
+     */
     int128_addto(&base, int128_make64(mr->addr));
     readonly |= mr->readonly;
 
+    /* 用start和size制作成一个AddrRange */
     tmp = addrrange_make(base, mr->size);
 
+    /* 判断两个AddrRange(tmp和clip)是否intersect */
     if (!addrrange_intersects(tmp, clip)) {
         return;
     }
 
+    /* 返回两个AddrRange相交的地方并返回新生成的AddrRange */
     clip = addrrange_intersection(tmp, clip);
 
     if (mr->alias) {
         int128_subfrom(&base, int128_make64(mr->alias->addr));
         int128_subfrom(&base, int128_make64(mr->alias_offset));
+	/*
+	 * view是参数中的view
+	 *
+	 * clip是传值 所以不会更新
+	 */
         render_memory_region(view, mr->alias, base, clip, readonly);
         return;
     }
 
     /* Render subregions in priority order. */
     QTAILQ_FOREACH(subregion, &mr->subregions, subregions_link) {
+        /*
+	 * clip是传值 所以不会更新
+	 */
         render_memory_region(view, subregion, base, clip, readonly);
     }
 
@@ -665,6 +1026,9 @@ static void render_memory_region(FlatView *view,
     base = clip.start;
     remain = clip.size;
 
+    /*
+     * fr是FlatRange
+     */
     fr.mr = mr;
     fr.dirty_log_mask = memory_region_get_dirty_log_mask(mr);
     fr.romd_mode = mr->romd_mode;
@@ -686,6 +1050,9 @@ static void render_memory_region(FlatView *view,
             offset_in_region += int128_get64(now);
             int128_subfrom(&remain, now);
         }
+	/*
+	 * addrrange_end(): 返回AddrRange的start+size (也就是end)
+	 */
         now = int128_sub(int128_min(int128_add(base, remain),
                                     addrrange_end(view->ranges[i].addr)),
                          base);
@@ -695,11 +1062,23 @@ static void render_memory_region(FlatView *view,
     }
     if (int128_nz(remain)) {
         fr.offset_in_region = offset_in_region;
+	/* 用start和size制作成一个AddrRange */
         fr.addr = addrrange_make(base, remain);
+	/*
+	 * FlatView的ranges数组(FlatRange)中的后面pos个都往后移一个
+	 * 把参数中的FlatRange放在pos的位置
+	 * 如果FlatView->nr_allocated不够了要扩容一下
+	 */
         flatview_insert(view, i, &fr);
     }
 }
 
+/*
+ * called by:
+ *   - memory.c|1006| <<flatviews_reset>> MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
+ *   - memory.c|1019| <<address_space_set_flatview>> MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
+ *   - memory.c|1067| <<address_space_update_topology>> MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
+ */
 static MemoryRegion *memory_region_get_flatview_root(MemoryRegion *mr)
 {
     while (mr->enabled) {
@@ -745,26 +1124,106 @@ static MemoryRegion *memory_region_get_flatview_root(MemoryRegion *mr)
 }
 
 /* Render a memory topology into a list of disjoint absolute ranges. */
+/*
+ * called by:
+ *   - memory.c|985| <<flatviews_init>> empty_view = generate_memory_topology(NULL);
+ *   - memory.c|1012| <<flatviews_reset>> generate_memory_topology(physmr);
+ *   - memory.c|1071| <<address_space_update_topology>> generate_memory_topology(physmr);
+ *
+ *
+ * hotplug nvme的例子:
+ * (gdb) bt
+ * #0  generate_memory_topology (mr=0x5555565c81f0) at /home/zhang/kvm/qemu-3.0.0/memory.c:749
+ * #1  0x0000555555834cb3 in flatviews_reset () at /home/zhang/kvm/qemu-3.0.0/memory.c:976
+ * #2  0x0000555555834f30 in memory_region_transaction_commit () at /home/zhang/kvm/qemu-3.0.0/memory.c:1052
+ * #3  0x00005555558386eb in memory_region_set_enabled (mr=0x55555706cbd0, enabled=false) at /home/zhang/kvm/qemu-3.0.0/memory.c:2360
+ * #4  0x0000555555af2ea9 in pci_init_bus_master (pci_dev=0x55555706c870) at hw/pci/pci.c:96
+ * #5  0x0000555555af5249 in do_pci_register_device (pci_dev=0x55555706c870, name=0x5555564e9f40 "nvme", devfn=32, errp=0x7fffffffcbf0) at hw/pci/pci.c:1030
+ * #6  0x0000555555af76d3 in pci_qdev_realize (qdev=0x55555706c870, errp=0x7fffffffcbf0) at hw/pci/pci.c:2021
+ * #7  0x0000555555a2d447 in device_set_realized (obj=0x55555706c870, value=true, errp=0x7fffffffcdc0) at hw/core/qdev.c:826
+ * #8  0x0000555555c21bc7 in property_set_bool (obj=0x55555706c870, v=0x55555709f010, name=0x555555db778a "realized", opaque=0x55555715d760, errp=0x7fffffffcdc0)
+ *     at qom/object.c:1984
+ * #9  0x0000555555c1fe4c in object_property_set (obj=0x55555706c870, v=0x55555709f010, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1176
+ * #10 0x0000555555c22f04 in object_property_set_qobject (obj=0x55555706c870, value=0x55555675fec0, name=0x555555db778a "realized", errp=0x7fffffffcdc0)
+ *     at qom/qom-qobject.c:27
+ * #11 0x0000555555c20131 in object_property_set_bool (obj=0x55555706c870, value=true, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1242
+ * #12 0x0000555555990749 in qdev_device_add (opts=0x5555565c63a0, errp=0x7fffffffce30) at qdev-monitor.c:627
+ * #13 0x0000555555990f32 in qmp_device_add (qdict=0x55555709df10, ret_data=0x0, errp=0x7fffffffce70) at qdev-monitor.c:807
+ * #14 0x00005555559bebd7 in hmp_device_add (mon=0x5555565e0bd0, qdict=0x55555709df10) at hmp.c:2008
+ * #15 0x00005555558230ac in handle_hmp_command (mon=0x5555565e0bd0, cmdline=0x5555565f005b "nvme,drive=lightnvme,serial=deadbeaf1")
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #16 0x0000555555825467 in monitor_command_cb (opaque=0x5555565e0bd0, cmdline=0x5555565f0050 "device_add nvme,drive=lightnvme,serial=deadbeaf1", 
+ *     readline_opaque=0x0) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #17 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565f0050, ch=13) at util/readline.c:393
+ * #18 0x00005555558253ba in monitor_read (opaque=0x5555565e0bd0, buf=0x7fffffffd030 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #19 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #20 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #21 0x0000555555cce691 in fd_chr_read (chan=0x5555565d3310, cond=G_IO_IN, opaque=0x5555565d3100) at chardev/char-fd.c:66
+ * #22 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x555556ff37e0, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d3100)
+ *     at io/channel-watch.c:84
+ * #23 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #24 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #25 0x0000555555d4f990 in os_host_main_loop_wait (timeout=198688541) at util/main-loop.c:238
+ * #26 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #27 0x00005555559967aa in main_loop () at vl.c:1866
+ * #28 0x000055555599dfbd in main (argc=12, argv=0x7fffffffe4a8, envp=0x7fffffffe510) at vl.c:4644
+ * (gdb) p mr->name
+ * $1 = 0x5555565c86c0 "system"
+ *
+ * physmr可以临时理解成AddressSpace的root (先忽略其他情况)
+ */
 static FlatView *generate_memory_topology(MemoryRegion *mr)
 {
     int i;
+    /*
+     * AddressSpace下面root及其子树形成了一个虚拟机的物理地址,但是在往kvm进行设置的时候,
+     * 需要将其转换为一个平坦的地址模型,也就是从0开始的.这个就用FlatView表示,一个
+     * AddressSpace对应一个FlatView.
+     */
     FlatView *view;
 
+    /*
+     * 分配一个FlatView, 让其root指向参数的mr(MemoryRegion)
+     *
+     * 刚分配的话nr和nr_allocated都是0吧
+     */
     view = flatview_new(mr);
 
     if (mr) {
+	/*
+	 * 因为等价于只被generate_memory_topology()调用, 核心思想就是生成FlatView中的FlatRange数组
+	 */
         render_memory_region(view, mr, int128_zero(),
                              addrrange_make(int128_zero(), int128_2_64()), false);
     }
+    /*
+     * 把FlatView中的ranges(FlatRange)数组中的FlatRange们合并一下
+     * 合并后nr也许会减少
+     *
+     * 如果参数mr是NULL (从flatviews_init()进来), 下面的flatview_simplify()似乎就不运行了
+     */
     flatview_simplify(view);
 
+    /*
+     * 为了在虚拟机退出时,能够顺利根据物理地址找到对应的HVA地址,qemu会有一个
+     * AddressSpaceDispatch结构,用来在AddressSpace中进行位置的找寻,继而完成
+     * 对IO/MMIO地址的访问.
+     *
+     *
+     * 分配一个AddressSpaceDispatch并简单初始化一些dummy section
+     */
     view->dispatch = address_space_dispatch_new(view);
+    /*
+     * 如果参数mr是NULL (从flatviews_init()进来), 下面的for循环似乎就不运行了
+     */
     for (i = 0; i < view->nr; i++) {
+        /* 根据参数的FlatRange和FlatView, 返回一个临时的MemoryRegionSection */
         MemoryRegionSection mrs =
             section_from_flat_range(&view->ranges[i], view);
         flatview_add_to_dispatch(view, &mrs);
     }
     address_space_dispatch_compact(view->dispatch);
+    /* 把新分配的FlatView换成全局的flat_views */
     g_hash_table_replace(flat_views, mr, view);
 
     return view;
@@ -819,6 +1278,20 @@ static void address_space_add_del_ioeventfds(AddressSpace *as,
     }
 }
 
+/*
+ * called by:
+ *   - exec.c|3821| <<address_space_cache_init>> cache->fv = address_space_get_flatview(as);
+ *   - memory.c|1158| <<address_space_update_ioeventfds>> view = address_space_get_flatview(as);
+ *   - memory.c|2423| <<memory_region_sync_dirty_bitmap>> view = address_space_get_flatview(as);
+ *   - memory.c|2544| <<memory_region_update_coalesced_range_as>> view = address_space_get_flatview(as);
+ *   - memory.c|3105| <<listener_add_address_space>> view = address_space_get_flatview(as);
+ *   - memory.c|3131| <<listener_del_address_space>> view = address_space_get_flatview(as);
+ *   - memory.c|3661| <<mtree_info>> view = address_space_get_flatview(as);
+ *
+ * 返回AddressSpace->current_map
+ * current_map是AddressSpace的一张平面视图,它是AddressSpace
+ * 所有正在使用的MemoryRegion的集合,这是从CPU的视角来看到的
+ */
 FlatView *address_space_get_flatview(AddressSpace *as)
 {
     FlatView *view;
@@ -834,6 +1307,12 @@ FlatView *address_space_get_flatview(AddressSpace *as)
     return view;
 }
 
+/*
+ * called by:
+ *   - memory.c|1092| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+ *   - memory.c|1099| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+ *   - memory.c|2933| <<address_space_init>> address_space_update_ioeventfds(as);
+ */
 static void address_space_update_ioeventfds(AddressSpace *as)
 {
     FlatView *view;
@@ -843,6 +1322,11 @@ static void address_space_update_ioeventfds(AddressSpace *as)
     AddrRange tmp;
     unsigned i;
 
+    /*
+     * 返回AddressSpace->current_map
+     * current_map是AddressSpace的一张平面视图,它是AddressSpace
+     * 所有正在使用的MemoryRegion的集合,这是从CPU的视角来看到的
+     */
     view = address_space_get_flatview(as);
     FOR_EACH_FLAT_RANGE(fr, view) {
         for (i = 0; i < fr->mr->ioeventfd_nb; ++i) {
@@ -868,6 +1352,92 @@ static void address_space_update_ioeventfds(AddressSpace *as)
     flatview_unref(view);
 }
 
+/*
+ * called by:
+ *   - memory.c|1359| <<address_space_set_flatview>> address_space_update_topology_pass(as, old_view2, new_view, false);
+ *   - memory.c|1360| <<address_space_set_flatview>> address_space_update_topology_pass(as, old_view2, new_view, true);
+ *
+ * hotplug e1000网卡的例子:
+ * (gdb) bt
+ * #0  address_space_update_topology_pass (as=0x555556498b40 <address_space_memory>, old_view=0x7fffdc000c00, new_view=0x55555772c200, adding=false)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:875
+ * #1  0x0000555555834dc9 in address_space_set_flatview (as=0x555556498b40 <address_space_memory>) at /home/zhang/kvm/qemu-3.0.0/memory.c:1004
+ * #2  0x0000555555834f89 in memory_region_transaction_commit () at /home/zhang/kvm/qemu-3.0.0/memory.c:1057
+ * #3  0x00005555558386eb in memory_region_set_enabled (mr=0x5555566fcf80, enabled=false) at /home/zhang/kvm/qemu-3.0.0/memory.c:2360
+ * #4  0x0000555555af2ea9 in pci_init_bus_master (pci_dev=0x5555566fcc20) at hw/pci/pci.c:96
+ * #5  0x0000555555af5249 in do_pci_register_device (pci_dev=0x5555566fcc20, name=0x5555565190c0 "e1000", devfn=40, errp=0x7fffffffcb60) at hw/pci/pci.c:1030
+ * #6  0x0000555555af76d3 in pci_qdev_realize (qdev=0x5555566fcc20, errp=0x7fffffffcb60) at hw/pci/pci.c:2021
+ * #7  0x0000555555a2d447 in device_set_realized (obj=0x5555566fcc20, value=true, errp=0x7fffffffcd30) at hw/core/qdev.c:826
+ * #8  0x0000555555c21bc7 in property_set_bool (obj=0x5555566fcc20, v=0x5555572103f0, name=0x555555db778a "realized", opaque=0x555556925990, errp=0x7fffffffcd30)
+ *     at qom/object.c:1984
+ * #9  0x0000555555c1fe4c in object_property_set (obj=0x5555566fcc20, v=0x5555572103f0, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1176
+ * #10 0x0000555555c22f04 in object_property_set_qobject (obj=0x5555566fcc20, value=0x5555575c4f80, name=0x555555db778a "realized", errp=0x7fffffffcd30)
+ *     at qom/qom-qobject.c:27
+ * #11 0x0000555555c20131 in object_property_set_bool (obj=0x5555566fcc20, value=true, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1242
+ * #12 0x0000555555990749 in qdev_device_add (opts=0x55555739f8d0, errp=0x7fffffffcda0) at qdev-monitor.c:627
+ * #13 0x0000555555990f32 in qmp_device_add (qdict=0x555556ffff10, ret_data=0x0, errp=0x7fffffffcde0) at qdev-monitor.c:807
+ * #14 0x00005555559bebd7 in hmp_device_add (mon=0x5555565fb820, qdict=0x555556ffff10) at hmp.c:2008
+ * #15 0x00005555558230ac in handle_hmp_command (mon=0x5555565fb820, cmdline=0x5555565fe2cb "e1000,netdev=nd1") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #16 0x0000555555825467 in monitor_command_cb (opaque=0x5555565fb820, cmdline=0x5555565fe2c0 "device_add e1000,netdev=nd1", readline_opaque=0x0)
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #17 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565fe2c0, ch=13) at util/readline.c:393
+ * #18 0x00005555558253ba in monitor_read (opaque=0x5555565fb820, buf=0x7fffffffcfa0 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #19 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #20 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #21 0x0000555555cce691 in fd_chr_read (chan=0x5555565d35f0, cond=G_IO_IN, opaque=0x5555565d33e0) at chardev/char-fd.c:66
+ * #22 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x5555574b9b40, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d33e0)
+ *     at io/channel-watch.c:84
+ * #23 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #24 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #25 0x0000555555d4f990 in os_host_main_loop_wait (timeout=198784721) at util/main-loop.c:238
+ * #26 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #27 0x00005555559967aa in main_loop () at vl.c:1866
+ * #28 0x000055555599dfbd in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4644
+ *
+ *
+ * hotplug nvme的例子:
+ * (gdb) bt
+ * #0  address_space_update_topology_pass (as=0x555556498b40 <address_space_memory>, old_view=0x7fffdc000c00, new_view=0x555556cfc690, adding=false)
+ *     at /home/zhang/kvm/qemu-3.0.0/memory.c:875
+ * #1  0x0000555555834dc9 in address_space_set_flatview (as=0x555556498b40 <address_space_memory>) at /home/zhang/kvm/qemu-3.0.0/memory.c:1004
+ * #2  0x0000555555834f89 in memory_region_transaction_commit () at /home/zhang/kvm/qemu-3.0.0/memory.c:1057
+ * #3  0x00005555558386eb in memory_region_set_enabled (mr=0x55555706cbd0, enabled=false) at /home/zhang/kvm/qemu-3.0.0/memory.c:2360
+ * #4  0x0000555555af2ea9 in pci_init_bus_master (pci_dev=0x55555706c870) at hw/pci/pci.c:96
+ * #5  0x0000555555af5249 in do_pci_register_device (pci_dev=0x55555706c870, name=0x5555564e9f40 "nvme", devfn=32, errp=0x7fffffffcbf0) at hw/pci/pci.c:1030
+ * #6  0x0000555555af76d3 in pci_qdev_realize (qdev=0x55555706c870, errp=0x7fffffffcbf0) at hw/pci/pci.c:2021
+ * #7  0x0000555555a2d447 in device_set_realized (obj=0x55555706c870, value=true, errp=0x7fffffffcdc0) at hw/core/qdev.c:826
+ * #8  0x0000555555c21bc7 in property_set_bool (obj=0x55555706c870, v=0x55555709f010, name=0x555555db778a "realized", opaque=0x55555715d760, errp=0x7fffffffcdc0)
+ *     at qom/object.c:1984
+ * #9  0x0000555555c1fe4c in object_property_set (obj=0x55555706c870, v=0x55555709f010, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1176
+ * #10 0x0000555555c22f04 in object_property_set_qobject (obj=0x55555706c870, value=0x55555675fec0, name=0x555555db778a "realized", errp=0x7fffffffcdc0)
+ *     at qom/qom-qobject.c:27
+ * #11 0x0000555555c20131 in object_property_set_bool (obj=0x55555706c870, value=true, name=0x555555db778a "realized", errp=0x7fffffffcdc0) at qom/object.c:1242
+ * #12 0x0000555555990749 in qdev_device_add (opts=0x5555565c63a0, errp=0x7fffffffce30) at qdev-monitor.c:627
+ * #13 0x0000555555990f32 in qmp_device_add (qdict=0x55555709df10, ret_data=0x0, errp=0x7fffffffce70) at qdev-monitor.c:807
+ * #14 0x00005555559bebd7 in hmp_device_add (mon=0x5555565e0bd0, qdict=0x55555709df10) at hmp.c:2008
+ * #15 0x00005555558230ac in handle_hmp_command (mon=0x5555565e0bd0, cmdline=0x5555565f005b "nvme,drive=lightnvme,serial=deadbeaf1")
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #16 0x0000555555825467 in monitor_command_cb (opaque=0x5555565e0bd0, cmdline=0x5555565f0050 "device_add nvme,drive=lightnvme,serial=deadbeaf1", 
+ *     readline_opaque=0x0) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #17 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565f0050, ch=13) at util/readline.c:393
+ * #18 0x00005555558253ba in monitor_read (opaque=0x5555565e0bd0, buf=0x7fffffffd030 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #19 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #20 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d3100, buf=0x7fffffffd030 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #21 0x0000555555cce691 in fd_chr_read (chan=0x5555565d3310, cond=G_IO_IN, opaque=0x5555565d3100) at chardev/char-fd.c:66
+ * #22 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x555556ff37e0, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d3100)
+ *     at io/channel-watch.c:84
+ * #23 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #24 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #25 0x0000555555d4f990 in os_host_main_loop_wait (timeout=198688541) at util/main-loop.c:238
+ * #26 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #27 0x00005555559967aa in main_loop () at vl.c:1866
+ * #28 0x000055555599dfbd in main (argc=12, argv=0x7fffffffe4a8, envp=0x7fffffffe510) at vl.c:4644
+ * (gdb) p as->name
+ * $4 = 0x5555565c86e0 "memory"
+ *
+ * 逐一对比新旧FlatView的差别,然后进行更新, 比如将FlatView模型通过
+ * KVM_SET_USER_MEMORY_REGION注册到KVM模块中
+ */
 static void address_space_update_topology_pass(AddressSpace *as,
                                                const FlatView *old_view,
                                                const FlatView *new_view,
@@ -927,6 +1497,10 @@ static void address_space_update_topology_pass(AddressSpace *as,
             /* In new */
 
             if (adding) {
+                /*
+		 * 如果新增加了一个FlatRange,则会调用将该fr转换为一个
+		 * MemroyRegionSection,然后调用Listener的region_add
+		 */
                 MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);
             }
 
@@ -935,14 +1509,29 @@ static void address_space_update_topology_pass(AddressSpace *as,
     }
 }
 
+/*
+ * called by:
+ *   - memory.c|1294| <<flatviews_reset>> flatviews_init();
+ *   - memory.c|1361| <<address_space_update_topology>> flatviews_init();
+ *
+ * 就是"重新"初始化全局的GHashTable flat_views,
+ * 然后根据情况把root mr是NULL的FlatView放入
+ */
 static void flatviews_init(void)
 {
+    /*
+     * FlatView是内存最终的体现
+     *
+     * 这个后面mr是NULL的FlatView不知道放入flat_views做什么
+     */
     static FlatView *empty_view;
 
+    /* static GHashTable *flat_views; */
     if (flat_views) {
         return;
     }
 
+    /* flat_views是GHashTable的指针 */
     flat_views = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
                                        (GDestroyNotify) flatview_unref);
     if (!empty_view) {
@@ -955,14 +1544,26 @@ static void flatviews_init(void)
     }
 }
 
+/*
+ * called only by memory_region_transaction_commit()
+ *
+ * 核心思想是"重新"初始化全局的GHashTable flat_views,
+ * 为address_spaces链表的每一个AddressSpace生成一份FlatView
+ * 然后插入flat_views(GHashTable)
+ */
 static void flatviews_reset(void)
 {
     AddressSpace *as;
 
+    /* static GHashTable *flat_views; */
     if (flat_views) {
         g_hash_table_unref(flat_views);
         flat_views = NULL;
     }
+    /*
+     * 就是"重新"初始化全局的GHashTable flat_views,
+     * 然后根据情况把root mr是NULL的FlatView放入
+     */
     flatviews_init();
 
     /* Render unique FVs */
@@ -973,10 +1574,21 @@ static void flatviews_reset(void)
             continue;
         }
 
+	/*
+	 * 生成FlatView
+	 */
         generate_memory_topology(physmr);
     }
 }
 
+/*
+ * called by:
+ *   - memory.c|1411| <<address_space_update_topology>> address_space_set_flatview(as);
+ *   - memory.c|1442| <<memory_region_transaction_commit>> address_space_set_flatview(as);
+ *
+ * 核心思想是逐一对比AddressSpace的新旧FlatView的差别,然后进行更新,
+ * 比如将FlatView模型通过KVM_SET_USER_MEMORY_REGION注册到KVM模块中
+ */
 static void address_space_set_flatview(AddressSpace *as)
 {
     FlatView *old_view = address_space_to_flatview(as);
@@ -1001,6 +1613,10 @@ static void address_space_set_flatview(AddressSpace *as)
         if (!old_view2) {
             old_view2 = &tmpview;
         }
+	/*
+	 * 逐一对比新旧FlatView的差别,然后进行更新, 比如将FlatView模型通过
+	 * KVM_SET_USER_MEMORY_REGION注册到KVM模块中
+	 */
         address_space_update_topology_pass(as, old_view2, new_view, false);
         address_space_update_topology_pass(as, old_view2, new_view, true);
     }
@@ -1022,14 +1638,58 @@ static void address_space_set_flatview(AddressSpace *as)
     }
 }
 
+/*
+ * called only by:
+ *   - memory.c|2833| <<address_space_init>> address_space_update_topology(as);
+ *
+ * hotplug e1000网卡的例子:
+ * (gdb) bt
+ * #0  address_space_update_topology (as=0x5555566fce30) at /home/zhang/kvm/qemu-3.0.0/memory.c:1027
+ * #1  0x0000555555839bce in address_space_init (as=0x5555566fce30, root=0x5555566fce90, name=0x5555566fccd8 "e1000") at /home/zhang/kvm/qemu-3.0.0/memory.c:2801
+ * #2  0x0000555555af5232 in do_pci_register_device (pci_dev=0x5555566fcc20, name=0x5555565190c0 "e1000", devfn=40, errp=0x7fffffffcb60) at hw/pci/pci.c:1026
+ * #3  0x0000555555af76d3 in pci_qdev_realize (qdev=0x5555566fcc20, errp=0x7fffffffcb60) at hw/pci/pci.c:2021
+ * #4  0x0000555555a2d447 in device_set_realized (obj=0x5555566fcc20, value=true, errp=0x7fffffffcd30) at hw/core/qdev.c:826
+ * #5  0x0000555555c21bc7 in property_set_bool (obj=0x5555566fcc20, v=0x5555572103f0, name=0x555555db778a "realized", opaque=0x555556925990, errp=0x7fffffffcd30)
+ *     at qom/object.c:1984
+ * #6  0x0000555555c1fe4c in object_property_set (obj=0x5555566fcc20, v=0x5555572103f0, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1176
+ * #7  0x0000555555c22f04 in object_property_set_qobject (obj=0x5555566fcc20, value=0x5555575c4f80, name=0x555555db778a "realized", errp=0x7fffffffcd30)
+ *     at qom/qom-qobject.c:27
+ * #8  0x0000555555c20131 in object_property_set_bool (obj=0x5555566fcc20, value=true, name=0x555555db778a "realized", errp=0x7fffffffcd30) at qom/object.c:1242
+ * #9  0x0000555555990749 in qdev_device_add (opts=0x55555739f8d0, errp=0x7fffffffcda0) at qdev-monitor.c:627
+ * #10 0x0000555555990f32 in qmp_device_add (qdict=0x555556ffff10, ret_data=0x0, errp=0x7fffffffcde0) at qdev-monitor.c:807
+ * #11 0x00005555559bebd7 in hmp_device_add (mon=0x5555565fb820, qdict=0x555556ffff10) at hmp.c:2008
+ * #12 0x00005555558230ac in handle_hmp_command (mon=0x5555565fb820, cmdline=0x5555565fe2cb "e1000,netdev=nd1") at /home/zhang/kvm/qemu-3.0.0/monitor.c:3488
+ * #13 0x0000555555825467 in monitor_command_cb (opaque=0x5555565fb820, cmdline=0x5555565fe2c0 "device_add e1000,netdev=nd1", readline_opaque=0x0)
+ *     at /home/zhang/kvm/qemu-3.0.0/monitor.c:4365
+ * #14 0x0000555555d6c64f in readline_handle_byte (rs=0x5555565fe2c0, ch=13) at util/readline.c:393
+ * #15 0x00005555558253ba in monitor_read (opaque=0x5555565fb820, buf=0x7fffffffcfa0 "\r\037\342UUU", size=1) at /home/zhang/kvm/qemu-3.0.0/monitor.c:4348
+ * #16 0x0000555555ccbf19 in qemu_chr_be_write_impl (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:175
+ * #17 0x0000555555ccbf7d in qemu_chr_be_write (s=0x5555565d33e0, buf=0x7fffffffcfa0 "\r\037\342UUU", len=1) at chardev/char.c:187
+ * #18 0x0000555555cce691 in fd_chr_read (chan=0x5555565d35f0, cond=G_IO_IN, opaque=0x5555565d33e0) at chardev/char-fd.c:66
+ * #19 0x0000555555cee3b9 in qio_channel_fd_source_dispatch (source=0x5555574b9b40, callback=0x555555cce533 <fd_chr_read>, user_data=0x5555565d33e0)
+ *     at io/channel-watch.c:84
+ * #20 0x00007ffff5e9904a in g_main_context_dispatch () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
+ * #21 0x0000555555d4f922 in glib_pollfds_poll () at util/main-loop.c:215
+ * #22 0x0000555555d4f990 in os_host_main_loop_wait (timeout=198784721) at util/main-loop.c:238
+ * #23 0x0000555555d4fa49 in main_loop_wait (nonblocking=0) at util/main-loop.c:497
+ * #24 0x00005555559967aa in main_loop () at vl.c:1866
+ * #25 0x000055555599dfbd in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4644
+ */
 static void address_space_update_topology(AddressSpace *as)
 {
     MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
 
     flatviews_init();
     if (!g_hash_table_lookup(flat_views, physmr)) {
+        /*
+	 * physmr可以临时理解成AddressSpace的root
+	 */
         generate_memory_topology(physmr);
     }
+    /*
+     * 核心思想是逐一对比AddressSpace的新旧FlatView的差别,然后进行更新,
+     * 比如将FlatView模型通过KVM_SET_USER_MEMORY_REGION注册到KVM模块中
+     */
     address_space_set_flatview(as);
 }
 
@@ -1049,18 +1709,46 @@ void memory_region_transaction_commit(void)
     --memory_region_transaction_depth;
     if (!memory_region_transaction_depth) {
         if (memory_region_update_pending) {
+            /*
+	     * 核心思想是"重新"初始化全局的GHashTable flat_views,
+	     * 为address_spaces链表的每一个AddressSpace生成一份FlatView
+	     * 然后插入flat_views(GHashTable)
+	     */
             flatviews_reset();
 
+	    /*
+	     * 从前向后遍历调用memory_listeners中的每个MemoryListener,
+	     * 并调用begin方法
+	     *
+	     * 设置beigin的地方:
+	     *   - hw/virtio/vhost.c|1232| <<vhost_dev_init>> .begin = vhost_begin,
+	     */
             MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);
 
+	    /*
+	     * address_spaces是一个链表 装着所有的AddressSpace
+	     */
             QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+                /*
+		 * 核心思想是逐一对比AddressSpace的新旧FlatView的差别,然后进行更新,
+		 * 比如将FlatView模型通过KVM_SET_USER_MEMORY_REGION注册到KVM模块中
+		 */
                 address_space_set_flatview(as);
                 address_space_update_ioeventfds(as);
             }
             memory_region_update_pending = false;
             ioeventfd_update_pending = false;
+	    /*
+	     * 设置commit的地方:
+	     *   - hw/virtio/vhost.c|1233| <<vhost_dev_init>> .commit = vhost_commit,
+	     *   - hw/virtio/virtio.c|2532| <<virtio_device_realize>> vdev->listener.commit = virtio_memory_listener_commit;
+	     *   - exec.c|1149| <<cpu_address_space_init>> newas->tcg_as_listener.commit = tcg_commit;
+	     */
             MEMORY_LISTENER_CALL_GLOBAL(commit, Forward);
         } else if (ioeventfd_update_pending) {
+            /*
+	     * address_spaces是一个链表 装着所有的AddressSpace
+	     */
             QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
                 address_space_update_ioeventfds(as);
             }
@@ -1112,6 +1800,13 @@ static char *memory_region_escape_name(const char *name)
     return escaped;
 }
 
+/*
+ * called by:
+ *   - memory.c|1158| <<memory_region_init>> memory_region_do_init(mr, owner, name, size);
+ *   - memory.c|1691| <<memory_region_init_iommu>> memory_region_do_init(mr, owner, name, size);
+ *
+ * 比如system_memory的name是"system", size是UINT64_MAX, owner是NULL
+ */
 static void memory_region_do_init(MemoryRegion *mr,
                                   Object *owner,
                                   const char *name,
@@ -1127,6 +1822,19 @@ static void memory_region_do_init(MemoryRegion *mr,
 
     if (name) {
         char *escaped_name = memory_region_escape_name(name);
+	/*
+	 * 对于system的内存, 这里执行完了就是system[*], 在object_property_add()会把[*]改动了
+	 *
+	 * (gdb) bt
+	 * #0  object_property_add (obj=0x5555568512d0, name=0x555556851250 "system[*]", type=0x555556851530 "child<qemu:memory-region>", get=0x555555c5f037 <object_get_child_property>, set=0x0, 
+	 *     release=0x555555c5f0cb <object_finalize_child_property>, opaque=0x555556850cd0, errp=0x7fffffffe060) at qom/object.c:990
+	 * #1  0x0000555555c5f1e6 in object_property_add_child (obj=0x5555568512d0, name=0x555556851250 "system[*]", child=0x555556850cd0, errp=0x555556751590 <error_abort>) at qom/object.c:1507
+	 * #2  0x0000555555866c8c in memory_region_do_init (mr=0x555556850cd0, owner=0x5555568512d0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1136
+	 * #3  0x0000555555866cfb in memory_region_init (mr=0x555556850cd0, owner=0x0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1149
+	 * #4  0x0000555555803699 in memory_map_init () at /home/zhang/kvm/qemu-3.0.0/exec.c:3100
+	 * #5  0x0000555555804201 in cpu_exec_init_all () at /home/zhang/kvm/qemu-3.0.0/exec.c:3534
+	 * #6  0x00005555559dea90 in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4046
+	 */
         char *name_array = g_strdup_printf("%s[*]", escaped_name);
 
         if (!owner) {
@@ -1140,12 +1848,29 @@ static void memory_region_do_init(MemoryRegion *mr,
     }
 }
 
+/*
+ * 被非常多的外部调用
+ *
+ * 初始化MemoryRegion,比如:
+ *     根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ *     MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+ *     然后简单初始化MemoryRegion的各个field
+ */
 void memory_region_init(MemoryRegion *mr,
                         Object *owner,
                         const char *name,
                         uint64_t size)
 {
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     *
+     * MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+     */
     object_initialize(mr, sizeof(*mr), TYPE_MEMORY_REGION);
+    /*
+     * 简单初始化MemoryRegion的各个field
+     */
     memory_region_do_init(mr, owner, name, size);
 }
 
@@ -1166,6 +1891,10 @@ static void memory_region_get_container(Object *obj, Visitor *v,
     gchar *path = (gchar *)"";
 
     if (mr->container) {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         path = object_get_canonical_path(OBJECT(mr->container));
     }
     visit_type_str(v, name, &path, errp);
@@ -1201,6 +1930,12 @@ static void memory_region_get_size(Object *obj, Visitor *v, const char *name,
     visit_type_uint64(v, name, &value, errp);
 }
 
+/*
+ * TypeInfo memory_region_info.instance_init = memory_reagion_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void memory_region_initfn(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -1214,6 +1949,10 @@ static void memory_region_initfn(Object *obj)
     QTAILQ_INIT(&mr->subregions);
     QTAILQ_INIT(&mr->coalesced);
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     op = object_property_add(OBJECT(mr), "container",
                              "link<" TYPE_MEMORY_REGION ">",
                              memory_region_get_container,
@@ -1221,20 +1960,38 @@ static void memory_region_initfn(Object *obj)
                              NULL, NULL, &error_abort);
     op->resolve = memory_region_resolve_container;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(OBJECT(mr), "addr", "uint64",
                         memory_region_get_addr,
                         NULL, /* memory_region_set_addr */
                         NULL, NULL, &error_abort);
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(OBJECT(mr), "priority", "uint32",
                         memory_region_get_priority,
                         NULL, /* memory_region_set_priority */
                         NULL, NULL, &error_abort);
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(OBJECT(mr), "size", "uint64",
                         memory_region_get_size,
                         NULL, /* memory_region_set_size, */
                         NULL, NULL, &error_abort);
 }
 
+/*
+ * TypeInfo iommu_memory_region_info.instance_init = iommu_memory_region_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void iommu_memory_region_initfn(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -1326,6 +2083,10 @@ static void memory_region_ram_device_write(void *opaque, hwaddr addr,
     }
 }
 
+/*
+ * used by:
+ *   - memory.c|2043| <<memory_region_init_ram_device_ptr>> mr->ops = &ram_device_mem_ops;
+ */
 static const MemoryRegionOps ram_device_mem_ops = {
     .read = memory_region_ram_device_read,
     .write = memory_region_ram_device_write,
@@ -1489,6 +2250,109 @@ MemTxResult memory_region_dispatch_write(MemoryRegion *mr,
     }
 }
 
+/*
+ * [0]  mark_mmio_spte [kvm]
+ * [0]  set_spte [kvm]
+ * [0]  mmu_set_spte [kvm]
+ * [0]  __direct_map [kvm]
+ * [0]  tdp_page_fault [kvm]
+ * [0]  kvm_mmu_page_fault [kvm]
+ * [0]  kvm_arch_vcpu_ioctl_run [kvm]
+ * [0]  kvm_vcpu_ioctl [kvm]
+ * [0]  do_vfs_ioctl
+ * [0]  ksys_ioctl
+ * [0]  __x64_sys_ioctl
+ * [0]  do_syscall_64
+ * [0]  entry_SYSCALL_64_after_hwframe
+ *
+ * [0]  is_noslot_pfn()
+ * [0]  set_spte [kvm]
+ * [0]  mmu_set_spte [kvm]
+ * [0]  __direct_map [kvm]
+ * [0]  tdp_page_fault [kvm]
+ * [0]  kvm_mmu_page_fault [kvm]
+ * [0]  kvm_arch_vcpu_ioctl_run [kvm]
+ * [0]  kvm_vcpu_ioctl [kvm]
+ * [0]  do_vfs_ioctl
+ * [0]  ksys_ioctl
+ * [0]  __x64_sys_ioctl
+ * [0]  do_syscall_64
+ * [0]  entry_SYSCALL_64_after_hwframe
+ *
+ * [0]  __gfn_to_pfn_memslot [kvm]
+ * [0]  try_async_pf [kvm]
+ * [0]  tdp_page_fault [kvm]
+ * [0]  kvm_mmu_page_fault [kvm]
+ * [0]  kvm_arch_vcpu_ioctl_run [kvm]
+ * [0]  kvm_vcpu_ioctl [kvm]
+ * [0]  do_vfs_ioctl
+ * [0]  ksys_ioctl
+ * [0]  __x64_sys_ioctl
+ * [0]  do_syscall_64
+ * [0]  entry_SYSCALL_64_after_hwframe
+ *
+ * 应该是kvm misconfig中设置pte的代码:
+ *  362 static bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,
+ *  363                           kvm_pfn_t pfn, unsigned access)
+ *  364 {
+ *  365         if (unlikely(is_noslot_pfn(pfn))) {
+ *  366                 mark_mmio_spte(vcpu, sptep, gfn, access);
+ *  367                 return true;
+ *  368         }
+ *  369 
+ *  370         return false;
+ *  371 }
+ *
+ *
+ *  3856 static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,
+ *  3857                          gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable)
+ *  3858 {
+ *  3859         struct kvm_memory_slot *slot;
+ *  3860         bool async;
+ *  3861         
+ *  3863         // Don't expose private memslots to L2.
+ *  3865         if (is_guest_mode(vcpu) && !kvm_is_visible_gfn(vcpu->kvm, gfn)) {
+ *  3866                 *pfn = KVM_PFN_NOSLOT;
+ *  3867                 return false;
+ *  3868         }
+ *  3869         
+ *  3870         slot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);
+ *  3871         async = false;
+ *  3872         *pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);
+ *  3873         if (!async)            
+ *  3874                 return false; // pfn has correct page already
+ *  3875 
+ *  3876         if (!prefault && kvm_can_do_async_pf(vcpu)) {
+ *  3877                 trace_kvm_try_async_get_page(gva, gfn);
+ *  3878                 if (kvm_find_async_pf_gfn(vcpu, gfn)) {
+ *  3879                         trace_kvm_async_pf_doublefault(gva, gfn);
+ *  3880                         kvm_make_request(KVM_REQ_APF_HALT, vcpu);
+ *  3881                         return true;
+ *  3882                 } else if (kvm_arch_setup_async_pf(vcpu, gva, gfn))
+ *  3883                         return true;
+ *  3884         }
+ *  3885 
+ *  3886         *pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);
+ *  3887         return false;
+ *  3888 }
+ *
+ *
+ * MMIO是通过设置spte的保留位来标志的.虚拟机内部第一次访问MMIO的gpa时,
+ * 发生了EPT_VIOLATION然后check gpa发现对应的pfn不存在(QEMU没有注册),那
+ * 么认为这是个MMIO,于是set_mmio_spte来标志它的spte是一个MMIO.后面再次访
+ * 问这个gpa时就发生EPT_MISCONFIG了,进而愉快地调用handle_ept_misconfig->
+ * handle_mmio_page_fault->x86_emulate_instruction来处理所有的MMIO操作了
+ */
+
+/*
+ * 初始化MemoryRegion,比如:
+ *     根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ *     MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+ *     然后简单初始化MemoryRegion的各个field
+ * 设置mr的ops, opaqueue和terminates=true
+ *
+ * 这里mr->ram是false!!!!!!!!!!!!!!1
+ */
 void memory_region_init_io(MemoryRegion *mr,
                            Object *owner,
                            const MemoryRegionOps *ops,
@@ -1502,6 +2366,13 @@ void memory_region_init_io(MemoryRegion *mr,
     mr->terminates = true;
 }
 
+/*
+ * called by:
+ *   - memory.c|3349| <<memory_region_init_ram>> memory_region_init_ram_nomigrate(mr, owner, name, size, &err);
+ *   - numa.c|499| <<allocate_system_memory_nonnuma>> memory_region_init_ram_nomigrate(mr, owner, name, ram_size, &error_fatal);
+ *   - numa.c|506| <<allocate_system_memory_nonnuma>> memory_region_init_ram_nomigrate(mr, owner, name, ram_size, &error_fatal);
+ *   - hw/pci-host/prep.c|308| <<raven_realize>> memory_region_init_ram_nomigrate(&s->bios, OBJECT(s), "bios", BIOS_SIZE,
+ */
 void memory_region_init_ram_nomigrate(MemoryRegion *mr,
                                       Object *owner,
                                       const char *name,
@@ -1511,6 +2382,11 @@ void memory_region_init_ram_nomigrate(MemoryRegion *mr,
     memory_region_init_ram_shared_nomigrate(mr, owner, name, size, false, errp);
 }
 
+/*
+ * called by:
+ *   - memory.c|1633| <<memory_region_init_ram_nomigrate>> memory_region_init_ram_shared_nomigrate(mr, owner, name, size, false, errp);
+ *   - backends/hostmem-ram.c|31| <<ram_backend_memory_alloc>> memory_region_init_ram_shared_nomigrate(&backend->mr, OBJECT(backend), path,
+ */
 void memory_region_init_ram_shared_nomigrate(MemoryRegion *mr,
                                              Object *owner,
                                              const char *name,
@@ -1610,6 +2486,22 @@ void memory_region_init_ram_device_ptr(MemoryRegion *mr,
     mr->opaque = mr;
 }
 
+/*
+ * 调用的一个例子:
+ * 1362     memory_region_init_alias(ram_below_4g, NULL, "ram-below-4g", ram,
+ * 1363                              0, pcms->below_4g_mem_size);
+ * 1364     memory_region_add_subregion(system_memory, 0, ram_below_4g);
+ *
+ * alias: a subsection of another region.  Aliases allow a region to be
+ * split apart into discontiguous regions.  Examples of uses are memory banks
+ * used when the guest address space is smaller than the amount of RAM
+ * addressed, or a memory controller that splits main memory to expose a "PCI
+ * hole".  Aliases may point to any type of region, including other aliases,
+ * but an alias may not point back to itself, directly or indirectly.
+ * You initialize these with memory_region_init_alias().
+ *
+ * 把mr设置为orig的一个alias, 也就是表示orig的一部分
+ */
 void memory_region_init_alias(MemoryRegion *mr,
                               Object *owner,
                               const char *name,
@@ -1617,6 +2509,12 @@ void memory_region_init_alias(MemoryRegion *mr,
                               hwaddr offset,
                               uint64_t size)
 {
+    /*
+     * 初始化MemoryRegion,比如:
+     *     根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     *     MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+     *     然后简单初始化MemoryRegion的各个field
+     */
     memory_region_init(mr, owner, name, size);
     mr->alias = orig;
     mr->alias_offset = offset;
@@ -1674,6 +2572,12 @@ void memory_region_init_iommu(void *_iommu_mr,
     iommu_mr->iommu_notify_flags = IOMMU_NOTIFIER_NONE;
 }
 
+/*
+ * TypeInfo memory_region_info.instance_finalize = memory_region_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void memory_region_finalize(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -2290,41 +3194,112 @@ void memory_region_del_eventfd(MemoryRegion *mr,
     memory_region_transaction_commit();
 }
 
+/*
+ * 按照priority把subregion插入到上一层的MemoryRegion的subregions链表
+ * "上一层"的意思就是说这个region是上一层的subregion
+ * 没有好的位置就插入到最后
+ * 最后还要memory_region_transaction_commit()
+ */
 static void memory_region_update_container_subregions(MemoryRegion *subregion)
 {
+    /* container里存着subregion上一层的MemoryRegion */
     MemoryRegion *mr = subregion->container;
     MemoryRegion *other;
 
     memory_region_transaction_begin();
 
     memory_region_ref(subregion);
+    /*
+     * mr是参数subregion的上一层的MemoryRegion
+     *
+     * 按照priority把subregion插入到上一层的MemoryRegion的subregions链表
+     * "上一层"的意思就是说这个region是上一层的subregion
+     */
     QTAILQ_FOREACH(other, &mr->subregions, subregions_link) {
         if (subregion->priority >= other->priority) {
             QTAILQ_INSERT_BEFORE(other, subregion, subregions_link);
             goto done;
         }
     }
+    /* 没有好的位置就插入到最后 */
     QTAILQ_INSERT_TAIL(&mr->subregions, subregion, subregions_link);
 done:
+    /* 如果memory_region_update_pending了memory_region_transaction_commit()就会做很多工作 */
     memory_region_update_pending |= mr->enabled && subregion->enabled;
     memory_region_transaction_commit();
 }
 
+/*
+ * called by:
+ *   - memory.c|2627| <<memory_region_add_subregion>> memory_region_add_subregion_common(mr, offset, subregion);
+ *   - memory.c|2636| <<memory_region_add_subregion_overlap>> memory_region_add_subregion_common(mr, offset, subregion);
+ *
+ * offset应该是物理内存中的offset, 把subregion挂到这个地址?
+ *
+ * 设置subregion的container和addr (记录该region在物理内存的地址)
+ * 按照priority把subregion插入到上一层的MemoryRegion的subregions链表
+ * "上一层"的意思就是说这个region是上一层的subregion
+ * 没有好的位置就插入到最后
+ * 最后还要memory_region_transaction_commit()
+ */
 static void memory_region_add_subregion_common(MemoryRegion *mr,
                                                hwaddr offset,
                                                MemoryRegion *subregion)
 {
     assert(!subregion->container);
     subregion->container = mr;
+    /* 记录该region在物理内存的地址 */
     subregion->addr = offset;
+    /*
+     * 按照priority把subregion插入到上一层的MemoryRegion的subregions链表
+     * "上一层"的意思就是说这个region是上一层的subregion
+     * 没有好的位置就插入到最后
+     * 最后还要memory_region_transaction_commit()
+     */
     memory_region_update_container_subregions(subregion);
 }
 
+/*
+ * 设置内存地址的地方
+ *
+ * 一些使用的例子:
+ *   - hw/i386/pc.c|1352| <<pc_memory_init>> memory_region_add_subregion(system_memory, 0, ram_below_4g);
+ *   - hw/i386/pc.c|1359| <<pc_memory_init>> memory_region_add_subregion(system_memory, 0x100000000ULL,
+ *   - hw/i386/pc.c|1412| <<pc_memory_init>> memory_region_add_subregion(system_memory, machine->device_memory->base,
+ *   - hw/i386/pc.c|1578| <<pc_basic_device_init>> memory_region_add_subregion(isa_bus->address_space_io, 0x80, ioport80_io);
+ *   - hw/i386/pc.c|1581| <<pc_basic_device_init>> memory_region_add_subregion(isa_bus->address_space_io, 0xf0, ioportF0_io);
+ *   - hw/vfio/common.c|858| <<vfio_region_mmap>> memory_region_add_subregion(region->mem, region->mmaps[i].offset,
+ *   - hw/vfio/pci-quirks.c|429| <<vfio_vga_probe_ati_3c3_quirk>> memory_region_add_subregion(&vdev->vga->region[QEMU_PCI_VGA_IO_HI].mem,
+ *   - hw/vfio/pci-quirks.c|686| <<vfio_vga_probe_nvidia_3d0_quirk>> memory_region_add_subregion(&vdev->vga->region[QEMU_PCI_VGA_IO_HI].mem,
+ *   - hw/vfio/pci-quirks.c|691| <<vfio_vga_probe_nvidia_3d0_quirk>> memory_region_add_subregion(&vdev->vga->region[QEMU_PCI_VGA_IO_HI].mem,
+ *   - hw/vfio/pci.c|1676| <<vfio_bar_register>> memory_region_add_subregion(bar->mr, 0, bar->region.mem);
+ *   - hw/virtio/virtio-pci.c|1517| <<virtio_pci_modern_region_map>> memory_region_add_subregion(mr, region->offset, &region->mr);
+ *   - hw/pci/msix.c|348| <<msix_init>> memory_region_add_subregion(table_bar, table_offset, &dev->msix_table_mmio);
+ *   - hw/pci/msix.c|351| <<msix_init>> memory_region_add_subregion(pba_bar, pba_offset, &dev->msix_pba_mmio);
+ *   - hw/pci/pci.c|97| <<pci_init_bus_master>> memory_region_add_subregion(&pci_dev->bus_master_container_region, 0,
+ *   - hw/pci/pcie_host.c|118| <<pcie_host_mmcfg_map>> memory_region_add_subregion(get_system_memory(), e->base_addr, &e->mmio);
+ *   - hw/i386/xen/xen-hvm.c|241| <<xen_ram_init>> memory_region_add_subregion(sysmem, 0xc0000, &ram_lo);
+ *
+ * offset应该是物理内存中的offset, 把subregion挂到这个地址?
+ *
+ * 设置subregion的container和addr (记录该region在物理内存的地址)
+ * 按照priority=0把subregion插入到上一层的MemoryRegion的subregions链表
+ * "上一层"的意思就是说这个region是上一层的subregion
+ * 没有好的位置就插入到最后
+ * 最后还要memory_region_transaction_commit()
+ */
 void memory_region_add_subregion(MemoryRegion *mr,
                                  hwaddr offset,
                                  MemoryRegion *subregion)
 {
     subregion->priority = 0;
+    /*
+     * 设置subregion的container和addr (记录该region在物理内存的地址)
+     * 按照priority把subregion插入到上一层的MemoryRegion的subregions链表
+     * "上一层"的意思就是说这个region是上一层的subregion
+     * 没有好的位置就插入到最后
+     * 最后还要memory_region_transaction_commit()
+     */
     memory_region_add_subregion_common(mr, offset, subregion);
 }
 
@@ -2391,6 +3366,23 @@ static void memory_region_readd_subregion(MemoryRegion *mr)
     }
 }
 
+/*
+ * 被很多看似无关的调用:
+ *   - hw/acpi/ich9.c|130| <<ich9_pm_iospace_update>> memory_region_set_address(&pm->io, pm->pm_io_base);
+ *   - hw/acpi/piix4.c|140| <<pm_io_space_update>> memory_region_set_address(&s->io, s->io_base);
+ *   - hw/acpi/piix4.c|153| <<smbus_io_space_update>> memory_region_set_address(&s->smb.io, s->smb_io_base);
+ *   - hw/isa/vt82c686.c|223| <<pm_io_space_update>> memory_region_set_address(&s->io, pm_io_base);
+ *   - hw/misc/mips_cmgcr.c|37| <<update_gcr_base>> memory_region_set_address(&gcr->iomem, gcr->gcr_base);
+ *   - hw/misc/mips_cmgcr.c|50| <<update_cpc_base>> memory_region_set_address(gcr->cpc_mr,
+ *   - hw/misc/mips_cmgcr.c|63| <<update_gic_base>> memory_region_set_address(gcr->gic_mr,
+ *   - hw/misc/mips_itu.c|91| <<itc_reconfigure>> memory_region_set_address(mr, address);
+ *   - hw/pci-host/designware.c|89| <<designware_pcie_root_update_msi_mapping>> memory_region_set_address(mem, base);
+ *   - hw/pci-host/designware.c|269| <<designware_pcie_update_viewport>> memory_region_set_address(current, base);
+ *   - hw/pci-host/q35.c|423| <<mch_update_smram>> memory_region_set_address(&mch->tseg_window,
+ *   - hw/ppc/rs6000_mc.c|112| <<rs6000mc_port0820_write>> memory_region_set_address(&s->simm[socket - 1],
+ *   - hw/ppc/rs6000_mc.c|186| <<rs6000mc_realize>> memory_region_set_address(&s->simm[socket], start_address);
+ *   - hw/ssi/aspeed_smc.c|373| <<aspeed_smc_flash_set_segment>> memory_region_set_address(&fl->mmio, seg.addr - s->ctrl->flash_window_base);
+ */
 void memory_region_set_address(MemoryRegion *mr, hwaddr addr)
 {
     if (addr != mr->addr) {
@@ -2633,6 +3625,29 @@ static void listener_del_address_space(MemoryListener *listener,
     flatview_unref(view);
 }
 
+/*
+ * 注意kvm的是重点
+ * accel/kvm/kvm-all.c|899| <<kvm_memory_listener_register>> memory_listener_register(&kml->listener, as);
+ * accel/kvm/kvm-all.c|1699| <<kvm_init>> memory_listener_register(&kvm_io_listener,
+ *								   &address_space_io);
+ * exec.c|929| <<cpu_address_space_init>> memory_listener_register(&newas->tcg_as_listener, as);
+ * hw/i386/xen/xen-hvm.c|1472| <<xen_hvm_init>> memory_listener_register(&state->memory_listener, &address_space_memory);
+ * hw/i386/xen/xen-hvm.c|1476| <<xen_hvm_init>> memory_listener_register(&state->io_listener, &address_space_io);
+ * hw/vfio/common.c|1151| <<vfio_connect_container>> memory_listener_register(&container->prereg_listener,
+ * hw/vfio/common.c|1210| <<vfio_connect_container>> memory_listener_register(&container->listener, container->space->as);
+ * hw/virtio/vhost.c|1277| <<vhost_dev_init>> memory_listener_register(&hdev->memory_listener, &address_space_memory);
+ * hw/virtio/vhost.c|1503| <<vhost_dev_start>> memory_listener_register(&hdev->iommu_listener, vdev->dma_as);
+ * hw/virtio/virtio.c|2533| <<virtio_device_realize>> memory_listener_register(&vdev->listener, vdev->dma_as);
+ * hw/xen/xen_pt.c|910| <<xen_pt_realize>> memory_listener_register(&s->memory_listener, &address_space_memory);
+ * hw/xen/xen_pt.c|911| <<xen_pt_realize>> memory_listener_register(&s->io_listener, &address_space_io);
+ * memory_mapping.c|270| <<guest_phys_blocks_append>> memory_listener_register(&g.listener, &address_space_memory);
+ *
+ * 进行内存更新有很多个点,比如我们新创建了一个AddressSpace address_space_init,再比如我们将
+ * 一个mr添加到另一个mr的subregions中memory_region_add_subregion,再比如我们更改了一端内存
+ * 的属性memory_region_set_readonly,将一个mr设置使能或者非使能memory_region_set_enabled,
+ * 总之一句话,我们修改了虚拟机的内存布局/属性时,就需要通知到各个Listener,这包括各个AddressSpace
+ * 对应的,以及kvm注册的,这个过程叫做commit,通过函数memory_region_transaction_commit实现.
+ */
 void memory_listener_register(MemoryListener *listener, AddressSpace *as)
 {
     MemoryListener *other = NULL;
@@ -2788,6 +3803,16 @@ void memory_region_invalidate_mmio_ptr(MemoryRegion *mr, hwaddr offset,
                           RUN_ON_CPU_HOST_PTR(invalidate_data));
 }
 
+/*
+ * 被很多外部调用, 一些调用的例子:
+ *   - exec.c|3109| <<memory_map_init>> address_space_init(&address_space_memory, system_memory, "memory");
+ *   - exec.c|3114| <<memory_map_init>> address_space_init(&address_space_io, system_io, "I/O");
+ *   - exec.c|906| <<cpu_address_space_init>> address_space_init(as, mr, as_name);
+ *   - hw/i386/amd_iommu.c|1055| <<amdvi_host_dma_iommu>> address_space_init(&iommu_as[devfn]->as,
+ *   - hw/i386/intel_iommu.c|2934| <<vtd_find_add_as>> address_space_init(&vtd_dev_as->as, &vtd_dev_as->root, name);
+ *   - hw/pci/pci.c|1047| <<do_pci_register_device>> address_space_init(&pci_dev->bus_master_as,
+ *   - target/i386/kvm.c|1372| <<register_smram_listener>> address_space_init(&smram_address_space, &smram_as_root, "KVM-SMRAM");
+ */
 void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
 {
     memory_region_ref(root);
@@ -2796,7 +3821,11 @@ void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
     as->ioeventfd_nb = 0;
     as->ioeventfds = NULL;
     QTAILQ_INIT(&as->listeners);
+    /* 把AddressSpace插入全局链表address_spaces */
     QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
+    /*
+     * 从memory_map_init()调用来的时候, name的例子是"memory"或者"I/O"
+     */
     as->name = g_strdup(name ? name : "anonymous");
     address_space_update_topology(as);
     address_space_update_ioeventfds(as);
@@ -2867,6 +3896,10 @@ static void mtree_expand_owner(fprintf_function mon_printf, void *f,
     if (dev && dev->id) {
         mon_printf(f, " id=%s", dev->id);
     } else {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         gchar *canonical_path = object_get_canonical_path(obj);
         if (canonical_path) {
             mon_printf(f, " path=%s", canonical_path);
@@ -3232,7 +4265,7 @@ static const TypeInfo memory_region_info = {
     .parent             = TYPE_OBJECT,
     .name               = TYPE_MEMORY_REGION,
     .instance_size      = sizeof(MemoryRegion),
-    .instance_init      = memory_region_initfn,
+    .instance_init      = memory_region_initfn, // 一个MemoryRegion有addr和size等属性
     .instance_finalize  = memory_region_finalize,
 };
 
@@ -3247,8 +4280,13 @@ static const TypeInfo iommu_memory_region_info = {
 
 static void memory_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&memory_region_info);
     type_register_static(&iommu_memory_region_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(memory_register_types)
diff --git a/numa.c b/numa.c
index 5f6367b..abc8bcc 100644
--- a/numa.c
+++ b/numa.c
@@ -346,6 +346,10 @@ void numa_default_auto_assign_ram(MachineClass *mc, NodeInfo *nodes,
     nodes[i].node_mem = size - usedmem;
 }
 
+/*
+ * called only by:
+ *   - hw/core/machine.c|839| <<machine_run_board_init>> numa_complete_configuration(machine);
+ */
 void numa_complete_configuration(MachineState *ms)
 {
     int i;
diff --git a/qapi/qobject-input-visitor.c b/qapi/qobject-input-visitor.c
index da57f4c..27269ff 100644
--- a/qapi/qobject-input-visitor.c
+++ b/qapi/qobject-input-visitor.c
@@ -658,6 +658,11 @@ static void qobject_input_free(Visitor *v)
     g_free(qiv);
 }
 
+/*
+ * QObjectInputVisitor的root里存着QObject
+ *
+ * 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是QObject
+ */
 static QObjectInputVisitor *qobject_input_visitor_base_new(QObject *obj)
 {
     QObjectInputVisitor *v = g_malloc0(sizeof(*v));
@@ -681,8 +686,13 @@ static QObjectInputVisitor *qobject_input_visitor_base_new(QObject *obj)
     return v;
 }
 
+/*
+ * 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是QObject
+ * 返回包含的Visitor
+ */
 Visitor *qobject_input_visitor_new(QObject *obj)
 {
+    /* 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是QObject */
     QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);
 
     v->visitor.type_int64 = qobject_input_type_int64;
diff --git a/qdev-monitor.c b/qdev-monitor.c
index 61e0300..fa7170d 100644
--- a/qdev-monitor.c
+++ b/qdev-monitor.c
@@ -219,6 +219,12 @@ static DeviceClass *qdev_get_device_class(const char **driver, Error **errp)
         }
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {
         if (*driver != original_name) {
             error_setg(errp, "'%s' (alias '%s') is not a valid device model"
@@ -554,6 +560,20 @@ void qdev_set_id(DeviceState *dev, const char *id)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
 {
     DeviceClass *dc;
diff --git a/qom/container.c b/qom/container.c
index f6ccaf7..2b95881 100644
--- a/qom/container.c
+++ b/qom/container.c
@@ -22,23 +22,103 @@ static const TypeInfo container_info = {
 
 static void container_register_types(void)
 {
+    /*
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&container_info);
 }
 
+/*
+ * 很多调用,其中一个例子:
+ *   - qom/object.c|2350| <<object_get_objects_root>> return container_get(object_get_root(), "/objects");
+ *
+ * (gdb) bt
+ * #0  container_get (root=0x55555684fb30, path=0x555555ee0c1e "/machine") at qom/container.c:34
+ * #1  0x0000555555a749f5 in qdev_get_machine () at hw/core/qdev.c:1095
+ * #2  0x0000555555866c5e in memory_region_do_init (mr=0x555556850cc0, owner=0x0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1133
+ * #3  0x0000555555866cfb in memory_region_init (mr=0x555556850cc0, owner=0x0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1149
+ * #4  0x0000555555803699 in memory_map_init () at /home/zhang/kvm/qemu-3.0.0/exec.c:3100
+ * #5  0x0000555555804201 in cpu_exec_init_all () at /home/zhang/kvm/qemu-3.0.0/exec.c:3534
+ * #6  0x00005555559dea90 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4046
+ *
+ * (gdb) bt
+ * #0  container_get (root=0x55555684f700, path=0x555555ee0b3f "/unattached") at qom/container.c:34
+ * #1  0x0000555555a73e3c in device_set_realized (obj=0x55555688a0f0, value=true, errp=0x7fffffffdf28) at hw/core/qdev.c:810
+ * #2  0x0000555555c6020e in property_set_bool (obj=0x55555688a0f0, v=0x5555568a2e50, name=0x555555ea7440 "realized", opaque=0x555556869e80, errp=0x7fffffffdf28) at qom/object.c:1984
+ * #3  0x0000555555c5e493 in object_property_set (obj=0x55555688a0f0, v=0x5555568a2e50, name=0x555555ea7440 "realized", errp=0x7fffffffdf28) at qom/object.c:1176
+ * #4  0x0000555555c6154b in object_property_set_qobject (obj=0x55555688a0f0, value=0x5555568a74f0, name=0x555555ea7440 "realized", errp=0x7fffffffdf28) at qom/qom-qobject.c:27
+ * #5  0x0000555555c5e778 in object_property_set_bool (obj=0x55555688a0f0, value=true, name=0x555555ea7440 "realized", errp=0x7fffffffdf28) at qom/object.c:1242
+ * #6  0x00005555559184e7 in pc_new_cpu (typename=0x555555ea7dec "qemu64-x86_64-cpu", apic_id=0, errp=0x555556751598 <error_fatal>) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1107
+ * #7  0x0000555555918752 in pc_cpus_init (pcms=0x55555684f700) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1155
+ * #8  0x000055555591cd4d in pc_init1 (machine=0x55555684f700, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:153
+ * #9  0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f700) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #10 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f700) at hw/core/machine.c:830
+ * #11 0x00005555559dfb8f in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4516
+ *
+ * 在这个例子中, machine是name, child<pc-i440fx-3.0-machine>是type
+ *    (qemu) qom-list /
+ *    machine (child<pc-i440fx-3.0-machine>)
+ *    type (string)
+ *    chardevs (child<container>)
+ *    backend (child<container>)
+ *
+ * 以下的调用可以在"qom-list /"中看到:
+ *   - hw/core/qdev.c|1236| <<qdev_get_machine>> dev = container_get(object_get_root(), "/machine"); ---> 测试的时候"/machine"不是在这里的container_get()初始化的
+ *   - chardev/char.c|46| <<get_chardevs_root>> return container_get(object_get_root(), "/chardevs");
+ *   - ui/console.c|1896| <<init_displaystate>> object_property_add_child(container_get(object_get_root(), "/backend"),
+ *   - qom/object.c|2350| <<object_get_objects_root>> return container_get(object_get_root(), "/objects");
+ *   - drc_container = container_get(object_get_root(), "/dr-connector");
+ *   - hw/ppc/spapr_drc.c|504| <<realize>> root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);
+ *   - hw/ppc/spapr_drc.c|529| <<unrealize>> root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);
+ *   - hw/ppc/spapr_drc.c|806| <<spapr_drc_populate_dt>> root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);
+ *   - scsi/pr-manager.c|148| <<qmp_query_pr_managers>> Object *container = container_get(object_get_root(), PR_MANAGER_PATH);
+ *
+ *
+ * "/machine"应该是在vl.c的main()初始化的:
+ *     4067     object_property_add_child(object_get_root(), "machine",
+ *     4068                               OBJECT(current_machine), &error_abort);
+ */
 Object *container_get(Object *root, const char *path)
 {
     Object *obj, *child;
     gchar **parts;
     int i;
 
+    /*
+     * 把path用'/'分开
+     *
+     * 对于/aaa/bbb/ccc/ddd
+     *     0: (不是NULL) 
+     *     1: aaa
+     *     2: bbb
+     *     3: ccc
+     *     4: ddd
+     *
+     * 对于aaa/bbb/ccc/ddd
+     *     0: aaa
+     *     1: bbb
+     *     2: ccc
+     *     3: ddd
+     */
     parts = g_strsplit(path, "/", 0);
+    /*
+     * 如果是以"/"开头的, parts[0][0]==0
+     */
     assert(parts != NULL && parts[0] != NULL && !parts[0][0]);
     obj = root;
 
+    /* obj=child让下一个iteration的parent换人! */
     for (i = 1; parts[i] != NULL; i++, obj = child) {
+        /* 从obj(Object)的properties(HashTable)中寻找parts[i]代表的prop, 返回其Object */
         child = object_resolve_path_component(obj, parts[i]);
         if (!child) {
             child = object_new("container");
+	    /*
+	     * 把child设置成一个obj的ObjectProperty
+	     * 在Object->properties (GHashTable)的name就是参数的name (patrs[i]), type是"child<child的type>"
+	     * ObjectProperty的opaque是child
+	     * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+	     */
             object_property_add_child(obj, parts[i], child, NULL);
             object_unref(child);
         }
@@ -50,4 +130,8 @@ Object *container_get(Object *root, const char *path)
 }
 
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(container_register_types)
diff --git a/qom/object.c b/qom/object.c
index 75d1d48..823a9c7 100644
--- a/qom/object.c
+++ b/qom/object.c
@@ -31,6 +31,15 @@
 
 #define MAX_INTERFACES 32
 
+/*
+ * 核心函数:
+ *   - type_initialize()
+ *   - object_initialize_with_type() (依赖type_initialize())
+ *
+ * 所有instance的祖先是Object
+ * 所有class的祖先是ObjectClass
+ */
+
 typedef struct InterfaceImpl InterfaceImpl;
 typedef struct TypeImpl TypeImpl;
 
@@ -39,6 +48,15 @@ struct InterfaceImpl
     const char *typename;
 };
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
 struct TypeImpl
 {
     const char *name;
@@ -47,29 +65,85 @@ struct TypeImpl
 
     size_t instance_size;
 
+    /*
+     * called only by:
+     *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+     */
     void (*class_init)(ObjectClass *klass, void *data);
+    /*
+     * called only by:
+     *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+     */
     void (*class_base_init)(ObjectClass *klass, void *data);
+    /*
+     * 似乎目前不调用:
+     *   - hw/core/machine.c|868| <<global>> .class_finalize = machine_class_finalize,
+     *   - qom/object.c|69| <<global>> void (*class_finalize)(ObjectClass *klass, void *data);
+     *   - qom/object.c|179| <<type_new>> ti->class_finalize = info->class_finalize;
+     */
     void (*class_finalize)(ObjectClass *klass, void *data);
 
+    /*
+     * 来自TypeInfo (各个外部自己定义):
+     *   - qom/object.c|198| <<type_new>> ti->class_data = info->class_data;
+     */
     void *class_data;
 
+    /*
+     * called only by:
+     *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+     */
     void (*instance_init)(Object *obj);
+    /*
+     * called only by:
+     *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+     */
     void (*instance_post_init)(Object *obj);
+    /*
+     * called only by:
+     *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+     */
     void (*instance_finalize)(Object *obj);
 
     bool abstract;
 
+    /*
+     * 在type_new()中由TypeInfo->parent获得
+     */
     const char *parent;
+    /*
+     * 设置parent_type的地方:
+     *   - qom/object.c|256| <<type_get_parent>> type->parent_type = type_get_by_name(type->parent);
+     *   - qom/object.c|334| <<type_initialize_interface>> iface_impl->parent_type = parent_type;
+     */
     TypeImpl *parent_type;
 
+    /*
+     * 在type_initialize()中分配
+     */
     ObjectClass *class;
 
     int num_interfaces;
     InterfaceImpl interfaces[MAX_INTERFACES];
 };
 
+/*
+ * TYPE_INTERFACE获得的TypeImpl
+ *
+ * 用到的地方:
+ *   - qom/object.c|1217| <<object_class_dynamic_cast>> type_is_ancestor(target_type, type_interface)) {
+ *   - qom/object.c|3412| <<register_types>> type_interface = type_register_internal(&interface_info);
+ */
 static Type type_interface;
 
+/*
+ * called by:
+ *   - qom/object.c|89| <<type_table_add>> g_hash_table_insert(type_table_get(), (void *)ti->name, ti);
+ *   - qom/object.c|94| <<type_table_lookup>> return g_hash_table_lookup(type_table_get(), name);
+ *   - qom/object.c|889| <<object_class_foreach>> g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
+ *
+ *   如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+ */
 static GHashTable *type_table_get(void)
 {
     static GHashTable *type_table;
@@ -83,17 +157,42 @@ static GHashTable *type_table_get(void)
 
 static bool enumerating_types;
 
+/*
+ * called by only type_register_internal()
+ *
+ * 把一个根据TypeInfo转化成的TypeImpl插入到hashtable
+ */
 static void type_table_add(TypeImpl *ti)
 {
     assert(!enumerating_types);
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     g_hash_table_insert(type_table_get(), (void *)ti->name, ti);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|135| <<type_new>> if (type_table_lookup(info->name) != NULL) {
+ *   - qom/object.c|200| <<type_get_by_name>> return type_table_lookup(name);
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ */
 static TypeImpl *type_table_lookup(const char *name)
 {
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     return g_hash_table_lookup(type_table_get(), name);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|137| <<type_register_internal>> ti = type_new(info);
+ *   - qom/object.c|250| <<type_initialize_interface>> iface_impl = type_new(&info);
+ *
+ * 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 (通过name搜素)
+ */
 static TypeImpl *type_new(const TypeInfo *info)
 {
     TypeImpl *ti = g_malloc0(sizeof(*ti));
@@ -101,6 +200,7 @@ static TypeImpl *type_new(const TypeInfo *info)
 
     g_assert(info->name != NULL);
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     if (type_table_lookup(info->name) != NULL) {
         fprintf(stderr, "Registering `%s' which already exists\n", info->name);
         abort();
@@ -123,6 +223,11 @@ static TypeImpl *type_new(const TypeInfo *info)
 
     ti->abstract = info->abstract;
 
+    /*
+     * TypeImpl包含:
+     *       int num_interfaces;
+     *       InterfaceImpl interfaces[MAX_INTERFACES]; --> 包含const char *typename;
+     */
     for (i = 0; info->interfaces && info->interfaces[i].type; i++) {
         ti->interfaces[i].typename = g_strdup(info->interfaces[i].type);
     }
@@ -131,47 +236,100 @@ static TypeImpl *type_new(const TypeInfo *info)
     return ti;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|191| <<type_register>> return type_register_internal(info);
+ *   - qom/object.c|2503| <<register_types>> type_interface = type_register_internal(&interface_info);
+ *   - qom/object.c|2504| <<register_types>> type_register_internal(&object_info);
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 static TypeImpl *type_register_internal(const TypeInfo *info)
 {
     TypeImpl *ti;
+    /* 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 */
     ti = type_new(info);
 
+    /* 把一个根据TypeInfo转化成的TypeImpl插入到hashtable */
     type_table_add(ti);
     return ti;
 }
 
+/*
+ * 被外部好多好多调用
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 TypeImpl *type_register(const TypeInfo *info)
 {
     assert(info->parent);
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     return type_register_internal(info);
 }
 
+/*
+ * 被外部好多好多调用
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 TypeImpl *type_register_static(const TypeInfo *info)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     return type_register(info);
 }
 
+/*
+ * 为nr_infos个: 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 void type_register_static_array(const TypeInfo *infos, int nr_infos)
 {
     int i;
 
     for (i = 0; i < nr_infos; i++) {
+        /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
         type_register_static(&infos[i]);
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|245| <<type_get_parent>> type->parent_type = type_get_by_name(type->parent);
+ *   - qom/object.c|285| <<object_type_get_instance_size>> TypeImpl *type = type_get_by_name(typename);
+ *   - qom/object.c|383| <<type_initialize>> TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);
+ *   - qom/object.c|461| <<object_initialize>> TypeImpl *type = type_get_by_name(typename);
+ *   - qom/object.c|625| <<object_new>> TypeImpl *ti = type_get_by_name(typename);
+ *   - qom/object.c|801| <<object_class_dynamic_cast>> target_type = type_get_by_name(typename);
+ *   - qom/object.c|899| <<object_class_by_name>> TypeImpl *type = type_get_by_name(typename);
+ */
 static TypeImpl *type_get_by_name(const char *name)
 {
     if (name == NULL) {
         return NULL;
     }
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     return type_table_lookup(name);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|283| <<type_class_get_size>> return type_class_get_size(type_get_parent(ti));
+ *   - qom/object.c|296| <<type_object_get_size>> return type_object_get_size(type_get_parent(ti));
+ *   - qom/object.c|321| <<type_is_ancestor>> type = type_get_parent(type);
+ *   - qom/object.c|383| <<type_initialize>> parent = type_get_parent(ti);
+ *   - qom/object.c|430| <<type_initialize>> parent = type_get_parent(parent);
+ *   - qom/object.c|441| <<object_init_with_type>> object_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|456| <<object_post_init_with_type>> object_post_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|613| <<object_deinit>> object_deinit(obj, type_get_parent(type));
+ *   - qom/object.c|937| <<object_class_get_parent>> TypeImpl *type = type_get_parent(class->type);
+ *
+ * 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+ */
 static TypeImpl *type_get_parent(TypeImpl *type)
 {
+    /* parent是const char *parent类型 */
     if (!type->parent_type && type->parent) {
+        /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
         type->parent_type = type_get_by_name(type->parent);
         g_assert(type->parent_type != NULL);
     }
@@ -179,45 +337,95 @@ static TypeImpl *type_get_parent(TypeImpl *type)
     return type->parent_type;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|296| <<type_class_get_size>> if (type_has_parent(ti)) {
+ *   - qom/object.c|309| <<type_object_get_size>> if (type_has_parent(ti)) {
+ *   - qom/object.c|457| <<object_init_with_type>> if (type_has_parent(ti)) {
+ *   - qom/object.c|475| <<object_post_init_with_type>> if (type_has_parent(ti)) {
+ *   - qom/object.c|635| <<object_deinit>> if (type_has_parent(type)) {
+ *
+ * 检查TypeImpl是否有parent
+ */
 static bool type_has_parent(TypeImpl *type)
 {
     return (type->parent != NULL);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|308| <<type_class_get_size>> return type_class_get_size(type_get_parent(ti));
+ *   - qom/object.c|399| <<type_initialize>> ti->class_size = type_class_get_size(ti);
+ *
+ * 如果TypeImpl有class_size返回class_size
+ * 其次递归调用自己返回parent的size
+ * 最后没办法了返回sizeof(ObjectClass)
+ */
 static size_t type_class_get_size(TypeImpl *ti)
 {
     if (ti->class_size) {
         return ti->class_size;
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
-        return type_class_get_size(type_get_parent(ti));
+        /* 这里递归调用 继续返回parent的TypeImpl的class_size */
+        return type_class_get_size(type_get_parent(ti)); // 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
     }
 
     return sizeof(ObjectClass);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|338| <<type_object_get_size>> return type_object_get_size(type_get_parent(ti));
+ *   - qom/object.c|350| <<object_type_get_instance_size>> return type_object_get_size(type);
+ *   - qom/object.c|421| <<type_initialize>> ti->instance_size = type_object_get_size(ti);
+ *
+ * 如果TypeImpl有instance_size返回instance_size
+ * 其次递归调用自己返回parent的object size
+ * 最后没办法了返回0
+ */
 static size_t type_object_get_size(TypeImpl *ti)
 {
     if (ti->instance_size) {
         return ti->instance_size;
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
-        return type_object_get_size(type_get_parent(ti));
+	    /* 这里递归调用 继续返回parent的TypeImpl的instance_size */
+        return type_object_get_size(type_get_parent(ti)); // 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
     }
 
     return 0;
 }
 
+/*
+ * hw/ppc/pnv.c中调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 如果TypeImpl有instance_size返回instance_size
+ * 其次递归调用自己返回parent的object size
+ * 最后没办法了返回0
+ */
 size_t object_type_get_instance_size(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
     g_assert(type != NULL);
+    /*
+     * 如果TypeImpl有instance_size返回instance_size
+     * 其次递归调用自己返回parent的object size
+     * 最后没办法了返回0
+     */
     return type_object_get_size(type);
 }
 
+/*
+ * 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+ */
 static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
 {
     assert(target_type);
@@ -228,6 +436,7 @@ static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
             return true;
         }
 
+	/* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
         type = type_get_parent(type);
     }
 
@@ -236,9 +445,23 @@ static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
 
 static void type_initialize(TypeImpl *ti);
 
+/*
+ * called by:
+ *   - qom/object.c|474| <<type_initialize>> type_initialize_interface(ti, iface->interface_type, klass->type);
+ *   - qom/object.c|493| <<type_initialize>> type_initialize_interface(ti, t, t);
+ *
+ * 用ti和interface_type的name组成新的name("%s::%s"), 作为新的TypeInfo的name
+ * 根据TypeInfo转换成TypeImpl, 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 把转换成的TypeInfo的class插入ti->class->interfaces (Glist *)
+ */
 static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
                                       TypeImpl *parent_type)
 {
+    /*
+     * 一个例子: ti来自"nvme", interface_type和parent_type来自INTERFACE_PCIE_DEVICE
+     *
+     * 所有的interface的祖先(TYPE_INTERFACE)的class就是InterfaceClass
+     */
     InterfaceClass *new_iface;
     TypeInfo info = { };
     TypeImpl *iface_impl;
@@ -247,19 +470,36 @@ static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
     info.name = g_strdup_printf("%s::%s", ti->name, interface_type->name);
     info.abstract = true;
 
+    /* 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 (通过name搜索) */
     iface_impl = type_new(&info);
     iface_impl->parent_type = parent_type;
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(iface_impl);
     g_free((char *)info.name);
 
+    /*
+     * 最右边的class是ObjectClass
+     *
+     * 所有interface的祖先的class是InterfaceClass
+     */
     new_iface = (InterfaceClass *)iface_impl->class;
     new_iface->concrete_class = ti->class;
     new_iface->interface_type = interface_type;
 
+    /* 把TypeImpl挂载到ti->class->interfaces */
     ti->class->interfaces = g_slist_append(ti->class->interfaces,
                                            iface_impl->class);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|468| <<type_initialize>> g_str_hash, g_str_equal, g_free, object_property_free);
+ *   - qom/object.c|497| <<type_initialize>> g_str_hash, g_str_equal, g_free, object_property_free);
+ *   - qom/object.c|560| <<object_initialize_with_type>> NULL, object_property_free);
+ */
 static void object_property_free(gpointer data)
 {
     ObjectProperty *prop = data;
@@ -270,49 +510,150 @@ static void object_property_free(gpointer data)
     g_free(prop);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|407| <<type_initialize_interface>> type_initialize(iface_impl);
+ *   - qom/object.c|460| <<type_initialize>> type_initialize(parent);
+ *   - qom/object.c|550| <<object_initialize_with_type>> type_initialize(type);
+ *   - qom/object.c|725| <<object_new_with_type>> type_initialize(type);
+ *   - qom/object.c|1023| <<object_class_by_name>> type_initialize(type);
+ *   - qom/object.c|1037| <<object_class_get_parent>> type_initialize(type);
+ *   - qom/object.c|1057| <<object_class_foreach_tramp>> type_initialize(type);
+ *
+ * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+ * 调用.class_init()
+ */
 static void type_initialize(TypeImpl *ti)
 {
     TypeImpl *parent;
 
+    /* ti->class是ObjectClass, 如果已经初始化了就退出 */
     if (ti->class) {
         return;
     }
 
+    /*
+     * 如果TypeImpl有class_size返回class_size
+     * 其次递归调用自己返回parent的size
+     * 最后没办法了返回sizeof(ObjectClass)
+     */
     ti->class_size = type_class_get_size(ti);
+    /*
+     * 如果TypeImpl有instance_size返回instance_size
+     * 其次递归调用自己返回parent的size
+     * 最后没办法了返回0
+     */
     ti->instance_size = type_object_get_size(ti);
     /* Any type with zero instance_size is implicitly abstract.
      * This means interface types are all abstract.
      */
+    /* 没有instance_size的就是abstract */
     if (ti->instance_size == 0) {
         ti->abstract = true;
     }
 
+    /* class的类型: ObjectClass *class; */
     ti->class = g_malloc0(ti->class_size);
 
+    /* 返回TypeImpl的parent_type (TypeImpl), 如果没有现设置 (可以为NULL) */
     parent = type_get_parent(ti);
     if (parent) {
+        /* 递归调用自己保证祖先们都完成了初始化, 比如祖先们的class_init都调用过了! */
         type_initialize(parent);
         GSList *e;
         int i;
 
+	/*
+	 * 孩子们的class_size必须比祖先小 因为包含祖先
+	 */
         g_assert(parent->class_size <= ti->class_size);
+	/*
+	 * 包含祖先的时候都在头上 所以先拷贝过来
+	 *
+	 * TypeImpl包含ObjectClass *class, 后者包含GSList *interfaces
+	 */
         memcpy(ti->class, parent->class, parent->class_size);
+	/*
+	 * nvme的例子帮助理解interface:
+	 *
+	 * 1397 static const TypeInfo nvme_info = {
+	 * 1398     .name          = "nvme",
+	 * 1399     .parent        = TYPE_PCI_DEVICE,
+	 * 1400     .instance_size = sizeof(NvmeCtrl),
+	 * 1401     .class_init    = nvme_class_init,
+	 * 1402     .instance_init = nvme_instance_init,
+	 * 1403     .interfaces = (InterfaceInfo[]) {
+	 * 1404         { INTERFACE_PCIE_DEVICE },
+	 * 1405         { }
+	 * 1406     },
+	 * 1407 };
+	 *
+	 *  178 static const TypeInfo pcie_interface_info = {
+	 *  179     .name          = INTERFACE_PCIE_DEVICE,
+	 *  180     .parent        = TYPE_INTERFACE,
+	 *  181 };
+	 *
+	 *  3335     static TypeInfo interface_info = {
+	 *  3336         .name = TYPE_INTERFACE,
+	 *  3337         .class_size = sizeof(InterfaceClass),
+	 *  3338         .abstract = true,
+	 *  3339     };
+	 *
+	 *   597 struct InterfaceClass
+	 *   598 {
+	 *   599     ObjectClass parent_class;
+	 *   600     //< private >
+	 *   601     ObjectClass *concrete_class;
+	 *   602     Type interface_type;
+	 *   603 };
+	 *
+	 *
+	 *
+	 *
+	 * 从TypeInfo转换为TypeImpl时对interface的处理:
+	 *      TypeInfo的interfaces是InterfaceInfo的数组, 就是const char *type
+	 *      TypeImpl的interfaces是InterfaceImpl的数组, 就是const char *typename
+	 *  
+	 *  224     for (i = 0; info->interfaces && info->interfaces[i].type; i++) {
+	 *  225         ti->interfaces[i].typename = g_strdup(info->interfaces[i].type);
+	 *  226     }
+	 *  227     ti->num_interfaces = i;
+	 */
         ti->class->interfaces = NULL;
+	/*
+	 * ObjectClass的properties是GHashTable
+	 */
         ti->class->properties = g_hash_table_new_full(
             g_str_hash, g_str_equal, g_free, object_property_free);
 
+	/* 祖先没有先略过 */
         for (e = parent->class->interfaces; e; e = e->next) {
             InterfaceClass *iface = e->data;
+	    /*
+	     * ObjectClass包含Type (定义typedef struct TypeImpl *Type)
+	     */
             ObjectClass *klass = OBJECT_CLASS(iface);
 
+	    /*
+	     * 用ti和interface_type的name组成新的name("%s::%s"), 作为新的TypeInfo的name
+	     * 根据TypeInfo转换成TypeImpl, 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+	     * 把转换成的TypeInfo的class插入ti->class->interfaces (Glist *)
+	     */
             type_initialize_interface(ti, iface->interface_type, klass->type);
         }
 
         for (i = 0; i < ti->num_interfaces; i++) {
+            /*
+	     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+	     *
+	     * nvme的typename的例子是INTERFACE_PCIE_DEVICE
+	     */
             TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);
+	    /* ObjectClass中的interfaces是GSList *interfaces */
             for (e = ti->class->interfaces; e; e = e->next) {
                 TypeImpl *target_type = OBJECT_CLASS(e->data)->type;
 
+		/* 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor */
                 if (type_is_ancestor(target_type, t)) {
                     break;
                 }
@@ -322,6 +663,13 @@ static void type_initialize(TypeImpl *ti)
                 continue;
             }
 
+	    /*
+	     * 一个例子: ti来自"nvme", t来自INTERFACE_PCIE_DEVICE
+	     *
+	     * 用ti和interface_type的name组成新的name("%s::%s"), 作为新的TypeInfo的name
+	     * 根据TypeInfo转换成TypeImpl, 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+	     * 把转换成的TypeInfo的class插入ti->class->interfaces (Glist *)
+	     */
             type_initialize_interface(ti, t, t);
         }
     } else {
@@ -333,8 +681,15 @@ static void type_initialize(TypeImpl *ti)
 
     while (parent) {
         if (parent->class_base_init) {
+            /*
+	     * 实现了class_base_init的
+	     *   - hw/core/machine.c|867| <<global>> .class_base_init = machine_class_base_init,
+	     *   - hw/core/qdev.c|1108| <<global>> .class_base_init = device_class_base_init,
+	     *   - hw/pci/pci.c|2667| <<global>> .class_base_init = pci_device_class_base_init
+	     */
             parent->class_base_init(ti->class, ti->class_data);
         }
+	/* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
         parent = type_get_parent(parent);
     }
 
@@ -343,9 +698,20 @@ static void type_initialize(TypeImpl *ti)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|602| <<object_init_with_type>> object_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|641| <<object_initialize_with_type>> object_init_with_type(obj, type);
+ *
+ * 调用TypeImpl的instance_init(), 如果有parent递归"先"调用parent的instance_init()
+ */
 static void object_init_with_type(Object *obj, TypeImpl *ti)
 {
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
+        /*
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_init_with_type(obj, type_get_parent(ti));
     }
 
@@ -354,22 +720,95 @@ static void object_init_with_type(Object *obj, TypeImpl *ti)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|621| <<object_post_init_with_type>> object_post_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|642| <<object_initialize_with_type>> object_post_init_with_type(obj, type);
+ *
+ * 调用TypeImpl的instance_post_init(obj), 如果有parent"再"递归调用parent的instance_post_init(obj)
+ */
 static void object_post_init_with_type(Object *obj, TypeImpl *ti)
 {
     if (ti->instance_post_init) {
         ti->instance_post_init(obj);
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
+        /* 
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_post_init_with_type(obj, type_get_parent(ti));
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|650| <<object_initialize>> object_initialize_with_type(data, size, type);
+ *   - qom/object.c|816| <<object_new_with_type>> object_initialize_with_type(obj, type->instance_size, type);
+ *
+ * 一个例子 (TYPE_KVM_ACCEL):
+ * (gdb) bt
+ * #0  object_initialize_with_type (data=0x5555565d3d40, size=4456, type=0x5555564f9b30) at qom/object.c:370
+ * #1  0x0000555555c1e805 in object_new_with_type (type=0x5555564f9b30) at qom/object.c:546
+ * #2  0x0000555555c1e842 in object_new (typename=0x5555564d6090 "kvm-accel") at qom/object.c:556
+ * #3  0x000055555584bdb2 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ *
+ * (gdb) set print pretty on
+ * (gdb) p *type
+ * $9 = {
+ *   name = 0x5555564d6090 "kvm-accel", 
+ *   class_size = 152, 
+ *   instance_size = 4456, 
+ *   class_init = 0x555555852628 <kvm_accel_class_init>, 
+ *   class_base_init = 0x0, 
+ *   class_finalize = 0x0, 
+ *   class_data = 0x0, 
+ *   instance_init = 0x0, 
+ *   instance_post_init = 0x0, 
+ *   instance_finalize = 0x0, 
+ *   abstract = false, 
+ *   parent = 0x5555564d6160 "accel", 
+ *   parent_type = 0x5555564f99b0, 
+ *   class = 0x555556547110, 
+ *   num_interfaces = 0, 
+ *   interfaces =     {{
+ *       typename = 0x0
+ *     } <repeats 32 times>}
+ * }
+ *
+ * (gdb) p *type.class
+ * $10 = {
+ *   type = 0x5555564f9b30,   ----->  又指向"kvm-accel"的TypeImpl 
+ *   interfaces = 0x0, 
+ *   object_cast_cache =     {0x0,
+ *     0x0,
+ *     0x0,
+ *     0x0}, 
+ *   class_cast_cache =     {0x0,
+ *     0x0,
+ *     0x555555d90dcc "accel",
+ *     0x555555d903a0 "accel"}, 
+ *   unparent = 0x0, 
+ *   properties = 0x555556545e40
+ * }
+ *
+ * 在上面的例子中, type是TYPE_KVM_ACCEL, 在该函数中obj->class就被设置成了TYPE_KVM_ACCEL的ObjectClass
+ *
+ *
+ * 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 static void object_initialize_with_type(void *data, size_t size, TypeImpl *type)
 {
     Object *obj = data;
 
     g_assert(type != NULL);
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     g_assert(type->instance_size >= sizeof(Object));
@@ -381,14 +820,24 @@ static void object_initialize_with_type(void *data, size_t size, TypeImpl *type)
     object_ref(obj);
     obj->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
                                             NULL, object_property_free);
+    /* 调用TypeImpl的instance_init(), 如果有parent递归"先"调用parent的instance_init() */
     object_init_with_type(obj, type);
+    /* 调用TypeImpl的instance_post_init(obj), 如果有parent"再"递归调用parent的instance_post_init(obj) */
     object_post_init_with_type(obj, type);
 }
 
+/*
+ * 被一群外部的调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 void object_initialize(void *data, size_t size, const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
+    /* 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init() */
     object_initialize_with_type(data, size, type);
 }
 
@@ -411,6 +860,10 @@ void object_initialize_childv(Object *parentobj, const char *propname,
     Error *local_err = NULL;
     Object *obj;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     object_initialize(childobj, size, type);
     obj = OBJECT(childobj);
 
@@ -419,11 +872,23 @@ void object_initialize_childv(Object *parentobj, const char *propname,
         goto out;
     }
 
+    /*
+     * 把child设置成一个obj的ObjectProperty
+     * 在Object->properties (GHashTable)的name就是参数的name, type是"child<child的type>"
+     * ObjectProperty的opaque是child
+     * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+     */
     object_property_add_child(parentobj, propname, obj, &local_err);
     if (local_err) {
         goto out;
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_dynamic_cast(obj, TYPE_USER_CREATABLE)) {
         user_creatable_complete(obj, &local_err);
         if (local_err) {
@@ -446,6 +911,9 @@ out:
     }
 }
 
+/*
+ * 判断ObjectProperty的type是否开头是"child<"
+ */
 static inline bool object_property_is_child(ObjectProperty *prop)
 {
     return strstart(prop->type, "child<", NULL);
@@ -516,11 +984,18 @@ static void object_deinit(Object *obj, TypeImpl *type)
         type->instance_finalize(obj);
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(type)) {
+        /*
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_deinit(obj, type_get_parent(type));
     }
 }
 
+/*
+ * called only by object_unref()
+ */
 static void object_finalize(void *data)
 {
     Object *obj = data;
@@ -535,28 +1010,56 @@ static void object_finalize(void *data)
     }
 }
 
+/*
+ * called only by object_new()
+ *
+ * Type的定义: typedef struct TypeImpl *Type
+ *
+ * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 static Object *object_new_with_type(Type type)
 {
     Object *obj;
 
     g_assert(type != NULL);
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     obj = g_malloc(type->instance_size);
+    /* 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init() */
     object_initialize_with_type(obj, type->instance_size, type);
     obj->free = g_free;
 
     return obj;
 }
 
+/*
+ * 被一群外部调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 Object *object_new(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *ti = type_get_by_name(typename);
 
     return object_new_with_type(ti);
 }
 
 
+/*
+ * called by:
+ *   - hw/misc/auxbus.c|70| <<aux_init_bus>> auxtoi2c = object_new_with_props(TYPE_AUXTOI2C, OBJECT(bus), "i2c",
+ *   - iothread.c|366| <<iothread_create>> obj = object_new_with_props(TYPE_IOTHREAD,
+ *   - ui/vnc.c|3539| <<vnc_display_create_creds>> creds = object_new_with_props(TYPE_QCRYPTO_TLS_CREDS_X509,
+ *   - ui/vnc.c|3548| <<vnc_display_create_creds>> creds = object_new_with_props(TYPE_QCRYPTO_TLS_CREDS_ANON,
+ */
 Object *object_new_with_props(const char *typename,
                               Object *parent,
                               const char *id,
@@ -584,6 +1087,11 @@ Object *object_new_with_propv(const char *typename,
     ObjectClass *klass;
     Error *local_err = NULL;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     klass = object_class_by_name(typename);
     if (!klass) {
         error_setg(errp, "invalid object type: %s", typename);
@@ -594,17 +1102,34 @@ Object *object_new_with_propv(const char *typename,
         error_setg(errp, "object type '%s' is abstract", typename);
         return NULL;
     }
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     obj = object_new(typename);
 
     if (object_set_propv(obj, &local_err, vargs) < 0) {
         goto error;
     }
 
+    /*
+     * 把child设置成一个obj的ObjectProperty
+     * 在Object->properties (GHashTable)的name (id)就是参数的name, type是"child<child的type>"
+     * ObjectProperty的opaque是child
+     * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+     */
     object_property_add_child(parent, id, obj, &local_err);
     if (local_err) {
         goto error;
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_dynamic_cast(obj, TYPE_USER_CREATABLE)) {
         user_creatable_complete(obj, &local_err);
         if (local_err) {
@@ -623,6 +1148,31 @@ Object *object_new_with_propv(const char *typename,
 }
 
 
+/*
+ * <example>
+ *   <title>Update an object's properties</title>
+ *   <programlisting>
+ *   Error *err = NULL;
+ *   Object *obj = ...get / create object...;
+ *
+ *   obj = object_set_props(obj,
+ *                          &err,
+ *                          "share", "yes",
+ *                          "mem-path", "/dev/shm/somefile",
+ *                          "prealloc", "yes",
+ *                          "size", "1048576",
+ *                          NULL);
+ *  
+ *   if (!obj) {
+ *     g_printerr("Cannot set properties: %s\n",
+ *                error_get_pretty(err));
+ *   }
+ *   </programlisting>
+ * </example>
+ */
+/*
+ * 对于参数的没一个vargs中的pair, 根据name找到ObjectProperty, 然后调用其set方法 (还有一点Visitor的操作)
+ */
 int object_set_props(Object *obj,
                      Error **errp,
                      ...)
@@ -631,6 +1181,7 @@ int object_set_props(Object *obj,
     int ret;
 
     va_start(vargs, errp);
+    /* 对于参数的没一个vargs中的pair, 根据name找到ObjectProperty, 然后调用其set方法 (还有一点Visitor的操作) */
     ret = object_set_propv(obj, errp, vargs);
     va_end(vargs);
 
@@ -638,6 +1189,15 @@ int object_set_props(Object *obj,
 }
 
 
+/*
+ * called by:
+ *   - qom/object.c|720| <<object_initialize_childv>> object_set_propv(obj, &local_err, vargs);
+ *   - qom/object.c|937| <<object_new_with_propv>> if (object_set_propv(obj, &local_err, vargs) < 0) {
+ *   - qom/object.c|994| <<object_set_props>> ret = object_set_propv(obj, errp, vargs);
+ *   - qom/object.c|1001| <<object_set_propv>> int object_set_propv(Object *obj,
+ *
+ * 对于参数的没一个vargs中的pair, 根据name找到ObjectProperty, 然后调用其set方法 (还有一点Visitor的操作)
+ */
 int object_set_propv(Object *obj,
                      Error **errp,
                      va_list vargs)
@@ -650,6 +1210,9 @@ int object_set_propv(Object *obj,
         const char *value = va_arg(vargs, char *);
 
         g_assert(value != NULL);
+	/*
+	 * 根据name找到ObjectProperty, 然后调用其set方法 (还有一点Visitor的操作)
+	 */
         object_property_parse(obj, value, propname, &local_err);
         if (local_err) {
             error_propagate(errp, local_err);
@@ -662,8 +1225,37 @@ int object_set_propv(Object *obj,
 }
 
 
+/*
+ * 一个使用的例子: DeviceState *dev = (DeviceState *) object_dynamic_cast(obj, TYPE_DEVICE);
+ *   - memory.c|2938| <<mtree_expand_owner>> DeviceState *dev = (DeviceState *) object_dynamic_cast(obj, TYPE_DEVICE);
+ *
+ * 一个例子(#1):
+ *
+ * (gdb) bt
+ * #0  object_class_dynamic_cast (class=0x555556547110, typename=0x555555d903a0 "accel") at qom/object.c:716
+ * #1  0x0000555555c1ed8d in object_dynamic_cast (obj=0x5555565d3d40, typename=0x555555d903a0 "accel") at qom/object.c:667
+ * #2  0x0000555555c1ee43 in object_dynamic_cast_assert (obj=0x5555565d3d40, typename=0x555555d903a0 "accel", 
+ *     file=0x555555d903b8 "/home/zhang/kvm/qemu-3.0.0/accel/accel.c", line=58, func=0x555555d90480 <__func__.27147> "accel_init_machine")
+ *     at qom/object.c:690
+ * #3  0x000055555584bdd4 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ *
+ * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+ * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+ * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+ * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+ */
 Object *object_dynamic_cast(Object *obj, const char *typename)
 {
+    /*
+     * object_get_class(): 参考object_initialize_with_type()的注释, 比如class可能是TYPE_KVM_ACCEL的ObjectClass
+     *
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (obj && object_class_dynamic_cast(object_get_class(obj), typename)) {
         return obj;
     }
@@ -671,6 +1263,19 @@ Object *object_dynamic_cast(Object *obj, const char *typename)
     return NULL;
 }
 
+/*
+ * 一个例子(#2):
+ *
+ * (gdb) bt
+ * #0  object_class_dynamic_cast (class=0x555556547110, typename=0x555555d903a0 "accel") at qom/object.c:716
+ * #1  0x0000555555c1ed8d in object_dynamic_cast (obj=0x5555565d3d40, typename=0x555555d903a0 "accel") at qom/object.c:667
+ * #2  0x0000555555c1ee43 in object_dynamic_cast_assert (obj=0x5555565d3d40, typename=0x555555d903a0 "accel", 
+ *     file=0x555555d903b8 "/home/zhang/kvm/qemu-3.0.0/accel/accel.c", line=58, func=0x555555d90480 <__func__.27147> "accel_init_machine")
+ *     at qom/object.c:690
+ * #3  0x000055555584bdd4 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ */
 Object *object_dynamic_cast_assert(Object *obj, const char *typename,
                                    const char *file, int line, const char *func)
 {
@@ -687,6 +1292,12 @@ Object *object_dynamic_cast_assert(Object *obj, const char *typename,
         }
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     inst = object_dynamic_cast(obj, typename);
 
     if (!inst && obj) {
@@ -710,6 +1321,48 @@ out:
     return obj;
 }
 
+/*
+ * 一个gdb的例子 (#0):
+ *
+ * (gdb) bt
+ * #0  object_class_dynamic_cast (class=0x555556547110, typename=0x555555d903a0 "accel") at qom/object.c:716
+ * #1  0x0000555555c1ed8d in object_dynamic_cast (obj=0x5555565d3d40, typename=0x555555d903a0 "accel") at qom/object.c:667
+ * #2  0x0000555555c1ee43 in object_dynamic_cast_assert (obj=0x5555565d3d40, typename=0x555555d903a0 "accel", 
+ *     file=0x555555d903b8 "/home/zhang/kvm/qemu-3.0.0/accel/accel.c", line=58, func=0x555555d90480 <__func__.27147> "accel_init_machine")
+ *     at qom/object.c:690
+ * #3  0x000055555584bdd4 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ *
+ * (gdb) p *class.type
+ * $11 = {
+ *   name = 0x5555564d6090 "kvm-accel", 
+ *   class_size = 152, 
+ *   instance_size = 4456, 
+ *   class_init = 0x555555852628 <kvm_accel_class_init>, 
+ *   class_base_init = 0x0, 
+ *   class_finalize = 0x0, 
+ *   class_data = 0x0, 
+ *   instance_init = 0x0, 
+ *   instance_post_init = 0x0, 
+ *   instance_finalize = 0x0, 
+ *   abstract = false, 
+ *   parent = 0x5555564d6160 "accel", 
+ *   parent_type = 0x5555564f99b0, 
+ *   class = 0x555556547110, 
+ *   num_interfaces = 0, 
+ *   interfaces =     {{
+ *       typename = 0x0
+ *     } <repeats 32 times>}
+ * }
+ *
+ * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+ *
+ * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+ * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+ * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+ * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回 
+ */
 ObjectClass *object_class_dynamic_cast(ObjectClass *class,
                                        const char *typename)
 {
@@ -723,24 +1376,54 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
 
     /* A simple fast path that can trigger a lot for leaf classes.  */
     type = class->type;
+    /* 如果这个ObjectClass的type就是我们要找的 直接返回ObjectClass */
     if (type->name == typename) {
         return class;
     }
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     target_type = type_get_by_name(typename);
     if (!target_type) {
         /* target class type unknown, so fail the cast */
         return NULL;
     }
 
+    /*
+     * type_is_ancestor(): 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+     *
+     *
+     * 一个nvme的例子:
+     *
+     * 1397 static const TypeInfo nvme_info = {
+     * 1398     .name          = "nvme",
+     * 1399     .parent        = TYPE_PCI_DEVICE,
+     * 1400     .instance_size = sizeof(NvmeCtrl),
+     * 1401     .class_init    = nvme_class_init,
+     * 1402     .instance_init = nvme_instance_init,
+     * 1403     .interfaces = (InterfaceInfo[]) {
+     * 1404         { INTERFACE_PCIE_DEVICE },
+     * 1405         { }
+     * 1406     },
+     * 1407 };
+     *
+     *
+     * type_interface是TYPE_INTERFACE获得的TypeImpl
+     *
+     * 这个if语句是ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (type->class->interfaces &&
             type_is_ancestor(target_type, type_interface)) {
         int found = 0;
         GSList *i;
 
+	/*
+	 * 从ObjectClass的interfaces (GList *)中找到一个祖先是target_type的
+	 */
         for (i = class->interfaces; i; i = i->next) {
             ObjectClass *target_class = i->data;
 
+	    /* 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor */
             if (type_is_ancestor(target_class->type, target_type)) {
                 ret = target_class;
                 found++;
@@ -748,16 +1431,27 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
          }
 
         /* The match was ambiguous, don't allow a cast */
+	/* 找到多于一个是不正确的 */
         if (found > 1) {
             ret = NULL;
         }
-    } else if (type_is_ancestor(type, target_type)) {
+    } else if (type_is_ancestor(type, target_type)) {  // 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+        /*
+	 * else if中如果typename获得的target_type是class->type的最先则返回class
+	 *
+	 * 一个例子是type是TYPE_KVM_ACCEL, target_type是TYPE_ACCEL, 返回的class (ret)是TYPE_KVM_ACCEL的ObjectClass (没关系 因为包含了后者)
+	 *
+	 * 如果不是interface的部分, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	 */
         ret = class;
     }
 
     return ret;
 }
 
+/*
+ * 调用object_class_dynamic_cast() 剩下就是做了些检查
+ */
 ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,
                                               const char *typename,
                                               const char *file, int line,
@@ -783,6 +1477,12 @@ ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,
     }
 #endif
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     ret = object_class_dynamic_cast(class, typename);
     if (!ret && class) {
         fprintf(stderr, "%s:%d:%s: Object %p is not an instance of type %s\n",
@@ -805,47 +1505,78 @@ out:
 
 const char *object_get_typename(const Object *obj)
 {
+    /* 最后的type (Type) 是一个TypeImpl */
     return obj->class->type->name;
 }
 
 ObjectClass *object_get_class(Object *obj)
 {
+    /*
+     * class是ObjectClass
+     *
+     * 参考object_initialize_with_type()的注释, 比如class可能是TYPE_KVM_ACCEL的ObjectClass
+     */
     return obj->class;
 }
 
 bool object_class_is_abstract(ObjectClass *klass)
 {
+    /* type是Type (TypeImpl) */
     return klass->type->abstract;
 }
 
 const char *object_class_get_name(ObjectClass *klass)
 {
+    /* type是Type (TypeImpl) */
     return klass->type->name;
 }
 
+/*
+ * 很多外部调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+ * 调用.class_init()
+ */
 ObjectClass *object_class_by_name(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
     if (!type) {
         return NULL;
     }
 
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     return type->class;
 }
 
+/*
+ * 得到TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+ * 初始化parent_type(TypeImpl)的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 最后返回parent_type(TypeImpl)的class (ObjectClass)
+ */
 ObjectClass *object_class_get_parent(ObjectClass *class)
 {
+    /* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
     TypeImpl *type = type_get_parent(class->type);
 
     if (!type) {
         return NULL;
     }
 
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
+    /* class是ObjectClass */
     return type->class;
 }
 
@@ -857,6 +1588,10 @@ typedef struct OCFData
     void *opaque;
 } OCFData;
 
+/*
+ * called by:
+ *   - qom/object.c|1630| <<object_class_foreach>> g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
+ */
 static void object_class_foreach_tramp(gpointer key, gpointer value,
                                        gpointer opaque)
 {
@@ -871,6 +1606,13 @@ static void object_class_foreach_tramp(gpointer key, gpointer value,
         return;
     }
 
+    /*
+     * object_class_dymanic_cast():
+     *     如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     *     一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     *     否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     *     在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (data->implements_type && 
         !object_class_dynamic_cast(k, data->implements_type)) {
         return;
@@ -886,10 +1628,22 @@ void object_class_foreach(void (*fn)(ObjectClass *klass, void *opaque),
     OCFData data = { fn, implements_type, include_abstract, opaque };
 
     enumerating_types = true;
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
     enumerating_types = false;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|1662| <<do_object_child_foreach>> do_object_child_foreach(child, fn, opaque, true);
+ *   - qom/object.c|1678| <<object_child_foreach>> return do_object_child_foreach(obj, fn, opaque, false);
+ *   - qom/object.c|1685| <<object_child_foreach_recursive>> return do_object_child_foreach(obj, fn, opaque, true);
+ *
+ * 遍历Object的properties(HashTable), 针对每一个type开头是"child<"的ObjectProperty, 调用fn
+ * 如果recurse是true, 继续递归调用自己(针对prop->opaque)
+ */
 static int do_object_child_foreach(Object *obj,
                                    int (*fn)(Object *child, void *opaque),
                                    void *opaque, bool recurse)
@@ -900,6 +1654,7 @@ static int do_object_child_foreach(Object *obj,
 
     g_hash_table_iter_init(&iter, obj->properties);
     while (g_hash_table_iter_next(&iter, NULL, (gpointer *)&prop)) {
+        /* 判断ObjectProperty的type是否开头是"child<" */
         if (object_property_is_child(prop)) {
             Object *child = prop->opaque;
 
@@ -908,6 +1663,7 @@ static int do_object_child_foreach(Object *obj,
                 break;
             }
             if (recurse) {
+		/* 如果recurse为true, 递归调用孩子Object */
                 do_object_child_foreach(child, fn, opaque, true);
             }
         }
@@ -915,16 +1671,34 @@ static int do_object_child_foreach(Object *obj,
     return ret;
 }
 
+/*
+ * 调用的几个例子:
+ *   - hw/virtio/virtio-balloon.c|342| <<build_dimm_list>> object_child_foreach(obj, build_dimm_list, opaque);
+ *   - iothread.c|334| <<qmp_query_iothreads>> object_child_foreach(container, query_one_iothread, &prev);
+ *   - qdev-monitor.c|787| <<print_qom_composition>> object_child_foreach(obj, print_qom_composition_child, &s);
+ */
 int object_child_foreach(Object *obj, int (*fn)(Object *child, void *opaque),
                          void *opaque)
 {
+    /*
+     * 遍历Object的properties(HashTable), 针对每一个type开头是"child<"的ObjectProperty, 调用fn
+     * 如果recurse是true, 继续递归调用自己(针对prop->opaque)
+     */
     return do_object_child_foreach(obj, fn, opaque, false);
 }
 
+/*
+ * 遍历Object的properties(HashTable), 针对每一个type开头是"child<"的ObjectProperty, 调用fn
+ * 如果recurse是true, 继续递归调用自己(针对prop->opaque)
+ */
 int object_child_foreach_recursive(Object *obj,
                                    int (*fn)(Object *child, void *opaque),
                                    void *opaque)
 {
+    /*
+     * 遍历Object的properties(HashTable), 针对每一个type开头是"child<"的ObjectProperty, 调用fn
+     * 如果recurse是true, 继续递归调用自己(针对prop->opaque)
+     */
     return do_object_child_foreach(obj, fn, opaque, true);
 }
 
@@ -958,6 +1732,7 @@ GSList *object_class_get_list_sorted(const char *implements_type,
                         object_class_cmp);
 }
 
+/* 增加Object的uint32_t ref */
 void object_ref(Object *obj)
 {
     if (!obj) {
@@ -966,6 +1741,10 @@ void object_ref(Object *obj)
     atomic_inc(&obj->ref);
 }
 
+/*
+ * 减少Object的uint32_t ref
+ * 如果是0了还要调用object_finalize()
+ */
 void object_unref(Object *obj)
 {
     if (!obj) {
@@ -979,6 +1758,12 @@ void object_unref(Object *obj)
     }
 }
 
+/*
+ * 好多外部调用
+ *
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 ObjectProperty *
 object_property_add(Object *obj, const char *name, const char *type,
                     ObjectPropertyAccessor *get,
@@ -989,6 +1774,20 @@ object_property_add(Object *obj, const char *name, const char *type,
     ObjectProperty *prop;
     size_t name_len = strlen(name);
 
+    /*
+     * 感觉一般的都不满足这个什么[*]吧
+     *
+     * system_memory进来的时候
+     * (gdb) bt
+     * #0  object_property_add (obj=0x5555568512d0, name=0x555556851250 "system[*]", type=0x555556851530 "child<qemu:memory-region>", get=0x555555c5f037 <object_get_child_property>, set=0x0, 
+     *     release=0x555555c5f0cb <object_finalize_child_property>, opaque=0x555556850cd0, errp=0x7fffffffe060) at qom/object.c:990
+     * #1  0x0000555555c5f1e6 in object_property_add_child (obj=0x5555568512d0, name=0x555556851250 "system[*]", child=0x555556850cd0, errp=0x555556751590 <error_abort>) at qom/object.c:1507
+     * #2  0x0000555555866c8c in memory_region_do_init (mr=0x555556850cd0, owner=0x5555568512d0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1136
+     * #3  0x0000555555866cfb in memory_region_init (mr=0x555556850cd0, owner=0x0, name=0x555555e7f09d "system", size=18446744073709551615) at /home/zhang/kvm/qemu-3.0.0/memory.c:1149
+     * #4  0x0000555555803699 in memory_map_init () at /home/zhang/kvm/qemu-3.0.0/exec.c:3100
+     * #5  0x0000555555804201 in cpu_exec_init_all () at /home/zhang/kvm/qemu-3.0.0/exec.c:3534
+     * #6  0x00005555559dea90 in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4046
+     */
     if (name_len >= 3 && !memcmp(name + name_len - 3, "[*]", 4)) {
         int i;
         ObjectProperty *ret;
@@ -1009,6 +1808,11 @@ object_property_add(Object *obj, const char *name, const char *type,
         return ret;
     }
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     if (object_property_find(obj, name, NULL) != NULL) {
         error_setg(errp, "attempt to add duplicate property '%s'"
                    " to object (type '%s')", name,
@@ -1024,12 +1828,17 @@ object_property_add(Object *obj, const char *name, const char *type,
     prop->get = get;
     prop->set = set;
     prop->release = release;
+    /* opaque用在get和set中 */
     prop->opaque = opaque;
 
     g_hash_table_insert(obj->properties, prop->name, prop);
     return prop;
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 ObjectProperty *
 object_class_property_add(ObjectClass *klass,
                           const char *name,
@@ -1064,17 +1873,29 @@ object_class_property_add(ObjectClass *klass,
     return prop;
 }
 
+/*
+ * 递归调用自己的parent (ObjectClass) 寻找prop
+ * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+ * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+ */
 ObjectProperty *object_property_find(Object *obj, const char *name,
                                      Error **errp)
 {
     ObjectProperty *prop;
     ObjectClass *klass = object_get_class(obj);
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     */
     prop = object_class_property_find(klass, name, NULL);
     if (prop) {
         return prop;
     }
 
+    /*
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     prop = g_hash_table_lookup(obj->properties, name);
     if (prop) {
         return prop;
@@ -1111,20 +1932,33 @@ void object_class_property_iter_init(ObjectPropertyIterator *iter,
     iter->nextclass = klass;
 }
 
+/*
+ * 递归调用自己的parent (ObjectClass) 寻找prop
+ * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+ */
 ObjectProperty *object_class_property_find(ObjectClass *klass, const char *name,
                                            Error **errp)
 {
     ObjectProperty *prop;
     ObjectClass *parent_klass;
 
+    /*
+     * 得到TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+     * 初始化parent_type(TypeImpl)的class_size, instance_size和class, 还有interface, 调用.class_init()
+     * 最后返回parent_type(TypeImpl)的class (ObjectClass)
+     */
     parent_klass = object_class_get_parent(klass);
     if (parent_klass) {
+        /*
+	 * 递归调用自己的parent (ObjectClass) 寻找prop
+	 */
         prop = object_class_property_find(parent_klass, name, NULL);
         if (prop) {
             return prop;
         }
     }
 
+    /* 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找 */
     prop = g_hash_table_lookup(klass->properties, name);
     if (!prop) {
         error_setg(errp, "Property '.%s' not found", name);
@@ -1147,9 +1981,17 @@ void object_property_del(Object *obj, const char *name, Error **errp)
     g_hash_table_remove(obj->properties, name);
 }
 
+/*
+ * 根据name找到ObjectProperty, 然后调用其get方法
+ */
 void object_property_get(Object *obj, Visitor *v, const char *name,
                          Error **errp)
 {
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     ObjectProperty *prop = object_property_find(obj, name, errp);
     if (prop == NULL) {
         return;
@@ -1162,9 +2004,38 @@ void object_property_get(Object *obj, Visitor *v, const char *name,
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|1791| <<object_property_parse>> object_property_set(obj, v, name, errp);
+ *   - qom/object.c|2719| <<property_set_alias>> object_property_set(prop->target_obj, v, prop->target_name, errp);
+ *   - qom/object_interfaces.c|73| <<user_creatable_add_type>> object_property_set(obj, v, e->key, &local_err);
+ *   - qom/qom-qobject.c|27| <<object_property_set_qobject>> object_property_set(obj, v, name, errp);
+ *   - target/s390x/cpu_models.c|491| <<cpu_model_from_info>> object_property_set(obj, visitor, e->key, errp);
+ *
+ * 根据name找到ObjectProperty, 然后调用其set方法
+ *
+ * 比如name可以是"realized" (#4):
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 void object_property_set(Object *obj, Visitor *v, const char *name,
                          Error **errp)
 {
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     ObjectProperty *prop = object_property_find(obj, name, errp);
     if (prop == NULL) {
         return;
@@ -1173,13 +2044,19 @@ void object_property_set(Object *obj, Visitor *v, const char *name,
     if (!prop->set) {
         error_setg(errp, QERR_PERMISSION_DENIED);
     } else {
-        prop->set(obj, v, name, prop->opaque, errp);
+        prop->set(obj, v, name, prop->opaque, errp); // 对于nvme的realized, 例子是property_set_bool()
     }
 }
 
+/*
+ * 很多调用, 几个调用的例子:
+ *   - qom/object.c|2076| <<object_property_set_link>> object_property_set_str(obj, path, name, errp);
+ *   - qom/object.c|2079| <<object_property_set_link>> object_property_set_str(obj, "", name, errp);
+ */
 void object_property_set_str(Object *obj, const char *value,
                              const char *name, Error **errp)
 {
+    /* Create a new QString from a regular C string */
     QString *qstr = qstring_from_str(value);
     object_property_set_qobject(obj, QOBJECT(qstr), name, errp);
 
@@ -1209,6 +2086,10 @@ void object_property_set_link(Object *obj, Object *value,
                               const char *name, Error **errp)
 {
     if (value) {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         gchar *path = object_get_canonical_path(value);
         object_property_set_str(obj, path, name, errp);
         g_free(path);
@@ -1235,6 +2116,20 @@ Object *object_property_get_link(Object *obj, const char *name,
     return target;
 }
 
+/*
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 void object_property_set_bool(Object *obj, bool value,
                               const char *name, Error **errp)
 {
@@ -1395,10 +2290,20 @@ out:
     visit_free(v);
 }
 
+/*
+ * called by:
+ *   - hmp.c|2594| <<hmp_qom_set>> object_property_parse(obj, value, property, &err);
+ *   - hw/core/qdev-properties.c|1259| <<qdev_prop_set_globals>> object_property_parse(OBJECT(dev), prop->value, prop->property, &err);
+ *   - qdev-monitor.c|180| <<set_property>> object_property_parse(obj, value, name, &err);
+ *   - qom/object.c|1020| <<object_set_propv>> object_property_parse(obj, value, propname, &local_err);
+ *   - target/i386/cpu.c|3528| <<x86_cpu_apply_props>> object_property_parse(OBJECT(cpu), pv->value, pv->prop,
+ *   - vl.c|2728| <<machine_set_property>> object_property_parse(obj, value, qom_name, &local_err);
+ */
 void object_property_parse(Object *obj, const char *string,
                            const char *name, Error **errp)
 {
     Visitor *v = string_input_visitor_new(string);
+    /* 根据name找到ObjectProperty, 然后调用其set方法 */
     object_property_set(obj, v, name, errp);
     visit_free(v);
 }
@@ -1434,11 +2339,19 @@ const char *object_property_get_type(Object *obj, const char *name, Error **errp
     return prop->type;
 }
 
+/*
+ * 返回"container"的Object (root), 如果为空先初始化
+ */
 Object *object_get_root(void)
 {
     static Object *root;
 
     if (!root) {
+        /*
+	 * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+	 * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+	 * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+	 */
         root = object_new("container");
     }
 
@@ -1450,6 +2363,21 @@ Object *object_get_objects_root(void)
     return container_get(object_get_root(), "/objects");
 }
 
+/*
+ * 返回"container"的Object (internal_root), 如果为空先初始化
+ *
+ * (gdb) bt
+ * #0  object_get_internal_root () at qom/object.c:1457
+ * #1  0x00005555559d0132 in iothread_create (id=0x555555e8d6b4 "mon_iothread", errp=0x555556751590 <error_abort>) at iothread.c:366
+ * #2  0x0000555555857432 in monitor_iothread_init () at /home/zhang/kvm/qemu-3.0.0/monitor.c:4544
+ * #3  0x00005555558574ac in monitor_init_globals () at /home/zhang/kvm/qemu-3.0.0/monitor.c:4572
+ * #4  0x00005555559dc36d in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:3000
+ *
+ * called only by iothread_create():
+ *    366     obj = object_new_with_props(TYPE_IOTHREAD,
+ *    367                                 object_get_internal_root(),
+ *    368                                 id, errp, NULL);
+ */
 Object *object_get_internal_root(void)
 {
     static Object *internal_root;
@@ -1461,6 +2389,11 @@ Object *object_get_internal_root(void)
     return internal_root;
 }
 
+/*
+ * 用作get方法:
+ *   - qom/object.c|2008| <<object_property_add_child>> op = object_property_add(obj, name, type, object_get_child_property, NULL,
+ *   - qom/object.c|2191| <<object_property_add_const_link>> object_get_child_property, NULL,
+ */
 static void object_get_child_property(Object *obj, Visitor *v,
                                       const char *name, void *opaque,
                                       Error **errp)
@@ -1468,16 +2401,31 @@ static void object_get_child_property(Object *obj, Visitor *v,
     Object *child = opaque;
     gchar *path;
 
+    /*
+     * 如果obj是root ("container")就返回"/"
+     * 否则返回到达该obj的路径
+     */
     path = object_get_canonical_path(child);
     visit_type_str(v, name, &path, errp);
     g_free(path);
 }
 
+/*
+ * 用作ObjectProperty的resolve方法:
+ *   - qom/object.c|2020| <<object_property_add_child>> op->resolve = object_resolve_child_property;
+ *   - qom/object.c|2199| <<object_property_add_const_link>> op->resolve = object_resolve_child_property;
+ *
+ * 返回opaque
+ */
 static Object *object_resolve_child_property(Object *parent, void *opaque, const gchar *part)
 {
     return opaque;
 }
 
+/*
+ * 用作release方法:
+ *   - qom/object.c|2014| <<object_property_add_child>> object_finalize_child_property, child, &local_err);
+ */
 static void object_finalize_child_property(Object *obj, const char *name,
                                            void *opaque)
 {
@@ -1490,6 +2438,12 @@ static void object_finalize_child_property(Object *obj, const char *name,
     object_unref(child);
 }
 
+/*
+ * 把child设置成一个obj的ObjectProperty
+ * 在Object->properties (GHashTable)的name就是参数的name, type是"child<child的type>"
+ * ObjectProperty的opaque是child
+ * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+ */
 void object_property_add_child(Object *obj, const char *name,
                                Object *child, Error **errp)
 {
@@ -1504,6 +2458,10 @@ void object_property_add_child(Object *obj, const char *name,
 
     type = g_strdup_printf("child<%s>", object_get_typename(OBJECT(child)));
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     op = object_property_add(obj, name, type, object_get_child_property, NULL,
                              object_finalize_child_property, child, &local_err);
     if (local_err) {
@@ -1540,6 +2498,10 @@ static void object_get_link_property(Object *obj, Visitor *v,
     gchar *path;
 
     if (*child) {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         path = object_get_canonical_path(*child);
         visit_type_str(v, name, &path, errp);
         g_free(path);
@@ -1679,6 +2641,12 @@ out:
     g_free(full_type);
 }
 
+/*
+ * 把child设置成一个obj的ObjectProperty
+ * 在Object->properties (GHashTable)的name就是参数的name, type是"link<target的type>"
+ * 2003  * ObjectProperty的opaque是child
+ * 2004  * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+ */
 void object_property_add_const_link(Object *obj, const char *name,
                                     Object *target, Error **errp)
 {
@@ -1686,15 +2654,24 @@ void object_property_add_const_link(Object *obj, const char *name,
     ObjectProperty *op;
 
     link_type = g_strdup_printf("link<%s>", object_get_typename(target));
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     op = object_property_add(obj, name, link_type,
                              object_get_child_property, NULL,
                              NULL, target, errp);
     if (op != NULL) {
+        /* object_resolve_child_property就是返回opaque */
         op->resolve = object_resolve_child_property;
     }
     g_free(link_type);
 }
 
+/*
+ * 从该Object的parent的HashTable中寻找指向该Object的type开头是"child<"的并返回
+ * 似乎就是返回parent指向这个Object的prop->name
+ */
 gchar *object_get_canonical_path_component(Object *obj)
 {
     ObjectProperty *prop = NULL;
@@ -1705,7 +2682,9 @@ gchar *object_get_canonical_path_component(Object *obj)
     }
 
     g_hash_table_iter_init(&iter, obj->parent->properties);
+    /* 遍历parent (Object)的properties (HashTable) */
     while (g_hash_table_iter_next(&iter, NULL, (gpointer *)&prop)) {
+        /* 判断ObjectProperty的type是否开头是"child<" */
         if (!object_property_is_child(prop)) {
             continue;
         }
@@ -1720,16 +2699,26 @@ gchar *object_get_canonical_path_component(Object *obj)
     return NULL;
 }
 
+/*
+ * 如果obj是root ("container")就返回"/"
+ * 否则返回到达该obj的路径
+ */
 gchar *object_get_canonical_path(Object *obj)
 {
+    /* 返回"container"的Object (root), 如果为空先初始化 */
     Object *root = object_get_root();
     char *newpath, *path = NULL;
 
+    /* 如果参数的obj就是"container", 直接返回"/" */
     if (obj == root) {
         return g_strdup("/");
     }
 
     do {
+        /*
+	 * 从该Object的parent的HashTable中寻找指向该Object的type开头是"child<"的并返回
+	 * 似乎就是返回parent指向这个Object的prop->name
+	 */
         char *component = object_get_canonical_path_component(obj);
 
         if (!component) {
@@ -1740,6 +2729,7 @@ gchar *object_get_canonical_path(Object *obj)
             return NULL;
         }
 
+	/* 更新newpath */
         newpath = g_strdup_printf("/%s%s", component, path ? path : "");
         g_free(path);
         g_free(component);
@@ -1750,8 +2740,16 @@ gchar *object_get_canonical_path(Object *obj)
     return path;
 }
 
+/*
+ * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+ */
 Object *object_resolve_path_component(Object *parent, const gchar *part)
 {
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     ObjectProperty *prop = object_property_find(parent, part, NULL);
     if (prop == NULL) {
         return NULL;
@@ -1764,6 +2762,13 @@ Object *object_resolve_path_component(Object *parent, const gchar *part)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|2266| <<object_resolve_abs_path>> return object_resolve_abs_path(parent, parts, typename, index + 1);
+ *   - qom/object.c|2274| <<object_resolve_abs_path>> return object_resolve_abs_path(child, parts, typename, index + 1);
+ *   - qom/object.c|2286| <<object_resolve_partial_path>> obj = object_resolve_abs_path(parent, parts, typename, 0);
+ *   - qom/object.c|2331| <<object_resolve_path_type>> obj = object_resolve_abs_path(object_get_root(), parts, typename, 1);
+ */
 static Object *object_resolve_abs_path(Object *parent,
                                           gchar **parts,
                                           const char *typename,
@@ -1779,14 +2784,25 @@ static Object *object_resolve_abs_path(Object *parent,
         return object_resolve_abs_path(parent, parts, typename, index + 1);
     }
 
+    /*
+     * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+     */
     child = object_resolve_path_component(parent, parts[index]);
     if (!child) {
         return NULL;
     }
 
+    /*
+     * 递归调用自己, 处理parts[index+1]
+     */
     return object_resolve_abs_path(child, parts, typename, index + 1);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|2296| <<object_resolve_partial_path>> found = object_resolve_partial_path(prop->opaque, parts,
+ *   - qom/object.c|2325| <<object_resolve_path_type>> obj = object_resolve_partial_path(object_get_root(), parts,
+ */
 static Object *object_resolve_partial_path(Object *parent,
                                               gchar **parts,
                                               const char *typename,
@@ -1830,17 +2846,41 @@ Object *object_resolve_path_type(const char *path, const char *typename,
     Object *obj;
     gchar **parts;
 
+    /*
+     * 把path用'/'分开
+     *
+     * 对于/aaa/bbb/ccc/ddd
+     *     0: (不是NULL) 
+     *     1: aaa
+     *     2: bbb
+     *     3: ccc
+     *     4: ddd
+     *
+     * 对于aaa/bbb/ccc/ddd
+     *     0: aaa
+     *     1: bbb
+     *     2: ccc
+     *     3: ddd
+     */
     parts = g_strsplit(path, "/", 0);
     assert(parts);
 
     if (parts[0] == NULL || strcmp(parts[0], "") != 0) {
         bool ambiguous = false;
+	/*
+	 * object_get_root(): 返回"container"的Object (root), 如果为空先初始化
+	 */
         obj = object_resolve_partial_path(object_get_root(), parts,
                                           typename, &ambiguous);
         if (ambiguousp) {
             *ambiguousp = ambiguous;
         }
     } else {
+        /*
+	 * object_get_root(): 返回"container"的Object (root), 如果为空先初始化
+	 *
+	 * 最后的参数是1, 从第一个开始, 因为第0个是root
+	 */
         obj = object_resolve_abs_path(object_get_root(), parts, typename, 1);
     }
 
@@ -1854,12 +2894,20 @@ Object *object_resolve_path(const char *path, bool *ambiguous)
     return object_resolve_path_type(path, TYPE_OBJECT, ambiguous);
 }
 
+/*
+ * get和set的opaque
+ */
 typedef struct StringProperty
 {
     char *(*get)(Object *, Error **);
     void (*set)(Object *, const char *, Error **);
 } StringProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2384| <<object_property_add_str>> get ? property_get_str : NULL,
+ *   - qom/object.c|2419| <<object_class_property_add_str>> get ? property_get_str : NULL,
+ */
 static void property_get_str(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
 {
@@ -1877,6 +2925,11 @@ static void property_get_str(Object *obj, Visitor *v, const char *name,
     g_free(value);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|2385| <<object_property_add_str>> set ? property_set_str : NULL,
+ *   - qom/object.c|2420| <<object_class_property_add_str>> set ? property_set_str : NULL,
+ */
 static void property_set_str(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
 {
@@ -1894,6 +2947,11 @@ static void property_set_str(Object *obj, Visitor *v, const char *name,
     g_free(value);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2386| <<object_property_add_str>> property_release_str,
+ *   - qom/object.c|2421| <<object_class_property_add_str>> property_release_str,
+ */
 static void property_release_str(Object *obj, const char *name,
                                  void *opaque)
 {
@@ -1901,6 +2959,13 @@ static void property_release_str(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_str()
+ *     set     = property_set_str()
+ *     release = property_release_str()
+ */
 void object_property_add_str(Object *obj, const char *name,
                            char *(*get)(Object *, Error **),
                            void (*set)(Object *, const char *, Error **),
@@ -1909,9 +2974,14 @@ void object_property_add_str(Object *obj, const char *name,
     Error *local_err = NULL;
     StringProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_str(), property_set_str()和property_release_str用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "string",
                         get ? property_get_str : NULL,
                         set ? property_set_str : NULL,
@@ -1923,6 +2993,13 @@ void object_property_add_str(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_str()
+ *     set     = property_set_str()
+ *     release = property_release_str()
+ */
 void object_class_property_add_str(ObjectClass *klass, const char *name,
                                    char *(*get)(Object *, Error **),
                                    void (*set)(Object *, const char *,
@@ -1932,9 +3009,14 @@ void object_class_property_add_str(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     StringProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_str(), property_set_str()和property_release_str用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "string",
                               get ? property_get_str : NULL,
                               set ? property_set_str : NULL,
@@ -1946,12 +3028,20 @@ void object_class_property_add_str(ObjectClass *klass, const char *name,
     }
 }
 
+/*
+ * get和set的opaque
+ */
 typedef struct BoolProperty
 {
     bool (*get)(Object *, Error **);
     void (*set)(Object *, bool, Error **);
 } BoolProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2504| <<object_property_add_bool()>> get ? property_get_bool : NULL,
+ *   - qom/object.c|2526| <<object_class_property_add_bool()>> get ? property_get_bool : NULL,
+ */
 static void property_get_bool(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -1968,6 +3058,34 @@ static void property_get_bool(Object *obj, Visitor *v, const char *name,
     visit_type_bool(v, name, &value, errp);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|2505| <<object_property_add_bool()>> set ? property_set_bool : NULL,
+ *   - qom/object.c|2527| <<object_class_property_add_bool()>> set ? property_set_bool : NULL,
+ *
+ * 如下的会被object_property_set()调用:
+ *   - qom/object.c|2821| <<property_set_str>> prop->set(obj, value, errp);
+ *   - qom/object.c|2954| <<property_set_bool>> prop->set(obj, value, errp);
+ *   - qom/object.c|3090| <<property_set_enum>> prop->set(obj, value, errp);
+ *
+ *
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ *
+ *
+ * called by:
+ *   - qom/object.c|1957| <<object_property_set>> prop->set(obj, v, name, prop->opaque, errp);
+ */
 static void property_set_bool(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -1984,6 +3102,11 @@ static void property_set_bool(Object *obj, Visitor *v, const char *name,
     prop->set(obj, value, errp);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2531| <<object_property_add_bool()>> property_release_bool,
+ *   - qom/object.c|2565| <<object_class_property_add_bool()>> property_release_bool,
+ */
 static void property_release_bool(Object *obj, const char *name,
                                   void *opaque)
 {
@@ -1991,6 +3114,28 @@ static void property_release_bool(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 几个调用的例子:
+ *   - hw/core/bus.c|233| <<qbus_initfn>> object_property_add_bool(obj, "realized",
+ *   - hw/core/qdev.c|1004| <<device_initfn>> object_property_add_bool(obj, "realized",
+ *   - hw/core/qdev.c|1006| <<device_initfn>> object_property_add_bool(obj, "hotpluggable",
+ *   - hw/core/qdev.c|1008| <<device_initfn>> object_property_add_bool(obj, "hotplugged",
+ *
+ * 重要的一组例子:
+ * 1025     object_property_add_bool(obj, "realized",
+ * 1026                              device_get_realized, device_set_realized, NULL);
+ * 1027     object_property_add_bool(obj, "hotpluggable",
+ * 1028                              device_get_hotpluggable, NULL, NULL);
+ * 1029     object_property_add_bool(obj, "hotplugged",
+ * 1030                              device_get_hotplugged, NULL,
+ * 1031                              &error_abort);
+ *
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_bool()
+ *     set     = property_set_bool()
+ *     release = property_release_bool()
+ */
 void object_property_add_bool(Object *obj, const char *name,
                               bool (*get)(Object *, Error **),
                               void (*set)(Object *, bool, Error **),
@@ -1999,9 +3144,14 @@ void object_property_add_bool(Object *obj, const char *name,
     Error *local_err = NULL;
     BoolProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_bool(), property_set_bool()和property_release_bool用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "bool",
                         get ? property_get_bool : NULL,
                         set ? property_set_bool : NULL,
@@ -2013,6 +3163,13 @@ void object_property_add_bool(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_bool()
+ *     set     = property_set_bool()
+ *     release = property_release_bool()
+ */
 void object_class_property_add_bool(ObjectClass *klass, const char *name,
                                     bool (*get)(Object *, Error **),
                                     void (*set)(Object *, bool, Error **),
@@ -2021,9 +3178,14 @@ void object_class_property_add_bool(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     BoolProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_bool(), property_set_bool()和property_release_bool用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "bool",
                               get ? property_get_bool : NULL,
                               set ? property_set_bool : NULL,
@@ -2035,6 +3197,11 @@ void object_class_property_add_bool(ObjectClass *klass, const char *name,
     }
 }
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2631| <<object_property_add_enum>> get ? property_get_enum : NULL,
+ *   - qom/object.c|2656| <<object_class_property_add_enum>> get ? property_get_enum : NULL,
+ */
 static void property_get_enum(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -2051,6 +3218,11 @@ static void property_get_enum(Object *obj, Visitor *v, const char *name,
     visit_type_enum(v, name, &value, prop->lookup, errp);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|2632| <<object_property_add_enum>> set ? property_set_enum : NULL,
+ *   - qom/object.c|2657| <<object_class_property_add_enum>> set ? property_set_enum : NULL,
+ */
 static void property_set_enum(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -2066,6 +3238,11 @@ static void property_set_enum(Object *obj, Visitor *v, const char *name,
     prop->set(obj, value, errp);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2633| <<object_property_add_enum>> property_release_enum,
+ *   - qom/object.c|2658| <<object_class_property_add_enum>> property_release_enum,
+ */
 static void property_release_enum(Object *obj, const char *name,
                                   void *opaque)
 {
@@ -2073,6 +3250,13 @@ static void property_release_enum(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_enum()
+ *     set     = property_set_enum()
+ *     release = property_release_enum()
+ */
 void object_property_add_enum(Object *obj, const char *name,
                               const char *typename,
                               const QEnumLookup *lookup,
@@ -2083,10 +3267,15 @@ void object_property_add_enum(Object *obj, const char *name,
     Error *local_err = NULL;
     EnumProperty *prop = g_malloc(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_enum(), property_set_enum()和property_release_enum用到 */
     prop->lookup = lookup;
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, typename,
                         get ? property_get_enum : NULL,
                         set ? property_set_enum : NULL,
@@ -2098,6 +3287,13 @@ void object_property_add_enum(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_enum()
+ *     set     = property_set_enum()
+ *     release = property_release_enum()
+ */
 void object_class_property_add_enum(ObjectClass *klass, const char *name,
                                     const char *typename,
                                     const QEnumLookup *lookup,
@@ -2108,10 +3304,15 @@ void object_class_property_add_enum(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     EnumProperty *prop = g_malloc(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_enum(), property_set_enum()和property_release_enum用到 */
     prop->lookup = lookup;
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, typename,
                               get ? property_get_enum : NULL,
                               set ? property_set_enum : NULL,
@@ -2127,6 +3328,11 @@ typedef struct TMProperty {
     void (*get)(Object *, struct tm *, Error **);
 } TMProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2774| <<object_property_add_tm>> get ? property_get_tm : NULL, NULL,
+ *   - qom/object.c|2793| <<object_class_property_add_tm>> get ? property_get_tm : NULL, NULL,
+ */
 static void property_get_tm(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
 {
@@ -2175,6 +3381,11 @@ out:
 
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2775| <<object_property_add_tm>> property_release_tm,
+ *   - qom/object.c|2794| <<object_class_property_add_tm>> property_release_tm,
+ */
 static void property_release_tm(Object *obj, const char *name,
                                 void *opaque)
 {
@@ -2182,6 +3393,12 @@ static void property_release_tm(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_tm()
+ *     release = property_release_tm()
+ */
 void object_property_add_tm(Object *obj, const char *name,
                             void (*get)(Object *, struct tm *, Error **),
                             Error **errp)
@@ -2189,8 +3406,13 @@ void object_property_add_tm(Object *obj, const char *name,
     Error *local_err = NULL;
     TMProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_tm()和property_release_tm()用到 */
     prop->get = get;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "struct tm",
                         get ? property_get_tm : NULL, NULL,
                         property_release_tm,
@@ -2201,6 +3423,12 @@ void object_property_add_tm(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_tm()
+ *     release = property_release_tm()
+ */
 void object_class_property_add_tm(ObjectClass *klass, const char *name,
                                   void (*get)(Object *, struct tm *, Error **),
                                   Error **errp)
@@ -2208,8 +3436,13 @@ void object_class_property_add_tm(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     TMProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_tm()和property_release_tm()用到 */
     prop->get = get;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "struct tm",
                               get ? property_get_tm : NULL, NULL,
                               property_release_tm,
@@ -2220,11 +3453,19 @@ void object_class_property_add_tm(ObjectClass *klass, const char *name,
     }
 }
 
+/*
+ * 用作prop (opaque)的get
+ */
 static char *qdev_get_type(Object *obj, Error **errp)
 {
     return g_strdup(object_get_typename(obj));
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2873| <<object_property_add_uint8_ptr>> object_property_add(obj, name, "uint8", property_get_uint8_ptr,
+ *   - qom/object.c|2880| <<object_class_property_add_uint8_ptr>> object_class_property_add(klass, name, "uint8", property_get_uint8_ptr,
+ */
 static void property_get_uint8_ptr(Object *obj, Visitor *v, const char *name,
                                    void *opaque, Error **errp)
 {
@@ -2232,6 +3473,11 @@ static void property_get_uint8_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint8(v, name, &value, errp);
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2892| <<object_property_add_uint16_ptr>> object_property_add(obj, name, "uint16", property_get_uint16_ptr,
+ *   - qom/object.c|2899| <<object_class_property_add_uint16_ptr>> object_class_property_add(klass, name, "uint16", property_get_uint16_ptr,
+ */
 static void property_get_uint16_ptr(Object *obj, Visitor *v, const char *name,
                                     void *opaque, Error **errp)
 {
@@ -2239,6 +3485,11 @@ static void property_get_uint16_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint16(v, name, &value, errp);
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2911| <<object_property_add_uint32_ptr>> object_property_add(obj, name, "uint32", property_get_uint32_ptr,
+ *   - qom/object.c|2918| <<object_class_property_add_uint32_ptr>> object_class_property_add(klass, name, "uint32", property_get_uint32_ptr,
+ */
 static void property_get_uint32_ptr(Object *obj, Visitor *v, const char *name,
                                     void *opaque, Error **errp)
 {
@@ -2246,6 +3497,11 @@ static void property_get_uint32_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint32(v, name, &value, errp);
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2930| <<object_property_add_uint64_ptr>> object_property_add(obj, name, "uint64", property_get_uint64_ptr,
+ *   - qom/object.c|2937| <<object_class_property_add_uint64_ptr>> object_class_property_add(klass, name, "uint64", property_get_uint64_ptr,
+ */
 static void property_get_uint64_ptr(Object *obj, Visitor *v, const char *name,
                                     void *opaque, Error **errp)
 {
@@ -2253,58 +3509,122 @@ static void property_get_uint64_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint64(v, name, &value, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint8_ptr(Object *obj, const char *name,
                                    const uint8_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint8", property_get_uint8_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint8_ptr(ObjectClass *klass, const char *name,
                                          const uint8_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint8", property_get_uint8_ptr,
                               NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint16_ptr(Object *obj, const char *name,
                                     const uint16_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint16", property_get_uint16_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint16_ptr(ObjectClass *klass, const char *name,
                                           const uint16_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint16", property_get_uint16_ptr,
                               NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint32_ptr(Object *obj, const char *name,
                                     const uint32_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint32", property_get_uint32_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint32_ptr(ObjectClass *klass, const char *name,
                                           const uint32_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint32", property_get_uint32_ptr,
                               NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint64_ptr(Object *obj, const char *name,
                                     const uint64_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint64", property_get_uint64_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint64_ptr(ObjectClass *klass, const char *name,
                                           const uint64_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint64", property_get_uint64_ptr,
                               NULL, NULL, (void *)v, errp);
 }
@@ -2314,30 +3634,51 @@ typedef struct {
     char *target_name;
 } AliasProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|3536| <<object_property_add_alias>> property_get_alias,
+ */
 static void property_get_alias(Object *obj, Visitor *v, const char *name,
                                void *opaque, Error **errp)
 {
     AliasProperty *prop = opaque;
 
+    /* 根据name找到ObjectProperty, 然后调用其get方法 */
     object_property_get(prop->target_obj, v, prop->target_name, errp);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|3537| <<object_property_add_alias>> property_set_alias,
+ */
 static void property_set_alias(Object *obj, Visitor *v, const char *name,
                                void *opaque, Error **errp)
 {
     AliasProperty *prop = opaque;
 
+    /* 根据name找到ObjectProperty, 然后调用其set方法 */
     object_property_set(prop->target_obj, v, prop->target_name, errp);
 }
 
+/*
+ * 作为ObjectProperty的resolve方法:
+ *   - qom/object.c|3545| <<object_property_add_alias>> op->resolve = property_resolve_alias;
+ */
 static Object *property_resolve_alias(Object *obj, void *opaque,
                                       const gchar *part)
 {
     AliasProperty *prop = opaque;
 
+    /*
+     * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+     */
     return object_resolve_path_component(prop->target_obj, prop->target_name);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|3538| <<object_property_add_alias>> property_release_alias,
+ */
 static void property_release_alias(Object *obj, const char *name, void *opaque)
 {
     AliasProperty *prop = opaque;
@@ -2346,6 +3687,10 @@ static void property_release_alias(Object *obj, const char *name, void *opaque)
     g_free(prop);
 }
 
+/*
+ * 一个调用的例子:
+ *   - hw/virtio/virtio-pci.c|1994| <<virtio_blk_pci_instance_init>> object_property_add_alias(obj, "bootindex", OBJECT(&dev->vdev),
+ */
 void object_property_add_alias(Object *obj, const char *name,
                                Object *target_obj, const char *target_name,
                                Error **errp)
@@ -2356,11 +3701,17 @@ void object_property_add_alias(Object *obj, const char *name,
     gchar *prop_type;
     Error *local_err = NULL;
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     target_prop = object_property_find(target_obj, target_name, errp);
     if (!target_prop) {
         return;
     }
 
+    /* 判断ObjectProperty的type是否开头是"child<" */
     if (object_property_is_child(target_prop)) {
         prop_type = g_strdup_printf("link%s",
                                     target_prop->type + strlen("child"));
@@ -2372,6 +3723,10 @@ void object_property_add_alias(Object *obj, const char *name,
     prop->target_obj = target_obj;
     prop->target_name = g_strdup(target_name);
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     op = object_property_add(obj, name, prop_type,
                              property_get_alias,
                              property_set_alias,
@@ -2384,6 +3739,12 @@ void object_property_add_alias(Object *obj, const char *name,
     }
     op->resolve = property_resolve_alias;
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     * 最后修改找到的ObjectProperty的description
+     */
     object_property_set_description(obj, op->name,
                                     target_prop->description,
                                     &error_abort);
@@ -2392,11 +3753,22 @@ out:
     g_free(prop_type);
 }
 
+/*
+ * 递归调用自己的parent (ObjectClass) 寻找prop
+ * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+ * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+ * 最后修改找到的ObjectProperty的description
+ */
 void object_property_set_description(Object *obj, const char *name,
                                      const char *description, Error **errp)
 {
     ObjectProperty *op;
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     op = object_property_find(obj, name, errp);
     if (!op) {
         return;
@@ -2406,6 +3778,10 @@ void object_property_set_description(Object *obj, const char *name,
     op->description = g_strdup(description);
 }
 
+/*
+ * 从ObjectClass(不是Object)的properties中寻找name的ObjectProperty
+ * 找到后重新设置ObjectProperty的description
+ */
 void object_class_property_set_description(ObjectClass *klass,
                                            const char *name,
                                            const char *description,
@@ -2423,11 +3799,30 @@ void object_class_property_set_description(ObjectClass *klass,
     op->description = g_strdup(description);
 }
 
+/*
+ * TypeInfo object_info.instance_init = object_instance_init()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void object_instance_init(Object *obj)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     *     get     = property_get_str()
+     *     set     = property_set_str()
+     *     release = property_release_str()
+     *
+     *  qdev_get_type()就是返回obj->class->type->name
+     */
     object_property_add_str(obj, "type", qdev_get_type, NULL, NULL);
 }
 
+/*
+ * 在以下被间接调用:
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ */
 static void register_types(void)
 {
     static TypeInfo interface_info = {
@@ -2443,8 +3838,31 @@ static void register_types(void)
         .abstract = true,
     };
 
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_interface = type_register_internal(&interface_info);
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_internal(&object_info);
 }
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ *
+ * 所有注册的module_init_type在以下调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * module_call_init()遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
 type_init(register_types)
diff --git a/qom/object_interfaces.c b/qom/object_interfaces.c
index 72b97a8..c1ccd33 100644
--- a/qom/object_interfaces.c
+++ b/qom/object_interfaces.c
@@ -168,6 +168,9 @@ void user_creatable_del(const char *id, Error **errp)
     Object *obj;
 
     container = object_get_objects_root();
+    /*
+     * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+     */
     obj = object_resolve_path_component(container, id);
     if (!obj) {
         error_setg(errp, "object '%s' not found", id);
diff --git a/qom/qom-qobject.c b/qom/qom-qobject.c
index 4aec20d..b7fedf5 100644
--- a/qom/qom-qobject.c
+++ b/qom/qom-qobject.c
@@ -18,16 +18,60 @@
 #include "qapi/qobject-input-visitor.h"
 #include "qapi/qobject-output-visitor.h"
 
+/*
+ * called by:
+ *   - qmp.c|235| <<qmp_qom_set>> object_property_set_qobject(obj, value, property, errp);
+ *   - qom/object.c|1650| <<object_property_set_str>> object_property_set_qobject(obj, QOBJECT(qstr), name, errp);
+ *   - qom/object.c|1708| <<object_property_set_bool>> object_property_set_qobject(obj, QOBJECT(qbool), name, errp);
+ *   - qom/object.c|1739| <<object_property_set_int>> object_property_set_qobject(obj, QOBJECT(qnum), name, errp);
+ *   - qom/object.c|1770| <<object_property_set_uint>> object_property_set_qobject(obj, QOBJECT(qnum), name, errp);
+ *   - target/i386/cpu.c|3696| <<object_apply_props>> object_property_set_qobject(obj, qdict_entry_value(prop),
+ *
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 void object_property_set_qobject(Object *obj, QObject *value,
                                  const char *name, Error **errp)
 {
     Visitor *v;
 
+    /*
+     * 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是value(QObject)
+     * 返回包含的Visitor
+     */
     v = qobject_input_visitor_new(value);
+    /*
+     * 据name找到ObjectProperty, 然后调用其set方法
+     */
     object_property_set(obj, v, name, errp);
     visit_free(v);
 }
 
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|196| <<acpi_get_pm_info>> o = object_property_get_qobject(obj, ACPI_PM_PROP_S3_DISABLED, NULL);
+ *   - hw/i386/acpi-build.c|203| <<acpi_get_pm_info>> o = object_property_get_qobject(obj, ACPI_PM_PROP_S4_DISABLED, NULL);
+ *   - hw/i386/acpi-build.c|210| <<acpi_get_pm_info>> o = object_property_get_qobject(obj, ACPI_PM_PROP_S4_VAL, NULL);
+ *   - hw/i386/acpi-build.c|438| <<build_append_pci_bus_devices>> bsel = object_property_get_qobject(OBJECT(bus), ACPI_PCIHP_PROP_BSEL, NULL);
+ *   - hw/i386/acpi-build.c|2617| <<acpi_get_mcfg>> o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_BASE, NULL);
+ *   - hw/i386/acpi-build.c|2624| <<acpi_get_mcfg>> o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_SIZE, NULL);
+ *   - qmp.c|249| <<qmp_qom_get>> return object_property_get_qobject(obj, property, errp);
+ *   - qom/object.c|1658| <<object_property_get_str>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - qom/object.c|1716| <<object_property_get_bool>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - qom/object.c|1747| <<object_property_get_int>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - qom/object.c|1777| <<object_property_get_uint>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - target/i386/cpu.c|3642| <<x86_cpu_expand_prop>> QObject *value = object_property_get_qobject(OBJECT(cpu), prop,
+ */
 QObject *object_property_get_qobject(Object *obj, const char *name,
                                      Error **errp)
 {
@@ -36,6 +80,9 @@ QObject *object_property_get_qobject(Object *obj, const char *name,
     Visitor *v;
 
     v = qobject_output_visitor_new(&ret);
+    /*
+     * 根据name找到ObjectProperty, 然后调用其get方法
+     */
     object_property_get(obj, v, name, &local_err);
     if (!local_err) {
         visit_complete(v, &ret);
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 723e022..268a12f 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -4480,6 +4480,22 @@ static void x86_cpu_apic_create(X86CPU *cpu, Error **errp)
     apic->apicbase = APIC_DEFAULT_ADDRESS | MSR_IA32_APICBASE_ENABLE;
 }
 
+/*
+ * 测试的几个cpu调用几次:
+ * #0  x86_cpu_apic_realize (cpu=0x5555568e8780, errp=0x7fffffffdc40) at /home/zhang/kvm/qemu-3.0.0/target/i386/cpu.c:4488
+ * #1  0x00005555559571da in x86_cpu_realizefn (dev=0x5555568e8780, errp=0x7fffffffdcc0) at /home/zhang/kvm/qemu-3.0.0/target/i386/cpu.c:5017
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555568e8780, value=true, errp=0x7fffffffde98) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555568e8780, v=0x555556902000, name=0x555555ea7440 "realized", opaque=0x5555568e8710, errp=0x7fffffffde98) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555568e8780, v=0x555556902000, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555568e8780, value=0x5555569066a0, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555568e8780, value=true, name=0x555555ea7440 "realized", errp=0x7fffffffde98) at qom/object.c:1242
+ * #7  0x00005555559184e7 in pc_new_cpu (typename=0x555555ea7dec "qemu64-x86_64-cpu", apic_id=1, errp=0x555556751598 <error_fatal>) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1107
+ * #8  0x0000555555918752 in pc_cpus_init (pcms=0x55555684fa40) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc.c:1155
+ * #9  0x000055555591cd4d in pc_init1 (machine=0x55555684fa40, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:153
+ * #10 0x000055555591da26 in pc_init_v3_0 (machine=0x55555684fa40) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #11 0x0000555555a7c472 in machine_run_board_init (machine=0x55555684fa40) at hw/core/machine.c:830
+ * #12 0x00005555559dfb8f in main (argc=16, argv=0x7fffffffe388, envp=0x7fffffffe410) at vl.c:4516
+ */
 static void x86_cpu_apic_realize(X86CPU *cpu, Error **errp)
 {
     APICCommonState *apic;
diff --git a/target/i386/kvm.c b/target/i386/kvm.c
index 9313602..a260ff1 100644
--- a/target/i386/kvm.c
+++ b/target/i386/kvm.c
@@ -1374,6 +1374,10 @@ static void register_smram_listener(Notifier *n, void *unused)
                                  &smram_address_space, 1);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1677| <<kvm_init>> ret = kvm_arch_init(ms, s);
+ */
 int kvm_arch_init(MachineState *ms, KVMState *s)
 {
     uint64_t identity_base = 0xfffbc000;
diff --git a/ui/console.c b/ui/console.c
index bc58458..b4144cb 100644
--- a/ui/console.c
+++ b/ui/console.c
@@ -1877,6 +1877,12 @@ static DisplayState *get_alloc_displaystate(void)
  * Called by main(), after creating QemuConsoles
  * and before initializing ui (sdl/vnc/...).
  */
+/*
+ * gdb调试确认被调用了
+ * (gdb) bt
+ * #0  init_displaystate () at ui/console.c:1885
+ * #1  0x00005555559dfcaa in main (argc=14, argv=0x7fffffffe408, envp=0x7fffffffe480) at vl.c:4573
+ */
 DisplayState *init_displaystate(void)
 {
     gchar *name;
diff --git a/util/module.c b/util/module.c
index c909737..4a9b8ec 100644
--- a/util/module.c
+++ b/util/module.c
@@ -32,34 +32,64 @@ typedef QTAILQ_HEAD(, ModuleEntry) ModuleTypeList;
 
 static ModuleTypeList init_type_list[MODULE_INIT_MAX];
 
+/*
+ * used by:
+ *   - util/module.c|58| <<init_lists>> QTAILQ_INIT(&dso_init_list);
+ *   - util/module.c|115| <<register_dso_module_init>> QTAILQ_INSERT_TAIL(&dso_init_list, e, node);
+ *   - util/module.c|163| <<module_load_file>> assert(QTAILQ_EMPTY(&dso_init_list));
+ *   - util/module.c|184| <<module_load_file>> QTAILQ_FOREACH(e, &dso_init_list, node) {
+ *   - util/module.c|191| <<module_load_file>> QTAILQ_FOREACH_SAFE(e, &dso_init_list, node, next) {
+ *   - util/module.c|192| <<module_load_file>> QTAILQ_REMOVE(&dso_init_list, e, node);
+ */
 static ModuleTypeList dso_init_list;
 
+/*
+ * called by:
+ *   - util/module.c|58| <<find_type>> init_lists();
+ *   - util/module.c|81| <<register_dso_module_init>> init_lists();
+ *
+ * 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化)
+ */
 static void init_lists(void)
 {
     static int inited;
     int i;
 
+    /* 静态变量只在这个函数修改 如果是1说明初始化过了 */
     if (inited) {
         return;
     }
 
     for (i = 0; i < MODULE_INIT_MAX; i++) {
-        QTAILQ_INIT(&init_type_list[i]);
+        QTAILQ_INIT(&init_type_list[i]);  // 在该函数上面声明的
     }
 
-    QTAILQ_INIT(&dso_init_list);
+    QTAILQ_INIT(&dso_init_list);  // 在该函数上面声明的
 
     inited = 1;
 }
 
 
+/*
+ * called by:
+ *   - register_module_init()
+ *   - module_call_init()
+ *
+ * 返回init_type_list[type] (type最多MODULE_INIT_MAX个)
+ */
 static ModuleTypeList *find_type(module_init_type type)
 {
+    /* 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化) */
     init_lists();
 
     return &init_type_list[type];
 }
 
+/*
+ * type最多MODULE_INIT_MAX个
+ *
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[type] (type最多MODULE_INIT_MAX个)
+ */
 void register_module_init(void (*fn)(void), module_init_type type)
 {
     ModuleEntry *e;
@@ -69,15 +99,22 @@ void register_module_init(void (*fn)(void), module_init_type type)
     e->init = fn;
     e->type = type;
 
+    /* 返回init_type_list[type] (type最多MODULE_INIT_MAX个) */
     l = find_type(type);
 
     QTAILQ_INSERT_TAIL(l, e, node);
 }
 
+/*
+ * type最多MODULE_INIT_MAX个
+ *
+ * 根据fn初始化一个ModuleEntry插入到dso_init_list
+ */
 void register_dso_module_init(void (*fn)(void), module_init_type type)
 {
     ModuleEntry *e;
 
+    /* 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化) */
     init_lists();
 
     e = g_malloc0(sizeof(*e));
@@ -87,6 +124,15 @@ void register_dso_module_init(void (*fn)(void), module_init_type type)
     QTAILQ_INSERT_TAIL(&dso_init_list, e, node);
 }
 
+/*
+ * 主要的调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * 遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
 void module_call_init(module_init_type type)
 {
     ModuleTypeList *l;
@@ -100,6 +146,9 @@ void module_call_init(module_init_type type)
 }
 
 #ifdef CONFIG_MODULES
+/*
+ * called only by module_load_one()
+ */
 static int module_load_file(const char *fname)
 {
     GModule *g_module;
@@ -157,6 +206,12 @@ out:
 }
 #endif
 
+/*
+ * called by:
+ *   - include/qemu/module.h|55| <<block_module_load_one>> #define block_module_load_one(lib) module_load_one("block-", lib)
+ *   - include/qemu/module.h|56| <<ui_module_load_one>> #define ui_module_load_one(lib) module_load_one("ui-", lib)
+ *   - include/qemu/module.h|57| <<audio_module_load_one>> #define audio_module_load_one(lib) module_load_one("audio-", lib)
+ */
 void module_load_one(const char *prefix, const char *lib_name)
 {
 #ifdef CONFIG_MODULES
diff --git a/util/qemu-config.c b/util/qemu-config.c
index 9d2e278..68da2f3 100644
--- a/util/qemu-config.c
+++ b/util/qemu-config.c
@@ -9,9 +9,24 @@
 #include "qemu/option.h"
 #include "qemu/config-file.h"
 
+/*
+ * 应该是只通过qemu_add_opts()添加新元素
+ */
 static QemuOptsList *vm_config_groups[48];
+/*
+ * 应该只通过qemu_add_drive_opts()添加新元素
+ */
 static QemuOptsList *drive_config_groups[5];
 
+/*
+ * called by:
+ *   - util/qemu-config.c|41| <<qemu_find_opts>> ret = find_list(vm_config_groups, group, &local_err);
+ *   - util/qemu-config.c|288| <<qemu_find_opts_err>> return find_list(vm_config_groups, group, errp);
+ *   - util/qemu-config.c|484| <<qemu_config_parse>> list = find_list(lists, group, &local_err);
+ *   - util/qemu-config.c|495| <<qemu_config_parse>> list = find_list(lists, group, &local_err);
+ *
+ * 从参数给的QemuOptsList列表中寻找lists[i]的name是参数group的, 并返回list[i]
+ */
 static QemuOptsList *find_list(QemuOptsList **lists, const char *group,
                                Error **errp)
 {
@@ -27,11 +42,17 @@ static QemuOptsList *find_list(QemuOptsList **lists, const char *group,
     return lists[i];
 }
 
+/*
+ * 从vm_config_groups(QemuOptsList)列表中寻找name是参数group的, 并返回(QemuOptsList)
+ */
 QemuOptsList *qemu_find_opts(const char *group)
 {
     QemuOptsList *ret;
     Error *local_err = NULL;
 
+    /*
+     * 从vm_config_groups(QemuOptsList)列表中寻找name是参数group的, 并返回在ret(QemuOptsList)
+     */
     ret = find_list(vm_config_groups, group, &local_err);
     if (local_err) {
         error_report_err(local_err);
@@ -282,6 +303,13 @@ QemuOptsList *qemu_find_opts_err(const char *group, Error **errp)
     return find_list(vm_config_groups, group, errp);
 }
 
+/*
+ * called by:
+ *   - vl.c|3014| <<main>> qemu_add_drive_opts(&qemu_legacy_drive_opts);
+ *   - vl.c|3015| <<main>> qemu_add_drive_opts(&qemu_common_drive_opts);
+ *   - vl.c|3016| <<main>> qemu_add_drive_opts(&qemu_drive_opts);
+ *   - vl.c|3017| <<main>> qemu_add_drive_opts(&bdrv_runtime_opts);
+ */
 void qemu_add_drive_opts(QemuOptsList *list)
 {
     int entries, i;
@@ -298,6 +326,48 @@ void qemu_add_drive_opts(QemuOptsList *list)
     abort();
 }
 
+/*
+ * 被很多调用, 比如:
+ *   - vl.c|3005| <<main>> qemu_add_opts(&qemu_device_opts);
+ *
+ * 正常的调用:
+ *   - vl.c|3013| <<main>> qemu_add_opts(&qemu_drive_opts);
+ *   - vl.c|3018| <<main>> qemu_add_opts(&qemu_chardev_opts);
+ *   - vl.c|3019| <<main>> qemu_add_opts(&qemu_device_opts);
+ *   - vl.c|3020| <<main>> qemu_add_opts(&qemu_netdev_opts);
+ *   - vl.c|3021| <<main>> qemu_add_opts(&qemu_nic_opts);
+ *   - vl.c|3022| <<main>> qemu_add_opts(&qemu_net_opts);
+ *   - vl.c|3023| <<main>> qemu_add_opts(&qemu_rtc_opts);
+ *   - vl.c|3024| <<main>> qemu_add_opts(&qemu_global_opts);
+ *   - vl.c|3025| <<main>> qemu_add_opts(&qemu_mon_opts);
+ *   - vl.c|3026| <<main>> qemu_add_opts(&qemu_trace_opts);
+ *   - vl.c|3027| <<main>> qemu_add_opts(&qemu_option_rom_opts);
+ *   - vl.c|3028| <<main>> qemu_add_opts(&qemu_machine_opts);
+ *   - vl.c|3029| <<main>> qemu_add_opts(&qemu_accel_opts);
+ *   - vl.c|3030| <<main>> qemu_add_opts(&qemu_mem_opts);
+ *   - vl.c|3031| <<main>> qemu_add_opts(&qemu_smp_opts);
+ *   - vl.c|3032| <<main>> qemu_add_opts(&qemu_boot_opts);
+ *   - vl.c|3033| <<main>> qemu_add_opts(&qemu_add_fd_opts);
+ *   - vl.c|3034| <<main>> qemu_add_opts(&qemu_object_opts);
+ *   - vl.c|3035| <<main>> qemu_add_opts(&qemu_tpmdev_opts);
+ *   - vl.c|3036| <<main>> qemu_add_opts(&qemu_realtime_opts);
+ *   - vl.c|3037| <<main>> qemu_add_opts(&qemu_msg_opts);
+ *   - vl.c|3038| <<main>> qemu_add_opts(&qemu_name_opts);
+ *   - vl.c|3039| <<main>> qemu_add_opts(&qemu_numa_opts);
+ *   - vl.c|3040| <<main>> qemu_add_opts(&qemu_icount_opts);
+ *   - vl.c|3041| <<main>> qemu_add_opts(&qemu_semihosting_config_opts);
+ *   - vl.c|3042| <<main>> qemu_add_opts(&qemu_fw_cfg_opts);
+ *
+ * 不确定的:
+ *   - block/iscsi-opts.c|67| <<iscsi_block_opts_init>> qemu_add_opts(&qemu_iscsi_opts);
+ *   - fsdev/qemu-fsdev-opts.c|98| <<fsdev_register_config>> qemu_add_opts(&qemu_fsdev_opts);
+ *   - fsdev/qemu-fsdev-opts.c|99| <<fsdev_register_config>> qemu_add_opts(&qemu_virtfs_opts);
+ *   - hw/acpi/core.c|70| <<acpi_register_config>> qemu_add_opts(&qemu_acpi_opts);
+ *   - hw/smbios/smbios.c|339| <<smbios_register_config>> qemu_add_opts(&qemu_smbios_opts);
+ *   - qemu-seccomp.c|251| <<seccomp_register>> qemu_add_opts(&qemu_sandbox_opts);
+ *   - ui/spice-core.c|951| <<spice_register_config>> qemu_add_opts(&qemu_spice_opts);
+ *   - ui/vnc.c|4183| <<vnc_register_config>> qemu_add_opts(&qemu_vnc_opts);
+ */
 void qemu_add_opts(QemuOptsList *list)
 {
     int entries, i;
@@ -305,6 +375,9 @@ void qemu_add_opts(QemuOptsList *list)
     entries = ARRAY_SIZE(vm_config_groups);
     entries--; /* keep list NULL terminated */
     for (i = 0; i < entries; i++) {
+        /*
+	 * 从头开始找到一个非空的设置QemuOptsList
+	 */
         if (vm_config_groups[i] == NULL) {
             vm_config_groups[i] = list;
             return;
@@ -314,6 +387,10 @@ void qemu_add_opts(QemuOptsList *list)
     abort();
 }
 
+/*
+ * called only by:
+ *   - vl.c|3130| <<main>> if (qemu_set_option(optarg) != 0)
+ */
 int qemu_set_option(const char *str)
 {
     Error *local_err = NULL;
@@ -391,6 +468,11 @@ void qemu_config_write(FILE *fp)
 }
 
 /* Returns number of config groups on success, -errno on error */
+/*
+ * called by:
+ *    - block/blkdebug.c|244| <<read_config>> ret = qemu_config_parse(f, config_groups, filename);
+ *    - util/qemu-config.c|481| <<qemu_read_config_file>> ret = qemu_config_parse(f, vm_config_groups, filename);
+ */
 int qemu_config_parse(FILE *fp, QemuOptsList **lists, const char *fname)
 {
     char line[1024], group[64], id[64], arg[64], value[1024];
@@ -462,6 +544,11 @@ out:
     return res;
 }
 
+/*
+ * called by:
+ *   - vl.c|2916| <<qemu_read_default_config_file>> ret = qemu_read_config_file(CONFIG_QEMU_CONFDIR "/qemu.conf");
+ *   - vl.c|3876| <<main>> int ret = qemu_read_config_file(optarg); --->  QEMU_OPTION_readconfig
+ */
 int qemu_read_config_file(const char *filename)
 {
     FILE *f = fopen(filename, "r");
@@ -476,6 +563,10 @@ int qemu_read_config_file(const char *filename)
     return ret;
 }
 
+/*
+ * called only by read_config()-->qemu_config_parse_qdict()
+ *   - util/qemu-config.c|598| <<qemu_config_parse_qdict>> config_parse_qdict_section(options, lists[i], &local_err);
+ */
 static void config_parse_qdict_section(QDict *options, QemuOptsList *opts,
                                        Error **errp)
 {
@@ -567,6 +658,10 @@ out:
     qobject_unref(list);
 }
 
+/*
+ * called only by:
+ *   - block/blkdebug.c|251| <<read_config>> qemu_config_parse_qdict(options, config_groups, &local_err);
+ */
 void qemu_config_parse_qdict(QDict *options, QemuOptsList **lists,
                              Error **errp)
 {
diff --git a/util/qemu-option.c b/util/qemu-option.c
index 01886ef..03d3ac8 100644
--- a/util/qemu-option.c
+++ b/util/qemu-option.c
@@ -601,6 +601,9 @@ QemuOpts *qemu_opts_find(QemuOptsList *list, const char *id)
     return NULL;
 }
 
+/*
+ * 核心思想是分配简单初始化一个QemuOpts, 插入QemuOptsList的head
+ */
 QemuOpts *qemu_opts_create(QemuOptsList *list, const char *id,
                            int fail_if_exists, Error **errp)
 {
@@ -749,6 +752,11 @@ void qemu_opts_print(QemuOpts *opts, const char *separator)
     }
 }
 
+/*
+ * called by:
+ *   - util/qemu-option.c|817| <<qemu_opts_do_parse>> opts_do_parse(opts, params, firstname, false, errp);
+ *   - util/qemu-option.c|861| <<opts_parse>> opts_do_parse(opts, params, firstname, defaults, &local_err);
+ */
 static void opts_do_parse(QemuOpts *opts, const char *params,
                           const char *firstname, bool prepend, Error **errp)
 {
@@ -817,6 +825,14 @@ void qemu_opts_do_parse(QemuOpts *opts, const char *params,
     opts_do_parse(opts, params, firstname, false, errp);
 }
 
+/*
+ * called by:
+ *   - util/qemu-option.c|876| <<qemu_opts_parse>> return opts_parse(list, params, permit_abbrev, false, errp);
+ *   - util/qemu-option.c|896| <<qemu_opts_parse_noisily>> opts = opts_parse(list, params, permit_abbrev, false, &err);
+ *   - util/qemu-option.c|908| <<qemu_opts_set_defaults>> opts = opts_parse(list, params, permit_abbrev, true, NULL);
+ *
+ * 从qemu_opts_parse_noisily()调用过来的一个例子: list=qemu_mem_opts, params="3000M", permit_abbrev=true, defaults=false
+ */
 static QemuOpts *opts_parse(QemuOptsList *list, const char *params,
                             bool permit_abbrev, bool defaults, Error **errp)
 {
@@ -843,6 +859,9 @@ static QemuOpts *opts_parse(QemuOptsList *list, const char *params,
      * (if unlikely) future misuse:
      */
     assert(!defaults || list->merge_lists);
+    /*
+     * 核心思想是分配简单初始化一个QemuOpts, 插入QemuOptsList的head
+     */
     opts = qemu_opts_create(list, id, !defaults, &local_err);
     g_free(id);
     if (opts == NULL) {
@@ -881,6 +900,9 @@ QemuOpts *qemu_opts_parse(QemuOptsList *list, const char *params,
  * QMP context.  Do not use this function there!
  * Return the new QemuOpts on success, null pointer on error.
  */
+/*
+ * 调用的一个例子是: list=qemu_mem_opts, params="3000M", permit_abbrev=true
+ */
 QemuOpts *qemu_opts_parse_noisily(QemuOptsList *list, const char *params,
                                   bool permit_abbrev)
 {
diff --git a/vl.c b/vl.c
index 16b913f..b929f62 100644
--- a/vl.c
+++ b/vl.c
@@ -1389,6 +1389,10 @@ static int usb_parse(const char *cmdline)
 
 MachineState *current_machine;
 
+/*
+ * called only by:
+ *   - vl.c|2564| <<machine_parse>> mc = find_machine(name);
+ */
 static MachineClass *find_machine(const char *name)
 {
     GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);
@@ -1412,6 +1416,10 @@ static MachineClass *find_machine(const char *name)
     return mc;
 }
 
+/*
+ * called only by:
+ *   - vl.c|2677| <<select_machine>> MachineClass *machine_class = find_default_machine();
+ */
 MachineClass *find_default_machine(void)
 {
     GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);
@@ -1907,6 +1915,12 @@ typedef struct QEMUOption {
     uint32_t arch_mask;
 } QEMUOption;
 
+/*
+ * used only by:
+ *   - vl.c|2670| <<lookup_opt>> popt = qemu_options;
+ *
+ * 全局数组 (从"qemu-options-wrapper.h"插入的)
+ */
 static const QEMUOption qemu_options[] = {
     { "h", 0, QEMU_OPTION_h, QEMU_ARCH_ALL },
 #define QEMU_OPTIONS_GENERATE_OPTIONS
@@ -2267,6 +2281,24 @@ static int device_help_func(void *opaque, QemuOpts *opts, Error **errp)
     return qdev_device_help(opts);
 }
 
+/*
+ * 被main()函数调用:
+ * 4557     if (qemu_opts_foreach(qemu_find_opts("device"),
+ * 4558                           device_init_func, NULL, NULL)) {
+ *
+ * (gdb) bt
+ * #0  nvme_realize (pci_dev=0x5555579a9f20, errp=0x7fffffffdde8) at hw/block/nvme.c:1202
+ * #1  0x0000555555b36d72 in pci_qdev_realize (qdev=0x5555579a9f20, errp=0x7fffffffde60) at hw/pci/pci.c:2028
+ * #2  0x0000555555a73ecc in device_set_realized (obj=0x5555579a9f20, value=true, errp=0x7fffffffe030) at hw/core/qdev.c:826
+ * #3  0x0000555555c6020e in property_set_bool (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", opaque=0x5555579abbf0, errp=0x7fffffffe030) at qom/object.c:1984
+ * #4  0x0000555555c5e493 in object_property_set (obj=0x5555579a9f20, v=0x5555579ad000, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1176
+ * #5  0x0000555555c6154b in object_property_set_qobject (obj=0x5555579a9f20, value=0x5555579acf50, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/qom-qobject.c:27
+ * #6  0x0000555555c5e778 in object_property_set_bool (obj=0x5555579a9f20, value=true, name=0x555555ebcaaa "realized", errp=0x7fffffffe030) at qom/object.c:1242
+ * #7  0x00005555559d2619 in qdev_device_add (opts=0x5555567bde00, errp=0x7fffffffe0a8) at qdev-monitor.c:627
+ * #8  0x00005555559daaa7 in device_init_func (opaque=0x0, opts=0x5555567bde00, errp=0x0) at vl.c:2275
+ * #9  0x0000555555da672b in qemu_opts_foreach (list=0x555556589680 <qemu_device_opts>, func=0x5555559daa69 <device_init_func>, opaque=0x0, errp=0x0) at util/qemu-option.c:1106
+ * #10 0x00005555559dfc38 in main (argc=14, argv=0x7fffffffe418, envp=0x7fffffffe490) at vl.c:4542
+ */
 static int device_init_func(void *opaque, QemuOpts *opts, Error **errp)
 {
     Error *err = NULL;
@@ -2555,6 +2587,10 @@ static gint machine_class_cmp(gconstpointer a, gconstpointer b)
                   object_class_get_name(OBJECT_CLASS(mc1)));
 }
 
+/*
+ * called by:
+ *   - vl.c|2685| <<select_machine>> machine_class = machine_parse(optarg);
+ */
  static MachineClass *machine_parse(const char *name)
 {
     MachineClass *mc = NULL;
@@ -2624,15 +2660,22 @@ static void qemu_run_machine_init_done_notifiers(void)
     notifier_list_notify(&machine_init_done_notifiers, NULL);
 }
 
+/*
+ * 两次被main()调用
+ */
 static const QEMUOption *lookup_opt(int argc, char **argv,
                                     const char **poptarg, int *poptind)
 {
+    /*
+     * 此时argv[optind][0]是"-"
+     */
     const QEMUOption *popt;
     int optind = *poptind;
     char *r = argv[optind];
     const char *optarg;
 
     loc_set_cmdline(argv, optind, 1);
+    /* 如果没参数, 加完了就指向下一个了 */
     optind++;
     /* Treat --foo the same as -foo.  */
     if (r[1] == '-')
@@ -2643,6 +2686,7 @@ static const QEMUOption *lookup_opt(int argc, char **argv,
             error_report("invalid option");
             exit(1);
         }
+	/* 比较'-'后面的部分是否和参数的名字相同 */
         if (!strcmp(popt->name, r + 1))
             break;
         popt++;
@@ -2664,6 +2708,9 @@ static const QEMUOption *lookup_opt(int argc, char **argv,
     return popt;
 }
 
+/*
+ * 被vl.c的main()调用
+ */
 static MachineClass *select_machine(void)
 {
     MachineClass *machine_class = find_default_machine();
@@ -2788,6 +2835,7 @@ static void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size,
 {
     uint64_t sz;
     const char *mem_str;
+    /* hw/core/machine.c|547| <<machine_class_init>> mc->default_ram_size = 128 * MiB; */
     const ram_addr_t default_ram_size = mc->default_ram_size;
     QemuOpts *opts = qemu_find_opts_singleton("memory");
     Location loc;
@@ -3021,12 +3069,13 @@ int main(int argc, char **argv, char **envp)
     optind = 1;
     while (optind < argc) {
         if (argv[optind][0] != '-') {
+            /* 如果开头不是'-'直接跳过 */
             /* disk image */
             optind++;
         } else {
             const QEMUOption *popt;
 
-            popt = lookup_opt(argc, argv, &optarg, &optind);
+            popt = lookup_opt(argc, argv, &optarg, &optind);      // ----> 第一轮
             switch (popt->index) {
             case QEMU_OPTION_nodefconfig:
             case QEMU_OPTION_nouserconfig:
@@ -3043,16 +3092,26 @@ int main(int argc, char **argv, char **envp)
     }
 
     /* second pass of option parsing */
+    /*
+     * 这一遍才是正式的!!!
+     */
     optind = 1;
     for(;;) {
         if (optind >= argc)
             break;
         if (argv[optind][0] != '-') {
+            /* 如果开头不是'-' */
             drive_add(IF_DEFAULT, 0, argv[optind++], HD_OPTS);
         } else {
             const QEMUOption *popt;
 
-            popt = lookup_opt(argc, argv, &optarg, &optind);
+	    /*
+	     * popt是返回的QEMUOption, 里面有index表明这代表的'-'后面的意义
+	     * optarg是返回的字符串参数内容
+	     *
+	     * 此时optind指向下一个
+	     */
+            popt = lookup_opt(argc, argv, &optarg, &optind);      // ----> 第二轮
             if (!(popt->arch_mask & arch_type)) {
                 error_report("Option not supported for this target");
                 exit(1);
@@ -3245,6 +3304,9 @@ int main(int argc, char **argv, char **envp)
                 exit(0);
                 break;
             case QEMU_OPTION_m:
+		/*
+		 * qemu_find_opts(): 从vm_config_groups(QemuOptsList)列表中寻找name是参数"memory"的, 并返回qemu_mem_opts
+		 */
                 opts = qemu_opts_parse_noisily(qemu_find_opts("memory"),
                                                optarg, true);
                 if (!opts) {
@@ -4026,11 +4088,29 @@ int main(int argc, char **argv, char **envp)
     }
 #endif
 
+    /*
+     * object_class_get_name()返回的一个例子是: pc-i440fx-3.0-machine
+     */
     current_machine = MACHINE(object_new(object_class_get_name(
                           OBJECT_CLASS(machine_class))));
     if (machine_help_func(qemu_get_machine_opts(), current_machine)) {
         exit(0);
     }
+    /*
+     * 把child设置成一个obj的ObjectProperty
+     * 在Object->properties (GHashTable)的name就是参数的name, type是"child<child的type>"
+     * ObjectProperty的opaque是child
+     * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+     *
+     *
+     * 应该是在这里初始化的"/machine"
+     * 在这个例子中, machine是name, child<pc-i440fx-3.0-machine>是type
+     *    (qemu) qom-list /
+     *    machine (child<pc-i440fx-3.0-machine>)
+     *    type (string)
+     *    chardevs (child<container>)
+     *    backend (child<container>)
+     */
     object_property_add_child(object_get_root(), "machine",
                               OBJECT(current_machine), &error_abort);
 
-- 
2.7.4

