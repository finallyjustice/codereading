From 9f2fbc741b27051d151574b98c369d788d0f104f Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang@oracle.com>
Date: Mon, 15 Oct 2018 06:04:24 +0800
Subject: [PATCH 1/1] qemu for 3.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-all.c          |   18 +-
 exec.c                       |    4 +
 hmp.c                        |    7 +
 hw/block/nvme.               |    0
 hw/block/nvme.c              |   20 +
 hw/core/bus.c                |   62 ++
 hw/core/machine.c            |   69 ++-
 hw/core/qdev-fw.c            |   13 +
 hw/core/qdev-properties.c    |    6 +
 hw/core/qdev.c               |  120 ++++
 hw/core/reset.c              |   41 ++
 hw/i386/pc.c                 |   51 ++
 hw/i386/pc_piix.c            |   44 ++
 hw/i386/pc_q35.c             |   24 +
 hw/i386/x86-iommu.c          |    6 +
 hw/pci/msix.c                |   15 +
 hw/pci/pci.c                 |  117 ++++
 hw/virtio/virtio-balloon.c   |    6 +
 include/exec/memory.h        |    4 +
 include/hw/boards.h          |    9 +
 include/hw/i386/pc.h         |   20 +-
 include/hw/pci/pci.h         |    8 +
 include/hw/pci/pci_bus.h     |    1 +
 include/hw/qdev-core.h       |   10 +
 include/hw/qdev-properties.h |   15 +
 include/qapi/qmp/qobject.h   |    3 +
 include/qemu/module.h        |   14 +
 include/qom/object.h         |   48 +-
 include/sysemu/accel.h       |    1 +
 include/sysemu/iothread.h    |    1 +
 include/sysemu/kvm_int.h     |    1 +
 linux-headers/linux/kvm.h    |    4 +
 memory.c                     |   83 +++
 qapi/qobject-input-visitor.c |   10 +
 qdev-monitor.c               |    6 +
 qom/object.c                 | 1276 +++++++++++++++++++++++++++++++++++++++++-
 qom/object_interfaces.c      |    3 +
 qom/qom-qobject.c            |   34 ++
 target/i386/kvm.c            |    4 +
 util/module.c                |   59 +-
 vl.c                         |   15 +
 41 files changed, 2243 insertions(+), 9 deletions(-)
 create mode 100644 hw/block/nvme.

diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index eb7db92..8ef7b78 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -1479,6 +1479,10 @@ bool kvm_vcpu_id_is_valid(int vcpu_id)
     return vcpu_id >= 0 && vcpu_id < kvm_max_vcpu_id(s);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2544| <<kvm_accel_class_init>> ac->init_machine = kvm_init;
+ */
 static int kvm_init(MachineState *ms)
 {
     MachineClass *mc = MACHINE_GET_CLASS(ms);
@@ -2537,6 +2541,9 @@ int kvm_get_one_reg(CPUState *cs, uint64_t id, void *target)
     return r;
 }
 
+/*
+ * TypeInfo kvm_accel_type.class_init = kvm_accel_class_init()
+ */
 static void kvm_accel_class_init(ObjectClass *oc, void *data)
 {
     AccelClass *ac = ACCEL_CLASS(oc);
@@ -2547,11 +2554,20 @@ static void kvm_accel_class_init(ObjectClass *oc, void *data)
 
 static const TypeInfo kvm_accel_type = {
     .name = TYPE_KVM_ACCEL,
-    .parent = TYPE_ACCEL,
+    .parent = TYPE_ACCEL,  // accel_type: class_size是AccelClass, instance_size是AccelState
     .class_init = kvm_accel_class_init,
     .instance_size = sizeof(KVMState),
 };
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
 static void kvm_type_init(void)
 {
     type_register_static(&kvm_accel_type);
diff --git a/exec.c b/exec.c
index 4f5df07..526b7b8 100644
--- a/exec.c
+++ b/exec.c
@@ -3093,6 +3093,10 @@ static void tcg_commit(MemoryListener *listener)
     tlb_flush(cpuas->cpu);
 }
 
+/*
+ * called only by:
+ *   - exec.c|3534| <<cpu_exec_init_all>> memory_map_init();
+ */
 static void memory_map_init(void)
 {
     system_memory = g_malloc(sizeof(*system_memory));
diff --git a/hmp.c b/hmp.c
index 2aafb50..2a2f4d0 100644
--- a/hmp.c
+++ b/hmp.c
@@ -2548,6 +2548,13 @@ void hmp_info_iothreads(Monitor *mon, const QDict *qdict)
     qapi_free_IOThreadInfoList(info_list);
 }
 
+/*
+ * (qemu) qom-list /
+ * machine (child<pc-i440fx-3.0-machine>)
+ * type (string)
+ * chardevs (child<container>)
+ * backend (child<container>)
+ */
 void hmp_qom_list(Monitor *mon, const QDict *qdict)
 {
     const char *path = qdict_get_try_str(qdict, "path");
diff --git a/hw/block/nvme. b/hw/block/nvme.
new file mode 100644
index 0000000..e69de29
diff --git a/hw/block/nvme.c b/hw/block/nvme.c
index 5e508ab..c44767b 100644
--- a/hw/block/nvme.c
+++ b/hw/block/nvme.c
@@ -1339,6 +1339,9 @@ static void nvme_exit(PCIDevice *pci_dev)
     msix_uninit_exclusive_bar(pci_dev);
 }
 
+/*
+ * 猜测props是用device_initfn()
+ */
 static Property nvme_props[] = {
     DEFINE_BLOCK_PROPERTIES(NvmeCtrl, conf),
     DEFINE_PROP_STRING("serial", NvmeCtrl, serial),
@@ -1352,6 +1355,12 @@ static const VMStateDescription nvme_vmstate = {
     .unmigratable = 1,
 };
 
+/*
+ * TypeInfo nvme_info.class_init = nvme_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void nvme_class_init(ObjectClass *oc, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(oc);
@@ -1370,6 +1379,12 @@ static void nvme_class_init(ObjectClass *oc, void *data)
     dc->vmsd = &nvme_vmstate;
 }
 
+/*
+ * TypeInfo nvme_info.instance_init = nvme_instance_init()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void nvme_instance_init(Object *obj)
 {
     NvmeCtrl *s = NVME(obj);
@@ -1393,7 +1408,12 @@ static const TypeInfo nvme_info = {
 
 static void nvme_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&nvme_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(nvme_register_types)
diff --git a/hw/core/bus.c b/hw/core/bus.c
index 4651f24..8f3d457 100644
--- a/hw/core/bus.c
+++ b/hw/core/bus.c
@@ -40,6 +40,12 @@ void qbus_set_bus_hotplug_handler(BusState *bus, Error **errp)
     qbus_set_hotplug_handler_internal(bus, OBJECT(bus), errp);
 }
 
+/*
+ * x86会用到的:
+ *   - hw/core/qdev.c|202| <<device_listener_register>> qbus_walk_children(sysbus_get_default(), NULL, NULL, device_listener_add,
+ *   - hw/core/qdev.c|276| <<qbus_reset_all>> qbus_walk_children(bus, NULL, NULL, qdev_reset_one, qbus_reset_one, NULL);
+ *   - hw/core/qdev.c|559| <<qdev_walk_children>> err = qbus_walk_children(bus, pre_devfn, pre_busfn,
+ */
 int qbus_walk_children(BusState *bus,
                        qdev_walkerfn *pre_devfn, qbus_walkerfn *pre_busfn,
                        qdev_walkerfn *post_devfn, qbus_walkerfn *post_busfn,
@@ -74,6 +80,11 @@ int qbus_walk_children(BusState *bus,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/core/bus.c|136| <<qbus_create_inplace>> qbus_realize(bus, parent, name);
+ *   - hw/core/bus.c|144| <<qbus_create>> qbus_realize(bus, parent, name);
+ */
 static void qbus_realize(BusState *bus, DeviceState *parent, const char *name)
 {
     const char *typename = object_get_typename(OBJECT(bus));
@@ -136,10 +147,27 @@ void qbus_create_inplace(void *bus, size_t size, const char *typename,
     qbus_realize(bus, parent, name);
 }
 
+/*
+ * called by:
+ *   - hw/i2c/core.c|59| <<i2c_init_bus>> bus = I2C_BUS(qbus_create(TYPE_I2C_BUS, parent, name));
+ *   - hw/isa/isa-bus.c|66| <<isa_bus_new>> isabus = ISA_BUS(qbus_create(TYPE_ISA_BUS, dev, NULL));
+ *   - hw/misc/auxbus.c|69| <<aux_init_bus>> bus = AUX_BUS(qbus_create(TYPE_AUX_BUS, parent, name));
+ *   - hw/pci/pci.c|410| <<pci_root_bus_new>> bus = PCI_BUS(qbus_create(typename, parent, name));
+ *   - hw/ppc/spapr_vio.c|558| <<spapr_vio_bus_init>> qbus = qbus_create(TYPE_SPAPR_VIO_BUS, dev, "spapr-vio");
+ *   - hw/s390x/css-bridge.c|107| <<virtual_css_bus_init>> bus = qbus_create(TYPE_VIRTUAL_CSS_BUS, dev, "virtual-css");
+ *   - hw/s390x/s390-pci-bus.c|714| <<s390_pcihost_init>> s->bus = S390_PCI_BUS(qbus_create(TYPE_S390_PCI_BUS, DEVICE(s), NULL));
+ *   - hw/ssi/ssi.c|106| <<ssi_create_bus>> bus = qbus_create(TYPE_SSI_BUS, parent, name);
+ *   - hw/xen/xen_backend.c|700| <<xen_be_init>> xen_sysbus = qbus_create(TYPE_XENSYSBUS, DEVICE(xen_sysdev), "xen-sysbus");
+ */
 BusState *qbus_create(const char *typename, DeviceState *parent, const char *name)
 {
     BusState *bus;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     bus = BUS(object_new(typename));
     qbus_realize(bus, parent, name);
 
@@ -188,6 +216,9 @@ static void bus_set_realized(Object *obj, bool value, Error **errp)
     bus->realized = value;
 }
 
+/*
+ * TypeInfo bus_info.instance_init = qbus_initfn()
+ */
 static void qbus_initfn(Object *obj)
 {
     BusState *bus = BUS(obj);
@@ -208,14 +239,24 @@ static char *default_bus_get_fw_dev_path(DeviceState *dev)
     return g_strdup(object_get_typename(OBJECT(dev)));
 }
 
+/*
+ * TypeInfo bus_info.class_init = bus_class_init()
+ */
 static void bus_class_init(ObjectClass *class, void *data)
 {
     BusClass *bc = BUS_CLASS(class);
 
+    /*
+     * Called when an object is being removed from the QOM composition tree.
+     * The function should remove any backlinks from children objects to @obj.
+     */
     class->unparent = bus_unparent;
     bc->get_fw_dev_path = default_bus_get_fw_dev_path;
 }
 
+/*
+ * TypeInfo bus_info.instance_finalize = qbus_finalize()
+ */
 static void qbus_finalize(Object *obj)
 {
     BusState *bus = BUS(obj);
@@ -229,14 +270,35 @@ static const TypeInfo bus_info = {
     .instance_size = sizeof(BusState),
     .abstract = true,
     .class_size = sizeof(BusClass),
+    /*
+     * called only by:
+     *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+     */
     .instance_init = qbus_initfn,
+    /*
+     * called only by:
+     *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+     */
     .instance_finalize = qbus_finalize,
+    /*
+     * called only by:
+     *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+     */
     .class_init = bus_class_init,
 };
 
 static void bus_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&bus_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(bus_register_types)
diff --git a/hw/core/machine.c b/hw/core/machine.c
index a9aeb22..8f0f78c 100644
--- a/hw/core/machine.c
+++ b/hw/core/machine.c
@@ -22,6 +22,11 @@
 #include "qemu/error-report.h"
 #include "sysemu/qtest.h"
 
+/*
+ * used by machine_class_init():
+ *   548     object_class_property_add_str(oc, "accel",
+ *   549         machine_get_accel, machine_set_accel, &error_abort);
+ */
 static char *machine_get_accel(Object *obj, Error **errp)
 {
     MachineState *ms = MACHINE(obj);
@@ -29,6 +34,11 @@ static char *machine_get_accel(Object *obj, Error **errp)
     return g_strdup(ms->accel);
 }
 
+/*
+ * used by machine_class_init():
+ *   548     object_class_property_add_str(oc, "accel",
+ *   549         machine_get_accel, machine_set_accel, &error_abort);
+ */
 static void machine_set_accel(Object *obj, const char *value, Error **errp)
 {
     MachineState *ms = MACHINE(obj);
@@ -37,6 +47,12 @@ static void machine_set_accel(Object *obj, const char *value, Error **errp)
     ms->accel = g_strdup(value);
 }
 
+/*
+ * used by machine_class_init():
+ *   545     object_class_property_add(oc, "kernel-irqchip", "on|off|split",
+ *   546         NULL, machine_set_kernel_irqchip, 
+ *   547         NULL, NULL, &error_abort);
+ */
 static void machine_set_kernel_irqchip(Object *obj, Visitor *v,
                                        const char *name, void *opaque,
                                        Error **errp)
@@ -517,6 +533,12 @@ void machine_set_cpu_numa_node(MachineState *machine,
     }
 }
 
+/*
+ * TypeInfo machine_info.class_init = machine_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
@@ -636,6 +658,12 @@ static void machine_class_init(ObjectClass *oc, void *data)
         "Set memory encyption object to use", &error_abort);
 }
 
+/*
+ * TypeInfo machine_info.class_base_init = machine_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void machine_class_base_init(ObjectClass *oc, void *data)
 {
     if (!object_class_is_abstract(oc)) {
@@ -647,6 +675,12 @@ static void machine_class_base_init(ObjectClass *oc, void *data)
     }
 }
 
+/*
+ * TypeInfo machine_info.instance_init = machine_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+ */
 static void machine_initfn(Object *obj)
 {
     MachineState *ms = MACHINE(obj);
@@ -662,6 +696,12 @@ static void machine_initfn(Object *obj)
     qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);
 }
 
+/*
+ * TypeInfo machine_info.instance_finalize = machine_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void machine_finalize(Object *obj)
 {
     MachineState *ms = MACHINE(obj);
@@ -788,6 +828,10 @@ static void machine_numa_finish_cpu_init(MachineState *machine)
     g_string_free(s, true);
 }
 
+/*
+ * called only by:
+ *   - vl.c|4516| <<main>> machine_run_board_init(current_machine);
+ */
 void machine_run_board_init(MachineState *machine)
 {
     MachineClass *machine_class = MACHINE_GET_CLASS(machine);
@@ -804,6 +848,12 @@ void machine_run_board_init(MachineState *machine)
         int i;
 
         for (i = 0; machine_class->valid_cpu_types[i]; i++) {
+            /*
+	     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+	     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+	     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+	     */
             if (object_class_dynamic_cast(class,
                                           machine_class->valid_cpu_types[i])) {
                 /* The user specificed CPU is in the valid field, we are
@@ -830,6 +880,14 @@ void machine_run_board_init(MachineState *machine)
     machine_class->init(machine);
 }
 
+/*
+ * TypeInfo machine_info.class_finalize = machine_class_finalize()
+ *
+ * 似乎目前不调用:
+ *   - hw/core/machine.c|868| <<global>> .class_finalize = machine_class_finalize,
+ *   - qom/object.c|69| <<global>> void (*class_finalize)(ObjectClass *klass, void *data);
+ *   - qom/object.c|179| <<type_new>> ti->class_finalize = info->class_finalize;
+ */
 static void machine_class_finalize(ObjectClass *klass, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(klass);
@@ -859,7 +917,7 @@ void machine_register_compat_props(MachineState *machine)
 }
 
 static const TypeInfo machine_info = {
-    .name = TYPE_MACHINE,
+    .name = TYPE_MACHINE,  // 还有孩子TYPE_PC_MACHINE
     .parent = TYPE_OBJECT,
     .abstract = true,
     .class_size = sizeof(MachineClass),
@@ -873,7 +931,16 @@ static const TypeInfo machine_info = {
 
 static void machine_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&machine_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(machine_register_types)
diff --git a/hw/core/qdev-fw.c b/hw/core/qdev-fw.c
index aa35e9d..ea88689 100644
--- a/hw/core/qdev-fw.c
+++ b/hw/core/qdev-fw.c
@@ -30,6 +30,10 @@ const char *qdev_fw_name(DeviceState *dev)
     return object_get_typename(OBJECT(dev));
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev-fw.c|72| <<qdev_get_fw_dev_path_helper>> d = bus_get_fw_dev_path(dev->parent_bus, dev);
+ */
 static char *bus_get_fw_dev_path(BusState *bus, DeviceState *dev)
 {
     BusClass *bc = BUS_GET_CLASS(bus);
@@ -60,6 +64,11 @@ char *qdev_get_own_fw_dev_path_from_handler(BusState *bus, DeviceState *dev)
     return fw_path_provider_try_get_dev_path(obj, bus, dev);
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev-fw.c|69| <<qdev_get_fw_dev_path_helper>> l = qdev_get_fw_dev_path_helper(dev->parent_bus->parent, p, size);
+ *   - hw/core/qdev-fw.c|91| <<qdev_get_fw_dev_path>> l = qdev_get_fw_dev_path_helper(dev, path, 128);
+ */
 static int qdev_get_fw_dev_path_helper(DeviceState *dev, char *p, int size)
 {
     int l = 0;
@@ -83,6 +92,10 @@ static int qdev_get_fw_dev_path_helper(DeviceState *dev, char *p, int size)
     return l;
 }
 
+/*
+ * called only by:
+ *   - bootdevice.c|224| <<get_boot_devices_list>> devpath = qdev_get_fw_dev_path(i->dev);
+ */
 char *qdev_get_fw_dev_path(DeviceState *dev)
 {
     char path[128];
diff --git a/hw/core/qdev-properties.c b/hw/core/qdev-properties.c
index 35072de..2aa9744 100644
--- a/hw/core/qdev-properties.c
+++ b/hw/core/qdev-properties.c
@@ -1226,6 +1226,12 @@ int qdev_prop_check_globals(void)
             continue;
         }
         oc = object_class_by_name(prop->driver);
+	/*
+	 * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	 * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+	 * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+	 * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+	 */
         oc = object_class_dynamic_cast(oc, TYPE_DEVICE);
         if (!oc) {
             warn_report("global %s.%s has invalid class name",
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index 529b82d..26abbc8 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -68,6 +68,10 @@ static void bus_remove_child(BusState *bus, DeviceState *child)
     }
 }
 
+/*
+ * called only by:
+ *   - hw/core/qdev.c|107| <<qdev_set_parent_bus>> bus_add_child(bus, dev);
+ */
 static void bus_add_child(BusState *bus, DeviceState *child)
 {
     char name[32];
@@ -89,6 +93,9 @@ static void bus_add_child(BusState *bus, DeviceState *child)
                              NULL);
 }
 
+/*
+ * 被很多很多外部调用
+ */
 void qdev_set_parent_bus(DeviceState *dev, BusState *bus)
 {
     bool replugging = dev->parent_bus != NULL;
@@ -113,6 +120,9 @@ void qdev_set_parent_bus(DeviceState *dev, BusState *bus)
 /* Create a new device.  This only initializes the device state
    structure and allows properties to be set.  The device still needs
    to be realized.  See qdev-core.h.  */
+/*
+ * 被很多很多外部调用
+ */
 DeviceState *qdev_create(BusState *bus, const char *name)
 {
     DeviceState *dev;
@@ -131,13 +141,33 @@ DeviceState *qdev_create(BusState *bus, const char *name)
     return dev;
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev.c|130| <<qdev_create>> dev = qdev_try_create(bus, name);
+ *   - hw/core/sysbus.c|256| <<sysbus_try_create_varargs>> dev = qdev_try_create(NULL, name);
+ *   - hw/i386/pc.c|1591| <<pc_basic_device_init>> hpet = qdev_try_create(NULL, TYPE_HPET);
+ *   - hw/isa/isa-bus.c|170| <<isa_try_create>> dev = qdev_try_create(BUS(bus), name);
+ *   - hw/s390x/s390-pci-bus.c|778| <<s390_pci_device_new>> dev = qdev_try_create(BUS(s->bus), TYPE_S390_PCI_DEVICE);
+ *   - hw/usb/bus.c|336| <<usb_try_create_simple>> dev = USB_DEVICE(qdev_try_create(&bus->qbus, name));
+ */
 DeviceState *qdev_try_create(BusState *bus, const char *type)
 {
     DeviceState *dev;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     if (object_class_by_name(type) == NULL) {
         return NULL;
     }
+    /*
+     * object_new():
+     *       根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     *       确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     *       然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     dev = DEVICE(object_new(type));
     if (!dev) {
         return NULL;
@@ -149,6 +179,12 @@ DeviceState *qdev_try_create(BusState *bus, const char *type)
          * being put onto a bus should be created with object_new(TYPE_FOO),
          * not qdev_create(NULL, TYPE_FOO).
          */
+        /*
+	 * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	 * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+	 * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+	 * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+	 */
         g_assert(object_dynamic_cast(OBJECT(dev), TYPE_SYS_BUS_DEVICE));
         bus = sysbus_get_default();
     }
@@ -540,6 +576,10 @@ BusState *qdev_get_child_bus(DeviceState *dev, const char *name)
     return NULL;
 }
 
+/*
+ * hw/core/bus.c|65| <<qbus_walk_children>> err = qdev_walk_children(kid->child,
+ * hw/core/qdev.c|266| <<qdev_reset_all>> qdev_walk_children(dev, NULL, NULL, qdev_reset_one, qbus_reset_one, NULL);
+ */
 int qdev_walk_children(DeviceState *dev,
                        qdev_walkerfn *pre_devfn, qbus_walkerfn *pre_busfn,
                        qdev_walkerfn *post_devfn, qbus_walkerfn *post_busfn,
@@ -661,6 +701,10 @@ static void qdev_property_add_legacy(DeviceState *dev, Property *prop,
     }
 
     name = g_strdup_printf("legacy-%s", prop->name);
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(OBJECT(dev), name, "str",
                         prop->info->print ? qdev_get_legacy_property : prop->info->get,
                         NULL,
@@ -697,6 +741,10 @@ void qdev_property_add_static(DeviceState *dev, Property *prop,
         if (!prop->info->get && !prop->info->set) {
             return;
         }
+	/*
+	 * 核心思想是分配并初始化一个ObjectProperty
+	 * 然后插入Object->properties (GHashTable)
+	 */
         object_property_add(obj, prop->name, prop->info->name,
                             prop->info->get, prop->info->set,
                             prop->info->release,
@@ -708,6 +756,12 @@ void qdev_property_add_static(DeviceState *dev, Property *prop,
         return;
     }
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     * 最后修改找到的ObjectProperty的description
+     */
     object_property_set_description(obj, prop->name,
                                     prop->info->description,
                                     &error_abort);
@@ -764,6 +818,11 @@ GSList *qdev_build_hotpluggable_device_list(Object *peripheral)
     return list;
 }
 
+/*
+ * 用在device_initfn():
+ * 1025     object_property_add_bool(obj, "realized",
+ * 1026                              device_get_realized, device_set_realized, NULL);
+ */
 static bool device_get_realized(Object *obj, Error **errp)
 {
     DeviceState *dev = DEVICE(obj);
@@ -784,6 +843,10 @@ static bool check_only_migratable(Object *obj, Error **err)
     return true;
 }
 
+/*
+ * used by:
+ *   - hw/core/qdev.c|995| <<device_initfn>> device_get_realized, device_set_realized, NULL);
+ */
 static void device_set_realized(Object *obj, bool value, Error **errp)
 {
     DeviceState *dev = DEVICE(obj);
@@ -937,6 +1000,12 @@ static bool device_get_hotplugged(Object *obj, Error **err)
     return dev->hotplugged;
 }
 
+/*
+ * TypeInfo device_type_info.instance_init = device_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void device_initfn(Object *obj)
 {
     DeviceState *dev = DEVICE(obj);
@@ -951,6 +1020,13 @@ static void device_initfn(Object *obj)
     dev->instance_id_alias = -1;
     dev->realized = false;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     *     get     = property_get_bool()
+     *     set     = property_set_bool()
+     *     release = property_release_bool()
+     */
     object_property_add_bool(obj, "realized",
                              device_get_realized, device_set_realized, NULL);
     object_property_add_bool(obj, "hotpluggable",
@@ -959,12 +1035,20 @@ static void device_initfn(Object *obj)
                              device_get_hotplugged, NULL,
                              &error_abort);
 
+    /*
+     * 返回Object->class
+     */
     class = object_get_class(OBJECT(dev));
     do {
         for (prop = DEVICE_CLASS(class)->props; prop && prop->name; prop++) {
             qdev_property_add_legacy(dev, prop, &error_abort);
             qdev_property_add_static(dev, prop, &error_abort);
         }
+	/*
+	 * 得到TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 * 初始化parent_type(TypeImpl)的class_size, instance_size和class, 还有interface, 调用.class_init()
+	 * 最后返回parent_type(TypeImpl)的class (ObjectClass)
+	 */
         class = object_class_get_parent(class);
     } while (class != object_class_by_name(TYPE_DEVICE));
 
@@ -974,12 +1058,24 @@ static void device_initfn(Object *obj)
     QLIST_INIT(&dev->gpios);
 }
 
+/*
+ * TypeInfo device_type_info.instance_post_init = device_post_init()
+ *
+ * called only by:
+ *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+ */
 static void device_post_init(Object *obj)
 {
     qdev_prop_set_globals(DEVICE(obj));
 }
 
 /* Unlink device from bus and free the structure.  */
+/*
+ * TypeInfo device_type_info.instance_finalize = device_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void device_finalize(Object *obj)
 {
     NamedGPIOList *ngl, *next;
@@ -1009,6 +1105,12 @@ static void device_finalize(Object *obj)
     qemu_opts_del(dev->opts);
 }
 
+/*
+ * TypeInfo device_type_info.class_base_init = device_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void device_class_base_init(ObjectClass *class, void *data)
 {
     DeviceClass *klass = DEVICE_CLASS(class);
@@ -1038,6 +1140,12 @@ static void device_unparent(Object *obj)
     }
 }
 
+/*
+ * TypeInfo device_type_info.class_init = device_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void device_class_init(ObjectClass *class, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(class);
@@ -1092,6 +1200,9 @@ Object *qdev_get_machine(void)
     static Object *dev;
 
     if (dev == NULL) {
+        /*
+	 * object_get_root(): 返回"container"的Object (root), 如果为空先初始化
+	 */
         dev = container_get(object_get_root(), "/machine");
     }
 
@@ -1113,7 +1224,16 @@ static const TypeInfo device_type_info = {
 
 static void qdev_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&device_type_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(qdev_register_types)
diff --git a/hw/core/reset.c b/hw/core/reset.c
index 84c8869..563a36f 100644
--- a/hw/core/reset.c
+++ b/hw/core/reset.c
@@ -35,9 +35,25 @@ typedef struct QEMUResetEntry {
     void *opaque;
 } QEMUResetEntry;
 
+/*
+ * 添加:
+ *   - hw/core/reset.c|47| <<qemu_register_reset>> QTAILQ_INSERT_TAIL(&reset_handlers, re, entry);
+ *
+ * 删除:
+ *   - hw/core/reset.c|56| <<qemu_unregister_reset>> QTAILQ_REMOVE(&reset_handlers, re, entry);
+ *
+ * 使用:
+ *   - hw/core/reset.c|54| <<qemu_unregister_reset>> QTAILQ_FOREACH(re, &reset_handlers, entry) {
+ *   - hw/core/reset.c|68| <<qemu_devices_reset>> QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {
+ */
 static QTAILQ_HEAD(reset_handlers, QEMUResetEntry) reset_handlers =
     QTAILQ_HEAD_INITIALIZER(reset_handlers);
 
+/*
+ * 很多很多外部调用
+ *
+ * 把func(QEMUResetHandler)和opaque初始化成QEMUResetEntry, 插入reset_handlers链表
+ */
 void qemu_register_reset(QEMUResetHandler *func, void *opaque)
 {
     QEMUResetEntry *re = g_malloc0(sizeof(QEMUResetEntry));
@@ -47,6 +63,23 @@ void qemu_register_reset(QEMUResetHandler *func, void *opaque)
     QTAILQ_INSERT_TAIL(&reset_handlers, re, entry);
 }
 
+/*
+ * bootdevice.c|115| <<restore_boot_order>> qemu_unregister_reset(restore_boot_order, normal_boot_order);
+ * hw/char/serial.c|959| <<serial_exit_core>> qemu_unregister_reset(serial_reset, s);
+ * hw/core/bus.c|139| <<bus_unparent>> qemu_unregister_reset(qbus_reset_all_fn, bus);
+ * hw/core/generic-loader.c|175| <<generic_loader_unrealize>> qemu_unregister_reset(generic_loader_reset, dev);
+ * hw/i386/pc.c|438| <<pc_cmos_init_late>> qemu_unregister_reset(pc_cmos_init_late, opaque);
+ * hw/intc/xics.c|364| <<icp_unrealize>> qemu_unregister_reset(icp_reset_handler, dev);
+ * hw/ppc/pnv_core.c|192| <<pnv_unrealize_vcpu>> qemu_unregister_reset(pnv_cpu_reset, cpu);
+ * hw/ppc/spapr_cpu_core.c|118| <<spapr_unrealize_vcpu>> qemu_unregister_reset(spapr_cpu_reset, cpu);
+ * hw/ppc/spapr_cpu_core.c|239| <<spapr_realize_vcpu>> qemu_unregister_reset(spapr_cpu_reset, cpu);
+ * hw/ppc/spapr_drc.c|641| <<unrealize_physical>> qemu_unregister_reset(drc_physical_reset, drcp);
+ * hw/vfio/common.c|1363| <<vfio_put_group>> qemu_unregister_reset(vfio_reset_handler, NULL);
+ * target/i386/cpu.c|5040| <<x86_cpu_unrealizefn>> qemu_unregister_reset(x86_cpu_machine_reset_cb, dev);
+ * target/s390x/cpu.c|303| <<s390_cpu_finalize>> qemu_unregister_reset(s390_cpu_machine_reset_cb, cpu);
+ *
+ * 根据func(QEMUResetHandler)和opaque在链表reset_handlers中寻找QEMUResetEntry并删掉
+ */
 void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
 {
     QEMUResetEntry *re;
@@ -60,6 +93,14 @@ void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
     }
 }
 
+/*
+ * hw/hppa/machine.c|245| <<hppa_machine_reset>> qemu_devices_reset();
+ * hw/i386/pc.c|2282| <<pc_machine_reset>> qemu_devices_reset();
+ * hw/ppc/pnv.c|504| <<pnv_reset>> qemu_devices_reset();
+ * hw/ppc/spapr.c|1639| <<spapr_machine_reset>> qemu_devices_reset();
+ * hw/s390x/s390-virtio-ccw.c|355| <<s390_machine_reset>> qemu_devices_reset();
+ * vl.c|1647| <<qemu_system_reset>> qemu_devices_reset();
+ */
 void qemu_devices_reset(void)
 {
     QEMUResetEntry *re, *nre;
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 83a4444..dfa9a33 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1633,6 +1633,11 @@ void pc_basic_device_init(ISABus *isa_bus, qemu_irq *gsi,
     pc_superio_init(isa_bus, create_fdctrl, no_vmport);
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|244| <<pc_init1>> pc_nic_init(pcmc, isa_bus, pci_bus);
+ *   - hw/i386/pc_q35.c|277| <<pc_q35_init>> pc_nic_init(pcmc, isa_bus, host_bus);
+ */
 void pc_nic_init(PCMachineClass *pcmc, ISABus *isa_bus, PCIBus *pci_bus)
 {
     int i;
@@ -2258,6 +2263,12 @@ static void pc_machine_set_pit(Object *obj, bool value, Error **errp)
     pcms->pit = value;
 }
 
+/*
+ * TypeInfo pc_machine_info.instance_init = pc_machine_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void pc_machine_initfn(Object *obj)
 {
     PCMachineState *pcms = PC_MACHINE(obj);
@@ -2274,6 +2285,9 @@ static void pc_machine_initfn(Object *obj)
     pcms->pit = true;
 }
 
+/*
+ * 在pc_machine_class_init设置成了MachineClass mc的reset
+ */
 static void pc_machine_reset(void)
 {
     CPUState *cs;
@@ -2363,6 +2377,12 @@ static void x86_nmi(NMIState *n, int cpu_index, Error **errp)
     }
 }
 
+/*
+ * TypeInfo pc_machine_info.class_init = pc_machine_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void pc_machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
@@ -2443,6 +2463,28 @@ static void pc_machine_class_init(ObjectClass *oc, void *data)
         pc_machine_get_pit, pc_machine_set_pit, &error_abort);
 }
 
+/*
+ * TYPE_PC_MACHINE is used by:
+ *   - hw/i386/x86-iommu.c|88| <<x86_iommu_realize>> PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));
+ *   - include/hw/i386/pc.h|142| <<PC_MACHINE>> OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|144| <<PC_MACHINE_GET_CLASS>> OBJECT_GET_CLASS(PCMachineClass, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|146| <<PC_MACHINE_CLASS>> OBJECT_CLASS_CHECK(PCMachineClass, (klass), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|954| <<DEFINE_PC_MACHINE>> .parent = TYPE_PC_MACHINE, \
+ *   - target/i386/kvm.c|1455| <<kvm_arch_init>> object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE) &&
+ *
+ *
+ * DEFINE_PC_MACHINE() is called by (i440x, q35, xenfv, isapc):
+ *   - hw/i386/pc_piix.c|1136| <<global>> DEFINE_PC_MACHINE(isapc, "isapc", pc_init_isa,
+ *   - hw/i386/pc_piix.c|1148| <<global>> DEFINE_PC_MACHINE(xenfv, "xenfv", pc_xen_hvm_init,
+ *   - hw/i386/pc_piix.c|417| <<DEFINE_I440FX_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *   - hw/i386/pc_q35.c|294| <<DEFINE_Q35_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *
+ * i440x: pc_init1()
+ * q35  : pc_q35_init()
+ *
+ * QEMU的默认是i440x
+ */
+
 static const TypeInfo pc_machine_info = {
     .name = TYPE_PC_MACHINE,
     .parent = TYPE_MACHINE,
@@ -2460,7 +2502,16 @@ static const TypeInfo pc_machine_info = {
 
 static void pc_machine_register_types(void)
 {
+    /*  
+     * 被外部好多好多调用
+     *
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&pc_machine_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(pc_machine_register_types)
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index dc09466..928505b 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -66,6 +66,19 @@ static const int ide_iobase2[MAX_IDE_BUS] = { 0x3f6, 0x376 };
 static const int ide_irq[MAX_IDE_BUS] = { 14, 15 };
 
 /* PC hardware initialisation */
+/*
+ * called or used by:
+ *   - hw/i386/pc_piix.c|379| <<pc_init_isa>> pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, TYPE_I440FX_PCI_DEVICE);
+ *   - hw/i386/pc_piix.c|388| <<pc_xen_hvm_init_pci>> pc_init1(machine,
+ *   - hw/i386/pc_piix.c|445| <<DEFINE_I440FX_MACHINE>> pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, \
+ *
+ * 一个例子:
+ * (gdb) bt
+ * #0  pc_init1 (machine=0x55555684f480, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:71
+ * #1  0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f480) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #2  0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f480) at hw/core/machine.c:830
+ * #3  0x00005555559dfb8f in main (argc=10, argv=0x7fffffffe498, envp=0x7fffffffe4f0) at vl.c:4516
+ */
 static void pc_init1(MachineState *machine,
                      const char *host_type, const char *pci_type)
 {
@@ -404,6 +417,37 @@ static void pc_xen_hvm_init(MachineState *machine)
 }
 #endif
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|438| <<global>> DEFINE_I440FX_MACHINE(v3_0, "pc-i440fx-3.0", NULL,
+ *   - hw/i386/pc_piix.c|449| <<global>> DEFINE_I440FX_MACHINE(v2_12, "pc-i440fx-2.12", NULL,
+ *   - hw/i386/pc_piix.c|458| <<global>> DEFINE_I440FX_MACHINE(v2_11, "pc-i440fx-2.11", NULL,
+ *   - hw/i386/pc_piix.c|468| <<global>> DEFINE_I440FX_MACHINE(v2_10, "pc-i440fx-2.10", NULL,
+ *   - hw/i386/pc_piix.c|478| <<global>> DEFINE_I440FX_MACHINE(v2_9, "pc-i440fx-2.9", NULL,
+ *   - hw/i386/pc_piix.c|487| <<global>> DEFINE_I440FX_MACHINE(v2_8, "pc-i440fx-2.8", NULL,
+ *   - hw/i386/pc_piix.c|497| <<global>> DEFINE_I440FX_MACHINE(v2_7, "pc-i440fx-2.7", NULL,
+ *   - hw/i386/pc_piix.c|510| <<global>> DEFINE_I440FX_MACHINE(v2_6, "pc-i440fx-2.6", NULL,
+ *   - hw/i386/pc_piix.c|523| <<global>> DEFINE_I440FX_MACHINE(v2_5, "pc-i440fx-2.5", NULL,
+ *   - hw/i386/pc_piix.c|536| <<global>> DEFINE_I440FX_MACHINE(v2_4, "pc-i440fx-2.4", NULL,
+ *   - hw/i386/pc_piix.c|547| <<global>> DEFINE_I440FX_MACHINE(v2_3, "pc-i440fx-2.3", pc_compat_2_3,
+ *   - hw/i386/pc_piix.c|560| <<global>> DEFINE_I440FX_MACHINE(v2_2, "pc-i440fx-2.2", pc_compat_2_2,
+ *   - hw/i386/pc_piix.c|575| <<global>> DEFINE_I440FX_MACHINE(v2_1, "pc-i440fx-2.1", pc_compat_2_1,
+ *   - hw/i386/pc_piix.c|608| <<global>> DEFINE_I440FX_MACHINE(v2_0, "pc-i440fx-2.0", pc_compat_2_0,
+ *   - hw/i386/pc_piix.c|625| <<global>> DEFINE_I440FX_MACHINE(v1_7, "pc-i440fx-1.7", pc_compat_1_7,
+ *   - hw/i386/pc_piix.c|639| <<global>> DEFINE_I440FX_MACHINE(v1_6, "pc-i440fx-1.6", pc_compat_1_6,
+ *   - hw/i386/pc_piix.c|650| <<global>> DEFINE_I440FX_MACHINE(v1_5, "pc-i440fx-1.5", pc_compat_1_5,
+ *   - hw/i386/pc_piix.c|662| <<global>> DEFINE_I440FX_MACHINE(v1_4, "pc-i440fx-1.4", pc_compat_1_4,
+ *   - hw/i386/pc_piix.c|694| <<global>> DEFINE_I440FX_MACHINE(v1_3, "pc-1.3", pc_compat_1_3,
+ *   - hw/i386/pc_piix.c|733| <<global>> DEFINE_I440FX_MACHINE(v1_2, "pc-1.2", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|776| <<global>> DEFINE_I440FX_MACHINE(v1_1, "pc-1.1", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|807| <<global>> DEFINE_I440FX_MACHINE(v1_0, "pc-1.0", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|821| <<global>> DEFINE_I440FX_MACHINE(v0_15, "pc-0.15", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|860| <<global>> DEFINE_I440FX_MACHINE(v0_14, "pc-0.14", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|897| <<global>> DEFINE_I440FX_MACHINE(v0_13, "pc-0.13", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|932| <<global>> DEFINE_I440FX_MACHINE(v0_12, "pc-0.12", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|964| <<global>> DEFINE_I440FX_MACHINE(v0_11, "pc-0.11", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|999| <<global>> DEFINE_I440FX_MACHINE(v0_10, "pc-0.10", pc_compat_0_13,
+ */
 #define DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn) \
     static void pc_init_##suffix(MachineState *machine) \
     { \
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index 532241e..85bc2d2 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -59,6 +59,17 @@
 #define MAX_SATA_PORTS     6
 
 /* PC hardware initialisation */
+/*
+ * called only by:
+ *   - hw/i386/pc_q35.c|305| <<DEFINE_Q35_MACHINE>> pc_q35_init(machine); \
+ *
+ * 一个例子:
+ * (gdb) bt
+ * #0  pc_q35_init (machine=0x55555684f880) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_q35.c:63
+ * #1  0x0000555555921d5e in pc_init_v3_0 (machine=0x55555684f880) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_q35.c:320
+ * #2  0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f880) at hw/core/machine.c:830
+ * #3  0x00005555559dfb8f in main (argc=12, argv=0x7fffffffe478, envp=0x7fffffffe4e0) at vl.c:4516
+ */
 static void pc_q35_init(MachineState *machine)
 {
     PCMachineState *pcms = PC_MACHINE(machine);
@@ -282,6 +293,19 @@ static void pc_q35_init(MachineState *machine)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_q35.c|320| <<global>> DEFINE_Q35_MACHINE(v3_0, "pc-q35-3.0", NULL,
+ *   - hw/i386/pc_q35.c|330| <<global>> DEFINE_Q35_MACHINE(v2_12, "pc-q35-2.12", NULL,
+ *   - hw/i386/pc_q35.c|342| <<global>> DEFINE_Q35_MACHINE(v2_11, "pc-q35-2.11", NULL,
+ *   - hw/i386/pc_q35.c|353| <<global>> DEFINE_Q35_MACHINE(v2_10, "pc-q35-2.10", NULL,
+ *   - hw/i386/pc_q35.c|362| <<global>> DEFINE_Q35_MACHINE(v2_9, "pc-q35-2.9", NULL,
+ *   - hw/i386/pc_q35.c|371| <<global>> DEFINE_Q35_MACHINE(v2_8, "pc-q35-2.8", NULL,
+ *   - hw/i386/pc_q35.c|381| <<global>> DEFINE_Q35_MACHINE(v2_7, "pc-q35-2.7", NULL,
+ *   - hw/i386/pc_q35.c|393| <<global>> DEFINE_Q35_MACHINE(v2_6, "pc-q35-2.6", NULL,
+ *   - hw/i386/pc_q35.c|405| <<global>> DEFINE_Q35_MACHINE(v2_5, "pc-q35-2.5", NULL,
+ *   - hw/i386/pc_q35.c|417| <<global>> DEFINE_Q35_MACHINE(v2_4, "pc-q35-2.4", NULL,
+ */
 #define DEFINE_Q35_MACHINE(suffix, name, compatfn, optionfn) \
     static void pc_init_##suffix(MachineState *machine) \
     { \
diff --git a/hw/i386/x86-iommu.c b/hw/i386/x86-iommu.c
index 8a01a2d..f86fb51 100644
--- a/hw/i386/x86-iommu.c
+++ b/hw/i386/x86-iommu.c
@@ -84,6 +84,12 @@ static void x86_iommu_realize(DeviceState *dev, Error **errp)
     X86IOMMUClass *x86_class = X86_IOMMU_GET_CLASS(dev);
     MachineState *ms = MACHINE(qdev_get_machine());
     MachineClass *mc = MACHINE_GET_CLASS(ms);
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     PCMachineState *pcms =
         PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));
     QLIST_INIT(&x86_iommu->iec_notifiers);
diff --git a/hw/pci/msix.c b/hw/pci/msix.c
index c944c02..1682e28 100644
--- a/hw/pci/msix.c
+++ b/hw/pci/msix.c
@@ -142,6 +142,10 @@ static void msix_update_function_masked(PCIDevice *dev)
 }
 
 /* Handle MSI-X capability config write. */
+/*
+ * called by:
+ *   - hw/pci/pci.c|1405| <<pci_default_write_config>> msix_write_config(d, addr, val_in, l);
+ */
 void msix_write_config(PCIDevice *dev, uint32_t addr,
                        uint32_t val, int len)
 {
@@ -266,6 +270,17 @@ static void msix_mask_all(struct PCIDevice *dev, unsigned nentries)
  * also means a programming error, except device assignment, which can check
  * if a real HW is broken.
  */
+/*
+ * called by:
+ *   - hw/net/e1000e.c|292| <<e1000e_init_msix>> int res = msix_init(PCI_DEVICE(s), E1000E_MSIX_VEC_NUM,
+ *   - hw/net/rocker/rocker.c|1245| <<rocker_msix_init>> err = msix_init(dev, ROCKER_MSIX_VEC_COUNT(r->fp_ports),
+ *   - hw/net/vmxnet3.c|2217| <<vmxnet3_init_msix>> int res = msix_init(d, VMXNET3_MAX_INTRS,
+ *   - hw/pci/msix.c|371| <<msix_init_exclusive_bar>> ret = msix_init(dev, nentries, &dev->msix_exclusive_bar, bar_nr,
+ *   - hw/rdma/vmw/pvrdma_main.c|490| <<init_msix>> rc = msix_init(pdev, RDMA_MAX_INTRS, &dev->msix, RDMA_MSIX_BAR_IDX,
+ *   - hw/scsi/megasas.c|2351| <<megasas_scsi_realize>> msix_init(dev, 15, &s->mmio_io, b->mmio_bar, 0x2000,
+ *   - hw/usb/hcd-xhci.c|3432| <<usb_xhci_realize>> msix_init(dev, xhci->numintrs,
+ *   - hw/vfio/pci.c|1550| <<vfio_msix_setup>> ret = msix_init(&vdev->pdev, vdev->msix->entries,
+ */
 int msix_init(struct PCIDevice *dev, unsigned short nentries,
               MemoryRegion *table_bar, uint8_t table_bar_nr,
               unsigned table_offset, MemoryRegion *pba_bar,
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index 80bc459..bf4c0ba 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -147,6 +147,9 @@ static uint16_t pcibus_numa_node(PCIBus *bus)
     return NUMA_NODE_UNASSIGNED;
 }
 
+/*
+ * TypeInfo pci_bus_info.class_init = pci_bus_class_init()
+ */
 static void pci_bus_class_init(ObjectClass *klass, void *data)
 {
     BusClass *k = BUS_CLASS(klass);
@@ -260,6 +263,11 @@ void pci_device_deassert_intx(PCIDevice *dev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|308| <<pci_device_reset>> pci_do_device_reset(dev);
+ *   - hw/pci/pci.c|323| <<pcibus_reset>> pci_do_device_reset(bus->devices[i]);
+ */
 static void pci_do_device_reset(PCIDevice *dev)
 {
     int r;
@@ -310,6 +318,10 @@ void pci_device_reset(PCIDevice *dev)
  * Called via qbus_reset_all on RST# assert, after the devices
  * have been reset qdev_reset_all-ed already.
  */
+/*
+ * used by:
+ *   - hw/pci/pci.c|163| <<pci_bus_class_init>> k->reset = pcibus_reset; k是BusClass, 在bus_set_realized()被调用
+ */
 static void pcibus_reset(BusState *qbus)
 {
     PCIBus *bus = DO_UPCAST(PCIBus, qbus, qbus);
@@ -846,10 +858,15 @@ static void pci_init_multifunction(PCIBus *bus, PCIDevice *dev, Error **errp)
     }
 }
 
+/*
+ * called by only:
+ *   - hw/pci/pci.c|1037| <<do_pci_register_device>> pci_config_alloc(pci_dev);
+ */
 static void pci_config_alloc(PCIDevice *pci_dev)
 {
     int config_size = pci_config_size(pci_dev);
 
+    /* 下面全都是一个uint8_t的指针 */
     pci_dev->config = g_malloc0(config_size);
     pci_dev->cmask = g_malloc0(config_size);
     pci_dev->wmask = g_malloc0(config_size);
@@ -964,6 +981,10 @@ static bool pci_bus_devfn_reserved(PCIBus *bus, int devfn)
 }
 
 /* -1 for devfn means auto assign */
+/*
+ * called only by:
+ *   - hw/pci/pci.c|2021| <<pci_qdev_realize>> pci_dev = do_pci_register_device(pci_dev,
+ */
 static PCIDevice *do_pci_register_device(PCIDevice *pci_dev,
                                          const char *name, int devfn,
                                          Error **errp)
@@ -1211,11 +1232,21 @@ void pci_unregister_vga(PCIDevice *pci_dev)
     pci_dev->has_vga = false;
 }
 
+/*
+ * called by:
+ *   - hw/display/vmware_vga.c|863| <<vmsvga_value_read>> ret = pci_get_bar_addr(PCI_DEVICE(pci_vmsvga), 1);
+ *   - hw/display/vmware_vga.c|899| <<vmsvga_value_read>> ret = pci_get_bar_addr(PCI_DEVICE(pci_vmsvga), 2);
+ */
 pcibus_t pci_get_bar_addr(PCIDevice *pci_dev, int region_num)
 {
     return pci_dev->io_regions[region_num].addr;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|1313| <<pci_update_mappings>> new_addr = pci_bar_address(d, i, r->type, r->size);
+ *   - hw/pci/pci.c|2624| <<pci_dev_get_w64>> lob = pci_bar_address(dev, i, r->type, r->size);
+ */
 static pcibus_t pci_bar_address(PCIDevice *d,
 				int reg, uint8_t type, pcibus_t size)
 {
@@ -1924,6 +1955,16 @@ static bool pci_root_bus_in_range(PCIBus *bus, int bus_num)
     return false;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|688| <<pci_get_bus_devfn>> return pci_find_bus_nr(root, 0);
+ *   - hw/pci/pci.c|701| <<pci_get_bus_devfn>> return pci_find_bus_nr(root, bus);
+ *   - hw/pci/pci.c|1608| <<pci_for_each_device_reverse>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|1635| <<pci_for_each_device>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|1724| <<qmp_query_pci_bridge>> PCIBus *child_bus = pci_find_bus_nr(bus, dev->config[PCI_SECONDARY_BUS]);
+ *   - hw/pci/pci.c|1805| <<qmp_query_pci_bus>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|2016| <<pci_find_device>> bus = pci_find_bus_nr(bus, bus_num);
+ */
 static PCIBus *pci_find_bus_nr(PCIBus *bus, int bus_num)
 {
     PCIBus *sec;
@@ -1932,6 +1973,10 @@ static PCIBus *pci_find_bus_nr(PCIBus *bus, int bus_num)
         return NULL;
     }
 
+    /*
+     * 如果参数中的bus就是要找的bus number 直接返回
+     * 否则要从child bus中继续找
+     */
     if (pci_bus_num(bus) == bus_num) {
         return bus;
     }
@@ -1992,6 +2037,9 @@ void pci_for_each_bus_depth_first(PCIBus *bus,
 }
 
 
+/*
+ * 被一群外部调用
+ */
 PCIDevice *pci_find_device(PCIBus *bus, int bus_num, uint8_t devfn)
 {
     bus = pci_find_bus_nr(bus, bus_num);
@@ -2002,6 +2050,10 @@ PCIDevice *pci_find_device(PCIBus *bus, int bus_num, uint8_t devfn)
     return bus->devices[devfn];
 }
 
+/*
+ * used by:
+ *   - hw/pci/pci.c|2557| <<pci_device_class_init>> k->realize = pci_qdev_realize;
+ */
 static void pci_qdev_realize(DeviceState *qdev, Error **errp)
 {
     PCIDevice *pci_dev = (PCIDevice *)qdev;
@@ -2013,6 +2065,13 @@ static void pci_qdev_realize(DeviceState *qdev, Error **errp)
     /* initialize cap_present for pci_is_express() and pci_config_size(),
      * Note that hybrid PCIs are not set automatically and need to manage
      * QEMU_PCI_CAP_EXPRESS manually */
+    /*
+     * object_classs_dynamic_cast():
+     *     如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     *     一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     *     否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     *     在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_class_dynamic_cast(klass, INTERFACE_PCIE_DEVICE) &&
        !object_class_dynamic_cast(klass, INTERFACE_CONVENTIONAL_PCI_DEVICE)) {
         pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;
@@ -2048,6 +2107,20 @@ static void pci_qdev_realize(DeviceState *qdev, Error **errp)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci-bridge/dec.c|93| <<pci_dec_21154_init>> dev = pci_create_multifunction(parent_bus, devfn, false,
+ *   - hw/pci-bridge/xio3130_downstream.c|139| <<xio3130_downstream_init>> d = pci_create_multifunction(bus, devfn, multifunction,
+ *   - hw/pci-bridge/xio3130_upstream.c|119| <<xio3130_upstream_init>> d = pci_create_multifunction(bus, devfn, multifunction, "x3130-upstream");
+ *   - hw/pci-host/sabre.c|405| <<sabre_realize>> pci_dev = pci_create_multifunction(phb->bus, PCI_DEVFN(1, 0), true,
+ *   - hw/pci-host/sabre.c|411| <<sabre_realize>> pci_dev = pci_create_multifunction(phb->bus, PCI_DEVFN(1, 1), true,
+ *   - hw/pci/pci.c|2106| <<pci_create_simple_multifunction>> PCIDevice *dev = pci_create_multifunction(bus, devfn, multifunction, name);
+ *   - hw/pci/pci.c|2113| <<pci_create>> return pci_create_multifunction(bus, devfn, false, name);
+ *   - hw/sparc64/sun4u.c|581| <<sun4uv_init>> ebus = pci_create_multifunction(pci_busA, PCI_DEVFN(1, 0), true, TYPE_EBUS);
+ *   - hw/sparc64/sun4u.c|607| <<sun4uv_init>> pci_dev = pci_create_multifunction(pci_busA, PCI_DEVFN(1, 1),
+ *   - hw/usb/hcd-ehci-pci.c|273| <<ehci_create_ich9_with_companions>> ehci = pci_create_multifunction(bus, PCI_DEVFN(slot, 7), true, name);
+ *   - hw/usb/hcd-ehci-pci.c|278| <<ehci_create_ich9_with_companions>> uhci = pci_create_multifunction(bus, PCI_DEVFN(slot, comp[i].func),
+ */
 PCIDevice *pci_create_multifunction(PCIBus *bus, int devfn, bool multifunction,
                                     const char *name)
 {
@@ -2059,6 +2132,18 @@ PCIDevice *pci_create_multifunction(PCIBus *bus, int devfn, bool multifunction,
     return PCI_DEVICE(dev);
 }
 
+/*
+ * called by:
+ *   - hw/i2c/smbus_ich9.c|111| <<ich9_smb_init>> pci_create_simple_multifunction(bus, devfn, true, TYPE_ICH9_SMB_DEVICE);
+ *   - hw/i386/pc_q35.c|191| <<pc_q35_init>> lpc = pci_create_simple_multifunction(host_bus, PCI_DEVFN(ICH9_LPC_DEV,
+ *   - hw/i386/pc_q35.c|247| <<pc_q35_init>> ahci = pci_create_simple_multifunction(host_bus,
+ *   - hw/isa/piix4.c|106| <<piix4_init>> d = pci_create_simple_multifunction(bus, devfn, true, "PIIX4");
+ *   - hw/isa/vt82c686.c|486| <<vt82c686b_isa_init>> d = pci_create_simple_multifunction(bus, devfn, true,
+ *   - hw/mips/boston.c|520| <<boston_mach_init>> ahci = pci_create_simple_multifunction(&PCI_BRIDGE(&pcie2->root)->sec_bus,
+ *   - hw/pci-host/piix.c|415| <<i440fx_init>> PCIDevice *pci_dev = pci_create_simple_multifunction(b,
+ *   - hw/pci-host/piix.c|421| <<i440fx_init>> PCIDevice *pci_dev = pci_create_simple_multifunction(b,
+ *   - hw/pci/pci.c|2135| <<pci_create_simple>> return pci_create_simple_multifunction(bus, devfn, false, name);
+ */
 PCIDevice *pci_create_simple_multifunction(PCIBus *bus, int devfn,
                                            bool multifunction,
                                            const char *name)
@@ -2073,11 +2158,18 @@ PCIDevice *pci_create(PCIBus *bus, int devfn, const char *name)
     return pci_create_multifunction(bus, devfn, false, name);
 }
 
+/*
+ * 被很多外部调用
+ */
 PCIDevice *pci_create_simple(PCIBus *bus, int devfn, const char *name)
 {
     return pci_create_simple_multifunction(bus, devfn, false, name);
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|2297| <<pci_add_capability>> offset = pci_find_space(pdev, size);
+ */
 static uint8_t pci_find_space(PCIDevice *pdev, uint8_t size)
 {
     int offset = PCI_CONFIG_HEADER_SIZE;
@@ -2517,16 +2609,32 @@ MemoryRegion *pci_address_space_io(PCIDevice *dev)
     return pci_get_bus(dev)->address_space_io;
 }
 
+/*
+ * TypeInfo pci_device_type_info.class_init = pci_device_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void pci_device_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *k = DEVICE_CLASS(klass);
 
+    /*
+     * realize is called by:
+     *   - hw/core/qdev.c|860| <<device_set_realized>> dc->realize(dev, &local_err);
+     */
     k->realize = pci_qdev_realize;
     k->unrealize = pci_qdev_unrealize;
     k->bus_type = TYPE_PCI_BUS;
     k->props = pci_props;
 }
 
+/*
+ * TypeInfo pci_device_type_info.class_base_init = pci_device_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void pci_device_class_base_init(ObjectClass *klass, void *data)
 {
     if (!object_class_is_abstract(klass)) {
@@ -2669,6 +2777,11 @@ static const TypeInfo pci_device_type_info = {
 
 static void pci_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&pci_bus_info);
     type_register_static(&pcie_bus_info);
     type_register_static(&conventional_pci_interface_info);
@@ -2676,4 +2789,8 @@ static void pci_register_types(void)
     type_register_static(&pci_device_type_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(pci_register_types)
diff --git a/hw/virtio/virtio-balloon.c b/hw/virtio/virtio-balloon.c
index 1f7a87f..e64942a 100644
--- a/hw/virtio/virtio-balloon.c
+++ b/hw/virtio/virtio-balloon.c
@@ -326,6 +326,12 @@ static int build_dimm_list(Object *obj, void *opaque)
 {
     GSList **list = opaque;
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_dynamic_cast(obj, TYPE_PC_DIMM)) {
         DeviceState *dev = DEVICE(obj);
         if (dev->realized) { /* only realized DIMMs matter */
diff --git a/include/exec/memory.h b/include/exec/memory.h
index 448d41a..d2f9eca 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -32,6 +32,7 @@
 #define MAX_PHYS_ADDR_SPACE_BITS 62
 #define MAX_PHYS_ADDR            (((hwaddr)1 << MAX_PHYS_ADDR_SPACE_BITS) - 1)
 
+/* TypeInfo memory_region_info */
 #define TYPE_MEMORY_REGION "qemu:memory-region"
 #define MEMORY_REGION(obj) \
         OBJECT_CHECK(MemoryRegion, (obj), TYPE_MEMORY_REGION)
@@ -336,6 +337,9 @@ typedef struct IOMMUMemoryRegionClass {
 typedef struct CoalescedMemoryRange CoalescedMemoryRange;
 typedef struct MemoryRegionIoeventfd MemoryRegionIoeventfd;
 
+/*
+ * TYPE_MEMORY_REGION的instance
+ */
 struct MemoryRegion {
     Object parent_obj;
 
diff --git a/include/hw/boards.h b/include/hw/boards.h
index d139a43..cbb20da 100644
--- a/include/hw/boards.h
+++ b/include/hw/boards.h
@@ -48,6 +48,7 @@ void memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner,
  */
 #define MACHINE_TYPE_NAME(machinename) (machinename TYPE_MACHINE_SUFFIX)
 
+/* TypeInfo machine_info */
 #define TYPE_MACHINE "machine"
 #undef MACHINE  /* BSD defines it and QEMU does not use it */
 #define MACHINE(obj) \
@@ -169,7 +170,15 @@ struct MachineClass {
     const char *desc;
     const char *deprecation_reason;
 
+    /*
+     * called by:
+     *   - hw/core/machine.c|870| <<machine_run_board_init>> machine_class->init(machine);
+     */
     void (*init)(MachineState *state);
+    /*
+     * called by:
+     *   - vl.c|1645| <<qemu_system_reset>> mc->reset();
+     */
     void (*reset)(void);
     void (*hot_add_cpu)(const int64_t id, Error **errp);
     int (*kvm_type)(const char *arg);
diff --git a/include/hw/i386/pc.h b/include/hw/i386/pc.h
index 6894f37..6b26809 100644
--- a/include/hw/i386/pc.h
+++ b/include/hw/i386/pc.h
@@ -37,7 +37,7 @@ struct PCMachineState {
     /* Pointers to devices and objects: */
     HotplugHandler *acpi_dev;
     ISADevice *rtc;
-    PCIBus *bus;
+    PCIBus *bus;  // 有pci bus!
     FWCfgState *fw_cfg;
     qemu_irq *gsi;
 
@@ -136,6 +136,16 @@ struct PCMachineClass {
     bool linuxboot_dma_enabled;
 };
 
+/* TypeInfo pc_machine_info */
+/*
+ * TYPE_PC_MACHINE is used by:
+ *   - hw/i386/x86-iommu.c|88| <<x86_iommu_realize>> PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));
+ *   - include/hw/i386/pc.h|142| <<PC_MACHINE>> OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|144| <<PC_MACHINE_GET_CLASS>> OBJECT_GET_CLASS(PCMachineClass, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|146| <<PC_MACHINE_CLASS>> OBJECT_CLASS_CHECK(PCMachineClass, (klass), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|954| <<DEFINE_PC_MACHINE>> .parent = TYPE_PC_MACHINE, \
+ *   - target/i386/kvm.c|1455| <<kvm_arch_init>> object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE) &&
+ */
 #define TYPE_PC_MACHINE "generic-pc-machine"
 #define PC_MACHINE(obj) \
     OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
@@ -249,6 +259,7 @@ struct PCII440FXState;
 typedef struct PCII440FXState PCII440FXState;
 
 #define TYPE_I440FX_PCI_HOST_BRIDGE "i440FX-pcihost"
+/* TypeInfo i440fx_info */
 #define TYPE_I440FX_PCI_DEVICE "i440FX"
 
 #define TYPE_IGD_PASSTHROUGH_I440FX_PCI_DEVICE "igd-passthrough-i440FX"
@@ -941,6 +952,13 @@ bool e820_get_entry(int, uint32_t, uint64_t *, uint64_t *);
         .value = "off",\
     },
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|1136| <<global>> DEFINE_PC_MACHINE(isapc, "isapc", pc_init_isa,
+ *   - hw/i386/pc_piix.c|1148| <<global>> DEFINE_PC_MACHINE(xenfv, "xenfv", pc_xen_hvm_init,
+ *   - hw/i386/pc_piix.c|417| <<DEFINE_I440FX_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *   - hw/i386/pc_q35.c|294| <<DEFINE_Q35_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ */
 #define DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn) \
     static void pc_machine_##suffix##_class_init(ObjectClass *oc, void *data) \
     { \
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 990d6fc..e6362d8 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -191,6 +191,7 @@ enum {
     QEMU_PCIE_EXTCAP_INIT = (1 << QEMU_PCIE_EXTCAP_INIT_BITNR),
 };
 
+/* TypeInfo pci_device_type_info */
 #define TYPE_PCI_DEVICE "pci-device"
 #define PCI_DEVICE(obj) \
      OBJECT_CHECK(PCIDevice, (obj), TYPE_PCI_DEVICE)
@@ -200,6 +201,7 @@ enum {
      OBJECT_GET_CLASS(PCIDeviceClass, (obj), TYPE_PCI_DEVICE)
 
 /* Implemented by devices that can be plugged on PCI Express buses */
+/* TypeInfo pcie_interface_info */
 #define INTERFACE_PCIE_DEVICE "pci-express-device"
 
 /* Implemented by devices that can be plugged on Conventional PCI buses */
@@ -388,10 +390,16 @@ typedef void (*pci_set_irq_fn)(void *opaque, int irq_num, int level);
 typedef int (*pci_map_irq_fn)(PCIDevice *pci_dev, int irq_num);
 typedef PCIINTxRoute (*pci_route_irq_fn)(void *opaque, int pin);
 
+/* TypeInfo pci_bus_info */
 #define TYPE_PCI_BUS "PCI"
 #define PCI_BUS(obj) OBJECT_CHECK(PCIBus, (obj), TYPE_PCI_BUS)
 #define PCI_BUS_CLASS(klass) OBJECT_CLASS_CHECK(PCIBusClass, (klass), TYPE_PCI_BUS)
 #define PCI_BUS_GET_CLASS(obj) OBJECT_GET_CLASS(PCIBusClass, (obj), TYPE_PCI_BUS)
+/*
+ * TypeInfo pcie_bus_info
+ *
+ * TYPE_PCIE_BUS的parent是TYPE_PCI_BUS
+ */
 #define TYPE_PCIE_BUS "PCIE"
 
 bool pci_bus_is_express(PCIBus *bus);
diff --git a/include/hw/pci/pci_bus.h b/include/hw/pci/pci_bus.h
index b7da8f5..72ba5ac 100644
--- a/include/hw/pci/pci_bus.h
+++ b/include/hw/pci/pci_bus.h
@@ -28,6 +28,7 @@ struct PCIBus {
     pci_map_irq_fn map_irq;
     pci_route_irq_fn route_intx_to_irq;
     void *irq_opaque;
+    /* 挂载着这个pci bus的所有device */
     PCIDevice *devices[PCI_SLOT_MAX * PCI_FUNC_MAX];
     PCIDevice *parent_dev;
     MemoryRegion *address_space_mem;
diff --git a/include/hw/qdev-core.h b/include/hw/qdev-core.h
index f1fd0f8..6f8b1f3 100644
--- a/include/hw/qdev-core.h
+++ b/include/hw/qdev-core.h
@@ -11,6 +11,7 @@ enum {
     DEV_NVECTORS_UNSPECIFIED = -1,
 };
 
+/* TypeInfo device_type_info */
 #define TYPE_DEVICE "device"
 #define DEVICE(obj) OBJECT_CHECK(DeviceState, (obj), TYPE_DEVICE)
 #define DEVICE_CLASS(klass) OBJECT_CLASS_CHECK(DeviceClass, (klass), TYPE_DEVICE)
@@ -107,6 +108,10 @@ typedef struct DeviceClass {
 
     /* callbacks */
     DeviceReset reset;
+    /*
+     * called by:
+     *   - hw/core/qdev.c|860| <<device_set_realized>> dc->realize(dev, &local_err);
+     */
     DeviceRealize realize;
     DeviceUnrealize unrealize;
 
@@ -159,6 +164,7 @@ struct DeviceListener {
     QTAILQ_ENTRY(DeviceListener) link;
 };
 
+/* TypeInfo bus_info */
 #define TYPE_BUS "bus"
 #define BUS(obj) OBJECT_CHECK(BusState, (obj), TYPE_BUS)
 #define BUS_CLASS(klass) OBJECT_CLASS_CHECK(BusClass, (klass), TYPE_BUS)
@@ -177,6 +183,10 @@ struct BusClass {
      */
     char *(*get_fw_dev_path)(DeviceState *dev);
     void (*reset)(BusState *bus);
+    /*
+     * called by:
+     *   - hw/core/bus.c|193| <<bus_set_realized>> bc->realize(bus, &local_err);
+     */
     BusRealize realize;
     BusUnrealize unrealize;
 
diff --git a/include/hw/qdev-properties.h b/include/hw/qdev-properties.h
index 4f60cc8..6d678d2 100644
--- a/include/hw/qdev-properties.h
+++ b/include/hw/qdev-properties.h
@@ -70,6 +70,17 @@ extern const PropertyInfo qdev_prop_off_auto_pcibar;
         .defval.u  = (bool)_defval,                              \
         }
 
+/*
+ * 一个例子:
+ *   _name   = "num_queues"
+ *   _state  = NvmeCtrl
+ *   _field  = num_queues
+ *   _defval = 64
+ *   _prop   = qdev_prop_uint32
+ *   _type   = uint32_t
+ *
+ * 定义了一个struct Property
+ */
 #define DEFINE_PROP_UNSIGNED(_name, _state, _field, _defval, _prop, _type) { \
         .name      = (_name),                                           \
         .info      = &(_prop),                                          \
@@ -156,6 +167,10 @@ extern const PropertyInfo qdev_prop_off_auto_pcibar;
     DEFINE_PROP_UNSIGNED(_n, _s, _f, _d, qdev_prop_uint8, uint8_t)
 #define DEFINE_PROP_UINT16(_n, _s, _f, _d)                      \
     DEFINE_PROP_UNSIGNED(_n, _s, _f, _d, qdev_prop_uint16, uint16_t)
+/*
+ * 一个例子:
+ *   DEFINE_PROP_UINT32("num_queues", NvmeCtrl, num_queues, 64),
+ */
 #define DEFINE_PROP_UINT32(_n, _s, _f, _d)                      \
     DEFINE_PROP_UNSIGNED(_n, _s, _f, _d, qdev_prop_uint32, uint32_t)
 #define DEFINE_PROP_INT32(_n, _s, _f, _d)                      \
diff --git a/include/qapi/qmp/qobject.h b/include/qapi/qmp/qobject.h
index fcfd549..5af95ff 100644
--- a/include/qapi/qmp/qobject.h
+++ b/include/qapi/qmp/qobject.h
@@ -41,6 +41,9 @@ struct QObjectBase_ {
 };
 
 /* this struct must have no other members than base */
+/*
+ * 作为root存储在QObjectInputVisitor
+ */
 struct QObject {
     struct QObjectBase_ base;
 };
diff --git a/include/qemu/module.h b/include/qemu/module.h
index 54300ab..54f79db 100644
--- a/include/qemu/module.h
+++ b/include/qemu/module.h
@@ -39,6 +39,16 @@ static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \
 }
 #endif
 
+/*
+ * 所有注册的module_init_type在以下调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * module_call_init()遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
+
 typedef enum {
     MODULE_INIT_BLOCK,
     MODULE_INIT_OPTS,
@@ -49,6 +59,10 @@ typedef enum {
 
 #define block_init(function) module_init(function, MODULE_INIT_BLOCK)
 #define opts_init(function) module_init(function, MODULE_INIT_OPTS)
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 #define type_init(function) module_init(function, MODULE_INIT_QOM)
 #define trace_init(function) module_init(function, MODULE_INIT_TRACE)
 
diff --git a/include/qom/object.h b/include/qom/object.h
index f0b0bf3..cc11938 100644
--- a/include/qom/object.h
+++ b/include/qom/object.h
@@ -17,6 +17,12 @@
 #include "qapi/qapi-builtin-types.h"
 #include "qemu/queue.h"
 
+/*
+ * 核心函数:
+ *   - type_initialize()
+ *   - object_initialize_with_type()
+ */
+
 struct TypeImpl;
 typedef struct TypeImpl *Type;
 
@@ -28,6 +34,7 @@ typedef struct TypeInfo TypeInfo;
 typedef struct InterfaceClass InterfaceClass;
 typedef struct InterfaceInfo InterfaceInfo;
 
+/* TypeInfo object_info */
 #define TYPE_OBJECT "object"
 
 /**
@@ -388,10 +395,28 @@ typedef void (ObjectFree)(void *obj);
  * The base for all classes.  The only thing that #ObjectClass contains is an
  * integer type handle.
  */
+/*
+ * 所有class_size()里的祖先都是ObjectClass
+ *
+ * 关注: type_initialize()
+ */
 struct ObjectClass
 {
     /*< private >*/
-    Type type;
+    Type type;  // 定义typedef struct TypeImpl *Type;
+    /*
+     * 插入新元素的地方:
+     *   - qom/object.c|472| <<type_initialize_interface>> ti->class->interfaces = g_slist_append(ti->class->interfaces,
+     *
+     * 用到的地方:
+     *   - qom/object.c|486| <<type_initialize_interface>> ti->class->interfaces = g_slist_append(ti->class->interfaces,
+     *   - qom/object.c|615| <<type_initialize>> ti->class->interfaces = NULL;
+     *   - qom/object.c|623| <<type_initialize>> for (e = parent->class->interfaces; e; e = e->next) {
+     *   - qom/object.c|646| <<type_initialize>> for (e = ti->class->interfaces; e; e = e->next) {
+     *   - qom/object.c|1199| <<object_class_dynamic_cast>> if (type->class->interfaces &&
+     *   - qom/object.c|1204| <<object_class_dynamic_cast>> for (i = class->interfaces; i; i = i->next) {
+     *   - qom/object.c|1245| <<object_class_dynamic_cast_assert>> if (!class || !class->interfaces) {
+     */
     GSList *interfaces;
 
     const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE];
@@ -399,6 +424,11 @@ struct ObjectClass
 
     ObjectUnparent *unparent;
 
+    /*
+     * 在以下分配:
+     *   - qom/object.c|550| <<type_initialize>> ti->class->properties = g_hash_table_new_full(
+     *   - qom/object.c|586| <<type_initialize>> ti->class->properties = g_hash_table_new_full(
+     */
     GHashTable *properties;
 };
 
@@ -414,11 +444,22 @@ struct ObjectClass
  * first member.  This allows identification of the real type of the object at
  * run time.
  */
+/*
+ * 关注object_initialize_with_type()
+ */
 struct Object
 {
     /*< private >*/
+    /*
+     * 初始化:
+     *   - qom/object.c|665| <<object_initialize_with_type>> obj->class = type->class;
+     */
     ObjectClass *class;
     ObjectFree *free;
+    /*
+     * 在以下初始化:
+     *   - qom/object.c|680| <<object_initialize_with_type>> obj->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
+     */
     GHashTable *properties;
     uint32_t ref;
     Object *parent;
@@ -574,6 +615,7 @@ struct InterfaceClass
     Type interface_type;
 };
 
+/* TypeInfo interface_info */
 #define TYPE_INTERFACE "interface"
 
 /**
@@ -868,6 +910,10 @@ void type_register_static_array(const TypeInfo *infos, int nr_infos);
  * @type_array should be static constant that exists for the life time
  * that the type is registered.
  */
+/*
+ * type_register_static_array()
+ *     为nr_infos个: 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 #define DEFINE_TYPES(type_array)                                            \
 static void do_qemu_init_ ## type_array(void)                               \
 {                                                                           \
diff --git a/include/sysemu/accel.h b/include/sysemu/accel.h
index 637358f..560b596 100644
--- a/include/sysemu/accel.h
+++ b/include/sysemu/accel.h
@@ -52,6 +52,7 @@ typedef struct AccelClass {
     GlobalProperty *global_props;
 } AccelClass;
 
+/* TypeInfo accel_type */
 #define TYPE_ACCEL "accel"
 
 #define ACCEL_CLASS_SUFFIX  "-" TYPE_ACCEL
diff --git a/include/sysemu/iothread.h b/include/sysemu/iothread.h
index 8a7ac2c..137877b 100644
--- a/include/sysemu/iothread.h
+++ b/include/sysemu/iothread.h
@@ -17,6 +17,7 @@
 #include "block/aio.h"
 #include "qemu/thread.h"
 
+/* TypeInfo iothread_info */
 #define TYPE_IOTHREAD "iothread"
 
 typedef struct {
diff --git a/include/sysemu/kvm_int.h b/include/sysemu/kvm_int.h
index f838412..7be68df 100644
--- a/include/sysemu/kvm_int.h
+++ b/include/sysemu/kvm_int.h
@@ -29,6 +29,7 @@ typedef struct KVMMemoryListener {
     int as_id;
 } KVMMemoryListener;
 
+/* TypeInfo kvm_accel_type */
 #define TYPE_KVM_ACCEL ACCEL_CLASS_NAME("kvm")
 
 #define KVM_STATE(obj) \
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 98f389a..b8b9320 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -754,6 +754,10 @@ struct kvm_ppc_resize_hpt {
  * ioctls for /dev/kvm fds:
  */
 #define KVM_GET_API_VERSION       _IO(KVMIO,   0x00)
+/*
+ * x86就用在:
+ *   - accel/kvm/kvm-all.c|1560| <<kvm_init>> ret = kvm_ioctl(s, KVM_CREATE_VM, type);
+ */
 #define KVM_CREATE_VM             _IO(KVMIO,   0x01) /* returns a VM fd */
 #define KVM_GET_MSR_INDEX_LIST    _IOWR(KVMIO, 0x02, struct kvm_msr_list)
 
diff --git a/memory.c b/memory.c
index e9cd446..bbfa6cd 100644
--- a/memory.c
+++ b/memory.c
@@ -40,9 +40,39 @@ static bool memory_region_update_pending;
 static bool ioeventfd_update_pending;
 static bool global_dirty_log = false;
 
+/*
+ * 所有使用的地方:
+ *   - memory.c|2696| <<memory_listener_register>> QTAILQ_INSERT_TAIL(&memory_listeners, listener, link);
+ *   - memory.c|126| <<MEMORY_LISTENER_CALL_GLOBAL>> QTAILQ_FOREACH(_listener, &memory_listeners, link) { \
+ *   - memory.c|133| <<MEMORY_LISTENER_CALL_GLOBAL>> QTAILQ_FOREACH_REVERSE(_listener, &memory_listeners, \
+ *   - memory.c|134| <<MEMORY_LISTENER_CALL_GLOBAL>> memory_listeners, link) { \
+ *   - memory.c|2046| <<memory_region_sync_dirty_bitmap>> QTAILQ_FOREACH(listener, &memory_listeners, link) {
+ *   - memory.c|2693| <<memory_listener_register>> if (QTAILQ_EMPTY(&memory_listeners)
+ *   - memory.c|2694| <<memory_listener_register>> || listener->priority >= QTAILQ_LAST(&memory_listeners,
+ *   - memory.c|2695| <<memory_listener_register>> memory_listeners)->priority) {
+ *   - memory.c|2698| <<memory_listener_register>> QTAILQ_FOREACH(other, &memory_listeners, link) {
+ *   - memory.c|2708| <<memory_listener_register>> memory_listeners)->priority) {
+ *   - memory.c|2729| <<memory_listener_unregister>> QTAILQ_REMOVE(&memory_listeners, listener, link);
+ */
 static QTAILQ_HEAD(memory_listeners, MemoryListener) memory_listeners
     = QTAILQ_HEAD_INITIALIZER(memory_listeners);
 
+/*
+ * 添加:
+ *   - memory.c|2835| <<address_space_init>> QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
+ *
+ * 删除:
+ *   - memory.c|2859| <<address_space_destroy>> QTAILQ_REMOVE(&address_spaces, as, address_spaces_link);
+ *
+ * 使用:
+ *   - memory.c|608| <<memory_region_to_address_space>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|969| <<flatviews_reset>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|1060| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|1068| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|2189| <<memory_region_update_coalesced_range>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|3150| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|3174| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ */
 static QTAILQ_HEAD(, AddressSpace) address_spaces
     = QTAILQ_HEAD_INITIALIZER(address_spaces);
 
@@ -1022,6 +1052,10 @@ static void address_space_set_flatview(AddressSpace *as)
     }
 }
 
+/*
+ * called only by:
+ *   - memory.c|2833| <<address_space_init>> address_space_update_topology(as);
+ */
 static void address_space_update_topology(AddressSpace *as)
 {
     MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
@@ -1112,6 +1146,11 @@ static char *memory_region_escape_name(const char *name)
     return escaped;
 }
 
+/*
+ * called by:
+ *   - memory.c|1158| <<memory_region_init>> memory_region_do_init(mr, owner, name, size);
+ *   - memory.c|1691| <<memory_region_init_iommu>> memory_region_do_init(mr, owner, name, size);
+ */
 static void memory_region_do_init(MemoryRegion *mr,
                                   Object *owner,
                                   const char *name,
@@ -1140,11 +1179,20 @@ static void memory_region_do_init(MemoryRegion *mr,
     }
 }
 
+/*
+ * 被非常多的外部调用
+ */
 void memory_region_init(MemoryRegion *mr,
                         Object *owner,
                         const char *name,
                         uint64_t size)
 {
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     *
+     * MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+     */
     object_initialize(mr, sizeof(*mr), TYPE_MEMORY_REGION);
     memory_region_do_init(mr, owner, name, size);
 }
@@ -1166,6 +1214,10 @@ static void memory_region_get_container(Object *obj, Visitor *v,
     gchar *path = (gchar *)"";
 
     if (mr->container) {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         path = object_get_canonical_path(OBJECT(mr->container));
     }
     visit_type_str(v, name, &path, errp);
@@ -1201,6 +1253,12 @@ static void memory_region_get_size(Object *obj, Visitor *v, const char *name,
     visit_type_uint64(v, name, &value, errp);
 }
 
+/*
+ * TypeInfo memory_region_info.instance_init = memory_reagion_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void memory_region_initfn(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -1235,6 +1293,12 @@ static void memory_region_initfn(Object *obj)
                         NULL, NULL, &error_abort);
 }
 
+/*
+ * TypeInfo iommu_memory_region_info.instance_init = iommu_memory_region_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void iommu_memory_region_initfn(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -1674,6 +1738,12 @@ void memory_region_init_iommu(void *_iommu_mr,
     iommu_mr->iommu_notify_flags = IOMMU_NOTIFIER_NONE;
 }
 
+/*
+ * TypeInfo memory_region_info.instance_finalize = memory_region_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void memory_region_finalize(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -2788,6 +2858,9 @@ void memory_region_invalidate_mmio_ptr(MemoryRegion *mr, hwaddr offset,
                           RUN_ON_CPU_HOST_PTR(invalidate_data));
 }
 
+/*
+ * 被很多外部调用
+ */
 void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
 {
     memory_region_ref(root);
@@ -2796,6 +2869,7 @@ void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
     as->ioeventfd_nb = 0;
     as->ioeventfds = NULL;
     QTAILQ_INIT(&as->listeners);
+    /* 把AddressSpace插入全局链表address_spaces */
     QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
     as->name = g_strdup(name ? name : "anonymous");
     address_space_update_topology(as);
@@ -2867,6 +2941,10 @@ static void mtree_expand_owner(fprintf_function mon_printf, void *f,
     if (dev && dev->id) {
         mon_printf(f, " id=%s", dev->id);
     } else {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         gchar *canonical_path = object_get_canonical_path(obj);
         if (canonical_path) {
             mon_printf(f, " path=%s", canonical_path);
@@ -3247,8 +3325,13 @@ static const TypeInfo iommu_memory_region_info = {
 
 static void memory_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&memory_region_info);
     type_register_static(&iommu_memory_region_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(memory_register_types)
diff --git a/qapi/qobject-input-visitor.c b/qapi/qobject-input-visitor.c
index da57f4c..27269ff 100644
--- a/qapi/qobject-input-visitor.c
+++ b/qapi/qobject-input-visitor.c
@@ -658,6 +658,11 @@ static void qobject_input_free(Visitor *v)
     g_free(qiv);
 }
 
+/*
+ * QObjectInputVisitor的root里存着QObject
+ *
+ * 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是QObject
+ */
 static QObjectInputVisitor *qobject_input_visitor_base_new(QObject *obj)
 {
     QObjectInputVisitor *v = g_malloc0(sizeof(*v));
@@ -681,8 +686,13 @@ static QObjectInputVisitor *qobject_input_visitor_base_new(QObject *obj)
     return v;
 }
 
+/*
+ * 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是QObject
+ * 返回包含的Visitor
+ */
 Visitor *qobject_input_visitor_new(QObject *obj)
 {
+    /* 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是QObject */
     QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);
 
     v->visitor.type_int64 = qobject_input_type_int64;
diff --git a/qdev-monitor.c b/qdev-monitor.c
index 61e0300..61e91ea 100644
--- a/qdev-monitor.c
+++ b/qdev-monitor.c
@@ -219,6 +219,12 @@ static DeviceClass *qdev_get_device_class(const char **driver, Error **errp)
         }
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {
         if (*driver != original_name) {
             error_setg(errp, "'%s' (alias '%s') is not a valid device model"
diff --git a/qom/object.c b/qom/object.c
index 75d1d48..cf8c0b7 100644
--- a/qom/object.c
+++ b/qom/object.c
@@ -31,6 +31,15 @@
 
 #define MAX_INTERFACES 32
 
+/*
+ * 核心函数:
+ *   - type_initialize()
+ *   - object_initialize_with_type() (依赖type_initialize())
+ *
+ * 所有instance的祖先是Object
+ * 所有class的祖先是ObjectClass
+ */
+
 typedef struct InterfaceImpl InterfaceImpl;
 typedef struct TypeImpl TypeImpl;
 
@@ -39,6 +48,15 @@ struct InterfaceImpl
     const char *typename;
 };
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
 struct TypeImpl
 {
     const char *name;
@@ -47,29 +65,85 @@ struct TypeImpl
 
     size_t instance_size;
 
+    /*
+     * called only by:
+     *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+     */
     void (*class_init)(ObjectClass *klass, void *data);
+    /*
+     * called only by:
+     *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+     */
     void (*class_base_init)(ObjectClass *klass, void *data);
+    /*
+     * 似乎目前不调用:
+     *   - hw/core/machine.c|868| <<global>> .class_finalize = machine_class_finalize,
+     *   - qom/object.c|69| <<global>> void (*class_finalize)(ObjectClass *klass, void *data);
+     *   - qom/object.c|179| <<type_new>> ti->class_finalize = info->class_finalize;
+     */
     void (*class_finalize)(ObjectClass *klass, void *data);
 
+    /*
+     * 来自TypeInfo (各个外部自己定义):
+     *   - qom/object.c|198| <<type_new>> ti->class_data = info->class_data;
+     */
     void *class_data;
 
+    /*
+     * called only by:
+     *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+     */
     void (*instance_init)(Object *obj);
+    /*
+     * called only by:
+     *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+     */
     void (*instance_post_init)(Object *obj);
+    /*
+     * called only by:
+     *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+     */
     void (*instance_finalize)(Object *obj);
 
     bool abstract;
 
+    /*
+     * 在type_new()中由TypeInfo->parent获得
+     */
     const char *parent;
+    /*
+     * 设置parent_type的地方:
+     *   - qom/object.c|256| <<type_get_parent>> type->parent_type = type_get_by_name(type->parent);
+     *   - qom/object.c|334| <<type_initialize_interface>> iface_impl->parent_type = parent_type;
+     */
     TypeImpl *parent_type;
 
+    /*
+     * 在type_initialize()中分配
+     */
     ObjectClass *class;
 
     int num_interfaces;
     InterfaceImpl interfaces[MAX_INTERFACES];
 };
 
+/*
+ * TYPE_INTERFACE获得的TypeImpl
+ *
+ * 用到的地方:
+ *   - qom/object.c|1217| <<object_class_dynamic_cast>> type_is_ancestor(target_type, type_interface)) {
+ *   - qom/object.c|3412| <<register_types>> type_interface = type_register_internal(&interface_info);
+ */
 static Type type_interface;
 
+/*
+ * called by:
+ *   - qom/object.c|89| <<type_table_add>> g_hash_table_insert(type_table_get(), (void *)ti->name, ti);
+ *   - qom/object.c|94| <<type_table_lookup>> return g_hash_table_lookup(type_table_get(), name);
+ *   - qom/object.c|889| <<object_class_foreach>> g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
+ *
+ *   如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+ */
 static GHashTable *type_table_get(void)
 {
     static GHashTable *type_table;
@@ -83,17 +157,42 @@ static GHashTable *type_table_get(void)
 
 static bool enumerating_types;
 
+/*
+ * called by only type_register_internal()
+ *
+ * 把一个根据TypeInfo转化成的TypeImpl插入到hashtable
+ */
 static void type_table_add(TypeImpl *ti)
 {
     assert(!enumerating_types);
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     g_hash_table_insert(type_table_get(), (void *)ti->name, ti);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|135| <<type_new>> if (type_table_lookup(info->name) != NULL) {
+ *   - qom/object.c|200| <<type_get_by_name>> return type_table_lookup(name);
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ */
 static TypeImpl *type_table_lookup(const char *name)
 {
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     return g_hash_table_lookup(type_table_get(), name);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|137| <<type_register_internal>> ti = type_new(info);
+ *   - qom/object.c|250| <<type_initialize_interface>> iface_impl = type_new(&info);
+ *
+ * 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 (通过name搜素)
+ */
 static TypeImpl *type_new(const TypeInfo *info)
 {
     TypeImpl *ti = g_malloc0(sizeof(*ti));
@@ -101,6 +200,7 @@ static TypeImpl *type_new(const TypeInfo *info)
 
     g_assert(info->name != NULL);
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     if (type_table_lookup(info->name) != NULL) {
         fprintf(stderr, "Registering `%s' which already exists\n", info->name);
         abort();
@@ -123,6 +223,11 @@ static TypeImpl *type_new(const TypeInfo *info)
 
     ti->abstract = info->abstract;
 
+    /*
+     * TypeImpl包含:
+     *       int num_interfaces;
+     *       InterfaceImpl interfaces[MAX_INTERFACES]; --> 包含const char *typename;
+     */
     for (i = 0; info->interfaces && info->interfaces[i].type; i++) {
         ti->interfaces[i].typename = g_strdup(info->interfaces[i].type);
     }
@@ -131,47 +236,100 @@ static TypeImpl *type_new(const TypeInfo *info)
     return ti;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|191| <<type_register>> return type_register_internal(info);
+ *   - qom/object.c|2503| <<register_types>> type_interface = type_register_internal(&interface_info);
+ *   - qom/object.c|2504| <<register_types>> type_register_internal(&object_info);
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 static TypeImpl *type_register_internal(const TypeInfo *info)
 {
     TypeImpl *ti;
+    /* 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 */
     ti = type_new(info);
 
+    /* 把一个根据TypeInfo转化成的TypeImpl插入到hashtable */
     type_table_add(ti);
     return ti;
 }
 
+/*
+ * 被外部好多好多调用
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 TypeImpl *type_register(const TypeInfo *info)
 {
     assert(info->parent);
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     return type_register_internal(info);
 }
 
+/*
+ * 被外部好多好多调用
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 TypeImpl *type_register_static(const TypeInfo *info)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     return type_register(info);
 }
 
+/*
+ * 为nr_infos个: 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 void type_register_static_array(const TypeInfo *infos, int nr_infos)
 {
     int i;
 
     for (i = 0; i < nr_infos; i++) {
+        /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
         type_register_static(&infos[i]);
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|245| <<type_get_parent>> type->parent_type = type_get_by_name(type->parent);
+ *   - qom/object.c|285| <<object_type_get_instance_size>> TypeImpl *type = type_get_by_name(typename);
+ *   - qom/object.c|383| <<type_initialize>> TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);
+ *   - qom/object.c|461| <<object_initialize>> TypeImpl *type = type_get_by_name(typename);
+ *   - qom/object.c|625| <<object_new>> TypeImpl *ti = type_get_by_name(typename);
+ *   - qom/object.c|801| <<object_class_dynamic_cast>> target_type = type_get_by_name(typename);
+ *   - qom/object.c|899| <<object_class_by_name>> TypeImpl *type = type_get_by_name(typename);
+ */
 static TypeImpl *type_get_by_name(const char *name)
 {
     if (name == NULL) {
         return NULL;
     }
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     return type_table_lookup(name);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|283| <<type_class_get_size>> return type_class_get_size(type_get_parent(ti));
+ *   - qom/object.c|296| <<type_object_get_size>> return type_object_get_size(type_get_parent(ti));
+ *   - qom/object.c|321| <<type_is_ancestor>> type = type_get_parent(type);
+ *   - qom/object.c|383| <<type_initialize>> parent = type_get_parent(ti);
+ *   - qom/object.c|430| <<type_initialize>> parent = type_get_parent(parent);
+ *   - qom/object.c|441| <<object_init_with_type>> object_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|456| <<object_post_init_with_type>> object_post_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|613| <<object_deinit>> object_deinit(obj, type_get_parent(type));
+ *   - qom/object.c|937| <<object_class_get_parent>> TypeImpl *type = type_get_parent(class->type);
+ *
+ * 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+ */
 static TypeImpl *type_get_parent(TypeImpl *type)
 {
+    /* parent是const char *parent类型 */
     if (!type->parent_type && type->parent) {
+        /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
         type->parent_type = type_get_by_name(type->parent);
         g_assert(type->parent_type != NULL);
     }
@@ -179,45 +337,95 @@ static TypeImpl *type_get_parent(TypeImpl *type)
     return type->parent_type;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|296| <<type_class_get_size>> if (type_has_parent(ti)) {
+ *   - qom/object.c|309| <<type_object_get_size>> if (type_has_parent(ti)) {
+ *   - qom/object.c|457| <<object_init_with_type>> if (type_has_parent(ti)) {
+ *   - qom/object.c|475| <<object_post_init_with_type>> if (type_has_parent(ti)) {
+ *   - qom/object.c|635| <<object_deinit>> if (type_has_parent(type)) {
+ *
+ * 检查TypeImpl是否有parent
+ */
 static bool type_has_parent(TypeImpl *type)
 {
     return (type->parent != NULL);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|308| <<type_class_get_size>> return type_class_get_size(type_get_parent(ti));
+ *   - qom/object.c|399| <<type_initialize>> ti->class_size = type_class_get_size(ti);
+ *
+ * 如果TypeImpl有class_size返回class_size
+ * 其次递归调用自己返回parent的size
+ * 最后没办法了返回sizeof(ObjectClass)
+ */
 static size_t type_class_get_size(TypeImpl *ti)
 {
     if (ti->class_size) {
         return ti->class_size;
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
-        return type_class_get_size(type_get_parent(ti));
+        /* 这里递归调用 继续返回parent的TypeImpl的class_size */
+        return type_class_get_size(type_get_parent(ti)); // 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
     }
 
     return sizeof(ObjectClass);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|338| <<type_object_get_size>> return type_object_get_size(type_get_parent(ti));
+ *   - qom/object.c|350| <<object_type_get_instance_size>> return type_object_get_size(type);
+ *   - qom/object.c|421| <<type_initialize>> ti->instance_size = type_object_get_size(ti);
+ *
+ * 如果TypeImpl有instance_size返回instance_size
+ * 其次递归调用自己返回parent的object size
+ * 最后没办法了返回0
+ */
 static size_t type_object_get_size(TypeImpl *ti)
 {
     if (ti->instance_size) {
         return ti->instance_size;
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
-        return type_object_get_size(type_get_parent(ti));
+	    /* 这里递归调用 继续返回parent的TypeImpl的instance_size */
+        return type_object_get_size(type_get_parent(ti)); // 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
     }
 
     return 0;
 }
 
+/*
+ * hw/ppc/pnv.c中调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 如果TypeImpl有instance_size返回instance_size
+ * 其次递归调用自己返回parent的object size
+ * 最后没办法了返回0
+ */
 size_t object_type_get_instance_size(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
     g_assert(type != NULL);
+    /*
+     * 如果TypeImpl有instance_size返回instance_size
+     * 其次递归调用自己返回parent的object size
+     * 最后没办法了返回0
+     */
     return type_object_get_size(type);
 }
 
+/*
+ * 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+ */
 static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
 {
     assert(target_type);
@@ -228,6 +436,7 @@ static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
             return true;
         }
 
+	/* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
         type = type_get_parent(type);
     }
 
@@ -236,9 +445,23 @@ static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
 
 static void type_initialize(TypeImpl *ti);
 
+/*
+ * called by:
+ *   - qom/object.c|474| <<type_initialize>> type_initialize_interface(ti, iface->interface_type, klass->type);
+ *   - qom/object.c|493| <<type_initialize>> type_initialize_interface(ti, t, t);
+ *
+ * 用ti和interface_type的name组成新的name("%s::%s"), 作为新的TypeInfo的name
+ * 根据TypeInfo转换成TypeImpl, 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 把转换成的TypeInfo的class插入ti->class->interfaces (Glist *)
+ */
 static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
                                       TypeImpl *parent_type)
 {
+    /*
+     * 一个例子: ti来自"nvme", interface_type和parent_type来自INTERFACE_PCIE_DEVICE
+     *
+     * 所有的interface的祖先(TYPE_INTERFACE)的class就是InterfaceClass
+     */
     InterfaceClass *new_iface;
     TypeInfo info = { };
     TypeImpl *iface_impl;
@@ -247,19 +470,36 @@ static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
     info.name = g_strdup_printf("%s::%s", ti->name, interface_type->name);
     info.abstract = true;
 
+    /* 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 (通过name搜索) */
     iface_impl = type_new(&info);
     iface_impl->parent_type = parent_type;
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(iface_impl);
     g_free((char *)info.name);
 
+    /*
+     * 最右边的class是ObjectClass
+     *
+     * 所有interface的祖先的class是InterfaceClass
+     */
     new_iface = (InterfaceClass *)iface_impl->class;
     new_iface->concrete_class = ti->class;
     new_iface->interface_type = interface_type;
 
+    /* 把TypeImpl挂载到ti->class->interfaces */
     ti->class->interfaces = g_slist_append(ti->class->interfaces,
                                            iface_impl->class);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|468| <<type_initialize>> g_str_hash, g_str_equal, g_free, object_property_free);
+ *   - qom/object.c|497| <<type_initialize>> g_str_hash, g_str_equal, g_free, object_property_free);
+ *   - qom/object.c|560| <<object_initialize_with_type>> NULL, object_property_free);
+ */
 static void object_property_free(gpointer data)
 {
     ObjectProperty *prop = data;
@@ -270,49 +510,150 @@ static void object_property_free(gpointer data)
     g_free(prop);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|407| <<type_initialize_interface>> type_initialize(iface_impl);
+ *   - qom/object.c|460| <<type_initialize>> type_initialize(parent);
+ *   - qom/object.c|550| <<object_initialize_with_type>> type_initialize(type);
+ *   - qom/object.c|725| <<object_new_with_type>> type_initialize(type);
+ *   - qom/object.c|1023| <<object_class_by_name>> type_initialize(type);
+ *   - qom/object.c|1037| <<object_class_get_parent>> type_initialize(type);
+ *   - qom/object.c|1057| <<object_class_foreach_tramp>> type_initialize(type);
+ *
+ * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+ * 调用.class_init()
+ */
 static void type_initialize(TypeImpl *ti)
 {
     TypeImpl *parent;
 
+    /* ti->class是ObjectClass, 如果已经初始化了就退出 */
     if (ti->class) {
         return;
     }
 
+    /*
+     * 如果TypeImpl有class_size返回class_size
+     * 其次递归调用自己返回parent的size
+     * 最后没办法了返回sizeof(ObjectClass)
+     */
     ti->class_size = type_class_get_size(ti);
+    /*
+     * 如果TypeImpl有instance_size返回instance_size
+     * 其次递归调用自己返回parent的size
+     * 最后没办法了返回0
+     */
     ti->instance_size = type_object_get_size(ti);
     /* Any type with zero instance_size is implicitly abstract.
      * This means interface types are all abstract.
      */
+    /* 没有instance_size的就是abstract */
     if (ti->instance_size == 0) {
         ti->abstract = true;
     }
 
+    /* class的类型: ObjectClass *class; */
     ti->class = g_malloc0(ti->class_size);
 
+    /* 返回TypeImpl的parent_type (TypeImpl), 如果没有现设置 (可以为NULL) */
     parent = type_get_parent(ti);
     if (parent) {
+        /* 递归调用自己保证祖先们都完成了初始化, 比如祖先们的class_init都调用过了! */
         type_initialize(parent);
         GSList *e;
         int i;
 
+	/*
+	 * 孩子们的class_size必须比祖先小 因为包含祖先
+	 */
         g_assert(parent->class_size <= ti->class_size);
+	/*
+	 * 包含祖先的时候都在头上 所以先拷贝过来
+	 *
+	 * TypeImpl包含ObjectClass *class, 后者包含GSList *interfaces
+	 */
         memcpy(ti->class, parent->class, parent->class_size);
+	/*
+	 * nvme的例子帮助理解interface:
+	 *
+	 * 1397 static const TypeInfo nvme_info = {
+	 * 1398     .name          = "nvme",
+	 * 1399     .parent        = TYPE_PCI_DEVICE,
+	 * 1400     .instance_size = sizeof(NvmeCtrl),
+	 * 1401     .class_init    = nvme_class_init,
+	 * 1402     .instance_init = nvme_instance_init,
+	 * 1403     .interfaces = (InterfaceInfo[]) {
+	 * 1404         { INTERFACE_PCIE_DEVICE },
+	 * 1405         { }
+	 * 1406     },
+	 * 1407 };
+	 *
+	 *  178 static const TypeInfo pcie_interface_info = {
+	 *  179     .name          = INTERFACE_PCIE_DEVICE,
+	 *  180     .parent        = TYPE_INTERFACE,
+	 *  181 };
+	 *
+	 *  3335     static TypeInfo interface_info = {
+	 *  3336         .name = TYPE_INTERFACE,
+	 *  3337         .class_size = sizeof(InterfaceClass),
+	 *  3338         .abstract = true,
+	 *  3339     };
+	 *
+	 *   597 struct InterfaceClass
+	 *   598 {
+	 *   599     ObjectClass parent_class;
+	 *   600     //< private >
+	 *   601     ObjectClass *concrete_class;
+	 *   602     Type interface_type;
+	 *   603 };
+	 *
+	 *
+	 *
+	 *
+	 * 从TypeInfo转换为TypeImpl时对interface的处理:
+	 *      TypeInfo的interfaces是InterfaceInfo的数组, 就是const char *type
+	 *      TypeImpl的interfaces是InterfaceImpl的数组, 就是const char *typename
+	 *  
+	 *  224     for (i = 0; info->interfaces && info->interfaces[i].type; i++) {
+	 *  225         ti->interfaces[i].typename = g_strdup(info->interfaces[i].type);
+	 *  226     }
+	 *  227     ti->num_interfaces = i;
+	 */
         ti->class->interfaces = NULL;
+	/*
+	 * ObjectClass的properties是GHashTable
+	 */
         ti->class->properties = g_hash_table_new_full(
             g_str_hash, g_str_equal, g_free, object_property_free);
 
+	/* 祖先没有先略过 */
         for (e = parent->class->interfaces; e; e = e->next) {
             InterfaceClass *iface = e->data;
+	    /*
+	     * ObjectClass包含Type (定义typedef struct TypeImpl *Type)
+	     */
             ObjectClass *klass = OBJECT_CLASS(iface);
 
+	    /*
+	     * 用ti和interface_type的name组成新的name("%s::%s"), 作为新的TypeInfo的name
+	     * 根据TypeInfo转换成TypeImpl, 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+	     * 把转换成的TypeInfo的class插入ti->class->interfaces (Glist *)
+	     */
             type_initialize_interface(ti, iface->interface_type, klass->type);
         }
 
         for (i = 0; i < ti->num_interfaces; i++) {
+            /*
+	     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+	     *
+	     * nvme的typename的例子是INTERFACE_PCIE_DEVICE
+	     */
             TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);
+	    /* ObjectClass中的interfaces是GSList *interfaces */
             for (e = ti->class->interfaces; e; e = e->next) {
                 TypeImpl *target_type = OBJECT_CLASS(e->data)->type;
 
+		/* 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor */
                 if (type_is_ancestor(target_type, t)) {
                     break;
                 }
@@ -322,6 +663,13 @@ static void type_initialize(TypeImpl *ti)
                 continue;
             }
 
+	    /*
+	     * 一个例子: ti来自"nvme", t来自INTERFACE_PCIE_DEVICE
+	     *
+	     * 用ti和interface_type的name组成新的name("%s::%s"), 作为新的TypeInfo的name
+	     * 根据TypeInfo转换成TypeImpl, 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+	     * 把转换成的TypeInfo的class插入ti->class->interfaces (Glist *)
+	     */
             type_initialize_interface(ti, t, t);
         }
     } else {
@@ -333,8 +681,15 @@ static void type_initialize(TypeImpl *ti)
 
     while (parent) {
         if (parent->class_base_init) {
+            /*
+	     * 实现了class_base_init的
+	     *   - hw/core/machine.c|867| <<global>> .class_base_init = machine_class_base_init,
+	     *   - hw/core/qdev.c|1108| <<global>> .class_base_init = device_class_base_init,
+	     *   - hw/pci/pci.c|2667| <<global>> .class_base_init = pci_device_class_base_init
+	     */
             parent->class_base_init(ti->class, ti->class_data);
         }
+	/* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
         parent = type_get_parent(parent);
     }
 
@@ -343,9 +698,20 @@ static void type_initialize(TypeImpl *ti)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|602| <<object_init_with_type>> object_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|641| <<object_initialize_with_type>> object_init_with_type(obj, type);
+ *
+ * 调用TypeImpl的instance_init(), 如果有parent递归"先"调用parent的instance_init()
+ */
 static void object_init_with_type(Object *obj, TypeImpl *ti)
 {
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
+        /*
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_init_with_type(obj, type_get_parent(ti));
     }
 
@@ -354,22 +720,95 @@ static void object_init_with_type(Object *obj, TypeImpl *ti)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|621| <<object_post_init_with_type>> object_post_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|642| <<object_initialize_with_type>> object_post_init_with_type(obj, type);
+ *
+ * 调用TypeImpl的instance_post_init(obj), 如果有parent"再"递归调用parent的instance_post_init(obj)
+ */
 static void object_post_init_with_type(Object *obj, TypeImpl *ti)
 {
     if (ti->instance_post_init) {
         ti->instance_post_init(obj);
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
+        /* 
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_post_init_with_type(obj, type_get_parent(ti));
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|650| <<object_initialize>> object_initialize_with_type(data, size, type);
+ *   - qom/object.c|816| <<object_new_with_type>> object_initialize_with_type(obj, type->instance_size, type);
+ *
+ * 一个例子 (TYPE_KVM_ACCEL):
+ * (gdb) bt
+ * #0  object_initialize_with_type (data=0x5555565d3d40, size=4456, type=0x5555564f9b30) at qom/object.c:370
+ * #1  0x0000555555c1e805 in object_new_with_type (type=0x5555564f9b30) at qom/object.c:546
+ * #2  0x0000555555c1e842 in object_new (typename=0x5555564d6090 "kvm-accel") at qom/object.c:556
+ * #3  0x000055555584bdb2 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ *
+ * (gdb) set print pretty on
+ * (gdb) p *type
+ * $9 = {
+ *   name = 0x5555564d6090 "kvm-accel", 
+ *   class_size = 152, 
+ *   instance_size = 4456, 
+ *   class_init = 0x555555852628 <kvm_accel_class_init>, 
+ *   class_base_init = 0x0, 
+ *   class_finalize = 0x0, 
+ *   class_data = 0x0, 
+ *   instance_init = 0x0, 
+ *   instance_post_init = 0x0, 
+ *   instance_finalize = 0x0, 
+ *   abstract = false, 
+ *   parent = 0x5555564d6160 "accel", 
+ *   parent_type = 0x5555564f99b0, 
+ *   class = 0x555556547110, 
+ *   num_interfaces = 0, 
+ *   interfaces =     {{
+ *       typename = 0x0
+ *     } <repeats 32 times>}
+ * }
+ *
+ * (gdb) p *type.class
+ * $10 = {
+ *   type = 0x5555564f9b30,   ----->  又指向"kvm-accel"的TypeImpl 
+ *   interfaces = 0x0, 
+ *   object_cast_cache =     {0x0,
+ *     0x0,
+ *     0x0,
+ *     0x0}, 
+ *   class_cast_cache =     {0x0,
+ *     0x0,
+ *     0x555555d90dcc "accel",
+ *     0x555555d903a0 "accel"}, 
+ *   unparent = 0x0, 
+ *   properties = 0x555556545e40
+ * }
+ *
+ * 在上面的例子中, type是TYPE_KVM_ACCEL, 在该函数中obj->class就被设置成了TYPE_KVM_ACCEL的ObjectClass
+ *
+ *
+ * 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 static void object_initialize_with_type(void *data, size_t size, TypeImpl *type)
 {
     Object *obj = data;
 
     g_assert(type != NULL);
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     g_assert(type->instance_size >= sizeof(Object));
@@ -381,14 +820,24 @@ static void object_initialize_with_type(void *data, size_t size, TypeImpl *type)
     object_ref(obj);
     obj->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
                                             NULL, object_property_free);
+    /* 调用TypeImpl的instance_init(), 如果有parent递归"先"调用parent的instance_init() */
     object_init_with_type(obj, type);
+    /* 调用TypeImpl的instance_post_init(obj), 如果有parent"再"递归调用parent的instance_post_init(obj) */
     object_post_init_with_type(obj, type);
 }
 
+/*
+ * 被一群外部的调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 void object_initialize(void *data, size_t size, const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
+    /* 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init() */
     object_initialize_with_type(data, size, type);
 }
 
@@ -424,6 +873,12 @@ void object_initialize_childv(Object *parentobj, const char *propname,
         goto out;
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_dynamic_cast(obj, TYPE_USER_CREATABLE)) {
         user_creatable_complete(obj, &local_err);
         if (local_err) {
@@ -446,6 +901,9 @@ out:
     }
 }
 
+/*
+ * 判断ObjectProperty的type是否开头是"child<"
+ */
 static inline bool object_property_is_child(ObjectProperty *prop)
 {
     return strstart(prop->type, "child<", NULL);
@@ -516,11 +974,18 @@ static void object_deinit(Object *obj, TypeImpl *type)
         type->instance_finalize(obj);
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(type)) {
+        /*
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_deinit(obj, type_get_parent(type));
     }
 }
 
+/*
+ * called only by object_unref()
+ */
 static void object_finalize(void *data)
 {
     Object *obj = data;
@@ -535,28 +1000,56 @@ static void object_finalize(void *data)
     }
 }
 
+/*
+ * called only by object_new()
+ *
+ * Type的定义: typedef struct TypeImpl *Type
+ *
+ * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 static Object *object_new_with_type(Type type)
 {
     Object *obj;
 
     g_assert(type != NULL);
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     obj = g_malloc(type->instance_size);
+    /* 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init() */
     object_initialize_with_type(obj, type->instance_size, type);
     obj->free = g_free;
 
     return obj;
 }
 
+/*
+ * 被一群外部调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 Object *object_new(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *ti = type_get_by_name(typename);
 
     return object_new_with_type(ti);
 }
 
 
+/*
+ * called by:
+ *   - hw/misc/auxbus.c|70| <<aux_init_bus>> auxtoi2c = object_new_with_props(TYPE_AUXTOI2C, OBJECT(bus), "i2c",
+ *   - iothread.c|366| <<iothread_create>> obj = object_new_with_props(TYPE_IOTHREAD,
+ *   - ui/vnc.c|3539| <<vnc_display_create_creds>> creds = object_new_with_props(TYPE_QCRYPTO_TLS_CREDS_X509,
+ *   - ui/vnc.c|3548| <<vnc_display_create_creds>> creds = object_new_with_props(TYPE_QCRYPTO_TLS_CREDS_ANON,
+ */
 Object *object_new_with_props(const char *typename,
                               Object *parent,
                               const char *id,
@@ -584,6 +1077,11 @@ Object *object_new_with_propv(const char *typename,
     ObjectClass *klass;
     Error *local_err = NULL;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     klass = object_class_by_name(typename);
     if (!klass) {
         error_setg(errp, "invalid object type: %s", typename);
@@ -594,17 +1092,34 @@ Object *object_new_with_propv(const char *typename,
         error_setg(errp, "object type '%s' is abstract", typename);
         return NULL;
     }
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     obj = object_new(typename);
 
     if (object_set_propv(obj, &local_err, vargs) < 0) {
         goto error;
     }
 
+    /*
+     * 把child设置成一个obj的ObjectProperty
+     * 在Object->properties (GHashTable)的name (id)就是参数的name, type是"child<child的type>"
+     * ObjectProperty的opaque是child
+     * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+     */
     object_property_add_child(parent, id, obj, &local_err);
     if (local_err) {
         goto error;
     }
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (object_dynamic_cast(obj, TYPE_USER_CREATABLE)) {
         user_creatable_complete(obj, &local_err);
         if (local_err) {
@@ -623,6 +1138,28 @@ Object *object_new_with_propv(const char *typename,
 }
 
 
+/*
+ * <example>
+ *   <title>Update an object's properties</title>
+ *   <programlisting>
+ *   Error *err = NULL;
+ *   Object *obj = ...get / create object...;
+ *
+ *   obj = object_set_props(obj,
+ *                          &err,
+ *                          "share", "yes",
+ *                          "mem-path", "/dev/shm/somefile",
+ *                          "prealloc", "yes",
+ *                          "size", "1048576",
+ *                          NULL);
+ *  
+ *   if (!obj) {
+ *     g_printerr("Cannot set properties: %s\n",
+ *                error_get_pretty(err));
+ *   }
+ *   </programlisting>
+ * </example>
+ */
 int object_set_props(Object *obj,
                      Error **errp,
                      ...)
@@ -638,6 +1175,13 @@ int object_set_props(Object *obj,
 }
 
 
+/*
+ * called by:
+ *   - qom/object.c|720| <<object_initialize_childv>> object_set_propv(obj, &local_err, vargs);
+ *   - qom/object.c|937| <<object_new_with_propv>> if (object_set_propv(obj, &local_err, vargs) < 0) {
+ *   - qom/object.c|994| <<object_set_props>> ret = object_set_propv(obj, errp, vargs);
+ *   - qom/object.c|1001| <<object_set_propv>> int object_set_propv(Object *obj,
+ */
 int object_set_propv(Object *obj,
                      Error **errp,
                      va_list vargs)
@@ -662,8 +1206,37 @@ int object_set_propv(Object *obj,
 }
 
 
+/*
+ * 一个使用的例子: DeviceState *dev = (DeviceState *) object_dynamic_cast(obj, TYPE_DEVICE);
+ *   - memory.c|2938| <<mtree_expand_owner>> DeviceState *dev = (DeviceState *) object_dynamic_cast(obj, TYPE_DEVICE);
+ *
+ * 一个例子(#1):
+ *
+ * (gdb) bt
+ * #0  object_class_dynamic_cast (class=0x555556547110, typename=0x555555d903a0 "accel") at qom/object.c:716
+ * #1  0x0000555555c1ed8d in object_dynamic_cast (obj=0x5555565d3d40, typename=0x555555d903a0 "accel") at qom/object.c:667
+ * #2  0x0000555555c1ee43 in object_dynamic_cast_assert (obj=0x5555565d3d40, typename=0x555555d903a0 "accel", 
+ *     file=0x555555d903b8 "/home/zhang/kvm/qemu-3.0.0/accel/accel.c", line=58, func=0x555555d90480 <__func__.27147> "accel_init_machine")
+ *     at qom/object.c:690
+ * #3  0x000055555584bdd4 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ *
+ * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+ * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+ * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+ * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+ */
 Object *object_dynamic_cast(Object *obj, const char *typename)
 {
+    /*
+     * object_get_class(): 参考object_initialize_with_type()的注释, 比如class可能是TYPE_KVM_ACCEL的ObjectClass
+     *
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (obj && object_class_dynamic_cast(object_get_class(obj), typename)) {
         return obj;
     }
@@ -671,6 +1244,19 @@ Object *object_dynamic_cast(Object *obj, const char *typename)
     return NULL;
 }
 
+/*
+ * 一个例子(#2):
+ *
+ * (gdb) bt
+ * #0  object_class_dynamic_cast (class=0x555556547110, typename=0x555555d903a0 "accel") at qom/object.c:716
+ * #1  0x0000555555c1ed8d in object_dynamic_cast (obj=0x5555565d3d40, typename=0x555555d903a0 "accel") at qom/object.c:667
+ * #2  0x0000555555c1ee43 in object_dynamic_cast_assert (obj=0x5555565d3d40, typename=0x555555d903a0 "accel", 
+ *     file=0x555555d903b8 "/home/zhang/kvm/qemu-3.0.0/accel/accel.c", line=58, func=0x555555d90480 <__func__.27147> "accel_init_machine")
+ *     at qom/object.c:690
+ * #3  0x000055555584bdd4 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ */
 Object *object_dynamic_cast_assert(Object *obj, const char *typename,
                                    const char *file, int line, const char *func)
 {
@@ -710,6 +1296,48 @@ out:
     return obj;
 }
 
+/*
+ * 一个gdb的例子 (#0):
+ *
+ * (gdb) bt
+ * #0  object_class_dynamic_cast (class=0x555556547110, typename=0x555555d903a0 "accel") at qom/object.c:716
+ * #1  0x0000555555c1ed8d in object_dynamic_cast (obj=0x5555565d3d40, typename=0x555555d903a0 "accel") at qom/object.c:667
+ * #2  0x0000555555c1ee43 in object_dynamic_cast_assert (obj=0x5555565d3d40, typename=0x555555d903a0 "accel", 
+ *     file=0x555555d903b8 "/home/zhang/kvm/qemu-3.0.0/accel/accel.c", line=58, func=0x555555d90480 <__func__.27147> "accel_init_machine")
+ *     at qom/object.c:690
+ * #3  0x000055555584bdd4 in accel_init_machine (acc=0x555556547110, ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:58
+ * #4  0x000055555584bf16 in configure_accelerator (ms=0x5555565c6770) at /home/zhang/kvm/qemu-3.0.0/accel/accel.c:98
+ * #5  0x000055555599d48a in main (argc=16, argv=0x7fffffffe418, envp=0x7fffffffe4a0) at vl.c:4297
+ *
+ * (gdb) p *class.type
+ * $11 = {
+ *   name = 0x5555564d6090 "kvm-accel", 
+ *   class_size = 152, 
+ *   instance_size = 4456, 
+ *   class_init = 0x555555852628 <kvm_accel_class_init>, 
+ *   class_base_init = 0x0, 
+ *   class_finalize = 0x0, 
+ *   class_data = 0x0, 
+ *   instance_init = 0x0, 
+ *   instance_post_init = 0x0, 
+ *   instance_finalize = 0x0, 
+ *   abstract = false, 
+ *   parent = 0x5555564d6160 "accel", 
+ *   parent_type = 0x5555564f99b0, 
+ *   class = 0x555556547110, 
+ *   num_interfaces = 0, 
+ *   interfaces =     {{
+ *       typename = 0x0
+ *     } <repeats 32 times>}
+ * }
+ *
+ * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+ *
+ * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+ * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+ * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+ * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回 
+ */
 ObjectClass *object_class_dynamic_cast(ObjectClass *class,
                                        const char *typename)
 {
@@ -723,24 +1351,54 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
 
     /* A simple fast path that can trigger a lot for leaf classes.  */
     type = class->type;
+    /* 如果这个ObjectClass的type就是我们要找的 直接返回ObjectClass */
     if (type->name == typename) {
         return class;
     }
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     target_type = type_get_by_name(typename);
     if (!target_type) {
         /* target class type unknown, so fail the cast */
         return NULL;
     }
 
+    /*
+     * type_is_ancestor(): 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+     *
+     *
+     * 一个nvme的例子:
+     *
+     * 1397 static const TypeInfo nvme_info = {
+     * 1398     .name          = "nvme",
+     * 1399     .parent        = TYPE_PCI_DEVICE,
+     * 1400     .instance_size = sizeof(NvmeCtrl),
+     * 1401     .class_init    = nvme_class_init,
+     * 1402     .instance_init = nvme_instance_init,
+     * 1403     .interfaces = (InterfaceInfo[]) {
+     * 1404         { INTERFACE_PCIE_DEVICE },
+     * 1405         { }
+     * 1406     },
+     * 1407 };
+     *
+     *
+     * type_interface是TYPE_INTERFACE获得的TypeImpl
+     *
+     * 这个if语句是ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (type->class->interfaces &&
             type_is_ancestor(target_type, type_interface)) {
         int found = 0;
         GSList *i;
 
+	/*
+	 * 从ObjectClass的interfaces (GList *)中找到一个祖先是target_type的
+	 */
         for (i = class->interfaces; i; i = i->next) {
             ObjectClass *target_class = i->data;
 
+	    /* 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor */
             if (type_is_ancestor(target_class->type, target_type)) {
                 ret = target_class;
                 found++;
@@ -748,16 +1406,27 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
          }
 
         /* The match was ambiguous, don't allow a cast */
+	/* 找到多于一个是不正确的 */
         if (found > 1) {
             ret = NULL;
         }
-    } else if (type_is_ancestor(type, target_type)) {
+    } else if (type_is_ancestor(type, target_type)) {  // 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+        /*
+	 * else if中如果typename获得的target_type是class->type的最先则返回class
+	 *
+	 * 一个例子是type是TYPE_KVM_ACCEL, target_type是TYPE_ACCEL, 返回的class (ret)是TYPE_KVM_ACCEL的ObjectClass (没关系 因为包含了后者)
+	 *
+	 * 如果不是interface的部分, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+	 */
         ret = class;
     }
 
     return ret;
 }
 
+/*
+ * 调用object_class_dynamic_cast() 剩下就是做了些检查
+ */
 ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,
                                               const char *typename,
                                               const char *file, int line,
@@ -783,6 +1452,12 @@ ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,
     }
 #endif
 
+    /*
+     * 如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     * 一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     * 否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     * 在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     ret = object_class_dynamic_cast(class, typename);
     if (!ret && class) {
         fprintf(stderr, "%s:%d:%s: Object %p is not an instance of type %s\n",
@@ -805,47 +1480,78 @@ out:
 
 const char *object_get_typename(const Object *obj)
 {
+    /* 最后的type (Type) 是一个TypeImpl */
     return obj->class->type->name;
 }
 
 ObjectClass *object_get_class(Object *obj)
 {
+    /*
+     * class是ObjectClass
+     *
+     * 参考object_initialize_with_type()的注释, 比如class可能是TYPE_KVM_ACCEL的ObjectClass
+     */
     return obj->class;
 }
 
 bool object_class_is_abstract(ObjectClass *klass)
 {
+    /* type是Type (TypeImpl) */
     return klass->type->abstract;
 }
 
 const char *object_class_get_name(ObjectClass *klass)
 {
+    /* type是Type (TypeImpl) */
     return klass->type->name;
 }
 
+/*
+ * 很多外部调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+ * 调用.class_init()
+ */
 ObjectClass *object_class_by_name(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
     if (!type) {
         return NULL;
     }
 
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     return type->class;
 }
 
+/*
+ * 得到TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+ * 初始化parent_type(TypeImpl)的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 最后返回parent_type(TypeImpl)的class (ObjectClass)
+ */
 ObjectClass *object_class_get_parent(ObjectClass *class)
 {
+    /* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
     TypeImpl *type = type_get_parent(class->type);
 
     if (!type) {
         return NULL;
     }
 
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
+    /* class是ObjectClass */
     return type->class;
 }
 
@@ -871,6 +1577,13 @@ static void object_class_foreach_tramp(gpointer key, gpointer value,
         return;
     }
 
+    /*
+     * object_class_dymanic_cast():
+     *     如果参数的ObjectClass没有interface, 就是检查了一下typename是否是class的祖先, 返回的还是参数的class (ObjectClass)
+     *     一般用于把一个更孩子的ObjectClass转化成typename的ObjectClass (比如把TYPE_KVM_ACCEL转化成TYPE_ACCEL)
+     *     否则在ObjectClass有interfaces的情况下, 并且目标的target_type祖先是TYPE_INTERFACE
+     *     在该ObjectClass的interfaces中寻找一个祖先是target_type的interface(ObjectClass)并返回
+     */
     if (data->implements_type && 
         !object_class_dynamic_cast(k, data->implements_type)) {
         return;
@@ -886,6 +1599,9 @@ void object_class_foreach(void (*fn)(ObjectClass *klass, void *opaque),
     OCFData data = { fn, implements_type, include_abstract, opaque };
 
     enumerating_types = true;
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
     enumerating_types = false;
 }
@@ -979,6 +1695,12 @@ void object_unref(Object *obj)
     }
 }
 
+/*
+ * 好多外部调用
+ *
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 ObjectProperty *
 object_property_add(Object *obj, const char *name, const char *type,
                     ObjectPropertyAccessor *get,
@@ -989,6 +1711,7 @@ object_property_add(Object *obj, const char *name, const char *type,
     ObjectProperty *prop;
     size_t name_len = strlen(name);
 
+    /* 感觉一般的都不满足这个什么[*]吧 */
     if (name_len >= 3 && !memcmp(name + name_len - 3, "[*]", 4)) {
         int i;
         ObjectProperty *ret;
@@ -1009,6 +1732,11 @@ object_property_add(Object *obj, const char *name, const char *type,
         return ret;
     }
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     if (object_property_find(obj, name, NULL) != NULL) {
         error_setg(errp, "attempt to add duplicate property '%s'"
                    " to object (type '%s')", name,
@@ -1024,12 +1752,17 @@ object_property_add(Object *obj, const char *name, const char *type,
     prop->get = get;
     prop->set = set;
     prop->release = release;
+    /* opaque用在get和set中 */
     prop->opaque = opaque;
 
     g_hash_table_insert(obj->properties, prop->name, prop);
     return prop;
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 ObjectProperty *
 object_class_property_add(ObjectClass *klass,
                           const char *name,
@@ -1064,17 +1797,29 @@ object_class_property_add(ObjectClass *klass,
     return prop;
 }
 
+/*
+ * 递归调用自己的parent (ObjectClass) 寻找prop
+ * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+ * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+ */
 ObjectProperty *object_property_find(Object *obj, const char *name,
                                      Error **errp)
 {
     ObjectProperty *prop;
     ObjectClass *klass = object_get_class(obj);
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     */
     prop = object_class_property_find(klass, name, NULL);
     if (prop) {
         return prop;
     }
 
+    /*
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     prop = g_hash_table_lookup(obj->properties, name);
     if (prop) {
         return prop;
@@ -1111,20 +1856,33 @@ void object_class_property_iter_init(ObjectPropertyIterator *iter,
     iter->nextclass = klass;
 }
 
+/*
+ * 递归调用自己的parent (ObjectClass) 寻找prop
+ * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+ */
 ObjectProperty *object_class_property_find(ObjectClass *klass, const char *name,
                                            Error **errp)
 {
     ObjectProperty *prop;
     ObjectClass *parent_klass;
 
+    /*
+     * 得到TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+     * 初始化parent_type(TypeImpl)的class_size, instance_size和class, 还有interface, 调用.class_init()
+     * 最后返回parent_type(TypeImpl)的class (ObjectClass)
+     */
     parent_klass = object_class_get_parent(klass);
     if (parent_klass) {
+        /*
+	 * 递归调用自己的parent (ObjectClass) 寻找prop
+	 */
         prop = object_class_property_find(parent_klass, name, NULL);
         if (prop) {
             return prop;
         }
     }
 
+    /* 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找 */
     prop = g_hash_table_lookup(klass->properties, name);
     if (!prop) {
         error_setg(errp, "Property '.%s' not found", name);
@@ -1147,9 +1905,17 @@ void object_property_del(Object *obj, const char *name, Error **errp)
     g_hash_table_remove(obj->properties, name);
 }
 
+/*
+ * 根据name找到ObjectProperty, 然后调用其get方法
+ */
 void object_property_get(Object *obj, Visitor *v, const char *name,
                          Error **errp)
 {
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     ObjectProperty *prop = object_property_find(obj, name, errp);
     if (prop == NULL) {
         return;
@@ -1162,9 +1928,24 @@ void object_property_get(Object *obj, Visitor *v, const char *name,
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|1791| <<object_property_parse>> object_property_set(obj, v, name, errp);
+ *   - qom/object.c|2719| <<property_set_alias>> object_property_set(prop->target_obj, v, prop->target_name, errp);
+ *   - qom/object_interfaces.c|73| <<user_creatable_add_type>> object_property_set(obj, v, e->key, &local_err);
+ *   - qom/qom-qobject.c|27| <<object_property_set_qobject>> object_property_set(obj, v, name, errp);
+ *   - target/s390x/cpu_models.c|491| <<cpu_model_from_info>> object_property_set(obj, visitor, e->key, errp);
+ *
+ * 根据name找到ObjectProperty, 然后调用其set方法
+ */
 void object_property_set(Object *obj, Visitor *v, const char *name,
                          Error **errp)
 {
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     ObjectProperty *prop = object_property_find(obj, name, errp);
     if (prop == NULL) {
         return;
@@ -1180,6 +1961,7 @@ void object_property_set(Object *obj, Visitor *v, const char *name,
 void object_property_set_str(Object *obj, const char *value,
                              const char *name, Error **errp)
 {
+    /* Create a new QString from a regular C string */
     QString *qstr = qstring_from_str(value);
     object_property_set_qobject(obj, QOBJECT(qstr), name, errp);
 
@@ -1209,6 +1991,10 @@ void object_property_set_link(Object *obj, Object *value,
                               const char *name, Error **errp)
 {
     if (value) {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         gchar *path = object_get_canonical_path(value);
         object_property_set_str(obj, path, name, errp);
         g_free(path);
@@ -1395,6 +2181,15 @@ out:
     visit_free(v);
 }
 
+/*
+ * called by:
+ *   - hmp.c|2594| <<hmp_qom_set>> object_property_parse(obj, value, property, &err);
+ *   - hw/core/qdev-properties.c|1259| <<qdev_prop_set_globals>> object_property_parse(OBJECT(dev), prop->value, prop->property, &err);
+ *   - qdev-monitor.c|180| <<set_property>> object_property_parse(obj, value, name, &err);
+ *   - qom/object.c|1020| <<object_set_propv>> object_property_parse(obj, value, propname, &local_err);
+ *   - target/i386/cpu.c|3528| <<x86_cpu_apply_props>> object_property_parse(OBJECT(cpu), pv->value, pv->prop,
+ *   - vl.c|2728| <<machine_set_property>> object_property_parse(obj, value, qom_name, &local_err);
+ */
 void object_property_parse(Object *obj, const char *string,
                            const char *name, Error **errp)
 {
@@ -1434,11 +2229,19 @@ const char *object_property_get_type(Object *obj, const char *name, Error **errp
     return prop->type;
 }
 
+/*
+ * 返回"container"的Object (root), 如果为空先初始化
+ */
 Object *object_get_root(void)
 {
     static Object *root;
 
     if (!root) {
+        /*
+	 * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+	 * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+	 * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+	 */
         root = object_new("container");
     }
 
@@ -1450,6 +2253,9 @@ Object *object_get_objects_root(void)
     return container_get(object_get_root(), "/objects");
 }
 
+/*
+ * 返回"container"的Object (internal_root), 如果为空先初始化
+ */
 Object *object_get_internal_root(void)
 {
     static Object *internal_root;
@@ -1461,6 +2267,11 @@ Object *object_get_internal_root(void)
     return internal_root;
 }
 
+/*
+ * 用作get方法:
+ *   - qom/object.c|2008| <<object_property_add_child>> op = object_property_add(obj, name, type, object_get_child_property, NULL,
+ *   - qom/object.c|2191| <<object_property_add_const_link>> object_get_child_property, NULL,
+ */
 static void object_get_child_property(Object *obj, Visitor *v,
                                       const char *name, void *opaque,
                                       Error **errp)
@@ -1468,16 +2279,31 @@ static void object_get_child_property(Object *obj, Visitor *v,
     Object *child = opaque;
     gchar *path;
 
+    /*
+     * 如果obj是root ("container")就返回"/"
+     * 否则返回到达该obj的路径
+     */
     path = object_get_canonical_path(child);
     visit_type_str(v, name, &path, errp);
     g_free(path);
 }
 
+/*
+ * 用作ObjectProperty的resolve方法:
+ *   - qom/object.c|2020| <<object_property_add_child>> op->resolve = object_resolve_child_property;
+ *   - qom/object.c|2199| <<object_property_add_const_link>> op->resolve = object_resolve_child_property;
+ *
+ * 返回opaque
+ */
 static Object *object_resolve_child_property(Object *parent, void *opaque, const gchar *part)
 {
     return opaque;
 }
 
+/*
+ * 用作release方法:
+ *   - qom/object.c|2014| <<object_property_add_child>> object_finalize_child_property, child, &local_err);
+ */
 static void object_finalize_child_property(Object *obj, const char *name,
                                            void *opaque)
 {
@@ -1490,6 +2316,12 @@ static void object_finalize_child_property(Object *obj, const char *name,
     object_unref(child);
 }
 
+/*
+ * 把child设置成一个obj的ObjectProperty
+ * 在Object->properties (GHashTable)的name就是参数的name, type是"child<child的type>"
+ * ObjectProperty的opaque是child
+ * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+ */
 void object_property_add_child(Object *obj, const char *name,
                                Object *child, Error **errp)
 {
@@ -1504,6 +2336,10 @@ void object_property_add_child(Object *obj, const char *name,
 
     type = g_strdup_printf("child<%s>", object_get_typename(OBJECT(child)));
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     op = object_property_add(obj, name, type, object_get_child_property, NULL,
                              object_finalize_child_property, child, &local_err);
     if (local_err) {
@@ -1540,6 +2376,10 @@ static void object_get_link_property(Object *obj, Visitor *v,
     gchar *path;
 
     if (*child) {
+        /*
+	 * 如果obj是root ("container")就返回"/"
+	 * 否则返回到达该obj的路径
+	 */
         path = object_get_canonical_path(*child);
         visit_type_str(v, name, &path, errp);
         g_free(path);
@@ -1679,6 +2519,12 @@ out:
     g_free(full_type);
 }
 
+/*
+ * 把child设置成一个obj的ObjectProperty
+ * 在Object->properties (GHashTable)的name就是参数的name, type是"link<target的type>"
+ * 2003  * ObjectProperty的opaque是child
+ * 2004  * ObjectProperty的resolve是object_resolve_child_property() --> 就是返回opqeue
+ */
 void object_property_add_const_link(Object *obj, const char *name,
                                     Object *target, Error **errp)
 {
@@ -1686,15 +2532,24 @@ void object_property_add_const_link(Object *obj, const char *name,
     ObjectProperty *op;
 
     link_type = g_strdup_printf("link<%s>", object_get_typename(target));
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     op = object_property_add(obj, name, link_type,
                              object_get_child_property, NULL,
                              NULL, target, errp);
     if (op != NULL) {
+        /* object_resolve_child_property就是返回opaque */
         op->resolve = object_resolve_child_property;
     }
     g_free(link_type);
 }
 
+/*
+ * 从该Object的parent的HashTable中寻找指向该Object的type开头是"child<"的并返回
+ * 似乎就是返回parent指向这个Object的prop->name
+ */
 gchar *object_get_canonical_path_component(Object *obj)
 {
     ObjectProperty *prop = NULL;
@@ -1705,7 +2560,9 @@ gchar *object_get_canonical_path_component(Object *obj)
     }
 
     g_hash_table_iter_init(&iter, obj->parent->properties);
+    /* 遍历parent (Object)的properties (HashTable) */
     while (g_hash_table_iter_next(&iter, NULL, (gpointer *)&prop)) {
+        /* 判断ObjectProperty的type是否开头是"child<" */
         if (!object_property_is_child(prop)) {
             continue;
         }
@@ -1720,16 +2577,26 @@ gchar *object_get_canonical_path_component(Object *obj)
     return NULL;
 }
 
+/*
+ * 如果obj是root ("container")就返回"/"
+ * 否则返回到达该obj的路径
+ */
 gchar *object_get_canonical_path(Object *obj)
 {
+    /* 返回"container"的Object (root), 如果为空先初始化 */
     Object *root = object_get_root();
     char *newpath, *path = NULL;
 
+    /* 如果参数的obj就是"container", 直接返回"/" */
     if (obj == root) {
         return g_strdup("/");
     }
 
     do {
+        /*
+	 * 从该Object的parent的HashTable中寻找指向该Object的type开头是"child<"的并返回
+	 * 似乎就是返回parent指向这个Object的prop->name
+	 */
         char *component = object_get_canonical_path_component(obj);
 
         if (!component) {
@@ -1740,6 +2607,7 @@ gchar *object_get_canonical_path(Object *obj)
             return NULL;
         }
 
+	/* 更新newpath */
         newpath = g_strdup_printf("/%s%s", component, path ? path : "");
         g_free(path);
         g_free(component);
@@ -1750,8 +2618,16 @@ gchar *object_get_canonical_path(Object *obj)
     return path;
 }
 
+/*
+ * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+ */
 Object *object_resolve_path_component(Object *parent, const gchar *part)
 {
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     ObjectProperty *prop = object_property_find(parent, part, NULL);
     if (prop == NULL) {
         return NULL;
@@ -1764,6 +2640,13 @@ Object *object_resolve_path_component(Object *parent, const gchar *part)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|2266| <<object_resolve_abs_path>> return object_resolve_abs_path(parent, parts, typename, index + 1);
+ *   - qom/object.c|2274| <<object_resolve_abs_path>> return object_resolve_abs_path(child, parts, typename, index + 1);
+ *   - qom/object.c|2286| <<object_resolve_partial_path>> obj = object_resolve_abs_path(parent, parts, typename, 0);
+ *   - qom/object.c|2331| <<object_resolve_path_type>> obj = object_resolve_abs_path(object_get_root(), parts, typename, 1);
+ */
 static Object *object_resolve_abs_path(Object *parent,
                                           gchar **parts,
                                           const char *typename,
@@ -1779,14 +2662,25 @@ static Object *object_resolve_abs_path(Object *parent,
         return object_resolve_abs_path(parent, parts, typename, index + 1);
     }
 
+    /*
+     * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+     */
     child = object_resolve_path_component(parent, parts[index]);
     if (!child) {
         return NULL;
     }
 
+    /*
+     * 递归调用自己, 处理parts[index+1]
+     */
     return object_resolve_abs_path(child, parts, typename, index + 1);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|2296| <<object_resolve_partial_path>> found = object_resolve_partial_path(prop->opaque, parts,
+ *   - qom/object.c|2325| <<object_resolve_path_type>> obj = object_resolve_partial_path(object_get_root(), parts,
+ */
 static Object *object_resolve_partial_path(Object *parent,
                                               gchar **parts,
                                               const char *typename,
@@ -1830,6 +2724,22 @@ Object *object_resolve_path_type(const char *path, const char *typename,
     Object *obj;
     gchar **parts;
 
+    /*
+     * 把path用'/'分开
+     *
+     * 对于/aaa/bbb/ccc/ddd
+     *     0: (不是NULL) 
+     *     1: aaa
+     *     2: bbb
+     *     3: ccc
+     *     4: ddd
+     *
+     * 对于aaa/bbb/ccc/ddd
+     *     0: aaa
+     *     1: bbb
+     *     2: ccc
+     *     3: ddd
+     */
     parts = g_strsplit(path, "/", 0);
     assert(parts);
 
@@ -1841,6 +2751,11 @@ Object *object_resolve_path_type(const char *path, const char *typename,
             *ambiguousp = ambiguous;
         }
     } else {
+        /*
+	 * object_get_root(): 返回"container"的Object (root), 如果为空先初始化
+	 *
+	 * 最后的参数是1, 从第一个开始, 因为第0个是root
+	 */
         obj = object_resolve_abs_path(object_get_root(), parts, typename, 1);
     }
 
@@ -1854,12 +2769,20 @@ Object *object_resolve_path(const char *path, bool *ambiguous)
     return object_resolve_path_type(path, TYPE_OBJECT, ambiguous);
 }
 
+/*
+ * get和set的opaque
+ */
 typedef struct StringProperty
 {
     char *(*get)(Object *, Error **);
     void (*set)(Object *, const char *, Error **);
 } StringProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2384| <<object_property_add_str>> get ? property_get_str : NULL,
+ *   - qom/object.c|2419| <<object_class_property_add_str>> get ? property_get_str : NULL,
+ */
 static void property_get_str(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
 {
@@ -1877,6 +2800,11 @@ static void property_get_str(Object *obj, Visitor *v, const char *name,
     g_free(value);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|2385| <<object_property_add_str>> set ? property_set_str : NULL,
+ *   - qom/object.c|2420| <<object_class_property_add_str>> set ? property_set_str : NULL,
+ */
 static void property_set_str(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
 {
@@ -1894,6 +2822,11 @@ static void property_set_str(Object *obj, Visitor *v, const char *name,
     g_free(value);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2386| <<object_property_add_str>> property_release_str,
+ *   - qom/object.c|2421| <<object_class_property_add_str>> property_release_str,
+ */
 static void property_release_str(Object *obj, const char *name,
                                  void *opaque)
 {
@@ -1901,6 +2834,13 @@ static void property_release_str(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_str()
+ *     set     = property_set_str()
+ *     release = property_release_str()
+ */
 void object_property_add_str(Object *obj, const char *name,
                            char *(*get)(Object *, Error **),
                            void (*set)(Object *, const char *, Error **),
@@ -1909,9 +2849,14 @@ void object_property_add_str(Object *obj, const char *name,
     Error *local_err = NULL;
     StringProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_str(), property_set_str()和property_release_str用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "string",
                         get ? property_get_str : NULL,
                         set ? property_set_str : NULL,
@@ -1923,6 +2868,13 @@ void object_property_add_str(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_str()
+ *     set     = property_set_str()
+ *     release = property_release_str()
+ */
 void object_class_property_add_str(ObjectClass *klass, const char *name,
                                    char *(*get)(Object *, Error **),
                                    void (*set)(Object *, const char *,
@@ -1932,9 +2884,14 @@ void object_class_property_add_str(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     StringProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_str(), property_set_str()和property_release_str用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "string",
                               get ? property_get_str : NULL,
                               set ? property_set_str : NULL,
@@ -1946,12 +2903,20 @@ void object_class_property_add_str(ObjectClass *klass, const char *name,
     }
 }
 
+/*
+ * get和set的opaque
+ */
 typedef struct BoolProperty
 {
     bool (*get)(Object *, Error **);
     void (*set)(Object *, bool, Error **);
 } BoolProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2504| <<object_property_add_bool()>> get ? property_get_bool : NULL,
+ *   - qom/object.c|2526| <<object_class_property_add_bool()>> get ? property_get_bool : NULL,
+ */
 static void property_get_bool(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -1968,6 +2933,11 @@ static void property_get_bool(Object *obj, Visitor *v, const char *name,
     visit_type_bool(v, name, &value, errp);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|2505| <<object_property_add_bool()>> set ? property_set_bool : NULL,
+ *   - qom/object.c|2527| <<object_class_property_add_bool()>> set ? property_set_bool : NULL,
+ */
 static void property_set_bool(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -1984,6 +2954,11 @@ static void property_set_bool(Object *obj, Visitor *v, const char *name,
     prop->set(obj, value, errp);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2531| <<object_property_add_bool()>> property_release_bool,
+ *   - qom/object.c|2565| <<object_class_property_add_bool()>> property_release_bool,
+ */
 static void property_release_bool(Object *obj, const char *name,
                                   void *opaque)
 {
@@ -1991,6 +2966,28 @@ static void property_release_bool(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 几个调用的例子:
+ *   - hw/core/bus.c|233| <<qbus_initfn>> object_property_add_bool(obj, "realized",
+ *   - hw/core/qdev.c|1004| <<device_initfn>> object_property_add_bool(obj, "realized",
+ *   - hw/core/qdev.c|1006| <<device_initfn>> object_property_add_bool(obj, "hotpluggable",
+ *   - hw/core/qdev.c|1008| <<device_initfn>> object_property_add_bool(obj, "hotplugged",
+ *
+ * 重要的一组例子:
+ * 1025     object_property_add_bool(obj, "realized",
+ * 1026                              device_get_realized, device_set_realized, NULL);
+ * 1027     object_property_add_bool(obj, "hotpluggable",
+ * 1028                              device_get_hotpluggable, NULL, NULL);
+ * 1029     object_property_add_bool(obj, "hotplugged",
+ * 1030                              device_get_hotplugged, NULL,
+ * 1031                              &error_abort);
+ *
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_bool()
+ *     set     = property_set_bool()
+ *     release = property_release_bool()
+ */
 void object_property_add_bool(Object *obj, const char *name,
                               bool (*get)(Object *, Error **),
                               void (*set)(Object *, bool, Error **),
@@ -1999,9 +2996,14 @@ void object_property_add_bool(Object *obj, const char *name,
     Error *local_err = NULL;
     BoolProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_bool(), property_set_bool()和property_release_bool用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "bool",
                         get ? property_get_bool : NULL,
                         set ? property_set_bool : NULL,
@@ -2013,6 +3015,13 @@ void object_property_add_bool(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_bool()
+ *     set     = property_set_bool()
+ *     release = property_release_bool()
+ */
 void object_class_property_add_bool(ObjectClass *klass, const char *name,
                                     bool (*get)(Object *, Error **),
                                     void (*set)(Object *, bool, Error **),
@@ -2021,9 +3030,14 @@ void object_class_property_add_bool(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     BoolProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_bool(), property_set_bool()和property_release_bool用到 */
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "bool",
                               get ? property_get_bool : NULL,
                               set ? property_set_bool : NULL,
@@ -2035,6 +3049,11 @@ void object_class_property_add_bool(ObjectClass *klass, const char *name,
     }
 }
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2631| <<object_property_add_enum>> get ? property_get_enum : NULL,
+ *   - qom/object.c|2656| <<object_class_property_add_enum>> get ? property_get_enum : NULL,
+ */
 static void property_get_enum(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -2051,6 +3070,11 @@ static void property_get_enum(Object *obj, Visitor *v, const char *name,
     visit_type_enum(v, name, &value, prop->lookup, errp);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|2632| <<object_property_add_enum>> set ? property_set_enum : NULL,
+ *   - qom/object.c|2657| <<object_class_property_add_enum>> set ? property_set_enum : NULL,
+ */
 static void property_set_enum(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
@@ -2066,6 +3090,11 @@ static void property_set_enum(Object *obj, Visitor *v, const char *name,
     prop->set(obj, value, errp);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2633| <<object_property_add_enum>> property_release_enum,
+ *   - qom/object.c|2658| <<object_class_property_add_enum>> property_release_enum,
+ */
 static void property_release_enum(Object *obj, const char *name,
                                   void *opaque)
 {
@@ -2073,6 +3102,13 @@ static void property_release_enum(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_enum()
+ *     set     = property_set_enum()
+ *     release = property_release_enum()
+ */
 void object_property_add_enum(Object *obj, const char *name,
                               const char *typename,
                               const QEnumLookup *lookup,
@@ -2083,10 +3119,15 @@ void object_property_add_enum(Object *obj, const char *name,
     Error *local_err = NULL;
     EnumProperty *prop = g_malloc(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_enum(), property_set_enum()和property_release_enum用到 */
     prop->lookup = lookup;
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, typename,
                         get ? property_get_enum : NULL,
                         set ? property_set_enum : NULL,
@@ -2098,6 +3139,13 @@ void object_property_add_enum(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_enum()
+ *     set     = property_set_enum()
+ *     release = property_release_enum()
+ */
 void object_class_property_add_enum(ObjectClass *klass, const char *name,
                                     const char *typename,
                                     const QEnumLookup *lookup,
@@ -2108,10 +3156,15 @@ void object_class_property_add_enum(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     EnumProperty *prop = g_malloc(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_enum(), property_set_enum()和property_release_enum用到 */
     prop->lookup = lookup;
     prop->get = get;
     prop->set = set;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, typename,
                               get ? property_get_enum : NULL,
                               set ? property_set_enum : NULL,
@@ -2127,6 +3180,11 @@ typedef struct TMProperty {
     void (*get)(Object *, struct tm *, Error **);
 } TMProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|2774| <<object_property_add_tm>> get ? property_get_tm : NULL, NULL,
+ *   - qom/object.c|2793| <<object_class_property_add_tm>> get ? property_get_tm : NULL, NULL,
+ */
 static void property_get_tm(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
 {
@@ -2175,6 +3233,11 @@ out:
 
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|2775| <<object_property_add_tm>> property_release_tm,
+ *   - qom/object.c|2794| <<object_class_property_add_tm>> property_release_tm,
+ */
 static void property_release_tm(Object *obj, const char *name,
                                 void *opaque)
 {
@@ -2182,6 +3245,12 @@ static void property_release_tm(Object *obj, const char *name,
     g_free(prop);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ *     get     = property_get_tm()
+ *     release = property_release_tm()
+ */
 void object_property_add_tm(Object *obj, const char *name,
                             void (*get)(Object *, struct tm *, Error **),
                             Error **errp)
@@ -2189,8 +3258,13 @@ void object_property_add_tm(Object *obj, const char *name,
     Error *local_err = NULL;
     TMProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_tm()和property_release_tm()用到 */
     prop->get = get;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "struct tm",
                         get ? property_get_tm : NULL, NULL,
                         property_release_tm,
@@ -2201,6 +3275,12 @@ void object_property_add_tm(Object *obj, const char *name,
     }
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ *     get     = property_get_tm()
+ *     release = property_release_tm()
+ */
 void object_class_property_add_tm(ObjectClass *klass, const char *name,
                                   void (*get)(Object *, struct tm *, Error **),
                                   Error **errp)
@@ -2208,8 +3288,13 @@ void object_class_property_add_tm(ObjectClass *klass, const char *name,
     Error *local_err = NULL;
     TMProperty *prop = g_malloc0(sizeof(*prop));
 
+    /* prop是当opaque的, 会在property_get_tm()和property_release_tm()用到 */
     prop->get = get;
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "struct tm",
                               get ? property_get_tm : NULL, NULL,
                               property_release_tm,
@@ -2220,11 +3305,19 @@ void object_class_property_add_tm(ObjectClass *klass, const char *name,
     }
 }
 
+/*
+ * 用作prop (opaque)的get
+ */
 static char *qdev_get_type(Object *obj, Error **errp)
 {
     return g_strdup(object_get_typename(obj));
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2873| <<object_property_add_uint8_ptr>> object_property_add(obj, name, "uint8", property_get_uint8_ptr,
+ *   - qom/object.c|2880| <<object_class_property_add_uint8_ptr>> object_class_property_add(klass, name, "uint8", property_get_uint8_ptr,
+ */
 static void property_get_uint8_ptr(Object *obj, Visitor *v, const char *name,
                                    void *opaque, Error **errp)
 {
@@ -2232,6 +3325,11 @@ static void property_get_uint8_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint8(v, name, &value, errp);
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2892| <<object_property_add_uint16_ptr>> object_property_add(obj, name, "uint16", property_get_uint16_ptr,
+ *   - qom/object.c|2899| <<object_class_property_add_uint16_ptr>> object_class_property_add(klass, name, "uint16", property_get_uint16_ptr,
+ */
 static void property_get_uint16_ptr(Object *obj, Visitor *v, const char *name,
                                     void *opaque, Error **errp)
 {
@@ -2239,6 +3337,11 @@ static void property_get_uint16_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint16(v, name, &value, errp);
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2911| <<object_property_add_uint32_ptr>> object_property_add(obj, name, "uint32", property_get_uint32_ptr,
+ *   - qom/object.c|2918| <<object_class_property_add_uint32_ptr>> object_class_property_add(klass, name, "uint32", property_get_uint32_ptr,
+ */
 static void property_get_uint32_ptr(Object *obj, Visitor *v, const char *name,
                                     void *opaque, Error **errp)
 {
@@ -2246,6 +3349,11 @@ static void property_get_uint32_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint32(v, name, &value, errp);
 }
 
+/*
+ * 用作ObjectProperty的get方法:
+ *   - qom/object.c|2930| <<object_property_add_uint64_ptr>> object_property_add(obj, name, "uint64", property_get_uint64_ptr,
+ *   - qom/object.c|2937| <<object_class_property_add_uint64_ptr>> object_class_property_add(klass, name, "uint64", property_get_uint64_ptr,
+ */
 static void property_get_uint64_ptr(Object *obj, Visitor *v, const char *name,
                                     void *opaque, Error **errp)
 {
@@ -2253,58 +3361,122 @@ static void property_get_uint64_ptr(Object *obj, Visitor *v, const char *name,
     visit_type_uint64(v, name, &value, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint8_ptr(Object *obj, const char *name,
                                    const uint8_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint8", property_get_uint8_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint8_ptr(ObjectClass *klass, const char *name,
                                          const uint8_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint8", property_get_uint8_ptr,
                               NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint16_ptr(Object *obj, const char *name,
                                     const uint16_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint16", property_get_uint16_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint16_ptr(ObjectClass *klass, const char *name,
                                           const uint16_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint16", property_get_uint16_ptr,
                               NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint32_ptr(Object *obj, const char *name,
                                     const uint32_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint32", property_get_uint32_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint32_ptr(ObjectClass *klass, const char *name,
                                           const uint32_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint32", property_get_uint32_ptr,
                               NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入Object->properties (GHashTable)
+ */
 void object_property_add_uint64_ptr(Object *obj, const char *name,
                                     const uint64_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     object_property_add(obj, name, "uint64", property_get_uint64_ptr,
                         NULL, NULL, (void *)v, errp);
 }
 
+/*
+ * 核心思想是分配并初始化一个ObjectProperty
+ * 然后插入ObjectClass->properties (GHashTable)
+ */
 void object_class_property_add_uint64_ptr(ObjectClass *klass, const char *name,
                                           const uint64_t *v, Error **errp)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入ObjectClass->properties (GHashTable)
+     */
     object_class_property_add(klass, name, "uint64", property_get_uint64_ptr,
                               NULL, NULL, (void *)v, errp);
 }
@@ -2314,30 +3486,51 @@ typedef struct {
     char *target_name;
 } AliasProperty;
 
+/*
+ * 作为get方法:
+ *   - qom/object.c|3536| <<object_property_add_alias>> property_get_alias,
+ */
 static void property_get_alias(Object *obj, Visitor *v, const char *name,
                                void *opaque, Error **errp)
 {
     AliasProperty *prop = opaque;
 
+    /* 根据name找到ObjectProperty, 然后调用其get方法 */
     object_property_get(prop->target_obj, v, prop->target_name, errp);
 }
 
+/*
+ * 作为set方法:
+ *   - qom/object.c|3537| <<object_property_add_alias>> property_set_alias,
+ */
 static void property_set_alias(Object *obj, Visitor *v, const char *name,
                                void *opaque, Error **errp)
 {
     AliasProperty *prop = opaque;
 
+    /* 根据name找到ObjectProperty, 然后调用其set方法 */
     object_property_set(prop->target_obj, v, prop->target_name, errp);
 }
 
+/*
+ * 作为ObjectProperty的resolve方法:
+ *   - qom/object.c|3545| <<object_property_add_alias>> op->resolve = property_resolve_alias;
+ */
 static Object *property_resolve_alias(Object *obj, void *opaque,
                                       const gchar *part)
 {
     AliasProperty *prop = opaque;
 
+    /*
+     * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+     */
     return object_resolve_path_component(prop->target_obj, prop->target_name);
 }
 
+/*
+ * 作为release方法:
+ *   - qom/object.c|3538| <<object_property_add_alias>> property_release_alias,
+ */
 static void property_release_alias(Object *obj, const char *name, void *opaque)
 {
     AliasProperty *prop = opaque;
@@ -2346,6 +3539,10 @@ static void property_release_alias(Object *obj, const char *name, void *opaque)
     g_free(prop);
 }
 
+/*
+ * 一个调用的例子:
+ *   - hw/virtio/virtio-pci.c|1994| <<virtio_blk_pci_instance_init>> object_property_add_alias(obj, "bootindex", OBJECT(&dev->vdev),
+ */
 void object_property_add_alias(Object *obj, const char *name,
                                Object *target_obj, const char *target_name,
                                Error **errp)
@@ -2356,11 +3553,17 @@ void object_property_add_alias(Object *obj, const char *name,
     gchar *prop_type;
     Error *local_err = NULL;
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     target_prop = object_property_find(target_obj, target_name, errp);
     if (!target_prop) {
         return;
     }
 
+    /* 判断ObjectProperty的type是否开头是"child<" */
     if (object_property_is_child(target_prop)) {
         prop_type = g_strdup_printf("link%s",
                                     target_prop->type + strlen("child"));
@@ -2372,6 +3575,10 @@ void object_property_add_alias(Object *obj, const char *name,
     prop->target_obj = target_obj;
     prop->target_name = g_strdup(target_name);
 
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     */
     op = object_property_add(obj, name, prop_type,
                              property_get_alias,
                              property_set_alias,
@@ -2384,6 +3591,12 @@ void object_property_add_alias(Object *obj, const char *name,
     }
     op->resolve = property_resolve_alias;
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     * 最后修改找到的ObjectProperty的description
+     */
     object_property_set_description(obj, op->name,
                                     target_prop->description,
                                     &error_abort);
@@ -2392,11 +3605,22 @@ out:
     g_free(prop_type);
 }
 
+/*
+ * 递归调用自己的parent (ObjectClass) 寻找prop
+ * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+ * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+ * 最后修改找到的ObjectProperty的description
+ */
 void object_property_set_description(Object *obj, const char *name,
                                      const char *description, Error **errp)
 {
     ObjectProperty *op;
 
+    /*
+     * 递归调用自己的parent (ObjectClass) 寻找prop
+     * 如果没有parent或者parent都没有, 在当前ObjectClass的properties (HashTable) 寻找
+     * 如果ObjectClass没有就在Object的properties (HashTable) 寻找
+     */
     op = object_property_find(obj, name, errp);
     if (!op) {
         return;
@@ -2406,6 +3630,10 @@ void object_property_set_description(Object *obj, const char *name,
     op->description = g_strdup(description);
 }
 
+/*
+ * 从ObjectClass(不是Object)的properties中寻找name的ObjectProperty
+ * 找到后重新设置ObjectProperty的description
+ */
 void object_class_property_set_description(ObjectClass *klass,
                                            const char *name,
                                            const char *description,
@@ -2423,11 +3651,30 @@ void object_class_property_set_description(ObjectClass *klass,
     op->description = g_strdup(description);
 }
 
+/*
+ * TypeInfo object_info.instance_init = object_instance_init()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void object_instance_init(Object *obj)
 {
+    /*
+     * 核心思想是分配并初始化一个ObjectProperty
+     * 然后插入Object->properties (GHashTable)
+     *     get     = property_get_str()
+     *     set     = property_set_str()
+     *     release = property_release_str()
+     *
+     *  qdev_get_type()就是返回obj->class->type->name
+     */
     object_property_add_str(obj, "type", qdev_get_type, NULL, NULL);
 }
 
+/*
+ * 在以下被间接调用:
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ */
 static void register_types(void)
 {
     static TypeInfo interface_info = {
@@ -2443,8 +3690,31 @@ static void register_types(void)
         .abstract = true,
     };
 
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_interface = type_register_internal(&interface_info);
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_internal(&object_info);
 }
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ *
+ * 所有注册的module_init_type在以下调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * module_call_init()遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
 type_init(register_types)
diff --git a/qom/object_interfaces.c b/qom/object_interfaces.c
index 72b97a8..c1ccd33 100644
--- a/qom/object_interfaces.c
+++ b/qom/object_interfaces.c
@@ -168,6 +168,9 @@ void user_creatable_del(const char *id, Error **errp)
     Object *obj;
 
     container = object_get_objects_root();
+    /*
+     * 从parent(Object)的properties(HashTable)中寻找part代表的prop, 返回其Object
+     */
     obj = object_resolve_path_component(container, id);
     if (!obj) {
         error_setg(errp, "object '%s' not found", id);
diff --git a/qom/qom-qobject.c b/qom/qom-qobject.c
index 4aec20d..195cca2 100644
--- a/qom/qom-qobject.c
+++ b/qom/qom-qobject.c
@@ -18,16 +18,47 @@
 #include "qapi/qobject-input-visitor.h"
 #include "qapi/qobject-output-visitor.h"
 
+/*
+ * called by:
+ *   - qmp.c|235| <<qmp_qom_set>> object_property_set_qobject(obj, value, property, errp);
+ *   - qom/object.c|1650| <<object_property_set_str>> object_property_set_qobject(obj, QOBJECT(qstr), name, errp);
+ *   - qom/object.c|1708| <<object_property_set_bool>> object_property_set_qobject(obj, QOBJECT(qbool), name, errp);
+ *   - qom/object.c|1739| <<object_property_set_int>> object_property_set_qobject(obj, QOBJECT(qnum), name, errp);
+ *   - qom/object.c|1770| <<object_property_set_uint>> object_property_set_qobject(obj, QOBJECT(qnum), name, errp);
+ *   - target/i386/cpu.c|3696| <<object_apply_props>> object_property_set_qobject(obj, qdict_entry_value(prop),
+ */
 void object_property_set_qobject(Object *obj, QObject *value,
                                  const char *name, Error **errp)
 {
     Visitor *v;
 
+    /*
+     * 分配一个QObjectInputVisitor(包含Visitor)并初始化, 其中的root是value(QObject)
+     * 返回包含的Visitor
+     */
     v = qobject_input_visitor_new(value);
+    /*
+     * 据name找到ObjectProperty, 然后调用其set方法
+     */
     object_property_set(obj, v, name, errp);
     visit_free(v);
 }
 
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|196| <<acpi_get_pm_info>> o = object_property_get_qobject(obj, ACPI_PM_PROP_S3_DISABLED, NULL);
+ *   - hw/i386/acpi-build.c|203| <<acpi_get_pm_info>> o = object_property_get_qobject(obj, ACPI_PM_PROP_S4_DISABLED, NULL);
+ *   - hw/i386/acpi-build.c|210| <<acpi_get_pm_info>> o = object_property_get_qobject(obj, ACPI_PM_PROP_S4_VAL, NULL);
+ *   - hw/i386/acpi-build.c|438| <<build_append_pci_bus_devices>> bsel = object_property_get_qobject(OBJECT(bus), ACPI_PCIHP_PROP_BSEL, NULL);
+ *   - hw/i386/acpi-build.c|2617| <<acpi_get_mcfg>> o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_BASE, NULL);
+ *   - hw/i386/acpi-build.c|2624| <<acpi_get_mcfg>> o = object_property_get_qobject(pci_host, PCIE_HOST_MCFG_SIZE, NULL);
+ *   - qmp.c|249| <<qmp_qom_get>> return object_property_get_qobject(obj, property, errp);
+ *   - qom/object.c|1658| <<object_property_get_str>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - qom/object.c|1716| <<object_property_get_bool>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - qom/object.c|1747| <<object_property_get_int>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - qom/object.c|1777| <<object_property_get_uint>> QObject *ret = object_property_get_qobject(obj, name, errp);
+ *   - target/i386/cpu.c|3642| <<x86_cpu_expand_prop>> QObject *value = object_property_get_qobject(OBJECT(cpu), prop,
+ */
 QObject *object_property_get_qobject(Object *obj, const char *name,
                                      Error **errp)
 {
@@ -36,6 +67,9 @@ QObject *object_property_get_qobject(Object *obj, const char *name,
     Visitor *v;
 
     v = qobject_output_visitor_new(&ret);
+    /*
+     * 根据name找到ObjectProperty, 然后调用其get方法
+     */
     object_property_get(obj, v, name, &local_err);
     if (!local_err) {
         visit_complete(v, &ret);
diff --git a/target/i386/kvm.c b/target/i386/kvm.c
index 9313602..a260ff1 100644
--- a/target/i386/kvm.c
+++ b/target/i386/kvm.c
@@ -1374,6 +1374,10 @@ static void register_smram_listener(Notifier *n, void *unused)
                                  &smram_address_space, 1);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1677| <<kvm_init>> ret = kvm_arch_init(ms, s);
+ */
 int kvm_arch_init(MachineState *ms, KVMState *s)
 {
     uint64_t identity_base = 0xfffbc000;
diff --git a/util/module.c b/util/module.c
index c909737..4a9b8ec 100644
--- a/util/module.c
+++ b/util/module.c
@@ -32,34 +32,64 @@ typedef QTAILQ_HEAD(, ModuleEntry) ModuleTypeList;
 
 static ModuleTypeList init_type_list[MODULE_INIT_MAX];
 
+/*
+ * used by:
+ *   - util/module.c|58| <<init_lists>> QTAILQ_INIT(&dso_init_list);
+ *   - util/module.c|115| <<register_dso_module_init>> QTAILQ_INSERT_TAIL(&dso_init_list, e, node);
+ *   - util/module.c|163| <<module_load_file>> assert(QTAILQ_EMPTY(&dso_init_list));
+ *   - util/module.c|184| <<module_load_file>> QTAILQ_FOREACH(e, &dso_init_list, node) {
+ *   - util/module.c|191| <<module_load_file>> QTAILQ_FOREACH_SAFE(e, &dso_init_list, node, next) {
+ *   - util/module.c|192| <<module_load_file>> QTAILQ_REMOVE(&dso_init_list, e, node);
+ */
 static ModuleTypeList dso_init_list;
 
+/*
+ * called by:
+ *   - util/module.c|58| <<find_type>> init_lists();
+ *   - util/module.c|81| <<register_dso_module_init>> init_lists();
+ *
+ * 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化)
+ */
 static void init_lists(void)
 {
     static int inited;
     int i;
 
+    /* 静态变量只在这个函数修改 如果是1说明初始化过了 */
     if (inited) {
         return;
     }
 
     for (i = 0; i < MODULE_INIT_MAX; i++) {
-        QTAILQ_INIT(&init_type_list[i]);
+        QTAILQ_INIT(&init_type_list[i]);  // 在该函数上面声明的
     }
 
-    QTAILQ_INIT(&dso_init_list);
+    QTAILQ_INIT(&dso_init_list);  // 在该函数上面声明的
 
     inited = 1;
 }
 
 
+/*
+ * called by:
+ *   - register_module_init()
+ *   - module_call_init()
+ *
+ * 返回init_type_list[type] (type最多MODULE_INIT_MAX个)
+ */
 static ModuleTypeList *find_type(module_init_type type)
 {
+    /* 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化) */
     init_lists();
 
     return &init_type_list[type];
 }
 
+/*
+ * type最多MODULE_INIT_MAX个
+ *
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[type] (type最多MODULE_INIT_MAX个)
+ */
 void register_module_init(void (*fn)(void), module_init_type type)
 {
     ModuleEntry *e;
@@ -69,15 +99,22 @@ void register_module_init(void (*fn)(void), module_init_type type)
     e->init = fn;
     e->type = type;
 
+    /* 返回init_type_list[type] (type最多MODULE_INIT_MAX个) */
     l = find_type(type);
 
     QTAILQ_INSERT_TAIL(l, e, node);
 }
 
+/*
+ * type最多MODULE_INIT_MAX个
+ *
+ * 根据fn初始化一个ModuleEntry插入到dso_init_list
+ */
 void register_dso_module_init(void (*fn)(void), module_init_type type)
 {
     ModuleEntry *e;
 
+    /* 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化) */
     init_lists();
 
     e = g_malloc0(sizeof(*e));
@@ -87,6 +124,15 @@ void register_dso_module_init(void (*fn)(void), module_init_type type)
     QTAILQ_INSERT_TAIL(&dso_init_list, e, node);
 }
 
+/*
+ * 主要的调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * 遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
 void module_call_init(module_init_type type)
 {
     ModuleTypeList *l;
@@ -100,6 +146,9 @@ void module_call_init(module_init_type type)
 }
 
 #ifdef CONFIG_MODULES
+/*
+ * called only by module_load_one()
+ */
 static int module_load_file(const char *fname)
 {
     GModule *g_module;
@@ -157,6 +206,12 @@ out:
 }
 #endif
 
+/*
+ * called by:
+ *   - include/qemu/module.h|55| <<block_module_load_one>> #define block_module_load_one(lib) module_load_one("block-", lib)
+ *   - include/qemu/module.h|56| <<ui_module_load_one>> #define ui_module_load_one(lib) module_load_one("ui-", lib)
+ *   - include/qemu/module.h|57| <<audio_module_load_one>> #define audio_module_load_one(lib) module_load_one("audio-", lib)
+ */
 void module_load_one(const char *prefix, const char *lib_name)
 {
 #ifdef CONFIG_MODULES
diff --git a/vl.c b/vl.c
index 16b913f..11e6541 100644
--- a/vl.c
+++ b/vl.c
@@ -1389,6 +1389,10 @@ static int usb_parse(const char *cmdline)
 
 MachineState *current_machine;
 
+/*
+ * called only by:
+ *   - vl.c|2564| <<machine_parse>> mc = find_machine(name);
+ */
 static MachineClass *find_machine(const char *name)
 {
     GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);
@@ -1412,6 +1416,10 @@ static MachineClass *find_machine(const char *name)
     return mc;
 }
 
+/*
+ * called only by:
+ *   - vl.c|2677| <<select_machine>> MachineClass *machine_class = find_default_machine();
+ */
 MachineClass *find_default_machine(void)
 {
     GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);
@@ -2555,6 +2563,10 @@ static gint machine_class_cmp(gconstpointer a, gconstpointer b)
                   object_class_get_name(OBJECT_CLASS(mc1)));
 }
 
+/*
+ * called by:
+ *   - vl.c|2685| <<select_machine>> machine_class = machine_parse(optarg);
+ */
  static MachineClass *machine_parse(const char *name)
 {
     MachineClass *mc = NULL;
@@ -2664,6 +2676,9 @@ static const QEMUOption *lookup_opt(int argc, char **argv,
     return popt;
 }
 
+/*
+ * 被vl.c的main()调用
+ */
 static MachineClass *select_machine(void)
 {
     MachineClass *machine_class = find_default_machine();
-- 
2.7.4

