From 338e1e8f1c27c7c149b8cd9c97edf8055411e846 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang@oracle.com>
Date: Fri, 12 Oct 2018 05:51:42 +0800
Subject: [PATCH 1/1] qemu for 3.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-all.c       |  18 ++-
 include/qemu/module.h     |  14 ++
 include/qom/object.h      |   6 +-
 linux-headers/linux/kvm.h |   4 +
 qom/object.c              | 369 +++++++++++++++++++++++++++++++++++++++++++++-
 target/i386/kvm.c         |   4 +
 util/module.c             |  59 +++++++-
 7 files changed, 467 insertions(+), 7 deletions(-)

diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index eb7db92..8ef7b78 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -1479,6 +1479,10 @@ bool kvm_vcpu_id_is_valid(int vcpu_id)
     return vcpu_id >= 0 && vcpu_id < kvm_max_vcpu_id(s);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2544| <<kvm_accel_class_init>> ac->init_machine = kvm_init;
+ */
 static int kvm_init(MachineState *ms)
 {
     MachineClass *mc = MACHINE_GET_CLASS(ms);
@@ -2537,6 +2541,9 @@ int kvm_get_one_reg(CPUState *cs, uint64_t id, void *target)
     return r;
 }
 
+/*
+ * TypeInfo kvm_accel_type.class_init = kvm_accel_class_init()
+ */
 static void kvm_accel_class_init(ObjectClass *oc, void *data)
 {
     AccelClass *ac = ACCEL_CLASS(oc);
@@ -2547,11 +2554,20 @@ static void kvm_accel_class_init(ObjectClass *oc, void *data)
 
 static const TypeInfo kvm_accel_type = {
     .name = TYPE_KVM_ACCEL,
-    .parent = TYPE_ACCEL,
+    .parent = TYPE_ACCEL,  // accel_type: class_size是AccelClass, instance_size是AccelState
     .class_init = kvm_accel_class_init,
     .instance_size = sizeof(KVMState),
 };
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
 static void kvm_type_init(void)
 {
     type_register_static(&kvm_accel_type);
diff --git a/include/qemu/module.h b/include/qemu/module.h
index 54300ab..54f79db 100644
--- a/include/qemu/module.h
+++ b/include/qemu/module.h
@@ -39,6 +39,16 @@ static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \
 }
 #endif
 
+/*
+ * 所有注册的module_init_type在以下调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * module_call_init()遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
+
 typedef enum {
     MODULE_INIT_BLOCK,
     MODULE_INIT_OPTS,
@@ -49,6 +59,10 @@ typedef enum {
 
 #define block_init(function) module_init(function, MODULE_INIT_BLOCK)
 #define opts_init(function) module_init(function, MODULE_INIT_OPTS)
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 #define type_init(function) module_init(function, MODULE_INIT_QOM)
 #define trace_init(function) module_init(function, MODULE_INIT_TRACE)
 
diff --git a/include/qom/object.h b/include/qom/object.h
index f0b0bf3..1f084d7 100644
--- a/include/qom/object.h
+++ b/include/qom/object.h
@@ -391,7 +391,7 @@ typedef void (ObjectFree)(void *obj);
 struct ObjectClass
 {
     /*< private >*/
-    Type type;
+    Type type;  // 定义typedef struct TypeImpl *Type;
     GSList *interfaces;
 
     const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE];
@@ -868,6 +868,10 @@ void type_register_static_array(const TypeInfo *infos, int nr_infos);
  * @type_array should be static constant that exists for the life time
  * that the type is registered.
  */
+/*
+ * type_register_static_array()
+ *     为nr_infos个: 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 #define DEFINE_TYPES(type_array)                                            \
 static void do_qemu_init_ ## type_array(void)                               \
 {                                                                           \
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 98f389a..b8b9320 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -754,6 +754,10 @@ struct kvm_ppc_resize_hpt {
  * ioctls for /dev/kvm fds:
  */
 #define KVM_GET_API_VERSION       _IO(KVMIO,   0x00)
+/*
+ * x86就用在:
+ *   - accel/kvm/kvm-all.c|1560| <<kvm_init>> ret = kvm_ioctl(s, KVM_CREATE_VM, type);
+ */
 #define KVM_CREATE_VM             _IO(KVMIO,   0x01) /* returns a VM fd */
 #define KVM_GET_MSR_INDEX_LIST    _IOWR(KVMIO, 0x02, struct kvm_msr_list)
 
diff --git a/qom/object.c b/qom/object.c
index 75d1d48..5235ce1 100644
--- a/qom/object.c
+++ b/qom/object.c
@@ -39,6 +39,15 @@ struct InterfaceImpl
     const char *typename;
 };
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
 struct TypeImpl
 {
     const char *name;
@@ -47,21 +56,58 @@ struct TypeImpl
 
     size_t instance_size;
 
+    /*
+     * called only by:
+     *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+     */
     void (*class_init)(ObjectClass *klass, void *data);
+    /*
+     * called only by:
+     *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+     */
     void (*class_base_init)(ObjectClass *klass, void *data);
+    /*
+     * 似乎目前不调用:
+     *   - hw/core/machine.c|868| <<global>> .class_finalize = machine_class_finalize,
+     *   - qom/object.c|69| <<global>> void (*class_finalize)(ObjectClass *klass, void *data);
+     *   - qom/object.c|179| <<type_new>> ti->class_finalize = info->class_finalize;
+     */
     void (*class_finalize)(ObjectClass *klass, void *data);
 
     void *class_data;
 
+    /*
+     * called only by:
+     *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+     */
     void (*instance_init)(Object *obj);
+    /*
+     * called only by:
+     *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+     */
     void (*instance_post_init)(Object *obj);
+    /*
+     * called only by:
+     *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+     */
     void (*instance_finalize)(Object *obj);
 
     bool abstract;
 
+    /*
+     * 在type_new()中由TypeInfo->parent获得
+     */
     const char *parent;
+    /*
+     * 设置parent_type的地方:
+     *   - qom/object.c|256| <<type_get_parent>> type->parent_type = type_get_by_name(type->parent);
+     *   - qom/object.c|334| <<type_initialize_interface>> iface_impl->parent_type = parent_type;
+     */
     TypeImpl *parent_type;
 
+    /*
+     * 在type_initialize()中分配
+     */
     ObjectClass *class;
 
     int num_interfaces;
@@ -70,6 +116,14 @@ struct TypeImpl
 
 static Type type_interface;
 
+/*
+ * called by:
+ *   - qom/object.c|89| <<type_table_add>> g_hash_table_insert(type_table_get(), (void *)ti->name, ti);
+ *   - qom/object.c|94| <<type_table_lookup>> return g_hash_table_lookup(type_table_get(), name);
+ *   - qom/object.c|889| <<object_class_foreach>> g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
+ *
+ *   如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+ */
 static GHashTable *type_table_get(void)
 {
     static GHashTable *type_table;
@@ -83,17 +137,42 @@ static GHashTable *type_table_get(void)
 
 static bool enumerating_types;
 
+/*
+ * called by only type_register_internal()
+ *
+ * 把一个根据TypeInfo转化成的TypeImpl插入到hashtable
+ */
 static void type_table_add(TypeImpl *ti)
 {
     assert(!enumerating_types);
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     g_hash_table_insert(type_table_get(), (void *)ti->name, ti);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|135| <<type_new>> if (type_table_lookup(info->name) != NULL) {
+ *   - qom/object.c|200| <<type_get_by_name>> return type_table_lookup(name);
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ */
 static TypeImpl *type_table_lookup(const char *name)
 {
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     return g_hash_table_lookup(type_table_get(), name);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|137| <<type_register_internal>> ti = type_new(info);
+ *   - qom/object.c|250| <<type_initialize_interface>> iface_impl = type_new(&info);
+ *
+ * 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了
+ */
 static TypeImpl *type_new(const TypeInfo *info)
 {
     TypeImpl *ti = g_malloc0(sizeof(*ti));
@@ -101,6 +180,7 @@ static TypeImpl *type_new(const TypeInfo *info)
 
     g_assert(info->name != NULL);
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     if (type_table_lookup(info->name) != NULL) {
         fprintf(stderr, "Registering `%s' which already exists\n", info->name);
         abort();
@@ -123,6 +203,11 @@ static TypeImpl *type_new(const TypeInfo *info)
 
     ti->abstract = info->abstract;
 
+    /*
+     * TypeImpl包含:
+     *       int num_interfaces;
+     *       InterfaceImpl interfaces[MAX_INTERFACES]; --> 包含const char *typename;
+     */
     for (i = 0; info->interfaces && info->interfaces[i].type; i++) {
         ti->interfaces[i].typename = g_strdup(info->interfaces[i].type);
     }
@@ -131,47 +216,99 @@ static TypeImpl *type_new(const TypeInfo *info)
     return ti;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|191| <<type_register>> return type_register_internal(info);
+ *   - qom/object.c|2503| <<register_types>> type_interface = type_register_internal(&interface_info);
+ *   - qom/object.c|2504| <<register_types>> type_register_internal(&object_info);
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 static TypeImpl *type_register_internal(const TypeInfo *info)
 {
     TypeImpl *ti;
+    /* 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 */
     ti = type_new(info);
 
+    /* 把一个根据TypeInfo转化成的TypeImpl插入到hashtable */
     type_table_add(ti);
     return ti;
 }
 
+/*
+ * 被外部好多好多调用
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 TypeImpl *type_register(const TypeInfo *info)
 {
     assert(info->parent);
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     return type_register_internal(info);
 }
 
+/*
+ * 被外部好多好多调用
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 TypeImpl *type_register_static(const TypeInfo *info)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     return type_register(info);
 }
 
+/*
+ * 为nr_infos个: 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 void type_register_static_array(const TypeInfo *infos, int nr_infos)
 {
     int i;
 
     for (i = 0; i < nr_infos; i++) {
+        /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
         type_register_static(&infos[i]);
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|245| <<type_get_parent>> type->parent_type = type_get_by_name(type->parent);
+ *   - qom/object.c|285| <<object_type_get_instance_size>> TypeImpl *type = type_get_by_name(typename);
+ *   - qom/object.c|383| <<type_initialize>> TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);
+ *   - qom/object.c|461| <<object_initialize>> TypeImpl *type = type_get_by_name(typename);
+ *   - qom/object.c|625| <<object_new>> TypeImpl *ti = type_get_by_name(typename);
+ *   - qom/object.c|801| <<object_class_dynamic_cast>> target_type = type_get_by_name(typename);
+ *   - qom/object.c|899| <<object_class_by_name>> TypeImpl *type = type_get_by_name(typename);
+ */
 static TypeImpl *type_get_by_name(const char *name)
 {
     if (name == NULL) {
         return NULL;
     }
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     return type_table_lookup(name);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|283| <<type_class_get_size>> return type_class_get_size(type_get_parent(ti));
+ *   - qom/object.c|296| <<type_object_get_size>> return type_object_get_size(type_get_parent(ti));
+ *   - qom/object.c|321| <<type_is_ancestor>> type = type_get_parent(type);
+ *   - qom/object.c|383| <<type_initialize>> parent = type_get_parent(ti);
+ *   - qom/object.c|430| <<type_initialize>> parent = type_get_parent(parent);
+ *   - qom/object.c|441| <<object_init_with_type>> object_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|456| <<object_post_init_with_type>> object_post_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|613| <<object_deinit>> object_deinit(obj, type_get_parent(type));
+ *   - qom/object.c|937| <<object_class_get_parent>> TypeImpl *type = type_get_parent(class->type);
+ *
+ * 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+ */
 static TypeImpl *type_get_parent(TypeImpl *type)
 {
     if (!type->parent_type && type->parent) {
+        /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
         type->parent_type = type_get_by_name(type->parent);
         g_assert(type->parent_type != NULL);
     }
@@ -179,45 +316,95 @@ static TypeImpl *type_get_parent(TypeImpl *type)
     return type->parent_type;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|296| <<type_class_get_size>> if (type_has_parent(ti)) {
+ *   - qom/object.c|309| <<type_object_get_size>> if (type_has_parent(ti)) {
+ *   - qom/object.c|457| <<object_init_with_type>> if (type_has_parent(ti)) {
+ *   - qom/object.c|475| <<object_post_init_with_type>> if (type_has_parent(ti)) {
+ *   - qom/object.c|635| <<object_deinit>> if (type_has_parent(type)) {
+ *
+ * 检查TypeImpl是否有parent
+ */
 static bool type_has_parent(TypeImpl *type)
 {
     return (type->parent != NULL);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|308| <<type_class_get_size>> return type_class_get_size(type_get_parent(ti));
+ *   - qom/object.c|399| <<type_initialize>> ti->class_size = type_class_get_size(ti);
+ *
+ * 如果TypeImpl有class_size返回class_size
+ * 其次递归调用自己返回parent的size
+ * 最后没办法了返回sizeof(ObjectClass)
+ */
 static size_t type_class_get_size(TypeImpl *ti)
 {
     if (ti->class_size) {
         return ti->class_size;
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
-        return type_class_get_size(type_get_parent(ti));
+        /* 这里递归调用 继续返回parent的TypeImpl的class_size */
+        return type_class_get_size(type_get_parent(ti)); // 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
     }
 
     return sizeof(ObjectClass);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|338| <<type_object_get_size>> return type_object_get_size(type_get_parent(ti));
+ *   - qom/object.c|350| <<object_type_get_instance_size>> return type_object_get_size(type);
+ *   - qom/object.c|421| <<type_initialize>> ti->instance_size = type_object_get_size(ti);
+ *
+ * 如果TypeImpl有instance_size返回instance_size
+ * 其次递归调用自己返回parent的object size
+ * 最后没办法了返回0
+ */
 static size_t type_object_get_size(TypeImpl *ti)
 {
     if (ti->instance_size) {
         return ti->instance_size;
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
-        return type_object_get_size(type_get_parent(ti));
+	    /* 这里递归调用 继续返回parent的TypeImpl的instance_size */
+        return type_object_get_size(type_get_parent(ti)); // 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
     }
 
     return 0;
 }
 
+/*
+ * hw/ppc/pnv.c中调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 如果TypeImpl有instance_size返回instance_size
+ * 其次递归调用自己返回parent的object size
+ * 最后没办法了返回0
+ */
 size_t object_type_get_instance_size(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
     g_assert(type != NULL);
+    /*
+     * 如果TypeImpl有instance_size返回instance_size
+     * 其次递归调用自己返回parent的object size
+     * 最后没办法了返回0
+     */
     return type_object_get_size(type);
 }
 
+/*
+ * 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+ */
 static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
 {
     assert(target_type);
@@ -228,6 +415,7 @@ static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
             return true;
         }
 
+	/* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
         type = type_get_parent(type);
     }
 
@@ -236,6 +424,11 @@ static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
 
 static void type_initialize(TypeImpl *ti);
 
+/*
+ * called by:
+ *   - qom/object.c|474| <<type_initialize>> type_initialize_interface(ti, iface->interface_type, klass->type);
+ *   - qom/object.c|493| <<type_initialize>> type_initialize_interface(ti, t, t);
+ */
 static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
                                       TypeImpl *parent_type)
 {
@@ -247,6 +440,7 @@ static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
     info.name = g_strdup_printf("%s::%s", ti->name, interface_type->name);
     info.abstract = true;
 
+    /* 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 */
     iface_impl = type_new(&info);
     iface_impl->parent_type = parent_type;
     type_initialize(iface_impl);
@@ -256,10 +450,17 @@ static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
     new_iface->concrete_class = ti->class;
     new_iface->interface_type = interface_type;
 
+    /* 把TypeImpl挂载到ti->class->interfaces */
     ti->class->interfaces = g_slist_append(ti->class->interfaces,
                                            iface_impl->class);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|468| <<type_initialize>> g_str_hash, g_str_equal, g_free, object_property_free);
+ *   - qom/object.c|497| <<type_initialize>> g_str_hash, g_str_equal, g_free, object_property_free);
+ *   - qom/object.c|560| <<object_initialize_with_type>> NULL, object_property_free);
+ */
 static void object_property_free(gpointer data)
 {
     ObjectProperty *prop = data;
@@ -270,32 +471,67 @@ static void object_property_free(gpointer data)
     g_free(prop);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|407| <<type_initialize_interface>> type_initialize(iface_impl);
+ *   - qom/object.c|460| <<type_initialize>> type_initialize(parent);
+ *   - qom/object.c|550| <<object_initialize_with_type>> type_initialize(type);
+ *   - qom/object.c|725| <<object_new_with_type>> type_initialize(type);
+ *   - qom/object.c|1023| <<object_class_by_name>> type_initialize(type);
+ *   - qom/object.c|1037| <<object_class_get_parent>> type_initialize(type);
+ *   - qom/object.c|1057| <<object_class_foreach_tramp>> type_initialize(type);
+ *
+ * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+ * 调用.class_init()
+ */
 static void type_initialize(TypeImpl *ti)
 {
     TypeImpl *parent;
 
+    /* ti->class是ObjectClass, 如果已经初始化了就退出 */
     if (ti->class) {
         return;
     }
 
+    /*
+     * 如果TypeImpl有class_size返回class_size
+     * 其次递归调用自己返回parent的size
+     * 最后没办法了返回sizeof(ObjectClass)
+     */
     ti->class_size = type_class_get_size(ti);
+    /*
+     * 如果TypeImpl有instance_size返回instance_size
+     * 其次递归调用自己返回parent的size
+     * 最后没办法了返回0
+     */
     ti->instance_size = type_object_get_size(ti);
     /* Any type with zero instance_size is implicitly abstract.
      * This means interface types are all abstract.
      */
+    /* 没有instance_size的就是abstract */
     if (ti->instance_size == 0) {
         ti->abstract = true;
     }
 
     ti->class = g_malloc0(ti->class_size);
 
+    /* 返回TypeImpl的parent_type (TypeImpl), 如果没有现设置 (可以为NULL) */
     parent = type_get_parent(ti);
     if (parent) {
+        /* 递归调用自己保证祖先们都完成了初始化 */
         type_initialize(parent);
         GSList *e;
         int i;
 
+	/*
+	 * 孩子们的class_size必须比祖先小 因为包含祖先
+	 */
         g_assert(parent->class_size <= ti->class_size);
+	/*
+	 * 包含祖先的时候都在头上 所以先拷贝过来
+	 *
+	 * TypeImpl包含ObjectClass *class, 后者包含GSList *interfaces
+	 */
         memcpy(ti->class, parent->class, parent->class_size);
         ti->class->interfaces = NULL;
         ti->class->properties = g_hash_table_new_full(
@@ -303,16 +539,25 @@ static void type_initialize(TypeImpl *ti)
 
         for (e = parent->class->interfaces; e; e = e->next) {
             InterfaceClass *iface = e->data;
+	    /*
+	     * ObjectClass包含Type (定义typedef struct TypeImpl *Type)
+	     */
             ObjectClass *klass = OBJECT_CLASS(iface);
 
             type_initialize_interface(ti, iface->interface_type, klass->type);
         }
 
         for (i = 0; i < ti->num_interfaces; i++) {
+            /*
+	     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+	     *
+	     * nvme的typename的例子是INTERFACE_PCIE_DEVICE
+	     */
             TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);
             for (e = ti->class->interfaces; e; e = e->next) {
                 TypeImpl *target_type = OBJECT_CLASS(e->data)->type;
 
+		/* 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor */
                 if (type_is_ancestor(target_type, t)) {
                     break;
                 }
@@ -333,8 +578,15 @@ static void type_initialize(TypeImpl *ti)
 
     while (parent) {
         if (parent->class_base_init) {
+            /*
+	     * 实现了class_base_init的
+	     *   - hw/core/machine.c|867| <<global>> .class_base_init = machine_class_base_init,
+	     *   - hw/core/qdev.c|1108| <<global>> .class_base_init = device_class_base_init,
+	     *   - hw/pci/pci.c|2667| <<global>> .class_base_init = pci_device_class_base_init
+	     */
             parent->class_base_init(ti->class, ti->class_data);
         }
+	/* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
         parent = type_get_parent(parent);
     }
 
@@ -343,9 +595,20 @@ static void type_initialize(TypeImpl *ti)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|602| <<object_init_with_type>> object_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|641| <<object_initialize_with_type>> object_init_with_type(obj, type);
+ *
+ * 调用TypeImpl的instance_init(), 如果有parent递归"先"调用parent的instance_init()
+ */
 static void object_init_with_type(Object *obj, TypeImpl *ti)
 {
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
+        /*
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_init_with_type(obj, type_get_parent(ti));
     }
 
@@ -354,22 +617,44 @@ static void object_init_with_type(Object *obj, TypeImpl *ti)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|621| <<object_post_init_with_type>> object_post_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|642| <<object_initialize_with_type>> object_post_init_with_type(obj, type);
+ *
+ * 调用TypeImpl的instance_post_init(obj), 如果有parent"再"递归调用parent的instance_post_init(obj)
+ */
 static void object_post_init_with_type(Object *obj, TypeImpl *ti)
 {
     if (ti->instance_post_init) {
         ti->instance_post_init(obj);
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
+        /* 
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_post_init_with_type(obj, type_get_parent(ti));
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|650| <<object_initialize>> object_initialize_with_type(data, size, type);
+ *   - qom/object.c|816| <<object_new_with_type>> object_initialize_with_type(obj, type->instance_size, type);
+ *
+ * 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 static void object_initialize_with_type(void *data, size_t size, TypeImpl *type)
 {
     Object *obj = data;
 
     g_assert(type != NULL);
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     g_assert(type->instance_size >= sizeof(Object));
@@ -381,14 +666,24 @@ static void object_initialize_with_type(void *data, size_t size, TypeImpl *type)
     object_ref(obj);
     obj->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
                                             NULL, object_property_free);
+    /* 调用TypeImpl的instance_init(), 如果有parent递归"先"调用parent的instance_init() */
     object_init_with_type(obj, type);
+    /* 调用TypeImpl的instance_post_init(obj), 如果有parent"再"递归调用parent的instance_post_init(obj) */
     object_post_init_with_type(obj, type);
 }
 
+/*
+ * 被一群外部的调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 void object_initialize(void *data, size_t size, const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
+    /* 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init() */
     object_initialize_with_type(data, size, type);
 }
 
@@ -516,11 +811,18 @@ static void object_deinit(Object *obj, TypeImpl *type)
         type->instance_finalize(obj);
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(type)) {
+        /*
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_deinit(obj, type_get_parent(type));
     }
 }
 
+/*
+ * called only by object_unref()
+ */
 static void object_finalize(void *data)
 {
     Object *obj = data;
@@ -535,28 +837,49 @@ static void object_finalize(void *data)
     }
 }
 
+/*
+ * called only by object_new()
+ *
+ * Type的定义: typedef struct TypeImpl *Type
+ */
 static Object *object_new_with_type(Type type)
 {
     Object *obj;
 
     g_assert(type != NULL);
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     obj = g_malloc(type->instance_size);
+    /* 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init() */
     object_initialize_with_type(obj, type->instance_size, type);
     obj->free = g_free;
 
     return obj;
 }
 
+/*
+ * 被一群外部调用
+ */
 Object *object_new(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *ti = type_get_by_name(typename);
 
     return object_new_with_type(ti);
 }
 
 
+/*
+ * called by:
+ *   - hw/misc/auxbus.c|70| <<aux_init_bus>> auxtoi2c = object_new_with_props(TYPE_AUXTOI2C, OBJECT(bus), "i2c",
+ *   - iothread.c|366| <<iothread_create>> obj = object_new_with_props(TYPE_IOTHREAD,
+ *   - ui/vnc.c|3539| <<vnc_display_create_creds>> creds = object_new_with_props(TYPE_QCRYPTO_TLS_CREDS_X509,
+ *   - ui/vnc.c|3548| <<vnc_display_create_creds>> creds = object_new_with_props(TYPE_QCRYPTO_TLS_CREDS_ANON,
+ */
 Object *object_new_with_props(const char *typename,
                               Object *parent,
                               const char *id,
@@ -727,12 +1050,16 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
         return class;
     }
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     target_type = type_get_by_name(typename);
     if (!target_type) {
         /* target class type unknown, so fail the cast */
         return NULL;
     }
 
+    /*
+     * type_is_ancestor(): 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+     */
     if (type->class->interfaces &&
             type_is_ancestor(target_type, type_interface)) {
         int found = 0;
@@ -741,6 +1068,7 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
         for (i = class->interfaces; i; i = i->next) {
             ObjectClass *target_class = i->data;
 
+	    /* 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor */
             if (type_is_ancestor(target_class->type, target_type)) {
                 ret = target_class;
                 found++;
@@ -751,7 +1079,7 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
         if (found > 1) {
             ret = NULL;
         }
-    } else if (type_is_ancestor(type, target_type)) {
+    } else if (type_is_ancestor(type, target_type)) {  // 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
         ret = class;
     }
 
@@ -825,6 +1153,7 @@ const char *object_class_get_name(ObjectClass *klass)
 
 ObjectClass *object_class_by_name(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
     if (!type) {
@@ -838,6 +1167,7 @@ ObjectClass *object_class_by_name(const char *typename)
 
 ObjectClass *object_class_get_parent(ObjectClass *class)
 {
+    /* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
     TypeImpl *type = type_get_parent(class->type);
 
     if (!type) {
@@ -886,6 +1216,9 @@ void object_class_foreach(void (*fn)(ObjectClass *klass, void *opaque),
     OCFData data = { fn, implements_type, include_abstract, opaque };
 
     enumerating_types = true;
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
     enumerating_types = false;
 }
@@ -2423,11 +2756,18 @@ void object_class_property_set_description(ObjectClass *klass,
     op->description = g_strdup(description);
 }
 
+/*
+ * TypeInfo object_info.instance_init = object_instance_init()
+ */
 static void object_instance_init(Object *obj)
 {
     object_property_add_str(obj, "type", qdev_get_type, NULL, NULL);
 }
 
+/*
+ * 在以下被间接调用:
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ */
 static void register_types(void)
 {
     static TypeInfo interface_info = {
@@ -2443,8 +2783,31 @@ static void register_types(void)
         .abstract = true,
     };
 
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_interface = type_register_internal(&interface_info);
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_internal(&object_info);
 }
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ *
+ * 所有注册的module_init_type在以下调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * module_call_init()遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
 type_init(register_types)
diff --git a/target/i386/kvm.c b/target/i386/kvm.c
index 9313602..a260ff1 100644
--- a/target/i386/kvm.c
+++ b/target/i386/kvm.c
@@ -1374,6 +1374,10 @@ static void register_smram_listener(Notifier *n, void *unused)
                                  &smram_address_space, 1);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1677| <<kvm_init>> ret = kvm_arch_init(ms, s);
+ */
 int kvm_arch_init(MachineState *ms, KVMState *s)
 {
     uint64_t identity_base = 0xfffbc000;
diff --git a/util/module.c b/util/module.c
index c909737..4a9b8ec 100644
--- a/util/module.c
+++ b/util/module.c
@@ -32,34 +32,64 @@ typedef QTAILQ_HEAD(, ModuleEntry) ModuleTypeList;
 
 static ModuleTypeList init_type_list[MODULE_INIT_MAX];
 
+/*
+ * used by:
+ *   - util/module.c|58| <<init_lists>> QTAILQ_INIT(&dso_init_list);
+ *   - util/module.c|115| <<register_dso_module_init>> QTAILQ_INSERT_TAIL(&dso_init_list, e, node);
+ *   - util/module.c|163| <<module_load_file>> assert(QTAILQ_EMPTY(&dso_init_list));
+ *   - util/module.c|184| <<module_load_file>> QTAILQ_FOREACH(e, &dso_init_list, node) {
+ *   - util/module.c|191| <<module_load_file>> QTAILQ_FOREACH_SAFE(e, &dso_init_list, node, next) {
+ *   - util/module.c|192| <<module_load_file>> QTAILQ_REMOVE(&dso_init_list, e, node);
+ */
 static ModuleTypeList dso_init_list;
 
+/*
+ * called by:
+ *   - util/module.c|58| <<find_type>> init_lists();
+ *   - util/module.c|81| <<register_dso_module_init>> init_lists();
+ *
+ * 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化)
+ */
 static void init_lists(void)
 {
     static int inited;
     int i;
 
+    /* 静态变量只在这个函数修改 如果是1说明初始化过了 */
     if (inited) {
         return;
     }
 
     for (i = 0; i < MODULE_INIT_MAX; i++) {
-        QTAILQ_INIT(&init_type_list[i]);
+        QTAILQ_INIT(&init_type_list[i]);  // 在该函数上面声明的
     }
 
-    QTAILQ_INIT(&dso_init_list);
+    QTAILQ_INIT(&dso_init_list);  // 在该函数上面声明的
 
     inited = 1;
 }
 
 
+/*
+ * called by:
+ *   - register_module_init()
+ *   - module_call_init()
+ *
+ * 返回init_type_list[type] (type最多MODULE_INIT_MAX个)
+ */
 static ModuleTypeList *find_type(module_init_type type)
 {
+    /* 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化) */
     init_lists();
 
     return &init_type_list[type];
 }
 
+/*
+ * type最多MODULE_INIT_MAX个
+ *
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[type] (type最多MODULE_INIT_MAX个)
+ */
 void register_module_init(void (*fn)(void), module_init_type type)
 {
     ModuleEntry *e;
@@ -69,15 +99,22 @@ void register_module_init(void (*fn)(void), module_init_type type)
     e->init = fn;
     e->type = type;
 
+    /* 返回init_type_list[type] (type最多MODULE_INIT_MAX个) */
     l = find_type(type);
 
     QTAILQ_INSERT_TAIL(l, e, node);
 }
 
+/*
+ * type最多MODULE_INIT_MAX个
+ *
+ * 根据fn初始化一个ModuleEntry插入到dso_init_list
+ */
 void register_dso_module_init(void (*fn)(void), module_init_type type)
 {
     ModuleEntry *e;
 
+    /* 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化) */
     init_lists();
 
     e = g_malloc0(sizeof(*e));
@@ -87,6 +124,15 @@ void register_dso_module_init(void (*fn)(void), module_init_type type)
     QTAILQ_INSERT_TAIL(&dso_init_list, e, node);
 }
 
+/*
+ * 主要的调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * 遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
 void module_call_init(module_init_type type)
 {
     ModuleTypeList *l;
@@ -100,6 +146,9 @@ void module_call_init(module_init_type type)
 }
 
 #ifdef CONFIG_MODULES
+/*
+ * called only by module_load_one()
+ */
 static int module_load_file(const char *fname)
 {
     GModule *g_module;
@@ -157,6 +206,12 @@ out:
 }
 #endif
 
+/*
+ * called by:
+ *   - include/qemu/module.h|55| <<block_module_load_one>> #define block_module_load_one(lib) module_load_one("block-", lib)
+ *   - include/qemu/module.h|56| <<ui_module_load_one>> #define ui_module_load_one(lib) module_load_one("ui-", lib)
+ *   - include/qemu/module.h|57| <<audio_module_load_one>> #define audio_module_load_one(lib) module_load_one("audio-", lib)
+ */
 void module_load_one(const char *prefix, const char *lib_name)
 {
 #ifdef CONFIG_MODULES
-- 
2.7.4

