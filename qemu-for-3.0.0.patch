From a0fe0669efcb5b2e2a556c29cb316c488bc7868f Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang@oracle.com>
Date: Fri, 12 Oct 2018 14:33:47 +0800
Subject: [PATCH 1/1] qemu for 3.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-all.c       |  18 +-
 exec.c                    |   4 +
 hw/block/nvme.            |   0
 hw/block/nvme.c           |  17 ++
 hw/core/bus.c             |  62 +++++++
 hw/core/machine.c         |  63 ++++++-
 hw/core/qdev-fw.c         |  13 ++
 hw/core/qdev.c            |  77 ++++++++
 hw/core/reset.c           |  41 +++++
 hw/i386/pc.c              |  51 ++++++
 hw/i386/pc_piix.c         |  44 +++++
 hw/i386/pc_q35.c          |  24 +++
 hw/pci/msix.c             |  15 ++
 hw/pci/pci.c              | 110 ++++++++++++
 include/exec/memory.h     |   4 +
 include/hw/boards.h       |   9 +
 include/hw/i386/pc.h      |  20 ++-
 include/hw/pci/pci.h      |   7 +
 include/hw/pci/pci_bus.h  |   1 +
 include/hw/qdev-core.h    |  10 ++
 include/qemu/module.h     |  14 ++
 include/qom/object.h      |  12 +-
 linux-headers/linux/kvm.h |   4 +
 memory.c                  |  75 ++++++++
 qom/object.c              | 442 +++++++++++++++++++++++++++++++++++++++++++++-
 target/i386/kvm.c         |   4 +
 util/module.c             |  59 ++++++-
 vl.c                      |  15 ++
 28 files changed, 1206 insertions(+), 9 deletions(-)
 create mode 100644 hw/block/nvme.

diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index eb7db92..8ef7b78 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -1479,6 +1479,10 @@ bool kvm_vcpu_id_is_valid(int vcpu_id)
     return vcpu_id >= 0 && vcpu_id < kvm_max_vcpu_id(s);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2544| <<kvm_accel_class_init>> ac->init_machine = kvm_init;
+ */
 static int kvm_init(MachineState *ms)
 {
     MachineClass *mc = MACHINE_GET_CLASS(ms);
@@ -2537,6 +2541,9 @@ int kvm_get_one_reg(CPUState *cs, uint64_t id, void *target)
     return r;
 }
 
+/*
+ * TypeInfo kvm_accel_type.class_init = kvm_accel_class_init()
+ */
 static void kvm_accel_class_init(ObjectClass *oc, void *data)
 {
     AccelClass *ac = ACCEL_CLASS(oc);
@@ -2547,11 +2554,20 @@ static void kvm_accel_class_init(ObjectClass *oc, void *data)
 
 static const TypeInfo kvm_accel_type = {
     .name = TYPE_KVM_ACCEL,
-    .parent = TYPE_ACCEL,
+    .parent = TYPE_ACCEL,  // accel_type: class_size是AccelClass, instance_size是AccelState
     .class_init = kvm_accel_class_init,
     .instance_size = sizeof(KVMState),
 };
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
 static void kvm_type_init(void)
 {
     type_register_static(&kvm_accel_type);
diff --git a/exec.c b/exec.c
index 4f5df07..526b7b8 100644
--- a/exec.c
+++ b/exec.c
@@ -3093,6 +3093,10 @@ static void tcg_commit(MemoryListener *listener)
     tlb_flush(cpuas->cpu);
 }
 
+/*
+ * called only by:
+ *   - exec.c|3534| <<cpu_exec_init_all>> memory_map_init();
+ */
 static void memory_map_init(void)
 {
     system_memory = g_malloc(sizeof(*system_memory));
diff --git a/hw/block/nvme. b/hw/block/nvme.
new file mode 100644
index 0000000..e69de29
diff --git a/hw/block/nvme.c b/hw/block/nvme.c
index 5e508ab..c0934cd 100644
--- a/hw/block/nvme.c
+++ b/hw/block/nvme.c
@@ -1352,6 +1352,12 @@ static const VMStateDescription nvme_vmstate = {
     .unmigratable = 1,
 };
 
+/*
+ * TypeInfo nvme_info.class_init = nvme_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void nvme_class_init(ObjectClass *oc, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(oc);
@@ -1370,6 +1376,12 @@ static void nvme_class_init(ObjectClass *oc, void *data)
     dc->vmsd = &nvme_vmstate;
 }
 
+/*
+ * TypeInfo nvme_info.instance_init = nvme_instance_init()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void nvme_instance_init(Object *obj)
 {
     NvmeCtrl *s = NVME(obj);
@@ -1393,7 +1405,12 @@ static const TypeInfo nvme_info = {
 
 static void nvme_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&nvme_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(nvme_register_types)
diff --git a/hw/core/bus.c b/hw/core/bus.c
index 4651f24..8f3d457 100644
--- a/hw/core/bus.c
+++ b/hw/core/bus.c
@@ -40,6 +40,12 @@ void qbus_set_bus_hotplug_handler(BusState *bus, Error **errp)
     qbus_set_hotplug_handler_internal(bus, OBJECT(bus), errp);
 }
 
+/*
+ * x86会用到的:
+ *   - hw/core/qdev.c|202| <<device_listener_register>> qbus_walk_children(sysbus_get_default(), NULL, NULL, device_listener_add,
+ *   - hw/core/qdev.c|276| <<qbus_reset_all>> qbus_walk_children(bus, NULL, NULL, qdev_reset_one, qbus_reset_one, NULL);
+ *   - hw/core/qdev.c|559| <<qdev_walk_children>> err = qbus_walk_children(bus, pre_devfn, pre_busfn,
+ */
 int qbus_walk_children(BusState *bus,
                        qdev_walkerfn *pre_devfn, qbus_walkerfn *pre_busfn,
                        qdev_walkerfn *post_devfn, qbus_walkerfn *post_busfn,
@@ -74,6 +80,11 @@ int qbus_walk_children(BusState *bus,
     return 0;
 }
 
+/*
+ * called by:
+ *   - hw/core/bus.c|136| <<qbus_create_inplace>> qbus_realize(bus, parent, name);
+ *   - hw/core/bus.c|144| <<qbus_create>> qbus_realize(bus, parent, name);
+ */
 static void qbus_realize(BusState *bus, DeviceState *parent, const char *name)
 {
     const char *typename = object_get_typename(OBJECT(bus));
@@ -136,10 +147,27 @@ void qbus_create_inplace(void *bus, size_t size, const char *typename,
     qbus_realize(bus, parent, name);
 }
 
+/*
+ * called by:
+ *   - hw/i2c/core.c|59| <<i2c_init_bus>> bus = I2C_BUS(qbus_create(TYPE_I2C_BUS, parent, name));
+ *   - hw/isa/isa-bus.c|66| <<isa_bus_new>> isabus = ISA_BUS(qbus_create(TYPE_ISA_BUS, dev, NULL));
+ *   - hw/misc/auxbus.c|69| <<aux_init_bus>> bus = AUX_BUS(qbus_create(TYPE_AUX_BUS, parent, name));
+ *   - hw/pci/pci.c|410| <<pci_root_bus_new>> bus = PCI_BUS(qbus_create(typename, parent, name));
+ *   - hw/ppc/spapr_vio.c|558| <<spapr_vio_bus_init>> qbus = qbus_create(TYPE_SPAPR_VIO_BUS, dev, "spapr-vio");
+ *   - hw/s390x/css-bridge.c|107| <<virtual_css_bus_init>> bus = qbus_create(TYPE_VIRTUAL_CSS_BUS, dev, "virtual-css");
+ *   - hw/s390x/s390-pci-bus.c|714| <<s390_pcihost_init>> s->bus = S390_PCI_BUS(qbus_create(TYPE_S390_PCI_BUS, DEVICE(s), NULL));
+ *   - hw/ssi/ssi.c|106| <<ssi_create_bus>> bus = qbus_create(TYPE_SSI_BUS, parent, name);
+ *   - hw/xen/xen_backend.c|700| <<xen_be_init>> xen_sysbus = qbus_create(TYPE_XENSYSBUS, DEVICE(xen_sysdev), "xen-sysbus");
+ */
 BusState *qbus_create(const char *typename, DeviceState *parent, const char *name)
 {
     BusState *bus;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     bus = BUS(object_new(typename));
     qbus_realize(bus, parent, name);
 
@@ -188,6 +216,9 @@ static void bus_set_realized(Object *obj, bool value, Error **errp)
     bus->realized = value;
 }
 
+/*
+ * TypeInfo bus_info.instance_init = qbus_initfn()
+ */
 static void qbus_initfn(Object *obj)
 {
     BusState *bus = BUS(obj);
@@ -208,14 +239,24 @@ static char *default_bus_get_fw_dev_path(DeviceState *dev)
     return g_strdup(object_get_typename(OBJECT(dev)));
 }
 
+/*
+ * TypeInfo bus_info.class_init = bus_class_init()
+ */
 static void bus_class_init(ObjectClass *class, void *data)
 {
     BusClass *bc = BUS_CLASS(class);
 
+    /*
+     * Called when an object is being removed from the QOM composition tree.
+     * The function should remove any backlinks from children objects to @obj.
+     */
     class->unparent = bus_unparent;
     bc->get_fw_dev_path = default_bus_get_fw_dev_path;
 }
 
+/*
+ * TypeInfo bus_info.instance_finalize = qbus_finalize()
+ */
 static void qbus_finalize(Object *obj)
 {
     BusState *bus = BUS(obj);
@@ -229,14 +270,35 @@ static const TypeInfo bus_info = {
     .instance_size = sizeof(BusState),
     .abstract = true,
     .class_size = sizeof(BusClass),
+    /*
+     * called only by:
+     *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+     */
     .instance_init = qbus_initfn,
+    /*
+     * called only by:
+     *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+     */
     .instance_finalize = qbus_finalize,
+    /*
+     * called only by:
+     *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+     */
     .class_init = bus_class_init,
 };
 
 static void bus_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&bus_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(bus_register_types)
diff --git a/hw/core/machine.c b/hw/core/machine.c
index a9aeb22..af2a948 100644
--- a/hw/core/machine.c
+++ b/hw/core/machine.c
@@ -22,6 +22,11 @@
 #include "qemu/error-report.h"
 #include "sysemu/qtest.h"
 
+/*
+ * used by machine_class_init():
+ *   548     object_class_property_add_str(oc, "accel",
+ *   549         machine_get_accel, machine_set_accel, &error_abort);
+ */
 static char *machine_get_accel(Object *obj, Error **errp)
 {
     MachineState *ms = MACHINE(obj);
@@ -29,6 +34,11 @@ static char *machine_get_accel(Object *obj, Error **errp)
     return g_strdup(ms->accel);
 }
 
+/*
+ * used by machine_class_init():
+ *   548     object_class_property_add_str(oc, "accel",
+ *   549         machine_get_accel, machine_set_accel, &error_abort);
+ */
 static void machine_set_accel(Object *obj, const char *value, Error **errp)
 {
     MachineState *ms = MACHINE(obj);
@@ -37,6 +47,12 @@ static void machine_set_accel(Object *obj, const char *value, Error **errp)
     ms->accel = g_strdup(value);
 }
 
+/*
+ * used by machine_class_init():
+ *   545     object_class_property_add(oc, "kernel-irqchip", "on|off|split",
+ *   546         NULL, machine_set_kernel_irqchip, 
+ *   547         NULL, NULL, &error_abort);
+ */
 static void machine_set_kernel_irqchip(Object *obj, Visitor *v,
                                        const char *name, void *opaque,
                                        Error **errp)
@@ -517,6 +533,12 @@ void machine_set_cpu_numa_node(MachineState *machine,
     }
 }
 
+/*
+ * TypeInfo machine_info.class_init = machine_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
@@ -636,6 +658,12 @@ static void machine_class_init(ObjectClass *oc, void *data)
         "Set memory encyption object to use", &error_abort);
 }
 
+/*
+ * TypeInfo machine_info.class_base_init = machine_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void machine_class_base_init(ObjectClass *oc, void *data)
 {
     if (!object_class_is_abstract(oc)) {
@@ -647,6 +675,12 @@ static void machine_class_base_init(ObjectClass *oc, void *data)
     }
 }
 
+/*
+ * TypeInfo machine_info.instance_init = machine_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+ */
 static void machine_initfn(Object *obj)
 {
     MachineState *ms = MACHINE(obj);
@@ -662,6 +696,12 @@ static void machine_initfn(Object *obj)
     qemu_add_machine_init_done_notifier(&ms->sysbus_notifier);
 }
 
+/*
+ * TypeInfo machine_info.instance_finalize = machine_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void machine_finalize(Object *obj)
 {
     MachineState *ms = MACHINE(obj);
@@ -788,6 +828,10 @@ static void machine_numa_finish_cpu_init(MachineState *machine)
     g_string_free(s, true);
 }
 
+/*
+ * called only by:
+ *   - vl.c|4516| <<main>> machine_run_board_init(current_machine);
+ */
 void machine_run_board_init(MachineState *machine)
 {
     MachineClass *machine_class = MACHINE_GET_CLASS(machine);
@@ -830,6 +874,14 @@ void machine_run_board_init(MachineState *machine)
     machine_class->init(machine);
 }
 
+/*
+ * TypeInfo machine_info.class_finalize = machine_class_finalize()
+ *
+ * 似乎目前不调用:
+ *   - hw/core/machine.c|868| <<global>> .class_finalize = machine_class_finalize,
+ *   - qom/object.c|69| <<global>> void (*class_finalize)(ObjectClass *klass, void *data);
+ *   - qom/object.c|179| <<type_new>> ti->class_finalize = info->class_finalize;
+ */
 static void machine_class_finalize(ObjectClass *klass, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(klass);
@@ -859,7 +911,7 @@ void machine_register_compat_props(MachineState *machine)
 }
 
 static const TypeInfo machine_info = {
-    .name = TYPE_MACHINE,
+    .name = TYPE_MACHINE,  // 还有孩子TYPE_PC_MACHINE
     .parent = TYPE_OBJECT,
     .abstract = true,
     .class_size = sizeof(MachineClass),
@@ -873,7 +925,16 @@ static const TypeInfo machine_info = {
 
 static void machine_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&machine_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(machine_register_types)
diff --git a/hw/core/qdev-fw.c b/hw/core/qdev-fw.c
index aa35e9d..ea88689 100644
--- a/hw/core/qdev-fw.c
+++ b/hw/core/qdev-fw.c
@@ -30,6 +30,10 @@ const char *qdev_fw_name(DeviceState *dev)
     return object_get_typename(OBJECT(dev));
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev-fw.c|72| <<qdev_get_fw_dev_path_helper>> d = bus_get_fw_dev_path(dev->parent_bus, dev);
+ */
 static char *bus_get_fw_dev_path(BusState *bus, DeviceState *dev)
 {
     BusClass *bc = BUS_GET_CLASS(bus);
@@ -60,6 +64,11 @@ char *qdev_get_own_fw_dev_path_from_handler(BusState *bus, DeviceState *dev)
     return fw_path_provider_try_get_dev_path(obj, bus, dev);
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev-fw.c|69| <<qdev_get_fw_dev_path_helper>> l = qdev_get_fw_dev_path_helper(dev->parent_bus->parent, p, size);
+ *   - hw/core/qdev-fw.c|91| <<qdev_get_fw_dev_path>> l = qdev_get_fw_dev_path_helper(dev, path, 128);
+ */
 static int qdev_get_fw_dev_path_helper(DeviceState *dev, char *p, int size)
 {
     int l = 0;
@@ -83,6 +92,10 @@ static int qdev_get_fw_dev_path_helper(DeviceState *dev, char *p, int size)
     return l;
 }
 
+/*
+ * called only by:
+ *   - bootdevice.c|224| <<get_boot_devices_list>> devpath = qdev_get_fw_dev_path(i->dev);
+ */
 char *qdev_get_fw_dev_path(DeviceState *dev)
 {
     char path[128];
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index 529b82d..27d95a1 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -68,6 +68,10 @@ static void bus_remove_child(BusState *bus, DeviceState *child)
     }
 }
 
+/*
+ * called only by:
+ *   - hw/core/qdev.c|107| <<qdev_set_parent_bus>> bus_add_child(bus, dev);
+ */
 static void bus_add_child(BusState *bus, DeviceState *child)
 {
     char name[32];
@@ -89,6 +93,9 @@ static void bus_add_child(BusState *bus, DeviceState *child)
                              NULL);
 }
 
+/*
+ * 被很多很多外部调用
+ */
 void qdev_set_parent_bus(DeviceState *dev, BusState *bus)
 {
     bool replugging = dev->parent_bus != NULL;
@@ -113,6 +120,9 @@ void qdev_set_parent_bus(DeviceState *dev, BusState *bus)
 /* Create a new device.  This only initializes the device state
    structure and allows properties to be set.  The device still needs
    to be realized.  See qdev-core.h.  */
+/*
+ * 被很多很多外部调用
+ */
 DeviceState *qdev_create(BusState *bus, const char *name)
 {
     DeviceState *dev;
@@ -131,13 +141,33 @@ DeviceState *qdev_create(BusState *bus, const char *name)
     return dev;
 }
 
+/*
+ * called by:
+ *   - hw/core/qdev.c|130| <<qdev_create>> dev = qdev_try_create(bus, name);
+ *   - hw/core/sysbus.c|256| <<sysbus_try_create_varargs>> dev = qdev_try_create(NULL, name);
+ *   - hw/i386/pc.c|1591| <<pc_basic_device_init>> hpet = qdev_try_create(NULL, TYPE_HPET);
+ *   - hw/isa/isa-bus.c|170| <<isa_try_create>> dev = qdev_try_create(BUS(bus), name);
+ *   - hw/s390x/s390-pci-bus.c|778| <<s390_pci_device_new>> dev = qdev_try_create(BUS(s->bus), TYPE_S390_PCI_DEVICE);
+ *   - hw/usb/bus.c|336| <<usb_try_create_simple>> dev = USB_DEVICE(qdev_try_create(&bus->qbus, name));
+ */
 DeviceState *qdev_try_create(BusState *bus, const char *type)
 {
     DeviceState *dev;
 
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     if (object_class_by_name(type) == NULL) {
         return NULL;
     }
+    /*
+     * object_new():
+     *       根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     *       确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+     *       然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     */
     dev = DEVICE(object_new(type));
     if (!dev) {
         return NULL;
@@ -540,6 +570,10 @@ BusState *qdev_get_child_bus(DeviceState *dev, const char *name)
     return NULL;
 }
 
+/*
+ * hw/core/bus.c|65| <<qbus_walk_children>> err = qdev_walk_children(kid->child,
+ * hw/core/qdev.c|266| <<qdev_reset_all>> qdev_walk_children(dev, NULL, NULL, qdev_reset_one, qbus_reset_one, NULL);
+ */
 int qdev_walk_children(DeviceState *dev,
                        qdev_walkerfn *pre_devfn, qbus_walkerfn *pre_busfn,
                        qdev_walkerfn *post_devfn, qbus_walkerfn *post_busfn,
@@ -784,6 +818,10 @@ static bool check_only_migratable(Object *obj, Error **err)
     return true;
 }
 
+/*
+ * used by:
+ *   - hw/core/qdev.c|995| <<device_initfn>> device_get_realized, device_set_realized, NULL);
+ */
 static void device_set_realized(Object *obj, bool value, Error **errp)
 {
     DeviceState *dev = DEVICE(obj);
@@ -937,6 +975,12 @@ static bool device_get_hotplugged(Object *obj, Error **err)
     return dev->hotplugged;
 }
 
+/*
+ * TypeInfo device_type_info.instance_init = device_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void device_initfn(Object *obj)
 {
     DeviceState *dev = DEVICE(obj);
@@ -974,12 +1018,24 @@ static void device_initfn(Object *obj)
     QLIST_INIT(&dev->gpios);
 }
 
+/*
+ * TypeInfo device_type_info.instance_post_init = device_post_init()
+ *
+ * called only by:
+ *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+ */
 static void device_post_init(Object *obj)
 {
     qdev_prop_set_globals(DEVICE(obj));
 }
 
 /* Unlink device from bus and free the structure.  */
+/*
+ * TypeInfo device_type_info.instance_finalize = device_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void device_finalize(Object *obj)
 {
     NamedGPIOList *ngl, *next;
@@ -1009,6 +1065,12 @@ static void device_finalize(Object *obj)
     qemu_opts_del(dev->opts);
 }
 
+/*
+ * TypeInfo device_type_info.class_base_init = device_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void device_class_base_init(ObjectClass *class, void *data)
 {
     DeviceClass *klass = DEVICE_CLASS(class);
@@ -1038,6 +1100,12 @@ static void device_unparent(Object *obj)
     }
 }
 
+/*
+ * TypeInfo device_type_info.class_init = device_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void device_class_init(ObjectClass *class, void *data)
 {
     DeviceClass *dc = DEVICE_CLASS(class);
@@ -1113,7 +1181,16 @@ static const TypeInfo device_type_info = {
 
 static void qdev_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&device_type_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(qdev_register_types)
diff --git a/hw/core/reset.c b/hw/core/reset.c
index 84c8869..563a36f 100644
--- a/hw/core/reset.c
+++ b/hw/core/reset.c
@@ -35,9 +35,25 @@ typedef struct QEMUResetEntry {
     void *opaque;
 } QEMUResetEntry;
 
+/*
+ * 添加:
+ *   - hw/core/reset.c|47| <<qemu_register_reset>> QTAILQ_INSERT_TAIL(&reset_handlers, re, entry);
+ *
+ * 删除:
+ *   - hw/core/reset.c|56| <<qemu_unregister_reset>> QTAILQ_REMOVE(&reset_handlers, re, entry);
+ *
+ * 使用:
+ *   - hw/core/reset.c|54| <<qemu_unregister_reset>> QTAILQ_FOREACH(re, &reset_handlers, entry) {
+ *   - hw/core/reset.c|68| <<qemu_devices_reset>> QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {
+ */
 static QTAILQ_HEAD(reset_handlers, QEMUResetEntry) reset_handlers =
     QTAILQ_HEAD_INITIALIZER(reset_handlers);
 
+/*
+ * 很多很多外部调用
+ *
+ * 把func(QEMUResetHandler)和opaque初始化成QEMUResetEntry, 插入reset_handlers链表
+ */
 void qemu_register_reset(QEMUResetHandler *func, void *opaque)
 {
     QEMUResetEntry *re = g_malloc0(sizeof(QEMUResetEntry));
@@ -47,6 +63,23 @@ void qemu_register_reset(QEMUResetHandler *func, void *opaque)
     QTAILQ_INSERT_TAIL(&reset_handlers, re, entry);
 }
 
+/*
+ * bootdevice.c|115| <<restore_boot_order>> qemu_unregister_reset(restore_boot_order, normal_boot_order);
+ * hw/char/serial.c|959| <<serial_exit_core>> qemu_unregister_reset(serial_reset, s);
+ * hw/core/bus.c|139| <<bus_unparent>> qemu_unregister_reset(qbus_reset_all_fn, bus);
+ * hw/core/generic-loader.c|175| <<generic_loader_unrealize>> qemu_unregister_reset(generic_loader_reset, dev);
+ * hw/i386/pc.c|438| <<pc_cmos_init_late>> qemu_unregister_reset(pc_cmos_init_late, opaque);
+ * hw/intc/xics.c|364| <<icp_unrealize>> qemu_unregister_reset(icp_reset_handler, dev);
+ * hw/ppc/pnv_core.c|192| <<pnv_unrealize_vcpu>> qemu_unregister_reset(pnv_cpu_reset, cpu);
+ * hw/ppc/spapr_cpu_core.c|118| <<spapr_unrealize_vcpu>> qemu_unregister_reset(spapr_cpu_reset, cpu);
+ * hw/ppc/spapr_cpu_core.c|239| <<spapr_realize_vcpu>> qemu_unregister_reset(spapr_cpu_reset, cpu);
+ * hw/ppc/spapr_drc.c|641| <<unrealize_physical>> qemu_unregister_reset(drc_physical_reset, drcp);
+ * hw/vfio/common.c|1363| <<vfio_put_group>> qemu_unregister_reset(vfio_reset_handler, NULL);
+ * target/i386/cpu.c|5040| <<x86_cpu_unrealizefn>> qemu_unregister_reset(x86_cpu_machine_reset_cb, dev);
+ * target/s390x/cpu.c|303| <<s390_cpu_finalize>> qemu_unregister_reset(s390_cpu_machine_reset_cb, cpu);
+ *
+ * 根据func(QEMUResetHandler)和opaque在链表reset_handlers中寻找QEMUResetEntry并删掉
+ */
 void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
 {
     QEMUResetEntry *re;
@@ -60,6 +93,14 @@ void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
     }
 }
 
+/*
+ * hw/hppa/machine.c|245| <<hppa_machine_reset>> qemu_devices_reset();
+ * hw/i386/pc.c|2282| <<pc_machine_reset>> qemu_devices_reset();
+ * hw/ppc/pnv.c|504| <<pnv_reset>> qemu_devices_reset();
+ * hw/ppc/spapr.c|1639| <<spapr_machine_reset>> qemu_devices_reset();
+ * hw/s390x/s390-virtio-ccw.c|355| <<s390_machine_reset>> qemu_devices_reset();
+ * vl.c|1647| <<qemu_system_reset>> qemu_devices_reset();
+ */
 void qemu_devices_reset(void)
 {
     QEMUResetEntry *re, *nre;
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 83a4444..dfa9a33 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1633,6 +1633,11 @@ void pc_basic_device_init(ISABus *isa_bus, qemu_irq *gsi,
     pc_superio_init(isa_bus, create_fdctrl, no_vmport);
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|244| <<pc_init1>> pc_nic_init(pcmc, isa_bus, pci_bus);
+ *   - hw/i386/pc_q35.c|277| <<pc_q35_init>> pc_nic_init(pcmc, isa_bus, host_bus);
+ */
 void pc_nic_init(PCMachineClass *pcmc, ISABus *isa_bus, PCIBus *pci_bus)
 {
     int i;
@@ -2258,6 +2263,12 @@ static void pc_machine_set_pit(Object *obj, bool value, Error **errp)
     pcms->pit = value;
 }
 
+/*
+ * TypeInfo pc_machine_info.instance_init = pc_machine_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void pc_machine_initfn(Object *obj)
 {
     PCMachineState *pcms = PC_MACHINE(obj);
@@ -2274,6 +2285,9 @@ static void pc_machine_initfn(Object *obj)
     pcms->pit = true;
 }
 
+/*
+ * 在pc_machine_class_init设置成了MachineClass mc的reset
+ */
 static void pc_machine_reset(void)
 {
     CPUState *cs;
@@ -2363,6 +2377,12 @@ static void x86_nmi(NMIState *n, int cpu_index, Error **errp)
     }
 }
 
+/*
+ * TypeInfo pc_machine_info.class_init = pc_machine_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void pc_machine_class_init(ObjectClass *oc, void *data)
 {
     MachineClass *mc = MACHINE_CLASS(oc);
@@ -2443,6 +2463,28 @@ static void pc_machine_class_init(ObjectClass *oc, void *data)
         pc_machine_get_pit, pc_machine_set_pit, &error_abort);
 }
 
+/*
+ * TYPE_PC_MACHINE is used by:
+ *   - hw/i386/x86-iommu.c|88| <<x86_iommu_realize>> PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));
+ *   - include/hw/i386/pc.h|142| <<PC_MACHINE>> OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|144| <<PC_MACHINE_GET_CLASS>> OBJECT_GET_CLASS(PCMachineClass, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|146| <<PC_MACHINE_CLASS>> OBJECT_CLASS_CHECK(PCMachineClass, (klass), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|954| <<DEFINE_PC_MACHINE>> .parent = TYPE_PC_MACHINE, \
+ *   - target/i386/kvm.c|1455| <<kvm_arch_init>> object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE) &&
+ *
+ *
+ * DEFINE_PC_MACHINE() is called by (i440x, q35, xenfv, isapc):
+ *   - hw/i386/pc_piix.c|1136| <<global>> DEFINE_PC_MACHINE(isapc, "isapc", pc_init_isa,
+ *   - hw/i386/pc_piix.c|1148| <<global>> DEFINE_PC_MACHINE(xenfv, "xenfv", pc_xen_hvm_init,
+ *   - hw/i386/pc_piix.c|417| <<DEFINE_I440FX_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *   - hw/i386/pc_q35.c|294| <<DEFINE_Q35_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *
+ * i440x: pc_init1()
+ * q35  : pc_q35_init()
+ *
+ * QEMU的默认是i440x
+ */
+
 static const TypeInfo pc_machine_info = {
     .name = TYPE_PC_MACHINE,
     .parent = TYPE_MACHINE,
@@ -2460,7 +2502,16 @@ static const TypeInfo pc_machine_info = {
 
 static void pc_machine_register_types(void)
 {
+    /*  
+     * 被外部好多好多调用
+     *
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&pc_machine_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(pc_machine_register_types)
diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index dc09466..928505b 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -66,6 +66,19 @@ static const int ide_iobase2[MAX_IDE_BUS] = { 0x3f6, 0x376 };
 static const int ide_irq[MAX_IDE_BUS] = { 14, 15 };
 
 /* PC hardware initialisation */
+/*
+ * called or used by:
+ *   - hw/i386/pc_piix.c|379| <<pc_init_isa>> pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, TYPE_I440FX_PCI_DEVICE);
+ *   - hw/i386/pc_piix.c|388| <<pc_xen_hvm_init_pci>> pc_init1(machine,
+ *   - hw/i386/pc_piix.c|445| <<DEFINE_I440FX_MACHINE>> pc_init1(machine, TYPE_I440FX_PCI_HOST_BRIDGE, \
+ *
+ * 一个例子:
+ * (gdb) bt
+ * #0  pc_init1 (machine=0x55555684f480, host_type=0x555555ea8834 "i440FX-pcihost", pci_type=0x555555ea882d "i440FX") at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:71
+ * #1  0x000055555591da26 in pc_init_v3_0 (machine=0x55555684f480) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_piix.c:438
+ * #2  0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f480) at hw/core/machine.c:830
+ * #3  0x00005555559dfb8f in main (argc=10, argv=0x7fffffffe498, envp=0x7fffffffe4f0) at vl.c:4516
+ */
 static void pc_init1(MachineState *machine,
                      const char *host_type, const char *pci_type)
 {
@@ -404,6 +417,37 @@ static void pc_xen_hvm_init(MachineState *machine)
 }
 #endif
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|438| <<global>> DEFINE_I440FX_MACHINE(v3_0, "pc-i440fx-3.0", NULL,
+ *   - hw/i386/pc_piix.c|449| <<global>> DEFINE_I440FX_MACHINE(v2_12, "pc-i440fx-2.12", NULL,
+ *   - hw/i386/pc_piix.c|458| <<global>> DEFINE_I440FX_MACHINE(v2_11, "pc-i440fx-2.11", NULL,
+ *   - hw/i386/pc_piix.c|468| <<global>> DEFINE_I440FX_MACHINE(v2_10, "pc-i440fx-2.10", NULL,
+ *   - hw/i386/pc_piix.c|478| <<global>> DEFINE_I440FX_MACHINE(v2_9, "pc-i440fx-2.9", NULL,
+ *   - hw/i386/pc_piix.c|487| <<global>> DEFINE_I440FX_MACHINE(v2_8, "pc-i440fx-2.8", NULL,
+ *   - hw/i386/pc_piix.c|497| <<global>> DEFINE_I440FX_MACHINE(v2_7, "pc-i440fx-2.7", NULL,
+ *   - hw/i386/pc_piix.c|510| <<global>> DEFINE_I440FX_MACHINE(v2_6, "pc-i440fx-2.6", NULL,
+ *   - hw/i386/pc_piix.c|523| <<global>> DEFINE_I440FX_MACHINE(v2_5, "pc-i440fx-2.5", NULL,
+ *   - hw/i386/pc_piix.c|536| <<global>> DEFINE_I440FX_MACHINE(v2_4, "pc-i440fx-2.4", NULL,
+ *   - hw/i386/pc_piix.c|547| <<global>> DEFINE_I440FX_MACHINE(v2_3, "pc-i440fx-2.3", pc_compat_2_3,
+ *   - hw/i386/pc_piix.c|560| <<global>> DEFINE_I440FX_MACHINE(v2_2, "pc-i440fx-2.2", pc_compat_2_2,
+ *   - hw/i386/pc_piix.c|575| <<global>> DEFINE_I440FX_MACHINE(v2_1, "pc-i440fx-2.1", pc_compat_2_1,
+ *   - hw/i386/pc_piix.c|608| <<global>> DEFINE_I440FX_MACHINE(v2_0, "pc-i440fx-2.0", pc_compat_2_0,
+ *   - hw/i386/pc_piix.c|625| <<global>> DEFINE_I440FX_MACHINE(v1_7, "pc-i440fx-1.7", pc_compat_1_7,
+ *   - hw/i386/pc_piix.c|639| <<global>> DEFINE_I440FX_MACHINE(v1_6, "pc-i440fx-1.6", pc_compat_1_6,
+ *   - hw/i386/pc_piix.c|650| <<global>> DEFINE_I440FX_MACHINE(v1_5, "pc-i440fx-1.5", pc_compat_1_5,
+ *   - hw/i386/pc_piix.c|662| <<global>> DEFINE_I440FX_MACHINE(v1_4, "pc-i440fx-1.4", pc_compat_1_4,
+ *   - hw/i386/pc_piix.c|694| <<global>> DEFINE_I440FX_MACHINE(v1_3, "pc-1.3", pc_compat_1_3,
+ *   - hw/i386/pc_piix.c|733| <<global>> DEFINE_I440FX_MACHINE(v1_2, "pc-1.2", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|776| <<global>> DEFINE_I440FX_MACHINE(v1_1, "pc-1.1", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|807| <<global>> DEFINE_I440FX_MACHINE(v1_0, "pc-1.0", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|821| <<global>> DEFINE_I440FX_MACHINE(v0_15, "pc-0.15", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|860| <<global>> DEFINE_I440FX_MACHINE(v0_14, "pc-0.14", pc_compat_1_2,
+ *   - hw/i386/pc_piix.c|897| <<global>> DEFINE_I440FX_MACHINE(v0_13, "pc-0.13", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|932| <<global>> DEFINE_I440FX_MACHINE(v0_12, "pc-0.12", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|964| <<global>> DEFINE_I440FX_MACHINE(v0_11, "pc-0.11", pc_compat_0_13,
+ *   - hw/i386/pc_piix.c|999| <<global>> DEFINE_I440FX_MACHINE(v0_10, "pc-0.10", pc_compat_0_13,
+ */
 #define DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn) \
     static void pc_init_##suffix(MachineState *machine) \
     { \
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index 532241e..85bc2d2 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -59,6 +59,17 @@
 #define MAX_SATA_PORTS     6
 
 /* PC hardware initialisation */
+/*
+ * called only by:
+ *   - hw/i386/pc_q35.c|305| <<DEFINE_Q35_MACHINE>> pc_q35_init(machine); \
+ *
+ * 一个例子:
+ * (gdb) bt
+ * #0  pc_q35_init (machine=0x55555684f880) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_q35.c:63
+ * #1  0x0000555555921d5e in pc_init_v3_0 (machine=0x55555684f880) at /home/zhang/kvm/qemu-3.0.0/hw/i386/pc_q35.c:320
+ * #2  0x0000555555a7c472 in machine_run_board_init (machine=0x55555684f880) at hw/core/machine.c:830
+ * #3  0x00005555559dfb8f in main (argc=12, argv=0x7fffffffe478, envp=0x7fffffffe4e0) at vl.c:4516
+ */
 static void pc_q35_init(MachineState *machine)
 {
     PCMachineState *pcms = PC_MACHINE(machine);
@@ -282,6 +293,19 @@ static void pc_q35_init(MachineState *machine)
     }
 }
 
+/*
+ * called by:
+ *   - hw/i386/pc_q35.c|320| <<global>> DEFINE_Q35_MACHINE(v3_0, "pc-q35-3.0", NULL,
+ *   - hw/i386/pc_q35.c|330| <<global>> DEFINE_Q35_MACHINE(v2_12, "pc-q35-2.12", NULL,
+ *   - hw/i386/pc_q35.c|342| <<global>> DEFINE_Q35_MACHINE(v2_11, "pc-q35-2.11", NULL,
+ *   - hw/i386/pc_q35.c|353| <<global>> DEFINE_Q35_MACHINE(v2_10, "pc-q35-2.10", NULL,
+ *   - hw/i386/pc_q35.c|362| <<global>> DEFINE_Q35_MACHINE(v2_9, "pc-q35-2.9", NULL,
+ *   - hw/i386/pc_q35.c|371| <<global>> DEFINE_Q35_MACHINE(v2_8, "pc-q35-2.8", NULL,
+ *   - hw/i386/pc_q35.c|381| <<global>> DEFINE_Q35_MACHINE(v2_7, "pc-q35-2.7", NULL,
+ *   - hw/i386/pc_q35.c|393| <<global>> DEFINE_Q35_MACHINE(v2_6, "pc-q35-2.6", NULL,
+ *   - hw/i386/pc_q35.c|405| <<global>> DEFINE_Q35_MACHINE(v2_5, "pc-q35-2.5", NULL,
+ *   - hw/i386/pc_q35.c|417| <<global>> DEFINE_Q35_MACHINE(v2_4, "pc-q35-2.4", NULL,
+ */
 #define DEFINE_Q35_MACHINE(suffix, name, compatfn, optionfn) \
     static void pc_init_##suffix(MachineState *machine) \
     { \
diff --git a/hw/pci/msix.c b/hw/pci/msix.c
index c944c02..1682e28 100644
--- a/hw/pci/msix.c
+++ b/hw/pci/msix.c
@@ -142,6 +142,10 @@ static void msix_update_function_masked(PCIDevice *dev)
 }
 
 /* Handle MSI-X capability config write. */
+/*
+ * called by:
+ *   - hw/pci/pci.c|1405| <<pci_default_write_config>> msix_write_config(d, addr, val_in, l);
+ */
 void msix_write_config(PCIDevice *dev, uint32_t addr,
                        uint32_t val, int len)
 {
@@ -266,6 +270,17 @@ static void msix_mask_all(struct PCIDevice *dev, unsigned nentries)
  * also means a programming error, except device assignment, which can check
  * if a real HW is broken.
  */
+/*
+ * called by:
+ *   - hw/net/e1000e.c|292| <<e1000e_init_msix>> int res = msix_init(PCI_DEVICE(s), E1000E_MSIX_VEC_NUM,
+ *   - hw/net/rocker/rocker.c|1245| <<rocker_msix_init>> err = msix_init(dev, ROCKER_MSIX_VEC_COUNT(r->fp_ports),
+ *   - hw/net/vmxnet3.c|2217| <<vmxnet3_init_msix>> int res = msix_init(d, VMXNET3_MAX_INTRS,
+ *   - hw/pci/msix.c|371| <<msix_init_exclusive_bar>> ret = msix_init(dev, nentries, &dev->msix_exclusive_bar, bar_nr,
+ *   - hw/rdma/vmw/pvrdma_main.c|490| <<init_msix>> rc = msix_init(pdev, RDMA_MAX_INTRS, &dev->msix, RDMA_MSIX_BAR_IDX,
+ *   - hw/scsi/megasas.c|2351| <<megasas_scsi_realize>> msix_init(dev, 15, &s->mmio_io, b->mmio_bar, 0x2000,
+ *   - hw/usb/hcd-xhci.c|3432| <<usb_xhci_realize>> msix_init(dev, xhci->numintrs,
+ *   - hw/vfio/pci.c|1550| <<vfio_msix_setup>> ret = msix_init(&vdev->pdev, vdev->msix->entries,
+ */
 int msix_init(struct PCIDevice *dev, unsigned short nentries,
               MemoryRegion *table_bar, uint8_t table_bar_nr,
               unsigned table_offset, MemoryRegion *pba_bar,
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index 80bc459..11bbe79 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -147,6 +147,9 @@ static uint16_t pcibus_numa_node(PCIBus *bus)
     return NUMA_NODE_UNASSIGNED;
 }
 
+/*
+ * TypeInfo pci_bus_info.class_init = pci_bus_class_init()
+ */
 static void pci_bus_class_init(ObjectClass *klass, void *data)
 {
     BusClass *k = BUS_CLASS(klass);
@@ -260,6 +263,11 @@ void pci_device_deassert_intx(PCIDevice *dev)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|308| <<pci_device_reset>> pci_do_device_reset(dev);
+ *   - hw/pci/pci.c|323| <<pcibus_reset>> pci_do_device_reset(bus->devices[i]);
+ */
 static void pci_do_device_reset(PCIDevice *dev)
 {
     int r;
@@ -310,6 +318,10 @@ void pci_device_reset(PCIDevice *dev)
  * Called via qbus_reset_all on RST# assert, after the devices
  * have been reset qdev_reset_all-ed already.
  */
+/*
+ * used by:
+ *   - hw/pci/pci.c|163| <<pci_bus_class_init>> k->reset = pcibus_reset; k是BusClass, 在bus_set_realized()被调用
+ */
 static void pcibus_reset(BusState *qbus)
 {
     PCIBus *bus = DO_UPCAST(PCIBus, qbus, qbus);
@@ -846,10 +858,15 @@ static void pci_init_multifunction(PCIBus *bus, PCIDevice *dev, Error **errp)
     }
 }
 
+/*
+ * called by only:
+ *   - hw/pci/pci.c|1037| <<do_pci_register_device>> pci_config_alloc(pci_dev);
+ */
 static void pci_config_alloc(PCIDevice *pci_dev)
 {
     int config_size = pci_config_size(pci_dev);
 
+    /* 下面全都是一个uint8_t的指针 */
     pci_dev->config = g_malloc0(config_size);
     pci_dev->cmask = g_malloc0(config_size);
     pci_dev->wmask = g_malloc0(config_size);
@@ -964,6 +981,10 @@ static bool pci_bus_devfn_reserved(PCIBus *bus, int devfn)
 }
 
 /* -1 for devfn means auto assign */
+/*
+ * called only by:
+ *   - hw/pci/pci.c|2021| <<pci_qdev_realize>> pci_dev = do_pci_register_device(pci_dev,
+ */
 static PCIDevice *do_pci_register_device(PCIDevice *pci_dev,
                                          const char *name, int devfn,
                                          Error **errp)
@@ -1211,11 +1232,21 @@ void pci_unregister_vga(PCIDevice *pci_dev)
     pci_dev->has_vga = false;
 }
 
+/*
+ * called by:
+ *   - hw/display/vmware_vga.c|863| <<vmsvga_value_read>> ret = pci_get_bar_addr(PCI_DEVICE(pci_vmsvga), 1);
+ *   - hw/display/vmware_vga.c|899| <<vmsvga_value_read>> ret = pci_get_bar_addr(PCI_DEVICE(pci_vmsvga), 2);
+ */
 pcibus_t pci_get_bar_addr(PCIDevice *pci_dev, int region_num)
 {
     return pci_dev->io_regions[region_num].addr;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|1313| <<pci_update_mappings>> new_addr = pci_bar_address(d, i, r->type, r->size);
+ *   - hw/pci/pci.c|2624| <<pci_dev_get_w64>> lob = pci_bar_address(dev, i, r->type, r->size);
+ */
 static pcibus_t pci_bar_address(PCIDevice *d,
 				int reg, uint8_t type, pcibus_t size)
 {
@@ -1924,6 +1955,16 @@ static bool pci_root_bus_in_range(PCIBus *bus, int bus_num)
     return false;
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|688| <<pci_get_bus_devfn>> return pci_find_bus_nr(root, 0);
+ *   - hw/pci/pci.c|701| <<pci_get_bus_devfn>> return pci_find_bus_nr(root, bus);
+ *   - hw/pci/pci.c|1608| <<pci_for_each_device_reverse>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|1635| <<pci_for_each_device>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|1724| <<qmp_query_pci_bridge>> PCIBus *child_bus = pci_find_bus_nr(bus, dev->config[PCI_SECONDARY_BUS]);
+ *   - hw/pci/pci.c|1805| <<qmp_query_pci_bus>> bus = pci_find_bus_nr(bus, bus_num);
+ *   - hw/pci/pci.c|2016| <<pci_find_device>> bus = pci_find_bus_nr(bus, bus_num);
+ */
 static PCIBus *pci_find_bus_nr(PCIBus *bus, int bus_num)
 {
     PCIBus *sec;
@@ -1932,6 +1973,10 @@ static PCIBus *pci_find_bus_nr(PCIBus *bus, int bus_num)
         return NULL;
     }
 
+    /*
+     * 如果参数中的bus就是要找的bus number 直接返回
+     * 否则要从child bus中继续找
+     */
     if (pci_bus_num(bus) == bus_num) {
         return bus;
     }
@@ -1992,6 +2037,9 @@ void pci_for_each_bus_depth_first(PCIBus *bus,
 }
 
 
+/*
+ * 被一群外部调用
+ */
 PCIDevice *pci_find_device(PCIBus *bus, int bus_num, uint8_t devfn)
 {
     bus = pci_find_bus_nr(bus, bus_num);
@@ -2002,6 +2050,10 @@ PCIDevice *pci_find_device(PCIBus *bus, int bus_num, uint8_t devfn)
     return bus->devices[devfn];
 }
 
+/*
+ * used by:
+ *   - hw/pci/pci.c|2557| <<pci_device_class_init>> k->realize = pci_qdev_realize;
+ */
 static void pci_qdev_realize(DeviceState *qdev, Error **errp)
 {
     PCIDevice *pci_dev = (PCIDevice *)qdev;
@@ -2048,6 +2100,20 @@ static void pci_qdev_realize(DeviceState *qdev, Error **errp)
     }
 }
 
+/*
+ * called by:
+ *   - hw/pci-bridge/dec.c|93| <<pci_dec_21154_init>> dev = pci_create_multifunction(parent_bus, devfn, false,
+ *   - hw/pci-bridge/xio3130_downstream.c|139| <<xio3130_downstream_init>> d = pci_create_multifunction(bus, devfn, multifunction,
+ *   - hw/pci-bridge/xio3130_upstream.c|119| <<xio3130_upstream_init>> d = pci_create_multifunction(bus, devfn, multifunction, "x3130-upstream");
+ *   - hw/pci-host/sabre.c|405| <<sabre_realize>> pci_dev = pci_create_multifunction(phb->bus, PCI_DEVFN(1, 0), true,
+ *   - hw/pci-host/sabre.c|411| <<sabre_realize>> pci_dev = pci_create_multifunction(phb->bus, PCI_DEVFN(1, 1), true,
+ *   - hw/pci/pci.c|2106| <<pci_create_simple_multifunction>> PCIDevice *dev = pci_create_multifunction(bus, devfn, multifunction, name);
+ *   - hw/pci/pci.c|2113| <<pci_create>> return pci_create_multifunction(bus, devfn, false, name);
+ *   - hw/sparc64/sun4u.c|581| <<sun4uv_init>> ebus = pci_create_multifunction(pci_busA, PCI_DEVFN(1, 0), true, TYPE_EBUS);
+ *   - hw/sparc64/sun4u.c|607| <<sun4uv_init>> pci_dev = pci_create_multifunction(pci_busA, PCI_DEVFN(1, 1),
+ *   - hw/usb/hcd-ehci-pci.c|273| <<ehci_create_ich9_with_companions>> ehci = pci_create_multifunction(bus, PCI_DEVFN(slot, 7), true, name);
+ *   - hw/usb/hcd-ehci-pci.c|278| <<ehci_create_ich9_with_companions>> uhci = pci_create_multifunction(bus, PCI_DEVFN(slot, comp[i].func),
+ */
 PCIDevice *pci_create_multifunction(PCIBus *bus, int devfn, bool multifunction,
                                     const char *name)
 {
@@ -2059,6 +2125,18 @@ PCIDevice *pci_create_multifunction(PCIBus *bus, int devfn, bool multifunction,
     return PCI_DEVICE(dev);
 }
 
+/*
+ * called by:
+ *   - hw/i2c/smbus_ich9.c|111| <<ich9_smb_init>> pci_create_simple_multifunction(bus, devfn, true, TYPE_ICH9_SMB_DEVICE);
+ *   - hw/i386/pc_q35.c|191| <<pc_q35_init>> lpc = pci_create_simple_multifunction(host_bus, PCI_DEVFN(ICH9_LPC_DEV,
+ *   - hw/i386/pc_q35.c|247| <<pc_q35_init>> ahci = pci_create_simple_multifunction(host_bus,
+ *   - hw/isa/piix4.c|106| <<piix4_init>> d = pci_create_simple_multifunction(bus, devfn, true, "PIIX4");
+ *   - hw/isa/vt82c686.c|486| <<vt82c686b_isa_init>> d = pci_create_simple_multifunction(bus, devfn, true,
+ *   - hw/mips/boston.c|520| <<boston_mach_init>> ahci = pci_create_simple_multifunction(&PCI_BRIDGE(&pcie2->root)->sec_bus,
+ *   - hw/pci-host/piix.c|415| <<i440fx_init>> PCIDevice *pci_dev = pci_create_simple_multifunction(b,
+ *   - hw/pci-host/piix.c|421| <<i440fx_init>> PCIDevice *pci_dev = pci_create_simple_multifunction(b,
+ *   - hw/pci/pci.c|2135| <<pci_create_simple>> return pci_create_simple_multifunction(bus, devfn, false, name);
+ */
 PCIDevice *pci_create_simple_multifunction(PCIBus *bus, int devfn,
                                            bool multifunction,
                                            const char *name)
@@ -2073,11 +2151,18 @@ PCIDevice *pci_create(PCIBus *bus, int devfn, const char *name)
     return pci_create_multifunction(bus, devfn, false, name);
 }
 
+/*
+ * 被很多外部调用
+ */
 PCIDevice *pci_create_simple(PCIBus *bus, int devfn, const char *name)
 {
     return pci_create_simple_multifunction(bus, devfn, false, name);
 }
 
+/*
+ * called by:
+ *   - hw/pci/pci.c|2297| <<pci_add_capability>> offset = pci_find_space(pdev, size);
+ */
 static uint8_t pci_find_space(PCIDevice *pdev, uint8_t size)
 {
     int offset = PCI_CONFIG_HEADER_SIZE;
@@ -2517,16 +2602,32 @@ MemoryRegion *pci_address_space_io(PCIDevice *dev)
     return pci_get_bus(dev)->address_space_io;
 }
 
+/*
+ * TypeInfo pci_device_type_info.class_init = pci_device_class_init()
+ *
+ * called only by:
+ *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+ */
 static void pci_device_class_init(ObjectClass *klass, void *data)
 {
     DeviceClass *k = DEVICE_CLASS(klass);
 
+    /*
+     * realize is called by:
+     *   - hw/core/qdev.c|860| <<device_set_realized>> dc->realize(dev, &local_err);
+     */
     k->realize = pci_qdev_realize;
     k->unrealize = pci_qdev_unrealize;
     k->bus_type = TYPE_PCI_BUS;
     k->props = pci_props;
 }
 
+/*
+ * TypeInfo pci_device_type_info.class_base_init = pci_device_class_base_init()
+ *
+ * called only by:
+ *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+ */
 static void pci_device_class_base_init(ObjectClass *klass, void *data)
 {
     if (!object_class_is_abstract(klass)) {
@@ -2669,6 +2770,11 @@ static const TypeInfo pci_device_type_info = {
 
 static void pci_register_types(void)
 {
+    /* 
+     * 被外部好多好多调用
+     * 
+     * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+     */
     type_register_static(&pci_bus_info);
     type_register_static(&pcie_bus_info);
     type_register_static(&conventional_pci_interface_info);
@@ -2676,4 +2782,8 @@ static void pci_register_types(void)
     type_register_static(&pci_device_type_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(pci_register_types)
diff --git a/include/exec/memory.h b/include/exec/memory.h
index 448d41a..d2f9eca 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -32,6 +32,7 @@
 #define MAX_PHYS_ADDR_SPACE_BITS 62
 #define MAX_PHYS_ADDR            (((hwaddr)1 << MAX_PHYS_ADDR_SPACE_BITS) - 1)
 
+/* TypeInfo memory_region_info */
 #define TYPE_MEMORY_REGION "qemu:memory-region"
 #define MEMORY_REGION(obj) \
         OBJECT_CHECK(MemoryRegion, (obj), TYPE_MEMORY_REGION)
@@ -336,6 +337,9 @@ typedef struct IOMMUMemoryRegionClass {
 typedef struct CoalescedMemoryRange CoalescedMemoryRange;
 typedef struct MemoryRegionIoeventfd MemoryRegionIoeventfd;
 
+/*
+ * TYPE_MEMORY_REGION的instance
+ */
 struct MemoryRegion {
     Object parent_obj;
 
diff --git a/include/hw/boards.h b/include/hw/boards.h
index d139a43..cbb20da 100644
--- a/include/hw/boards.h
+++ b/include/hw/boards.h
@@ -48,6 +48,7 @@ void memory_region_allocate_system_memory(MemoryRegion *mr, Object *owner,
  */
 #define MACHINE_TYPE_NAME(machinename) (machinename TYPE_MACHINE_SUFFIX)
 
+/* TypeInfo machine_info */
 #define TYPE_MACHINE "machine"
 #undef MACHINE  /* BSD defines it and QEMU does not use it */
 #define MACHINE(obj) \
@@ -169,7 +170,15 @@ struct MachineClass {
     const char *desc;
     const char *deprecation_reason;
 
+    /*
+     * called by:
+     *   - hw/core/machine.c|870| <<machine_run_board_init>> machine_class->init(machine);
+     */
     void (*init)(MachineState *state);
+    /*
+     * called by:
+     *   - vl.c|1645| <<qemu_system_reset>> mc->reset();
+     */
     void (*reset)(void);
     void (*hot_add_cpu)(const int64_t id, Error **errp);
     int (*kvm_type)(const char *arg);
diff --git a/include/hw/i386/pc.h b/include/hw/i386/pc.h
index 6894f37..6b26809 100644
--- a/include/hw/i386/pc.h
+++ b/include/hw/i386/pc.h
@@ -37,7 +37,7 @@ struct PCMachineState {
     /* Pointers to devices and objects: */
     HotplugHandler *acpi_dev;
     ISADevice *rtc;
-    PCIBus *bus;
+    PCIBus *bus;  // 有pci bus!
     FWCfgState *fw_cfg;
     qemu_irq *gsi;
 
@@ -136,6 +136,16 @@ struct PCMachineClass {
     bool linuxboot_dma_enabled;
 };
 
+/* TypeInfo pc_machine_info */
+/*
+ * TYPE_PC_MACHINE is used by:
+ *   - hw/i386/x86-iommu.c|88| <<x86_iommu_realize>> PC_MACHINE(object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE));
+ *   - include/hw/i386/pc.h|142| <<PC_MACHINE>> OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|144| <<PC_MACHINE_GET_CLASS>> OBJECT_GET_CLASS(PCMachineClass, (obj), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|146| <<PC_MACHINE_CLASS>> OBJECT_CLASS_CHECK(PCMachineClass, (klass), TYPE_PC_MACHINE)
+ *   - include/hw/i386/pc.h|954| <<DEFINE_PC_MACHINE>> .parent = TYPE_PC_MACHINE, \
+ *   - target/i386/kvm.c|1455| <<kvm_arch_init>> object_dynamic_cast(OBJECT(ms), TYPE_PC_MACHINE) &&
+ */
 #define TYPE_PC_MACHINE "generic-pc-machine"
 #define PC_MACHINE(obj) \
     OBJECT_CHECK(PCMachineState, (obj), TYPE_PC_MACHINE)
@@ -249,6 +259,7 @@ struct PCII440FXState;
 typedef struct PCII440FXState PCII440FXState;
 
 #define TYPE_I440FX_PCI_HOST_BRIDGE "i440FX-pcihost"
+/* TypeInfo i440fx_info */
 #define TYPE_I440FX_PCI_DEVICE "i440FX"
 
 #define TYPE_IGD_PASSTHROUGH_I440FX_PCI_DEVICE "igd-passthrough-i440FX"
@@ -941,6 +952,13 @@ bool e820_get_entry(int, uint32_t, uint64_t *, uint64_t *);
         .value = "off",\
     },
 
+/*
+ * called by:
+ *   - hw/i386/pc_piix.c|1136| <<global>> DEFINE_PC_MACHINE(isapc, "isapc", pc_init_isa,
+ *   - hw/i386/pc_piix.c|1148| <<global>> DEFINE_PC_MACHINE(xenfv, "xenfv", pc_xen_hvm_init,
+ *   - hw/i386/pc_piix.c|417| <<DEFINE_I440FX_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ *   - hw/i386/pc_q35.c|294| <<DEFINE_Q35_MACHINE>> DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+ */
 #define DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn) \
     static void pc_machine_##suffix##_class_init(ObjectClass *oc, void *data) \
     { \
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index 990d6fc..e399575 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -191,6 +191,7 @@ enum {
     QEMU_PCIE_EXTCAP_INIT = (1 << QEMU_PCIE_EXTCAP_INIT_BITNR),
 };
 
+/* TypeInfo pci_device_type_info */
 #define TYPE_PCI_DEVICE "pci-device"
 #define PCI_DEVICE(obj) \
      OBJECT_CHECK(PCIDevice, (obj), TYPE_PCI_DEVICE)
@@ -388,10 +389,16 @@ typedef void (*pci_set_irq_fn)(void *opaque, int irq_num, int level);
 typedef int (*pci_map_irq_fn)(PCIDevice *pci_dev, int irq_num);
 typedef PCIINTxRoute (*pci_route_irq_fn)(void *opaque, int pin);
 
+/* TypeInfo pci_bus_info */
 #define TYPE_PCI_BUS "PCI"
 #define PCI_BUS(obj) OBJECT_CHECK(PCIBus, (obj), TYPE_PCI_BUS)
 #define PCI_BUS_CLASS(klass) OBJECT_CLASS_CHECK(PCIBusClass, (klass), TYPE_PCI_BUS)
 #define PCI_BUS_GET_CLASS(obj) OBJECT_GET_CLASS(PCIBusClass, (obj), TYPE_PCI_BUS)
+/*
+ * TypeInfo pcie_bus_info
+ *
+ * TYPE_PCIE_BUS的parent是TYPE_PCI_BUS
+ */
 #define TYPE_PCIE_BUS "PCIE"
 
 bool pci_bus_is_express(PCIBus *bus);
diff --git a/include/hw/pci/pci_bus.h b/include/hw/pci/pci_bus.h
index b7da8f5..72ba5ac 100644
--- a/include/hw/pci/pci_bus.h
+++ b/include/hw/pci/pci_bus.h
@@ -28,6 +28,7 @@ struct PCIBus {
     pci_map_irq_fn map_irq;
     pci_route_irq_fn route_intx_to_irq;
     void *irq_opaque;
+    /* 挂载着这个pci bus的所有device */
     PCIDevice *devices[PCI_SLOT_MAX * PCI_FUNC_MAX];
     PCIDevice *parent_dev;
     MemoryRegion *address_space_mem;
diff --git a/include/hw/qdev-core.h b/include/hw/qdev-core.h
index f1fd0f8..6f8b1f3 100644
--- a/include/hw/qdev-core.h
+++ b/include/hw/qdev-core.h
@@ -11,6 +11,7 @@ enum {
     DEV_NVECTORS_UNSPECIFIED = -1,
 };
 
+/* TypeInfo device_type_info */
 #define TYPE_DEVICE "device"
 #define DEVICE(obj) OBJECT_CHECK(DeviceState, (obj), TYPE_DEVICE)
 #define DEVICE_CLASS(klass) OBJECT_CLASS_CHECK(DeviceClass, (klass), TYPE_DEVICE)
@@ -107,6 +108,10 @@ typedef struct DeviceClass {
 
     /* callbacks */
     DeviceReset reset;
+    /*
+     * called by:
+     *   - hw/core/qdev.c|860| <<device_set_realized>> dc->realize(dev, &local_err);
+     */
     DeviceRealize realize;
     DeviceUnrealize unrealize;
 
@@ -159,6 +164,7 @@ struct DeviceListener {
     QTAILQ_ENTRY(DeviceListener) link;
 };
 
+/* TypeInfo bus_info */
 #define TYPE_BUS "bus"
 #define BUS(obj) OBJECT_CHECK(BusState, (obj), TYPE_BUS)
 #define BUS_CLASS(klass) OBJECT_CLASS_CHECK(BusClass, (klass), TYPE_BUS)
@@ -177,6 +183,10 @@ struct BusClass {
      */
     char *(*get_fw_dev_path)(DeviceState *dev);
     void (*reset)(BusState *bus);
+    /*
+     * called by:
+     *   - hw/core/bus.c|193| <<bus_set_realized>> bc->realize(bus, &local_err);
+     */
     BusRealize realize;
     BusUnrealize unrealize;
 
diff --git a/include/qemu/module.h b/include/qemu/module.h
index 54300ab..54f79db 100644
--- a/include/qemu/module.h
+++ b/include/qemu/module.h
@@ -39,6 +39,16 @@ static void __attribute__((constructor)) do_qemu_init_ ## function(void)    \
 }
 #endif
 
+/*
+ * 所有注册的module_init_type在以下调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * module_call_init()遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
+
 typedef enum {
     MODULE_INIT_BLOCK,
     MODULE_INIT_OPTS,
@@ -49,6 +59,10 @@ typedef enum {
 
 #define block_init(function) module_init(function, MODULE_INIT_BLOCK)
 #define opts_init(function) module_init(function, MODULE_INIT_OPTS)
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 #define type_init(function) module_init(function, MODULE_INIT_QOM)
 #define trace_init(function) module_init(function, MODULE_INIT_TRACE)
 
diff --git a/include/qom/object.h b/include/qom/object.h
index f0b0bf3..39c0c18 100644
--- a/include/qom/object.h
+++ b/include/qom/object.h
@@ -28,6 +28,7 @@ typedef struct TypeInfo TypeInfo;
 typedef struct InterfaceClass InterfaceClass;
 typedef struct InterfaceInfo InterfaceInfo;
 
+/* TypeInfo object_info */
 #define TYPE_OBJECT "object"
 
 /**
@@ -391,7 +392,7 @@ typedef void (ObjectFree)(void *obj);
 struct ObjectClass
 {
     /*< private >*/
-    Type type;
+    Type type;  // 定义typedef struct TypeImpl *Type;
     GSList *interfaces;
 
     const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE];
@@ -417,6 +418,10 @@ struct ObjectClass
 struct Object
 {
     /*< private >*/
+    /*
+     * 初始化:
+     *   - qom/object.c|665| <<object_initialize_with_type>> obj->class = type->class;
+     */
     ObjectClass *class;
     ObjectFree *free;
     GHashTable *properties;
@@ -574,6 +579,7 @@ struct InterfaceClass
     Type interface_type;
 };
 
+/* TypeInfo interface_info */
 #define TYPE_INTERFACE "interface"
 
 /**
@@ -868,6 +874,10 @@ void type_register_static_array(const TypeInfo *infos, int nr_infos);
  * @type_array should be static constant that exists for the life time
  * that the type is registered.
  */
+/*
+ * type_register_static_array()
+ *     为nr_infos个: 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 #define DEFINE_TYPES(type_array)                                            \
 static void do_qemu_init_ ## type_array(void)                               \
 {                                                                           \
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 98f389a..b8b9320 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -754,6 +754,10 @@ struct kvm_ppc_resize_hpt {
  * ioctls for /dev/kvm fds:
  */
 #define KVM_GET_API_VERSION       _IO(KVMIO,   0x00)
+/*
+ * x86就用在:
+ *   - accel/kvm/kvm-all.c|1560| <<kvm_init>> ret = kvm_ioctl(s, KVM_CREATE_VM, type);
+ */
 #define KVM_CREATE_VM             _IO(KVMIO,   0x01) /* returns a VM fd */
 #define KVM_GET_MSR_INDEX_LIST    _IOWR(KVMIO, 0x02, struct kvm_msr_list)
 
diff --git a/memory.c b/memory.c
index e9cd446..76c8b13 100644
--- a/memory.c
+++ b/memory.c
@@ -40,9 +40,39 @@ static bool memory_region_update_pending;
 static bool ioeventfd_update_pending;
 static bool global_dirty_log = false;
 
+/*
+ * 所有使用的地方:
+ *   - memory.c|2696| <<memory_listener_register>> QTAILQ_INSERT_TAIL(&memory_listeners, listener, link);
+ *   - memory.c|126| <<MEMORY_LISTENER_CALL_GLOBAL>> QTAILQ_FOREACH(_listener, &memory_listeners, link) { \
+ *   - memory.c|133| <<MEMORY_LISTENER_CALL_GLOBAL>> QTAILQ_FOREACH_REVERSE(_listener, &memory_listeners, \
+ *   - memory.c|134| <<MEMORY_LISTENER_CALL_GLOBAL>> memory_listeners, link) { \
+ *   - memory.c|2046| <<memory_region_sync_dirty_bitmap>> QTAILQ_FOREACH(listener, &memory_listeners, link) {
+ *   - memory.c|2693| <<memory_listener_register>> if (QTAILQ_EMPTY(&memory_listeners)
+ *   - memory.c|2694| <<memory_listener_register>> || listener->priority >= QTAILQ_LAST(&memory_listeners,
+ *   - memory.c|2695| <<memory_listener_register>> memory_listeners)->priority) {
+ *   - memory.c|2698| <<memory_listener_register>> QTAILQ_FOREACH(other, &memory_listeners, link) {
+ *   - memory.c|2708| <<memory_listener_register>> memory_listeners)->priority) {
+ *   - memory.c|2729| <<memory_listener_unregister>> QTAILQ_REMOVE(&memory_listeners, listener, link);
+ */
 static QTAILQ_HEAD(memory_listeners, MemoryListener) memory_listeners
     = QTAILQ_HEAD_INITIALIZER(memory_listeners);
 
+/*
+ * 添加:
+ *   - memory.c|2835| <<address_space_init>> QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
+ *
+ * 删除:
+ *   - memory.c|2859| <<address_space_destroy>> QTAILQ_REMOVE(&address_spaces, as, address_spaces_link);
+ *
+ * 使用:
+ *   - memory.c|608| <<memory_region_to_address_space>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|969| <<flatviews_reset>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|1060| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|1068| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|2189| <<memory_region_update_coalesced_range>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|3150| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - memory.c|3174| <<mtree_info>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ */
 static QTAILQ_HEAD(, AddressSpace) address_spaces
     = QTAILQ_HEAD_INITIALIZER(address_spaces);
 
@@ -1022,6 +1052,10 @@ static void address_space_set_flatview(AddressSpace *as)
     }
 }
 
+/*
+ * called only by:
+ *   - memory.c|2833| <<address_space_init>> address_space_update_topology(as);
+ */
 static void address_space_update_topology(AddressSpace *as)
 {
     MemoryRegion *physmr = memory_region_get_flatview_root(as->root);
@@ -1112,6 +1146,11 @@ static char *memory_region_escape_name(const char *name)
     return escaped;
 }
 
+/*
+ * called by:
+ *   - memory.c|1158| <<memory_region_init>> memory_region_do_init(mr, owner, name, size);
+ *   - memory.c|1691| <<memory_region_init_iommu>> memory_region_do_init(mr, owner, name, size);
+ */
 static void memory_region_do_init(MemoryRegion *mr,
                                   Object *owner,
                                   const char *name,
@@ -1140,11 +1179,20 @@ static void memory_region_do_init(MemoryRegion *mr,
     }
 }
 
+/*
+ * 被非常多的外部调用
+ */
 void memory_region_init(MemoryRegion *mr,
                         Object *owner,
                         const char *name,
                         uint64_t size)
 {
+    /*
+     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+     * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+     *
+     * MemoryRegion (TYPE_MEMORY_REGION) 的instance_init(): memory_region_initfn()
+     */
     object_initialize(mr, sizeof(*mr), TYPE_MEMORY_REGION);
     memory_region_do_init(mr, owner, name, size);
 }
@@ -1201,6 +1249,12 @@ static void memory_region_get_size(Object *obj, Visitor *v, const char *name,
     visit_type_uint64(v, name, &value, errp);
 }
 
+/*
+ * TypeInfo memory_region_info.instance_init = memory_reagion_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void memory_region_initfn(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -1235,6 +1289,12 @@ static void memory_region_initfn(Object *obj)
                         NULL, NULL, &error_abort);
 }
 
+/*
+ * TypeInfo iommu_memory_region_info.instance_init = iommu_memory_region_initfn()
+ *
+ * called only by:
+ *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+ */
 static void iommu_memory_region_initfn(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -1674,6 +1734,12 @@ void memory_region_init_iommu(void *_iommu_mr,
     iommu_mr->iommu_notify_flags = IOMMU_NOTIFIER_NONE;
 }
 
+/*
+ * TypeInfo memory_region_info.instance_finalize = memory_region_finalize()
+ *
+ * called only by:
+ *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+ */
 static void memory_region_finalize(Object *obj)
 {
     MemoryRegion *mr = MEMORY_REGION(obj);
@@ -2788,6 +2854,9 @@ void memory_region_invalidate_mmio_ptr(MemoryRegion *mr, hwaddr offset,
                           RUN_ON_CPU_HOST_PTR(invalidate_data));
 }
 
+/*
+ * 被很多外部调用
+ */
 void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
 {
     memory_region_ref(root);
@@ -2796,6 +2865,7 @@ void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
     as->ioeventfd_nb = 0;
     as->ioeventfds = NULL;
     QTAILQ_INIT(&as->listeners);
+    /* 把AddressSpace插入全局链表address_spaces */
     QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
     as->name = g_strdup(name ? name : "anonymous");
     address_space_update_topology(as);
@@ -3247,8 +3317,13 @@ static const TypeInfo iommu_memory_region_info = {
 
 static void memory_register_types(void)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_static(&memory_region_info);
     type_register_static(&iommu_memory_region_info);
 }
 
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ */
 type_init(memory_register_types)
diff --git a/qom/object.c b/qom/object.c
index 75d1d48..d219fe4 100644
--- a/qom/object.c
+++ b/qom/object.c
@@ -39,6 +39,15 @@ struct InterfaceImpl
     const char *typename;
 };
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
 struct TypeImpl
 {
     const char *name;
@@ -47,21 +56,62 @@ struct TypeImpl
 
     size_t instance_size;
 
+    /*
+     * called only by:
+     *   - qom/object.c|565| <<type_initialize>> ti->class_init(ti->class, ti->class_data);
+     */
     void (*class_init)(ObjectClass *klass, void *data);
+    /*
+     * called only by:
+     *   - qom/object.c|558| <<type_initialize>> parent->class_base_init(ti->class, ti->class_data);
+     */
     void (*class_base_init)(ObjectClass *klass, void *data);
+    /*
+     * 似乎目前不调用:
+     *   - hw/core/machine.c|868| <<global>> .class_finalize = machine_class_finalize,
+     *   - qom/object.c|69| <<global>> void (*class_finalize)(ObjectClass *klass, void *data);
+     *   - qom/object.c|179| <<type_new>> ti->class_finalize = info->class_finalize;
+     */
     void (*class_finalize)(ObjectClass *klass, void *data);
 
+    /*
+     * 来自TypeInfo (各个外部自己定义):
+     *   - qom/object.c|198| <<type_new>> ti->class_data = info->class_data;
+     */
     void *class_data;
 
+    /*
+     * called only by:
+     *   - qom/object.c|598| <<object_init_with_type>> ti->instance_init(obj);
+     */
     void (*instance_init)(Object *obj);
+    /*
+     * called only by:
+     *   - qom/object.c|605| <<object_post_init_with_type>> ti->instance_post_init(obj);
+     */
     void (*instance_post_init)(Object *obj);
+    /*
+     * called only by:
+     *   - qom/object.c|766| <<object_deinit>> type->instance_finalize(obj);
+     */
     void (*instance_finalize)(Object *obj);
 
     bool abstract;
 
+    /*
+     * 在type_new()中由TypeInfo->parent获得
+     */
     const char *parent;
+    /*
+     * 设置parent_type的地方:
+     *   - qom/object.c|256| <<type_get_parent>> type->parent_type = type_get_by_name(type->parent);
+     *   - qom/object.c|334| <<type_initialize_interface>> iface_impl->parent_type = parent_type;
+     */
     TypeImpl *parent_type;
 
+    /*
+     * 在type_initialize()中分配
+     */
     ObjectClass *class;
 
     int num_interfaces;
@@ -70,6 +120,14 @@ struct TypeImpl
 
 static Type type_interface;
 
+/*
+ * called by:
+ *   - qom/object.c|89| <<type_table_add>> g_hash_table_insert(type_table_get(), (void *)ti->name, ti);
+ *   - qom/object.c|94| <<type_table_lookup>> return g_hash_table_lookup(type_table_get(), name);
+ *   - qom/object.c|889| <<object_class_foreach>> g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
+ *
+ *   如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+ */
 static GHashTable *type_table_get(void)
 {
     static GHashTable *type_table;
@@ -83,17 +141,42 @@ static GHashTable *type_table_get(void)
 
 static bool enumerating_types;
 
+/*
+ * called by only type_register_internal()
+ *
+ * 把一个根据TypeInfo转化成的TypeImpl插入到hashtable
+ */
 static void type_table_add(TypeImpl *ti)
 {
     assert(!enumerating_types);
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     g_hash_table_insert(type_table_get(), (void *)ti->name, ti);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|135| <<type_new>> if (type_table_lookup(info->name) != NULL) {
+ *   - qom/object.c|200| <<type_get_by_name>> return type_table_lookup(name);
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ */
 static TypeImpl *type_table_lookup(const char *name)
 {
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     return g_hash_table_lookup(type_table_get(), name);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|137| <<type_register_internal>> ti = type_new(info);
+ *   - qom/object.c|250| <<type_initialize_interface>> iface_impl = type_new(&info);
+ *
+ * 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了
+ */
 static TypeImpl *type_new(const TypeInfo *info)
 {
     TypeImpl *ti = g_malloc0(sizeof(*ti));
@@ -101,6 +184,7 @@ static TypeImpl *type_new(const TypeInfo *info)
 
     g_assert(info->name != NULL);
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     if (type_table_lookup(info->name) != NULL) {
         fprintf(stderr, "Registering `%s' which already exists\n", info->name);
         abort();
@@ -123,6 +207,11 @@ static TypeImpl *type_new(const TypeInfo *info)
 
     ti->abstract = info->abstract;
 
+    /*
+     * TypeImpl包含:
+     *       int num_interfaces;
+     *       InterfaceImpl interfaces[MAX_INTERFACES]; --> 包含const char *typename;
+     */
     for (i = 0; info->interfaces && info->interfaces[i].type; i++) {
         ti->interfaces[i].typename = g_strdup(info->interfaces[i].type);
     }
@@ -131,47 +220,99 @@ static TypeImpl *type_new(const TypeInfo *info)
     return ti;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|191| <<type_register>> return type_register_internal(info);
+ *   - qom/object.c|2503| <<register_types>> type_interface = type_register_internal(&interface_info);
+ *   - qom/object.c|2504| <<register_types>> type_register_internal(&object_info);
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 static TypeImpl *type_register_internal(const TypeInfo *info)
 {
     TypeImpl *ti;
+    /* 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 */
     ti = type_new(info);
 
+    /* 把一个根据TypeInfo转化成的TypeImpl插入到hashtable */
     type_table_add(ti);
     return ti;
 }
 
+/*
+ * 被外部好多好多调用
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 TypeImpl *type_register(const TypeInfo *info)
 {
     assert(info->parent);
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     return type_register_internal(info);
 }
 
+/*
+ * 被外部好多好多调用
+ *
+ * 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 TypeImpl *type_register_static(const TypeInfo *info)
 {
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     return type_register(info);
 }
 
+/*
+ * 为nr_infos个: 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable
+ */
 void type_register_static_array(const TypeInfo *infos, int nr_infos)
 {
     int i;
 
     for (i = 0; i < nr_infos; i++) {
+        /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
         type_register_static(&infos[i]);
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|245| <<type_get_parent>> type->parent_type = type_get_by_name(type->parent);
+ *   - qom/object.c|285| <<object_type_get_instance_size>> TypeImpl *type = type_get_by_name(typename);
+ *   - qom/object.c|383| <<type_initialize>> TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);
+ *   - qom/object.c|461| <<object_initialize>> TypeImpl *type = type_get_by_name(typename);
+ *   - qom/object.c|625| <<object_new>> TypeImpl *ti = type_get_by_name(typename);
+ *   - qom/object.c|801| <<object_class_dynamic_cast>> target_type = type_get_by_name(typename);
+ *   - qom/object.c|899| <<object_class_by_name>> TypeImpl *type = type_get_by_name(typename);
+ */
 static TypeImpl *type_get_by_name(const char *name)
 {
     if (name == NULL) {
         return NULL;
     }
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     return type_table_lookup(name);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|283| <<type_class_get_size>> return type_class_get_size(type_get_parent(ti));
+ *   - qom/object.c|296| <<type_object_get_size>> return type_object_get_size(type_get_parent(ti));
+ *   - qom/object.c|321| <<type_is_ancestor>> type = type_get_parent(type);
+ *   - qom/object.c|383| <<type_initialize>> parent = type_get_parent(ti);
+ *   - qom/object.c|430| <<type_initialize>> parent = type_get_parent(parent);
+ *   - qom/object.c|441| <<object_init_with_type>> object_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|456| <<object_post_init_with_type>> object_post_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|613| <<object_deinit>> object_deinit(obj, type_get_parent(type));
+ *   - qom/object.c|937| <<object_class_get_parent>> TypeImpl *type = type_get_parent(class->type);
+ *
+ * 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+ */
 static TypeImpl *type_get_parent(TypeImpl *type)
 {
     if (!type->parent_type && type->parent) {
+        /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
         type->parent_type = type_get_by_name(type->parent);
         g_assert(type->parent_type != NULL);
     }
@@ -179,45 +320,95 @@ static TypeImpl *type_get_parent(TypeImpl *type)
     return type->parent_type;
 }
 
+/*
+ * called by:
+ *   - qom/object.c|296| <<type_class_get_size>> if (type_has_parent(ti)) {
+ *   - qom/object.c|309| <<type_object_get_size>> if (type_has_parent(ti)) {
+ *   - qom/object.c|457| <<object_init_with_type>> if (type_has_parent(ti)) {
+ *   - qom/object.c|475| <<object_post_init_with_type>> if (type_has_parent(ti)) {
+ *   - qom/object.c|635| <<object_deinit>> if (type_has_parent(type)) {
+ *
+ * 检查TypeImpl是否有parent
+ */
 static bool type_has_parent(TypeImpl *type)
 {
     return (type->parent != NULL);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|308| <<type_class_get_size>> return type_class_get_size(type_get_parent(ti));
+ *   - qom/object.c|399| <<type_initialize>> ti->class_size = type_class_get_size(ti);
+ *
+ * 如果TypeImpl有class_size返回class_size
+ * 其次递归调用自己返回parent的size
+ * 最后没办法了返回sizeof(ObjectClass)
+ */
 static size_t type_class_get_size(TypeImpl *ti)
 {
     if (ti->class_size) {
         return ti->class_size;
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
-        return type_class_get_size(type_get_parent(ti));
+        /* 这里递归调用 继续返回parent的TypeImpl的class_size */
+        return type_class_get_size(type_get_parent(ti)); // 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
     }
 
     return sizeof(ObjectClass);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|338| <<type_object_get_size>> return type_object_get_size(type_get_parent(ti));
+ *   - qom/object.c|350| <<object_type_get_instance_size>> return type_object_get_size(type);
+ *   - qom/object.c|421| <<type_initialize>> ti->instance_size = type_object_get_size(ti);
+ *
+ * 如果TypeImpl有instance_size返回instance_size
+ * 其次递归调用自己返回parent的object size
+ * 最后没办法了返回0
+ */
 static size_t type_object_get_size(TypeImpl *ti)
 {
     if (ti->instance_size) {
         return ti->instance_size;
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
-        return type_object_get_size(type_get_parent(ti));
+	    /* 这里递归调用 继续返回parent的TypeImpl的instance_size */
+        return type_object_get_size(type_get_parent(ti)); // 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
     }
 
     return 0;
 }
 
+/*
+ * hw/ppc/pnv.c中调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 如果TypeImpl有instance_size返回instance_size
+ * 其次递归调用自己返回parent的object size
+ * 最后没办法了返回0
+ */
 size_t object_type_get_instance_size(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
     g_assert(type != NULL);
+    /*
+     * 如果TypeImpl有instance_size返回instance_size
+     * 其次递归调用自己返回parent的object size
+     * 最后没办法了返回0
+     */
     return type_object_get_size(type);
 }
 
+/*
+ * 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+ */
 static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
 {
     assert(target_type);
@@ -228,6 +419,7 @@ static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
             return true;
         }
 
+	/* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
         type = type_get_parent(type);
     }
 
@@ -236,6 +428,11 @@ static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)
 
 static void type_initialize(TypeImpl *ti);
 
+/*
+ * called by:
+ *   - qom/object.c|474| <<type_initialize>> type_initialize_interface(ti, iface->interface_type, klass->type);
+ *   - qom/object.c|493| <<type_initialize>> type_initialize_interface(ti, t, t);
+ */
 static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
                                       TypeImpl *parent_type)
 {
@@ -247,6 +444,7 @@ static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
     info.name = g_strdup_printf("%s::%s", ti->name, interface_type->name);
     info.abstract = true;
 
+    /* 根据TypeInfo转换成TypeImpl, 如果hashtable中已经存在就不用了 */
     iface_impl = type_new(&info);
     iface_impl->parent_type = parent_type;
     type_initialize(iface_impl);
@@ -256,10 +454,17 @@ static void type_initialize_interface(TypeImpl *ti, TypeImpl *interface_type,
     new_iface->concrete_class = ti->class;
     new_iface->interface_type = interface_type;
 
+    /* 把TypeImpl挂载到ti->class->interfaces */
     ti->class->interfaces = g_slist_append(ti->class->interfaces,
                                            iface_impl->class);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|468| <<type_initialize>> g_str_hash, g_str_equal, g_free, object_property_free);
+ *   - qom/object.c|497| <<type_initialize>> g_str_hash, g_str_equal, g_free, object_property_free);
+ *   - qom/object.c|560| <<object_initialize_with_type>> NULL, object_property_free);
+ */
 static void object_property_free(gpointer data)
 {
     ObjectProperty *prop = data;
@@ -270,49 +475,97 @@ static void object_property_free(gpointer data)
     g_free(prop);
 }
 
+/*
+ * called by:
+ *   - qom/object.c|407| <<type_initialize_interface>> type_initialize(iface_impl);
+ *   - qom/object.c|460| <<type_initialize>> type_initialize(parent);
+ *   - qom/object.c|550| <<object_initialize_with_type>> type_initialize(type);
+ *   - qom/object.c|725| <<object_new_with_type>> type_initialize(type);
+ *   - qom/object.c|1023| <<object_class_by_name>> type_initialize(type);
+ *   - qom/object.c|1037| <<object_class_get_parent>> type_initialize(type);
+ *   - qom/object.c|1057| <<object_class_foreach_tramp>> type_initialize(type);
+ *
+ * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+ * 调用.class_init()
+ */
 static void type_initialize(TypeImpl *ti)
 {
     TypeImpl *parent;
 
+    /* ti->class是ObjectClass, 如果已经初始化了就退出 */
     if (ti->class) {
         return;
     }
 
+    /*
+     * 如果TypeImpl有class_size返回class_size
+     * 其次递归调用自己返回parent的size
+     * 最后没办法了返回sizeof(ObjectClass)
+     */
     ti->class_size = type_class_get_size(ti);
+    /*
+     * 如果TypeImpl有instance_size返回instance_size
+     * 其次递归调用自己返回parent的size
+     * 最后没办法了返回0
+     */
     ti->instance_size = type_object_get_size(ti);
     /* Any type with zero instance_size is implicitly abstract.
      * This means interface types are all abstract.
      */
+    /* 没有instance_size的就是abstract */
     if (ti->instance_size == 0) {
         ti->abstract = true;
     }
 
+    /* class的类型: ObjectClass *class; */
     ti->class = g_malloc0(ti->class_size);
 
+    /* 返回TypeImpl的parent_type (TypeImpl), 如果没有现设置 (可以为NULL) */
     parent = type_get_parent(ti);
     if (parent) {
+        /* 递归调用自己保证祖先们都完成了初始化 */
         type_initialize(parent);
         GSList *e;
         int i;
 
+	/*
+	 * 孩子们的class_size必须比祖先小 因为包含祖先
+	 */
         g_assert(parent->class_size <= ti->class_size);
+	/*
+	 * 包含祖先的时候都在头上 所以先拷贝过来
+	 *
+	 * TypeImpl包含ObjectClass *class, 后者包含GSList *interfaces
+	 */
         memcpy(ti->class, parent->class, parent->class_size);
         ti->class->interfaces = NULL;
+	/*
+	 * ObjectCLass的properties是GHashTable
+	 */
         ti->class->properties = g_hash_table_new_full(
             g_str_hash, g_str_equal, g_free, object_property_free);
 
         for (e = parent->class->interfaces; e; e = e->next) {
             InterfaceClass *iface = e->data;
+	    /*
+	     * ObjectClass包含Type (定义typedef struct TypeImpl *Type)
+	     */
             ObjectClass *klass = OBJECT_CLASS(iface);
 
             type_initialize_interface(ti, iface->interface_type, klass->type);
         }
 
         for (i = 0; i < ti->num_interfaces; i++) {
+            /*
+	     * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+	     *
+	     * nvme的typename的例子是INTERFACE_PCIE_DEVICE
+	     */
             TypeImpl *t = type_get_by_name(ti->interfaces[i].typename);
             for (e = ti->class->interfaces; e; e = e->next) {
                 TypeImpl *target_type = OBJECT_CLASS(e->data)->type;
 
+		/* 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor */
                 if (type_is_ancestor(target_type, t)) {
                     break;
                 }
@@ -333,8 +586,15 @@ static void type_initialize(TypeImpl *ti)
 
     while (parent) {
         if (parent->class_base_init) {
+            /*
+	     * 实现了class_base_init的
+	     *   - hw/core/machine.c|867| <<global>> .class_base_init = machine_class_base_init,
+	     *   - hw/core/qdev.c|1108| <<global>> .class_base_init = device_class_base_init,
+	     *   - hw/pci/pci.c|2667| <<global>> .class_base_init = pci_device_class_base_init
+	     */
             parent->class_base_init(ti->class, ti->class_data);
         }
+	/* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
         parent = type_get_parent(parent);
     }
 
@@ -343,9 +603,20 @@ static void type_initialize(TypeImpl *ti)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|602| <<object_init_with_type>> object_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|641| <<object_initialize_with_type>> object_init_with_type(obj, type);
+ *
+ * 调用TypeImpl的instance_init(), 如果有parent递归"先"调用parent的instance_init()
+ */
 static void object_init_with_type(Object *obj, TypeImpl *ti)
 {
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
+        /*
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_init_with_type(obj, type_get_parent(ti));
     }
 
@@ -354,22 +625,44 @@ static void object_init_with_type(Object *obj, TypeImpl *ti)
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|621| <<object_post_init_with_type>> object_post_init_with_type(obj, type_get_parent(ti));
+ *   - qom/object.c|642| <<object_initialize_with_type>> object_post_init_with_type(obj, type);
+ *
+ * 调用TypeImpl的instance_post_init(obj), 如果有parent"再"递归调用parent的instance_post_init(obj)
+ */
 static void object_post_init_with_type(Object *obj, TypeImpl *ti)
 {
     if (ti->instance_post_init) {
         ti->instance_post_init(obj);
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(ti)) {
+        /* 
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_post_init_with_type(obj, type_get_parent(ti));
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|650| <<object_initialize>> object_initialize_with_type(data, size, type);
+ *   - qom/object.c|816| <<object_new_with_type>> object_initialize_with_type(obj, type->instance_size, type);
+ *
+ * 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 static void object_initialize_with_type(void *data, size_t size, TypeImpl *type)
 {
     Object *obj = data;
 
     g_assert(type != NULL);
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     g_assert(type->instance_size >= sizeof(Object));
@@ -381,14 +674,24 @@ static void object_initialize_with_type(void *data, size_t size, TypeImpl *type)
     object_ref(obj);
     obj->properties = g_hash_table_new_full(g_str_hash, g_str_equal,
                                             NULL, object_property_free);
+    /* 调用TypeImpl的instance_init(), 如果有parent递归"先"调用parent的instance_init() */
     object_init_with_type(obj, type);
+    /* 调用TypeImpl的instance_post_init(obj), 如果有parent"再"递归调用parent的instance_post_init(obj) */
     object_post_init_with_type(obj, type);
 }
 
+/*
+ * 被一群外部的调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 根据TypeImpl初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 void object_initialize(void *data, size_t size, const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
+    /* 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init() */
     object_initialize_with_type(data, size, type);
 }
 
@@ -516,11 +819,18 @@ static void object_deinit(Object *obj, TypeImpl *type)
         type->instance_finalize(obj);
     }
 
+    /* 检查TypeImpl是否有parent */
     if (type_has_parent(type)) {
+        /*
+	 * type_get_parent(): 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL)
+	 */
         object_deinit(obj, type_get_parent(type));
     }
 }
 
+/*
+ * called only by object_unref()
+ */
 static void object_finalize(void *data)
 {
     Object *obj = data;
@@ -535,28 +845,56 @@ static void object_finalize(void *data)
     }
 }
 
+/*
+ * called only by object_new()
+ *
+ * Type的定义: typedef struct TypeImpl *Type
+ *
+ * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 static Object *object_new_with_type(Type type)
 {
     Object *obj;
 
     g_assert(type != NULL);
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     obj = g_malloc(type->instance_size);
+    /* 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init() */
     object_initialize_with_type(obj, type->instance_size, type);
     obj->free = g_free;
 
     return obj;
 }
 
+/*
+ * 被一群外部调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 确保相应的class已经初始化了: 初始化参数TypeImpl的class_size, instance_size和class, 还有interface, 调用.class_init()
+ * 然后分配Object, 初始化data头部的Object, 递归调用自己parent的instance_init()和instance_post_init()
+ */
 Object *object_new(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *ti = type_get_by_name(typename);
 
     return object_new_with_type(ti);
 }
 
 
+/*
+ * called by:
+ *   - hw/misc/auxbus.c|70| <<aux_init_bus>> auxtoi2c = object_new_with_props(TYPE_AUXTOI2C, OBJECT(bus), "i2c",
+ *   - iothread.c|366| <<iothread_create>> obj = object_new_with_props(TYPE_IOTHREAD,
+ *   - ui/vnc.c|3539| <<vnc_display_create_creds>> creds = object_new_with_props(TYPE_QCRYPTO_TLS_CREDS_X509,
+ *   - ui/vnc.c|3548| <<vnc_display_create_creds>> creds = object_new_with_props(TYPE_QCRYPTO_TLS_CREDS_ANON,
+ */
 Object *object_new_with_props(const char *typename,
                               Object *parent,
                               const char *id,
@@ -623,6 +961,28 @@ Object *object_new_with_propv(const char *typename,
 }
 
 
+/*
+ * <example>
+ *   <title>Update an object's properties</title>
+ *   <programlisting>
+ *   Error *err = NULL;
+ *   Object *obj = ...get / create object...;
+ *
+ *   obj = object_set_props(obj,
+ *                          &err,
+ *                          "share", "yes",
+ *                          "mem-path", "/dev/shm/somefile",
+ *                          "prealloc", "yes",
+ *                          "size", "1048576",
+ *                          NULL);
+ *  
+ *   if (!obj) {
+ *     g_printerr("Cannot set properties: %s\n",
+ *                error_get_pretty(err));
+ *   }
+ *   </programlisting>
+ * </example>
+ */
 int object_set_props(Object *obj,
                      Error **errp,
                      ...)
@@ -638,6 +998,13 @@ int object_set_props(Object *obj,
 }
 
 
+/*
+ * called by:
+ *   - qom/object.c|720| <<object_initialize_childv>> object_set_propv(obj, &local_err, vargs);
+ *   - qom/object.c|937| <<object_new_with_propv>> if (object_set_propv(obj, &local_err, vargs) < 0) {
+ *   - qom/object.c|994| <<object_set_props>> ret = object_set_propv(obj, errp, vargs);
+ *   - qom/object.c|1001| <<object_set_propv>> int object_set_propv(Object *obj,
+ */
 int object_set_propv(Object *obj,
                      Error **errp,
                      va_list vargs)
@@ -727,12 +1094,16 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
         return class;
     }
 
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     target_type = type_get_by_name(typename);
     if (!target_type) {
         /* target class type unknown, so fail the cast */
         return NULL;
     }
 
+    /*
+     * type_is_ancestor(): 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
+     */
     if (type->class->interfaces &&
             type_is_ancestor(target_type, type_interface)) {
         int found = 0;
@@ -741,6 +1112,7 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
         for (i = class->interfaces; i; i = i->next) {
             ObjectClass *target_class = i->data;
 
+	    /* 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor */
             if (type_is_ancestor(target_class->type, target_type)) {
                 ret = target_class;
                 found++;
@@ -751,7 +1123,7 @@ ObjectClass *object_class_dynamic_cast(ObjectClass *class,
         if (found > 1) {
             ret = NULL;
         }
-    } else if (type_is_ancestor(type, target_type)) {
+    } else if (type_is_ancestor(type, target_type)) {  // 从type(TypeImpl)一直往parent回溯 判断target_type是否是type的ancestor
         ret = class;
     }
 
@@ -805,6 +1177,7 @@ out:
 
 const char *object_get_typename(const Object *obj)
 {
+    /* 最后的type (Type) 是一个TypeImpl */
     return obj->class->type->name;
 }
 
@@ -823,14 +1196,26 @@ const char *object_class_get_name(ObjectClass *klass)
     return klass->type->name;
 }
 
+/*
+ * 很多外部调用
+ *
+ * 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl
+ * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+ * 调用.class_init()
+ */
 ObjectClass *object_class_by_name(const char *typename)
 {
+    /* 根据name在hashtable中搜索由TypeInfo转化成的TypeImpl */
     TypeImpl *type = type_get_by_name(typename);
 
     if (!type) {
         return NULL;
     }
 
+    /*
+     * 初始化参数TypeImpl的class_size, instance_size和class, 还有interface
+     * 调用.class_init()
+     */
     type_initialize(type);
 
     return type->class;
@@ -838,6 +1223,7 @@ ObjectClass *object_class_by_name(const char *typename)
 
 ObjectClass *object_class_get_parent(ObjectClass *class)
 {
+    /* 返回TypeImpl的parent_type, 如果没有现设置 (可以为NULL) */
     TypeImpl *type = type_get_parent(class->type);
 
     if (!type) {
@@ -886,6 +1272,9 @@ void object_class_foreach(void (*fn)(ObjectClass *klass, void *opaque),
     OCFData data = { fn, implements_type, include_abstract, opaque };
 
     enumerating_types = true;
+    /*
+     * type_table_get(): 如果静态变量static GHashTable *type_table没有初始化就初始化并返回
+     */
     g_hash_table_foreach(type_table_get(), object_class_foreach_tramp, &data);
     enumerating_types = false;
 }
@@ -1162,6 +1551,14 @@ void object_property_get(Object *obj, Visitor *v, const char *name,
     }
 }
 
+/*
+ * called by:
+ *   - qom/object.c|1791| <<object_property_parse>> object_property_set(obj, v, name, errp);
+ *   - qom/object.c|2719| <<property_set_alias>> object_property_set(prop->target_obj, v, prop->target_name, errp);
+ *   - qom/object_interfaces.c|73| <<user_creatable_add_type>> object_property_set(obj, v, e->key, &local_err);
+ *   - qom/qom-qobject.c|27| <<object_property_set_qobject>> object_property_set(obj, v, name, errp);
+ *   - target/s390x/cpu_models.c|491| <<cpu_model_from_info>> object_property_set(obj, visitor, e->key, errp);
+ */
 void object_property_set(Object *obj, Visitor *v, const char *name,
                          Error **errp)
 {
@@ -1395,6 +1792,15 @@ out:
     visit_free(v);
 }
 
+/*
+ * called by:
+ *   - hmp.c|2594| <<hmp_qom_set>> object_property_parse(obj, value, property, &err);
+ *   - hw/core/qdev-properties.c|1259| <<qdev_prop_set_globals>> object_property_parse(OBJECT(dev), prop->value, prop->property, &err);
+ *   - qdev-monitor.c|180| <<set_property>> object_property_parse(obj, value, name, &err);
+ *   - qom/object.c|1020| <<object_set_propv>> object_property_parse(obj, value, propname, &local_err);
+ *   - target/i386/cpu.c|3528| <<x86_cpu_apply_props>> object_property_parse(OBJECT(cpu), pv->value, pv->prop,
+ *   - vl.c|2728| <<machine_set_property>> object_property_parse(obj, value, qom_name, &local_err);
+ */
 void object_property_parse(Object *obj, const char *string,
                            const char *name, Error **errp)
 {
@@ -2423,11 +2829,18 @@ void object_class_property_set_description(ObjectClass *klass,
     op->description = g_strdup(description);
 }
 
+/*
+ * TypeInfo object_info.instance_init = object_instance_init()
+ */
 static void object_instance_init(Object *obj)
 {
     object_property_add_str(obj, "type", qdev_get_type, NULL, NULL);
 }
 
+/*
+ * 在以下被间接调用:
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ */
 static void register_types(void)
 {
     static TypeInfo interface_info = {
@@ -2443,8 +2856,31 @@ static void register_types(void)
         .abstract = true,
     };
 
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_interface = type_register_internal(&interface_info);
+    /* 如果hashtable中不存在, 就根据TypeInfo转换成TypeImpl然后插入hashtable */
     type_register_internal(&object_info);
 }
 
+/*
+ * 例子:
+ *
+ * 在accel/kvm/kvm-all.c中,有struct TypeInfo kvm_accel_type.
+ * type_register_static(&kvm_accel_type)会把struct TypeInfo
+ * 实例化为TypeImpl, 然后放入一个hash table:
+ * g_hash_table_insert(type_table_get(), (void *)ti->name, ti)
+ */
+
+/*
+ * 该函数调用module_init(function, MODULE_INIT_QOM)
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[MODULE_INIT_QOM]
+ *
+ * 所有注册的module_init_type在以下调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * module_call_init()遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
 type_init(register_types)
diff --git a/target/i386/kvm.c b/target/i386/kvm.c
index 9313602..a260ff1 100644
--- a/target/i386/kvm.c
+++ b/target/i386/kvm.c
@@ -1374,6 +1374,10 @@ static void register_smram_listener(Notifier *n, void *unused)
                                  &smram_address_space, 1);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|1677| <<kvm_init>> ret = kvm_arch_init(ms, s);
+ */
 int kvm_arch_init(MachineState *ms, KVMState *s)
 {
     uint64_t identity_base = 0xfffbc000;
diff --git a/util/module.c b/util/module.c
index c909737..4a9b8ec 100644
--- a/util/module.c
+++ b/util/module.c
@@ -32,34 +32,64 @@ typedef QTAILQ_HEAD(, ModuleEntry) ModuleTypeList;
 
 static ModuleTypeList init_type_list[MODULE_INIT_MAX];
 
+/*
+ * used by:
+ *   - util/module.c|58| <<init_lists>> QTAILQ_INIT(&dso_init_list);
+ *   - util/module.c|115| <<register_dso_module_init>> QTAILQ_INSERT_TAIL(&dso_init_list, e, node);
+ *   - util/module.c|163| <<module_load_file>> assert(QTAILQ_EMPTY(&dso_init_list));
+ *   - util/module.c|184| <<module_load_file>> QTAILQ_FOREACH(e, &dso_init_list, node) {
+ *   - util/module.c|191| <<module_load_file>> QTAILQ_FOREACH_SAFE(e, &dso_init_list, node, next) {
+ *   - util/module.c|192| <<module_load_file>> QTAILQ_REMOVE(&dso_init_list, e, node);
+ */
 static ModuleTypeList dso_init_list;
 
+/*
+ * called by:
+ *   - util/module.c|58| <<find_type>> init_lists();
+ *   - util/module.c|81| <<register_dso_module_init>> init_lists();
+ *
+ * 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化)
+ */
 static void init_lists(void)
 {
     static int inited;
     int i;
 
+    /* 静态变量只在这个函数修改 如果是1说明初始化过了 */
     if (inited) {
         return;
     }
 
     for (i = 0; i < MODULE_INIT_MAX; i++) {
-        QTAILQ_INIT(&init_type_list[i]);
+        QTAILQ_INIT(&init_type_list[i]);  // 在该函数上面声明的
     }
 
-    QTAILQ_INIT(&dso_init_list);
+    QTAILQ_INIT(&dso_init_list);  // 在该函数上面声明的
 
     inited = 1;
 }
 
 
+/*
+ * called by:
+ *   - register_module_init()
+ *   - module_call_init()
+ *
+ * 返回init_type_list[type] (type最多MODULE_INIT_MAX个)
+ */
 static ModuleTypeList *find_type(module_init_type type)
 {
+    /* 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化) */
     init_lists();
 
     return &init_type_list[type];
 }
 
+/*
+ * type最多MODULE_INIT_MAX个
+ *
+ * 根据fn初始化一个ModuleEntry插入到对应的init_type_list[type] (type最多MODULE_INIT_MAX个)
+ */
 void register_module_init(void (*fn)(void), module_init_type type)
 {
     ModuleEntry *e;
@@ -69,15 +99,22 @@ void register_module_init(void (*fn)(void), module_init_type type)
     e->init = fn;
     e->type = type;
 
+    /* 返回init_type_list[type] (type最多MODULE_INIT_MAX个) */
     l = find_type(type);
 
     QTAILQ_INSERT_TAIL(l, e, node);
 }
 
+/*
+ * type最多MODULE_INIT_MAX个
+ *
+ * 根据fn初始化一个ModuleEntry插入到dso_init_list
+ */
 void register_dso_module_init(void (*fn)(void), module_init_type type)
 {
     ModuleEntry *e;
 
+    /* 确认init_type_list[MODULE_INIT_MAX]和dso_init_list已经初始化了 (如果没有则初始化) */
     init_lists();
 
     e = g_malloc0(sizeof(*e));
@@ -87,6 +124,15 @@ void register_dso_module_init(void (*fn)(void), module_init_type type)
     QTAILQ_INSERT_TAIL(&dso_init_list, e, node);
 }
 
+/*
+ * 主要的调用:
+ *   - vl.c|2953| <<main>> module_call_init(MODULE_INIT_TRACE);
+ *   - vl.c|2964| <<main>> module_call_init(MODULE_INIT_QOM);
+ *   - vl.c|2996| <<main>> module_call_init(MODULE_INIT_OPTS);
+ *   - block.c|4321| <<bdrv_init>> module_call_init(MODULE_INIT_BLOCK);
+ *
+ * 遍历init_type_list[type](type最多MODULE_INIT_MAX个)上所有的ModuleEntry调用其init()
+ */
 void module_call_init(module_init_type type)
 {
     ModuleTypeList *l;
@@ -100,6 +146,9 @@ void module_call_init(module_init_type type)
 }
 
 #ifdef CONFIG_MODULES
+/*
+ * called only by module_load_one()
+ */
 static int module_load_file(const char *fname)
 {
     GModule *g_module;
@@ -157,6 +206,12 @@ out:
 }
 #endif
 
+/*
+ * called by:
+ *   - include/qemu/module.h|55| <<block_module_load_one>> #define block_module_load_one(lib) module_load_one("block-", lib)
+ *   - include/qemu/module.h|56| <<ui_module_load_one>> #define ui_module_load_one(lib) module_load_one("ui-", lib)
+ *   - include/qemu/module.h|57| <<audio_module_load_one>> #define audio_module_load_one(lib) module_load_one("audio-", lib)
+ */
 void module_load_one(const char *prefix, const char *lib_name)
 {
 #ifdef CONFIG_MODULES
diff --git a/vl.c b/vl.c
index 16b913f..11e6541 100644
--- a/vl.c
+++ b/vl.c
@@ -1389,6 +1389,10 @@ static int usb_parse(const char *cmdline)
 
 MachineState *current_machine;
 
+/*
+ * called only by:
+ *   - vl.c|2564| <<machine_parse>> mc = find_machine(name);
+ */
 static MachineClass *find_machine(const char *name)
 {
     GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);
@@ -1412,6 +1416,10 @@ static MachineClass *find_machine(const char *name)
     return mc;
 }
 
+/*
+ * called only by:
+ *   - vl.c|2677| <<select_machine>> MachineClass *machine_class = find_default_machine();
+ */
 MachineClass *find_default_machine(void)
 {
     GSList *el, *machines = object_class_get_list(TYPE_MACHINE, false);
@@ -2555,6 +2563,10 @@ static gint machine_class_cmp(gconstpointer a, gconstpointer b)
                   object_class_get_name(OBJECT_CLASS(mc1)));
 }
 
+/*
+ * called by:
+ *   - vl.c|2685| <<select_machine>> machine_class = machine_parse(optarg);
+ */
  static MachineClass *machine_parse(const char *name)
 {
     MachineClass *mc = NULL;
@@ -2664,6 +2676,9 @@ static const QEMUOption *lookup_opt(int argc, char **argv,
     return popt;
 }
 
+/*
+ * 被vl.c的main()调用
+ */
 static MachineClass *select_machine(void)
 {
     MachineClass *machine_class = find_default_machine();
-- 
2.7.4

