From a4e4d4d2ec01d6ad89990aa6683b284743dda1d7 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 3 Jul 2019 21:21:11 +0800
Subject: [PATCH 1/1] kasan for linux v5.2-rc4

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 mm/kasan/common.c           | 22 ++++++++++++++++++++++
 mm/kasan/generic.c          | 41 +++++++++++++++++++++++++++++++++++++++++
 mm/kasan/report.c           |  4 ++++
 tools/objtool/builtin-orc.c |  4 ++++
 tools/objtool/check.c       | 17 +++++++++++++++++
 5 files changed, 88 insertions(+)

diff --git a/mm/kasan/common.c b/mm/kasan/common.c
index 242fdc0..7195a67 100644
--- a/mm/kasan/common.c
+++ b/mm/kasan/common.c
@@ -354,6 +354,11 @@ void kasan_poison_object_data(struct kmem_cache *cache, void *object)
  *    based on objects indexes, so that objects that are next to each other
  *    get different tags.
  */
+/*
+ * called by:
+ *   - mm/kasan/common.c|402| <<kasan_init_slab_obj>> assign_tag(cache, object, true, false));
+ *   - mm/kasan/common.c|481| <<__kasan_kmalloc>> tag = assign_tag(cache, object, false, keep_tag);
+ */
 static u8 assign_tag(struct kmem_cache *cache, const void *object,
 			bool init, bool keep_tag)
 {
@@ -570,6 +575,12 @@ void kasan_kfree_large(void *ptr, unsigned long ip)
 	/* The object will be poisoned by page_alloc. */
 }
 
+/*
+ * called by:
+ *   - arch/arm64/kernel/module.c|63| <<module_alloc>> if (p && (kasan_module_alloc(p, size) < 0)) {
+ *   - arch/s390/kernel/module.c|43| <<module_alloc>> if (p && (kasan_module_alloc(p, size) < 0)) {
+ *   - arch/x86/kernel/module.c|80| <<module_alloc>> if (p && (kasan_module_alloc(p, size) < 0)) {
+ */
 int kasan_module_alloc(void *addr, size_t size)
 {
 	void *ret;
@@ -608,6 +619,17 @@ void kasan_free_shadow(const struct vm_struct *vm)
 
 extern void __kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip);
 
+/*
+ * called by:
+ *   - mm/kasan/generic.c|207| <<check_memory_region_inline>> kasan_report(addr, size, write, ret_ip);
+ *   - mm/kasan/generic.c|214| <<check_memory_region_inline>> kasan_report(addr, size, write, ret_ip);
+ *   - mm/kasan/generic_report.c|118| <<DEFINE_ASAN_REPORT_LOAD>> kasan_report(addr, size, false, _RET_IP_); \
+ *   - mm/kasan/generic_report.c|125| <<DEFINE_ASAN_REPORT_STORE>> kasan_report(addr, size, true, _RET_IP_); \
+ *   - mm/kasan/generic_report.c|142| <<__asan_report_load_n_noabort>> kasan_report(addr, size, false, _RET_IP_);
+ *   - mm/kasan/generic_report.c|148| <<__asan_report_store_n_noabort>> kasan_report(addr, size, true, _RET_IP_);
+ *   - mm/kasan/tags.c|114| <<check_memory_region>> kasan_report(addr, size, write, ret_ip);
+ *   - mm/kasan/tags.c|121| <<check_memory_region>> kasan_report(addr, size, write, ret_ip);
+ */
 void kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip)
 {
 	unsigned long flags = user_access_save();
diff --git a/mm/kasan/generic.c b/mm/kasan/generic.c
index 504c7936..aef1ddc 100644
--- a/mm/kasan/generic.c
+++ b/mm/kasan/generic.c
@@ -47,6 +47,13 @@
  * depending on memory access size X.
  */
 
+/*
+ * called by:
+ *   - mm/kasan/generic.c|76| <<memory_is_poisoned_2_4_8>> return *shadow_addr || memory_is_poisoned_1(addr + size - 1);
+ *   - mm/kasan/generic.c|78| <<memory_is_poisoned_2_4_8>> return memory_is_poisoned_1(addr + size - 1);
+ *   - mm/kasan/generic.c|91| <<memory_is_poisoned_16>> return *shadow_addr || memory_is_poisoned_1(addr + 15);
+ *   - mm/kasan/generic.c|162| <<memory_is_poisoned>> return memory_is_poisoned_1(addr);
+ */
 static __always_inline bool memory_is_poisoned_1(unsigned long addr)
 {
 	s8 shadow_value = *(s8 *)kasan_mem_to_shadow((void *)addr);
@@ -59,6 +66,10 @@ static __always_inline bool memory_is_poisoned_1(unsigned long addr)
 	return false;
 }
 
+/*
+ * 只在size是2, 4, 8的时候调用:
+ *   - mm/kasan/generic.c|158| <<memory_is_poisoned>> return memory_is_poisoned_2_4_8(addr, size);
+ */
 static __always_inline bool memory_is_poisoned_2_4_8(unsigned long addr,
 						unsigned long size)
 {
@@ -74,6 +85,10 @@ static __always_inline bool memory_is_poisoned_2_4_8(unsigned long addr,
 	return memory_is_poisoned_1(addr + size - 1);
 }
 
+/*
+ * 只在size是16的时候调用:
+ *   - mm/kasan/generic.c|160| <<memory_is_poisoned>> return memory_is_poisoned_16(addr);
+ */
 static __always_inline bool memory_is_poisoned_16(unsigned long addr)
 {
 	u16 *shadow_addr = (u16 *)kasan_mem_to_shadow((void *)addr);
@@ -127,6 +142,10 @@ static __always_inline unsigned long memory_is_nonzero(const void *start,
 	return bytes_is_nonzero(start, (end - start) % 8);
 }
 
+/*
+ * called by:
+ *   - mm/kasan/generic.c|174| <<memory_is_poisoned>> return memory_is_poisoned_n(addr, size);
+ */
 static __always_inline bool memory_is_poisoned_n(unsigned long addr,
 						size_t size)
 {
@@ -146,6 +165,10 @@ static __always_inline bool memory_is_poisoned_n(unsigned long addr,
 	return false;
 }
 
+/*
+ * called by:
+ *   - mm/kasan/generic.c|190| <<check_memory_region_inline>> if (likely(!memory_is_poisoned(addr, size)))
+ */
 static __always_inline bool memory_is_poisoned(unsigned long addr, size_t size)
 {
 	if (__builtin_constant_p(size)) {
@@ -166,6 +189,12 @@ static __always_inline bool memory_is_poisoned(unsigned long addr, size_t size)
 	return memory_is_poisoned_n(addr, size);
 }
 
+/*
+ * called by:
+ *   - mm/kasan/generic.c|199| <<check_memory_region>> check_memory_region_inline(addr, size, write, ret_ip);
+ *   - mm/kasan/generic.c|241| <<DEFINE_ASAN_LOAD_STORE>> check_memory_region_inline(addr, size, false, _RET_IP_);\
+ *   - mm/kasan/generic.c|249| <<DEFINE_ASAN_LOAD_STORE>> check_memory_region_inline(addr, size, true, _RET_IP_); \
+ */
 static __always_inline void check_memory_region_inline(unsigned long addr,
 						size_t size, bool write,
 						unsigned long ret_ip)
@@ -185,6 +214,18 @@ static __always_inline void check_memory_region_inline(unsigned long addr,
 	kasan_report(addr, size, write, ret_ip);
 }
 
+/*
+ * called by:
+ *   - mm/kasan/common.c|94| <<kasan_check_read>> check_memory_region((unsigned long )p, size, false, _RET_IP_);
+ *   - mm/kasan/common.c|100| <<kasan_check_write>> check_memory_region((unsigned long )p, size, true, _RET_IP_);
+ *   - mm/kasan/common.c|107| <<memset>> check_memory_region((unsigned long )addr, len, true, _RET_IP_);
+ *   - mm/kasan/common.c|115| <<memmove>> check_memory_region((unsigned long )src, len, false, _RET_IP_);
+ *   - mm/kasan/common.c|116| <<memmove>> check_memory_region((unsigned long )dest, len, true, _RET_IP_);
+ *   - mm/kasan/common.c|124| <<memcpy>> check_memory_region((unsigned long )src, len, false, _RET_IP_);
+ *   - mm/kasan/common.c|125| <<memcpy>> check_memory_region((unsigned long )dest, len, true, _RET_IP_);
+ *   - mm/kasan/generic.c|285| <<__asan_loadN>> check_memory_region(addr, size, false, _RET_IP_);
+ *   - mm/kasan/generic.c|295| <<__asan_storeN>> check_memory_region(addr, size, true, _RET_IP_);
+ */
 void check_memory_region(unsigned long addr, size_t size, bool write,
 				unsigned long ret_ip)
 {
diff --git a/mm/kasan/report.c b/mm/kasan/report.c
index 03a4435..df61b43 100644
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@ -282,6 +282,10 @@ void kasan_report_invalid_free(void *object, unsigned long ip)
 	end_report(&flags);
 }
 
+/*
+ * called by:
+ *   - mm/kasan/common.c|614| <<kasan_report>> __kasan_report(addr, size, is_write, ip);
+ */
 void __kasan_report(unsigned long addr, size_t size, bool is_write, unsigned long ip)
 {
 	struct kasan_access_info info;
diff --git a/tools/objtool/builtin-orc.c b/tools/objtool/builtin-orc.c
index 5f7cc61..7435efe 100644
--- a/tools/objtool/builtin-orc.c
+++ b/tools/objtool/builtin-orc.c
@@ -23,6 +23,10 @@ static const char *orc_usage[] = {
 	NULL,
 };
 
+/*
+ * called by only:
+ *   - tools/objtool/objtool.c|37| <<global>> {"orc", cmd_orc, "Generate in-place ORC unwind tables for an object file" },
+ */
 int cmd_orc(int argc, const char **argv)
 {
 	const char *objname;
diff --git a/tools/objtool/check.c b/tools/objtool/check.c
index 172f991..b0f2a61 100644
--- a/tools/objtool/check.c
+++ b/tools/objtool/check.c
@@ -440,6 +440,10 @@ static void add_ignores(struct objtool_file *file)
  *
  * These functions must not directly change AC, but may PUSHF/POPF.
  */
+/*
+ * used by only:
+ *   - tools/objtool/check.c|503| <<add_uaccess_safe>> for (name = uaccess_safe_builtin; *name; name++) {
+ */
 static const char *uaccess_safe_builtin[] = {
 	/* KASAN */
 	"kasan_report",
@@ -492,6 +496,10 @@ static const char *uaccess_safe_builtin[] = {
 	NULL
 };
 
+/*
+ * called by only:
+ *   - tools/objtool/check.c|1310| <<decode_sections>> add_uaccess_safe(file);
+ */
 static void add_uaccess_safe(struct objtool_file *file)
 {
 	struct symbol *func;
@@ -1292,6 +1300,10 @@ static void mark_rodata(struct objtool_file *file)
 	file->rodata = found;
 }
 
+/*
+ * called by:
+ *   - tools/objtool/check.c|2422| <<check>> ret = decode_sections(&file);
+ */
 static int decode_sections(struct objtool_file *file)
 {
 	int ret;
@@ -2401,6 +2413,11 @@ static void cleanup(struct objtool_file *file)
 
 static struct objtool_file file;
 
+/*
+ * called by:
+ *   - tools/objtool/builtin-check.c|48| <<cmd_check>> return check(objname, false);
+ *   - tools/objtool/builtin-orc.c|41| <<cmd_orc>> return check(objname, true);
+ */
 int check(const char *_objname, bool orc)
 {
 	int ret, warnings = 0;
-- 
2.7.4

