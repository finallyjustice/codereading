From e4b953d71730d09d5d3c754c2bcf2897835faaa0 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 27 Aug 2025 14:37:39 -0700
Subject: [PATCH 1/1] qemu for v10.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-accel-ops.c           |  48 +++
 accel/kvm/kvm-all.c                 | 616 ++++++++++++++++++++++++++++
 audio/audio.c                       |  16 +
 backends/cryptodev-vhost.c          |  27 ++
 backends/dbus-vmstate.c             |  16 +
 backends/tpm/tpm_emulator.c         |  16 +
 backends/vhost-user.c               |  27 ++
 block.c                             |   3 +
 block/accounting.c                  | 103 +++++
 block/aio_task.c                    |   5 +
 block/block-backend.c               | 168 ++++++++
 block/iscsi.c                       |   4 +
 chardev/char.c                      |  53 +++
 cpu-common.c                        |  47 +++
 dump/dump.c                         |  10 +
 gdbstub/system.c                    |   4 +
 hw/acpi/acpi_interface.c            |  14 +
 hw/acpi/aml-build.c                 |  83 ++++
 hw/acpi/bios-linker-loader.c        |  10 +
 hw/acpi/core.c                      |  14 +
 hw/acpi/generic_event_device.c      |   4 +
 hw/acpi/ich9.c                      | 101 +++++
 hw/acpi/pcihp.c                     | 315 ++++++++++++++
 hw/acpi/piix4.c                     |   4 +
 hw/acpi/utils.c                     |  51 +++
 hw/arm/virt-acpi-build.c            |  65 +++
 hw/arm/virt.c                       |   4 +
 hw/block/vhost-user-blk.c           |  34 ++
 hw/block/virtio-blk-common.c        |   7 +
 hw/block/virtio-blk.c               | 466 +++++++++++++++++++++
 hw/char/serial.c                    | 151 +++++++
 hw/core/cpu-common.c                |  42 ++
 hw/core/machine.c                   |   8 +
 hw/core/qdev.c                      |   9 +
 hw/i2c/core.c                       |  16 +
 hw/i386/acpi-build.c                | 289 +++++++++++++
 hw/i386/acpi-microvm.c              |  29 ++
 hw/i386/amd_iommu.c                 |   4 +
 hw/i386/kvm/apic.c                  | 230 +++++++++++
 hw/i386/kvm/clock.c                 |  60 +++
 hw/i386/pc.c                        |  33 ++
 hw/i386/pc_q35.c                    |  23 ++
 hw/i386/vapic.c                     |  34 ++
 hw/ide/core.c                       |  14 +
 hw/ide/isa.c                        |  16 +
 hw/intc/apic.c                      |  10 +
 hw/intc/apic_common.c               | 109 +++++
 hw/intc/kvm_irqcount.c              |  10 +
 hw/isa/lpc_ich9.c                   |   4 +
 hw/net/eepro100.c                   |  16 +
 hw/net/vhost_net.c                  |  32 ++
 hw/nvme/ctrl.c                      |  14 +
 hw/nvram/fw_cfg.c                   | 184 +++++++++
 hw/pci-bridge/pci_expander_bridge.c |  19 +
 hw/pci-host/gpex-acpi.c             |  20 +
 hw/pci-host/i440fx.c                |  19 +
 hw/pci-host/q35.c                   |  43 ++
 hw/pci-host/remote.c                |  19 +
 hw/pci/pci-qmp-cmds.c               |   7 +
 hw/pci/pci.c                        | 191 +++++++++
 hw/riscv/virt-acpi-build.c          |  18 +
 hw/scsi/scsi-bus.c                  |  26 ++
 hw/scsi/scsi-disk.c                 | 227 ++++++++++
 hw/scsi/vhost-scsi.c                | 298 ++++++++++++++
 hw/scsi/vhost-user-scsi.c           |  27 ++
 hw/scsi/virtio-scsi-dataplane.c     |  51 +++
 hw/scsi/virtio-scsi.c               |  11 +
 hw/timer/arm_timer.c                |  16 +
 hw/timer/hpet.c                     |   8 +
 hw/vfio/helpers.c                   |  17 +
 hw/vfio/pci.c                       |  52 +++
 hw/vfio/pci.h                       |  10 +
 hw/virtio/iothread-vq-mapping.c     |  10 +
 hw/virtio/vdpa-dev.c                |  27 ++
 hw/virtio/vhost-user-base.c         |  27 ++
 hw/virtio/vhost-user-fs.c           |  27 ++
 hw/virtio/vhost-user-scmi.c         |  27 ++
 hw/virtio/vhost-user-vsock.c        |  27 ++
 hw/virtio/vhost-vsock.c             |  27 ++
 hw/virtio/vhost.c                   |  27 ++
 hw/virtio/virtio-bus.c              |  19 +
 hw/virtio/virtio-mem.c              |  16 +
 hw/virtio/virtio.c                  | 107 +++++
 include/exec/ram_addr.h             |   4 +
 include/exec/ramblock.h             |  33 ++
 include/exec/ramlist.h              |  59 +++
 include/hw/acpi/aml-build.h         |  18 +
 include/hw/acpi/ich9.h              |  20 +
 include/hw/acpi/pcihp.h             |  24 ++
 include/hw/char/serial.h            |  34 ++
 include/hw/core/cpu.h               |  19 +
 include/hw/i386/apic_internal.h     |  35 ++
 include/hw/virtio/virtio-blk.h      |  54 +++
 include/hw/virtio/virtio-scsi.h     |  10 +
 include/hw/virtio/virtio.h          |  30 ++
 include/migration/vmstate.h         |  34 ++
 include/qemu/timer.h                |  13 +
 include/system/kvm_int.h            |  25 ++
 linux-headers/linux/kvm.h           |   8 +
 migration/cpr-transfer.c            |   4 +
 migration/cpr.c                     |   4 +
 migration/dirtyrate.c               |  80 ++++
 migration/migration.c               |  14 +
 migration/qemu-file.c               |  35 ++
 migration/ram.c                     | 117 ++++++
 migration/ram.h                     |  40 ++
 migration/savevm.c                  | 195 +++++++++
 migration/vmstate-types.c           | 107 +++++
 migration/vmstate.c                 | 121 ++++++
 net/slirp.c                         |   8 +
 system/cpus.c                       | 264 ++++++++++++
 system/dirtylimit.c                 |   7 +
 system/main.c                       |  30 ++
 system/memory.c                     | 162 ++++++++
 system/physmem.c                    | 155 +++++++
 system/runstate.c                   |  33 ++
 system/vl.c                         |   8 +
 target/i386/cpu-apic.c              | 174 ++++++++
 target/i386/cpu-dump.c              |  35 ++
 target/i386/cpu.c                   |  42 ++
 target/i386/cpu.h                   |  20 +
 target/i386/kvm/kvm.c               | 237 +++++++++++
 target/i386/kvm/xen-emu.c           |   6 +
 util/async.c                        |  32 ++
 util/coroutine-ucontext.c           |   5 +
 util/main-loop.c                    | 165 ++++++++
 util/osdep.c                        |   7 +
 util/qemu-coroutine.c               | 578 ++++++++++++++++++++++++++
 util/qemu-option.c                  | 154 +++++++
 util/qemu-timer.c                   |  24 ++
 util/rcu.c                          | 166 ++++++++
 131 files changed, 8541 insertions(+)

diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index 54ea60909..9c42bd318 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -27,6 +27,11 @@
 #include <linux/kvm.h>
 #include "kvm-cpus.h"
 
+/*
+ * 在以下使用kvm_vcpu_thread_fn():
+ *   - accel/kvm/kvm-accel-ops.c|72| <<kvm_start_vcpu_thread>> qemu_thread_create(cpu->thread, thread_name,
+ *            kvm_vcpu_thread_fn, cpu, QEMU_THREAD_JOINABLE);
+ */
 static void *kvm_vcpu_thread_fn(void *arg)
 {
     CPUState *cpu = arg;
@@ -39,6 +44,9 @@ static void *kvm_vcpu_thread_fn(void *arg)
     cpu->thread_id = qemu_get_thread_id();
     current_cpu = cpu;
 
+    /*
+     * 只在此处调用kvm_init_vcpu()
+     */
     r = kvm_init_vcpu(cpu, &error_fatal);
     kvm_init_cpu_signals(cpu);
 
@@ -47,12 +55,33 @@ static void *kvm_vcpu_thread_fn(void *arg)
     qemu_guest_random_seed_thread_part2(cpu->random_seed);
 
     do {
+        /*
+	 * can run主要看能不能stop
+	 */
         if (cpu_can_run(cpu)) {
+            /*
+	     * 返回的ret
+	     * #define EXCP_INTERRUPT  0x10000 // async interruption
+	     * #define EXCP_HLT        0x10001 // hlt instruction reached
+	     * #define EXCP_DEBUG      0x10002 // cpu stopped after a breakpoint or singlestep
+	     * #define EXCP_HALTED     0x10003 // cpu is halted (waiting for external event)
+	     * #define EXCP_YIELD      0x10004 // cpu wants to yield timeslice to another
+	     * #define EXCP_ATOMIC     0x10005 // stop-the-world and emulate atomic
+	     *
+	     * 只在以下调用kvm_cpu_exec()
+	     */
             r = kvm_cpu_exec(cpu);
             if (r == EXCP_DEBUG) {
                 cpu_handle_guest_debug(cpu);
             }
         }
+        /*
+	 * 在以下使用qemu_wait_io_event():
+	 *   - accel/dummy-cpus.c|59| <<dummy_cpu_thread_fn>> qemu_wait_io_event(cpu);
+	 *   - accel/hvf/hvf-accel-ops.c|453| <<hvf_cpu_thread_fn>> qemu_wait_io_event(cpu);
+	 *   - accel/kvm/kvm-accel-ops.c|56| <<kvm_vcpu_thread_fn>> qemu_wait_io_event(cpu);
+	 *   - accel/tcg/tcg-accel-ops-mttcg.c|117| <<mttcg_cpu_thread_fn>> qemu_wait_io_event(cpu);
+	 */
         qemu_wait_io_event(cpu);
     } while (!cpu->unplug || cpu_can_run(cpu));
 
@@ -63,6 +92,10 @@ static void *kvm_vcpu_thread_fn(void *arg)
     return NULL;
 }
 
+/*
+ * 在以下使用kvm_start_vcpu_thread():
+ *   - accel/kvm/kvm-accel-ops.c|126| <<kvm_accel_ops_class_init>> ops->create_vcpu_thread = kvm_start_vcpu_thread;
+ */
 static void kvm_start_vcpu_thread(CPUState *cpu)
 {
     char thread_name[VCPU_THREAD_NAME_SIZE];
@@ -99,6 +132,21 @@ static void kvm_accel_ops_class_init(ObjectClass *oc, void *data)
     ops->cpus_are_resettable = kvm_cpus_are_resettable;
     ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
     ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+    /*
+     * 在以下使用kvm_cpu_synchronize_state():
+     *   - accel/kvm/kvm-accel-ops.c|131| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - accel/kvm/kvm-all.c|3547| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+     *   - target/arm/kvm.c|1376| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+     *   - target/arm/kvm.c|2389| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+     *   - target/i386/kvm/kvm.c|5646| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+     *   - target/i386/kvm/kvm.c|5665| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+     *   - target/i386/kvm/kvm.c|5683| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+     *   - target/i386/kvm/kvm.c|5688| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+     *   - target/i386/kvm/kvm.c|6202| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+     *   - target/loongarch/kvm/kvm.c|1323| <<kvm_loongarch_handle_debug>> kvm_cpu_synchronize_state(cs);
+     *   - target/riscv/kvm/kvm-cpu.c|1589| <<kvm_riscv_handle_debug>> kvm_cpu_synchronize_state(cs);
+     *   - target/s390x/kvm/kvm.c|1911| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+     */
     ops->synchronize_state = kvm_cpu_synchronize_state;
     ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
 
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index f89568bfa..506986976 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -82,6 +82,10 @@ struct KVMParkedVcpu {
 
 KVMState *kvm_state;
 bool kvm_kernel_irqchip;
+/*
+ * 在以下使用kvm_split_irqchip:
+ *   - target/i386/kvm/kvm.c|6222| <<kvm_arch_irqchip_create>> kvm_split_irqchip = true;
+ */
 bool kvm_split_irqchip;
 bool kvm_async_interrupts_allowed;
 bool kvm_halt_in_kernel_allowed;
@@ -423,6 +427,13 @@ int kvm_unpark_vcpu(KVMState *s, unsigned long vcpu_id)
     struct KVMParkedVcpu *cpu;
     int kvm_fd = -ENOENT;
 
+    /*
+     * struct KVMParkedVcpu {
+     *     unsigned long vcpu_id;
+     *     int kvm_fd;
+     *     QLIST_ENTRY(KVMParkedVcpu) node;
+     * };
+     */
     QLIST_FOREACH(cpu, &s->kvm_parked_vcpus, node) {
         if (cpu->vcpu_id == vcpu_id) {
             QLIST_REMOVE(cpu, node);
@@ -447,6 +458,13 @@ static void kvm_reset_parked_vcpus(void *param)
     }
 }
 
+/*
+ * 在以下使用kvm_create_vcpu（）：
+ *   - accel/kvm/kvm-all.c|512| <<kvm_create_and_park_vcpu>> ret = kvm_create_vcpu(cpu);
+ *   - accel/kvm/kvm-all.c|577| <<kvm_init_vcpu>> ret = kvm_create_vcpu(cpu);
+ *
+ * kvm_create_and_park_vcpu()只被PPC使用
+ */
 int kvm_create_vcpu(CPUState *cpu)
 {
     unsigned long vcpu_id = kvm_arch_vcpu_id(cpu);
@@ -466,6 +484,25 @@ int kvm_create_vcpu(CPUState *cpu)
 
     cpu->kvm_fd = kvm_fd;
     cpu->kvm_state = s;
+    /*
+     * 在以下使用CPUState->vcpu_dirty:
+     *   - accel/kvm/kvm-all.c|480| <<kvm_create_vcpu>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3128| <<do_kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3142| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3174| <<kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3194| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3216| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3232| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3405| <<kvm_cpu_exec>> if (cpu->vcpu_dirty) {
+     *   - accel/kvm/kvm-all.c|3419| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/mips/kvm.c|563| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *   - target/mips/kvm.c|579| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *
+     * cpu->vcpu_dirty说明有东西要从QEMU更新到KVM
+     * 比如要调用kvm_arch_put_registers()
+     * !cpu->vcpu_dirty说明"也许"有东西要从KVM更新到QEMU
+     * 比如要调用kvm_arch_get_registers()
+     */
     cpu->vcpu_dirty = true;
     cpu->dirty_pages = 0;
     cpu->throttle_us_per_full = 0;
@@ -475,6 +512,10 @@ int kvm_create_vcpu(CPUState *cpu)
     return 0;
 }
 
+/*
+ * 在以下使用kvm_create_and_park_vcpu():
+ *   - target/ppc/kvm.c|2373| <<kvmppc_cpu_realize>> ret = kvm_create_and_park_vcpu(cs);
+ */
 int kvm_create_and_park_vcpu(CPUState *cpu)
 {
     int ret = 0;
@@ -532,6 +573,10 @@ void kvm_destroy_vcpu(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下使用kvm_init_vcpu():
+ *   - accel/kvm/kvm-accel-ops.c|42| <<kvm_vcpu_thread_fn>> r = kvm_init_vcpu(cpu, &error_fatal);
+ */
 int kvm_init_vcpu(CPUState *cpu, Error **errp)
 {
     KVMState *s = kvm_state;
@@ -599,12 +644,25 @@ err:
  * dirty pages logging control
  */
 
+/*
+ * 在以下使用kvm_mem_flags():
+ *   - accel/kvm/kvm-all.c|624| <<kvm_slot_update_flags>> mem->flags = kvm_mem_flags(mr);
+ *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> mem->flags = kvm_mem_flags(mr);
+ */
 static int kvm_mem_flags(MemoryRegion *mr)
 {
     bool readonly = mr->readonly || memory_region_is_romd(mr);
     int flags = 0;
 
     if (memory_region_get_dirty_log_mask(mr) != 0) {
+        /*
+	 *  在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+	 *   - linux-headers/linux/kvm.h|51| <<global>> #define KVM_MEM_LOG_DIRTY_PAGES (1UL << 0)
+	 *   - accel/kvm/kvm-all.c|608| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+	 *   - accel/kvm/kvm-all.c|720| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+	 *   - accel/kvm/kvm-all.c|1490| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	 *   - accel/kvm/kvm-all.c|1797| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	 */
         flags |= KVM_MEM_LOG_DIRTY_PAGES;
     }
     if (readonly && kvm_readonly_mem_allowed) {
@@ -621,6 +679,11 @@ static int kvm_mem_flags(MemoryRegion *mr)
 static int kvm_slot_update_flags(KVMMemoryListener *kml, KVMSlot *mem,
                                  MemoryRegion *mr)
 {
+    /*
+     * 在以下使用kvm_mem_flags():
+     *   - accel/kvm/kvm-all.c|624| <<kvm_slot_update_flags>> mem->flags = kvm_mem_flags(mr);
+     *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> mem->flags = kvm_mem_flags(mr);
+     */
     mem->flags = kvm_mem_flags(mr);
 
     /* If nothing changed effectively, no need to issue ioctl */
@@ -664,6 +727,24 @@ out:
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_log_start (listener=0x5555576ac8b8, section=0x7ffec5bf6360, old=0, new=4) at ../accel/kvm/kvm-all.c:671
+ * #1  0x0000555555ebb2ec in address_space_update_topology_pass (as=0x555557384080 <address_space_memory>,
+ *     old_view=0x7ffed4005a70, new_view=0x7ffeb40506a0, adding=true) at ../system/memory.c:1019
+ * #2  0x0000555555ebb787 in address_space_set_flatview (as=0x555557384080 <address_space_memory>) at ../system/memory.c:1112
+ * #3  0x0000555555ebb964 in memory_region_transaction_commit () at ../system/memory.c:1164
+ * #4  0x0000555555ec0ef4 in memory_global_dirty_log_start (flags=1, errp=0x7ffec5bf6628) at ../system/memory.c:2981
+ * #5  0x0000555555edacd2 in ram_init_bitmaps (rs=0x7ffeb4008290, errp=0x7ffec5bf6628) at ../migration/ram.c:2729
+ * #6  0x0000555555edaddc in ram_init_all (rsp=0x555557384360 <ram_state>, errp=0x7ffec5bf6628) at ../migration/ram.c:2763
+ * #7  0x0000555555edb46a in ram_save_setup (f=0x55555779d910, opaque=0x555557384360 <ram_state>, errp=0x7ffec5bf6628)
+ *     at ../migration/ram.c:2957
+ * #8  0x0000555555c818ec in qemu_savevm_state_setup (f=0x55555779d910, errp=0x7ffec5bf6628) at ../migration/savevm.c:1380
+ * #9  0x0000555555c6933f in migration_thread (opaque=0x55555745c750) at ../migration/migration.c:3690
+ * #10 0x00005555561ad4c6 in qemu_thread_start (args=0x55555824c5b0) at ../util/qemu-thread-posix.c:541
+ * #11 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #12 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 static void kvm_log_start(MemoryListener *listener,
                           MemoryRegionSection *section,
                           int old, int new)
@@ -681,6 +762,33 @@ static void kvm_log_start(MemoryListener *listener,
     }
 }
 
+/*
+ * (gdb) bt
+#0  kvm_log_stop (listener=0x5555576ac8b8, section=0x7fffffffd5b0, old=4, new=0) at ../accel/kvm/kvm-all.c:688
+#1  0x0000555555ebb3c0 in address_space_update_topology_pass (as=0x555557384080 <address_space_memory>, old_view=0x7ffe8c050df0, new_view=0x5555578709b0,
+    adding=true) at ../system/memory.c:1024
+#2  0x0000555555ebb787 in address_space_set_flatview (as=0x555557384080 <address_space_memory>) at ../system/memory.c:1112
+#3  0x0000555555ebb964 in memory_region_transaction_commit () at ../system/memory.c:1164
+#4  0x0000555555ec0fb9 in memory_global_dirty_log_do_stop (flags=1) at ../system/memory.c:2997
+#5  0x0000555555ec112c in memory_global_dirty_log_stop (flags=1) at ../system/memory.c:3044
+#6  0x0000555555ed9f8e in ram_save_cleanup (opaque=0x555557384360 <ram_state>) at ../migration/ram.c:2331
+#7  0x0000555555c82737 in qemu_savevm_state_cleanup () at ../migration/savevm.c:1737
+#8  0x0000555555c6462d in migration_cleanup (s=0x55555745c750) at ../migration/migration.c:1476
+#9  0x0000555555c6484b in migration_cleanup_bh (opaque=0x55555745c750) at ../migration/migration.c:1528
+#10 0x0000555555c61d92 in migration_bh_dispatch_bh (opaque=0x7ffe8c0bf4e0) at ../migration/migration.c:340
+#11 0x00005555561c8b2b in aio_bh_call (bh=0x55555777a8d0) at ../util/async.c:172
+#12 0x00005555561c8c79 in aio_bh_poll (ctx=0x55555745e9c0) at ../util/async.c:219
+#13 0x00005555561a773d in aio_dispatch (ctx=0x55555745e9c0) at ../util/aio-posix.c:436
+#14 0x00005555561c9148 in aio_ctx_dispatch (source=0x55555745e9c0, callback=0x0, user_data=0x0) at ../util/async.c:361
+#15 0x00007ffff6fd394b in g_main_dispatch (context=0x55555745edd0) at ../glib/gmain.c:3325
+#16 g_main_context_dispatch (context=0x55555745edd0) at ../glib/gmain.c:4043
+#17 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+#18 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=785834740) at ../util/main-loop.c:310
+#19 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+#20 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+#21 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+#22 0x00005555560d296f in main (argc=20, argv=0x7fffffffdb78) at ../system/main.c:80
+ */
 static void kvm_log_stop(MemoryListener *listener,
                           MemoryRegionSection *section,
                           int old, int new)
@@ -717,6 +825,14 @@ static void kvm_slot_reset_dirty_pages(KVMSlot *slot)
 /* Allocate the dirty bitmap for a slot  */
 static void kvm_slot_init_dirty_bitmap(KVMSlot *mem)
 {
+    /*
+     * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+     *   - linux-headers/linux/kvm.h|51| <<global>> #define KVM_MEM_LOG_DIRTY_PAGES (1UL << 0)
+     *   - accel/kvm/kvm-all.c|608| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+     *   - accel/kvm/kvm-all.c|720| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+     *   - accel/kvm/kvm-all.c|1490| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+     *   - accel/kvm/kvm-all.c|1797| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+     */
     if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
         return;
     }
@@ -1487,6 +1603,14 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
             if (!mem) {
                 return;
             }
+            /*
+	     * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+	     *   - linux-headers/linux/kvm.h|51| <<global>> #define KVM_MEM_LOG_DIRTY_PAGES (1UL << 0)
+	     *   - accel/kvm/kvm-all.c|608| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+	     *   - accel/kvm/kvm-all.c|720| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+	     *   - accel/kvm/kvm-all.c|1490| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	     *   - accel/kvm/kvm-all.c|1797| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	     */
             if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
                 /*
                  * NOTE: We should be aware of the fact that here we're only
@@ -1540,6 +1664,11 @@ static void kvm_set_phys_mem(KVMMemoryListener *kml,
         mem->start_addr = start_addr;
         mem->ram_start_offset = ram_start_offset;
         mem->ram = ram;
+	/*
+	 * 在以下使用kvm_mem_flags():
+	 *   - accel/kvm/kvm-all.c|624| <<kvm_slot_update_flags>> mem->flags = kvm_mem_flags(mr);
+	 *   - accel/kvm/kvm-all.c|1543| <<kvm_set_phys_mem>> mem->flags = kvm_mem_flags(mr);
+	 */
         mem->flags = kvm_mem_flags(mr);
         mem->guest_memfd = mr->ram_block->guest_memfd;
         mem->guest_memfd_offset = (uint8_t*)ram - mr->ram_block->host;
@@ -1794,6 +1923,14 @@ static void kvm_log_sync_global(MemoryListener *l, bool last_stage)
     kvm_slots_lock();
     for (i = 0; i < kml->nr_slots_allocated; i++) {
         mem = &kml->slots[i];
+        /*
+	 * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+	 *   - linux-headers/linux/kvm.h|51| <<global>> #define KVM_MEM_LOG_DIRTY_PAGES (1UL << 0)
+	 *   - accel/kvm/kvm-all.c|608| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+	 *   - accel/kvm/kvm-all.c|720| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+	 *   - accel/kvm/kvm-all.c|1490| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	 *   - accel/kvm/kvm-all.c|1797| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+	 */
         if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
             kvm_slot_sync_dirty_pages(mem);
 
@@ -1949,6 +2086,17 @@ static MemoryListener kvm_io_listener = {
     .priority = MEMORY_LISTENER_PRIORITY_DEV_BACKEND,
 };
 
+/*
+ * 在以下使用kvm_set_irq():
+ *   - hw/i386/kvm/i8259.c|119| <<kvm_pic_set_irq>> delivered = kvm_set_irq(kvm_state, irq, level);
+ *   - hw/i386/kvm/ioapic.c|118| <<kvm_ioapic_set_irq>> delivered = kvm_set_irq(kvm_state, s->kvm_gsi_base + irq, level);
+ *   - hw/intc/ioapic.c|125| <<ioapic_service>> kvm_set_irq(kvm_state, i, 1);
+ *   - hw/intc/ioapic.c|126| <<ioapic_service>> kvm_set_irq(kvm_state, i, 0);
+ *   - hw/intc/ioapic.c|128| <<ioapic_service>> kvm_set_irq(kvm_state, i, 1);
+ *   - hw/intc/openpic_kvm.c|56| <<kvm_openpic_set_irq>> kvm_set_irq(kvm_state, n_IRQ, level);
+ *   - target/arm/kvm.c|1553| <<kvm_arm_set_irq>> return kvm_set_irq(kvm_state, kvm_irq, !!level);
+ *   - target/riscv/kvm/kvm-cpu.c|56| <<riscv_kvm_aplic_request>> kvm_set_irq(kvm_state, irq, !!level);
+ */
 int kvm_set_irq(KVMState *s, int irq, int level)
 {
     struct kvm_irq_level event;
@@ -1994,6 +2142,23 @@ void kvm_init_irq_routing(KVMState *s)
         s->gsi_count = gsi_count;
     }
 
+    /*
+     * 在以下使用KVMState->irq_routes:
+     *   - accel/kvm/kvm-all.c|2111| <<kvm_init_irq_routing>> s->irq_routes = g_malloc0(sizeof(*s->irq_routes));
+     *   - accel/kvm/kvm-all.c|2129| <<kvm_irqchip_commit_routes>> s->irq_routes->flags = 0;
+     *   - accel/kvm/kvm-all.c|2131| <<kvm_irqchip_commit_routes>> ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);
+     *   - accel/kvm/kvm-all.c|2141| <<kvm_add_routing_entry>> if (s->irq_routes->nr == s->nr_allocated_irq_routes) {
+     *   - accel/kvm/kvm-all.c|2148| <<kvm_add_routing_entry>> s->irq_routes = g_realloc(s->irq_routes, size);
+     *   - accel/kvm/kvm-all.c|2151| <<kvm_add_routing_entry>> n = s->irq_routes->nr++;
+     *   - accel/kvm/kvm-all.c|2152| <<kvm_add_routing_entry>> new = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2165| <<kvm_update_routing_entry>> for (n = 0; n < s->irq_routes->nr; n++) {
+     *   - accel/kvm/kvm-all.c|2166| <<kvm_update_routing_entry>> entry = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2206| <<kvm_irqchip_release_virq>> for (i = 0; i < s->irq_routes->nr; i++) {
+     *   - accel/kvm/kvm-all.c|2207| <<kvm_irqchip_release_virq>> e = &s->irq_routes->entries[i];
+     *   - accel/kvm/kvm-all.c|2209| <<kvm_irqchip_release_virq>> s->irq_routes->nr--;
+     *   - accel/kvm/kvm-all.c|2210| <<kvm_irqchip_release_virq>> *e = s->irq_routes->entries[s->irq_routes->nr];
+     *   - accel/kvm/kvm-all.c|2314| <<kvm_irqchip_add_msi_route>> if (s->irq_routes->nr < s->gsi_count) {
+     */
     s->irq_routes = g_malloc0(sizeof(*s->irq_routes));
     s->nr_allocated_irq_routes = 0;
 
@@ -2012,6 +2177,23 @@ void kvm_irqchip_commit_routes(KVMState *s)
         return;
     }
 
+    /*
+     * 在以下使用KVMState->irq_routes:
+     *   - accel/kvm/kvm-all.c|2111| <<kvm_init_irq_routing>> s->irq_routes = g_malloc0(sizeof(*s->irq_routes));
+     *   - accel/kvm/kvm-all.c|2129| <<kvm_irqchip_commit_routes>> s->irq_routes->flags = 0;
+     *   - accel/kvm/kvm-all.c|2131| <<kvm_irqchip_commit_routes>> ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);
+     *   - accel/kvm/kvm-all.c|2141| <<kvm_add_routing_entry>> if (s->irq_routes->nr == s->nr_allocated_irq_routes) {
+     *   - accel/kvm/kvm-all.c|2148| <<kvm_add_routing_entry>> s->irq_routes = g_realloc(s->irq_routes, size);
+     *   - accel/kvm/kvm-all.c|2151| <<kvm_add_routing_entry>> n = s->irq_routes->nr++;
+     *   - accel/kvm/kvm-all.c|2152| <<kvm_add_routing_entry>> new = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2165| <<kvm_update_routing_entry>> for (n = 0; n < s->irq_routes->nr; n++) {
+     *   - accel/kvm/kvm-all.c|2166| <<kvm_update_routing_entry>> entry = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2206| <<kvm_irqchip_release_virq>> for (i = 0; i < s->irq_routes->nr; i++) {
+     *   - accel/kvm/kvm-all.c|2207| <<kvm_irqchip_release_virq>> e = &s->irq_routes->entries[i];
+     *   - accel/kvm/kvm-all.c|2209| <<kvm_irqchip_release_virq>> s->irq_routes->nr--;
+     *   - accel/kvm/kvm-all.c|2210| <<kvm_irqchip_release_virq>> *e = s->irq_routes->entries[s->irq_routes->nr];
+     *   - accel/kvm/kvm-all.c|2314| <<kvm_irqchip_add_msi_route>> if (s->irq_routes->nr < s->gsi_count) {
+     */
     s->irq_routes->flags = 0;
     trace_kvm_irqchip_commit_routes();
     ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);
@@ -2024,6 +2206,23 @@ void kvm_add_routing_entry(KVMState *s,
     struct kvm_irq_routing_entry *new;
     int n, size;
 
+    /*
+     * 在以下使用KVMState->irq_routes:
+     *   - accel/kvm/kvm-all.c|2111| <<kvm_init_irq_routing>> s->irq_routes = g_malloc0(sizeof(*s->irq_routes));
+     *   - accel/kvm/kvm-all.c|2129| <<kvm_irqchip_commit_routes>> s->irq_routes->flags = 0;
+     *   - accel/kvm/kvm-all.c|2131| <<kvm_irqchip_commit_routes>> ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);
+     *   - accel/kvm/kvm-all.c|2141| <<kvm_add_routing_entry>> if (s->irq_routes->nr == s->nr_allocated_irq_routes) {
+     *   - accel/kvm/kvm-all.c|2148| <<kvm_add_routing_entry>> s->irq_routes = g_realloc(s->irq_routes, size);
+     *   - accel/kvm/kvm-all.c|2151| <<kvm_add_routing_entry>> n = s->irq_routes->nr++;
+     *   - accel/kvm/kvm-all.c|2152| <<kvm_add_routing_entry>> new = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2165| <<kvm_update_routing_entry>> for (n = 0; n < s->irq_routes->nr; n++) {
+     *   - accel/kvm/kvm-all.c|2166| <<kvm_update_routing_entry>> entry = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2206| <<kvm_irqchip_release_virq>> for (i = 0; i < s->irq_routes->nr; i++) {
+     *   - accel/kvm/kvm-all.c|2207| <<kvm_irqchip_release_virq>> e = &s->irq_routes->entries[i];
+     *   - accel/kvm/kvm-all.c|2209| <<kvm_irqchip_release_virq>> s->irq_routes->nr--;
+     *   - accel/kvm/kvm-all.c|2210| <<kvm_irqchip_release_virq>> *e = s->irq_routes->entries[s->irq_routes->nr];
+     *   - accel/kvm/kvm-all.c|2314| <<kvm_irqchip_add_msi_route>> if (s->irq_routes->nr < s->gsi_count) {
+     */
     if (s->irq_routes->nr == s->nr_allocated_irq_routes) {
         n = s->nr_allocated_irq_routes * 2;
         if (n < 64) {
@@ -2048,6 +2247,23 @@ static int kvm_update_routing_entry(KVMState *s,
     struct kvm_irq_routing_entry *entry;
     int n;
 
+    /*
+     * 在以下使用KVMState->irq_routes:
+     *   - accel/kvm/kvm-all.c|2111| <<kvm_init_irq_routing>> s->irq_routes = g_malloc0(sizeof(*s->irq_routes));
+     *   - accel/kvm/kvm-all.c|2129| <<kvm_irqchip_commit_routes>> s->irq_routes->flags = 0;
+     *   - accel/kvm/kvm-all.c|2131| <<kvm_irqchip_commit_routes>> ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);
+     *   - accel/kvm/kvm-all.c|2141| <<kvm_add_routing_entry>> if (s->irq_routes->nr == s->nr_allocated_irq_routes) {
+     *   - accel/kvm/kvm-all.c|2148| <<kvm_add_routing_entry>> s->irq_routes = g_realloc(s->irq_routes, size);
+     *   - accel/kvm/kvm-all.c|2151| <<kvm_add_routing_entry>> n = s->irq_routes->nr++;
+     *   - accel/kvm/kvm-all.c|2152| <<kvm_add_routing_entry>> new = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2165| <<kvm_update_routing_entry>> for (n = 0; n < s->irq_routes->nr; n++) {
+     *   - accel/kvm/kvm-all.c|2166| <<kvm_update_routing_entry>> entry = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2206| <<kvm_irqchip_release_virq>> for (i = 0; i < s->irq_routes->nr; i++) {
+     *   - accel/kvm/kvm-all.c|2207| <<kvm_irqchip_release_virq>> e = &s->irq_routes->entries[i];
+     *   - accel/kvm/kvm-all.c|2209| <<kvm_irqchip_release_virq>> s->irq_routes->nr--;
+     *   - accel/kvm/kvm-all.c|2210| <<kvm_irqchip_release_virq>> *e = s->irq_routes->entries[s->irq_routes->nr];
+     *   - accel/kvm/kvm-all.c|2314| <<kvm_irqchip_add_msi_route>> if (s->irq_routes->nr < s->gsi_count) {
+     */
     for (n = 0; n < s->irq_routes->nr; n++) {
         entry = &s->irq_routes->entries[n];
         if (entry->gsi != new_entry->gsi) {
@@ -2089,6 +2305,23 @@ void kvm_irqchip_release_virq(KVMState *s, int virq)
         return;
     }
 
+    /*
+     * 在以下使用KVMState->irq_routes:
+     *   - accel/kvm/kvm-all.c|2111| <<kvm_init_irq_routing>> s->irq_routes = g_malloc0(sizeof(*s->irq_routes));
+     *   - accel/kvm/kvm-all.c|2129| <<kvm_irqchip_commit_routes>> s->irq_routes->flags = 0;
+     *   - accel/kvm/kvm-all.c|2131| <<kvm_irqchip_commit_routes>> ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);
+     *   - accel/kvm/kvm-all.c|2141| <<kvm_add_routing_entry>> if (s->irq_routes->nr == s->nr_allocated_irq_routes) {
+     *   - accel/kvm/kvm-all.c|2148| <<kvm_add_routing_entry>> s->irq_routes = g_realloc(s->irq_routes, size);
+     *   - accel/kvm/kvm-all.c|2151| <<kvm_add_routing_entry>> n = s->irq_routes->nr++;
+     *   - accel/kvm/kvm-all.c|2152| <<kvm_add_routing_entry>> new = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2165| <<kvm_update_routing_entry>> for (n = 0; n < s->irq_routes->nr; n++) {
+     *   - accel/kvm/kvm-all.c|2166| <<kvm_update_routing_entry>> entry = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2206| <<kvm_irqchip_release_virq>> for (i = 0; i < s->irq_routes->nr; i++) {
+     *   - accel/kvm/kvm-all.c|2207| <<kvm_irqchip_release_virq>> e = &s->irq_routes->entries[i];
+     *   - accel/kvm/kvm-all.c|2209| <<kvm_irqchip_release_virq>> s->irq_routes->nr--;
+     *   - accel/kvm/kvm-all.c|2210| <<kvm_irqchip_release_virq>> *e = s->irq_routes->entries[s->irq_routes->nr];
+     *   - accel/kvm/kvm-all.c|2314| <<kvm_irqchip_add_msi_route>> if (s->irq_routes->nr < s->gsi_count) {
+     */
     for (i = 0; i < s->irq_routes->nr; i++) {
         e = &s->irq_routes->entries[i];
         if (e->gsi == virq) {
@@ -2129,8 +2362,24 @@ int kvm_irqchip_get_virq(KVMState *s)
     }
 }
 
+/*
+ * 在以下使用kvm_irqchip_send_msi():
+ *   - hw/i386/kvm/apic.c|277| <<kvm_send_msi>> ret = kvm_irqchip_send_msi(kvm_state, *msg);
+ *   - target/i386/kvm/xen-emu.c|451| <<kvm_xen_inject_vcpu_callback_vector>> kvm_irqchip_send_msi(kvm_state, msg);
+ */
 int kvm_irqchip_send_msi(KVMState *s, MSIMessage msg)
 {
+    /*
+     * 1093 #define KVM_MSI_VALID_DEVID     (1U << 0)
+     * 1094 struct kvm_msi {
+     * 1095         __u32 address_lo;
+     * 1096         __u32 address_hi;
+     * 1097         __u32 data;
+     * 1098         __u32 flags;
+     * 1099         __u32 devid;
+     * 1100         __u8  pad[12];
+     * 1101 };
+     */
     struct kvm_msi msi;
 
     msi.address_lo = (uint32_t)msg.address;
@@ -2181,6 +2430,23 @@ int kvm_irqchip_add_msi_route(KVMRouteChange *c, int vector, PCIDevice *dev)
         return -EINVAL;
     }
 
+    /*
+     * 在以下使用KVMState->irq_routes:
+     *   - accel/kvm/kvm-all.c|2111| <<kvm_init_irq_routing>> s->irq_routes = g_malloc0(sizeof(*s->irq_routes));
+     *   - accel/kvm/kvm-all.c|2129| <<kvm_irqchip_commit_routes>> s->irq_routes->flags = 0;
+     *   - accel/kvm/kvm-all.c|2131| <<kvm_irqchip_commit_routes>> ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);
+     *   - accel/kvm/kvm-all.c|2141| <<kvm_add_routing_entry>> if (s->irq_routes->nr == s->nr_allocated_irq_routes) {
+     *   - accel/kvm/kvm-all.c|2148| <<kvm_add_routing_entry>> s->irq_routes = g_realloc(s->irq_routes, size);
+     *   - accel/kvm/kvm-all.c|2151| <<kvm_add_routing_entry>> n = s->irq_routes->nr++;
+     *   - accel/kvm/kvm-all.c|2152| <<kvm_add_routing_entry>> new = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2165| <<kvm_update_routing_entry>> for (n = 0; n < s->irq_routes->nr; n++) {
+     *   - accel/kvm/kvm-all.c|2166| <<kvm_update_routing_entry>> entry = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2206| <<kvm_irqchip_release_virq>> for (i = 0; i < s->irq_routes->nr; i++) {
+     *   - accel/kvm/kvm-all.c|2207| <<kvm_irqchip_release_virq>> e = &s->irq_routes->entries[i];
+     *   - accel/kvm/kvm-all.c|2209| <<kvm_irqchip_release_virq>> s->irq_routes->nr--;
+     *   - accel/kvm/kvm-all.c|2210| <<kvm_irqchip_release_virq>> *e = s->irq_routes->entries[s->irq_routes->nr];
+     *   - accel/kvm/kvm-all.c|2314| <<kvm_irqchip_add_msi_route>> if (s->irq_routes->nr < s->gsi_count) {
+     */
     if (s->irq_routes->nr < s->gsi_count) {
         trace_kvm_irqchip_add_msi_route(dev ? dev->name : (char *)"N/A",
                                         vector, virq);
@@ -2228,6 +2494,11 @@ int kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg,
     return kvm_update_routing_entry(s, &kroute);
 }
 
+/*
+ * 在以下使用kvm_irqchip_assign_irqfd():
+ *   - accel/kvm/kvm-all.c|2431| <<kvm_irqchip_add_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, rn, virq, true);
+ *   - accel/kvm/kvm-all.c|2437| <<kvm_irqchip_remove_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, NULL, virq, false);
+ */
 static int kvm_irqchip_assign_irqfd(KVMState *s, EventNotifier *event,
                                     EventNotifier *resample, int virq,
                                     bool assign)
@@ -2317,15 +2588,37 @@ int kvm_irqchip_update_msi_route(KVMState *s, int virq, MSIMessage msg)
 }
 #endif /* !KVM_CAP_IRQ_ROUTING */
 
+/*
+ * 在以下使用kvm_irqchip_add_irqfd_notifier_gsi():
+ *   - accel/kvm/kvm-all.c|2449| <<kvm_irqchip_add_irqfd_notifier>> return kvm_irqchip_add_irqfd_notifier_gsi(s, n, rn, GPOINTER_TO_INT(gsi));
+ *   - hw/hyperv/hyperv.c|463| <<hyperv_sint_route_new>> r = kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &sint_route->sint_set_notifier, ack_notifier, gsi);
+ *   - hw/misc/ivshmem-pci.c|296| <<ivshmem_vector_unmask>> ret = kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL, v->virq);
+ *   - hw/misc/ivshmem-pci.c|467| <<setup_interrupt>> kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL, s->msi_vectors[vector].virq);
+ *   - hw/remote/proxy.c|45| <<proxy_intx_update>> kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &dev->intr, &dev->resample, dev->virq);
+ *   - hw/s390x/virtio-ccw.c|1004| <<virtio_ccw_add_irqfd>> return kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, notifier, NULL, dev->routes.gsi[n]);
+ *   - hw/vfio/pci.c|142| <<vfio_intx_enable_kvm>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &vdev->intx.interrupt, &vdev->intx.unmask, vdev->intx.route.irq)) {
+ *   - hw/vfio/pci.c|484| <<vfio_connect_kvm_msi_virq>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt, NULL, vector->virq) < 0) {
+ *   - hw/virtio/virtio-pci.c|854| <<kvm_virtio_pci_irqfd_use>> return kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, n, NULL, irqfd->virq);
+ */
 int kvm_irqchip_add_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,
                                        EventNotifier *rn, int virq)
 {
+    /*
+     * 在以下使用kvm_irqchip_assign_irqfd():
+     *   - accel/kvm/kvm-all.c|2431| <<kvm_irqchip_add_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, rn, virq, true);
+     *   - accel/kvm/kvm-all.c|2437| <<kvm_irqchip_remove_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, NULL, virq, false);
+     */
     return kvm_irqchip_assign_irqfd(s, n, rn, virq, true);
 }
 
 int kvm_irqchip_remove_irqfd_notifier_gsi(KVMState *s, EventNotifier *n,
                                           int virq)
 {
+    /*
+     * 在以下使用kvm_irqchip_assign_irqfd():
+     *   - accel/kvm/kvm-all.c|2431| <<kvm_irqchip_add_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, rn, virq, true);
+     *   - accel/kvm/kvm-all.c|2437| <<kvm_irqchip_remove_irqfd_notifier_gsi>> return kvm_irqchip_assign_irqfd(s, n, NULL, virq, false);
+     */
     return kvm_irqchip_assign_irqfd(s, n, NULL, virq, false);
 }
 
@@ -2860,10 +3153,37 @@ void kvm_flush_coalesced_mmio_buffer(void)
     s->coalesced_flush_in_progress = false;
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-all.c|3175| <<kvm_cpu_synchronize_state>> run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
 {
+    /*
+     * 在以下使用CPUState->vcpu_dirty:
+     *   - accel/kvm/kvm-all.c|480| <<kvm_create_vcpu>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3128| <<do_kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3142| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3174| <<kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3194| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3216| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3232| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3405| <<kvm_cpu_exec>> if (cpu->vcpu_dirty) {
+     *   - accel/kvm/kvm-all.c|3419| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/mips/kvm.c|563| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *   - target/mips/kvm.c|579| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *
+     * cpu->vcpu_dirty说明有东西要从QEMU更新到KVM
+     * 比如要调用kvm_arch_put_registers()
+     * !cpu->vcpu_dirty说明"也许"有东西要从KVM更新到QEMU
+     * 比如要调用kvm_arch_get_registers()
+     */
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
         Error *err = NULL;
+        /*
+	 * 在以下使用kvm_arch_get_registers():
+	 *   - accel/kvm/kvm-all.c|3130| <<do_kvm_cpu_synchronize_state>> int ret = kvm_arch_get_registers(cpu, &err);
+	 */
         int ret = kvm_arch_get_registers(cpu, &err);
         if (ret) {
             if (err) {
@@ -2876,20 +3196,95 @@ static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
             vm_stop(RUN_STATE_INTERNAL_ERROR);
         }
 
+        /*
+	 * cpu->vcpu_dirty说明有东西要从QEMU更新到KVM
+         * 比如要调用kvm_arch_put_registers()
+         * !cpu->vcpu_dirty说明"也许"有东西要从KVM更新到QEMU
+         * 比如要调用kvm_arch_get_registers()
+	 */
         cpu->vcpu_dirty = true;
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_state (cpu=0x55a74f0a0600) at ../accel/kvm/kvm-all.c:2884
+ * #1  0x000055a728b1784e in cpu_synchronize_state (cpu=0x55a74f0a0600) at ../system/cpus.c:173
+ * #2  0x000055a728c147a3 in hmp_info_local_apic (mon=0x55a74efccc80, qdict=0x55a74f0d5400) at ../target/i386/cpu-apic.c:100
+ * #3  0x000055a728b8b18f in handle_hmp_command_exec (mon=0x55a74efccc80, cmd=0x55a72a1a2900 <hmp_info_cmds+1280>, qdict=0x55a74f0d5400)
+ *     at ../monitor/hmp.c:1106
+ * #4  0x000055a728b8b3da in handle_hmp_command (mon=0x55a74efccc80, cmdline=0x55a74eff047b "7") at ../monitor/hmp.c:1158
+ * #5  0x000055a728b8845f in monitor_command_cb (opaque=0x55a74efccc80, cmdline=0x55a74eff0470 "info lapic 7", readline_opaque=0x0)
+ *     at ../monitor/hmp.c:47
+ * #6  0x000055a7290d8895 in readline_handle_byte (rs=0x55a74eff0470, ch=13) at ../util/readline.c:427
+ * #7  0x000055a728b8c031 in monitor_read (opaque=0x55a74efccc80, buf=0x7ffc02430f80 "\r", size=1) at ../monitor/hmp.c:1390
+ * #8  0x000055a728fc1d61 in qemu_chr_be_write_impl (s=0x55a74eda1300, buf=0x7ffc02430f80 "\r", len=1) at ../chardev/char.c:214
+ * #9  0x000055a728fc1dd2 in qemu_chr_be_write (s=0x55a74eda1300, buf=0x7ffc02430f80 "\r", len=1) at ../chardev/char.c:226
+ * #10 0x000055a728fc4df1 in fd_chr_read (chan=0x55a74ef82ae0, cond=G_IO_IN, opaque=0x55a74eda1300) at ../chardev/char-fd.c:72
+ * #11 0x000055a728e898d0 in qio_channel_fd_source_dispatch (source=0x55a74f0b9280, callback=0x55a728fc4c95 <fd_chr_read>,
+ *     user_data=0x55a74eda1300) at ../io/channel-watch.c:84
+ * #12 0x00007f67cd01f854 in g_main_dispatch (context=0x55a74ed3d990) at ../glib/gmain.c:3325
+ * #13 g_main_context_dispatch (context=0x55a74ed3d990) at ../glib/gmain.c:4043
+ * #14 0x000055a7290c4939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #15 0x000055a7290c49c7 in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:310
+ * #16 0x000055a7290c4af6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #17 0x000055a728b27c8a in qemu_main_loop () at ../system/runstate.c:835
+ * #18 0x000055a728fcc8b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #19 0x000055a728fcc96f in main (argc=23, argv=0x7ffc02432238) at ../system/main.c:80
+ *
+ * 在以下使用kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-accel-ops.c|131| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - accel/kvm/kvm-all.c|3547| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+ *   - target/arm/kvm.c|1376| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/arm/kvm.c|2389| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+ *   - target/i386/kvm/kvm.c|5646| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5665| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5683| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5688| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|6202| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+ *   - target/loongarch/kvm/kvm.c|1323| <<kvm_loongarch_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/riscv/kvm/kvm-cpu.c|1589| <<kvm_riscv_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/s390x/kvm/kvm.c|1911| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+ */
 void kvm_cpu_synchronize_state(CPUState *cpu)
 {
+    /*
+     * 在以下使用CPUState->vcpu_dirty:
+     *   - accel/kvm/kvm-all.c|480| <<kvm_create_vcpu>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3128| <<do_kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3142| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3174| <<kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3194| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3216| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3232| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3405| <<kvm_cpu_exec>> if (cpu->vcpu_dirty) {
+     *   - accel/kvm/kvm-all.c|3419| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/mips/kvm.c|563| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *   - target/mips/kvm.c|579| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *
+     * cpu->vcpu_dirty说明有东西要从QEMU更新到KVM
+     * 比如要调用kvm_arch_put_registers()
+     * !cpu->vcpu_dirty说明"也许"有东西要从KVM更新到QEMU
+     * 比如要调用kvm_arch_get_registers()
+     */
     if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
         run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);
     }
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_post_reset():
+ *   - accel/kvm/kvm-all.c|3199| <<kvm_cpu_synchronize_post_reset>> run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_post_reset(CPUState *cpu, run_on_cpu_data arg)
 {
     Error *err = NULL;
+    /*
+     * 在以下使用kvm_arch_put_registers():
+     *   - accel/kvm/kvm-all.c|3182| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+     *   - accel/kvm/kvm-all.c|3205| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+     *   - vaccel/kvm/kvm-all.c|3407| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+     */
     int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
     if (ret) {
         if (err) {
@@ -2902,17 +3297,58 @@ static void do_kvm_cpu_synchronize_post_reset(CPUState *cpu, run_on_cpu_data arg
         vm_stop(RUN_STATE_INTERNAL_ERROR);
     }
 
+    /*
+     * 在以下使用CPUState->vcpu_dirty:
+     *   - accel/kvm/kvm-all.c|480| <<kvm_create_vcpu>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3128| <<do_kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3142| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3174| <<kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3194| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3216| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3232| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3405| <<kvm_cpu_exec>> if (cpu->vcpu_dirty) {
+     *   - accel/kvm/kvm-all.c|3419| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/mips/kvm.c|563| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *   - target/mips/kvm.c|579| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *
+     * cpu->vcpu_dirty说明有东西要从QEMU更新到KVM
+     * 比如要调用kvm_arch_put_registers()
+     * !cpu->vcpu_dirty说明"也许"有东西要从KVM更新到QEMU
+     * 比如要调用kvm_arch_get_registers()
+     */
     cpu->vcpu_dirty = false;
 }
 
+/*
+ * 在以下使用cpus_accel->synchronize_post_reset:
+ *   - accel/hvf/hvf-accel-ops.c|588| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+ *   - accel/kvm/kvm-accel-ops.c|129| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+ *   - system/cpus.c|269| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+ *   - system/cpus.c|270| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|91| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+ *   - target/i386/whpx/whpx-accel-ops.c|94| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+ *
+ * 在以下使用kvm_cpu_synchronize_post_reset():
+ *   - accel/kvm/kvm-accel-ops.c|129| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+ */
 void kvm_cpu_synchronize_post_reset(CPUState *cpu)
 {
     run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-all.c|3365| <<kvm_cpu_synchronize_post_init>> run_on_cpu(cpu, do_kvm_cpu_synchronize_post_init, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
 {
     Error *err = NULL;
+    /*
+     * 在以下使用kvm_arch_put_registers():
+     *   - accel/kvm/kvm-all.c|3182| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+     *   - accel/kvm/kvm-all.c|3205| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+     *   - vaccel/kvm/kvm-all.c|3407| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+     */
     int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
     if (ret) {
         if (err) {
@@ -2924,9 +3360,94 @@ static void do_kvm_cpu_synchronize_post_init(CPUState *cpu, run_on_cpu_data arg)
         exit(1);
     }
 
+    /*
+     * 在以下使用CPUState->vcpu_dirty:
+     *   - accel/kvm/kvm-all.c|480| <<kvm_create_vcpu>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3128| <<do_kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3142| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3174| <<kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3194| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3216| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3232| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3405| <<kvm_cpu_exec>> if (cpu->vcpu_dirty) {
+     *   - accel/kvm/kvm-all.c|3419| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/mips/kvm.c|563| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *   - target/mips/kvm.c|579| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *
+     * cpu->vcpu_dirty说明有东西要从QEMU更新到KVM
+     * 比如要调用kvm_arch_put_registers()
+     * !cpu->vcpu_dirty说明"也许"有东西要从KVM更新到QEMU
+     * 比如要调用kvm_arch_get_registers()
+     */
     cpu->vcpu_dirty = false;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_post_init (cpu=0x5555577517f0) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c1d8cc in cpu_synchronize_post_init (cpu=0x5555577517f0) at ../system/cpus.c:187
+ * #2  0x0000555555c1d747 in cpu_synchronize_all_post_init () at ../system/cpus.c:157
+ * #3  0x000055555597d969 in qdev_machine_creation_done () at ../hw/core/machine.c:1720
+ * #4  0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #5  0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #6  0x0000555555c38346 in qemu_init (argc=21, argv=0x7fffffffdc28) at ../system/vl.c:3843
+ * #7  0x00005555560d2905 in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:71
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_post_init (cpu=0x55555775f620) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c1d8cc in cpu_synchronize_post_init (cpu=0x55555775f620) at ../system/cpus.c:187
+ * #2  0x000055555588ba76 in cpu_common_realizefn (dev=0x55555775f620, errp=0x7fffffffc318) at ../hw/core/cpu-common.c:219
+ * #3  0x0000555555daafd3 in x86_cpu_realizefn (dev=0x55555775f620, errp=0x7fffffffc3e0) at ../target/i386/cpu.c:8362
+ * #4  0x0000555555da3bf3 in max_x86_cpu_realize (dev=0x55555775f620, errp=0x7fffffffc3e0) at ../target/i386/cpu.c:5689
+ * #5  0x0000555555f1e213 in device_set_realized (obj=0x55555775f620, value=true, errp=0x7fffffffc700) at ../hw/core/qdev.c:494
+ * #6  0x0000555555f29192 in property_set_bool (obj=0x55555775f620, v=0x5555582cdbb0, name=0x5555563e9969 "realized",
+ *     opaque=0x555557460d40, errp=0x7fffffffc700) at ../qom/object.c:2374
+ * #7  0x0000555555f26c07 in object_property_set (obj=0x55555775f620, name=0x5555563e9969 "realized", v=0x5555582cdbb0,
+ *     errp=0x7fffffffc700) at ../qom/object.c:1449
+ * #8  0x0000555555f2ba94 in object_property_set_qobject (obj=0x55555775f620, name=0x5555563e9969 "realized", value=0x5555581a7830,
+ *     errp=0x7fffffffc700) at ../qom/qom-qobject.c:28
+ * #9  0x0000555555f26fac in object_property_set_bool (obj=0x55555775f620, name=0x5555563e9969 "realized", value=true,
+ *     errp=0x7fffffffc700) at ../qom/object.c:1519
+ * #10 0x0000555555f1d90b in qdev_realize (dev=0x55555775f620, bus=0x0, errp=0x7fffffffc700) at ../hw/core/qdev.c:276
+ * #11 0x0000555555c26632 in qdev_device_add_from_qdict (opts=0x5555577b5400, from_json=false, errp=0x7fffffffc700)
+ *     at ../system/qdev-monitor.c:714
+ * #12 0x0000555555c266e6 in qdev_device_add (opts=0x5555577a3620, errp=0x7fffffffc700) at ../system/qdev-monitor.c:733
+ * #13 0x0000555555c2730b in hmp_device_add (mon=0x5555576efc20, qdict=0x555557fd15d0) at ../system/qdev-monitor.c:994
+ * #14 0x0000555555c9118f in handle_hmp_command_exec (mon=0x5555576efc20, cmd=0x5555572ac020 <hmp_cmds+1920>, qdict=0x555557fd15d0)
+ *     at ../monitor/hmp.c:1106
+ * #15 0x0000555555c913da in handle_hmp_command (mon=0x5555576efc20, cmdline=0x555557711d7c
+ *     "host-x86_64-cpu,id=core2,socket-id=0,core-id=2,thread-id=0") at ../monitor/hmp.c:1158
+ * #16 0x0000555555c8e45f in monitor_command_cb (opaque=0x5555576efc20, cmdline=0x555557711d70
+ *     " device_add host-x86_64-cpu,id=core2,socket-id=0,core-id=2,thread-id=0", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #17 0x00005555561de895 in readline_handle_byte (rs=0x555557711d70, ch=13) at ../util/readline.c:427
+ * #18 0x0000555555c92031 in monitor_read (opaque=0x5555576efc20, buf=0x7fffffffc970 "\r", size=1) at ../monitor/hmp.c:1390
+ * #19 0x00005555560c7d61 in qemu_chr_be_write_impl (s=0x55555758df40, buf=0x7fffffffc970 "\r", len=1) at ../chardev/char.c:214
+ * #20 0x00005555560c7dd2 in qemu_chr_be_write (s=0x55555758df40, buf=0x7fffffffc970 "\r", len=1) at ../chardev/char.c:226
+ * #21 0x00005555560cadf1 in fd_chr_read (chan=0x5555576d6a00, cond=G_IO_IN, opaque=0x55555758df40) at ../chardev/char-fd.c:72
+ * #22 0x0000555555f8f8d0 in qio_channel_fd_source_dispatch (source=0x555557e71390, callback=0x5555560cac95 <fd_chr_read>,
+ *     user_data=0x55555758df40) at ../io/channel-watch.c:84
+ * #23 0x00007ffff6fd3854 in g_main_dispatch (context=0x55555745e9e0) at ../glib/gmain.c:3325
+ * #24 g_main_context_dispatch (context=0x55555745e9e0) at ../glib/gmain.c:4043
+ * #25 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #26 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=930966) at ../util/main-loop.c:310
+ * #27 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #28 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #29 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #30 0x00005555560d296f in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:80
+ *
+ *
+ * 在以下使用ops->synchronize_post_init:
+ *   - accel/hvf/hvf-accel-ops.c|589| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+ *   - accel/kvm/kvm-accel-ops.c|130| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ *   - system/cpus.c|196| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+ *   - system/cpus.c|197| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+ *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+ *
+ * 在以下使用kvm_cpu_synchronize_post_init():
+ *   - accel/kvm/kvm-accel-ops.c|130| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+ */
 void kvm_cpu_synchronize_post_init(CPUState *cpu)
 {
     if (!kvm_state->guest_state_protected) {
@@ -2940,6 +3461,25 @@ void kvm_cpu_synchronize_post_init(CPUState *cpu)
 
 static void do_kvm_cpu_synchronize_pre_loadvm(CPUState *cpu, run_on_cpu_data arg)
 {
+    /*
+     * 在以下使用CPUState->vcpu_dirty:
+     *   - accel/kvm/kvm-all.c|480| <<kvm_create_vcpu>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3128| <<do_kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3142| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3174| <<kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3194| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3216| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3232| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3405| <<kvm_cpu_exec>> if (cpu->vcpu_dirty) {
+     *   - accel/kvm/kvm-all.c|3419| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/mips/kvm.c|563| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *   - target/mips/kvm.c|579| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *
+     * cpu->vcpu_dirty说明有东西要从QEMU更新到KVM
+     * 比如要调用kvm_arch_put_registers()
+     * !cpu->vcpu_dirty说明"也许"有东西要从KVM更新到QEMU
+     * 比如要调用kvm_arch_get_registers()
+     */
     cpu->vcpu_dirty = true;
 }
 
@@ -2954,6 +3494,11 @@ static __thread int pending_sigbus_code;
 static __thread bool have_sigbus_pending;
 #endif
 
+/*
+ * 在以下使用kvm_cpu_kick():
+ *   - accel/kvm/kvm-all.c|3254| <<kvm_cpu_kick_self>> kvm_cpu_kick(current_cpu);
+ *   - accel/kvm/kvm-all.c|3940| <<kvm_ipi_signal>> kvm_cpu_kick(current_cpu);
+ */
 static void kvm_cpu_kick(CPUState *cpu)
 {
     qatomic_set(&cpu->kvm_run->immediate_exit, 1);
@@ -3091,6 +3636,10 @@ out_unref:
     return ret;
 }
 
+/*
+ * 只在以下调用kvm_cpu_exec():
+ *   - accel/kvm/kvm-accel-ops.c|51| <<kvm_vcpu_thread_fn>> r = kvm_cpu_exec(cpu);
+ */
 int kvm_cpu_exec(CPUState *cpu)
 {
     struct kvm_run *run = cpu->kvm_run;
@@ -3109,8 +3658,37 @@ int kvm_cpu_exec(CPUState *cpu)
     do {
         MemTxAttrs attrs;
 
+        /*
+	 * 在以下使用CPUState->vcpu_dirty:
+	 *   - accel/kvm/kvm-all.c|480| <<kvm_create_vcpu>> cpu->vcpu_dirty = true;
+         *   - accel/kvm/kvm-all.c|3128| <<do_kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+         *   - accel/kvm/kvm-all.c|3142| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+         *   - accel/kvm/kvm-all.c|3174| <<kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+         *   - accel/kvm/kvm-all.c|3194| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+         *   - accel/kvm/kvm-all.c|3216| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+         *   - accel/kvm/kvm-all.c|3232| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+         *   - accel/kvm/kvm-all.c|3405| <<kvm_cpu_exec>> if (cpu->vcpu_dirty) {
+         *   - accel/kvm/kvm-all.c|3419| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+         *   - target/mips/kvm.c|563| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+         *   - target/mips/kvm.c|579| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+	 *
+	 * cpu->vcpu_dirty说明有东西要从QEMU更新到KVM
+	 * 比如要调用kvm_arch_put_registers()
+	 * !cpu->vcpu_dirty说明"也许"有东西要从QEMU更新到KVM
+	 * 比如要调用kvm_arch_get_registers()
+	 */
         if (cpu->vcpu_dirty) {
             Error *err = NULL;
+            /*
+	     * 在以下使用kvm_arch_put_registers():
+	     *   - accel/kvm/kvm-all.c|3182| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+	     *   - accel/kvm/kvm-all.c|3205| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+	     *   - accel/kvm/kvm-all.c|3407| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+	     *
+	     * 这里是put, 是写
+	     * 说明有东西要从QEMU更新到KVM
+	     * cpu->vcpu_dirty说明有东西要从QEMU更新到KVM
+	     */
             ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
             if (ret) {
                 if (err) {
@@ -3123,6 +3701,12 @@ int kvm_cpu_exec(CPUState *cpu)
                 break;
             }
 
+            /*
+	     * cpu->vcpu_dirty说明有东西要从QEMU更新到KVM
+             * 比如要调用kvm_arch_put_registers()
+             * !cpu->vcpu_dirty说明"也许"有东西要从KVM更新到QEMU
+             * 比如要调用kvm_arch_get_registers()
+	     */
             cpu->vcpu_dirty = false;
         }
 
@@ -3144,6 +3728,12 @@ int kvm_cpu_exec(CPUState *cpu)
 
         run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0);
 
+	/*
+	 * kvm_arch_post_run()
+	 * -> cpu_set_apic_base(x86_cpu->apic_state, run->apic_base);
+	 *
+	 * 只在这里调用每一个arch的accel/kvm/kvm-all.c|3436| <<kvm_cpu_exec>> attrs = kvm_arch_post_run()
+	 */
         attrs = kvm_arch_post_run(cpu, run);
 
 #ifdef KVM_HAVE_MCE_INJECTION
@@ -3248,6 +3838,21 @@ int kvm_cpu_exec(CPUState *cpu)
                 ret = EXCP_INTERRUPT;
                 break;
             case KVM_SYSTEM_EVENT_CRASH:
+                /*
+		 * 在以下使用kvm_cpu_synchronize_state():
+                 *   - accel/kvm/kvm-accel-ops.c|131| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+                 *   - accel/kvm/kvm-all.c|3547| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+		 *   - target/arm/kvm.c|1376| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+		 *   - target/arm/kvm.c|2389| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+		 *   - target/i386/kvm/kvm.c|5646| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+		 *   - target/i386/kvm/kvm.c|5665| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+		 *   - target/i386/kvm/kvm.c|5683| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+		 *   - target/i386/kvm/kvm.c|5688| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+		 *   - target/i386/kvm/kvm.c|6202| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+		 *   - target/loongarch/kvm/kvm.c|1323| <<kvm_loongarch_handle_debug>> kvm_cpu_synchronize_state(cs);
+		 *   - target/riscv/kvm/kvm-cpu.c|1589| <<kvm_riscv_handle_debug>> kvm_cpu_synchronize_state(cs);
+		 *   - target/s390x/kvm/kvm.c|1911| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+		 */
                 kvm_cpu_synchronize_state(cpu);
                 bql_lock();
                 qemu_system_guest_panicked(cpu_get_crash_info(cpu));
@@ -3480,6 +4085,13 @@ static void kvm_invoke_set_guest_debug(CPUState *cpu, run_on_cpu_data data)
                                    &dbg_data->dbg);
 }
 
+/*
+ * 在以下调用kvm_update_guest_debug():
+ *   - accel/kvm/kvm-accel-ops.c|118| <<kvm_update_guest_debug_ops>> return kvm_update_guest_debug(cpu, 0);
+ *   - accel/kvm/kvm-all.c|3672| <<kvm_insert_breakpoint>> err = kvm_update_guest_debug(cpu, 0);
+ *   - accel/kvm/kvm-all.c|3711| <<kvm_remove_breakpoint>> err = kvm_update_guest_debug(cpu, 0);
+ *   - accel/kvm/kvm-all.c|3740| <<kvm_remove_all_breakpoints>> kvm_update_guest_debug(cpu, 0);
+ */
 int kvm_update_guest_debug(CPUState *cpu, unsigned long reinject_trap)
 {
     struct kvm_set_guest_debug_data data;
@@ -3506,6 +4118,10 @@ bool kvm_supports_guest_debug(void)
     return kvm_has_guest_debug;
 }
 
+/*
+ * 在以下使用kvm_insert_breakpoint():
+ *   - accel/kvm/kvm-accel-ops.c|137| <<kvm_accel_ops_class_init>> ops->insert_breakpoint = kvm_insert_breakpoint;
+ */
 int kvm_insert_breakpoint(CPUState *cpu, int type, vaddr addr, vaddr len)
 {
     struct kvm_sw_breakpoint *bp;
diff --git a/audio/audio.c b/audio/audio.c
index 41ee11aaa..e3cffa67f 100644
--- a/audio/audio.c
+++ b/audio/audio.c
@@ -1784,6 +1784,22 @@ static AudioState *audio_init(Audiodev *dev, Error **errp)
 
     QTAILQ_INSERT_TAIL(&audio_states, s, list);
     QLIST_INIT (&s->card_head);
+    /*
+     * 在以下使用vmstate_register_any():
+     *   - audio/audio.c|1787| <<audio_init>> vmstate_register_any(NULL, &vmstate_audio, s);
+     *   - backends/dbus-vmstate.c|429| <<dbus_vmstate_complete>> if (vmstate_register_any(VMSTATE_IF(self), &dbus_vmstate, self) < 0) {
+     *   - backends/tpm/tpm_emulator.c|1009| <<tpm_emulator_inst_init>> vmstate_register_any(NULL, &vmstate_tpm_emulator, obj);
+     *   - hw/display/vmware_vga.c|1265| <<vmsvga_init>> vmstate_register_any(NULL, &vmstate_vga_common, &s->vga);
+     *   - hw/i2c/core.c|66| <<i2c_init_bus>> vmstate_register_any(NULL, &vmstate_i2c_bus, bus);
+     *   - hw/ide/isa.c|76| <<isa_ide_realizefn>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_ide_isa, s);
+     *   - hw/input/adb.c|250| <<adb_bus_realize>> vmstate_register_any(NULL, &vmstate_adb_bus, adb_bus);
+     *   - hw/net/eepro100.c|1888| <<e100_nic_realize>> vmstate_register_any(VMSTATE_IF(&pci_dev->qdev), s->vmstate, s);
+     *   - hw/nvram/eeprom93xx.c|324| <<eeprom93xx_new>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_eeprom, eeprom);
+     *   - hw/pci/pci.c|178| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+     *   - hw/ppc/spapr_nvdimm.c|879| <<spapr_nvdimm_realize>> vmstate_register_any(NULL, &vmstate_spapr_nvdimm_states, dimm);
+     *   - hw/timer/arm_timer.c|184| <<arm_timer_init>> vmstate_register_any(NULL, &vmstate_arm_timer, s);
+     *   - hw/virtio/virtio-mem.c|1122| <<virtio_mem_device_realize>> vmstate_register_any(VMSTATE_IF(vmem), &vmstate_virtio_mem_device_early, vmem);
+     */
     vmstate_register_any(NULL, &vmstate_audio, s);
     return s;
 
diff --git a/backends/cryptodev-vhost.c b/backends/cryptodev-vhost.c
index 943680a23..ae7c0e82c 100644
--- a/backends/cryptodev-vhost.c
+++ b/backends/cryptodev-vhost.c
@@ -66,6 +66,33 @@ cryptodev_vhost_init(
     /* vhost-user needs vq_index to initiate a specific queue pair */
     crypto->dev.vq_index = crypto->cc->queue_index * crypto->dev.nvqs;
 
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     r = vhost_dev_init(&crypto->dev, options->opaque, options->backend_type, 0,
                        &local_err);
     if (r < 0) {
diff --git a/backends/dbus-vmstate.c b/backends/dbus-vmstate.c
index be6c4d8e0..bb7e409f1 100644
--- a/backends/dbus-vmstate.c
+++ b/backends/dbus-vmstate.c
@@ -426,6 +426,22 @@ dbus_vmstate_complete(UserCreatable *uc, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用vmstate_register_any():
+     *   - audio/audio.c|1787| <<audio_init>> vmstate_register_any(NULL, &vmstate_audio, s);
+     *   - backends/dbus-vmstate.c|429| <<dbus_vmstate_complete>> if (vmstate_register_any(VMSTATE_IF(self), &dbus_vmstate, self) < 0) {
+     *   - backends/tpm/tpm_emulator.c|1009| <<tpm_emulator_inst_init>> vmstate_register_any(NULL, &vmstate_tpm_emulator, obj);
+     *   - hw/display/vmware_vga.c|1265| <<vmsvga_init>> vmstate_register_any(NULL, &vmstate_vga_common, &s->vga);
+     *   - hw/i2c/core.c|66| <<i2c_init_bus>> vmstate_register_any(NULL, &vmstate_i2c_bus, bus);
+     *   - hw/ide/isa.c|76| <<isa_ide_realizefn>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_ide_isa, s);
+     *   - hw/input/adb.c|250| <<adb_bus_realize>> vmstate_register_any(NULL, &vmstate_adb_bus, adb_bus);
+     *   - hw/net/eepro100.c|1888| <<e100_nic_realize>> vmstate_register_any(VMSTATE_IF(&pci_dev->qdev), s->vmstate, s);
+     *   - hw/nvram/eeprom93xx.c|324| <<eeprom93xx_new>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_eeprom, eeprom);
+     *   - hw/pci/pci.c|178| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+     *   - hw/ppc/spapr_nvdimm.c|879| <<spapr_nvdimm_realize>> vmstate_register_any(NULL, &vmstate_spapr_nvdimm_states, dimm);
+     *   - hw/timer/arm_timer.c|184| <<arm_timer_init>> vmstate_register_any(NULL, &vmstate_arm_timer, s);
+     *   - hw/virtio/virtio-mem.c|1122| <<virtio_mem_device_realize>> vmstate_register_any(VMSTATE_IF(vmem), &vmstate_virtio_mem_device_early, vmem);
+     */
     if (vmstate_register_any(VMSTATE_IF(self), &dbus_vmstate, self) < 0) {
         error_setg(errp, "Failed to register vmstate");
     }
diff --git a/backends/tpm/tpm_emulator.c b/backends/tpm/tpm_emulator.c
index 00fe015a9..8b76f5197 100644
--- a/backends/tpm/tpm_emulator.c
+++ b/backends/tpm/tpm_emulator.c
@@ -1006,6 +1006,22 @@ static void tpm_emulator_inst_init(Object *obj)
         qemu_add_vm_change_state_handler(tpm_emulator_vm_state_change,
                                          tpm_emu);
 
+    /*
+     * 在以下使用vmstate_register_any():
+     *   - audio/audio.c|1787| <<audio_init>> vmstate_register_any(NULL, &vmstate_audio, s);
+     *   - backends/dbus-vmstate.c|429| <<dbus_vmstate_complete>> if (vmstate_register_any(VMSTATE_IF(self), &dbus_vmstate, self) < 0) {
+     *   - backends/tpm/tpm_emulator.c|1009| <<tpm_emulator_inst_init>> vmstate_register_any(NULL, &vmstate_tpm_emulator, obj);
+     *   - hw/display/vmware_vga.c|1265| <<vmsvga_init>> vmstate_register_any(NULL, &vmstate_vga_common, &s->vga);
+     *   - hw/i2c/core.c|66| <<i2c_init_bus>> vmstate_register_any(NULL, &vmstate_i2c_bus, bus);
+     *   - hw/ide/isa.c|76| <<isa_ide_realizefn>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_ide_isa, s);
+     *   - hw/input/adb.c|250| <<adb_bus_realize>> vmstate_register_any(NULL, &vmstate_adb_bus, adb_bus);
+     *   - hw/net/eepro100.c|1888| <<e100_nic_realize>> vmstate_register_any(VMSTATE_IF(&pci_dev->qdev), s->vmstate, s);
+     *   - hw/nvram/eeprom93xx.c|324| <<eeprom93xx_new>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_eeprom, eeprom);
+     *   - hw/pci/pci.c|178| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+     *   - hw/ppc/spapr_nvdimm.c|879| <<spapr_nvdimm_realize>> vmstate_register_any(NULL, &vmstate_spapr_nvdimm_states, dimm);
+     *   - hw/timer/arm_timer.c|184| <<arm_timer_init>> vmstate_register_any(NULL, &vmstate_arm_timer, s);
+     *   - hw/virtio/virtio-mem.c|1122| <<virtio_mem_device_realize>> vmstate_register_any(VMSTATE_IF(vmem), &vmstate_virtio_mem_device_early, vmem);
+     */
     vmstate_register_any(NULL, &vmstate_tpm_emulator, obj);
 }
 
diff --git a/backends/vhost-user.c b/backends/vhost-user.c
index d0e4d71a6..662ce7034 100644
--- a/backends/vhost-user.c
+++ b/backends/vhost-user.c
@@ -36,6 +36,33 @@ vhost_user_backend_dev_init(VhostUserBackend *b, VirtIODevice *vdev,
     b->dev.nvqs = nvqs;
     b->dev.vqs = g_new0(struct vhost_virtqueue, nvqs);
 
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     ret = vhost_dev_init(&b->dev, &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0,
                          errp);
     if (ret < 0) {
diff --git a/block.c b/block.c
index 0ece805e4..ccc8341e4 100644
--- a/block.c
+++ b/block.c
@@ -1880,6 +1880,9 @@ static int bdrv_open_common(BlockDriverState *bs, BlockBackend *file,
     assert(options != NULL && bs->options != options);
     bdrv_graph_rdunlock_main_loop();
 
+    /*
+     * 特别特别多的调用
+     */
     opts = qemu_opts_create(&bdrv_runtime_opts, NULL, 0, &error_abort);
     if (!qemu_opts_absorb_qdict(opts, options, errp)) {
         ret = -EINVAL;
diff --git a/block/accounting.c b/block/accounting.c
index 3e4615956..cf5b09a41 100644
--- a/block/accounting.c
+++ b/block/accounting.c
@@ -102,6 +102,50 @@ BlockAcctTimedStats *block_acct_interval_next(BlockAcctStats *stats,
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/xen-block.c|375| <<xen_block_do_aio>> block_acct_start(blk_get_stats(dataplane->blk), &request->acct,
+ *   - hw/block/dataplane/xen-block.c|388| <<xen_block_do_aio>> block_acct_start(blk_get_stats(dataplane->blk), &request->acct,
+ *   - hw/block/virtio-blk.c|342| <<virtio_blk_handle_flush>> block_acct_start(blk_get_stats(s->blk), &req->acct, 0,
+ *   - hw/block/virtio-blk.c|425| <<virtio_blk_handle_discard_write_zeroes>> block_acct_start(blk_get_stats(s->blk), &req->acct, bytes,
+ *   - hw/block/virtio-blk.c|778| <<virtio_blk_handle_zone_append>> block_acct_start(blk_get_stats(s->blk), &req->acct, len,
+ *   - hw/block/virtio-blk.c|858| <<virtio_blk_handle_request>> block_acct_start(blk_get_stats(s->blk), &req->acct, req->qiov.size,
+ *   - hw/ide/atapi.c|95| <<cd_read_sector_sync>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/atapi.c|167| <<cd_read_sector>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/atapi.c|312| <<ide_atapi_cmd_reply>> block_acct_start(blk_get_stats(s->blk), &s->acct, size,
+ *   - hw/ide/atapi.c|434| <<ide_atapi_cmd_read_dma>> block_acct_start(blk_get_stats(s->blk), &s->acct, s->packet_transfer_size,
+ *   - hw/ide/core.c|498| <<ide_issue_trim_cb>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|824| <<ide_sector_read>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|995| <<ide_sector_start_dma>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|999| <<ide_sector_start_dma>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|1098| <<ide_sector_write>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|1134| <<ide_flush_cache>> block_acct_start(blk_get_stats(s->blk), &s->acct, 0, BLOCK_ACCT_FLUSH);
+ *   - hw/ide/macio.c|221| <<pmac_ide_transfer>> block_acct_start(blk_get_stats(s->blk), &s->acct, io->len,
+ *   - hw/ide/macio.c|230| <<pmac_ide_transfer>> block_acct_start(blk_get_stats(s->blk), &s->acct, io->len,
+ *   - hw/ide/macio.c|234| <<pmac_ide_transfer>> block_acct_start(blk_get_stats(s->blk), &s->acct, io->len,
+ *   - hw/nvme/ctrl.c|2716| <<nvme_verify>> block_acct_start(blk_get_stats(blk), &req->acct, ctx->data.iov.size,
+ *   - hw/nvme/ctrl.c|3070| <<nvme_copy_in_completed_cb>> block_acct_start(blk_get_stats(dns->blkconf.blk), &iocb->acct.write, 0,
+ *   - hw/nvme/ctrl.c|3307| <<nvme_do_copy>> block_acct_start(blk_get_stats(sns->blkconf.blk), &iocb->acct.read, 0,
+ *   - hw/nvme/ctrl.c|3469| <<nvme_compare>> block_acct_start(blk_get_stats(blk), &req->acct, data_len,
+ *   - hw/nvme/ctrl.c|3667| <<nvme_read>> block_acct_start(blk_get_stats(blk), &req->acct, data_size,
+ *   - hw/nvme/ctrl.c|3837| <<nvme_do_write>> block_acct_start(blk_get_stats(blk), &req->acct, data_size,
+ *   - hw/nvme/dif.c|647| <<nvme_dif_rw>> block_acct_start(blk_get_stats(blk), &req->acct, ctx->data.iov.size,
+ *   - hw/nvme/dif.c|693| <<nvme_dif_rw>> block_acct_start(blk_get_stats(blk), &req->acct, ctx->data.iov.size,
+ *   - hw/scsi/scsi-disk.c|400| <<scsi_write_do_fua>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - hw/scsi/scsi-disk.c|509| <<scsi_do_read>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|568| <<scsi_read_data>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - hw/scsi/scsi-disk.c|667| <<scsi_write_data>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|1723| <<scsi_disk_emulate_mode_select>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - hw/scsi/scsi-disk.c|1789| <<scsi_unmap_complete_noio>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|1906| <<scsi_write_same_complete>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|1955| <<scsi_disk_emulate_write_same>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|1981| <<scsi_disk_emulate_write_same>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|2250| <<scsi_disk_emulate_command>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - qemu-io-cmds.c|1541| <<aio_read_f>> block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,
+ *   - qemu-io-cmds.c|1696| <<aio_write_f>> block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,
+ *   - qemu-io-cmds.c|1709| <<aio_flush_f>> block_acct_start(blk_get_stats(blk), &cookie, 0, BLOCK_ACCT_FLUSH);
+ *   - system/dma-helpers.c|320| <<dma_acct_start>> block_acct_start(blk_get_stats(blk), cookie, sg->size, type);
+ */
 void block_acct_start(BlockAcctStats *stats, BlockAcctCookie *cookie,
                       int64_t bytes, enum BlockAcctType type)
 {
@@ -241,11 +285,70 @@ static void block_account_one_io(BlockAcctStats *stats, BlockAcctCookie *cookie,
     cookie->type = BLOCK_ACCT_NONE;
 }
 
+/*
+ * 在以下使用block_acct_done():
+ *   - hw/block/dataplane/xen-block.c|304| <<xen_block_complete_aio>> block_acct_done(blk_get_stats(dataplane->blk), &request->acct);
+ *   - hw/block/virtio-blk.c|139| <<virtio_blk_rw_complete>> block_acct_done(blk_get_stats(s->blk), &req->acct);
+ *   - hw/block/virtio-blk.c|154| <<virtio_blk_flush_complete>> block_acct_done(blk_get_stats(s->blk), &req->acct);
+ *   - hw/block/virtio-blk.c|171| <<virtio_blk_discard_write_zeroes_complete>> block_acct_done(blk_get_stats(s->blk), &req->acct);
+ *   - hw/ide/ahci.c|1007| <<ncq_finish>> block_acct_done(blk_get_stats(ncq_tfs->drive->port.ifs[0].blk),
+ *   - hw/ide/atapi.c|120| <<cd_read_sector_sync>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/atapi.c|140| <<cd_read_sector_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/atapi.c|417| <<ide_atapi_cmd_read_dma_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|470| <<ide_issue_trim_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|779| <<ide_sector_read_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|982| <<ide_dma_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|1040| <<ide_sector_write_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|1118| <<ide_flush_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/macio.c|125| <<pmac_ide_atapi_transfer_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/macio.c|205| <<pmac_ide_transfer_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/nvme/ctrl.c|2174| <<nvme_rw_complete_cb>> block_acct_done(stats, acct);
+ *   - hw/nvme/ctrl.c|2264| <<nvme_verify_cb>> block_acct_done(stats, acct);
+ *   - hw/nvme/ctrl.c|2413| <<nvme_compare_mdata_cb>> block_acct_done(stats, acct)
+ *   - hw/nvme/ctrl.c|2482| <<nvme_compare_data_cb>> block_acct_done(stats, acct);
+ *   - hw/nvme/ctrl.c|2785| <<nvme_copy_done>> block_acct_done(stats, &iocb->acct.read);
+ *   - hw/nvme/ctrl.c|2786| <<nvme_copy_done>> block_acct_done(stats, &iocb->acct.write);
+ *   - hw/scsi/scsi-disk.c|359| <<scsi_aio_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|442| <<scsi_dma_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|480| <<scsi_read_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|530| <<scsi_do_read_cb>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|616| <<scsi_write_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|1822| <<scsi_unmap_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|1899| <<scsi_write_same_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - qemu-io-cmds.c|1375| <<aio_write_done>> block_acct_done(blk_get_stats(ctx->blk), &ctx->acct);
+ *   - qemu-io-cmds.c|1418| <<aio_read_done>> block_acct_done(blk_get_stats(ctx->blk), &ctx->acct);
+ *   - qemu-io-cmds.c|1711| <<aio_flush_f>> block_acct_done(blk_get_stats(blk), &cookie);
+ */
 void block_acct_done(BlockAcctStats *stats, BlockAcctCookie *cookie)
 {
     block_account_one_io(stats, cookie, false);
 }
 
+/*
+ * 在以下使用block_acct_failed():
+ *   - hw/block/dataplane/xen-block.c|306| <<xen_block_complete_aio>> block_acct_failed(blk_get_stats(dataplane->blk), &request->acct);
+ *   - hw/block/virtio-blk.c|90| <<virtio_blk_handle_rw_error>> block_acct_failed(blk_get_stats(s->blk), &req->acct);
+ *   - hw/ide/atapi.c|118| <<cd_read_sector_sync>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/atapi.c|135| <<cd_read_sector_cb>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/atapi.c|415| <<ide_atapi_cmd_read_dma_cb>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|472| <<ide_issue_trim_cb>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|866| <<ide_handle_rw_error>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/macio.c|123| <<pmac_ide_atapi_transfer_cb>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/macio.c|203| <<pmac_ide_transfer_cb>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/nvme/ctrl.c|2151| <<nvme_rw_complete_cb>> block_acct_failed(stats, acct);
+ *   - hw/nvme/ctrl.c|2256| <<nvme_verify_cb>> block_acct_failed(stats, acct);
+ *   - hw/nvme/ctrl.c|2358| <<nvme_compare_mdata_cb>> block_acct_failed(stats, acct);
+ *   - hw/nvme/ctrl.c|2443| <<nvme_compare_data_cb>> block_acct_failed(stats, acct);
+ *   - hw/nvme/ctrl.c|2782| <<nvme_copy_done>> block_acct_failed(stats, &iocb->acct.read);
+ *   - hw/nvme/ctrl.c|2783| <<nvme_copy_done>> block_acct_failed(stats, &iocb->acct.write);
+ *   - hw/scsi/scsi-disk.c|304| <<scsi_handle_rw_error>> block_acct_failed(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|440| <<scsi_dma_complete>> block_acct_failed(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|478| <<scsi_read_complete>> block_acct_failed(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|528| <<scsi_do_read_cb>> block_acct_failed(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|614| <<scsi_write_complete>> block_acct_failed(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - qemu-io-cmds.c|1371| <<aio_write_done>> block_acct_failed(blk_get_stats(ctx->blk), &ctx->acct);
+ *   - qemu-io-cmds.c|1403| <<aio_read_done>> block_acct_failed(blk_get_stats(ctx->blk), &ctx->acct);
+ */
 void block_acct_failed(BlockAcctStats *stats, BlockAcctCookie *cookie)
 {
     block_account_one_io(stats, cookie, true);
diff --git a/block/aio_task.c b/block/aio_task.c
index bb5c05f45..24ef6f783 100644
--- a/block/aio_task.c
+++ b/block/aio_task.c
@@ -86,6 +86,11 @@ void coroutine_fn aio_task_pool_wait_all(AioTaskPool *pool)
     }
 }
 
+/*
+ * 在以下使用aio_task_pool_start_task():
+ *   - block/block-copy.c|483| <<block_copy_task_run>> aio_task_pool_start_task(pool, &task->task);
+ *   - block/qcow2.c|2324| <<qcow2_add_task>> aio_task_pool_start_task(pool, &task->task);
+ */
 void coroutine_fn aio_task_pool_start_task(AioTaskPool *pool, AioTask *task)
 {
     aio_task_pool_wait_slot(pool);
diff --git a/block/block-backend.c b/block/block-backend.c
index a402db13f..2141e9630 100644
--- a/block/block-backend.c
+++ b/block/block-backend.c
@@ -1560,6 +1560,18 @@ static const AIOCBInfo blk_aio_em_aiocb_info = {
     .aiocb_size         = sizeof(BlkAioEmAIOCB),
 };
 
+/*
+ * 在以下使用blk_aio_complete():
+ *   - block/block-backend.c|1576| <<blk_aio_complete_bh>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1630| <<blk_aio_read_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1642| <<blk_aio_write_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1804| <<blk_aio_ioctl_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1838| <<blk_aio_pdiscard_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1883| <<blk_aio_flush_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1913| <<blk_aio_zone_report_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1956| <<blk_aio_zone_mgmt_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1996| <<blk_aio_zone_append_entry>> blk_aio_complete(acb);
+ */
 static void blk_aio_complete(BlkAioEmAIOCB *acb)
 {
     if (acb->has_returned) {
@@ -1569,6 +1581,17 @@ static void blk_aio_complete(BlkAioEmAIOCB *acb)
     }
 }
 
+/*
+ * 在以下使用blk_aio_complete_bh():
+ *   - block/block-backend.c|1615| <<blk_aio_prwv>>
+ *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+ *   - block/block-backend.c|1942| <<blk_aio_zone_report>>
+ *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+ *   - block/block-backend.c|1983| <<blk_aio_zone_mgmt>>
+ *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+ *   - block/block-backend.c|2022| <<blk_aio_zone_append>>
+ *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+ */
 static void blk_aio_complete_bh(void *opaque)
 {
     BlkAioEmAIOCB *acb = opaque;
@@ -1576,6 +1599,46 @@ static void blk_aio_complete_bh(void *opaque)
     blk_aio_complete(acb);
 }
 
+/*
+ * 没有iothread应该就是mainloop
+ * (gdb) bt
+ * #0  coroutine_pool_get_local () at ../util/qemu-coroutine.c:116
+ * #1  0x00005555561cb785 in coroutine_pool_get () at ../util/qemu-coroutine.c:181
+ * #2  0x00005555561cb8c7 in qemu_coroutine_create (entry=0x5555560034f4 <blk_aio_write_entry>, opaque=0x5555582fd4d0)
+ *     at ../util/qemu-coroutine.c:222
+ * #3  0x00005555560033cc in blk_aio_prwv (blk=0x55555846f060, offset=540709888, bytes=1024, iobuf=0x5555577f63e8,
+ *     co_entry=0x5555560034f4 <blk_aio_write_entry>, flags=BDRV_REQ_REGISTERED_BUF, 
+ *     cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350) at ../block/block-backend.c:1600
+ * #4  0x0000555556003927 in blk_aio_pwritev (blk=0x55555846f060, offset=540709888, qiov=0x5555577f63e8,
+ *     flags=BDRV_REQ_REGISTERED_BUF, cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350)
+ *     at ../block/block-backend.c:1722
+ * #5  0x0000555555e2c003 in submit_requests (s=0x5555584688c0, mrb=0x7fffffffd640, start=0, num_reqs=1, niov=-1) at ../hw/block/virtio-blk.c:259
+ * #6  0x0000555555e2c12f in virtio_blk_submit_multireq (s=0x5555584688c0, mrb=0x7fffffffd640) at ../hw/block/virtio-blk.c:294
+ * #7  0x0000555555e2e065 in virtio_blk_handle_vq (s=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1008
+ * #8  0x0000555555e2e0f8 in virtio_blk_handle_output (vdev=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1028
+ * #9  0x0000555555e89d02 in virtio_queue_notify_vq (vq=0x5555584b0960) at ../hw/virtio/virtio.c:2484
+ * #10 0x0000555555e8d53c in virtio_queue_host_notifier_read (n=0x5555584b09d4) at ../hw/virtio/virtio.c:3869
+ * #11 0x00005555561a74d8 in aio_dispatch_handler (ctx=0x55555745ee50, node=0x7fffe43dfba0) at ../util/aio-posix.c:376
+ * #12 0x00005555561a76ed in aio_dispatch_handlers (ctx=0x55555745ee50) at ../util/aio-posix.c:427
+ * #13 0x00005555561a7749 in aio_dispatch (ctx=0x55555745ee50) at ../util/aio-posix.c:437
+ * #14 0x00005555561c9148 in aio_ctx_dispatch (source=0x55555745ee50, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #15 0x00007ffff6fd394b in g_main_dispatch (context=0x55555745f260) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x55555745f260) at ../glib/gmain.c:4043
+ * #17 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=657614) at ../util/main-loop.c:310
+ * #19 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #21 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x00005555560d296f in main (argc=25, argv=0x7fffffffdb28) at ../system/main.c:80
+ *
+ * called by:
+ *   - block/block-backend.c|1641| <<blk_aio_pwrite_zeroes>> return blk_aio_prwv(blk, offset, bytes, NULL, blk_aio_write_entry,
+ *   - block/block-backend.c|1712| <<blk_aio_preadv>> return blk_aio_prwv(blk, offset, qiov->size, qiov,
+ *   - block/block-backend.c|1722| <<blk_aio_pwritev>> return blk_aio_prwv(blk, offset, qiov->size, qiov,
+ *   - block/block-backend.c|1781| <<blk_aio_ioctl>> return blk_aio_prwv(blk, req, 0, buf, blk_aio_ioctl_entry, 0, cb, opaque);
+ *   - block/block-backend.c|1816| <<blk_aio_pdiscard>> return blk_aio_prwv(blk, offset, bytes, NULL, blk_aio_pdiscard_entry, 0,
+ *   - block/block-backend.c|1860| <<blk_aio_flush>> return blk_aio_prwv(blk, 0, 0, NULL, blk_aio_flush_entry, 0, cb, opaque);
+ */
 static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset,
                                 int64_t bytes,
                                 void *iobuf, CoroutineEntry co_entry,
@@ -1602,6 +1665,17 @@ static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset,
 
     acb->has_returned = true;
     if (acb->rwco.ret != NOT_DONE) {
+        /*
+	 * 在以下使用blk_aio_complete_bh():
+	 *   - block/block-backend.c|1615| <<blk_aio_prwv>>
+	 *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+	 *   - block/block-backend.c|1942| <<blk_aio_zone_report>>
+	 *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+	 *   - block/block-backend.c|1983| <<blk_aio_zone_mgmt>>
+	 *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+	 *   - block/block-backend.c|2022| <<blk_aio_zone_append>>
+	 *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+	 */
         replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(),
                                          blk_aio_complete_bh, acb);
     }
@@ -1621,6 +1695,13 @@ static void coroutine_fn blk_aio_read_entry(void *opaque)
     blk_aio_complete(acb);
 }
 
+/*
+ * 在以下使用blk_aio_write_entry():
+ *   - block/block-backend.c|1650| <<blk_aio_pwrite_zeroes>> return blk_aio_prwv(blk,
+ *      offset, bytes, NULL, blk_aio_write_entry, flags | BDRV_REQ_ZERO_WRITE, cb, opaque);
+ *   - block/block-backend.c|1753| <<blk_aio_pwritev>> return blk_aio_prwv(blk,
+ *      offset, qiov->size, qiov, blk_aio_write_entry, flags, cb, opaque);
+ */
 static void coroutine_fn blk_aio_write_entry(void *opaque)
 {
     BlkAioEmAIOCB *acb = opaque;
@@ -1638,6 +1719,13 @@ BlockAIOCB *blk_aio_pwrite_zeroes(BlockBackend *blk, int64_t offset,
                                   BlockCompletionFunc *cb, void *opaque)
 {
     IO_CODE();
+    /*
+     * 在以下使用blk_aio_write_entry():
+     *   - block/block-backend.c|1650| <<blk_aio_pwrite_zeroes>> return blk_aio_prwv(blk,
+     *      offset, bytes, NULL, blk_aio_write_entry, flags | BDRV_REQ_ZERO_WRITE, cb, opaque);
+     *   - block/block-backend.c|1753| <<blk_aio_pwritev>> return blk_aio_prwv(blk,
+     *      offset, qiov->size, qiov, blk_aio_write_entry, flags, cb, opaque);
+     */
     return blk_aio_prwv(blk, offset, bytes, NULL, blk_aio_write_entry,
                         flags | BDRV_REQ_ZERO_WRITE, cb, opaque);
 }
@@ -1713,12 +1801,71 @@ BlockAIOCB *blk_aio_preadv(BlockBackend *blk, int64_t offset,
                         blk_aio_read_entry, flags, cb, opaque);
 }
 
+/*
+ * 没有iothread应该就是mainloop
+ * (gdb) bt
+ * #0  coroutine_pool_get_local () at ../util/qemu-coroutine.c:116
+ * #1  0x00005555561cb785 in coroutine_pool_get () at ../util/qemu-coroutine.c:181
+ * #2  0x00005555561cb8c7 in qemu_coroutine_create (entry=0x5555560034f4 <blk_aio_write_entry>, opaque=0x5555582fd4d0)
+ *     at ../util/qemu-coroutine.c:222
+ * #3  0x00005555560033cc in blk_aio_prwv (blk=0x55555846f060, offset=540709888, bytes=1024, iobuf=0x5555577f63e8,
+ *     co_entry=0x5555560034f4 <blk_aio_write_entry>, flags=BDRV_REQ_REGISTERED_BUF, 
+ *     cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350) at ../block/block-backend.c:1600
+ * #4  0x0000555556003927 in blk_aio_pwritev (blk=0x55555846f060, offset=540709888, qiov=0x5555577f63e8,
+ *     flags=BDRV_REQ_REGISTERED_BUF, cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350)
+ *     at ../block/block-backend.c:1722
+ * #5  0x0000555555e2c003 in submit_requests (s=0x5555584688c0, mrb=0x7fffffffd640, start=0, num_reqs=1, niov=-1) at ../hw/block/virtio-blk.c:259
+ * #6  0x0000555555e2c12f in virtio_blk_submit_multireq (s=0x5555584688c0, mrb=0x7fffffffd640) at ../hw/block/virtio-blk.c:294
+ * #7  0x0000555555e2e065 in virtio_blk_handle_vq (s=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1008
+ * #8  0x0000555555e2e0f8 in virtio_blk_handle_output (vdev=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1028
+ * #9  0x0000555555e89d02 in virtio_queue_notify_vq (vq=0x5555584b0960) at ../hw/virtio/virtio.c:2484
+ * #10 0x0000555555e8d53c in virtio_queue_host_notifier_read (n=0x5555584b09d4) at ../hw/virtio/virtio.c:3869
+ * #11 0x00005555561a74d8 in aio_dispatch_handler (ctx=0x55555745ee50, node=0x7fffe43dfba0) at ../util/aio-posix.c:376
+ * #12 0x00005555561a76ed in aio_dispatch_handlers (ctx=0x55555745ee50) at ../util/aio-posix.c:427
+ * #13 0x00005555561a7749 in aio_dispatch (ctx=0x55555745ee50) at ../util/aio-posix.c:437
+ * #14 0x00005555561c9148 in aio_ctx_dispatch (source=0x55555745ee50, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #15 0x00007ffff6fd394b in g_main_dispatch (context=0x55555745f260) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x55555745f260) at ../glib/gmain.c:4043
+ * #17 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=657614) at ../util/main-loop.c:310
+ * #19 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #21 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x00005555560d296f in main (argc=25, argv=0x7fffffffdb28) at ../system/main.c:80
+ *
+ * called by:
+ *   - hw/block/dataplane/xen-block.c|393| <<xen_block_do_aio>> blk_aio_pwritev(dataplane->blk, request->start, &request->v, 0,
+ *   - hw/block/m25p80.c|581| <<flash_sync_page>> blk_aio_pwritev(s->blk, page * s->pi->page_size, iov, 0,
+ *   - hw/block/m25p80.c|597| <<flash_sync_area>> blk_aio_pwritev(s->blk, off, iov, 0, blk_sync_complete, iov);
+ *   - hw/block/virtio-blk.c|259| <<submit_requests>> blk_aio_pwritev(blk, sector_num << BDRV_SECTOR_BITS, qiov,
+ *   - hw/ide/core.c|1100| <<ide_sector_write>> s->pio_aiocb = blk_aio_pwritev(s->blk, sector_num << BDRV_SECTOR_BITS,
+ *   - hw/nvme/ctrl.c|1475| <<nvme_blk_write>> req->aiocb = blk_aio_pwritev(blk, offset, &req->sg.iov, 0, cb, req);
+ *   - hw/nvme/ctrl.c|2964| <<nvme_copy_out_cb>> iocb->aiocb = blk_aio_pwritev(dns->blkconf.blk, nvme_moff(dns, iocb->slba),
+ *   - hw/nvme/ctrl.c|3073| <<nvme_copy_in_completed_cb>> iocb->aiocb = blk_aio_pwritev(dns->blkconf.blk, nvme_l2b(dns, iocb->slba),
+ *   - hw/nvme/dif.c|530| <<nvme_dif_rw_mdata_out_cb>> req->aiocb = blk_aio_pwritev(blk, offset, &ctx->mdata.iov, 0,
+ *   - hw/nvme/dif.c|696| <<nvme_dif_rw>> req->aiocb = blk_aio_pwritev(ns->blkconf.blk, offset, &ctx->data.iov, 0,
+ *   - hw/scsi/scsi-disk.c|1911| <<scsi_write_same_complete>> r->req.aiocb = blk_aio_pwritev(s->qdev.conf.blk,
+ *   - hw/scsi/scsi-disk.c|1983| <<scsi_disk_emulate_write_same>> r->req.aiocb = blk_aio_pwritev(s->qdev.conf.blk,
+ *   - hw/scsi/scsi-disk.c|3140| <<scsi_dma_writev>> return blk_aio_pwritev(s->qdev.conf.blk, offset, iov, 0, cb, cb_opaque);
+ *   - qemu-img.c|4497| <<bench_cb>> acb = blk_aio_pwritev(b->blk, offset, b->qiov, 0, bench_cb, b);
+ *   - qemu-io-cmds.c|663| <<do_aio_writev>> blk_aio_pwritev(blk, offset, qiov, flags, aio_rw_done, &async_ret);
+ *   - qemu-io-cmds.c|1699| <<aio_write_f>> blk_aio_pwritev(blk, ctx->offset, &ctx->qiov, ctx->flags,
+ *   - system/dma-helpers.c|265| <<dma_blk_write_io_func>> return blk_aio_pwritev(blk, offset, iov, 0, cb, cb_opaque);
+ *   - tests/unit/test-replication.c|113| <<test_blk_write>> blk_aio_pwritev(blk, offset, &qiov, 0, blk_rw_done, &async_ret);
+ */
 BlockAIOCB *blk_aio_pwritev(BlockBackend *blk, int64_t offset,
                             QEMUIOVector *qiov, BdrvRequestFlags flags,
                             BlockCompletionFunc *cb, void *opaque)
 {
     IO_CODE();
     assert((uint64_t)qiov->size <= INT64_MAX);
+    /*
+     * 在以下使用blk_aio_write_entry():
+     *   - block/block-backend.c|1650| <<blk_aio_pwrite_zeroes>> return blk_aio_prwv(blk,
+     *      offset, bytes, NULL, blk_aio_write_entry, flags | BDRV_REQ_ZERO_WRITE, cb, opaque);
+     *   - block/block-backend.c|1753| <<blk_aio_pwritev>> return blk_aio_prwv(blk,
+     *      offset, qiov->size, qiov, blk_aio_write_entry, flags, cb, opaque);
+     */
     return blk_aio_prwv(blk, offset, qiov->size, qiov,
                         blk_aio_write_entry, flags, cb, opaque);
 }
@@ -1853,6 +2000,20 @@ static void coroutine_fn blk_aio_flush_entry(void *opaque)
     blk_aio_complete(acb);
 }
 
+/*
+ * 在以下使用blk_aio_flush():
+ *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+ *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+ *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+ *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+ *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+ *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+ *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+ *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+ *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+ *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+ *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+ */
 BlockAIOCB *blk_aio_flush(BlockBackend *blk,
                           BlockCompletionFunc *cb, void *opaque)
 {
@@ -2120,6 +2281,13 @@ BlockdevOnError blk_get_on_error(BlockBackend *blk, bool is_read)
     return is_read ? blk->on_read_error : blk->on_write_error;
 }
 
+/*
+ * 在以下使用blk_get_error_action():
+ *   - hw/block/virtio-blk.c|76| <<virtio_blk_handle_rw_error>> BlockErrorAction action = blk_get_error_action(s->blk, is_read, error);
+ *   - hw/ide/ahci.c|1022| <<ncq_cb>> BlockErrorAction action = blk_get_error_action(ide_state->blk, is_read, -ret);
+ *   - hw/ide/core.c|860| <<ide_handle_rw_error>> BlockErrorAction action = blk_get_error_action(s->blk, is_read, error);
+ *   - hw/scsi/scsi-disk.c|297| <<scsi_handle_rw_error>> action = blk_get_error_action(s->qdev.conf.blk, is_read, error);
+ */
 BlockErrorAction blk_get_error_action(BlockBackend *blk, bool is_read,
                                       int error)
 {
diff --git a/block/iscsi.c b/block/iscsi.c
index 2f0f4dac0..d424e599a 100644
--- a/block/iscsi.c
+++ b/block/iscsi.c
@@ -2107,6 +2107,10 @@ static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)
     }
     if (iscsilun->bl.opt_xfer_len &&
         iscsilun->bl.opt_xfer_len < INT_MAX / block_size) {
+        /*
+	 * IscsiLun *iscsilun:
+	 * -> struct scsi_inquiry_block_limits bl;
+	 */
         bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *
                                         iscsilun->block_size);
     }
diff --git a/chardev/char.c b/chardev/char.c
index 5a9e9762a..2cd39e154 100644
--- a/chardev/char.c
+++ b/chardev/char.c
@@ -108,6 +108,42 @@ static void qemu_chr_write_log(Chardev *s, const uint8_t *buf, size_t len)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_chr_write_buffer (s=0x55555750d400, buf=0x55555759aa0c "[", len=1, offset=0x7fffed23e1c0, write_all=false)
+ *     at ../chardev/char.c:115
+ * #1  0x00005555560c7c5e in qemu_chr_write (s=0x55555750d400, buf=0x55555759aa0c "[", len=1, write_all=false)
+ *     at ../chardev/char.c:186
+ * #2  0x00005555560bc2e5 in qemu_chr_fe_write (be=0x55555759aa28, buf=0x55555759aa0c "[", len=1)
+ *     at ../chardev/char-fe.c:41
+ * #3  0x0000555555965c20 in serial_xmit (s=0x55555759a970) at ../hw/char/serial.c:259
+ * #4  0x00005555559660b5 in serial_ioport_write (opaque=0x55555759a970, addr=0, val=91, size=1)
+ *     at ../hw/char/serial.c:359
+ * #5  0x0000555555eb8e96 in memory_region_write_accessor (mr=0x55555759aae0, addr=0, value=0x7fffed23e3a8, size=1,
+ *     shift=0, mask=255, attrs=...) at ../system/memory.c:497
+ * #6  0x0000555555eb91df in access_with_adjusted_size (addr=0, value=0x7fffed23e3a8, size=1, access_size_min=1,
+ *     access_size_max=1, access_fn=0x555555eb8da0 <memory_region_write_accessor>, mr=0x55555759aae0, attrs=...)
+ *     at ../system/memory.c:573
+ * #7  0x0000555555ebc9a2 in memory_region_dispatch_write (mr=0x55555759aae0, addr=0, data=91, op=MO_8, attrs=...)
+ *     at ../system/memory.c:1553
+ * #8  0x0000555555eccb5a in flatview_write_continue_step (attrs=..., buf=0x7ffff7fee000 "[", len=1, mr_addr=0,
+ *     l=0x7fffed23e490, mr=0x55555759aae0) at ../system/physmem.c:2951
+ * #9  0x0000555555eccc2f in flatview_write_continue (fv=0x7ffbd801c2c0, addr=1016, attrs=..., ptr=0x7ffff7fee000,
+ *     len=1, mr_addr=0, l=1, mr=0x55555759aae0) at ../system/physmem.c:2981
+ * #10 0x0000555555eccd5c in flatview_write (fv=0x7ffbd801c2c0, addr=1016, attrs=..., buf=0x7ffff7fee000, len=1)
+ *     at ../system/physmem.c:3012
+ * #11 0x0000555555ecd1e9 in address_space_write (as=0x555557383fc0 <address_space_io>, addr=1016, attrs=...,
+ *     buf=0x7ffff7fee000, len=1) at ../system/physmem.c:3132
+ * #12 0x0000555555ecd263 in address_space_rw (as=0x555557383fc0 <address_space_io>, addr=1016, attrs=...,
+ *     buf=0x7ffff7fee000, len=1, is_write=true) at ../system/physmem.c:3142
+ * #13 0x0000555555f0b7dd in kvm_handle_io (port=1016, attrs=..., data=0x7ffff7fee000, direction=1, size=1, count=1)
+ *     at ../accel/kvm/kvm-all.c:2800
+ * #14 0x0000555555f0c755 in kvm_cpu_exec (cpu=0x555557784610) at ../accel/kvm/kvm-all.c:3186
+ * #15 0x0000555555f0fecd in kvm_vcpu_thread_fn (arg=0x555557784610) at ../accel/kvm/kvm-accel-ops.c:51
+ * #16 0x00005555561ad4c6 in qemu_thread_start (args=0x55555778dd20) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #18 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 static int qemu_chr_write_buffer(Chardev *s,
                                  const uint8_t *buf, int len,
                                  int *offset, bool write_all)
@@ -195,6 +231,23 @@ int qemu_chr_write(Chardev *s, const uint8_t *buf, int len, bool write_all)
     return offset;
 }
 
+/*
+ * (gdb) bt
+ * #0  serial_can_receive (s=0x55555759a970) at ../hw/char/serial.c:557
+ * #1  0x00005555559669af in serial_can_receive1 (opaque=0x55555759a970) at ../hw/char/serial.c:597
+ * #2  0x00005555560c7d08 in qemu_chr_be_can_write (s=0x55555750d400) at ../chardev/char.c:206
+ * #3  0x00005555560cae4c in fd_chr_read_poll (opaque=0x55555750d400) at ../chardev/char-fd.c:83
+ * #4  0x00005555560bd37f in io_watch_poll_prepare (source=0x555558342690, timeout=0x7fffffffda04)
+ *     at ../chardev/char-io.c:48
+ * #5  0x00007ffff6fd30f7 in g_main_context_prepare (context=0x55555745e6a0, priority=0x5555573a2588 <max_priority>)
+ *     at ../glib/gmain.c:3645
+ * #6  0x00005555561ca7e4 in glib_pollfds_fill (cur_timeout=0x7fffffffdac8) at ../util/main-loop.c:259
+ * #7  0x00005555561ca97a in os_host_main_loop_wait (timeout=271798) at ../util/main-loop.c:300
+ * #8  0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #9  0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #10 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #11 0x00005555560d296f in main (argc=21, argv=0x7fffffffdc88) at ../system/main.c:80
+ */
 int qemu_chr_be_can_write(Chardev *s)
 {
     CharBackend *be = s->be;
diff --git a/cpu-common.c b/cpu-common.c
index ef5757d23..ffd90016f 100644
--- a/cpu-common.c
+++ b/cpu-common.c
@@ -78,6 +78,10 @@ unsigned int cpu_list_generation_id_get(void)
     return cpu_list_generation_id;
 }
 
+/*
+ * 在以下使用cpu_list_add():
+ *   - hw/core/cpu-common.c|196| <<cpu_exec_realizefn>> cpu_list_add(cpu);
+ */
 void cpu_list_add(CPUState *cpu)
 {
     static bool cpu_index_auto_assigned;
@@ -285,6 +289,36 @@ void cpu_exec_start(CPUState *cpu)
     }
 }
 
+/*
+ * 在以下调用cpu_exec_end():
+ *   - accel/kvm/kvm-all.c|3336| <<kvm_cpu_exec>> cpu_exec_end(cpu);
+ *   - accel/tcg/tcg-accel-ops.c|81| <<tcg_cpu_exec>> cpu_exec_end(cpu);
+ *   - bsd-user/aarch64/target_arch_cpu.h|56| <<target_cpu_loop>> cpu_exec_end(cs);
+ *   - bsd-user/arm/target_arch_cpu.h|48| <<target_cpu_loop>> cpu_exec_end(cs);
+ *   - bsd-user/i386/target_arch_cpu.h|115| <<target_cpu_loop>> cpu_exec_end(cs);
+ *   - bsd-user/riscv/target_arch_cpu.h|51| <<target_cpu_loop>> cpu_exec_end(cs);
+ *   - bsd-user/x86_64/target_arch_cpu.h|123| <<target_cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/aarch64/cpu_loop.c|40| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/alpha/cpu_loop.c|37| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/arm/cpu_loop.c|296| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/hexagon/cpu_loop.c|38| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/hppa/cpu_loop.c|121| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/i386/cpu_loop.c|216| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/loongarch64/cpu_loop.c|23| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/m68k/cpu_loop.c|35| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/microblaze/cpu_loop.c|34| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/mips/cpu_loop.c|76| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/openrisc/cpu_loop.c|35| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/ppc/cpu_loop.c|79| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/riscv/cpu_loop.c|38| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/s390x/cpu_loop.c|66| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/sh4/cpu_loop.c|36| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/sparc/cpu_loop.c|222| <<cpu_loop>> cpu_exec_end(cs);
+ *   - linux-user/xtensa/cpu_loop.c|135| <<cpu_loop>> cpu_exec_end(cs);
+ *   - target/i386/nvmm/nvmm-all.c|816| <<nvmm_vcpu_loop>> cpu_exec_end(cpu);
+ *   - target/i386/tcg/system/excp_helper.c|113| <<ptw_setl_slow>> cpu_exec_end(cpu);
+ *   - target/i386/whpx/whpx-all.c|2050| <<whpx_vcpu_run>> cpu_exec_end(cpu);
+ */
 /* Mark cpu as not executing, and release pending exclusive ops.  */
 void cpu_exec_end(CPUState *cpu)
 {
@@ -345,6 +379,19 @@ void free_queued_cpu_work(CPUState *cpu)
     }
 }
 
+/*
+ * QEMU-9.2的callstack
+ * (gdb) bt
+ * #0  kvm_arch_put_registers (cpu=0x555557721960, level=3, errp=0x7fffedb02580) at ../target/i386/kvm/kvm.c:5237
+ * #1  0x0000555555edb672 in do_kvm_cpu_synchronize_post_init (cpu=0x555557721960, arg=...) at ../accel/kvm/kvm-all.c:2905
+ * #2  0x00005555558841ea in process_queued_cpu_work (cpu=0x555557721960) at ../cpu-common.c:375
+ * #3  0x0000555555bd2d4f in qemu_wait_io_event_common (cpu=0x555557721960) at ../system/cpus.c:456
+ * #4  0x0000555555bd2de8 in qemu_wait_io_event (cpu=0x555557721960) at ../system/cpus.c:474
+ * #5  0x0000555555edf7e1 in kvm_vcpu_thread_fn (arg=0x555557721960) at ../accel/kvm/kvm-accel-ops.c:55
+ * #6  0x000055555617e61f in qemu_thread_start (args=0x55555772bbe0) at ../util/qemu-thread-posix.c:541
+ * #7  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #8  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 void process_queued_cpu_work(CPUState *cpu)
 {
     struct qemu_work_item *wi;
diff --git a/dump/dump.c b/dump/dump.c
index 15bbcc0c6..b4e1222a6 100644
--- a/dump/dump.c
+++ b/dump/dump.c
@@ -1808,6 +1808,16 @@ static void dump_init(DumpState *s, int fd, bool has_format,
     /* If we use KVM, we should synchronize the registers before we get dump
      * info or physmap info.
      */
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1741| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1792| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1989| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|515| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2127| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
     nr_cpus = 0;
     CPU_FOREACH(cpu) {
diff --git a/gdbstub/system.c b/gdbstub/system.c
index dd22ff0fb..b516f9960 100644
--- a/gdbstub/system.c
+++ b/gdbstub/system.c
@@ -641,6 +641,10 @@ bool gdb_supports_guest_debug(void)
     return false;
 }
 
+/*
+ * 在以下使用gdb_breakpoint_insert():
+ *   - gdbstub/gdbstub.c|1148| <<handle_insert_bp>> res = gdb_breakpoint_insert(gdbserver_state.c_cpu,
+ */
 int gdb_breakpoint_insert(CPUState *cs, int type, vaddr addr, vaddr len)
 {
     const AccelOpsClass *ops = cpus_get_accel();
diff --git a/hw/acpi/acpi_interface.c b/hw/acpi/acpi_interface.c
index 8637ff18f..93a419b2e 100644
--- a/hw/acpi/acpi_interface.c
+++ b/hw/acpi/acpi_interface.c
@@ -4,6 +4,20 @@
 #include "qemu/module.h"
 #include "qemu/queue.h"
 
+/*
+ * 在以下使用acpi_send_event():
+ *   - hw/acpi/cpu.c|263| <<acpi_cpu_plug_cb>> acpi_send_event(DEVICE(hotplug_dev), ACPI_CPU_HOTPLUG_STATUS);
+  3 hw/acpi/cpu.c|279| <<acpi_cpu_unplug_request_cb>> acpi_send_event(DEVICE(hotplug_dev), ACPI_CPU_HOTPLUG_STATUS);
+  4 hw/acpi/cpu_hotplug.c|90| <<legacy_acpi_cpu_plug_cb>> acpi_send_event(DEVICE(hotplug_dev), ACPI_CPU_HOTPLUG_STATUS);
+  5 hw/acpi/memory_hotplug.c|275| <<acpi_memory_plug_cb>> acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);
+  6 hw/acpi/memory_hotplug.c|291| <<acpi_memory_unplug_request_cb>> acpi_send_event(DEVICE(hotplug_dev), ACPI_MEMORY_HOTPLUG_STATUS);
+  7 hw/acpi/nvdimm.c|891| <<nvdimm_acpi_plug_cb>> acpi_send_event(DEVICE(hotplug_dev), ACPI_NVDIMM_HOTPLUG_STATUS);
+  8 hw/acpi/pcihp.c|324| <<acpi_pcihp_device_plug_cb>> acpi_send_event(DEVICE(hotplug_dev), ACPI_PCI_HOTPLUG_STATUS);
+  9 hw/acpi/pcihp.c|371| <<acpi_pcihp_device_unplug_request_cb>> acpi_send_event(DEVICE(hotplug_dev), ACPI_PCI_HOTPLUG_STATUS);
+ 10 hw/acpi/vmgenid.c|161| <<vmgenid_update_guest>> acpi_send_event(DEVICE(obj), ACPI_VMGENID_CHANGE_STATUS);
+ *   - hw/arm/virt.c|1017| <<virt_powerdown_req>> acpi_send_event(s->acpi_dev, ACPI_POWER_DOWN_STATUS);
+ 12 hw/loongarch/virt.c|167| <<virt_powerdown_req>> acpi_send_event(s->acpi_ged, ACPI_POWER_DOWN_STATUS);
+ */
 void acpi_send_event(DeviceState *dev, AcpiEventStatusBits event)
 {
     AcpiDeviceIfClass *adevc = ACPI_DEVICE_IF_GET_CLASS(dev);
diff --git a/hw/acpi/aml-build.c b/hw/acpi/aml-build.c
index f8f93a9f6..f7371a6d3 100644
--- a/hw/acpi/aml-build.c
+++ b/hw/acpi/aml-build.c
@@ -1731,6 +1731,48 @@ void acpi_table_begin(AcpiTable *desc, GArray *array)
     build_append_int_noprefix(array, 1, 4); /* Creator Revision */
 }
 
+/*
+ * 在以下使用acpi_table_end():
+ *   - hw/acpi/aml-build.c|1888| <<build_rsdt>> acpi_table_end(linker, &table);
+ *   - hw/acpi/aml-build.c|1916| <<build_xsdt>> acpi_table_end(linker, &table);
+ *   - hw/acpi/aml-build.c|2046| <<build_slit>> acpi_table_end(linker, &table);
+ *   - hw/acpi/aml-build.c|2142| <<build_spcr>> acpi_table_end(linker, &table);
+ *   - hw/acpi/aml-build.c|2217| <<build_pptt>> acpi_table_end(linker, &table);
+ *   - hw/acpi/aml-build.c|2354| <<build_fadt>> acpi_table_end(linker, &table);
+ *   - hw/acpi/aml-build.c|2412| <<build_tpm2>> acpi_table_end(linker, &table);
+ *   - hw/acpi/cxl.c|222| <<cxl_build_cedt>> acpi_table_end(linker, &table);
+ *   - hw/acpi/erst.c|372| <<build_erst>> acpi_table_end(linker, &table);
+ *   - hw/acpi/ghes.c|350| <<acpi_build_hest>> acpi_table_end(linker, &table);
+ *   - hw/acpi/hmat.c|278| <<build_hmat>> acpi_table_end(linker, &table);
+ *   - hw/acpi/nvdimm.c|415| <<nvdimm_build_nfit>> acpi_table_end(linker, &table);
+ *   - hw/acpi/nvdimm.c|1427| <<nvdimm_build_ssdt>> acpi_table_end(linker, &table);
+ *   - hw/acpi/pci.c|66| <<build_mcfg>> acpi_table_end(linker, &table);
+ *   - hw/acpi/viot.c|141| <<build_viot>> acpi_table_end(linker, &table);
+ *   - hw/acpi/vmclock.c|60| <<vmclock_build_acpi>> acpi_table_end(linker, &table);
+ *   - hw/acpi/vmgenid.c|119| <<vmgenid_build_acpi>> acpi_table_end(linker, &table);
+ *   - hw/arm/virt-acpi-build.c|430| <<build_iort>> acpi_table_end(linker, &table);
+ *   - hw/arm/virt-acpi-build.c|530| <<build_srat>> acpi_table_end(linker, &table);
+ *   - hw/arm/virt-acpi-build.c|594| <<build_gtdt>> acpi_table_end(linker, &table);
+ *   - hw/arm/virt-acpi-build.c|652| <<build_dbg2>> acpi_table_end(linker, &table);
+ *   - hw/arm/virt-acpi-build.c|773| <<build_madt>> acpi_table_end(linker, &table);
+ *   - hw/arm/virt-acpi-build.c|873| <<build_dsdt>> acpi_table_end(linker, &table);
+ *   - hw/i386/acpi-build.c|1887| <<build_dsdt>> acpi_table_end(linker, &table);
+ *   - hw/i386/acpi-build.c|1916| <<build_hpet>> acpi_table_end(linker, &table);
+ *   - hw/i386/acpi-build.c|1952| <<build_tpm_tcpa>> acpi_table_end(linker, &table);
+ *   - hw/i386/acpi-build.c|2098| <<build_srat>> acpi_table_end(linker, &table);
+ *   - hw/i386/acpi-build.c|2229| <<build_dmar_q35>> acpi_table_end(linker, &table);
+ *   - hw/i386/acpi-build.c|2255| <<build_waet>> acpi_table_end(linker, &table);
+ *   - hw/i386/acpi-build.c|2484| <<build_amd_iommu>> acpi_table_end(linker, &table);
+ *   - hw/i386/acpi-common.c|163| <<acpi_build_madt>> acpi_table_end(linker, &table);
+ *   - hw/i386/acpi-microvm.c|144| <<build_dsdt_microvm>> acpi_table_end(linker, &table);
+ *   - hw/loongarch/virt-acpi-build.c|178| <<build_madt>> acpi_table_end(linker, &table);
+ *   - hw/loongarch/virt-acpi-build.c|258| <<build_srat>> acpi_table_end(linker, &table);
+ *   - hw/loongarch/virt-acpi-build.c|508| <<build_dsdt>> acpi_table_end(linker, &table);
+ *   - hw/riscv/virt-acpi-build.c|396| <<build_rhct>> acpi_table_end(linker, &table);
+ *   - hw/riscv/virt-acpi-build.c|478| <<build_dsdt>> acpi_table_end(linker, &table);
+ *   - hw/riscv/virt-acpi-build.c|602| <<build_madt>> acpi_table_end(linker, &table);
+ *   - hw/riscv/virt-acpi-build.c|651| <<build_srat>> acpi_table_end(linker, &table);
+ */
 void acpi_table_end(BIOSLinker *linker, AcpiTable *desc)
 {
     /*
@@ -1749,6 +1791,12 @@ void acpi_table_end(BIOSLinker *linker, AcpiTable *desc)
      */
     memcpy(len_ptr, &table_len_le, sizeof table_len_le);
 
+    /*
+     * 在以下使用bios_linker_loader_add_checksum():
+     *   - hw/acpi/aml-build.c|1752| <<acpi_table_end>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
+     *   - hw/acpi/aml-build.c|1835| <<build_rsdp>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
+     *   - hw/acpi/aml-build.c|1858| <<build_rsdp>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
+     */
     bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
         desc->table_offset, table_len, desc->table_offset + checksum_offset);
 }
@@ -1772,8 +1820,31 @@ void acpi_add_table(GArray *table_offsets, GArray *table_data)
     g_array_append_val(table_offsets, offset);
 }
 
+/*
+ * 在以下使用acpi_build_tables_init():
+ *   - hw/arm/virt-acpi-build.c|1077| <<virt_acpi_build_update>> acpi_build_tables_init(&tables);
+ *   - hw/arm/virt-acpi-build.c|1133| <<virt_acpi_setup>> acpi_build_tables_init(&tables);
+ *   - hw/i386/acpi-build.c|2779| <<acpi_build_update>> acpi_build_tables_init(&tables);
+ *   - hw/i386/acpi-build.c|2862| <<acpi_setup>> acpi_build_tables_init(&tables);
+ *   - hw/i386/acpi-microvm.c|256| <<acpi_setup_microvm>> acpi_build_tables_init(&tables);
+ *   - hw/loongarch/virt-acpi-build.c|661| <<acpi_build_update>> acpi_build_tables_init(&tables);
+ *   - hw/loongarch/virt-acpi-build.c|713| <<virt_acpi_setup>> acpi_build_tables_init(&tables);
+ *   - hw/riscv/virt-acpi-build.c|764| <<virt_acpi_build_update>> acpi_build_tables_init(&tables);
+ *   - hw/riscv/virt-acpi-build.c|798| <<virt_acpi_setup>> acpi_build_tables_init(&tables);
+ */
 void acpi_build_tables_init(AcpiBuildTables *tables)
 {
+    /*
+     * 232 typedef
+     * 233 struct AcpiBuildTables {
+     * 234     GArray *table_data;
+     * 235     GArray *rsdp;
+     * 236     GArray *tcpalog;
+     * 237     GArray *vmgenid;
+     * 238     GArray *hardware_errors;
+     * 239     BIOSLinker *linker;
+     * 240 } AcpiBuildTables;
+     */
     tables->rsdp = g_array_new(false, true /* clear */, 1);
     tables->table_data = g_array_new(false, true /* clear */, 1);
     tables->tcpalog = g_array_new(false, true /* clear */, 1);
@@ -1831,6 +1902,12 @@ build_rsdp(GArray *tbl, BIOSLinker *linker, AcpiRsdpData *rsdp_data)
                                        *rsdp_data->rsdt_tbl_offset);
     }
 
+    /*
+     * 在以下使用bios_linker_loader_add_checksum():
+     *   - hw/acpi/aml-build.c|1752| <<acpi_table_end>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
+     *   - hw/acpi/aml-build.c|1835| <<build_rsdp>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
+     *   - hw/acpi/aml-build.c|1858| <<build_rsdp>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
+     */
     /* Checksum to be filled by guest linker */
     bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
                                     tbl_off, 20, /* ACPI rev 1.0 RSDP size */
@@ -1854,6 +1931,12 @@ build_rsdp(GArray *tbl, BIOSLinker *linker, AcpiRsdpData *rsdp_data)
     build_append_int_noprefix(tbl, 0, 1); /* Extended Checksum */
     build_append_int_noprefix(tbl, 0, 3); /* Reserved */
 
+    /*
+     * 在以下使用bios_linker_loader_add_checksum():
+     *   - hw/acpi/aml-build.c|1752| <<acpi_table_end>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
+     *   - hw/acpi/aml-build.c|1835| <<build_rsdp>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
+     *   - hw/acpi/aml-build.c|1858| <<build_rsdp>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
+     */
     /* Extended checksum to be filled by Guest linker */
     bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
                                     tbl_off, 36, /* ACPI rev 2.0 RSDP size */
diff --git a/hw/acpi/bios-linker-loader.c b/hw/acpi/bios-linker-loader.c
index 108061828..cde5f90bf 100644
--- a/hw/acpi/bios-linker-loader.c
+++ b/hw/acpi/bios-linker-loader.c
@@ -126,6 +126,10 @@ typedef struct BiosLinkerFileEntry {
  * After initialization, linker commands can be added, and will
  * be stored in the linker.cmd_blob array.
  */
+/*
+ * 在以下使用bios_linker_loader_init():
+ *   - hw/acpi/aml-build.c|1782| <<acpi_build_tables_init>> tables->linker = bios_linker_loader_init();
+ */
 BIOSLinker *bios_linker_loader_init(void)
 {
     BIOSLinker *linker = g_new(BIOSLinker, 1);
@@ -228,6 +232,12 @@ void bios_linker_loader_alloc(BIOSLinker *linker,
  * @checksum_offset: location of the checksum to be patched within file blob,
  *                   relative to the start of file blob
  */
+/*
+ * 在以下使用bios_linker_loader_add_checksum():
+ *   - hw/acpi/aml-build.c|1752| <<acpi_table_end>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,
+ *   - hw/acpi/aml-build.c|1835| <<build_rsdp>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
+ *   - hw/acpi/aml-build.c|1858| <<build_rsdp>> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
+ */
 void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,
                                      unsigned start_offset, unsigned size,
                                      unsigned checksum_offset)
diff --git a/hw/acpi/core.c b/hw/acpi/core.c
index 58f8964e1..a5b6e49ff 100644
--- a/hw/acpi/core.c
+++ b/hw/acpi/core.c
@@ -496,6 +496,9 @@ void acpi_pm_tmr_update(ACPIREGS *ar, bool enable)
 
 static inline int64_t acpi_pm_tmr_get_clock(void)
 {
+    /*
+     * 注释: Reading QEMU_CLOCK_VIRTUAL is thread-safe
+     */
     return muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), PM_TIMER_FREQUENCY,
                     NANOSECONDS_PER_SECOND);
 }
@@ -540,11 +543,22 @@ static const MemoryRegionOps acpi_pm_tmr_ops = {
     .endianness = DEVICE_LITTLE_ENDIAN,
 };
 
+/*
+ * 在以下使用acpi_pm_tmr_init():
+ *   - hw/acpi/ich9.c|337| <<ich9_pm_init>> acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);
+ *   - hw/acpi/piix4.c|488| <<piix4_pm_realize>> acpi_pm_tmr_init(&s->ar, pm_tmr_timer, &s->io);
+ *   - hw/isa/vt82c686.c|214| <<via_pm_realize>> acpi_pm_tmr_init(&s->ar, pm_tmr_timer, &s->io);
+ */
 void acpi_pm_tmr_init(ACPIREGS *ar, acpi_update_sci_fn update_sci,
                       MemoryRegion *parent)
 {
     ar->tmr.update_sci = update_sci;
     ar->tmr.timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, acpi_pm_tmr_timer, ar);
+    /*
+     * ACPIREGS *ar:
+     * -> ACPIPMTimer tmr;
+     *    -> MemoryRegion io;
+     */
     memory_region_init_io(&ar->tmr.io, memory_region_owner(parent),
                           &acpi_pm_tmr_ops, ar, "acpi-tmr", 4);
     memory_region_add_subregion(parent, 8, &ar->tmr.io);
diff --git a/hw/acpi/generic_event_device.c b/hw/acpi/generic_event_device.c
index c85d97ca3..fb5554b3d 100644
--- a/hw/acpi/generic_event_device.c
+++ b/hw/acpi/generic_event_device.c
@@ -285,6 +285,10 @@ static void acpi_ged_ospm_status(AcpiDeviceIf *adev, ACPIOSTInfoList ***list)
     acpi_cpu_ospm_status(&s->cpuhp_state, list);
 }
 
+/*
+ * 在以下使用acpi_ged_send_event():
+ *   - hw/acpi/generic_event_device.c|488| <<acpi_ged_class_init>> adevc->send_event = acpi_ged_send_event;
+ */
 static void acpi_ged_send_event(AcpiDeviceIf *adev, AcpiEventStatusBits ev)
 {
     AcpiGedState *s = ACPI_GED(adev);
diff --git a/hw/acpi/ich9.c b/hw/acpi/ich9.c
index c7a735bf6..e16d001db 100644
--- a/hw/acpi/ich9.c
+++ b/hw/acpi/ich9.c
@@ -266,6 +266,10 @@ const VMStateDescription vmstate_ich9_pm = {
     }
 };
 
+/*
+ * 在以下使用pm_reset():
+ *   - hw/acpi/ich9.c|351| <<ich9_pm_init>> qemu_register_reset(pm_reset, pm);
+ */
 static void pm_reset(void *opaque)
 {
     ICH9LPCPMRegs *pm = opaque;
@@ -284,6 +288,26 @@ static void pm_reset(void *opaque)
     pm->smi_en_wmask = ~0;
 
     if (pm->acpi_pci_hotplug.use_acpi_hotplug_bridge) {
+        /*
+         * 在以下使用ICH9LPCPMRegs->acpi_pci_hotplug:
+         *   - hw/acpi/ich9.c|236| <<global>> VMSTATE_PCI_HOTPLUG(acpi_pci_hotplug,
+         *   - hw/acpi/ich9.c|227| <<vmstate_test_use_pcihp>> return s->acpi_pci_hotplug.use_acpi_hotplug_bridge;
+         *   - hw/acpi/ich9.c|286| <<pm_reset>> if (pm->acpi_pci_hotplug.use_acpi_hotplug_bridge) {
+         *   - hw/acpi/ich9.c|287| <<pm_reset>> acpi_pcihp_reset(&pm->acpi_pci_hotplug);
+         *   - hw/acpi/ich9.c|335| <<ich9_pm_init>> if (pm->acpi_pci_hotplug.use_acpi_hotplug_bridge) {
+         *   - hw/acpi/ich9.c|227| <<vmstate_test_use_pcihp>> return s->acpi_pci_hotplug.use_acpi_hotplug_bridge;
+         *   - hw/acpi/ich9.c|286| <<pm_reset>> if (pm->acpi_pci_hotplug.use_acpi_hotplug_bridge) {
+         *   - hw/acpi/ich9.c|287| <<pm_reset>> acpi_pcihp_reset(&pm->acpi_pci_hotplug);
+         *   - hw/acpi/ich9.c|335| <<ich9_pm_init>> if (pm->acpi_pci_hotplug.use_acpi_hotplug_bridge) {
+         *   - hw/acpi/ich9.c|337| <<ich9_pm_init>> &pm->acpi_pci_hotplug,
+         *   - hw/acpi/ich9.c|404| <<ich9_pm_get_acpi_pci_hotplug>> return s->pm.acpi_pci_hotplug.use_acpi_hotplug_bridge;
+         *   - hw/acpi/ich9.c|411| <<ich9_pm_set_acpi_pci_hotplug>> s->pm.acpi_pci_hotplug.use_acpi_hotplug_bridge = value;
+         *   - hw/acpi/ich9.c|436| <<ich9_pm_add_properties>> pm->acpi_pci_hotplug.use_acpi_hotplug_bridge = true;
+         *   - hw/acpi/ich9.c|508| <<ich9_pm_device_plug_cb>> acpi_pcihp_device_plug_cb(hotplug_dev, &lpc->pm.acpi_pci_hotplug,
+         *   - hw/acpi/ich9.c|543| <<ich9_pm_device_unplug_request_cb>> &lpc->pm.acpi_pci_hotplug,
+         *   - hw/acpi/ich9.c|562| <<ich9_pm_device_unplug_cb>> acpi_pcihp_device_unplug_cb(hotplug_dev, &lpc->pm.acpi_pci_hotplug,
+         *   - hw/acpi/ich9.c|573| <<ich9_pm_is_hotpluggable_bus>> return acpi_pcihp_is_hotpluggbale_bus(&lpc->pm.acpi_pci_hotplug, bus);
+         */
         acpi_pcihp_reset(&pm->acpi_pci_hotplug);
     }
 
@@ -297,6 +321,10 @@ static void pm_powerdown_req(Notifier *n, void *opaque)
     acpi_pm1_evt_power_down(&pm->acpi_regs);
 }
 
+/*
+ * 在以下使用ich9_pm_init():
+ *   - hw/isa/lpc_ich9.c|429| <<ich9_lpc_pm_init>> ich9_pm_init(PCI_DEVICE(lpc), &lpc->pm, sci_irq);
+ */
 void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm, qemu_irq sci_irq)
 {
     pm->smi_sts_wmask = 0;
@@ -486,6 +514,74 @@ void ich9_pm_device_pre_plug_cb(HotplugHandler *hotplug_dev, DeviceState *dev,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  acpi_pcihp_device_plug_cb (hotplug_dev=0x5555578f8610, s=0x5555578fa000, dev=0x555557ca4700, errp=0x7fffffffb430)
+ *     at ../hw/acpi/pcihp.c:287
+ * #1  0x0000555555cfd8b0 in device_set_realized (obj=<optimized out>, value=<optimized out>, errp=0x7fffffffb4b0)
+ *     at ../hw/core/qdev.c:551
+ * #2  0x0000555555d006eb in property_set_bool (obj=0x555557ca4700, v=<optimized out>, name=<optimized out>, opaque=0x5555570093d0,
+ *     errp=0x7fffffffb4b0) at ../qom/object.c:2374
+ * #3  0x0000555555d03878 in object_property_set (obj=obj@entry=0x555557ca4700, name=name@entry=0x55555600da85 "realized", v=v@entry=0x555557ca6930,
+ *     errp=0x7fffffffb4b0, errp@entry=0x555556f6f438 <error_fatal>) at ../qom/object.c:1449
+ * #4  0x0000555555d075b0 in object_property_set_qobject (obj=obj@entry=0x555557ca4700, name=name@entry=0x55555600da85 "realized",
+ *     value=value@entry=0x555557ca66d0, errp=errp@entry=0x555556f6f438 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #5  0x0000555555d03f25 in object_property_set_bool (obj=obj@entry=0x555557ca4700, name=name@entry=0x55555600da85 "realized", value=value@entry=true,
+ *     errp=0x555556f6f438 <error_fatal>) at ../qom/object.c:1519
+ * #6  0x0000555555cfcc9e in qdev_realize (dev=dev@entry=0x555557ca4700, bus=bus@entry=0x5555574e22d0, errp=<optimized out>) at ../hw/core/qdev.c:276
+ * #7  0x0000555555cfcd3f in qdev_realize_and_unref (dev=dev@entry=0x555557ca4700, bus=bus@entry=0x5555574e22d0, errp=<optimized out>) at ../hw/core/qdev.c:283
+ * #8  0x0000555555a1c013 in pci_realize_and_unref (errp=<optimized out>, bus=0x5555574e22d0, dev=0x555557ca4700) at ../hw/pci/pci.c:2356
+ * #9  pci_create_simple_multifunction (bus=0x5555574e22d0, devfn=devfn@entry=250, name=name@entry=0x555555f693ab "ich9-ahci") at ../hw/pci/pci.c:2363
+ * #10 0x0000555555bd4f53 in pc_q35_init (machine=0x555557280110) at ../hw/i386/pc_q35.c:289
+ * #11 0x000055555593bb15 in machine_run_board_init (machine=<optimized out>, mem_path=<optimized out>, errp=<optimized out>,
+ *     errp@entry=0x555556f6f438 <error_fatal>) at ../hw/core/machine.c:1682
+ * #12 0x0000555555b06eb8 in qemu_init_board () at ../system/vl.c:2711
+ * #13 qmp_x_exit_preconfig (errp=0x555556f6f438 <error_fatal>) at ../system/vl.c:2807
+ * #14 0x0000555555b0a897 in qemu_init (argc=<optimized out>, argv=<optimized out>) at ../system/vl.c:3843
+ * #15 0x000055555587f449 in main (argc=<optimized out>, argv=<optimized out>) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  acpi_pcihp_device_plug_cb (hotplug_dev=0x5555578f8610, s=0x5555578fa000, dev=0x555557a839d0, errp=0x7fffffffa410) at ../hw/acpi/pcihp.c:287
+ * #1  0x0000555555cfd8b0 in device_set_realized (obj=<optimized out>, value=<optimized out>, errp=0x7fffffffa6b0) at ../hw/core/qdev.c:551
+ * #2  0x0000555555d006eb in property_set_bool (obj=0x555557a839d0, v=<optimized out>, name=<optimized out>, opaque=0x5555570093d0,
+ *     errp=0x7fffffffa6b0) at ../qom/object.c:2374
+ * #3  0x0000555555d03878 in object_property_set (obj=obj@entry=0x555557a839d0, name=name@entry=0x55555600da85 "realized", v=v@entry=0x55555a6f0f00,
+ *     errp=errp@entry=0x7fffffffa6b0) at ../qom/object.c:1449
+ * #4  0x0000555555d075b0 in object_property_set_qobject (obj=obj@entry=0x555557a839d0, name=name@entry=0x55555600da85 "realized",
+ *     value=value@entry=0x5555590e01a0, errp=errp@entry=0x7fffffffa6b0) at ../qom/qom-qobject.c:28
+ * #5  0x0000555555d03f25 in object_property_set_bool (obj=obj@entry=0x555557a839d0, name=name@entry=0x55555600da85 "realized", value=value@entry=true,
+ *     errp=errp@entry=0x7fffffffa6b0) at ../qom/object.c:1519
+ * #6  0x0000555555cfcc9e in qdev_realize (dev=dev@entry=0x555557a839d0, bus=bus@entry=0x555557d9dd40, errp=errp@entry=0x7fffffffa6b0) at
+ *     ../hw/core/qdev.c:276
+ * #7  0x0000555555afe270 in qdev_device_add_from_qdict (opts=opts@entry=0x555557bcde20, from_json=from_json@entry=false, errp=errp@entry=0x7fffffffa6b0)
+ *     at ../system/qdev-monitor.c:714
+ * #8  0x0000555555afe382 in qdev_device_add (opts=opts@entry=0x55555a838f50, errp=errp@entry=0x7fffffffa6b0) at ../system/qdev-monitor.c:733
+ * #9  0x0000555555afe863 in hmp_device_add (mon=0x55555729cb40, qdict=<optimized out>) at ../system/qdev-monitor.c:994
+ * #10 0x0000555555b4a789 in handle_hmp_command_exec (cmd=<optimized out>, cmd=<optimized out>, qdict=0x555557accd70, mon=0x55555729cb40)
+ *     at ../monitor/hmp.c:1106
+ * #11 handle_hmp_command_exec (qdict=0x555557accd70, cmd=0x555556e7f2c0 <hmp_cmds+1920>, mon=0x55555729cb40) at ../monitor/hmp.c:1098
+ * #12 handle_hmp_command (mon=mon@entry=0x55555729cb40, cmdline=<optimized out>, cmdline@entry=0x5555572b5c90
+ *     "device_add vhost-scsi-pci,wwpn=naa.1123451234512346,num_queues=1,bus=pcie-root-port.1,bootindex=-1,migratable=true,id=vhost02")
+ *     at ../monitor/hmp.c:1158
+ * #13 0x0000555555b4a8cd in monitor_command_cb (opaque=0x55555729cb40, cmdline=0x5555572b5c90
+ *     "device_add vhost-scsi-pci,wwpn=naa.1123451234512346,num_queues=1,bus=pcie-root-port.1,bootindex=-1,migratable=true,id=vhost02", readline_opaque=<optimized out>)
+ *     at ../monitor/hmp.c:47
+ * #14 0x0000555555ee6eb4 in readline_handle_byte (rs=0x5555572b5c90, ch=<optimized out>) at ../util/readline.c:427
+ * #15 0x0000555555b4a91b in monitor_read (opaque=0x55555729cb40, buf=<optimized out>, size=<optimized out>) at ../monitor/hmp.c:1390
+ * #16 0x0000555555e19a3d in fd_chr_read (chan=0x55555725ef30, cond=<optimized out>, opaque=<optimized out>) at ../chardev/char-fd.c:72
+ * #17 0x00007ffff73c4854 in g_main_dispatch (context=0x555557007150) at ../glib/gmain.c:3325
+ * #18 g_main_context_dispatch (context=0x555557007150) at ../glib/gmain.c:4043
+ * #19 0x0000555555edaea8 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #20 os_host_main_loop_wait (timeout=989890) at ../util/main-loop.c:310
+ * #21 main_loop_wait (nonblocking=nonblocking@entry=0) at ../util/main-loop.c:589
+ * #22 0x0000555555b02e09 in qemu_main_loop () at ../system/runstate.c:835
+ * #23 0x0000555555e1ec2c in qemu_default_main (opaque=opaque@entry=0x0) at ../system/main.c:50
+ * #24 0x000055555587f4a5 in main (argc=<optimized out>, argv=<optimized out>) at ../system/main.c:80
+ *
+ *
+ * 在以下使用ich9_pm_device_plug_cb():
+ *   - hw/isa/lpc_ich9.c|903| <<ich9_lpc_class_init>> hc->plug = ich9_pm_device_plug_cb;
+ */
 void ich9_pm_device_plug_cb(HotplugHandler *hotplug_dev, DeviceState *dev,
                             Error **errp)
 {
@@ -505,6 +601,11 @@ void ich9_pm_device_plug_cb(HotplugHandler *hotplug_dev, DeviceState *dev,
             acpi_cpu_plug_cb(hotplug_dev, &lpc->pm.cpuhp_state, dev, errp);
         }
     } else if (object_dynamic_cast(OBJECT(dev), TYPE_PCI_DEVICE)) {
+        /*
+         * 在以下调用acpi_pcihp_device_plug_cb():
+	 *   - hw/acpi/ich9.c|508| <<ich9_pm_device_plug_cb>> acpi_pcihp_device_plug_cb(hotplug_dev, &lpc->pm.acpi_pci_hotplug, dev, errp);
+         *   - hw/acpi/piix4.c|352| <<piix4_device_plug_cb>> acpi_pcihp_device_plug_cb(hotplug_dev, &s->acpi_pci_hotplug, dev, errp);
+	 */
         acpi_pcihp_device_plug_cb(hotplug_dev, &lpc->pm.acpi_pci_hotplug,
                                   dev, errp);
     } else {
diff --git a/hw/acpi/pcihp.c b/hw/acpi/pcihp.c
index 5f79c9016..b8b6cf065 100644
--- a/hw/acpi/pcihp.c
+++ b/hw/acpi/pcihp.c
@@ -54,6 +54,14 @@ typedef struct AcpiPciHpFind {
     PCIBus *bus;
 } AcpiPciHpFind;
 
+/*
+ * 在以下使用acpi_pcihp_get_bsel():
+ *   - hw/acpi/pcihp.c|160| <<acpi_pcihp_test_hotplug_bus>> if (find->bsel == acpi_pcihp_get_bsel(bus)) {
+ *   - hw/acpi/pcihp.c|358| <<acpi_pcihp_device_pre_plug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)) < 0) {
+ *   - hw/acpi/pcihp.c|471| <<acpi_pcihp_device_plug_cb>> bsel = acpi_pcihp_get_bsel(bus);
+ *   - hw/acpi/pcihp.c|500| <<acpi_pcihp_device_unplug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)));
+ *   - hw/acpi/pcihp.c|511| <<acpi_pcihp_device_unplug_request_cb>> int bsel = acpi_pcihp_get_bsel(pci_get_bus(pdev));
+ */
 static int acpi_pcihp_get_bsel(PCIBus *bus)
 {
     Error *local_err = NULL;
@@ -75,6 +83,35 @@ typedef struct {
     bool has_bridge_hotplug;
 } BSELInfo;
 
+/*
+ * (gdb) bt
+ * #0  acpi_set_bsel (bus=0x5555579986a0, opaque=0x7fffffffd160) at ../hw/acpi/pcihp.c:81
+ * #1  0x0000555555ad0ae8 in pci_for_each_bus_depth_first (bus=0x5555579986a0, begin=0x55555592cb9c <acpi_set_bsel>,
+ *     end=0x0, parent_state=0x7fffffffd160) at ../hw/pci/pci.c:2174
+ * #2  0x000055555592cd09 in acpi_set_pci_info (has_bridge_hotplug=true) at ../hw/acpi/pcihp.c:120
+ * #3  0x000055555592d294 in acpi_pcihp_reset (s=0x555557db21f0) at ../hw/acpi/pcihp.c:267
+ * #4  0x000055555592e781 in pm_reset (opaque=0x555557db1850) at ../hw/acpi/ich9.c:287
+ * #5  0x0000555555984b3d in legacy_reset_hold (obj=0x555557f66c10, type=RESET_TYPE_COLD) at ../hw/core/reset.c:76
+ * #6  0x0000555555f20bad in resettable_phase_hold (obj=0x555557f66c10, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #7  0x0000555555f1f185 in resettable_container_child_foreach (obj=0x5555576fc140, cb=0x555555f20a95 <resettable_phase_hold>, opaque=0x0,
+ *     type=RESET_TYPE_COLD) at ../hw/core/resetcontainer.c:54
+ * #8  0x0000555555f208fc in resettable_child_foreach (rc=0x5555576b2b10, obj=0x5555576fc140, cb=0x555555f20a95 <resettable_phase_hold>,
+ *     opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:92
+ * #9  0x0000555555f20b52 in resettable_phase_hold (obj=0x5555576fc140, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:155
+ * #10 0x0000555555f207b1 in resettable_assert_reset (obj=0x5555576fc140, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #11 0x0000555555f20709 in resettable_reset (obj=0x5555576fc140, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #12 0x0000555555984e8a in qemu_devices_reset (type=RESET_TYPE_COLD) at ../hw/core/reset.c:176
+ * #13 0x0000555555d7ec44 in pc_machine_reset (machine=0x5555576d8380, type=RESET_TYPE_COLD) at ../hw/i386/pc.c:1727
+ * #14 0x0000555555c2d38f in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at ../system/runstate.c:525
+ * #15 0x000055555597da2f in qdev_machine_creation_done () at ../hw/core/machine.c:1763
+ * #16 0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #17 0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #18 0x0000555555c38346 in qemu_init (argc=39, argv=0x7fffffffd6e8) at ../system/vl.c:3843
+ * #19 0x00005555560d2905 in main (argc=39, argv=0x7fffffffd6e8) at ../system/main.c:71
+ *
+ * 在以下使用acpi_set_bsel():
+ *   - hw/acpi/pcihp.c|120| <<acpi_set_pci_info>> pci_for_each_bus_depth_first(bus, acpi_set_bsel, NULL, &info);
+ */
 /* Assign BSEL property only to buses that support hotplug. */
 static void *acpi_set_bsel(PCIBus *bus, void *opaque)
 {
@@ -97,6 +134,10 @@ static void *acpi_set_bsel(PCIBus *bus, void *opaque)
     return info;
 }
 
+/*
+ * 在以下使用acpi_set_pci_info():
+ *   - hw/acpi/pcihp.c|314| <<acpi_pcihp_reset>> acpi_set_pci_info(s->use_acpi_hotplug_bridge);
+ */
 static void acpi_set_pci_info(bool has_bridge_hotplug)
 {
     static bool bsel_is_set;
@@ -105,6 +146,9 @@ static void acpi_set_pci_info(bool has_bridge_hotplug)
     BSELInfo info = { .bsel_alloc = ACPI_PCIHP_BSEL_DEFAULT,
                       .has_bridge_hotplug = has_bridge_hotplug };
 
+    /*
+     * 这里保证只设置一次
+     */
     if (bsel_is_set) {
         return;
     }
@@ -114,6 +158,10 @@ static void acpi_set_pci_info(bool has_bridge_hotplug)
         return;
     }
 
+    /*
+     * PCIHostState:
+     * -> PCIBus *bus;
+     */
     bus = PCI_HOST_BRIDGE(host)->bus;
     if (bus) {
         /* Scan all PCI buses. Set property to enable acpi based hotplug. */
@@ -124,6 +172,14 @@ static void acpi_set_pci_info(bool has_bridge_hotplug)
 static void acpi_pcihp_test_hotplug_bus(PCIBus *bus, void *opaque)
 {
     AcpiPciHpFind *find = opaque;
+    /*
+     * 在以下使用acpi_pcihp_get_bsel():
+     *   - hw/acpi/pcihp.c|160| <<acpi_pcihp_test_hotplug_bus>> if (find->bsel == acpi_pcihp_get_bsel(bus)) {
+     *   - hw/acpi/pcihp.c|358| <<acpi_pcihp_device_pre_plug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)) < 0) {
+     *   - hw/acpi/pcihp.c|471| <<acpi_pcihp_device_plug_cb>> bsel = acpi_pcihp_get_bsel(bus);
+     *   - hw/acpi/pcihp.c|500| <<acpi_pcihp_device_unplug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)));
+     *   - hw/acpi/pcihp.c|511| <<acpi_pcihp_device_unplug_request_cb>> int bsel = acpi_pcihp_get_bsel(pci_get_bus(pdev));
+     */
     if (find->bsel == acpi_pcihp_get_bsel(bus)) {
         find->bus = bus;
     }
@@ -192,6 +248,23 @@ static void acpi_pcihp_eject_slot(AcpiPciHpState *s, unsigned bsel, unsigned slo
         return;
     }
 
+    /*
+     * 在以下使用AcpiPciHpState->acpi_pcihp_pci_status[ACPI_PCIHP_MAX_HOTPLUG_BUS]:
+     *   - hw/acpi/piix4.c|262| <<global>> acpi_pci_hotplug.acpi_pcihp_pci_status[ACPI_PCIHP_BSEL_DEFAULT],
+     *   - hw/acpi/pcihp.c|196| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|197| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|236| <<acpi_pcihp_update_hotplug_bus>> while (s->acpi_pcihp_pci_status[bsel].down) {
+     *   - hw/acpi/pcihp.c|237| <<acpi_pcihp_update_hotplug_bus>> acpi_pcihp_eject_slot(s, bsel, s->acpi_pcihp_pci_status[bsel].down);
+     *   - hw/acpi/pcihp.c|240| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable = ~0;
+     *   - hw/acpi/pcihp.c|251| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|323| <<acpi_pcihp_device_plug_cb>> s->acpi_pcihp_pci_status[bsel].up |= (1U << slot);
+     *   - hw/acpi/pcihp.c|370| <<acpi_pcihp_device_unplug_request_cb>> s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);
+     *   - hw/acpi/pcihp.c|404| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].up;
+     *   - hw/acpi/pcihp.c|406| <<pci_read>> s->acpi_pcihp_pci_status[bsel].up = 0;
+     *   - hw/acpi/pcihp.c|411| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].down;
+     *   - hw/acpi/pcihp.c|418| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;
+     *   - include/hw/acpi/pcihp.h|82| <<VMSTATE_PCI_HOTPLUG>> VMSTATE_STRUCT_ARRAY_TEST(pcihp.acpi_pcihp_pci_status, state, \
+     */
     /* Mark request as complete */
     s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);
     s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);
@@ -227,11 +300,32 @@ static void acpi_pcihp_eject_slot(AcpiPciHpState *s, unsigned bsel, unsigned slo
     }
 }
 
+/*
+ * 在以下使用acpi_pcihp_update_hotplug_bus():
+ *   - hw/acpi/pcihp.c|261| <<acpi_pcihp_update>> acpi_pcihp_update_hotplug_bus(s, i);
+ */
 static void acpi_pcihp_update_hotplug_bus(AcpiPciHpState *s, int bsel)
 {
     BusChild *kid, *next;
     PCIBus *bus = acpi_pcihp_find_hotplug_bus(s, bsel);
 
+    /*
+     * 在以下使用AcpiPciHpState->acpi_pcihp_pci_status[ACPI_PCIHP_MAX_HOTPLUG_BUS]:
+     *   - hw/acpi/piix4.c|262| <<global>> acpi_pci_hotplug.acpi_pcihp_pci_status[ACPI_PCIHP_BSEL_DEFAULT],
+     *   - hw/acpi/pcihp.c|196| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|197| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|236| <<acpi_pcihp_update_hotplug_bus>> while (s->acpi_pcihp_pci_status[bsel].down) {
+     *   - hw/acpi/pcihp.c|237| <<acpi_pcihp_update_hotplug_bus>> acpi_pcihp_eject_slot(s, bsel, s->acpi_pcihp_pci_status[bsel].down);
+     *   - hw/acpi/pcihp.c|240| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable = ~0;
+     *   - hw/acpi/pcihp.c|251| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|323| <<acpi_pcihp_device_plug_cb>> s->acpi_pcihp_pci_status[bsel].up |= (1U << slot);
+     *   - hw/acpi/pcihp.c|370| <<acpi_pcihp_device_unplug_request_cb>> s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);
+     *   - hw/acpi/pcihp.c|404| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].up;
+     *   - hw/acpi/pcihp.c|406| <<pci_read>> s->acpi_pcihp_pci_status[bsel].up = 0;
+     *   - hw/acpi/pcihp.c|411| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].down;
+     *   - hw/acpi/pcihp.c|418| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;
+     *   - include/hw/acpi/pcihp.h|82| <<VMSTATE_PCI_HOTPLUG>> VMSTATE_STRUCT_ARRAY_TEST(pcihp.acpi_pcihp_pci_status, state, \
+     */
     /* Execute any pending removes during reset */
     while (s->acpi_pcihp_pci_status[bsel].down) {
         acpi_pcihp_eject_slot(s, bsel, s->acpi_pcihp_pci_status[bsel].down);
@@ -253,6 +347,10 @@ static void acpi_pcihp_update_hotplug_bus(AcpiPciHpState *s, int bsel)
     }
 }
 
+/*
+ * 在以下使用acpi_pcihp_update():
+ *   - hw/acpi/pcihp.c|268| <<acpi_pcihp_reset>> acpi_pcihp_update(s);
+ */
 static void acpi_pcihp_update(AcpiPciHpState *s)
 {
     int i;
@@ -262,6 +360,11 @@ static void acpi_pcihp_update(AcpiPciHpState *s)
     }
 }
 
+/*
+ * 在以下使用acpi_pcihp_reset():
+ *   - hw/acpi/ich9.c|287| <<pm_reset>> acpi_pcihp_reset(&pm->acpi_pci_hotplug);
+ *   - hw/acpi/piix4.c|307| <<piix4_pm_reset>> acpi_pcihp_reset(&s->acpi_pci_hotplug);
+ */
 void acpi_pcihp_reset(AcpiPciHpState *s)
 {
     acpi_set_pci_info(s->use_acpi_hotplug_bridge);
@@ -273,6 +376,14 @@ void acpi_pcihp_device_pre_plug_cb(HotplugHandler *hotplug_dev,
 {
     PCIDevice *pdev = PCI_DEVICE(dev);
 
+    /*
+     * 在以下使用acpi_pcihp_get_bsel():
+     *   - hw/acpi/pcihp.c|160| <<acpi_pcihp_test_hotplug_bus>> if (find->bsel == acpi_pcihp_get_bsel(bus)) {
+     *   - hw/acpi/pcihp.c|358| <<acpi_pcihp_device_pre_plug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)) < 0) {
+     *   - hw/acpi/pcihp.c|471| <<acpi_pcihp_device_plug_cb>> bsel = acpi_pcihp_get_bsel(bus);
+     *   - hw/acpi/pcihp.c|500| <<acpi_pcihp_device_unplug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)));
+     *   - hw/acpi/pcihp.c|511| <<acpi_pcihp_device_unplug_request_cb>> int bsel = acpi_pcihp_get_bsel(pci_get_bus(pdev));
+     */
     /* Only hotplugged devices need the hotplug capability. */
     if (dev->hotplugged &&
         acpi_pcihp_get_bsel(pci_get_bus(pdev)) < 0) {
@@ -282,6 +393,76 @@ void acpi_pcihp_device_pre_plug_cb(HotplugHandler *hotplug_dev,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  acpi_pcihp_device_plug_cb (hotplug_dev=0x5555578f8610, s=0x5555578fa000, dev=0x555557ca4700, errp=0x7fffffffb430)
+ *     at ../hw/acpi/pcihp.c:287
+ * #1  0x0000555555cfd8b0 in device_set_realized (obj=<optimized out>, value=<optimized out>, errp=0x7fffffffb4b0)
+ *     at ../hw/core/qdev.c:551
+ * #2  0x0000555555d006eb in property_set_bool (obj=0x555557ca4700, v=<optimized out>, name=<optimized out>, opaque=0x5555570093d0,
+ *     errp=0x7fffffffb4b0) at ../qom/object.c:2374
+ * #3  0x0000555555d03878 in object_property_set (obj=obj@entry=0x555557ca4700, name=name@entry=0x55555600da85 "realized", v=v@entry=0x555557ca6930,
+ *     errp=0x7fffffffb4b0, errp@entry=0x555556f6f438 <error_fatal>) at ../qom/object.c:1449
+ * #4  0x0000555555d075b0 in object_property_set_qobject (obj=obj@entry=0x555557ca4700, name=name@entry=0x55555600da85 "realized",
+ *     value=value@entry=0x555557ca66d0, errp=errp@entry=0x555556f6f438 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #5  0x0000555555d03f25 in object_property_set_bool (obj=obj@entry=0x555557ca4700, name=name@entry=0x55555600da85 "realized", value=value@entry=true,
+ *     errp=0x555556f6f438 <error_fatal>) at ../qom/object.c:1519
+ * #6  0x0000555555cfcc9e in qdev_realize (dev=dev@entry=0x555557ca4700, bus=bus@entry=0x5555574e22d0, errp=<optimized out>) at ../hw/core/qdev.c:276
+ * #7  0x0000555555cfcd3f in qdev_realize_and_unref (dev=dev@entry=0x555557ca4700, bus=bus@entry=0x5555574e22d0, errp=<optimized out>) at ../hw/core/qdev.c:283
+ * #8  0x0000555555a1c013 in pci_realize_and_unref (errp=<optimized out>, bus=0x5555574e22d0, dev=0x555557ca4700) at ../hw/pci/pci.c:2356
+ * #9  pci_create_simple_multifunction (bus=0x5555574e22d0, devfn=devfn@entry=250, name=name@entry=0x555555f693ab "ich9-ahci") at ../hw/pci/pci.c:2363
+ * #10 0x0000555555bd4f53 in pc_q35_init (machine=0x555557280110) at ../hw/i386/pc_q35.c:289
+ * #11 0x000055555593bb15 in machine_run_board_init (machine=<optimized out>, mem_path=<optimized out>, errp=<optimized out>,
+ *     errp@entry=0x555556f6f438 <error_fatal>) at ../hw/core/machine.c:1682
+ * #12 0x0000555555b06eb8 in qemu_init_board () at ../system/vl.c:2711
+ * #13 qmp_x_exit_preconfig (errp=0x555556f6f438 <error_fatal>) at ../system/vl.c:2807
+ * #14 0x0000555555b0a897 in qemu_init (argc=<optimized out>, argv=<optimized out>) at ../system/vl.c:3843
+ * #15 0x000055555587f449 in main (argc=<optimized out>, argv=<optimized out>) at ../system/main.c:71
+ *
+ *
+ * (gdb) bt
+ * #0  acpi_pcihp_device_plug_cb (hotplug_dev=0x5555578f8610, s=0x5555578fa000, dev=0x555557a839d0, errp=0x7fffffffa410) at ../hw/acpi/pcihp.c:287
+ * #1  0x0000555555cfd8b0 in device_set_realized (obj=<optimized out>, value=<optimized out>, errp=0x7fffffffa6b0) at ../hw/core/qdev.c:551
+ * #2  0x0000555555d006eb in property_set_bool (obj=0x555557a839d0, v=<optimized out>, name=<optimized out>, opaque=0x5555570093d0,
+ *     errp=0x7fffffffa6b0) at ../qom/object.c:2374
+ * #3  0x0000555555d03878 in object_property_set (obj=obj@entry=0x555557a839d0, name=name@entry=0x55555600da85 "realized", v=v@entry=0x55555a6f0f00,
+ *     errp=errp@entry=0x7fffffffa6b0) at ../qom/object.c:1449
+ * #4  0x0000555555d075b0 in object_property_set_qobject (obj=obj@entry=0x555557a839d0, name=name@entry=0x55555600da85 "realized",
+ *     value=value@entry=0x5555590e01a0, errp=errp@entry=0x7fffffffa6b0) at ../qom/qom-qobject.c:28
+ * #5  0x0000555555d03f25 in object_property_set_bool (obj=obj@entry=0x555557a839d0, name=name@entry=0x55555600da85 "realized", value=value@entry=true,
+ *     errp=errp@entry=0x7fffffffa6b0) at ../qom/object.c:1519
+ * #6  0x0000555555cfcc9e in qdev_realize (dev=dev@entry=0x555557a839d0, bus=bus@entry=0x555557d9dd40, errp=errp@entry=0x7fffffffa6b0) at
+ *     ../hw/core/qdev.c:276
+ * #7  0x0000555555afe270 in qdev_device_add_from_qdict (opts=opts@entry=0x555557bcde20, from_json=from_json@entry=false, errp=errp@entry=0x7fffffffa6b0)
+ *     at ../system/qdev-monitor.c:714
+ * #8  0x0000555555afe382 in qdev_device_add (opts=opts@entry=0x55555a838f50, errp=errp@entry=0x7fffffffa6b0) at ../system/qdev-monitor.c:733
+ * #9  0x0000555555afe863 in hmp_device_add (mon=0x55555729cb40, qdict=<optimized out>) at ../system/qdev-monitor.c:994
+ * #10 0x0000555555b4a789 in handle_hmp_command_exec (cmd=<optimized out>, cmd=<optimized out>, qdict=0x555557accd70, mon=0x55555729cb40)
+ *     at ../monitor/hmp.c:1106
+ * #11 handle_hmp_command_exec (qdict=0x555557accd70, cmd=0x555556e7f2c0 <hmp_cmds+1920>, mon=0x55555729cb40) at ../monitor/hmp.c:1098
+ * #12 handle_hmp_command (mon=mon@entry=0x55555729cb40, cmdline=<optimized out>, cmdline@entry=0x5555572b5c90
+ *     "device_add vhost-scsi-pci,wwpn=naa.1123451234512346,num_queues=1,bus=pcie-root-port.1,bootindex=-1,migratable=true,id=vhost02")
+ *     at ../monitor/hmp.c:1158
+ * #13 0x0000555555b4a8cd in monitor_command_cb (opaque=0x55555729cb40, cmdline=0x5555572b5c90
+ *     "device_add vhost-scsi-pci,wwpn=naa.1123451234512346,num_queues=1,bus=pcie-root-port.1,bootindex=-1,migratable=true,id=vhost02", readline_opaque=<optimized out>)
+ *     at ../monitor/hmp.c:47
+ * #14 0x0000555555ee6eb4 in readline_handle_byte (rs=0x5555572b5c90, ch=<optimized out>) at ../util/readline.c:427
+ * #15 0x0000555555b4a91b in monitor_read (opaque=0x55555729cb40, buf=<optimized out>, size=<optimized out>) at ../monitor/hmp.c:1390
+ * #16 0x0000555555e19a3d in fd_chr_read (chan=0x55555725ef30, cond=<optimized out>, opaque=<optimized out>) at ../chardev/char-fd.c:72
+ * #17 0x00007ffff73c4854 in g_main_dispatch (context=0x555557007150) at ../glib/gmain.c:3325
+ * #18 g_main_context_dispatch (context=0x555557007150) at ../glib/gmain.c:4043
+ * #19 0x0000555555edaea8 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #20 os_host_main_loop_wait (timeout=989890) at ../util/main-loop.c:310
+ * #21 main_loop_wait (nonblocking=nonblocking@entry=0) at ../util/main-loop.c:589
+ * #22 0x0000555555b02e09 in qemu_main_loop () at ../system/runstate.c:835
+ * #23 0x0000555555e1ec2c in qemu_default_main (opaque=opaque@entry=0x0) at ../system/main.c:50
+ * #24 0x000055555587f4a5 in main (argc=<optimized out>, argv=<optimized out>) at ../system/main.c:80
+ *
+ *
+ * 在以下调用acpi_pcihp_device_plug_cb():
+ *   - hw/acpi/ich9.c|508| <<ich9_pm_device_plug_cb>> acpi_pcihp_device_plug_cb(hotplug_dev, &lpc->pm.acpi_pci_hotplug, dev, errp);
+ *   - hw/acpi/piix4.c|352| <<piix4_device_plug_cb>> acpi_pcihp_device_plug_cb(hotplug_dev, &s->acpi_pci_hotplug, dev, errp);
+ */
 void acpi_pcihp_device_plug_cb(HotplugHandler *hotplug_dev, AcpiPciHpState *s,
                                DeviceState *dev, Error **errp)
 {
@@ -318,8 +499,33 @@ void acpi_pcihp_device_plug_cb(HotplugHandler *hotplug_dev, AcpiPciHpState *s,
         pcie_cap_slot_enable_power(bridge);
     }
 
+    /*
+     * 在以下使用acpi_pcihp_get_bsel():
+     *   - hw/acpi/pcihp.c|160| <<acpi_pcihp_test_hotplug_bus>> if (find->bsel == acpi_pcihp_get_bsel(bus)) {
+     *   - hw/acpi/pcihp.c|358| <<acpi_pcihp_device_pre_plug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)) < 0) {
+     *   - hw/acpi/pcihp.c|471| <<acpi_pcihp_device_plug_cb>> bsel = acpi_pcihp_get_bsel(bus);
+     *   - hw/acpi/pcihp.c|500| <<acpi_pcihp_device_unplug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)));
+     *   - hw/acpi/pcihp.c|511| <<acpi_pcihp_device_unplug_request_cb>> int bsel = acpi_pcihp_get_bsel(pci_get_bus(pdev));
+     */
     bsel = acpi_pcihp_get_bsel(bus);
     g_assert(bsel >= 0);
+    /*
+     * 在以下使用AcpiPciHpState->acpi_pcihp_pci_status[ACPI_PCIHP_MAX_HOTPLUG_BUS]:
+     *   - hw/acpi/piix4.c|262| <<global>> acpi_pci_hotplug.acpi_pcihp_pci_status[ACPI_PCIHP_BSEL_DEFAULT],
+     *   - hw/acpi/pcihp.c|196| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|197| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|236| <<acpi_pcihp_update_hotplug_bus>> while (s->acpi_pcihp_pci_status[bsel].down) {
+     *   - hw/acpi/pcihp.c|237| <<acpi_pcihp_update_hotplug_bus>> acpi_pcihp_eject_slot(s, bsel, s->acpi_pcihp_pci_status[bsel].down);
+     *   - hw/acpi/pcihp.c|240| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable = ~0;
+     *   - hw/acpi/pcihp.c|251| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|323| <<acpi_pcihp_device_plug_cb>> s->acpi_pcihp_pci_status[bsel].up |= (1U << slot);
+     *   - hw/acpi/pcihp.c|370| <<acpi_pcihp_device_unplug_request_cb>> s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);
+     *   - hw/acpi/pcihp.c|404| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].up;
+     *   - hw/acpi/pcihp.c|406| <<pci_read>> s->acpi_pcihp_pci_status[bsel].up = 0;
+     *   - hw/acpi/pcihp.c|411| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].down;
+     *   - hw/acpi/pcihp.c|418| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;
+     *   - include/hw/acpi/pcihp.h|82| <<VMSTATE_PCI_HOTPLUG>> VMSTATE_STRUCT_ARRAY_TEST(pcihp.acpi_pcihp_pci_status, state, \
+     */
     s->acpi_pcihp_pci_status[bsel].up |= (1U << slot);
     acpi_send_event(DEVICE(hotplug_dev), ACPI_PCI_HOTPLUG_STATUS);
 }
@@ -329,6 +535,14 @@ void acpi_pcihp_device_unplug_cb(HotplugHandler *hotplug_dev, AcpiPciHpState *s,
 {
     PCIDevice *pdev = PCI_DEVICE(dev);
 
+    /*
+     * 在以下使用acpi_pcihp_get_bsel():
+     *   - hw/acpi/pcihp.c|160| <<acpi_pcihp_test_hotplug_bus>> if (find->bsel == acpi_pcihp_get_bsel(bus)) {
+     *   - hw/acpi/pcihp.c|358| <<acpi_pcihp_device_pre_plug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)) < 0) {
+     *   - hw/acpi/pcihp.c|471| <<acpi_pcihp_device_plug_cb>> bsel = acpi_pcihp_get_bsel(bus);
+     *   - hw/acpi/pcihp.c|500| <<acpi_pcihp_device_unplug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)));
+     *   - hw/acpi/pcihp.c|511| <<acpi_pcihp_device_unplug_request_cb>> int bsel = acpi_pcihp_get_bsel(pci_get_bus(pdev));
+     */
     trace_acpi_pci_unplug(PCI_SLOT(pdev->devfn),
                           acpi_pcihp_get_bsel(pci_get_bus(pdev)));
 
@@ -341,6 +555,14 @@ void acpi_pcihp_device_unplug_request_cb(HotplugHandler *hotplug_dev,
 {
     PCIDevice *pdev = PCI_DEVICE(dev);
     int slot = PCI_SLOT(pdev->devfn);
+    /*
+     * 在以下使用acpi_pcihp_get_bsel():
+     *   - hw/acpi/pcihp.c|160| <<acpi_pcihp_test_hotplug_bus>> if (find->bsel == acpi_pcihp_get_bsel(bus)) {
+     *   - hw/acpi/pcihp.c|358| <<acpi_pcihp_device_pre_plug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)) < 0) {
+     *   - hw/acpi/pcihp.c|471| <<acpi_pcihp_device_plug_cb>> bsel = acpi_pcihp_get_bsel(bus);
+     *   - hw/acpi/pcihp.c|500| <<acpi_pcihp_device_unplug_cb>> acpi_pcihp_get_bsel(pci_get_bus(pdev)));
+     *   - hw/acpi/pcihp.c|511| <<acpi_pcihp_device_unplug_request_cb>> int bsel = acpi_pcihp_get_bsel(pci_get_bus(pdev));
+     */
     int bsel = acpi_pcihp_get_bsel(pci_get_bus(pdev));
 
     trace_acpi_pci_unplug_request(bsel, slot);
@@ -367,6 +589,23 @@ void acpi_pcihp_device_unplug_request_cb(HotplugHandler *hotplug_dev,
     pdev->qdev.pending_deleted_expires_ms =
         qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL); /* 1 msec */
 
+    /*
+     * 在以下使用AcpiPciHpState->acpi_pcihp_pci_status[ACPI_PCIHP_MAX_HOTPLUG_BUS]:
+     *   - hw/acpi/piix4.c|262| <<global>> acpi_pci_hotplug.acpi_pcihp_pci_status[ACPI_PCIHP_BSEL_DEFAULT],
+     *   - hw/acpi/pcihp.c|196| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|197| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|236| <<acpi_pcihp_update_hotplug_bus>> while (s->acpi_pcihp_pci_status[bsel].down) {
+     *   - hw/acpi/pcihp.c|237| <<acpi_pcihp_update_hotplug_bus>> acpi_pcihp_eject_slot(s, bsel, s->acpi_pcihp_pci_status[bsel].down);
+     *   - hw/acpi/pcihp.c|240| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable = ~0;
+     *   - hw/acpi/pcihp.c|251| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|323| <<acpi_pcihp_device_plug_cb>> s->acpi_pcihp_pci_status[bsel].up |= (1U << slot);
+     *   - hw/acpi/pcihp.c|370| <<acpi_pcihp_device_unplug_request_cb>> s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);
+     *   - hw/acpi/pcihp.c|404| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].up;
+     *   - hw/acpi/pcihp.c|406| <<pci_read>> s->acpi_pcihp_pci_status[bsel].up = 0;
+     *   - hw/acpi/pcihp.c|411| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].down;
+     *   - hw/acpi/pcihp.c|418| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;
+     *   - include/hw/acpi/pcihp.h|82| <<VMSTATE_PCI_HOTPLUG>> VMSTATE_STRUCT_ARRAY_TEST(pcihp.acpi_pcihp_pci_status, state, \
+     */
     s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);
     acpi_send_event(DEVICE(hotplug_dev), ACPI_PCI_HOTPLUG_STATUS);
 }
@@ -389,6 +628,37 @@ bool acpi_pcihp_is_hotpluggbale_bus(AcpiPciHpState *s, BusState *bus)
     return false;
 }
 
+/*
+ * (gdb) bt
+ * #0  pci_read (opaque=0x5555578fa000, addr=0, size=4) at ../hw/acpi/pcihp.c:393
+ * #1  0x0000555555cb5bbf in memory_region_read_accessor (mr=mr@entry=0x5555578fac10, addr=0, value=value@entry=0x7fffefffe690,
+ *     size=size@entry=4, shift=0, mask=mask@entry=4294967295, attrs=...) at ../system/memory.c:445
+ * #2  0x0000555555cb67ad in access_with_adjusted_size (addr=addr@entry=0, value=value@entry=0x7fffefffe690, size=size@entry=4,
+ *     access_size_min=<optimized out>, access_size_max=<optimized out>, access_fn=0x555555cb5b80 <memory_region_read_accessor>,
+ *     mr=0x5555578fac10, attrs=...) at ../system/memory.c:573
+ * #3  0x0000555555cb7751 in memory_region_dispatch_read1 (attrs=..., size=4, pval=0x7fffefffe690, addr=0, mr=0x5555578fac10)
+ *     at ../system/memory.c:1464
+ * #4  memory_region_dispatch_read (mr=mr@entry=0x5555578fac10, addr=addr@entry=0, pval=pval@entry=0x7fffefffe690, op=MO_32,
+ *     attrs=attrs@entry=...) at ../system/memory.c:1491
+ * #5  0x0000555555cbe184 in flatview_read_continue_step (attrs=attrs@entry=..., buf=buf@entry=0x7ffff7ff1000 "", mr_addr=0,
+ *     l=l@entry=0x7fffefffe790, mr=0x5555578fac10, len=4) at ../system/physmem.c:3032
+ * #6  0x0000555555cc2de0 in flatview_read_continue (fv=fv@entry=0x55555793ed70, addr=addr@entry=3264, attrs=attrs@entry=...,
+ *     ptr=ptr@entry=0x7ffff7ff1000, len=len@entry=4, mr_addr=<optimized out>, l=<optimized out>, mr=<optimized out>)
+ *     at ../system/physmem.c:3073
+ * #7  0x0000555555cc2ef1 in flatview_read (fv=0x55555793ed70, addr=addr@entry=3264, attrs=attrs@entry=...,
+ *     buf=buf@entry=0x7ffff7ff1000, len=len@entry=4) at ../system/physmem.c:3103
+ * #8  0x0000555555cc327e in address_space_read_full (len=4, buf=0x7ffff7ff1000, attrs=..., addr=3264, as=0x555556f514e0 <address_space_io>)
+ *     at ../system/physmem.c:3116
+ * #9  address_space_rw (as=0x555556f514e0 <address_space_io>, addr=addr@entry=3264, attrs=attrs@entry=..., buf=0x7ffff7ff1000,
+ *     len=len@entry=4, is_write=is_write@entry=false) at ../system/physmem.c:3144
+ * #10 0x0000555555cf19db in kvm_handle_io (count=1, size=4, direction=<optimized out>, data=<optimized out>, attrs=..., port=3264)
+ *     at ../accel/kvm/kvm-all.c:2800
+ * #11 kvm_cpu_exec (cpu=cpu@entry=0x5555572b8800) at ../accel/kvm/kvm-all.c:3186
+ * #12 0x0000555555cf30d5 in kvm_vcpu_thread_fn (arg=arg@entry=0x5555572b8800) at ../accel/kvm/kvm-accel-ops.c:51
+ * #13 0x0000555555ec5269 in qemu_thread_start (args=<optimized out>) at ../util/qemu-thread-posix.c:541
+ * #14 0x00007ffff65111da in start_thread () from /lib64/libpthread.so.0
+ * #15 0x00007ffff616b8d3 in clone () from /lib64/libc.so.6
+ */
 static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)
 {
     AcpiPciHpState *s = opaque;
@@ -401,6 +671,23 @@ static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)
 
     switch (addr) {
     case PCI_UP_BASE:
+        /*
+	 * 在以下使用AcpiPciHpState->acpi_pcihp_pci_status[ACPI_PCIHP_MAX_HOTPLUG_BUS]:
+	 *   - hw/acpi/piix4.c|262| <<global>> acpi_pci_hotplug.acpi_pcihp_pci_status[ACPI_PCIHP_BSEL_DEFAULT],
+	 *   - hw/acpi/pcihp.c|196| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);
+	 *   - hw/acpi/pcihp.c|197| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);
+	 *   - hw/acpi/pcihp.c|236| <<acpi_pcihp_update_hotplug_bus>> while (s->acpi_pcihp_pci_status[bsel].down) {
+	 *   - hw/acpi/pcihp.c|237| <<acpi_pcihp_update_hotplug_bus>> acpi_pcihp_eject_slot(s, bsel, s->acpi_pcihp_pci_status[bsel].down);
+	 *   - hw/acpi/pcihp.c|240| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable = ~0;
+	 *   - hw/acpi/pcihp.c|251| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable &= ~(1U << slot);
+	 *   - hw/acpi/pcihp.c|323| <<acpi_pcihp_device_plug_cb>> s->acpi_pcihp_pci_status[bsel].up |= (1U << slot);
+	 *   - hw/acpi/pcihp.c|370| <<acpi_pcihp_device_unplug_request_cb>> s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);
+	 *   - hw/acpi/pcihp.c|404| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].up;
+	 *   - hw/acpi/pcihp.c|406| <<pci_read>> s->acpi_pcihp_pci_status[bsel].up = 0;
+	 *   - hw/acpi/pcihp.c|411| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].down;
+	 *   - hw/acpi/pcihp.c|418| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;
+	 *   - include/hw/acpi/pcihp.h|82| <<VMSTATE_PCI_HOTPLUG>> VMSTATE_STRUCT_ARRAY_TEST(pcihp.acpi_pcihp_pci_status, state, \
+	 */
         val = s->acpi_pcihp_pci_status[bsel].up;
         if (s->use_acpi_hotplug_bridge) {
             s->acpi_pcihp_pci_status[bsel].up = 0;
@@ -495,6 +782,34 @@ static const MemoryRegionOps acpi_pcihp_io_ops = {
     },
 };
 
+/*
+ * (gdb) bt
+ * #0  acpi_pcihp_init (owner=owner@entry=0x5555578f8610, s=s@entry=0x5555578fa000, root_bus=0x5555574e22d0, io=io@entry=0x5555572142e0,
+ *     io_base=io_base@entry=3264) at ../hw/acpi/pcihp.c:501
+ * #1  0x0000555555908928 in ich9_pm_init (lpc_pci=0x5555578f8610, pm=0x5555578f9660, sci_irq=0x555557a323d0) at ../hw/acpi/ich9.c:336
+ * #2  0x0000555555c71953 in ich9_lpc_pm_init (lpc=0x5555578f8610) at ../hw/isa/lpc_ich9.c:429
+ * #3  ich9_lpc_realize (d=<optimized out>, errp=0x7fffffffb3b0) at ../hw/isa/lpc_ich9.c:765
+ * #4  0x0000555555a1daa6 in pci_qdev_realize (qdev=<optimized out>, errp=<optimized out>) at ../hw/pci/pci.c:2263
+ * #5  0x0000555555cfd5fb in device_set_realized (obj=<optimized out>, value=<optimized out>, errp=0x7fffffffb4d0) at ../hw/core/qdev.c:494
+ * #6  0x0000555555d006eb in property_set_bool (obj=0x5555578f8610, v=<optimized out>, name=<optimized out>, opaque=0x5555570093d0,
+ *     errp=0x7fffffffb4d0) at ../qom/object.c:2374
+ * #7  0x0000555555d03878 in object_property_set (obj=obj@entry=0x5555578f8610, name=name@entry=0x55555600da85 "realized", v=v@entry=0x5555579029c0,
+ *     errp=0x7fffffffb4d0, errp@entry=0x555556f6f438 <error_fatal>) at ../qom/object.c:1449
+ * #8  0x0000555555d075b0 in object_property_set_qobject (obj=obj@entry=0x5555578f8610, name=name@entry=0x55555600da85 "realized",
+ *     value=value@entry=0x555557901610, errp=errp@entry=0x555556f6f438 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #9  0x0000555555d03f25 in object_property_set_bool (obj=obj@entry=0x5555578f8610, name=name@entry=0x55555600da85 "realized",
+ *     value=value@entry=true, errp=0x555556f6f438 <error_fatal>) at ../qom/object.c:1519
+ * #10 0x0000555555cfcc9e in qdev_realize (dev=dev@entry=0x5555578f8610, bus=<optimized out>, errp=<optimized out>) at ../hw/core/qdev.c:276
+ * #11 0x0000555555cfcd3f in qdev_realize_and_unref (dev=dev@entry=0x5555578f8610, bus=<optimized out>, errp=<optimized out>) at ../hw/core/qdev.c:283
+ * #12 0x0000555555a1bf95 in pci_realize_and_unref (dev=dev@entry=0x5555578f8610, bus=<optimized out>, errp=<optimized out>) at ../hw/pci/pci.c:2356
+ * #13 0x0000555555bd4dd5 in pc_q35_init (machine=0x555557280110) at ../hw/i386/pc_q35.c:242
+ * #14 0x000055555593bb15 in machine_run_board_init (machine=<optimized out>, mem_path=<optimized out>, errp=<optimized out>,
+ *     errp@entry=0x555556f6f438 <error_fatal>) at ../hw/core/machine.c:1682
+ * #15 0x0000555555b06eb8 in qemu_init_board () at ../system/vl.c:2711
+ * #16 qmp_x_exit_preconfig (errp=0x555556f6f438 <error_fatal>) at ../system/vl.c:2807
+ * #17 0x0000555555b0a897 in qemu_init (argc=<optimized out>, argv=<optimized out>) at ../system/vl.c:3843
+ * #18 0x000055555587f449 in main (argc=<optimized out>, argv=<optimized out>) at ../system/main.c:71
+ */
 void acpi_pcihp_init(Object *owner, AcpiPciHpState *s, PCIBus *root_bus,
                      MemoryRegion *io, uint16_t io_base)
 {
diff --git a/hw/acpi/piix4.c b/hw/acpi/piix4.c
index 6d023e595..fbe55e354 100644
--- a/hw/acpi/piix4.c
+++ b/hw/acpi/piix4.c
@@ -276,6 +276,10 @@ static const VMStateDescription vmstate_acpi = {
     }
 };
 
+/*
+ * 在以下使用piix4_pm_reset():
+ *   - hw/acpi/piix4.c|635| <<piix4_pm_class_init>> device_class_set_legacy_reset(dc, piix4_pm_reset);
+ */
 static void piix4_pm_reset(DeviceState *dev)
 {
     PIIX4PMState *s = PIIX4_PM(dev);
diff --git a/hw/acpi/utils.c b/hw/acpi/utils.c
index 0c486ea29..b8017cf58 100644
--- a/hw/acpi/utils.c
+++ b/hw/acpi/utils.c
@@ -26,6 +26,39 @@
 #include "hw/acpi/utils.h"
 #include "hw/loader.h"
 
+/*
+ * 在以下调用acpi_add_rom_blob():
+ *   - hw/arm/virt-acpi-build.c|1137| <<virt_acpi_setup>> build_state->table_mr =
+ *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.table_data, ACPI_BUILD_TABLE_FILE);
+ *   - hw/arm/virt-acpi-build.c|1142| <<virt_acpi_setup>> build_state->linker_mr =
+ *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+ *   - hw/arm/virt-acpi-build.c|1157| <<virt_acpi_setup>> build_state->rsdp_mr =
+ *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.rsdp, ACPI_BUILD_RSDP_FILE);
+ *   - hw/i386/acpi-build.c|2767| <<acpi_setup>> build_state->table_mr =
+ *       acpi_add_rom_blob(acpi_build_update, build_state, tables.table_data, ACPI_BUILD_TABLE_FILE);
+ *   - hw/i386/acpi-build.c|2773| <<acpi_setup>> build_state->linker_mr =
+ *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+ *   - hw/i386/acpi-build.c|2798| <<acpi_setup>> build_state->rsdp_mr =
+ *       acpi_add_rom_blob(acpi_build_update, build_state, tables.rsdp, ACPI_BUILD_RSDP_FILE);
+ *   - hw/i386/acpi-microvm.c|260| <<acpi_setup_microvm>> acpi_add_rom_blob(acpi_build_no_update,
+ *       NULL, tables.table_data, ACPI_BUILD_TABLE_FILE);
+ *   - hw/i386/acpi-microvm.c|262| <<acpi_setup_microvm>> acpi_add_rom_blob(acpi_build_no_update,
+ *       NULL, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+ *   - hw/i386/acpi-microvm.c|264| <<acpi_setup_microvm>> acpi_add_rom_blob(acpi_build_no_update,
+ *       NULL, tables.rsdp, ACPI_BUILD_RSDP_FILE);
+ *   - hw/loongarch/virt-acpi-build.c|717| <<virt_acpi_setup>> build_state->table_mr =
+ *       acpi_add_rom_blob(acpi_build_update, build_state, tables.table_data, ACPI_BUILD_TABLE_FILE);
+ *   - hw/loongarch/virt-acpi-build.c|723| <<virt_acpi_setup>> build_state->linker_mr =
+ *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+ *   - hw/loongarch/virt-acpi-build.c|726| <<virt_acpi_setup>> build_state->rsdp_mr =
+ *       acpi_add_rom_blob(acpi_build_update, build_state, tables.rsdp, ACPI_BUILD_RSDP_FILE);
+ *   - hw/riscv/virt-acpi-build.c|802| <<virt_acpi_setup>> build_state->table_mr =
+ *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.table_data, ACPI_BUILD_TABLE_FILE);
+ *   - hw/riscv/virt-acpi-build.c|807| <<virt_acpi_setup>> build_state->linker_mr =
+ *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+ *   - hw/riscv/virt-acpi-build.c|812| <<virt_acpi_setup>> build_state->rsdp_mr =
+ *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.rsdp, ACPI_BUILD_RSDP_FILE);
+ */
 MemoryRegion *acpi_add_rom_blob(FWCfgCallback update, void *opaque,
                                 GArray *blob, const char *name)
 {
@@ -35,6 +68,24 @@ MemoryRegion *acpi_add_rom_blob(FWCfgCallback update, void *opaque,
     if (!strcmp(name, ACPI_BUILD_TABLE_FILE)) {
         max_size = 0x200000;
     } else if (!strcmp(name, ACPI_BUILD_LOADER_FILE)) {
+        /*
+	 * 在以下使用ACPI_BUILD_LOADER_FILE:
+         *   - include/hw/acpi/aml-build.h|13| <<global>> #define ACPI_BUILD_LOADER_FILE "etc/table-loader"
+	 *   - hw/acpi/utils.c|37| <<acpi_add_rom_blob>> } else if (!strcmp(name, ACPI_BUILD_LOADER_FILE)) {
+         *   - hw/arm/virt-acpi-build.c|1145| <<virt_acpi_setup>> build_state->linker_mr =
+         *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+         *   - hw/i386/acpi-build.c|2774| <<acpi_setup>> build_state->linker_mr =
+         *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+         *   - hw/i386/acpi-microvm.c|263| <<acpi_setup_microvm>> acpi_add_rom_blob(acpi_build_no_update, NULL,
+         *       tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+         *   - hw/loongarch/virt-acpi-build.c|724| <<virt_acpi_setup>> build_state->linker_mr =
+         *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+         *   - hw/nvram/fw_cfg.c|654| <<fw_cfg_acpi_mr_restore_post_load>>
+         *       } else if (!strcmp(s->files->f[i].name, ACPI_BUILD_LOADER_FILE)) {
+         *   - hw/nvram/fw_cfg.c|894| <<fw_cfg_acpi_mr_save>> } else if (!strcmp(filename, ACPI_BUILD_LOADER_FILE)) {
+         *   - hw/riscv/virt-acpi-build.c|810| <<virt_acpi_setup>> build_state->linker_mr =
+         *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+	 */
         max_size = 0x10000;
     } else if (!strcmp(name, ACPI_BUILD_RSDP_FILE)) {
         max_size = 0x1000;
diff --git a/hw/arm/virt-acpi-build.c b/hw/arm/virt-acpi-build.c
index 3ac8f8e17..711bfe32c 100644
--- a/hw/arm/virt-acpi-build.c
+++ b/hw/arm/virt-acpi-build.c
@@ -119,6 +119,10 @@ static void acpi_dsdt_add_flash(Aml *scope, const MemMapEntry *flash_memmap)
     aml_append(scope, dev);
 }
 
+/*
+ * 在以下使用acpi_dsdt_add_pci():
+ *   - hw/arm/virt-acpi-build.c|841| <<build_dsdt>> acpi_dsdt_add_pci(scope, memmap, irqmap[VIRT_PCIE] + ARM_SPI_BASE, vms);
+ */
 static void acpi_dsdt_add_pci(Aml *scope, const MemMapEntry *memmap,
                               uint32_t irq, VirtMachineState *vms)
 {
@@ -135,6 +139,13 @@ static void acpi_dsdt_add_pci(Aml *scope, const MemMapEntry *memmap,
         cfg.mmio64 = memmap[VIRT_HIGH_PCIE_MMIO];
     }
 
+    /*
+     * 在以下使用acpi_dsdt_add_gpex():
+     *   - hw/arm/virt-acpi-build.c|138| <<acpi_dsdt_add_pci>> acpi_dsdt_add_gpex(scope, &cfg);
+     *   - hw/i386/acpi-microvm.c|99| <<acpi_dsdt_add_pci>> acpi_dsdt_add_gpex(scope, &mms->gpex);
+     *   - hw/loongarch/virt-acpi-build.c|398| <<build_pci_device_aml>> acpi_dsdt_add_gpex(scope, &cfg);
+     *   - hw/pci-host/gpex-acpi.c|299| <<acpi_dsdt_add_gpex_host>> acpi_dsdt_add_gpex(scope, &GPEX_HOST(obj)->gpex_cfg);
+     */
     acpi_dsdt_add_gpex(scope, &cfg);
 }
 
@@ -1026,18 +1037,43 @@ void virt_acpi_build(VirtMachineState *vms, AcpiBuildTables *tables)
     g_array_free(table_offsets, true);
 }
 
+/*
+ * 在以下调用arm的acpi_ram_update():
+ *   - hw/arm/virt-acpi-build.c|1064| <<virt_acpi_build_update>> acpi_ram_update(build_state->table_mr, tables.table_data);
+ *   - hw/arm/virt-acpi-build.c|1065| <<virt_acpi_build_update>> acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
+ *   - hw/arm/virt-acpi-build.c|1066| <<virt_acpi_build_update>> acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
+ *
+ * 在以下调用i386的acpi_ram_update():
+ *   - hw/i386/acpi-build.c|2671| <<acpi_build_update>> acpi_ram_update(build_state->table_mr, tables.table_data);
+ *   - hw/i386/acpi-build.c|2673| <<acpi_build_update>> acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
+ *   - hw/i386/acpi-build.c|2675| <<acpi_build_update>> acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
+ */
 static void acpi_ram_update(MemoryRegion *mr, GArray *data)
 {
     uint32_t size = acpi_data_len(data);
 
     /* Make sure RAM size is correct - in case it got changed
      * e.g. by migration */
+    /*
+     * 在以下调用memory_region_ram_resize():
+     *   - hw/arm/virt-acpi-build.c|1035| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/i386/acpi-build.c|2642| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/loongarch/virt-acpi-build.c|644| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/nvram/fw_cfg.c|631| <<fw_cfg_update_mr>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/riscv/virt-acpi-build.c|746| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     */
     memory_region_ram_resize(mr, size, &error_abort);
 
     memcpy(memory_region_get_ram_ptr(mr), data->data, size);
     memory_region_set_dirty(mr, 0, size);
 }
 
+/*
+ * 在以下使用virt_acpi_build_update():
+ *   - hw/arm/virt-acpi-build.c|1109| <<virt_acpi_setup>> build_state->table_mr = acpi_add_rom_blob(virt_acpi_build_update,
+ *   - hw/arm/virt-acpi-build.c|1114| <<virt_acpi_setup>> build_state->linker_mr = acpi_add_rom_blob(virt_acpi_build_update,
+ *   - hw/arm/virt-acpi-build.c|1129| <<virt_acpi_setup>> build_state->rsdp_mr = acpi_add_rom_blob(virt_acpi_build_update,
+ */
 static void virt_acpi_build_update(void *build_opaque)
 {
     AcpiBuildState *build_state = build_opaque;
@@ -1053,6 +1089,17 @@ static void virt_acpi_build_update(void *build_opaque)
 
     virt_acpi_build(VIRT_MACHINE(qdev_get_machine()), &tables);
 
+    /*
+     * 在以下调用arm的acpi_ram_update():
+     *   - hw/arm/virt-acpi-build.c|1064| <<virt_acpi_build_update>> acpi_ram_update(build_state->table_mr, tables.table_data);
+     *   - hw/arm/virt-acpi-build.c|1065| <<virt_acpi_build_update>> acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
+     *   - hw/arm/virt-acpi-build.c|1066| <<virt_acpi_build_update>> acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
+     *
+     * 在以下调用i386的acpi_ram_update():
+     *   - hw/i386/acpi-build.c|2671| <<acpi_build_update>> acpi_ram_update(build_state->table_mr, tables.table_data);
+     *   - hw/i386/acpi-build.c|2673| <<acpi_build_update>> acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
+     *   - hw/i386/acpi-build.c|2675| <<acpi_build_update>> acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
+     */
     acpi_ram_update(build_state->table_mr, tables.table_data);
     acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
     acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
@@ -1103,6 +1150,24 @@ void virt_acpi_setup(VirtMachineState *vms)
                                               ACPI_BUILD_TABLE_FILE);
     assert(build_state->table_mr != NULL);
 
+    /*
+     * 在以下使用ACPI_BUILD_LOADER_FILE:
+     *   - include/hw/acpi/aml-build.h|13| <<global>> #define ACPI_BUILD_LOADER_FILE "etc/table-loader"
+     *   - hw/acpi/utils.c|37| <<acpi_add_rom_blob>> } else if (!strcmp(name, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/arm/virt-acpi-build.c|1145| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/i386/acpi-build.c|2774| <<acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/i386/acpi-microvm.c|263| <<acpi_setup_microvm>> acpi_add_rom_blob(acpi_build_no_update, NULL,
+     *       tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/loongarch/virt-acpi-build.c|724| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/nvram/fw_cfg.c|654| <<fw_cfg_acpi_mr_restore_post_load>>
+     *       } else if (!strcmp(s->files->f[i].name, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/nvram/fw_cfg.c|894| <<fw_cfg_acpi_mr_save>> } else if (!strcmp(filename, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/riscv/virt-acpi-build.c|810| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     */
     build_state->linker_mr = acpi_add_rom_blob(virt_acpi_build_update,
                                                build_state,
                                                tables.linker->cmd_blob,
diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index a96452f17..a2b23c91d 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -2944,6 +2944,10 @@ static void virt_machine_device_pre_plug_cb(HotplugHandler *hotplug_dev,
     }
 }
 
+/*
+ * 在以下使用virt_machine_device_plug_cb():
+ *   - hw/arm/virt.c|3191| <<virt_machine_class_init>> hc->plug = virt_machine_device_plug_cb;
+ */
 static void virt_machine_device_plug_cb(HotplugHandler *hotplug_dev,
                                         DeviceState *dev, Error **errp)
 {
diff --git a/hw/block/vhost-user-blk.c b/hw/block/vhost-user-blk.c
index ae42327cf..1cfc2a36c 100644
--- a/hw/block/vhost-user-blk.c
+++ b/hw/block/vhost-user-blk.c
@@ -345,6 +345,33 @@ static int vhost_user_blk_connect(DeviceState *dev, Error **errp)
     vhost_dev_set_config_notifier(&s->dev, &blk_ops);
 
     s->vhost_user.supports_config = true;
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     ret = vhost_dev_init(&s->dev, &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0,
                          errp);
     if (ret < 0) {
@@ -475,6 +502,13 @@ static void vhost_user_blk_device_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用virtio_blk_cfg_size_params:
+     *   - hw/block/vhost-user-blk.c|478| <<vhost_user_blk_device_realize>>
+     *        config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+     *   - hw/block/virtio-blk.c|1815| <<virtio_blk_device_realize>>
+     *        s->config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+     */
     config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
                                          vdev->host_features);
     virtio_init(vdev, VIRTIO_ID_BLOCK, config_size);
diff --git a/hw/block/virtio-blk-common.c b/hw/block/virtio-blk-common.c
index e2f8e2f6d..475776b7f 100644
--- a/hw/block/virtio-blk-common.c
+++ b/hw/block/virtio-blk-common.c
@@ -34,6 +34,13 @@ static const VirtIOFeature feature_sizes[] = {
     {}
 };
 
+/*
+ * 在以下使用virtio_blk_cfg_size_params:
+ *   - hw/block/vhost-user-blk.c|478| <<vhost_user_blk_device_realize>>
+ *        config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+ *   - hw/block/virtio-blk.c|1815| <<virtio_blk_device_realize>>
+ *        s->config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+ */
 const VirtIOConfigSizeParams virtio_blk_cfg_size_params = {
     .min_size = VIRTIO_BLK_CFG_SIZE,
     .max_size = sizeof(struct virtio_blk_config),
diff --git a/hw/block/virtio-blk.c b/hw/block/virtio-blk.c
index 5077793e5..c248a1aba 100644
--- a/hw/block/virtio-blk.c
+++ b/hw/block/virtio-blk.c
@@ -38,8 +38,46 @@
 #include "hw/virtio/virtio-blk-common.h"
 #include "qemu/coroutine.h"
 
+/*
+ * 没有iothread应该就是mainloop
+ * (gdb) bt
+ * #0  coroutine_pool_get_local () at ../util/qemu-coroutine.c:116
+ * #1  0x00005555561cb785 in coroutine_pool_get () at ../util/qemu-coroutine.c:181
+ * #2  0x00005555561cb8c7 in qemu_coroutine_create (entry=0x5555560034f4 <blk_aio_write_entry>, opaque=0x5555582fd4d0)
+ *     at ../util/qemu-coroutine.c:222
+ * #3  0x00005555560033cc in blk_aio_prwv (blk=0x55555846f060, offset=540709888, bytes=1024, iobuf=0x5555577f63e8,
+ *     co_entry=0x5555560034f4 <blk_aio_write_entry>, flags=BDRV_REQ_REGISTERED_BUF,
+ *     cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350) at ../block/block-backend.c:1600
+ * #4  0x0000555556003927 in blk_aio_pwritev (blk=0x55555846f060, offset=540709888, qiov=0x5555577f63e8,
+ *     flags=BDRV_REQ_REGISTERED_BUF, cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350)
+ *     at ../block/block-backend.c:1722
+ * #5  0x0000555555e2c003 in submit_requests (s=0x5555584688c0, mrb=0x7fffffffd640, start=0, num_reqs=1, niov=-1) at ../hw/block/virtio-blk.c:259
+ * #6  0x0000555555e2c12f in virtio_blk_submit_multireq (s=0x5555584688c0, mrb=0x7fffffffd640) at ../hw/block/virtio-blk.c:294
+ * #7  0x0000555555e2e065 in virtio_blk_handle_vq (s=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1008
+ * #8  0x0000555555e2e0f8 in virtio_blk_handle_output (vdev=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1028
+ * #9  0x0000555555e89d02 in virtio_queue_notify_vq (vq=0x5555584b0960) at ../hw/virtio/virtio.c:2484
+ * #10 0x0000555555e8d53c in virtio_queue_host_notifier_read (n=0x5555584b09d4) at ../hw/virtio/virtio.c:3869
+ * #11 0x00005555561a74d8 in aio_dispatch_handler (ctx=0x55555745ee50, node=0x7fffe43dfba0) at ../util/aio-posix.c:376
+ * #12 0x00005555561a76ed in aio_dispatch_handlers (ctx=0x55555745ee50) at ../util/aio-posix.c:427
+ * #13 0x00005555561a7749 in aio_dispatch (ctx=0x55555745ee50) at ../util/aio-posix.c:437
+ * #14 0x00005555561c9148 in aio_ctx_dispatch (source=0x55555745ee50, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #15 0x00007ffff6fd394b in g_main_dispatch (context=0x55555745f260) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x55555745f260) at ../glib/gmain.c:4043
+ * #17 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=657614) at ../util/main-loop.c:310
+ * #19 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #21 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x00005555560d296f in main (argc=25, argv=0x7fffffffdb28) at ../system/main.c:80
+ */
+
 static void virtio_blk_ioeventfd_attach(VirtIOBlock *s);
 
+/*
+ * 在以下使用virtio_blk_init_request():
+ *   - hw/block/virtio-blk.c|181| <<virtio_blk_get_request>> virtio_blk_init_request(s, vq, req);
+ *   - hw/block/virtio-blk.c|1395| <<virtio_blk_load_device>> virtio_blk_init_request(s, virtio_get_queue(vdev, vq_idx), req);
+ */
 static void virtio_blk_init_request(VirtIOBlock *s, VirtQueue *vq,
                                     VirtIOBlockReq *req)
 {
@@ -48,9 +86,36 @@ static void virtio_blk_init_request(VirtIOBlock *s, VirtQueue *vq,
     req->qiov.size = 0;
     req->in_len = 0;
     req->next = NULL;
+    /*
+     * 在以下使用VirtIOBlockReq->mr_next:
+     *   - hw/block/virtio-blk.c|51| <<virtio_blk_init_request>> req->mr_next = NULL;
+     *   - hw/block/virtio-blk.c|81| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+     *   - hw/block/virtio-blk.c|112| <<virtio_blk_rw_complete>> next = req->mr_next;
+     *   - hw/block/virtio-blk.c|253| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+     */
     req->mr_next = NULL;
 }
 
+/*
+ * 在以下使用virtio_blk_req_complete():
+ *   - hw/block/virtio-blk.c|88| <<virtio_blk_handle_rw_error>> virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
+ *   - hw/block/virtio-blk.c|138| <<virtio_blk_rw_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|153| <<virtio_blk_flush_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|169| <<virtio_blk_discard_write_zeroes_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|217| <<virtio_blk_handle_scsi>> virtio_blk_req_complete(req, status);
+ *   - hw/block/virtio-blk.c|645| <<virtio_blk_zone_report_complete>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|694| <<virtio_blk_handle_zone_report>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|710| <<virtio_blk_zone_mgmt_complete>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|752| <<virtio_blk_handle_zone_mgmt>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|783| <<virtio_blk_zone_append_complete>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|821| <<virtio_blk_handle_zone_append>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|891| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
+ *   - hw/block/virtio-blk.c|949| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|981| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
+ *   - hw/block/virtio-blk.c|998| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|1013| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
+ *   - hw/vmapple/virtio-blk.c|57| <<vmapple_virtio_blk_handle_unknown_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ */
 void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
 {
     VirtIOBlock *s = req->dev;
@@ -58,8 +123,33 @@ void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
 
     trace_virtio_blk_req_complete(vdev, req, status);
 
+    /*
+     * 根据Linux kernel的注释:
+     * The status byte is always the last byte of the virtblk request
+     * in-header. This helper fetches its value for all in-header formats
+     * that are currently defined.
+     *
+     * VirtIOBlockReq *req:
+     * -> struct virtio_blk_inhdr *in;
+     * -> struct virtio_blk_outhdr out;
+     */
     stb_p(&req->in->status, status);
+    /*
+     * 在以下使用VirtIOBlockReq->inhdr_undo:
+     *   - hw/block/virtio-blk.c|62| <<virtio_blk_req_complete>> iov_discard_undo(&req->inhdr_undo);
+     *   - hw/block/virtio-blk.c|867| <<virtio_blk_handle_request>> iov_discard_back_undoable(in_iov,
+     *                          &in_num, sizeof(struct virtio_blk_inhdr), &req->inhdr_undo);
+     *   - hw/block/virtio-blk.c|988| <<virtio_blk_handle_request>> iov_discard_undo(&req->inhdr_undo);
+     */
     iov_discard_undo(&req->inhdr_undo);
+    /*
+     * 在以下使用VirtIOBlockReq->outhdr_undo:
+     *   - hw/block/virtio-blk.c|112| <<virtio_blk_req_complete>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|964| <<virtio_blk_handle_request>> iov_discard_front_undoable(&out_iov,
+     *                           &out_num, sizeof(req->out), &req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|968| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|1100| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     */
     iov_discard_undo(&req->outhdr_undo);
     virtqueue_push(req->vq, &req->elem, req->in_len);
     if (qemu_in_iothread()) {
@@ -69,6 +159,12 @@ void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
     }
 }
 
+/*
+ * 在以下使用virtio_blk_handle_rw_error():
+ *   - hw/block/virtio-blk.c|133| <<virtio_blk_rw_complete>> if (virtio_blk_handle_rw_error(req, -ret, is_read, true)) {
+ *   - hw/block/virtio-blk.c|149| <<virtio_blk_flush_complete>> if (ret && virtio_blk_handle_rw_error(req, -ret, 0, true)) {
+ *   - hw/block/virtio-blk.c|165| <<virtio_blk_discard_write_zeroes_complete>> if (ret && virtio_blk_handle_rw_error(req, -ret, false, is_write_zeroes)) {
+ */
 static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
     bool is_read, bool acct_failed)
 {
@@ -76,6 +172,13 @@ static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
     BlockErrorAction action = blk_get_error_action(s->blk, is_read, error);
 
     if (action == BLOCK_ERROR_ACTION_STOP) {
+        /*
+	 * 在以下使用VirtIOBlockReq->mr_next:
+	 *   - hw/block/virtio-blk.c|51| <<virtio_blk_init_request>> req->mr_next = NULL;
+	 *   - hw/block/virtio-blk.c|81| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+	 *   - hw/block/virtio-blk.c|112| <<virtio_blk_rw_complete>> next = req->mr_next;
+	 *   - hw/block/virtio-blk.c|253| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+	 */
         /* Break the link as the next request is going to be parsed from the
          * ring again. Otherwise we may end up doing a double completion! */
         req->mr_next = NULL;
@@ -96,6 +199,13 @@ static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
     return action != BLOCK_ERROR_ACTION_IGNORE;
 }
 
+/*
+ * 在以下使用virtio_blk_rw_complete():
+ *   - hw/block/virtio-blk.c|266| <<submit_requests>> blk_aio_pwritev(blk, sector_num << BDRV_SECTOR_BITS, qiov,
+ *        flags, virtio_blk_rw_complete, mrb->reqs[start]);
+ *   - hw/block/virtio-blk.c|270| <<submit_requests>> blk_aio_preadv(blk, sector_num << BDRV_SECTOR_BITS, qiov,
+ *        flags, virtio_blk_rw_complete, mrb->reqs[start]);
+ */
 static void virtio_blk_rw_complete(void *opaque, int ret)
 {
     VirtIOBlockReq *next = opaque;
@@ -104,9 +214,20 @@ static void virtio_blk_rw_complete(void *opaque, int ret)
 
     while (next) {
         VirtIOBlockReq *req = next;
+        /*
+	 * 在以下使用VirtIOBlockReq->mr_next:
+	 *   - hw/block/virtio-blk.c|51| <<virtio_blk_init_request>> req->mr_next = NULL;
+	 *   - hw/block/virtio-blk.c|81| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+	 *   - hw/block/virtio-blk.c|112| <<virtio_blk_rw_complete>> next = req->mr_next;
+	 *   - hw/block/virtio-blk.c|253| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+	 */
         next = req->mr_next;
         trace_virtio_blk_rw_complete(vdev, req, ret);
 
+	/*
+	 * VirtIOBlockReq *req:
+	 * -> QEMUIOVector qiov;
+	 */
         if (req->qiov.nalloc != -1) {
             /* If nalloc is != -1 req->qiov is a local copy of the original
              * external iovec. It was allocated in submit_requests to be
@@ -125,6 +246,13 @@ static void virtio_blk_rw_complete(void *opaque, int ret)
              * the memory until the request is completed (which will
              * happen on the other side of the migration).
              */
+            /*
+	     * 在以下使用virtio_blk_handle_rw_error():
+	     *   - hw/block/virtio-blk.c|133| <<virtio_blk_rw_complete>> if (virtio_blk_handle_rw_error(req, -ret, is_read, true)) {
+	     *   - hw/block/virtio-blk.c|149| <<virtio_blk_flush_complete>> if (ret && virtio_blk_handle_rw_error(req, -ret, 0, true)) {
+	     *   - hw/block/virtio-blk.c|165| <<virtio_blk_discard_write_zeroes_complete>> if (ret && virtio_blk_handle_rw_error(req,
+	     *        -ret, false, is_write_zeroes)) {
+	     */
             if (virtio_blk_handle_rw_error(req, -ret, is_read, true)) {
                 continue;
             }
@@ -141,6 +269,13 @@ static void virtio_blk_flush_complete(void *opaque, int ret)
     VirtIOBlockReq *req = opaque;
     VirtIOBlock *s = req->dev;
 
+    /*
+     * 在以下使用virtio_blk_handle_rw_error():
+     *   - hw/block/virtio-blk.c|133| <<virtio_blk_rw_complete>> if (virtio_blk_handle_rw_error(req, -ret, is_read, true)) {
+     *   - hw/block/virtio-blk.c|149| <<virtio_blk_flush_complete>> if (ret && virtio_blk_handle_rw_error(req, -ret, 0, true)) {
+     *   - hw/block/virtio-blk.c|165| <<virtio_blk_discard_write_zeroes_complete>> if (ret && virtio_blk_handle_rw_error(req,
+     *        -ret, false, is_write_zeroes)) {
+     */
     if (ret && virtio_blk_handle_rw_error(req, -ret, 0, true)) {
         return;
     }
@@ -157,6 +292,13 @@ static void virtio_blk_discard_write_zeroes_complete(void *opaque, int ret)
     bool is_write_zeroes = (virtio_ldl_p(VIRTIO_DEVICE(s), &req->out.type) &
                             ~VIRTIO_BLK_T_BARRIER) == VIRTIO_BLK_T_WRITE_ZEROES;
 
+    /*
+     * 在以下使用virtio_blk_handle_rw_error():
+     *   - hw/block/virtio-blk.c|133| <<virtio_blk_rw_complete>> if (virtio_blk_handle_rw_error(req, -ret, is_read, true)) {
+     *   - hw/block/virtio-blk.c|149| <<virtio_blk_flush_complete>> if (ret && virtio_blk_handle_rw_error(req, -ret, 0, true)) {
+     *   - hw/block/virtio-blk.c|165| <<virtio_blk_discard_write_zeroes_complete>> if (ret && virtio_blk_handle_rw_error(req,
+     *        -ret, false, is_write_zeroes)) {
+     */
     if (ret && virtio_blk_handle_rw_error(req, -ret, false, is_write_zeroes)) {
         return;
     }
@@ -168,8 +310,16 @@ static void virtio_blk_discard_write_zeroes_complete(void *opaque, int ret)
     g_free(req);
 }
 
+/*
+ * 在以下使用virtio_blk_get_request():
+ *   - hw/block/virtio-blk.c|1034| <<virtio_blk_handle_vq>> while ((req = virtio_blk_get_request(s, vq))) {
+ */
 static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s, VirtQueue *vq)
 {
+    /*
+     * 89 typedef struct VirtIOBlockReq {
+     * 90     VirtQueueElement elem;
+     */
     VirtIOBlockReq *req = virtqueue_pop(vq, sizeof(VirtIOBlockReq));
 
     if (req) {
@@ -213,6 +363,43 @@ fail:
     g_free(req);
 }
 
+/*
+ * 没有iothread应该就是mainloop
+ * (gdb) bt
+ * #0  coroutine_pool_get_local () at ../util/qemu-coroutine.c:116
+ * #1  0x00005555561cb785 in coroutine_pool_get () at ../util/qemu-coroutine.c:181
+ * #2  0x00005555561cb8c7 in qemu_coroutine_create (entry=0x5555560034f4 <blk_aio_write_entry>, opaque=0x5555582fd4d0)
+ *     at ../util/qemu-coroutine.c:222
+ * #3  0x00005555560033cc in blk_aio_prwv (blk=0x55555846f060, offset=540709888, bytes=1024, iobuf=0x5555577f63e8,
+ *     co_entry=0x5555560034f4 <blk_aio_write_entry>, flags=BDRV_REQ_REGISTERED_BUF, 
+ *     cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350) at ../block/block-backend.c:1600
+ * #4  0x0000555556003927 in blk_aio_pwritev (blk=0x55555846f060, offset=540709888, qiov=0x5555577f63e8,
+ *     flags=BDRV_REQ_REGISTERED_BUF, cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350)
+ *     at ../block/block-backend.c:1722
+ * #5  0x0000555555e2c003 in submit_requests (s=0x5555584688c0, mrb=0x7fffffffd640, start=0, num_reqs=1, niov=-1) at ../hw/block/virtio-blk.c:259
+ * #6  0x0000555555e2c12f in virtio_blk_submit_multireq (s=0x5555584688c0, mrb=0x7fffffffd640) at ../hw/block/virtio-blk.c:294
+ * #7  0x0000555555e2e065 in virtio_blk_handle_vq (s=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1008
+ * #8  0x0000555555e2e0f8 in virtio_blk_handle_output (vdev=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1028
+ * #9  0x0000555555e89d02 in virtio_queue_notify_vq (vq=0x5555584b0960) at ../hw/virtio/virtio.c:2484
+ * #10 0x0000555555e8d53c in virtio_queue_host_notifier_read (n=0x5555584b09d4) at ../hw/virtio/virtio.c:3869
+ * #11 0x00005555561a74d8 in aio_dispatch_handler (ctx=0x55555745ee50, node=0x7fffe43dfba0) at ../util/aio-posix.c:376
+ * #12 0x00005555561a76ed in aio_dispatch_handlers (ctx=0x55555745ee50) at ../util/aio-posix.c:427
+ * #13 0x00005555561a7749 in aio_dispatch (ctx=0x55555745ee50) at ../util/aio-posix.c:437
+ * #14 0x00005555561c9148 in aio_ctx_dispatch (source=0x55555745ee50, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #15 0x00007ffff6fd394b in g_main_dispatch (context=0x55555745f260) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x55555745f260) at ../glib/gmain.c:4043
+ * #17 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=657614) at ../util/main-loop.c:310
+ * #19 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #21 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x00005555560d296f in main (argc=25, argv=0x7fffffffdb28) at ../system/main.c:80
+ *
+ * called by:
+ *   - hw/block/virtio-blk.c|294| <<virtio_blk_submit_multireq>> submit_requests(s, mrb, 0, 1, -1);
+ *   - hw/block/virtio-blk.c|318| <<virtio_blk_submit_multireq>> submit_requests(s, mrb, start, num_reqs, niov);
+ *   - hw/block/virtio-blk.c|334| <<virtio_blk_submit_multireq>> submit_requests(s, mrb, start, num_reqs, niov);
+ */
 static inline void submit_requests(VirtIOBlock *s, MultiReqBuffer *mrb,
                                    int start, int num_reqs, int niov)
 {
@@ -239,6 +426,13 @@ static inline void submit_requests(VirtIOBlock *s, MultiReqBuffer *mrb,
         for (i = start + 1; i < start + num_reqs; i++) {
             qemu_iovec_concat(qiov, &mrb->reqs[i]->qiov, 0,
                               mrb->reqs[i]->qiov.size);
+	    /*
+	     * 在以下使用VirtIOBlockReq->mr_next:
+	     *   - hw/block/virtio-blk.c|51| <<virtio_blk_init_request>> req->mr_next = NULL;
+	     *   - hw/block/virtio-blk.c|81| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+	     *   - hw/block/virtio-blk.c|112| <<virtio_blk_rw_complete>> next = req->mr_next;
+	     *   - hw/block/virtio-blk.c|253| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+	     */
             mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
         }
 
@@ -284,6 +478,13 @@ static int multireq_compare(const void *a, const void *b)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|349| <<virtio_blk_handle_flush>> virtio_blk_submit_multireq(s, mrb);
+ *   - hw/block/virtio-blk.c|866| <<virtio_blk_handle_request>> virtio_blk_submit_multireq(s, mrb);
+ *   - hw/block/virtio-blk.c|1008| <<virtio_blk_handle_vq>> virtio_blk_submit_multireq(s, &mrb);
+ *   - hw/block/virtio-blk.c|1056| <<virtio_blk_dma_restart_bh>> virtio_blk_submit_multireq(s, &mrb);
+ */
 static void virtio_blk_submit_multireq(VirtIOBlock *s, MultiReqBuffer *mrb)
 {
     int i = 0, start = 0, num_reqs = 0, niov = 0, nb_sectors = 0;
@@ -302,6 +503,23 @@ static void virtio_blk_submit_multireq(VirtIOBlock *s, MultiReqBuffer *mrb)
           &multireq_compare);
 
     for (i = 0; i < mrb->num_reqs; i++) {
+        /*
+	 * typedef struct VirtIOBlockReq {
+	 *     VirtQueueElement elem;
+	 *     int64_t sector_num;
+	 *     VirtIOBlock *dev;
+	 *     VirtQueue *vq;
+	 *     IOVDiscardUndo inhdr_undo;
+	 *     IOVDiscardUndo outhdr_undo;
+	 *     struct virtio_blk_inhdr *in;
+	 *     struct virtio_blk_outhdr out;
+	 *     QEMUIOVector qiov;
+	 *     size_t in_len;
+	 *     struct VirtIOBlockReq *next;
+	 *     struct VirtIOBlockReq *mr_next;
+	 *     BlockAcctCookie acct;
+	 * } VirtIOBlockReq;
+	 */
         VirtIOBlockReq *req = mrb->reqs[i];
         if (num_reqs > 0) {
             /*
@@ -348,9 +566,28 @@ static void virtio_blk_handle_flush(VirtIOBlockReq *req, MultiReqBuffer *mrb)
     if (mrb->is_write && mrb->num_reqs > 0) {
         virtio_blk_submit_multireq(s, mrb);
     }
+    /*
+     * 在以下使用blk_aio_flush():
+     *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+     *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+     *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+     *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+     *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+     *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+     *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+     *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+     */
     blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|550| <<virtio_blk_handle_discard_write_zeroes>> if (unlikely(!virtio_blk_sect_range_ok(s, sector, bytes))) {
+ *   - hw/block/virtio-blk.c|1011| <<virtio_blk_handle_request>> if (!virtio_blk_sect_range_ok(s, req->sector_num, req->qiov.size)) {
+ */
 static bool virtio_blk_sect_range_ok(VirtIOBlock *dev,
                                      uint64_t sector, size_t size)
 {
@@ -788,9 +1025,20 @@ out:
     return err_status;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|995| <<virtio_blk_handle_vq>> if (virtio_blk_handle_request(req, &mrb)) {
+ *   - hw/block/virtio-blk.c|1040| <<virtio_blk_dma_restart_bh>> if (virtio_blk_handle_request(req, &mrb)) {
+ */
 static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
 {
     uint32_t type;
+    /*
+     * VirtIOBlockReq *req:
+     * -> VirtQueueElement elem;
+     * -> struct virtio_blk_inhdr *in;
+     * -> struct virtio_blk_outhdr out;
+     */
     struct iovec *in_iov = req->elem.in_sg;
     struct iovec *out_iov = req->elem.out_sg;
     unsigned in_num = req->elem.in_num;
@@ -809,11 +1057,30 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
         return -1;
     }
 
+    /*
+     * 在以下使用VirtIOBlockReq->outhdr_undo:
+     *   - hw/block/virtio-blk.c|112| <<virtio_blk_req_complete>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|964| <<virtio_blk_handle_request>> iov_discard_front_undoable(&out_iov,
+     *                           &out_num, sizeof(req->out), &req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|968| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|1100| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     *
+     * 似乎是从out_iov中把header的部分去掉?
+     * 更新了out_iov
+     */
     iov_discard_front_undoable(&out_iov, &out_num, sizeof(req->out),
                                &req->outhdr_undo);
 
     if (in_iov[in_num - 1].iov_len < sizeof(struct virtio_blk_inhdr)) {
         virtio_error(vdev, "virtio-blk request inhdr too short");
+        /*
+	 * 在以下使用VirtIOBlockReq->outhdr_undo:
+	 *   - hw/block/virtio-blk.c|112| <<virtio_blk_req_complete>> iov_discard_undo(&req->outhdr_undo);
+	 *   - hw/block/virtio-blk.c|964| <<virtio_blk_handle_request>> iov_discard_front_undoable(&out_iov,
+	 *                           &out_num, sizeof(req->out), &req->outhdr_undo);
+	 *   - hw/block/virtio-blk.c|968| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+	 *   - hw/block/virtio-blk.c|1100| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+	 */
         iov_discard_undo(&req->outhdr_undo);
         return -1;
     }
@@ -826,6 +1093,12 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
     iov_discard_back_undoable(in_iov, &in_num, sizeof(struct virtio_blk_inhdr),
                               &req->inhdr_undo);
 
+    /*
+     * VirtIOBlockReq *req:
+     * -> VirtQueueElement elem;
+     * -> struct virtio_blk_inhdr *in;
+     * -> struct virtio_blk_outhdr out;
+     */
     type = virtio_ldl_p(vdev, &req->out.type);
 
     /* VIRTIO_BLK_T_OUT defines the command direction. VIRTIO_BLK_T_BARRIER
@@ -837,6 +1110,10 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
         bool is_write = type & VIRTIO_BLK_T_OUT;
         req->sector_num = virtio_ldq_p(vdev, &req->out.sector);
 
+        /*
+	 * VirtIOBlockReq *req:
+	 * -> QEMUIOVector qiov;
+	 */
         if (is_write) {
             qemu_iovec_init_external(&req->qiov, out_iov, out_num);
             trace_virtio_blk_handle_write(vdev, req, req->sector_num,
@@ -858,14 +1135,33 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
         block_acct_start(blk_get_stats(s->blk), &req->acct, req->qiov.size,
                          is_write ? BLOCK_ACCT_WRITE : BLOCK_ACCT_READ);
 
+        /*
+	 * 在以下使用VirtIOBlkConf->request_merging:
+	 *   - hw/block/virtio-blk.c|2054| <<global>> DEFINE_PROP_BIT("request-merging", VirtIOBlock, conf.request_merging, 0,
+	 *   - hw/block/virtio-blk.c|1026| <<virtio_blk_handle_request>> if (...!s->conf.request_merging)) {
+	 */
         /* merge would exceed maximum number of requests or IO direction
          * changes */
         if (mrb->num_reqs > 0 && (mrb->num_reqs == VIRTIO_BLK_MAX_MERGE_REQS ||
                                   is_write != mrb->is_write ||
                                   !s->conf.request_merging)) {
+            /*
+	     * called by:
+	     *   - hw/block/virtio-blk.c|349| <<virtio_blk_handle_flush>> virtio_blk_submit_multireq(s, mrb);
+	     *   - hw/block/virtio-blk.c|866| <<virtio_blk_handle_request>> virtio_blk_submit_multireq(s, mrb);
+	     *   - hw/block/virtio-blk.c|1008| <<virtio_blk_handle_vq>> virtio_blk_submit_multireq(s, &mrb);
+	     *   - hw/block/virtio-blk.c|1056| <<virtio_blk_dma_restart_bh>> virtio_blk_submit_multireq(s, &mrb);
+	     */
             virtio_blk_submit_multireq(s, mrb);
         }
 
+        /*
+	 * typedef struct MultiReqBuffer {
+	 *     VirtIOBlockReq *reqs[VIRTIO_BLK_MAX_MERGE_REQS];
+	 *     unsigned int num_reqs;
+	 *     bool is_write;
+	 * } MultiReqBuffer;
+	 */
         assert(mrb->num_reqs < VIRTIO_BLK_MAX_MERGE_REQS);
         mrb->reqs[mrb->num_reqs++] = req;
         mrb->is_write = is_write;
@@ -946,6 +1242,14 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
         if (unlikely(iov_to_buf(out_iov, out_num, 0, &dwz_hdr,
                                 sizeof(dwz_hdr)) != sizeof(dwz_hdr))) {
             iov_discard_undo(&req->inhdr_undo);
+	    /*
+	     * 在以下使用VirtIOBlockReq->outhdr_undo:
+	     *   - hw/block/virtio-blk.c|112| <<virtio_blk_req_complete>> iov_discard_undo(&req->outhdr_undo);
+	     *   - hw/block/virtio-blk.c|964| <<virtio_blk_handle_request>> iov_discard_front_undoable(&out_iov,
+	     *                           &out_num, sizeof(req->out), &req->outhdr_undo);
+	     *   - hw/block/virtio-blk.c|968| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+	     *   - hw/block/virtio-blk.c|1100| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+	     */
             iov_discard_undo(&req->outhdr_undo);
             virtio_error(vdev, "virtio-blk discard/write_zeroes header"
                          " too short");
@@ -968,6 +1272,10 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
          * class lookup is not in the hot path.
          */
         VirtIOBlkClass *vbk = VIRTIO_BLK_GET_CLASS(s);
+        /*
+	 * 只有hw/vmapple/virtio-blk.c实现了:
+	 * vbk->handle_unknown_request = vmapple_virtio_blk_handle_unknown_request;
+	 */
         if (!vbk->handle_unknown_request ||
             !vbk->handle_unknown_request(req, mrb, type)) {
             virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
@@ -978,6 +1286,41 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
     return 0;
 }
 
+/*
+ * 没有iothread应该就是mainloop
+ * (gdb) bt
+ * #0  coroutine_pool_get_local () at ../util/qemu-coroutine.c:116
+ * #1  0x00005555561cb785 in coroutine_pool_get () at ../util/qemu-coroutine.c:181
+ * #2  0x00005555561cb8c7 in qemu_coroutine_create (entry=0x5555560034f4 <blk_aio_write_entry>, opaque=0x5555582fd4d0)
+ *     at ../util/qemu-coroutine.c:222
+ * #3  0x00005555560033cc in blk_aio_prwv (blk=0x55555846f060, offset=540709888, bytes=1024, iobuf=0x5555577f63e8,
+ *     co_entry=0x5555560034f4 <blk_aio_write_entry>, flags=BDRV_REQ_REGISTERED_BUF, 
+ *     cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350) at ../block/block-backend.c:1600
+ * #4  0x0000555556003927 in blk_aio_pwritev (blk=0x55555846f060, offset=540709888, qiov=0x5555577f63e8,
+ *     flags=BDRV_REQ_REGISTERED_BUF, cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350)
+ *     at ../block/block-backend.c:1722
+ * #5  0x0000555555e2c003 in submit_requests (s=0x5555584688c0, mrb=0x7fffffffd640, start=0, num_reqs=1, niov=-1) at ../hw/block/virtio-blk.c:259
+ * #6  0x0000555555e2c12f in virtio_blk_submit_multireq (s=0x5555584688c0, mrb=0x7fffffffd640) at ../hw/block/virtio-blk.c:294
+ * #7  0x0000555555e2e065 in virtio_blk_handle_vq (s=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1008
+ * #8  0x0000555555e2e0f8 in virtio_blk_handle_output (vdev=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1028
+ * #9  0x0000555555e89d02 in virtio_queue_notify_vq (vq=0x5555584b0960) at ../hw/virtio/virtio.c:2484
+ * #10 0x0000555555e8d53c in virtio_queue_host_notifier_read (n=0x5555584b09d4) at ../hw/virtio/virtio.c:3869
+ * #11 0x00005555561a74d8 in aio_dispatch_handler (ctx=0x55555745ee50, node=0x7fffe43dfba0) at ../util/aio-posix.c:376
+ * #12 0x00005555561a76ed in aio_dispatch_handlers (ctx=0x55555745ee50) at ../util/aio-posix.c:427
+ * #13 0x00005555561a7749 in aio_dispatch (ctx=0x55555745ee50) at ../util/aio-posix.c:437
+ * #14 0x00005555561c9148 in aio_ctx_dispatch (source=0x55555745ee50, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #15 0x00007ffff6fd394b in g_main_dispatch (context=0x55555745f260) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x55555745f260) at ../glib/gmain.c:4043
+ * #17 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=657614) at ../util/main-loop.c:310
+ * #19 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #21 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x00005555560d296f in main (argc=25, argv=0x7fffffffdb28) at ../system/main.c:80
+ *
+ * 在以下使用virtio_blk_handle_vq():
+ *   - hw/block/virtio-blk.c|1068| <<virtio_blk_handle_output>> virtio_blk_handle_vq(s, vq);
+ */
 void virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
 {
     VirtIOBlockReq *req;
@@ -992,6 +1335,11 @@ void virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
         }
 
         while ((req = virtio_blk_get_request(s, vq))) {
+            /*
+	     * called by:
+	     *   - hw/block/virtio-blk.c|995| <<virtio_blk_handle_vq>> if (virtio_blk_handle_request(req, &mrb)) {
+	     *   - hw/block/virtio-blk.c|1040| <<virtio_blk_dma_restart_bh>> if (virtio_blk_handle_request(req, &mrb)) {
+	     */
             if (virtio_blk_handle_request(req, &mrb)) {
                 virtqueue_detach_element(req->vq, &req->elem, 0);
                 g_free(req);
@@ -1011,6 +1359,10 @@ void virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
     defer_call_end();
 }
 
+/*
+ * 在以下使用virtio_blk_handle_output():
+ *   - hw/block/virtio-blk.c|1826| <<virtio_blk_device_realize>> virtio_add_queue(vdev, conf->queue_size, virtio_blk_handle_output);
+ */
 static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBlock *s = (VirtIOBlock *)vdev;
@@ -1025,6 +1377,9 @@ static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
         }
     }
 
+    /*
+     * 只在此处调用
+     */
     virtio_blk_handle_vq(s, vq);
 }
 
@@ -1060,6 +1415,11 @@ static void virtio_blk_dma_restart_bh(void *opaque)
     blk_dec_in_flight(s->conf.conf.blk);
 }
 
+/*
+ * 在以下使用virtio_blk_dma_restart_cb():
+ *   - hw/block/virtio-blk.c|1805| <<virtio_blk_device_realize>>
+ *       s->change = qdev_add_vm_change_state_handler(dev, virtio_blk_dma_restart_cb, s);
+ */
 static void virtio_blk_dma_restart_cb(void *opaque, bool running,
                                       RunState state)
 {
@@ -1100,6 +1460,23 @@ static void virtio_blk_dma_restart_cb(void *opaque, bool running,
         /* Paired with dec in virtio_blk_dma_restart_bh() */
         blk_inc_in_flight(s->conf.conf.blk);
 
+        /*
+	 * 在以下使用VirtIOBlock->vq_aio_context (二维数组):
+	 *   - hw/block/virtio-blk.c|1368| <<virtio_blk_dma_restart_cb>> aio_bh_schedule_oneshot(s->vq_aio_context[i], virtio_blk_dma_restart_bh, vq_rq[i]);
+	 *   - hw/block/virtio-blk.c|1652| <<virtio_blk_ioeventfd_detach>> virtio_queue_aio_detach_host_notifier(vq, s->vq_aio_context[i]);
+	 *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>> virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+	 *   - hw/block/virtio-blk.c|1721| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = g_new(AioContext *, conf->num_queues);
+	 *   - hw/block/virtio-blk.c|1725| <<virtio_blk_vq_aio_context_init>> if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+	 *        s->vq_aio_context, conf->num_queues, errp)) {
+	 *   - hw/block/virtio-blk.c|1728| <<virtio_blk_vq_aio_context_init>> g_free(s->vq_aio_context);
+	 *   - hw/block/virtio-blk.c|1729| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = NULL;
+	 *   - hw/block/virtio-blk.c|1735| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+	 *   - hw/block/virtio-blk.c|1743| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+	 *   - hw/block/virtio-blk.c|1765| <<virtio_blk_vq_aio_context_cleanup>> g_free(s->vq_aio_context);
+	 *   - hw/block/virtio-blk.c|1766| <<virtio_blk_vq_aio_context_cleanup>> s->vq_aio_context = NULL;
+	 *   - hw/block/virtio-blk.c|1831| <<virtio_blk_start_ioeventfd>> r = blk_set_aio_context(s->conf.conf.blk, s->vq_aio_context[0], &local_err);
+	 *   - hw/block/virtio-blk.c|1910| <<virtio_blk_stop_ioeventfd>> AioContext *ctx = s->vq_aio_context[i];
+	 */
         aio_bh_schedule_oneshot(s->vq_aio_context[i],
                                 virtio_blk_dma_restart_bh,
                                 vq_rq[i]);
@@ -1388,12 +1765,28 @@ static void virtio_blk_ioeventfd_detach(VirtIOBlock *s)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|1682| <<virtio_blk_drained_end>> virtio_blk_ioeventfd_attach(s);
+ *   - hw/block/virtio-blk.c|1856| <<virtio_blk_start_ioeventfd>> virtio_blk_ioeventfd_attach(s);
+ */
 static void virtio_blk_ioeventfd_attach(VirtIOBlock *s)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
 
     for (uint16_t i = 0; i < s->conf.num_queues; i++) {
         VirtQueue *vq = virtio_get_queue(vdev, i);
+        /*
+	 * 在以下使用virtio_queue_aio_attach_host_notifier():
+	 *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>>
+	 *        virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+	 *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>>
+	 *        virtio_queue_aio_attach_host_notifier(vs->ctrl_vq, s->vq_aio_context[0]);
+	 *   - hw/scsi/virtio-scsi-dataplane.c|210| <<virtio_scsi_dataplane_start>>
+	 *        virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
+	 *   - hw/scsi/virtio-scsi.c|1250| <<virtio_scsi_drained_end>>
+	 *        virtio_queue_aio_attach_host_notifier(vq, ctx);
+	 */
         virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
     }
 }
@@ -1453,9 +1846,36 @@ static bool virtio_blk_vq_aio_context_init(VirtIOBlock *s, Error **errp)
         }
     }
 
+    /*
+     * 在以下使用VirtIOBlock->vq_aio_context (二维数组):
+     *   - hw/block/virtio-blk.c|1368| <<virtio_blk_dma_restart_cb>> aio_bh_schedule_oneshot(s->vq_aio_context[i], virtio_blk_dma_restart_bh, vq_rq[i]);
+     *   - hw/block/virtio-blk.c|1652| <<virtio_blk_ioeventfd_detach>> virtio_queue_aio_detach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>> virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1721| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = g_new(AioContext *, conf->num_queues);
+     *   - hw/block/virtio-blk.c|1725| <<virtio_blk_vq_aio_context_init>> if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+     *        s->vq_aio_context, conf->num_queues, errp)) {
+     *   - hw/block/virtio-blk.c|1728| <<virtio_blk_vq_aio_context_init>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1729| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = NULL;
+     *   - hw/block/virtio-blk.c|1735| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+     *   - hw/block/virtio-blk.c|1743| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+     *   - hw/block/virtio-blk.c|1765| <<virtio_blk_vq_aio_context_cleanup>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1766| <<virtio_blk_vq_aio_context_cleanup>> s->vq_aio_context = NULL;
+     *   - hw/block/virtio-blk.c|1831| <<virtio_blk_start_ioeventfd>> r = blk_set_aio_context(s->conf.conf.blk, s->vq_aio_context[0], &local_err);
+     *   - hw/block/virtio-blk.c|1910| <<virtio_blk_stop_ioeventfd>> AioContext *ctx = s->vq_aio_context[i];
+     */
     s->vq_aio_context = g_new(AioContext *, conf->num_queues);
 
     if (conf->iothread_vq_mapping_list) {
+        /*
+	 * 在以下调用iothread_vq_mapping_apply():
+	 *   - hw/block/virtio-blk.c|1740| <<virtio_blk_vq_aio_context_init>>
+	 *       if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+	 *                 s->vq_aio_context, conf->num_queues, errp)) {
+	 *   - hw/scsi/virtio-scsi-dataplane.c|68| <<virtio_scsi_dataplane_setup>>
+	 *       if (!iothread_vq_mapping_apply(vs->conf.iothread_vq_mapping_list,
+	 *                 &s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED],
+	 *                 vs->conf.num_queues, errp)) {
+	 */
         if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
                                        s->vq_aio_context,
                                        conf->num_queues,
@@ -1497,10 +1917,37 @@ static void virtio_blk_vq_aio_context_cleanup(VirtIOBlock *s)
         object_unref(OBJECT(conf->iothread));
     }
 
+    /*
+     * 在以下使用VirtIOBlock->vq_aio_context (二维数组):
+     *   - hw/block/virtio-blk.c|1368| <<virtio_blk_dma_restart_cb>> aio_bh_schedule_oneshot(s->vq_aio_context[i], virtio_blk_dma_restart_bh, vq_rq[i]);
+     *   - hw/block/virtio-blk.c|1652| <<virtio_blk_ioeventfd_detach>> virtio_queue_aio_detach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>> virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1721| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = g_new(AioContext *, conf->num_queues);
+     *   - hw/block/virtio-blk.c|1725| <<virtio_blk_vq_aio_context_init>> if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+     *        s->vq_aio_context, conf->num_queues, errp)) {
+     *   - hw/block/virtio-blk.c|1728| <<virtio_blk_vq_aio_context_init>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1729| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = NULL;
+     *   - hw/block/virtio-blk.c|1735| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+     *   - hw/block/virtio-blk.c|1743| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+     *   - hw/block/virtio-blk.c|1765| <<virtio_blk_vq_aio_context_cleanup>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1766| <<virtio_blk_vq_aio_context_cleanup>> s->vq_aio_context = NULL;
+     *   - hw/block/virtio-blk.c|1831| <<virtio_blk_start_ioeventfd>> r = blk_set_aio_context(s->conf.conf.blk, s->vq_aio_context[0], &local_err);
+     *   - hw/block/virtio-blk.c|1910| <<virtio_blk_stop_ioeventfd>> AioContext *ctx = s->vq_aio_context[i];
+     */
     g_free(s->vq_aio_context);
     s->vq_aio_context = NULL;
 }
 
+/*
+ * 在以下使用VirtioDeviceClass->start_ioeventfd:
+ *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+ *   - hw/scsi/virtio-scsi.c|1421| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+ *   - hw/virtio/virtio.c|4153| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+ *
+ * 在以下使用virtio_blk_start_ioeventfd():
+ *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+ */
 /* Context: BQL held */
 static int virtio_blk_start_ioeventfd(VirtIODevice *vdev)
 {
@@ -1611,6 +2058,18 @@ static void virtio_blk_ioeventfd_stop_vq_bh(void *opaque)
 
     virtio_queue_aio_detach_host_notifier(vq, qemu_get_current_aio_context());
 
+    /*
+     * 在以下使用virtio_queue_host_notifier_read():
+     *   - hw/block/virtio-blk.c|2065| <<virtio_blk_ioeventfd_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+     *   - hw/scsi/virtio-scsi-dataplane.c|149| <<virtio_scsi_dataplane_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+     *   - hw/virtio/virtio-bus.c|328| <<virtio_bus_cleanup_host_notifier>> virtio_queue_host_notifier_read(notifier);
+     *   - hw/virtio/virtio.c|3829| <<virtio_queue_aio_attach_host_notifier>> aio_set_event_notifier(ctx, &vq->host_notifier,
+     *        virtio_queue_host_notifier_read, virtio_queue_host_notifier_aio_poll, virtio_queue_host_notifier_aio_poll_ready);
+     *   - hw/virtio/virtio.c|3858| <<virtio_queue_aio_attach_host_notifier_no_poll>> aio_set_event_notifier(ctx,
+     *        &vq->host_notifier, virtio_queue_host_notifier_read, NULL, NULL);
+     *   - hw/virtio/virtio.c|4077| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier,
+     *        virtio_queue_host_notifier_read);
+     */
     /*
      * Test and clear notifier after disabling event, in case poll callback
      * didn't have time to run.
@@ -1767,6 +2226,13 @@ static void virtio_blk_device_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用virtio_blk_cfg_size_params:
+     *   - hw/block/vhost-user-blk.c|478| <<vhost_user_blk_device_realize>>
+     *        config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+     *   - hw/block/virtio-blk.c|1815| <<virtio_blk_device_realize>>
+     *        s->config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+     */
     s->config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
                                             s->host_features);
     virtio_init(vdev, VIRTIO_ID_BLOCK, s->config_size);
diff --git a/hw/char/serial.c b/hw/char/serial.c
index 70044e14a..472dd5e24 100644
--- a/hw/char/serial.c
+++ b/hw/char/serial.c
@@ -105,8 +105,22 @@
 static void serial_receive1(void *opaque, const uint8_t *buf, int size);
 static void serial_xmit(SerialState *s);
 
+/*
+ * called by:
+ *   - hw/char/serial.c|580| <<serial_receive_break>> recv_fifo_put(s, '\0');
+ *   - hw/char/serial.c|610| <<serial_receive1>> recv_fifo_put(s, buf[i]);
+ */
 static inline void recv_fifo_put(SerialState *s, uint8_t chr)
 {
+    /*
+     * typedef struct {
+     *     // All fields are private
+     *     uint8_t *data;
+     *     uint32_t capacity;
+     *     uint32_t head;
+     *     uint32_t num;
+     * } Fifo8;
+     */
     /* Receive overruns do not overwrite FIFO contents. */
     if (!fifo8_is_full(&s->recv_fifo)) {
         fifo8_push(&s->recv_fifo, chr);
@@ -115,6 +129,21 @@ static inline void recv_fifo_put(SerialState *s, uint8_t chr)
     }
 }
 
+/*
+ * called by:
+ *   - hw/char/serial.c|211| <<serial_update_msl>> serial_update_irq(s);
+ *   - hw/char/serial.c|251| <<serial_xmit>> serial_update_irq(s);
+ *   - hw/char/serial.c|357| <<serial_ioport_write>> serial_update_irq(s);
+ *   - hw/char/serial.c|403| <<serial_ioport_write>> serial_update_irq(s);
+ *   - hw/char/serial.c|429| <<serial_ioport_write>> serial_update_irq(s);
+ *   - hw/char/serial.c|494| <<serial_ioport_read>> serial_update_irq(s);
+ *   - hw/char/serial.c|512| <<serial_ioport_read>> serial_update_irq(s);
+ *   - hw/char/serial.c|526| <<serial_ioport_read>> serial_update_irq(s);
+ *   - hw/char/serial.c|543| <<serial_ioport_read>> serial_update_irq(s);
+ *   - hw/char/serial.c|582| <<serial_receive_break>> serial_update_irq(s);
+ *   - hw/char/serial.c|590| <<fifo_timeout_int>> serial_update_irq(s);
+ *   - hw/char/serial.c|621| <<serial_receive1>> serial_update_irq(s);
+ */
 static void serial_update_irq(SerialState *s)
 {
     uint8_t tmp_iir = UART_IIR_NO_INT;
@@ -145,6 +174,14 @@ static void serial_update_irq(SerialState *s)
     }
 }
 
+/*
+ * 在以下调用serial_update_parameters():
+ *   - hw/char/serial.c|344| <<serial_ioport_write>> serial_update_parameters(s);
+ *   - hw/char/serial.c|366| <<serial_ioport_write>> serial_update_parameters(s);
+ *   - hw/char/serial.c|435| <<serial_ioport_write>> serial_update_parameters(s);
+ *   - hw/char/serial.c|685| <<serial_post_load>> serial_update_parameters(s);
+ *   - hw/char/serial.c|901| <<serial_be_change>> serial_update_parameters(s);
+ */
 static void serial_update_parameters(SerialState *s)
 {
     float speed;
@@ -329,6 +366,42 @@ static void serial_update_tiocm(SerialState *s)
     qemu_chr_fe_ioctl(&s->chr, CHR_IOCTL_SERIAL_SET_TIOCM, &flags);
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_chr_write_buffer (s=0x55555750d400, buf=0x55555759aa0c "[", len=1, offset=0x7fffed23e1c0, write_all=false)
+ *     at ../chardev/char.c:115
+ * #1  0x00005555560c7c5e in qemu_chr_write (s=0x55555750d400, buf=0x55555759aa0c "[", len=1, write_all=false)
+ *     at ../chardev/char.c:186
+ * #2  0x00005555560bc2e5 in qemu_chr_fe_write (be=0x55555759aa28, buf=0x55555759aa0c "[", len=1)
+ *     at ../chardev/char-fe.c:41
+ * #3  0x0000555555965c20 in serial_xmit (s=0x55555759a970) at ../hw/char/serial.c:259
+ * #4  0x00005555559660b5 in serial_ioport_write (opaque=0x55555759a970, addr=0, val=91, size=1)
+ *     at ../hw/char/serial.c:359
+ * #5  0x0000555555eb8e96 in memory_region_write_accessor (mr=0x55555759aae0, addr=0, value=0x7fffed23e3a8, size=1,
+ *     shift=0, mask=255, attrs=...) at ../system/memory.c:497
+ * #6  0x0000555555eb91df in access_with_adjusted_size (addr=0, value=0x7fffed23e3a8, size=1, access_size_min=1,
+ *     access_size_max=1, access_fn=0x555555eb8da0 <memory_region_write_accessor>, mr=0x55555759aae0, attrs=...)
+ *     at ../system/memory.c:573
+ * #7  0x0000555555ebc9a2 in memory_region_dispatch_write (mr=0x55555759aae0, addr=0, data=91, op=MO_8, attrs=...)
+ *     at ../system/memory.c:1553
+ * #8  0x0000555555eccb5a in flatview_write_continue_step (attrs=..., buf=0x7ffff7fee000 "[", len=1, mr_addr=0,
+ *     l=0x7fffed23e490, mr=0x55555759aae0) at ../system/physmem.c:2951
+ * #9  0x0000555555eccc2f in flatview_write_continue (fv=0x7ffbd801c2c0, addr=1016, attrs=..., ptr=0x7ffff7fee000,
+ *     len=1, mr_addr=0, l=1, mr=0x55555759aae0) at ../system/physmem.c:2981
+ * #10 0x0000555555eccd5c in flatview_write (fv=0x7ffbd801c2c0, addr=1016, attrs=..., buf=0x7ffff7fee000, len=1)
+ *     at ../system/physmem.c:3012
+ * #11 0x0000555555ecd1e9 in address_space_write (as=0x555557383fc0 <address_space_io>, addr=1016, attrs=...,
+ *     buf=0x7ffff7fee000, len=1) at ../system/physmem.c:3132
+ * #12 0x0000555555ecd263 in address_space_rw (as=0x555557383fc0 <address_space_io>, addr=1016, attrs=...,
+ *     buf=0x7ffff7fee000, len=1, is_write=true) at ../system/physmem.c:3142
+ * #13 0x0000555555f0b7dd in kvm_handle_io (port=1016, attrs=..., data=0x7ffff7fee000, direction=1, size=1, count=1)
+ *     at ../accel/kvm/kvm-all.c:2800
+ * #14 0x0000555555f0c755 in kvm_cpu_exec (cpu=0x555557784610) at ../accel/kvm/kvm-all.c:3186
+ * #15 0x0000555555f0fecd in kvm_vcpu_thread_fn (arg=0x555557784610) at ../accel/kvm/kvm-accel-ops.c:51
+ * #16 0x00005555561ad4c6 in qemu_thread_start (args=0x55555778dd20) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #18 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 static void serial_ioport_write(void *opaque, hwaddr addr, uint64_t val,
                                 unsigned size)
 {
@@ -466,6 +539,35 @@ static void serial_ioport_write(void *opaque, hwaddr addr, uint64_t val,
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  serial_ioport_read (opaque=0x55555759a970, addr=1, size=1) at ../hw/char/serial.c:471
+ * #1  0x0000555555eb8b85 in memory_region_read_accessor (mr=0x55555759aae0, addr=1, value=0x7ffbdfdfe418, size=1, shift=0, mask=255,
+ *     attrs=...) at ../system/memory.c:445
+ * #2  0x0000555555eb91df in access_with_adjusted_size (addr=1, value=0x7ffbdfdfe418, size=1, access_size_min=1, access_size_max=1,
+ *     access_fn=0x555555eb8b3a <memory_region_read_accessor>, mr=0x55555759aae0, attrs=...) at ../system/memory.c:573
+ * #3  0x0000555555ebc539 in memory_region_dispatch_read1 (mr=0x55555759aae0, addr=1, pval=0x7ffbdfdfe418, size=1, attrs=...)
+ *     at ../system/memory.c:1458
+ * #4  0x0000555555ebc66c in memory_region_dispatch_read (mr=0x55555759aae0, addr=1, pval=0x7ffbdfdfe418, op=MO_8, attrs=...)
+ *     at ../system/memory.c:1491
+ * #5  0x0000555555ecce6e in flatview_read_continue_step (attrs=..., buf=0x7fffec239000 "", len=1, mr_addr=1, l=0x7ffbdfdfe490,
+ *     mr=0x55555759aae0) at ../system/physmem.c:3032
+ * #6  0x0000555555eccf6f in flatview_read_continue (fv=0x7ffbd83622b0, addr=1017, attrs=..., ptr=0x7fffec239000, len=1, mr_addr=1, l=1,
+ *     mr=0x55555759aae0) at ../system/physmem.c:3073
+ * #7  0x0000555555ecd09c in flatview_read (fv=0x7ffbd83622b0, addr=1017, attrs=..., buf=0x7fffec239000, len=1)
+ *     at ../system/physmem.c:3103
+ * #8  0x0000555555ecd13d in address_space_read_full (as=0x555557383fc0 <address_space_io>, addr=1017, attrs=..., buf=0x7fffec239000,
+ *     len=1) at ../system/physmem.c:3116
+ * #9  0x0000555555ecd284 in address_space_rw (as=0x555557383fc0 <address_space_io>, addr=1017, attrs=..., buf=0x7fffec239000, len=1,
+ *     is_write=false) at ../system/physmem.c:3144
+ * #10 0x0000555555f0b7dd in kvm_handle_io (port=1017, attrs=..., data=0x7fffec239000, direction=0, size=1, count=1)
+ *     at ../accel/kvm/kvm-all.c:2800
+ * #11 0x0000555555f0c755 in kvm_cpu_exec (cpu=0x555557798850) at ../accel/kvm/kvm-all.c:3186
+ * #12 0x0000555555f0fecd in kvm_vcpu_thread_fn (arg=0x555557798850) at ../accel/kvm/kvm-accel-ops.c:51
+ * #13 0x00005555561ad4c6 in qemu_thread_start (args=0x5555577a1de0) at ../util/qemu-thread-posix.c:541
+ * #14 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #15 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ */
 static uint64_t serial_ioport_read(void *opaque, hwaddr addr, unsigned size)
 {
     SerialState *s = opaque;
@@ -552,6 +654,23 @@ static uint64_t serial_ioport_read(void *opaque, hwaddr addr, unsigned size)
     return ret;
 }
 
+/*
+ * (gdb) bt
+ * #0  serial_can_receive (s=0x55555759a970) at ../hw/char/serial.c:557
+ * #1  0x00005555559669af in serial_can_receive1 (opaque=0x55555759a970) at ../hw/char/serial.c:597
+ * #2  0x00005555560c7d08 in qemu_chr_be_can_write (s=0x55555750d400) at ../chardev/char.c:206
+ * #3  0x00005555560cae4c in fd_chr_read_poll (opaque=0x55555750d400) at ../chardev/char-fd.c:83
+ * #4  0x00005555560bd37f in io_watch_poll_prepare (source=0x555558342690, timeout=0x7fffffffda04)
+ *     at ../chardev/char-io.c:48
+ * #5  0x00007ffff6fd30f7 in g_main_context_prepare (context=0x55555745e6a0, priority=0x5555573a2588 <max_priority>)
+ *     at ../glib/gmain.c:3645
+ * #6  0x00005555561ca7e4 in glib_pollfds_fill (cur_timeout=0x7fffffffdac8) at ../util/main-loop.c:259
+ * #7  0x00005555561ca97a in os_host_main_loop_wait (timeout=271798) at ../util/main-loop.c:300
+ * #8  0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #9  0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #10 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #11 0x00005555560d296f in main (argc=21, argv=0x7fffffffdc88) at ../system/main.c:80
+ */
 static int serial_can_receive(SerialState *s)
 {
     if(s->fcr & UART_FCR_FE) {
@@ -597,6 +716,26 @@ static int serial_can_receive1(void *opaque)
     return serial_can_receive(s);
 }
 
+/*
+ * (gdb) bt
+ * #0  serial_receive1 (opaque=0x55555759a970, buf=0x7fffffffc9d0 "k", size=1) at ../hw/char/serial.c:602
+ * #1  0x00005555560c7d61 in qemu_chr_be_write_impl (s=0x55555750d400, buf=0x7fffffffc9d0 "k", len=1)
+ *     at ../chardev/char.c:214
+ * #2  0x00005555560c7dd2 in qemu_chr_be_write (s=0x55555750d400, buf=0x7fffffffc9d0 "k", len=1)
+ *     at ../chardev/char.c:226
+ * #3  0x00005555560cadf1 in fd_chr_read (chan=0x55555745f730, cond=G_IO_IN, opaque=0x55555750d400)
+ *     at ../chardev/char-fd.c:72
+ * #4  0x0000555555f8f8d0 in qio_channel_fd_source_dispatch (source=0x5555582ecd80,
+ *     callback=0x5555560cac95 <fd_chr_read>, user_data=0x55555750d400) at ../io/channel-watch.c:84
+ * #5  0x00007ffff6fd3854 in g_main_dispatch (context=0x55555745e6a0) at ../glib/gmain.c:3325
+ * #6  g_main_context_dispatch (context=0x55555745e6a0) at ../glib/gmain.c:4043
+ * #7  0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #8  0x00005555561ca9c7 in os_host_main_loop_wait (timeout=962480) at ../util/main-loop.c:310
+ * #9  0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #10 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #11 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #12 0x00005555560d296f in main (argc=21, argv=0x7fffffffdc88) at ../system/main.c:80
+ */
 static void serial_receive1(void *opaque, const uint8_t *buf, int size)
 {
     SerialState *s = opaque;
@@ -930,6 +1069,9 @@ static void serial_realize(DeviceState *dev, Error **errp)
 
     qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,
                              serial_event, serial_be_change, s, NULL, true);
+    /*
+     * #define UART_FIFO_LENGTH 16
+     */
     fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);
     fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);
     serial_reset(s);
@@ -951,6 +1093,15 @@ static void serial_unrealize(DeviceState *dev)
     qemu_unregister_reset(serial_reset, s);
 }
 
+/*
+ * 在以下使用serial_io_ops:
+ *   - hw/char/diva-gsp.c|141| <<diva_pci_realize>> memory_region_init_io(&s->io, OBJECT(pci), &serial_io_ops, s,
+ *   - hw/char/serial-isa.c|83| <<serial_isa_realizefn>> memory_region_init_io(&s->io, OBJECT(isa), &serial_io_ops, s, "serial", 8);
+ *   - hw/char/serial-mm.c|36| <<serial_mm_read>> return serial_io_ops.read(&s->serial, addr >> s->regshift, 1);
+ *   - hw/char/serial-mm.c|44| <<serial_mm_write>> serial_io_ops.write(&s->serial, addr >> s->regshift, value, 1);
+ *   - hw/char/serial-pci-multi.c|113| <<multi_serial_pci_realize>> memory_region_init_io(&s->io, OBJECT(pci), &serial_io_ops, s,
+ *   - hw/char/serial-pci.c|60| <<serial_pci_realize>> memory_region_init_io(&s->io, OBJECT(pci), &serial_io_ops, s, "serial", 8);
+ */
 const MemoryRegionOps serial_io_ops = {
     .read = serial_ioport_read,
     .write = serial_ioport_write,
diff --git a/hw/core/cpu-common.c b/hw/core/cpu-common.c
index 9064dd24f..c7693ce7c 100644
--- a/hw/core/cpu-common.c
+++ b/hw/core/cpu-common.c
@@ -40,6 +40,20 @@ CPUState *cpu_by_arch_id(int64_t id)
     CPUState *cpu;
 
     CPU_FOREACH(cpu) {
+        /*
+	 * 在以下使用get_arch_id:
+	 *   - hw/acpi/cpu.c|239| <<get_cpu_status>> uint64_t cpu_arch_id = cpu->cc->get_arch_id(cpu);
+	 *   - hw/acpi/cpu_hotplug.c|67| <<acpi_set_cpu_present_bit>> cpu_id = cpu->cc->get_arch_id(cpu);
+         *   - hw/core/cpu-common.c|43| <<cpu_by_arch_id>> if (cpu->cc->get_arch_id(cpu) == id) {
+	 *   - hw/core/cpu-common.c|358| <<cpu_common_class_init>> k->get_arch_id = cpu_common_get_arch_id;
+	 *   - hw/intc/loongarch_extioi_common.c|19| <<loongarch_extioi_get_cpu>> uint64_t arch_id = k->get_arch_id(CPU(dev));
+	 *   - hw/intc/loongarch_ipi.c|56| <<loongarch_ipi_get_cpu>> uint64_t arch_id = k->get_arch_id(CPU(dev));
+	 *   - target/i386/cpu.c|8960| <<x86_cpu_common_class_init>> cc->get_arch_id = x86_cpu_get_arch_id;
+	 *   - target/loongarch/cpu.c|927| <<loongarch_cpu_class_init>> cc->get_arch_id = loongarch_cpu_get_arch_id;
+	 *   - target/riscv/cpu.c|3062| <<riscv_cpu_common_class_init>> cc->get_arch_id = riscv_get_arch_id;
+	 *
+	 * x86_cpu_get_arch_id()返回cpu->apic_id
+	 */
         if (cpu->cc->get_arch_id(cpu) == id) {
             return cpu;
         }
@@ -101,6 +115,9 @@ void cpu_dump_state(CPUState *cpu, FILE *f, int flags)
 {
     if (cpu->cc->dump_state) {
         cpu_synchronize_state(cpu);
+        /*
+	 * x86_cpu_dump_state
+	 */
         cpu->cc->dump_state(cpu, f, flags);
     }
 }
@@ -183,12 +200,37 @@ static void cpu_common_parse_features(const char *typename, char *features,
     }
 }
 
+/*
+ * 在以下使用cpu_exec_realizefn():
+ *   - target/alpha/cpu.c|106| <<alpha_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/arm/cpu.c|2080| <<arm_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/avr/cpu.c|116| <<avr_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/hexagon/cpu.c|300| <<hexagon_cpu_realize>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/hppa/cpu.c|182| <<hppa_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/i386/cpu.c|8189| <<x86_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/loongarch/cpu.c|640| <<loongarch_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/m68k/cpu.c|367| <<m68k_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/microblaze/cpu.c|243| <<mb_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/mips/cpu.c|479| <<mips_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/openrisc/cpu.c|162| <<openrisc_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/ppc/cpu_init.c|6929| <<ppc_cpu_realize>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/riscv/cpu.c|1287| <<riscv_cpu_realize>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/rx/cpu.c|138| <<rx_cpu_realize>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/s390x/cpu.c|252| <<s390_cpu_realizefn>> cpu_exec_realizefn(cs, &err);
+ *   - target/sh4/cpu.c|229| <<superh_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/sparc/cpu.c|890| <<sparc_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/tricore/cpu.c|92| <<tricore_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ *   - target/xtensa/cpu.c|174| <<xtensa_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+ */
 bool cpu_exec_realizefn(CPUState *cpu, Error **errp)
 {
     if (!accel_cpu_common_realize(cpu, errp)) {
         return false;
     }
 
+    /*
+     * 只在这里调用
+     */
     /* Wait until cpu initialization complete before exposing cpu. */
     cpu_list_add(cpu);
 
diff --git a/hw/core/machine.c b/hw/core/machine.c
index 63c6ef93d..064c232fe 100644
--- a/hw/core/machine.c
+++ b/hw/core/machine.c
@@ -1593,6 +1593,10 @@ static bool is_cpu_type_supported(const MachineState *machine, Error **errp)
     return true;
 }
 
+/*
+ * 在以下使用machine_run_board_init():
+ *   - system/vl.c|2711| <<qemu_init_board>> machine_run_board_init(current_machine, mem_path, &error_fatal);
+ */
 void machine_run_board_init(MachineState *machine, const char *mem_path, Error **errp)
 {
     ERRP_GUARD();
@@ -1679,6 +1683,10 @@ void machine_run_board_init(MachineState *machine, const char *mem_path, Error *
     }
 
     accel_init_interfaces(ACCEL_GET_CLASS(machine->accelerator));
+    /*
+     * 比如pc_q35_machine_7_2_init()
+     * 或者pc_q35_init()
+     */
     machine_class->init(machine);
     phase_advance(PHASE_MACHINE_INITIALIZED);
 }
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index 2745b5e09..dbebc1038 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -514,6 +514,15 @@ static void device_set_realized(Object *obj, bool value, Error **errp)
         }
 
         if (qdev_get_vmsd(dev)) {
+            /*
+	     * 在以下使用vmstate_register_with_alias_id():
+	     *   -  hw/core/qdev.c|517| <<device_set_realized>> if (vmstate_register_with_alias_id(VMSTATE_IF(dev),
+	     *              VMSTATE_INSTANCE_ID_ANY, qdev_get_vmsd(dev), dev, dev->instance_id_alias,
+	     *              dev->alias_required_for_version, &local_err) < 0) {
+	     *   - hw/intc/apic_common.c|303| <<apic_common_realize>> vmstate_register_with_alias_id(NULL, instance_id, &vmstate_apic_common, s, -1, 0, NULL);
+	     *   - include/migration/vmstate.h|1228| <<vmstate_register>> return vmstate_register_with_alias_id(obj, instance_id, vmsd, opaque, -1, 0, NULL);
+	     *   - include/migration/vmstate.h|1256| <<vmstate_register_any>> return vmstate_register_with_alias_id(obj, VMSTATE_INSTANCE_ID_ANY, vmsd, opaque, -1, 0, NULL);
+	     */
             if (vmstate_register_with_alias_id(VMSTATE_IF(dev),
                                                VMSTATE_INSTANCE_ID_ANY,
                                                qdev_get_vmsd(dev), dev,
diff --git a/hw/i2c/core.c b/hw/i2c/core.c
index 26bb18514..8cfabc62c 100644
--- a/hw/i2c/core.c
+++ b/hw/i2c/core.c
@@ -63,6 +63,22 @@ I2CBus *i2c_init_bus(DeviceState *parent, const char *name)
     bus = I2C_BUS(qbus_new(TYPE_I2C_BUS, parent, name));
     QLIST_INIT(&bus->current_devs);
     QSIMPLEQ_INIT(&bus->pending_masters);
+    /*
+     * 在以下使用vmstate_register_any():
+     *   - audio/audio.c|1787| <<audio_init>> vmstate_register_any(NULL, &vmstate_audio, s);
+     *   - backends/dbus-vmstate.c|429| <<dbus_vmstate_complete>> if (vmstate_register_any(VMSTATE_IF(self), &dbus_vmstate, self) < 0) {
+     *   - backends/tpm/tpm_emulator.c|1009| <<tpm_emulator_inst_init>> vmstate_register_any(NULL, &vmstate_tpm_emulator, obj);
+     *   - hw/display/vmware_vga.c|1265| <<vmsvga_init>> vmstate_register_any(NULL, &vmstate_vga_common, &s->vga);
+     *   - hw/i2c/core.c|66| <<i2c_init_bus>> vmstate_register_any(NULL, &vmstate_i2c_bus, bus);
+     *   - hw/ide/isa.c|76| <<isa_ide_realizefn>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_ide_isa, s);
+     *   - hw/input/adb.c|250| <<adb_bus_realize>> vmstate_register_any(NULL, &vmstate_adb_bus, adb_bus);
+     *   - hw/net/eepro100.c|1888| <<e100_nic_realize>> vmstate_register_any(VMSTATE_IF(&pci_dev->qdev), s->vmstate, s);
+     *   - hw/nvram/eeprom93xx.c|324| <<eeprom93xx_new>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_eeprom, eeprom);
+     *   - hw/pci/pci.c|178| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+     *   - hw/ppc/spapr_nvdimm.c|879| <<spapr_nvdimm_realize>> vmstate_register_any(NULL, &vmstate_spapr_nvdimm_states, dimm);
+     *   - hw/timer/arm_timer.c|184| <<arm_timer_init>> vmstate_register_any(NULL, &vmstate_arm_timer, s);
+     *   - hw/virtio/virtio-mem.c|1122| <<virtio_mem_device_realize>> vmstate_register_any(VMSTATE_IF(vmem), &vmstate_virtio_mem_device_early, vmem);
+     */
     vmstate_register_any(NULL, &vmstate_i2c_bus, bus);
     return bus;
 }
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 3fffa4a33..3f8d1acdb 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -273,6 +273,14 @@ static void acpi_get_misc_info(AcpiMiscInfo *info)
  * Because of the PXB hosts we cannot simply query TYPE_PCI_HOST_BRIDGE.
  * On i386 arch we only have two pci hosts, so we can look only for them.
  */
+/*
+ * 在以下使用acpi_get_i386_pci_host():
+ *   - hw/acpi/pcihp.c|136| <<acpi_set_pci_info>> Object *host = acpi_get_i386_pci_host();
+ *   - hw/i386/acpi-build.c|292| <<acpi_get_pci_holes>> pci_host = acpi_get_i386_pci_host();
+ *   - hw/i386/acpi-build.c|1801| <<build_dsdt>> Object *pci_host = acpi_get_i386_pci_host();
+ *   - hw/i386/acpi-build.c|1862| <<build_dsdt>> Object *pci_host = acpi_get_i386_pci_host();
+ *   - hw/i386/acpi-build.c|2502| <<acpi_get_mcfg>> pci_host = acpi_get_i386_pci_host();
+ */
 Object *acpi_get_i386_pci_host(void)
 {
     PCIHostState *host;
@@ -459,6 +467,10 @@ static Aml *aml_pci_static_endpoint_dsm(PCIDevice *pdev)
     return method;
 }
 
+/*
+ * 在以下使用build_append_pcihp_notify_entry():
+ *   - hw/i386/acpi-build.c|553| <<build_append_pcihp_slots>> build_append_pcihp_notify_entry(notify_method, slot);
+ */
 static void build_append_pcihp_notify_entry(Aml *method, int slot)
 {
     Aml *if_ctx;
@@ -647,6 +659,10 @@ static bool build_append_notfication_callback(Aml *parent_scope,
     return !!nr_notifiers;
 }
 
+/*
+ * 在以下使用aml_pci_pdsm():
+ *   - hw/i386/acpi-build.c|1281| <<build_x86_acpi_pci_hotplug>> aml_append(scope, aml_pci_pdsm());
+ */
 static Aml *aml_pci_pdsm(void)
 {
     Aml *method, *ifctx, *ifctx1;
@@ -1227,6 +1243,11 @@ static Aml *build_q35_dram_controller(const AcpiMcfgInfo *mcfg)
     return dev;
 }
 
+/*
+ * 在以下使用build_x86_acpi_pci_hotplug():
+ *   - hw/i386/acpi-build.c|1397| <<build_dsdt>> build_x86_acpi_pci_hotplug(dsdt, pm->pcihp_io_base);
+ *   - hw/i386/acpi-build.c|1441| <<build_dsdt>> build_x86_acpi_pci_hotplug(dsdt, pm->pcihp_io_base);
+ */
 static void build_x86_acpi_pci_hotplug(Aml *table, uint64_t pcihp_addr)
 {
     Aml *scope;
@@ -1350,6 +1371,83 @@ static void build_acpi0017(Aml *table)
     aml_append(table, scope);
 }
 
+/*
+ * 启动的时候触发两次, 一次创建QEMU, 一次从VM.
+ *
+ * (gdb) bt
+ * #0  build_dsdt (table_data=0x555557459ef0, linker=0x5555589cd0a0, pm=0x7fffffffd1f0, misc=0x7fffffffd188, pci_hole=0x7fffffffd1a0,
+ *     pci_hole64=0x7fffffffd1b0, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:1357
+ * #1  0x0000555555d894c5 in acpi_build (tables=0x7fffffffd310, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:2489
+ * #2  0x0000555555d8a122 in acpi_setup () at ../hw/i386/acpi-build.c:2717
+ * #3  0x0000555555d7bb31 in pc_machine_done (notifier=0x5555576d87c0, data=0x0) at ../hw/i386/pc.c:638
+ * #4  0x00005555561b6024 in notifier_list_notify (list=0x55555737b390 <machine_init_done_notifiers>, data=0x0) at ../util/notify.c:39
+ * #5  0x000055555597d9f4 in qdev_machine_creation_done () at ../hw/core/machine.c:1745
+ * #6  0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #7  0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #8  0x0000555555c38346 in qemu_init (argc=39, argv=0x7fffffffd6e8) at ../system/vl.c:3843
+ * #9  0x00005555560d2905 in main (argc=39, argv=0x7fffffffd6e8) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  build_dsdt (table_data=0x55555784f670, linker=0x7fffe478a670, pm=0x7fffedb7f0d0, misc=0x7fffedb7f068, pci_hole=0x7fffedb7f080,
+ *     pci_hole64=0x7fffedb7f090, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:1357
+ * #1  0x0000555555d894c5 in acpi_build (tables=0x7fffedb7f1e0, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:2489
+ * #2  0x0000555555d89f83 in acpi_build_update (build_opaque=0x5555578392b0) at ../hw/i386/acpi-build.c:2661
+ * #3  0x0000555555ac20fd in fw_cfg_select (s=0x555557922180, key=45) at ../hw/nvram/fw_cfg.c:285
+ * #4  0x0000555555ac2a75 in fw_cfg_comb_write (opaque=0x555557922180, addr=0, value=45, size=2) at ../hw/nvram/fw_cfg.c:509
+ * #5  0x0000555555eb8e96 in memory_region_write_accessor (mr=0x555557922640, addr=0, value=0x7fffedb7f3a8, size=2, shift=0,
+ *     mask=65535, attrs=...) at ../system/memory.c:497
+ * #6  0x0000555555eb91df in access_with_adjusted_size (addr=0, value=0x7fffedb7f3a8, size=2, access_size_min=1, access_size_max=4,
+ *     access_fn=0x555555eb8da0 <memory_region_write_accessor>, mr=0x555557922640, attrs=...) at ../system/memory.c:573
+ * #7  0x0000555555ebc9a2 in memory_region_dispatch_write (mr=0x555557922640, addr=0, data=45, op=MO_16, attrs=...) at ../system/memory.c:1553
+ * #8  0x0000555555eccb5a in flatview_write_continue_step (attrs=..., buf=0x7ffff7ff1000 "-", len=2, mr_addr=0, l=0x7fffedb7f490,
+ *     mr=0x555557922640) at ../system/physmem.c:2951
+ * #9  0x0000555555eccc2f in flatview_write_continue (fv=0x7fffe458a6e0, addr=1296, attrs=..., ptr=0x7ffff7ff1000, len=2, mr_addr=0, l=2,
+ *     mr=0x555557922640) at ../system/physmem.c:2981
+ * #10 0x0000555555eccd5c in flatview_write (fv=0x7fffe458a6e0, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2) at ../system/physmem.c:3012
+ * #11 0x0000555555ecd1e9 in address_space_write (as=0x555557383fc0 <address_space_io>, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2)
+ *     at ../system/physmem.c:3132
+ * #12 0x0000555555ecd263 in address_space_rw (as=0x555557383fc0 <address_space_io>, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2, is_write=true)
+ *     at ../system/physmem.c:3142
+ * #13 0x0000555555f0b7dd in kvm_handle_io (port=1296, attrs=..., data=0x7ffff7ff1000, direction=1, size=2, count=1) at ../accel/kvm/kvm-all.c:2800
+ * #14 0x0000555555f0c755 in kvm_cpu_exec (cpu=0x55555776e340) at ../accel/kvm/kvm-all.c:3186
+ * #15 0x0000555555f0fecd in kvm_vcpu_thread_fn (arg=0x55555776e340) at ../accel/kvm/kvm-accel-ops.c:51
+ * #16 0x00005555561ad4c6 in qemu_thread_start (args=0x555557778700) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #18 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * Reset的时候
+ *
+ * (gdb) bt
+ * #0  build_dsdt (table_data=0x7fffe42f2350, linker=0x7fffe4208b20, pm=0x7fffedb7f0d0, misc=0x7fffedb7f068,
+ *     pci_hole=0x7fffedb7f080, pci_hole64=0x7fffedb7f090, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:1357
+ * #1  0x0000555555d894c5 in acpi_build (tables=0x7fffedb7f1e0, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:2489
+ * #2  0x0000555555d89f83 in acpi_build_update (build_opaque=0x5555578392b0) at ../hw/i386/acpi-build.c:2661
+ * #3  0x0000555555ac20fd in fw_cfg_select (s=0x555557922180, key=45) at ../hw/nvram/fw_cfg.c:285
+ * #4  0x0000555555ac2a75 in fw_cfg_comb_write (opaque=0x555557922180, addr=0, value=45, size=2) at ../hw/nvram/fw_cfg.c:509
+ * #5  0x0000555555eb8e96 in memory_region_write_accessor (mr=0x555557922640, addr=0, value=0x7fffedb7f3a8, size=2,
+ *     shift=0, mask=65535, attrs=...) at ../system/memory.c:497
+ * #6  0x0000555555eb91df in access_with_adjusted_size (addr=0, value=0x7fffedb7f3a8, size=2, access_size_min=1,
+ *     access_size_max=4, access_fn=0x555555eb8da0 <memory_region_write_accessor>, mr=0x555557922640, attrs=...) at ../system/memory.c:573
+ * #7  0x0000555555ebc9a2 in memory_region_dispatch_write (mr=0x555557922640, addr=0, data=45, op=MO_16, attrs=...) at ../system/memory.c:1553
+ * #8  0x0000555555eccb5a in flatview_write_continue_step (attrs=..., buf=0x7ffff7ff1000 "-", len=2, mr_addr=0, l=0x7fffedb7f490,
+ *     mr=0x555557922640) at ../system/physmem.c:2951
+ * #9  0x0000555555eccc2f in flatview_write_continue (fv=0x7fffe4981f70, addr=1296, attrs=..., ptr=0x7ffff7ff1000, len=2, mr_addr=0,
+ *     l=2, mr=0x555557922640) at ../system/physmem.c:2981
+ * #10 0x0000555555eccd5c in flatview_write (fv=0x7fffe4981f70, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2) at ../system/physmem.c:3012
+ * #11 0x0000555555ecd1e9 in address_space_write (as=0x555557383fc0 <address_space_io>, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2)
+ *     at ../system/physmem.c:3132
+ * #12 0x0000555555ecd263 in address_space_rw (as=0x555557383fc0 <address_space_io>, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2, is_write=true)
+ *     at ../system/physmem.c:3142
+ * #13 0x0000555555f0b7dd in kvm_handle_io (port=1296, attrs=..., data=0x7ffff7ff1000, direction=1, size=2, count=1) at ../accel/kvm/kvm-all.c:2800
+ * #14 0x0000555555f0c755 in kvm_cpu_exec (cpu=0x55555776e340) at ../accel/kvm/kvm-all.c:3186
+ * #15 0x0000555555f0fecd in kvm_vcpu_thread_fn (arg=0x55555776e340) at ../accel/kvm/kvm-accel-ops.c:51
+ * #16 0x00005555561ad4c6 in qemu_thread_start (args=0x555557778700) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #18 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用build_dsdt():
+ *   - hw/i386/acpi-build.c|2489| <<acpi_build>> build_dsdt(tables_blob, tables->linker, &pm, &misc, &pci_hole, &pci_hole64, machine);
+ */
 static void
 build_dsdt(GArray *table_data, BIOSLinker *linker,
            AcpiPmInfo *pm, AcpiMiscInfo *misc,
@@ -2431,6 +2529,11 @@ static bool acpi_get_mcfg(AcpiMcfgInfo *mcfg)
     return true;
 }
 
+/*
+ * 在以下使用acpi_build():
+ *   - hw/i386/acpi-build.c|2686| <<acpi_build_update>> acpi_build(&tables, MACHINE(qdev_get_machine()));
+ *   - hw/i386/acpi-build.c|2764| <<acpi_setup>> acpi_build(&tables, MACHINE(pcms));
+ */
 static
 void acpi_build(AcpiBuildTables *tables, MachineState *machine)
 {
@@ -2634,10 +2737,29 @@ void acpi_build(AcpiBuildTables *tables, MachineState *machine)
     g_free(slic_oem.table_id);
 }
 
+/*
+ * 在以下调用arm的acpi_ram_update():
+ *   - hw/arm/virt-acpi-build.c|1064| <<virt_acpi_build_update>> acpi_ram_update(build_state->table_mr, tables.table_data);
+ *   - hw/arm/virt-acpi-build.c|1065| <<virt_acpi_build_update>> acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
+ *   - hw/arm/virt-acpi-build.c|1066| <<virt_acpi_build_update>> acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
+ *
+ * 在以下调用i386的acpi_ram_update():
+ *   - hw/i386/acpi-build.c|2671| <<acpi_build_update>> acpi_ram_update(build_state->table_mr, tables.table_data);
+ *   - hw/i386/acpi-build.c|2673| <<acpi_build_update>> acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
+ *   - hw/i386/acpi-build.c|2675| <<acpi_build_update>> acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
+ */
 static void acpi_ram_update(MemoryRegion *mr, GArray *data)
 {
     uint32_t size = acpi_data_len(data);
 
+    /*
+     * 在以下调用memory_region_ram_resize():
+     *   - hw/arm/virt-acpi-build.c|1035| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/i386/acpi-build.c|2642| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/loongarch/virt-acpi-build.c|644| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/nvram/fw_cfg.c|631| <<fw_cfg_update_mr>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/riscv/virt-acpi-build.c|746| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     */
     /* Make sure RAM size is correct - in case it got changed e.g. by migration */
     memory_region_ram_resize(mr, size, &error_abort);
 
@@ -2645,9 +2767,111 @@ static void acpi_ram_update(MemoryRegion *mr, GArray *data)
     memory_region_set_dirty(mr, 0, size);
 }
 
+/*
+ * 启动的时候触发两次, 一次创建QEMU, 一次从VM.
+ *
+ * (gdb) bt
+ * #0  build_dsdt (table_data=0x555557459ef0, linker=0x5555589cd0a0, pm=0x7fffffffd1f0, misc=0x7fffffffd188, pci_hole=0x7fffffffd1a0,
+ *     pci_hole64=0x7fffffffd1b0, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:1357
+ * #1  0x0000555555d894c5 in acpi_build (tables=0x7fffffffd310, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:2489
+ * #2  0x0000555555d8a122 in acpi_setup () at ../hw/i386/acpi-build.c:2717
+ * #3  0x0000555555d7bb31 in pc_machine_done (notifier=0x5555576d87c0, data=0x0) at ../hw/i386/pc.c:638
+ * #4  0x00005555561b6024 in notifier_list_notify (list=0x55555737b390 <machine_init_done_notifiers>, data=0x0) at ../util/notify.c:39
+ * #5  0x000055555597d9f4 in qdev_machine_creation_done () at ../hw/core/machine.c:1745
+ * #6  0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #7  0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #8  0x0000555555c38346 in qemu_init (argc=39, argv=0x7fffffffd6e8) at ../system/vl.c:3843
+ * #9  0x00005555560d2905 in main (argc=39, argv=0x7fffffffd6e8) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  build_dsdt (table_data=0x55555784f670, linker=0x7fffe478a670, pm=0x7fffedb7f0d0, misc=0x7fffedb7f068, pci_hole=0x7fffedb7f080,
+ *     pci_hole64=0x7fffedb7f090, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:1357
+ * #1  0x0000555555d894c5 in acpi_build (tables=0x7fffedb7f1e0, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:2489
+ * #2  0x0000555555d89f83 in acpi_build_update (build_opaque=0x5555578392b0) at ../hw/i386/acpi-build.c:2661
+ * #3  0x0000555555ac20fd in fw_cfg_select (s=0x555557922180, key=45) at ../hw/nvram/fw_cfg.c:285
+ * #4  0x0000555555ac2a75 in fw_cfg_comb_write (opaque=0x555557922180, addr=0, value=45, size=2) at ../hw/nvram/fw_cfg.c:509
+ * #5  0x0000555555eb8e96 in memory_region_write_accessor (mr=0x555557922640, addr=0, value=0x7fffedb7f3a8, size=2, shift=0,
+ *     mask=65535, attrs=...) at ../system/memory.c:497
+ * #6  0x0000555555eb91df in access_with_adjusted_size (addr=0, value=0x7fffedb7f3a8, size=2, access_size_min=1, access_size_max=4,
+ *     access_fn=0x555555eb8da0 <memory_region_write_accessor>, mr=0x555557922640, attrs=...) at ../system/memory.c:573
+ * #7  0x0000555555ebc9a2 in memory_region_dispatch_write (mr=0x555557922640, addr=0, data=45, op=MO_16, attrs=...) at ../system/memory.c:1553
+ * #8  0x0000555555eccb5a in flatview_write_continue_step (attrs=..., buf=0x7ffff7ff1000 "-", len=2, mr_addr=0, l=0x7fffedb7f490,
+ *     mr=0x555557922640) at ../system/physmem.c:2951
+ * #9  0x0000555555eccc2f in flatview_write_continue (fv=0x7fffe458a6e0, addr=1296, attrs=..., ptr=0x7ffff7ff1000, len=2, mr_addr=0, l=2,
+ *     mr=0x555557922640) at ../system/physmem.c:2981
+ * #10 0x0000555555eccd5c in flatview_write (fv=0x7fffe458a6e0, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2) at ../system/physmem.c:3012
+ * #11 0x0000555555ecd1e9 in address_space_write (as=0x555557383fc0 <address_space_io>, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2)
+ *     at ../system/physmem.c:3132
+ * #12 0x0000555555ecd263 in address_space_rw (as=0x555557383fc0 <address_space_io>, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2, is_write=true)
+ *     at ../system/physmem.c:3142
+ * #13 0x0000555555f0b7dd in kvm_handle_io (port=1296, attrs=..., data=0x7ffff7ff1000, direction=1, size=2, count=1) at ../accel/kvm/kvm-all.c:2800
+ * #14 0x0000555555f0c755 in kvm_cpu_exec (cpu=0x55555776e340) at ../accel/kvm/kvm-all.c:3186
+ * #15 0x0000555555f0fecd in kvm_vcpu_thread_fn (arg=0x55555776e340) at ../accel/kvm/kvm-accel-ops.c:51
+ * #16 0x00005555561ad4c6 in qemu_thread_start (args=0x555557778700) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #18 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * Reset的时候
+ *
+ * (gdb) bt
+ * #0  build_dsdt (table_data=0x7fffe42f2350, linker=0x7fffe4208b20, pm=0x7fffedb7f0d0, misc=0x7fffedb7f068,
+ *     pci_hole=0x7fffedb7f080, pci_hole64=0x7fffedb7f090, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:1357
+ * #1  0x0000555555d894c5 in acpi_build (tables=0x7fffedb7f1e0, machine=0x5555576d8380) at ../hw/i386/acpi-build.c:2489
+ * #2  0x0000555555d89f83 in acpi_build_update (build_opaque=0x5555578392b0) at ../hw/i386/acpi-build.c:2661
+ * #3  0x0000555555ac20fd in fw_cfg_select (s=0x555557922180, key=45) at ../hw/nvram/fw_cfg.c:285
+ * #4  0x0000555555ac2a75 in fw_cfg_comb_write (opaque=0x555557922180, addr=0, value=45, size=2) at ../hw/nvram/fw_cfg.c:509
+ * #5  0x0000555555eb8e96 in memory_region_write_accessor (mr=0x555557922640, addr=0, value=0x7fffedb7f3a8, size=2,
+ *     shift=0, mask=65535, attrs=...) at ../system/memory.c:497
+ * #6  0x0000555555eb91df in access_with_adjusted_size (addr=0, value=0x7fffedb7f3a8, size=2, access_size_min=1,
+ *     access_size_max=4, access_fn=0x555555eb8da0 <memory_region_write_accessor>, mr=0x555557922640, attrs=...) at ../system/memory.c:573
+ * #7  0x0000555555ebc9a2 in memory_region_dispatch_write (mr=0x555557922640, addr=0, data=45, op=MO_16, attrs=...) at ../system/memory.c:1553
+ * #8  0x0000555555eccb5a in flatview_write_continue_step (attrs=..., buf=0x7ffff7ff1000 "-", len=2, mr_addr=0, l=0x7fffedb7f490,
+ *     mr=0x555557922640) at ../system/physmem.c:2951
+ * #9  0x0000555555eccc2f in flatview_write_continue (fv=0x7fffe4981f70, addr=1296, attrs=..., ptr=0x7ffff7ff1000, len=2, mr_addr=0,
+ *     l=2, mr=0x555557922640) at ../system/physmem.c:2981
+ * #10 0x0000555555eccd5c in flatview_write (fv=0x7fffe4981f70, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2) at ../system/physmem.c:3012
+ * #11 0x0000555555ecd1e9 in address_space_write (as=0x555557383fc0 <address_space_io>, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2)
+ *     at ../system/physmem.c:3132
+ * #12 0x0000555555ecd263 in address_space_rw (as=0x555557383fc0 <address_space_io>, addr=1296, attrs=..., buf=0x7ffff7ff1000, len=2, is_write=true)
+ *     at ../system/physmem.c:3142
+ * #13 0x0000555555f0b7dd in kvm_handle_io (port=1296, attrs=..., data=0x7ffff7ff1000, direction=1, size=2, count=1) at ../accel/kvm/kvm-all.c:2800
+ * #14 0x0000555555f0c755 in kvm_cpu_exec (cpu=0x55555776e340) at ../accel/kvm/kvm-all.c:3186
+ * #15 0x0000555555f0fecd in kvm_vcpu_thread_fn (arg=0x55555776e340) at ../accel/kvm/kvm-accel-ops.c:51
+ * #16 0x00005555561ad4c6 in qemu_thread_start (args=0x555557778700) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #18 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用acpi_build_update():
+ *   - hw/i386/acpi-build.c|2728| <<acpi_setup>> build_state->table_mr = acpi_add_rom_blob(acpi_build_update,
+ *   - hw/i386/acpi-build.c|2734| <<acpi_setup>> acpi_add_rom_blob(acpi_build_update, build_state,
+ *   - hw/i386/acpi-build.c|2759| <<acpi_setup>> build_state->rsdp_mr = acpi_add_rom_blob(acpi_build_update,
+ *
+ * 是使用, 不是调用!!!
+ */
 static void acpi_build_update(void *build_opaque)
 {
+    /*
+     * 2487 typedef
+     * 2488 struct AcpiBuildState {
+     * 2489     // Copy of table in RAM (for patching).
+     * 2490     MemoryRegion *table_mr;
+     * 2491     // Is table patched?
+     * 2492     uint8_t patched;
+     * 2493     MemoryRegion *rsdp_mr;
+     * 2494     MemoryRegion *linker_mr;
+     * 2495 } AcpiBuildState;
+     */
     AcpiBuildState *build_state = build_opaque;
+    /*
+     * 233 struct AcpiBuildTables {
+     * 234     GArray *table_data;
+     * 235     GArray *rsdp;
+     * 236     GArray *tcpalog;
+     * 237     GArray *vmgenid;
+     * 238     GArray *hardware_errors;
+     * 239     BIOSLinker *linker;
+     * 240 } AcpiBuildTables;
+     */
     AcpiBuildTables tables;
 
     /* No state to update or already patched? Nothing to do. */
@@ -2656,14 +2880,53 @@ static void acpi_build_update(void *build_opaque)
     }
     build_state->patched = 1;
 
+    /*
+     * 在以下使用acpi_build_tables_init():
+     *   - hw/arm/virt-acpi-build.c|1077| <<virt_acpi_build_update>> acpi_build_tables_init(&tables);
+     *   - hw/arm/virt-acpi-build.c|1133| <<virt_acpi_setup>> acpi_build_tables_init(&tables);
+     *   - hw/i386/acpi-build.c|2779| <<acpi_build_update>> acpi_build_tables_init(&tables);
+     *   - hw/i386/acpi-build.c|2862| <<acpi_setup>> acpi_build_tables_init(&tables);
+     *   - hw/i386/acpi-microvm.c|256| <<acpi_setup_microvm>> acpi_build_tables_init(&tables);
+     *   - hw/loongarch/virt-acpi-build.c|661| <<acpi_build_update>> acpi_build_tables_init(&tables);
+     *   - hw/loongarch/virt-acpi-build.c|713| <<virt_acpi_setup>> acpi_build_tables_init(&tables);
+     *   - hw/riscv/virt-acpi-build.c|764| <<virt_acpi_build_update>> acpi_build_tables_init(&tables);
+     *   - hw/riscv/virt-acpi-build.c|798| <<virt_acpi_setup>> acpi_build_tables_init(&tables);
+     */
     acpi_build_tables_init(&tables);
 
+    /*
+     * 在以下使用acpi_build():
+     *   - hw/i386/acpi-build.c|2686| <<acpi_build_update>> acpi_build(&tables, MACHINE(qdev_get_machine()));
+     *   - hw/i386/acpi-build.c|2764| <<acpi_setup>> acpi_build(&tables, MACHINE(pcms));
+     */
     acpi_build(&tables, MACHINE(qdev_get_machine()));
 
+    /*
+     * 在以下调用arm的acpi_ram_update():
+     *   - hw/arm/virt-acpi-build.c|1064| <<virt_acpi_build_update>> acpi_ram_update(build_state->table_mr, tables.table_data);
+     *   - hw/arm/virt-acpi-build.c|1065| <<virt_acpi_build_update>> acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
+     *   - hw/arm/virt-acpi-build.c|1066| <<virt_acpi_build_update>> acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
+     *
+     * 在以下调用i386的acpi_ram_update():
+     *   - hw/i386/acpi-build.c|2671| <<acpi_build_update>> acpi_ram_update(build_state->table_mr, tables.table_data);
+     *   - hw/i386/acpi-build.c|2673| <<acpi_build_update>> acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
+     *   - hw/i386/acpi-build.c|2675| <<acpi_build_update>> acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
+     */
     acpi_ram_update(build_state->table_mr, tables.table_data);
 
     acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
 
+    /*
+     * 在以下调用arm的acpi_ram_update():
+     *   - hw/arm/virt-acpi-build.c|1064| <<virt_acpi_build_update>> acpi_ram_update(build_state->table_mr, tables.table_data);
+     *   - hw/arm/virt-acpi-build.c|1065| <<virt_acpi_build_update>> acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
+     *   - hw/arm/virt-acpi-build.c|1066| <<virt_acpi_build_update>> acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
+     *
+     * 在以下调用i386的acpi_ram_update():
+     *   - hw/i386/acpi-build.c|2671| <<acpi_build_update>> acpi_ram_update(build_state->table_mr, tables.table_data);
+     *   - hw/i386/acpi-build.c|2673| <<acpi_build_update>> acpi_ram_update(build_state->rsdp_mr, tables.rsdp);
+     *   - hw/i386/acpi-build.c|2675| <<acpi_build_update>> acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
+     */
     acpi_ram_update(build_state->linker_mr, tables.linker->cmd_blob);
     acpi_build_tables_cleanup(&tables, true);
 }
@@ -2684,6 +2947,10 @@ static const VMStateDescription vmstate_acpi_build = {
     },
 };
 
+/*
+ * 在以下使用acpi_setup():
+ *   - hw/i386/pc.c|638| <<pc_machine_done>> acpi_setup();
+ */
 void acpi_setup(void)
 {
     PCMachineState *pcms = PC_MACHINE(qdev_get_machine());
@@ -2722,6 +2989,28 @@ void acpi_setup(void)
                                               ACPI_BUILD_TABLE_FILE);
     assert(build_state->table_mr != NULL);
 
+    /*
+     * 在以下使用ACPI_BUILD_LOADER_FILE:
+     *   - include/hw/acpi/aml-build.h|13| <<global>> #define ACPI_BUILD_LOADER_FILE "etc/table-loader"
+     *   - hw/acpi/utils.c|37| <<acpi_add_rom_blob>> } else if (!strcmp(name, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/arm/virt-acpi-build.c|1145| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/i386/acpi-build.c|2774| <<acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/i386/acpi-microvm.c|263| <<acpi_setup_microvm>> acpi_add_rom_blob(acpi_build_no_update, NULL,
+     *       tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/loongarch/virt-acpi-build.c|724| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/nvram/fw_cfg.c|654| <<fw_cfg_acpi_mr_restore_post_load>>
+     *       } else if (!strcmp(s->files->f[i].name, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/nvram/fw_cfg.c|894| <<fw_cfg_acpi_mr_save>> } else if (!strcmp(filename, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/riscv/virt-acpi-build.c|810| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *
+     * AcpiBuildTables tables:
+     * -> BIOSLinker *linker;
+     *    -> GArray *cmd_blob;
+     */
     build_state->linker_mr =
         acpi_add_rom_blob(acpi_build_update, build_state,
                           tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
diff --git a/hw/i386/acpi-microvm.c b/hw/i386/acpi-microvm.c
index 279da6b4a..f749d486b 100644
--- a/hw/i386/acpi-microvm.c
+++ b/hw/i386/acpi-microvm.c
@@ -90,12 +90,23 @@ static void acpi_dsdt_add_xhci(Aml *scope, MicrovmMachineState *mms)
     }
 }
 
+/*
+ * 在以下使用acpi_dsdt_add_pci():
+ *   - hw/i386/acpi-microvm.c|128| <<build_dsdt_microvm>> acpi_dsdt_add_pci(sb_scope, mms);
+ */
 static void acpi_dsdt_add_pci(Aml *scope, MicrovmMachineState *mms)
 {
     if (mms->pcie != ON_OFF_AUTO_ON) {
         return;
     }
 
+    /*
+     * 在以下使用acpi_dsdt_add_gpex():
+     *   - hw/arm/virt-acpi-build.c|138| <<acpi_dsdt_add_pci>> acpi_dsdt_add_gpex(scope, &cfg);
+     *   - hw/i386/acpi-microvm.c|99| <<acpi_dsdt_add_pci>> acpi_dsdt_add_gpex(scope, &mms->gpex);
+     *   - hw/loongarch/virt-acpi-build.c|398| <<build_pci_device_aml>> acpi_dsdt_add_gpex(scope, &cfg);
+     *   - hw/pci-host/gpex-acpi.c|299| <<acpi_dsdt_add_gpex_host>> acpi_dsdt_add_gpex(scope, &GPEX_HOST(obj)->gpex_cfg);
+     */
     acpi_dsdt_add_gpex(scope, &mms->gpex);
 }
 
@@ -256,6 +267,24 @@ void acpi_setup_microvm(MicrovmMachineState *mms)
     acpi_build_tables_init(&tables);
     acpi_build_microvm(&tables, mms);
 
+    /*
+     * 在以下使用ACPI_BUILD_LOADER_FILE:
+     *   - include/hw/acpi/aml-build.h|13| <<global>> #define ACPI_BUILD_LOADER_FILE "etc/table-loader"
+     *   - hw/acpi/utils.c|37| <<acpi_add_rom_blob>> } else if (!strcmp(name, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/arm/virt-acpi-build.c|1145| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/i386/acpi-build.c|2774| <<acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/i386/acpi-microvm.c|263| <<acpi_setup_microvm>> acpi_add_rom_blob(acpi_build_no_update, NULL,
+     *       tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/loongarch/virt-acpi-build.c|724| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/nvram/fw_cfg.c|654| <<fw_cfg_acpi_mr_restore_post_load>>
+     *       } else if (!strcmp(s->files->f[i].name, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/nvram/fw_cfg.c|894| <<fw_cfg_acpi_mr_save>> } else if (!strcmp(filename, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/riscv/virt-acpi-build.c|810| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     */
     /* Now expose it all to Guest */
     acpi_add_rom_blob(acpi_build_no_update, NULL, tables.table_data,
                       ACPI_BUILD_TABLE_FILE);
diff --git a/hw/i386/amd_iommu.c b/hw/i386/amd_iommu.c
index 5f9b95279..99c6d4b76 100644
--- a/hw/i386/amd_iommu.c
+++ b/hw/i386/amd_iommu.c
@@ -1029,6 +1029,10 @@ static inline bool amdvi_is_interrupt_addr(hwaddr addr)
     return addr >= AMDVI_INT_ADDR_FIRST && addr <= AMDVI_INT_ADDR_LAST;
 }
 
+/*
+ * 在以下使用amdvi_translate():
+ *   - hw/i386/amd_iommu.c|1732| <<amdvi_iommu_memory_region_class_init>> imrc->translate = amdvi_translate;
+ */
 static IOMMUTLBEntry amdvi_translate(IOMMUMemoryRegion *iommu, hwaddr addr,
                                      IOMMUAccessFlags flag, int iommu_idx)
 {
diff --git a/hw/i386/kvm/apic.c b/hw/i386/kvm/apic.c
index 757510600..9bf4d4f2e 100644
--- a/hw/i386/kvm/apic.c
+++ b/hw/i386/kvm/apic.c
@@ -18,18 +18,71 @@
 #include "system/kvm.h"
 #include "kvm/kvm_i386.h"
 
+/*
+ * 在以下使用kvm_apic_set_reg():
+ *   - hw/i386/kvm/apic.c|49| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x2, s->initial_apic_id);
+ *   - hw/i386/kvm/apic.c|51| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x2, s->id << 24);
+ *   - hw/i386/kvm/apic.c|53| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x8, s->tpr);
+ *   - hw/i386/kvm/apic.c|54| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0xd, s->log_dest << 24);
+ *   - hw/i386/kvm/apic.c|55| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0xe, s->dest_mode << 28 | 0x0fffffff);
+ *   - hw/i386/kvm/apic.c|56| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0xf, s->spurious_vec);
+ *   - hw/i386/kvm/apic.c|58| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x10 + i, s->isr[i]);
+ *   - hw/i386/kvm/apic.c|59| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x18 + i, s->tmr[i]);
+ *   - hw/i386/kvm/apic.c|60| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x20 + i, s->irr[i]);
+ *   - hw/i386/kvm/apic.c|62| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x28, s->esr);
+ *   - hw/i386/kvm/apic.c|63| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x30, s->icr[0]);
+ *   - hw/i386/kvm/apic.c|64| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x31, s->icr[1]);
+ *   - hw/i386/kvm/apic.c|66| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x32 + i, s->lvt[i]);
+ *   - hw/i386/kvm/apic.c|68| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x38, s->initial_count);
+ *   - hw/i386/kvm/apic.c|69| <<kvm_put_apic_state>> kvm_apic_set_reg(kapic, 0x3e, s->divide_conf);
+ *
+ * // for KVM_GET_LAPIC and KVM_SET_LAPIC
+ * #define KVM_APIC_REG_SIZE 0x400
+ * struct kvm_lapic_state {
+ *     char regs[KVM_APIC_REG_SIZE];
+ * };
+ */
 static inline void kvm_apic_set_reg(struct kvm_lapic_state *kapic,
                                     int reg_id, uint32_t val)
 {
     *((uint32_t *)(kapic->regs + (reg_id << 4))) = val;
 }
 
+/*
+ * 在以下使用kvm_apic_get_reg():
+ *   - hw/i386/kvm/apic.c|100| <<kvm_get_apic_state>> assert(kvm_apic_get_reg(kapic, 0x2) == s->initial_apic_id);
+ *   - hw/i386/kvm/apic.c|102| <<kvm_get_apic_state>> s->id = kvm_apic_get_reg(kapic, 0x2) >> 24;
+ *   - hw/i386/kvm/apic.c|104| <<kvm_get_apic_state>> s->tpr = kvm_apic_get_reg(kapic, 0x8);
+ *   - hw/i386/kvm/apic.c|105| <<kvm_get_apic_state>> s->arb_id = kvm_apic_get_reg(kapic, 0x9);
+ *   - hw/i386/kvm/apic.c|106| <<kvm_get_apic_state>> s->log_dest = kvm_apic_get_reg(kapic, 0xd) >> 24;
+ *   - hw/i386/kvm/apic.c|107| <<kvm_get_apic_state>> s->dest_mode = kvm_apic_get_reg(kapic, 0xe) >> 28;
+ *   - hw/i386/kvm/apic.c|108| <<kvm_get_apic_state>> s->spurious_vec = kvm_apic_get_reg(kapic, 0xf);
+ *   - hw/i386/kvm/apic.c|110| <<kvm_get_apic_state>> s->isr[i] = kvm_apic_get_reg(kapic, 0x10 + i);
+ *   - hw/i386/kvm/apic.c|111| <<kvm_get_apic_state>> s->tmr[i] = kvm_apic_get_reg(kapic, 0x18 + i);
+ *   - hw/i386/kvm/apic.c|112| <<kvm_get_apic_state>> s->irr[i] = kvm_apic_get_reg(kapic, 0x20 + i);
+ *   - hw/i386/kvm/apic.c|114| <<kvm_get_apic_state>> s->esr = kvm_apic_get_reg(kapic, 0x28);
+ *   - hw/i386/kvm/apic.c|115| <<kvm_get_apic_state>> s->icr[0] = kvm_apic_get_reg(kapic, 0x30);
+ *   - hw/i386/kvm/apic.c|116| <<kvm_get_apic_state>> s->icr[1] = kvm_apic_get_reg(kapic, 0x31);
+ *   - hw/i386/kvm/apic.c|118| <<kvm_get_apic_state>> s->lvt[i] = kvm_apic_get_reg(kapic, 0x32 + i);
+ *   - hw/i386/kvm/apic.c|120| <<kvm_get_apic_state>> s->initial_count = kvm_apic_get_reg(kapic, 0x38);
+ *   - hw/i386/kvm/apic.c|121| <<kvm_get_apic_state>> s->divide_conf = kvm_apic_get_reg(kapic, 0x3e);
+ */
 static inline uint32_t kvm_apic_get_reg(struct kvm_lapic_state *kapic,
                                         int reg_id)
 {
+    /*
+     * 122 #define KVM_APIC_REG_SIZE 0x400
+     * 123 struct kvm_lapic_state {
+     * 124         char regs[KVM_APIC_REG_SIZE];
+     * 125 };
+     */
     return *((uint32_t *)(kapic->regs + (reg_id << 4)));
 }
 
+/*
+ * 在以下使用kvm_put_apic_state():
+ *   - hw/i386/kvm/apic.c|177| <<kvm_apic_put>> kvm_put_apic_state(s, &kapic);
+ */
 static void kvm_put_apic_state(APICCommonState *s, struct kvm_lapic_state *kapic)
 {
     int i;
@@ -38,6 +91,10 @@ static void kvm_put_apic_state(APICCommonState *s, struct kvm_lapic_state *kapic
     if (kvm_has_x2apic_api() && s->apicbase & MSR_IA32_APICBASE_EXTD) {
         kvm_apic_set_reg(kapic, 0x2, s->initial_apic_id);
     } else {
+        /*
+	 * 不管此刻x2apic有没激活 都往左24 bit
+	 * 算是一个潜规则??
+	 */
         kvm_apic_set_reg(kapic, 0x2, s->id << 24);
     }
     kvm_apic_set_reg(kapic, 0x8, s->tpr);
@@ -59,6 +116,28 @@ static void kvm_put_apic_state(APICCommonState *s, struct kvm_lapic_state *kapic
     kvm_apic_set_reg(kapic, 0x3e, s->divide_conf);
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_get_apic_state (dev=0x55a74f0a97f0, kapic=0x7f65b7dfe110) at ../hw/i386/kvm/apic.c:64
+ * #1  0x000055a728c2c1f3 in kvm_get_apic (cpu=0x55a74f0a0600) at ../target/i386/kvm/kvm.c:5002
+ * #2  0x000055a728c2d461 in kvm_arch_get_registers (cs=0x55a74f0a0600, errp=0x7f65b7dfe580) at ../target/i386/kvm/kvm.c:5396
+ * #3  0x000055a728e05add in do_kvm_cpu_synchronize_state (cpu=0x55a74f0a0600, arg=...) at ../accel/kvm/kvm-all.c:2867
+ * #4  0x000055a7287883ab in process_queued_cpu_work (cpu=0x55a74f0a0600) at ../cpu-common.c:374
+ * #5  0x000055a728b18021 in qemu_wait_io_event_common (cpu=0x55a74f0a0600) at ../system/cpus.c:451
+ * #6  0x000055a728b180ba in qemu_wait_io_event (cpu=0x55a74f0a0600) at ../system/cpus.c:469
+ * #7  0x000055a728e09ef1 in kvm_vcpu_thread_fn (arg=0x55a74f0a0600) at ../accel/kvm/kvm-accel-ops.c:56
+ * #8  0x000055a7290a74c6 in qemu_thread_start (args=0x55a74f0a9ce0) at ../util/qemu-thread-posix.c:541
+ * #9  0x00007f67cc8f51da in start_thread () from /lib64/libpthread.so.0
+ * #10 0x00007f67cac268d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用kvm_get_apic_state():
+ *   - target/i386/kvm/kvm.c|5002| <<kvm_get_apic>> kvm_get_apic_state(apic, &kapic);
+ *
+ * 122 #define KVM_APIC_REG_SIZE 0x400
+ * 123 struct kvm_lapic_state {
+ * 124         char regs[KVM_APIC_REG_SIZE];
+ * 125 };
+ */
 void kvm_get_apic_state(DeviceState *dev, struct kvm_lapic_state *kapic)
 {
     APICCommonState *s = APIC_COMMON(dev);
@@ -92,9 +171,19 @@ void kvm_get_apic_state(DeviceState *dev, struct kvm_lapic_state *kapic)
     s->count_shift = (v + 1) & 7;
 
     s->initial_count_load_time = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);
+    /*
+     * 在以下使用apic_next_timer():
+     *   - hw/i386/kvm/apic.c|170| <<kvm_get_apic_state>> apic_next_timer(s, s->initial_count_load_time);
+     *   - hw/intc/apic.c|775| <<apic_timer_update>> if (apic_next_timer(s, current_time)) {
+     *   - target/i386/whpx/whpx-apic.c|90| <<whpx_get_apic_state>> apic_next_timer(s, s->initial_count_load_time);
+     */
     apic_next_timer(s, s->initial_count_load_time);
 }
 
+/*
+ * 在以下使用kvm_apic_set_base():
+ *   - hw/i386/kvm/apic.c|334| <<kvm_apic_class_init>> k->set_base = kvm_apic_set_base;
+ */
 static int kvm_apic_set_base(APICCommonState *s, uint64_t val)
 {
     s->apicbase = val;
@@ -120,6 +209,10 @@ static void kvm_apic_enable_tpr_reporting(APICCommonState *s, bool enable)
     kvm_vcpu_ioctl(CPU(s->cpu), KVM_TPR_ACCESS_REPORTING, &ctl);
 }
 
+/*
+ * 在以下使用kvm_apic_vapic_base_update():
+ *   - hw/i386/kvm/apic.c|255| <<kvm_apic_class_init>> k->vapic_base_update = kvm_apic_vapic_base_update;
+ */
 static void kvm_apic_vapic_base_update(APICCommonState *s)
 {
     struct kvm_vapic_addr vapid_addr = {
@@ -135,13 +228,82 @@ static void kvm_apic_vapic_base_update(APICCommonState *s)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_apic_reset (s=0x555557618000) at ../hw/i386/kvm/apic.c:221
+ * #1  0x0000555555e4b64b in apic_init_reset (dev=0x555557618000) at ../hw/intc/apic_common.c:232
+ * #2  0x0000555555e4b76a in apic_reset_common (dev=0x555557618000) at ../hw/intc/apic_common.c:265
+ * #3  0x0000555555f1eca5 in do_legacy_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/qdev.c:776
+ * #4  0x0000555555f20bad in resettable_phase_hold (obj=0x555557618000, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #5  0x0000555555f207b1 in resettable_assert_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #6  0x0000555555f20709 in resettable_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #7  0x0000555555f1d762 in device_cold_reset (dev=0x555557618000) at ../hw/core/qdev.c:239
+ * #8  0x0000555555da9303 in x86_cpu_after_reset (cpu=0x5555577517f0) at ../target/i386/cpu.c:7621
+ * #9  0x0000555555d7ec7e in pc_machine_reset (machine=0x5555576d8c50, type=RESET_TYPE_COLD) at ../hw/i386/pc.c:1735
+ * #10 0x0000555555c2d38f in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at ../system/runstate.c:525
+ * #11 0x000055555597da2f in qdev_machine_creation_done () at ../hw/core/machine.c:1763
+ * #12 0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #13 0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #14 0x0000555555c38346 in qemu_init (argc=21, argv=0x7fffffffdc28) at ../system/vl.c:3843
+ * #15 0x00005555560d2905 in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  kvm_apic_reset (s=0x555557618000) at ../hw/i386/kvm/apic.c:221
+ * #1  0x0000555555e4b64b in apic_init_reset (dev=0x555557618000) at ../hw/intc/apic_common.c:232
+ * #2  0x0000555555e4b76a in apic_reset_common (dev=0x555557618000) at ../hw/intc/apic_common.c:265
+ * #3  0x0000555555f1eca5 in do_legacy_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/qdev.c:776
+ * #4  0x0000555555f20bad in resettable_phase_hold (obj=0x555557618000, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #5  0x0000555555f207b1 in resettable_assert_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #6  0x0000555555f20709 in resettable_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #7  0x0000555555f1d762 in device_cold_reset (dev=0x555557618000) at ../hw/core/qdev.c:239
+ * #8  0x0000555555da9303 in x86_cpu_after_reset (cpu=0x5555577517f0) at ../target/i386/cpu.c:7621
+ * #9  0x0000555555d7ec7e in pc_machine_reset (machine=0x5555576d8c50, type=RESET_TYPE_COLD) at ../hw/i386/pc.c:1735
+ * #10 0x0000555555c2d38f in qemu_system_reset (reason=SHUTDOWN_CAUSE_GUEST_RESET) at ../system/runstate.c:525
+ * #11 0x0000555555c2db95 in main_loop_should_exit (status=0x7fffffffdae4) at ../system/runstate.c:801
+ * #12 0x0000555555c2dc96 in qemu_main_loop () at ../system/runstate.c:834
+ * #13 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #14 0x00005555560d296f in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:80
+ *
+ * (gdb) bt
+ * #0  kvm_apic_put (cs=0x5555577517f0, data=...) at ../hw/i386/kvm/apic.c:139
+ * #1  0x000055555588e3ab in process_queued_cpu_work (cpu=0x5555577517f0) at ../cpu-common.c:374
+ * #2  0x0000555555c1e021 in qemu_wait_io_event_common (cpu=0x5555577517f0) at ../system/cpus.c:451
+ * #3  0x0000555555c1e0ba in qemu_wait_io_event (cpu=0x5555577517f0) at ../system/cpus.c:469
+ * #4  0x0000555555f0fef1 in kvm_vcpu_thread_fn (arg=0x5555577517f0) at ../accel/kvm/kvm-accel-ops.c:56
+ * #5  0x00005555561ad4c6 in qemu_thread_start (args=0x55555775bc80) at ../util/qemu-thread-posix.c:541
+ * #6  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #7  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下使用kvm_apic_put():
+ *   - hw/i386/kvm/apic.c|188| <<kvm_apic_post_load>> run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
+ *   - hw/i386/kvm/apic.c|257| <<kvm_apic_reset>> run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
+ */
 static void kvm_apic_put(CPUState *cs, run_on_cpu_data data)
 {
     APICCommonState *s = data.host_ptr;
     struct kvm_lapic_state kapic;
     int ret;
 
+    /*
+     * 在以下设置APICCommonState->apicbase:
+     *   - hw/intc/apic_common.c|411| <<global>> VMSTATE_UINT32(apicbase, APICCommonState),
+     *   - hw/i386/kvm/apic.c|185| <<kvm_apic_set_base>> s->apicbase = val;
+     *   - hw/intc/apic.c|353| <<apic_set_base>> s->apicbase = (val & MSR_IA32_APICBASE_BASE) |
+     *   - hw/intc/apic.c|364| <<apic_set_base>> s->apicbase |= MSR_IA32_APICBASE_ENABLE;
+     *   - hw/intc/apic.c|372| <<apic_set_base>> s->apicbase |= MSR_IA32_APICBASE_EXTD;
+     *   - hw/intc/apic_common.c|263| <<apic_designate_bsp>> s->apicbase |= MSR_IA32_APICBASE_BSP;
+     *   - hw/intc/apic_common.c|265| <<apic_designate_bsp>> s->apicbase &= ~MSR_IA32_APICBASE_BSP;
+     *   - hw/intc/apic_common.c|276| <<apic_reset_common>> s->apicbase = APIC_DEFAULT_ADDRESS | bsp | MSR_IA32_APICBASE_ENABLE;
+     *   - target/i386/cpu-apic.c|59| <<x86_cpu_apic_create>> apic->apicbase = APIC_DEFAULT_ADDRESS | MSR_IA32_APICBASE_ENABLE;
+     *   - target/i386/whpx/whpx-apic.c|95| <<whpx_apic_set_base>> s->apicbase = val;
+     *
+     *
+     * 只在这里使用kvm_put_apicbase()
+     */
     kvm_put_apicbase(s->cpu, s->apicbase);
+    /*
+     * 只在这里使用kvm_put_apic_state()
+     */
     kvm_put_apic_state(s, &kapic);
 
     ret = kvm_vcpu_ioctl(CPU(s->cpu), KVM_SET_LAPIC, &kapic);
@@ -151,6 +313,10 @@ static void kvm_apic_put(CPUState *cs, run_on_cpu_data data)
     }
 }
 
+/*
+ * 在以下使用kvm_apic_post_load():
+ *   - hw/i386/kvm/apic.c|466| <<kvm_apic_class_init>> k->post_load = kvm_apic_post_load;
+ */
 static void kvm_apic_post_load(APICCommonState *s)
 {
     run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
@@ -179,6 +345,16 @@ static void kvm_apic_external_nmi(APICCommonState *s)
     run_on_cpu(CPU(s->cpu), do_inject_external_nmi, RUN_ON_CPU_HOST_PTR(s));
 }
 
+/*
+ * 在以下使用kvm_send_msi():
+ *   - hw/i386/kvm/apic.c|305| <<kvm_apic_mem_write>> kvm_send_msi(&msg);
+ *   - hw/i386/kvm/apic.c|351| <<kvm_apic_class_init>> k->send_msi = kvm_send_msi;
+ *
+ * struct MSIMessage {
+ *     uint64_t address;
+ *     uint32_t data;
+ * };
+ */
 static void kvm_send_msi(MSIMessage *msg)
 {
     int ret;
@@ -190,6 +366,11 @@ static void kvm_send_msi(MSIMessage *msg)
      */
     msg->address = kvm_swizzle_msi_ext_dest_id(msg->address);
 
+    /*
+     * 在以下使用kvm_irqchip_send_msi():
+     *   - hw/i386/kvm/apic.c|277| <<kvm_send_msi>> ret = kvm_irqchip_send_msi(kvm_state, *msg);
+     *   - target/i386/kvm/xen-emu.c|451| <<kvm_xen_inject_vcpu_callback_vector>> kvm_irqchip_send_msi(kvm_state, msg);
+     */
     ret = kvm_irqchip_send_msi(kvm_state, *msg);
     if (ret < 0) {
         fprintf(stderr, "KVM: injection failed, MSI lost (%s)\n",
@@ -217,11 +398,56 @@ static const MemoryRegionOps kvm_apic_io_ops = {
     .endianness = DEVICE_LITTLE_ENDIAN,
 };
 
+/*
+ * (gdb) bt
+ * #0  kvm_apic_reset (s=0x555557618000) at ../hw/i386/kvm/apic.c:221
+ * #1  0x0000555555e4b64b in apic_init_reset (dev=0x555557618000) at ../hw/intc/apic_common.c:232
+ * #2  0x0000555555e4b76a in apic_reset_common (dev=0x555557618000) at ../hw/intc/apic_common.c:265
+ * #3  0x0000555555f1eca5 in do_legacy_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/qdev.c:776
+ * #4  0x0000555555f20bad in resettable_phase_hold (obj=0x555557618000, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #5  0x0000555555f207b1 in resettable_assert_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #6  0x0000555555f20709 in resettable_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #7  0x0000555555f1d762 in device_cold_reset (dev=0x555557618000) at ../hw/core/qdev.c:239
+ * #8  0x0000555555da9303 in x86_cpu_after_reset (cpu=0x5555577517f0) at ../target/i386/cpu.c:7621
+ * #9  0x0000555555d7ec7e in pc_machine_reset (machine=0x5555576d8c50, type=RESET_TYPE_COLD) at ../hw/i386/pc.c:1735
+ * #10 0x0000555555c2d38f in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at ../system/runstate.c:525
+ * #11 0x000055555597da2f in qdev_machine_creation_done () at ../hw/core/machine.c:1763
+ * #12 0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #13 0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #14 0x0000555555c38346 in qemu_init (argc=21, argv=0x7fffffffdc28) at ../system/vl.c:3843
+ * #15 0x00005555560d2905 in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  kvm_apic_reset (s=0x555557618000) at ../hw/i386/kvm/apic.c:221
+ * #1  0x0000555555e4b64b in apic_init_reset (dev=0x555557618000) at ../hw/intc/apic_common.c:232
+ * #2  0x0000555555e4b76a in apic_reset_common (dev=0x555557618000) at ../hw/intc/apic_common.c:265
+ * #3  0x0000555555f1eca5 in do_legacy_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/qdev.c:776
+ * #4  0x0000555555f20bad in resettable_phase_hold (obj=0x555557618000, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #5  0x0000555555f207b1 in resettable_assert_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #6  0x0000555555f20709 in resettable_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #7  0x0000555555f1d762 in device_cold_reset (dev=0x555557618000) at ../hw/core/qdev.c:239
+ * #8  0x0000555555da9303 in x86_cpu_after_reset (cpu=0x5555577517f0) at ../target/i386/cpu.c:7621
+ * #9  0x0000555555d7ec7e in pc_machine_reset (machine=0x5555576d8c50, type=RESET_TYPE_COLD) at ../hw/i386/pc.c:1735
+ * #10 0x0000555555c2d38f in qemu_system_reset (reason=SHUTDOWN_CAUSE_GUEST_RESET) at ../system/runstate.c:525
+ * #11 0x0000555555c2db95 in main_loop_should_exit (status=0x7fffffffdae4) at ../system/runstate.c:801
+ * #12 0x0000555555c2dc96 in qemu_main_loop () at ../system/runstate.c:834
+ * #13 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #14 0x00005555560d296f in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:80
+ *
+ *
+ * 在以下使用kvm_apic_reset():
+ *   - hw/i386/kvm/apic.c|358| <<kvm_apic_class_init>> k->reset = kvm_apic_reset;
+ */
 static void kvm_apic_reset(APICCommonState *s)
 {
     /* Not used by KVM, which uses the CPU mp_state instead.  */
     s->wait_for_sipi = 0;
 
+    /*
+     * 在以下使用kvm_apic_put():
+     *   - hw/i386/kvm/apic.c|188| <<kvm_apic_post_load>> run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
+     *   - hw/i386/kvm/apic.c|257| <<kvm_apic_reset>> run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
+     */
     run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
 }
 
@@ -257,6 +483,10 @@ static void kvm_apic_class_init(ObjectClass *klass, void *data)
     k->send_msi = kvm_send_msi;
 }
 
+/*
+ * TYPE_APIC_COMMON的parent是TYPE_DEVICE
+ * hw/intc/apic_common.c
+ */
 static const TypeInfo kvm_apic_info = {
     .name = "kvm-apic",
     .parent = TYPE_APIC_COMMON,
diff --git a/hw/i386/kvm/clock.c b/hw/i386/kvm/clock.c
index 17443552e..9e0863ac3 100644
--- a/hw/i386/kvm/clock.c
+++ b/hw/i386/kvm/clock.c
@@ -43,6 +43,13 @@ struct KVMClockState {
     /* whether the 'clock' value was obtained in the 'paused' state */
     bool runstate_paused;
 
+    /*
+     * 在以下使用KVMClockState->mach_use_reliable_get_clock:
+     *   - hw/i386/kvm/clock.c|333| <<global>> static const Property kvmclock_properties[] = {
+     *             DEFINE_PROP_BOOL("x-mach-use-reliable-get-clock",
+     *             KVMClockState, mach_use_reliable_get_clock, true),
+     *   - hw/i386/kvm/clock.c|263| <<kvmclock_clock_is_reliable_needed>> return s->mach_use_reliable_get_clock;
+     */
     /* whether machine type supports reliable KVM_GET_CLOCK */
     bool mach_use_reliable_get_clock;
 
@@ -62,11 +69,31 @@ struct pvclock_vcpu_time_info {
     uint8_t    pad[2];
 } __attribute__((__packed__)); /* 32 bytes */
 
+/*
+ * 在以下使用kvmclock_current_nsec():
+ *   - hw/i386/kvm/clock.c|179| <<kvmclock_vm_state_change>> uint64_t pvclock_via_mem = kvmclock_current_nsec(s);
+ */
 static uint64_t kvmclock_current_nsec(KVMClockState *s)
 {
     CPUState *cpu = first_cpu;
     CPUX86State *env = cpu_env(cpu);
     hwaddr kvmclock_struct_pa;
+    /*
+     * 在以下使用CPUX86State->tsc:
+     *   - target/i386/machine.c|1724| <<global>> VMSTATE_UINT64(env.tsc, X86CPU),
+     *   - hw/i386/kvm/clock.c|70| <<kvmclock_current_nsec>> uint64_t migration_tsc = env->tsc;
+     *   - target/i386/cpu.c|7535| <<x86_cpu_reset_hold>> if (env->tsc != 0) {
+     *   - target/i386/cpu.c|7536| <<x86_cpu_reset_hold>> env->tsc = 1;
+     *   - target/i386/cpu.c|7539| <<x86_cpu_reset_hold>> env->tsc = 0;
+     *   - target/i386/hvf/x86hvf.c|236| <<hvf_get_msrs>> env->tsc = rdtscp() + rvmcs(cs->accel->fd, VMCS_TSC_OFFSET);
+     *   - target/i386/kvm/kvm.c|329| <<kvm_get_tsc>> env->tsc = value;
+     *   - target/i386/kvm/kvm.c|4013| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
+     *   - target/i386/kvm/kvm.c|4752| <<kvm_get_msrs>> env->tsc = msrs[i].data;
+     *   - target/i386/nvmm/nvmm-all.c|181| <<nvmm_set_registers>> state->msrs[NVMM_X64_MSR_TSC] = env->tsc;
+     *   - target/i386/nvmm/nvmm-all.c|336| <<nvmm_get_registers>> env->tsc = state->msrs[NVMM_X64_MSR_TSC];
+     *   - target/i386/whpx/whpx-all.c|347| <<whpx_set_tsc>> tsc_val.Reg64 = cpu_env(cpu)->tsc;
+     *   - target/i386/whpx/whpx-all.c|570| <<whpx_get_tsc>> cpu_env(cpu)->tsc = tsc_val.Reg64;
+     */
     uint64_t migration_tsc = env->tsc;
     struct pvclock_vcpu_time_info time;
     uint64_t delta;
@@ -97,6 +124,12 @@ static uint64_t kvmclock_current_nsec(KVMClockState *s)
     return nsec + time.system_time;
 }
 
+/*
+ * 在以下使用kvm_update_clock():
+ *   - hw/i386/kvm/clock.c|235| <<kvmclock_vm_state_change>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|254| <<kvmclock_realize>> kvm_update_clock(s);
+ *   - hw/i386/kvm/clock.c|309| <<kvmclock_pre_save>> kvm_update_clock(s);
+ */
 static void kvm_update_clock(KVMClockState *s)
 {
     struct kvm_clock_data data;
@@ -151,6 +184,10 @@ static void kvm_update_clock(KVMClockState *s)
     s->clock_is_reliable = kvm_has_adjust_clock_stable();
 }
 
+/*
+ * 在以下使用do_kvmclock_ctrl():
+ *   - hw/i386/kvm/clock.c|236| <<kvmclock_vm_state_change>> run_on_cpu(cpu, do_kvmclock_ctrl, RUN_ON_CPU_NULL);
+ */
 static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
 {
     int ret = kvm_vcpu_ioctl(cpu, KVM_KVMCLOCK_CTRL, 0);
@@ -160,6 +197,10 @@ static void do_kvmclock_ctrl(CPUState *cpu, run_on_cpu_data data)
     }
 }
 
+/*
+ * 在以下使用kvmclock_vm_state_change():
+ *   - hw/i386/kvm/clock.c|232| <<kvmclock_realize>> qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
+ */
 static void kvmclock_vm_state_change(void *opaque, bool running,
                                      RunState state)
 {
@@ -232,10 +273,29 @@ static void kvmclock_realize(DeviceState *dev, Error **errp)
     qemu_add_vm_change_state_handler(kvmclock_vm_state_change, s);
 }
 
+/*
+ * 289 static const VMStateDescription kvmclock_reliable_get_clock = {
+ * 290     .name = "kvmclock/clock_is_reliable",
+ * 291     .version_id = 1,
+ * 292     .minimum_version_id = 1,
+ * 293     .needed = kvmclock_clock_is_reliable_needed,
+ * 294     .fields = (const VMStateField[]) {
+ * 295         VMSTATE_BOOL(clock_is_reliable, KVMClockState),
+ * 296         VMSTATE_END_OF_LIST()
+ * 297     }
+ * 298 };
+ */
 static bool kvmclock_clock_is_reliable_needed(void *opaque)
 {
     KVMClockState *s = opaque;
 
+    /*
+     * 在以下使用KVMClockState->mach_use_reliable_get_clock:
+     *   - hw/i386/kvm/clock.c|333| <<global>> static const Property kvmclock_properties[] = {
+     *             DEFINE_PROP_BOOL("x-mach-use-reliable-get-clock",
+     *             KVMClockState, mach_use_reliable_get_clock, true),
+     *   - hw/i386/kvm/clock.c|263| <<kvmclock_clock_is_reliable_needed>> return s->mach_use_reliable_get_clock;
+     */
     return s->mach_use_reliable_get_clock;
 }
 
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index 01d0581f6..aa93a8e7a 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1719,6 +1719,29 @@ static void pc_machine_initfn(Object *obj)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_apic_reset (s=0x555557618000) at ../hw/i386/kvm/apic.c:221
+ * #1  0x0000555555e4b64b in apic_init_reset (dev=0x555557618000) at ../hw/intc/apic_common.c:232
+ * #2  0x0000555555e4b76a in apic_reset_common (dev=0x555557618000) at ../hw/intc/apic_common.c:265
+ * #3  0x0000555555f1eca5 in do_legacy_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/qdev.c:776
+ * #4  0x0000555555f20bad in resettable_phase_hold (obj=0x555557618000, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:162
+ * #5  0x0000555555f207b1 in resettable_assert_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:58
+ * #6  0x0000555555f20709 in resettable_reset (obj=0x555557618000, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #7  0x0000555555f1d762 in device_cold_reset (dev=0x555557618000) at ../hw/core/qdev.c:239
+ * #8  0x0000555555da9303 in x86_cpu_after_reset (cpu=0x5555577517f0) at ../target/i386/cpu.c:7621
+ * #9  0x0000555555d7ec7e in pc_machine_reset (machine=0x5555576d8c50, type=RESET_TYPE_COLD) at ../hw/i386/pc.c:1735
+ * #10 0x0000555555c2d38f in qemu_system_reset (reason=SHUTDOWN_CAUSE_NONE) at ../system/runstate.c:525
+ * #11 0x000055555597da2f in qdev_machine_creation_done () at ../hw/core/machine.c:1763
+ * #12 0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #13 0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #14 0x0000555555c38346 in qemu_init (argc=21, argv=0x7fffffffdc28) at ../system/vl.c:3843
+ * #15 0x00005555560d2905 in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:71
+ *
+ * 在以下使用pc_machine_reset():
+ *   - hw/i386/pc.c|1742| <<pc_machine_wakeup>> pc_machine_reset(machine, RESET_TYPE_WAKEUP);
+ *   - hw/i386/pc.c|1791| <<pc_machine_class_init>> mc->reset = pc_machine_reset;
+ */
 static void pc_machine_reset(MachineState *machine, ResetType type)
 {
     CPUState *cs;
@@ -1738,6 +1761,16 @@ static void pc_machine_reset(MachineState *machine, ResetType type)
 
 static void pc_machine_wakeup(MachineState *machine)
 {
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1741| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1792| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1989| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|515| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2127| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
     pc_machine_reset(machine, RESET_TYPE_WAKEUP);
     cpu_synchronize_all_post_reset();
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index fd96d0345..19529c899 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -124,6 +124,16 @@ static int ehci_create_ich9_with_companions(PCIBus *bus, int slot)
     return 0;
 }
 
+/*
+ * 330 #define DEFINE_Q35_MACHINE(major, minor) \
+ * 331     DEFINE_PC_VER_MACHINE(pc_q35, "pc-q35", pc_q35_init, false, NULL, major, minor);
+ * 332
+ * 333 #define DEFINE_Q35_MACHINE_AS_LATEST(major, minor) \
+ * 334     DEFINE_PC_VER_MACHINE(pc_q35, "pc-q35", pc_q35_init, false, "q35", major, minor);
+ * 335
+ * 336 #define DEFINE_Q35_MACHINE_BUGFIX(major, minor, micro) \
+ * 337     DEFINE_PC_VER_MACHINE(pc_q35, "pc-q35", pc_q35_init, false, NULL, major, minor, micro);
+ */
 /* PC hardware initialisation */
 static void pc_q35_init(MachineState *machine)
 {
@@ -222,6 +232,9 @@ static void pc_q35_init(MachineState *machine)
                              pcms->default_bus_bypass_iommu, NULL);
     object_property_set_bool(phb, PCI_HOST_PROP_SMM_RANGES,
                              x86_machine_is_smm_enabled(x86ms), NULL);
+    /*
+     * 这里!!
+     */
     sysbus_realize_and_unref(SYS_BUS_DEVICE(phb), &error_fatal);
 
     /* pci */
@@ -239,6 +252,16 @@ static void pc_q35_init(MachineState *machine)
     for (i = 0; i < IOAPIC_NUM_PINS; i++) {
         qdev_connect_gpio_out_named(lpc_dev, ICH9_GPIO_GSI, i, x86ms->gsi[i]);
     }
+    /*
+     * BusChild *kid = g_malloc0(sizeof(*kid));
+     * bus->num_children++;
+     * kid->index = bus->max_index++;
+     * kid->child = child;
+     * object_ref(OBJECT(kid->child));
+     * QTAILQ_INSERT_HEAD_RCU(&bus->children, kid, sibling);
+     *
+     * 所以, 如果能找到pcms->pcibus, 就能从children上找到lpc (ICH9LPCState)
+     */
     pci_realize_and_unref(lpc, pcms->pcibus, &error_fatal);
 
     x86ms->rtc = ISA_DEVICE(object_resolve_path_component(OBJECT(lpc), "rtc"));
diff --git a/hw/i386/vapic.c b/hw/i386/vapic.c
index 14de9b7a8..b145c8bd5 100644
--- a/hw/i386/vapic.c
+++ b/hw/i386/vapic.c
@@ -23,6 +23,40 @@
 #include "migration/vmstate.h"
 #include "qom/object.h"
 
+/*
+ * commit e5ad936b0fd7dfd7fd7908be6f9f1ca88f63b96b
+ * Author: Jan Kiszka <jan.kiszka@siemens.com>
+ * Date:   Fri Feb 17 18:31:19 2012 +0100
+ *
+ * kvmvapic: Introduce TPR access optimization for Windows guests
+ *
+ * This enables acceleration for MMIO-based TPR registers accesses of
+ * 32-bit Windows guest systems. It is mostly useful with KVM enabled,
+ * either on older Intel CPUs (without flexpriority feature, can also be
+ * manually disabled for testing) or any current AMD processor.
+ *
+ * The approach introduced here is derived from the original version of
+ * qemu-kvm. It was refactored, documented, and extended by support for
+ * user space APIC emulation, both with and without KVM acceleration. The
+ * VMState format was kept compatible, so was the ABI to the option ROM
+ * that implements the guest-side para-virtualized driver service. This
+ * enables seamless migration from qemu-kvm to upstream or, one day,
+ * between KVM and TCG mode.
+ *
+ * The basic concept goes like this:
+ *  - VAPIC PV interface consisting of I/O port 0x7e and (for KVM in-kernel
+ *    irqchip) a vmcall hypercall is registered
+ *  - VAPIC option ROM is loaded into guest
+ *  - option ROM activates TPR MMIO access reporting via port 0x7e
+ *  - TPR accesses are trapped and patched in the guest to call into option
+ *    ROM instead, VAPIC support is enabled
+ *  - option ROM TPR helpers track state in memory and invoke hypercall to
+ *    poll for pending IRQs if required
+ *
+ * Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
+ * Signed-off-by: Avi Kivity <avi@redhat.com>
+ */
+
 #define VAPIC_IO_PORT           0x7e
 
 #define VAPIC_CPU_SHIFT         7
diff --git a/hw/ide/core.c b/hw/ide/core.c
index b14983ec5..641c4bedd 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -1132,6 +1132,20 @@ static void ide_flush_cache(IDEState *s)
     s->status |= BUSY_STAT;
     ide_set_retry(s);
     block_acct_start(blk_get_stats(s->blk), &s->acct, 0, BLOCK_ACCT_FLUSH);
+    /*
+     * 在以下使用blk_aio_flush():
+     *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+     *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+     *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+     *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+     *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+     *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+     *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+     *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+     */
     s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
 }
 
diff --git a/hw/ide/isa.c b/hw/ide/isa.c
index 4863ad808..1a560bbea 100644
--- a/hw/ide/isa.c
+++ b/hw/ide/isa.c
@@ -73,6 +73,22 @@ static void isa_ide_realizefn(DeviceState *dev, Error **errp)
     ide_bus_init(&s->bus, sizeof(s->bus), dev, 0, 2);
     ide_init_ioport(&s->bus, isadev, s->iobase, s->iobase2);
     ide_bus_init_output_irq(&s->bus, isa_get_irq(isadev, s->irqnum));
+    /*
+     * 在以下使用vmstate_register_any():
+     *   - audio/audio.c|1787| <<audio_init>> vmstate_register_any(NULL, &vmstate_audio, s);
+     *   - backends/dbus-vmstate.c|429| <<dbus_vmstate_complete>> if (vmstate_register_any(VMSTATE_IF(self), &dbus_vmstate, self) < 0) {
+     *   - backends/tpm/tpm_emulator.c|1009| <<tpm_emulator_inst_init>> vmstate_register_any(NULL, &vmstate_tpm_emulator, obj);
+     *   - hw/display/vmware_vga.c|1265| <<vmsvga_init>> vmstate_register_any(NULL, &vmstate_vga_common, &s->vga);
+     *   - hw/i2c/core.c|66| <<i2c_init_bus>> vmstate_register_any(NULL, &vmstate_i2c_bus, bus);
+     *   - hw/ide/isa.c|76| <<isa_ide_realizefn>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_ide_isa, s);
+     *   - hw/input/adb.c|250| <<adb_bus_realize>> vmstate_register_any(NULL, &vmstate_adb_bus, adb_bus);
+     *   - hw/net/eepro100.c|1888| <<e100_nic_realize>> vmstate_register_any(VMSTATE_IF(&pci_dev->qdev), s->vmstate, s);
+     *   - hw/nvram/eeprom93xx.c|324| <<eeprom93xx_new>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_eeprom, eeprom);
+     *   - hw/pci/pci.c|178| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+     *   - hw/ppc/spapr_nvdimm.c|879| <<spapr_nvdimm_realize>> vmstate_register_any(NULL, &vmstate_spapr_nvdimm_states, dimm);
+     *   - hw/timer/arm_timer.c|184| <<arm_timer_init>> vmstate_register_any(NULL, &vmstate_arm_timer, s);
+     *   - hw/virtio/virtio-mem.c|1122| <<virtio_mem_device_realize>> vmstate_register_any(VMSTATE_IF(vmem), &vmstate_virtio_mem_device_early, vmem);
+     */
     vmstate_register_any(VMSTATE_IF(dev), &vmstate_ide_isa, s);
     ide_bus_register_restart_cb(&s->bus);
 }
diff --git a/hw/intc/apic.c b/hw/intc/apic.c
index d18c1dbf2..9ac2ef5f1 100644
--- a/hw/intc/apic.c
+++ b/hw/intc/apic.c
@@ -772,6 +772,12 @@ int apic_accept_pic_intr(DeviceState *dev)
 
 static void apic_timer_update(APICCommonState *s, int64_t current_time)
 {
+    /*
+     * 在以下使用apic_next_timer():
+     *   - hw/i386/kvm/apic.c|170| <<kvm_get_apic_state>> apic_next_timer(s, s->initial_count_load_time);
+     *   - hw/intc/apic.c|775| <<apic_timer_update>> if (apic_next_timer(s, current_time)) {
+     *   - target/i386/whpx/whpx-apic.c|90| <<whpx_get_apic_state>> apic_next_timer(s, s->initial_count_load_time);
+     */
     if (apic_next_timer(s, current_time)) {
         timer_mod(s->timer, s->next_time);
     } else {
@@ -1192,6 +1198,10 @@ static void apic_class_init(ObjectClass *klass, void *data)
     k->send_msi = apic_send_msi;
 }
 
+/*
+ * TYPE_APIC_COMMON的parent是TYPE_DEVICE
+ * hw/intc/apic_common.c
+ */
 static const TypeInfo apic_info = {
     .name          = TYPE_APIC,
     .instance_size = sizeof(APICCommonState),
diff --git a/hw/intc/apic_common.c b/hw/intc/apic_common.c
index 2a3e878c4..5329009f0 100644
--- a/hw/intc/apic_common.c
+++ b/hw/intc/apic_common.c
@@ -35,6 +35,14 @@
 
 bool apic_report_tpr_access;
 
+/*
+ * 在以下使用cpu_set_apic_base():
+ *   - target/i386/hvf/hvf.c|602| <<hvf_simulate_wrmsr>> r = cpu_set_apic_base(cpu->apic_state, data);
+ *   - target/i386/kvm/kvm.c|5587| <<kvm_arch_post_run>> cpu_set_apic_base(x86_cpu->apic_state, run->apic_base);
+ *   - target/i386/nvmm/nvmm-all.c|618| <<nvmm_handle_wrmsr>> cpu_set_apic_base(x86_cpu->apic_state, val);
+ *   - target/i386/tcg/system/misc_helper.c|158| <<helper_wrmsr>> ret = cpu_set_apic_base(env_archcpu(env)->apic_state, val);
+ *   - target/i386/whpx/whpx-all.c|743| <<whpx_get_registers>> cpu_set_apic_base(x86_cpu->apic_state, vcpu->apic_base);
+ */
 int cpu_set_apic_base(DeviceState *dev, uint64_t val)
 {
     trace_cpu_set_apic_base(val);
@@ -44,12 +52,29 @@ int cpu_set_apic_base(DeviceState *dev, uint64_t val)
         APICCommonClass *info = APIC_COMMON_GET_CLASS(s);
         /* Reset possibly modified xAPIC ID */
         s->id = s->initial_apic_id;
+        /*
+	 * 在以下设置set_base():
+	 *   - hw/i386/kvm/apic.c|359| <<kvm_apic_class_init>> k->set_base = kvm_apic_set_base;
+	 *   - hw/i386/xen/xen_apic.c|84| <<xen_apic_class_init>> k->set_base = xen_apic_set_base;
+	 *   - hw/intc/apic.c|1191| <<apic_class_init>> k->set_base = apic_set_base;
+	 *   - target/i386/whpx/whpx-apic.c|261| <<whpx_apic_class_init>> k->set_base = whpx_apic_set_base;
+	 */
         return info->set_base(s, val);
     }
 
     return 0;
 }
 
+/*
+ * 在以下使用cpu_get_apic_base():
+ *   - target/i386/cpu-system.c|259| <<cpu_is_bsp>> return cpu_get_apic_base(cpu->apic_state) & MSR_IA32_APICBASE_BSP;
+ *   - target/i386/hvf/hvf.c|496| <<hvf_simulate_rdmsr>> val = cpu_get_apic_base(cpu->apic_state);
+ *   - target/i386/kvm/kvm.c|3535| <<kvm_put_sregs>> sregs.apic_base = cpu_get_apic_base(cpu->apic_state);
+ *   - target/i386/kvm/kvm.c|3582| <<kvm_put_sregs2>> sregs.apic_base = cpu_get_apic_base(cpu->apic_state);
+ *   - target/i386/nvmm/nvmm-all.c|571| <<nvmm_handle_rdmsr>> val = cpu_get_apic_base(x86_cpu->apic_state);
+ *   - target/i386/tcg/system/misc_helper.c|346| <<helper_rdmsr>> val = cpu_get_apic_base(env_archcpu(env)->apic_state);
+ *   - target/i386/whpx/whpx-all.c|409| <<whpx_set_registers>> vcpu->apic_base = cpu_get_apic_base(x86_cpu->apic_state);
+ */
 uint64_t cpu_get_apic_base(DeviceState *dev)
 {
     if (dev) {
@@ -62,6 +87,11 @@ uint64_t cpu_get_apic_base(DeviceState *dev)
     }
 }
 
+/*
+ * 在以下使用cpu_is_apic_enabled():
+ *   - hw/i386/x86-cpu.c|47| <<pic_irq_request>> if (cpu_is_apic_enabled(cpu->apic_state) && !kvm_irqchip_in_kernel() &&
+ *   - hw/i386/x86.c|158| <<x86_nmi>> if (cpu_is_apic_enabled(cpu->apic_state)) {
+ */
 bool cpu_is_apic_enabled(DeviceState *dev)
 {
     APICCommonState *s;
@@ -116,12 +146,20 @@ void apic_enable_tpr_access_reporting(DeviceState *dev, bool enable)
     }
 }
 
+/*
+ * 在以下使用apic_enable_vapic():
+ *   - hw/i386/vapic.c|378| <<vapic_enable>> apic_enable_vapic(cpu->apic_state, vapic_paddr);
+ *   - hw/i386/vapic.c|746| <<do_vapic_enable>> apic_enable_vapic(cpu->apic_state, s->vapic_paddr);
+ */
 void apic_enable_vapic(DeviceState *dev, hwaddr paddr)
 {
     APICCommonState *s = APIC_COMMON(dev);
     APICCommonClass *info = APIC_COMMON_GET_CLASS(s);
 
     s->vapic_paddr = paddr;
+    /*
+     * kvm的例子kvm_apic_vapic_base_update()
+     */
     info->vapic_base_update(s);
 }
 
@@ -141,6 +179,12 @@ void apic_deliver_nmi(DeviceState *dev)
     info->external_nmi(s);
 }
 
+/*
+ * 在以下使用apic_next_timer():
+ *   - hw/i386/kvm/apic.c|170| <<kvm_get_apic_state>> apic_next_timer(s, s->initial_count_load_time);
+ *   - hw/intc/apic.c|775| <<apic_timer_update>> if (apic_next_timer(s, current_time)) {
+ *   - target/i386/whpx/whpx-apic.c|90| <<whpx_get_apic_state>> apic_next_timer(s, s->initial_count_load_time);
+ */
 bool apic_next_timer(APICCommonState *s, int64_t current_time)
 {
     int64_t d;
@@ -233,6 +277,10 @@ void apic_init_reset(DeviceState *dev)
     }
 }
 
+/*
+ * 在以下调用apic_designate_bsp():
+ *   - target/i386/cpu.c|7598| <<x86_cpu_reset_hold>> apic_designate_bsp(cpu->apic_state, cs->cpu_index == 0);
+ */
 void apic_designate_bsp(DeviceState *dev, bool bsp)
 {
     if (dev == NULL) {
@@ -247,6 +295,10 @@ void apic_designate_bsp(DeviceState *dev, bool bsp)
     }
 }
 
+/*
+ * 在以下使用apic_reset_common():
+ *   - hw/intc/apic_common.c|508| <<apic_common_class_init>> device_class_set_legacy_reset(dc, apic_reset_common);
+ */
 static void apic_reset_common(DeviceState *dev)
 {
     APICCommonState *s = APIC_COMMON(dev);
@@ -254,6 +306,19 @@ static void apic_reset_common(DeviceState *dev)
     uint32_t bsp;
 
     bsp = s->apicbase & MSR_IA32_APICBASE_BSP;
+    /*
+     * 在以下设置APICCommonState->apicbase:
+     *   - hw/intc/apic_common.c|411| <<global>> VMSTATE_UINT32(apicbase, APICCommonState),
+     *   - hw/i386/kvm/apic.c|185| <<kvm_apic_set_base>> s->apicbase = val;
+     *   - hw/intc/apic.c|353| <<apic_set_base>> s->apicbase = (val & MSR_IA32_APICBASE_BASE) |
+     *   - hw/intc/apic.c|364| <<apic_set_base>> s->apicbase |= MSR_IA32_APICBASE_ENABLE;
+     *   - hw/intc/apic.c|372| <<apic_set_base>> s->apicbase |= MSR_IA32_APICBASE_EXTD;
+     *   - hw/intc/apic_common.c|263| <<apic_designate_bsp>> s->apicbase |= MSR_IA32_APICBASE_BSP;
+     *   - hw/intc/apic_common.c|265| <<apic_designate_bsp>> s->apicbase &= ~MSR_IA32_APICBASE_BSP;
+     *   - hw/intc/apic_common.c|276| <<apic_reset_common>> s->apicbase = APIC_DEFAULT_ADDRESS | bsp | MSR_IA32_APICBASE_ENABLE;
+     *   - target/i386/cpu-apic.c|59| <<x86_cpu_apic_create>> apic->apicbase = APIC_DEFAULT_ADDRESS | MSR_IA32_APICBASE_ENABLE;
+     *   - target/i386/whpx/whpx-apic.c|95| <<whpx_apic_set_base>> s->apicbase = val;
+     */
     s->apicbase = APIC_DEFAULT_ADDRESS | bsp | MSR_IA32_APICBASE_ENABLE;
     s->id = s->initial_apic_id;
 
@@ -297,6 +362,15 @@ static void apic_common_realize(DeviceState *dev, Error **errp)
     if (s->legacy_instance_id) {
         instance_id = VMSTATE_INSTANCE_ID_ANY;
     }
+    /*
+     * 在以下使用vmstate_register_with_alias_id():
+     *   -  hw/core/qdev.c|517| <<device_set_realized>> if (vmstate_register_with_alias_id(VMSTATE_IF(dev),
+     *              VMSTATE_INSTANCE_ID_ANY, qdev_get_vmsd(dev), dev, dev->instance_id_alias,
+     *              dev->alias_required_for_version, &local_err) < 0) {
+     *   - hw/intc/apic_common.c|303| <<apic_common_realize>> vmstate_register_with_alias_id(NULL, instance_id, &vmstate_apic_common, s, -1, 0, NULL);
+     *   - include/migration/vmstate.h|1228| <<vmstate_register>> return vmstate_register_with_alias_id(obj, instance_id, vmsd, opaque, -1, 0, NULL);
+     *   - include/migration/vmstate.h|1256| <<vmstate_register_any>> return vmstate_register_with_alias_id(obj, VMSTATE_INSTANCE_ID_ANY, vmsd, opaque, -1, 0, NULL);
+     */
     vmstate_register_with_alias_id(NULL, instance_id, &vmstate_apic_common,
                                    s, -1, 0, NULL);
 
@@ -426,6 +500,41 @@ static void apic_common_get_id(Object *obj, Visitor *v, const char *name,
     visit_type_uint32(v, name, &value, errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  apic_common_set_id (obj=0x55555755d140, v=0x55555778f340, name=0x555556393d55 "id", opaque=0x0, errp=0x5555573a2118 <error_abort>) at ../hw/intc/apic_common.c:431
+ * #1  0x0000555555f26c07 in object_property_set (obj=0x55555755d140, name=0x555556393d55 "id", v=0x55555778f340, errp=0x5555573a2118 <error_abort>) at ../qom/object.c:1449
+ * #2  0x0000555555f2ba94 in object_property_set_qobject (obj=0x55555755d140, name=0x555556393d55 "id", value=0x55555775d1d0, errp=0x5555573a2118 <error_abort>)
+ *     at ../qom/qom-qobject.c:28
+ * #3  0x0000555555f27138 in object_property_set_int (obj=0x55555755d140, name=0x555556393d55 "id", value=1, errp=0x5555573a2118 <error_abort>) at ../qom/object.c:1552
+ * #4  0x0000555555f1bc8a in qdev_prop_set_uint32 (dev=0x55555755d140, name=0x555556393d55 "id", value=1) at ../hw/core/qdev-properties.c:851
+ * #5  0x0000555555d1a64e in x86_cpu_apic_create (cpu=0x555557785d90, errp=0x7fffffffd458) at ../target/i386/cpu-apic.c:66
+ * #6  0x0000555555daaf63 in x86_cpu_realizefn (dev=0x555557785d90, errp=0x7fffffffd520) at ../target/i386/cpu.c:8342
+ * #7  0x0000555555da3bf3 in max_x86_cpu_realize (dev=0x555557785d90, errp=0x7fffffffd520) at ../target/i386/cpu.c:5689
+ * #8  0x0000555555f1e213 in device_set_realized (obj=0x555557785d90, value=true, errp=0x7fffffffd630) at ../hw/core/qdev.c:494
+ * #9  0x0000555555f29192 in property_set_bool (obj=0x555557785d90, v=0x55555778ed20, name=0x5555563e9969 "realized", opaque=0x555557460d40, errp=0x7fffffffd630)
+ *     at ../qom/object.c:2374
+ * #10 0x0000555555f26c07 in object_property_set (obj=0x555557785d90, name=0x5555563e9969 "realized", v=0x55555778ed20, errp=0x7fffffffd630) at ../qom/object.c:1449
+ * #11 0x0000555555f2ba94 in object_property_set_qobject (obj=0x555557785d90, name=0x5555563e9969 "realized", value=0x55555778c910, errp=0x5555573a2120 <error_fatal>)
+ *     at ../qom/qom-qobject.c:28
+ * #12 0x0000555555f26fac in object_property_set_bool (obj=0x555557785d90, name=0x5555563e9969 "realized", value=true, errp=0x5555573a2120 <error_fatal>) at ../qom/object.c:1519
+ * #13 0x0000555555f1d90b in qdev_realize (dev=0x555557785d90, bus=0x0, errp=0x5555573a2120 <error_fatal>) at ../hw/core/qdev.c:276
+ * #14 0x0000555555d591ec in x86_cpu_new (x86ms=0x5555576d8c50, apic_id=1, errp=0x5555573a2120 <error_fatal>) at ../hw/i386/x86-common.c:63
+ * #15 0x0000555555d59366 in x86_cpus_init (x86ms=0x5555576d8c50, default_cpu_version=1) at ../hw/i386/x86-common.c:114
+ * #16 0x0000555555d612c5 in pc_q35_init (machine=0x5555576d8c50) at ../hw/i386/pc_q35.c:191
+ * #17 0x0000555555d61c95 in pc_q35_machine_10_0_init (machine=0x5555576d8c50) at ../hw/i386/pc_q35.c:369
+ * #18 0x000055555597d861 in machine_run_board_init (machine=0x5555576d8c50, mem_path=0x0, errp=0x7fffffffd900) at ../hw/core/machine.c:1682
+ * #19 0x0000555555c35477 in qemu_init_board () at ../system/vl.c:2711
+ * #20 0x0000555555c3581c in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2807
+ * #21 0x0000555555c38346 in qemu_init (argc=21, argv=0x7fffffffdc28) at ../system/vl.c:3843
+ * #22 0x00005555560d2905 in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:71
+ *
+ * 只在下面调用apic_common_set_id():
+ *
+ * 486     object_property_add(obj, "id", "uint32",
+ * 487                         apic_common_get_id,
+ * 488                         apic_common_set_id, NULL, NULL);
+ */
 static void apic_common_set_id(Object *obj, Visitor *v, const char *name,
                                void *opaque, Error **errp)
 {
diff --git a/hw/intc/kvm_irqcount.c b/hw/intc/kvm_irqcount.c
index 2ef8a83a7..c3b436e11 100644
--- a/hw/intc/kvm_irqcount.c
+++ b/hw/intc/kvm_irqcount.c
@@ -19,6 +19,16 @@
 #include "hw/intc/kvm_irqcount.h"
 #include "trace.h"
 
+/*
+ * 在以下使用kvm_irq_delivered:
+ *   - hw/intc/kvm_irqcount.c|22| <<global>> static int kvm_irq_delivered;
+ *   - hw/intc/kvm_irqcount.c|26| <<kvm_report_irq_delivered>> kvm_irq_delivered += delivered;
+ *   - hw/intc/kvm_irqcount.c|28| <<kvm_report_irq_delivered>> trace_kvm_report_irq_delivered(kvm_irq_delivered);
+ *   - hw/intc/kvm_irqcount.c|38| <<kvm_reset_irq_delivered>> volatile int k_i_d = kvm_irq_delivered;
+ *   - hw/intc/kvm_irqcount.c|41| <<kvm_reset_irq_delivered>> kvm_irq_delivered = 0;
+ *   - hw/intc/kvm_irqcount.c|46| <<kvm_get_irq_delivered>> trace_kvm_get_irq_delivered(kvm_irq_delivered);
+ *   - hw/intc/kvm_irqcount.c|48| <<kvm_get_irq_delivered>> return kvm_irq_delivered;
+ */
 static int kvm_irq_delivered;
 
 void kvm_report_irq_delivered(int delivered)
diff --git a/hw/isa/lpc_ich9.c b/hw/isa/lpc_ich9.c
index dcb0ac284..a1913a35b 100644
--- a/hw/isa/lpc_ich9.c
+++ b/hw/isa/lpc_ich9.c
@@ -420,6 +420,10 @@ static void smi_features_ok_callback(void *opaque)
     lpc->smi_features_ok = 1;
 }
 
+/*
+ * 在以下使用ich9_lpc_pm_init():
+ *   - hw/isa/lpc_ich9.c|765| <<ich9_lpc_realize>> ich9_lpc_pm_init(lpc);
+ */
 static void ich9_lpc_pm_init(ICH9LPCState *lpc)
 {
     qemu_irq sci_irq;
diff --git a/hw/net/eepro100.c b/hw/net/eepro100.c
index 29a39865a..b88ac5fd8 100644
--- a/hw/net/eepro100.c
+++ b/hw/net/eepro100.c
@@ -1885,6 +1885,22 @@ static void e100_nic_realize(PCIDevice *pci_dev, Error **errp)
 
     s->vmstate = g_memdup(&vmstate_eepro100, sizeof(vmstate_eepro100));
     s->vmstate->name = qemu_get_queue(s->nic)->model;
+    /*
+     * 在以下使用vmstate_register_any():
+     *   - audio/audio.c|1787| <<audio_init>> vmstate_register_any(NULL, &vmstate_audio, s);
+     *   - backends/dbus-vmstate.c|429| <<dbus_vmstate_complete>> if (vmstate_register_any(VMSTATE_IF(self), &dbus_vmstate, self) < 0) {
+     *   - backends/tpm/tpm_emulator.c|1009| <<tpm_emulator_inst_init>> vmstate_register_any(NULL, &vmstate_tpm_emulator, obj);
+     *   - hw/display/vmware_vga.c|1265| <<vmsvga_init>> vmstate_register_any(NULL, &vmstate_vga_common, &s->vga);
+     *   - hw/i2c/core.c|66| <<i2c_init_bus>> vmstate_register_any(NULL, &vmstate_i2c_bus, bus);
+     *   - hw/ide/isa.c|76| <<isa_ide_realizefn>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_ide_isa, s);
+     *   - hw/input/adb.c|250| <<adb_bus_realize>> vmstate_register_any(NULL, &vmstate_adb_bus, adb_bus);
+     *   - hw/net/eepro100.c|1888| <<e100_nic_realize>> vmstate_register_any(VMSTATE_IF(&pci_dev->qdev), s->vmstate, s);
+     *   - hw/nvram/eeprom93xx.c|324| <<eeprom93xx_new>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_eeprom, eeprom);
+     *   - hw/pci/pci.c|178| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+     *   - hw/ppc/spapr_nvdimm.c|879| <<spapr_nvdimm_realize>> vmstate_register_any(NULL, &vmstate_spapr_nvdimm_states, dimm);
+     *   - hw/timer/arm_timer.c|184| <<arm_timer_init>> vmstate_register_any(NULL, &vmstate_arm_timer, s);
+     *   - hw/virtio/virtio-mem.c|1122| <<virtio_mem_device_realize>> vmstate_register_any(VMSTATE_IF(vmem), &vmstate_virtio_mem_device_early, vmem);
+     */
     vmstate_register_any(VMSTATE_IF(&pci_dev->qdev), s->vmstate, s);
 }
 
diff --git a/hw/net/vhost_net.c b/hw/net/vhost_net.c
index 891f235a0..03d350128 100644
--- a/hw/net/vhost_net.c
+++ b/hw/net/vhost_net.c
@@ -351,6 +351,33 @@ struct vhost_net *vhost_net_init(VhostNetOptions *options)
         net->dev.vq_index = net->nc->queue_index * net->dev.nvqs;
     }
 
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     r = vhost_dev_init(&net->dev, options->opaque,
                        options->backend_type, options->busyloop_timeout,
                        &local_err);
@@ -583,6 +610,11 @@ err:
     return r;
 }
 
+/*
+ * 在以下使用vhost_net_stop():
+ *   - hw/net/virtio-net.c|318| <<virtio_net_vhost_status>> vhost_net_stop(vdev, n->nic->ncs, queue_pairs, cvq);
+ *   - net/vhost-vdpa.c|340| <<vhost_vdpa_net_log_global_enable>> vhost_net_stop(vdev, n->nic->ncs, data_queue_pairs, cvq);
+ */
 void vhost_net_stop(VirtIODevice *dev, NetClientState *ncs,
                     int data_queue_pairs, int cvq)
 {
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index d6b77d4fb..b0eb2d462 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -3521,6 +3521,20 @@ static void nvme_flush_ns_cb(void *opaque, int ret)
         trace_pci_nvme_flush_ns(iocb->nsid);
 
         iocb->ns = NULL;
+        /*
+	 * 在以下使用blk_aio_flush():
+	 *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+	 *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+	 *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+	 *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+	 *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+	 *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+	 *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 */
         iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
         return;
     }
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index a757939cf..fbea34a4d 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -266,6 +266,13 @@ static inline uint32_t fw_cfg_max_entry(const FWCfgState *s)
     return FW_CFG_FILE_FIRST + fw_cfg_file_slots(s);
 }
 
+/*
+ * 在以下使用fw_cfg_select():
+ *   - hw/nvram/fw_cfg.c|359| <<fw_cfg_dma_transfer>> fw_cfg_select(s, dma.control >> 16);
+ *   - hw/nvram/fw_cfg.c|491| <<fw_cfg_ctl_mem_write>> fw_cfg_select(opaque, (uint16_t)value);
+ *   - hw/nvram/fw_cfg.c|509| <<fw_cfg_comb_write>> fw_cfg_select(opaque, (uint16_t)value);
+ *   - hw/nvram/fw_cfg.c|560| <<fw_cfg_reset>> fw_cfg_select(s, FW_CFG_SIGNATURE);
+ */
 static int fw_cfg_select(FWCfgState *s, uint16_t key)
 {
     int arch, ret;
@@ -280,6 +287,20 @@ static int fw_cfg_select(FWCfgState *s, uint16_t key)
         ret = 1;
         /* entry successfully selected, now run callback if present */
         arch = !!(key & FW_CFG_ARCH_LOCAL);
+        /*
+	 * struct FWCfgEntry {
+	 *     uint32_t len;
+	 *     bool allow_write;
+	 *     uint8_t *data;
+	 *     void *callback_opaque;
+	 *     FWCfgCallback select_cb;
+	 *     FWCfgWriteCallback write_cb;
+	 * };
+	 *
+	 *
+	 * struct FWCfgState:
+	 * -> FWCfgEntry *entries[2];
+	 */
         e = &s->entries[arch][key & FW_CFG_ENTRY_MASK];
         if (e->select_cb) {
             e->select_cb(e->callback_opaque);
@@ -498,6 +519,14 @@ static bool fw_cfg_ctl_mem_valid(void *opaque, hwaddr addr,
     return is_write && size == 2;
 }
 
+/*
+ * static const MemoryRegionOps fw_cfg_comb_mem_ops = {
+ *     .read = fw_cfg_data_read,
+ *     .write = fw_cfg_comb_write,
+ *     .endianness = DEVICE_LITTLE_ENDIAN,
+ *     .valid.accepts = fw_cfg_comb_valid,
+ * };
+ */
 static void fw_cfg_comb_write(void *opaque, hwaddr addr,
                               uint64_t value, unsigned size)
 {
@@ -615,6 +644,28 @@ static bool fw_cfg_acpi_mr_restore(void *opaque)
     return s->acpi_mr_restore && !mr_aligned;
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_ram_resize (block=0x5555582c8820, newsize=4096, errp=0x5555573a2118 <error_abort>) at ../system/physmem.c:1720
+ * #1  0x0000555555ebf3e9 in memory_region_ram_resize (mr=0x5555582a00e0, newsize=4096, errp=0x5555573a2118 <error_abort>) at ../system/memory.c:2476
+ * #2  0x0000555555ac2db8 in fw_cfg_update_mr (s=0x555557c2ac80, key=41, size=4096) at ../hw/nvram/fw_cfg.c:631
+ * #3  0x0000555555ac2f08 in fw_cfg_acpi_mr_restore_post_load (opaque=0x555557c2ac80, version_id=1) at ../hw/nvram/fw_cfg.c:647
+ * #4  0x0000555555f83d72 in vmstate_load_state (f=0x555557a5bb00, vmsd=0x5555571d0ce0 <vmstate_fw_cfg_acpi_mr>, opaque=0x555557c2ac80, version_id=1)
+ *     at ../migration/vmstate.c:234
+ * #5  0x0000555555f84d35 in vmstate_subsection_load (f=0x555557a5bb00, vmsd=0x5555571d0d60 <vmstate_fw_cfg>, opaque=0x555557c2ac80)
+ *     at ../migration/vmstate.c:608
+ * #6  0x0000555555f83d30 in vmstate_load_state (f=0x555557a5bb00, vmsd=0x5555571d0d60 <vmstate_fw_cfg>, opaque=0x555557c2ac80, version_id=2)
+ *     at ../migration/vmstate.c:228
+ * #7  0x0000555555c807aa in vmstate_load (f=0x555557a5bb00, se=0x555557c2d810) at ../migration/savevm.c:972
+ * #8  0x0000555555c8442a in qemu_loadvm_section_start_full (f=0x555557a5bb00, type=4 '\004') at ../migration/savevm.c:2701
+ * #9  0x0000555555c84fe1 in qemu_loadvm_state_main (f=0x555557a5bb00, mis=0x55555745ce40) at ../migration/savevm.c:3007
+ * #10 0x0000555555c851b0 in qemu_loadvm_state (f=0x555557a5bb00) at ../migration/savevm.c:3094
+ * #11 0x0000555555c6310c in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:866
+ * #12 0x00005555561cda9d in coroutine_trampoline (i0=1466944864, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #13 0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #14 0x00007fffffffc7c0 in ?? ()
+ * #15 0x0000000000000000 in ?? ()
+ */
 static void fw_cfg_update_mr(FWCfgState *s, uint16_t key, size_t size)
 {
     MemoryRegion *mr;
@@ -625,12 +676,46 @@ static void fw_cfg_update_mr(FWCfgState *s, uint16_t key, size_t size)
     key &= FW_CFG_ENTRY_MASK;
     assert(key < fw_cfg_max_entry(s));
 
+    /*
+     * FWCfgState *s:
+     * -> FWCfgEntry *entries[2];
+     */
     ptr = s->entries[arch][key].data;
     mr = memory_region_from_host(ptr, &offset);
 
+    /*
+     * 在以下调用memory_region_ram_resize():
+     *   - hw/arm/virt-acpi-build.c|1035| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/i386/acpi-build.c|2642| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/loongarch/virt-acpi-build.c|644| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/nvram/fw_cfg.c|631| <<fw_cfg_update_mr>> memory_region_ram_resize(mr, size, &error_abort);
+     *   - hw/riscv/virt-acpi-build.c|746| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+     */
     memory_region_ram_resize(mr, size, &error_abort);
 }
 
+/*
+ * (gdb) bt
+ * #0  qemu_ram_resize (block=0x5555582c8820, newsize=4096, errp=0x5555573a2118 <error_abort>) at ../system/physmem.c:1720
+ * #1  0x0000555555ebf3e9 in memory_region_ram_resize (mr=0x5555582a00e0, newsize=4096, errp=0x5555573a2118 <error_abort>) at ../system/memory.c:2476
+ * #2  0x0000555555ac2db8 in fw_cfg_update_mr (s=0x555557c2ac80, key=41, size=4096) at ../hw/nvram/fw_cfg.c:631
+ * #3  0x0000555555ac2f08 in fw_cfg_acpi_mr_restore_post_load (opaque=0x555557c2ac80, version_id=1) at ../hw/nvram/fw_cfg.c:647
+ * #4  0x0000555555f83d72 in vmstate_load_state (f=0x555557a5bb00, vmsd=0x5555571d0ce0 <vmstate_fw_cfg_acpi_mr>, opaque=0x555557c2ac80, version_id=1)
+ *     at ../migration/vmstate.c:234
+ * #5  0x0000555555f84d35 in vmstate_subsection_load (f=0x555557a5bb00, vmsd=0x5555571d0d60 <vmstate_fw_cfg>, opaque=0x555557c2ac80)
+ *     at ../migration/vmstate.c:608
+ * #6  0x0000555555f83d30 in vmstate_load_state (f=0x555557a5bb00, vmsd=0x5555571d0d60 <vmstate_fw_cfg>, opaque=0x555557c2ac80, version_id=2)
+ *     at ../migration/vmstate.c:228
+ * #7  0x0000555555c807aa in vmstate_load (f=0x555557a5bb00, se=0x555557c2d810) at ../migration/savevm.c:972
+ * #8  0x0000555555c8442a in qemu_loadvm_section_start_full (f=0x555557a5bb00, type=4 '\004') at ../migration/savevm.c:2701
+ * #9  0x0000555555c84fe1 in qemu_loadvm_state_main (f=0x555557a5bb00, mis=0x55555745ce40) at ../migration/savevm.c:3007
+ * #10 0x0000555555c851b0 in qemu_loadvm_state (f=0x555557a5bb00) at ../migration/savevm.c:3094
+ * #11 0x0000555555c6310c in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:866
+ * #12 0x00005555561cda9d in coroutine_trampoline (i0=1466944864, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #13 0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #14 0x00007fffffffc7c0 in ?? ()
+ * #15 0x0000000000000000 in ?? ()
+ */
 static int fw_cfg_acpi_mr_restore_post_load(void *opaque, int version_id)
 {
     FWCfgState *s = opaque;
@@ -644,6 +729,24 @@ static int fw_cfg_acpi_mr_restore_post_load(void *opaque, int version_id)
         if (!strcmp(s->files->f[i].name, ACPI_BUILD_TABLE_FILE)) {
             fw_cfg_update_mr(s, FW_CFG_FILE_FIRST + i, s->table_mr_size);
         } else if (!strcmp(s->files->f[i].name, ACPI_BUILD_LOADER_FILE)) {
+            /*
+	     * 在以下使用ACPI_BUILD_LOADER_FILE:
+             *   - include/hw/acpi/aml-build.h|13| <<global>> #define ACPI_BUILD_LOADER_FILE "etc/table-loader"
+             *   - hw/acpi/utils.c|37| <<acpi_add_rom_blob>> } else if (!strcmp(name, ACPI_BUILD_LOADER_FILE)) {
+             *   - hw/arm/virt-acpi-build.c|1145| <<virt_acpi_setup>> build_state->linker_mr =
+             *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+             *   - hw/i386/acpi-build.c|2774| <<acpi_setup>> build_state->linker_mr =
+             *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+             *   - hw/i386/acpi-microvm.c|263| <<acpi_setup_microvm>> acpi_add_rom_blob(acpi_build_no_update, NULL,
+             *       tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+             *   - hw/loongarch/virt-acpi-build.c|724| <<virt_acpi_setup>> build_state->linker_mr =
+             *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+             *   - hw/nvram/fw_cfg.c|654| <<fw_cfg_acpi_mr_restore_post_load>>
+	     *       } else if (!strcmp(s->files->f[i].name, ACPI_BUILD_LOADER_FILE)) {
+             *   - hw/nvram/fw_cfg.c|894| <<fw_cfg_acpi_mr_save>> } else if (!strcmp(filename, ACPI_BUILD_LOADER_FILE)) {
+             *   - hw/riscv/virt-acpi-build.c|810| <<virt_acpi_setup>> build_state->linker_mr =
+             *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+	     */
             fw_cfg_update_mr(s, FW_CFG_FILE_FIRST + i, s->linker_mr_size);
         } else if (!strcmp(s->files->f[i].name, ACPI_BUILD_RSDP_FILE)) {
             fw_cfg_update_mr(s, FW_CFG_FILE_FIRST + i, s->rsdp_mr_size);
@@ -693,6 +796,69 @@ static const VMStateDescription vmstate_fw_cfg = {
     }
 };
 
+/*
+ * 很多调用, 其中之一.
+ * (gdb) bt
+ * #0  fw_cfg_add_bytes_callback (s=0x555557922180, key=32, select_cb=0x555555d89edf <acpi_build_update>, write_cb=0x0, callback_opaque=0x5555578392b0,
+ *     data=0x7ffcb4400000, len=131072, read_only=true) at ../hw/nvram/fw_cfg.c:703
+ * #1  0x0000555555ac3e1d in fw_cfg_add_file_callback (s=0x555557922180, filename=0x5555563a8263 "etc/acpi/tables", select_cb=0x555555d89edf <acpi_build_update>,
+ *     write_cb=0x0, callback_opaque=0x5555578392b0, data=0x7ffcb4400000, len=131072, read_only=true) at ../hw/nvram/fw_cfg.c:981
+ * #2  0x0000555555974d46 in rom_add_blob (name=0x5555563a8263 "etc/acpi/tables", blob=0x555558112d70, len=131072, max_len=2097152, addr=18446744073709551615,
+ *     fw_file_name=0x5555563a8263 "etc/acpi/tables", fw_callback=0x555555d89edf <acpi_build_update>, callback_opaque=0x5555578392b0, as=0x0, read_only=true)
+ *     at ../hw/core/loader.c:1156
+ * #3  0x0000555555917d63 in acpi_add_rom_blob (update=0x555555d89edf <acpi_build_update>, opaque=0x5555578392b0, blob=0x555557459ef0,
+ *     name=0x5555563a8263 "etc/acpi/tables") at ../hw/acpi/utils.c:46
+ * #4  0x0000555555d8a143 in acpi_setup () at ../hw/i386/acpi-build.c:2720
+ * #5  0x0000555555d7bb31 in pc_machine_done (notifier=0x5555576d87c0, data=0x0) at ../hw/i386/pc.c:638
+ * #6  0x00005555561b6024 in notifier_list_notify (list=0x55555737b390 <machine_init_done_notifiers>, data=0x0) at ../util/notify.c:39
+ * #7  0x000055555597d9f4 in qdev_machine_creation_done () at ../hw/core/machine.c:1745
+ * #8  0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #9  0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #10 0x0000555555c38346 in qemu_init (argc=39, argv=0x7fffffffd748) at ../system/vl.c:3843
+ * #11 0x00005555560d2905 in main (argc=39, argv=0x7fffffffd748) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  fw_cfg_add_bytes_callback (s=0x555557922180, key=38, select_cb=0x555555d89edf <acpi_build_update>, write_cb=0x0, callback_opaque=0x5555578392b0,
+ *     data=0x7ffcb4200000, len=4096, read_only=true) at ../hw/nvram/fw_cfg.c:703
+ * #1  0x0000555555ac3e1d in fw_cfg_add_file_callback (s=0x555557922180, filename=0x5555563a82e5 "etc/table-loader", select_cb=0x555555d89edf <acpi_build_update>,
+ *     write_cb=0x0, callback_opaque=0x5555578392b0, data=0x7ffcb4200000, len=4096, read_only=true) at ../hw/nvram/fw_cfg.c:981
+ * #2  0x0000555555974d46 in rom_add_blob (name=0x5555563a82e5 "etc/table-loader", blob=0x555557858c70, len=4096, max_len=65536, addr=18446744073709551615,
+ *     fw_file_name=0x5555563a82e5 "etc/table-loader", fw_callback=0x555555d89edf <acpi_build_update>, callback_opaque=0x5555578392b0, as=0x0, read_only=true)
+ *     at ../hw/core/loader.c:1156
+ * #3  0x0000555555917d63 in acpi_add_rom_blob (update=0x555555d89edf <acpi_build_update>, opaque=0x5555578392b0, blob=0x55555745a210,
+ *     name=0x5555563a82e5 "etc/table-loader") at ../hw/acpi/utils.c:46
+ * #4  0x0000555555d8a1a2 in acpi_setup () at ../hw/i386/acpi-build.c:2726
+ * #5  0x0000555555d7bb31 in pc_machine_done (notifier=0x5555576d87c0, data=0x0) at ../hw/i386/pc.c:638
+ * #6  0x00005555561b6024 in notifier_list_notify (list=0x55555737b390 <machine_init_done_notifiers>, data=0x0) at ../util/notify.c:39
+ * #7  0x000055555597d9f4 in qdev_machine_creation_done () at ../hw/core/machine.c:1745
+ * #8  0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #9  0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #10 0x0000555555c38346 in qemu_init (argc=39, argv=0x7fffffffd748) at ../system/vl.c:3843
+ * #11 0x00005555560d2905 in main (argc=39, argv=0x7fffffffd748) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  fw_cfg_add_bytes_callback (s=0x555557922180, key=32, select_cb=0x555555d89edf <acpi_build_update>, write_cb=0x0, callback_opaque=0x5555578392b0,
+ *     data=0x7ffc9ec00000, len=20, read_only=true) at ../hw/nvram/fw_cfg.c:703
+ * #1  0x0000555555ac3e1d in fw_cfg_add_file_callback (s=0x555557922180, filename=0x5555563a8309 "etc/acpi/rsdp", select_cb=0x555555d89edf <acpi_build_update>,
+ *     write_cb=0x0, callback_opaque=0x5555578392b0, data=0x7ffc9ec00000, len=20, read_only=true) at ../hw/nvram/fw_cfg.c:981
+ * #2  0x0000555555974d46 in rom_add_blob (name=0x5555563a8309 "etc/acpi/rsdp", blob=0x55555785ec30, len=20, max_len=4096, addr=18446744073709551615,
+ *     fw_file_name=0x5555563a8309 "etc/acpi/rsdp", fw_callback=0x555555d89edf <acpi_build_update>, callback_opaque=0x5555578392b0, as=0x0, read_only=true)
+ *     at ../hw/core/loader.c:1156
+ * #3  0x0000555555917d63 in acpi_add_rom_blob (update=0x555555d89edf <acpi_build_update>, opaque=0x5555578392b0, blob=0x555557459ec0,
+ *     name=0x5555563a8309 "etc/acpi/rsdp") at ../hw/acpi/utils.c:46
+ * #4  0x0000555555d8a2b5 in acpi_setup () at ../hw/i386/acpi-build.c:2751
+ * #5  0x0000555555d7bb31 in pc_machine_done (notifier=0x5555576d87c0, data=0x0) at ../hw/i386/pc.c:638
+ * #6  0x00005555561b6024 in notifier_list_notify (list=0x55555737b390 <machine_init_done_notifiers>, data=0x0) at ../util/notify.c:39
+ * #7  0x000055555597d9f4 in qdev_machine_creation_done () at ../hw/core/machine.c:1745
+ * #8  0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #9  0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #10 0x0000555555c38346 in qemu_init (argc=39, argv=0x7fffffffd748) at ../system/vl.c:3843
+ * #11 0x00005555560d2905 in main (argc=39, argv=0x7fffffffd748) at ../system/main.c:71
+ *
+ * 在以下使用fw_cfg_add_bytes_callback():
+ *   - hw/nvram/fw_cfg.c|814| <<fw_cfg_add_bytes>> fw_cfg_add_bytes_callback(s, key, NULL, NULL, NULL, data, len, true);
+ *   - hw/nvram/fw_cfg.c|1073| <<fw_cfg_add_file_callback>> fw_cfg_add_bytes_callback(s, FW_CFG_FILE_FIRST + index,
+ */
 static void fw_cfg_add_bytes_callback(FWCfgState *s, uint16_t key,
                                       FWCfgCallback select_cb,
                                       FWCfgWriteCallback write_cb,
@@ -884,6 +1050,24 @@ static void fw_cfg_acpi_mr_save(FWCfgState *s, const char *filename, size_t len)
     if (!strcmp(filename, ACPI_BUILD_TABLE_FILE)) {
         s->table_mr_size = len;
     } else if (!strcmp(filename, ACPI_BUILD_LOADER_FILE)) {
+        /*
+	 * 在以下使用ACPI_BUILD_LOADER_FILE:
+	 *   - include/hw/acpi/aml-build.h|13| <<global>> #define ACPI_BUILD_LOADER_FILE "etc/table-loader"
+	 *   - hw/acpi/utils.c|37| <<acpi_add_rom_blob>> } else if (!strcmp(name, ACPI_BUILD_LOADER_FILE)) {
+	 *   - hw/arm/virt-acpi-build.c|1145| <<virt_acpi_setup>> build_state->linker_mr =
+	 *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+	 *   - hw/i386/acpi-build.c|2774| <<acpi_setup>> build_state->linker_mr =
+	 *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+	 *   - hw/i386/acpi-microvm.c|263| <<acpi_setup_microvm>> acpi_add_rom_blob(acpi_build_no_update, NULL,
+         *       tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+         *   - hw/loongarch/virt-acpi-build.c|724| <<virt_acpi_setup>> build_state->linker_mr =
+         *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+         *   - hw/nvram/fw_cfg.c|654| <<fw_cfg_acpi_mr_restore_post_load>>
+         *       } else if (!strcmp(s->files->f[i].name, ACPI_BUILD_LOADER_FILE)) {
+         *   - hw/nvram/fw_cfg.c|894| <<fw_cfg_acpi_mr_save>> } else if (!strcmp(filename, ACPI_BUILD_LOADER_FILE)) {
+         *   - hw/riscv/virt-acpi-build.c|810| <<virt_acpi_setup>> build_state->linker_mr =
+         *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+	 */
         s->linker_mr_size = len;
     } else if (!strcmp(filename, ACPI_BUILD_RSDP_FILE)) {
         s->rsdp_mr_size = len;
diff --git a/hw/pci-bridge/pci_expander_bridge.c b/hw/pci-bridge/pci_expander_bridge.c
index 3396ab4bd..dfa52cfa7 100644
--- a/hw/pci-bridge/pci_expander_bridge.c
+++ b/hw/pci-bridge/pci_expander_bridge.c
@@ -357,6 +357,25 @@ static bool pxb_dev_realize_common(PCIDevice *dev, enum BusType type,
 
     ds = qdev_new(type == CXL ? TYPE_PXB_CXL_HOST : TYPE_PXB_HOST);
     if (type == PCIE) {
+        /*
+	 * 在以下使用pci_root_bus_new():
+	 *   - hw/pci-bridge/pci_expander_bridge.c|360| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+	 *             dev_name, NULL, NULL, 0, TYPE_PXB_PCIE_BUS);
+	 *   - hw/pci-bridge/pci_expander_bridge.c|362| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+	 *             dev_name, NULL, NULL, 0, TYPE_PXB_CXL_BUS);
+	 *   - hw/pci-bridge/pci_expander_bridge.c|366| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+	 *             "pxb-internal", NULL, NULL, 0, TYPE_PXB_BUS);
+	 *   - hw/pci-host/gt64120.c|1193| <<gt64120_realize>> phb->bus = pci_root_bus_new(dev, "pci",
+	 *             &s->pci0_mem, get_system_io(), PCI_DEVFN(18, 0), TYPE_PCI_BUS);
+	 *   - hw/pci-host/i440fx.c|270| <<i440fx_pcihost_realize>> b = pci_root_bus_new(dev, NULL,
+	 *             s->pci_address_space, s->io_memory, 0, TYPE_PCI_BUS);
+	 *   - hw/pci-host/q35.c|65| <<q35_host_realize>> pci->bus = pci_root_bus_new(DEVICE(s), "pcie.0",
+	 *             s->mch.pci_address_space, s->mch.address_space_io, 0, TYPE_PCIE_BUS);
+	 *   - hw/pci-host/remote.c|44| <<remote_pcihost_realize>> pci->bus = pci_root_bus_new(DEVICE(s),
+	 *             "remote-pci", s->mr_pci_mem, s->mr_sys_io, 0, TYPE_PCIE_BUS);
+	 *   - hw/pci/pci.c|746| <<pci_register_root_bus>> bus = pci_root_bus_new(parent, name, mem, io,
+	 *             devfn_min, typename);
+	 */
         bus = pci_root_bus_new(ds, dev_name, NULL, NULL, 0, TYPE_PXB_PCIE_BUS);
     } else if (type == CXL) {
         bus = pci_root_bus_new(ds, dev_name, NULL, NULL, 0, TYPE_PXB_CXL_BUS);
diff --git a/hw/pci-host/gpex-acpi.c b/hw/pci-host/gpex-acpi.c
index e8b4c64c5..8c5a4ca8a 100644
--- a/hw/pci-host/gpex-acpi.c
+++ b/hw/pci-host/gpex-acpi.c
@@ -126,6 +126,13 @@ static void acpi_dsdt_add_pci_osc(Aml *dev)
     aml_append(dev, method);
 }
 
+/*
+ * 在以下使用acpi_dsdt_add_gpex():
+ *   - hw/arm/virt-acpi-build.c|138| <<acpi_dsdt_add_pci>> acpi_dsdt_add_gpex(scope, &cfg);
+ *   - hw/i386/acpi-microvm.c|99| <<acpi_dsdt_add_pci>> acpi_dsdt_add_gpex(scope, &mms->gpex);
+ *   - hw/loongarch/virt-acpi-build.c|398| <<build_pci_device_aml>> acpi_dsdt_add_gpex(scope, &cfg);
+ *   - hw/pci-host/gpex-acpi.c|299| <<acpi_dsdt_add_gpex_host>> acpi_dsdt_add_gpex(scope, &GPEX_HOST(obj)->gpex_cfg);
+ */
 void acpi_dsdt_add_gpex(Aml *scope, struct GPEXConfig *cfg)
 {
     int nr_pcie_buses = cfg->ecam.size / PCIE_MMCFG_SIZE_MIN;
@@ -286,6 +293,12 @@ void acpi_dsdt_add_gpex(Aml *scope, struct GPEXConfig *cfg)
     crs_range_set_free(&crs_range_set);
 }
 
+/*
+ * 在以下使用acpi_dsdt_add_gpex_host():
+ *   - hw/riscv/virt-acpi-build.c|458| <<build_dsdt>> acpi_dsdt_add_gpex_host(scope, PCIE_IRQ);
+ *   - hw/riscv/virt-acpi-build.c|464| <<build_dsdt>> acpi_dsdt_add_gpex_host(scope, PCIE_IRQ + VIRT_IRQCHIP_NUM_SOURCES);
+ *   - hw/riscv/virt-acpi-build.c|470| <<build_dsdt>> acpi_dsdt_add_gpex_host(scope, PCIE_IRQ + VIRT_IRQCHIP_NUM_SOURCES * 2);
+ */
 void acpi_dsdt_add_gpex_host(Aml *scope, uint32_t irq)
 {
     bool ambig;
@@ -296,5 +309,12 @@ void acpi_dsdt_add_gpex_host(Aml *scope, uint32_t irq)
     }
 
     GPEX_HOST(obj)->gpex_cfg.irq = irq;
+    /*
+     * 在以下使用acpi_dsdt_add_gpex():
+     *   - hw/arm/virt-acpi-build.c|138| <<acpi_dsdt_add_pci>> acpi_dsdt_add_gpex(scope, &cfg);
+     *   - hw/i386/acpi-microvm.c|99| <<acpi_dsdt_add_pci>> acpi_dsdt_add_gpex(scope, &mms->gpex);
+     *   - hw/loongarch/virt-acpi-build.c|398| <<build_pci_device_aml>> acpi_dsdt_add_gpex(scope, &cfg);
+     *   - hw/pci-host/gpex-acpi.c|299| <<acpi_dsdt_add_gpex_host>> acpi_dsdt_add_gpex(scope, &GPEX_HOST(obj)->gpex_cfg);
+     */
     acpi_dsdt_add_gpex(scope, &GPEX_HOST(obj)->gpex_cfg);
 }
diff --git a/hw/pci-host/i440fx.c b/hw/pci-host/i440fx.c
index 1e69691c6..f49f22eef 100644
--- a/hw/pci-host/i440fx.c
+++ b/hw/pci-host/i440fx.c
@@ -267,6 +267,25 @@ static void i440fx_pcihost_realize(DeviceState *dev, Error **errp)
     memory_region_set_flush_coalesced(&phb->data_mem);
     memory_region_add_coalescing(&phb->conf_mem, 0, 4);
 
+    /*
+     * 在以下使用pci_root_bus_new():
+     *   - hw/pci-bridge/pci_expander_bridge.c|360| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             dev_name, NULL, NULL, 0, TYPE_PXB_PCIE_BUS);
+     *   - hw/pci-bridge/pci_expander_bridge.c|362| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             dev_name, NULL, NULL, 0, TYPE_PXB_CXL_BUS);
+     *   - hw/pci-bridge/pci_expander_bridge.c|366| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             "pxb-internal", NULL, NULL, 0, TYPE_PXB_BUS);
+     *   - hw/pci-host/gt64120.c|1193| <<gt64120_realize>> phb->bus = pci_root_bus_new(dev, "pci",
+     *             &s->pci0_mem, get_system_io(), PCI_DEVFN(18, 0), TYPE_PCI_BUS);
+     *   - hw/pci-host/i440fx.c|270| <<i440fx_pcihost_realize>> b = pci_root_bus_new(dev, NULL,
+     *             s->pci_address_space, s->io_memory, 0, TYPE_PCI_BUS);
+     *   - hw/pci-host/q35.c|65| <<q35_host_realize>> pci->bus = pci_root_bus_new(DEVICE(s), "pcie.0",
+     *             s->mch.pci_address_space, s->mch.address_space_io, 0, TYPE_PCIE_BUS);
+     *   - hw/pci-host/remote.c|44| <<remote_pcihost_realize>> pci->bus = pci_root_bus_new(DEVICE(s),
+     *             "remote-pci", s->mr_pci_mem, s->mr_sys_io, 0, TYPE_PCIE_BUS);
+     *   - hw/pci/pci.c|746| <<pci_register_root_bus>> bus = pci_root_bus_new(parent, name, mem, io,
+     *             devfn_min, typename);
+     */
     b = pci_root_bus_new(dev, NULL, s->pci_address_space,
                          s->io_memory, 0, TYPE_PCI_BUS);
     phb->bus = b;
diff --git a/hw/pci-host/q35.c b/hw/pci-host/q35.c
index 06be3d77c..ab30fa8e9 100644
--- a/hw/pci-host/q35.c
+++ b/hw/pci-host/q35.c
@@ -44,6 +44,30 @@
 
 #define Q35_PCI_HOST_HOLE64_SIZE_DEFAULT (1ULL << 35)
 
+/*
+ * #0  pci_root_bus_new (parent=0x5555573856b0, name=name@entry=0x555555fd8d35 "pcie.0", mem=mem@entry=0x55555729ff70,
+ *     io=io@entry=0x55555712bee0, devfn_min=devfn_min@entry=0 '\000', typename=typename@entry=0x555555fd5b3b "PCIE") at ../hw/pci/pci.c:697
+ * #1  0x0000555555a2dd83 in q35_host_realize (dev=<optimized out>, errp=<optimized out>) at ../hw/pci-host/q35.c:65
+ * #2  0x0000555555cfd5fb in device_set_realized (obj=<optimized out>, value=<optimized out>, errp=0x7fffffffb560) at ../hw/core/qdev.c:494
+ * #3  0x0000555555d006eb in property_set_bool (obj=0x5555573856b0, v=<optimized out>, name=<optimized out>,
+ *     opaque=0x555557009060, errp=0x7fffffffb560) at ../qom/object.c:2374
+ * #4  0x0000555555d03878 in object_property_set (obj=obj@entry=0x5555573856b0, name=name@entry=0x55555600da85 "realized",
+ *     v=v@entry=0x5555574ac9f0, errp=0x7fffffffb560, errp@entry=0x555556f6f438 <error_fatal>) at ../qom/object.c:1449
+ * #5  0x0000555555d075b0 in object_property_set_qobject (obj=obj@entry=0x5555573856b0, name=name@entry=0x55555600da85 "realized",
+ *     value=value@entry=0x5555574ac710, errp=errp@entry=0x555556f6f438 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #6  0x0000555555d03f25 in object_property_set_bool (obj=obj@entry=0x5555573856b0, name=name@entry=0x55555600da85 "realized",
+ *     value=value@entry=true, errp=0x555556f6f438 <error_fatal>) at ../qom/object.c:1519
+ * #7  0x0000555555cfcc9e in qdev_realize (dev=dev@entry=0x5555573856b0, bus=<optimized out>, errp=<optimized out>) at ../hw/core/qdev.c:276
+ * #8  0x0000555555cfcd3f in qdev_realize_and_unref (dev=0x5555573856b0, bus=<optimized out>, errp=<optimized out>) at ../hw/core/qdev.c:283
+ * #9  0x00005555559421dc in sysbus_realize_and_unref (dev=<optimized out>, errp=<optimized out>) at ../hw/core/sysbus.c:243
+ * #10 0x0000555555bd4cc1 in pc_q35_init (machine=0x5555572826f0) at ../hw/i386/pc_q35.c:225
+ * #11 0x000055555593bb15 in machine_run_board_init (machine=<optimized out>, mem_path=<optimized out>, errp=<optimized out>,
+ *     errp@entry=0x555556f6f438 <error_fatal>) at ../hw/core/machine.c:1682
+ * #12 0x0000555555b06eb8 in qemu_init_board () at ../system/vl.c:2711
+ * #13 qmp_x_exit_preconfig (errp=0x555556f6f438 <error_fatal>) at ../system/vl.c:2807
+ * #14 0x0000555555b0a897 in qemu_init (argc=<optimized out>, argv=<optimized out>) at ../system/vl.c:3843
+ * #15 0x000055555587f449 in main (argc=<optimized out>, argv=<optimized out>) at ../system/main.c:71
+ */
 static void q35_host_realize(DeviceState *dev, Error **errp)
 {
     PCIHostState *pci = PCI_HOST_BRIDGE(dev);
@@ -62,6 +86,25 @@ static void q35_host_realize(DeviceState *dev, Error **errp)
     memory_region_set_flush_coalesced(&pci->data_mem);
     memory_region_add_coalescing(&pci->conf_mem, 0, 4);
 
+    /*
+     * 在以下使用pci_root_bus_new():
+     *   - hw/pci-bridge/pci_expander_bridge.c|360| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             dev_name, NULL, NULL, 0, TYPE_PXB_PCIE_BUS);
+     *   - hw/pci-bridge/pci_expander_bridge.c|362| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             dev_name, NULL, NULL, 0, TYPE_PXB_CXL_BUS);
+     *   - hw/pci-bridge/pci_expander_bridge.c|366| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             "pxb-internal", NULL, NULL, 0, TYPE_PXB_BUS);
+     *   - hw/pci-host/gt64120.c|1193| <<gt64120_realize>> phb->bus = pci_root_bus_new(dev, "pci",
+     *             &s->pci0_mem, get_system_io(), PCI_DEVFN(18, 0), TYPE_PCI_BUS);
+     *   - hw/pci-host/i440fx.c|270| <<i440fx_pcihost_realize>> b = pci_root_bus_new(dev, NULL,
+     *             s->pci_address_space, s->io_memory, 0, TYPE_PCI_BUS);
+     *   - hw/pci-host/q35.c|65| <<q35_host_realize>> pci->bus = pci_root_bus_new(DEVICE(s), "pcie.0",
+     *             s->mch.pci_address_space, s->mch.address_space_io, 0, TYPE_PCIE_BUS);
+     *   - hw/pci-host/remote.c|44| <<remote_pcihost_realize>> pci->bus = pci_root_bus_new(DEVICE(s),
+     *             "remote-pci", s->mr_pci_mem, s->mr_sys_io, 0, TYPE_PCIE_BUS);
+     *   - hw/pci/pci.c|746| <<pci_register_root_bus>> bus = pci_root_bus_new(parent, name, mem, io,
+     *             devfn_min, typename);
+     */
     pci->bus = pci_root_bus_new(DEVICE(s), "pcie.0",
                                 s->mch.pci_address_space,
                                 s->mch.address_space_io,
diff --git a/hw/pci-host/remote.c b/hw/pci-host/remote.c
index bfb25ef6a..4cd4d7acd 100644
--- a/hw/pci-host/remote.c
+++ b/hw/pci-host/remote.c
@@ -41,6 +41,25 @@ static void remote_pcihost_realize(DeviceState *dev, Error **errp)
     PCIHostState *pci = PCI_HOST_BRIDGE(dev);
     RemotePCIHost *s = REMOTE_PCIHOST(dev);
 
+    /*
+     * 在以下使用pci_root_bus_new():
+     *   - hw/pci-bridge/pci_expander_bridge.c|360| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             dev_name, NULL, NULL, 0, TYPE_PXB_PCIE_BUS);
+     *   - hw/pci-bridge/pci_expander_bridge.c|362| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             dev_name, NULL, NULL, 0, TYPE_PXB_CXL_BUS);
+     *   - hw/pci-bridge/pci_expander_bridge.c|366| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             "pxb-internal", NULL, NULL, 0, TYPE_PXB_BUS);
+     *   - hw/pci-host/gt64120.c|1193| <<gt64120_realize>> phb->bus = pci_root_bus_new(dev, "pci",
+     *             &s->pci0_mem, get_system_io(), PCI_DEVFN(18, 0), TYPE_PCI_BUS);
+     *   - hw/pci-host/i440fx.c|270| <<i440fx_pcihost_realize>> b = pci_root_bus_new(dev, NULL,
+     *             s->pci_address_space, s->io_memory, 0, TYPE_PCI_BUS);
+     *   - hw/pci-host/q35.c|65| <<q35_host_realize>> pci->bus = pci_root_bus_new(DEVICE(s), "pcie.0",
+     *             s->mch.pci_address_space, s->mch.address_space_io, 0, TYPE_PCIE_BUS);
+     *   - hw/pci-host/remote.c|44| <<remote_pcihost_realize>> pci->bus = pci_root_bus_new(DEVICE(s),
+     *             "remote-pci", s->mr_pci_mem, s->mr_sys_io, 0, TYPE_PCIE_BUS);
+     *   - hw/pci/pci.c|746| <<pci_register_root_bus>> bus = pci_root_bus_new(parent, name, mem, io,
+     *             devfn_min, typename);
+     */
     pci->bus = pci_root_bus_new(DEVICE(s), "remote-pci",
                                 s->mr_pci_mem, s->mr_sys_io,
                                 0, TYPE_PCIE_BUS);
diff --git a/hw/pci/pci-qmp-cmds.c b/hw/pci/pci-qmp-cmds.c
index 5d9f4817f..fa66a369a 100644
--- a/hw/pci/pci-qmp-cmds.c
+++ b/hw/pci/pci-qmp-cmds.c
@@ -189,6 +189,13 @@ PciInfoList *qmp_query_pci(Error **errp)
     PciInfoList *head = NULL, **tail = &head;
     PCIHostState *host_bridge;
 
+    /*
+     * 在以下使用pci_host_bridges:
+     *   - hw/pci/pci.c|339| <<global>> PCIHostStateList pci_host_bridges;
+     *   - hw/pci/pci-qmp-cmds.c|192| <<qmp_query_pci>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     *   - hw/pci/pci.c|603| <<pci_host_bus_register>> QLIST_INSERT_HEAD(&pci_host_bridges, host_bridge, next);
+     *   - hw/pci/pci.c|2812| <<pci_qdev_find_device>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     */
     QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
         QAPI_LIST_APPEND(tail,
                          qmp_query_pci_bus(host_bridge->bus,
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index 2844ec555..81e87b202 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -106,6 +106,27 @@ static const Property pci_props[] = {
     { .name = "busnr", .info = &prop_pci_busnr },
 };
 
+/*
+ * version_id
+ * 表示当前这个VMStateDescription的结构版本号.
+ * 每次你修改了字段的保存方式,添加新字段,改变字段顺序,
+ * 就应该增加 version_id.
+ *
+ * QEMU 会在迁移或快照时,把这个版本号保存在状态数据里.
+ * 加载状态的时候会读取这个版本号,然后据此选择合适的逻辑
+ * (如是否读某些字段).
+ *
+ * minimum_version_id
+ * 表示最小兼容的版本号.
+ *
+ * 如果加载时发现迁移的状态版本比这个值还低,说明这个版本太
+ * 旧了,无法兼容当前的读取逻辑,会报错.
+ *
+ *
+ * 在以下使用vmstate_pcibus:
+ *   - hw/pci/pci.c|168| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+ *   - hw/pci/pci.c|203| <<pci_bus_unrealize>> vmstate_unregister(NULL, &vmstate_pcibus, bus);
+ */
 static const VMStateDescription vmstate_pcibus = {
     .name = "PCIBUS",
     .version_id = 1,
@@ -165,6 +186,26 @@ static void pci_bus_realize(BusState *qbus, Error **errp)
     bus->machine_done.notify = pcibus_machine_done;
     qemu_add_machine_init_done_notifier(&bus->machine_done);
 
+    /*
+     * 在以下使用vmstate_register_any():
+     *   - audio/audio.c|1787| <<audio_init>> vmstate_register_any(NULL, &vmstate_audio, s);
+     *   - backends/dbus-vmstate.c|429| <<dbus_vmstate_complete>> if (vmstate_register_any(VMSTATE_IF(self), &dbus_vmstate, self) < 0) {
+     *   - backends/tpm/tpm_emulator.c|1009| <<tpm_emulator_inst_init>> vmstate_register_any(NULL, &vmstate_tpm_emulator, obj);
+     *   - hw/display/vmware_vga.c|1265| <<vmsvga_init>> vmstate_register_any(NULL, &vmstate_vga_common, &s->vga);
+     *   - hw/i2c/core.c|66| <<i2c_init_bus>> vmstate_register_any(NULL, &vmstate_i2c_bus, bus);
+     *   - hw/ide/isa.c|76| <<isa_ide_realizefn>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_ide_isa, s);
+     *   - hw/input/adb.c|250| <<adb_bus_realize>> vmstate_register_any(NULL, &vmstate_adb_bus, adb_bus);
+     *   - hw/net/eepro100.c|1888| <<e100_nic_realize>> vmstate_register_any(VMSTATE_IF(&pci_dev->qdev), s->vmstate, s);
+     *   - hw/nvram/eeprom93xx.c|324| <<eeprom93xx_new>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_eeprom, eeprom);
+     *   - hw/pci/pci.c|178| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+     *   - hw/ppc/spapr_nvdimm.c|879| <<spapr_nvdimm_realize>> vmstate_register_any(NULL, &vmstate_spapr_nvdimm_states, dimm);
+     *   - hw/timer/arm_timer.c|184| <<arm_timer_init>> vmstate_register_any(NULL, &vmstate_arm_timer, s);
+     *   - hw/virtio/virtio-mem.c|1122| <<virtio_mem_device_realize>> vmstate_register_any(VMSTATE_IF(vmem), &vmstate_virtio_mem_device_early, vmem);
+     *
+     * 在以下使用vmstate_pcibus:
+     *   - hw/pci/pci.c|168| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+     *   - hw/pci/pci.c|203| <<pci_bus_unrealize>> vmstate_unregister(NULL, &vmstate_pcibus, bus);
+     */
     vmstate_register_any(NULL, &vmstate_pcibus, bus);
 }
 
@@ -200,6 +241,11 @@ static void pci_bus_unrealize(BusState *qbus)
 
     qemu_remove_machine_init_done_notifier(&bus->machine_done);
 
+    /*
+     * 在以下使用vmstate_pcibus:
+     *   - hw/pci/pci.c|168| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+     *   - hw/pci/pci.c|203| <<pci_bus_unrealize>> vmstate_unregister(NULL, &vmstate_pcibus, bus);
+     */
     vmstate_unregister(NULL, &vmstate_pcibus, bus);
 }
 
@@ -336,6 +382,15 @@ static void pci_del_option_rom(PCIDevice *pdev);
 static uint16_t pci_default_sub_vendor_id = PCI_SUBVENDOR_ID_REDHAT_QUMRANET;
 static uint16_t pci_default_sub_device_id = PCI_SUBDEVICE_ID_QEMU;
 
+/*
+ * 在以下使用pci_host_bridges:
+ *   - hw/pci/pci.c|339| <<global>> PCIHostStateList pci_host_bridges;
+ *   - hw/pci/pci-qmp-cmds.c|192| <<qmp_query_pci>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+ *   - hw/pci/pci.c|603| <<pci_host_bus_register>> QLIST_INSERT_HEAD(&pci_host_bridges, host_bridge, next);
+ *   - hw/pci/pci.c|2812| <<pci_qdev_find_device>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+ *
+ * 类型是PCIHostState
+ */
 PCIHostStateList pci_host_bridges;
 
 int pci_bar(PCIDevice *d, int reg)
@@ -596,10 +651,21 @@ static void pcibus_reset_hold(Object *obj, ResetType type)
     }
 }
 
+/*
+ * 在以下使用pci_host_bus_register():
+ *   - hw/pci/pci.c|672| <<pci_root_bus_internal_init>> pci_host_bus_register(parent);
+ */
 static void pci_host_bus_register(DeviceState *host)
 {
     PCIHostState *host_bridge = PCI_HOST_BRIDGE(host);
 
+    /*
+     * 在以下使用pci_host_bridges:
+     *   - hw/pci/pci.c|339| <<global>> PCIHostStateList pci_host_bridges;
+     *   - hw/pci/pci-qmp-cmds.c|192| <<qmp_query_pci>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     *   - hw/pci/pci.c|603| <<pci_host_bus_register>> QLIST_INSERT_HEAD(&pci_host_bridges, host_bridge, next);
+     *   - hw/pci/pci.c|2812| <<pci_qdev_find_device>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     */
     QLIST_INSERT_HEAD(&pci_host_bridges, host_bridge, next);
 }
 
@@ -655,6 +721,11 @@ bool pci_bus_bypass_iommu(PCIBus *bus)
     return host_bridge->bypass_iommu;
 }
 
+/*
+ * 在以下使用pci_root_bus_internal_init():
+ *   - hw/pci/pci.c|691| <<pci_root_bus_init>> pci_root_bus_internal_init(bus, parent, mem, io, devfn_min);
+ *   - hw/pci/pci.c|701| <<pci_root_bus_new>> pci_root_bus_internal_init(bus, parent, mem, io, devfn_min);
+ */
 static void pci_root_bus_internal_init(PCIBus *bus, DeviceState *parent,
                                        MemoryRegion *mem, MemoryRegion *io,
                                        uint8_t devfn_min)
@@ -669,6 +740,10 @@ static void pci_root_bus_internal_init(PCIBus *bus, DeviceState *parent,
     /* host bridge */
     QLIST_INIT(&bus->child);
 
+    /*
+     * 在以下使用pci_host_bus_register():
+     *   - hw/pci/pci.c|672| <<pci_root_bus_internal_init>> pci_host_bus_register(parent);
+     */
     pci_host_bus_register(parent);
 }
 
@@ -682,6 +757,11 @@ bool pci_bus_is_express(const PCIBus *bus)
     return object_dynamic_cast(OBJECT(bus), TYPE_PCIE_BUS);
 }
 
+/*
+ * 在以下使用pci_root_bus_init():
+ *   - hw/pci-host/raven.c|315| <<raven_pcihost_initfn>> pci_root_bus_init(&s->pci_bus, sizeof(s->pci_bus), DEVICE(obj), NULL,
+ *   - hw/pci-host/versatile.c|408| <<pci_vpb_realize>> pci_root_bus_init(&s->pci_bus, sizeof(s->pci_bus), dev, "pci",
+ */
 void pci_root_bus_init(PCIBus *bus, size_t bus_size, DeviceState *parent,
                        const char *name,
                        MemoryRegion *mem, MemoryRegion *io,
@@ -691,6 +771,48 @@ void pci_root_bus_init(PCIBus *bus, size_t bus_size, DeviceState *parent,
     pci_root_bus_internal_init(bus, parent, mem, io, devfn_min);
 }
 
+/*
+ * #0  pci_root_bus_new (parent=0x5555573856b0, name=name@entry=0x555555fd8d35 "pcie.0", mem=mem@entry=0x55555729ff70,
+ *     io=io@entry=0x55555712bee0, devfn_min=devfn_min@entry=0 '\000', typename=typename@entry=0x555555fd5b3b "PCIE") at ../hw/pci/pci.c:697
+ * #1  0x0000555555a2dd83 in q35_host_realize (dev=<optimized out>, errp=<optimized out>) at ../hw/pci-host/q35.c:65
+ * #2  0x0000555555cfd5fb in device_set_realized (obj=<optimized out>, value=<optimized out>, errp=0x7fffffffb560) at ../hw/core/qdev.c:494
+ * #3  0x0000555555d006eb in property_set_bool (obj=0x5555573856b0, v=<optimized out>, name=<optimized out>,
+ *     opaque=0x555557009060, errp=0x7fffffffb560) at ../qom/object.c:2374
+ * #4  0x0000555555d03878 in object_property_set (obj=obj@entry=0x5555573856b0, name=name@entry=0x55555600da85 "realized",
+ *     v=v@entry=0x5555574ac9f0, errp=0x7fffffffb560, errp@entry=0x555556f6f438 <error_fatal>) at ../qom/object.c:1449
+ * #5  0x0000555555d075b0 in object_property_set_qobject (obj=obj@entry=0x5555573856b0, name=name@entry=0x55555600da85 "realized",
+ *     value=value@entry=0x5555574ac710, errp=errp@entry=0x555556f6f438 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #6  0x0000555555d03f25 in object_property_set_bool (obj=obj@entry=0x5555573856b0, name=name@entry=0x55555600da85 "realized",
+ *     value=value@entry=true, errp=0x555556f6f438 <error_fatal>) at ../qom/object.c:1519
+ * #7  0x0000555555cfcc9e in qdev_realize (dev=dev@entry=0x5555573856b0, bus=<optimized out>, errp=<optimized out>) at ../hw/core/qdev.c:276
+ * #8  0x0000555555cfcd3f in qdev_realize_and_unref (dev=0x5555573856b0, bus=<optimized out>, errp=<optimized out>) at ../hw/core/qdev.c:283
+ * #9  0x00005555559421dc in sysbus_realize_and_unref (dev=<optimized out>, errp=<optimized out>) at ../hw/core/sysbus.c:243
+ * #10 0x0000555555bd4cc1 in pc_q35_init (machine=0x5555572826f0) at ../hw/i386/pc_q35.c:225
+ * #11 0x000055555593bb15 in machine_run_board_init (machine=<optimized out>, mem_path=<optimized out>, errp=<optimized out>,
+ *     errp@entry=0x555556f6f438 <error_fatal>) at ../hw/core/machine.c:1682
+ * #12 0x0000555555b06eb8 in qemu_init_board () at ../system/vl.c:2711
+ * #13 qmp_x_exit_preconfig (errp=0x555556f6f438 <error_fatal>) at ../system/vl.c:2807
+ * #14 0x0000555555b0a897 in qemu_init (argc=<optimized out>, argv=<optimized out>) at ../system/vl.c:3843
+ * #15 0x000055555587f449 in main (argc=<optimized out>, argv=<optimized out>) at ../system/main.c:71
+ *
+ * 在以下使用pci_root_bus_new():
+ *   - hw/pci-bridge/pci_expander_bridge.c|360| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+ *             dev_name, NULL, NULL, 0, TYPE_PXB_PCIE_BUS);
+ *   - hw/pci-bridge/pci_expander_bridge.c|362| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+ *             dev_name, NULL, NULL, 0, TYPE_PXB_CXL_BUS);
+ *   - hw/pci-bridge/pci_expander_bridge.c|366| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+ *             "pxb-internal", NULL, NULL, 0, TYPE_PXB_BUS);
+ *   - hw/pci-host/gt64120.c|1193| <<gt64120_realize>> phb->bus = pci_root_bus_new(dev, "pci",
+ *             &s->pci0_mem, get_system_io(), PCI_DEVFN(18, 0), TYPE_PCI_BUS);
+ *   - hw/pci-host/i440fx.c|270| <<i440fx_pcihost_realize>> b = pci_root_bus_new(dev, NULL,
+ *             s->pci_address_space, s->io_memory, 0, TYPE_PCI_BUS);
+ *   - hw/pci-host/q35.c|65| <<q35_host_realize>> pci->bus = pci_root_bus_new(DEVICE(s), "pcie.0",
+ *             s->mch.pci_address_space, s->mch.address_space_io, 0, TYPE_PCIE_BUS);
+ *   - hw/pci-host/remote.c|44| <<remote_pcihost_realize>> pci->bus = pci_root_bus_new(DEVICE(s),
+ *             "remote-pci", s->mr_pci_mem, s->mr_sys_io, 0, TYPE_PCIE_BUS);
+ *   - hw/pci/pci.c|746| <<pci_register_root_bus>> bus = pci_root_bus_new(parent, name, mem, io,
+ *             devfn_min, typename);
+ */
 PCIBus *pci_root_bus_new(DeviceState *parent, const char *name,
                          MemoryRegion *mem, MemoryRegion *io,
                          uint8_t devfn_min, const char *typename)
@@ -698,6 +820,11 @@ PCIBus *pci_root_bus_new(DeviceState *parent, const char *name,
     PCIBus *bus;
 
     bus = PCI_BUS(qbus_new(typename, parent, name));
+    /*
+     * 在以下使用pci_root_bus_internal_init():
+     *   - hw/pci/pci.c|691| <<pci_root_bus_init>> pci_root_bus_internal_init(bus, parent, mem, io, devfn_min);
+     *   - hw/pci/pci.c|701| <<pci_root_bus_new>> pci_root_bus_internal_init(bus, parent, mem, io, devfn_min);
+     */
     pci_root_bus_internal_init(bus, parent, mem, io, devfn_min);
     return bus;
 }
@@ -743,6 +870,25 @@ PCIBus *pci_register_root_bus(DeviceState *parent, const char *name,
 {
     PCIBus *bus;
 
+    /*
+     * 在以下使用pci_root_bus_new():
+     *   - hw/pci-bridge/pci_expander_bridge.c|360| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             dev_name, NULL, NULL, 0, TYPE_PXB_PCIE_BUS);
+     *   - hw/pci-bridge/pci_expander_bridge.c|362| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             dev_name, NULL, NULL, 0, TYPE_PXB_CXL_BUS);
+     *   - hw/pci-bridge/pci_expander_bridge.c|366| <<pxb_dev_realize_common>> bus = pci_root_bus_new(ds,
+     *             "pxb-internal", NULL, NULL, 0, TYPE_PXB_BUS);
+     *   - hw/pci-host/gt64120.c|1193| <<gt64120_realize>> phb->bus = pci_root_bus_new(dev, "pci",
+     *             &s->pci0_mem, get_system_io(), PCI_DEVFN(18, 0), TYPE_PCI_BUS);
+     *   - hw/pci-host/i440fx.c|270| <<i440fx_pcihost_realize>> b = pci_root_bus_new(dev, NULL,
+     *             s->pci_address_space, s->io_memory, 0, TYPE_PCI_BUS);
+     *   - hw/pci-host/q35.c|65| <<q35_host_realize>> pci->bus = pci_root_bus_new(DEVICE(s), "pcie.0",
+     *             s->mch.pci_address_space, s->mch.address_space_io, 0, TYPE_PCIE_BUS);
+     *   - hw/pci-host/remote.c|44| <<remote_pcihost_realize>> pci->bus = pci_root_bus_new(DEVICE(s),
+     *             "remote-pci", s->mr_pci_mem, s->mr_sys_io, 0, TYPE_PCIE_BUS);
+     *   - hw/pci/pci.c|746| <<pci_register_root_bus>> bus = pci_root_bus_new(parent, name, mem, io,
+     *             devfn_min, typename);
+     */
     bus = pci_root_bus_new(parent, name, mem, io, devfn_min, typename);
     pci_bus_irqs(bus, set_irq, irq_opaque, nirq);
     pci_bus_map_irqs(bus, map_irq);
@@ -793,6 +939,25 @@ static int get_pci_config_device(QEMUFile *f, void *pv, size_t size,
 
     qemu_get_buffer(f, config, size);
     for (i = 0; i < size; ++i) {
+        /*
+	 * (config[i] ^ s->config[i])先异或一下
+	 * 表示只关注那些迁移了的或者没迁移的
+	 *
+	 * 再&一下子cmask.
+	 * Used to enable checks on load. Note that writable bits are
+	 * never checked even if set in cmask.
+	 *
+	 * 再把那些write的bit移除
+	 *
+	 * 再把那些write-1-to-clear的移除
+	 *
+	 * 比如:
+	 * config[i] = 5 (101b)
+	 * s->config[i] = 3 (011b)
+	 * s->cmask[i] = = 0xff
+	 * s->wmask[i] = 0
+	 * s->w1cmask[i] = 0
+	 */
         if ((config[i] ^ s->config[i]) &
             s->cmask[i] & ~s->wmask[i] & ~s->w1cmask[i]) {
             error_report("%s: Bad config data: i=0x%x read: %x device: %x "
@@ -1165,6 +1330,10 @@ static void pci_config_alloc(PCIDevice *pci_dev)
     int config_size = pci_config_size(pci_dev);
 
     pci_dev->config = g_malloc0(config_size);
+    /*
+     * Used to enable config checks on load. Note that writable bits are
+     * never checked even if set in cmask.
+     */
     pci_dev->cmask = g_malloc0(config_size);
     pci_dev->wmask = g_malloc0(config_size);
     pci_dev->w1cmask = g_malloc0(config_size);
@@ -1763,9 +1932,24 @@ void pci_default_write_config(PCIDevice *d, uint32_t addr, uint32_t val_in, int
 
     for (i = 0; i < l; val >>= 8, ++i) {
         uint8_t wmask = d->wmask[addr + i];
+        /*
+	 * 注释Used to implement RW1C(Write 1 to Clear) bytes
+	 */
         uint8_t w1cmask = d->w1cmask[addr + i];
+        /*
+	 * assert的必须返回true
+	 * 所以(wmask & w1cmask)必须是false
+	 * write的bit和write clear不能重合?
+	 */
         assert(!(wmask & w1cmask));
+        /*
+	 * 把已经有的那些write的bit清空
+	 * 再和新的val里write的bit们组合
+	 */
         d->config[addr + i] = (d->config[addr + i] & ~wmask) | (val & wmask);
+        /*
+	 * 组合后的结果中的那些write-to-clear的bit们也要清空
+	 */
         d->config[addr + i] &= ~(val & w1cmask); /* W1C: Write 1 to Clear */
     }
 
@@ -2771,6 +2955,13 @@ int pci_qdev_find_device(const char *id, PCIDevice **pdev)
     PCIHostState *host_bridge;
     int rc = -ENODEV;
 
+    /*
+     * 在以下使用pci_host_bridges:
+     *   - hw/pci/pci.c|339| <<global>> PCIHostStateList pci_host_bridges;
+     *   - hw/pci/pci-qmp-cmds.c|192| <<qmp_query_pci>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     *   - hw/pci/pci.c|603| <<pci_host_bus_register>> QLIST_INSERT_HEAD(&pci_host_bridges, host_bridge, next);
+     *   - hw/pci/pci.c|2812| <<pci_qdev_find_device>> QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
+     */
     QLIST_FOREACH(host_bridge, &pci_host_bridges, next) {
         int tmp = pci_qdev_find_recursive(host_bridge->bus, id, pdev);
         if (!tmp) {
diff --git a/hw/riscv/virt-acpi-build.c b/hw/riscv/virt-acpi-build.c
index 1ad680050..9f83559ce 100644
--- a/hw/riscv/virt-acpi-build.c
+++ b/hw/riscv/virt-acpi-build.c
@@ -804,6 +804,24 @@ void virt_acpi_setup(RISCVVirtState *s)
                                               ACPI_BUILD_TABLE_FILE);
     assert(build_state->table_mr != NULL);
 
+    /*
+     * 在以下使用ACPI_BUILD_LOADER_FILE:
+     *   - include/hw/acpi/aml-build.h|13| <<global>> #define ACPI_BUILD_LOADER_FILE "etc/table-loader"
+     *   - hw/acpi/utils.c|37| <<acpi_add_rom_blob>> } else if (!strcmp(name, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/arm/virt-acpi-build.c|1145| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/i386/acpi-build.c|2774| <<acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/i386/acpi-microvm.c|263| <<acpi_setup_microvm>> acpi_add_rom_blob(acpi_build_no_update, NULL,
+     *       tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/loongarch/virt-acpi-build.c|724| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     *   - hw/nvram/fw_cfg.c|654| <<fw_cfg_acpi_mr_restore_post_load>>
+     *       } else if (!strcmp(s->files->f[i].name, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/nvram/fw_cfg.c|894| <<fw_cfg_acpi_mr_save>> } else if (!strcmp(filename, ACPI_BUILD_LOADER_FILE)) {
+     *   - hw/riscv/virt-acpi-build.c|810| <<virt_acpi_setup>> build_state->linker_mr =
+     *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+     */
     build_state->linker_mr = acpi_add_rom_blob(virt_acpi_build_update,
                                                build_state,
                                                tables.linker->cmd_blob,
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index ece1107ee..ba5594f62 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -1626,6 +1626,32 @@ void scsi_req_complete_failed(SCSIRequest *req, int host_status)
     scsi_req_unref(req);
 }
 
+/*
+ * 在以下调用scsi_req_complete():
+ *   - hw/scsi/scsi-bus.c|508| <<scsi_invalid_field>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|522| <<scsi_invalid_command>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|555| <<scsi_unit_attention>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|724| <<scsi_target_send_command>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|760| <<scsi_target_send_command>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|764| <<scsi_target_send_command>> scsi_req_complete(req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-bus.c|769| <<scsi_target_send_command>> scsi_req_complete(req, GOOD);
+ *   - hw/scsi/scsi-bus.c|784| <<scsi_target_read_data>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-bus.c|1615| <<scsi_req_complete_failed>> scsi_req_complete(req, status);
+ *   - hw/scsi/scsi-disk.c|140| <<scsi_check_condition>> scsi_req_complete(&r->req, CHECK_CONDITION);
+ *   - hw/scsi/scsi-disk.c|315| <<scsi_handle_rw_error>> scsi_req_complete(&r->req, status);
+ *   - hw/scsi/scsi-disk.c|360| <<scsi_aio_complete>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|420| <<scsi_write_do_fua>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|437| <<scsi_dma_complete_noio>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|559| <<scsi_read_data>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|1571| <<scsi_disk_emulate_read_data>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|1771| <<scsi_disk_emulate_mode_select>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|1844| <<scsi_unmap_complete_noio>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|1960| <<scsi_write_same_complete>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|2068| <<scsi_disk_emulate_write_data>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|2350| <<scsi_disk_emulate_command>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-disk.c|2452| <<scsi_disk_dma_command>> scsi_req_complete(&r->req, GOOD);
+ *   - hw/scsi/scsi-generic.c|104| <<scsi_command_complete_noio>> scsi_req_complete(&r->req, status);
+ */
 void scsi_req_complete(SCSIRequest *req, int status)
 {
     assert(req->status == -1 && req->host_status == -1);
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index e59632e9b..eb5cc089b 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -74,6 +74,16 @@ struct SCSIDiskClass {
      */
     DMAIOFunc       *dma_readv;
     DMAIOFunc       *dma_writev;
+    /*
+     * 在以下使用SCSIDiskClass->need_fua_emulation():
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     *   - hw/scsi/scsi-disk.c|3352| <<scsi_disk_base_class_initfn>> sdc->need_fua_emulation = scsi_is_cmd_fua;
+     *   - hw/scsi/scsi-disk.c|3504| <<scsi_block_class_initfn>> sdc->need_fua_emulation = scsi_block_no_fua;
+     * 在以下使用SCSIDiskReq->need_fua_emulation:
+     *   - hw/scsi/scsi-disk.c|428| <<scsi_write_do_fua>> if (r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|645| <<scsi_read_data>> if (first && r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     */
     bool            (*need_fua_emulation)(SCSICommand *cmd);
     void            (*update_sense)(SCSIRequest *r);
 };
@@ -218,6 +228,10 @@ static void scsi_disk_emulate_load_request(QEMUFile *f, SCSIRequest *req)
  * scsi_handle_rw_error always manages its reference counts, independent
  * of the return value.
  */
+/*
+ * 在以下使用scsi_handle_rw_error():
+ *   - hw/scsi/scsi-disk.c|338| <<scsi_disk_req_check_error>> return scsi_handle_rw_error(r, ret, acct_failed);
+ */
 static bool scsi_handle_rw_error(SCSIDiskReq *r, int ret, bool acct_failed)
 {
     bool is_read = (r->req.cmd.mode == SCSI_XFER_FROM_DEV);
@@ -327,6 +341,16 @@ static bool scsi_handle_rw_error(SCSIDiskReq *r, int ret, bool acct_failed)
     }
 }
 
+/*
+ * 在以下使用scsi_disk_req_check_error():
+ *   - hw/scsi/scsi-disk.c|355| <<scsi_aio_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+ *   - hw/scsi/scsi-disk.c|427| <<scsi_dma_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+ *   - hw/scsi/scsi-disk.c|469| <<scsi_read_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+ *   - hw/scsi/scsi-disk.c|507| <<scsi_do_read>> if (scsi_disk_req_check_error(r, ret, false)) {
+ *   - hw/scsi/scsi-disk.c|612| <<scsi_write_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+ *   - hw/scsi/scsi-disk.c|1860| <<scsi_unmap_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+ *   - hw/scsi/scsi-disk.c|1937| <<scsi_write_same_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+ */
 static bool scsi_disk_req_check_error(SCSIDiskReq *r, int ret, bool acct_failed)
 {
     if (r->req.io_canceled) {
@@ -352,6 +376,16 @@ static void scsi_aio_complete(void *opaque, int ret)
     assert(r->req.aiocb != NULL);
     r->req.aiocb = NULL;
 
+    /*
+     * 在以下使用scsi_disk_req_check_error():
+     *   - hw/scsi/scsi-disk.c|355| <<scsi_aio_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|427| <<scsi_dma_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|469| <<scsi_read_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|507| <<scsi_do_read>> if (scsi_disk_req_check_error(r, ret, false)) {
+     *   - hw/scsi/scsi-disk.c|612| <<scsi_write_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|1860| <<scsi_unmap_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|1937| <<scsi_write_same_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     */
     if (scsi_disk_req_check_error(r, ret, true)) {
         goto done;
     }
@@ -389,6 +423,11 @@ static bool scsi_is_cmd_fua(SCSICommand *cmd)
     }
 }
 
+/*
+ * 在以下使用scsi_write_do_fua():
+ *   - hw/scsi/scsi-disk.c|434| <<scsi_dma_complete_noio>> scsi_write_do_fua(r);
+ *   - hw/scsi/scsi-disk.c|620| <<scsi_write_complete_noio>> scsi_write_do_fua(r);
+ */
 static void scsi_write_do_fua(SCSIDiskReq *r)
 {
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
@@ -396,9 +435,33 @@ static void scsi_write_do_fua(SCSIDiskReq *r)
     assert(r->req.aiocb == NULL);
     assert(!r->req.io_canceled);
 
+    /*
+     * 在以下使用SCSIDiskClass->need_fua_emulation():
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     *   - hw/scsi/scsi-disk.c|3352| <<scsi_disk_base_class_initfn>> sdc->need_fua_emulation = scsi_is_cmd_fua;
+     *   - hw/scsi/scsi-disk.c|3504| <<scsi_block_class_initfn>> sdc->need_fua_emulation = scsi_block_no_fua;
+     * 在以下使用SCSIDiskReq->need_fua_emulation:
+     *   - hw/scsi/scsi-disk.c|428| <<scsi_write_do_fua>> if (r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|645| <<scsi_read_data>> if (first && r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     */
     if (r->need_fua_emulation) {
         block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
                          BLOCK_ACCT_FLUSH);
+        /*
+	 * 在以下使用blk_aio_flush():
+	 *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+	 *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+	 *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+	 *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+	 *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+	 *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+	 *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 */
         r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
         return;
     }
@@ -407,9 +470,24 @@ static void scsi_write_do_fua(SCSIDiskReq *r)
     scsi_req_unref(&r->req);
 }
 
+/*
+ * 在以下使用scsi_dma_complete_noio():
+ *   - hw/scsi/scsi-disk.c|458| <<scsi_dma_complete>> scsi_dma_complete_noio(r, ret);
+ *   - hw/scsi/scsi-disk.c|680| <<scsi_write_data>> scsi_dma_complete_noio(r, 0);
+ */
 static void scsi_dma_complete_noio(SCSIDiskReq *r, int ret)
 {
     assert(r->req.aiocb == NULL);
+    /*
+     * 在以下使用scsi_disk_req_check_error():
+     *   - hw/scsi/scsi-disk.c|355| <<scsi_aio_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|427| <<scsi_dma_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|469| <<scsi_read_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|507| <<scsi_do_read>> if (scsi_disk_req_check_error(r, ret, false)) {
+     *   - hw/scsi/scsi-disk.c|612| <<scsi_write_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|1860| <<scsi_unmap_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|1937| <<scsi_write_same_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     */
     if (scsi_disk_req_check_error(r, ret, ret > 0)) {
         goto done;
     }
@@ -452,6 +530,16 @@ static void scsi_read_complete_noio(SCSIDiskReq *r, int ret)
     assert(r->req.ctx == qemu_get_current_aio_context());
 
     assert(r->req.aiocb == NULL);
+    /*
+     * 在以下使用scsi_disk_req_check_error():
+     *   - hw/scsi/scsi-disk.c|355| <<scsi_aio_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|427| <<scsi_dma_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|469| <<scsi_read_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|507| <<scsi_do_read>> if (scsi_disk_req_check_error(r, ret, false)) {
+     *   - hw/scsi/scsi-disk.c|612| <<scsi_write_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|1860| <<scsi_unmap_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|1937| <<scsi_write_same_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     */
     if (scsi_disk_req_check_error(r, ret, ret > 0)) {
         goto done;
     }
@@ -490,6 +578,16 @@ static void scsi_do_read(SCSIDiskReq *r, int ret)
     SCSIDiskClass *sdc = (SCSIDiskClass *) object_get_class(OBJECT(s));
 
     assert (r->req.aiocb == NULL);
+    /*
+     * 在以下使用scsi_disk_req_check_error():
+     *   - hw/scsi/scsi-disk.c|355| <<scsi_aio_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|427| <<scsi_dma_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|469| <<scsi_read_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|507| <<scsi_do_read>> if (scsi_disk_req_check_error(r, ret, false)) {
+     *   - hw/scsi/scsi-disk.c|612| <<scsi_write_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|1860| <<scsi_unmap_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|1937| <<scsi_write_same_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     */
     if (scsi_disk_req_check_error(r, ret, false)) {
         goto done;
     }
@@ -564,15 +662,47 @@ static void scsi_read_data(SCSIRequest *req)
 
     first = !r->started;
     r->started = true;
+    /*
+     * 在以下使用SCSIDiskClass->need_fua_emulation():
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     *   - hw/scsi/scsi-disk.c|3352| <<scsi_disk_base_class_initfn>> sdc->need_fua_emulation = scsi_is_cmd_fua;
+     *   - hw/scsi/scsi-disk.c|3504| <<scsi_block_class_initfn>> sdc->need_fua_emulation = scsi_block_no_fua;
+     * 在以下使用SCSIDiskReq->need_fua_emulation:
+     *   - hw/scsi/scsi-disk.c|428| <<scsi_write_do_fua>> if (r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|645| <<scsi_read_data>> if (first && r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     */
     if (first && r->need_fua_emulation) {
         block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
                          BLOCK_ACCT_FLUSH);
+        /*
+	 * 在以下使用blk_aio_flush():
+	 *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+	 *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+	 *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+	 *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+	 *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+	 *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+	 *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 */
         r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
     } else {
         scsi_do_read(r, 0);
     }
 }
 
+/*
+ * 在以下使用scsi_write_complete_noio():
+ *   - hw/scsi/scsi-disk.c|646| <<scsi_write_complete>> scsi_write_complete_noio(r, ret);
+ *   - hw/scsi/scsi-disk.c|662| <<scsi_write_data>> scsi_write_complete_noio(r, -EINVAL);
+ *   - hw/scsi/scsi-disk.c|669| <<scsi_write_data>> scsi_write_complete_noio(r, 0);
+ *   - hw/scsi/scsi-disk.c|673| <<scsi_write_data>> scsi_write_complete_noio(r, -ENOMEDIUM);
+ *   - hw/scsi/scsi-disk.c|682| <<scsi_write_data>> scsi_write_complete_noio(r, 0);
+ */
 static void scsi_write_complete_noio(SCSIDiskReq *r, int ret)
 {
     uint32_t n;
@@ -581,6 +711,16 @@ static void scsi_write_complete_noio(SCSIDiskReq *r, int ret)
     assert(r->req.ctx == qemu_get_current_aio_context());
 
     assert (r->req.aiocb == NULL);
+    /*
+     * 在以下使用scsi_disk_req_check_error():
+     *   - hw/scsi/scsi-disk.c|355| <<scsi_aio_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|427| <<scsi_dma_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|469| <<scsi_read_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|507| <<scsi_do_read>> if (scsi_disk_req_check_error(r, ret, false)) {
+     *   - hw/scsi/scsi-disk.c|612| <<scsi_write_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|1860| <<scsi_unmap_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|1937| <<scsi_write_same_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     */
     if (scsi_disk_req_check_error(r, ret, ret > 0)) {
         goto done;
     }
@@ -618,6 +758,11 @@ static void scsi_write_complete(void * opaque, int ret)
     scsi_write_complete_noio(r, ret);
 }
 
+/*
+ * 在以下使用scsi_write_data():
+ *   - hw/scsi/scsi-disk.c|2740| <<global>> scsi_disk_dma_reqops.write_data = scsi_write_data,
+ *   - hw/scsi/scsi-disk.c|3137| <<global>> scsi_block_dma_reqops.write_data = scsi_write_data,
+ */
 static void scsi_write_data(SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
@@ -679,6 +824,10 @@ static uint8_t *scsi_get_buf(SCSIRequest *req)
     return (uint8_t *)r->iov.iov_base;
 }
 
+/*
+ * 在以下使用scsi_disk_emulate_vpd_page():
+ *   - hw/scsi/scsi-disk.c|989| <<scsi_disk_emulate_inquiry>> return scsi_disk_emulate_vpd_page(req, outbuf);
+ */
 static int scsi_disk_emulate_vpd_page(SCSIRequest *req, uint8_t *outbuf)
 {
     SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
@@ -1722,6 +1871,20 @@ static void scsi_disk_emulate_mode_select(SCSIDiskReq *r, uint8_t *inbuf)
         scsi_req_ref(&r->req);
         block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
                          BLOCK_ACCT_FLUSH);
+        /*
+	 * 在以下使用blk_aio_flush():
+	 *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+	 *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+	 *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+	 *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+	 *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+	 *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+	 *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 */
         r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
         return;
     }
@@ -1815,6 +1978,16 @@ static void scsi_unmap_complete(void *opaque, int ret)
     assert(r->req.aiocb != NULL);
     r->req.aiocb = NULL;
 
+    /*
+     * 在以下使用scsi_disk_req_check_error():
+     *   - hw/scsi/scsi-disk.c|355| <<scsi_aio_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|427| <<scsi_dma_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|469| <<scsi_read_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|507| <<scsi_do_read>> if (scsi_disk_req_check_error(r, ret, false)) {
+     *   - hw/scsi/scsi-disk.c|612| <<scsi_write_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|1860| <<scsi_unmap_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|1937| <<scsi_write_same_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     */
     if (scsi_disk_req_check_error(r, ret, true)) {
         scsi_req_unref(&r->req);
         g_free(data);
@@ -1892,6 +2065,16 @@ static void scsi_write_same_complete(void *opaque, int ret)
     assert(r->req.aiocb != NULL);
     r->req.aiocb = NULL;
 
+    /*
+     * 在以下使用scsi_disk_req_check_error():
+     *   - hw/scsi/scsi-disk.c|355| <<scsi_aio_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|427| <<scsi_dma_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|469| <<scsi_read_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|507| <<scsi_do_read>> if (scsi_disk_req_check_error(r, ret, false)) {
+     *   - hw/scsi/scsi-disk.c|612| <<scsi_write_complete_noio>> if (scsi_disk_req_check_error(r, ret, ret > 0)) {
+     *   - hw/scsi/scsi-disk.c|1860| <<scsi_unmap_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     *   - hw/scsi/scsi-disk.c|1937| <<scsi_write_same_complete>> if (scsi_disk_req_check_error(r, ret, true)) {
+     */
     if (scsi_disk_req_check_error(r, ret, true)) {
         goto done;
     }
@@ -2249,6 +2432,20 @@ static int32_t scsi_disk_emulate_command(SCSIRequest *req, uint8_t *buf)
         scsi_req_ref(&r->req);
         block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
                          BLOCK_ACCT_FLUSH);
+        /*
+	 * 在以下使用blk_aio_flush():
+	 *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+	 *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+	 *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+	 *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+	 *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+	 *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+	 *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 */
         r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
         return 0;
     case SEEK_10:
@@ -2391,6 +2588,16 @@ static int32_t scsi_disk_dma_command(SCSIRequest *req, uint8_t *buf)
         scsi_check_condition(r, SENSE_CODE(LBA_OUT_OF_RANGE));
         return 0;
     }
+    /*
+     * 在以下使用SCSIDiskClass->need_fua_emulation():
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     *   - hw/scsi/scsi-disk.c|3352| <<scsi_disk_base_class_initfn>> sdc->need_fua_emulation = scsi_is_cmd_fua;
+     *   - hw/scsi/scsi-disk.c|3504| <<scsi_block_class_initfn>> sdc->need_fua_emulation = scsi_block_no_fua;
+     * 在以下使用SCSIDiskReq->need_fua_emulation:
+     *   - hw/scsi/scsi-disk.c|428| <<scsi_write_do_fua>> if (r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|645| <<scsi_read_data>> if (first && r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     */
     r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
     if (r->sector_count == 0) {
         scsi_req_complete(&r->req, GOOD);
@@ -3186,6 +3393,16 @@ static void scsi_disk_base_class_initfn(ObjectClass *klass, void *data)
     device_class_set_legacy_reset(dc, scsi_disk_reset);
     sdc->dma_readv = scsi_dma_readv;
     sdc->dma_writev = scsi_dma_writev;
+    /*
+     * 在以下使用SCSIDiskClass->need_fua_emulation():
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     *   - hw/scsi/scsi-disk.c|3352| <<scsi_disk_base_class_initfn>> sdc->need_fua_emulation = scsi_is_cmd_fua;
+     *   - hw/scsi/scsi-disk.c|3504| <<scsi_block_class_initfn>> sdc->need_fua_emulation = scsi_block_no_fua;
+     * 在以下使用SCSIDiskReq->need_fua_emulation:
+     *   - hw/scsi/scsi-disk.c|428| <<scsi_write_do_fua>> if (r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|645| <<scsi_read_data>> if (first && r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     */
     sdc->need_fua_emulation = scsi_is_cmd_fua;
 }
 
@@ -3338,6 +3555,16 @@ static void scsi_block_class_initfn(ObjectClass *klass, void *data)
     sdc->dma_readv   = scsi_block_dma_readv;
     sdc->dma_writev  = scsi_block_dma_writev;
     sdc->update_sense = scsi_block_update_sense;
+    /*
+     * 在以下使用SCSIDiskClass->need_fua_emulation():
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     *   - hw/scsi/scsi-disk.c|3352| <<scsi_disk_base_class_initfn>> sdc->need_fua_emulation = scsi_is_cmd_fua;
+     *   - hw/scsi/scsi-disk.c|3504| <<scsi_block_class_initfn>> sdc->need_fua_emulation = scsi_block_no_fua;
+     * 在以下使用SCSIDiskReq->need_fua_emulation:
+     *   - hw/scsi/scsi-disk.c|428| <<scsi_write_do_fua>> if (r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|645| <<scsi_read_data>> if (first && r->need_fua_emulation) {
+     *   - hw/scsi/scsi-disk.c|2557| <<scsi_disk_dma_command>> r->need_fua_emulation = sdc->need_fua_emulation(&r->req.cmd);
+     */
     sdc->need_fua_emulation = scsi_block_no_fua;
     dc->desc = "SCSI block device passthrough";
     device_class_set_props(dc, scsi_block_properties);
diff --git a/hw/scsi/vhost-scsi.c b/hw/scsi/vhost-scsi.c
index 8039d13fd..3076d5cd0 100644
--- a/hw/scsi/vhost-scsi.c
+++ b/hw/scsi/vhost-scsi.c
@@ -31,6 +31,104 @@
 #include "qemu/cutils.h"
 #include "system/system.h"
 
+/*
+ * Legacy的方式.
+ *
+ * VHOST_SET_OWNER
+ * -> vhost_dev_set_owner()
+ *    -> vhost_worker_create()
+ *    -> for (i = 0; i < dev->nvqs; i++)
+ *         __vhost_vq_attach_worker(dev->vqs[i], worker)
+ *
+ * 新的multiqueue/worker的方式.
+ *
+ * vhost_scsi_ioctl()
+ * -> VHOST_NEW_WORKER
+ *    -> vhost_worker_ioctl()
+ *       -> VHOST_NEW_WORKER
+ *          -> vhost_new_worker()
+ *             -> vhost_worker_create()
+ *
+ * vhost_scsi_ioctl()
+ * -> VHOST_ATTACH_VRING_WORKER
+ *    -> vhost_worker_ioctl()
+ *       -> VHOST_ATTACH_VRING_WORKER
+ *          -> vhost_vq_attach_worker()
+ *             -> __vhost_vq_attach_worker()
+ */
+/*
+ * vhost-scsi的stack.
+ *
+ * (gdb) bt
+ * #0  virtio_scsi_get_config (vdev=0x555558406a90, config=0x5555584313b0 "") at ../hw/scsi/virtio-scsi.c:888
+ * #1  0x0000555555e3d3e0 in virtio_config_modern_readl (vdev=0x555558406a90, addr=0) at ../hw/virtio/virtio-config-io.c:148
+ * #2  0x0000555555b7ba61 in virtio_pci_device_read (opaque=0x5555583fe4d0, addr=0, size=4) at ../hw/virtio/virtio-pci.c:1778
+ * #3  0x0000555555e65ce2 in memory_region_read_accessor (mr=0x5555583ff2f0, addr=0, value=0x7fffeb0d5458, size=4, shift=0,
+ *     mask=4294967295, attrs=...) at ../system/memory.c:445
+ * #4  0x0000555555e6633a in access_with_adjusted_size (addr=0, value=0x7fffeb0d5458, size=4, access_size_min=1,
+ *     access_size_max=4, access_fn=0x555555e65c97 <memory_region_read_accessor>, mr=0x5555583ff2f0, attrs=...)
+ *     at ../system/memory.c:573
+ * #5  0x0000555555e6969d in memory_region_dispatch_read1 (mr=0x5555583ff2f0, addr=0, pval=0x7fffeb0d5458, size=4, attrs=...)
+ *     at ../system/memory.c:1458
+ * #6  0x0000555555e697cc in memory_region_dispatch_read (mr=0x5555583ff2f0, addr=0, pval=0x7fffeb0d5458, op=MO_32, attrs=...)
+ *     at ../system/memory.c:1491
+ * #7  0x0000555555e796f6 in flatview_read_continue_step (attrs=..., buf=0x7ffff7ff0028 "\v", len=4, mr_addr=0, l=0x7fffeb0d54d0,
+ *     mr=0x5555583ff2f0) at ../system/physmem.c:2867
+ * #8  0x0000555555e797f4 in flatview_read_continue (fv=0x7ffbd4000fc0, addr=61572651163648, attrs=..., ptr=0x7ffff7ff0028,
+ *     len=4, mr_addr=0, l=4, mr=0x5555583ff2f0) at ../system/physmem.c:2908
+ * #9  0x0000555555e7991c in flatview_read (fv=0x7ffbd4000fc0, addr=61572651163648, attrs=..., buf=0x7ffff7ff0028, len=4)
+ *     at ../system/physmem.c:2938
+ * #10 0x0000555555e799bb in address_space_read_full (as=0x555557334980 <address_space_memory>, addr=61572651163648, attrs=...,
+ *     buf=0x7ffff7ff0028, len=4) at ../system/physmem.c:2951
+ * #11 0x0000555555e79afd in address_space_rw (as=0x555557334980 <address_space_memory>, addr=61572651163648, attrs=...,
+ *     buf=0x7ffff7ff0028, len=4, is_write=false) at ../system/physmem.c:2979
+ * #12 0x0000555555ed996b in kvm_cpu_exec (cpu=0x5555576f0660) at ../accel/kvm/kvm-all.c:3184
+ * #13 0x0000555555edd092 in kvm_vcpu_thread_fn (arg=0x5555576f0660) at ../accel/kvm/kvm-accel-ops.c:50
+ * #14 0x0000555556172954 in qemu_thread_start (args=0x5555576fa4e0) at ../util/qemu-thread-posix.c:541
+ * #15 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #16 0x00007ffff52488d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  virtio_pci_modern_regions_init (proxy=0x5555583fe4d0, vdev_name=0x55555637e0e5 "virtio-scsi") at ../hw/virtio/virtio-pci.c:1812
+ * #1  0x0000555555b7c3b4 in virtio_pci_device_plugged (d=0x5555583fe4d0, errp=0x7fffffffd198) at ../hw/virtio/virtio-pci.c:2050
+ * #2  0x0000555555b75f0f in virtio_bus_device_plugged (vdev=0x555558406a90, errp=0x7fffffffd1f0) at ../hw/virtio/virtio-bus.c:74
+ * #3  0x0000555555e3b66e in virtio_device_realize (dev=0x555558406a90, errp=0x7fffffffd250) at ../hw/virtio/virtio.c:3961
+ * #4  0x0000555555ef1d70 in device_set_realized (obj=0x555558406a90, value=true, errp=0x7fffffffd510) at ../hw/core/qdev.c:495
+ * #5  0x0000555555efccbf in property_set_bool (obj=0x555558406a90, v=0x55555840c050, name=0x5555563a55d1 "realized", opaque=0x55555740cf10,
+ *     errp=0x7fffffffd510) at ../qom/object.c:2348
+ * #6  0x0000555555efa803 in object_property_set (obj=0x555558406a90, name=0x5555563a55d1 "realized", v=0x55555840c050, errp=0x7fffffffd510)
+ *     at ../qom/object.c:1455
+ * #7  0x0000555555eff53a in object_property_set_qobject (obj=0x555558406a90, name=0x5555563a55d1 "realized", value=0x5555584312f0, errp=0x7fffffffd510)
+ *     at ../qom/qom-qobject.c:28
+ * #8  0x0000555555efaba8 in object_property_set_bool (obj=0x555558406a90, name=0x5555563a55d1 "realized", value=true, errp=0x7fffffffd510)
+ *     at ../qom/object.c:1525
+ * #9  0x0000555555ef145d in qdev_realize (dev=0x555558406a90, bus=0x555558406a10, errp=0x7fffffffd510) at ../hw/core/qdev.c:276
+ * #10 0x0000555555e5925b in vhost_scsi_pci_realize (vpci_dev=0x5555583fe4d0, errp=0x7fffffffd510) at ../hw/virtio/vhost-scsi-pci.c:62
+ * #11 0x0000555555b7cdb6 in virtio_pci_realize (pci_dev=0x5555583fe4d0, errp=0x7fffffffd510) at ../hw/virtio/virtio-pci.c:2268
+ * #12 0x0000555555a97958 in pci_qdev_realize (qdev=0x5555583fe4d0, errp=0x7fffffffd5d0) at ../hw/pci/pci.c:2114
+ * #13 0x0000555555b7d2d3 in virtio_pci_dc_realize (qdev=0x5555583fe4d0, errp=0x7fffffffd5d0) at ../hw/virtio/virtio-pci.c:2395
+ * #14 0x0000555555ef1d70 in device_set_realized (obj=0x5555583fe4d0, value=true, errp=0x7fffffffd840) at ../hw/core/qdev.c:495
+ * #15 0x0000555555efccbf in property_set_bool (obj=0x5555583fe4d0, v=0x5555584304e0, name=0x5555563a55d1 "realized", opaque=0x55555740cf10,
+ *     errp=0x7fffffffd840) at ../qom/object.c:2348
+ * #16 0x0000555555efa803 in object_property_set (obj=0x5555583fe4d0, name=0x5555563a55d1 "realized", v=0x5555584304e0, errp=0x7fffffffd840)
+ *     at ../qom/object.c:1455
+ * #17 0x0000555555eff53a in object_property_set_qobject (obj=0x5555583fe4d0, name=0x5555563a55d1 "realized", value=0x555558430470,
+ *     errp=0x7fffffffd840) at ../qom/qom-qobject.c:28
+ * #18 0x0000555555efaba8 in object_property_set_bool (obj=0x5555583fe4d0, name=0x5555563a55d1 "realized", value=true, errp=0x7fffffffd840)
+ *     at ../qom/object.c:1525
+ * #19 0x0000555555ef145d in qdev_realize (dev=0x5555583fe4d0, bus=0x555557779c60, errp=0x7fffffffd840) at ../hw/core/qdev.c:276
+ * #20 0x0000555555bd8ea6 in qdev_device_add_from_qdict (opts=0x55555842c7b0, from_json=false, errp=0x7fffffffd840)
+ *     at ../system/qdev-monitor.c:726
+ * #21 0x0000555555bd8f5a in qdev_device_add (opts=0x55555740a160, errp=0x555557350860 <error_fatal>) at ../system/qdev-monitor.c:745
+ * #22 0x0000555555be38b7 in device_init_func (opaque=0x0, opts=0x55555740a160, errp=0x555557350860 <error_fatal>) at ../system/vl.c:1215
+ * #23 0x000055555617e55f in qemu_opts_foreach (list=0x55555722dfe0 <qemu_device_opts>, func=0x555555be3888 <device_init_func>, opaque=0x0,
+ *     errp=0x555557350860 <error_fatal>) at ../util/qemu-option.c:1135
+ * #24 0x0000555555be77ac in qemu_create_cli_devices () at ../system/vl.c:2656
+ * #25 0x0000555555be7a30 in qmp_x_exit_preconfig (errp=0x555557350860 <error_fatal>) at ../system/vl.c:2719
+ * #26 0x0000555555bea569 in qemu_init (argc=21, argv=0x7fffffffdc58) at ../system/vl.c:3753
+ * #27 0x000055555609a086 in main (argc=21, argv=0x7fffffffdc58) at ../system/main.c:47
+ */
+
 /* Features supported by host kernel. */
 static const int kernel_feature_bits[] = {
     VIRTIO_F_NOTIFY_ON_EMPTY,
@@ -43,6 +141,151 @@ static const int kernel_feature_bits[] = {
     VHOST_INVALID_FEATURE_BIT
 };
 
+/*
+ * 9.1的.
+ *
+ * Bootup on source:
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_scsi_set_endpoint (dev=0x5555585519b0, target=0x7fffeae130f0) at ../hw/virtio/vhost-backend.c:81
+ * #1  0x0000555555afe88a in vhost_scsi_set_endpoint (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:56
+ * #2  0x0000555555afeacd in vhost_scsi_start (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:100
+ * #3  0x0000555555afebd8 in vhost_scsi_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/scsi/vhost-scsi.c:134
+ * #4  0x0000555555e33c08 in virtio_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #5  0x0000555555b7b531 in virtio_pci_common_write (opaque=0x555558549290, addr=20, val=15, size=1) at ../hw/virtio/virtio-pci.c:1608
+ * #6  0x0000555555e63c32 in memory_region_write_accessor (mr=0x555558549e80, addr=20, value=0x7fffeae133f8, size=1, shift=0,
+ *     mask=255, attrs=...) at ../system/memory.c:497
+ * #7  0x0000555555e63f79 in access_with_adjusted_size (addr=20, value=0x7fffeae133f8, size=1, access_size_min=1, access_size_max=4,
+ *     access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x555558549e80, attrs=...) at ../system/memory.c:573
+ * #8  0x0000555555e674ae in memory_region_dispatch_write (mr=0x555558549e80, addr=20, data=15, op=MO_8, attrs=...) at ../system/memory.c:1521
+ * #9  0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff7e0c028 "\017", len=1, mr_addr=20, l=0x7fffeae134e0,
+ *     mr=0x555558549e80) at ../system/physmem.c:2803
+ * #10 0x0000555555e76cae in flatview_write_continue (fv=0x7ffbdc32a800, addr=4261429268, attrs=..., ptr=0x7ffff7e0c028,
+ *     len=1, mr_addr=20, l=1, mr=0x555558549e80) at ../system/physmem.c:2833
+ * #11 0x0000555555e76dd6 in flatview_write (fv=0x7ffbdc32a800, addr=4261429268, attrs=..., buf=0x7ffff7e0c028, len=1) at ../system/physmem.c:2864
+ * #12 0x0000555555e77250 in address_space_write (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1) at ../system/physmem.c:2984
+ * #13 0x0000555555e772c8 in address_space_rw (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1, is_write=true) at ../system/physmem.c:2994
+ * #14 0x0000555555ed4d63 in kvm_cpu_exec (cpu=0x5555576e1b00) at ../accel/kvm/kvm-all.c:3075
+ * #15 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x5555576e1b00) at ../accel/kvm/kvm-accel-ops.c:50
+ * #16 0x000055555616b040 in qemu_thread_start (args=0x5555576ec4a0) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #18 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_scsi_clear_endpoint (dev=0x5555585519b0, target=0x7fffeae13110) at ../hw/virtio/vhost-backend.c:87
+ * #1  0x0000555555afe9b0 in vhost_scsi_clear_endpoint (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:72
+ * #2  0x0000555555afeb3f in vhost_scsi_stop (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:113
+ * #3  0x0000555555afec1a in vhost_scsi_set_status (vdev=0x555558551710, val=0 '\000') at ../hw/scsi/vhost-scsi.c:140
+ * #4  0x0000555555e33c08 in virtio_set_status (vdev=0x555558551710, val=0 '\000') at ../hw/virtio/virtio.c:2242
+ * #5  0x0000555555b7b531 in virtio_pci_common_write (opaque=0x555558549290, addr=20, val=0, size=1) at ../hw/virtio/virtio-pci.c:1608
+ * #6  0x0000555555e63c32 in memory_region_write_accessor (mr=0x555558549e80, addr=20, value=0x7fffeae133f8, size=1, shift=0,
+ *     mask=255, attrs=...) at ../system/memory.c:497
+ * #7  0x0000555555e63f79 in access_with_adjusted_size (addr=20, value=0x7fffeae133f8, size=1, access_size_min=1, access_size_max=4,
+ *     access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x555558549e80, attrs=...) at ../system/memory.c:573
+ * #8  0x0000555555e674ae in memory_region_dispatch_write (mr=0x555558549e80, addr=20, data=0, op=MO_8, attrs=...) at ../system/memory.c:1521
+ * #9  0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff7e0c028 "", len=1, mr_addr=20,
+ *     l=0x7fffeae134e0, mr=0x555558549e80) at ../system/physmem.c:2803
+ * #10 0x0000555555e76cae in flatview_write_continue (fv=0x7ffbd8003990, addr=4261429268, attrs=..., ptr=0x7ffff7e0c028, len=1,
+ *     mr_addr=20, l=1, mr=0x555558549e80) at ../system/physmem.c:2833
+ * #11 0x0000555555e76dd6 in flatview_write (fv=0x7ffbd8003990, addr=4261429268, attrs=..., buf=0x7ffff7e0c028, len=1)
+ *     at ../system/physmem.c:2864
+ * #12 0x0000555555e77250 in address_space_write (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1) at ../system/physmem.c:2984
+ * #13 0x0000555555e772c8 in address_space_rw (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1, is_write=true) at ../system/physmem.c:2994
+ * #14 0x0000555555ed4d63 in kvm_cpu_exec (cpu=0x5555576e1b00) at ../accel/kvm/kvm-all.c:3075
+ * #15 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x5555576e1b00) at ../accel/kvm/kvm-accel-ops.c:50
+ * #16 0x000055555616b040 in qemu_thread_start (args=0x5555576ec4a0) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #18 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_scsi_set_endpoint (dev=0x5555585519b0, target=0x7fffeae130f0) at ../hw/virtio/vhost-backend.c:81
+ * #1  0x0000555555afe88a in vhost_scsi_set_endpoint (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:56
+ * #2  0x0000555555afeacd in vhost_scsi_start (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:100
+ * #3  0x0000555555afebd8 in vhost_scsi_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/scsi/vhost-scsi.c:134
+ * #4  0x0000555555e33c08 in virtio_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #5  0x0000555555b7b531 in virtio_pci_common_write (opaque=0x555558549290, addr=20, val=15, size=1) at ../hw/virtio/virtio-pci.c:1608
+ * #6  0x0000555555e63c32 in memory_region_write_accessor (mr=0x555558549e80, addr=20, value=0x7fffeae133f8, size=1, shift=0, mask=255,
+ *     attrs=...) at ../system/memory.c:497
+ * #7  0x0000555555e63f79 in access_with_adjusted_size (addr=20, value=0x7fffeae133f8, size=1, access_size_min=1,
+ *     access_size_max=4, access_fn=0x555555e63b3c <memory_region_write_accessor>, mr=0x555558549e80, attrs=...) at ../system/memory.c:573
+ * #8  0x0000555555e674ae in memory_region_dispatch_write (mr=0x555558549e80, addr=20, data=15, op=MO_8, attrs=...) at ../system/memory.c:1521
+ * #9  0x0000555555e76bdc in flatview_write_continue_step (attrs=..., buf=0x7ffff7e0c028 "\017\020", len=1, mr_addr=20,
+ *     l=0x7fffeae134e0, mr=0x555558549e80) at ../system/physmem.c:2803
+ * #10 0x0000555555e76cae in flatview_write_continue (fv=0x7ffbd8003990, addr=4261429268, attrs=..., ptr=0x7ffff7e0c028,
+ *     len=1, mr_addr=20, l=1, mr=0x555558549e80) at ../system/physmem.c:2833
+ * #11 0x0000555555e76dd6 in flatview_write (fv=0x7ffbd8003990, addr=4261429268, attrs=..., buf=0x7ffff7e0c028, len=1)
+ *     at ../system/physmem.c:2864
+ * #12 0x0000555555e77250 in address_space_write (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1) at ../system/physmem.c:2984
+ * #13 0x0000555555e772c8 in address_space_rw (as=0x55555732a200 <address_space_memory>, addr=4261429268, attrs=...,
+ *     buf=0x7ffff7e0c028, len=1, is_write=true) at ../system/physmem.c:2994
+ * #14 0x0000555555ed4d63 in kvm_cpu_exec (cpu=0x5555576e1b00) at ../accel/kvm/kvm-all.c:3075
+ * #15 0x0000555555ed8469 in kvm_vcpu_thread_fn (arg=0x5555576e1b00) at ../accel/kvm/kvm-accel-ops.c:50
+ * #16 0x000055555616b040 in qemu_thread_start (args=0x5555576ec4a0) at ../util/qemu-thread-posix.c:541
+ * #17 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #18 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * --------------------------
+ *
+ * Migration from source:
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_scsi_clear_endpoint (dev=0x5555585519b0, target=0x7ffbb95d5280) at ../hw/virtio/vhost-backend.c:87
+ * #1  0x0000555555afe9b0 in vhost_scsi_clear_endpoint (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:72
+ * #2  0x0000555555afeb3f in vhost_scsi_stop (s=0x555558551710) at ../hw/scsi/vhost-scsi.c:113
+ * #3  0x0000555555afec1a in vhost_scsi_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/scsi/vhost-scsi.c:140
+ * #4  0x0000555555e33c08 in virtio_set_status (vdev=0x555558551710, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #5  0x0000555555e36d84 in virtio_vmstate_change (opaque=0x555558551710, running=false, state=RUN_STATE_FINISH_MIGRATE)
+ *     at ../hw/virtio/virtio.c:3428
+ * #6  0x0000555555be03d7 in vm_state_notify (running=false, state=RUN_STATE_FINISH_MIGRATE) at ../system/runstate.c:405
+ * #7  0x0000555555bd0b84 in do_vm_stop (state=RUN_STATE_FINISH_MIGRATE, send_stop=true) at ../system/cpus.c:301
+ * #8  0x0000555555bd1b08 in vm_stop (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:712
+ * #9  0x0000555555bd1c83 in vm_stop_force_state (state=RUN_STATE_FINISH_MIGRATE) at ../system/cpus.c:781
+ * #10 0x0000555555c11e3b in migration_stop_vm (s=0x555557400150, state=RUN_STATE_FINISH_MIGRATE) at ../migration/migration.c:225
+ * #11 0x0000555555c17bde in migration_completion_precopy (s=0x555557400150, current_active_state=0x7ffbb95d5588)
+ *     at ../migration/migration.c:2757
+ * #12 0x0000555555c17e13 in migration_completion (s=0x555557400150) at ../migration/migration.c:2839
+ * #13 0x0000555555c18c5a in migration_iteration_run (s=0x555557400150) at ../migration/migration.c:3265
+ * #14 0x0000555555c193b8 in migration_thread (opaque=0x555557400150) at ../migration/migration.c:3531
+ * #15 0x000055555616b040 in qemu_thread_start (args=0x555557e01e50) at ../util/qemu-thread-posix.c:541
+ * #16 0x00007ffff68aa1da in start_thread () from /lib/../lib64/libpthread.so.0
+ * #17 0x00007ffff525ae73 in clone () from /lib/../lib64/libc.so.6
+ *
+ * Migration to target:
+ *
+ * (gdb) bt
+ * #0  vhost_kernel_scsi_set_endpoint (dev=0x555558552430, target=0x7fffffffd5c0) at ../hw/virtio/vhost-backend.c:81
+ * #1  0x0000555555afe88a in vhost_scsi_set_endpoint (s=0x555558552190) at ../hw/scsi/vhost-scsi.c:56
+ * #2  0x0000555555afeacd in vhost_scsi_start (s=0x555558552190) at ../hw/scsi/vhost-scsi.c:100
+ * #3  0x0000555555afebd8 in vhost_scsi_set_status (vdev=0x555558552190, val=15 '\017') at ../hw/scsi/vhost-scsi.c:134
+ * #4  0x0000555555e33c08 in virtio_set_status (vdev=0x555558552190, val=15 '\017') at ../hw/virtio/virtio.c:2242
+ * #5  0x0000555555e36d2f in virtio_vmstate_change (opaque=0x555558552190, running=true, state=RUN_STATE_RUNNING)
+ *     at ../hw/virtio/virtio.c:3420
+ * #6  0x0000555555be0320 in vm_state_notify (running=true, state=RUN_STATE_RUNNING) at ../system/runstate.c:395
+ * #7  0x0000555555bd1be6 in vm_prepare_start (step_pending=false) at ../system/cpus.c:755
+ * #8  0x0000555555bd1c1d in vm_start () at ../system/cpus.c:762
+ * #9  0x0000555555c13324 in process_incoming_migration_bh (opaque=0x5555573fd9d0) at ../migration/migration.c:757
+ * #10 0x0000555555c120bb in migration_bh_dispatch_bh (opaque=0x555557cc41e0) at ../migration/migration.c:284
+ * #11 0x0000555556186520 in aio_bh_call (bh=0x5555573fedc0) at ../util/async.c:171
+ * #12 0x000055555618666e in aio_bh_poll (ctx=0x5555573ff890) at ../util/async.c:218
+ * #13 0x0000555556165595 in aio_dispatch (ctx=0x5555573ff890) at ../util/aio-posix.c:423
+ * #14 0x0000555556186b3d in aio_ctx_dispatch (source=0x5555573ff890, callback=0x0, user_data=0x0) at ../util/async.c:360
+ * #15 0x00007ffff6fd494b in g_main_dispatch (context=0x5555573ffd80) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x5555573ffd80) at ../glib/gmain.c:4043
+ * #17 0x0000555556188215 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561882a3 in os_host_main_loop_wait (timeout=0) at ../util/main-loop.c:310
+ * #19 0x00005555561883d2 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555be0f17 in qemu_main_loop () at ../system/runstate.c:826
+ * #21 0x0000555556093994 in qemu_default_main () at ../system/main.c:37
+ * #22 0x00005555560939d1 in main (argc=22, argv=0x7fffffffdbd8) at ../system/main.c:48
+ *
+ * 在以下调用vhost_scsi_set_endpoint():
+ *   - hw/scsi/vhost-scsi.c|100| <<vhost_scsi_start>> ret = vhost_scsi_set_endpoint(s);
+ */
 static int vhost_scsi_set_endpoint(VHostSCSI *s)
 {
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);
@@ -167,6 +410,34 @@ static const VMStateDescription vmstate_virtio_vhost_scsi = {
     .pre_save = vhost_scsi_pre_save,
 };
 
+/*
+ * Legacy的方式.
+ *
+ * VHOST_SET_OWNER
+ * -> vhost_dev_set_owner()
+ *    -> vhost_worker_create()
+ *    -> for (i = 0; i < dev->nvqs; i++)
+ *         __vhost_vq_attach_worker(dev->vqs[i], worker)
+ *
+ * 新的multiqueue/worker的方式.
+ *
+ * vhost_scsi_ioctl()
+ * -> VHOST_NEW_WORKER
+ *    -> vhost_worker_ioctl()
+ *       -> VHOST_NEW_WORKER
+ *          -> vhost_new_worker()
+ *             -> vhost_worker_create()
+ *
+ * vhost_scsi_ioctl()
+ * -> VHOST_ATTACH_VRING_WORKER
+ *    -> vhost_worker_ioctl()
+ *       -> VHOST_ATTACH_VRING_WORKER
+ *          -> vhost_vq_attach_worker()
+ *             -> __vhost_vq_attach_worker()
+ *
+ * 在以下使用vhost_scsi_set_workers():
+ *   - hw/scsi/vhost-scsi.c|534| <<vhost_scsi_realize>> ret = vhost_scsi_set_workers(vsc, vs->conf.worker_per_virtqueue);
+ */
 static int vhost_scsi_set_workers(VHostSCSICommon *vsc, bool per_virtqueue)
 {
     struct vhost_dev *dev = &vsc->dev;
@@ -277,6 +548,33 @@ static void vhost_scsi_realize(DeviceState *dev, Error **errp)
     vsc->dev.vq_index = 0;
     vsc->dev.backend_features = 0;
 
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     ret = vhost_dev_init(&vsc->dev, (void *)(uintptr_t)vhostfd,
                          VHOST_BACKEND_TYPE_KERNEL, 0, errp);
     if (ret < 0) {
diff --git a/hw/scsi/vhost-user-scsi.c b/hw/scsi/vhost-user-scsi.c
index adb41b981..7efa4ae28 100644
--- a/hw/scsi/vhost-user-scsi.c
+++ b/hw/scsi/vhost-user-scsi.c
@@ -157,6 +157,33 @@ static int vhost_user_scsi_connect(DeviceState *dev, Error **errp)
     vsc->dev.vq_index = 0;
     vsc->dev.backend_features = 0;
 
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     ret = vhost_dev_init(&vsc->dev, &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0,
                          errp);
     if (ret < 0) {
diff --git a/hw/scsi/virtio-scsi-dataplane.c b/hw/scsi/virtio-scsi-dataplane.c
index 95f13fb7c..0c929f52e 100644
--- a/hw/scsi/virtio-scsi-dataplane.c
+++ b/hw/scsi/virtio-scsi-dataplane.c
@@ -65,6 +65,16 @@ void virtio_scsi_dataplane_setup(VirtIOSCSI *s, Error **errp)
     s->vq_aio_context[1] = qemu_get_aio_context();
 
     if (vs->conf.iothread_vq_mapping_list) {
+        /*
+	 * 在以下调用iothread_vq_mapping_apply():
+	 *   - hw/block/virtio-blk.c|1740| <<virtio_blk_vq_aio_context_init>>
+	 *       if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+	 *                 s->vq_aio_context, conf->num_queues, errp)) {
+	 *   - hw/scsi/virtio-scsi-dataplane.c|68| <<virtio_scsi_dataplane_setup>>
+	 *       if (!iothread_vq_mapping_apply(vs->conf.iothread_vq_mapping_list,
+	 *                 &s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED],
+	 *                 vs->conf.num_queues, errp)) {
+	 */
         if (!iothread_vq_mapping_apply(vs->conf.iothread_vq_mapping_list,
                     &s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED],
                     vs->conf.num_queues, errp)) {
@@ -132,6 +142,18 @@ static void virtio_scsi_dataplane_stop_vq_bh(void *opaque)
     virtio_queue_aio_detach_host_notifier(vq, ctx);
     host_notifier = virtio_queue_get_host_notifier(vq);
 
+    /*
+     * 在以下使用virtio_queue_host_notifier_read():
+     *   - hw/block/virtio-blk.c|2065| <<virtio_blk_ioeventfd_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+     *   - hw/scsi/virtio-scsi-dataplane.c|149| <<virtio_scsi_dataplane_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+     *   - hw/virtio/virtio-bus.c|328| <<virtio_bus_cleanup_host_notifier>> virtio_queue_host_notifier_read(notifier);
+     *   - hw/virtio/virtio.c|3829| <<virtio_queue_aio_attach_host_notifier>> aio_set_event_notifier(ctx, &vq->host_notifier,
+     *        virtio_queue_host_notifier_read, virtio_queue_host_notifier_aio_poll, virtio_queue_host_notifier_aio_poll_ready);
+     *   - hw/virtio/virtio.c|3858| <<virtio_queue_aio_attach_host_notifier_no_poll>> aio_set_event_notifier(ctx,
+     *        &vq->host_notifier, virtio_queue_host_notifier_read, NULL, NULL);
+     *   - hw/virtio/virtio.c|4077| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier,
+     *        virtio_queue_host_notifier_read);
+     */
     /*
      * Test and clear notifier after disabling event, in case poll callback
      * didn't have time to run.
@@ -139,6 +161,13 @@ static void virtio_scsi_dataplane_stop_vq_bh(void *opaque)
     virtio_queue_host_notifier_read(host_notifier);
 }
 
+/*
+ * 在以下使用VirtioDeviceClass->start_ioeventfd:
+ *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+ *   - hw/scsi/virtio-scsi.c|1421| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+ *   - hw/virtio/virtio.c|4153| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+ */
 /* Context: BQL held */
 int virtio_scsi_dataplane_start(VirtIODevice *vdev)
 {
@@ -200,6 +229,17 @@ int virtio_scsi_dataplane_start(VirtIODevice *vdev)
     smp_wmb(); /* paired with aio_notify_accept() */
 
     if (s->bus.drain_count == 0) {
+        /*
+	 * 在以下使用virtio_queue_aio_attach_host_notifier():
+	 *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>>
+	 *        virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+	 *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>>
+	 *        virtio_queue_aio_attach_host_notifier(vs->ctrl_vq, s->vq_aio_context[0]);
+	 *   - hw/scsi/virtio-scsi-dataplane.c|210| <<virtio_scsi_dataplane_start>>
+	 *        virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
+	 *   - hw/scsi/virtio-scsi.c|1250| <<virtio_scsi_drained_end>>
+	 *        virtio_queue_aio_attach_host_notifier(vq, ctx);
+	 */
         virtio_queue_aio_attach_host_notifier(vs->ctrl_vq,
                                               s->vq_aio_context[0]);
         virtio_queue_aio_attach_host_notifier_no_poll(vs->event_vq,
@@ -207,6 +247,17 @@ int virtio_scsi_dataplane_start(VirtIODevice *vdev)
 
         for (i = 0; i < vs->conf.num_queues; i++) {
             AioContext *ctx = s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED + i];
+            /*
+	     * 在以下使用virtio_queue_aio_attach_host_notifier():
+	     *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>>
+	     *        virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+	     *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>>
+	     *        virtio_queue_aio_attach_host_notifier(vs->ctrl_vq, s->vq_aio_context[0]);
+	     *   - hw/scsi/virtio-scsi-dataplane.c|210| <<virtio_scsi_dataplane_start>>
+	     *        virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
+	     *   - hw/scsi/virtio-scsi.c|1250| <<virtio_scsi_drained_end>>
+	     *        virtio_queue_aio_attach_host_notifier(vq, ctx);
+	     */
             virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
         }
     }
diff --git a/hw/scsi/virtio-scsi.c b/hw/scsi/virtio-scsi.c
index f5a3aa236..e52ebe999 100644
--- a/hw/scsi/virtio-scsi.c
+++ b/hw/scsi/virtio-scsi.c
@@ -1247,6 +1247,17 @@ static void virtio_scsi_drained_end(SCSIBus *bus)
         if (vq == vs->event_vq) {
             virtio_queue_aio_attach_host_notifier_no_poll(vq, ctx);
         } else {
+            /*
+	     * 在以下使用virtio_queue_aio_attach_host_notifier():
+	     *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>>
+	     *        virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+	     *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>>
+	     *        virtio_queue_aio_attach_host_notifier(vs->ctrl_vq, s->vq_aio_context[0]);
+	     *   - hw/scsi/virtio-scsi-dataplane.c|210| <<virtio_scsi_dataplane_start>>
+	     *        virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
+	     *   - hw/scsi/virtio-scsi.c|1250| <<virtio_scsi_drained_end>>
+	     *        virtio_queue_aio_attach_host_notifier(vq, ctx);
+	     */
             virtio_queue_aio_attach_host_notifier(vq, ctx);
         }
     }
diff --git a/hw/timer/arm_timer.c b/hw/timer/arm_timer.c
index 1213b77aa..28f228bcc 100644
--- a/hw/timer/arm_timer.c
+++ b/hw/timer/arm_timer.c
@@ -181,6 +181,22 @@ static arm_timer_state *arm_timer_init(uint32_t freq)
     s->control = TIMER_CTRL_IE;
 
     s->timer = ptimer_init(arm_timer_tick, s, PTIMER_POLICY_LEGACY);
+    /*
+     * 在以下使用vmstate_register_any():
+     *   - audio/audio.c|1787| <<audio_init>> vmstate_register_any(NULL, &vmstate_audio, s);
+     *   - backends/dbus-vmstate.c|429| <<dbus_vmstate_complete>> if (vmstate_register_any(VMSTATE_IF(self), &dbus_vmstate, self) < 0) {
+     *   - backends/tpm/tpm_emulator.c|1009| <<tpm_emulator_inst_init>> vmstate_register_any(NULL, &vmstate_tpm_emulator, obj);
+     *   - hw/display/vmware_vga.c|1265| <<vmsvga_init>> vmstate_register_any(NULL, &vmstate_vga_common, &s->vga);
+     *   - hw/i2c/core.c|66| <<i2c_init_bus>> vmstate_register_any(NULL, &vmstate_i2c_bus, bus);
+     *   - hw/ide/isa.c|76| <<isa_ide_realizefn>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_ide_isa, s);
+     *   - hw/input/adb.c|250| <<adb_bus_realize>> vmstate_register_any(NULL, &vmstate_adb_bus, adb_bus);
+     *   - hw/net/eepro100.c|1888| <<e100_nic_realize>> vmstate_register_any(VMSTATE_IF(&pci_dev->qdev), s->vmstate, s);
+     *   - hw/nvram/eeprom93xx.c|324| <<eeprom93xx_new>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_eeprom, eeprom);
+     *   - hw/pci/pci.c|178| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+     *   - hw/ppc/spapr_nvdimm.c|879| <<spapr_nvdimm_realize>> vmstate_register_any(NULL, &vmstate_spapr_nvdimm_states, dimm);
+     *   - hw/timer/arm_timer.c|184| <<arm_timer_init>> vmstate_register_any(NULL, &vmstate_arm_timer, s);
+     *   - hw/virtio/virtio-mem.c|1122| <<virtio_mem_device_realize>> vmstate_register_any(VMSTATE_IF(vmem), &vmstate_virtio_mem_device_early, vmem);
+     */
     vmstate_register_any(NULL, &vmstate_arm_timer, s);
     return s;
 }
diff --git a/hw/timer/hpet.c b/hw/timer/hpet.c
index ccb97b680..2dced59c6 100644
--- a/hw/timer/hpet.c
+++ b/hw/timer/hpet.c
@@ -151,6 +151,14 @@ static int deactivating_bit(uint64_t old, uint64_t new, uint64_t mask)
     return ((old & mask) && !(new & mask));
 }
 
+/*
+ * 在以下使用hpet_get_ticks():
+ *   - hw/timer/hpet.c|238| <<hpet_pre_save>> s->hpet_counter = hpet_get_ticks(s);
+ *   - hw/timer/hpet.c|371| <<hpet_timer>> uint64_t cur_tick = hpet_get_ticks(t->state);
+ *   - hw/timer/hpet.c|392| <<hpet_set_timer>> uint64_t cur_tick = hpet_get_ticks(t->state);
+ *   - hw/timer/hpet.c|459| <<hpet_ram_read>> cur_tick = hpet_get_ticks(s);
+ *   - hw/timer/hpet.c|574| <<hpet_ram_write>> s->hpet_counter = hpet_get_ticks(s);
+ */
 static uint64_t hpet_get_ticks(HPETState *s)
 {
     return ns_to_ticks(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + s->hpet_offset);
diff --git a/hw/vfio/helpers.c b/hw/vfio/helpers.c
index 4b255d4f3..420c2d994 100644
--- a/hw/vfio/helpers.c
+++ b/hw/vfio/helpers.c
@@ -109,6 +109,23 @@ static const char *index_to_str(VFIODevice *vbasedev, int index)
     }
 }
 
+/*
+ * 在以下使用vfio_set_irq_signaling():
+ *   - hw/vfio/ap.c|120| <<vfio_ap_register_irq_notifier>> if (!vfio_set_irq_signaling(vdev, irq, 0, VFIO_IRQ_SET_ACTION_TRIGGER, fd,
+ *   - hw/vfio/ap.c|144| <<vfio_ap_unregister_irq_notifier>> if (!vfio_set_irq_signaling(&vapdev->vdev, irq, 0,
+ *   - hw/vfio/ccw.c|429| <<vfio_ccw_register_irq_notifier>> if (!vfio_set_irq_signaling(vdev, irq, 0,
+ *   - hw/vfio/ccw.c|459| <<vfio_ccw_unregister_irq_notifier>> if (!vfio_set_irq_signaling(&vcdev->vdev, irq, 0,
+ *   - hw/vfio/pci.c|150| <<vfio_intx_enable_kvm>> if (!vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0,
+ *   - hw/vfio/pci.c|300| <<vfio_intx_enable>> if (!vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0,
+ *   - hw/vfio/pci.c|594| <<vfio_msix_vector_do_use>> if (!vfio_set_irq_signaling(&vdev->vbasedev,
+ *   - hw/vfio/pci.c|639| <<vfio_msix_vector_release>> if (!vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_MSIX_IRQ_INDEX,
+ *   - hw/vfio/pci.c|2870| <<vfio_register_err_notifier>> if (!vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_ERR_IRQ_INDEX, 0,
+ *   - hw/vfio/pci.c|2887| <<vfio_unregister_err_notifier>> if (!vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_ERR_IRQ_INDEX, 0,
+ *   - hw/vfio/pci.c|2935| <<vfio_register_req_notifier>> if (!vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_REQ_IRQ_INDEX, 0,
+ *   - hw/vfio/pci.c|2953| <<vfio_unregister_req_notifier>> if (!vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_REQ_IRQ_INDEX, 0,
+ *   - hw/vfio/platform.c|121| <<vfio_set_trigger_eventfd>> if (!vfio_set_irq_signaling(vbasedev, intp->pin, 0,
+ *   - hw/vfio/platform.c|359| <<vfio_set_resample_eventfd>> if (!vfio_set_irq_signaling(vbasedev, intp->pin, 0,
+ */
 bool vfio_set_irq_signaling(VFIODevice *vbasedev, int index, int subindex,
                             int action, int fd, Error **errp)
 {
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index 7f1532fbe..f1f0c1773 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -446,6 +446,16 @@ static int vfio_enable_vectors(VFIOPCIDevice *vdev, bool msix)
                 (msix && msix_is_masked(&vdev->pdev, i))) {
                 fd = event_notifier_get_fd(&vdev->msi_vectors[i].interrupt);
             } else {
+                /*
+		 * 在以下使用VFIOMSIVector->kvm_interrupt:
+		 *   - hw/vfio/pci.c|449| <<vfio_enable_vectors>> fd = event_notifier_get_fd(&vdev->msi_vectors[i].kvm_interrupt);
+		 *   - hw/vfio/pci.c|480| <<vfio_connect_kvm_msi_virq>> if (event_notifier_init(&vector->kvm_interrupt, 0)) {
+		 *   - hw/vfio/pci.c|484| <<vfio_connect_kvm_msi_virq>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+		 *   - hw/vfio/pci.c|492| <<vfio_connect_kvm_msi_virq>> event_notifier_cleanup(&vector->kvm_interrupt);
+		 *   - hw/vfio/pci.c|500| <<vfio_remove_kvm_msi_virq>> kvm_irqchip_remove_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+		 *   - hw/vfio/pci.c|504| <<vfio_remove_kvm_msi_virq>> event_notifier_cleanup(&vector->kvm_interrupt);
+		 *   - hw/vfio/pci.c|589| <<vfio_msix_vector_do_use>> fd = event_notifier_get_fd(&vector->kvm_interrupt);
+		 */
                 fd = event_notifier_get_fd(&vdev->msi_vectors[i].kvm_interrupt);
             }
         }
@@ -471,12 +481,34 @@ static void vfio_add_kvm_msi_virq(VFIOPCIDevice *vdev, VFIOMSIVector *vector,
                                              vector_n, &vdev->pdev);
 }
 
+/*
+ * 在以下使用vfio_connect_kvm_msi_virq():
+ *   - hw/vfio/pci.c|557| <<vfio_msix_vector_do_use>> vfio_connect_kvm_msi_virq(vector);
+ *   - hw/vfio/pci.c|664| <<vfio_commit_kvm_msi_virq_batch>> vfio_connect_kvm_msi_virq(&vdev->msi_vectors[i]);
+ */
 static void vfio_connect_kvm_msi_virq(VFIOMSIVector *vector)
 {
     if (vector->virq < 0) {
         return;
     }
 
+    /*
+     * 在以下使用VFIOMSIVector->kvm_interrupt:
+     *   - hw/vfio/pci.c|449| <<vfio_enable_vectors>> fd = event_notifier_get_fd(&vdev->msi_vectors[i].kvm_interrupt);
+     *   - hw/vfio/pci.c|480| <<vfio_connect_kvm_msi_virq>> if (event_notifier_init(&vector->kvm_interrupt, 0)) {
+     *   - hw/vfio/pci.c|484| <<vfio_connect_kvm_msi_virq>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+     *   - hw/vfio/pci.c|492| <<vfio_connect_kvm_msi_virq>> event_notifier_cleanup(&vector->kvm_interrupt);
+     *   - hw/vfio/pci.c|500| <<vfio_remove_kvm_msi_virq>> kvm_irqchip_remove_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+     *   - hw/vfio/pci.c|504| <<vfio_remove_kvm_msi_virq>> event_notifier_cleanup(&vector->kvm_interrupt);
+     *   - hw/vfio/pci.c|589| <<vfio_msix_vector_do_use>> fd = event_notifier_get_fd(&vector->kvm_interrupt);
+     *
+     * struct VFIOMSIVector:
+     * -> EventNotifier interrupt;
+     * -> EventNotifier kvm_interrupt;
+     * -> struct VFIOPCIDevice *vdev;
+     * -> int virq;
+     * -> bool use;
+     */
     if (event_notifier_init(&vector->kvm_interrupt, 0)) {
         goto fail_notifier;
     }
@@ -497,6 +529,16 @@ fail_notifier:
 
 static void vfio_remove_kvm_msi_virq(VFIOMSIVector *vector)
 {
+    /*
+     * 在以下使用VFIOMSIVector->kvm_interrupt:
+     *   - hw/vfio/pci.c|449| <<vfio_enable_vectors>> fd = event_notifier_get_fd(&vdev->msi_vectors[i].kvm_interrupt);
+     *   - hw/vfio/pci.c|480| <<vfio_connect_kvm_msi_virq>> if (event_notifier_init(&vector->kvm_interrupt, 0)) {
+     *   - hw/vfio/pci.c|484| <<vfio_connect_kvm_msi_virq>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+     *   - hw/vfio/pci.c|492| <<vfio_connect_kvm_msi_virq>> event_notifier_cleanup(&vector->kvm_interrupt);
+     *   - hw/vfio/pci.c|500| <<vfio_remove_kvm_msi_virq>> kvm_irqchip_remove_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+     *   - hw/vfio/pci.c|504| <<vfio_remove_kvm_msi_virq>> event_notifier_cleanup(&vector->kvm_interrupt);
+     *   - hw/vfio/pci.c|589| <<vfio_msix_vector_do_use>> fd = event_notifier_get_fd(&vector->kvm_interrupt);
+     */
     kvm_irqchip_remove_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
                                           vector->virq);
     kvm_irqchip_release_virq(kvm_state, vector->virq);
@@ -586,6 +628,16 @@ static int vfio_msix_vector_do_use(PCIDevice *pdev, unsigned int nr,
             int32_t fd;
 
             if (vector->virq >= 0) {
+                /*
+		 * 在以下使用VFIOMSIVector->kvm_interrupt:
+		 *   - hw/vfio/pci.c|449| <<vfio_enable_vectors>> fd = event_notifier_get_fd(&vdev->msi_vectors[i].kvm_interrupt);
+		 *   - hw/vfio/pci.c|480| <<vfio_connect_kvm_msi_virq>> if (event_notifier_init(&vector->kvm_interrupt, 0)) {
+		 *   - hw/vfio/pci.c|484| <<vfio_connect_kvm_msi_virq>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+		 *   - hw/vfio/pci.c|492| <<vfio_connect_kvm_msi_virq>> event_notifier_cleanup(&vector->kvm_interrupt);
+		 *   - hw/vfio/pci.c|500| <<vfio_remove_kvm_msi_virq>> kvm_irqchip_remove_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+		 *   - hw/vfio/pci.c|504| <<vfio_remove_kvm_msi_virq>> event_notifier_cleanup(&vector->kvm_interrupt);
+		 *   - hw/vfio/pci.c|589| <<vfio_msix_vector_do_use>> fd = event_notifier_get_fd(&vector->kvm_interrupt);
+		 */
                 fd = event_notifier_get_fd(&vector->kvm_interrupt);
             } else {
                 fd = event_notifier_get_fd(&vector->interrupt);
diff --git a/hw/vfio/pci.h b/hw/vfio/pci.h
index d94ecaba6..6068aeef9 100644
--- a/hw/vfio/pci.h
+++ b/hw/vfio/pci.h
@@ -92,6 +92,16 @@ typedef struct VFIOMSIVector {
      * valid (>= 0) value.
      */
     EventNotifier interrupt;
+    /*
+     * 在以下使用VFIOMSIVector->kvm_interrupt:
+     *   - hw/vfio/pci.c|449| <<vfio_enable_vectors>> fd = event_notifier_get_fd(&vdev->msi_vectors[i].kvm_interrupt);
+     *   - hw/vfio/pci.c|480| <<vfio_connect_kvm_msi_virq>> if (event_notifier_init(&vector->kvm_interrupt, 0)) {
+     *   - hw/vfio/pci.c|484| <<vfio_connect_kvm_msi_virq>> if (kvm_irqchip_add_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+     *   - hw/vfio/pci.c|492| <<vfio_connect_kvm_msi_virq>> event_notifier_cleanup(&vector->kvm_interrupt);
+     *   - hw/vfio/pci.c|500| <<vfio_remove_kvm_msi_virq>> kvm_irqchip_remove_irqfd_notifier_gsi(kvm_state, &vector->kvm_interrupt,
+     *   - hw/vfio/pci.c|504| <<vfio_remove_kvm_msi_virq>> event_notifier_cleanup(&vector->kvm_interrupt);
+     *   - hw/vfio/pci.c|589| <<vfio_msix_vector_do_use>> fd = event_notifier_get_fd(&vector->kvm_interrupt);
+     */
     EventNotifier kvm_interrupt;
     struct VFIOPCIDevice *vdev; /* back pointer to device */
     int virq;
diff --git a/hw/virtio/iothread-vq-mapping.c b/hw/virtio/iothread-vq-mapping.c
index 15909eb93..b1f415e27 100644
--- a/hw/virtio/iothread-vq-mapping.c
+++ b/hw/virtio/iothread-vq-mapping.c
@@ -72,6 +72,16 @@ iothread_vq_mapping_validate(IOThreadVirtQueueMappingList *list, uint16_t
     return true;
 }
 
+/*
+ * 在以下调用iothread_vq_mapping_apply():
+ *   - hw/block/virtio-blk.c|1740| <<virtio_blk_vq_aio_context_init>>
+ *       if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+ *                 s->vq_aio_context, conf->num_queues, errp)) {
+ *   - hw/scsi/virtio-scsi-dataplane.c|68| <<virtio_scsi_dataplane_setup>>
+ *       if (!iothread_vq_mapping_apply(vs->conf.iothread_vq_mapping_list,
+ *                 &s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED],
+ *                 vs->conf.num_queues, errp)) {
+ */
 bool iothread_vq_mapping_apply(
         IOThreadVirtQueueMappingList *list,
         AioContext **vq_aio_context,
diff --git a/hw/virtio/vdpa-dev.c b/hw/virtio/vdpa-dev.c
index a7e73b1c9..704350f28 100644
--- a/hw/virtio/vdpa-dev.c
+++ b/hw/virtio/vdpa-dev.c
@@ -117,6 +117,33 @@ static void vhost_vdpa_device_realize(DeviceState *dev, Error **errp)
     v->vdpa.shared->device_fd = v->vhostfd;
     v->vdpa.shared->iova_range = iova_range;
 
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     ret = vhost_dev_init(&v->dev, &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
     if (ret < 0) {
         error_setg(errp, "vhost-vdpa-device: vhost initialization failed: %s",
diff --git a/hw/virtio/vhost-user-base.c b/hw/virtio/vhost-user-base.c
index 2bc342332..58079bf5f 100644
--- a/hw/virtio/vhost-user-base.c
+++ b/hw/virtio/vhost-user-base.c
@@ -323,6 +323,33 @@ static void vub_device_realize(DeviceState *dev, Error **errp)
     vub->vhost_dev.nvqs = vub->num_vqs;
     vub->vhost_dev.vqs = g_new0(struct vhost_virtqueue, vub->vhost_dev.nvqs);
 
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     /* connect to backend */
     ret = vhost_dev_init(&vub->vhost_dev, &vub->vhost_user,
                          VHOST_BACKEND_TYPE_USER, 0, errp);
diff --git a/hw/virtio/vhost-user-fs.c b/hw/virtio/vhost-user-fs.c
index 3f00d79ed..998f8ee8c 100644
--- a/hw/virtio/vhost-user-fs.c
+++ b/hw/virtio/vhost-user-fs.c
@@ -250,6 +250,33 @@ static void vuf_device_realize(DeviceState *dev, Error **errp)
     /* 1 high prio queue, plus the number configured */
     fs->vhost_dev.nvqs = 1 + fs->conf.num_request_queues;
     fs->vhost_dev.vqs = g_new0(struct vhost_virtqueue, fs->vhost_dev.nvqs);
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     ret = vhost_dev_init(&fs->vhost_dev, &fs->vhost_user,
                          VHOST_BACKEND_TYPE_USER, 0, errp);
     if (ret < 0) {
diff --git a/hw/virtio/vhost-user-scmi.c b/hw/virtio/vhost-user-scmi.c
index 410a936ca..b62630081 100644
--- a/hw/virtio/vhost-user-scmi.c
+++ b/hw/virtio/vhost-user-scmi.c
@@ -247,6 +247,33 @@ static void vu_scmi_device_realize(DeviceState *dev, Error **errp)
     scmi->vhost_dev.nvqs = 2;
     scmi->vhost_dev.vqs = g_new0(struct vhost_virtqueue, scmi->vhost_dev.nvqs);
 
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     ret = vhost_dev_init(&scmi->vhost_dev, &scmi->vhost_user,
                          VHOST_BACKEND_TYPE_USER, 0, errp);
     if (ret < 0) {
diff --git a/hw/virtio/vhost-user-vsock.c b/hw/virtio/vhost-user-vsock.c
index 293273080..bbb4d59f0 100644
--- a/hw/virtio/vhost-user-vsock.c
+++ b/hw/virtio/vhost-user-vsock.c
@@ -109,6 +109,33 @@ static void vuv_device_realize(DeviceState *dev, Error **errp)
 
     vhost_dev_set_config_notifier(&vvc->vhost_dev, &vsock_ops);
 
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     ret = vhost_dev_init(&vvc->vhost_dev, &vsock->vhost_user,
                          VHOST_BACKEND_TYPE_USER, 0, errp);
     if (ret < 0) {
diff --git a/hw/virtio/vhost-vsock.c b/hw/virtio/vhost-vsock.c
index 940b30fa2..dd2258365 100644
--- a/hw/virtio/vhost-vsock.c
+++ b/hw/virtio/vhost-vsock.c
@@ -168,6 +168,33 @@ static void vhost_vsock_device_realize(DeviceState *dev, Error **errp)
 
     vhost_vsock_common_realize(vdev);
 
+    /*
+     * 在以下调用vhost_dev_init():
+     *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+     *        options->opaque, options->backend_type, 0, &local_err);
+     *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+     *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+     *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+     *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+     *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+     *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+     *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+     *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+     *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+     *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+     *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+     *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+     */
     ret = vhost_dev_init(&vvc->vhost_dev, (void *)(uintptr_t)vhostfd,
                          VHOST_BACKEND_TYPE_KERNEL, 0, errp);
     if (ret < 0) {
diff --git a/hw/virtio/vhost.c b/hw/virtio/vhost.c
index 6aa72fd43..776191d4d 100644
--- a/hw/virtio/vhost.c
+++ b/hw/virtio/vhost.c
@@ -1506,6 +1506,33 @@ static void vhost_virtqueue_cleanup(struct vhost_virtqueue *vq)
     }
 }
 
+/*
+ * 在以下调用vhost_dev_init():
+ *   - backends/cryptodev-vhost.c|69| <<cryptodev_vhost_init>> r = vhost_dev_init(&crypto->dev,
+ *        options->opaque, options->backend_type, 0, &local_err);
+ *   - backends/vhost-user.c|39| <<vhost_user_backend_dev_init>> ret = vhost_dev_init(&b->dev,
+ *        &b->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+ *   - hw/block/vhost-user-blk.c|348| <<vhost_user_blk_connect>> ret = vhost_dev_init(&s->dev,
+ *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+ *   - hw/net/vhost_net.c|354| <<vhost_net_init>> r = vhost_dev_init(&net->dev,
+ *        options->opaque, options->backend_type, options->busyloop_timeout, &local_err);
+ *   - hw/scsi/vhost-scsi.c|523| <<vhost_scsi_realize>> ret = vhost_dev_init(&vsc->dev,
+ *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+ *   - hw/scsi/vhost-user-scsi.c|160| <<vhost_user_scsi_connect>> ret = vhost_dev_init(&vsc->dev,
+ *        &s->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+ *   - hw/virtio/vdpa-dev.c|120| <<vhost_vdpa_device_realize>> ret = vhost_dev_init(&v->dev,
+ *        &v->vdpa, VHOST_BACKEND_TYPE_VDPA, 0, NULL);
+ *   - hw/virtio/vhost-user-base.c|327| <<vub_device_realize>> ret = vhost_dev_init(&vub->vhost_dev,
+ *        &vub->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+ *   - hw/virtio/vhost-user-fs.c|253| <<vuf_device_realize>> ret = vhost_dev_init(&fs->vhost_dev,
+ *        &fs->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+ *   - hw/virtio/vhost-user-scmi.c|250| <<vu_scmi_device_realize>> ret = vhost_dev_init(&scmi->vhost_dev,
+ *        &scmi->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+ *   - hw/virtio/vhost-user-vsock.c|112| <<vuv_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+ *        &vsock->vhost_user, VHOST_BACKEND_TYPE_USER, 0, errp);
+ *   - hw/virtio/vhost-vsock.c|171| <<vhost_vsock_device_realize>> ret = vhost_dev_init(&vvc->vhost_dev,
+ *        (void *)(uintptr_t)vhostfd, VHOST_BACKEND_TYPE_KERNEL, 0, errp);
+ */
 int vhost_dev_init(struct vhost_dev *hdev, void *opaque,
                    VhostBackendType backend_type, uint32_t busyloop_timeout,
                    Error **errp)
diff --git a/hw/virtio/virtio-bus.c b/hw/virtio/virtio-bus.c
index 896feb37a..0e1bfec28 100644
--- a/hw/virtio/virtio-bus.c
+++ b/hw/virtio/virtio-bus.c
@@ -233,6 +233,13 @@ int virtio_bus_start_ioeventfd(VirtioBusState *bus)
 
     /* Only set our notifier if we have ownership.  */
     if (!bus->ioeventfd_grabbed) {
+        /*
+	 * 在以下使用VirtioDeviceClass->start_ioeventfd:
+	 *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+         *   - hw/scsi/virtio-scsi.c|1421| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+         *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+         *   - hw/virtio/virtio.c|4153| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+	 */
         r = vdc->start_ioeventfd(vdev);
         if (r < 0) {
             error_report("%s: failed. Fallback to userspace (slower).", __func__);
@@ -315,6 +322,18 @@ void virtio_bus_cleanup_host_notifier(VirtioBusState *bus, int n)
     VirtQueue *vq = virtio_get_queue(vdev, n);
     EventNotifier *notifier = virtio_queue_get_host_notifier(vq);
 
+    /*
+     * 在以下使用virtio_queue_host_notifier_read():
+     *   - hw/block/virtio-blk.c|2065| <<virtio_blk_ioeventfd_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+     *   - hw/scsi/virtio-scsi-dataplane.c|149| <<virtio_scsi_dataplane_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+     *   - hw/virtio/virtio-bus.c|328| <<virtio_bus_cleanup_host_notifier>> virtio_queue_host_notifier_read(notifier);
+     *   - hw/virtio/virtio.c|3829| <<virtio_queue_aio_attach_host_notifier>> aio_set_event_notifier(ctx, &vq->host_notifier,
+     *        virtio_queue_host_notifier_read, virtio_queue_host_notifier_aio_poll, virtio_queue_host_notifier_aio_poll_ready);
+     *   - hw/virtio/virtio.c|3858| <<virtio_queue_aio_attach_host_notifier_no_poll>> aio_set_event_notifier(ctx,
+     *        &vq->host_notifier, virtio_queue_host_notifier_read, NULL, NULL);
+     *   - hw/virtio/virtio.c|4077| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier,
+     *        virtio_queue_host_notifier_read);
+     */
     /* Test and clear notifier after disabling event,
      * in case poll callback didn't have time to run.
      */
diff --git a/hw/virtio/virtio-mem.c b/hw/virtio/virtio-mem.c
index 5f57eccbb..e134cfab3 100644
--- a/hw/virtio/virtio-mem.c
+++ b/hw/virtio/virtio-mem.c
@@ -1119,6 +1119,22 @@ static void virtio_mem_device_realize(DeviceState *dev, Error **errp)
     host_memory_backend_set_mapped(vmem->memdev, true);
     vmstate_register_ram(&vmem->memdev->mr, DEVICE(vmem));
     if (vmem->early_migration) {
+        /*
+	 * 在以下使用vmstate_register_any():
+	 *   - audio/audio.c|1787| <<audio_init>> vmstate_register_any(NULL, &vmstate_audio, s);
+	 *   - backends/dbus-vmstate.c|429| <<dbus_vmstate_complete>> if (vmstate_register_any(VMSTATE_IF(self), &dbus_vmstate, self) < 0) {
+	 *   - backends/tpm/tpm_emulator.c|1009| <<tpm_emulator_inst_init>> vmstate_register_any(NULL, &vmstate_tpm_emulator, obj);
+	 *   - hw/display/vmware_vga.c|1265| <<vmsvga_init>> vmstate_register_any(NULL, &vmstate_vga_common, &s->vga);
+	 *   - hw/i2c/core.c|66| <<i2c_init_bus>> vmstate_register_any(NULL, &vmstate_i2c_bus, bus);
+	 *   - hw/ide/isa.c|76| <<isa_ide_realizefn>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_ide_isa, s);
+	 *   - hw/input/adb.c|250| <<adb_bus_realize>> vmstate_register_any(NULL, &vmstate_adb_bus, adb_bus);
+	 *   - hw/net/eepro100.c|1888| <<e100_nic_realize>> vmstate_register_any(VMSTATE_IF(&pci_dev->qdev), s->vmstate, s);
+	 *   - hw/nvram/eeprom93xx.c|324| <<eeprom93xx_new>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_eeprom, eeprom);
+	 *   - hw/pci/pci.c|178| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+	 *   - hw/ppc/spapr_nvdimm.c|879| <<spapr_nvdimm_realize>> vmstate_register_any(NULL, &vmstate_spapr_nvdimm_states, dimm);
+	 *   - hw/timer/arm_timer.c|184| <<arm_timer_init>> vmstate_register_any(NULL, &vmstate_arm_timer, s);
+	 *   - hw/virtio/virtio-mem.c|1122| <<virtio_mem_device_realize>> vmstate_register_any(VMSTATE_IF(vmem), &vmstate_virtio_mem_device_early, vmem);
+	 */
         vmstate_register_any(VMSTATE_IF(vmem),
                              &vmstate_virtio_mem_device_early, vmem);
     }
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index 85110bce3..b6d0d9187 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -2471,6 +2471,11 @@ void virtio_queue_set_shadow_avail_idx(VirtQueue *vq, uint16_t shadow_avail_idx)
     }
 }
 
+/*
+ * 在以下使用virtio_queue_notify_vq():
+ *   - hw/virtio/virtio.c|3783| <<virtio_queue_host_notifier_aio_poll_ready>> virtio_queue_notify_vq(vq);
+ *   - hw/virtio/virtio.c|3869| <<virtio_queue_host_notifier_read>> virtio_queue_notify_vq(vq);
+ */
 static void virtio_queue_notify_vq(VirtQueue *vq)
 {
     if (vq->vring.desc && vq->handle_output) {
@@ -2982,6 +2987,12 @@ static const VMStateDescription vmstate_virtio_disabled = {
     }
 };
 
+/*
+ * 在以下使用vmstate_virtio:
+ *   - hw/virtio/virtio.c|2991| <<global>> static const VMStateDescription vmstate_virtio = {
+ *   - hw/virtio/virtio.c|3068| <<virtio_save>> return vmstate_save_state(f, &vmstate_virtio, vdev, NULL);
+ *   - hw/virtio/virtio.c|3317| <<virtio_load>> ret = vmstate_load_state(f, &vmstate_virtio, vdev, 1);
+ */
 static const VMStateDescription vmstate_virtio = {
     .name = "virtio",
     .version_id = 1,
@@ -3003,6 +3014,10 @@ static const VMStateDescription vmstate_virtio = {
     }
 };
 
+/*
+ * 只在以下调用virtio_save():
+ *   - hw/virtio/virtio.c|3087| <<virtio_device_put>> return virtio_save(VIRTIO_DEVICE(opaque), f);
+ */
 int virtio_save(VirtIODevice *vdev, QEMUFile *f)
 {
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
@@ -3060,6 +3075,12 @@ int virtio_save(VirtIODevice *vdev, QEMUFile *f)
     }
 
     /* Subsections */
+    /*
+     * 在以下使用vmstate_virtio:
+     *   - hw/virtio/virtio.c|2991| <<global>> static const VMStateDescription vmstate_virtio = {
+     *   - hw/virtio/virtio.c|3068| <<virtio_save>> return vmstate_save_state(f, &vmstate_virtio, vdev, NULL);
+     *   - hw/virtio/virtio.c|3317| <<virtio_load>> ret = vmstate_load_state(f, &vmstate_virtio, vdev, 1);
+     */
     return vmstate_save_state(f, &vmstate_virtio, vdev, NULL);
 }
 
@@ -3067,6 +3088,10 @@ int virtio_save(VirtIODevice *vdev, QEMUFile *f)
 static int virtio_device_put(QEMUFile *f, void *opaque, size_t size,
                               const VMStateField *field, JSONWriter *vmdesc)
 {
+    /*
+     * 只在以下调用virtio_save():
+     *   - hw/virtio/virtio.c|3087| <<virtio_device_put>> return virtio_save(VIRTIO_DEVICE(opaque), f);
+     */
     return virtio_save(VIRTIO_DEVICE(opaque), f);
 }
 
@@ -3309,6 +3334,12 @@ virtio_load(VirtIODevice *vdev, QEMUFile *f, int version_id)
     }
 
     /* Subsections */
+    /*
+     * 在以下使用vmstate_virtio:
+     *   - hw/virtio/virtio.c|2991| <<global>> static const VMStateDescription vmstate_virtio = {
+     *   - hw/virtio/virtio.c|3068| <<virtio_save>> return vmstate_save_state(f, &vmstate_virtio, vdev, NULL);
+     *   - hw/virtio/virtio.c|3317| <<virtio_load>> ret = vmstate_load_state(f, &vmstate_virtio, vdev, 1);
+     */
     ret = vmstate_load_state(f, &vmstate_virtio, vdev, 1);
     if (ret) {
         return ret;
@@ -3780,6 +3811,11 @@ static void virtio_queue_host_notifier_aio_poll_ready(EventNotifier *n)
 {
     VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
 
+    /*
+     * 在以下使用virtio_queue_notify_vq():
+     *   - hw/virtio/virtio.c|3783| <<virtio_queue_host_notifier_aio_poll_ready>> virtio_queue_notify_vq(vq);
+     *   - hw/virtio/virtio.c|3869| <<virtio_queue_host_notifier_read>> virtio_queue_notify_vq(vq);
+     */
     virtio_queue_notify_vq(vq);
 }
 
@@ -3791,6 +3827,17 @@ static void virtio_queue_host_notifier_aio_poll_end(EventNotifier *n)
     virtio_queue_set_notification(vq, 1);
 }
 
+/*
+ * 在以下使用virtio_queue_aio_attach_host_notifier():
+ *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>>
+ *        virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+ *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>>
+ *        virtio_queue_aio_attach_host_notifier(vs->ctrl_vq, s->vq_aio_context[0]);
+ *   - hw/scsi/virtio-scsi-dataplane.c|210| <<virtio_scsi_dataplane_start>>
+ *        virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
+ *   - hw/scsi/virtio-scsi.c|1250| <<virtio_scsi_drained_end>>
+ *        virtio_queue_aio_attach_host_notifier(vq, ctx);
+ */
 void virtio_queue_aio_attach_host_notifier(VirtQueue *vq, AioContext *ctx)
 {
     /*
@@ -3804,6 +3851,18 @@ void virtio_queue_aio_attach_host_notifier(VirtQueue *vq, AioContext *ctx)
         virtio_queue_set_notification(vq, 1);
     }
 
+    /*
+     * 在以下使用virtio_queue_host_notifier_read():
+     *   - hw/block/virtio-blk.c|2065| <<virtio_blk_ioeventfd_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+     *   - hw/scsi/virtio-scsi-dataplane.c|149| <<virtio_scsi_dataplane_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+     *   - hw/virtio/virtio-bus.c|328| <<virtio_bus_cleanup_host_notifier>> virtio_queue_host_notifier_read(notifier);
+     *   - hw/virtio/virtio.c|3829| <<virtio_queue_aio_attach_host_notifier>> aio_set_event_notifier(ctx, &vq->host_notifier,
+     *        virtio_queue_host_notifier_read, virtio_queue_host_notifier_aio_poll, virtio_queue_host_notifier_aio_poll_ready);
+     *   - hw/virtio/virtio.c|3858| <<virtio_queue_aio_attach_host_notifier_no_poll>> aio_set_event_notifier(ctx,
+     *        &vq->host_notifier, virtio_queue_host_notifier_read, NULL, NULL);
+     *   - hw/virtio/virtio.c|4077| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier,
+     *        virtio_queue_host_notifier_read);
+     */
     aio_set_event_notifier(ctx, &vq->host_notifier,
                            virtio_queue_host_notifier_read,
                            virtio_queue_host_notifier_aio_poll,
@@ -3833,6 +3892,18 @@ void virtio_queue_aio_attach_host_notifier_no_poll(VirtQueue *vq, AioContext *ct
         virtio_queue_set_notification(vq, 1);
     }
 
+    /*
+     * 在以下使用virtio_queue_host_notifier_read():
+     *   - hw/block/virtio-blk.c|2065| <<virtio_blk_ioeventfd_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+     *   - hw/scsi/virtio-scsi-dataplane.c|149| <<virtio_scsi_dataplane_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+     *   - hw/virtio/virtio-bus.c|328| <<virtio_bus_cleanup_host_notifier>> virtio_queue_host_notifier_read(notifier);
+     *   - hw/virtio/virtio.c|3829| <<virtio_queue_aio_attach_host_notifier>> aio_set_event_notifier(ctx, &vq->host_notifier,
+     *        virtio_queue_host_notifier_read, virtio_queue_host_notifier_aio_poll, virtio_queue_host_notifier_aio_poll_ready);
+     *   - hw/virtio/virtio.c|3858| <<virtio_queue_aio_attach_host_notifier_no_poll>> aio_set_event_notifier(ctx,
+     *        &vq->host_notifier, virtio_queue_host_notifier_read, NULL, NULL);
+     *   - hw/virtio/virtio.c|4077| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier,
+     *        virtio_queue_host_notifier_read);
+     */
     aio_set_event_notifier(ctx, &vq->host_notifier,
                            virtio_queue_host_notifier_read,
                            NULL, NULL);
@@ -3862,10 +3933,27 @@ void virtio_queue_aio_detach_host_notifier(VirtQueue *vq, AioContext *ctx)
      */
 }
 
+/*
+ * 在以下使用virtio_queue_host_notifier_read():
+ *   - hw/block/virtio-blk.c|2065| <<virtio_blk_ioeventfd_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+ *   - hw/scsi/virtio-scsi-dataplane.c|149| <<virtio_scsi_dataplane_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+ *   - hw/virtio/virtio-bus.c|328| <<virtio_bus_cleanup_host_notifier>> virtio_queue_host_notifier_read(notifier);
+ *   - hw/virtio/virtio.c|3829| <<virtio_queue_aio_attach_host_notifier>> aio_set_event_notifier(ctx, &vq->host_notifier,
+ *        virtio_queue_host_notifier_read, virtio_queue_host_notifier_aio_poll, virtio_queue_host_notifier_aio_poll_ready);
+ *   - hw/virtio/virtio.c|3858| <<virtio_queue_aio_attach_host_notifier_no_poll>> aio_set_event_notifier(ctx,
+ *        &vq->host_notifier, virtio_queue_host_notifier_read, NULL, NULL);
+ *   - hw/virtio/virtio.c|4077| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier,
+ *        virtio_queue_host_notifier_read);
+ */
 void virtio_queue_host_notifier_read(EventNotifier *n)
 {
     VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
     if (event_notifier_test_and_clear(n)) {
+        /*
+	 * 在以下使用virtio_queue_notify_vq():
+	 *   - hw/virtio/virtio.c|3783| <<virtio_queue_host_notifier_aio_poll_ready>> virtio_queue_notify_vq(vq);
+	 *   - hw/virtio/virtio.c|3869| <<virtio_queue_host_notifier_read>> virtio_queue_notify_vq(vq);
+	 */
         virtio_queue_notify_vq(vq);
     }
 }
@@ -4020,6 +4108,13 @@ static const Property virtio_properties[] = {
                      disable_legacy_check, false),
 };
 
+/*
+ * 在以下使用VirtioDeviceClass->start_ioeventfd:
+ *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+ *   - hw/scsi/virtio-scsi.c|1421| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+ *   - hw/virtio/virtio.c|4153| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+ */
 static int virtio_device_start_ioeventfd_impl(VirtIODevice *vdev)
 {
     VirtioBusState *qbus = VIRTIO_BUS(qdev_get_parent_bus(DEVICE(vdev)));
@@ -4040,6 +4135,18 @@ static int virtio_device_start_ioeventfd_impl(VirtIODevice *vdev)
             err = r;
             goto assign_error;
         }
+        /*
+	 * 在以下使用virtio_queue_host_notifier_read():
+         *   - hw/block/virtio-blk.c|2065| <<virtio_blk_ioeventfd_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+         *   - hw/scsi/virtio-scsi-dataplane.c|149| <<virtio_scsi_dataplane_stop_vq_bh>> virtio_queue_host_notifier_read(host_notifier);
+         *   - hw/virtio/virtio-bus.c|328| <<virtio_bus_cleanup_host_notifier>> virtio_queue_host_notifier_read(notifier);
+         *   - hw/virtio/virtio.c|3829| <<virtio_queue_aio_attach_host_notifier>> aio_set_event_notifier(ctx, &vq->host_notifier,
+         *        virtio_queue_host_notifier_read, virtio_queue_host_notifier_aio_poll, virtio_queue_host_notifier_aio_poll_ready);
+	 *   - hw/virtio/virtio.c|3858| <<virtio_queue_aio_attach_host_notifier_no_poll>> aio_set_event_notifier(ctx,
+	 *        &vq->host_notifier, virtio_queue_host_notifier_read, NULL, NULL);
+	 *   - hw/virtio/virtio.c|4077| <<virtio_device_start_ioeventfd_impl>> event_notifier_set_handler(&vq->host_notifier,
+	 *        virtio_queue_host_notifier_read);
+	 */
         event_notifier_set_handler(&vq->host_notifier,
                                    virtio_queue_host_notifier_read);
     }
diff --git a/include/exec/ram_addr.h b/include/exec/ram_addr.h
index e4c28fbec..b3f09b3fc 100644
--- a/include/exec/ram_addr.h
+++ b/include/exec/ram_addr.h
@@ -479,6 +479,10 @@ static inline void cpu_physical_memory_clear_dirty_range(ram_addr_t start,
 }
 
 
+/*
+ * 在以下调用cpu_physical_memory_sync_dirty_bitmap():
+ *   - migration/ram.c|893| <<ramblock_sync_dirty_bitmap>> cpu_physical_memory_sync_dirty_bitmap(rb, 0, rb->used_length);
+ */
 /* Called with RCU critical section */
 static inline
 uint64_t cpu_physical_memory_sync_dirty_bitmap(RAMBlock *rb,
diff --git a/include/exec/ramblock.h b/include/exec/ramblock.h
index 64484cd82..ba1b02e66 100644
--- a/include/exec/ramblock.h
+++ b/include/exec/ramblock.h
@@ -31,6 +31,11 @@ struct RAMBlock {
     uint8_t *colo_cache; /* For colo, VM's ram cache */
     ram_addr_t offset;
     ram_addr_t used_length;
+    /*
+     * 在以下设置RAMBlock->max_length:
+     *   - system/physmem.c|2111| <<qemu_ram_alloc_from_fd>> new_block->max_length = max_size;
+     *   - system/physmem.c|2284| <<qemu_ram_alloc_internal>> new_block->max_length = max_size;
+     */
     ram_addr_t max_length;
     void (*resized)(const char*, uint64_t length, void *host);
     uint32_t flags;
@@ -44,6 +49,34 @@ struct RAMBlock {
     uint64_t fd_offset;
     int guest_memfd;
     size_t page_size;
+    /*
+     * 在以下使用RAMBlock->bmap:
+     *   - include/exec/ram_addr.h|491| <<cpu_physical_memory_sync_dirty_bitmap>> unsigned long *dest = rb->bmap;
+     *   - migration/ram.c|690| <<pss_find_next_dirty>> unsigned long *bitmap = rb->bmap;
+     *   - migration/ram.c|771| <<colo_bitmap_find_dirty>> unsigned long *bitmap = rb->bmap;
+     *   - migration/ram.c|806| <<migration_bitmap_clear_dirty>> ret = test_and_clear_bit(page, rb->bmap);
+     *   - migration/ram.c|832| <<dirty_bitmap_clear_section>> *cleared_bits += bitmap_count_one_with_offset(rb->bmap, start, npages);
+     *   - migration/ram.c|833| <<dirty_bitmap_clear_section>> bitmap_clear(rb->bmap, start, npages);
+     *   - migration/ram.c|853| <<ramblock_dirty_bitmap_clear_discarded_pages>> if (rb->mr && rb->bmap && memory_region_has_ram_discard_manager(rb->mr)) {
+     *   - migration/ram.c|1778| <<get_queued_page>> dirty = test_bit(page, block->bmap);
+     *   - migration/ram.c|2309| <<ram_bitmaps_destroy>> g_free(block->bmap);
+     *   - migration/ram.c|2310| <<ram_bitmaps_destroy>> block->bmap = NULL;
+     *   - migration/ram.c|2365| <<ram_postcopy_migrated_memory_release>> unsigned long *bitmap = block->bmap;
+     *   - migration/ram.c|2392| <<postcopy_send_discard_bm_ram>> unsigned long *bitmap = block->bmap;
+     *   - migration/ram.c|2468| <<postcopy_chunk_hostpages_pass>> unsigned long *bitmap = block->bmap;
+     *   - migration/ram.c|2695| <<ram_list_init_bitmaps>> block->bmap = bitmap_new(pages);
+     *   - migration/ram.c|2696| <<ram_list_init_bitmaps>> bitmap_set(block->bmap, 0, pages);
+     *   - migration/ram.c|2782| <<ram_state_resume_prepare>> pages += bitmap_count_one(block->bmap,
+     *   - migration/ram.c|2844| <<qemu_guest_free_page_hint>> bitmap_count_one_with_offset(block->bmap, start, npages);
+     *   - migration/ram.c|2845| <<qemu_guest_free_page_hint>> bitmap_clear(block->bmap, start, npages);
+     *   - migration/ram.c|3428| <<colo_record_bitmap>> block->bmap);
+     *   - migration/ram.c|3522| <<colo_init_ram_cache>> block->bmap = bitmap_new(pages);
+     *   - migration/ram.c|3545| <<colo_incoming_start_dirty_log>> bitmap_zero(block->bmap, block->max_length >> TARGET_PAGE_BITS);
+     *   - migration/ram.c|3564| <<colo_release_ram_cache>> g_free(block->bmap);
+     *   - migration/ram.c|3565| <<colo_release_ram_cache>> block->bmap = NULL;
+     *   - migration/ram.c|4392| <<ram_dirty_bitmap_reload>> bitmap_from_le(block->bmap, le_bitmap, nbits);
+     *   - migration/ram.c|4398| <<ram_dirty_bitmap_reload>> bitmap_complement(block->bmap, block->bmap, nbits);
+     */
     /* dirty bitmap used during migration */
     unsigned long *bmap;
 
diff --git a/include/exec/ramlist.h b/include/exec/ramlist.h
index d9cfe530b..89010b28a 100644
--- a/include/exec/ramlist.h
+++ b/include/exec/ramlist.h
@@ -54,11 +54,70 @@ typedef struct RAMList {
     uint32_t version;
     QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;
 } RAMList;
+/*
+ * 在以下使用ram_list:
+ *   - system/physmem.c|96| <<global>> RAMList ram_list = { .blocks = QLIST_HEAD_INITIALIZER(ram_list.blocks) };
+ *   - system/physmem.c|956| <<global>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - hw/core/numa.c|846| <<ram_block_notifier_add>> QLIST_INSERT_HEAD(&ram_list.ramblock_notifiers, n, next);
+ *   - hw/core/numa.c|868| <<ram_block_notify_add>> QLIST_FOREACH_SAFE(notifier, &ram_list.ramblock_notifiers, next, next) {
+ *   - hw/core/numa.c|880| <<ram_block_notify_remove>> QLIST_FOREACH_SAFE(notifier, &ram_list.ramblock_notifiers, next, next) {
+ *   - hw/core/numa.c|892| <<ram_block_notify_resize>> QLIST_FOREACH_SAFE(notifier, &ram_list.ramblock_notifiers, next, next) {
+ *   - include/exec/ram_addr.h|175| <<cpu_physical_memory_get_dirty>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - include/exec/ram_addr.h|216| <<cpu_physical_memory_all_dirty>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - include/exec/ram_addr.h|289| <<cpu_physical_memory_set_dirty_flag>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - include/exec/ram_addr.h|312| <<cpu_physical_memory_set_dirty_range>> blocks[i] = qatomic_rcu_read(&ram_list.dirty_memory[i]);
+ *   - include/exec/ram_addr.h|382| <<cpu_physical_memory_set_dirty_lebitmap>> qatomic_rcu_read(&ram_list.dirty_memory[i])->blocks;
+ *   - include/exec/ram_addr.h|506| <<cpu_physical_memory_sync_dirty_bitmap>> &ram_list.dirty_memory[DIRTY_MEMORY_MIGRATION])->blocks;
+ *   - include/exec/ramlist.h|61| <<INTERNAL_RAMBLOCK_FOREACH>> QLIST_FOREACH_RCU(block, &ram_list.blocks, next)
+ *   - migration/ram.c|1309| <<find_dirty_block>> pss->block = QLIST_FIRST_RCU(&ram_list.blocks);
+ *   - migration/ram.c|2205| <<ram_find_and_save_block>> rs->last_seen_block = QLIST_FIRST_RCU(&ram_list.blocks);
+ *   - migration/ram.c|2352| <<ram_state_reset>> rs->last_version = ram_list.version;
+ *   - migration/ram.c|3107| <<ram_save_iterate>> if (ram_list.version != rs->last_version) {
+ *   - migration/ram.c|3822| <<colo_flush_ram_cache>> block = QLIST_FIRST_RCU(&ram_list.blocks);
+ *   - system/physmem.c|826| <<qemu_get_ram_block>> block = qatomic_rcu_read(&ram_list.mru_block);
+ *   - system/physmem.c|856| <<qemu_get_ram_block>> ram_list.mru_block = block;
+ *   - system/physmem.c|900| <<cpu_physical_memory_test_and_clear_dirty>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - system/physmem.c|1155| <<qemu_mutex_lock_ramlist>> qemu_mutex_lock(&ram_list.mutex);
+ *   - system/physmem.c|1160| <<qemu_mutex_unlock_ramlist>> qemu_mutex_unlock(&ram_list.mutex);
+ *   - system/physmem.c|1499| <<find_ram_offset>> if (QLIST_EMPTY_RCU(&ram_list.blocks)) {
+ *   - system/physmem.c|1889| <<dirty_memory_extend>> unsigned int old_num_blocks = ram_list.num_dirty_blocks;
+ *   - system/physmem.c|1904| <<dirty_memory_extend>> old_blocks = qatomic_rcu_read(&ram_list.dirty_memory[i]);
+ *   - system/physmem.c|1917| <<dirty_memory_extend>> qatomic_rcu_set(&ram_list.dirty_memory[i], new_blocks);
+ *   - system/physmem.c|1924| <<dirty_memory_extend>> ram_list.num_dirty_blocks = new_num_blocks;
+ *   - system/physmem.c|2021| <<ram_block_add>> QLIST_INSERT_HEAD_RCU(&ram_list.blocks, new_block, next);
+ *   - system/physmem.c|2023| <<ram_block_add>> ram_list.mru_block = NULL;
+ *   - system/physmem.c|2027| <<ram_block_add>> ram_list.version++;
+ *   - system/physmem.c|2379| <<qemu_ram_free>> ram_list.mru_block = NULL;
+ *   - system/physmem.c|2382| <<qemu_ram_free>> ram_list.version++;
+ *   - system/physmem.c|2566| <<qemu_ram_block_from_host>> block = qatomic_rcu_read(&ram_list.mru_block);
+ *   - system/physmem.c|3381| <<cpu_exec_init_all>> qemu_mutex_init(&ram_list.mutex);
+ */
 extern RAMList ram_list;
 
+/*
+ * 在以下使用INTERNAL_RAMBLOCK_FOREACH():
+ *   - include/exec/ramlist.h|63| <<RAMBLOCK_FOREACH>> #define RAMBLOCK_FOREACH(block) INTERNAL_RAMBLOCK_FOREACH(block)
+ *   - migration/ram.h|68| <<RAMBLOCK_FOREACH_NOT_IGNORED>> INTERNAL_RAMBLOCK_FOREACH(block) \
+ *   - migration/ram.h|72| <<RAMBLOCK_FOREACH_MIGRATABLE>> INTERNAL_RAMBLOCK_FOREACH(block) \
+ */
 /* Should be holding either ram_list.mutex, or the RCU lock. */
 #define  INTERNAL_RAMBLOCK_FOREACH(block)  \
     QLIST_FOREACH_RCU(block, &ram_list.blocks, next)
+/*
+ * 在以下使用RAMBLOCK_FOREACH():
+ *   - migration/postcopy-ram.c|418| <<postcopy_ram_supported_by_host>> RAMBLOCK_FOREACH(block) {
+ *   - system/physmem.c|830| <<qemu_get_ram_block>> RAMBLOCK_FOREACH(block) {
+ *   - system/physmem.c|1174| <<ram_block_format>> RAMBLOCK_FOREACH(block) {
+ *   - system/physmem.c|1503| <<find_ram_offset>> RAMBLOCK_FOREACH(block) {
+ *   - system/physmem.c|1515| <<find_ram_offset>> RAMBLOCK_FOREACH(next_block) {
+ *   - system/physmem.c|1648| <<qemu_ram_set_idstr>> RAMBLOCK_FOREACH(block) {
+ *   - system/physmem.c|1693| <<qemu_ram_pagesize_largest>> RAMBLOCK_FOREACH(block) {
+ *   - system/physmem.c|2010| <<ram_block_add>> RAMBLOCK_FOREACH(block) {
+ *   - system/physmem.c|2425| <<qemu_ram_remap>> RAMBLOCK_FOREACH(block) {
+ *   - system/physmem.c|2571| <<qemu_ram_block_from_host>> RAMBLOCK_FOREACH(block) {
+ *   - system/physmem.c|2602| <<qemu_ram_block_by_name>> RAMBLOCK_FOREACH(block) {
+ *   - system/physmem.c|3859| <<qemu_ram_foreach_block>> RAMBLOCK_FOREACH(block) {
+ */
 /* Never use the INTERNAL_ version except for defining other macros */
 #define RAMBLOCK_FOREACH(block) INTERNAL_RAMBLOCK_FOREACH(block)
 
diff --git a/include/hw/acpi/aml-build.h b/include/hw/acpi/aml-build.h
index c18f68134..3197ca859 100644
--- a/include/hw/acpi/aml-build.h
+++ b/include/hw/acpi/aml-build.h
@@ -10,6 +10,24 @@
 #define ACPI_BUILD_TABLE_FILE "etc/acpi/tables"
 #define ACPI_BUILD_RSDP_FILE "etc/acpi/rsdp"
 #define ACPI_BUILD_TPMLOG_FILE "etc/tpm/log"
+/*
+ * 在以下使用ACPI_BUILD_LOADER_FILE:
+ *   - include/hw/acpi/aml-build.h|13| <<global>> #define ACPI_BUILD_LOADER_FILE "etc/table-loader"
+ *   - hw/acpi/utils.c|37| <<acpi_add_rom_blob>> } else if (!strcmp(name, ACPI_BUILD_LOADER_FILE)) {
+ *   - hw/arm/virt-acpi-build.c|1145| <<virt_acpi_setup>> build_state->linker_mr =
+ *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+ *   - hw/i386/acpi-build.c|2774| <<acpi_setup>> build_state->linker_mr =
+ *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+ *   - hw/i386/acpi-microvm.c|263| <<acpi_setup_microvm>> acpi_add_rom_blob(acpi_build_no_update, NULL,
+ *       tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+ *   - hw/loongarch/virt-acpi-build.c|724| <<virt_acpi_setup>> build_state->linker_mr =
+ *       acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+ *   - hw/nvram/fw_cfg.c|654| <<fw_cfg_acpi_mr_restore_post_load>>
+ *       } else if (!strcmp(s->files->f[i].name, ACPI_BUILD_LOADER_FILE)) {
+ *   - hw/nvram/fw_cfg.c|894| <<fw_cfg_acpi_mr_save>> } else if (!strcmp(filename, ACPI_BUILD_LOADER_FILE)) {
+ *   - hw/riscv/virt-acpi-build.c|810| <<virt_acpi_setup>> build_state->linker_mr =
+ *       acpi_add_rom_blob(virt_acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+ */
 #define ACPI_BUILD_LOADER_FILE "etc/table-loader"
 
 #define AML_NOTIFY_METHOD "NTFY"
diff --git a/include/hw/acpi/ich9.h b/include/hw/acpi/ich9.h
index 245fe08dc..990cb6ec5 100644
--- a/include/hw/acpi/ich9.h
+++ b/include/hw/acpi/ich9.h
@@ -59,6 +59,26 @@ typedef struct ICH9LPCPMRegs {
 
     bool keep_pci_slot_hpc;
     bool use_acpi_hotplug_bridge;
+    /*
+     * 在以下使用ICH9LPCPMRegs->acpi_pci_hotplug:
+     *   - hw/acpi/ich9.c|236| <<global>> VMSTATE_PCI_HOTPLUG(acpi_pci_hotplug,
+     *   - hw/acpi/ich9.c|227| <<vmstate_test_use_pcihp>> return s->acpi_pci_hotplug.use_acpi_hotplug_bridge;
+     *   - hw/acpi/ich9.c|286| <<pm_reset>> if (pm->acpi_pci_hotplug.use_acpi_hotplug_bridge) {
+     *   - hw/acpi/ich9.c|287| <<pm_reset>> acpi_pcihp_reset(&pm->acpi_pci_hotplug);
+     *   - hw/acpi/ich9.c|335| <<ich9_pm_init>> if (pm->acpi_pci_hotplug.use_acpi_hotplug_bridge) {
+     *   - hw/acpi/ich9.c|227| <<vmstate_test_use_pcihp>> return s->acpi_pci_hotplug.use_acpi_hotplug_bridge;
+     *   - hw/acpi/ich9.c|286| <<pm_reset>> if (pm->acpi_pci_hotplug.use_acpi_hotplug_bridge) {
+     *   - hw/acpi/ich9.c|287| <<pm_reset>> acpi_pcihp_reset(&pm->acpi_pci_hotplug);
+     *   - hw/acpi/ich9.c|335| <<ich9_pm_init>> if (pm->acpi_pci_hotplug.use_acpi_hotplug_bridge) {
+     *   - hw/acpi/ich9.c|337| <<ich9_pm_init>> &pm->acpi_pci_hotplug,
+     *   - hw/acpi/ich9.c|404| <<ich9_pm_get_acpi_pci_hotplug>> return s->pm.acpi_pci_hotplug.use_acpi_hotplug_bridge;
+     *   - hw/acpi/ich9.c|411| <<ich9_pm_set_acpi_pci_hotplug>> s->pm.acpi_pci_hotplug.use_acpi_hotplug_bridge = value;
+     *   - hw/acpi/ich9.c|436| <<ich9_pm_add_properties>> pm->acpi_pci_hotplug.use_acpi_hotplug_bridge = true;
+     *   - hw/acpi/ich9.c|508| <<ich9_pm_device_plug_cb>> acpi_pcihp_device_plug_cb(hotplug_dev, &lpc->pm.acpi_pci_hotplug,
+     *   - hw/acpi/ich9.c|543| <<ich9_pm_device_unplug_request_cb>> &lpc->pm.acpi_pci_hotplug,
+     *   - hw/acpi/ich9.c|562| <<ich9_pm_device_unplug_cb>> acpi_pcihp_device_unplug_cb(hotplug_dev, &lpc->pm.acpi_pci_hotplug,
+     *   - hw/acpi/ich9.c|573| <<ich9_pm_is_hotpluggable_bus>> return acpi_pcihp_is_hotpluggbale_bus(&lpc->pm.acpi_pci_hotplug, bus);
+     */
     AcpiPciHpState acpi_pci_hotplug;
     MemHotplugState acpi_memory_hotplug;
 
diff --git a/include/hw/acpi/pcihp.h b/include/hw/acpi/pcihp.h
index ac21a9591..0ffccc1eb 100644
--- a/include/hw/acpi/pcihp.h
+++ b/include/hw/acpi/pcihp.h
@@ -44,6 +44,23 @@ typedef struct AcpiPciHpPciStatus {
 #define ACPI_PCIHP_BSEL_DEFAULT 0x0
 
 typedef struct AcpiPciHpState {
+    /*
+     * 在以下使用AcpiPciHpState->acpi_pcihp_pci_status[ACPI_PCIHP_MAX_HOTPLUG_BUS]:
+     *   - hw/acpi/piix4.c|262| <<global>> acpi_pci_hotplug.acpi_pcihp_pci_status[ACPI_PCIHP_BSEL_DEFAULT],
+     *   - hw/acpi/pcihp.c|196| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].down &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|197| <<acpi_pcihp_eject_slot>> s->acpi_pcihp_pci_status[bsel].up &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|236| <<acpi_pcihp_update_hotplug_bus>> while (s->acpi_pcihp_pci_status[bsel].down) {
+     *   - hw/acpi/pcihp.c|237| <<acpi_pcihp_update_hotplug_bus>> acpi_pcihp_eject_slot(s, bsel, s->acpi_pcihp_pci_status[bsel].down);
+     *   - hw/acpi/pcihp.c|240| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable = ~0;
+     *   - hw/acpi/pcihp.c|251| <<acpi_pcihp_update_hotplug_bus>> s->acpi_pcihp_pci_status[bsel].hotplug_enable &= ~(1U << slot);
+     *   - hw/acpi/pcihp.c|323| <<acpi_pcihp_device_plug_cb>> s->acpi_pcihp_pci_status[bsel].up |= (1U << slot);
+     *   - hw/acpi/pcihp.c|370| <<acpi_pcihp_device_unplug_request_cb>> s->acpi_pcihp_pci_status[bsel].down |= (1U << slot);
+     *   - hw/acpi/pcihp.c|404| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].up;
+     *   - hw/acpi/pcihp.c|406| <<pci_read>> s->acpi_pcihp_pci_status[bsel].up = 0;
+     *   - hw/acpi/pcihp.c|411| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].down;
+     *   - hw/acpi/pcihp.c|418| <<pci_read>> val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;
+     *   - include/hw/acpi/pcihp.h|82| <<VMSTATE_PCI_HOTPLUG>> VMSTATE_STRUCT_ARRAY_TEST(pcihp.acpi_pcihp_pci_status, state, \
+     */
     AcpiPciHpPciStatus acpi_pcihp_pci_status[ACPI_PCIHP_MAX_HOTPLUG_BUS];
     uint32_t hotplug_select;
     uint32_t acpi_index;
@@ -76,6 +93,13 @@ void build_append_pcihp_slots(Aml *parent_scope, PCIBus *bus);
 
 extern const VMStateDescription vmstate_acpi_pcihp_pci_status;
 
+/*
+ * 在以下使用VMSTATE_PCI_HOTPLUG():
+ *   - hw/acpi/ich9.c|236| <<global>> VMSTATE_PCI_HOTPLUG(acpi_pci_hotplug,
+ *   - hw/acpi/piix4.c|267| <<global>> VMSTATE_PCI_HOTPLUG(acpi_pci_hotplug, PIIX4PMState,
+ *
+ * 关于迁移的
+ */
 #define VMSTATE_PCI_HOTPLUG(pcihp, state, test_pcihp, test_acpi_index) \
         VMSTATE_UINT32_TEST(pcihp.hotplug_select, state, \
                             test_pcihp), \
diff --git a/include/hw/char/serial.h b/include/hw/char/serial.h
index 942b372df..bd321cedc 100644
--- a/include/hw/char/serial.h
+++ b/include/hw/char/serial.h
@@ -63,7 +63,41 @@ struct SerialState {
 
     /* Time when the last byte was successfully sent out of the tsr */
     uint64_t last_xmit_ts;
+    /*
+     * 在以下使用SerialState->recv_fifo:
+     *   - hw/char/serial.c|748| <<global>> VMSTATE_STRUCT(recv_fifo, SerialState, 1, vmstate_fifo8, Fifo8),
+     *   - hw/char/serial.c|111| <<recv_fifo_put>> if (!fifo8_is_full(&s->recv_fifo)) {
+     *   - hw/char/serial.c|112| <<recv_fifo_put>> fifo8_push(&s->recv_fifo, chr);
+     *   - hw/char/serial.c|131| <<serial_update_irq>> s->recv_fifo.num >= s->recv_fifo_itl)) {
+     *   - hw/char/serial.c|419| <<serial_ioport_write>> fifo8_reset(&s->recv_fifo);
+     *   - hw/char/serial.c|482| <<serial_ioport_read>> ret = fifo8_is_empty(&s->recv_fifo) ?
+     *   - hw/char/serial.c|483| <<serial_ioport_read>> 0 : fifo8_pop(&s->recv_fifo);
+     *   - hw/char/serial.c|484| <<serial_ioport_read>> if (s->recv_fifo.num == 0) {
+     *   - hw/char/serial.c|558| <<serial_can_receive>> if (s->recv_fifo.num < UART_FIFO_LENGTH) {
+     *   - hw/char/serial.c|566| <<serial_can_receive>> return (s->recv_fifo.num <= s->recv_fifo_itl) ?
+     *   - hw/char/serial.c|567| <<serial_can_receive>> s->recv_fifo_itl - s->recv_fifo.num : 1;
+     *   - hw/char/serial.c|588| <<fifo_timeout_int>> if (s->recv_fifo.num) {
+     *   - hw/char/serial.c|738| <<serial_recv_fifo_needed>> return !fifo8_is_empty(&s->recv_fifo);
+     *   - hw/char/serial.c|881| <<serial_reset>> fifo8_reset(&s->recv_fifo);
+     *   - hw/char/serial.c|933| <<serial_realize>> fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);
+     *   - hw/char/serial.c|948| <<serial_unrealize>> fifo8_destroy(&s->recv_fifo);
+     */
     Fifo8 recv_fifo;
+    /*
+     * 在以下使用SerialState->xmit_fifo:
+     *   - hw/char/serial.c|765| <<global>> VMSTATE_STRUCT(xmit_fifo, SerialState, 1, vmstate_fifo8, Fifo8),
+     *   - hw/char/serial.c|240| <<serial_xmit>> assert(!fifo8_is_empty(&s->xmit_fifo));
+     *   - hw/char/serial.c|241| <<serial_xmit>> s->tsr = fifo8_pop(&s->xmit_fifo);
+     *   - hw/char/serial.c|242| <<serial_xmit>> if (!s->xmit_fifo.num) {
+     *   - hw/char/serial.c|349| <<serial_ioport_write>> if (fifo8_is_full(&s->xmit_fifo)) {
+     *   - hw/char/serial.c|350| <<serial_ioport_write>> fifo8_pop(&s->xmit_fifo);
+     *   - hw/char/serial.c|352| <<serial_ioport_write>> fifo8_push(&s->xmit_fifo, s->thr);
+     *   - hw/char/serial.c|425| <<serial_ioport_write>> fifo8_reset(&s->xmit_fifo);
+     *   - hw/char/serial.c|756| <<serial_xmit_fifo_needed>> return !fifo8_is_empty(&s->xmit_fifo);
+     *   - hw/char/serial.c|882| <<serial_reset>> fifo8_reset(&s->xmit_fifo);
+     *   - hw/char/serial.c|934| <<serial_realize>> fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);
+     *   - hw/char/serial.c|949| <<serial_unrealize>> fifo8_destroy(&s->xmit_fifo);
+     */
     Fifo8 xmit_fifo;
     /* Interrupt trigger level for recv_fifo */
     uint8_t recv_fifo_itl;
diff --git a/include/hw/core/cpu.h b/include/hw/core/cpu.h
index abd8764e8..bfaf50ec1 100644
--- a/include/hw/core/cpu.h
+++ b/include/hw/core/cpu.h
@@ -532,6 +532,25 @@ struct CPUState {
     uint32_t kvm_fetch_index;
     uint64_t dirty_pages;
     int kvm_vcpu_stats_fd;
+    /*
+     * 在以下使用CPUState->vcpu_dirty:
+     *   - accel/kvm/kvm-all.c|480| <<kvm_create_vcpu>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3128| <<do_kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3142| <<do_kvm_cpu_synchronize_state>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3174| <<kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3194| <<do_kvm_cpu_synchronize_post_reset>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3216| <<do_kvm_cpu_synchronize_post_init>> cpu->vcpu_dirty = false;
+     *   - accel/kvm/kvm-all.c|3232| <<do_kvm_cpu_synchronize_pre_loadvm>> cpu->vcpu_dirty = true;
+     *   - accel/kvm/kvm-all.c|3405| <<kvm_cpu_exec>> if (cpu->vcpu_dirty) {
+     *   - accel/kvm/kvm-all.c|3419| <<kvm_cpu_exec>> cpu->vcpu_dirty = false;
+     *   - target/mips/kvm.c|563| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *   - target/mips/kvm.c|579| <<kvm_mips_update_state>> if (!cs->vcpu_dirty) {
+     *
+     * cpu->vcpu_dirty说明有东西要从QEMU更新到KVM
+     * 比如要调用kvm_arch_put_registers()
+     * !cpu->vcpu_dirty说明"也许"有东西要从KVM更新到QEMU
+     * 比如要调用kvm_arch_get_registers()
+     */
     bool vcpu_dirty;
 
     /* Use by accel-block: CPU is executing an ioctl() */
diff --git a/include/hw/i386/apic_internal.h b/include/hw/i386/apic_internal.h
index d6e85833d..02ba115b2 100644
--- a/include/hw/i386/apic_internal.h
+++ b/include/hw/i386/apic_internal.h
@@ -159,6 +159,41 @@ struct APICCommonState {
 
     MemoryRegion io_memory;
     X86CPU *cpu;
+    /*
+     * 在以下设置APICCommonState->apicbase:
+     *   - hw/intc/apic_common.c|411| <<global>> VMSTATE_UINT32(apicbase, APICCommonState),
+     *   - hw/i386/kvm/apic.c|185| <<kvm_apic_set_base>> s->apicbase = val;
+     *   - hw/intc/apic.c|353| <<apic_set_base>> s->apicbase = (val & MSR_IA32_APICBASE_BASE) |
+     *   - hw/intc/apic.c|364| <<apic_set_base>> s->apicbase |= MSR_IA32_APICBASE_ENABLE;
+     *   - hw/intc/apic.c|372| <<apic_set_base>> s->apicbase |= MSR_IA32_APICBASE_EXTD;
+     *   - hw/intc/apic_common.c|263| <<apic_designate_bsp>> s->apicbase |= MSR_IA32_APICBASE_BSP;
+     *   - hw/intc/apic_common.c|265| <<apic_designate_bsp>> s->apicbase &= ~MSR_IA32_APICBASE_BSP;
+     *   - hw/intc/apic_common.c|276| <<apic_reset_common>> s->apicbase = APIC_DEFAULT_ADDRESS | bsp | MSR_IA32_APICBASE_ENABLE;
+     *   - target/i386/cpu-apic.c|59| <<x86_cpu_apic_create>> apic->apicbase = APIC_DEFAULT_ADDRESS | MSR_IA32_APICBASE_ENABLE;
+     *   - target/i386/whpx/whpx-apic.c|95| <<whpx_apic_set_base>> s->apicbase = val;
+     * 在以下使用APICCommonState->apicbase:
+     *   - hw/i386/kvm/apic.c|91| <<kvm_put_apic_state>> if (kvm_has_x2apic_api() && s->apicbase & MSR_IA32_APICBASE_EXTD) {
+     *   - hw/i386/kvm/apic.c|142| <<kvm_get_apic_state>> if (kvm_has_x2apic_api() && s->apicbase & MSR_IA32_APICBASE_EXTD) {
+     *   - hw/i386/kvm/apic.c|238| <<kvm_apic_put>> kvm_put_apicbase(s->cpu, s->apicbase);
+     *   - hw/intc/apic.c|307| <<is_x2apic_mode>> return s->apicbase & MSR_IA32_APICBASE_EXTD; 
+     *   - hw/intc/apic.c|329| <<apic_set_base_check>> if (!(s->apicbase & MSR_IA32_APICBASE_ENABLE) &&
+     *   - hw/intc/apic.c|330| <<apic_set_base_check>> if ... !(s->apicbase & MSR_IA32_APICBASE_EXTD) &&
+     *   - hw/intc/apic.c|337| <<apic_set_base_check>> if ((s->apicbase & MSR_IA32_APICBASE_ENABLE) &&
+     *   - hw/intc/apic.c|338| <<apic_set_base_check>> if ... (s->apicbase & MSR_IA32_APICBASE_EXTD) &&
+     *   - hw/intc/apic.c|354| <<apic_set_base>> (s->apicbase & (MSR_IA32_APICBASE_BSP | MSR_IA32_APICBASE_ENABLE));
+     *   - hw/intc/apic.c|362| <<apic_set_base>> if (!(s->apicbase & MSR_IA32_APICBASE_ENABLE) &&
+     *   - hw/intc/apic.c|370| <<apic_set_base>> if (cpu_has_x2apic_feature(&s->cpu->env) && !(s->apicbase & MSR_IA32_APICBASE_EXTD) &&
+     *   - hw/intc/apic.c|599| <<apic_get_delivery_bitmask>> if (apic->apicbase & MSR_IA32_APICBASE_EXTD) {
+     *   - hw/intc/apic.c|766| <<apic_accept_pic_intr>> if ((s->apicbase & MSR_IA32_APICBASE_ENABLE) == 0 ||
+     *   - hw/intc/apic_common.c|57| <<cpu_get_apic_base>> trace_cpu_get_apic_base((uint64_t)s->apicbase);
+     *   - hw/intc/apic_common.c|58| <<cpu_get_apic_base>> return s->apicbase;
+     *   - hw/intc/apic_common.c|80| <<cpu_is_apic_enabled>> return s->apicbase & MSR_IA32_APICBASE_ENABLE;
+     *   - hw/intc/apic_common.c|275| <<apic_reset_common>> bsp = s->apicbase & MSR_IA32_APICBASE_BSP;
+     *   - hw/intc/apic_common.c|453| <<apic_common_get_id>> value = s->apicbase & MSR_IA32_APICBASE_EXTD ? s->initial_apic_id : s->id;
+     *   - target/i386/cpu-apic.c|83| <<x86_cpu_apic_realize>> memory_region_add_subregion_overlap(get_system_memory(),
+     *            apic->apicbase & MSR_IA32_APICBASE_BASE, &apic->io_memory, 0x1000);
+     *   - target/i386/whpx/whpx-apic.c|137| <<whpx_apic_put>> whpx_put_apic_base(CPU(s->cpu), s->apicbase);
+     */
     uint32_t apicbase;
     uint8_t id; /* legacy APIC ID */
     uint32_t initial_apic_id;
diff --git a/include/hw/virtio/virtio-blk.h b/include/hw/virtio/virtio-blk.h
index 3d8dee7ec..5142b8757 100644
--- a/include/hw/virtio/virtio-blk.h
+++ b/include/hw/virtio/virtio-blk.h
@@ -38,8 +38,23 @@ struct VirtIOBlkConf
 {
     BlockConf conf;
     IOThread *iothread;
+    /*
+     * 在以下使用VirtIOBlkConf->iothread_vq_mapping_list:
+     *   - hw/block/virtio-blk.c|1919| <<global>> conf.iothread_vq_mapping_list),
+     *   - hw/block/virtio-blk.c|1481| <<virtio_blk_vq_aio_context_init>> if (conf->iothread && conf->iothread_vq_mapping_list) {
+     *   - hw/block/virtio-blk.c|1488| <<virtio_blk_vq_aio_context_init>> if (conf->iothread || conf->iothread_vq_mapping_list) {
+     *   - hw/block/virtio-blk.c|1503| <<virtio_blk_vq_aio_context_init>> if (conf->iothread_vq_mapping_list) {
+     *   - hw/block/virtio-blk.c|1504| <<virtio_blk_vq_aio_context_init>> if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+     *   - hw/block/virtio-blk.c|1537| <<virtio_blk_vq_aio_context_cleanup>> if (conf->iothread_vq_mapping_list) {
+     *   - hw/block/virtio-blk.c|1538| <<virtio_blk_vq_aio_context_cleanup>> iothread_vq_mapping_cleanup(conf->iothread_vq_mapping_list);
+     */
     IOThreadVirtQueueMappingList *iothread_vq_mapping_list;
     char *serial;
+    /*
+     * 在以下使用VirtIOBlkConf->request_merging:
+     *   - hw/block/virtio-blk.c|2054| <<global>> DEFINE_PROP_BIT("request-merging", VirtIOBlock, conf.request_merging, 0,
+     *   - hw/block/virtio-blk.c|1026| <<virtio_blk_handle_request>> if (...!s->conf.request_merging)) {
+     */
     uint32_t request_merging;
     uint16_t num_queues;
     uint16_t queue_size;
@@ -65,6 +80,23 @@ struct VirtIOBlock {
     bool ioeventfd_starting;
     bool ioeventfd_stopping;
 
+    /*
+     * 在以下使用VirtIOBlock->vq_aio_context (二维数组):
+     *   - hw/block/virtio-blk.c|1368| <<virtio_blk_dma_restart_cb>> aio_bh_schedule_oneshot(s->vq_aio_context[i], virtio_blk_dma_restart_bh, vq_rq[i]);
+     *   - hw/block/virtio-blk.c|1652| <<virtio_blk_ioeventfd_detach>> virtio_queue_aio_detach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>> virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1721| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = g_new(AioContext *, conf->num_queues);
+     *   - hw/block/virtio-blk.c|1725| <<virtio_blk_vq_aio_context_init>> if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+     *        s->vq_aio_context, conf->num_queues, errp)) {
+     *   - hw/block/virtio-blk.c|1728| <<virtio_blk_vq_aio_context_init>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1729| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = NULL; 
+     *   - hw/block/virtio-blk.c|1735| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx; 
+     *   - hw/block/virtio-blk.c|1743| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+     *   - hw/block/virtio-blk.c|1765| <<virtio_blk_vq_aio_context_cleanup>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1766| <<virtio_blk_vq_aio_context_cleanup>> s->vq_aio_context = NULL;
+     *   - hw/block/virtio-blk.c|1831| <<virtio_blk_start_ioeventfd>> r = blk_set_aio_context(s->conf.conf.blk, s->vq_aio_context[0], &local_err);
+     *   - hw/block/virtio-blk.c|1910| <<virtio_blk_stop_ioeventfd>> AioContext *ctx = s->vq_aio_context[i];
+     */
     /*
      * The AioContext for each virtqueue. The BlockDriverState will use the
      * first element as its AioContext.
@@ -81,13 +113,35 @@ typedef struct VirtIOBlockReq {
     int64_t sector_num;
     VirtIOBlock *dev;
     VirtQueue *vq;
+    /*
+     * 在以下使用VirtIOBlockReq->inhdr_undo:
+     *   - hw/block/virtio-blk.c|62| <<virtio_blk_req_complete>> iov_discard_undo(&req->inhdr_undo);
+     *   - hw/block/virtio-blk.c|867| <<virtio_blk_handle_request>> iov_discard_back_undoable(in_iov,
+     *                          &in_num, sizeof(struct virtio_blk_inhdr), &req->inhdr_undo);
+     *   - hw/block/virtio-blk.c|988| <<virtio_blk_handle_request>> iov_discard_undo(&req->inhdr_undo);
+     */
     IOVDiscardUndo inhdr_undo;
+    /*
+     * 在以下使用VirtIOBlockReq->outhdr_undo:
+     *   - hw/block/virtio-blk.c|112| <<virtio_blk_req_complete>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|964| <<virtio_blk_handle_request>> iov_discard_front_undoable(&out_iov,
+     *                           &out_num, sizeof(req->out), &req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|968| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|1100| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     */
     IOVDiscardUndo outhdr_undo;
     struct virtio_blk_inhdr *in;
     struct virtio_blk_outhdr out;
     QEMUIOVector qiov;
     size_t in_len;
     struct VirtIOBlockReq *next;
+    /*
+     * 在以下使用VirtIOBlockReq->mr_next:
+     *   - hw/block/virtio-blk.c|51| <<virtio_blk_init_request>> req->mr_next = NULL;
+     *   - hw/block/virtio-blk.c|81| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+     *   - hw/block/virtio-blk.c|112| <<virtio_blk_rw_complete>> next = req->mr_next;
+     *   - hw/block/virtio-blk.c|253| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+     */
     struct VirtIOBlockReq *mr_next;
     BlockAcctCookie acct;
 } VirtIOBlockReq;
diff --git a/include/hw/virtio/virtio-scsi.h b/include/hw/virtio/virtio-scsi.h
index 31e852ed6..da9798ef3 100644
--- a/include/hw/virtio/virtio-scsi.h
+++ b/include/hw/virtio/virtio-scsi.h
@@ -61,6 +61,16 @@ struct VirtIOSCSIConf {
     CharBackend chardev;
     uint32_t boot_tpgt;
     IOThread *iothread;
+    /*
+     * 在以下使用VirtIOSCSIConf->iothread_vq_mapping_list:
+     *   - hw/scsi/virtio-scsi.c|1385| <<global>> parent_obj.conf.iothread_vq_mapping_list),
+     *   - hw/scsi/virtio-scsi-dataplane.c|32| <<virtio_scsi_dataplane_setup>> if (vs->conf.iothread && vs->conf.iothread_vq_mapping_list) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|39| <<virtio_scsi_dataplane_setup>> if (vs->conf.iothread || vs->conf.iothread_vq_mapping_list) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|67| <<virtio_scsi_dataplane_setup>> if (vs->conf.iothread_vq_mapping_list) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|68| <<virtio_scsi_dataplane_setup>> if (!iothread_vq_mapping_apply(vs->conf.iothread_vq_mapping_list,
+     *   - hw/scsi/virtio-scsi-dataplane.c|96| <<virtio_scsi_dataplane_cleanup>> if (vs->conf.iothread_vq_mapping_list) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|97| <<virtio_scsi_dataplane_cleanup>> iothread_vq_mapping_cleanup(vs->conf.iothread_vq_mapping_list);
+     */
     IOThreadVirtQueueMappingList *iothread_vq_mapping_list;
 };
 
diff --git a/include/hw/virtio/virtio.h b/include/hw/virtio/virtio.h
index 638691028..9ff5860d8 100644
--- a/include/hw/virtio/virtio.h
+++ b/include/hw/virtio/virtio.h
@@ -208,6 +208,13 @@ struct VirtioDeviceClass {
      * must mask in frontend instead.
      */
     void (*guest_notifier_mask)(VirtIODevice *vdev, int n, bool mask);
+    /*
+     * 在以下使用VirtioDeviceClass->start_ioeventfd:
+     *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+     *   - hw/scsi/virtio-scsi.c|1421| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+     *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+     *   - hw/virtio/virtio.c|4153| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+     */
     int (*start_ioeventfd)(VirtIODevice *vdev);
     void (*stop_ioeventfd)(VirtIODevice *vdev);
     /* Called before loading queues. Useful to add queues before loading. */
@@ -291,6 +298,29 @@ int virtio_save(VirtIODevice *vdev, QEMUFile *f);
 
 extern const VMStateInfo virtio_vmstate_info;
 
+/*
+ * 在以下使用VMSTATE_VIRTIO_DEVICE:
+ *   - hw/9pfs/virtio-9p-device.c|241| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/audio/virtio-snd.c|75| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/block/vhost-user-blk.c|602| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/block/virtio-blk.c|2319| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/char/virtio-serial-bus.c|1150| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/display/virtio-gpu.c|1658| <<global>> VMSTATE_VIRTIO_DEVICE ,
+ *   - hw/input/virtio-input.c|297| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/net/virtio-net.c|4056| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/scsi/vhost-scsi.c|407| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/scsi/vhost-user-scsi.c|411| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/scsi/virtio-scsi.c|1404| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/virtio/vdpa-dev.c|378| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/virtio/vhost-user-fs.c|405| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/virtio/vhost-vsock.c|115| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/virtio/virtio-balloon.c|1037| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/virtio/virtio-crypto.c|1126| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/virtio/virtio-iommu.c|1653| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/virtio/virtio-mem.c|1461| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/virtio/virtio-nsm.c|1703| <<global>> VMSTATE_VIRTIO_DEVICE,
+ *   - hw/virtio/virtio-rng.c|247| <<global>> VMSTATE_VIRTIO_DEVICE,
+ */
 #define VMSTATE_VIRTIO_DEVICE \
     {                                         \
         .name = "virtio",                     \
diff --git a/include/migration/vmstate.h b/include/migration/vmstate.h
index a1dfab446..99aa877b7 100644
--- a/include/migration/vmstate.h
+++ b/include/migration/vmstate.h
@@ -1225,6 +1225,15 @@ static inline int vmstate_register(VMStateIf *obj, int instance_id,
                                    const VMStateDescription *vmsd,
                                    void *opaque)
 {
+    /*
+     * 在以下使用vmstate_register_with_alias_id():
+     *   -  hw/core/qdev.c|517| <<device_set_realized>> if (vmstate_register_with_alias_id(VMSTATE_IF(dev),
+     *              VMSTATE_INSTANCE_ID_ANY, qdev_get_vmsd(dev), dev, dev->instance_id_alias,
+     *              dev->alias_required_for_version, &local_err) < 0) {
+     *   - hw/intc/apic_common.c|303| <<apic_common_realize>> vmstate_register_with_alias_id(NULL, instance_id, &vmstate_apic_common, s, -1, 0, NULL);
+     *   - include/migration/vmstate.h|1228| <<vmstate_register>> return vmstate_register_with_alias_id(obj, instance_id, vmsd, opaque, -1, 0, NULL);
+     *   - include/migration/vmstate.h|1256| <<vmstate_register_any>> return vmstate_register_with_alias_id(obj, VMSTATE_INSTANCE_ID_ANY, vmsd, opaque, -1, 0, NULL);
+     */
     return vmstate_register_with_alias_id(obj, instance_id, vmsd,
                                           opaque, -1, 0, NULL);
 }
@@ -1249,10 +1258,35 @@ int vmstate_replace_hack_for_ppc(VMStateIf *obj, int instance_id,
  *
  * Returns: 0 on success, -1 on failure
  */
+/*
+ * 在以下使用vmstate_register_any():
+ *   - audio/audio.c|1787| <<audio_init>> vmstate_register_any(NULL, &vmstate_audio, s);
+ *   - backends/dbus-vmstate.c|429| <<dbus_vmstate_complete>> if (vmstate_register_any(VMSTATE_IF(self), &dbus_vmstate, self) < 0) {
+ *   - backends/tpm/tpm_emulator.c|1009| <<tpm_emulator_inst_init>> vmstate_register_any(NULL, &vmstate_tpm_emulator, obj);
+ *   - hw/display/vmware_vga.c|1265| <<vmsvga_init>> vmstate_register_any(NULL, &vmstate_vga_common, &s->vga);
+ *   - hw/i2c/core.c|66| <<i2c_init_bus>> vmstate_register_any(NULL, &vmstate_i2c_bus, bus);
+ *   - hw/ide/isa.c|76| <<isa_ide_realizefn>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_ide_isa, s);
+ *   - hw/input/adb.c|250| <<adb_bus_realize>> vmstate_register_any(NULL, &vmstate_adb_bus, adb_bus);
+ *   - hw/net/eepro100.c|1888| <<e100_nic_realize>> vmstate_register_any(VMSTATE_IF(&pci_dev->qdev), s->vmstate, s);
+ *   - hw/nvram/eeprom93xx.c|324| <<eeprom93xx_new>> vmstate_register_any(VMSTATE_IF(dev), &vmstate_eeprom, eeprom);
+ *   - hw/pci/pci.c|178| <<pci_bus_realize>> vmstate_register_any(NULL, &vmstate_pcibus, bus);
+ *   - hw/ppc/spapr_nvdimm.c|879| <<spapr_nvdimm_realize>> vmstate_register_any(NULL, &vmstate_spapr_nvdimm_states, dimm);
+ *   - hw/timer/arm_timer.c|184| <<arm_timer_init>> vmstate_register_any(NULL, &vmstate_arm_timer, s);
+ *   - hw/virtio/virtio-mem.c|1122| <<virtio_mem_device_realize>> vmstate_register_any(VMSTATE_IF(vmem), &vmstate_virtio_mem_device_early, vmem);
+ */
 static inline int vmstate_register_any(VMStateIf *obj,
                                        const VMStateDescription *vmsd,
                                        void *opaque)
 {
+    /*
+     * 在以下使用vmstate_register_with_alias_id():
+     *   -  hw/core/qdev.c|517| <<device_set_realized>> if (vmstate_register_with_alias_id(VMSTATE_IF(dev),
+     *              VMSTATE_INSTANCE_ID_ANY, qdev_get_vmsd(dev), dev, dev->instance_id_alias,
+     *              dev->alias_required_for_version, &local_err) < 0) {
+     *   - hw/intc/apic_common.c|303| <<apic_common_realize>> vmstate_register_with_alias_id(NULL, instance_id, &vmstate_apic_common, s, -1, 0, NULL);
+     *   - include/migration/vmstate.h|1228| <<vmstate_register>> return vmstate_register_with_alias_id(obj, instance_id, vmsd, opaque, -1, 0, NULL);
+     *   - include/migration/vmstate.h|1256| <<vmstate_register_any>> return vmstate_register_with_alias_id(obj, VMSTATE_INSTANCE_ID_ANY, vmsd, opaque, -1, 0, NULL);
+     */
     return vmstate_register_with_alias_id(obj, VMSTATE_INSTANCE_ID_ANY, vmsd,
                                           opaque, -1, 0, NULL);
 }
diff --git a/include/qemu/timer.h b/include/qemu/timer.h
index abd2204f3..9631ffa48 100644
--- a/include/qemu/timer.h
+++ b/include/qemu/timer.h
@@ -776,6 +776,19 @@ int qemu_poll_ns(GPollFD *fds, guint nfds, int64_t timeout);
  *
  * Returns: soonest timeout value in nanoseconds (or -1 for infinite)
  */
+/*
+ * 在以下使用qemu_soonest_timeout():
+ *   - accel/tcg/tcg-accel-ops-icount.c|49| <<icount_get_limit>> deadline = qemu_soonest_timeout(deadline,
+ *   - util/aio-posix.c|560| <<run_poll_handlers>> max_ns = qemu_soonest_timeout(*timeout, max_ns);
+ *   - util/aio-posix.c|605| <<try_poll_mode>> max_ns = qemu_soonest_timeout(*timeout, max_ns);
+ *   - util/async.c|298| <<aio_compute_timeout>> return qemu_soonest_timeout(timeout, deadline);
+ *   - util/main-loop.c|278| <<glib_pollfds_fill>> *cur_timeout = qemu_soonest_timeout(timeout_ns, *cur_timeout);
+ *   - util/main-loop.c|515| <<os_host_main_loop_wait>> poll_timeout_ns = qemu_soonest_timeout(poll_timeout_ns, timeout);
+ *   - util/main-loop.c|642| <<main_loop_wait>> timeout_ns = qemu_soonest_timeout(timeout_ns,
+ *   - util/qemu-timer.c|284| <<qemu_clock_deadline_ns_all>> deadline = qemu_soonest_timeout(deadline, delta);
+ *   - util/qemu-timer.c|612| <<timerlistgroup_deadline_ns>> deadline = qemu_soonest_timeout(deadline,
+ *   - util/qemu-timer.c|678| <<qemu_clock_advance_virtual_time>> int64_t warp = qemu_soonest_timeout(dest - clock, deadline);
+ */
 static inline int64_t qemu_soonest_timeout(int64_t timeout1, int64_t timeout2)
 {
     /* we can abuse the fact that -1 (which means infinite) is a maximal
diff --git a/include/system/kvm_int.h b/include/system/kvm_int.h
index 4de610686..d8e40c77e 100644
--- a/include/system/kvm_int.h
+++ b/include/system/kvm_int.h
@@ -121,6 +121,14 @@ struct KVMState
     bool kernel_irqchip_required;
     OnOffAuto kernel_irqchip_split;
     bool sync_mmu;
+    /*
+     * 在以下使用KVMState->guest_state_protected:
+     *   - cel/kvm/kvm-accel-ops.c|112| <<kvm_cpus_are_resettable>> return !kvm_enabled() || !kvm_state->guest_state_protected;
+     *   - accel/kvm/kvm-all.c|2961| <<do_kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3007| <<kvm_cpu_synchronize_state>> if (!cpu->vcpu_dirty && !kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|3054| <<kvm_cpu_synchronize_post_init>> if (!kvm_state->guest_state_protected) {
+     *   - accel/kvm/kvm-all.c|4549| <<kvm_mark_guest_state_protected>> kvm_state->guest_state_protected = true;
+     */
     bool guest_state_protected;
     uint64_t manual_dirty_log_protect;
     /*
@@ -139,6 +147,23 @@ struct KVMState
     unsigned int sigmask_len;
     GHashTable *gsimap;
 #ifdef KVM_CAP_IRQ_ROUTING
+    /*
+     * 在以下使用KVMState->irq_routes:
+     *   - accel/kvm/kvm-all.c|2111| <<kvm_init_irq_routing>> s->irq_routes = g_malloc0(sizeof(*s->irq_routes));
+     *   - accel/kvm/kvm-all.c|2129| <<kvm_irqchip_commit_routes>> s->irq_routes->flags = 0;
+     *   - accel/kvm/kvm-all.c|2131| <<kvm_irqchip_commit_routes>> ret = kvm_vm_ioctl(s, KVM_SET_GSI_ROUTING, s->irq_routes);
+     *   - accel/kvm/kvm-all.c|2141| <<kvm_add_routing_entry>> if (s->irq_routes->nr == s->nr_allocated_irq_routes) {
+     *   - accel/kvm/kvm-all.c|2148| <<kvm_add_routing_entry>> s->irq_routes = g_realloc(s->irq_routes, size);
+     *   - accel/kvm/kvm-all.c|2151| <<kvm_add_routing_entry>> n = s->irq_routes->nr++;
+     *   - accel/kvm/kvm-all.c|2152| <<kvm_add_routing_entry>> new = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2165| <<kvm_update_routing_entry>> for (n = 0; n < s->irq_routes->nr; n++) {
+     *   - accel/kvm/kvm-all.c|2166| <<kvm_update_routing_entry>> entry = &s->irq_routes->entries[n];
+     *   - accel/kvm/kvm-all.c|2206| <<kvm_irqchip_release_virq>> for (i = 0; i < s->irq_routes->nr; i++) {
+     *   - accel/kvm/kvm-all.c|2207| <<kvm_irqchip_release_virq>> e = &s->irq_routes->entries[i];
+     *   - accel/kvm/kvm-all.c|2209| <<kvm_irqchip_release_virq>> s->irq_routes->nr--;
+     *   - accel/kvm/kvm-all.c|2210| <<kvm_irqchip_release_virq>> *e = s->irq_routes->entries[s->irq_routes->nr];
+     *   - accel/kvm/kvm-all.c|2314| <<kvm_irqchip_add_msi_route>> if (s->irq_routes->nr < s->gsi_count) {
+     */
     struct kvm_irq_routing *irq_routes;
     int nr_allocated_irq_routes;
     unsigned long *used_gsi_bitmap;
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index 27181b3dd..2d86c4944 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -43,6 +43,14 @@ struct kvm_userspace_memory_region2 {
 	__u64 pad2[14];
 };
 
+/*
+ * 在以下使用KVM_MEM_LOG_DIRTY_PAGES:
+ *   - linux-headers/linux/kvm.h|51| <<global>> #define KVM_MEM_LOG_DIRTY_PAGES (1UL << 0)
+ *   - accel/kvm/kvm-all.c|608| <<kvm_mem_flags>> flags |= KVM_MEM_LOG_DIRTY_PAGES;
+ *   - accel/kvm/kvm-all.c|720| <<kvm_slot_init_dirty_bitmap>> if (!(mem->flags & KVM_MEM_LOG_DIRTY_PAGES) || mem->dirty_bmap) {
+ *   - accel/kvm/kvm-all.c|1490| <<kvm_set_phys_mem>> if (mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+ *   - accel/kvm/kvm-all.c|1797| <<kvm_log_sync_global>> if (mem->memory_size && mem->flags & KVM_MEM_LOG_DIRTY_PAGES) {
+ */
 /*
  * The bit 0 ~ bit 15 of kvm_userspace_memory_region::flags are visible for
  * userspace, other bits are reserved for kvm internal use which are defined
diff --git a/migration/cpr-transfer.c b/migration/cpr-transfer.c
index e1f140359..3eeb5ef03 100644
--- a/migration/cpr-transfer.c
+++ b/migration/cpr-transfer.c
@@ -17,6 +17,10 @@
 #include "migration/vmstate.h"
 #include "trace.h"
 
+/*
+ * 在以下调用cpr_transfer_output():
+ *   - migration/cpr.c|146| <<cpr_state_save>> f = cpr_transfer_output(channel, errp);
+ */
 QEMUFile *cpr_transfer_output(MigrationChannel *channel, Error **errp)
 {
     MigrationAddress *addr = channel->addr;
diff --git a/migration/cpr.c b/migration/cpr.c
index 42c46563e..9c2188d2c 100644
--- a/migration/cpr.c
+++ b/migration/cpr.c
@@ -133,6 +133,10 @@ bool cpr_is_incoming(void)
     return incoming_mode != MIG_MODE_NONE;
 }
 
+/*
+ * 在以下使用cpr_state_save():
+ *   - migration/migration.c|2226| <<qmp_migrate>> if (cpr_state_save(cpr_channel, &local_err)) {
+ */
 int cpr_state_save(MigrationChannel *channel, Error **errp)
 {
     int ret;
diff --git a/migration/dirtyrate.c b/migration/dirtyrate.c
index 4cd14779d..3aa959d64 100644
--- a/migration/dirtyrate.c
+++ b/migration/dirtyrate.c
@@ -100,6 +100,14 @@ void global_dirty_log_change(unsigned int flag, bool start)
             error_report_err(local_err);
         }
     } else {
+        /*
+	 * 在以下使用memory_global_dirty_log_stop():
+         *   - hw/i386/xen/xen-hvm.c|704| <<qmp_xen_set_global_dirty_log>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+         *   - migration/dirtyrate.c|103| <<global_dirty_log_change>> memory_global_dirty_log_stop(flag);
+         *   - migration/dirtyrate.c|118| <<global_dirty_log_sync>> memory_global_dirty_log_stop(flag);
+         *   - migration/ram.c|2354| <<ram_save_cleanup>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+         *   - migration/ram.c|3622| <<colo_release_ram_cache>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+	 */
         memory_global_dirty_log_stop(flag);
     }
     bql_unlock();
@@ -110,11 +118,37 @@ void global_dirty_log_change(unsigned int flag, bool start)
  * 1. sync dirty log from kvm
  * 2. stop dirty tracking if needed.
  */
+/*
+ * 在以下使用global_dirty_log_sync():
+ *   - migration/dirtyrate.c|171| <<vcpu_calculate_dirtyrate>> global_dirty_log_sync(flag, one_shot);
+ *   - migration/dirtyrate.c|654| <<calculate_dirtyrate_dirty_bitmap>> global_dirty_log_sync(GLOBAL_DIRTY_DIRTY_RATE, true);
+ *
+ * 注释:
+ * global_dirty_log_sync
+ * 1. sync dirty log from kvm
+ * 2. stop dirty tracking if needed.
+ */
 static void global_dirty_log_sync(unsigned int flag, bool one_shot)
 {
     bql_lock();
+    /*
+     * 在以下使用memory_global_dirty_log_sync():
+     *   - migration/dirtyrate.c|116| <<global_dirty_log_sync>> memory_global_dirty_log_sync(false);
+     *   - migration/dirtyrate.c|632| <<calculate_dirtyrate_dirty_bitmap>> memory_global_dirty_log_sync(false);
+     *   - migration/ram.c|1041| <<migration_bitmap_sync>> memory_global_dirty_log_sync(last_stage);
+     *   - migration/ram.c|3600| <<colo_incoming_start_dirty_log>> memory_global_dirty_log_sync(false);
+     *   - migration/ram.c|3872| <<colo_flush_ram_cache>> memory_global_dirty_log_sync(false);
+     */
     memory_global_dirty_log_sync(false);
     if (one_shot) {
+        /*
+	 * 在以下使用memory_global_dirty_log_stop():
+	 *   - hw/i386/xen/xen-hvm.c|704| <<qmp_xen_set_global_dirty_log>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+	 *   - migration/dirtyrate.c|103| <<global_dirty_log_change>> memory_global_dirty_log_stop(flag);
+	 *   - migration/dirtyrate.c|118| <<global_dirty_log_sync>> memory_global_dirty_log_stop(flag);
+	 *   - migration/ram.c|2354| <<ram_save_cleanup>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+	 *   - migration/ram.c|3622| <<colo_release_ram_cache>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+	 */
         memory_global_dirty_log_stop(flag);
     }
     bql_unlock();
@@ -145,6 +179,13 @@ static void vcpu_dirty_stat_collect(DirtyPageRecord *records,
     }
 }
 
+/*
+ * 在以下使用vcpu_calculate_dirtyrate():
+ *   - migration/dirtyrate.c|674| <<calculate_dirtyrate_dirty_ring>> DirtyStat.calc_time_ms =
+ *           vcpu_calculate_dirtyrate(config.calc_time_ms, &DirtyStat.dirty_ring, GLOBAL_DIRTY_DIRTY_RATE, true);
+ *   - system/dirtylimit.c|88| <<vcpu_dirty_rate_stat_collect>> vcpu_calculate_dirtyrate(period,
+ *           &stat, GLOBAL_DIRTY_LIMIT, false); 
+ */
 int64_t vcpu_calculate_dirtyrate(int64_t calc_time_ms,
                                  VcpuStat *stat,
                                  unsigned int flag,
@@ -168,6 +209,16 @@ retry:
 
     duration = dirty_stat_wait(calc_time_ms, init_time_ms);
 
+    /*
+     * 在以下使用global_dirty_log_sync():
+     *   - migration/dirtyrate.c|171| <<vcpu_calculate_dirtyrate>> global_dirty_log_sync(flag, one_shot);
+     *   - migration/dirtyrate.c|654| <<calculate_dirtyrate_dirty_bitmap>> global_dirty_log_sync(GLOBAL_DIRTY_DIRTY_RATE, true);
+     *
+     * 注释:
+     * global_dirty_log_sync
+     * 1. sync dirty log from kvm
+     * 2. stop dirty tracking if needed.
+     */
     global_dirty_log_sync(flag, one_shot);
 
     WITH_QEMU_LOCK_GUARD(&qemu_cpu_list_lock) {
@@ -629,6 +680,14 @@ static void calculate_dirtyrate_dirty_bitmap(struct DirtyRateConfig config)
      * skip it unconditionally and start dirty tracking
      * from 2'round of log sync
      */
+    /*
+     * 在以下使用memory_global_dirty_log_sync():
+     *   - migration/dirtyrate.c|116| <<global_dirty_log_sync>> memory_global_dirty_log_sync(false);
+     *   - migration/dirtyrate.c|632| <<calculate_dirtyrate_dirty_bitmap>> memory_global_dirty_log_sync(false);
+     *   - migration/ram.c|1041| <<migration_bitmap_sync>> memory_global_dirty_log_sync(last_stage);
+     *   - migration/ram.c|3600| <<colo_incoming_start_dirty_log>> memory_global_dirty_log_sync(false);
+     *   - migration/ram.c|3872| <<colo_flush_ram_cache>> memory_global_dirty_log_sync(false);
+     */
     memory_global_dirty_log_sync(false);
 
     /*
@@ -651,6 +710,16 @@ static void calculate_dirtyrate_dirty_bitmap(struct DirtyRateConfig config)
      * 1. fetch dirty bitmap from kvm
      * 2. stop dirty tracking
      */
+    /*
+     * 在以下使用global_dirty_log_sync():
+     *   - migration/dirtyrate.c|171| <<vcpu_calculate_dirtyrate>> global_dirty_log_sync(flag, one_shot);
+     *   - migration/dirtyrate.c|654| <<calculate_dirtyrate_dirty_bitmap>> global_dirty_log_sync(GLOBAL_DIRTY_DIRTY_RATE, true);
+     *
+     * 注释:
+     * global_dirty_log_sync
+     * 1. sync dirty log from kvm
+     * 2. stop dirty tracking if needed.
+     */
     global_dirty_log_sync(GLOBAL_DIRTY_DIRTY_RATE, true);
 
     record_dirtypages_bitmap(&dirty_pages, false);
@@ -659,6 +728,10 @@ static void calculate_dirtyrate_dirty_bitmap(struct DirtyRateConfig config)
                                                   DirtyStat.calc_time_ms);
 }
 
+/*
+ * 在以下使用calculate_dirtyrate_dirty_ring():
+ *   - migration/dirtyrate.c|790| <<calculate_dirtyrate>> calculate_dirtyrate_dirty_ring(config);
+ */
 static void calculate_dirtyrate_dirty_ring(struct DirtyRateConfig config)
 {
     uint64_t dirtyrate = 0;
@@ -670,6 +743,13 @@ static void calculate_dirtyrate_dirty_ring(struct DirtyRateConfig config)
 
     DirtyStat.start_time = qemu_clock_get_ms(QEMU_CLOCK_HOST) / 1000;
 
+    /*
+     * 在以下使用vcpu_calculate_dirtyrate():
+     *   - migration/dirtyrate.c|674| <<calculate_dirtyrate_dirty_ring>> DirtyStat.calc_time_ms =
+     *           vcpu_calculate_dirtyrate(config.calc_time_ms, &DirtyStat.dirty_ring, GLOBAL_DIRTY_DIRTY_RATE, true);
+     *   - system/dirtylimit.c|88| <<vcpu_dirty_rate_stat_collect>> vcpu_calculate_dirtyrate(period,
+     *           &stat, GLOBAL_DIRTY_LIMIT, false);
+     */
     /* calculate vcpu dirtyrate */
     DirtyStat.calc_time_ms = vcpu_calculate_dirtyrate(config.calc_time_ms,
                                                       &DirtyStat.dirty_ring,
diff --git a/migration/migration.c b/migration/migration.c
index d46e776e2..5344d5a6a 100644
--- a/migration/migration.c
+++ b/migration/migration.c
@@ -362,6 +362,10 @@ void migration_bh_schedule(QEMUBHFunc *cb, void *opaque)
     qemu_bh_schedule(bh);
 }
 
+/*
+ * 在以下使用migration_shutdown():
+ *   - system/runstate.c|899| <<qemu_cleanup>> migration_shutdown();
+ */
 void migration_shutdown(void)
 {
     /*
@@ -1584,6 +1588,11 @@ static void migration_connect_set_error(MigrationState *s, const Error *error)
     migrate_set_error(s, error);
 }
 
+/*
+ * 在以下使用migration_cancel():
+ *   - migration/migration.c|2314| <<qmp_migrate_cancel>> migration_cancel();
+ *   - migration/ram.c|4544| <<ram_mig_ram_block_resized>> migration_cancel();
+ */
 void migration_cancel(void)
 {
     MigrationState *s = migrate_get_current();
@@ -2311,6 +2320,11 @@ void qmp_migrate_cancel(Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用migration_cancel():
+     *   - migration/migration.c|2314| <<qmp_migrate_cancel>> migration_cancel();
+     *   - migration/ram.c|4544| <<ram_mig_ram_block_resized>> migration_cancel();
+     */
     migration_cancel();
 }
 
diff --git a/migration/qemu-file.c b/migration/qemu-file.c
index 1303a5bf5..e3a744a92 100644
--- a/migration/qemu-file.c
+++ b/migration/qemu-file.c
@@ -273,6 +273,41 @@ bool qemu_file_is_seekable(QEMUFile *f)
     return qio_channel_has_feature(f->ioc, QIO_CHANNEL_FEATURE_SEEKABLE);
 }
 
+/*
+ * 在以下使用qemu_fflush():
+ *   - hw/vfio/migration-multifd.c|220| <<vfio_load_bufs_thread_load_config>> ret = qemu_fflush(f_out);
+ *   - hw/vfio/migration-multifd.c|557| <<vfio_save_complete_precopy_thread_config_state>> ret = qemu_fflush(f);
+ *   - migration/block-dirty-bitmap.c|458| <<send_bitmap_bits>> qemu_fflush(f);
+ *   - migration/colo.c|321| <<colo_send_message>> ret = qemu_fflush(f);
+ *   - migration/colo.c|340| <<colo_send_message_value>> ret = qemu_fflush(f);
+ *   - migration/colo.c|476| <<colo_do_checkpoint_transaction>> qemu_fflush(fb);
+ *   - migration/colo.c|489| <<colo_do_checkpoint_transaction>> ret = qemu_fflush(s->to_dst_file);
+ *   - migration/cpr.c|172| <<cpr_state_save>> qemu_fflush(f);
+ *   - migration/migration.c|516| <<migrate_send_rp_message>> return qemu_fflush(mis->to_src_file);
+ *   - migration/migration.c|3080| <<bg_migration_completion>> qemu_fflush(s->to_dst_file);
+ *   - migration/migration.c|3864| <<bg_migration_thread>> qemu_fflush(fb);
+ *   - migration/multifd-nocomp.c|435| <<multifd_ram_flush_and_sync>> qemu_fflush(f);
+ *   - migration/qemu-file.c|386| <<qemu_file_put_fd>> qemu_fflush(f);
+ *   - migration/qemu-file.c|435| <<qemu_fclose>> int ret = qemu_fflush(f);
+ *   - migration/qemu-file.c|483| <<add_to_iovec>> qemu_fflush(f);
+ *   - migration/qemu-file.c|495| <<add_buf_to_iovec>> qemu_fflush(f);
+ *   - migration/qemu-file.c|543| <<qemu_put_buffer_at>> qemu_fflush(f);
+ *   - migration/qemu-file.c|606| <<qemu_set_offset>> qemu_fflush(f);
+ *   - migration/qemu-file.c|624| <<qemu_get_offset>> qemu_fflush(f);
+ *   - migration/ram.c|315| <<ramblock_recv_bitmap_send>> int ret = qemu_fflush(file);
+ *   - migration/ram.c|1449| <<ram_save_release_protection>> qemu_fflush(pss->pss_channel);
+ *   - migration/ram.c|2112| <<ram_save_host_page_urgent>> qemu_fflush(pss->pss_channel);
+ *   - migration/ram.c|3089| <<ram_save_setup>> ret = qemu_fflush(f);
+ *   - migration/ram.c|3229| <<ram_save_iterate>> ret = qemu_fflush(f);
+ *   - migration/ram.c|3340| <<ram_save_complete>> return qemu_fflush(f);
+ *   - migration/ram.c|4538| <<postcopy_preempt_shutdown_file>> qemu_fflush(s->postcopy_qemufile_src);
+ *   - migration/rdma.c|3225| <<qemu_rdma_save_page>> qemu_fflush(f);
+ *   - migration/rdma.c|3849| <<rdma_registration_start>> return qemu_fflush(f);
+ *   - migration/rdma.c|3879| <<rdma_registration_stop>> qemu_fflush(f);
+ *   - migration/savevm.c|1254| <<qemu_savevm_command_send>> qemu_fflush(f);
+ *   - migration/savevm.c|1698| <<qemu_savevm_state_complete_postcopy>> qemu_fflush(f);
+ *   - migration/savevm.c|1851| <<qemu_savevm_state_complete_precopy>> return qemu_fflush(f);
+ */
 /**
  * Flushes QEMUFile buffer
  *
diff --git a/migration/ram.c b/migration/ram.c
index 424df6d9f..a53b81bdf 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -886,6 +886,12 @@ bool ramblock_page_is_discarded(RAMBlock *rb, ram_addr_t start)
     return false;
 }
 
+/*
+ * 在以下调用ramblock_sync_dirty_bitmap():
+ *   - migration/ram.c|1035| <<migration_bitmap_sync>> ramblock_sync_dirty_bitmap(rs, block);
+ *   - migration/ram.c|3543| <<colo_incoming_start_dirty_log>> ramblock_sync_dirty_bitmap(ram_state, block);
+ *   - migration/ram.c|3816| <<colo_flush_ram_cache>> ramblock_sync_dirty_bitmap(ram_state, block);
+ */
 /* Called with RCU critical section */
 static void ramblock_sync_dirty_bitmap(RAMState *rs, RAMBlock *rb)
 {
@@ -1015,6 +1021,11 @@ static void migration_trigger_throttle(RAMState *rs)
     }
 }
 
+/*
+ * 在以下调用migration_bitmap_sync():
+ *   - migration/ram.c|1079| <<migration_bitmap_sync_precopy>> migration_bitmap_sync(ram_state, last_stage);
+ *   - migration/ram.c|2539| <<ram_postcopy_send_discard_bitmap>> migration_bitmap_sync(rs, false);
+ */
 static void migration_bitmap_sync(RAMState *rs, bool last_stage)
 {
     RAMBlock *block;
@@ -1027,6 +1038,14 @@ static void migration_bitmap_sync(RAMState *rs, bool last_stage)
     }
 
     trace_migration_bitmap_sync_start();
+    /*
+     * 在以下使用memory_global_dirty_log_sync():
+     *   - migration/dirtyrate.c|116| <<global_dirty_log_sync>> memory_global_dirty_log_sync(false);
+     *   - migration/dirtyrate.c|632| <<calculate_dirtyrate_dirty_bitmap>> memory_global_dirty_log_sync(false);
+     *   - migration/ram.c|1041| <<migration_bitmap_sync>> memory_global_dirty_log_sync(last_stage);
+     *   - migration/ram.c|3600| <<colo_incoming_start_dirty_log>> memory_global_dirty_log_sync(false);
+     *   - migration/ram.c|3872| <<colo_flush_ram_cache>> memory_global_dirty_log_sync(false);
+     */
     memory_global_dirty_log_sync(last_stage);
 
     WITH_QEMU_LOCK_GUARD(&rs->bitmap_mutex) {
@@ -1062,6 +1081,13 @@ static void migration_bitmap_sync(RAMState *rs, bool last_stage)
     }
 }
 
+/*
+ * 在以下调用migration_bitmap_sync_precopy():
+ *   - migration/cpu-throttle.c|151| <<cpu_throttle_dirty_sync_timer_tick>> migration_bitmap_sync_precopy(false);
+ *   - migration/ram.c|2733| <<ram_init_bitmaps>> migration_bitmap_sync_precopy(false);
+ *   - migration/ram.c|3212| <<ram_save_complete>> migration_bitmap_sync_precopy(true);
+ *   - migration/ram.c|3300| <<ram_state_pending_exact>> migration_bitmap_sync_precopy(false);
+ */
 void migration_bitmap_sync_precopy(bool last_stage)
 {
     Error *local_err = NULL;
@@ -2184,6 +2210,11 @@ static int ram_save_host_page(RAMState *rs, PageSearchStatus *pss)
  * On systems where host-page-size > target-page-size it will send all the
  * pages in a host page that are dirty.
  */
+/*
+ * 在以下调用ram_find_and_save_block():
+ *   - migration/ram.c|3130| <<ram_save_iterate>> pages = ram_find_and_save_block(rs);
+ *   - migration/ram.c|3228| <<ram_save_complete>> pages = ram_find_and_save_block(rs);
+ */
 static int ram_find_and_save_block(RAMState *rs)
 {
     PageSearchStatus *pss = &rs->pss[RAM_CHANNEL_PRECOPY];
@@ -2328,6 +2359,14 @@ static void ram_save_cleanup(void *opaque)
              * memory_global_dirty_log_stop will assert that
              * memory_global_dirty_log_start/stop used in pairs
              */
+            /*
+	     * 在以下使用memory_global_dirty_log_stop():
+	     *   - hw/i386/xen/xen-hvm.c|704| <<qmp_xen_set_global_dirty_log>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+	     *   - migration/dirtyrate.c|103| <<global_dirty_log_change>> memory_global_dirty_log_stop(flag);
+	     *   - migration/dirtyrate.c|118| <<global_dirty_log_sync>> memory_global_dirty_log_stop(flag);
+	     *   - migration/ram.c|2354| <<ram_save_cleanup>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+	     *   - migration/ram.c|3622| <<colo_release_ram_cache>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+	     */
             memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
         }
     }
@@ -2730,6 +2769,13 @@ static bool ram_init_bitmaps(RAMState *rs, Error **errp)
             if (!ret) {
                 goto out_unlock;
             }
+            /*
+	     * 在以下调用migration_bitmap_sync_precopy():
+             *   - migration/cpu-throttle.c|151| <<cpu_throttle_dirty_sync_timer_tick>> migration_bitmap_sync_precopy(false);
+             *   - migration/ram.c|2733| <<ram_init_bitmaps>> migration_bitmap_sync_precopy(false);
+	     *   - migration/ram.c|3212| <<ram_save_complete>> migration_bitmap_sync_precopy(true);
+             *   - migration/ram.c|3300| <<ram_state_pending_exact>> migration_bitmap_sync_precopy(false);
+	     */
             migration_bitmap_sync_precopy(false);
         }
     }
@@ -3189,6 +3235,22 @@ out:
     return done;
 }
 
+/*
+ * 4480 static SaveVMHandlers savevm_ram_handlers = {
+ * 4481     .save_setup = ram_save_setup,
+ * 4482     .save_live_iterate = ram_save_iterate,
+ * 4483     .save_live_complete_postcopy = ram_save_complete,
+ * 4484     .save_live_complete_precopy = ram_save_complete,
+ * 4485     .has_postcopy = ram_has_postcopy,
+ * 4486     .state_pending_exact = ram_state_pending_exact,
+ * 4487     .state_pending_estimate = ram_state_pending_estimate,
+ * 4488     .load_state = ram_load,
+ * 4489     .save_cleanup = ram_save_cleanup,
+ * 4490     .load_setup = ram_load_setup,
+ * 4491     .load_cleanup = ram_load_cleanup,
+ * 4492     .resume_prepare = ram_resume_prepare,
+ * 4493 };
+ */
 /**
  * ram_save_complete: function called to send the remaining amount of ram
  *
@@ -3209,6 +3271,13 @@ static int ram_save_complete(QEMUFile *f, void *opaque)
 
     WITH_RCU_READ_LOCK_GUARD() {
         if (!migration_in_postcopy()) {
+            /*
+	     * 在以下调用migration_bitmap_sync_precopy():
+             *   - migration/cpu-throttle.c|151| <<cpu_throttle_dirty_sync_timer_tick>> migration_bitmap_sync_precopy(false);
+             *   - migration/ram.c|2733| <<ram_init_bitmaps>> migration_bitmap_sync_precopy(false);
+             *   - migration/ram.c|3212| <<ram_save_complete>> migration_bitmap_sync_precopy(true);
+             *   - migration/ram.c|3300| <<ram_state_pending_exact>> migration_bitmap_sync_precopy(false);
+	     */
             migration_bitmap_sync_precopy(true);
         }
 
@@ -3297,6 +3366,13 @@ static void ram_state_pending_exact(void *opaque, uint64_t *must_precopy,
     if (!migration_in_postcopy()) {
         bql_lock();
         WITH_RCU_READ_LOCK_GUARD() {
+            /*
+	     * 在以下调用migration_bitmap_sync_precopy():
+             *   - migration/cpu-throttle.c|151| <<cpu_throttle_dirty_sync_timer_tick>> migration_bitmap_sync_precopy(false);
+             *   - migration/ram.c|2733| <<ram_init_bitmaps>> migration_bitmap_sync_precopy(false);
+             *   - migration/ram.c|3212| <<ram_save_complete>> migration_bitmap_sync_precopy(true);
+             *   - migration/ram.c|3300| <<ram_state_pending_exact>> migration_bitmap_sync_precopy(false);
+	     */
             migration_bitmap_sync_precopy(false);
         }
         bql_unlock();
@@ -3537,6 +3613,14 @@ void colo_incoming_start_dirty_log(void)
     bql_lock();
     qemu_mutex_lock_ramlist();
 
+    /*
+     * 在以下使用memory_global_dirty_log_sync():
+     *   - migration/dirtyrate.c|116| <<global_dirty_log_sync>> memory_global_dirty_log_sync(false);
+     *   - migration/dirtyrate.c|632| <<calculate_dirtyrate_dirty_bitmap>> memory_global_dirty_log_sync(false);
+     *   - migration/ram.c|1041| <<migration_bitmap_sync>> memory_global_dirty_log_sync(last_stage);
+     *   - migration/ram.c|3600| <<colo_incoming_start_dirty_log>> memory_global_dirty_log_sync(false);
+     *   - migration/ram.c|3872| <<colo_flush_ram_cache>> memory_global_dirty_log_sync(false);
+     */
     memory_global_dirty_log_sync(false);
     WITH_RCU_READ_LOCK_GUARD() {
         RAMBLOCK_FOREACH_NOT_IGNORED(block) {
@@ -3559,6 +3643,14 @@ void colo_release_ram_cache(void)
 {
     RAMBlock *block;
 
+    /*
+     * 在以下使用memory_global_dirty_log_stop():
+     *   - hw/i386/xen/xen-hvm.c|704| <<qmp_xen_set_global_dirty_log>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+     *   - migration/dirtyrate.c|103| <<global_dirty_log_change>> memory_global_dirty_log_stop(flag);
+     *   - migration/dirtyrate.c|118| <<global_dirty_log_sync>> memory_global_dirty_log_stop(flag);
+     *   - migration/ram.c|2354| <<ram_save_cleanup>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+     *   - migration/ram.c|3622| <<colo_release_ram_cache>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+     */
     memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
     RAMBLOCK_FOREACH_NOT_IGNORED(block) {
         g_free(block->bmap);
@@ -3809,6 +3901,14 @@ void colo_flush_ram_cache(void)
     void *src_host;
     unsigned long offset = 0;
 
+    /*
+     * 在以下使用memory_global_dirty_log_sync():
+     *   - migration/dirtyrate.c|116| <<global_dirty_log_sync>> memory_global_dirty_log_sync(false);
+     *   - migration/dirtyrate.c|632| <<calculate_dirtyrate_dirty_bitmap>> memory_global_dirty_log_sync(false);
+     *   - migration/ram.c|1041| <<migration_bitmap_sync>> memory_global_dirty_log_sync(last_stage);
+     *   - migration/ram.c|3600| <<colo_incoming_start_dirty_log>> memory_global_dirty_log_sync(false);
+     *   - migration/ram.c|3872| <<colo_flush_ram_cache>> memory_global_dirty_log_sync(false);
+     */
     memory_global_dirty_log_sync(false);
     qemu_mutex_lock(&ram_state->bitmap_mutex);
     WITH_RCU_READ_LOCK_GUARD() {
@@ -3992,6 +4092,11 @@ static int parse_ramblock(QEMUFile *f, RAMBlock *block, ram_addr_t length)
     }
 
     if (length != block->used_length) {
+        /*
+	 * called by:
+	 *   - migration/ram.c|3995| <<parse_ramblock>> ret = qemu_ram_resize(block, length, &local_err);
+	 *   - system/memory.c|2476| <<memory_region_ram_resize>> qemu_ram_resize(mr->ram_block, newsize, errp);
+	 */
         ret = qemu_ram_resize(block, length, &local_err);
         if (local_err) {
             error_report_err(local_err);
@@ -4073,6 +4178,10 @@ static int parse_ramblocks(QEMUFile *f, ram_addr_t total_ram_bytes)
  *
  * @f: QEMUFile where to send the data
  */
+/*
+ * 在以下调用ram_load_precopy():
+ *   - migration/ram.c|4271| <<ram_load>> ret = ram_load_precopy(f);
+ */
 static int ram_load_precopy(QEMUFile *f)
 {
     MigrationIncomingState *mis = migration_incoming_get_current();
@@ -4263,6 +4372,9 @@ static int ram_load(QEMUFile *f, void *opaque, int version_id)
              */
             ret = ram_load_postcopy(f, RAM_CHANNEL_PRECOPY);
         } else {
+            /*
+	     * 只在此处调用ram_load_precopy()
+	     */
             ret = ram_load_precopy(f);
         }
     }
@@ -4469,6 +4581,11 @@ static void ram_mig_ram_block_resized(RAMBlockNotifier *n, void *host,
         migrate_set_error(migrate_get_current(), err);
         error_free(err);
 
+        /*
+	 * 在以下使用migration_cancel():
+	 *   - migration/migration.c|2314| <<qmp_migrate_cancel>> migration_cancel();
+	 *   - migration/ram.c|4544| <<ram_mig_ram_block_resized>> migration_cancel();
+	 */
         migration_cancel();
     }
 
diff --git a/migration/ram.h b/migration/ram.h
index 921c39a2c..ee2e81c12 100644
--- a/migration/ram.h
+++ b/migration/ram.h
@@ -63,11 +63,51 @@
 
 extern XBZRLECacheStats xbzrle_counters;
 
+/*
+ * 在以下使用RAMBLOCK_FOREACH_NOT_IGNORED():
+ *   - migration/ram.c|214| <<foreach_not_ignored_block>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|227| <<ramblock_recv_map_init>> RAMBLOCK_FOREACH_NOT_IGNORED(rb) {
+ *   - migration/ram.c|913| <<ram_pagesize_summary>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|1034| <<migration_bitmap_sync>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|1466| <<ram_write_tracking_compatible>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|1565| <<ram_write_tracking_prepare>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|1636| <<ram_write_tracking_start>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|1664| <<ram_write_tracking_start>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|1689| <<ram_write_tracking_stop>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|2258| <<ram_bytes_total>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|2306| <<ram_bitmaps_destroy>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|2364| <<ram_postcopy_migrated_memory_release>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|2431| <<postcopy_each_ram_send_discard>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|2684| <<ram_list_init_bitmaps>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|2713| <<migration_bitmap_clear_discarded_pages>> RAMBLOCK_FOREACH_NOT_IGNORED(rb) {
+ *   - migration/ram.c|2781| <<ram_state_resume_prepare>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|3492| <<colo_init_ram_cache>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|3499| <<colo_init_ram_cache>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|3520| <<colo_init_ram_cache>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|3542| <<colo_incoming_start_dirty_log>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|3563| <<colo_release_ram_cache>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|3569| <<colo_release_ram_cache>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|3600| <<ram_load_cleanup>> RAMBLOCK_FOREACH_NOT_IGNORED(rb) {
+ *   - migration/ram.c|3606| <<ram_load_cleanup>> RAMBLOCK_FOREACH_NOT_IGNORED(rb) {
+ *   - migration/ram.c|3815| <<colo_flush_ram_cache>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ *   - migration/ram.c|4282| <<ram_has_postcopy>> RAMBLOCK_FOREACH_NOT_IGNORED(rb) {
+ *   - migration/ram.c|4302| <<ram_dirty_bitmap_sync_all>> RAMBLOCK_FOREACH_NOT_IGNORED(block) {
+ */
 /* Should be holding either ram_list.mutex, or the RCU lock. */
 #define RAMBLOCK_FOREACH_NOT_IGNORED(block)            \
     INTERNAL_RAMBLOCK_FOREACH(block)                   \
         if (migrate_ram_is_ignored(block)) {} else
 
+/*
+ * 在以下使用RAMBLOCK_FOREACH_MIGRATABLE():
+ *   - migration/dirtyrate.c|494| <<record_ramblock_hash_info>> RAMBLOCK_FOREACH_MIGRATABLE(block) {
+ *   - migration/dirtyrate.c|506| <<record_ramblock_hash_info>> RAMBLOCK_FOREACH_MIGRATABLE(block) {
+ *   - migration/dirtyrate.c|574| <<compare_page_hash_info>> RAMBLOCK_FOREACH_MIGRATABLE(block) {
+ *   - migration/dirtyrate.c|608| <<dirtyrate_manual_reset_protect>> RAMBLOCK_FOREACH_MIGRATABLE(block) {
+ *   - migration/ram.c|2245| <<ram_bytes_total_with_ignored>> RAMBLOCK_FOREACH_MIGRATABLE(block) {
+ *   - migration/ram.c|2973| <<ram_save_setup>> RAMBLOCK_FOREACH_MIGRATABLE(block) {
+ *   - migration/ram.c|3054| <<ram_save_file_bmap>> RAMBLOCK_FOREACH_MIGRATABLE(block) {
+ */
 #define RAMBLOCK_FOREACH_MIGRATABLE(block)             \
     INTERNAL_RAMBLOCK_FOREACH(block)                   \
         if (!qemu_ram_is_migratable(block)) {} else
diff --git a/migration/savevm.c b/migration/savevm.c
index ce158c351..19a2943aa 100644
--- a/migration/savevm.c
+++ b/migration/savevm.c
@@ -263,6 +263,48 @@ typedef struct SaveState {
     QemuUUID uuid;
 } SaveState;
 
+/*
+ * 在以下使用savevm_state:
+ *   - migration/savevm.c|266| <<global>> static SaveState savevm_state = {
+ *   - migration/savevm.c|267| <<global>> .handlers = QTAILQ_HEAD_INITIALIZER(savevm_state.handlers),
+ *   - migration/savevm.c|709| <<calculate_new_instance_id>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|725| <<calculate_compat_instance_id>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|870| <<savevm_state_handler_insert>> se = savevm_state.handler_pri_head[i];
+ *   - migration/savevm.c|880| <<savevm_state_handler_insert>> QTAILQ_INSERT_TAIL(&savevm_state.handlers, nse, entry);
+ *   - migration/savevm.c|883| <<savevm_state_handler_insert>> if (savevm_state.handler_pri_head[priority] == NULL) {
+ *   - migration/savevm.c|884| <<savevm_state_handler_insert>> savevm_state.handler_pri_head[priority] = nse; 
+ *   - migration/savevm.c|893| <<savevm_state_handler_remove>> if (se == savevm_state.handler_pri_head[priority]) {
+ *   - migration/savevm.c|896| <<savevm_state_handler_remove>> savevm_state.handler_pri_head[priority] = next;
+ *   - migration/savevm.c|898| <<savevm_state_handler_remove>> savevm_state.handler_pri_head[priority] = NULL;
+ *   - migration/savevm.c|901| <<savevm_state_handler_remove>> QTAILQ_REMOVE(&savevm_state.handlers, se, entry);
+ *   - migration/savevm.c|918| <<register_savevm_live>> se->section_id = savevm_state.global_section_id++;
+ *   - migration/savevm.c|954| <<unregister_savevm>> QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {
+ *   - migration/savevm.c|1013| <<vmstate_register_with_alias_id>> se->section_id = savevm_state.global_section_id++;
+ *   - migration/savevm.c|1060| <<vmstate_unregister>> QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {
+ *   - migration/savevm.c|1357| <<qemu_savevm_state_blocked>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1371| <<qemu_savevm_non_migratable_list>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1402| <<qemu_savevm_state_header>> vmstate_save_state(f, &vmstate_configuration, &savevm_state, vmdesc);
+ *   - migration/savevm.c|1414| <<qemu_savevm_state_guest_unplug_pending>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1429| <<qemu_savevm_state_prepare>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1462| <<qemu_savevm_state_setup>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1506| <<qemu_savevm_state_resume_prepare>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1537| <<qemu_savevm_state_iterate>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1602| <<qemu_savevm_state_complete_postcopy>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1637| <<qemu_savevm_state_complete_precopy_iterable>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1653| <<qemu_savevm_state_complete_precopy_iterable>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1722| <<qemu_savevm_state_complete_precopy_non_iterable>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1794| <<qemu_savevm_state_pending_estimate>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1815| <<qemu_savevm_state_pending_exact>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1838| <<qemu_savevm_state_cleanup>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1919| <<qemu_save_device_state>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|1942| <<find_se>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|2581| <<loadvm_postcopy_handle_switchover_start>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) 
+ *   - migration/savevm.c|2843| <<qemu_loadvm_section_part_end>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|2903| <<qemu_loadvm_state_header>> ret = vmstate_load_state(f, &vmstate_configuration, &savevm_state, 0);
+ *   - migration/savevm.c|2916| <<qemu_loadvm_state_switchover_ack_needed>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|2936| <<qemu_loadvm_state_setup>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ *   - migration/savevm.c|3012| <<qemu_loadvm_state_cleanup>> QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
+ */
 static SaveState savevm_state = {
     .handlers = QTAILQ_HEAD_INITIALIZER(savevm_state.handlers),
     .handler_pri_head = { [MIG_PRI_DEFAULT ... MIG_PRI_MAX] = NULL },
@@ -701,6 +743,11 @@ void dump_vmstate_json_to_file(FILE *out_file)
     g_slist_free(list);
 }
 
+/*
+ * 在以下使用calculate_new_instance_id():
+ *   - migration/savevm.c|930| <<register_savevm_live>> se->instance_id = calculate_new_instance_id(se->idstr);
+ *   - migration/savevm.c|1041| <<vmstate_register_with_alias_id>> se->instance_id = calculate_new_instance_id(se->idstr);
+ */
 static uint32_t calculate_new_instance_id(const char *idstr)
 {
     SaveStateEntry *se;
@@ -743,6 +790,109 @@ static inline MigrationPriority save_state_priority(SaveStateEntry *se)
     return MIG_PRI_DEFAULT;
 }
 
+/*(gdb) bt
+ * #0  savevm_state_handler_insert (nse=0x555557cf1910) at ../migration/savevm.c:748
+ * #1  0x0000555555c807db in vmstate_register_with_alias_id (obj=0x0, instance_id=4294967295, vmsd=0x5555571d13c0 <vmstate_pcibus>,
+ *     opaque=0x5555578dd660, alias_id=-1, required_for_version=0, errp=0x0) at ../migration/savevm.c:950
+ * #2  0x0000555555acae82 in vmstate_register_any (obj=0x0, vmsd=0x5555571d13c0 <vmstate_pcibus>, opaque=0x5555578dd660)
+ *     at /home/zhang/kvm/test/qemu-10.0.0/include/migration/vmstate.h:1256
+ * #3  0x0000555555acbb5f in pci_bus_realize (qbus=0x5555578dd660, errp=0x7fffffffd190) at ../hw/pci/pci.c:212
+ * #4  0x0000555555acbbb4 in pcie_bus_realize (qbus=0x5555578dd660, errp=0x7fffffffd500) at ../hw/pci/pci.c:220
+ * #5  0x0000555555f198e8 in bus_set_realized (obj=0x5555578dd660, value=true, errp=0x7fffffffd500) at ../hw/core/bus.c:197
+ * #6  0x0000555555f2940c in property_set_bool (obj=0x5555578dd660, v=0x5555578de7e0, name=0x5555563e91e3 "realized",
+ *     opaque=0x5555578de540, errp=0x7fffffffd500) at ../qom/object.c:2374
+ * #7  0x0000555555f26e81 in object_property_set (obj=0x5555578dd660, name=0x5555563e91e3 "realized", v=0x5555578de7e0,
+ *     errp=0x7fffffffd500) at ../qom/object.c:1449
+ * #8  0x0000555555f2bd0e in object_property_set_qobject (obj=0x5555578dd660, name=0x5555563e91e3 "realized", value=0x5555578de720,
+ *     errp=0x7fffffffd500) at ../qom/qom-qobject.c:28
+ * #9  0x0000555555f27226 in object_property_set_bool (obj=0x5555578dd660, name=0x5555563e91e3 "realized", value=true,
+ *     errp=0x7fffffffd500) at ../qom/object.c:1519
+ * #10 0x0000555555f197e5 in qbus_realize (bus=0x5555578dd660, errp=0x7fffffffd500) at ../hw/core/bus.c:174
+ * #11 0x0000555555f1e606 in device_set_realized (obj=0x55555775cfd0, value=true, errp=0x7fffffffd500) at ../hw/core/qdev.c:534
+ * #12 0x0000555555f2940c in property_set_bool (obj=0x55555775cfd0, v=0x5555578a7000, name=0x5555563e9b29 "realized",
+ *     opaque=0x555557461090, errp=0x7fffffffd500) at ../qom/object.c:2374
+ * #13 0x0000555555f26e81 in object_property_set (obj=0x55555775cfd0, name=0x5555563e9b29 "realized", v=0x5555578a7000,
+ *     errp=0x7fffffffd500) at ../qom/object.c:1449
+ * #14 0x0000555555f2bd0e in object_property_set_qobject (obj=0x55555775cfd0, name=0x5555563e9b29 "realized", value=0x5555578a6e60,
+ *     errp=0x5555573a2120 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #15 0x0000555555f27226 in object_property_set_bool (obj=0x55555775cfd0, name=0x5555563e9b29 "realized", value=true,
+ *     errp=0x5555573a2120 <error_fatal>) at ../qom/object.c:1519
+ * #16 0x0000555555f1db85 in qdev_realize (dev=0x55555775cfd0, bus=0x5555576e0400, errp=0x5555573a2120 <error_fatal>)
+ *     at ../hw/core/qdev.c:276
+ * #17 0x0000555555f1dbbe in qdev_realize_and_unref (dev=0x55555775cfd0, bus=0x5555576e0400, errp=0x5555573a2120 <error_fatal>)
+ *     at ../hw/core/qdev.c:283
+ * #18 0x00005555559859bd in sysbus_realize_and_unref (dev=0x55555775cfd0, errp=0x5555573a2120 <error_fatal>) at ../hw/core/sysbus.c:243
+ * #19 0x0000555555d616a8 in pc_q35_init (machine=0x5555576d6570) at ../hw/i386/pc_q35.c:225
+ * #20 0x0000555555d61e5d in pc_q35_machine_10_0_init (machine=0x5555576d6570) at ../hw/i386/pc_q35.c:369
+ * #21 0x000055555597d861 in machine_run_board_init (machine=0x5555576d6570, mem_path=0x0, errp=0x7fffffffd7c0) at ../hw/core/machine.c:1682
+ * #22 0x0000555555c355fc in qemu_init_board () at ../system/vl.c:2711
+ * #23 0x0000555555c359a1 in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2807
+ * #24 0x0000555555c384cb in qemu_init (argc=25, argv=0x7fffffffdae8) at ../system/vl.c:3843
+ * #25 0x00005555560d2b7f in main (argc=25, argv=0x7fffffffdae8) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  savevm_state_handler_insert (nse=0x555558508b90) at ../migration/savevm.c:748
+ * #1  0x0000555555c807db in vmstate_register_with_alias_id (obj=0x555558383c50, instance_id=4294967295, vmsd=0x555557204780 <vmstate_virtio_scsi>,
+ * opaque=0x555558383c50, alias_id=-1, required_for_version=0, errp=0x7fffffffd0a0) at ../migration/savevm.c:950
+ * #2  0x0000555555f1e5c6 in device_set_realized (obj=0x555558383c50, value=true, errp=0x7fffffffd370) at ../hw/core/qdev.c:517
+ * #3  0x0000555555f2940c in property_set_bool (obj=0x555558383c50, v=0x5555583865c0, name=0x5555563e9b29 "realized", opaque=0x555557461090, errp=0x7fffffffd370) at ../qom/object.c:2374
+ * #4  0x0000555555f26e81 in object_property_set (obj=0x555558383c50, name=0x5555563e9b29 "realized", v=0x5555583865c0, errp=0x7fffffffd370) at ../qom/object.c:1449
+ * #5  0x0000555555f2bd0e in object_property_set_qobject (obj=0x555558383c50, name=0x5555563e9b29 "realized", value=0x5555583865a0, errp=0x7fffffffd370) at ../qom/qom-qobject.c:28
+ * #6  0x0000555555f27226 in object_property_set_bool (obj=0x555558383c50, name=0x5555563e9b29 "realized", value=true, errp=0x7fffffffd370) at ../qom/object.c:1519
+ * #7  0x0000555555f1db85 in qdev_realize (dev=0x555558383c50, bus=0x555558383bd0, errp=0x7fffffffd370) at ../hw/core/qdev.c:276
+ * #8  0x0000555555eae272 in virtio_scsi_pci_realize (vpci_dev=0x55555837b6b0, errp=0x7fffffffd370) at ../hw/virtio/virtio-scsi-pci.c:72
+ * #9  0x0000555555bc9d2d in virtio_pci_realize (pci_dev=0x55555837b6b0, errp=0x7fffffffd370) at ../hw/virtio/virtio-pci.c:2265
+ * #10 0x0000555555ad0fd6 in pci_qdev_realize (qdev=0x55555837b6b0, errp=0x7fffffffd430) at ../hw/pci/pci.c:2307
+ * #11 0x0000555555bca24e in virtio_pci_dc_realize (qdev=0x55555837b6b0, errp=0x7fffffffd430) at ../hw/virtio/virtio-pci.c:2391
+ * #12 0x0000555555f1e48d in device_set_realized (obj=0x55555837b6b0, value=true, errp=0x7fffffffd6c0) at ../hw/core/qdev.c:494
+ * #13 0x0000555555f2940c in property_set_bool (obj=0x55555837b6b0, v=0x5555583859b0, name=0x5555563e9b29 "realized", opaque=0x555557461090, errp=0x7fffffffd6c0) at ../qom/object.c:2374
+ * #14 0x0000555555f26e81 in object_property_set (obj=0x55555837b6b0, name=0x5555563e9b29 "realized", v=0x5555583859b0, errp=0x7fffffffd6c0) at ../qom/object.c:1449
+ * #15 0x0000555555f2bd0e in object_property_set_qobject (obj=0x55555837b6b0, name=0x5555563e9b29 "realized", value=0x5555583858f0, errp=0x7fffffffd6c0) at ../qom/qom-qobject.c:28
+ * #16 0x0000555555f27226 in object_property_set_bool (obj=0x55555837b6b0, name=0x5555563e9b29 "realized", value=true, errp=0x7fffffffd6c0) at ../qom/object.c:1519
+ * #17 0x0000555555f1db85 in qdev_realize (dev=0x55555837b6b0, bus=0x5555578dd660, errp=0x7fffffffd6c0) at ../hw/core/qdev.c:276
+ * #18 0x0000555555c267b7 in qdev_device_add_from_qdict (opts=0x55555837a690, from_json=false, errp=0x7fffffffd6c0) at ../system/qdev-monitor.c:714
+ * #19 0x0000555555c2686b in qdev_device_add (opts=0x55555745e180, errp=0x5555573a2120 <error_fatal>) at ../system/qdev-monitor.c:733
+ * #20 0x0000555555c31431 in device_init_func (opaque=0x0, opts=0x55555745e180, errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:1209
+ * #21 0x00005555561b93cf in qemu_opts_foreach (list=0x5555572894a0 <qemu_device_opts>, func=0x555555c31402 <device_init_func>, opaque=0x0, errp=0x5555573a2120 <error_fatal>) at ../util/qemu-option.c:1135
+ * #22 0x0000555555c3575b in qemu_create_cli_devices () at ../system/vl.c:2747
+ * #23 0x0000555555c359a6 in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2808
+ * #24 0x0000555555c384cb in qemu_init (argc=25, argv=0x7fffffffdae8) at ../system/vl.c:3843
+ * #25 0x00005555560d2b7f in main (argc=25, argv=0x7fffffffdae8) at ../system/main.c:71i
+ *
+ * savevm_state_handler_insert() nse->idstr=smbus-eeprom
+ * savevm_state_handler_insert() nse->idstr=smbus-eeprom
+ * savevm_state_handler_insert() nse->idstr=smbus-eeprom
+ * savevm_state_handler_insert() nse->idstr=smbus-eeprom
+ * savevm_state_handler_insert() nse->idstr=smbus-eeprom
+ * savevm_state_handler_insert() nse->idstr=smbus-eeprom
+ * savevm_state_handler_insert() nse->idstr=smbus-eeprom
+ * savevm_state_handler_insert() nse->idstr=smbus-eeprom
+ * savevm_state_handler_insert() nse->idstr=0000:00:01.0/vga
+ * savevm_state_handler_insert() nse->idstr=0000:00:02.0/e1000e
+ * savevm_state_handler_insert() nse->idstr=0000:00:05.0/pcie-root-port
+ * savevm_state_handler_insert() nse->idstr=PCIBUS
+ * savevm_state_handler_insert() nse->idstr=0000:00:05.1/pcie-root-port
+ * savevm_state_handler_insert() nse->idstr=PCIBUS
+ * savevm_state_handler_insert() nse->idstr=0000:00:05.2/pcie-root-port
+ * savevm_state_handler_insert() nse->idstr=PCIBUS
+ * savevm_state_handler_insert() nse->idstr=0000:00:05.3/pcie-root-port
+ * savevm_state_handler_insert() nse->idstr=PCIBUS
+ * savevm_state_handler_insert() nse->idstr=0000:00:05.4/pcie-root-port
+ * savevm_state_handler_insert() nse->idstr=PCIBUS
+ * savevm_state_handler_insert() nse->idstr=0000:00:05.5/pcie-root-port
+ * savevm_state_handler_insert() nse->idstr=PCIBUS
+ * savevm_state_handler_insert() nse->idstr=0000:00:05.6/pcie-root-port
+ * savevm_state_handler_insert() nse->idstr=PCIBUS
+ * savevm_state_handler_insert() nse->idstr=0000:00:05.7/pcie-root-port
+ * savevm_state_handler_insert() nse->idstr=PCIBUS
+ * savevm_state_handler_insert() nse->idstr=acpi_build
+ * savevm_state_handler_insert() nse->idstr=globalstate
+ * savevm_state_handler_insert() nse->idstr=audio
+ *
+ * 在以下使用savevm_state_handler_insert():
+ *   - migration/savevm.c|931| <<register_savevm_live>> savevm_state_handler_insert(se);
+ *   - migration/savevm.c|1047| <<vmstate_register_with_alias_id>> savevm_state_handler_insert(se);
+ */
 static void savevm_state_handler_insert(SaveStateEntry *nse)
 {
     MigrationPriority priority = save_state_priority(nse);
@@ -824,6 +974,11 @@ int register_savevm_live(const char *idstr,
     pstrcat(se->idstr, sizeof(se->idstr), idstr);
 
     if (instance_id == VMSTATE_INSTANCE_ID_ANY) {
+        /*
+	 * 在以下使用calculate_new_instance_id():
+	 *   - migration/savevm.c|930| <<register_savevm_live>> se->instance_id = calculate_new_instance_id(se->idstr);
+	 *   - migration/savevm.c|1041| <<vmstate_register_with_alias_id>> se->instance_id = calculate_new_instance_id(se->idstr);
+	 */
         se->instance_id = calculate_new_instance_id(se->idstr);
     } else {
         se->instance_id = instance_id;
@@ -894,6 +1049,15 @@ static void vmstate_check(const VMStateDescription *vmsd)
 }
 
 
+/*
+ * 在以下使用vmstate_register_with_alias_id():
+ *   -  hw/core/qdev.c|517| <<device_set_realized>> if (vmstate_register_with_alias_id(VMSTATE_IF(dev),
+ *              VMSTATE_INSTANCE_ID_ANY, qdev_get_vmsd(dev), dev, dev->instance_id_alias,
+ *              dev->alias_required_for_version, &local_err) < 0) {
+ *   - hw/intc/apic_common.c|303| <<apic_common_realize>> vmstate_register_with_alias_id(NULL, instance_id, &vmstate_apic_common, s, -1, 0, NULL);
+ *   - include/migration/vmstate.h|1228| <<vmstate_register>> return vmstate_register_with_alias_id(obj, instance_id, vmsd, opaque, -1, 0, NULL);
+ *   - include/migration/vmstate.h|1256| <<vmstate_register_any>> return vmstate_register_with_alias_id(obj, VMSTATE_INSTANCE_ID_ANY, vmsd, opaque, -1, 0, NULL);
+ */
 int vmstate_register_with_alias_id(VMStateIf *obj, uint32_t instance_id,
                                    const VMStateDescription *vmsd,
                                    void *opaque, int alias_id,
@@ -935,6 +1099,11 @@ int vmstate_register_with_alias_id(VMStateIf *obj, uint32_t instance_id,
     pstrcat(se->idstr, sizeof(se->idstr), vmsd->name);
 
     if (instance_id == VMSTATE_INSTANCE_ID_ANY) {
+        /*
+	 * 在以下使用calculate_new_instance_id():
+	 *   - migration/savevm.c|930| <<register_savevm_live>> se->instance_id = calculate_new_instance_id(se->idstr);
+	 *   - migration/savevm.c|1041| <<vmstate_register_with_alias_id>> se->instance_id = calculate_new_instance_id(se->idstr);
+	 */
         se->instance_id = calculate_new_instance_id(se->idstr);
     } else {
         se->instance_id = instance_id;
@@ -1274,6 +1443,12 @@ void qemu_savevm_non_migratable_list(strList **reasons)
     }
 }
 
+/*
+ * 在以下使用qemu_savevm_state_header():
+ *   - migration/migration.c|3669| <<migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+ *   - migration/migration.c|3828| <<bg_migration_thread>> qemu_savevm_state_header(s->to_dst_file);
+ *   - migration/savevm.c|1862| <<qemu_savevm_state>> qemu_savevm_state_header(f);
+ */
 void qemu_savevm_state_header(QEMUFile *f)
 {
     MigrationState *s = migrate_get_current();
@@ -1613,6 +1788,16 @@ int qemu_savevm_state_complete_precopy_non_iterable(QEMUFile *f,
     Error *local_err = NULL;
     int ret;
 
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1741| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1792| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1989| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|515| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2127| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     /* Making sure cpu states are synchronized before saving non-iterable */
     cpu_synchronize_all_states();
 
@@ -1811,6 +1996,16 @@ int qemu_save_device_state(QEMUFile *f)
         qemu_put_be32(f, QEMU_VM_FILE_MAGIC);
         qemu_put_be32(f, QEMU_VM_FILE_VERSION);
     }
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1741| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1792| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1989| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|515| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2127| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
 
     QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {
diff --git a/migration/vmstate-types.c b/migration/vmstate-types.c
index 741a588b7..d61bff77c 100644
--- a/migration/vmstate-types.c
+++ b/migration/vmstate-types.c
@@ -22,6 +22,50 @@
 
 /* bool */
 
+/*
+ * // VMStateInfo allows customized migration of objects that don't fit in
+ * // any category in VMStateFlags. Additional information is always passed
+ * // into get and put in terms of field and vmdesc parameters. However
+ * // these two parameters should only be used in cases when customized
+ * // handling is needed, such as QTAILQ. For primitive data types such as
+ * // integer, field and vmdesc parameters should be ignored inside get/put.
+ *
+ * struct VMStateInfo {
+ *     const char *name;
+ *     int coroutine_mixed_fn (*get)(QEMUFile *f, void *pv, size_t size,
+ *                                   const VMStateField *field);
+ *     int coroutine_mixed_fn (*put)(QEMUFile *f, void *pv, size_t size,
+ *                                   const VMStateField *field,
+ *                                   JSONWriter *vmdesc);
+ * };
+ *
+ *
+ * struct VMStateField {
+ *     const char *name;
+ *     const char *err_hint;
+ *     size_t offset;
+ *     size_t size;
+ *     size_t start;
+ *     int num;
+ *     size_t num_offset;
+ *     size_t size_offset;
+ *     const VMStateInfo *info;
+ *     enum VMStateFlags flags;
+ *     const VMStateDescription *vmsd;
+ *     int version_id;
+ *     int struct_version_id;
+ *     bool (*field_exists)(void *opaque, int version_id);
+ * };
+ *
+ *
+ * struct JSONWriter {
+ *     bool pretty;
+ *     bool need_comma;
+ *     GString *contents;
+ *     GByteArray *container_is_array;
+ * };
+ */
+
 static int get_bool(QEMUFile *f, void *pv, size_t size,
                     const VMStateField *field)
 {
@@ -38,6 +82,14 @@ static int put_bool(QEMUFile *f, void *pv, size_t size,
     return 0;
 }
 
+/*
+ * 在以下使用vmstate_info_bool:
+ *   - hw/core/or-irq.c|99| <<global>> vmstate_info_bool, bool),
+ *   - include/migration/vmstate.h|886| <<VMSTATE_BOOL_V>> VMSTATE_SINGLE(_f, _s, _v, vmstate_info_bool, bool)
+ *   - include/migration/vmstate.h|993| <<VMSTATE_BOOL_TEST>> VMSTATE_SINGLE_TEST(_f, _s, _t, 0, vmstate_info_bool, bool)
+ *   - include/migration/vmstate.h|1047| <<VMSTATE_BOOL_ARRAY_V>> VMSTATE_ARRAY(_f, _s, _n, _v, vmstate_info_bool, bool)
+ *   - include/migration/vmstate.h|1053| <<VMSTATE_BOOL_SUB_ARRAY>> VMSTATE_SUB_ARRAY(_f, _s, _start, _num, 0, vmstate_info_bool, bool)
+ */
 const VMStateInfo vmstate_info_bool = {
     .name = "bool",
     .get  = get_bool,
@@ -413,6 +465,10 @@ static int get_uint8_equal(QEMUFile *f, void *pv, size_t size,
     return -EINVAL;
 }
 
+/*
+ * 在以下使用vmstate_info_uint8_equal:
+ *   - include/migration/vmstate.h|961| <<VMSTATE_UINT8_EQUAL>> vmstate_info_uint8_equal, uint8_t, _err_hint)
+ */
 const VMStateInfo vmstate_info_uint8_equal = {
     .name = "uint8 equal",
     .get  = get_uint8_equal,
@@ -439,6 +495,12 @@ static int get_uint16_equal(QEMUFile *f, void *pv, size_t size,
     return -EINVAL;
 }
 
+/*
+ * 在以下使用vmstate_info_uint16_equal:
+ *   - hw/net/virtio-net.c|3495| <<global>> vmstate_info_uint16_equal, uint16_t),
+ *   - include/migration/vmstate.h|965| <<VMSTATE_UINT16_EQUAL>> vmstate_info_uint16_equal, uint16_t, _err_hint)
+ *   - include/migration/vmstate.h|969| <<VMSTATE_UINT16_EQUAL_V>> vmstate_info_uint16_equal, uint16_t, _err_hint)
+ */
 const VMStateInfo vmstate_info_uint16_equal = {
     .name = "uint16 equal",
     .get  = get_uint16_equal,
@@ -465,6 +527,10 @@ static int put_cpudouble(QEMUFile *f, void *pv, size_t size,
     return 0;
 }
 
+/*
+ * 在以下使用vmstate_info_cpudouble:
+ *   - include/migration/vmstate.h|1134| <<VMSTATE_CPUDOUBLE_ARRAY_V>> VMSTATE_ARRAY(_f, _s, _n, _v, vmstate_info_cpudouble, CPU_DoubleU)
+ */
 const VMStateInfo vmstate_info_cpudouble = {
     .name = "CPU_Double_U",
     .get  = get_cpudouble,
@@ -489,6 +555,17 @@ static int put_buffer(QEMUFile *f, void *pv, size_t size,
     return 0;
 }
 
+/*
+ * 在以下使用vmstate_info_buffer:
+ *   - include/migration/vmstate.h|643| <<VMSTATE_STATIC_BUFFER>> .info = &vmstate_info_buffer, \
+ *   - include/migration/vmstate.h|655| <<VMSTATE_VBUFFER_MULTIPLY>> .info = &vmstate_info_buffer, \
+ *   - include/migration/vmstate.h|665| <<VMSTATE_VBUFFER>> .info = &vmstate_info_buffer, \
+ *   - include/migration/vmstate.h|675| <<VMSTATE_VBUFFER_UINT32>> .info = &vmstate_info_buffer, \
+ *   - include/migration/vmstate.h|686| <<VMSTATE_VBUFFER_ALLOC_UINT32>> .info = &vmstate_info_buffer, \
+ *   - include/migration/vmstate.h|705| <<VMSTATE_BUFFER_POINTER_UNSAFE>> .info = &vmstate_info_buffer, \
+ *   - include/migration/vmstate.h|1164| <<VMSTATE_BUFFER_UNSAFE>> VMSTATE_BUFFER_UNSAFE_INFO(_field, _state, _version, vmstate_info_buffer, _size)
+ *   - include/net/net.h|327| <<VMSTATE_MACADDR>> .info = &vmstate_info_buffer, \
+ */
 const VMStateInfo vmstate_info_buffer = {
     .name = "buffer",
     .get  = get_buffer,
@@ -527,6 +604,11 @@ static int put_unused_buffer(QEMUFile *f, void *pv, size_t size,
     return 0;
 }
 
+/*
+ * 在以下使用vmstate_info_unused_buffer:
+ *   - include/migration/vmstate.h|737| <<VMSTATE_UNUSED_BUFFER>> .info = &vmstate_info_unused_buffer, \
+ *   - include/migration/vmstate.h|748| <<VMSTATE_UNUSED_VARRAY_UINT32>> .info = &vmstate_info_unused_buffer, \
+ */
 const VMStateInfo vmstate_info_unused_buffer = {
     .name = "unused_buffer",
     .get  = get_unused_buffer,
@@ -569,6 +651,10 @@ static int put_tmp(QEMUFile *f, void *pv, size_t size,
     return ret;
 }
 
+/*
+ * 在以下使用vmstate_info_tmp:
+ *   - include/migration/vmstate.h|726| <<VMSTATE_WITH_TMP_TEST>> .info = &vmstate_info_tmp, \
+ */
 const VMStateInfo vmstate_info_tmp = {
     .name = "tmp",
     .get = get_tmp,
@@ -613,6 +699,10 @@ static int put_bitmap(QEMUFile *f, void *pv, size_t size,
     return 0;
 }
 
+/*
+ * 在以下使用vmstate_info_bitmap:
+ *   - include/migration/vmstate.h|760| <<VMSTATE_BITMAP_TEST>> .info = &vmstate_info_bitmap, \
+ */
 const VMStateInfo vmstate_info_bitmap = {
     .name = "bitmap",
     .get = get_bitmap,
@@ -685,6 +775,10 @@ static int put_qtailq(QEMUFile *f, void *pv, size_t unused_size,
 
     return 0;
 }
+/*
+ * 在以下使用vmstate_info_qtailq:
+ *   - include/migration/vmstate.h|782| <<VMSTATE_QTAILQ_V>> .info = &vmstate_info_qtailq, \
+ */
 const VMStateInfo vmstate_info_qtailq = {
     .name = "qtailq",
     .get  = get_qtailq,
@@ -699,6 +793,10 @@ struct put_gtree_data {
     int ret;
 };
 
+/*
+ * 在以下使用put_gtree_elem:
+ *   - migration/vmstate-types.c|750| <<put_gtree>> g_tree_foreach(tree, put_gtree_elem, (gpointer)&capsule);
+ */
 static gboolean put_gtree_elem(gpointer key, gpointer value, gpointer data)
 {
     struct put_gtree_data *capsule = (struct put_gtree_data *)data;
@@ -837,6 +935,11 @@ key_error:
 }
 
 
+/*
+ * 在以下使用vmstate_info_gtree:
+ *   - include/migration/vmstate.h|802| <<VMSTATE_GTREE_V>> .info = &vmstate_info_gtree, \
+ *   - include/migration/vmstate.h|820| <<VMSTATE_GTREE_DIRECT_KEY_V>> .info = &vmstate_info_gtree, \
+ */
 const VMStateInfo vmstate_info_gtree = {
     .name = "gtree",
     .get  = get_gtree,
@@ -911,6 +1014,10 @@ static int get_qlist(QEMUFile *f, void *pv, size_t unused_size,
     return ret;
 }
 
+/*
+ * 在以下使用vmstate_info_qlist:
+ *   - include/migration/vmstate.h|841| <<VMSTATE_QLIST_V>> .info = &vmstate_info_qlist, \
+ */
 const VMStateInfo vmstate_info_qlist = {
     .name = "qlist",
     .get  = get_qlist,
diff --git a/migration/vmstate.c b/migration/vmstate.c
index 5feaa3244..e79877ced 100644
--- a/migration/vmstate.c
+++ b/migration/vmstate.c
@@ -383,22 +383,112 @@ bool vmstate_section_needed(const VMStateDescription *vmsd, void *opaque)
 }
 
 
+/*
+ * 在以下使用vmstate_save_state():
+ *   - hw/display/virtio-gpu.c|1249| <<virtio_gpu_save>> return vmstate_save_state(f, &vmstate_virtio_gpu_scanouts, g, NULL);
+ *   - hw/pci/pci.c|1059| <<pci_device_save>> vmstate_save_state(f, &vmstate_pci_device, s, NULL);
+ *   - hw/s390x/virtio-ccw.c|1133| <<virtio_ccw_save_config>> vmstate_save_state(f, &vmstate_virtio_ccw_dev, dev, NULL);
+ *   - hw/scsi/spapr_vscsi.c|633| <<vscsi_save_request>> vmstate_save_state(f, &vmstate_spapr_vscsi_req, req, NULL);
+ *   - hw/virtio/virtio-mmio.c|615| <<virtio_mmio_save_extra_state>> vmstate_save_state(f, &vmstate_virtio_mmio, proxy, NULL);
+ *   - hw/virtio/virtio-pci.c|158| <<virtio_pci_save_extra_state>> vmstate_save_state(f, &vmstate_virtio_pci, proxy, NULL);
+ *   - hw/virtio/virtio.c|3061| <<virtio_save>> int ret = vmstate_save_state(f, vdc->vmsd, vdev, NULL);
+ *   - hw/virtio/virtio.c|3068| <<virtio_save>> return vmstate_save_state(f, &vmstate_virtio, vdev, NULL);
+ *   - migration/cpr.c|161| <<cpr_state_save>> ret = vmstate_save_state(f, &vmstate_cpr_state, &cpr_state, 0);
+ *   - migration/savevm.c|1402| <<qemu_savevm_state_header>> vmstate_save_state(f, &vmstate_configuration, &savevm_state, vmdesc);
+ *   - migration/vmstate-types.c|566| <<put_tmp>> ret = vmstate_save_state(f, vmsd, tmp, vmdesc);
+ *   - migration/vmstate-types.c|677| <<put_qtailq>> ret = vmstate_save_state(f, vmsd, elm, vmdesc);
+ *   - migration/vmstate-types.c|714| <<put_gtree_elem>> ret = vmstate_save_state(f, capsule->key_vmsd, key, capsule->vmdesc);
+ *   - migration/vmstate-types.c|722| <<put_gtree_elem>> ret = vmstate_save_state(f, capsule->val_vmsd, value, capsule->vmdesc);
+ *   - migration/vmstate-types.c|858| <<put_qlist>> ret = vmstate_save_state(f, vmsd, elm, vmdesc);
+ *   - migration/vmstate.c|492| <<vmstate_save_state_v>> ret = vmstate_save_state(f, inner_field->vmsd, curr_elem, vmdesc_loop);
+ *   - tests/unit/test-vmstate.c|71| <<save_vmstate>> int ret = vmstate_save_state(f, desc, obj, NULL);
+ *   - tests/unit/test-vmstate.c|431| <<test_save_noskip>> int ret = vmstate_save_state(fsave, &vmstate_skipping, &obj, NULL);
+ *   - tests/unit/test-vmstate.c|453| <<test_save_skip>> int ret = vmstate_save_state(fsave, &vmstate_skipping, &obj, NULL);
+ */
 int vmstate_save_state(QEMUFile *f, const VMStateDescription *vmsd,
                        void *opaque, JSONWriter *vmdesc_id)
 {
+    /*
+     * 在以下使用vmstate_save_state_v():
+     *   - migration/vmstate.c|389| <<vmstate_save_state>> return vmstate_save_state_v(f, vmsd, opaque, vmdesc_id, vmsd->version_id, NULL);
+     *   - migration/vmstate.c|395| <<vmstate_save_state_with_err>> return vmstate_save_state_v(f, vmsd, opaque, vmdesc_id, vmsd->version_id, errp);
+     *   - migration/vmstate.c|495| <<vmstate_save_state_v>> ret = vmstate_save_state_v(f, inner_field->vmsd,
+     */
     return vmstate_save_state_v(f, vmsd, opaque, vmdesc_id, vmsd->version_id, NULL);
 }
 
 int vmstate_save_state_with_err(QEMUFile *f, const VMStateDescription *vmsd,
                        void *opaque, JSONWriter *vmdesc_id, Error **errp)
 {
+    /*
+     * 在以下使用vmstate_save_state_v():
+     *   - migration/vmstate.c|389| <<vmstate_save_state>> return vmstate_save_state_v(f, vmsd, opaque, vmdesc_id, vmsd->version_id, NULL);
+     *   - migration/vmstate.c|395| <<vmstate_save_state_with_err>> return vmstate_save_state_v(f, vmsd, opaque, vmdesc_id, vmsd->version_id, errp);
+     *   - migration/vmstate.c|495| <<vmstate_save_state_v>> ret = vmstate_save_state_v(f, inner_field->vmsd,
+     */
     return vmstate_save_state_v(f, vmsd, opaque, vmdesc_id, vmsd->version_id, errp);
 }
 
+/*
+ * 184 struct VMStateDescription {
+ * 185     const char *name;
+ * 186     bool unmigratable;
+ * 187     //
+ * 188      * This VMSD describes something that should be sent during setup phase
+ * 189      * of migration. It plays similar role as save_setup() for explicitly
+ * 190      * registered vmstate entries, so it can be seen as a way to describe
+ * 191      * save_setup() in VMSD structures.
+ * 192      *
+ * 193      * Note that for now, a SaveStateEntry cannot have a VMSD and
+ * 194      * operations (e.g., save_setup()) set at the same time. Consequently,
+ * 195      * save_setup() and a VMSD with early_setup set to true are mutually
+ * 196      * exclusive. For this reason, also early_setup VMSDs are migrated in a
+ * 197      * QEMU_VM_SECTION_FULL section, while save_setup() data is migrated in
+ * 198      * a QEMU_VM_SECTION_START section.
+ * 199      //
+ * 200     bool early_setup;
+ * 201     int version_id;
+ * 202     int minimum_version_id;
+ * 203     MigrationPriority priority;
+ * 204     int (*pre_load)(void *opaque);
+ * 205     int (*post_load)(void *opaque, int version_id);
+ * 206     int (*pre_save)(void *opaque);
+ * 207     int (*post_save)(void *opaque);
+ * 208     bool (*needed)(void *opaque);
+ * 209     bool (*dev_unplug_pending)(void *opaque);
+ * 210 
+ * 211     const VMStateField *fields;
+ * 212     const VMStateDescription * const *subsections;
+ * 213 };
+ *
+ *
+ * 在以下使用vmstate_save_state_v():
+ *   - migration/vmstate.c|389| <<vmstate_save_state>> return vmstate_save_state_v(f, vmsd, opaque, vmdesc_id, vmsd->version_id, NULL);
+ *   - migration/vmstate.c|395| <<vmstate_save_state_with_err>> return vmstate_save_state_v(f, vmsd, opaque, vmdesc_id, vmsd->version_id, errp);
+ *   - migration/vmstate.c|495| <<vmstate_save_state_v>> ret = vmstate_save_state_v(f, inner_field->vmsd,
+ */
 int vmstate_save_state_v(QEMUFile *f, const VMStateDescription *vmsd,
                          void *opaque, JSONWriter *vmdesc, int version_id, Error **errp)
 {
     int ret = 0;
+    /*
+     * struct VMStateField {
+     *     const char *name;
+     *     const char *err_hint;
+     *     size_t offset;
+     *     size_t size;
+     *     size_t start;
+     *     int num;
+     *     size_t num_offset;
+     *     size_t size_offset;
+     *     const VMStateInfo *info;
+     *     enum VMStateFlags flags;
+     *     const VMStateDescription *vmsd;
+     *     int version_id;
+     *     int struct_version_id;
+     *     bool (*field_exists)(void *opaque, int version_id);
+     * };
+     */
     const VMStateField *field = vmsd->fields;
 
     trace_vmstate_save_state_top(vmsd->name);
@@ -412,6 +502,14 @@ int vmstate_save_state_v(QEMUFile *f, const VMStateDescription *vmsd,
         }
     }
 
+    /*
+     * struct JSONWriter {
+     *     bool pretty;
+     *     bool need_comma;
+     *     GString *contents;
+     *     GByteArray *container_is_array;
+     * };
+     */
     if (vmdesc) {
         json_writer_str(vmdesc, "vmsd_name", vmsd->name);
         json_writer_int64(vmdesc, "version", version_id);
@@ -492,11 +590,34 @@ int vmstate_save_state_v(QEMUFile *f, const VMStateDescription *vmsd,
                     ret = vmstate_save_state(f, inner_field->vmsd,
                                              curr_elem, vmdesc_loop);
                 } else if (inner_field->flags & VMS_VSTRUCT) {
+                    /*
+		     * 在以下使用vmstate_save_state_v():
+		     *   - migration/vmstate.c|389| <<vmstate_save_state>> return vmstate_save_state_v(f, vmsd, opaque, vmdesc_id, vmsd->version_id, NULL);
+		     *   - migration/vmstate.c|395| <<vmstate_save_state_with_err>> return vmstate_save_state_v(f, vmsd, opaque, vmdesc_id, vmsd->version_id, errp);
+		     *   - migration/vmstate.c|495| <<vmstate_save_state_v>> ret = vmstate_save_state_v(f, inner_field->vmsd,
+		     */
                     ret = vmstate_save_state_v(f, inner_field->vmsd,
                                                curr_elem, vmdesc_loop,
                                                inner_field->struct_version_id,
                                                errp);
                 } else {
+                    /*
+		     * 77 static int put_bool(QEMUFile *f, void *pv, size_t size,
+		     * 78                     const VMStateField *field, JSONWriter *vmdesc)
+		     * 79 {
+		     * 80     bool *v = pv;
+		     * 81     qemu_put_byte(f, *v);
+		     * 82     return 0;
+		     * 83 }
+		     *
+		     * 3072 static int virtio_device_put(QEMUFile *f, void *opaque, size_t size,
+		     * 3073                               const VMStateField *field, JSONWriter *vmdesc)
+		     * 3074 {
+		     * 3075     return virtio_save(VIRTIO_DEVICE(opaque), f);
+		     * 3076 }
+		     *
+		     * 这里是put!
+		     */
                     ret = inner_field->info->put(f, curr_elem, size,
                                                  inner_field, vmdesc_loop);
                 }
diff --git a/net/slirp.c b/net/slirp.c
index 9657e86a8..94153ffef 100644
--- a/net/slirp.c
+++ b/net/slirp.c
@@ -423,6 +423,10 @@ static SaveVMHandlers savevm_slirp_state = {
     .load_state = net_slirp_state_load,
 };
 
+/*
+ * 在以下调用net_slirp_init():
+ *   - net/slirp.c|1223| <<net_init_slirp>> ret = net_slirp_init(peer, "user", name, user->q_restrict,
+ */
 static int net_slirp_init(NetClientState *peer, const char *model,
                           const char *name, int restricted,
                           bool ipv4, const char *vnetwork, const char *vhost,
@@ -672,6 +676,10 @@ static int net_slirp_init(NetClientState *peer, const char *model,
     register_savevm_live("slirp", VMSTATE_INSTANCE_ID_ANY,
                          slirp_state_version(), &savevm_slirp_state, s->slirp);
 
+    /*
+     * 只在以下调用main_loop_poll_add_notifier():
+     *   - net/slirp.c|676| <<net_slirp_init>> main_loop_poll_add_notifier(&s->poll_notifier);
+     */
     s->poll_notifier.notify = net_slirp_poll_notify;
     main_loop_poll_add_notifier(&s->poll_notifier);
 
diff --git a/system/cpus.c b/system/cpus.c
index 2cc5f887a..d5d6e217a 100644
--- a/system/cpus.c
+++ b/system/cpus.c
@@ -131,33 +131,98 @@ void hw_error(const char *fmt, ...)
     abort();
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_states():
+ *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+ *   - hw/i386/pc.c|1741| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+ *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+ *   - migration/savevm.c|1792| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+ *   - migration/savevm.c|1989| <<qemu_save_device_state>> cpu_synchronize_all_states();
+ *   - system/runstate.c|515| <<qemu_system_reset>> cpu_synchronize_all_states();
+ *   - target/arm/hvf/hvf.c|2127| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+ */
 void cpu_synchronize_all_states(void)
 {
     CPUState *cpu;
 
     CPU_FOREACH(cpu) {
+        /*
+	 * 特别多的地方调用cpu_synchronize_state(), 下面只是一些例子:
+         *   - hw/core/cpu-common.c|103| <<cpu_dump_state>> cpu_synchronize_state(cpu);
+         *   - hw/i386/kvm/apic.c|331| <<do_inject_external_nmi>> cpu_synchronize_state(cpu);
+         *   - hw/i386/kvm/clock.c|77| <<kvmclock_current_nsec>> cpu_synchronize_state(cpu);
+         *   - hw/i386/vapic.c|508| <<vapic_report_tpr_access>> cpu_synchronize_state(cs);
+	 *   - hw/i386/vapic.c|684| <<vapic_write>> cpu_synchronize_state(current_cpu);
+	 *   - w/i386/vmport.c|107| <<vmport_ioport_read>> cpu_synchronize_state(cs);
+	 *   -  monitor/hmp-cmds-target.c|71| <<mon_get_cpu_sync>> cpu_synchronize_state(cpu);
+	 *   - system/cpus.c|139| <<cpu_synchronize_all_states>> cpu_synchronize_state(cpu);
+	 *   - system/physmem.c|3879| <<cpu_memory_rw_debug>> cpu_synchronize_state(cpu);
+	 *   - target/i386/cpu-apic.c|144| <<hmp_info_local_apic>> cpu_synchronize_state(cs);
+	 *   - target/i386/helper.c|393| <<do_inject_x86_mce>> cpu_synchronize_state(cs);
+         *   - target/i386/kvm/kvm.c|724| <<kvm_mce_inject>> cpu_synchronize_state(cs);
+         *   - target/i386/kvm/kvm.c|5910| <<kvm_handle_debug>> cpu_synchronize_state(cs);
+	 */
         cpu_synchronize_state(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_post_reset():
+ *   - hw/i386/pc.c|1743| <<pc_machine_wakeup>> cpu_synchronize_all_post_reset();
+ *   system/runstate.c|546| <<qemu_system_reset>> cpu_synchronize_all_post_reset();
+ */
 void cpu_synchronize_all_post_reset(void)
 {
     CPUState *cpu;
 
     CPU_FOREACH(cpu) {
+        /*
+	 * 在以下使用cpu_synchronize_post_reset():
+         *   - system/cpus.c|179| <<cpu_synchronize_all_post_reset>> cpu_synchronize_post_reset(cpu);
+         *   - target/s390x/sigp.c|259| <<sigp_initial_cpu_reset>> cpu_synchronize_post_reset(cs);
+         *   - target/s390x/sigp.c|269| <<sigp_cpu_reset>> cpu_synchronize_post_reset(cs);
+	 */
         cpu_synchronize_post_reset(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_all_post_init():
+ *   - hw/core/machine.c|1728| <<qdev_machine_creation_done>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|2368| <<loadvm_postcopy_handle_run_bh>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3332| <<qemu_loadvm_state>> cpu_synchronize_all_post_init();
+ *   - migration/savevm.c|3349| <<qemu_load_device_state>> cpu_synchronize_all_post_init();
+ */
 void cpu_synchronize_all_post_init(void)
 {
     CPUState *cpu;
 
     CPU_FOREACH(cpu) {
+        /*
+	 * 在以下使用cpu_synchronize_post_init():
+         *   - hw/core/cpu-common.c|222| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+         *   - system/cpus.c|164| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+         *   - target/s390x/gdbstub.c|92| <<cpu_write_ac_reg>> cpu_synchronize_post_init(env_cpu(env));
+         *   - target/s390x/gdbstub.c|210| <<cpu_write_c_reg>> cpu_synchronize_post_init(env_cpu(env));
+         *   - target/s390x/gdbstub.c|250| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+         *   - target/s390x/gdbstub.c|254| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+         *   - target/s390x/gdbstub.c|258| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+         *   - target/s390x/gdbstub.c|262| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+	 *   - target/s390x/gdbstub.c|302| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+	 *   - target/s390x/gdbstub.c|306| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+	 *   - target/s390x/gdbstub.c|310| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+	 *   - target/s390x/gdbstub.c|314| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+	 *   - target/s390x/gdbstub.c|342| <<cpu_write_gs_reg>> cpu_synchronize_post_init(env_cpu(env));
+	 *   - target/s390x/sigp.c|296| <<sigp_set_prefix>> cpu_synchronize_post_init(cs);
+	 */
         cpu_synchronize_post_init(cpu);
     }
 }
 
+/*
+ * 在以下调用cpu_synchronize_all_pre_loadvm():
+ *   - migration/savevm.c|3287| <<qemu_loadvm_state>> cpu_synchronize_all_pre_loadvm();
+ */
 void cpu_synchronize_all_pre_loadvm(void)
 {
     CPUState *cpu;
@@ -167,36 +232,174 @@ void cpu_synchronize_all_pre_loadvm(void)
     }
 }
 
+/*
+ * 特别多的地方调用cpu_synchronize_state(), 下面只是一些例子:
+ *   - hw/core/cpu-common.c|103| <<cpu_dump_state>> cpu_synchronize_state(cpu);
+ *   - hw/i386/kvm/apic.c|331| <<do_inject_external_nmi>> cpu_synchronize_state(cpu);
+ *   - hw/i386/kvm/clock.c|77| <<kvmclock_current_nsec>> cpu_synchronize_state(cpu);
+ *   - hw/i386/vapic.c|508| <<vapic_report_tpr_access>> cpu_synchronize_state(cs);
+ *   - hw/i386/vapic.c|684| <<vapic_write>> cpu_synchronize_state(current_cpu);
+ *   - hw/i386/vmport.c|107| <<vmport_ioport_read>> cpu_synchronize_state(cs);
+ *   - monitor/hmp-cmds-target.c|71| <<mon_get_cpu_sync>> cpu_synchronize_state(cpu);
+ *   - system/cpus.c|139| <<cpu_synchronize_all_states>> cpu_synchronize_state(cpu);
+ *   - system/physmem.c|3879| <<cpu_memory_rw_debug>> cpu_synchronize_state(cpu);
+ *   - target/i386/cpu-apic.c|144| <<hmp_info_local_apic>> cpu_synchronize_state(cs);
+ *   - target/i386/helper.c|393| <<do_inject_x86_mce>> cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|724| <<kvm_mce_inject>> cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5910| <<kvm_handle_debug>> cpu_synchronize_state(cs);
+ */
 void cpu_synchronize_state(CPUState *cpu)
 {
+    /*
+     * kvm_cpu_synchronize_state()
+     */
     if (cpus_accel->synchronize_state) {
         cpus_accel->synchronize_state(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_post_reset():
+ *   - system/cpus.c|179| <<cpu_synchronize_all_post_reset>> cpu_synchronize_post_reset(cpu);
+ *   - target/s390x/sigp.c|259| <<sigp_initial_cpu_reset>> cpu_synchronize_post_reset(cs);
+ *   - target/s390x/sigp.c|269| <<sigp_cpu_reset>> cpu_synchronize_post_reset(cs);
+ */
 void cpu_synchronize_post_reset(CPUState *cpu)
 {
+    /*
+     * 在以下使用cpus_accel->synchronize_post_reset:
+     *   - accel/hvf/hvf-accel-ops.c|588| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|129| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - system/cpus.c|269| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - system/cpus.c|270| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|91| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|94| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     if (cpus_accel->synchronize_post_reset) {
         cpus_accel->synchronize_post_reset(cpu);
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_post_init (cpu=0x5555577517f0) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c1d8cc in cpu_synchronize_post_init (cpu=0x5555577517f0) at ../system/cpus.c:187
+ * #2  0x0000555555c1d747 in cpu_synchronize_all_post_init () at ../system/cpus.c:157
+ * #3  0x000055555597d969 in qdev_machine_creation_done () at ../hw/core/machine.c:1720
+ * #4  0x0000555555c356ee in qemu_machine_creation_done (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2781
+ * #5  0x0000555555c3582d in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2809
+ * #6  0x0000555555c38346 in qemu_init (argc=21, argv=0x7fffffffdc28) at ../system/vl.c:3843
+ * #7  0x00005555560d2905 in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:71
+ *
+ *
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_post_init (cpu=0x55555775f620) at ../accel/kvm/kvm-all.c:2931
+ * #1  0x0000555555c1d8cc in cpu_synchronize_post_init (cpu=0x55555775f620) at ../system/cpus.c:187
+ * #2  0x000055555588ba76 in cpu_common_realizefn (dev=0x55555775f620, errp=0x7fffffffc318) at ../hw/core/cpu-common.c:219
+ * #3  0x0000555555daafd3 in x86_cpu_realizefn (dev=0x55555775f620, errp=0x7fffffffc3e0) at ../target/i386/cpu.c:8362
+ * #4  0x0000555555da3bf3 in max_x86_cpu_realize (dev=0x55555775f620, errp=0x7fffffffc3e0) at ../target/i386/cpu.c:5689
+ * #5  0x0000555555f1e213 in device_set_realized (obj=0x55555775f620, value=true, errp=0x7fffffffc700) at ../hw/core/qdev.c:494
+ * #6  0x0000555555f29192 in property_set_bool (obj=0x55555775f620, v=0x5555582cdbb0, name=0x5555563e9969 "realized",
+ *     opaque=0x555557460d40, errp=0x7fffffffc700) at ../qom/object.c:2374
+ * #7  0x0000555555f26c07 in object_property_set (obj=0x55555775f620, name=0x5555563e9969 "realized", v=0x5555582cdbb0,
+ *     errp=0x7fffffffc700) at ../qom/object.c:1449
+ * #8  0x0000555555f2ba94 in object_property_set_qobject (obj=0x55555775f620, name=0x5555563e9969 "realized", value=0x5555581a7830,
+ *     errp=0x7fffffffc700) at ../qom/qom-qobject.c:28
+ * #9  0x0000555555f26fac in object_property_set_bool (obj=0x55555775f620, name=0x5555563e9969 "realized", value=true,
+ *     errp=0x7fffffffc700) at ../qom/object.c:1519
+ * #10 0x0000555555f1d90b in qdev_realize (dev=0x55555775f620, bus=0x0, errp=0x7fffffffc700) at ../hw/core/qdev.c:276
+ * #11 0x0000555555c26632 in qdev_device_add_from_qdict (opts=0x5555577b5400, from_json=false, errp=0x7fffffffc700)
+ *     at ../system/qdev-monitor.c:714
+ * #12 0x0000555555c266e6 in qdev_device_add (opts=0x5555577a3620, errp=0x7fffffffc700) at ../system/qdev-monitor.c:733
+ * #13 0x0000555555c2730b in hmp_device_add (mon=0x5555576efc20, qdict=0x555557fd15d0) at ../system/qdev-monitor.c:994
+ * #14 0x0000555555c9118f in handle_hmp_command_exec (mon=0x5555576efc20, cmd=0x5555572ac020 <hmp_cmds+1920>, qdict=0x555557fd15d0)
+ *     at ../monitor/hmp.c:1106
+ * #15 0x0000555555c913da in handle_hmp_command (mon=0x5555576efc20, cmdline=0x555557711d7c
+ *     "host-x86_64-cpu,id=core2,socket-id=0,core-id=2,thread-id=0") at ../monitor/hmp.c:1158
+ * #16 0x0000555555c8e45f in monitor_command_cb (opaque=0x5555576efc20, cmdline=0x555557711d70
+ *     " device_add host-x86_64-cpu,id=core2,socket-id=0,core-id=2,thread-id=0", readline_opaque=0x0) at ../monitor/hmp.c:47
+ * #17 0x00005555561de895 in readline_handle_byte (rs=0x555557711d70, ch=13) at ../util/readline.c:427
+ * #18 0x0000555555c92031 in monitor_read (opaque=0x5555576efc20, buf=0x7fffffffc970 "\r", size=1) at ../monitor/hmp.c:1390
+ * #19 0x00005555560c7d61 in qemu_chr_be_write_impl (s=0x55555758df40, buf=0x7fffffffc970 "\r", len=1) at ../chardev/char.c:214
+ * #20 0x00005555560c7dd2 in qemu_chr_be_write (s=0x55555758df40, buf=0x7fffffffc970 "\r", len=1) at ../chardev/char.c:226
+ * #21 0x00005555560cadf1 in fd_chr_read (chan=0x5555576d6a00, cond=G_IO_IN, opaque=0x55555758df40) at ../chardev/char-fd.c:72
+ * #22 0x0000555555f8f8d0 in qio_channel_fd_source_dispatch (source=0x555557e71390, callback=0x5555560cac95 <fd_chr_read>,
+ *     user_data=0x55555758df40) at ../io/channel-watch.c:84
+ * #23 0x00007ffff6fd3854 in g_main_dispatch (context=0x55555745e9e0) at ../glib/gmain.c:3325
+ * #24 g_main_context_dispatch (context=0x55555745e9e0) at ../glib/gmain.c:4043
+ * #25 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #26 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=930966) at ../util/main-loop.c:310
+ * #27 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #28 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #29 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #30 0x00005555560d296f in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:80
+ *
+ *
+ * 在以下使用cpu_synchronize_post_init():
+ *   - hw/core/cpu-common.c|222| <<cpu_common_realizefn>> cpu_synchronize_post_init(cpu);
+ *   - system/cpus.c|164| <<cpu_synchronize_all_post_init>> cpu_synchronize_post_init(cpu);
+ *   - target/s390x/gdbstub.c|92| <<cpu_write_ac_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|210| <<cpu_write_c_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|250| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|254| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|258| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|262| <<cpu_write_virt_reg>> cpu_synchronize_post_init(cs);
+ *   - target/s390x/gdbstub.c|302| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|306| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|310| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|314| <<cpu_write_virt_kvm_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/gdbstub.c|342| <<cpu_write_gs_reg>> cpu_synchronize_post_init(env_cpu(env));
+ *   - target/s390x/sigp.c|296| <<sigp_set_prefix>> cpu_synchronize_post_init(cs);
+ */
 void cpu_synchronize_post_init(CPUState *cpu)
 {
+    /*
+     * 在以下使用cpus_accel->synchronize_post_init:
+     *   - accel/hvf/hvf-accel-ops.c|589| <<hvf_accel_ops_class_init>> ops->synchronize_post_init = hvf_cpu_synchronize_post_init;
+     *   - accel/kvm/kvm-accel-ops.c|130| <<kvm_accel_ops_class_init>> ops->synchronize_post_init = kvm_cpu_synchronize_post_init;
+     *   - system/cpus.c|314| <<cpu_synchronize_post_init>> if (cpus_accel->synchronize_post_init) {
+     *   - system/cpus.c|315| <<cpu_synchronize_post_init>> cpus_accel->synchronize_post_init(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|92| <<nvmm_accel_ops_class_init>> ops->synchronize_post_init = nvmm_cpu_synchronize_post_init;
+     *   - target/i386/whpx/whpx-accel-ops.c|95| <<whpx_accel_ops_class_init>> ops->synchronize_post_init = whpx_cpu_synchronize_post_init;
+     */
     if (cpus_accel->synchronize_post_init) {
         cpus_accel->synchronize_post_init(cpu);
     }
 }
 
+/*
+ * 在以下使用cpu_synchronize_pre_loadvm():
+ *   - system/cpus.c|204| <<cpu_synchronize_all_pre_loadvm>> cpu_synchronize_pre_loadvm(cpu);
+ */
 void cpu_synchronize_pre_loadvm(CPUState *cpu)
 {
+    /*
+     * 在以下使用cpu_accel->synchronize_pre_loadvm:
+     *   - accel/hvf/hvf-accel-ops.c|591| <<hvf_accel_ops_class_init>> ops->synchronize_pre_loadvm = hvf_cpu_synchronize_pre_loadvm;
+     *   - accel/kvm/kvm-accel-ops.c|147| <<kvm_accel_ops_class_init>> ops->synchronize_pre_loadvm = kvm_cpu_synchronize_pre_loadvm;
+     *   - system/cpus.c|321| <<cpu_synchronize_pre_loadvm>> if (cpus_accel->synchronize_pre_loadvm) {
+     *   - system/cpus.c|322| <<cpu_synchronize_pre_loadvm>> cpus_accel->synchronize_pre_loadvm(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|94| <<nvmm_accel_ops_class_init>> ops->synchronize_pre_loadvm = nvmm_cpu_synchronize_pre_loadvm;
+     *   - target/i386/whpx/whpx-accel-ops.c|97| <<whpx_accel_ops_class_init>> ops->synchronize_pre_loadvm = whpx_cpu_synchronize_pre_loadvm;
+     */
     if (cpus_accel->synchronize_pre_loadvm) {
         cpus_accel->synchronize_pre_loadvm(cpu);
     }
 }
 
+/*
+ * 在以下使用cpus_are_resettable():
+ *   - system/runstate.c|563| <<qemu_system_reset>> if (cpus_are_resettable()) {
+ *   - system/runstate.c|650| <<qemu_system_reset_request>> } else if (!cpus_are_resettable()) {
+ */
 bool cpus_are_resettable(void)
 {
+    /*
+     * 在以下使用cpus_accel->cpus_are_resettable:
+     *   - accel/kvm/kvm-accel-ops.c|128| <<kvm_accel_ops_class_init>> ops->cpus_are_resettable = kvm_cpus_are_resettable;
+     *   - system/cpus.c|328| <<cpus_are_resettable>> if (cpus_accel->cpus_are_resettable) {
+     *   - system/cpus.c|329| <<cpus_are_resettable>> return cpus_accel->cpus_are_resettable();
+     */
     if (cpus_accel->cpus_are_resettable) {
         return cpus_accel->cpus_are_resettable();
     }
@@ -205,11 +408,21 @@ bool cpus_are_resettable(void)
 
 void cpu_exec_reset_hold(CPUState *cpu)
 {
+    /*
+     * 在以下使用cpus_accel->cpu_reset_hold:
+     *   - accel/tcg/tcg-accel-ops.c|219| <<tcg_accel_ops_init>> ops->cpu_reset_hold = tcg_cpu_reset_hold;
+     *   - system/cpus.c|336| <<cpu_exec_reset_hold>> if (cpus_accel->cpu_reset_hold) {
+     *   - system/cpus.c|337| <<cpu_exec_reset_hold>> cpus_accel->cpu_reset_hold(cpu);
+     */
     if (cpus_accel->cpu_reset_hold) {
         cpus_accel->cpu_reset_hold(cpu);
     }
 }
 
+/*
+ * 在以下使用cpus_get_virtual_clock():
+ *   - util/qemu-timer.c|646| <<qemu_clock_get_ns>> return cpus_get_virtual_clock();
+ */
 int64_t cpus_get_virtual_clock(void)
 {
     /*
@@ -234,6 +447,10 @@ int64_t cpus_get_virtual_clock(void)
  * Signal the new virtual time to the accelerator. This is only needed
  * by accelerators that need to track the changes as we warp time.
  */
+/*
+ * 在以下使用cpus_set_virtual_clock():
+ *   - util/qemu-timer.c|656| <<qemu_virtual_clock_set_ns>> return cpus_set_virtual_clock(time);
+ */
 void cpus_set_virtual_clock(int64_t new_time)
 {
     if (cpus_accel && cpus_accel->set_virtual_clock) {
@@ -331,6 +548,15 @@ bool cpu_can_run(CPUState *cpu)
     return true;
 }
 
+/*
+ * 在以下使用cpu_handle_guest_debug():
+ *   - accel/hvf/hvf-accel-ops.c|450| <<hvf_cpu_thread_fn>> cpu_handle_guest_debug(cpu);
+ *   - accel/kvm/kvm-accel-ops.c|75| <<kvm_vcpu_thread_fn>> cpu_handle_guest_debug(cpu);
+ *   - accel/tcg/tcg-accel-ops-mttcg.c|98| <<mttcg_cpu_thread_fn>> cpu_handle_guest_debug(cpu);
+ *   - accel/tcg/tcg-accel-ops-rr.c|268| <<rr_cpu_thread_fn>> cpu_handle_guest_debug(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|48| <<qemu_nvmm_cpu_thread_fn>> cpu_handle_guest_debug(cpu);
+ *   - target/i386/whpx/whpx-accel-ops.c|48| <<whpx_cpu_thread_fn>> cpu_handle_guest_debug(cpu);
+ */
 void cpu_handle_guest_debug(CPUState *cpu)
 {
     if (replay_running_debug()) {
@@ -442,15 +668,45 @@ static void qemu_cpu_stop(CPUState *cpu, bool exit)
     qemu_cond_broadcast(&qemu_pause_cond);
 }
 
+/*
+ * QEMU-9.2的callstack.
+ * (gdb) bt
+ * #0  kvm_arch_put_registers (cpu=0x555557721960, level=3, errp=0x7fffedb02580) at ../target/i386/kvm/kvm.c:5237
+ * #1  0x0000555555edb672 in do_kvm_cpu_synchronize_post_init (cpu=0x555557721960, arg=...) at ../accel/kvm/kvm-all.c:2905
+ * #2  0x00005555558841ea in process_queued_cpu_work (cpu=0x555557721960) at ../cpu-common.c:375
+ * #3  0x0000555555bd2d4f in qemu_wait_io_event_common (cpu=0x555557721960) at ../system/cpus.c:456
+ * #4  0x0000555555bd2de8 in qemu_wait_io_event (cpu=0x555557721960) at ../system/cpus.c:474
+ * #5  0x0000555555edf7e1 in kvm_vcpu_thread_fn (arg=0x555557721960) at ../accel/kvm/kvm-accel-ops.c:55
+ * #6  0x000055555617e61f in qemu_thread_start (args=0x55555772bbe0) at ../util/qemu-thread-posix.c:541
+ * #7  0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #8  0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下调用qemu_wait_io_event_common():
+ *   - accel/tcg/tcg-accel-ops-rr.c|120| <<rr_wait_io_event>> qemu_wait_io_event_common(cpu);
+ *   - accel/tcg/tcg-accel-ops-rr.c|206| <<rr_cpu_thread_fn>> qemu_wait_io_event_common(cpu);
+ *   - system/cpus.c|469| <<qemu_wait_io_event>> qemu_wait_io_event_common(cpu);
+ *   - target/i386/nvmm/nvmm-accel-ops.c|54| <<qemu_nvmm_cpu_thread_fn>> qemu_wait_io_event_common(cpu);
+ *   - target/i386/whpx/whpx-accel-ops.c|54| <<whpx_cpu_thread_fn>> qemu_wait_io_event_common(cpu);
+ */
 void qemu_wait_io_event_common(CPUState *cpu)
 {
     qatomic_set_mb(&cpu->thread_kicked, false);
     if (cpu->stop) {
         qemu_cpu_stop(cpu, false);
     }
+    /*
+     * 非常重要的函数
+     */
     process_queued_cpu_work(cpu);
 }
 
+/*
+ * 在以下使用qemu_wait_io_event():
+ *   - accel/dummy-cpus.c|59| <<dummy_cpu_thread_fn>> qemu_wait_io_event(cpu);
+ *   - accel/hvf/hvf-accel-ops.c|453| <<hvf_cpu_thread_fn>> qemu_wait_io_event(cpu);
+ *   - accel/kvm/kvm-accel-ops.c|56| <<kvm_vcpu_thread_fn>> qemu_wait_io_event(cpu);
+ *   - accel/tcg/tcg-accel-ops-mttcg.c|117| <<mttcg_cpu_thread_fn>> qemu_wait_io_event(cpu);
+ */
 void qemu_wait_io_event(CPUState *cpu)
 {
     bool slept = false;
@@ -466,6 +722,14 @@ void qemu_wait_io_event(CPUState *cpu)
         qemu_plugin_vcpu_resume_cb(cpu);
     }
 
+    /*
+     * 在以下调用qemu_wait_io_event_common():
+     *   - accel/tcg/tcg-accel-ops-rr.c|120| <<rr_wait_io_event>> qemu_wait_io_event_common(cpu);
+     *   - accel/tcg/tcg-accel-ops-rr.c|206| <<rr_cpu_thread_fn>> qemu_wait_io_event_common(cpu);
+     *   - system/cpus.c|469| <<qemu_wait_io_event>> qemu_wait_io_event_common(cpu);
+     *   - target/i386/nvmm/nvmm-accel-ops.c|54| <<qemu_nvmm_cpu_thread_fn>> qemu_wait_io_event_common(cpu);
+     *   - target/i386/whpx/whpx-accel-ops.c|54| <<whpx_cpu_thread_fn>> qemu_wait_io_event_common(cpu);
+     */
     qemu_wait_io_event_common(cpu);
 }
 
diff --git a/system/dirtylimit.c b/system/dirtylimit.c
index 7dedef8dd..e2850e71e 100644
--- a/system/dirtylimit.c
+++ b/system/dirtylimit.c
@@ -84,6 +84,13 @@ static void vcpu_dirty_rate_stat_collect(void)
         period = migrate_vcpu_dirty_limit_period();
     }
 
+    /*
+     * 在以下使用vcpu_calculate_dirtyrate():
+     *   - migration/dirtyrate.c|674| <<calculate_dirtyrate_dirty_ring>> DirtyStat.calc_time_ms =
+     *           vcpu_calculate_dirtyrate(config.calc_time_ms, &DirtyStat.dirty_ring, GLOBAL_DIRTY_DIRTY_RATE, true);
+     *   - system/dirtylimit.c|88| <<vcpu_dirty_rate_stat_collect>> vcpu_calculate_dirtyrate(period,
+     *           &stat, GLOBAL_DIRTY_LIMIT, false);
+     */
     /* calculate vcpu dirtyrate */
     vcpu_calculate_dirtyrate(period,
                               &stat,
diff --git a/system/main.c b/system/main.c
index 1c0220673..96d37aa3a 100644
--- a/system/main.c
+++ b/system/main.c
@@ -41,12 +41,21 @@
 #include <CoreFoundation/CoreFoundation.h>
 #endif
 
+/*
+ * 在以下使用qemu_default_main():
+ *   - system/main.c|77| <<main>> qemu_thread_create(&main_loop_thread,
+ *      "qemu_main", qemu_default_main, NULL, QEMU_THREAD_DETACHED);
+ *   - system/main.c|80| <<main>> qemu_default_main(NULL);
+ */
 static void *qemu_default_main(void *opaque)
 {
     int status;
 
     replay_mutex_lock();
     bql_lock();
+    /*
+     * 只在此处调用qemu_main_loop()
+     */
     status = qemu_main_loop();
     qemu_cleanup(status);
     bql_unlock();
@@ -55,6 +64,14 @@ static void *qemu_default_main(void *opaque)
     exit(status);
 }
 
+/*
+ * 在以下使用qemu_main函数指针:
+ *   - system/main.c|66| <<global>> int (*qemu_main)(void ) = os_darwin_cfrunloop_main;
+ *   - system/main.c|74| <<main>> if (qemu_main) {
+ *   - system/main.c|78| <<main>> return qemu_main();
+ *   - ui/gtk.c|2490| <<gtk_display_init>> qemu_main = NULL;
+ *   - ui/sdl2.c|945| <<sdl2_display_init>> qemu_main = NULL;
+ */
 int (*qemu_main)(void);
 
 #ifdef CONFIG_DARWIN
@@ -68,9 +85,22 @@ int (*qemu_main)(void) = os_darwin_cfrunloop_main;
 
 int main(int argc, char **argv)
 {
+    /*
+     * 在以下调用qemu_init():
+     *   - system/main.c|71| <<main>> qemu_init(argc, argv);
+     *   - tests/qtest/fuzz/fuzz.c|228| <<LLVMFuzzerInitialize>> qemu_init(result.we_wordc, result.we_wordv);
+     */
     qemu_init(argc, argv);
     bql_unlock();
     replay_mutex_unlock();
+    /*
+     * 在以下使用qemu_main函数指针:
+     *   - system/main.c|66| <<global>> int (*qemu_main)(void ) = os_darwin_cfrunloop_main;
+     *   - system/main.c|74| <<main>> if (qemu_main) {
+     *   - system/main.c|78| <<main>> return qemu_main();
+     *   - ui/gtk.c|2490| <<gtk_display_init>> qemu_main = NULL;
+     *   - ui/sdl2.c|945| <<sdl2_display_init>> qemu_main = NULL;
+     */
     if (qemu_main) {
         QemuThread main_loop_thread;
         qemu_thread_create(&main_loop_thread, "qemu_main",
diff --git a/system/memory.c b/system/memory.c
index 4c829793a..adce705ce 100644
--- a/system/memory.c
+++ b/system/memory.c
@@ -37,9 +37,62 @@
 
 //#define DEBUG_UNASSIGNED
 
+/*
+ * 在以下使用memory_region_transaction_depth:
+ *   - system/memory.c|1166| <<memory_region_transaction_begin>> ++memory_region_transaction_depth;
+ *   - system/memory.c|1173| <<memory_region_transaction_commit>> assert(memory_region_transaction_depth);
+ *   - system/memory.c|1176| <<memory_region_transaction_commit>> --memory_region_transaction_depth;
+ *   - system/memory.c|1177| <<memory_region_transaction_commit>> if (!memory_region_transaction_depth) {
+ */
 static unsigned memory_region_transaction_depth;
+/*
+ * 在以下修改memory_region_update_pending:
+ *   - system/memory.c|1187| <<memory_region_transaction_commit>> memory_region_update_pending = false;
+ *   - system/memory.c|2294| <<memory_region_set_log>> memory_region_update_pending |= mr->enabled;
+ *   - system/memory.c|2424| <<memory_region_set_readonly>> memory_region_update_pending |= mr->enabled;
+ *   - system/memory.c|2434| <<memory_region_set_nonvolatile>> memory_region_update_pending |= mr->enabled;
+ *   - system/memory.c|2444| <<memory_region_rom_device_set_romd>> memory_region_update_pending |= mr->enabled;
+ *   - system/memory.c|2693| <<memory_region_update_container_subregions>> memory_region_update_pending |= mr->enabled && subregion->enabled;
+ *   - system/memory.c|2743| <<memory_region_del_subregion>> memory_region_update_pending |= mr->enabled && subregion->enabled;
+ *   - system/memory.c|2754| <<memory_region_set_enabled>> memory_region_update_pending = true;
+ *   - system/memory.c|2770| <<memory_region_set_size>> memory_region_update_pending = true;
+ *   - system/memory.c|2806| <<memory_region_set_alias_offset>> memory_region_update_pending |= mr->enabled;
+ *   - system/memory.c|2818| <<memory_region_set_unmergeable>> memory_region_update_pending |= mr->enabled;
+ *   - system/memory.c|3017| <<memory_global_dirty_log_start>> memory_region_update_pending = true;
+ *   - system/memory.c|3033| <<memory_global_dirty_log_do_stop>> memory_region_update_pending = true;
+ * 在以下使用memory_region_update_pending:
+ *   - system/memory.c|1178| <<memory_region_transaction_commit>> if (memory_region_update_pending) {
+ */
 static bool memory_region_update_pending;
+/*
+ * 在以下使用ioeventfd_update_pending:
+ *   - system/memory.c|1188| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - system/memory.c|1190| <<memory_region_transaction_commit>> } else if (ioeventfd_update_pending) {
+ *   - system/memory.c|1194| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - system/memory.c|2638| <<memory_region_add_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ *   - system/memory.c|2673| <<memory_region_del_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ */
 static bool ioeventfd_update_pending;
+/*
+ * 在以下使用global_dirty_tracking:
+ *   - include/exec/ram_addr.h|392| <<cpu_physical_memory_set_dirty_lebitmap>> if (global_dirty_tracking) {
+ *   - include/exec/ram_addr.h|397| <<cpu_physical_memory_set_dirty_lebitmap>> global_dirty_tracking & GLOBAL_DIRTY_DIRTY_RATE)) {
+ *   - include/exec/ram_addr.h|421| <<cpu_physical_memory_set_dirty_lebitmap>> if (!global_dirty_tracking) {
+ *   - include/exec/ram_addr.h|433| <<cpu_physical_memory_set_dirty_lebitmap>> if (unlikely(global_dirty_tracking & GLOBAL_DIRTY_DIRTY_RATE)) {
+ *   - migration/ram.c|2348| <<ram_save_cleanup>> if (global_dirty_tracking & GLOBAL_DIRTY_MIGRATION) { 
+ *   - system/memory.c|1899| <<memory_region_get_dirty_log_mask>> if (global_dirty_tracking && ((rb && qemu_ram_is_migratable(rb)) ||
+ *   - system/memory.c|2980| <<memory_global_dirty_log_start>> flags &= ~global_dirty_tracking;
+ *   - system/memory.c|2985| <<memory_global_dirty_log_start>> old_flags = global_dirty_tracking;
+ *   - system/memory.c|2986| <<memory_global_dirty_log_start>> global_dirty_tracking |= flags;
+ *   - system/memory.c|2987| <<memory_global_dirty_log_start>> trace_global_dirty_changed(global_dirty_tracking);
+ *   - system/memory.c|2991| <<memory_global_dirty_log_start>> global_dirty_tracking &= ~flags;
+ *   - system/memory.c|2992| <<memory_global_dirty_log_start>> trace_global_dirty_changed(global_dirty_tracking);
+ *   - system/memory.c|3006| <<memory_global_dirty_log_do_stop>> assert((global_dirty_tracking & flags) == flags);
+ *   - system/memory.c|3007| <<memory_global_dirty_log_do_stop>> global_dirty_tracking &= ~flags;
+ *   - system/memory.c|3009| <<memory_global_dirty_log_do_stop>> trace_global_dirty_changed(global_dirty_tracking);
+ *   - system/memory.c|3011| <<memory_global_dirty_log_do_stop>> if (!global_dirty_tracking) {
+ *   - system/memory.c|3075| <<listener_add_address_space>> if (global_dirty_tracking) {
+ */
 unsigned int global_dirty_tracking;
 
 static QTAILQ_HEAD(, MemoryListener) memory_listeners
@@ -839,6 +892,12 @@ FlatView *address_space_get_flatview(AddressSpace *as)
     return view;
 }
 
+/*
+ * 在以下使用address_space_update_ioeventfds():
+ *   - system/memory.c|1185| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+ *   - system/memory.c|1192| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+ *   - system/memory.c|3277| <<address_space_init>> address_space_update_ioeventfds(as);
+ */
 static void address_space_update_ioeventfds(AddressSpace *as)
 {
     FlatView *view;
@@ -973,6 +1032,11 @@ flat_range_coalesced_io_notify_listener_add_del(FlatRange *fr,
     }
 }
 
+/*
+ * 在以下使用address_space_update_topology_pass():
+ *   - system/memory.c|1170| <<address_space_set_flatview>> address_space_update_topology_pass(as, old_view2, new_view, false);
+ *   - system/memory.c|1171| <<address_space_set_flatview>> address_space_update_topology_pass(as, old_view2, new_view, true);
+ */
 static void address_space_update_topology_pass(AddressSpace *as,
                                                const FlatView *old_view,
                                                const FlatView *new_view,
@@ -1084,6 +1148,11 @@ static void flatviews_reset(void)
     }
 }
 
+/*
+ * 在以下使用address_space_set_flatview():
+ *   - system/memory.c|1199| <<address_space_update_topology>> address_space_set_flatview(as);
+ *   - system/memory.c|1237| <<memory_region_transaction_commit>> address_space_set_flatview(as);
+ */
 static void address_space_set_flatview(AddressSpace *as)
 {
     FlatView *old_view = address_space_to_flatview(as);
@@ -1143,9 +1212,28 @@ static void address_space_update_topology(AddressSpace *as)
 void memory_region_transaction_begin(void)
 {
     qemu_flush_coalesced_mmio_buffer();
+    /*
+     * 在以下使用memory_region_transaction_depth:
+     *   - system/memory.c|1166| <<memory_region_transaction_begin>> ++memory_region_transaction_depth;
+     *   - system/memory.c|1173| <<memory_region_transaction_commit>> assert(memory_region_transaction_depth);
+     *   - system/memory.c|1176| <<memory_region_transaction_commit>> --memory_region_transaction_depth;
+     *   - system/memory.c|1177| <<memory_region_transaction_commit>> if (!memory_region_transaction_depth) {
+     */
     ++memory_region_transaction_depth;
 }
 
+/*
+ * (gdb) bt
+ * #0  memory_global_dirty_log_do_stop (flags=2) at ../system/memory.c:2995
+ * #1  0x0000555555cbbc10 in memory_global_dirty_log_stop (flags=<optimized out>) at ../system/memory.c:3054
+ * #2  0x0000555555b20a57 in global_dirty_log_sync (flag=2, one_shot=<optimized out>) at ../migration/dirtyrate.c:119
+ * #3  0x0000555555b219b0 in calculate_dirtyrate_dirty_bitmap (config=..., config=...) at ../migration/dirtyrate.c:656
+ * #4  calculate_dirtyrate (config=...) at ../migration/dirtyrate.c:723
+ * #5  get_dirtyrate_thread (arg=arg@entry=0x555556f4d6f0 <config>) at ../migration/dirtyrate.c:746
+ * #6  0x0000555555ec4839 in qemu_thread_start (args=<optimized out>) at ../util/qemu-thread-posix.c:541
+ * #7  0x00007ffff69201da in start_thread () from /lib64/libpthread.so.0
+ * #8  0x00007ffff657a8d3 in clone () from /lib64/libc.so.6
+ */
 void memory_region_transaction_commit(void)
 {
     AddressSpace *as;
@@ -1153,6 +1241,13 @@ void memory_region_transaction_commit(void)
     assert(memory_region_transaction_depth);
     assert(bql_locked());
 
+    /*
+     * 在以下使用memory_region_transaction_depth:
+     *   - system/memory.c|1166| <<memory_region_transaction_begin>> ++memory_region_transaction_depth;
+     *   - system/memory.c|1173| <<memory_region_transaction_commit>> assert(memory_region_transaction_depth);
+     *   - system/memory.c|1176| <<memory_region_transaction_commit>> --memory_region_transaction_depth;
+     *   - system/memory.c|1177| <<memory_region_transaction_commit>> if (!memory_region_transaction_depth) {
+     */
     --memory_region_transaction_depth;
     if (!memory_region_transaction_depth) {
         if (memory_region_update_pending) {
@@ -1162,6 +1257,12 @@ void memory_region_transaction_commit(void)
 
             QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
                 address_space_set_flatview(as);
+                /*
+		 * 在以下使用address_space_update_ioeventfds():
+                 *   - system/memory.c|1185| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+		 *   - system/memory.c|1192| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+		 *   - system/memory.c|3277| <<address_space_init>> address_space_update_ioeventfds(as);
+		 */
                 address_space_update_ioeventfds(as);
             }
             memory_region_update_pending = false;
@@ -1610,6 +1711,10 @@ bool memory_region_init_ram_flags_nomigrate(MemoryRegion *mr,
     return true;
 }
 
+/*
+ * 在以下使用memory_region_init_resizeable_ram():
+ *   - hw/core/loader.c|1025| <<rom_set_mr>> memory_region_init_resizeable_ram(rom->mr, owner, name,
+ */
 bool memory_region_init_resizeable_ram(MemoryRegion *mr,
                                        Object *owner,
                                        const char *name,
@@ -2469,10 +2574,23 @@ ram_addr_t memory_region_get_ram_addr(MemoryRegion *mr)
     return mr->ram_block ? mr->ram_block->offset : RAM_ADDR_INVALID;
 }
 
+/*
+ * 在以下调用memory_region_ram_resize():
+ *   - hw/arm/virt-acpi-build.c|1035| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+ *   - hw/i386/acpi-build.c|2642| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+ *   - hw/loongarch/virt-acpi-build.c|644| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+ *   - hw/nvram/fw_cfg.c|631| <<fw_cfg_update_mr>> memory_region_ram_resize(mr, size, &error_abort);
+ *   - hw/riscv/virt-acpi-build.c|746| <<acpi_ram_update>> memory_region_ram_resize(mr, size, &error_abort);
+ */
 void memory_region_ram_resize(MemoryRegion *mr, ram_addr_t newsize, Error **errp)
 {
     assert(mr->ram_block);
 
+    /*
+     * called by:
+     *   - migration/ram.c|3995| <<parse_ramblock>> ret = qemu_ram_resize(block, length, &local_err);
+     *   - system/memory.c|2476| <<memory_region_ram_resize>> qemu_ram_resize(mr->ram_block, newsize, errp);
+     */
     qemu_ram_resize(mr->ram_block, newsize, errp);
 }
 
@@ -2598,6 +2716,14 @@ void memory_region_add_eventfd(MemoryRegion *mr,
     memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],
             sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));
     mr->ioeventfds[i] = mrfd;
+    /*
+     * 在以下使用ioeventfd_update_pending:
+     *   - system/memory.c|1188| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+     *   - system/memory.c|1190| <<memory_region_transaction_commit>> } else if (ioeventfd_update_pending) {
+     *   - system/memory.c|1194| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+     *   - system/memory.c|2638| <<memory_region_add_eventfd>> ioeventfd_update_pending |= mr->enabled;
+     *   - system/memory.c|2673| <<memory_region_del_eventfd>> ioeventfd_update_pending |= mr->enabled;
+     */
     ioeventfd_update_pending |= mr->enabled;
     memory_region_transaction_commit();
 }
@@ -2633,6 +2759,14 @@ void memory_region_del_eventfd(MemoryRegion *mr,
     --mr->ioeventfd_nb;
     mr->ioeventfds = g_realloc(mr->ioeventfds,
                                   sizeof(*mr->ioeventfds)*mr->ioeventfd_nb + 1);
+    /*
+     * 在以下使用ioeventfd_update_pending:
+     *   - system/memory.c|1188| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+     *   - system/memory.c|1190| <<memory_region_transaction_commit>> } else if (ioeventfd_update_pending) {
+     *   - system/memory.c|1194| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+     *   - system/memory.c|2638| <<memory_region_add_eventfd>> ioeventfd_update_pending |= mr->enabled;
+     *   - system/memory.c|2673| <<memory_region_del_eventfd>> ioeventfd_update_pending |= mr->enabled;
+     */
     ioeventfd_update_pending |= mr->enabled;
     memory_region_transaction_commit();
 }
@@ -2907,6 +3041,14 @@ bool memory_region_present(MemoryRegion *container, hwaddr addr)
     return mr && mr != container;
 }
 
+/*
+ * 在以下使用memory_global_dirty_log_sync():
+ *   - migration/dirtyrate.c|116| <<global_dirty_log_sync>> memory_global_dirty_log_sync(false);
+ *   - migration/dirtyrate.c|632| <<calculate_dirtyrate_dirty_bitmap>> memory_global_dirty_log_sync(false);
+ *   - migration/ram.c|1041| <<migration_bitmap_sync>> memory_global_dirty_log_sync(last_stage);
+ *   - migration/ram.c|3600| <<colo_incoming_start_dirty_log>> memory_global_dirty_log_sync(false);
+ *   - migration/ram.c|3872| <<colo_flush_ram_cache>> memory_global_dirty_log_sync(false);
+ */
 void memory_global_dirty_log_sync(bool last_stage)
 {
     memory_region_sync_dirty_bitmap(NULL, last_stage);
@@ -2983,6 +3125,18 @@ bool memory_global_dirty_log_start(unsigned int flags, Error **errp)
     return true;
 }
 
+/*
+ * (gdb) bt
+ * #0  memory_global_dirty_log_do_stop (flags=2) at ../system/memory.c:2995
+ * #1  0x0000555555cbbc10 in memory_global_dirty_log_stop (flags=<optimized out>) at ../system/memory.c:3054
+ * #2  0x0000555555b20a57 in global_dirty_log_sync (flag=2, one_shot=<optimized out>) at ../migration/dirtyrate.c:119
+ * #3  0x0000555555b219b0 in calculate_dirtyrate_dirty_bitmap (config=..., config=...) at ../migration/dirtyrate.c:656
+ * #4  calculate_dirtyrate (config=...) at ../migration/dirtyrate.c:723
+ * #5  get_dirtyrate_thread (arg=arg@entry=0x555556f4d6f0 <config>) at ../migration/dirtyrate.c:746
+ * #6  0x0000555555ec4839 in qemu_thread_start (args=<optimized out>) at ../util/qemu-thread-posix.c:541
+ * #7  0x00007ffff69201da in start_thread () from /lib64/libpthread.so.0
+ * #8  0x00007ffff657a8d3 in clone () from /lib64/libc.so.6
+ */
 static void memory_global_dirty_log_do_stop(unsigned int flags)
 {
     assert(flags && !(flags & (~GLOBAL_DIRTY_MASK)));
@@ -3026,6 +3180,14 @@ static void memory_vm_change_state_handler(void *opaque, bool running,
     }
 }
 
+/*
+ * 在以下使用memory_global_dirty_log_stop():
+ *   - hw/i386/xen/xen-hvm.c|704| <<qmp_xen_set_global_dirty_log>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+ *   - migration/dirtyrate.c|103| <<global_dirty_log_change>> memory_global_dirty_log_stop(flag);
+ *   - migration/dirtyrate.c|118| <<global_dirty_log_sync>> memory_global_dirty_log_stop(flag);
+ *   - migration/ram.c|2354| <<ram_save_cleanup>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+ *   - migration/ram.c|3622| <<colo_release_ram_cache>> memory_global_dirty_log_stop(GLOBAL_DIRTY_MIGRATION);
+ */
 void memory_global_dirty_log_stop(unsigned int flags)
 {
     if (!runstate_is_running()) {
diff --git a/system/physmem.c b/system/physmem.c
index 333a5eb94..e474d27b3 100644
--- a/system/physmem.c
+++ b/system/physmem.c
@@ -90,6 +90,44 @@
 
 //#define DEBUG_SUBPAGE
 
+/*
+ * 在以下使用ram_list:
+ *   - system/physmem.c|96| <<global>> RAMList ram_list = { .blocks = QLIST_HEAD_INITIALIZER(ram_list.blocks) };
+ *   - system/physmem.c|956| <<global>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - hw/core/numa.c|846| <<ram_block_notifier_add>> QLIST_INSERT_HEAD(&ram_list.ramblock_notifiers, n, next);
+ *   - hw/core/numa.c|868| <<ram_block_notify_add>> QLIST_FOREACH_SAFE(notifier, &ram_list.ramblock_notifiers, next, next) {
+ *   - hw/core/numa.c|880| <<ram_block_notify_remove>> QLIST_FOREACH_SAFE(notifier, &ram_list.ramblock_notifiers, next, next) {
+ *   - hw/core/numa.c|892| <<ram_block_notify_resize>> QLIST_FOREACH_SAFE(notifier, &ram_list.ramblock_notifiers, next, next) {
+ *   - include/exec/ram_addr.h|175| <<cpu_physical_memory_get_dirty>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - include/exec/ram_addr.h|216| <<cpu_physical_memory_all_dirty>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - include/exec/ram_addr.h|289| <<cpu_physical_memory_set_dirty_flag>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - include/exec/ram_addr.h|312| <<cpu_physical_memory_set_dirty_range>> blocks[i] = qatomic_rcu_read(&ram_list.dirty_memory[i]);
+ *   - include/exec/ram_addr.h|382| <<cpu_physical_memory_set_dirty_lebitmap>> qatomic_rcu_read(&ram_list.dirty_memory[i])->blocks;
+ *   - include/exec/ram_addr.h|506| <<cpu_physical_memory_sync_dirty_bitmap>> &ram_list.dirty_memory[DIRTY_MEMORY_MIGRATION])->blocks;
+ *   - include/exec/ramlist.h|61| <<INTERNAL_RAMBLOCK_FOREACH>> QLIST_FOREACH_RCU(block, &ram_list.blocks, next)
+ *   - migration/ram.c|1309| <<find_dirty_block>> pss->block = QLIST_FIRST_RCU(&ram_list.blocks);
+ *   - migration/ram.c|2205| <<ram_find_and_save_block>> rs->last_seen_block = QLIST_FIRST_RCU(&ram_list.blocks);
+ *   - migration/ram.c|2352| <<ram_state_reset>> rs->last_version = ram_list.version;
+ *   - migration/ram.c|3107| <<ram_save_iterate>> if (ram_list.version != rs->last_version) {
+ *   - migration/ram.c|3822| <<colo_flush_ram_cache>> block = QLIST_FIRST_RCU(&ram_list.blocks);
+ *   - system/physmem.c|826| <<qemu_get_ram_block>> block = qatomic_rcu_read(&ram_list.mru_block);
+ *   - system/physmem.c|856| <<qemu_get_ram_block>> ram_list.mru_block = block;
+ *   - system/physmem.c|900| <<cpu_physical_memory_test_and_clear_dirty>> blocks = qatomic_rcu_read(&ram_list.dirty_memory[client]);
+ *   - system/physmem.c|1155| <<qemu_mutex_lock_ramlist>> qemu_mutex_lock(&ram_list.mutex);
+ *   - system/physmem.c|1160| <<qemu_mutex_unlock_ramlist>> qemu_mutex_unlock(&ram_list.mutex);
+ *   - system/physmem.c|1499| <<find_ram_offset>> if (QLIST_EMPTY_RCU(&ram_list.blocks)) {
+ *   - system/physmem.c|1889| <<dirty_memory_extend>> unsigned int old_num_blocks = ram_list.num_dirty_blocks;
+ *   - system/physmem.c|1904| <<dirty_memory_extend>> old_blocks = qatomic_rcu_read(&ram_list.dirty_memory[i]);
+ *   - system/physmem.c|1917| <<dirty_memory_extend>> qatomic_rcu_set(&ram_list.dirty_memory[i], new_blocks);
+ *   - system/physmem.c|1924| <<dirty_memory_extend>> ram_list.num_dirty_blocks = new_num_blocks;
+ *   - system/physmem.c|2021| <<ram_block_add>> QLIST_INSERT_HEAD_RCU(&ram_list.blocks, new_block, next);
+ *   - system/physmem.c|2023| <<ram_block_add>> ram_list.mru_block = NULL;
+ *   - system/physmem.c|2027| <<ram_block_add>> ram_list.version++;
+ *   - system/physmem.c|2379| <<qemu_ram_free>> ram_list.mru_block = NULL;
+ *   - system/physmem.c|2382| <<qemu_ram_free>> ram_list.version++;
+ *   - system/physmem.c|2566| <<qemu_ram_block_from_host>> block = qatomic_rcu_read(&ram_list.mru_block);
+ *   - system/physmem.c|3381| <<cpu_exec_init_all>> qemu_mutex_init(&ram_list.mutex);
+ */
 /* ram_list is read under rcu_read_lock()/rcu_read_unlock().  Writes
  * are protected by the ramlist lock.
  */
@@ -1171,6 +1209,21 @@ GString *ram_block_format(void)
                            "Block Name", "PSize", "Offset", "Used", "Total",
                            "HVA", "RO");
 
+    /*
+     * 在以下使用RAMBLOCK_FOREACH():
+     *   - migration/postcopy-ram.c|418| <<postcopy_ram_supported_by_host>> RAMBLOCK_FOREACH(block) {
+     *   - system/physmem.c|830| <<qemu_get_ram_block>> RAMBLOCK_FOREACH(block) {
+     *   - system/physmem.c|1174| <<ram_block_format>> RAMBLOCK_FOREACH(block) {
+     *   - system/physmem.c|1503| <<find_ram_offset>> RAMBLOCK_FOREACH(block) {
+     *   - system/physmem.c|1515| <<find_ram_offset>> RAMBLOCK_FOREACH(next_block) {
+     *   - system/physmem.c|1648| <<qemu_ram_set_idstr>> RAMBLOCK_FOREACH(block) {
+     *   - system/physmem.c|1693| <<qemu_ram_pagesize_largest>> RAMBLOCK_FOREACH(block) {
+     *   - system/physmem.c|2010| <<ram_block_add>> RAMBLOCK_FOREACH(block) {
+     *   - system/physmem.c|2425| <<qemu_ram_remap>> RAMBLOCK_FOREACH(block) {
+     *   - system/physmem.c|2571| <<qemu_ram_block_from_host>> RAMBLOCK_FOREACH(block) {
+     *   - system/physmem.c|2602| <<qemu_ram_block_by_name>> RAMBLOCK_FOREACH(block) {
+     *   - system/physmem.c|3859| <<qemu_ram_foreach_block>> RAMBLOCK_FOREACH(block) {
+     */
     RAMBLOCK_FOREACH(block) {
         psize = size_to_str(block->page_size);
         g_string_append_printf(buf, "%24s %8s  0x%016" PRIx64 " 0x%016" PRIx64
@@ -1602,6 +1655,14 @@ void qemu_ram_set_uf_zeroable(RAMBlock *rb)
     rb->flags |= RAM_UF_ZEROPAGE;
 }
 
+/*
+ * 在以下使用qemu_ram_is_migratable():
+ *   - migration/ram.c|199| <<migrate_ram_is_ignored>> return !qemu_ram_is_migratable(block) ||
+ *   - migration/ram.c|3989| <<parse_ramblock>> if (!qemu_ram_is_migratable(block)) {
+ *   - migration/ram.h|73| <<RAMBLOCK_FOREACH_MIGRATABLE>> if (!qemu_ram_is_migratable(block)) {} else
+ *   - system/memory.c|1899| <<memory_region_get_dirty_log_mask>> if (global_dirty_tracking && ((rb && qemu_ram_is_migratable(rb)) ||
+ *   - system/physmem.c|4240| <<ram_block_add_cpr_blocker>> assert(qemu_ram_is_migratable(rb));
+ */
 bool qemu_ram_is_migratable(RAMBlock *rb)
 {
     return rb->flags & RAM_MIGRATABLE;
@@ -1715,6 +1776,69 @@ static int memory_try_enable_merging(void *addr, size_t len)
  * resize callback to update device state and/or add assertions to detect
  * misuse, if necessary.
  */
+/*
+ * (gdb) bt
+ * #0  qemu_ram_resize (block=0x555557fd1400, newsize=4096, errp=0x5555573a2118 <error_abort>) at ../system/physmem.c:1720
+ * #1  0x0000555555ebf3e9 in memory_region_ram_resize (mr=0x5555583a8ae0, newsize=4096, errp=0x5555573a2118 <error_abort>)
+ *     at ../system/memory.c:2476
+ * #2  0x0000555555d89e92 in acpi_ram_update (mr=0x5555583a8ae0, data=0x5555576eaf90) at ../hw/i386/acpi-build.c:2642
+ * #3  0x0000555555d89fca in acpi_build_update (build_opaque=0x5555576d78c0) at ../hw/i386/acpi-build.c:2667
+ * #4  0x0000555555ac20fd in fw_cfg_select (s=0x555557c08fa0, key=42) at ../hw/nvram/fw_cfg.c:285
+ * #5  0x0000555555ac2460 in fw_cfg_dma_transfer (s=0x555557c08fa0) at ../hw/nvram/fw_cfg.c:359
+ * #6  0x0000555555ac28cb in fw_cfg_dma_mem_write (opaque=0x555557c08fa0, addr=4, value=27712, size=4)
+ *     at ../hw/nvram/fw_cfg.c:460
+ * #7  0x0000555555eb8e96 in memory_region_write_accessor (mr=0x555557c09330, addr=4, value=0x7fffeda3f3a8, size=4, shift=0,
+ *     mask=4294967295, attrs=...) at ../system/memory.c:497
+ * #8  0x0000555555eb9184 in access_with_adjusted_size (addr=4, value=0x7fffeda3f3a8, size=4, access_size_min=1,
+ *     access_size_max=8, access_fn=0x555555eb8da0 <memory_region_write_accessor>, mr=0x555557c09330, attrs=...)
+ *     at ../system/memory.c:568
+ * #9  0x0000555555ebc9a2 in memory_region_dispatch_write (mr=0x555557c09330, addr=4, data=27712, op=MO_32, attrs=...)
+ *     at ../system/memory.c:1553
+ * #10 0x0000555555eccb79 in flatview_write_continue_step (attrs=..., buf=0x7ffff7ff1000 "", len=4, mr_addr=4, l=0x7fffeda3f490,
+ *     mr=0x555557c09330) at ../system/physmem.c:2953
+ * #11 0x0000555555eccc4e in flatview_write_continue (fv=0x7fffe4202160, addr=1304, attrs=..., ptr=0x7ffff7ff1000, len=4,
+ *     mr_addr=4, l=4, mr=0x555557c09330) at ../system/physmem.c:2983
+ * #12 0x0000555555eccd7b in flatview_write (fv=0x7fffe4202160, addr=1304, attrs=..., buf=0x7ffff7ff1000, len=4)
+ *     at ../system/physmem.c:3014
+ * #13 0x0000555555ecd208 in address_space_write (as=0x555557383fc0 <address_space_io>, addr=1304, attrs=...,
+ *     buf=0x7ffff7ff1000, len=4) at ../system/physmem.c:3134
+ * #14 0x0000555555ecd282 in address_space_rw (as=0x555557383fc0 <address_space_io>, addr=1304, attrs=...,
+ *     buf=0x7ffff7ff1000, len=4, is_write=true) at ../system/physmem.c:3144
+ * #15 0x0000555555f0b7fc in kvm_handle_io (port=1304, attrs=..., data=0x7ffff7ff1000, direction=1, size=4, count=1) at
+ *     ../accel/kvm/kvm-all.c:2800
+ * #16 0x0000555555f0c774 in kvm_cpu_exec (cpu=0x5555577504d0) at ../accel/kvm/kvm-all.c:3186
+ * #17 0x0000555555f0feec in kvm_vcpu_thread_fn (arg=0x5555577504d0) at ../accel/kvm/kvm-accel-ops.c:51
+ * #18 0x00005555561ad4e5 in qemu_thread_start (args=0x55555775a960) at ../util/qemu-thread-posix.c:541
+ * #19 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #20 0x00007ffff4bda8d3 in clone () from /lib64/libc.so.6
+ *
+ *
+ * (gdb) bt
+ * #0  qemu_ram_resize (block=0x5555582c8820, newsize=4096, errp=0x5555573a2118 <error_abort>) at ../system/physmem.c:1720
+ * #1  0x0000555555ebf3e9 in memory_region_ram_resize (mr=0x5555582a00e0, newsize=4096, errp=0x5555573a2118 <error_abort>) at ../system/memory.c:2476
+ * #2  0x0000555555ac2db8 in fw_cfg_update_mr (s=0x555557c2ac80, key=41, size=4096) at ../hw/nvram/fw_cfg.c:631
+ * #3  0x0000555555ac2f08 in fw_cfg_acpi_mr_restore_post_load (opaque=0x555557c2ac80, version_id=1) at ../hw/nvram/fw_cfg.c:647
+ * #4  0x0000555555f83d72 in vmstate_load_state (f=0x555557a5bb00, vmsd=0x5555571d0ce0 <vmstate_fw_cfg_acpi_mr>, opaque=0x555557c2ac80, version_id=1)
+ *     at ../migration/vmstate.c:234
+ * #5  0x0000555555f84d35 in vmstate_subsection_load (f=0x555557a5bb00, vmsd=0x5555571d0d60 <vmstate_fw_cfg>, opaque=0x555557c2ac80)
+ *     at ../migration/vmstate.c:608
+ * #6  0x0000555555f83d30 in vmstate_load_state (f=0x555557a5bb00, vmsd=0x5555571d0d60 <vmstate_fw_cfg>, opaque=0x555557c2ac80, version_id=2)
+ *     at ../migration/vmstate.c:228
+ * #7  0x0000555555c807aa in vmstate_load (f=0x555557a5bb00, se=0x555557c2d810) at ../migration/savevm.c:972
+ * #8  0x0000555555c8442a in qemu_loadvm_section_start_full (f=0x555557a5bb00, type=4 '\004') at ../migration/savevm.c:2701
+ * #9  0x0000555555c84fe1 in qemu_loadvm_state_main (f=0x555557a5bb00, mis=0x55555745ce40) at ../migration/savevm.c:3007
+ * #10 0x0000555555c851b0 in qemu_loadvm_state (f=0x555557a5bb00) at ../migration/savevm.c:3094
+ * #11 0x0000555555c6310c in process_incoming_migration_co (opaque=0x0) at ../migration/migration.c:866
+ * #12 0x00005555561cda9d in coroutine_trampoline (i0=1466944864, i1=21845) at ../util/coroutine-ucontext.c:175
+ * #13 0x00007ffff4bc5120 in ?? () from /lib64/libc.so.6
+ * #14 0x00007fffffffc7c0 in ?? ()
+ * #15 0x0000000000000000 in ?? ()
+ *
+ *
+ * called by:
+ *   - migration/ram.c|3995| <<parse_ramblock>> ret = qemu_ram_resize(block, length, &local_err);
+ *   - system/memory.c|2476| <<memory_region_ram_resize>> qemu_ram_resize(mr->ram_block, newsize, errp);
+ */
 int qemu_ram_resize(RAMBlock *block, ram_addr_t newsize, Error **errp)
 {
     const ram_addr_t oldsize = block->used_length;
@@ -1723,6 +1847,13 @@ int qemu_ram_resize(RAMBlock *block, ram_addr_t newsize, Error **errp)
     assert(block);
 
     newsize = TARGET_PAGE_ALIGN(newsize);
+    /*
+     * 实现:
+     * 747 static inline uintptr_t qemu_real_host_page_size(void)
+     * 748 {
+     * 749     return getpagesize();
+     * 750 }
+     */
     newsize = REAL_HOST_PAGE_ALIGN(newsize);
 
     if (block->used_length == newsize) {
@@ -1747,6 +1878,14 @@ int qemu_ram_resize(RAMBlock *block, ram_addr_t newsize, Error **errp)
         return -EINVAL;
     }
 
+    /*
+     * RAMBlock *block:
+     * -> char idstr[256];
+     *
+     * 比如说:
+     * newsize = 0x10000
+     * block->max_length = 0x1000
+     */
     if (block->max_length < newsize) {
         error_setg_errno(errp, EINVAL,
                          "Size too large: %s: 0x" RAM_ADDR_FMT
@@ -2138,6 +2277,12 @@ static int qemu_ram_get_shared_fd(const char *name, bool *reused, Error **errp)
 }
 #endif
 
+/*
+ * 在以下调用qemu_ram_alloc_internal():
+ *   - system/physmem.c|2302| <<qemu_ram_alloc_from_ptr>> return qemu_ram_alloc_internal(size, size, NULL, host, RAM_PREALLOC, mr,
+ *   - system/physmem.c|2311| <<qemu_ram_alloc>> return qemu_ram_alloc_internal(size, size, NULL, NULL, ram_flags, mr, errp);
+ *   - system/physmem.c|2318| <<qemu_ram_alloc_resizeable>> return qemu_ram_alloc_internal(size, maxsz, resized, NULL,
+ */
 static
 RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                   qemu_ram_resize_cb resized,
@@ -2240,6 +2385,10 @@ RAMBlock *qemu_ram_alloc(ram_addr_t size, uint32_t ram_flags,
     return qemu_ram_alloc_internal(size, size, NULL, NULL, ram_flags, mr, errp);
 }
 
+/*
+ * 在以下调用qemu_ram_alloc_resizeable():
+ *   - system/memory.c|1628| <<memory_region_init_resizeable_ram>> mr->ram_block = qemu_ram_alloc_resizeable(size, max_size, resized,
+ */
 RAMBlock *qemu_ram_alloc_resizeable(ram_addr_t size, ram_addr_t maxsz,
                                     qemu_ram_resize_cb resized,
                                     MemoryRegion *mr, Error **errp)
@@ -2875,6 +3024,12 @@ int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)
     return l;
 }
 
+/*
+ * 在以下使用prepare_mmio_access():
+ *   - hw/remote/vfio-user-obj.c|384| <<vfu_object_mr_rw>> release_lock = prepare_mmio_access(mr);
+ *   - system/physmem.c|3081| <<flatview_write_continue_step>> bool release_lock = prepare_mmio_access(mr);
+ *   - system/physmem.c|3178| <<flatview_read_continue_step>> bool release_lock = prepare_mmio_access(mr);
+ */
 bool prepare_mmio_access(MemoryRegion *mr)
 {
     bool release_lock = false;
diff --git a/system/runstate.c b/system/runstate.c
index 272801d30..fa14648cb 100644
--- a/system/runstate.c
+++ b/system/runstate.c
@@ -502,6 +502,14 @@ static int qemu_debug_requested(void)
     return r;
 }
 
+/*
+ * 在以下使用qemu_system_reset():
+ *   - hw/core/machine.c|1771| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+ *   - hw/xen/xen-hvm-common.c|609| <<cpu_handle_ioreq>> qemu_system_reset(request);
+ *   - migration/savevm.c|3641| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_SNAPSHOT_LOAD);
+ *   - system/runstate.c|805| <<main_loop_should_exit>> qemu_system_reset(request);
+ *   - tests/qtest/fuzz/fuzz.c|57| <<fuzz_reset>> qemu_system_reset(SHUTDOWN_CAUSE_GUEST_RESET);
+ */
 /*
  * Reset the VM. Issue an event unless @reason is SHUTDOWN_CAUSE_NONE.
  */
@@ -512,6 +520,16 @@ void qemu_system_reset(ShutdownCause reason)
 
     mc = current_machine ? MACHINE_GET_CLASS(current_machine) : NULL;
 
+    /*
+     * 在以下使用cpu_synchronize_all_states():
+     *   - dump/dump.c|1811| <<dump_init>> cpu_synchronize_all_states();
+     *   - hw/i386/pc.c|1741| <<pc_machine_wakeup>> cpu_synchronize_all_states();
+     *   - migration/colo.c|688| <<colo_incoming_process_checkpoint>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1792| <<qemu_savevm_state_complete_precopy_non_iterable>> cpu_synchronize_all_states();
+     *   - migration/savevm.c|1989| <<qemu_save_device_state>> cpu_synchronize_all_states();
+     *   - system/runstate.c|515| <<qemu_system_reset>> cpu_synchronize_all_states();
+     *   - target/arm/hvf/hvf.c|2127| <<hvf_vm_state_change>> cpu_synchronize_all_states();
+     */
     cpu_synchronize_all_states();
 
     switch (reason) {
@@ -768,6 +786,10 @@ void qemu_system_debug_request(void)
     qemu_notify_event();
 }
 
+/*
+ * 在以下使用main_loop_should_exit():
+ *   - system/runstate.c|834| <<qemu_main_loop>> while (!main_loop_should_exit(&status)) {
+ */
 static bool main_loop_should_exit(int *status)
 {
     RunState r;
@@ -827,10 +849,17 @@ static bool main_loop_should_exit(int *status)
     return false;
 }
 
+/*
+ * 在以下使用qemu_main_loop():
+ *   - system/main.c|50| <<qemu_default_main>> status = qemu_main_loop();
+ */
 int qemu_main_loop(void)
 {
     int status = EXIT_SUCCESS;
 
+    /*
+     * 只在此处调用main_loop_should_exit()
+     */
     while (!main_loop_should_exit(&status)) {
         main_loop_wait(false);
     }
@@ -888,6 +917,10 @@ void qemu_init_subsystems(void)
 }
 
 
+/*
+ * 在以下使用qemu_cleanup():
+ *   - system/main.c|51| <<qemu_default_main>> qemu_cleanup(status);
+ */
 void qemu_cleanup(int status)
 {
     gdb_exit(status);
diff --git a/system/vl.c b/system/vl.c
index ec93988a0..fc71f90f5 100644
--- a/system/vl.c
+++ b/system/vl.c
@@ -2707,6 +2707,9 @@ static void qemu_init_board(void)
     /* process plugin before CPUs are created, but once -smp has been parsed */
     qemu_plugin_load_list(&plugin_list, &error_fatal);
 
+    /*
+     * 只在此处调用
+     */
     /* From here on we enter MACHINE_PHASE_INITIALIZED.  */
     machine_run_board_init(current_machine, mem_path, &error_fatal);
 
@@ -2837,6 +2840,11 @@ void qmp_x_exit_preconfig(Error **errp)
     }
 }
 
+/*
+ * 在以下调用qemu_init():
+ *   - system/main.c|71| <<main>> qemu_init(argc, argv);
+ *   - tests/qtest/fuzz/fuzz.c|228| <<LLVMFuzzerInitialize>> qemu_init(result.we_wordc, result.we_wordv);
+ */
 void qemu_init(int argc, char **argv)
 {
     QemuOpts *opts;
diff --git a/target/i386/cpu-apic.c b/target/i386/cpu-apic.c
index c1708b04b..5168776ea 100644
--- a/target/i386/cpu-apic.c
+++ b/target/i386/cpu-apic.c
@@ -19,6 +19,13 @@
 #include "hw/i386/apic_internal.h"
 #include "cpu-internal.h"
 
+/*
+ * 在以下使用apic_get_class():
+ *   - hw/i386/amd_iommu.c|1400| <<amdvi_mem_ir_write>> apic_get_class(NULL)->send_msi(&to);
+ *   - hw/i386/intel_iommu.c|468| <<vtd_generate_interrupt>> apic_get_class(NULL)->send_msi(&msi);
+ *   - hw/i386/intel_iommu.c|4126| <<vtd_mem_ir_write>> apic_get_class(NULL)->send_msi(&to);
+ *   - target/i386/cpu-apic.c|77| <<x86_cpu_apic_create>> APICCommonClass *apic_class = apic_get_class(errp);
+ */
 APICCommonClass *apic_get_class(Error **errp)
 {
     const char *apic_type = "apic";
@@ -39,6 +46,38 @@ APICCommonClass *apic_get_class(Error **errp)
     return APIC_COMMON_CLASS(object_class_by_name(apic_type));
 }
 
+/*
+ * (gdb) bt
+ * #0  apic_common_set_id (obj=0x55555755d140, v=0x55555778f340, name=0x555556393d55 "id", opaque=0x0, errp=0x5555573a2118 <error_abort>) at ../hw/intc/apic_common.c:431
+ * #1  0x0000555555f26c07 in object_property_set (obj=0x55555755d140, name=0x555556393d55 "id", v=0x55555778f340, errp=0x5555573a2118 <error_abort>) at ../qom/object.c:1449
+ * #2  0x0000555555f2ba94 in object_property_set_qobject (obj=0x55555755d140, name=0x555556393d55 "id", value=0x55555775d1d0, errp=0x5555573a2118 <error_abort>)
+ *     at ../qom/qom-qobject.c:28
+ * #3  0x0000555555f27138 in object_property_set_int (obj=0x55555755d140, name=0x555556393d55 "id", value=1, errp=0x5555573a2118 <error_abort>) at ../qom/object.c:1552
+ * #4  0x0000555555f1bc8a in qdev_prop_set_uint32 (dev=0x55555755d140, name=0x555556393d55 "id", value=1) at ../hw/core/qdev-properties.c:851
+ * #5  0x0000555555d1a64e in x86_cpu_apic_create (cpu=0x555557785d90, errp=0x7fffffffd458) at ../target/i386/cpu-apic.c:66
+ * #6  0x0000555555daaf63 in x86_cpu_realizefn (dev=0x555557785d90, errp=0x7fffffffd520) at ../target/i386/cpu.c:8342
+ * #7  0x0000555555da3bf3 in max_x86_cpu_realize (dev=0x555557785d90, errp=0x7fffffffd520) at ../target/i386/cpu.c:5689
+ * #8  0x0000555555f1e213 in device_set_realized (obj=0x555557785d90, value=true, errp=0x7fffffffd630) at ../hw/core/qdev.c:494
+ * #9  0x0000555555f29192 in property_set_bool (obj=0x555557785d90, v=0x55555778ed20, name=0x5555563e9969 "realized", opaque=0x555557460d40, errp=0x7fffffffd630)
+ *     at ../qom/object.c:2374
+ * #10 0x0000555555f26c07 in object_property_set (obj=0x555557785d90, name=0x5555563e9969 "realized", v=0x55555778ed20, errp=0x7fffffffd630) at ../qom/object.c:1449
+ * #11 0x0000555555f2ba94 in object_property_set_qobject (obj=0x555557785d90, name=0x5555563e9969 "realized", value=0x55555778c910, errp=0x5555573a2120 <error_fatal>)
+ *     at ../qom/qom-qobject.c:28
+ * #12 0x0000555555f26fac in object_property_set_bool (obj=0x555557785d90, name=0x5555563e9969 "realized", value=true, errp=0x5555573a2120 <error_fatal>) at ../qom/object.c:1519
+ * #13 0x0000555555f1d90b in qdev_realize (dev=0x555557785d90, bus=0x0, errp=0x5555573a2120 <error_fatal>) at ../hw/core/qdev.c:276
+ * #14 0x0000555555d591ec in x86_cpu_new (x86ms=0x5555576d8c50, apic_id=1, errp=0x5555573a2120 <error_fatal>) at ../hw/i386/x86-common.c:63
+ * #15 0x0000555555d59366 in x86_cpus_init (x86ms=0x5555576d8c50, default_cpu_version=1) at ../hw/i386/x86-common.c:114
+ * #16 0x0000555555d612c5 in pc_q35_init (machine=0x5555576d8c50) at ../hw/i386/pc_q35.c:191
+ * #17 0x0000555555d61c95 in pc_q35_machine_10_0_init (machine=0x5555576d8c50) at ../hw/i386/pc_q35.c:369
+ * #18 0x000055555597d861 in machine_run_board_init (machine=0x5555576d8c50, mem_path=0x0, errp=0x7fffffffd900) at ../hw/core/machine.c:1682
+ * #19 0x0000555555c35477 in qemu_init_board () at ../system/vl.c:2711
+ * #20 0x0000555555c3581c in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2807
+ * #21 0x0000555555c38346 in qemu_init (argc=21, argv=0x7fffffffdc28) at ../system/vl.c:3843
+ * #22 0x00005555560d2905 in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:71
+ *
+ * 在以下使用x86_cpu_apic_create():
+ *   - target/i386/cpu.c|8342| <<x86_cpu_realizefn>> x86_cpu_apic_create(cpu, &local_err);
+ */
 void x86_cpu_apic_create(X86CPU *cpu, Error **errp)
 {
     APICCommonState *apic;
@@ -88,6 +127,136 @@ void x86_cpu_apic_realize(X86CPU *cpu, Error **errp)
      }
 }
 
+/*
+ * 一共有下面的几个field.
+ *
+ * X86CPU->apic_id
+ * CPUState->cpu_index
+ * APICCommonState->initial_apic_id
+ *
+ *
+ * QEMU通过ioctl创建vCPU的时候是通过kvm_arch_vcpu_id()和KVM进行match的.
+ * i386下kvm_arch_vcpu_id()就是用的cpu->apic_id.
+ *
+ * 844 unsigned long kvm_arch_vcpu_id(CPUState *cs)
+ * 845 {
+ * 846     X86CPU *cpu = X86_CPU(cs);
+ * 847     return cpu->apic_id;
+ * 848 }
+ *
+ * X86CPU->apic_id是QEMU通过topology计算的.
+ *
+ * 这个被通过apic_common_set_id()设置成APICCommonState->initial_apic_id.
+ *
+ * (gdb) bt
+ * #0  apic_common_set_id (obj=0x55555755d140, v=0x55555778f340, name=0x555556393d55 "id", opaque=0x0, errp=0x5555573a2118 <error_abort>) at ../hw/intc/apic_common.c:431
+ * #1  0x0000555555f26c07 in object_property_set (obj=0x55555755d140, name=0x555556393d55 "id", v=0x55555778f340, errp=0x5555573a2118 <error_abort>) at ../qom/object.c:1449
+ * #2  0x0000555555f2ba94 in object_property_set_qobject (obj=0x55555755d140, name=0x555556393d55 "id", value=0x55555775d1d0, errp=0x5555573a2118 <error_abort>)
+ *     at ../qom/qom-qobject.c:28
+ *     0x0000555555f27138 in object_property_set_int (obj=0x55555755d140, name=0x555556393d55 "id", value=1, errp=0x5555573a2118 <error_abort>) at ../qom/object.c:1552
+ *     0x0000555555f1bc8a in qdev_prop_set_uint32 (dev=0x55555755d140, name=0x555556393d55 "id", value=1) at ../hw/core/qdev-properties.c:851
+ * #5  0x0000555555d1a64e in x86_cpu_apic_create (cpu=0x555557785d90, errp=0x7fffffffd458) at ../target/i386/cpu-apic.c:66
+ * #6  0x0000555555daaf63 in x86_cpu_realizefn (dev=0x555557785d90, errp=0x7fffffffd520) at ../target/i386/cpu.c:8342
+ * #7  0x0000555555da3bf3 in max_x86_cpu_realize (dev=0x555557785d90, errp=0x7fffffffd520) at ../target/i386/cpu.c:5689
+ * #8  0x0000555555f1e213 in device_set_realized (obj=0x555557785d90, value=true, errp=0x7fffffffd630) at ../hw/core/qdev.c:494
+ * #9  0x0000555555f29192 in property_set_bool (obj=0x555557785d90, v=0x55555778ed20, name=0x5555563e9969 "realized", opaque=0x555557460d40, errp=0x7fffffffd630)
+ *     at ../qom/object.c:2374
+ * #10 0x0000555555f26c07 in object_property_set (obj=0x555557785d90, name=0x5555563e9969 "realized", v=0x55555778ed20, errp=0x7fffffffd630) at ../qom/object.c:1449
+ * #11 0x0000555555f2ba94 in object_property_set_qobject (obj=0x555557785d90, name=0x5555563e9969 "realized", value=0x55555778c910, errp=0x5555573a2120 <error_fatal>)
+ *     at ../qom/qom-qobject.c:28
+ * #12 0x0000555555f26fac in object_property_set_bool (obj=0x555557785d90, name=0x5555563e9969 "realized", value=true, errp=0x5555573a2120 <error_fatal>) at ../qom/object.c:1519
+ * #13 0x0000555555f1d90b in qdev_realize (dev=0x555557785d90, bus=0x0, errp=0x5555573a2120 <error_fatal>) at ../hw/core/qdev.c:276
+ * #14 0x0000555555d591ec in x86_cpu_new (x86ms=0x5555576d8c50, apic_id=1, errp=0x5555573a2120 <error_fatal>) at ../hw/i386/x86-common.c:63
+ * #15 0x0000555555d59366 in x86_cpus_init (x86ms=0x5555576d8c50, default_cpu_version=1) at ../hw/i386/x86-common.c:114
+ * #16 0x0000555555d612c5 in pc_q35_init (machine=0x5555576d8c50) at ../hw/i386/pc_q35.c:191
+ * #17 0x0000555555d61c95 in pc_q35_machine_10_0_init (machine=0x5555576d8c50) at ../hw/i386/pc_q35.c:369
+ * #18 0x000055555597d861 in machine_run_board_init (machine=0x5555576d8c50, mem_path=0x0, errp=0x7fffffffd900) at ../hw/core/machine.c:1682
+ * #19 0x0000555555c35477 in qemu_init_board () at ../system/vl.c:2711
+ * #20 0x0000555555c3581c in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2807
+ * #21 0x0000555555c38346 in qemu_init (argc=21, argv=0x7fffffffdc28) at ../system/vl.c:3843
+ * #22 0x00005555560d2905 in main (argc=21, argv=0x7fffffffdc28) at ../system/main.c:71
+ *
+ * 尽管vcpu_id是cpu->apic_id, 创建的pthread的name是用的CPUState->cpu_index。
+ *
+ *  99 static void kvm_start_vcpu_thread(CPUState *cpu)
+ * 100 {
+ * 101     char thread_name[VCPU_THREAD_NAME_SIZE];
+ * 102
+ * 103     snprintf(thread_name, VCPU_THREAD_NAME_SIZE, "CPU %d/KVM",
+ * 104              cpu->cpu_index);
+ * 105     qemu_thread_create(cpu->thread, thread_name, kvm_vcpu_thread_fn,
+ * 106                        cpu, QEMU_THREAD_JOINABLE);
+ * 107 }
+ *
+ *
+ * CPUState->cpu_index是在cpu_list_add()分配的.
+ *
+ * 85 void cpu_list_add(CPUState *cpu)
+ * 86 {
+ * 87     static bool cpu_index_auto_assigned;
+ * 88
+ * 89     QEMU_LOCK_GUARD(&qemu_cpu_list_lock);
+ * 90     if (cpu->cpu_index == UNASSIGNED_CPU_INDEX) {
+ * 91         cpu_index_auto_assigned = true;
+ * 92         cpu->cpu_index = cpu_get_free_index();
+ * 93         assert(cpu->cpu_index != UNASSIGNED_CPU_INDEX);
+ * 94     } else {
+ * 95         assert(!cpu_index_auto_assigned);
+ * 96     }
+ * 97     QTAILQ_INSERT_TAIL_RCU(&cpus_queue, cpu, node);
+ * 98     cpu_list_generation_id++;
+ * 99 }
+ *
+ * (gdb) bt
+ * #0  cpu_list_add (cpu=0x5555577657b0) at ../cpu-common.c:82
+ * #1  0x000055555588b9de in cpu_exec_realizefn (cpu=0x5555577657b0, errp=0x7fffffffd428) at ../hw/core/cpu-common.c:193
+ * #2  0x0000555555daa8ef in x86_cpu_realizefn (dev=0x5555577657b0, errp=0x7fffffffd4f0) at ../target/i386/cpu.c:8185
+ * #3  0x0000555555da3bf3 in max_x86_cpu_realize (dev=0x5555577657b0, errp=0x7fffffffd4f0) at ../target/i386/cpu.c:5689
+ * #4  0x0000555555f1e213 in device_set_realized (obj=0x5555577657b0, value=true, errp=0x7fffffffd600) at ../hw/core/qdev.c:494
+ * #5  0x0000555555f29192 in property_set_bool (obj=0x5555577657b0, v=0x55555776e660, name=0x5555563e9969 "realized", opaque=0x555557461080, errp=0x7fffffffd600)
+ *     at ../qom/object.c:2374
+ * #6  0x0000555555f26c07 in object_property_set (obj=0x5555577657b0, name=0x5555563e9969 "realized", v=0x55555776e660, errp=0x7fffffffd600) at ../qom/object.c:1449
+ * #7  0x0000555555f2ba94 in object_property_set_qobject (obj=0x5555577657b0, name=0x5555563e9969 "realized", value=0x55555776c2b0, errp=0x5555573a2120 <error_fatal>)
+ *     at ../qom/qom-qobject.c:28
+ * #8  0x0000555555f26fac in object_property_set_bool (obj=0x5555577657b0, name=0x5555563e9969 "realized", value=true, errp=0x5555573a2120 <error_fatal>)
+ *     at ../qom/object.c:1519
+ * #9  0x0000555555f1d90b in qdev_realize (dev=0x5555577657b0, bus=0x0, errp=0x5555573a2120 <error_fatal>) at ../hw/core/qdev.c:276
+ * #10 0x0000555555d591ec in x86_cpu_new (x86ms=0x5555576d6810, apic_id=1, errp=0x5555573a2120 <error_fatal>) at ../hw/i386/x86-common.c:63
+ * #11 0x0000555555d59366 in x86_cpus_init (x86ms=0x5555576d6810, default_cpu_version=1) at ../hw/i386/x86-common.c:114
+ * #12 0x0000555555d612c5 in pc_q35_init (machine=0x5555576d6810) at ../hw/i386/pc_q35.c:191
+ * #13 0x0000555555d61c95 in pc_q35_machine_10_0_init (machine=0x5555576d6810) at ../hw/i386/pc_q35.c:369
+ * #14 0x000055555597d861 in machine_run_board_init (machine=0x5555576d6810, mem_path=0x0, errp=0x7fffffffd8d0) at ../hw/core/machine.c:1682
+ * #15 0x0000555555c35477 in qemu_init_board () at ../system/vl.c:2711
+ * #16 0x0000555555c3581c in qmp_x_exit_preconfig (errp=0x5555573a2120 <error_fatal>) at ../system/vl.c:2807
+ * #17 0x0000555555c38346 in qemu_init (argc=25, argv=0x7fffffffdbf8) at ../system/vl.c:3843
+ * #18 0x00005555560d294a in main (argc=25, argv=0x7fffffffdbf8) at ../system/main.c:71
+ *
+ *
+ * (qemu) info lapic 1 ==> cpu->apic_id
+ * dumping local APIC state for CPU 1 ==> CPU(cpu)->cpu_index
+ *
+ * LVT0	 0x00010700 active-hi edge  masked                      ExtINT (vec 0)
+ * LVT1	 0x00010400 active-hi edge  masked                      NMI
+ * LVTPC	 0x00000400 active-hi edge                              NMI
+ * LVTERR	 0x000000fe active-hi edge                              Fixed  (vec 254)
+ * LVTTHMR	 0x00010000 active-hi edge  masked                      Fixed  (vec 0)
+ * LVTT	 0x000400ec active-hi edge                 tsc-deadline Fixed  (vec 236)
+ * Timer	 DCR=0x0 (divide by 2) initial_count = 0 current_count = 0
+ * SPIV	 0x000001ff APIC enabled, focus=off, spurious vec 255
+ * ICR	 0x000000fd physical edge de-assert no-shorthand
+ * ICR2	 0x00000000 cpu 0 (X2APIC ID)
+ * ESR	 0x00000000
+ * ISR	 (none)
+ * IRR	 (none)
+ *
+ * APR 0x00 TPR 0x10 DFR 0x0f LDR 0x00 PPR 0x10
+ */
+
+/*
+ * 在以下使用kvm_apic_put():
+ *   - hw/i386/kvm/apic.c|188| <<kvm_apic_post_load>> run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
+ *   - hw/i386/kvm/apic.c|257| <<kvm_apic_reset>> run_on_cpu(CPU(s->cpu), kvm_apic_put, RUN_ON_CPU_HOST_PTR(s));
+ */
 void hmp_info_local_apic(Monitor *mon, const QDict *qdict)
 {
     CPUState *cs;
@@ -95,6 +264,11 @@ void hmp_info_local_apic(Monitor *mon, const QDict *qdict)
     if (qdict_haskey(qdict, "apic-id")) {
         int id = qdict_get_try_int(qdict, "apic-id", 0);
 
+        /*
+	 * 用的X86CPU->apic_id.
+	 * x86_cpu_get_arch_id
+	 * x86_cpu_get_arch_id()返回cpu->apic_id
+	 */
         cs = cpu_by_arch_id(id);
         if (cs) {
             cpu_synchronize_state(cs);
diff --git a/target/i386/cpu-dump.c b/target/i386/cpu-dump.c
index a72ed93bd..b4863bd90 100644
--- a/target/i386/cpu-dump.c
+++ b/target/i386/cpu-dump.c
@@ -157,6 +157,10 @@ done:
 /* ARRAY_SIZE check is not required because
  * DeliveryMode(dm) has a size of 3 bit.
  */
+/*
+ * 在以下使用dm2str():
+ *   - target/i386/cpu-dump.c|188| <<dump_apic_lvt>> dm2str(dm));
+ */
 static inline const char *dm2str(uint32_t dm)
 {
     static const char *str[] = {
@@ -172,6 +176,15 @@ static inline const char *dm2str(uint32_t dm)
     return str[dm];
 }
 
+/*
+ * 在以下使用dump_apic_lvt():
+ *   - target/i386/cpu-dump.c|311| <<x86_cpu_dump_local_apic_state>> dump_apic_lvt("LVT0", lvt[APIC_LVT_LINT0], false);
+ *   - target/i386/cpu-dump.c|312| <<x86_cpu_dump_local_apic_state>> dump_apic_lvt("LVT1", lvt[APIC_LVT_LINT1], false);
+ *   - target/i386/cpu-dump.c|313| <<x86_cpu_dump_local_apic_state>> dump_apic_lvt("LVTPC", lvt[APIC_LVT_PERFORM], false);
+ *   - target/i386/cpu-dump.c|314| <<x86_cpu_dump_local_apic_state>> dump_apic_lvt("LVTERR", lvt[APIC_LVT_ERROR], false);
+ *   - target/i386/cpu-dump.c|315| <<x86_cpu_dump_local_apic_state>> dump_apic_lvt("LVTTHMR", lvt[APIC_LVT_THERMAL], false);
+ *   - target/i386/cpu-dump.c|316| <<x86_cpu_dump_local_apic_state>> dump_apic_lvt("LVTT", lvt[APIC_LVT_TIMER], true);
+ */
 static void dump_apic_lvt(const char *name, uint32_t lvt, bool is_timer)
 {
     uint32_t dm = (lvt & APIC_LVT_DELIV_MOD) >> APIC_LVT_DELIV_MOD_SHIFT;
@@ -196,6 +209,10 @@ static void dump_apic_lvt(const char *name, uint32_t lvt, bool is_timer)
 /* ARRAY_SIZE check is not required because
  * destination shorthand has a size of 2 bit.
  */
+/*
+ * 在以下使用shorthand2str():
+ *   - target/i386/cpu-dump.c|243| <<dump_apic_icr>> shorthand2str(dest_shorthand));
+ */
 static inline const char *shorthand2str(uint32_t shorthand)
 {
     const char *str[] = {
@@ -221,6 +238,10 @@ static inline void mask2str(char *str, uint32_t val, uint8_t size)
 
 #define MAX_LOGICAL_APIC_ID_MASK_SIZE 16
 
+/*
+ * 在以下使用dump_apic_icr():
+ *   - target/i386/cpu-dump.c|322| <<x86_cpu_dump_local_apic_state>> dump_apic_icr(s, &cpu->env);
+ */
 static void dump_apic_icr(APICCommonState *s, CPUX86State *env)
 {
     uint32_t icr = s->icr[0], icr2 = s->icr[1];
@@ -288,6 +309,10 @@ static void dump_apic_interrupt(const char *name, uint32_t *ireg_tab,
     qemu_printf("%s\n", empty ? "(none)" : "");
 }
 
+/*
+ * 在以下使用x86_cpu_dump_local_apic_state():
+ *   - target/i386/cpu-apic.c|155| <<hmp_info_local_apic>> x86_cpu_dump_local_apic_state(cs, CPU_DUMP_FPU);
+ */
 void x86_cpu_dump_local_apic_state(CPUState *cs, int flags)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -323,6 +348,12 @@ void x86_cpu_dump_local_apic_state(CPUState *cs, int flags)
 
     qemu_printf("ESR\t 0x%08x\n", s->esr);
 
+    /*
+     * struct APICCommonState:
+     * -> uint32_t isr[8];
+     * -> uint32_t tmr[8];
+     * -> uint32_t irr[8];
+     */
     dump_apic_interrupt("ISR", s->isr, s->tmr);
     dump_apic_interrupt("IRR", s->irr, s->tmr);
 
@@ -341,6 +372,10 @@ void x86_cpu_dump_local_apic_state(CPUState *cs, int flags)
 #define DUMP_CODE_BYTES_TOTAL    50
 #define DUMP_CODE_BYTES_BACKWARD 20
 
+/*
+ * 在以下使用x86_cpu_dump_state():
+ *   - target/i386/cpu.c|8933| <<x86_cpu_common_class_init>> cc->dump_state = x86_cpu_dump_state;
+ */
 void x86_cpu_dump_state(CPUState *cs, FILE *f, int flags)
 {
     X86CPU *cpu = X86_CPU(cs);
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 1b64ceaab..621d713ee 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -7447,6 +7447,10 @@ static bool cpuid_has_xsave_feature(CPUX86State *env, const ExtSaveArea *esa)
     return false;
 }
 
+/*
+ * 在以下使用x86_cpu_reset_hold():
+ *   - target/i386/cpu.c|8922| <<x86_cpu_common_class_init>> resettable_class_set_parent_phases(rc, NULL, x86_cpu_reset_hold, NULL,
+ */
 static void x86_cpu_reset_hold(Object *obj, ResetType type)
 {
     CPUState *cs = CPU(obj);
@@ -7523,6 +7527,22 @@ static void x86_cpu_reset_hold(Object *obj, ResetType type)
 
     env->pat = 0x0007040600070406ULL;
 
+    /*
+     * 在以下使用CPUX86State->tsc:
+     *   - target/i386/machine.c|1724| <<global>> VMSTATE_UINT64(env.tsc, X86CPU),
+     *   - hw/i386/kvm/clock.c|70| <<kvmclock_current_nsec>> uint64_t migration_tsc = env->tsc;
+     *   - target/i386/cpu.c|7535| <<x86_cpu_reset_hold>> if (env->tsc != 0) {
+     *   - target/i386/cpu.c|7536| <<x86_cpu_reset_hold>> env->tsc = 1;
+     *   - target/i386/cpu.c|7539| <<x86_cpu_reset_hold>> env->tsc = 0;
+     *   - target/i386/hvf/x86hvf.c|236| <<hvf_get_msrs>> env->tsc = rdtscp() + rvmcs(cs->accel->fd, VMCS_TSC_OFFSET);
+     *   - target/i386/kvm/kvm.c|329| <<kvm_get_tsc>> env->tsc = value;
+     *   - target/i386/kvm/kvm.c|4013| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
+     *   - target/i386/kvm/kvm.c|4752| <<kvm_get_msrs>> env->tsc = msrs[i].data;
+     *   - target/i386/nvmm/nvmm-all.c|181| <<nvmm_set_registers>> state->msrs[NVMM_X64_MSR_TSC] = env->tsc;
+     *   - target/i386/nvmm/nvmm-all.c|336| <<nvmm_get_registers>> env->tsc = state->msrs[NVMM_X64_MSR_TSC];
+     *   - target/i386/whpx/whpx-all.c|347| <<whpx_set_tsc>> tsc_val.Reg64 = cpu_env(cpu)->tsc;
+     *   - target/i386/whpx/whpx-all.c|570| <<whpx_get_tsc>> cpu_env(cpu)->tsc = tsc_val.Reg64;
+     */
     if (kvm_enabled()) {
         /*
          * KVM handles TSC = 0 specially and thinks we are hot-plugging
@@ -8176,6 +8196,28 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
 
     x86_cpu_set_sgxlepubkeyhash(env);
 
+    /*
+     * 在以下使用cpu_exec_realizefn():
+     *   - target/alpha/cpu.c|106| <<alpha_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/arm/cpu.c|2080| <<arm_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/avr/cpu.c|116| <<avr_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/hexagon/cpu.c|300| <<hexagon_cpu_realize>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/hppa/cpu.c|182| <<hppa_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/i386/cpu.c|8189| <<x86_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/loongarch/cpu.c|640| <<loongarch_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/m68k/cpu.c|367| <<m68k_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/microblaze/cpu.c|243| <<mb_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/mips/cpu.c|479| <<mips_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/openrisc/cpu.c|162| <<openrisc_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/ppc/cpu_init.c|6929| <<ppc_cpu_realize>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/riscv/cpu.c|1287| <<riscv_cpu_realize>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/rx/cpu.c|138| <<rx_cpu_realize>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/s390x/cpu.c|252| <<s390_cpu_realizefn>> cpu_exec_realizefn(cs, &err);
+     *   - target/sh4/cpu.c|229| <<superh_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/sparc/cpu.c|890| <<sparc_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/tricore/cpu.c|92| <<tricore_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     *   - target/xtensa/cpu.c|174| <<xtensa_cpu_realizefn>> cpu_exec_realizefn(cs, &local_err);
+     */
     /*
      * note: the call to the framework needs to happen after feature expansion,
      * but before the checks/modifications to ucode_rev, mwait, phys_bits.
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index 76f24446a..6ef13cead 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -2085,6 +2085,22 @@ typedef struct CPUArchState {
     int64_t tsc_khz;
     int64_t user_tsc_khz; /* for sanity check only */
     uint64_t apic_bus_freq;
+    /*
+     * 在以下使用CPUX86State->tsc:
+     *   - target/i386/machine.c|1724| <<global>> VMSTATE_UINT64(env.tsc, X86CPU),
+     *   - hw/i386/kvm/clock.c|70| <<kvmclock_current_nsec>> uint64_t migration_tsc = env->tsc;
+     *   - target/i386/cpu.c|7535| <<x86_cpu_reset_hold>> if (env->tsc != 0) { 
+     *   - target/i386/cpu.c|7536| <<x86_cpu_reset_hold>> env->tsc = 1;
+     *   - target/i386/cpu.c|7539| <<x86_cpu_reset_hold>> env->tsc = 0;
+     *   - target/i386/hvf/x86hvf.c|236| <<hvf_get_msrs>> env->tsc = rdtscp() + rvmcs(cs->accel->fd, VMCS_TSC_OFFSET);
+     *   - target/i386/kvm/kvm.c|329| <<kvm_get_tsc>> env->tsc = value;
+     *   - target/i386/kvm/kvm.c|4013| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
+     *   - target/i386/kvm/kvm.c|4752| <<kvm_get_msrs>> env->tsc = msrs[i].data;
+     *   - target/i386/nvmm/nvmm-all.c|181| <<nvmm_set_registers>> state->msrs[NVMM_X64_MSR_TSC] = env->tsc;
+     *   - target/i386/nvmm/nvmm-all.c|336| <<nvmm_get_registers>> env->tsc = state->msrs[NVMM_X64_MSR_TSC];
+     *   - target/i386/whpx/whpx-all.c|347| <<whpx_set_tsc>> tsc_val.Reg64 = cpu_env(cpu)->tsc;
+     *   - target/i386/whpx/whpx-all.c|570| <<whpx_get_tsc>> cpu_env(cpu)->tsc = tsc_val.Reg64;
+     */
     uint64_t tsc;
 #if defined(CONFIG_KVM) || defined(CONFIG_HVF)
     void *xsave_buf;
@@ -2686,6 +2702,10 @@ static inline bool cpu_has_svm(CPUX86State *env)
  * VMX is being used by examining CR4.VMXE. Otherwise, we cannot
  * know for certain.
  */
+/*
+ * 在以下使用cpu_vmx_maybe_enabled():
+ *   - target/i386/machine.c|264| <<cpu_pre_save>> if (kvm_enabled() && cpu_vmx_maybe_enabled(env) &&
+ */
 static inline bool cpu_vmx_maybe_enabled(CPUX86State *env)
 {
     return cpu_has_vmx(env) &&
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 6c749d4ee..0d13d874a 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -274,13 +274,27 @@ static bool kvm_x2apic_api_set_flags(uint64_t flags)
         _result = fn; \
     })
 
+/*
+ * 在以下使用has_x2apic_api:
+ *   - target/i386/kvm/kvm.c|281| <<kvm_has_x2apic_api>> return has_x2apic_api;
+ *   - target/i386/kvm/kvm.c|289| <<kvm_enable_x2apic>> has_x2apic_api);
+ */
 static bool has_x2apic_api;
 
 bool kvm_has_x2apic_api(void)
 {
+    /*
+     * false概率还挺大?
+     */
     return has_x2apic_api;
 }
 
+/*
+ * 在以下使用kvm_enable_x2apic():
+ *   - hw/i386/intel_iommu.c|4741| <<vtd_decide_config>> if (kvm_irqchip_is_split() && !kvm_enable_x2apic()) {
+ *   - hw/i386/x86-common.c|98| <<x86_cpus_init>> if (kvm_enabled() && x86ms->apic_id_limit > 255 &&
+ *                kvm_irqchip_in_kernel() && !kvm_enable_x2apic()) {
+ */
 bool kvm_enable_x2apic(void)
 {
     return MEMORIZE(
@@ -294,6 +308,10 @@ bool kvm_hv_vpindex_settable(void)
     return hv_vpindex_settable;
 }
 
+/*
+ * 在以下使用kvm_get_tsc():
+ *   - target/i386/kvm/kvm.c|362| <<do_kvm_synchronize_tsc>> kvm_get_tsc(cpu);
+ */
 static int kvm_get_tsc(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -307,11 +325,38 @@ static int kvm_get_tsc(CPUState *cs)
 
     env->tsc_valid = !runstate_is_running();
 
+    /*
+     * 在以下使用MSR_IA32_TSC:
+     *   - target/i386/hvf/hvf.c|334| <<hvf_arch_init_vcpu>> hv_vcpu_enable_native_msr(cpu->accel->fd, MSR_IA32_TSC, 1);
+     *   - target/i386/hvf/hvf.c|492| <<hvf_simulate_rdmsr>> case MSR_IA32_TSC:
+     *   - target/i386/hvf/hvf.c|597| <<hvf_simulate_wrmsr>> case MSR_IA32_TSC:
+     *   - target/i386/kvm/kvm.c|324| <<kvm_get_tsc>> ret = kvm_get_one_msr(cpu, MSR_IA32_TSC, &value);
+     *   - target/i386/kvm/kvm.c|2434| <<kvm_arch_reset_parked_vcpu>> msrs->entries[0].index = MSR_IA32_TSC;
+     *   - target/i386/kvm/kvm.c|4013| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
+     *   - target/i386/kvm/kvm.c|4476| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);
+     *   - target/i386/kvm/kvm.c|4751| <<kvm_get_msrs>> case MSR_IA32_TSC:
+     */
     ret = kvm_get_one_msr(cpu, MSR_IA32_TSC, &value);
     if (ret < 0) {
         return ret;
     }
 
+    /*
+     * 在以下使用CPUX86State->tsc:
+     *   - target/i386/machine.c|1724| <<global>> VMSTATE_UINT64(env.tsc, X86CPU),
+     *   - hw/i386/kvm/clock.c|70| <<kvmclock_current_nsec>> uint64_t migration_tsc = env->tsc;
+     *   - target/i386/cpu.c|7535| <<x86_cpu_reset_hold>> if (env->tsc != 0) {
+     *   - target/i386/cpu.c|7536| <<x86_cpu_reset_hold>> env->tsc = 1;
+     *   - target/i386/cpu.c|7539| <<x86_cpu_reset_hold>> env->tsc = 0;
+     *   - target/i386/hvf/x86hvf.c|236| <<hvf_get_msrs>> env->tsc = rdtscp() + rvmcs(cs->accel->fd, VMCS_TSC_OFFSET);
+     *   - target/i386/kvm/kvm.c|329| <<kvm_get_tsc>> env->tsc = value;
+     *   - target/i386/kvm/kvm.c|4013| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
+     *   - target/i386/kvm/kvm.c|4752| <<kvm_get_msrs>> env->tsc = msrs[i].data;
+     *   - target/i386/nvmm/nvmm-all.c|181| <<nvmm_set_registers>> state->msrs[NVMM_X64_MSR_TSC] = env->tsc;
+     *   - target/i386/nvmm/nvmm-all.c|336| <<nvmm_get_registers>> env->tsc = state->msrs[NVMM_X64_MSR_TSC];
+     *   - target/i386/whpx/whpx-all.c|347| <<whpx_set_tsc>> tsc_val.Reg64 = cpu_env(cpu)->tsc;
+     *   - target/i386/whpx/whpx-all.c|570| <<whpx_get_tsc>> cpu_env(cpu)->tsc = tsc_val.Reg64;
+     */
     env->tsc = value;
     return 0;
 }
@@ -860,6 +905,11 @@ static inline bool freq_within_bounds(int freq, int target_freq)
         return false;
 }
 
+/*
+ * 在以下使用kvm_arch_set_tsc_khz():
+ *   - target/i386/kvm/kvm.c|2098| <<kvm_arch_init_vcpu>> r = kvm_arch_set_tsc_khz(cs);
+ *   - target/i386/kvm/kvm.c|5361| <<kvm_arch_put_registers>> kvm_arch_set_tsc_khz(cpu);
+ */
 static int kvm_arch_set_tsc_khz(CPUState *cs)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -2417,6 +2467,17 @@ void kvm_arch_reset_parked_vcpu(unsigned long vcpu_id, int kvm_fd)
     g_autofree struct kvm_msrs *msrs = NULL;
 
     msrs = g_malloc0(sizeof(*msrs) + sizeof(msrs->entries[0]));
+    /*
+     * 在以下使用MSR_IA32_TSC:
+     *   - target/i386/hvf/hvf.c|334| <<hvf_arch_init_vcpu>> hv_vcpu_enable_native_msr(cpu->accel->fd, MSR_IA32_TSC, 1);
+     *   - target/i386/hvf/hvf.c|492| <<hvf_simulate_rdmsr>> case MSR_IA32_TSC:
+     *   - target/i386/hvf/hvf.c|597| <<hvf_simulate_wrmsr>> case MSR_IA32_TSC:
+     *   - target/i386/kvm/kvm.c|324| <<kvm_get_tsc>> ret = kvm_get_one_msr(cpu, MSR_IA32_TSC, &value);
+     *   - target/i386/kvm/kvm.c|2434| <<kvm_arch_reset_parked_vcpu>> msrs->entries[0].index = MSR_IA32_TSC;
+     *   - target/i386/kvm/kvm.c|4013| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
+     *   - target/i386/kvm/kvm.c|4476| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);
+     *   - target/i386/kvm/kvm.c|4751| <<kvm_get_msrs>> case MSR_IA32_TSC:
+     */
     msrs->entries[0].index = MSR_IA32_TSC;
     msrs->entries[0].data = 1; /* match the value in x86_cpu_reset() */
     msrs->nmsrs++;
@@ -3475,6 +3536,10 @@ static int kvm_put_xcrs(X86CPU *cpu)
     return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_XCRS, &xcrs);
 }
 
+/*
+ * 在以下使用kvm_put_sregs():
+ *   - target/i386/kvm/kvm.c|5303| <<kvm_arch_put_registers>> ret = has_sregs2 ? kvm_put_sregs2(x86_cpu) : kvm_put_sregs(x86_cpu);
+ */
 static int kvm_put_sregs(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -3525,6 +3590,10 @@ static int kvm_put_sregs(X86CPU *cpu)
     return kvm_vcpu_ioctl(CPU(cpu), KVM_SET_SREGS, &sregs);
 }
 
+/*
+ * 在以下调用kvm_put_sregs2():
+ *   - target/i386/kvm/kvm.c|5320| <<kvm_arch_put_registers>> ret = has_sregs2 ? kvm_put_sregs2(x86_cpu) : kvm_put_sregs(x86_cpu);
+ */
 static int kvm_put_sregs2(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -3565,6 +3634,16 @@ static int kvm_put_sregs2(X86CPU *cpu)
     sregs.cr4 = env->cr[4];
 
     sregs.cr8 = cpu_get_apic_tpr(cpu->apic_state);
+    /*
+     * 在以下使用cpu_get_apic_base():
+     *   - target/i386/cpu-system.c|259| <<cpu_is_bsp>> return cpu_get_apic_base(cpu->apic_state) & MSR_IA32_APICBASE_BSP;
+     *   - target/i386/hvf/hvf.c|496| <<hvf_simulate_rdmsr>> val = cpu_get_apic_base(cpu->apic_state);
+     *   - target/i386/kvm/kvm.c|3535| <<kvm_put_sregs>> sregs.apic_base = cpu_get_apic_base(cpu->apic_state);
+     *   - target/i386/kvm/kvm.c|3582| <<kvm_put_sregs2>> sregs.apic_base = cpu_get_apic_base(cpu->apic_state);
+     *   - target/i386/nvmm/nvmm-all.c|571| <<nvmm_handle_rdmsr>> val = cpu_get_apic_base(x86_cpu->apic_state);
+     *   - target/i386/tcg/system/misc_helper.c|346| <<helper_rdmsr>> val = cpu_get_apic_base(env_archcpu(env)->apic_state);
+     *   - target/i386/whpx/whpx-all.c|409| <<whpx_set_registers>> vcpu->apic_base = cpu_get_apic_base(x86_cpu->apic_state);
+     */
     sregs.apic_base = cpu_get_apic_base(cpu->apic_state);
 
     sregs.efer = env->efer;
@@ -3626,10 +3705,17 @@ static int kvm_get_one_msr(X86CPU *cpu, int index, uint64_t *value)
     *value = msr_data.entries[0].data;
     return ret;
 }
+/*
+ * 在以下使用kvm_put_apicbase():
+ *   - hw/i386/kvm/apic.c|238| <<kvm_apic_put>> kvm_put_apicbase(s->cpu, s->apicbase);
+ */
 void kvm_put_apicbase(X86CPU *cpu, uint64_t value)
 {
     int ret;
 
+    /*
+     * KVM就在这一个地方用MSR_IA32_APICBASE
+     */
     ret = kvm_put_one_msr(cpu, MSR_IA32_APICBASE, value);
     assert(ret == 1);
 }
@@ -3884,6 +3970,10 @@ static void kvm_init_msrs(X86CPU *cpu)
     assert(kvm_buf_set_msrs(cpu) == 0);
 }
 
+/*
+ * 在以下使用kvm_put_msrs():
+ *   - target/i386/kvm/kvm.c|5495| <<kvm_arch_put_registers>> ret = kvm_put_msrs(x86_cpu, level);
+ */
 static int kvm_put_msrs(X86CPU *cpu, int level)
 {
     CPUX86State *env = &cpu->env;
@@ -3971,6 +4061,32 @@ static int kvm_put_msrs(X86CPU *cpu, int level)
      * for normal writeback. Limit them to reset or full state updates.
      */
     if (level >= KVM_PUT_RESET_STATE) {
+        /*
+	 * 在以下使用MSR_IA32_TSC:
+	 *   - target/i386/hvf/hvf.c|334| <<hvf_arch_init_vcpu>> hv_vcpu_enable_native_msr(cpu->accel->fd, MSR_IA32_TSC, 1);
+	 *   - target/i386/hvf/hvf.c|492| <<hvf_simulate_rdmsr>> case MSR_IA32_TSC:
+	 *   - target/i386/hvf/hvf.c|597| <<hvf_simulate_wrmsr>> case MSR_IA32_TSC:
+	 *   - target/i386/kvm/kvm.c|324| <<kvm_get_tsc>> ret = kvm_get_one_msr(cpu, MSR_IA32_TSC, &value);
+	 *   - target/i386/kvm/kvm.c|2434| <<kvm_arch_reset_parked_vcpu>> msrs->entries[0].index = MSR_IA32_TSC;
+	 *   - target/i386/kvm/kvm.c|4013| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
+	 *   - target/i386/kvm/kvm.c|4476| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);
+	 *   - target/i386/kvm/kvm.c|4751| <<kvm_get_msrs>> case MSR_IA32_TSC:
+	 *
+	 * 在以下使用CPUX86State->tsc:
+         *   - target/i386/machine.c|1724| <<global>> VMSTATE_UINT64(env.tsc, X86CPU),
+         *   - hw/i386/kvm/clock.c|70| <<kvmclock_current_nsec>> uint64_t migration_tsc = env->tsc;
+         *   - target/i386/cpu.c|7535| <<x86_cpu_reset_hold>> if (env->tsc != 0) { 
+         *   - target/i386/cpu.c|7536| <<x86_cpu_reset_hold>> env->tsc = 1;
+         *   - target/i386/cpu.c|7539| <<x86_cpu_reset_hold>> env->tsc = 0;
+         *   - target/i386/hvf/x86hvf.c|236| <<hvf_get_msrs>> env->tsc = rdtscp() + rvmcs(cs->accel->fd, VMCS_TSC_OFFSET);
+         *   - target/i386/kvm/kvm.c|329| <<kvm_get_tsc>> env->tsc = value;
+         *   - target/i386/kvm/kvm.c|4013| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
+         *   - target/i386/kvm/kvm.c|4752| <<kvm_get_msrs>> env->tsc = msrs[i].data;
+         *   - target/i386/nvmm/nvmm-all.c|181| <<nvmm_set_registers>> state->msrs[NVMM_X64_MSR_TSC] = env->tsc;
+         *   - target/i386/nvmm/nvmm-all.c|336| <<nvmm_get_registers>> env->tsc = state->msrs[NVMM_X64_MSR_TSC];
+         *   - target/i386/whpx/whpx-all.c|347| <<whpx_set_tsc>> tsc_val.Reg64 = cpu_env(cpu)->tsc;
+         *   - target/i386/whpx/whpx-all.c|570| <<whpx_get_tsc>> cpu_env(cpu)->tsc = tsc_val.Reg64;
+	 */
         kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
         if (env->features[FEAT_KVM] & (CPUID_KVM_CLOCK | CPUID_KVM_CLOCK2)) {
             kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, env->system_time_msr);
@@ -4261,6 +4377,10 @@ static int kvm_get_xcrs(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * 在以下使用kvm_get_sregs():
+ *   - target/i386/kvm/kvm.c|5432| <<kvm_arch_get_registers>> ret = has_sregs2 ? kvm_get_sregs2(cpu) : kvm_get_sregs(cpu);
+ */
 static int kvm_get_sregs(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -4309,6 +4429,10 @@ static int kvm_get_sregs(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * 在以下使用kvm_get_sregs2():
+ *   - target/i386/kvm/kvm.c|5456| <<kvm_arch_get_registers>> ret = has_sregs2 ? kvm_get_sregs2(cpu) : kvm_get_sregs(cpu);
+ */
 static int kvm_get_sregs2(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -4426,6 +4550,17 @@ static int kvm_get_msrs(X86CPU *cpu)
         kvm_msr_entry_add(cpu, MSR_VIRT_SSBD, 0);
     }
     if (!env->tsc_valid) {
+        /*
+	 * 在以下使用MSR_IA32_TSC:
+	 *   - target/i386/hvf/hvf.c|334| <<hvf_arch_init_vcpu>> hv_vcpu_enable_native_msr(cpu->accel->fd, MSR_IA32_TSC, 1);
+	 *   - target/i386/hvf/hvf.c|492| <<hvf_simulate_rdmsr>> case MSR_IA32_TSC:
+	 *   - target/i386/hvf/hvf.c|597| <<hvf_simulate_wrmsr>> case MSR_IA32_TSC:
+	 *   - target/i386/kvm/kvm.c|324| <<kvm_get_tsc>> ret = kvm_get_one_msr(cpu, MSR_IA32_TSC, &value);
+	 *   - target/i386/kvm/kvm.c|2434| <<kvm_arch_reset_parked_vcpu>> msrs->entries[0].index = MSR_IA32_TSC;
+	 *   - target/i386/kvm/kvm.c|4013| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
+	 *   - target/i386/kvm/kvm.c|4476| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);
+	 *   - target/i386/kvm/kvm.c|4751| <<kvm_get_msrs>> case MSR_IA32_TSC:
+	 */
         kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);
         env->tsc_valid = !runstate_is_running();
     }
@@ -4702,6 +4837,32 @@ static int kvm_get_msrs(X86CPU *cpu)
             break;
 #endif
         case MSR_IA32_TSC:
+            /*
+	     * 在以下使用MSR_IA32_TSC:
+	     *   - target/i386/hvf/hvf.c|334| <<hvf_arch_init_vcpu>> hv_vcpu_enable_native_msr(cpu->accel->fd, MSR_IA32_TSC, 1);
+	     *   - target/i386/hvf/hvf.c|492| <<hvf_simulate_rdmsr>> case MSR_IA32_TSC:
+	     *   - target/i386/hvf/hvf.c|597| <<hvf_simulate_wrmsr>> case MSR_IA32_TSC:
+	     *   - target/i386/kvm/kvm.c|324| <<kvm_get_tsc>> ret = kvm_get_one_msr(cpu, MSR_IA32_TSC, &value);
+	     *   - target/i386/kvm/kvm.c|2434| <<kvm_arch_reset_parked_vcpu>> msrs->entries[0].index = MSR_IA32_TSC;
+	     *   - target/i386/kvm/kvm.c|4013| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
+	     *   - target/i386/kvm/kvm.c|4476| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);
+	     *   - target/i386/kvm/kvm.c|4751| <<kvm_get_msrs>> case MSR_IA32_TSC:
+	     *
+	     * 在以下使用CPUX86State->tsc:
+             *   - target/i386/machine.c|1724| <<global>> VMSTATE_UINT64(env.tsc, X86CPU),
+             *   - hw/i386/kvm/clock.c|70| <<kvmclock_current_nsec>> uint64_t migration_tsc = env->tsc;
+             *   - target/i386/cpu.c|7535| <<x86_cpu_reset_hold>> if (env->tsc != 0) { 
+	     *   - target/i386/cpu.c|7536| <<x86_cpu_reset_hold>> env->tsc = 1;
+	     *   - target/i386/cpu.c|7539| <<x86_cpu_reset_hold>> env->tsc = 0;
+	     *   - target/i386/hvf/x86hvf.c|236| <<hvf_get_msrs>> env->tsc = rdtscp() + rvmcs(cs->accel->fd, VMCS_TSC_OFFSET);
+	     *   - target/i386/kvm/kvm.c|329| <<kvm_get_tsc>> env->tsc = value;
+	     *   - target/i386/kvm/kvm.c|4013| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_IA32_TSC, env->tsc);
+	     *   - target/i386/kvm/kvm.c|4752| <<kvm_get_msrs>> env->tsc = msrs[i].data;
+	     *   - target/i386/nvmm/nvmm-all.c|181| <<nvmm_set_registers>> state->msrs[NVMM_X64_MSR_TSC] = env->tsc;
+	     *   - target/i386/nvmm/nvmm-all.c|336| <<nvmm_get_registers>> env->tsc = state->msrs[NVMM_X64_MSR_TSC];
+	     *   - target/i386/whpx/whpx-all.c|347| <<whpx_set_tsc>> tsc_val.Reg64 = cpu_env(cpu)->tsc;
+             *   - target/i386/whpx/whpx-all.c|570| <<whpx_get_tsc>> cpu_env(cpu)->tsc = tsc_val.Reg64;
+	     */
             env->tsc = msrs[i].data;
             break;
         case MSR_TSC_AUX:
@@ -4987,6 +5148,10 @@ static int kvm_get_mp_state(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * 在以下使用kvm_get_apic():
+ *   - target/i386/kvm/kvm.c|5412| <<kvm_arch_get_registers>> ret = kvm_get_apic(cpu);
+ */
 static int kvm_get_apic(X86CPU *cpu)
 {
     DeviceState *apic = cpu->apic_state;
@@ -4994,11 +5159,21 @@ static int kvm_get_apic(X86CPU *cpu)
     int ret;
 
     if (apic && kvm_irqchip_in_kernel()) {
+        /*
+	 * 122 #define KVM_APIC_REG_SIZE 0x400
+	 * 123 struct kvm_lapic_state {
+	 * 124         char regs[KVM_APIC_REG_SIZE];
+	 * 125 };
+	 */
         ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_LAPIC, &kapic);
         if (ret < 0) {
             return ret;
         }
 
+        /*
+	 * 在以下使用kvm_get_apic_state():
+	 *   - target/i386/kvm/kvm.c|5002| <<kvm_get_apic>> kvm_get_apic_state(apic, &kapic);
+	 */
         kvm_get_apic_state(apic, &kapic);
     }
     return 0;
@@ -5247,6 +5422,12 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * 在以下使用kvm_arch_put_registers():
+ *   - accel/kvm/kvm-all.c|3182| <<do_kvm_cpu_synchronize_post_reset>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE, &err);
+ *   - accel/kvm/kvm-all.c|3205| <<do_kvm_cpu_synchronize_post_init>> int ret = kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE, &err);
+ *   - accel/kvm/kvm-all.c|3407| <<kvm_cpu_exec>> ret = kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE, &err);
+ */
 int kvm_arch_put_registers(CPUState *cpu, int level, Error **errp)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -5267,6 +5448,9 @@ int kvm_arch_put_registers(CPUState *cpu, int level, Error **errp)
         }
     }
 
+    /*
+     * 在5.15中has_sregs2一般是1
+     */
     /* must be before kvm_put_nested_state so that EFER.SVME is set */
     ret = has_sregs2 ? kvm_put_sregs2(x86_cpu) : kvm_put_sregs(x86_cpu);
     if (ret < 0) {
@@ -5347,6 +5531,10 @@ int kvm_arch_put_registers(CPUState *cpu, int level, Error **errp)
     return 0;
 }
 
+/*
+ * 在以下使用kvm_arch_get_registers():
+ *   - accel/kvm/kvm-all.c|3130| <<do_kvm_cpu_synchronize_state>> int ret = kvm_arch_get_registers(cpu, &err);
+ */
 int kvm_arch_get_registers(CPUState *cs, Error **errp)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -5393,6 +5581,9 @@ int kvm_arch_get_registers(CPUState *cs, Error **errp)
         error_setg_errno(errp, -ret, "Failed to get MSRs");
         goto out;
     }
+    /*
+     * 只在这里调用
+     */
     ret = kvm_get_apic(cpu);
     if (ret < 0) {
         error_setg_errno(errp, -ret, "Failed to get APIC");
@@ -5423,6 +5614,10 @@ int kvm_arch_get_registers(CPUState *cs, Error **errp)
     return ret;
 }
 
+/*
+ * 在以下使用kvm_arch_pre_run():
+ *   - accel/kvm/kvm-all.c|3418| <<kvm_cpu_exec>> kvm_arch_pre_run(cpu, run);
+ */
 void kvm_arch_pre_run(CPUState *cpu, struct kvm_run *run)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -5522,6 +5717,10 @@ static void kvm_rate_limit_on_bus_lock(void)
     }
 }
 
+/*
+ * 在以下使用kvm_arch_post_run():
+ *   - accel/kvm/kvm-all.c|3436| <<kvm_cpu_exec>> attrs = kvm_arch_post_run(cpu, run);
+ */
 MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
@@ -5560,6 +5759,14 @@ MemTxAttrs kvm_arch_post_run(CPUState *cpu, struct kvm_run *run)
         bql_lock();
     }
     cpu_set_apic_tpr(x86_cpu->apic_state, run->cr8);
+    /*
+     * 在以下使用cpu_set_apic_base():
+     *   - target/i386/hvf/hvf.c|602| <<hvf_simulate_wrmsr>> r = cpu_set_apic_base(cpu->apic_state, data);
+     *   - target/i386/kvm/kvm.c|5587| <<kvm_arch_post_run>> cpu_set_apic_base(x86_cpu->apic_state, run->apic_base);
+     *   - target/i386/nvmm/nvmm-all.c|618| <<nvmm_handle_wrmsr>> cpu_set_apic_base(x86_cpu->apic_state, val);
+     *   - target/i386/tcg/system/misc_helper.c|158| <<helper_wrmsr>> ret = cpu_set_apic_base(env_archcpu(env)->apic_state, val);
+     *   - target/i386/whpx/whpx-all.c|743| <<whpx_get_registers>> cpu_set_apic_base(x86_cpu->apic_state, vcpu->apic_base);
+     */
     cpu_set_apic_base(x86_cpu->apic_state, run->apic_base);
     if (!kvm_irqchip_in_kernel()) {
         bql_unlock();
@@ -5578,6 +5785,21 @@ int kvm_arch_process_async_events(CPUState *cs)
 
         cs->interrupt_request &= ~CPU_INTERRUPT_MCE;
 
+        /*
+	 * 在以下使用kvm_cpu_synchronize_state():
+         *   - accel/kvm/kvm-accel-ops.c|131| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+         *   - accel/kvm/kvm-all.c|3547| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+         *   - target/arm/kvm.c|1376| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+	 *   - target/arm/kvm.c|2389| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+         *   - target/i386/kvm/kvm.c|5646| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+         *   - target/i386/kvm/kvm.c|5665| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+         *   - target/i386/kvm/kvm.c|5683| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+         *   - target/i386/kvm/kvm.c|5688| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+         *   - target/i386/kvm/kvm.c|6202| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+         *   - target/loongarch/kvm/kvm.c|1323| <<kvm_loongarch_handle_debug>> kvm_cpu_synchronize_state(cs);
+         *   - target/riscv/kvm/kvm-cpu.c|1589| <<kvm_riscv_handle_debug>> kvm_cpu_synchronize_state(cs);
+         *   - target/s390x/kvm/kvm.c|1911| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+	 */
         kvm_cpu_synchronize_state(cs);
 
         if (env->exception_nr == EXCP08_DBLE) {
@@ -6134,6 +6356,21 @@ bool kvm_arch_stop_on_emulation_error(CPUState *cs)
     X86CPU *cpu = X86_CPU(cs);
     CPUX86State *env = &cpu->env;
 
+    /*
+     * 在以下使用kvm_cpu_synchronize_state():
+     *   - accel/kvm/kvm-accel-ops.c|131| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - accel/kvm/kvm-all.c|3547| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+     *   - target/arm/kvm.c|1376| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+     *   - target/arm/kvm.c|2389| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+     *   - target/i386/kvm/kvm.c|5646| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+     *   - target/i386/kvm/kvm.c|5665| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+     *   - target/i386/kvm/kvm.c|5683| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+     *   - target/i386/kvm/kvm.c|5688| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+     *   - target/i386/kvm/kvm.c|6202| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+     *   - target/loongarch/kvm/kvm.c|1323| <<kvm_loongarch_handle_debug>> kvm_cpu_synchronize_state(cs);
+     *   - target/riscv/kvm/kvm-cpu.c|1589| <<kvm_riscv_handle_debug>> kvm_cpu_synchronize_state(cs);
+     *   - target/s390x/kvm/kvm.c|1911| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+     */
     kvm_cpu_synchronize_state(cs);
     return !(env->cr[0] & CR0_PE_MASK) ||
            ((env->segs[R_CS].selector  & 3) != 3);
diff --git a/target/i386/kvm/xen-emu.c b/target/i386/kvm/xen-emu.c
index e81a24588..6be604162 100644
--- a/target/i386/kvm/xen-emu.c
+++ b/target/i386/kvm/xen-emu.c
@@ -979,6 +979,12 @@ static int vcpuop_register_runstate_info(CPUState *cs, CPUState *target,
     return 0;
 }
 
+/*
+ * 在以下使用kvm_get_current_ns():
+ *   - target/i386/kvm/xen-emu.c|1092| <<do_set_singleshot_timer>> int64_t now = kvm_get_current_ns();
+ *
+ * 只是xen用
+ */
 static uint64_t kvm_get_current_ns(void)
 {
     struct kvm_clock_data data;
diff --git a/util/async.c b/util/async.c
index 863416dee..b61ae00b8 100644
--- a/util/async.c
+++ b/util/async.c
@@ -299,6 +299,14 @@ aio_compute_timeout(AioContext *ctx)
     }
 }
 
+/*
+ * 424 static GSourceFuncs aio_source_funcs = {
+ * 425     aio_ctx_prepare,
+ * 426     aio_ctx_check,
+ * 427     aio_ctx_dispatch,
+ * 428     aio_ctx_finalize
+ * 429 };
+ */
 static gboolean
 aio_ctx_prepare(GSource *source, gint    *timeout)
 {
@@ -323,6 +331,14 @@ aio_ctx_prepare(GSource *source, gint    *timeout)
     return *timeout == 0;
 }
 
+/*
+ * 424 static GSourceFuncs aio_source_funcs = {
+ * 425     aio_ctx_prepare,
+ * 426     aio_ctx_check,
+ * 427     aio_ctx_dispatch,
+ * 428     aio_ctx_finalize
+ * 429 };
+ */
 static gboolean
 aio_ctx_check(GSource *source)
 {
@@ -350,6 +366,14 @@ aio_ctx_check(GSource *source)
     return aio_pending(ctx) || (timerlistgroup_deadline_ns(&ctx->tlg) == 0);
 }
 
+/*
+ * 424 static GSourceFuncs aio_source_funcs = {
+ * 425     aio_ctx_prepare,
+ * 426     aio_ctx_check,
+ * 427     aio_ctx_dispatch,
+ * 428     aio_ctx_finalize
+ * 429 };
+ */
 static gboolean
 aio_ctx_dispatch(GSource     *source,
                  GSourceFunc  callback,
@@ -362,6 +386,14 @@ aio_ctx_dispatch(GSource     *source,
     return true;
 }
 
+/*
+ * 424 static GSourceFuncs aio_source_funcs = {
+ * 425     aio_ctx_prepare,
+ * 426     aio_ctx_check,
+ * 427     aio_ctx_dispatch,
+ * 428     aio_ctx_finalize
+ * 429 };
+ */
 static void
 aio_ctx_finalize(GSource     *source)
 {
diff --git a/util/coroutine-ucontext.c b/util/coroutine-ucontext.c
index 8ef603d08..5e08f2cce 100644
--- a/util/coroutine-ucontext.c
+++ b/util/coroutine-ucontext.c
@@ -278,6 +278,11 @@ static void coroutine_fn terminate_asan(void *opaque)
 }
 #endif
 
+/*
+ * 在以下调用qemu_coroutine_delete():
+ *   -  util/qemu-coroutine.c|288| <<coroutine_pool_batch_delete>> qemu_coroutine_delete(co);
+ *   - util/qemu-coroutine.c|699| <<coroutine_delete>> qemu_coroutine_delete(co);
+ */
 void qemu_coroutine_delete(Coroutine *co_)
 {
     CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);
diff --git a/util/main-loop.c b/util/main-loop.c
index acad8c2e6..6ec65b89f 100644
--- a/util/main-loop.c
+++ b/util/main-loop.c
@@ -290,6 +290,58 @@ static void glib_pollfds_poll(void)
 
 #define MAX_MAIN_LOOP_SPIN (1000)
 
+/*
+ * (gdb) bt
+ * #0  virtio_scsi_get_config (vdev=0x555558406a90, config=0x5555584313b0 "") at ../hw/scsi/virtio-scsi.c:888
+ * #1  0x0000555555e3d3e0 in virtio_config_modern_readl (vdev=0x555558406a90, addr=0) at ../hw/virtio/virtio-config-io.c:148
+ * #2  0x0000555555b7ba61 in virtio_pci_device_read (opaque=0x5555583fe4d0, addr=0, size=4) at ../hw/virtio/virtio-pci.c:1778
+ * #3  0x0000555555e65ce2 in memory_region_read_accessor (mr=0x5555583ff2f0, addr=0, value=0x7fffeb0d5458, size=4, shift=0,
+ * #4  0x0000555555e6633a in access_with_adjusted_size (addr=0, value=0x7fffeb0d5458, size=4, access_size_min=1,
+ * #5  0x0000555555e6969d in memory_region_dispatch_read1 (mr=0x5555583ff2f0, addr=0, pval=0x7fffeb0d5458, size=4, attrs=...)
+ * #6  0x0000555555e697cc in memory_region_dispatch_read (mr=0x5555583ff2f0, addr=0, pval=0x7fffeb0d5458, op=MO_32, attrs=...)
+ * #7  0x0000555555e796f6 in flatview_read_continue_step (attrs=..., buf=0x7ffff7ff0028 "\v", len=4, mr_addr=0, l=0x7fffeb0d54d0,
+ * #8  0x0000555555e797f4 in flatview_read_continue (fv=0x7ffbd4000fc0, addr=61572651163648, attrs=..., ptr=0x7ffff7ff0028,
+ * #9  0x0000555555e7991c in flatview_read (fv=0x7ffbd4000fc0, addr=61572651163648, attrs=..., buf=0x7ffff7ff0028, len=4)
+ * #10 0x0000555555e799bb in address_space_read_full (as=0x555557334980 <address_space_memory>, addr=61572651163648, attrs=...,
+ * #11 0x0000555555e79afd in address_space_rw (as=0x555557334980 <address_space_memory>, addr=61572651163648, attrs=...,
+ * #12 0x0000555555ed996b in kvm_cpu_exec (cpu=0x5555576f0660) at ../accel/kvm/kvm-all.c:3184
+ * #13 0x0000555555edd092 in kvm_vcpu_thread_fn (arg=0x5555576f0660) at ../accel/kvm/kvm-accel-ops.c:50
+ * #14 0x0000555556172954 in qemu_thread_start (args=0x5555576fa4e0) at ../util/qemu-thread-posix.c:541
+ * #15 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #16 0x00007ffff52488d3 in clone () from /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  coroutine_pool_get_local () at ../util/qemu-coroutine.c:116
+ * #1  0x00005555561cb785 in coroutine_pool_get () at ../util/qemu-coroutine.c:181
+ * #2  0x00005555561cb8c7 in qemu_coroutine_create (entry=0x5555560034f4 <blk_aio_write_entry>, opaque=0x5555582fd4d0)
+ *     at ../util/qemu-coroutine.c:222
+ * #3  0x00005555560033cc in blk_aio_prwv (blk=0x55555846f060, offset=540709888, bytes=1024, iobuf=0x5555577f63e8,
+ *     co_entry=0x5555560034f4 <blk_aio_write_entry>, flags=BDRV_REQ_REGISTERED_BUF,
+ *     cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350) at ../block/block-backend.c:1600
+ * #4  0x0000555556003927 in blk_aio_pwritev (blk=0x55555846f060, offset=540709888, qiov=0x5555577f63e8,
+ *     flags=BDRV_REQ_REGISTERED_BUF, cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350)
+ *     at ../block/block-backend.c:1722
+ * #5  0x0000555555e2c003 in submit_requests (s=0x5555584688c0, mrb=0x7fffffffd640, start=0, num_reqs=1, niov=-1) at ../hw/block/virtio-blk.c:259
+ * #6  0x0000555555e2c12f in virtio_blk_submit_multireq (s=0x5555584688c0, mrb=0x7fffffffd640) at ../hw/block/virtio-blk.c:294
+ * #7  0x0000555555e2e065 in virtio_blk_handle_vq (s=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1008
+ * #8  0x0000555555e2e0f8 in virtio_blk_handle_output (vdev=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1028
+ * #9  0x0000555555e89d02 in virtio_queue_notify_vq (vq=0x5555584b0960) at ../hw/virtio/virtio.c:2484
+ * #10 0x0000555555e8d53c in virtio_queue_host_notifier_read (n=0x5555584b09d4) at ../hw/virtio/virtio.c:3869
+ * #11 0x00005555561a74d8 in aio_dispatch_handler (ctx=0x55555745ee50, node=0x7fffe43dfba0) at ../util/aio-posix.c:376
+ * #12 0x00005555561a76ed in aio_dispatch_handlers (ctx=0x55555745ee50) at ../util/aio-posix.c:427
+ * #13 0x00005555561a7749 in aio_dispatch (ctx=0x55555745ee50) at ../util/aio-posix.c:437
+ * #14 0x00005555561c9148 in aio_ctx_dispatch (source=0x55555745ee50, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #15 0x00007ffff6fd394b in g_main_dispatch (context=0x55555745f260) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x55555745f260) at ../glib/gmain.c:4043
+ * #17 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=657614) at ../util/main-loop.c:310
+ * #19 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #21 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x00005555560d296f in main (argc=25, argv=0x7fffffffdb28) at ../system/main.c:80
+ *
+ * 这个是Linux的
+ */
 static int os_host_main_loop_wait(int64_t timeout)
 {
     GMainContext *context = g_main_context_default();
@@ -302,11 +354,17 @@ static int os_host_main_loop_wait(int64_t timeout)
     bql_unlock();
     replay_mutex_unlock();
 
+    /*
+     * 如果想测试时间, 应该是这个函数的后面到前面
+     */
     ret = qemu_poll_ns((GPollFD *)gpollfds->data, gpollfds->len, timeout);
 
     replay_mutex_lock();
     bql_lock();
 
+    /*
+     * 这里是handler!
+     */
     glib_pollfds_poll();
 
     g_main_context_release(context);
@@ -456,6 +514,9 @@ static void pollfds_poll(GArray *pollfds, int nfds, fd_set *rfds,
     }
 }
 
+/*
+ * 这个是Windows的
+ */
 static int os_host_main_loop_wait(int64_t timeout)
 {
     GMainContext *context = g_main_context_default();
@@ -544,11 +605,31 @@ static int os_host_main_loop_wait(int64_t timeout)
 }
 #endif
 
+/*
+ * 在以下使用main_loop_poll_notifiers:
+ *   - util/main-loop.c|547| <<global>> static NotifierList main_loop_poll_notifiers =
+ *             NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
+ *   - util/main-loop.c|552| <<main_loop_poll_add_notifier>> notifier_list_add(&main_loop_poll_notifiers, notify);
+ *   - util/main-loop.c|577| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+ *   - util/main-loop.c|591| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+ */
 static NotifierList main_loop_poll_notifiers =
     NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
 
+/*
+ * 只在以下调用main_loop_poll_add_notifier():
+ *   - net/slirp.c|676| <<net_slirp_init>> main_loop_poll_add_notifier(&s->poll_notifier);
+ */
 void main_loop_poll_add_notifier(Notifier *notify)
 {
+    /*
+     * 在以下使用main_loop_poll_notifiers:
+     *   - util/main-loop.c|547| <<global>> static NotifierList main_loop_poll_notifiers =
+     *             NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
+     *   - util/main-loop.c|552| <<main_loop_poll_add_notifier>> notifier_list_add(&main_loop_poll_notifiers, notify);
+     *   - util/main-loop.c|577| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+     *   - util/main-loop.c|591| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+     */
     notifier_list_add(&main_loop_poll_notifiers, notify);
 }
 
@@ -557,6 +638,51 @@ void main_loop_poll_remove_notifier(Notifier *notify)
     notifier_remove(notify);
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_scsi_get_config (vdev=0x555558406a90, config=0x5555584313b0 "") at ../hw/scsi/virtio-scsi.c:888
+ * #1  0x0000555555e3d3e0 in virtio_config_modern_readl (vdev=0x555558406a90, addr=0) at ../hw/virtio/virtio-config-io.c:148
+ * #2  0x0000555555b7ba61 in virtio_pci_device_read (opaque=0x5555583fe4d0, addr=0, size=4) at ../hw/virtio/virtio-pci.c:1778
+ * #3  0x0000555555e65ce2 in memory_region_read_accessor (mr=0x5555583ff2f0, addr=0, value=0x7fffeb0d5458, size=4, shift=0,
+ * #4  0x0000555555e6633a in access_with_adjusted_size (addr=0, value=0x7fffeb0d5458, size=4, access_size_min=1,
+ * #5  0x0000555555e6969d in memory_region_dispatch_read1 (mr=0x5555583ff2f0, addr=0, pval=0x7fffeb0d5458, size=4, attrs=...)
+ * #6  0x0000555555e697cc in memory_region_dispatch_read (mr=0x5555583ff2f0, addr=0, pval=0x7fffeb0d5458, op=MO_32, attrs=...)
+ * #7  0x0000555555e796f6 in flatview_read_continue_step (attrs=..., buf=0x7ffff7ff0028 "\v", len=4, mr_addr=0, l=0x7fffeb0d54d0,
+ * #8  0x0000555555e797f4 in flatview_read_continue (fv=0x7ffbd4000fc0, addr=61572651163648, attrs=..., ptr=0x7ffff7ff0028,
+ * #9  0x0000555555e7991c in flatview_read (fv=0x7ffbd4000fc0, addr=61572651163648, attrs=..., buf=0x7ffff7ff0028, len=4)
+ * #10 0x0000555555e799bb in address_space_read_full (as=0x555557334980 <address_space_memory>, addr=61572651163648, attrs=...,
+ * #11 0x0000555555e79afd in address_space_rw (as=0x555557334980 <address_space_memory>, addr=61572651163648, attrs=...,
+ * #12 0x0000555555ed996b in kvm_cpu_exec (cpu=0x5555576f0660) at ../accel/kvm/kvm-all.c:3184
+ * #13 0x0000555555edd092 in kvm_vcpu_thread_fn (arg=0x5555576f0660) at ../accel/kvm/kvm-accel-ops.c:50
+ * #14 0x0000555556172954 in qemu_thread_start (args=0x5555576fa4e0) at ../util/qemu-thread-posix.c:541
+ * #15 0x00007ffff68a91da in start_thread () from /lib64/libpthread.so.0
+ * #16 0x00007ffff52488d3 in clone () from /lib64/libc.so.6
+ *
+ * 在以下调用main_loop_wait():
+ *   - qemu-img.c|2144| <<convert_do_copy>> main_loop_wait(false);
+ *   - qemu-img.c|4743| <<img_bench>> main_loop_wait(false);
+ *   - qemu-io-cmds.c|651| <<do_aio_readv>> main_loop_wait(false);
+ *   - qemu-io-cmds.c|665| <<do_aio_writev>> main_loop_wait(false);
+ *   - qemu-io-cmds.c|1930| <<do_aio_zone_append>> main_loop_wait(false);
+ *   - qemu-io-cmds.c|2678| <<sleep_f>> main_loop_wait(false);
+ *   - qemu-io.c|445| <<command_loop>> main_loop_wait(false);
+ *   - qemu-nbd.c|1230| <<main>> main_loop_wait(false);
+ *   - scsi/qemu-pr-helper.c|1069| <<main>> main_loop_wait(false);
+ *   - storage-daemon/qemu-storage-daemon.c|434| <<main>> main_loop_wait(false);
+ *   - system/runstate.c|835| <<qemu_main_loop>> main_loop_wait(false);
+ *   - tests/qtest/fuzz/fuzz.c|51| <<flush_events>> main_loop_wait(false);
+ *   - tests/qtest/fuzz/fuzz.c|58| <<fuzz_reset>> main_loop_wait(true);
+ *   - tests/unit/test-char.c|35| <<main_loop>> main_loop_wait(false);
+ *   - tests/unit/test-char.c|1256| <<char_socket_server_test>> main_loop_wait(false);
+ *   - tests/unit/test-char.c|1279| <<char_socket_server_test>> main_loop_wait(false);
+ *   - tests/unit/test-char.c|1463| <<char_socket_client_test>> main_loop_wait(false);
+ *   - tests/unit/test-char.c|1486| <<char_socket_client_test>> main_loop_wait(false);
+ *   - tests/unit/test-replication.c|78| <<test_blk_read>> main_loop_wait(false);
+ *   - tests/unit/test-replication.c|115| <<test_blk_write>> main_loop_wait(false);
+ *   - tests/unit/test-util-filemonitor.c|85| <<qemu_file_monitor_test_event_loop>> main_loop_wait(true);
+ *   - tools/i386/qemu-vmsr-helper.c|532| <<main>> main_loop_wait(false);
+ *   - ui/gtk-clipboard.c|55| <<gd_clipboard_get_data>> main_loop_wait(false);
+ */
 void main_loop_wait(int nonblocking)
 {
     MainLoopPoll mlpoll = {
@@ -567,12 +693,26 @@ void main_loop_wait(int nonblocking)
     int ret;
     int64_t timeout_ns;
 
+    /*
+     * qemu-system-x86_64来的nonblocking=false
+     */
     if (nonblocking) {
         mlpoll.timeout = 0;
     }
 
     /* poll any events */
     g_array_set_size(gpollfds, 0); /* reset for new iteration */
+    /*
+     * 只在以下调用main_loop_poll_add_notifier():
+     *   - net/slirp.c|676| <<net_slirp_init>> main_loop_poll_add_notifier(&s->poll_notifier);
+     *
+     * 在以下使用main_loop_poll_notifiers:
+     *   - util/main-loop.c|547| <<global>> static NotifierList main_loop_poll_notifiers =
+     *             NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
+     *   - util/main-loop.c|552| <<main_loop_poll_add_notifier>> notifier_list_add(&main_loop_poll_notifiers, notify);
+     *   - util/main-loop.c|577| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+     *   - util/main-loop.c|591| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+     */
     /* XXX: separate device handlers from system ones */
     notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
 
@@ -582,12 +722,34 @@ void main_loop_wait(int nonblocking)
         timeout_ns = (uint64_t)mlpoll.timeout * (int64_t)(SCALE_MS);
     }
 
+    /*
+     * 注释:
+     * qemu_soonest_timeout:
+     * @timeout1: first timeout in nanoseconds (or -1 for infinite)
+     * @timeout2: second timeout in nanoseconds (or -1 for infinite)
+     *
+     * Calculates the soonest of two timeout values. -1 means infinite, which
+     * is later than any other value.
+     *
+     * Returns: soonest timeout value in nanoseconds (or -1 for infinite)
+     */
     timeout_ns = qemu_soonest_timeout(timeout_ns,
                                       timerlistgroup_deadline_ns(
                                           &main_loop_tlg));
 
     ret = os_host_main_loop_wait(timeout_ns);
     mlpoll.state = ret < 0 ? MAIN_LOOP_POLL_ERR : MAIN_LOOP_POLL_OK;
+    /*
+     * 只在以下调用main_loop_poll_add_notifier():
+     *   - net/slirp.c|676| <<net_slirp_init>> main_loop_poll_add_notifier(&s->poll_notifier);
+     *
+     * 在以下使用main_loop_poll_notifiers:
+     *   - util/main-loop.c|547| <<global>> static NotifierList main_loop_poll_notifiers =
+     *             NOTIFIER_LIST_INITIALIZER(main_loop_poll_notifiers);
+     *   - util/main-loop.c|552| <<main_loop_poll_add_notifier>> notifier_list_add(&main_loop_poll_notifiers, notify);
+     *   - util/main-loop.c|577| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+     *   - util/main-loop.c|591| <<main_loop_wait>> notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
+     */
     notifier_list_notify(&main_loop_poll_notifiers, &mlpoll);
 
     if (icount_enabled()) {
@@ -597,6 +759,9 @@ void main_loop_wait(int nonblocking)
          */
         icount_start_warp_timer();
     }
+    /*
+     * 只在以下调用qemu_clock_run_all_timers()
+     */
     qemu_clock_run_all_timers();
 }
 
diff --git a/util/osdep.c b/util/osdep.c
index 770369831..8676bce08 100644
--- a/util/osdep.c
+++ b/util/osdep.c
@@ -605,6 +605,13 @@ writev(int fd, const struct iovec *iov, int iov_cnt)
  * Unfortunately even in 2009 many operating systems do not support
  * fdatasync and have to fall back to fsync.
  */
+/*
+ * 在以下使用qemu_fdatasync():
+ *   - block/file-posix.c|1636| <<handle_aiocb_flush>> ret = qemu_fdatasync(aiocb->aio_fildes);
+ *   - hw/9pfs/9p-local.c|1179| <<local_fsync>> return qemu_fdatasync(fd);
+ *   - hw/ppc/spapr_nvdimm.c|471| <<flush_worker_cb>> if (qemu_fdatasync(backend_fd) < 0)
+ *   - util/oslib-win32.c|845| <<qemu_msync>> return qemu_fdatasync(fd);
+ */
 int qemu_fdatasync(int fd)
 {
 #ifdef CONFIG_FDATASYNC
diff --git a/util/qemu-coroutine.c b/util/qemu-coroutine.c
index 64d6264fc..5df0261ec 100644
--- a/util/qemu-coroutine.c
+++ b/util/qemu-coroutine.c
@@ -21,7 +21,83 @@
 #include "qemu/cutils.h"
 #include "block/aio.h"
 
+/*
+ * commit 86a637e48104ae74d8be53bed6441ce32be33433
+ * Author: Stefan Hajnoczi <stefanha@redhat.com>
+ * Date:   Mon Mar 18 14:34:29 2024 -0400
+ *
+ * coroutine: cap per-thread local pool size
+ *
+ * The coroutine pool implementation can hit the Linux vm.max_map_count
+ * limit, causing QEMU to abort with "failed to allocate memory for stack"
+ * or "failed to set up stack guard page" during coroutine creation.
+ *
+ * This happens because per-thread pools can grow to tens of thousands of
+ * coroutines. Each coroutine causes 2 virtual memory areas to be created.
+ * Eventually vm.max_map_count is reached and memory-related syscalls fail.
+ * The per-thread pool sizes are non-uniform and depend on past coroutine
+ * usage in each thread, so it's possible for one thread to have a large
+ * pool while another thread's pool is empty.
+ *
+ * Switch to a new coroutine pool implementation with a global pool that
+ * grows to a maximum number of coroutines and per-thread local pools that
+ * are capped at hardcoded small number of coroutines.
+ *
+ * This approach does not leave large numbers of coroutines pooled in a
+ * thread that may not use them again. In order to perform well it
+ * amortizes the cost of global pool accesses by working in batches of
+ * coroutines instead of individual coroutines.
+ *
+ * The global pool is a list. Threads donate batches of coroutines to when
+ * they have too many and take batches from when they have too few:
+ *
+ * .-----------------------------------.
+ * | Batch 1 | Batch 2 | Batch 3 | ... | global_pool
+ * `-----------------------------------'
+ *
+ * Each thread has up to 2 batches of coroutines:
+ *
+ * .-------------------.
+ * | Batch 1 | Batch 2 | per-thread local_pool (maximum 2 batches)
+ * `-------------------'
+ *
+ * The goal of this change is to reduce the excessive number of pooled
+ * coroutines that cause QEMU to abort when vm.max_map_count is reached
+ * without losing the performance of an adequately sized coroutine pool.
+ *
+ * Here are virtio-blk disk I/O benchmark results:
+ *
+ * RW BLKSIZE IODEPTH    OLD    NEW CHANGE
+ * randread      4k       1 113725 117451 +3.3%
+ * randread      4k       8 192968 198510 +2.9%
+ * randread      4k      16 207138 209429 +1.1%
+ * randread      4k      32 212399 215145 +1.3%
+ * randread      4k      64 218319 221277 +1.4%
+ * randread    128k       1  17587  17535 -0.3%
+ * randread    128k       8  17614  17616 +0.0%
+ * randread    128k      16  17608  17609 +0.0%
+ * randread    128k      32  17552  17553 +0.0%
+ * randread    128k      64  17484  17484 +0.0%
+ *
+ * See files/{fio.sh,test.xml.j2} for the benchmark configuration:
+ * https://gitlab.com/stefanha/virt-playbooks/-/tree/coroutine-pool-fix-sizing
+ *
+ * Buglink: https://issues.redhat.com/browse/RHEL-28947
+ * Reported-by: Sanjay Rao <srao@redhat.com>
+ * Reported-by: Boaz Ben Shabat <bbenshab@redhat.com>
+ * Reported-by: Joe Mario <jmario@redhat.com>
+ * Reviewed-by: Kevin Wolf <kwolf@redhat.com>
+ * Signed-off-by: Stefan Hajnoczi <stefanha@redhat.com>
+ * Message-ID: <20240318183429.1039340-1-stefanha@redhat.com>
+ */
+
 enum {
+    /*
+     * 在以下使用COROUTINE_POOL_BATCH_MAX_SIZE:
+     *   - util/qemu-coroutine.c|25| <<global>> COROUTINE_POOL_BATCH_MAX_SIZE = 128,
+     *   - util/qemu-coroutine.c|65| <<QSLIST_HEAD>> static unsigned int global_pool_max_size = COROUTINE_POOL_BATCH_MAX_SIZE;
+     *   - util/qemu-coroutine.c|204| <<coroutine_pool_put>> if (unlikely(batch->size >= COROUTINE_POOL_BATCH_MAX_SIZE)) {
+     */
     COROUTINE_POOL_BATCH_MAX_SIZE = 128,
 };
 
@@ -56,17 +132,127 @@ typedef struct CoroutinePoolBatch {
 
 typedef QSLIST_HEAD(, CoroutinePoolBatch) CoroutinePool;
 
+/*
+ * 在以下使用global_pool_hard_max_size:
+ *   - util/qemu-coroutine.c|136| <<QSLIST_HEAD>> static unsigned int global_pool_hard_max_size;
+ *   - util/qemu-coroutine.c|296| <<coroutine_pool_put_global>> unsigned int max = MIN(global_pool_max_size, global_pool_hard_max_size);
+ *   - util/qemu-coroutine.c|600| <<qemu_coroutine_init>> global_pool_hard_max_size = get_global_pool_hard_max_size();
+ */
 /* Host operating system limit on number of pooled coroutines */
 static unsigned int global_pool_hard_max_size;
 
+/*
+ * 在以下使用global_pool_lock:
+ *   - util/qemu-coroutine.c|138| <<QSLIST_HEAD>> static QemuMutex global_pool_lock;
+ *   - util/qemu-coroutine.c|276| <<coroutine_pool_refill_local>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+ *   - util/qemu-coroutine.c|294| <<coroutine_pool_put_global>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+ *   - util/qemu-coroutine.c|554| <<qemu_coroutine_inc_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+ *   - util/qemu-coroutine.c|560| <<qemu_coroutine_dec_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+ *   - util/qemu-coroutine.c|599| <<qemu_coroutine_init>> qemu_mutex_init(&global_pool_lock);
+ */
 static QemuMutex global_pool_lock; /* protects the following variables */
+/*
+ * 在以下使用global_pool:
+ *   - util/qemu-coroutine.c|139| <<QSLIST_HEAD>> static CoroutinePool global_pool = QSLIST_HEAD_INITIALIZER(global_pool);
+ *   - util/qemu-coroutine.c|277| <<coroutine_pool_refill_local>> batch = QSLIST_FIRST(&global_pool);
+ *   - util/qemu-coroutine.c|280| <<coroutine_pool_refill_local>> QSLIST_REMOVE_HEAD(&global_pool, next);
+ *   - util/qemu-coroutine.c|299| <<coroutine_pool_put_global>> QSLIST_INSERT_HEAD(&global_pool, batch, next);
+ */
 static CoroutinePool global_pool = QSLIST_HEAD_INITIALIZER(global_pool);
+/*
+ * 在以下使用global_pool_size:
+ *   - util/qemu-coroutine.c|140| <<QSLIST_HEAD>> static unsigned int global_pool_size;
+ *   - util/qemu-coroutine.c|281| <<coroutine_pool_refill_local>> global_pool_size -= batch->size;
+ *   - util/qemu-coroutine.c|298| <<coroutine_pool_put_global>> if (global_pool_size < max) {
+ *   - util/qemu-coroutine.c|302| <<coroutine_pool_put_global>> global_pool_size += batch->size;
+ */
 static unsigned int global_pool_size;
+/*
+ * 在以下使用COROUTINE_POOL_BATCH_MAX_SIZE:
+ *   - util/qemu-coroutine.c|25| <<global>> COROUTINE_POOL_BATCH_MAX_SIZE = 128,
+ *   - util/qemu-coroutine.c|65| <<QSLIST_HEAD>> static unsigned int global_pool_max_size = COROUTINE_POOL_BATCH_MAX_SIZE;
+ *   - util/qemu-coroutine.c|204| <<coroutine_pool_put>> if (unlikely(batch->size >= COROUTINE_POOL_BATCH_MAX_SIZE)) {
+ *
+ * 在以下使用global_pool_max_size:
+ *   - util/qemu-coroutine.c|389| <<coroutine_pool_put_global>> unsigned int max = MIN(global_pool_max_size,
+ *   - util/qemu-coroutine.c|664| <<qemu_coroutine_inc_pool_size>> global_pool_max_size += additional_pool_size;
+ *   - util/qemu-coroutine.c|670| <<qemu_coroutine_dec_pool_size>> global_pool_max_size -= removing_pool_size;
+ */
 static unsigned int global_pool_max_size = COROUTINE_POOL_BATCH_MAX_SIZE;
 
+/*
+ * (gdb) info threads 
+ *   Id   Target Id                                            Frame 
+ * * 1    Thread 0x7fffef5b5f00 (LWP 291721) "qemu-system-x86" 0x00007ffff4cd3c36 in ppoll () from /lib64/libc.so.6
+ *   2    Thread 0x7fffef5b4700 (LWP 291725) "qemu-system-x86" 0x00007ffff4bda41d in syscall () from /lib64/libc.so.6
+ *   4    Thread 0x7fffeda40700 (LWP 291729) "CPU 0/KVM"       0x00007ffff4bda22b in ioctl () from /lib64/libc.so.6
+ *   5    Thread 0x7fffed23f700 (LWP 291730) "CPU 1/KVM"       0x00007ffff4bda22b in ioctl () from /lib64/libc.so.6
+ *   6    Thread 0x7fffeca3e700 (LWP 291731) "CPU 2/KVM"       0x00007ffff4bda22b in ioctl () from /lib64/libc.so.6
+ *   7    Thread 0x7ffbdfdff700 (LWP 291732) "CPU 3/KVM"       0x00007ffff4bda22b in ioctl () from /lib64/libc.so.6
+ *   8    Thread 0x7ffbdd3ff700 (LWP 291734) "vnc_worker"      0x00007ffff68af4dc in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0
+ *
+ * (gdb) p co_tls_local_pool
+ * $6 = {slh_first = 0x555557793a60}
+ *
+ * (gdb) thread 2
+ * (gdb) p co_tls_local_pool
+ * $7 = {slh_first = 0x0}
+ *
+ * (gdb) thread 4
+ * (gdb) p co_tls_local_pool
+ * $8 = {slh_first = 0x7fffe4045780}
+ *
+ * (gdb) thread 5
+ * (gdb) p co_tls_local_pool
+ * $9 = {slh_first = 0x5555577893f0}
+ *
+ * (gdb) thread 6
+ * (gdb) p co_tls_local_pool
+ * $10 = {slh_first = 0x7ffbd0018b40}
+ *
+ * (gdb) thread 7
+ * (gdb) p co_tls_local_pool
+ * $11 = {slh_first = 0x55555779d8f0}
+ *
+ * (gdb) thread 8
+ * (gdb) p co_tls_local_pool
+ * $12 = {slh_first = 0x0}
+ *
+ * 定义:
+ * 153 #define QEMU_DEFINE_STATIC_CO_TLS(type, var)                                 \
+ * 154     static __thread type co_tls_##var;                                       \
+ * 155     static __attribute__((noinline, unused))                                 \
+ * 156     type get_##var(void)                                                     \
+ * 157     { asm volatile(""); return co_tls_##var; }                               \
+ * 158     static __attribute__((noinline, unused))                                 \
+ * 159     void set_##var(type v)                                                   \
+ * 160     { asm volatile(""); co_tls_##var = v; }                                  \
+ * 161     static __attribute__((noinline, unused))                                 \
+ * 162     type *get_ptr_##var(void)                                                \
+ * 163     { type *ptr = &co_tls_##var; asm volatile("" : "+rm" (ptr)); return ptr; }
+ *
+ * get_local_pool()
+ * set_local_pool()
+ * get_ptr_local_pool()
+ *
+ * 在以下定义get_ptr_local_pool():
+ *   - QEMU_DEFINE_STATIC_CO_TLS(CoroutinePool, local_pool);
+ * 在以下使用get_ptr_local_pool():
+ *   - util/qemu-coroutine.c|93| <<local_pool_cleanup>> CoroutinePool *local_pool = get_ptr_local_pool();
+ *   - util/qemu-coroutine.c|116| <<coroutine_pool_get_local>> CoroutinePool *local_pool = get_ptr_local_pool();
+ *   - util/qemu-coroutine.c|138| <<coroutine_pool_refill_local>> CoroutinePool *local_pool = get_ptr_local_pool();
+ *   - util/qemu-coroutine.c|195| <<coroutine_pool_put>> CoroutinePool *local_pool = get_ptr_local_pool();
+ *
+ * 每个thread一个local_pool指针
+ */
 QEMU_DEFINE_STATIC_CO_TLS(CoroutinePool, local_pool);
 QEMU_DEFINE_STATIC_CO_TLS(Notifier, local_pool_cleanup_notifier);
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|378| <<coroutine_pool_put>> batch = coroutine_pool_batch_new();
+ *   - util/qemu-coroutine.c|398| <<coroutine_pool_put>> batch = coroutine_pool_batch_new();
+ */
 static CoroutinePoolBatch *coroutine_pool_batch_new(void)
 {
     CoroutinePoolBatch *batch = g_new(CoroutinePoolBatch, 1);
@@ -76,20 +262,56 @@ static CoroutinePoolBatch *coroutine_pool_batch_new(void)
     return batch;
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|245| <<local_pool_cleanup>> coroutine_pool_batch_delete(batch);
+ *   - util/qemu-coroutine.c|285| <<coroutine_pool_get_local>> coroutine_pool_batch_delete(batch);
+ *   - util/qemu-coroutine.c|343| <<coroutine_pool_put_global>> coroutine_pool_batch_delete(batch);
+ *
+ * 如果从coroutine_pool_get_local()来的话理论上batch上没有co了.
+ */
 static void coroutine_pool_batch_delete(CoroutinePoolBatch *batch)
 {
     Coroutine *co;
     Coroutine *tmp;
 
+    /*
+     * 124 typedef struct CoroutinePoolBatch {
+     * 125     // Batches are kept in a list
+     * 126     QSLIST_ENTRY(CoroutinePoolBatch) next;
+     * 127
+     * 128     // This batch holds up to @COROUTINE_POOL_BATCH_MAX_SIZE coroutines
+     * 129     QSLIST_HEAD(, Coroutine) list;
+     * 130     unsigned int size;
+     * 131 } CoroutinePoolBatch;
+     */
     QSLIST_FOREACH_SAFE(co, &batch->list, pool_next, tmp) {
         QSLIST_REMOVE_HEAD(&batch->list, pool_next);
+        /*
+	 * 在以下调用qemu_coroutine_delete():
+	 *   - util/qemu-coroutine.c|288| <<coroutine_pool_batch_delete>> qemu_coroutine_delete(co);
+	 *   - util/qemu-coroutine.c|699| <<coroutine_delete>> qemu_coroutine_delete(co);
+	 */
         qemu_coroutine_delete(co);
     }
     g_free(batch);
 }
 
+/*
+ * 在以下使用local_pool_cleanup():
+ *   - util/qemu-coroutine.c|254| <<local_pool_cleanup_init_once>> notifier->notify = local_pool_cleanup;
+ */
 static void local_pool_cleanup(Notifier *n, void *value)
 {
+    /*
+     * 在以下定义get_ptr_local_pool():
+     *   - QEMU_DEFINE_STATIC_CO_TLS(CoroutinePool, local_pool);
+     * 在以下使用get_ptr_local_pool():
+     *   - util/qemu-coroutine.c|93| <<local_pool_cleanup>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|116| <<coroutine_pool_get_local>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|138| <<coroutine_pool_refill_local>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|195| <<coroutine_pool_put>> CoroutinePool *local_pool = get_ptr_local_pool();
+     */
     CoroutinePool *local_pool = get_ptr_local_pool();
     CoroutinePoolBatch *batch;
     CoroutinePoolBatch *tmp;
@@ -100,6 +322,11 @@ static void local_pool_cleanup(Notifier *n, void *value)
     }
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|316| <<coroutine_pool_refill_local>> local_pool_cleanup_init_once();
+ *   - util/qemu-coroutine.c|380| <<coroutine_pool_put>> local_pool_cleanup_init_once();
+ */
 /* Ensure the atexit notifier is registered */
 static void local_pool_cleanup_init_once(void)
 {
@@ -110,10 +337,58 @@ static void local_pool_cleanup_init_once(void)
     }
 }
 
+/*
+ * 没有iothread应该就是mainloop
+ * (gdb) bt
+ * #0  coroutine_pool_get_local () at ../util/qemu-coroutine.c:116
+ * #1  0x00005555561cb785 in coroutine_pool_get () at ../util/qemu-coroutine.c:181
+ * #2  0x00005555561cb8c7 in qemu_coroutine_create (entry=0x5555560034f4 <blk_aio_write_entry>, opaque=0x5555582fd4d0)
+ *     at ../util/qemu-coroutine.c:222
+ * #3  0x00005555560033cc in blk_aio_prwv (blk=0x55555846f060, offset=540709888, bytes=1024, iobuf=0x5555577f63e8,
+ *     co_entry=0x5555560034f4 <blk_aio_write_entry>, flags=BDRV_REQ_REGISTERED_BUF, 
+ *     cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350) at ../block/block-backend.c:1600
+ * #4  0x0000555556003927 in blk_aio_pwritev (blk=0x55555846f060, offset=540709888, qiov=0x5555577f63e8,
+ *     flags=BDRV_REQ_REGISTERED_BUF, cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350)
+ *     at ../block/block-backend.c:1722
+ * #5  0x0000555555e2c003 in submit_requests (s=0x5555584688c0, mrb=0x7fffffffd640, start=0, num_reqs=1, niov=-1) at ../hw/block/virtio-blk.c:259
+ * #6  0x0000555555e2c12f in virtio_blk_submit_multireq (s=0x5555584688c0, mrb=0x7fffffffd640) at ../hw/block/virtio-blk.c:294
+ * #7  0x0000555555e2e065 in virtio_blk_handle_vq (s=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1008
+ * #8  0x0000555555e2e0f8 in virtio_blk_handle_output (vdev=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1028
+ * #9  0x0000555555e89d02 in virtio_queue_notify_vq (vq=0x5555584b0960) at ../hw/virtio/virtio.c:2484
+ * #10 0x0000555555e8d53c in virtio_queue_host_notifier_read (n=0x5555584b09d4) at ../hw/virtio/virtio.c:3869
+ * #11 0x00005555561a74d8 in aio_dispatch_handler (ctx=0x55555745ee50, node=0x7fffe43dfba0) at ../util/aio-posix.c:376
+ * #12 0x00005555561a76ed in aio_dispatch_handlers (ctx=0x55555745ee50) at ../util/aio-posix.c:427
+ * #13 0x00005555561a7749 in aio_dispatch (ctx=0x55555745ee50) at ../util/aio-posix.c:437
+ * #14 0x00005555561c9148 in aio_ctx_dispatch (source=0x55555745ee50, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #15 0x00007ffff6fd394b in g_main_dispatch (context=0x55555745f260) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x55555745f260) at ../glib/gmain.c:4043
+ * #17 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=657614) at ../util/main-loop.c:310
+ * #19 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #21 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x00005555560d296f in main (argc=25, argv=0x7fffffffdb28) at ../system/main.c:80
+ *
+ * 在以下调用coroutine_pool_get_local():
+ *   - util/qemu-coroutine.c|355| <<coroutine_pool_get>> co = coroutine_pool_get_local();
+ *   - util/qemu-coroutine.c|358| <<coroutine_pool_get>> co = coroutine_pool_get_local();
+ */
 /* Helper to get the next unused coroutine from the local pool */
 static Coroutine *coroutine_pool_get_local(void)
 {
+    /*
+     * 在以下定义get_ptr_local_pool():
+     *   - QEMU_DEFINE_STATIC_CO_TLS(CoroutinePool, local_pool);
+     * 在以下使用get_ptr_local_pool():
+     *   - util/qemu-coroutine.c|93| <<local_pool_cleanup>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|116| <<coroutine_pool_get_local>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|138| <<coroutine_pool_refill_local>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|195| <<coroutine_pool_put>> CoroutinePool *local_pool = get_ptr_local_pool();
+     */
     CoroutinePool *local_pool = get_ptr_local_pool();
+    /*
+     * 每个local应该最多两个batch
+     */
     CoroutinePoolBatch *batch = QSLIST_FIRST(local_pool);
     Coroutine *co;
 
@@ -127,22 +402,66 @@ static Coroutine *coroutine_pool_get_local(void)
 
     if (batch->size == 0) {
         QSLIST_REMOVE_HEAD(local_pool, next);
+        /*
+	 * called by:
+	 *   - util/qemu-coroutine.c|245| <<local_pool_cleanup>> coroutine_pool_batch_delete(batch);
+	 *   - util/qemu-coroutine.c|285| <<coroutine_pool_get_local>> coroutine_pool_batch_delete(batch);
+	 *   - util/qemu-coroutine.c|343| <<coroutine_pool_put_global>> coroutine_pool_batch_delete(batch);
+	 *
+	 * 理论上这时候batch上没有co了
+	 */
         coroutine_pool_batch_delete(batch);
     }
     return co;
 }
 
+/*
+ * 在以下使用coroutine_pool_refill_local():
+ *   - util/qemu-coroutine.c|357| <<coroutine_pool_get>> coroutine_pool_refill_local();
+ */
 /* Get the next batch from the global pool */
 static void coroutine_pool_refill_local(void)
 {
+    /*
+     * 在以下定义get_ptr_local_pool():
+     *   - QEMU_DEFINE_STATIC_CO_TLS(CoroutinePool, local_pool);
+     * 在以下使用get_ptr_local_pool():
+     *   - util/qemu-coroutine.c|93| <<local_pool_cleanup>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|116| <<coroutine_pool_get_local>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|138| <<coroutine_pool_refill_local>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|195| <<coroutine_pool_put>> CoroutinePool *local_pool = get_ptr_local_pool();
+     */
     CoroutinePool *local_pool = get_ptr_local_pool();
     CoroutinePoolBatch *batch = NULL;
 
+    /*
+     * 在以下使用global_pool_lock:
+     *   - util/qemu-coroutine.c|138| <<QSLIST_HEAD>> static QemuMutex global_pool_lock;
+     *   - util/qemu-coroutine.c|276| <<coroutine_pool_refill_local>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|294| <<coroutine_pool_put_global>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|554| <<qemu_coroutine_inc_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|560| <<qemu_coroutine_dec_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|599| <<qemu_coroutine_init>> qemu_mutex_init(&global_pool_lock);
+     */
     WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+        /*
+	 * 在以下使用global_pool:
+	 *   - util/qemu-coroutine.c|139| <<QSLIST_HEAD>> static CoroutinePool global_pool = QSLIST_HEAD_INITIALIZER(global_pool);
+	 *   - util/qemu-coroutine.c|277| <<coroutine_pool_refill_local>> batch = QSLIST_FIRST(&global_pool);
+	 *   - util/qemu-coroutine.c|280| <<coroutine_pool_refill_local>> QSLIST_REMOVE_HEAD(&global_pool, next);
+	 *   - util/qemu-coroutine.c|299| <<coroutine_pool_put_global>> QSLIST_INSERT_HEAD(&global_pool, batch, next);
+	 */
         batch = QSLIST_FIRST(&global_pool);
 
         if (batch) {
             QSLIST_REMOVE_HEAD(&global_pool, next);
+            /*
+	     * 在以下使用global_pool_size:
+	     *   - util/qemu-coroutine.c|140| <<QSLIST_HEAD>> static unsigned int global_pool_size;
+	     *   - util/qemu-coroutine.c|281| <<coroutine_pool_refill_local>> global_pool_size -= batch->size;
+	     *   - util/qemu-coroutine.c|298| <<coroutine_pool_put_global>> if (global_pool_size < max) {
+	     *   - util/qemu-coroutine.c|302| <<coroutine_pool_put_global>> global_pool_size += batch->size;
+	     */
             global_pool_size -= batch->size;
         }
     }
@@ -153,14 +472,46 @@ static void coroutine_pool_refill_local(void)
     }
 }
 
+/*
+ * 在以下调用coroutine_pool_put_global():
+ *   - util/qemu-coroutine.c|469| <<coroutine_pool_put>> coroutine_pool_put_global(batch);
+ */
 /* Add a batch of coroutines to the global pool */
 static void coroutine_pool_put_global(CoroutinePoolBatch *batch)
 {
+    /*
+     * 在以下使用global_pool_lock:
+     *   - util/qemu-coroutine.c|138| <<QSLIST_HEAD>> static QemuMutex global_pool_lock;
+     *   - util/qemu-coroutine.c|276| <<coroutine_pool_refill_local>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|294| <<coroutine_pool_put_global>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|554| <<qemu_coroutine_inc_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|560| <<qemu_coroutine_dec_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|599| <<qemu_coroutine_init>> qemu_mutex_init(&global_pool_lock);
+     */
     WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+        /*
+	 * 在以下使用global_pool_hard_max_size:
+	 *   - util/qemu-coroutine.c|136| <<QSLIST_HEAD>> static unsigned int global_pool_hard_max_size;
+	 *   - util/qemu-coroutine.c|296| <<coroutine_pool_put_global>> unsigned int max = MIN(global_pool_max_size, global_pool_hard_max_size);
+	 *   - util/qemu-coroutine.c|600| <<qemu_coroutine_init>> global_pool_hard_max_size = get_global_pool_hard_max_size();
+	 *
+	 * 在以下使用global_pool_size:
+	 *   - util/qemu-coroutine.c|140| <<QSLIST_HEAD>> static unsigned int global_pool_size;
+	 *   - util/qemu-coroutine.c|281| <<coroutine_pool_refill_local>> global_pool_size -= batch->size;
+	 *   - util/qemu-coroutine.c|298| <<coroutine_pool_put_global>> if (global_pool_size < max) {
+	 *   - util/qemu-coroutine.c|302| <<coroutine_pool_put_global>> global_pool_size += batch->size;
+	 */
         unsigned int max = MIN(global_pool_max_size,
                                global_pool_hard_max_size);
 
         if (global_pool_size < max) {
+            /*
+	     * 在以下使用global_pool:
+	     *   - util/qemu-coroutine.c|139| <<QSLIST_HEAD>> static CoroutinePool global_pool = QSLIST_HEAD_INITIALIZER(global_pool);
+	     *   - util/qemu-coroutine.c|277| <<coroutine_pool_refill_local>> batch = QSLIST_FIRST(&global_pool);
+	     *   - util/qemu-coroutine.c|280| <<coroutine_pool_refill_local>> QSLIST_REMOVE_HEAD(&global_pool, next);
+	     *   - util/qemu-coroutine.c|299| <<coroutine_pool_put_global>> QSLIST_INSERT_HEAD(&global_pool, batch, next);
+	     */
             QSLIST_INSERT_HEAD(&global_pool, batch, next);
 
             /* Overshooting the max pool size is allowed */
@@ -173,21 +524,77 @@ static void coroutine_pool_put_global(CoroutinePoolBatch *batch)
     coroutine_pool_batch_delete(batch);
 }
 
+/*
+ * 没有iothread应该就是mainloop
+ * (gdb) bt
+ * #0  coroutine_pool_get_local () at ../util/qemu-coroutine.c:116
+ * #1  0x00005555561cb785 in coroutine_pool_get () at ../util/qemu-coroutine.c:181
+ * #2  0x00005555561cb8c7 in qemu_coroutine_create (entry=0x5555560034f4 <blk_aio_write_entry>, opaque=0x5555582fd4d0)
+ *     at ../util/qemu-coroutine.c:222
+ * #3  0x00005555560033cc in blk_aio_prwv (blk=0x55555846f060, offset=540709888, bytes=1024, iobuf=0x5555577f63e8,
+ *     co_entry=0x5555560034f4 <blk_aio_write_entry>, flags=BDRV_REQ_REGISTERED_BUF, 
+ *     cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350) at ../block/block-backend.c:1600
+ * #4  0x0000555556003927 in blk_aio_pwritev (blk=0x55555846f060, offset=540709888, qiov=0x5555577f63e8,
+ *     flags=BDRV_REQ_REGISTERED_BUF, cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350)
+ *     at ../block/block-backend.c:1722
+ * #5  0x0000555555e2c003 in submit_requests (s=0x5555584688c0, mrb=0x7fffffffd640, start=0, num_reqs=1, niov=-1) at ../hw/block/virtio-blk.c:259
+ * #6  0x0000555555e2c12f in virtio_blk_submit_multireq (s=0x5555584688c0, mrb=0x7fffffffd640) at ../hw/block/virtio-blk.c:294
+ * #7  0x0000555555e2e065 in virtio_blk_handle_vq (s=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1008
+ * #8  0x0000555555e2e0f8 in virtio_blk_handle_output (vdev=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1028
+ * #9  0x0000555555e89d02 in virtio_queue_notify_vq (vq=0x5555584b0960) at ../hw/virtio/virtio.c:2484
+ * #10 0x0000555555e8d53c in virtio_queue_host_notifier_read (n=0x5555584b09d4) at ../hw/virtio/virtio.c:3869
+ * #11 0x00005555561a74d8 in aio_dispatch_handler (ctx=0x55555745ee50, node=0x7fffe43dfba0) at ../util/aio-posix.c:376
+ * #12 0x00005555561a76ed in aio_dispatch_handlers (ctx=0x55555745ee50) at ../util/aio-posix.c:427
+ * #13 0x00005555561a7749 in aio_dispatch (ctx=0x55555745ee50) at ../util/aio-posix.c:437
+ * #14 0x00005555561c9148 in aio_ctx_dispatch (source=0x55555745ee50, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #15 0x00007ffff6fd394b in g_main_dispatch (context=0x55555745f260) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x55555745f260) at ../glib/gmain.c:4043
+ * #17 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=657614) at ../util/main-loop.c:310
+ * #19 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #21 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x00005555560d296f in main (argc=25, argv=0x7fffffffdb28) at ../system/main.c:80
+ *
+ * called by:
+ *   - util/qemu-coroutine.c|262| <<qemu_coroutine_create>> co = coroutine_pool_get();
+ */
 /* Get the next unused coroutine from the pool or return NULL */
 static Coroutine *coroutine_pool_get(void)
 {
     Coroutine *co;
 
+    /*
+     * 在以下调用coroutine_pool_get_local():
+     *   - util/qemu-coroutine.c|355| <<coroutine_pool_get>> co = coroutine_pool_get_local();
+     *   - util/qemu-coroutine.c|358| <<coroutine_pool_get>> co = coroutine_pool_get_local();
+     */
     co = coroutine_pool_get_local();
     if (!co) {
+        /*
+	 * 只在以下调用refill
+	 */
         coroutine_pool_refill_local();
         co = coroutine_pool_get_local();
     }
     return co;
 }
 
+/*
+ * 在以下调用coroutine_pool_put():
+ *   - util/qemu-coroutine.c|549| <<coroutine_delete>> coroutine_pool_put(co);
+ */
 static void coroutine_pool_put(Coroutine *co)
 {
+    /*
+     * 在以下定义get_ptr_local_pool():
+     *   - QEMU_DEFINE_STATIC_CO_TLS(CoroutinePool, local_pool);
+     * 在以下使用get_ptr_local_pool():
+     *   - util/qemu-coroutine.c|93| <<local_pool_cleanup>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|116| <<coroutine_pool_get_local>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|138| <<coroutine_pool_refill_local>> CoroutinePool *local_pool = get_ptr_local_pool();
+     *   - util/qemu-coroutine.c|195| <<coroutine_pool_put>> CoroutinePool *local_pool = get_ptr_local_pool();
+     */
     CoroutinePool *local_pool = get_ptr_local_pool();
     CoroutinePoolBatch *batch = QSLIST_FIRST(local_pool);
 
@@ -197,9 +604,18 @@ static void coroutine_pool_put(Coroutine *co)
         local_pool_cleanup_init_once();
     }
 
+    /*
+     * 在以下使用COROUTINE_POOL_BATCH_MAX_SIZE:
+     *   - util/qemu-coroutine.c|25| <<global>> COROUTINE_POOL_BATCH_MAX_SIZE = 128,
+     *   - util/qemu-coroutine.c|65| <<QSLIST_HEAD>> static unsigned int global_pool_max_size = COROUTINE_POOL_BATCH_MAX_SIZE;
+     *   - util/qemu-coroutine.c|204| <<coroutine_pool_put>> if (unlikely(batch->size >= COROUTINE_POOL_BATCH_MAX_SIZE)) {
+     */
     if (unlikely(batch->size >= COROUTINE_POOL_BATCH_MAX_SIZE)) {
         CoroutinePoolBatch *next = QSLIST_NEXT(batch, next);
 
+        /*
+	 * Local pool最多两个batch
+	 */
         /* Is the local pool full? */
         if (next) {
             QSLIST_REMOVE_HEAD(local_pool, next);
@@ -214,15 +630,92 @@ static void coroutine_pool_put(Coroutine *co)
     batch->size++;
 }
 
+/*
+ * 没有iothread应该就是mainloop
+ * (gdb) bt
+ * #0  coroutine_pool_get_local () at ../util/qemu-coroutine.c:116
+ * #1  0x00005555561cb785 in coroutine_pool_get () at ../util/qemu-coroutine.c:181
+ * #2  0x00005555561cb8c7 in qemu_coroutine_create (entry=0x5555560034f4 <blk_aio_write_entry>, opaque=0x5555582fd4d0)
+ *     at ../util/qemu-coroutine.c:222
+ * #3  0x00005555560033cc in blk_aio_prwv (blk=0x55555846f060, offset=540709888, bytes=1024, iobuf=0x5555577f63e8,
+ *     co_entry=0x5555560034f4 <blk_aio_write_entry>, flags=BDRV_REQ_REGISTERED_BUF,
+ *     cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350) at ../block/block-backend.c:1600
+ * #4  0x0000555556003927 in blk_aio_pwritev (blk=0x55555846f060, offset=540709888, qiov=0x5555577f63e8,
+ *     flags=BDRV_REQ_REGISTERED_BUF, cb=0x555555e2b9c9 <virtio_blk_rw_complete>, opaque=0x5555577f6350)
+ *     at ../block/block-backend.c:1722
+ * #5  0x0000555555e2c003 in submit_requests (s=0x5555584688c0, mrb=0x7fffffffd640, start=0, num_reqs=1, niov=-1) at ../hw/block/virtio-blk.c:259
+ * #6  0x0000555555e2c12f in virtio_blk_submit_multireq (s=0x5555584688c0, mrb=0x7fffffffd640) at ../hw/block/virtio-blk.c:294
+ * #7  0x0000555555e2e065 in virtio_blk_handle_vq (s=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1008
+ * #8  0x0000555555e2e0f8 in virtio_blk_handle_output (vdev=0x5555584688c0, vq=0x5555584b0960) at ../hw/block/virtio-blk.c:1028
+ * #9  0x0000555555e89d02 in virtio_queue_notify_vq (vq=0x5555584b0960) at ../hw/virtio/virtio.c:2484
+ * #10 0x0000555555e8d53c in virtio_queue_host_notifier_read (n=0x5555584b09d4) at ../hw/virtio/virtio.c:3869
+ * #11 0x00005555561a74d8 in aio_dispatch_handler (ctx=0x55555745ee50, node=0x7fffe43dfba0) at ../util/aio-posix.c:376
+ * #12 0x00005555561a76ed in aio_dispatch_handlers (ctx=0x55555745ee50) at ../util/aio-posix.c:427
+ * #13 0x00005555561a7749 in aio_dispatch (ctx=0x55555745ee50) at ../util/aio-posix.c:437
+ * #14 0x00005555561c9148 in aio_ctx_dispatch (source=0x55555745ee50, callback=0x0, user_data=0x0) at ../util/async.c:361
+ * #15 0x00007ffff6fd394b in g_main_dispatch (context=0x55555745f260) at ../glib/gmain.c:3325
+ * #16 g_main_context_dispatch (context=0x55555745f260) at ../glib/gmain.c:4043
+ * #17 0x00005555561ca939 in glib_pollfds_poll () at ../util/main-loop.c:287
+ * #18 0x00005555561ca9c7 in os_host_main_loop_wait (timeout=657614) at ../util/main-loop.c:310
+ * #19 0x00005555561caaf6 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:589
+ * #20 0x0000555555c2dc8a in qemu_main_loop () at ../system/runstate.c:835
+ * #21 0x00005555560d28b5 in qemu_default_main (opaque=0x0) at ../system/main.c:50
+ * #22 0x00005555560d296f in main (argc=25, argv=0x7fffffffdb28) at ../system/main.c:80
+ *
+ * 非test的对qemu_coroutine_create()的调用:
+ *   - block/aio_task.c|94| <<aio_task_pool_start_task>> qemu_coroutine_enter(qemu_coroutine_create(aio_task_co, task));
+ *   - block/blkverify.c|214| <<blkverify_co_prwv>> co_a = qemu_coroutine_create(blkverify_do_test_req, r);
+ *   - block/blkverify.c|215| <<blkverify_co_prwv>> co_b = qemu_coroutine_create(blkverify_do_raw_req, r);
+ *   - block/block-backend.c|1600| <<blk_aio_prwv>> co = qemu_coroutine_create(co_entry, acb);
+ *   - block/block-backend.c|1906| <<blk_aio_zone_report>> co = qemu_coroutine_create(blk_aio_zone_report_entry, acb);
+ *   - block/block-backend.c|1947| <<blk_aio_zone_mgmt>> co = qemu_coroutine_create(blk_aio_zone_mgmt_entry, acb);
+ *   - block/block-backend.c|1987| <<blk_aio_zone_append>> co = qemu_coroutine_create(blk_aio_zone_append_entry, acb);
+ *   - block/block-copy.c|989| <<block_copy_async>> .co = qemu_coroutine_create(block_copy_async_co_entry, call_state),
+ *   - block/export/vduse-blk.c|109| <<vduse_blk_vq_handler>> qemu_coroutine_create(vduse_blk_virtio_process_req, req);
+ *   - block/export/vhost-user-blk-server.c|99| <<vu_blk_process_vq>> qemu_coroutine_create(vu_blk_virtio_process_req, req);
+ *   - block/mirror.c|455| <<mirror_perform>> co = qemu_coroutine_create(mirror_co_read, op);
+ *   - block/mirror.c|458| <<mirror_perform>> co = qemu_coroutine_create(mirror_co_zero, op);
+ *   - block/mirror.c|461| <<mirror_perform>> co = qemu_coroutine_create(mirror_co_discard, op);
+ *   - block/qcow2.c|1969| <<qcow2_open>> qemu_coroutine_create(qcow2_open_entry, &qoc));
+ *   - block/qed.c|326| <<qed_need_check_timer_cb>> Coroutine *co = qemu_coroutine_create(qed_need_check_timer_entry, opaque);
+ *   - block/qed.c|383| <<bdrv_qed_drain_begin>> co = qemu_coroutine_create(qed_need_check_timer_entry, s);
+ *   - block/qed.c|594| <<bdrv_qed_open>> qemu_coroutine_enter(qemu_coroutine_create(bdrv_qed_open_entry, &qoc));
+ *   - block/quorum.c|331| <<quorum_rewrite_bad_versions>> co = qemu_coroutine_create(quorum_rewrite_entry, &data);
+ *   - block/quorum.c|629| <<read_quorum_children>> co = qemu_coroutine_create(read_quorum_children_entry, &data);
+ *   - block/quorum.c|743| <<quorum_co_pwritev>> co = qemu_coroutine_create(write_quorum_entry, &data);
+ *   - block/throttle-groups.c|445| <<throttle_group_restart_queue>> co = qemu_coroutine_create(throttle_group_restart_queue_entry, rd);
+ *   - hw/9pfs/9p.c|4220| <<pdu_submit>> co = qemu_coroutine_create(handler, pdu);
+ *   - hw/9pfs/9p.c|4377| <<v9fs_reset>> co = qemu_coroutine_create(virtfs_co_reset, &data);
+ *   - hw/remote/remote-obj.c|124| <<remote_object_machine_done>> co = qemu_coroutine_create(mpqemu_remote_msg_loop_co, comdev);
+ *   - job.c|1128| <<job_start>> job->co = qemu_coroutine_create(job_co_entry, job);
+ *   - migration/migration.c|942| <<migration_incoming_process>> Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
+ *   - monitor/hmp.c|1167| <<handle_hmp_command>> Coroutine *co = qemu_coroutine_create(handle_hmp_command_co, &data);
+ *   - monitor/monitor.c|724| <<monitor_init_globals>> qmp_dispatcher_co = qemu_coroutine_create(monitor_qmp_dispatcher_co, NULL);
+ *   - nbd/server.c|3209| <<nbd_client_receive_next_request>> client->recv_coroutine = qemu_coroutine_create(nbd_trip, req);
+ *   - nbd/server.c|3294| <<nbd_client_receive_next_request>> co = qemu_coroutine_create(nbd_co_client_start, client);
+ *   - net/colo-compare.c|822| <<compare_chr_send>> sendco->co = qemu_coroutine_create(_compare_chr_send, sendco);
+ *   - net/filter-mirror.c|127| <<filter_send>> Coroutine *co = qemu_coroutine_create(filter_send_co, &data);
+ *   - qemu-img.c|2138| <<convert_do_copy>> s->co[i] = qemu_coroutine_create(convert_co_do_copy, s);
+ *   - scsi/qemu-pr-helper.c|816| <<accept_client>> prh->co = qemu_coroutine_create(prh_co_entry, prh);
+ *   - tools/i386/qemu-vmsr-helper.c|295| <<accept_client>> vmsrh->co = qemu_coroutine_create(vh_co_entry, vmsrh);
+ *   - util/qemu-co-timeout.c|75| <<qemu_co_timeout>> co = qemu_coroutine_create(qemu_co_timeout_entry, s);
+ *   - util/vhost-user-server.c|446| <<vhost_user_server_attach_aio_context>> server->co_trip = qemu_coroutine_create(vu_client_trip, server);
+ */
 Coroutine *qemu_coroutine_create(CoroutineEntry *entry, void *opaque)
 {
     Coroutine *co = NULL;
 
     if (IS_ENABLED(CONFIG_COROUTINE_POOL)) {
+        /*
+	 * 只在此处调用
+	 */
         co = coroutine_pool_get();
     }
 
     if (!co) {
+        /*
+	 * 只在此处调用
+	 */
         co = qemu_coroutine_new();
     }
 
@@ -232,6 +725,10 @@ Coroutine *qemu_coroutine_create(CoroutineEntry *entry, void *opaque)
     return co;
 }
 
+/*
+ * 在以下调用coroutine_delete():
+ *   - util/qemu-coroutine.c|769| <<qemu_aio_coroutine_enter>> coroutine_delete(to);
+ */
 static void coroutine_delete(Coroutine *co)
 {
     co->caller = NULL;
@@ -243,6 +740,12 @@ static void coroutine_delete(Coroutine *co)
     }
 }
 
+/*
+ * 在以下调用qemu_aio_coroutine_enter():
+ *   - util/async.c|571| <<co_schedule_bh_cb>> qemu_aio_coroutine_enter(ctx, co);
+ *   - util/async.c|710| <<aio_co_enter>> qemu_aio_coroutine_enter(ctx, co);
+ *   - util/qemu-coroutine.c|625| <<qemu_coroutine_enter>> qemu_aio_coroutine_enter(qemu_get_current_aio_context(), co);
+ */
 void qemu_aio_coroutine_enter(AioContext *ctx, Coroutine *co)
 {
     QSIMPLEQ_HEAD(, Coroutine) pending = QSIMPLEQ_HEAD_INITIALIZER(pending);
@@ -339,6 +842,26 @@ void coroutine_fn qemu_coroutine_yield(void)
     qemu_coroutine_switch(self, to, COROUTINE_YIELD);
 }
 
+/*
+ * 注释:
+ * Return true if the coroutine is currently entered
+ *
+ * A coroutine is "entered" if it has not yielded from the current
+ * qemu_coroutine_enter() call used to run it.  This does not mean that the
+ * coroutine is currently executing code since it may have transferred control
+ * to another coroutine using qemu_coroutine_enter().
+ *
+ * When several coroutines enter each other there may be no way to know which
+ * ones have already been entered.  In such situations this function can be
+ * used to avoid recursively entering coroutines.
+ *
+ * 非test调用的地方:
+ *   - block/io_uring.c|219| <<luring_process_completions>> if (!qemu_coroutine_entered(luringcb->co)) {
+ *   - block/linux-aio.c|108| <<qemu_laio_process_completion>> if (!qemu_coroutine_entered(laiocb->co)) {
+ *   - hw/9pfs/xen-9p-backend.c|312| <<xen_9pfs_bh>> wait = ring->co != NULL && qemu_coroutine_entered(ring->co);
+ *   - nbd/server.c|776| <<nbd_server_tls_handshake>> if (!qemu_coroutine_entered(data->co)) {
+ *   - util/qemu-coroutine.c|630| <<qemu_coroutine_enter_if_inactive>> if (!qemu_coroutine_entered(co)) {
+ */
 bool qemu_coroutine_entered(Coroutine *co)
 {
     return co->caller;
@@ -349,18 +872,58 @@ AioContext *qemu_coroutine_get_aio_context(Coroutine *co)
     return co->ctx;
 }
 
+/*
+ * cakked by:
+ *   - hw/block/virtio-blk.c|2142| <<virtio_blk_device_realize>> qemu_coroutine_inc_pool_size(conf->num_queues * conf->queue_size / 2);
+ */
 void qemu_coroutine_inc_pool_size(unsigned int additional_pool_size)
 {
+    /*
+     * 在以下使用global_pool_lock:
+     *   - util/qemu-coroutine.c|138| <<QSLIST_HEAD>> static QemuMutex global_pool_lock;
+     *   - util/qemu-coroutine.c|276| <<coroutine_pool_refill_local>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|294| <<coroutine_pool_put_global>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|554| <<qemu_coroutine_inc_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|560| <<qemu_coroutine_dec_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|599| <<qemu_coroutine_init>> qemu_mutex_init(&global_pool_lock);
+     */
     QEMU_LOCK_GUARD(&global_pool_lock);
+    /*
+     * 在以下使用global_pool_max_size:
+     *   - util/qemu-coroutine.c|389| <<coroutine_pool_put_global>> unsigned int max = MIN(global_pool_max_size,
+     *   - util/qemu-coroutine.c|664| <<qemu_coroutine_inc_pool_size>> global_pool_max_size += additional_pool_size;
+     *   - util/qemu-coroutine.c|670| <<qemu_coroutine_dec_pool_size>> global_pool_max_size -= removing_pool_size;
+     */
     global_pool_max_size += additional_pool_size;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|2190| <<virtio_blk_device_unrealize>> qemu_coroutine_dec_pool_size(conf->num_queues * conf->queue_size / 2);
+ */
 void qemu_coroutine_dec_pool_size(unsigned int removing_pool_size)
 {
     QEMU_LOCK_GUARD(&global_pool_lock);
+    /*
+     * 在以下使用global_pool_max_size:
+     *   - util/qemu-coroutine.c|389| <<coroutine_pool_put_global>> unsigned int max = MIN(global_pool_max_size,
+     *   - util/qemu-coroutine.c|664| <<qemu_coroutine_inc_pool_size>> global_pool_max_size += additional_pool_size;
+     *   - util/qemu-coroutine.c|670| <<qemu_coroutine_dec_pool_size>> global_pool_max_size -= removing_pool_size;
+     */
     global_pool_max_size -= removing_pool_size;
 }
 
+/*
+ * (gdb) bt
+ * #0  get_global_pool_hard_max_size () at ../util/qemu-coroutine.c:365
+ * #1  0x00005555561cbec7 in qemu_coroutine_init () at ../util/qemu-coroutine.c:400
+ * #2  0x000055555623192d in __libc_csu_init ()
+ * #3  0x00007ffff4bdb838 in __libc_start_main () from /lib64/libc.so.6
+ * #4  0x000055555588a80e in _start ()
+ *
+ * 在以下调用get_global_pool_hard_max_size():
+ *   - util/qemu-coroutine.c|715| <<qemu_coroutine_init>> global_pool_hard_max_size = get_global_pool_hard_max_size();
+ */
 static unsigned int get_global_pool_hard_max_size(void)
 {
 #ifdef __linux__
@@ -396,6 +959,21 @@ static unsigned int get_global_pool_hard_max_size(void)
 
 static void __attribute__((constructor)) qemu_coroutine_init(void)
 {
+    /*
+     * 在以下使用global_pool_lock:
+     *   - util/qemu-coroutine.c|138| <<QSLIST_HEAD>> static QemuMutex global_pool_lock;
+     *   - util/qemu-coroutine.c|276| <<coroutine_pool_refill_local>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|294| <<coroutine_pool_put_global>> WITH_QEMU_LOCK_GUARD(&global_pool_lock) {
+     *   - util/qemu-coroutine.c|554| <<qemu_coroutine_inc_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|560| <<qemu_coroutine_dec_pool_size>> QEMU_LOCK_GUARD(&global_pool_lock);
+     *   - util/qemu-coroutine.c|599| <<qemu_coroutine_init>> qemu_mutex_init(&global_pool_lock);
+     */
     qemu_mutex_init(&global_pool_lock);
+    /*
+     * 在以下使用global_pool_hard_max_size:
+     *   - util/qemu-coroutine.c|136| <<QSLIST_HEAD>> static unsigned int global_pool_hard_max_size;
+     *   - util/qemu-coroutine.c|296| <<coroutine_pool_put_global>> unsigned int max = MIN(global_pool_max_size, global_pool_hard_max_size);
+     *   - util/qemu-coroutine.c|600| <<qemu_coroutine_init>> global_pool_hard_max_size = get_global_pool_hard_max_size();
+     */
     global_pool_hard_max_size = get_global_pool_hard_max_size();
 }
diff --git a/util/qemu-option.c b/util/qemu-option.c
index 770300dff..5a21697f2 100644
--- a/util/qemu-option.c
+++ b/util/qemu-option.c
@@ -605,6 +605,9 @@ QemuOpts *qemu_opts_find(QemuOptsList *list, const char *id)
     return NULL;
 }
 
+/*
+ * 特别特别多的调用
+ */
 QemuOpts *qemu_opts_create(QemuOptsList *list, const char *id,
                            int fail_if_exists, Error **errp)
 {
@@ -740,6 +743,41 @@ void qemu_opts_print(QemuOpts *opts, const char *separator)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  get_opt_name_value (params=0x7fffffffe098 "socket,id=serial0,path=serial.sock,server,nowait", firstname=0x0,
+ *     warn_on_flag=false, help_wanted=0x0, name=0x7fffffffd8a0, value=0x7fffffffd8a8) at ../util/qemu-option.c:749
+ * #1  0x00005555561b869b in opts_parse_id (params=0x7fffffffe098 "socket,id=serial0,path=serial.sock,server,nowait")
+ *     at ../util/qemu-option.c:839
+ * #2  0x00005555561b8866 in opts_parse (list=0x555557346440 <qemu_chardev_opts>, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, errp=0x7fffffffd958) at ../util/qemu-option.c:886
+ * #3  0x00005555561b8a24 in qemu_opts_parse_noisily (list=0x555557346440 <qemu_chardev_opts>, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true) at ../util/qemu-option.c:935
+ * #4  0x0000555555c36ae8 in qemu_init (argc=25, argv=0x7fffffffdbf8) at ../system/vl.c:3238
+ * #5  0x00005555560d294a in main (argc=25, argv=0x7fffffffdbf8) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  get_opt_name_value (params=0x7fffffffe0bb "server,nowait", firstname=0x0, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, name=0x7fffffffd898, value=0x7fffffffd8a0) at ../util/qemu-option.c:749
+ * #1  0x00005555561b8533 in opts_do_parse (opts=0x55555745e180, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", firstname=0x0, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, errp=0x7fffffffd958) at ../util/qemu-option.c:808
+ * #2  0x00005555561b8931 in opts_parse (list=0x555557346440 <qemu_chardev_opts>, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, errp=0x7fffffffd958) at ../util/qemu-option.c:898
+ * #3  0x00005555561b8a24 in qemu_opts_parse_noisily (list=0x555557346440 <qemu_chardev_opts>,
+ *     params=0x7fffffffe098 "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true)
+ *     at ../util/qemu-option.c:935
+ * #4  0x0000555555c36ae8 in qemu_init (argc=25, argv=0x7fffffffdbf8) at ../system/vl.c:3238
+ * #5  0x00005555560d294a in main (argc=25, argv=0x7fffffffdbf8) at ../system/main.c:71
+ *
+ *
+ * 在以下使用get_opt_name_value():
+ *   - util/qemu-option.c|808| <<opts_do_parse>> p = get_opt_name_value(p, firstname, warn_on_flag, help_wanted, &option, &value);
+ *   - util/qemu-option.c|839| <<opts_parse_id>> p = get_opt_name_value(p, NULL, false, NULL, &name, &value);
+ *   - util/qemu-option.c|858| <<has_help_option>> p = get_opt_name_value(p, NULL, false, &ret, &name, &value);
+ */
 static const char *get_opt_name_value(const char *params,
                                       const char *firstname,
                                       bool warn_on_flag,
@@ -770,6 +808,10 @@ static const char *get_opt_name_value(const char *params,
                 is_help = is_help_option(*name);
             }
             if (!is_help && warn_on_flag) {
+                /*
+		 * warning: short-form boolean option 'server' deprecated
+		 * Please use server=on instead
+		 */
                 warn_report("short-form boolean option '%s%s' deprecated", prefix, *name);
                 if (g_str_equal(*name, "delay")) {
                     error_printf("Please use nodelay=%s instead\n", prefix[0] ? "on" : "off");
@@ -796,6 +838,11 @@ static const char *get_opt_name_value(const char *params,
     return p;
 }
 
+/*
+ * 在以下使用opts_do_parse():
+ *   - util/qemu-option.c|878| <<qemu_opts_do_parse>> return opts_do_parse(opts, params, firstname, false, NULL, errp);
+ *   - util/qemu-option.c|898| <<opts_parse>> if (!opts_do_parse(opts, params, firstname, warn_on_flag, help_wanted, errp)) {
+ */
 static bool opts_do_parse(QemuOpts *opts, const char *params,
                           const char *firstname,
                           bool warn_on_flag, bool *help_wanted, Error **errp)
@@ -805,6 +852,12 @@ static bool opts_do_parse(QemuOpts *opts, const char *params,
     QemuOpt *opt;
 
     for (p = params; *p;) {
+        /*
+	 * 在以下使用get_opt_name_value():
+	 *   - util/qemu-option.c|808| <<opts_do_parse>> p = get_opt_name_value(p, firstname, warn_on_flag, help_wanted, &option, &value);
+	 *   - util/qemu-option.c|839| <<opts_parse_id>> p = get_opt_name_value(p, NULL, false, NULL, &name, &value);
+	 *   - util/qemu-option.c|858| <<has_help_option>> p = get_opt_name_value(p, NULL, false, &ret, &name, &value);
+	 */
         p = get_opt_name_value(p, firstname, warn_on_flag, help_wanted, &option, &value);
         if (help_wanted && *help_wanted) {
             g_free(option);
@@ -830,6 +883,10 @@ static bool opts_do_parse(QemuOpts *opts, const char *params,
     return true;
 }
 
+/*
+ * 在以下使用opts_parse_id():
+ *   - util/qemu-option.c|886| <<opts_parse>> char *id = opts_parse_id(params);
+ */
 static char *opts_parse_id(const char *params)
 {
     const char *p;
@@ -872,12 +929,63 @@ bool has_help_option(const char *params)
  * key=, and is treated as if key was @firstname.
  * On error, store an error object through @errp if non-null.
  */
+/*
+ * 在以下使用qemu_opts_do_parse():
+ *   - block.c|7335| <<bdrv_img_create>> if (!qemu_opts_do_parse(opts, options, NULL, errp)) {
+ *   - chardev/char.c|502| <<qemu_chr_parse_compat>> if (!qemu_opts_do_parse(opts, p + pos + 1, NULL, &local_err)) {
+ *   - chardev/char.c|541| <<qemu_chr_parse_compat>> if (!qemu_opts_do_parse(opts, p, "path", &local_err)) {
+ *   - net/net.c|1917| <<netdev_is_modern>> qemu_opts_do_parse(opts, optstr, dummy_opts.implied_opt_name,
+ *   - qemu-img.c|2572| <<img_convert>> if (!qemu_opts_do_parse(opts, options, NULL, &local_err)) {
+ *   - qemu-img.c|4371| <<img_amend>> if (!qemu_opts_do_parse(opts, options, NULL, &err)) {
+ *   - qemu-img.c|4376| <<img_amend>> if (qemu_opts_do_parse(opts, options, NULL, NULL)) {
+ *   - qemu-img.c|5499| <<img_measure>> if (!qemu_opts_do_parse(opts, options, NULL, &local_err)) {
+ */
 bool qemu_opts_do_parse(QemuOpts *opts, const char *params,
                        const char *firstname, Error **errp)
 {
+    /*
+     * 在以下使用opts_do_parse():
+     *   - util/qemu-option.c|878| <<qemu_opts_do_parse>> return opts_do_parse(opts, params, firstname, false, NULL, errp);
+     *   - util/qemu-option.c|898| <<opts_parse>> if (!opts_do_parse(opts, params, firstname, warn_on_flag, help_wanted, errp)) {
+     */
     return opts_do_parse(opts, params, firstname, false, NULL, errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  get_opt_name_value (params=0x7fffffffe098 "socket,id=serial0,path=serial.sock,server,nowait", firstname=0x0,
+ *     warn_on_flag=false, help_wanted=0x0, name=0x7fffffffd8a0, value=0x7fffffffd8a8) at ../util/qemu-option.c:749
+ * #1  0x00005555561b869b in opts_parse_id (params=0x7fffffffe098 "socket,id=serial0,path=serial.sock,server,nowait")
+ *     at ../util/qemu-option.c:839
+ * #2  0x00005555561b8866 in opts_parse (list=0x555557346440 <qemu_chardev_opts>, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, errp=0x7fffffffd958) at ../util/qemu-option.c:886
+ * #3  0x00005555561b8a24 in qemu_opts_parse_noisily (list=0x555557346440 <qemu_chardev_opts>, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true) at ../util/qemu-option.c:935
+ * #4  0x0000555555c36ae8 in qemu_init (argc=25, argv=0x7fffffffdbf8) at ../system/vl.c:3238
+ * #5  0x00005555560d294a in main (argc=25, argv=0x7fffffffdbf8) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  get_opt_name_value (params=0x7fffffffe0bb "server,nowait", firstname=0x0, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, name=0x7fffffffd898, value=0x7fffffffd8a0) at ../util/qemu-option.c:749
+ * #1  0x00005555561b8533 in opts_do_parse (opts=0x55555745e180, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", firstname=0x0, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, errp=0x7fffffffd958) at ../util/qemu-option.c:808
+ * #2  0x00005555561b8931 in opts_parse (list=0x555557346440 <qemu_chardev_opts>, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, errp=0x7fffffffd958) at ../util/qemu-option.c:898
+ * #3  0x00005555561b8a24 in qemu_opts_parse_noisily (list=0x555557346440 <qemu_chardev_opts>,
+ *     params=0x7fffffffe098 "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true)
+ *     at ../util/qemu-option.c:935
+ * #4  0x0000555555c36ae8 in qemu_init (argc=25, argv=0x7fffffffdbf8) at ../system/vl.c:3238
+ * #5  0x00005555560d294a in main (argc=25, argv=0x7fffffffdbf8) at ../system/main.c:71
+ *
+ *
+ * 在以下使用opts_parse():
+ *   - util/qemu-option.c|965| <<qemu_opts_parse>> return opts_parse(list, params, permit_abbrev, false, NULL, errp);
+ *   - util/qemu-option.c|983| <<qemu_opts_parse_noisily>> opts = opts_parse(list, params, permit_abbrev, true,
+ *           opts_accepts_any(list) ? NULL : &help_wanted, &err);
+ */
 static QemuOpts *opts_parse(QemuOptsList *list, const char *params,
                             bool permit_abbrev,
                             bool warn_on_flag, bool *help_wanted, Error **errp)
@@ -889,12 +997,20 @@ static QemuOpts *opts_parse(QemuOptsList *list, const char *params,
     assert(!permit_abbrev || list->implied_opt_name);
     firstname = permit_abbrev ? list->implied_opt_name : NULL;
 
+    /*
+     * 特别特别多的调用
+     */
     opts = qemu_opts_create(list, id, !list->merge_lists, errp);
     g_free(id);
     if (opts == NULL) {
         return NULL;
     }
 
+    /*
+     * 在以下使用opts_do_parse():
+     *   - util/qemu-option.c|878| <<qemu_opts_do_parse>> return opts_do_parse(opts, params, firstname, false, NULL, errp);
+     *   - util/qemu-option.c|898| <<opts_parse>> if (!opts_do_parse(opts, params, firstname, warn_on_flag, help_wanted, errp)) {
+     */
     if (!opts_do_parse(opts, params, firstname,
                        warn_on_flag, help_wanted, errp)) {
         qemu_opts_del(opts);
@@ -917,6 +1033,35 @@ QemuOpts *qemu_opts_parse(QemuOptsList *list, const char *params,
     return opts_parse(list, params, permit_abbrev, false, NULL, errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  get_opt_name_value (params=0x7fffffffe098 "socket,id=serial0,path=serial.sock,server,nowait", firstname=0x0,
+ *     warn_on_flag=false, help_wanted=0x0, name=0x7fffffffd8a0, value=0x7fffffffd8a8) at ../util/qemu-option.c:749
+ * #1  0x00005555561b869b in opts_parse_id (params=0x7fffffffe098 "socket,id=serial0,path=serial.sock,server,nowait")
+ *     at ../util/qemu-option.c:839
+ * #2  0x00005555561b8866 in opts_parse (list=0x555557346440 <qemu_chardev_opts>, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, errp=0x7fffffffd958) at ../util/qemu-option.c:886
+ * #3  0x00005555561b8a24 in qemu_opts_parse_noisily (list=0x555557346440 <qemu_chardev_opts>, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true) at ../util/qemu-option.c:935
+ * #4  0x0000555555c36ae8 in qemu_init (argc=25, argv=0x7fffffffdbf8) at ../system/vl.c:3238
+ * #5  0x00005555560d294a in main (argc=25, argv=0x7fffffffdbf8) at ../system/main.c:71
+ *
+ * (gdb) bt
+ * #0  get_opt_name_value (params=0x7fffffffe0bb "server,nowait", firstname=0x0, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, name=0x7fffffffd898, value=0x7fffffffd8a0) at ../util/qemu-option.c:749
+ * #1  0x00005555561b8533 in opts_do_parse (opts=0x55555745e180, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", firstname=0x0, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, errp=0x7fffffffd958) at ../util/qemu-option.c:808
+ * #2  0x00005555561b8931 in opts_parse (list=0x555557346440 <qemu_chardev_opts>, params=0x7fffffffe098
+ *     "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true, warn_on_flag=true,
+ *     help_wanted=0x7fffffffd957, errp=0x7fffffffd958) at ../util/qemu-option.c:898
+ * #3  0x00005555561b8a24 in qemu_opts_parse_noisily (list=0x555557346440 <qemu_chardev_opts>,
+ *     params=0x7fffffffe098 "socket,id=serial0,path=serial.sock,server,nowait", permit_abbrev=true)
+ *     at ../util/qemu-option.c:935
+ * #4  0x0000555555c36ae8 in qemu_init (argc=25, argv=0x7fffffffdbf8) at ../system/vl.c:3238
+ * #5  0x00005555560d294a in main (argc=25, argv=0x7fffffffdbf8) at ../system/main.c:71
+ */
 /**
  * Create a QemuOpts in @list and with options parsed from @params.
  * If @permit_abbrev, the first key=value in @params may omit key=,
@@ -925,6 +1070,9 @@ QemuOpts *qemu_opts_parse(QemuOptsList *list, const char *params,
  * QMP context.  Do not use this function there!
  * Return the new QemuOpts on success, null pointer on error.
  */
+/*
+ * 特别特别多的调用
+ */
 QemuOpts *qemu_opts_parse_noisily(QemuOptsList *list, const char *params,
                                   bool permit_abbrev)
 {
@@ -932,6 +1080,12 @@ QemuOpts *qemu_opts_parse_noisily(QemuOptsList *list, const char *params,
     QemuOpts *opts;
     bool help_wanted = false;
 
+    /*
+     * 在以下使用opts_parse():
+     *   - util/qemu-option.c|965| <<qemu_opts_parse>> return opts_parse(list, params, permit_abbrev, false, NULL, errp);
+     *   - util/qemu-option.c|983| <<qemu_opts_parse_noisily>> opts = opts_parse(list, params, permit_abbrev, true,
+     *           opts_accepts_any(list) ? NULL : &help_wanted, &err);
+     */
     opts = opts_parse(list, params, permit_abbrev, true,
                       opts_accepts_any(list) ? NULL : &help_wanted,
                       &err);
diff --git a/util/qemu-timer.c b/util/qemu-timer.c
index 788466fe2..dd38b9460 100644
--- a/util/qemu-timer.c
+++ b/util/qemu-timer.c
@@ -322,6 +322,26 @@ int qemu_timeout_ns_to_ms(int64_t ns)
 /* qemu implementation of g_poll which uses a nanosecond timeout but is
  * otherwise identical to g_poll
  */
+/*
+ * 注释:
+ * qemu_poll_ns:
+ * @fds: Array of file descriptors
+ * @nfds: number of file descriptors
+ * @timeout: timeout in nanoseconds
+ *
+ * Perform a poll like g_poll but with a timeout in nanoseconds.
+ * See g_poll documentation for further details.
+ *
+ * Returns: number of fds ready
+ *
+ * 在以下使用qemu_poll_ns():
+ *   - hw/remote/vfio-user-obj.c|247| <<vfu_object_attach_ctx>> (void )qemu_poll_ns(pfds, 1, 500 * (int64_t)SCALE_MS);
+ *   - migration/rdma.c|1539| <<qemu_rdma_wait_comp_channel>> switch (qemu_poll_ns(pfds, 2, 100 * 1000 * 1000)) {
+ *   - util/fdmon-epoll.c|69| <<fdmon_epoll_wait>> ret = qemu_poll_ns(&pfd, 1, timeout);
+ *   - util/fdmon-poll.c|79| <<fdmon_poll_wait>> ret = qemu_poll_ns(pollfds, npfd, timeout);
+ *   - util/main-loop.c|338| <<os_host_main_loop_wait>> ret = qemu_poll_ns((GPollFD *)gpollfds->data, gpollfds->len, timeout);
+ *   - util/main-loop.c|560| <<os_host_main_loop_wait>> g_poll_ret = qemu_poll_ns(poll_fds, n_poll_fds + w->num, poll_timeout_ns);
+ */
 int qemu_poll_ns(GPollFD *fds, guint nfds, int64_t timeout)
 {
 #ifdef CONFIG_PPOLL
@@ -653,6 +673,10 @@ uint64_t timer_expire_time_ns(QEMUTimer *ts)
     return timer_pending(ts) ? ts->expire_time : -1;
 }
 
+/*
+ * called by:
+ *   - util/main-loop.c|665| <<main_loop_wait>> qemu_clock_run_all_timers();
+ */
 bool qemu_clock_run_all_timers(void)
 {
     bool progress = false;
diff --git a/util/rcu.c b/util/rcu.c
index fa32c942e..825057e60 100644
--- a/util/rcu.c
+++ b/util/rcu.c
@@ -43,11 +43,27 @@
 #define RCU_GP_LOCKED           (1UL << 0)
 #define RCU_GP_CTR              (1UL << 1)
 
+/*
+ *   - util/rcu.c|46| <<global>> unsigned long rcu_gp_ctr = RCU_GP_LOCKED
+ *   - include/qemu/rcu.h|87| <<rcu_read_lock>> ctr = qatomic_read(&rcu_gp_ctr);
+  4 util/rcu.c|69| <<rcu_gp_ongoing>> return v && (v != rcu_gp_ctr);
+  5 util/rcu.c|237| <<synchronize_rcu>> if (sizeof(rcu_gp_ctr) < 8) {
+  6 util/rcu.c|243| <<synchronize_rcu>> qatomic_set(&rcu_gp_ctr, rcu_gp_ctr ^ RCU_GP_CTR);
+  7 util/rcu.c|250| <<synchronize_rcu>> qatomic_set(&rcu_gp_ctr, rcu_gp_ctr ^ RCU_GP_CTR);
+  8 util/rcu.c|253| <<synchronize_rcu>> qatomic_set(&rcu_gp_ctr, rcu_gp_ctr + RCU_GP_CTR);
+ */
 unsigned long rcu_gp_ctr = RCU_GP_LOCKED;
 
 QemuEvent rcu_gp_event;
 static int in_drain_call_rcu;
 static QemuMutex rcu_registry_lock;
+/*
+ * 在以下使用rcu_sync_lock:
+ *   - util/rcu.c|173| <<synchronize_rcu>> QEMU_LOCK_GUARD(&rcu_sync_lock);
+ *   - util/rcu.c|436| <<rcu_init_complete>> qemu_mutex_init(&rcu_sync_lock);
+ *   - util/rcu.c|469| <<rcu_init_lock>> qemu_mutex_lock(&rcu_sync_lock);
+ *   - util/rcu.c|480| <<rcu_init_unlock>> qemu_mutex_unlock(&rcu_sync_lock);
+ */
 static QemuMutex rcu_sync_lock;
 
 /*
@@ -69,8 +85,24 @@ QEMU_DEFINE_CO_TLS(struct rcu_reader_data, rcu_reader)
 
 /* Protected by rcu_registry_lock.  */
 typedef QLIST_HEAD(, rcu_reader_data) ThreadList;
+/*
+ * 在以下使用registry:
+ *   - util/rcu.c|72| <<QLIST_HEAD>> static ThreadList registry = QLIST_HEAD_INITIALIZER(registry);
+ *   - util/rcu.c|86| <<wait_for_readers>> QLIST_FOREACH(index, &registry, node) {
+ *   - util/rcu.c|100| <<wait_for_readers>> QLIST_FOREACH_SAFE(index, &registry, node, tmp) {
+ *   - util/rcu.c|114| <<wait_for_readers>> if (QLIST_EMPTY(&registry)) {
+ *   - util/rcu.c|141| <<wait_for_readers>> QLIST_SWAP(&registry, &qsreaders, node);
+ *   - util/rcu.c|157| <<synchronize_rcu>> if (!QLIST_EMPTY(&registry)) {
+ *   - util/rcu.c|377| <<rcu_register_thread>> QLIST_INSERT_HEAD(&registry, get_ptr_rcu_reader(), node);
+ *   - util/rcu.c|460| <<rcu_init_child>> memset(&registry, 0, sizeof(registry));
+ */
 static ThreadList registry = QLIST_HEAD_INITIALIZER(registry);
 
+/*
+ * 在以下使用wait_for_readers():
+ *   - util/rcu.c|165| <<synchronize_rcu>> wait_for_readers();
+ *   - util/rcu.c|172| <<synchronize_rcu>> wait_for_readers();
+ */
 /* Wait for previous parity/grace period to be empty of readers.  */
 static void wait_for_readers(void)
 {
@@ -83,6 +115,17 @@ static void wait_for_readers(void)
          */
         qemu_event_reset(&rcu_gp_event);
 
+	/*
+	 * 在以下使用registry:
+	 *   - util/rcu.c|72| <<QLIST_HEAD>> static ThreadList registry = QLIST_HEAD_INITIALIZER(registry);
+	 *   - util/rcu.c|86| <<wait_for_readers>> QLIST_FOREACH(index, &registry, node) {
+	 *   - util/rcu.c|100| <<wait_for_readers>> QLIST_FOREACH_SAFE(index, &registry, node, tmp) {
+	 *   - util/rcu.c|114| <<wait_for_readers>> if (QLIST_EMPTY(&registry)) {
+	 *   - util/rcu.c|141| <<wait_for_readers>> QLIST_SWAP(&registry, &qsreaders, node);
+	 *   - util/rcu.c|157| <<synchronize_rcu>> if (!QLIST_EMPTY(&registry)) {
+	 *   - util/rcu.c|377| <<rcu_register_thread>> QLIST_INSERT_HEAD(&registry, get_ptr_rcu_reader(), node);
+	 *   - util/rcu.c|460| <<rcu_init_child>> memset(&registry, 0, sizeof(registry));
+	 */
         QLIST_FOREACH(index, &registry, node) {
             qatomic_set(&index->waiting, true);
         }
@@ -97,7 +140,23 @@ static void wait_for_readers(void)
          */
         smp_mb_global();
 
+	/*
+	 * 在以下使用registry:
+	 *   - util/rcu.c|72| <<QLIST_HEAD>> static ThreadList registry = QLIST_HEAD_INITIALIZER(registry);
+	 *   - util/rcu.c|86| <<wait_for_readers>> QLIST_FOREACH(index, &registry, node) {
+	 *   - util/rcu.c|100| <<wait_for_readers>> QLIST_FOREACH_SAFE(index, &registry, node, tmp) {
+	 *   - util/rcu.c|114| <<wait_for_readers>> if (QLIST_EMPTY(&registry)) {
+	 *   - util/rcu.c|141| <<wait_for_readers>> QLIST_SWAP(&registry, &qsreaders, node);
+	 *   - util/rcu.c|157| <<synchronize_rcu>> if (!QLIST_EMPTY(&registry)) {
+	 *   - util/rcu.c|377| <<rcu_register_thread>> QLIST_INSERT_HEAD(&registry, get_ptr_rcu_reader(), node);
+	 *   - util/rcu.c|460| <<rcu_init_child>> memset(&registry, 0, sizeof(registry));
+	 */
         QLIST_FOREACH_SAFE(index, &registry, node, tmp) {
+            /*
+	     * 注释:
+	     * Check whether a quiescent state was crossed between the beginning of
+	     * update_counter_and_wait and now.
+	     */
             if (!rcu_gp_ongoing(&index->ctr)) {
                 QLIST_REMOVE(index, node);
                 QLIST_INSERT_HEAD(&qsreaders, index, node);
@@ -141,8 +200,26 @@ static void wait_for_readers(void)
     QLIST_SWAP(&registry, &qsreaders, node);
 }
 
+/*
+ * 在以下使用synchronize_rcu():
+ *   - tests/unit/rcutorture.c|156| <<rcu_update_perf_test>> synchronize_rcu();
+ *   - tests/unit/rcutorture.c|337| <<rcu_update_stress_test>> synchronize_rcu();
+ *   - tests/unit/rcutorture.c|354| <<rcu_fake_update_stress_test>> synchronize_rcu();
+ *   - tests/unit/test-rcu-list.c|244| <<rcu_q_updater>> synchronize_rcu();
+ *   - tests/unit/test-rcu-list.c|246| <<rcu_q_updater>> synchronize_rcu();
+ *   - tests/unit/test-rcu-list.c|306| <<rcu_qtest>> synchronize_rcu();
+ *   - tests/unit/test-rcu-list.c|310| <<rcu_qtest>> synchronize_rcu();
+ *   - util/rcu.c|285| <<call_rcu_thread>> synchronize_rcu();
+ */
 void synchronize_rcu(void)
 {
+    /*
+     * 在以下使用rcu_sync_lock:
+     *   - util/rcu.c|173| <<synchronize_rcu>> QEMU_LOCK_GUARD(&rcu_sync_lock);
+     *   - util/rcu.c|436| <<rcu_init_complete>> qemu_mutex_init(&rcu_sync_lock);
+     *   - util/rcu.c|469| <<rcu_init_lock>> qemu_mutex_lock(&rcu_sync_lock);
+     *   - util/rcu.c|480| <<rcu_init_unlock>> qemu_mutex_unlock(&rcu_sync_lock);
+     */
     QEMU_LOCK_GUARD(&rcu_sync_lock);
 
     /* Write RCU-protected pointers before reading p_rcu_reader->ctr.
@@ -154,6 +231,17 @@ void synchronize_rcu(void)
     smp_mb_global();
 
     QEMU_LOCK_GUARD(&rcu_registry_lock);
+    /*
+     * 在以下使用registry:
+     *   - util/rcu.c|72| <<QLIST_HEAD>> static ThreadList registry = QLIST_HEAD_INITIALIZER(registry);
+     *   - util/rcu.c|86| <<wait_for_readers>> QLIST_FOREACH(index, &registry, node) {
+     *   - util/rcu.c|100| <<wait_for_readers>> QLIST_FOREACH_SAFE(index, &registry, node, tmp) {
+     *   - util/rcu.c|114| <<wait_for_readers>> if (QLIST_EMPTY(&registry)) {
+     *   - util/rcu.c|141| <<wait_for_readers>> QLIST_SWAP(&registry, &qsreaders, node);
+     *   - util/rcu.c|157| <<synchronize_rcu>> if (!QLIST_EMPTY(&registry)) {
+     *   - util/rcu.c|377| <<rcu_register_thread>> QLIST_INSERT_HEAD(&registry, get_ptr_rcu_reader(), node);
+     *   - util/rcu.c|460| <<rcu_init_child>> memset(&registry, 0, sizeof(registry));
+     */
     if (!QLIST_EMPTY(&registry)) {
         if (sizeof(rcu_gp_ctr) < 8) {
             /* For architectures with 32-bit longs, a two-subphases algorithm
@@ -162,6 +250,11 @@ void synchronize_rcu(void)
              * Switch parity: 0 -> 1, 1 -> 0.
              */
             qatomic_set(&rcu_gp_ctr, rcu_gp_ctr ^ RCU_GP_CTR);
+	    /*
+	     * 在以下使用wait_for_readers():
+             *   - util/rcu.c|165| <<synchronize_rcu>> wait_for_readers();
+             *   - util/rcu.c|172| <<synchronize_rcu>> wait_for_readers();
+	     */
             wait_for_readers();
             qatomic_set(&rcu_gp_ctr, rcu_gp_ctr ^ RCU_GP_CTR);
         } else {
@@ -169,6 +262,11 @@ void synchronize_rcu(void)
             qatomic_set(&rcu_gp_ctr, rcu_gp_ctr + RCU_GP_CTR);
         }
 
+	/*
+	 * 在以下使用wait_for_readers():
+         *   - util/rcu.c|165| <<synchronize_rcu>> wait_for_readers();
+         *   - util/rcu.c|172| <<synchronize_rcu>> wait_for_readers();
+	 */
         wait_for_readers();
     }
 }
@@ -252,6 +350,10 @@ retry:
     return node;
 }
 
+/*
+ * 在以下使用call_rcu_thread():
+ *   - util/rcu.c|444| <<rcu_init_complete>> qemu_thread_create(&thread, "call_rcu", call_rcu_thread, NULL, QEMU_THREAD_DETACHED);
+ */
 static void *call_rcu_thread(void *opaque)
 {
     struct rcu_head *node;
@@ -305,6 +407,14 @@ static void *call_rcu_thread(void *opaque)
     abort();
 }
 
+/*
+ * 在以下使用call_rcu1():
+ *   - include/qemu/rcu.h|150| <<call_rcu>> call_rcu1(({ \
+ *   - include/qemu/rcu.h|159| <<g_free_rcu>> call_rcu1(({ \
+ *   - tests/unit/test-rcu-list.c|223| <<rcu_q_updater>> call_rcu1(&prev_el->rcu, reclaim_list_el);
+ *   - tests/unit/test-rcu-list.c|300| <<rcu_qtest>> call_rcu1(&prev_el->rcu, reclaim_list_el);
+ *   - util/rcu.c|456| <<drain_call_rcu>> call_rcu1(&rcu_drain.rcu, drain_rcu_callback);
+ */
 void call_rcu1(struct rcu_head *node, void (*func)(struct rcu_head *node))
 {
     node->func = func;
@@ -374,6 +484,17 @@ void rcu_register_thread(void)
 {
     assert(get_ptr_rcu_reader()->ctr == 0);
     qemu_mutex_lock(&rcu_registry_lock);
+    /*
+     * 在以下使用registry:
+     *   - util/rcu.c|72| <<QLIST_HEAD>> static ThreadList registry = QLIST_HEAD_INITIALIZER(registry);
+     *   - util/rcu.c|86| <<wait_for_readers>> QLIST_FOREACH(index, &registry, node) {
+     *   - util/rcu.c|100| <<wait_for_readers>> QLIST_FOREACH_SAFE(index, &registry, node, tmp) {
+     *   - util/rcu.c|114| <<wait_for_readers>> if (QLIST_EMPTY(&registry)) {
+     *   - util/rcu.c|141| <<wait_for_readers>> QLIST_SWAP(&registry, &qsreaders, node);
+     *   - util/rcu.c|157| <<synchronize_rcu>> if (!QLIST_EMPTY(&registry)) {
+     *   - util/rcu.c|377| <<rcu_register_thread>> QLIST_INSERT_HEAD(&registry, get_ptr_rcu_reader(), node);
+     *   - util/rcu.c|460| <<rcu_init_child>> memset(&registry, 0, sizeof(registry));
+     */
     QLIST_INSERT_HEAD(&registry, get_ptr_rcu_reader(), node);
     qemu_mutex_unlock(&rcu_registry_lock);
 }
@@ -399,11 +520,23 @@ void rcu_remove_force_rcu_notifier(Notifier *n)
     qemu_mutex_unlock(&rcu_registry_lock);
 }
 
+/*
+ * 在以下使用rcu_init_complete():
+ *   - util/rcu.c|597| <<rcu_init_child>> rcu_init_complete();
+ *   - util/rcu.c|607| <<rcu_init>> rcu_init_complete();
+ */
 static void rcu_init_complete(void)
 {
     QemuThread thread;
 
     qemu_mutex_init(&rcu_registry_lock);
+    /*
+     * 在以下使用rcu_sync_lock:
+     *   - util/rcu.c|173| <<synchronize_rcu>> QEMU_LOCK_GUARD(&rcu_sync_lock);
+     *   - util/rcu.c|436| <<rcu_init_complete>> qemu_mutex_init(&rcu_sync_lock);
+     *   - util/rcu.c|469| <<rcu_init_lock>> qemu_mutex_lock(&rcu_sync_lock);
+     *   - util/rcu.c|480| <<rcu_init_unlock>> qemu_mutex_unlock(&rcu_sync_lock);
+     */
     qemu_mutex_init(&rcu_sync_lock);
     qemu_event_init(&rcu_gp_event, true);
 
@@ -431,12 +564,23 @@ void rcu_disable_atfork(void)
 }
 
 #ifdef CONFIG_POSIX
+/*
+ * 在以下使用rcu_init_lock():
+ *   - util/rcu.c|605| <<rcu_init>> pthread_atfork(rcu_init_lock, rcu_init_unlock, rcu_init_child);
+ */
 static void rcu_init_lock(void)
 {
     if (atfork_depth < 1) {
         return;
     }
 
+    /*
+     * 在以下使用rcu_sync_lock:
+     *   - util/rcu.c|173| <<synchronize_rcu>> QEMU_LOCK_GUARD(&rcu_sync_lock);
+     *   - util/rcu.c|436| <<rcu_init_complete>> qemu_mutex_init(&rcu_sync_lock);
+     *   - util/rcu.c|469| <<rcu_init_lock>> qemu_mutex_lock(&rcu_sync_lock);
+     *   - util/rcu.c|480| <<rcu_init_unlock>> qemu_mutex_unlock(&rcu_sync_lock);
+     */
     qemu_mutex_lock(&rcu_sync_lock);
     qemu_mutex_lock(&rcu_registry_lock);
 }
@@ -448,15 +592,37 @@ static void rcu_init_unlock(void)
     }
 
     qemu_mutex_unlock(&rcu_registry_lock);
+    /*
+     * 在以下使用rcu_sync_lock:
+     *   - util/rcu.c|173| <<synchronize_rcu>> QEMU_LOCK_GUARD(&rcu_sync_lock);
+     *   - util/rcu.c|436| <<rcu_init_complete>> qemu_mutex_init(&rcu_sync_lock);
+     *   - util/rcu.c|469| <<rcu_init_lock>> qemu_mutex_lock(&rcu_sync_lock);
+     *   - util/rcu.c|480| <<rcu_init_unlock>> qemu_mutex_unlock(&rcu_sync_lock);
+     */
     qemu_mutex_unlock(&rcu_sync_lock);
 }
 
+/*
+ * 在以下使用rcu_init_child():
+ *   - util/rcu.c|605| <<rcu_init>> pthread_atfork(rcu_init_lock, rcu_init_unlock, rcu_init_child);
+ */
 static void rcu_init_child(void)
 {
     if (atfork_depth < 1) {
         return;
     }
 
+    /*
+     * 在以下使用registry:
+     *   - util/rcu.c|72| <<QLIST_HEAD>> static ThreadList registry = QLIST_HEAD_INITIALIZER(registry);
+     *   - util/rcu.c|86| <<wait_for_readers>> QLIST_FOREACH(index, &registry, node) {
+     *   - util/rcu.c|100| <<wait_for_readers>> QLIST_FOREACH_SAFE(index, &registry, node, tmp) {
+     *   - util/rcu.c|114| <<wait_for_readers>> if (QLIST_EMPTY(&registry)) {
+     *   - util/rcu.c|141| <<wait_for_readers>> QLIST_SWAP(&registry, &qsreaders, node);
+     *   - util/rcu.c|157| <<synchronize_rcu>> if (!QLIST_EMPTY(&registry)) {
+     *   - util/rcu.c|377| <<rcu_register_thread>> QLIST_INSERT_HEAD(&registry, get_ptr_rcu_reader(), node);
+     *   - util/rcu.c|460| <<rcu_init_child>> memset(&registry, 0, sizeof(registry));
+     */
     memset(&registry, 0, sizeof(registry));
     rcu_init_complete();
 }
-- 
2.39.5 (Apple Git-154)

