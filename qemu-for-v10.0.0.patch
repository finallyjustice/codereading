From 609418e43b4357103819eeadc010ba0bced97b09 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Fri, 25 Apr 2025 15:57:32 -0700
Subject: [PATCH 1/1] qemu for v10.0.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 block/accounting.c              | 103 +++++++++
 block/block-backend.c           | 106 ++++++++++
 hw/block/vhost-user-blk.c       |   7 +
 hw/block/virtio-blk-common.c    |   7 +
 hw/block/virtio-blk.c           | 359 ++++++++++++++++++++++++++++++++
 hw/ide/core.c                   |  14 ++
 hw/nvme/ctrl.c                  |  14 ++
 hw/scsi/scsi-disk.c             |  56 +++++
 hw/scsi/virtio-scsi-dataplane.c |  39 ++++
 hw/scsi/virtio-scsi.c           |  11 +
 hw/virtio/iothread-vq-mapping.c |  10 +
 hw/virtio/virtio-bus.c          |   7 +
 hw/virtio/virtio.c              |  33 +++
 include/hw/virtio/virtio-blk.h  |  54 +++++
 include/hw/virtio/virtio-scsi.h |  10 +
 include/hw/virtio/virtio.h      |   7 +
 util/osdep.c                    |   7 +
 util/qemu-coroutine.c           |  50 +++++
 18 files changed, 894 insertions(+)

diff --git a/block/accounting.c b/block/accounting.c
index 3e4615956..cf5b09a41 100644
--- a/block/accounting.c
+++ b/block/accounting.c
@@ -102,6 +102,50 @@ BlockAcctTimedStats *block_acct_interval_next(BlockAcctStats *stats,
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/xen-block.c|375| <<xen_block_do_aio>> block_acct_start(blk_get_stats(dataplane->blk), &request->acct,
+ *   - hw/block/dataplane/xen-block.c|388| <<xen_block_do_aio>> block_acct_start(blk_get_stats(dataplane->blk), &request->acct,
+ *   - hw/block/virtio-blk.c|342| <<virtio_blk_handle_flush>> block_acct_start(blk_get_stats(s->blk), &req->acct, 0,
+ *   - hw/block/virtio-blk.c|425| <<virtio_blk_handle_discard_write_zeroes>> block_acct_start(blk_get_stats(s->blk), &req->acct, bytes,
+ *   - hw/block/virtio-blk.c|778| <<virtio_blk_handle_zone_append>> block_acct_start(blk_get_stats(s->blk), &req->acct, len,
+ *   - hw/block/virtio-blk.c|858| <<virtio_blk_handle_request>> block_acct_start(blk_get_stats(s->blk), &req->acct, req->qiov.size,
+ *   - hw/ide/atapi.c|95| <<cd_read_sector_sync>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/atapi.c|167| <<cd_read_sector>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/atapi.c|312| <<ide_atapi_cmd_reply>> block_acct_start(blk_get_stats(s->blk), &s->acct, size,
+ *   - hw/ide/atapi.c|434| <<ide_atapi_cmd_read_dma>> block_acct_start(blk_get_stats(s->blk), &s->acct, s->packet_transfer_size,
+ *   - hw/ide/core.c|498| <<ide_issue_trim_cb>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|824| <<ide_sector_read>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|995| <<ide_sector_start_dma>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|999| <<ide_sector_start_dma>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|1098| <<ide_sector_write>> block_acct_start(blk_get_stats(s->blk), &s->acct,
+ *   - hw/ide/core.c|1134| <<ide_flush_cache>> block_acct_start(blk_get_stats(s->blk), &s->acct, 0, BLOCK_ACCT_FLUSH);
+ *   - hw/ide/macio.c|221| <<pmac_ide_transfer>> block_acct_start(blk_get_stats(s->blk), &s->acct, io->len,
+ *   - hw/ide/macio.c|230| <<pmac_ide_transfer>> block_acct_start(blk_get_stats(s->blk), &s->acct, io->len,
+ *   - hw/ide/macio.c|234| <<pmac_ide_transfer>> block_acct_start(blk_get_stats(s->blk), &s->acct, io->len,
+ *   - hw/nvme/ctrl.c|2716| <<nvme_verify>> block_acct_start(blk_get_stats(blk), &req->acct, ctx->data.iov.size,
+ *   - hw/nvme/ctrl.c|3070| <<nvme_copy_in_completed_cb>> block_acct_start(blk_get_stats(dns->blkconf.blk), &iocb->acct.write, 0,
+ *   - hw/nvme/ctrl.c|3307| <<nvme_do_copy>> block_acct_start(blk_get_stats(sns->blkconf.blk), &iocb->acct.read, 0,
+ *   - hw/nvme/ctrl.c|3469| <<nvme_compare>> block_acct_start(blk_get_stats(blk), &req->acct, data_len,
+ *   - hw/nvme/ctrl.c|3667| <<nvme_read>> block_acct_start(blk_get_stats(blk), &req->acct, data_size,
+ *   - hw/nvme/ctrl.c|3837| <<nvme_do_write>> block_acct_start(blk_get_stats(blk), &req->acct, data_size,
+ *   - hw/nvme/dif.c|647| <<nvme_dif_rw>> block_acct_start(blk_get_stats(blk), &req->acct, ctx->data.iov.size,
+ *   - hw/nvme/dif.c|693| <<nvme_dif_rw>> block_acct_start(blk_get_stats(blk), &req->acct, ctx->data.iov.size,
+ *   - hw/scsi/scsi-disk.c|400| <<scsi_write_do_fua>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - hw/scsi/scsi-disk.c|509| <<scsi_do_read>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|568| <<scsi_read_data>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - hw/scsi/scsi-disk.c|667| <<scsi_write_data>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|1723| <<scsi_disk_emulate_mode_select>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - hw/scsi/scsi-disk.c|1789| <<scsi_unmap_complete_noio>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|1906| <<scsi_write_same_complete>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|1955| <<scsi_disk_emulate_write_same>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|1981| <<scsi_disk_emulate_write_same>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct,
+ *   - hw/scsi/scsi-disk.c|2250| <<scsi_disk_emulate_command>> block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
+ *   - qemu-io-cmds.c|1541| <<aio_read_f>> block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,
+ *   - qemu-io-cmds.c|1696| <<aio_write_f>> block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,
+ *   - qemu-io-cmds.c|1709| <<aio_flush_f>> block_acct_start(blk_get_stats(blk), &cookie, 0, BLOCK_ACCT_FLUSH);
+ *   - system/dma-helpers.c|320| <<dma_acct_start>> block_acct_start(blk_get_stats(blk), cookie, sg->size, type);
+ */
 void block_acct_start(BlockAcctStats *stats, BlockAcctCookie *cookie,
                       int64_t bytes, enum BlockAcctType type)
 {
@@ -241,11 +285,70 @@ static void block_account_one_io(BlockAcctStats *stats, BlockAcctCookie *cookie,
     cookie->type = BLOCK_ACCT_NONE;
 }
 
+/*
+ * 在以下使用block_acct_done():
+ *   - hw/block/dataplane/xen-block.c|304| <<xen_block_complete_aio>> block_acct_done(blk_get_stats(dataplane->blk), &request->acct);
+ *   - hw/block/virtio-blk.c|139| <<virtio_blk_rw_complete>> block_acct_done(blk_get_stats(s->blk), &req->acct);
+ *   - hw/block/virtio-blk.c|154| <<virtio_blk_flush_complete>> block_acct_done(blk_get_stats(s->blk), &req->acct);
+ *   - hw/block/virtio-blk.c|171| <<virtio_blk_discard_write_zeroes_complete>> block_acct_done(blk_get_stats(s->blk), &req->acct);
+ *   - hw/ide/ahci.c|1007| <<ncq_finish>> block_acct_done(blk_get_stats(ncq_tfs->drive->port.ifs[0].blk),
+ *   - hw/ide/atapi.c|120| <<cd_read_sector_sync>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/atapi.c|140| <<cd_read_sector_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/atapi.c|417| <<ide_atapi_cmd_read_dma_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|470| <<ide_issue_trim_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|779| <<ide_sector_read_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|982| <<ide_dma_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|1040| <<ide_sector_write_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|1118| <<ide_flush_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/macio.c|125| <<pmac_ide_atapi_transfer_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/macio.c|205| <<pmac_ide_transfer_cb>> block_acct_done(blk_get_stats(s->blk), &s->acct);
+ *   - hw/nvme/ctrl.c|2174| <<nvme_rw_complete_cb>> block_acct_done(stats, acct);
+ *   - hw/nvme/ctrl.c|2264| <<nvme_verify_cb>> block_acct_done(stats, acct);
+ *   - hw/nvme/ctrl.c|2413| <<nvme_compare_mdata_cb>> block_acct_done(stats, acct)
+ *   - hw/nvme/ctrl.c|2482| <<nvme_compare_data_cb>> block_acct_done(stats, acct);
+ *   - hw/nvme/ctrl.c|2785| <<nvme_copy_done>> block_acct_done(stats, &iocb->acct.read);
+ *   - hw/nvme/ctrl.c|2786| <<nvme_copy_done>> block_acct_done(stats, &iocb->acct.write);
+ *   - hw/scsi/scsi-disk.c|359| <<scsi_aio_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|442| <<scsi_dma_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|480| <<scsi_read_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|530| <<scsi_do_read_cb>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|616| <<scsi_write_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|1822| <<scsi_unmap_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|1899| <<scsi_write_same_complete>> block_acct_done(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - qemu-io-cmds.c|1375| <<aio_write_done>> block_acct_done(blk_get_stats(ctx->blk), &ctx->acct);
+ *   - qemu-io-cmds.c|1418| <<aio_read_done>> block_acct_done(blk_get_stats(ctx->blk), &ctx->acct);
+ *   - qemu-io-cmds.c|1711| <<aio_flush_f>> block_acct_done(blk_get_stats(blk), &cookie);
+ */
 void block_acct_done(BlockAcctStats *stats, BlockAcctCookie *cookie)
 {
     block_account_one_io(stats, cookie, false);
 }
 
+/*
+ * 在以下使用block_acct_failed():
+ *   - hw/block/dataplane/xen-block.c|306| <<xen_block_complete_aio>> block_acct_failed(blk_get_stats(dataplane->blk), &request->acct);
+ *   - hw/block/virtio-blk.c|90| <<virtio_blk_handle_rw_error>> block_acct_failed(blk_get_stats(s->blk), &req->acct);
+ *   - hw/ide/atapi.c|118| <<cd_read_sector_sync>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/atapi.c|135| <<cd_read_sector_cb>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/atapi.c|415| <<ide_atapi_cmd_read_dma_cb>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|472| <<ide_issue_trim_cb>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/core.c|866| <<ide_handle_rw_error>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/macio.c|123| <<pmac_ide_atapi_transfer_cb>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/ide/macio.c|203| <<pmac_ide_transfer_cb>> block_acct_failed(blk_get_stats(s->blk), &s->acct);
+ *   - hw/nvme/ctrl.c|2151| <<nvme_rw_complete_cb>> block_acct_failed(stats, acct);
+ *   - hw/nvme/ctrl.c|2256| <<nvme_verify_cb>> block_acct_failed(stats, acct);
+ *   - hw/nvme/ctrl.c|2358| <<nvme_compare_mdata_cb>> block_acct_failed(stats, acct);
+ *   - hw/nvme/ctrl.c|2443| <<nvme_compare_data_cb>> block_acct_failed(stats, acct);
+ *   - hw/nvme/ctrl.c|2782| <<nvme_copy_done>> block_acct_failed(stats, &iocb->acct.read);
+ *   - hw/nvme/ctrl.c|2783| <<nvme_copy_done>> block_acct_failed(stats, &iocb->acct.write);
+ *   - hw/scsi/scsi-disk.c|304| <<scsi_handle_rw_error>> block_acct_failed(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|440| <<scsi_dma_complete>> block_acct_failed(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|478| <<scsi_read_complete>> block_acct_failed(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|528| <<scsi_do_read_cb>> block_acct_failed(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - hw/scsi/scsi-disk.c|614| <<scsi_write_complete>> block_acct_failed(blk_get_stats(s->qdev.conf.blk), &r->acct);
+ *   - qemu-io-cmds.c|1371| <<aio_write_done>> block_acct_failed(blk_get_stats(ctx->blk), &ctx->acct);
+ *   - qemu-io-cmds.c|1403| <<aio_read_done>> block_acct_failed(blk_get_stats(ctx->blk), &ctx->acct);
+ */
 void block_acct_failed(BlockAcctStats *stats, BlockAcctCookie *cookie)
 {
     block_account_one_io(stats, cookie, true);
diff --git a/block/block-backend.c b/block/block-backend.c
index a402db13f..a7cc36af6 100644
--- a/block/block-backend.c
+++ b/block/block-backend.c
@@ -1560,6 +1560,18 @@ static const AIOCBInfo blk_aio_em_aiocb_info = {
     .aiocb_size         = sizeof(BlkAioEmAIOCB),
 };
 
+/*
+ * 在以下使用blk_aio_complete():
+ *   - block/block-backend.c|1576| <<blk_aio_complete_bh>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1630| <<blk_aio_read_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1642| <<blk_aio_write_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1804| <<blk_aio_ioctl_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1838| <<blk_aio_pdiscard_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1883| <<blk_aio_flush_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1913| <<blk_aio_zone_report_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1956| <<blk_aio_zone_mgmt_entry>> blk_aio_complete(acb);
+ *   - block/block-backend.c|1996| <<blk_aio_zone_append_entry>> blk_aio_complete(acb);
+ */
 static void blk_aio_complete(BlkAioEmAIOCB *acb)
 {
     if (acb->has_returned) {
@@ -1569,6 +1581,17 @@ static void blk_aio_complete(BlkAioEmAIOCB *acb)
     }
 }
 
+/*
+ * 在以下使用blk_aio_complete_bh():
+ *   - block/block-backend.c|1615| <<blk_aio_prwv>>
+ *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+ *   - block/block-backend.c|1942| <<blk_aio_zone_report>>
+ *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+ *   - block/block-backend.c|1983| <<blk_aio_zone_mgmt>>
+ *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+ *   - block/block-backend.c|2022| <<blk_aio_zone_append>>
+ *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+ */
 static void blk_aio_complete_bh(void *opaque)
 {
     BlkAioEmAIOCB *acb = opaque;
@@ -1576,6 +1599,15 @@ static void blk_aio_complete_bh(void *opaque)
     blk_aio_complete(acb);
 }
 
+/*
+ * called by:
+ *   - block/block-backend.c|1641| <<blk_aio_pwrite_zeroes>> return blk_aio_prwv(blk, offset, bytes, NULL, blk_aio_write_entry,
+ *   - block/block-backend.c|1712| <<blk_aio_preadv>> return blk_aio_prwv(blk, offset, qiov->size, qiov,
+ *   - block/block-backend.c|1722| <<blk_aio_pwritev>> return blk_aio_prwv(blk, offset, qiov->size, qiov,
+ *   - block/block-backend.c|1781| <<blk_aio_ioctl>> return blk_aio_prwv(blk, req, 0, buf, blk_aio_ioctl_entry, 0, cb, opaque);
+ *   - block/block-backend.c|1816| <<blk_aio_pdiscard>> return blk_aio_prwv(blk, offset, bytes, NULL, blk_aio_pdiscard_entry, 0,
+ *   - block/block-backend.c|1860| <<blk_aio_flush>> return blk_aio_prwv(blk, 0, 0, NULL, blk_aio_flush_entry, 0, cb, opaque);
+ */
 static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset,
                                 int64_t bytes,
                                 void *iobuf, CoroutineEntry co_entry,
@@ -1602,6 +1634,17 @@ static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset,
 
     acb->has_returned = true;
     if (acb->rwco.ret != NOT_DONE) {
+        /*
+	 * 在以下使用blk_aio_complete_bh():
+	 *   - block/block-backend.c|1615| <<blk_aio_prwv>>
+	 *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+	 *   - block/block-backend.c|1942| <<blk_aio_zone_report>>
+	 *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+	 *   - block/block-backend.c|1983| <<blk_aio_zone_mgmt>>
+	 *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+	 *   - block/block-backend.c|2022| <<blk_aio_zone_append>>
+	 *      replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(), blk_aio_complete_bh, acb);
+	 */
         replay_bh_schedule_oneshot_event(qemu_get_current_aio_context(),
                                          blk_aio_complete_bh, acb);
     }
@@ -1621,6 +1664,13 @@ static void coroutine_fn blk_aio_read_entry(void *opaque)
     blk_aio_complete(acb);
 }
 
+/*
+ * 在以下使用blk_aio_write_entry():
+ *   - block/block-backend.c|1650| <<blk_aio_pwrite_zeroes>> return blk_aio_prwv(blk,
+ *      offset, bytes, NULL, blk_aio_write_entry, flags | BDRV_REQ_ZERO_WRITE, cb, opaque);
+ *   - block/block-backend.c|1753| <<blk_aio_pwritev>> return blk_aio_prwv(blk,
+ *      offset, qiov->size, qiov, blk_aio_write_entry, flags, cb, opaque);
+ */
 static void coroutine_fn blk_aio_write_entry(void *opaque)
 {
     BlkAioEmAIOCB *acb = opaque;
@@ -1638,6 +1688,13 @@ BlockAIOCB *blk_aio_pwrite_zeroes(BlockBackend *blk, int64_t offset,
                                   BlockCompletionFunc *cb, void *opaque)
 {
     IO_CODE();
+    /*
+     * 在以下使用blk_aio_write_entry():
+     *   - block/block-backend.c|1650| <<blk_aio_pwrite_zeroes>> return blk_aio_prwv(blk,
+     *      offset, bytes, NULL, blk_aio_write_entry, flags | BDRV_REQ_ZERO_WRITE, cb, opaque);
+     *   - block/block-backend.c|1753| <<blk_aio_pwritev>> return blk_aio_prwv(blk,
+     *      offset, qiov->size, qiov, blk_aio_write_entry, flags, cb, opaque);
+     */
     return blk_aio_prwv(blk, offset, bytes, NULL, blk_aio_write_entry,
                         flags | BDRV_REQ_ZERO_WRITE, cb, opaque);
 }
@@ -1713,12 +1770,40 @@ BlockAIOCB *blk_aio_preadv(BlockBackend *blk, int64_t offset,
                         blk_aio_read_entry, flags, cb, opaque);
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/xen-block.c|393| <<xen_block_do_aio>> blk_aio_pwritev(dataplane->blk, request->start, &request->v, 0,
+ *   - hw/block/m25p80.c|581| <<flash_sync_page>> blk_aio_pwritev(s->blk, page * s->pi->page_size, iov, 0,
+ *   - hw/block/m25p80.c|597| <<flash_sync_area>> blk_aio_pwritev(s->blk, off, iov, 0, blk_sync_complete, iov);
+ *   - hw/block/virtio-blk.c|259| <<submit_requests>> blk_aio_pwritev(blk, sector_num << BDRV_SECTOR_BITS, qiov,
+ *   - hw/ide/core.c|1100| <<ide_sector_write>> s->pio_aiocb = blk_aio_pwritev(s->blk, sector_num << BDRV_SECTOR_BITS,
+ *   - hw/nvme/ctrl.c|1475| <<nvme_blk_write>> req->aiocb = blk_aio_pwritev(blk, offset, &req->sg.iov, 0, cb, req);
+ *   - hw/nvme/ctrl.c|2964| <<nvme_copy_out_cb>> iocb->aiocb = blk_aio_pwritev(dns->blkconf.blk, nvme_moff(dns, iocb->slba),
+ *   - hw/nvme/ctrl.c|3073| <<nvme_copy_in_completed_cb>> iocb->aiocb = blk_aio_pwritev(dns->blkconf.blk, nvme_l2b(dns, iocb->slba),
+ *   - hw/nvme/dif.c|530| <<nvme_dif_rw_mdata_out_cb>> req->aiocb = blk_aio_pwritev(blk, offset, &ctx->mdata.iov, 0,
+ *   - hw/nvme/dif.c|696| <<nvme_dif_rw>> req->aiocb = blk_aio_pwritev(ns->blkconf.blk, offset, &ctx->data.iov, 0,
+ *   - hw/scsi/scsi-disk.c|1911| <<scsi_write_same_complete>> r->req.aiocb = blk_aio_pwritev(s->qdev.conf.blk,
+ *   - hw/scsi/scsi-disk.c|1983| <<scsi_disk_emulate_write_same>> r->req.aiocb = blk_aio_pwritev(s->qdev.conf.blk,
+ *   - hw/scsi/scsi-disk.c|3140| <<scsi_dma_writev>> return blk_aio_pwritev(s->qdev.conf.blk, offset, iov, 0, cb, cb_opaque);
+ *   - qemu-img.c|4497| <<bench_cb>> acb = blk_aio_pwritev(b->blk, offset, b->qiov, 0, bench_cb, b);
+ *   - qemu-io-cmds.c|663| <<do_aio_writev>> blk_aio_pwritev(blk, offset, qiov, flags, aio_rw_done, &async_ret);
+ *   - qemu-io-cmds.c|1699| <<aio_write_f>> blk_aio_pwritev(blk, ctx->offset, &ctx->qiov, ctx->flags,
+ *   - system/dma-helpers.c|265| <<dma_blk_write_io_func>> return blk_aio_pwritev(blk, offset, iov, 0, cb, cb_opaque);
+ *   - tests/unit/test-replication.c|113| <<test_blk_write>> blk_aio_pwritev(blk, offset, &qiov, 0, blk_rw_done, &async_ret);
+ */
 BlockAIOCB *blk_aio_pwritev(BlockBackend *blk, int64_t offset,
                             QEMUIOVector *qiov, BdrvRequestFlags flags,
                             BlockCompletionFunc *cb, void *opaque)
 {
     IO_CODE();
     assert((uint64_t)qiov->size <= INT64_MAX);
+    /*
+     * 在以下使用blk_aio_write_entry():
+     *   - block/block-backend.c|1650| <<blk_aio_pwrite_zeroes>> return blk_aio_prwv(blk,
+     *      offset, bytes, NULL, blk_aio_write_entry, flags | BDRV_REQ_ZERO_WRITE, cb, opaque);
+     *   - block/block-backend.c|1753| <<blk_aio_pwritev>> return blk_aio_prwv(blk,
+     *      offset, qiov->size, qiov, blk_aio_write_entry, flags, cb, opaque);
+     */
     return blk_aio_prwv(blk, offset, qiov->size, qiov,
                         blk_aio_write_entry, flags, cb, opaque);
 }
@@ -1853,6 +1938,20 @@ static void coroutine_fn blk_aio_flush_entry(void *opaque)
     blk_aio_complete(acb);
 }
 
+/*
+ * 在以下使用blk_aio_flush():
+ *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+ *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+ *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+ *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+ *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+ *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+ *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+ *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+ *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+ *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+ *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+ */
 BlockAIOCB *blk_aio_flush(BlockBackend *blk,
                           BlockCompletionFunc *cb, void *opaque)
 {
@@ -2120,6 +2219,13 @@ BlockdevOnError blk_get_on_error(BlockBackend *blk, bool is_read)
     return is_read ? blk->on_read_error : blk->on_write_error;
 }
 
+/*
+ * 在以下使用blk_get_error_action():
+ *   - hw/block/virtio-blk.c|76| <<virtio_blk_handle_rw_error>> BlockErrorAction action = blk_get_error_action(s->blk, is_read, error);
+ *   - hw/ide/ahci.c|1022| <<ncq_cb>> BlockErrorAction action = blk_get_error_action(ide_state->blk, is_read, -ret);
+ *   - hw/ide/core.c|860| <<ide_handle_rw_error>> BlockErrorAction action = blk_get_error_action(s->blk, is_read, error);
+ *   - hw/scsi/scsi-disk.c|297| <<scsi_handle_rw_error>> action = blk_get_error_action(s->qdev.conf.blk, is_read, error);
+ */
 BlockErrorAction blk_get_error_action(BlockBackend *blk, bool is_read,
                                       int error)
 {
diff --git a/hw/block/vhost-user-blk.c b/hw/block/vhost-user-blk.c
index ae42327cf..b68d005e8 100644
--- a/hw/block/vhost-user-blk.c
+++ b/hw/block/vhost-user-blk.c
@@ -475,6 +475,13 @@ static void vhost_user_blk_device_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用virtio_blk_cfg_size_params:
+     *   - hw/block/vhost-user-blk.c|478| <<vhost_user_blk_device_realize>>
+     *        config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+     *   - hw/block/virtio-blk.c|1815| <<virtio_blk_device_realize>>
+     *        s->config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+     */
     config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
                                          vdev->host_features);
     virtio_init(vdev, VIRTIO_ID_BLOCK, config_size);
diff --git a/hw/block/virtio-blk-common.c b/hw/block/virtio-blk-common.c
index e2f8e2f6d..475776b7f 100644
--- a/hw/block/virtio-blk-common.c
+++ b/hw/block/virtio-blk-common.c
@@ -34,6 +34,13 @@ static const VirtIOFeature feature_sizes[] = {
     {}
 };
 
+/*
+ * 在以下使用virtio_blk_cfg_size_params:
+ *   - hw/block/vhost-user-blk.c|478| <<vhost_user_blk_device_realize>>
+ *        config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+ *   - hw/block/virtio-blk.c|1815| <<virtio_blk_device_realize>>
+ *        s->config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+ */
 const VirtIOConfigSizeParams virtio_blk_cfg_size_params = {
     .min_size = VIRTIO_BLK_CFG_SIZE,
     .max_size = sizeof(struct virtio_blk_config),
diff --git a/hw/block/virtio-blk.c b/hw/block/virtio-blk.c
index 5077793e5..10adf214e 100644
--- a/hw/block/virtio-blk.c
+++ b/hw/block/virtio-blk.c
@@ -40,6 +40,11 @@
 
 static void virtio_blk_ioeventfd_attach(VirtIOBlock *s);
 
+/*
+ * 在以下使用virtio_blk_init_request():
+ *   - hw/block/virtio-blk.c|181| <<virtio_blk_get_request>> virtio_blk_init_request(s, vq, req);
+ *   - hw/block/virtio-blk.c|1395| <<virtio_blk_load_device>> virtio_blk_init_request(s, virtio_get_queue(vdev, vq_idx), req);
+ */
 static void virtio_blk_init_request(VirtIOBlock *s, VirtQueue *vq,
                                     VirtIOBlockReq *req)
 {
@@ -48,9 +53,36 @@ static void virtio_blk_init_request(VirtIOBlock *s, VirtQueue *vq,
     req->qiov.size = 0;
     req->in_len = 0;
     req->next = NULL;
+    /*
+     * 在以下使用VirtIOBlockReq->mr_next:
+     *   - hw/block/virtio-blk.c|51| <<virtio_blk_init_request>> req->mr_next = NULL;
+     *   - hw/block/virtio-blk.c|81| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+     *   - hw/block/virtio-blk.c|112| <<virtio_blk_rw_complete>> next = req->mr_next;
+     *   - hw/block/virtio-blk.c|253| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+     */
     req->mr_next = NULL;
 }
 
+/*
+ * 在以下使用virtio_blk_req_complete():
+ *   - hw/block/virtio-blk.c|88| <<virtio_blk_handle_rw_error>> virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
+ *   - hw/block/virtio-blk.c|138| <<virtio_blk_rw_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|153| <<virtio_blk_flush_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|169| <<virtio_blk_discard_write_zeroes_complete>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|217| <<virtio_blk_handle_scsi>> virtio_blk_req_complete(req, status);
+ *   - hw/block/virtio-blk.c|645| <<virtio_blk_zone_report_complete>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|694| <<virtio_blk_handle_zone_report>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|710| <<virtio_blk_zone_mgmt_complete>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|752| <<virtio_blk_handle_zone_mgmt>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|783| <<virtio_blk_zone_append_complete>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|821| <<virtio_blk_handle_zone_append>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|891| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
+ *   - hw/block/virtio-blk.c|949| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ *   - hw/block/virtio-blk.c|981| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
+ *   - hw/block/virtio-blk.c|998| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, err_status);
+ *   - hw/block/virtio-blk.c|1013| <<virtio_blk_handle_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
+ *   - hw/vmapple/virtio-blk.c|57| <<vmapple_virtio_blk_handle_unknown_request>> virtio_blk_req_complete(req, VIRTIO_BLK_S_OK);
+ */
 void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
 {
     VirtIOBlock *s = req->dev;
@@ -58,8 +90,33 @@ void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
 
     trace_virtio_blk_req_complete(vdev, req, status);
 
+    /*
+     * 根据Linux kernel的注释:
+     * The status byte is always the last byte of the virtblk request
+     * in-header. This helper fetches its value for all in-header formats
+     * that are currently defined.
+     *
+     * VirtIOBlockReq *req:
+     * -> struct virtio_blk_inhdr *in;
+     * -> struct virtio_blk_outhdr out;
+     */
     stb_p(&req->in->status, status);
+    /*
+     * 在以下使用VirtIOBlockReq->inhdr_undo:
+     *   - hw/block/virtio-blk.c|62| <<virtio_blk_req_complete>> iov_discard_undo(&req->inhdr_undo);
+     *   - hw/block/virtio-blk.c|867| <<virtio_blk_handle_request>> iov_discard_back_undoable(in_iov,
+     *                          &in_num, sizeof(struct virtio_blk_inhdr), &req->inhdr_undo);
+     *   - hw/block/virtio-blk.c|988| <<virtio_blk_handle_request>> iov_discard_undo(&req->inhdr_undo);
+     */
     iov_discard_undo(&req->inhdr_undo);
+    /*
+     * 在以下使用VirtIOBlockReq->outhdr_undo:
+     *   - hw/block/virtio-blk.c|112| <<virtio_blk_req_complete>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|964| <<virtio_blk_handle_request>> iov_discard_front_undoable(&out_iov,
+     *                           &out_num, sizeof(req->out), &req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|968| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|1100| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     */
     iov_discard_undo(&req->outhdr_undo);
     virtqueue_push(req->vq, &req->elem, req->in_len);
     if (qemu_in_iothread()) {
@@ -69,6 +126,12 @@ void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
     }
 }
 
+/*
+ * 在以下使用virtio_blk_handle_rw_error():
+ *   - hw/block/virtio-blk.c|133| <<virtio_blk_rw_complete>> if (virtio_blk_handle_rw_error(req, -ret, is_read, true)) {
+ *   - hw/block/virtio-blk.c|149| <<virtio_blk_flush_complete>> if (ret && virtio_blk_handle_rw_error(req, -ret, 0, true)) {
+ *   - hw/block/virtio-blk.c|165| <<virtio_blk_discard_write_zeroes_complete>> if (ret && virtio_blk_handle_rw_error(req, -ret, false, is_write_zeroes)) {
+ */
 static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
     bool is_read, bool acct_failed)
 {
@@ -76,6 +139,13 @@ static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
     BlockErrorAction action = blk_get_error_action(s->blk, is_read, error);
 
     if (action == BLOCK_ERROR_ACTION_STOP) {
+        /*
+	 * 在以下使用VirtIOBlockReq->mr_next:
+	 *   - hw/block/virtio-blk.c|51| <<virtio_blk_init_request>> req->mr_next = NULL;
+	 *   - hw/block/virtio-blk.c|81| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+	 *   - hw/block/virtio-blk.c|112| <<virtio_blk_rw_complete>> next = req->mr_next;
+	 *   - hw/block/virtio-blk.c|253| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+	 */
         /* Break the link as the next request is going to be parsed from the
          * ring again. Otherwise we may end up doing a double completion! */
         req->mr_next = NULL;
@@ -96,6 +166,13 @@ static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
     return action != BLOCK_ERROR_ACTION_IGNORE;
 }
 
+/*
+ * 在以下使用virtio_blk_rw_complete():
+ *   - hw/block/virtio-blk.c|266| <<submit_requests>> blk_aio_pwritev(blk, sector_num << BDRV_SECTOR_BITS, qiov,
+ *        flags, virtio_blk_rw_complete, mrb->reqs[start]);
+ *   - hw/block/virtio-blk.c|270| <<submit_requests>> blk_aio_preadv(blk, sector_num << BDRV_SECTOR_BITS, qiov,
+ *        flags, virtio_blk_rw_complete, mrb->reqs[start]);
+ */
 static void virtio_blk_rw_complete(void *opaque, int ret)
 {
     VirtIOBlockReq *next = opaque;
@@ -104,9 +181,20 @@ static void virtio_blk_rw_complete(void *opaque, int ret)
 
     while (next) {
         VirtIOBlockReq *req = next;
+        /*
+	 * 在以下使用VirtIOBlockReq->mr_next:
+	 *   - hw/block/virtio-blk.c|51| <<virtio_blk_init_request>> req->mr_next = NULL;
+	 *   - hw/block/virtio-blk.c|81| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+	 *   - hw/block/virtio-blk.c|112| <<virtio_blk_rw_complete>> next = req->mr_next;
+	 *   - hw/block/virtio-blk.c|253| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+	 */
         next = req->mr_next;
         trace_virtio_blk_rw_complete(vdev, req, ret);
 
+	/*
+	 * VirtIOBlockReq *req:
+	 * -> QEMUIOVector qiov;
+	 */
         if (req->qiov.nalloc != -1) {
             /* If nalloc is != -1 req->qiov is a local copy of the original
              * external iovec. It was allocated in submit_requests to be
@@ -125,6 +213,13 @@ static void virtio_blk_rw_complete(void *opaque, int ret)
              * the memory until the request is completed (which will
              * happen on the other side of the migration).
              */
+            /*
+	     * 在以下使用virtio_blk_handle_rw_error():
+	     *   - hw/block/virtio-blk.c|133| <<virtio_blk_rw_complete>> if (virtio_blk_handle_rw_error(req, -ret, is_read, true)) {
+	     *   - hw/block/virtio-blk.c|149| <<virtio_blk_flush_complete>> if (ret && virtio_blk_handle_rw_error(req, -ret, 0, true)) {
+	     *   - hw/block/virtio-blk.c|165| <<virtio_blk_discard_write_zeroes_complete>> if (ret && virtio_blk_handle_rw_error(req,
+	     *        -ret, false, is_write_zeroes)) {
+	     */
             if (virtio_blk_handle_rw_error(req, -ret, is_read, true)) {
                 continue;
             }
@@ -141,6 +236,13 @@ static void virtio_blk_flush_complete(void *opaque, int ret)
     VirtIOBlockReq *req = opaque;
     VirtIOBlock *s = req->dev;
 
+    /*
+     * 在以下使用virtio_blk_handle_rw_error():
+     *   - hw/block/virtio-blk.c|133| <<virtio_blk_rw_complete>> if (virtio_blk_handle_rw_error(req, -ret, is_read, true)) {
+     *   - hw/block/virtio-blk.c|149| <<virtio_blk_flush_complete>> if (ret && virtio_blk_handle_rw_error(req, -ret, 0, true)) {
+     *   - hw/block/virtio-blk.c|165| <<virtio_blk_discard_write_zeroes_complete>> if (ret && virtio_blk_handle_rw_error(req,
+     *        -ret, false, is_write_zeroes)) {
+     */
     if (ret && virtio_blk_handle_rw_error(req, -ret, 0, true)) {
         return;
     }
@@ -157,6 +259,13 @@ static void virtio_blk_discard_write_zeroes_complete(void *opaque, int ret)
     bool is_write_zeroes = (virtio_ldl_p(VIRTIO_DEVICE(s), &req->out.type) &
                             ~VIRTIO_BLK_T_BARRIER) == VIRTIO_BLK_T_WRITE_ZEROES;
 
+    /*
+     * 在以下使用virtio_blk_handle_rw_error():
+     *   - hw/block/virtio-blk.c|133| <<virtio_blk_rw_complete>> if (virtio_blk_handle_rw_error(req, -ret, is_read, true)) {
+     *   - hw/block/virtio-blk.c|149| <<virtio_blk_flush_complete>> if (ret && virtio_blk_handle_rw_error(req, -ret, 0, true)) {
+     *   - hw/block/virtio-blk.c|165| <<virtio_blk_discard_write_zeroes_complete>> if (ret && virtio_blk_handle_rw_error(req,
+     *        -ret, false, is_write_zeroes)) {
+     */
     if (ret && virtio_blk_handle_rw_error(req, -ret, false, is_write_zeroes)) {
         return;
     }
@@ -168,8 +277,16 @@ static void virtio_blk_discard_write_zeroes_complete(void *opaque, int ret)
     g_free(req);
 }
 
+/*
+ * 在以下使用virtio_blk_get_request():
+ *   - hw/block/virtio-blk.c|1034| <<virtio_blk_handle_vq>> while ((req = virtio_blk_get_request(s, vq))) {
+ */
 static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s, VirtQueue *vq)
 {
+    /*
+     * 89 typedef struct VirtIOBlockReq {
+     * 90     VirtQueueElement elem;
+     */
     VirtIOBlockReq *req = virtqueue_pop(vq, sizeof(VirtIOBlockReq));
 
     if (req) {
@@ -213,6 +330,12 @@ fail:
     g_free(req);
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|294| <<virtio_blk_submit_multireq>> submit_requests(s, mrb, 0, 1, -1);
+ *   - hw/block/virtio-blk.c|318| <<virtio_blk_submit_multireq>> submit_requests(s, mrb, start, num_reqs, niov);
+ *   - hw/block/virtio-blk.c|334| <<virtio_blk_submit_multireq>> submit_requests(s, mrb, start, num_reqs, niov);
+ */
 static inline void submit_requests(VirtIOBlock *s, MultiReqBuffer *mrb,
                                    int start, int num_reqs, int niov)
 {
@@ -239,6 +362,13 @@ static inline void submit_requests(VirtIOBlock *s, MultiReqBuffer *mrb,
         for (i = start + 1; i < start + num_reqs; i++) {
             qemu_iovec_concat(qiov, &mrb->reqs[i]->qiov, 0,
                               mrb->reqs[i]->qiov.size);
+	    /*
+	     * 在以下使用VirtIOBlockReq->mr_next:
+	     *   - hw/block/virtio-blk.c|51| <<virtio_blk_init_request>> req->mr_next = NULL;
+	     *   - hw/block/virtio-blk.c|81| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+	     *   - hw/block/virtio-blk.c|112| <<virtio_blk_rw_complete>> next = req->mr_next;
+	     *   - hw/block/virtio-blk.c|253| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+	     */
             mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
         }
 
@@ -284,6 +414,13 @@ static int multireq_compare(const void *a, const void *b)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|349| <<virtio_blk_handle_flush>> virtio_blk_submit_multireq(s, mrb);
+ *   - hw/block/virtio-blk.c|866| <<virtio_blk_handle_request>> virtio_blk_submit_multireq(s, mrb);
+ *   - hw/block/virtio-blk.c|1008| <<virtio_blk_handle_vq>> virtio_blk_submit_multireq(s, &mrb);
+ *   - hw/block/virtio-blk.c|1056| <<virtio_blk_dma_restart_bh>> virtio_blk_submit_multireq(s, &mrb);
+ */
 static void virtio_blk_submit_multireq(VirtIOBlock *s, MultiReqBuffer *mrb)
 {
     int i = 0, start = 0, num_reqs = 0, niov = 0, nb_sectors = 0;
@@ -302,6 +439,23 @@ static void virtio_blk_submit_multireq(VirtIOBlock *s, MultiReqBuffer *mrb)
           &multireq_compare);
 
     for (i = 0; i < mrb->num_reqs; i++) {
+        /*
+	 * typedef struct VirtIOBlockReq {
+	 *     VirtQueueElement elem;
+	 *     int64_t sector_num;
+	 *     VirtIOBlock *dev;
+	 *     VirtQueue *vq;
+	 *     IOVDiscardUndo inhdr_undo;
+	 *     IOVDiscardUndo outhdr_undo;
+	 *     struct virtio_blk_inhdr *in;
+	 *     struct virtio_blk_outhdr out;
+	 *     QEMUIOVector qiov;
+	 *     size_t in_len;
+	 *     struct VirtIOBlockReq *next;
+	 *     struct VirtIOBlockReq *mr_next;
+	 *     BlockAcctCookie acct;
+	 * } VirtIOBlockReq;
+	 */
         VirtIOBlockReq *req = mrb->reqs[i];
         if (num_reqs > 0) {
             /*
@@ -348,9 +502,28 @@ static void virtio_blk_handle_flush(VirtIOBlockReq *req, MultiReqBuffer *mrb)
     if (mrb->is_write && mrb->num_reqs > 0) {
         virtio_blk_submit_multireq(s, mrb);
     }
+    /*
+     * 在以下使用blk_aio_flush():
+     *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+     *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+     *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+     *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+     *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+     *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+     *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+     *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+     */
     blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|550| <<virtio_blk_handle_discard_write_zeroes>> if (unlikely(!virtio_blk_sect_range_ok(s, sector, bytes))) {
+ *   - hw/block/virtio-blk.c|1011| <<virtio_blk_handle_request>> if (!virtio_blk_sect_range_ok(s, req->sector_num, req->qiov.size)) {
+ */
 static bool virtio_blk_sect_range_ok(VirtIOBlock *dev,
                                      uint64_t sector, size_t size)
 {
@@ -788,9 +961,20 @@ out:
     return err_status;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|995| <<virtio_blk_handle_vq>> if (virtio_blk_handle_request(req, &mrb)) {
+ *   - hw/block/virtio-blk.c|1040| <<virtio_blk_dma_restart_bh>> if (virtio_blk_handle_request(req, &mrb)) {
+ */
 static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
 {
     uint32_t type;
+    /*
+     * VirtIOBlockReq *req:
+     * -> VirtQueueElement elem;
+     * -> struct virtio_blk_inhdr *in;
+     * -> struct virtio_blk_outhdr out;
+     */
     struct iovec *in_iov = req->elem.in_sg;
     struct iovec *out_iov = req->elem.out_sg;
     unsigned in_num = req->elem.in_num;
@@ -809,11 +993,30 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
         return -1;
     }
 
+    /*
+     * 在以下使用VirtIOBlockReq->outhdr_undo:
+     *   - hw/block/virtio-blk.c|112| <<virtio_blk_req_complete>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|964| <<virtio_blk_handle_request>> iov_discard_front_undoable(&out_iov,
+     *                           &out_num, sizeof(req->out), &req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|968| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|1100| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     *
+     * 似乎是从out_iov中把header的部分去掉?
+     * 更新了out_iov
+     */
     iov_discard_front_undoable(&out_iov, &out_num, sizeof(req->out),
                                &req->outhdr_undo);
 
     if (in_iov[in_num - 1].iov_len < sizeof(struct virtio_blk_inhdr)) {
         virtio_error(vdev, "virtio-blk request inhdr too short");
+        /*
+	 * 在以下使用VirtIOBlockReq->outhdr_undo:
+	 *   - hw/block/virtio-blk.c|112| <<virtio_blk_req_complete>> iov_discard_undo(&req->outhdr_undo);
+	 *   - hw/block/virtio-blk.c|964| <<virtio_blk_handle_request>> iov_discard_front_undoable(&out_iov,
+	 *                           &out_num, sizeof(req->out), &req->outhdr_undo);
+	 *   - hw/block/virtio-blk.c|968| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+	 *   - hw/block/virtio-blk.c|1100| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+	 */
         iov_discard_undo(&req->outhdr_undo);
         return -1;
     }
@@ -826,6 +1029,12 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
     iov_discard_back_undoable(in_iov, &in_num, sizeof(struct virtio_blk_inhdr),
                               &req->inhdr_undo);
 
+    /*
+     * VirtIOBlockReq *req:
+     * -> VirtQueueElement elem;
+     * -> struct virtio_blk_inhdr *in;
+     * -> struct virtio_blk_outhdr out;
+     */
     type = virtio_ldl_p(vdev, &req->out.type);
 
     /* VIRTIO_BLK_T_OUT defines the command direction. VIRTIO_BLK_T_BARRIER
@@ -837,6 +1046,10 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
         bool is_write = type & VIRTIO_BLK_T_OUT;
         req->sector_num = virtio_ldq_p(vdev, &req->out.sector);
 
+        /*
+	 * VirtIOBlockReq *req:
+	 * -> QEMUIOVector qiov;
+	 */
         if (is_write) {
             qemu_iovec_init_external(&req->qiov, out_iov, out_num);
             trace_virtio_blk_handle_write(vdev, req, req->sector_num,
@@ -858,14 +1071,33 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
         block_acct_start(blk_get_stats(s->blk), &req->acct, req->qiov.size,
                          is_write ? BLOCK_ACCT_WRITE : BLOCK_ACCT_READ);
 
+        /*
+	 * 在以下使用VirtIOBlkConf->request_merging:
+	 *   - hw/block/virtio-blk.c|2054| <<global>> DEFINE_PROP_BIT("request-merging", VirtIOBlock, conf.request_merging, 0,
+	 *   - hw/block/virtio-blk.c|1026| <<virtio_blk_handle_request>> if (...!s->conf.request_merging)) {
+	 */
         /* merge would exceed maximum number of requests or IO direction
          * changes */
         if (mrb->num_reqs > 0 && (mrb->num_reqs == VIRTIO_BLK_MAX_MERGE_REQS ||
                                   is_write != mrb->is_write ||
                                   !s->conf.request_merging)) {
+            /*
+	     * called by:
+	     *   - hw/block/virtio-blk.c|349| <<virtio_blk_handle_flush>> virtio_blk_submit_multireq(s, mrb);
+	     *   - hw/block/virtio-blk.c|866| <<virtio_blk_handle_request>> virtio_blk_submit_multireq(s, mrb);
+	     *   - hw/block/virtio-blk.c|1008| <<virtio_blk_handle_vq>> virtio_blk_submit_multireq(s, &mrb);
+	     *   - hw/block/virtio-blk.c|1056| <<virtio_blk_dma_restart_bh>> virtio_blk_submit_multireq(s, &mrb);
+	     */
             virtio_blk_submit_multireq(s, mrb);
         }
 
+        /*
+	 * typedef struct MultiReqBuffer {
+	 *     VirtIOBlockReq *reqs[VIRTIO_BLK_MAX_MERGE_REQS];
+	 *     unsigned int num_reqs;
+	 *     bool is_write;
+	 * } MultiReqBuffer;
+	 */
         assert(mrb->num_reqs < VIRTIO_BLK_MAX_MERGE_REQS);
         mrb->reqs[mrb->num_reqs++] = req;
         mrb->is_write = is_write;
@@ -946,6 +1178,14 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
         if (unlikely(iov_to_buf(out_iov, out_num, 0, &dwz_hdr,
                                 sizeof(dwz_hdr)) != sizeof(dwz_hdr))) {
             iov_discard_undo(&req->inhdr_undo);
+	    /*
+	     * 在以下使用VirtIOBlockReq->outhdr_undo:
+	     *   - hw/block/virtio-blk.c|112| <<virtio_blk_req_complete>> iov_discard_undo(&req->outhdr_undo);
+	     *   - hw/block/virtio-blk.c|964| <<virtio_blk_handle_request>> iov_discard_front_undoable(&out_iov,
+	     *                           &out_num, sizeof(req->out), &req->outhdr_undo);
+	     *   - hw/block/virtio-blk.c|968| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+	     *   - hw/block/virtio-blk.c|1100| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+	     */
             iov_discard_undo(&req->outhdr_undo);
             virtio_error(vdev, "virtio-blk discard/write_zeroes header"
                          " too short");
@@ -968,6 +1208,10 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
          * class lookup is not in the hot path.
          */
         VirtIOBlkClass *vbk = VIRTIO_BLK_GET_CLASS(s);
+        /*
+	 * 只有hw/vmapple/virtio-blk.c实现了:
+	 * vbk->handle_unknown_request = vmapple_virtio_blk_handle_unknown_request;
+	 */
         if (!vbk->handle_unknown_request ||
             !vbk->handle_unknown_request(req, mrb, type)) {
             virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);
@@ -978,6 +1222,10 @@ static int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)
     return 0;
 }
 
+/*
+ * 在以下使用virtio_blk_handle_vq():
+ *   - hw/block/virtio-blk.c|1068| <<virtio_blk_handle_output>> virtio_blk_handle_vq(s, vq);
+ */
 void virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
 {
     VirtIOBlockReq *req;
@@ -992,6 +1240,11 @@ void virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
         }
 
         while ((req = virtio_blk_get_request(s, vq))) {
+            /*
+	     * called by:
+	     *   - hw/block/virtio-blk.c|995| <<virtio_blk_handle_vq>> if (virtio_blk_handle_request(req, &mrb)) {
+	     *   - hw/block/virtio-blk.c|1040| <<virtio_blk_dma_restart_bh>> if (virtio_blk_handle_request(req, &mrb)) {
+	     */
             if (virtio_blk_handle_request(req, &mrb)) {
                 virtqueue_detach_element(req->vq, &req->elem, 0);
                 g_free(req);
@@ -1011,6 +1264,10 @@ void virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
     defer_call_end();
 }
 
+/*
+ * 在以下使用virtio_blk_handle_output():
+ *   - hw/block/virtio-blk.c|1826| <<virtio_blk_device_realize>> virtio_add_queue(vdev, conf->queue_size, virtio_blk_handle_output);
+ */
 static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
 {
     VirtIOBlock *s = (VirtIOBlock *)vdev;
@@ -1025,6 +1282,9 @@ static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
         }
     }
 
+    /*
+     * 只在此处调用
+     */
     virtio_blk_handle_vq(s, vq);
 }
 
@@ -1060,6 +1320,11 @@ static void virtio_blk_dma_restart_bh(void *opaque)
     blk_dec_in_flight(s->conf.conf.blk);
 }
 
+/*
+ * 在以下使用virtio_blk_dma_restart_cb():
+ *   - hw/block/virtio-blk.c|1805| <<virtio_blk_device_realize>>
+ *       s->change = qdev_add_vm_change_state_handler(dev, virtio_blk_dma_restart_cb, s);
+ */
 static void virtio_blk_dma_restart_cb(void *opaque, bool running,
                                       RunState state)
 {
@@ -1100,6 +1365,23 @@ static void virtio_blk_dma_restart_cb(void *opaque, bool running,
         /* Paired with dec in virtio_blk_dma_restart_bh() */
         blk_inc_in_flight(s->conf.conf.blk);
 
+        /*
+	 * 在以下使用VirtIOBlock->vq_aio_context (二维数组):
+	 *   - hw/block/virtio-blk.c|1368| <<virtio_blk_dma_restart_cb>> aio_bh_schedule_oneshot(s->vq_aio_context[i], virtio_blk_dma_restart_bh, vq_rq[i]);
+	 *   - hw/block/virtio-blk.c|1652| <<virtio_blk_ioeventfd_detach>> virtio_queue_aio_detach_host_notifier(vq, s->vq_aio_context[i]);
+	 *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>> virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+	 *   - hw/block/virtio-blk.c|1721| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = g_new(AioContext *, conf->num_queues);
+	 *   - hw/block/virtio-blk.c|1725| <<virtio_blk_vq_aio_context_init>> if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+	 *        s->vq_aio_context, conf->num_queues, errp)) {
+	 *   - hw/block/virtio-blk.c|1728| <<virtio_blk_vq_aio_context_init>> g_free(s->vq_aio_context);
+	 *   - hw/block/virtio-blk.c|1729| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = NULL;
+	 *   - hw/block/virtio-blk.c|1735| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+	 *   - hw/block/virtio-blk.c|1743| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+	 *   - hw/block/virtio-blk.c|1765| <<virtio_blk_vq_aio_context_cleanup>> g_free(s->vq_aio_context);
+	 *   - hw/block/virtio-blk.c|1766| <<virtio_blk_vq_aio_context_cleanup>> s->vq_aio_context = NULL;
+	 *   - hw/block/virtio-blk.c|1831| <<virtio_blk_start_ioeventfd>> r = blk_set_aio_context(s->conf.conf.blk, s->vq_aio_context[0], &local_err);
+	 *   - hw/block/virtio-blk.c|1910| <<virtio_blk_stop_ioeventfd>> AioContext *ctx = s->vq_aio_context[i];
+	 */
         aio_bh_schedule_oneshot(s->vq_aio_context[i],
                                 virtio_blk_dma_restart_bh,
                                 vq_rq[i]);
@@ -1388,12 +1670,28 @@ static void virtio_blk_ioeventfd_detach(VirtIOBlock *s)
     }
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|1682| <<virtio_blk_drained_end>> virtio_blk_ioeventfd_attach(s);
+ *   - hw/block/virtio-blk.c|1856| <<virtio_blk_start_ioeventfd>> virtio_blk_ioeventfd_attach(s);
+ */
 static void virtio_blk_ioeventfd_attach(VirtIOBlock *s)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(s);
 
     for (uint16_t i = 0; i < s->conf.num_queues; i++) {
         VirtQueue *vq = virtio_get_queue(vdev, i);
+        /*
+	 * 在以下使用virtio_queue_aio_attach_host_notifier():
+	 *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>>
+	 *        virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+	 *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>>
+	 *        virtio_queue_aio_attach_host_notifier(vs->ctrl_vq, s->vq_aio_context[0]);
+	 *   - hw/scsi/virtio-scsi-dataplane.c|210| <<virtio_scsi_dataplane_start>>
+	 *        virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
+	 *   - hw/scsi/virtio-scsi.c|1250| <<virtio_scsi_drained_end>>
+	 *        virtio_queue_aio_attach_host_notifier(vq, ctx);
+	 */
         virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
     }
 }
@@ -1453,9 +1751,36 @@ static bool virtio_blk_vq_aio_context_init(VirtIOBlock *s, Error **errp)
         }
     }
 
+    /*
+     * 在以下使用VirtIOBlock->vq_aio_context (二维数组):
+     *   - hw/block/virtio-blk.c|1368| <<virtio_blk_dma_restart_cb>> aio_bh_schedule_oneshot(s->vq_aio_context[i], virtio_blk_dma_restart_bh, vq_rq[i]);
+     *   - hw/block/virtio-blk.c|1652| <<virtio_blk_ioeventfd_detach>> virtio_queue_aio_detach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>> virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1721| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = g_new(AioContext *, conf->num_queues);
+     *   - hw/block/virtio-blk.c|1725| <<virtio_blk_vq_aio_context_init>> if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+     *        s->vq_aio_context, conf->num_queues, errp)) {
+     *   - hw/block/virtio-blk.c|1728| <<virtio_blk_vq_aio_context_init>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1729| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = NULL;
+     *   - hw/block/virtio-blk.c|1735| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+     *   - hw/block/virtio-blk.c|1743| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+     *   - hw/block/virtio-blk.c|1765| <<virtio_blk_vq_aio_context_cleanup>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1766| <<virtio_blk_vq_aio_context_cleanup>> s->vq_aio_context = NULL;
+     *   - hw/block/virtio-blk.c|1831| <<virtio_blk_start_ioeventfd>> r = blk_set_aio_context(s->conf.conf.blk, s->vq_aio_context[0], &local_err);
+     *   - hw/block/virtio-blk.c|1910| <<virtio_blk_stop_ioeventfd>> AioContext *ctx = s->vq_aio_context[i];
+     */
     s->vq_aio_context = g_new(AioContext *, conf->num_queues);
 
     if (conf->iothread_vq_mapping_list) {
+        /*
+	 * 在以下调用iothread_vq_mapping_apply():
+	 *   - hw/block/virtio-blk.c|1740| <<virtio_blk_vq_aio_context_init>>
+	 *       if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+	 *                 s->vq_aio_context, conf->num_queues, errp)) {
+	 *   - hw/scsi/virtio-scsi-dataplane.c|68| <<virtio_scsi_dataplane_setup>>
+	 *       if (!iothread_vq_mapping_apply(vs->conf.iothread_vq_mapping_list,
+	 *                 &s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED],
+	 *                 vs->conf.num_queues, errp)) {
+	 */
         if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
                                        s->vq_aio_context,
                                        conf->num_queues,
@@ -1497,10 +1822,37 @@ static void virtio_blk_vq_aio_context_cleanup(VirtIOBlock *s)
         object_unref(OBJECT(conf->iothread));
     }
 
+    /*
+     * 在以下使用VirtIOBlock->vq_aio_context (二维数组):
+     *   - hw/block/virtio-blk.c|1368| <<virtio_blk_dma_restart_cb>> aio_bh_schedule_oneshot(s->vq_aio_context[i], virtio_blk_dma_restart_bh, vq_rq[i]);
+     *   - hw/block/virtio-blk.c|1652| <<virtio_blk_ioeventfd_detach>> virtio_queue_aio_detach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>> virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1721| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = g_new(AioContext *, conf->num_queues);
+     *   - hw/block/virtio-blk.c|1725| <<virtio_blk_vq_aio_context_init>> if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+     *        s->vq_aio_context, conf->num_queues, errp)) {
+     *   - hw/block/virtio-blk.c|1728| <<virtio_blk_vq_aio_context_init>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1729| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = NULL;
+     *   - hw/block/virtio-blk.c|1735| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+     *   - hw/block/virtio-blk.c|1743| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+     *   - hw/block/virtio-blk.c|1765| <<virtio_blk_vq_aio_context_cleanup>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1766| <<virtio_blk_vq_aio_context_cleanup>> s->vq_aio_context = NULL;
+     *   - hw/block/virtio-blk.c|1831| <<virtio_blk_start_ioeventfd>> r = blk_set_aio_context(s->conf.conf.blk, s->vq_aio_context[0], &local_err);
+     *   - hw/block/virtio-blk.c|1910| <<virtio_blk_stop_ioeventfd>> AioContext *ctx = s->vq_aio_context[i];
+     */
     g_free(s->vq_aio_context);
     s->vq_aio_context = NULL;
 }
 
+/*
+ * 在以下使用VirtioDeviceClass->start_ioeventfd:
+ *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+ *   - hw/scsi/virtio-scsi.c|1421| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+ *   - hw/virtio/virtio.c|4153| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+ *
+ * 在以下使用virtio_blk_start_ioeventfd():
+ *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+ */
 /* Context: BQL held */
 static int virtio_blk_start_ioeventfd(VirtIODevice *vdev)
 {
@@ -1767,6 +2119,13 @@ static void virtio_blk_device_realize(DeviceState *dev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下使用virtio_blk_cfg_size_params:
+     *   - hw/block/vhost-user-blk.c|478| <<vhost_user_blk_device_realize>>
+     *        config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+     *   - hw/block/virtio-blk.c|1815| <<virtio_blk_device_realize>>
+     *        s->config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
+     */
     s->config_size = virtio_get_config_size(&virtio_blk_cfg_size_params,
                                             s->host_features);
     virtio_init(vdev, VIRTIO_ID_BLOCK, s->config_size);
diff --git a/hw/ide/core.c b/hw/ide/core.c
index b14983ec5..641c4bedd 100644
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -1132,6 +1132,20 @@ static void ide_flush_cache(IDEState *s)
     s->status |= BUSY_STAT;
     ide_set_retry(s);
     block_acct_start(blk_get_stats(s->blk), &s->acct, 0, BLOCK_ACCT_FLUSH);
+    /*
+     * 在以下使用blk_aio_flush():
+     *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+     *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+     *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+     *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+     *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+     *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+     *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+     *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+     *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+     */
     s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
 }
 
diff --git a/hw/nvme/ctrl.c b/hw/nvme/ctrl.c
index d6b77d4fb..b0eb2d462 100644
--- a/hw/nvme/ctrl.c
+++ b/hw/nvme/ctrl.c
@@ -3521,6 +3521,20 @@ static void nvme_flush_ns_cb(void *opaque, int ret)
         trace_pci_nvme_flush_ns(iocb->nsid);
 
         iocb->ns = NULL;
+        /*
+	 * 在以下使用blk_aio_flush():
+	 *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+	 *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+	 *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+	 *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+	 *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+	 *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+	 *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 */
         iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
         return;
     }
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index e59632e9b..816cc7289 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -399,6 +399,20 @@ static void scsi_write_do_fua(SCSIDiskReq *r)
     if (r->need_fua_emulation) {
         block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
                          BLOCK_ACCT_FLUSH);
+        /*
+	 * 在以下使用blk_aio_flush():
+	 *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+	 *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+	 *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+	 *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+	 *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+	 *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+	 *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 */
         r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
         return;
     }
@@ -567,6 +581,20 @@ static void scsi_read_data(SCSIRequest *req)
     if (first && r->need_fua_emulation) {
         block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
                          BLOCK_ACCT_FLUSH);
+        /*
+	 * 在以下使用blk_aio_flush():
+	 *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+	 *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+	 *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+	 *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+	 *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+	 *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+	 *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 */
         r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
     } else {
         scsi_do_read(r, 0);
@@ -1722,6 +1750,20 @@ static void scsi_disk_emulate_mode_select(SCSIDiskReq *r, uint8_t *inbuf)
         scsi_req_ref(&r->req);
         block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
                          BLOCK_ACCT_FLUSH);
+        /*
+	 * 在以下使用blk_aio_flush():
+	 *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+	 *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+	 *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+	 *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+	 *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+	 *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+	 *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 */
         r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
         return;
     }
@@ -2249,6 +2291,20 @@ static int32_t scsi_disk_emulate_command(SCSIRequest *req, uint8_t *buf)
         scsi_req_ref(&r->req);
         block_acct_start(blk_get_stats(s->qdev.conf.blk), &r->acct, 0,
                          BLOCK_ACCT_FLUSH);
+        /*
+	 * 在以下使用blk_aio_flush():
+	 *   - hw/block/dataplane/xen-block.c|367| <<xen_block_do_aio>> blk_aio_flush(request->dataplane->blk, xen_block_complete_aio,
+	 *   - hw/block/virtio-blk.c|497| <<virtio_blk_handle_flush>> blk_aio_flush(s->blk, virtio_blk_flush_complete, req);
+	 *   - hw/ide/core.c|1135| <<ide_flush_cache>> s->pio_aiocb = blk_aio_flush(s->blk, ide_flush_cb, s);
+	 *   - hw/nvme/ctrl.c|3524| <<nvme_flush_ns_cb>> iocb->aiocb = blk_aio_flush(ns->blkconf.blk, nvme_flush_ns_cb, iocb);
+	 *   - hw/scsi/scsi-disk.c|402| <<scsi_write_do_fua>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|570| <<scsi_read_data>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_do_read_cb, r);
+	 *   - hw/scsi/scsi-disk.c|1725| <<scsi_disk_emulate_mode_select>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - hw/scsi/scsi-disk.c|2252| <<scsi_disk_emulate_command>> r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
+	 *   - qemu-img.c|4471| <<bench_cb>> acb = blk_aio_flush(b->blk, cb, b);
+	 *   - tests/unit/test-block-backend.c|46| <<test_drain_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 *   - tests/unit/test-block-backend.c|63| <<test_drain_all_aio_error>> acb = blk_aio_flush(blk, test_drain_aio_error_flush_cb, &completed);
+	 */
         r->req.aiocb = blk_aio_flush(s->qdev.conf.blk, scsi_aio_complete, r);
         return 0;
     case SEEK_10:
diff --git a/hw/scsi/virtio-scsi-dataplane.c b/hw/scsi/virtio-scsi-dataplane.c
index 95f13fb7c..05193db8c 100644
--- a/hw/scsi/virtio-scsi-dataplane.c
+++ b/hw/scsi/virtio-scsi-dataplane.c
@@ -65,6 +65,16 @@ void virtio_scsi_dataplane_setup(VirtIOSCSI *s, Error **errp)
     s->vq_aio_context[1] = qemu_get_aio_context();
 
     if (vs->conf.iothread_vq_mapping_list) {
+        /*
+	 * 在以下调用iothread_vq_mapping_apply():
+	 *   - hw/block/virtio-blk.c|1740| <<virtio_blk_vq_aio_context_init>>
+	 *       if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+	 *                 s->vq_aio_context, conf->num_queues, errp)) {
+	 *   - hw/scsi/virtio-scsi-dataplane.c|68| <<virtio_scsi_dataplane_setup>>
+	 *       if (!iothread_vq_mapping_apply(vs->conf.iothread_vq_mapping_list,
+	 *                 &s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED],
+	 *                 vs->conf.num_queues, errp)) {
+	 */
         if (!iothread_vq_mapping_apply(vs->conf.iothread_vq_mapping_list,
                     &s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED],
                     vs->conf.num_queues, errp)) {
@@ -139,6 +149,13 @@ static void virtio_scsi_dataplane_stop_vq_bh(void *opaque)
     virtio_queue_host_notifier_read(host_notifier);
 }
 
+/*
+ * 在以下使用VirtioDeviceClass->start_ioeventfd:
+ *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+ *   - hw/scsi/virtio-scsi.c|1421| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+ *   - hw/virtio/virtio.c|4153| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+ */
 /* Context: BQL held */
 int virtio_scsi_dataplane_start(VirtIODevice *vdev)
 {
@@ -200,6 +217,17 @@ int virtio_scsi_dataplane_start(VirtIODevice *vdev)
     smp_wmb(); /* paired with aio_notify_accept() */
 
     if (s->bus.drain_count == 0) {
+        /*
+	 * 在以下使用virtio_queue_aio_attach_host_notifier():
+	 *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>>
+	 *        virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+	 *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>>
+	 *        virtio_queue_aio_attach_host_notifier(vs->ctrl_vq, s->vq_aio_context[0]);
+	 *   - hw/scsi/virtio-scsi-dataplane.c|210| <<virtio_scsi_dataplane_start>>
+	 *        virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
+	 *   - hw/scsi/virtio-scsi.c|1250| <<virtio_scsi_drained_end>>
+	 *        virtio_queue_aio_attach_host_notifier(vq, ctx);
+	 */
         virtio_queue_aio_attach_host_notifier(vs->ctrl_vq,
                                               s->vq_aio_context[0]);
         virtio_queue_aio_attach_host_notifier_no_poll(vs->event_vq,
@@ -207,6 +235,17 @@ int virtio_scsi_dataplane_start(VirtIODevice *vdev)
 
         for (i = 0; i < vs->conf.num_queues; i++) {
             AioContext *ctx = s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED + i];
+            /*
+	     * 在以下使用virtio_queue_aio_attach_host_notifier():
+	     *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>>
+	     *        virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+	     *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>>
+	     *        virtio_queue_aio_attach_host_notifier(vs->ctrl_vq, s->vq_aio_context[0]);
+	     *   - hw/scsi/virtio-scsi-dataplane.c|210| <<virtio_scsi_dataplane_start>>
+	     *        virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
+	     *   - hw/scsi/virtio-scsi.c|1250| <<virtio_scsi_drained_end>>
+	     *        virtio_queue_aio_attach_host_notifier(vq, ctx);
+	     */
             virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
         }
     }
diff --git a/hw/scsi/virtio-scsi.c b/hw/scsi/virtio-scsi.c
index f5a3aa236..e52ebe999 100644
--- a/hw/scsi/virtio-scsi.c
+++ b/hw/scsi/virtio-scsi.c
@@ -1247,6 +1247,17 @@ static void virtio_scsi_drained_end(SCSIBus *bus)
         if (vq == vs->event_vq) {
             virtio_queue_aio_attach_host_notifier_no_poll(vq, ctx);
         } else {
+            /*
+	     * 在以下使用virtio_queue_aio_attach_host_notifier():
+	     *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>>
+	     *        virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+	     *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>>
+	     *        virtio_queue_aio_attach_host_notifier(vs->ctrl_vq, s->vq_aio_context[0]);
+	     *   - hw/scsi/virtio-scsi-dataplane.c|210| <<virtio_scsi_dataplane_start>>
+	     *        virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
+	     *   - hw/scsi/virtio-scsi.c|1250| <<virtio_scsi_drained_end>>
+	     *        virtio_queue_aio_attach_host_notifier(vq, ctx);
+	     */
             virtio_queue_aio_attach_host_notifier(vq, ctx);
         }
     }
diff --git a/hw/virtio/iothread-vq-mapping.c b/hw/virtio/iothread-vq-mapping.c
index 15909eb93..b1f415e27 100644
--- a/hw/virtio/iothread-vq-mapping.c
+++ b/hw/virtio/iothread-vq-mapping.c
@@ -72,6 +72,16 @@ iothread_vq_mapping_validate(IOThreadVirtQueueMappingList *list, uint16_t
     return true;
 }
 
+/*
+ * 在以下调用iothread_vq_mapping_apply():
+ *   - hw/block/virtio-blk.c|1740| <<virtio_blk_vq_aio_context_init>>
+ *       if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+ *                 s->vq_aio_context, conf->num_queues, errp)) {
+ *   - hw/scsi/virtio-scsi-dataplane.c|68| <<virtio_scsi_dataplane_setup>>
+ *       if (!iothread_vq_mapping_apply(vs->conf.iothread_vq_mapping_list,
+ *                 &s->vq_aio_context[VIRTIO_SCSI_VQ_NUM_FIXED],
+ *                 vs->conf.num_queues, errp)) {
+ */
 bool iothread_vq_mapping_apply(
         IOThreadVirtQueueMappingList *list,
         AioContext **vq_aio_context,
diff --git a/hw/virtio/virtio-bus.c b/hw/virtio/virtio-bus.c
index 896feb37a..1ca139a21 100644
--- a/hw/virtio/virtio-bus.c
+++ b/hw/virtio/virtio-bus.c
@@ -233,6 +233,13 @@ int virtio_bus_start_ioeventfd(VirtioBusState *bus)
 
     /* Only set our notifier if we have ownership.  */
     if (!bus->ioeventfd_grabbed) {
+        /*
+	 * 在以下使用VirtioDeviceClass->start_ioeventfd:
+	 *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+         *   - hw/scsi/virtio-scsi.c|1421| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+         *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+         *   - hw/virtio/virtio.c|4153| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+	 */
         r = vdc->start_ioeventfd(vdev);
         if (r < 0) {
             error_report("%s: failed. Fallback to userspace (slower).", __func__);
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index 85110bce3..3700556db 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -2471,6 +2471,11 @@ void virtio_queue_set_shadow_avail_idx(VirtQueue *vq, uint16_t shadow_avail_idx)
     }
 }
 
+/*
+ * 在以下使用virtio_queue_notify_vq():
+ *   - hw/virtio/virtio.c|3783| <<virtio_queue_host_notifier_aio_poll_ready>> virtio_queue_notify_vq(vq);
+ *   - hw/virtio/virtio.c|3869| <<virtio_queue_host_notifier_read>> virtio_queue_notify_vq(vq);
+ */
 static void virtio_queue_notify_vq(VirtQueue *vq)
 {
     if (vq->vring.desc && vq->handle_output) {
@@ -3780,6 +3785,11 @@ static void virtio_queue_host_notifier_aio_poll_ready(EventNotifier *n)
 {
     VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
 
+    /*
+     * 在以下使用virtio_queue_notify_vq():
+     *   - hw/virtio/virtio.c|3783| <<virtio_queue_host_notifier_aio_poll_ready>> virtio_queue_notify_vq(vq);
+     *   - hw/virtio/virtio.c|3869| <<virtio_queue_host_notifier_read>> virtio_queue_notify_vq(vq);
+     */
     virtio_queue_notify_vq(vq);
 }
 
@@ -3791,6 +3801,17 @@ static void virtio_queue_host_notifier_aio_poll_end(EventNotifier *n)
     virtio_queue_set_notification(vq, 1);
 }
 
+/*
+ * 在以下使用virtio_queue_aio_attach_host_notifier():
+ *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>>
+ *        virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+ *   - hw/scsi/virtio-scsi-dataplane.c|203| <<virtio_scsi_dataplane_start>>
+ *        virtio_queue_aio_attach_host_notifier(vs->ctrl_vq, s->vq_aio_context[0]);
+ *   - hw/scsi/virtio-scsi-dataplane.c|210| <<virtio_scsi_dataplane_start>>
+ *        virtio_queue_aio_attach_host_notifier(vs->cmd_vqs[i], ctx);
+ *   - hw/scsi/virtio-scsi.c|1250| <<virtio_scsi_drained_end>>
+ *        virtio_queue_aio_attach_host_notifier(vq, ctx);
+ */
 void virtio_queue_aio_attach_host_notifier(VirtQueue *vq, AioContext *ctx)
 {
     /*
@@ -3866,6 +3887,11 @@ void virtio_queue_host_notifier_read(EventNotifier *n)
 {
     VirtQueue *vq = container_of(n, VirtQueue, host_notifier);
     if (event_notifier_test_and_clear(n)) {
+        /*
+	 * 在以下使用virtio_queue_notify_vq():
+	 *   - hw/virtio/virtio.c|3783| <<virtio_queue_host_notifier_aio_poll_ready>> virtio_queue_notify_vq(vq);
+	 *   - hw/virtio/virtio.c|3869| <<virtio_queue_host_notifier_read>> virtio_queue_notify_vq(vq);
+	 */
         virtio_queue_notify_vq(vq);
     }
 }
@@ -4020,6 +4046,13 @@ static const Property virtio_properties[] = {
                      disable_legacy_check, false),
 };
 
+/*
+ * 在以下使用VirtioDeviceClass->start_ioeventfd:
+ *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+ *   - hw/scsi/virtio-scsi.c|1421| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+ *   - hw/virtio/virtio.c|4153| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+ */
 static int virtio_device_start_ioeventfd_impl(VirtIODevice *vdev)
 {
     VirtioBusState *qbus = VIRTIO_BUS(qdev_get_parent_bus(DEVICE(vdev)));
diff --git a/include/hw/virtio/virtio-blk.h b/include/hw/virtio/virtio-blk.h
index 3d8dee7ec..5142b8757 100644
--- a/include/hw/virtio/virtio-blk.h
+++ b/include/hw/virtio/virtio-blk.h
@@ -38,8 +38,23 @@ struct VirtIOBlkConf
 {
     BlockConf conf;
     IOThread *iothread;
+    /*
+     * 在以下使用VirtIOBlkConf->iothread_vq_mapping_list:
+     *   - hw/block/virtio-blk.c|1919| <<global>> conf.iothread_vq_mapping_list),
+     *   - hw/block/virtio-blk.c|1481| <<virtio_blk_vq_aio_context_init>> if (conf->iothread && conf->iothread_vq_mapping_list) {
+     *   - hw/block/virtio-blk.c|1488| <<virtio_blk_vq_aio_context_init>> if (conf->iothread || conf->iothread_vq_mapping_list) {
+     *   - hw/block/virtio-blk.c|1503| <<virtio_blk_vq_aio_context_init>> if (conf->iothread_vq_mapping_list) {
+     *   - hw/block/virtio-blk.c|1504| <<virtio_blk_vq_aio_context_init>> if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+     *   - hw/block/virtio-blk.c|1537| <<virtio_blk_vq_aio_context_cleanup>> if (conf->iothread_vq_mapping_list) {
+     *   - hw/block/virtio-blk.c|1538| <<virtio_blk_vq_aio_context_cleanup>> iothread_vq_mapping_cleanup(conf->iothread_vq_mapping_list);
+     */
     IOThreadVirtQueueMappingList *iothread_vq_mapping_list;
     char *serial;
+    /*
+     * 在以下使用VirtIOBlkConf->request_merging:
+     *   - hw/block/virtio-blk.c|2054| <<global>> DEFINE_PROP_BIT("request-merging", VirtIOBlock, conf.request_merging, 0,
+     *   - hw/block/virtio-blk.c|1026| <<virtio_blk_handle_request>> if (...!s->conf.request_merging)) {
+     */
     uint32_t request_merging;
     uint16_t num_queues;
     uint16_t queue_size;
@@ -65,6 +80,23 @@ struct VirtIOBlock {
     bool ioeventfd_starting;
     bool ioeventfd_stopping;
 
+    /*
+     * 在以下使用VirtIOBlock->vq_aio_context (二维数组):
+     *   - hw/block/virtio-blk.c|1368| <<virtio_blk_dma_restart_cb>> aio_bh_schedule_oneshot(s->vq_aio_context[i], virtio_blk_dma_restart_bh, vq_rq[i]);
+     *   - hw/block/virtio-blk.c|1652| <<virtio_blk_ioeventfd_detach>> virtio_queue_aio_detach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1662| <<virtio_blk_ioeventfd_attach>> virtio_queue_aio_attach_host_notifier(vq, s->vq_aio_context[i]);
+     *   - hw/block/virtio-blk.c|1721| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = g_new(AioContext *, conf->num_queues);
+     *   - hw/block/virtio-blk.c|1725| <<virtio_blk_vq_aio_context_init>> if (!iothread_vq_mapping_apply(conf->iothread_vq_mapping_list,
+     *        s->vq_aio_context, conf->num_queues, errp)) {
+     *   - hw/block/virtio-blk.c|1728| <<virtio_blk_vq_aio_context_init>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1729| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context = NULL; 
+     *   - hw/block/virtio-blk.c|1735| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx; 
+     *   - hw/block/virtio-blk.c|1743| <<virtio_blk_vq_aio_context_init>> s->vq_aio_context[i] = ctx;
+     *   - hw/block/virtio-blk.c|1765| <<virtio_blk_vq_aio_context_cleanup>> g_free(s->vq_aio_context);
+     *   - hw/block/virtio-blk.c|1766| <<virtio_blk_vq_aio_context_cleanup>> s->vq_aio_context = NULL;
+     *   - hw/block/virtio-blk.c|1831| <<virtio_blk_start_ioeventfd>> r = blk_set_aio_context(s->conf.conf.blk, s->vq_aio_context[0], &local_err);
+     *   - hw/block/virtio-blk.c|1910| <<virtio_blk_stop_ioeventfd>> AioContext *ctx = s->vq_aio_context[i];
+     */
     /*
      * The AioContext for each virtqueue. The BlockDriverState will use the
      * first element as its AioContext.
@@ -81,13 +113,35 @@ typedef struct VirtIOBlockReq {
     int64_t sector_num;
     VirtIOBlock *dev;
     VirtQueue *vq;
+    /*
+     * 在以下使用VirtIOBlockReq->inhdr_undo:
+     *   - hw/block/virtio-blk.c|62| <<virtio_blk_req_complete>> iov_discard_undo(&req->inhdr_undo);
+     *   - hw/block/virtio-blk.c|867| <<virtio_blk_handle_request>> iov_discard_back_undoable(in_iov,
+     *                          &in_num, sizeof(struct virtio_blk_inhdr), &req->inhdr_undo);
+     *   - hw/block/virtio-blk.c|988| <<virtio_blk_handle_request>> iov_discard_undo(&req->inhdr_undo);
+     */
     IOVDiscardUndo inhdr_undo;
+    /*
+     * 在以下使用VirtIOBlockReq->outhdr_undo:
+     *   - hw/block/virtio-blk.c|112| <<virtio_blk_req_complete>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|964| <<virtio_blk_handle_request>> iov_discard_front_undoable(&out_iov,
+     *                           &out_num, sizeof(req->out), &req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|968| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     *   - hw/block/virtio-blk.c|1100| <<virtio_blk_handle_request>> iov_discard_undo(&req->outhdr_undo);
+     */
     IOVDiscardUndo outhdr_undo;
     struct virtio_blk_inhdr *in;
     struct virtio_blk_outhdr out;
     QEMUIOVector qiov;
     size_t in_len;
     struct VirtIOBlockReq *next;
+    /*
+     * 在以下使用VirtIOBlockReq->mr_next:
+     *   - hw/block/virtio-blk.c|51| <<virtio_blk_init_request>> req->mr_next = NULL;
+     *   - hw/block/virtio-blk.c|81| <<virtio_blk_handle_rw_error>> req->mr_next = NULL;
+     *   - hw/block/virtio-blk.c|112| <<virtio_blk_rw_complete>> next = req->mr_next;
+     *   - hw/block/virtio-blk.c|253| <<submit_requests>> mrb->reqs[i - 1]->mr_next = mrb->reqs[i];
+     */
     struct VirtIOBlockReq *mr_next;
     BlockAcctCookie acct;
 } VirtIOBlockReq;
diff --git a/include/hw/virtio/virtio-scsi.h b/include/hw/virtio/virtio-scsi.h
index 31e852ed6..da9798ef3 100644
--- a/include/hw/virtio/virtio-scsi.h
+++ b/include/hw/virtio/virtio-scsi.h
@@ -61,6 +61,16 @@ struct VirtIOSCSIConf {
     CharBackend chardev;
     uint32_t boot_tpgt;
     IOThread *iothread;
+    /*
+     * 在以下使用VirtIOSCSIConf->iothread_vq_mapping_list:
+     *   - hw/scsi/virtio-scsi.c|1385| <<global>> parent_obj.conf.iothread_vq_mapping_list),
+     *   - hw/scsi/virtio-scsi-dataplane.c|32| <<virtio_scsi_dataplane_setup>> if (vs->conf.iothread && vs->conf.iothread_vq_mapping_list) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|39| <<virtio_scsi_dataplane_setup>> if (vs->conf.iothread || vs->conf.iothread_vq_mapping_list) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|67| <<virtio_scsi_dataplane_setup>> if (vs->conf.iothread_vq_mapping_list) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|68| <<virtio_scsi_dataplane_setup>> if (!iothread_vq_mapping_apply(vs->conf.iothread_vq_mapping_list,
+     *   - hw/scsi/virtio-scsi-dataplane.c|96| <<virtio_scsi_dataplane_cleanup>> if (vs->conf.iothread_vq_mapping_list) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|97| <<virtio_scsi_dataplane_cleanup>> iothread_vq_mapping_cleanup(vs->conf.iothread_vq_mapping_list);
+     */
     IOThreadVirtQueueMappingList *iothread_vq_mapping_list;
 };
 
diff --git a/include/hw/virtio/virtio.h b/include/hw/virtio/virtio.h
index 638691028..dcd696cdd 100644
--- a/include/hw/virtio/virtio.h
+++ b/include/hw/virtio/virtio.h
@@ -208,6 +208,13 @@ struct VirtioDeviceClass {
      * must mask in frontend instead.
      */
     void (*guest_notifier_mask)(VirtIODevice *vdev, int n, bool mask);
+    /*
+     * 在以下使用VirtioDeviceClass->start_ioeventfd:
+     *   - hw/block/virtio-blk.c|2178| <<virtio_blk_class_init>> vdc->start_ioeventfd = virtio_blk_start_ioeventfd;
+     *   - hw/scsi/virtio-scsi.c|1421| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+     *   - hw/virtio/virtio-bus.c|236| <<virtio_bus_start_ioeventfd>> r = vdc->start_ioeventfd(vdev);
+     *   - hw/virtio/virtio.c|4153| <<virtio_device_class_init>> vdc->start_ioeventfd = virtio_device_start_ioeventfd_impl;
+     */
     int (*start_ioeventfd)(VirtIODevice *vdev);
     void (*stop_ioeventfd)(VirtIODevice *vdev);
     /* Called before loading queues. Useful to add queues before loading. */
diff --git a/util/osdep.c b/util/osdep.c
index 770369831..8676bce08 100644
--- a/util/osdep.c
+++ b/util/osdep.c
@@ -605,6 +605,13 @@ writev(int fd, const struct iovec *iov, int iov_cnt)
  * Unfortunately even in 2009 many operating systems do not support
  * fdatasync and have to fall back to fsync.
  */
+/*
+ * 在以下使用qemu_fdatasync():
+ *   - block/file-posix.c|1636| <<handle_aiocb_flush>> ret = qemu_fdatasync(aiocb->aio_fildes);
+ *   - hw/9pfs/9p-local.c|1179| <<local_fsync>> return qemu_fdatasync(fd);
+ *   - hw/ppc/spapr_nvdimm.c|471| <<flush_worker_cb>> if (qemu_fdatasync(backend_fd) < 0)
+ *   - util/oslib-win32.c|845| <<qemu_msync>> return qemu_fdatasync(fd);
+ */
 int qemu_fdatasync(int fd)
 {
 #ifdef CONFIG_FDATASYNC
diff --git a/util/qemu-coroutine.c b/util/qemu-coroutine.c
index 64d6264fc..48c1c8dbe 100644
--- a/util/qemu-coroutine.c
+++ b/util/qemu-coroutine.c
@@ -173,6 +173,10 @@ static void coroutine_pool_put_global(CoroutinePoolBatch *batch)
     coroutine_pool_batch_delete(batch);
 }
 
+/*
+ * called by:
+ *   - util/qemu-coroutine.c|262| <<qemu_coroutine_create>> co = coroutine_pool_get();
+ */
 /* Get the next unused coroutine from the pool or return NULL */
 static Coroutine *coroutine_pool_get(void)
 {
@@ -214,15 +218,61 @@ static void coroutine_pool_put(Coroutine *co)
     batch->size++;
 }
 
+/*
+ * 非test的对qemu_coroutine_create()的调用:
+ *   - block/aio_task.c|94| <<aio_task_pool_start_task>> qemu_coroutine_enter(qemu_coroutine_create(aio_task_co, task));
+ *   - block/blkverify.c|214| <<blkverify_co_prwv>> co_a = qemu_coroutine_create(blkverify_do_test_req, r);
+ *   - block/blkverify.c|215| <<blkverify_co_prwv>> co_b = qemu_coroutine_create(blkverify_do_raw_req, r);
+ *   - block/block-backend.c|1600| <<blk_aio_prwv>> co = qemu_coroutine_create(co_entry, acb);
+ *   - block/block-backend.c|1906| <<blk_aio_zone_report>> co = qemu_coroutine_create(blk_aio_zone_report_entry, acb);
+ *   - block/block-backend.c|1947| <<blk_aio_zone_mgmt>> co = qemu_coroutine_create(blk_aio_zone_mgmt_entry, acb);
+ *   - block/block-backend.c|1987| <<blk_aio_zone_append>> co = qemu_coroutine_create(blk_aio_zone_append_entry, acb);
+ *   - block/block-copy.c|989| <<block_copy_async>> .co = qemu_coroutine_create(block_copy_async_co_entry, call_state),
+ *   - block/export/vduse-blk.c|109| <<vduse_blk_vq_handler>> qemu_coroutine_create(vduse_blk_virtio_process_req, req);
+ *   - block/export/vhost-user-blk-server.c|99| <<vu_blk_process_vq>> qemu_coroutine_create(vu_blk_virtio_process_req, req);
+ *   - block/mirror.c|455| <<mirror_perform>> co = qemu_coroutine_create(mirror_co_read, op);
+ *   - block/mirror.c|458| <<mirror_perform>> co = qemu_coroutine_create(mirror_co_zero, op);
+ *   - block/mirror.c|461| <<mirror_perform>> co = qemu_coroutine_create(mirror_co_discard, op);
+ *   - block/qcow2.c|1969| <<qcow2_open>> qemu_coroutine_create(qcow2_open_entry, &qoc));
+ *   - block/qed.c|326| <<qed_need_check_timer_cb>> Coroutine *co = qemu_coroutine_create(qed_need_check_timer_entry, opaque);
+ *   - block/qed.c|383| <<bdrv_qed_drain_begin>> co = qemu_coroutine_create(qed_need_check_timer_entry, s);
+ *   - block/qed.c|594| <<bdrv_qed_open>> qemu_coroutine_enter(qemu_coroutine_create(bdrv_qed_open_entry, &qoc));
+ *   - block/quorum.c|331| <<quorum_rewrite_bad_versions>> co = qemu_coroutine_create(quorum_rewrite_entry, &data);
+ *   - block/quorum.c|629| <<read_quorum_children>> co = qemu_coroutine_create(read_quorum_children_entry, &data);
+ *   - block/quorum.c|743| <<quorum_co_pwritev>> co = qemu_coroutine_create(write_quorum_entry, &data);
+ *   - block/throttle-groups.c|445| <<throttle_group_restart_queue>> co = qemu_coroutine_create(throttle_group_restart_queue_entry, rd);
+ *   - hw/9pfs/9p.c|4220| <<pdu_submit>> co = qemu_coroutine_create(handler, pdu);
+ *   - hw/9pfs/9p.c|4377| <<v9fs_reset>> co = qemu_coroutine_create(virtfs_co_reset, &data);
+ *   - hw/remote/remote-obj.c|124| <<remote_object_machine_done>> co = qemu_coroutine_create(mpqemu_remote_msg_loop_co, comdev);
+ *   - job.c|1128| <<job_start>> job->co = qemu_coroutine_create(job_co_entry, job);
+ *   - migration/migration.c|942| <<migration_incoming_process>> Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, NULL);
+ *   - monitor/hmp.c|1167| <<handle_hmp_command>> Coroutine *co = qemu_coroutine_create(handle_hmp_command_co, &data);
+ *   - monitor/monitor.c|724| <<monitor_init_globals>> qmp_dispatcher_co = qemu_coroutine_create(monitor_qmp_dispatcher_co, NULL);
+ *   - nbd/server.c|3209| <<nbd_client_receive_next_request>> client->recv_coroutine = qemu_coroutine_create(nbd_trip, req);
+ *   - nbd/server.c|3294| <<nbd_client_receive_next_request>> co = qemu_coroutine_create(nbd_co_client_start, client);
+ *   - net/colo-compare.c|822| <<compare_chr_send>> sendco->co = qemu_coroutine_create(_compare_chr_send, sendco);
+ *   - net/filter-mirror.c|127| <<filter_send>> Coroutine *co = qemu_coroutine_create(filter_send_co, &data);
+ *   - qemu-img.c|2138| <<convert_do_copy>> s->co[i] = qemu_coroutine_create(convert_co_do_copy, s);
+ *   - scsi/qemu-pr-helper.c|816| <<accept_client>> prh->co = qemu_coroutine_create(prh_co_entry, prh);
+ *   - tools/i386/qemu-vmsr-helper.c|295| <<accept_client>> vmsrh->co = qemu_coroutine_create(vh_co_entry, vmsrh);
+ *   - util/qemu-co-timeout.c|75| <<qemu_co_timeout>> co = qemu_coroutine_create(qemu_co_timeout_entry, s);
+ *   - util/vhost-user-server.c|446| <<vhost_user_server_attach_aio_context>> server->co_trip = qemu_coroutine_create(vu_client_trip, server);
+ */
 Coroutine *qemu_coroutine_create(CoroutineEntry *entry, void *opaque)
 {
     Coroutine *co = NULL;
 
     if (IS_ENABLED(CONFIG_COROUTINE_POOL)) {
+        /*
+	 * 只在此处调用
+	 */
         co = coroutine_pool_get();
     }
 
     if (!co) {
+        /*
+	 * 只在此处调用
+	 */
         co = qemu_coroutine_new();
     }
 
-- 
2.39.5 (Apple Git-154)

