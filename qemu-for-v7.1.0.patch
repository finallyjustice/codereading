From 861210ae313d4ced826f558f45f38b44fde7dad4 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Fri, 6 Jan 2023 07:46:10 -0800
Subject: [PATCH 1/1] qemu for v7.1.0

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 accel/kvm/kvm-accel-ops.c             |   4 +
 accel/kvm/kvm-all.c                   | 111 ++++++++++
 block/block-backend.c                 |   7 +
 hw/acpi/cpu.c                         |   4 +
 hw/acpi/ich9.c                        |   4 +
 hw/acpi/pci.c                         |   6 +
 hw/acpi/pcihp.c                       | 112 ++++++++++
 hw/acpi/piix4.c                       |   4 +
 hw/core/qdev.c                        |  54 +++++
 hw/core/reset.c                       |  13 ++
 hw/i386/acpi-build.c                  |  38 ++++
 hw/i386/intel_iommu.c                 |  19 ++
 hw/net/virtio-net.c                   |  29 +++
 hw/scsi/vhost-scsi-common.c           |  20 ++
 hw/scsi/vhost-scsi.c                  |   6 +
 hw/scsi/virtio-scsi-dataplane.c       |  70 +++++++
 hw/scsi/virtio-scsi.c                 |  11 +
 hw/virtio/vhost.c                     |  26 +++
 hw/virtio/virtio-bus.c                |  82 ++++++++
 hw/virtio/virtio-pci.c                |  55 +++++
 hw/virtio/virtio.c                    |  72 +++++++
 include/exec/memory.h                 |  46 +++++
 include/hw/core/accel-cpu.h           |  10 +
 include/hw/core/cpu.h                 |  11 +
 include/hw/qdev-core.h                |  13 ++
 include/hw/virtio/vhost-scsi-common.h |   6 +
 include/hw/virtio/virtio-bus.h        |  30 +++
 include/hw/virtio/virtio-pci.h        |  44 ++++
 include/hw/virtio/virtio-scsi.h       |  39 ++++
 include/hw/virtio/virtio.h            |  22 ++
 include/sysemu/accel-ops.h            |  20 ++
 iothread.c                            |   4 +
 monitor/hmp.c                         |   8 +
 qga/commands-posix.c                  |  28 +++
 qom/object.c                          |   7 +
 softmmu/cpus.c                        |  20 ++
 softmmu/memory.c                      | 237 +++++++++++++++++++++
 softmmu/physmem.c                     |  18 ++
 softmmu/runstate.c                    |  10 +
 softmmu/vl.c                          |  14 ++
 target/i386/cpu.c                     | 133 ++++++++++++
 target/i386/cpu.h                     |  98 +++++++++
 target/i386/host-cpu.c                |  27 +++
 target/i386/kvm/kvm-cpu.c             |  10 +
 target/i386/kvm/kvm.c                 | 285 ++++++++++++++++++++++++++
 target/i386/machine.c                 |  10 +
 util/aio-wait.c                       |  17 ++
 util/log.c                            |  29 +++
 util/qemu-config.c                    |   3 +
 util/qemu-option.c                    |  29 +++
 50 files changed, 1975 insertions(+)

diff --git a/accel/kvm/kvm-accel-ops.c b/accel/kvm/kvm-accel-ops.c
index c4244a23c..21a98283f 100644
--- a/accel/kvm/kvm-accel-ops.c
+++ b/accel/kvm/kvm-accel-ops.c
@@ -24,6 +24,10 @@
 
 #include "kvm-cpus.h"
 
+/*
+ * 在以下使用kvm_vcpu_thread_fn():
+ *   - accel/kvm/kvm-accel-ops.c|73| <<kvm_start_vcpu_thread>> qemu_thread_create(cpu->thread, thread_name, kvm_vcpu_thread_fn,
+ */
 static void *kvm_vcpu_thread_fn(void *arg)
 {
     CPUState *cpu = arg;
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index 8d81ab74d..6ec2ce1e6 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -441,6 +441,10 @@ void kvm_destroy_vcpu(CPUState *cpu)
     }
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|474| <<kvm_init_vcpu>> ret = kvm_get_vcpu(s, kvm_arch_vcpu_id(cpu));
+ */
 static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id)
 {
     struct KVMParkedVcpu *cpu;
@@ -459,6 +463,10 @@ static int kvm_get_vcpu(KVMState *s, unsigned long vcpu_id)
     return kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)vcpu_id);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-accel-ops.c|40| <<kvm_vcpu_thread_fn>> r = kvm_init_vcpu(cpu, &error_fatal);
+ */
 int kvm_init_vcpu(CPUState *cpu, Error **errp)
 {
     KVMState *s = kvm_state;
@@ -1148,6 +1156,22 @@ static MemoryListener kvm_coalesced_pio_listener = {
     .coalesced_io_del = kvm_coalesce_pio_del,
 };
 
+/*
+ * 一些例子:
+ *   - accel/kvm/kvm-all.c|1178| <<kvm_vm_check_extension>> ret = kvm_check_extension(s, extension);
+ *   - accel/kvm/kvm-all.c|1341| <<kvm_check_extension_list>> if (!kvm_check_extension(s, list->value)) {
+ *   - accel/kvm/kvm-all.c|1745| <<kvm_init_irq_routing>> gsi_count = kvm_check_extension(s, KVM_CAP_IRQ_ROUTING) - 1;
+ *   - accel/kvm/kvm-all.c|2150| <<kvm_irqchip_add_hv_sint_route>> if (!kvm_check_extension(s, KVM_CAP_HYPERV_SYNIC)) {
+ *   - accel/kvm/kvm-all.c|2259| <<kvm_irqchip_create>> if (kvm_check_extension(s, KVM_CAP_IRQCHIP)) {
+ *   - accel/kvm/kvm-all.c|2261| <<kvm_irqchip_create>> } else if (kvm_check_extension(s, KVM_CAP_S390_IRQCHIP)) {
+ *   - accel/kvm/kvm-all.c|2311| <<kvm_max_vcpus>> int ret = kvm_check_extension(s, KVM_CAP_MAX_VCPUS);
+ *   - accel/kvm/kvm-all.c|2317| <<kvm_max_vcpu_id>> int ret = kvm_check_extension(s, KVM_CAP_MAX_VCPU_ID);
+ *   - accel/kvm/kvm-all.c|2402| <<kvm_init>> kvm_immediate_exit = kvm_check_extension(s, KVM_CAP_IMMEDIATE_EXIT);
+ *   - target/i386/kvm/kvm.c|1812| <<kvm_arch_init_vcpu>> has_xsave2 = kvm_check_extension(cs->kvm_state, KVM_CAP_XSAVE2);
+ *   - target/i386/kvm/kvm.c|1825| <<kvm_arch_init_vcpu>> r = kvm_check_extension(cs->kvm_state, KVM_CAP_GET_TSC_KHZ) ?
+ *   - target/i386/kvm/kvm.c|2131| <<kvm_arch_init_vcpu>> && kvm_check_extension(cs->kvm_state, KVM_CAP_MCE) > 0) {
+ *   - target/i386/kvm/kvm.c|2334| <<kvm_get_supported_feature_msrs>> if (!kvm_check_extension(s, KVM_CAP_GET_MSR_FEATURES)) {
+ */
 int kvm_check_extension(KVMState *s, unsigned int extension)
 {
     int ret;
@@ -1160,6 +1184,30 @@ int kvm_check_extension(KVMState *s, unsigned int extension)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2305| <<kvm_recommended_vcpus>> int ret = kvm_vm_check_extension(s, KVM_CAP_NR_VCPUS);
+ *   - accel/kvm/kvm-all.c|2503| <<kvm_init>> ret = kvm_vm_check_extension(s, KVM_CAP_DIRTY_LOG_RING);
+ *   - accel/kvm/kvm-all.c|2656| <<kvm_init>> s->sync_mmu = !!kvm_vm_check_extension(kvm_state, KVM_CAP_SYNC_MMU);
+ *   - target/i386/kvm/kvm.c|185| <<kvm_has_smm>> return kvm_vm_check_extension(kvm_state, KVM_CAP_X86_SMM);
+ *   - target/i386/kvm/kvm.c|5281| <<__kvm_enable_sgx_provisioning>> if (!kvm_vm_check_extension(s, KVM_CAP_SGX_ATTRIBUTE)) {
+ *   - target/ppc/kvm.c|104| <<kvmppc_is_pr>> return kvm_vm_check_extension(ks, KVM_CAP_PPC_GET_PVINFO) != 0;
+ *   - target/ppc/kvm.c|116| <<kvm_arch_init>> cap_ppc_smt_possible = kvm_vm_check_extension(s, KVM_CAP_PPC_SMT_POSSIBLE);
+ *   - target/ppc/kvm.c|120| <<kvm_arch_init>> cap_spapr_vfio = kvm_vm_check_extension(s, KVM_CAP_SPAPR_TCE_VFIO);
+ *   - target/ppc/kvm.c|129| <<kvm_arch_init>> cap_htab_fd = kvm_vm_check_extension(s, KVM_CAP_PPC_HTAB_FD);
+ *   - target/ppc/kvm.c|131| <<kvm_arch_init>> cap_ppc_smt = kvm_vm_check_extension(s, KVM_CAP_PPC_SMT);
+ *   - target/ppc/kvm.c|132| <<kvm_arch_init>> cap_htm = kvm_vm_check_extension(s, KVM_CAP_PPC_HTM);
+ *   - target/ppc/kvm.c|133| <<kvm_arch_init>> cap_mmu_radix = kvm_vm_check_extension(s, KVM_CAP_PPC_MMU_RADIX);
+ *   - target/ppc/kvm.c|134| <<kvm_arch_init>> cap_mmu_hash_v3 = kvm_vm_check_extension(s, KVM_CAP_PPC_MMU_HASH_V3);
+ *   - target/ppc/kvm.c|135| <<kvm_arch_init>> cap_xive = kvm_vm_check_extension(s, KVM_CAP_PPC_IRQ_XIVE);
+ *   - target/ppc/kvm.c|136| <<kvm_arch_init>> cap_resize_hpt = kvm_vm_check_extension(s, KVM_CAP_SPAPR_RESIZE_HPT);
+ *   - target/ppc/kvm.c|138| <<kvm_arch_init>> cap_ppc_nested_kvm_hv = kvm_vm_check_extension(s, KVM_CAP_PPC_NESTED_HV);
+ *   - target/ppc/kvm.c|140| <<kvm_arch_init>> cap_fwnmi = kvm_vm_check_extension(s, KVM_CAP_PPC_FWNMI);
+ *   - target/ppc/kvm.c|155| <<kvm_arch_init>> cap_rpt_invalidate = kvm_vm_check_extension(s, KVM_CAP_PPC_RPT_INVALIDATE);
+ *   - target/ppc/kvm.c|1972| <<kvmppc_get_pvinfo>> if (kvm_vm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&
+ *   - target/ppc/kvm.c|2292| <<kvmppc_reset_htab>> if (kvm_vm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {
+ *   - target/ppc/kvm.c|2488| <<kvmppc_get_cpu_characteristics>> ret = kvm_vm_check_extension(s, KVM_CAP_PPC_GET_CPU_CHAR);
+ */
 int kvm_vm_check_extension(KVMState *s, unsigned int extension)
 {
     int ret;
@@ -2760,6 +2808,10 @@ bool kvm_cpu_check_are_resettable(void)
     return kvm_arch_cpu_check_are_resettable();
 }
 
+/*
+ * 在以下使用do_kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-all.c|2774| <<kvm_cpu_synchronize_state>> run_on_cpu(cpu, do_kvm_cpu_synchronize_state, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
 {
     if (!cpu->vcpu_dirty) {
@@ -2768,6 +2820,20 @@ static void do_kvm_cpu_synchronize_state(CPUState *cpu, run_on_cpu_data arg)
     }
 }
 
+/*
+ * 在以下使用和调用kvm_cpu_synchronize_state():
+ *   - accel/kvm/kvm-accel-ops.c|96| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+ *   - accel/kvm/kvm-all.c|3039| <<kvm_cpu_exec>> kvm_cpu_synchronize_state(cpu);
+ *   - accel/stubs/kvm-stub.c|35| <<kvm_cpu_synchronize_state>> void kvm_cpu_synchronize_state(CPUState *cpu)
+ *   - target/arm/kvm64.c|1455| <<kvm_arch_on_sigbus_vcpu>> kvm_cpu_synchronize_state(c);
+ *   - target/arm/kvm64.c|1525| <<kvm_arm_handle_debug>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4824| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4843| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4861| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|4866| <<kvm_arch_process_async_events>> kvm_cpu_synchronize_state(cs);
+ *   - target/i386/kvm/kvm.c|5204| <<kvm_arch_stop_on_emulation_error>> kvm_cpu_synchronize_state(cs);
+ *   - target/s390x/kvm/kvm.c|1967| <<kvm_arch_handle_exit>> kvm_cpu_synchronize_state(cs);
+ */
 void kvm_cpu_synchronize_state(CPUState *cpu)
 {
     if (!cpu->vcpu_dirty) {
@@ -2775,12 +2841,40 @@ void kvm_cpu_synchronize_state(CPUState *cpu)
     }
 }
 
+/*
+ * (gdb) bt
+ * #0  do_kvm_cpu_synchronize_post_reset (cpu=0x555556aa6f30, arg=...) at ../accel/kvm/kvm-all.c:2780
+ * #1  0x0000555555821f77 in process_queued_cpu_work (cpu=0x555556aa6f30) at ../cpus-common.c:351
+ * #2  0x0000555555a717d4 in qemu_wait_io_event_common (cpu=0x555556aa6f30) at ../softmmu/cpus.c:411
+ * #3  0x0000555555a71865 in qemu_wait_io_event (cpu=0x555556aa6f30) at ../softmmu/cpus.c:435
+ * #4  0x0000555555d1105f in kvm_vcpu_thread_fn (arg=0x555556aa6f30) at ../accel/kvm/kvm-accel-ops.c:54
+ * #5  0x0000555555eec56f in qemu_thread_start (args=0x555556ab6b70) at ../util/qemu-thread-posix.c:504
+ * #6  0x00007ffff55eeea5 in start_thread () at /lib64/libpthread.so.0
+ * #7  0x00007ffff53179fd in clone () at /lib64/libc.so.6
+ *
+ * 在以下使用do_kvm_cpu_synchronize_post_reset():
+ *   - accel/kvm/kvm-all.c|2786| <<kvm_cpu_synchronize_post_reset>> run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
+ */
 static void do_kvm_cpu_synchronize_post_reset(CPUState *cpu, run_on_cpu_data arg)
 {
     kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE);
     cpu->vcpu_dirty = false;
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_cpu_synchronize_post_reset (cpu=0x555556aa6f30) at ../accel/kvm/kvm-all.c:2786
+ * #1  0x0000555555a711ea in cpu_synchronize_post_reset (cpu=0x555556aa6f30) at ../softmmu/cpus.c:177
+ * #2  0x0000555555a71066 in cpu_synchronize_all_post_reset () at ../softmmu/cpus.c:145
+ * #3  0x0000555555a798dd in qemu_system_reset (reason=SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET) at ../softmmu/runstate.c:451
+ * #4  0x0000555555a79f75 in main_loop_should_exit (status=0x7fffffffddc4) at ../softmmu/runstate.c:694]
+ * #5  0x0000555555a7a06a in qemu_main_loop () at ../softmmu/runstate.c:730
+ * #6  0x000055555581fe62 in qemu_main (argc=18, argv=0x7fffffffdf18, envp=0x0) at ../softmmu/main.c:38
+ * #7  0x000055555581fe94 in main (argc=18, argv=0x7fffffffdf18) at ../softmmu/main.c:47
+ *
+ * 在以下使用kvm_cpu_synchronize_post_reset():
+ *   - accel/kvm/kvm-accel-ops.c|94| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+ */
 void kvm_cpu_synchronize_post_reset(CPUState *cpu)
 {
     run_on_cpu(cpu, do_kvm_cpu_synchronize_post_reset, RUN_ON_CPU_NULL);
@@ -3589,6 +3683,10 @@ static void kvm_set_kvm_shadow_mem(Object *obj, Visitor *v,
     s->kvm_shadow_mem = value;
 }
 
+/*
+ * 只在以下使用kvm_set_kernel_irqchip():
+ *   - accel/kvm/kvm-all.c|3811| <<kvm_accel_class_init>> NULL, kvm_set_kernel_irqchip,
+ */
 static void kvm_set_kernel_irqchip(Object *obj, Visitor *v,
                                    const char *name, void *opaque,
                                    Error **errp)
@@ -3700,6 +3798,19 @@ static void kvm_accel_class_init(ObjectClass *oc, void *data)
     ac->has_memory = kvm_accel_has_memory;
     ac->allowed = &kvm_allowed;
 
+    /*
+     * 1258 ObjectProperty *
+     * 1259 object_class_property_add(ObjectClass *klass,
+     * 1260                           const char *name,
+     * 1261                           const char *type,
+     * 1262                           ObjectPropertyAccessor *get,
+     * 1263                           ObjectPropertyAccessor *set,
+     * 1264                           ObjectPropertyRelease *release,
+     * 1265                           void *opaque)
+     * 1266 {
+     *
+     * kvm_set_kernel_irqchip()在kvm_arch_init()之前执行
+     */
     object_class_property_add(oc, "kernel-irqchip", "on|off|split",
         NULL, kvm_set_kernel_irqchip,
         NULL, NULL);
diff --git a/block/block-backend.c b/block/block-backend.c
index d4a5df2ac..afb5077df 100644
--- a/block/block-backend.c
+++ b/block/block-backend.c
@@ -1795,6 +1795,13 @@ void blk_drain(BlockBackend *blk)
     }
 }
 
+/*
+ * called by:
+ *   - hw/scsi/megasas.c|1464| <<megasas_cache_flush>> blk_drain_all();
+ *   - hw/scsi/virtio-scsi-dataplane.c|252| <<virtio_scsi_dataplane_stop>> blk_drain_all();
+ *   - qemu-io-cmds.c|1692| <<aio_flush_f>> blk_drain_all();
+ *   - tests/unit/test-block-backend.c|67| <<test_drain_all_aio_error>> blk_drain_all();
+ */
 void blk_drain_all(void)
 {
     BlockBackend *blk = NULL;
diff --git a/hw/acpi/cpu.c b/hw/acpi/cpu.c
index 3646dbfe6..d330cfee3 100644
--- a/hw/acpi/cpu.c
+++ b/hw/acpi/cpu.c
@@ -338,6 +338,10 @@ const VMStateDescription vmstate_cpu_hotplug = {
 #define CPU_EJECT_EVENT   "CEJ0"
 #define CPU_FW_EJECT_EVENT "CEJF"
 
+/*
+ * called by:
+ *  - hw/i386/acpi-build.c|1545| <<build_dsdt>> build_cpus_aml(dsdt, machine, opts, pm->cpu_hp_io_base,
+ */
 void build_cpus_aml(Aml *table, MachineState *machine, CPUHotplugFeatures opts,
                     hwaddr io_base,
                     const char *res_root,
diff --git a/hw/acpi/ich9.c b/hw/acpi/ich9.c
index bd9bbade7..2f9dccd55 100644
--- a/hw/acpi/ich9.c
+++ b/hw/acpi/ich9.c
@@ -260,6 +260,10 @@ const VMStateDescription vmstate_ich9_pm = {
     }
 };
 
+/*
+ * called by:
+ *   - hw/acpi/ich9.c|335| <<ich9_pm_init>> qemu_register_reset(pm_reset, pm);
+ */
 static void pm_reset(void *opaque)
 {
     ICH9LPCPMRegs *pm = opaque;
diff --git a/hw/acpi/pci.c b/hw/acpi/pci.c
index 20b70dcd8..4414990e4 100644
--- a/hw/acpi/pci.c
+++ b/hw/acpi/pci.c
@@ -32,6 +32,12 @@
  * PCI Firmware Specification, Revision 3.0
  * 4.1.2 MCFG Table Description.
  */
+/*
+ * called by:
+ *   - hw/arm/virt-acpi-build.c|968| <<virt_acpi_build>> build_mcfg(tables_blob, tables->linker, &mcfg, vms->oem_id,
+ *   - hw/i386/acpi-build.c|2608| <<acpi_build>> build_mcfg(tables_blob, tables->linker, &mcfg, x86ms->oem_id,
+ *   - hw/loongarch/acpi-build.c|459| <<acpi_build>> build_mcfg(tables_blob, tables->linker, &mcfg, lams->oem_id,
+ */
 void build_mcfg(GArray *table_data, BIOSLinker *linker, AcpiMcfgInfo *info,
                 const char *oem_id, const char *oem_table_id)
 {
diff --git a/hw/acpi/pcihp.c b/hw/acpi/pcihp.c
index 84d75e6b8..ae282c5d3 100644
--- a/hw/acpi/pcihp.c
+++ b/hw/acpi/pcihp.c
@@ -200,6 +200,11 @@ static bool acpi_pcihp_pc_no_hotplug(AcpiPciHpState *s, PCIDevice *dev)
            pci_is_vf(dev);
 }
 
+/*
+ * 在以下使用acpi_pcihp_eject_slot():
+ *   - hw/acpi/pcihp.c|258| <<acpi_pcihp_update_hotplug_bus>> acpi_pcihp_eject_slot(s, bsel, s->acpi_pcihp_pci_status[bsel].down);
+ *   - hw/acpi/pcihp.c|520| <<pci_write(PCI_EJ_BASE)>> acpi_pcihp_eject_slot(s, s->hotplug_select, data);
+ */
 static void acpi_pcihp_eject_slot(AcpiPciHpState *s, unsigned bsel, unsigned slots)
 {
     HotplugHandler *hotplug_ctrl;
@@ -248,6 +253,10 @@ static void acpi_pcihp_eject_slot(AcpiPciHpState *s, unsigned bsel, unsigned slo
     }
 }
 
+/*
+ * called by:
+ *   - hw/acpi/pcihp.c|282| <<acpi_pcihp_update>> acpi_pcihp_update_hotplug_bus(s, i);
+ */
 static void acpi_pcihp_update_hotplug_bus(AcpiPciHpState *s, int bsel)
 {
     BusChild *kid, *next;
@@ -274,6 +283,10 @@ static void acpi_pcihp_update_hotplug_bus(AcpiPciHpState *s, int bsel)
     }
 }
 
+/*
+ * called by:
+ *   - hw/acpi/pcihp.c|292| <<acpi_pcihp_reset>> acpi_pcihp_update(s);
+ */
 static void acpi_pcihp_update(AcpiPciHpState *s)
 {
     int i;
@@ -283,6 +296,100 @@ static void acpi_pcihp_update(AcpiPciHpState *s)
     }
 }
 
+/*
+ * i440fx system_reset循序调用以下.
+ *
+ * (gdb) bt
+ * #0  acpi_pcihp_reset (s=0x55555768a510, acpihp_root_off=false) at ../hw/acpi/pcihp.c:288
+ * #1  0x000055555586b70d in piix4_pm_reset (dev=0x555557689210) at ../hw/acpi/piix4.c:308
+ * #2  0x0000555555d218cb in device_transitional_reset (obj=0x555557689210) at ../hw/core/qdev.c:823
+ * #3  0x0000555555d23536 in resettable_phase_hold (obj=0x555557689210, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:182
+ * #4  0x0000555555d1c74c in bus_reset_child_foreach (obj=0x555556c22de0, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD)
+ *     at ../hw/core/bus.c:97
+ * #5  0x0000555555d2323d in resettable_child_foreach
+ *     (rc=0x555556899f60, obj=0x555556c22de0, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:96
+ * #6  0x0000555555d234bc in resettable_phase_hold (obj=0x555556c22de0, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:173
+ * #7  0x0000555555d205e3 in device_reset_child_foreach (obj=0x555556b03e70, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD)
+ *     at ../hw/core/qdev.c:317
+ * #8  0x0000555555d2323d in resettable_child_foreach
+ *     (rc=0x555556951180, obj=0x555556b03e70, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:96
+ * #9  0x0000555555d234bc in resettable_phase_hold (obj=0x555556b03e70, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:173
+ * #10 0x0000555555d1c74c in bus_reset_child_foreach (obj=0x555556a5bd10, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD)
+ *     at ../hw/core/bus.c:97
+ * #11 0x0000555555d2323d in resettable_child_foreach
+ *     (rc=0x555556998150, obj=0x555556a5bd10, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:96
+ * #12 0x0000555555d234bc in resettable_phase_hold (obj=0x555556a5bd10, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:173
+ * #13 0x0000555555d230ee in resettable_assert_reset (obj=0x555556a5bd10, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:60
+ * #14 0x0000555555d23032 in resettable_reset (obj=0x555556a5bd10, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #15 0x0000555555d23873 in resettable_cold_reset_fn (opaque=0x555556a5bd10) at ../hw/core/resettable.c:269
+ * #16 0x0000555555d21d7a in qemu_devices_reset () at ../hw/core/reset.c:69
+ * #17 0x0000555555b4d08c in pc_machine_reset (machine=0x555556a526e0) at ../hw/i386/pc.c:1851
+ * #18 0x0000555555a798ac in qemu_system_reset (reason=SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET) at ../softmmu/runstate.c:444
+ * #19 0x0000555555a79f75 in main_loop_should_exit (status=0x7fffffffdc04) at ../softmmu/runstate.c:694
+ * #20 0x0000555555a7a06a in qemu_main_loop () at ../softmmu/runstate.c:730
+ * #21 0x000055555581fe62 in qemu_main (argc=32, argv=0x7fffffffdd58, envp=0x0) at ../softmmu/main.c:38
+ * #22 0x000055555581fe94 in main (argc=32, argv=0x7fffffffdd58) at ../softmmu/main.c:47
+ *
+ * (gdb) bt
+ * #0  acpi_pcihp_reset (s=0x55555768a510, acpihp_root_off=false) at ../hw/acpi/pcihp.c:288
+ * #1  0x000055555586b70d in piix4_pm_reset (dev=0x555557689210) at ../hw/acpi/piix4.c:308
+ * #2  0x0000555555d218cb in device_transitional_reset (obj=0x555557689210) at ../hw/core/qdev.c:823
+ * #3  0x0000555555d23536 in resettable_phase_hold (obj=0x555557689210, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:182
+ * #4  0x0000555555d1c74c in bus_reset_child_foreach (obj=0x555556c22de0, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD)
+ *     at ../hw/core/bus.c:97
+ * #5  0x0000555555d2323d in resettable_child_foreach
+ *     (rc=0x555556899f60, obj=0x555556c22de0, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:96
+ * #6  0x0000555555d234bc in resettable_phase_hold (obj=0x555556c22de0, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:173
+ * #7  0x0000555555d205e3 in device_reset_child_foreach (obj=0x555556b03e70, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD)
+ *     at ../hw/core/qdev.c:317
+ * #8  0x0000555555d2323d in resettable_child_foreach
+ *     (rc=0x555556951180, obj=0x555556b03e70, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:96
+ * #9  0x0000555555d234bc in resettable_phase_hold (obj=0x555556b03e70, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:173
+ * #10 0x0000555555d1c74c in bus_reset_child_foreach (obj=0x555556a5bd10, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD)
+ *     at ../hw/core/bus.c:97
+ * #11 0x0000555555d2323d in resettable_child_foreach
+ *     (rc=0x555556998150, obj=0x555556a5bd10, cb=0x555555d23408 <resettable_phase_hold>, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:96
+ * #12 0x0000555555d234bc in resettable_phase_hold (obj=0x555556a5bd10, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:173
+ * #13 0x0000555555d230ee in resettable_assert_reset (obj=0x555556a5bd10, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:60
+ * #14 0x0000555555d23032 in resettable_reset (obj=0x555556a5bd10, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #15 0x0000555555d23873 in resettable_cold_reset_fn (opaque=0x555556a5bd10) at ../hw/core/resettable.c:269
+ * #16 0x0000555555d21d7a in qemu_devices_reset () at ../hw/core/reset.c:69
+ * #17 0x0000555555b4d08c in pc_machine_reset (machine=0x555556a526e0) at ../hw/i386/pc.c:1851
+ * #18 0x0000555555a798ac in qemu_system_reset (reason=SHUTDOWN_CAUSE_GUEST_RESET) at ../softmmu/runstate.c:444
+ * #19 0x0000555555a79f75 in main_loop_should_exit (status=0x7fffffffdc04) at ../softmmu/runstate.c:694
+ * #20 0x0000555555a7a06a in qemu_main_loop () at ../softmmu/runstate.c:730
+ * #21 0x000055555581fe62 in qemu_main (argc=32, argv=0x7fffffffdd58, envp=0x0) at ../softmmu/main.c:38
+ * #22 0x000055555581fe94 in main (argc=32, argv=0x7fffffffdd58) at ../softmmu/main.c:47
+ *
+ *
+ * 在q35 system_reset的时候
+ *
+ * (gdb) bt
+ * #0  acpi_pcihp_reset (s=0x55555708b130, acpihp_root_off=true) at ../hw/acpi/pcihp.c:288
+ * #1  0x000055555586f0cc in pm_reset (opaque=0x55555708a790) at ../hw/acpi/ich9.c:281
+ * #2  0x0000555555d21d7a in qemu_devices_reset () at ../hw/core/reset.c:69
+ * #3  0x0000555555b4d08c in pc_machine_reset (machine=0x555556a528f0) at ../hw/i386/pc.c:1851
+ * #4  0x0000555555a798ac in qemu_system_reset (reason=SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET) at ../softmmu/runstate.c:444
+ * #5  0x0000555555a79f75 in main_loop_should_exit (status=0x7fffffffdbb4) at ../softmmu/runstate.c:694
+ * #6  0x0000555555a7a06a in qemu_main_loop () at ../softmmu/runstate.c:730
+ * #7  0x000055555581fe62 in qemu_main (argc=36, argv=0x7fffffffdd08, envp=0x0) at ../softmmu/main.c:38
+ * #8  0x000055555581fe94 in main (argc=36, argv=0x7fffffffdd08) at ../softmmu/main.c:47
+ *
+ * (gdb) bt
+ * #0  acpi_pcihp_reset (s=0x55555708b130, acpihp_root_off=true) at ../hw/acpi/pcihp.c:288
+ * #1  0x000055555586f0cc in pm_reset (opaque=0x55555708a790) at ../hw/acpi/ich9.c:281
+ * #2  0x0000555555d21d7a in qemu_devices_reset () at ../hw/core/reset.c:69
+ * #3  0x0000555555b4d08c in pc_machine_reset (machine=0x555556a528f0) at ../hw/i386/pc.c:1851
+ * #4  0x0000555555a798ac in qemu_system_reset (reason=SHUTDOWN_CAUSE_GUEST_RESET) at ../softmmu/runstate.c:444
+ * #5  0x0000555555a79f75 in main_loop_should_exit (status=0x7fffffffdbb4) at ../softmmu/runstate.c:694
+ * #6  0x0000555555a7a06a in qemu_main_loop () at ../softmmu/runstate.c:730
+ * #7  0x000055555581fe62 in qemu_main (argc=36, argv=0x7fffffffdd08, envp=0x0) at ../softmmu/main.c:38
+ * #8  0x000055555581fe94 in main (argc=36, argv=0x7fffffffdd08) at ../softmmu/main.c:47
+ *
+ * called by:
+ *   - hw/acpi/ich9.c|281| <<pm_reset>> acpi_pcihp_reset(&pm->acpi_pci_hotplug, true);
+ *   - hw/acpi/piix4.c|308| <<piix4_pm_reset>> acpi_pcihp_reset(&s->acpi_pci_hotplug, !s->use_acpi_root_pci_hotplug);
+ */
 void acpi_pcihp_reset(AcpiPciHpState *s, bool acpihp_root_off)
 {
     if (acpihp_root_off) {
@@ -538,6 +645,11 @@ static const MemoryRegionOps acpi_pcihp_io_ops = {
     },
 };
 
+/*
+ * called by:
+ *   - hw/acpi/ich9.c|323| <<ich9_pm_init>> acpi_pcihp_init(OBJECT(lpc_pci),
+ *   - hw/acpi/piix4.c|565| <<piix4_acpi_system_hot_add_init>> acpi_pcihp_init(OBJECT(s), &s->acpi_pci_hotplug, bus, parent,
+ */
 void acpi_pcihp_init(Object *owner, AcpiPciHpState *s, PCIBus *root_bus,
                      MemoryRegion *address_space_io, bool bridges_enabled,
                      uint16_t io_base)
diff --git a/hw/acpi/piix4.c b/hw/acpi/piix4.c
index 0a81f1ad9..e711be752 100644
--- a/hw/acpi/piix4.c
+++ b/hw/acpi/piix4.c
@@ -279,6 +279,10 @@ static const VMStateDescription vmstate_acpi = {
     }
 };
 
+/*
+ * 在以下使用piix4_pm_reset():
+ *   - hw/acpi/piix4.c|630| <<piix4_pm_class_init>> dc->reset = piix4_pm_reset;
+ */
 static void piix4_pm_reset(DeviceState *dev)
 {
     PIIX4PMState *s = PIIX4_PM(dev);
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index 0806d8fca..eccef5c1a 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -56,6 +56,43 @@ static void bus_free_bus_child(BusChild *kid)
     g_free(kid);
 }
 
+/*
+ * (gdb) bt
+ * #0  bus_remove_child (bus=0x5555571e3f58, child=0x5555571e3fe0) at ../hw/core/qdev.c:60
+ * #1  0x0000555555d217b5 in device_unparent (obj=0x5555571e3fe0) at ../hw/core/qdev.c:779
+ * #2  0x0000555555d29795 in object_finalize_child_property (obj=0x5555571dbc20, name=0x5555568469c0 "virtio-backend", opaque=0x5555571e3fe0)
+ *     at ../qom/object.c:1732
+ * #3  0x0000555555d271ac in object_property_del_child (obj=0x5555571dbc20, child=0x5555571e3fe0) at ../qom/object.c:649
+ * #4  0x0000555555d27287 in object_unparent (obj=0x5555571e3fe0) at ../qom/object.c:668
+ * #5  0x0000555555d1ca3a in bus_unparent (obj=0x5555571e3f58) at ../hw/core/bus.c:148
+ * #6  0x0000555555d29795 in object_finalize_child_property (obj=0x5555571dbc20, name=0x555556df1290 "virtio-bus", opaque=0x5555571e3f58) at ../qom/object.c:1732
+ * #7  0x0000555555d271ac in object_property_del_child (obj=0x5555571dbc20, child=0x5555571e3f58) at ../qom/object.c:649
+ * #8  0x0000555555d27287 in object_unparent (obj=0x5555571e3f58) at ../qom/object.c:668
+ * #9  0x0000555555d21786 in device_unparent (obj=0x5555571dbc20) at ../hw/core/qdev.c:776
+ * #10 0x0000555555d29795 in object_finalize_child_property (obj=0x555556a52c00, name=0x555557125170 "vnic01", opaque=0x5555571dbc20) at ../qom/object.c:1732
+ * #11 0x0000555555d271ac in object_property_del_child (obj=0x555556a52c00, child=0x5555571dbc20) at ../qom/object.c:649
+ * #12 0x0000555555d27287 in object_unparent (obj=0x5555571dbc20) at ../qom/object.c:668
+ * #13 0x000055555586da8a in acpi_pcihp_eject_slot (s=0x55555768a510, bsel=0, slots=16) at ../hw/acpi/pcihp.c:244
+ * #14 0x000055555586e50c in pci_write (opaque=0x55555768a510, addr=8, data=16, size=4) at ../hw/acpi/pcihp.c:520
+ * #15 0x0000555555c650a3 in memory_region_write_accessor (mr=0x55555768b120, addr=8, value=0x7fffed4a06a8, size=4, shift=0, mask=4294967295, attrs=...)
+ *     at ../softmmu/memory.c:492
+ * #16 0x0000555555c652e7 in access_with_adjusted_size (addr=8, value=0x7fffed4a06a8, size=4, access_size_min=1, access_size_max=4, access_fn=
+ *     0x555555c64fad <memory_region_write_accessor>, mr=0x55555768b120, attrs=...) at ../softmmu/memory.c:554
+ * #17 0x0000555555c683dd in memory_region_dispatch_write (mr=0x55555768b120, addr=8, data=16, op=MO_32, attrs=...) at ../softmmu/memory.c:1514
+ * #18 0x0000555555c758f6 in flatview_write_continue (fv=0x7ffddc009460, addr=44552, attrs=..., ptr=0x7ffff7fed000, len=4, addr1=8, l=4, mr=0x55555768b120)
+ *     at ../softmmu/physmem.c:2825
+ * #19 0x0000555555c75a59 in flatview_write (fv=0x7ffddc009460, addr=44552, attrs=..., buf=0x7ffff7fed000, len=4) at ../softmmu/physmem.c:2867
+ * #20 0x0000555555c75e09 in address_space_write (as=0x5555567b3420 <address_space_io>, addr=44552, attrs=..., buf=0x7ffff7fed000, len=4)
+ *     at ../softmmu/physmem.c:2963
+ * #21 0x0000555555c75e76 in address_space_rw (as=0x5555567b3420 <address_space_io>, addr=44552, attrs=..., buf=0x7ffff7fed000, len=4, is_write=true)
+ *     at ../softmmu/physmem.c:2973
+ * #22 0x0000555555d0db63 in kvm_handle_io (port=44552, attrs=..., data=0x7ffff7fed000, direction=1, size=4, count=1) at ../accel/kvm/kvm-all.c:2693
+ * #23 0x0000555555d0e2dd in kvm_cpu_exec (cpu=0x555556ae3cb0) at ../accel/kvm/kvm-all.c:2944
+ * #24 0x0000555555d10faa in kvm_vcpu_thread_fn (arg=0x555556ae3cb0) at ../accel/kvm/kvm-accel-ops.c:49
+ * #25 0x0000555555eec4de in qemu_thread_start (args=0x555556af2de0) at ../util/qemu-thread-posix.c:504
+ * #26 0x00007ffff55eeea5 in start_thread () at /lib64/libpthread.so.0
+ * #27 0x00007ffff53179fd in clone () at /lib64/libc.so.6
+ */
 static void bus_remove_child(BusState *bus, DeviceState *child)
 {
     BusChild *kid;
@@ -720,6 +757,23 @@ static void device_post_init(Object *obj)
 }
 
 /* Unlink device from bus and free the structure.  */
+/*
+ * (gdb) bt
+ * #0  device_finalize (obj=0x5555571e3fe0) at ../hw/core/qdev.c:727
+ * #1  0x0000555555d272b8 in object_deinit (obj=0x5555571e3fe0, type=0x55555683a5f0) at ../qom/object.c:675
+ * #2  0x0000555555d272e6 in object_deinit (obj=0x5555571e3fe0, type=0x55555682f140) at ../qom/object.c:679
+ * #3  0x0000555555d272e6 in object_deinit (obj=0x5555571e3fe0, type=0x55555682dee0) at ../qom/object.c:679
+ * #4  0x0000555555d2732a in object_finalize (data=0x5555571e3fe0) at ../qom/object.c:689
+ * #5  0x0000555555d28147 in object_unref (objptr=0x5555571e3fe0) at ../qom/object.c:1192
+ * #6  0x0000555555d1fbc2 in bus_free_bus_child (kid=0x555556df11f0) at ../hw/core/qdev.c:55
+ * #7  0x0000555555ef6fe1 in call_rcu_thread (opaque=0x0) at ../util/rcu.c:284
+ * #8  0x0000555555eec4de in qemu_thread_start (args=0x5555567e7e80) at ../util/qemu-thread-posix.c:504
+ * #9  0x00007ffff55eeea5 in start_thread () at /lib64/libpthread.so.0
+ * #10 0x00007ffff53179fd in clone () at /lib64/libc.so.6
+ *
+ * 在以下使用device_finalize():
+ *   - hw/core/qdev.c|954| <<global>> .instance_finalize = device_finalize,
+ */
 static void device_finalize(Object *obj)
 {
     NamedGPIOList *ngl, *next;
diff --git a/hw/core/reset.c b/hw/core/reset.c
index 36be82c49..ea444e4d2 100644
--- a/hw/core/reset.c
+++ b/hw/core/reset.c
@@ -60,6 +60,19 @@ void qemu_unregister_reset(QEMUResetHandler *func, void *opaque)
     }
 }
 
+/*
+ * called by:
+ *   - hw/arm/aspeed.c|1357| <<fby35_reset>> qemu_devices_reset();
+ *   - hw/arm/mps2-tz.c|1252| <<mps2_machine_reset>> qemu_devices_reset();
+ *   - hw/hppa/machine.c|419| <<hppa_machine_reset>> qemu_devices_reset();
+ *   - hw/i386/microvm.c|483| <<microvm_machine_reset>> qemu_devices_reset();
+ *   - hw/i386/pc.c|1851| <<pc_machine_reset>> qemu_devices_reset();
+ *   - hw/ppc/pegasos2.c|258| <<pegasos2_machine_reset>> qemu_devices_reset();
+ *   - hw/ppc/pnv.c|582| <<pnv_reset>> qemu_devices_reset();
+ *   - hw/ppc/spapr.c|1652| <<spapr_machine_reset>> qemu_devices_reset();
+ *   - hw/s390x/s390-virtio-ccw.c|430| <<s390_machine_reset>> qemu_devices_reset();
+ *   - softmmu/runstate.c|446| <<qemu_system_reset>> qemu_devices_reset();
+ */
 void qemu_devices_reset(void)
 {
     QEMUResetEntry *re, *nre;
diff --git a/hw/i386/acpi-build.c b/hw/i386/acpi-build.c
index 0355bd3dd..ec22ce3ea 100644
--- a/hw/i386/acpi-build.c
+++ b/hw/i386/acpi-build.c
@@ -213,6 +213,20 @@ static Object *object_resolve_type_unambiguous(const char *typename)
     return o;
 }
 
+/*
+ * (gdb) bt
+#0  acpi_get_pm_info (machine=0x555556a51aa0, pm=0x7fffffffda20) at ../hw/i386/acpi-build.c:218
+#1  0x0000555555b56b1c in acpi_build (tables=0x7fffffffdb50, machine=0x555556a51aa0) at ../hw/i386/acpi-build.c:2484
+#2  0x0000555555b5798d in acpi_setup () at ../hw/i386/acpi-build.c:2802
+#3  0x0000555555b4a2f7 in pc_machine_done (notifier=0x555556a51c88, data=0x0) at ../hw/i386/pc.c:758
+#4  0x0000555555ef1e2b in notifier_list_notify (list=0x5555567aac38 <machine_init_done_notifiers>, data=0x0) at ../util/notify.c:39
+#5  0x00005555558a76c4 in qdev_machine_creation_done () at ../hw/core/machine.c:1448
+#6  0x0000555555a8018b in qemu_machine_creation_done () at ../softmmu/vl.c:2554
+#7  0x0000555555a80287 in qmp_x_exit_preconfig (errp=0x5555567d1640 <error_fatal>) at ../softmmu/vl.c:2583
+#8  0x0000555555a8290d in qemu_init (argc=15, argv=0x7fffffffdf58, envp=0x0) at ../softmmu/vl.c:3584
+#9  0x000055555581fe5d in qemu_main (argc=15, argv=0x7fffffffdf58, envp=0x0) at ../softmmu/main.c:37
+#10 0x000055555581fe94 in main (argc=15, argv=0x7fffffffdf58) at ../softmmu/main.c:47
+ */
 static void acpi_get_pm_info(MachineState *machine, AcpiPmInfo *pm)
 {
     Object *piix = object_resolve_type_unambiguous(TYPE_PIIX4_PM);
@@ -1429,6 +1443,10 @@ static void build_acpi0017(Aml *table)
     aml_append(table, scope);
 }
 
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|2529| <<acpi_build>> build_dsdt(tables_blob, tables->linker, &pm, &misc,
+ */
 static void
 build_dsdt(GArray *table_data, BIOSLinker *linker,
            AcpiPmInfo *pm, AcpiMiscInfo *misc,
@@ -1930,6 +1948,10 @@ build_tpm_tcpa(GArray *table_data, BIOSLinker *linker, GArray *tcpalog,
  * ACPI spec, Revision 3.0
  * 5.2.15 System Resource Affinity Table (SRAT)
  */
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|2581| <<acpi_build>> build_srat(tables_blob, tables->linker, machine)
+ */
 static void
 build_srat(GArray *table_data, BIOSLinker *linker, MachineState *machine)
 {
@@ -2460,6 +2482,11 @@ static bool acpi_get_mcfg(AcpiMcfgInfo *mcfg)
     return true;
 }
 
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|2741| <<acpi_build_update>> acpi_build(&tables, MACHINE(qdev_get_machine()));
+ *   - hw/i386/acpi-build.c|2802| <<acpi_setup>> acpi_build(&tables, MACHINE(pcms));
+ */
 static
 void acpi_build(AcpiBuildTables *tables, MachineState *machine)
 {
@@ -2725,6 +2752,13 @@ static void acpi_ram_update(MemoryRegion *mr, GArray *data)
     memory_region_set_dirty(mr, 0, size);
 }
 
+/*
+ * called by:
+ *   - hw/i386/acpi-build.c|2818| <<acpi_setup>> build_state->table_mr = acpi_add_rom_blob(acpi_build_update, build_state, tables.table_data, ACPI_BUILD_TABLE_FILE);
+ *   - hw/i386/acpi-build.c|2824| <<acpi_setup>> acpi_add_rom_blob(acpi_build_update, build_state, tables.linker->cmd_blob, ACPI_BUILD_LOADER_FILE);
+ *   - hw/i386/acpi-build.c|2859| <<acpi_setup>> acpi_build_update, NULL, build_state, acpi_build_update, NULL, build_state, build_state->rsdp, rsdp_size, true);
+ *   - hw/i386/acpi-build.c|2864| <<acpi_setup>> build_state->rsdp_mr = acpi_add_rom_blob(acpi_build_update, build_state, tables.rsdp, ACPI_BUILD_RSDP_FILE);
+ */
 static void acpi_build_update(void *build_opaque)
 {
     AcpiBuildState *build_state = build_opaque;
@@ -2768,6 +2802,10 @@ static const VMStateDescription vmstate_acpi_build = {
     },
 };
 
+/*
+ * called by:
+ *   - hw/i386/pc.c|758| <<pc_machine_done>> acpi_setup();
+ */
 void acpi_setup(void)
 {
     PCMachineState *pcms = PC_MACHINE(qdev_get_machine());
diff --git a/hw/i386/intel_iommu.c b/hw/i386/intel_iommu.c
index 2162394e0..a05f0889f 100644
--- a/hw/i386/intel_iommu.c
+++ b/hw/i386/intel_iommu.c
@@ -1590,6 +1590,13 @@ static bool vtd_as_pt_enabled(VTDAddressSpace *as)
 }
 
 /* Return whether the device is using IOMMU translation. */
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|1645| <<vtd_switch_address_space_all>> vtd_switch_address_space(vtd_bus->dev_as[i]);
+ *   - hw/i386/intel_iommu.c|1705| <<vtd_pt_enable_fast_path>> if (vtd_switch_address_space(vtd_as) == false) {
+ *   - hw/i386/intel_iommu.c|1950| <<vtd_context_device_invalidate>> vtd_switch_address_space(vtd_as);
+ *   - hw/i386/intel_iommu.c|3505| <<vtd_find_add_as>> vtd_switch_address_space(vtd_dev_as);
+ */
 static bool vtd_switch_address_space(VTDAddressSpace *as)
 {
     bool use_iommu;
@@ -3425,6 +3432,13 @@ static const MemoryRegionOps vtd_mem_ir_ops = {
     },
 };
 
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|3798| <<vtd_host_dma_iommu>> vtd_as = vtd_find_add_as(s, bus, devfn);
+ *
+ * 注释: Find the VTD Address space associated with the given bus pointer,
+ * create a new one if none exists
+ */
 VTDAddressSpace *vtd_find_add_as(IntelIOMMUState *s, PCIBus *bus, int devfn)
 {
     uintptr_t key = (uintptr_t)bus;
@@ -3788,6 +3802,11 @@ static void vtd_reset(DeviceState *dev)
     vtd_address_space_refresh_all(s);
 }
 
+/*
+ * called by:
+ *   - hw/i386/intel_iommu.c|3905| <<vtd_realize>> pci_setup_iommu(bus, vtd_host_dma_iommu, dev);
+ *   - hw/i386/intel_iommu.c|3907| <<vtd_realize>> x86ms->ioapic_as = vtd_host_dma_iommu(bus, s, Q35_PSEUDO_DEVFN_IOAPIC);
+ */
 static AddressSpace *vtd_host_dma_iommu(PCIBus *bus, void *opaque, int devfn)
 {
     IntelIOMMUState *s = opaque;
diff --git a/hw/net/virtio-net.c b/hw/net/virtio-net.c
index dd0d056fd..daff0d791 100644
--- a/hw/net/virtio-net.c
+++ b/hw/net/virtio-net.c
@@ -1171,6 +1171,30 @@ static void virtio_net_disable_rss(VirtIONet *n)
     virtio_net_detach_epbf_rss(n);
 }
 
+/*
+ * (gdb) bt
+ * #0  virtio_net_attach_ebpf_to_backend (nic=0x5555578316c0, prog_fd=-1) at ../hw/net/virtio-net.c:1239
+ * #1  0x0000555555c18bf2 in virtio_net_detach_epbf_rss (n=0x555557806ed0) at ../hw/net/virtio-net.c:1281
+ * #2  0x0000555555c18a19 in virtio_net_disable_rss (n=0x555557806ed0) at ../hw/net/virtio-net.c:1234
+ * #3  0x0000555555c192cb in virtio_net_handle_mq (n=0x555557806ed0, cmd=0 '\000', iov=0x7ffee8270bd0, iov_cnt=1) at ../hw/net/virtio-net.c:1448
+ * #4  0x0000555555c19617 in virtio_net_handle_ctrl_iov (vdev=0x555557806ed0, in_sg=0x7ffee825c3a0, in_num=1, out_sg=0x7ffee825c3b0, out_num=1) at ../hw/net/virtio-net.c:1525
+ * #5  0x0000555555c19710 in virtio_net_handle_ctrl (vdev=0x555557806ed0, vq=0x7fffef86f4d0) at ../hw/net/virtio-net.c:1548
+ * #6  0x0000555555c519f4 in virtio_queue_notify (vdev=0x555557806ed0, n=8) at ../hw/virtio/virtio.c:2867
+ * #7  0x0000555555a60b0c in virtio_pci_notify_write (opaque=0x5555577feb10, addr=32, val=8, size=2) at ../hw/virtio/virtio-pci.c:1436
+ * #8  0x0000555555c9b042 in memory_region_write_accessor (mr=0x5555577ff9a0, addr=32, value=0x7ffeef7fe6e8, size=2, shift=0, mask=65535, attrs=...) at ../softmmu/memory.c:493
+ * #9  0x0000555555c9b286 in access_with_adjusted_size (addr=32, value=0x7ffeef7fe6e8, size=2, access_size_min=1, access_size_max=4, access_fn=
+ *     0x555555c9af4c <memory_region_write_accessor>, mr=0x5555577ff9a0, attrs=...) at ../softmmu/memory.c:555
+ * #10 0x0000555555c9e37d in memory_region_dispatch_write (mr=0x5555577ff9a0, addr=32, data=8, op=MO_16, attrs=...) at ../softmmu/memory.c:1515
+ * #11 0x0000555555cabbac in flatview_write_continue (fv=0x7ffee02ab0a0, addr=4261425184, attrs=..., ptr=0x7ffff7ff2028, len=2, addr1=32, l=2, mr=0x5555577ff9a0) at ../softmmu/physmem.c:2825
+ * #12 0x0000555555cabd0f in flatview_write (fv=0x7ffee02ab0a0, addr=4261425184, attrs=..., buf=0x7ffff7ff2028, len=2) at ../softmmu/physmem.c:2867
+ * #13 0x0000555555cac0bf in address_space_write (as=0x5555567deb00 <address_space_memory>, addr=4261425184, attrs=..., buf=0x7ffff7ff2028, len=2) at ../softmmu/physmem.c:2963
+ * #14 0x0000555555cac12c in address_space_rw (as=0x5555567deb00 <address_space_memory>, addr=4261425184, attrs=..., buf=0x7ffff7ff2028, len=2, is_write=true) at ../softmmu/physmem.c:2973
+ * #15 0x0000555555d3e37a in kvm_cpu_exec (cpu=0x555556b1b370) at ../accel/kvm/kvm-all.c:2900
+ * #16 0x0000555555d4104e in kvm_vcpu_thread_fn (arg=0x555556b1b370) at ../accel/kvm/kvm-accel-ops.c:51
+ * #17 0x0000555555f21924 in qemu_thread_start (args=0x555556b23120) at ../util/qemu-thread-posix.c:505
+ * #18 0x00007ffff5c05ea5 in start_thread () at /lib64/libpthread.so.0
+ * #19 0x00007ffff592eb2d in clone () at /lib64/libc.so.6
+ */
 static bool virtio_net_attach_ebpf_to_backend(NICState *nic, int prog_fd)
 {
     NetClientState *nc = qemu_get_peer(qemu_get_queue(nic), 0);
@@ -1234,6 +1258,11 @@ static void virtio_net_unload_ebpf(VirtIONet *n)
     ebpf_rss_unload(&n->ebpf_rss);
 }
 
+/*
+ * called by:
+ *   - hw/net/virtio-net.c|1387| <<virtio_net_handle_mq>> queue_pairs = virtio_net_handle_rss(n, iov, iov_cnt, false);
+ *   - hw/net/virtio-net.c|1391| <<virtio_net_handle_mq>> queue_pairs = virtio_net_handle_rss(n, iov, iov_cnt, true);
+ */
 static uint16_t virtio_net_handle_rss(VirtIONet *n,
                                       struct iovec *iov,
                                       unsigned int iov_cnt,
diff --git a/hw/scsi/vhost-scsi-common.c b/hw/scsi/vhost-scsi-common.c
index 767f827e5..321cd9922 100644
--- a/hw/scsi/vhost-scsi-common.c
+++ b/hw/scsi/vhost-scsi-common.c
@@ -127,9 +127,29 @@ uint64_t vhost_scsi_common_get_features(VirtIODevice *vdev, uint64_t features,
     /* Turn on predefined features supported by this device */
     features |= vsc->host_features;
 
+    /*
+     * vhost scsi的
+     * static const int kernel_feature_bits[] = {
+     *     VIRTIO_F_NOTIFY_ON_EMPTY,
+     *     VIRTIO_RING_F_INDIRECT_DESC,
+     *     VIRTIO_RING_F_EVENT_IDX,
+     *     VIRTIO_SCSI_F_HOTPLUG,
+     *     VHOST_INVALID_FEATURE_BIT
+     * };
+     *
+     * 在以下使用VHostSCSICommon->feature_bits:
+     *   - hw/scsi/vhost-scsi-common.c|130| <<vhost_scsi_common_get_features>> return vhost_get_features(&vsc->dev, vsc->feature_bits, features);
+     *   - hw/scsi/vhost-scsi.c|325| <<vhost_scsi_instance_init>> vsc->feature_bits = kernel_feature_bits;
+     *   - hw/scsi/vhost-user-scsi.c|215| <<vhost_user_scsi_instance_init>> vsc->feature_bits = user_feature_bits;
+     */
     return vhost_get_features(&vsc->dev, vsc->feature_bits, features);
 }
 
+/*
+ * 在以下使用vhost_scsi_common_set_config():
+ *   - hw/scsi/vhost-scsi.c|315| <<vhost_scsi_class_init>> vdc->set_config = vhost_scsi_common_set_config;
+ *   - hw/scsi/vhost-user-scsi.c|205| <<vhost_user_scsi_class_init>> vdc->set_config = vhost_scsi_common_set_config;
+ */
 void vhost_scsi_common_set_config(VirtIODevice *vdev, const uint8_t *config)
 {
     VirtIOSCSIConfig *scsiconf = (VirtIOSCSIConfig *)config;
diff --git a/hw/scsi/vhost-scsi.c b/hw/scsi/vhost-scsi.c
index 305906817..e1792d213 100644
--- a/hw/scsi/vhost-scsi.c
+++ b/hw/scsi/vhost-scsi.c
@@ -322,6 +322,12 @@ static void vhost_scsi_instance_init(Object *obj)
 {
     VHostSCSICommon *vsc = VHOST_SCSI_COMMON(obj);
 
+    /*
+     * 在以下使用VHostSCSICommon->feature_bits:
+     *   - hw/scsi/vhost-scsi-common.c|130| <<vhost_scsi_common_get_features>> return vhost_get_features(&vsc->dev, vsc->feature_bits, features);
+     *   - hw/scsi/vhost-scsi.c|325| <<vhost_scsi_instance_init>> vsc->feature_bits = kernel_feature_bits;
+     *   - hw/scsi/vhost-user-scsi.c|215| <<vhost_user_scsi_instance_init>> vsc->feature_bits = user_feature_bits;
+     */
     vsc->feature_bits = kernel_feature_bits;
 
     device_add_bootindex_property(obj, &vsc->bootindex, "bootindex", NULL,
diff --git a/hw/scsi/virtio-scsi-dataplane.c b/hw/scsi/virtio-scsi-dataplane.c
index 20bb91766..1927c9600 100644
--- a/hw/scsi/virtio-scsi-dataplane.c
+++ b/hw/scsi/virtio-scsi-dataplane.c
@@ -22,6 +22,12 @@
 #include "hw/virtio/virtio-access.h"
 
 /* Context: QEMU global mutex held */
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|1067| <<virtio_scsi_device_realize>> virtio_scsi_dataplane_setup(s, errp);
+ *
+ * 核心思想是设置VirtIOSCSI->ctx (类型struct AioContext *)
+ */
 void virtio_scsi_dataplane_setup(VirtIOSCSI *s, Error **errp)
 {
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(s);
@@ -40,15 +46,31 @@ void virtio_scsi_dataplane_setup(VirtIOSCSI *s, Error **errp)
             error_setg(errp, "ioeventfd is required for iothread");
             return;
         }
+        /*
+         * struct VirtIOSCSI:
+         * -> VirtIOSCSICommon parent_obj;
+         *    -> VirtIODevice parent_obj;
+	 * -> AioContext *ctx;
+         */
         s->ctx = iothread_get_aio_context(vs->conf.iothread);
     } else {
         if (!virtio_device_ioeventfd_enabled(vdev)) {
             return;
         }
+        /*
+	 * 返回qemu_aio_context
+	 * static AioContext *qemu_aio_context;
+	 */
         s->ctx = qemu_get_aio_context();
     }
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi-dataplane.c|130| <<virtio_scsi_dataplane_start>> rc = virtio_scsi_set_host_notifier(s, vs->ctrl_vq, 0);
+ *   - hw/scsi/virtio-scsi-dataplane.c|136| <<virtio_scsi_dataplane_start>> rc = virtio_scsi_set_host_notifier(s, vs->event_vq, 1);
+ *   - hw/scsi/virtio-scsi-dataplane.c|144| <<virtio_scsi_dataplane_start>> rc = virtio_scsi_set_host_notifier(s, vs->cmd_vqs[i], i + 2);
+ */
 static int virtio_scsi_set_host_notifier(VirtIOSCSI *s, VirtQueue *vq, int n)
 {
     BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));
@@ -59,6 +81,18 @@ static int virtio_scsi_set_host_notifier(VirtIOSCSI *s, VirtQueue *vq, int n)
     if (rc != 0) {
         fprintf(stderr, "virtio-scsi: Failed to set host notifier (%d)\n",
                 rc);
+        /*
+         * 在以下设置VirtIOSCSI->dataplane_fenced:
+         *   - hw/scsi/virtio-scsi-dataplane.c|62| <<virtio_scsi_set_host_notifier>> s->dataplane_fenced = true;
+         *   - hw/scsi/virtio-scsi-dataplane.c|177| <<virtio_scsi_dataplane_start>> s->dataplane_fenced = true;
+         *   - hw/scsi/virtio-scsi-dataplane.c|198| <<virtio_scsi_dataplane_stop>> s->dataplane_fenced = false;
+         * 在以下使用VirtIOSCSI->dataplane_fenced:
+         *   - hw/scsi/virtio-scsi-dataplane.c|100| <<virtio_scsi_dataplane_start>> s->dataplane_fenced) {
+         *   - hw/scsi/virtio-scsi-dataplane.c|197| <<virtio_scsi_dataplane_stop>> if (s->dataplane_fenced) {
+         *   - hw/scsi/virtio-scsi.c|113| <<virtio_scsi_complete_req>> if (s->dataplane_started && !s->dataplane_fenced) {
+         *   - hw/scsi/virtio-scsi.c|524| <<virtio_scsi_defer_to_dataplane>> return !s->dataplane_fenced;
+         *   - hw/scsi/virtio-scsi.c|940| <<virtio_scsi_hotplug>> if (s->ctx && !s->dataplane_fenced) {
+	 */
         s->dataplane_fenced = true;
         return rc;
     }
@@ -67,6 +101,10 @@ static int virtio_scsi_set_host_notifier(VirtIOSCSI *s, VirtQueue *vq, int n)
 }
 
 /* Context: BH in IOThread */
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi-dataplane.c|249| <<virtio_scsi_dataplane_stop>> aio_wait_bh_oneshot(s->ctx, virtio_scsi_dataplane_stop_bh, s);
+ */
 static void virtio_scsi_dataplane_stop_bh(void *opaque)
 {
     VirtIOSCSI *s = opaque;
@@ -81,14 +119,28 @@ static void virtio_scsi_dataplane_stop_bh(void *opaque)
 }
 
 /* Context: QEMU global mutex held */
+/*
+ * 在以下设置VirtioDeviceClass->start_ioeventfd:
+ *   - hw/scsi/virtio-scsi.c|1146| <<virtio_scsi_class_init>> vdc->start_ioeventfd = virtio_scsi_dataplane_start;
+ */
 int virtio_scsi_dataplane_start(VirtIODevice *vdev)
 {
     int i;
     int rc;
     int vq_init_count = 0;
+    /*
+     * VirtIODevice *vdev:
+     * -> DeviceState parent_obj;
+     *    -> BusState *parent_bus;
+     */
     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
     VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(vdev);
+    /*
+     * struct VirtIOSCSI:
+     * -> VirtIOSCSICommon parent_obj;
+     *    -> VirtIODevice parent_obj;
+     */
     VirtIOSCSI *s = VIRTIO_SCSI(vdev);
 
     if (s->dataplane_started ||
@@ -100,6 +152,12 @@ int virtio_scsi_dataplane_start(VirtIODevice *vdev)
     s->dataplane_starting = true;
 
     /* Set up guest notifier (irq) */
+    /*
+     * 在以下设置VirtioBusClass->set_guest_notifiers:
+     *   - hw/s390x/virtio-ccw.c|1276| <<virtio_ccw_bus_class_init>> k->set_guest_notifiers = virtio_ccw_set_guest_notifiers;
+     *   - hw/virtio/virtio-mmio.c|839| <<virtio_mmio_bus_class_init>> k->set_guest_notifiers = virtio_mmio_set_guest_notifiers;
+     *   - hw/virtio/virtio-pci.c|2240| <<virtio_pci_bus_class_init>> k->set_guest_notifiers = virtio_pci_set_guest_notifiers;
+     */
     rc = k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, true);
     if (rc != 0) {
         error_report("virtio-scsi: Failed to set guest notifiers (%d), "
@@ -168,6 +226,12 @@ fail_host_notifiers:
     for (i = 0; i < vq_init_count; i++) {
         virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
     }
+    /*
+     * 在以下设置VirtioBusClass->set_guest_notifiers:
+     *   - hw/s390x/virtio-ccw.c|1276| <<virtio_ccw_bus_class_init>> k->set_guest_notifiers = virtio_ccw_set_guest_notifiers;
+     *   - hw/virtio/virtio-mmio.c|839| <<virtio_mmio_bus_class_init>> k->set_guest_notifiers = virtio_mmio_set_guest_notifiers;
+     *   - hw/virtio/virtio-pci.c|2240| <<virtio_pci_bus_class_init>> k->set_guest_notifiers = virtio_pci_set_guest_notifiers;
+     */
     k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, false);
 fail_guest_notifiers:
     s->dataplane_fenced = true;
@@ -224,6 +288,12 @@ void virtio_scsi_dataplane_stop(VirtIODevice *vdev)
     }
 
     /* Clean up guest notifier (irq) */
+    /*
+     * 在以下设置VirtioBusClass->set_guest_notifiers:
+     *   - hw/s390x/virtio-ccw.c|1276| <<virtio_ccw_bus_class_init>> k->set_guest_notifiers = virtio_ccw_set_guest_notifiers;
+     *   - hw/virtio/virtio-mmio.c|839| <<virtio_mmio_bus_class_init>> k->set_guest_notifiers = virtio_mmio_set_guest_notifiers;
+     *   - hw/virtio/virtio-pci.c|2240| <<virtio_pci_bus_class_init>> k->set_guest_notifiers = virtio_pci_set_guest_notifiers;
+     */
     k->set_guest_notifiers(qbus->parent, vs->conf.num_queues + 2, false);
     s->dataplane_stopping = false;
     s->dataplane_started = false;
diff --git a/hw/scsi/virtio-scsi.c b/hw/scsi/virtio-scsi.c
index 4141dddd5..5fcfb56ea 100644
--- a/hw/scsi/virtio-scsi.c
+++ b/hw/scsi/virtio-scsi.c
@@ -838,6 +838,13 @@ static void virtio_scsi_reset(VirtIODevice *vdev)
     s->events_dropped = false;
 }
 
+/*
+ * called by:
+ *   - hw/scsi/virtio-scsi.c|893| <<virtio_scsi_handle_event_vq>> virtio_scsi_push_event(s, NULL, VIRTIO_SCSI_T_NO_EVENT, 0);
+ *   - hw/scsi/virtio-scsi.c|918| <<virtio_scsi_change>> virtio_scsi_push_event(s, dev, VIRTIO_SCSI_T_PARAM_CHANGE,
+ *   - hw/scsi/virtio-scsi.c|955| <<virtio_scsi_hotplug>> virtio_scsi_push_event(s, sd,
+ *   - hw/scsi/virtio-scsi.c|972| <<virtio_scsi_hotunplug>> virtio_scsi_push_event(s, sd,
+ */
 static void virtio_scsi_push_event(VirtIOSCSI *s, SCSIDevice *dev,
                                    uint32_t event, uint32_t reason)
 {
@@ -928,6 +935,10 @@ static void virtio_scsi_pre_hotplug(HotplugHandler *hotplug_dev,
     sd->hba_supports_iothread = true;
 }
 
+/*
+ * 在以下使用virtio_scsi_hotplug():
+ *   - hw/scsi/virtio-scsi.c|1149| <<virtio_scsi_class_init>> hc->plug = virtio_scsi_hotplug;
+ */
 static void virtio_scsi_hotplug(HotplugHandler *hotplug_dev, DeviceState *dev,
                                 Error **errp)
 {
diff --git a/hw/virtio/vhost.c b/hw/virtio/vhost.c
index f758f177b..fd4024cff 100644
--- a/hw/virtio/vhost.c
+++ b/hw/virtio/vhost.c
@@ -1282,6 +1282,10 @@ static int vhost_virtqueue_set_busyloop_timeout(struct vhost_dev *dev,
     return 0;
 }
 
+/*
+ * 在以下使用vhost_virtqueue_error_notifier():
+ *   - hw/virtio/vhost.c|1333| <<vhost_virtqueue_init>> event_notifier_set_handler(&vq->error_notifier, vhost_virtqueue_error_notifier);
+ */
 static void vhost_virtqueue_error_notifier(EventNotifier *n)
 {
     struct vhost_virtqueue *vq = container_of(n, struct vhost_virtqueue,
@@ -1598,12 +1602,34 @@ void vhost_virtqueue_mask(struct vhost_dev *hdev, VirtIODevice *vdev, int n,
     }
 }
 
+/*
+ * 在以下使用vhost_get_features():
+ *   - hw/block/vhost-user-blk.c|272| <<vhost_user_blk_get_features>> return vhost_get_features(&s->dev, user_feature_bits, features);
+ *   - hw/net/vhost_net.c|114| <<vhost_net_get_features>> return vhost_get_features(&net->dev, vhost_net_get_feature_bits(net),
+ *   - hw/scsi/vhost-scsi-common.c|136| <<vhost_scsi_common_get_features>> return vhost_get_features(&vsc->dev, vsc->feature_bits, features);
+ *   - hw/virtio/vhost-user-fs.c|148| <<vuf_get_features>> return vhost_get_features(&fs->vhost_dev, user_feature_bits, features);
+ *   - hw/virtio/vhost-user-i2c.c|119| <<vu_i2c_get_features>> return vhost_get_features(&i2c->vhost_dev, feature_bits, requested_features);
+ *   - hw/virtio/vhost-user-vsock.c|84| <<vuv_get_features>> features = vhost_get_features(&vvc->vhost_dev, user_feature_bits, features);
+ *   - hw/virtio/vhost-vsock-common.c|35| <<vhost_vsock_common_get_features>> features = vhost_get_features(&vvc->vhost_dev, feature_bits, features);
+ *   - hw/virtio/vhost.c|1378| <<vhost_dev_init>> r = hdev->vhost_ops->vhost_get_features(hdev, &features);
+ */
 uint64_t vhost_get_features(struct vhost_dev *hdev, const int *feature_bits,
                             uint64_t features)
 {
+    /*
+     * feature_bits是一个地址
+     * *bit就是一个值, value
+     */
     const int *bit = feature_bits;
+    /*
+     * 一直到*bit这个value不等于0xff ...
+     */
     while (*bit != VHOST_INVALID_FEATURE_BIT) {
         uint64_t bit_mask = (1ULL << *bit);
+        /*
+	 * #define VIRTIO_F_VERSION_1 32
+	 * hex is 0x20
+	 */
         if (!(hdev->features & bit_mask)) {
             features &= ~bit_mask;
         }
diff --git a/hw/virtio/virtio-bus.c b/hw/virtio/virtio-bus.c
index 896feb37a..a3310b616 100644
--- a/hw/virtio/virtio-bus.c
+++ b/hw/virtio/virtio-bus.c
@@ -40,6 +40,10 @@ do { printf("virtio_bus: " fmt , ## __VA_ARGS__); } while (0)
 #endif
 
 /* A VirtIODevice is being plugged */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|3763| <<virtio_device_realize>> virtio_bus_device_plugged(vdev, &err);
+ */
 void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
 {
     DeviceState *qdev = DEVICE(vdev);
@@ -53,6 +57,10 @@ void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
 
     DPRINTF("%s: plug device.\n", qbus->name);
 
+    /*
+     * virtio_pci_pre_plugged()
+     * 根据是否modern为vdev->host_features添加VIRTIO_F_VERSION_1
+     */
     if (klass->pre_plugged != NULL) {
         klass->pre_plugged(qbus->parent, &local_err);
         if (local_err) {
@@ -63,6 +71,13 @@ void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
 
     /* Get the features of the plugged device. */
     assert(vdc->get_features != NULL);
+    /*
+     * 一些例子:
+     *   - hw/net/virtio-net.c|3778| <<virtio_net_class_init>> vdc->get_features = virtio_net_get_features;
+     *   - hw/scsi/vhost-scsi.c|314| <<vhost_scsi_class_init>> vdc->get_features = vhost_scsi_common_get_features;
+     *   - hw/scsi/vhost-user-scsi.c|204| <<vhost_user_scsi_class_init>> vdc->get_features = vhost_scsi_common_get_features;
+     *   - hw/scsi/virtio-scsi.c|1155| <<virtio_scsi_class_init>> vdc->get_features = virtio_scsi_get_features;
+     */
     vdev->host_features = vdc->get_features(vdev, vdev->host_features,
                                             &local_err);
     if (local_err) {
@@ -70,6 +85,11 @@ void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
         return;
     }
 
+    /*
+     * 在以下:
+     *   - hw/s390x/virtio-ccw.c|1282| <<virtio_ccw_bus_class_init>> k->device_plugged = virtio_ccw_device_plugged;
+     *   - hw/virtio/virtio-pci.c|2252| <<virtio_pci_bus_class_init>> k->device_plugged = virtio_pci_device_plugged;
+     */
     if (klass->device_plugged != NULL) {
         klass->device_plugged(qbus->parent, &local_err);
     }
@@ -99,6 +119,12 @@ void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
 }
 
 /* Reset the virtio_bus */
+/*
+ * called by:
+ *   - hw/s390x/virtio-ccw.c|256| <<virtio_ccw_reset_virtio>> virtio_bus_reset(&dev->bus);
+ *   - hw/virtio/virtio-mmio.c|75| <<virtio_mmio_soft_reset>> virtio_bus_reset(&proxy->bus);
+ *   - hw/virtio/virtio-pci.c|1979| <<virtio_pci_reset>> virtio_bus_reset(bus);
+ */
 void virtio_bus_reset(VirtioBusState *bus)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -111,6 +137,10 @@ void virtio_bus_reset(VirtioBusState *bus)
 }
 
 /* A VirtIODevice is being unplugged */
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|3781| <<virtio_device_unrealize>> virtio_bus_device_unplugged(vdev);
+ */
 void virtio_bus_device_unplugged(VirtIODevice *vdev)
 {
     DeviceState *qdev = DEVICE(vdev);
@@ -273,6 +303,22 @@ bool virtio_bus_ioeventfd_enabled(VirtioBusState *bus)
  * This function switches ioeventfd on/off in the device.
  * The caller must set or clear the handlers for the EventNotifier.
  */
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|198| <<virtio_blk_data_plane_start>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, true);
+ *   - hw/block/dataplane/virtio-blk.c|204| <<virtio_blk_data_plane_start>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/block/dataplane/virtio-blk.c|264| <<virtio_blk_data_plane_start>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/block/dataplane/virtio-blk.c|341| <<virtio_blk_data_plane_stop>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|58| <<virtio_scsi_set_host_notifier>> rc = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), n, true);
+ *   - hw/scsi/virtio-scsi-dataplane.c|173| <<virtio_scsi_dataplane_start>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/scsi/virtio-scsi-dataplane.c|227| <<virtio_scsi_dataplane_stop>> virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), i, false);
+ *   - hw/virtio/vhost.c|1520| <<vhost_dev_enable_notifiers>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i,
+ *   - hw/virtio/vhost.c|1531| <<vhost_dev_enable_notifiers>> e = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i,
+ *   - hw/virtio/vhost.c|1555| <<vhost_dev_disable_notifiers>> r = virtio_bus_set_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i,
+ *   - hw/virtio/virtio.c|3769| <<virtio_device_start_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, true);
+ *   - hw/virtio/virtio.c|3798| <<virtio_device_start_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, false);
+ *   - hw/virtio/virtio.c|3841| <<virtio_device_stop_ioeventfd_impl>> r = virtio_bus_set_host_notifier(qbus, n, false);
+ */
 int virtio_bus_set_host_notifier(VirtioBusState *bus, int n, bool assign)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
@@ -287,12 +333,33 @@ int virtio_bus_set_host_notifier(VirtioBusState *bus, int n, bool assign)
     }
 
     if (assign) {
+        /*
+	 * EventNotifier *notifier
+	 * -> int rfd;
+	 * -> int wfd;
+	 * -> bool initialized;
+	 */
         r = event_notifier_init(notifier, 1);
         if (r < 0) {
             error_report("%s: unable to init event notifier: %s (%d)",
                          __func__, strerror(-r), r);
             return r;
         }
+        /*
+	 * 在以下设置VirtioBusClass->ioeventfd_assign:
+         *   - hw/s390x/virtio-ccw.c|1285| <<virtio_ccw_bus_class_init>> k->ioeventfd_assign = virtio_ccw_ioeventfd_assign;
+         *   - hw/virtio/virtio-mmio.c|841| <<virtio_mmio_bus_class_init>> k->ioeventfd_assign = virtio_mmio_ioeventfd_assign;
+         *   - hw/virtio/virtio-pci.c|2229| <<virtio_pci_bus_class_init>> k->ioeventfd_assign = virtio_pci_ioeventfd_assign;
+         * 在以下使用VirtioBusClass->ioeventfd_assign:
+         *   - hw/block/dataplane/virtio-blk.c|95| <<virtio_blk_data_plane_create>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+         *   - hw/scsi/virtio-scsi-dataplane.c|39| <<virtio_scsi_dataplane_setup>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+         *   - hw/virtio/virtio-bus.c|194| <<virtio_bus_grab_ioeventfd>> if (!k->ioeventfd_assign) {
+         *   - hw/virtio/virtio-bus.c|227| <<virtio_bus_start_ioeventfd>> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
+         *   - hw/virtio/virtio-bus.c|269| <<virtio_bus_ioeventfd_enabled>> return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
+         *   - hw/virtio/virtio-bus.c|301| <<virtio_bus_set_host_notifier>> if (!k->ioeventfd_assign) {
+         *   - hw/virtio/virtio-bus.c|312| <<virtio_bus_set_host_notifier>> r = k->ioeventfd_assign(proxy, notifier, n, true);
+         *   - hw/virtio/virtio-bus.c|318| <<virtio_bus_set_host_notifier>> k->ioeventfd_assign(proxy, notifier, n, false);
+         */
         r = k->ioeventfd_assign(proxy, notifier, n, true);
         if (r < 0) {
             error_report("%s: unable to assign ioeventfd: %d", __func__, r);
@@ -309,6 +376,21 @@ int virtio_bus_set_host_notifier(VirtioBusState *bus, int n, bool assign)
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|214| <<virtio_blk_data_plane_start>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), j);
+ *   - hw/block/dataplane/virtio-blk.c|270| <<virtio_blk_data_plane_start>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/block/dataplane/virtio-blk.c|351| <<virtio_blk_data_plane_stop>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/scsi/virtio-scsi-dataplane.c|217| <<virtio_scsi_dataplane_start>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/scsi/virtio-scsi-dataplane.c|271| <<virtio_scsi_dataplane_stop>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), i);
+ *   - hw/virtio/vhost.c|1537| <<vhost_dev_enable_notifiers>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i);
+ *   - hw/virtio/vhost.c|1561| <<vhost_dev_disable_notifiers>> virtio_bus_cleanup_host_notifier(VIRTIO_BUS(qbus), hdev->vq_index + i);
+ *   - hw/virtio/virtio-bus.c|315| <<virtio_bus_set_host_notifier>> virtio_bus_cleanup_host_notifier(bus, n);
+ *   - hw/virtio/virtio.c|3818| <<virtio_device_start_ioeventfd_impl>> virtio_bus_cleanup_host_notifier(qbus, i);
+ *   - hw/virtio/virtio.c|3861| <<virtio_device_stop_ioeventfd_impl>> virtio_bus_cleanup_host_notifier(qbus, n);
+ *
+ * Tell the bus that the ioeventfd handler is no longer required.
+ */
 void virtio_bus_cleanup_host_notifier(VirtioBusState *bus, int n)
 {
     VirtIODevice *vdev = virtio_bus_get_device(bus);
diff --git a/hw/virtio/virtio-pci.c b/hw/virtio/virtio-pci.c
index a50c5a57d..516a705ab 100644
--- a/hw/virtio/virtio-pci.c
+++ b/hw/virtio/virtio-pci.c
@@ -228,6 +228,21 @@ static inline int virtio_pci_queue_mem_mult(struct VirtIOPCIProxy *proxy)
         QEMU_VIRTIO_PCI_QUEUE_MEM_MULT : 4;
 }
 
+/*
+ * 在以下设置VirtioBusClass->ioeventfd_assign:
+ *   - hw/s390x/virtio-ccw.c|1285| <<virtio_ccw_bus_class_init>> k->ioeventfd_assign = virtio_ccw_ioeventfd_assign;
+ *   - hw/virtio/virtio-mmio.c|841| <<virtio_mmio_bus_class_init>> k->ioeventfd_assign = virtio_mmio_ioeventfd_assign;
+ *   - hw/virtio/virtio-pci.c|2229| <<virtio_pci_bus_class_init>> k->ioeventfd_assign = virtio_pci_ioeventfd_assign;
+ * 在以下使用VirtioBusClass->ioeventfd_assign:
+ *   - hw/block/dataplane/virtio-blk.c|95| <<virtio_blk_data_plane_create>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+ *   - hw/scsi/virtio-scsi-dataplane.c|39| <<virtio_scsi_dataplane_setup>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+ *   - hw/virtio/virtio-bus.c|194| <<virtio_bus_grab_ioeventfd>> if (!k->ioeventfd_assign) {
+ *   - hw/virtio/virtio-bus.c|227| <<virtio_bus_start_ioeventfd>> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
+ *   - hw/virtio/virtio-bus.c|269| <<virtio_bus_ioeventfd_enabled>> return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
+ *   - hw/virtio/virtio-bus.c|301| <<virtio_bus_set_host_notifier>> if (!k->ioeventfd_assign) {
+ *   - hw/virtio/virtio-bus.c|312| <<virtio_bus_set_host_notifier>> r = k->ioeventfd_assign(proxy, notifier, n, true);
+ *   - hw/virtio/virtio-bus.c|318| <<virtio_bus_set_host_notifier>> k->ioeventfd_assign(proxy, notifier, n, false);
+ */
 static int virtio_pci_ioeventfd_assign(DeviceState *d, EventNotifier *notifier,
                                        int n, bool assign)
 {
@@ -251,6 +266,10 @@ static int virtio_pci_ioeventfd_assign(DeviceState *d, EventNotifier *notifier,
                 memory_region_add_eventfd(modern_mr, modern_addr, 0,
                                           false, n, notifier);
             } else {
+                /*
+		 * 核心思想就是制作MemoryRegionIoeventfd给MemoryRegion->ioeventfds[i]
+                 * 可能会g_realloc()
+		 */
                 memory_region_add_eventfd(modern_mr, modern_addr, 2,
                                           false, n, notifier);
             }
@@ -1189,6 +1208,14 @@ static uint64_t virtio_pci_common_read(void *opaque, hwaddr addr,
         if (proxy->dfselect <= 1) {
             VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(vdev);
 
+            /*
+	     * 在以下使用ViriioDevice->legacy_features:
+             *   - hw/net/virtio-net.c|3785| <<virtio_net_class_init>> vdc->legacy_features |= (0x1 << VIRTIO_NET_F_GSO);
+             *   - hw/s390x/virtio-ccw.c|389| <<virtio_ccw_cb>> (vdev->host_features & ~vdc->legacy_features);
+             *   - hw/virtio/virtio-mmio.c|170| <<virtio_mmio_read>> return (vdev->host_features & ~vdc->legacy_features)
+             *   - hw/virtio/virtio-pci.c|1211| <<virtio_pci_common_read>> val = (vdev->host_features & ~vdc->legacy_features) >>
+             *   - hw/virtio/virtio.c|3959| <<virtio_device_class_init>> vdc->legacy_features |= VIRTIO_LEGACY_FEATURES;
+	     */
             val = (vdev->host_features & ~vdc->legacy_features) >>
                 (32 * proxy->dfselect);
         }
@@ -1477,6 +1504,10 @@ static void virtio_pci_device_write(void *opaque, hwaddr addr,
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1744| <<virtio_pci_device_plugged>> virtio_pci_modern_regions_init(proxy, vdev->name);
+ */
 static void virtio_pci_modern_regions_init(VirtIOPCIProxy *proxy,
                                            const char *vdev_name)
 {
@@ -1609,6 +1640,10 @@ static void virtio_pci_modern_io_region_unmap(VirtIOPCIProxy *proxy,
                                 &region->mr);
 }
 
+/*
+ * 在以下使用virtio_pci_pre_plugged():
+ *   - hw/virtio/virtio-pci.c|2259| <<virtio_pci_bus_class_init>> k->pre_plugged = virtio_pci_pre_plugged;
+ */
 static void virtio_pci_pre_plugged(DeviceState *d, Error **errp)
 {
     VirtIOPCIProxy *proxy = VIRTIO_PCI(d);
@@ -1622,6 +1657,13 @@ static void virtio_pci_pre_plugged(DeviceState *d, Error **errp)
 }
 
 /* This is called by virtio-bus just after the device is plugged. */
+/*
+ * called by:
+ *   - hw/virtio/virtio-bus.c|93| <<virtio_bus_device_plugged>> klass->device_plugged(qbus->parent, &local_err);
+ *
+ * 在以下使用virtio_pci_device_plugged():
+ *   - hw/virtio/virtio-pci.c|2252| <<virtio_pci_bus_class_init>> k->device_plugged = virtio_pci_device_plugged;
+ */
 static void virtio_pci_device_plugged(DeviceState *d, Error **errp)
 {
     VirtIOPCIProxy *proxy = VIRTIO_PCI(d);
@@ -1650,6 +1692,15 @@ static void virtio_pci_device_plugged(DeviceState *d, Error **errp)
         }
     }
 
+    /*
+     * 在以下使用VirtIOPCIProxy->disable_modern:
+     *   - hw/virtio/virtio-pci.c|2078| <<global>> DEFINE_PROP_BOOL("disable-modern", VirtIOPCIProxy, disable_modern, false),
+     *   - hw/virtio/virtio-pci.c|2102| <<virtio_pci_transitional_instance_init>> proxy->disable_modern = false;
+     *   - hw/virtio/virtio-pci.c|2110| <<virtio_pci_non_transitional_instance_init>> proxy->disable_modern = false;
+     *   - include/hw/virtio/virtio-pci.h|163| <<virtio_pci_modern>> return !proxy->disable_modern;
+     *   - include/hw/virtio/virtio-pci.h|173| <<virtio_pci_force_virtio_1>> proxy->disable_modern = false;
+     *   - include/hw/virtio/virtio-pci.h|179| <<virtio_pci_disable_modern>> proxy->disable_modern = true;
+     */
     modern = virtio_pci_modern(proxy);
 
     config = proxy->pci_dev.config;
@@ -2195,6 +2246,10 @@ unsigned virtio_pci_optimal_num_queues(unsigned fixed_queues)
 
 /* virtio-pci-bus */
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1978| <<virtio_pci_realize>> virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);
+ */
 static void virtio_pci_bus_new(VirtioBusState *bus, size_t bus_size,
                                VirtIOPCIProxy *dev)
 {
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index 5d607aeaa..2ae295558 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -101,10 +101,34 @@ struct VirtQueue
 
     /* Next head to pop */
     uint16_t last_avail_idx;
+    /*
+     * 在以下使用VirtQueue->last_avail_wrap_counter:
+     *   - w/virtio/virtio.c|2697| <<global>> VMSTATE_BOOL(last_avail_wrap_counter, struct VirtQueue),
+     *   - hw/virtio/virtio.c|694| <<virtio_queue_packed_empty_rcu>> return !is_desc_avail(desc.flags, vq->last_avail_wrap_counter);
+     *   - hw/virtio/virtio.c|762| <<virtqueue_packed_rewind>> vq->last_avail_wrap_counter ^= 1;
+     *   - hw/virtio/virtio.c|1182| <<virtqueue_packed_get_avail_bytes>> wrap_counter = vq->last_avail_wrap_counter;
+     *   - hw/virtio/virtio.c|1706| <<virtqueue_packed_pop>> vq->last_avail_wrap_counter ^= 1;
+     *   - hw/virtio/virtio.c|1710| <<virtqueue_packed_pop>> vq->shadow_avail_wrap_counter = vq->last_avail_wrap_counter;
+     *   - hw/virtio/virtio.c|1764| <<virtqueue_packed_drop_all>> if (!is_desc_avail(desc.flags, vq->last_avail_wrap_counter)) {
+     *   - hw/virtio/virtio.c|1782| <<virtqueue_packed_drop_all>> vq->last_avail_wrap_counter ^= 1;
+     *   - hw/virtio/virtio.c|2059| <<virtio_reset>> vdev->vq[i].last_avail_wrap_counter = true;
+     *   - hw/virtio/virtio.c|3174| <<virtio_load>> vdev->vq[i].last_avail_wrap_counter;
+     *   - hw/virtio/virtio.c|3400| <<virtio_queue_packed_get_last_avail_idx>> avail |= ((uint16_t)vdev->vq[n].last_avail_wrap_counter) << 15;
+     *   - hw/virtio/virtio.c|3429| <<virtio_queue_packed_set_last_avail_idx>> vq->last_avail_wrap_counter =
+     */
     bool last_avail_wrap_counter;
 
     /* Last avail_idx read from VQ. */
     uint16_t shadow_avail_idx;
+    /*
+     * 在以下使用VirtQueue->shadow_avail_wrap_counter:
+     *   - hw/virtio/virtio.c|523| <<virtio_queue_packed_set_notification>> off_wrap = vq->shadow_avail_idx | vq->shadow_avail_wrap_counter << 15;
+     *   - hw/virtio/virtio.c|1278| <<virtqueue_packed_get_avail_bytes>> vq->shadow_avail_wrap_counter = wrap_counter;
+     *   - hw/virtio/virtio.c|1725| <<virtqueue_packed_pop>> vq->shadow_avail_wrap_counter = vq->last_avail_wrap_counter;
+     *   - hw/virtio/virtio.c|2075| <<virtio_reset>> vdev->vq[i].shadow_avail_wrap_counter = true;
+     *   - hw/virtio/virtio.c|3188| <<virtio_load>> vdev->vq[i].shadow_avail_wrap_counter = vdev->vq[i].last_avail_wrap_counter;
+     *   - hw/virtio/virtio.c|3445| <<virtio_queue_packed_set_last_avail_idx>> vq->shadow_avail_wrap_counter = !!(idx & 0x8000);
+     */
     bool shadow_avail_wrap_counter;
 
     uint16_t used_idx;
@@ -488,6 +512,10 @@ static void virtio_queue_split_set_notification(VirtQueue *vq, int enable)
     }
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|562| <<virtio_queue_set_notification>> virtio_queue_packed_set_notification(vq, enable);
+ */
 static void virtio_queue_packed_set_notification(VirtQueue *vq, int enable)
 {
     uint16_t off_wrap;
@@ -502,6 +530,10 @@ static void virtio_queue_packed_set_notification(VirtQueue *vq, int enable)
 
     vring_packed_event_read(vq->vdev, &caches->used, &e);
 
+    /*
+     * disable: 设置VRING_PACKED_EVENT_FLAG_DISABLE
+     * enable:  设置VRING_PACKED_EVENT_FLAG_DESC或者VRING_PACKED_EVENT_FLAG_ENABLE
+     */
     if (!enable) {
         e.flags = VRING_PACKED_EVENT_FLAG_DISABLE;
     } else if (virtio_vdev_has_feature(vq->vdev, VIRTIO_RING_F_EVENT_IDX)) {
@@ -526,6 +558,35 @@ bool virtio_queue_get_notification(VirtQueue *vq)
     return vq->notification;
 }
 
+/*
+ * called by:
+ *   - hw/block/virtio-blk.c|782| <<virtio_blk_handle_vq>> virtio_queue_set_notification(vq, 0);
+ *   - hw/block/virtio-blk.c|794| <<virtio_blk_handle_vq>> virtio_queue_set_notification(vq, 1);
+ *   - hw/net/virtio-net.c|414| <<virtio_net_set_status>> virtio_queue_set_notification(q->tx_vq, 1);
+ *   - hw/net/virtio-net.c|1542| <<virtio_net_has_buffers>> virtio_queue_set_notification(q->rx_vq, 1);
+ *   - hw/net/virtio-net.c|1555| <<virtio_net_has_buffers>> virtio_queue_set_notification(q->rx_vq, 0);
+ *   - hw/net/virtio-net.c|2535| <<virtio_net_tx_complete>> virtio_queue_set_notification(q->tx_vq, 1);
+ *   - hw/net/virtio-net.c|2552| <<virtio_net_flush_tx>> virtio_queue_set_notification(q->tx_vq, 0);
+ *   - hw/net/virtio-net.c|2618| <<virtio_net_flush_tx>> virtio_queue_set_notification(q->tx_vq, 0);
+ *   - hw/net/virtio-net.c|2652| <<virtio_net_handle_tx_timer>> virtio_queue_set_notification(vq, 1);
+ *   - hw/net/virtio-net.c|2662| <<virtio_net_handle_tx_timer>> virtio_queue_set_notification(vq, 0);
+ *   - hw/net/virtio-net.c|2684| <<virtio_net_handle_tx_bh>> virtio_queue_set_notification(vq, 0);
+ *   - hw/net/virtio-net.c|2707| <<virtio_net_tx_timer>> virtio_queue_set_notification(q->tx_vq, 1);
+ *   - hw/net/virtio-net.c|2749| <<virtio_net_tx_bh>> virtio_queue_set_notification(q->tx_vq, 1);
+ *   - hw/net/virtio-net.c|2754| <<virtio_net_tx_bh>> virtio_queue_set_notification(q->tx_vq, 0);
+ *   - hw/scsi/virtio-scsi.c|735| <<virtio_scsi_handle_cmd_vq>> virtio_queue_set_notification(vq, 0);
+ *   - hw/scsi/virtio-scsi.c|756| <<virtio_scsi_handle_cmd_vq>> virtio_queue_set_notification(vq, 1);
+ *   - hw/virtio/vhost-shadow-virtqueue.c|293| <<vhost_handle_guest_kick>> virtio_queue_set_notification(svq->vq, false);
+ *   - hw/virtio/vhost-shadow-virtqueue.c|335| <<vhost_handle_guest_kick>> virtio_queue_set_notification(svq->vq, true);
+ *   - hw/virtio/virtio-balloon.c|563| <<virtio_ballloon_get_free_page_hints>> virtio_queue_set_notification(vq, 0);
+ *   - hw/virtio/virtio-balloon.c|573| <<virtio_ballloon_get_free_page_hints>> virtio_queue_set_notification(vq, 1);
+ *   - hw/virtio/virtio-crypto.c|912| <<virtio_crypto_dataq_bh>> virtio_queue_set_notification(q->dataq, 1);
+ *   - hw/virtio/virtio-crypto.c|919| <<virtio_crypto_dataq_bh>> virtio_queue_set_notification(q->dataq, 0);
+ *   - hw/virtio/virtio-crypto.c|934| <<virtio_crypto_handle_dataq_bh>> virtio_queue_set_notification(vq, 0);
+ *   - hw/virtio/virtio.c|1782| <<virtqueue_packed_drop_all>> virtio_queue_set_notification(vq, 0);
+ *   - hw/virtio/virtio.c|3578| <<virtio_queue_host_notifier_aio_poll_begin>> virtio_queue_set_notification(vq, 0);
+ *   - hw/virtio/virtio.c|3601| <<virtio_queue_host_notifier_aio_poll_end>> virtio_queue_set_notification(vq, 1);
+ */
 void virtio_queue_set_notification(VirtQueue *vq, int enable)
 {
     vq->notification = enable;
@@ -1585,6 +1646,10 @@ err_undo_map:
     goto done;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio.c|1745| <<virtqueue_pop>> return virtqueue_packed_pop(vq, sz);
+ */
 static void *virtqueue_packed_pop(VirtQueue *vq, size_t sz)
 {
     unsigned int i, max;
@@ -3597,6 +3662,13 @@ void virtio_queue_aio_attach_host_notifier_no_poll(VirtQueue *vq, AioContext *ct
                            NULL, NULL);
 }
 
+/*
+ * called by:
+ *   - hw/block/dataplane/virtio-blk.c|298| <<virtio_blk_data_plane_stop_bh>> virtio_queue_aio_detach_host_notifier(vq, s->ctx);
+ *   - hw/scsi/virtio-scsi-dataplane.c|76| <<virtio_scsi_dataplane_stop_bh>> virtio_queue_aio_detach_host_notifier(vs->ctrl_vq, s->ctx);
+ *   - hw/scsi/virtio-scsi-dataplane.c|77| <<virtio_scsi_dataplane_stop_bh>> virtio_queue_aio_detach_host_notifier(vs->event_vq, s->ctx);
+ *   - hw/scsi/virtio-scsi-dataplane.c|79| <<virtio_scsi_dataplane_stop_bh>> virtio_queue_aio_detach_host_notifier(vs->cmd_vqs[i], s->ctx);
+ */
 void virtio_queue_aio_detach_host_notifier(VirtQueue *vq, AioContext *ctx)
 {
     aio_set_event_notifier(ctx, &vq->host_notifier, true, NULL, NULL, NULL);
diff --git a/include/exec/memory.h b/include/exec/memory.h
index bfb1de8ee..d652a7d75 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -758,6 +758,25 @@ struct MemoryRegion {
     QTAILQ_ENTRY(MemoryRegion) subregions_link;
     QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;
     const char *name;
+    /*
+     * 在以下使用MemoryRegion->ioeventfd_nb:
+     *   - softmmu/memory.c|899| <<address_space_update_ioeventfds>> for (i = 0; i < fr->mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|1545| <<memory_region_dispatch_write_eventfds>> for (i = 0; i < mr->ioeventfd_nb; i++) {
+     *   - softmmu/memory.c|2565| <<memory_region_add_eventfd>> for (i = 0; i < mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|2570| <<memory_region_add_eventfd>> ++mr->ioeventfd_nb;
+     *   - softmmu/memory.c|2575| <<memory_region_add_eventfd>> sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);
+     *   - softmmu/memory.c|2581| <<memory_region_add_eventfd>> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));
+     *   - softmmu/memory.c|2628| <<memory_region_del_eventfd>> for (i = 0; i < mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|2633| <<memory_region_del_eventfd>> assert(i != mr->ioeventfd_nb);
+     *   - softmmu/memory.c|2635| <<memory_region_del_eventfd>> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb - (i+1)));
+     *   - softmmu/memory.c|2636| <<memory_region_del_eventfd>> --mr->ioeventfd_nb;
+     *   - softmmu/memory.c|2638| <<memory_region_del_eventfd>> sizeof(*mr->ioeventfds)*mr->ioeventfd_nb + 1);
+     * 在以下使用struct AddressSpace->ioeventfd_nb:
+     *   - softmmu/memory.c|878| <<address_space_update_ioeventfds>> ioeventfd_max = QEMU_ALIGN_UP(as->ioeventfd_nb, 4);
+     *   - softmmu/memory.c|921| <<address_space_update_ioeventfds>> as->ioeventfds, as->ioeventfd_nb);
+     *   - softmmu/memory.c|925| <<address_space_update_ioeventfds>> as->ioeventfd_nb = ioeventfd_nb;
+     *   - softmmu/memory.c|3126| <<address_space_init>> as->ioeventfd_nb = 0;
+     */
     unsigned ioeventfd_nb;
     MemoryRegionIoeventfd *ioeventfds;
     RamDiscardManager *rdm; /* Only for RAM */
@@ -1041,8 +1060,35 @@ struct AddressSpace {
     MemoryRegion *root;
 
     /* Accessed via RCU.  */
+    /*
+     * 在以下使用AddressSpace->current_map:
+     *   - include/exec/memory.h|1108| <<address_space_to_flatview>> return qatomic_rcu_read(&as->current_map);
+     *   - softmmu/memory.c|1144| <<address_space_set_flatview>> qatomic_rcu_set(&as->current_map, new_view);
+     *   - softmmu/memory.c|3144| <<address_space_init>> as->current_map = NULL;
+     *   - softmmu/memory.c|3158| <<do_address_space_destroy>> flatview_unref(as->current_map);
+     *   - tests/qtest/fuzz/generic_fuzz.c|294| <<get_io_address>> view = as->current_map;
+     */
     struct FlatView *current_map;
 
+    /*
+     * 在以下使用MemoryRegion->ioeventfd_nb:
+     *   - softmmu/memory.c|899| <<address_space_update_ioeventfds>> for (i = 0; i < fr->mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|1545| <<memory_region_dispatch_write_eventfds>> for (i = 0; i < mr->ioeventfd_nb; i++) {
+     *   - softmmu/memory.c|2565| <<memory_region_add_eventfd>> for (i = 0; i < mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|2570| <<memory_region_add_eventfd>> ++mr->ioeventfd_nb;
+     *   - softmmu/memory.c|2575| <<memory_region_add_eventfd>> sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);
+     *   - softmmu/memory.c|2581| <<memory_region_add_eventfd>> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));
+     *   - softmmu/memory.c|2628| <<memory_region_del_eventfd>> for (i = 0; i < mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|2633| <<memory_region_del_eventfd>> assert(i != mr->ioeventfd_nb);
+     *   - softmmu/memory.c|2635| <<memory_region_del_eventfd>> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb - (i+1)));
+     *   - softmmu/memory.c|2636| <<memory_region_del_eventfd>> --mr->ioeventfd_nb;
+     *   - softmmu/memory.c|2638| <<memory_region_del_eventfd>> sizeof(*mr->ioeventfds)*mr->ioeventfd_nb + 1);
+     * 在以下使用struct AddressSpace->ioeventfd_nb:
+     *   - softmmu/memory.c|878| <<address_space_update_ioeventfds>> ioeventfd_max = QEMU_ALIGN_UP(as->ioeventfd_nb, 4);
+     *   - softmmu/memory.c|921| <<address_space_update_ioeventfds>> as->ioeventfds, as->ioeventfd_nb);
+     *   - softmmu/memory.c|925| <<address_space_update_ioeventfds>> as->ioeventfd_nb = ioeventfd_nb;
+     *   - softmmu/memory.c|3126| <<address_space_init>> as->ioeventfd_nb = 0;
+     */
     int ioeventfd_nb;
     struct MemoryRegionIoeventfd *ioeventfds;
     QTAILQ_HEAD(, MemoryListener) listeners;
diff --git a/include/hw/core/accel-cpu.h b/include/hw/core/accel-cpu.h
index 5dbfd7995..7df34726b 100644
--- a/include/hw/core/accel-cpu.h
+++ b/include/hw/core/accel-cpu.h
@@ -20,6 +20,16 @@
  * subclasses in target/, or the accel implementation itself in accel/
  */
 
+/*
+ * 在以下使用TYPE_ACCEL_CPU:
+ *   - include/hw/core/accel-cpu.h|23| <<global>> #define TYPE_ACCEL_CPU "accel-" CPU_RESOLVING_TYPE
+ *   - accel/accel-common.c|133| <<global>> .name = TYPE_ACCEL_CPU,
+ *   - target/i386/hvf/hvf-cpu.c|87| <<global>> .parent = TYPE_ACCEL_CPU,
+ *   - target/i386/kvm/kvm-cpu.c|199| <<global>> .parent = TYPE_ACCEL_CPU,
+ *   - target/i386/tcg/tcg-cpu.c|152| <<global>> .parent = TYPE_ACCEL_CPU,
+ *   - include/hw/core/accel-cpu.h|24| <<ACCEL_CPU_NAME>> #define ACCEL_CPU_NAME(name) (name "-" TYPE_ACCEL_CPU)
+ *   - include/hw/core/accel-cpu.h|26| <<DECLARE_CLASS_CHECKERS>> DECLARE_CLASS_CHECKERS(AccelCPUClass, ACCEL_CPU, TYPE_ACCEL_CPU)
+ */
 #define TYPE_ACCEL_CPU "accel-" CPU_RESOLVING_TYPE
 #define ACCEL_CPU_NAME(name) (name "-" TYPE_ACCEL_CPU)
 typedef struct AccelCPUClass AccelCPUClass;
diff --git a/include/hw/core/cpu.h b/include/hw/core/cpu.h
index 500503da1..b871a8eea 100644
--- a/include/hw/core/cpu.h
+++ b/include/hw/core/cpu.h
@@ -353,6 +353,17 @@ struct CPUState {
     QemuMutex work_mutex;
     QSIMPLEQ_HEAD(, qemu_work_item) work_list;
 
+    /*
+     * 在以下CPUState->cpu_ases:
+     *   - softmmu/physmem.c|683| <<address_space_translate_for_iotlb>> qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);
+     *   - softmmu/physmem.c|772| <<cpu_address_space_init>> if (!cpu->cpu_ases) {
+     *   - softmmu/physmem.c|773| <<cpu_address_space_init>> cpu->cpu_ases = g_new0(CPUAddressSpace, cpu->num_ases);
+     *   - softmmu/physmem.c|776| <<cpu_address_space_init>> newas = &cpu->cpu_ases[asidx];
+     *   - softmmu/physmem.c|790| <<cpu_get_address_space>> return cpu->cpu_ases[asidx].as;
+     *   - softmmu/physmem.c|2596| <<iotlb_to_section>> CPUAddressSpace *cpuas = &cpu->cpu_ases[asidx];
+     *   - softmmu/physmem.c|3519| <<cpu_memory_rw_debug>> res = address_space_write_rom(cpu->cpu_ases[asidx].as, phys_addr,
+     *   - softmmu/physmem.c|3522| <<cpu_memory_rw_debug>> res = address_space_read(cpu->cpu_ases[asidx].as, phys_addr,
+     */
     CPUAddressSpace *cpu_ases;
     int num_ases;
     AddressSpace *as;
diff --git a/include/hw/qdev-core.h b/include/hw/qdev-core.h
index 785dd5a56..c08d75578 100644
--- a/include/hw/qdev-core.h
+++ b/include/hw/qdev-core.h
@@ -180,6 +180,19 @@ struct DeviceState {
     char *id;
     char *canonical_path;
     bool realized;
+    /*
+     * 在以下设置DeviceState->pending_deleted_event:
+     *   - hw/acpi/pcihp.c|245| <<acpi_pcihp_eject_slot>> qdev->pending_deleted_event = false;
+     *   - hw/acpi/pcihp.c|538| <<acpi_pcihp_device_unplug_request_cb>> pdev->qdev.pending_deleted_event = true;
+     *   - hw/core/qdev.c|644| <<device_set_realized>> dev->pending_deleted_event = false;
+     *   - hw/core/qdev.c|681| <<device_set_realized>> dev->pending_deleted_event = true;
+     *   - hw/pci/pcie.c|510| <<pcie_unplug_device>> dev->qdev.pending_deleted_event = false;
+     *   - hw/pci/pcie.c|567| <<pcie_cap_slot_unplug_request_cb>> dev->pending_deleted_event = true;
+     * 在以下使用DeviceState->pending_deleted_event:
+     *   - hw/core/qdev.c|798| <<device_finalize>> if (dev->pending_deleted_event) {
+     *   - hw/net/virtio-net.c|3697| <<primary_unplug_pending>> return primary ? primary->pending_deleted_event : false;
+     *   - softmmu/qdev-monitor.c|947| <<qmp_device_del>> if (dev->pending_deleted_event &&
+     */
     bool pending_deleted_event;
     int64_t pending_deleted_expires_ms;
     QDict *opts;
diff --git a/include/hw/virtio/vhost-scsi-common.h b/include/hw/virtio/vhost-scsi-common.h
index 18f115527..e681c9406 100644
--- a/include/hw/virtio/vhost-scsi-common.h
+++ b/include/hw/virtio/vhost-scsi-common.h
@@ -28,6 +28,12 @@ struct VHostSCSICommon {
     Error *migration_blocker;
 
     struct vhost_dev dev;
+    /*
+     * 在以下使用VHostSCSICommon->feature_bits:
+     *   - hw/scsi/vhost-scsi-common.c|130| <<vhost_scsi_common_get_features>> return vhost_get_features(&vsc->dev, vsc->feature_bits, features);
+     *   - hw/scsi/vhost-scsi.c|325| <<vhost_scsi_instance_init>> vsc->feature_bits = kernel_feature_bits;
+     *   - hw/scsi/vhost-user-scsi.c|215| <<vhost_user_scsi_instance_init>> vsc->feature_bits = user_feature_bits;
+     */
     const int *feature_bits;
     int32_t bootindex;
     int channel;
diff --git a/include/hw/virtio/virtio-bus.h b/include/hw/virtio/virtio-bus.h
index 7ab8c9dab..8181d3b8a 100644
--- a/include/hw/virtio/virtio-bus.h
+++ b/include/hw/virtio/virtio-bus.h
@@ -29,6 +29,15 @@
 #include "hw/virtio/virtio.h"
 #include "qom/object.h"
 
+/*
+ * 在以下使用TYPE_VIRTIO_BUS:
+ *   - hw/s390x/virtio-ccw.c|1290| <<global>> .parent = TYPE_VIRTIO_BUS,
+ *   - hw/virtio/virtio-bus.c|430| <<global>> .name = TYPE_VIRTIO_BUS,
+ *   - hw/virtio/virtio-mmio.c|851| <<global>> .parent = TYPE_VIRTIO_BUS,
+ *   - hw/virtio/virtio-pci.c|2264| <<global>> .parent = TYPE_VIRTIO_BUS,
+ *   - hw/virtio/virtio.c|3954| <<virtio_device_class_init>> dc->bus_type = TYPE_VIRTIO_BUS;
+ *   - include/hw/virtio/virtio-bus.h|36| <<DECLARE_OBJ_CHECKERS>> DECLARE_OBJ_CHECKERS(VirtioBusState, VirtioBusClass, VIRTIO_BUS, TYPE_VIRTIO_BUS)
+ */
 #define TYPE_VIRTIO_BUS "virtio-bus"
 typedef struct VirtioBusClass VirtioBusClass;
 typedef struct VirtioBusState VirtioBusState;
@@ -49,6 +58,12 @@ struct VirtioBusClass {
     int (*load_extra_state)(DeviceState *d, QEMUFile *f);
     bool (*has_extra_state)(DeviceState *d);
     bool (*query_guest_notifiers)(DeviceState *d);
+    /*
+     * 在以下设置VirtioBusClass->set_guest_notifiers:
+     *   - hw/s390x/virtio-ccw.c|1276| <<virtio_ccw_bus_class_init>> k->set_guest_notifiers = virtio_ccw_set_guest_notifiers;
+     *   - hw/virtio/virtio-mmio.c|839| <<virtio_mmio_bus_class_init>> k->set_guest_notifiers = virtio_mmio_set_guest_notifiers;
+     *   - hw/virtio/virtio-pci.c|2240| <<virtio_pci_bus_class_init>> k->set_guest_notifiers = virtio_pci_set_guest_notifiers;
+     */
     int (*set_guest_notifiers)(DeviceState *d, int nvqs, bool assign);
     int (*set_host_notifier_mr)(DeviceState *d, int n,
                                 MemoryRegion *mr, bool assign);
@@ -80,6 +95,21 @@ struct VirtioBusClass {
      * the device for queue number n. Returns an error value on
      * failure.
      */
+    /*
+     * 在以下设置VirtioBusClass->ioeventfd_assign:
+     *   - hw/s390x/virtio-ccw.c|1285| <<virtio_ccw_bus_class_init>> k->ioeventfd_assign = virtio_ccw_ioeventfd_assign;
+     *   - hw/virtio/virtio-mmio.c|841| <<virtio_mmio_bus_class_init>> k->ioeventfd_assign = virtio_mmio_ioeventfd_assign;
+     *   - hw/virtio/virtio-pci.c|2229| <<virtio_pci_bus_class_init>> k->ioeventfd_assign = virtio_pci_ioeventfd_assign;
+     * 在以下使用VirtioBusClass->ioeventfd_assign:
+     *   - hw/block/dataplane/virtio-blk.c|95| <<virtio_blk_data_plane_create>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|39| <<virtio_scsi_dataplane_setup>> if (!k->set_guest_notifiers || !k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|194| <<virtio_bus_grab_ioeventfd>> if (!k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|227| <<virtio_bus_start_ioeventfd>> if (!k->ioeventfd_assign || !k->ioeventfd_enabled(proxy)) {
+     *   - hw/virtio/virtio-bus.c|269| <<virtio_bus_ioeventfd_enabled>> return k->ioeventfd_assign && k->ioeventfd_enabled(proxy);
+     *   - hw/virtio/virtio-bus.c|301| <<virtio_bus_set_host_notifier>> if (!k->ioeventfd_assign) {
+     *   - hw/virtio/virtio-bus.c|312| <<virtio_bus_set_host_notifier>> r = k->ioeventfd_assign(proxy, notifier, n, true);
+     *   - hw/virtio/virtio-bus.c|318| <<virtio_bus_set_host_notifier>> k->ioeventfd_assign(proxy, notifier, n, false);
+     */
     int (*ioeventfd_assign)(DeviceState *d, EventNotifier *notifier,
                             int n, bool assign);
     /*
diff --git a/include/hw/virtio/virtio-pci.h b/include/hw/virtio/virtio-pci.h
index 2446dcd9a..34986d835 100644
--- a/include/hw/virtio/virtio-pci.h
+++ b/include/hw/virtio/virtio-pci.h
@@ -143,6 +143,15 @@ struct VirtIOPCIProxy {
     uint32_t modern_mem_bar_idx;
     int config_cap;
     uint32_t flags;
+    /*
+     * 在以下使用VirtIOPCIProxy->disable_modern:
+     *   - hw/virtio/virtio-pci.c|2078| <<global>> DEFINE_PROP_BOOL("disable-modern", VirtIOPCIProxy, disable_modern, false),
+     *   - hw/virtio/virtio-pci.c|2102| <<virtio_pci_transitional_instance_init>> proxy->disable_modern = false;
+     *   - hw/virtio/virtio-pci.c|2110| <<virtio_pci_non_transitional_instance_init>> proxy->disable_modern = false;
+     *   - include/hw/virtio/virtio-pci.h|163| <<virtio_pci_modern>> return !proxy->disable_modern;
+     *   - include/hw/virtio/virtio-pci.h|173| <<virtio_pci_force_virtio_1>> proxy->disable_modern = false;
+     *   - include/hw/virtio/virtio-pci.h|179| <<virtio_pci_disable_modern>> proxy->disable_modern = true;
+     */
     bool disable_modern;
     bool ignore_backend_features;
     OnOffAuto disable_legacy;
@@ -158,8 +167,28 @@ struct VirtIOPCIProxy {
     VirtioBusState bus;
 };
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|112| <<virtio_pci_modern_state_needed>> return virtio_pci_modern(proxy);
+ *   - hw/virtio/virtio-pci.c|253| <<virtio_pci_ioeventfd_assign>> bool modern = virtio_pci_modern(proxy);
+ *   - hw/virtio/virtio-pci.c|1094| <<virtio_pci_set_host_notifier_mr>> if (n >= VIRTIO_QUEUE_MAX || !virtio_pci_modern(proxy) ||
+ *   - hw/virtio/virtio-pci.c|1644| <<virtio_pci_pre_plugged>> if (virtio_pci_modern(proxy)) {
+ *   - hw/virtio/virtio-pci.c|1680| <<virtio_pci_device_plugged>> modern = virtio_pci_modern(proxy);
+ *   - hw/virtio/virtio-pci.c|1809| <<virtio_pci_device_unplugged>> bool modern = virtio_pci_modern(proxy);
+ *   - hw/virtio/virtio-pci.c|1885| <<virtio_pci_realize>> if (!virtio_pci_modern(proxy) && !virtio_pci_legacy(proxy)) {
+ *   - hw/virtio/virtio-pci.c|2042| <<virtio_pci_dc_realize>> virtio_pci_modern(proxy)) {
+ */
 static inline bool virtio_pci_modern(VirtIOPCIProxy *proxy)
 {
+    /*
+     * 在以下使用VirtIOPCIProxy->disable_modern:
+     *   - hw/virtio/virtio-pci.c|2078| <<global>> DEFINE_PROP_BOOL("disable-modern", VirtIOPCIProxy, disable_modern, false),
+     *   - hw/virtio/virtio-pci.c|2102| <<virtio_pci_transitional_instance_init>> proxy->disable_modern = false;
+     *   - hw/virtio/virtio-pci.c|2110| <<virtio_pci_non_transitional_instance_init>> proxy->disable_modern = false;
+     *   - include/hw/virtio/virtio-pci.h|163| <<virtio_pci_modern>> return !proxy->disable_modern;
+     *   - include/hw/virtio/virtio-pci.h|173| <<virtio_pci_force_virtio_1>> proxy->disable_modern = false;
+     *   - include/hw/virtio/virtio-pci.h|179| <<virtio_pci_disable_modern>> proxy->disable_modern = true;
+     */
     return !proxy->disable_modern;
 }
 
@@ -168,12 +197,27 @@ static inline bool virtio_pci_legacy(VirtIOPCIProxy *proxy)
     return proxy->disable_legacy == ON_OFF_AUTO_OFF;
 }
 
+/*
+ * called by:
+ *   - hw/display/virtio-vga.c|150| <<virtio_vga_base_realize>> virtio_pci_force_virtio_1(vpci_dev);
+ *   - hw/virtio/vhost-user-vsock-pci.c|45| <<vhost_user_vsock_pci_realize>> virtio_pci_force_virtio_1(vpci_dev);
+ *   - hw/virtio/vhost-vsock-pci.c|54| <<vhost_vsock_pci_realize>> virtio_pci_force_virtio_1(vpci_dev);
+ *   - hw/virtio/virtio-crypto-pci.c|57| <<virtio_crypto_pci_realize>> virtio_pci_force_virtio_1(vpci_dev);
+ *   - hw/virtio/virtio-input-pci.c|49| <<virtio_input_pci_realize>> virtio_pci_force_virtio_1(vpci_dev);
+ *   - hw/virtio/virtio-iommu-pci.c|65| <<virtio_iommu_pci_realize>> virtio_pci_force_virtio_1(vpci_dev);
+ *   - hw/virtio/virtio-mem-pci.c|25| <<virtio_mem_pci_realize>> virtio_pci_force_virtio_1(vpci_dev);
+ *   - hw/virtio/virtio-pmem-pci.c|25| <<virtio_pmem_pci_realize>> virtio_pci_force_virtio_1(vpci_dev);
+ */
 static inline void virtio_pci_force_virtio_1(VirtIOPCIProxy *proxy)
 {
     proxy->disable_modern = false;
     proxy->disable_legacy = ON_OFF_AUTO_ON;
 }
 
+/*
+ * called by:
+ *   - hw/virtio/virtio-pci.c|1669| <<virtio_pci_device_plugged>> virtio_pci_disable_modern(proxy);
+ */
 static inline void virtio_pci_disable_modern(VirtIOPCIProxy *proxy)
 {
     proxy->disable_modern = true;
diff --git a/include/hw/virtio/virtio-scsi.h b/include/hw/virtio/virtio-scsi.h
index a36aad9c8..5a0334c7f 100644
--- a/include/hw/virtio/virtio-scsi.h
+++ b/include/hw/virtio/virtio-scsi.h
@@ -85,9 +85,48 @@ struct VirtIOSCSI {
     /* Fields for dataplane below */
     AioContext *ctx; /* one iothread per virtio-scsi-pci for now */
 
+    /*
+     * 在以下设置VirtIOSCSI->dataplane_started:
+     *   - hw/scsi/virtio-scsi-dataplane.c|149| <<virtio_scsi_dataplane_start>> s->dataplane_started = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|179| <<virtio_scsi_dataplane_start>> s->dataplane_started = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|233| <<virtio_scsi_dataplane_stop>> s->dataplane_started = false;
+     *   - hw/scsi/virtio-scsi-dataplane.c|199| <<virtio_scsi_dataplane_stop>> s->dataplane_started = false;
+     * 在以下使用VirtIOSCSI->dataplane_started:
+     *   - hw/scsi/virtio-scsi-dataplane.c|98| <<virtio_scsi_dataplane_start>> if (s->dataplane_started ||
+     *   - hw/scsi/virtio-scsi-dataplane.c|192| <<virtio_scsi_dataplane_stop>> if (!s->dataplane_started || s->dataplane_stopping) {
+     *   - hw/scsi/virtio-scsi.c|113| <<virtio_scsi_complete_req>> if (s->dataplane_started && !s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|291| <<virtio_scsi_ctx_check>> if (s->dataplane_started && d && blk_is_available(d->conf.blk)) {
+     *   - hw/scsi/virtio-scsi.c|519| <<virtio_scsi_defer_to_dataplane>> if (!s->ctx || s->dataplane_started) {
+     *   - hw/scsi/virtio-scsi.c|831| <<virtio_scsi_reset>> assert(!s->dataplane_started);
+     */
     bool dataplane_started;
+    /*
+     * 在以下使用VirtIOSCSI->dataplane_starting:
+     *   - hw/scsi/virtio-scsi-dataplane.c|99| <<virtio_scsi_dataplane_start>> s->dataplane_starting ||
+     *   - hw/scsi/virtio-scsi-dataplane.c|104| <<virtio_scsi_dataplane_start>> s->dataplane_starting = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|148| <<virtio_scsi_dataplane_start>> s->dataplane_starting = false;
+     *   - hw/scsi/virtio-scsi-dataplane.c|178| <<virtio_scsi_dataplane_start>> s->dataplane_starting = false;
+     */
     bool dataplane_starting;
+    /*
+     * 在以下使用VirtIOSCSI->dataplane_stopping:
+     *   - hw/scsi/virtio-scsi-dataplane.c|192| <<virtio_scsi_dataplane_stop>> if (!s->dataplane_started || s->dataplane_stopping) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|202| <<virtio_scsi_dataplane_stop>> s->dataplane_stopping = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|232| <<virtio_scsi_dataplane_stop>> s->dataplane_stopping = false;
+     */
     bool dataplane_stopping;
+    /*
+     * 在以下设置VirtIOSCSI->dataplane_fenced:
+     *   - hw/scsi/virtio-scsi-dataplane.c|62| <<virtio_scsi_set_host_notifier>> s->dataplane_fenced = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|177| <<virtio_scsi_dataplane_start>> s->dataplane_fenced = true;
+     *   - hw/scsi/virtio-scsi-dataplane.c|198| <<virtio_scsi_dataplane_stop>> s->dataplane_fenced = false;
+     * 在以下使用VirtIOSCSI->dataplane_fenced:
+     *   - hw/scsi/virtio-scsi-dataplane.c|100| <<virtio_scsi_dataplane_start>> s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi-dataplane.c|197| <<virtio_scsi_dataplane_stop>> if (s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|113| <<virtio_scsi_complete_req>> if (s->dataplane_started && !s->dataplane_fenced) {
+     *   - hw/scsi/virtio-scsi.c|524| <<virtio_scsi_defer_to_dataplane>> return !s->dataplane_fenced;
+     *   - hw/scsi/virtio-scsi.c|940| <<virtio_scsi_hotplug>> if (s->ctx && !s->dataplane_fenced) {
+     */
     bool dataplane_fenced;
     uint32_t host_features;
 };
diff --git a/include/hw/virtio/virtio.h b/include/hw/virtio/virtio.h
index db1c0ddf6..f11953efb 100644
--- a/include/hw/virtio/virtio.h
+++ b/include/hw/virtio/virtio.h
@@ -86,6 +86,20 @@ struct VirtIODevice
     uint16_t queue_sel;
     uint64_t guest_features;
     uint64_t host_features;
+    /*
+     * 在以下使用VirtIODevice->backend_features:
+     *   - hw/block/vhost-user-blk.c|336| <<vhost_user_blk_connect>> s->dev.backend_features = 0;
+     *   - hw/net/vhost_net.c|130| <<vhost_net_ack_features>> net->dev.acked_features = net->dev.backend_features;
+     *   - hw/net/vhost_net.c|178| <<vhost_net_init>> net->dev.backend_features = qemu_has_vnet_hdr(options->net_backend)
+     *   - hw/net/vhost_net.c|183| <<vhost_net_init>> net->dev.backend_features = 0;
+     *   - hw/net/vhost_net.c|203| <<vhost_net_init>> if (~net->dev.features & net->dev.backend_features) {
+     *   - hw/net/vhost_net.c|206| <<vhost_net_init>> (uint64_t)(~net->dev.features & net->dev.backend_features));
+     *   - hw/net/virtio-net.c|750| <<virtio_net_get_features>> vdev->backend_features = features;
+     *   - hw/net/virtio-net.c|886| <<virtio_net_set_features>> !virtio_has_feature(vdev->backend_features, VIRTIO_NET_F_MTU)) {
+     *   - hw/scsi/vhost-scsi.c|220| <<vhost_scsi_realize>> vsc->dev.backend_features = 0;
+     *   - hw/scsi/vhost-user-scsi.c|121| <<vhost_user_scsi_realize>> vsc->dev.backend_features = 0;
+     *   - hw/virtio/vhost-user.c|2020| <<vhost_user_backend_init>> dev->backend_features |= 1ULL << VHOST_USER_F_PROTOCOL_FEATURES;
+     */
     uint64_t backend_features;
     size_t config_len;
     void *config;
@@ -134,6 +148,14 @@ struct VirtioDeviceClass {
      * that are only exposed on the legacy interface but not
      * the modern one.
      */
+    /*
+     * 在以下使用ViriioDevice->legacy_features:
+     *   - hw/net/virtio-net.c|3785| <<virtio_net_class_init>> vdc->legacy_features |= (0x1 << VIRTIO_NET_F_GSO);
+     *   - hw/s390x/virtio-ccw.c|389| <<virtio_ccw_cb>> (vdev->host_features & ~vdc->legacy_features);
+     *   - hw/virtio/virtio-mmio.c|170| <<virtio_mmio_read>> return (vdev->host_features & ~vdc->legacy_features)
+     *   - hw/virtio/virtio-pci.c|1211| <<virtio_pci_common_read>> val = (vdev->host_features & ~vdc->legacy_features) >>
+     *   - hw/virtio/virtio.c|3959| <<virtio_device_class_init>> vdc->legacy_features |= VIRTIO_LEGACY_FEATURES;
+     */
     uint64_t legacy_features;
     /* Test and clear event pending status.
      * Should be called after unmask to avoid losing events.
diff --git a/include/sysemu/accel-ops.h b/include/sysemu/accel-ops.h
index a0572ea87..66c1ec6a5 100644
--- a/include/sysemu/accel-ops.h
+++ b/include/sysemu/accel-ops.h
@@ -34,8 +34,28 @@ struct AccelOpsClass {
     void (*kick_vcpu_thread)(CPUState *cpu);
     bool (*cpu_thread_is_idle)(CPUState *cpu);
 
+    /*
+     * 在以下使用AcclOpsClass->synchronize_post_reset:
+     *   - accel/hvf/hvf-accel-ops.c|472| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|94| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - softmmu/cpus.c|176| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - softmmu/cpus.c|177| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/hax/hax-accel-ops.c|84| <<hax_accel_ops_class_init>> ops->synchronize_post_reset = hax_cpu_synchronize_post_reset;
+     *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|99| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     void (*synchronize_post_reset)(CPUState *cpu);
     void (*synchronize_post_init)(CPUState *cpu);
+    /*
+     * 在以下使用AcclOpsClass->synchronize_state:
+     *   - accel/hvf/hvf-accel-ops.c|474| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|96| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - softmmu/cpus.c|169| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - softmmu/cpus.c|170| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/hax/hax-accel-ops.c|86| <<hax_accel_ops_class_init>> ops->synchronize_state = hax_cpu_synchronize_state;
+     *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|101| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     void (*synchronize_state)(CPUState *cpu);
     void (*synchronize_pre_loadvm)(CPUState *cpu);
     void (*synchronize_pre_resume)(bool step_pending);
diff --git a/iothread.c b/iothread.c
index 529194a56..253db1a3e 100644
--- a/iothread.c
+++ b/iothread.c
@@ -339,6 +339,10 @@ char *iothread_get_id(IOThread *iothread)
 
 AioContext *iothread_get_aio_context(IOThread *iothread)
 {
+    /*
+     * IOThread *iothread:
+     * -> AioContext *ctx;
+     */
     return iothread->ctx;
 }
 
diff --git a/monitor/hmp.c b/monitor/hmp.c
index 15ca04735..04f8659de 100644
--- a/monitor/hmp.c
+++ b/monitor/hmp.c
@@ -274,6 +274,14 @@ static void help_cmd_dump(Monitor *mon, const HMPCommand *cmds,
     }
 }
 
+/*
+ * called by:
+ *   - monitor/misc.c|175| <<do_help_cmd>> help_cmd(mon, qdict_get_try_str(qdict, "name"));
+ *   - monitor/misc.c|217| <<hmp_trace_file>> help_cmd(mon, "trace-file");
+ *   - monitor/misc.c|224| <<hmp_info_help>> help_cmd(mon, "info");
+ *   - monitor/misc.c|440| <<hmp_log>> help_cmd(mon, "log");
+ *   - qemu-io-cmds.c|2498| <<init_qemuio_commands>> qemuio_add_command(&help_cmd);
+ */
 void help_cmd(Monitor *mon, const char *name)
 {
     char *args[MAX_ARGS];
diff --git a/qga/commands-posix.c b/qga/commands-posix.c
index 954efed01..c5ff4fd09 100644
--- a/qga/commands-posix.c
+++ b/qga/commands-posix.c
@@ -81,6 +81,34 @@ static void ga_wait_child(pid_t pid, int *status, Error **errp)
     g_assert(rpid == pid);
 }
 
+/*
+ * (gdb) bt
+ * #0  qmp_guest_shutdown (has_mode=false, mode=0x0, errp=errp@entry=0x7ffd6b9d2928) at ../qga/commands-posix.c:85
+ * #1  0x000055c142ed9765 in qmp_marshal_guest_shutdown (args=<optimized out>, ret=<optimized out>, errp=0x7ffd6b9d29a0)
+ *     at qga/qga-qapi-commands.c:270
+ * #2  0x000055c142eee853 in qmp_dispatch (cmds=cmds@entry=0x55c14312e9d0 <ga_commands>, request=request@entry=0x55c143c197f0,
+ *     allow_oob=allow_oob@entry=false, cur_mon=cur_mon@entry=0x0) at ../qapi/qmp-dispatch.c:211
+ * #3  0x000055c142ee32c0 in process_event (opaque=0x55c143c17080, obj=0x55c143c197f0, err=0x0) at ../qga/main.c:574
+ * #4  0x000055c142ef08eb in json_message_process_token (lexer=lexer@entry=0x55c143c17098, input=0x55c143c15780,
+ *     type=<optimized out>, x=28, y=0) at ../qobject/json-streamer.c:99
+ * #5  0x000055c142f04010 in json_lexer_feed_char (lexer=lexer@entry=0x55c143c17098, ch=125 '}', flush=flush@entry=false)
+ *     at ../qobject/json-lexer.c:313
+ * #6  0x000055c142f04191 in json_lexer_feed (lexer=lexer@entry=0x55c143c17098,
+ *     buffer=buffer@entry=0x7ffd6b9d2b30 "{\"execute\":\"guest-shutdown\"}\n", size=<optimized out>)
+ *     at ../qobject/json-lexer.c:350
+ * #7  0x000055c142ef0a2d in json_message_parser_feed (parser=parser@entry=0x55c143c17080,
+ *     buffer=buffer@entry=0x7ffd6b9d2b30 "{\"execute\":\"guest-shutdown\"}\n", size=<optimized out>)
+ *     at ../qobject/json-streamer.c:121
+ * #8  0x000055c142ee2c82 in channel_event_cb (condition=<optimized out>, data=0x55c143c17080) at ../qga/main.c:600
+ * #9  0x000055c142ee3b02 in ga_channel_client_event (channel=<optimized out>, condition=<optimized out>, data=0x55c143c174c0)
+ *     at ../qga/channel-posix.c:92
+ * #10 0x00007f10c385867d in g_main_context_dispatch () from /lib64/libglib-2.0.so.0
+ * #11 0x00007f10c3858a48 in g_main_context_iterate.isra () from /lib64/libglib-2.0.so.0
+ * #12 0x00007f10c3858d72 in g_main_loop_run () from /lib64/libglib-2.0.so.0
+ * #13 0x000055c142ed83ff in run_agent_once (s=0x55c143c17080) at ../qga/main.c:1391
+ * #14 run_agent (s=0x55c143c17080) at ../qga/main.c:1428
+ * #15 main (argc=<optimized out>, argv=<optimized out>) at ../qga/main.c:1541
+ */
 void qmp_guest_shutdown(bool has_mode, const char *mode, Error **errp)
 {
     const char *shutdown_flag;
diff --git a/qom/object.c b/qom/object.c
index d34608558..c9d8eb39c 100644
--- a/qom/object.c
+++ b/qom/object.c
@@ -2125,6 +2125,13 @@ Object *object_resolve_path_type(const char *path, const char *typename,
     Object *obj;
     char **parts;
 
+    /*
+     * 按照"/"分割
+     *
+     * 从acpi_get_pm_info()进来 ...
+     * (gdb) p parts[0]
+     * $3 = 0x0
+     */
     parts = g_strsplit(path, "/", 0);
     assert(parts);
 
diff --git a/softmmu/cpus.c b/softmmu/cpus.c
index 23b30484b..6b48329e4 100644
--- a/softmmu/cpus.c
+++ b/softmmu/cpus.c
@@ -166,6 +166,16 @@ void cpu_synchronize_all_pre_loadvm(void)
 
 void cpu_synchronize_state(CPUState *cpu)
 {
+    /*
+     * 在以下使用AcclOpsClass->synchronize_state:
+     *   - accel/hvf/hvf-accel-ops.c|474| <<hvf_accel_ops_class_init>> ops->synchronize_state = hvf_cpu_synchronize_state;
+     *   - accel/kvm/kvm-accel-ops.c|96| <<kvm_accel_ops_class_init>> ops->synchronize_state = kvm_cpu_synchronize_state;
+     *   - softmmu/cpus.c|169| <<cpu_synchronize_state>> if (cpus_accel->synchronize_state) {
+     *   - softmmu/cpus.c|170| <<cpu_synchronize_state>> cpus_accel->synchronize_state(cpu);
+     *   - target/i386/hax/hax-accel-ops.c|86| <<hax_accel_ops_class_init>> ops->synchronize_state = hax_cpu_synchronize_state;
+     *   - target/i386/nvmm/nvmm-accel-ops.c|95| <<nvmm_accel_ops_class_init>> ops->synchronize_state = nvmm_cpu_synchronize_state;
+     *   - target/i386/whpx/whpx-accel-ops.c|101| <<whpx_accel_ops_class_init>> ops->synchronize_state = whpx_cpu_synchronize_state;
+     */
     if (cpus_accel->synchronize_state) {
         cpus_accel->synchronize_state(cpu);
     }
@@ -173,6 +183,16 @@ void cpu_synchronize_state(CPUState *cpu)
 
 void cpu_synchronize_post_reset(CPUState *cpu)
 {
+    /*
+     * 在以下使用AcclOpsClass->synchronize_post_reset:
+     *   - accel/hvf/hvf-accel-ops.c|472| <<hvf_accel_ops_class_init>> ops->synchronize_post_reset = hvf_cpu_synchronize_post_reset;
+     *   - accel/kvm/kvm-accel-ops.c|94| <<kvm_accel_ops_class_init>> ops->synchronize_post_reset = kvm_cpu_synchronize_post_reset;
+     *   - softmmu/cpus.c|176| <<cpu_synchronize_post_reset>> if (cpus_accel->synchronize_post_reset) {
+     *   - softmmu/cpus.c|177| <<cpu_synchronize_post_reset>> cpus_accel->synchronize_post_reset(cpu);
+     *   - target/i386/hax/hax-accel-ops.c|84| <<hax_accel_ops_class_init>> ops->synchronize_post_reset = hax_cpu_synchronize_post_reset;
+     *   - target/i386/nvmm/nvmm-accel-ops.c|93| <<nvmm_accel_ops_class_init>> ops->synchronize_post_reset = nvmm_cpu_synchronize_post_reset;
+     *   - target/i386/whpx/whpx-accel-ops.c|99| <<whpx_accel_ops_class_init>> ops->synchronize_post_reset = whpx_cpu_synchronize_post_reset;
+     */
     if (cpus_accel->synchronize_post_reset) {
         cpus_accel->synchronize_post_reset(cpu);
     }
diff --git a/softmmu/memory.c b/softmmu/memory.c
index 7ba204883..6a20221bd 100644
--- a/softmmu/memory.c
+++ b/softmmu/memory.c
@@ -37,13 +37,50 @@
 //#define DEBUG_UNASSIGNED
 
 static unsigned memory_region_transaction_depth;
+/*
+ * 在以下使用memory_region_update_pending:
+ *   - softmmu/memory.c|1137| <<memory_region_transaction_commit>> if (memory_region_update_pending) {
+ *   - softmmu/memory.c|1146| <<memory_region_transaction_commit>> memory_region_update_pending = false;
+ *   - softmmu/memory.c|2178| <<memory_region_set_log>> memory_region_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2308| <<memory_region_set_readonly>> memory_region_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2318| <<memory_region_set_nonvolatile>> memory_region_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2328| <<memory_region_rom_device_set_romd>> memory_region_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2629| <<memory_region_update_container_subregions>> memory_region_update_pending |= mr->enabled && subregion->enabled;
+ *   - softmmu/memory.c|2679| <<memory_region_del_subregion>> memory_region_update_pending |= mr->enabled && subregion->enabled;
+ *   - softmmu/memory.c|2690| <<memory_region_set_enabled>> memory_region_update_pending = true;
+ *   - softmmu/memory.c|2706| <<memory_region_set_size>> memory_region_update_pending = true;
+ *   - softmmu/memory.c|2742| <<memory_region_set_alias_offset>> memory_region_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2913| <<memory_global_dirty_log_start>> memory_region_update_pending = true;
+ *   - softmmu/memory.c|2928| <<memory_global_dirty_log_do_stop>> memory_region_update_pending = true;
+ */
 static bool memory_region_update_pending;
+/*
+ * 在以下使用ioeventfd_update_pending:
+ *   - softmmu/memory.c|1107| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - softmmu/memory.c|1109| <<memory_region_transaction_commit>> } else if (ioeventfd_update_pending) {
+ *   - softmmu/memory.c|1113| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+ *   - softmmu/memory.c|2485| <<memory_region_add_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ *   - softmmu/memory.c|2520| <<memory_region_del_eventfd>> ioeventfd_update_pending |= mr->enabled;
+ */
 static bool ioeventfd_update_pending;
 unsigned int global_dirty_tracking;
 
 static QTAILQ_HEAD(, MemoryListener) memory_listeners
     = QTAILQ_HEAD_INITIALIZER(memory_listeners);
 
+/*
+ * 在以下使用address_spaces (list):
+ *   - softmmu/memory.c|72| <<QTAILQ_HEAD>> = QTAILQ_HEAD_INITIALIZER(address_spaces);
+ *   - softmmu/memory.c|598| <<memory_region_to_address_space>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - softmmu/memory.c|1122| <<flatviews_reset>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - softmmu/memory.c|1209| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - softmmu/memory.c|1217| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - softmmu/memory.c|2491| <<memory_region_update_coalesced_range>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - softmmu/memory.c|3166| <<address_space_init>> QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
+ *   - softmmu/memory.c|3190| <<address_space_destroy>> QTAILQ_REMOVE(&address_spaces, as, address_spaces_link);
+ *   - softmmu/memory.c|3501| <<mtree_info_flatview>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ *   - softmmu/memory.c|3579| <<mtree_info_as>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+ */
 static QTAILQ_HEAD(, AddressSpace) address_spaces
     = QTAILQ_HEAD_INITIALIZER(address_spaces);
 
@@ -170,6 +207,12 @@ struct MemoryRegionIoeventfd {
     EventNotifier *e;
 };
 
+/*
+ * called by:
+ *   - softmmu/memory.c|780| <<address_space_add_del_ioeventfds>> || memory_region_ioeventfd_before(&fds_old[iold],
+ *   - softmmu/memory.c|793| <<address_space_add_del_ioeventfds>> || memory_region_ioeventfd_before(&fds_new[inew],
+ *   - softmmu/memory.c|2522| <<memory_region_add_eventfd>> if (memory_region_ioeventfd_before(&mrfd, &mr->ioeventfds[i])) {
+ */
 static bool memory_region_ioeventfd_before(MemoryRegionIoeventfd *a,
                                            MemoryRegionIoeventfd *b)
 {
@@ -576,6 +619,12 @@ static AddressSpace *memory_region_to_address_space(MemoryRegion *mr)
 /* Render a memory region into the global view.  Ranges in @view obscure
  * ranges in @mr.
  */
+/*
+ * called by:
+ *   - softmmu/memory.c|656| <<render_memory_region>> render_memory_region(view, mr->alias, base, clip,
+ *   - softmmu/memory.c|663| <<render_memory_region>> render_memory_region(view, subregion, base, clip,
+ *   - softmmu/memory.c|785| <<generate_memory_topology>> render_memory_region(view, mr, int128_zero(),
+ */
 static void render_memory_region(FlatView *view,
                                  MemoryRegion *mr,
                                  Int128 base,
@@ -725,6 +774,12 @@ static MemoryRegion *memory_region_get_flatview_root(MemoryRegion *mr)
 }
 
 /* Render a memory topology into a list of disjoint absolute ranges. */
+/*
+ * called by:
+ *   - softmmu/memory.c|1035| <<flatviews_init>> empty_view = generate_memory_topology(NULL);
+ *   - softmmu/memory.c|1062| <<flatviews_reset>> generate_memory_topology(physmr);
+ *   - softmmu/memory.c|1117| <<address_space_update_topology>> generate_memory_topology(physmr);
+ */
 static FlatView *generate_memory_topology(MemoryRegion *mr)
 {
     int i;
@@ -751,6 +806,10 @@ static FlatView *generate_memory_topology(MemoryRegion *mr)
     return view;
 }
 
+/*
+ * called by:
+ *   - softmmu/memory.c|916| <<address_space_update_ioeventfds>> address_space_add_del_ioeventfds(as, ioeventfds, ioeventfd_nb,
+ */
 static void address_space_add_del_ioeventfds(AddressSpace *as,
                                              MemoryRegionIoeventfd *fds_new,
                                              unsigned fds_new_nb,
@@ -800,6 +859,17 @@ static void address_space_add_del_ioeventfds(AddressSpace *as,
     }
 }
 
+/*
+ * called by:
+ *   - softmmu/memory.c|913| <<address_space_update_ioeventfds>> view = address_space_get_flatview(as);
+ *   - softmmu/memory.c|2259| <<memory_region_sync_dirty_bitmap>> view = address_space_get_flatview(as);
+ *   - softmmu/memory.c|2295| <<memory_region_clear_dirty_bitmap>> view = address_space_get_flatview(as);
+ *   - softmmu/memory.c|2474| <<memory_region_update_coalesced_range>> view = address_space_get_flatview(as);
+ *   - softmmu/memory.c|3043| <<listener_add_address_space>> view = address_space_get_flatview(as);
+ *   - softmmu/memory.c|3069| <<listener_del_address_space>> view = address_space_get_flatview(as);
+ *   - softmmu/memory.c|3484| <<mtree_info_flatview>> view = address_space_get_flatview(as);
+ *   - softmmu/physmem.c|3352| <<address_space_cache_init>> cache->fv = address_space_get_flatview(as);
+ */
 FlatView *address_space_get_flatview(AddressSpace *as)
 {
     FlatView *view;
@@ -814,6 +884,47 @@ FlatView *address_space_get_flatview(AddressSpace *as)
     return view;
 }
 
+/*
+ * 当device_add cpu的时候:
+ *
+ * (gdb) bt
+ * #0  address_space_update_ioeventfds (as=0x555557b8eea0) at ../softmmu/memory.c:818
+ * #1  0x0000555555c6c86a in address_space_init (as=0x555557b8eea0, root=0x555556a5e770, name=0x555557b8ef00 "cpu-memory-4") at ../softmmu/memory.c:3025
+ * #2  0x0000555555c70e74 in cpu_address_space_init (cpu=0x555556dd7000, asidx=0, prefix=0x55555603415f "cpu-memory", mr=0x555556a5e770) at ../softmmu/physmem.c:748
+ * #3  0x0000555555a71fd1 in qemu_init_vcpu (cpu=0x555556dd7000) at ../softmmu/cpus.c:634
+ * #4  0x0000555555b633c0 in x86_cpu_realizefn (dev=0x555556dd7000, errp=0x7fffffffc4b0) at ../target/i386/cpu.c:6591
+ * #5  0x0000555555d21085 in device_set_realized (obj=0x555556dd7000, value=true, errp=0x7fffffffc7f0) at ../hw/core/qdev.c:553
+ * #6  0x0000555555d2aaf5 in property_set_bool (obj=0x555556dd7000, v=0x555557318610, name=0x5555560b9501 "realized", opaque=0x555556852210, errp=0x7fffffffc7f0) at ../qom/object.c:2273
+ * #7  0x0000555555d28b3c in object_property_set (obj=0x555556dd7000, name=0x5555560b9501 "realized", v=0x555557318610, errp=0x7fffffffc7f0) at ../qom/object.c:1408
+ * #8  0x0000555555d2cee7 in object_property_set_qobject (obj=0x555556dd7000, name=0x5555560b9501 "realized", value=0x555556f93610, errp=0x7fffffffc7f0) at ../qom/qom-qobject.c:28
+ * #9  0x0000555555d28ea1 in object_property_set_bool (obj=0x555556dd7000, name=0x5555560b9501 "realized", value=true, errp=0x7fffffffc7f0) at ../qom/object.c:1477
+ * #10 0x0000555555d2081d in qdev_realize (dev=0x555556dd7000, bus=0x0, errp=0x7fffffffc7f0) at ../hw/core/qdev.c:333
+ * #11 0x0000555555a7768e in qdev_device_add_from_qdict (opts=0x55555705ba10, from_json=false, errp=0x7fffffffc7f0) at ../softmmu/qdev-monitor.c:714
+ * #12 0x0000555555a7772c in qdev_device_add (opts=0x5555579113b0, errp=0x7fffffffc7f0) at ../softmmu/qdev-monitor.c:733
+ * #13 0x0000555555a77d40 in qmp_device_add (qdict=0x5555578b4b60, ret_data=0x0, errp=0x7fffffffc7f0) at ../softmmu/qdev-monitor.c:855
+ * #14 0x0000555555a78150 in hmp_device_add (mon=0x5555568485f0, qdict=0x5555578b4b60) at ../softmmu/qdev-monitor.c:963
+ * #15 0x0000555555accc3e in handle_hmp_command_exec (mon=0x5555568485f0, cmd=0x5555566fb220 <hmp_cmds+1920>, qdict=0x5555578b4b60) at ../monitor/hmp.c:1103
+ * #16 0x0000555555acce6b in handle_hmp_command (mon=0x5555568485f0, cmdline=0x555556ae1f1b "host-x86_64-cpu,id=core4,socket-id=0,core-id=4,thread-id=0") at ../monitor/hmp.c:1155
+ * #17 0x0000555555aca384 in monitor_command_cb (opaque=0x5555568485f0, cmdline=0x555556ae1f10 "device_add host-x86_64-cpu,id=core4,socket-id=0,core-id=4,thread-id=0", readline_opaque=0x0) at ../monitor/hmp.c:49
+ * #18 0x0000555555f19732 in readline_handle_byte (rs=0x555556ae1f10, ch=13) at ../util/readline.c:411
+ * #19 0x0000555555acd9a8 in monitor_read (opaque=0x5555568485f0, buf=0x7fffffffca50 "\r\320\377\377\377\177", size=1) at ../monitor/hmp.c:1393
+ * #20 0x0000555555e31768 in qemu_chr_be_write_impl (s=0x555556a69190, buf=0x7fffffffca50 "\r\320\377\377\377\177", len=1) at ../chardev/char.c:201
+ * #21 0x0000555555e317cc in qemu_chr_be_write (s=0x555556a69190, buf=0x7fffffffca50 "\r\320\377\377\377\177", len=1) at ../chardev/char.c:213
+ * #22 0x0000555555e341f9 in fd_chr_read (chan=0x555556a69250, cond=G_IO_IN, opaque=0x555556a69190) at ../chardev/char-fd.c:72
+ * #23 0x0000555555d33709 in qio_channel_fd_source_dispatch (source=0x555557384df0, callback=0x555555e340cf <fd_chr_read>, user_data=0x555556a69190) at ../io/channel-watch.c:84
+ * #24 0x00007ffff6c40119 in g_main_context_dispatch () at /lib64/libglib-2.0.so.0
+ * #25 0x0000555555f12165 in glib_pollfds_poll () at ../util/main-loop.c:297
+ * #26 0x0000555555f121df in os_host_main_loop_wait (timeout=499000000) at ../util/main-loop.c:320
+ * #27 0x0000555555f122e4 in main_loop_wait (nonblocking=0) at ../util/main-loop.c:596
+ * #28 0x0000555555a7a05e in qemu_main_loop () at ../softmmu/runstate.c:734
+ * #29 0x000055555581fe62 in qemu_main (argc=32, argv=0x7fffffffdd38, envp=0x0) at ../softmmu/main.c:38
+ * #30 0x000055555581fe94 in main (argc=32, argv=0x7fffffffdd38) at ../softmmu/main.c:47
+ *
+ * called by:
+ *   - softmmu/memory.c|1104| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+ *   - softmmu/memory.c|1111| <<memory_region_transaction_commit>> address_space_update_ioeventfds(as);
+ *   - softmmu/memory.c|3013| <<address_space_init>> address_space_update_ioeventfds(as);
+ */
 static void address_space_update_ioeventfds(AddressSpace *as)
 {
     FlatView *view;
@@ -824,6 +935,25 @@ static void address_space_update_ioeventfds(AddressSpace *as)
     AddrRange tmp;
     unsigned i;
 
+    /*
+     * 在以下使用MemoryRegion->ioeventfd_nb:
+     *   - softmmu/memory.c|899| <<address_space_update_ioeventfds>> for (i = 0; i < fr->mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|1545| <<memory_region_dispatch_write_eventfds>> for (i = 0; i < mr->ioeventfd_nb; i++) {
+     *   - softmmu/memory.c|2565| <<memory_region_add_eventfd>> for (i = 0; i < mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|2570| <<memory_region_add_eventfd>> ++mr->ioeventfd_nb;
+     *   - softmmu/memory.c|2575| <<memory_region_add_eventfd>> sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);
+     *   - softmmu/memory.c|2581| <<memory_region_add_eventfd>> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));
+     *   - softmmu/memory.c|2628| <<memory_region_del_eventfd>> for (i = 0; i < mr->ioeventfd_nb; ++i) {
+     *   - softmmu/memory.c|2633| <<memory_region_del_eventfd>> assert(i != mr->ioeventfd_nb);
+     *   - softmmu/memory.c|2635| <<memory_region_del_eventfd>> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb - (i+1)));
+     *   - softmmu/memory.c|2636| <<memory_region_del_eventfd>> --mr->ioeventfd_nb;
+     *   - softmmu/memory.c|2638| <<memory_region_del_eventfd>> sizeof(*mr->ioeventfds)*mr->ioeventfd_nb + 1);
+     * 在以下使用struct AddressSpace->ioeventfd_nb:
+     *   - softmmu/memory.c|878| <<address_space_update_ioeventfds>> ioeventfd_max = QEMU_ALIGN_UP(as->ioeventfd_nb, 4);
+     *   - softmmu/memory.c|921| <<address_space_update_ioeventfds>> as->ioeventfds, as->ioeventfd_nb);
+     *   - softmmu/memory.c|925| <<address_space_update_ioeventfds>> as->ioeventfd_nb = ioeventfd_nb;
+     *   - softmmu/memory.c|3126| <<address_space_init>> as->ioeventfd_nb = 0;
+     */
     /*
      * It is likely that the number of ioeventfds hasn't changed much, so use
      * the previous size as the starting value, with some headroom to avoid
@@ -832,9 +962,29 @@ static void address_space_update_ioeventfds(AddressSpace *as)
     ioeventfd_max = QEMU_ALIGN_UP(as->ioeventfd_nb, 4);
     ioeventfds = g_new(MemoryRegionIoeventfd, ioeventfd_max);
 
+    /*
+     * struct FlatView {
+     *     struct rcu_head rcu;
+     *     unsigned ref; 
+     *     FlatRange *ranges;
+     *     unsigned nr;
+     *     unsigned nr_allocated;
+     *     struct AddressSpaceDispatch *dispatch;
+     *     MemoryRegion *root;
+     * };
+     *
+     * FlatView *view;
+     */
     view = address_space_get_flatview(as);
+    /*
+     * 对于每一个fr
+     */
     FOR_EACH_FLAT_RANGE(fr, view) {
         for (i = 0; i < fr->mr->ioeventfd_nb; ++i) {
+            /*
+	     * 大概是:
+	     * fr->mr->ioeventfds[i].addr + (fr->addr.start - fr->offset_in_region)
+	     */
             tmp = addrrange_shift(fr->mr->ioeventfds[i].addr,
                                   int128_sub(fr->addr.start,
                                              int128_make64(fr->offset_in_region)));
@@ -851,6 +1001,13 @@ static void address_space_update_ioeventfds(AddressSpace *as)
         }
     }
 
+    /*
+     * 794 static void address_space_add_del_ioeventfds(AddressSpace *as,
+     * 795                                              MemoryRegionIoeventfd *fds_new,
+     * 796                                              unsigned fds_new_nb,
+     * 797                                              MemoryRegionIoeventfd *fds_old,
+     * 798                                              unsigned fds_old_nb)
+     */
     address_space_add_del_ioeventfds(as, ioeventfds, ioeventfd_nb,
                                      as->ioeventfds, as->ioeventfd_nb);
 
@@ -1001,6 +1158,10 @@ static void flatviews_init(void)
     }
 }
 
+/*
+ * called by:
+ *   - softmmu/memory.c|1138| <<memory_region_transaction_commit>> flatviews_reset();
+ */
 static void flatviews_reset(void)
 {
     AddressSpace *as;
@@ -1099,6 +1260,19 @@ void memory_region_transaction_commit(void)
 
             MEMORY_LISTENER_CALL_GLOBAL(begin, Forward);
 
+            /*
+	     * 在以下使用address_spaces (list):
+	     *   - softmmu/memory.c|72| <<QTAILQ_HEAD>> = QTAILQ_HEAD_INITIALIZER(address_spaces);
+             *   - softmmu/memory.c|598| <<memory_region_to_address_space>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+             *   - softmmu/memory.c|1122| <<flatviews_reset>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+             *   - softmmu/memory.c|1209| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+             *   - softmmu/memory.c|1217| <<memory_region_transaction_commit>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+             *   - softmmu/memory.c|2491| <<memory_region_update_coalesced_range>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+             *   - softmmu/memory.c|3166| <<address_space_init>> QTAILQ_INSERT_TAIL(&address_spaces, as, address_spaces_link);
+             *   - softmmu/memory.c|3190| <<address_space_destroy>> QTAILQ_REMOVE(&address_spaces, as, address_spaces_link);
+             *   - softmmu/memory.c|3501| <<mtree_info_flatview>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+             *   - softmmu/memory.c|3579| <<mtree_info_as>> QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
+	     */
             QTAILQ_FOREACH(as, &address_spaces, address_spaces_link) {
                 address_space_set_flatview(as);
                 address_space_update_ioeventfds(as);
@@ -2444,6 +2618,22 @@ void memory_region_clear_flush_coalesced(MemoryRegion *mr)
 
 static bool userspace_eventfd_warning;
 
+/*
+ * called by:
+ *   - hw/misc/ivshmem.c|365| <<ivshmem_add_eventfd>> memory_region_add_eventfd(&s->ivshmem_mmio,
+ *   - hw/misc/pci-testdev.c|113| <<pci_testdev_start>> memory_region_add_eventfd(test->mr,
+ *   - hw/nvme/ctrl.c|4270| <<nvme_init_cq_ioeventfd>> memory_region_add_eventfd(&n->iomem,
+ *   - hw/nvme/ctrl.c|4299| <<nvme_init_sq_ioeventfd>> memory_region_add_eventfd(&n->iomem,
+ *   - hw/vfio/pci-quirks.c|401| <<vfio_ioeventfd_init>> memory_region_add_eventfd(ioeventfd->mr, ioeventfd->addr, ioeventfd->size,
+ *   - hw/virtio/virtio-mmio.c|52| <<virtio_mmio_ioeventfd_assign>> memory_region_add_eventfd(&proxy->iomem, VIRTIO_MMIO_QUEUE_NOTIFY, 4,
+ *   - hw/virtio/virtio-pci.c|251| <<virtio_pci_ioeventfd_assign>> memory_region_add_eventfd(modern_mr, modern_addr, 0,
+ *   - hw/virtio/virtio-pci.c|254| <<virtio_pci_ioeventfd_assign>> memory_region_add_eventfd(modern_mr, modern_addr, 2,
+ *   - hw/virtio/virtio-pci.c|258| <<virtio_pci_ioeventfd_assign>> memory_region_add_eventfd(modern_notify_mr, 0, 2,
+ *   - hw/virtio/virtio-pci.c|263| <<virtio_pci_ioeventfd_assign>> memory_region_add_eventfd(legacy_mr, legacy_addr, 2,
+ *
+ * 核心思想就是制作MemoryRegionIoeventfd给MemoryRegion->ioeventfds[i]
+ * 可能会g_realloc()
+ */
 void memory_region_add_eventfd(MemoryRegion *mr,
                                hwaddr addr,
                                unsigned size,
@@ -2471,21 +2661,54 @@ void memory_region_add_eventfd(MemoryRegion *mr,
         adjust_endianness(mr, &mrfd.data, size_memop(size) | MO_TE);
     }
     memory_region_transaction_begin();
+    /*
+     * MemoryRegion *mr:
+     * -> unsigned ioeventfd_nb;
+     * -> MemoryRegionIoeventfd *ioeventfds;
+     */
     for (i = 0; i < mr->ioeventfd_nb; ++i) {
         if (memory_region_ioeventfd_before(&mrfd, &mr->ioeventfds[i])) {
             break;
         }
     }
     ++mr->ioeventfd_nb;
+    /*
+     * 似乎这里是唯一alloc的地方
+     */
     mr->ioeventfds = g_realloc(mr->ioeventfds,
                                   sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);
+    /*
+     * dst: &mr->ioeventfds[i+1]
+     * src: &mr->ioeventfds[i]
+     */
     memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],
             sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 - i));
     mr->ioeventfds[i] = mrfd;
+    /*
+     * 在以下使用ioeventfd_update_pending:
+     *   - softmmu/memory.c|1107| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+     *   - softmmu/memory.c|1109| <<memory_region_transaction_commit>> } else if (ioeventfd_update_pending) {
+     *   - softmmu/memory.c|1113| <<memory_region_transaction_commit>> ioeventfd_update_pending = false;
+     *   - softmmu/memory.c|2485| <<memory_region_add_eventfd>> ioeventfd_update_pending |= mr->enabled;
+     *   - softmmu/memory.c|2520| <<memory_region_del_eventfd>> ioeventfd_update_pending |= mr->enabled;
+     */
     ioeventfd_update_pending |= mr->enabled;
     memory_region_transaction_commit();
 }
 
+/*
+ * called by:
+ *   - hw/misc/ivshmem.c|375| <<ivshmem_del_eventfd>> memory_region_del_eventfd(&s->ivshmem_mmio,
+ *   - hw/misc/pci-testdev.c|127| <<pci_testdev_stop>> memory_region_del_eventfd(test->mr,
+ *   - hw/nvme/ctrl.c|4312| <<nvme_free_sq>> memory_region_del_eventfd(&n->iomem,
+ *   - hw/nvme/ctrl.c|4703| <<nvme_free_cq>> memory_region_del_eventfd(&n->iomem,
+ *   - hw/vfio/pci-quirks.c|292| <<vfio_ioeventfd_exit>> memory_region_del_eventfd(ioeventfd->mr, ioeventfd->addr, ioeventfd->size,
+ *   - hw/virtio/virtio-mmio.c|55| <<virtio_mmio_ioeventfd_assign>> memory_region_del_eventfd(&proxy->iomem, VIRTIO_MMIO_QUEUE_NOTIFY, 4,
+ *   - hw/virtio/virtio-pci.c|269| <<virtio_pci_ioeventfd_assign>> memory_region_del_eventfd(modern_mr, modern_addr, 0,
+ *   - hw/virtio/virtio-pci.c|272| <<virtio_pci_ioeventfd_assign>> memory_region_del_eventfd(modern_mr, modern_addr, 2,
+ *   - hw/virtio/virtio-pci.c|276| <<virtio_pci_ioeventfd_assign>> memory_region_del_eventfd(modern_notify_mr, 0, 2,
+ *   - hw/virtio/virtio-pci.c|281| <<virtio_pci_ioeventfd_assign>> memory_region_del_eventfd(legacy_mr, legacy_addr, 2,
+ */
 void memory_region_del_eventfd(MemoryRegion *mr,
                                hwaddr addr,
                                unsigned size,
@@ -2999,6 +3222,20 @@ void address_space_remove_listeners(AddressSpace *as)
     }
 }
 
+/*
+ * 被特别多调用,几个特殊的例子:
+ *   - hw/i386/amd_iommu.c|1443| <<amdvi_host_dma_iommu>> address_space_init(&amdvi_dev_as->as, &amdvi_dev_as->root, name);
+ *   - hw/i386/intel_iommu.c|3459| <<vtd_find_add_as>> address_space_init(&vtd_dev_as->as, &vtd_dev_as->root, "vtd-root");
+ *   - hw/pci/pci.c|1143| <<do_pci_register_device>> address_space_init(&pci_dev->bus_master_as,
+ *   - hw/remote/iommu.c|57| <<remote_iommu_find_add_as>> address_space_init(&elem->as, elem->mr, NULL);
+ *   - hw/s390x/s390-pci-bus.c|618| <<s390_pci_get_iommu>> address_space_init(&iommu->as, &iommu->mr, as_name);
+ *   - hw/scsi/lsi53c895a.c|2305| <<lsi_scsi_realize>> address_space_init(&s->pci_io_as, pci_address_space_io(dev), "lsi-pci-io");
+ *   - hw/virtio/virtio-iommu.c|409| <<virtio_iommu_find_add_as>> address_space_init(&sdev->as, &sdev->root, TYPE_VIRTIO_IOMMU);
+ *   - softmmu/physmem.c|748| <<cpu_address_space_init>> address_space_init(as, mr, as_name);
+ *   - softmmu/physmem.c|2680| <<memory_map_init>> address_space_init(&address_space_memory, system_memory, "memory");
+ *   - softmmu/physmem.c|2685| <<memory_map_init>> address_space_init(&address_space_io, system_io, "I/O");
+ *   - target/i386/kvm/kvm.c|2416| <<register_smram_listener>> address_space_init(&smram_address_space, &smram_as_root, "KVM-SMRAM");
+ */
 void address_space_init(AddressSpace *as, MemoryRegion *root, const char *name)
 {
     memory_region_ref(root);
diff --git a/softmmu/physmem.c b/softmmu/physmem.c
index dc3c3e5f2..e4e44cda4 100644
--- a/softmmu/physmem.c
+++ b/softmmu/physmem.c
@@ -736,6 +736,16 @@ translate_fail:
     return &d->map.sections[PHYS_SECTION_UNASSIGNED];
 }
 
+/*
+ * called by:
+ *   - softmmu/cpus.c|634| <<qemu_init_vcpu>> cpu_address_space_init(cpu, 0, "cpu-memory", cpu->memory);
+ *   - target/arm/cpu.c|2025| <<arm_cpu_realizefn>> cpu_address_space_init(cs, ARMASIdx_S, "cpu-secure-memory",
+ *   - target/arm/cpu.c|2030| <<arm_cpu_realizefn>> cpu_address_space_init(cs, ARMASIdx_TagNS, "cpu-tag-memory",
+ *   - target/arm/cpu.c|2033| <<arm_cpu_realizefn>> cpu_address_space_init(cs, ARMASIdx_TagS, "cpu-tag-memory",
+ *   - target/arm/cpu.c|2038| <<arm_cpu_realizefn>> cpu_address_space_init(cs, ARMASIdx_NS, "cpu-memory", cs->memory);
+ *   - target/i386/tcg/sysemu/tcg-cpu.c|76| <<tcg_cpu_realizefn>> cpu_address_space_init(cs, 0, "cpu-memory", cs->memory);
+ *   - target/i386/tcg/sysemu/tcg-cpu.c|77| <<tcg_cpu_realizefn>> cpu_address_space_init(cs, 1, "cpu-smm", cpu->cpu_as_root);
+ */
 void cpu_address_space_init(CPUState *cpu, int asidx,
                             const char *prefix, MemoryRegion *mr)
 {
@@ -774,6 +784,14 @@ void cpu_address_space_init(CPUState *cpu, int asidx,
     }
 }
 
+/*
+ * called by:
+ *   - hw/arm/armv7m.c|591| <<armv7m_load_kernel>> as = cpu_get_address_space(cs, asidx);
+ *   - hw/arm/boot.c|59| <<arm_boot_address_space>> return cpu_get_address_space(cs, asidx);
+ *   - target/arm/cpu.h|3327| <<arm_addressspace>> return cpu_get_address_space(cs, arm_asidx_from_attrs(cs, attrs));
+ *   - target/arm/mte_helper.c|206| <<allocation_tag_mem>> tag_as = cpu_get_address_space(env_cpu(env), tag_asi);
+ *   - target/i386/cpu.h|2103| <<cpu_addressspace>> return cpu_get_address_space(cs, cpu_asidx_from_attrs(cs, attrs));
+ */
 AddressSpace *cpu_get_address_space(CPUState *cpu, int asidx)
 {
     /* Return the AddressSpace corresponding to the specified index */
diff --git a/softmmu/runstate.c b/softmmu/runstate.c
index 1e68680b9..4072ddc4b 100644
--- a/softmmu/runstate.c
+++ b/softmmu/runstate.c
@@ -432,6 +432,13 @@ static int qemu_debug_requested(void)
 /*
  * Reset the VM. Issue an event unless @reason is SHUTDOWN_CAUSE_NONE.
  */
+/*
+ * called by:
+ *   - hw/core/machine.c|1460| <<qdev_machine_creation_done>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+ *   - hw/i386/xen/xen-hvm.c|1193| <<cpu_handle_ioreq>> qemu_system_reset(request);
+ *   - migration/savevm.c|3061| <<load_snapshot>> qemu_system_reset(SHUTDOWN_CAUSE_NONE);
+ *   - softmmu/runstate.c|694| <<main_loop_should_exit>> qemu_system_reset(request);
+ */
 void qemu_system_reset(ShutdownCause reason)
 {
     MachineClass *mc;
@@ -440,6 +447,9 @@ void qemu_system_reset(ShutdownCause reason)
 
     cpu_synchronize_all_states();
 
+    /*
+     * pc_machine_reset()
+     */
     if (mc && mc->reset) {
         mc->reset(current_machine);
     } else {
diff --git a/softmmu/vl.c b/softmmu/vl.c
index 706bd7cff..02a1a9fbc 100644
--- a/softmmu/vl.c
+++ b/softmmu/vl.c
@@ -178,6 +178,12 @@ static const char *vga_model = NULL;
 static DisplayOptions dpy;
 static int num_serial_hds;
 static Chardev **serial_hds;
+/*
+ * 在以下使用log_mask:
+ *   - softmmu/vl.c|2390| <<qemu_process_early_options>> if (log_mask) {
+ *   - softmmu/vl.c|2391| <<qemu_process_early_options>> mask = qemu_str_to_log_mask(log_mask);
+ *   - softmmu/vl.c|2900| <<qemu_init>> log_mask = optarg;
+ */
 static const char *log_mask;
 static const char *log_file;
 static bool list_data_dirs;
@@ -2355,6 +2361,10 @@ static int process_runstate_actions(void *opaque, QemuOpts *opts, Error **errp)
     return 0;
 }
 
+/*
+ * called by:
+ *   - softmmu/vl.c|3487| <<qemu_init>> qemu_process_early_options();
+ */
 static void qemu_process_early_options(void)
 {
 #ifdef CONFIG_SECCOMP
@@ -2396,6 +2406,10 @@ static void qemu_process_early_options(void)
     qemu_add_default_firmwarepath();
 }
 
+/*
+ * called by:
+ *   - softmmu/vl.c|3499| <<qemu_init>> qemu_process_help_options();
+ */
 static void qemu_process_help_options(void)
 {
     /*
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 1db1278a5..593a2ab54 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -673,6 +673,22 @@ void x86_cpu_vendor_words2str(char *dst, uint32_t vendor1,
 #define TCG_SGX_12_0_EBX_FEATURES 0
 #define TCG_SGX_12_1_EAX_FEATURES 0
 
+/*
+ * 在以下使用feature_word_info[FEATURE_WORDS]:
+ *   - target/i386/cpu-sysemu.c|68| <<x86_cpu_static_props>> FeatureWordInfo *fi = &feature_word_info[w];
+ *   - target/i386/cpu.c|1519| <<x86_cpu_get_migratable_flags>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|4310| <<mark_unavailable_features>> FeatureWordInfo *f = &feature_word_info[w];
+ *   - target/i386/cpu.c|4560| <<x86_cpu_get_feature_words>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|4613| <<x86_cpu_feature_name>> name = feature_word_info[w].feat_names[bitnr];
+ *   - target/i386/cpu.c|4614| <<x86_cpu_feature_name>> assert(bitnr < 32 || !(name && feature_word_info[w].type == CPUID_FEATURE_WORD));
+ *   - target/i386/cpu.c|4896| <<x86_cpu_list>> for (i = 0; i < ARRAY_SIZE(feature_word_info); i++) {
+ *   - target/i386/cpu.c|4897| <<x86_cpu_list>> FeatureWordInfo *fw = &feature_word_info[i];
+ *   - target/i386/cpu.c|4957| <<x86_cpu_get_supported_feature_word>> FeatureWordInfo *wi = &feature_word_info[w];
+ *   - target/i386/cpu.c|6121| <<x86_cpu_adjust_feat_level>> FeatureWordInfo *fi = &feature_word_info[w];
+ *   - target/i386/cpu.c|6125| <<x86_cpu_adjust_feat_level>> assert(feature_word_info[w].type == CPUID_FEATURE_WORD);
+ *   - target/i386/cpu.c|6256| <<x86_cpu_expand_features>> ~feature_word_info[w].no_autoenable_flags;
+ *   - target/i386/cpu.c|6780| <<x86_cpu_register_feature_bit_props>> FeatureWordInfo *fi = &feature_word_info[w];
+ */
 FeatureWordInfo feature_word_info[FEATURE_WORDS] = {
     [FEAT_1_EDX] = {
         .type = CPUID_FEATURE_WORD,
@@ -1533,6 +1549,28 @@ static uint64_t x86_cpu_get_migratable_flags(FeatureWord w)
     return r;
 }
 
+/*
+ * called by:
+ *   - hw/i386/sgx.c|95| <<sgx_calc_host_epc_sections>> host_cpuid(0x12, i + 2, &eax, &ebx, &ecx, &edx);
+ *   - hw/i386/sgx.c|169| <<qmp_query_sgx_capabilities>> host_cpuid(0x7, 0, &eax, &ebx, &ecx, &edx);
+ *   - hw/i386/sgx.c|174| <<qmp_query_sgx_capabilities>> host_cpuid(0x12, 0, &eax, &ebx, &ecx, &edx);
+ *   - target/i386/cpu.c|4992| <<x86_cpu_get_cache_cpuid>> host_cpuid(0, 0, &level, &unused, &unused, &unused);
+ *   - target/i386/cpu.c|4997| <<x86_cpu_get_cache_cpuid>> host_cpuid(0x80000000, 0, &level, &unused, &unused, &unused);
+ *   - target/i386/cpu.c|5009| <<x86_cpu_get_cache_cpuid>> host_cpuid(func, index, eax, ebx, ecx, edx);
+ *   - target/i386/cpu.c|5565| <<cpu_x86_cpuid>> host_cpuid(index, 2, eax, ebx, ecx, edx);
+ *   - target/i386/host-cpu.c|22| <<host_cpu_phys_bits>> host_cpuid(0x80000000, 0, &eax, NULL, NULL, NULL);
+ *   - target/i386/host-cpu.c|24| <<host_cpu_phys_bits>> host_cpuid(0x80000008, 0, &eax, NULL, NULL, NULL);
+ *   - target/i386/host-cpu.c|48| <<host_cpu_enable_cpu_pm>> host_cpuid(5, 0, &cpu->mwait.eax, &cpu->mwait.ebx,
+ *   - target/i386/host-cpu.c|123| <<host_cpu_fill_model_id>> host_cpuid(0x80000002 + i, 0, &eax, &ebx, &ecx, &edx);
+ *   - target/i386/host-cpu.c|136| <<host_cpu_vendor_fms>> host_cpuid(0x0, 0, &eax, &ebx, &ecx, &edx);
+ *   - target/i386/host-cpu.c|139| <<host_cpu_vendor_fms>> host_cpuid(0x1, 0, &eax, &ebx, &ecx, &edx);
+ *   - target/i386/host-cpu.c|159| <<host_cpu_instance_init>> host_cpuid(0, 0, NULL, &ebx, &ecx, &edx);
+ *   - target/i386/hvf/x86_cpuid.c|53| <<hvf_get_supported_cpuid>> host_cpuid(func, idx, &eax, &ebx, &ecx, &edx);
+ *   - target/i386/kvm/kvm-cpu.c|109| <<kvm_cpu_xsave_init>> host_cpuid(0xd, i, &eax, &ebx, &ecx, &edx);
+ *   - target/i386/kvm/kvm.c|5182| <<host_supports_vmx>> host_cpuid(1, 0, &unused, &unused, &ecx, &unused);
+ *   - target/i386/sev.c|607| <<sev_get_capabilities>> host_cpuid(0x8000001F, 0, NULL, &ebx, NULL, NULL);
+ *   - target/i386/sev.c|932| <<sev_kvm_init>> host_cpuid(0x8000001F, 0, NULL, &ebx, NULL, NULL);
+ */
 void host_cpuid(uint32_t function, uint32_t count,
                 uint32_t *eax, uint32_t *ebx, uint32_t *ecx, uint32_t *edx)
 {
@@ -4198,6 +4236,14 @@ static void max_x86_cpu_class_init(ObjectClass *oc, void *data)
     device_class_set_props(dc, max_x86_cpu_properties);
 }
 
+/*
+ * 4282 static const TypeInfo max_x86_cpu_type_info = {
+ * 4283     .name = X86_CPU_TYPE_NAME("max"),
+ * 4284     .parent = TYPE_X86_CPU,
+ * 4285     .instance_init = max_x86_cpu_initfn,
+ * 4286     .class_init = max_x86_cpu_class_init,
+ * 4287 };
+ */
 static void max_x86_cpu_initfn(Object *obj)
 {
     X86CPU *cpu = X86_CPU(obj);
@@ -4206,6 +4252,19 @@ static void max_x86_cpu_initfn(Object *obj)
      * "migratable" is true or false.
      */
     cpu->max_features = true;
+    /*
+     * 在以下使用ArchCPU->enable_pmu:
+     *   - target/i386/cpu.c|6994| <<global>> DEFINE_PROP_BOOL("pmu", X86CPU, enable_pmu, false),
+     *   - target/i386/cpu.c|5286| <<cpu_x86_cpuid>> if (!cpu->enable_pmu) {
+     *   - target/i386/cpu.c|5431| <<cpu_x86_cpuid>> if (accel_uses_host_cpuid() && cpu->enable_pmu) {
+     *   - target/i386/cpu.c|5471| <<cpu_x86_cpuid>> if (accel_uses_host_cpuid() && cpu->enable_pmu &&
+     *   - target/i386/cpu.c|5539| <<cpu_x86_cpuid>> if (kvm_enabled() && cpu->enable_pmu &&
+     *   - target/i386/cpu.c|5547| <<cpu_x86_cpuid>> accel_uses_host_cpuid() && cpu->enable_pmu &&
+     *   - target/i386/cpu.c|6475| <<x86_cpu_realizefn>> if (!cpu->enable_pmu) {
+     *   - target/i386/kvm/kvm.c|3161| <<kvm_init_msrs>> if (has_msr_perf_capabs && cpu->enable_pmu) {
+     *   - target/i386/kvm/kvm.c|3484| <<kvm_put_msrs>> if (kvm_enabled() && cpu->enable_pmu &&
+     *   - target/i386/kvm/kvm.c|3923| <<kvm_get_msrs>> if (kvm_enabled() && cpu->enable_pmu &&
+     */
     object_property_set_bool(OBJECT(cpu), "pmu", true, &error_abort);
 
     /*
@@ -4311,6 +4370,31 @@ static void x86_cpuid_version_get_family(Object *obj, Visitor *v,
     visit_type_int(v, name, &value, errp);
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_cpuid_version_set_family (obj=0x555556aa7340, v=0x555556ab5960, name=0x555556072166 "family", opaque=0x0, errp=0x5555567d3638 <error_abort>) at ../target/i386/cpu.c:4317
+ * #1  0x0000555555d289e7 in object_property_set (obj=0x555556aa7340, name=0x555556072166 "family", v=0x555556ab5960, errp=0x5555567d3638 <error_abort>) at ../qom/object.c:1408
+ * #2  0x0000555555d2cd92 in object_property_set_qobject (obj=0x555556aa7340, name=0x555556072166 "family", value=0x555556ab5930, errp=0x5555567d3638 <error_abort>)
+ *                        at ../qom/qom-qobject.c:28
+ * #3  0x0000555555d28ec3 in object_property_set_int (obj=0x555556aa7340, name=0x555556072166 "family", value=23, errp=0x5555567d3638 <error_abort>) at ../qom/object.c:1509
+ * #4  0x0000555555b5f39b in x86_cpu_load_model (cpu=0x555556aa7340, model=0x55555682c1e0) at ../target/i386/cpu.c:5082
+ * #5  0x0000555555b63e51 in x86_cpu_initfn (obj=0x555556aa7340) at ../target/i386/cpu.c:6800
+ * #6  0x0000555555d26830 in object_init_with_type (obj=0x555556aa7340, ti=0x55555681b560) at ../qom/object.c:377
+ * #7  0x0000555555d26812 in object_init_with_type (obj=0x555556aa7340, ti=0x55555682c3e0) at ../qom/object.c:373
+ * #8  0x0000555555d26d62 in object_initialize_with_type (obj=0x555556aa7340, size=50432, type=0x55555682c3e0) at ../qom/object.c:519
+ * #9  0x0000555555d2746c in object_new_with_type (type=0x55555682c3e0) at ../qom/object.c:734
+ * #10 0x0000555555d274c3 in object_new (typename=0x55555682c560 "EPYC-x86_64-cpu") at ../qom/object.c:749
+ * #11 0x0000555555b22e7f in x86_cpu_new (x86ms=0x555556a53be0, apic_id=0, errp=0x5555567d3640 <error_fatal>) at ../hw/i386/x86.c:97
+ * #12 0x0000555555b22fd2 in x86_cpus_init (x86ms=0x555556a53be0, default_cpu_version=1) at ../hw/i386/x86.c:144
+ * #13 0x0000555555b2ea22 in pc_init1 (machine=0x555556a53be0, host_type=0x555556066191 "i440FX-pcihost", pci_type=0x55555606618a "i440FX") at ../hw/i386/pc_piix.c:159
+ * #14 0x0000555555b2f5f2 in pc_init_v7_1 (machine=0x555556a53be0) at ../hw/i386/pc_piix.c:445
+ * #15 0x00005555558a75be in machine_run_board_init (machine=0x555556a53be0, mem_path=0x0, errp=0x5555567d3640 <error_fatal>) at ../hw/core/machine.c:1400
+ * #16 0x0000555555a8000c in qemu_init_board () at ../softmmu/vl.c:2485
+ * #17 0x0000555555a8027d in qmp_x_exit_preconfig (errp=0x5555567d3640 <error_fatal>) at ../softmmu/vl.c:2581
+ * #18 0x0000555555a8290d in qemu_init (argc=18, argv=0x7fffffffdf08, envp=0x0) at ../softmmu/vl.c:3584
+ * #19 0x000055555581fe5d in qemu_main (argc=18, argv=0x7fffffffdf08, envp=0x0) at ../softmmu/main.c:37
+ * #20 0x000055555581fe94 in main (argc=18, argv=0x7fffffffdf08) at ../softmmu/main.c:47
+ */
 static void x86_cpuid_version_set_family(Object *obj, Visitor *v,
                                          const char *name, void *opaque,
                                          Error **errp)
@@ -4916,6 +5000,13 @@ CpuDefinitionInfoList *qmp_query_cpu_definitions(Error **errp)
     return cpu_list;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|6278| <<x86_cpu_expand_features>> x86_cpu_get_supported_feature_word(w, cpu->migratable) &
+ *   - target/i386/cpu.c|6398| <<x86_cpu_filter_features>> x86_cpu_get_supported_feature_word(w, false);
+ *   - target/i386/cpu.c|6509| <<x86_cpu_realizefn>> x86_cpu_get_supported_feature_word(FEAT_PERF_CAPABILITIES, false);
+ *   - target/i386/kvm/kvm-cpu.c|105| <<kvm_cpu_xsave_init>> if ((x86_cpu_get_supported_feature_word(esa->feature, false) & esa->bits)
+ */
 uint64_t x86_cpu_get_supported_feature_word(FeatureWord w,
                                             bool migratable_only)
 {
@@ -5878,6 +5969,27 @@ static void x86_cpu_set_sgxlepubkeyhash(CPUX86State *env)
 #endif
 }
 
+/*
+ * (gdb) bt
+ * #0  x86_cpu_reset (dev=0x555556aa6f30) at ../target/i386/cpu.c:5883
+ * #1  0x0000555555d2195c in device_transitional_reset (obj=0x555556aa6f30) at ../hw/core/qdev.c:823
+ * #2  0x0000555555d235c7 in resettable_phase_hold (obj=0x555556aa6f30, opaque=0x0, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:182
+ * #3  0x0000555555d2317f in resettable_assert_reset (obj=0x555556aa6f30, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:60
+ * #4  0x0000555555d230c3 in resettable_reset (obj=0x555556aa6f30, type=RESET_TYPE_COLD) at ../hw/core/resettable.c:45
+ * #5  0x0000555555d205e2 in device_cold_reset (dev=0x555556aa6f30) at ../hw/core/qdev.c:296
+ * #6  0x000055555582049e in cpu_reset (cpu=0x555556aa6f30) at ../hw/core/cpu-common.c:114
+ * #7  0x0000555555b03810 in x86_cpu_machine_reset_cb (opaque=0x555556aa6f30) at ../target/i386/cpu-sysemu.c:250
+ * #8  0x0000555555d21e0b in qemu_devices_reset () at ../hw/core/reset.c:69
+ * #9  0x0000555555b4d111 in pc_machine_reset (machine=0x555556a53be0) at ../hw/i386/pc.c:1851
+ * #10 0x0000555555a798ac in qemu_system_reset (reason=SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET) at ../softmmu/runstate.c:444
+ * #11 0x0000555555a79f75 in main_loop_should_exit (status=0x7fffffffddc4) at ../softmmu/runstate.c:694
+ * #12 0x0000555555a7a06a in qemu_main_loop () at ../softmmu/runstate.c:730
+ * #13 0x000055555581fe62 in qemu_main (argc=18, argv=0x7fffffffdf18, envp=0x0) at ../softmmu/main.c:38
+ * #14 0x000055555581fe94 in main (argc=18, argv=0x7fffffffdf18) at ../softmmu/main.c:47
+ *
+ * 在以下使用x86_cpu_reset():
+ *   - target/i386/cpu.c|7101| <<x86_cpu_common_class_init>> device_class_set_parent_reset(dc, x86_cpu_reset, &xcc->parent_reset);
+ */
 static void x86_cpu_reset(DeviceState *dev)
 {
     CPUState *s = CPU(dev);
@@ -6379,6 +6491,27 @@ static void x86_cpu_hyperv_realize(X86CPU *cpu)
     cpu->hyperv_limits[2] = 0;
 }
 
+/*
+ * (gdb)
+ * #0  x86_cpu_realizefn (dev=0x555556a91910, errp=0x7fffffffd760) at ../target/i386/cpu.c:6383
+ * #1  0x0000555555d21ded in device_set_realized (obj=0x555556a91910, value=true, errp=0x7fffffffd870) at ../hw/core/qdev.c:553
+ * #2  0x0000555555d2b85d in property_set_bool (obj=0x555556a91910, v=0x555556aa09b0, name=0x5555560ba659 "realized", opaque=0x555556851e10, errp=0x7fffffffd870)
+ *                                             at ../qom/object.c:2273
+ * #3  0x0000555555d298a4 in object_property_set (obj=0x555556a91910, name=0x5555560ba659 "realized", v=0x555556aa09b0, errp=0x7fffffffd870) at ../qom/object.c:1408
+ * #4  0x0000555555d2dc4f in object_property_set_qobject (obj=0x555556a91910, name=0x5555560ba659 "realized", value=0x555556848200, errp=0x5555567d4f80 <error_fatal>) at ../qom/qom-qobject.c:28
+ * #5  0x0000555555d29c09 in object_property_set_bool (obj=0x555556a91910, name=0x5555560ba659 "realized", value=true, errp=0x5555567d4f80 <error_fatal>) at ../qom/object.c:1477
+ * #6  0x0000555555d21585 in qdev_realize (dev=0x555556a91910, bus=0x0, errp=0x5555567d4f80 <error_fatal>) at ../hw/core/qdev.c:333
+ * #7  0x0000555555b23c6f in x86_cpu_new (x86ms=0x555556a546e0, apic_id=0, errp=0x5555567d4f80 <error_fatal>) at ../hw/i386/x86.c:102
+ * #8  0x0000555555b23d79 in x86_cpus_init (x86ms=0x555556a546e0, default_cpu_version=1) at ../hw/i386/x86.c:144
+ * #9  0x0000555555b2f7c9 in pc_init1 (machine=0x555556a546e0, host_type=0x555556067d41 "i440FX-pcihost", pci_type=0x555556067d3a "i440FX") at ../hw/i386/pc_piix.c:159
+ * #10 0x0000555555b30399 in pc_init_v7_1 (machine=0x555556a546e0) at ../hw/i386/pc_piix.c:445
+ * #11 0x00005555558a870e in machine_run_board_init (machine=0x555556a546e0, mem_path=0x0, errp=0x5555567d4f80 <error_fatal>) at ../hw/core/machine.c:1400
+ * #12 0x0000555555a80fcc in qemu_init_board () at ../softmmu/vl.c:2492
+ * #13 0x0000555555a8123d in qmp_x_exit_preconfig (errp=0x5555567d4f80 <error_fatal>) at ../softmmu/vl.c:2588
+ * #14 0x0000555555a83915 in qemu_init (argc=15, argv=0x7fffffffdee8, envp=0x0) at ../softmmu/vl.c:3591
+ * #15 0x0000555555820fad in qemu_main (argc=15, argv=0x7fffffffdee8, envp=0x0) at ../softmmu/main.c:37
+ * #16 0x0000555555820fe4 in main (argc=15, argv=0x7fffffffdee8) at ../softmmu/main.c:47
+ */
 static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
diff --git a/target/i386/cpu.h b/target/i386/cpu.h
index 82004b65b..ea61e0d36 100644
--- a/target/i386/cpu.h
+++ b/target/i386/cpu.h
@@ -428,8 +428,21 @@ typedef enum X86Seg {
 #define MSR_MCG_CTL                     0x17b
 #define MSR_MCG_EXT_CTL                 0x4d0
 
+/*
+ * 在以下使用MSR_P6_EVNTSEL0:
+ *   - target/i386/cpu.h|1319| <<MAX_GP_COUNTERS>> #define MAX_GP_COUNTERS (MSR_IA32_PERF_STATUS - MSR_P6_EVNTSEL0)
+ *   - target/i386/kvm/kvm.c|3380| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i,
+ *   - target/i386/kvm/kvm.c|3880| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);
+ *   - target/i386/kvm/kvm.c|4166| <<kvm_get_msrs>> case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:
+ *   - target/i386/kvm/kvm.c|4167| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+ */
 #define MSR_P6_EVNTSEL0                 0x186
 
+/*
+ * 在以下使用MSR_IA32_PERF_STATUS:
+ *   - target/i386/cpu.h|1327| <<MAX_GP_COUNTERS>> #define MAX_GP_COUNTERS (MSR_IA32_PERF_STATUS - MSR_P6_EVNTSEL0)
+ *   - target/i386/tcg/sysemu/misc_helper.c|346| <<helper_rdmsr>> case MSR_IA32_PERF_STATUS:
+ */
 #define MSR_IA32_PERF_STATUS            0x198
 
 #define MSR_IA32_MISC_ENABLE            0x1a0
@@ -948,6 +961,15 @@ uint64_t x86_cpu_get_supported_feature_word(FeatureWord w,
 #define IS_INTEL_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_INTEL_1 && \
                            (env)->cpuid_vendor2 == CPUID_VENDOR_INTEL_2 && \
                            (env)->cpuid_vendor3 == CPUID_VENDOR_INTEL_3)
+/*
+ * 在以下使用IS_AMD_CPU():
+ *   - hw/i386/pc.c|957| <<pc_memory_init>> if (IS_AMD_CPU(&cpu->env) && pcmc->enforce_amd_1tb_hole) {
+ *   - target/i386/cpu.c|5273| <<cpu_x86_cpuid>> } else if (cpu->vendor_cpuid_only && IS_AMD_CPU(env)) {
+ *   - target/i386/cpu.c|5309| <<cpu_x86_cpuid>> } else if (cpu->vendor_cpuid_only && IS_AMD_CPU(env)) {
+ *   - target/i386/cpu.c|6478| <<x86_cpu_realizefn>> if (IS_AMD_CPU(env)) {
+ *   - target/i386/cpu.c|6510| <<x86_cpu_realizefn>> if (IS_AMD_CPU(env)) {
+ *   - target/i386/cpu.c|6623| <<x86_cpu_realizefn>> if (IS_AMD_CPU(env) &&
+ */
 #define IS_AMD_CPU(env) ((env)->cpuid_vendor1 == CPUID_VENDOR_AMD_1 && \
                          (env)->cpuid_vendor2 == CPUID_VENDOR_AMD_2 && \
                          (env)->cpuid_vendor3 == CPUID_VENDOR_AMD_3)
@@ -1306,7 +1328,28 @@ typedef struct {
 #define CPU_NB_REGS CPU_NB_REGS32
 #endif
 
+/*
+ * 在以下使用MAX_FIXED_COUNTERS:
+ *   - target/i386/machine.c|686| <<global>> VMSTATE_UINT64_ARRAY(env.msr_fixed_counters, X86CPU, MAX_FIXED_COUNTERS),
+ *   - target/i386/cpu.h|1616| <<MMREG_UNION>> uint64_t msr_fixed_counters[MAX_FIXED_COUNTERS];
+ *   - target/i386/kvm/kvm.c|2009| <<kvm_arch_init_vcpu>> if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
+ *   - target/i386/kvm/kvm.c|2010| <<kvm_arch_init_vcpu>> num_architectural_pmu_fixed_counters = MAX_FIXED_COUNTERS;
+ *   - target/i386/kvm/kvm.c|4160| <<kvm_get_msrs>> case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:
+ *   - target/i386/machine.c|655| <<pmu_enable_needed>> for (i = 0; i < MAX_FIXED_COUNTERS; i++) {
+ */
 #define MAX_FIXED_COUNTERS 3
+/*
+ * 在以下使用MAX_GP_COUNTERS:
+ *   - target/i386/machine.c|687| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_counters, X86CPU, MAX_GP_COUNTERS),
+ *   - target/i386/machine.c|688| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_evtsel, X86CPU, MAX_GP_COUNTERS),
+ *   - target/i386/cpu.h|1617| <<MMREG_UNION>> uint64_t msr_gp_counters[MAX_GP_COUNTERS];
+ *   - target/i386/cpu.h|1625| <<MMREG_UNION>> uint64_t msr_gp_evtsel[MAX_GP_COUNTERS];
+ *   - target/i386/kvm/kvm.c|2002| <<kvm_arch_init_vcpu>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+ *   - target/i386/kvm/kvm.c|2003| <<kvm_arch_init_vcpu>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+ *   - target/i386/kvm/kvm.c|4163| <<kvm_get_msrs>> case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:
+ *   - target/i386/kvm/kvm.c|4166| <<kvm_get_msrs>> case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:
+ *   - target/i386/machine.c|667| <<pmu_enable_needed>> for (i = 0; i < MAX_GP_COUNTERS; i++) {
+ */
 #define MAX_GP_COUNTERS    (MSR_IA32_PERF_STATUS - MSR_P6_EVNTSEL0)
 
 #define TARGET_INSN_START_EXTRA_WORDS 1
@@ -1598,6 +1641,13 @@ typedef struct CPUArchState {
     uint64_t msr_global_ovf_ctrl;
     uint64_t msr_fixed_counters[MAX_FIXED_COUNTERS];
     uint64_t msr_gp_counters[MAX_GP_COUNTERS];
+    /*
+     * 在以下使用CPUArchState->msr_gp_evtsel[MAX_GP_COUNTERS]:
+     *   - target/i386/machine.c|678| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_evtsel, X86CPU, MAX_GP_COUNTERS),
+     *   - target/i386/kvm/kvm.c|3314| <<kvm_put_msrs>> env->msr_gp_evtsel[i]);
+     *   - target/i386/kvm/kvm.c|4088| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+     *   - target/i386/machine.c|658| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+     */
     uint64_t msr_gp_evtsel[MAX_GP_COUNTERS];
 
     uint64_t pat;
@@ -1713,6 +1763,29 @@ typedef struct CPUArchState {
     uint32_t cpuid_vendor1;
     uint32_t cpuid_vendor2;
     uint32_t cpuid_vendor3;
+    /*
+     * 在以下使用CPUArchState->cpuid_version:
+     *   - hw/i386/fw_cfg.c|61| <<fw_cfg_build_smbios>> smbios_set_cpuid(cpu->env.cpuid_version, cpu->env.features[FEAT_1_EDX]);
+     *   - target/i386/cpu.c|4366| <<x86_cpuid_version_get_family>> value = (env->cpuid_version >> 8) & 0xf;
+     *   - target/i386/cpu.c|4368| <<x86_cpuid_version_get_family>> value += (env->cpuid_version >> 20) & 0xff;
+     *   - target/i386/cpu.c|4392| <<x86_cpuid_version_set_family>> env->cpuid_version &= ~0xff00f00;
+     *   - target/i386/cpu.c|4394| <<x86_cpuid_version_set_family>> env->cpuid_version |= 0xf00 | ((value - 0x0f) << 20);
+     *   - target/i386/cpu.c|4396| <<x86_cpuid_version_set_family>> env->cpuid_version |= value << 8;
+     *   - target/i386/cpu.c|4408| <<x86_cpuid_version_get_model>> value = (env->cpuid_version >> 4) & 0xf;
+     *   - target/i386/cpu.c|4409| <<x86_cpuid_version_get_model>> value |= ((env->cpuid_version >> 16) & 0xf) << 4;
+     *   - target/i386/cpu.c|4432| <<x86_cpuid_version_set_model>> env->cpuid_version &= ~0xf00f0;
+     *   - target/i386/cpu.c|4433| <<x86_cpuid_version_set_model>> env->cpuid_version |= ((value & 0xf) << 4) | ((value >> 4) << 16);
+     *   - target/i386/cpu.c|4444| <<x86_cpuid_version_get_stepping>> value = env->cpuid_version & 0xf;
+     *   - target/i386/cpu.c|4467| <<x86_cpuid_version_set_stepping>> env->cpuid_version &= ~0xf;
+     *   - target/i386/cpu.c|4468| <<x86_cpuid_version_set_stepping>> env->cpuid_version |= value & 0xf;
+     *   - target/i386/cpu.c|5318| <<cpu_x86_cpuid>> *eax = env->cpuid_version;
+     *   - target/i386/cpu.c|5759| <<cpu_x86_cpuid>> *eax = env->cpuid_version;
+     *   - target/i386/cpu.c|5903| <<cpu_x86_cpuid>> *eax = env->cpuid_version;
+     *   - target/i386/cpu.c|6022| <<x86_cpu_reset>> env->regs[R_EDX] = env->cpuid_version;
+     *   - target/i386/cpu.c|6129| <<mce_init>> if (((cenv->cpuid_version >> 8) & 0xf) >= 6
+     *   - target/i386/helper.c|64| <<cpu_x86_version>> int cpuver = env->cpuid_version;
+     *   - target/i386/kvm/kvm.c|2128| <<kvm_arch_init_vcpu>> if (((env->cpuid_version >> 8)&0xF) >= 6
+     */
     uint32_t cpuid_version;
     FeatureWordArray features;
     /* Features that were explicitly enabled/disabled */
@@ -1855,6 +1928,19 @@ struct ArchCPU {
      * bits returned by GET_SUPPORTED_CPUID (that depend on host CPU and kernel
      * capabilities) directly to the guest.
      */
+    /*
+     * 在以下使用ArchCPU->enable_pmu:
+     *   - target/i386/cpu.c|6994| <<global>> DEFINE_PROP_BOOL("pmu", X86CPU, enable_pmu, false),
+     *   - target/i386/cpu.c|5286| <<cpu_x86_cpuid>> if (!cpu->enable_pmu) {
+     *   - target/i386/cpu.c|5431| <<cpu_x86_cpuid>> if (accel_uses_host_cpuid() && cpu->enable_pmu) {
+     *   - target/i386/cpu.c|5471| <<cpu_x86_cpuid>> if (accel_uses_host_cpuid() && cpu->enable_pmu &&
+     *   - target/i386/cpu.c|5539| <<cpu_x86_cpuid>> if (kvm_enabled() && cpu->enable_pmu &&
+     *   - target/i386/cpu.c|5547| <<cpu_x86_cpuid>> accel_uses_host_cpuid() && cpu->enable_pmu &&
+     *   - target/i386/cpu.c|6475| <<x86_cpu_realizefn>> if (!cpu->enable_pmu) {
+     *   - target/i386/kvm/kvm.c|3161| <<kvm_init_msrs>> if (has_msr_perf_capabs && cpu->enable_pmu) {
+     *   - target/i386/kvm/kvm.c|3484| <<kvm_put_msrs>> if (kvm_enabled() && cpu->enable_pmu &&
+     *   - target/i386/kvm/kvm.c|3923| <<kvm_get_msrs>> if (kvm_enabled() && cpu->enable_pmu &&
+     */
     bool enable_pmu;
 
     /*
@@ -2098,6 +2184,18 @@ static inline int x86_asidx_from_attrs(CPUState *cs, MemTxAttrs attrs)
     return !!attrs.secure;
 }
 
+/*
+ * called by:
+ *   - target/i386/helper.c|602| <<x86_ldub_phys>> AddressSpace *as = cpu_addressspace(cs, attrs);
+ *   - target/i386/helper.c|612| <<x86_lduw_phys>> AddressSpace *as = cpu_addressspace(cs, attrs);
+ *   - target/i386/helper.c|622| <<x86_ldl_phys>> AddressSpace *as = cpu_addressspace(cs, attrs);
+ *   - target/i386/helper.c|632| <<x86_ldq_phys>> AddressSpace *as = cpu_addressspace(cs, attrs);
+ *   - target/i386/helper.c|642| <<x86_stb_phys>> AddressSpace *as = cpu_addressspace(cs, attrs);
+ *   - target/i386/helper.c|652| <<x86_stl_phys_notdirty>> AddressSpace *as = cpu_addressspace(cs, attrs);
+ *   - target/i386/helper.c|662| <<x86_stw_phys>> AddressSpace *as = cpu_addressspace(cs, attrs);
+ *   - target/i386/helper.c|672| <<x86_stl_phys>> AddressSpace *as = cpu_addressspace(cs, attrs);
+ *   - target/i386/helper.c|682| <<x86_stq_phys>> AddressSpace *as = cpu_addressspace(cs, attrs);
+ */
 static inline AddressSpace *cpu_addressspace(CPUState *cs, MemTxAttrs attrs)
 {
     return cpu_get_address_space(cs, cpu_asidx_from_attrs(cs, attrs));
diff --git a/target/i386/host-cpu.c b/target/i386/host-cpu.c
index 10f8aba86..d357a1dd3 100644
--- a/target/i386/host-cpu.c
+++ b/target/i386/host-cpu.c
@@ -80,6 +80,11 @@ static uint32_t host_cpu_adjust_phys_bits(X86CPU *cpu)
     return phys_bits;
 }
 
+/*
+ * 在以下使用host_cpu_realizefn():
+ *   - target/i386/hvf/hvf-cpu.c|80| <<hvf_cpu_accel_class_init>> acc->cpu_realizefn = host_cpu_realizefn;
+ *   - target/i386/kvm/kvm-cpu.c|52| <<kvm_cpu_realizefn>> return host_cpu_realizefn(cs, errp);
+ */
 bool host_cpu_realizefn(CPUState *cs, Error **errp)
 {
     X86CPU *cpu = X86_CPU(cs);
@@ -193,6 +198,28 @@ static void host_cpu_class_init(ObjectClass *oc, void *data)
         g_strdup_printf("processor with all supported host features ");
 }
 
+/*
+ * 在以下使用ArchCPU->enable_pmu:
+ *   - target/i386/cpu.c|6994| <<global>> DEFINE_PROP_BOOL("pmu", X86CPU, enable_pmu, false),
+ *   - target/i386/cpu.c|5286| <<cpu_x86_cpuid>> if (!cpu->enable_pmu) {
+ *   - target/i386/cpu.c|5431| <<cpu_x86_cpuid>> if (accel_uses_host_cpuid() && cpu->enable_pmu) {
+ *   - target/i386/cpu.c|5471| <<cpu_x86_cpuid>> if (accel_uses_host_cpuid() && cpu->enable_pmu &&
+ *   - target/i386/cpu.c|5539| <<cpu_x86_cpuid>> if (kvm_enabled() && cpu->enable_pmu &&
+ *   - target/i386/cpu.c|5547| <<cpu_x86_cpuid>> accel_uses_host_cpuid() && cpu->enable_pmu &&
+ *   - target/i386/cpu.c|6475| <<x86_cpu_realizefn>> if (!cpu->enable_pmu) {
+ *   - target/i386/kvm/kvm.c|3161| <<kvm_init_msrs>> if (has_msr_perf_capabs && cpu->enable_pmu) {
+ *   - target/i386/kvm/kvm.c|3484| <<kvm_put_msrs>> if (kvm_enabled() && cpu->enable_pmu &&
+ *   - target/i386/kvm/kvm.c|3923| <<kvm_get_msrs>> if (kvm_enabled() && cpu->enable_pmu &&
+ *
+ * 关于.parent = X86_CPU_TYPE_NAME("max"),
+ *
+ * 4253 static const TypeInfo max_x86_cpu_type_info = {
+ * 4254     .name = X86_CPU_TYPE_NAME("max"),
+ * 4255     .parent = TYPE_X86_CPU,
+ * 4256     .instance_init = max_x86_cpu_initfn,
+ * 4257     .class_init = max_x86_cpu_class_init,
+ * 4258 };
+ */
 static const TypeInfo host_cpu_type_info = {
     .name = X86_CPU_TYPE_NAME("host"),
     .parent = X86_CPU_TYPE_NAME("max"),
diff --git a/target/i386/kvm/kvm-cpu.c b/target/i386/kvm/kvm-cpu.c
index 7237378a7..68c1db7a0 100644
--- a/target/i386/kvm/kvm-cpu.c
+++ b/target/i386/kvm/kvm-cpu.c
@@ -193,6 +193,16 @@ static void kvm_cpu_accel_class_init(ObjectClass *oc, void *data)
     acc->cpu_realizefn = kvm_cpu_realizefn;
     acc->cpu_instance_init = kvm_cpu_instance_init;
 }
+/*
+ * 在以下使用TYPE_ACCEL_CPU:
+ *   - include/hw/core/accel-cpu.h|23| <<global>> #define TYPE_ACCEL_CPU "accel-" CPU_RESOLVING_TYPE
+ *   - accel/accel-common.c|133| <<global>> .name = TYPE_ACCEL_CPU,
+ *   - target/i386/hvf/hvf-cpu.c|87| <<global>> .parent = TYPE_ACCEL_CPU,
+ *   - target/i386/kvm/kvm-cpu.c|199| <<global>> .parent = TYPE_ACCEL_CPU,
+ *   - target/i386/tcg/tcg-cpu.c|152| <<global>> .parent = TYPE_ACCEL_CPU,
+ *   - include/hw/core/accel-cpu.h|24| <<ACCEL_CPU_NAME>> #define ACCEL_CPU_NAME(name) (name "-" TYPE_ACCEL_CPU)
+ *   - include/hw/core/accel-cpu.h|26| <<DECLARE_CLASS_CHECKERS>> DECLARE_CLASS_CHECKERS(AccelCPUClass, ACCEL_CPU, TYPE_ACCEL_CPU)
+ */
 static const TypeInfo kvm_cpu_accel_type_info = {
     .name = ACCEL_CPU_NAME("kvm"),
 
diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index f148a6d52..0cc12a410 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -119,11 +119,43 @@ static bool has_msr_core_capabs;
 static bool has_msr_vmx_vmfunc;
 static bool has_msr_ucode_rev;
 static bool has_msr_vmx_procbased_ctls2;
+/*
+ * 在以下使用has_msr_perf_capabs:
+ *   - target/i386/kvm/kvm.c|2410| <<kvm_get_supported_msrs>> has_msr_perf_capabs = true;
+ *   - target/i386/kvm/kvm.c|3161| <<kvm_init_msrs>> if (has_msr_perf_capabs && cpu->enable_pmu) {
+ */
 static bool has_msr_perf_capabs;
 static bool has_msr_pkrs;
 
+/*
+ * 在以下使用has_architectural_pmu_version:
+ *   - target/i386/kvm/kvm.c|1939| <<kvm_arch_init_vcpu>> has_architectural_pmu_version = eax & 0xff;
+ *   - target/i386/kvm/kvm.c|1940| <<kvm_arch_init_vcpu>> if (has_architectural_pmu_version > 0) {
+ *   - target/i386/kvm/kvm.c|1951| <<kvm_arch_init_vcpu>> if (has_architectural_pmu_version > 1) {
+ *   - target/i386/kvm/kvm.c|3256| <<kvm_put_msrs>> if (has_architectural_pmu_version > 0) {
+ *   - target/i386/kvm/kvm.c|3257| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+ *   - target/i386/kvm/kvm.c|3274| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+ *   - target/i386/kvm/kvm.c|3747| <<kvm_get_msrs>> if (has_architectural_pmu_version > 0) {
+ *   - target/i386/kvm/kvm.c|3748| <<kvm_get_msrs>> if (has_architectural_pmu_version > 1) {
+ */
 static uint32_t has_architectural_pmu_version;
+/*
+ * 在以下使用num_architectural_pmu_gp_counters:
+ *   - target/i386/kvm/kvm.c|1941| <<kvm_arch_init_vcpu>> num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
+ *   - target/i386/kvm/kvm.c|1947| <<kvm_arch_init_vcpu>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+ *   - target/i386/kvm/kvm.c|1948| <<kvm_arch_init_vcpu>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+ *   - target/i386/kvm/kvm.c|3268| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+ *   - target/i386/kvm/kvm.c|3757| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+ */
 static uint32_t num_architectural_pmu_gp_counters;
+/*
+ * 在以下使用num_architectural_pmu_fixed_counters:
+ *   - target/i386/kvm/kvm.c|1986| <<kvm_arch_init_vcpu>> num_architectural_pmu_fixed_counters = edx & 0x1f;
+ *   - target/i386/kvm/kvm.c|1988| <<kvm_arch_init_vcpu>> if (num_architectural_pmu_fixed_counters > MAX_FIXED_COUNTERS) {
+ *   - target/i386/kvm/kvm.c|1989| <<kvm_arch_init_vcpu>> num_architectural_pmu_fixed_counters = MAX_FIXED_COUNTERS;
+ *   - target/i386/kvm/kvm.c|3298| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+ *   - target/i386/kvm/kvm.c|3788| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
+ */
 static uint32_t num_architectural_pmu_fixed_counters;
 
 static int has_xsave;
@@ -246,6 +278,10 @@ void kvm_synchronize_all_tsc(void)
     }
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|317| <<get_supported_cpuid>> while ((cpuid = try_get_cpuid(s, max)) == NULL) {
+ */
 static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 {
     struct kvm_cpuid2 *cpuid;
@@ -274,6 +310,10 @@ static struct kvm_cpuid2 *try_get_cpuid(KVMState *s, int max)
 /* Run KVM_GET_SUPPORTED_CPUID ioctl(), allocating a buffer large enough
  * for all entries.
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|385| <<kvm_arch_get_supported_cpuid>> cpuid = get_supported_cpuid(s);
+ */
 static struct kvm_cpuid2 *get_supported_cpuid(KVMState *s)
 {
     struct kvm_cpuid2 *cpuid;
@@ -327,6 +367,14 @@ static uint32_t cpuid_entry_get_reg(struct kvm_cpuid_entry2 *entry, int reg)
 
 /* Find matching entry for function/index on kvm_cpuid2 struct
  */
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|428| <<kvm_arch_get_supported_cpuid>> struct kvm_cpuid_entry2 *entry = cpuid_find_entry(cpuid, function, index);
+ *   - target/i386/kvm/kvm.c|1287| <<hv_cpuid_get_host>> entry = cpuid_find_entry(cpuid, func, 0);
+ *   - target/i386/kvm/kvm.c|2160| <<kvm_arch_init_vcpu>> c = cpuid_find_entry(&cpuid_data.cpuid, 1, 0);
+ *   - target/i386/kvm/kvm.c|2166| <<kvm_arch_init_vcpu>> c = cpuid_find_entry(&cpuid_data.cpuid, 7, 0);
+ *   - target/i386/kvm/kvm.c|2203| <<kvm_arch_init_vcpu>> c = cpuid_find_entry(&cpuid_data.cpuid, kvm_base, 0);
+ */
 static struct kvm_cpuid_entry2 *cpuid_find_entry(struct kvm_cpuid2 *cpuid,
                                                  uint32_t function,
                                                  uint32_t index)
@@ -342,6 +390,35 @@ static struct kvm_cpuid_entry2 *cpuid_find_entry(struct kvm_cpuid2 *cpuid,
     return NULL;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|4987| <<x86_cpu_get_supported_feature_word>> r = kvm_arch_get_supported_cpuid(kvm_state, wi->cpuid.eax,
+ *   - target/i386/cpu.c|5024| <<x86_cpu_get_supported_cpuid>> *eax = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_EAX);
+ *   - target/i386/cpu.c|5025| <<x86_cpu_get_supported_cpuid>> *ebx = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_EBX);
+ *   - target/i386/cpu.c|5026| <<x86_cpu_get_supported_cpuid>> *ecx = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_ECX);
+ *   - target/i386/cpu.c|5027| <<x86_cpu_get_supported_cpuid>> *edx = kvm_arch_get_supported_cpuid(kvm_state, func, index, R_EDX);
+ *   - target/i386/cpu.c|5436| <<cpu_x86_cpuid>> !(kvm_arch_get_supported_cpuid(cs->kvm_state, 0x7, 0, R_EBX) &
+ *   - target/i386/cpu.c|5443| <<cpu_x86_cpuid>> !(kvm_arch_get_supported_cpuid(cs->kvm_state, 0x7, 0, R_ECX) &
+ *   - target/i386/cpu.c|6407| <<x86_cpu_filter_features>> uint32_t eax_0 = kvm_arch_get_supported_cpuid(s, 0x14, 0, R_EAX);
+ *   - target/i386/cpu.c|6408| <<x86_cpu_filter_features>> uint32_t ebx_0 = kvm_arch_get_supported_cpuid(s, 0x14, 0, R_EBX);
+ *   - target/i386/cpu.c|6409| <<x86_cpu_filter_features>> uint32_t ecx_0 = kvm_arch_get_supported_cpuid(s, 0x14, 0, R_ECX);
+ *   - target/i386/cpu.c|6410| <<x86_cpu_filter_features>> uint32_t eax_1 = kvm_arch_get_supported_cpuid(s, 0x14, 1, R_EAX);
+ *   - target/i386/cpu.c|6411| <<x86_cpu_filter_features>> uint32_t ebx_1 = kvm_arch_get_supported_cpuid(s, 0x14, 1, R_EBX);
+ *   - target/i386/kvm/kvm-cpu.c|77| <<kvm_cpu_max_instance_init>> kvm_arch_get_supported_cpuid(s, 0x0, 0, R_EAX);
+ *   - target/i386/kvm/kvm-cpu.c|79| <<kvm_cpu_max_instance_init>> kvm_arch_get_supported_cpuid(s, 0x80000000, 0, R_EAX);
+ *   - target/i386/kvm/kvm-cpu.c|81| <<kvm_cpu_max_instance_init>> kvm_arch_get_supported_cpuid(s, 0xC0000000, 0, R_EAX);
+ *   - target/i386/kvm/kvm.c|480| <<kvm_arch_get_supported_cpuid>> cpuid_1_edx = kvm_arch_get_supported_cpuid(s, 1, 0, R_EDX);
+ *   - target/i386/kvm/kvm.c|537| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 0xD, 1, R_ECX) &
+ *   - target/i386/kvm/kvm.c|541| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 1, 0, R_ECX) &
+ *   - target/i386/kvm/kvm.c|545| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 7, 0, R_EBX) &
+ *   - target/i386/kvm/kvm.c|549| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 7, 0, R_EBX) &
+ *   - target/i386/kvm/kvm.c|553| <<kvm_arch_get_supported_msr_feature>> if (kvm_arch_get_supported_cpuid(s, 0x80000001, 0, R_EDX) &
+ *   - target/i386/kvm/kvm.c|1726| <<kvm_init_xsave>> assert(kvm_arch_get_supported_cpuid(kvm_state, 0xd, 0, R_ECX) <=
+ *   - target/i386/kvm/kvm.c|3521| <<kvm_put_msrs>> int addr_num = kvm_arch_get_supported_cpuid(kvm_state,
+ *   - target/i386/kvm/kvm.c|3973| <<kvm_get_msrs>> kvm_arch_get_supported_cpuid(kvm_state, 0x14, 1, R_EAX) & 0x7;
+ *   - target/i386/kvm/kvm.c|5579| <<kvm_request_xsave_components>> supported = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);
+ *   - target/i386/kvm/kvm.c|5580| <<kvm_request_xsave_components>> supported |= (uint64_t)kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX) << 32;
+ */
 uint32_t kvm_arch_get_supported_cpuid(KVMState *s, uint32_t function,
                                       uint32_t index, int reg)
 {
@@ -350,6 +427,10 @@ uint32_t kvm_arch_get_supported_cpuid(KVMState *s, uint32_t function,
     uint32_t cpuid_1_edx;
     uint64_t bitmask;
 
+    /*
+     * called by:
+     *   - target/i386/kvm/kvm.c|385| <<kvm_arch_get_supported_cpuid>> cpuid = get_supported_cpuid(s);
+     */
     cpuid = get_supported_cpuid(s);
 
     struct kvm_cpuid_entry2 *entry = cpuid_find_entry(cpuid, function, index);
@@ -1695,6 +1776,10 @@ static void kvm_init_xsave(CPUX86State *env)
            env->xsave_buf_len);
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|519| <<kvm_init_vcpu>> ret = kvm_arch_init_vcpu(cpu);
+ */
 int kvm_arch_init_vcpu(CPUState *cs)
 {
     struct {
@@ -1936,8 +2021,27 @@ int kvm_arch_init_vcpu(CPUState *cs)
 
         cpu_x86_cpuid(env, 0x0a, 0, &eax, &unused, &unused, &edx);
 
+	/*
+	 * 在以下使用has_architectural_pmu_version:
+	 *   - target/i386/kvm/kvm.c|1939| <<kvm_arch_init_vcpu>> has_architectural_pmu_version = eax & 0xff;
+	 *   - target/i386/kvm/kvm.c|1940| <<kvm_arch_init_vcpu>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|1951| <<kvm_arch_init_vcpu>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|3256| <<kvm_put_msrs>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|3257| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|3274| <<kvm_put_msrs>> if (has_architectural_pmu_version > 1) {
+	 *   - target/i386/kvm/kvm.c|3747| <<kvm_get_msrs>> if (has_architectural_pmu_version > 0) {
+	 *   - target/i386/kvm/kvm.c|3748| <<kvm_get_msrs>> if (has_architectural_pmu_version > 1) {
+	 */
         has_architectural_pmu_version = eax & 0xff;
         if (has_architectural_pmu_version > 0) {
+            /*
+	     * 在以下使用num_architectural_pmu_gp_counters:
+	     *   - target/i386/kvm/kvm.c|1941| <<kvm_arch_init_vcpu>> num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
+	     *   - target/i386/kvm/kvm.c|1947| <<kvm_arch_init_vcpu>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+	     *   - target/i386/kvm/kvm.c|1948| <<kvm_arch_init_vcpu>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+	     *   - target/i386/kvm/kvm.c|3268| <<kvm_put_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	     *   - target/i386/kvm/kvm.c|3757| <<kvm_get_msrs>> for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
+	     */
             num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
 
             /* Shouldn't be more than 32, since that's the number of bits
@@ -2111,6 +2215,9 @@ int kvm_arch_init_vcpu(CPUState *cs)
     cpuid_data.cpuid.nent = cpuid_i;
 
     cpuid_data.cpuid.padding = 0;
+    /*
+     * 只在此处使用KVM_SET_CPUID2.
+     */
     r = kvm_vcpu_ioctl(cs, KVM_SET_CPUID2, &cpuid_data);
     if (r) {
         goto fail;
@@ -2176,6 +2283,10 @@ int kvm_arch_destroy_vcpu(CPUState *cs)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/cpu.c|6027| <<x86_cpu_reset>> kvm_arch_reset_vcpu(cpu);
+ */
 void kvm_arch_reset_vcpu(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -2253,6 +2364,10 @@ static int kvm_get_supported_feature_msrs(KVMState *s)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2515| <<kvm_arch_init>> ret = kvm_get_supported_msrs(s);
+ */
 static int kvm_get_supported_msrs(KVMState *s)
 {
     int ret = 0;
@@ -2361,6 +2476,11 @@ static int kvm_get_supported_msrs(KVMState *s)
                 has_msr_core_capabs = true;
                 break;
             case MSR_IA32_PERF_CAPABILITIES:
+                /*
+		 * 在以下使用has_msr_perf_capabs:
+                 *   - target/i386/kvm/kvm.c|2410| <<kvm_get_supported_msrs>> has_msr_perf_capabs = true;
+                 *   - target/i386/kvm/kvm.c|3161| <<kvm_init_msrs>> if (has_msr_perf_capabs && cpu->enable_pmu) {
+		 */
                 has_msr_perf_capabs = true;
                 break;
             case MSR_IA32_VMX_VMFUNC:
@@ -2418,6 +2538,72 @@ static void register_smram_listener(Notifier *n, void *unused)
                                  &smram_address_space, 1, "kvm-smram");
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_arch_init (ms=0x555556a54770, s=0x555556847200) at ../target/i386/kvm/kvm.c:2426
+ * #1  0x0000555555d0e59a in kvm_init (ms=0x555556a54770) at ../accel/kvm/kvm-all.c:2618
+ * #2  0x0000555555af1814 in accel_init_machine (accel=0x555556847200, ms=0x555556a54770) at ../accel/accel-softmmu.c:39
+ * #3  0x0000555555a80590 in do_configure_accelerator (opaque=0x7fffffffdbb5, opts=0x555556a714b0, errp=0x5555567d4f80 <error_fatal>) at ../softmmu/vl.c:2196
+ * #4  0x0000555555ef7c39 in qemu_opts_foreach
+ *     (list=0x5555566d5580 <qemu_accel_opts>, func=0x555555a8046a <do_configure_accelerator>, opaque=0x7fffffffdbb5, errp=0x5555567d4f80 <error_fatal>) at ../util/qemu-option.c:1135
+ * #5  0x0000555555a807f1 in configure_accelerators (progname=0x7fffffffe1fd "/home/opc/ext4/qemu-7.1.0/build/x86_64-softmmu/qemu-system-x86_64") at ../softmmu/vl.c:2262
+ * #6  0x0000555555a837c3 in qemu_init (argc=18, argv=0x7fffffffdeb8, envp=0x0) at ../softmmu/vl.c:3533
+ * #7  0x0000555555820fad in qemu_main (argc=18, argv=0x7fffffffdeb8, envp=0x0) at ../softmmu/main.c:37
+ * #8  0x0000555555820fe4 in main (argc=18, argv=0x7fffffffdeb8) at ../softmmu/main.c:47
+ *
+ * (gdb) bt
+ * #0  max_x86_cpu_initfn (obj=0x555556a91b10) at ../target/i386/cpu.c:4203
+ * #1  0x0000555555d275a3 in object_init_with_type (obj=0x555556a91b10, ti=0x55555682ea10) at ../qom/object.c:377
+ * #2  0x0000555555d27585 in object_init_with_type (obj=0x555556a91b10, ti=0x55555682ed70) at ../qom/object.c:373
+ * #3  0x0000555555d27ad5 in object_initialize_with_type (obj=0x555556a91b10, size=50432, type=0x55555682ed70) at ../qom/object.c:519
+ * #4  0x0000555555d281df in object_new_with_type (type=0x55555682ed70) at ../qom/object.c:734
+ * #5  0x0000555555d28236 in object_new (typename=0x55555682eef0 "host-x86_64-cpu") at ../qom/object.c:749
+ * #6  0x0000555555b23be1 in x86_cpu_new (x86ms=0x555556a54770, apic_id=0, errp=0x5555567d4f80 <error_fatal>) at ../hw/i386/x86.c:97
+ * #7  0x0000555555b23d34 in x86_cpus_init (x86ms=0x555556a54770, default_cpu_version=1) at ../hw/i386/x86.c:144
+ * #8  0x0000555555b2f784 in pc_init1 (machine=0x555556a54770, host_type=0x555556067ce1 "i440FX-pcihost", pci_type=0x555556067cda "i440FX") at ../hw/i386/pc_piix.c:159
+ * #9  0x0000555555b30354 in pc_init_v7_1 (machine=0x555556a54770) at ../hw/i386/pc_piix.c:445
+ * #10 0x00005555558a870e in machine_run_board_init (machine=0x555556a54770, mem_path=0x0, errp=0x5555567d4f80 <error_fatal>) at ../hw/core/machine.c:1400
+ * #11 0x0000555555a80f7c in qemu_init_board () at ../softmmu/vl.c:2485
+ * #12 0x0000555555a811ed in qmp_x_exit_preconfig (errp=0x5555567d4f80 <error_fatal>) at ../softmmu/vl.c:2581
+ * #13 0x0000555555a838c5 in qemu_init (argc=18, argv=0x7fffffffdeb8, envp=0x0) at ../softmmu/vl.c:3584
+ * #14 0x0000555555820fad in qemu_main (argc=18, argv=0x7fffffffdeb8, envp=0x0) at ../softmmu/main.c:37
+ * #15 0x0000555555820fe4 in main (argc=18, argv=0x7fffffffdeb8) at ../softmmu/main.c:47
+ *
+ * (gdb) bt
+ * #0  cpu_list_add (cpu=0x555556a91b10) at ../cpus-common.c:84
+ * #1  0x0000555555c8114b in cpu_exec_realizefn (cpu=0x555556a91b10, errp=0x7fffffffd6a8) at ../cpu.c:138
+ * #2  0x0000555555b63c39 in x86_cpu_realizefn (dev=0x555556a91b10, errp=0x7fffffffd730) at ../target/i386/cpu.c:6471
+ * #3  0x0000555555d21ca3 in device_set_realized (obj=0x555556a91b10, value=true, errp=0x7fffffffd840) at ../hw/core/qdev.c:553
+ * #4  0x0000555555d2b713 in property_set_bool (obj=0x555556a91b10, v=0x555556aa0b30, name=0x5555560ba599 "realized", opaque=0x555556851f00, errp=0x7fffffffd840) at ../qom/object.c:2273
+ * #5  0x0000555555d2975a in object_property_set (obj=0x555556a91b10, name=0x5555560ba599 "realized", v=0x555556aa0b30, errp=0x7fffffffd840) at ../qom/object.c:1408
+ * #6  0x0000555555d2db05 in object_property_set_qobject (obj=0x555556a91b10, name=0x5555560ba599 "realized", value=0x555556a91880, errp=0x5555567d4f80 <error_fatal>)
+       at ../qom/qom-qobject.c:28
+ * #7  0x0000555555d29abf in object_property_set_bool (obj=0x555556a91b10, name=0x5555560ba599 "realized", value=true, errp=0x5555567d4f80 <error_fatal>) at ../qom/object.c:1477
+ * #8  0x0000555555d2143b in qdev_realize (dev=0x555556a91b10, bus=0x0, errp=0x5555567d4f80 <error_fatal>) at ../hw/core/qdev.c:333
+ * #9  0x0000555555b23c2a in x86_cpu_new (x86ms=0x555556a54770, apic_id=0, errp=0x5555567d4f80 <error_fatal>) at ../hw/i386/x86.c:102
+ * #10 0x0000555555b23d34 in x86_cpus_init (x86ms=0x555556a54770, default_cpu_version=1) at ../hw/i386/x86.c:144
+ * #11 0x0000555555b2f784 in pc_init1 (machine=0x555556a54770, host_type=0x555556067ce1 "i440FX-pcihost", pci_type=0x555556067cda "i440FX") at ../hw/i386/pc_piix.c:159
+ * #12 0x0000555555b30354 in pc_init_v7_1 (machine=0x555556a54770) at ../hw/i386/pc_piix.c:445
+ * #13 0x00005555558a870e in machine_run_board_init (machine=0x555556a54770, mem_path=0x0, errp=0x5555567d4f80 <error_fatal>) at ../hw/core/machine.c:1400
+ * #14 0x0000555555a80f7c in qemu_init_board () at ../softmmu/vl.c:2485
+ * #15 0x0000555555a811ed in qmp_x_exit_preconfig (errp=0x5555567d4f80 <error_fatal>) at ../softmmu/vl.c:2581
+ * #16 0x0000555555a838c5 in qemu_init (argc=18, argv=0x7fffffffdeb8, envp=0x0) at ../softmmu/vl.c:3584
+ * #17 0x0000555555820fad in qemu_main (argc=18, argv=0x7fffffffdeb8, envp=0x0) at ../softmmu/main.c:37
+ * #18 0x0000555555820fe4 in main (argc=18, argv=0x7fffffffdeb8) at ../softmmu/main.c:47
+ *
+ * (gdb) bt
+ * #0  kvm_init_vcpu (cpu=0x555556a91b10, errp=0x5555567d4f80 <error_fatal>) at ../accel/kvm/kvm-all.c:467
+ * #1  0x0000555555d11cd3 in kvm_vcpu_thread_fn (arg=0x555556a91b10) at ../accel/kvm/kvm-accel-ops.c:40
+ * #2  0x0000555555eef738 in qemu_thread_start (args=0x555556aa1630) at ../util/qemu-thread-posix.c:504
+ * #3  0x00007ffff5be9ea5 in start_thread () at /lib64/libpthread.so.0
+ * #4  0x00007ffff5912b2d in clone () at /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  accel_setup_post (ms=0x555556a54770) at ../accel/accel-softmmu.c:57
+ * #1  0x0000555555a838d9 in qemu_init (argc=18, argv=0x7fffffffdeb8, envp=0x0) at ../softmmu/vl.c:3587
+ * #2  0x0000555555820fad in qemu_main (argc=18, argv=0x7fffffffdeb8, envp=0x0) at ../softmmu/main.c:37
+ * #3  0x0000555555820fe4 in main (argc=18, argv=0x7fffffffdeb8) at ../softmmu/main.c:47
+ */
 int kvm_arch_init(MachineState *ms, KVMState *s)
 {
     uint64_t identity_base = 0xfffbc000;
@@ -2836,6 +3022,13 @@ static int kvm_put_sregs2(X86CPU *cpu)
 
 static void kvm_msr_buf_reset(X86CPU *cpu)
 {
+    /*
+     * ArchCPU:
+     * -> struct kvm_msrs *kvm_msr_buf;
+     *    -> __u32 nmsrs; // number of msrs in entries
+     *    -> __u32 pad;
+     *    -> struct kvm_msr_entry entries[0];
+     */
     memset(cpu->kvm_msr_buf, 0, MSR_BUF_SIZE);
 }
 
@@ -3097,6 +3290,10 @@ static int kvm_buf_set_msrs(X86CPU *cpu)
     return 0;
 }
 
+/*
+ * called by:
+ *   - target/i386/kvm/kvm.c|2202| <<kvm_arch_init_vcpu>> kvm_init_msrs(cpu);
+ */
 static void kvm_init_msrs(X86CPU *cpu)
 {
     CPUX86State *env = &cpu->env;
@@ -3112,6 +3309,11 @@ static void kvm_init_msrs(X86CPU *cpu)
                           env->features[FEAT_CORE_CAPABILITY]);
     }
 
+    /*
+     * 在以下使用has_msr_perf_capabs:
+     *   - target/i386/kvm/kvm.c|2410| <<kvm_get_supported_msrs>> has_msr_perf_capabs = true;
+     *   - target/i386/kvm/kvm.c|3161| <<kvm_init_msrs>> if (has_msr_perf_capabs && cpu->enable_pmu) {
+     */
     if (has_msr_perf_capabs && cpu->enable_pmu) {
         kvm_msr_entry_add_perf(cpu, env->features);
     }
@@ -3131,6 +3333,31 @@ static void kvm_init_msrs(X86CPU *cpu)
     assert(kvm_buf_set_msrs(cpu) == 0);
 }
 
+/*
+ * (gdb) bt
+ * #0  kvm_put_msrs (cpu=0x555556ae2360, level=2) at ../target/i386/kvm/kvm.c:3135
+ * #1  0x0000555555b1497a in kvm_arch_put_registers (cpu=0x555556ae2360, level=2) at ../target/i386/kvm/kvm.c:4559
+ * #2  0x0000555555d0de56 in do_kvm_cpu_synchronize_post_reset (cpu=0x555556ae2360, arg=...) at ../accel/kvm/kvm-all.c:2780
+ * #3  0x0000555555821f77 in process_queued_cpu_work (cpu=0x555556ae2360) at ../cpus-common.c:351
+ * #4  0x0000555555a717d4 in qemu_wait_io_event_common (cpu=0x555556ae2360) at ../softmmu/cpus.c:411
+ * #5  0x0000555555a71865 in qemu_wait_io_event (cpu=0x555556ae2360) at ../softmmu/cpus.c:435
+ * #6  0x0000555555d10fce in kvm_vcpu_thread_fn (arg=0x555556ae2360) at ../accel/kvm/kvm-accel-ops.c:54
+ * #7  0x0000555555eec4de in qemu_thread_start (args=0x555556af1620) at ../util/qemu-thread-posix.c:504
+ * #8  0x00007ffff55eeea5 in start_thread () at /lib64/libpthread.so.0
+ * #9  0x00007ffff53179fd in clone () at /lib64/libc.so.6
+ *
+ * (gdb) bt
+ * #0  kvm_put_msrs (cpu=0x555556ae2360, level=1) at ../target/i386/kvm/kvm.c:3135
+ * #1  0x0000555555b1497a in kvm_arch_put_registers (cpu=0x555556ae2360, level=1) at ../target/i386/kvm/kvm.c:4559
+ * #2  0x0000555555d0e12c in kvm_cpu_exec (cpu=0x555556ae2360) at ../accel/kvm/kvm-all.c:2884
+ * #3  0x0000555555d10faa in kvm_vcpu_thread_fn (arg=0x555556ae2360) at ../accel/kvm/kvm-accel-ops.c:49
+ * #4  0x0000555555eec4de in qemu_thread_start (args=0x555556af1620) at ../util/qemu-thread-posix.c:504
+ * #5  0x00007ffff55eeea5 in start_thread () at /lib64/libpthread.so.0
+ * #6  0x00007ffff53179fd in clone () at /lib64/libc.so.6
+ *
+ * called by:
+ *   - target/i386/kvm/kvm.c|4565| <<kvm_arch_put_registers>> ret = kvm_put_msrs(x86_cpu, level);
+ */
 static int kvm_put_msrs(X86CPU *cpu, int level)
 {
     CPUX86State *env = &cpu->env;
@@ -3224,6 +3451,28 @@ static int kvm_put_msrs(X86CPU *cpu, int level)
             kvm_msr_entry_add(cpu, MSR_KVM_POLL_CONTROL, env->poll_control_msr);
         }
 
+        /*
+	 * version 1:
+	 * 
+	 * IA32_PMCx MSRs 从 0x0c1开始
+	 * IA32_PERFEVTSELx MSRs 从0x186开始
+	 *
+	 * 当IA_PERF_CAPABILITIES.FW_WRITE[bit 13] == 1的时候:
+	 * IA32_PMCx从0x4c1开始
+	 *
+	 * MSR_P6_PERFCTR0 + i,
+	 * MSR_P6_EVNTSEL0 + i,
+	 * MSR_CORE_PERF_FIXED_CTR0 + i
+	 *
+	 * MSR_CORE_PERF_FIXED_CTR_CTRL
+	 * MSR_CORE_PERF_GLOBAL_CTRL
+	 * MSR_CORE_PERF_GLOBAL_STATUS,
+	 * MSR_CORE_PERF_GLOBAL_OVF_CTRL,
+	 */
+        /*
+	 * 在以下使用has_architectural_pmu_version:
+	 *   - target/i386/kvm/kvm.c|1939| <<kvm_arch_init_vcpu>> has_architectural_pmu_version = eax & 0xff;
+	 */
         if (has_architectural_pmu_version > 0) {
             if (has_architectural_pmu_version > 1) {
                 /* Stop the counter.  */
@@ -3232,16 +3481,38 @@ static int kvm_put_msrs(X86CPU *cpu, int level)
             }
 
             /* Set the counter values.  */
+            /*
+	     * 在以下使用num_architectural_pmu_fixed_counters:
+	     *   - target/i386/kvm/kvm.c|1986| <<kvm_arch_init_vcpu>> num_architectural_pmu_fixed_counters = edx & 0x1f;
+             *   - target/i386/kvm/kvm.c|1989| <<kvm_arch_init_vcpu>> num_architectural_pmu_fixed_counters = MAX_FIXED_COUNTERS;
+             */
             for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i,
                                   env->msr_fixed_counters[i]);
             }
+            /*
+	     * 在以下使用MSR_F15H_PERF_CTR0:
+	     *   - target/i386/cpu.h|1319| <<MAX_GP_COUNTERS>> #define MAX_GP_COUNTERS (MSR_IA32_PERF_STATUS - MSR_P6_EVNTSEL0)
+	     *   - target/i386/kvm/kvm.c|3313| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i,
+	     *   - target/i386/kvm/kvm.c|3801| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);
+	     *   - target/i386/kvm/kvm.c|4087| <<kvm_get_msrs>> case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:
+	     *   - target/i386/kvm/kvm.c|4088| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+	     *
+	     * 在以下使用num_architectural_pmu_gp_counters:
+             *   - target/i386/kvm/kvm.c|1941| <<kvm_arch_init_vcpu>> num_architectural_pmu_gp_counters = (eax & 0xff00) >> 8;
+             *   - target/i386/kvm/kvm.c|1947| <<kvm_arch_init_vcpu>> if (num_architectural_pmu_gp_counters > MAX_GP_COUNTERS) {
+             *   - target/i386/kvm/kvm.c|1948| <<kvm_arch_init_vcpu>> num_architectural_pmu_gp_counters = MAX_GP_COUNTERS;
+	     */
             for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
                 kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i,
                                   env->msr_gp_counters[i]);
                 kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i,
                                   env->msr_gp_evtsel[i]);
             }
+            /*
+	     * 在以下使用has_architectural_pmu_version:
+	     *   - target/i386/kvm/kvm.c|1939| <<kvm_arch_init_vcpu>> has_architectural_pmu_version = eax & 0xff;
+	     */
             if (has_architectural_pmu_version > 1) {
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS,
                                   env->msr_global_status);
@@ -3725,6 +3996,14 @@ static int kvm_get_msrs(X86CPU *cpu)
         for (i = 0; i < num_architectural_pmu_fixed_counters; i++) {
             kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);
         }
+        /*
+	 * 在以下使用MSR_F15H_PERF_CTR0:
+         *   - target/i386/cpu.h|1319| <<MAX_GP_COUNTERS>> #define MAX_GP_COUNTERS (MSR_IA32_PERF_STATUS - MSR_P6_EVNTSEL0)
+         *   - target/i386/kvm/kvm.c|3313| <<kvm_put_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i,
+         *   - target/i386/kvm/kvm.c|3801| <<kvm_get_msrs>> kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);
+         *   - target/i386/kvm/kvm.c|4087| <<kvm_get_msrs>> case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:
+         *   - target/i386/kvm/kvm.c|4088| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+	 */
         for (i = 0; i < num_architectural_pmu_gp_counters; i++) {
             kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);
             kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);
@@ -4505,6 +4784,12 @@ static int kvm_get_nested_state(X86CPU *cpu)
     return ret;
 }
 
+/*
+ * called by:
+ *   - accel/kvm/kvm-all.c|2780| <<do_kvm_cpu_synchronize_post_reset>> kvm_arch_put_registers(cpu, KVM_PUT_RESET_STATE);
+ *   - accel/kvm/kvm-all.c|2791| <<do_kvm_cpu_synchronize_post_init>> kvm_arch_put_registers(cpu, KVM_PUT_FULL_STATE);
+ *   - accel/kvm/kvm-all.c|2884| <<kvm_cpu_exec>> kvm_arch_put_registers(cpu, KVM_PUT_RUNTIME_STATE);
+ */
 int kvm_arch_put_registers(CPUState *cpu, int level)
 {
     X86CPU *x86_cpu = X86_CPU(cpu);
diff --git a/target/i386/machine.c b/target/i386/machine.c
index cecd476e9..0a9cc4522 100644
--- a/target/i386/machine.c
+++ b/target/i386/machine.c
@@ -639,6 +639,9 @@ static const VMStateDescription vmstate_msr_ia32_feature_control = {
     }
 };
 
+/*
+ * VMStateDescription vmstate_msr_architectural_pmu.pmu_enable_needed()
+ */
 static bool pmu_enable_needed(void *opaque)
 {
     X86CPU *cpu = opaque;
@@ -654,6 +657,13 @@ static bool pmu_enable_needed(void *opaque)
             return true;
         }
     }
+    /*
+     * 在以下使用CPUArchState->msr_gp_evtsel[MAX_GP_COUNTERS]:
+     *   - target/i386/machine.c|678| <<global>> VMSTATE_UINT64_ARRAY(env.msr_gp_evtsel, X86CPU, MAX_GP_COUNTERS),
+     *   - target/i386/kvm/kvm.c|3314| <<kvm_put_msrs>> env->msr_gp_evtsel[i]);
+     *   - target/i386/kvm/kvm.c|4088| <<kvm_get_msrs>> env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;
+     *   - target/i386/machine.c|658| <<pmu_enable_needed>> if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
+     */
     for (i = 0; i < MAX_GP_COUNTERS; i++) {
         if (env->msr_gp_counters[i] || env->msr_gp_evtsel[i]) {
             return true;
diff --git a/util/aio-wait.c b/util/aio-wait.c
index 98c5accd2..948ee021b 100644
--- a/util/aio-wait.c
+++ b/util/aio-wait.c
@@ -82,5 +82,22 @@ void aio_wait_bh_oneshot(AioContext *ctx, QEMUBHFunc *cb, void *opaque)
     assert(qemu_get_current_aio_context() == qemu_get_aio_context());
 
     aio_bh_schedule_oneshot(ctx, aio_wait_bh, &data);
+    /*
+     * AIO_WAIT_WHILE:
+     * @ctx: the aio context, or NULL if multiple aio contexts (for which the
+     *       caller does not hold a lock) are involved in the polling condition.
+     * @cond: wait while this conditional expression is true
+     *  
+     * Wait while a condition is true.  Use this to implement synchronous
+     * operations that require event loop activity.
+     *  
+     * The caller must be sure that something calls aio_wait_kick() when the value
+     * of @cond might have changed.
+     *
+     * The caller's thread must be the IOThread that owns @ctx or the main loop
+     * thread (with @ctx acquired exactly once).  This function cannot be used to
+     * wait on conditions between two IOThreads since that could lead to deadlock,
+     * go via the main loop instead.
+     */
     AIO_WAIT_WHILE(ctx, !data.done);
 }
diff --git a/util/log.c b/util/log.c
index d6eb0378c..912f580bc 100644
--- a/util/log.c
+++ b/util/log.c
@@ -186,6 +186,12 @@ valid_filename_template(const char *filename, bool per_thread, Error **errp)
 }
 
 /* enable or disable low levels log */
+/*
+ * called by:
+ *   - util/log.c|302| <<qemu_set_log>> return qemu_set_log_internal(NULL, false, log_flags, errp);
+ *   - util/log.c|307| <<qemu_set_log_filename>> return qemu_set_log_internal(filename, true, qemu_loglevel, errp);
+ *   - util/log.c|312| <<qemu_set_log_filename_flags>> return qemu_set_log_internal(name, true, flags, errp);
+ */
 static bool qemu_set_log_internal(const char *filename, bool changed_name,
                                   int log_flags, Error **errp)
 {
@@ -297,6 +303,16 @@ static bool qemu_set_log_internal(const char *filename, bool changed_name,
     return true;
 }
 
+/*
+ * called by:
+ *   - monitor/misc.c|445| <<hmp_log>> if (!qemu_set_log(mask, &err)) {
+ *   - qemu-img.c|5443| <<main>> qemu_set_log(LOG_TRACE, &error_fatal);
+ *   - qemu-io.c|638| <<main>> qemu_set_log(LOG_TRACE, &error_fatal);
+ *   - qemu-nbd.c|814| <<main>> qemu_set_log(LOG_TRACE, &error_fatal);
+ *   - scsi/qemu-pr-helper.c|1006| <<main>> qemu_set_log(LOG_TRACE, &error_fatal);
+ *   - storage-daemon/qemu-storage-daemon.c|419| <<main>> qemu_set_log(LOG_TRACE, &error_fatal);
+ *   - tests/unit/test-logging.c|124| <<test_logfile_write>> qemu_set_log(CPU_LOG_TB_OUT_ASM, &error_abort);
+ */
 bool qemu_set_log(int log_flags, Error **errp)
 {
     return qemu_set_log_internal(NULL, false, log_flags, errp);
@@ -449,6 +465,13 @@ const QEMULogItem qemu_log_items[] = {
 };
 
 /* takes a comma separated list of log masks. Return 0 if error. */
+/*
+ * called by:
+ *   - bsd-user/main.c|410| <<main>> mask = qemu_str_to_log_mask(log_mask);
+ *   - linux-user/main.c|250| <<handle_arg_log>> last_log_mask = qemu_str_to_log_mask(arg);
+ *   - monitor/misc.c|438| <<hmp_log>> mask = qemu_str_to_log_mask(items);
+ *   - softmmu/vl.c|2387| <<qemu_process_early_options>> mask = qemu_str_to_log_mask(log_mask);
+ */
 int qemu_str_to_log_mask(const char *str)
 {
     const QEMULogItem *item;
@@ -486,6 +509,12 @@ int qemu_str_to_log_mask(const char *str)
     return 0;
 }
 
+/*
+ * called by:
+ *   - bsd-user/main.c|412| <<main>> qemu_print_log_usage(stdout);
+ *   - linux-user/main.c|252| <<handle_arg_log>> qemu_print_log_usage(stdout);
+ *   - softmmu/vl.c|2399| <<qemu_process_early_options>> qemu_print_log_usage(stdout);
+ */
 void qemu_print_log_usage(FILE *f)
 {
     const QEMULogItem *item;
diff --git a/util/qemu-config.c b/util/qemu-config.c
index 433488aa5..72fd3f8a0 100644
--- a/util/qemu-config.c
+++ b/util/qemu-config.c
@@ -241,6 +241,9 @@ static QemuOptsList machine_opts = {
     }
 };
 
+/*
+ * 只被qmp调用
+ */
 CommandLineOptionInfoList *qmp_query_command_line_options(bool has_option,
                                                           const char *option,
                                                           Error **errp)
diff --git a/util/qemu-option.c b/util/qemu-option.c
index eedd08929..81e1bebf7 100644
--- a/util/qemu-option.c
+++ b/util/qemu-option.c
@@ -1122,6 +1122,35 @@ bool qemu_opts_validate(QemuOpts *opts, const QemuOptDesc *desc, Error **errp)
  * When @func() returns non-zero, break the loop and return that value.
  * Return zero when the loop completes.
  */
+/*
+ * called by:
+ *   - block/blkdebug.c|309| <<read_config>> qemu_opts_foreach(&inject_error_opts, add_rule, &d, &local_err);
+ *   - block/blkdebug.c|317| <<read_config>> qemu_opts_foreach(&set_state_opts, add_rule, &d, &local_err);
+ *   - hw/core/numa.c|732| <<parse_numa_opts>> qemu_opts_foreach(qemu_find_opts("numa"), parse_numa, ms, &error_fatal);
+ *   - net/net.c|1570| <<net_init_clients>> if (qemu_opts_foreach(qemu_find_opts("netdev"),
+ *   - net/net.c|1575| <<net_init_clients>> if (qemu_opts_foreach(qemu_find_opts("nic"), net_param_nic, NULL, errp)) {
+ *   - net/net.c|1579| <<net_init_clients>> if (qemu_opts_foreach(qemu_find_opts("net"), net_init_client, NULL, errp)) {
+ *   - softmmu/tpm.c|166| <<tpm_init>> if (qemu_opts_foreach(qemu_find_opts("tpmdev"),
+ *   - softmmu/vl.c|710| <<configure_blockdev>> qemu_opts_foreach(qemu_find_opts("drive"), drive_enable_snapshot,
+ *   - softmmu/vl.c|713| <<configure_blockdev>> if (qemu_opts_foreach(qemu_find_opts("drive"), drive_init_func,
+ *   - softmmu/vl.c|1265| <<qemu_disable_default_devices>> qemu_opts_foreach(qemu_find_opts("device"),
+ *   - softmmu/vl.c|1267| <<qemu_disable_default_devices>> qemu_opts_foreach(qemu_find_opts("global"),
+ *   - softmmu/vl.c|1881| <<qemu_create_early_backends>> qemu_opts_foreach(qemu_find_opts("chardev"),
+ *   - softmmu/vl.c|1885| <<qemu_create_early_backends>> qemu_opts_foreach(qemu_find_opts("fsdev"),
+ *   - softmmu/vl.c|1921| <<qemu_create_late_backends>> qemu_opts_foreach(qemu_find_opts("mon"),
+ *   - softmmu/vl.c|2161| <<user_register_global_props>> qemu_opts_foreach(qemu_find_opts("global"),
+ *   - softmmu/vl.c|2218| <<configure_accelerators>> qemu_opts_foreach(qemu_find_opts("icount"),
+ *   - softmmu/vl.c|2268| <<configure_accelerators>> if (!qemu_opts_foreach(qemu_find_opts("accel"),
+ *   - softmmu/vl.c|2373| <<qemu_process_early_options>> qemu_opts_foreach(olist, parse_sandbox, NULL, &error_fatal);
+ *   - softmmu/vl.c|2377| <<qemu_process_early_options>> qemu_opts_foreach(qemu_find_opts("name"),
+ *   - softmmu/vl.c|2380| <<qemu_process_early_options>> if (qemu_opts_foreach(qemu_find_opts("action"),
+ *   - softmmu/vl.c|2386| <<qemu_process_early_options>> qemu_opts_foreach(qemu_find_opts("add-fd"),
+ *   - softmmu/vl.c|2389| <<qemu_process_early_options>> qemu_opts_foreach(qemu_find_opts("add-fd"),
+ *   - softmmu/vl.c|2422| <<qemu_process_help_options>> if (qemu_opts_foreach(qemu_find_opts("device"),
+ *   - softmmu/vl.c|2480| <<qemu_init_displays>> qemu_opts_foreach(qemu_find_opts("vnc"),
+ *   - softmmu/vl.c|2513| <<qemu_create_cli_devices>> qemu_opts_foreach(qemu_find_opts("fw_cfg"),
+ *   - softmmu/vl.c|2524| <<qemu_create_cli_devices>> qemu_opts_foreach(qemu_find_opts("device"),
+ */
 int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func,
                       void *opaque, Error **errp)
 {
-- 
2.34.1

