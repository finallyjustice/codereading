From 6aa3558d87a738a4f10a7d393ed3002896bec35e Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 29 Apr 2020 14:50:01 -0700
Subject: [PATCH 1/1] xen-4.4.4-155.0.75.el6-kdump

xen-4.4.4-155.0.75

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 xen/arch/x86/crash.c                     | 25 ++++++
 xen/common/domain.c                      | 11 +++
 xen/common/kexec.c                       | 25 ++++++
 xen/common/shutdown.c                    |  4 +
 xen/drivers/char/console.c               | 32 ++++++++
 xen/drivers/passthrough/amd/iommu_init.c |  4 +
 xen/drivers/passthrough/iommu.c          | 14 ++++
 xen/drivers/passthrough/vtd/dmar.h       | 19 +++++
 xen/drivers/passthrough/vtd/intremap.c   | 15 ++++
 xen/drivers/passthrough/vtd/iommu.c      | 98 ++++++++++++++++++++++++
 xen/drivers/passthrough/vtd/qinval.c     | 23 ++++++
 xen/drivers/passthrough/vtd/quirks.c     |  6 ++
 xen/drivers/passthrough/vtd/x86/vtd.c    |  4 +
 13 files changed, 280 insertions(+)

diff --git a/xen/arch/x86/crash.c b/xen/arch/x86/crash.c
index c5332a5ea2..84f23548f0 100644
--- a/xen/arch/x86/crash.c
+++ b/xen/arch/x86/crash.c
@@ -36,6 +36,20 @@ static unsigned int crashing_cpu;
 static DEFINE_PER_CPU_READ_MOSTLY(bool_t, crash_save_done);
 
 /* This becomes the NMI handler for non-crashing CPUs, when Xen is crashing. */
+/*
+ * 在以下使用do_nmi_crash():
+ *   - arch/x86/crash.c|148| <<nmi_shootdown_cpus>> (unsigned long )&do_nmi_crash);
+ *
+ * //
+ * // Ideally would be:
+ * //   exception_table[TRAP_nmi] = &do_nmi_crash;
+ * //
+ * // but the exception_table is read only.  Access it via its directmap
+ * // mappings.
+ *
+ * write_atomic((unsigned long *)__va(__pa(&exception_table[TRAP_nmi])),
+ *              (unsigned long)&do_nmi_crash);
+ */
 void __attribute__((noreturn)) do_nmi_crash(struct cpu_user_regs *regs)
 {
     unsigned int cpu = smp_processor_id();
@@ -113,6 +127,10 @@ void __attribute__((noreturn)) do_nmi_crash(struct cpu_user_regs *regs)
         halt();
 }
 
+/*
+ * called by:
+ *   - arch/x86/crash.c|187| <<machine_crash_shutdown>> nmi_shootdown_cpus();
+ */
 static void nmi_shootdown_cpus(void)
 {
     unsigned long msecs;
@@ -180,10 +198,17 @@ static void nmi_shootdown_cpus(void)
     hpet_disable();
 }
 
+/*
+ * called by:
+ *   - common/kexec.c|368| <<kexec_crash>> machine_crash_shutdown();
+ */
 void machine_crash_shutdown(void)
 {
     crash_xen_info_t *info;
 
+    /*
+     * 打印: Shot down all CPUs
+     */
     nmi_shootdown_cpus();
 
     info = kexec_crash_save_info();
diff --git a/xen/common/domain.c b/xen/common/domain.c
index fcb13abf33..01df319807 100644
--- a/xen/common/domain.c
+++ b/xen/common/domain.c
@@ -694,6 +694,17 @@ void __domain_crash_synchronous(void)
 }
 
 
+/*
+ * called by:
+ *   - arch/x86/hvm/hvm.c|1504| <<hvm_vcpu_down>> domain_shutdown(d, SHUTDOWN_poweroff);
+ *   - arch/x86/hvm/hvm.c|1567| <<hvm_triple_fault>> domain_shutdown(d, reason);
+ *   - common/domain.c|682| <<__domain_crash>> domain_shutdown(d, SHUTDOWN_crash);
+ *   - common/page_alloc.c|1125| <<offline_page>> domain_shutdown(owner, SHUTDOWN_crash);
+ *   - common/schedule.c|807| <<domain_watchdog_timeout>> domain_shutdown(d, SHUTDOWN_watchdog);
+ *   - common/schedule.c|893| <<do_sched_op_compat>> domain_shutdown(current->domain, (u8)arg);
+ *   - common/schedule.c|938| <<do_sched_op(SCHEDOP_shutdown)>> domain_shutdown(current->domain, (u8)sched_shutdown.reason);
+ *   - common/schedule.c|998| <<do_sched_op(SCHEDOP_remote_shutdown)>> domain_shutdown(d, (u8)sched_remote_shutdown.reason);
+ */
 void domain_shutdown(struct domain *d, u8 reason)
 {
     struct vcpu *v;
diff --git a/xen/common/kexec.c b/xen/common/kexec.c
index 44ae95d52f..d7ade29d6e 100644
--- a/xen/common/kexec.c
+++ b/xen/common/kexec.c
@@ -242,6 +242,10 @@ void __init set_kexec_crash_area_size(u64 system_ram)
  * This is noinline to make it obvious in stack traces which cpus have lost
  * the race (as opposed to being somewhere in kexec_common_shutdown())
  */
+/*
+ * called by:
+ *   - common/kexec.c|325| <<kexec_common_shutdown>> ret = one_cpu_only();
+ */
 static int noinline one_cpu_only(void)
 {
     static unsigned int crashing_cpu = -1;
@@ -271,6 +275,11 @@ static int noinline one_cpu_only(void)
 }
 
 /* Save the registers in the per-cpu crash note buffer. */
+/*
+ * called by:
+ *   - arch/x86/crash.c|65| <<do_nmi_crash>> kexec_crash_save_cpu();
+ *   - common/kexec.c|367| <<kexec_crash>> kexec_crash_save_cpu();
+ */
 void kexec_crash_save_cpu(void)
 {
     int cpu = smp_processor_id();
@@ -318,6 +327,11 @@ crash_xen_info_t *kexec_crash_save_info(void)
     return out;
 }
 
+/*
+ * called by:
+ *   - common/kexec.c|347| <<kexec_crash>> if ( kexec_common_shutdown() != 0 )
+ *   - common/kexec.c|363| <<kexec_reboot>> kexec_common_shutdown();
+ */
 static int kexec_common_shutdown(void)
 {
     int ret;
@@ -334,6 +348,14 @@ static int kexec_common_shutdown(void)
     return 0;
 }
 
+/*
+ * called by:
+ *   - common/kexec.c|373| <<do_crashdump_trigger>> kexec_crash();
+ *   - common/kexec.c|809| <<kexec_exec(KEXEC_TYPE_CRASH)>> kexec_crash();
+ *   - common/shutdown.c|51| <<dom0_shutdown>> kexec_crash();
+ *   - common/shutdown.c|68| <<dom0_shutdown>> kexec_crash();
+ *   - drivers/char/console.c|1072| <<panic>> kexec_crash();
+ */
 void kexec_crash(void)
 {
     int pos;
@@ -348,6 +370,9 @@ void kexec_crash(void)
         return;
 
     kexec_crash_save_cpu();
+    /*
+     * 打印: Shot down all CPUs
+     */
     machine_crash_shutdown();
     machine_kexec(kexec_image[KEXEC_IMAGE_CRASH_BASE + pos]);
 
diff --git a/xen/common/shutdown.c b/xen/common/shutdown.c
index 90ee384212..162a7e59e1 100644
--- a/xen/common/shutdown.c
+++ b/xen/common/shutdown.c
@@ -32,6 +32,10 @@ static void maybe_reboot(void)
     }
 }
 
+/*
+ * called by:
+ *   - common/domain.c|708| <<domain_shutdown>> dom0_shutdown(reason);
+ */
 void dom0_shutdown(u8 reason)
 {
     switch ( reason )
diff --git a/xen/drivers/char/console.c b/xen/drivers/char/console.c
index 9d1460474c..ebe022c458 100644
--- a/xen/drivers/char/console.c
+++ b/xen/drivers/char/console.c
@@ -65,6 +65,24 @@ static uint32_t conringc, conringp;
 
 static int __read_mostly sercon_handle = -1;
 
+/*
+ * 在以下使用console_lock:
+ *   - drivers/char/console.c|183| <<conring_puts>> ASSERT(spin_is_locked(&console_lock));
+ *   - drivers/char/console.c|221| <<read_console_ring>> spin_lock_irq(&console_lock);
+ *   - drivers/char/console.c|226| <<read_console_ring>> spin_unlock_irq(&console_lock);
+ *   - drivers/char/console.c|396| <<guest_console_write>> spin_lock_irq(&console_lock);
+ *   - drivers/char/console.c|407| <<guest_console_write>> spin_unlock_irq(&console_lock);
+ *   - drivers/char/console.c|505| <<__putstr>> ASSERT(spin_is_locked(&console_lock));
+ *   - drivers/char/console.c|579| <<vprintk_common>> spin_lock_recursive(&console_lock);
+ *   - drivers/char/console.c|614| <<vprintk_common>> spin_unlock_recursive(&console_lock);
+ *   - drivers/char/console.c|670| <<console_init_preirq>> spin_lock(&console_lock);
+ *   - drivers/char/console.c|672| <<console_init_preirq>> spin_unlock(&console_lock);
+ *   - drivers/char/console.c|706| <<console_init_postirq>> spin_lock_irq(&console_lock);
+ *   - drivers/char/console.c|712| <<console_init_postirq>> spin_unlock_irq(&console_lock);
+ *   - drivers/char/console.c|800| <<console_force_unlock>> spin_lock_init(&console_lock);
+ *   - drivers/char/console.c|853| <<__printk_ratelimit>> spin_lock_recursive(&console_lock);
+ *   - drivers/char/console.c|858| <<__printk_ratelimit>> spin_unlock_recursive(&console_lock);
+ */
 static DEFINE_SPINLOCK(console_lock);
 
 /*
@@ -566,6 +584,11 @@ static void printk_start_of_line(const char *prefix)
     __putstr(tstr);
 }
 
+/*
+ * called by:
+ *   - drivers/char/console.c|622| <<printk>> vprintk_common("(XEN) ", fmt, args);
+ *   - drivers/char/console.c|634| <<guest_printk>> vprintk_common(prefix, fmt, args);
+ */
 static void vprintk_common(const char *prefix, const char *fmt, va_list args)
 {
     static char   buf[1024];
@@ -794,6 +817,15 @@ void console_end_log_everything(void)
     atomic_dec(&print_everything);
 }
 
+/*
+ * called by:
+ *   - arch/x86/cpu/mcheck/mce.c|1542| <<mc_panic>> console_force_unlock();
+ *   - arch/x86/nmi.c|479| <<nmi_watchdog_tick>> console_force_unlock();
+ *   - arch/x86/traps.c|3296| <<pci_serr_error>> console_force_unlock();
+ *   - arch/x86/traps.c|3311| <<io_check_error>> console_force_unlock();
+ *   - arch/x86/traps.c|3330| <<unknown_nmi_error>> console_force_unlock();
+ *   - arch/x86/x86_64/traps.c|229| <<do_double_fault>> console_force_unlock();
+ */
 void console_force_unlock(void)
 {
     watchdog_disable();
diff --git a/xen/drivers/passthrough/amd/iommu_init.c b/xen/drivers/passthrough/amd/iommu_init.c
index 4686813a8b..9691f9ae5b 100644
--- a/xen/drivers/passthrough/amd/iommu_init.c
+++ b/xen/drivers/passthrough/amd/iommu_init.c
@@ -1036,6 +1036,10 @@ error_out:
     return -ENODEV;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/amd/iommu_init.c|1266| <<amd_iommu_init>> amd_iommu_init_cleanup();
+ */
 static void __init amd_iommu_init_cleanup(void)
 {
     struct amd_iommu *iommu, *next;
diff --git a/xen/drivers/passthrough/iommu.c b/xen/drivers/passthrough/iommu.c
index c86b237a32..8cdb0ca770 100644
--- a/xen/drivers/passthrough/iommu.c
+++ b/xen/drivers/passthrough/iommu.c
@@ -43,6 +43,11 @@ static void iommu_dump_p2m_table(unsigned char key);
  *   no-intremap                Disable VT-d Interrupt Remapping
  */
 custom_param("iommu", parse_iommu_param);
+/*
+ * 在以下修改iommu_enable:
+ *   - drivers/passthrough/amd/iommu_init.c|1066| <<amd_iommu_init_cleanup>> iommu_enabled = 0;
+ *   - drivers/passthrough/iommu.c|615| <<iommu_setup>> iommu_enabled = (rc == 0);
+ */
 bool_t __initdata iommu_enable = 1;
 bool_t __read_mostly iommu_enabled;
 bool_t __read_mostly force_iommu;
@@ -743,9 +748,18 @@ void iommu_share_p2m_table(struct domain* d)
         ops->share_p2m(d);
 }
 
+/*
+ * called by:
+ *   - arch/x86/crash.c|188| <<nmi_shootdown_cpus>> iommu_crash_shutdown();
+ */
 void iommu_crash_shutdown(void)
 {
+    /* 返回intel_iommu_ops或者amd_iommu_ops */
     const struct iommu_ops *ops = iommu_get_ops();
+    /*
+     * intel: vtd_crash_shutdown()
+     * amd  : amd_iommu_suspend()
+     */
     if ( iommu_enabled )
         ops->crash_shutdown();
     iommu_enabled = iommu_intremap = 0;
diff --git a/xen/drivers/passthrough/vtd/dmar.h b/xen/drivers/passthrough/vtd/dmar.h
index 479dbeff60..b2b64cf204 100644
--- a/xen/drivers/passthrough/vtd/dmar.h
+++ b/xen/drivers/passthrough/vtd/dmar.h
@@ -118,6 +118,25 @@ struct acpi_atsr_unit *acpi_find_matched_atsr_unit(const struct pci_dev *);
           __FILE__, __LINE__, __func__);
 #endif
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/intremap.c|768| <<enable_intremap>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/intremap.c|780| <<enable_intremap>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/intremap.c|803| <<disable_intremap>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/intremap.c|822| <<disable_intremap>> IOMMU_WAIT_OP(iommu, DMAR_IRTA_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/iommu.c|333| <<iommu_flush_write_buffer>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/iommu.c|385| <<flush_context_reg>> IOMMU_WAIT_OP(iommu, DMAR_CCMD_REG, dmar_readq,
+ *   - drivers/passthrough/vtd/iommu.c|475| <<flush_iotlb_reg>> IOMMU_WAIT_OP(iommu, (tlb_offset + 8), dmar_readq,
+ *   - drivers/passthrough/vtd/iommu.c|728| <<iommu_set_root_entry>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/iommu.c|764| <<iommu_enable_translation>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/iommu.c|788| <<iommu_disable_translation>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/qinval.c|485| <<enable_qinval>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/qinval.c|508| <<disable_qinval>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/utils.c|52| <<disable_pmr>> IOMMU_WAIT_OP(iommu, DMAR_PMEN_REG, dmar_readl,
+ *
+ * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+ * 不会hang!!!
+ */
 #define IOMMU_WAIT_OP(iommu, offset, op, cond, sts) \
 do {                                                \
     s_time_t start_time = NOW();                    \
diff --git a/xen/drivers/passthrough/vtd/intremap.c b/xen/drivers/passthrough/vtd/intremap.c
index 2f8b9ebc23..33cf76d41e 100644
--- a/xen/drivers/passthrough/vtd/intremap.c
+++ b/xen/drivers/passthrough/vtd/intremap.c
@@ -784,6 +784,13 @@ int enable_intremap(struct iommu *iommu, int eim)
     return init_apic_pin_2_ir_idx();
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/intremap.c|855| <<iommu_enable_x2apic_IR>> disable_intremap(iommu);
+ *   - drivers/passthrough/vtd/intremap.c|898| <<iommu_disable_x2apic_IR>> disable_intremap(drhd->iommu);
+ *   - drivers/passthrough/vtd/iommu.c|2165| <<init_vtd_hw>> disable_intremap(drhd->iommu);
+ *   - drivers/passthrough/vtd/iommu.c|2429| <<vtd_crash_shutdown>> disable_intremap(drhd->iommu);
+ */
 void disable_intremap(struct iommu *iommu)
 {
     u32 sts;
@@ -800,6 +807,10 @@ void disable_intremap(struct iommu *iommu)
 
     dmar_writel(iommu->reg, DMAR_GCMD_REG, sts & (~DMA_GCMD_IRE));
 
+    /*
+     * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+     * 不会hang!!!
+     */
     IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
                   !(sts & DMA_GSTS_IRES), sts);
 
@@ -819,6 +830,10 @@ void disable_intremap(struct iommu *iommu)
         goto out;
 
     dmar_writel(iommu->reg, DMAR_IRTA_REG, irta & ~IRTA_EIME);
+    /*
+     * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+     * 不会hang!!!
+     */
     IOMMU_WAIT_OP(iommu, DMAR_IRTA_REG, dmar_readl,
                   !(irta & IRTA_EIME), irta);
 
diff --git a/xen/drivers/passthrough/vtd/iommu.c b/xen/drivers/passthrough/vtd/iommu.c
index 2036d56301..b7592add7f 100644
--- a/xen/drivers/passthrough/vtd/iommu.c
+++ b/xen/drivers/passthrough/vtd/iommu.c
@@ -382,6 +382,10 @@ static int flush_context_reg(
     dmar_writeq(iommu->reg, DMAR_CCMD_REG, val);
 
     /* Make sure hardware complete it */
+    /*
+     * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+     * 不会hang!!!
+     */
     IOMMU_WAIT_OP(iommu, DMAR_CCMD_REG, dmar_readq,
                   !(val & DMA_CCMD_ICC), val);
 
@@ -390,10 +394,21 @@ static int flush_context_reg(
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|556| <<iommu_flush_all>> iommu_flush_context_global(iommu, 0);
+ */
 static int iommu_flush_context_global(
     struct iommu *iommu, int flush_non_present_entry)
 {
     struct iommu_flush *flush = iommu_get_flush(iommu);
+    /*
+     * 在以下设置context:
+     *   - drivers/passthrough/vtd/iommu.c|2120| <<init_vtd_hw>> flush->context = flush_context_reg;
+     *   - drivers/passthrough/vtd/qinval.c|463| <<enable_qinval>> flush->context = flush_context_qi;
+     *
+     * 更大的可能是flush_context_qi()
+     */
     return flush->context(iommu, 0, 0, 0, DMA_CCMD_GLOBAL_INVL,
                                  flush_non_present_entry);
 }
@@ -475,6 +490,10 @@ static int flush_iotlb_reg(void *_iommu, u16 did,
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|558| <<iommu_flush_all>> iommu_flush_iotlb_global(iommu, 0, flush_dev_iotlb);
+ */
 static int iommu_flush_iotlb_global(struct iommu *iommu,
     int flush_non_present_entry, int flush_dev_iotlb)
 {
@@ -484,6 +503,13 @@ static int iommu_flush_iotlb_global(struct iommu *iommu,
     /* apply platform specific errata workarounds */
     vtd_ops_preamble_quirk(iommu);
 
+    /*
+     * 在以下设置iotlb:
+     *   - drivers/passthrough/vtd/iommu.c|2113| <<init_vtd_hw>> flush->iotlb = flush_iotlb_reg;
+     *   - drivers/passthrough/vtd/qinval.c|464| <<enable_qinval>> flush->iotlb = flush_iotlb_qi;
+     *
+     * 更大的可能是flush_iotlb_qi()
+     */
     status = flush->iotlb(iommu, 0, 0, 0, DMA_TLB_GLOBAL_FLUSH,
                         flush_non_present_entry, flush_dev_iotlb);
 
@@ -543,18 +569,39 @@ static int iommu_flush_iotlb_psi(
     return status;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|1269| <<intel_iommu_dom0_init>> iommu_flush_all();
+ *   - drivers/passthrough/vtd/iommu.c|2155| <<init_vtd_hw>> iommu_flush_all();
+ *   - drivers/passthrough/vtd/iommu.c|2344| <<vtd_suspend>> iommu_flush_all();
+ *   - drivers/passthrough/vtd/iommu.c|2383| <<vtd_crash_shutdown>> iommu_flush_all();
+ */
 static void iommu_flush_all(void)
 {
     struct acpi_drhd_unit *drhd;
     struct iommu *iommu;
     int flush_dev_iotlb;
 
+    /*
+     * 在以下调用flush_all_cache():
+     *   - - drivers/passthrough/vtd/iommu.c|588| <<iommu_flush_all>> flush_all_cache();
+     *
+     * 就是一个wbinvd();
+     */
     flush_all_cache();
     for_each_drhd_unit ( drhd )
     {
         iommu = drhd->iommu;
+	/*
+	 * 在以下调用iommu_flush_context_global():
+	 *   - drivers/passthrough/vtd/iommu.c|556| <<iommu_flush_all>> iommu_flush_context_global(iommu, 0);
+	 */
         iommu_flush_context_global(iommu, 0);
         flush_dev_iotlb = find_ats_dev_drhd(iommu) ? 1 : 0;
+	/*
+	 * 在以下调用iommu_flush_iotlb_global():
+	 *   - drivers/passthrough/vtd/iommu.c|558| <<iommu_flush_all>> iommu_flush_iotlb_global(iommu, 0, flush_dev_iotlb);
+	 */
         iommu_flush_iotlb_global(iommu, 0, flush_dev_iotlb);
     }
 }
@@ -744,6 +791,11 @@ static void iommu_enable_translation(struct acpi_drhd_unit *drhd)
     disable_pmr(iommu);
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|2392| <<vtd_suspend>> iommu_disable_translation(iommu);
+ *   - drivers/passthrough/vtd/iommu.c|2428| <<vtd_crash_shutdown>> iommu_disable_translation(iommu);
+ */
 static void iommu_disable_translation(struct iommu *iommu)
 {
     u32 sts;
@@ -757,6 +809,10 @@ static void iommu_disable_translation(struct iommu *iommu)
     dmar_writel(iommu->reg, DMAR_GCMD_REG, sts & (~DMA_GCMD_TE));
 
     /* Make sure hardware complete it */
+    /*
+     * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+     * 不会hang!!!
+     */
     IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
                   !(sts & DMA_GSTS_TES), sts);
     spin_unlock_irqrestore(&iommu->register_lock, flags);
@@ -2372,21 +2428,63 @@ static void vtd_suspend(void)
     }
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/iommu.c|759| <<iommu_crash_shutdown>> ops->crash_shutdown();
+ *
+ * struct iommu_ops intel_iommu_ops.crash_shutdown = vtd_crash_shutdown()
+ */
 static void vtd_crash_shutdown(void)
 {
     struct acpi_drhd_unit *drhd;
     struct iommu *iommu;
 
+    /*
+     * 在以下修改iommu_enable:
+     *   - drivers/passthrough/amd/iommu_init.c|1066| <<amd_iommu_init_cleanup>> iommu_enabled = 0;
+     *   - drivers/passthrough/iommu.c|615| <<iommu_setup>> iommu_enabled = (rc == 0)
+     */
     if ( !iommu_enabled )
         return;
 
+    /*
+     * 在以下调用iommu_flush_all():
+     *   - drivers/passthrough/vtd/iommu.c|1269| <<intel_iommu_dom0_init>> iommu_flush_all();
+     *   - drivers/passthrough/vtd/iommu.c|2155| <<init_vtd_hw>> iommu_flush_all();
+     *   - drivers/passthrough/vtd/iommu.c|2344| <<vtd_suspend>> iommu_flush_all();
+     *   - drivers/passthrough/vtd/iommu.c|2383| <<vtd_crash_shutdown>> iommu_flush_all();
+     *
+     * upstream是这样的:
+     * 2599     if ( iommu_flush_all() )
+     * 2600         printk(XENLOG_WARNING VTDPREFIX
+     * 2601                " crash shutdown: IOMMU flush all failed\n");
+     */
     iommu_flush_all();
 
     for_each_drhd_unit ( drhd )
     {
         iommu = drhd->iommu;
+	/*
+	 * 在以下调用iommu_disable_translation():
+	 *   - drivers/passthrough/vtd/iommu.c|2392| <<vtd_suspend>> iommu_disable_translation(iommu);
+	 *   - drivers/passthrough/vtd/iommu.c|2428| <<vtd_crash_shutdown>> iommu_disable_translation(iommu);
+	 */
         iommu_disable_translation(iommu);
+	/*
+	 * 在以下调用disable_intremap():
+	 *   - drivers/passthrough/vtd/intremap.c|855| <<iommu_enable_x2apic_IR>> disable_intremap(iommu);
+	 *   - drivers/passthrough/vtd/intremap.c|898| <<iommu_disable_x2apic_IR>> disable_intremap(drhd->iommu);
+	 *   - drivers/passthrough/vtd/iommu.c|2165| <<init_vtd_hw>> disable_intremap(drhd->iommu);
+	 *   - drivers/passthrough/vtd/iommu.c|2429| <<vtd_crash_shutdown>> disable_intremap(drhd->iommu);
+	 */
         disable_intremap(drhd->iommu);
+	/*
+	 * 在以下调用disable_qinval():
+	 *   - drivers/passthrough/vtd/intremap.c|856| <<iommu_enable_x2apic_IR>> disable_qinval(iommu);
+	 *   - drivers/passthrough/vtd/intremap.c|901| <<iommu_disable_x2apic_IR>> disable_qinval(drhd->iommu);
+	 *   - drivers/passthrough/vtd/iommu.c|2399| <<vtd_suspend>> disable_qinval(iommu);
+	 *   - drivers/passthrough/vtd/iommu.c|2430| <<vtd_crash_shutdown>> disable_qinval(drhd->iommu);
+	 */
         disable_qinval(drhd->iommu);
     }
 }
diff --git a/xen/drivers/passthrough/vtd/qinval.c b/xen/drivers/passthrough/vtd/qinval.c
index fe29e826c1..0e88d37abd 100644
--- a/xen/drivers/passthrough/vtd/qinval.c
+++ b/xen/drivers/passthrough/vtd/qinval.c
@@ -192,6 +192,10 @@ static int gen_wait_dsc(struct iommu *iommu, int index,
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/qinval.c|246| <<invalidate_sync>> ret = queue_invalidate_wait(iommu, 0, 1, 1);
+ */
 static int queue_invalidate_wait(struct iommu *iommu,
     u8 iflag, u8 sw, u8 fn)
 {
@@ -228,6 +232,14 @@ static int queue_invalidate_wait(struct iommu *iommu,
     return ret;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/intremap.c|361| <<ioapic_rte_to_remap_entry>> invalidate_sync(iommu);
+ *   - drivers/passthrough/vtd/intremap.c|646| <<msi_msg_to_remap_entry>> invalidate_sync(iommu);
+ *   - drivers/passthrough/vtd/qinval.c|339| <<__iommu_flush_iec>> ret |= invalidate_sync(iommu);
+ *   - drivers/passthrough/vtd/qinval.c|385| <<flush_context_qi>> ret |= invalidate_sync(iommu);
+ *   - drivers/passthrough/vtd/qinval.c|427| <<flush_iotlb_qi>> ret |= invalidate_sync(iommu);
+ */
 int invalidate_sync(struct iommu *iommu)
 {
     int ret = -1;
@@ -489,6 +501,13 @@ int enable_qinval(struct iommu *iommu)
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/intremap.c|856| <<iommu_enable_x2apic_IR>> disable_qinval(iommu);
+ *   - drivers/passthrough/vtd/intremap.c|901| <<iommu_disable_x2apic_IR>> disable_qinval(drhd->iommu);
+ *   - drivers/passthrough/vtd/iommu.c|2399| <<vtd_suspend>> disable_qinval(iommu);
+ *   - drivers/passthrough/vtd/iommu.c|2430| <<vtd_crash_shutdown>> disable_qinval(drhd->iommu);
+ */
 void disable_qinval(struct iommu *iommu)
 {
     u32 sts;
@@ -505,6 +524,10 @@ void disable_qinval(struct iommu *iommu)
     dmar_writel(iommu->reg, DMAR_GCMD_REG, sts & (~DMA_GCMD_QIE));
 
     /* Make sure hardware complete it */
+    /*
+     * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+     * 不会hang!!!
+     */
     IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
                   !(sts & DMA_GSTS_QIES), sts);
 out:
diff --git a/xen/drivers/passthrough/vtd/quirks.c b/xen/drivers/passthrough/vtd/quirks.c
index feeeea2895..ee1b3fd4a3 100644
--- a/xen/drivers/passthrough/vtd/quirks.c
+++ b/xen/drivers/passthrough/vtd/quirks.c
@@ -216,6 +216,12 @@ static void snb_vtd_ops_postamble(struct iommu* iommu)
  * call before VT-d translation enable and IOTLB flush operations.
  */
 
+/*
+ * 在以下使用snb_igd_quirk:
+ *   - drivers/passthrough/vtd/quirks.c|220| <<global>> boolean_param("snb_igd_quirk", snb_igd_quirk);
+ *   - drivers/passthrough/vtd/quirks.c|225| <<vtd_ops_preamble_quirk>> if ( snb_igd_quirk )
+ *   - drivers/passthrough/vtd/quirks.c|239| <<vtd_ops_postamble_quirk>> if ( snb_igd_quirk )
+ */
 static int snb_igd_quirk;
 boolean_param("snb_igd_quirk", snb_igd_quirk);
 
diff --git a/xen/drivers/passthrough/vtd/x86/vtd.c b/xen/drivers/passthrough/vtd/x86/vtd.c
index ca17cb12ca..a0e7a8a69f 100644
--- a/xen/drivers/passthrough/vtd/x86/vtd.c
+++ b/xen/drivers/passthrough/vtd/x86/vtd.c
@@ -59,6 +59,10 @@ void cacheline_flush(char * addr)
     clflush(addr);
 }
 
+/*
+ * called by 
+ *   - drivers/passthrough/vtd/iommu.c|588| <<iommu_flush_all>> 
+ */
 void flush_all_cache()
 {
     wbinvd();
-- 
2.17.1

