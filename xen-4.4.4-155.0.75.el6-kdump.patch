From e32071cb7788acb2e1f53e7b5e993035d6b69d56 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Mon, 13 Apr 2020 15:43:11 -0700
Subject: [PATCH 1/1] xen-4.4.4-155.0.75.el6-kdump

xen-4.4.4-155.0.75

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 xen/arch/x86/crash.c       | 25 +++++++++++++++++++++++++
 xen/common/domain.c        | 11 +++++++++++
 xen/common/kexec.c         | 25 +++++++++++++++++++++++++
 xen/common/shutdown.c      |  4 ++++
 xen/drivers/char/console.c | 32 ++++++++++++++++++++++++++++++++
 5 files changed, 97 insertions(+)

diff --git a/xen/arch/x86/crash.c b/xen/arch/x86/crash.c
index c5332a5ea2..84f23548f0 100644
--- a/xen/arch/x86/crash.c
+++ b/xen/arch/x86/crash.c
@@ -36,6 +36,20 @@ static unsigned int crashing_cpu;
 static DEFINE_PER_CPU_READ_MOSTLY(bool_t, crash_save_done);
 
 /* This becomes the NMI handler for non-crashing CPUs, when Xen is crashing. */
+/*
+ * 在以下使用do_nmi_crash():
+ *   - arch/x86/crash.c|148| <<nmi_shootdown_cpus>> (unsigned long )&do_nmi_crash);
+ *
+ * //
+ * // Ideally would be:
+ * //   exception_table[TRAP_nmi] = &do_nmi_crash;
+ * //
+ * // but the exception_table is read only.  Access it via its directmap
+ * // mappings.
+ *
+ * write_atomic((unsigned long *)__va(__pa(&exception_table[TRAP_nmi])),
+ *              (unsigned long)&do_nmi_crash);
+ */
 void __attribute__((noreturn)) do_nmi_crash(struct cpu_user_regs *regs)
 {
     unsigned int cpu = smp_processor_id();
@@ -113,6 +127,10 @@ void __attribute__((noreturn)) do_nmi_crash(struct cpu_user_regs *regs)
         halt();
 }
 
+/*
+ * called by:
+ *   - arch/x86/crash.c|187| <<machine_crash_shutdown>> nmi_shootdown_cpus();
+ */
 static void nmi_shootdown_cpus(void)
 {
     unsigned long msecs;
@@ -180,10 +198,17 @@ static void nmi_shootdown_cpus(void)
     hpet_disable();
 }
 
+/*
+ * called by:
+ *   - common/kexec.c|368| <<kexec_crash>> machine_crash_shutdown();
+ */
 void machine_crash_shutdown(void)
 {
     crash_xen_info_t *info;
 
+    /*
+     * 打印: Shot down all CPUs
+     */
     nmi_shootdown_cpus();
 
     info = kexec_crash_save_info();
diff --git a/xen/common/domain.c b/xen/common/domain.c
index fcb13abf33..01df319807 100644
--- a/xen/common/domain.c
+++ b/xen/common/domain.c
@@ -694,6 +694,17 @@ void __domain_crash_synchronous(void)
 }
 
 
+/*
+ * called by:
+ *   - arch/x86/hvm/hvm.c|1504| <<hvm_vcpu_down>> domain_shutdown(d, SHUTDOWN_poweroff);
+ *   - arch/x86/hvm/hvm.c|1567| <<hvm_triple_fault>> domain_shutdown(d, reason);
+ *   - common/domain.c|682| <<__domain_crash>> domain_shutdown(d, SHUTDOWN_crash);
+ *   - common/page_alloc.c|1125| <<offline_page>> domain_shutdown(owner, SHUTDOWN_crash);
+ *   - common/schedule.c|807| <<domain_watchdog_timeout>> domain_shutdown(d, SHUTDOWN_watchdog);
+ *   - common/schedule.c|893| <<do_sched_op_compat>> domain_shutdown(current->domain, (u8)arg);
+ *   - common/schedule.c|938| <<do_sched_op(SCHEDOP_shutdown)>> domain_shutdown(current->domain, (u8)sched_shutdown.reason);
+ *   - common/schedule.c|998| <<do_sched_op(SCHEDOP_remote_shutdown)>> domain_shutdown(d, (u8)sched_remote_shutdown.reason);
+ */
 void domain_shutdown(struct domain *d, u8 reason)
 {
     struct vcpu *v;
diff --git a/xen/common/kexec.c b/xen/common/kexec.c
index 44ae95d52f..d7ade29d6e 100644
--- a/xen/common/kexec.c
+++ b/xen/common/kexec.c
@@ -242,6 +242,10 @@ void __init set_kexec_crash_area_size(u64 system_ram)
  * This is noinline to make it obvious in stack traces which cpus have lost
  * the race (as opposed to being somewhere in kexec_common_shutdown())
  */
+/*
+ * called by:
+ *   - common/kexec.c|325| <<kexec_common_shutdown>> ret = one_cpu_only();
+ */
 static int noinline one_cpu_only(void)
 {
     static unsigned int crashing_cpu = -1;
@@ -271,6 +275,11 @@ static int noinline one_cpu_only(void)
 }
 
 /* Save the registers in the per-cpu crash note buffer. */
+/*
+ * called by:
+ *   - arch/x86/crash.c|65| <<do_nmi_crash>> kexec_crash_save_cpu();
+ *   - common/kexec.c|367| <<kexec_crash>> kexec_crash_save_cpu();
+ */
 void kexec_crash_save_cpu(void)
 {
     int cpu = smp_processor_id();
@@ -318,6 +327,11 @@ crash_xen_info_t *kexec_crash_save_info(void)
     return out;
 }
 
+/*
+ * called by:
+ *   - common/kexec.c|347| <<kexec_crash>> if ( kexec_common_shutdown() != 0 )
+ *   - common/kexec.c|363| <<kexec_reboot>> kexec_common_shutdown();
+ */
 static int kexec_common_shutdown(void)
 {
     int ret;
@@ -334,6 +348,14 @@ static int kexec_common_shutdown(void)
     return 0;
 }
 
+/*
+ * called by:
+ *   - common/kexec.c|373| <<do_crashdump_trigger>> kexec_crash();
+ *   - common/kexec.c|809| <<kexec_exec(KEXEC_TYPE_CRASH)>> kexec_crash();
+ *   - common/shutdown.c|51| <<dom0_shutdown>> kexec_crash();
+ *   - common/shutdown.c|68| <<dom0_shutdown>> kexec_crash();
+ *   - drivers/char/console.c|1072| <<panic>> kexec_crash();
+ */
 void kexec_crash(void)
 {
     int pos;
@@ -348,6 +370,9 @@ void kexec_crash(void)
         return;
 
     kexec_crash_save_cpu();
+    /*
+     * 打印: Shot down all CPUs
+     */
     machine_crash_shutdown();
     machine_kexec(kexec_image[KEXEC_IMAGE_CRASH_BASE + pos]);
 
diff --git a/xen/common/shutdown.c b/xen/common/shutdown.c
index 90ee384212..162a7e59e1 100644
--- a/xen/common/shutdown.c
+++ b/xen/common/shutdown.c
@@ -32,6 +32,10 @@ static void maybe_reboot(void)
     }
 }
 
+/*
+ * called by:
+ *   - common/domain.c|708| <<domain_shutdown>> dom0_shutdown(reason);
+ */
 void dom0_shutdown(u8 reason)
 {
     switch ( reason )
diff --git a/xen/drivers/char/console.c b/xen/drivers/char/console.c
index 9d1460474c..ebe022c458 100644
--- a/xen/drivers/char/console.c
+++ b/xen/drivers/char/console.c
@@ -65,6 +65,24 @@ static uint32_t conringc, conringp;
 
 static int __read_mostly sercon_handle = -1;
 
+/*
+ * 在以下使用console_lock:
+ *   - drivers/char/console.c|183| <<conring_puts>> ASSERT(spin_is_locked(&console_lock));
+ *   - drivers/char/console.c|221| <<read_console_ring>> spin_lock_irq(&console_lock);
+ *   - drivers/char/console.c|226| <<read_console_ring>> spin_unlock_irq(&console_lock);
+ *   - drivers/char/console.c|396| <<guest_console_write>> spin_lock_irq(&console_lock);
+ *   - drivers/char/console.c|407| <<guest_console_write>> spin_unlock_irq(&console_lock);
+ *   - drivers/char/console.c|505| <<__putstr>> ASSERT(spin_is_locked(&console_lock));
+ *   - drivers/char/console.c|579| <<vprintk_common>> spin_lock_recursive(&console_lock);
+ *   - drivers/char/console.c|614| <<vprintk_common>> spin_unlock_recursive(&console_lock);
+ *   - drivers/char/console.c|670| <<console_init_preirq>> spin_lock(&console_lock);
+ *   - drivers/char/console.c|672| <<console_init_preirq>> spin_unlock(&console_lock);
+ *   - drivers/char/console.c|706| <<console_init_postirq>> spin_lock_irq(&console_lock);
+ *   - drivers/char/console.c|712| <<console_init_postirq>> spin_unlock_irq(&console_lock);
+ *   - drivers/char/console.c|800| <<console_force_unlock>> spin_lock_init(&console_lock);
+ *   - drivers/char/console.c|853| <<__printk_ratelimit>> spin_lock_recursive(&console_lock);
+ *   - drivers/char/console.c|858| <<__printk_ratelimit>> spin_unlock_recursive(&console_lock);
+ */
 static DEFINE_SPINLOCK(console_lock);
 
 /*
@@ -566,6 +584,11 @@ static void printk_start_of_line(const char *prefix)
     __putstr(tstr);
 }
 
+/*
+ * called by:
+ *   - drivers/char/console.c|622| <<printk>> vprintk_common("(XEN) ", fmt, args);
+ *   - drivers/char/console.c|634| <<guest_printk>> vprintk_common(prefix, fmt, args);
+ */
 static void vprintk_common(const char *prefix, const char *fmt, va_list args)
 {
     static char   buf[1024];
@@ -794,6 +817,15 @@ void console_end_log_everything(void)
     atomic_dec(&print_everything);
 }
 
+/*
+ * called by:
+ *   - arch/x86/cpu/mcheck/mce.c|1542| <<mc_panic>> console_force_unlock();
+ *   - arch/x86/nmi.c|479| <<nmi_watchdog_tick>> console_force_unlock();
+ *   - arch/x86/traps.c|3296| <<pci_serr_error>> console_force_unlock();
+ *   - arch/x86/traps.c|3311| <<io_check_error>> console_force_unlock();
+ *   - arch/x86/traps.c|3330| <<unknown_nmi_error>> console_force_unlock();
+ *   - arch/x86/x86_64/traps.c|229| <<do_double_fault>> console_force_unlock();
+ */
 void console_force_unlock(void)
 {
     watchdog_disable();
-- 
2.17.1

