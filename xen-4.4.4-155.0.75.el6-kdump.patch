From dcfaa2e684767c7f30e822f6904a4dd440dd0630 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Sat, 23 May 2020 19:41:31 -0700
Subject: [PATCH 1/1] xen-4.4.4-155.0.75.el6-kdump

xen-4.4.4-155.0.75

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 xen/arch/x86/crash.c                     |  25 ++++
 xen/common/domain.c                      |  11 ++
 xen/common/kexec.c                       |  25 ++++
 xen/common/shutdown.c                    |   4 +
 xen/drivers/char/console.c               |  32 +++++
 xen/drivers/passthrough/amd/iommu_init.c |   4 +
 xen/drivers/passthrough/ats.h            |   7 +
 xen/drivers/passthrough/io.c             |   4 +
 xen/drivers/passthrough/iommu.c          |  70 +++++++++
 xen/drivers/passthrough/pci.c            |  60 ++++++++
 xen/drivers/passthrough/vtd/dmar.c       |  26 ++++
 xen/drivers/passthrough/vtd/dmar.h       |  19 +++
 xen/drivers/passthrough/vtd/intremap.c   |  27 ++++
 xen/drivers/passthrough/vtd/iommu.c      | 172 +++++++++++++++++++++++
 xen/drivers/passthrough/vtd/qinval.c     |  27 ++++
 xen/drivers/passthrough/vtd/quirks.c     |  15 ++
 xen/drivers/passthrough/vtd/utils.c      |   9 ++
 xen/drivers/passthrough/vtd/x86/vtd.c    |   4 +
 xen/drivers/passthrough/x86/ats.c        |  30 ++++
 xen/drivers/pci/pci.c                    |  32 +++++
 20 files changed, 603 insertions(+)

diff --git a/xen/arch/x86/crash.c b/xen/arch/x86/crash.c
index c5332a5ea2..84f23548f0 100644
--- a/xen/arch/x86/crash.c
+++ b/xen/arch/x86/crash.c
@@ -36,6 +36,20 @@ static unsigned int crashing_cpu;
 static DEFINE_PER_CPU_READ_MOSTLY(bool_t, crash_save_done);
 
 /* This becomes the NMI handler for non-crashing CPUs, when Xen is crashing. */
+/*
+ * 在以下使用do_nmi_crash():
+ *   - arch/x86/crash.c|148| <<nmi_shootdown_cpus>> (unsigned long )&do_nmi_crash);
+ *
+ * //
+ * // Ideally would be:
+ * //   exception_table[TRAP_nmi] = &do_nmi_crash;
+ * //
+ * // but the exception_table is read only.  Access it via its directmap
+ * // mappings.
+ *
+ * write_atomic((unsigned long *)__va(__pa(&exception_table[TRAP_nmi])),
+ *              (unsigned long)&do_nmi_crash);
+ */
 void __attribute__((noreturn)) do_nmi_crash(struct cpu_user_regs *regs)
 {
     unsigned int cpu = smp_processor_id();
@@ -113,6 +127,10 @@ void __attribute__((noreturn)) do_nmi_crash(struct cpu_user_regs *regs)
         halt();
 }
 
+/*
+ * called by:
+ *   - arch/x86/crash.c|187| <<machine_crash_shutdown>> nmi_shootdown_cpus();
+ */
 static void nmi_shootdown_cpus(void)
 {
     unsigned long msecs;
@@ -180,10 +198,17 @@ static void nmi_shootdown_cpus(void)
     hpet_disable();
 }
 
+/*
+ * called by:
+ *   - common/kexec.c|368| <<kexec_crash>> machine_crash_shutdown();
+ */
 void machine_crash_shutdown(void)
 {
     crash_xen_info_t *info;
 
+    /*
+     * 打印: Shot down all CPUs
+     */
     nmi_shootdown_cpus();
 
     info = kexec_crash_save_info();
diff --git a/xen/common/domain.c b/xen/common/domain.c
index fcb13abf33..01df319807 100644
--- a/xen/common/domain.c
+++ b/xen/common/domain.c
@@ -694,6 +694,17 @@ void __domain_crash_synchronous(void)
 }
 
 
+/*
+ * called by:
+ *   - arch/x86/hvm/hvm.c|1504| <<hvm_vcpu_down>> domain_shutdown(d, SHUTDOWN_poweroff);
+ *   - arch/x86/hvm/hvm.c|1567| <<hvm_triple_fault>> domain_shutdown(d, reason);
+ *   - common/domain.c|682| <<__domain_crash>> domain_shutdown(d, SHUTDOWN_crash);
+ *   - common/page_alloc.c|1125| <<offline_page>> domain_shutdown(owner, SHUTDOWN_crash);
+ *   - common/schedule.c|807| <<domain_watchdog_timeout>> domain_shutdown(d, SHUTDOWN_watchdog);
+ *   - common/schedule.c|893| <<do_sched_op_compat>> domain_shutdown(current->domain, (u8)arg);
+ *   - common/schedule.c|938| <<do_sched_op(SCHEDOP_shutdown)>> domain_shutdown(current->domain, (u8)sched_shutdown.reason);
+ *   - common/schedule.c|998| <<do_sched_op(SCHEDOP_remote_shutdown)>> domain_shutdown(d, (u8)sched_remote_shutdown.reason);
+ */
 void domain_shutdown(struct domain *d, u8 reason)
 {
     struct vcpu *v;
diff --git a/xen/common/kexec.c b/xen/common/kexec.c
index 44ae95d52f..d7ade29d6e 100644
--- a/xen/common/kexec.c
+++ b/xen/common/kexec.c
@@ -242,6 +242,10 @@ void __init set_kexec_crash_area_size(u64 system_ram)
  * This is noinline to make it obvious in stack traces which cpus have lost
  * the race (as opposed to being somewhere in kexec_common_shutdown())
  */
+/*
+ * called by:
+ *   - common/kexec.c|325| <<kexec_common_shutdown>> ret = one_cpu_only();
+ */
 static int noinline one_cpu_only(void)
 {
     static unsigned int crashing_cpu = -1;
@@ -271,6 +275,11 @@ static int noinline one_cpu_only(void)
 }
 
 /* Save the registers in the per-cpu crash note buffer. */
+/*
+ * called by:
+ *   - arch/x86/crash.c|65| <<do_nmi_crash>> kexec_crash_save_cpu();
+ *   - common/kexec.c|367| <<kexec_crash>> kexec_crash_save_cpu();
+ */
 void kexec_crash_save_cpu(void)
 {
     int cpu = smp_processor_id();
@@ -318,6 +327,11 @@ crash_xen_info_t *kexec_crash_save_info(void)
     return out;
 }
 
+/*
+ * called by:
+ *   - common/kexec.c|347| <<kexec_crash>> if ( kexec_common_shutdown() != 0 )
+ *   - common/kexec.c|363| <<kexec_reboot>> kexec_common_shutdown();
+ */
 static int kexec_common_shutdown(void)
 {
     int ret;
@@ -334,6 +348,14 @@ static int kexec_common_shutdown(void)
     return 0;
 }
 
+/*
+ * called by:
+ *   - common/kexec.c|373| <<do_crashdump_trigger>> kexec_crash();
+ *   - common/kexec.c|809| <<kexec_exec(KEXEC_TYPE_CRASH)>> kexec_crash();
+ *   - common/shutdown.c|51| <<dom0_shutdown>> kexec_crash();
+ *   - common/shutdown.c|68| <<dom0_shutdown>> kexec_crash();
+ *   - drivers/char/console.c|1072| <<panic>> kexec_crash();
+ */
 void kexec_crash(void)
 {
     int pos;
@@ -348,6 +370,9 @@ void kexec_crash(void)
         return;
 
     kexec_crash_save_cpu();
+    /*
+     * 打印: Shot down all CPUs
+     */
     machine_crash_shutdown();
     machine_kexec(kexec_image[KEXEC_IMAGE_CRASH_BASE + pos]);
 
diff --git a/xen/common/shutdown.c b/xen/common/shutdown.c
index 90ee384212..162a7e59e1 100644
--- a/xen/common/shutdown.c
+++ b/xen/common/shutdown.c
@@ -32,6 +32,10 @@ static void maybe_reboot(void)
     }
 }
 
+/*
+ * called by:
+ *   - common/domain.c|708| <<domain_shutdown>> dom0_shutdown(reason);
+ */
 void dom0_shutdown(u8 reason)
 {
     switch ( reason )
diff --git a/xen/drivers/char/console.c b/xen/drivers/char/console.c
index 9d1460474c..ebe022c458 100644
--- a/xen/drivers/char/console.c
+++ b/xen/drivers/char/console.c
@@ -65,6 +65,24 @@ static uint32_t conringc, conringp;
 
 static int __read_mostly sercon_handle = -1;
 
+/*
+ * 在以下使用console_lock:
+ *   - drivers/char/console.c|183| <<conring_puts>> ASSERT(spin_is_locked(&console_lock));
+ *   - drivers/char/console.c|221| <<read_console_ring>> spin_lock_irq(&console_lock);
+ *   - drivers/char/console.c|226| <<read_console_ring>> spin_unlock_irq(&console_lock);
+ *   - drivers/char/console.c|396| <<guest_console_write>> spin_lock_irq(&console_lock);
+ *   - drivers/char/console.c|407| <<guest_console_write>> spin_unlock_irq(&console_lock);
+ *   - drivers/char/console.c|505| <<__putstr>> ASSERT(spin_is_locked(&console_lock));
+ *   - drivers/char/console.c|579| <<vprintk_common>> spin_lock_recursive(&console_lock);
+ *   - drivers/char/console.c|614| <<vprintk_common>> spin_unlock_recursive(&console_lock);
+ *   - drivers/char/console.c|670| <<console_init_preirq>> spin_lock(&console_lock);
+ *   - drivers/char/console.c|672| <<console_init_preirq>> spin_unlock(&console_lock);
+ *   - drivers/char/console.c|706| <<console_init_postirq>> spin_lock_irq(&console_lock);
+ *   - drivers/char/console.c|712| <<console_init_postirq>> spin_unlock_irq(&console_lock);
+ *   - drivers/char/console.c|800| <<console_force_unlock>> spin_lock_init(&console_lock);
+ *   - drivers/char/console.c|853| <<__printk_ratelimit>> spin_lock_recursive(&console_lock);
+ *   - drivers/char/console.c|858| <<__printk_ratelimit>> spin_unlock_recursive(&console_lock);
+ */
 static DEFINE_SPINLOCK(console_lock);
 
 /*
@@ -566,6 +584,11 @@ static void printk_start_of_line(const char *prefix)
     __putstr(tstr);
 }
 
+/*
+ * called by:
+ *   - drivers/char/console.c|622| <<printk>> vprintk_common("(XEN) ", fmt, args);
+ *   - drivers/char/console.c|634| <<guest_printk>> vprintk_common(prefix, fmt, args);
+ */
 static void vprintk_common(const char *prefix, const char *fmt, va_list args)
 {
     static char   buf[1024];
@@ -794,6 +817,15 @@ void console_end_log_everything(void)
     atomic_dec(&print_everything);
 }
 
+/*
+ * called by:
+ *   - arch/x86/cpu/mcheck/mce.c|1542| <<mc_panic>> console_force_unlock();
+ *   - arch/x86/nmi.c|479| <<nmi_watchdog_tick>> console_force_unlock();
+ *   - arch/x86/traps.c|3296| <<pci_serr_error>> console_force_unlock();
+ *   - arch/x86/traps.c|3311| <<io_check_error>> console_force_unlock();
+ *   - arch/x86/traps.c|3330| <<unknown_nmi_error>> console_force_unlock();
+ *   - arch/x86/x86_64/traps.c|229| <<do_double_fault>> console_force_unlock();
+ */
 void console_force_unlock(void)
 {
     watchdog_disable();
diff --git a/xen/drivers/passthrough/amd/iommu_init.c b/xen/drivers/passthrough/amd/iommu_init.c
index 4686813a8b..9691f9ae5b 100644
--- a/xen/drivers/passthrough/amd/iommu_init.c
+++ b/xen/drivers/passthrough/amd/iommu_init.c
@@ -1036,6 +1036,10 @@ error_out:
     return -ENODEV;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/amd/iommu_init.c|1266| <<amd_iommu_init>> amd_iommu_init_cleanup();
+ */
 static void __init amd_iommu_init_cleanup(void)
 {
     struct amd_iommu *iommu, *next;
diff --git a/xen/drivers/passthrough/ats.h b/xen/drivers/passthrough/ats.h
index 000e76db95..20d0379bba 100644
--- a/xen/drivers/passthrough/ats.h
+++ b/xen/drivers/passthrough/ats.h
@@ -18,6 +18,13 @@
 
 #include <xen/pci_regs.h>
 
+/*
+ * Address Translation Service: ATS makes the PCI Endpoint be able to request
+ * the DMA address translation from the IOMMU and cache the translation in the
+ * Endpoint, thus alleviate IOMMU pressure and improve the hardware performance
+ * in the I/O virtualization environment.
+ */
+
 struct pci_ats_dev {
     struct list_head list;
     u16 seg;
diff --git a/xen/drivers/passthrough/io.c b/xen/drivers/passthrough/io.c
index cd386dfc58..45f8654189 100644
--- a/xen/drivers/passthrough/io.c
+++ b/xen/drivers/passthrough/io.c
@@ -93,6 +93,10 @@ void free_hvm_irq_dpci(struct hvm_irq_dpci *dpci)
     xfree(dpci);
 }
 
+/*
+ * called by:
+ *   - arch/x86/domctl.c|750| <<arch_do_domctl(XEN_DOMCTL_bind_pt_irq)>> ret = pt_irq_create_bind(d, bind);
+ */
 int pt_irq_create_bind(
     struct domain *d, xen_domctl_bind_pt_irq_t *pt_irq_bind)
 {
diff --git a/xen/drivers/passthrough/iommu.c b/xen/drivers/passthrough/iommu.c
index c86b237a32..b44a982180 100644
--- a/xen/drivers/passthrough/iommu.c
+++ b/xen/drivers/passthrough/iommu.c
@@ -43,6 +43,11 @@ static void iommu_dump_p2m_table(unsigned char key);
  *   no-intremap                Disable VT-d Interrupt Remapping
  */
 custom_param("iommu", parse_iommu_param);
+/*
+ * 在以下修改iommu_enable:
+ *   - drivers/passthrough/amd/iommu_init.c|1066| <<amd_iommu_init_cleanup>> iommu_enabled = 0;
+ *   - drivers/passthrough/iommu.c|615| <<iommu_setup>> iommu_enabled = (rc == 0);
+ */
 bool_t __initdata iommu_enable = 1;
 bool_t __read_mostly iommu_enabled;
 bool_t __read_mostly force_iommu;
@@ -116,6 +121,10 @@ static void __init parse_iommu_param(char *s)
     } while ( ss );
 }
 
+/*
+ * called by:
+ *   - arch/x86/domain.c|632| <<arch_domain_create>> if ( (rc = iommu_domain_init(d)) != 0 )
+ */
 int iommu_domain_init(struct domain *d)
 {
     struct hvm_iommu *hd = domain_hvm_iommu(d);
@@ -177,6 +186,10 @@ void __init iommu_dom0_init(struct domain *d)
     return hd->platform_ops->dom0_init(d);
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/pci.c|735| <<pci_add_device>> ret = iommu_add_device(pdev);
+ */
 int iommu_add_device(struct pci_dev *pdev)
 {
     struct hvm_iommu *hd;
@@ -208,6 +221,10 @@ int iommu_add_device(struct pci_dev *pdev)
     }
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/pci.c|745| <<pci_add_device>> iommu_enable_device(pdev);
+ */
 int iommu_enable_device(struct pci_dev *pdev)
 {
     struct hvm_iommu *hd;
@@ -265,6 +282,11 @@ static void iommu_teardown(struct domain *d)
     tasklet_schedule(&iommu_pt_cleanup_tasklet);
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/iommu.c|291| <<device_assigned>> return device_assigned_to_domain(dom0, seg, bus, devfn) ? 0 : -EBUSY;
+ *   - drivers/passthrough/iommu.c|296| <<device_hidden>> return device_assigned_to_domain(dom_xen, seg, bus, devfn) ? -EBUSY : 0;
+ */
 static int device_assigned_to_domain(struct domain *d, u16 seg, u8 bus, u8 devfn)
 {
     int rc = 0;
@@ -291,6 +313,13 @@ static int device_hidden(u16 seg, u8 bus, u8 devfn)
     return device_assigned_to_domain(dom_xen, seg, bus, devfn) ? -EBUSY : 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/iommu.c|374| <<assign_device>> if ( (rc = hd->platform_ops->assign_device(d, devfn, pdev)) )
+ *   - drivers/passthrough/iommu.c|382| <<assign_device>> rc = hd->platform_ops->assign_device(d, devfn, pdev);
+ *   - drivers/passthrough/iommu.c|879| <<iommu_do_domctl(XEN_DOMCTL_assign_device)>> ret = assign_device(d, seg, bus, devfn);
+ *   - drivers/passthrough/iommu.c|971| <<iommu_do_domctl(XEN_DOMCTL_hide_device)>> ret = assign_device(dom_xen, seg, bus, devfn);
+ */
 static int assign_device(struct domain *d, u16 seg, u8 bus, u8 devfn)
 {
     struct hvm_iommu *hd = domain_hvm_iommu(d);
@@ -372,6 +401,10 @@ static int assign_device(struct domain *d, u16 seg, u8 bus, u8 devfn)
     return rc;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/iommu.c|355| <<assign_device>> rc = iommu_populate_page_table(d);
+ */
 static int iommu_populate_page_table(struct domain *d)
 {
     struct hvm_iommu *hd = domain_hvm_iommu(d);
@@ -456,6 +489,18 @@ void iommu_domain_destroy(struct domain *d)
     }
 }
 
+/*
+ * called by:
+ *   - arch/x86/mm.c|2590| <<__get_page_type>> iommu_map_page(d, mfn_to_gmfn(d, page_to_mfn(page)),
+ *   - arch/x86/mm/p2m-ept.c|453| <<ept_set_entry>> iommu_map_page(d, gfn + i, mfn_x(mfn) + i, flags);
+ *   - arch/x86/mm/p2m-pt.c|437| <<p2m_pt_set_entry>> iommu_map_page(p2m->domain, gfn+i, mfn_x(mfn)+i, flags);
+ *   - arch/x86/mm/p2m.c|576| <<guest_physmap_add_entry>> rc = iommu_map_page(
+ *   - arch/x86/x86_64/mm.c|1465| <<memory_add>> if ( iommu_map_page(dom0, i, i, IOMMUF_readable|IOMMUF_writable) )
+ *   - common/grant_table.c|992| <<__gnttab_map_grant_ref>> err = iommu_map_page(ld, frame, frame,
+ *   - common/grant_table.c|998| <<__gnttab_map_grant_ref>> err = iommu_map_page(ld, frame, frame, IOMMUF_readable);
+ *   - common/grant_table.c|1255| <<__gnttab_unmap_common>> err = iommu_map_page(ld, op->frame, op->frame, IOMMUF_readable);
+ *   - drivers/passthrough/vtd/x86/vtd.c|146| <<iommu_set_dom0_mapping>> iommu_map_page(d, pfn * tmp + j, pfn * tmp + j,
+ */
 int iommu_map_page(struct domain *d, unsigned long gfn, unsigned long mfn,
                    unsigned int flags)
 {
@@ -641,6 +686,10 @@ int __init iommu_setup(void)
     return rc;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/iommu.c|824| <<iommu_do_domctl(XEN_DOMCTL_get_device_group)>> ret = iommu_get_device_group(d, seg, bus, devfn, sdevs, max_sdevs);
+ */
 static int iommu_get_device_group(
     struct domain *d, u16 seg, u8 bus, u8 devfn,
     XEN_GUEST_HANDLE_64(uint32) buf, int max_sdevs)
@@ -694,6 +743,13 @@ void iommu_update_ire_from_apic(
     ops->update_ire_from_apic(apic, reg, value);
 }
 
+/*
+ * called by:
+ *   - arch/x86/hpet.c|263| <<hpet_msi_write>> int rc = iommu_update_ire_from_msi(&ch->msi, msg);
+ *   - arch/x86/hpet.c|364| <<hpet_setup_msi_irq>> iommu_update_ire_from_msi(&ch->msi, NULL);
+ *   - arch/x86/msi.c|223| <<write_msi_msg>> rc = iommu_update_ire_from_msi(entry, msg);
+ *   - arch/x86/msi.c|518| <<msi_free_irq>> iommu_update_ire_from_msi(entry + nr, NULL);
+ */
 int iommu_update_ire_from_msi(
     struct msi_desc *msi_desc, struct msi_msg *msg)
 {
@@ -701,6 +757,11 @@ int iommu_update_ire_from_msi(
     return iommu_intremap ? ops->update_ire_from_msi(msi_desc, msg) : 0;
 }
 
+/*
+ * called by:
+ *   - arch/x86/hpet.c|282| <<hpet_msi_read>> iommu_read_msi_from_ire(&ch->msi, msg);
+ *   - arch/x86/msi.c|211| <<read_msi_msg>> iommu_read_msi_from_ire(entry, msg);
+ */
 void iommu_read_msi_from_ire(
     struct msi_desc *msi_desc, struct msi_msg *msg)
 {
@@ -743,9 +804,18 @@ void iommu_share_p2m_table(struct domain* d)
         ops->share_p2m(d);
 }
 
+/*
+ * called by:
+ *   - arch/x86/crash.c|188| <<nmi_shootdown_cpus>> iommu_crash_shutdown();
+ */
 void iommu_crash_shutdown(void)
 {
+    /* 返回intel_iommu_ops或者amd_iommu_ops */
     const struct iommu_ops *ops = iommu_get_ops();
+    /*
+     * intel: vtd_crash_shutdown()
+     * amd  : amd_iommu_suspend()
+     */
     if ( iommu_enabled )
         ops->crash_shutdown();
     iommu_enabled = iommu_intremap = 0;
diff --git a/xen/drivers/passthrough/pci.c b/xen/drivers/passthrough/pci.c
index 8514b1a437..506cc3cff8 100644
--- a/xen/drivers/passthrough/pci.c
+++ b/xen/drivers/passthrough/pci.c
@@ -47,6 +47,17 @@ struct pci_seg {
 };
 
 spinlock_t pcidevs_lock = SPIN_LOCK_UNLOCKED;
+/*
+ * called by:
+ *   - drivers/passthrough/pci.c|54| <<get_pseg>> return radix_tree_lookup(&pci_segments, seg);
+ *   - drivers/passthrough/pci.c|77| <<alloc_pseg>> if ( radix_tree_insert(&pci_segments, seg, pseg) )
+ *   - drivers/passthrough/pci.c|95| <<pci_segments_iterate>> if ( !radix_tree_gang_lookup(&pci_segments, (void **)&pseg, seg, 1) )
+ *   - drivers/passthrough/pci.c|106| <<pt_pci_init>> radix_tree_init(&pci_segments);
+ *   - drivers/passthrough/pci.c|465| <<pci_get_pdev>> radix_tree_gang_lookup(&pci_segments, (void **)&pseg, 0, 1);
+ *   - drivers/passthrough/pci.c|475| <<pci_get_pdev>> } while ( radix_tree_gang_lookup(&pci_segments, (void **)&pseg,
+ *   - drivers/passthrough/pci.c|514| <<pci_get_pdev_by_domain>> radix_tree_gang_lookup(&pci_segments, (void **)&pseg, 0, 1);
+ *   - drivers/passthrough/pci.c|525| <<pci_get_pdev_by_domain>> } while ( radix_tree_gang_lookup(&pci_segments, (void **)&pseg,
+ */
 static struct radix_tree_root pci_segments;
 
 static inline struct pci_seg *get_pseg(u16 seg)
@@ -59,6 +70,13 @@ bool_t pci_known_segment(u16 seg)
     return get_pseg(seg) != NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/pci.c|107| <<pt_pci_init>> if ( !alloc_pseg(0) )
+ *   - drivers/passthrough/pci.c|113| <<pci_add_segment>> return alloc_pseg(seg) ? 0 : -ENOMEM;
+ *   - drivers/passthrough/pci.c|427| <<pci_ro_device>> struct pci_seg *pseg = alloc_pseg(seg);
+ *   - drivers/passthrough/pci.c|606| <<pci_add_device>> pseg = alloc_pseg(seg);
+ */
 static struct pci_seg *alloc_pseg(u16 seg)
 {
     struct pci_seg *pseg = get_pseg(seg);
@@ -101,6 +119,10 @@ static int pci_segments_iterate(
     return rc;
 }
 
+/*
+ * called by:
+ *   - arch/x86/setup.c|1428| <<__start_xen>> pt_pci_init();
+ */
 void __init pt_pci_init(void)
 {
     radix_tree_init(&pci_segments);
@@ -263,6 +285,13 @@ static void check_pdev(const struct pci_dev *pdev)
 #undef PCI_STATUS_CHECK
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/pci.c|414| <<pci_hide_device>> pdev = alloc_pdev(get_pseg(0), bus, devfn);
+ *   - drivers/passthrough/pci.c|432| <<pci_ro_device>> pdev = alloc_pdev(pseg, bus, devfn);
+ *   - drivers/passthrough/pci.c|609| <<pci_add_device>> pdev = alloc_pdev(pseg, bus, devfn);
+ *   - drivers/passthrough/pci.c|965| <<_scan_pci_devices>> pdev = alloc_pdev(pseg, bus, PCI_DEVFN(dev, func));
+ */
 static struct pci_dev *alloc_pdev(struct pci_seg *pseg, u8 bus, u8 devfn)
 {
     struct pci_dev *pdev;
@@ -499,6 +528,17 @@ struct pci_dev *pci_get_real_pdev(int seg, int bus, int devfn)
     return pdev;
 }
 
+/*
+ * called by:
+ *   - arch/x86/irq.c|1968| <<map_domain_pirq>> pdev = pci_get_pdev_by_domain(d, msi->seg, msi->bus, msi->devfn);
+ *   - drivers/passthrough/iommu.c|278| <<device_assigned_to_domain>> if ( pci_get_pdev_by_domain(d, seg, bus, devfn) )
+ *   - drivers/passthrough/iommu.c|348| <<assign_device>> pdev = pci_get_pdev_by_domain(dom0, seg, bus, devfn);
+ *   - drivers/passthrough/iommu.c|573| <<deassign_device>> pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);
+ *   - arch/x86/irq.c|1968| <<map_domain_pirq>> pdev = pci_get_pdev_by_domain(d, msi->seg, msi->bus, msi->devfn);
+ *   - drivers/passthrough/iommu.c|278| <<device_assigned_to_domain>> if ( pci_get_pdev_by_domain(d, seg, bus, devfn) )
+ *   - drivers/passthrough/iommu.c|348| <<assign_device>> pdev = pci_get_pdev_by_domain(dom0, seg, bus, devfn);
+ *   - drivers/passthrough/iommu.c|573| <<deassign_device>> pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);
+ */
 struct pci_dev *pci_get_pdev_by_domain(
     struct domain *d, int seg, int bus, int devfn)
 {
@@ -565,6 +605,13 @@ static void pci_enable_acs(struct pci_dev *pdev)
     pci_conf_write16(seg, bus, dev, func, pos + PCI_ACS_CTRL, ctrl);
 }
 
+/*
+ * called by:
+ *   - arch/x86/physdev.c|569| <<do_physdev_op(PHYSDEVOP_manage_pci_add)>> ret = pci_add_device(0, manage_pci.bus, manage_pci.devfn, NULL, -1);
+ *   - arch/x86/physdev.c|599| <<do_physdev_op(PHYSDEVOP_manage_pci_add_ext)>> ret = pci_add_device(0, manage_pci_ext.bus,
+ *   - arch/x86/physdev.c|635| <<do_physdev_op(PHYSDEVOP_pci_device_add)>> ret = pci_add_device(add.seg, add.bus, add.devfn, &pdev_info, node);
+ *   - drivers/passthrough/pci.c|590| <<pci_add_device>> pci_add_device(seg, info->physfn.bus, info->physfn.devfn, NULL, node);
+ */
 int pci_add_device(u16 seg, u8 bus, u8 devfn, const struct pci_dev_info *info, int node)
 {
     struct pci_seg *pseg;
@@ -936,6 +983,10 @@ void pci_check_disable_device(u16 seg, u8 bus, u8 devfn)
  * scan pci devices to add all existed PCI devices to alldevs_list,
  * and setup pci hierarchy in array bus2bridge.
  */
+/*
+ * 在以下使用_scan_pci_devices():
+ *   - drivers/passthrough/pci.c|979| <<scan_pci_devices>> ret = pci_segments_iterate(_scan_pci_devices, NULL);
+ */
 static int __init _scan_pci_devices(struct pci_seg *pseg, void *arg)
 {
     struct pci_dev *pdev;
@@ -971,6 +1022,11 @@ static int __init _scan_pci_devices(struct pci_seg *pseg, void *arg)
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/amd/pci_amd_iommu.c|223| <<amd_iov_detect>> return scan_pci_devices();
+ *   - drivers/passthrough/vtd/iommu.c|2315| <<intel_vtd_setup>> scan_pci_devices();
+ */
 int __init scan_pci_devices(void)
 {
     int ret;
@@ -1008,6 +1064,10 @@ static void setup_one_dom0_device(const struct setup_dom0 *ctxt,
               PCI_SLOT(devfn) == PCI_SLOT(pdev->devfn) );
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/pci.c|1067| <<setup_dom0_pci_devices>> pci_segments_iterate(_setup_dom0_pci_devices, &ctxt);
+ */
 static int __init _setup_dom0_pci_devices(struct pci_seg *pseg, void *arg)
 {
     struct setup_dom0 *ctxt = arg;
diff --git a/xen/drivers/passthrough/vtd/dmar.c b/xen/drivers/passthrough/vtd/dmar.c
index f5b85f2ad3..f7727a1713 100644
--- a/xen/drivers/passthrough/vtd/dmar.c
+++ b/xen/drivers/passthrough/vtd/dmar.c
@@ -41,6 +41,24 @@
 #define MIN_SCOPE_LEN (sizeof(struct acpi_dmar_device_scope) + \
                        sizeof(struct acpi_dmar_pci_path))
 
+/*
+ * 在以下使用acpi_drhd_units:
+ *   - drivers/passthrough/vtd/dmar.c|71| <<acpi_register_drhd_unit>> list_add_tail(&drhd->list, &acpi_drhd_units);
+ *   - drivers/passthrough/vtd/dmar.c|73| <<acpi_register_drhd_unit>> list_add(&drhd->list, &acpi_drhd_units);
+ *   - drivers/passthrough/vtd/dmar.c|99| <<disable_all_dmar_units>> list_for_each_entry_safe ( drhd, _drhd, &acpi_drhd_units, list )
+ *   - drivers/passthrough/vtd/dmar.c|133| <<ioapic_to_drhd>> list_for_each_entry( drhd, &acpi_drhd_units, list )
+ *   - drivers/passthrough/vtd/dmar.c|146| <<iommu_to_drhd>> list_for_each_entry( drhd, &acpi_drhd_units, list )
+ *   - drivers/passthrough/vtd/dmar.c|157| <<ioapic_to_iommu>> list_for_each_entry( drhd, &acpi_drhd_units, list )
+ *   - drivers/passthrough/vtd/dmar.c|178| <<hpet_to_drhd>> list_for_each_entry( drhd, &acpi_drhd_units, list )
+ *   - drivers/passthrough/vtd/dmar.c|230| <<acpi_find_matched_drhd_unit>> list_for_each_entry ( drhd, &acpi_drhd_units, list )
+ *   - drivers/passthrough/vtd/dmar.h|95| <<for_each_drhd_unit>> list_for_each_entry(drhd, &acpi_drhd_units, list)
+ *   - drivers/passthrough/vtd/intremap.c|152| <<iommu_supports_eim>> if ( !iommu_qinval || !iommu_intremap || list_empty(&acpi_drhd_units) )
+ *   - drivers/passthrough/vtd/iommu.c|1020| <<do_iommu_page_fault>> if ( list_empty(&acpi_drhd_units) )
+ *   - drivers/passthrough/vtd/iommu.c|1768| <<iommu_domain_teardown>> if ( list_empty(&acpi_drhd_units) )
+ *   - drivers/passthrough/vtd/iommu.c|2238| <<intel_vtd_setup>> if ( list_empty(&acpi_drhd_units) )
+ *   - drivers/passthrough/vtd/iommu.c|2342| <<intel_iommu_assign_device>> if ( list_empty(&acpi_drhd_units) )
+ *   - drivers/passthrough/vtd/iommu.c|2571| <<vtd_dump_p2m_table>> if ( list_empty(&acpi_drhd_units) )
+ */
 LIST_HEAD_READ_MOSTLY(acpi_drhd_units);
 LIST_HEAD_READ_MOSTLY(acpi_rmrr_units);
 static LIST_HEAD_READ_MOSTLY(acpi_atsr_units);
@@ -455,6 +473,10 @@ static int __init acpi_dmar_check_length(
     return -EINVAL;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/dmar.c|842| <<acpi_parse_dmar>> ret = acpi_parse_one_drhd(entry_header);
+ */
 static int __init
 acpi_parse_one_drhd(struct acpi_dmar_header *header)
 {
@@ -869,6 +891,10 @@ out:
 /* SINIT saved in SinitMleData in TXT heap (which is DMA protected) */
 #define parse_dmar_table(h) tboot_parse_dmar_table(h)
 
+/*
+ * called by:
+ *   - arch/x86/acpi/boot.c|747| <<acpi_boot_init>> acpi_dmar_init();
+ */
 int __init acpi_dmar_init(void)
 {
     acpi_physical_address dmar_addr;
diff --git a/xen/drivers/passthrough/vtd/dmar.h b/xen/drivers/passthrough/vtd/dmar.h
index 479dbeff60..b2b64cf204 100644
--- a/xen/drivers/passthrough/vtd/dmar.h
+++ b/xen/drivers/passthrough/vtd/dmar.h
@@ -118,6 +118,25 @@ struct acpi_atsr_unit *acpi_find_matched_atsr_unit(const struct pci_dev *);
           __FILE__, __LINE__, __func__);
 #endif
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/intremap.c|768| <<enable_intremap>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/intremap.c|780| <<enable_intremap>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/intremap.c|803| <<disable_intremap>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/intremap.c|822| <<disable_intremap>> IOMMU_WAIT_OP(iommu, DMAR_IRTA_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/iommu.c|333| <<iommu_flush_write_buffer>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/iommu.c|385| <<flush_context_reg>> IOMMU_WAIT_OP(iommu, DMAR_CCMD_REG, dmar_readq,
+ *   - drivers/passthrough/vtd/iommu.c|475| <<flush_iotlb_reg>> IOMMU_WAIT_OP(iommu, (tlb_offset + 8), dmar_readq,
+ *   - drivers/passthrough/vtd/iommu.c|728| <<iommu_set_root_entry>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/iommu.c|764| <<iommu_enable_translation>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/iommu.c|788| <<iommu_disable_translation>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/qinval.c|485| <<enable_qinval>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/qinval.c|508| <<disable_qinval>> IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
+ *   - drivers/passthrough/vtd/utils.c|52| <<disable_pmr>> IOMMU_WAIT_OP(iommu, DMAR_PMEN_REG, dmar_readl,
+ *
+ * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+ * 不会hang!!!
+ */
 #define IOMMU_WAIT_OP(iommu, offset, op, cond, sts) \
 do {                                                \
     s_time_t start_time = NOW();                    \
diff --git a/xen/drivers/passthrough/vtd/intremap.c b/xen/drivers/passthrough/vtd/intremap.c
index 2f8b9ebc23..834b20a6f5 100644
--- a/xen/drivers/passthrough/vtd/intremap.c
+++ b/xen/drivers/passthrough/vtd/intremap.c
@@ -487,6 +487,10 @@ static void set_msi_source_id(struct pci_dev *pdev, struct iremap_entry *ire)
    }
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/intremap.c|662| <<msi_msg_read_remap_rte>> remap_entry_to_msi_msg(drhd->iommu, msg,
+ */
 static int remap_entry_to_msi_msg(
     struct iommu *iommu, struct msi_msg *msg, unsigned int index)
 {
@@ -650,6 +654,9 @@ static int msi_msg_to_remap_entry(
     return 0;
 }
 
+/*
+ * struct iommu_ops intel_iommu_ops.read_msi_from_ire = msi_msg_read_remap_rte()
+ */
 void msi_msg_read_remap_rte(
     struct msi_desc *msi_desc, struct msi_msg *msg)
 {
@@ -784,6 +791,13 @@ int enable_intremap(struct iommu *iommu, int eim)
     return init_apic_pin_2_ir_idx();
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/intremap.c|855| <<iommu_enable_x2apic_IR>> disable_intremap(iommu);
+ *   - drivers/passthrough/vtd/intremap.c|898| <<iommu_disable_x2apic_IR>> disable_intremap(drhd->iommu);
+ *   - drivers/passthrough/vtd/iommu.c|2165| <<init_vtd_hw>> disable_intremap(drhd->iommu);
+ *   - drivers/passthrough/vtd/iommu.c|2429| <<vtd_crash_shutdown>> disable_intremap(drhd->iommu);
+ */
 void disable_intremap(struct iommu *iommu)
 {
     u32 sts;
@@ -800,6 +814,10 @@ void disable_intremap(struct iommu *iommu)
 
     dmar_writel(iommu->reg, DMAR_GCMD_REG, sts & (~DMA_GCMD_IRE));
 
+    /*
+     * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+     * 不会hang!!!
+     */
     IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
                   !(sts & DMA_GSTS_IRES), sts);
 
@@ -819,6 +837,10 @@ void disable_intremap(struct iommu *iommu)
         goto out;
 
     dmar_writel(iommu->reg, DMAR_IRTA_REG, irta & ~IRTA_EIME);
+    /*
+     * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+     * 不会hang!!!
+     */
     IOMMU_WAIT_OP(iommu, DMAR_IRTA_REG, dmar_readl,
                   !(irta & IRTA_EIME), irta);
 
@@ -830,6 +852,11 @@ out:
  * This function is used to enable Interrupt remapping when
  * enable x2apic
  */
+/*
+ * called by:
+ *   - arch/x86/apic.c|526| <<resume_x2apic>> iommu_enable_x2apic_IR();
+ *   - arch/x86/apic.c|969| <<x2apic_bsp_setup>> if ( iommu_enable_x2apic_IR() )
+ */
 int iommu_enable_x2apic_IR(void)
 {
     struct acpi_drhd_unit *drhd;
diff --git a/xen/drivers/passthrough/vtd/iommu.c b/xen/drivers/passthrough/vtd/iommu.c
index 2036d56301..b1c3eb98b3 100644
--- a/xen/drivers/passthrough/vtd/iommu.c
+++ b/xen/drivers/passthrough/vtd/iommu.c
@@ -52,8 +52,19 @@ struct mapped_rmrr {
 /* Possible unfiltered LAPIC/MSI messages from untrusted sources? */
 bool_t __read_mostly untrusted_msi;
 
+/*
+ * 在以下使用nr_iommus:
+ *   - drivers/passthrough/vtd/iommu.c|1188| <<iommu_alloc>> if ( nr_iommus > MAX_IOMMUS )
+ *   - drivers/passthrough/vtd/iommu.c|1191| <<iommu_alloc>> "IOMMU: nr_iommus %d > MAX_IOMMUS\n", nr_iommus);
+ *   - drivers/passthrough/vtd/iommu.c|1216| <<iommu_alloc>> iommu->index = nr_iommus++;
+ */
 int nr_iommus;
 
+/*
+ * 在以下使用vtd_fault_tasklet:
+ *   - drivers/passthrough/vtd/iommu.c|1056| <<iommu_page_fault>> tasklet_schedule(&vtd_fault_tasklet);
+ *   - drivers/passthrough/vtd/iommu.c|2335| <<intel_vtd_setup>> softirq_tasklet_init(&vtd_fault_tasklet, do_iommu_page_fault, 0);
+ */
 static struct tasklet vtd_fault_tasklet;
 
 static int setup_dom0_device(u8 devfn, struct pci_dev *);
@@ -382,6 +393,10 @@ static int flush_context_reg(
     dmar_writeq(iommu->reg, DMAR_CCMD_REG, val);
 
     /* Make sure hardware complete it */
+    /*
+     * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+     * 不会hang!!!
+     */
     IOMMU_WAIT_OP(iommu, DMAR_CCMD_REG, dmar_readq,
                   !(val & DMA_CCMD_ICC), val);
 
@@ -390,10 +405,21 @@ static int flush_context_reg(
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|556| <<iommu_flush_all>> iommu_flush_context_global(iommu, 0);
+ */
 static int iommu_flush_context_global(
     struct iommu *iommu, int flush_non_present_entry)
 {
     struct iommu_flush *flush = iommu_get_flush(iommu);
+    /*
+     * 在以下设置context:
+     *   - drivers/passthrough/vtd/iommu.c|2120| <<init_vtd_hw>> flush->context = flush_context_reg;
+     *   - drivers/passthrough/vtd/qinval.c|463| <<enable_qinval>> flush->context = flush_context_qi;
+     *
+     * 更大的可能是flush_context_qi()
+     */
     return flush->context(iommu, 0, 0, 0, DMA_CCMD_GLOBAL_INVL,
                                  flush_non_present_entry);
 }
@@ -475,6 +501,10 @@ static int flush_iotlb_reg(void *_iommu, u16 did,
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|558| <<iommu_flush_all>> iommu_flush_iotlb_global(iommu, 0, flush_dev_iotlb);
+ */
 static int iommu_flush_iotlb_global(struct iommu *iommu,
     int flush_non_present_entry, int flush_dev_iotlb)
 {
@@ -484,6 +514,13 @@ static int iommu_flush_iotlb_global(struct iommu *iommu,
     /* apply platform specific errata workarounds */
     vtd_ops_preamble_quirk(iommu);
 
+    /*
+     * 在以下设置iotlb:
+     *   - drivers/passthrough/vtd/iommu.c|2113| <<init_vtd_hw>> flush->iotlb = flush_iotlb_reg;
+     *   - drivers/passthrough/vtd/qinval.c|464| <<enable_qinval>> flush->iotlb = flush_iotlb_qi;
+     *
+     * 更大的可能是flush_iotlb_qi()
+     */
     status = flush->iotlb(iommu, 0, 0, 0, DMA_TLB_GLOBAL_FLUSH,
                         flush_non_present_entry, flush_dev_iotlb);
 
@@ -543,18 +580,39 @@ static int iommu_flush_iotlb_psi(
     return status;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|1269| <<intel_iommu_dom0_init>> iommu_flush_all();
+ *   - drivers/passthrough/vtd/iommu.c|2155| <<init_vtd_hw>> iommu_flush_all();
+ *   - drivers/passthrough/vtd/iommu.c|2344| <<vtd_suspend>> iommu_flush_all();
+ *   - drivers/passthrough/vtd/iommu.c|2383| <<vtd_crash_shutdown>> iommu_flush_all();
+ */
 static void iommu_flush_all(void)
 {
     struct acpi_drhd_unit *drhd;
     struct iommu *iommu;
     int flush_dev_iotlb;
 
+    /*
+     * 在以下调用flush_all_cache():
+     *   - - drivers/passthrough/vtd/iommu.c|588| <<iommu_flush_all>> flush_all_cache();
+     *
+     * 就是一个wbinvd();
+     */
     flush_all_cache();
     for_each_drhd_unit ( drhd )
     {
         iommu = drhd->iommu;
+	/*
+	 * 在以下调用iommu_flush_context_global():
+	 *   - drivers/passthrough/vtd/iommu.c|556| <<iommu_flush_all>> iommu_flush_context_global(iommu, 0);
+	 */
         iommu_flush_context_global(iommu, 0);
         flush_dev_iotlb = find_ats_dev_drhd(iommu) ? 1 : 0;
+	/*
+	 * 在以下调用iommu_flush_iotlb_global():
+	 *   - drivers/passthrough/vtd/iommu.c|558| <<iommu_flush_all>> iommu_flush_iotlb_global(iommu, 0, flush_dev_iotlb);
+	 */
         iommu_flush_iotlb_global(iommu, 0, flush_dev_iotlb);
     }
 }
@@ -605,6 +663,9 @@ static void intel_iommu_iotlb_flush(struct domain *d, unsigned long gfn, unsigne
     __intel_iommu_iotlb_flush(d, gfn, 1, page_count);
 }
 
+/*
+ * iommu_ops intel_iommu_ops.iotlb_flush_all = intel_iommu_iotlb_flush_all()
+ */
 static void intel_iommu_iotlb_flush_all(struct domain *d)
 {
     __intel_iommu_iotlb_flush(d, 0, 0, 0);
@@ -685,6 +746,10 @@ static void iommu_free_page_table(struct page_info *pg)
     free_pgtable_maddr(pt_maddr);
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|2251| <<init_vtd_hw>> ret = iommu_set_root_entry(iommu);
+ */
 static int iommu_set_root_entry(struct iommu *iommu)
 {
     u32 sts;
@@ -704,6 +769,11 @@ static int iommu_set_root_entry(struct iommu *iommu)
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|1358| <<intel_iommu_dom0_init>> iommu_enable_translation(drhd);
+ *   - drivers/passthrough/vtd/iommu.c|2575| <<vtd_resume>> iommu_enable_translation(drhd);
+ */
 static void iommu_enable_translation(struct acpi_drhd_unit *drhd)
 {
     u32 sts;
@@ -744,6 +814,11 @@ static void iommu_enable_translation(struct acpi_drhd_unit *drhd)
     disable_pmr(iommu);
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|2392| <<vtd_suspend>> iommu_disable_translation(iommu);
+ *   - drivers/passthrough/vtd/iommu.c|2428| <<vtd_crash_shutdown>> iommu_disable_translation(iommu);
+ */
 static void iommu_disable_translation(struct iommu *iommu)
 {
     u32 sts;
@@ -757,6 +832,10 @@ static void iommu_disable_translation(struct iommu *iommu)
     dmar_writel(iommu->reg, DMAR_GCMD_REG, sts & (~DMA_GCMD_TE));
 
     /* Make sure hardware complete it */
+    /*
+     * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+     * 不会hang!!!
+     */
     IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
                   !(sts & DMA_GSTS_TES), sts);
     spin_unlock_irqrestore(&iommu->register_lock, flags);
@@ -821,6 +900,10 @@ static const char *iommu_get_fault_reason(u8 fault_reason,
     }
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|995| <<__do_iommu_page_fault>> iommu_page_fault_do_one(iommu, type, fault_reason,
+ */
 static int iommu_page_fault_do_one(struct iommu *iommu, int type,
                                    u8 fault_reason, u16 source_id, u64 addr)
 {
@@ -887,6 +970,10 @@ static void iommu_fault_status(u32 fault_status)
 }
 
 #define PRIMARY_FAULT_REG_LEN (16)
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|1033| <<do_iommu_page_fault>> __do_iommu_page_fault(drhd->iommu);
+ */
 static void __do_iommu_page_fault(struct iommu *iommu)
 {
     int reg, fault_index;
@@ -957,6 +1044,10 @@ clear_overflow:
     }
 }
 
+/*
+ * 在以下使用do_iommu_page_fault():
+ *   - drivers/passthrough/vtd/iommu.c|2298| <<intel_vtd_setup>> softirq_tasklet_init(&vtd_fault_tasklet, do_iommu_page_fault, 0);
+ */
 static void do_iommu_page_fault(unsigned long data)
 {
     struct acpi_drhd_unit *drhd;
@@ -1111,6 +1202,10 @@ static int __init iommu_set_interrupt(struct acpi_drhd_unit *drhd)
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/dmar.c|505| <<acpi_parse_one_drhd>> ret = iommu_alloc(dmaru);
+ */
 int __init iommu_alloc(struct acpi_drhd_unit *drhd)
 {
     struct iommu *iommu;
@@ -1419,6 +1514,12 @@ int domain_context_mapping_one(
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|1762| <<reassign_device_ownership>> ret = domain_context_mapping(target, devfn, pdev);
+ *   - drivers/passthrough/vtd/iommu.c|1984| <<intel_iommu_add_device>> ret = domain_context_mapping(pdev->domain, devfn, pdev);
+ *   - drivers/passthrough/vtd/iommu.c|2093| <<setup_dom0_device>> return domain_context_mapping(pdev->domain, devfn, pdev);
+ */
 static int domain_context_mapping(
     struct domain *domain, u8 devfn, const struct pci_dev *pdev)
 {
@@ -1899,6 +2000,9 @@ static int rmrr_identity_mapping(struct domain *d,
     return 0;
 }
 
+/*
+ * struct iommu_ops intel_iommu_ops.add_device = intel_iommu_add_device()
+ */
 static int intel_iommu_add_device(u8 devfn, struct pci_dev *pdev)
 {
     struct acpi_rmrr_unit *rmrr;
@@ -1934,6 +2038,9 @@ static int intel_iommu_add_device(u8 devfn, struct pci_dev *pdev)
     return ret;
 }
 
+/*
+ * struct iommu_ops intel_iommu_ops.enable_device = intel_iommu_enable_device()
+ */
 static int intel_iommu_enable_device(struct pci_dev *pdev)
 {
     struct acpi_drhd_unit *drhd = acpi_find_matched_drhd_unit(pdev);
@@ -2010,6 +2117,10 @@ static int intel_iommu_remove_device(u8 devfn, struct pci_dev *pdev)
     return domain_context_unmap(pdev->domain, devfn, pdev);
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|1334| <<intel_iommu_dom0_init>> setup_dom0_pci_devices(d, setup_dom0_device);
+ */
 static int __init setup_dom0_device(u8 devfn, struct pci_dev *pdev)
 {
     return domain_context_mapping(pdev->domain, devfn, pdev);
@@ -2040,6 +2151,11 @@ static void adjust_irq_affinity(struct acpi_drhd_unit *drhd)
     dma_msi_set_affinity(irq_to_desc(drhd->iommu->msi.irq), cpumask);
 }
 
+/*
+ * called by:
+ *   - arch/x86/acpi/power.c|225| <<enter_state>> adjust_vtd_irq_affinities();
+ *   - drivers/passthrough/vtd/iommu.c|2123| <<global>> __initcall(adjust_vtd_irq_affinities);
+ */
 int adjust_vtd_irq_affinities(void)
 {
     struct acpi_drhd_unit *drhd;
@@ -2173,6 +2289,10 @@ static void __init setup_dom0_rmrr(struct domain *d)
     spin_unlock(&pcidevs_lock);
 }
 
+/*
+ * called by:
+ *   - include/asm-x86/hvm/iommu.h|32| <<iommu_hardware_setup>> return intel_vtd_setup();
+ */
 int __init intel_vtd_setup(void)
 {
     struct acpi_drhd_unit *drhd;
@@ -2275,6 +2395,9 @@ int __init intel_vtd_setup(void)
     return ret;
 }
 
+/*
+ * struct iommu_ops intel_iommu_ops.assign_device = intel_iommu_assign_device()
+ */
 static int intel_iommu_assign_device(
     struct domain *d, u8 devfn, struct pci_dev *pdev)
 {
@@ -2372,21 +2495,63 @@ static void vtd_suspend(void)
     }
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/iommu.c|759| <<iommu_crash_shutdown>> ops->crash_shutdown();
+ *
+ * struct iommu_ops intel_iommu_ops.crash_shutdown = vtd_crash_shutdown()
+ */
 static void vtd_crash_shutdown(void)
 {
     struct acpi_drhd_unit *drhd;
     struct iommu *iommu;
 
+    /*
+     * 在以下修改iommu_enable:
+     *   - drivers/passthrough/amd/iommu_init.c|1066| <<amd_iommu_init_cleanup>> iommu_enabled = 0;
+     *   - drivers/passthrough/iommu.c|615| <<iommu_setup>> iommu_enabled = (rc == 0)
+     */
     if ( !iommu_enabled )
         return;
 
+    /*
+     * 在以下调用iommu_flush_all():
+     *   - drivers/passthrough/vtd/iommu.c|1269| <<intel_iommu_dom0_init>> iommu_flush_all();
+     *   - drivers/passthrough/vtd/iommu.c|2155| <<init_vtd_hw>> iommu_flush_all();
+     *   - drivers/passthrough/vtd/iommu.c|2344| <<vtd_suspend>> iommu_flush_all();
+     *   - drivers/passthrough/vtd/iommu.c|2383| <<vtd_crash_shutdown>> iommu_flush_all();
+     *
+     * upstream是这样的:
+     * 2599     if ( iommu_flush_all() )
+     * 2600         printk(XENLOG_WARNING VTDPREFIX
+     * 2601                " crash shutdown: IOMMU flush all failed\n");
+     */
     iommu_flush_all();
 
     for_each_drhd_unit ( drhd )
     {
         iommu = drhd->iommu;
+	/*
+	 * 在以下调用iommu_disable_translation():
+	 *   - drivers/passthrough/vtd/iommu.c|2392| <<vtd_suspend>> iommu_disable_translation(iommu);
+	 *   - drivers/passthrough/vtd/iommu.c|2428| <<vtd_crash_shutdown>> iommu_disable_translation(iommu);
+	 */
         iommu_disable_translation(iommu);
+	/*
+	 * 在以下调用disable_intremap():
+	 *   - drivers/passthrough/vtd/intremap.c|855| <<iommu_enable_x2apic_IR>> disable_intremap(iommu);
+	 *   - drivers/passthrough/vtd/intremap.c|898| <<iommu_disable_x2apic_IR>> disable_intremap(drhd->iommu);
+	 *   - drivers/passthrough/vtd/iommu.c|2165| <<init_vtd_hw>> disable_intremap(drhd->iommu);
+	 *   - drivers/passthrough/vtd/iommu.c|2429| <<vtd_crash_shutdown>> disable_intremap(drhd->iommu);
+	 */
         disable_intremap(drhd->iommu);
+	/*
+	 * 在以下调用disable_qinval():
+	 *   - drivers/passthrough/vtd/intremap.c|856| <<iommu_enable_x2apic_IR>> disable_qinval(iommu);
+	 *   - drivers/passthrough/vtd/intremap.c|901| <<iommu_disable_x2apic_IR>> disable_qinval(drhd->iommu);
+	 *   - drivers/passthrough/vtd/iommu.c|2399| <<vtd_suspend>> disable_qinval(iommu);
+	 *   - drivers/passthrough/vtd/iommu.c|2430| <<vtd_crash_shutdown>> disable_qinval(drhd->iommu);
+	 */
         disable_qinval(drhd->iommu);
     }
 }
@@ -2466,6 +2631,9 @@ static void vtd_dump_p2m_table_level(paddr_t pt_maddr, int level, paddr_t gpa,
     unmap_vtd_domain_page(pt_vaddr);
 }
 
+/*
+ * struct iommu_ops intel_iommu_ops.dump_p2m_table()
+ */
 static void vtd_dump_p2m_table(struct domain *d)
 {
     struct hvm_iommu *hd;
@@ -2478,6 +2646,10 @@ static void vtd_dump_p2m_table(struct domain *d)
     vtd_dump_p2m_table_level(hd->pgd_maddr, agaw_to_level(hd->agaw), 0, 0);
 }
 
+/*
+ * called by:
+ *   - include/asm-x86/hvm/iommu.h|17| <<iommu_get_ops>> return &intel_iommu_ops;
+ */
 const struct iommu_ops intel_iommu_ops = {
     .init = intel_iommu_domain_init,
     .dom0_init = intel_iommu_dom0_init,
diff --git a/xen/drivers/passthrough/vtd/qinval.c b/xen/drivers/passthrough/vtd/qinval.c
index fe29e826c1..f27cf17f52 100644
--- a/xen/drivers/passthrough/vtd/qinval.c
+++ b/xen/drivers/passthrough/vtd/qinval.c
@@ -29,6 +29,10 @@
 #include "vtd.h"
 #include "extern.h"
 
+/*
+ * VT-d Queued Invalidation
+ */
+
 static void print_qi_regs(struct iommu *iommu)
 {
     u64 val;
@@ -192,6 +196,10 @@ static int gen_wait_dsc(struct iommu *iommu, int index,
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/qinval.c|246| <<invalidate_sync>> ret = queue_invalidate_wait(iommu, 0, 1, 1);
+ */
 static int queue_invalidate_wait(struct iommu *iommu,
     u8 iflag, u8 sw, u8 fn)
 {
@@ -228,6 +236,14 @@ static int queue_invalidate_wait(struct iommu *iommu,
     return ret;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/intremap.c|361| <<ioapic_rte_to_remap_entry>> invalidate_sync(iommu);
+ *   - drivers/passthrough/vtd/intremap.c|646| <<msi_msg_to_remap_entry>> invalidate_sync(iommu);
+ *   - drivers/passthrough/vtd/qinval.c|339| <<__iommu_flush_iec>> ret |= invalidate_sync(iommu);
+ *   - drivers/passthrough/vtd/qinval.c|385| <<flush_context_qi>> ret |= invalidate_sync(iommu);
+ *   - drivers/passthrough/vtd/qinval.c|427| <<flush_iotlb_qi>> ret |= invalidate_sync(iommu);
+ */
 int invalidate_sync(struct iommu *iommu)
 {
     int ret = -1;
@@ -489,6 +505,13 @@ int enable_qinval(struct iommu *iommu)
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/intremap.c|856| <<iommu_enable_x2apic_IR>> disable_qinval(iommu);
+ *   - drivers/passthrough/vtd/intremap.c|901| <<iommu_disable_x2apic_IR>> disable_qinval(drhd->iommu);
+ *   - drivers/passthrough/vtd/iommu.c|2399| <<vtd_suspend>> disable_qinval(iommu);
+ *   - drivers/passthrough/vtd/iommu.c|2430| <<vtd_crash_shutdown>> disable_qinval(drhd->iommu);
+ */
 void disable_qinval(struct iommu *iommu)
 {
     u32 sts;
@@ -505,6 +528,10 @@ void disable_qinval(struct iommu *iommu)
     dmar_writel(iommu->reg, DMAR_GCMD_REG, sts & (~DMA_GCMD_QIE));
 
     /* Make sure hardware complete it */
+    /*
+     * 根据代码分析, 在timeout的条件下, 要么panic, 要么break退出
+     * 不会hang!!!
+     */
     IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG, dmar_readl,
                   !(sts & DMA_GSTS_QIES), sts);
 out:
diff --git a/xen/drivers/passthrough/vtd/quirks.c b/xen/drivers/passthrough/vtd/quirks.c
index feeeea2895..ae85533578 100644
--- a/xen/drivers/passthrough/vtd/quirks.c
+++ b/xen/drivers/passthrough/vtd/quirks.c
@@ -216,6 +216,12 @@ static void snb_vtd_ops_postamble(struct iommu* iommu)
  * call before VT-d translation enable and IOTLB flush operations.
  */
 
+/*
+ * 在以下使用snb_igd_quirk:
+ *   - drivers/passthrough/vtd/quirks.c|220| <<global>> boolean_param("snb_igd_quirk", snb_igd_quirk);
+ *   - drivers/passthrough/vtd/quirks.c|225| <<vtd_ops_preamble_quirk>> if ( snb_igd_quirk )
+ *   - drivers/passthrough/vtd/quirks.c|239| <<vtd_ops_postamble_quirk>> if ( snb_igd_quirk )
+ */
 static int snb_igd_quirk;
 boolean_param("snb_igd_quirk", snb_igd_quirk);
 
@@ -269,6 +275,10 @@ static void __init tylersburg_intremap_quirk(void)
 }
 
 /* initialize platform identification flags */
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|2250| <<intel_vtd_setup>> platform_quirks_init();
+ */
 void __init platform_quirks_init(void)
 {
     ioh_id = pci_conf_read32(0, 0, IOH_DEV, 0, 0);
@@ -379,6 +389,11 @@ void me_wifi_quirk(struct domain *domain, u8 bus, u8 devfn, int map)
     }
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|1557| <<domain_context_mapping>> pci_vtd_quirk(pdev);
+ *   - drivers/passthrough/vtd/iommu.c|1998| <<intel_iommu_enable_device>> pci_vtd_quirk(pdev);
+ */
 void pci_vtd_quirk(const struct pci_dev *pdev)
 {
     int seg = pdev->seg;
diff --git a/xen/drivers/passthrough/vtd/utils.c b/xen/drivers/passthrough/vtd/utils.c
index bd14c02827..5c9b37c992 100644
--- a/xen/drivers/passthrough/vtd/utils.c
+++ b/xen/drivers/passthrough/vtd/utils.c
@@ -57,6 +57,11 @@ void disable_pmr(struct iommu *iommu)
             "Disabled protected memory registers\n");
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|1225| <<iommu_alloc>> print_iommu_regs(drhd);
+ *   - drivers/passthrough/vtd/iommu.c|1238| <<iommu_alloc>> print_iommu_regs(drhd);
+ */
 void print_iommu_regs(struct acpi_drhd_unit *drhd)
 {
     struct iommu *iommu = drhd->iommu;
@@ -95,6 +100,10 @@ static u32 get_level_index(unsigned long gmfn, int level)
     return gmfn & LEVEL_MASK;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/vtd/iommu.c|921| <<iommu_page_fault_do_one>> print_vtd_entries(iommu, PCI_BUS(source_id), PCI_DEVFN2(source_id),
+ */
 void print_vtd_entries(struct iommu *iommu, int bus, int devfn, u64 gmfn)
 {
     struct context_entry *ctxt_entry;
diff --git a/xen/drivers/passthrough/vtd/x86/vtd.c b/xen/drivers/passthrough/vtd/x86/vtd.c
index ca17cb12ca..a0e7a8a69f 100644
--- a/xen/drivers/passthrough/vtd/x86/vtd.c
+++ b/xen/drivers/passthrough/vtd/x86/vtd.c
@@ -59,6 +59,10 @@ void cacheline_flush(char * addr)
     clflush(addr);
 }
 
+/*
+ * called by 
+ *   - drivers/passthrough/vtd/iommu.c|588| <<iommu_flush_all>> 
+ */
 void flush_all_cache()
 {
     wbinvd();
diff --git a/xen/drivers/passthrough/x86/ats.c b/xen/drivers/passthrough/x86/ats.c
index 436eadac61..109f1a989e 100644
--- a/xen/drivers/passthrough/x86/ats.c
+++ b/xen/drivers/passthrough/x86/ats.c
@@ -18,11 +18,32 @@
 #include <xen/pci_regs.h>
 #include "../ats.h"
 
+/*
+ * Address Translation Service: ATS makes the PCI Endpoint be able to request
+ * the DMA address translation from the IOMMU and cache the translation in the
+ * Endpoint, thus alleviate IOMMU pressure and improve the hardware performance
+ * in the I/O virtualization environment.
+ */
+
+/*
+ * 在以下使用ats_devices:
+ *   - drivers/passthrough/vtd/x86/ats.c|118| <<dev_invalidate_iotlb>> list_for_each_entry( pdev, &ats_devices, list )
+ *   - drivers/passthrough/x86/ats.c|43| <<enable_ats_device>> list_for_each_entry ( pdev, &ats_devices, list )
+ *   - drivers/passthrough/x86/ats.c|74| <<enable_ats_device>> list_add(&pdev->list, &ats_devices);
+ *   - drivers/passthrough/x86/ats.c|100| <<disable_ats_device>> list_for_each_entry ( pdev, &ats_devices, list )
+ *   - drivers/passthrough/x86/ats.c|122| <<get_ats_device>> list_for_each_entry ( pdev, &ats_devices, list )
+ */
 LIST_HEAD(ats_devices);
 
 bool_t __read_mostly ats_enabled = 0;
 boolean_param("ats", ats_enabled);
 
+/*
+ * called by:
+ *   - drivers/passthrough/amd/pci_amd_iommu.c|167| <<amd_iommu_setup_domain_device>> enable_ats_device(iommu->seg, bus, devfn, iommu);
+ *   - drivers/passthrough/vtd/iommu.c|1515| <<domain_context_mapping>> enable_ats_device(seg, bus, devfn, drhd->iommu);
+ *   - drivers/passthrough/vtd/iommu.c|2003| <<intel_iommu_enable_device>> ret = enable_ats_device(pdev->seg, pdev->bus, pdev->devfn, drhd->iommu);
+ */
 int enable_ats_device(int seg, int bus, int devfn, const void *iommu)
 {
     struct pci_ats_dev *pdev = NULL;
@@ -82,6 +103,11 @@ int enable_ats_device(int seg, int bus, int devfn, const void *iommu)
     return pos;
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/amd/pci_amd_iommu.c|354| <<amd_iommu_disable_domain_device>> disable_ats_device(iommu->seg, bus, devfn);
+ *   - drivers/passthrough/vtd/iommu.c|1653| <<domain_context_unmap>> disable_ats_device(seg, bus, devfn);
+ */
 void disable_ats_device(int seg, int bus, int devfn)
 {
     struct pci_ats_dev *pdev;
@@ -112,6 +138,10 @@ void disable_ats_device(int seg, int bus, int devfn)
                 seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));
 }
 
+/*
+ * called by:
+ *   - drivers/passthrough/amd/iommu_cmd.c|299| <<amd_iommu_flush_iotlb>> ats_pdev = get_ats_device(pdev->seg, pdev->bus, pdev->devfn);
+ */
 struct pci_ats_dev *get_ats_device(int seg, int bus, int devfn)
 {
     struct pci_ats_dev *pdev;
diff --git a/xen/drivers/pci/pci.c b/xen/drivers/pci/pci.c
index ca07ed03b8..4c833fb1c5 100644
--- a/xen/drivers/pci/pci.c
+++ b/xen/drivers/pci/pci.c
@@ -8,6 +8,24 @@
 #include <xen/pci.h>
 #include <xen/pci_regs.h>
 
+/*
+ * called by:
+ *   - arch/x86/msi.c|319| <<msi_set_enable>> pos = pci_find_cap_offset(seg, bus, slot, func, PCI_CAP_ID_MSI);
+ *   - arch/x86/msi.c|332| <<msix_set_enable>> pos = pci_find_cap_offset(seg, bus, slot, func, PCI_CAP_ID_MSIX);
+ *   - arch/x86/msi.c|568| <<msi_capability_init>> pos = pci_find_cap_offset(seg, bus, slot, func, PCI_CAP_ID_MSI);
+ *   - arch/x86/msi.c|724| <<msix_capability_init>> pos = pci_find_cap_offset(seg, bus, slot, func, PCI_CAP_ID_MSIX);
+ *   - arch/x86/msi.c|957| <<__pci_enable_msix>> pos = pci_find_cap_offset(msi->seg, msi->bus, slot, func, PCI_CAP_ID_MSIX);
+ *   - arch/x86/msi.c|1013| <<__pci_disable_msix>> pos = pci_find_cap_offset(seg, bus, slot, func, PCI_CAP_ID_MSIX);
+ *   - arch/x86/msi.c|1031| <<pci_prepare_msix>> unsigned int pos = pci_find_cap_offset(seg, bus, slot, func,
+ *   - arch/x86/msi.c|1211| <<pci_msix_get_table_len>> pos = pci_find_cap_offset(seg, bus, slot, func, PCI_CAP_ID_MSIX);
+ *   - drivers/char/ehci-dbgp.c|691| <<__find_dbgp>> return pci_find_cap_offset(0, bus, slot, func, PCI_CAP_ID_EHCI_DEBUG);
+ *   - drivers/passthrough/amd/iommu_detect.c|35| <<get_iommu_msi_capabilities>> pos = pci_find_cap_offset(seg, bus, dev, func, PCI_CAP_ID_MSI);
+ *   - drivers/passthrough/pci.c|284| <<alloc_pdev>> if ( pci_find_cap_offset(pseg->nr, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),
+ *   - drivers/passthrough/pci.c|325| <<alloc_pdev>> pos = pci_find_cap_offset(pseg->nr, bus, PCI_SLOT(devfn),
+ *   - drivers/passthrough/pci.c|822| <<pdev_type>> int pos = pci_find_cap_offset(seg, bus, d, f, PCI_CAP_ID_EXP);
+ *   - drivers/passthrough/pci.c|1087| <<hest_match_type>> unsigned int pos = pci_find_cap_offset(pdev->seg, pdev->bus,
+ *   - drivers/passthrough/pci.c|1164| <<pcie_aer_get_firmware_first>> return pci_find_cap_offset(pdev->seg, pdev->bus, PCI_SLOT(pdev->devfn),
+ */
 int pci_find_cap_offset(u16 seg, u8 bus, u8 dev, u8 func, u8 cap)
 {
     u8 id;
@@ -39,6 +57,9 @@ int pci_find_cap_offset(u16 seg, u8 bus, u8 dev, u8 func, u8 cap)
     return 0;
 }
 
+/*
+ * 没人调用
+ */
 int pci_find_next_cap(u16 seg, u8 bus, unsigned int devfn, u8 pos, int cap)
 {
     u8 id;
@@ -115,6 +136,17 @@ int pci_find_next_ext_capability(int seg, int bus, int devfn, int start, int cap
     return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/char/ehci-dbgp.c|1485| <<ehci_dbgp_init>> e = parse_pci(opt_dbgp + 8, NULL, &bus, &slot, &func);
+ *   - drivers/char/ns16550.c|690| <<ns16550_parse_port_config>> conf = parse_pci(conf, NULL, &uart->ps_bdf[0],
+ *   - drivers/char/ns16550.c|699| <<ns16550_parse_port_config>> if ( !parse_pci(conf, NULL, &uart->pb_bdf[0],
+ *   - drivers/passthrough/amd/iommu_acpi.c|650| <<parse_ivrs_ioapic>> s = parse_pci(s + 1, &seg, &bus, &dev, &func);
+ *   - drivers/passthrough/amd/iommu_acpi.c|671| <<parse_ivrs_hpet>> s = parse_pci(s + 1, &seg, &bus, &dev, &func);
+ *   - drivers/passthrough/pci.c|137| <<parse_phantom_dev>> s = parse_pci(s, &seg, &bus, &slot, NULL);
+ *
+ * 似乎没什么调用
+ */
 const char *__init parse_pci(const char *s, unsigned int *seg_p,
                              unsigned int *bus_p, unsigned int *dev_p,
                              unsigned int *func_p)
-- 
2.17.1

