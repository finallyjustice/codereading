From 1644a45f8dd741526114633c705c40287036d93c Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Wed, 4 Dec 2024 16:23:05 -0800
Subject: [PATCH 1/1] linux-v4.14.35-2047.528.2.3

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 drivers/xen/ovmapi.c              |  36 ++
 drivers/xen/xenbus/xenbus.h       |  21 +
 drivers/xen/xenbus/xenbus_comms.c | 401 ++++++++++++++++
 drivers/xen/xenbus/xenbus_probe.c |  16 +
 drivers/xen/xenbus/xenbus_xs.c    | 769 ++++++++++++++++++++++++++++++
 include/xen/events.h              |  14 +
 6 files changed, 1257 insertions(+)

diff --git a/drivers/xen/ovmapi.c b/drivers/xen/ovmapi.c
index 718c1ea4f588..4ed6184b0591 100644
--- a/drivers/xen/ovmapi.c
+++ b/drivers/xen/ovmapi.c
@@ -263,6 +263,10 @@ static int ovmapi_read_name(const char *pathname, char *name,
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/ovmapi.c|867| <<ovmapi_receive_dom0_message>> status = ovmapi_read_name_value(pathname, tmp_value,
+ */
 static int ovmapi_read_name_value(const char *pathname, char *value,
 				  unsigned long *value_len)
 {
@@ -273,6 +277,38 @@ static int ovmapi_read_name_value(const char *pathname, char *value,
 	int n;
 	char num[8];
 
+	/*
+	 * ovmapi_receive_dom0_message()
+	 * -> ovmapi_read_name_value()
+	 *    -> xenbus_directory()
+	 *       -> xs_single()
+	 *          -> xs_talkv()
+	 *             -> req->cb = xs_wake_up; ---> cb is set here !!!
+	 *             -> xs_send()
+	 *                -> add the req to xb_write_list
+	 *             -> xs_wait_for_reply()
+	 *                -> read_reply()
+	 *                   -> wait_event(req->wq, test_reply(req));
+	 *                   -> while (req->state != xb_req_state_got_reply);
+	 *
+	 *
+	 * xenbus_thread()
+	 * -> process_writes()
+	 *    -> submit to xenstore
+	 *    -> list_del(&state.req->list);
+	 *    -> state.req->state = xb_req_state_wait_reply;
+	 *    -> list_add_tail(&state.req->list, &xs_reply_list);
+	 *
+	 *
+	 * xenbus_thread()
+	 * -> wait_event_interruptible(xb_waitq, xb_thread_work())
+	 * -> process_msg()
+	 *    -> req->cb(req) = xs_wake_up()
+	 *       -> wake_up(&req->wq)
+	 *          -> __wake_up(x, TASK_NORMAL, 1, NULL)
+	 *             -> __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);
+	 *                -> spin_lock_irqsave(&wq_head->lock, flags);
+	 */
 	dir = xenbus_directory(XBT_NIL, pathname, "", &dir_n);
 	if (IS_ERR(dir)) {
 		OVMLOG(DGBLVL_ERROR, "OVMAPI: unable to read %s\n", pathname);
diff --git a/drivers/xen/xenbus/xenbus.h b/drivers/xen/xenbus/xenbus.h
index 139539b0ab20..4afb402328dd 100644
--- a/drivers/xen/xenbus/xenbus.h
+++ b/drivers/xen/xenbus/xenbus.h
@@ -67,6 +67,27 @@ struct xs_watch_event {
 	char body[];
 };
 
+/*
+ * 在以下使用xb_req_state_queued:
+ *   - drivers/xen/xenbus/xenbus_xs.c|401| <<xs_send>> req->state = xb_req_state_queued;
+ *   - drivers/xen/xenbus/xenbus_xs.c|450| <<xs_wait_for_reply>> if (req->state == xb_req_state_queued ||
+ *
+ * 在以下使用xb_req_state_wait_reply:
+ *   - drivers/xen/xenbus/xenbus_comms.c|357| <<process_msg>> if (req->state == xb_req_state_wait_reply) {
+ *   - drivers/xen/xenbus/xenbus_comms.c|440| <<process_writes>> state.req->state = xb_req_state_wait_reply;
+ *   - drivers/xen/xenbus/xenbus_xs.c|451| <<xs_wait_for_reply>> req->state == xb_req_state_wait_reply)
+ *
+ * 在以下使用xb_req_state_got_reply:
+ *   - drivers/xen/xenbus/xenbus_comms.c|364| <<process_msg>> req->state = xb_req_state_got_reply;
+ *   - drivers/xen/xenbus/xenbus_comms.c|465| <<process_writes>> state.req->state = xb_req_state_got_reply;
+ *   - drivers/xen/xenbus/xenbus_xs.c|353| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok()) {
+ *   - drivers/xen/xenbus/xenbus_xs.c|385| <<read_reply>> } while (req->state != xb_req_state_got_reply);
+ *
+ * 在以下使用xb_req_state_aborted:
+ *   - drivers/xen/xenbus/xenbus_comms.c|414| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+ *   - drivers/xen/xenbus/xenbus_comms.c|460| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+ *   - drivers/xen/xenbus/xenbus_xs.c|452| <<xs_wait_for_reply>> req->state = xb_req_state_aborted;
+ */
 enum xb_req_state {
 	xb_req_state_queued,
 	xb_req_state_wait_reply,
diff --git a/drivers/xen/xenbus/xenbus_comms.c b/drivers/xen/xenbus/xenbus_comms.c
index e5fda0256feb..bd839acc4a44 100644
--- a/drivers/xen/xenbus/xenbus_comms.c
+++ b/drivers/xen/xenbus/xenbus_comms.c
@@ -43,12 +43,87 @@
 #include <xen/page.h>
 #include "xenbus.h"
 
+/*
+ * ovmapi_receive_dom0_message()
+ * -> ovmapi_read_name_value()
+ *    -> xenbus_directory()
+ *       -> xs_single()
+ *          -> xs_talkv()
+ *             -> req->cb = xs_wake_up; ---> cb is set here !!!
+ *             -> xs_send()
+ *                -> add the req to xb_write_list
+ *             -> xs_wait_for_reply()
+ *                -> read_reply()
+ *                   -> wait_event(req->wq, test_reply(req));
+ *                   -> while (req->state != xb_req_state_got_reply);
+ *
+ *
+ * xenbus_thread()
+ * -> process_writes()
+ *    -> submit to xenstore
+ *    -> list_del(&state.req->list);
+ *    -> state.req->state = xb_req_state_wait_reply;
+ *    -> list_add_tail(&state.req->list, &xs_reply_list);
+ *
+ *
+ * xenbus_thread()
+ * -> wait_event_interruptible(xb_waitq, xb_thread_work())
+ * -> process_msg()
+ *    -> req->cb(req) = xs_wake_up()
+ *       -> wake_up(&req->wq)
+ *          -> __wake_up(x, TASK_NORMAL, 1, NULL)
+ *             -> __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);
+ *                -> spin_lock_irqsave(&wq_head->lock, flags);
+ */
+
+/*
+ * 在以下使用xs_reply_list:
+ *   - drivers/xen/xenbus/xenbus_comms.c|47| <<global>> LIST_HEAD(xs_reply_list);
+ *   - drivers/xen/xenbus/xenbus_comms.c|312| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+ *   - drivers/xen/xenbus/xenbus_comms.c|397| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|1454| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+ */
 /* A list of replies. Currently only one will ever be outstanding. */
 LIST_HEAD(xs_reply_list);
 
+/*
+ * 在以下使用xb_write_list:
+ *   - drivers/xen/xenbus/xenbus_comms.c|50| <<global>> LIST_HEAD(xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_comms.c|96| <<xb_data_to_write>> !list_empty(&xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_comms.c|347| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+ *   - drivers/xen/xenbus/xenbus_xs.c|409| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|410| <<xs_send>> notify = list_is_singular(&xb_write_list);
+ *   - drivers/xen/xenbus/xenbus_xs.c|1404| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+ */
 /* A list of write requests. */
 LIST_HEAD(xb_write_list);
+/*
+ * 在以下使用xb_waitq:
+ *   - drivers/xen/xenbus/xenbus_comms.c|51| <<global>> DECLARE_WAIT_QUEUE_HEAD(xb_waitq);
+ *   - drivers/xen/xenbus/xenbus_comms.c|62| <<wake_waiting>> wake_up(&xb_waitq);
+ *   - drivers/xen/xenbus/xenbus_comms.c|415| <<xenbus_thread>> if (wait_event_interruptible(xb_waitq, xb_thread_work()))
+ *   - drivers/xen/xenbus/xenbus_comms.c|466| <<xb_init_comms>> err = bind_evtchn_to_irqhandler(xen_store_evtchn, wake_waiting, 0, "xenbus", &xb_waitq);
+ *   - drivers/xen/xenbus/xenbus_comms.c|487| <<xb_deinit_comms>> unbind_from_irqhandler(xenbus_irq, &xb_waitq);
+ *   - drivers/xen/xenbus/xenbus_probe.c|725| <<xenbus_probe_thread>> prepare_to_wait(&xb_waitq, &w, TASK_INTERRUPTIBLE);
+ *   - drivers/xen/xenbus/xenbus_probe.c|727| <<xenbus_probe_thread>> finish_wait(&xb_waitq, &w);
+ *   - drivers/xen/xenbus/xenbus_xs.c|414| <<xs_send>> wake_up(&xb_waitq);
+ */
 DECLARE_WAIT_QUEUE_HEAD(xb_waitq);
+/*
+ * 在以下使用xb_write_mutex:
+ *   - drivers/xen/xenbus/xenbus_comms.c|112| <<global>> DEFINE_MUTEX(xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|474| <<process_msg>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|489| <<process_msg>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|607| <<process_writes>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|687| <<process_writes>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_comms.c|716| <<process_writes>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|452| <<xs_send>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|464| <<xs_send>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|493| <<xs_wait_for_reply>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|520| <<xs_wait_for_reply>> mutex_unlock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|1679| <<xs_reboot_notify>> mutex_lock(&xb_write_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|1684| <<xs_reboot_notify>> mutex_unlock(&xb_write_mutex);
+ */
 DEFINE_MUTEX(xb_write_mutex);
 
 /* Protect xenbus reader thread against save/restore. */
@@ -59,15 +134,35 @@ static struct task_struct *xenbus_task;
 
 static irqreturn_t wake_waiting(int irq, void *unused)
 {
+	/*
+	 * 在以下使用xb_waitq:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|51| <<global>> DECLARE_WAIT_QUEUE_HEAD(xb_waitq);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|62| <<wake_waiting>> wake_up(&xb_waitq);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|415| <<xenbus_thread>> if (wait_event_interruptible(xb_waitq, xb_thread_work()))
+	 *   - drivers/xen/xenbus/xenbus_comms.c|466| <<xb_init_comms>> err = bind_evtchn_to_irqhandler(xen_store_evtchn, wake_waiting, 0, "xenbus", &xb_waitq);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|487| <<xb_deinit_comms>> unbind_from_irqhandler(xenbus_irq, &xb_waitq);
+	 *   - drivers/xen/xenbus/xenbus_probe.c|725| <<xenbus_probe_thread>> prepare_to_wait(&xb_waitq, &w, TASK_INTERRUPTIBLE);
+	 *   - drivers/xen/xenbus/xenbus_probe.c|727| <<xenbus_probe_thread>> finish_wait(&xb_waitq, &w);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|414| <<xs_send>> wake_up(&xb_waitq);
+	 */
 	wake_up(&xb_waitq);
 	return IRQ_HANDLED;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|194| <<xb_write>> if (!check_indexes(cons, prod)) {
+ *   - drivers/xen/xenbus/xenbus_comms.c|254| <<xb_read>> if (!check_indexes(cons, prod)) {
+ */
 static int check_indexes(XENSTORE_RING_IDX cons, XENSTORE_RING_IDX prod)
 {
 	return ((prod - cons) <= XENSTORE_RING_SIZE);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|247| <<xb_write>> dst = get_output_chunk(cons, prod, intf->req, &avail);
+ */
 static void *get_output_chunk(XENSTORE_RING_IDX cons,
 			      XENSTORE_RING_IDX prod,
 			      char *buf, uint32_t *len)
@@ -78,6 +173,10 @@ static void *get_output_chunk(XENSTORE_RING_IDX cons,
 	return buf + MASK_XENSTORE_IDX(prod);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|316| <<xb_read>> src = get_input_chunk(cons, prod, intf->rsp, &avail);
+ */
 static const void *get_input_chunk(XENSTORE_RING_IDX cons,
 				   XENSTORE_RING_IDX prod,
 				   const char *buf, uint32_t *len)
@@ -88,10 +187,25 @@ static const void *get_input_chunk(XENSTORE_RING_IDX cons,
 	return buf + MASK_XENSTORE_IDX(cons);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|198| <<xb_write>> if (!xb_data_to_write())
+ *   - drivers/xen/xenbus/xenbus_comms.c|533| <<process_writes>> if (!xb_data_to_write())
+ *   - drivers/xen/xenbus/xenbus_comms.c|633| <<xb_thread_work>> return xb_data_to_read() || xb_data_to_write();
+ */
 static int xb_data_to_write(void)
 {
 	struct xenstore_domain_interface *intf = xen_store_interface;
 
+	/*
+	 * 在以下使用xb_write_list:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|50| <<global>> LIST_HEAD(xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|96| <<xb_data_to_write>> !list_empty(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|347| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+	 *   - drivers/xen/xenbus/xenbus_xs.c|409| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|410| <<xs_send>> notify = list_is_singular(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|1404| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+	 */
 	return (intf->req_prod - intf->req_cons) != XENSTORE_RING_SIZE &&
 		!list_empty(&xb_write_list);
 }
@@ -103,8 +217,35 @@ static int xb_data_to_write(void)
  *
  * Returns number of bytes written or -err.
  */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|384| <<process_writes>> err = xb_write(base + state.written, len - state.written);
+ */
 static int xb_write(const void *data, unsigned int len)
 {
+	/*
+	 * 在以下使用全局的xen_store_interface:
+	 *   - drivers/xen/xenbus/xenbus_probe.c|71| <<global>> struct xenstore_domain_interface *xen_store_interface;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|164| <<xb_data_to_write>> struct xenstore_domain_interface *intf = xen_store_interface;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|183| <<xb_write>> struct xenstore_domain_interface *intf = xen_store_interface;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|229| <<xb_data_to_read>> struct xenstore_domain_interface *intf = xen_store_interface;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|240| <<xb_read>> struct xenstore_domain_interface *intf = xen_store_interface;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|714| <<xb_init_comms>> struct xenstore_domain_interface *intf = xen_store_interface;
+	 *   - drivers/xen/xenbus/xenbus_dev_backend.c|51| <<xenbus_alloc>> gnttab_grant_foreign_access_ref(GNTTAB_RESERVED_XENSTORE, domid, virt_to_gfn(xen_store_interface), 0 );
+	 *   - drivers/xen/xenbus/xenbus_dev_backend.c|103| <<xenbus_backend_mmap>> if (remap_pfn_range(vma, vma->vm_start, virt_to_pfn(xen_store_interface), size, vma->vm_page_prot))
+	 *   - drivers/xen/xenbus/xenbus_probe.c|874| <<xenbus_init>> xen_store_interface = gfn_to_virt(xen_store_gfn);
+	 *   - drivers/xen/xenbus/xenbus_probe.c|879| <<xenbus_init>> xen_store_interface = gfn_to_virt(xen_store_gfn);
+	 *   - drivers/xen/xenbus/xenbus_probe.c|913| <<xenbus_init>> xen_store_interface = xen_remap(xen_store_gfn << XEN_PAGE_SHIFT, XEN_PAGE_SIZE);
+	 *   - drivers/xen/xenfs/xenstored.c|28| <<xsd_kva_open>> file->private_data = (void *)kasprintf(GFP_KERNEL, "0x%p", xen_store_interface);
+	 *   - drivers/xen/xenfs/xenstored.c|42| <<xsd_kva_mmap>> if (remap_pfn_range(vma, vma->vm_start, virt_to_pfn(xen_store_interface), size, vma->vm_page_prot))
+	 *
+	 * struct xenstore_domain_interface {
+	 *     char req[XENSTORE_RING_SIZE]; // Requests to xenstore daemon.
+	 *     char rsp[XENSTORE_RING_SIZE]; // Replies and async watch events.
+	 *     XENSTORE_RING_IDX req_cons, req_prod;
+	 *     XENSTORE_RING_IDX rsp_cons, rsp_prod;
+	 * };
+	 */
 	struct xenstore_domain_interface *intf = xen_store_interface;
 	XENSTORE_RING_IDX cons, prod;
 	unsigned int bytes = 0;
@@ -126,6 +267,9 @@ static int xb_write(const void *data, unsigned int len)
 		/* Must write data /after/ reading the consumer index. */
 		virt_mb();
 
+		/*
+		 * 只在此处调用
+		 */
 		dst = get_output_chunk(cons, prod, intf->req, &avail);
 		if (avail == 0)
 			continue;
@@ -141,6 +285,20 @@ static int xb_write(const void *data, unsigned int len)
 		virt_wmb();
 		intf->req_prod += avail;
 
+		/*
+		 * called by:
+		 *   - drivers/char/tpm/xen-tpmfront.c|68| <<vtpm_cancel>> notify_remote_via_evtchn(priv->evtchn);
+		 *   - drivers/char/tpm/xen-tpmfront.c|103| <<vtpm_send>> notify_remote_via_evtchn(priv->evtchn);
+		 *   - drivers/pci/xen-pcifront.c|130| <<do_pci_op>> notify_remote_via_evtchn(port);
+		 *   - drivers/pci/xen-pcifront.c|675| <<pcifront_do_aer>> notify_remote_via_evtchn(pdev->evtchn);
+		 *   - drivers/tty/hvc/hvc_xen.c|97| <<notify_daemon>> notify_remote_via_evtchn(cons->evtchn);
+		 *   - drivers/xen/events/events_base.c|437| <<notify_remote_via_irq>> notify_remote_via_evtchn(evtchn);
+		 *   - drivers/xen/evtchn.c|576| <<evtchn_ioctl>> notify_remote_via_evtchn(notify.port);
+		 *   - drivers/xen/gntalloc.c|186| <<__del_gref>> notify_remote_via_evtchn(gref->notify.event);
+		 *   - drivers/xen/gntdev.c|284| <<gntdev_put_map>> notify_remote_via_evtchn(map->notify.event);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|221| <<xb_write>> notify_remote_via_evtchn(xen_store_evtchn);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|279| <<xb_read>> notify_remote_via_evtchn(xen_store_evtchn);
+		 */
 		/* Implies mb(): other side will see the updated producer. */
 		if (prod <= intf->req_cons)
 			notify_remote_via_evtchn(xen_store_evtchn);
@@ -149,12 +307,22 @@ static int xb_write(const void *data, unsigned int len)
 	return bytes;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|417| <<process_msg>> if (!xb_data_to_read()) {
+ *   - drivers/xen/xenbus/xenbus_comms.c|725| <<xb_thread_work>> return xb_data_to_read() || xb_data_to_write();
+ */
 static int xb_data_to_read(void)
 {
 	struct xenstore_domain_interface *intf = xen_store_interface;
 	return (intf->rsp_cons != intf->rsp_prod);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|267| <<process_msg>> err = xb_read((void *)&state.msg + state.read, sizeof(state.msg) - state.read);
+ *   - drivers/xen/xenbus/xenbus_comms.c|296| <<process_msg>> err = xb_read(state.body + state.read, state.msg.len - state.read);
+ */
 static int xb_read(void *data, unsigned int len)
 {
 	struct xenstore_domain_interface *intf = xen_store_interface;
@@ -202,6 +370,38 @@ static int xb_read(void *data, unsigned int len)
 	return bytes;
 }
 
+/*
+ * ovmapi_receive_dom0_message()
+ * -> ovmapi_read_name_value()
+ *    -> xenbus_directory()
+ *       -> xs_single()
+ *          -> xs_talkv()
+ *             -> req->cb = xs_wake_up; ---> cb is set here !!!
+ *             -> xs_send()
+ *                -> add the req to xb_write_list
+ *             -> xs_wait_for_reply()
+ *                -> read_reply()
+ *                   -> wait_event(req->wq, test_reply(req));
+ *                   -> while (req->state != xb_req_state_got_reply);
+ *
+ *
+ * xenbus_thread()
+ * -> process_writes()
+ *    -> submit to xenstore
+ *    -> list_del(&state.req->list);
+ *    -> state.req->state = xb_req_state_wait_reply;
+ *    -> list_add_tail(&state.req->list, &xs_reply_list);
+ *
+ *
+ * xenbus_thread()
+ * -> wait_event_interruptible(xb_waitq, xb_thread_work())
+ * -> process_msg()
+ *    -> req->cb(req) = xs_wake_up()
+ *       -> wake_up(&req->wq)
+ *          -> __wake_up(x, TASK_NORMAL, 1, NULL)
+ *             -> __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);
+ *                -> spin_lock_irqsave(&wq_head->lock, flags);
+ */
 static int process_msg(void)
 {
 	static struct {
@@ -234,6 +434,11 @@ static int process_msg(void)
 		 */
 		mutex_lock(&xs_response_mutex);
 
+		/*
+		 * called by:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|417| <<process_msg>> if (!xb_data_to_read()) {
+		 *   - drivers/xen/xenbus/xenbus_comms.c|725| <<xb_thread_work>> return xb_data_to_read() || xb_data_to_write();
+		 */
 		if (!xb_data_to_read()) {
 			/* We raced with save/restore: pending data 'gone'. */
 			mutex_unlock(&xs_response_mutex);
@@ -244,6 +449,11 @@ static int process_msg(void)
 
 	if (state.in_hdr) {
 		if (state.read != sizeof(state.msg)) {
+			/*
+			 * called by:
+			 *   - drivers/xen/xenbus/xenbus_comms.c|267| <<process_msg>> err = xb_read((void *)&state.msg + state.read, sizeof(state.msg) - state.read);
+			 *   - drivers/xen/xenbus/xenbus_comms.c|296| <<process_msg>> err = xb_read(state.body + state.read, state.msg.len - state.read);
+			 */
 			err = xb_read((void *)&state.msg + state.read,
 				      sizeof(state.msg) - state.read);
 			if (err < 0)
@@ -273,10 +483,18 @@ static int process_msg(void)
 		state.read = 0;
 	}
 
+	/*
+	 * called by:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|267| <<process_msg>> err = xb_read((void *)&state.msg + state.read, sizeof(state.msg) - state.read);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|296| <<process_msg>> err = xb_read(state.body + state.read, state.msg.len - state.read);
+	 */
 	err = xb_read(state.body + state.read, state.msg.len - state.read);
 	if (err < 0)
 		goto out;
 
+	/*
+	 * 返回的信息长度不够就要返回
+	 */
 	state.read += err;
 	if (state.read != state.msg.len)
 		return 0;
@@ -289,6 +507,13 @@ static int process_msg(void)
 	} else {
 		err = -ENOENT;
 		mutex_lock(&xb_write_mutex);
+		/*
+		 * 在以下使用xs_reply_list:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|47| <<global>> LIST_HEAD(xs_reply_list);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|312| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+		 *   - drivers/xen/xenbus/xenbus_comms.c|397| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|1454| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+		 */
 		list_for_each_entry(req, &xs_reply_list, list) {
 			if (req->msg.req_id == state.msg.req_id) {
 				list_del(&req->list);
@@ -300,6 +525,27 @@ static int process_msg(void)
 		if (err)
 			goto out;
 
+		/*
+		 * 在以下使用xb_req_state_queued:
+		 *   - drivers/xen/xenbus/xenbus_xs.c|401| <<xs_send>> req->state = xb_req_state_queued;
+		 *   - drivers/xen/xenbus/xenbus_xs.c|450| <<xs_wait_for_reply>> if (req->state == xb_req_state_queued ||
+		 *
+		 * 在以下使用xb_req_state_wait_reply:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|357| <<process_msg>> if (req->state == xb_req_state_wait_reply) {
+		 *   - drivers/xen/xenbus/xenbus_comms.c|440| <<process_writes>> state.req->state = xb_req_state_wait_reply;
+		 *   - drivers/xen/xenbus/xenbus_xs.c|451| <<xs_wait_for_reply>> req->state == xb_req_state_wait_reply)
+		 *
+		 * 在以下使用xb_req_state_got_reply:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|364| <<process_msg>> req->state = xb_req_state_got_reply;
+		 *   - drivers/xen/xenbus/xenbus_comms.c|465| <<process_writes>> state.req->state = xb_req_state_got_reply;
+		 *   - drivers/xen/xenbus/xenbus_xs.c|353| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok()) {
+		 *   - drivers/xen/xenbus/xenbus_xs.c|385| <<read_reply>> } while (req->state != xb_req_state_got_reply);
+		 *
+		 * 在以下使用xb_req_state_aborted:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|414| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+		 *   - drivers/xen/xenbus/xenbus_comms.c|460| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+		 *   - drivers/xen/xenbus/xenbus_xs.c|452| <<xs_wait_for_reply>> req->state = xb_req_state_aborted;
+		 */
 		if (req->state == xb_req_state_wait_reply) {
 			req->msg.req_id = req->caller_req_id;
 			req->msg.type = state.msg.type;
@@ -308,6 +554,20 @@ static int process_msg(void)
 			/* write body, then update state */
 			virt_wmb();
 			req->state = xb_req_state_got_reply;
+			/*
+			 * ovmapi_receive_dom0_message()
+			 * -> ovmapi_read_name_value()
+			 *    -> xenbus_directory()
+			 *       -> xs_single()
+			 *          -> xs_talkv()
+			 *             -> req->cb = xs_wake_up; ---> cb is set here !!!
+			 *             -> xs_send()
+			 *                -> add the req to xb_write_list
+			 *             -> xs_wait_for_reply()
+			 *                -> read_reply()
+			 *                   -> wait_event(req->wq, test_reply(req));
+			 *                   -> while (req->state != xb_req_state_got_reply);
+			 */
 			req->cb(req);
 		} else
 			kfree(req);
@@ -327,8 +587,46 @@ static int process_msg(void)
 	return err;
 }
 
+/*
+ * ovmapi_receive_dom0_message()
+ * -> ovmapi_read_name_value()
+ *    -> xenbus_directory()
+ *       -> xs_single()
+ *          -> xs_talkv()
+ *             -> req->cb = xs_wake_up; ---> cb is set here !!!
+ *             -> xs_send()
+ *                -> add the req to xb_write_list
+ *             -> xs_wait_for_reply()
+ *                -> read_reply()
+ *                   -> wait_event(req->wq, test_reply(req));
+ *                   -> while (req->state != xb_req_state_got_reply);
+ *
+ *
+ * xenbus_thread()
+ * -> process_writes()
+ *    -> submit to xenstore
+ *    -> list_del(&state.req->list);
+ *    -> state.req->state = xb_req_state_wait_reply;
+ *    -> list_add_tail(&state.req->list, &xs_reply_list);
+ *
+ *
+ * xenbus_thread()
+ * -> wait_event_interruptible(xb_waitq, xb_thread_work())
+ * -> process_msg()
+ *    -> req->cb(req) = xs_wake_up()
+ *       -> wake_up(&req->wq)
+ *          -> __wake_up(x, TASK_NORMAL, 1, NULL)
+ *             -> __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);
+ *                -> spin_lock_irqsave(&wq_head->lock, flags);
+ *
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|445| <<xenbus_thread>> err = process_writes();
+ */
 static int process_writes(void)
 {
+	/*
+	 * 这里是static的
+	 */
 	static struct {
 		struct xb_req_data *req;
 		int idx;
@@ -344,23 +642,59 @@ static int process_writes(void)
 	mutex_lock(&xb_write_mutex);
 
 	if (!state.req) {
+		/*
+		 * 在以下使用xb_write_list:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|50| <<global>> LIST_HEAD(xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|96| <<xb_data_to_write>> !list_empty(&xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|347| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+		 *   - drivers/xen/xenbus/xenbus_xs.c|409| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|410| <<xs_send>> notify = list_is_singular(&xb_write_list);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|1404| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+		 */
 		state.req = list_first_entry(&xb_write_list,
 					     struct xb_req_data, list);
 		state.idx = -1;
 		state.written = 0;
 	}
 
+	/*
+	 * 在以下使用xb_req_state_queued:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|401| <<xs_send>> req->state = xb_req_state_queued;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|450| <<xs_wait_for_reply>> if (req->state == xb_req_state_queued ||
+	 *
+	 * 在以下使用xb_req_state_wait_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|357| <<process_msg>> if (req->state == xb_req_state_wait_reply) {
+	 *   - drivers/xen/xenbus/xenbus_comms.c|440| <<process_writes>> state.req->state = xb_req_state_wait_reply;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|451| <<xs_wait_for_reply>> req->state == xb_req_state_wait_reply)
+	 *
+	 * 在以下使用xb_req_state_got_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|364| <<process_msg>> req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|465| <<process_writes>> state.req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|353| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok()) {
+	 *   - drivers/xen/xenbus/xenbus_xs.c|385| <<read_reply>> } while (req->state != xb_req_state_got_reply);
+	 *
+	 * 在以下使用xb_req_state_aborted:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|414| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 *   - drivers/xen/xenbus/xenbus_comms.c|460| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 *   - drivers/xen/xenbus/xenbus_xs.c|452| <<xs_wait_for_reply>> req->state = xb_req_state_aborted;
+	 */
 	if (state.req->state == xb_req_state_aborted)
 		goto out_err;
 
 	while (state.idx < state.req->num_vecs) {
 		if (state.idx < 0) {
+			/*
+			 * void *base;
+			 */
 			base = &state.req->msg;
 			len = sizeof(state.req->msg);
 		} else {
 			base = state.req->vec[state.idx].iov_base;
 			len = state.req->vec[state.idx].iov_len;
 		}
+		/*
+		 * 只在此处调用
+		 */
 		err = xb_write(base + state.written, len - state.written);
 		if (err < 0)
 			goto out_err;
@@ -374,6 +708,13 @@ static int process_writes(void)
 
 	list_del(&state.req->list);
 	state.req->state = xb_req_state_wait_reply;
+	/*
+	 * 在以下使用xs_reply_list:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|47| <<global>> LIST_HEAD(xs_reply_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|312| <<process_msg>> list_for_each_entry(req, &xs_reply_list, list) {
+	 *   - drivers/xen/xenbus/xenbus_comms.c|397| <<process_writes>> list_add_tail(&state.req->list, &xs_reply_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|1454| <<xs_reboot_notify>> list_for_each_entry(req, &xs_reply_list, list)
+	 */
 	list_add_tail(&state.req->list, &xs_reply_list);
 	state.req = NULL;
 
@@ -383,6 +724,18 @@ static int process_writes(void)
 	return 0;
 
  out_err:
+	/*
+	 * static struct {
+	 *     struct xb_req_data *req;
+	 *     int idx;
+	 *     unsigned int written;
+	 * } state;
+	 *
+	 * struct xb_req_data *req;
+	 * -> struct xsd_sockmsg msg;
+	 * -> int err;
+	 * -> enum xb_req_state state;
+	 */
 	state.req->msg.type = XS_ERROR;
 	state.req->err = err;
 	list_del(&state.req->list);
@@ -407,11 +760,54 @@ static int xb_thread_work(void)
 	return xb_data_to_read() || xb_data_to_write();
 }
 
+/*
+ * ovmapi_receive_dom0_message()
+ * -> ovmapi_read_name_value()
+ *    -> xenbus_directory()
+ *       -> xs_single()
+ *          -> xs_talkv()
+ *             -> req->cb = xs_wake_up; ---> cb is set here !!!
+ *             -> xs_send()
+ *                -> add the req to xb_write_list
+ *             -> xs_wait_for_reply()
+ *                -> read_reply()
+ *                   -> wait_event(req->wq, test_reply(req));
+ *                   -> while (req->state != xb_req_state_got_reply);
+ *
+ *
+ * xenbus_thread()
+ * -> process_writes()
+ *    -> submit to xenstore
+ *    -> list_del(&state.req->list);
+ *    -> state.req->state = xb_req_state_wait_reply;
+ *    -> list_add_tail(&state.req->list, &xs_reply_list);
+ *
+ *
+ * xenbus_thread()
+ * -> wait_event_interruptible(xb_waitq, xb_thread_work())
+ * -> process_msg()
+ *    -> req->cb(req) = xs_wake_up()
+ *       -> wake_up(&req->wq)
+ *          -> __wake_up(x, TASK_NORMAL, 1, NULL)
+ *             -> __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);
+ *                -> spin_lock_irqsave(&wq_head->lock, flags);
+ */
 static int xenbus_thread(void *unused)
 {
 	int err;
 
 	while (!kthread_should_stop()) {
+		/*
+		 * 在以下使用xb_waitq:
+		 *   - drivers/xen/xenbus/xenbus_comms.c|51| <<global>> DECLARE_WAIT_QUEUE_HEAD(xb_waitq);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|62| <<wake_waiting>> wake_up(&xb_waitq);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|415| <<xenbus_thread>> if (wait_event_interruptible(xb_waitq, xb_thread_work()))
+		 *   - drivers/xen/xenbus/xenbus_comms.c|466| <<xb_init_comms>> err = bind_evtchn_to_irqhandler(xen_store_evtchn, wake_waiting, 0, "xenbus", &xb_waitq);
+		 *   - drivers/xen/xenbus/xenbus_comms.c|487| <<xb_deinit_comms>> unbind_from_irqhandler(xenbus_irq, &xb_waitq);
+		 *   - drivers/xen/xenbus/xenbus_probe.c|725| <<xenbus_probe_thread>> prepare_to_wait(&xb_waitq, &w, TASK_INTERRUPTIBLE);
+		 *   - drivers/xen/xenbus/xenbus_probe.c|727| <<xenbus_probe_thread>> finish_wait(&xb_waitq, &w);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|414| <<xs_send>> wake_up(&xb_waitq);
+		 */
 		if (wait_event_interruptible(xb_waitq, xb_thread_work()))
 			continue;
 
@@ -435,6 +831,11 @@ static int xenbus_thread(void *unused)
 /**
  * xb_init_comms - Set up interrupt handler off store event channel.
  */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|930| <<xs_resume>> xb_init_comms();
+ *   - drivers/xen/xenbus/xenbus_xs.c|1036| <<xs_init>> err = xb_init_comms();
+ */
 int xb_init_comms(void)
 {
 	struct xenstore_domain_interface *intf = xen_store_interface;
diff --git a/drivers/xen/xenbus/xenbus_probe.c b/drivers/xen/xenbus/xenbus_probe.c
index b911a91bce6b..43acb7e42a6d 100644
--- a/drivers/xen/xenbus/xenbus_probe.c
+++ b/drivers/xen/xenbus/xenbus_probe.c
@@ -68,6 +68,22 @@
 int xen_store_evtchn;
 EXPORT_SYMBOL_GPL(xen_store_evtchn);
 
+/*
+ * 在以下使用全局的xen_store_interface:
+ *   - drivers/xen/xenbus/xenbus_probe.c|71| <<global>> struct xenstore_domain_interface *xen_store_interface;
+ *   - drivers/xen/xenbus/xenbus_comms.c|164| <<xb_data_to_write>> struct xenstore_domain_interface *intf = xen_store_interface;
+ *   - drivers/xen/xenbus/xenbus_comms.c|183| <<xb_write>> struct xenstore_domain_interface *intf = xen_store_interface;
+ *   - drivers/xen/xenbus/xenbus_comms.c|229| <<xb_data_to_read>> struct xenstore_domain_interface *intf = xen_store_interface;
+ *   - drivers/xen/xenbus/xenbus_comms.c|240| <<xb_read>> struct xenstore_domain_interface *intf = xen_store_interface;
+ *   - drivers/xen/xenbus/xenbus_comms.c|714| <<xb_init_comms>> struct xenstore_domain_interface *intf = xen_store_interface;
+ *   - drivers/xen/xenbus/xenbus_dev_backend.c|51| <<xenbus_alloc>> gnttab_grant_foreign_access_ref(GNTTAB_RESERVED_XENSTORE, domid, virt_to_gfn(xen_store_interface), 0 );
+ *   - drivers/xen/xenbus/xenbus_dev_backend.c|103| <<xenbus_backend_mmap>> if (remap_pfn_range(vma, vma->vm_start, virt_to_pfn(xen_store_interface), size, vma->vm_page_prot))
+ *   - drivers/xen/xenbus/xenbus_probe.c|874| <<xenbus_init>> xen_store_interface = gfn_to_virt(xen_store_gfn);
+ *   - drivers/xen/xenbus/xenbus_probe.c|879| <<xenbus_init>> xen_store_interface = gfn_to_virt(xen_store_gfn);
+ *   - drivers/xen/xenbus/xenbus_probe.c|913| <<xenbus_init>> xen_store_interface = xen_remap(xen_store_gfn << XEN_PAGE_SHIFT, XEN_PAGE_SIZE);
+ *   - drivers/xen/xenfs/xenstored.c|28| <<xsd_kva_open>> file->private_data = (void *)kasprintf(GFP_KERNEL, "0x%p", xen_store_interface);
+ *   - drivers/xen/xenfs/xenstored.c|42| <<xsd_kva_mmap>> if (remap_pfn_range(vma, vma->vm_start, virt_to_pfn(xen_store_interface), size, vma->vm_page_prot))
+ */
 struct xenstore_domain_interface *xen_store_interface;
 EXPORT_SYMBOL_GPL(xen_store_interface);
 
diff --git a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c
index 5c4a72ddada5..5cd88e8c7d77 100644
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -60,28 +60,127 @@
  * after resume.
  */
 
+/*
+ * 在以下使用xs_state_lock:
+ *   - drivers/xen/xenbus/xenbus_xs.c|64| <<global>> static DEFINE_SPINLOCK(xs_state_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|100| <<xs_suspend_enter>> spin_lock(&xs_state_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|102| <<xs_suspend_enter>> spin_unlock(&xs_state_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|108| <<xs_suspend_exit>> spin_lock(&xs_state_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|110| <<xs_suspend_exit>> spin_unlock(&xs_state_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|120| <<xs_request_enter>> spin_lock(&xs_state_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|123| <<xs_request_enter>> spin_unlock(&xs_state_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|125| <<xs_request_enter>> spin_lock(&xs_state_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|133| <<xs_request_enter>> spin_unlock(&xs_state_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|140| <<xs_request_exit>> spin_lock(&xs_state_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|147| <<xs_request_exit>> spin_unlock(&xs_state_lock);
+ */
 /* Lock protecting enter/exit critical region. */
 static DEFINE_SPINLOCK(xs_state_lock);
+/*
+ * 在以下使用xs_state_users:
+ *   - drivers/xen/xenbus/xenbus_xs.c|66| <<global>> static unsigned int xs_state_users;
+ *   - drivers/xen/xenbus/xenbus_xs.c|103| <<xs_suspend_enter>> wait_event(xs_state_exit_wq, xs_state_users == 0);
+ *   - drivers/xen/xenbus/xenbus_xs.c|122| <<xs_request_enter>> while (!xs_state_users && xs_suspend_active) {
+ *   - drivers/xen/xenbus/xenbus_xs.c|129| <<xs_request_enter>> xs_state_users++;
+ *   - drivers/xen/xenbus/xenbus_xs.c|130| <<xs_request_enter>> xs_state_users++;
+ *   - drivers/xen/xenbus/xenbus_xs.c|141| <<xs_request_exit>> xs_state_users--;
+ *   - drivers/xen/xenbus/xenbus_xs.c|146| <<xs_request_exit>> xs_state_users--;
+ *   - drivers/xen/xenbus/xenbus_xs.c|149| <<xs_request_exit>> if (xs_suspend_active && !xs_state_users)
+ */
 /* Number of users in critical region (protected by xs_state_lock). */
 static unsigned int xs_state_users;
+/*
+ * 在以下使用xs_suspend_active:
+ *   - drivers/xen/xenbus/xenbus_xs.c|68| <<global>> static int xs_suspend_active;
+ *   - drivers/xen/xenbus/xenbus_xs.c|101| <<xs_suspend_enter>> xs_suspend_active++;
+ *   - drivers/xen/xenbus/xenbus_xs.c|109| <<xs_suspend_exit>> xs_suspend_active--;
+ *   - drivers/xen/xenbus/xenbus_xs.c|122| <<xs_request_enter>> while (!xs_state_users && xs_suspend_active) {
+ *   - drivers/xen/xenbus/xenbus_xs.c|124| <<xs_request_enter>> wait_event(xs_state_enter_wq, xs_suspend_active == 0);
+ *   - drivers/xen/xenbus/xenbus_xs.c|149| <<xs_request_exit>> if (xs_suspend_active && !xs_state_users)
+ */
 /* Suspend handler waiting or already active (protected by xs_state_lock)? */
 static int xs_suspend_active;
+/*
+ * 在以下使用xs_request_id:
+ *   - drivers/xen/xenbus/xenbus_xs.c|70| <<global>> static uint32_t xs_request_id;
+ *   - drivers/xen/xenbus/xenbus_xs.c|131| <<xs_request_enter>> rq_id = xs_request_id++;
+ */
 /* Unique Xenstore request id (protected by xs_state_lock). */
 static uint32_t xs_request_id;
 
+/*
+ * 在以下使用xs_state_enter_wq:
+ *   - drivers/xen/xenbus/xenbus_xs.c|73| <<global>> static DECLARE_WAIT_QUEUE_HEAD(xs_state_enter_wq);
+ *   - drivers/xen/xenbus/xenbus_xs.c|111| <<xs_suspend_exit>> wake_up_all(&xs_state_enter_wq);
+ *   - drivers/xen/xenbus/xenbus_xs.c|124| <<xs_request_enter>> wait_event(xs_state_enter_wq, xs_suspend_active == 0);
+ */
 /* Wait queue for all callers waiting for critical region to become usable. */
 static DECLARE_WAIT_QUEUE_HEAD(xs_state_enter_wq);
+/*
+ * 在以下使用xs_state_exit_wq:
+ *   - drivers/xen/xenbus/xenbus_xs.c|75| <<global>> static DECLARE_WAIT_QUEUE_HEAD(xs_state_exit_wq);
+ *   - drivers/xen/xenbus/xenbus_xs.c|103| <<xs_suspend_enter>> wait_event(xs_state_exit_wq, xs_state_users == 0);
+ *   - drivers/xen/xenbus/xenbus_xs.c|150| <<xs_request_exit>> wake_up(&xs_state_exit_wq);
+ */
 /* Wait queue for suspend handling waiting for critical region being empty. */
 static DECLARE_WAIT_QUEUE_HEAD(xs_state_exit_wq);
 
+/*
+ * 在以下使用watches:
+ *   - drivers/xen/xenbus/xenbus_xs.c|129| <<global>> static LIST_HEAD(watches);
+ *   - drivers/xen/xenbus/xenbus_xs.c|768| <<find_watch>> list_for_each_entry(i, &watches, list)
+ *   - drivers/xen/xenbus/xenbus_xs.c|856| <<register_xenbus_watch>> list_add(&watch->list, &watches);
+ *   - drivers/xen/xenbus/xenbus_xs.c|937| <<xs_resume>> list_for_each_entry(watch, &watches, list) {
+ */
 /* List of registered watches, and a lock to protect it. */
 static LIST_HEAD(watches);
+/*
+ * 在以下使用watches_lock:
+ *   - drivers/xen/xenbus/xenbus_xs.c|130| <<global>> static DEFINE_SPINLOCK(watches_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|784| <<xs_watch_msg>> spin_lock(&watches_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|797| <<xs_watch_msg>> spin_unlock(&watches_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|854| <<register_xenbus_watch>> spin_lock(&watches_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|857| <<register_xenbus_watch>> spin_unlock(&watches_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|862| <<register_xenbus_watch>> spin_lock(&watches_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|864| <<register_xenbus_watch>> spin_unlock(&watches_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|883| <<unregister_xenbus_watch>> spin_lock(&watches_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|886| <<unregister_xenbus_watch>> spin_unlock(&watches_lock);
+ */
 static DEFINE_SPINLOCK(watches_lock);
 
+/*
+ * 在以下使用watch_events:
+ *   - drivers/xen/xenbus/xenbus_xs.c|82| <<global>> static LIST_HEAD(watch_events);
+ *   - drivers/xen/xenbus/xenbus_xs.c|721| <<xs_watch_msg>> list_add_tail(&event->list, &watch_events);
+ *   - drivers/xen/xenbus/xenbus_xs.c|832| <<unregister_xenbus_watch>> list_for_each_entry_safe(event, tmp, &watch_events, list) {
+ *   - drivers/xen/xenbus/xenbus_xs.c|891| <<xenwatch_thread>> !list_empty(&watch_events));
+ *   - drivers/xen/xenbus/xenbus_xs.c|899| <<xenwatch_thread>> event = list_first_entry_or_null(&watch_events, struct xs_watch_event, list);
+ */
 /* List of pending watch callback events, and a lock to protect it. */
 static LIST_HEAD(watch_events);
+/*
+ * 在以下使用watch_events_lock:
+ *   - drivers/xen/xenbus/xenbus_xs.c|142| <<global>> static DEFINE_SPINLOCK(watch_events_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|790| <<xs_watch_msg>> spin_lock(&watch_events_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|794| <<xs_watch_msg>> spin_unlock(&watch_events_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|900| <<unregister_xenbus_watch>> spin_lock(&watch_events_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|910| <<unregister_xenbus_watch>> spin_unlock(&watch_events_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|977| <<xenwatch_thread>> spin_lock(&watch_events_lock);
+ *   - drivers/xen/xenbus/xenbus_xs.c|984| <<xenwatch_thread>> spin_unlock(&watch_events_lock);
+ */
 static DEFINE_SPINLOCK(watch_events_lock);
 
+/*
+ * 在以下使用xs_watch_rwsem:
+ *   - drivers/xen/xenbus/xenbus_xs.c|86| <<global>> static DECLARE_RWSEM(xs_watch_rwsem);
+ *   - drivers/xen/xenbus/xenbus_xs.c|782| <<register_xenbus_watch>> down_read(&xs_watch_rwsem);
+ *   - drivers/xen/xenbus/xenbus_xs.c|797| <<register_xenbus_watch>> up_read(&xs_watch_rwsem);
+ *   - drivers/xen/xenbus/xenbus_xs.c|811| <<unregister_xenbus_watch>> down_read(&xs_watch_rwsem);
+ *   - drivers/xen/xenbus/xenbus_xs.c|822| <<unregister_xenbus_watch>> up_read(&xs_watch_rwsem);
+ *   - drivers/xen/xenbus/xenbus_xs.c|851| <<xs_suspend>> down_write(&xs_watch_rwsem);
+ *   - drivers/xen/xenbus/xenbus_xs.c|872| <<xs_resume>> up_write(&xs_watch_rwsem);
+ *   - drivers/xen/xenbus/xenbus_xs.c|878| <<xs_suspend_cancel>> up_write(&xs_watch_rwsem);
+ */
 /* Protect watch (de)register against save/restore. */
 static DECLARE_RWSEM(xs_watch_rwsem);
 
@@ -91,18 +190,57 @@ static DECLARE_RWSEM(xs_watch_rwsem);
  * wakes up it acquires the xenwatch_mutex before reading the list and
  * carrying out work.
  */
+/*
+ * 在以下使用xenwatch_pid:
+ *   - drivers/xen/xenbus/xenbus_xs.c|164| <<global>> static pid_t xenwatch_pid;
+ *   - drivers/xen/xenbus/xenbus_xs.c|896| <<unregister_xenbus_watch>> if (current->pid != xenwatch_pid)
+ *   - drivers/xen/xenbus/xenbus_xs.c|912| <<unregister_xenbus_watch>> if (current->pid != xenwatch_pid)
+ *   - drivers/xen/xenbus/xenbus_xs.c|966| <<xenwatch_thread>> xenwatch_pid = current->pid;
+ */
 static pid_t xenwatch_pid;
+/*
+ * 在以下使用xenwatch_mutex:
+ *   - drivers/xen/xenbus/xenbus_xs.c|165| <<global>> static DEFINE_MUTEX(xenwatch_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|897| <<unregister_xenbus_watch>> mutex_lock(&xenwatch_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|913| <<unregister_xenbus_watch>> mutex_unlock(&xenwatch_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|975| <<xenwatch_thread>> mutex_lock(&xenwatch_mutex);
+ *   - drivers/xen/xenbus/xenbus_xs.c|992| <<xenwatch_thread>> mutex_unlock(&xenwatch_mutex);
+ */
 static DEFINE_MUTEX(xenwatch_mutex);
+/*
+ * 在以下使用watch_events_waitq:
+ *   - drivers/xen/xenbus/xenbus_xs.c|166| <<global>> static DECLARE_WAIT_QUEUE_HEAD(watch_events_waitq);
+ *   - drivers/xen/xenbus/xenbus_xs.c|793| <<xs_watch_msg>> wake_up(&watch_events_waitq);
+ *   - drivers/xen/xenbus/xenbus_xs.c|969| <<xenwatch_thread>> wait_event_interruptible(watch_events_waitq, !list_empty(&watch_events));
+ */
 static DECLARE_WAIT_QUEUE_HEAD(watch_events_waitq);
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|1160| <<xs_suspend>> xs_suspend_enter();
+ */
 static void xs_suspend_enter(void)
 {
 	spin_lock(&xs_state_lock);
+	/*
+	 * 在以下使用xs_suspend_active:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|68| <<global>> static int xs_suspend_active;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|101| <<xs_suspend_enter>> xs_suspend_active++;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|109| <<xs_suspend_exit>> xs_suspend_active--;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|122| <<xs_request_enter>> while (!xs_state_users && xs_suspend_active) {
+	 *   - drivers/xen/xenbus/xenbus_xs.c|124| <<xs_request_enter>> wait_event(xs_state_enter_wq, xs_suspend_active == 0);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|149| <<xs_request_exit>> if (xs_suspend_active && !xs_state_users)
+	 */
 	xs_suspend_active++;
 	spin_unlock(&xs_state_lock);
 	wait_event(xs_state_exit_wq, xs_state_users == 0);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|1180| <<xs_resume>> xs_suspend_exit();
+ *   - drivers/xen/xenbus/xenbus_xs.c|1201| <<xs_suspend_cancel>> xs_suspend_exit();
+ */
 static void xs_suspend_exit(void)
 {
 	spin_lock(&xs_state_lock);
@@ -111,6 +249,10 @@ static void xs_suspend_exit(void)
 	wake_up_all(&xs_state_enter_wq);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|362| <<xs_send>> req->msg.req_id = xs_request_enter(req);
+ */
 static uint32_t xs_request_enter(struct xb_req_data *req)
 {
 	uint32_t rq_id;
@@ -135,6 +277,11 @@ static uint32_t xs_request_enter(struct xb_req_data *req)
 	return rq_id;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_dev_frontend.c|367| <<xenbus_dev_queue_reply>> xs_request_exit(req);
+ *   - drivers/xen/xenbus/xenbus_xs.c|324| <<xs_wait_for_reply>> xs_request_exit(req);
+ */
 void xs_request_exit(struct xb_req_data *req)
 {
 	spin_lock(&xs_state_lock);
@@ -150,6 +297,10 @@ void xs_request_exit(struct xb_req_data *req)
 		wake_up(&xs_state_exit_wq);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|477| <<xs_talkv>> err = get_error(ret);
+ */
 static int get_error(const char *errorstring)
 {
 	unsigned int i;
@@ -164,6 +315,11 @@ static int get_error(const char *errorstring)
 	return xsd_errors[i].errnum;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|322| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok()) {
+ *   - drivers/xen/xenbus/xenbus_xs.c|339| <<read_reply>> if (!xenbus_ok())
+ */
 static bool xenbus_ok(void)
 {
 	switch (xen_store_domain_type) {
@@ -188,6 +344,10 @@ static bool xenbus_ok(void)
 	return false;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|337| <<read_reply>> wait_event(req->wq, test_reply(req));
+ */
 static bool test_reply(struct xb_req_data *req)
 {
 	if (req->state == xb_req_state_got_reply || !xenbus_ok()) {
@@ -202,6 +362,10 @@ static bool test_reply(struct xb_req_data *req)
 	return false;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|381| <<xs_wait_for_reply>> ret = read_reply(req);
+ */
 static void *read_reply(struct xb_req_data *req)
 {
 	do {
@@ -223,20 +387,78 @@ static void *read_reply(struct xb_req_data *req)
 	return req->body;
 }
 
+/*
+ * 65 struct xsd_sockmsg
+ * 66 {
+ * 67     uint32_t type;  // XS_???
+ * 68     uint32_t req_id;// Request identifier, echoed in daemon's response.
+ * 69     uint32_t tx_id; // Transaction id (0 if not related to a transaction).
+ * 70     uint32_t len;   // Length of data following this.
+ * 71 
+ * 72     // Generally followed by nul-terminated string(s).
+ * 73 };
+ *
+ *
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|426| <<xenbus_dev_request_and_reply>> xs_send(req, msg);
+ *   - drivers/xen/xenbus/xenbus_xs.c|467| <<xs_talkv>> xs_send(req, &msg);
+ */
 static void xs_send(struct xb_req_data *req, struct xsd_sockmsg *msg)
 {
 	bool notify;
 
 	req->msg = *msg;
 	req->err = 0;
+	/*
+	 * 在以下使用xb_req_state_queued:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|401| <<xs_send>> req->state = xb_req_state_queued;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|450| <<xs_wait_for_reply>> if (req->state == xb_req_state_queued ||
+	 *
+	 * 在以下使用xb_req_state_wait_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|357| <<process_msg>> if (req->state == xb_req_state_wait_reply) {
+	 *   - drivers/xen/xenbus/xenbus_comms.c|440| <<process_writes>> state.req->state = xb_req_state_wait_reply;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|451| <<xs_wait_for_reply>> req->state == xb_req_state_wait_reply)
+	 *
+	 * 在以下使用xb_req_state_got_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|364| <<process_msg>> req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|465| <<process_writes>> state.req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|353| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok()) {
+	 *   - drivers/xen/xenbus/xenbus_xs.c|385| <<read_reply>> } while (req->state != xb_req_state_got_reply);
+	 *
+	 * 在以下使用xb_req_state_aborted:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|414| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 *   - drivers/xen/xenbus/xenbus_comms.c|460| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 *   - drivers/xen/xenbus/xenbus_xs.c|452| <<xs_wait_for_reply>> req->state = xb_req_state_aborted;
+	 */
 	req->state = xb_req_state_queued;
+	/*
+	 * 核心的:
+	 * 16 void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *key)
+	 * 17 {
+	 * 18         spin_lock_init(&wq_head->lock);
+	 * 19         lockdep_set_class_and_name(&wq_head->lock, key, name);
+	 * 20         INIT_LIST_HEAD(&wq_head->head);
+	 * 21 }
+	 */
 	init_waitqueue_head(&req->wq);
 
 	/* Save the caller req_id and restore it later in the reply */
 	req->caller_req_id = req->msg.req_id;
+	/*
+	 * 只在此处调用
+	 */
 	req->msg.req_id = xs_request_enter(req);
 
 	mutex_lock(&xb_write_mutex);
+	/*
+	 * 在以下使用xb_write_list:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|50| <<global>> LIST_HEAD(xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|96| <<xb_data_to_write>> !list_empty(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_comms.c|347| <<process_writes>> state.req = list_first_entry(&xb_write_list,
+	 *   - drivers/xen/xenbus/xenbus_xs.c|409| <<xs_send>> list_add_tail(&req->list, &xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|410| <<xs_send>> notify = list_is_singular(&xb_write_list);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|1404| <<xs_reboot_notify>> list_for_each_entry(req, &xb_write_list, list)
+	 */
 	list_add_tail(&req->list, &xb_write_list);
 	notify = list_is_singular(&xb_write_list);
 	mutex_unlock(&xb_write_mutex);
@@ -245,18 +467,51 @@ static void xs_send(struct xb_req_data *req, struct xsd_sockmsg *msg)
 		wake_up(&xb_waitq);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|469| <<xs_talkv>> ret = xs_wait_for_reply(req, &msg);
+ */
 static void *xs_wait_for_reply(struct xb_req_data *req, struct xsd_sockmsg *msg)
 {
 	void *ret;
 
+	/*
+	 * 只在此处调用
+	 */
 	ret = read_reply(req);
 
+	/*
+	 * called by:
+	 *   - drivers/xen/xenbus/xenbus_dev_frontend.c|367| <<xenbus_dev_queue_reply>> xs_request_exit(req);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|324| <<xs_wait_for_reply>> xs_request_exit(req);
+	 */
 	xs_request_exit(req);
 
 	msg->type = req->msg.type;
 	msg->len = req->msg.len;
 
 	mutex_lock(&xb_write_mutex);
+	/*
+	 * 在以下使用xb_req_state_queued:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|401| <<xs_send>> req->state = xb_req_state_queued;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|450| <<xs_wait_for_reply>> if (req->state == xb_req_state_queued ||
+	 *
+	 * 在以下使用xb_req_state_wait_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|357| <<process_msg>> if (req->state == xb_req_state_wait_reply) {
+	 *   - drivers/xen/xenbus/xenbus_comms.c|440| <<process_writes>> state.req->state = xb_req_state_wait_reply;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|451| <<xs_wait_for_reply>> req->state == xb_req_state_wait_reply)
+	 *
+	 * 在以下使用xb_req_state_got_reply:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|364| <<process_msg>> req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_comms.c|465| <<process_writes>> state.req->state = xb_req_state_got_reply;
+	 *   - drivers/xen/xenbus/xenbus_xs.c|353| <<test_reply>> if (req->state == xb_req_state_got_reply || !xenbus_ok()) {
+	 *   - drivers/xen/xenbus/xenbus_xs.c|385| <<read_reply>> } while (req->state != xb_req_state_got_reply);
+	 *
+	 * 在以下使用xb_req_state_aborted:
+	 *   - drivers/xen/xenbus/xenbus_comms.c|414| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 *   - drivers/xen/xenbus/xenbus_comms.c|460| <<process_writes>> if (state.req->state == xb_req_state_aborted)
+	 *   - drivers/xen/xenbus/xenbus_xs.c|452| <<xs_wait_for_reply>> req->state = xb_req_state_aborted;
+	 */
 	if (req->state == xb_req_state_queued ||
 	    req->state == xb_req_state_wait_reply)
 		req->state = xb_req_state_aborted;
@@ -267,11 +522,19 @@ static void *xs_wait_for_reply(struct xb_req_data *req, struct xsd_sockmsg *msg)
 	return ret;
 }
 
+/*
+ * 在以下使用xs_wake_up():
+ *   - drivers/xen/xenbus/xenbus_xs.c|318| <<xs_talkv>> req->cb = xs_wake_up;
+ */
 static void xs_wake_up(struct xb_req_data *req)
 {
 	wake_up(&req->wq);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_dev_frontend.c|468| <<xenbus_write_transaction>> rc = xenbus_dev_request_and_reply(&msg->hdr, u);
+ */
 int xenbus_dev_request_and_reply(struct xsd_sockmsg *msg, void *par)
 {
 	struct xb_req_data *req;
@@ -296,6 +559,51 @@ int xenbus_dev_request_and_reply(struct xsd_sockmsg *msg, void *par)
 }
 EXPORT_SYMBOL(xenbus_dev_request_and_reply);
 
+/*
+ * ovmapi_receive_dom0_message()
+ * -> ovmapi_read_name_value()
+ *    -> xenbus_directory()
+ *       -> xs_single()
+ *          -> xs_talkv()
+ *             -> req->cb = xs_wake_up; ---> cb is set here !!!
+ *             -> xs_send()
+ *                -> add the req to xb_write_list
+ *             -> xs_wait_for_reply()
+ *                -> read_reply()
+ *                   -> wait_event(req->wq, test_reply(req));
+ *                   -> while (req->state != xb_req_state_got_reply);
+ *
+ *
+ * xenbus_thread()
+ * -> process_writes()
+ *    -> submit to xenstore
+ *    -> list_del(&state.req->list);
+ *    -> state.req->state = xb_req_state_wait_reply;
+ *    -> list_add_tail(&state.req->list, &xs_reply_list);
+ *
+ *
+ * xenbus_thread()
+ * -> wait_event_interruptible(xb_waitq, xb_thread_work())
+ * -> process_msg()
+ *    -> req->cb(req) = xs_wake_up()
+ *       -> wake_up(&req->wq)
+ *          -> __wake_up(x, TASK_NORMAL, 1, NULL)
+ *             -> __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);
+ *                -> spin_lock_irqsave(&wq_head->lock, flags);
+ *
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|361| <<xs_single>> return xs_talkv(t, type, &iovec, 1, len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|492| <<xenbus_write>> ret = xs_error(xs_talkv(t, XS_WRITE, iovec, ARRAY_SIZE(iovec), NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|664| <<xs_watch>> return xs_error(xs_talkv(XBT_NIL, XS_WATCH, iov, ARRAY_SIZE(iov), NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|677| <<xs_unwatch>> return xs_error(xs_talkv(XBT_NIL, XS_UNWATCH, iov, ARRAY_SIZE(iov), NULL));
+ *
+ * 比如:
+ * t    = XBT_NIL
+ * type = XS_DIRECTORY
+ * path = 要list的路径 (有ovmapi)
+ * 1    = 就1个iovec (num_iovec)
+ * len  = 要返回的长度
+ */
 /* Send message to xs, get kmalloc'ed reply.  ERR_PTR() on error. */
 static void *xs_talkv(struct xenbus_transaction t,
 		      enum xsd_sockmsg_type type,
@@ -303,7 +611,34 @@ static void *xs_talkv(struct xenbus_transaction t,
 		      unsigned int num_vecs,
 		      unsigned int *len)
 {
+	/*
+	 * 77 struct xb_req_data {
+	 * 78         struct list_head list;
+	 * 79         wait_queue_head_t wq;
+	 * 80         struct xsd_sockmsg msg;
+	 * 81         uint32_t caller_req_id;
+	 * 82         enum xsd_sockmsg_type type;
+	 * 83         char *body;
+	 * 84         const struct kvec *vec;
+	 * 85         int num_vecs;
+	 * 86         int err;
+	 * 87         enum xb_req_state state;
+	 * 88         void (*cb)(struct xb_req_data *);
+	 * 89         void *par;
+	 * 90 };
+	 */
 	struct xb_req_data *req;
+	/*
+	 * 65 struct xsd_sockmsg
+	 * 66 {
+	 * 67     uint32_t type;  // XS_???
+	 * 68     uint32_t req_id;// Request identifier, echoed in daemon's response.
+	 * 69     uint32_t tx_id; // Transaction id (0 if not related to a transaction).
+	 * 70     uint32_t len;   // Length of data following this.
+	 * 71
+	 * 72     // Generally followed by nul-terminated string(s).
+	 * 73 };
+	 */
 	struct xsd_sockmsg msg;
 	void *ret = NULL;
 	unsigned int i;
@@ -313,10 +648,24 @@ static void *xs_talkv(struct xenbus_transaction t,
 	if (!req)
 		return ERR_PTR(-ENOMEM);
 
+	/*
+	 * 19 struct kvec {
+	 * 20         void *iov_base; // and that should *never* hold a userland pointer
+	 * 21         size_t iov_len;
+	 * 22 };
+	 */
 	req->vec = iovec;
 	req->num_vecs = num_vecs;
+	/*
+	 * 在以下使用xs_wake_up():
+	 *   - drivers/xen/xenbus/xenbus_xs.c|318| <<xs_talkv>> req->cb = xs_wake_up;
+	 */
 	req->cb = xs_wake_up;
 
+	/*
+	 * 上面定义
+	 * struct xsd_sockmsg msg;
+	 */
 	msg.req_id = 0;
 	msg.tx_id = t.id;
 	msg.type = type;
@@ -324,8 +673,16 @@ static void *xs_talkv(struct xenbus_transaction t,
 	for (i = 0; i < num_vecs; i++)
 		msg.len += iovec[i].iov_len;
 
+	/*
+	 * called by:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|426| <<xenbus_dev_request_and_reply>> xs_send(req, msg);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|467| <<xs_talkv>> xs_send(req, &msg);
+	 */
 	xs_send(req, &msg);
 
+	/*
+	 * 只在此处调用
+	 */
 	ret = xs_wait_for_reply(req, &msg);
 	if (len)
 		*len = msg.len;
@@ -348,6 +705,77 @@ static void *xs_talkv(struct xenbus_transaction t,
 	return ret;
 }
 
+/*
+ * ovmapi_receive_dom0_message()
+ * -> ovmapi_read_name_value()
+ *    -> xenbus_directory()
+ *       -> xs_single()
+ *          -> xs_talkv()
+ *             -> req->cb = xs_wake_up; ---> cb is set here !!!
+ *             -> xs_send()
+ *                -> add the req to xb_write_list
+ *             -> xs_wait_for_reply()
+ *                -> read_reply()
+ *                   -> wait_event(req->wq, test_reply(req));
+ *                   -> while (req->state != xb_req_state_got_reply);
+ *
+ *
+ * xenbus_thread()
+ * -> process_writes()
+ *    -> submit to xenstore
+ *    -> list_del(&state.req->list);
+ *    -> state.req->state = xb_req_state_wait_reply;
+ *    -> list_add_tail(&state.req->list, &xs_reply_list);
+ *
+ *
+ * xenbus_thread()
+ * -> wait_event_interruptible(xb_waitq, xb_thread_work())
+ * -> process_msg()
+ *    -> req->cb(req) = xs_wake_up()
+ *       -> wake_up(&req->wq)
+ *          -> __wake_up(x, TASK_NORMAL, 1, NULL)
+ *             -> __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);
+ *                -> spin_lock_irqsave(&wq_head->lock, flags);
+ *
+ *
+ * 11 enum xsd_sockmsg_type                
+ * 12 {                
+ * 13     XS_DEBUG,    
+ * 14     XS_DIRECTORY,
+ * 15     XS_READ,
+ * 16     XS_GET_PERMS,
+ * 17     XS_WATCH,
+ * 18     XS_UNWATCH,
+ * 19     XS_TRANSACTION_START,
+ * 20     XS_TRANSACTION_END,
+ * 21     XS_INTRODUCE,
+ * 22     XS_RELEASE,
+ * 23     XS_GET_DOMAIN_PATH,
+ * 24     XS_WRITE,
+ * 25     XS_MKDIR,
+ * 26     XS_RM,
+ * 27     XS_SET_PERMS,
+ * 28     XS_WATCH_EVENT,
+ * 29     XS_ERROR,
+ * 30     XS_IS_DOMAIN_INTRODUCED, 
+ * 31     XS_RESUME,          
+ * 32     XS_SET_TARGET,      
+ * 33     XS_RESTRICT,
+ * 34     XS_RESET_WATCHES,
+ * 35 };
+ *
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|565| <<xenbus_directory>> strings = xs_single(t, XS_DIRECTORY, path, &len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|603| <<xenbus_read>> ret = xs_single(t, XS_READ, path, len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|645| <<xenbus_mkdir>> ret = xs_error(xs_single(t, XS_MKDIR, path, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|661| <<xenbus_rm>> ret = xs_error(xs_single(t, XS_RM, path, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|674| <<xenbus_transaction_start>> id_str = xs_single(XBT_NIL, XS_TRANSACTION_START, "", NULL);
+ *   - drivers/xen/xenbus/xenbus_xs.c|696| <<xenbus_transaction_end>> return xs_error(xs_single(t, XS_TRANSACTION_END, abortstr, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|895| <<xs_reset_watches>> err = xs_error(xs_single(XBT_NIL, XS_RESET_WATCHES, "", NULL));
+ *
+ * 如果是xenbus_directory()来的, string就是path
+ * len是要返回的长度
+ */
 /* Simplified version of xs_talkv: single message. */
 static void *xs_single(struct xenbus_transaction t,
 		       enum xsd_sockmsg_type type,
@@ -358,9 +786,33 @@ static void *xs_single(struct xenbus_transaction t,
 
 	iovec.iov_base = (void *)string;
 	iovec.iov_len = strlen(string) + 1;
+	/*
+	 * called by:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|361| <<xs_single>> return xs_talkv(t, type, &iovec, 1, len);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|492| <<xenbus_write>> ret = xs_error(xs_talkv(t, XS_WRITE, iovec, ARRAY_SIZE(iovec), NULL));
+	 *   - drivers/xen/xenbus/xenbus_xs.c|664| <<xs_watch>> return xs_error(xs_talkv(XBT_NIL, XS_WATCH, iov, ARRAY_SIZE(iov), NULL));
+	 *   - drivers/xen/xenbus/xenbus_xs.c|677| <<xs_unwatch>> return xs_error(xs_talkv(XBT_NIL, XS_UNWATCH, iov, ARRAY_SIZE(iov), NULL));
+	 *
+	 * 比如:
+	 * t    = XBT_NIL
+	 * type = XS_DIRECTORY
+	 * path = 要list的路径 (有ovmapi)
+	 * 1    = 就1个iovec (num_iovec)
+	 * len  = 要返回的长度
+	 */
 	return xs_talkv(t, type, &iovec, 1, len);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|673| <<xenbus_write>> ret = xs_error(xs_talkv(t, XS_WRITE, iovec, ARRAY_SIZE(iovec), NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|690| <<xenbus_mkdir>> ret = xs_error(xs_single(t, XS_MKDIR, path, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|706| <<xenbus_rm>> ret = xs_error(xs_single(t, XS_RM, path, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|747| <<xenbus_transaction_end>> return xs_error(xs_single(t, XS_TRANSACTION_END, abortstr, NULL));
+ *   - drivers/xen/xenbus/xenbus_xs.c|889| <<xs_watch>> return xs_error(xs_talkv(XBT_NIL, XS_WATCH, iov,
+ *   - drivers/xen/xenbus/xenbus_xs.c|906| <<xs_unwatch>> return xs_error(xs_talkv(XBT_NIL, XS_UNWATCH, iov,
+ *   - drivers/xen/xenbus/xenbus_xs.c|1033| <<xs_reset_watches>> err = xs_error(xs_single(XBT_NIL, XS_RESET_WATCHES, "", NULL));
+ */
 /* Many commands only need an ack, don't care what it says. */
 static int xs_error(char *reply)
 {
@@ -370,6 +822,11 @@ static int xs_error(char *reply)
 	return 0;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|558| <<split>> *num = count_strings(strings, len);
+ *   - drivers/xen/xenbus/xenbus_xs.c|952| <<xs_watch_msg>> if (count_strings(event->body, event->len) != 2) {
+ */
 static unsigned int count_strings(const char *strings, unsigned int len)
 {
 	unsigned int num;
@@ -381,6 +838,14 @@ static unsigned int count_strings(const char *strings, unsigned int len)
 	return num;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|582| <<xenbus_directory>> path = join(dir, node);
+ *   - drivers/xen/xenbus/xenbus_xs.c|644| <<xenbus_read>> path = join(dir, node);
+ *   - drivers/xen/xenbus/xenbus_xs.c|664| <<xenbus_write>> path = join(dir, node);
+ *   - drivers/xen/xenbus/xenbus_xs.c|686| <<xenbus_mkdir>> path = join(dir, node);
+ *   - drivers/xen/xenbus/xenbus_xs.c|702| <<xenbus_rm>> path = join(dir, node);
+ */
 /* Return the path to dir with /name appended. Buffer must be kfree()'ed. */
 static char *join(const char *dir, const char *name)
 {
@@ -393,6 +858,10 @@ static char *join(const char *dir, const char *name)
 	return (!buffer) ? ERR_PTR(-ENOMEM) : buffer;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|591| <<xenbus_directory>> return split(strings, len, num);
+ */
 static char **split(char *strings, unsigned int len, unsigned int *num)
 {
 	char *p, **ret;
@@ -416,6 +885,49 @@ static char **split(char *strings, unsigned int len, unsigned int *num)
 	return ret;
 }
 
+/*
+ * ovmapi_receive_dom0_message()
+ * -> ovmapi_read_name_value()
+ *    -> xenbus_directory()
+ *       -> xs_single()
+ *          -> xs_talkv()
+ *             -> req->cb = xs_wake_up; ---> cb is set here !!!
+ *             -> xs_send()
+ *                -> add the req to xb_write_list
+ *             -> xs_wait_for_reply()
+ *                -> read_reply()
+ *                   -> wait_event(req->wq, test_reply(req));
+ *                   -> while (req->state != xb_req_state_got_reply);
+ *
+ *
+ * xenbus_thread()
+ * -> process_writes()
+ *    -> submit to xenstore
+ *    -> list_del(&state.req->list);
+ *    -> state.req->state = xb_req_state_wait_reply;
+ *    -> list_add_tail(&state.req->list, &xs_reply_list);
+ *
+ *
+ * xenbus_thread()
+ * -> wait_event_interruptible(xb_waitq, xb_thread_work())
+ * -> process_msg()
+ *    -> req->cb(req) = xs_wake_up()
+ *       -> wake_up(&req->wq)
+ *          -> __wake_up(x, TASK_NORMAL, 1, NULL)
+ *             -> __wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);
+ *                -> spin_lock_irqsave(&wq_head->lock, flags);
+ *
+ * called by:
+ *   - drivers/scsi/xen-scsifront.c|979| <<scsifront_do_lun_hotplug>> dir = xenbus_directory(XBT_NIL, dev->otherend, "vscsi-devs", &dir_n);
+ *   - drivers/xen/ovmapi.c|276| <<ovmapi_read_name_value>> dir = xenbus_directory(XBT_NIL, pathname, "", &dir_n);
+ *   - drivers/xen/xen-scsiback.c|1143| <<scsiback_do_lun_hotplug>> dir = xenbus_directory(XBT_NIL, info->dev->nodename, "vscsi-devs",
+ *   - drivers/xen/xenbus/xenbus_probe.c|499| <<xenbus_probe_device_type>> dir = xenbus_directory(XBT_NIL, bus->root, type, &dir_n);
+ *   - drivers/xen/xenbus/xenbus_probe.c|519| <<xenbus_probe_devices>> dir = xenbus_directory(XBT_NIL, bus->root, "", &dir_n);
+ *   - drivers/xen/xenbus/xenbus_probe_backend.c|167| <<xenbus_probe_backend>> dir = xenbus_directory(XBT_NIL, nodename, "", &dir_n);
+ *   - drivers/xen/xenbus/xenbus_probe_frontend.c|438| <<xenbus_reset_state>> devclass = xenbus_directory(XBT_NIL, "device", "", &devclass_n);
+ *   - drivers/xen/xenbus/xenbus_probe_frontend.c|443| <<xenbus_reset_state>> dev = xenbus_directory(XBT_NIL, "device", devclass[i], &dev_n);
+ *   - drivers/xen/xenbus/xenbus_xs.c|602| <<xenbus_exists>> d = xenbus_directory(t, dir, node, &dir_n);
+ */
 char **xenbus_directory(struct xenbus_transaction t,
 			const char *dir, const char *node, unsigned int *num)
 {
@@ -426,6 +938,16 @@ char **xenbus_directory(struct xenbus_transaction t,
 	if (IS_ERR(path))
 		return (char **)path;
 
+	/*
+	 * 在以下调用xs_single():
+	 *   - drivers/xen/xenbus/xenbus_xs.c|565| <<xenbus_directory>> strings = xs_single(t, XS_DIRECTORY, path, &len);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|603| <<xenbus_read>> ret = xs_single(t, XS_READ, path, len);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|645| <<xenbus_mkdir>> ret = xs_error(xs_single(t, XS_MKDIR, path, NULL));
+	 *   - drivers/xen/xenbus/xenbus_xs.c|661| <<xenbus_rm>> ret = xs_error(xs_single(t, XS_RM, path, NULL));
+	 *   - drivers/xen/xenbus/xenbus_xs.c|674| <<xenbus_transaction_start>> id_str = xs_single(XBT_NIL, XS_TRANSACTION_START, "", NULL);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|696| <<xenbus_transaction_end>> return xs_error(xs_single(t, XS_TRANSACTION_END, abortstr, NULL));
+	 *   - drivers/xen/xenbus/xenbus_xs.c|895| <<xs_reset_watches>> err = xs_error(xs_single(XBT_NIL, XS_RESET_WATCHES, "", NULL));
+	 */
 	strings = xs_single(t, XS_DIRECTORY, path, &len);
 	kfree(path);
 	if (IS_ERR(strings))
@@ -435,6 +957,13 @@ char **xenbus_directory(struct xenbus_transaction t,
 }
 EXPORT_SYMBOL_GPL(xenbus_directory);
 
+/*
+ * called by:
+ *   - drivers/net/xen-netfront.c|2425| <<talk_to_netback>> if (xenbus_exists(XBT_NIL,
+ *   - drivers/xen/xenbus/xenbus_probe.c|159| <<xenbus_read_otherend_details>> !xenbus_exists(XBT_NIL, xendev->otherend, "")) {
+ *   - drivers/xen/xenbus/xenbus_probe.c|567| <<xenbus_dev_changed>> exists = xenbus_exists(XBT_NIL, node, "");
+ *   - drivers/xen/xenbus/xenbus_probe_backend.c|82| <<backend_bus_id>> if (!err && !xenbus_exists(XBT_NIL, frontend, ""))
+ */
 /* Check if a path exists. Return 1 if it does. */
 int xenbus_exists(struct xenbus_transaction t,
 		  const char *dir, const char *node)
@@ -454,6 +983,30 @@ EXPORT_SYMBOL_GPL(xenbus_exists);
  * Returns a kmalloced value: call free() on it after use.
  * len indicates length in bytes.
  */
+/*
+ * called by:
+ *   - drivers/block/xen-blkback/xenbus.c|77| <<blkback_name>> devpath = xenbus_read(XBT_NIL, dev->nodename, "dev", NULL);
+ *   - drivers/block/xen-blkback/xenbus.c|729| <<backend_changed>> be->mode = xenbus_read(XBT_NIL, dev->nodename, "mode", NULL);
+ *   - drivers/block/xen-blkback/xenbus.c|737| <<backend_changed>> device_type = xenbus_read(XBT_NIL, dev->otherend, "device-type", NULL);
+ *   - drivers/block/xen-blkfront.c|1976| <<blkfront_probe>> type = xenbus_read(XBT_NIL, dev->nodename, "device-type", &len);
+ *   - drivers/net/xen-netback/xenbus.c|423| <<netback_probe>> script = xenbus_read(XBT_NIL, dev->nodename, "script", NULL);
+ *   - drivers/net/xen-netback/xenbus.c|705| <<xen_net_read_rate>> ratestr = xenbus_read(XBT_NIL, dev->nodename, "rate", NULL);
+ *   - drivers/net/xen-netback/xenbus.c|735| <<xen_net_read_mac>> macstr = s = xenbus_read(XBT_NIL, dev->nodename, "mac", NULL);
+ *   - drivers/net/xen-netback/xenbus.c|898| <<hotplug_status_changed>> str = xenbus_read(XBT_NIL, be->dev->nodename, "hotplug-status", &len);
+ *   - drivers/net/xen-netfront.c|1759| <<xen_net_read_mac>> macstr = s = xenbus_read(XBT_NIL, dev->nodename, "mac", NULL);
+ *   - drivers/xen/manage.c|234| <<shutdown_handler>> str = (char *)xenbus_read(xbt, "control", "shutdown", NULL);
+ *   - drivers/xen/ovmapi.c|254| <<ovmapi_read_name>> name_buff = xenbus_read(XBT_NIL, pathname, "", &name_len);
+ *   - drivers/xen/ovmapi.c|284| <<ovmapi_read_name_value>> name_value = xenbus_read(XBT_NIL, pathname, num, &name_len);
+ *   - drivers/xen/pvcalls-front.c|1108| <<pvcalls_front_probe>> versions = xenbus_read(XBT_NIL, dev->otherend, "versions", &len);
+ *   - drivers/xen/sys-hypervisor.c|149| <<uuid_show_fallback>> vm = xenbus_read(XBT_NIL, "vm", "", NULL);
+ *   - drivers/xen/sys-hypervisor.c|152| <<uuid_show_fallback>> val = xenbus_read(XBT_NIL, vm, "uuid", NULL);
+ *   - drivers/xen/xen-scsiback.c|1077| <<scsiback_do_1lun_hotplug>> val = xenbus_read(XBT_NIL, dev->nodename, str, NULL);
+ *   - drivers/xen/xenbus/xenbus_probe_frontend.c|417| <<xenbus_check_frontend>> backend = xenbus_read(XBT_NIL, frontend, "backend", NULL);
+ *   - drivers/xen/xenbus/xenbus_xs.c|708| <<xenbus_scanf>> val = xenbus_read(t, dir, node, NULL);
+ *   - drivers/xen/xenbus/xenbus_xs.c|774| <<xenbus_gather>> p = xenbus_read(t, dir, name, NULL);
+ *   - net/9p/trans_xen.c|395| <<xen_9pfs_front_init>> versions = xenbus_read(XBT_NIL, dev->otherend, "versions", &len);
+ *   - net/9p/trans_xen.c|461| <<xen_9pfs_front_init>> priv->tag = xenbus_read(xbt, dev->nodename, "tag", NULL);
+ */
 void *xenbus_read(struct xenbus_transaction t,
 		  const char *dir, const char *node, unsigned int *len)
 {
@@ -470,6 +1023,20 @@ void *xenbus_read(struct xenbus_transaction t,
 }
 EXPORT_SYMBOL_GPL(xenbus_read);
 
+/*
+ * called by:
+ *   - drivers/input/misc/xen-kbdfront.c|237| <<xenkbd_probe>> ret = xenbus_write(XBT_NIL, dev->nodename,
+ *   - drivers/input/misc/xen-kbdfront.c|286| <<xenkbd_probe>> ret = xenbus_write(XBT_NIL, dev->nodename,
+ *   - drivers/net/xen-netfront.c|2476| <<talk_to_netback>> err = xenbus_write(xbt, dev->nodename, "feature-gso-tcpv6", "1");
+ *   - drivers/net/xen-netfront.c|2482| <<talk_to_netback>> err = xenbus_write(xbt, dev->nodename, "feature-ipv6-csum-offload",
+ *   - drivers/xen/manage.c|248| <<shutdown_handler>> xenbus_write(xbt, "control", "shutdown", "");
+ *   - drivers/xen/ovmapi.c|778| <<ovmapi_send_dom0_message>> xenbus_write(XBT_NIL, pathname, "", name);
+ *   - drivers/xen/ovmapi.c|792| <<ovmapi_send_dom0_message>> xenbus_write(XBT_NIL, pathname, number,
+ *   - drivers/xen/ovmapi.c|801| <<ovmapi_send_dom0_message>> xenbus_write(XBT_NIL, "control/oracle-vmapi/from-guest", "last-write",
+ *   - drivers/xen/xenbus/xenbus_client.c|288| <<xenbus_va_dev_error>> xenbus_write(XBT_NIL, path_buffer, "error", printf_buffer))
+ *   - drivers/xen/xenbus/xenbus_xs.c|657| <<xenbus_write>> int xenbus_write(struct xenbus_transaction t,
+ *   - drivers/xen/xenbus/xenbus_xs.c|813| <<xenbus_printf>> ret = xenbus_write(t, dir, node, buf);
+ */
 /* Write the value of a single file.
  * Returns -err on failure.
  */
@@ -495,6 +1062,9 @@ int xenbus_write(struct xenbus_transaction t,
 }
 EXPORT_SYMBOL_GPL(xenbus_write);
 
+/*
+ * 没人调用
+ */
 /* Create a new directory. */
 int xenbus_mkdir(struct xenbus_transaction t,
 		 const char *dir, const char *node)
@@ -512,6 +1082,17 @@ int xenbus_mkdir(struct xenbus_transaction t,
 }
 EXPORT_SYMBOL_GPL(xenbus_mkdir);
 
+/*
+ * called by:
+ *   - drivers/block/xen-blkfront.c|1331| <<blkif_free>> xenbus_rm(XBT_NIL, info->xbdev->nodename, "ring-page-order");
+ *   - drivers/block/xen-blkfront.c|1335| <<blkif_free>> xenbus_rm(XBT_NIL, info->xbdev->nodename, "ring-ref");
+ *   - drivers/block/xen-blkfront.c|1341| <<blkif_free>> xenbus_rm(XBT_NIL, info->xbdev->nodename, ring_ref_name);
+ *   - drivers/block/xen-blkfront.c|1345| <<blkif_free>> xenbus_rm(XBT_NIL, info->xbdev->nodename, "multi-queue-num-queues");
+ *   - drivers/block/xen-blkfront.c|1351| <<blkif_free>> xenbus_rm(XBT_NIL, info->xbdev->nodename, queuename);
+ *   - drivers/net/xen-netback/xenbus.c|275| <<netback_remove>> xenbus_rm(XBT_NIL, dev->nodename, "hotplug-status");
+ *   - drivers/net/xen-netback/xenbus.c|510| <<backend_disconnect>> xenbus_rm(XBT_NIL, be->dev->nodename, "hotplug-status");
+ *   - drivers/xen/ovmapi.c|914| <<ovmapi_receive_dom0_message>> xenbus_rm(XBT_NIL, pathname, "");
+ */
 /* Destroy a file or directory (directories must be empty). */
 int xenbus_rm(struct xenbus_transaction t, const char *dir, const char *node)
 {
@@ -528,6 +1109,9 @@ int xenbus_rm(struct xenbus_transaction t, const char *dir, const char *node)
 }
 EXPORT_SYMBOL_GPL(xenbus_rm);
 
+/*
+ * 很多调用
+ */
 /* Start a transaction: changes by others will not be seen during this
  * transaction, and changes will not be visible to others until end.
  */
@@ -545,6 +1129,9 @@ int xenbus_transaction_start(struct xenbus_transaction *t)
 }
 EXPORT_SYMBOL_GPL(xenbus_transaction_start);
 
+/*
+ * 很多调用
+ */
 /* End a transaction.
  * If abandon is true, transaction is discarded instead of committed.
  */
@@ -561,6 +1148,9 @@ int xenbus_transaction_end(struct xenbus_transaction t, int abort)
 }
 EXPORT_SYMBOL_GPL(xenbus_transaction_end);
 
+/*
+ * 很多调用
+ */
 /* Single read and scanf: returns -errno or num scanned. */
 int xenbus_scanf(struct xenbus_transaction t,
 		 const char *dir, const char *node, const char *fmt, ...)
@@ -584,6 +1174,9 @@ int xenbus_scanf(struct xenbus_transaction t,
 }
 EXPORT_SYMBOL_GPL(xenbus_scanf);
 
+/*
+ * 很多调用
+ */
 /* Read an (optional) unsigned value. */
 unsigned int xenbus_read_unsigned(const char *dir, const char *node,
 				  unsigned int default_val)
@@ -599,6 +1192,9 @@ unsigned int xenbus_read_unsigned(const char *dir, const char *node,
 }
 EXPORT_SYMBOL_GPL(xenbus_read_unsigned);
 
+/*
+ * 很多调用
+ */
 /* Single printf and write: returns -errno or 0. */
 int xenbus_printf(struct xenbus_transaction t,
 		  const char *dir, const char *node, const char *fmt, ...)
@@ -622,6 +1218,23 @@ int xenbus_printf(struct xenbus_transaction t,
 }
 EXPORT_SYMBOL_GPL(xenbus_printf);
 
+/*
+ * called by:
+ *   - drivers/block/xen-blkfront.c|2280| <<blkfront_gather_backend_features>> err = xenbus_gather(XBT_NIL, info->xbdev->otherend,
+ *   - drivers/block/xen-blkfront.c|2286| <<blkfront_gather_backend_features>> err = xenbus_gather(XBT_NIL, info->xbdev->otherend,
+ *   - drivers/block/xen-blkfront.c|2419| <<max_indirect_segs_store>> err = xenbus_gather(XBT_NIL, info->xbdev->otherend,
+ *   - drivers/block/xen-blkfront.c|2570| <<blkfront_connect>> err = xenbus_gather(XBT_NIL, info->xbdev->otherend,
+ *   - drivers/net/xen-netback/xenbus.c|1117| <<connect_data_rings>> err = xenbus_gather(XBT_NIL, xspath,
+ *   - drivers/net/xen-netback/xenbus.c|1128| <<connect_data_rings>> err = xenbus_gather(XBT_NIL, xspath,
+ *   - drivers/net/xen-netback/xenbus.c|1154| <<connect_data_rings>> err = xenbus_gather(XBT_NIL, xspath,
+ *   - drivers/net/xen-netback/xenbus.c|1167| <<connect_data_rings>> err = xenbus_gather(XBT_NIL, xspath,
+ *   - drivers/net/xen-netfront.c|2383| <<talk_to_netback>> err = xenbus_gather(XBT_NIL, info->xbdev->otherend,
+ *   - drivers/xen/xen-pciback/xenbus.c|162| <<xen_pcibk_attach>> err = xenbus_gather(XBT_NIL, pdev->xdev->otherend,
+ *   - drivers/xen/xen-scsiback.c|864| <<scsiback_map>> err = xenbus_gather(XBT_NIL, dev->otherend,
+ *   - drivers/xen/xenbus/xenbus_client.c|935| <<xenbus_read_driver_state>> int err = xenbus_gather(XBT_NIL, path, "state", "%d", &result, NULL);
+ *   - drivers/xen/xenbus/xenbus_probe.c|148| <<xenbus_read_otherend_details>> int err = xenbus_gather(XBT_NIL, xendev->nodename,
+ *   - drivers/xen/xenbus/xenbus_probe_backend.c|75| <<backend_bus_id>> err = xenbus_gather(XBT_NIL, nodename, "frontend-id", "%i", &domid,
+ */
 /* Takes tuples of names, scanf-style args, and void **, NULL terminated. */
 int xenbus_gather(struct xenbus_transaction t, const char *dir, ...)
 {
@@ -652,6 +1265,11 @@ int xenbus_gather(struct xenbus_transaction t, const char *dir, ...)
 }
 EXPORT_SYMBOL_GPL(xenbus_gather);
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|918| <<register_xenbus_watch>> err = xs_watch(watch->node, token);
+ *   - drivers/xen/xenbus/xenbus_xs.c|998| <<xs_resume>> xs_watch(watch->node, token);
+ */
 static int xs_watch(const char *path, const char *token)
 {
 	struct kvec iov[2];
@@ -661,10 +1279,21 @@ static int xs_watch(const char *path, const char *token)
 	iov[1].iov_base = (void *)token;
 	iov[1].iov_len = strlen(token) + 1;
 
+	/*
+	 * called by:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|361| <<xs_single>> return xs_talkv(t, type, &iovec, 1, len);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|492| <<xenbus_write>> ret = xs_error(xs_talkv(t, XS_WRITE, iovec, ARRAY_SIZE(iovec), NULL));
+	 *   - drivers/xen/xenbus/xenbus_xs.c|664| <<xs_watch>> return xs_error(xs_talkv(XBT_NIL, XS_WATCH, iov, ARRAY_SIZE(iov), NULL));
+	 *   - drivers/xen/xenbus/xenbus_xs.c|677| <<xs_unwatch>> return xs_error(xs_talkv(XBT_NIL, XS_UNWATCH, iov, ARRAY_SIZE(iov), NULL));
+	 */
 	return xs_error(xs_talkv(XBT_NIL, XS_WATCH, iov,
 				 ARRAY_SIZE(iov), NULL));
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|947| <<unregister_xenbus_watch>> err = xs_unwatch(watch->node, token);
+ */
 static int xs_unwatch(const char *path, const char *token)
 {
 	struct kvec iov[2];
@@ -678,12 +1307,25 @@ static int xs_unwatch(const char *path, const char *token)
 				 ARRAY_SIZE(iov), NULL));
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|840| <<xs_watch_msg>> event->handle = find_watch(event->token);
+ *   - drivers/xen/xenbus/xenbus_xs.c|914| <<register_xenbus_watch>> BUG_ON(find_watch(token));
+ *   - drivers/xen/xenbus/xenbus_xs.c|943| <<unregister_xenbus_watch>> BUG_ON(!find_watch(token));
+ */
 static struct xenbus_watch *find_watch(const char *token)
 {
 	struct xenbus_watch *i, *cmp;
 
 	cmp = (void *)simple_strtoul(token, NULL, 16);
 
+	/*
+	 * 在以下使用watches:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|129| <<global>> static LIST_HEAD(watches);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|768| <<find_watch>> list_for_each_entry(i, &watches, list)
+	 *   - drivers/xen/xenbus/xenbus_xs.c|856| <<register_xenbus_watch>> list_add(&watch->list, &watches);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|937| <<xs_resume>> list_for_each_entry(watch, &watches, list) {
+	 */
 	list_for_each_entry(i, &watches, list)
 		if (i == cmp)
 			return i;
@@ -691,8 +1333,22 @@ static struct xenbus_watch *find_watch(const char *token)
 	return NULL;
 }
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_comms.c|288| <<process_msg>> err = xs_watch_msg(state.watch);
+ */
 int xs_watch_msg(struct xs_watch_event *event)
 {
+	/*
+	 * 61 struct xs_watch_event {
+	 * 62         struct list_head list;
+	 * 63         unsigned int len;
+	 * 64         struct xenbus_watch *handle;
+	 * 65         const char *path;
+	 * 66         const char *token;
+	 * 67         char body[];
+	 * 68 };
+	 */
 	if (count_strings(event->body, event->len) != 2) {
 		kfree(event);
 		return -EINVAL;
@@ -707,8 +1363,22 @@ int xs_watch_msg(struct xs_watch_event *event)
 			 event->handle->will_handle(event->handle,
 				 event->path, event->token))) {
 		spin_lock(&watch_events_lock);
+		/*
+		 * 在以下使用watch_events:
+		 *   - drivers/xen/xenbus/xenbus_xs.c|82| <<global>> static LIST_HEAD(watch_events);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|721| <<xs_watch_msg>> list_add_tail(&event->list, &watch_events);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|832| <<unregister_xenbus_watch>> list_for_each_entry_safe(event, tmp, &watch_events, list) {
+		 *   - drivers/xen/xenbus/xenbus_xs.c|891| <<xenwatch_thread>> !list_empty(&watch_events));
+		 *   - drivers/xen/xenbus/xenbus_xs.c|899| <<xenwatch_thread>> event = list_first_entry_or_null(&watch_events, struct xs_watch_event, list);
+		 */
 		list_add_tail(&event->list, &watch_events);
 		event->handle->nr_pending++;
+		/*
+		 * 在以下使用watch_events_waitq:
+		 *   - drivers/xen/xenbus/xenbus_xs.c|166| <<global>> static DECLARE_WAIT_QUEUE_HEAD(watch_events_waitq);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|793| <<xs_watch_msg>> wake_up(&watch_events_waitq);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|969| <<xenwatch_thread>> wait_event_interruptible(watch_events_waitq, !list_empty(&watch_events));
+		 */
 		wake_up(&watch_events_waitq);
 		spin_unlock(&watch_events_lock);
 	} else
@@ -724,6 +1394,10 @@ int xs_watch_msg(struct xs_watch_event *event)
  * so if we are running on anything older than 4 do not attempt to read
  * control/platform-feature-xs_reset_watches.
  */
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|888| <<xs_reset_watches>> if (xen_strict_xenbus_quirk())
+ */
 static bool xen_strict_xenbus_quirk(void)
 {
 #ifdef CONFIG_X86
@@ -738,6 +1412,10 @@ static bool xen_strict_xenbus_quirk(void)
 	return false;
 
 }
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_xs.c|1045| <<xs_init>> xs_reset_watches();
+ */
 static void xs_reset_watches(void)
 {
 	int err;
@@ -757,6 +1435,26 @@ static void xs_reset_watches(void)
 		pr_warn("xs_reset_watches failed: %d\n", err);
 }
 
+/*
+ * called by:
+ *   - drivers/net/xen-netback/xenbus.c|791| <<xen_register_credit_watch>> err = register_xenbus_watch(&vif->credit_watch);
+ *   - drivers/net/xen-netback/xenbus.c|845| <<xen_register_mcast_ctrl_watch>> err = register_xenbus_watch(&vif->mcast_ctrl_watch);
+ *   - drivers/xen/cpu_hotplug.c|93| <<setup_cpu_watcher>> (void )register_xenbus_watch(&cpu_watch);
+ *   - drivers/xen/manage.c|334| <<setup_shutdown_watcher>> err = register_xenbus_watch(&shutdown_watch);
+ *   - drivers/xen/manage.c|342| <<setup_shutdown_watcher>> err = register_xenbus_watch(&sysrq_watch);
+ *   - drivers/xen/ovmapi.c|1066| <<ovmapi_init_watcher>> err = register_xenbus_watch(&ovmapi_info.dom0_message_watch);
+ *   - drivers/xen/xen-balloon.c|106| <<balloon_init_watcher>> err = register_xenbus_watch(&target_watch);
+ *   - drivers/xen/xenbus/xenbus_client.c|128| <<bool>> err = register_xenbus_watch(watch);
+ *   - drivers/xen/xenbus/xenbus_dev_frontend.c|507| <<xenbus_write_watch>> err = register_xenbus_watch(&watch->watch);
+ *   - drivers/xen/xenbus/xenbus_probe_backend.c|253| <<backend_probe_and_watch>> register_xenbus_watch(&be_watch);
+ *   - drivers/xen/xenbus/xenbus_probe_frontend.c|375| <<xenbus_reset_frontend>> register_xenbus_watch(&be_watch);
+ *   - drivers/xen/xenbus/xenbus_probe_frontend.c|462| <<frontend_probe_and_watch>> register_xenbus_watch(&fe_watch);
+ *
+ * 例子:
+ * 89         static struct xenbus_watch cpu_watch = {
+ * 90                 .node = "cpu",
+ * 91                 .callback = handle_vcpu_hotplug_event};
+ */
 /* Register callback to watch this node. */
 int register_xenbus_watch(struct xenbus_watch *watch)
 {
@@ -772,6 +1470,13 @@ int register_xenbus_watch(struct xenbus_watch *watch)
 
 	spin_lock(&watches_lock);
 	BUG_ON(find_watch(token));
+	/*
+	 * 在以下使用watches:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|129| <<global>> static LIST_HEAD(watches);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|768| <<find_watch>> list_for_each_entry(i, &watches, list)
+	 *   - drivers/xen/xenbus/xenbus_xs.c|856| <<register_xenbus_watch>> list_add(&watch->list, &watches);
+	 *   - drivers/xen/xenbus/xenbus_xs.c|937| <<xs_resume>> list_for_each_entry(watch, &watches, list) {
+	 */
 	list_add(&watch->list, &watches);
 	spin_unlock(&watches_lock);
 
@@ -789,6 +1494,18 @@ int register_xenbus_watch(struct xenbus_watch *watch)
 }
 EXPORT_SYMBOL_GPL(register_xenbus_watch);
 
+/*
+ * called by:
+ *   - drivers/block/xen-blkback/xenbus.c|528| <<xen_blkbk_remove>> unregister_xenbus_watch(&be->backend_watch);
+ *   - drivers/net/xen-netback/xenbus.c|805| <<xen_unregister_credit_watch>> unregister_xenbus_watch(&vif->credit_watch);
+ *   - drivers/net/xen-netback/xenbus.c|860| <<xen_unregister_mcast_ctrl_watch>> unregister_xenbus_watch(&vif->mcast_ctrl_watch);
+ *   - drivers/net/xen-netback/xenbus.c|882| <<unregister_hotplug_status_watch>> unregister_xenbus_watch(&be->hotplug_status_watch);
+ *   - drivers/xen/xen-pciback/xenbus.c|91| <<free_pdev>> unregister_xenbus_watch(&pdev->be_watch);
+ *   - drivers/xen/xenbus/xenbus_dev_frontend.c|324| <<xenbus_worker>> unregister_xenbus_watch(&watch->watch);
+ *   - drivers/xen/xenbus/xenbus_dev_frontend.c|518| <<xenbus_write_watch>> unregister_xenbus_watch(&watch->watch);
+ *   - drivers/xen/xenbus/xenbus_probe.c|114| <<free_otherend_watch>> unregister_xenbus_watch(&dev->otherend_watch);
+ *   - drivers/xen/xenbus/xenbus_probe_frontend.c|394| <<xenbus_reset_frontend>> unregister_xenbus_watch(&be_watch);
+ */
 void unregister_xenbus_watch(struct xenbus_watch *watch)
 {
 	struct xs_watch_event *event, *tmp;
@@ -833,6 +1550,11 @@ void unregister_xenbus_watch(struct xenbus_watch *watch)
 }
 EXPORT_SYMBOL_GPL(unregister_xenbus_watch);
 
+/*
+ * called by:
+ *   - drivers/xen/manage.c|122| <<do_suspend>> xs_suspend();
+ *   - drivers/xen/xenbus/xenbus_dev_backend.c|35| <<xenbus_alloc>> xs_suspend();
+ */
 void xs_suspend(void)
 {
 	xs_suspend_enter();
@@ -841,6 +1563,11 @@ void xs_suspend(void)
 	mutex_lock(&xs_response_mutex);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/manage.c|154| <<do_suspend>> xs_resume();
+ *   - drivers/xen/xenbus/xenbus_dev_backend.c|65| <<xenbus_alloc>> xs_resume();
+ */
 void xs_resume(void)
 {
 	struct xenbus_watch *watch;
@@ -861,6 +1588,11 @@ void xs_resume(void)
 	up_write(&xs_watch_rwsem);
 }
 
+/*
+ * called by:
+ *   - drivers/xen/manage.c|156| <<do_suspend>> xs_suspend_cancel();
+ *   - drivers/xen/xenbus/xenbus_dev_backend.c|70| <<xenbus_alloc>> xs_suspend_cancel();
+ */
 void xs_suspend_cancel(void)
 {
 	mutex_unlock(&xs_response_mutex);
@@ -869,13 +1601,40 @@ void xs_suspend_cancel(void)
 	xs_suspend_exit();
 }
 
+/*
+ * 在以下使用xenwatch_thread():
+ *   - drivers/xen/xenbus/xenbus_xs.c|956| <<xs_init>> task = kthread_run(xenwatch_thread, NULL, "xenwatch");
+ */
 static int xenwatch_thread(void *unused)
 {
+	/*
+	 * 61 struct xs_watch_event {
+	 * 62         struct list_head list;
+	 * 63         unsigned int len;
+	 * 64         struct xenbus_watch *handle;
+	 * 65         const char *path;
+	 * 66         const char *token;
+	 * 67         char body[];
+	 * 68 };
+	 */
 	struct xs_watch_event *event;
 
 	xenwatch_pid = current->pid;
 
 	for (;;) {
+		/*
+		 * 在以下使用watch_events_waitq:
+		 *   - drivers/xen/xenbus/xenbus_xs.c|166| <<global>> static DECLARE_WAIT_QUEUE_HEAD(watch_events_waitq);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|793| <<xs_watch_msg>> wake_up(&watch_events_waitq);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|969| <<xenwatch_thread>> wait_event_interruptible(watch_events_waitq, !list_empty(&watch_events));
+		 *
+		 * 在以下使用watch_events:
+		 *   - drivers/xen/xenbus/xenbus_xs.c|82| <<global>> static LIST_HEAD(watch_events);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|721| <<xs_watch_msg>> list_add_tail(&event->list, &watch_events);
+		 *   - drivers/xen/xenbus/xenbus_xs.c|832| <<unregister_xenbus_watch>> list_for_each_entry_safe(event, tmp, &watch_events, list) {
+		 *   - drivers/xen/xenbus/xenbus_xs.c|891| <<xenwatch_thread>> !list_empty(&watch_events));
+		 *   - drivers/xen/xenbus/xenbus_xs.c|899| <<xenwatch_thread>> event = list_first_entry_or_null(&watch_events, struct xs_watch_event, list);
+		 */
 		wait_event_interruptible(watch_events_waitq,
 					 !list_empty(&watch_events));
 
@@ -930,6 +1689,11 @@ static struct notifier_block xs_reboot_nb = {
 	.notifier_call = xs_reboot_notify,
 };
 
+/*
+ * called by:
+ *   - drivers/xen/xenbus/xenbus_probe.c|696| <<xenbus_probe>> xs_init();
+ *   - drivers/xen/xenbus/xenbus_probe.c|928| <<xenbus_init>> err = xs_init();
+ */
 int xs_init(void)
 {
 	int err;
@@ -937,6 +1701,11 @@ int xs_init(void)
 
 	register_reboot_notifier(&xs_reboot_nb);
 
+	/*
+	 * called by:
+	 *   - drivers/xen/xenbus/xenbus_xs.c|930| <<xs_resume>> xb_init_comms();
+	 *   - drivers/xen/xenbus/xenbus_xs.c|1036| <<xs_init>> err = xb_init_comms();
+	 */
 	/* Initialize the shared memory rings to talk to xenstored */
 	err = xb_init_comms();
 	if (err)
diff --git a/include/xen/events.h b/include/xen/events.h
index 31952308a6d5..b57e6b2824a5 100644
--- a/include/xen/events.h
+++ b/include/xen/events.h
@@ -83,6 +83,20 @@ void xen_send_IPI_one(unsigned int cpu, enum ipi_vector vector);
 void rebind_evtchn_irq(int evtchn, int irq);
 int xen_set_affinity_evtchn(struct irq_desc *desc, unsigned int tcpu);
 
+/*
+ * called by:
+ *   - drivers/char/tpm/xen-tpmfront.c|68| <<vtpm_cancel>> notify_remote_via_evtchn(priv->evtchn);
+ *   - drivers/char/tpm/xen-tpmfront.c|103| <<vtpm_send>> notify_remote_via_evtchn(priv->evtchn);
+ *   - drivers/pci/xen-pcifront.c|130| <<do_pci_op>> notify_remote_via_evtchn(port);
+ *   - drivers/pci/xen-pcifront.c|675| <<pcifront_do_aer>> notify_remote_via_evtchn(pdev->evtchn);
+ *   - drivers/tty/hvc/hvc_xen.c|97| <<notify_daemon>> notify_remote_via_evtchn(cons->evtchn);
+ *   - drivers/xen/events/events_base.c|437| <<notify_remote_via_irq>> notify_remote_via_evtchn(evtchn);
+ *   - drivers/xen/evtchn.c|576| <<evtchn_ioctl>> notify_remote_via_evtchn(notify.port);
+ *   - drivers/xen/gntalloc.c|186| <<__del_gref>> notify_remote_via_evtchn(gref->notify.event);
+ *   - drivers/xen/gntdev.c|284| <<gntdev_put_map>> notify_remote_via_evtchn(map->notify.event);
+ *   - drivers/xen/xenbus/xenbus_comms.c|221| <<xb_write>> notify_remote_via_evtchn(xen_store_evtchn);
+ *   - drivers/xen/xenbus/xenbus_comms.c|279| <<xb_read>> notify_remote_via_evtchn(xen_store_evtchn);
+ */
 static inline void notify_remote_via_evtchn(int port)
 {
 	struct evtchn_send send = { .port = port };
-- 
2.39.5 (Apple Git-154)

