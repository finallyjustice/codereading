From b7e4a27066517aceb557abf2ef308974621d7a24 Mon Sep 17 00:00:00 2001
From: Dongli Zhang <dongli.zhang0129@gmail.com>
Date: Tue, 1 Dec 2020 19:43:41 -0800
Subject: [PATCH 1/1] linux uek6 v5.4.17-2036.101.1

Signed-off-by: Dongli Zhang <dongli.zhang0129@gmail.com>
---
 drivers/infiniband/core/cm.c          |   6 ++
 drivers/infiniband/sw/rxe/rxe_net.c   |  55 ++++++++++
 drivers/infiniband/sw/rxe/rxe_verbs.c |  34 ++++++
 drivers/scsi/iscsi_tcp.c              | 105 +++++++++++++++++++
 drivers/scsi/libiscsi.c               |   4 +
 drivers/scsi/scsi_transport_iscsi.c   |  10 ++
 net/rds/af_rds.c                      |  49 +++++++++
 net/rds/bind.c                        |   6 ++
 net/rds/connection.c                  | 143 ++++++++++++++++++++++++++
 net/rds/ib.c                          |  10 ++
 net/rds/ib.h                          |  21 ++++
 net/rds/ib_cm.c                       |  94 +++++++++++++++++
 net/rds/ib_rdma.c                     |   4 +
 net/rds/ib_recv.c                     |  46 +++++++++
 net/rds/ib_ring.c                     |  13 +++
 net/rds/ib_send.c                     |  44 ++++++++
 net/rds/ib_stats.c                    |   3 +
 net/rds/info.c                        |   4 +
 net/rds/rdma.c                        |   6 ++
 net/rds/rdma_transport.c              |   6 ++
 net/rds/rds.h                         |  30 ++++++
 net/rds/recv.c                        |  62 +++++++++++
 net/rds/send.c                        |  90 ++++++++++++++++
 net/rds/threads.c                     |   4 +
 net/rds/transport.c                   |  14 +++
 25 files changed, 863 insertions(+)

diff --git a/drivers/infiniband/core/cm.c b/drivers/infiniband/core/cm.c
index 54507569475a..744a2a23f1d9 100644
--- a/drivers/infiniband/core/cm.c
+++ b/drivers/infiniband/core/cm.c
@@ -3879,6 +3879,12 @@ static void cm_send_handler(struct ib_mad_agent *mad_agent,
 	}
 }
 
+/*
+ * 在以下使用cm_work_handler():
+ *   - drivers/infiniband/core/cm.c|959| <<cm_create_timewait_info>> INIT_DELAYED_WORK(&timewait_info->work.work, cm_work_handler);
+ *   - drivers/infiniband/core/cm.c|3982| <<cm_establish>> INIT_DELAYED_WORK(&work->work, cm_work_handler);
+ *   - drivers/infiniband/core/cm.c|4114| <<cm_recv_handler>> INIT_DELAYED_WORK(&work->work, cm_work_handler);
+ */
 static void cm_work_handler(struct work_struct *_work)
 {
 	struct cm_work *work = container_of(_work, struct cm_work, work.work);
diff --git a/drivers/infiniband/sw/rxe/rxe_net.c b/drivers/infiniband/sw/rxe/rxe_net.c
index 312c2fc961c0..d520995b5fbd 100644
--- a/drivers/infiniband/sw/rxe/rxe_net.c
+++ b/drivers/infiniband/sw/rxe/rxe_net.c
@@ -421,6 +421,61 @@ static void rxe_skb_tx_dtor(struct sk_buff *skb)
 	rxe_drop_ref(qp);
 }
 
+/*
+ * 几个例子
+ *
+ * [0] rxe_send
+ * [0] rxe_do_task
+ * [0] rxe_run_task
+ * [0] rxe_post_send
+ * [0] ib_uverbs_post_send
+ * [0] ib_uverbs_write
+ * [0] __vfs_write
+ * [0] vfs_write
+ * [0] ksys_write
+ * [0] __x64_sys_write
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ *
+ * [0] rxe_send
+ * [0] rxe_responder
+ * [0] rxe_do_task
+ * [0] rxe_run_task
+ * [0] rxe_resp_queue_pkt
+ * [0] rxe_rcv
+ * [0] rxe_udp_encap_recv
+ * [0] udp_queue_rcv_one_skb
+ * [0] udp_queue_rcv_skb
+ * [0] udp_unicast_rcv_skb
+ * [0] __udp4_lib_rcv
+ * [0] udp_rcv
+ * [0] ip_protocol_deliver_rcu
+ * [0] ip_local_deliver_finish
+ * [0] ip_local_deliver
+ * [0] ip_rcv_finish
+ * [0] ip_rcv
+ * [0] __netif_receive_skb_one_core
+ * [0] __netif_receive_skb
+ * [0] netif_receive_skb_internal
+ * [0] napi_gro_receive
+ * [0] receive_buf
+ * [0] virtnet_poll
+ * [0] net_rx_action
+ * [0] __do_softirq
+ * [0] irq_exit
+ * [0] do_IRQ
+ * [0] ret_from_intr
+ *
+ * [0] rxe_send
+ * [0] rxe_do_task
+ * [0] tasklet_action_common.isra.18
+ * [0] tasklet_action
+ * [0] __do_softirq
+ * [0] run_ksoftirqd
+ * [0] smpboot_thread_fn
+ * [0] kthread
+ * [0] ret_from_fork
+ */
 int rxe_send(struct rxe_pkt_info *pkt, struct sk_buff *skb)
 {
 	int err;
diff --git a/drivers/infiniband/sw/rxe/rxe_verbs.c b/drivers/infiniband/sw/rxe/rxe_verbs.c
index 36b4ab8ea4e6..a6de8278766d 100644
--- a/drivers/infiniband/sw/rxe/rxe_verbs.c
+++ b/drivers/infiniband/sw/rxe/rxe_verbs.c
@@ -689,6 +689,10 @@ static int post_one_send(struct rxe_qp *qp, const struct ib_send_wr *ibwr,
 	return err;
 }
 
+/*
+ * called by:
+ *   - drivers/infiniband/sw/rxe/rxe_verbs.c|758| <<rxe_post_send>> return rxe_post_send_kernel(qp, wr, bad_wr);
+ */
 static int rxe_post_send_kernel(struct rxe_qp *qp, const struct ib_send_wr *wr,
 				const struct ib_send_wr **bad_wr)
 {
@@ -735,6 +739,36 @@ static int rxe_post_send_kernel(struct rxe_qp *qp, const struct ib_send_wr *wr,
 	return err;
 }
 
+/*
+ * [0] rxe_post_send
+ * [0] rds_ib_rx
+ * [0] rds_ib_tasklet_fn_recv
+ * [0] tasklet_action_common.isra.18
+ * [0] tasklet_action
+ * [0] __do_softirq
+ * [0] irq_exit
+ * [0] do_IRQ
+ * [0] ret_from_intr
+ * [0] native_safe_halt
+ * [0] default_idle
+ * [0] arch_cpu_idle
+ * [0] default_idle_call
+ * [0] do_idle
+ * [0] cpu_startup_entry
+ * [0] start_secondary
+ * [0] secondary_startup_64
+ *
+ * [0] rxe_post_send
+ * [0] rds_send_xmit
+ * [0] rds_sendmsg
+ * [0] sock_sendmsg
+ * [0] ____sys_sendmsg
+ * [0] ___sys_sendmsg
+ * [0] __sys_sendmsg
+ * [0] __x64_sys_sendmsg
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ */
 static int rxe_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,
 			 const struct ib_send_wr **bad_wr)
 {
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index b5dd1caae5e9..f71e4f75391d 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -47,6 +47,12 @@ MODULE_LICENSE("GPL");
 
 static struct scsi_transport_template *iscsi_sw_tcp_scsi_transport;
 static struct scsi_host_template iscsi_sw_tcp_sht;
+/*
+ * 在以下使用iscsi_sw_tcp_transport:
+ *   - drivers/scsi/iscsi_tcp.c|939| <<iscsi_sw_tcp_session_create>> cls_session = iscsi_session_setup(&iscsi_sw_tcp_transport, shost,
+ *   - drivers/scsi/iscsi_tcp.c|1114| <<iscsi_sw_tcp_init>> &iscsi_sw_tcp_transport);
+ *   - drivers/scsi/iscsi_tcp.c|1123| <<iscsi_sw_tcp_exit>> iscsi_unregister_transport(&iscsi_sw_tcp_transport);
+ */
 static struct iscsi_transport iscsi_sw_tcp_transport;
 
 static unsigned int iscsi_max_lun = ~0;
@@ -58,6 +64,19 @@ module_param_named(debug_iscsi_tcp, iscsi_sw_tcp_dbg, int,
 MODULE_PARM_DESC(debug_iscsi_tcp, "Turn on debugging for iscsi_tcp module "
 		 "Set to 1 to turn on, and zero to turn off. Default is off.");
 
+/*
+ * called by:
+ *   - drivers/scsi/iscsi_tcp.c|87| <<iscsi_sw_tcp_recv>> ISCSI_SW_TCP_DBG(conn, "in %d bytes\n", skb->len - offset);
+ *   - drivers/scsi/iscsi_tcp.c|96| <<iscsi_sw_tcp_recv>> ISCSI_SW_TCP_DBG(conn, "read %d bytes status %d\n",
+ *   - drivers/scsi/iscsi_tcp.c|118| <<iscsi_sw_sk_state_check>> ISCSI_SW_TCP_DBG(conn, "TCP_CLOSE|TCP_CLOSE_WAIT\n");
+ *   - drivers/scsi/iscsi_tcp.c|207| <<iscsi_sw_tcp_write_space>> ISCSI_SW_TCP_DBG(conn, "iscsi_write_space\n");
+ *   - drivers/scsi/iscsi_tcp.c|342| <<iscsi_sw_tcp_xmit>> ISCSI_SW_TCP_DBG(conn, "xmit %d bytes\n", consumed);
+ *   - drivers/scsi/iscsi_tcp.c|350| <<iscsi_sw_tcp_xmit>> ISCSI_SW_TCP_DBG(conn, "Error sending PDU, errno=%d\n", rc);
+ *   - drivers/scsi/iscsi_tcp.c|409| <<iscsi_sw_tcp_send_hdr_done>> ISCSI_SW_TCP_DBG(tcp_conn->iscsi_conn,
+ *   - drivers/scsi/iscsi_tcp.c|422| <<iscsi_sw_tcp_send_hdr_prep>> ISCSI_SW_TCP_DBG(conn, "%s\n", conn->hdrdgst_en ?
+ *   - drivers/scsi/iscsi_tcp.c|465| <<iscsi_sw_tcp_send_data_prep>> ISCSI_SW_TCP_DBG(conn, "offset=%d, datalen=%d %s\n", offset, len,
+ *   - drivers/scsi/iscsi_tcp.c|491| <<iscsi_sw_tcp_send_linear_data_prep>> ISCSI_SW_TCP_DBG(conn, "datalen=%zd %s\n", len, conn->datadgst_en ?
+ */
 #define ISCSI_SW_TCP_DBG(_conn, dbg_fmt, arg...)		\
 	do {							\
 		if (iscsi_sw_tcp_dbg)				\
@@ -77,6 +96,57 @@ MODULE_PARM_DESC(debug_iscsi_tcp, "Turn on debugging for iscsi_tcp module "
  * @offset: offset in skb
  * @len: skb->len - offset
  */
+/*
+ * 两个例子
+ *
+ * [0] iscsi_sw_tcp_recv
+ * [0] iscsi_sw_tcp_data_ready
+ * [0] tcp_data_queue
+ * [0] tcp_rcv_established
+ * [0] tcp_v4_do_rcv
+ * [0] tcp_v4_rcv
+ * [0] ip_protocol_deliver_rcu
+ * [0] ip_local_deliver_finish
+ * [0] ip_local_deliver
+ * [0] ip_rcv_finish
+ * [0] ip_rcv
+ * [0] __netif_receive_skb_one_core
+ * [0] __netif_receive_skb
+ * [0] netif_receive_skb_internal
+ * [0] napi_gro_receive
+ * [0] receive_buf
+ * [0] virtnet_poll
+ * [0] net_rx_action
+ * [0] __do_softirq
+ * [0] irq_exit
+ * [0] do_IRQ
+ * [0] ret_from_intr
+ *
+ * [0] iscsi_sw_tcp_recv
+ * [0] iscsi_sw_tcp_data_ready
+ * [0] tcp_rcv_established
+ * [0] tcp_v4_do_rcv
+ * [0] tcp_v4_rcv
+ * [0] ip_protocol_deliver_rcu
+ * [0] ip_local_deliver_finish
+ * [0] ip_local_deliver
+ * [0] ip_rcv_finish
+ * [0] ip_rcv
+ * [0] __netif_receive_skb_one_core
+ * [0] __netif_receive_skb
+ * [0] netif_receive_skb_internal
+ * [0] napi_gro_receive
+ * [0] receive_buf
+ * [0] virtnet_poll
+ * [0] net_rx_action
+ * [0] __do_softirq
+ * [0] irq_exit
+ * [0] do_IRQ
+ * [0] ret_from_intr
+ *
+ * called by:
+ *   - drivers/scsi/iscsi_tcp.c|208| <<iscsi_sw_tcp_data_ready>> tcp_read_sock(sk, &rd_desc, iscsi_sw_tcp_recv);
+ */
 static int iscsi_sw_tcp_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 			     unsigned int offset, size_t len)
 {
@@ -305,6 +375,19 @@ static int iscsi_sw_tcp_xmit_segment(struct iscsi_tcp_conn *tcp_conn,
  * iscsi_sw_tcp_xmit - TCP transmit
  * @conn: iscsi connection
  **/
+/*
+ * [0] iscsi_sw_tcp_xmit
+ * [0] iscsi_sw_tcp_pdu_xmit
+ * [0] iscsi_xmit_task
+ * [0] iscsi_xmitworker
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - drivers/scsi/iscsi_tcp.c|385| <<iscsi_sw_tcp_pdu_xmit>> rc = iscsi_sw_tcp_xmit(conn);
+ */
 static int iscsi_sw_tcp_xmit(struct iscsi_conn *conn)
 {
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
@@ -540,6 +623,22 @@ static int iscsi_sw_tcp_pdu_alloc(struct iscsi_task *task, uint8_t opcode)
 	return 0;
 }
 
+/*
+ * [0] iscsi_sw_tcp_session_create
+ * [0] iscsi_if_recv_msg
+ * [0] iscsi_if_rx
+ * [0] netlink_unicast
+ * [0] netlink_sendmsg
+ * [0] sock_sendmsg
+ * [0] ____sys_sendmsg
+ * [0] ___sys_sendmsg
+ * [0] __sys_sendmsg
+ * [0] __x64_sys_sendmsg
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ *
+ * struct iscsi_transport iscsi_sw_tcp_transpor.create_conn = iscsi_sw_tcp_conn_create()
+ */
 static struct iscsi_cls_conn *
 iscsi_sw_tcp_conn_create(struct iscsi_cls_session *cls_session,
 			 uint32_t conn_idx)
@@ -989,6 +1088,12 @@ static struct scsi_host_template iscsi_sw_tcp_sht = {
 	.track_queue_depth	= 1,
 };
 
+/*
+ * 在以下使用iscsi_sw_tcp_transport:
+ *   - drivers/scsi/iscsi_tcp.c|939| <<iscsi_sw_tcp_session_create>> cls_session = iscsi_session_setup(&iscsi_sw_tcp_transport, shost,
+ *   - drivers/scsi/iscsi_tcp.c|1114| <<iscsi_sw_tcp_init>> &iscsi_sw_tcp_transport);
+ *   - drivers/scsi/iscsi_tcp.c|1123| <<iscsi_sw_tcp_exit>> iscsi_unregister_transport(&iscsi_sw_tcp_transport);
+ */
 static struct iscsi_transport iscsi_sw_tcp_transport = {
 	.owner			= THIS_MODULE,
 	.name			= "tcp",
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 74fdb180d011..f23fff54e367 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1582,6 +1582,10 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 	return rc;
 }
 
+/*
+ * 在以下使用iscsi_xmitworker():
+ *   - drivers/scsi/libiscsi.c|2916| <<iscsi_conn_setup>> INIT_WORK(&conn->xmitwork, iscsi_xmitworker);
+ */
 static void iscsi_xmitworker(struct work_struct *work)
 {
 	struct iscsi_conn *conn =
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 5de8ced5169e..d3904d76cd3d 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -4530,6 +4530,16 @@ int iscsi_unregister_transport(struct iscsi_transport *tt)
 }
 EXPORT_SYMBOL_GPL(iscsi_unregister_transport);
 
+/*
+ * called by:
+ *   - drivers/scsi/iscsi_tcp.c|67| <<ISCSI_SW_TCP_DBG>> iscsi_dbg_trace(trace_iscsi_dbg_sw_tcp, \
+ *   - drivers/scsi/libiscsi.c|59| <<ISCSI_DBG_CONN>> iscsi_dbg_trace(trace_iscsi_dbg_conn, \
+ *   - drivers/scsi/libiscsi.c|70| <<ISCSI_DBG_SESSION>> iscsi_dbg_trace(trace_iscsi_dbg_session, \
+ *   - drivers/scsi/libiscsi.c|81| <<ISCSI_DBG_EH>> iscsi_dbg_trace(trace_iscsi_dbg_eh, \
+ *   - drivers/scsi/libiscsi_tcp.c|58| <<ISCSI_DBG_TCP>> iscsi_dbg_trace(trace_iscsi_dbg_tcp, \
+ *   - drivers/scsi/scsi_transport_iscsi.c|63| <<ISCSI_DBG_TRANS_SESSION>> iscsi_dbg_trace(trace_iscsi_dbg_trans_session, \
+ *   - drivers/scsi/scsi_transport_iscsi.c|74| <<ISCSI_DBG_TRANS_CONN>> iscsi_dbg_trace(trace_iscsi_dbg_trans_conn, \
+ */
 void iscsi_dbg_trace(void (*trace)(struct device *dev, struct va_format *),
 		     struct device *dev, const char *fmt, ...)
 {
diff --git a/net/rds/af_rds.c b/net/rds/af_rds.c
index af4481d6386c..da830ea964fa 100644
--- a/net/rds/af_rds.c
+++ b/net/rds/af_rds.c
@@ -77,6 +77,14 @@ EXPORT_SYMBOL(rds_str_array);
 /* this is just used for stats gathering :/ */
 static DEFINE_SPINLOCK(rds_sock_lock);
 static unsigned long rds_sock_count;
+/*
+ * 在以下使用rds_sock_list:
+ *   - net/rds/af_rds.c|987| <<__rds_create>> list_add_tail(&rs->rs_item, &rds_sock_list);
+ *   - net/rds/af_rds.c|1076| <<rds_sock_inc_info>> list_for_each_entry(rs, &rds_sock_list, rs_item) {
+ *   - net/rds/af_rds.c|1112| <<rds6_sock_inc_info>> list_for_each_entry(rs, &rds_sock_list, rs_item) {
+ *   - net/rds/af_rds.c|1147| <<rds_sock_info>> list_for_each_entry(rs, &rds_sock_list, rs_item) {
+ *   - net/rds/af_rds.c|1181| <<rds6_sock_info>> list_for_each_entry(rs, &rds_sock_list, rs_item) {
+ */
 static LIST_HEAD(rds_sock_list);
 DECLARE_WAIT_QUEUE_HEAD(rds_poll_waitq);
 
@@ -944,6 +952,13 @@ static void rds_sock_destruct(struct sock *sk)
 	    &rs->rs_item != rs->rs_item.prev));
 }
 
+/*
+ * [0] rds_create
+ * [0] __sys_socket
+ * [0] __x64_sys_socket
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ */
 static int __rds_create(struct socket *sock, struct sock *sk, int protocol)
 {
 	struct rds_sock *rs;
@@ -954,6 +969,10 @@ static int __rds_create(struct socket *sock, struct sock *sk, int protocol)
 	sk->sk_protocol		= protocol;
 	sk->sk_destruct		= rds_sock_destruct;
 
+	/*
+	 * struct rds_sock:
+	 *   -> struct sock rs_sk;
+	 */
 	rs = rds_sk_to_rs(sk);
 	spin_lock_init(&rs->rs_lock);
 	rwlock_init(&rs->rs_recv_lock);
@@ -971,6 +990,15 @@ static int __rds_create(struct socket *sock, struct sock *sk, int protocol)
 	rs->rs_rx_traces = 0;
 
 	spin_lock_init(&rs->rs_snd_lock);
+	/*
+	 * 在以下使用rds_sock->rs_buf_info_tbl:
+	 *   - net/rds/af_rds.c|128| <<rds_release>> rhashtable_free_and_destroy(&rs->rs_buf_info_tbl, rds_buf_info_free,
+	 *   - net/rds/af_rds.c|753| <<rds_add_buf_info>> info = rhashtable_lookup_fast(&rs->rs_buf_info_tbl, addr,
+	 *   - net/rds/af_rds.c|780| <<rds_add_buf_info>> *ret = rhashtable_insert_fast(&rs->rs_buf_info_tbl,
+	 *   - net/rds/af_rds.c|796| <<rds_add_buf_info>> info = rhashtable_lookup_fast(&rs->rs_buf_info_tbl, addr,
+	 *   - net/rds/af_rds.c|974| <<__rds_create>> ret = rhashtable_init(&rs->rs_buf_info_tbl, &rs_buf_info_params);
+	 *   - net/rds/rds.h|975| <<rds_get_buf_info>> return rhashtable_lookup_fast(&rs->rs_buf_info_tbl, addr,
+	 */
 	ret = rhashtable_init(&rs->rs_buf_info_tbl, &rs_buf_info_params);
 	if (ret)
 		return ret;
@@ -984,6 +1012,14 @@ static int __rds_create(struct socket *sock, struct sock *sk, int protocol)
 	}
 
 	spin_lock_bh(&rds_sock_lock);
+	/*
+	 * 在以下使用rds_sock_list:
+	 *   - net/rds/af_rds.c|987| <<__rds_create>> list_add_tail(&rs->rs_item, &rds_sock_list);
+	 *   - net/rds/af_rds.c|1076| <<rds_sock_inc_info>> list_for_each_entry(rs, &rds_sock_list, rs_item) {
+	 *   - net/rds/af_rds.c|1112| <<rds6_sock_inc_info>> list_for_each_entry(rs, &rds_sock_list, rs_item) {
+	 *   - net/rds/af_rds.c|1147| <<rds_sock_info>> list_for_each_entry(rs, &rds_sock_list, rs_item) {
+	 *   - net/rds/af_rds.c|1181| <<rds6_sock_info>> list_for_each_entry(rs, &rds_sock_list, rs_item) {
+	 */
 	list_add_tail(&rs->rs_item, &rds_sock_list);
 	rds_sock_count++;
 	spin_unlock_bh(&rds_sock_lock);
@@ -991,6 +1027,13 @@ static int __rds_create(struct socket *sock, struct sock *sk, int protocol)
 	return 0;
 }
 
+/*
+ * [0] rds_create
+ * [0] __sys_socket
+ * [0] __x64_sys_socket
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ */
 static int rds_create(struct net *net, struct socket *sock, int protocol, int kern)
 {
 	struct sock *sk;
@@ -1000,6 +1043,12 @@ static int rds_create(struct net *net, struct socket *sock, int protocol, int ke
 	    (protocol && IPPROTO_OKA != protocol))
 		return -ESOCKTNOSUPPORT;
 
+	/*
+	 * struct rds_sock:
+	 *   -> struct sock rs_sk;
+	 *
+	 * struct proto rds_proto.obj_size = sizeof(struct rds_sock)
+	 */
 	sk = sk_alloc(net, AF_RDS, GFP_KERNEL, &rds_proto, kern);
 	if (!sk)
 		return -ENOMEM;
diff --git a/net/rds/bind.c b/net/rds/bind.c
index c37dd96f7ac8..97ff83660ff7 100644
--- a/net/rds/bind.c
+++ b/net/rds/bind.c
@@ -184,6 +184,12 @@ void rds_remove_bound(struct rds_sock *rs)
 	write_unlock_irqrestore(&bucket->lock, flags);
 }
 
+/*
+ * [0] rds_bind
+ * [0] __x64_sys_bind
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ */
 int rds_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 {
 	struct sock *sk = sock->sk;
diff --git a/net/rds/connection.c b/net/rds/connection.c
index 5882adf51029..90377ef881e4 100644
--- a/net/rds/connection.c
+++ b/net/rds/connection.c
@@ -55,6 +55,11 @@ static struct kmem_cache *rds_conn_slab;
 	 (head) < rds_conn_hash + ARRAY_SIZE(rds_conn_hash);	\
 	 (head)++)
 
+/*
+ * called by:
+ *   - net/rds/connection.c|236| <<__rds_conn_create>> struct hlist_head *head = rds_conn_bucket(laddr, faddr, tos);
+ *   - net/rds/connection.c|446| <<rds_conn_find>> struct hlist_head *head = rds_conn_bucket(laddr, faddr, tos);
+ */
 static struct hlist_head *rds_conn_bucket(const struct in6_addr *laddr,
 					  const struct in6_addr *faddr,
 					  u8 tos)
@@ -79,12 +84,32 @@ static struct hlist_head *rds_conn_bucket(const struct in6_addr *laddr,
 	return &rds_conn_hash[hash & RDS_CONNECTION_HASH_MASK];
 }
 
+/*
+ * 在以下调用rds_conn_info_set():
+ *   - net/rds/connection.c|945| <<rds_conn_info_visitor>> rds_conn_info_set(cinfo->flags, test_bit(RDS_IN_XMIT, &cp->cp_flags),
+ *   - net/rds/connection.c|948| <<rds_conn_info_visitor>> rds_conn_info_set(cinfo->flags,
+ *   - net/rds/connection.c|951| <<rds_conn_info_visitor>> rds_conn_info_set(cinfo->flags,
+ *   - net/rds/connection.c|954| <<rds_conn_info_visitor>> rds_conn_info_set(cinfo->flags, cp->cp_pending_flush,
+ *   - net/rds/connection.c|977| <<fill_path_info>> rds_conn_info_set(pinfo->flags,
+ *   - net/rds/connection.c|980| <<fill_path_info>> rds_conn_info_set(pinfo->flags,
+ *   - net/rds/connection.c|983| <<fill_path_info>> rds_conn_info_set(pinfo->flags, cp->cp_pending_flush,
+ *   - net/rds/connection.c|1022| <<rds6_conn_info_visitor>> rds_conn_info_set(cinfo6->flags, test_bit(RDS_IN_XMIT, &cp->cp_flags),
+ *   - net/rds/connection.c|1025| <<rds6_conn_info_visitor>> rds_conn_info_set(cinfo6->flags,
+ *   - net/rds/connection.c|1028| <<rds6_conn_info_visitor>> rds_conn_info_set(cinfo6->flags,
+ *   - net/rds/connection.c|1031| <<rds6_conn_info_visitor>> rds_conn_info_set(cinfo6->flags, cp->cp_pending_flush,
+ */
 #define rds_conn_info_set(var, test, suffix) do {		\
 	if (test)						\
 		var |= RDS_INFO_CONNECTION_FLAG_##suffix;	\
 } while (0)
 
 /* rcu read lock must be held or the connection spinlock */
+/*
+ * called by:
+ *   - net/rds/connection.c|247| <<__rds_conn_create>> conn = rds_conn_lookup(net, head, laddr, faddr, trans, tos, dev_if);
+ *   - net/rds/connection.c|386| <<__rds_conn_create>> found = rds_conn_lookup(net, head, laddr, faddr, trans, tos,
+ *   - net/rds/connection.c|449| <<rds_conn_find>> conn = rds_conn_lookup(net, head, laddr, faddr, trans, tos, dev_if);
+ */
 static struct rds_connection *rds_conn_lookup(struct net *net,
 					      struct hlist_head *head,
 					      const struct in6_addr *laddr,
@@ -224,6 +249,19 @@ static void __rds_conn_path_init(struct rds_connection *conn,
  * For now they are not garbage collected once they're created.  They
  * are torn down as the module is removed, if ever.
  */
+/*
+ * 猜测这里的conn是:
+ * # rds-info -n
+ *
+ * RDS Connections:
+ *       LocalAddr      RemoteAddr  Tos           NextTX           NextRX Flgs
+ * 100.100.231.248 100.100.231.251    0           789534         17396635 --C-
+ *
+ *
+ * called by:
+ *   - net/rds/connection.c|458| <<rds_conn_create>> return __rds_conn_create(net, laddr, faddr, trans, gfp, tos, 0, dev_if);
+ *   - net/rds/connection.c|478| <<rds_conn_create_outgoing>> return __rds_conn_create(net, laddr, faddr, trans, gfp, tos, 1, dev_if);
+ */
 static struct rds_connection *__rds_conn_create(struct net *net,
 						const struct in6_addr *laddr,
 						const struct in6_addr *faddr,
@@ -340,6 +378,19 @@ static struct rds_connection *__rds_conn_create(struct net *net,
 			cp->cp_wq = rds_cp_wqs[cp_wqs_inx];
 		}
 	}
+
+	/*
+	 * [0] rds_ib_conn_alloc
+	 * [0] rds_conn_create_outgoing
+	 * [0] rds_sendmsg
+	 * [0] sock_sendmsg
+	 * [0] ____sys_sendmsg
+	 * [0] ___sys_sendmsg
+	 * [0] __sys_sendmsg
+	 * [0] __x64_sys_sendmsg
+	 * [0] do_syscall_64
+	 * [0] entry_SYSCALL_64_after_hwframe
+	 */
 	ret = trans->conn_alloc(conn, gfp);
 	if (ret) {
 		kfree(conn->c_path);
@@ -417,6 +468,11 @@ static struct rds_connection *__rds_conn_create(struct net *net,
 	return conn;
 }
 
+/*
+ * called by:
+ *   - net/rds/ib_cm.c|1458| <<rds_ib_cm_handle_connect>> conn = rds_conn_create(&init_net, daddr6, saddr6,
+ *   - net/rds/tcp_listen.c|192| <<rds_tcp_accept_one>> conn = rds_conn_create(sock_net(sock->sk),
+ */
 struct rds_connection *rds_conn_create(struct net *net,
 				       const struct in6_addr *laddr,
 				       const struct in6_addr *faddr,
@@ -427,6 +483,16 @@ struct rds_connection *rds_conn_create(struct net *net,
 }
 EXPORT_SYMBOL_GPL(rds_conn_create);
 
+/*
+ * [0] rds_conn_create_outgoing
+ * [0] sock_sendmsg
+ * [0] ____sys_sendmsg
+ * [0] ___sys_sendmsg
+ * [0] __sys_sendmsg
+ * [0] __x64_sys_sendmsg
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ */
 struct rds_connection *rds_conn_create_outgoing(struct net *net,
 						struct in6_addr *laddr,
 						struct in6_addr *faddr,
@@ -453,6 +519,10 @@ struct rds_connection *rds_conn_find(struct net *net, struct in6_addr *laddr,
 }
 EXPORT_SYMBOL_GPL(rds_conn_find);
 
+/*
+ * called by:
+ *   - net/rds/threads.c|430| <<rds_shutdown_worker>> rds_conn_shutdown(cp, restart);
+ */
 void rds_conn_shutdown(struct rds_conn_path *cp, int restart)
 {
 	struct rds_connection *conn = cp->cp_conn;
@@ -780,6 +850,11 @@ static void rds6_conn_message_info_retrans(struct socket *sock,
 }
 #endif
 
+/*
+ * called by:
+ *   - net/rds/ib.c|864| <<rds_ib_ic_info>> rds_for_each_conn_info(sock, len, iter, lens,
+ *   - net/rds/ib.c|877| <<rds6_ib_ic_info>> rds_for_each_conn_info(sock, len, iter, lens,
+ */
 void rds_for_each_conn_info(struct socket *sock, unsigned int len,
 			    struct rds_info_iterator *iter,
 			    struct rds_info_lengths *lens,
@@ -1142,6 +1217,35 @@ char *conn_drop_reason_str(enum rds_conn_drop_src reason)
 /*
  * Force a disconnect
  */
+/*
+ * [0] rds_conn_path_drop
+ * [0] rds_rdma_cm_event_handler_cmn
+ * [0] rds_rdma_cm_event_handler
+ * [0] cma_ib_handler
+ * [0] cm_process_work
+ * [0] cm_work_handler
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - net/rds/af_rds.c|451| <<rds_user_conn_paths_drop>> rds_conn_path_drop(cp, DR_USER_RESET);
+ *   - net/rds/af_rds.c|456| <<rds_user_conn_paths_drop>> rds_conn_path_drop(cp, DR_USER_RESET);
+ *   - net/rds/connection.c|534| <<rds_conn_shutdown>> rds_conn_path_drop(cp, DR_INV_CONN_STATE);
+ *   - net/rds/connection.c|569| <<rds_conn_shutdown>> rds_conn_path_drop(cp, DR_DOWN_TRANSITION_FAIL);
+ *   - net/rds/connection.c|618| <<rds_conn_path_destroy>> rds_conn_path_drop(cp, DR_CONN_DESTROY);
+ *   - net/rds/connection.c|1261| <<rds_conn_drop>> rds_conn_path_drop(&conn->c_path[0], reason);
+ *   - net/rds/connection.c|1277| <<rds_conn_drop>> rds_conn_path_drop(peer->c_path + 0, reason);
+ *   - net/rds/tcp.c|659| <<rds_tcp_sysctl_reset>> rds_conn_path_drop(tc->t_cpath, DR_USER_RESET);
+ *   - net/rds/tcp_connect.c|67| <<rds_tcp_state_change>> rds_conn_path_drop(cp, DR_TCP_STATE_CLOSE);
+ *   - net/rds/tcp_connect.c|75| <<rds_tcp_state_change>> rds_conn_path_drop(cp, DR_TCP_STATE_CLOSE);
+ *   - net/rds/tcp_send.c|165| <<rds_tcp_xmit>> rds_conn_path_drop(cp, DR_TCP_STATE_CLOSE);
+ *   - net/rds/threads.c|113| <<rds_connect_path_complete>> rds_conn_path_drop(cp, DR_IB_NOT_CONNECTING_STATE);
+ *   - net/rds/threads.c|262| <<rds_connect_worker>> rds_conn_path_drop(cp, DR_CONN_CONNECT_FAIL);
+ *   - net/rds/threads.c|359| <<rds_hb_worker>> rds_conn_path_drop(cp, DR_HB_TIMEOUT);
+ *   - net/rds/threads.c|395| <<rds_reconnect_timeout>> rds_conn_path_drop(cp, DR_RECONNECT_TIMEOUT);
+ */
 void rds_conn_path_drop(struct rds_conn_path *cp, int reason)
 {
 	unsigned long now = get_seconds();
@@ -1157,6 +1261,13 @@ void rds_conn_path_drop(struct rds_conn_path *cp, int reason)
 		cp->cp_connection_reset = ktime_get_real_seconds();
 		/* Restart counting */
 		cp->cp_connection_attempts = 0;
+		/*
+		 * [329683.387224] RDS/IB: connection <::ffff:xxx.xxx.xxx.251,::ffff:xxx.xxx.xxx.20,0> dropped due to 'RDMA device removal'
+		 * [329683.391885] RDS/IB: connection <::ffff:xxx.xxx.xxx.251,::ffff:xxx.xxx.xxx.248,0> dropped due to 'RDMA device removal'
+		 *
+		 * [317830.182577] RDS/IB: connection <::ffff:xxx.xxx.xxx.251,::ffff:xxx.xxx.xxx.248,0> dropped due to 'DISCONNECTED event'
+		 * [317830.211642] RDS/IB: Passive conn 000000008ef4824b i_cm_id 00000000c91f483b, frag 16KB, connected <::ffff:xxx.xxx.xxx.251,::ffff:xxx.xxx.xxx.248,0> version 4.1
+		 */
 		if (conn->c_trans->t_type != RDS_TRANS_TCP)
 			printk(KERN_INFO "RDS/IB: connection <%pI6c,%pI6c,%d> dropped due to '%s'\n",
 			       &conn->c_laddr,
@@ -1198,6 +1309,38 @@ void rds_conn_path_drop(struct rds_conn_path *cp, int reason)
 }
 EXPORT_SYMBOL_GPL(rds_conn_path_drop);
 
+/*
+ * called by:
+ *   - net/rds/af_rds.c|488| <<rds_user_reset>> rds_conn_drop(conn, DR_USER_RESET);
+ *   - net/rds/ib.c|457| <<__rds_ib_dev_shutdown>> rds_conn_drop(ic->conn, DR_RDMA_DEV_REM);
+ *   - net/rds/ib_cm.c|354| <<rds_ib_cm_connect_complete>> rds_conn_drop(conn, DR_IB_CONN_DROP_RACE);
+ *   - net/rds/ib_cm.c|738| <<rds_ib_qp_event_handler>> rds_conn_drop(conn, DR_IB_QP_EVENT);
+ *   - net/rds/ib_cm.c|1517| <<rds_ib_cm_handle_connect>> rds_conn_drop(conn, DR_IB_REQ_WHILE_CONN_UP);
+ *   - net/rds/ib_cm.c|1535| <<rds_ib_cm_handle_connect>> rds_conn_drop(conn, DR_IB_REQ_WHILE_CONNECTING);
+ *   - net/rds/ib_cm.c|1546| <<rds_ib_cm_handle_connect>> rds_conn_drop(conn, DR_IB_REQ_WHILE_CONNECTING);
+ *   - net/rds/ib_cm.c|1602| <<rds_ib_cm_handle_connect>> rds_conn_drop(conn, DR_IB_PAS_SETUP_QP_FAIL);
+ *   - net/rds/ib_cm.c|1620| <<rds_ib_cm_handle_connect>> rds_conn_drop(conn, DR_IB_RDMA_ACCEPT_FAIL);
+ *   - net/rds/ib_cm.c|1716| <<rds_ib_cm_initiate_connect>> rds_conn_drop(conn, DR_IB_ACT_SETUP_QP_FAIL);
+ *   - net/rds/ib_cm.c|1726| <<rds_ib_cm_initiate_connect>> rds_conn_drop(conn, DR_IB_RDMA_CONNECT_FAIL);
+ *   - net/rds/ib_recv.c|612| <<rds_ib_recv_refill>> rds_conn_drop(conn, DR_IB_POST_RECV_FAIL);
+ *   - net/rds/ib_recv.c|911| <<rds_ib_send_ack>> rds_conn_drop(ic->conn, DR_IB_SEND_ACK_FAIL);
+ *   - net/rds/ib_recv.c|1107| <<rds_ib_process_recv>> rds_conn_drop(conn, DR_IB_HEADER_MISSING);
+ *   - net/rds/ib_recv.c|1118| <<rds_ib_process_recv>> rds_conn_drop(conn, DR_IB_HEADER_CORRUPTED);
+ *   - net/rds/ib_recv.c|1184| <<rds_ib_process_recv>> rds_conn_drop(conn, DR_IB_FRAG_HEADER_MISMATCH);
+ *   - net/rds/ib_recv.c|1387| <<rds_ib_recv_cqe_handler>> rds_conn_drop(conn, DR_IB_RECV_COMP_ERR);
+ *   - net/rds/ib_send.c|397| <<rds_ib_send_cqe_handler>> rds_conn_drop(conn, DR_IB_SEND_COMP_ERR);
+ *   - net/rds/ib_send.c|877| <<rds_ib_xmit>> rds_conn_drop(ic->conn, DR_IB_POST_SEND_FAIL);
+ *   - net/rds/rdma_transport.c|211| <<rds_rdma_cm_event_handler_cmn>> rds_conn_drop(conn, DR_IB_RESOLVE_ROUTE_FAIL);
+ *   - net/rds/rdma_transport.c|244| <<rds_rdma_cm_event_handler_cmn>> rds_conn_drop(conn, DR_IB_RDMA_CM_ID_MISMATCH);
+ *   - net/rds/rdma_transport.c|257| <<rds_rdma_cm_event_handler_cmn>> rds_conn_drop(conn, DR_IB_ROUTE_ERR);
+ *   - net/rds/rdma_transport.c|273| <<rds_rdma_cm_event_handler_cmn>> rds_conn_drop(conn, DR_IB_ADDR_ERR);
+ *   - net/rds/rdma_transport.c|287| <<rds_rdma_cm_event_handler_cmn>> rds_conn_drop(conn, DR_IB_CONNECT_ERR);
+ *   - net/rds/rdma_transport.c|313| <<rds_rdma_cm_event_handler_cmn>> rds_conn_drop(conn, DR_IB_CONSUMER_DEFINED_REJ);
+ *   - net/rds/rdma_transport.c|332| <<rds_rdma_cm_event_handler_cmn>> rds_conn_drop(conn, DR_IB_REJECTED_EVENT);
+ *   - net/rds/rdma_transport.c|348| <<rds_rdma_cm_event_handler_cmn>> rds_conn_drop(conn, DR_IB_ADDR_CHANGE);
+ *   - net/rds/rdma_transport.c|360| <<rds_rdma_cm_event_handler_cmn>> rds_conn_drop(conn, DR_IB_DISCONNECTED_EVENT);
+ 32 net/rds/rdma_transport.c|367| <<rds_rdma_cm_event_handler_cmn>> rds_conn_drop(conn, DR_IB_TIMEWAIT_EXIT);
+ */
 void rds_conn_drop(struct rds_connection *conn, int reason)
 {
 	WARN_ON(conn->c_trans->t_mp_capable);
diff --git a/net/rds/ib.c b/net/rds/ib.c
index e34f19ced7f2..b967f497da72 100644
--- a/net/rds/ib.c
+++ b/net/rds/ib.c
@@ -1318,6 +1318,16 @@ void rds_ib_exit(void)
 	}
 }
 
+/*
+ * 在以下使用rds_ib_transport:
+ *   - net/rds/ib.c|761| <<rds_ib_conn_info_visitor>> if (conn->c_trans != &rds_ib_transport)
+ *   - net/rds/ib.c|815| <<rds6_ib_conn_info_visitor>> if (conn->c_trans != &rds_ib_transport)
+ *   - net/rds/ib.c|1221| <<rds_ib_init>> ret = rds_trans_register(&rds_ib_transport);
+ *   - net/rds/ib.c|1263| <<rds_ib_exit>> rds_trans_unregister(&rds_ib_transport);
+ *   - net/rds/ib.c|1307| <<rds_ib_exit>> WARN_ON(atomic_read(&rds_ib_transport.t_conn_count));
+ *   - net/rds/ib_cm.c|1433| <<rds_ib_cm_handle_connect>> &rds_ib_transport, dp_cmn->ricpc_tos,
+ *   - net/rds/rdma_transport.c|106| <<rds_rdma_cm_event_handler_cmn>> struct rds_transport *trans = &rds_ib_transport;
+ */
 struct rds_transport rds_ib_transport = {
 	.laddr_check		= rds_ib_laddr_check,
 	.xmit_path_complete	= rds_ib_xmit_path_complete,
diff --git a/net/rds/ib.h b/net/rds/ib.h
index eef1fd91f686..9a4321a746c8 100644
--- a/net/rds/ib.h
+++ b/net/rds/ib.h
@@ -201,6 +201,15 @@ struct rds_ib_connection {
 	struct rds_connection	*conn;
 
 	/* alphabet soup, IBTA style */
+	/*
+	 * 在以下设置rds_ib_connection->i_cm_id:
+	 *   - net/rds/ib_cm.c|1562| <<rds_ib_cm_handle_connect>> ic->i_cm_id = cm_id;
+	 *   - net/rds/ib_cm.c|1726| <<rds_ib_conn_path_connect>> ic->i_cm_id = rds_ib_rdma_create_id(rds_conn_net(conn),
+	 *   - net/rds/ib_cm.c|1731| <<rds_ib_conn_path_connect>> ic->i_cm_id = NULL;
+	 *   - net/rds/ib_cm.c|1777| <<rds_ib_conn_path_connect>> ic->i_cm_id = NULL;
+	 *   - net/rds/ib_cm.c|1857| <<rds_ib_conn_path_shutdown>> ic->i_cm_id = NULL;
+	 *   - net/rds/rdma_transport.c|210| <<rds_rdma_cm_event_handler_cmn>> ibic->i_cm_id = NULL;
+	 */
 	struct rdma_cm_id	*i_cm_id;
 	struct rds_connection	*i_cm_id_ctx;
 	struct ib_pd		*i_pd;
@@ -284,6 +293,12 @@ struct rds_ib_connection {
 	struct completion       i_last_wqe_complete;
 
 	/* Active Bonding */
+	/*
+	 * 在以下使用rds_ib_connection->i_active_side:
+	 *   - net/rds/ib_cm.c|336| <<rds_ib_cm_connect_complete>> ic->i_active_side ? "Active " : "Passive",
+	 *   - net/rds/ib_cm.c|1699| <<rds_ib_cm_initiate_connect>> ic->i_active_side = 1;
+	 *   - net/rds/ib_cm.c|1902| <<rds_ib_conn_path_shutdown>> ic->i_active_side = 0;
+	 */
 	unsigned int		i_active_side;
 
 	int			i_scq_vector;
@@ -304,6 +319,12 @@ struct rds_ib_connection {
 	struct rds_ib_device	*i_saved_rds_ibdev;
 
 	/* qp number info */
+	/*
+	 * 在以下使用rds_ib_connection->i_qp_num:
+	 *   - net/rds/ib.c|791| <<rds_ib_conn_info_visitor>> iinfo->qp_num = ic->i_qp_num;
+	 *   - net/rds/ib.c|842| <<rds6_ib_conn_info_visitor>> iinfo6->qp_num = ic->i_qp_num;
+	 *   - net/rds/ib_cm.c|379| <<rds_ib_cm_connect_complete>> ic->i_qp_num = ic->i_cm_id->qp->qp_num;
+	 */
 	s32			i_qp_num;
 	s32			i_dst_qp_num;
 };
diff --git a/net/rds/ib_cm.c b/net/rds/ib_cm.c
index 952d65a77e91..c1dab8986748 100644
--- a/net/rds/ib_cm.c
+++ b/net/rds/ib_cm.c
@@ -261,6 +261,20 @@ static int rds_ib_match_acl(struct rdma_cm_id *cm_id,
  * Connection established.
  * We get here for both outgoing and incoming connection.
  */
+/*
+ * [0] rds_ib_cm_connect_complete
+ * [0] rds_rdma_cm_event_handler
+ * [0] cma_ib_handler
+ * [0] cm_process_work
+ * [0] cm_rep_handler
+ * [0] cm_work_handler
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct rds_transport rds_ib_transport.cm_connect_complete = rds_ib_cm_connect_complete()
+ */
 void rds_ib_cm_connect_complete(struct rds_connection *conn, struct rdma_cm_event *event)
 {
 	struct rds_ib_connection *ic = conn->c_transport_data;
@@ -315,6 +329,14 @@ void rds_ib_cm_connect_complete(struct rds_connection *conn, struct rdma_cm_even
 		}
 	}
 
+	/*
+	 * 在以下使用rds_ib_connection->i_active_side:
+	 *   - net/rds/ib_cm.c|336| <<rds_ib_cm_connect_complete>> ic->i_active_side ? "Active " : "Passive",
+	 *   - net/rds/ib_cm.c|1699| <<rds_ib_cm_initiate_connect>> ic->i_active_side = 1;
+	 *   - net/rds/ib_cm.c|1902| <<rds_ib_conn_path_shutdown>> ic->i_active_side = 0;
+	 *
+	 * RDS/IB: Active  conn 00000000c0404405 i_cm_id 000000002e971272, frag 16KB, connected <::ffff:100.100.231.248,::ffff:100.100.231.251,0> version 4.1
+	 */
 	printk(KERN_NOTICE "RDS/IB: %s conn %p i_cm_id %p, frag %dKB, connected <%pI6c,%pI6c,%d> version %u.%u%s%s\n",
 	       ic->i_active_side ? "Active " : "Passive",
 	       conn, ic->i_cm_id, ic->i_frag_sz / SZ_1K,
@@ -535,6 +557,11 @@ static void poll_scq(struct rds_ib_connection *ic, struct ib_cq *cq,
 	}
 }
 
+/*
+ * called by:
+ *   - net/rds/ib_cm.c|638| <<rds_ib_rx>> poll_rcq(ic, ic->i_rcq, ic->i_recv_wc, &ack_state);
+ *   - net/rds/ib_cm.c|640| <<rds_ib_rx>> poll_rcq(ic, ic->i_rcq, ic->i_recv_wc, &ack_state);
+ */
 static void poll_rcq(struct rds_ib_connection *ic, struct ib_cq *cq,
 		     struct ib_wc *wcs,
 		     struct rds_ib_ack_state *ack_state)
@@ -599,6 +626,24 @@ void rds_ib_tasklet_fn_send(unsigned long data)
  * routines that reach into rds_rdma_free_op()
  * where irqs_disabled() warning is asserted!
  */
+/*
+ * 一个例子:
+ * [0] rds_ib_rx
+ * [0] tasklet_action_common.isra.18
+ * [0] tasklet_action
+ * [0] __do_softirq
+ * [0] irq_exit
+ * [0] do_IRQ
+ * [0] ret_from_intr
+ * [0] native_safe_halt
+ * [0] default_idle
+ * [0] arch_cpu_idle
+ * [0] default_idle_call
+ * [0] do_idle
+ * [0] cpu_startup_entry
+ * [0] start_secondary
+ * [0] secondary_startup_64
+ */
 static void rds_ib_rx(struct rds_ib_connection *ic)
 {
 	struct rds_connection *conn = ic->conn;
@@ -987,6 +1032,20 @@ static void __rds_rdma_conn_dev_rele(struct rds_ib_connection *ic)
  * This needs to be very careful to not leave IS_ERR pointers around for
  * cleanup to trip over.
  */
+/*
+ * [0] rds_ib_setup_qp
+ * [0] rds_rdma_cm_event_handler_cmn
+ * [0] rds_rdma_cm_event_handler
+ * [0] cma_work_handler
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * called by:
+ *   - net/rds/ib_cm.c|1549| <<rds_ib_cm_handle_connect>> err = rds_ib_setup_qp(conn);
+ *   - net/rds/ib_cm.c|1653| <<rds_ib_cm_initiate_connect>> ret = rds_ib_setup_qp(conn);
+ */
 static int rds_ib_setup_qp(struct rds_connection *conn)
 {
 	struct rds_ib_connection *ic = conn->c_transport_data;
@@ -1595,6 +1654,17 @@ void rds_ib_conn_destroy_init(struct rds_connection *conn)
 	queue_delayed_work(rds_aux_wq, &work->work, 0);
 }
 
+/*
+ * [0] rds_ib_cm_initiate_connect
+ * [0] rds_rdma_cm_event_handler
+ * [0] cma_work_handler
+ * [0] process_one_work
+ * [0] worker_thread
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * struct rds_transport rds_ib_transport.cm_initiate_connect = rds_ib_cm_initiate_connect()
+ */
 int rds_ib_cm_initiate_connect(struct rdma_cm_id *cm_id, bool isv6)
 {
 	struct rds_connection *conn = rds_ib_get_conn(cm_id);
@@ -1755,6 +1825,12 @@ int rds_ib_conn_path_connect(struct rds_conn_path *cp)
  * so that it can be called at any point during startup.  In fact it
  * can be called multiple times for a given connection.
  */
+/*
+ * called by:
+ *   - net/rds/connection.c|547| <<rds_conn_shutdown>> conn->c_trans->conn_path_shutdown(cp);
+ *
+ * struct rds_transport rds_ib_transport.conn_path_shutdown = rds_ib_conn_path_shutdown()
+ */
 void rds_ib_conn_path_shutdown(struct rds_conn_path *cp)
 {
 	struct rds_connection *conn = cp->cp_conn;
@@ -1871,12 +1947,27 @@ void rds_ib_conn_path_shutdown(struct rds_conn_path *cp)
 	ic->i_active_side = 0;
 }
 
+/*
+ * [0] rds_ib_conn_alloc
+ * [0] rds_conn_create_outgoing
+ * [0] rds_sendmsg
+ * [0] sock_sendmsg
+ * [0] ____sys_sendmsg
+ * [0] ___sys_sendmsg
+ * [0] __sys_sendmsg
+ * [0] __x64_sys_sendmsg
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ */
 int rds_ib_conn_alloc(struct rds_connection *conn, gfp_t gfp)
 {
 	struct rds_ib_connection *ic;
 	unsigned long flags;
 
 	/* XXX too lazy? */
+	/*
+	 * !!! 这里分配的rds_ib_connection !!!
+	 */
 	ic = kzalloc(sizeof(struct rds_ib_connection), gfp);
 	if (!ic)
 		return -ENOMEM;
@@ -1906,6 +1997,9 @@ int rds_ib_conn_alloc(struct rds_connection *conn, gfp_t gfp)
 	rds_ib_init_ic_frag(ic);
 
 	ic->conn = conn;
+	/*
+	 * struct rds_ib_connection *ic;
+	 */
 	conn->c_transport_data = ic;
 
 	init_completion(&ic->i_last_wqe_complete);
diff --git a/net/rds/ib_rdma.c b/net/rds/ib_rdma.c
index 9fd03928a783..d155b66df109 100644
--- a/net/rds/ib_rdma.c
+++ b/net/rds/ib_rdma.c
@@ -1582,6 +1582,10 @@ void rds_ib_fcq_handler(struct rds_ib_device *rds_ibdev, struct ib_wc *wc)
 	complete(&ibmr->wr_comp);
 }
 
+/*
+ * called by:
+ *   - net/rds/ib_cm.c|555| <<poll_scq>> rds_ib_mr_cqe_handler(ic, wc);
+ */
 void rds_ib_mr_cqe_handler(struct rds_ib_connection *ic, struct ib_wc *wc)
 {
 	struct rds_ib_mr *ibmr;
diff --git a/net/rds/ib_recv.c b/net/rds/ib_recv.c
index 107880943691..9da80df68666 100644
--- a/net/rds/ib_recv.c
+++ b/net/rds/ib_recv.c
@@ -1086,6 +1086,10 @@ static void rds_ib_cong_recv(struct rds_connection *conn,
 	rds_cong_map_updated(map, uncongested);
 }
 
+/*
+ * called by:
+ *   - net/rds/ib_recv.c|1341| <<rds_ib_recv_cqe_handler>> rds_ib_process_recv(conn, recv, wc->byte_len, state);
+ */
 static void rds_ib_process_recv(struct rds_connection *conn,
 				struct rds_ib_recv_work *recv, u32 data_len,
 				struct rds_ib_ack_state *state)
@@ -1305,6 +1309,37 @@ void rds_ib_srq_process_recv(struct rds_connection *conn,
 	}
 }
 
+/*
+ * 两个用的多的例子
+ * [0] rds_ib_recv_cqe_handler
+ * [0] rds_ib_rx
+ * [0] rds_ib_tasklet_fn_recv
+ * [0] tasklet_action_common.isra.18
+ * [0] tasklet_action
+ * [0] __do_softirq
+ * [0] run_ksoftirqd
+ * [0] smpboot_thread_fn
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] rds_ib_recv_cqe_handler
+ * [0] rds_ib_rx
+ * [0] rds_ib_tasklet_fn_recv
+ * [0] tasklet_action_common.isra.18
+ * [0] tasklet_action
+ * [0] __do_softirq
+ * [0] irq_exit
+ * [0] do_IRQ
+ * [0] ret_from_intr
+ * [0] native_safe_halt
+ * [0] default_idle
+ * [0] arch_cpu_idle
+ * [0] default_idle_call
+ * [0] do_idle
+ * [0] cpu_startup_entry
+ * [0] start_secondary
+ * [0] secondary_startup_64
+ */
 void rds_ib_recv_cqe_handler(struct rds_ib_connection *ic,
 			     struct ib_wc *wc,
 			     struct rds_ib_ack_state *state)
@@ -1494,6 +1529,9 @@ static void rds_ib_srq_clear_ring(struct rds_ib_device *rds_ibdev)
 }
 
 
+/*
+ * struct rds_transport rds_ib_transport.recv_path = rds_ib_recv_path()
+ */
 int rds_ib_recv_path(struct rds_conn_path *cp)
 {
 	struct rds_connection *conn = cp->cp_conn;
@@ -1510,6 +1548,10 @@ int rds_ib_recv_path(struct rds_conn_path *cp)
 	return ret;
 }
 
+/*
+ * called by:
+ *   - net/rds/ib.c|1210| <<rds_ib_init>> ret = rds_ib_recv_init();
+ */
 int rds_ib_recv_init(void)
 {
 	struct sysinfo si;
@@ -1585,6 +1627,10 @@ static void rds_ib_srq_event(struct ib_event *event,
 }
 
 /* Setup SRQ for a device */
+/*
+ * called by:
+ *   - net/rds/ib.c|1149| <<rds_ib_add_one>> if (rds_ib_srq_init(rds_ibdev))
+ */
 int rds_ib_srq_init(struct rds_ib_device *rds_ibdev)
 {
 	struct ib_srq_init_attr srq_init_attr = {
diff --git a/net/rds/ib_ring.c b/net/rds/ib_ring.c
index b66cd4244d30..81d0b0ede0b1 100644
--- a/net/rds/ib_ring.c
+++ b/net/rds/ib_ring.c
@@ -93,6 +93,15 @@ static int __rds_ib_ring_empty(struct rds_ib_work_ring *ring)
 	return __rds_ib_ring_used(ring) == 0;
 }
 
+/*
+ * called by:
+ *   - net/rds/ib_recv.c|581| <<rds_ib_recv_refill>> && rds_ib_ring_alloc(&ic->i_recv_ring, 1, &pos)) {
+ *   - net/rds/ib_send.c|602| <<rds_ib_xmit>> work_alloc = rds_ib_ring_alloc(&ic->i_send_ring, i, &pos);
+ *   - net/rds/ib_send.c|610| <<rds_ib_xmit>> work_alloc = rds_ib_ring_alloc(&ic->i_send_ring, i, &pos);
+ *   - net/rds/ib_send.c|877| <<rds_ib_xmit_atomic>> work_alloc = rds_ib_ring_alloc(&ic->i_send_ring, 1, &pos);
+ *   - net/rds/ib_send.c|993| <<rds_ib_xmit_rdma>> work_alloc = rds_ib_ring_alloc(&ic->i_send_ring, i, &pos);
+ *   - net/rds/ib_send.c|1060| <<rds_ib_xmit_rdma>> rcomp_alloc = rds_ib_ring_alloc(&ic->i_send_ring, 1,
+ */
 u32 rds_ib_ring_alloc(struct rds_ib_work_ring *ring, u32 val, u32 *pos)
 {
 	u32 ret = 0, avail;
@@ -153,6 +162,10 @@ u32 rds_ib_ring_oldest(struct rds_ib_work_ring *ring)
  * returns the number of completed work requests.
  */
 
+/*
+ * called by:
+ *   - net/rds/ib_send.c|313| <<rds_ib_send_cqe_handler>> completed = rds_ib_ring_completed(&ic->i_send_ring, wc->wr_id, oldest);
+ */
 u32 rds_ib_ring_completed(struct rds_ib_work_ring *ring, u32 wr_id, u32 oldest)
 {
 	u32 ret;
diff --git a/net/rds/ib_send.c b/net/rds/ib_send.c
index 78d376b0d234..465e5b4b51fe 100644
--- a/net/rds/ib_send.c
+++ b/net/rds/ib_send.c
@@ -284,6 +284,28 @@ static void rds_ib_sub_signaled(struct rds_ib_connection *ic, int nr)
  * unallocs the next free entry in the ring it doesn't alter which is
  * the next to be freed, which is what this is concerned with.
  */
+/*
+ * 一个例子
+ * [0] rds_ib_send_cqe_handler
+ * [0] rds_ib_tasklet_fn_send
+ * [0] tasklet_action_common.isra.18
+ * [0] tasklet_action
+ * [0] __do_softirq
+ * [0] irq_exit
+ * [0] do_IRQ
+ * [0] ret_from_intr
+ * [0] native_safe_halt
+ * [0] default_idle
+ * [0] arch_cpu_idle
+ * [0] default_idle_call
+ * [0] do_idle
+ * [0] cpu_startup_entry
+ * [0] start_secondary
+ * [0] secondary_startup_64
+ *
+ * called by:
+ *   - net/rds/ib_cm.c|553| <<poll_scq>> rds_ib_send_cqe_handler(ic, wc);
+ */
 void rds_ib_send_cqe_handler(struct rds_ib_connection *ic, struct ib_wc *wc)
 {
 	struct rds_connection *conn = ic->conn;
@@ -561,6 +583,9 @@ static inline int rds_ib_set_wr_signal_state(struct rds_ib_connection *ic,
  * per connection.  This makes sure that the tx ring alloc/unalloc pairs
  * don't get out of sync and confuse the ring.
  */
+/*
+ * struct rds_transport rds_ib_transport.xmit = rds_ib_xmit()
+ */
 int rds_ib_xmit(struct rds_connection *conn, struct rds_message *rm,
 		unsigned int hdr_off, unsigned int sg, unsigned int off)
 {
@@ -946,6 +971,9 @@ int rds_ib_xmit_atomic(struct rds_connection *conn, struct rm_atomic_op *op)
 	return ret;
 }
 
+/*
+ * struct rds_transport rds_ib_transport.xmit_rdma = rds_ib_xmit_rdma()
+ */
 int rds_ib_xmit_rdma(struct rds_connection *conn, struct rm_rdma_op *op)
 {
 	struct rds_ib_connection *ic = conn->c_transport_data;
@@ -1003,6 +1031,9 @@ int rds_ib_xmit_rdma(struct rds_connection *conn, struct rm_rdma_op *op)
 	num_sge = op->op_count;
 
 	for (i = 0; i < work_alloc && scat != &op->op_sg[op->op_count]; i++) {
+		/*
+		 * struct rds_ib_send_work *send
+		 */
 		send->s_wr.send_flags = 0;
 		send->s_queued = jiffies;
 		send->s_op = NULL;
@@ -1091,6 +1122,19 @@ int rds_ib_xmit_rdma(struct rds_connection *conn, struct rm_rdma_op *op)
 		atomic_add(nr_sig, &ic->i_signaled_sends);
 
 	failed_wr = &first->s_wr;
+	/*
+	 * 在以下设置rds_ib_connection->i_cm_id:
+	 *   - net/rds/ib_cm.c|1562| <<rds_ib_cm_handle_connect>> ic->i_cm_id = cm_id;
+	 *   - net/rds/ib_cm.c|1726| <<rds_ib_conn_path_connect>> ic->i_cm_id = rds_ib_rdma_create_id(rds_conn_net(conn),
+	 *   - net/rds/ib_cm.c|1731| <<rds_ib_conn_path_connect>> ic->i_cm_id = NULL;
+	 *   - net/rds/ib_cm.c|1777| <<rds_ib_conn_path_connect>> ic->i_cm_id = NULL;
+	 *   - net/rds/ib_cm.c|1857| <<rds_ib_conn_path_shutdown>> ic->i_cm_id = NULL;
+	 *   - net/rds/rdma_transport.c|210| <<rds_rdma_cm_event_handler_cmn>> ibic->i_cm_id = NULL;
+	 *
+	 * struct rds_ib_connection:
+	 *  -> struct rdma_cm_id *i_cm_id;
+	 *      -> struct ib_qp *qp;
+	 */
 	ret = ib_post_send(ic->i_cm_id->qp, &first->s_wr, &failed_wr);
 	rdsdebug("ic %p first %p (wr %p) ret %d wr %p\n", ic,
 		 first, &first->s_wr, ret, failed_wr);
diff --git a/net/rds/ib_stats.c b/net/rds/ib_stats.c
index 0c0e6a31af55..2fbbb89a4f9a 100644
--- a/net/rds/ib_stats.c
+++ b/net/rds/ib_stats.c
@@ -97,6 +97,9 @@ static char *rds_ib_stat_names[] = {
 	"ib_recv_nmb_cache_removed",
 };
 
+/*
+ * struct rds_transport rds_ib_transport.stats_info_copy = rds_ib_stats_info_copy()
+ */
 unsigned int rds_ib_stats_info_copy(struct rds_info_iterator *iter,
 				    unsigned int avail)
 {
diff --git a/net/rds/info.c b/net/rds/info.c
index 8f810439f29d..d7ef2132007b 100644
--- a/net/rds/info.c
+++ b/net/rds/info.c
@@ -153,6 +153,10 @@ EXPORT_SYMBOL_GPL(rds_info_copy);
  * On success it returns the positive number of bytes of each array element
  * in the snapshot.
  */
+/*
+ * called by:
+ *   - net/rds/af_rds.c|704| <<rds_getsockopt>> ret = rds_info_getsockopt(sock, optname, optval,
+ */
 int rds_info_getsockopt(struct socket *sock, int optname, char __user *optval,
 			int __user *optlen)
 {
diff --git a/net/rds/rdma.c b/net/rds/rdma.c
index 2ac87c5a4cce..945eee5fde50 100644
--- a/net/rds/rdma.c
+++ b/net/rds/rdma.c
@@ -154,6 +154,12 @@ EXPORT_SYMBOL_GPL(rds_rdma_drop_keys);
 /*
  * Helper function to pin user pages.
  */
+/*
+ * called by:
+ *   - net/rds/rdma.c|254| <<__rds_rdma_map>> ret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);
+ *   - net/rds/rdma.c|656| <<rds_cmsg_rdma_args>> ret = rds_pin_pages(vec.addr, nr, pages, !op->op_write);
+ *   - net/rds/rdma.c|829| <<rds_cmsg_atomic>> ret = rds_pin_pages(args->local_addr, 1, &page, 1);
+ */
 static int rds_pin_pages(unsigned long user_addr, unsigned int nr_pages,
 			struct page **pages, int write)
 {
diff --git a/net/rds/rdma_transport.c b/net/rds/rdma_transport.c
index adcb7f2e9940..e8a6fa175c89 100644
--- a/net/rds/rdma_transport.c
+++ b/net/rds/rdma_transport.c
@@ -383,6 +383,12 @@ static int rds_rdma_cm_event_handler_cmn(struct rdma_cm_id *cm_id,
 	return ret;
 }
 
+/*
+ * called by:
+ *   - net/rds/ib.c|927| <<rds_ib_laddr_check_cm>> cm_id = rds_ib_rdma_create_id(net, rds_rdma_cm_event_handler, &dummy_ic,
+ *   - net/rds/ib_cm.c|1723| <<rds_ib_conn_path_connect>> handler = rds_rdma_cm_event_handler;
+ *   - net/rds/rdma_transport.c|467| <<rds_rdma_listen_init>> ret = rds_rdma_listen_init_common(rds_rdma_cm_event_handler,
+ */
 int rds_rdma_cm_event_handler(struct rdma_cm_id *cm_id,
 			      struct rdma_cm_event *event)
 {
diff --git a/net/rds/rds.h b/net/rds/rds.h
index 020f94bd7f71..1383d0fa30a9 100644
--- a/net/rds/rds.h
+++ b/net/rds/rds.h
@@ -92,6 +92,15 @@ enum {
 	RDS_RTD_TCP			= 1 << 28,	/* 0x10000000 */
 };
 
+/*
+ * # echo "ibase=2;111111111111" | bc > /sys/module/rds/parameters/rds_rt_debug_bitmap
+ *
+ * # echo "ibase=2;100000001011" | bc > /sys/module/rds/parameters/rds_rt_debug_bitmap
+ *
+ * # echo "ibase=2;000000000000" | bc > /sys/module/rds/parameters/rds_rt_debug_bitmap
+ *
+ * # echo "ibase=2;11111111111111111111" | bc > /sys/module/rds/parameters/rds_rt_debug_bitmap
+ */
 #define rds_rtd(enabling_bit, format, arg...)				     \
 	do { if (likely(!(enabling_bit & kernel_rds_rt_debug_bitmap))) break;\
 		trace_printk("%d: " format, __LINE__, ## arg);		     \
@@ -814,6 +823,12 @@ struct rds_sock {
 	 * around. This helps avoid costly lookups.
 	 */
 	struct rds_connection	*rs_conn;
+	/*
+	 * 在以下使用rds_sock->rs_conn_path:
+	 *   - net/rds/af_rds.c|988| <<__rds_create>> rs->rs_conn_path = NULL;
+	 *   - net/rds/send.c|1493| <<rds_sendmsg>> cpath = rs->rs_conn_path;
+	 *   - net/rds/send.c|1525| <<rds_sendmsg>> rs->rs_conn_path = cpath;
+	 */
 	struct rds_conn_path	*rs_conn_path;
 
 	/* flag indicating we were congested or not */
@@ -840,9 +855,24 @@ struct rds_sock {
 	 * newline
 	 */
 	spinlock_t		rs_snd_lock;
+	/*
+	 * 在以下使用rds_sock->rs_send_queue:
+	 *   - net/rds/af_rds.c|960| <<__rds_create>> INIT_LIST_HEAD(&rs->rs_send_queue);
+	 *   - net/rds/send.c|961| <<rds_send_drop_to>> list_for_each_entry_safe(rm, tmp, &rs->rs_send_queue, m_sock_item) {
+	 *   - net/rds/send.c|1090| <<rds_send_queue_rm>> list_add_tail(&rm->m_sock_item, &rs->rs_send_queue);
+	 */
 	struct list_head	rs_send_queue;
 	u32			rs_snd_bytes; /* Total bytes to all peers */
 	u32			rs_buf_info_dest_cnt;
+	/*
+	 * 在以下使用rds_sock->rs_buf_info_tbl:
+	 *   - net/rds/af_rds.c|128| <<rds_release>> rhashtable_free_and_destroy(&rs->rs_buf_info_tbl, rds_buf_info_free,
+	 *   - net/rds/af_rds.c|753| <<rds_add_buf_info>> info = rhashtable_lookup_fast(&rs->rs_buf_info_tbl, addr,
+	 *   - net/rds/af_rds.c|780| <<rds_add_buf_info>> *ret = rhashtable_insert_fast(&rs->rs_buf_info_tbl,
+	 *   - net/rds/af_rds.c|796| <<rds_add_buf_info>> info = rhashtable_lookup_fast(&rs->rs_buf_info_tbl, addr,
+	 *   - net/rds/af_rds.c|974| <<__rds_create>> ret = rhashtable_init(&rs->rs_buf_info_tbl, &rs_buf_info_params);
+	 *   - net/rds/rds.h|975| <<rds_get_buf_info>> return rhashtable_lookup_fast(&rs->rs_buf_info_tbl, addr,
+	 */
 	struct rhashtable	rs_buf_info_tbl;
 
 	/*
diff --git a/net/rds/recv.c b/net/rds/recv.c
index 24d8920aa863..8a8703f1071c 100644
--- a/net/rds/recv.c
+++ b/net/rds/recv.c
@@ -344,6 +344,50 @@ static void rds_start_mprds(struct rds_connection *conn)
  * conn.  This lets loopback, who only has one conn for both directions,
  * tell us which roles the addrs in the conn are playing for this message.
  */
+/*
+ * 代表的两个例子
+ *
+ * [0] rds_recv_incoming
+ * [0] poll_rcq
+ * [0] rds_ib_rx
+ * [0] rds_ib_tasklet_fn_recv
+ * [0] tasklet_action_common.isra.18
+ * [0] tasklet_action
+ * [0] __do_softirq
+ * [0] run_ksoftirqd
+ * [0] smpboot_thread_fn
+ * [0] kthread
+ * [0] ret_from_fork
+ *
+ * [0] rds_recv_incoming
+ * [0] poll_rcq
+ * [0] rds_ib_rx
+ * [0] rds_ib_tasklet_fn_recv
+ * [0] tasklet_action_common.isra.18
+ * [0] tasklet_action
+ * [0] __do_softirq
+ * [0] irq_exit
+ * [0] do_IRQ
+ * [0] ret_from_intr
+ * [0] native_safe_halt
+ * [0] default_idle
+ * [0] arch_cpu_idle
+ * [0] default_idle_call
+ * [0] do_idle
+ * [0] cpu_startup_entry
+ * [0] rest_init
+ * [0] arch_call_rest_init
+ * [0] start_kernel
+ * [0] x86_64_start_reservations
+ * [0] x86_64_start_kernel
+ * [0] secondary_startup_64
+ *
+ * called by:
+ *   - net/rds/ib_recv.c|1201| <<rds_ib_process_recv>> rds_recv_incoming(conn, &conn->c_faddr, &conn->c_laddr,
+ *   - net/rds/ib_recv.c|1298| <<rds_ib_srq_process_recv>> rds_recv_incoming(conn, &conn->c_faddr, &conn->c_laddr,
+ *   - net/rds/loop.c|85| <<rds_loop_xmit>> rds_recv_incoming(conn, &conn->c_laddr, &conn->c_faddr, &rm->m_inc,
+ *   - net/rds/tcp_recv.c|243| <<rds_tcp_data_recv>> rds_recv_incoming(conn, &conn->c_faddr,
+ */
 void rds_recv_incoming(struct rds_connection *conn, struct in6_addr *saddr,
 		       struct in6_addr *daddr,
 		       struct rds_incoming *inc, gfp_t gfp)
@@ -614,6 +658,15 @@ rds_recv_forward(struct rds_conn_path *cp, struct rds_incoming *inc,
 		       inc, gfp, NULL);
 }
 
+/*
+ * called by:
+ *   - net/rds/recv.c|380| <<rds_recv_incoming>> rds_recv_local(cp, saddr, daddr, inc, gfp, rs);
+ *   - net/rds/recv.c|399| <<rds_recv_incoming>> rds_recv_local(cp, saddr, daddr, inc, gfp, rs);
+ *   - net/rds/recv.c|467| <<rds_recv_incoming>> rds_recv_local(cp, saddr, daddr, inc, gfp, NULL);
+ *   - net/rds/recv.c|476| <<rds_recv_incoming>> rds_recv_local(cp, saddr, daddr, inc, gfp, NULL);
+ *   - net/rds/recv.c|543| <<rds_recv_route>> rds_recv_local(&nconn->c_path[0],
+ *   - net/rds/recv.c|613| <<rds_recv_forward>> rds_recv_local(&inc->i_oconn->c_path[0], &org->saddr, &org->daddr,
+ */
 static void
 rds_recv_local(struct rds_conn_path *cp, struct in6_addr *saddr,
 	       struct in6_addr *daddr, struct rds_incoming *inc, gfp_t gfp,
@@ -984,6 +1037,15 @@ static int rds_cmsg_recv(struct rds_incoming *inc, struct msghdr *msg,
 	return ret;
 }
 
+/*
+ * [0] rds_recvmsg
+ * [0] ____sys_recvmsg
+ * [0] ___sys_recvmsg
+ * [0] __sys_recvmsg
+ * [0] __x64_sys_recvmsg
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ */
 int rds_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,
 		int msg_flags)
 {
diff --git a/net/rds/send.c b/net/rds/send.c
index 5f77c549043a..f91efa2f37df 100644
--- a/net/rds/send.c
+++ b/net/rds/send.c
@@ -182,8 +182,46 @@ static void release_in_xmit(struct rds_conn_path *cp)
  *      - small message latency is higher behind queued large messages
  *      - large message latency isn't starved by intervening small sends
  */
+/*
+ * [0] rds_send_xmit
+ * [0] sock_sendmsg
+ * [0] ____sys_sendmsg
+ * [0] ___sys_sendmsg
+ * [0] __sys_sendmsg
+ * [0] __x64_sys_sendmsg
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ *
+ * [0] rds_send_xmit
+ * [0] tasklet_action_common.isra.18
+ * [0] tasklet_action
+ * [0] __do_softirq
+ * [0] irq_exit
+ * [0] do_IRQ
+ * [0] ret_from_intr
+ * [0] native_safe_halt
+ * [0] default_idle
+ * [0] arch_cpu_idle
+ * [0] default_idle_call
+ * [0] do_idle
+ * [0] cpu_startup_entry
+ * [0] rest_init
+ * [0] arch_call_rest_init
+ * [0] start_kernel
+ * [0] x86_64_start_reservations
+ * [0] x86_64_start_kernel
+ * [0] secondary_startup_64
+ *
+ * called by:
+ *   - net/rds/ib_cm.c|593| <<rds_ib_tasklet_fn_send>> rds_send_xmit(&ic->conn->c_path[0]);
+ *   - net/rds/send.c|1613| <<rds_sendmsg>> ret = rds_send_xmit(cpath);
+ *   - net/rds/threads.c|285| <<rds_send_worker>> ret = rds_send_xmit(cp);
+ */
 int rds_send_xmit(struct rds_conn_path *cp)
 {
+	/*
+	 * 似乎一个connection可以有多个path
+	 */
 	struct rds_connection *conn = cp->cp_conn;
 	struct rds_message *rm;
 	unsigned long flags;
@@ -1017,6 +1055,12 @@ void rds_send_drop_to(struct rds_sock *rs, struct sockaddr_in6 *dest)
  * possible that another thread can race with us and remove the
  * message from the flow with RDS_CANCEL_SENT_TO.
  */
+/*
+ * called by:
+ *   - net/rds/send.c|1607| <<rds_sendmsg>> while (!rds_send_queue_rm(rs, conn, cpath, rm, rs->rs_bound_port,
+ *   - net/rds/send.c|1621| <<rds_sendmsg>> rds_send_queue_rm(rs, conn, cpath, rm,
+ *   - net/rds/send.c|1776| <<rds_send_internal>> if (!rds_send_queue_rm(rs, conn, &conn->c_path[0], rm,
+ */
 static int rds_send_queue_rm(struct rds_sock *rs, struct rds_connection *conn,
 			     struct rds_conn_path *cp,
 			     struct rds_message *rm, __be16 sport,
@@ -1235,6 +1279,17 @@ static int rds_send_mprds_hash(struct rds_sock *rs, struct rds_connection *conn)
 	return hash;
 }
 
+/*
+ * [0] rds_sendmsg
+ * [0] ____sys_sendmsg
+ * [0] ___sys_sendmsg
+ * [0] __sys_sendmsg
+ * [0] __x64_sys_sendmsg
+ * [0] do_syscall_64
+ * [0] entry_SYSCALL_64_after_hwframe
+ *
+ * struct proto_ops rds_proto_ops.sendmsg = rds_sendmsg()
+ */
 int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
 {
 	struct sock *sk = sock->sk;
@@ -1391,6 +1446,13 @@ int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
 		goto out;
 	}
 
+	/*
+	 * Check if there is a rs_buf_info associated with the given address.  If not,
+	 * add one to the rds_sock.  The found or added rs_buf_info is returned.  If
+	 * there is no rs_buf_info found and a new rs_buf_info cannot be allocated,
+	 * NULL is returned and ret is set to the error.  Once an address' rs_buf_info
+	 * is added, it will not be removed until the rs_sock is closed.
+	 */
 	bufi = rds_add_buf_info(rs, &daddr, &ret, GFP_KERNEL);
 	if (!bufi)
 		goto out;
@@ -1454,6 +1516,18 @@ int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
 		conn = rs->rs_conn;
 		cpath = rs->rs_conn_path;
 	} else {
+		/*
+		 * [0] rds_conn_create_outgoing
+		 * [0] sock_sendmsg
+		 * [0] ____sys_sendmsg
+		 * [0] ___sys_sendmsg
+		 * [0] __sys_sendmsg
+		 * [0] __x64_sys_sendmsg
+		 * [0] do_syscall_64
+		 * [0] entry_SYSCALL_64_after_hwframe
+		 *
+		 * 似乎两个ip之间就调用一次
+		 */
 		conn = rds_conn_create_outgoing(sock_net(sock->sk),
 						&rs->rs_bound_addr, &daddr,
 						rs->rs_transport, rs->rs_tos,
@@ -1463,6 +1537,10 @@ int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
 			ret = PTR_ERR(conn);
 			goto out;
 		}
+		/*
+		 * struct rds_connection:
+		 * -> struct rds_transport *c_trans;
+		 */
 		if (conn->c_trans->t_mp_capable) {
 			/* c_npaths == 0 if we have not talked to this peer
 			 * before.  Initiate a connection request to the
@@ -1484,9 +1562,18 @@ int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
 			cpath = &conn->c_path[0];
 		}
 		rs->rs_conn = conn;
+		/*
+		 * 在以下使用rds_sock->rs_conn_path:
+		 *   - net/rds/af_rds.c|988| <<__rds_create>> rs->rs_conn_path = NULL;
+		 *   - net/rds/send.c|1493| <<rds_sendmsg>> cpath = rs->rs_conn_path;
+		 *   - net/rds/send.c|1525| <<rds_sendmsg>> rs->rs_conn_path = cpath;
+		 */
 		rs->rs_conn_path = cpath;
 	}
 
+	/*
+	 * struct rds_message *rm = NULL;
+	 */
 	rm->m_conn_path = cpath;
 
 	/* Parse any control messages the user may have included. */
@@ -1580,6 +1667,9 @@ int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
 	if (!dport)
 		rds_stats_inc(s_send_ping);
 
+	/*
+	 * 发送的核心函数!!!
+	 */
 	ret = rds_send_xmit(cpath);
 	if (ret == -ENOMEM || ret == -EAGAIN)
 		rds_cond_queue_send_work(cpath, 1);
diff --git a/net/rds/threads.c b/net/rds/threads.c
index 0d3afb063ad3..32f3b794db94 100644
--- a/net/rds/threads.c
+++ b/net/rds/threads.c
@@ -396,6 +396,10 @@ void rds_reconnect_timeout(struct work_struct *work)
 	}
 }
 
+/*
+ * 在以下使用rds_shutdown_worker():
+ *   - net/rds/connection.c|223| <<__rds_conn_path_init>> INIT_WORK(&cp->cp_down_w, rds_shutdown_worker);
+ */
 void rds_shutdown_worker(struct work_struct *work)
 {
 	struct rds_conn_path *cp = container_of(work,
diff --git a/net/rds/transport.c b/net/rds/transport.c
index 5454ec07fba5..7efdfd01f1ac 100644
--- a/net/rds/transport.c
+++ b/net/rds/transport.c
@@ -47,6 +47,11 @@ static char * const rds_trans_modules[] = {
 static struct rds_transport *transports[RDS_TRANS_COUNT];
 static DECLARE_RWSEM(rds_trans_sem);
 
+/*
+ * called by:
+ *   - net/rds/ib.c|1221| <<rds_ib_init>> ret = rds_trans_register(&rds_ib_transport);
+ *   - net/rds/tcp.c|724| <<rds_tcp_init>> ret = rds_trans_register(&rds_tcp_transport);
+ */
 int rds_trans_register(struct rds_transport *trans)
 {
 	BUG_ON(strlen(trans->t_name) + 1 > TRANSNAMSIZ);
@@ -84,6 +89,11 @@ void rds_trans_put(struct rds_transport *trans)
 		module_put(trans->t_owner);
 }
 
+/*
+ * called by:
+ *   - net/rds/bind.c|285| <<rds_bind>> trans = rds_trans_get_preferred(sock_net(sock->sk),
+ *   - net/rds/connection.c|329| <<__rds_conn_create>> loop_trans = rds_trans_get_preferred(net, faddr, conn->c_dev_if);
+ */
 struct rds_transport *rds_trans_get_preferred(struct net *net,
 					      const struct in6_addr *addr,
 					      __u32 scope_id)
@@ -114,6 +124,10 @@ struct rds_transport *rds_trans_get_preferred(struct net *net,
 	return ret;
 }
 
+/*
+ * called by:
+ *   - net/rds/af_rds.c|574| <<rds_set_transport>> rs->rs_transport = rds_trans_get(t_type);
+ */
 struct rds_transport *rds_trans_get(int t_type)
 {
 	struct rds_transport *ret = NULL;
-- 
2.17.1

